<html>
<head>
<title>Parallel Programming in Python with Message Passing Interface (mpi4py)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用消息传递接口(mpi4py)的Python并行编程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/parallel-programming-in-python-with-message-passing-interface-mpi4py-551e3f198053?source=collection_archive---------8-----------------------#2020-06-25">https://towardsdatascience.com/parallel-programming-in-python-with-message-passing-interface-mpi4py-551e3f198053?source=collection_archive---------8-----------------------#2020-06-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="92cb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为超级计算机准备好您的代码。没那么难。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/56159355fe8ed7b4292be689436e6599.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*d3PMO5h1MzCSmRNF"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@carolran?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Carol Jeng </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="35a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您知道您可以编写并行Python代码，在您的笔记本电脑和超级计算机上运行吗？你可以，而且没有你想象的那么难。如果您已经为<a class="ae ky" rel="noopener" target="_blank" href="/asynchronous-parallel-programming-in-python-with-multiprocessing-a3fc882b4023">异步并行化</a>编写了代码，那么您甚至不需要进行太多的重构。</p><p id="b0ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">高性能计算(HPC)将任务分配到数千个CPU上(与笔记本电脑上的4–8个CPU形成对比),以实现显著的性能提升。CPU使用消息传递接口(MPI)进行通信和传递数据。当您编写代码将任务分配给多个内核同时运行时，在您的笔记本电脑上也使用了相同的原则。本文将演示如何使用MPI和Python来编写可以在您的笔记本电脑或超级计算机上并行运行的代码。</p><h2 id="9eaf" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">安装MPI</h2><p id="4739" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">您需要为您的操作系统安装一个MPI应用程序。对于Windows用户，我建议直接从微软安装MPI。对于Mac和Linux用户，我建议安装<a class="ae ky" href="https://www.open-mpi.org/software/ompi/v4.0/" rel="noopener ugc nofollow" target="_blank"> OpenMPI </a>。Windows用户必须将MPI安装目录添加到<a class="ae ky" href="https://www.java.com/en/download/help/path.xml" rel="noopener ugc nofollow" target="_blank">路径变量</a>。</p><p id="3869" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要测试您的安装，请在终端窗口中键入<code class="fe mt mu mv mw b">mpiexec</code> (Windows)或<code class="fe mt mu mv mw b">mpirun</code> (Mac/Linux，但请检查安装文档)，然后按“Enter”键。如果您已正确安装，这将生成一条包含使用信息的消息。当你在终端时，也输入<code class="fe mt mu mv mw b">python</code>并按下‘回车’。这应该会启动一个交互式Python会话。如果没有，您需要安装或配置Python。</p><h2 id="adeb" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">安装mpi4py</h2><p id="2424" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated"><code class="fe mt mu mv mw b">mpi4py</code>是一个Python模块，允许您与您的MPI应用程序进行交互(<code class="fe mt mu mv mw b">mpiexec</code>或<code class="fe mt mu mv mw b">mpirun</code>)。和任何Python模块(<code class="fe mt mu mv mw b">pip install mpi4py</code>等)一样安装。).</p><p id="d19d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦你安装了MPI和<code class="fe mt mu mv mw b">mpi4py</code>，你就可以开始了！</p><h2 id="0efc" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">一个基本例子</h2><p id="0c62" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">使用MPI运行Python脚本与您可能习惯的略有不同。使用<code class="fe mt mu mv mw b">mpiexec</code>和<code class="fe mt mu mv mw b">mpirun</code>，每一行代码将由每个处理器运行，除非另有说明。让我们制作一个“hello world”示例来演示MPI基础知识。</p><p id="ade3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建一个新的python脚本(<code class="fe mt mu mv mw b">.py</code>文件)。导入<code class="fe mt mu mv mw b">mpi4py</code>并使用<code class="fe mt mu mv mw b">MPI.COMM_WORLD</code>来获取关于所有可用于运行您的脚本的处理器的信息(当调用脚本时，这个数字被传递给MPI应用程序)。<code class="fe mt mu mv mw b">COMM_WORLD</code>访问可用于分配工作的进程数量(等级/处理器),以及关于每个处理器的信息。给出了为运行我们的脚本而分配的队列或处理器的总数。<code class="fe mt mu mv mw b">rank</code>给出当前执行代码的处理器的标识符。下面的<code class="fe mt mu mv mw b">print</code>语句将为作业中使用的每个处理器打印一次。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="15d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过打开终端，导航到包含该脚本的目录，并执行以下命令来执行该脚本:</p><pre class="kj kk kl km gt mz mw na nb aw nc bi"><span id="23fa" class="lv lw it mw b gy nd ne l nf ng">mpiexec -n 4 python mpi_hello_world.py</span></pre><p id="7085" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mt mu mv mw b">n -4</code>指定要使用的处理器数量。在这个实例中，我使用了4个处理器，这意味着print语句将执行4次。注意，等级不是按数字顺序打印出来的，所以您需要确保您的代码可以异步运行<a class="ae ky" rel="noopener" target="_blank" href="/asynchronous-parallel-programming-in-python-with-multiprocessing-a3fc882b4023"/>。换句话说，不可能知道哪个处理器将首先启动或完成，因此您的代码需要以这样一种方式进行组织，即结果不依赖于可能在不同处理器上计算的值。</p><pre class="kj kk kl km gt mz mw na nb aw nc bi"><span id="a137" class="lv lw it mw b gy nd ne l nf ng">Hello world from rank 2 of 4<br/>Hello world from rank 3 of 4<br/>Hello world from rank 0 of 4<br/>Hello world from rank 1 of 4</span></pre><p id="e1fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，更新脚本，以便它为不同的等级输出不同的消息。这是使用逻辑语句(<code class="fe mt mu mv mw b">if</code>、<code class="fe mt mu mv mw b">elif</code>、<code class="fe mt mu mv mw b">else</code>)完成的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="a402" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在得到0级和1级的不同消息。</p><pre class="kj kk kl km gt mz mw na nb aw nc bi"><span id="7880" class="lv lw it mw b gy nd ne l nf ng">First rank<br/>Hello world from rank 0 of 4<br/>Not first or second rank<br/>Hello world from rank 2 of 4<br/>Not first or second rank<br/>Hello world from rank 3 of 4<br/>Second rank<br/>Hello world from rank 1 of 4</span></pre><h2 id="bbc2" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">发送和接收数组</h2><p id="d6cc" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated"><code class="fe mt mu mv mw b">send</code>和<code class="fe mt mu mv mw b">recv</code>功能分别将数据从一个处理器发送到另一个处理器，并从一个处理器接收数据。许多数据类型可以通过这些函数传递。这个例子将特别关注发送和接收<code class="fe mt mu mv mw b">numpy</code>数组。<code class="fe mt mu mv mw b">Send</code>和<code class="fe mt mu mv mw b">Recv</code>函数(注意大写字母“S”和“R”)是专用于<code class="fe mt mu mv mw b">numpy</code>数组的。有关基本<code class="fe mt mu mv mw b">send</code>和<code class="fe mt mu mv mw b">recv</code>的示例，请参见<code class="fe mt mu mv mw b"><a class="ae ky" href="https://mpi4py.readthedocs.io/en/stable/tutorial.html" rel="noopener ugc nofollow" target="_blank">mpi4py</a></code> <a class="ae ky" href="https://mpi4py.readthedocs.io/en/stable/tutorial.html" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="28d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上一篇文章中，我用<code class="fe mt mu mv mw b">multiprocessing</code>模块演示了并行处理。我们将在这个例子中使用相同的函数。</p><div class="nh ni gp gr nj nk"><a rel="noopener follow" target="_blank" href="/asynchronous-parallel-programming-in-python-with-multiprocessing-a3fc882b4023"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd iu gy z fp np fr fs nq fu fw is bi translated">多处理Python中的异步并行编程</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">一种在个人计算机上加速代码的灵活方法</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">towardsdatascience.com</p></div></div><div class="nt l"><div class="nu l nv nw nx nt ny ks nk"/></div></div></a></div><p id="e2f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在同一个目录中创建两个新的Python脚本。说出一个<code class="fe mt mu mv mw b">my_function.py</code>和另一个<code class="fe mt mu mv mw b">mpi_my_function.py</code>的名字。在<code class="fe mt mu mv mw b">my_function.py</code>中，实现上面链接的文章中的功能。你的脚本应该是这样的。这是一个简单的函数，用暂停来模拟长时间的运行。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="da88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些段落解释了<code class="fe mt mu mv mw b">my_function</code>的并行化程序。代码在下面的要点中给出(带注释)。在<code class="fe mt mu mv mw b">mpi_my_function.py</code>中导入<code class="fe mt mu mv mw b">my_function</code>、<code class="fe mt mu mv mw b">mpi4py</code>和<code class="fe mt mu mv mw b">numpy</code>。然后从<code class="fe mt mu mv mw b">MPI.COMM_WORLD</code>得到大小和等级。使用<code class="fe mt mu mv mw b">numpy</code>为<code class="fe mt mu mv mw b">my_function</code>创建随机参数值。所有处理器上都有<code class="fe mt mu mv mw b">params</code>变量。现在划分参数列表，将数组的一部分分配给每个进程(或等级)。我特意将<code class="fe mt mu mv mw b">params</code> (15)中的行数奇怪地被处理器(4)的数量整除，因此我们必须做一些额外的数学运算来分解<code class="fe mt mu mv mw b">params</code>。现在每个处理器都有一个变量来索引它在<code class="fe mt mu mv mw b">params</code>数组中的块的<code class="fe mt mu mv mw b">start</code>和<code class="fe mt mu mv mw b">stop</code>位置。</p><p id="14c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们希望最终结果是一个数组，其中包含每个参数集的参数值和函数结果。创建一个空数组，<code class="fe mt mu mv mw b">local_results</code>,其行数与参数数组相同，并增加一列来存储结果。然后对每个参数集运行<code class="fe mt mu mv mw b">my_function</code>，并将结果保存在结果数组中(<code class="fe mt mu mv mw b">local_results</code>)。现在每个处理器都有了它的<code class="fe mt mu mv mw b">params</code>数组块的结果。</p><p id="1db6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">必须收集结果以创建最终数组，其中包含每个原始参数组合的结果。将每个等级的<code class="fe mt mu mv mw b">local_results</code>数组发送到等级‘0’，在那里它们被组合成一个数组。当使用<code class="fe mt mu mv mw b">Send</code>时，指定要发送到的秩，<code class="fe mt mu mv mw b">dest</code>，并指定一个<code class="fe mt mu mv mw b">tag</code>(唯一的整数)，以便接收秩知道要检索哪个值(如果您最终执行多个<code class="fe mt mu mv mw b">Send</code>，这一点很重要)。</p><p id="3385" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于接收秩(0)，遍历所有其他秩，创建一个大小为要接收的数组的空数组，并使用<code class="fe mt mu mv mw b">Recv</code>从每个秩中检索发送的值，指定要接收的秩和<code class="fe mt mu mv mw b">tag</code>。检索到数组后，将其添加到现有值中。打印出最终的数组，确保它看起来是正确的。我们完事了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="e025" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用以下命令运行上面的脚本:</p><pre class="kj kk kl km gt mz mw na nb aw nc bi"><span id="4a23" class="lv lw it mw b gy nd ne l nf ng">mpiexec -n 4 python mpi_my_function.py</span></pre><p id="d2e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果应该类似于:</p><pre class="kj kk kl km gt mz mw na nb aw nc bi"><span id="d383" class="lv lw it mw b gy nd ne l nf ng">results<br/>[[7.58886620e+00 5.62618310e+01 9.09064771e+01 3.33107541e+03]<br/> [2.76707037e+01 4.03218572e+01 2.20310537e+01 3.08951805e+04]<br/> [7.82729169e+01 9.40939134e+01 7.24046134e+01 5.76552834e+05]<br/> [9.88496826e+01 6.91320832e+00 1.59490375e+01 6.75667032e+04]<br/> [8.94286742e+01 8.88605014e+01 5.31814181e+01 7.10713954e+05]<br/> [3.83757552e+01 4.64666288e+01 3.72791712e+01 6.84686177e+04]<br/> [9.33796247e+01 1.71058163e+01 2.94036272e+00 1.49161456e+05]<br/> [1.49763382e+01 6.77803268e+01 7.62249839e+01 1.52787224e+04]<br/> [7.42368720e+01 8.45623531e+01 6.27481273e+01 4.66095445e+05]<br/> [6.76429554e+01 5.95075836e+01 9.82287031e+00 2.72290902e+05]<br/> [4.94157194e+00 7.38840592e+01 3.70077813e+00 1.80788546e+03]<br/> [2.71179540e+01 2.94973140e+00 2.86632603e+01 2.19784685e+03]<br/> [2.92793532e+01 9.90621647e+01 9.45343344e+01 8.50185987e+04]<br/> [1.20975353e+01 8.89643839e+01 7.13313160e+01 1.30913009e+04]<br/> [8.45193908e+01 4.89884544e+01 5.67737042e+01 3.50007141e+05]]</span></pre><h2 id="77bc" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">结论</h2><p id="a742" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">您可能已经注意到，并行运行一个4行函数需要43行代码。似乎有点矫枉过正。我们并行化了一个简单的函数，但这实际上是一个更复杂的例子，因为需要进行操作来获得所需的输出格式。这个例子作为更复杂函数的并行化模板。一般来说，我将编写一个Python模块来运行我的模型/分析，然后在并行化脚本(上面的43行要点)中设置并调用模块中的一个函数(完成所有工作)。您可以运行非常复杂的分析，而无需向我们在此创建的脚本添加太多代码。一旦你让这个代码在你的个人机器上运行，它就可以在大多数超级计算机上运行，而不需要太多额外的工作。</p><p id="529e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并行快乐！</p></div></div>    
</body>
</html>