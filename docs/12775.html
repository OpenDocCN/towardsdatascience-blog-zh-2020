<html>
<head>
<title>GeoTIFF Coordinate Querying with JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 JavaScript 实现 GeoTIFF 坐标查询</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/geotiff-coordinate-querying-with-javascript-5e6caaaf88cf?source=collection_archive---------28-----------------------#2020-09-02">https://towardsdatascience.com/geotiff-coordinate-querying-with-javascript-5e6caaaf88cf?source=collection_archive---------28-----------------------#2020-09-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="17a2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何在没有外部库的情况下从地理空间栅格像元中检索数据</h2></div><p id="9af9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您在 Node.js 或客户端 JavaScript 中构建地理空间应用程序，您最终可能需要从特定坐标的栅格中提取数据，或者提取大量数据。从历史上看，这在 JavaScript 中并不简单，因为地理空间栅格最常见的格式是 GeoTIFF 文件类型，不容易解析。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/9bdc6aa8decee0cd04098e14d144677b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*n2aoujMrbfWFuXAi"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">作者图片</p></figure><p id="e1e0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有一些可用的解决方案，随着 JavaScript 语言和节点生态系统的最新进展，这不再是过去的技术障碍。</p><h1 id="876b" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">GDAL？</h1><p id="7ea6" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">在 JavaScript 真正有能力解析 GeoTIFF 文件之前——除非你用自己的包装器包装底层编程语言——最好的办法是通过<code class="fe mo mp mq mr b">exec()</code>调用另一个应用程序，比如 python 脚本或命令行实用程序。第一个想到的是<code class="fe mo mp mq mr b">gdallocationinfo</code>，它是 GDAL 套件的一部分，可用于使用纬度和经度查询栅格，如下所示:</p><pre class="lc ld le lf gt ms mr mt mu aw mv bi"><span id="c139" class="mw ls iq mr b gy mx my l mz na">gdallocationinfo -valonly -wgs84 &lt;geotiff filename&gt; &lt;longitude&gt; &lt;latitude&gt;</span></pre><p id="a77c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您只是查询栅格中的一个点，这种方法就足够了。然而，有一些问题:</p><ul class=""><li id="739d" class="nb nc iq kh b ki kj kl km ko nd ks ne kw nf la ng nh ni nj bi translated">如果在客户端这样做，用户必须安装 GDAL。</li><li id="2c3b" class="nb nc iq kh b ki nk kl nl ko nm ks nn kw no la ng nh ni nj bi translated">除了每次解析文件之外，通过<code class="fe mo mp mq mr b">exec()</code>调用它还有一个开销。</li></ul><p id="cdb8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为一个现实世界的例子，使用这种方法查询 60 个 GeoTIFF 文件中的一个点，每个文件有数百个波段，在速度相当快的计算机上需要大约 10 秒钟的处理时间。多个点会很快累积成不合理的时间量。</p><p id="8112" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果调用 shell 脚本和加载文件是大部分开销，那么为什么不使用为库提供绑定的<code class="fe mo mp mq mr b">gdal</code> npm 包呢？截至 2020 年 9 月，这也不是一个很好的选择，主要是因为它需要 GDAL 版本 2(当前版本是 3.1)，所以如果你在你的机器或服务器上安装了 GDAL，你将不得不做一些困难的版本杂耍来使它工作，如果你甚至可以让它从源代码开始构建。它也不提供异步绑定，这意味着如果您不希望您的线程被阻塞，您必须设置 web workers(如果运行 Node.js 服务器，这是有问题的，取决于您打算做多少处理)。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi np"><img src="../Images/9a8a6a3b0a478085fc38f0dcf301a3e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_KOgPcHg-F5o-hGlguUz7w.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">作者图片</p></figure><h1 id="e18f" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">GeoTIFF.js</h1><p id="9a7b" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">这个库已经存在了 4-5 年，几个月前才发布了 1.0.0 版本。GeoTIFF.js 不仅为同名文件类型提供了读写功能，还提供了内置的异步功能，甚至还有一个 web worker 池来处理更重要的任务。</p><p id="4593" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该库本身没有提供一种简单的方法来查询栅格中的地理坐标，因此您需要自己编写该功能。然而，一旦您从 GeoTIFF 中提取地理元数据，这就非常容易了。</p><p id="ec14" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，加载 GeoTIFF 及其相关图像。为了获得最佳效果，请确保首先将其投影到 WGS84。如果您将文件保存在内存中，您将不会处理从磁盘中重复读取它的开销，尽管它可能很小:</p><pre class="lc ld le lf gt ms mr mt mu aw mv bi"><span id="e576" class="mw ls iq mr b gy mx my l mz na">const file = await geoTIFF.fromFile(&lt;geotiff filename&gt;);<br/>const image = await file.getImage();</span></pre><p id="9eac" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，获取地理信息并计算一些数字，您将使用这些数字来计算哪个像素对应于给定的纬度和经度:</p><pre class="lc ld le lf gt ms mr mt mu aw mv bi"><span id="0b95" class="mw ls iq mr b gy mx my l mz na">const bbox = image.getBoundingBox();<br/>const pixelWidth = image.getWidth();<br/>const pixelHeight = image.getHeight();<br/>const bboxWidth = bbox[ 2 ] - bbox[ 0 ];<br/>const bboxHeight = bbox[ 3 ] - bbox[ 1 ];</span></pre><p id="5301" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">边界框数据存储为<code class="fe mo mp mq mr b">[xMin, yMin, xMax, yMax]</code>。我们现在可以获得坐标，并计算出它对应于哪个像素:</p><pre class="lc ld le lf gt ms mr mt mu aw mv bi"><span id="1057" class="mw ls iq mr b gy mx my l mz na">const widthPct = ( &lt;longitude&gt; - bbox[ 0 ] ) / bboxWidth;<br/>const heightPct = ( &lt;latitude&gt; - bbox[ 1 ] ) / bboxHeight;<br/>const xPx = <em class="nq">Math</em>.floor( pixelWidth * widthPct );<br/>const yPx = <em class="nq">Math</em>.floor( pixelHeight * ( 1 - heightPct ) );</span></pre><p id="a1f2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nq">注意，</em> <code class="fe mo mp mq mr b"><em class="nq">heightPct</em></code> <em class="nq">已经被倒置，因为这个天气模型的原点在左下角。一些天气模型在右上角有它。你可能需要写一些代码来决定是否基于这个事实反转</em> <code class="fe mo mp mq mr b"><em class="nq">heightPct</em></code> <em class="nq">。</em></p><p id="d504" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在怎么办？当然，您可以从<code class="fe mo mp mq mr b">image</code>中提取整个光栅。对于较小的图像，这很好，您可以将整个数据数组保存在内存中，这样查询起来非常便宜和快速。但是，如果您正在处理大型栅格和/或大量波段，这将需要很长时间和相当多的内存。</p><p id="c7e0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">幸运的是，GeoTIFF.js 提供了一种使用边界框提取栅格的方法，因此我们将只使用一个逐个像素的边界框。事实证明，这非常快速，即使是在具有大量波段的非常大的栅格上也是如此(此外，GeoTIFF.js 支持切片栅格-切片大栅格应该可以进一步提高性能，但我尚未对其进行测试。):</p><pre class="lc ld le lf gt ms mr mt mu aw mv bi"><span id="06ca" class="mw ls iq mr b gy mx my l mz na">const window = [ xPx, yPx, xPx + 1, yPx + 1 ];<br/>const data = await image.readRasters( {window} );</span></pre><p id="6d89" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在你有了这个特定点上所有波段的数组。</p><pre class="lc ld le lf gt ms mr mt mu aw mv bi"><span id="9065" class="mw ls iq mr b gy mx my l mz na">[<br/>  Float32Array [ 0.07990912348031998 ],<br/>  Float32Array [ 0.16144123673439026 ],<br/>  Float32Array [ 0.1751343011856079 ],<br/>  Float32Array [ 0.2101452350616455 ],<br/>  Float32Array [ 0.2505287826061249 ],<br/>  Float32Array [ 0.3461601734161377 ]<br/>  ...<br/>]</span></pre><p id="c870" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，您可以让<code class="fe mo mp mq mr b">readRasters</code>使用一个 web worker 池，这增加了多线程的潜力，但是使用这样小的边界框，启动一个新的 web worker 的开销会大大降低性能，所以不建议使用这种方法。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi nr"><img src="../Images/4145c7f3ca927e74b9265ea4922b0e10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SzS3DNPjjpITXLZa4R5atA.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">作者图片</p></figure><h1 id="55c2" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">性能比较</h1><p id="3b9a" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">GeoTIFF.js 查询逻辑如何应对对<code class="fe mo mp mq mr b">gdallocationinfo</code>的调用？这可能取决于你打开了多少个文件(尤其是重复打开)，但是我的实验和实践结果是决定性的。在一个固态硬盘上，我使用相同的纬度和经度查询了相同的栅格(大约 500px 乘 200px，有 250 个波段),并记录了经过的毫秒数。</p><p id="d910" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">exec(gdallocationinfo…)</strong></p><pre class="lc ld le lf gt ms mr mt mu aw mv bi"><span id="271e" class="mw ls iq mr b gy mx my l mz na">Run 1: 62ms<br/>Run 2: 163ms<br/>Run 3: 64ms<br/>Run 4: 68ms<br/>Run 5: 176ms<br/>----<br/>Average: 106.6ms</span></pre><p id="fa03" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种方法似乎每运行几次就会经历随机的停顿，这对它的总处理时间是有害的。除了我的服务器之外，我的开发计算机也注意到了这一点。</p><p id="9613" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> GeoTIFF.js </strong></p><pre class="lc ld le lf gt ms mr mt mu aw mv bi"><span id="710f" class="mw ls iq mr b gy mx my l mz na">Run 1: 58ms<br/>Run 2: 60ms<br/>Run 3: 60ms<br/>Run 4: 54ms<br/>Run 5: 57ms<br/>----<br/>Average: 57.8ms</span></pre><p id="fb62" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个库不仅比调用<code class="fe mo mp mq mr b">gdallocationinfo</code>稍快，而且性能非常稳定，几乎将平均处理时间减半。</p><p id="fca8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用这种技术，我能够将 JavaScript 天气预报算法的性能提高近三倍，因为它可以读取大约 60 个地理位置和数千个波段。使用<code class="fe mo mp mq mr b">gdallocationinfo</code>，这通常需要大约十秒钟。在使用 GeoTIFF.js 切换到上述技术后，该算法运行时间不到三秒。如今，通过一些额外的缓存技术，我的生产服务器可以在不到一秒钟的时间内检索到从几千个栅格波段生成的预测-只有迁移到完整的二进制或其他一些更具编译性的解决方案，性能才有可能得到显著提高。</p><p id="87ed" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，还有其他读取 GeoTIFF 数据的外部库，但是用<code class="fe mo mp mq mr b">exec()</code>调用它们似乎不太可能比 GeoTIFF.js 提供更多的优势，特别是因为您无法将 GeoTIFF 图像或数据本身(作为原始数值数组)缓存在您的 JavaScript 应用程序中。</p><p id="93ed" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">是的，你总是可以用一种实际上适合处理这些数据的语言或框架来阅读 GeoTIFFs，但是这种范式正在开始改变。JavaScript 继续发展和成熟，Node.js 中构建的服务器变得越来越常见，实现类似基于浏览器的天气模型分析应用程序不再是白日梦。您可能需要使用这种技术。也许你会想出更快的东西，如果是这样，我很想听听！</p></div></div>    
</body>
</html>