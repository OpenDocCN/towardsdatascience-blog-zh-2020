<html>
<head>
<title>How to build a multi-threaded pipeline in C++ with std::async</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用 std::async 在 C++中构建多线程管道</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-build-a-multi-threaded-pipeline-in-c-with-std-async-78edc19e862d?source=collection_archive---------15-----------------------#2020-09-17">https://towardsdatascience.com/how-to-build-a-multi-threaded-pipeline-in-c-with-std-async-78edc19e862d?source=collection_archive---------15-----------------------#2020-09-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/6e0c674cb20cd2076fabb4e5db04e67d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RlXIvkib4-Csgklq"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@ikukevk?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">凯文·Ku</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="cd81" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">今天我们要弄清楚如何在 C++11 中创建一个能够处理流数据的多线程应用程序。更重要的是，我们不会自己创建任何 std::thread-s，相反，我们将采用未来和异步调用的新功能范式。</p><p id="9e79" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本教程的代码可以在 Github 上找到:</p><div class="le lf gp gr lg lh"><a href="https://github.com/Obs01ete/async_pipeline" rel="noopener  ugc nofollow" target="_blank"><div class="li ab fo"><div class="lj ab lk cl cj ll"><h2 class="bd iu gy z fp lm fr fs ln fu fw is bi translated">OBS 01 远程/异步管道</h2><div class="lo l"><h3 class="bd b gy z fp lm fr fs ln fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="lp l"><p class="bd b dl z fp lm fr fs ln fu fw dk translated">github.com</p></div></div><div class="lq l"><div class="lr l ls lt lu lq lv jz lh"/></div></div></a></div><p id="a55c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这项工作的动机是，当您想要在 CPU 上执行一些繁重的计算时，您不可避免地想要在多线程中运行它。否则，数据研磨的带宽将被限制在一个线程内。例如，如果你有一个来自网络摄像头的图像流，你想对它应用几个过滤器:颜色调整，调整大小，甚至可能是一些人工智能，比如人脸检测，运行所有这些处理步骤可能需要数百毫秒。当源帧速率为 30 fps 时，您可能会在可视化窗口中得到令人失望的 5–10 fps。我们通过<future> header 和 stdlib 的内容来看看如何处理。</future></p><figure class="lw lx ly lz gt ju"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="9a97" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后让我们创建我们的处理函数<code class="fe mc md me mf b">func1</code>和<code class="fe mc md me mf b">func2</code>。在本教程中，我们不会运行真正的计算，因此作为概念验证，让我们设置模拟线程繁忙的睡眠。</p><figure class="lw lx ly lz gt ju"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="c83c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们希望可视化处理的结果，比如调用 OpenCV 的 cv::showImage()。为了简单起见，我们在这里放置了一个简单的 std::cout 打印输出。</p><figure class="lw lx ly lz gt ju"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="9d0f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们准备好准备我们的主要应用程序。</p><figure class="lw lx ly lz gt ju"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="71eb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">是时候推出我们的应用程序，看看我们有什么。</p><pre class="lw lx ly lz gt mg mf mh mi aw mj bi"><span id="a0ef" class="mk ml it mf b gy mm mn l mo mp">Enqueued sample: 0<br/>Enqueued sample: 1<br/>Sample 0 output: ‘input_string_0 func1 func2’ finished at 1851<br/>Sample 1 output: ‘input_string_1 func1 func2’ finished at 2851<br/>Enqueued sample: 2<br/>Sample 2 output: ‘input_string_2 func1 func2’ finished at 3851<br/>Enqueued sample: 3<br/>Sample 3 output: ‘input_string_3 func1 func2’ finished at 4851<br/>Enqueued sample: 4<br/>Enqueued sample: 5<br/>Sample 4 output: ‘input_string_4 func1 func2’ finished at 5851<br/>Sample 5 output: ‘input_string_5 func1 func2’ finished at 6851<br/>Enqueued sample: 6<br/>...<br/>Enqueued sample: 98<br/>Sample 98 output: 'input_string_98 func1 func2' finished at 99862<br/>Enqueued sample: 99<br/>Waiting to finish...<br/>Sample 99 output: 'input_string_99 func1 func2' finished at 100862<br/>Finished!</span></pre><p id="d8f1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">太神奇了，管道成功了！请注意样本可视化时刻之间的时间差:为 1000 毫秒。如果没有多线程管道，则为 900+950=1850 毫秒。</p><p id="b615" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">std::async 的一个优点是它在幕后管理一个线程池。所以不用担心每次我们调用 std::async 时都会启动一个新线程。后续调用会重用线程，因此操作系统不会因为启动和终止大量线程而过载。</p><p id="3243" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">人们可能会注意到代码中的一些缺陷:</p><ul class=""><li id="8d60" class="mq mr it ki b kj kk kn ko kr ms kv mt kz mu ld mv mw mx my bi translated">std::cout 不受互斥体保护。</li><li id="320d" class="mq mr it ki b kj mz kn na kr nb kv nc kz nd ld mv mw mx my bi translated">异常不由处理函数处理。</li><li id="9cb7" class="mq mr it ki b kj mz kn na kr nb kv nc kz nd ld mv mw mx my bi translated">我们正在向<code class="fe mc md me mf b">func#</code>，尤其是<code class="fe mc md me mf b">visualize</code>传递大量的争论。值得考虑将代码组织成一个类。</li></ul><p id="6cde" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些我将在下一篇文章中讨论。</p><p id="7134" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">谢谢你看我的教程，下期再见！</p></div></div>    
</body>
</html>