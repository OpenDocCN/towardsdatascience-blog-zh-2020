<html>
<head>
<title>20 Minute Data Science Crash Course for 2020</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">2020年20分钟数据科学速成班</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/20-minute-data-science-crash-course-for-2020-8670ad4f727a?source=collection_archive---------12-----------------------#2020-03-30">https://towardsdatascience.com/20-minute-data-science-crash-course-for-2020-8670ad4f727a?source=collection_archive---------12-----------------------#2020-03-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="abd9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">帮助你在顶尖科技公司找到工作的终极资源</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/eefc801e19015c6d7f71a992fa1aa17b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/0*7Syuw0x12FiWziPo"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图片由阿曼达·福西特提供</p></figure><p id="0323" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这篇文章是一个广泛的速成班，我认为这是成为一名数据科学家需要知道的一些最基本和最有用的概念。我已经把它分成了不同的部分，这样你就可以一点一点地看了。</p><p id="7a96" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">好吧，这并没有涵盖<strong class="kw iu">与数据科学相关的一切</strong>(那是不可能的),不，这应该是<strong class="kw iu">而不是</strong>你用来发展知识和技能的唯一资源…</p><p id="9fe6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，如果你一无所知，那么这将有助于你很好地理解数据科学的基础知识。如果您对数据科学有所了解，这可以作为一门紧凑的速成课程，用于复习、磨练您的知识和/或找出您知识中的差距。</p><p id="e557" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一如既往，我希望这能对您有所帮助，并祝您在数据科学事业中好运！</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="4814" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">目录</h1><ol class=""><li id="b819" class="mp mq it kw b kx mr la ms ld mt lh mu ll mv lp mw mx my mz bi translated"><a class="ae na" href="#d0a6" rel="noopener ugc nofollow">机器学习模型</a></li><li id="2324" class="mp mq it kw b kx nb la nc ld nd lh ne ll nf lp mw mx my mz bi translated"><a class="ae na" href="#be81" rel="noopener ugc nofollow">统计数据</a></li><li id="276d" class="mp mq it kw b kx nb la nc ld nd lh ne ll nf lp mw mx my mz bi translated"><a class="ae na" href="#9411" rel="noopener ugc nofollow">概率</a></li><li id="5abe" class="mp mq it kw b kx nb la nc ld nd lh ne ll nf lp mw mx my mz bi translated"><a class="ae na" href="#2af6" rel="noopener ugc nofollow">熊猫</a></li><li id="2fc7" class="mp mq it kw b kx nb la nc ld nd lh ne ll nf lp mw mx my mz bi translated"><a class="ae na" href="#1886" rel="noopener ugc nofollow"> SQL &amp;查询</a></li><li id="3f0d" class="mp mq it kw b kx nb la nc ld nd lh ne ll nf lp mw mx my mz bi translated"><a class="ae na" href="#723f" rel="noopener ugc nofollow">奖金内容</a></li></ol></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="d0a6" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">1.机器学习模型</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi ng"><img src="../Images/05eb8fa9613c5d2fb4e59d8a2e12d7f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XOAOuTfiPT5hGSLSNRSB4Q.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">机器学习模型的基本分段</p></figure><p id="a35f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所有的机器学习模型被分类为<strong class="kw iu">监督的</strong>或<strong class="kw iu">非监督的</strong>。如果模型是一个监督模型，那么它会被细分为<strong class="kw iu">回归</strong>或<strong class="kw iu">分类</strong>模型。我们将讨论这些术语的含义以及下面每个类别中对应的模型。</p><h1 id="527a" class="lx ly it bd lz ma nl mc md me nm mg mh jz nn ka mj kc no kd ml kf np kg mn mo bi translated">监督学习</h1><p id="aff7" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated"><strong class="kw iu">监督学习</strong>涉及学习基于示例输入-输出对将输入映射到输出的函数。</p><p id="cd57" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，如果我有一个包含两个变量的数据集，年龄(输入)和身高(输出)，我可以实现一个监督学习模型，根据年龄预测一个人的身高。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nt"><img src="../Images/4469c2929dc4299e691df01aa9d7db83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NhlimsPFBurZKVEJbUN4Vg.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">监督学习的例子</p></figure><p id="bc70" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">重复一下，在监督学习中，有两个子类别:回归和分类。</p><h1 id="f2c2" class="lx ly it bd lz ma nl mc md me nm mg mh jz nn ka mj kc no kd ml kf np kg mn mo bi translated">回归</h1><p id="c9b0" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">在<strong class="kw iu">回归</strong>模型中，输出是连续的。下面是一些最常见的回归模型。</p><h2 id="5dab" class="nu ly it bd lz nv nw dn md nx ny dp mh ld nz oa mj lh ob oc ml ll od oe mn of bi translated">线性回归</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi og"><img src="../Images/fdb1eb19ae2ed98560be41be9391f0af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sOi6uKo3d-OxmA1caVmm0g.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">线性回归的例子</p></figure><p id="4981" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">线性回归的概念就是找到一条最符合数据的直线。线性回归的扩展包括多元线性回归(例如，找到最佳拟合的平面)和多项式回归(例如，找到最佳拟合的曲线)。你可以在我的<a class="ae na" href="https://medium.com/swlh/predicting-life-expectancy-w-regression-b794ca457cd4" rel="noopener">上一篇文章</a>中了解更多关于线性回归的知识。</p><h2 id="64b9" class="nu ly it bd lz nv nw dn md nx ny dp mh ld nz oa mj lh ob oc ml ll od oe mn of bi translated">决策图表</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi og"><img src="../Images/89991e805ee972142726c35a7ffd91c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L9AcBn8WmWN44s-NQiDbOQ.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图片来自Kaggle</p></figure><p id="5264" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">决策树</strong>是一种流行的模型，用于运筹学、战略规划和机器学习。上面的每个方块被称为一个<strong class="kw iu">节点</strong>，节点越多，你的决策树就越精确(一般来说)。决策树的最后一个节点，也就是做出决策的地方，被称为树的<strong class="kw iu">叶</strong>。决策树直观且易于构建，但在准确性方面有所欠缺。</p><h2 id="0bb8" class="nu ly it bd lz nv nw dn md nx ny dp mh ld nz oa mj lh ob oc ml ll od oe mn of bi translated">随机森林</h2><p id="b186" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated"><strong class="kw iu">随机森林</strong>是一种基于决策树的<a class="ae na" href="https://en.wikipedia.org/wiki/Ensemble_learning" rel="noopener ugc nofollow" target="_blank">集成学习</a>技术。随机森林包括使用原始数据的<a class="ae na" href="https://machinelearningmastery.com/a-gentle-introduction-to-the-bootstrap-method/" rel="noopener ugc nofollow" target="_blank">自举数据集</a>创建多个决策树，并在决策树的每一步随机选择一个变量子集。然后，该模型选择每个决策树的所有预测的模式。这有什么意义？依靠“多数获胜”模型，它降低了单个树出错的风险。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi oh"><img src="../Images/37d302e5755ad3c13eb03d397cfc0f25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RuglAQsrbJWG49kaXv6tdQ.png"/></div></div></figure><p id="ec9e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，如果我们创建一个决策树，第三个，它会预测0。但是如果我们依赖所有4个决策树的模式，预测值将是1。这就是随机森林的力量。</p><p id="474b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">StatQuest做了一项了不起的工作，更详细地说明了这一点。见<a class="ae na" href="https://www.youtube.com/watch?v=J4Wdy0Wc_xQ&amp;vl=en" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><h2 id="5788" class="nu ly it bd lz nv nw dn md nx ny dp mh ld nz oa mj lh ob oc ml ll od oe mn of bi translated">神经网络</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/9d560ce9742fc78499d8ddcaad9737cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/format:webp/1*o2xECsD8cGULb8YucHx_2w.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">神经网络的可视化表示</p></figure><p id="1501" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一个<strong class="kw iu">神经网络</strong>是一个受人脑启发的多层模型。就像我们大脑中的神经元一样，上面的圆圈代表一个节点。蓝色圆圈代表<strong class="kw iu">输入层，</strong>黑色圆圈代表<strong class="kw iu">隐藏层，</strong>，绿色圆圈代表<strong class="kw iu">输出层。隐藏层中的每个节点代表一个输入经过的函数，最终导致绿色圆圈中的输出。</strong></p><p id="b18c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">神经网络实际上是非常复杂和非常数学化的，所以我不会进入它的细节，但…</p><p id="12ac" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">饶彤彤的文章对神经网络背后的过程给出了直观的解释(见<a class="ae na" rel="noopener" target="_blank" href="/understanding-neural-networks-19020b758230">此处</a>)。</p><p id="f6ae" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你想更进一步，理解神经网络背后的数学，请点击这里查看这本免费的在线书籍<a class="ae na" href="http://neuralnetworksanddeeplearning.com/index.html" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="0d73" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你是一名视觉/音频学习者，3Blue1Brown在YouTube上有一个关于神经网络和深度学习的惊人系列<a class="ae na" href="https://www.youtube.com/watch?v=aircAruvnKk" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><h1 id="6cc1" class="lx ly it bd lz ma nl mc md me nm mg mh jz nn ka mj kc no kd ml kf np kg mn mo bi translated">分类</h1><p id="03ab" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">在分类模型中，输出是离散的。下面是一些最常见的分类模型。</p><h2 id="9202" class="nu ly it bd lz nv nw dn md nx ny dp mh ld nz oa mj lh ob oc ml ll od oe mn of bi translated">逻辑回归</h2><p id="ea83" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">逻辑回归类似于线性回归，但用于模拟有限数量结果的概率，通常为两个。在对结果的概率建模时，逻辑回归比线性回归更常用，原因有很多(见<a class="ae na" href="https://stackoverflow.com/questions/12146914/what-is-the-difference-between-linear-regression-and-logistic-regression" rel="noopener ugc nofollow" target="_blank">此处</a>)。实质上，逻辑方程是以这样一种方式创建的，即输出值只能在0和1之间(见下文)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi oj"><img src="../Images/4e1289edda5acd0ce4741587c097e46b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*USrdZ1puaFIIymBRcO51mg.png"/></div></div></figure><h2 id="1f62" class="nu ly it bd lz nv nw dn md nx ny dp mh ld nz oa mj lh ob oc ml ll od oe mn of bi translated">支持向量机</h2><p id="1c28" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">一个<strong class="kw iu">支持向量机</strong>是一种监督分类技术，它实际上可以变得非常复杂，但在最基本的层面上是非常直观的。</p><p id="a327" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们假设有两类数据。支持向量机将找到一个<strong class="kw iu">超平面</strong>或两类数据之间的边界，该边界使两类数据之间的间隔最大化(见下文)。有许多平面可以分隔这两个类别，但只有一个平面可以最大化类别之间的边距或距离。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/d6dbc0b7a28c7c62f684687fd5be0fc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*kTUuRm1tGnEw0dHz.png"/></div></figure><p id="5020" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你想了解更多细节，Savan在这里写了一篇关于支持向量机的文章。</p><h2 id="13d1" class="nu ly it bd lz nv nw dn md nx ny dp mh ld nz oa mj lh ob oc ml ll od oe mn of bi translated">朴素贝叶斯</h2><p id="be07" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">朴素贝叶斯是数据科学中使用的另一种流行的分类器。背后的想法是由贝叶斯定理驱动的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/c4f2916899f51bf70d5882c1a6533a49.png" data-original-src="https://miro.medium.com/v2/resize:fit:978/format:webp/1*TqeIPHaO8FPcaSW3FwxH8A.png"/></div></figure><p id="1d5d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">虽然有许多关于朴素贝叶斯的不切实际的假设(这就是为什么它被称为‘朴素’)，但它已经被证明在大多数情况下都是有效的，而且构建起来也相对较快。</p><p id="c440" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你想了解更多，请点击<a class="ae na" rel="noopener" target="_blank" href="/naive-bayes-classifier-81d512f50a7c">这里</a>。</p><h2 id="e2e0" class="nu ly it bd lz nv nw dn md nx ny dp mh ld nz oa mj lh ob oc ml ll od oe mn of bi translated">决策树，随机森林，神经网络</h2><p id="543b" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">这些模型遵循与前面解释的相同的逻辑。唯一区别是输出是离散的而不是连续的。</p><h1 id="949b" class="lx ly it bd lz ma nl mc md me nm mg mh jz nn ka mj kc no kd ml kf np kg mn mo bi translated">无监督学习</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi om"><img src="../Images/307a89c0453c3da15af0ac0d702ac587.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k0sd5IuawFLNQAbZ-JjKnA.png"/></div></div></figure><p id="713a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">与监督学习不同，<strong class="kw iu">非监督学习</strong>用于从输入数据中进行推断和发现模式，而不参考标记的结果。无监督学习中使用的两种主要方法包括聚类和降维。</p><h1 id="8ff0" class="lx ly it bd lz ma nl mc md me nm mg mh jz nn ka mj kc no kd ml kf np kg mn mo bi translated">使聚集</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/114b4d851e53c735225a1778e4274d12.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*lHjMiUUkkQP6EEL4VAQjcA.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">摘自GeeksforGeeks</p></figure><p id="61c3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">聚类是一种无监督的技术，涉及数据点的分组，或<strong class="kw iu">聚类</strong>。它经常用于客户细分、欺诈检测和文档分类。</p><p id="e74a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">常见的聚类技术有<strong class="kw iu"> k-means </strong>聚类、<strong class="kw iu">分层</strong>聚类、<strong class="kw iu">均值漂移</strong>聚类、<strong class="kw iu">基于密度的</strong>聚类。虽然每种技术在寻找聚类时有不同的方法，但它们的目标都是一样的。</p><h1 id="2115" class="lx ly it bd lz ma nl mc md me nm mg mh jz nn ka mj kc no kd ml kf np kg mn mo bi translated">降维</h1><p id="640f" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">降维是通过获得一组主变量来减少所考虑的随机变量的数量的过程。简单来说，就是减少特性集的维数的过程(更简单来说，就是减少特性的数量)。大多数降维技术可以分为<strong class="kw iu">特征消除</strong>或<strong class="kw iu">特征提取。</strong></p><p id="41d2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一种流行的降维方法叫做<strong class="kw iu">主成分分析。</strong></p><h2 id="8e10" class="nu ly it bd lz nv nw dn md nx ny dp mh ld nz oa mj lh ob oc ml ll od oe mn of bi translated">主成分分析</h2><p id="a2a9" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">从最简单的意义上来说，<strong class="kw iu"> PCA </strong>涉及到将高维数据(如3维)投影到更小的空间(如2维)。这导致数据的维度降低(2维而不是3维)，同时保持模型中的所有原始变量。</p><p id="4e4a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这涉及到相当多的数学问题。如果你想了解更多…</p><p id="ed31" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">点击查看这篇关于PCA <a class="ae na" rel="noopener" target="_blank" href="/a-one-stop-shop-for-principal-component-analysis-5582fb7e0a9c">的精彩文章。</a></p><p id="68ad" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你宁愿看视频，StatQuest在5分钟内解释PCA<a class="ae na" href="https://www.youtube.com/watch?v=HMOI_lkzW08&amp;vl=en" rel="noopener ugc nofollow" target="_blank">这里</a>。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="be81" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">2.统计数字</h1><h1 id="be95" class="lx ly it bd lz ma nl mc md me nm mg mh jz nn ka mj kc no kd ml kf np kg mn mo bi translated">数据类型</h1><p id="3135" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated"><strong class="kw iu">数值:</strong>用数字表示的数据；是可以衡量的。既可以是<strong class="kw iu">离散</strong>也可以是<strong class="kw iu">连续</strong>。</p><p id="0dcf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">分类:</strong>定性数据分类成类别。可以是<strong class="kw iu">名义</strong>(未排序)或<strong class="kw iu">序数</strong>(排序数据)。</p><h1 id="7ed8" class="lx ly it bd lz ma nl mc md me nm mg mh jz nn ka mj kc no kd ml kf np kg mn mo bi translated">集中趋势测量</h1><p id="072b" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated"><strong class="kw iu">均值:</strong>一个数据集的平均值。<br/> <strong class="kw iu">中位数:</strong>有序数据集的中间；不易受离群值的影响。<br/> <strong class="kw iu">模式:</strong>数据集中最常见的值；仅与离散数据相关。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi oo"><img src="../Images/d749028b2d60bb26fe873b7f9b39020c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Tyr_tJ0n5adP-xdw.png"/></div></div></figure><h1 id="c626" class="lx ly it bd lz ma nl mc md me nm mg mh jz nn ka mj kc no kd ml kf np kg mn mo bi translated">差异量数</h1><p id="978e" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated"><strong class="kw iu">范围:</strong>数据集中最高值和最低值之差。</p><p id="6bf0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">方差(σ2): </strong>衡量一组数据相对于平均值的分布程度。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/c1cbad01936cdc36bcad096487d8fec1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/0*b3AgWOeuLAZcXh_I.png"/></div></figure><p id="4e58" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">标准差(σ): </strong>数据集中数字分布的另一种度量；它是方差的平方根。</p><p id="b565" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> Z-score: </strong>确定数据点偏离平均值的标准偏差数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/9e96b6e221222a56745c91b7e80fff82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/format:webp/0*t5ZcqpGfA1O6Yx6b.png"/></div></figure><p id="93b7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> R-Squared: </strong>拟合的统计度量，表明自变量解释了因变量的多少变化；仅对简单的线性回归有用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi or"><img src="../Images/9393e662b08a5f86b7a0ada1158b1348.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Z1wIhqI7oOoPOxVW.png"/></div></div></figure><p id="4b11" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">调整后的R平方:</strong>已针对模型中预测器的数量进行调整的R平方的修改版本；如果新项对模型的改进超过偶然的预期，那么它就会增加，反之亦然。</p><h1 id="5498" class="lx ly it bd lz ma nl mc md me nm mg mh jz nn ka mj kc no kd ml kf np kg mn mo bi translated">变量之间关系的度量</h1><p id="a99a" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated"><strong class="kw iu">协方差:</strong>测量两个(或多个)变量之间的方差。如果是正的，那么它们倾向于向同一个方向移动，如果是负的，那么它们倾向于向相反的方向移动，如果它们是零，那么它们彼此没有关系。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi om"><img src="../Images/b5365cfba0e1403ab71616615d200219.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Fcl8ZRTZTI103L1D.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">样本的分母变为(n-1)</p></figure><p id="2293" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">相关性:</strong>衡量两个变量之间的关系强度，范围从-1到1；协方差的标准化版本。一般来说，+/- 0.7的相关性代表两个变量之间的密切关系。另一方面，介于-0.3和0.3之间的相关性表明变量之间几乎没有关系。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi ot"><img src="../Images/db987c8d4eab43ff7e694fc6193ab2ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xrv_RtZuCybWm5t5.png"/></div></div></figure><h1 id="3f52" class="lx ly it bd lz ma nl mc md me nm mg mh jz nn ka mj kc no kd ml kf np kg mn mo bi translated">概率分布函数</h1><p id="4c27" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated"><strong class="kw iu">概率密度函数(PDF): </strong>连续数据的函数，其中任意点的值可以被解释为提供随机变量的值等于该样本的<em class="os">相对</em>可能性。(<a class="ae na" href="https://en.wikipedia.org/wiki/Probability_density_function" rel="noopener ugc nofollow" target="_blank">维基</a>)</p><p id="7d97" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">概率质量函数(PMF): </strong>离散数据的函数，给出给定值出现的概率。</p><p id="7e1e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">累积密度函数(CDF): </strong>告诉我们随机变量小于某个值的概率的函数；PDF的积分。</p><h1 id="2944" class="lx ly it bd lz ma nl mc md me nm mg mh jz nn ka mj kc no kd ml kf np kg mn mo bi translated">连续数据分布</h1><p id="1049" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated"><strong class="kw iu">均匀分布:</strong>所有结果可能性相等的概率分布。</p><p id="61fb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">正态/高斯分布:</strong>通常称为钟形曲线，与<a class="ae na" href="https://en.wikipedia.org/wiki/Central_limit_theorem" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu">中心极限定理</strong> </a>有关；平均值为0，标准偏差为1。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi ou"><img src="../Images/c2c535410896714ffb9fdb192fa12a1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4xC54TiVYk8y54Fg.png"/></div></div></figure><p id="cb2c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">T-分布:</strong>在样本量较小和/r总体方差未知时用于估计总体参数的概率分布(<em class="os">参见更多</em> <a class="ae na" href="https://stattrek.com/probability-distributions/t-distribution.aspx" rel="noopener ugc nofollow" target="_blank"> <em class="os">此处</em> </a> <em class="os">)。</em></p><p id="0f78" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">卡方分布:</strong>卡方统计量的分布(<em class="os">见</em> <a class="ae na" href="https://stattrek.com/probability-distributions/chi-square.aspx" rel="noopener ugc nofollow" target="_blank"> <em class="os">此处</em> </a> <em class="os">)。</em></p><h1 id="8717" class="lx ly it bd lz ma nl mc md me nm mg mh jz nn ka mj kc no kd ml kf np kg mn mo bi translated">离散数据分布</h1><p id="0460" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated"><strong class="kw iu">泊松分布:</strong>概率分布，表示给定数量的事件在固定时间段内发生的概率。</p><p id="942e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">二项式分布:</strong>一系列n次独立经历中成功次数的概率分布，每次经历都有自己的布尔值结果(p，1-p)。</p><h1 id="fd7c" class="lx ly it bd lz ma nl mc md me nm mg mh jz nn ka mj kc no kd ml kf np kg mn mo bi translated">朋友圈</h1><p id="ab3c" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated"><strong class="kw iu">矩</strong>描述了分布的性质和形状的不同方面。一阶矩是均值<strong class="kw iu">，二阶矩是方差<strong class="kw iu">，三阶矩是偏度<strong class="kw iu">，四阶矩是峰度<strong class="kw iu"/>。</strong></strong></strong></p><h1 id="f659" class="lx ly it bd lz ma nl mc md me nm mg mh jz nn ka mj kc no kd ml kf np kg mn mo bi translated">准确(性)</h1><p id="233f" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated"><strong class="kw iu">真阳性:</strong>检测条件出现时的条件。</p><p id="59cb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">真否定:</strong>不检测条件不存在时的条件。</p><p id="1c74" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">假阳性:</strong>检测条件不存在时的条件。</p><p id="a87d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">假阴性:</strong>在条件存在时不检测条件。</p><p id="95ae" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">灵敏度:</strong>又称<strong class="kw iu">召回</strong>；当条件存在时，测量测试检测条件的能力；灵敏度= TP/(TP+FN)</p><p id="ec6f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">特异性:</strong>测量当条件不存在时，测试正确排除条件的能力；特异性= TN/(TN+FP)</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi ov"><img src="../Images/1d9f1be8a3b4e5683281206371ccb6bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PnSpL-AcwAj4LEsK.png"/></div></div></figure><p id="e33e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">预测值阳性:</strong>又称<strong class="kw iu">精度</strong>；<strong class="kw iu"> </strong>对应于条件存在的阳性比例；PVP = TP/(TP+FP)</p><p id="c0cb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">预测值阴性:</strong>对应于不存在条件的阴性比例；PVN = TN/(TN+FN)</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi ow"><img src="../Images/a05e7206cf3e5882c756b7a9315d26f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*f5hbbiBSaXnn-75o.png"/></div></div></figure><h1 id="5e69" class="lx ly it bd lz ma nl mc md me nm mg mh jz nn ka mj kc no kd ml kf np kg mn mo bi translated">假设检验和统计显著性</h1><p id="f988" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated"><em class="os">查看我的文章“尽可能简单地解释假设检验”以获得更深入的解释</em> <a class="ae na" rel="noopener" target="_blank" href="/hypothesis-testing-explained-as-simply-as-possible-6e0a256293cf"> <em class="os">这里</em> </a> <em class="os">。</em></p><p id="ff9a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">零假设:</strong>样本观察结果纯粹来自偶然的假设。</p><p id="dc42" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">备选假设:</strong>样本观测值受某种非随机原因影响的假设。</p><p id="9a11" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> P值:</strong>假设零假设正确，获得某个检验的观测结果的概率；较小的p值意味着有更强的证据支持替代假设。</p><p id="f019" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">α:</strong>显著性水平；当零假设为真时拒绝零假设的概率—也称为<strong class="kw iu">1型错误。</strong></p><p id="d461" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">Beta:</strong>2型错误；未能拒绝虚假的零假设。</p><p id="6420" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">假设检验的步骤:<br/> 1。陈述无效假设和替代假设<br/> 2。确定测试规模；是单尾还是双尾检验？<br/> 3。计算测试统计和概率值<br/> 4。分析结果，拒绝或不拒绝零假设(<em class="os">如果p值大于α，不拒绝零假设！)</em></p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="9411" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">3.可能性</h1><p id="51c0" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">概率是事件发生的可能性。</p><p id="7301" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">条件概率【P(A | B)】</strong>是一个事件发生的可能性，基于前一个事件的发生。</p><p id="c887" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">独立事件</strong>是其结果不影响另一事件结果概率的事件；P(A|B) = P(A)。</p><p id="b99d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">互斥事件</strong>是不能同时发生的事件；P(A|B) = 0。</p><p id="489b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">贝叶斯定理:</strong>确定条件概率的数学公式。<em class="os">“给定B的概率等于给定A的B的概率乘以A的概率超过B的概率”。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi ox"><img src="../Images/aeaaf760c618af22847431ba6b26082c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PdVipreYEgGaoav7G45V9A.png"/></div></div></figure><h2 id="1b42" class="nu ly it bd lz nv nw dn md nx ny dp mh ld nz oa mj lh ob oc ml ll od oe mn of bi translated">概率的八大法则</h2><ul class=""><li id="2985" class="mp mq it kw b kx mr la ms ld mt lh mu ll mv lp oy mx my mz bi translated">规则#1:对于任何事件A，<strong class="kw iu">0≤P(A)≤1</strong>；<em class="os">换句话说，一个事件的概率范围可以从0到1。</em></li><li id="81d5" class="mp mq it kw b kx nb la nc ld nd lh ne ll nf lp oy mx my mz bi translated">规则2:所有可能结果的概率总和总是等于1。</li><li id="55d9" class="mp mq it kw b kx nb la nc ld nd lh ne ll nf lp oy mx my mz bi translated">规则#3: <strong class="kw iu"> P(不是A)= 1—P(A)</strong>；<em class="os">这个规则解释了一个事件的概率和它的补事件之间的关系。补充事件是指包含a中没有的所有可能结果的事件。</em></li><li id="c7e9" class="mp mq it kw b kx nb la nc ld nd lh ne ll nf lp oy mx my mz bi translated">规则#4:如果A和B是不相交事件(互斥)，那么<strong class="kw iu"> P(A或B)= P(A)+P(B)</strong>；<em class="os">这被称为不相交事件的添加规则</em></li><li id="aba3" class="mp mq it kw b kx nb la nc ld nd lh ne ll nf lp oy mx my mz bi translated">规则#5: <strong class="kw iu"> P(A或B) = P(A) + P(B) — P(A和B)</strong>；<em class="os">这叫做一般加法法则。</em></li><li id="6881" class="mp mq it kw b kx nb la nc ld nd lh ne ll nf lp oy mx my mz bi translated">规则#6:如果A和B是两个独立事件，那么<strong class="kw iu"> P(A和B)= P(A)* P(B)</strong>；这被称为独立事件的乘法法则。</li><li id="c4c7" class="mp mq it kw b kx nb la nc ld nd lh ne ll nf lp oy mx my mz bi translated">规则#7:给定事件A，事件B的条件概率为<strong class="kw iu"> P(B|A) = P(A和B) / P(A) </strong></li><li id="049a" class="mp mq it kw b kx nb la nc ld nd lh ne ll nf lp oy mx my mz bi translated">规则#8:对于任意两个事件A和B，<strong class="kw iu"> P(A和B)= P(A)* P(B | A)</strong>；<em class="os">这被称为通用乘法法则</em></li></ul><h2 id="bb1a" class="nu ly it bd lz nv nw dn md nx ny dp mh ld nz oa mj lh ob oc ml ll od oe mn of bi translated">计数方法</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi oz"><img src="../Images/a286b5c84c870685378d7e38c940bb3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*NhBzNUrU1OvIG6QP.png"/></div></div></figure><p id="60a0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">阶乘公式:n！= n x(n-1)x(n-2)x…x 2 x 1<br/></strong>当项目数等于可用位置数时使用。<strong class="kw iu"> <br/> </strong> <em class="os">例如:找出5个人可以坐在5个空座位上的总方式数。<br/>= 5×4×3×2×1 = 120</em></p><p id="30b2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">基本计数原理(乘法)<br/> </strong>当允许重复且填充空位的方式数不受之前填充的影响时，应使用此方法。有3种早餐、4种午餐和5种甜点。组合总数= 5 x 4 x 3 = 60 </p><p id="aed6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">排列:P(n，r)= n！/(n r)！<br/>一个代码有4个数字，按特定的顺序排列，数字范围从0到9。如果一个数字只能用一次，有多少种排列？<br/> P(n，r) = 10！/(10–4)!=(10 x 9 x 8 x 7 x 6 x 5 x 4 x 3 x2 x 1)/(6x 5 x 4 x 3 x2 x 1)= 5040</strong></p><p id="4a7c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">组合公式:C(n，r)=(n！)/[(n r)！r！] <br/> </strong>当不允许替换并且项目的排列顺序不重要时使用。<strong class="kw iu"> <br/> </strong> <em class="os">要赢得彩票，你必须从1到52中以任何顺序选出5个正确的数字。有多少种可能的组合？<br/> C(n，r) = 52！/ (52–5)!5!= 2598960</em></p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="2af6" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">4.熊猫</h1><p id="90dd" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated"><strong class="kw iu"> Pandas </strong>是Python中的一个软件库，用于数据操作和分析。这在数据科学领域是普遍现象，必须了解！下面是学习熊猫基本功能的指南。</p><h1 id="13ee" class="lx ly it bd lz ma nl mc md me nm mg mh jz nn ka mj kc no kd ml kf np kg mn mo bi translated">设置</h1><h2 id="e8ca" class="nu ly it bd lz nv nw dn md nx ny dp mh ld nz oa mj lh ob oc ml ll od oe mn of bi translated">导入熊猫库</h2><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="adbe" class="nu ly it pb b gy pf pg l ph pi">import pandas as pd</span></pre><h1 id="2b4b" class="lx ly it bd lz ma nl mc md me nm mg mh jz nn ka mj kc no kd ml kf np kg mn mo bi translated">创建和读取数据</h1><h2 id="abfd" class="nu ly it bd lz nv nw dn md nx ny dp mh ld nz oa mj lh ob oc ml ll od oe mn of bi translated">创建数据框架</h2><p id="4fd2" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">数据帧只是一个由多个数组组成的表。在下面的示例中，代码将创建一个包含ABC和DEF两列的表。</p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="1231" class="nu ly it pb b gy pf pg l ph pi">pd<strong class="pb iu">.DataFrame</strong>({'ABC':[1,2,3],'DEF':[4,5,6]},index=[1,2,3])</span></pre><h2 id="8a6b" class="nu ly it bd lz nv nw dn md nx ny dp mh ld nz oa mj lh ob oc ml ll od oe mn of bi translated">创建一个系列</h2><p id="a802" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">系列是一系列值，也称为列表。从视觉角度来看，想象它是表格中的一列。</p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="bcff" class="nu ly it pb b gy pf pg l ph pi">pd<strong class="pb iu">.Series</strong>([1,2,3],index=[], name ='ABC')</span></pre><h2 id="79b3" class="nu ly it bd lz nv nw dn md nx ny dp mh ld nz oa mj lh ob oc ml ll od oe mn of bi translated">将CSV文件读入数据帧</h2><p id="b4a6" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">获取数据的最常见方式。这将CSV文件转换为数据帧。</p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="75b8" class="nu ly it pb b gy pf pg l ph pi"># example<br/>df = pd<strong class="pb iu">.read_csv</strong>("filename.csv", index_col=0)</span></pre><h2 id="b4c9" class="nu ly it bd lz nv nw dn md nx ny dp mh ld nz oa mj lh ob oc ml ll od oe mn of bi translated">将数据帧转换为CSV文件</h2><p id="7808" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">反之亦然，如果您想将DataFrame转换成CSV，可以使用下面的代码:</p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="3206" class="nu ly it pb b gy pf pg l ph pi"># example<br/>df<strong class="pb iu">.to_csv</strong>("filename.csv", index_col=0)</span></pre><h2 id="d7ab" class="nu ly it bd lz nv nw dn md nx ny dp mh ld nz oa mj lh ob oc ml ll od oe mn of bi translated">确定数据帧的形状</h2><p id="eecd" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">这将告诉您数据帧有多大，格式是什么(行，列)。</p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="3755" class="nu ly it pb b gy pf pg l ph pi">df<strong class="pb iu">.shape()</strong></span></pre><h2 id="7962" class="nu ly it bd lz nv nw dn md nx ny dp mh ld nz oa mj lh ob oc ml ll od oe mn of bi translated">查看数据帧的前5行</h2><p id="0fcd" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">如果你想直观地了解数据帧的样子。head() 返回给定数据帧的前5行。</p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="bc7a" class="nu ly it pb b gy pf pg l ph pi">df<strong class="pb iu">.head()</strong></span></pre><h2 id="3231" class="nu ly it bd lz nv nw dn md nx ny dp mh ld nz oa mj lh ob oc ml ll od oe mn of bi translated">查看一列或多列的数据类型</h2><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="c75e" class="nu ly it pb b gy pf pg l ph pi"># For one column<br/>df.variable<strong class="pb iu">.dtype</strong></span><span id="fc8c" class="nu ly it pb b gy pj pg l ph pi"># For all columns<br/>df<strong class="pb iu">.dtypes</strong></span></pre><h2 id="2255" class="nu ly it bd lz nv nw dn md nx ny dp mh ld nz oa mj lh ob oc ml ll od oe mn of bi translated">将列转换为另一种数据类型</h2><p id="7ea3" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">如果您想将整数转换成浮点数(反之亦然)，这是很有用的。</p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="9f01" class="nu ly it pb b gy pf pg l ph pi">df.variable<strong class="pb iu">.astype()</strong></span></pre><h1 id="3e9a" class="lx ly it bd lz ma nl mc md me nm mg mh jz nn ka mj kc no kd ml kf np kg mn mo bi translated">操作数据帧</h1><h2 id="3752" class="nu ly it bd lz nv nw dn md nx ny dp mh ld nz oa mj lh ob oc ml ll od oe mn of bi translated">从数据帧中选择系列</h2><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="4dc5" class="nu ly it pb b gy pf pg l ph pi"># a) Method 1<br/>df.property_name</span><span id="42ad" class="nu ly it pb b gy pj pg l ph pi"># b) Method 2<br/>df['property_name']</span></pre><h2 id="f215" class="nu ly it bd lz nv nw dn md nx ny dp mh ld nz oa mj lh ob oc ml ll od oe mn of bi translated">索引系列</h2><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="29a3" class="nu ly it pb b gy pf pg l ph pi"># if you want to get the first value in a series<br/>df['property_name'][0]</span></pre><h2 id="d6b1" class="nu ly it bd lz nv nw dn md nx ny dp mh ld nz oa mj lh ob oc ml ll od oe mn of bi translated">基于索引的选择</h2><p id="ec3a" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">基于索引的选择根据数据在数据帧中的数字位置检索数据。它遵循行优先，列第二的格式。Iloc的索引方案是这样的:<strong class="kw iu">的第一个数字是包含性的</strong>，而<strong class="kw iu">的最后一个数字是排他性的</strong>。</p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="dba6" class="nu ly it pb b gy pf pg l ph pi">df<strong class="pb iu">.iloc[]</strong></span></pre><h2 id="47ed" class="nu ly it bd lz nv nw dn md nx ny dp mh ld nz oa mj lh ob oc ml ll od oe mn of bi translated">基于标签的选择</h2><p id="5ff3" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">基于标签的选择是索引数据帧的另一种方式，但它基于实际数据值而不是数字位置来检索数据。Loc的索引方案使得<strong class="kw iu">的第一个和最后一个值都包含在内。</strong></p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="c501" class="nu ly it pb b gy pf pg l ph pi">df<strong class="pb iu">.loc[]</strong></span></pre><h2 id="ac6c" class="nu ly it bd lz nv nw dn md nx ny dp mh ld nz oa mj lh ob oc ml ll od oe mn of bi translated">使用现有列设置索引</h2><p id="9ea1" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">因为基于标签的选择依赖于数据帧的索引，所以可以使用<strong class="kw iu">。set_index() </strong>将一列分配给索引。</p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="56f0" class="nu ly it pb b gy pf pg l ph pi">df.<strong class="pb iu">set_index</strong>("variable")</span></pre><h2 id="b79a" class="nu ly it bd lz nv nw dn md nx ny dp mh ld nz oa mj lh ob oc ml ll od oe mn of bi translated">基于条件标签的选择</h2><p id="ebd0" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">我们也可以使用基于标签的选择来过滤出数据帧。</p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="76f2" class="nu ly it pb b gy pf pg l ph pi"># a) Single Condition <br/>df.loc[df.property_name == 'ABC']</span><span id="e49a" class="nu ly it pb b gy pj pg l ph pi"># b) Multiple conditions using AND<br/>df.loc[df.property_name == 'ABC' &amp; df.property_name == 'DEF']</span><span id="4877" class="nu ly it pb b gy pj pg l ph pi"># c) Multiple conditions using OR<br/>df.loc[df.property_name == 'ABC' | df.property_name == 'DEF']</span></pre><h2 id="52aa" class="nu ly it bd lz nv nw dn md nx ny dp mh ld nz oa mj lh ob oc ml ll od oe mn of bi translated">选择值在值列表中的位置</h2><p id="5d8e" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">我们也可以使用<strong class="kw iu"> isin() </strong>来过滤数据帧。如果你懂SQL，它类似于WHERE ___ IN()语句。</p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="ee7c" class="nu ly it pb b gy pf pg l ph pi">df.loc[df.property_name.<strong class="pb iu">isin</strong>(['ABC','DEF'])</span></pre><h2 id="926c" class="nu ly it bd lz nv nw dn md nx ny dp mh ld nz oa mj lh ob oc ml ll od oe mn of bi translated">选择值为空/不为空的位置</h2><p id="c5e0" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">第一行代码将过滤DataFrame，只显示属性名为null的行。<br/>反之亦然，第二行代码用filter it使属性名不为空。</p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="fb45" class="nu ly it pb b gy pf pg l ph pi">df.loc[df.property_name<strong class="pb iu">.isnull</strong>()]</span><span id="e6f6" class="nu ly it pb b gy pj pg l ph pi">df.loc[df.property_name<strong class="pb iu">.notnull()</strong>]</span></pre><h2 id="e7b3" class="nu ly it bd lz nv nw dn md nx ny dp mh ld nz oa mj lh ob oc ml ll od oe mn of bi translated">添加新列</h2><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="d5ef" class="nu ly it pb b gy pf pg l ph pi">df['new_column'] = 'ABC'</span></pre><h2 id="3b38" class="nu ly it bd lz nv nw dn md nx ny dp mh ld nz oa mj lh ob oc ml ll od oe mn of bi translated">重命名列</h2><p id="d8b1" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">您通常会希望将列重命名为更容易引用的名称。使用下面的代码，列ABC将被重命名为DEF。</p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="977a" class="nu ly it pb b gy pf pg l ph pi">df.<strong class="pb iu">rename</strong>(columns={'ABC': 'DEF'})</span></pre><h1 id="f416" class="lx ly it bd lz ma nl mc md me nm mg mh jz nn ka mj kc no kd ml kf np kg mn mo bi translated">汇总函数</h1><h2 id="10d8" class="nu ly it bd lz nv nw dn md nx ny dp mh ld nz oa mj lh ob oc ml ll od oe mn of bi translated">。描述()</h2><p id="6e28" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">这给出了数据帧或变量的高级摘要。它是类型敏感的，这意味着与字符串变量相比，数字变量的输出是不同的。</p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="8237" class="nu ly it pb b gy pf pg l ph pi">df<strong class="pb iu">.describe()</strong><br/>df.variable<strong class="pb iu">.describe()</strong></span></pre><h2 id="c129" class="nu ly it bd lz nv nw dn md nx ny dp mh ld nz oa mj lh ob oc ml ll od oe mn of bi translated">。平均值()</h2><p id="c313" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">这将返回变量的平均值。</p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="327b" class="nu ly it pb b gy pf pg l ph pi">df.variable<strong class="pb iu">.mean()</strong></span></pre><h2 id="33f3" class="nu ly it bd lz nv nw dn md nx ny dp mh ld nz oa mj lh ob oc ml ll od oe mn of bi translated">。唯一()</h2><p id="68fc" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">这将返回变量的所有唯一值。</p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="80b5" class="nu ly it pb b gy pf pg l ph pi">df.variable<strong class="pb iu">.unique()</strong></span></pre><h2 id="1485" class="nu ly it bd lz nv nw dn md nx ny dp mh ld nz oa mj lh ob oc ml ll od oe mn of bi translated">。值计数()</h2><p id="a50c" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">这显示了唯一值的列表以及数据帧中出现的频率。</p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="afb7" class="nu ly it pb b gy pf pg l ph pi">df.variable.<strong class="pb iu">value_counts()</strong></span></pre><h1 id="83dc" class="lx ly it bd lz ma nl mc md me nm mg mh jz nn ka mj kc no kd ml kf np kg mn mo bi translated">映射函数</h1><h2 id="458d" class="nu ly it bd lz nv nw dn md nx ny dp mh ld nz oa mj lh ob oc ml ll od oe mn of bi translated">。地图()</h2><p id="e87a" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">映射用于通过函数将一组初始值转换为另一组值。例如，我们可以使用映射将列的值从米转换为厘米，或者我们可以将这些值标准化。</p><p id="dd32" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">。map()用于转换一个序列。</p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="96c3" class="nu ly it pb b gy pf pg l ph pi">df.numerical_variable<strong class="pb iu">.map()</strong></span></pre><h2 id="7deb" class="nu ly it bd lz nv nw dn md nx ny dp mh ld nz oa mj lh ob oc ml ll od oe mn of bi translated">。应用()</h2><p id="d239" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">。apply()类似于。map()，只是它转换整个数据帧。</p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="2d76" class="nu ly it pb b gy pf pg l ph pi">df.numerical_variable<strong class="pb iu">.apply()</strong></span></pre><h1 id="a263" class="lx ly it bd lz ma nl mc md me nm mg mh jz nn ka mj kc no kd ml kf np kg mn mo bi translated">分组和排序</h1><h2 id="c948" class="nu ly it bd lz nv nw dn md nx ny dp mh ld nz oa mj lh ob oc ml ll od oe mn of bi translated">。groupby()</h2><p id="c789" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated"><strong class="kw iu">获取变量的每个值的计数(<em class="os">与value_counts </em>相同)</strong></p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="de8b" class="nu ly it pb b gy pf pg l ph pi">df<strong class="pb iu">.groupby</strong>('variable').variable<strong class="pb iu">.count()</strong></span></pre><p id="ed65" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">获取变量的每个值的最小值</strong></p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="7b81" class="nu ly it pb b gy pf pg l ph pi">df<strong class="pb iu">.groupby</strong>('variable').variable<strong class="pb iu">.min()</strong></span></pre><p id="d6ca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">获取变量</strong>的每个值的汇总(长度、最小值、最大值)</p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="4e68" class="nu ly it pb b gy pf pg l ph pi">df<strong class="pb iu">.groupby</strong>(['variable']).variable.<strong class="pb iu">agg([len, min, max])</strong></span></pre><p id="5c4d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">多重索引</strong></p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="f57d" class="nu ly it pb b gy pf pg l ph pi">df.groupby(['variable_one', 'variable_two'])</span></pre><h2 id="d971" class="nu ly it bd lz nv nw dn md nx ny dp mh ld nz oa mj lh ob oc ml ll od oe mn of bi translated">对数据帧排序</h2><p id="a521" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated"><strong class="kw iu">按一个变量排序</strong></p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="1861" class="nu ly it pb b gy pf pg l ph pi">df.<strong class="pb iu">sort_values</strong>(by='variable', ascending=False)</span></pre><p id="f6e7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">多变量排序</strong></p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="c613" class="nu ly it pb b gy pf pg l ph pi">df.sort_values(by=['variable_one', 'variable_two'])</span></pre><p id="7e6b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">按索引排序</strong></p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="3625" class="nu ly it pb b gy pf pg l ph pi">df<strong class="pb iu">.sort_index()</strong></span></pre><h1 id="520b" class="lx ly it bd lz ma nl mc md me nm mg mh jz nn ka mj kc no kd ml kf np kg mn mo bi translated">处理缺失数据</h1><p id="92ff" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">处理缺失数据是EDA中最重要的步骤之一。下面是一些处理缺失数据的方法。</p><h2 id="ae20" class="nu ly it bd lz nv nw dn md nx ny dp mh ld nz oa mj lh ob oc ml ll od oe mn of bi translated">删除包含空值的行</h2><p id="4e40" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">如果您有一个包含大量行的数据帧，并且您能够完全删除包含空值的行，那么。dropna()是一个有用的工具。</p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="5279" class="nu ly it pb b gy pf pg l ph pi">df.<strong class="pb iu">dropna()</strong></span></pre><h2 id="b50b" class="nu ly it bd lz nv nw dn md nx ny dp mh ld nz oa mj lh ob oc ml ll od oe mn of bi translated">删除包含空值的列</h2><p id="2650" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">这与上面的类似，除了它删除任何具有空值的列<strong class="kw iu">而不是行。</strong></p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="373b" class="nu ly it pb b gy pf pg l ph pi">df.<strong class="pb iu">dropna(axis=1)</strong></span></pre><h2 id="64c2" class="nu ly it bd lz nv nw dn md nx ny dp mh ld nz oa mj lh ob oc ml ll od oe mn of bi translated">填充缺失值</h2><p id="cdf6" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">如果您希望填充缺少的值，而不是完全删除行或列，可以使用下面的代码:</p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="6460" class="nu ly it pb b gy pf pg l ph pi">df.variable<strong class="pb iu">.fillna</strong>("n/a")</span></pre><h2 id="3e5d" class="nu ly it bd lz nv nw dn md nx ny dp mh ld nz oa mj lh ob oc ml ll od oe mn of bi translated">替换值</h2><p id="2731" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">假设有一个数据帧，其中有人已经用“n/a”填充了缺失值，但是您希望用“unknown”填充缺失值。那么您可以使用下面的代码:</p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="b4f5" class="nu ly it pb b gy pf pg l ph pi">df.variable<strong class="pb iu">.replace</strong>("n/a", "unknown")</span></pre><h1 id="8a80" class="lx ly it bd lz ma nl mc md me nm mg mh jz nn ka mj kc no kd ml kf np kg mn mo bi translated">组合数据</h1><h2 id="b457" class="nu ly it bd lz nv nw dn md nx ny dp mh ld nz oa mj lh ob oc ml ll od oe mn of bi translated">。concat()</h2><p id="9f22" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">当您想要合并具有相同列的两个数据帧时，这很有用。例如，如果我们想将一月份的销售额和二月份的销售额结合起来分析长期趋势，您可以使用以下代码:</p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="9639" class="nu ly it pb b gy pf pg l ph pi">Jan_sales = pd.read_csv("jan_sales.csv")<br/>Feb_sales = pd.read_csv("feb_sales.csv")</span><span id="17de" class="nu ly it pb b gy pj pg l ph pi"><strong class="pb iu">pd.concat</strong>([Jan_sales, Feb_sales])</span></pre><h2 id="b970" class="nu ly it bd lz nv nw dn md nx ny dp mh ld nz oa mj lh ob oc ml ll od oe mn of bi translated">。加入()</h2><p id="faa1" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">如果您想要合并具有公共索引的两个列(例如customer_id)，那么您可以使用。加入()。</p><p id="3fc4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用上的参数<strong class="kw iu">确定要连接的列。</strong></p><p id="8550" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要确定它是左连接、右连接、内连接还是外连接，可以使用参数<strong class="kw iu"> how </strong> <em class="os">。</em></p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="cf5e" class="nu ly it pb b gy pf pg l ph pi"># example<br/>table_1.<strong class="pb iu">join</strong>(table_2, on='customer_id', <em class="os">how='left')</em></span></pre><p id="1540" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="os">如果你不了解SQL joins，在这里阅读</em><a class="ae na" href="https://www.w3schools.com/sql/sql_join.asp" rel="noopener ugc nofollow" target="_blank"><em class="os"/></a><em class="os">。本质上是一样的想法。</em></p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="1886" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">5.SQL和查询</h1><h2 id="93db" class="nu ly it bd lz nv nw dn md nx ny dp mh ld nz oa mj lh ob oc ml ll od oe mn of bi translated">定义</h2><p id="d9c4" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated"><strong class="kw iu">行</strong>，也称为<strong class="kw iu">记录，</strong>是代表单个实体的属性(变量)的集合。例如，一行可能代表一个住院病人，可能有年龄、体重、身高等属性/变量…</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi pk"><img src="../Images/23b48a6399beda8b495205fb3df03284.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l4Uy5LA2OvRW9GBrkTzYvw.png"/></div></div></figure><p id="2d80" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">表</strong>是具有相同属性(相同变量)的行的集合。对我帮助最大的是把一个表格想象成一个Excel表格。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi pl"><img src="../Images/35c6269f5b84733716de22524748efe2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CjTVBhr8GJ8QiLl26B5idA.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">表格示例</p></figure><p id="feab" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">查询</strong>是从数据库表或表的组合中请求数据。使用上面的表格，如果我想找到所有年龄大于23岁的病人，我将编写一个<strong class="kw iu">查询</strong>。</p><h2 id="2343" class="nu ly it bd lz nv nw dn md nx ny dp mh ld nz oa mj lh ob oc ml ll od oe mn of bi translated">如何编写SQL</h2><p id="c2e8" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">因为这是给初学者的教程，所以如果你想从<strong class="kw iu">一个</strong>表中提取数据，我将向你展示如何编写一个查询。</p><p id="152a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一个基本查询有五个组成部分:</p><ol class=""><li id="7f0a" class="mp mq it kw b kx ky la lb ld pm lh pn ll po lp mw mx my mz bi translated">选择(必填)</li><li id="60dc" class="mp mq it kw b kx nb la nc ld nd lh ne ll nf lp mw mx my mz bi translated">从(必填)</li><li id="3e8c" class="mp mq it kw b kx nb la nc ld nd lh ne ll nf lp mw mx my mz bi translated">其中(可选)</li><li id="e10c" class="mp mq it kw b kx nb la nc ld nd lh ne ll nf lp mw mx my mz bi translated">分组依据(可选)</li><li id="191b" class="mp mq it kw b kx nb la nc ld nd lh ne ll nf lp mw mx my mz bi translated">排序依据(可选)</li></ol><p id="e52e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">其结构如下:</p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="cac6" class="nu ly it pb b gy pf pg l ph pi"><strong class="pb iu">SELECT</strong><br/>   [column_name_1],<br/>   [column_name_2],<br/>   [column_name_n]<br/><strong class="pb iu">FROM</strong><br/>   [table_name]<br/><strong class="pb iu">WHERE</strong><br/>   [condition 1]<br/><strong class="pb iu">GROUP BY<br/>   </strong>[column_name] <br/><strong class="pb iu">ORDER BY<br/>   </strong>[column_name]</span></pre><p id="f7b0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们带回我的例子作为参考:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi pp"><img src="../Images/832f0a6d621f0cb4274d0c48805b0198.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KtsMyIrXRZh6MCjrRtRGHg.png"/></div></div></figure><h2 id="8399" class="nu ly it bd lz nv nw dn md nx ny dp mh ld nz oa mj lh ob oc ml ll od oe mn of bi translated">1.选择(必填)</h2><p id="0fe8" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated"><strong class="kw iu"> SELECT确定要从给定的表中提取哪些列。</strong>例如，如果我想提取名称，那么我的代码应该是这样的:</p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="2385" class="nu ly it pb b gy pf pg l ph pi">SELECT Name</span></pre><p id="3dcb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一个巧妙的技巧是，如果你想拉所有的列的<strong class="kw iu">，你可以使用星号——见下文:</strong></p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="81dd" class="nu ly it pb b gy pf pg l ph pi">SELECT *</span></pre><h2 id="1093" class="nu ly it bd lz nv nw dn md nx ny dp mh ld nz oa mj lh ob oc ml ll od oe mn of bi translated">2.从(必填)</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi pq"><img src="../Images/542a75d81a9048120850e735af8d1c1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*swDSAst2lfX9F0-vhMlT6A.png"/></div></div></figure><p id="9b87" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> FROM确定您要从哪个表中提取信息。</strong>例如，如果您想要提取患者的姓名，您可能想要从名为patient_info的表中提取数据(见上文)。代码看起来会像这样:</p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="7a09" class="nu ly it pb b gy pf pg l ph pi">SELECT<br/>   Name<br/>FROM<br/>   patient_info</span></pre><p id="1391" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是您的第一个函数查询！让我们来完成另外3个可选步骤。</p><h2 id="2de0" class="nu ly it bd lz nv nw dn md nx ny dp mh ld nz oa mj lh ob oc ml ll od oe mn of bi translated">3.其中(可选)</h2><p id="7bd7" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">如果您想选择年龄超过23岁的患者的姓名，该怎么办？这就是我们的用武之地。<strong class="kw iu"> WHERE是用来过滤您的表</strong>的语句，就像您在Excel中使用过滤工具一样！</p><p id="e2cf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">获取23岁以上患者姓名的代码在左边。右侧显示了一个可视化表示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi pr"><img src="../Images/e640594f626cc40add9d27f54cd48090.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R6k99-tyb_tzJtihD6g5DQ.png"/></div></div></figure><p id="c6a9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果想要满足<strong class="kw iu">两个</strong>子句的患者姓名，可以使用<strong class="kw iu">和</strong>。例如，查找年龄超过23岁且体重超过130磅的患者的姓名。</p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="999b" class="nu ly it pb b gy pf pg l ph pi">SELECT<br/>   Name<br/>FROM<br/>   patient_info<br/>WHERE<br/>   Age &gt; 23<br/>   AND<br/>   Weight_lbs &gt; 130</span></pre><p id="1b63" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您想要满足两个子句之一的<strong class="kw iu">的患者姓名，您可以使用<strong class="kw iu">或</strong>。<em class="os">例如，查找小于22岁或大于23岁的患者的姓名。</em></strong></p><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="f212" class="nu ly it pb b gy pf pg l ph pi">SELECT<br/>   Name<br/>FROM<br/>   patient_info<br/>WHERE<br/>   Age &lt; 22<br/>   OR<br/>   Age &gt; 23</span></pre><h2 id="d363" class="nu ly it bd lz nv nw dn md nx ny dp mh ld nz oa mj lh ob oc ml ll od oe mn of bi translated">4.分组依据(可选)</h2><p id="dce5" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">GROUP BY正如它所说的那样— <strong class="kw iu">它将具有相同值的行分组到汇总行中</strong>。它通常与计数、最小值、最大值、总和、AVG等聚合函数一起使用。</p><p id="fbf1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们用下面的例子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi ps"><img src="../Images/4f6cd70a442e20fd098b11ec20e05a57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G-EJXdDlV3DLDB2czEKSbA.png"/></div></div></figure><p id="79d6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们想得到每个病人去医院的次数，我们可以使用下面的代码并得到下面的结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi pt"><img src="../Images/d5ed25943a06ff5e79d0b708fa006626.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1RLJDlGESa7-Jdd1qoAG5g.png"/></div></div></figure><h2 id="8371" class="nu ly it bd lz nv nw dn md nx ny dp mh ld nz oa mj lh ob oc ml ll od oe mn of bi translated">5.排序依据(可选)</h2><p id="f08b" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">ORDER BY允许您根据特定属性或多个属性按升序或降序对结果进行排序。我们来举个例子。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi pu"><img src="../Images/6f9714292b150280b77a0df5997a81da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UMMgrcK-l7M47JLKNehchg.png"/></div></div></figure><pre class="kj kk kl km gt pa pb pc pd aw pe bi"><span id="46a6" class="nu ly it pb b gy pf pg l ph pi">SELECT<br/>   *<br/>FROM<br/>   patient_info<br/>ORDER BY<br/>   Age asc</span></pre><p id="5a0d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">“ORDER BY Age asc”意味着您的结果集将按年龄以升序对行进行排序(参见上图中的左表)。如果你想按降序排列(上图的右边表格)，你可以用<strong class="kw iu"> desc代替<strong class="kw iu"> asc </strong>。</strong></p><p id="eca1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在你已经学习了基本结构，下一步是学习SQL连接，你可以在这里阅读<a class="ae na" href="https://www.w3schools.com/sql/sql_join.asp" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="723f" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">6.额外内容</h1><p id="c6c6" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">如果你读到了最后，恭喜你！我希望这能激励你继续你的数据科学之旅。事实是，关于我写的每个主题，还有很多东西需要学习，但幸运的是，有成千上万的资源可供您使用！</p><p id="0ed6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以下是一些额外的资源和教程，您可以用来继续学习:</p><ul class=""><li id="95f6" class="mp mq it kw b kx ky la lb ld pm lh pn ll po lp oy mx my mz bi translated"><a class="ae na" rel="noopener" target="_blank" href="/a-guide-to-build-your-first-machine-learning-model-and-start-your-data-science-career-ef487f455c9"> <strong class="kw iu">建立你的第一个机器学习模型并开始你的数据科学生涯的指南</strong> </a> <strong class="kw iu"> : </strong>如果你从未创建过机器学习模型并且不知道从哪里开始，请参考这个。</li><li id="0815" class="mp mq it kw b kx nb la nc ld nd lh ne ll nf lp oy mx my mz bi translated"><a class="ae na" rel="noopener" target="_blank" href="/an-extensive-guide-to-exploratory-data-analysis-ddd99a03199e"><strong class="kw iu"/></a>探索性数据分析的详尽逐步指南:探索您的数据对于您使用的每个数据集都至关重要。通读这篇文章，了解什么是EDA以及如何进行EDA。</li><li id="1186" class="mp mq it kw b kx nb la nc ld nd lh ne ll nf lp oy mx my mz bi translated"><a class="ae na" rel="noopener" target="_blank" href="/how-to-evaluate-your-machine-learning-models-with-python-code-5f8d2d8d945b"> <strong class="kw iu">如何用Python代码评价你的机器学习模型！</strong> </a>:创建你的机器学习模型是一回事。创造一个好的机器学习模型是另一件事。这篇文章教你如何评估你是否建立了一个好的机器学习模型。</li><li id="b815" class="mp mq it kw b kx nb la nc ld nd lh ne ll nf lp oy mx my mz bi translated"><a class="ae na" rel="noopener" target="_blank" href="/over-100-data-scientist-interview-questions-and-answers-c5a66186769a#6c1e"> <strong class="kw iu">超过100个数据科学家面试问答！</strong> </a>:一旦你建立了一个强大的数据科学组合，你觉得已经准备好找工作了，利用这个资源来帮助你准备找工作。</li></ul><h1 id="0572" class="lx ly it bd lz ma nl mc md me nm mg mh jz nn ka mj kc no kd ml kf np kg mn mo bi translated">感谢阅读！</h1><p id="d1b7" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">如果你喜欢我的工作，想支持我…</p><ol class=""><li id="9327" class="mp mq it kw b kx ky la lb ld pm lh pn ll po lp mw mx my mz bi translated">支持我的最好方式就是在<strong class="kw iu">媒体</strong>上关注我<a class="ae na" href="https://medium.com/@terenceshin" rel="noopener">这里</a>。</li><li id="64a1" class="mp mq it kw b kx nb la nc ld nd lh ne ll nf lp mw mx my mz bi translated">在<strong class="kw iu"> Twitter </strong> <a class="ae na" href="https://twitter.com/terence_shin" rel="noopener ugc nofollow" target="_blank">这里</a>成为第一批关注我的人之一。我会在这里发布很多更新和有趣的东西！</li><li id="79b1" class="mp mq it kw b kx nb la nc ld nd lh ne ll nf lp mw mx my mz bi translated">此外，成为第一批订阅我的新<strong class="kw iu"> YouTube频道</strong> <a class="ae na" href="https://www.youtube.com/channel/UCmy1ox7bo7zsLlDo8pOEEhA?view_as=subscriber" rel="noopener ugc nofollow" target="_blank">这里</a>！</li><li id="8009" class="mp mq it kw b kx nb la nc ld nd lh ne ll nf lp mw mx my mz bi translated">关注我<strong class="kw iu">LinkedIn</strong>T36】这里。</li><li id="26c2" class="mp mq it kw b kx nb la nc ld nd lh ne ll nf lp mw mx my mz bi translated">在我的<strong class="kw iu">邮箱列表</strong> <a class="ae na" href="https://forms.gle/UGdTom9G6aFGHzPD9" rel="noopener ugc nofollow" target="_blank">这里</a>报名。</li><li id="8175" class="mp mq it kw b kx nb la nc ld nd lh ne ll nf lp mw mx my mz bi translated">看看我的网站，【terenceshin.com】<strong class="kw iu"/>。</li></ol></div></div>    
</body>
</html>