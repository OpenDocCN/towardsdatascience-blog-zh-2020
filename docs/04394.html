<html>
<head>
<title>Face Detection in 10 lines for Beginners</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向初学者的10行人脸检测</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/face-detection-in-10-lines-for-beginners-1787aa1d9127?source=collection_archive---------32-----------------------#2020-04-20">https://towardsdatascience.com/face-detection-in-10-lines-for-beginners-1787aa1d9127?source=collection_archive---------32-----------------------#2020-04-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3b6d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Python OpenCV在图像和视频中检测人脸的介绍</h2></div></div><div class="ab cl ki kj hx kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="im in io ip iq"><p id="f5d4" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我最近在为一个个人项目探索OpenCV的Haar级联对象检测模块。虽然网上有很多这方面的技术资料，但我这篇文章的重点是用通俗易懂的语言解释这些概念。我希望这将有助于初学者以简单的方式理解Python的OpenCV库。</p><p id="e1d5" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">在这个演示中，我们将拍摄一张图像并在其中搜索人脸。我们将使用预训练的分类器来执行该搜索。我计划分享更多关于我们将来如何训练我们自己的模型的文章。但是现在，让我们开始使用一个预先训练好的模型。</p><p id="d985" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">对于外行来说，OpenCV是一个Python库，主要用于各种计算机视觉问题。</p><p id="5775" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">在这里，我们使用的是来自opencv github <a class="ae lm" href="https://github.com/opencv/opencv/tree/master/data/haarcascades" rel="noopener ugc nofollow" target="_blank"> <strong class="kr iu"> <em class="ll">资源库</em></strong></a><em class="ll"/><strong class="kr iu"><em class="ll">作为我们的模型。您可以下载这个xml文件，并将其放在与python文件相同的路径中。这里还有一堆其他的模型，你可能想以后尝试一下(例如:-眼睛检测，全身检测，猫脸检测等。)</em></strong></p></div><div class="ab cl ki kj hx kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="im in io ip iq"><p id="30c8" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">在开始编写代码之前，让我们先看一下程序的高级流程。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi ln"><img src="../Images/c346450d0700bb5fe234d173526e3629.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*QLVoFI7wfztwVrcw_hodag.png"/></div><p class="lv lw gj gh gi lx ly bd b be z dk translated">下面描述的整个过程的图表[输入、面部检测过程和输出]</p></figure><h1 id="51b6" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">输入:</h1><p id="a6c6" class="pw-post-body-paragraph kp kq it kr b ks mr ju ku kv ms jx kx ky mt la lb lc mu le lf lg mv li lj lk im bi translated">该算法需要两个输入:</p><ol class=""><li id="9a25" class="mw mx it kr b ks kt kv kw ky my lc mz lg na lk nb nc nd ne bi translated">输入图像矩阵(我们将读取一个图像并将其转换为数字矩阵/numpy数组)</li><li id="fa66" class="mw mx it kr b ks nf kv ng ky nh lc ni lg nj lk nb nc nd ne bi translated">脸部特征(可在<em class="ll">Haar cascade _ frontal face _ default . XML</em><strong class="kr iu"><em class="ll"/></strong><em class="ll">文件中找到)</em></li></ol><h1 id="f1a7" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">人脸检测过程:</h1><p id="999b" class="pw-post-body-paragraph kp kq it kr b ks mr ju ku kv ms jx kx ky mt la lb lc mu le lf lg mv li lj lk im bi translated">OpenCV的哈尔级联分类器基于<em class="ll">滑动窗口</em>方法。在这种方法中，一个窗口(默认大小为20×20像素)在图像上滑动(逐行)以寻找面部特征。每次迭代后，图像按一定的因子缩小(调整大小)(由参数'<strong class="kr iu"> <em class="ll">比例因子</em> </strong>'决定)。每次迭代的输出被存储，并且在较小的、调整大小的图像上重复滑动操作。在最初的迭代过程中可能会出现误报，这将在本文后面详细讨论。这种缩小和开窗过程一直持续到图像对于滑动窗口来说太小为止。比例因子的值越小，精度越高，计算费用越高。</p><h1 id="adc5" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">输出:</h1><p id="8b46" class="pw-post-body-paragraph kp kq it kr b ks mr ju ku kv ms jx kx ky mt la lb lc mu le lf lg mv li lj lk im bi translated">我们的输出图像将在每个检测到的人脸周围包含一个矩形。</p></div><div class="ab cl ki kj hx kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="im in io ip iq"><p id="b32b" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated"><strong class="kr iu">代码&amp;解释:</strong></p><p id="f071" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">让我们从python代码开始。对于这个实验，我们将需要以下Python包:</p><pre class="lo lp lq lr gt nk nl nm nn aw no bi"><span id="126d" class="np ma it nl b gy nq nr l ns nt">pip install numpy<br/>pip install opencv-python</span></pre><p id="575f" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">让我们把我们的python文件叫做‘face _ detector . py’,<strong class="kr iu">把它放在与我们从上面分享的github链接下载的xml文件</strong>相同的路径中。</p><pre class="lo lp lq lr gt nk nl nm nn aw no bi"><span id="ee14" class="np ma it nl b gy nq nr l ns nt"># File Name: face_detector.py<br/># Import the OpenCV library<br/>import cv2</span></pre><p id="4e9e" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">现在让我们看看承诺的10行！</p><p id="aa50" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我们准备了2个输入[ <em class="ll">输入图像</em> &amp; <em class="ll">面部特征XML</em>]，如上面流程图中所示。</p><p id="2b1b" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我用贝丝·哈米蒂的这张美丽的照片(下面的链接)作为我的输入图像(kids.jpg)。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="nv nw di nx bf ny"><div class="gh gi nu"><img src="../Images/2cc260b43f3dea74e9ce7eb2d0bd3c35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZJcbaIr2TN0GfAtH54c3cA.jpeg"/></div></div><p class="lv lw gj gh gi lx ly bd b be z dk translated">照片由<a class="ae lm" href="https://www.pexels.com/photo/people-girl-design-happy-35188/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>的<a class="ae lm" href="https://www.pexels.com/@bess-hamiti-83687?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">贝丝·哈米蒂</a>拍摄</p></figure><p id="ca2f" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">1我们首先加载xml分类器和输入图像文件。由于输入文件相当大，我已经用与原始分辨率相似的尺寸调整了大小，这样它们就不会显得太大。然后，我把图像转换成灰度图像。灰度图像被认为提高了算法的效率。</p><pre class="lo lp lq lr gt nk nl nm nn aw no bi"><span id="a3e3" class="np ma it nl b gy nq nr l ns nt">face_cascade = cv2.CascadeClassifier("haarcascade_frontalface_default.xml")<br/>image = cv2.imread("kids.jpg")<br/>image = cv2.resize(image, (800,533))<br/>gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)</span></pre><p id="680d" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">读取的图像存储为多维numpy数组，如下所示。</p><pre class="lo lp lq lr gt nk nl nm nn aw no bi"><span id="71d8" class="np ma it nl b gy nq nr l ns nt">print(type(gray_image))<br/>&lt;class 'numpy.ndarray'&gt;</span></pre><p id="d52e" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">在下一步中，我们将gray_image作为输入传递给<em class="ll"> detectMultiScale </em>方法。</p><p id="0bf6" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated"><strong class="kr iu"><em class="ll">detect multi scale</em></strong>方法将为我们执行检测。它采用以下参数:</p><p id="18fd" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated"><strong class="kr iu"> scaleFactor : </strong>该参数指定图像缩小的因子，例如:-如果该值为1.05，则图像缩小5%。如果该值为1.10，则图像缩小10%。比例因子1.10比比例因子1.05需要更少的计算。</p><p id="b9a7" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated"><strong class="kr iu">最小邻居:</strong>这是一个阈值，指定每个矩形应该有多少个邻居才能被标记为真正。换句话说，让我们假设每次迭代标记某些矩形(即，将图像的一部分分类为面部)。现在，如果随后的迭代也将相同的区域标记为阳性，则增加了该矩形区域为真阳性的可能性。如果某个区域在一次迭代中被识别为人脸，但在任何其他迭代中没有被识别为人脸，则它们被标记为假阳性。换句话说，minNeighbors是一个区域被确定为一个面的最小次数。</p><p id="3f70" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">让我们做一个实验来更好地理解它。我们将使用不同的minNeighbors参数值运行我们的代码。</p><p id="f392" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">对于<strong class="kr iu"> minNeighbors = 0，</strong></p><p id="a281" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">所有的矩形都被检测为面。对于一些矩形，有许多重叠的矩形，这意味着这些矩形在多次迭代中被检测为阳性。我们设置阈值来提高算法的准确性。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="nv nw di nx bf ny"><div class="gh gi nz"><img src="../Images/7fad993c0591f4f3bd42f97335254a5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0VLH2xzM8kn_f9IEK8nDoA.jpeg"/></div></div><p class="lv lw gj gh gi lx ly bd b be z dk translated">minNeighbors = 0的阳性[图片来自<a class="ae lm" href="https://www.pexels.com/photo/people-girl-design-happy-35188/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>的<a class="ae lm" href="https://www.pexels.com/@bess-hamiti-83687?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">贝丝·哈米蒂</a></p></figure><p id="3bf8" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated"><strong class="kr iu">明邻= 2 </strong></p><p id="5973" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">当minNeighbors = 2时，大多数重叠矩形不再存在。然而，我们仍然有一些误报。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="nv nw di nx bf ny"><div class="gh gi nz"><img src="../Images/b3ed0f158aaf74c45dc868c84202bc2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3jOm1tE7OedsyLbBeB-x_Q.jpeg"/></div></div><p class="lv lw gj gh gi lx ly bd b be z dk translated">minNeighbors = 2的阳性[照片由<a class="ae lm" href="https://www.pexels.com/@bess-hamiti-83687?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">贝丝·哈米蒂</a>从<a class="ae lm" href="https://www.pexels.com/photo/people-girl-design-happy-35188/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">像素</a>拍摄]</p></figure><p id="fb05" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">如果我们将这个阈值增加到4或5，我们可以看到不再有假阳性。让我们将这个值设置为5，然后继续。</p><pre class="lo lp lq lr gt nk nl nm nn aw no bi"><span id="f1d8" class="np ma it nl b gy nq nr l ns nt">faces=face_cascade.detectMultiScale(gray_image,scaleFactor=1.10,minNeighbors=5)</span></pre><p id="30a9" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated"><strong class="kr iu"><em class="ll">detect multi scale</em></strong>方法返回一个numpy数组，其中包含面的矩形的尺寸和位置。</p><p id="5c41" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">x，y-矩形左上角的位置</p><p id="d658" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">w，h-矩形的宽度和高度</p><p id="ac53" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我们现在用绿色(0，255，0) (BGR色码)画一个矩形，边界厚度= 1。</p><p id="4c8b" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">该窗口等待2秒(2000毫秒)并自动关闭。</p><pre class="lo lp lq lr gt nk nl nm nn aw no bi"><span id="9ab1" class="np ma it nl b gy nq nr l ns nt">for x,y,w,h in faces:<br/>    image=cv2.rectangle(image, (x,y), (x+w, y+h), (0, 255, 0),1)<br/>    cv2.imshow("Face Detector", image)<br/>    k=cv2.waitKey(2000)<br/>cv2.destroyAllWindows()</span></pre><p id="f533" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">或者，我们也可以通过添加下面一行来保存图像。</p><pre class="lo lp lq lr gt nk nl nm nn aw no bi"><span id="da1c" class="np ma it nl b gy nq nr l ns nt">cv2.imwrite("kids_face_detected.jpeg", image)</span></pre><p id="f39e" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我们的输出图像现在在每个检测到的人脸周围包含一个绿色矩形。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="nv nw di nx bf ny"><div class="gh gi nz"><img src="../Images/39f5eabf69355edae79f8b4556455d2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*coA7YAgDYwd5osh6woBDPg.jpeg"/></div></div><p class="lv lw gj gh gi lx ly bd b be z dk translated">误报minNeighbors = 5[图片来自<a class="ae lm" href="https://www.pexels.com/@bess-hamiti-83687?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Bess Hamiti </a>来自<a class="ae lm" href="https://www.pexels.com/photo/people-girl-design-happy-35188/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a></p></figure><p id="acec" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我希望这篇文章能让您对如何在python中使用OpenCV进行人脸检测有一个基本的了解。我们也可以扩展这段代码来跟踪视频中的人脸。如果你感兴趣的话，我已经在我的GitHub储存库<a class="ae lm" href="https://github.com/arindomjit/Face_Detector" rel="noopener ugc nofollow" target="_blank">这里</a>上传了上面讨论的和用于跟踪网络摄像头视频中的人脸的完整代码。祝你有美好的一天！</p></div><div class="ab cl ki kj hx kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="im in io ip iq"><div class="lo lp lq lr gt oa"><a href="https://medium.com/@b.arindom/build-a-voice-controlled-mouse-keyboard-in-5-minutes-952bc8f101fc" rel="noopener follow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd iu gy z fp of fr fs og fu fw is bi translated">在5分钟内制作一个声控鼠标/键盘</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">Python中语音识别和GUI自动化的初学者指南</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">medium.com</p></div></div><div class="oj l"><div class="ok l ol om on oj oo lt oa"/></div></div></a></div><div class="op oq gp gr or oa"><a rel="noopener follow" target="_blank" href="/generate-qrcode-with-python-in-5-lines-42eda283f325"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd iu gy z fp of fr fs og fu fw is bi translated">用Python生成5行二维码</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">也许在你的简历中使用它来链接到你的网站或LinkedIn个人资料</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">towardsdatascience.com</p></div></div><div class="oj l"><div class="os l ol om on oj oo lt oa"/></div></div></a></div><div class="op oq gp gr or oa"><a href="https://medium.com/swlh/artificial-neural-networks-for-absolute-beginners-a75bc1522e1d" rel="noopener follow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd iu gy z fp of fr fs og fu fw is bi translated">绝对初学者的神经网络</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">用简单的英语介绍感知器</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">medium.com</p></div></div><div class="oj l"><div class="ot l ol om on oj oo lt oa"/></div></div></a></div></div><div class="ab cl ki kj hx kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="im in io ip iq"><p id="3560" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated"><strong class="kr iu">参考文献&amp;延伸阅读:</strong></p><p id="e2b4" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">[1]级联分类器，<a class="ae lm" href="https://docs.opencv.org/2.4/modules/objdetect/doc/cascade_classification.html" rel="noopener ugc nofollow" target="_blank">https://docs . opencv . org/2.4/modules/obj detect/doc/Cascade _ classification . html</a></p><p id="b1fe" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">[2] 5KK73 GPU分配，<a class="ae lm" href="https://sites.google.com/site/5kk73gpu2012/assignment/viola-jones-face-detection#TOC-Image-Pyramid" rel="noopener ugc nofollow" target="_blank">https://sites . Google . com/site/5kk 73 GPU 2012/Assignment/viola-Jones-face-detection</a></p><p id="c54d" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">[3] OpenCV Github页面，<a class="ae lm" href="https://github.com/opencv/opencv/tree/master/data/haarcascades" rel="noopener ugc nofollow" target="_blank">https://Github . com/OpenCV/OpenCV/tree/master/data/Haar cascades</a></p></div></div>    
</body>
</html>