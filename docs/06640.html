<html>
<head>
<title>Train a neural network in python to predict robot dynamics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 python 训练神经网络来预测机器人动力学</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/train-a-neural-network-to-predict-robot-dynamics-bd08fd589eca?source=collection_archive---------39-----------------------#2020-05-25">https://towardsdatascience.com/train-a-neural-network-to-predict-robot-dynamics-bd08fd589eca?source=collection_archive---------39-----------------------#2020-05-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="32b5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何处理真实的机器人数据。</h2></div><p id="63ba" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我作为机器人学习研究员的生活主要是数据科学(理解数据)和一点有趣的数学(强化学习)。这里有一个片段，你可以自己运行，并把经验带到你的项目(和职业生涯)中去！</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/210b46b83b7e1816e657286df5967aac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dzVSvxVd8B681db1mILdHg.png"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">一堆有趣的机器人平台，来自我的资格考试演讲。我们希望这些能飞起来！</p></figure><h1 id="837d" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">深度学习和机器人技术</h1><p id="f719" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">神经网络在多个数字领域，特别是计算机视觉和语言处理领域已经成为最先进的技术。神经网络是复杂的函数逼近(能够足够精确地拟合任何函数，从<a class="ae mr" href="https://en.wikipedia.org/wiki/Universal_approximation_theorem" rel="noopener ugc nofollow" target="_blank">一个有趣的定理</a>)，那么为什么不将它们用于机器人呢？</p><p id="ba42" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在机器人中，我们想为两件事建立动力学模型:</p><ol class=""><li id="df91" class="ms mt it kk b kl km ko kp kr mu kv mv kz mw ld mx my mz na bi translated"><strong class="kk iu">计划采取行动</strong>。行动完成任务。这就制造出了有用的机器人。我们都想要有用的机器人。</li><li id="c42b" class="ms mt it kk b kl nb ko nc kr nd kv ne kz nf ld mx my mz na bi translated"><strong class="kk iu">了解系统</strong>。了解该系统可以为机器人开辟更多的未来行动和任务。</li></ol><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/660843bdc1eb98903104b778e2cb7fba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/format:webp/1*lve6f0F1Vbo9NQ5c_x348g.png"/></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">经典的神经网络图解。密集连接的非线性激活函数可以适合任何具有足够数量神经元的函数。</p></figure><h2 id="9045" class="nh lv it bd lw ni nj dn ma nk nl dp me kr nm nn mg kv no np mi kz nq nr mk ns bi translated">最优化问题</h2><p id="67b6" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">当用神经网络学习时，将预测系统动态中的离散步骤。动态系统采取如下所示的形式:</p><ul class=""><li id="0e7d" class="ms mt it kk b kl km ko kp kr mu kv mv kz mw ld nt my mz na bi translated"><strong class="kk iu"> <em class="nu"> s </em> </strong>是系统的状态(如物理位置)。</li><li id="a54e" class="ms mt it kk b kl nb ko nc kr nd kv ne kz nf ld nt my mz na bi translated"><strong class="kk iu"> <em class="nu">一个</em> </strong>是代理的动作(如电机电压)。</li><li id="1ae9" class="ms mt it kk b kl nb ko nc kr nd kv ne kz nf ld nt my mz na bi translated"><strong class="kk iu"> <em class="nu"> f </em> </strong>是机器人的真实动力学。</li><li id="0ca2" class="ms mt it kk b kl nb ko nc kr nd kv ne kz nf ld nt my mz na bi translated"><strong class="kk iu"> <em class="nu"> w </em> </strong>是扰动(随机性，或系统的未建模部分)。</li></ul><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi nv"><img src="../Images/f4cf2c63aa54c4cfd6dc9d0af8c6bb0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Etz_bdeG8ga9j0y8JlrYdA.png"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">动力系统的一般形式。</p></figure><p id="33bb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将用神经网络(有意地)建模的是底层函数，<strong class="kk iu"> <em class="nu"> f </em> </strong>，我们隐式地捕捉数据中的扰动，<strong class="kk iu"> <em class="nu"> w </em> </strong>。我们如何做到这一点？为了数据的“美观”,我们做了几件事。精确意味着数据接近均匀分布，平均值为 0，标准偏差为 1。</p><div class="lf lg lh li gt ab cb"><figure class="nw lj nx ny nz oa ob paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><img src="../Images/6bce2d9e809651140b502d857bc32c77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*cFy8gB6k35AAbArenQuRGg.png"/></div></figure><figure class="nw lj oc ny nz oa ob paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><img src="../Images/2233ae4e45fd56ea5fd6f24466b5ac15.png" data-original-src="https://miro.medium.com/v2/resize:fit:218/format:webp/1*xnh5veMa8E9Rl9IXaxSxJQ.png"/></div></figure><figure class="nw lj od ny nz oa ob paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><img src="../Images/bccf55e40697d058a0535d1c93012f6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*bPRSRO8AykSFypIvM3ywAg.png"/></div><p class="lq lr gj gh gi ls lt bd b be z dk oe di of og translated">我们对学习到的动力学(用θ下标表示)进行建模，以预测状态的变化，而不是真实的状态。右边的 delta 状态是从上一个时间步到下一个时间步的简单变化。</p></figure></div><p id="4105" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在神经网络的环境中，这看起来像什么？具体来说，我们可以最小化状态变化和函数逼近之间的差的范数平方。这是一个<strong class="kk iu">均方差</strong>。在 PyTorch <a class="ae mr" href="https://pytorch.org/docs/master/generated/torch.nn.MSELoss.html" rel="noopener ugc nofollow" target="_blank">这里</a>实现。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi oh"><img src="../Images/43e53281c2fc63b111f553d3f2384564.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6baSw1ioUHJzQBEiFK8-0g.png"/></div></div></figure><p id="48b1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最先进的技术是使用像<a class="ae mr" href="https://arxiv.org/abs/1412.6980" rel="noopener ugc nofollow" target="_blank"> Adam 优化器</a>、<a class="ae mr" href="https://arxiv.org/abs/1710.05941" rel="noopener ugc nofollow" target="_blank"> Swish 激活函数</a>(ReLU 的平滑版本)、学习率<a class="ae mr" href="https://arxiv.org/abs/1710.05941" rel="noopener ugc nofollow" target="_blank">调度器</a>等等。让神经网络工作的重要方法是数据标准化。如果你仔细看代码，我用一种非常模块化的方式处理它。没有它，将模型拟合到真实数据几乎是不可能的。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi oi"><img src="../Images/7fcf9a690a09ff02afd5b48685e834e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JZnpNAcJ5YzkZL8dPAzWoA.png"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">我玩的机器人——底部)<a class="ae mr" href="https://arxiv.org/abs/1901.03737" rel="noopener ugc nofollow" target="_blank"> Crazyflie </a>微型飞行器和顶部)<a class="ae mr" href="https://people.eecs.berkeley.edu/~ddrew73/files/RAL18.pdf" rel="noopener ugc nofollow" target="_blank"> Ionocraft </a>离子推进器。</p></figure><h1 id="44de" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">代码(PyTorch)</h1><p id="7fe8" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">这就是你如何运行<a class="ae mr" href="https://github.com/natolambert/dynamicslearn/blob/master/learn/trainer.py" rel="noopener ugc nofollow" target="_blank">代码</a>。我包含了一个名为<em class="nu"> ml </em>的 conda 环境(PyTorch，AI Gym，Mujoco 等等)。培训师代码可在学习目录中找到。参数存储在配置文件中。</p><pre class="lf lg lh li gt oj ok ol om aw on bi"><span id="d467" class="nh lv it ok b gy oo op l oq or">(ml) user: dynamicslearn nato$ python learn/trainer.py robot=iono_sim</span></pre><h2 id="8449" class="nh lv it bd lw ni nj dn ma nk nl dp me kr nm nn mg kv no np mi kz nq nr mk ns bi translated">机器人</h2><p id="e5b6" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">知识库中有经过预过滤的数据，这些数据来自通过强化学习学习控制的实验机器人的真实飞行。它是加州大学伯克利分校的一个活跃的研究资料库。</p><p id="213a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">代码包括两个飞行机器人的模拟器，分别是<a class="ae mr" href="https://arxiv.org/abs/1901.03737" rel="noopener ugc nofollow" target="_blank"> Crazyflie </a>和<a class="ae mr" href="https://people.eecs.berkeley.edu/~ddrew73/files/RAL18.pdf" rel="noopener ugc nofollow" target="_blank"> Ionocraft </a>。这两个都允许你以 100 赫兹控制机器人，模拟器以 1000 赫兹计算动力学。你可以在这里找到动态模拟器<a class="ae mr" href="https://github.com/natolambert/dynamicslearn/blob/master/learn/envs/rigidbody.py" rel="noopener ugc nofollow" target="_blank">。特定的机器人为不同的致动器定义力的转换。</a></p><h2 id="69b5" class="nh lv it bd lw ni nj dn ma nk nl dp me kr nm nn mg kv no np mi kz nq nr mk ns bi translated">丰富 NN 对象</h2><p id="96de" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">当处理复杂任务时(弄清楚如何为机器人建模)，拥有一个可配置的网络对象会有所帮助。你会在这里看到一系列的旗帜:</p><ul class=""><li id="c853" class="ms mt it kk b kl km ko kp kr mu kv mv kz mw ld nt my mz na bi translated">一个<em class="nu"> prob </em>标志——它从 MSE 变成了一个高级损失函数，具有来自<a class="ae mr" href="http://papers.nips.cc/paper/7725-deep-reinforcement-learning-in-a-handful-of-trials-using-probabilistic-dynamics-models.pdf" rel="noopener ugc nofollow" target="_blank">的更好的方差正则化。</a></li><li id="6c62" class="ms mt it kk b kl nb ko nc kr nd kv ne kz nf ld nt my mz na bi translated">一个<em class="nu">历史</em>参数——我们希望将过去的状态传递到预测器中(当状态进化得更快时，一些潜在的动态就会进化)。</li><li id="1c19" class="ms mt it kk b kl nb ko nc kr nd kv ne kz nf ld nt my mz na bi translated">一堆<em class="nu">参数</em> — <em class="nu">隐藏宽度、深度、落差等。</em></li><li id="9a6e" class="ms mt it kk b kl nb ko nc kr nd kv ne kz nf ld nt my mz na bi translated">SciKitLearn <em class="nu">规范化标量</em>——对于获得可行的优化表面非常重要(没有这个你可能会得到 NaN 的)。</li></ul><p id="cdb8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="nu">注意，我用</em> <strong class="kk iu"> <em class="nu"> X </em> </strong> <em class="nu">表示状态，用</em> <strong class="kk iu"> <em class="nu"> U </em> </strong> <em class="nu">表示动作。</em></p><pre class="lf lg lh li gt oj ok ol om aw on bi"><span id="73f6" class="nh lv it ok b gy oo op l oq or">class GeneralNN(nn.Module):<br/>    def __init__(self, **nn_params):<br/>        super(GeneralNN, self).__init__()<br/>        # Store the parameters:<br/>        self.prob = nn_params['training']['probl']<br/>        self.hidden_w = nn_params['training']['hid_width']<br/>        self.depth = nn_params['training']['hid_depth']</span><span id="bdec" class="nh lv it ok b gy os op l oq or">        self.hist = nn_params['history']<br/>        self.n_in_input = nn_params['du'] * (self.hist + 1) <br/>        self.n_in_state = nn_params['dx'] * (self.hist + 1)<br/>        self.n_in = self.n_in_input + self.n_in_state<br/>        self.n_out = nn_params['dt']</span><span id="ca60" class="nh lv it ok b gy os op l oq or">        self.activation = Swish()  <br/>        self.d = nn_params['training']['dropout']<br/>        self.E = 0  # clarify that these models are not ensemble</span><span id="ccfa" class="nh lv it ok b gy os op l oq or">        self.scalarX = StandardScaler()  <br/>        self.scalarU = MinMaxScaler(feature_range=(-1, 1))<br/>        self.scalardX = MinMaxScaler(feature_range=(-1, 1))</span><span id="28e0" class="nh lv it ok b gy os op l oq or">        self.init_training = False</span></pre><h2 id="3b1e" class="nh lv it bd lw ni nj dn ma nk nl dp me kr nm nn mg kv no np mi kz nq nr mk ns bi translated">动态创建层</h2><p id="08d3" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">对于 PyTorch 新手来说，这可能是文章中最有用的部分。它让你创建一个不同深度和宽度的网络(另一种方法是对配置进行硬编码)。</p><pre class="lf lg lh li gt oj ok ol om aw on bi"><span id="12a8" class="nh lv it ok b gy oo op l oq or">        layers = []<br/>        layers.append(('dynm_input_lin', nn.Linear(<br/>            self.n_in, self.hidden_w)))  # input layer<br/>        layers.append(('dynm_input_act', self.activation))<br/>        for d in range(self.depth):<br/>            layers.append(<br/>                ('d_l' + str(d), nn.Linear(self.hid_w, self.hid_w)))<br/>            layers.append(('dynm_act_' + str(d), self.activation))<br/>        layers.append(('d_o_l', nn.Linear(self.hid_w, self.n_out)))<br/>        self.features = nn.Sequential(OrderedDict([*layers]))</span></pre><h2 id="90e4" class="nh lv it bd lw ni nj dn ma nk nl dp me kr nm nn mg kv no np mi kz nq nr mk ns bi translated">训练模型</h2><p id="9ef5" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">省略公开可用的优化器代码，以及在许多教程中详述的<a class="ae mr" href="https://pytorch.org/tutorials/beginner/blitz/neural_networks_tutorial.html" rel="noopener ugc nofollow" target="_blank">，我们可以有一个很好的训练函数作为我们的顶级对象。让较低层次的抽象来处理细节。</a></p><pre class="lf lg lh li gt oj ok ol om aw on bi"><span id="5904" class="nh lv it ok b gy oo op l oq or">def train_model(X, U, dX, model_cfg, logged=False):<br/>    if logged: log.info(f"Training Model on {np.shape(X)[0]} pts")<br/>    start = time.time()<br/>    train_log = dict()</span><span id="aa9f" class="nh lv it ok b gy os op l oq or">    train_log['model_params'] = model_cfg.params<br/>    model = hydra.utils.instantiate(model_cfg)</span><span id="8a77" class="nh lv it ok b gy os op l oq or">    model.train_cust((X_t, U_t, dX_t), model_cfg.params)</span><span id="c815" class="nh lv it ok b gy os op l oq or">    end = time.time()<br/>    if logged: log.info(f"Trained Model in {end-start} s")<br/>    return model, train_log</span></pre><p id="47d2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">神经网络代码<a class="ae mr" href="https://github.com/natolambert/dynamicslearn/blob/master/learn/models/model_general_nn.py" rel="noopener ugc nofollow" target="_blank">在这里</a>。训练脚本<a class="ae mr" href="https://github.com/natolambert/dynamicslearn/blob/master/learn/trainer.py" rel="noopener ugc nofollow" target="_blank">在这里</a>。整体代码<a class="ae mr" href="https://github.com/natolambert/dynamicslearn" rel="noopener ugc nofollow" target="_blank">在这里</a>。</p></div><div class="ab cl ot ou hx ov" role="separator"><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy"/></div><div class="im in io ip iq"><p id="f075" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个存储库还有更多的功能。我很乐意回答问题、提出请求和反馈。或者你可以在这里了解我的研究<a class="ae mr" href="https://drive.google.com/file/d/1zINn9Uj9vGita_NIPqpWS1cSH79twNJB/view?usp=sharing" rel="noopener ugc nofollow" target="_blank">。</a></p><div class="pa pb gp gr pc pd"><a href="https://github.com/natolambert/dynamicslearn" rel="noopener  ugc nofollow" target="_blank"><div class="pe ab fo"><div class="pf ab pg cl cj ph"><h2 class="bd iu gy z fp pi fr fs pj fu fw is bi translated">NATO Lambert/动态学习</h2><div class="pk l"><h3 class="bd b gy z fp pi fr fs pj fu fw dk translated">我在新型机器人的基于模型的强化学习方面的工作目录。最适合高考验的机器人…</h3></div><div class="pl l"><p class="bd b dl z fp pi fr fs pj fu fw dk translated">github.com</p></div></div><div class="pm l"><div class="pn l po pp pq pm pr lo pd"/></div></div></a></div><div class="pa pb gp gr pc pd"><a href="https://robotic.substack.com/" rel="noopener  ugc nofollow" target="_blank"><div class="pe ab fo"><div class="pf ab pg cl cj ph"><h2 class="bd iu gy z fp pi fr fs pj fu fw is bi translated">自动化大众化</h2><div class="pk l"><h3 class="bd b gy z fp pi fr fs pj fu fw dk translated">一个关于机器人和人工智能的博客，让它们对每个人都有益，以及即将到来的自动化浪潮…</h3></div><div class="pl l"><p class="bd b dl z fp pi fr fs pj fu fw dk translated">robotic.substack.com</p></div></div><div class="pm l"><div class="ps l po pp pq pm pr lo pd"/></div></div></a></div></div></div>    
</body>
</html>