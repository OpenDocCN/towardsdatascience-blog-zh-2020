<html>
<head>
<title>Using the Spark Aggregator class in Scala</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 Scala 中使用 Spark 聚合器类</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/using-the-spark-aggregator-class-in-scala-341ee8bb46e5?source=collection_archive---------15-----------------------#2020-04-16">https://towardsdatascience.com/using-the-spark-aggregator-class-in-scala-341ee8bb46e5?source=collection_archive---------15-----------------------#2020-04-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="fb4f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">注意:</strong>如果你已经理解了<code class="fe ko kp kq kr b">Aggregator</code>类，并且只是想看看它是如何在 Scala 中实现的例子，请随意跳到“<em class="ks">使用我们的聚合器</em>”部分。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/1c9057c0a0c5dc64e6afb76b04514ada.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JS1jttKlhdNYHV0P"/></div></div><p class="lf lg gj gh gi lh li bd b be z dk translated">马库斯·温克勒在<a class="ae lj" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="b589" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated"><strong class="ak">类型安全聚合</strong></h1><p id="d364" class="pw-post-body-paragraph jq jr it js b jt mi jv jw jx mj jz ka kb mk kd ke kf ml kh ki kj mm kl km kn im bi translated"><strong class="js iu"> <em class="ks">它们是什么？</em>T15】</strong></p><p id="d057" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你在机场的行李认领处等你的行李。你内心的混乱正在加剧，因为大多数其他乘客现在已经收到了他们的行李，你肯定不想丢失你的衣服、化妆品或你托运的那瓶豪华精酿啤酒。就在你开始绝望的时候，你看到了它:一个大而亮的橙色行李箱，显然是你的。你兴高采烈地把它捡起来，微笑开始掠过你的脸庞——直到你注意到从拉链上滴下来的水滴。然后又是一个。另一个。虽然袋子本身和你托运时一样，但是里面的东西都湿透了。你不禁好奇，<em class="ks">这是什么时候的事？是飞机里的低压吗？它是从手推车上掉下来的吗？我应该用气泡包装吗？不幸的是，你真的没有任何办法知道。虽然你应该用气泡包装。</em></p><p id="f5fb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当数据科学家在 Spark 中对数据集执行聚合时，也会有类似的苦恼，只是输出数据集的内容以某种方式显示为无效；也许输入和输出都是完整的数据集，但输出的内容类型有些不正确。聚合的内部机制以及哪里出了问题通常只能在大量的检测工作之后才能得到诊断。即使这样，也不能保证输入数据的未来实例不会给聚合带来另一个问题。</p><p id="8e83" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，就像添加更多的气泡包装以防止瓶子在您的手提箱中破碎一样，我们可以使用 Spark 的<code class="fe ko kp kq kr b">Aggregator</code>类创建强类型化的自定义聚合。这个类允许数据科学家准确地指定 worker 节点执行什么转换，如何跨节点组合数据，以及每个步骤在预期的输入和输出类型方面应该包含什么。结果是对聚合转换是如何执行的有了深入的了解，并且有了一种自动的方法来诊断可能出现的任何类型问题。换句话说，这是一个万无一失的方法，可以让你下次坐飞机时省下一瓶啤酒。</p><p id="b97e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="ks">何时使用类型安全聚合</em> </strong></p><p id="fcc8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">决定是否对 Spark 数据集执行类型安全聚合可能是一个困难的决定。一方面，很容易就豁出去了，把输入输出类型声明为<code class="fe ko kp kq kr b">Dataset</code>，就到此为止。根据我的经验，这适用于数据科学家可能遇到的许多探索和分析实例，因为数据和类型验证可以在笔记本或脚本环境中动态执行。</p><p id="7d7b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一方面，在有些情况下(例如生产中的自动化 ML 管道，为其他数据科学家创建 API ),您需要确保转换不会在没有警告的情况下产生意外的和潜在的错误结果。这些是您想要在 Spark 中使用<a class="ae lj" href="https://spark.apache.org/docs/2.0.2/api/java/org/apache/spark/sql/expressions/Aggregator.html" rel="noopener ugc nofollow" target="_blank">聚合器</a>类的情况。该类允许数据科学家在执行某种类型的自定义聚合时识别输入、中间和输出类型。</p><p id="8469" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一次遇到的时候发现 Spark 的<code class="fe ko kp kq kr b">Aggregator</code>类有些混乱。有几个步骤，看似不用的参数，网上例子有限。我见过的大多数例子都倾向于描述简单的用例，比如对一组整数求和或者计算平均值。虽然这些对于同义反复来说肯定是有用的，但是它们并没有提供对可能需要执行的其他常见聚合的更多了解。因此，我在这里的目的是演示<code class="fe ko kp kq kr b">Aggregator</code>类的两种<em class="ks">用法，人们可能会在编写数据预处理应用程序时实际使用它们，并逐行分解它们。</em></p><h1 id="9cdb" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated"><strong class="ak">安`</strong>T3<strong class="ak">例</strong></h1><p id="eaae" class="pw-post-body-paragraph jq jr it js b jt mi jv jw jx mj jz ka kb mk kd ke kf ml kh ki kj mm kl km kn im bi translated">让我们假设您有以下家装商店的零售数据</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="mn mo l"/></div><p class="lf lg gj gh gi lh li bd b be z dk translated">我们的五金店数据集。</p></figure><p id="ea06" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">并希望以类型安全的方式执行以下操作:</p><ul class=""><li id="ace6" class="mp mq it js b jt ju jx jy kb mr kf ms kj mt kn mu mv mw mx bi translated">统计每个<code class="fe ko kp kq kr b">retailCategory</code>中有多少独立客户</li><li id="cf3f" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn mu mv mw mx bi translated">收集唯一的<code class="fe ko kp kq kr b">productID</code>数组，按<code class="fe ko kp kq kr b">retailCategory</code>分组</li><li id="d090" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn mu mv mw mx bi translated">将上述数据转换成包含前两步的<code class="fe ko kp kq kr b">Dataset</code></li></ul><p id="f269" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们假设我们想要使用下面的通用结构来实现我们的聚合器:</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="b10f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将导致数据科学家在使用我们的库时调用以下 API:</p><pre class="ku kv kw kx gt nd kr ne nf aw ng bi"><span id="1088" class="nh ll it kr b gy ni nj l nk nl">val myValue = DoSomething.transformData(…)</span></pre><p id="0eaa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意，我们正在创建一个对象，其中包含我们希望用来执行聚合的方法，以及我们希望在该方法中使用的两个聚合器。这与我在网上看到的许多其他例子不同，原因有二。首先，我们试图创建一个 API 供数据科学家在数据预处理阶段使用，而不是创建一个工作流来调用某个<code class="fe ko kp kq kr b">mainApp</code>对象。其次，我们正在构建两个以上的由同一个转换使用的聚合器。</p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><p id="1107" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们的待办事项列表上的第一项是导入<code class="fe ko kp kq kr b">Aggregator</code>类、<code class="fe ko kp kq kr b">ExpressionEncoder</code>类，为上面显示的输入数据模式创建一个<code class="fe ko kp kq kr b">case class</code>，并为我们的输出模式创建另一个<code class="fe ko kp kq kr b">case class</code>:</p><pre class="ku kv kw kx gt nd kr ne nf aw ng bi"><span id="86e5" class="nh ll it kr b gy ni nj l nk nl">import org.apache.spark.sql.expressions.Aggregator<br/>import org.apache.spark.sql.catalyst.encoders.ExpressionEncoder</span><span id="1f5c" class="nh ll it kr b gy nt nj l nk nl">// input schema<br/>case class RetailByCustomer(customerID: String,<br/>  productID: String,<br/>  retailCategory: String)</span><span id="036a" class="nh ll it kr b gy nt nj l nk nl">// output schema<br/>case class AggRetailByCategory(retailCategory: String, <br/>  customerCount:Int,<br/>  productSet: Set[String])</span></pre><p id="80ca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">注意</strong>:我们需要导入<code class="fe ko kp kq kr b">ExpressionEncoder</code>类来为<code class="fe ko kp kq kr b">Set[String]</code>类型定义我们自己的编码器，因为这不是 Scala 中的默认编码器。</p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><p id="9a03" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们开始写我们的聚合器。我现在将完整地展示这两种方法，然后逐行分解。</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="mn mo l"/></div><p class="lf lg gj gh gi lh li bd b be z dk translated">我们的两个聚合器。</p></figure><p id="b0fc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如您可能从值名中推断的那样，我们的第一个聚合器提供了不同客户的计数。这是通过将每个客户添加到一个<code class="fe ko kp kq kr b">Set</code>来完成的，因为集合只包含任何给定值的一个实例。在这种情况下使用不同的计数也很重要，以避免在传入数据可能包含重复值或没有映射到任何<code class="fe ko kp kq kr b">retailCategory</code>的<code class="fe ko kp kq kr b">productID</code>值的情况下出现过度计数。现在，让我们看看第一行:</p><pre class="ku kv kw kx gt nd kr ne nf aw ng bi"><span id="709a" class="nh ll it kr b gy ni nj l nk nl">val distinctCustomerCountAggregator: <br/>  TypedColumn[RetailByCustomer, Int] = new<br/>    Aggregator[RetailByCustomer, Set[String], Int]</span></pre><p id="709b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里我们声明一个值，该值将返回一个具有预期输入(<code class="fe ko kp kq kr b">RetailByCustomer</code> —一个<a class="ae lj" href="https://jaceklaskowski.gitbooks.io/mastering-spark-sql/spark-sql-Expression.html" rel="noopener ugc nofollow" target="_blank">表达式</a>)和预期输出(<code class="fe ko kp kq kr b">Int</code> —一个<a class="ae lj" href="https://jaceklaskowski.gitbooks.io/mastering-spark-sql/spark-sql-ExpressionEncoder.html" rel="noopener ugc nofollow" target="_blank">表达式编码器</a>)的<a class="ae lj" href="https://spark.apache.org/docs/2.2.1/api/java/org/apache/spark/sql/TypedColumn.html" rel="noopener ugc nofollow" target="_blank"> TypedColumn </a>。我们将这个值设置为一个新的<code class="fe ko kp kq kr b">Aggregator</code>，并定义输入类型(<code class="fe ko kp kq kr b">RetailByCustomer</code>)、中间类型(<code class="fe ko kp kq kr b">Set[String]</code>)和输出类型(<code class="fe ko kp kq kr b">Int</code>)。也就是说，这个聚合器将接受在我们的<code class="fe ko kp kq kr b">RetailByCustomer</code> case 类中定义的某种类型，执行某种类型的转换，这将产生一个<code class="fe ko kp kq kr b">Set[String]</code>类型，并在聚合后返回类型<code class="fe ko kp kq kr b">Int</code>的某个值。</p><p id="f333" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在来看函数的实质。但首先，这里有一只小狗来打破单调，让你的灵魂稍微清醒一下。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi nu"><img src="../Images/52a3f9c90f3d567fa140eec4baf04813.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JHMDoW_aJJ7aQNp2"/></div></div><p class="lf lg gj gh gi lh li bd b be z dk translated"><a class="ae lj" href="https://unsplash.com/@freestocks?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">自由股票</a>在<a class="ae lj" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="1393" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您正在阅读本文，您可能知道 Spark 是一个以分布式方式执行数据转换的框架，因此您可能知道有一个主节点向工作节点执行器发送任务来执行数据转换。但是，在对整个数据集执行聚合时，您会向工作节点发送哪些任务来协同工作呢？</p><p id="3a11" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我喜欢从高层次<em class="ks">考虑这个问题</em>从单个工人节点开始。<code class="fe ko kp kq kr b">Aggregator</code>类将任务发送给单个工作节点(以及该作业的所有其他活动工作节点)上的执行器，说明如何开始聚合:</p><pre class="ku kv kw kx gt nd kr ne nf aw ng bi"><span id="4b8d" class="nh ll it kr b gy ni nj l nk nl">override def zero: Set[String] = Set[String]()</span></pre><p id="d123" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">也就是说，在我们的例子中，每个 worker 节点应该用一个类型为<code class="fe ko kp kq kr b">String</code>的空集开始聚合。</p><p id="c86c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，<code class="fe ko kp kq kr b">Aggregator</code>类告诉每个 worker 节点如何处理它在内存中的数据:</p><pre class="ku kv kw kx gt nd kr ne nf aw ng bi"><span id="feda" class="nh ll it kr b gy ni nj l nk nl">override def reduce(es: Set[String], rbc: RetailByCustomer):<br/>  Set[String] = es + rbc.customerID</span></pre><p id="be44" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们的<code class="fe ko kp kq kr b">reduce</code>定义中的指令告诉每个 worker 节点期待来自上一步的“空集”<code class="fe ko kp kq kr b">es</code>和上面定义的<code class="fe ko kp kq kr b">RetailByCustomer</code> case 类<code class="fe ko kp kq kr b">rbc</code>的输入。此外，每个 worker 节点上的这个转换的输出将会产生一个期望的类型<code class="fe ko kp kq kr b">Set[String]</code>。最后，定义了在每个 worker 节点上发生的实际转换。每个存储为类型<code class="fe ko kp kq kr b">RetailByCustomer.customerID</code>(我们定义为<code class="fe ko kp kq kr b">String</code>)的内存值被添加到现有的空集，从而产生一个包含不同客户 id 的<code class="fe ko kp kq kr b">Set[String]</code>。</p><p id="c5ce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了在实践中看到这一点，假设我们的数据已经由<code class="fe ko kp kq kr b">retailCategory</code>进行了分区，这样关于“照明”和“园艺”的信息存储在一个 worker 节点上，“空调”和“清洁”存储在第二个节点上，而“油漆”存储在第三个节点上。每个节点上的结果集应该如下所示:</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi nv"><img src="../Images/136c356a850bf0422ce9d60614473fcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SdY-uwql5crcBeE8_PZVww.png"/></div></div></figure><p id="2c72" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">既然已经在每个工作者节点上执行了寻找唯一的<code class="fe ko kp kq kr b">customerID</code>的转换，那么<code class="fe ko kp kq kr b">Aggregator</code>类必须指示工作者节点如何相互交互，以便在节点上寻找唯一的<code class="fe ko kp kq kr b">customerID</code> s <em class="ks">。这让我们想到了<code class="fe ko kp kq kr b">merge</code>的定义:</em></p><pre class="ku kv kw kx gt nd kr ne nf aw ng bi"><span id="7fed" class="nh ll it kr b gy ni nj l nk nl">override def merge(wx: Set[String], wy: Set[String]): <br/>  Set[String] = wx.union(wy)</span></pre><p id="730e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，我们将两个预期输入定义为类型<code class="fe ko kp kq kr b">Set[String]</code>；一个来自“工人 X”(<code class="fe ko kp kq kr b">wx</code>)，一个来自“工人 Y”(<code class="fe ko kp kq kr b">wy</code>)。同样，我们将预期的输出类型定义为<code class="fe ko kp kq kr b">Set[String]</code>。最后，<code class="fe ko kp kq kr b">Aggregator</code>类必须给出每个 worker 节点在与其他节点交互时应该做什么的指令。在这种情况下，我们告诉每个工人将来自<code class="fe ko kp kq kr b">reduce</code>步骤的输出与另一个工人的<code class="fe ko kp kq kr b">reduce</code>输出合并(即返回两个集合之间的所有元素)。</p><p id="4aee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虽然信息在工作节点之间传递的方式有很多细微差别，但是为了理解<code class="fe ko kp kq kr b">Aggregator</code>类，我们可以将<code class="fe ko kp kq kr b">merge</code>步骤的输出可视化如下:</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi nw"><img src="../Images/512f711f5dca76718d0f79c1bede243d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5xdOKT1dnqgNG8VQOORMLg.png"/></div></div><p class="lf lg gj gh gi lh li bd b be z dk translated">假设如果我们的 workers 节点没有联合结果，它们将返回什么。</p></figure><p id="dd9c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将导致类型<code class="fe ko kp kq kr b">Set[String]</code>的输出“集合(“001”、“005”、“003”、“004”、“002”)”。</p><p id="e604" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下一步<code class="fe ko kp kq kr b">finish</code>，为驾驶员提供执行动作的指令:</p><pre class="ku kv kw kx gt nd kr ne nf aw ng bi"><span id="1a72" class="nh ll it kr b gy ni nj l nk nl">override def finish(reduction: Set[String]): Int = reduction.size</span></pre><p id="08c8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，我们将期望的输入类型定义为我们的<code class="fe ko kp kq kr b">union</code> ed <code class="fe ko kp kq kr b">Set[String]</code>，期望的输出类型定义为<code class="fe ko kp kq kr b">Int</code>。我们还通过调用<code class="fe ko kp kq kr b">size</code>方法定义了对<code class="fe ko kp kq kr b">Set[String]</code>输入采取的动作，该方法返回一个表示集合中项目数量的整数。在我们的例子中，这会返回<code class="fe ko kp kq kr b">5</code>。</p><p id="b27c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后一步是为我们的缓冲(或中间)步骤和输出步骤定义<code class="fe ko kp kq kr b">Encoder</code>:</p><pre class="ku kv kw kx gt nd kr ne nf aw ng bi"><span id="d489" class="nh ll it kr b gy ni nj l nk nl">override def bufferEncoder: Encoder[Set[String]] =<br/>  implicitly(ExpressionEncoder[Set[String]])</span><span id="10c8" class="nh ll it kr b gy nt nj l nk nl">override def outputEncoder: Encoder[Int] =<br/>  implicitly(Encoders.scalaInt)</span></pre><p id="ca99" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ko kp kq kr b">distinctCustomerCountAggregator</code>的输出是一个<code class="fe ko kp kq kr b">Int</code>，它在 Scala 中有一个预定义的编码器。因此，我们可以在定义我们的<code class="fe ko kp kq kr b">outputEncoder</code>时简单地调用<code class="fe ko kp kq kr b">Encoders.scalaInt</code>，并隐式地将它传递给其他定义。然而，尽管<code class="fe ko kp kq kr b">Set</code>和<code class="fe ko kp kq kr b">String</code>在 Scala 中都有预定义的编码器，但是<code class="fe ko kp kq kr b">Set[String]</code>没有。因此，我们必须使用第一步中导入的<code class="fe ko kp kq kr b">ExpressionEncoder</code>类定义我们自己的<code class="fe ko kp kq kr b">Set[String]</code>编码器。</p><p id="d485" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ko kp kq kr b">productIDAggregator</code>实际上与<code class="fe ko kp kq kr b">distinctCustomerCountAggregator</code>非常相似，除了一个关键的区别:我们期望的是<code class="fe ko kp kq kr b">Set[String]</code>类型的输出，而不是<code class="fe ko kp kq kr b">Int</code>。这将改变几个步骤。</p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><p id="fd8e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">练习</strong> : <em class="ks">如果你正在全文阅读这篇文章，我鼓励你在继续下一步之前，思考哪些步骤需要改变以促进这一点(提示:有 3 个)。</em></p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><p id="eb47" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一个区别是将<code class="fe ko kp kq kr b">TypedColumn</code>和预期<code class="fe ko kp kq kr b">Aggregator</code>输出类型都改为<code class="fe ko kp kq kr b">Set[String]</code>:</p><pre class="ku kv kw kx gt nd kr ne nf aw ng bi"><span id="908a" class="nh ll it kr b gy ni nj l nk nl">val productIDAggregator: <br/>  TypedColumn[RetailByCustomer, Set[String]] =<br/>    new Aggregator[RetailByCustomer, Set[String], Set[String]]</span></pre><p id="451e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来的三个步骤对于两个聚合器来说实际上是相同的:我们指示工作节点创建空集，向这些集合添加<code class="fe ko kp kq kr b">productID</code> s，并联合它们自己得到的集合。</p><p id="5381" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，第二个区别出现在<code class="fe ko kp kq kr b">finish</code>定义中。我们希望将预期的输出类型从<code class="fe ko kp kq kr b">Int</code>改为<code class="fe ko kp kq kr b">Set[String]</code>，并删除<code class="fe ko kp kq kr b">size</code>方法，因为我们只想返回实际的一组<code class="fe ko kp kq kr b">productID</code> s:</p><pre class="ku kv kw kx gt nd kr ne nf aw ng bi"><span id="c9b4" class="nh ll it kr b gy ni nj l nk nl">override def finish(reduction: Set[String]): Set[String] = reduction</span></pre><p id="44b0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，我们需要改变<code class="fe ko kp kq kr b">outputEncoder</code>。由于在这种情况下我们没有真正在类型之间转换，我们的<code class="fe ko kp kq kr b">bufferEncoder</code>和<code class="fe ko kp kq kr b">outputEncoder</code>将是相同的:</p><pre class="ku kv kw kx gt nd kr ne nf aw ng bi"><span id="239a" class="nh ll it kr b gy ni nj l nk nl">override def bufferEncoder: Encoder[Set[String]] =<br/>  implicitly(ExpressionEncoder[Set[String]])</span><span id="c198" class="nh ll it kr b gy nt nj l nk nl">override def outputEncoder: Encoder[Set[String]] =<br/>  implicitly(ExpressionEncoder[Set[String]])</span></pre><p id="87c1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">就是这样！我们已经创建了两个执行两种不同功能的聚合器！</p><h1 id="502a" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated"><strong class="ak">使用我们的聚合器</strong></h1><p id="9acf" class="pw-post-body-paragraph jq jr it js b jt mi jv jw jx mj jz ka kb mk kd ke kf ml kh ki kj mm kl km kn im bi translated">为了在实践中使用这些，让我们看一下完整的代码:</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="0288" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">编译并发布上述代码后，数据科学家可以在构建数据转换管道时调用以下代码(或者您可以在文件底部调用它):</p><pre class="ku kv kw kx gt nd kr ne nf aw ng bi"><span id="5e7c" class="nh ll it kr b gy ni nj l nk nl">import com.wherever.code.is.PreprocessData</span><span id="1142" class="nh ll it kr b gy nt nj l nk nl">val retailData = Seq(<br/>("001", "zk67", "Lighting"),<br/>("001", "gg89", "Paint"),<br/>("002", "gg97", "Paint"),<br/>("003", "gd01", "Gardening"),<br/>("003", "af83", "A.C."),<br/>("003", "af84", "A.C."),<br/>("004", "gd77", "Gardening"),<br/>("004", "gd73", "Gardening"),<br/>("005", "cl55", "Cleaning"),<br/>("005", "zk67", "Lighting"),<br/>).toDF("customerID", "productID", "retailCategory")</span><span id="6c2c" class="nh ll it kr b gy nt nj l nk nl">val transformedRetailData = PreprocessData.createArrayAndCount(retailData)</span></pre><p id="6994" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里显示的<code class="fe ko kp kq kr b">val transformedRetailData</code>的输出应该类似于</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi nx"><img src="../Images/629464e7cc9c8d083a93c002ad4b28e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wbgbXnaWNeXawFvTmuInog.png"/></div></div></figure><h1 id="2c51" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated"><strong class="ak">结论</strong></h1><ul class=""><li id="301b" class="mp mq it js b jt mi jx mj kb ny kf nz kj oa kn mu mv mw mx bi translated">类型安全聚合允许数据科学家指定如何进行转换，如何在节点内和节点间组合数据，以及每个步骤在预期的输入和输出类型方面应该包含什么。</li><li id="46cb" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn mu mv mw mx bi translated">使用 Spark 的<code class="fe ko kp kq kr b">Aggregator</code>类来执行类型安全转换。典型的用例是在生产级环境中，编写 API，或者计划重复使用聚合。</li><li id="4b98" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn mu mv mw mx bi translated">理解 Spark 中发生的事情对于理解<code class="fe ko kp kq kr b">Aggregator</code>类如何工作是很重要的。</li></ul></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h2 id="b01c" class="nh ll it bd lm ob oc dn lq od oe dp lu kb of og ly kf oh oi mc kj oj ok mg ol bi translated"><strong class="ak"> <em class="om">伸手</em> </strong></h2><p id="4c2c" class="pw-post-body-paragraph jq jr it js b jt mi jv jw jx mj jz ka kb mk kd ke kf ml kh ki kj mm kl km kn im bi translated">感谢阅读这篇文章！如有任何意见/问题，请随时联系我们或通过<a class="ae lj" href="https://twitter.com/martainyo" rel="noopener ugc nofollow" target="_blank"> Twitter </a>。你也可以访问我的个人网站:【mfjackson.github.com<a class="ae lj" href="http://mfjackson.github.com" rel="noopener ugc nofollow" target="_blank">。我一直在学习并寻求提高我在数据科学方面的知识，所以如果我做了任何错误的陈述，或者你知道比本文更好的方法，请告诉我！！</a></p></div></div>    
</body>
</html>