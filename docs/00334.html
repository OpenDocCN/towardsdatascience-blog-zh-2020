<html>
<head>
<title>Bulk Mapping Attributes to Dataframes using Python Pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Python Pandas 将属性批量映射到数据帧</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/bulk-mapping-attributes-to-dataframes-using-python-pandas-fe192dca9e83?source=collection_archive---------22-----------------------#2020-01-10">https://towardsdatascience.com/bulk-mapping-attributes-to-dataframes-using-python-pandas-fe192dca9e83?source=collection_archive---------22-----------------------#2020-01-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c01f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">合并而不是循环遍历大型数据帧如何显著提高程序性能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/12758a0a59b8c8f18a9bd41b8bb74ef1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*udYfNLqj-Wq3nqzJLi2uOw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:https://www.pexels.com</p></figure><p id="469f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当涉及到遍历 Pandas 数据帧中的大量行时，我们中的许多人都不耐烦地等待我们的程序结束循环，有时一行一行地等待很长时间。这是我在将高容量事务性数据作为 Pandas dataframe 加载，然后在单独的字典(从 JSON 文件加载)中根据客户机 ID 匹配丰富记录时遇到的主要困难之一。</p><p id="834f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">两种数据来源:</strong></p><ul class=""><li id="2237" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><strong class="lb iu">熊猫数据框</strong>包含几千行交易数据(待丰富)</li><li id="0b6a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">包含客户端数据的字典</strong>(将用于丰富 Pandas 数据帧)</li></ul><p id="9e96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">问题:</strong></p><p id="8919" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用来自<strong class="lb iu">字典</strong>的客户数据丰富交易<strong class="lb iu"> Pandas Dataframe </strong></p><p id="9151" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，最初的方法(如下所示)是在源数据帧中查找 ID，然后遍历参考字典中的另外几千条记录来查找匹配。对每一行重复进行这种操作——想想看。一秒钟是完成这个查找的平均时间，更不用说根据参考数据值更新数据帧需要几个小时的数据处理时间！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/47745c0aa028da4e75b97679813917e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*xjMX__vJHX2zMXnqVcRcrQ.png"/></div></figure><p id="91d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">源数据是作为来自不同源系统的独立数据帧收集、清理和加载的，因此我的程序遍历这些数据帧的每一行，根据参考字典中的不同属性进行匹配。首先，知道您希望将这两个数据源映射到哪个属性非常重要。在我的例子中，数据帧有 2-3 个不同的属性(基本上是跨数据集的不同映射属性)，这就是为什么一开始不可能将它们全部整合到一个更大的数据帧中——这从一开始就会简单得多。在大多数情况下，您无法控制系统和团队如何收集数据，因此在开始繁重的工作之前，可能会花费大量时间来确保您的格式是一致的。</p><p id="f08a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就这一点而言，如果实现一个战略解决方案，与源团队合作并让他们知道您希望他们如何发送数据是值得的——这将节省您未来的时间，也有助于确保一致性。此外，您不希望遇到这样的情况:最终接收到的源数据包含意外的列、缺失的属性或不同的数据类型。</p><p id="025b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦数据帧被清理并重新标记，允许使用相同的属性和数据类型快速组合它们，我很快意识到<strong class="lb iu">循环应该只保留给较小的数据集。</strong>映射或合并更适合有几千条记录的数据帧。这个过程非常类似于 SQL 连接，将多个表(在我们的例子中是数据帧)组合成一个统一的表。</p><p id="590b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以想象，使用循环查找匹配对性能没有好处。最初，我的程序要花几个小时来运行，因为它要逐行(针对数千条记录)运行，然后在参考数据字典中找到匹配。我知道，如果我生成的报告从长远来看有效率的话，这个程序必须得到充分的改进。<strong class="lb iu">这就是战略问题解决发挥作用的地方！</strong></p><p id="937e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然我在程序中使用了循环，但这只是为了识别惟一的客户机 id，然后从更大的引用数据集中创建一个子集字典。这使我避免了在源数据帧的几千条记录和参考字典的几千个其他值中循环。</p><h1 id="d137" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">这种通过迭代开发的新方法将我的程序的执行时间从 12 小时提高到了 15 分钟。</h1><p id="095e" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated"><strong class="lb iu">解决方案:</strong></p><p id="2a54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">步骤 1: </strong>在源数据帧中识别惟一的 id，并将它们保存到一个列表中</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/58b40513f8780c8985aabfb115678d9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/format:webp/1*C1w7DEw0qfSy5upPUdPIWg.png"/></div></figure><p id="bcf3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">步骤 2: </strong>查找源数据帧和参考字典之间的匹配</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/1a2193104a971f7a23eff13ff85c101e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*s9syXH7tUAN1zV9HmpZ35A.png"/></div></figure><p id="b9a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">步骤 3: </strong>为较大的参考字典中的所有匹配创建一个子字典&amp;将其转换为数据帧</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/fb46c29ff418cedde73ea95254785b0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/1*r0EQFGod4agrwCQV6uEKXw.png"/></div></figure><p id="3f4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">步骤 4: </strong>将子集参考数据帧与源数据帧合并</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/005f7351f95ac7f0405a0d457fe44222.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PGuLWMdGsGlEfjGkEXRQrQ.png"/></div></div></figure><p id="f91a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望这种合并而不是循环的发现能够帮助您踏上数据科学之旅！</p></div></div>    
</body>
</html>