<html>
<head>
<title>An intuitive approach to DTW — Dynamic Time Warping</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">DTW 的直观方法——动态时间弯曲</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/an-intuitive-approach-to-dtw-dynamic-time-warping-f660ccb77ff4?source=collection_archive---------25-----------------------#2020-06-27">https://towardsdatascience.com/an-intuitive-approach-to-dtw-dynamic-time-warping-f660ccb77ff4?source=collection_archive---------25-----------------------#2020-06-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c7fa" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何将算法可视化，让你可以自己定制。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/20d6089a5d50ad7188d6e18f70183995.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yOGITbltunSw9W8hcJ-ToQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">奈杰尔·塔迪亚恩多在<a class="ae ky" href="/photos/i9gR_dz_xzU?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="0c34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated">既然你在这里，我想你已经知道我们为什么在时间序列数据中使用动态的或 DTW。简单地说，它用于对齐或匹配两个相似的模式。</p><h1 id="4772" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">简要概述</h1><p id="cc56" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi lv translated">最初开发 DTW 的原因之一是为了语音识别。你的母亲可能一天说得很慢，另一天又说得很快；即使有些日子会有点感冒和喉咙痛，但你仍然可以听出她的声音。机器也能做到吗？它们能以某种方式匹配她的声音的高低、高低、频率，而不是她说话的方式，并告诉我们这确实是她的声音吗？</p><p id="1c83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">DTW 在现实生活中有几个令人敬畏的场景——如果你还不知道，我推荐你去了解它们——它们真的很有趣！</p><blockquote class="nb nc nd"><p id="aee8" class="kz la ne lb b lc ld ju le lf lg jx lh nf lj lk ll ng ln lo lp nh lr ls lt lu im bi translated">你可以在这里阅读更多关于 DTW <a class="ae ky" href="https://en.wikipedia.org/wiki/Dynamic_time_warping" rel="noopener ugc nofollow" target="_blank">和它的许多应用</a><a class="ae ky" href="http://seninp.github.io/assets/pubs/senin_dtw_litreview_2008.pdf" rel="noopener ugc nofollow" target="_blank">在这里</a>(参考<em class="it">介绍</em>部分)</p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/e5b0f3ac03ea15aee5146dac0983e702.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lPecfOMHaASWUcFXjaB4jQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">两个信号对齐——“作者的图像”</p></figure><h1 id="4b05" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">带我去那里，快！</h1><p id="597a" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi lv translated">我喜欢这个算法！本质上，它是一种短小精悍的算法。这是一个使用<a class="ae ky" href="https://en.wikipedia.org/wiki/Dynamic_programming" rel="noopener ugc nofollow" target="_blank"> <em class="ne">动态规划</em> </a>方法寻找最短路径的经典例子。</p><p id="42d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我有同事逃避理解算法的内部运作，因为它涉及到<a class="ae ky" href="https://en.wikipedia.org/wiki/Recursion_(computer_science)" rel="noopener ugc nofollow" target="_blank"> <em class="ne">递归</em> </a> <em class="ne">。</em>这最终会阻止他们理解方法的细微差别，以及学习如何根据他们的需求进行调整。</p><p id="3337" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用一种非编程的方式来可视化算法背后的逻辑，这样我们就可以从头开始写了。</p><blockquote class="nj"><p id="fb0d" class="nk nl it bd nm nn no np nq nr ns lu dk translated">要理解递归，首先必须理解递归。</p><p id="b923" class="nk nl it bd nm nn no np nq nr ns lu dk translated">——斯蒂芬·霍金</p></blockquote><p id="2686" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">想象你站在蓝色广场，希望去红色广场。你在沿途的单元格中看到的所有数字，对应于你在每一步必须支付的通行费金额(暂时是任意决定的)。如果我问你，“<em class="ne">告诉我一个人要从蓝色变成红色最少需要花多少钱</em>”，你会怎么做？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/60e6a18957f6fc7eae1b46a02d9ccb32.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*jXVEZO662GINnPOaDOgDxQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">寻找“最便宜”的路线——“作者图片”</p></figure><p id="ec25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，我可以简单地说，你应该只朝“向前”的方向移动。黑色箭头显示仅有的 3 个“允许”方向(右、下、右下对角线)，红色箭头显示“限制”方向，即除了 3 个允许方向(上、左、其他对角线等)之外的所有方向。).这类似于 DTW 在解决问题之前的假设。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/4e5061b604e72bee1c368c253dcbe829.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/1*EDbUq61O55WxcIpIXLYr9w.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">允许的方向—“按作者分类的图像”</p></figure><p id="d827" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上述事实的另一种说法是，“你只能从 3 个相邻的方格中的一个到达任何方格”:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/72689699572dc0a20e021bd15c5f8e9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/1*_D5M5XxFthueepO4coSGPg.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">另一种看待它的方式——“作者的图像”</p></figure><p id="5631" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一种“蛮力”方法是尝试从蓝色到红色方块的所有可能路径，并选择最便宜的一条。然而，动态编程和递归给了我们一个更好、更聪明的方法。</p><h1 id="0b99" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">懒惰的老板</h1><p id="4d4a" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi lv translated"><span class="l lw lx ly bm lz ma mb mc md di">我</span>喜欢以“懒惰老板”的身份来解决所有递归问题，他有无数的手下来完成这项工作。如果有人让我解决上述问题，我会简单地说:“小黄人 A，B，C，告诉我到达红色方块周围的 3 个方块的最小成本，然后我一分钟后计算出答案。在那之前，不要打扰我。”</p><blockquote class="nj"><p id="bc90" class="nk nl it bd nm nn no np nq nr ns lu dk translated">这就是递归使用的技巧——将你被要求做的<strong class="ak"> <em class="oa">完全相同的工作</em> </strong>交给你的下属，在将工作“缩小”一点之后。一定要给自己留一些简单的东西，这样就没人会说你什么也没做！</p></blockquote><p id="79d4" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">假设通过某种魔法(你没兴趣知道)，小喽啰给你带来了答案，标在绿色的格子里:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/35f1e5806e20df9059a9f89674c00746.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*vAc5YbC4dLPGQ_0eIXhNwg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">小黄人 A、B、C 的回答——“作者图片”</p></figure><p id="e809" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我现在需要做的就是找到<strong class="lb iu"> (10，7，7) </strong>的<strong class="lb iu">最小值</strong>，也就是 7，然后加上当前方块的成本，也就是 2。这给了我答案为<strong class="lb iu"> 9 </strong>。搞定了。</p><p id="8e30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">9 是从蓝色到红色旅行的最小花费。但是等等，奴才们是怎么想出绿色价值观的？他们当然会模仿你，也扮演懒惰老板的角色！</p><p id="2f36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个爪牙抓 3 个低级爪牙(我告诉你，办公室里该死的等级制度！)并告诉他们为他们的 3 个邻居/相邻方块带来最小成本值。下面的动画可以更好地解释这一点:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/972e3e8f8bb9fd2235e005cfa0581e0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*yXV5QgCRsi3v7HYu_v6z0g.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">工作中的奴才——“作者的形象”</p></figure><p id="ec69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种情况一直持续下去，每一个小跟班都“神奇地”得到了答案。但是能持续多久呢？它肯定会结束吗？是的，确实如此。<strong class="lb iu">当没有办法进一步细分作品时。当一个仆从在蓝色方块得到计算费用的任务时，他不能把它委托给任何人，因为没有邻居可去。他只需要知道那里的成本是零。</strong></p><p id="6f27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样。只需几行代码，您就可以将它转化为一个递归 python 函数:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="fb3c" class="oi mf it oe b gy oj ok l ol om">def cheapest(cost, i, j):<br/> if (i==0) &amp; (j==0):<br/>     return 0  ## can't subdivide the work anymore</span><span id="add0" class="oi mf it oe b gy on ok l ol om"> if (i&lt;0) | (j&lt;0):<br/>     return np.inf</span><span id="93ec" class="oi mf it oe b gy on ok l ol om"> ## current square's cost + minimum of the 3 neigbours<br/> return cost[i][j] + min(cheapest(cost, i-1, j-1), <br/>                         cheapest(cost, i-1, j), <br/>                         cheapest(cost, i, j-1))</span></pre><p id="42ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，<code class="fe oo op oq oe b">cost</code>是一个二维数组，我们的初始矩阵:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="c1fb" class="oi mf it oe b gy oj ok l ol om">cost = [<br/> [0,2,5,1,1],<br/> [5,3,4,2,2],<br/> [1,1,6,1,3],<br/> [1,3,2,1,2]<br/>]</span></pre><p id="8900" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，当<code class="fe oo op oq oe b">i</code>或<code class="fe oo op oq oe b">j</code>小于零时，我是如何返回<code class="fe oo op oq oe b">np.inf</code>(无穷大)的。这只是忽略不存在的邻居的一种方式。例如，当你在一个顶行方块中时，你需要考虑的唯一邻居是左边的那个，因为在当前方块的上面没有方块。类似的逻辑也适用于第一列中的正方形，这里左边没有邻居。</p><p id="5106" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以通过简单地调用以下命令来调用递归函数:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="3632" class="oi mf it oe b gy oj ok l ol om">output_cost = cheapest(cost, 3, 4)<br/>print(output_cost)</span></pre><p id="e7bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它将给出的输出是 9。</p><p id="b029" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果对所有方块调用它，最终可以创建一个最便宜的成本矩阵作为输出:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="a28c" class="oi mf it oe b gy oj ok l ol om">output_cost_matrix = []   ## used to store all outputs<br/>for i in range(4):<br/>   for j in range(5):<br/>      output_cost_matrix.append(cheapest(cost, i, j))</span><span id="ee59" class="oi mf it oe b gy on ok l ol om">## reshape the output for better display<br/>output_cost_matrix= (np.array(output_cost_matrix)).reshape(-1,5)<br/>print(output_cost_matrix)</span></pre><p id="64d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="cd05" class="oi mf it oe b gy oj ok l ol om">[[ 0,  2,  7,  8,  9],<br/> [ 5,  3,  6,  8, 10],<br/> [ 6,  4,  9,  7, 10],<br/> [ 7,  7,  6,  7,  9]]</span></pre><p id="f558" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，从蓝色方块到红色方块最便宜的路径是什么呢？</p><p id="c017" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们只需要跟踪每个方块周围的<em class="ne">最小邻居</em>。如果您也想打印路径，下面是代码。这当然没有优化，但很容易理解:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="1503" class="oi mf it oe b gy oj ok l ol om">def trace_path(output_cost_matrix, i, j):<br/> path = [(i, j)]<br/> while ((i&gt;0) | (j&gt;0)):<br/>   neighbours = [output_cost_matrix[i-1, j-1], <br/>                 output_cost_matrix[i-1, j], <br/>                 output_cost_matrix[i, j-1]]<br/>   ## see which neighbour is the smallest<br/>   path_min = np.argmin(neighbours)</span><span id="c524" class="oi mf it oe b gy on ok l ol om">   ## store the position of the smallest neighbour<br/>   if path_min==0:<br/>      i=i-1<br/>      j=j-1<br/>   elif path_min==1:<br/>      i=i-1<br/>   else:<br/>      j=j-1<br/>   path.append((i, j))</span><span id="eecd" class="oi mf it oe b gy on ok l ol om"> return path[::-1] ## return after reversing the list</span></pre><p id="8ce5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们通过调用来查看从蓝色返回到红色方块的路径:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="8364" class="oi mf it oe b gy oj ok l ol om">trace_path(output_cost_matrix, 3, 4)</span></pre><p id="51df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="c746" class="oi mf it oe b gy oj ok l ol om">[(0, 0), (0, 1), (1, 2), (2, 3), (3, 4)]</span></pre><p id="cfa0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用图形表示出来:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/5de8a2c8b1175d75de513fe01d0f27ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/1*gm7eMWs5d1u53Z_DTZK1Vw.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">追踪的路径——“作者的图像”</p></figure><p id="0fce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者在我们的原始矩阵上追踪它:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/d62b6b65535ab7be9c82061ad7132884.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/1*mQ910QZS3ZD7nJZCSah1vg.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">最便宜的路径——“按作者排序的图像”</p></figure><h1 id="a718" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">酷！但是 DTW 在这一切中处于什么位置呢？</h1><p id="77ab" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi lv translated">问对了！DTW 是如何看待这一切的？</p><blockquote class="nj"><p id="8662" class="nk nl it bd nm nn no np nq nr ns lu dk translated">DTW 不过是简单地将时间序列模式 1 中的一个点与模式 2 中最近的点进行匹配。</p></blockquote><p id="5f89" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">我们再来看两个信号的映射。青色的是图案 1，橙色的是图案 2，红线试图为图案 2 上的每个点找到图案 1 上的对应点:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/34dc74aa8b3e92cdcca60a02a9aa5fee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1394/format:webp/1*EU7BJnoXrjxAeuWszbhEBw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">模式映射——“作者的图像”</p></figure><p id="c8f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以本质上，我们在寻找模式 2-点和模式 1-点之间的最短或最便宜的路径。但是任意两点之间的成本是多少。我们是否像例子中那样，对每个方块随机放置？</p><p id="45bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据您的用例，您可以从这里选择各种选项，但最常见的是这些点之间的<a class="ae ky" href="https://en.wikipedia.org/wiki/Euclidean_distance" rel="noopener ugc nofollow" target="_blank">欧几里德距离</a>。</p><p id="5bba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您将所有模式 1 点排列为矩阵的列轴，所有模式 2 点排列为行轴。然后用欧几里德距离填充每个正方形:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi os"><img src="../Images/62aa2c706bd3f60c6b991ed68c9870a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/format:webp/1*6us6pc7YPECym-oNJ4oKmA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">排列成矩阵的图案——“作者的图像”</p></figure><p id="3ba6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后是我们刚刚经历过的递归算法。像<code class="fe oo op oq oe b">[(0,0), (0,1), (1,1), (2,2), (3,3), (4,3)]</code>这样的输出路径意味着模式 1 中的点 0 应该与模式 2 中的点 0 和 1 匹配。模式 1 中的点 1、2、3 和 4 应与模式 2 中的点 1、2、3 和 3 相匹配。</p><p id="4a23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是这实际上能达到什么目的呢？这样的最短距离匹配意味着什么？</p><blockquote class="nj"><p id="d786" class="nk nl it bd nm nn no np nq nr ns lu dk translated">我喜欢把它想象成这样一种解决方案:你试图以一种确保模式 2 的拉伸(或收缩)最小的方式来匹配模式 2 和模式 1；贪婪地将它匹配到最近的邻居。</p></blockquote><p id="50e5" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">现在你知道了。从头开始实现一个简单的 DTW 算法。</p></div><div class="ab cl ot ou hx ov" role="separator"><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy"/></div><div class="im in io ip iq"><p id="b0e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我没有提到 DTW 过程的一些细微差别和变化，例如一个<a class="ae ky" href="https://en.wikipedia.org/wiki/Dynamic_time_warping#Implementation" rel="noopener ugc nofollow" target="_blank">窗口 DTW </a>，我们在其中添加了一个位置约束。我希望这篇文章已经激发了你想了解更多的兴趣。如果你发现了一些很酷的东西，一定要告诉我！</p></div><div class="ab cl ot ou hx ov" role="separator"><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy"/></div><div class="im in io ip iq"><p id="29b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对分享想法、提问或简单讨论想法感兴趣？在<a class="ae ky" href="https://www.linkedin.com/in/himanshu-chandra-33512811/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>、<a class="ae ky" href="https://www.youtube.com/channel/UChNybQwpqrX9SOc1D4K_x5Q" rel="noopener ugc nofollow" target="_blank"> YouTube </a>、<a class="ae ky" href="https://github.com/HCGrit/MachineLearning-iamJustAStudent" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上或通过我的网站与我联系:<a class="ae ky" href="http://iamjustastudent.com/about" rel="noopener ugc nofollow" target="_blank">我只是一个学生</a>。</p><p id="fc38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回头见&amp;学习愉快！</p><div class="pa pb gp gr pc pd"><a href="https://www.linkedin.com/in/himanshu-chandra-33512811/" rel="noopener  ugc nofollow" target="_blank"><div class="pe ab fo"><div class="pf ab pg cl cj ph"><h2 class="bd iu gy z fp pi fr fs pj fu fw is bi translated">Himanshu Chandra -业务主管-ML</h2><div class="pk l"><p class="bd b dl z fp pi fr fs pj fu fw dk translated">www.linkedin.com</p></div></div><div class="pl l"><div class="pm l pn po pp pl pq ks pd"/></div></div></a></div></div></div>    
</body>
</html>