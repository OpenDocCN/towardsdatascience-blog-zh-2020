<html>
<head>
<title>Classification of Amazon Food Reviews</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">亚马逊美食评论的分类</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/text-classification-of-amazon-fine-food-reviews-ed27948fc1a2?source=collection_archive---------55-----------------------#2020-06-17">https://towardsdatascience.com/text-classification-of-amazon-fine-food-reviews-ed27948fc1a2?source=collection_archive---------55-----------------------#2020-06-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ad87" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">我们如何对客户的反馈进行分类？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/88ca6f19eaf4cad73533f4c198d4fdda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WHOwWXeJUwQUEoO3lUrxyg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由克里斯蒂安·威迪格在Unsplash上拍摄</p></figure><p id="8329" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里的目标是根据顾客的文本对食品评论进行分类。所以第一步是下载数据集。对于供应商来说，利用客户的评论来为他们提供更好的服务是非常有趣的。评论包括几个功能，如“产品Id”、“用户Id”、“分数”和“文本”。</p><p id="0cdb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是我们如何分析这类问题呢？</p><h1 id="b4d3" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">数据</strong></h1><p id="2331" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">让我们看看数据集中包含的要素:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="faa1" class="mu lt iq mq b gy mv mw l mx my">print(“There are <strong class="mq ir">{}</strong> observations and <strong class="mq ir">{}</strong> features in this dataset. “\ .format(reviews.shape[0],reviews.shape[1]))</span><span id="7f41" class="mu lt iq mq b gy mz mw l mx my">There are 568454 observations and 10 features in this dataset.</span></pre><p id="18c8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如图所示，该数据集由568454篇评论组成，时间跨度超过十年。在这个数据集中有十种不同的特征，但是我们只分别将“文本”和“分数”列作为输入/输出。</p><p id="ab97" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将根据客户的短信预测分数。这叫做情感分析。其他特征不影响目标和特征之间的关系。</p><p id="171e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，让我们看看数据集中包含的要素:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="aa89" class="mu lt iq mq b gy mv mw l mx my">reviews.head()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi na"><img src="../Images/132de53b17e1366c4754f76b6a5158a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/format:webp/1*p8H5btFf9mEjeEredzUVJQ.png"/></div></figure><h1 id="1759" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">数据探索</strong></h1><p id="f1c1" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">为了更好地理解目标(分数)分布，我们使用。seaborn图书馆的countplot。通过应用这个导入的函数，我们可以看到分数的分布。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="9719" class="mu lt iq mq b gy mv mw l mx my"><strong class="mq ir">import</strong> <strong class="mq ir">seaborn</strong> <strong class="mq ir">as</strong> <strong class="mq ir">sns</strong> <br/><strong class="mq ir">import</strong> <strong class="mq ir">matplotlib.pyplot</strong> <strong class="mq ir">as</strong> <strong class="mq ir">plt</strong> <br/>sns.countplot(reviews[‘Score’]) <br/>plt.show()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/b40dc6f2c248aad77cda9561814e8036.png" data-original-src="https://miro.medium.com/v2/resize:fit:642/format:webp/1*fU4Nczx9Wj-pEHHWUSE6Mw.png"/></div></figure><p id="1471" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">它表明分数五在其余的分数之间有最大的数。基于分数分布，在我们的例子中，我们将它作为我们的目标，它显示分布是偏斜的，我们还可以考虑应用对数使它看起来更像高斯分布。当输入和输出具有高斯分布时，机器学习工作得更好。</p><p id="7ea9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们看看熊猫的每个特征的类型。info()函数，它也可以让您对特性有一个大致的了解。了解每一列是否有任何缺失值会很有帮助，这样您就能够以有效的方式处理它。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="d659" class="mu lt iq mq b gy mv mw l mx my">reviews.info()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/feb153bd246cd2335d582737ac7f0791.png" data-original-src="https://miro.medium.com/v2/resize:fit:664/format:webp/1*fSPZ5OLW6iZUaduMw6mOKw.png"/></div></figure><p id="5e9c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">由于我们只处理两列，并且没有缺失值，我们不需要删除任何观察值或使用插补转换器来完成缺失值。</p><h1 id="530a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">文本表示</h1><p id="13cf" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">多项式朴素贝叶斯分类器适用于文本分类。基于数据集的大小和创建离散特征，我认为使用运行速度快的机器学习算法是可行的。否则，需要一段时间才能得到满意的输出。</p><p id="4913" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们的目标是找到输入和输出之间的关系。我使用“文本”作为输入，使用“分数”作为输出。所以我的第一步是把文本转换成向量。我们必须这样做，因为我们对多项式模型使用朴素贝叶斯分类器，而且这种方法也接受数字输入。这与应用任何机器学习算法的技术相同。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="addc" class="mu lt iq mq b gy mv mw l mx my"><strong class="mq ir">from</strong> <strong class="mq ir">sklearn.feature_extraction.text</strong> <strong class="mq ir">import</strong> TfidfTransformer <br/><strong class="mq ir">from</strong> <strong class="mq ir">sklearn.naive_bayes</strong> <strong class="mq ir">import</strong> MultinomialNB <br/><strong class="mq ir">from</strong> <strong class="mq ir">sklearn.pipeline</strong> <strong class="mq ir">import</strong> Pipeline</span></pre><p id="b2c0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们需要将反馈(文本)转换为令牌计数矩阵，以便从文本内容中提取数字特征。这样，计数的稀疏表示就产生了。这是非常有益的，因为你可以想象独特的映射词到向量创建一个矩阵的巨大规模。CountVectorizer用于此目的，它可以按如下方式导入。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="890e" class="mu lt iq mq b gy mv mw l mx my"><strong class="mq ir">from</strong> <strong class="mq ir">sklearn.feature_extraction.text</strong> <strong class="mq ir">import</strong> CountVectorizer</span></pre><p id="800d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有许多像“the”、“them”、“are”这样的词对上下文的意思没有任何影响，这些词被称为停用词。它们不提供信息，可以通过选择step_words='english '作为CountVectorizer函数中的超参数来删除。</p><p id="69fd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下一步是使用tf-idf表示来规范化计数矩阵。标准化频率而不是使用原始频率的主要原因是为了减少在文本中出现几次的标记的影响，并且没有出现几次的标记信息量大。例如，单词“document”在给定的语料库中出现一千次，而“awesome”出现两次。tf-idf在这种情况下工作，就像预处理数据，将原始特征向量变成更适合机器学习算法的表示。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="f23a" class="mu lt iq mq b gy mv mw l mx my"><strong class="mq ir">from</strong> <strong class="mq ir">sklearn.feature_extraction.text</strong> <strong class="mq ir">import</strong> TfidfTransformer</span></pre><h1 id="a501" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">管道</strong></h1><p id="cbc5" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">我使用管道功能来完成所有步骤。顺序应用变换列表和最终估计器。因此，它开始应用CountVectorizer、Tfidf，然后是MultinomialNB。您可以拥有管道工作所需的任意数量的变压器。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="e8e7" class="mu lt iq mq b gy mv mw l mx my">twitter_sentiment = Pipeline([('CVec', CountVectorizer(stop_words='english')),<br/>                     ('Tfidf', TfidfTransformer()),<br/>                     ('MNB', MultinomialNB())])</span></pre><h1 id="e653" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">交叉验证</strong></h1><p id="f8a5" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">最后，cross_validate与roc_auc指标一起使用。应用k-fold交叉验证，并且以循环中值的平均值来计算性能度量。在我们的例子中，k被指定为5。5和10是在k倍交叉验证中选择的常见值。下面是这段代码。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="e857" class="mu lt iq mq b gy mv mw l mx my"><strong class="mq ir">from</strong> <strong class="mq ir">sklearn.model_selection</strong> <strong class="mq ir">import</strong> cross_validate</span><span id="5310" class="mu lt iq mq b gy mz mw l mx my">cv_pred = cross_validate(twitter_sentiment,<br/>                             reviews['Text'], <br/>                             reviews['Score'], <br/>                             cv=5,<br/>                             scoring=('roc_auc_ovr'), n_jobs=-1, verbose =10)</span></pre><h1 id="2fca" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak"> ROC-AUC </strong></h1><p id="d723" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">这是一个分类问题，所以我们用受试者工作特征曲线下的完全面积(ROC-AUC)来衡量预测得分。因为我们有一个多类的问题，我们要去' roc_auc_ovr '。对于这种情况，可以使用其他选项。我们使用ROC_AUC测量的结果如下。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="92d0" class="mu lt iq mq b gy mv mw l mx my">cv_pred['test_score']</span><span id="14bc" class="mu lt iq mq b gy mz mw l mx my">array([0.80588185, 0.81448439, 0.8088359 , 0.81728556, 0.81103624])</span></pre><h1 id="a6fb" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">结论</strong></h1><p id="2c77" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">每折一次，分数都在80%以上。有可用的算法，如随机森林，梯度推进也可以在这里使用。但这取决于你在解决每一个案件中寻找什么。你在寻找一个快速的答案和更好的准确性吗？这两个选项之间总是有一个权衡，您需要为每个数据集选择最佳选项。</p><p id="c1b4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">完整的代码可以通过这个<a class="ae lr" href="https://github.com/shosseini811/Amazon-Fine-Food-Reviews-text-classification-/blob/master/amn-fine-food-reviews.ipynb" rel="noopener ugc nofollow" target="_blank">链接</a>访问。</p></div></div>    
</body>
</html>