<html>
<head>
<title>Conv2d: Finally Understand What Happens in the Forward Pass</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Conv2d:终于明白了向前传球会发生什么</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/conv2d-to-finally-understand-what-happens-in-the-forward-pass-1bbaafb0b148?source=collection_archive---------3-----------------------#2020-05-02">https://towardsdatascience.com/conv2d-to-finally-understand-what-happens-in-the-forward-pass-1bbaafb0b148?source=collection_archive---------3-----------------------#2020-05-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="289c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">2D卷积层及其参数的直观和数学解释</h2></div><h1 id="c80d" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">介绍</h1><p id="1b81" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">深度学习的<strong class="lc iu">库</strong>和平台如<strong class="lc iu"> Tensorflow </strong>、<strong class="lc iu"> Keras </strong>、<strong class="lc iu"> Pytorch </strong>、<strong class="lc iu"> Caffe </strong>或<strong class="lc iu"> Theano </strong>在日常生活中帮助我们，以至于每天都有新的应用让我们觉得“哇！”。我们都有自己最喜欢的框架，但它们的共同点是，它们通过易于使用、可按需配置的功能来简化我们的工作。但是我们仍然需要理解<strong class="lc iu">可用的参数是什么</strong>来利用这些框架给我们的所有能力。</p><p id="83b5" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">在这篇文章中，我将尝试列出所有这些论点。如果您想了解它们对<strong class="lc iu">计算时间</strong>、可训练参数<strong class="lc iu">的数量</strong>以及卷积输出通道的<strong class="lc iu">大小</strong>的影响，那么这篇文章就是为您准备的。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/b181bdd531d37aeb806e864ce9644f08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/1*DTTpGlhwkctlv9CYannVsw.gif"/></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">输入形状:(3，7，7) —输出形状:(2，3，3) — K : (3，3) — P : (1，1) — S : (2，2) — D : (2，2) — G : 1</p></figure><p id="303f" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">所有的gif都是用python做的。你将能够测试这些论点中的每一个，并且<strong class="lc iu">自己想象</strong>它们对我的Github 上的<a class="ae mn" href="https://github.com/AxelThevenot/GIF_convolutions" rel="noopener ugc nofollow" target="_blank">脚本的影响(或者制作你的gif)。</a></p><p id="ef30" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">这篇文章的各个部分将根据以下论点进行划分。这些参数可以在<strong class="lc iu"> Conv2d </strong>模块的<strong class="lc iu"> Pytorch </strong>文档中找到:</p><ul class=""><li id="de1e" class="mo mp it lc b ld lw lg lx lj mq ln mr lr ms lv mt mu mv mw bi translated"><strong class="lc iu">in _ channels</strong>(<a class="ae mn" href="https://docs.python.org/3/library/functions.html#int" rel="noopener ugc nofollow" target="_blank"><em class="mx">int</em></a>)—输入图像的通道数</li><li id="0eea" class="mo mp it lc b ld my lg mz lj na ln nb lr nc lv mt mu mv mw bi translated"><strong class="lc iu">out _ channels</strong>(<a class="ae mn" href="https://docs.python.org/3/library/functions.html#int" rel="noopener ugc nofollow" target="_blank"><em class="mx">int</em></a>)—卷积产生的通道数</li><li id="4301" class="mo mp it lc b ld my lg mz lj na ln nb lr nc lv mt mu mv mw bi translated"><strong class="lc iu">kernel _ Size</strong>(<a class="ae mn" href="https://docs.python.org/3/library/functions.html#int" rel="noopener ugc nofollow" target="_blank"><em class="mx">int</em></a><em class="mx">或</em><a class="ae mn" href="https://docs.python.org/3/library/stdtypes.html#tuple" rel="noopener ugc nofollow" target="_blank"><em class="mx">tuple</em></a>)—卷积核的大小</li><li id="c0dd" class="mo mp it lc b ld my lg mz lj na ln nb lr nc lv mt mu mv mw bi translated"><strong class="lc iu">步距</strong> ( <a class="ae mn" href="https://docs.python.org/3/library/functions.html#int" rel="noopener ugc nofollow" target="_blank"> <em class="mx"> int </em> </a> <em class="mx">或</em> <a class="ae mn" href="https://docs.python.org/3/library/stdtypes.html#tuple" rel="noopener ugc nofollow" target="_blank"> <em class="mx">元组</em> </a> <em class="mx">，可选</em> ) —卷积的步距。默认值:1</li><li id="a512" class="mo mp it lc b ld my lg mz lj na ln nb lr nc lv mt mu mv mw bi translated"><strong class="lc iu">填充</strong>(<a class="ae mn" href="https://docs.python.org/3/library/functions.html#int" rel="noopener ugc nofollow" target="_blank"><em class="mx">int</em></a><em class="mx">或</em> <a class="ae mn" href="https://docs.python.org/3/library/stdtypes.html#tuple" rel="noopener ugc nofollow" target="_blank"> <em class="mx">元组</em> </a> <em class="mx">，可选</em> ) —输入两边加零。默认值:0</li><li id="4992" class="mo mp it lc b ld my lg mz lj na ln nb lr nc lv mt mu mv mw bi translated"><strong class="lc iu">膨胀</strong>(<a class="ae mn" href="https://docs.python.org/3/library/functions.html#int" rel="noopener ugc nofollow" target="_blank"><em class="mx">int</em></a><em class="mx">或</em> <a class="ae mn" href="https://docs.python.org/3/library/stdtypes.html#tuple" rel="noopener ugc nofollow" target="_blank"> <em class="mx">元组</em> </a> <em class="mx">，可选</em> ) —内核元素之间的间距。默认值:1</li><li id="bfeb" class="mo mp it lc b ld my lg mz lj na ln nb lr nc lv mt mu mv mw bi translated"><strong class="lc iu">组</strong>(<a class="ae mn" href="https://docs.python.org/3/library/functions.html#int" rel="noopener ugc nofollow" target="_blank"><em class="mx">int</em></a><em class="mx">，可选</em> ) —输入通道到输出通道的阻塞连接数。默认值:1</li><li id="7279" class="mo mp it lc b ld my lg mz lj na ln nb lr nc lv mt mu mv mw bi translated"><strong class="lc iu">偏置</strong> ( <a class="ae mn" href="https://docs.python.org/3/library/functions.html#bool" rel="noopener ugc nofollow" target="_blank"> <em class="mx">布尔</em> </a> <em class="mx">，可选</em> ) —如果<code class="fe nd ne nf ng b">True</code>，向输出添加一个可学习的偏置。默认:<code class="fe nd ne nf ng b">True</code></li></ul><p id="e727" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">最后，我们将让<strong class="lc iu">的所有键根据参数和输入通道的大小计算输出</strong>通道的大小。</p><h1 id="de66" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">什么是内核？</h1><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nh"><img src="../Images/b8938894e01ec3703e5563ac2843216a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*A0hPszjXFj1S2FZ6.png"/></div></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">输入图像和内核之间的卷积</p></figure><p id="2f97" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">我来介绍一下什么是<strong class="lc iu">内核</strong>(或者说<strong class="lc iu">卷积矩阵</strong>)。内核描述了一个<strong class="lc iu">过滤器</strong>，我们将通过它来处理输入图像。简单来说，内核将通过应用<strong class="lc iu">卷积乘积</strong>在整个图像上从左到右、从上到下移动。该操作的输出被称为<strong class="lc iu">过滤图像</strong>。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nm"><img src="../Images/8be55e1625428bdf3cd7e655ff950bd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aR8KlS1KpCM36Kx7I8bmeQ.png"/></div></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">卷积乘积</p></figure><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/3d8c1fba2764d6b61ba3ed079062116c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/1*LT0l-KXw5FXIkcGVl-KXlQ.gif"/></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">输入形状:(1，9，9) —输出形状:(1，7，7) — K : (3，3) — P : (0，0) — S : (1，1) — D : (1，1) — G : 1</p></figure><p id="f7a6" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">举一个非常基本的例子，让我们想象一个3乘3卷积核过滤一个9乘9图像。然后，这个内核在整个图像上移动，以在图像中捕获所有大小相同的正方形。卷积乘积是一个<strong class="lc iu">元素级</strong>(或点级)乘法。这个结果的总和就是输出(或过滤)图像上的结果像素。</p><p id="6907" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">如果你还不熟悉滤波器和卷积矩阵，那么我强烈建议你多花一点时间来理解卷积核。<strong class="lc iu">它们是2D卷积层的核心</strong>。</p><h1 id="013d" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">可训练参数和偏差</h1><p id="7dce" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">可训练参数</strong>，也简称为“参数”，都是网络训练时<strong class="lc iu">会更新</strong>的参数。在Conv2d中，可训练元素是由<strong class="lc iu">组成内核</strong>的值。因此，对于我们的3乘3卷积核，我们有3*3=9个可训练参数。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nn"><img src="../Images/35582730971dfbc68676fc40c238817a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rZJKaIg3F4NI0EJNcozMgg.png"/></div></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">有偏卷积积</p></figure><p id="4ed7" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">为了更完整。我们可以包括<strong class="lc iu">偏差</strong>或不包括。偏差的作用是加到卷积乘积的和上。这个偏差<strong class="lc iu">也是一个可训练的</strong> <strong class="lc iu">参数</strong>，这使得我们的3乘3内核的可训练参数的数量增加到10个。</p><h1 id="2e44" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">输入和输出通道的数量</h1><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi no"><img src="../Images/7d15b297502eadd7187d135e77f7c485.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*o8O7owMwiF4Ull9NE-uWQw.gif"/></div></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">输入形状:(1，7，7) —输出形状:(4，5，5) — K : (3，3) — P : (0，0) — S : (1，1) — D : (1，1) — G : 1</p></figure><p id="1e40" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">使用层的好处是能够<strong class="lc iu">同时执行类似的操作</strong>。换句话说，如果我们想要对一个输入通道应用4个相同大小的不同滤波器，那么我们将有4个输出通道。这些通道是4个不同过滤器的结果。因此产生了4个不同的内核。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi np"><img src="../Images/4a7b033c4819a4c26251fe213f9e772b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0brvRE9_kOj_9m53N-Y0Xw.png"/></div></div></figure><p id="f972" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">在上一节中，我们看到可训练参数构成了卷积核。因此<strong class="lc iu">参数的数量随着卷积核的数量线性增加</strong>。因此与所需输出声道的数量成线性关系。还要注意的是，<strong class="lc iu">计算时间</strong>也随着输入通道的大小和内核的数量成比例地变化<strong class="lc iu">。</strong></p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nq"><img src="../Images/ded7eafff0ef99141b77cf6a0b42e4a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1BIUPOV6uzHgUX1Rz1pHaQ.png"/></div></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">请注意，参数图中的曲线是相同的</p></figure><p id="7466" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">同样的原理适用于<strong class="lc iu">输入通道</strong>的数量。让我们考虑RGB编码图像的情况。这个图像有三个通道:红色，蓝色和绿色。我们可以决定在这3个通道的每一个上用相同大小的滤波器提取信息，以获得4个新通道。因此，对于4个输出通道，操作是相同的3倍。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi no"><img src="../Images/978f2e71416b856345cf0306d5fb4902.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ubRrYAZJUlCcqg7WoKjLgQ.gif"/></div></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">输入形状:(3，7，7) —输出形状:(4，5，5) — K : (3，3) — P : (0，0) — S : (1，1) — D : (1，1) — G : 1</p></figure><p id="6d78" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated"><strong class="lc iu">每个输出通道是经过滤波的输入通道的总和。</strong>对于4个输出通道和3个输入通道，每个输出通道是3个滤波后的输入通道之和。换句话说，卷积层由4*3=12个卷积核组成。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nr"><img src="../Images/6491fbb7524aa86f3ec24bb5948d22ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*viA_WLZYQQ_QkuJdwo_B5g.png"/></div></div></figure><p id="ff4a" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">提醒一下，参数数量和计算时间与输出通道数量成比例变化。这是因为每个输出通道都链接到不同于其他通道的内核。对于<strong class="lc iu">输入通道</strong>的数量也是如此。计算时间和参数数量成比例增长。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nq"><img src="../Images/3cc4a74dce38a88cc45e85f3e37e9034.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CW4RMAB3OSowcritKwozlA.png"/></div></div></figure><h1 id="af80" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">内核大小</h1><p id="f601" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">到目前为止，所有的例子都给出了3乘3大小的内核。其实它的<strong class="lc iu">大小</strong>的选择完全<strong class="lc iu">由你</strong>决定。可以创建核心大小为1*1或19*19的卷积层。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi ns"><img src="../Images/4115e46ab9e9e09be42059eb0e8ac205.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*EnIGiVTcIMQm9ujkOHPc5A.gif"/></div></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">输入形状:(3，7，9) —输出形状:(2，3，9) — K : (5，2) — P : (0，0) — S : (1，1) — D : (1，1) — G : 1</p></figure><p id="bff7" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">但是也绝对有可能没有方形核。有可能决定让内核具有不同的高度和宽度。在信号图像分析中经常会出现这种情况。例如，如果我们知道我们想要扫描信号或声音的图像，那么我们可能想要5*1大小的内核。</p><p id="fa12" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">最后，你会注意到所有尺寸都由奇数<strong class="lc iu">和奇数</strong>定义。定义一个<strong class="lc iu">甚至</strong>的内核大小也是可以接受的。实际上，很少这样做。通常，选择奇数大小的内核是因为在中心像素周围有对称性。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nq"><img src="../Images/c528e5df2508c05d264919e193097ec1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WmN8M2C_rfYcB1juX9ajZg.png"/></div></div></figure><p id="5071" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">由于卷积层的所有(经典)可训练参数都在内核中，参数的数量<strong class="lc iu">随着内核的大小</strong>线性增长。计算时间也成比例地变化。</p><h1 id="0b63" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">大步</h1><p id="5cb8" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">默认情况下，内核从左向右移动，从上到下逐像素移动。但是这种转变也是可以改变的。常用于<strong class="lc iu">下采样</strong>输出通道。例如，对于(1，3)的步长，滤波器从水平方向的3到3和从垂直方向的1到1进行<strong class="lc iu">移位</strong>。这会产生水平向下采样3倍的输出通道。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nt"><img src="../Images/ebb97c69a239ae3a48a8e599ccc5f7cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*o9-Rq3QUC8IzTMfAJIbhLA.gif"/></div></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">输入形状:(3，9，9) —输出形状:(2，7，3) — K : (3，3) — P : (0，0) — S : (1，3) — D : (1，1) — G : 1</p></figure><p id="ce41" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">步长对参数的数量没有影响，但是逻辑上，计算时间随着步长线性减少。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nq"><img src="../Images/87027dd581f8487ec8b4f2860b60feec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MNRIIpu3I7UeiKhsb_IfVg.png"/></div></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">请注意，参数图中的曲线是相同的</p></figure><h1 id="71b9" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">填料</h1><p id="0a3a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">填充定义了在卷积滤波之前添加到输入通道<strong class="lc iu">的侧边</strong>的<strong class="lc iu">像素的数量。通常，填充像素被设置为零。输入通道<strong class="lc iu">延长</strong>。</strong></p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nt"><img src="../Images/4d76142e12c7d8d26848a0f631a92beb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*oRmppyqA2jQFUCVEDHB6hQ.gif"/></div></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">输入形状:(2，7，7) —输出形状:(1，7，7) — K : (3，3) — P : (1，1) — S : (1，1) — D : (1，1) — G : 1</p></figure><p id="2928" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">当您希望<strong class="lc iu">输出</strong>通道的大小与<strong class="lc iu">输入</strong>通道的大小<strong class="lc iu">相等</strong>时，这非常有用。简单来说，当内核为3*3时，输出通道的大小每侧减少一个。为了克服这个问题，我们可以使用填充1。</p><p id="f286" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">因此，填充对参数数量没有影响，但会产生与填充大小成比例的额外计算时间。但一般来说，与输入声道的大小相比，填充通常足够小，以至于不会影响计算时间。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nq"><img src="../Images/9127a3051772ab3d2bf6c08e869f4787.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5IDdVgfnQ9zdlLB_n3kl6Q.png"/></div></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">请注意，参数图中的曲线是相同的</p></figure><h1 id="2637" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">扩张</h1><p id="c6b3" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在某种程度上，膨胀就是地核的宽度。默认等于1，对应于 <strong class="lc iu">卷积</strong>期间输入通道<strong class="lc iu">上内核的每个像素</strong>之间的<strong class="lc iu">偏移。</strong></p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nu"><img src="../Images/5ad0acb70c7e77ca03a3d64d6d0ab43e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Kpk5osuivJe_QcRn8vW_ZQ.gif"/></div></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">输入形状:(2，7，7) —输出形状:(1，1，5) — K : (3，3) — P : (1，1) — S : (1，1) — D : (4，2) — G : 1</p></figure><p id="fbde" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">我在我的GIF上夸大了一点，但如果我们以(4，2)的膨胀为例，那么输入通道上的内核的<strong class="lc iu">感受域在垂直方向上加宽了4 * ( 3 -1)=8，在水平方向上加宽了2 *(3–1)= 4(对于3乘3的内核)。</strong></p><p id="e86c" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">就像填充一样，膨胀对参数的数量没有影响，对计算时间的影响也非常有限。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nq"><img src="../Images/64e22da210c094a1086b8fa3dafaa9a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jFrBUt2To8oWGgOlU0reRw.png"/></div></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">请注意，参数图中的曲线是相同的</p></figure><h1 id="47da" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">组</h1><p id="ab76" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在特定的情况下，组非常有用。例如，如果我们有几个串联的数据源。当没有必要对待他们相互依赖的时候。输入通道可以<strong class="lc iu">分组并独立处理</strong>。最后，输出通道在最后被<strong class="lc iu">连接</strong>。</p><p id="b66a" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">如果有2组2个输入通道和4个输出通道。这就像将输入通道分成两组(每组一个输入通道)，并使其通过一个输出通道数量减半的卷积层。然后输出声道被连接起来。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nv"><img src="../Images/520de21990daa56b36aaac7f0e973138.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*zeNP0KMPiFZwrjIh8G3ypg.gif"/></div></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">输入形状:(2，7，7) —输出形状:(4，5，5) — K : (3，3) — P : (2，2) — S : (2，2) — D : (1，1) — G : 2</p></figure><p id="5deb" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">需要注意的是，组的数量必须完全除以输入通道的数量和输出通道的数量(<strong class="lc iu">公约数</strong>)。</p><p id="690d" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">因此，参数的数量除以组的数量。关于Pytorch的计算时间，该算法针对组进行了优化，因此应该会减少计算时间。但是，还应该考虑到，必须将输出通道的<strong class="lc iu">组形成</strong>和<strong class="lc iu">连接</strong>的计算时间与<strong class="lc iu">相加。</strong></p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nq"><img src="../Images/910e5f7d625445554b7b78b1b52a5fdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z5Hl2_Lxo_SiVkjDTYDLkQ.png"/></div></div></figure><h1 id="ed5c" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">输出通道尺寸</h1><p id="161c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">有了所有参数的知识，就可以从输入通道的大小计算出输出通道的大小。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nw"><img src="../Images/436b4e323128eefd3d1b2db1b759701d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gR2Zxe_ADxVpceFb4nDXaA.png"/></div></div></figure><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nx"><img src="../Images/a41213d2ce618721d92c099fba464fc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eGtKKRvZfNm6mIdQlVXisA.png"/></div></div></figure><blockquote class="ny nz oa"><p id="cd08" class="la lb mx lc b ld lw ju lf lg lx jx li ob ly ll lm oc lz lp lq od ma lt lu lv im bi translated">知识就是分享。 <br/> <strong class="lc iu">支持</strong>我，获得<strong class="lc iu">访问<a class="ae mn" href="https://axel-thevenot.medium.com/membership" rel="noopener"> <strong class="lc iu">中我所有文章的</strong>一键点击此处</a></strong> 。</p></blockquote><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nx"><img src="../Images/94e903d7d66ff043ca9645dbc42c33bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y7Q5U2MjIji7pvt6DRzq3A.png"/></div></div></figure><h1 id="1eaf" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">来源</h1><p id="a15d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><a class="ae mn" href="https://cs.nyu.edu/~yann/talks/lecun-ranzato-icml2013.pdf" rel="noopener ugc nofollow" target="_blank">深度学习教程</a>，Y. LeCun</p><p id="897f" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated"><a class="ae mn" href="https://pytorch.org/docs/stable/nn.html" rel="noopener ugc nofollow" target="_blank">文档torch.nn </a>，Pytorch</p><p id="b01f" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated"><a class="ae mn" href="https://cs231n.github.io/convolutional-networks/" rel="noopener ugc nofollow" target="_blank">卷积神经网络</a>，cs231n</p><p id="6af9" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated"><a class="ae mn" href="https://keras.io/layers/convolutional/" rel="noopener ugc nofollow" target="_blank">卷积层</a>，Keras</p><p id="3592" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">所有的图像都是自制的</p><p id="7e33" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">所有计算时间测试都是在我的GPU (GeForce GTX 960M)上用Pytorch执行的，如果你想自己运行它们或执行替代测试，可以从GitHub库 获得<a class="ae mn" href="https://github.com/AxelThevenot/GIF_convolutions" rel="noopener ugc nofollow" target="_blank"> <strong class="lc iu">。</strong></a></p></div></div>    
</body>
</html>