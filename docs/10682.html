<html>
<head>
<title>An Implementation of DBSCAN on PySpark</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 PySpark 上实现 DBSCAN</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/an-efficient-implementation-of-dbscan-on-pyspark-3e2be646f57d?source=collection_archive---------17-----------------------#2020-07-26">https://towardsdatascience.com/an-efficient-implementation-of-dbscan-on-pyspark-3e2be646f57d?source=collection_archive---------17-----------------------#2020-07-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="db75" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一种基于三角形不等式的高效距离计算和聚类合并算法</h2></div><p id="f929" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">DBSCAN 是一种众所周知的聚类算法，它经受住了时间的考验。虽然算法没有包含在<a class="ae le" href="https://spark.apache.org/docs/latest/ml-clustering.html" rel="noopener ugc nofollow" target="_blank"> Spark MLLib </a>中。有几个实现(<a class="ae le" href="https://github.com/alitouka/spark_dbscan" rel="noopener ugc nofollow" target="_blank"> 1 </a>、<a class="ae le" href="https://github.com/mraad/dbscan-spark" rel="noopener ugc nofollow" target="_blank"> 2 </a>、<a class="ae le" href="https://github.com/irvingc/dbscan-on-spark" rel="noopener ugc nofollow" target="_blank"> 3 </a>)虽然都是在 scala 中。在<a class="ae le" href="https://github.com/htleeab/DBSCAN-pyspark" rel="noopener ugc nofollow" target="_blank"> PySpark </a>中的实现使用 rdd 与其自身的笛卡儿积，这导致 O(n)复杂度，并且在滤波器之前可能需要 O(n)内存。</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="6845" class="lo lp it lk b gy lq lr l ls lt">ptsFullNeighborRDD=rdd.cartesian(rdd)                            .filter(lambda (pt1,pt2): dist(pt1,pt2)&lt;eps)                            .map(lambda (pt1,pt2):(pt1,[pt2]))                            .reduceByKey(lambda pts1,pts2: pts1+pts2)                            .filter(lambda (pt, pts): len(pts)&gt;=minPts)</span><span id="038a" class="lo lp it lk b gy lu lr l ls lt">source: <a class="ae le" href="https://github.com/htleeab/DBSCAN-pyspark/blob/master/DBSCAN.py" rel="noopener ugc nofollow" target="_blank">https://github.com/htleeab/DBSCAN-pyspark/blob/master/DBSCAN.py</a></span></pre><p id="65f7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">关于 DBSCAN 算法复杂性的快速入门:</p><blockquote class="lv lw lx"><p id="7340" class="ki kj ly kk b kl km ju kn ko kp jx kq lz ks kt ku ma kw kx ky mb la lb lc ld im bi translated"><a class="ae le" href="https://en.wikipedia.org/wiki/DBSCAN#Complexity" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/DBSCAN#Complexity</a></p><p id="c91d" class="ki kj ly kk b kl km ju kn ko kp jx kq lz ks kt ku ma kw kx ky mb la lb lc ld im bi translated">DBSCAN 可能多次访问数据库的每个点(例如，作为不同聚类的候选)。然而，出于实际考虑，时间复杂度主要由 regionQuery 调用的数量决定。DBSCAN 对每个点只执行一个这样的查询，并且如果使用在 O(log <em class="it"> n </em>)中执行<a class="ae le" href="https://en.wikipedia.org/wiki/Fixed-radius_near_neighbors" rel="noopener ugc nofollow" target="_blank">邻域查询</a>的<a class="ae le" href="https://en.wikipedia.org/wiki/Spatial_index" rel="noopener ugc nofollow" target="_blank">索引结构，则获得 O( <em class="it"> n </em> log <em class="it"> n </em>)的总体平均运行时间复杂度(如果以有意义的方式选择参数ε，即平均只返回 O(log <em class="it"> n </em>)个点)。在不使用加速索引结构的情况下，或者在退化数据上(例如，距离小于ε的所有点)，最坏情况运行时间复杂度保持为 O( <em class="it"> n </em>)。大小为(<em class="it"> n </em> - <em class="it"> n </em> )/2 的距离矩阵可以被具体化以避免距离重新计算，但是这需要 O( <em class="it"> n </em>)存储器，而基于非矩阵的 DBSCAN 实现只需要 O( <em class="it"> n </em>)存储器。</a></p></blockquote><p id="ec33" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将探讨如何通过减少距离计算的次数，在不使用 O(n)运算的情况下，在 PySpark 中高效地实现 DBSCAN。我们将实现一个基于三角形不等式的索引/分区结构来实现这一点。</p><h1 id="66ca" class="mc lp it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">三角形不等式</h1><p id="55ae" class="pw-post-body-paragraph ki kj it kk b kl mt ju kn ko mu jx kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">让我们用<strong class="kk iu"> </strong>来刷新三角形不等式。如果三角形有三个顶点<em class="ly"> a </em>、<em class="ly"> b </em>和<em class="ly"> c、</em>以及给定的距离度量<em class="ly"> d. </em>那么</p><p id="cb0b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ly"> d </em> ( <em class="ly"> a，b</em>)<em class="ly"/>≤<em class="ly">d</em>(<em class="ly">a，c </em> ) <em class="ly"> + d </em> ( <em class="ly"> c，b </em>)</p><p id="1eda" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ly"> d </em> ( <em class="ly"> a，c</em>)<em class="ly"/>≤<em class="ly">d</em>(<em class="ly">a，b </em> ) <em class="ly"> + d </em> ( <em class="ly"> b，c </em>)</p><p id="d90d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ly"> d </em> ( <em class="ly"> b，c</em>)<em class="ly"/>≤<em class="ly">d</em>(<em class="ly">b，a </em> ) <em class="ly"> + d </em> ( <em class="ly"> a，c </em>)</p><p id="1f4e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在 DBSCAN 中有一个参数ε，用来寻找点与点之间的联系。现在，让我们用这个参数来看看能否利用三角形不等式来减少运算次数。</p><p id="3f7a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设有四个点<em class="ly"> x </em>、<em class="ly"> y、z、</em>c、</p><p id="3c7f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">引理 1 </strong>:如果<em class="ly"> d </em> ( <em class="ly"> x，c </em> ) ≥ ( <em class="ly"> k </em> +1)ε和<em class="ly"> d </em> ( <em class="ly"> y，c </em> ) &lt; <em class="ly"> k </em> ε那么<em class="ly"> d </em> ( <em class="ly"> x，y<em class="ly"/></em></p><p id="a1ae" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">根据三角形不等式，</p><p id="7aac" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ly"> d </em> ( <em class="ly"> x，c </em> ) ≤ <em class="ly"> d </em> ( <em class="ly"> x，y </em> ) + <em class="ly"> d </em> ( <em class="ly"> y，c </em>)</p><p id="d093" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ly"> d </em> ( <em class="ly"> x，c </em> )- <em class="ly"> d </em> ( <em class="ly"> y，c </em> )≤ <em class="ly"> d </em> ( <em class="ly"> x，y </em>)</p><p id="b090" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ly"> d </em> ( <em class="ly"> x，c </em> )- <em class="ly"> d </em> ( <em class="ly"> y，c</em>)&gt;(<em class="ly">k</em>+1)ε-<em class="ly">k</em>ε&gt;ε</p><p id="5d81" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以<em class="ly"> d </em> ( <em class="ly"> x，y </em> ) &gt; ε</p><p id="d18f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">引理 2 </strong>:如果<em class="ly"> d </em> ( <em class="ly"> x，c </em> ) ≤ <em class="ly"> l </em> ε和<em class="ly"> d </em> ( <em class="ly"> z，c</em>)&gt;(<em class="ly">l+1)</em>ε则<em class="ly"> d </em> ( <em class="ly"> x</em></p><p id="055f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">根据三角形不等式，</p><p id="6f2d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ly"> d </em> ( <em class="ly"> z，c </em> ) ≤ <em class="ly"> d </em> ( <em class="ly"> x，z </em> ) + <em class="ly"> d </em> ( <em class="ly"> x，c </em>)</p><p id="197c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ly"> d </em> ( <em class="ly"> z，c </em> )- <em class="ly"> d </em> ( <em class="ly"> x，c </em> )≤ <em class="ly"> d </em> ( <em class="ly"> x，z </em></p><p id="e18e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ly"> d </em> ( <em class="ly"> z，c </em> )- <em class="ly"> d </em> ( <em class="ly"> x，c</em>)&gt;(<em class="ly">l</em>+1)ε-<em class="ly">l</em>ε</p><p id="3953" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ly"> d </em> ( <em class="ly"> z，c </em> )- <em class="ly"> d </em> ( <em class="ly"> x，c </em> ) &gt; ε</p><p id="422d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以<em class="ly"> d </em> ( <em class="ly"> x，z </em> ) &gt; ε</p><p id="be88" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从上面我们可以推断出，如果我们计算所有的点到<em class="ly"> c </em>的距离，那么我们可以使用上面的标准过滤点<em class="ly"> y </em>和<em class="ly"> z </em>。我们可以计算从<em class="ly"> c </em>到同心环(中心为<em class="ly"> c </em>)中分割点的距离。</p><h1 id="8f56" class="mc lp it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">重叠同心环形隔板</h1><h2 id="800e" class="lo lp it bd md my mz dn mh na nb dp ml kr nc nd mn kv ne nf mp kz ng nh mr ni bi translated">隔板的宽度应该是多少？</h2><p id="59ef" class="pw-post-body-paragraph ki kj it kk b kl mt ju kn ko mu jx kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">从以上引理可以看出，如果</p><p id="43d9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ly">(m+1</em>)ε≥<em class="ly">d</em>(<em class="ly">x，c </em> ) ≥ <em class="ly"> m </em> ε那么我们就可以过滤出点<em class="ly"> y </em>和<em class="ly"> z </em>如果<em class="ly"> d </em> ( <em class="ly"> y，c </em> ) &lt; ( <em class="ly"> m </em> -1)ε和<em class="ly"> d</em></p><p id="9518" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由此我们可以推导出，对于<em class="ly">(m+1</em>)ε≥<em class="ly">d</em>(<em class="ly">x，c </em> ) ≥ <em class="ly"> m </em> ε为真的任意一点，我们可以有一个宽度为(<em class="ly"> m </em> +3)ε的分块，从(<em class="ly"> m </em> -1)ε开始，到(<em class="ly"> m+ </em> 2)ε结束</p><figure class="lf lg lh li gt nk gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi nj"><img src="../Images/3d0b48a1847c54108eb8de4c71b1f4fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RSgsNdL2zZc4eBdj1mVeWQ.png"/></div></div><p class="nr ns gj gh gi nt nu bd b be z dk translated">图 1:隔板的宽度应该是多少？</p></figure><p id="627f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是它看起来的样子。二维空间被分成ε欧氏距离的分位数。绿色环表示分区。<em class="ly"> x </em> 1 在距离<em class="ly">c</em>(<em class="ly">m-</em>1<em class="ly">)</em>ε—(<em class="ly">m</em>+2)ε隔板的中心)的(<em class="ly"> m </em> +1/2)ε距离处。<em class="ly"> x </em> 2 和<em class="ly"> x </em> 3 位于<em class="ly"> m </em> ε和(<em class="ly"> m </em> +1)ε距离<em class="ly"> c. </em>很明显对于<em class="ly"> x </em> 1、<em class="ly"> x </em> 2 和<em class="ly"> x </em> 3 所有相关点(在圆内</p><p id="27fb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们创建互斥分区并计算该分区内各点之间的距离，这将是不完整的。比如<em class="ly"> x </em> 4 和<em class="ly"> x </em> 5 的范围圈会重叠两个分区。因此需要重叠分区。一种策略是将分区移动ε。尽管在这种情况下，如果分区宽度是 3ε，那么一个点可能出现在三个不同的分区中。相反，分区是以 2ε宽度创建的，并按ε移动它们。在这种情况下，一个点可能只出现在两个分区中。</p><div class="lf lg lh li gt ab cb"><figure class="nv nk nw nx ny nz oa paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><img src="../Images/8c65e751dc79b69dd1875196e9021406.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*tvxEsyiVAuADZfx1L2JjlA.png"/></div></figure><figure class="nv nk ob nx ny nz oa paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><img src="../Images/8f01851306d4f1a827bc22684e07e5d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*nJC0v6fhBoeQ7ls5g7SejA.png"/></div><p class="nr ns gj gh gi nt nu bd b be z dk oc di od oe translated">图 2:具有ε重叠的 2ε宽度分区</p></figure></div><p id="d7a3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面两张图片展示了这种分区方案的工作原理。两个分区的组合允许对从<em class="ly"> m </em> ε到(<em class="ly"> m+ </em> 1)ε的所有点进行ε半径的范围查询。第一个分区覆盖从<em class="ly"> m </em> ε到(<em class="ly"> m+ </em> 1/2)ε ( <em class="ly"> x </em> 2 被覆盖但<em class="ly"> x </em> 3 未被覆盖)的所有点，第二个分区覆盖(<em class="ly"> m+ </em> 1/2)ε到(<em class="ly"> m+ </em> 1)ε ( <em class="ly"> x </em> 3 被覆盖但 3)</p><h1 id="14ac" class="mc lp it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">分区可视化</h1><p id="160a" class="pw-post-body-paragraph ki kj it kk b kl mt ju kn ko mu jx kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">让我们看看这些分区在一些生成的数据上是什么样子的。</p><figure class="lf lg lh li gt nk gh gi paragraph-image"><div class="gh gi of"><img src="../Images/300951cb3aeff223cfed06ae780a7bd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*3JxtBgQIarE12O7N7MBZzQ.png"/></div><p class="nr ns gj gh gi nt nu bd b be z dk translated">图 3:数据点</p></figure><p id="0115" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上述数据和图像由以下代码生成:</p><figure class="lf lg lh li gt nk"><div class="bz fp l di"><div class="og oh l"/></div></figure><figure class="lf lg lh li gt nk gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi oi"><img src="../Images/a025e997294eece9f481bfbc7ae3d2bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-6nLL_B4KdmN0rqpoB3r7A.png"/></div></div><p class="nr ns gj gh gi nt nu bd b be z dk translated">图 4:从数据中生成的几个分区</p></figure><p id="23f4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上述数据分区由以下代码生成:</p><figure class="lf lg lh li gt nk"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="398e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">partition_index 标识每个分区。如前所述，根据从<em class="ly"> c </em>(枢轴)到ε的距离，每个数据点被放入两个分区。距离方法一次处理一个点。在 PySpark <em class="ly">中，flatMap </em>方法用于将每个点映射到元组数组(out)中。</p><figure class="lf lg lh li gt nk"><div class="bz fp l di"><div class="og oh l"/></div></figure><h1 id="cfc3" class="mc lp it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">合并分区</h1><p id="b2c7" class="pw-post-body-paragraph ki kj it kk b kl mt ju kn ko mu jx kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">在生成可视化之前，合并分区内的所有数据点。它们还需要合并，以便在 PySpark 上进一步处理 DBSCAN。</p><p id="87f0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ly"> reduceByKey </em>方法用于将分区数据合并为一个。单词分区的使用可能会与 PySpark 分区混淆，但这是两件不同的事情。虽然<em class="ly"> partitionBy </em>方法也可以用来协调这一点。</p><figure class="lf lg lh li gt nk"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="2499" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<em class="ly"> reduceByKey </em>，<em class="ly"> </em>之后，我们将得到 rdd 的每一行，如图 4 所示。正如你所看到的，有一个重叠，所以点将在两行 rdd 中，这是故意的。</p><h1 id="543f" class="mc lp it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">距离计算</h1><figure class="lf lg lh li gt nk"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="88fc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码计算每个分区内的距离。该方法的输出是一个元组列表。每个元组都有一个点的 id 和它在ε距离内的邻居集。我们知道，该点会出现在两个分区中，因此我们需要组合给定点的集合，以便在整个数据中获得其所有在ε距离内的邻居。<em class="ly"> reduceByKey </em>用于通过对集合进行并集运算来合并集合。</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="d284" class="lo lp it lk b gy lq lr l ls lt">reduceByKey(lambda x, y: x.union(y))</span></pre><p id="cbf8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">到目前为止，组合代码如下所示:</p><figure class="lf lg lh li gt nk"><div class="bz fp l di"><div class="og oh l"/></div></figure><h1 id="3063" class="mc lp it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">核心和边界点标记</h1><p id="43da" class="pw-post-body-paragraph ki kj it kk b kl mt ju kn ko mu jx kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">一旦我们在一个点的ε距离内有了邻居，我们就可以确定它是核心点还是边界点。</p><p id="b348" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">核心点</strong>:ε距离内至少有<em class="ly">个 min_pts </em></p><p id="056f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">边界点</strong>:ε距离内有少于<em class="ly">个 min_pts </em>，但其中一个是核心点。</p><p id="6e7a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了识别核心点和边界点，首先，我们将它们分配给一个集群。对于作为核心点的每个点，我们创建一个与其 id 相同的聚类标签(假设 id 是唯一的)。我们为每个核心点及其邻居创建一个元组，其形式为(<em class="ly"> id </em>，[( <em class="ly"> cluster_label </em>，<em class="ly"> is_core_point </em> )])。这种情况下的所有邻居都将被标记为基点。让我们举一个例子</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="8a93" class="lo lp it lk b gy lq lr l ls lt"><em class="ly">min_pts</em> = 3<br/>Input: (3, set(4,6,2))<br/>Output: [(3, [(3, True)]), (4, [(3, False)]), (6, [(3, False)]), (2, [(3, False)])]</span></pre><p id="ffa8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">输入是一个元组，其中 3 是点的 id，而(4，6，2)是它在ε距离内的邻居。</p><p id="bb89" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可以看出，所有点都被分配了聚类标签 3。当 3 被指定为<em class="ly">真</em>时<em class="ly">是核心点</em>并且所有其他点被认为是基点并且被指定为<em class="ly">假</em>时<em class="ly">是核心点。</em></p><p id="056e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于 4、6 和 2，我们可能有类似的输入元组，它们可能被指定为核心点，也可能不被指定为核心点。想法是最终组合一个点的所有聚类标签，并且如果至少一个对<em class="ly">的赋值是 _ 核心 _ 点</em>是<em class="ly">真</em>，那么它是核心点，否则它是边界点。</p><p id="3a3c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们使用<em class="ly"> reduceByKey </em>方法将一个点的所有(<em class="ly"> cluster_label </em>，<em class="ly"> is_core_point </em>)元组组合起来，然后在组合该点的所有聚类标签时调查它是否是核心点。如果它是一个边界点，那么我们将只为它留下一个集群标签。</p><figure class="lf lg lh li gt nk"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="bcff" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上述方法用于组合一个点的所有聚类标签。同样，如果它是边界点，那么我们只返回第一个聚类标签。</p><p id="464e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">到目前为止，PySpark 中的代码如下所示:</p><figure class="lf lg lh li gt nk"><div class="bz fp l di"><div class="og oh l"/></div></figure><h1 id="78e9" class="mc lp it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">连接的核心和边界点</h1><p id="65f4" class="pw-post-body-paragraph ki kj it kk b kl mt ju kn ko mu jx kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">对于每个点，我们都有聚类标签。如果一个点有多个聚类标签，则意味着这些聚类是相连的。那些相连的聚类是我们需要求解 DBSCAN 的最终聚类。我们通过创建一个图来解决这个问题，如果顶点被分配到同一点，则图中的顶点作为聚类标签，而边位于聚类标签之间。</p><figure class="lf lg lh li gt nk"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="0ba4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，combine_cluster_rdd 是行的集合，其中每一行都是一个元组(<em class="ly"> point </em>，<em class="ly"> cluster_labels </em>)。每个聚类标签是顶点，点的聚类标签的组合是边。该图的连通分量给出了每个聚类标签和一个连通的聚类之间的映射。我们可以将它应用到点上以得到最终的聚类。</p><figure class="lf lg lh li gt nk"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="3093" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面是最终方法的样子，它返回一个 Spark 数据帧，带有点 id、集群组件标签和一个布尔指示符(如果是核心点的话)。</p><h1 id="8ca3" class="mc lp it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">比较</h1><p id="b809" class="pw-post-body-paragraph ki kj it kk b kl mt ju kn ko mu jx kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">现在，我将结果与 DBSCAN 的<a class="ae le" href="https://scikit-learn.org/stable/auto_examples/cluster/plot_dbscan.html" rel="noopener ugc nofollow" target="_blank"> sklearn </a>实现进行比较。</p><figure class="lf lg lh li gt nk"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="d06e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ly"> make_blobs </em>方法在三个输入中心周围创建斑点。使用 sklearn 和我的实现在ε=0.3 和<em class="ly"> min_pts </em> =10 的情况下运行 DBSCAN 得到以下结果。</p><div class="lf lg lh li gt ab cb"><figure class="nv nk oj nx ny nz oa paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><img src="../Images/271c66eba9e271ccd0228399f6e0c6f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*XnBvbs83szGAxo5OQHv0sg.png"/></div></figure><figure class="nv nk oj nx ny nz oa paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><img src="../Images/c21b5bc9d5e7473833fd08438cd5623f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*b8gDyhBkT7I7G_wgI1S5Sg.png"/></div><p class="nr ns gj gh gi nt nu bd b be z dk oc di od oe translated">左:sklearn vs 右:基于 pyspark 的实现(ε=0.3 且<em class="ok"> min_pts </em> =10)</p></figure></div><p id="e126" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">核心点是较大的圆圈，而边界点是较小的圆圈。噪声点被涂成黑色，这在两种实现中是相同的。突出的一点是边界点被分配了不同的集群，这说明了 DBSCAN 的不确定性。我的另一篇帖子也谈到了这一点。</p><div class="ol om gp gr on oo"><a href="https://medium.com/@salilkjain/some-notes-on-dbscan-algorithm-61a2e9acce29" rel="noopener follow" target="_blank"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd iu gy z fp ot fr fs ou fu fw is bi translated">关于 DBSCAN 算法的几点注记</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">在这篇文章中，我想讨论一些关于 DBSCAN 算法的见解。通常，当我看一个算法时，我…</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">medium.com</p></div></div><div class="ox l"><div class="oy l oz pa pb ox pc np oo"/></div></div></a></div><div class="lf lg lh li gt ab cb"><figure class="nv nk oj nx ny nz oa paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><img src="../Images/8ce8de3c3c5271ed57a9432d1611cd65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*34M2bWFDfI-4P5Kx2uvD9Q.png"/></div></figure><figure class="nv nk oj nx ny nz oa paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><img src="../Images/78979792464d596b73a235d909df6c49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*KUh_WOYSU_hqTmeqQ3fQ4Q.png"/></div><p class="nr ns gj gh gi nt nu bd b be z dk oc di od oe translated">左:sklearn vs 右:基于 pyspark 的实现(ε=0.2 且<em class="ok"> min_pts </em> =10)</p></figure></div><p id="7bef" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于ε=0.2，我们得到分配给相同聚类的边界点。下面是环中数据的一些代码和结果。</p><h2 id="0fcc" class="lo lp it bd md my mz dn mh na nb dp ml kr nc nd mn kv ne nf mp kz ng nh mr ni bi translated"><strong class="ak">操作次数</strong></h2><p id="7352" class="pw-post-body-paragraph ki kj it kk b kl mt ju kn ko mu jx kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">对于 n=750，DBSCAN 的简单实现所需的距离运算的数量将是 n(n-1)/2，即 280875。当我们基于ε创建分区时，ε越小，所需的距离运算次数就越少。在这种情况下，总共需要 149716 次(ε= 0.2)和 217624 次(ε=0.3)运算。</p><h2 id="7403" class="lo lp it bd md my mz dn mh na nb dp ml kr nc nd mn kv ne nf mp kz ng nh mr ni bi translated"><strong class="ak">环比数据</strong></h2><figure class="lf lg lh li gt nk"><div class="bz fp l di"><div class="og oh l"/></div></figure><div class="lf lg lh li gt ab cb"><figure class="nv nk oj nx ny nz oa paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><img src="../Images/a0b76329db9835dcc9c1eaf76f3a4f15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*EbS2jonzTpFj4qOphw0ICA.png"/></div></figure><figure class="nv nk oj nx ny nz oa paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><img src="../Images/e0b31d8dcb0dd2eb79dda00b6e00104e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*Ogej0f-7GP9aozlYnhTGtw.png"/></div><p class="nr ns gj gh gi nt nu bd b be z dk oc di od oe translated">左:sklearn vs 右:基于 pyspark 的实现(ε=0.3 并且<em class="ok"> min_pts </em> =5)</p></figure></div><div class="ab cb"><figure class="nv nk oj nx ny nz oa paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><img src="../Images/e748bdb120fa488c48c6346706703ab0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*pw_z3uTqEvyOD0-tdtETUg.png"/></div></figure><figure class="nv nk oj nx ny nz oa paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><img src="../Images/608aaac7b5bc845c064fa045f436b0a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*yz3XotjijgUv0cnRnyL4KA.png"/></div><p class="nr ns gj gh gi nt nu bd b be z dk oc di od oe translated">左:sklearn vs 右:基于 pyspark 的实现(ε=1 且<em class="ok"> min_pts </em> =5)</p></figure></div><h1 id="9e61" class="mc lp it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">结论</h1><p id="2ddf" class="pw-post-body-paragraph ki kj it kk b kl mt ju kn ko mu jx kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">基于ε值的 pyspark 实现是高效的，其步骤如下:</p><ol class=""><li id="de41" class="pd pe it kk b kl km ko kp kr pf kv pg kz ph ld pi pj pk pl bi translated">分区数据:用ε移动的 2ε宽的重叠环进行分区。</li><li id="2506" class="pd pe it kk b kl pm ko pn kr po kv pp kz pq ld pi pj pk pl bi translated">合并分区数据:这样我们就可以在一条记录中获得所有分区数据。</li><li id="ca5c" class="pd pe it kk b kl pm ko pn kr po kv pp kz pq ld pi pj pk pl bi translated">距离计算:计算同一分区内的距离</li><li id="2605" class="pd pe it kk b kl pm ko pn kr po kv pp kz pq ld pi pj pk pl bi translated">点标注:基于相邻点、标注核心和边界点的数量。</li><li id="2ab3" class="pd pe it kk b kl pm ko pn kr po kv pp kz pq ld pi pj pk pl bi translated">连接的簇:使用 Graphframe 连接簇标签以评估最终的 DBSCAN 标签。</li></ol><p id="8a4f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与现有实现的比较显示了该算法和该帖子的实现的准确性。</p><h2 id="74ae" class="lo lp it bd md my mz dn mh na nb dp ml kr nc nd mn kv ne nf mp kz ng nh mr ni bi translated">是否高效？</h2><p id="a630" class="pw-post-body-paragraph ki kj it kk b kl mt ju kn ko mu jx kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">在具有驱动程序和工作节点的本地机器上，实现比 sklearn 慢。可能有几个原因需要调查:</p><ol class=""><li id="a71c" class="pd pe it kk b kl km ko kp kr pf kv pg kz ph ld pi pj pk pl bi translated">对于少量数据，sklearn 可能要快得多，但对于大数据来说是这样吗？</li><li id="04f2" class="pd pe it kk b kl pm ko pn kr po kv pp kz pq ld pi pj pk pl bi translated">Graphframe 需要相当长的时间来执行，想知道是否可以在驱动程序上使用其他图形库来执行连接组件分析？</li></ol><h1 id="6dad" class="mc lp it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">履行</h1><p id="7f26" class="pw-post-body-paragraph ki kj it kk b kl mt ju kn ko mu jx kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">完整的 PySpark 实施可在以下网址找到:</p><div class="ol om gp gr on oo"><a href="https://github.com/SalilJain/pyspark_dbscan" rel="noopener  ugc nofollow" target="_blank"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd iu gy z fp ot fr fs ou fu fw is bi translated">SalilJain/pyspark_dbscan</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">在 py spark-salil Jain/py spark _ DBSCAN 上“高效”实现 DBS can</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">github.com</p></div></div><div class="ox l"><div class="pr l oz pa pb ox pc np oo"/></div></div></a></div></div></div>    
</body>
</html>