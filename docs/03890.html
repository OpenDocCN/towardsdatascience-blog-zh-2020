<html>
<head>
<title>Graph data structure cheat sheet for coding interviews.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编码面试的图表数据结构备忘单。</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/graph-data-structure-cheat-sheet-for-coding-interviews-a38aadf8aa87?source=collection_archive---------3-----------------------#2020-04-11">https://towardsdatascience.com/graph-data-structure-cheat-sheet-for-coding-interviews-a38aadf8aa87?source=collection_archive---------3-----------------------#2020-04-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="41d0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这篇博客是我的“<a class="ae ko" href="https://medium.com/@nhudinhtuan/15-days-cheat-sheet-for-hacking-technical-interviews-at-big-tech-companies-d780717dcec1" rel="noopener">大型科技公司</a>黑客技术面试 15 天备忘单”的一部分。在这篇博客中，我不会详细介绍图形数据结构，但我会总结一些解决编码面试问题的必备图形算法。</p><h1 id="05ce" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">图形数据结构</h1><p id="e0a3" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">图是由顶点(V)和边(E)组成的非线性数据结构。</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi ls"><img src="../Images/df2be48011fe81246b56d118cb27d172.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HpYMnHjGZWmH9NKRG05lAg.jpeg"/></div></div></figure><p id="1cc0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最常用的图的表示是邻接矩阵(大小为 V x V 的 2D 数组，其中 V 是图中顶点的数量)和邻接表(列表数组表示与每个顶点相邻的顶点的列表)。</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi me"><img src="../Images/e7f12e4a622f46aa44df63cf508bb9f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WRZ395WrerEbM35ngz5OUQ.png"/></div></div></figure><p id="9e96" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在接下来的几节中，让我们来看看与图形数据结构相关的一些必须知道的算法。为简单起见，所有实现中都使用邻接表表示。</p><h2 id="03c9" class="mf kq it bd kr mg mh dn kv mi mj dp kz kb mk ml ld kf mm mn lh kj mo mp ll mq bi translated">1.广度优先搜索(BFS)</h2><pre class="lt lu lv lw gt mr ms mt mu aw mv bi"><span id="40e5" class="mf kq it ms b gy mw mx l my mz">Input (graph 1): graph = [[1,2], [0,2,4], [0,1,3], [2], [1]], s = 0<br/>Output: <strong class="ms iu">0 1 2 4 3</strong></span></pre><p id="7722" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">图的广度优先搜索类似于<a class="ae ko" href="https://medium.com/@nhudinhtuan/binary-tree-traversals-cheat-sheet-for-coding-interviews-a71af9fe1dba" rel="noopener">树的广度优先遍历</a>。但是，图可能包含圈，所以我们可能会一次又一次地访问同一个顶点。为了避免这种情况，我们可以使用布尔访问数组来标记访问过的顶点。</p><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="309f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面的代码只遍历从给定的源顶点可以到达的顶点。为了完成不连通图的 BFS 遍历，我们需要为每个顶点调用 BFS。</p><p id="545b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">时间复杂度是 O(V+E ),其中 V 是图中顶点的数量，E 是图中边的数量。</p><h2 id="f310" class="mf kq it bd kr mg mh dn kv mi mj dp kz kb mk ml ld kf mm mn lh kj mo mp ll mq bi translated">2.深度优先搜索</h2><pre class="lt lu lv lw gt mr ms mt mu aw mv bi"><span id="07a0" class="mf kq it ms b gy mw mx l my mz">Input (graph 1): graph = [[1,2], [0,2,4], [0,1,3], [2], [1]], s = 0<br/>Output: <strong class="ms iu">0 1 2 3 4 (or 0 2 3 1 4)</strong></span></pre><p id="a99e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">类似于 BFS，我们也需要使用一个布尔数组来标记 DFS 的访问过的顶点。</p><p id="30aa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">递归实现:</p><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="28c2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用堆栈的迭代实现。请注意，堆栈可能<em class="nc">包含同一个顶点两次，</em>，所以我们需要在打印前检查访问过的集合。</p><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="dbd7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于这两种实现方式，从给定的顶点可能无法到达所有的顶点(示例断开图)。为了完成 DFS 遍历，我们需要为每个顶点调用 DFS。</p><p id="6731" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">时间复杂度是 O(V+E ),其中 V 是图中顶点的数量，E 是图中边的数量。</p><h2 id="18ef" class="mf kq it bd kr mg mh dn kv mi mj dp kz kb mk ml ld kf mm mn lh kj mo mp ll mq bi translated">3.检测有向图中的圈</h2><pre class="lt lu lv lw gt mr ms mt mu aw mv bi"><span id="4bc5" class="mf kq it ms b gy mw mx l my mz">Given a <strong class="ms iu">directed</strong> graph, return true if the given graph contains at least one cycle, else return false.</span><span id="1b0d" class="mf kq it ms b gy nd mx l my mz">Input (graph 2): graph = [[1,2], [2], [0,3], [], [1]]<br/>Output: <strong class="ms iu">True</strong></span></pre><p id="d844" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">DFS 可用于检测图中的循环。只有当从一个顶点到它自己(自循环)或者到它在 DFS 栈树中的一个祖先有一个后沿时，图中才有一个循环。</p><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="ee4c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">时间复杂度和正常的 DFS 一样，都是 O(V+E)。</p><h2 id="a24d" class="mf kq it bd kr mg mh dn kv mi mj dp kz kb mk ml ld kf mm mn lh kj mo mp ll mq bi translated">4.检测无向图中的圈</h2><pre class="lt lu lv lw gt mr ms mt mu aw mv bi"><span id="8c67" class="mf kq it ms b gy mw mx l my mz">Given an <strong class="ms iu">undirected</strong> graph, return true if the given graph contains at least one cycle, else return false.</span><span id="dd58" class="mf kq it ms b gy nd mx l my mz">Input (graph 1): graph = [[1,2], [0,2,4], [0,1,3], [2], [1]]<br/>Output: <strong class="ms iu">True</strong></span></pre><p id="3dd0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于无向图，我们不需要跟踪整个堆栈树(与有向图的情况相比)。对于每个顶点“v”，如果有一个相邻的“u”使得 u 已经被访问过，并且 u 不是 v 的父节点，那么图中有一个圈。</p><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="503a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">时间复杂度和正常的 DFS 一样，都是 O(V+E)。</p><h2 id="08fd" class="mf kq it bd kr mg mh dn kv mi mj dp kz kb mk ml ld kf mm mn lh kj mo mp ll mq bi translated">5.多源 BFS</h2><p id="f6ee" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">在某些问题中，您需要为多个顶点启动 BFS，并计算行进深度。我们来看一个典型问题。</p><pre class="lt lu lv lw gt mr ms mt mu aw mv bi"><span id="1490" class="mf kq it ms b gy mw mx l my mz">Rotting Oranges: <a class="ae ko" href="https://leetcode.com/problems/rotting-oranges/" rel="noopener ugc nofollow" target="_blank">https://leetcode.com/problems/rotting-oranges/</a></span></pre><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi ne"><img src="../Images/d525ee639b3299940b28ba3bb1996117.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_l111oYuT3XcwqfhuQ2Mdg.jpeg"/></div></div></figure><p id="fd13" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个问题中，我们使用 BFS 来模拟这个过程。网格被认为是一个图形(一个橙色的单元是一个顶点，有边到单元的邻居)。从“深度”为 0 的所有腐烂的橙子开始 BFS，然后旅行到其深度为 1 的邻居。最后，如果我们仍然有未访问的橙子，返回-1，因为这不可能腐烂所有的橙子。</p><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="1bb3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">时间复杂度为 O(V+E) = O(网格中的单元数)。</p><h2 id="89ec" class="mf kq it bd kr mg mh dn kv mi mj dp kz kb mk ml ld kf mm mn lh kj mo mp ll mq bi translated">6.拓扑排序</h2><p id="9c79" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">拓扑排序是顶点的线性排序，使得对于每个有向边 uv，顶点 u 在排序中位于 v 之前。拓扑排序只可能用于<a class="ae ko" href="https://en.wikipedia.org/wiki/Directed_acyclic_graph" rel="noopener ugc nofollow" target="_blank">有向无环图(DAG) </a>。</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi nf"><img src="../Images/e590e43babb59295a1be9e2f92c49bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kXXJJRWrD6vhdDqc6RnEtA.jpeg"/></div></div></figure><pre class="lt lu lv lw gt mr ms mt mu aw mv bi"><span id="7b1d" class="mf kq it ms b gy mw mx l my mz">Given a <strong class="ms iu">DAG</strong>, return the topological sorting</span><span id="2645" class="mf kq it ms b gy nd mx l my mz">Input: graph = [[1,2], [2], [3], [], [1]]<br/>Output: <strong class="ms iu">4 0 1 2 3</strong></span></pre><p id="aff9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在普通的 DFS 中，我们在递归函数的开始打印顶点。为了找到拓扑排序，我们修改 DFS，使其首先递归调用所有相邻顶点，然后将其值推入堆栈。最后，我们打印出堆栈。</p><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="9590" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">时间复杂度和正常的 DFS 一样，都是 O(V+E)。</p><h2 id="3329" class="mf kq it bd kr mg mh dn kv mi mj dp kz kb mk ml ld kf mm mn lh kj mo mp ll mq bi translated">7.未加权图中的最短路径</h2><pre class="lt lu lv lw gt mr ms mt mu aw mv bi"><span id="6a49" class="mf kq it ms b gy mw mx l my mz">Given a unweighted graph, a source and a destination, we need to find shortest path from source to destination.</span><span id="bd0f" class="mf kq it ms b gy nd mx l my mz">Input (graph 1): graph = [[1,2], [0,2,4], [0,1,3], [2], [1]], s=4, d=0<br/>Output: <strong class="ms iu">4 1 0</strong></span><span id="8313" class="mf kq it ms b gy nd mx l my mz">Input (graph 2): graph = [[1,2], [2], [0, 3], [], [1]], s=1, d=0<br/>Output: <strong class="ms iu">1 2 0</strong></span></pre><p id="950d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于这个问题，我们使用 BFS，并在进行广度优先搜索时保存给定顶点的前任。最后，我们使用 predecessor 数组打印路径。</p><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="e483" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">时间复杂度和普通 BFS 一样，都是 O(V+E)。</p><h2 id="903d" class="mf kq it bd kr mg mh dn kv mi mj dp kz kb mk ml ld kf mm mn lh kj mo mp ll mq bi translated">7.加权图中的最短路径</h2><pre class="lt lu lv lw gt mr ms mt mu aw mv bi"><span id="4533" class="mf kq it ms b gy mw mx l my mz">Given a graph and a source vertex in graph, find shortest distances from source to all vertices in the given graph.</span><span id="54c7" class="mf kq it ms b gy nd mx l my mz">Input: graph = [[[1, 2], [2, 6]], [[2, 1]], [[0, 1], [3, 3]], [], [[1, 1]]], s=0<br/>Output: <strong class="ms iu">[0, 2, 3, 6, inf]</strong></span></pre><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi ng"><img src="../Images/2ff831ab3a1ccd8f9664bab2748f4079.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TPDkarMgeeG5kRf8z1NxTA.jpeg"/></div></div></figure><p id="7534" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个问题中，我们处理加权图(一个实数与图的每条边相关联)。该图被表示为一个邻接表，其项目是一对目标顶点&amp;权重。Dijkstra 算法用于查找从一个起始顶点到其他顶点的最短路径。该算法适用于有向或无向图，只要它的<em class="nc">在一条边上没有负权重。</em></p><p id="c92d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可以在<a class="ae ko" href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm" rel="noopener ugc nofollow" target="_blank">这里</a>阅读更多关于 Dijkstra 算法的内容。下面是我使用优先级队列的实现。</p><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="a68e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面的实现只返回距离。您可以添加一个前置数组(类似于未加权图中的最短路径)来打印出路径。时间复杂度是 O(V + VlogE)，其中 V 是图中顶点的数量，E 是图中边的数量。</p><h1 id="3dba" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">推荐问题</h1><p id="0d76" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">您可以通过以下问题练习图形数据结构:</p><ol class=""><li id="e1f6" class="nh ni it js b jt ju jx jy kb nj kf nk kj nl kn nm nn no np bi translated"><a class="ae ko" href="https://leetcode.com/problems/is-graph-bipartite/" rel="noopener ugc nofollow" target="_blank">图是二分的吗？</a></li><li id="cecf" class="nh ni it js b jt nq jx nr kb ns kf nt kj nu kn nm nn no np bi translated"><a class="ae ko" href="https://leetcode.com/problems/clone-graph/" rel="noopener ugc nofollow" target="_blank">克隆图形</a></li><li id="a94d" class="nh ni it js b jt nq jx nr kb ns kf nt kj nu kn nm nn no np bi translated"><a class="ae ko" href="https://leetcode.com/problems/course-schedule/" rel="noopener ugc nofollow" target="_blank">课程表</a></li><li id="71aa" class="nh ni it js b jt nq jx nr kb ns kf nt kj nu kn nm nn no np bi translated"><a class="ae ko" href="https://leetcode.com/problems/course-schedule-ii/" rel="noopener ugc nofollow" target="_blank">课程表二</a></li><li id="80b2" class="nh ni it js b jt nq jx nr kb ns kf nt kj nu kn nm nn no np bi translated"><a class="ae ko" href="https://leetcode.com/problems/number-of-islands/" rel="noopener ugc nofollow" target="_blank">岛屿数量</a></li><li id="eacf" class="nh ni it js b jt nq jx nr kb ns kf nt kj nu kn nm nn no np bi translated"><a class="ae ko" href="https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/" rel="noopener ugc nofollow" target="_blank">无向图中连通分量的数量</a></li><li id="5ed4" class="nh ni it js b jt nq jx nr kb ns kf nt kj nu kn nm nn no np bi translated"><a class="ae ko" href="https://leetcode.com/problems/graph-valid-tree/" rel="noopener ugc nofollow" target="_blank">图形有效树</a></li><li id="aea0" class="nh ni it js b jt nq jx nr kb ns kf nt kj nu kn nm nn no np bi translated"><a class="ae ko" href="https://leetcode.com/problems/reconstruct-itinerary/" rel="noopener ugc nofollow" target="_blank">重建旅程</a></li><li id="9514" class="nh ni it js b jt nq jx nr kb ns kf nt kj nu kn nm nn no np bi translated"><a class="ae ko" href="https://leetcode.com/problems/cheapest-flights-within-k-stops/" rel="noopener ugc nofollow" target="_blank">K 站内最便宜的航班</a>(提示:Dijkstra 算法)</li><li id="ea8b" class="nh ni it js b jt nq jx nr kb ns kf nt kj nu kn nm nn no np bi translated"><a class="ae ko" href="https://leetcode.com/problems/alien-dictionary/solution/" rel="noopener ugc nofollow" target="_blank">外星人字典</a>(提示:拓扑排序)</li></ol></div></div>    
</body>
</html>