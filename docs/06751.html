<html>
<head>
<title>A Swift Introduction To Metaprogramming in Julia</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Julia中元编程的快速介绍</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-swift-introduction-to-metaprogramming-in-julia-5eef529f5a8a?source=collection_archive---------68-----------------------#2020-05-26">https://towardsdatascience.com/a-swift-introduction-to-metaprogramming-in-julia-5eef529f5a8a?source=collection_archive---------68-----------------------#2020-05-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="737a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在Julia中使用Julia的元包进行编程的基础。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/243e350c9f1e17d694b5a43585b094db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C9sy24sqwLa4jQsn1vwd9g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(茱莉亚logo src = http://julialang.org)</p></figure><blockquote class="ky"><p id="b460" class="kz la it bd lb lc ld le lf lg lh li dk translated"><a class="ae lj" href="https://github.com/emmettgb/Emmetts-DS-NoteBooks/blob/master/Julia/intro%20to%20Julian%20meta.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a></p></blockquote><h1 id="aae0" class="lk ll it bd lm ln lo lp lq lr ls lt lu jz lv ka lw kc lx kd ly kf lz kg ma mb bi translated">介绍</h1><p id="38e0" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk ml mm mn mo mp mq mr ms mt mu mv mw li im bi translated">Julia语言因其许多相对有用的特性而备受推崇。然而，我认为在Julia语言中经常被忽略的一个特性是Julia的元编程能力。元编程是一种编程方式，其中一个程序使用另一个程序作为其数据。当我说程序时，我指的是可以在该语言中运行的任何可执行代码，而不是单独的语言或应用程序。</p><p id="28e4" class="pw-post-body-paragraph mc md it me b mf mx ju mh mi my jx mk ml mz mn mo mp na mr ms mt nb mv mw li im bi translated">元编程非常有用。有些事情你可以用代码作为数据来做，而这些事情在编程语言中是无法做到的。我想从我的文件夹中给大家带来一个很好的例子是Hone.jl. Hone.jl使用元标记，这些元标记只是包含代码的字符串，可以随后连接和修改这些字符串以形成图和绘图。如果不使用这些元标记，有些事情是不可能实现的，那就是扩展Hone的能力。如果你想了解更多关于如何编写Hone扩展的知识，你可以看看这篇文章:</p><div class="nc nd gp gr ne nf"><a rel="noopener follow" target="_blank" href="/how-i-programmed-the-first-hone-extension-in-julia-edf7813d0e1b"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd iu gy z fp nk fr fs nl fu fw is bi translated">我是如何在Julia中编写第一个Hone扩展的</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">在Julia中创建和使用我的绘图库的扩展。</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">towardsdatascience.com</p></div></div><div class="no l"><div class="np l nq nr ns no nt ks nf"/></div></div></a></div><p id="22e6" class="pw-post-body-paragraph mc md it me b mf mx ju mh mi my jx mk ml mz mn mo mp na mr ms mt nb mv mw li im bi translated">幸运的是，Julia中的元编程很容易上手。朱莉娅的元是很容易掌握和学习的东西之一，但要掌握起来要困难得多。使用元编程的一个很大的缺点是，它会使调试变得特别困难，因为您的代码都包含在表达式中，一个小错误，比如省略一个逗号，就会使您的代码无法运行。这是因为在线上读取错误返回比解析错误要容易得多。</p></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><h1 id="9ae1" class="lk ll it bd lm ln ob lp lq lr oc lt lu jz od ka lw kc oe kd ly kf of kg ma mb bi translated">表达式类型</h1><p id="a6d3" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk ml mm mn mo mp mq mr ms mt mu mv mw li im bi translated">为了在Julia中有效地进行元编程，你需要很快习惯的一件事是一种新的类型。让我给你介绍一下:</p><blockquote class="ky"><p id="6393" class="kz la it bd lb lc og oh oi oj ok li dk translated">:Expr</p></blockquote><p id="62d0" class="pw-post-body-paragraph mc md it me b mf ol ju mh mi om jx mk ml on mn mo mp oo mr ms mt op mv mw li im bi translated">表达式类型是一种旨在存储可评估的已解析元代码的类型。为了进行基本的字符串到表达式的转换，您需要熟悉Base.Meta中的parse()方法。</p><pre class="kj kk kl km gt oq or os ot aw ou bi"><span id="1794" class="ov ll it or b gy ow ox l oy oz">using Base.Meta: parse</span></pre><p id="5527" class="pw-post-body-paragraph mc md it me b mf mx ju mh mi my jx mk ml mz mn mo mp na mr ms mt nb mv mw li im bi translated">让我们试着在一个字符串上使用它:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/353bb1948047c210ff37f3ff30932f28.png" data-original-src="https://miro.medium.com/v2/resize:fit:530/format:webp/1*BOilElIeSchf7e98BTFipg.png"/></div></figure><p id="93a9" class="pw-post-body-paragraph mc md it me b mf mx ju mh mi my jx mk ml mz mn mo mp na mr ms mt nb mv mw li im bi translated">请注意，我们的输出现在变成了一个符号。这个符号在某种程度上可以被看作是我之前谈到的应用程序。这是一个运行该符号内部代码的表达式。或者，我们也可以创建一个我们自己的符号来执行这个运算。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/2cb73bc8658b6d7bc8b6a47ef716dbf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:606/format:webp/1*PkIGWc4Bp4Wn4JkJGMOqAQ.png"/></div></figure><p id="cf1f" class="pw-post-body-paragraph mc md it me b mf mx ju mh mi my jx mk ml mz mn mo mp na mr ms mt nb mv mw li im bi translated">正如您所看到的，这两个都是表达式，一个是解析的，另一个是使用内部带有语法的符号创建的。这实际上是存储在符号数据类型中的代码。</p><h2 id="389d" class="ov ll it bd lm pc pd dn lq pe pf dp lu ml pg ph lw mp pi pj ly mt pk pl ma pm bi translated">表达式的属性</h2><p id="985d" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk ml mm mn mo mp mq mr ms mt mu mv mw li im bi translated">Expr类型实际上有一些您可能没有想到的有趣属性。真正酷的是，它们允许我们剖析数据/代码的内容，并对它们有更多的了解。我想给你看的第一个财产是人头。Expr类型包含两种主要的数据类型，头数据和参数数据。head用于界定要传递的是哪种表达式。在这个例子以及大多数例子中，我们使用:call类型。这不是一个实际的数据类型，只是一个存储在Expr结构中的符号。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/db15eae03b5adab11a10c754ed99870a.png" data-original-src="https://miro.medium.com/v2/resize:fit:654/format:webp/1*hRWXg_lz_8wlZPkveuvejA.png"/></div></figure><p id="e387" class="pw-post-body-paragraph mc md it me b mf mx ju mh mi my jx mk ml mz mn mo mp na mr ms mt nb mv mw li im bi translated">接下来我们有参数。Args是我们的数据包含的所有参数。这些争论可以分为两类。他们要么是</p><blockquote class="ky"><p id="254a" class="kz la it bd lb lc og oh oi oj ok li dk translated">操作</p></blockquote><p id="d2fb" class="pw-post-body-paragraph mc md it me b mf ol ju mh mi om jx mk ml on mn mo mp oo mr ms mt op mv mw li im bi translated">其中包括方法和操作数。这些将用符号数据类型来表示。事实上，这些是你的元表达式的元部分。然而，如果没有数据，这些操作是没有用的，所以除了操作之外，我们还有</p><blockquote class="ky"><p id="6617" class="kz la it bd lb lc og oh oi oj ok li dk translated">数据。</p></blockquote><p id="d801" class="pw-post-body-paragraph mc md it me b mf ol ju mh mi om jx mk ml on mn mo mp oo mr ms mt op mv mw li im bi translated">我们可以通过打印所有参数的类型来可视化这一点。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi po"><img src="../Images/c5f6b726e01c8f502c04d21e3ba8384e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/1*a6ON1u0pMuk497jnjLuWmg.png"/></div></figure><p id="ba04" class="pw-post-body-paragraph mc md it me b mf mx ju mh mi my jx mk ml mz mn mo mp na mr ms mt nb mv mw li im bi translated">这基本上就是解析器为我们做的事情。解析器将需要执行的功能和数据相互分离。之后，它会把所有东西按正确的顺序排列，这样它就可以被正确地评估。另一件应该提到的事情是从字符串类型到表达式类型的转换。</p><h1 id="6284" class="lk ll it bd lm ln lo lp lq lr ls lt lu jz pp ka lw kc pq kd ly kf pr kg ma mb bi translated">解析和评估</h1><p id="3d38" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk ml mm mn mo mp mq mr ms mt mu mv mw li im bi translated">既然我们理解了parse()的作用，以及它如何将字符串转换成表达式类型，我们现在可以开始创建一些表达式，然后用eval()对其求值:</p><pre class="kj kk kl km gt oq or os ot aw ou bi"><span id="c003" class="ov ll it or b gy ow ox l oy oz">data_code = "mean([5,10,15,20])"<br/>expression = parse(data_code)<br/>mu = eval(expression)</span></pre><p id="a87d" class="pw-post-body-paragraph mc md it me b mf mx ju mh mi my jx mk ml mz mn mo mp na mr ms mt nb mv mw li im bi translated">这是相对基本的，但也有一些事情你应该注意。首先，如果你所有的数据都在一个字符串中，你如何使用字符串数据类型？不幸的是，在Julia中没有办法像在Python中那样在字符串内部分隔字符串，所以我们需要使用正则表达式。仔细想想，正则表达式本身也是元程序；所以我们真的是在兜圈子。在Julia中获取字符串而无需创建字符串的最简单方法是使用一个符号:</p><pre class="kj kk kl km gt oq or os ot aw ou bi"><span id="cd39" class="ov ll it or b gy ow ox l oy oz">symb = :hello_world<br/>a_string = string("\"",string(symb),"\"")</span></pre><p id="495a" class="pw-post-body-paragraph mc md it me b mf mx ju mh mi my jx mk ml mz mn mo mp na mr ms mt nb mv mw li im bi translated">正则表达式\ "用于在字符串中分隔引号。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ps"><img src="../Images/2b03befb29e23b48d3fb9f2d9330efb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JGvdAVuESGWfnwjPqpKp9A.png"/></div></div></figure><blockquote class="ky"><p id="8e9c" class="kz la it bd lb lc ld le lf lg lh li dk translated">这真的就是全部了！</p></blockquote></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><p id="a136" class="pw-post-body-paragraph mc md it me b mf mx ju mh mi my jx mk ml mz mn mo mp na mr ms mt nb mv mw li im bi translated">元编程是一个强大的工具，我相信有时会被忽略。我认为茱莉亚的处理方式是最完美的处理方式。虽然它肯定不是这门语言的重点，但是它的实现非常好，使用起来也非常简单。Julia有很强的元编程能力，我已经享受了很长时间了！</p></div></div>    
</body>
</html>