<html>
<head>
<title>Weighted K-Means Clustering example — artificial countries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">加权K均值聚类示例-人造国家</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/weighted-k-means-clustering-example-artificial-countries-f91c541827fe?source=collection_archive---------31-----------------------#2020-03-08">https://towardsdatascience.com/weighted-k-means-clustering-example-artificial-countries-f91c541827fe?source=collection_archive---------31-----------------------#2020-03-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d19e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">应用于世界人口地图的加权K均值聚类示例，看看会发生什么。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/65c383a05f34110be1de27e44f849fdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8CiUN3QCWHjxQCHq.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图一。世界人口密度图。为了可视性，我们对每个像素取对数。</p></figure><h1 id="cb36" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">介绍</h1><p id="1287" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">WKMC算法可以应用的领域之一是人口统计学。想象一下这样一种情况，如果所有的行政区划或历史冲突都消失了，或者种族、民族或部落身份不再重要，你希望看到人们如何分组或愿意分组？那么人们如何着手创建社区呢？</p><p id="a8e9" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">在本帖中，我们将使用WKMC算法来找出人们如何根据他们目前的地理分布来分组。为此，我们将关注两个<em class="mr">参数</em>:</p><ul class=""><li id="6b62" class="ms mt it ls b lt mm lw mn lz mu md mv mh mw ml mx my mz na bi translated">地理坐标，</li><li id="61c9" class="ms mt it ls b lt nb lw nc lz nd md ne mh nf ml mx my mz na bi translated">特定位置的人口密度。</li></ul><p id="f154" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">由于这是一个好奇心驱动的模拟，这是一个具有纯粹假设性质的极大简化。该模拟没有考虑自然资源或地形障碍等会阻碍人们定居的条件。然而南极洲是唯一的例外。我们将它排除在外，因为它是地图的一大部分，对于算法来说太大而无法忽略，但几乎完全可以居住。</p><h1 id="6801" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">数据集</h1><p id="b77d" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我们将使用美国宇航局的<a class="ae ng" href="https://neo.sci.gsfc.nasa.gov/view.php?datasetId=SEDAC_POP" rel="noopener ugc nofollow" target="_blank">人口密度数据集。该网站提供了四个版本的数据集，有不同的分辨率，非常适合实验。</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/65c383a05f34110be1de27e44f849fdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8CiUN3QCWHjxQCHq.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图一。世界人口密度图。为了可视性，我们对每个像素取对数。</p></figure><p id="7a32" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">该数据集有四种不同的分辨率版本。当然，最高分辨率的分辨率会给出最好的结果，尽管必要的计算可能会成为一个问题。要获取数据集，请执行:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="e22b" class="nm kz it ni b gy nn no l np nq">mkdir dataset<br/>wget -O dataset/world.csv "https://neo.sci.gsfc.nasa.giv/servlet/RenderData?si=875430&amp;cs=rgb&amp;format=CSV&amp;width=360&amp;height=180"</span></pre><p id="67ae" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">然后:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="8188" class="nm kz it ni b gy nn no l np nq">import pandas as pd<br/><br/>df = pd.read_csv('./dataset/world.csv', header=-1)<br/>df = df.replace(df.max().max(), 0)<br/>df = df.loc[10:145, :]<br/>df = df.reset_index()<br/>df = df.drop(columns=['index'])<br/>df.columns = range(df.shape[1])</span></pre><p id="e084" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">对于这个数据集，地理<em class="mr">经度</em>和<em class="mr">纬度</em>被简单地表示为整数，并被视为一个矩阵的<em class="mr"> (x，y) </em>索引，地图具有<a class="ae ng" href="https://en.wikipedia.org/wiki/List_of_map_projections#Cylindrical" rel="noopener ugc nofollow" target="_blank">圆柱</a>表示。同时，这个矩阵的每一个元素都代表了居住在特定区域的人口密度。</p><p id="d011" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">海洋被标记为<code class="fe nr ns nt ni b">99999.0</code>，这是不自然的，因此我们将其置零。稍后，我们移除北冰洋(只是为了稍微加快计算速度)和南极洲的“狭长地带”，正如前面示意的那样。然后，我们重新枚举行和列的索引，使它们从零开始计数。</p><h1 id="f5f0" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">特征工程</h1><p id="e132" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">在我们继续之前，我们需要对我们的数据集进行一点转换，以适应聚类问题。首先，我们需要将数据集的表示从一个<em class="mr">人口密度矩阵</em>改为一个<em class="mr">经度和纬度坐标点</em>的列表，以便WKMC能够计算<em class="mr">距离</em>。但是，我们还需要保留人口密度值，我们和机器都可以将其解释为每个数据点的<em class="mr">权重</em>。换句话说，与农村地区或沙漠相比，大城市等大型居住区更倾向于将最近的点拉入聚类。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="997e" class="nm kz it ni b gy nn no l np nq">latitude_idx = df.index.to_numpy()<br/>longitude_idx = df.columns.to_numpy()<br/><br/>lat_max = len(latitude_idx)<br/>lon_max = len(longitude_idx)<br/><br/>x0 = latitude_idx.repeat(lon_max)<br/>x1 = np.tile(longitude_idx, lat_max)<br/>x  = df.to_numpy()<br/><br/>dd = pd.DataFrame({<br/>    'x0':     x0,<br/>    'x1':     x1,<br/>    'weight': x.flatten()<br/>})</span></pre><p id="88af" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">首先，我们从dataframe对象中提取<em class="mr">纬度</em>和<em class="mr">经度</em>。然后，我们重复纬度和纬度值，以便它们形成沿着某个新索引排序的唯一对。我们还转储所有的<em class="mr">权重</em>并将它们展平为一个系列，我们将其加入到一个新的数据帧中，这样我们就可以保留引用。</p><h1 id="cab5" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">世界是圆的…</h1><p id="2538" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我们知道现在人们倾向于把所有事情都放在一起讨论，但是不……地球还在转。这里我们有一个圆柱表示的地图，这个地图有一个重要的结果:<strong class="ls iu">地图的左右两边连在一起</strong>。因此，确保我们的算法不会将靠近两条边的两个点视为非常分离是至关重要的。</p><p id="a8ed" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">因为skearn <a class="ae ng" href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html#sklearn.cluster.KMeans.fit" rel="noopener ugc nofollow" target="_blank"> API </a>不允许我们轻易覆盖距离度量，所以我们必须对数据集进行不同的参数化:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="e86a" class="nm kz it ni b gy nn no l np nq">dd['latitude']      = (x0 / x0.max() - 0.5) * 2.0<br/>dd['longitude_sin'] = np.sin((x1 / x1.max()) * np.pi * 2.0)<br/>dd['longitude_cos'] = np.cos((x1 / x1.max()) * np.pi * 2.0)</span></pre><p id="4ce5" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">经度是<em class="mr">循环</em>的维度，如果我们把它换算成一个区间<code class="fe nr ns nt ni b">[0:2.0*np.pi]</code>，它就会变成纵向角度。问题是1和360度之差是360度，而<em class="mr">距离</em>应该等于1度。所以我们可以把这个维度分解成两个特征，分别用正弦和余弦。</p><p id="1147" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">这里的纬度不应该是循环的。但是，如果我们查看刚刚定义的与经度相关的特征，我们可以看到沿这些轴出现的最大值是2。因此，为了在缩放纬度时补偿它，我们需要确保沿它的最大距离也是2。</p><p id="2413" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">因为我们的dataframe <code class="fe nr ns nt ni b">dd</code>保存了所有的引用，所以我们可以简单地向其中添加新的特性，就像我们刚刚做的那样。</p><h1 id="368d" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">解决办法</h1><p id="6351" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">现在，我们的特征矩阵<code class="fe nr ns nt ni b">X</code>可以通过参考通过<em class="mr">纬度</em>和<em class="mr">经度</em>的正弦/余弦投影的所有点来构建。同时，我们把人口密度作为<em class="mr">权重</em>。然而，在此之前，我们移除所有权重严格为零的点。由于我们的飞机表面大约70%是水，这可以大大减少所需的计算。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="7338" class="nm kz it ni b gy nn no l np nq">N_CLUSTERS = 195<br/><br/>dd = dd[dd['weight'] != 0.0]<br/><br/>dd = dd.reset_index()<br/>dd = dd.drop(columns=['index'])<br/><br/>X = dd[['latitude', 'longitude_sin', 'longitude_cos']].to_numpy()<br/>weights = dd['weight'].to_numpy()<br/><br/>dd['cluster'] = KMeans(n_clusters=N_CLUSTERS).fit_predict(X,<br/>    sample_weight=weights)</span></pre><p id="f88b" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">195这个数字不是偶然的。目前，我们有<a class="ae ng" href="https://www.worldometers.info/geography/how-many-countries-are-there-in-the-world/" rel="noopener ugc nofollow" target="_blank"> 195 </a>个地区被认定为国家。我们可以用这个数字作为新世界的参考。</p><p id="514d" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">解决了WKMC问题后，我们需要“重组”旧坐标的解决方案，这相当容易，因为我们保留了对原始索引的引用。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="e702" class="nm kz it ni b gy nn no l np nq">XX = -1 * np.ones((lat_max, lon_max))<br/>for i in range(len(dd)):<br/>        u, v = dd['x0'].iloc[0], dd['x1'].ilox[i]<br/>        cluster_id = dd['cluster'].iloc[i]<br/>        XX[u, v] = cluster_id</span></pre><p id="40aa" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">现在，让我们画出结果。我们将用新的“国家”覆盖原始人口密度图。(请注意，<code class="fe nr ns nt ni b">np.where</code>功能仅用于增强绘图。)</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="5c08" class="nm kz it ni b gy nn no l np nq">fig, ax = plt.subplots(1, 1, figsize=(24, 24))<br/>ax.imshow(np.where(XX == -1, np.NaN, XX), <br/>    cmap='Spectral', <br/>    alpha=0.75)<br/>ax.imshow(df.apply(lambda x: np.log(x)), alpha=0.25, cmap='gray')<br/>ax.contour(longitude_idx, latitude_idx, <br/>    np.where(XX == -1, -10, XX), <br/>    levels=N_CLUSTERS, <br/>    linewidths=0.1, <br/>    alpha=0.5, <br/>    colors='k')<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/873e2193e2a68cbdff3fe4f9fa52d404.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9-gC3LMgTtQCLGuP.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">通过K-Means聚类算法定义的195个国家的世界。</p></figure><h1 id="4b3c" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">讨论</h1><p id="fab9" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我们终于聚集了人口。观察WKMC算法假设的结果是有用的。</p><p id="08c4" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">首先，因为我们已经移除了零权重的点，所以没有聚类的标签被分配给这些点。然而，人口密度越大，集群就越集中。这在印度和中国这两个世界上人口最稠密的地区尤为明显。西伯利亚和加拿大北部、格陵兰岛、撒哈拉和澳大利亚形成较大的星团。</p><p id="494b" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">其次，通过缩放特征(记住，所有特征都在<code class="fe nr ns nt ni b">[-1, 1]</code>范围内)，集群在任何方向都不会表现出各向异性。换句话说，如果例如x轴具有5倍的范围，我们将期望它的影响更强，因此集群将被垂直拉长。</p><p id="fc27" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">最后，通过确保东西轴的连续性，我们的集群不会因为边界条件的存在而失真。</p><h1 id="e03b" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">结论</h1><p id="6944" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我们已经看到了K-Means聚类算法是如何在我们的假设世界中投入使用的。然而，刚刚演示的用法实际上非常传统，可以应用于类似的情况，在处理较小的地图时会产生特别好的效果。该算法有助于发现存在的相似性，而不管行政区划如何。</p><h1 id="48e0" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">还会有更多…</h1><p id="f1b4" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我计划把文章带到下一个层次，并提供简短的视频教程。</p><p id="b613" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">如果您想了解关于视频和未来文章的更新，<strong class="ls iu">订阅我的</strong> <a class="ae ng" href="https://landing.mailerlite.com/webforms/landing/j5y2q1" rel="noopener ugc nofollow" target="_blank"> <strong class="ls iu">简讯</strong> </a> <strong class="ls iu">。你也可以通过填写<a class="ae ng" href="https://forms.gle/bNpf9aqZJGLgaU589" rel="noopener ugc nofollow" target="_blank">表格</a>让我知道你的期望。回头见！</strong></p></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><p id="443d" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated"><em class="mr">原载于</em><a class="ae ng" href="https://zerowithdot.com/weighted-k-means-clustering-example/" rel="noopener ugc nofollow" target="_blank"><em class="mr">https://zerowithdot.com</em></a><em class="mr">。</em></p></div></div>    
</body>
</html>