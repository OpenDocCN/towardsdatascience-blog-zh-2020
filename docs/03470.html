<html>
<head>
<title>Find and plot your optimal path using OSM, Plotly and NetworkX in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Python 中的 OSM、Plotly 和 NetworkX 找到并绘制最佳路径</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/find-and-plot-your-optimal-path-using-plotly-and-networkx-in-python-17e75387b873?source=collection_archive---------9-----------------------#2020-04-02">https://towardsdatascience.com/find-and-plot-your-optimal-path-using-plotly-and-networkx-in-python-17e75387b873?source=collection_archive---------9-----------------------#2020-04-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="40b8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用<strong class="ak"> OpenStreetMap、</strong> OSMnx &amp; NetworkX 寻找最佳路径的指南，并使用 Python 中的 Plotly 绘制带有弯曲和曲线的详细路径。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ef67756a52b209c666c81c3018b7eecb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TchvidJGki3mIjxGhygumQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://pixabay.com/users/pexels-2286921/" rel="noopener ugc nofollow" target="_blank">像素</a>，通过<a class="ae ky" href="https://pixabay.com/photos/arrows-barren-direction-road-1834859/" rel="noopener ugc nofollow" target="_blank">像素</a></p></figure><p id="817c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用 Google Maps API 可以使用许多库来绘制路径，但这会导致灵活性降低。同样，如果你用一组线条来画一条路径，在缺乏更好的词语的情况下，它看起来并不好。让我给你举个例子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/c2c4a87b565ac1b1ddd422fea64eade4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_iIIF-9I2rHShtcwrRl_XQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用 Plotly 生成</p></figure><p id="5dd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，在许多情况下，您可能需要一些灵活性，不仅可以更改两点之间的所需路径(例如，您需要满足您的标准的路径，而不是 google maps 给出的最短或最快路径)，还可以更改您想要的绘图方式。</p><p id="9d51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇博客中，我试图解决这样一个问题，我们不仅可以找到最佳路径，还可以使用 Plotly 绘制它们。我们先从导入一些库开始。</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="4350" class="mb mc it lx b gy md me l mf mg">import osmnx as ox<br/>import networkx as nx<br/>import plotly.graph_objects as go<br/>import numpy as np</span></pre><p id="e0d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">OSMnx 库有助于从 OpenStreetMap 检索、分析和可视化街道网络。你可以在这里阅读更多关于 OSMnx <a class="ae ky" href="https://github.com/gboeing/osmnx" rel="noopener ugc nofollow" target="_blank">的内容。为了演示，我将下载美国佐治亚州的州界，并使用 OSMnx 库绘制它。</a></p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="4bb0" class="mb mc it lx b gy md me l mf mg">state = ox.gdf_from_place('Georgia, US') ox.plot_shape(ox.project_gdf(state))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/70f881a3a825b120fcd5f2e36f4cc3e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:582/format:webp/1*QnJrzWrbcqe5n1TFh8Lx0Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用 OSMnx 库生成的佐治亚州地图</p></figure><p id="1c26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们下载一张地图。这一次，我们将通过提供一个参数<code class="fe mi mj mk lx b">network_type = 'drive'</code>来下载佐治亚理工学院周围地区的更详细地图。OSMnx 以图形对象的形式下载地图，可以很容易地被 NetworkX 库使用。</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="f021" class="mb mc it lx b gy md me l mf mg"># Defining the map boundaries <br/>north, east, south, west = 33.798, -84.378, 33.763, -84.422  <br/># Downloading the map as a graph object <br/>G = ox.graph_from_bbox(north, south, east, west, network_type = 'drive')  <br/># Plotting the map graph <br/>ox.plot_graph(G)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/94b1650a3fa067f690ed29ea2cf56ccd.png" data-original-src="https://miro.medium.com/v2/resize:fit:710/format:webp/1*-8_rRd35BHV3k-tdrmzZ3w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">显示使用 OSMnx 库生成的边(道路)和节点的道路网络图</p></figure><p id="6cb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上图中，我们可以看到所有的节点(蓝色)和边(灰色)以精确的形状表示道路。让我们深入研究一下我们下载的图形对象，看看边和节点是什么样子的:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="74ec" class="mb mc it lx b gy md me l mf mg"># Displaying the 3rd node <br/>list(G.nodes(data=True))[2]</span></pre><p id="3e4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(69128194，<br/> {'y': 33.7692046，<br/> 'x': -84.390567，<br/> 'osmid': 69128194，<br/> 'ref': '249C '，<br/>' highway ':' automobile _ junction ' })</p><p id="a590" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的输出显示了节点 id <code class="fe mi mj mk lx b">69128194</code>的信息及其 x 和 y 坐标、OSM id 和节点类型(交汇点)。同样，我们可以看到边缘的细节:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="3cf7" class="mb mc it lx b gy md me l mf mg"># Displaying the 1st edge<br/>list(G.edges(data=True))[1]</span></pre><p id="4858" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(69259268，<br/> 69508853，<br/> {'osmid': 9270483，<br/>'名称':'林赛街西北'，<br/>'公路':'住宅'，<br/>'单向':False，<br/>'长度':145.352，<br/>'几何':))</p><p id="b693" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这显示了连接节点<code class="fe mi mj mk lx b">69259264</code>到<code class="fe mi mj mk lx b">69290452</code>的边的细节，以及它的 OSM id、名称、类型、单向/双向、长度和一个有趣的 geometry.linestring 类型的元素。我们可以看到这个几何图形是什么样子。</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="3f56" class="mb mc it lx b gy md me l mf mg"># Displaying the shape of edge using the geometry list(G.edges(data=True))[1][2]['geometry']</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/c976f99a059221af1ce74f3168f08d89.png" data-original-src="https://miro.medium.com/v2/resize:fit:420/format:webp/1*PkLSqg8v2s9ZRpABfRH4sA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">边缘的几何形状</p></figure><p id="64e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这说明边缘不是直线而是曲线路径。我们将在以后绘制这种类型的曲线边时使用这些信息。</p><p id="867c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们将找到最佳路径。现在，让我们把目标定为找到最小长度的路径。这可以改变以满足任何标准，并将在一个单独的博客中讨论。在决定了起点和终点之后，首先，我们需要得到离这些位置最近的节点。这可以使用 OSMnx 的函数<code class="fe mi mj mk lx b">get_nearest_node</code>来完成。</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="fbeb" class="mb mc it lx b gy md me l mf mg"># define origin and desination locations <br/>origin_point = (33.787201, -84.405076) <br/>destination_point = (33.764135, -84.394980)</span><span id="9a36" class="mb mc it lx b gy mn me l mf mg"># get the nearest nodes to the locations <br/>origin_node = ox.get_nearest_node(G, origin_point) <br/>destination_node = ox.get_nearest_node(G, destination_point)</span><span id="9d53" class="mb mc it lx b gy mn me l mf mg"># printing the closest node id to origin and destination points origin_node, destination_node</span></pre><p id="c447" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi">(69425048, 2919090915)</p><p id="1d65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以使用<code class="fe mi mj mk lx b">NetworkX</code>库中的<code class="fe mi mj mk lx b">shortest_path</code>函数，通过 Dijkstra 算法得到总长度最小的最优路径。注意，我们已经提供了<code class="fe mi mj mk lx b">weight='length'</code>。这个函数返回路径中有序节点的列表。</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="2eac" class="mb mc it lx b gy md me l mf mg"># Finding the optimal path <br/>route = nx.shortest_path(G, origin_node, destination_node, weight = 'length') route</span></pre><p id="495a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[69425048，<br/> 69425021，<br/> 69466983，<br/> 69466977，<br/>。<br/>。</p><p id="0948" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们在地图上标出这些节点。为此，我们将使用 Plotly 库。我们将绘制所有这些节点，并用线将它们连接起来以表示一条路径。让我们看看它看起来怎么样。但是首先，让我们得到这些节点的坐标</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="27c5" class="mb mc it lx b gy md me l mf mg"># getting coordinates of the nodes</span><span id="9272" class="mb mc it lx b gy mn me l mf mg"># we will store the longitudes and latitudes in following list <br/>long = [] <br/>lat = []  <br/>for i in route:<br/>     point = G.nodes[i]<br/>     long.append(point['x'])<br/>     lat.append(point['y'])</span></pre><p id="3338" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将在地图上多次绘制路径，因此让我们为此定义一个函数:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="2985" class="mb mc it lx b gy md me l mf mg">def plot_path(lat, long, origin_point, destination_point):<br/>    <br/>    """<br/>    Given a list of latitudes and longitudes, origin <br/>    and destination point, plots a path on a map<br/>    <br/>    Parameters<br/>    ----------<br/>    lat, long: list of latitudes and longitudes<br/>    origin_point, destination_point: co-ordinates of origin<br/>    and destination</span><span id="efdd" class="mb mc it lx b gy mn me l mf mg">    Returns<br/>    -------<br/>    Nothing. Only shows the map.<br/>    """</span><span id="9939" class="mb mc it lx b gy mn me l mf mg">    # adding the lines joining the nodes<br/>    fig = go.Figure(go.Scattermapbox(<br/>        name = "Path",<br/>        mode = "lines",<br/>        lon = long,<br/>        lat = lat,<br/>        marker = {'size': 10},<br/>        line = dict(width = 4.5, color = 'blue')))</span><span id="3b6a" class="mb mc it lx b gy mn me l mf mg">    # adding source marker<br/>    fig.add_trace(go.Scattermapbox(<br/>        name = "Source",<br/>        mode = "markers",<br/>        lon = [origin_point[1]],<br/>        lat = [origin_point[0]],<br/>        marker = {'size': 12, 'color':"red"}))<br/>     <br/>    # adding destination marker<br/>    fig.add_trace(go.Scattermapbox(<br/>        name = "Destination",<br/>        mode = "markers",<br/>        lon = [destination_point[1]],<br/>        lat = [destination_point[0]],<br/>        marker = {'size': 12, 'color':'green'}))<br/>    <br/>    # getting center for plots:<br/>    lat_center = np.mean(lat)<br/>    long_center = np.mean(long)</span><span id="8808" class="mb mc it lx b gy mn me l mf mg">    # defining the layout using mapbox_style<br/>    fig.update_layout(mapbox_style="stamen-terrain",<br/>        mapbox_center_lat = 30, mapbox_center_lon=-80)<br/>    fig.update_layout(margin={"r":0,"t":0,"l":0,"b":0},<br/>                      mapbox = {<br/>                          'center': {'lat': lat_center, <br/>                          'lon': long_center},<br/>                          'zoom': 13})<br/>    fig.show()</span></pre><p id="fca9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们调用函数并在地图上绘制路径:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="468a" class="mb mc it lx b gy md me l mf mg">plot_path(lat, long, origin_point, destination_point)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mo"><img src="../Images/c07fa8371ae62a867674040b2dc05819.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tuKVX75fbDVAm6DAADXpiQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用连接节点的直线显示最短路径的地图。橙色方框显示绘制的线与实际道路的偏差。使用 Plotly 库生成。</p></figure><p id="aebc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这看起来不错。我们绘制了一条从源节点到目的节点的路径，这些节点非常接近我们作为源节点和目的节点提供的实际坐标(分别用红色和绿色标记表示)。但是少了点什么。是的，道路上的曲线被连接路径中两个节点的直线所取代。这可以在橙色方框中观察到。如果你记得上面边的几何元素，我们将使用它来解决这个问题。</p><p id="48f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了说明，我们将看到这部分路径的边缘形状。该路径位于从终点输入输出路由变量开始的第 6 个和第 7 个节点之间。让我们得到连接这两个节点的边，我们将看到它的形状。</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="d779" class="mb mc it lx b gy md me l mf mg"># Getting the start and end node of this part <br/>start_node=route[-7] <br/>end_node=route[-6]</span><span id="ff81" class="mb mc it lx b gy mn me l mf mg"># Getting the edge connecting these nodes and storing it as a list in z to maintain the data structure of G.edges <br/>z = []  <br/>for i in list(G.edges(data=True)):<br/>     if (i[0]==start_node) &amp; (i[1]==end_node):<br/>         z.append(i)<br/> <br/>z[0][2]['geometry']</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/04fd56dd6fc831ae0175d8b4d11db936.png" data-original-src="https://miro.medium.com/v2/resize:fit:420/format:webp/1*2kW6qXG1geOUZfj9xppkpw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">上图中橙色框中标记的一条道路的几何图形</p></figure><p id="e641" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这看起来和第二个橙色盒子里的街道一模一样。所以现在我们有一种方法来绘制这些曲线形状。我们只需要得到这些形状，并用我们的原始路线数据替换它们。为此，我们将定义一个函数来实现这一点。它在所有边上循环，如果该边有曲线形状，它就存储该曲线。</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="c441" class="mb mc it lx b gy md me l mf mg">def node_list_to_path(G, node_list):<br/>    """<br/>    Given a list of nodes, return a list of lines that together<br/>    follow the path<br/>    defined by the list of nodes.<br/>    Parameters<br/>    ----------<br/>    G : networkx multidigraph<br/>    route : list<br/>        the route as a list of nodes<br/>    Returns<br/>    -------<br/>    lines : list of lines given as pairs ( (x_start, y_start), <br/>    (x_stop, y_stop) )<br/>    """<br/>    edge_nodes = list(zip(node_list[:-1], node_list[1:]))<br/>    lines = []<br/>    for u, v in edge_nodes:<br/>        # if there are parallel edges, select the shortest in length<br/>        data = min(G.get_edge_data(u, v).values(), <br/>                   key=lambda x: x['length'])</span><span id="5ecb" class="mb mc it lx b gy mn me l mf mg">        # if it has a geometry attribute<br/>        if 'geometry' in data:<br/>            # add them to the list of lines to plot<br/>            xs, ys = data['geometry'].xy<br/>            lines.append(list(zip(xs, ys)))<br/>        else:<br/>            # if it doesn't have a geometry attribute,<br/>            # then the edge is a straight line from node to node<br/>            x1 = G.nodes[u]['x']<br/>            y1 = G.nodes[u]['y']<br/>            x2 = G.nodes[v]['x']<br/>            y2 = G.nodes[v]['y']<br/>            line = [(x1, y1), (x2, y2)]<br/>            lines.append(line)</span><span id="e197" class="mb mc it lx b gy mn me l mf mg">return lines</span><span id="ec51" class="mb mc it lx b gy mn me l mf mg"># getting the list of coordinates from the path <br/># (which is a list of nodes)</span><span id="9191" class="mb mc it lx b gy mn me l mf mg">lines = node_list_to_path(G, route)</span><span id="5bac" class="mb mc it lx b gy mn me l mf mg">long2 = []<br/>lat2 = []</span><span id="33a5" class="mb mc it lx b gy mn me l mf mg">for i in range(len(lines)):<br/>    z = list(lines[i])<br/>    l1 = list(list(zip(*z))[0])<br/>    l2 = list(list(zip(*z))[1])<br/>    for j in range(len(l1)):<br/>        long2.append(l1[j])<br/>        lat2.append(l2[j])</span></pre><p id="f996" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们比较 lat 和 lat2 的长度，我们会注意到 lat2 的坐标是 lat 的 6 倍以上。</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="ca8b" class="mb mc it lx b gy md me l mf mg">print("Length of lat: ", len(lat))<br/>print("Length of lat2: ", len(lat2))</span></pre><p id="9dda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">lat: 23 长度<br/>lat 2 长度:141</p><p id="7145" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在要做的最后一件事是绘制路径，看看它看起来如何。</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="df07" class="mb mc it lx b gy md me l mf mg">plot_path(lat2, long2, origin_point, destination_point)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mp"><img src="../Images/2e3433526060f959c8642cb3d6ae84f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vbKbrDK8a-0cr6_Ux-ZL2w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用 Plotly 库生成的最终路径</p></figure><p id="2a88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个看起来好多了。在这篇博客中，我们使用了像<code class="fe mi mj mk lx b">OSMnx</code>和<code class="fe mi mj mk lx b">Plotly</code>这样的库来创建我们的方向图。我们使用<code class="fe mi mj mk lx b">NetworkX</code>来获得基于我们目标的最优路径。这里我们使用了最常见的目标——长度，但这可以很容易地替换。</p><p id="f121" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的网站上找到原帖【apurv.page/plotthepath.html T4】</p></div></div>    
</body>
</html>