<html>
<head>
<title>Deploy RShiny with the Rocker/Shiny Docker Image</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用摇杆/闪亮的 Docker 图像部署 RShiny</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/deploy-rshiny-with-the-rocker-shiny-docker-image-1d940437e6e0?source=collection_archive---------60-----------------------#2020-04-13">https://towardsdatascience.com/deploy-rshiny-with-the-rocker-shiny-docker-image-1d940437e6e0?source=collection_archive---------60-----------------------#2020-04-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6190012f2caacc7f7227e55d40c92336.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ukVcws67qn7noUy7.jpg"/></div></div></figure><p id="d8b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你用 docker 部署 RShiny，你可以<a class="ae kw" href="https://www.dabbleofdevops.com/blog/deploy-your-rshiny-app-locally-with-docker" rel="noopener ugc nofollow" target="_blank">滚动你自己的镜像</a>，或者你可以使用<a class="ae kw" href="https://hub.docker.com/r/rocker/shiny" rel="noopener ugc nofollow" target="_blank">摇杆 Dockerhub 镜像</a>。</p><p id="cf34" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您选择哪种解决方案将取决于您自己的需求。通常，我使用大量的生物信息学和/或数据科学软件包，在我看来，没有什么能真正击败康达生态系统。另一方面，拥有一个已经安装了 RShiny 的映像真的很棒！我也很喜欢<code class="fe kx ky kz la b">rocker/shiny</code>图像的配置方式。你把你的文件放到一个目录中，只要你有你需要的包，你闪亮的应用程序就会直接启动！</p><h1 id="f577" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用摇杆/闪亮图像部署简单的闪亮应用程序</h1><p id="8865" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">这是我们通常使用的闪亮应用程序，大部分是从闪亮文档中偷来的。；-)</p><pre class="me mf mg mh gt mi la mj mk aw ml bi"><span id="a09b" class="mm lc iq la b gy mn mo l mp mq">#!/usr/bin/env Rscript<br/><br/># This example comes from the r-shiny examples github repo.<br/># https://github.com/rstudio/shiny-examples/blob/master/001-hello/app.R<br/><br/>library(shiny)<br/><br/># Define UI for app that draws a histogram ----<br/>ui &lt;- fluidPage(<br/><br/>  # App title ----<br/>  titlePanel("Hello Shiny!"),<br/><br/>  # Sidebar layout with input and output definitions ----<br/>  sidebarLayout(<br/><br/>    # Sidebar panel for inputs ----<br/>    sidebarPanel(<br/><br/>      # Input: Slider for the number of bins ----<br/>      sliderInput(inputId = "bins",<br/>                  label = "Number of bins:",<br/>                  min = 1,<br/>                  max = 50,<br/>                  value = 30)<br/><br/>    ),<br/><br/>    # Main panel for displaying outputs ----<br/>    mainPanel(<br/><br/>      # Output: Histogram ----<br/>      plotOutput(outputId = "distPlot")<br/><br/>    )<br/>  )<br/>)<br/><br/><br/># Define server logic required to draw a histogram ----<br/>server &lt;- function(input, output) {<br/><br/>  # Histogram of the Old Faithful Geyser Data ----<br/>  # with requested number of bins<br/>  # This expression that generates a histogram is wrapped in a call<br/>  # to renderPlot to indicate that:<br/>  #<br/>  # 1. It is "reactive" and therefore should be automatically<br/>  #    re-executed when inputs (input$bins) change<br/>  # 2. Its output type is a plot<br/>  output$distPlot &lt;- renderPlot({<br/><br/>    x    &lt;- faithful$waiting<br/>    bins &lt;- seq(min(x), max(x), length.out = input$bins + 1)<br/><br/>    hist(x, breaks = bins, col = "#75AADB", border = "white",<br/>         xlab = "Waiting time to next eruption (in mins)",<br/>         main = "Histogram of waiting times")<br/><br/>    })<br/><br/>}<br/><br/># If you want to automatically reload the app when your codebase changes - should be turned off in production<br/>options(shiny.autoreload = TRUE)<br/><br/>options(shiny.host = '0.0.0.0')<br/>options(shiny.port = 8080)<br/><br/># Create Shiny app ---- <br/>shinyApp(ui = ui, server = server)</span></pre><p id="e4e5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">制作一个名为<code class="fe kx ky kz la b">shiny-app</code>的目录，将上面的<code class="fe kx ky kz la b">app.R</code>放进去。</p><h1 id="fb53" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">提供您的 RShiny 应用程序</h1><p id="55b9" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">现在你有了一个应用程序，你需要知道两个基本的 docker 概念。如何公开端口以及如何挂载卷。</p><pre class="me mf mg mh gt mi la mj mk aw ml bi"><span id="4f23" class="mm lc iq la b gy mn mo l mp mq">docker run --rm \ <br/>-v "$(pwd)/shiny-app":/srv/shiny-server \ <br/>-p 3838:3838</span></pre><p id="9a8a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您应该会看到一条关于您的 RShiny 应用程序正在运行的消息。在<code class="fe kx ky kz la b">localhost:3838</code>打开浏览器，您应该会看到以下应用程序。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mr"><img src="../Images/e62ae151bec94e928a2b3077cf9b2588.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mpwvkFLcUvfUNWDn.png"/></div></div></figure><p id="03ed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，这是摇滚形象非常简洁的地方。由于我们将应用程序直接放入<code class="fe kx ky kz la b">/srv/shiny-server</code>中，它会立即启动。要知道为什么会这样，让我们看看 docker 文件中的魔法。</p><h1 id="149b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">深入摇滚/闪亮的形象</h1><pre class="me mf mg mh gt mi la mj mk aw ml bi"><span id="19c3" class="mm lc iq la b gy mn mo l mp mq">FROM rocker/r-ver:3.6.3<br/><br/>RUN apt-get update &amp;&amp; apt-get install -y \<br/>    sudo \<br/>    gdebi-core \<br/>    pandoc \<br/>    pandoc-citeproc \<br/>    libcurl4-gnutls-dev \<br/>    libcairo2-dev \<br/>    libxt-dev \<br/>    xtail \<br/>    wget<br/><br/><br/># Download and install shiny server<br/>RUN wget --no-verbose https://download3.rstudio.org/ubuntu-14.04/x86_64/VERSION -O "version.txt" &amp;&amp; \<br/>    VERSION=$(cat version.txt)  &amp;&amp; \<br/>    wget --no-verbose "https://download3.rstudio.org/ubuntu-14.04/x86_64/shiny-server-$VERSION-amd64.deb" -O ss-latest.deb &amp;&amp; \<br/>    gdebi -n ss-latest.deb &amp;&amp; \<br/>    rm -f version.txt ss-latest.deb &amp;&amp; \<br/>    . /etc/environment &amp;&amp; \<br/>    R -e "install.packages(c('shiny', 'rmarkdown'), repos='$MRAN')" &amp;&amp; \<br/>    cp -R /usr/local/lib/R/site-library/shiny/examples/* /srv/shiny-server/ &amp;&amp; \<br/>    chown shiny:shiny /var/lib/shiny-server<br/><br/>EXPOSE 3838<br/><br/>COPY shiny-server.sh /usr/bin/shiny-server.sh<br/><br/>CMD ["/usr/bin/shiny-server.sh"]</span></pre><p id="f200" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们在这里可以看到,<code class="fe kx ky kz la b">rocker/shiny</code>映像使用了一个 base R Docker 映像，然后安装了闪亮的包。它还将一个<code class="fe kx ky kz la b">shiny-server.sh</code>文件从构建目录复制到映像。<code class="fe kx ky kz la b">shiny-server.sh</code>正被用作启动<code class="fe kx ky kz la b">CMD</code>。(记住，<code class="fe kx ky kz la b">RUN</code>在构建期间执行命令，而<code class="fe kx ky kz la b">CMD</code>在使用<code class="fe kx ky kz la b">docker run</code>运行容器时执行命令。让我们研究一下<code class="fe kx ky kz la b">shiny-server.sh</code>启动文件。</p><pre class="me mf mg mh gt mi la mj mk aw ml bi"><span id="449a" class="mm lc iq la b gy mn mo l mp mq">#!/bin/sh<br/><br/># Make sure the directory for individual app logs exists<br/>mkdir -p /var/log/shiny-server<br/>chown shiny.shiny /var/log/shiny-server<br/><br/>if [ "$APPLICATION_LOGS_TO_STDOUT" != "false" ];<br/>then<br/>    # push the "real" application logs to stdout with xtail in detached mode<br/>    exec xtail /var/log/shiny-server/ &amp;<br/>fi<br/><br/># start shiny server<br/>exec shiny-server 2&gt;&amp;1</span></pre><p id="8405" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们在这里看到的是，<code class="fe kx ky kz la b">shiny-server.sh</code>脚本正在执行一个命令，该命令带有一个选项，可以选择是否将日志推送到 stdout。这是你在 docker 容器中经常看到的东西。在构建时，您通常希望看到所有的日志信息，但对于生产系统，您通常希望将日志推送到文件或日志基础设施，如 logstash 或 elasticsearch。</p><h1 id="18d2" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">闪亮服务器在做什么？</h1><p id="eab3" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">我总是喜欢深入容器本身，看看发生了什么，尤其是在启动命令和 web 服务器方面。</p><p id="d10d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要在 docker 容器中挖掘，提供<code class="fe kx ky kz la b">it</code>标志(interactive 和 tty)并运行 bash 命令。这会让你直接变成一个空壳。</p><p id="fedb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">退出先前的 docker 运行命令或不提供端口。否则，此命令将失败，并显示一个关于端口已被监听的错误。</p><pre class="me mf mg mh gt mi la mj mk aw ml bi"><span id="deed" class="mm lc iq la b gy mn mo l mp mq">docker run -it --rm \<br/>-p 3838:3838 \<br/>-v "$(pwd)/shiny-app":/srv/shiny-server \<br/>rocker/shiny bash</span></pre><p id="8a53" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，如果我运行<code class="fe kx ky kz la b">shiny-server --help</code>，它会启动一个节点服务器，并告诉你它正在查看哪个配置文件。作为一个永远好奇的人，我想知道更多，所以我去看了一下<a class="ae kw" href="https://github.com/rstudio/shiny-server" rel="noopener ugc nofollow" target="_blank"> Github 回购</a>。据我所知，请不要因为我不太懂 javascript 而坚持这样做，但它所做的是读取您的配置文件，并在<code class="fe kx ky kz la b">/srv/shinyapps</code>中为每个文件夹创建一个单独的 web 服务器，以及与您的文件夹名称对应的漂亮路径，这就是您如何获得漂亮的拖放和快速的闪亮效果！</p><h1 id="eea1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">创建一个定制的摇滚/闪亮的形象</h1><p id="d6d2" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">现在，如果您想安装任何额外的系统软件包，您将需要创建一个新的映像。</p><p id="97a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我也喜欢将我的应用程序放在 docker 映像中，而不是出于生产目的将其安装在文件系统上，所以我们在这里也将这样做。</p><p id="ce66" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您的目录结构应该如下所示:</p><pre class="me mf mg mh gt mi la mj mk aw ml bi"><span id="e1b4" class="mm lc iq la b gy mn mo l mp mq">Dockerfile<br/>shiny-app/<br/>    app-R</span></pre><p id="acaa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里有一个样本 Dockerfile 文件。</p><pre class="me mf mg mh gt mi la mj mk aw ml bi"><span id="d6b3" class="mm lc iq la b gy mn mo l mp mq"># Dockerfile<br/>FROM rocker/shiny:3.6.3<br/><br/>RUN apt-get update &amp;&amp; apt-get install -y \<br/>    things-i-want-to-install<br/>    <br/>COPY shiny-app/app.R /srv/shiny-app/app.R</span></pre><p id="4dc5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦你有了你的<code class="fe kx ky kz la b">Dockerfile</code>设置，你只需要建立你的形象。</p><pre class="me mf mg mh gt mi la mj mk aw ml bi"><span id="0220" class="mm lc iq la b gy mn mo l mp mq">docker build -t my-rshiny-app .</span></pre><p id="d02b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">除了，你知道，有一个更好的名字和更具描述性的名字，绝对没有东西或东西在那里。</p><h1 id="d1f8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">包裹</h1><p id="6c0d" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">就是这样！你的 docker 图像将从 rocker/shiny 图像继承启动命令，所以需要在这里指定它。只需添加您的附加包，复制您的文件，并繁荣！</p></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><p id="1ab3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mz">最初发表于</em><a class="ae kw" href="https://www.dabbleofdevops.com/blog/deploy-rshiny-with-the-rocker-shiny-docker-image" rel="noopener ugc nofollow" target="_blank"><em class="mz">https://www.dabbleofdevops.com</em></a><em class="mz">。</em></p></div></div>    
</body>
</html>