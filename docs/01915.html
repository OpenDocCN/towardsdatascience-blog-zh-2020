<html>
<head>
<title>Supercharging MS SQL Server with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python为MS SQL Server增压</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/supercharging-ms-sql-server-with-python-e3335d11fa17?source=collection_archive---------3-----------------------#2020-02-23">https://towardsdatascience.com/supercharging-ms-sql-server-with-python-e3335d11fa17?source=collection_archive---------3-----------------------#2020-02-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6443" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何使用Python来自动化SQL的一切</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3359a9aa4b81e042905f0ba4e0615566.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cYMN-i16f0RzCQ4w"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@cadop?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马修·施瓦茨</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="65cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在工作中，我大量使用SQL<strong class="lb iu"/>。它并不是没有令人讨厌的细微差别和限制，但归根结底，它是所有数据职业的基础。因此，对于任何在数据领域工作的人来说，这是绝对必要的。精通SQL非常重要。</p><p id="fb3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然SQL很棒，但为什么要满足于棒呢？为什么我们不<strong class="lb iu">给SQL </strong>增压？</p><p id="8de7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SQL的局限性源于它是一种声明性语言，这意味着我们告诉SQL我们想要什么，然后SQL将从指定的数据库中获取这些信息。对于许多数据提取或简单的数据操作任务，这是所有需要的。</p><p id="20f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果我们想要更多呢？</p><p id="763c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这正是我将在本文中向您展示的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/f2fefb33e7e03f4c0b0e259213f6cdaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*blO2ag7Mg7Gyiqfh"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Axel Antas-Bergkvist 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="99f2" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">它始于一个基础</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">点击<a class="ae ky" href="https://gist.github.com/jamescalam/1a13bee1d81439ca4b2511d7e9370f53" rel="noopener ugc nofollow" target="_blank">此处</a>查看完整脚本</p></figure><p id="42b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段代码是增强MS SQL server的基础。一旦构建完成，我们就可以从Python连接到SQL，只需:</p><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="f075" class="mv lx it mr b gy mw mx l my mz">sql = Sql('database123')</span></pre><p id="200d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单对吗？有几件事情正在进行，所以让我们剖析代码。</p><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="8060" class="mv lx it mr b gy mw mx l my mz">class Sql:</span></pre><p id="319c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先要注意的是，我们将它包含在一个类中。我发现这种方法是合理的，因为在这种格式中，我们可以为这个特定的数据库添加或删除进程。一旦看到这是如何工作的，这就更有意义了。</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><p id="3050" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们初始化我们的类:</p><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="74d0" class="mv lx it mr b gy mw mx l my mz">def __init__(self, database, server="XXVIR00012,55000"):</span></pre><p id="3b82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我和我的同事几乎总是连接到同一个服务器。所以我将这个公共服务器名设置为<code class="fe nh ni nj mr b">server</code>的默认参数。</p><blockquote class="nk nl nm"><p id="d1e0" class="kz la nn lb b lc ld ju le lf lg jx lh no lj lk ll np ln lo lp nq lr ls lt lu im bi translated">您的服务器名称可以在“连接到服务器”对话框中找到，也可以在MS SQL Server Management Studio的窗口顶部找到:</p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/5c9ae4bd44b24c8696c4dfe91b7ad471.png" data-original-src="https://miro.medium.com/v2/resize:fit:958/format:webp/1*4fbulsM0nE0FdnCWuzYK4g.png"/></div></figure></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><p id="1cf1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们建立与SQL的连接:</p><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="0cd8" class="mv lx it mr b gy mw mx l my mz">self.cnxn = pyodbc.connect("Driver={SQL Server Native Client 11.0};"<br/>                           "Server="+self.server+";"<br/>                           "Database="+self.database+";"<br/>                           "Trusted_Connection=yes;")</span></pre><p id="47ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">多亏了<a class="ae ky" href="https://pypi.org/project/pyodbc/" rel="noopener ugc nofollow" target="_blank"> pyodbc </a>模块，这变得非常容易。我们简单地将一个连接字符串传递给<code class="fe nh ni nj mr b">pyodbc.connect(...)</code>函数，更多细节可以在<a class="ae ky" href="https://docs.microsoft.com/en-us/sql/connect/python/pyodbc/step-3-proof-of-concept-connecting-to-sql-using-pyodbc?view=sql-server-ver15" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><p id="848b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我喜欢在<code class="fe nh ni nj mr b">Sql</code>类中创建一个查询字符串，它随着传递给该类的每个查询而更新:</p><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="f8f6" class="mv lx it mr b gy mw mx l my mz">self.query = "-- {}\n\n-- Made in Python".format(datetime.now()<br/>                                              .strftime("%d/%m/%Y"))</span></pre><p id="b980" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这允许我们记录我们的代码，同时也作为一个可读性更强的输出，提供给那些更愿意阅读SQL代码的同事。</p><p id="e0dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nn">注意，我将在下面的代码片段中排除对</em> <code class="fe nh ni nj mr b"><em class="nn">self.query </em></code> <em class="nn">部分代码的更新，如果需要，请查看提供的链接中的完整代码。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/daef08b1da8ef8db78a530a955b5ba70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oMnHmGes4TWvDzX6"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@heyluisa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">路易莎·阿泽维多</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="1f71" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">积木</h1><p id="eddf" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">有几个基本功能我觉得非常有用，几乎每天都在使用。这些都侧重于将数据传入或传出数据库。</p><p id="0109" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从以下目录开始:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/5b74f1686887ff0a94b2a18f2f515a83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/format:webp/1*7NYq1-E9txL2DXWOYM0L7Q.png"/></div></figure><p id="94ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于我们当前的项目，我们需要:</p><ul class=""><li id="b390" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated">将这些文件导入SQL server</li><li id="7347" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">将它们合并到一个表中</li><li id="1445" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">基于列中的类别动态创建多个表</li></ul><p id="df19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在进一步充实我们的SQL类之后，这将变得像下面这样简单:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="a4bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从头开始。</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h2 id="52b4" class="mv lx it bd ly on oo dn mc op oq dp mg li or os mi lm ot ou mk lq ov ow mm ox bi translated">推送数据帧</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">点击<a class="ae ky" href="https://gist.github.com/jamescalam/74e18f935e223c4aa486dc517e689d84" rel="noopener ugc nofollow" target="_blank">这里</a>查看完整的脚本，或者<a class="ae ky" href="https://gist.github.com/jamescalam/9532e8813f8161e66f420b0f427e7c87" rel="noopener ugc nofollow" target="_blank">这个</a>脚本可以维护数据类型(但是偶尔会在不太干净的数据集上抛出错误)</p></figure><p id="9b10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个函数包含在我们的SQL类中。它允许我们轻松地将Pandas数据帧推送到SQL数据库。</p><p id="89bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这在需要上传大量文件时特别有用。然而，允许Python将数据导入SQL的真正力量来自于Python的灵活性。</p><blockquote class="nk nl nm"><p id="5a34" class="kz la nn lb b lc ld ju le lf lg jx lh no lj lk ll np ln lo lp nq lr ls lt lu im bi translated">将十几个Excel工作簿中的特定选项卡导入SQL可能是一场噩梦。但是使用Python很容易。现在我们已经构建了一个函数，允许我们使用Python来读取这些选项卡，并为我们将它们导入SQL。</p></blockquote></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h2 id="f7ab" class="mv lx it bd ly on oo dn mc op oq dp mg li or os mi lm ot ou mk lq ov ow mm ox bi translated">指南</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">点击<a class="ae ky" href="https://gist.github.com/jamescalam/586f79e4d9aba64d6e30d70de72d3f90" rel="noopener ugc nofollow" target="_blank">此处</a>查看完整脚本</p></figure><p id="1cbc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该功能实际上用于<code class="fe nh ni nj mr b">union </code>和<code class="fe nh ni nj mr b">drop </code>功能。它只是让我们尽可能简单地执行SQL代码。</p><p id="1327" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nh ni nj mr b">response </code>参数为我们提供了将查询输出提取到数据帧的选项。允许我们从<code class="fe nh ni nj mr b">generic_jan </code>表中的<code class="fe nh ni nj mr b">colX </code>中提取所有唯一值，只需使用:</p><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="c98d" class="mv lx it mr b gy mw mx l my mz">sets = list(sql.manual("SELECT colX AS 'category' FROM generic_jan GROUP BY colX", response=True)['category'])</span></pre></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h2 id="af81" class="mv lx it bd ly on oo dn mc op oq dp mg li or os mi lm ot ou mk lq ov ow mm ox bi translated">联盟</h2><p id="cc05" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">现在我们已经构建了<code class="fe nh ni nj mr b">manual </code>函数，创建<code class="fe nh ni nj mr b">union </code>函数很容易:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">点击<a class="ae ky" href="https://gist.github.com/jamescalam/0ee0dfc9b907e6a59f5d3b2ab2d02d9e" rel="noopener ugc nofollow" target="_blank">此处</a>查看完整脚本</p></figure><p id="41f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这只是循环遍历我们通过<code class="fe nh ni nj mr b">table_list</code>提供的表名列表，为所有给定的表名构建一个联合查询。然后用<code class="fe nh ni nj mr b">self.manual(query)</code>执行。</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h2 id="f2d1" class="mv lx it bd ly on oo dn mc op oq dp mg li or os mi lm ot ou mk lq ov ow mm ox bi translated">滴</h2><p id="4f7b" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">我们能够将大量的表上传到SQL Server。这很好，但会很快使我们的数据库人满为患。为了解决这个问题，我们将创建一个<code class="fe nh ni nj mr b">drop </code>函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">点击<a class="ae ky" href="https://gist.github.com/jamescalam/b316c1714c30986fff58c22b00395cc0" rel="noopener ugc nofollow" target="_blank">此处</a>查看完整脚本</p></figure><p id="d00c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，由于有了<code class="fe nh ni nj mr b">manual </code>功能，这个功能非常简单。这允许我们通过向<code class="fe nh ni nj mr b">tables </code>提供一个字符串来删除单个表，或者通过向<code class="fe nh ni nj mr b">tables</code>提供一个表名列表来删除多个表。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/eac698451f19a16713a8f828976e247e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TLprGagG_1chEaUG"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@aows?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿德里安</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="6018" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当将这些极其简单的函数结合起来时，我们可以利用Python的优势来大规模扩展SQL Server的功能。</p><p id="e6d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你有兴趣了解更多，请查看<code class="fe nh ni nj mr b">pysqlplus</code>的<a class="ae ky" href="https://github.com/jamescalam/pysqlplus" rel="noopener ugc nofollow" target="_blank"> GitHub回购</a>。这是一个小项目，只是为了增强我自己的工作场所与MS SQL Server的交互而构建的。</p><p id="20cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管如此，我希望它可以帮助其他一些用户找到将Python集成到他们的SQL例程中的方法。我个人几乎每天都在使用它，它是如此简单却又无比强大。</p><p id="fa7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><p id="eb2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nn">如果你有兴趣学习更多关于Python和云中SQL的知识，可以看看我在Coursera </em> <a class="ae ky" href="https://www.coursera.org/learn/ds" rel="noopener ugc nofollow" target="_blank"> <em class="nn">上发表的关于IBMs可扩展数据科学基础课程的评论，点击这里</em> </a> <em class="nn"> : </em></p><div class="oz pa gp gr pb pc"><a rel="noopener follow" target="_blank" href="/a-summary-of-the-advanced-data-science-with-ibm-specialization-1-4-5caf48c011df"><div class="pd ab fo"><div class="pe ab pf cl cj pg"><h2 class="bd iu gy z fp ph fr fs pi fu fw is bi translated">对IBM可伸缩数据科学基础的回顾</h2><div class="pj l"><h3 class="bd b gy z fp ph fr fs pi fu fw dk translated">我的想法是，在IBM的高级数据中，对可伸缩数据科学基础中的关键概念进行分解…</h3></div><div class="pk l"><p class="bd b dl z fp ph fr fs pi fu fw dk translated">towardsdatascience.com</p></div></div><div class="pl l"><div class="pm l pn po pp pl pq ks pc"/></div></div></a></div></div></div>    
</body>
</html>