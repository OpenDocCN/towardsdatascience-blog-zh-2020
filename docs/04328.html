<html>
<head>
<title>Working With Android WorkManager Using Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Kotlin 使用 Android WorkManager</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/working-with-android-workmanager-using-kotlin-36167a143579?source=collection_archive---------19-----------------------#2020-04-19">https://towardsdatascience.com/working-with-android-workmanager-using-kotlin-36167a143579?source=collection_archive---------19-----------------------#2020-04-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2c68" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">向后兼容的调度未来任务的理想方式</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fa7e8f75bc84305d11ba49d8d1b490dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qUguZ6LUTc3v8YVbMGI8Nw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Fernando Jorge 在<a class="ae ky" href="https://unsplash.com/s/photos/under-water?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="8308" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">工作管理器</strong>是一个 API，它可以调度你未来的异步任务，并且可以在后台运行它们。即使用户在应用程序之外或应用程序关闭，分配给工作管理器的任务也会执行。WorkManager 只能运行您的任务一次，也可以多次运行或定期运行。</p><h1 id="c6e0" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">工作管理器的功能</h1><ul class=""><li id="ae4a" class="mn mo it lb b lc mp lf mq li mr lm ms lq mt lu mu mv mw mx bi translated">它提供了高达 API 级别 14 的向后兼容性</li><li id="0ee6" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated">您可以添加一个或多个约束条件，如仅在手机充电或重启时执行任务等。</li><li id="78c6" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated">您可以计划一次性任务或定期任务</li><li id="e7b5" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated">您还可以链接多个任务。例如，任务<strong class="lb iu"> (B) </strong>应该只在任务<strong class="lb iu"> (A) </strong>完成时执行。</li><li id="f33e" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated">它可以帮助您在特定事件上执行任务。</li></ul><p id="adfb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>工作管理器不适用于在 app 进程结束时可以安全终止的正在进行的后台工作，也不适用于需要立即执行的任务。</p><h1 id="64fb" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">上层社会</h1><p id="be8e" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated"><strong class="lb iu">工作人员:</strong>这里定义了需要完成的工作。</p><p id="a6b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> WorkRequest: </strong>它决定将要执行哪个 worker 类。这是一个抽象类，所以我们将使用它的直接类，它们是<strong class="lb iu"> OneTimeWorkRequest </strong>和<strong class="lb iu"> PeriodWorkRequest </strong>。</p><p id="8ae9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">工作管理器:它对工作请求进行排队和管理。</p><p id="e962" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">WorkInfo: 它给我们关于工作的信息，不管是成功的、运行的还是失败的。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><p id="e3f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们现在开始编码吧…</p><h1 id="f2a7" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">我们会创造什么？</h1><p id="dd46" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">我们将在后台创建一个通知，这个通知只能创建一次，因为我们使用的是<strong class="lb iu"> OneTimeWorkRequest </strong>类。稍后，我们将使用一些约束来基于事件生成通知。</p><p id="87fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，添加以下依赖项。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="0e6c" class="ns lw it no b gy nt nu l nv nw">implementation <strong class="no iu">"androidx.work:work-runtime-ktx:2.3.4"</strong></span></pre><p id="301b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将首先通过扩展<code class="fe nx ny nz no b"><strong class="lb iu"><em class="oa">Worker</em></strong></code>类来创建我们的 worker 类，并覆盖它的<code class="fe nx ny nz no b"><strong class="lb iu"><em class="oa">doWork()</em></strong></code>方法用于后台处理。当工作管理器调用<code class="fe nx ny nz no b"><strong class="lb iu"><em class="oa">doWork()</em></strong></code>方法时，它调用用户定义的方法<code class="fe nx ny nz no b"><strong class="lb iu"><em class="oa">createNotification()</em></strong></code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="9263" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的<code class="fe nx ny nz no b"><strong class="lb iu"><em class="oa">MainActivity.kt</em></strong></code>类中，我创建了一个按钮，当用户点击按钮时，就会立即生成通知。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="2045" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我创建了<strong class="lb iu"> OneTimeWorkRequest </strong>的对象，并传递了我们的<code class="fe nx ny nz no b"><strong class="lb iu"><em class="oa">MyWork</em></strong></code>类的类名。在现实世界中，我们可以有很多 worker 类，所以应该执行哪个类是由这个 request 对象决定的。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="02d8" class="ns lw it no b gy nt nu l nv nw"><strong class="no iu">val </strong>request = <em class="oa">OneTimeWorkRequestBuilder</em>&lt;MyWork&gt;().build()</span></pre><p id="8687" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当用户单击按钮时，WorkManager 将请求排队。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="6ef6" class="ns lw it no b gy nt nu l nv nw">WorkManager.getInstance(<strong class="no iu">this</strong>).enqueue(request)</span></pre><p id="ae75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们创建一个 toast 来显示我们任务的状态，无论是<strong class="lb iu">运行</strong>、<strong class="lb iu">成功</strong>还是<strong class="lb iu">失败</strong>。<code class="fe nx ny nz no b"><strong class="lb iu"><em class="oa">getWorkInfoByIdLiveData</em></strong></code>方法获取请求 id 并给出关于任务的信息。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="3cac" class="ns lw it no b gy nt nu l nv nw">WorkManager.getInstance(<strong class="no iu">this</strong>).getWorkInfoByIdLiveData(request.<em class="oa">id</em>)<br/>            .observe(<strong class="no iu">this</strong>, <em class="oa">Observer </em><strong class="no iu">{<br/><br/>                val </strong>status: String = <strong class="no iu">it</strong>.<em class="oa">state</em>.<strong class="no iu">name<br/>                </strong>Toast.makeText(<strong class="no iu">this</strong>,status, Toast.<em class="oa">LENGTH_SHORT</em>).show()<br/>            <strong class="no iu">}</strong>)<br/><br/>}</span></pre><p id="4ff9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在运行你的应用程序，点击按钮，你会看到一个通知。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><p id="1990" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们将了解如何添加约束，以便仅在手机充电时创建通知。</p><p id="0b09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">添加以下代码行以创建约束并修改您的请求对象。在请求对象中，我只是设置约束，仅此而已。现在，只有当满足这个特定标准时，才会生成通知。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="df20" class="ns lw it no b gy nt nu l nv nw"><strong class="no iu">val </strong>constraints = Constraints.Builder()<br/>        .setRequiresCharging(<strong class="no iu">true</strong>)<br/>        .build()</span><span id="50d8" class="ns lw it no b gy od nu l nv nw"><strong class="no iu">var </strong>request = <em class="oa">OneTimeWorkRequestBuilder</em>&lt;MyWork&gt;()<br/>        .setConstraints(constraints)<br/>        .build()</span></pre><p id="f452" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>当指定了多个约束时，您的任务只有在所有约束都满足时才会运行。</p><p id="f941" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你点击按钮，而你的手机没有在充电，那么你会看到一个状态显示<strong class="lb iu">“排队”，</strong>这意味着你的请求已经被放入队列，只有当你的手机正在充电时才会执行。</p><p id="98b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你在运行代码时遇到任何问题，那么你可以从我的<a class="ae ky" href="https://github.com/himanshujbd/WorkManager" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> Github </strong> </a>账户下载这个项目。</p><p id="cb6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢读这篇文章，你也可以访问我的<a class="ae ky" href="http://thehimanshuverma.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">网站</strong> </a> <strong class="lb iu"> </strong>，在那里我会定期发布文章。</p><p id="ae59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://mailchi.mp/b08da935e5d9/himanshuverma" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">订阅</strong> </a>我的邮件列表，以便在您的收件箱中直接获得我的文章，并且不要忘记关注我自己在 Medium <a class="ae ky" href="https://medium.com/the-code-monster" rel="noopener"> <strong class="lb iu">【代码怪兽】</strong> </a>上发表的文章，以丰富您的技术知识。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="f4b8" class="lv lw it bd lx ly oe ma mb mc of me mf jz og ka mh kc oh kd mj kf oi kg ml mm bi translated">结论</h1><p id="470f" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">我们已经看到了如何使用 WorkManager 类来执行一些后台处理。在本文中，我在后台创建了一个通知。也看到了我们如何根据未来将要发生的事件来安排未来的任务。</p></div></div>    
</body>
</html>