<html>
<head>
<title>Using Python To Compile Julia Code Natively</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python原生编译Julia代码</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/run-native-julia-code-with-python-92d3e1079385?source=collection_archive---------12-----------------------#2020-01-09">https://towardsdatascience.com/run-native-julia-code-with-python-92d3e1079385?source=collection_archive---------12-----------------------#2020-01-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a154" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过切换语言来加速Python</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9a445889aa48ff069f30d90776d09ca4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gi7-7h0Z9RsMNv-O0HK1kg.jpeg"/></div></div></figure><p id="50f6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我经常讨论使用Julia的好处，因为有很多好处。Julia是一种可扩展的、高性能的高级语言，易于学习，几乎可以完成任何工作。对于数据科学家来说尤其如此，因为Julia的重心是统计计算和函数程序。在Julia的核心，它是一种为科学家用数据做统计而创造的语言，这种直接的意图使它在特定的事情上非常棒。</p><p id="a432" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">虽然我可以花很多年谈论Julia如何更快，具有更好的浮点精度，并且打字非常简单，但这不是我今天在这里的原因。虽然我已经表达了我的担忧，也可能夸大了我对朱莉娅的喜爱，但有一个大话题我还没有和朱莉娅谈过:</p><blockquote class="lq"><p id="ed55" class="lr ls it bd lt lu lv lw lx ly lz lp dk translated">多才多艺</p></blockquote><p id="0e25" class="pw-post-body-paragraph ku kv it kw b kx ma ju kz la mb jx lc ld mc lf lg lh md lj lk ll me ln lo lp im bi translated">使用Python语言的一个巨大好处是Python是通用的。如果你不想使用web请求，可能有一个包装器，如果你想把时间戳从Unix转换成UTC，有一个库。这是一个很大的好处，因为这意味着你的语言将永远支持你的工具。我已经提到过Julia的包是它最大的缺陷，但尽管如此，Julia最初是在2012年发布的，也就是8年前。朱莉娅反驳说:</p><blockquote class="lq"><p id="2e10" class="lr ls it bd lt lu lv lw lx ly lz lp dk translated">可翻译。</p></blockquote><figure class="mg mh mi mj mk kn gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/16c5ba182df7f4fb83342124a0a24a4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*Ck-wlAGJimim0RwlxD2YAQ.png"/></div></figure><p id="e1a9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，我们有令人惊奇的包PyCall.jl，它允许调用Python包，甚至在虚拟环境中。在数据科学领域，能够调用数百万个Python包是一件大事。</p><p id="df72" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">布丁中真正的水果是，反过来也是可能的。没错，从Python本地运行Julia非常容易。这很重要，因为我们都知道Python有时会相当慢。我承认，在大多数情况下，Python很棒，但是当Python让你失望时，它真的会让你进退两难，不知道下一步该做什么。</p><p id="69f3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">PyJulia或julia.py允许您发送类似SQL查询的代码行，并为实际返回标识一个返回变量。简而言之，你可以通过向Julia编译器发送字符串来运行Python中的Julia。当然，第一步是从您的包管理器中获取Julia，我将使用APT。</p><pre class="kj kk kl km gt ml mm mn mo aw mp bi"><span id="d7a1" class="mq mr it mm b gy ms mt l mu mv">sudo apt-get install julia</span></pre><p id="bb11" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在它就像进入朱莉娅REPL，然后安装PyCall与]或使用Pkg一样简单。</p><pre class="kj kk kl km gt ml mm mn mo aw mp bi"><span id="78b7" class="mq mr it mm b gy ms mt l mu mv">julia<br/>julia&gt; using Pkg; Pkg.add("PyCall")<br/>(or)<br/>julia&gt; ]<br/>pkg&gt; add "PyCall"</span></pre><p id="3f3a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于一些Julia包，包括PyCall，我推荐构建代码:</p><pre class="kj kk kl km gt ml mm mn mo aw mp bi"><span id="a1cc" class="mq mr it mm b gy ms mt l mu mv">julia&gt; ]<br/>pkg&gt; build "PyCall"</span></pre><p id="ee02" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，用退格键退出Pkg，按ctrl/command+D退出朱莉娅press。我们现在可以用pip安装我们的Python包了，我将使用pip3。</p><pre class="kj kk kl km gt ml mm mn mo aw mp bi"><span id="48c8" class="mq mr it mm b gy ms mt l mu mv">sudo pip3 install julia</span></pre></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><p id="f032" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">既然我们所有的依赖关系都得到了满足，我们就可以跳到笔记本上进行尝试了！第一步是使用Julia库中的安装方法:</p><pre class="kj kk kl km gt ml mm mn mo aw mp bi"><span id="8a2b" class="mq mr it mm b gy ms mt l mu mv">import julia as jl<br/>jl.install()</span></pre><p id="8520" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们可以导入Julia可执行文件，并用它运行字符串代码！</p><pre class="kj kk kl km gt ml mm mn mo aw mp bi"><span id="be89" class="mq mr it mm b gy ms mt l mu mv">from julia import Julia<br/>jl = Julia()<br/>average = jl.run("using Lathe.stats: mean; array = [1,5,4,5,6]; m = mean(array); return(m)")</span></pre></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><blockquote class="lq"><p id="02a6" class="lr ls it bd lt lu lv lw lx ly lz lp dk translated">所以…酷！</p></blockquote><p id="ee5f" class="pw-post-body-paragraph ku kv it kw b kx ma ju kz la mb jx lc ld mc lf lg lh md lj lk ll me ln lo lp im bi translated">但这意味着什么呢？嗯，任何用Julia开发的包都可以用Python开发。不仅如此，该包还可以在R中与JuliaCall.R一起使用。我已经开始为Julia的车床机器学习模块开发包装器，这些包装器将在native Julia下与Python和R一起使用。我真的很高兴Julia代码既更快，又同时使该包在最流行的统计语言中通用。这对Julia开发者来说是一个很大的好处，因为我们不必为了维护一个Python和R版本而重写代码。当然，随之而来的是在编译时使用Julia而不是Python的实际好处。</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="8db9" class="nd mr it bd ne nf ng nh ni nj nk nl nm jz nn ka no kc np kd nq kf nr kg ns nt bi translated">下降趋势</h1><p id="8068" class="pw-post-body-paragraph ku kv it kw b kx nu ju kz la nv jx lc ld nw lf lg lh nx lj lk ll ny ln lo lp im bi translated">在计算中没有什么是如此简单的，所以用这种了不起的方法翻译代码，也有一些不幸的问题。虽然很少，但我承认必须安装Julia和PyCall依赖项有点乏味，特别是对于一个以前从未使用过Julia的Python包的最终用户来说。此外，Julia的版本控制和兼容性给这个包带来了很大的问题，让PyJulia运行起来可能会很困难。我遇到的问题主要是在Unix所有权中，编译器在我的非所有目录(由root所有)中，由于权限被拒绝，我将得到退出状态1。</p><p id="7d01" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这当然是通过在我的Python位置上使用chown并在Julia的情况下做同样的事情来解决的。</p><p id="815c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">除了这个问题，还有它的写作方式，有点乏味。诚实地说，通过字符串发送单行代码并不是最理想的，如果你打算在代码中使用引号，并使用字符串，那么在Python中的“、”和”之间导航将会非常困难。没什么大不了的，但绝对是需要注意的。</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="b65a" class="nd mr it bd ne nf ng nh ni nj nk nl nm jz nn ka no kc np kd nq kf nr kg ns nt bi translated">结论</h1><p id="2048" class="pw-post-body-paragraph ku kv it kw b kx nu ju kz la nv jx lc ld nw lf lg lh nx lj lk ll ny ln lo lp im bi translated">总之，多才多艺是朱莉娅的一大优势。Julia代码不仅速度快，而且扩展性极强，还可以写成其他语言。这是一个很大的优势，因为您的mill Julia包可以在一个包装器中轻松运行，并且当它在本地系统上更新时，可以与原始的Julia包一致地更新，所以…酷！我非常期待能让R和Python都了解Lathe，这样更多的人就能使用Lathe，并希望能喜欢上它。</p></div></div>    
</body>
</html>