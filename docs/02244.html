<html>
<head>
<title>Serverless: Building Your Own Router</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无服务器:构建自己的路由器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/serverless-building-your-own-router-c2ca3071b2ec?source=collection_archive---------10-----------------------#2020-03-03">https://towardsdatascience.com/serverless-building-your-own-router-c2ca3071b2ec?source=collection_archive---------10-----------------------#2020-03-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d9c1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何为基于角色访问的REST API开发自己完整的lambda路由器</h2></div><p id="be8d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我的<a class="ae lb" rel="noopener" target="_blank" href="/serverless-a-painless-aws-boilerplate-e5ec3b4fb609">上一篇文章</a>中，我介绍了如何开发一个样板文件来支持AWS lambda部署。在本文中，我将展示如何为REST API开发一个合适的lambda路由器。这是开发可伸缩AWS lambda实例的重要一步。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lc"><img src="../Images/644cf61f48ef7a42271fa6d37b9a1690.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FlzFp07Y9_KO8yB14fbakw.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated"><a class="ae lb" href="https://aws.amazon.com/api-gateway/" rel="noopener ugc nofollow" target="_blank"> AWS API网关架构</a></p></figure><h1 id="bedf" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">为什么是路由器，而不是NodeJS服务器？</h1><p id="cef4" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">人们通常会在lambda中部署一个成熟的NodeJS HTTP服务器。然而，在理想的情况下，我们应该避免这样做，因为它会在lambda函数内部产生延迟。此外，我们肯定会错过API网关的唯一目的和特性，如身份验证和授权。</p><p id="f03b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种情况下，我们将实现一个简单的路由器，它不启动单独的服务器，而是利用lambda代理实现头将请求导航到我们实现的功能逻辑。通过这种方法，当lambdas被调用时，我们将拥有请求的即时路由。</p><h1 id="c213" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">AWS Lambda代理集成请求事件</h1><p id="1fba" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">使用无服务器框架的默认部署将通过Lambda代理集成来部署lambdas。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi mp"><img src="../Images/a13958fc891c8aee0a2fc13af99b9ba1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kCTEpdCg7qDYDtAXLuQHpQ.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">Lambda代理集成API示例</p></figure><p id="fd2b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">lambdas由带有三个参数<strong class="kh ir"> <em class="mq">事件</em> </strong>、<strong class="kh ir"> <em class="mq">上下文、</em> </strong>和<strong class="kh ir"> <em class="mq">回调</em> </strong>的函数组成。事件对象包含所有有用的信息，包括请求体、路径参数、查询参数、请求路径、源、cookie信息、头和其他请求参数。在代理集成中，我们的lambdas的行为类似于Nginx路由器(其中我们有所有的重写规则、转发、静态文件呈现等)。我们将利用来自事件对象的信息来构建我们的路由器。首先，让我们看一下事件对象。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="mr ms l"/></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">示例请求的事件对象</p></figure><p id="c249" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">观察事件对象，我们可以清楚地注意到以下两个主要有用的属性。</p><pre class="ld le lf lg gt mt mu mv mw aw mx bi"><span id="70df" class="my lt iq mu b gy mz na l nb nc">- resource<br/>- httpMethod</span></pre><p id="0e14" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这基本上是我们纯路由所需要的。哪个<code class="fe nd ne nf mu b">method</code>中的哪个<code class="fe nd ne nf mu b">path</code>应该被转发给目标<code class="fe nd ne nf mu b">function</code>。这简单地类似于开关情况。但是switch case应该有更多的功能，包括响应构建和处理不同类型的请求方法。</p><h1 id="a2cd" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">构建路由器</h1><h2 id="bd51" class="my lt iq bd lu ng nh dn ly ni nj dp mc ko nk nl me ks nm nn mg kw no np mi nq bi translated">路由器的输入</h2><p id="b67d" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">路由器必须与AWS函数调用一致，即使用<strong class="kh ir"> <em class="mq">事件</em> </strong>、<strong class="kh ir"> <em class="mq">上下文</em> </strong>和<strong class="kh ir"> <em class="mq">回调</em> </strong>作为参数。</p><h2 id="86ed" class="my lt iq bd lu ng nh dn ly ni nj dp mc ko nk nl me ks nm nn mg kw no np mi nq bi translated">创建路由器类或函数</h2><p id="8032" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">在经典的javascript中，类是用函数来模拟的。因此，在这个例子中，我将使用一个考虑到朴素场景的函数(这通常是Lambdas中的首选均值)。</p><p id="af8e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将实现一个名为<code class="fe nd ne nf mu b">Router</code>的函数，它将接受<code class="fe nd ne nf mu b">event</code>、<code class="fe nd ne nf mu b">context</code>和<code class="fe nd ne nf mu b">callback</code>作为参数(类似于构造函数属性)。在其中，我们可以有一个函数来调用分配给方法和路径的相关处理程序。让我们看看我们的代码会是什么样子。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="mr ms l"/></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">路由器实施</p></figure><p id="a8e3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你也可以看到我还有另一个功能<code class="fe nd ne nf mu b">builResponse</code>。它负责构建响应、字符串化主体和分配状态代码。这将使事情变得简单得多，在下一个关于如何使用路由器的代码片段中，您将会看到这一点。</p><h1 id="0528" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">使用路由器</strong></h1><p id="1ff0" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">现在我们已经实现了路由器，让我们看看如何使用它。在下面的代码中，我将展示如何让路由器处理路径<code class="fe nd ne nf mu b">data</code>和<code class="fe nd ne nf mu b">data/{taskId}</code>上的GET请求。如您所见，第二个路径是一个路径模板。路由必须相对于由服务的<strong class="kh ir"> service.yml </strong>文件确定的服务来完成。我在之前的文章中已经讨论过这个问题(<a class="ae lb" rel="noopener" target="_blank" href="/serverless-a-painless-aws-boilerplate-e5ec3b4fb609">此处阅读</a>)。<em class="mq">如果整个程序只有一个</em><strong class="kh ir"><em class="mq">server less . yml</em></strong><em class="mq">文件，可以使用完整路径忽略我前面那句话。</em></p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="mr ms l"/></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">路由器使用</p></figure><p id="c574" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以看到，我们可以使用路由器并传递一个处理函数，该函数具有与我们从lambda调用中获得的参数相同的参数。我们必须用<code class="fe nd ne nf mu b">error</code>和<code class="fe nd ne nf mu b">response</code>值调用<code class="fe nd ne nf mu b">callback</code>函数。但是，我们以HTTP状态代码的形式返回错误。因此，<code class="fe nd ne nf mu b">error</code>参数将始终为<code class="fe nd ne nf mu b">null</code>。</p><h1 id="bc6d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">授权和认证</h1><p id="9d65" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">如果没有适当的访问控制，应用程序基本上是无用的。<strong class="kh ir">认证</strong>是授权访问具有用户身份的API端点。授权是确保任务由有适当权限的人来完成。最好使用<em class="mq"> Cognito用户池</em>进行身份验证，其中每个用户的头都根据用户池进行验证(<a class="ae lb" href="https://medium.com/@anuradhawick/understanding-aws-cognito-and-iam-roles-af2dfefef996" rel="noopener">从此处了解更多信息</a>)。这将允许带有有效令牌的请求到达lambda调用。</p><h2 id="0370" class="my lt iq bd lu ng nh dn ly ni nj dp mc ko nk nl me ks nm nn mg kw no np mi nq bi translated">角色认知组</h2><p id="ecf5" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">当您拥有角色并且角色有权执行特定操作时，需要更细粒度的控制。换句话说，必须对报头进行验证，以检查令牌持有者的权限。这可以通过使用<em class="mq">认知用户组</em>来完成。这些可以通过<em class="mq"> Cognito控制台</em>轻松创建。下面是来自真实世界应用程序的几个组。您可以看到一个管理组。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi nr"><img src="../Images/f501837105b2789cff94a90cd7c44bcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sGho28uPLl01_PLYiGQUvQ.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">为管理员创建的管理员组</p></figure><p id="470b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可以创建这些组来向用户分配特定的角色。一个用户可以被分配到多个组。注意，这些组可以使用AWS SDK动态创建，不需要访问这个UI。</p><p id="f933" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">验证Lambda事件对象的角色</strong></p><p id="f511" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们分配的这些角色必须在我们的路由器中进行验证，在路由器中我们实际实现了基于角色的访问。我们可以在AWS中使用IAM角色来执行此操作。但是，这种方法更复杂，更适合限制对AWS资源的访问；即S3桶、用户池等。因此，我们将在lambda内部的路由器级别实现基于角色的访问，以便操纵对数据库和其他资源的访问。</p><p id="1f1e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">事件</strong>对象将在路径<code class="fe nd ne nf mu b">event.requestContext.authorizer.claims</code>中具有授权属性。这个对象将有一个名为<code class="fe nd ne nf mu b">cognito:groups</code>的属性。这可以是一个数组，也可以是一个值，匹配组或者这个人所属的组。这个值可以用来实现我们的授权。</p><h1 id="0379" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">带角色验证的路由器</h1><p id="ee92" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">这可以简单地作为我们路由器的<code class="fe nd ne nf mu b">route</code>功能的扩展。让我们看一下修改情况。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="mr ms l"/></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">增强型路由器实施</p></figure><p id="96eb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以看到我已经检查了<code class="fe nd ne nf mu b">cognito:groups</code>是否是一个数组。由于无服务器离线仿真和实际lambda行为的不匹配，我不得不这样做。无论如何，它使函数对可能的错误更强。我们的route函数调用只需要一个额外的参数，roles数组。仅此而已！。比如说；</p><pre class="ld le lf lg gt mt mu mv mw aw mx bi"><span id="1e9a" class="my lt iq mu b gy mz na l nb nc">router.route(<br/>    "GET", <br/>    "/path", <br/>    (event, context, callback) =&gt; { /* Logic + callback */      }, <br/>    ["Admin", "Some other group", ...]<br/>);</span></pre><p id="30f8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在你有了一个完整的lambda路由器，你可以导入并使用它。lambdas或重代码处理路由中没有服务器实例。这是一个遵循<strong class="kh ir"> <em class="mq">【责任链】</em> </strong>设计模式的大开关案例。在每个函数调用中，如果函数调用负责给定的<strong class="kh ir">方法</strong>和<strong class="kh ir">路径</strong>，处理它们，或者忽略。</p><p id="26da" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个路由器设计是我们创业时努力的结果，我一直在改进最初设计的一些细节，以适应新的需求。完整的样板文件可以在<a class="ae lb" href="https://github.com/anuradhawick/aws-lambda-serverless-boilerplate" rel="noopener ugc nofollow" target="_blank"> GitHub </a>中找到。</p><p id="7147" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢阅读！干杯！</p></div></div>    
</body>
</html>