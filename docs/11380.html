<html>
<head>
<title>From Jupyter Notebook To Scripts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从朱庇特笔记本到剧本</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/from-jupyter-notebook-to-sc-582978d3c0c?source=collection_archive---------3-----------------------#2020-08-07">https://towardsdatascience.com/from-jupyter-notebook-to-sc-582978d3c0c?source=collection_archive---------3-----------------------#2020-08-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="98e1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">不要玩玩具模型；准备好生产你的作品吧！</h2></div><blockquote class="kf kg kh"><p id="afa8" class="ki kj kk kl b km kn jr ko kp kq ju kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">8 月 16 日:<a class="ae lf" rel="noopener" target="_blank" href="/from-scripts-to-prediction-api-2372c95fb7c7">从脚本到预测 API </a></p><p id="7094" class="ki kj kk kl b km kn jr ko kp kq ju kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">2 月 23 日:<a class="ae lf" href="https://medium.com/@geoffreyhung/from-curl-to-automated-workflow-d79c7c108450" rel="noopener">从 cURL 到自动化工作流程</a></p><p id="64bc" class="ki kj kk kl b km kn jr ko kp kq ju kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">2022 年 1 月:<a class="ae lf" href="https://medium.com/@geoffreyhung/python-for-advanced-beginners-cd39b42ef10" rel="noopener">面向高级初学者的 Python</a></p></blockquote><p id="ef1d" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">作为高级初学者，我们知道很多:EDA、ML 概念、模型架构等……我们可以写一个大的 Jupyter 笔记本，点击“重启并运行全部”,生成最先进的结果。好吧，接下来呢？别人如何使用/复制/扩展你的成果？</p><p id="3e25" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">在本文中，我将向您展示我如何将 Jupyter 笔记本从葡萄酒数据集上的 Kaggle 转换为脚本，分享一些我们可以轻松适应并立即带来好处的工程实践。</p><p id="31a0" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">对于它们中的每一个，都有更多的内容需要挖掘，但我们将只介绍基本的内容，展示其优势，并解释思考过程！目标是尽量减少工程师在和你说话时翻白眼的可能性。</p><h1 id="220d" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">Jupyter 笔记本</h1><p id="710c" class="pw-post-body-paragraph ki kj iq kl b km mb jr ko kp mc ju kr lg md ku kv lh me ky kz li mf lc ld le ij bi translated">Jupyter 笔记本是很好的探索和原型，但我们不能永远停留在那里。没有工程师(或没有人)愿意阅读你的代码并重写它。即使你足够幸运地拥有工程资源，它也只会减慢整个过程🙁</p><p id="79ee" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">不知何故，我们需要调整工程实践，使其可重复、可自动化和可部署！第一步是将笔记本转换成脚本，这是本文的主题！</p><p id="a329" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated"><a class="ae lf" href="https://github.com/G-Hung/model-productization_article" rel="noopener ugc nofollow" target="_blank">&gt;&gt;&gt;【GitHub 回购&lt; &lt; &lt; </a></p><p id="5dd4" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">回购中<a class="ae lf" href="https://www.kaggle.com/vishalyo990/prediction-of-quality-of-wine" rel="noopener ugc nofollow" target="_blank">这部伟大笔记本</a>的所有功劳归原创者所有！</p><h1 id="1439" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">脚本:ipynb--&gt;。巴拉圭</h1><p id="204a" class="pw-post-body-paragraph ki kj iq kl b km mb jr ko kp mc ju kr lg md ku kv lh me ky kz li mf lc ld le ij bi translated">为什么要写剧本？为什么我们不能在交互式笔记本工作正常的时候使用它呢？让我提出一些场景来证明为什么在探索之外使用脚本是一个好主意！</p><ol class=""><li id="de38" class="mg mh iq kl b km kn kp kq lg mi lh mj li mk le ml mm mn mo bi translated">如果要并行运行 20 个大机型，会开 20 台笔记本吗？</li><li id="f22b" class="mg mh iq kl b km mp kp mq lg mr lh ms li mt le ml mm mn mo bi translated">假设你愿意打开 20 台笔记本，你会如何配置超参数？去每个笔记本找相关单元格？</li><li id="7dc4" class="mg mh iq kl b km mp kp mq lg mr lh ms li mt le ml mm mn mo bi translated">假设你手动配置 20 台笔记本，你会如何分析结果？转到每个笔记本？</li><li id="b5b2" class="mg mh iq kl b km mp kp mq lg mr lh ms li mt le ml mm mn mo bi translated">假设您可以在前 3 步处理 20 台笔记本电脑，如果您有一个伟大的想法，但您需要用 200 组超参数进行实验，您愿意重复步骤 1-3 吗？</li><li id="a8d7" class="mg mh iq kl b km mp kp mq lg mr lh ms li mt le ml mm mn mo bi translated">假设您在原始笔记本中发现了一个错误，需要重新运行所有内容，您愿意重复步骤 1–3 吗？</li></ol><p id="b360" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">如果你的回答都是肯定的，那么这篇文章不适合你，再见，祝你有美好的一天😊</p><p id="4e05" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">我构建管道的方式是将它分解成<strong class="kl ir"> etl.py </strong>、<strong class="kl ir"> train.py </strong>和<strong class="kl ir"> predict.py </strong>。每个脚本都有自己的职责，并尽量做到原子化，这样，只要职责明确，每个团队成员都可以开发它们。</p><p id="ecbc" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated"><strong class="kl ir"> etl.py </strong>:转换原始数据，做一些转换，在数据文件夹【train_test_split】下创建 train.csv 和 test.csv</p><p id="9321" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated"><strong class="kl ir"> train.py </strong>:使用 train.csv 中的数据，将模型导出到模型文件夹【model.fit(X，y)】</p><p id="fca0" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated"><strong class="kl ir"> predict.py </strong>:使用 test.csv 中的数据和训练好的模型，导出预测，并对[model.predict(X，y)]求值</p><figure class="mv mw mx my gt mz gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/95174bd1df1015de2dd2c1e891ba53ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1178/format:webp/1*nqbLGPriluEcI1IyXqv01Q.png"/></div><p class="nc nd gj gh gi ne nf bd b be z dk translated">脚本关系，各自处理自己的部分</p></figure><pre class="mv mw mx my gt ng nh ni nj aw nk bi"><span id="bd0a" class="nl lk iq nh b gy nm nn l no np"># File structure<br/>.<br/>├── README.md<br/>├── __init__.py<br/>├── autoformat.sh<br/>├── data<br/>│   ├── predict.csv<br/>│   ├── test.csv<br/>│   ├── train.csv<br/>│   └── winequality.csv<br/>├── log<br/>│   ├── etl.log<br/>│   ├── predict.log<br/>│   └── train.log<br/>├── model<br/>│   └── model.pkl<br/>├── notebook<br/>│   └── prediction-of-quality-of-wine.ipynb<br/>├── requirement.txt<br/>└── scripts<br/>    ├── config.yml<br/>    ├── <strong class="nh ir">etl.py</strong><br/>    ├── <strong class="nh ir">predict.py</strong><br/>    ├── test_train.py<br/>    ├── test_utility.py<br/>    ├── <strong class="nh ir">train.py</strong><br/>    └── utility.py</span></pre><p id="dfaa" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">如果我搞砸了什么，我不会试图找出原因[想象 Jupyter 中的状态突变，因为你随机运行细胞]，我只会再次运行脚本，看看。</p><pre class="mv mw mx my gt ng nh ni nj aw nk bi"><span id="7283" class="nl lk iq nh b gy nm nn l no np"># Run in command line, as simple as this :)</span><span id="75f2" class="nl lk iq nh b gy nq nn l no np">$ python3 ./scripts/etl.py<br/>$ python3 ./scripts/train.py<br/>$ python3 ./scripts/predict.py</span></pre><p id="3f8d" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">太好了，我们可以在命令行中加载和运行脚本了！但是正如我们在上面的场景中提到的那样[№2]，我们如何配置超参数呢？_?</p><h1 id="1059" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">配置文件作为输入:单击</h1><p id="4b7e" class="pw-post-body-paragraph ki kj iq kl b km mb jr ko kp mc ju kr lg md ku kv lh me ky kz li mf lc ld le ij bi translated">原则是尽量不要接触代码，我已经创建了另一个 config.yml 来包含所有的配置，并通过<a class="ae lf" href="https://click.palletsprojects.com/en/7.x/" rel="noopener ugc nofollow" target="_blank">点击</a>来加载它们。这样，每一个新的模型都是另一个配置，这保证了可复制性，避免了手动修改代码和引入错误🙁 ].</p><pre class="mv mw mx my gt ng nh ni nj aw nk bi"><span id="1309" class="nl lk iq nh b gy nm nn l no np"># config.yml example, I only use this to configure the scripts<br/>etl:<br/>  raw_data_file: "data/winequality.csv"<br/>  processed_path: "data"<br/>  test_size: 0.2<br/>  random_state: 42</span><span id="c3fd" class="nl lk iq nh b gy nq nn l no np">train:<br/>  processed_train: "data/train.csv" <br/>  ensemble_model: "RandomForestClassifier"<br/>  model_config: {n_estimators: 300}<br/>  model_path: "model/model.pkl"</span><span id="7b5b" class="nl lk iq nh b gy nq nn l no np">predict:<br/>  model_path: "model/model.pkl"<br/>  processed_test: "data/test.csv"<br/>  predicted_file: "data/predict.csv"<br/>  export_result: True</span></pre><p id="8101" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">在脚本中，我创建了一个实用函数来解析配置文件</p><pre class="mv mw mx my gt ng nh ni nj aw nk bi"><span id="6092" class="nl lk iq nh b gy nm nn l no np">def parse_config(config_file):<br/>    with open(config_file, "rb") as f:<br/>        config = yaml.safe_load(f)<br/>    return config</span></pre><p id="c12b" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">然后，我们可以以可扩展的方式将配置加载到脚本中！</p><pre class="mv mw mx my gt ng nh ni nj aw nk bi"><span id="cd49" class="nl lk iq nh b gy nm nn l no np"><a class="ae lf" href="http://twitter.com/click" rel="noopener ugc nofollow" target="_blank">@click</a>.command()<br/><a class="ae lf" href="http://twitter.com/click" rel="noopener ugc nofollow" target="_blank">@click</a>.argument("config_file", type=str, default=<strong class="nh ir">"scripts/config.yml"</strong>)<br/>def etl(config_file):<br/>    config = <strong class="nh ir">parse_config</strong>(config_file)<br/>    raw_data_file = config["etl"]["raw_data_file"]<br/>    processed_path = Path(config["etl"]["processed_path"])</span><span id="ac68" class="nl lk iq nh b gy nq nn l no np">.......DO SOMETHING.......</span></pre><p id="e1e2" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">如果我们有 20 个具有相似体系结构的模型，我们只需准备 20 种配置，仅此而已</p><h1 id="4b23" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">不打印:记录</h1><p id="73aa" class="pw-post-body-paragraph ki kj iq kl b km mb jr ko kp mc ju kr lg md ku kv lh me ky kz li mf lc ld le ij bi translated">我们现在可以在命令行环境中组合脚本和配置了！我如何获得输出？在 Jupyter 世界中，我可以打印和查看，但这意味着我需要浏览一个很长很长的笔记本，如果我有很多模型怎么办？有什么具体的方法可以将输出收集到一个文件中吗？</p><p id="6dbf" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">放开打印，学习<a class="ae lf" href="https://docs.python.org/3/howto/logging.html" rel="noopener ugc nofollow" target="_blank">日志</a>！Python 中的日志模块顾名思义就是用 Python 做日志。我们可以定义和记录我们感兴趣的事情，例如，脚本的哪个阶段[用于调试]，指标的总结[用于评估]，我从模型预测和评估中提取了一段作为示例</p><figure class="mv mw mx my gt mz"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="e730" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">这段代码将生成如下所示的日志</p><figure class="mv mw mx my gt mz"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="1f86" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">从本文中了解更多关于日志记录的信息！<a class="ae lf" href="https://www.machinelearningplus.com/python/python-logging-guide/" rel="noopener ugc nofollow" target="_blank">https://www . machinelingplus . com/python/python-logging-guide/</a></p><p id="7465" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated"><strong class="kl ir">旁白:</strong></p><p id="51bb" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">日志记录很好，但是如果我们有 100 个实验，我们将得到 100 个日志文件🙁即使是具体的，我们也不一定想一个一个看，有没有更好的方法来评价？以下是一些可能的解决方案:</p><ul class=""><li id="1a5f" class="mg mh iq kl b km kn kp kq lg mi lh mj li mk le nt mm mn mo bi translated">还有一个脚本，利用 grep 或 regex，解析并提取关键信息[但是如果有人改变了格式或拼写怎么办！？]</li><li id="1506" class="mg mh iq kl b km mp kp mq lg mr lh ms li mt le nt mm mn mo bi translated">又一个工具，checkout <a class="ae lf" href="https://mlflow.org/docs/latest/projects.html" rel="noopener ugc nofollow" target="_blank"> MLFlow </a>或者<a class="ae lf" href="https://github.com/VertaAI/modeldb" rel="noopener ugc nofollow" target="_blank"> ModelDB </a>！[日志记录只是这两款产品的功能之一]</li></ul><h1 id="96c3" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">再现性问题:康达环境</h1><p id="d706" class="pw-post-body-paragraph ki kj iq kl b km mb jr ko kp mc ju kr lg md ku kv lh me ky kz li mf lc ld le ij bi translated">哟，现在情况似乎不错！我可以推送至 GitHub，我的朋友/同事可以克隆并运行他们在<strong class="kl ir">的</strong>电脑😊</p><p id="e4cb" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">哦，等等……..他们的电脑……..如果我们使用不同的版本呢？之所以常见，是因为每个包都有很多版本，比如:<a class="ae lf" href="https://scikit-learn.org/stable/whats_new.html" rel="noopener ugc nofollow" target="_blank"> sklearn </a>。APIs 接口可能会随着时间而改变[并破坏代码🙁]，我们如何确保使用相同的软件包？</p><p id="b208" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">简答:康达 env，查看<a class="ae lf" rel="noopener" target="_blank" href="/a-guide-to-conda-environments-bc6180fc533">马特的文章</a></p><p id="9280" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">我在下面列出了一些有用的命令，刚好满足我们的需求</p><pre class="mv mw mx my gt ng nh ni nj aw nk bi"><span id="a444" class="nl lk iq nh b gy nm nn l no np"># In terminal</span><span id="a408" class="nl lk iq nh b gy nq nn l no np"># Create the environment<br/>$ conda create — name YOU_CHANGE_THIS python=3.7 -y</span><span id="9368" class="nl lk iq nh b gy nq nn l no np"># Activate it<br/>$ conda activate YOU_CHANGE_THIS</span><span id="fd1a" class="nl lk iq nh b gy nq nn l no np"># Install the needed package<br/>$ pip install –r requirements.txt</span><span id="327b" class="nl lk iq nh b gy nq nn l no np"># # ## # ## # ## # ## # ## # ##<br/># # # Do your development # # #<br/># # ## # ## # ## # ## # ## # ##</span><span id="2e81" class="nl lk iq nh b gy nq nn l no np"># Deactivate and back to normal environment<br/>$ conda deactivate</span><span id="8a80" class="nl lk iq nh b gy nq nn l no np"># This will remove the environment, do it when you finish the project?<br/>$ conda remove –name YOU_CHANGE_THIS –all</span></pre><p id="2a94" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">*在 requirements.txt 中，您应该始终指定版本！如果你不指定它，它会尝试下载最新的版本，但是你的最新版本可能不是我的最新版本，这样就失去了使用 Conda env 的意义</p><pre class="mv mw mx my gt ng nh ni nj aw nk bi"><span id="c49a" class="nl lk iq nh b gy nm nn l no np"># this is what I have inside requirements.txt<br/>pytest==5.3.5<br/>pandas==1.0.1<br/>Click==7.0<br/>scikit-learn==0.22.1<br/>black==19.10b0<br/>isort==4.3.21<br/>PyYAML==5.2</span></pre><h1 id="c20f" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">不要破坏你以前的代码:pytest</h1><p id="6f44" class="pw-post-body-paragraph ki kj iq kl b km mb jr ko kp mc ju kr lg md ku kv lh me ky kz li mf lc ld le ij bi translated">在软件/ ML 的世界里，变化是永恒的，无论何时我们工作，我们都会改变一些东西。但是我们如何确保新的变化不会破坏现有的变化(尤其是你几个月前写的变化)？</p><p id="3938" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">单元测试是有帮助的😊我们可以为每个功能编写测试用例，以确保它们具有预期的行为。单元测试不能证明程序的正确性，但是它们可以保护你列出的场景！</p><p id="3342" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">例如，下面的代码断言类型和输出维度是预期的。这看起来很傻也很简单，但是如果你的 load_data 函数变得更复杂，你会感激一些东西一直保护着你[特别是如果你想改变一些东西，不要问我是怎么知道的]！</p><figure class="mv mw mx my gt mz"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="1276" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">要运行单元测试，只需在终端中运行<strong class="kl ir"> pytest </strong>，您应该会看到如下输出</p><figure class="mv mw mx my gt mz gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/4650a3a2e88c5b49c2921128c458524d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*koXC4iwTNJW6gAvwL7RVVQ.png"/></div></figure><p id="5385" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">酷，我们可以在推 GitHub 之前运行 pytest，并尝试维护一个可行的程序！但是人类是不可靠的，如果我们在 push 之前忘记运行 pytest 并破解代码怎么办！？在这种情况下，我们该如何保护自己？</p><h1 id="9e30" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">如果可能，不要依赖人类:持续集成</h1><p id="85a8" class="pw-post-body-paragraph ki kj iq kl b km mb jr ko kp mc ju kr lg md ku kv lh me ky kz li mf lc ld le ij bi translated">如果程序本身可以在我们推送/创建拉取请求时自动运行单元测试，那会怎么样？如果不能通过测试，它就可以停止合并！如果您听说过持续集成，这是特性的一部分！市场上流行的产品是 CircleCI / TravisCI / jenkins，但是我很懒，如果不需要，我不想做任何额外的配置工作，所以我们将使用相对较新的 GitHub 动作😊</p><figure class="mv mw mx my gt mz"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="3726" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">在过去，我认为工程师是如此聪明，他们怎么能记住语法并自己想出这样的脚本(这已经很简单了)？不要这样想，大多数人只是像我一样复制和修改模板 GitHub Actions 中 CI workflows 下有一个名为<strong class="kl ir"> Publish Python package </strong>的模板]</p><figure class="mv mw mx my gt mz gh gi paragraph-image"><div role="button" tabindex="0" class="nw nx di ny bf nz"><div class="gh gi nv"><img src="../Images/b9787afafa8a6aa1ab0807f138c82706.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5CKfEB6aWrt4qKxcorUFuA.png"/></div></div></figure><p id="d854" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">现在你看到了！脚本、包版本和 pytest 一起工作来确保包版本是正确的，程序是可行的！当我们增量开发时，他们会保护我们，如果代码破坏了单元测试，他们会说不。如果我们发现了一个 bug，我们可以把它作为另一个测试用例，以确保我们不会犯两次同样的错误！</p><p id="3f7c" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">你能以同样的信心在 Jupyter 笔记本上做同样的事情吗？</p><p id="65d3" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated"><strong class="kl ir">代码风格问题:黑色，isort </strong></p><p id="d8e2" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">你听说过<a class="ae lf" href="https://www.python.org/dev/peps/pep-0008/" rel="noopener ugc nofollow" target="_blank"> pep8 </a>吗？这是写 Python 的风格惯例，有许多(好)点，但老实说，请不要在这方面测试我，我的大脑不能记住它们！</p><p id="c01b" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">我记得在我的一堂课上，我的教授要求我们使用<a class="ae lf" href="https://pypi.org/project/pycodestyle/" rel="noopener ugc nofollow" target="_blank"> pycodestyle </a>这是一种检查代码风格的工具，然后我得到了这些消息并逐一修复它们。例如:</p><pre class="mv mw mx my gt ng nh ni nj aw nk bi"><span id="b490" class="nl lk iq nh b gy nm nn l no np">$ pycodestyle --first optparse.py<br/>optparse.py:69:11: E401 multiple imports on one line<br/>optparse.py:77:1: E302 expected 2 blank lines, found 1<br/>optparse.py:88:5: E301 expected 1 blank line, found 0</span></pre><p id="9890" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">我认为这是一个很好的工具，但有点不完整，如果你能找到我的问题，为什么不帮我纠正一下，节省我的时间呢？</p><figure class="mv mw mx my gt mz"><div class="bz fp l di"><div class="nr ns l"/></div></figure><pre class="mv mw mx my gt ng nh ni nj aw nk bi"><span id="7ec4" class="nl lk iq nh b gy nm nn l no np">Simply run this and the script will do the rest!</span><span id="5008" class="nl lk iq nh b gy nq nn l no np"># If you get permission error, you can try<br/># chmod +rx autoformat.sh<br/>$ ./autoformat.sh</span></pre><h1 id="7d24" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">结论</h1><p id="f155" class="pw-post-body-paragraph ki kj iq kl b km mb jr ko kp mc ju kr lg md ku kv lh me ky kz li mf lc ld le ij bi translated">事情现在对<strong class="kl ir">本地</strong>有利！我可以把它们推送到 GitHub，我的朋友可以克隆并在他们的电脑上运行它</p><p id="4bf6" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">但是！我们知道重要的(不好的)信息通常以但是开头，例如:工作申请被拒🙁</p><figure class="mv mw mx my gt mz gh gi paragraph-image"><div role="button" tabindex="0" class="nw nx di ny bf nz"><div class="gh gi oa"><img src="../Images/c270ddf128e424b1622195cb1d485b07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KQzyaHtfx3XCm6l-xq9HXw.png"/></div></div></figure><p id="fdd9" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">但是如果我们想要生产这个模型呢？_?</p><p id="1612" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">问:首先，生产化意味着什么？</p><p id="2afe" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">答:狭义的意思是模型消费，我给你输入，你给我返回输出[可能以 JSON 的形式]，例如:web 端点/ API。我们需要一台服务器[另一台计算机]来托管模型和端点，我不想用我的计算机 T11 来托管它，否则整个产品将依赖于我可怜的 Macbook<strong class="kl ir">🙁</strong></p><p id="9105" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">我在上面<strong class="kl ir">突出了</strong>两个字，它们正是挑战</p><p id="c882" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">1.如何找到另一台计算机来托管模型？</p><p id="05a8" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">简短的回答:要么买一台电脑，要么从云提供商那里租一台[例如:AWS，Azure，GCP]，然后我们就可以宣称我们了解云计算😊</p><p id="4dd9" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">2.如果另一台计算机不是 MacOS，我如何确保我的代码在那里工作？</p><p id="8008" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">简答:Docker</p><p id="23fa" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated"><strong class="kl ir">总结一下，我们:</strong></p><pre class="mv mw mx my gt ng nh ni nj aw nk bi"><span id="8f21" class="nl lk iq nh b gy nm nn l no np">a. start from a Jupyter Notebook<br/>b. Code conversion [ipynb to .py]<br/>c. Make the scripts configurable [Click]<br/>d. Include logging [logging]<br/>e. Make sure the local environment is the same [Conda env]<br/>f. Include unit test and basic CI [pytest, GitHub Action]<br/>g. Autoformat the script style [black, isort]</span></pre><p id="7de5" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">我希望带有注释的文件树结构可以向您展示代码的演变，不要被许多文件夹吓到，因为它们是一步一步开发的，如果您理解思维过程，它是非常简单的！</p><pre class="mv mw mx my gt ng nh ni nj aw nk bi"><span id="7e47" class="nl lk iq nh b gy nm nn l no np">.<br/>├── README.md<br/>├── __init__.py<br/>├── .github/workflows         [f]<br/>├── autoformat.sh             [g]<br/>├── data<br/>│   ├── predict.csv           [b]<br/>│   ├── test.csv              [b]<br/>│   ├── train.csv             [b]<br/>│   └── winequality.csv<br/>├── log<br/>│   ├── etl.log               [d]<br/>│   ├── predict.log           [d]<br/>│   └── train.log             [d]<br/>├── model<br/>│   └── model.pkl             [b]<br/>├── notebook<br/>│   └── prediction-of-quality-of-wine.ipynb [a]<br/>├── requirement.txt           [e]<br/>└── scripts<br/>    ├── config.yml            [c]<br/>    ├── etl.py                [b, c]<br/>    ├── predict.py            [b, c]<br/>    ├── test_train.py         [f]<br/>    ├── test_utility.py       [f]<br/>    ├── train.py              [b, c]<br/>    └── utility.py</span></pre><p id="4ab7" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated"><strong class="kl ir">我们提到但没有详细说明的东西:</strong></p><p id="034c" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">-&gt; Databricks 的 MLFlow / VertaAI 的 ModelDB</p><p id="d851" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated"><strong class="kl ir">我们可以多讨论的事情:</strong></p><ul class=""><li id="3d26" class="mg mh iq kl b km kn kp kq lg mi lh mj li mk le nt mm mn mo bi translated">云中的模型部署[AWS]</li><li id="1410" class="mg mh iq kl b km mp kp mq lg mr lh ms li mt le nt mm mn mo bi translated">集装箱化[码头工人]</li></ul><p id="6e1a" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">现在我们已经建立了一个坚实的基础，这些脚本的形式，我们可以进一步重用它！想象一下，你如何用 Jupyter 笔记本做到这一点？</p></div><div class="ab cl ob oc hu od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="ij ik il im in"><p id="ca44" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">我理解当有人说你应该尝试 ABC / XYZ 时的感受，但他们没有解释为什么或如何从零开始发展，我希望这篇文章能有所贡献:)</p><p id="9164" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">如果这篇文章有用，可以留下一些评论</p><p id="947a" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">或者你可以开始我的<a class="ae lf" href="https://github.com/G-Hung/model-productization_article" rel="noopener ugc nofollow" target="_blank">回购</a>！</p><p id="33fe" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">或者<a class="ae lf" href="https://www.linkedin.com/in/geoffreyhung/" rel="noopener ugc nofollow" target="_blank">我的 LinkedIn </a>【欢迎但请留下几句话表明你不是僵尸】！</p><p id="9376" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr lg kt ku kv lh kx ky kz li lb lc ld le ij bi translated">这些东西大部分都是我在实习@ <a class="ae lf" href="https://www.manifold.ai/manifold" rel="noopener ugc nofollow" target="_blank">流形 AI </a>中学到的</p></div></div>    
</body>
</html>