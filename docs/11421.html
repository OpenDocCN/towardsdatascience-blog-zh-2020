<html>
<head>
<title>Scope of Variable and LEGB Rule</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">变量范围和 LEGB 规则</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/scope-of-variable-and-legb-rule-4d44d4576df5?source=collection_archive---------44-----------------------#2020-08-07">https://towardsdatascience.com/scope-of-variable-and-legb-rule-4d44d4576df5?source=collection_archive---------44-----------------------#2020-08-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/e21590c97a44f60cb98b51d0ce5141e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K_9lTWTwn2cA_lh24xjKkg.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">变量范围和 LEGB 规则。图片由<a class="ae jg" href="https://medium.com/@wiekiang" rel="noopener">作者</a></p></figure><h2 id="1a7e" class="jh ji jj bd b dl jk jl jm jn jo jp dk jq translated" aria-label="kicker paragraph">给 PYTHON 开发者的提示</h2><div class=""/><div class=""><h2 id="15ff" class="pw-subtitle-paragraph kp js jj bd b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dk translated"><strong class="ak">变量</strong>的<strong class="ak">范围</strong>是指你可以看到或者访问<strong class="ak">变量</strong>的地方</h2></div><p id="e05d" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">一开始，我假设您知道如何定义自己的函数，但不仅如此，您还知道如何编写具有多个参数的函数，并且可以使用元组返回多个值。</p><h2 id="5c03" class="md me jj bd mf mg mh dn mi mj mk dp ml lq mm mn mo lu mp mq mr ly ms mt mu jp bi translated">先决条件</h2><p id="5d32" class="pw-post-body-paragraph lh li jj lj b lk mv kt lm ln mw kw lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">如果你不熟悉定义自己的函数，下面的文章会给你更多的信息。</p><div class="is it gp gr iu na"><a rel="noopener follow" target="_blank" href="/writing-your-own-functions-40d381bd679"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd jt gy z fp nf fr fs ng fu fw js bi translated">编写自己的函数</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">数据科学家需要具有特定功能的函数</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">towardsdatascience.com</p></div></div><div class="nj l"><div class="nk l nl nm nn nj no ja na"/></div></div></a></div></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><p id="cf92" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们现在将在用户定义函数的上下文中讨论作用域的概念。你已经在你的程序中定义了变量。到目前为止，您一直在使用这些变量，没有任何问题。然而，如果你记得不是你定义的所有对象在程序中的任何地方都是可访问的，那就更好了。这就是作用域的概念，它告诉你程序的哪一部分一个对象或者一个变量可以被访问。</p><p id="fd84" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jt">变量或对象，如程序中定义的函数，都有名称，函数也是如此。</strong></p><p id="df7e" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">有几种类型的范围。第一个是<strong class="lj jt">全局范围</strong>，这意味着它是在脚本的主体中定义的。第二个是<strong class="lj jt">局部范围</strong>。局部作用域意味着它是在函数中定义的。一旦函数执行完毕，局部范围内的任何变量都会终止，这意味着在函数定义之外不能再访问这些变量。</p><p id="81f0" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">第三个是<strong class="lj jt">内置范围</strong>。这由 Python 提供的预定义内置模块中的变量组成，比如 print 和 sum。最后一个是<strong class="lj jt">封闭函数</strong>，我们将在后面的嵌套函数部分讨论这一点。</p><p id="adb4" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">让我们来看一个例子。</p><figure class="nw nx ny nz gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/c1e0f7df331c0c9b05d331d22b74dcde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YB49T77zQoPJgdrdWMVgcQ.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">本地范围。图片作者<a class="ae jg" href="https://medium.com/@wiekiang" rel="noopener">作者</a></p></figure><p id="136c" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们定义函数，然后调用它。如果我们试图在函数执行之前或之后访问变量名<code class="fe oa ob oc od b">value</code>，该变量是不可访问的。这是因为它仅在函数的局部范围内被定义。变量<code class="fe oa ob oc od b">value</code>没有被全局定义。</p><p id="e672" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果我们在定义和调用函数之前全局定义变量会怎么样？</p><figure class="nw nx ny nz gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/8c757f52af232113b55af6c92a8168cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fw6i60hkTu7JfY_eNcsfJQ.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">全球范围。图片由<a class="ae jg" href="https://medium.com/@wiekiang" rel="noopener">作者</a></p></figure><p id="50c7" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">简而言之，任何时候我们调用全局范围内的变量，它都会访问全局范围内的变量名。然而，每当我们在函数的局部范围内调用变量时，它将首先在局部范围内查找。这就是为什么调用<code class="fe oa ob oc od b">square(5)</code>返回的结果是 25 而不是 30。</p><p id="2df2" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果 Python 在局部范围内找不到变量，那么它会在全局范围内寻找。例如，我们在函数方块中访问一个全局定义的变量<code class="fe oa ob oc od b">value</code>。请注意，访问的全局值是调用函数时的值，而不是定义函数时的值。因此，如果我们重新分配<code class="fe oa ob oc od b">value</code>并调用该函数，我们会看到<code class="fe oa ob oc od b">value</code>的新值被访问。</p><p id="2a57" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">很明显，当我们引用一个变量时，首先搜索局部范围，然后是全局范围。如果变量在局部和全局范围内不存在，则到达内置范围。如果我们想在函数调用中改变一个全局变量的值呢？这就是关键字 global 派上用场的地方。</p><figure class="nw nx ny nz gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/86f1737c8d4e39cc6e4b28e72e98ea41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9tR9bBy8PdDrLAbB5Vd9jg.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">内置范围。图片作者<a class="ae jg" href="https://medium.com/@wiekiang" rel="noopener">作者</a></p></figure><p id="a2f5" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在函数定义中，我们使用关键字<code class="fe oa ob oc od b">global</code>，后跟我们希望访问和更改的全局变量的变量名。比如这里我们把<code class="fe oa ob oc od b">value</code>改成它的平方。之后，我们将调用<code class="fe oa ob oc od b">value</code>变量。我们看到，通过运行函数 square，全局值确实被平方了。</p></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><h2 id="81d3" class="md me jj bd mf mg mh dn mi mj mk dp ml lq mm mn mo lu mp mq mr ly ms mt mu jp bi translated">嵌套函数</h2><p id="d299" class="pw-post-body-paragraph lh li jj lj b lk mv kt lm ln mw kw lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">如果我们有一个在函数<code class="fe oa ob oc od b">outside</code>中定义的函数<code class="fe oa ob oc od b">inside</code>，并且我们在<code class="fe oa ob oc od b">inside</code>函数中引用了一个变量名<code class="fe oa ob oc od b">x</code>会怎么样？答案很直观。Python 搜索<code class="fe oa ob oc od b">inside</code>函数的局部范围。如果没有找到那个变量，它就搜索<code class="fe oa ob oc od b">outside</code>函数的范围，这个函数被称为封闭函数，因为它封闭了<code class="fe oa ob oc od b">inside</code>函数。如果 Python 在封闭函数的作用域中找不到那个变量，它只会搜索全局作用域，然后是内置作用域。</p><figure class="nw nx ny nz gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/c1d0b82deeea991fe7d64819e2b9d301.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2r66x4JqAXfKYssDdB0H2A.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">嵌套函数。图片作者<a class="ae jg" href="https://medium.com/@wiekiang" rel="noopener">作者</a></p></figure><p id="f1ea" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jt">为什么我们要嵌套一个函数？</strong></p><p id="e55e" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">有一些很好的理由。假设我们想在一个函数中多次执行一个过程。例如，我们想要一个函数，它接受三个数字作为参数，并对每个数字执行相同的函数。一种方法是将计算写出来三次，但是如果您想经常执行它，这是不可伸缩的。相反，我们可以在函数定义中定义一个内部函数，并在需要的地方调用它。这称为嵌套函数。</p><p id="17fa" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jt">我们来看另一个例子。</strong></p><figure class="nw nx ny nz gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/083da631bb9643c1a34fdb304910fd06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KHizinnEyh_uDe-7Wc0S3A.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">嵌套函数示例。图片作者<a class="ae jg" href="https://medium.com/@wiekiang" rel="noopener">作者</a></p></figure><p id="edb2" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><code class="fe oa ob oc od b">inside</code>函数的语法与任何其他函数的语法相同。在这个例子中，我们定义了一个函数<code class="fe oa ob oc od b">power_of</code>，它包含一个名为<code class="fe oa ob oc od b">inside</code>的内部函数。现在看看<code class="fe oa ob oc od b">power_of</code>返回什么:它返回内部函数<code class="fe oa ob oc od b">inside</code>。<code class="fe oa ob oc od b">power_of</code>接受一个参数并创建一个函数<code class="fe oa ob oc od b">inside</code>，该函数返回任意数字的 n 次方。这有点复杂，当我们执行函数<code class="fe oa ob oc od b">power_of</code>时会更精确。</p><p id="4fa4" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">将数字 2 传递给<code class="fe oa ob oc od b">power_of</code>会创建一个对任意数字求平方的函数。同样，将数字 3 传递给<code class="fe oa ob oc od b">power_of</code>会创建一个对任意数字进行立方的函数。</p><p id="5b7a" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">一个有趣的细节是，当我们调用函数<code class="fe oa ob oc od b">square</code>时，它会记住值<code class="fe oa ob oc od b">n=2</code>，尽管<code class="fe oa ob oc od b">power_of</code>定义的封闭范围和<code class="fe oa ob oc od b">n=2</code>所在的局部范围已经执行完毕。这是一个细微的差别，在计算机科学的圈子里被称为闭包，你不应该太担心。然而，这是值得一提的，因为你可能会遇到它。</p><figure class="nw nx ny nz gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/ca6babb461488a2d2f5e289f44287872.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JlCBOj_71F5uZnYxoT_yiQ.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">封闭范围内的变量。图片由<a class="ae jg" href="https://medium.com/@wiekiang" rel="noopener">作者</a></p></figure><p id="da69" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">转到我们对作用域的讨论，您可以在函数定义中使用关键字<code class="fe oa ob oc od b">global</code>来创建和更改全局变量；类似地，在嵌套函数中，可以使用关键字<code class="fe oa ob oc od b">nonlocal</code>在封闭范围内创建和更改变量。</p><p id="5557" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在这个例子中，我们修改了<code class="fe oa ob oc od b">inside</code>函数中<code class="fe oa ob oc od b">n</code>的值。因为我们使用了关键字<code class="fe oa ob oc od b">nonlocal</code>，它改变了封闭范围内<code class="fe oa ob oc od b">n</code>的值。这就是为什么调用<code class="fe oa ob oc od b">outside</code>函数会打印出函数<code class="fe oa ob oc od b">inside</code>中确定的<code class="fe oa ob oc od b">n</code>的值。</p></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><h2 id="5d90" class="md me jj bd mf mg mh dn mi mj mk dp ml lq mm mn mo lu mp mq mr ly ms mt mu jp bi translated">结论</h2><p id="2478" class="pw-post-body-paragraph lh li jj lj b lk mv kt lm ln mw kw lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">变量引用搜索:</p><ul class=""><li id="3074" class="oe of jj lj b lk ll ln lo lq og lu oh ly oi mc oj ok ol om bi translated">局部范围</li><li id="f141" class="oe of jj lj b lk on ln oo lq op lu oq ly or mc oj ok ol om bi translated">封闭函数</li><li id="b74f" class="oe of jj lj b lk on ln oo lq op lu oq ly or mc oj ok ol om bi translated">全球范围</li><li id="8666" class="oe of jj lj b lk on ln oo lq op lu oq ly or mc oj ok ol om bi translated">内置范围</li></ul><p id="1d14" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这被认为是 LEGB 规则，其中 L 代表局部，E 代表封闭，G 代表全局，B 代表内置。此外，请记住，定义变量将只创建或更改局部名称，除非它们在使用关键字 global 或关键字 nonlocal 的全局或非局部语句中声明。</p></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><pre class="nw nx ny nz gt os od ot ou aw ov bi"><span id="26c2" class="md me jj od b gy ow ox l oy oz"><strong class="od jt">Other Interesting Articles</strong></span><span id="47d3" class="md me jj od b gy pa ox l oy oz">#1 <a class="ae jg" rel="noopener" target="_blank" href="/function-arguments-default-keyword-and-arbitrary-9588b5eaaef3">Function Arguments: Default, Keyword, and Arbitrary</a></span><span id="ac90" class="md me jj od b gy pa ox l oy oz">#2 <a class="ae jg" rel="noopener" target="_blank" href="/writing-your-own-functions-40d381bd679">Writing Your Own Functions</a></span><span id="59a4" class="md me jj od b gy pa ox l oy oz">#3 <a class="ae jg" rel="noopener" target="_blank" href="/python-procedural-or-object-oriented-programming-42c66a008676">Python: Procedural or Object-Oriented Programming?</a></span><span id="162a" class="md me jj od b gy pa ox l oy oz">#4 <a class="ae jg" rel="noopener" target="_blank" href="/data-science-with-python-how-to-use-numpy-library-5885aa83be6b">Data Science with Python: How to Use NumPy Library</a></span><span id="7caa" class="md me jj od b gy pa ox l oy oz">#5 <a class="ae jg" rel="noopener" target="_blank" href="/do-you-have-the-software-engineer-and-data-scientist-skills-probably-not-7e8fb069e067">Do you have the Software Engineer and Data Scientist skills?</a></span></pre></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><h2 id="c2f8" class="md me jj bd mf mg mh dn mi mj mk dp ml lq mm mn mo lu mp mq mr ly ms mt mu jp bi translated"><strong class="ak">关于作者</strong></h2><p id="a61d" class="pw-post-body-paragraph lh li jj lj b lk mv kt lm ln mw kw lp lq mx ls lt lu my lw lx ly mz ma mb mc im bi translated">Wie Kiang 是一名研究员，负责收集、组织和分析意见和数据，以解决问题、探索问题和预测趋势。</p><p id="8922" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">他几乎在机器学习和深度学习的每个领域工作。他正在一系列领域进行实验和研究，包括卷积神经网络、自然语言处理和递归神经网络。</p><p id="f1ed" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><em class="pb">连接上</em><a class="ae jg" href="https://linkedin.com/in/wiekiang" rel="noopener ugc nofollow" target="_blank"><em class="pb">LinkedIn</em></a></p></div></div>    
</body>
</html>