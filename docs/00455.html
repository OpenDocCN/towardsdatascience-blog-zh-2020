<html>
<head>
<title>Hands-on Web Scraping: Building your Twitter dataset with python and scrapy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">动手抓取网页:用python和scrapy构建你的Twitter数据集</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/hands-on-web-scraping-building-your-own-twitter-dataset-with-python-and-scrapy-8823fb7d0598?source=collection_archive---------1-----------------------#2020-01-14">https://towardsdatascience.com/hands-on-web-scraping-building-your-own-twitter-dataset-with-python-and-scrapy-8823fb7d0598?source=collection_archive---------1-----------------------#2020-01-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="9c11" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi ko translated">我明白了——你厌倦了为你的机器学习项目在网上搜索数据集，或者可能是为了分析流行的Twitter趋势。</p><p id="ac90" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">今天我们将学习如何使用hashtag搜索从Twitter生成您自己的自定义数据集。据internetlivestats.com的<a class="ae kx" href="https://www.internetlivestats.com/twitter-statistics/" rel="noopener ugc nofollow" target="_blank">报道，平均每秒钟，大约有6000条推文被发布，相当于每分钟超过35万条推文，每天有5亿条推文。这使得Twitter成为一个为您的项目获取数据的绝佳场所，因为Tweets是当今社交媒体上自然语言的准确表达。</a></p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi ky"><img src="../Images/e3dbc4caa719eeba7de5451aa157cf2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fOBdIaCCmA1tsatOp1A2VA.png"/></div></div></figure><p id="82dc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">想跳过帖子直接看好东西？这是给你的<a class="ae kx" href="https://github.com/amitupreti/Hands-on-WebScraping/tree/master/project1_twitter_hashtag_crawler" rel="noopener ugc nofollow" target="_blank"> Github回购</a></p></div><div class="ab cl lk ll hx lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="im in io ip iq"><h2 id="bcfe" class="lr ls it bd lt lu lv dn lw lx ly dp lz kb ma mb mc kf md me mf kj mg mh mi mj bi translated">了解机器人的Twitter政策</h2><p id="3ff4" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">首先，让我们确保遵守twitter.com为机器人爬行制定的政策，这样我们就不会遇到任何法律问题。这可以在<a class="ae kx" href="https://twitter.com/robots.txt" rel="noopener ugc nofollow" target="_blank">https://twitter.com/robots.txt</a>找到</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi mp"><img src="../Images/8c75e402d4e54c6b27d8970ce6ab08e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m3O-Y1hmPmgdwbNmD6pvPQ.png"/></div></div><p class="mq mr gj gh gi ms mt bd b be z dk translated">面向所有用户代理的robots.txt for twitter</p></figure><p id="df4e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以从User-agent和Allow部分(第1-4行)看到，Twitter允许所有的机器人访问标签和搜索URL，在抓取请求之间有1秒钟的延迟。</p><pre class="kz la lb lc gt mu mv mw mx aw my bi"><span id="fa53" class="lr ls it mv b gy mz na l nb nc">User-agent: *<br/>Allow: /hashtag/*?src=<br/>Crawl-delay: 1</span></pre></div><div class="ab cl lk ll hx lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="im in io ip iq"><h1 id="459b" class="nd ls it bd lt ne nf ng lw nh ni nj lz nk nl nm mc nn no np mf nq nr ns mi nt bi translated">我们如何刮推特？让我们看一下代码。</h1><p id="3948" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated"><em class="nu">这里假设你有一些python和scrapy的基础知识。如果您只对生成数据集感兴趣，请跳过这一部分，转到</em><a class="ae kx" href="https://github.com/amitupreti/Hands-on-WebScraping/tree/master/project1_twitter_hashtag_crawler" rel="noopener ugc nofollow" target="_blank"><em class="nu">GitHub repo</em></a><em class="nu">上的样本抓取部分。</em></p><h2 id="0bd5" class="lr ls it bd lt lu lv dn lw lx ly dp lz kb ma mb mc kf md me mf kj mg mh mi mj bi translated">通过搜索标签收集tweets URL</h2><p id="d04a" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">为了搜索推文，我们将使用传统的Twitter网站。让我们试着搜索#猫<a class="ae kx" href="https://mobile.twitter.com/hashtag/cats" rel="noopener ugc nofollow" target="_blank">https://mobile.twitter.com/hashtag/cats</a>。我们希望使用这个遗留版本来收集tweets URLs，因为它加载数据而不使用javascript，这使得我们的工作非常容易。</p><blockquote class="nv"><p id="0493" class="nw nx it bd ny nz oa ob oc od oe kn dk translated">我选择一个懒惰的人去做艰苦的工作。因为一个懒惰的人会找到一个简单的方法去做。</p><p id="1511" class="nw nx it bd ny nz oa ob oc od oe kn dk translated">―比尔·盖茨</p></blockquote><figure class="og oh oi oj ok ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi of"><img src="../Images/155277f72c1fe1f9dbdff5db694cdab0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tBYwszcGzOckuEJGxydNrg.png"/></div></div><p class="mq mr gj gh gi ms mt bd b be z dk translated">twitter的传统版本</p></figure><p id="15d1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">查找我们标签搜索的所有tweet URL—</strong><em class="nu">find _ tweets()函数</em></p><p id="936b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">scrapy爬虫的find_tweets功能</p><p id="9512" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">解释</strong>:我们将使用<a class="ae kx" href="https://www.tutorialspoint.com/xpath/index.htm" rel="noopener ugc nofollow" target="_blank">XPath</a>找到当前页面中的所有tweets URL，并抓取这些URL，然后将响应发送给我们的第二个函数<code class="fe ol om on mv b">parse_tweet ()</code></p><pre class="kz la lb lc gt mu mv mw mx aw my bi"><span id="0a86" class="lr ls it mv b gy mz na l nb nc">tweets = response.xpath('//table[@class="tweet  "]/@href').getall()    logging.info(f'{len(tweets)} tweets found')    <br/>for tweet_id in tweets:        <br/>    tweet_id = re.findall("\d+", tweet_id)[-1]        <br/>    tweet_url = 'https://twitter.com/anyuser/status/'+str(tweet_id)           <br/>    yield scrapy.Request(tweet_url, callback=self.parse_tweet)</span></pre><p id="cbc4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们将找到<code class="fe ol om on mv b"><strong class="js iu">Load older Tweets</strong></code>按钮的下一个URL，抓取它并将响应发送给我们当前的<code class="fe ol om on mv b">find_tweets()</code>函数。这样，我们的爬虫将不断递归地点击<code class="fe ol om on mv b"><strong class="js iu">Load older Tweet</strong></code>按钮，如果它在每次爬行时可用的话。这意味着我们将逐一访问所有结果页面。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi oo"><img src="../Images/2ba2c33799933d9fab8e605cfcdbc632.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j3k98Gglaa6w37qCCQ3W0A.png"/></div></div><p class="mq mr gj gh gi ms mt bd b be z dk translated">加载旧推文</p></figure><pre class="kz la lb lc gt mu mv mw mx aw my bi"><span id="cabe" class="lr ls it mv b gy mz na l nb nc">next_page = response.xpath(<br/>    '//*[@class="w-button-more"]/a/@href').get(default='')<br/>logging.info('Next page found:')<br/>if next_page != '':<br/>    next_page = 'https://mobile.twitter.com' + next_page<br/>    yield scrapy.Request(next_page, callback=self.find_tweets)</span></pre><p id="75a8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">从单个tweet中查找所有数据— <em class="nu"> parse_tweet()函数</em> </strong></p><p id="5c14" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">解释</strong>:在这里，我们将使用Twitter的当前版本(示例:<a class="ae kx" href="https://twitter.com/catsfootprint/status/1213603795663491075?p=v" rel="noopener ugc nofollow" target="_blank">https://Twitter . com/catsfootprint/status/1213603795663491075</a>)，因为当前版本加载了所有数据，如赞数、转发数、评论数和其他元数据。下面是在旧版和当前版本的twitter中加载上述tweet的比较。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi op"><img src="../Images/07948cf8ece40153e22f274846468b59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0fCB9R22JLc4vyrh-ex7nQ.png"/></div></div></figure><p id="1802" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">parse tweet()函数</p><h1 id="339d" class="nd ls it bd lt ne oq ng lw nh or nj lz nk os nm mc nn ot np mf nq ou ns mi nt bi translated">让我们来看看数据集。</h1><p id="13d4" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">我们的数据集将由14列组成，其中包含了几乎所有可以从tweet中抓取的数据。目前爬虫不收集评论。数据集还将包括列<code class="fe ol om on mv b">hashtags</code>和<code class="fe ol om on mv b">mentions</code>，这是通过解析tweet文本并搜索开头带有#的单词(用于查找标签)和开头带有@的单词(用于查找提及)获得的。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi ov"><img src="../Images/a80db54b490c6975049d2c8643377737.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HpnMdsrNYSKpKR2xyGEMZw.png"/></div></div><p class="mq mr gj gh gi ms mt bd b be z dk translated">示例数据截图CSV</p></figure><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi ow"><img src="../Images/d55c27799e4eea87745063b1d3136773.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PIWrooxANdRyiY3YTEq9ag.png"/></div></div><p class="mq mr gj gh gi ms mt bd b be z dk translated">示例twitter数据JSON</p></figure><h2 id="36a8" class="lr ls it bd lt lu lv dn lw lx ly dp lz kb ma mb mc kf md me mf kj mg mh mi mj bi translated">您可以在哪里使用这些数据？</h2><p id="a3af" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">您可能希望通过以下几种方式使用该数据集:</p><ul class=""><li id="cee6" class="ox oy it js b jt ju jx jy kb oz kf pa kj pb kn pc pd pe pf bi translated">流行twitter趋势的情感分析</li><li id="381e" class="ox oy it js b jt pg jx ph kb pi kf pj kj pk kn pc pd pe pf bi translated">竞争对手分析(例如，人们可以找到并分析竞争对手的推文)</li><li id="2b1c" class="ox oy it js b jt pg jx ph kb pi kf pj kj pk kn pc pd pe pf bi translated">通过标签建立你的推文数据库</li><li id="2fce" class="ox oy it js b jt pg jx ph kb pi kf pj kj pk kn pc pd pe pf bi translated">分析一个流行趋势。例如，人们可以使用#globalwarmingto查找和分析推文，以了解人们的意见。</li></ul><h2 id="9cf5" class="lr ls it bd lt lu lv dn lw lx ly dp lz kb ma mb mc kf md me mf kj mg mh mi mj bi translated">结论</h2><p id="bb93" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">目前，我们可以看到Twitter允许抓取其内容搜索结果，即推文和标签，并且对我们可以抓取的页面数量没有限制。因此，我们的爬行器不受任何速率限制的影响，我们能够使用这个简单的脚本，使用标签和tweet搜索方法来爬行数百万条tweet。为了收集大量的推文，我建议你使用数百个标签，并在VPS服务器或<a class="ae kx" href="https://scrapinghub.com/scrapy-cloud" rel="noopener ugc nofollow" target="_blank">垃圾云</a>上运行爬虫，以避免任何形式的中断。</p><p id="0a5d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你有建议或发现一些问题。欢迎您在GitHub上<a class="ae kx" href="https://github.com/amitupreti/Hands-on-WebScraping/issues/new" rel="noopener ugc nofollow" target="_blank">开问题</a>或<a class="ae kx" href="https://github.com/amitupreti/Hands-on-WebScraping/compare" rel="noopener ugc nofollow" target="_blank">拉请求</a>。</p><p id="6361" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">爬行愉快。</p><h1 id="7d50" class="nd ls it bd lt ne oq ng lw nh or nj lz nk os nm mc nn ot np mf nq ou ns mi nt bi translated">你真棒</h1></div></div>    
</body>
</html>