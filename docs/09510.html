<html>
<head>
<title>Deploying an Image Classification Web App with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Python 部署影像分类 Web 应用程序</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/deploying-an-image-classification-web-app-with-python-3753c46bb79?source=collection_archive---------7-----------------------#2020-07-07">https://towardsdatascience.com/deploying-an-image-classification-web-app-with-python-3753c46bb79?source=collection_archive---------7-----------------------#2020-07-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0bfe" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何使用 Streamlit 和 Heroku 部署您的机器学习模型</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f8f8355a58a490ad1339a64f391fee7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HYAd1aal5Et1A-Qzs6VAtQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:<a class="ae ky" href="https://unsplash.com/photos/Q1p7bh3SHj8" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="4e2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">毫无疑问，做一个数据科学和机器学习项目，从收集数据开始，处理数据，可视化关于数据的见解，并开发一个机器学习模型来完成预测任务，是一件有趣的事情。更有趣和可行的是，我们可以在本地机器上完成所有这些步骤，然后就可以完成了。</p><p id="f247" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，如果其他人可以利用我们的机器学习模型来做有趣和酷的事情，这不是很棒吗？当我们的模型可以进入其他人的手中，他们可以从中做有用的东西时，机器学习的真正魔力就来了。</p><p id="66da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建一个 web 应用程序是解决方案之一，这样其他人就可以利用我们的机器学习模型。幸运的是，现在创建一个 web 应用程序非常简单。</p><p id="6ec3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您正在使用 Python，您可以使用 Streamlit 库在本地机器上创建一个简单的机器学习 web 应用程序。要部署 web 应用程序，使其可供其他人访问，那么我们可以使用 Heroku 或其他云平台。在本文中，我将一步一步向您展示如何使用 Python、Streamlit 和 Heroku 创建自己的简单图像分类 web 应用程序。</p><p id="6852" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您还没有安装 Streamlit，您可以通过在提示符下运行以下 pip 命令来安装它。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="9b9c" class="ma mb it lw b gy mc md l me mf">pip install streamlit</span></pre><h1 id="9a18" class="mg mb it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">图像分类数据</h1><p id="dec3" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">对于这个图像分类示例，将使用 Laurence Moroney 创建的石头-纸-剪刀数据集。你可以在他的<a class="ae ky" href="http://www.laurencemoroney.com/rock-paper-scissors-dataset/" rel="noopener ugc nofollow" target="_blank">网站</a>上下载数据。总之，石头-纸-剪刀是一个合成的数据集，它包含人们形成石头、纸或剪刀形状的手。总共有 2520 幅训练图像和 372 幅测试图像。</p><p id="cec1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是合成图像数据的预览图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/5460ebf81fe545e3e2a5cde55ffaefbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*TXHUg1FvbEjXPGUW.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">先睹为快<a class="ae ky" href="http://laurencemoroney.com/rock-paper-scissors-dataset" rel="noopener ugc nofollow" target="_blank">石头剪刀布数据集</a>的训练图像</p></figure><p id="9f66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总的来说，本文将涵盖三个步骤:</p><ul class=""><li id="77ec" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">创建第一个 Python 文件来加载数据、构建模型并最终训练模型。</li><li id="bf72" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">创建第二个 Python 文件来加载模型和构建 web 应用程序。</li><li id="ad4c" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">使用 Heroku 部署 web 应用程序。</li></ul></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><h1 id="3bb8" class="mg mb it bd mh mi ny mk ml mm nz mo mp jz oa ka mr kc ob kd mt kf oc kg mv mw bi translated">加载数据、构建模型和训练模型</h1><p id="87f9" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">首先，下载训练集和测试集，并将其保存到您选择的目录中。接下来，您需要解压缩它们。将有两个文件夹，一个称为<em class="od">‘RPS’</em>用于训练图像，另一个称为<em class="od">‘RPS-test-set’</em>用于测试图像。之后创建一个名为<code class="fe oe of og lw b">rps_model.py</code>的 Python 文件来加载数据，建立机器学习模型，训练模型。</p><h1 id="a0a2" class="mg mb it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">加载数据</h1><p id="c525" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">在构建模型之前，您需要首先使用<code class="fe oe of og lw b">os</code>库指定本地机器中训练集文件夹和测试集文件夹的路径。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="a978" class="ma mb it lw b gy mc md l me mf">import os</span><span id="75e4" class="ma mb it lw b gy oh md l me mf">train_dir = os.path.join('directory/to/your/rps/')<br/>test_dir = os.path.join('directory/to/your/rps-test-set/')</span></pre><p id="4307" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们可以使用 TensorFlow 库中的图像生成器来生成训练集和测试集，并自动标记数据。使用 image generator 的另一个优点是，我们可以“即时”进行数据扩充，通过缩放、旋转或移动训练图像来增加训练集的数量。此外，我们可以将训练集的某一部分拆分为验证集，以比较模型的性能。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="b45e" class="ma mb it lw b gy mc md l me mf">from tensorflow.keras.preprocessing.image import ImageDataGenerator</span><span id="143c" class="ma mb it lw b gy oh md l me mf"><br/>def image_gen_w_aug(train_parent_directory, test_parent_directory):<br/>    <br/>    train_datagen = ImageDataGenerator(rescale=1/255,<br/>                                      rotation_range = 30,  <br/>                                      zoom_range = 0.2, <br/>                                      width_shift_range=0.1,  <br/>                                      height_shift_range=0.1,<br/>                                      validation_split = 0.15)<br/>    <br/>  <br/>    <br/>    test_datagen = ImageDataGenerator(rescale=1/255)<br/>    <br/>    train_generator =          train_datagen.flow_from_directory(train_parent_directory,<br/>                                  target_size = (75,75),<br/>                                  batch_size = 214,<br/>                                  class_mode = 'categorical',<br/>                                  subset='training')<br/>    <br/>    val_generator = train_datagen.flow_from_directory(train_parent_directory,<br/>                                  target_size = (75,75),<br/>                                  batch_size = 37,<br/>                                  class_mode = 'categorical',<br/>                                  subset = 'validation')<br/>    <br/>    test_generator = test_datagen.flow_from_directory(test_parent_directory,<br/>                                 target_size=(75,75),<br/>                                 batch_size = 37,<br/>                                 class_mode = 'categorical')</span><span id="6509" class="ma mb it lw b gy oh md l me mf">    return train_generator, val_generator, test_generator</span></pre><p id="2538" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在创建了上面的函数之后，现在您可以调用该函数，并使用您之前定义的<code class="fe oe of og lw b">train_dir</code>和<code class="fe oe of og lw b">test_dir</code>变量传递参数。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="9947" class="ma mb it lw b gy mc md l me mf">train_generator, validation_generator, test_generator = image_gen_w_aug(train_dir, test_dir)</span></pre><p id="4f33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而到了这一步，就已经加载好数据了！</p></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><h1 id="21a8" class="mg mb it bd mh mi ny mk ml mm nz mo mp jz oa ka mr kc ob kd mt kf oc kg mv mw bi translated">建立机器学习模型</h1><p id="774c" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">作为一个机器学习模型，如果你愿意，你可以建立自己的 CNN 模型。但在本文中，迁移学习法将被应用。使用来自 ImageNet 的具有预训练权重的 InceptionV3 模型。</p><p id="8743" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，由于这个模型非常深，所以使用的模型将一直到称为<code class="fe oe of og lw b">mixed_5</code>的层，并且直到这一层的所有权重都是固定的，以加快训练时间。从该图层开始，模型将被展平以连接到密集图层，然后连接到最终的密集输出。<code class="fe oe of og lw b">mixed_5 </code>之后的所有重量都是可训练的。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="a873" class="ma mb it lw b gy mc md l me mf">from tensorflow.keras.applications.inception_v3 import InceptionV3<br/>from tensorflow.keras.layers import Flatten, Dense, Dropout</span><span id="8289" class="ma mb it lw b gy oh md l me mf">def model_output_for_TL (pre_trained_model, last_output):    </span><span id="3cae" class="ma mb it lw b gy oh md l me mf">    x = Flatten()(last_output)<br/>    <br/>    # Dense hidden layer<br/>    x = Dense(512, activation='relu')(x)<br/>    x = Dropout(0.2)(x)<br/>    <br/>    # Output neuron. <br/>    x = Dense(3, activation='softmax')(x)<br/>    <br/>    model = Model(pre_trained_model.input, x)<br/>    <br/>    return model</span><span id="f1fb" class="ma mb it lw b gy oh md l me mf">pre_trained_model = InceptionV3(input_shape = (75, 75, 3), <br/>                                include_top = False, <br/>                                weights = 'imagenet')</span><span id="b65c" class="ma mb it lw b gy oh md l me mf">for layer in pre_trained_model.layers:<br/>  layer.trainable = False</span><span id="0b87" class="ma mb it lw b gy oh md l me mf">last_layer = pre_trained_model.get_layer('mixed5')<br/>last_output = last_layer.output<br/>model_TL = model_output_for_TL(pre_trained_model, last_output)</span></pre><p id="1dc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="od">如果您还没有导入 InceptionV3 模型，下载该模型需要几分钟时间。</em>T13】</strong></p><p id="2700" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这一步，您已经建立了模型！接下来，我们需要训练模型。</p></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><h1 id="87ff" class="mg mb it bd mh mi ny mk ml mm nz mo mp jz oa ka mr kc ob kd mt kf oc kg mv mw bi translated">训练并保存机器学习模型</h1><p id="4f15" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">现在是我们训练模型的时候了。在训练模型之前，首先需要编译模型。在本文中，优化器将是 Adam，因为我们有一个分类问题，那么我们应该使用分类交叉熵作为损失。对于指标，我们将使用准确性。</p><p id="71c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编译完模型后，现在我们可以训练模型了。模型训练完成后，我们需要保存训练好的模型。然后，在与 Python 文件相同的目录中，您应该有一个名为“my_model.hdf5”的新 hdf5 文件。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="58af" class="ma mb it lw b gy mc md l me mf">model_TL.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])</span><span id="0f2e" class="ma mb it lw b gy oh md l me mf">history_TL = model_TL.fit(<br/>      train_generator,<br/>      steps_per_epoch=10,  <br/>      epochs=20,<br/>      verbose=1,<br/>      validation_data = validation_generator)</span><span id="ea8a" class="ma mb it lw b gy oh md l me mf">tf.keras.models.save_model(model_TL,'my_model.hdf5')</span></pre><p id="c74f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你已经完成了建模过程。您可以保存并关闭 Python 文件。</p></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><h1 id="505b" class="mg mb it bd mh mi ny mk ml mm nz mo mp jz oa ka mr kc ob kd mt kf oc kg mv mw bi translated">创建 Streamlit Web 应用程序</h1><p id="6119" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">要用 Streamlit 创建一个 web 应用程序，我们需要做的第一件事是创建一个新的 Python 文件，姑且称之为<code class="fe oe of og lw b">rps_app.py</code>。在这个 Python 文件中，首先我们需要加载之前保存的训练模型。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="b18a" class="ma mb it lw b gy mc md l me mf">import tensorflow as tf</span><span id="9e95" class="ma mb it lw b gy oh md l me mf">model = tf.keras.models.load_model('my_model.hdf5')</span></pre><p id="9cc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一步是编写一个标题和任何其他你想放入你的 web 应用程序的文本。要写标题，只需使用 Streamlit 的<code class="fe oe of og lw b">write</code>属性，然后在文本前加上<code class="fe oe of og lw b">#</code>。要写一个简单的文本，我们也可以使用<code class="fe oe of og lw b">write</code>的方法，然后在不添加<code class="fe oe of og lw b">#</code>的情况下继续你的文本</p><p id="3053" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要让用户将自己的图像上传到您的 web 应用程序，只需使用 Streamlit 库中的<code class="fe oe of og lw b">file_uploader</code>属性。有关 Streamlit 上其他可用选项的更多详细信息，您可以在<a class="ae ky" href="https://docs.streamlit.io/en/stable/api.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> Streamlit API 文档页面</strong> </a>查看。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="4c87" class="ma mb it lw b gy mc md l me mf">import streamlit as st</span><span id="ebcd" class="ma mb it lw b gy oh md l me mf">st.write("""<br/>         # Rock-Paper-Scissor Hand Sign Prediction<br/>         """<br/>         )</span><span id="d091" class="ma mb it lw b gy oh md l me mf">st.write("This is a simple image classification web app to predict rock-paper-scissor hand sign")</span><span id="5db2" class="ma mb it lw b gy oh md l me mf">file = st.file_uploader("Please upload an image file", type=["jpg", "png"])</span></pre><p id="3618" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一个重要步骤是处理用户上传的图像。该处理步骤包括将图像调整到与训练和验证图像相同的大小。调整图像大小后，加载的模型应该预测该图像属于哪个类别。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="016f" class="ma mb it lw b gy mc md l me mf">import cv2<br/>from PIL import Image, ImageOps<br/>import numpy as np</span><span id="485f" class="ma mb it lw b gy oh md l me mf">def import_and_predict(image_data, model):<br/>    <br/>        size = (150,150)    <br/>        image = ImageOps.fit(image_data, size, Image.ANTIALIAS)<br/>        image = np.asarray(image)<br/>        img = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)<br/>        img_resize = (cv2.resize(img, dsize=(75, 75),    interpolation=cv2.INTER_CUBIC))/255.<br/>        <br/>        img_reshape = img_resize[np.newaxis,...]<br/>    <br/>        prediction = model.predict(img_reshape)<br/>        <br/>        return prediction</span><span id="8f27" class="ma mb it lw b gy oh md l me mf">if file is None:<br/>    st.text("Please upload an image file")<br/>else:<br/>    image = Image.open(file)<br/>    st.image(image, use_column_width=True)<br/>    prediction = import_and_predict(image, model)<br/>    <br/>    if np.argmax(prediction) == 0:<br/>        st.write("It is a paper!")<br/>    elif np.argmax(prediction) == 1:<br/>        st.write("It is a rock!")<br/>    else:<br/>        st.write("It is a scissor!")<br/>    <br/>    st.text("Probability (0: Paper, 1: Rock, 2: Scissor")<br/>    st.write(prediction)</span></pre><p id="a430" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后，您需要将 Python 文件保存在与之前的 Python 文件相同的目录中。</p><p id="8267" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在基本上都准备好了！要检查我们的 web 应用程序的外观，请打开提示符，然后导航到 Python 文件的工作目录。在工作目录中，您可以键入以下命令:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="c012" class="ma mb it lw b gy mc md l me mf">streamlit run rps_app.py</span></pre><p id="19cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您将从提示中看到，您可以在本地主机上检查您的 web 应用程序。如果你再等一会儿，在你运行你的 Streamlit 应用程序后，一个新的窗口将会马上打开。下面是简单图像分类 web app 的截图。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/6d0e9c05d5eb05146414ab5cfb4c56be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jF29i4nVxf30w-9T.png"/></div></div></figure></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><h1 id="8bd4" class="mg mb it bd mh mi ny mk ml mm nz mo mp jz oa ka mr kc ob kd mt kf oc kg mv mw bi translated">使用 Heroku 部署您的 Web 应用程序</h1><p id="875d" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">到目前为止，您已经在本地计算机上构建了 web 应用程序。为了让其他人能够使用你的网络应用，你可以使用 Heroku。</p><h2 id="b596" class="ma mb it bd mh oj ok dn ml ol om dp mp li on oo mr lm op oq mt lq or os mv ot bi translated">用于部署的附加文件</h2><p id="cb16" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">在部署 web 应用程序之前，除了我们为构建应用程序而创建的 Python 文件之外，我们还需要创建另外三个文件。这三个文件是:</p><ul class=""><li id="543d" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated"><strong class="lb iu"> requirements.txt: </strong>这是我们需要创建的文本文件，用来告诉 Heroku 安装部署我们的机器学习模型所需的必要 Python 包。在本教程中，我们使用了四个 Python 库来构建应用程序:numpy、streamlit、tensorflow 和 pillow。因此，我们需要在这个文本文件中指定这些库的相关版本。</li></ul><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="b3b9" class="ma mb it lw b gy mc md l me mf">tensorflow==2.0.0<br/>streamlit==0.62.0<br/>numpy==1.16.5<br/>pillow==6.2.0</span></pre><p id="0c14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="od">如果您不确定您正在使用的 Python 库的版本，您可以在您的 Python 环境中使用'</em><strong class="lb iu"><em class="od">_ _ version _ _ '</em></strong><em class="od">属性，或者在 conda 提示符中键入'</em><strong class="lb iu"><em class="od">conda list '</em></strong><em class="od">。</em></p><ul class=""><li id="0d50" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated"><strong class="lb iu"> setup.sh: </strong>这个文件是处理我们在 Heroku 上的应用的服务器和端口号所必需的。</li></ul><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="686c" class="ma mb it lw b gy mc md l me mf">mkdir -p ~/.streamlit/                                               echo "\                       <br/>[server]\n\                       <br/>port = $PORT\n\                       <br/>enableCORS = false\n\                       <br/>headless = true\n\                       <br/>\n\                       <br/>" &gt; ~/.streamlit/config.toml</span></pre><ul class=""><li id="7e86" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">Procfile: 这是你的配置文件，用来告诉 Heroku 如何以及执行哪些文件。</li></ul><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="3d77" class="ma mb it lw b gy mc md l me mf">web: sh setup.sh &amp;&amp; streamlit run rps_app.py</span></pre><p id="7660" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在已经有了这三个文件，将它们放在与 Python 文件相同的目录中。</p><p id="bc15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们跳到 Heroku。</p><h2 id="6dd9" class="ma mb it bd mh oj ok dn ml ol om dp mp li on oo mr lm op oq mt lq or os mv ot bi translated">创建您的 Heroku 帐户</h2><p id="13ac" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">如果你已经有了 Heroku 账号，可以跳过这一步。如果你还没有，那么你可以直接去<a class="ae ky" href="https://www.heroku.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> Heroku </strong> </a>。在那里你会发现一个“<em class="od">注册”</em>按钮，点击该按钮并填写必要的信息。之后，你需要用你的电子邮件确认你的新 Heroku 账户。</p><h2 id="93db" class="ma mb it bd mh oj ok dn ml ol om dp mp li on oo mr lm op oq mt lq or os mv ot bi translated">用 Heroku Git 部署您的 ML 模型</h2><p id="2902" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">创建好 Heroku 账号后，接下来需要做的事情就是安装<a class="ae ky" href="https://devcenter.heroku.com/articles/heroku-cli" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> Heroku CLI </strong> </a>(命令行界面)。接下来，打开命令提示符，键入以下命令。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="678b" class="ma mb it lw b gy mc md l me mf">heroku login</span></pre><p id="076c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该命令将引导您使用 Heroku 帐户登录。</p><p id="2d54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，使用命令提示符移动到应用程序文件的目录。在应用程序文件的目录中，键入以下命令。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="8c06" class="ma mb it lw b gy mc md l me mf">heroku create your_app_name</span></pre><p id="3843" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以根据自己的喜好更改<code class="fe oe of og lw b">your_app_name</code>作为应用名称。接下来，您需要通过键入以下命令来启动一个空的 git 存储库。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="39ee" class="ma mb it lw b gy mc md l me mf">git init</span></pre><p id="ffe7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，您希望将所有应用程序文件提交到刚刚创建的空存储库中。为此，您可以键入<code class="fe oe of og lw b">git add .</code>命令，然后您需要通过键入<code class="fe oe of og lw b">commit</code>和<code class="fe oe of og lw b">push</code>命令来推送它们，如下所示。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="b850" class="ma mb it lw b gy mc md l me mf">git add .<br/>git commit -m "your message"<br/>git push heroku master</span></pre><p id="948b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您的应用程序文件将通过 Heroku Git 部署到 Heroku，在该过程完成后，您将看到您的 web 应用程序的 URL，可以通过互联网访问。您的 web 应用程序 URL 的格式类似于<em class="od">your _ app _ name . heroku app . com .</em></p><p id="fe48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个用 Heroku 部署的简单 web 应用程序的例子。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/203883087c0ce1a474191c6cb0ed01d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1394/format:webp/0*eDZui9SY_T4UKPf6.png"/></div></figure><p id="400f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样！您的影像分类 web 应用程序已部署！</p><p id="1ecc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果想看本教程中 web app 的代码或者其他必要的文件，可以在我的<a class="ae ky" href="https://github.com/marcellusruben/rock_paper_scissor_web_app" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> GitHub </strong> </a>上看到。</p></div></div>    
</body>
</html>