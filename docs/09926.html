<html>
<head>
<title>3 Smooth Syntactical Tips For Julia</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">给 Julia 的 3 个流畅的语法技巧</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/3-smooth-syntactical-tips-for-julia-65ddf577f071?source=collection_archive---------61-----------------------#2020-07-13">https://towardsdatascience.com/3-smooth-syntactical-tips-for-julia-65ddf577f071?source=collection_archive---------61-----------------------#2020-07-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0d9d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用这些令人兴奋的技巧最大化你的语法！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f4f0bcd6267a9fdbdf93855309803257.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3mXC1DMu4w19-PpO5OhQiQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(茱莉亚标志由 http://julialang.org/提供)</p></figure><p id="08cc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">伟大的代码编写艺术，尤其是像 Python 和 Julia 这样的高级语言，是一种相当容易学习的东西——但却难以掌握。即使非常熟练的程序员也有可能在他们的语法中犯看似基本的错误。然而，拥有清晰简洁的代码不仅在可读性标准上很重要，而且在做错的时候也会产生非常严重的影响。学习一些伟大的技术和快捷方式来执行操作，这绝对是一个让你的代码发光并让你的同事喜欢你的绝妙方法。幸运的是，有成千上万的小技巧可以用来增强你的代码。</p><blockquote class="lu"><p id="d3ff" class="lv lw it bd lx ly lz ma mb mc md lt dk translated"><a class="ae me" href="https://github.com/emmettgb/Emmetts-DS-NoteBooks/blob/master/Julia/3%20Tips%20for%20better%20Syntax.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a></p></blockquote></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="81a8" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">№1:布尔逆</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/cf1932c8cc4559f66449feecd90f0ffe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*-K80dgjLs6_JZ4aN0xBJag.png"/></div></figure><p id="9b0b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们来看看下面的场景:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="fbf6" class="nk mn it ng b gy nl nm l nn no">mutable struct light<br/>   status<br/>end<br/>function turn_on(light)<br/>    light.status = true<br/>    return(light)<br/>end<br/>function turn_off(light)<br/>    light.status = false<br/>    return(light)<br/>end</span></pre><p id="2fa1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个例子中，我们可以使用 turn_on 和 turn_off 方法打开或关闭灯光。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/bcf5d85a5d3fab1391ce2048d675d22d.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*hSPhHr5E6WYBsnLnjgdVzA.png"/></div></figure><blockquote class="lu"><p id="0840" class="lv lw it bd lx ly nq nr ns nt nu lt dk translated">如果我们想把两者结合成一个功能呢？</p></blockquote><p id="ef6d" class="pw-post-body-paragraph ky kz it la b lb nv ju ld le nw jx lg lh nx lj lk ll ny ln lo lp nz lr ls lt im bi translated">对于条件语句来说，这是一项显而易见的工作，许多程序员会这样处理这个问题:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="1ecd" class="nk mn it ng b gy nl nm l nn no">function use_switch(light)<br/>    if light.status == true<br/>        light.status = false<br/>    else<br/>        light.status = true<br/>    end<br/>end</span></pre><p id="fc46" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，我们检查灯光是否设置为 true。这将首先需要来自处理器的 MOV 指令，其中由变量 light.status 表示的数据将被移动到注册表核心中进行比较。接下来，还需要将 true 移动到注册表核心中。然后，将执行一个 CMP 指令来比较这两个值，这将改变一个标志—(但在这种情况下，他们可能会使用 JNE 条件转移来代替。)</p><p id="08bf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，计算机需要将我们的 false 移动到当前保存 light.status 变量数据的内存中。如果我们的标志从未被更改，那么下面将有一个部分，它将在代表 light.status 变量的地址处移入我们的内存。</p><p id="d164" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，如果 light.status 为真，这个条件语句至少需要 4 条指令。如果是假的，最少需要 6 个指令。幸运的是，在 Julia 中，我们有一个用于反转 bool 类型的操作符。为了在 Julia 中这样做，我们可以使用=！。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="6e0a" class="nk mn it ng b gy nl nm l nn no">function use_efficient_switch(light)<br/>    light.status =! light.status<br/>    return(light)<br/>end</span></pre><p id="dccb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在让我们建立一个小的性能测试，并测量这两种方法之间的差异。我构造了两个函数在 for 循环中调用这些不同的方法。然后我用@time 宏运行这两个函数，看看这个小小的改进会带来什么样的不同。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="e352" class="nk mn it ng b gy nl nm l nn no">function flick(bulb, iters)<br/>    for i in 1:iters<br/>        use_switch(bulb)<br/>    end<br/>end<br/>function flickeff(bulb, iters)<br/>    for i in 1:iters<br/>        use_efficient_switch(bulb)<br/>    end<br/>end</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/7b2d1edb82d84810fb183114d37a5dab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/format:webp/1*lOJf102k2acTplHn9rr79g.png"/></div></figure><blockquote class="lu"><p id="f693" class="lv lw it bd lx ly nq nr ns nt nu lt dk translated">显然好多了</p></blockquote><p id="b3d1" class="pw-post-body-paragraph ky kz it la b lb nv ju ld le nw jx lg lh nx lj lk ll ny ln lo lp nz lr ls lt im bi translated">由于需要移动到内存中的值更少了，我们浪费的时间更少了，甚至减少了分配。不仅如此，还有这个:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/85c5c5ec5d61d4bd90bfd667f3b57c77.png" data-original-src="https://miro.medium.com/v2/resize:fit:662/format:webp/1*GBcph3Bsqvpnw1CYj4evHQ.png"/></div></figure><p id="b255" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">看起来比这好多了:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/98fd8abdf1d6ca6182da22149ed74fe6.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*0rolixMv5zyM_rulFXgAjA.png"/></div></figure></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="b5d7" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">№2:调度一切！</h1><p id="497c" class="pw-post-body-paragraph ky kz it la b lb od ju ld le oe jx lg lh of lj lk ll og ln lo lp oh lr ls lt im bi translated">如果您是 Julia 的新手，您可能会很高兴了解到该语言有一个多态分派，允许您基于某些标准(如类型或值)来路由方法。下面是调度用法的一个基本示例:</p><p id="24fd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从两个函数开始，在这个例子中，我们想要打印一个数组的每个元素，或者打印一个整数。下面是实现这一目的的两个函数:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="143e" class="nk mn it ng b gy nl nm l nn no">function handle_array(arr)<br/>    [println(i) for i in arr]<br/>end<br/>function handle_int(int)<br/>    println(int)<br/>end</span></pre><p id="5bf5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">需要明确的是，迭代地执行 println()和在一行上打印数组是有区别的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/f86e506ec7feb6481af9bb83c9e58d22.png" data-original-src="https://miro.medium.com/v2/resize:fit:710/format:webp/1*hNdY-BUWdDr_X5I-weWSxw.png"/></div></figure><p id="1f19" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们还从 for 循环中得到一个有趣的三元素 nothing 返回。如果您想取消它，您总是可以添加一个；到循环的终点。我们可以将这些合并到一个函数中，通过使用 Julia 的调度来处理这两种类型，如下所示。为此，我们只需使用=运算符。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="c99e" class="nk mn it ng b gy nl nm l nn no">inlineprint(arr::Array) = handle_array(arr)<br/>inlineprint(arr::Int64) = handle_int(arr)</span></pre><blockquote class="lu"><p id="07d7" class="lv lw it bd lx ly nq nr ns nt nu lt dk translated">结果是:</p></blockquote><figure class="ok ol om on oo kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/1c1317fa176e48d29dd69e7bd0f413de.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*rN5gKhlNQX_PM4O6KFzRiA.png"/></div></figure><p id="bccd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们可以就此打住，这本身就是一个强大的工具，但重要的是要记住，函数只是一个有着花哨名字的类型。朱莉娅的伟大之处在于我们能够利用这一点。首先，你应该理解语法表达。这些当然是朱莉娅语法的一大部分，而且是一种只因为分派而存在的能力。让我们举一个速度的例子:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="7047" class="nk mn it ng b gy nl nm l nn no">mutable struct car_stats<br/>    distance<br/>    time<br/>    speed<br/>end<br/>honda_civic = car_stats(25, 40, nothing)</span></pre><p id="7268" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个特定的场景中，我们知道汽车行驶的距离，以及汽车行驶那么远所用的时间。我们缺少这辆车的速度数据，我们需要找到它。如果你还记得的话，这个公式就是距离除以时间得到速度。所以与其写这样一个函数:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="a614" class="nk mn it ng b gy nl nm l nn no">function speed(carstat)<br/>    mph = carstat.distance / carstat.time<br/>    return(mph)<br/>end</span></pre><p id="b3fc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以用 Julia 返回时间的调度创建一个语法表达式:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/f37ca70c9749dfd83a301afa4996f5f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:882/format:webp/1*UQS0FtD3h8Wv8bpdNVKWyQ.png"/></div></figure><p id="0f51" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们甚至可以更进一步，使用 dispatch 将这些方法作为一种类型的子方法，这是非常不可思议的！为此，我们首先需要创建另一个分派函数来返回我们的类型:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="e5c7" class="nk mn it ng b gy nl nm l nn no">typemaker(speedfunc,civic) = ()-&gt;(speedfunc;civic)</span></pre><p id="7dee" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，我们将为变量分配相应的方法和速度统计类型:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="77a4" class="nk mn it ng b gy nl nm l nn no">d = typemaker(speed,honda_civic)</span></pre><p id="f268" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们可以跑了</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="47c5" class="nk mn it ng b gy nl nm l nn no">d.speedfunc(d.civic)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/e0e0fe3736fdd931ef5c8f247d5c41cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:632/format:webp/1*bZw1QrOx8_L52XakHADKZA.png"/></div></figure><p id="ca6f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">作为一个新的 Julia 开发人员，你可能犯的最大错误之一就是没有利用 Julia 的调度并充分发挥它的潜力！</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="53f0" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">№3:滤镜！</h1><p id="c0e3" class="pw-post-body-paragraph ky kz it la b lb od ju ld le oe jx lg lh of lj lk ll og ln lo lp oh lr ls lt im bi translated">Filter 可能是来自 Julia 库的最有用和最通用的工具之一，尤其是如果你像我一样，经常发现自己在对大量数据进行排序。您可以花费数小时构建循环来确定数据中是否满足某些条件，或者您可以只使用 filter！Filter 是 Python 的 Pandas 的条件屏蔽的 Julian 等价物，然而，它被合并到语言的基础中，使它更快并且与语言的其余部分的语法非常一致。</p><p id="2681" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在数据操作中，过滤是实现各种不同目标的一种很好的方法。毫无疑问，能够有效地使用这种方法将会使您在 Julia 中管理数据时受益匪浅。考虑以下数据:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="db06" class="nk mn it ng b gy nl nm l nn no">x = 1:10</span></pre><p id="66f6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用过滤器！，我们可以根据每个 dim 是否满足特定条件来决定包含或排除哪些数据。比方说，我们只想得到能被 3 整除的值:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="2f4d" class="nk mn it ng b gy nl nm l nn no">filter((x) -&gt; x % 3 == 0, x)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/39902085478a4185566aaa2c1d97d201.png" data-original-src="https://miro.medium.com/v2/resize:fit:656/format:webp/1*UaH8R9LqSMHDJ1k5QxrbCw.png"/></div></figure><p id="a258" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">虽然这是一个相当不实用的例子，但它确实以最基本的方式展示了 filter 的用法。在基本的统计测试中，这可能会派上用场。在 Julia 中有许多方法可以做到这一点，但是 filter 始终是一种非常有效的方法。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="4489" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">结论</h1><p id="9d0f" class="pw-post-body-paragraph ky kz it la b lb od ju ld le oe jx lg lh of lj lk ll og ln lo lp oh lr ls lt im bi translated">在 Julia 语言中，有很多很酷的小技巧可以用来升级语法，让事情变得更简单。从像操作符和多态调度这样令人惊奇和复杂的工具到像过滤器这样简单的基本功能！，使用 Julia 语言总有一些很好的东西可以让你的代码更快更简洁。</p></div></div>    
</body>
</html>