<html>
<head>
<title>Join the Tables</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">加入表格</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/join-the-tables-ab7fd4fac26b?source=collection_archive---------33-----------------------#2020-06-30">https://towardsdatascience.com/join-the-tables-ab7fd4fac26b?source=collection_archive---------33-----------------------#2020-06-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bbcc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解 Python pandas 中的 merge()和 concat()</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/026060bb413dd4d4cddb05f8536f96dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R_9DJKPnWhXp4frKFsG7Tg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由来自<a class="ae ky" href="https://www.pexels.com/photo/white-wooden-table-and-black-chairs-inside-white-green-painted-room-159806/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">像素</a>的<a class="ae ky" href="https://www.pexels.com/@pixabay?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">皮克斯拜</a>拍摄</p></figure><p id="276d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据科学项目始于数据。从不同的来源收集所需的数据，对其进行评估、清理和存储，以便进一步分析和建模。</p><blockquote class="lv"><p id="3ddf" class="lw lx it bd ly lz ma mb mc md me lu dk translated">数据是数据科学项目的关键要素</p></blockquote><p id="4ef2" class="pw-post-body-paragraph kz la it lb b lc mf ju le lf mg jx lh li mh lk ll lm mi lo lp lq mj ls lt lu im bi translated">然而，在一个项目中有多个数据集是相当混乱的。在数据清理时，需要对所有数据集应用相同的过程，这是一项繁琐的任务。这也可能会导致一些错误。在这种情况下，将所有数据集组合在一起以获得整个数据的单一视图是一个好主意。当原始数据是从不同的文件、工作表、数据表，甚至是从 web 抓取中收集时，这个过程通常是必要的。</p><div class="mk ml gp gr mm mn"><a rel="noopener follow" target="_blank" href="/web-scraping-make-your-own-dataset-cc973a9f0ee5"><div class="mo ab fo"><div class="mp ab mq cl cj mr"><h2 class="bd iu gy z fp ms fr fs mt fu fw is bi translated">网页抓取—制作您自己的数据集</h2><div class="mu l"><h3 class="bd b gy z fp ms fr fs mt fu fw dk translated">从网页中提取数据并将其存储到 excel 中—只需 4 个简单的步骤</h3></div><div class="mv l"><p class="bd b dl z fp ms fr fs mt fu fw dk translated">towardsdatascience.com</p></div></div><div class="mw l"><div class="mx l my mz na mw nb ks mn"/></div></div></a></div></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><p id="6709" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在 Python 中，有两种方法可以组合来自不同数据帧的数据。因此，这就是这两种方法的故事—</p><blockquote class="lv"><p id="aea7" class="lw lx it bd ly lz ma mb mc md me lu dk translated"><strong class="ak"> <em class="nj">熊猫。data frame . merge Vs pandas . concat</em></strong></p></blockquote><p id="8365" class="pw-post-body-paragraph kz la it lb b lc mf ju le lf mg jx lh li mh lk ll lm mi lo lp lq mj ls lt lu im bi translated">DataFrame 是最常用的 pandas 对象，用于以行和列的形式存储不同数据类型的表格数据。</p><p id="9644" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">merge()和 Concat()是 pandas 中组合不同数据帧的两个非常有用的方法</p><p id="8f48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建三个数据帧，<em class="nk"> df_one，df_two，df_three </em></p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="8a49" class="nq nr it nm b gy ns nt l nu nv">countries = {'ID':["EU101","AS101","EU103","EU102","US111"],\<br/>             'Country': ["Germany", "India", "Belgium", "Austria",   "Mexico"]}</span><span id="4836" class="nq nr it nm b gy nw nt l nu nv">states = {'Countryname': ["France", "India", "Belgium", "Japan", "Mexico","Spain"],\<br/>         'statecount': [15, 7, 10, 9, 32, 10]}</span><span id="7302" class="nq nr it nm b gy nw nt l nu nv">europe ={'ID':["EU101","AS101","EU103","EU102","US112"],\<br/>        'EU_member': ["Yes", "No", "No", "No", "No"],\<br/>        'Airports': [36,126,5,6,77]}</span><span id="2509" class="nq nr it nm b gy nw nt l nu nv">df_one = pd.DataFrame(countries, index = [0,1,2,3,4])<br/>df_two = pd.DataFrame(states, index = [1,2,3,4,5,6])<br/>df_three = pd.DataFrame(europe, index = [0,1,2,3,4])<br/></span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/12fde78d375485d755c742c9a66ba96c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6HpPd-XMCCxCR_zb3FEcMQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">样本数据帧</p></figure></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><h1 id="fbdb" class="ny nr it bd nz oa ob oc od oe of og oh jz oi ka oj kc ok kd ol kf om kg on oo bi translated">1.Concat()</h1><p id="a612" class="pw-post-body-paragraph kz la it lb b lc op ju le lf oq jx lh li or lk ll lm os lo lp lq ot ls lt lu im bi translated">它沿着一个特定的轴耦合熊猫数据帧。它将数据集按行或列连接在一起。</p><p id="1e13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设，您想要在行方向上组合三个数据帧 df_one、df_two 和 df_three，以便它们将形成单个数据帧。</p><p id="789c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用 Concat()，您只需要在一个列表中传递数据帧的名称。</p><p id="2489" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ou ov ow nm b">df_four = pd.concat([df_one, df_two])</code></p><p id="694c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，两个数据帧简单地缝合在一起，一个在另一个下面。两个数据帧中的所有列和行都将保留。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/a144adbdde30a671c46f42a981c82e84.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/format:webp/1*bayv0U-lukLauh6NNywtHA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">级联数据帧</p></figure><p id="787b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要并排连接这些表，必须向 concat()添加一个额外的参数<code class="fe ou ov ow nm b">axis = 1</code>。</p><p id="cbc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ou ov ow nm b">df_four = pd.concat([df_one, df_two], axis = 1)</code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/7fe5b3efbcd15f8387c0062ed450cbd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/format:webp/1*NDGgP_DTA9vVLNqXDyxA2w.png"/></div></figure><p id="cc4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单！！</p><p id="eded" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有数据帧被连接在一起作为单个数据帧。但是等等，<em class="nk">我怎么知道，哪个数据来自哪个数据帧？？</em></p><p id="544d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">熊猫对此有一个答案。Pandas 提供了一个用关键字标记数据帧的选项，这样，在连接之后，您将知道数据帧来自哪里。这种数据标记实际上使得提取对应于特定数据帧的数据变得容易。</p><p id="72ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ou ov ow nm b">df_four = pd.concat([df_one, df_two], keys=[“df_one”,”df_two”])</code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/7164ff6209506d52d0094754cf8cd3da.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/format:webp/1*Cf59gO1jigImjCHL0Sp3nQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">具有源数据帧名称的串联数据帧</p></figure><p id="3b8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在组合来自多个数据帧的数据时，我们确实可以控制在结果数据帧中得到什么。可以使用 Concat()中的<code class="fe ou ov ow nm b">join</code>参数来实现。在这场争论中，熊猫给了我们两个选择。</p><ol class=""><li id="1ab0" class="pa pb it lb b lc ld lf lg li pc lm pd lq pe lu pf pg ph pi bi translated"><code class="fe ou ov ow nm b">outer</code>:数据帧的联合</li></ol><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="280b" class="nq nr it nm b gy ns nt l nu nv">df_five = pd.concat([df_one, df_two], axis = 1, join = 'outer',\<br/>                   keys=['df_one', 'df_two'])</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/c6d1de669ce3d7e01411f8b27f329e41.png" data-original-src="https://miro.medium.com/v2/resize:fit:930/format:webp/1*TVPoewABHXvMssYiCqymqA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">带有外部连接的 pandas.concat()</p></figure><p id="0b20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对应于所有索引的行保留在结果数据帧中。</p><ol class=""><li id="b2c4" class="pa pb it lb b lc ld lf lg li pc lm pd lq pe lu pf pg ph pi bi translated"><code class="fe ou ov ow nm b">inner</code>:数据帧的交集</li></ol><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="fe87" class="nq nr it nm b gy ns nt l nu nv">df_five = pd.concat([df_one, df_two], axis = 1, join = 'inner',\<br/>                   keys=['df_one', 'df_two'])</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/449a7851d0fa691484807091cf615888.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/format:webp/1*mFIKnEWK8k6qKlYqpg8jiA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">带有内部连接的 pandas.concat()</p></figure><p id="70ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在一个<code class="fe ou ov ow nm b">inner</code>连接中，数据帧<code class="fe ou ov ow nm b">df_one</code>和<code class="fe ou ov ow nm b">df_two</code>共有的所有索引都保留在结果数据帧中。默认情况下，熊猫执行沿行的外部连接。关于它的文档信息可以在<a class="ae ky" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.concat.html" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h1 id="c8e5" class="ny nr it bd nz oa pl oc od oe pm og oh jz pn ka oj kc po kd ol kf pp kg on oo bi translated"><strong class="ak"> 2。merge() </strong></h1><p id="e606" class="pw-post-body-paragraph kz la it lb b lc op ju le lf oq jx lh li or lk ll lm os lo lp lq ot ls lt lu im bi translated">它以数据库风格组合数据帧，即数据帧在公共列或索引上连接。通常，我们处理不同的数据集，这些数据集包含关于同一实体的不同类型的数据。这种数据集通常通过一两个公共列相互链接。</p><p id="6bec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">merge()根据公共列中的值组合数据帧。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="c1f2" class="nq nr it nm b gy ns nt l nu nv">df_four = df_one.merge(df_three)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pq"><img src="../Images/1e0ffaac9da9900de126d4799754bcea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*byopqkxbaA7BGR-hCkQx3A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这就是表格合并的方式</p></figure><p id="b8b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，<code class="fe ou ov ow nm b">df_one</code>和<code class="fe ou ov ow nm b">df_three</code>这两个表在两个表中都可用的公共列<em class="nk"> "ID" </em>上连接，并且在两个表中对于列<em class="nk"> "ID" </em>具有相同值的行将保留在结果表中。merge()自动识别两个表中的公共列。</p><p id="19ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于它的定制选项列表很长，merge()被认为是连接表或数据帧的最灵活的方法。</p><p id="c72d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我最常听到的关于 merge()的说法是，</p><blockquote class="pr ps pt"><p id="a95f" class="kz la nk lb b lc ld ju le lf lg jx lh pu lj lk ll pv ln lo lp pw lr ls lt lu im bi translated">merge()以 SQL 风格连接表</p></blockquote><p id="06eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nk">你不了解 SQL 或者结构化查询语言？？？</em></p><p id="62b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完全没问题。这里我展示了理解 merge()的最简单的方法。每个人都知道集合论中的维恩图和维恩图的基础知识，如集合的并和交。下面四张图会给你最简单最清晰的 merge()视图。光看颜色，这些图片就一目了然了。</p><p id="6a4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">merge()提供了 4 个选项来获得对结果数据集的控制，这些选项可以在 merge()内的<em class="nk"> "how" </em>参数中传递，例如，</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="cc24" class="nq nr it nm b gy ns nt l nu nv">df_one.merge(df_three, how="inner")</span></pre><p id="1ce0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，merge()提供内部连接，因此不需要特别提到它。一个<strong class="lb iu"> <em class="nk">内部</em> </strong>连接类似于集合 的<strong class="lb iu"> <em class="nk">交集，而<strong class="lb iu"> <em class="nk">外部</em> </strong>连接类似于集合</em> </strong>的<strong class="lb iu"> <em class="nk">联合。</em></strong></p><p id="6f42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，这里有 merge()选项，</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi px"><img src="../Images/5e76efe9cc0e5724c8645b8ecd82c229.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jRkzIqLK-Bkq27LCr8imng.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这就是 merge()的工作方式</p></figure><p id="857b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在 merge()中，有一个巨大的可选参数列表，可以在这里进行探索。</p><p id="8b36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="nk">熊猫。DataFrame.join() </em> </strong>可以认为是 merge()的一种简单形式，可选参数较少。它确实像 merge()-join 操作一样。与 merge()不同，join()在公共索引<em class="nk">上耦合两个数据帧</em>。因此，要将两个表或数据帧连接在一起，我们应该在两个数据帧中设置相同的列作为索引。该表格连接选项也可在<a class="ae ky" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.join.html" rel="noopener ugc nofollow" target="_blank">文档</a>中找到。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><p id="734c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的时间和阅读！！！</p><p id="37d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢这个关于熊猫的简单解释，这是加入数据集的两个重要特征。选择 Concat()还是 merge()完全是我们的选择，但我主要使用 merge()，因为它提供了广泛的选项。如果你喜欢这篇文章，请随时添加反馈，并在 LinkedIn 上与我联系。</p><div class="mk ml gp gr mm mn"><a href="https://www.linkedin.com/in/surajgurav17/" rel="noopener  ugc nofollow" target="_blank"><div class="mo ab fo"><div class="mp ab mq cl cj mr"><h2 class="bd iu gy z fp ms fr fs mt fu fw is bi translated">Suraj Gurav -副机械工程师-康耐视公司| LinkedIn</h2><div class="mu l"><h3 class="bd b gy z fp ms fr fs mt fu fw dk translated">查看 Suraj Gurav 在全球最大的职业社区 LinkedIn 上的个人资料。Suraj 有 8 个工作列在他们的…</h3></div><div class="mv l"><p class="bd b dl z fp ms fr fs mt fu fw dk translated">www.linkedin.com</p></div></div><div class="mw l"><div class="py l my mz na mw nb ks mn"/></div></div></a></div></div></div>    
</body>
</html>