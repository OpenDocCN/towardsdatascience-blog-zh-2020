<html>
<head>
<title>The 4 steps necessary before fitting a machine learning model</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">拟合机器学习模型前的 4 个必要步骤</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-4-steps-necessary-before-fitting-a-machine-learning-model-574bf8f1cd48?source=collection_archive---------26-----------------------#2020-03-06">https://towardsdatascience.com/the-4-steps-necessary-before-fitting-a-machine-learning-model-574bf8f1cd48?source=collection_archive---------26-----------------------#2020-03-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f286" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一种简单的面向对象的数据处理方法。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f1fd405d17f7186c018dd0a8c8961c65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TYZzoSVTSRCVyzsrJf1_Og.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@chuttersnap?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> chuttersnap </a>在<a class="ae ky" href="https://unsplash.com/s/photos/pipes?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><blockquote class="kz la lb"><p id="b7af" class="lc ld le lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><a class="ae ky" href="https://mailchi.mp/d2d2d4a109b5/learning-rate-newsletter" rel="noopener ugc nofollow" target="_blank"> Learning Rate </a>是为那些对 AI 和 MLOps 的世界感到好奇的人准备的时事通讯。你会在每周五收到我关于最新人工智能新闻和文章的更新和想法。订阅<a class="ae ky" href="https://mailchi.mp/d2d2d4a109b5/learning-rate-newsletter" rel="noopener ugc nofollow" target="_blank">这里</a>！</p></blockquote></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><p id="6c3c" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mg ln lo lp mh lr ls lt mi lv lw lx ly im bi translated">在一个通用的机器学习管道中有许多步骤，并且在设计它的时候有很多想法。有问题定义、数据采集、错误检测和数据清理等。在这个故事中，我们首先假设我们有一个干净的现成数据集。</p><p id="a9c7" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mg ln lo lp mh lr ls lt mi lv lw lx ly im bi translated">考虑到这一点，我们概述了在拟合任何机器学习模型之前的四个必要步骤。然后，我们在 Pytorch 中实现这些步骤，使用公共语法调用多个方法调用；方法链接。<strong class="lf iu">我们的目标是定义一个简单而通用的 API，将任何原始数据集转换成机器学习模型可以使用的格式。</strong></p><p id="9c1d" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mg ln lo lp mh lr ls lt mi lv lw lx ly im bi translated">为此，我们将使用<strong class="lf iu"> <em class="le">构建模式</em> </strong> <em class="le">、</em>，它使用逐步方法构建一个复杂的对象。</p><blockquote class="mj"><p id="d9a4" class="mk ml it bd mm mn mo mp mq mr ms ly dk translated"><strong class="ak"> builder 模式</strong>是一种<a class="ae ky" href="https://en.wikipedia.org/wiki/Software_design_pattern" rel="noopener ugc nofollow" target="_blank">设计模式</a>，为<a class="ae ky" href="https://en.wikipedia.org/wiki/Object-oriented_programming" rel="noopener ugc nofollow" target="_blank">面向对象编程</a>中的对象创建问题提供了一种灵活的解决方案。它的目的是把一个复杂物体的构造和它的表现分离开来。</p></blockquote><p id="3fff" class="pw-post-body-paragraph lc ld it lf b lg mt ju li lj mu jx ll mg mv lo lp mh mw ls lt mi mx lw lx ly im bi translated">那么，这四样东西是什么？在最简单的情况下，建模前的数据处理包括四个不同的动作:</p><ol class=""><li id="2b6e" class="my mz it lf b lg lh lj lk mg na mh nb mi nc ly nd ne nf ng bi translated">加载数据</li><li id="0a4d" class="my mz it lf b lg nh lj ni mg nj mh nk mi nl ly nd ne nf ng bi translated">分成训练/有效/测试集</li><li id="6cd1" class="my mz it lf b lg nh lj ni mg nj mh nk mi nl ly nd ne nf ng bi translated">标记数据元组</li><li id="324d" class="my mz it lf b lg nh lj ni mg nj mh nk mi nl ly nd ne nf ng bi translated">获取批量数据</li></ol><p id="3d11" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mg ln lo lp mh lr ls lt mi lv lw lx ly im bi translated">在接下来的小节中，我将逐一分析这四个步骤，并用代码实现它们。我们的目标是最终创建一个 PyTorch <code class="fe nm nn no np b">DataLoader</code>，PyTorch 使用这个抽象来表示数据集上的 iterable。拥有一个<code class="fe nm nn no np b">DataLoader</code>是设置训练循环的第一步。所以，事不宜迟，让我们把手弄脏吧。</p><h1 id="e64d" class="nq nr it bd ns nt nu nv nw nx ny nz oa jz ob ka oc kc od kd oe kf of kg og oh bi translated">加载数据</h1><p id="7775" class="pw-post-body-paragraph lc ld it lf b lg oi ju li lj oj jx ll mg ok lo lp mh ol ls lt mi om lw lx ly im bi translated">对于这个例子，我们使用一个模拟数据集，它以 pandas <code class="fe nm nn no np b">DataFrame</code>格式保存。我们的目标是为训练集和验证集分别创建一个 PyTorch <code class="fe nm nn no np b">Dataloader</code>类。因此，让我们构建一个名为<code class="fe nm nn no np b">DataLoaderBuilder</code>的类，它负责构建这些类。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="eeac" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mg ln lo lp mh lr ls lt mi lv lw lx ly im bi translated">我们看到<code class="fe nm nn no np b">DataLoaderBuilder</code>的唯一操作是存储一个<code class="fe nm nn no np b">data</code>变量，它的类型是<code class="fe nm nn no np b">torch.tensor</code>。所以现在，我们需要一个从熊猫<code class="fe nm nn no np b">DataFrame</code>初始化它的方法。为此，我们使用 python <code class="fe nm nn no np b">classmethod</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="de03" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mg ln lo lp mh lr ls lt mi lv lw lx ly im bi translated"><code class="fe nm nn no np b">classmethod</code>是一个普通的 python 类方法，但是它没有接收<code class="fe nm nn no np b">self</code>作为第一个参数，而是接收了一个<code class="fe nm nn no np b">class</code>。因此，给定一个熊猫<code class="fe nm nn no np b">DataFrame</code>，我们将<code class="fe nm nn no np b">DataFrame</code>转换成 PyTorch 张量并实例化<code class="fe nm nn no np b">DataLoaderBuilder</code>类，该类作为<code class="fe nm nn no np b">cls</code>参数传递给方法。可选地，我们可以只保留我们关心的<code class="fe nm nn no np b">DataFrame</code>的列。在定义它之后，我们将它修补到主<code class="fe nm nn no np b">DataLoaderBuilder</code>类。</p><h1 id="43ed" class="nq nr it bd ns nt nu nv nw nx ny nz oa jz ob ka oc kc od kd oe kf of kg og oh bi translated">分为培训和验证</h1><p id="8ed8" class="pw-post-body-paragraph lc ld it lf b lg oi ju li lj oj jx ll mg ok lo lp mh ol ls lt mi om lw lx ly im bi translated">对于这个例子，我们将数据集分成两组；培训和验证。很容易扩展代码，把它分成三组；培训、验证和测试。</p><p id="0714" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mg ln lo lp mh lr ls lt mi lv lw lx ly im bi translated">我们希望随机分割数据集，保留一定比例的数据用于训练，并留出一些数据用于验证。为此，我们使用 Pytorch 的<code class="fe nm nn no np b">SubsetRandomSampler</code>。你可以在 PyTorch 的官方文档中读到更多关于这个采样器和更多采样方法的信息。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="d36c" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mg ln lo lp mh lr ls lt mi lv lw lx ly im bi translated">默认情况下，我们保留 90%的数据用于训练，并且我们跨行拆分(<code class="fe nm nn no np b">axis=0</code>)。<strong class="lf iu">代码中的另一个细节是我们返回</strong> <code class="fe nm nn no np b"><strong class="lf iu">self</strong></code> <strong class="lf iu">。因此，在创建了</strong> <code class="fe nm nn no np b"><strong class="lf iu">train_data</strong></code> <strong class="lf iu">和</strong><code class="fe nm nn no np b"><strong class="lf iu">valid_data</strong></code><strong class="lf iu">split 之后，我们返回了整个类。这将允许 as 最终使用方法链接。</strong></p><h1 id="95d9" class="nq nr it bd ns nt nu nv nw nx ny nz oa jz ob ka oc kc od kd oe kf of kg og oh bi translated">标注数据集</h1><p id="7794" class="pw-post-body-paragraph lc ld it lf b lg oi ju li lj oj jx ll mg ok lo lp mh ol ls lt mi om lw lx ly im bi translated">接下来，我们应该标记数据集。很多时候，我们用一些特征变量来预测一个因变量(即目标)。那当然就是所谓的监督学习。<code class="fe nm nn no np b">label_by_func</code>方法根据给定的函数注释数据集。在这个调用之后，数据集通常被转换成<code class="fe nm nn no np b">(features, target)</code>元组。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="040c" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mg ln lo lp mh lr ls lt mi lv lw lx ly im bi translated">我们看到<code class="fe nm nn no np b">label_by_func</code>方法接受一个函数作为参数，并将其应用于训练集和有效集。我们的工作是设计一个函数，在我们想要标记某种形式的数据集的任何时候为我们的目的服务。在后面的<em class="le">“把它们放在一起”</em>例子中，我们展示了创建这样一个函数是多么简单。</p><h1 id="5a67" class="nq nr it bd ns nt nu nv nw nx ny nz oa jz ob ka oc kc od kd oe kf of kg og oh bi translated">创建批次</h1><p id="6be9" class="pw-post-body-paragraph lc ld it lf b lg oi ju li lj oj jx ll mg ok lo lp mh ol ls lt mi om lw lx ly im bi translated">最后只剩下一步；将数据集分成几批。为此，我们可以利用 PyTorch 的<code class="fe nm nn no np b">TensorDataset</code>和<code class="fe nm nn no np b">DataLoader</code>类。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="d21a" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mg ln lo lp mh lr ls lt mi lv lw lx ly im bi translated"><strong class="lf iu">这是这个链中的最后一个方法，因此，我们将其命名为“<em class="le">build”</em>。它创建训练和有效数据集，有了它们，就很容易用已知的批量实例化相应的 Pytorch </strong> <code class="fe nm nn no np b"><strong class="lf iu">DataLoader</strong></code> <strong class="lf iu">。</strong>请记住，我们现在已经标记了数据，因此，<code class="fe nm nn no np b">self.train_data</code>是一个由<code class="fe nm nn no np b">features</code>和<code class="fe nm nn no np b">target</code>变量组成的元组。因此，<code class="fe nm nn no np b">self.train_data[0]</code>保持<code class="fe nm nn no np b">features</code>并且<code class="fe nm nn no np b">self.train_data[1]</code>保持目标。</p><p id="66bf" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mg ln lo lp mh lr ls lt mi lv lw lx ly im bi translated">了解了这一点之后，让我们用一个简单的例子来说明这一点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="3e4a" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mg ln lo lp mh lr ls lt mi lv lw lx ly im bi translated">在本例中，我们创建了一个包含三列的虚拟数据集，其中最后一列存储了<em class="le">目标</em>或<em class="le">依赖</em>变量。然后我们定义了一个<code class="fe nm nn no np b">get_label</code>函数，它提取最后一列并创建一个 features-target 元组。最后，使用方法链接，我们可以很容易地从给定的 pandas <code class="fe nm nn no np b">DataFrame</code>中创建我们需要的数据加载器。</p><h1 id="115d" class="nq nr it bd ns nt nu nv nw nx ny nz oa jz ob ka oc kc od kd oe kf of kg og oh bi translated">结论</h1><p id="1b6d" class="pw-post-body-paragraph lc ld it lf b lg oi ju li lj oj jx ll mg ok lo lp mh ol ls lt mi om lw lx ly im bi translated">在这个故事中，我们看到了在拟合任何模型之前，数据处理的四个必要步骤是什么，假设数据集是干净的。虽然这是一个玩具示例，但它可以用于并扩展到各种各样的机器学习问题。</p><p id="325b" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mg ln lo lp mh lr ls lt mi lv lw lx ly im bi translated">此外，还有一些步骤没有在本文中介绍(例如，计算机视觉的数据规范化或扩充)，但本文的目的是提供一个关于如何构建代码来解决相关问题的总体思路。</p><blockquote class="kz la lb"><p id="d275" class="lc ld le lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf iu">我叫 Dimitris Poulopoulos，是希腊比雷埃夫斯大学<em class="it"/></strong><a class="ae ky" href="https://bigdatastack.eu/" rel="noopener ugc nofollow" target="_blank"><strong class="lf iu">BigDataStack</strong></a><strong class="lf iu"><em class="it"/>的机器学习研究员和博士(c)。我曾为欧洲委员会、欧盟统计局、国际货币基金组织、欧洲中央银行、经合组织和宜家等主要客户设计和实施人工智能和软件解决方案。如果你有兴趣阅读更多关于机器学习、深度学习和数据科学的帖子，请在 twitter 上关注我的</strong> <a class="ae ky" href="https://medium.com/@dpoulopoulos" rel="noopener"> <strong class="lf iu">中</strong> </a> <strong class="lf iu">、</strong><a class="ae ky" href="https://www.linkedin.com/in/dpoulopoulos/" rel="noopener ugc nofollow" target="_blank"><strong class="lf iu">LinkedIn</strong></a><strong class="lf iu">或</strong><a class="ae ky" href="https://twitter.com/james2pl" rel="noopener ugc nofollow" target="_blank"><strong class="lf iu">@ james2pl</strong></a><strong class="lf iu">。</strong></p></blockquote></div></div>    
</body>
</html>