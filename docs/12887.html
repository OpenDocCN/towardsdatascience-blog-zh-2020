<html>
<head>
<title>Linear Regression: From Math to Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">线性回归:从数学到代码</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/linear-regression-from-math-to-code-9659132383ec?source=collection_archive---------32-----------------------#2020-09-04">https://towardsdatascience.com/linear-regression-from-math-to-code-9659132383ec?source=collection_archive---------32-----------------------#2020-09-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a340" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用 Python 的数学和实现指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/76038da15425f6b81e4d26ad6e9328ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/1*YWCF2sa91-sAQgNxSNHH7g.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><h2 id="de23" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">介绍</h2><p id="87f1" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">如果你有统计学背景，甚至可能是高中水平，你可能对线性回归(LR)很熟悉。简而言之，它是统计学和机器学习(ML)中使用的核心技术之一，用于定义一个模型，该模型最好地描述由未知过程生成的一组观察数据<em class="mj"> D </em>。虽然你可以在网上找到大量的例子来解释如何使用示例代码实现 LR，但是我的帖子试图提供贝叶斯 LR 背后的数学的逐步分解，并进一步试图解释如何使用 Python 代码实现它。<strong class="ls iu">请注意，我对这个概念包括符号的理解和解释，完全是基于本书第三章</strong>[1]。最后提供了参考资料，供您参考。对于那些熟悉该算法的人来说，这篇文章可能是对其背后概念的修正。对于那些不熟悉的人来说，我希望这篇文章能在你浏览其他作者提供的概念时起到指导作用。有一些线性代数，概率论和微积分的知识是必不可少的，以获得足够的这个职位。好了，我们开始吧！</p><h2 id="e343" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">数学</h2><p id="9b50" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">假设你有一组<em class="mj"> D </em>的观察数据，<em class="mj"> (tᵢ，</em> <strong class="ls iu"> <em class="mj"> x </em> </strong> <em class="mj"> ᵢ)，从一个未知过程中得到的</em>其中<strong class="ls iu"><em class="mj"/></strong><em class="mj">ᵢ</em>和<em class="mj"> tᵢ </em>分别是输入和输出。粗体<strong class="ls iu"> <em class="mj"> x </em> </strong> <em class="mj"> ᵢ </em>的意思是它是一个矢量。这个未知过程的一个输出，<em class="mj"> tᵢ </em>与其输入<strong class="ls iu"> <em class="mj"> x </em> </strong> <em class="mj"> ᵢ，</em>之间的关系可以用一个函数<em class="mj">tᵢ= f(</em><strong class="ls iu"><em class="mj">x</em></strong><em class="mj">ᵢ，</em> <strong class="ls iu"> <em class="mj"> w </em> </strong> <em class="mj">)来描述。</em>几何上，从线性代数的角度来看，一旦我们有了正确的一组基向量，我们就可以表示向量空间中的任何向量/点。这里的想法是，我们的输入生活在一个 d 维空间，ℝᴰ，我们的输出生活在一个 m 维 space,ℝᴹ，我喜欢称之为输出空间。我们的建模问题现在变成寻找 M 的合适值，即合适数量的基和参数值，<strong class="ls iu"> <em class="mj"> w </em> </strong>，其组合这些基。这些依据又是，<strong class="ls iu"> <em class="mj"> x </em> </strong>的函数，我相信是为了调音的目的！。这些函数被称为基函数。有许多函数可以用作基函数，例如多项式、高斯函数、sigmoids 等。在本文的代码部分，我们将使用多项式。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mk"><img src="../Images/feea7ae8bd9b047506ba5a1e24ea02ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sprXZzHqc_ybyiH2bNbSzw.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者根据[1]和[2]提供的图片</p></figure><p id="db5a" class="pw-post-body-paragraph lq lr it ls b lt mp ju lv lw mq jx ly ld mr ma mb lh ms md me ll mt mg mh mi im bi translated">这个函数描述了这个数据中的一个模式，如果确实有一个模式，那么下次我们有一个输入<strong class="ls iu"><em class="mj">x</em></strong><em class="mj"/>ᵢ，我们期望测量相同的输出<em class="mj"> tᵢ </em>，这也可以通过我们的函数来预测。然而，实际上这并不完全准确，因为在我们的测量中总有一些噪声。因此，我们的函数应该考虑这种噪声。我们的观察将倾向于围绕我们的函数预测。由于<strong class="ls iu">中心极限定理</strong>，这些预测的分布近似于高斯分布。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mu"><img src="../Images/338eb520e9461b5fda976a96d3ace7ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wK4M9wdfqbInBf_OZgEDMg.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图片由作者基于[1]</p></figure><p id="ddeb" class="pw-post-body-paragraph lq lr it ls b lt mp ju lv lw mq jx ly ld mr ma mb lh ms md me ll mt mg mh mi im bi translated">所有观测值的联合概率(假设它们是独立同分布的)是单个观测值的概率分布的乘积，如下所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mv"><img src="../Images/40338ee19d0d1477e51a851b40fc8f08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RA_6D5mePnqircpjs6qxFQ.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图片由作者基于[1]</p></figure><p id="3e89" class="pw-post-body-paragraph lq lr it ls b lt mp ju lv lw mq jx ly ld mr ma mb lh ms md me ll mt mg mh mi im bi translated">这个表达式叫做<strong class="ls iu">似然</strong>，如果我们在两边都应用 log，这样我们就可以处理加法而不是乘积，我们得到下面的表达式。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mw"><img src="../Images/0b86e3caa81f6092dd06d4313e0eb0c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZXV4B5vnc4nQS6NS2no5QQ.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者根据[1]和[2]提供的图片</p></figure><p id="1b24" class="pw-post-body-paragraph lq lr it ls b lt mp ju lv lw mq jx ly ld mr ma mb lh ms md me ll mt mg mh mi im bi translated">希腊<strong class="ls iu">φ</strong>符号被称为设计矩阵，我们将在代码部分看到构建它的一种方式。<strong class="ls iu"> t </strong>是输出观测值的列向量<em class="mj"> tᵢ </em>和<strong class="ls iu"> X </strong>是矩阵，其中每行是观测值<strong class="ls iu"> <em class="mj"> x </em> </strong> <em class="mj"> ᵢ.</em>假设我们固定 M 的值，使可能性最大化的模型的参数值具有封闭形式的解，称为<strong class="ls iu">最大可能性估计</strong>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mx"><img src="../Images/692df2362686f2aebd1e8d93d71ab58b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cG_iILImkp4RLag6biWRsQ.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="9318" class="pw-post-body-paragraph lq lr it ls b lt mp ju lv lw mq jx ly ld mr ma mb lh ms md me ll mt mg mh mi im bi translated">为了获得最大可能性的直觉，让我们做一个简单的思维实验。假设我们抛一次硬币，也许会有一条尾巴。好，让我们再抛一次，<em class="mj">和</em>我们又得到一条尾巴。好吧，也许这枚硬币有瑕疵。让我们再翻转一次，这次我们仍然得到一条尾巴。基于这些观察，我们不妨得出结论，得到尾巴的机会是 100%。但是我们知道我们的硬币是公平的，即先验知识。使用 Baye 定理，我们使用这个先验知识来提出一个更好的表达式来计算我们的参数<strong class="ls iu"> <em class="mj"> w </em> </strong> <em class="mj">。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi my"><img src="../Images/8088d5e06d0da65b95c30efb88cb6447.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LiWw0UzHuWFopu9XL0UQbA.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图片由作者基于[1]</p></figure><p id="023d" class="pw-post-body-paragraph lq lr it ls b lt mp ju lv lw mq jx ly ld mr ma mb lh ms md me ll mt mg mh mi im bi translated">将 log 应用于等式的两边，并求解最佳参数<strong class="ls iu"> <em class="mj"> w </em> </strong>，如之前所做的，我们获得下面的表达式及其下面的参数估计。这叫做<strong class="ls iu">最大后验估计</strong>(图)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mz"><img src="../Images/30c2ec1e11ec21740960321cdadff6ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-JQU-L_kD_9I6tDEr0d32w.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="8b42" class="pw-post-body-paragraph lq lr it ls b lt mp ju lv lw mq jx ly ld mr ma mb lh ms md me ll mt mg mh mi im bi translated">最大似然法和最大后验概率法都只能给我们一个模型参数的精确估计，我们以后可以用它来进行预测。然而，在做预测时，重要的是要有一定的不确定性，这样我们才能从预测中做出正确的决定。显然，如果我们在这里结束，它不足以建立一个健壮的模型。</p><p id="51ca" class="pw-post-body-paragraph lq lr it ls b lt mp ju lv lw mq jx ly ld mr ma mb lh ms md me ll mt mg mh mi im bi translated">贝叶斯方法(BLR)进一步采用最大后验概率来形成预测分布。根据该分布，每个未来输入将具有相应的目标均值和方差/协方差。下面是数学的高级视图。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi na"><img src="../Images/469d5347f117b47d5a42e8bfe4fe3255.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7XRfX-2bROT7aJLVFB12EQ.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="03ba" class="pw-post-body-paragraph lq lr it ls b lt mp ju lv lw mq jx ly ld mr ma mb lh ms md me ll mt mg mh mi im bi translated">现在可以使用下面的等式获得预测分布</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi na"><img src="../Images/fe9a346eb9bea2cc7d063431c84ac714.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QpiIUZ_kaKxSBDscfh3rKQ.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="a291" class="pw-post-body-paragraph lq lr it ls b lt mp ju lv lw mq jx ly ld mr ma mb lh ms md me ll mt mg mh mi im bi translated">利用高斯分布的条件分布和边缘分布性质，可以得到后验参数分布和预测分布。更多细节见[1]的第 2 章。</p><p id="e984" class="pw-post-body-paragraph lq lr it ls b lt mp ju lv lw mq jx ly ld mr ma mb lh ms md me ll mt mg mh mi im bi translated">在上述所有方法中，我们假设我们的数据和参数的方差(即<strong class="ls iu"> <em class="mj"> w </em> </strong>)、<em class="mj"/>和<em class="mj"/>分别是已知的。实际上，这些值是未知的，可以从数据集进行估计。完整的贝叶斯治疗，我不打算在这篇文章中讨论，提供了一种称为证据近似的技术，可以用来近似这些值。然而，有几件事值得指出，我将在这里提到它们。如果<em class="mj"> α⁻ </em>很高，<strong class="ls iu"> <em class="mj"> w </em> </strong>将逼近最大似然估计。如果数据集很小，<strong class="ls iu"> <em class="mj"> w </em> </strong>将逼近先验。随着数据集大小向无穷大增加，我们预测的方差变小，接近极限<em class="mj"> β⁻ </em>。</p><h2 id="46ea" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">密码</h2><p id="e46a" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">使用 Python 代码，让我们从构建设计矩阵开始。如前所述，在这种情况下，我们将使用多项式基函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="12c1" class="pw-post-body-paragraph lq lr it ls b lt mp ju lv lw mq jx ly ld mr ma mb lh ms md me ll mt mg mh mi im bi translated">让我们首先创建一个使用最大似然估计(ML)进行回归的类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="63d2" class="pw-post-body-paragraph lq lr it ls b lt mp ju lv lw mq jx ly ld mr ma mb lh ms md me ll mt mg mh mi im bi translated">现在让我们创建一个使用最大后验概率(MAP)进行预测的类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="887d" class="pw-post-body-paragraph lq lr it ls b lt mp ju lv lw mq jx ly ld mr ma mb lh ms md me ll mt mg mh mi im bi translated">最后，让我们创建一个用于进行贝叶斯线性回归的类。请注意，这并不完全是贝叶斯方法，因为<em class="mj"> α⁻ </em>和<em class="mj"> β⁻ </em>被假定为已知的，并且应该在类实例化期间作为标准差传入。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><h2 id="1746" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">测试</h2><p id="5cc1" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">现在让我们测试我们的模型。我们将使用合成数据，因此首先我们创建一个简单的函数来生成合成数据，然后设置一些参数并准备训练和测试数据。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="7c0c" class="pw-post-body-paragraph lq lr it ls b lt mp ju lv lw mq jx ly ld mr ma mb lh ms md me ll mt mg mh mi im bi translated">现在创建模型、训练、预测和绘图，例如 ML、MAP 和 BLR:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="9cdd" class="pw-post-body-paragraph lq lr it ls b lt mp ju lv lw mq jx ly ld mr ma mb lh ms md me ll mt mg mh mi im bi translated">最后是我们的图表:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/76038da15425f6b81e4d26ad6e9328ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/1*YWCF2sa91-sAQgNxSNHH7g.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><h2 id="a7c6" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">结论</h2><p id="559b" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">在这篇文章中，我试图介绍线性回归背后的核心数学，并尝试使用 python 代码实现它。然而，正如您所看到的，该模型并不是观察到的数据的最佳拟合。主要原因是模型不够复杂，无法拟合数据(即拟合不足)。模型复杂度是模型的参数数量 M，在这个例子中，我使用了随机值 7。贝叶斯方法还提供了一种可以逼近模型复杂度最优值的方法，我可能会在另一篇文章中介绍。</p><h2 id="226a" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">参考</h2><p id="1ae0" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">[1]:主教，C. M. (2006 年)。<em class="mj">模式识别与机器学习</em>。斯普林格。</p><p id="ba5e" class="pw-post-body-paragraph lq lr it ls b lt mp ju lv lw mq jx ly ld mr ma mb lh ms md me ll mt mg mh mi im bi translated">[2]: Deisenroth，M. P .，Faisal，A. A .，&amp; Ong，C. S. (2020)。<em class="mj">机器学习的数学</em>。剑桥大学出版社。</p></div></div>    
</body>
</html>