<html>
<head>
<title>How to Track Unprocessed Objects in S3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在 S3 追踪未加工的物体</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-track-unprocessed-objects-in-s3-5a7d3b32352d?source=collection_archive---------54-----------------------#2020-07-07">https://towardsdatascience.com/how-to-track-unprocessed-objects-in-s3-5a7d3b32352d?source=collection_archive---------54-----------------------#2020-07-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a7b9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><strong class="ak">处理对象的正确方式只有一次</strong></h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a13b701ec2f2933ba398e86ca7e079b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_xPst3hqVOIwf4an"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">斯科特·韦伯在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="55f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑一个场景，其中数据对象在<code class="fe lv lw lx ly b">raw-data</code>桶被持续摄取。该数据被定期处理并存储在<code class="fe lv lw lx ly b">processed-data</code>桶中。我们的兴趣是找到一种方法，如何跟踪哪些新对象是未处理的，并处理它们。这是为了避免多次处理相同的对象。考虑下面的 AWS 服务设置作为对此场景的响应。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lz"><img src="../Images/5beee90d454feb43accc442df48d16a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hLm0QCXiG2Q0tjh5eNUDUA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">服务的主要设置</p></figure><p id="dfcf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过云，我抽象了所有不同的 AWS 服务(EMR、Lambda、EC2 等。)可以用来处理数据。正方形代表数据对象，它们的颜色代表它们的状态，如下图所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ma"><img src="../Images/71fb35f230f06f7607773adb19db40da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*seLOdf9Iwi3oXLAHj2Y1OA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">对象状态的描述</p></figure></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="7d8a" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">SQS 的解决方案</h1><p id="36ea" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">在设置中引入 SQS 队列。我把这个队列叫做<code class="fe lv lw lx ly b">raw-data-object-creation-event-queue</code>。每当在<code class="fe lv lw lx ly b">raw-data</code>桶中创建新对象时，一个消息事件将被发送到该队列。</p><p id="b1fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，在<code class="fe lv lw lx ly b">raw-data</code>桶设置一个事件监听器，监听<em class="nf">所有对象创建事件</em>的发生。如果创建了一个对象(即在此存储桶上传)，在创建的 SQS 队列发送通知事件。</p><p id="3b76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在您的处理脚本中，轮询来自 SQS 服务的事件，解析 json 消息以获取未处理数据对象的对象键。从<code class="fe lv lw lx ly b">raw-data</code>桶中读取这些对象并处理它们。在处理执行结束时，如果处理成功<strong class="lb iu">从队列中删除</strong>您轮询的事件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/5b6b1b9fb0a2e0a0ea79a48d16fb99a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*nDM1z99SB-4pnNEbL7u_5Q.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用 SQS 队列跟踪未处理的数据</p></figure><p id="4cc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">去 SQS 肯定是最容易实现的解决方案，而且也很便宜。您可以每月在每个 SQS 队列中发出 100 万个免费 SQS 请求。这意味着你可以每分钟发出 22 个请求，而且不用支付任何费用。</p><h1 id="2eda" class="mi mj it bd mk ml nh mn mo mp ni mr ms jz nj ka mu kc nk kd mw kf nl kg my mz bi translated">结论</h1><p id="4d36" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">跟踪未处理的对象对于避免多次处理同一个对象是必要的。SQS 提出的解决方案易于实施、监控，同时成本低廉。</p><p id="5f75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据用例，可以考虑其他的解决方案:跟踪最后处理的文件的时间戳<em class="nf">；</em>将原始数据对象首先存储在<code class="fe lv lw lx ly b">temp-raw-data</code>桶中，当它们被成功处理时，将它们移动到<code class="fe lv lw lx ly b">archived-raw-data</code>；<em class="nf"> </em>使用桶版本控制，在处理原始文件时将其删除。</p></div></div>    
</body>
</html>