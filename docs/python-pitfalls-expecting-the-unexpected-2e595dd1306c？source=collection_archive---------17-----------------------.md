# Python 陷阱——期待意想不到的事情

> 原文：<https://towardsdatascience.com/python-pitfalls-expecting-the-unexpected-2e595dd1306c?source=collection_archive---------17----------------------->

## 通过避免 Python 代码中的这些常见问题和陷阱，节省您的调试时间

不管你用哪种编程语言编写代码，你可能都遇到过很多奇怪的、看似无法解释的问题，这些问题最终都变成了这种特定语言的愚蠢错误或怪癖。Python 的目标是成为干净简单的语言，但它也有一些让初学者和有经验的软件开发人员感到惊讶的陷阱和怪癖。因此，为了避免对您最喜欢的编程语言中的一些奇怪问题产生不必要的愤怒和沮丧，下面列出了一些常见的 Python 陷阱，您应该不惜一切代价避免这些陷阱。

![](img/b26b1b1ceeb644a54f6e762c2ca95bb2.png)

由 [Meor Mohamad](https://unsplash.com/@meooooo?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 在 [Unsplash](https://unsplash.com/?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄的照片

# 可变的默认参数不是一个好主意

为函数设置默认参数非常常见，对于定义可选参数或通常使用相同预定义值的参数非常有用。但是，将默认参数设置为可变值(如`list`或`dict`)会导致意外行为:

使用可变值作为默认参数的问题是，每次调用函数时，默认参数都没有初始化。相反，最近使用的值将被传入，这在可变类型的情况下是一个问题。为了避免这个问题，你应该总是使用`None`或者其他不可变的类型，并如上所示对参数进行检查。

尽管这看起来很麻烦，也是一个问题，但这是一种有意的行为，也可以利用*来制作缓存函数，这些函数可以使用持久可变的默认参数作为缓存:*

与上面的默认参数类似的行为也可以在`dict.setdefault(key, value)`中看到。在下面的代码中，我们可以看到一些令人惊讶的结果:

尽管我们没有接触上面的`data`字典，但它已经通过添加默认值`val`进行了修改。这是因为当键丢失时，传递给`setdefault`的默认值被直接分配到字典中，而不是从原始值中复制。为了避免这个问题，请确保在使用`setdefault`时不要重用值。

# `NaN`(非)反身性

处理浮点数和非整数通常会很困难和烦人，但是当你进入*非数字*和*无穷大*的领域时，这就变得特别奇怪了。因此，让我们通过与这些值进行一些比较来证明这一点:

上面的代码显示了`NaN`的非自反性。Python 中的`NaN`即使和自身比较也永远比不上。所以，如果你需要测试`NaN`或`inf`，那么你应该使用`math.isnan()`和`math.isinf()`。在处理可能产生`NaN`的代码时，也要小心任何其他算术运算，因为它会在所有运算中传播，而不会引发异常。

Python 通常很聪明，通常不会从数学函数中返回`NaN`，例如`math.exp(1000.0)`将返回`OverflowError: math range error`，而`math.sqrt(-1.0)`和`math.log(0.0)`都将返回`ValueError: math domain error`，但是您可能会遇到使用 *Numpy* 或 *Pandas* 的情况，如果您这样做了，请记住不要尝试比较`NaNs`是否相等。

# 后期绑定闭包

关于 Python 中的作用域和闭包，有一些陷阱、陷阱和惊喜。我认为最常见的是闭包中的*后期绑定*。让我们从例子开始:

上面的代码显示了循环中函数的定义，然后被添加到一个列表中。随着每次迭代，`i`变量增加，定义函数中的`i`变量也增加，对吗？*错了。*

*后期绑定*导致所有函数都假定值为 2(来自上一次迭代)。这是因为闭包中定义了所有的函数——全局函数。因此，它们都引用同一个在循环中变异的`i`。

解决这个问题的方法不止一种，但我认为最干净的方法是使用`functools.partial`:

使用`partial`我们可以创建新的带有预定义`i`的可调用对象，强制变量立即绑定*从而解决问题。然后，当我们想要实际调用函数时，我们可以提供剩余的原始参数`n`。*

# *重新分配全局变量*

*使用大量的全局变量通常是不鼓励的，并且被认为是一种不好的做法。然而，使用一些全局变量是有正当理由的——例如定义各种*标志*，这些标志可用于设置函数的日志级别。*

*但是如果你决定翻转(重新分配)这个标志呢？嗯，它会引起严重的头痛:*

*看上面的代码，你可能会认为在执行了`some_func()`之后，全局`flag`变量的值会变成`True`，但事实并非如此。`some_func`声明*新的局部*变量`flag`，将其设置为`True`，然后在函数体结束后消失。全局变量永远不会被触及。*

*不过，有一个简单的解决办法。我们需要首先在函数体中声明我们想要引用全局变量，而不是使用局部变量。我们用`global <var_name>`做这个——在这个例子中是`global flag`:*

*你可能遇到的另一个*【有趣】*变量问题是*超出范围*变量的修改——幸运的是，这更容易调试和修复。与前面的问题类似，这是由于操作在外部作用域中定义的变量引起的:*

*这里我们尝试在函数范围内增加变量`var`，假设它会修改全局变量。但同样，这是错误的。*

*当你修改变量时，它就变成了这个作用域的局部变量，但是你不能增加之前没有声明的变量(在当前作用域中)，所以`UnboundLocalError`被抛出。*

*在全局变量的情况下，这也可以使用`global <var_name>`来解决。这种所谓的*作用域错误*也可能发生在嵌套函数中，此时您应该使用`nonlocal <var_name>`来引用最近的外部作用域中的变量:*

# *定义元组的正确方法*

*几乎每个 Python 开发人员都有一个根深蒂固的误解，即元组是由括号定义的。与像`dict`或`set`这样的可重复项不同，Python `tuple`是通过逗号分隔元素来定义的。*

*源自这种误解的错误通常出现在我们试图用单个元素定义元组时:*

*在上面的代码片段中，我们可以看到有必要在单数元素后添加`,`以使 Python 将其识别为 tuple。我们也可以完全省略括号，这在返回多个值的`return`语句中很常见。*

*上面的最后一个例子显示了一个类似的陷阱。如果您忘记用逗号分隔元素，Python 将使用隐式串联，使其成为类型字符串的单个值。这种隐式连接可以发生在代码中的任何地方，而不仅仅是在定义 tuple 时，所以如果你的程序有问题，一定要仔细检查你的字符串和 iterables。*

# *索引字节值而不是字节字符串*

*当处理文件和其中的数据时，我们通常只使用 ASCII 或 UTF-8 字符串。然而，有时您可能不得不读写一些二进制数据，并且您可能会对索引和迭代它们的结果感到惊讶:*

*当索引到二进制字符串时，我们得到的不是字节字符串，而是整数字节值，换句话说，就是被索引字符的序数值。为了避免这种情况——尤其是在读取二进制文件时——最好总是使用`text.decode('utf-8')`来获得正确的字符串。但是，如果您想将原始数据保存为二进制字符串，那么您可以使用`chr(c)`将单个字符转换为字符串表示。*

# *使用取反变量进行索引*

*切片和切块是 Python 最方便的特性之一，包括指定负索引的能力，但是如果不小心，可能会得到意想不到的结果:*

*如果我们用除了`-0`之外的任何负值(变量)对一个序列进行切片，我们将得到预期的值，但是如果我们碰巧使用`[-0:]`进行切片，我们将得到整个序列的副本，因为它等同于`[:]`。*

# *为什么它一个也不返回！？*

*我把我的*【最爱】*留到了最后。很容易忘记函数是返回新值还是就地修改原来的*。特别是当一般有两种类型的方法时——*列出修改参数的*方法，返回原地修改参数*的`None`和*字符串*方法。***

*我犯了太多次这样的错误。很容易忘记许多字符串或列表方法之一的行为，这可能会导致数小时的调试。所以，如果你在应该是整个字符串或列表的地方收到了`None`，那么仔细检查以确保你正确地使用了上面显示的所有方法。*

# *结论*

*这是不可避免的，你会遇到这些或其他类似的陷阱和陷阱，这将导致很多愤怒和沮丧。通常情况下，解决这些问题的最好方法是暂时退后一步。去散步。去冲杯咖啡。或者至少深呼吸一下。大多数情况下，解决这样一个问题所需要的就是把它留一会儿，以后再回来。*

*如果这没有帮助，也许是时候进行一些橡皮鸭调试或引入另一双眼睛(坐在你旁边的同事)。通常，当你开始向别人解释问题时，你会立刻意识到问题到底出在哪里。*

*当您最终找到错误并设法解决它时，花一点时间想想您可以做些什么来更快地找到它。下一次你遇到类似的问题时，你也许能更快地解决它。*

**本文原帖*[*martinheinz . dev*](https://martinheinz.dev/blog/37?utm_source=tds&utm_medium=referral&utm_campaign=blog_post_37)*

*[](/ultimate-guide-to-python-debugging-854dea731e1b) [## Python 调试终极指南

### 让我们探索使用 Python 日志记录、回溯、装饰器等等进行调试的艺术…

towardsdatascience.com](/ultimate-guide-to-python-debugging-854dea731e1b) [](/writing-more-idiomatic-and-pythonic-code-c22e900eaf83) [## 编写更加地道和 Pythonic 化的代码

### 使你的 Python 代码可读、有效、简洁和可靠的习惯用法和惯例。

towardsdatascience.com](/writing-more-idiomatic-and-pythonic-code-c22e900eaf83) [](/the-magic-of-python-context-managers-adb92ace1dd0) [## Python 上下文管理器的魔力

### 使用和创建令人敬畏的 Python 上下文管理器的方法，这将使你的代码更具可读性、可靠性和…

towardsdatascience.com](/the-magic-of-python-context-managers-adb92ace1dd0)*