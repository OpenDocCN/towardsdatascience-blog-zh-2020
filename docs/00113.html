<html>
<head>
<title>Finding performance bottlenecks in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 Python 中寻找性能瓶颈</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/finding-performance-bottlenecks-in-python-4372598b7b2c?source=collection_archive---------5-----------------------#2020-01-04">https://towardsdatascience.com/finding-performance-bottlenecks-in-python-4372598b7b2c?source=collection_archive---------5-----------------------#2020-01-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1b7f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">是什么让你的代码如此缓慢？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/446e5c504b0daabe93191fe0f38cba5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VBtenIyker3iL-cFgFPuhA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://pixabay.com/images/id-382992/" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="0e23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将解释如何分析一段代码，并可能发现性能瓶颈。</p><h1 id="c1a4" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">让我们首先创建瓶颈</h1><p id="a86c" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">假设我们需要创建一个在循环上迭代的脚本，每次循环执行都会产生一个依赖于当前迭代的值和一个独立值。独立值是初始设置的一部分，这可能是一个相对繁重的功能:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="5caf" class="mx lw it mt b gy my mz l na nb">import time</span><span id="e984" class="mx lw it mt b gy nc mz l na nb">def initial_setup():<br/>  a = 7<br/>  time.sleep(1)<br/>  return a</span></pre><p id="0261" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的“initial_setup”函数只是返回一个固定值，但是我添加了一个 1 秒钟的<a class="ae ky" href="https://docs.python.org/3/library/time.html#time.sleep" rel="noopener ugc nofollow" target="_blank"> time.sleep() </a>调用来模拟一个更重的函数。让我们继续构建脚本的主函数，我们姑且称之为“slow_function”。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="5f39" class="mx lw it mt b gy my mz l na nb">def slow_function():<br/>  x = range(5)<br/>  for i in x:<br/>    a = initial_setup()<br/>    b = a + i<br/>    print(b)</span></pre><p id="3aa2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的新函数只是简单地迭代[0，4]并将当前数字添加到初始设置中返回的固定数字。您可能已经注意到，我在循环块中错误地调用了“initial_setup()”。即使结果是正确的，这仍然是一个性能错误，因为“initial_setup()”不依赖于循环迭代，而且，它是一个很重的函数。</p><p id="e395" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论如何，让我们假装没有注意到，并测试我们的解决方案。您应该会得到以下结果:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="4c94" class="mx lw it mt b gy my mz l na nb">7<br/>8<br/>9<br/>10<br/>11</span></pre><p id="a4b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很管用，对吧？虽然它比我预期的要长…我不知道是什么让它这么慢，所以也许是时候使用 Python 的分析器了…</p><h1 id="c729" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">cProfile 入门</h1><p id="7efa" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们需要剖析我们的功能，并找出是什么阻碍了它的性能！幸运的是，Python 提供了一个可以帮助我们完成这项任务的模块:<a class="ae ky" href="https://docs.python.org/3/library/profile.html#module-cProfile" rel="noopener ugc nofollow" target="_blank"> cProfile </a>。我们将从创建 Profile 类的一个实例开始:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="7cd8" class="mx lw it mt b gy my mz l na nb">import cProfile</span><span id="63e7" class="mx lw it mt b gy nc mz l na nb">profile = cProfile.Profile()</span></pre><p id="5a81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在准备好分析我们的函数了！我们将开始使用一种简单的方法，使用 runcall()方法，它接收要分析的函数(及其参数，如果有的话)。在我们的例子中，我们想要分析“slow_function()”，所以我们将添加以下指令:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="bc29" class="mx lw it mt b gy my mz l na nb">import cProfile</span><span id="24ea" class="mx lw it mt b gy nc mz l na nb">profile = cProfile.Profile()<br/>profile.runcall(slow_function)</span></pre><p id="76d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果您运行上面的代码片段，您将会看到，显然，什么都没有发生。至少，在 stdout 中没有输出任何分析信息。这是因为我们缺少了拼图的最后一块:<a class="ae ky" href="https://docs.python.org/3/library/profile.html#pstats.Stats" rel="noopener ugc nofollow" target="_blank"> pstats </a>。让我们继续将它添加到我们的代码片段中:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="8328" class="mx lw it mt b gy my mz l na nb">import cProfile<br/>import pstats</span><span id="6c38" class="mx lw it mt b gy nc mz l na nb">profile = cProfile.Profile()<br/>profile.runcall(slow_function)<br/>ps = pstats.Stats(profile)<br/>ps.print_stats()</span></pre><p id="42f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，我们将“profile”实例传递给了构造函数<a class="ae ky" href="https://docs.python.org/3/library/profile.html#pstats.Stats" rel="noopener ugc nofollow" target="_blank"> Stats </a>来创建这个类的新实例“ps”。这个实例最终允许我们打印分析结果。</p><p id="2af9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，说够了(或写够了)，让我们运行我们的代码片段，看看我们得到了什么！</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="e617" class="mx lw it mt b gy my mz l na nb">7<br/>8<br/>9<br/>10<br/>11<br/>         17 function calls in 5.011 seconds</span><span id="e55e" class="mx lw it mt b gy nc mz l na nb">   Random listing order was used</span><span id="b9f2" class="mx lw it mt b gy nc mz l na nb">   ncalls  tottime  percall  cumtime  percall filename:lineno(function)<br/>        5    0.001    0.000    0.001    0.000 {built-in method builtins.print}<br/>        5    5.010    1.002    5.010    1.002 {built-in method time.sleep}<br/>        5    0.000    0.000    5.010    1.002 python-performance-bottlenecks.py:5(initial_setup)<br/>        1    0.000    0.000    5.011    5.011 python-performance-bottlenecks.py:10(slow_function)<br/>        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}</span></pre><h1 id="2546" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">如何解读 print_stats()的结果？</h1><p id="201b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">很好！我们现在可以看到一系列信息，这些信息应该可以指出性能瓶颈。为了找到它，我们应该首先理解每一列的含义。</p><ul class=""><li id="6892" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">ncalls:被分析的函数被调用的次数</li><li id="71f7" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">tottime:在分析的函数中花费的总执行时间(不包括子函数的执行时间)</li><li id="c19d" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">percall:总时间除以 ncalls</li><li id="4301" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">累计时间:所分析的函数花费的总执行时间(包括子函数的执行时间)</li><li id="6bee" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">percall:累计时间除以 ncalls</li><li id="ab89" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">文件名:行号(函数):文件、行号和分析的函数</li></ul><p id="4a71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们理解了每一列的含义，我们可以寻找阻碍我们表现的原因。嗯…哦！“initial_setup()”被调用了 5 次。实际上累计执行时间在 5 秒以上！这是有意义的，因为我在 for 循环中错误地调用了“initial_setup()”!好吧，我在循环外调用它，因为它不依赖于它。</p><p id="772a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经解决了第一个性能问题！现在，我们将如何解决未来的瓶颈？我们应该一直关注 ncalls 吗？嗯，有时候。但有时，我们会面临另一种问题，ncalls 不会告诉我们任何事情。例如，我们可能不得不处理一个只被调用一次，但是非常慢的函数。作为一般策略，我倾向于首先查看具有较高累积时间(cumtime)的函数，然后检查是否有任何函数在 ncalls 中表现突出。然而，我要说的是，选择一个策略是一个相当个人化的旅程，是我们根据自己的经验建立起来的。</p><h1 id="9a97" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">更灵活的分析方法</h1><p id="9f18" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">有时，您可能不想分析整个函数，而只想分析它的一部分。这也是可能的，而且很容易，方法如下:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="f4bf" class="mx lw it mt b gy my mz l na nb">def slow_function():<br/>  profile = cProfile.Profile()<br/>  profile.enable()<br/>  x = range(5)<br/>  for i in x:<br/>    a = initial_setup()<br/>    b = a + i<br/>    print(b)<br/>  profile.disable()<br/>  ps = pstats.Stats(profile)<br/>  ps.print_stats()</span></pre><p id="601d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们必须将我们想要分析的代码片段放在“profile.enable()”和“profile.disable()”之间。请记住，在这种情况下，我们正在分析一个玩具示例，但在实际情况下，您可能必须分析一个更大的函数，因此，如果您怀疑瓶颈可能在哪里，限制被分析的代码片段的范围总是有用的。</p><p id="0242" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，<a class="ae ky" href="https://docs.python.org/3/whatsnew/3.8.html#cprofile" rel="noopener ugc nofollow" target="_blank">从 Python 3.8 </a>开始，您还可以选择将其用作上下文管理器，将“profile”实例的范围限制在封闭的块中:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="3752" class="mx lw it mt b gy my mz l na nb">with cProfile.Profile() as profile:<br/>  x = range(5)<br/>  for i in x:<br/>    a = initial_setup()<br/>    b = a + i<br/>    print(b)<br/>  ps = pstats.Stats(profile)<br/>  ps.print_stats()</span></pre><h1 id="dbe1" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">充分利用 pstats</h1><p id="39fd" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">一旦您开始在真实世界的代码库中进行分析，您将会看到打印的统计数据会大得多，因为您可能会分析更大的代码片段。嗯，在某些时候，有这么多的信息，它变得有点混乱。幸运的是，<a class="ae ky" href="https://docs.python.org/3/library/profile.html#pstats.Stats" rel="noopener ugc nofollow" target="_blank"> pstats </a>可以帮助您使这些信息更易于管理。</p><p id="3f85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，您可以使用<a class="ae ky" href="https://docs.python.org/3/library/profile.html#pstats.Stats.sort_stats" rel="noopener ugc nofollow" target="_blank"> sort_stats() </a>来确定打印函数的顺序(您也可以在链接中找到可用的排序键)。例如，根据呼叫次数或累计时间对其进行分类可能会有所帮助。您可以定义多个排序键，按照键的顺序定义它们的优先级。另一个方便的选择是设置打印功能数量的限制。你可以通过传递一个整数给<a class="ae ky" href="https://docs.python.org/3/library/profile.html#pstats.Stats.print_stats" rel="noopener ugc nofollow" target="_blank"> print_stats() </a>来实现。让我们修改我们的示例，按照 ncalls 和 cumtime 的顺序对输出进行排序，并限制为 3 个函数:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="7c87" class="mx lw it mt b gy my mz l na nb">def slow_function():<br/>  profile = cProfile.Profile()<br/>  profile.enable()<br/>  x = range(5)<br/>  for i in x:<br/>    a = initial_setup()<br/>    b = a + i<br/>    print(b)<br/>  profile.disable()<br/>  ps = pstats.Stats(profile)<br/>  ps.sort_stats('calls', 'cumtime') <br/>  ps.print_stats(3)</span></pre><p id="a057" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您的输出应该如下所示:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="e95e" class="mx lw it mt b gy my mz l na nb">7<br/>8<br/>9<br/>10<br/>11<br/>         17 function calls in 5.017 seconds</span><span id="5a57" class="mx lw it mt b gy nc mz l na nb">   Ordered by: call count, cumulative time<br/>   List reduced from 5 to 3 due to restriction &lt;3&gt;</span><span id="9ee9" class="mx lw it mt b gy nc mz l na nb">   ncalls  tottime  percall  cumtime  percall filename:lineno(function)<br/>        5    0.000    0.000    5.016    1.003 python-performance-bottlenecks.py:5(initial_setup)<br/>        5    5.016    1.003    5.016    1.003 {built-in method time.sleep}<br/>        5    0.001    0.000    0.001    0.000 {built-in method builtins.print}</span></pre><p id="44b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，已经应用了定义的顺序和限制。还要注意，这些限制是在输出中声明的。</p><p id="dd9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，就这样，你现在已经准备好让你的代码更快了！</p></div></div>    
</body>
</html>