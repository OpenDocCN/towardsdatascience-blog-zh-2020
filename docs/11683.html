<html>
<head>
<title>Practical Cython— Music Retrieval: Short Time Fourier Transform</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实用 cy thon——音乐检索:短时傅里叶变换</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/practical-cython-music-retrieval-short-time-fourier-transform-f89a0e65754d?source=collection_archive---------20-----------------------#2020-08-13">https://towardsdatascience.com/practical-cython-music-retrieval-short-time-fourier-transform-f89a0e65754d?source=collection_archive---------20-----------------------#2020-08-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c828" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你想知道更多关于 Cython 的事情吗？在本系列中跟随我，我将向您展示 C-Cython-Python 实现的实际例子</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/42cc1f489b435d3c92ac5dc304e25dee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3hGrV9PmGhBI_7n3AZswsQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">《时间的压缩》声谱图，最终幻想 8【https://www.youtube.com/watch?v=l75zjpDpAWs T4】</p></figure><div class="kz la gp gr lb lc"><a href="https://medium.com/@stefanobosisio1/membership" rel="noopener follow" target="_blank"><div class="ld ab fo"><div class="le ab lf cl cj lg"><h2 class="bd iu gy z fp lh fr fs li fu fw is bi translated">通过我的推荐链接加入 Medium-Stefano Bosisio</h2><div class="lj l"><h3 class="bd b gy z fp lh fr fs li fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="lk l"><p class="bd b dl z fp lh fr fs li fu fw dk translated">medium.com</p></div></div><div class="ll l"><div class="lm l ln lo lp ll lq ks lc"/></div></div></a></div><p id="1ad5" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我非常喜欢 Cython，因为它吸取了两个主要编程领域的精华:C 和 Python。这两种语言可以以一种简单明了的方式结合在一起，以便为您提供计算效率更高的 API 或脚本。此外，用 Cython 和 C 编写代码有助于您理解常见 python 包(如<code class="fe mn mo mp mq b">sklearn</code>)下的内容，让数据科学家更进一步，这与简单的<code class="fe mn mo mp mq b">import torch</code>和预定义算法用法相去甚远。</p><p id="8472" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在这个系列中，我将向你展示如何用 C 和 Cyhton 算法来分析音乐，下面是相应的<code class="fe mn mo mp mq b">sklearn</code>和<code class="fe mn mo mp mq b">scipy</code>软件包作为参考。</p><p id="66c5" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这一课讲的是<a class="ae ky" href="https://en.wikipedia.org/wiki/Short-time_Fourier_transform" rel="noopener ugc nofollow" target="_blank">短时傅立叶变换</a>或 STFT。这种算法广泛用于分析信号的频率及其随时间的演变。代码存储在以下存储库中:</p><div class="kz la gp gr lb lc"><a href="https://github.com/Steboss/music_retrieval/tree/master/stft" rel="noopener  ugc nofollow" target="_blank"><div class="ld ab fo"><div class="le ab lf cl cj lg"><h2 class="bd iu gy z fp lh fr fs li fu fw is bi translated">ste boss/音乐 _ 检索</h2><div class="lj l"><h3 class="bd b gy z fp lh fr fs li fu fw dk translated">用于检索音乐信息的 python-c-cython 工具小套件</h3></div><div class="lk l"><p class="bd b dl z fp lh fr fs li fu fw dk translated">github.com</p></div></div><div class="ll l"><div class="mr l ln lo lp ll lq ks lc"/></div></div></a></div><p id="6d99" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这些代码对于理解如何构建 Cython 项目、在文件夹中细分代码以及安装最终的包非常有用。</p><p id="5966" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">此帖子包含亚马逊联盟计划的外部链接。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="ea02" class="mz na it bd nb nc nd ne nf ng nh ni nj jz nk ka nl kc nm kd nn kf no kg np nq bi translated">外行理论</h1><p id="2e53" class="pw-post-body-paragraph lr ls it lt b lu nr ju lw lx ns jx lz ma nt mc md me nu mg mh mi nv mk ml mm im bi translated">如果您想立即接触这些代码，可以跳过这一部分。这只是对 STFT 及其理论的简单介绍。</p><p id="6ade" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">傅立叶变换的主要方面是将信号映射(或者说绘制)到频域，指出构成信号本身的最重要频率。这种映射在许多领域具有广泛的含义:在生物医学工程(例如，研究心电图(ECG)中的频率贡献，以检测可能的疾病或心脏功能障碍<a class="ae ky" href="https://onlinelibrary.wiley.com/doi/full/10.1002/jmri.1160" rel="noopener ugc nofollow" target="_blank"> </a> <a class="ae ky" href="https://www.sciencedirect.com/science/article/abs/pii/S0010482516302104" rel="noopener ugc nofollow" target="_blank"> </a> <a class="ae ky" href="https://www.scirp.org/html/4708.html" rel="noopener ugc nofollow" target="_blank"> </a>)、计算科学(例如，压缩算法，如<code class="fe mn mo mp mq b">mp3, jpeg</code><a class="ae ky" href="https://www.roe.ac.uk/japwww/teaching/fourier/compression.html" rel="noopener ugc nofollow" target="_blank">【⁴</a>)或金融(例如，研究股票价格、债券价格行为<a class="ae ky" href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.307.8732&amp;rep=rep1&amp;type=pdf" rel="noopener ugc nofollow" target="_blank">、⁵ </a>)。这种映射也有利于研究音乐信号，因为可以检索和分析主要频率内容，例如，创建流派分类器或类似 Shazam 的应用程序(例如<a class="ae ky" href="https://www.instagram.com/p/BWh54ImAg4a/" rel="noopener ugc nofollow" target="_blank">检查我的帖子</a>)。然而，了解频率在时间和幅度上的演变有时是有趣和有帮助的，以便找到特定的噪声或在记录会话中均衡频率，或创建神经网络算法来将语音信号转换为文本(例如<a class="ae ky" href="https://github.com/deepmipt/DeepPavlov" rel="noopener ugc nofollow" target="_blank"> DeepPavlov </a>)。</p><p id="19d1" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在实践中，STFT 将时间信号分成等长的小段(<code class="fe mn mo mp mq b">window_length</code>)，然后计算每段的傅立叶变换。由此产生的分段频率内容可以相对于时间绘制，它被称为<em class="nw">频谱图。</em></p><p id="efdc" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">实际上，STFT 可以概括为以下几个步骤:</p><ul class=""><li id="23ab" class="nx ny it lt b lu lv lx ly ma nz me oa mi ob mm oc od oe of bi translated">获取一个输入信号(例如 mp3 文件)</li><li id="c86d" class="nx ny it lt b lu og lx oh ma oi me oj mi ok mm oc od oe of bi translated">将信号乘以窗口函数(例如<a class="ae ky" href="https://en.wikipedia.org/wiki/Window_function" rel="noopener ugc nofollow" target="_blank">汉明函数</a>)。这将有助于在每个片段的极端处计算傅立叶变换，以避免信号中可能的不连续性，这种不连续性可能会阻碍傅立叶变换计算</li><li id="4642" class="nx ny it lt b lu og lx oh ma oi me oj mi ok mm oc od oe of bi translated">沿着信号/时间滑动一个窗口和一个跳跃大小的窗口，并计算傅立叶变换</li></ul><p id="b4d7" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">图 1 有助于更好地理解 STFT 做了什么。具有定义的幅度(以分贝为单位)和时间(以秒为单位)的输入信号被封装在大小为<em class="nw">窗口大小的<em class="nw"> N </em>个窗口中。</em>每个<em class="nw"> HopSize，</em>窗口定义一个信号段，该信号段被傅立叶变换。输出频率(单位:赫兹)可以绘制成时间的函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/30110a83f9155a2e222fe24bf7f181b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i45cRw41dSDkPCjYVNAR9g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 1: STFT 的缩影。定义了窗口大小和跳跃大小。对于每个窗口段，计算傅立叶变换。频率内容可以显示为时间的函数</p></figure><p id="e98c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">最后要记住的是<a class="ae ky" href="https://en.wikipedia.org/wiki/Nyquist_frequency#:~:text=The%20Nyquist%20frequency%20is%20half,cycles%20per%20second%20(hertz)." rel="noopener ugc nofollow" target="_blank">奈奎斯特频率</a>。如果查看频谱图，您会发现最大绘制频率是信号采样频率的一半，以避免傅立叶变换中的<em class="nw">混叠</em>问题。这意味着从信号中检索的<em class="nw"> N </em>个复傅立叶系数中，具有采样频率<em class="nw"> fs </em>(例如，音频文件通常具有 44100 Hz 的采样频率)的只有一半是有用的，代表从 0 到<em class="nw"> fs/2 </em>的频率</p><p id="18f3" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">要了解更多信息，我强烈推荐这些非常有价值和有用的书籍:</p><ul class=""><li id="48da" class="nx ny it lt b lu lv lx ly ma nz me oa mi ob mm oc od oe of bi translated"><a class="ae ky" href="https://www.amazon.co.uk/gp/product/3319723138/ref=as_li_tl?ie=UTF8&amp;camp=1634&amp;creative=6738&amp;creativeASIN=3319723138&amp;linkCode=as2&amp;tag=stefanobosisi-21&amp;linkId=dcd9dc69686225384e98e26930e49fe5" rel="noopener ugc nofollow" target="_blank">振荡和波的物理学:使用 Matlab 和 Python(物理学本科教材)</a></li><li id="a776" class="nx ny it lt b lu og lx oh ma oi me oj mi ok mm oc od oe of bi translated"><a class="ae ky" href="https://www.amazon.co.uk/gp/product/0486240614/ref=as_li_tl?ie=UTF8&amp;camp=1634&amp;creative=6738&amp;creativeASIN=0486240614&amp;linkCode=as2&amp;tag=stefanobosisi-21&amp;linkId=b41d92ad0c7c671cead4ff5d8b27423c" rel="noopener ugc nofollow" target="_blank">信息论、符号、信号和噪声介绍(多佛数学书籍)</a></li><li id="ea5b" class="nx ny it lt b lu og lx oh ma oi me oj mi ok mm oc od oe of bi translated"><a class="ae ky" href="https://www.amazon.co.uk/gp/product/0486685225/ref=as_li_tl?ie=UTF8&amp;camp=1634&amp;creative=6738&amp;creativeASIN=0486685225&amp;linkCode=as2&amp;tag=stefanobosisi-21&amp;linkId=549a77575f734559f132ad217c0a3e13" rel="noopener ugc nofollow" target="_blank">傅立叶变换(多佛数学书籍)</a></li></ul></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="ab0d" class="mz na it bd nb nc nd ne nf ng nh ni nj jz nk ka nl kc nm kd nn kf no kg np nq bi translated">塞顿的 STFT:让我们玩得开心</h1><h2 id="b545" class="om na it bd nb on oo dn nf op oq dp nj ma or os nl me ot ou nn mi ov ow np ox bi translated">行动（或活动、袭击）计划</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/e8534c192128e434a29467c99945628f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zVelbUD_GfXCXKeLh6wRDw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 2:从 Python 到 Cython 和 C 的实现示意图</p></figure><p id="61c1" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">图 2 显示了在 Cython 和 C 中实现 STFT 的行动计划。整个过程可以分为三个部分，分别使用 Python、Cython 和 C:</p><ol class=""><li id="4141" class="nx ny it lt b lu lv lx ly ma nz me oa mi ob mm oz od oe of bi translated">Python 接口处理信号的输入/输出和操作:</li></ol><ul class=""><li id="f276" class="nx ny it lt b lu lv lx ly ma nz me oa mi ob mm oc od oe of bi translated">用<code class="fe mn mo mp mq b">scipy</code>或<code class="fe mn mo mp mq b">pydub</code>打开 mp3/wav 输入文件</li><li id="03a6" class="nx ny it lt b lu og lx oh ma oi me oj mi ok mm oc od oe of bi translated">左声道和右声道被隔离，只分析<code class="fe mn mo mp mq b">channel[:,0]</code></li><li id="e2f2" class="nx ny it lt b lu og lx oh ma oi me oj mi ok mm oc od oe of bi translated">对信号进行填充，因此元素总数是 2 的幂，这提高了傅立叶变换库的性能<code class="fe mn mo mp mq b">fftw</code></li></ul><p id="8937" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">2.Cython 接口将 Cython 输入转换为 memoryviews，然后可以很容易地将 memoryviews 作为指向 C 套件的指针传递:</p><ul class=""><li id="3b8f" class="nx ny it lt b lu lv lx ly ma nz me oa mi ob mm oc od oe of bi translated">为了有一个具体的概念，图 3 展示了一个例子，它从一个长度为<code class="fe mn mo mp mq b">n_elements</code>的零数组<code class="fe mn mo mp mq b">np.zeros</code>中创建一个内存视图</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pa pb l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 3:在 Cython 中创建 memoryview 的例子</p></figure><p id="6655" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">3.C 接口执行核心的 STFT 操作。简而言之:</p><ul class=""><li id="20c0" class="nx ny it lt b lu lv lx ly ma nz me oa mi ob mm oc od oe of bi translated">用<code class="fe mn mo mp mq b">fftw</code>元素定义<code class="fe mn mo mp mq b">fftw3</code>库域并进行规划。该计划是执行快速傅立叶变换所必需的:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pa pb l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 4:用 C 语言初始化 fftw 元素和计划</p></figure><ul class=""><li id="b71b" class="nx ny it lt b lu lv lx ly ma nz me oa mi ob mm oc od oe of bi translated">创建一个汉明窗口</li><li id="aa5d" class="nx ny it lt b lu og lx oh ma oi me oj mi ok mm oc od oe of bi translated">执行 STFT 循环:将输入块乘以汉明窗口，计算输出的快速傅立叶变换，存储一半结果。</li></ul><p id="312d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">需要强调的是，当前的结构确保计算最密集的操作在 C 代码中执行，然后所有信息返回给 Python。这可以降低计算成本——因为许多算法仅由 Python 实现，而不是用 C 语言实现——并提高 Python 代码的整体性能。</p><h2 id="9f7c" class="om na it bd nb on oo dn nf op oq dp nj ma or os nl me ot ou nn mi ov ow np ox bi translated">Python 脚本</h2><p id="2904" class="pw-post-body-paragraph lr ls it lt b lu nr ju lw lx ns jx lz ma nt mc md me nu mg mh mi nv mk ml mm im bi translated">代码:<a class="ae ky" href="https://github.com/Steboss/music_retrieval/blob/master/stft/installer/tester.py" rel="noopener ugc nofollow" target="_blank">https://github . com/ste boss/music _ retrieval/blob/master/STFT/installer/tester . py</a></p><p id="e8c4" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Python 脚本处理输入音频文件，并为将要执行的 STFT 准备所有信息。</p><p id="bac3" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">首先，<code class="fe mn mo mp mq b">pydub</code>可以用来打开和读取 mp3 文件，而<code class="fe mn mo mp mq b">scipy</code>提供了一个内置功能来读取 wav 扩展名:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pa pb l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 5:如何打开 mp3 和 wav 文件</p></figure><p id="5e3b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">然后，我们可以在代码中定义所有的“常数”,并调用 STFT:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pa pb l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 Python 中关键参数的定义，准备 stft 调用</p></figure><p id="a3d5" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在图 6 中，定义了<code class="fe mn mo mp mq b">windowSize</code>和<code class="fe mn mo mp mq b">hopSize</code>。如图 1 所示，这两个量可以重叠。一般来说，随着时间的推移，重叠越多，分析点越多，结果越平滑，但代价是更高的计算成本。总的来说，对于本教程，我们可以达到相同的大小，但尽可能自由地尝试。</p><h2 id="405d" class="om na it bd nb on oo dn nf op oq dp nj ma or os nl me ot ou nn mi ov ow np ox bi translated">Cython 代码</h2><p id="259c" class="pw-post-body-paragraph lr ls it lt b lu nr ju lw lx ns jx lz ma nt mc md me nu mg mh mi nv mk ml mm im bi translated">代码:<a class="ae ky" href="https://github.com/Steboss/music_retrieval/blob/master/stft/installer/stft.pyx" rel="noopener ugc nofollow" target="_blank">https://github . com/ste boss/music _ retrieval/blob/master/STFT/installer/STFT . pyx</a></p><p id="61a4" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Cython 代码通常有两个扩展名:<code class="fe mn mo mp mq b">pyx</code>和<code class="fe mn mo mp mq b">pxd</code>。前者是编写主代码的地方，而后者用于声明。在本教程中，我们将只使用<code class="fe mn mo mp mq b">pyx</code>扩展，以便更熟悉 Cython，并且只需处理一段代码。</p><p id="1a9f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">第一步是在 Cython 中导入我们的 c 代码——稍后我们将看到 c 代码是如何构造的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pa pb l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 7:在 Cython 中导入 c 代码</p></figure><p id="eae2" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">使用<code class="fe mn mo mp mq b">cdef extern from YOUR_C_CODE:</code>声明导入 c 代码。接下来，我们要使用的 C 函数的名字，必须和所有类型一起声明，就像我们在 C 代码中一样。因此，函数<code class="fe mn mo mp mq b">stft</code>返回一个数组作为指针，所以<code class="fe mn mo mp mq b">double*</code>为<code class="fe mn mo mp mq b">stft</code> C 函数。参数是输入音频通道<code class="fe mn mo mp mq b">double *wav_data</code>，最终 STFT 信号内的样本数量<code class="fe mn mo mp mq b">int samples</code>，窗口和跳跃大小<code class="fe mn mo mp mq b">int windowSize, int hop_Size</code>，采样频率和音频通道长度<code class="fe mn mo mp mq b">int sample_freq, int length</code>。<code class="fe mn mo mp mq b">samples</code>可以计算为:</p><pre class="kj kk kl km gt pc mq pd pe aw pf bi"><span id="8e06" class="om na it mq b gy pg ph l pi pj">samples = int((length/windowSize/2))*((windowSize/2)+1))</span></pre><p id="e16f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">下一步是创建和声明我们的主函数。，它将在我们的 python 脚本中被调用(这里它的名字是<code class="fe mn mo mp mq b">play</code>):</p><p id="55a1" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><code class="fe mn mo mp mq b">cpdef play(audData, rate, windowSize, hopSize):</code></p><p id="9a44" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><code class="fe mn mo mp mq b">cpdef</code>声明下面的函数将包含 C 和 Python 代码和类型。如果我们想直接调用一个 Python 函数和用于声明一个纯 C 函数的<code class="fe mn mo mp mq b">cdef</code>，进一步的选项是按照普通 Python 的<code class="fe mn mo mp mq b">def</code>。</p><p id="aa4d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">第二个重要的概念是将所有参数传递给主<code class="fe mn mo mp mq b">stft</code> C 函数，如图 8 所示</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pa pb l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 8:调用 c 函数 stft 传递 Cython 参数</p></figure><p id="33ac" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">基本上，内存视图可以很容易地传递给 C 函数，它们将被视为 1D 数组。首先，要创建 memoryview，必须定义类型和大小。图 8 的第 2 行和第 6 行显示了如何创建 1D 内存视图:<code class="fe mn mo mp mq b">cdef double[:] name_of_memory_view = content</code>其中<code class="fe mn mo mp mq b">[:]</code>定义了一个 1D 内存视图。最后，内存视图可以像第 8 行中对<code class="fe mn mo mp mq b">&amp;audData_view[0]</code>和<code class="fe mn mo mp mq b">&amp;magnitude[0]</code>所做的那样作为<code class="fe mn mo mp mq b">&amp;name_of_memory_view[0]</code>传递给 C 函数。在接下来的教程中，我将更详细地向你展示如何处理 2D 内存视图并将它们传递给 C，因为这必须处理内存缓冲区。值得注意的是，在第 8 行中<code class="fe mn mo mp mq b">&amp;magnitude[0]</code>作为 0 的向量传递给 C。这允许处理 C 中已经初始化的指针，并用 STFT 值填充它们。</p><h2 id="0eb9" class="om na it bd nb on oo dn nf op oq dp nj ma or os nl me ot ou nn mi ov ow np ox bi translated">c 代码</h2><p id="eb63" class="pw-post-body-paragraph lr ls it lt b lu nr ju lw lx ns jx lz ma nt mc md me nu mg mh mi nv mk ml mm im bi translated">code:<a class="ae ky" href="https://github.com/Steboss/music_retrieval/blob/master/stft/c_code/stft.c" rel="noopener ugc nofollow" target="_blank">https://github . com/ste boss/music _ retrieval/blob/master/STFT/c _ code/STFT . c</a></p><p id="9776" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">第一步是导入必要的库:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pa pb l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 9:用于 STFT 算法的 C 库</p></figure><p id="6fb9" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><code class="fe mn mo mp mq b">fftw3</code>是最重要的库，它允许计算快速傅立叶变换，以及余弦变换等等。</p><p id="1181" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">其次，我们需要定义一些常数，如<em class="nw"> pi </em>值和汉明窗函数，来创建汉明窗值。这可以通过以下方式轻松实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pa pb l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 10:为 PI 定义一个常量值和一个函数来创建汉明窗口</p></figure><p id="0003" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">至此，我们可以开始玩<code class="fe mn mo mp mq b">fftw3</code>了。如图 11 所示，我们需要为大小为<code class="fe mn mo mp mq b">windowSize</code>的输入数据<code class="fe mn mo mp mq b">stft_data</code>创建一个<code class="fe mn mo mp mq b">fftw_complex</code>数组；一个与<code class="fe mn mo mp mq b">stft_data</code>具有相同尺寸的输出数组<code class="fe mn mo mp mq b">fft_result</code>用于存储傅立叶变换加窗信号，最后一个<code class="fe mn mo mp mq b">storage</code>数组用于存储所有变换后的窗口，其尺寸为<code class="fe mn mo mp mq b">samples</code>。为了允许<code class="fe mn mo mp mq b">fftw</code>计算窗口输入信号的傅立叶变换，我们需要一个傅立叶平面对象，该对象在第 17 行以这种方式创建:</p><pre class="kj kk kl km gt pc mq pd pe aw pf bi"><span id="0072" class="om na it mq b gy pg ph l pi pj">fftw_plan plan_forward;</span><span id="e708" class="om na it mq b gy pk ph l pi pj">plan_forward = fftw_plan_dft_1d(number_of_elements_in_output, <br/>                                input_data_to_be_transformed, <br/>                                output_transformed_data, <br/>                                flag_for_forward_transform, <br/>                                flag_for_inverse_transform);</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pa pb l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 11:玩 fftw</p></figure><p id="c74d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">最后一步是实现真正的 STFT 算法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pa pb l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 12: STFT 在实践中的 C</p></figure><p id="4803" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">图 12 帮助您理解 STFT 是如何实现的。首先，用当前窗口大小的信号幅度值填充<code class="fe mn mo mp mq b">stft_data</code>数组(第 10 行)。然后对这一段进行傅立叶变换，称为<code class="fe mn mo mp mq b">fftw_execute(plan_forward)</code>。实际上，<code class="fe mn mo mp mq b">fftw_execute</code>将触发上面定义的傅立叶变换计划的执行，以便变换当前输入并将结果保存在输出数组<code class="fe mn mo mp mq b">fft_result</code>中。最后，一半的傅立叶样本保存在<code class="fe mn mo mp mq b">storage</code>阵列中，稍后将返回给 Cython，并且<code class="fe mn mo mp mq b">chunkPosition</code>由<code class="fe mn mo mp mq b">hop_size/2</code>更新，因此可以继续下一个窗口——还记得奈奎斯特频率吗？</p><p id="879b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">此时，可以用来自<code class="fe mn mo mp mq b">storage</code>的傅立叶变换信号填充<code class="fe mn mo mp mq b">magnitude</code>数组，该数组是在 Cython 中创建的内存视图</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pa pb l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 13:填充内存视图大小并将其返回给 Cython</p></figure><p id="21ce" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">因此，量值将从 C 转移到 Cython。在 Cython 中，可以操作<code class="fe mn mo mp mq b">magnitude</code>数组来返回一个 numpy 数组，可以用 Python 读取:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pa pb l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 14: Cython 零件。magnitude memoryview 被转换成一个 numpy 数组，经过整形后返回给 Python</p></figure><h2 id="4bf9" class="om na it bd nb on oo dn nf op oq dp nj ma or os nl me ot ou nn mi ov ow np ox bi translated">准备 setup.py 并安装所有东西</h2><p id="52f6" class="pw-post-body-paragraph lr ls it lt b lu nr ju lw lx ns jx lz ma nt mc md me nu mg mh mi nv mk ml mm im bi translated">这是享受分析 STFT 之前的最后一步。为了在 Cython 中安装 create Python 包，我通常将我的代码分成两个文件夹:<code class="fe mn mo mp mq b">c_code</code>，其中存储了<code class="fe mn mo mp mq b">stft.c</code>和<code class="fe mn mo mp mq b">installer</code>，其中保存了<code class="fe mn mo mp mq b">pyx</code>和 Python 文件。在<code class="fe mn mo mp mq b">installer</code>文件夹中，我创建了<code class="fe mn mo mp mq b">setup.py</code>文件，这是一个 Python 文件，用于安装和编译 Cython 和 C 代码。代码非常简单:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pa pb l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 15:编译 Cython 和 C 代码的 setup.py 脚本</p></figure><p id="96f4" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在图 15 的代码中，我们可以看到编译代码的主要元素是<code class="fe mn mo mp mq b">Extension</code>和<code class="fe mn mo mp mq b">setup</code>。前者定义了当前扩展的名称<code class="fe mn mo mp mq b">stft.stft</code>、<code class="fe mn mo mp mq b">pyx</code>文件列表<code class="fe mn mo mp mq b">[stft.pyx]</code>、库列表和编译 C 代码所需的额外参数。特别是，在这种情况下，我们需要将<code class="fe mn mo mp mq b">fftw3</code>和<code class="fe mn mo mp mq b">m </code>指定为附加库，其中一个声明使用快速傅立叶变换库，另一个声明使用数学库(编译 C 代码时，通常将<code class="fe mn mo mp mq b">m</code>添加为<code class="fe mn mo mp mq b">-lm</code>，将<code class="fe mn mo mp mq b">fftw3 </code>添加为<code class="fe mn mo mp mq b">-lfftw3</code>)。额外的参数确保我们在编译 C 时有一个<code class="fe mn mo mp mq b">O3</code>优化过程，而<code class="fe mn mo mp mq b">std=C99</code>是通知编译器我们正在使用标准版本 C99。最后，<code class="fe mn mo mp mq b">setup</code>存储包信息，即最终模块的名称——因此 Python 将当前模块作为<code class="fe mn mo mp mq b">import stft</code>导入——版本控制、C 的扩展和 Cython 的任何指令。关于 Cython 指令，我建议你看一下<a class="ae ky" href="https://cython.readthedocs.io/en/latest/src/userguide/source_files_and_compilation.html#compiler-directives" rel="noopener ugc nofollow" target="_blank">指南</a>。</p><p id="2ad0" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">一旦代码准备好，我们就可以像下面这样运行<code class="fe mn mo mp mq b">setup.py</code>:</p><pre class="kj kk kl km gt pc mq pd pe aw pf bi"><span id="a79f" class="om na it mq b gy pg ph l pi pj">python setup.py build_ext --inplace</span></pre><p id="c838" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><code class="fe mn mo mp mq b">build_ext</code>是构建当前扩展的命令，<code class="fe mn mo mp mq b">--inplace</code>允许在工作目录中安装当前包。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="770e" class="mz na it bd nb nc nd ne nf ng nh ni nj jz nk ka nl kc nm kd nn kf no kg np nq bi translated">STFT 的有趣例子</h1><p id="5a75" class="pw-post-body-paragraph lr ls it lt b lu nr ju lw lx ns jx lz ma nt mc md me nu mg mh mi nv mk ml mm im bi translated">代码:<a class="ae ky" href="https://github.com/Steboss/music_retrieval/tree/master/stft/examples" rel="noopener ugc nofollow" target="_blank">https://github . com/ste boss/music _ retrieval/tree/master/STFT/examples</a></p><p id="2777" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">研究 STFT 的一个很好的例子是 Aphex 双胞胎“方程式”音乐</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pl pb l"/></div></figure><p id="ec33" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果我们分析 300 到 350 秒之间的声谱图:</p><pre class="kj kk kl km gt pc mq pd pe aw pf bi"><span id="8a46" class="om na it mq b gy pg ph l pi pj">start = 300*rate <br/>end   = 350*rate </span><span id="4665" class="om na it mq b gy pk ph l pi pj">channel1 = audData[:,0][start:end]</span></pre><p id="9137" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">设置<code class="fe mn mo mp mq b">windowSize=4096</code>和<code class="fe mn mo mp mq b">hopSize=4096</code>音乐谱图中会出现一张恶魔的脸:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/011c62dfe9454c481b4de7fb0abc85f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w9IPBkgQ4pZb-FM5slnp7Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 16:Aphex Twin 的“方程式”中隐藏的恐怖脸(30-40 岁之间)</p></figure><p id="8951" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我希望你喜欢这第一次对 Cython 的介绍:)如果有任何问题或意见，请发邮件给我，地址是:stefanobosisio1@gmail.com</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="ffe4" class="mz na it bd nb nc nd ne nf ng nh ni nj jz nk ka nl kc nm kd nn kf no kg np nq bi translated">文献学</h1><ol class=""><li id="189c" class="nx ny it lt b lu nr lx ns ma pm me pn mi po mm oz od oe of bi translated"><a class="ae ky" href="https://onlinelibrary.wiley.com/doi/full/10.1002/jmri.1160" rel="noopener ugc nofollow" target="_blank">https://onlinelibrary.wiley.com/doi/full/10.1002/jmri.1160</a></li><li id="b152" class="nx ny it lt b lu og lx oh ma oi me oj mi ok mm oz od oe of bi translated"><a class="ae ky" href="https://www.sciencedirect.com/science/article/abs/pii/S0010482516302104" rel="noopener ugc nofollow" target="_blank">https://www . science direct . com/science/article/ABS/pii/s 0010482516302104</a></li><li id="5ead" class="nx ny it lt b lu og lx oh ma oi me oj mi ok mm oz od oe of bi translated">https://www.scirp.org/html/4708.html<a class="ae ky" href="https://www.scirp.org/html/4708.html" rel="noopener ugc nofollow" target="_blank"/></li><li id="c94b" class="nx ny it lt b lu og lx oh ma oi me oj mi ok mm oz od oe of bi translated"><a class="ae ky" href="https://www.roe.ac.uk/japwww/teaching/fourier/compression.html" rel="noopener ugc nofollow" target="_blank">https://www . roe . AC . uk/jawww/teaching/Fourier/compression . html</a></li><li id="9381" class="nx ny it lt b lu og lx oh ma oi me oj mi ok mm oz od oe of bi translated"><a class="ae ky" href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.307.8732&amp;rep=rep1&amp;type=pdf" rel="noopener ugc nofollow" target="_blank">http://citeseerx.ist.psu.edu/viewdoc/download?doi = 10 . 1 . 1 . 307 . 8732&amp;rep = re P1&amp;type = pdf</a></li></ol></div></div>    
</body>
</html>