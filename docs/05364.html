<html>
<head>
<title>Introduction to Python Heapq Module</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python Heapq模块简介</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/introduction-to-python-heapq-module-53534feda625?source=collection_archive---------19-----------------------#2020-05-06">https://towardsdatascience.com/introduction-to-python-heapq-module-53534feda625?source=collection_archive---------19-----------------------#2020-05-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="41d1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关于如何使用Python的heapq模块的简单介绍</h2></div><p id="b749" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个<strong class="kk iu">堆</strong>是二叉树的一个特例，其中父节点与它们的子节点的值进行比较，并相应地进行排列。如果你看过我以前的一篇名为<a class="ae le" rel="noopener" target="_blank" href="/8-common-data-structures-every-programmer-must-know-171acf6a1a42"> 8常见数据结构的文章，每个程序员都必须知道</a>有两种类型的堆；最小堆和最大堆。</p><div class="lf lg gp gr lh li"><a rel="noopener follow" target="_blank" href="/8-common-data-structures-every-programmer-must-know-171acf6a1a42"><div class="lj ab fo"><div class="lk ab ll cl cj lm"><h2 class="bd iu gy z fp ln fr fs lo fu fw is bi translated">每个程序员都必须知道的8种常见数据结构</h2><div class="lp l"><h3 class="bd b gy z fp ln fr fs lo fu fw dk translated">数据结构是一种在计算机中组织和存储数据的专门方法，以这种方式我们可以执行…</h3></div><div class="lq l"><p class="bd b dl z fp ln fr fs lo fu fw dk translated">towardsdatascience.com</p></div></div><div class="lr l"><div class="ls l lt lu lv lr lw lx li"/></div></div></a></div><p id="c9a8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">python的<strong class="kk iu"> heapq </strong>模块实现了堆队列算法。它使用<strong class="kk iu">最小堆</strong>，其中父堆的键小于或等于其子堆的键。在本文中，我将介绍python heapq模块，并通过一些示例向您展示如何将heapq用于原始数据类型和具有复杂数据的对象。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi ly"><img src="../Images/f1c8285b1046a9aa5504bcd18400a1be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KHgBZzUUu7kYU834C7X5hA.jpeg"/></div></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">图片来自<a class="ae le" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2819215" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae le" href="https://pixabay.com/users/Kaz-19203/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2819215" rel="noopener ugc nofollow" target="_blank">凯伦·阿诺德</a></p></figure><h1 id="ed2b" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">Heapq函数</h1><p id="bdb8" class="pw-post-body-paragraph ki kj it kk b kl nf ju kn ko ng jx kq kr nh kt ku kv ni kx ky kz nj lb lc ld im bi translated">假设你知道堆数据结构是如何工作的，我们来看看Python的heapq模型提供了哪些功能。</p><ul class=""><li id="f8ce" class="nk nl it kk b kl km ko kp kr nm kv nn kz no ld np nq nr ns bi translated"><strong class="kk iu"> heappush(heap，item) </strong> —将值<em class="nt"> item </em>推入<em class="nt">堆</em></li><li id="e3bd" class="nk nl it kk b kl nu ko nv kr nw kv nx kz ny ld np nq nr ns bi translated"><strong class="kk iu"> heappop(heap) </strong> —弹出并返回<em class="nt">堆中的最小值</em></li><li id="2671" class="nk nl it kk b kl nu ko nv kr nw kv nx kz ny ld np nq nr ns bi translated"><strong class="kk iu"> heappushpop(heap，item) </strong> —将值<em class="nt"> item </em>推入<em class="nt">堆</em>并返回<em class="nt">堆</em>中的最小值</li><li id="6539" class="nk nl it kk b kl nu ko nv kr nw kv nx kz ny ld np nq nr ns bi translated"><strong class="kk iu">堆(x) </strong> —将列表<em class="nt"> x </em>转换成堆</li><li id="1aeb" class="nk nl it kk b kl nu ko nv kr nw kv nx kz ny ld np nq nr ns bi translated"><strong class="kk iu">heap preplace(heap，item) </strong> —弹出并返回<em class="nt">堆</em>中的最小值，然后将值<em class="nt"> item </em>推入<em class="nt">堆</em></li></ul><h1 id="7f82" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">使用原始数据类型的Heapq示例演练</h1><p id="5ad7" class="pw-post-body-paragraph ki kj it kk b kl nf ju kn ko ng jx kq kr nh kt ku kv ni kx ky kz nj lb lc ld im bi translated">让我们看一些使用不同heapq函数的例子。首先你要导入heapq模块。</p><pre class="lz ma mb mc gt nz oa ob oc aw od bi"><span id="039c" class="oe mo it oa b gy of og l oh oi">import heapq</span></pre><p id="935d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">考虑下面给出的示例列表<code class="fe oj ok ol oa b">a</code>。</p><pre class="lz ma mb mc gt nz oa ob oc aw od bi"><span id="6f83" class="oe mo it oa b gy of og l oh oi">&gt;&gt;&gt; a = [52, 94, 13, 77, 41]</span></pre><p id="ea84" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们把这个列表放大，结果将如下。请注意，堆积是就地完成的。</p><pre class="lz ma mb mc gt nz oa ob oc aw od bi"><span id="8568" class="oe mo it oa b gy of og l oh oi">&gt;&gt;&gt; heapq.heapify(a)<br/>&gt;&gt;&gt; print(a)<br/>[13, 41, 52, 77, 94]</span></pre><p id="7187" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，第0个索引包含所有值中的最小值，即13。</p><p id="079d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们把值10放到我们的堆里。</p><pre class="lz ma mb mc gt nz oa ob oc aw od bi"><span id="b12f" class="oe mo it oa b gy of og l oh oi">&gt;&gt;&gt; heapq.heappush(a,10)<br/>&gt;&gt;&gt; print(a)<br/>[10, 41, 13, 77, 94, 52]</span></pre><p id="aa0c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，添加了10，因为10是可用值中的最小值，所以它在第0个索引中。</p><p id="4e31" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们从我们的堆里跳出来。</p><pre class="lz ma mb mc gt nz oa ob oc aw od bi"><span id="7c01" class="oe mo it oa b gy of og l oh oi">&gt;&gt;&gt; print(heapq.heappop(a))<br/>10<br/>&gt;&gt;&gt; print(a)<br/>[13, 41, 52, 77, 94]</span></pre><p id="238c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们从堆中弹出时，它将从堆中移除最小值并返回它。现在值10已经不在我们的堆中了。</p><p id="1841" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看看heappushpop()函数是如何工作的。让我们把值28。</p><pre class="lz ma mb mc gt nz oa ob oc aw od bi"><span id="6db2" class="oe mo it oa b gy of og l oh oi">&gt;&gt;&gt; print(heapq.heappushpop(a,28))<br/>13<br/>&gt;&gt;&gt; print(a)<br/>[28, 41, 52, 77, 94]</span></pre><p id="bb21" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以看到28被推送到堆中，最小值13从堆中弹出。</p><p id="a6fd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们试试heapreplace()函数。让我们将值3放入堆中。</p><pre class="lz ma mb mc gt nz oa ob oc aw od bi"><span id="7002" class="oe mo it oa b gy of og l oh oi">&gt;&gt;&gt; print(heapq.heapreplace(a,3))<br/>28<br/>&gt;&gt;&gt; print(a)<br/>[3, 41, 52, 77, 94]</span></pre><p id="e441" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以看到，最初最小的值28被弹出，然后我们的新值3被推入。新堆值3中的第0个索引。请注意heappushpop()和heapreplace()函数中push和pop操作顺序的不同。</p><h1 id="26cd" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">如何在Heapq中使用对象？</h1><p id="3ba6" class="pw-post-body-paragraph ki kj it kk b kl nf ju kn ko ng jx kq kr nh kt ku kv ni kx ky kz nj lb lc ld im bi translated">在前面的例子中，我已经解释了如何将heapq函数用于整数等原始数据类型。类似地，我们可以使用带有heapq函数的对象来对复杂数据(如元组甚至字符串)进行排序。为此，根据我们的场景，我们需要一个包装类。考虑这样一种情况，您希望存储字符串，并根据字符串的长度对它们进行排序，从最短到最长。我们的包装类将如下所示。</p><pre class="lz ma mb mc gt nz oa ob oc aw od bi"><span id="5fda" class="oe mo it oa b gy of og l oh oi">class DataWrap:<br/>    <br/>    def __init__(self, data):<br/>        self.data = data  <br/>    <br/>    def __lt__(self, other):<br/>        return len(self.data) &lt; len(other.data)</span></pre><p id="4fdf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe oj ok ol oa b">__lt__</code>函数(它是比较运算符的运算符重载函数；&gt;、≥、==、&lt;和≤)将包含比较字符串长度的逻辑。现在让我们试着用一些字符串做一个堆。</p><pre class="lz ma mb mc gt nz oa ob oc aw od bi"><span id="d4f2" class="oe mo it oa b gy of og l oh oi"># Create list of strings<br/>my_strings = ["write", "go", "run", "come"]</span><span id="5126" class="oe mo it oa b gy om og l oh oi"># Initialising<br/>sorted_strings = []</span><span id="5358" class="oe mo it oa b gy om og l oh oi"># Wrap strings and push to heap<br/>for s in my_strings:<br/>    heapObj = DataWrap(s)<br/>    heapq.heappush(sorted_strings, heapObj)</span><span id="9b24" class="oe mo it oa b gy om og l oh oi"># Print the heap<br/>for myObj in sorted_strings:<br/>    print(myObj.data, end="\t")</span></pre><p id="1418" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">打印堆中项目的输出如下。</p><pre class="lz ma mb mc gt nz oa ob oc aw od bi"><span id="7971" class="oe mo it oa b gy of og l oh oi">go	come	run	write</span></pre><p id="a921" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意最短的单词<code class="fe oj ok ol oa b">go</code>在堆的前面。现在，您可以通过包装字符串来尝试其他heapq函数。</p><h1 id="c78e" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">使用Heapq实现最大堆</h1><p id="e70c" class="pw-post-body-paragraph ki kj it kk b kl nf ju kn ko ng jx kq kr nh kt ku kv ni kx ky kz nj lb lc ld im bi translated">我们可以使用heapq轻松实现最大堆。你所要做的就是改变<code class="fe oj ok ol oa b">__lt__</code>函数中的比较运算符，将最大值排在前面。让我们用字符串和它们的长度来试试前面的例子。</p><pre class="lz ma mb mc gt nz oa ob oc aw od bi"><span id="0236" class="oe mo it oa b gy of og l oh oi">class DataWrap:<br/>    <br/>    def __init__(self, data):<br/>        self.data = data  <br/>    <br/>    def __lt__(self, other):<br/>        return len(self.data) &gt; len(other.data)</span><span id="8c12" class="oe mo it oa b gy om og l oh oi"># Create list of strings<br/>my_strings = ["write", "go", "run", "come"]</span><span id="90d0" class="oe mo it oa b gy om og l oh oi"># Initialising<br/>sorted_strings = []</span><span id="f31c" class="oe mo it oa b gy om og l oh oi"># Wrap strings and push to heap<br/>for s in my_strings:<br/>    heapObj = DataWrap(s)<br/>    heapq.heappush(sorted_strings, heapObj)</span><span id="6a98" class="oe mo it oa b gy om og l oh oi"># Print the heap<br/>for myObj in sorted_strings:<br/>    print(myObj.data, end="\t")</span></pre><p id="7026" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意长度比较在<code class="fe oj ok ol oa b">DataWrap</code>类的<code class="fe oj ok ol oa b">__lt__</code>函数中是如何变化的。打印这个堆中的项目的输出如下。</p><pre class="lz ma mb mc gt nz oa ob oc aw od bi"><span id="8097" class="oe mo it oa b gy of og l oh oi">write	come	run	go</span></pre><p id="f733" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，现在最长的单词<code class="fe oj ok ol oa b">write</code>在堆的前面。</p><h1 id="9f16" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">最后的想法</h1><p id="16a4" class="pw-post-body-paragraph ki kj it kk b kl nf ju kn ko ng jx kq kr nh kt ku kv ni kx ky kz nj lb lc ld im bi translated">我希望在使用heapq模块实现的过程中，这篇文章对您有所帮助。请随意使用提供的代码。</p><p id="857f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您的阅读！</p><p id="9a15" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">干杯！</p><h1 id="2e2a" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">参考</h1><p id="70e8" class="pw-post-body-paragraph ki kj it kk b kl nf ju kn ko ng jx kq kr nh kt ku kv ni kx ky kz nj lb lc ld im bi translated">[1] heapq —堆队列算法— Python 3.8.3rc1文档(<a class="ae le" href="https://docs.python.org/3/library/heapq.html" rel="noopener ugc nofollow" target="_blank">https://docs.python.org/3/library/heapq.html</a>)</p></div></div>    
</body>
</html>