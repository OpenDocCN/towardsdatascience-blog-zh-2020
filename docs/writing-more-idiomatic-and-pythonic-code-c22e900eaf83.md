# 编写更加地道和 Pythonic 化的代码

> 原文：<https://towardsdatascience.com/writing-more-idiomatic-and-pythonic-code-c22e900eaf83?source=collection_archive---------6----------------------->

## 使你的 Python 代码可读、有效、简洁和可靠的习惯用法和惯例。

有许多方法可以实现相同的特性、算法或功能。有些简单明了——更好*，有些混乱低效——更糟*。Python 社区经常使用像*Python*这样的术语，或者在描述遵循特定(自然、恰当)风格和约定的代码时使用。这就是我们每天都在努力编写的好的、清晰的代码，在这篇文章中，我们将回顾一些技巧、约定和习惯用法，它们将帮助你编写更多的*惯用*和*python 式*代码。**

**![](img/036f6d869e7d3903679af84a872aec82.png)**

**照片由[艾哈迈德·卡希姆](https://unsplash.com/@ahmadkadhim?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)在 [Unsplash](https://unsplash.com/?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄**

# **身份和平等比较**

**不只是在 Python 中，实际上在任何编程语言中，您都可能陷入混淆身份和值相等的陷阱。在 Python 中，你可以选择使用`is`或`==`进行比较，其中`is`检查身份而`==`检查值。**

**考虑到大多数时候我们只关心价值，而不是身份，我们通常会选择`==`。然而，在有些情况下，你应该总是使用`is`操作符。其中之一就是与所有的蟒蛇*单线* - `None`、`True`或`False`进行比较。**

**使用`is None`、`is True`或`is False`不仅仅是为了约定俗成或提高可读性。这也提高了性能，尤其是如果您在循环内部使用`x is None`而不是`x == None`的话。为什么会这样？你可能会问。嗯，这是因为`is`操作符不能像`==`(实际上就是`a.__eq__(b)`)那样被重载，所以 Python 可以跳过对这些 *dunder* 方法的查找，这些方法是使用`==`进行比较所需要的。**

**所以，这里的底线是，你应该尽可能地使用`is`，因为它可读性更强，速度更快，而且更习惯。但是要想知道你*是否真的能*使用它，你应该问问你自己你是否关心被比较变量的价值或同一性。**

# **上下文管理器而不是`try/finally`**

**在其他语言中，常见的做法是使用`try/finally`来管理资源，并确保在发生异常时处理打开的文件或获取的锁。你也可以在 Python 中使用`try/finally`，但是我们可以使用`with`语句做得更好:**

**上面的代码显示了所谓的*上下文协议*的用法，该协议由两个方法组成——分别在*进入*和*退出`with`块的*体时调用的`__enter__`和`__exit__`。你可能已经知道`with`语句及其用法，但你可能不知道上面使用的`contextlib`。它是一个模块，提供了将功能转化为上下文管理器的工具。至于上面的`closing`函数，它只是强制调用对象的`.close()`方法，在本例中是`page`。**

**然而，*上下文协议*的使用并不局限于资源管理。它也可用于抑制异常(`with suppress(...)`)或重定向输出(`with redirect_stdout(...)`):**

# **检查是否提供了参数**

**有时，您可能需要定义带有可选参数的函数。用 Python 可以非常容易地做到这一点，当然知道怎么做:**

**大多数情况下，我们使用可选参数来允许 our 函数的用户省略明显的默认参数或很少使用的选项。但是在某些情况下，我们可能希望改变函数的行为，不仅基于可选参数的值，还基于参数是否被提供。对于这种情况，一个合理的解决方案是使用`None`作为缺省值(当它是`None` do X 时，当它不是 do Y 时)。但是如果`None`是可接受的值呢？您可以选择另一个一次性值，但是有一个很好的*惯用的*解决方案:**

**我们可以通过创建一个名为`_no_value`的常量来解决这个问题，我们将这个常量设置为可选参数的默认值。通过这样做，我们避免了任何可能可接受的值，因为我们实际上根本不检查值——我们检查的是*标识*。换句话说，我们正在检查`y`参数是否与分配给`_no_value`的参数指向同一个对象。**

# **多重赋值**

**Python 的一个很好的特性是多重赋值，这是大多数编程语言所缺乏的。最简单的形式如下:**

**这很好，因为它缩短和简化了代码，但我个人很少有机会使用它。在将可重复项分解成多个变量时，可以使用更实用的版本:**

**与使用索引为每个变量赋值相比，这无疑是更好的选择，因为它产生的视觉噪声更少，更简洁，也更不容易出错。**

# **变量解包**

**基于前面的例子，我们还可以使用*星形表达式*来解包任意长度的 iterable 元素:**

**通常，iterables 中的值会有一些模式或已知的组成部分，使用解包可以很容易地提取出来。这总是比在 iterable 中显式使用索引更好的解决方案，因为这样会创建带有大量未命名和未知变量的不可读代码。**

**不过，在使用*星形表达式*时，有一点需要注意。用*星形表达式*解包总是创建列表，即使变量从解包中接收到零值，考虑到你不需要做任何额外的类型检查，这可能很好，但是接收到`[]`而不是`None`也可能有点令人惊讶。**

**如果我们想扩展这个特性的限制，那么我们甚至可以将多个级别的 iterable 分解成其他 iterable:**

**我不一定推荐这样做，因为这不会产生可读性很好的代码，但是知道我们使用的工具的限制是有好处的，即使我们不经常使用或者根本不使用这个特定的选项。**

# **交换值**

**在其他语言中，你需要额外的变量和 3 行代码来交换 2 个变量。然而在 Python 中，有一种更好的方法类似于前面展示的多重赋值:**

**这是超级简单和超级有用的，它是提醒你 Python 有多棒的特性之一。除了交换变量，这也适用于可变的可重复项(如列表)及其索引，这在排序中很常见:**

**这看起来像是 Python 的魔法，但实际上 Python 足够聪明，知道什么时候创建临时变量，什么时候放入临时变量，在哪里赋值，什么时候丢弃。**

# **并行处理列表**

**例如，在处理数据库或 CSV 表时，您经常会发现自己有多个相关数据列表。它可能是数据库表中的几列，几个相关的数据集，等等。不管数据实际上是什么，您可能都希望使用它并并行处理它。在 Python 中，最简单的方法是使用`zip`:**

**`zip`函数获取可变数量的列表，并生成惰性生成器，该生成器生成包含来自每个所提供列表的元素的元组。这对于处理数据来说很棒，而且非常高效，因为——正如我提到的——生成器是*懒惰的*，所以它不会将整个列表加载到内存中，只加载当前的元素元组。**

**当使用这个函数时，你可能会意识到，当处理不同长度的列表时，它并不那么好，因为它只在列表中最短的*用尽时才产生值，这可能并不总是令人满意的。如果您想消耗值，直到列表中最长的*用完，您可以使用`itertools.zip_longest`，它将使用作为参数提供的`None`或`fillvalue`来填充缺少的值。****

# **避免映射、过滤和减少**

**Python 有许多函数式编程概念和函数，如`lambda`表达式、列表理解、`functools`模块等。然而，有一些是许多人不喜欢的。这些是`map`、`reduce`和`filter`。但是这些功能有什么不好呢？嗯，有多种原因，但我不得不同意的一个原因是，编写列表理解通常比编写`map`或`filter`更干净和清晰，并且在`reduce`的情况下，当与非平凡函数参数一起使用时，代码变得难以阅读。不喜欢这些函数的另一个很好的理由是，理想情况下应该只有一种正确的做事方式，那么当我们有列表理解时，为什么还要使用`map`、`filter`、`reduce`甚至`lambda`？**

**如果你不同意我的观点，这是可以理解的，但在写一些愤怒的评论之前，你可能想读一读 Guido va Rossum 的简短评论，这可能会改变你的想法。**

**底线——尽量少用上面的函数，理想的情况是尽可能用列表理解来代替它们。**

> **“‘reduce’的唯一目的是编写真正混乱的代码，以显示你有多酷。我只是没那么酷。”—吉多·范·罗苏姆**

# **含电池**

**Python 在很长一段时间里都保持着*“包含电池”*的理念，这意味着你会在标准库中找到很多有用的工具、模块和函数，这些都是你意想不到的。你应该经常检查你正试图解决的问题或者你正试图实现的函数是否在标准库中的某个地方，如果你找不到，很可能是你找得不够仔细。**

**这些*【电池】*在标准库中有很多例子，我想到的第一个模块是`itertools`，它提供了迭代器构建块。另一个很棒的是具有高阶函数集合的`functools`，我还必须提到具有非常有用的数据类型的`collections`模块，例如`Counter`、`deque`或`namedtuple`等等。**

**所以，下一次你在程序中需要一些相当常见的功能时，不要重新发明轮子，去看看 [Python 库文档](https://docs.python.org/3/library/)，抓住已经有的东西，为自己节省一些时间。**

# **“一帮”习语**

**当你定义一个 Python `class`时，你很可能会在它的`__init__`方法中声明几个属性。您可能只声明一个或两个属性，但也可能以如下形式结束:**

**在`class`中只有几个属性，把它们写出来没什么问题，也不会让你的代码变得那么混乱，但是如果有 10 个左右的属性——就像上面的代码——你还能把它们都写出来吗？嗯，我不会。所以，为了避免它你可以使用所谓的[*【习语】*](http://code.activestate.com/recipes/52308-the-simple-but-handy-collector-of-a-bunch-of-named)*:***

***上面的代码片段演示了`self.__dict__`的用法，这是一个存储了`class`所有属性的字典(除非声明了`__slots__`)。这里，我们将构造函数的任何关键字参数传递给生成所有属性的`update`函数。也可以用`vars(self)`在我看来好看一点。***

***你可能会认为这是一个肮脏的手段，但是我认为使用它是没问题的，特别是如果你有`class`(数据结构)来存储*束*属性，而没有任何真正的功能。另外 [Raymond Hettinger 说](https://stackoverflow.com/a/9205029)可以直接更新实例字典，所以就这样了。***

# **结论**

**我绝对推荐在你的 Python 代码中使用以上所有的习惯用法和技巧，我相信这些会让你的代码更加*Python 化*和*习惯化*。然而,*“什么是 Pythonic？”*或者*“什么是惯用语？”对我有效的，可能对你无效。所以，使用习惯用法使你的代码更易读、简洁和有效，而不仅仅是因为它是习惯用法。以同样的方式，使用语言特有的 Python 特性来改进你的代码，而不仅仅是使它更加 Python 化。***

***本文原帖*[*martinheinz . dev*](https://martinheinz.dev/blog/32?utm_source=tds&utm_medium=referral&utm_campaign=blog_post_32)**

**[](/making-python-programs-blazingly-fast-c1cd79bd1b32) [## 让 Python 程序快得惊人

### 让我们看看我们的 Python 程序的性能，看看如何让它们快 30%！

towardsdatascience.com](/making-python-programs-blazingly-fast-c1cd79bd1b32) [](/tour-of-python-itertools-2af84db18a5e) [## Python Itertools 之旅

### 让我们探索两个伟大的 Python 库——ITER tools 和 more_itertools，看看如何利用它们来处理数据…

towardsdatascience.com](/tour-of-python-itertools-2af84db18a5e) [](/python-tips-and-trick-you-havent-already-seen-37825547544f) [## Python 的技巧和诀窍，你还没有看过

### 有很多关于 Python 中很多很酷的特性的文章，但是还有更多值得讨论的…

towardsdatascience.com](/python-tips-and-trick-you-havent-already-seen-37825547544f)**