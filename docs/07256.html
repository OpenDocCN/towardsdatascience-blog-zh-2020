<html>
<head>
<title>A-Z Julia Endpoint With Genie</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带精灵的 A-Z Julia 端点</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-z-julia-endpoint-with-genie-a2e0c2f1c884?source=collection_archive---------31-----------------------#2020-06-02">https://towardsdatascience.com/a-z-julia-endpoint-with-genie-a2e0c2f1c884?source=collection_archive---------31-----------------------#2020-06-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0f64" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关于使用 Julia、Genie 和 Lathe 部署端点的介绍。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8ea56062e9f68c982a946ebeb753e03f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7C3cjXHKkTV9tnaurVuocw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(茱莉亚标志 src =<a class="ae ky" href="http://julialang.org" rel="noopener ugc nofollow" target="_blank">http://julialang.org</a>)</p></figure><blockquote class="kz"><p id="0e56" class="la lb it bd lc ld le lf lg lh li lj dk translated"><a class="ae ky" href="https://github.com/emmettgb/Emmetts-DS-NoteBooks/blob/master/Julia/DeployingGenie.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a></p><p id="ee92" class="la lb it bd lc ld lk ll lm ln lo lj dk translated"><a class="ae ky" href="https://github.com/emmettgb/CarPricePredictor" rel="noopener ugc nofollow" target="_blank"> Github 回购</a></p></blockquote><p id="fb63" class="pw-post-body-paragraph lp lq it lr b ls lt ju lu lv lw jx lx ly lz ma mb mc md me mf mg mh mi mj lj im bi translated">任何有抱负的数据科学家应该能够完成的最重要的任务之一是创建和部署一个端点。端点是现代机器学习的主干，也是将模型转化为真实生产环境的最简单方法。为了在端点部署模型，您首先需要选择一个 web 框架来创建该端点。对于 Python 和 R 来说，选择是非常明显的，并且很容易找到一个合适的 web 框架来满足您的需求。</p><blockquote class="kz"><p id="e116" class="la lb it bd lc ld lk ll lm ln lo lj dk translated">但是朱莉娅呢？</p></blockquote><p id="d606" class="pw-post-body-paragraph lp lq it lr b ls lt ju lu lv lw jx lx ly lz ma mb mc md me mf mg mh mi mj lj im bi translated">尽管 Julia 的生态系统肯定没有 Python 或 R 的那么成熟，但是 Julia 确实有一些有趣的选项来部署您的模型。首先，你总是可以依靠 PyCall。这将允许您使用像 Flask 和 Django 这样的 Python 库来进行部署，而不必担心使用与这两个选项相比仍然相对年轻的 Julia 项目。但是对于那些渴望更高性能的人，我介绍</p><blockquote class="kz"><p id="616b" class="la lb it bd lc ld lk ll lm ln lo lj dk translated">Genie.jl。</p></blockquote><p id="8658" class="pw-post-body-paragraph lp lq it lr b ls lt ju lu lv lw jx lx ly lz ma mb mc md me mf mg mh mi mj lj im bi translated">当然，与其他 web 框架相比，Genie 还很年轻，但是在我看来，它带来了更多有趣的想法，使得部署模型成为一项休闲活动。Genie 仍在 0.31.1 版本中，但你可能会惊讶于这项技术已经有多强大。今天，我将带你了解 Genie 的一切，从建立虚拟环境到序列化模型和在 Ubuntu 上部署基于 Genie 的 API。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="355e" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">建立模型</h1><p id="9714" class="pw-post-body-paragraph lp lq it lr b ls nj ju lu lv nk jx lx ly nl ma mb mc nm me mf mg nn mi mj lj im bi translated">举个例子来说，关于一个模型没有什么是真正重要的。无论如何，我们将使用 Lathe 来创建我们的模型，因为与许多其他选项不同，Lathe 模型非常容易序列化和部署。对于今天的例子，我们将使用车床 0.1.2，但语法应该保持不变，直到至少车床 1.0 的发布。第一件事是首先，让我们找到一些数据！</p><div class="no np gp gr nq nr"><a href="https://www.kaggle.com/nehalbirla/vehicle-dataset-from-cardekho/data#" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">来自 cardekho 的车辆数据集</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">二手车和摩托车数据</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">www.kaggle.com</p></div></div><div class="oa l"><div class="ob l oc od oe oa of ks nr"/></div></div></a></div><p id="e59b" class="pw-post-body-paragraph lp lq it lr b ls og ju lu lv oh jx lx ly oi ma mb mc oj me mf mg ok mi mj lj im bi translated">我选定的数据集是来自 Kaggle 的“车辆数据集”。我选择这个主要是因为我对汽车感兴趣。此外，我对它们感到特别兴奋，因为下周我就要去买一幅德尔·索尔的画了。对于汽车人，我只想说一件事:</p><blockquote class="kz"><p id="ec77" class="la lb it bd lc ld lk ll lm ln lo lj dk translated">双收费 B20 交换。</p></blockquote><p id="8dde" class="pw-post-body-paragraph lp lq it lr b ls lt ju lu lv lw jx lx ly lz ma mb mc md me mf mg mh mi mj lj im bi translated">回到数据科学的世界，我下载了我们的新数据集，现在我们可以读取它了。我们将使用 CSV.jl:</p><pre class="kj kk kl km gt ol om on oo aw op bi"><span id="dc03" class="oq ms it om b gy or os l ot ou">using CSV<br/>df = CSV.read("car data.csv")</span></pre><p id="aa26" class="pw-post-body-paragraph lp lq it lr b ls og ju lu lv oh jx lx ly oi ma mb mc oj me mf mg ok mi mj lj im bi translated">朱莉娅的趣事:虽然 DataFrames.jl 是 CSV.jl 的依赖项，但是每当我们导入 CSV 时，它都不会被预编译。换句话说，df 的类型是 DataFrame，它来自 DataFrames.jl，但是我们不能使用与此类型相关的任何方法，直到我们也导入 DataFrames。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/624f6fd4e32518bfe99d11a7e2474216.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*Wi9_oGkJRai0LMhtgIOp7Q.png"/></div></figure><pre class="kj kk kl km gt ol om on oo aw op bi"><span id="e961" class="oq ms it om b gy or os l ot ou">using DataFrames</span></pre><p id="2e1d" class="pw-post-body-paragraph lp lq it lr b ls og ju lu lv oh jx lx ly oi ma mb mc oj me mf mg ok mi mj lj im bi translated">虽然肯定有其他方法可以删除你丢失的值，但这是一个有效的方法:</p><pre class="kj kk kl km gt ol om on oo aw op bi"><span id="f012" class="oq ms it om b gy or os l ot ou">df = collect(skipmissing(eachrow(df)))</span></pre><p id="d069" class="pw-post-body-paragraph lp lq it lr b ls og ju lu lv oh jx lx ly oi ma mb mc oj me mf mg ok mi mj lj im bi translated">使用这种方法的一个优点是 collect()和 skipmissing()都是 Julia 语言中的基本方法。这意味着它们可以应用于任何类型，如果显式导入，甚至可以应用于您自己的类型。Eachrow()来自数据帧，只是用来把我们的 df 转换成可以迭代的东西。这样做的缺点是，我们将得到一个 DataFrame 行数组作为返回。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/b207c31734ae18bb8fef5a53ffbc0eca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1338/format:webp/1*hBA2qYyx6HfSOyimmNOS9g.png"/></div></figure><p id="86fe" class="pw-post-body-paragraph lp lq it lr b ls og ju lu lv oh jx lx ly oi ma mb mc oj me mf mg ok mi mj lj im bi translated">我们可以通过断言该数据的 DataFrame 类型来缓解这一问题。</p><pre class="kj kk kl km gt ol om on oo aw op bi"><span id="3d97" class="oq ms it om b gy or os l ot ou">df = DataFrame(df)</span></pre><p id="a032" class="pw-post-body-paragraph lp lq it lr b ls og ju lu lv oh jx lx ly oi ma mb mc oj me mf mg ok mi mj lj im bi translated">跳过这一步，我们不打算考虑统计测试，因为我们并不关心这个例子的准确性，所以接下来我们将继续分割我们的数据。为此，我们将使用来自 Lathe.preprocess 的 TrainTestSplit。在 Lathe 的不稳定版本中，我们需要设置 at 参数(float 设置为 75%)，但在任何稳定版本中，情况都不是这样。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/8413c8cdffe49e0ae3d725295a4d9cff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hqo_s8VWKwdvxxg_kUO19Q.png"/></div></div></figure><p id="73f3" class="pw-post-body-paragraph lp lq it lr b ls og ju lu lv oh jx lx ly oi ma mb mc oj me mf mg ok mi mj lj im bi translated">接下来，我们需要确定目标和特性。我认为比较 Kms_Driven 和 Selling_Price 是一个很酷的主意。然后我想也许这一年也会很酷，所以为什么不两个都做呢？</p><pre class="kj kk kl km gt ol om on oo aw op bi"><span id="60b0" class="oq ms it om b gy or os l ot ou">target = :Present_Price<br/>feature1 = :Year<br/>feature2 = :Kms_Driven</span></pre><p id="b664" class="pw-post-body-paragraph lp lq it lr b ls og ju lu lv oh jx lx ly oi ma mb mc oj me mf mg ok mi mj lj im bi translated">现在，让我们插入这些内容，以便从数据帧中获取实际阵列:</p><pre class="kj kk kl km gt ol om on oo aw op bi"><span id="3343" class="oq ms it om b gy or os l ot ou">trainy = train[!,target]<br/>testy = test[!,target]<br/>trainX1 = train[!,feature1]<br/>trainX2 = train[!,feature2]<br/>testX1 = test[!,feature1]<br/>testX2 = test[!,feature2]</span></pre><p id="6feb" class="pw-post-body-paragraph lp lq it lr b ls og ju lu lv oh jx lx ly oi ma mb mc oj me mf mg ok mi mj lj im bi translated">现在我们将安装两个独立的车床模型:</p><pre class="kj kk kl km gt ol om on oo aw op bi"><span id="6ccb" class="oq ms it om b gy or os l ot ou">using Lathe.models<br/>model1 = LinearRegression(trainX1,trainy)<br/>model2 = LinearRegression(trainX2,trainy)</span></pre><p id="fb6c" class="pw-post-body-paragraph lp lq it lr b ls og ju lu lv oh jx lx ly oi ma mb mc oj me mf mg ok mi mj lj im bi translated">得到两个预测:</p><pre class="kj kk kl km gt ol om on oo aw op bi"><span id="a2e8" class="oq ms it om b gy or os l ot ou">yhat1 = model1.predict(testX1)<br/>yhat2 = model2.predict(testX2)</span></pre><p id="b1b4" class="pw-post-body-paragraph lp lq it lr b ls og ju lu lv oh jx lx ly oi ma mb mc oj me mf mg ok mi mj lj im bi translated">现在我们将一起和单独测试它们的准确性。对于我们的验证指标，我们将使用平均绝对误差:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/0ec9a1c6feb05ff4904fe17639063518.png" data-original-src="https://miro.medium.com/v2/resize:fit:1064/format:webp/1*UJIHgf2OcDcVHG695Ir6fg.png"/></div></figure><blockquote class="kz"><p id="0036" class="la lb it bd lc ld le lf lg lh li lj dk translated">还不错！</p></blockquote><p id="5ca6" class="pw-post-body-paragraph lp lq it lr b ls lt ju lu lv lw jx lx ly lz ma mb mc md me mf mg mh mi mj lj im bi translated">让我们看看如果我们把两者结合起来会发生什么。我们将通过对 zip 循环中的所有预测进行平均来将两者结合起来:</p><pre class="kj kk kl km gt ol om on oo aw op bi"><span id="0a9e" class="oq ms it om b gy or os l ot ou">yhati = [mean([pred1,pred2]) for (pred1,pred2) in zip(yhat1,yhat2)]</span></pre><p id="f298" class="pw-post-body-paragraph lp lq it lr b ls og ju lu lv oh jx lx ly oi ma mb mc oj me mf mg ok mi mj lj im bi translated">现在我们将比较所有的精度:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/2df7b926b26a3f71fbc8fdc0ebf2dc93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*B4VKJ8Cep-_HvE1AV_-9SA.png"/></div></figure><p id="8fd4" class="pw-post-body-paragraph lp lq it lr b ls og ju lu lv oh jx lx ly oi ma mb mc oj me mf mg ok mi mj lj im bi translated">正如您可能已经预料到的，我们的新功能稍微降低了我们的准确性，因为这个模型没有对使用哪个值或对哪个值进行优先级排序做出任何逻辑决策。因此，我们将只使用第一个模型，因为它具有最好的准确性。为了序列化这个模型，我们将使用 JLD2。使用 JLD2，我们可以使用@save 宏将我们的模型保存为序列化的 JLD2 格式。</p><pre class="kj kk kl km gt ol om on oo aw op bi"><span id="f675" class="oq ms it om b gy or os l ot ou">using JLD2<br/><a class="ae ky" href="http://twitter.com/save" rel="noopener ugc nofollow" target="_blank">@save</a> "mdl.jld2" model1</span></pre></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="7aab" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">创建我们的端点</h1><p id="f21b" class="pw-post-body-paragraph lp lq it lr b ls nj ju lu lv nk jx lx ly nl ma mb mc nm me mf mg nn mi mj lj im bi translated">现在，我们将获取 JLD2 文件，并将其移动到一个新目录中。我将在 Bash 中这样做，但是当然，您也可以按照自己的意愿这样做:</p><pre class="kj kk kl km gt ol om on oo aw op bi"><span id="03b5" class="oq ms it om b gy or os l ot ou">mkdir CarPrice<br/>mv mdl.jld2 ./CarPrice</span></pre><p id="15d9" class="pw-post-body-paragraph lp lq it lr b ls og ju lu lv oh jx lx ly oi ma mb mc oj me mf mg ok mi mj lj im bi translated">现在，我们将为我们的端点创建一个目录。</p><pre class="kj kk kl km gt ol om on oo aw op bi"><span id="73d6" class="oq ms it om b gy or os l ot ou">mkdir endp<br/>cd endp</span></pre><p id="ac7c" class="pw-post-body-paragraph lp lq it lr b ls og ju lu lv oh jx lx ly oi ma mb mc oj me mf mg ok mi mj lj im bi translated">现在我们将初始化一个 Genie 项目。为此，我们将输入朱莉娅·REPL，导入精灵，然后最后是 newapp_webservice()方法:</p><pre class="kj kk kl km gt ol om on oo aw op bi"><span id="3297" class="oq ms it om b gy or os l ot ou">julia<br/>using Genie<br/>Genie<strong class="om iu">.</strong>newapp_webservice("CarPricePredictor")</span></pre><p id="df78" class="pw-post-body-paragraph lp lq it lr b ls og ju lu lv oh jx lx ly oi ma mb mc oj me mf mg ok mi mj lj im bi translated">这将实例化一个新的 Pkg 环境，并为我们的 Genie 端点创建一个新的目录系统。它还将启动一个服务器，因此您可以继续访问您的本地主机(默认为<a class="ae ky" href="http://127.0.0.1:8000/" rel="noopener ugc nofollow" target="_blank"> http://127.0.0.1:8000/ </a>)并检查您的服务器！默认情况下，无法写入这些文件，因此您需要调整权限才能编辑它们。之后，我将我们的模型文件移动到端点的目录中，然后将它放在自己的名为 models 的文件夹中。现在，我们只需在由 Genie 生成的 routes.jl 文件中使用 JLD2 重新加载它:</p><pre class="kj kk kl km gt ol om on oo aw op bi"><span id="40f2" class="oq ms it om b gy or os l ot ou">using Genie.Router</span><span id="5b66" class="oq ms it om b gy pa os l ot ou">route("/") do<br/>  mdl = <a class="ae ky" href="http://twitter.com/load" rel="noopener ugc nofollow" target="_blank">@load</a> "models/mdl.jld2"<br/>end</span></pre><p id="abb5" class="pw-post-body-paragraph lp lq it lr b ls og ju lu lv oh jx lx ly oi ma mb mc oj me mf mg ok mi mj lj im bi translated">接下来，我们将从请求中请求一个参数实参，我们可以这样做:</p><pre class="kj kk kl km gt ol om on oo aw op bi"><span id="ba19" class="oq ms it om b gy or os l ot ou">using Genie.Router</span><span id="f0e0" class="oq ms it om b gy pa os l ot ou">route("/") do<br/>  mdl = <a class="ae ky" href="http://twitter.com/load" rel="noopener ugc nofollow" target="_blank">@load</a> "models/mdl.jld2"<br/>  year = haskey(<a class="ae ky" href="http://twitter.com/params" rel="noopener ugc nofollow" target="_blank">@params</a>, :year)<br/>end</span></pre><p id="a620" class="pw-post-body-paragraph lp lq it lr b ls og ju lu lv oh jx lx ly oi ma mb mc oj me mf mg ok mi mj lj im bi translated">现在，我们将根据数据进行预测，并返回结果。</p><pre class="kj kk kl km gt ol om on oo aw op bi"><span id="75c0" class="oq ms it om b gy or os l ot ou">using Genie.Router</span><span id="d5d4" class="oq ms it om b gy pa os l ot ou">route("/") do<br/>  mdl = <a class="ae ky" href="http://twitter.com/load" rel="noopener ugc nofollow" target="_blank">@load</a> "models/mdl.jld2"<br/>  year = haskey(<a class="ae ky" href="http://twitter.com/params" rel="noopener ugc nofollow" target="_blank">@params</a>, :year)<br/>  return(mdl.predict(year))</span><span id="f2af" class="oq ms it om b gy pa os l ot ou">end</span></pre><h1 id="1a69" class="mr ms it bd mt mu pb mw mx my pc na nb jz pd ka nd kc pe kd nf kf pf kg nh ni bi translated">部署</h1><p id="2129" class="pw-post-body-paragraph lp lq it lr b ls nj ju lu lv nk jx lx ly nl ma mb mc nm me mf mg nn mi mj lj im bi translated">为了部署这个模型，我们首先要把我们的文件放到我们的服务器上。为此，您可以使用 FTP、HTTP(通过 Git 或 Wget)或 STP。通常在这种情况下，您会使用 STP，但是因为我已经将我的文件提交给 Github，所以我会将它复制到我的服务器上的/var/www 目录中。</p><pre class="kj kk kl km gt ol om on oo aw op bi"><span id="ff2c" class="oq ms it om b gy or os l ot ou">ssh emmett@(this_is_my_ip)<br/>cd /var/www<br/>git clone <a class="ae ky" href="https://github.com/emmettgb/CarPricePredictor" rel="noopener ugc nofollow" target="_blank">https://github.com/emmettgb/CarPricePredictor</a></span></pre><p id="a9c3" class="pw-post-body-paragraph lp lq it lr b ls og ju lu lv oh jx lx ly oi ma mb mc oj me mf mg ok mi mj lj im bi translated">现在我们有两件事情要设置:</p><ul class=""><li id="b1ec" class="pg ph it lr b ls og lv oh ly pi mc pj mg pk lj pl pm pn po bi translated">网络服务器</li><li id="2b7d" class="pg ph it lr b ls pp lv pq ly pr mc ps mg pt lj pl pm pn po bi translated">主管</li></ul><p id="3fe1" class="pw-post-body-paragraph lp lq it lr b ls og ju lu lv oh jx lx ly oi ma mb mc oj me mf mg ok mi mj lj im bi translated">对于我的网络服务器，我将使用 NGINX。我几乎什么都用 NGINX，因为它比 Apache 有一些优势，主要是它通常有更好的响应时间。如果你需要做出决定，我建议你选择你熟悉的那个。如果你对两者都不熟悉，那就用 NGINX 吧，因为它的配置更简单，而且以我的主观观点(以及许多指标)来看，它更好。使用 Apache 当然有优势，但是我不认为至少从尝试 NGINX 开始你会错过很多。</p><p id="ba5c" class="pw-post-body-paragraph lp lq it lr b ls og ju lu lv oh jx lx ly oi ma mb mc oj me mf mg ok mi mj lj im bi translated">我们要在 NGINX 配置中做的是创建一个代理传递到我们的服务器将要运行的端口上，默认情况下是 8000。如果你在 VPS 上运行多个网络服务器，那么你可能需要使用更高的端口，比如 8001 或 8002。配置文件存储在/etc/nginx/conf.d 中，所以让我们创建一个新的配置:</p><pre class="kj kk kl km gt ol om on oo aw op bi"><span id="7572" class="oq ms it om b gy or os l ot ou">sudo dnf/apt/pacman/man install nginx<br/>sudo nano /etc/nginx/conf.d/carpredictor.conf</span></pre><p id="f536" class="pw-post-body-paragraph lp lq it lr b ls og ju lu lv oh jx lx ly oi ma mb mc oj me mf mg ok mi mj lj im bi translated">以下是从端口 80(默认 HTTP 协议端口)到端口 8000 的代理传递的配置示例:</p><pre class="kj kk kl km gt ol om on oo aw op bi"><span id="5e10" class="oq ms it om b gy or os l ot ou"><strong class="om iu">server</strong> {<br/>    <strong class="om iu">listen</strong> 80;<br/>    <strong class="om iu">server_name</strong> your domain;<br/><br/>    <strong class="om iu">location</strong> / {<br/>        <strong class="om iu">proxy_pass</strong> http://127.0.0.1:8000;<br/>        <strong class="om iu">proxy_set_header</strong> Host $host;<br/>        <strong class="om iu">proxy_set_header</strong> X-Forwarded-For $proxy_add_x_forwarded_for;<br/>    }<br/>}</span></pre><p id="a908" class="pw-post-body-paragraph lp lq it lr b ls og ju lu lv oh jx lx ly oi ma mb mc oj me mf mg ok mi mj lj im bi translated">如果这是你的第一台 NGINX 服务器，你必须解除 NGINX 默认站点的链接:</p><pre class="kj kk kl km gt ol om on oo aw op bi"><span id="3b76" class="oq ms it om b gy or os l ot ou">sudo unlink /etc/nginx/sites-enabled/default</span></pre><p id="4086" class="pw-post-body-paragraph lp lq it lr b ls og ju lu lv oh jx lx ly oi ma mb mc oj me mf mg ok mi mj lj im bi translated">接下来，我们需要设置一个主管。和 NGINX 一样，supervisor 的配置文件。我的服务器在 Ubuntu 上，尽管我痴迷于 RHEL，所以安装 supervisor 就像</p><pre class="kj kk kl km gt ol om on oo aw op bi"><span id="1afe" class="oq ms it om b gy or os l ot ou">sudo apt-get install supervisor</span></pre><p id="c290" class="pw-post-body-paragraph lp lq it lr b ls og ju lu lv oh jx lx ly oi ma mb mc oj me mf mg ok mi mj lj im bi translated">现在我们将创建一个新的配置。</p><pre class="kj kk kl km gt ol om on oo aw op bi"><span id="6ec2" class="oq ms it om b gy or os l ot ou">sudo nano /etc/supervisor/conf.d/flask_app.conf</span></pre><p id="cad1" class="pw-post-body-paragraph lp lq it lr b ls og ju lu lv oh jx lx ly oi ma mb mc oj me mf mg ok mi mj lj im bi translated">以下是我的主管配置:</p><pre class="kj kk kl km gt ol om on oo aw op bi"><span id="b6a7" class="oq ms it om b gy or os l ot ou">[program:genieapp]<br/>directory=/var/www/CarPricePredictor<br/>command=. bin/server<br/>autostart=true<br/>autorestart=true<br/>stopasgroup=true<br/>killasgroup=true<br/>stderr_logfile=/var/log/appname/lognameerr.log<br/>stdout_logfile=/var/log/appname/lognamestdout.log</span></pre><p id="2e10" class="pw-post-body-paragraph lp lq it lr b ls og ju lu lv oh jx lx ly oi ma mb mc oj me mf mg ok mi mj lj im bi translated">命令和目录是您应该在这里查看的两个参数。我们将把 SH 文件放在我们的 Genie 端点附带的 bin/server 中，这将自动启动一个我们可以使用的 Genie 服务器。我们还需要运行上述命令的目录，差不多就是这样。现在我们只需要重新加载我们的服务:</p><pre class="kj kk kl km gt ol om on oo aw op bi"><span id="3b70" class="oq ms it om b gy or os l ot ou">sudo nginx -s reload<br/>sudo service supervisor reload</span></pre><blockquote class="kz"><p id="afc3" class="la lb it bd lc ld le lf lg lh li lj dk translated">现在我们的端点已经部署好了！</p></blockquote></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="5fc1" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">结论</h1><p id="4d5b" class="pw-post-body-paragraph lp lq it lr b ls nj ju lu lv nk jx lx ly nl ma mb mc nm me mf mg nn mi mj lj im bi translated">Julia 部署并不太难，最近已经变得更容易了。每当我第一次进入 Genie 时，文档是绝对糟糕的。幸运的是，随着时间的推移，这种情况已经发生了变化，现在这个工具比以往任何时候都更容易使用。车床模型也是我认为非常酷的一个方面。或者，您也可以使用车床部署管道。以下是为老版本的车床部署管道的教程:</p><p id="e609" class="pw-post-body-paragraph lp lq it lr b ls og ju lu lv oh jx lx ly oi ma mb mc oj me mf mg ok mi mj lj im bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/building-pipelines-with-lathe-0-0-7-unstable-in-julia-f7ba1850bde3">https://towards data science . com/building-pipelines-with-lathe-0-0-7-unstable-in-Julia-f7ba 1850 bde 3</a></p><p id="7f52" class="pw-post-body-paragraph lp lq it lr b ls og ju lu lv oh jx lx ly oi ma mb mc oj me mf mg ok mi mj lj im bi translated">旧版本和新版本的区别在于，现在管道只接受一个参数:</p><blockquote class="kz"><p id="f615" class="la lb it bd lc ld lk ll lm ln lo lj dk translated">台阶。</p></blockquote><p id="7d64" class="pw-post-body-paragraph lp lq it lr b ls lt ju lu lv lw jx lx ly lz ma mb mc md me mf mg mh mi mj lj im bi translated">所以为了做一个管道，你只需要做:</p><pre class="kj kk kl km gt ol om on oo aw op bi"><span id="6f4b" class="oq ms it om b gy or os l ot ou">using Lathe.preprocess<br/>scaler = Normalizer(xt)<br/>using Lathe.models<br/>mdl = LinearRegression(trainX,trainy)<br/>pipl = Pipeline([scaler, mdl])<br/>yhat = pipl.predict(xt)</span></pre><blockquote class="kz"><p id="ba57" class="la lb it bd lc ld le lf lg lh li lj dk translated">很酷，对吧？</p></blockquote><p id="1741" class="pw-post-body-paragraph lp lq it lr b ls lt ju lu lv lw jx lx ly lz ma mb mc md me mf mg mh mi mj lj im bi translated">所以管道部署肯定是可行的，而且在 Julia 中使用车床也很酷。我很兴奋地看到这种方法能够在这方面使用车床进行机器学习到什么程度，因为管道肯定是 DS 生态系统的重要组成部分。</p></div></div>    
</body>
</html>