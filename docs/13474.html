<html>
<head>
<title>Speed Cubing for Machine Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">机器学习的速度立方</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/speed-cubing-for-machine-learning-a5c6775fff0b?source=collection_archive---------52-----------------------#2020-09-15">https://towardsdatascience.com/speed-cubing-for-machine-learning-a5c6775fff0b?source=collection_archive---------52-----------------------#2020-09-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5d3c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">第 1 集:如何优化 Python 代码、CPU 和 I/O 利用率以及云中的部署。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e7f00133504d83b73b5bf40dd8b7eb58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KIDRh44937WoM0IY"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">莱纳斯·艾肯斯塔姆在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="67d1" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="c457" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在机器学习项目的某个阶段，您可能想要克服本地机器的限制(内核数量、内存等。)，无论你是想生成大量数据来馈入深度学习网络，还是想尽快训练你的算法。在本文中，我们将带您踏上一段旅程，分享我们发现的困难和解决方案，从幼稚的实现到更高级的技术，利用云中可能存在的各种计算资源。我们希望这将帮助您有效地管理和提高您的机器学习项目的生产率。</p><h1 id="a49d" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">生成大量数据(比如…很多！)</h1><p id="62f0" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在我们的实验中，我们希望能够在几分钟内生成大量(比如说<strong class="lt iu"> 1，000，000</strong>)<strong class="lt iu">的数据块，作为一些生成性对抗网络(GANs)的输入。如果你没听说过 GANs，可以在这里【1】阅读我的入门文章<a class="ae ky" href="https://95ba6910-ffb9-46f0-bab4-8431d2e31772.filesusr.com/ugd/dcd9aa_6ca686087fd04f04bd20b5f71a1f5ceb.pdf" rel="noopener ugc nofollow" target="_blank">。</a></strong></p><p id="0926" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们正在讨论的块将是维度 n=100 的<strong class="lt iu">立方体</strong>(即<em class="ms">1，000，000 个数据点)。这一特定数量的 1 <em class="ms">兆体素</em>(体积的数据点)被选择来匹配生成假脸的当前艺术状态，这可以在网站<a class="ae ky" href="https://www.thispersondoesnotexist.com" rel="noopener ugc nofollow" target="_blank"><em class="ms">thispersondoesnotexist.com</em></a>上看到。这里使用的技术被称为<em class="ms">style gan2</em>【2】(GANs 的一个变种)，其中生成的图像大小为 1024 <em class="ms"> </em> x <em class="ms"> </em> 1024，因此数量级为 1 <em class="ms">兆像素</em>。</em></p><p id="a23e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为了反映来自真实世界的一些数据准备，额外的约束将应用于构建我们的立方体。它们将从数据帧中导出，并且将是堆叠<em class="ms"> numpy </em>数组的结果。为了简单起见，这些数据帧将具有随机值。</p><blockquote class="mt mu mv"><p id="b1dc" class="lr ls ms lt b lu mn ju lw lx mo jx lz mw mp mc md mx mq mg mh my mr mk ml mm im bi translated"><strong class="lt iu">这里的目标是尽可能快地创建立方体！</strong></p></blockquote><p id="223e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">第一步将在我们的本地机器上完成，其规格在<em class="ms">表 1 中描述。如你所见，这已经是一个相当不错的设置了。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/88cb30a5faf336592f47f4f0b9082818.png" data-original-src="https://miro.medium.com/v2/resize:fit:1106/format:webp/1*iUTFRwNbvTZx9NS0WuefSA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">表 1:我们本地机器的规格。</p></figure><h1 id="d471" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">输入数据</h1><p id="b464" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们首先生成大小为 1000 <em class="ms"> </em> x <em class="ms"> </em> 1000 的 100 个数据帧，由于使用了<code class="fe na nb nc nd b">numpy.random.rand</code>函数，这些数据帧包含随机浮点(四舍五入到 10 位小数)。然后使用<code class="fe na nb nc nd b">pandas.DataFrame.to_csv</code>功能将数据帧保存到磁盘。每个 csv 文件大约 13 Mo。</p><p id="587b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">对于每个立方体，我们将不得不使用所有的数据帧来从中提取一个随机子集。使用<code class="fe na nb nc nd b">pandas.read_csv</code>函数，读取所有数据帧需要 20.87 秒，因此每秒 4.79 个文件。这是非常慢的<strong class="lt iu"/>。根据记录，如果我们想要构建 100 万个立方体，按照这个速度，需要<strong class="lt iu">超过 240 天</strong>！</p><p id="5167" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们考虑使用<em class="ms"> parquet </em>文件格式来保存我们的数据帧，而不是使用 csv 格式。使用<em class="ms"> fastparquet </em>引擎【3】，每个保存的拼花文件现在只有 8 Mo。如果你想了解更多的拼花文件格式，可以查看官网<a class="ae ky" href="https://parquet.apache.org/documentation/latest/" rel="noopener ugc nofollow" target="_blank">这里</a>【4】。这一次，读取全部 100 个数据帧只需要 6.57 <em class="ms"> s </em>(或 15.21 files/s)！这代表了 3.2 倍的加速。第一批结果汇总在<em class="ms">表 2 </em>中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/0a6ed670f3a672eb6bc54c91c89b9c53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/format:webp/1*JKH45VYle-ZMZkeMiLmPlQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">表 2:CSV 与 parquet 的读取速度比较(100 个文件)。</p></figure><h1 id="4f62" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">建造我们的第一个立方体</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/304980dfbb48a83cfe222b316009ccc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7J1A9oSsyC4C_bwO"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@henkiboy?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马克斯·亨克</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="6549" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">使用一些约束，以下步骤将适用于构建一个立方体:</p><ol class=""><li id="1e1b" class="ng nh it lt b lu mn lx mo ma ni me nj mi nk mm nl nm nn no bi translated">对于每个数据帧，我们提取包含前 100 行和 100 个随机列的子数据帧，</li><li id="57a7" class="ng nh it lt b lu np lx nq ma nr me ns mi nt mm nl nm nn no bi translated">每个子数据帧然后被转换成尺寸为 100×100 的<em class="ms"> numpy </em>数组，</li><li id="c4c5" class="ng nh it lt b lu np lx nq ma nr me ns mi nt mm nl nm nn no bi translated">将<em class="ms"> numpy </em>数组堆叠起来，形成一个立方体。</li></ol><pre class="kj kk kl km gt nu nd nv nw aw nx bi"><span id="935d" class="ny la it nd b gy nz oa l ob oc"><em class="ms"># CREATING THE CUBES FROM FILES (READ IN A LOOP)</em></span><span id="a5c3" class="ny la it nd b gy od oa l ob oc"><strong class="nd iu">import</strong> numpy <strong class="nd iu">as</strong> np<br/><strong class="nd iu">import</strong> pandas <strong class="nd iu">as</strong> pd</span><span id="45d7" class="ny la it nd b gy od oa l ob oc">ncubes = 100<br/>dim = 100</span><span id="dadc" class="ny la it nd b gy od oa l ob oc"><strong class="nd iu">for</strong> n <strong class="nd iu">in</strong> range(ncubes):<br/>    cube = np.zeros(shape=(dim, dim, dim))<br/>    <em class="ms"># 'files_list' is the list of the parquet file paths</em><br/>    <strong class="nd iu">for</strong> i, f <strong class="nd iu">in</strong> enumerate(files_list):<br/>        df = pd.read_parquet(f)<br/>        df = df.head(dim)<br/>        rnd_cols = random.sample(range(1, df.shape[1]), dim)<br/>        df = df.iloc[:, rnd_cols]<br/>        layer = df.to_numpy()<br/>        cube[i, :, :] = layer</span></pre><p id="ee28" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">获得一批 100 个立方体的总时间约为 661 秒(几乎 11 分钟)，因此速率为<strong class="lt iu"> 0.15 个立方体/秒</strong>。</p><p id="1f0d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我相信你已经发现了这里的错误。事实上，对于每个立方体，我们每次都读取相同的 100 个拼花文件！实际上，您肯定不希望遍历这些文件。关于<strong class="lt iu">数据</strong> <strong class="lt iu">结构</strong>的下一个改进将会解决这个问题。</p><h1 id="476b" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">提高速度—步骤 1:数据结构</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/e68bbbd228ae3794df050881d8ccd8d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PhEBhq_HwB640yuU"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@fezbot2000?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Fezbot2000 </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="ae93" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">因为我们不想在循环中读取每个立方体的拼花文件，所以最好只提前执行一次这个任务。因此，我们可以构建一个字典<code class="fe na nb nc nd b">df_dict</code>，将文件名作为键，将数据帧作为值。这个操作非常快，而且字典只有 7.33 秒。</p><p id="e98e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在，我们将编写一个函数来创建一个立方体，利用这个字典已经读取了数据帧并将其存储为自己的值。</p><pre class="kj kk kl km gt nu nd nv nw aw nx bi"><span id="3db0" class="ny la it nd b gy nz oa l ob oc"><em class="ms"># FUNCTION CREATING A CUBE FROM A DICTIONARY OF DATAFRAMES</em></span><span id="aaed" class="ny la it nd b gy od oa l ob oc"><strong class="nd iu">def</strong> create_cube(dimc, dict_df):<br/>    cube = np.zeros(shape=(dimc, dimc, dimc))<br/>    <strong class="nd iu">for</strong> i, df <strong class="nd iu">in</strong> enumerate(dict_df.values()):<br/>        df = df.head(dimc)<br/>        rnd_cols = random.sample(range(1, df.shape[1]), dimc)<br/>        df = df.iloc[:, rnd_cols]<br/>        layer = df.to_numpy()<br/>        cube[i, :, :] = layer<br/>    <strong class="nd iu">return</strong> cube</span></pre><p id="756c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这一次，创建 100 个立方体只需要 6.61 秒，速率为<strong class="lt iu"> 15.13 个立方体/秒</strong>。与不使用数据帧字典的先前版本相比，这代表了 100 倍的加速。创建我们这一批 100 万个立方体现在只需要将近 20 个小时，而不是最初的 240 天。</p><p id="31e3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在，我们仍然使用数据帧来构建我们的立方体，也许是时候使用<strong class="lt iu">full</strong>T11】NumPy 来提高我们的速度了。</p><h1 id="c91c" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">提高速度——第二步:NumPy Rocks！</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/b653f90da380bc965da5abf5ef2216cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WI9pt1G3yOLSdY_e"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@hansonluu?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Hanson Lu </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="0745" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">以前使用数据帧字典的想法很有趣，但可以通过从一开始就构建一个从 parquet 文件派生的<code class="fe na nb nc nd b">numpy.ndarray</code>来改进，我们将沿着列对其进行子采样以创建我们的立方体。让我们首先创建这个大男孩:</p><pre class="kj kk kl km gt nu nd nv nw aw nx bi"><span id="925d" class="ny la it nd b gy nz oa l ob oc"><em class="ms"># CREATING THE RAW DATA (NUMPY FORMAT)</em></span><span id="0f47" class="ny la it nd b gy od oa l ob oc">arr_data = np.zeros(shape=(100, 1000, 1000))<br/><em class="ms"># 'files_list' is the list of the parquet file paths</em><br/><strong class="nd iu">for</strong> i, j <strong class="nd iu">in</strong> enumerate(files_list):<br/>    df = pd.read_parquet(j)<br/>    layer = df.to_numpy()<br/>    arr_data[i, :, :] = layer</span></pre><p id="2f06" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然后，我们必须相应地修改我们的<code class="fe na nb nc nd b">create_cube</code>函数，并实现一个完整的向量化:</p><pre class="kj kk kl km gt nu nd nv nw aw nx bi"><span id="aff3" class="ny la it nd b gy nz oa l ob oc"><em class="ms"># FUNCTION CREATING A CUBE FROM RAW DATA (FULL NUMPY VERSION)</em></span><span id="2d18" class="ny la it nd b gy od oa l ob oc"><strong class="nd iu">def</strong> create_cube_np(dimc):<br/>    rnd_cols = random.sample(range(1, 1000), dimc)<br/>   <em class="ms"> # First 100 rows, 100 random columns (vectorization)</em><br/>    cube = arr_data[:, :100, rnd_cols]<br/>    <strong class="nd iu">return</strong> cube</span></pre><p id="d896" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">使用这个新版本，我们能够在 1.31 秒内创建 100 个立方体，因此有一个不错的速率<strong class="lt iu"> 76.26 立方体/秒</strong>。</p><p id="f861" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在，我们可以进入下一步，以更快的速度前进。你猜对了，是时候进行<strong class="lt iu">并行化</strong>了！</p><h1 id="d2cc" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">提高速度—步骤 3:并行化</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/000f858e662405077b86bffe682036cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RddSQYNngXwjZUns"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@marcojodoin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马克-奥利维尔·乔多因</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="b023" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在 Python【5】【6】中有几种方法可以执行<a class="ae ky" href="https://docs.python.org/3/library/multiprocessing.html" rel="noopener ugc nofollow" target="_blank">并行化。这里，我们将使用原生的<code class="fe na nb nc nd b">multiprocessing</code> Python 包和<code class="fe na nb nc nd b">imap_unordered</code>函数来执行异步作业。我们计划利用本地机器上的 12 个内核。</a></p><pre class="kj kk kl km gt nu nd nv nw aw nx bi"><span id="1d78" class="ny la it nd b gy nz oa l ob oc"><em class="ms"># PARALLELIZATION</em></span><span id="448a" class="ny la it nd b gy od oa l ob oc"><strong class="nd iu">from</strong> multiprocessing.pool <strong class="nd iu">import</strong> ThreadPool</span><span id="039b" class="ny la it nd b gy od oa l ob oc">proc = 12  <em class="ms"># Number of workers</em><br/>ncubes = 100<br/>dim = 100</span><span id="6f94" class="ny la it nd b gy od oa l ob oc"><strong class="nd iu">def</strong> work(none=None):<br/>    <strong class="nd iu">return</strong> create_cube_np(dim)</span><span id="0119" class="ny la it nd b gy od oa l ob oc"><strong class="nd iu">with</strong> ThreadPool(processes=proc) <strong class="nd iu">as</strong> pool:<br/>    cubes = pool.imap_unordered(work, (None for i in range(ncubes)))<br/>    <strong class="nd iu">for</strong> n <strong class="nd iu">in</strong> range(ncubes):<br/>        c = next(cubes)  <em class="ms"># Cube is retrieved here</em></span></pre><p id="8f21" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这里导入了<code class="fe na nb nc nd b">ThreadPool</code>包(而不是通常的<code class="fe na nb nc nd b">Pool</code>包)，因为我们希望<strong class="lt iu">确保以下</strong>:</p><ul class=""><li id="edc6" class="ng nh it lt b lu mn lx mo ma ni me nj mi nk mm oh nm nn no bi translated">留在同一个进程中，</li><li id="fa3d" class="ng nh it lt b lu np lx nq ma nr me ns mi nt mm oh nm nn no bi translated">避免在进程间传输数据，</li><li id="8296" class="ng nh it lt b lu np lx nq ma nr me ns mi nt mm oh nm nn no bi translated">通过使用仅<em class="ms"> numpy </em>操作绕过 Python 全局解释器锁(GIL)(大多数<em class="ms"> numpy </em>计算不受 GIL 影响)。</li></ul><p id="fc71" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在这篇漂亮的<a class="ae ky" href="https://nathangrigg.com/2015/04/python-threading-vs-processes" rel="noopener ugc nofollow" target="_blank">博客文章</a>【7】中，你可以了解更多关于 Python 中多重处理和多线程的区别。</p><p id="0169" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">使用这种<em class="ms">多线程</em>方法，我们只需要 0.28 秒就可以创建一批 100 个立方体。我们达到了非常好的速率<strong class="lt iu"> 355.50 立方/秒</strong>，因此与第一个版本相比，速度提高了 2370 倍(<em class="ms">表 3 </em>)。关于我们的 1，000，000 个立方体，生成时间已经下降了<strong class="lt iu">不到一个小时</strong>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/24afad7f7e61fc1b5eea144cbc3e2cf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1KgrGjJ4D5RiDuuZpNc9Aw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">表 3:立方体的本地生成，速度结果。</p></figure><p id="761e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在，是使用<strong class="lt iu">云</strong>中的虚拟机实例<em class="ms">飞行</em>的时候了！</p><h1 id="8ac7" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">提高速度—步骤 4:云</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/c8693fc2ba33b8d07a2d153671b708e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EinQXCgKdC4NyzFy"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@spacex?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> SpaceX </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="cfe5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果说机器学习即服务(<em class="ms"> MLaaS </em>)，排名前 4 的云解决方案分别是:微软 Azure、亚马逊 AWS、IBM Watson 和谷歌云平台(GCP)。在这项研究中，我们选择了 GCP，但任何其他供应商都可以完成这项工作。您可以在许多不同的虚拟机实例中选择或定制您自己的配置，您将能够在笔记本电脑中执行您的代码。</p><p id="ae9a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">你想问自己的第一个问题如下:</p><blockquote class="mt mu mv"><p id="f5e5" class="lr ls ms lt b lu mn ju lw lx mo jx lz mw mp mc md mx mq mg mh my mr mk ml mm im bi translated">"我想创建什么样的实例来满足我的计算需求？"</p></blockquote><p id="ef29" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">基本上，你可以找到三种类型的机器:通用、内存优化或计算优化(<em class="ms">表 4 </em>)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/ef6ac9ca918fa91f0cbd04e19978affd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*tszQWQossMgIyU4mNDAV_g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">表 4:不同工作负载的机器类型建议。</p></figure><p id="7775" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">计算<em class="ms"> numpy </em>。<em class="ms"> ndarray </em>从<em class="ms">步骤 2 </em>开始，拼花文件首先被存储到云中的一个桶中。然后，在不同的 VM 实例上进行几次测试(<em class="ms">表 5 </em>，保持与<em class="ms">步骤 3 </em>中相同的多线程代码，并逐步增加 vcpu(worker)的数量。一台虚拟机的结果示例在<em class="ms">表 6 </em>中给出。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/25cadf7310796a09f480c5e6703d1247.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I9hZKIZIkGLmQmwA33zEdg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">表 5:一些虚拟机实例的选择。</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/1a9c826dc2ee281c8d819cdd20d14ab8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sny538dX5JWnqI1Co_4bMA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">表 6:针对“<em class="on">N2-high CPU-80”</em>实例的速度结果。</p></figure><p id="ebac" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在连接到虚拟机的<em class="ms">终端</em>中，您还可以使用<code class="fe na nb nc nd b">htop</code> <em class="ms"> linux </em>命令(<em class="ms">图 1 </em>)来可视化 vCPUs 的活动。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/65fb41b270b25a95c499091467116dbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DlezgyvfOmbM0bOWIcV22w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 1:我们 160 个内核协同工作的情况(“m1-ultramem-160”实例)。</p></figure><h1 id="0fdf" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">结论</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/971b19a4d9de27434a382193e9bb3722.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A_ZDThR-HwIyvfFdSqkc5g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 2:所有测试的虚拟机实例的性能。</p></figure><p id="08a4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">查看<em class="ms">图 2 </em>，除了<em class="ms"> m1-ultramem-160 </em>实例(这是最昂贵的)之外，其他所有实例都执行得相当好，但是遵循相同的模式。该比率几乎随着工作人员数量的增加而线性增加，并在 60 个 vCPUs 时达到峰值。超过这个限制，速率会急剧下降，很可能是因为多线程的<em class="ms">开销</em>。</p><p id="2d42" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在我们的选择中，<strong class="lt iu">胜出者</strong>是<em class="ms"> n2-highcpu-80 </em>实例(第二便宜)，达到了<strong class="lt iu"> 2026.62 cubes/s </strong>的速率，几乎是<strong class="lt iu">每秒 20 亿个数据点</strong>。按照这个速度，我们可以在仅仅<strong class="lt iu"> 8 分钟</strong>内生成 100 万个立方体。</p><blockquote class="mt mu mv"><p id="98da" class="lr ls ms lt b lu mn ju lw lx mo jx lz mw mp mc md mx mq mg mh my mr mk ml mm im bi translated">我们最初的目标成功实现了！</p></blockquote><p id="87c8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">整个实验表明，不仅代码很重要，硬件也很重要。我们在本地机器上以 0.15 立方/秒的速率开始，使用<strong class="lt iu">云</strong>达到了非常快的速率<strong class="lt iu"> 2027 立方/秒</strong>。这比<strong class="lt iu">13500 倍加速</strong>还要多！</p><p id="eb89" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这仅仅是开始…我们可以通过使用更先进的技术和基础设施来升级。这是为第二集准备的。</p><h1 id="2fd9" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">参考</h1><p id="bb98" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">[1] <a class="ae ky" href="https://95ba6910-ffb9-46f0-bab4-8431d2e31772.filesusr.com/ugd/dcd9aa_6ca686087fd04f04bd20b5f71a1f5ceb.pdf" rel="noopener ugc nofollow" target="_blank"> N. Morizet，生成式对抗网络导论(2020)，Advestis Tech Report </a>。</p><p id="f21a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">[2] <a class="ae ky" href="https://research.nvidia.com/publication/2019-12_Analyzing-and-Improving" rel="noopener ugc nofollow" target="_blank"> T. Karras <em class="ms">等人</em>，StyleGAN (2019)的图像质量分析与改进，NVIDIA Research </a>。</p><p id="e63b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">[3]<a class="ae ky" href="https://fastparquet.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">【fastparquet】正式文件(2020) </a>。</p><p id="2bfa" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">[4]<a class="ae ky" href="https://parquet.apache.org/documentation/latest/" rel="noopener ugc nofollow" target="_blank">阿帕奇拼花地板官方文档(2020) </a>。</p><p id="9ba0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">[5] <a class="ae ky" href="https://docs.python.org/3/library/multiprocessing.html" rel="noopener ugc nofollow" target="_blank">多处理——基于进程的并行性(2020)，Python 标准库</a>。</p><p id="fef3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">[6] " <a class="ae ky" href="https://docs.ray.io/en/latest/index.html" rel="noopener ugc nofollow" target="_blank">雷"框架正式文件(2020) </a>。</p><p id="6ce9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">[7]n . Grigg，阐释 Python 多线程与多处理(2015)，来自 nathangrigg.com 的博客文章。</p><h1 id="e4a1" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">关于我们</h1><p id="727e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><a class="ae ky" href="https://www.advestis.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="lt iu"> Advestis </strong> </a>是一家欧洲合同研究组织(CRO)，对统计学和可解释的机器学习技术有着深刻的理解和实践。Advestis 的专长包括复杂系统的建模和时间现象的预测分析。<br/> <em class="ms">领英</em>:<a class="ae ky" href="https://www.linkedin.com/company/advestis/" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/company/advestis/</a></p></div></div>    
</body>
</html>