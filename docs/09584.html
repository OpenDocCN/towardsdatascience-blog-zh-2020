<html>
<head>
<title>Build And Host Fast Data Science Applications Using FastAPI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 FastAPI 构建和托管快速数据科学应用</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/build-and-host-fast-data-science-applications-using-fastapi-823be8a1d6a0?source=collection_archive---------8-----------------------#2020-07-08">https://towardsdatascience.com/build-and-host-fast-data-science-applications-using-fastapi-823be8a1d6a0?source=collection_archive---------8-----------------------#2020-07-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7ce0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">将智能数据科学应用程序构建为 Restful API 的分步指南</h2></div><p id="f141" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我最近使用 FastAPI web 框架托管了许多生产就绪的数据科学应用程序，作为 Restful web 服务。</p><p id="460f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我发现 FastAPI 稳定且易于使用，因此，我决定写一篇关于 FastAPI 库的文章，概述托管数据科学应用程序的步骤。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi le"><img src="../Images/425a246971580e57cdda58a4defd7981.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*BUdPprpT1LDBBWzXFPfblA.png"/></div><p class="lm ln gj gh gi lo lp bd b be z dk translated">解释 FastAPI 的工作原理</p></figure><p id="9f29" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">FastAPI 于 2018 年发布，正在成为构建高性能数据科学应用的事实上的选择。</p><p id="3b0a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本文将解释什么是 FastAPI，为什么它优于竞争对手，以及如何使用 FastAPI 托管数据科学应用程序的分步指南。</p><blockquote class="lq"><p id="b021" class="lr ls it bd lt lu lv lw lx ly lz ld dk translated">可以把 FastAPI 想象成一个数据科学应用程序的包装器，以 RESTFUL 微服务的形式公开其功能</p></blockquote><figure class="mb mc md me mf lj gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi ma"><img src="../Images/502429e32c1f13e39cf6e5470af66af4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hyOzvQKuVr1ELfFv0YWNWw.png"/></div></div><p class="lm ln gj gh gi lo lp bd b be z dk translated">作为包装器的 FastAPI</p></figure><h1 id="8e3d" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">文章摘要</h1><p id="8ed3" class="pw-post-body-paragraph ki kj it kk b kl nc ju kn ko nd jx kq kr ne kt ku kv nf kx ky kz ng lb lc ld im bi translated">本文将概述以下主题:</p><ol class=""><li id="532a" class="nh ni it kk b kl km ko kp kr nj kv nk kz nl ld nm nn no np bi translated">什么是 FastAPI？</li><li id="3804" class="nh ni it kk b kl nq ko nr kr ns kv nt kz nu ld nm nn no np bi translated">FastAPI 的主要特性</li><li id="7da3" class="nh ni it kk b kl nq ko nr kr ns kv nt kz nu ld nm nn no np bi translated">使用 FastAPI 构建和托管 Python 数据科学应用程序的分步指南。</li></ol><blockquote class="lq"><p id="07f5" class="lr ls it bd lt lu nv nw nx ny nz ld dk translated">本文将构建一个真实的数据科学应用程序来演示如何在您的数据科学项目中使用 FastAPI</p></blockquote><h1 id="4b95" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz oa ka mw kc ob kd my kf oc kg na nb bi translated">1.什么是 FastAPI？</h1><p id="2fee" class="pw-post-body-paragraph ki kj it kk b kl nc ju kn ko nd jx kq kr ne kt ku kv nf kx ky kz ng lb lc ld im bi translated">顾名思义，FastAPI 是一个高性能的 web 框架。它的性能可以与 NodeJS 和 Go 相提并论，它被评为目前最快的 Python 框架之一。</p><blockquote class="lq"><p id="f3aa" class="lr ls it bd lt lu lv lw lx ly lz ld dk translated">网飞、优步、微软以及许多其他公司都在使用 FastAPI 库。</p></blockquote><p id="b61b" class="pw-post-body-paragraph ki kj it kk b kl oe ju kn ko of jx kq kr og kt ku kv oh kx ky kz oi lb lc ld im bi translated">FastAPI 可以帮助我们用 Python 3.6+构建 API。</p><p id="7e20" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它基于标准的 Python 类型提示。FastAPI 不仅在项目中使用起来直观明了，而且 FastAPI 代码还具有 100%的测试覆盖率，因此它是生产就绪的健壮代码。</p><p id="4a28" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用 Flask 有一段时间了，我注意到 FastAPI 和 Flask 一样简单易用。事实上，FastAPI 已经从 Flask API 改编了它的简单性。随后，总的来说，我建议在未来的项目中探索 FastAPI。</p><blockquote class="lq"><p id="8178" class="lr ls it bd lt lu lv lw lx ly lz ld dk translated">FastAPI 建立在 Starlette 和 Pydantic 库的基础上。</p></blockquote><p id="0482" class="pw-post-body-paragraph ki kj it kk b kl oe ju kn ko of jx kq kr og kt ku kv oh kx ky kz oi lb lc ld im bi translated">该图说明了 FastAPI 使用 Starlette 作为 web 部件，使用 Pydantic 作为数据部件。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi oj"><img src="../Images/f4182135e37c1af6f4120e5340450698.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*027mZtvcwsqxDblcdWbJQg.png"/></div></div><p class="lm ln gj gh gi lo lp bd b be z dk translated">FastAPI 基于 Pydantic 和 Starlette</p></figure><p id="0c8d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">ydantic 是一个 Python 库，用于执行数据验证、文档以及序列化。P <em class="ok"> ydantic </em>使用 PEP 484 中定义的标准库<code class="fe ol om on oo b">typing</code>类型来定义复杂对象。</p><p id="3ce6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们来探索一下 FastAPI 的特性。</p><h1 id="f226" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">2.FastAPI 的主要特性</h1><h2 id="f679" class="op ml it bd mm oq or dn mq os ot dp mu kr ou ov mw kv ow ox my kz oy oz na pa bi translated">1.要概述的第一个特性是自动交互式 API 文档</h2><p id="d084" class="pw-post-body-paragraph ki kj it kk b kl nc ju kn ko nd jx kq kr ne kt ku kv nf kx ky kz ng lb lc ld im bi translated">FastAPI 是基于开放标准的<a class="ae od" href="https://github.com/OAI/OpenAPI-Specification" rel="noopener ugc nofollow" target="_blank"> OpenAPI </a>和<a class="ae od" href="http://json-schema.org/" rel="noopener ugc nofollow" target="_blank"> JSON 模式</a>。因此，只要我们使用适当的 Pydantic 数据类型，它可以自动为我们的 web API 构建一个 SwaggerUI，而无需任何额外的编码。SwaggerUI 本质上是交互式的，允许我们直接从浏览器测试 API。自动化文档受到 APISpec 的启发。</p><blockquote class="lq"><p id="153d" class="lr ls it bd lt lu lv lw lx ly lz ld dk translated">我将在本文后面演示如何使用 FastAPI 用 JSON schema 构建自动数据模型文档。</p></blockquote><p id="0dc2" class="pw-post-body-paragraph ki kj it kk b kl oe ju kn ko of jx kq kr og kt ku kv oh kx ky kz oi lb lc ld im bi translated">FastAPI 还允许我们验证来自外部调用者的输入数据，并在接收到无效数据时向客户端自动生成错误。文档特性受到了 Django REST 框架的启发。</p><p id="80c4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">OpenAPI 自动为应用程序生成一个模式。FastAPI 还支持数据序列化和输入数据解析，这是受 Marshmallow 和 Webargs 的启发。点击阅读更多信息<a class="ae od" href="https://fastapi.tiangolo.com/alternatives/#flask" rel="noopener ugc nofollow" target="_blank"/></p><h2 id="6374" class="op ml it bd mm oq or dn mq os ot dp mu kr ou ov mw kv ow ox my kz oy oz na pa bi translated">2.第二个关键特性是支持异步 IO 操作</h2><p id="e1de" class="pw-post-body-paragraph ki kj it kk b kl nc ju kn ko nd jx kq kr ne kt ku kv nf kx ky kz ng lb lc ld im bi translated">构建一个在执行操作时不会阻塞调用者的 web API 是至关重要的。Python 中的 asyncio 库提供了大量的异步功能。</p><p id="3993" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">FastAPI 库支持异步 IO 操作。这是可能的，因为 FastAPI 是基于 Starlette 库的。</p><p id="cbf9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Starlette 图书馆本身坐落在 Uvicorn 的顶部。Uvicorn 是一个支持 asyncio 框架的快如闪电的 ASGI 服务器。</p><p id="6e5d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Starlette 是一个轻量级的 ASGI 框架，它使我们能够构建高性能的 asyncio 服务。</p><p id="adb1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与 WSGI 服务器不同，ASGI 服务器可以支持 HTTP/2 和 WebSockets。在 Uvicorn 的帮助下，我们可以构建一个 web API，它可以在 IO 绑定的上下文中实现高吞吐量。</p><blockquote class="lq"><p id="51e9" class="lr ls it bd lt lu lv lw lx ly lz ld dk translated">Starlette 使用较新的异步 IO ASGI 服务器，也支持后台任务。因此，我们可以使用 FastAPI 构建低潜在的快速 web APIs</p></blockquote><h2 id="94fe" class="op ml it bd mm oq pb dn mq os pc dp mu kr pd ov mw kv pe ox my kz pf oz na pa bi translated">3.最重要的特征；我们可以快速为我们的数据科学应用程序创建 REST 端点</h2><p id="9b55" class="pw-post-body-paragraph ki kj it kk b kl nc ju kn ko nd jx kq kr ne kt ku kv nf kx ky kz ng lb lc ld im bi translated">Flask 用户必须安装 Flask-restplus 包来为他们的数据科学应用程序创建 REST 端点。</p><p id="3a6a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">FastAPI 支持 GET、PUT、POST、DELETE、OPTIONS、HEAD、PATCH 和 TRACE Rest 操作，无需任何额外的包。所有路线及其操作都是在文档中自动生成的。</p><h2 id="4515" class="op ml it bd mm oq or dn mq os ot dp mu kr ou ov mw kv ow ox my kz oy oz na pa bi translated">4.FastAPI 应用程序易于安装、使用和支持</h2><p id="32dc" class="pw-post-body-paragraph ki kj it kk b kl nc ju kn ko nd jx kq kr ne kt ku kv nf kx ky kz ng lb lc ld im bi translated">最近我注意到了这个行业的一个模式。将数据科学解决方案快速推向市场变得至关重要。此外，数据科学应用程序是大型生态系统的一个组成部分，它们需要与许多服务和接口进行交互。这意味着能够将应用程序快速部署为 web 服务，以便最终用户可以使用它，这是非常重要的。</p><p id="8121" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">FastAPI 使用起来很简单。将数据科学应用托管为微服务并公开其他应用可以调用的 Rest 端点只需几分钟。验证、错误处理以及其他 API 特性都是现成的，有助于提高客户满意度和应用程序的可靠性。</p><p id="bf35" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将我们带到本文的最后一节，在这里我将演示托管数据科学应用程序的步骤。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/c231574aab7a8db9e6a01088bcd8a877.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*IklcTl3o3fBAf33pPOYlZQ.png"/></div><p class="lm ln gj gh gi lo lp bd b be z dk translated">分步指南</p></figure><h1 id="c98a" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">3.逐步实施</h1><p id="abb0" class="pw-post-body-paragraph ki kj it kk b kl nc ju kn ko nd jx kq kr ne kt ku kv nf kx ky kz ng lb lc ld im bi translated">让我们从构建智能数据科学应用程序的真实用例开始。</p><h2 id="7ce5" class="op ml it bd mm oq or dn mq os ot dp mu kr ou ov mw kv ow ox my kz oy oz na pa bi translated">用例</h2><ol class=""><li id="d5c2" class="nh ni it kk b kl nc ko nd kr ph kv pi kz pj ld nm nn no np bi translated">我们将使用 Python 3.8 构建一个数据科学应用程序</li><li id="3ffe" class="nh ni it kk b kl nq ko nr kr ns kv nt kz nu ld nm nn no np bi translated">该应用程序将抓取在线网页，以返回作为指数成份股的公司列表，如富时 100 指数、标准普尔 500 或道琼斯。</li><li id="a106" class="nh ni it kk b kl nq ko nr kr ns kv nt kz nu ld nm nn no np bi translated">该功能将通过 GET Rest 端点公开，我们将在本地主机的端口 8000 上托管该端点。端点将接受一个查询参数:index。该指数只能是下列指数之一:富时 100 指数、标准普尔 500 指数或道琼斯指数。</li><li id="2506" class="nh ni it kk b kl nq ko nr kr ns kv nt kz nu ld nm nn no np bi translated">端点还将确保该值是可接受的索引值之一。所有的错误都将被处理，并优雅地发送回 API 的用户/调用者。</li><li id="a85b" class="nh ni it kk b kl nq ko nr kr ns kv nt kz nu ld nm nn no np bi translated">我们将使用 FastAPI 自动生成 Swagger UI 和 OpenAPI 文档。</li></ol><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi pk"><img src="../Images/bd0b45bf5f719c1a4fccda288bd537d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EagzMoRz6JeGLEspxXD7ZA.png"/></div></div><p class="lm ln gj gh gi lo lp bd b be z dk translated">目标应用程序</p></figure><h2 id="4311" class="op ml it bd mm oq or dn mq os ot dp mu kr ou ov mw kv ow ox my kz oy oz na pa bi translated">1.创建虚拟环境</h2><p id="25b7" class="pw-post-body-paragraph ki kj it kk b kl nc ju kn ko nd jx kq kr ne kt ku kv nf kx ky kz ng lb lc ld im bi translated">第一步是创建一个虚拟环境并激活它。</p><pre class="lf lg lh li gt pl oo pm pn aw po bi"><span id="ab6b" class="op ml it oo b gy pp pq l pr ps">python3 -m venv fintechexplained<br/>fintechexplained<!-- -->\Scripts\activate</span></pre><h2 id="05dc" class="op ml it bd mm oq or dn mq os ot dp mu kr ou ov mw kv ow ox my kz oy oz na pa bi translated">2.安装依赖项</h2><p id="4eee" class="pw-post-body-paragraph ki kj it kk b kl nc ju kn ko nd jx kq kr ne kt ku kv nf kx ky kz ng lb lc ld im bi translated">下一步是安装所需的模块。</p><p id="39b3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，安装 fastapi</p><pre class="lf lg lh li gt pl oo pm pn aw po bi"><span id="a3d7" class="op ml it oo b gy pp pq l pr ps">pip install fastapi==0.58.1</span></pre><p id="d23c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，它还将安装所需的依赖项，如 starlette==0.13.4 和 pydantic==1.5.1。</p><p id="4db8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后安装 uvicorn</p><pre class="lf lg lh li gt pl oo pm pn aw po bi"><span id="ae8b" class="op ml it oo b gy pp pq l pr ps">pip install uvicorn==0.11.5</span></pre><p id="5bf6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，为了抓取网页，我将使用熊猫图书馆。因此，下一步是安装熊猫:</p><pre class="lf lg lh li gt pl oo pm pn aw po bi"><span id="2027" class="op ml it oo b gy pp pq l pr ps">pip install pandas==1.0.3</span></pre><p id="e6a6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">安装步骤完成了。</strong></p><p id="d09b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们创建文件夹结构。</p><h2 id="86d3" class="op ml it bd mm oq or dn mq os ot dp mu kr ou ov mw kv ow ox my kz oy oz na pa bi translated">3.创建项目结构</h2><p id="cfda" class="pw-post-body-paragraph ki kj it kk b kl nc ju kn ko nd jx kq kr ne kt ku kv nf kx ky kz ng lb lc ld im bi translated">为了简单起见，让我们创建以下文件夹结构。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi pt"><img src="../Images/2ea933ccde35e95bd40c98d7da8724b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/format:webp/1*kEnlIeNk_JxFzzDPacnTrA.png"/></div></figure><p id="f461" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们创建了两个文件夹:SmartApp 和 SmartApp 文件夹中的 src。此外，让我们创建以下三个空 Python 文件:</p><ol class=""><li id="b581" class="nh ni it kk b kl km ko kp kr nj kv nk kz nl ld nm nn no np bi translated">这个文件将包含启动 uvicorn 服务器的代码。它还将包含异步服务请求和返回响应的代码。这个文件还将创建一个 FastAPI()实例，它是创建 API 的主要交互点。</li><li id="254f" class="nh ni it kk b kl nq ko nr kr ns kv nt kz nu ld nm nn no np bi translated">models.py:这个文件将包含应用程序的域类，比如 Company 和 Configuration。</li><li id="a456" class="nh ni it kk b kl nq ko nr kr ns kv nt kz nu ld nm nn no np bi translated">workflow_runner:这个文件将包含抓取网页并返回公司名称的代码。这是我们的数据科学应用程序代码，我们将通过 FastAPI 公开它。</li></ol><p id="0162" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您想创建一个生产就绪的解决方案，那么我推荐使用千篇一律的 python 项目。有许多模板可用，包括一个针对 FastAPI 的模板。</p><p id="7750" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">确保虚拟环境已激活。</p><h2 id="fcbb" class="op ml it bd mm oq or dn mq os ot dp mu kr ou ov mw kv ow ox my kz oy oz na pa bi translated">4.Python 代码实现</h2><p id="aedb" class="pw-post-body-paragraph ki kj it kk b kl nc ju kn ko nd jx kq kr ne kt ku kv nf kx ky kz ng lb lc ld im bi translated">下一步涉及实现 Python 代码。</p><h2 id="9681" class="op ml it bd mm oq or dn mq os ot dp mu kr ou ov mw kv ow ox my kz oy oz na pa bi translated">models.py</h2><p id="f614" class="pw-post-body-paragraph ki kj it kk b kl nc ju kn ko nd jx kq kr ne kt ku kv nf kx ky kz ng lb lc ld im bi translated">打开 models.py 文件并添加以下代码:</p><pre class="lf lg lh li gt pl oo pm pn aw po bi"><span id="bc66" class="op ml it oo b gy pp pq l pr ps">from enum import Enum<br/>from pydantic import BaseModel</span><span id="661a" class="op ml it oo b gy pu pq l pr ps">class MyException(Exception):<br/>    pass</span><span id="5db2" class="op ml it oo b gy pu pq l pr ps">class Company:<br/>    def __init__(self, symbol):<br/>        self.name = None<br/>        self.symbol = symbol<br/>        self.sector = None<br/>        self.industry = None<br/><br/>class Index(str, Enum):<br/>    FTSE100 = "FTSE 100"<br/>    SNP500 = "S&amp;P 500"<br/>    DOWJONE = "Dow Jones"<br/><br/>class Configuration(BaseModel):<br/>    index: str = None<br/><br/>    index_map = {<br/>        Index.FTSE100: 'https://en.wikipedia.org/wiki/FTSE_100_Index',<br/>        Index.SNP500: 'http://en.wikipedia.org/wiki/List_of_S%26P_500_companies'<br/>    }<br/><br/>    def get_url(self):<br/>        return self.index_map[self.index]</span></pre><ul class=""><li id="ec23" class="nh ni it kk b kl km ko kp kr nj kv nk kz nl ld pv nn no np bi translated">我们将有一个名为 Company 的类来代表指数的每个成分。</li><li id="27c0" class="nh ni it kk b kl nq ko nr kr ns kv nt kz nu ld pv nn no np bi translated">我们还创建了一个配置类。此类包含作为枚举的索引名称。枚举成员将作为下拉菜单显示在 API 文档和 Swagger UI 中。请注意，配置类继承自 pydantic BaseModel。这将使我们能够生成自动数据模式文档。配置类包含一个名为 index_map 的字典。每个索引映射项的键作为索引枚举成员，值作为包含公司信息的网页的 URL。</li></ul><p id="babc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还要注意，我添加了一个函数 get_url()，它将返回所选索引的 url。</p><ul class=""><li id="eb55" class="nh ni it kk b kl km ko kp kr nj kv nk kz nl ld pv nn no np bi translated">我们还创建了一个定制的异常类 MyException。我们将在 workflow_runner.py 中为它生成一个异常处理程序。</li></ul><h2 id="1f00" class="op ml it bd mm oq or dn mq os ot dp mu kr ou ov mw kv ow ox my kz oy oz na pa bi translated">workflow_runner.py</h2><p id="5f9f" class="pw-post-body-paragraph ki kj it kk b kl nc ju kn ko nd jx kq kr ne kt ku kv nf kx ky kz ng lb lc ld im bi translated">现在模型已经实现，让我们将代码添加到 workflow_runner.py 中。这是我们的数据科学应用程序的核心。</p><p id="6311" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该文件将包含执行以下两个步骤的代码:</p><ol class=""><li id="97b1" class="nh ni it kk b kl km ko kp kr nj kv nk kz nl ld nm nn no np bi translated">对于输入索引，通过删除适当的网页来获取其公司</li><li id="ef91" class="nh ni it kk b kl nq ko nr kr ns kv nt kz nu ld nm nn no np bi translated">以字符串列表的形式返回公司名称</li></ol><p id="8d67" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，workflow_controller 的<em class="ok"> run() </em>方法已经声明为 async，以说明我们如何创建非阻塞的 async IO 操作。</p><pre class="lf lg lh li gt pl oo pm pn aw po bi"><span id="d044" class="op ml it oo b gy pp pq l pr ps">from models import Company, Index<br/>import pandas as pd<br/><br/>def get_snp_500_companies(url):<br/>    companies = []<br/>    table = pd.read_html(url)[0]<br/>    for index, row in table.iterrows():<br/>        company = Company(row['Symbol'])<br/>        company.name = row['Security']<br/>        company.sector = row['GICS Sector']<br/>        company.industry = row['GICS Sub Industry']<br/>        company.date_added = row['Date first added']<br/>        companies.append(company)<br/>    return companies<br/><br/>def get_ftse_companies(url):<br/>    companies = []<br/>    table = pd.read_html(url)[3]<br/>    for index, row in table.iterrows():<br/>        company = Company(row['EPIC'])<br/>        company.name = row['Company']<br/>        company.sector = row['FTSE Industry Classification Benchmark sector[12]']<br/>        companies.append(company)<br/>    return companies<br/><br/><strong class="oo iu">async </strong>def run(config):<br/>    companies_map = {<br/>        Index.SNP500: get_snp_500_companies,<br/>        Index.FTSE100: get_ftse_companies<br/><br/>    }<br/>    url = config.get_url()<br/><br/>    func_to_get_data = companies_map.get(config.index, None)<br/>    if func_to_get_data is None:<br/>        raise KeyError(f'{input.index} is not suppported')<br/><br/>    companies = func_to_get_data(url)<br/>    return [c.name for c in companies]</span></pre><p id="2773" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我用的是 pandas.read_html(url)函数。它返回网页中的所有表格。因此，我从网页上选择合适的表格。因为每个 web 页面都有不同的结构，所以我已经用公司地图中的 url 注册了索引名。在运行时，工作流运行器将选择适当的 url，并通过执行特定于索引的函数来创建公司类的实例。</p><p id="100e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们选择道琼斯，它将引发一个异常。这将帮助我演示如何向用户显示用户友好的错误。</p><p id="32f5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们现在准备集成 FastAPI。</p><h2 id="bd3c" class="op ml it bd mm oq or dn mq os ot dp mu kr ou ov mw kv ow ox my kz oy oz na pa bi translated">main.py</h2><p id="3237" class="pw-post-body-paragraph ki kj it kk b kl nc ju kn ko nd jx kq kr ne kt ku kv nf kx ky kz ng lb lc ld im bi translated">最后，我们将把代码添加到 main.py 文件中</p><p id="0e8f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，添加导入:</p><pre class="lf lg lh li gt pl oo pm pn aw po bi"><span id="9cdb" class="op ml it oo b gy pp pq l pr ps">import uvicorn<br/>from fastapi import FastAPI, Path, Request<br/>from fastapi.responses import JSONResponse<br/><br/>import workflow_runner<br/>from models import MyException, Configuration, Index</span></pre><p id="643d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后创建一个 FastAPI()实例，并将其声明为 app 变量。</p><p id="e4a1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们给它一个标题、描述和版本。该信息将自动显示在文档中。</p><pre class="lf lg lh li gt pl oo pm pn aw po bi"><span id="e94f" class="op ml it oo b gy pp pq l pr ps">app = FastAPI(title='SMART Data Science Application',<br/>              description='A Smart Data Science Application running on FastAPI + uvicorn',<br/>              version='0.0.1')</span></pre><p id="1227" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">公开 GET 端点以处理调用 workflow_runner.run()的请求:</p><pre class="lf lg lh li gt pl oo pm pn aw po bi"><span id="a019" class="op ml it oo b gy pp pq l pr ps">@app.get("/{index}")<br/>async def get_result(index: Index = Path(..., title="The name of the Index")<br/>                     ):<br/>    config = Configuration(<br/>        index=index<br/>    )<br/>    try:<br/>    result = await workflow_runner.run(config)<br/>    return JSONResponse(status_code=200, content=result)<br/>except Exception as e:<br/>    raise MyException(e)</span></pre><p id="51e1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意我是如何等待 run 函数的。</p><p id="c898" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本质上，@app.get 是 REST 路径操作。它用路径“/”和 GET 操作处理请求。它调用异步 get_result()函数。参数索引现在是一个查询参数。</p><p id="73f4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以将查询参数标记为可选的，文档将自动反映出来以适应这种变化。我们已经为路径参数索引声明了一个<code class="fe ol om on oo b">title</code>元数据值。这将出现在自动文档中。</p><p id="3612" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以在 Path()中添加验证规则，例如对于整数参数，gt=0，le=1000。</p><p id="9f6c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ok">注意，函数 get_result()被声明为 async。它允许我们在不阻塞其他呼叫的情况下服务请求。</em></p><p id="f0e9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，这个特性使应用程序能够并发地处理请求。</p><p id="5fa9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后要注意的一点是，所有的异常都被捕获，然后引发 MyException。</p><p id="058e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ok">尽管最佳实践是显式捕获异常并单独处理它们，但出于演示目的，我用宽 try/except 异常捕获所有异常。</em></p><p id="eebe" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，对于错误处理，我们定义了一个可以处理 MyException 类型的异常的端点。</p><pre class="lf lg lh li gt pl oo pm pn aw po bi"><span id="b398" class="op ml it oo b gy pp pq l pr ps">@app.exception_handler(MyException)<br/>async def unicorn_exception_handler(request: Request, exc: MyException):<br/>    return JSONResponse(<br/>        status_code=418,<br/>        content={"message": f"Error occurred! Please contact the system admin."},<br/>    )</span></pre><p id="1926" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，每当我们得到 MyException 类型的异常时，它将显示消息“Error occurred！请联系系统管理员。”。这是因为 app.exception_handler 路径。FastAPI 还允许我们创建自己的异常处理程序。</p><p id="26e4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，添加运行 uvicorn 服务器的代码。</p><p id="e4bd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，我们使用端口 8000，主机 IP 地址是 localhost (0.0.0.0)。</p><pre class="lf lg lh li gt pl oo pm pn aw po bi"><span id="d40b" class="op ml it oo b gy pp pq l pr ps">if __name__ == "__main__":<br/>    uvicorn.run(app, host="0.0.0.0", port=8000)</span></pre><p id="c6af" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们已经完成了实现。</p><h2 id="8fc6" class="op ml it bd mm oq or dn mq os ot dp mu kr ou ov mw kv ow ox my kz oy oz na pa bi translated">5.运行服务器应用程序</h2><p id="788f" class="pw-post-body-paragraph ki kj it kk b kl nc ju kn ko nd jx kq kr ne kt ku kv nf kx ky kz ng lb lc ld im bi translated">让我们运行应用程序。导航到 main.py 所在的文件夹，并在终端中执行以下行:</p><pre class="lf lg lh li gt pl oo pm pn aw po bi"><span id="3143" class="op ml it oo b gy pp pq l pr ps">uvicorn main:app — reload</span></pre><ul class=""><li id="5317" class="nh ni it kk b kl km ko kp kr nj kv nk kz nl ld pv nn no np bi translated"><em class="ok"> main </em>是我们想要运行的 python 文件的名称。</li><li id="28b5" class="nh ni it kk b kl nq ko nr kr ns kv nt kz nu ld pv nn no np bi translated"><em class="ok"> app </em>是 main.py 中的 FastAPI 对象</li></ul><p id="8ad6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ok"> reload </em>将使我们能够在代码更改后重启服务器，从而在开发期间实现快速开发。</p><p id="4f78" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">运行该命令将显示:</p><pre class="lf lg lh li gt pl oo pm pn aw po bi"><span id="f026" class="op ml it oo b gy pp pq l pr ps">←[32mINFO←[0m:     Uvicorn running on ←[1mhttp://127.0.0.1:8000←[0m (Press CTRL+C to quit)<br/>←[32mINFO←[0m:     Started reloader process [←[36m←[1m1180←[0m] using ←[36m←[1mstatreload←[0m<br/>←[32mINFO←[0m:     Started server process [←[36m7004←[0m]<br/>←[32mINFO←[0m:     Waiting for application startup.<br/>←[32mINFO←[0m:     Application startup complete.</span></pre><ul class=""><li id="9ed5" class="nh ni it kk b kl km ko kp kr nj kv nk kz nl ld pv nn no np bi translated">Uvicorn 服务器已经暴露了本地主机端口 8000 上的应用程序。</li><li id="dbfd" class="nh ni it kk b kl nq ko nr kr ns kv nt kz nu ld pv nn no np bi translated">另外，它为应用程序创建了一个大摇大摆的 UI</li><li id="0944" class="nh ni it kk b kl nq ko nr kr ns kv nt kz nu ld pv nn no np bi translated">最后，它为应用程序生成了 OpenAPI 文档。</li></ul><h2 id="f414" class="op ml it bd mm oq or dn mq os ot dp mu kr ou ov mw kv ow ox my kz oy oz na pa bi translated">6.消费服务</h2><p id="1864" class="pw-post-body-paragraph ki kj it kk b kl nc ju kn ko nd jx kq kr ne kt ku kv nf kx ky kz ng lb lc ld im bi translated">首先，让我们回顾一下自动化 API 文档</p><p id="274e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">导航到</p><pre class="lf lg lh li gt pl oo pm pn aw po bi"><span id="e1f0" class="op ml it oo b gy pp pq l pr ps"><a class="ae od" href="http://127.0.0.1:8000/redoc" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8000/redoc</a></span></pre><p id="2adb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它将显示 Swagger UI。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi pw"><img src="../Images/b77ee6e263f8bc42651c892b6bd731da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2EfpfHvUVgx1-2YMXJKhig.png"/></div></div></figure><p id="a8c0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">单击索引会显示索引列表:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi px"><img src="../Images/7981f6666f2376708bd351f5b2d10b07.png" data-original-src="https://miro.medium.com/v2/resize:fit:784/format:webp/1*ajn7HyekzHSLPhPiprr1Rw.png"/></div></figure><p id="de07" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">运行它会在响应中显示公司名称:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi py"><img src="../Images/afe2351a86c134e64cac7b6d1409c158.png" data-original-src="https://miro.medium.com/v2/resize:fit:818/format:webp/1*3nbgikoiIBYssh04wymfHA.png"/></div></figure><p id="06c1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们选择道琼斯，看看我们是否得到一个用户友好的错误:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi le"><img src="../Images/4132742aa2f86981e8255122d9dc32a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*GE77rb5rBWdUpX4fN2MZWQ.png"/></div></figure><p id="58bc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是由 FastAPI 自动完成的。</p><h2 id="1d78" class="op ml it bd mm oq or dn mq os ot dp mu kr ou ov mw kv ow ox my kz oy oz na pa bi translated">从另一个应用程序调用智能数据科学应用程序</h2><p id="df9c" class="pw-post-body-paragraph ki kj it kk b kl nc ju kn ko nd jx kq kr ne kt ku kv nf kx ky kz ng lb lc ld im bi translated">我们可以从旋度来称呼它:</p><pre class="lf lg lh li gt pl oo pm pn aw po bi"><span id="1fe7" class="op ml it oo b gy pp pq l pr ps">curl -X GET "<a class="ae od" href="http://localhost:8000/FTSE%20100" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/FTSE%20100</a>" -H "accept: application/json"</span></pre><p id="948b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以打开浏览器并导航到 url 来查看响应:</p><pre class="lf lg lh li gt pl oo pm pn aw po bi"><span id="2fca" class="op ml it oo b gy pp pq l pr ps">http://localhost:8000/FTSE%20100</span></pre><p id="1007" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以通过导航到以下 url 来下载 openAPI 规范:</p><pre class="lf lg lh li gt pl oo pm pn aw po bi"><span id="7aa1" class="op ml it oo b gy pp pq l pr ps"><a class="ae od" href="http://localhost:8000/openapi.json" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/openapi.json</a></span></pre><p id="c3ec" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以看到已经内置了验证以及可接受的索引值，如下所示。OpenAPI 模式支持 Swagger UI。它包括 API 和数据模式，如下所示:</p><pre class="lf lg lh li gt pl oo pm pn aw po bi"><span id="a0bd" class="op ml it oo b gy pp pq l pr ps">{<br/>  "openapi": "3.0.2",<br/>  "info": {<br/>    "title": "SMART Data Science Application",<br/>    "description": "A Smart Data Science Application running on FastAPI + uvicorn",<br/>    "version": "0.0.1"<br/>  },<br/>  "paths": {<br/>    "/{index}": {<br/>      "get": {<br/>        "summary": "Get Result",<br/>        "operationId": "get_result__index__get",<br/>        "parameters": [<br/>          {<br/>            "required": true,<br/>            "schema": {<br/>              "title": "The name of the Index",<br/>              "enum": [<br/>                "FTSE 100",<br/>                "S&amp;P 500",<br/>                "Dow Jones"<br/>              ],<br/>              "type": "string"<br/>            },<br/>            "name": "index",<br/>            "in": "path"<br/>          }<br/>        ],<br/>        "responses": {<br/>          "200": {<br/>            "description": "Successful Response",<br/>            "content": {<br/>              "application/json": {<br/>                "schema": {}<br/>              }<br/>            }<br/>          },<br/>          "422": {<br/>            "description": "Validation Error",<br/>            "content": {<br/>              "application/json": {<br/>                "schema": {<br/>                  "$ref": "#/components/schemas/HTTPValidationError"<br/>                }<br/>              }<br/>            }<br/>          }<br/>        }<br/>      }<br/>    }<br/>  },<br/>  "components": {<br/>    "schemas": {<br/>      "HTTPValidationError": {<br/>        "title": "HTTPValidationError",<br/>        "type": "object",<br/>        "properties": {<br/>          "detail": {<br/>            "title": "Detail",<br/>            "type": "array",<br/>            "items": {<br/>              "$ref": "#/components/schemas/ValidationError"<br/>            }<br/>          }<br/>        }<br/>      },<br/>      "ValidationError": {<br/>        "title": "ValidationError",<br/>        "required": [<br/>          "loc",<br/>          "msg",<br/>          "type"<br/>        ],<br/>        "type": "object",<br/>        "properties": {<br/>          "loc": {<br/>            "title": "Location",<br/>            "type": "array",<br/>            "items": {<br/>              "type": "string"<br/>            }<br/>          },<br/>          "msg": {<br/>            "title": "Message",<br/>            "type": "string"<br/>          },<br/>          "type": {<br/>            "title": "Error Type",<br/>            "type": "string"<br/>          }<br/>        }<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="751c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是 FastAPI 自动构建的 API 的 OpenAPI 文档。我们可以将它发送给 API 的调用者，这样他们就可以轻松地将他们的服务与我们的解决方案集成在一起。</p><p id="d8ba" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，索引枚举成员与参数标题和验证规则一起出现在 OpenAPI 文档中。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi pz"><img src="../Images/e8d2432802cc78b97371d4bef6747a15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/1*0yjrMLMjs3mhL_E0cqjfEg.png"/></div><p class="lm ln gj gh gi lo lp bd b be z dk translated">感谢您的阅读</p></figure><p id="be58" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">仅此而已。如果你想了解更多关于 FastAPI 的信息，请访问他们的<a class="ae od" href="https://fastapi.tiangolo.com/tutorial/" rel="noopener ugc nofollow" target="_blank">网站</a>获取更多信息。</p><h1 id="78c4" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">摘要</h1><p id="bde3" class="pw-post-body-paragraph ki kj it kk b kl nc ju kn ko nd jx kq kr ne kt ku kv nf kx ky kz ng lb lc ld im bi translated">FastAPI 是一个高性能的 web 框架。FastAPI 于 2018 年发布，正在成为构建高性能数据科学应用的事实上的选择。</p><p id="6ac2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本文解释了什么是 FastAPI，它的主要特性是什么，并一步步地指导如何将数据科学应用打包成 Restful 微服务。</p></div></div>    
</body>
</html>