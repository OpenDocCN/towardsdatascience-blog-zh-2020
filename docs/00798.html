<html>
<head>
<title>Creating a spam filter using Naive Bayes with TextAnalysis.jl</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用朴素贝叶斯和 TextAnalysis.jl 创建垃圾邮件过滤器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/implementing-a-spam-filter-using-naive-bayes-and-textanalysis-jl-on-julia-e321180ea301?source=collection_archive---------23-----------------------#2020-01-22">https://towardsdatascience.com/implementing-a-spam-filter-using-naive-bayes-and-textanalysis-jl-on-julia-e321180ea301?source=collection_archive---------23-----------------------#2020-01-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/0c06e787dd13043efcbe34a7b9f6edf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ipk6Xeowueq40fBcdf72vA.jpeg"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">Christopher Gower 在<a class="ae kf" href="https://unsplash.com/s/photos/code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="c040" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你好！今天，我将告诉你更多关于我做了什么来制作一个垃圾邮件过滤器，使用朴素贝叶斯从 UCI 机器学习的 kaggle 上的数据集中检测垃圾邮件数据，以及在 Julia 上使用<a class="ae kf" href="https://github.com/JuliaText/TextAnalysis.jl" rel="noopener ugc nofollow" target="_blank"> TextAnalysis.jl </a>。</p><p id="d64a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我从查看 TextAnalysis.jl 的文档开始，以了解更多关于<a class="ae kf" href="https://juliatext.github.io/TextAnalysis.jl/latest/classify/" rel="noopener ugc nofollow" target="_blank"> NaiveBayes 分类器</a>的工作原理。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="a801" class="ln lo it lj b gy lp lq l lr ls">using TextAnalysis: NaiveBayesClassifier, fit!, predict<br/>m = NaiveBayesClassifier([:legal, :financial])<br/>fit!(m, "this is financial doc", :financial)<br/>fit!(m, "this is legal doc", :legal)<br/>predict(m, "this should be predicted as a legal document")</span></pre><p id="22ea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我运行了文档中的示例，并了解到函数 NaiveBayesClassifier 接受一组可能的类的参数，这些数据可能属于这些类。</p><p id="21fc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这种情况下，是<code class="fe lt lu lv lj b">:legal</code>和<code class="fe lt lu lv lj b">:financial</code>。我还了解到，我们通过用<code class="fe lt lu lv lj b">fit!</code>函数拟合相关数据来训练模型，该函数接受模型本身的参数、我们试图训练的数据串以及数据所属的类。这里的数据是一个字符串，例如<code class="fe lt lu lv lj b">“this is financial doc”</code>，在本例中，它所属的类是<code class="fe lt lu lv lj b">:financial</code>。</p><p id="2b28" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我了解到<code class="fe lt lu lv lj b">predict</code>函数允许我们输入一串数据，并使用 NaiveBayesClassifier 算法，根据使用<code class="fe lt lu lv lj b">fit!</code>函数之前训练的数据串来预测该字符串属于哪个类。<code class="fe lt lu lv lj b">predict</code>函数接受模型本身的参数以及我们试图预测的数据字符串。</p><p id="9b1c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我解决这个问题的第一个方法是，我认为首先导入所有的数据是一个好主意。因为我有使用<a class="ae kf" href="https://github.com/JuliaData/CSV.jl" rel="noopener ugc nofollow" target="_blank"> CSV.jl </a>和<a class="ae kf" href="https://github.com/JuliaData/DataFrames.jl" rel="noopener ugc nofollow" target="_blank"> DataFrames.jl </a>软件包的经验，所以我熟悉数据的导入。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="0219" class="ln lo it lj b gy lp lq l lr ls">using CSV, DataFrames<br/>spamdata = DataFrame(CSV.read("spam.csv"; allowmissing=:none))</span><span id="1f12" class="ln lo it lj b gy lw lq l lr ls">---------------------------------------------------------------</span><span id="aeea" class="ln lo it lj b gy lw lq l lr ls">julia&gt; showall(spamdata)<br/>5572×5 DataFrame<br/>│ Row  │ v1     │<br/>│      │ String │<br/>├──────┼────────┤<br/>│ 1    │ ham    │<br/>│ 2    │ ham    │<br/>│ 3    │ spam   │<br/>│ 4    │ ham    │<br/>│ 5    │ ham    │<br/>│ 6    │ spam   │<br/>│ 7    │ ham    │<br/>│ 8    │ ham    │<br/>│ 9    │ spam   │<br/>│ 10   │ spam   │</span></pre><p id="4a8f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下图显示了包含数据的原始<code class="fe lt lu lv lj b">.csv</code>文件的结构。</p><figure class="le lf lg lh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lx"><img src="../Images/e04ba7afe049c5de997759a620839706.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hV836oBmOuDRQkdASUS0wQ.png"/></div></div></figure><p id="7b9d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">csv 文件有两列。<code class="fe lt lu lv lj b">v2</code>是我们想要用来训练的数据串，<code class="fe lt lu lv lj b">v1</code>是特定数据串的类，对应于<code class="fe lt lu lv lj b">v2</code>。</p><p id="b46b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我想要一种方法来循环遍历文件的每一行，并在一个条件下拆分 ham 数据，在另一个条件下拆分 spam 数据，这样，当进行训练时，我将能够使用<code class="fe lt lu lv lj b">fit!</code>函数来训练<code class="fe lt lu lv lj b">ham</code>数据，这需要我指定该数据的类别。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="338a" class="ln lo it lj b gy lp lq l lr ls">for row in eachrow(spamdata)<br/>    if row.v1 == "ham"<br/>        println("ham")<br/>    elseif row.v1 == "spam"<br/>        println("spam")<br/>    end<br/>end</span></pre><p id="5cfc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是一个成功，我最终有火腿和垃圾邮件被打印！</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="fb39" class="ln lo it lj b gy lp lq l lr ls">ham<br/>spam<br/>ham<br/>spam<br/>ham<br/>ham<br/>spam<br/>spam<br/>ham<br/>spam<br/>⋮</span></pre><p id="6375" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">既然已经解决了，我可以使用 NaiveBayesClassifier 函数来定义我的模型了。我想定义两个类，<code class="fe lt lu lv lj b">:ham</code>和<code class="fe lt lu lv lj b">:spam</code>。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="8011" class="ln lo it lj b gy lp lq l lr ls">using TextAnalysis: NaiveBayesClassifier, fit!, predict<br/>m = NaiveBayesClassifier([:ham, :spam])</span></pre><p id="3b8d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我想开始训练我的模型。正如我们从最初的<code class="fe lt lu lv lj b">.csv</code>文件的结构中看到的，<code class="fe lt lu lv lj b">v2</code>是我们试图训练的字符串。将<code class="fe lt lu lv lj b">for</code>循环与<code class="fe lt lu lv lj b">fit!</code>函数结合起来，我做了以下工作来尝试训练我们所有可用的数据。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="3978" class="ln lo it lj b gy lp lq l lr ls">using CSV, DataFrames<br/>using TextAnalysis: NaiveBayesClassifier, fit!, predict</span><span id="fcff" class="ln lo it lj b gy lw lq l lr ls">spamdata = DataFrame(CSV.read("spam.csv"; allowmissing=:none))<br/>global m = NaiveBayesClassifier([:ham, :spam])<br/>for row in eachrow(spamdata)<br/>    if row.v1 == "ham"<br/>        fit!(m, row.v2, :ham)<br/>    elseif row.v1 == "spam"<br/>        fit!(m, row.v2, :spam)<br/>    end<br/>end</span></pre><p id="c932" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是当我运行它时，我得到了下面的错误:<code class="fe lt lu lv lj b">LoadError: Base.InvalidCharError{Char}('\xe5\xa3')</code></p><p id="ca44" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">就在那时，我意识到数据集在<code class="fe lt lu lv lj b">v2</code>列的某些字符串中有无效字符。为了消除这个错误，我们需要使用下面的函数过滤掉不支持的字符:<code class="fe lt lu lv lj b">filter(isvalid, &lt;string&gt;)</code></p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="593d" class="ln lo it lj b gy lp lq l lr ls">for row in eachrow(spamdata)<br/>    if row.v1 == "ham"<br/>        fit!(m, filter(isvalid, row.v2), :ham)<br/>    elseif row.v1 == "spam"<br/>        fit!(m, filter(isvalid, row.v2), :spam)<br/>    end<br/>end</span></pre><p id="8c6f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我将字符串<code class="fe lt lu lv lj b">row.v2</code>替换为<code class="fe lt lu lv lj b">filter(isvalid, row.v2)</code>并再次运行程序时，没有出现错误。因此，该模型被成功训练，到目前为止一切顺利！</p><p id="0903" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在 REPL 中，实际上什么都没有打印出来，因为没有错误，程序中没有任何东西被打印出来。为了全面测试模型是否有效，我们可以尝试创建一个预测，并打印出预测的结果，以查看训练是否真正完成。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="286e" class="ln lo it lj b gy lp lq l lr ls">prediction1 = predict(m, "hello my name is kfung")<br/>prediction2 = predict(m, "text 31845 to get a free phone")<br/>println(prediction1)<br/>println(prediction2)</span></pre><p id="53fa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这里，我创建了两个预测，其中第一个看起来像一个火腿消息(因为它看起来不可疑)，第二个看起来像一个垃圾邮件，以测试模型。</p><p id="100e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我得到的结果如下:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="9b2f" class="ln lo it lj b gy lp lq l lr ls">Dict(:spam =&gt; 0.013170434049325023, :ham =&gt; 0.986829565950675)<br/>Dict(:spam =&gt; 0.9892304346396908, :ham =&gt; 0.010769565360309069)</span></pre><p id="dfc2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所知，预测非常准确，因为第一个预测的<code class="fe lt lu lv lj b">:ham</code>值接近 1，这意味着它最有可能是一封垃圾邮件，第二个预测的:<code class="fe lt lu lv lj b">spam value</code>值接近 1，这意味着它最有可能是一封垃圾邮件。正如我们所料。</p><p id="f1b9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是对于不熟悉字典或 Julia 语法的用户来说，他们可能会对上面的字典的含义感到困惑。我修改了代码，以便它检查字典中的<code class="fe lt lu lv lj b">:spam</code>和<code class="fe lt lu lv lj b">:ham</code>值，并打印出这两个值中较大值的类。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="5305" class="ln lo it lj b gy lp lq l lr ls">prediction = predict(m, "hello my name is kfung")<br/>if prediction[:spam] &gt; prediction[:ham]<br/>    println("spam")<br/>else<br/>    println("ham")<br/>end</span></pre><p id="b131" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所料，这个程序的结果是字符串<code class="fe lt lu lv lj b">“ham”</code>，因为它预测的<code class="fe lt lu lv lj b">:ham</code>值大于<code class="fe lt lu lv lj b">:spam</code>值，因此它更有可能是一个火腿消息。</p><p id="f03e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我将所有内容都包装在一个函数中，该函数以一个字符串作为参数，这样当您用一个字符串调用该函数时，如果模型预测它是垃圾邮件，它将输出<code class="fe lt lu lv lj b">“spam”</code>,如果模型预测它不是垃圾邮件，则输出<code class="fe lt lu lv lj b">“ham”</code>。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="e9cf" class="ln lo it lj b gy lp lq l lr ls">using CSV, DataFrames<br/>using TextAnalysis: NaiveBayesClassifier, fit!, predict</span><span id="a7ae" class="ln lo it lj b gy lw lq l lr ls">function checkspam(msg::String)<br/>    spamdata = DataFrame(CSV.read("spam.csv"; allowmissing=:none))<br/>    m = NaiveBayesClassifier([:ham, :spam])<br/>    for row in eachrow(spamdata)<br/>        if row.v1 == "ham"<br/>            fit!(m, filter(isvalid, row.v2), :ham)<br/>        elseif row.v1 == "spam"<br/>            fit!(m, filter(isvalid, row.v2), :spam)<br/>        end<br/>    end<br/>    prediction = predict(m, msg)<br/>    if prediction[:spam] &gt; prediction[:ham]<br/>        println("spam")<br/>    else<br/>        println("ham (not spam)")<br/>    end<br/>end</span></pre><p id="cef8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我意识到每次对信息进行分类时，我是如何训练模型的。这使得程序在运行时效率不高，因为每次我们试图使用模型进行预测时，它都要从头到尾检查 5600 行数据。相反，我们可以将模型置于函数之外(这样它只在开始时运行一次)，并将模型存储在一个全局变量中，这样以后它就可以使用存储在全局变量中的预训练模型来分类任何其他消息。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="b84a" class="ln lo it lj b gy lp lq l lr ls">using CSV, DataFrames<br/>using TextAnalysis: NaiveBayesClassifier, fit!, predict</span><span id="d790" class="ln lo it lj b gy lw lq l lr ls">spamdata = DataFrame(CSV.read("spam.csv"; allowmissing=:none))<br/>global m = NaiveBayesClassifier([:ham, :spam])<br/>for row in eachrow(spamdata)<br/>    if row.v1 == "ham"<br/>        fit!(m, filter(isvalid, row.v2), :ham)<br/>    elseif row.v1 == "spam"<br/>        fit!(m, filter(isvalid, row.v2), :spam)<br/>    end<br/>end</span><span id="755c" class="ln lo it lj b gy lw lq l lr ls">function checkspam(msg::String)<br/>    prediction = predict(m, msg)<br/>    if prediction[:spam] &gt; prediction[:ham]<br/>        println("spam")<br/>    else<br/>        println("ham (not spam)")<br/>    end<br/>end</span></pre><p id="ea33" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">总的来说，我认为这是创建新的垃圾邮件过滤器的一次非常成功的尝试。我学到了更多关于如何应用朴素贝叶斯为概率分类的独立假设建模的知识。朴素贝叶斯目前仍然是文本分类的一个相当受欢迎的选项，这就是一个例子，并且可以与其他模型训练方法形成对比，例如逻辑回归，其中数据是有条件训练的。这个模型还有其他应用，比如情绪分析，这是我将在另一篇文章中重点介绍的，所以请继续关注！</p><p id="9f25" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">非常感谢您的阅读！</p></div></div>    
</body>
</html>