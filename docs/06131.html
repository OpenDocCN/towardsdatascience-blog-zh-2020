<html>
<head>
<title>Automating Sunday Meal Preps Using SQLite Relational Databases and Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用SQLite关系数据库和Python实现周日膳食准备自动化</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/automating-sunday-meal-preps-using-sqlite-relational-databases-and-python-c85821099ca8?source=collection_archive---------35-----------------------#2020-05-18">https://towardsdatascience.com/automating-sunday-meal-preps-using-sqlite-relational-databases-and-python-c85821099ca8?source=collection_archive---------35-----------------------#2020-05-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="30cb" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">创建和使用储物件，满足您所有的烹饪需求</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/84e658a8bd47dc57c0e97d55491b23bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uPsHLwqQNNwrRPSn"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@lvnatikk?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">百合网</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="60d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">成为一个真正的成年人(现在，被隔离)意味着加入r/meal prep Sunday，重新创造所有的膳食准备食谱。然而，随着我的食谱越来越多，我对存储的需求也越来越大。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ls"><img src="../Images/2af2eee7dd29110a52c630e026071489.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0TgNK6B1tKjNL6gUXzqjOA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">我现有的谷歌电子表格的快照，准备在未来几年成倍增长</p></figure><p id="ad7c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我最初在一个电子表格中跟踪我所有尝试过的食谱，首先按照餐点，然后按照主料精心组织。我还包括了我想要跟踪的其他属性，包括烹饪、难度和食谱中的任何饮食限制。但是行数的增长也意味着组织和搜索时间的增长。我需要一个新的，更强大的存储单元。那时，我开始研究电子表格的轻量级(尽管在UI方面没有那么吸引人)表亲SQLite关系数据库的用途。</p><p id="6b55" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我想要这个新的食谱数据库来补救我的电子表格的困境。因此，我将它设计成:</p><ol class=""><li id="f4cb" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated">最大化增长空间(我可能会在我的烹饪生涯中一直使用它</li><li id="d3ae" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">允许使用我现有的属性轻松存储和排序</li><li id="090e" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">通过汇总我为这一周选择的食谱中的所有材料来简化购物</li></ol><p id="a083" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最终，我的食谱数据库完成了所有这些目标。结果证明这是最用户友好/可行的选择吗？可能不会，而且我了解到SQLite可能不是这样一个项目的最佳选择。然而，我确实创建了食谱数据库的一些基本构件，并对现有的电子表格应用程序有了新的认识。如果您有兴趣了解SQLite和python的pandas如何用于食谱的上下文，那么让我们来看看实用性。</p><p id="8efb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mh">完整代码可以在我的Github </em> <a class="ae kv" href="https://github.com/jenniferrkim/recipe_database" rel="noopener ugc nofollow" target="_blank"> <em class="mh">这里</em> </a> <em class="mh">找到。为了方便查看，我用了一个Jupyter笔记本，但是你可以随意把它分成有标签的文件。</em></p><h2 id="b55a" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lf mr ms mt lj mu mv mw ln mx my mz na bi translated"><strong class="ak">目录:</strong></h2><ol class=""><li id="2df6" class="lt lu iq ky b kz nb lc nc lf nd lj ne ln nf lr ly lz ma mb bi translated">设置关系数据库模式</li><li id="d252" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">Python for SQLite入门</li><li id="88a4" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">Python中的SQLite关系基础:配方版</li><li id="f725" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">用关键字参数和熊猫检索食谱</li><li id="8f61" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">随时可用— Python的input()作为UI</li><li id="4017" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">结论</li></ol></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><h1 id="49c3" class="nn mj iq bd mk no np nq mn nr ns nt mq jw nu jx mt jz nv ka mw kc nw kd mz nx bi translated">设置关系数据库模式</h1><p id="9090" class="pw-post-body-paragraph kw kx iq ky b kz nb jr lb lc nc ju le lf ny lh li lj nz ll lm ln oa lp lq lr ij bi translated">我希望我的数据库满足的第一个标准是最大化增长空间，这直接受其结构的影响。随着数据库的扩展，最大限度地减少可能影响存储效率的冗余尤为重要。这个概念叫做规范化。</p><p id="cdbf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然不同的规范化形式包含它们自己特定的<a class="ae kv" href="https://www.geeksforgeeks.org/normal-forms-in-dbms/" rel="noopener ugc nofollow" target="_blank">规则</a>，但是作为一个整体，规范化通常需要将一个大表分解成多个小表，并维护这些部分之间的联系。这些小表的结构由底层数据的关系决定，有三种类型:一对一、一对多和多对多。</p><h2 id="6499" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lf mr ms mt lj mu mv mw ln mx my mz na bi translated">一个配方对应一套说明</h2><p id="5783" class="pw-post-body-paragraph kw kx iq ky b kz nb jr lb lc nc ju le lf ny lh li lj nz ll lm ln oa lp lq lr ij bi translated">最简单的数据库关系是一对一的。这是指表A中的一条记录与表b中的一条且仅有一条记录相关联。在配方数据库中，配方及其说明具有一对一的关系，因为两个配方几乎不可能具有完全相同的说明。因此，配方名称表和配方指令表将具有一行配方名称，对应于仅仅一行配方指令。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/68bfad2d4d95b1224868d5c59f9c627c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p_nMUd53b3DSIONXG7dYZQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">一对一的配方数据库模式</p></figure><h2 id="4f41" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lf mr ms mt lj mu mv mw ln mx my mz na bi translated">一个配方多种属性</h2><p id="7e0e" class="pw-post-body-paragraph kw kx iq ky b kz nb jr lb lc nc ju le lf ny lh li lj nz ll lm ln oa lp lq lr ij bi translated">对于大多数其他食谱属性(例如，难度、烹饪、课程和饮食类型)，存在一对多的关系。表A中有一条记录链接到(你猜对了！)表b中的多个记录。例如，一个难度级别(例如“容易”)可以有许多与其相关联的食谱，因为可以有许多“容易”食谱。然而，反过来就不正确了——一个食谱不可能既“简单”又“困难”(除非我的烹饪能力一天比一天有很大的变化)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/61b12ff680e9e0458e35cfaa8d15b9a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MIGvR52WvzgrTDsfdf4shw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">一对多配方数据库模式</p></figure><h2 id="81e6" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lf mr ms mt lj mu mv mw ln mx my mz na bi translated">多种配料的多种食谱</h2><p id="084b" class="pw-post-body-paragraph kw kx iq ky b kz nb jr lb lc nc ju le lf ny lh li lj nz ll lm ln oa lp lq lr ij bi translated">表之间的最后一种关系是多对多关系。在配方数据库中，一个配方可以有许多配料，一种配料可以用于许多配方。</p><p id="37c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">多对多关系的实现需要第三个连接表来符合规范化规则。在我的Recipes表和Ingredient表之间，我创建了一个名为Recipe_Ingredient的连接表。第三个表将多对多关系分解为两个一对多关系。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/30701abe7d2d1bb8166f8c2a2435f525.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dcNjGLJBiVhcVHHtaAJKmw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">多对多配方数据库模式</p></figure><p id="7eed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在图的右侧，您可能已经注意到不只是一个成分表，而是四个独立的表，包括单位表、数量表和制备方法表。这种结构利用了配料的单位、数量和制备方法与食谱之间的多对多关系。虽然我可以利用配料及其各自的单位、数量和制备方法之间的一对多关系，但我更喜欢将所有与配料相关的信息集中在Recipe_Ingredients表中的一个地方。</p><h2 id="818e" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lf mr ms mt lj mu mv mw ln mx my mz na bi translated">主键和外键</h2><p id="dde3" class="pw-post-body-paragraph kw kx iq ky b kz nb jr lb lc nc ju le lf ny lh li lj nz ll lm ln oa lp lq lr ij bi translated">既然表已经拆分，那么如何将它们链接起来的问题就出现了。所有以前的模式图都有箭头，从一个特定的表指向另一个表中与其等价的“id”列。箭头底部表示主键，或特定表中行的唯一标识符。箭头的尖端指向一个外键，或者指向一个主键的引用。</p><p id="96e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些关键不仅有助于建立关系，还能减少冗余。在做改变的时候，如果有一天我想把“容易”变成“毫不费力”，我只需要在难度表上做一个改变。如果主外键关系不存在，我需要用“easy”遍历所有行，并单独进行更改。建立此链接还可以通过防止删除具有依赖外键的主键来保存孤立记录。有关SQLite外键的更多信息，请查看这里的文档<a class="ae kv" href="https://www.sqlite.org/foreignkeys.html" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="9f33" class="nn mj iq bd mk no oe nq mn nr of nt mq jw og jx mt jz oh ka mw kc oi kd mz nx bi translated">Python for SQLite入门</h1><p id="150a" class="pw-post-body-paragraph kw kx iq ky b kz nb jr lb lc nc ju le lf ny lh li lj nz ll lm ln oa lp lq lr ij bi translated">现在设置已经完成，是时候用Python实现了。</p><h2 id="7b19" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lf mr ms mt lj mu mv mw ln mx my mz na bi translated"><strong class="ak">选择数据库管理系统</strong></h2><p id="a074" class="pw-post-body-paragraph kw kx iq ky b kz nb jr lb lc nc ju le lf ny lh li lj nz ll lm ln oa lp lq lr ij bi translated">数据库管理系统，简称DBMS，是帮助处理数据库的系统的总称。其中的一个子集可以处理关系，将它们分类到RDBMS下，用额外的R表示关系。因为我需要关系管理，所以我选择了SQLite，一个RDBMS，因为它的<a class="ae kv" href="https://www.sqlite.org/different.html" rel="noopener ugc nofollow" target="_blank">易于设置并且不需要服务器</a>。</p><h2 id="9a98" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lf mr ms mt lj mu mv mw ln mx my mz na bi translated"><strong class="ak">设置和关闭</strong></h2><pre class="kg kh ki kj gt oj ok ol om aw on bi"><span id="0ed9" class="mi mj iq ok b gy oo op l oq or"># getting start with sqlite<br/>import sqlite3</span><span id="9033" class="mi mj iq ok b gy os op l oq or"># create database file by specifying location<br/>cnn = sqlite3.connect(r"C:\file\path\here\mealpreprecipes.db")</span><span id="a334" class="mi mj iq ok b gy os op l oq or"># initialize cursor object to interact with database<br/>cur = cnn.cursor()</span></pre><p id="eab7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们希望Python与数据库交互并处理SQL查询时，Cursor对象将会派上用场。更多信息可以在Python文档<a class="ae kv" href="https://docs.python.org/2.5/lib/sqlite3-Cursor-Objects.html" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="4dc4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦进行了任何更改，您需要使用Commit语句进行保存。</p><pre class="kg kh ki kj gt oj ok ol om aw on bi"><span id="42aa" class="mi mj iq ok b gy oo op l oq or">cnn.commit()</span></pre><p id="a57c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完成连接后，使用以下命令关闭它:</p><pre class="kg kh ki kj gt oj ok ol om aw on bi"><span id="021e" class="mi mj iq ok b gy oo op l oq or">cnn.close()</span></pre><p id="f173" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者，您可以使用<code class="fe ot ou ov ok b">with</code>语句来确保在运行必要的代码后连接被关闭。</p><pre class="kg kh ki kj gt oj ok ol om aw on bi"><span id="b5f7" class="mi mj iq ok b gy oo op l oq or">with cnn:<br/>    * insert code *</span></pre><p id="cea2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更多直接来自源代码的设置信息，请访问Python文档<a class="ae kv" href="https://docs.python.org/2/library/sqlite3.html" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><h1 id="ff99" class="nn mj iq bd mk no oe nq mn nr of nt mq jw og jx mt jz oh ka mw kc oi kd mz nx bi translated">Python中的SQLite关系基础:配方版</h1><p id="7bec" class="pw-post-body-paragraph kw kx iq ky b kz nb jr lb lc nc ju le lf ny lh li lj nz ll lm ln oa lp lq lr ij bi translated">虽然我不会介绍简单的SQL语法，但我会解释在实现本文开头创建的数据库结构时我发现有用的技巧和诀窍。</p><h2 id="659e" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lf mr ms mt lj mu mv mw ln mx my mz na bi translated"><strong class="ak">创建具有主键和外键的表</strong></h2><p id="745a" class="pw-post-body-paragraph kw kx iq ky b kz nb jr lb lc nc ju le lf ny lh li lj nz ll lm ln oa lp lq lr ij bi translated">前面建立的主键和外键现在可以在我们创建表时实现。以下是一个配方表示例:</p><pre class="kg kh ki kj gt oj ok ol om aw on bi"><span id="12e2" class="mi mj iq ok b gy oo op l oq or">cur.execute("""CREATE TABLE recipe <br/>                (recipe_id INTEGER PRIMARY KEY NOT NULL, <br/>                recipe_name TEXT, <br/>                recipe_notes TEXT,<br/>                difficulty_id INTEGER,<br/>                cuisine_id INTEGER,<br/>                course_id INTEGER,<br/>                diet_id INTEGER,<br/>                instructions_id INTEGER,<br/>                FOREIGN KEY (difficulty_id) REFERENCES difficulty(difficulty_id),<br/>                FOREIGN KEY (cuisine_id) REFERENCES difficulty(cuisine_id),<br/>                FOREIGN KEY (course_id) REFERENCES difficulty(course_id),<br/>                FOREIGN KEY (diet_id) REFERENCES difficulty(diet_id),<br/>                FOREIGN KEY (instructions_id) REFERENCES difficulty(instructions_id))""")</span></pre><p id="85d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">应用这些<code class="fe ot ou ov ok b">FOREIGN KEY</code>约束可以确保<code class="fe ot ou ov ok b">recipe</code>表的任何一行中的所有外键都将链接到另一个表的主键。例如，如果插入到<code class="fe ot ou ov ok b">recipe</code>表的<code class="fe ot ou ov ok b">difficulty_id</code>中的一行在<code class="fe ot ou ov ok b">difficulty</code>表中没有对应的主键，插入将会失败。</p><h2 id="89ed" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lf mr ms mt lj mu mv mw ln mx my mz na bi translated"><strong class="ak">插入主键和外键的值</strong></h2><p id="06be" class="pw-post-body-paragraph kw kx iq ky b kz nb jr lb lc nc ju le lf ny lh li lj nz ll lm ln oa lp lq lr ij bi translated">在设置了具有主键和外键的表之后，我们现在想要插入一些值。</p><p id="a446" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢我们使用的<code class="fe ot ou ov ok b">INTEGER PRIMARY KEY NOT NULL</code>关键字，我们不必为表的主键插入显式值。只需为该行插入一个值，表就会自动生成一个唯一的整数对其进行编号。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/8b3ff5debf394059d0398545a253228c.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/format:webp/1*DLcUhpzLC6CKkwXTFxt9wg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">diet_id列表示稍后要引用的主键</p></figure><p id="be7f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了插入外键，我喜欢使用下面的语法:</p><pre class="kg kh ki kj gt oj ok ol om aw on bi"><span id="395a" class="mi mj iq ok b gy oo op l oq or">sql = """INSERT INTO recipe(recipe_name, recipe_notes,      difficulty_id, cuisine_id, course_id, diet_id, instructions_id)    VALUES (?, ?, <br/>    (SELECT difficulty_id FROM difficulty WHERE difficulty = ?), <br/>    (SELECT cuisine_id FROM cuisine WHERE cuisine = ?),<br/>    (SELECT course_id FROM course WHERE course = ?),<br/>    (SELECT diet_id FROM diet WHERE diet = ?),<br/>    (SELECT instruction_id FROM instructions WHERE instructions = ?))"""</span></pre><p id="ce8e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以这种方式使用<code class="fe ot ou ov ok b">SELECT</code>语句可以确保我找到正确的对应主键，即使我不知道唯一的整数。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ox"><img src="../Images/2a66f44e7e059e414dccca2c85fd77e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0PleOMnsvIyxCxcTjt0PrQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">具有外键列的配方表条目</p></figure><h2 id="bc4c" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lf mr ms mt lj mu mv mw ln mx my mz na bi translated"><strong class="ak">数据插入</strong></h2><p id="94b7" class="pw-post-body-paragraph kw kx iq ky b kz nb jr lb lc nc ju le lf ny lh li lj nz ll lm ln oa lp lq lr ij bi translated">我希望既不是主键也不是外键的行条目是用户给定的值。幸运的是，SQL为我们提供了准备好的语句来插入我们事先不知道的值。有了准备好的语句，我们可以将参数指定为查询，使用问号作为语法。这些用来代替传统的Python字符串格式来保护我们免受SQL注入的影响。在下面的函数中，我使用了一条准备好的语句来插入食谱的指令。</p><pre class="kg kh ki kj gt oj ok ol om aw on bi"><span id="1a89" class="mi mj iq ok b gy oo op l oq or">def insert_instructions(self):<br/>        sql = "INSERT INTO instructions (instructions) VALUES (?)"<br/>        # insert values as tuples<br/>        # single item tuples need trailing comma to show tuple-ness<br/>        values = (self.instructions,)<br/>        <br/>        cur.execute(sql, values)<br/>        cnn.commit()</span></pre><p id="93f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">检查是否存在</strong></p><p id="fa55" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于某些属性，比如cuisine，我知道插入的值很可能是数据库中已经存在的值。为了与效率的主题保持一致，我想通过检查存在来防止重复。在select表中，我在一个准备好的语句中使用了一个<code class="fe ot ou ov ok b">SELECT</code>语句。</p><pre class="kg kh ki kj gt oj ok ol om aw on bi"><span id="bb09" class="mi mj iq ok b gy oo op l oq or">sql = "INSERT INTO cuisine (cuisine) SELECT (?) WHERE NOT EXISTS (SELECT 1 FROM cuisine WHERE cuisine = ?)"</span><span id="6c6e" class="mi mj iq ok b gy os op l oq or">values = (self.cuisine, self.cuisine)</span><span id="80af" class="mi mj iq ok b gy os op l oq or">cur.execute(sql, values)<br/>cnn.commit()</span></pre><p id="46da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">插入已知的表格值</strong></p><p id="4852" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然我的大多数表都根据用户输入插入了行，但是我希望我的两个表<code class="fe ot ou ov ok b">course</code>和<code class="fe ot ou ov ok b">diet</code>只包含我预先选择的值。</p><pre class="kg kh ki kj gt oj ok ol om aw on bi"><span id="8518" class="mi mj iq ok b gy oo op l oq or"># example in diet table<br/>cur.execute("""CREATE TABLE diet<br/>                (diet_id INTEGER PRIMARY KEY NOT NULL,<br/>                diet TEXT)""")</span><span id="284c" class="mi mj iq ok b gy os op l oq or">cur.execute("""INSERT INTO diet (diet) VALUES ("None", vegan", "vegetarian", "gluten-free")""")</span></pre><p id="9c0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然SQLite不支持None类型，如<code class="fe ot ou ov ok b">NULL</code>，但我添加了字符串“None”作为选项。我发现当我使用select方法插入外键时，SQLite不认为<code class="fe ot ou ov ok b">NULL</code>是可搜索的值。因此，我选择将“None”作为一个值，这样食谱就可以被表示为没有饮食限制。</p><p id="2fbd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mh">关于execute()与executemany()的补充说明</em></p><p id="2fe9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如上面两个例子中所使用的，Cursor对象有一个<code class="fe ot ou ov ok b">Cursor.execute()</code>方法，用于将SQL查询作为字符串传递。上面没有显示的是<code class="fe ot ou ov ok b">Cursor.executemany()</code>，方便一次插入多行。确保将您想要插入的行作为<em class="mh">列表传入。</em></p><h2 id="595b" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lf mr ms mt lj mu mv mw ln mx my mz na bi translated"><strong class="ak">我如何处理配料</strong></h2><p id="3580" class="pw-post-body-paragraph kw kx iq ky b kz nb jr lb lc nc ju le lf ny lh li lj nz ll lm ln oa lp lq lr ij bi translated">规划这个食谱数据库时最大的挑战是配料处理，因为一种配料有四个属性:名称、数量、单位和制备方法。我最终选择将这些属性按照每种成分组成一个字典。对于Python来说，这似乎是一个自然的电子表格，每一列都被转换成一个键。</p><pre class="kg kh ki kj gt oj ok ol om aw on bi"><span id="6820" class="mi mj iq ok b gy oo op l oq or">pesto_tilapia = {'ingredient': ['butter', 'pesto', 'coconut milk'],<br/>              'unit': ['tbsp', 'cup', 'can'],<br/>              'quantity': [3, 1, 1],<br/>              'prepmethod': ['room temp', 'None', 'None']}</span></pre><p id="9a07" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然手动输入这样的词典很麻烦，但一个好的用户界面有望使这变得易于管理。</p><h1 id="10c5" class="nn mj iq bd mk no oe nq mn nr of nt mq jw og jx mt jz oh ka mw kc oi kd mz nx bi translated">用关键字参数和熊猫检索食谱</h1><p id="e562" class="pw-post-body-paragraph kw kx iq ky b kz nb jr lb lc nc ju le lf ny lh li lj nz ll lm ln oa lp lq lr ij bi translated">检索和查看食谱对使用至关重要。为了实现这个数据库的第二个和第三个目标，我在view.py中构建了两个函数:一个用于查看选择的食谱，另一个用于收集配料的汇总列表。</p><h2 id="fda5" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lf mr ms mt lj mu mv mw ln mx my mz na bi translated">查看选定的配方</h2><p id="70c9" class="pw-post-body-paragraph kw kx iq ky b kz nb jr lb lc nc ju le lf ny lh li lj nz ll lm ln oa lp lq lr ij bi translated">第一个函数我命名为【非常原本】<code class="fe ot ou ov ok b">print_recipes()</code>。我想根据我选择的标准过滤和选择食谱，并使用关键字参数实现这个“搜索”功能，然后格式化成一个SQL <code class="fe ot ou ov ok b">SELECT</code>查询。关键字arg将category作为键，将category selection作为值。因为参数不是位置性的，所以我可以根据需要传入任意多的标准。</p><p id="274e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不幸的是，Python中的SQL查询是麻烦的字符串，所以函数的其余部分专门用于格式化参数。在有多个参数的情况下，我决定用一个<code class="fe ot ou ov ok b">OR</code>而不是一个<code class="fe ot ou ov ok b">AND</code>来连接搜索标准。这是因为我知道我的大部分搜索会是前一周我想用完的成分。为了找到包含所有我想用的配料的食谱，我需要配料的联合，而不是交集。如果你要寻找的东西需要你的标准的交集，请随意将它改为<code class="fe ot ou ov ok b">AND</code>。如果你感觉更有野心，尝试在<code class="fe ot ou ov ok b">OR</code>和<code class="fe ot ou ov ok b">AND</code>搜索之间集成一个切换。</p><p id="456d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在所有的字符串格式化之后，您将会得到一个函数，它会显示出您用关键字参数选择的食谱的数据帧。现在是时候列出购物清单了。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oy"><img src="../Images/87689fd900d71caa269bfde25180bee1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x3-BziPTwCIpq1yGB1khxA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">带有kwarg {'ingredients': 'fish'}的示例数据帧</p></figure><h2 id="db9a" class="mi mj iq bd mk ml mm dn mn mo mp dp mq lf mr ms mt lj mu mv mw ln mx my mz na bi translated">收集成分的汇总列表</h2><p id="b1e3" class="pw-post-body-paragraph kw kx iq ky b kz nb jr lb lc nc ju le lf ny lh li lj nz ll lm ln oa lp lq lr ij bi translated">第二个函数在一个名为<code class="fe ot ou ov ok b">convert()</code>的函数中返回我的购物清单。它获取在前面的函数<code class="fe ot ou ov ok b">print_recipes()</code>中创建的食谱数据帧，并返回其配料的字典，其中包括所有重复的配料。</p><p id="3a6e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然具有相同单位的成分组合起来很简单，但是需要单位转换的成分就比较棘手了。使用pandas的<code class="fe ot ou ov ok b">groupby()</code>和<code class="fe ot ou ov ok b">nunique()</code>，该函数首先在数据帧中搜索独特的配料。基于该成分的单位是否可转换(字典<code class="fe ot ou ov ok b">conversion_chart</code>中硬编码的选项)，该函数将该成分的多个实例聚合(在大量数据帧过滤之后)成用户在<code class="fe ot ou ov ok b">convert()</code>参数中指定的一个单位。</p><p id="f924" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所有的食材都加入字典后，你就有了你的购物清单！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oz"><img src="../Images/1be5ebac3706621bc1ca588cbf6131b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1u1PxrcbqQXAmxTdZG-8FQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">用户提示后的购物清单词典</p></figure><h1 id="b10d" class="nn mj iq bd mk no oe nq mn nr of nt mq jw og jx mt jz oh ka mw kc oi kd mz nx bi translated">随时可用— Python的Input()作为UI</h1><p id="fad0" class="pw-post-body-paragraph kw kx iq ky b kz nb jr lb lc nc ju le lf ny lh li lj nz ll lm ln oa lp lq lr ij bi translated">由于没有用户界面经验，我需要一种快速简单的方法来访问我的数据库。我使用Python的<code class="fe ot ou ov ok b">input()</code>函数来获得用户响应并实现基本的控制。然后，这些输入用于启动main.py文件中的数据库插入和检索。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pa"><img src="../Images/7f1805e8753d8fa563b12ef8d9cc121b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WkesgN9PmpdLM4NH9Cs8MA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用input()的用户提示</p></figure><h1 id="7a0d" class="nn mj iq bd mk no oe nq mn nr of nt mq jw og jx mt jz oh ka mw kc oi kd mz nx bi translated">结论</h1><p id="fbb5" class="pw-post-body-paragraph kw kx iq ky b kz nb jr lb lc nc ju le lf ny lh li lj nz ll lm ln oa lp lq lr ij bi translated">现在你有了一个全功能的(有些易坏的)食谱数据库，它最大化了增长空间，允许简单的分类和搜索，并简化了你一周的购物。</p><p id="5bc3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你更愿意拥有一个充满来自互联网的食谱的数据库，尝试使用Selenium和Beautiful Soup从你最喜欢的网站上收集食谱。可以在<a class="ae kv" rel="noopener" target="_blank" href="/how-i-diyd-my-budget-using-python-for-selenium-and-beautiful-soup-4d2edc5c519">这里</a>找到这些工具不同用例的教程。</p><p id="1a0d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">快乐的用餐准备！</p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><p id="1055" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mh">完整代码可以在我的Github </em> <a class="ae kv" href="https://github.com/jenniferrkim/recipe_database" rel="noopener ugc nofollow" target="_blank"> <em class="mh">这里</em> </a> <em class="mh">找到。为了方便查看，我用了一个Jupyter笔记本，但是你可以随意把它分成有标签的文件。</em></p></div></div>    
</body>
</html>