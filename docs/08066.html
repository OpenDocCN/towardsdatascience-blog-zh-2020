<html>
<head>
<title>Why We Need Indexes for Database Tables</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么我们需要数据库表的索引</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/why-we-need-indexes-for-database-tables-25198145a8ca?source=collection_archive---------31-----------------------#2020-06-14">https://towardsdatascience.com/why-we-need-indexes-for-database-tables-25198145a8ca?source=collection_archive---------31-----------------------#2020-06-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/16178e5dd28190ebf66b214e0775d667.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*t2mysn04Zzwewzgk"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">托德·夸肯布什在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><div class=""/><div class=""><h2 id="4b92" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">引入没有任何公式和计算机科学理论的B+树索引</h2></div><p id="ba70" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您不是DBA或数据库开发人员，您可能不知道数据库索引的机制。但是只要你会写一些SQL查询，你一定听说过数据库索引，知道索引可以提高SQL查询的性能。</p><p id="660b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我将尝试使用最简单的语言和图表来说明B+树索引如何提高SQL查询的性能。我使用B+树索引作为例子的原因是</p><ul class=""><li id="cb78" class="lu lv jj la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">它被大多数关系数据库管理系统使用，如MySQL、SQL Server和Oracle</li><li id="597d" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">它可以提高大多数类型的SQL查询的性能，而不是特定类型的查询</li></ul><h1 id="532d" class="mi mj jj bd mk ml mm mn mo mp mq mr ms kp mt kq mu ks mv kt mw kv mx kw my mz bi translated">它看起来怎么样？</h1><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi na"><img src="../Images/ce980bfb9578b68e2f95ffebd22e7d1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pn4NtGsyXKQrebhG"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://unsplash.com/@shanehauser?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">谢恩·豪泽</a>在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="91e0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们保持这个指令简单，这里有一个简化的图表说明了B+树索引的结构。</p><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nf"><img src="../Images/a431bcd64ef9defc5bb6c80ae5bf343c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a-i_EluPLupSju9uxCg3GQ.png"/></div></div></figure><p id="db29" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的B+树示例中，每个矩形代表硬盘中的一个块，而蓝色填充的点代表将这些块链接在一起的指针。</p><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/742d6f9d0c1bcc53d0f836d4a763cd78.png" data-original-src="https://miro.medium.com/v2/resize:fit:442/format:webp/1*VwnKvYSkp9rxhojn1mBOOQ.png"/></div></figure><p id="fdc6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，出于演示目的，该图极大地简化了B+树，因为它假设每个硬盘块只能包含2个键。实际上，这个数字会大得多。</p><p id="886f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">理解B+树索引是如何构造的很重要。我们需要知道“叶节点”级别应该包含创建该索引的字段的所有值。在上面的例子中，很明显我们在这个表列中只有9行，它们的值从1到9。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><p id="876f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你对上面的B+树是如何构建的感兴趣，请参考我的另一篇文章:<strong class="la jk">B+树索引是如何在数据库中构建的？</strong></p><div class="is it gp gr iu no"><a rel="noopener follow" target="_blank" href="/how-b-tree-indexes-are-built-in-a-database-6f847fb3cfcc"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd jk gy z fp nt fr fs nu fu fw ji bi translated">B+树索引是如何在数据库中构建的？</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">使用图表来说明如何在数据库管理系统中建立B+树索引</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">towardsdatascience.com</p></div></div><div class="nx l"><div class="ny l nz oa ob nx oc ja no"/></div></div></a></div></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="bc5e" class="mi mj jj bd mk ml od mn mo mp oe mr ms kp of kq mu ks og kt mw kv oh kw my mz bi translated">它是如何工作的？</h1><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oi"><img src="../Images/2652af5cbb2c71097c13d63770729c68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*C8OvsdWOLkgCIWST"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">玛丽亚·克拉斯诺娃在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="4e65" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">B+tree可以帮助大部分的数据库查询场景，这也是它有用的原因。</p><h2 id="f9bc" class="oj mj jj bd mk ok ol dn mo om on dp ms lh oo op mu ll oq or mw lp os ot my ou bi translated">对平等测试的质疑</h2><p id="c7e9" class="pw-post-body-paragraph ky kz jj la b lb ov kk ld le ow kn lg lh ox lj lk ll oy ln lo lp oz lr ls lt im bi translated">假设我们的SQL查询是在“equal”where条件下进行检索，例如:</p><pre class="nb nc nd ne gt pa pb pc pd aw pe bi"><span id="2ba3" class="oj mj jj pb b gy pf pg l ph pi">SELECT *<br/>FROM TABLE<br/>WHERE ID = 3</span></pre><p id="8a57" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了找到等于3的ID，B+树的用法如下。</p><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/eec378c365288fc3e0ac29968a06497e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Csz1PQnJAfGF7x9SRvCzYg.png"/></div></figure><ul class=""><li id="e569" class="lu lv jj la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">从树的顶层开始，3小于5，所以我们需要使用数字5左边的指针</li><li id="c02d" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">在下一层，3在2和4之间，所以我们需要使用中间的指针</li><li id="ea41" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">我们得到了叶节点上的块，3在这里</li></ul><h2 id="d9f9" class="oj mj jj bd mk ok ol dn mo om on dp ms lh oo op mu ll oq or mw lp os ot my ou bi translated">对比较的质疑</h2><p id="f41d" class="pw-post-body-paragraph ky kz jj la b lb ov kk ld le ow kn lg lh ox lj lk ll oy ln lo lp oz lr ls lt im bi translated">如果我们的SQL查询在一个范围内搜索会怎样？例如，以下是SQL查询:</p><pre class="nb nc nd ne gt pa pb pc pd aw pe bi"><span id="08a5" class="oj mj jj pb b gy pf pg l ph pi">SELECT *<br/>FROM TABLE<br/>WHERE ID BETWEEN 3 AND 7</span></pre><p id="da38" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是该过程的演示。</p><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/c24484949dcc6076d9a705bbf6d20ba2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c2v_p7QQFZEP-24fKxfKNg.png"/></div></figure><ul class=""><li id="3ccc" class="lu lv jj la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">从树的顶层开始，3小于5，所以我们需要使用数字5左边的指针</li><li id="f835" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">在下一层，3在2和4之间，所以我们需要使用中间的指针</li><li id="8b07" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">我们得到了叶节点上的块，3在这里</li><li id="6e43" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">因为我们是在比较中查询，所以光标将继续在这个块中获取，所以我们可以得到数字4</li><li id="0d8b" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">我们还没有到达7，所以光标将继续移动到下一个(右)叶节点块</li><li id="f87c" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">我们到了下一个街区，所以我们得到了数字5和6。但是它还没有完成，将使用与上一步类似的机制到达下一个块</li><li id="cc76" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">我们到达了下一个包含数字7的街区</li><li id="f065" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">我们已经达到了范围的上限，因此查询结束</li></ul><h1 id="a8ec" class="mi mj jj bd mk ml mm mn mo mp mq mr ms kp mt kq mu ks mv kt mw kv mx kw my mz bi translated">b+树特征</h1><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pk"><img src="../Images/a387f37f4eb346895fefc07a063811f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zOFZBFylewvnBc5C"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">克里斯汀娜·戈塔迪在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="607e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">B+树索引最重要的特点是它由树的<strong class="la jk">叶节点层</strong>和<strong class="la jk">搜索关键字层</strong>组成。</p><ol class=""><li id="264a" class="lu lv jj la b lb lc le lf lh lw ll lx lp ly lt pl ma mb mc bi translated">该索引列的所有值都出现在叶节点中。</li><li id="35b2" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt pl ma mb mc bi translated">非叶节点仅用于搜索目的，因此只有指向较低级别的指针。换句话说，它们不能导致实际的数据条目。</li><li id="4ade" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt pl ma mb mc bi translated">叶节点中的每个键都有一个指向数据条目的额外指针，因此它可以引导光标查找/获取数据行。</li></ol><h1 id="1fb7" class="mi mj jj bd mk ml mm mn mo mp mq mr ms kp mt kq mu ks mv kt mw kv mx kw my mz bi translated">B+树如何提高性能？</h1><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pm"><img src="../Images/edda92128c40d68c29479eeb0539becb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iFpbA8-HMMwGJ8x5"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">安德斯·吉尔登在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="64c3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如上例所示，B+树适用于“相等”和比较条件。</p><h2 id="5e3e" class="oj mj jj bd mk ok ol dn mo om on dp ms lh oo op mu ll oq or mw lp os ot my ou bi translated">叶片与非叶片水平</h2><p id="2d2f" class="pw-post-body-paragraph ky kz jj la b lb ov kk ld le ow kn lg lh ox lj lk ll oy ln lo lp oz lr ls lt im bi translated">可以看出，查询只需要遍历非叶节点上的搜索关键字就可以找到期望值。因此，当SQL查询在创建B+树索引的列上进行检索时，只需要遍历几层非叶节点。</p><p id="d553" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您一定认为非叶节点一定是一种开销，当有大量数据行时，它会变慢，因为可能有许多非叶级别。</p><p id="1be8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">部分正确。是的，需要扫描非叶节点以获得期望值。实际上，扫描的次数正好等于非叶层的数量。但是，实际上，我们硬盘上的块会比上面的例子大得多。通常，一个有1000万个条目的表可以放在一个只有3个非叶层的B+树中。即使表非常大，如十亿级，通常B+树的非叶层的数量通常是4或5。</p><p id="fb3f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，使用B+树索引可以显著减少SQL查询中扫描的硬盘块数。</p><h2 id="51e9" class="oj mj jj bd mk ok ol dn mo om on dp ms lh oo op mu ll oq or mw lp os ot my ou bi translated">为什么扫描的块数很重要？</h2><p id="e921" class="pw-post-body-paragraph ky kz jj la b lb ov kk ld le ow kn lg lh ox lj lk ll oy ln lo lp oz lr ls lt im bi translated">我想这篇文章的读者可能没有计算机科学背景，所以我想对“块”的简单解释对于更好地理解这个问题可能是必要的。</p><p id="bda3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们的硬盘中，数据并不总是按顺序存储的。单个文件可能被分割并存储到不同的块中。因此，当我们读取文件/数据集/表时，为了扫描整个文件，有必要在不同的块之间跳转。</p><p id="ee9a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通常，对于机械硬盘，有一个只能上下移动的磁头。当需要从不同的位置读取数据时，整个硬盘驱动器会将该位置旋转到磁头所在的位置，以便磁头可以读取数据。</p><p id="e280" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设我们正在扫描1000个块。最坏的情况是磁盘需要旋转1000次。如果我们使用索引，这个数字将减少到4-5倍。这就是指数有助于提高性能的原因。</p><h1 id="4167" class="mi mj jj bd mk ml mm mn mo mp mq mr ms kp mt kq mu ks mv kt mw kv mx kw my mz bi translated">摘要</h1><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pn"><img src="../Images/0b5a52e9cf2730827c1a3013679b9a01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*67RHUBA2_owni7Yq"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://unsplash.com/@aaronburden?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Aaron Burden </a>在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="3036" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这篇文章中，我分享了B+tree的样子以及它是如何工作的，并促进了一个SQL查询，通常使用相等和比较条件。</p><p id="55ad" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">事实证明B+Tree不再是最先进的数据库索引，但是我相信，作为在大多数RDBMS中仍然普遍使用的最经典的索引，它仍然是展示为什么我们需要数据库表的索引以及它如何工作的最好例子。希望这对你来说足够有趣。</p><div class="is it gp gr iu no"><a href="https://medium.com/@qiuyujx/membership" rel="noopener follow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd jk gy z fp nt fr fs nu fu fw ji bi translated">通过我的推荐链接加入Medium克里斯托弗·陶</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">medium.com</p></div></div><div class="nx l"><div class="po l nz oa ob nx oc ja no"/></div></div></a></div><p id="7d6b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">如果你觉得我的文章有帮助，请考虑加入灵媒会员来支持我和成千上万的其他作家！(点击上面的链接)</strong></p></div></div>    
</body>
</html>