<html>
<head>
<title>Pandas DataFrame Group by Consecutive Same Values</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">熊猫数据帧按连续的相同值分组</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/pandas-dataframe-group-by-consecutive-same-values-128913875dba?source=collection_archive---------8-----------------------#2020-07-06">https://towardsdatascience.com/pandas-dataframe-group-by-consecutive-same-values-128913875dba?source=collection_archive---------8-----------------------#2020-07-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/10894fcb641b4c8a1293534755654a53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N6QQR9jxqJVuhBfjQQ533w.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://pixabay.com/users/MichaelGaida-652234/" rel="noopener ugc nofollow" target="_blank"> MichaelGaida </a>在<a class="ae jg" href="https://pixabay.com/photos/stadium-sit-auditorium-grandstand-1750794/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上拍摄</p></figure><h2 id="77fe" class="jh ji jj bd b dl jk jl jm jn jo jp dk jq translated" aria-label="kicker paragraph">Python 编程技巧</h2><div class=""/><div class=""><h2 id="5572" class="pw-subtitle-paragraph kp js jj bd b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dk translated">按重复多次的连续相同值对熊猫数据帧进行分组</h2></div><p id="c8ce" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们通常希望通过连续的值来分割熊猫数据帧。然而，在任何情况下处理连续值几乎总是不容易的，比如 SQL，Pandas 也是如此。此外，标准 SQL 提供了一堆窗口函数来促进这种操作，但是在 Pandas 中没有太多的窗口函数。幸运的是，Python 中有许多变通方法，有时甚至比经典的窗口函数更简单。</p><p id="5c78" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在本文中，我将演示如何通过重复一次或多次的连续相同值对 Pandas 数据帧进行分组。</p><h1 id="bf04" class="md me jj bd mf mg mh mi mj mk ml mm mn ky mo kz mp lb mq lc mr le ms lf mt mu bi translated">问题定义</h1><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/564438fb0842e525bd4a0361c7071e94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K_ASFaz5nY8Ft1f2ZtV3bA.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://pixabay.com/users/Anemone123-2637160/" rel="noopener ugc nofollow" target="_blank">Pixabay<a class="ae jg" href="https://pixabay.com/photos/question-question-mark-survey-2736480/" rel="noopener ugc nofollow" target="_blank">上的</a>银莲花 123</a>拍摄</p></figure><p id="0cd5" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果您仍然不太确定我们要解决的问题是什么，请不要担心，您将通过如下生成的示例数据了解这一点:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="02b8" class="ne me jj na b gy nf ng l nh ni">df = pd.DataFrame({<br/>    'item':['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M'], <br/>    'v':[1, 2, 3, 3, 3, 4, 5, 5, 6, 7, 8, 8, 9]<br/>})</span></pre><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nj"><img src="../Images/57da1aab08f10ed46247d79c3a0d83ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:316/format:webp/1*4Y_xVwYmG3JCNhBgUljYVg.png"/></div></div></figure><p id="fe64" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在截图中，绿线划分了我们预期的组。</p><p id="6d82" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在这个例子中，对这些值进行分组实际上非常容易。就简单<code class="fe nk nl nm na b">groupby('v')</code>。</p><p id="0bc3" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">然而，它实际上是假设值<code class="fe nk nl nm na b">v</code>必须单调递增。</p><p id="0958" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果值列不是单调递增的怎么办？</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="7c48" class="ne me jj na b gy nf ng l nh ni">df = pd.DataFrame({<br/>    'item':['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N'], <br/>    'v':[1, 2, 3, 3, 3, 4, 5, 5, 6, 7, 8, 8, 9, 3]<br/>})</span></pre><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nn"><img src="../Images/83b9deb624d17cd3a29a93b31af6a777.png" data-original-src="https://miro.medium.com/v2/resize:fit:340/format:webp/1*s0dV6kkDo394Zdt0oFnEtw.png"/></div></div></figure><p id="ab7b" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在这个新示例中，我们再次添加了第 13 行，它的值为<code class="fe nk nl nm na b">v == 3</code>。如果我们单纯的<code class="fe nk nl nm na b">groupby('v')</code>，第 13 排会和 2、3、4 排放在同一个组，这不是我们想要的。</p><p id="3d9e" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">换句话说，第 13 行应该在一个单独的组中，因为它不是连续的。</p><h1 id="3f85" class="md me jj bd mf mg mh mi mj mk ml mm mn ky mo kz mp lb mq lc mr le ms lf mt mu bi translated">直觉</h1><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/ff9df7dca9fff75900a6e6dee790f59a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OYiiK2Y8lM0gil3Wy0uTMA.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae jg" href="https://pixabay.com/users/qimono-1962238/" rel="noopener ugc nofollow" target="_blank">奇莫诺</a>在<a class="ae jg" href="https://pixabay.com/photos/light-bulbs-chosen-bulb-light-1875384/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上的照片</p></figure><p id="0f79" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">基本思想是创建这样一个列，它可以根据。对于连续的原始值，它必须具有相同的值，但是当原始值改变时，它必须具有不同的值。我们可以用<code class="fe nk nl nm na b">cumsum()</code>。以下是直观的步骤。</p><ol class=""><li id="a333" class="no np jj lj b lk ll ln lo lq nq lu nr ly ns mc nt nu nv nw bi translated">创建一个新列，将原始值下移一行</li><li id="543c" class="no np jj lj b lk nx ln ny lq nz lu oa ly ob mc nt nu nv nw bi translated">将移位值与原始值进行比较。如果相等，则为真，否则为假</li><li id="3333" class="no np jj lj b lk nx ln ny lq nz lu oa ly ob mc nt nu nv nw bi translated">在布尔列上使用<code class="fe nk nl nm na b">cumsum()</code>,得到的列可以用于分组</li></ol><p id="66ac" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这是一个仅为直观目的而创建的示例数据帧。</p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oc"><img src="../Images/3bd03bcd57bff3242b866ed36122397d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1126/format:webp/1*5Jj5SDarE9wu8BsGevjY3g.png"/></div></div></figure><p id="a1cb" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">为什么有效？如果你关注每一组:</p><ul class=""><li id="befa" class="no np jj lj b lk ll ln lo lq nq lu nr ly ns mc od nu nv nw bi translated"><code class="fe nk nl nm na b">shifted_not_equal_to_original</code>的第一个布尔值为<code class="fe nk nl nm na b">True</code>，其余为<code class="fe nk nl nm na b">False</code>(如果该组有多行)。因此，<code class="fe nk nl nm na b">cumsum()</code>函数将使每组的第一行与前一组的最后一行有所不同。</li><li id="3795" class="no np jj lj b lk nx ln ny lq nz lu oa ly ob mc od nu nv nw bi translated">布尔值为<code class="fe nk nl nm na b">True </code>，因为如果前一行值不同于当前行值，则移位后的值不同于原始值。另一方面，从这个连续条纹的第二行开始，它将是<code class="fe nk nl nm na b">False</code>,因为该值等于它的前一行。</li></ul><h1 id="185e" class="md me jj bd mf mg mh mi mj mk ml mm mn ky mo kz mp lb mq lc mr le ms lf mt mu bi translated">解决办法</h1><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/5ca0f8a49122d8584224c2148647bd3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F1R1p1W9B8Bc58KAy6Al8A.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://pixabay.com/users/rubylia-2153926/" rel="noopener ugc nofollow" target="_blank"> rubylia </a>在<a class="ae jg" href="https://pixabay.com/photos/hand-rubik-cube-puzzle-game-2208491/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上拍摄</p></figure><p id="aa1c" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我知道直觉看起来很复杂，但是一旦你理解了这些，使用这种方法就很容易了，如下所示。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="53c9" class="ne me jj na b gy nf ng l nh ni">df.groupby((df['v'].shift() != df['v']).cumsum())</span></pre><p id="70db" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">让我们验证这些组:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="ee7c" class="ne me jj na b gy nf ng l nh ni">for k, v in df.groupby((df['v'].shift() != df['v']).cumsum()):<br/>    print(f'[group {k}]')<br/>    print(v)</span></pre><figure class="mv mw mx my gt iv gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/461754100c77ebd38cd6b0725531c96a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*5zEde7BCK8XDAy6wMOGYfA.png"/></div></figure><p id="d957" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">非常重要的是，第 13 排与第 2、3、4 排分开分组，这正是我们所期待的。</p><p id="cbcc" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">因此，这种方法将能够对连续的值进行分组，而不管这些值后来是否重复，只要它不是连续的，就会创建另一个组。</p><h1 id="c294" class="md me jj bd mf mg mh mi mj mk ml mm mn ky mo kz mp lb mq lc mr le ms lf mt mu bi translated">摘要</h1><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/4fb7030ff6422f6b74e149b813a6b65a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4sDIrc2ASvDch_xT5pSTZA.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">由<a class="ae jg" href="https://pixabay.com/users/Free-Photos-242387/" rel="noopener ugc nofollow" target="_blank">自由照片</a>在<a class="ae jg" href="https://pixabay.com/photos/macbook-notebook-home-office-336704/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上拍摄的照片</p></figure><p id="e918" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">事实上，我不会说熊猫提供了许多有用的窗口功能。但是，Python 中的 Pandas 是典型的不像 SQL 的“编程语言”。因此，它提供了更多的可能性，有时甚至能以更简单的方式解决问题。</p><div class="is it gp gr iu of"><a href="https://medium.com/@qiuyujx/membership" rel="noopener follow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd jt gy z fp ok fr fs ol fu fw js bi translated">通过我的推荐链接加入 Medium 克里斯托弗·陶</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">medium.com</p></div></div><div class="oo l"><div class="op l oq or os oo ot ja of"/></div></div></a></div><p id="7f5c" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果你觉得我的文章有帮助，请考虑加入 Medium 会员来支持我和成千上万的其他作者！(点击上面的链接)</p></div></div>    
</body>
</html>