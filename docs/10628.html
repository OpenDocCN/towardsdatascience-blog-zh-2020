<html>
<head>
<title>Master the art of subplots in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握 Python 中支线剧情的艺术</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/master-the-art-of-subplots-in-python-45f7884f3d2e?source=collection_archive---------12-----------------------#2020-07-25">https://towardsdatascience.com/master-the-art-of-subplots-in-python-45f7884f3d2e?source=collection_archive---------12-----------------------#2020-07-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/cd88a4be841a4b199525cc47105a57c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Xs71FX_-eX3JfJdp"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://unsplash.com/@pietromattia?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Pietro Mattia </a>在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><div class=""/><div class=""><h2 id="6953" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">了解可视化大数据的六种独特方式</h2></div><p id="4c37" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通常，在处理数据时，无论大小，有时您都希望并排比较事物，或者分别绘制不同的属性或特征。在这种情况下，一个数字是不够的。因此，你需要知道<strong class="la jk"> <em class="lu">处理支线剧情</em> </strong>的艺术。</p><p id="126b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本文将重点介绍<strong class="la jk">支线剧情</strong>的概念。它会教你<strong class="la jk"> <em class="lu">使用 Matplotlib 在 Python 中创建<strong class="la jk">非常简单和非常复杂的网格</strong>的六种独特方式</em> </strong>。</p><blockquote class="lv lw lx"><p id="1b21" class="ky kz lu la b lb lc kk ld le lf kn lg ly li lj lk lz lm ln lo ma lq lr ls lt im bi translated">“每一次失败都有另一种选择。你只需要找到它。遇到路障时，绕道而行”——<strong class="la jk"><em class="jj">玫琳·凯·艾施</em> </strong></p></blockquote></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="fd5b" class="mi mj jj bd mk ml mm mn mo mp mq mr ms kp mt kq mu ks mv kt mw kv mx kw my mz bi translated">方式一:使用支线剧情( )</h1><h2 id="5945" class="na mj jj bd mk nb nc dn mo nd ne dp ms lh nf ng mu ll nh ni mw lp nj nk my nl bi translated">绘制单行或单列</h2><p id="57d7" class="pw-post-body-paragraph ky kz jj la b lb nm kk ld le nn kn lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">让我们首先导入一些基本模块，并使用一个<a class="ae jg" href="https://matplotlib.org/3.1.1/gallery/style_sheets/style_sheets_reference.html" rel="noopener ugc nofollow" target="_blank">花哨的样式表</a>来给我们的人物添加艺术感。</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="6167" class="na mj jj nw b gy oa ob l oc od">%matplotlib inline # To enable inline plotting in Jupyter Notebook</span><span id="eaf5" class="na mj jj nw b gy oe ob l oc od">import numpy as np<br/>import matplotlib.pyplot as plt<br/>plt.style.use('fivethirtyeight') # For better style</span></pre><p id="4d9b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们定义一些数据来绘图。我们用我们不朽的正弦和余弦曲线来描述 3𝜋).的𝑥∈(0</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="5b5e" class="na mj jj nw b gy oa ob l oc od">x = np.linspace(0., 3*np.pi, 100) # 0 to 3*Pi in 100 steps</span><span id="c025" class="na mj jj nw b gy oe ob l oc od">y_1 = np.sin(x) <br/>y_2 = np.cos(x)</span></pre><p id="7bd0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在让我们用一行两列来创建我们最初的两个支线剧情。由于<code class="fe of og oh nw b">axes</code>对象包含两个子情节，您可以使用索引[0]和[1]来访问它们，因为在 Python 中索引是从 0 开始的。</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="d635" class="na mj jj nw b gy oa ob l oc od">fig, axes = plt.subplots(nrows=1, ncols=2, figsize=(9, 3))</span><span id="52e1" class="na mj jj nw b gy oe ob l oc od">axes[0].plot(x, y_1, '-', c='orange', label='sin(x)')<br/>axes[1].plot(x, y_2, '-', c='magenta', label='cos(x)')</span><span id="517b" class="na mj jj nw b gy oe ob l oc od">axes[0].legend(fontsize=16, frameon=False)<br/>axes[1].legend(fontsize=16, frameon=False)</span><span id="e3fd" class="na mj jj nw b gy oe ob l oc od">fig.suptitle('Subplots without shared y-axis')</span></pre><figure class="nr ns nt nu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oi"><img src="../Images/ed664f72b5a07e7d1ef248de05945715.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4ytCFz1OMWHl9FdI_3Xxaw.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">使用“支线剧情()”模块创建的支线剧情</p></figure><p id="7c52" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">注意:</strong>如果你不喜欢指数符号，你也可以使用如下所示的轴名，然后直接使用它们绘图。下面的元组<code class="fe of og oh nw b">(ax1, ax2)</code>表示各个支线剧情的轴句柄。由于以上两个支线剧情有相同的<em class="lu"> y </em>轴限制，你可以使用关键字<code class="fe of og oh nw b">sharey=True</code>从右侧支线剧情中移除多余的<em class="lu"> y </em>轴值。</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="cf1d" class="na mj jj nw b gy oa ob l oc od">fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 3), sharey=True)</span><span id="141d" class="na mj jj nw b gy oe ob l oc od">ax1.plot(...)<br/>ax2.plot(...)</span></pre><p id="fdea" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">跨越多行的支线剧情:</strong>上图中，支线剧情以柱状方式绘制。要将它们绘制成两行，可以使用<code class="fe of og oh nw b">nrows=2, ncols=1</code>。现在你必须使用关键字<code class="fe of og oh nw b">sharex</code>。</p><h2 id="5335" class="na mj jj bd mk nb nc dn mo nd ne dp ms lh nf ng mu ll nh ni mw lp nj nk my nl bi translated">绘制多行和多列</h2><p id="ef9f" class="pw-post-body-paragraph ky kz jj la b lb nm kk ld le nn kn lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">当你有超过 1 行<strong class="la jk">和 1 列</strong>时，你需要两个索引来访问单独的支线剧情，如下面的代码所示。索引从 0 开始。因此，对于 2 行 2 列，索引将是 0 和 1。切片符号[i，j]中的第一和第二索引分别对应于行(I)和列(j)的编号。</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="d062" class="na mj jj nw b gy oa ob l oc od">fig, axes = plt.subplots(nrows=2, ncols=2, figsize=(9, 5),<br/>                         sharey='row', sharex='row')</span><span id="a5b4" class="na mj jj nw b gy oe ob l oc od">axes[0, 0].plot(x+1, y_1+1, '-', c='orange')<br/>axes[0, 1].plot(x, y_2, '-', c='magenta')<br/>axes[1, 0].plot(x, y_1**2, '--', c='orange')<br/>axes[1, 1].plot(x, y_2**2, '--', c='magenta')</span><span id="685f" class="na mj jj nw b gy oe ob l oc od">axes[0, 0].set_ylabel(r'sin(x)')<br/>axes[0, 1].set_ylabel(r'cos(x)')<br/>axes[1, 0].set_ylabel(r'sin$^2$(x)')<br/>axes[1, 1].set_ylabel(r'cos$^2$(x)')</span><span id="8ee4" class="na mj jj nw b gy oe ob l oc od">fig.tight_layout()</span></pre><figure class="nr ns nt nu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oj"><img src="../Images/7702873c214e970f6807c357db37fcb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bdZYC3bEExV2lnWzajcMlw.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">使用 subplots()模块绘制的包含 2 行 2 列的图形。</p></figure><p id="7895" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上图中，您可以选择如何共享<em class="lu"> x </em>和<em class="lu"> y </em>轴。我选择了<code class="fe of og oh nw b">sharex='col'</code>和<code class="fe of og oh nw b">sharey='row'</code>，这意味着<em class="lu">x</em>-轴跨每列共享，而<em class="lu">y</em>-轴跨每行共享。请注意上图中不同的轴限制，以便理解这一点。</p><p id="c29a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如前所述，您还可以使用元组来命名轴，避免使用索引符号。第一个元组<code class="fe of og oh nw b">(ax1, ax2)</code>对应第一行支线剧情。同样，<code class="fe of og oh nw b">(ax3, ax4)</code>对应于第二行。</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="6997" class="na mj jj nw b gy oa ob l oc od">fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(9, 5))</span></pre></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="1c0e" class="mi mj jj bd mk ml mm mn mo mp mq mr ms kp mt kq mu ks mv kt mw kv mx kw my mz bi translated">方式二:使用支线剧情( )</h1><p id="298a" class="pw-post-body-paragraph ky kz jj la b lb nm kk ld le nn kn lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">在这种方法中，首先创建人物对象，然后手动一个接一个地添加支线剧情。下面的示例创建一个 2 x 2 的网格。如果你想让多个支线剧情共享同一个<em class="lu"> x </em>或<em class="lu"> y- </em>轴，你可以在创建支线剧情时指定相应的轴，如下所示。</p><p id="bfc3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">注:</strong>此处，<strong class="la jk">从 1 </strong>开始编号。因此，对于一个 2×2 的网格，上面一行将使用数字<code class="fe of og oh nw b">(2, 2, 1)</code>、<code class="fe of og oh nw b">(2, 2, 2)</code>，第二行将分别使用数字<code class="fe of og oh nw b">(2, 2, 3)</code>、<code class="fe of og oh nw b">(2, 2, 4)</code>。前两个索引分别是总行数和总列数，而第三个数字指定子情节。</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="9421" class="na mj jj nw b gy oa ob l oc od">fig = plt.figure(figsize=(8, 6))</span><span id="f5cb" class="na mj jj nw b gy oe ob l oc od">ax1 = plt.subplot(2, 2, 1, frameon=True) <br/>ax1.plot(x+1, y_1+1)<br/>ax1.set_title('ax1')</span><span id="92e2" class="na mj jj nw b gy oe ob l oc od">ax2 = plt.subplot(2, 2, 2, sharex=ax1, facecolor='orange')<br/>ax2.plot(x, y_2, '-r')<br/>ax2.set_title('Shares x-axis with ax1')</span><span id="a714" class="na mj jj nw b gy oe ob l oc od">ax3 = plt.subplot(2, 2, 3, sharey=ax1)<br/>ax3.plot(x, y_1**2, '-g')<br/>ax3.set_title('Shares y-axis with ax1')</span><span id="8049" class="na mj jj nw b gy oe ob l oc od">ax4 = plt.subplot(2, 2, 4, facecolor='orchid')<br/>ax4.plot(x, y_2**2, '-b')</span><span id="ccb0" class="na mj jj nw b gy oe ob l oc od">fig.tight_layout()</span></pre><figure class="nr ns nt nu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ok"><img src="../Images/4254aac474870c6cdec072d9ee9b47d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EuZ2bewCSeGaK1sF0qfhmg.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">包含使用 subplot()模块创建的 2x2 子情节的图形。</p></figure></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="49c9" class="mi mj jj bd mk ml mm mn mo mp mq mr ms kp mt kq mu ks mv kt mw kv mx kw my mz bi translated">方式 3:使用 subplot2grid()</h1><p id="d3c1" class="pw-post-body-paragraph ky kz jj la b lb nm kk ld le nn kn lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">这种方法对于生成复杂网格很有用，其中子情节跨越多行或多列。在这里，您可以在整个网格中的指定位置创建支线剧情。</p><p id="e6e3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您必须首先指定整体网格大小，如下面示例代码中的<code class="fe of og oh nw b">(3, 3)</code>。然后，使用索引元组指定子情节的开始位置，索引元组的顺序为(行，列),其中索引从 0 开始。因此，对于一个 3 x 3 的网格，行和列的索引都是 0、1 和 2。如果您希望一个子情节跨越多行或多列，您可以使用关键字<code class="fe of og oh nw b">rowspan</code>或<code class="fe of og oh nw b">colspan</code>指定跨度的长度。</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="1cf3" class="na mj jj nw b gy oa ob l oc od">def add_title(axes):<br/>    for i, ax in enumerate(axes):<br/>        ax.set_title("ax%d" % (i+1), fontsize=18)</span><span id="b35a" class="na mj jj nw b gy oe ob l oc od">fig = plt.figure(figsize=(8, 8))</span><span id="a60c" class="na mj jj nw b gy oe ob l oc od">ax1 = plt.subplot2grid((3, 3), (0, 0), colspan=2)<br/>ax2 = plt.subplot2grid((3, 3), (0, 2), rowspan=3)<br/>ax3 = plt.subplot2grid((3, 3), (1, 0), rowspan=2)<br/>ax4 = plt.subplot2grid((3, 3), (1, 1))<br/>ax5 = plt.subplot2grid((3, 3), (2, 1))</span><span id="6de2" class="na mj jj nw b gy oe ob l oc od">add_title(fig.axes)</span></pre><figure class="nr ns nt nu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ok"><img src="../Images/91acfa79c33b6592d4840a00eb53736d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B6p6PdlHxefNojLzh9PMkA.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">使用 subplot2grid()模块生成的复杂的子情节网格。</p></figure></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="ab28" class="mi mj jj bd mk ml mm mn mo mp mq mr ms kp mt kq mu ks mv kt mw kv mx kw my mz bi translated">方式 4:使用 gridspec。GridSpec()</h1><p id="776e" class="pw-post-body-paragraph ky kz jj la b lb nm kk ld le nn kn lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">这种方法对于生成复杂网格也很有用<strong class="la jk">。要使用这种方法，您需要对 NumPy 数组的切片和索引符号有一个基本的了解。</strong></p><p id="de2e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，切片<code class="fe of og oh nw b">[0, :]</code>表示第一行(索引 0)和所有列(:表示全部)，切片<code class="fe of og oh nw b">[1, :-1]</code>表示第二行(索引 1)和除最后一列以外的所有列(:-1 表示除最后一列以外的所有列)。</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="2bbd" class="na mj jj nw b gy oa ob l oc od">import matplotlib.gridspec as gridspec</span><span id="2360" class="na mj jj nw b gy oe ob l oc od">fig = plt.figure(constrained_layout=True, figsize=(8, 8))<br/>spec = gridspec.GridSpec(ncols=3, nrows=3, figure=fig)</span><span id="a29d" class="na mj jj nw b gy oe ob l oc od">ax1 = fig.add_subplot(spec[0, :])<br/>ax2 = fig.add_subplot(spec[1, :-1])<br/>ax3 = fig.add_subplot(spec[1, -1])<br/>ax4 = fig.add_subplot(spec[2, 1:])<br/>ax5 = fig.add_subplot(spec[2, 0])</span><span id="2732" class="na mj jj nw b gy oe ob l oc od"># Now you can plot individually as ax1.plot(), ax2.plot() etc.</span></pre><figure class="nr ns nt nu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ol"><img src="../Images/eeb17b69fad4684622210fc7d3f56f50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q2WFSpva1UnS6w5TToZCSw.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">使用 gridspec 生成的复杂的子情节网格。Gridspec()模块。</p></figure></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="f64a" class="mi mj jj bd mk ml mm mn mo mp mq mr ms kp mt kq mu ks mv kt mw kv mx kw my mz bi translated">方式 5:使用 add_gridspec( ) —仅限 Matplotlib 3+</h1><p id="ff77" class="pw-post-body-paragraph ky kz jj la b lb nm kk ld le nn kn lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">该方法<strong class="la jk">与方式 3 </strong>非常相似，并且<strong class="la jk"> </strong>使用与上述相同的索引符号。该功能仅在 Matplotlib 3+版本中可用。</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="b04e" class="na mj jj nw b gy oa ob l oc od">fig = plt.figure(constrained_layout=True, figsize=(8, 8))</span><span id="9d8f" class="na mj jj nw b gy oe ob l oc od">spec = fig.add_gridspec(3, 3)</span><span id="a92b" class="na mj jj nw b gy oe ob l oc od">ax1 = fig.add_subplot(spec[0, :-1])<br/>ax1.set_title('ax1')</span><span id="8cc0" class="na mj jj nw b gy oe ob l oc od">ax2 = fig.add_subplot(spec[:, -1])<br/>ax2.set_title('ax2')</span><span id="0e63" class="na mj jj nw b gy oe ob l oc od">ax3 = fig.add_subplot(spec[1:, 0])<br/>ax3.set_title('ax3')</span><span id="df38" class="na mj jj nw b gy oe ob l oc od">ax4 = fig.add_subplot(spec[1, 1])<br/>ax4.set_title('ax4')</span><span id="3d25" class="na mj jj nw b gy oe ob l oc od">ax5 = fig.add_subplot(spec[-1, 1])<br/>ax5.set_title('ax5')</span></pre><figure class="nr ns nt nu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ol"><img src="../Images/ad36b0025c1b8b55583d51845b9eb00d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F6g6_5LUDxnTxvDOkg_jRw.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">使用 add_gridspec()模块生成的复杂的子情节网格。</p></figure></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="1950" class="mi mj jj bd mk ml mm mn mo mp mq mr ms kp mt kq mu ks mv kt mw kv mx kw my mz bi translated">方式 6:使用 subplot_mosaic( ) —仅限 Matplotlib 3.3</h1><h2 id="cadd" class="na mj jj bd mk nb nc dn mo nd ne dp ms lh nf ng mu ll nh ni mw lp nj nk my nl bi translated">这是仅在 Matplotlib 3.3 中可用的最新方法</h2><p id="e45e" class="pw-post-body-paragraph ky kz jj la b lb nm kk ld le nn kn lg lh no lj lk ll np ln lo lp nq lr ls lt im bi translated">最新版本的 Matplotlib 3.3 引入了一个新的、不太冗长的和一个<a class="ae jg" href="https://matplotlib.org/3.3.0/tutorials/provisional/mosaic.html#sphx-glr-tutorials-provisional-mosaic-py" rel="noopener ugc nofollow" target="_blank"> <strong class="la jk">语义的方式</strong> </a>来生成复杂的子情节网格。经由<code class="fe of og oh nw b">subplot_mosaic()</code>。你也可以随意命名你的支线剧情。您也可以使用<a class="ae jg" href="https://matplotlib.org/3.3.0/tutorials/provisional/mosaic.html#sphx-glr-tutorials-provisional-mosaic-py" rel="noopener ugc nofollow" target="_blank">简写 ASCII 符号</a>重新创建下图。</p><p id="cbb6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> <em class="lu">最酷的地方在于</em> </strong>，要生成下图所示的支线剧情网格，可以通过<strong class="la jk">以列表的形式布局</strong>。缺失的支线剧情被标示为<code class="fe of og oh nw b">'.'</code>。为了让一个支线剧情跨越两列，你可以重复名字，就像我对<code class="fe of og oh nw b">'bar'</code>做的那样。要跨越多行(垂直)，请在第二个列表中垂直重复下面的名称。你也可以使用名字<code class="fe of og oh nw b">'bar'</code>、<code class="fe of og oh nw b">'hist'</code>和<code class="fe of og oh nw b">'scatter'</code>使用字典来控制/修改相应支线剧情<strong class="la jk">的属性。</strong></p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="2f6d" class="na mj jj nw b gy oa ob l oc od">axes = plt.figure(constrained_layout=True).subplot_mosaic(<br/>                [['.', 'bar', 'bar'], # Note repitition of 'bar'<br/>                 ['hist', '.', 'scatter']])</span><span id="f46c" class="na mj jj nw b gy oe ob l oc od">for k, ax in axes.items():<br/>    ax.text(0.5, 0.5, k, ha='center', va='center', <br/>            fontsize=36, color='magenta')</span><span id="0b06" class="na mj jj nw b gy oe ob l oc od"># Using dictionary to change subplot properties<br/>axes['bar'].set_title('A bar plot', fontsize=24)    <br/>axes['hist'].set_title('A histogram', fontsize=24)    <br/>axes['scatter'].set_title('A scatter plot', fontsize=24)</span></pre><figure class="nr ns nt nu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ol"><img src="../Images/2fe36122a402ef9e8448587f88f09c1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OfhOU8ATx6LMz2ZNmLjAqg.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">使用 subplot_mosaic()生成的支线剧情。请注意跨越两列的扩展“条”。</p></figure></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><p id="d9d2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这就是我这篇文章的结尾。如果你有兴趣了解更多关于 Matplotlib 的<strong class="la jk">最新特性，可以参考我下面的文章。</strong></p><div class="is it gp gr iu om"><a rel="noopener follow" target="_blank" href="/latest-cool-features-of-matplotlib-c7a1e2c060c1"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd jk gy z fp or fr fs os fu fw ji bi translated">Matplotlib 的最新酷功能</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">立即将您的 Matplotlib 升级至最新版本 3.3</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">towardsdatascience.com</p></div></div><div class="ov l"><div class="ow l ox oy oz ov pa ja om"/></div></div></a></div><div class="is it gp gr iu om"><a rel="noopener follow" target="_blank" href="/whats-new-in-matplotlib-3-1b3b03f18ddc"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd jk gy z fp or fr fs os fu fw ji bi translated">Matplotlib 3 的新特性</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">第 3 代中最重要的更新概述</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">towardsdatascience.com</p></div></div><div class="ov l"><div class="pb l ox oy oz ov pa ja om"/></div></div></a></div></div></div>    
</body>
</html>