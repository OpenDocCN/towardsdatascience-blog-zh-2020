<html>
<head>
<title>Building a Conversational AI Chatbot With AWS Lambda Function and Amazon EFS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用AWS Lambda函数和亚马逊EFS构建对话式AI聊天机器人</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-a-conversational-ai-chatbot-with-aws-lambda-function-and-amazon-efs-615fddb4d55?source=collection_archive---------30-----------------------#2020-06-23">https://towardsdatascience.com/building-a-conversational-ai-chatbot-with-aws-lambda-function-and-amazon-efs-615fddb4d55?source=collection_archive---------30-----------------------#2020-06-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c4ec" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">亚马逊EFS在AWS Lambda上的无服务器机器学习</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ffa006e59930478e04eec61362969e08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TDUEcq0Vv2n-acV_rr6w7Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@exxteban" rel="noopener ugc nofollow" target="_blank"> @exxteban </a>在<a class="ae ky" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> unsplash </a>上的照片</p></figure><p id="82a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">亚马逊宣布对亚马逊弹性文件系统的AWS Lambda支持全面可用。亚马逊EFS是一个完全托管的、弹性的、共享的文件系统，旨在供其他AWS服务使用。</p><p id="bea7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着Amazon EFS for Lambda的发布，我们现在可以轻松地跨函数调用共享数据。它还开放了新的功能，例如将大型库和机器学习模型直接构建/导入到Lambda函数中。让我们来看看如何使用Lambda函数和EFS构建一个无服务器的对话式人工智能聊天机器人。</p><p id="93bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本帖中，我们将:</p><ul class=""><li id="74b5" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">创建一个Amazon弹性文件系统</li><li id="f6a5" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">部署并运行一个SageMaker笔记本实例，并将EFS装载到该实例。</li><li id="21ac" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">将PyTorch库和ConvAI预训练模型下载到EFS。</li><li id="c466" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">添加对话历史DynamoDB表和网关端点以保存和检索对话历史。</li><li id="a017" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">部署聊天机器人引擎Lambda功能，并为其启用EFS。</li></ul><p id="8b9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是架构图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/b8c6b57e4c0a45019e5d9250ba27abb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lbmfSWJ35xikL8asd97B-w.png"/></div></div></figure><h1 id="56d0" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">创建EFS文件系统</h1><p id="e149" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">在这个例子中我们将使用CloudFormation来创建EFS和EFS接入点，配置定义如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="d758" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，我们将使用EFS <strong class="lb iu">通用</strong>性能模式，因为它的延迟低于最大I/O</p><h1 id="975a" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">与亚马逊SageMaker合作</h1><p id="be6f" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">我们将在亚马逊SageMaker笔记本<strong class="lb iu"> </strong>上安装EFS，在EFS上安装PyTorch和ConvAI模型。</p><p id="b297" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">笔记本实例必须能够访问同一个安全组，并且与EFS文件系统位于同一个VPC中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/7436c1ba7ccfcb8c3e34d84b10327cbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iv6k2kU1dvX7SXd3k9MjQA.png"/></div></div></figure><p id="1ba5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看EFS山路径<code class="fe nk nl nm nn b">/py-libs</code>到<code class="fe nk nl nm nn b">/home/ec2-user/SageMaker/libs </code>目录:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="0c44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后将PyTorch和<a class="ae ky" href="https://github.com/ThilinaRajapakse/simpletransformers" rel="noopener ugc nofollow" target="_blank"> simpletransformers </a>安装到<code class="fe nk nl nm nn b">lib/py-libs</code>目录:</p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="5c93" class="ns ml it nn b gy nt nu l nv nw">!sudo pip --no-cache-dir install torch -t libs/py-libs<br/>!sudo pip --no-cache-dir install torchvision -t libs/py-libs<br/>!sudo pip --no-cache-dir install simpletransformers -t libs/py-libs</span></pre><p id="0868" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们安装好所有的包，下载拥抱脸提供的<a class="ae ky" href="https://s3.amazonaws.com/models.huggingface.co/transfer-learning-chatbot/gpt_personachat_cache.tar.gz" rel="noopener ugc nofollow" target="_blank">预训练模型</a>，然后解压文件到EFS的<code class="fe nk nl nm nn b">convai-model</code>目录。</p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="e93e" class="ns ml it nn b gy nt nu l nv nw">!sudo wget <a class="ae ky" href="https://s3.amazonaws.com/models.huggingface.co/transfer-learning-chatbot/gpt_personachat_cache.tar.gz" rel="noopener ugc nofollow" target="_blank">https://s3.amazonaws.com/models.huggingface.co/transfer-learning-chatbot/gpt_personachat_cache.tar.gz</a><br/>!sudo tar -xvf gpt_personachat_cache.tar.gz -C libs/convai-model<br/>!sudo chmod -R g+rw libs/convai-model</span></pre><p id="354c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在准备与预训练的模型对话，只需调用<code class="fe nk nl nm nn b">model.interact()</code>。</p><p id="4868" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">拥抱脸提供的<a class="ae ky" href="https://s3.amazonaws.com/models.huggingface.co/transfer-learning-chatbot/gpt_personachat_cache.tar.gz" rel="noopener ugc nofollow" target="_blank">预训练模型</a>开箱即用性能良好，在创建聊天机器人时可能需要较少的微调。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/87a697d5a2710ebf5ae3d74efbaa6946.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vg9AWQgr877si50FGEb7Lg.jpeg"/></div></div></figure><p id="4814" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到python包和模型正确地从EFS消费，我们能够与预先训练好模型开始对话。</p><h1 id="7675" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">创建AWS DynamoDB表</h1><p id="984f" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">创建一个DialogHistory表来存储至少带有用户最后一次发言的对话历史。我们可以使用<strong class="lb iu"> </strong> <a class="ae ky" href="http:#" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">样例CloudFormation模板</strong> </a>来配置DynamoDB表。</p><p id="4a6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，<strong class="lb iu"> </strong>我们必须为DynamoDB  创建一个<strong class="lb iu"> </strong> <a class="ae ky" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/vpc-endpoints-dynamodb.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> VPC端点，即使Lambda函数在VPC的公共子网内运行。</strong></a></p><h1 id="996e" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">配置AWS Lambda以使用EFS</h1><p id="e053" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">我们将使用AWS <strong class="lb iu"> SAM </strong>来创建Lambda函数并挂载Lambda函数的EFS访问点。</p><p id="bca4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，创建一个Lambda函数资源，然后为Lambda设置EFS文件系统。确保EFS和Lambda在同一个VPC中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h2 id="51a4" class="ns ml it bd mm ny nz dn mq oa ob dp mu li oc od mw lm oe of my lq og oh na oi bi translated">添加对话引擎:AWS Lambda</h2><p id="dd50" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">在本节中，我们将创建一个Lambda函数，用于用户和对话AI模型之间的通信。</p><p id="110a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将在<code class="fe nk nl nm nn b">src/api.py</code>中包含以下源代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="e85b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意<a class="ae ky" href="https://github.com/ThilinaRajapakse/simpletransformers" rel="noopener ugc nofollow" target="_blank"> simpletransformers </a>库允许我们使用<code class="fe nk nl nm nn b">input()</code>在本地与模型交互。为了构建我们的聊天引擎，我们需要覆盖默认方法<code class="fe nk nl nm nn b">interact</code>和<code class="fe nk nl nm nn b">conv_ai</code>中的<code class="fe nk nl nm nn b">sample_sequenc</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h1 id="39e9" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">部署聊天机器人服务</h1><p id="91e2" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">我们快到了！现在我们必须部署我们的机器人。运行以下命令进行部署:</p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="2dbe" class="ns ml it nn b gy nt nu l nv nw"><strong class="nn iu">$</strong>sam deploy --capabilities CAPABILITY_NAMED_IAM --guided</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/84114f2233915df8b2bb19fedd7569e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jdDdlkPgS86zdgyeGcgEgw.png"/></div></div></figure><p id="101c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上面的输出中，我们可以看到聊天机器人现在已经部署好了。</p><p id="0d08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在是时候测试我们的机器人了。转到AWS管理控制台中的CloudFormation资源列表，找到lambda函数名称，并使用以下命令调用Lambda函数:</p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="00b2" class="ns ml it nn b gy nt nu l nv nw"><strong class="nn iu">$</strong>aws lambda invoke --function-name "<a class="ae ky" href="https://ap-southeast-2.console.aws.amazon.com/lambda/home?region=ap-southeast-2#/functions/chat-efs-api-HelloFunction-KQSNKF5K0IY8" rel="noopener ugc nofollow" target="_blank">chat-efs-api-HelloFunction-KQSNKF5K0IY8</a>" out --log-type Tail  \--query 'LogResult' --output text |  base64 -d</span></pre><p id="0631" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/f6fe2c3169612ce3bc44c30db272759f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eN4T7xEZ9-GLA8jG2noxZA.jpeg"/></div></div></figure><p id="4cb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个对话框示例:</p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="d757" class="ns ml it nn b gy nt nu l nv nw">&gt;&gt;hi there<br/>how are you?<br/>&gt;&gt;good, thank you<br/>what do you like to do for fun?<br/>&gt;&gt;I like reading, yourself?<br/>i like to listen to classical music<br/>......</span></pre><p id="e62f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有用！从上面的截图我们可以看到，聊天机器人根据用户的输入返回响应。</p><p id="dad6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，我知道冷启动对响应时间的影响。第一个请求花费了大约30秒的时间让<strong class="lb iu">冷启动</strong>完成。为了防止Lambda函数冷启动，我们可以使用<a class="ae ky" href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-concurrency.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">提供并发</strong> </a> <strong class="lb iu"> </strong>来保持函数预热:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/de7d3fe57b6cb3d5f4c5c4d4b84e060f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P_FqqPhxT6tkrk4Qgt8NRQ.png"/></div></div></figure><p id="f292" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，预热功能的等待时间缩短至约3秒:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/16e3f28f1be0e8e3fe916933bd10217e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p7kY7fivCYvyt2GoPYMGdA.png"/></div></div></figure><p id="f3c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样！希望你觉得这篇文章有用，这篇文章的源代码可以在我的<a class="ae ky" href="https://github.com/yai333/ConversationalAIChatbot" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> GitHub repo </strong> </a>中找到。</p></div></div>    
</body>
</html>