<html>
<head>
<title>Pneumonia Detection using deep learning and swagger.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用深度学习和 swagger 的肺炎检测。</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/pneumonia-detection-using-deep-learning-and-swagger-18aa5e8af576?source=collection_archive---------34-----------------------#2020-07-16">https://towardsdatascience.com/pneumonia-detection-using-deep-learning-and-swagger-18aa5e8af576?source=collection_archive---------34-----------------------#2020-07-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="c702" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">深度学习| Swagger API</h2><div class=""/><div class=""><h2 id="0307" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">在这个故事中，我们将通过使用深度学习检测肺炎的步骤，并使用 swagger 部署模型。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/0ec69fe1c757dc1946135eb012730ee0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WXCRC0JtmwSVgC2aM8tFcg.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">来自<a class="ae lh" href="https://burst.shopify.com/medical?utm_campaign=photo_credit&amp;amp;utm_content=High+Res+Doctor%27s+Office+Flatlay+Picture+%E2%80%94+Free+Images&amp;amp;utm_medium=referral&amp;amp;utm_source=credit" rel="noopener ugc nofollow" target="_blank">突发</a>的莎拉<a class="ae lh" href="https://burst.shopify.com/@sarahpflugphoto?utm_campaign=photo_credit&amp;amp;utm_content=High+Res+Doctor%27s+Office+Flatlay+Picture+%E2%80%94+Free+Images&amp;amp;utm_medium=referral&amp;amp;utm_source=credit" rel="noopener ugc nofollow" target="_blank">普夫卢格</a>的照片</p></figure><p id="987e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在本文中，我们将借助胸部 X 射线进行肺炎检测。此外，我们还将使用 swagger API 为它添加一个 GUI。这里需要注意的重要一点是，创建 GUI 所需的时间将会大大减少。由于本文有两个主要部分，我们将讨论深度学习在肺炎检测中的使用，然后使用 swagger 创建一个快速前端。</p><h1 id="5336" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated"><strong class="ak">深度学习在肺炎检测中的应用:</strong></h1><p id="05f8" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">在任何深度学习用例中，可以开始的第一个术语是数据。在这次检测中，我们将使用正常和肺炎胸部 x 光片的数据集<a class="ae lh" href="https://www.kaggle.com/paultimothymooney/chest-xray-pneumonia" rel="noopener ugc nofollow" target="_blank">这里</a>。数据集包含训练、测试和验证三个目录。这三个子目录中的子目录是:normal 和 pneumonia，其中包含用于训练、测试和验证模型的图像。我们总共有 5856 张图片。理解了数据集之后，现在让我们进入训练部分。首先，我们将导入所有有用的库</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="656b" class="ng mf it nc b gy nh ni l nj nk"><strong class="nc jd">import os<br/>import pandas as pd<br/>import numpy as np</strong></span><span id="1aa6" class="ng mf it nc b gy nl ni l nj nk"><strong class="nc jd">from</strong> <strong class="nc jd">keras.layers</strong> <strong class="nc jd">import</strong> Input, Lambda, Dense, Flatten<br/><strong class="nc jd">from</strong> <strong class="nc jd">keras.models</strong> <strong class="nc jd">import</strong> Model<br/><strong class="nc jd">from</strong> <strong class="nc jd">keras.applications.vgg16</strong> <strong class="nc jd">import</strong> VGG16<br/><strong class="nc jd">from</strong> <strong class="nc jd">keras.applications.vgg16</strong> <strong class="nc jd">import</strong> preprocess_input<br/><strong class="nc jd">from</strong> <strong class="nc jd">keras.preprocessing</strong> <strong class="nc jd">import</strong> image<br/><strong class="nc jd">from</strong> <strong class="nc jd">keras.preprocessing.image</strong> <strong class="nc jd">import</strong> ImageDataGenerator<br/><strong class="nc jd">from</strong> <strong class="nc jd">keras.models</strong> <strong class="nc jd">import</strong> Sequential<br/><strong class="nc jd">from</strong> <strong class="nc jd">glob</strong> <strong class="nc jd">import</strong> glob<br/><strong class="nc jd">import</strong> <strong class="nc jd">matplotlib.pyplot</strong> <strong class="nc jd">as</strong> <strong class="nc jd">plt</strong></span></pre><p id="15db" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在上面的代码片段中，我们导入了像 NumPy 这样的库，用于数组处理，pandas，用于数据帧创建和操作，OS，用于路径和目录相关的操作。当我们在代码中使用它时，其他目录将被讨论。</p><p id="67dd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这个问题中，我们将保持所有图像的大小相同。因此，调整所有图像的大小。</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="fe3c" class="ng mf it nc b gy nh ni l nj nk">IMAGE_SIZE = [224, 224]</span></pre><p id="c332" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们将在变量中声明训练和测试路径。之后，在我们的例子中，我们使用迁移学习技术，如 VGG16，以获得更好的准确性。为此，我们必须导入 VGG16 模型。</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="5a4e" class="ng mf it nc b gy nh ni l nj nk">vgg = VGG16(input_shape=IMAGE_SIZE + [3], weights='imagenet', include_top=<strong class="nc jd">False</strong>)</span></pre><p id="c0c4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">由于有三个 RGB 通道，输入形状参数为正 3。权重取自 imagenet 竞赛。此外，include_top 保持为 False，因为我们只需要在两个类之间进行分类。<br/>为了不重新训练预训练层，我们必须将所有可训练层设为假。</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="a813" class="ng mf it nc b gy nh ni l nj nk"><strong class="nc jd">for</strong> layer <strong class="nc jd">in</strong> vgg.layers:<br/>  layer.trainable = <strong class="nc jd">False</strong></span></pre><p id="23e6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了获得列表中 train 文件夹路径下的所有类别，我们使用了一个 glob 方法。</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="dbb4" class="ng mf it nc b gy nh ni l nj nk">folders = glob('/chest-xray-pneumonia/chest_xray/chest_xray/train/*')</span></pre><p id="606b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">通过将 include_top 保持为 False，我们没有指定模型中的最后一层。在这里，我们将添加我们定制的最后一层。</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="e9ea" class="ng mf it nc b gy nh ni l nj nk"><br/>x = Flatten()(vgg.output)<em class="nm">#this removes the last layers</em><br/>prediction = Dense(len(folders), activation='softmax')(x)</span></pre><p id="003f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在预测中，当添加一个密集层时，我们传递了参数 len(folders ),它表示正常和肺炎这两个类别。所以，len(文件夹)是两个。指定最后一层后，我们现在将创建一个对象模型。其具有标准的 VGG 输入(我们在上面已经定义)和作为输出的预测。</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="4d7f" class="ng mf it nc b gy nh ni l nj nk">model = Model(inputs=vgg.input, outputs=prediction)</span></pre><p id="5afd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在我们将编译已定义的模型对象。</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="71ee" class="ng mf it nc b gy nh ni l nj nk">model.compile(<br/>  loss='categorical_crossentropy',<br/>  optimizer='adam',<br/>  metrics=['accuracy']<br/>)</span></pre><p id="0703" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在编译之后，加载带有一些预处理和图像增强的数据集，以便我们的模型获得更多可以学习的图像。我们使用图像数据生成器。这有助于通过对给定图像执行水平翻转、剪切和缩放来重新缩放图像并生成更多图像。</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="c545" class="ng mf it nc b gy nh ni l nj nk"><strong class="nc jd">from</strong> <strong class="nc jd">keras.preprocessing.image</strong> <strong class="nc jd">import</strong> ImageDataGenerator<br/>#for test data</span><span id="1638" class="ng mf it nc b gy nl ni l nj nk">test_datagen = ImageDataGenerator(rescale = 1./255)</span><span id="9def" class="ng mf it nc b gy nl ni l nj nk">#For train data</span><span id="f55f" class="ng mf it nc b gy nl ni l nj nk">train_datagen = ImageDataGenerator(rescale = 1./255,<br/>                                   shear_range = 0.2,<br/>                                   zoom_range = 0.2,<br/>                                   horizontal_flip = <strong class="nc jd">True</strong>)</span></pre><p id="6aca" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，我们将创建一个训练集，用于模型训练。这个目标是通过使用来自目录函数的流来实现的。</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="2d56" class="ng mf it nc b gy nh ni l nj nk">training_set = train_datagen.flow_from_directory('/chest-xray-pneumonia/chest_xray/chest_xray/train', <br/>target_size = (224, 224),<br/>batch_size = 32, <br/>class_mode = 'categorical')</span><span id="feb6" class="ng mf it nc b gy nl ni l nj nk"># for test data</span><span id="1dc8" class="ng mf it nc b gy nl ni l nj nk">test_set = test_datagen.flow_from_directory('/chest-xray-pneumonia/chest_xray/chest_xray/test',                                             target_size = (224, 224),                                             batch_size = 32,                                             class_mode = 'categorical')</span></pre><p id="3110" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，我们将用 5 个历元训练模型，如果你愿意，你也可以增加历元。</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="41bc" class="ng mf it nc b gy nh ni l nj nk">r = model.fit_generator(<br/>  training_set,<br/>  validation_data=test_set,<br/>  epochs=5,<br/>  steps_per_epoch=len(training_set),<br/>  validation_steps=len(test_set)<br/>)</span></pre><p id="7bbd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在成功训练了五个时期的模型后，它给出了大约 95%的验证准确度，这在任何情况下都足够好了。之后，我们将把模型保存在“h5”表单中。</p><h1 id="e5bc" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated"><strong class="ak">通过 swagger 部署保存的模型</strong></h1><p id="3ca6" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">这一部分展示了我们如何快速制作前端来演示我们的模型输出。这将需要不到 10 分钟的时间来执行。这将在另一个名为 app.py 的文件中完成</p><p id="b64d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">首先，导入所需的库，如 Flask、flassger 和 swagger</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="2f55" class="ng mf it nc b gy nh ni l nj nk">from flask import Flask<br/>import flasgger<br/>from flasgger import Swagger</span></pre><p id="b75a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">之后，我们将加载保存的“h5 模型”。</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="18fc" class="ng mf it nc b gy nh ni l nj nk"><br/>from keras.models import load_model<br/>from keras.preprocessing import image<br/>from keras.applications.vgg16 import preprocess_input<br/>import numpy as np<br/><br/>MODEL_PATH="model_vgg19.h5"<br/>model = load_model(MODEL_PATH)<br/>model._make_predict_function()</span></pre><p id="da89" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这之后，创建了一个简单的 flask 应用程序，其中 swagger API 用于创建一个易于使用的前端页面。flask 应用程序有两个函数 welcome，当我们点击本地主机链接时会被重定向到这两个函数。另一个功能是 predict_note_file，通过将“/predict_file”添加到本地主机链接来显示在浏览器中。<br/>以下代码描述了 flassger 附带的 flask app 功能。</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="9930" class="ng mf it nc b gy nh ni l nj nk">from flask import Flask, request<br/>import flasgger<br/>from flasgger import Swagger</span><span id="7e2a" class="ng mf it nc b gy nl ni l nj nk">app=Flask(__name__)<br/>Swagger(app)</span><span id="fb44" class="ng mf it nc b gy nl ni l nj nk"><a class="ae lh" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route('/')<br/>def welcome():<br/>    return "Welcome All"</span><span id="990d" class="ng mf it nc b gy nl ni l nj nk"><a class="ae lh" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route('/predict_file',methods=["POST"])<br/>def predict_note_file():<br/>    """Let's Predict Pneumonia<br/>    This is using docstrings for specifications.<br/>    ---<br/>    parameters:<br/>      - name: file<br/>        in: formData<br/>        type: file<br/>        required: true<br/>      <br/>    responses:<br/>        200:<br/>            description: The output values<br/>        <br/>    """<br/>    img = image.load_img(request.files.get("file"),target_size=(224, 224))<br/>    x = image.img_to_array(img)<br/>    x = np.expand_dims(x, axis=0)<br/>    img_data = preprocess_input(x)<br/>    classes = model.predict(img_data)<br/>    A = np.squeeze(np.asarray(classes))<br/>    if(A[1]==1):<br/>        return "PNEUMONIA"<br/>    else:<br/>        return "NORMAL"<br/>    <br/>if __name__=='__main__':<br/>    app.run()</span></pre><p id="9e79" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在函数 predict_note_file 中，图像数据以 post 方法的形式传输。docstring 包含属性、参数和响应。docstring 中描述的参数被合并到使用 swagger API 生成的页面中。此外，要激活 swagger API，我们必须将“/apidocs”添加到本地主机链接的末尾。当你观看下面的输出演示视频时，你会更加清楚。获得图像后，我们对其进行预处理，使其与我们的模型输入形式兼容，并相应地预测输出。<br/>此图描述了在 swagger API 和其他相关分类器的帮助下进行肺炎检测的逐步过程。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/aad2be348860065cdfa1ec2936c14bc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:626/format:webp/1*7bqP2-ZKPePghapPgIlhtg.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">整个系统流程图。</p></figure><p id="9993" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">输出:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi no"><img src="../Images/ac27df5c166c4f8841169a19ac7c9158.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*bcFFAa3nIPv-aXNv.gif"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">输出演示</p></figure><h1 id="adf1" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated"><strong class="ak">结论</strong></h1><p id="4425" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">在本文中，我们看到了如何用一个非常简单的前端 UI 实现肺炎检测，而不需要前端做太多工作。这个 flassger 代码可以被视为一个模板，您可以在这个前端的帮助下轻松部署任何机器学习模型。这对没有任何 web 开发知识的人很有帮助。此外，这也有助于他们轻松地在各种数据上测试他们的模型。因此，本文指出了肺炎检测背后的深度学习技术，并使用 swagger API 来可视化本地服务器上模型的工作。</p><p id="821e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你有任何疑问，那么你可以 ping 我这里的。</p><p id="c117" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于所有的源代码，你可以访问<a class="ae lh" href="https://github.com/Devarsh23/Pneumonia-detection-Using-Chest-X-ray-End-to-End-deployment" rel="noopener ugc nofollow" target="_blank">这里</a>。</p></div></div>    
</body>
</html>