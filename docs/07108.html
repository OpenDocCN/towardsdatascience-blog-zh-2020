<html>
<head>
<title>Dig deep enough</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">挖得足够深</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/dig-deep-enough-features-engineering-techniques-for-time-series-analysis-in-python-500c96aebade?source=collection_archive---------39-----------------------#2020-05-31">https://towardsdatascience.com/dig-deep-enough-features-engineering-techniques-for-time-series-analysis-in-python-500c96aebade?source=collection_archive---------39-----------------------#2020-05-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2ea3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">以Python中时间序列分析的工程技术为特色。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6ea9caa03b484c947f9090ce71f4d036.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KmN00-kkTMXZa6kWm2L84A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/s/photos/digging?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@dragos126?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Dragos Gontariu </a>拍摄</p></figure><p id="7986" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们开始挖掘数据之前，对时间序列有一个概念是非常重要的。<br/>基本上，一个时间序列是一个按连续顺序排列的数据点的<strong class="lb iu">序列，在大多数情况下，时间序列是一个变量在<strong class="lb iu">不同时间</strong>取值的一组观察值。</strong></p><p id="3b3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将重点介绍一些特性工程的基本技术，这些技术可以随着时间的推移增强您的预测。很久没有在时间序列项目中合作了，所以我决定快速更新一下我用来提高预测的技术，并与大家分享。</p><h1 id="affb" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">特征工程</h1><p id="1fb5" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">特征工程是使用领域知识来创建相关特征的过程，以便使您的机器学习算法更加准确。特征工程可以显著影响您的建模过程的性能，如果它做得正确，它可以帮助您的模型执行得非常好。</p><p id="7cdd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在进行这一步之前，您需要遵循解决数据科学问题的基本流程，即:</p><ul class=""><li id="bff9" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">明确你的目标；</li><li id="5fdc" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">提取数据；</li><li id="564c" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">清洗数据；</li><li id="69a7" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">探索数据和发现洞察力(探索性数据分析)；</li><li id="309f" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><strong class="lb iu">特色工程；</strong></li><li id="822e" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">定义你的模型；</li><li id="7504" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">训练和调整您的模型；</li><li id="7675" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">部署模型。</li></ul><p id="7333" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">特征工程是区分好模型和坏模型的重要步骤。在接下来的章节中，我们将讨论这些技术在时间序列分析中的应用。</p><p id="306a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们假设我们需要预测某个区域的能源消耗，那么我们得到了这个数据:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/fb619a67a0398b7f8f264033e7165beb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BodPq8WlDZhVDPgjoWILlQ.png"/></div></div></figure><p id="5443" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据是不言自明的，它是一个单变量时间序列，我们有一些重复的模式，我们有两列日期和值，日期列被视为一个对象，因此我们需要将其转换为一个<em class="nh">日期时间</em>类型<em class="nh">，</em>这可以使用Pandas轻松完成:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="f817" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们的数据已经准备好了，让我们看看我们可以从这些变量中挖掘的东西，正如我所说的，数据集包含两列，一个与值相关联的日期，所以让我们讨论一些用于设计这类问题的技术。</p><h1 id="f8f5" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">日期相关功能</h1><p id="e62b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">日期相关要素是一种特殊类型的分类变量，日期仅提供时间线上的特定点。如果我们有一些领域的知识或者对问题有深刻的理解，约会是可以被恰当地安排的。<br/>既然我们想预测能源消耗，我们来问一些问题...</p><ul class=""><li id="aebc" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">日期/时间和消费有关系吗？</li><li id="a775" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">数据中是否至少有一个趋势？</li></ul><p id="685f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要回答第一个问题，如果我们的数据与一些个人使用有关，例如，我们知道晚上的能源使用量比白天低；因此，我们可以得出结论，如果我们从日期中提取小时，可能会有一些隐藏的模式，这也回答了第二个问题，因为我们知道在我们的数据中有一个重复的趋势。</p><p id="f83e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提取周末和工作日有助于了解一周中是否有任何变化模式，而月/年也是一种非常有用的方法来查看季节是否有变化。</p><p id="99af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用Python提取这些特征非常简单:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="baf1" class="np lw it nl b gy nq nr l ns nt">data['year']=data['Datetime'].dt.year <br/>data['month']=data['Datetime'].dt.month <br/>data['day']=data['Datetime'].dt.day<br/>data['dayofweek']=data['Datetime'].dt.dayofweek  <br/>data['dayofweek_name']=data['Datetime'].dt.day_name()<br/>data.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/47f5dd3c16e139432d59c546b4aba249.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BcRlZtThoCXi6x0JpZUXcQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">从日期变量中提取的特征</p></figure><p id="1ca5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以提取更多信息，例如:</p><ul class=""><li id="dcec" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">四分之一</li><li id="03ce" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">学期</li><li id="0758" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">是一个月的开始</li><li id="73bf" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">是一年的开始</li><li id="c542" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">是月末</li><li id="fa49" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">是年末</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一些日期提取的代码</p></figure><h1 id="cebc" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">基于时间的特征</h1><p id="fa0f" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">同样，我们可以使用日期的时间戳部分提取更多的特征，例如，我们可以提取小时、分钟甚至秒，因为日期是每小时的，所以我们在这里可以提取的唯一特征是小时。</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="d75b" class="np lw it nl b gy nq nr l ns nt">data['Hour'] = data['Datetime'].dt.hour </span></pre><p id="3c77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用日期列生成很多特性，如果你想探索更多关于基于日期/时间的特性，这里有文档<a class="ae ky" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DatetimeIndex.html#pandas.DatetimeIndex" rel="noopener ugc nofollow" target="_blank">链接</a>。</p><h1 id="466d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">滞后特征</h1><p id="29b2" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">滞后特征基本上是目标变量，但随着一段时间而变化，它用于了解我们的目标值在过去的行为，可能是前一天，一周或一个月。</p><blockquote class="nv nw nx"><p id="72c8" class="kz la nh lb b lc ld ju le lf lg jx lh ny lj lk ll nz ln lo lp oa lr ls lt lu im bi translated">使用滞后特性有时可能是一把双刃剑，因为使用目标变量<strong class="lb iu">非常棘手，如果使用不当，有时会导致过度拟合</strong>。</p></blockquote><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="9084" class="np lw it nl b gy nq nr l ns nt">data["Lag1"] = data['AEP_MW'].shift(3) # Lag with 3 hours<br/>data["Lag5"] = data['AEP_MW'].shift(5) # Lag with 5 hours<br/>data["Lag8"] = data['AEP_MW'].shift(8) # Lag with 8 hours</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/851b8cf1200b4b81bf49c50eefa84c79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_-VFT0hXBcbc1WVS9uJrdA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">滞后特征</p></figure><h1 id="c53e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">滚动窗口功能</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/e1547f00d8945561ec8d620516cc388c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*C6xJFOY0M9WPNfl1.jpg"/></div></figure><p id="fd46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">滚动窗口功能正在根据过去的值计算一些统计数据:</p><ul class=""><li id="d966" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated"><strong class="lb iu">预测点:</strong>进行预测的时间点；</li><li id="ca23" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><strong class="lb iu">特征推导窗口(FDW): </strong>滚动窗口，相对于预测点；</li><li id="6ad2" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><strong class="lb iu">预测窗口(FW): </strong>我们希望预测的未来值的范围，称为预测距离(FDs)。</li></ul><p id="1918" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用这行代码来实现:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="23e9" class="np lw it nl b gy nq nr l ns nt">data['rollingMean'] = data['AEP_MW'].rolling(window=6).mean()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/82ca136c8ac9edd23ea9c4b94ca38472.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/1*0eZiBKMBHOx-e0fo7K4u4g.png"/></div></figure><p id="4421" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，我们可以生成许多不同的时间序列特征，这些特征可用于预测不同的预测距离:</p><ul class=""><li id="8187" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Moving_average" rel="noopener ugc nofollow" target="_blank">滚动平均值</a>，最小值，最大值，...统计数字</li><li id="5c72" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Bollinger_Bands" rel="noopener ugc nofollow" target="_blank">布林线</a>和统计</li><li id="3bce" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">分类特征的滚动熵或滚动多数</li></ul><h1 id="d0d6" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">扩展窗口统计</h1><p id="bc0f" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">另一种类型的窗口，包括<strong class="lb iu">系列中所有先前的</strong>数据。</p><p id="5d1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可以通过使用<em class="nh"> expanding() </em>函数在Python中轻松实现:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="78cd" class="np lw it nl b gy nq nr l ns nt">data['ExpandingMean'] = data['AEP_MW'].expanding(6).mean()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/46fa146b5a16d723df0f2baf64cbd8a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XygPYl36NXX10NPgrd9Z0Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">滚动平均值与膨胀平均值</p></figure><p id="fa92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们对问题有了很好的理解时，所有这些特性都是有用的，这将引导我们做出有意义的见解，并避免<a class="ae ky" href="https://en.wikipedia.org/wiki/Feature_engineering#Feature_explosion" rel="noopener ugc nofollow" target="_blank">特性爆炸</a>。</p><p id="d92d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于非时间序列数据，还有一些其他有用的特征工程技术，我想和你们分享一下。</p><h1 id="0dbf" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">交互功能</h1><p id="58b0" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">还有一些其他类型的特征工程，涉及揭示特征之间的相互作用，一些特征可以组合起来提取一条特定的信息，所以基本上，我们可以对两个变量进行求和、相乘、求差或求商。</p><blockquote class="nv nw nx"><p id="fe65" class="kz la nh lb b lc ld ju le lf lg jx lh ny lj lk ll nz ln lo lp oa lr ls lt lu im bi translated">一个通用的技巧是查看每一对特征并问自己，“我能以任何可能更有用的方式组合这些信息吗？”</p></blockquote><ul class=""><li id="2508" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated"><strong class="lb iu">T0变量的总和:</strong>假设我们有两个变量，<code class="fe of og oh nl b">selling_food_amount</code>和<code class="fe of og oh nl b">selling_gadgets_amount</code>，如果我们只关心费用的总额，我们可以对它们求和。</li><li id="96ae" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><strong class="lb iu">两个特征的区别:</strong>假设我们有两个特征<code class="fe of og oh nl b">expiration_date</code>和<code class="fe of og oh nl b">manufacturing_date</code>，我们可以创建一个新特征，名为<code class="fe of og oh nl b">product_validity</code>。</li><li id="a713" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><strong class="lb iu">两个特征的乘积:</strong>我们有一个在某个区域定义最佳房屋的问题，我们有这两个特征<br/> <code class="fe of og oh nl b">number_of_houses</code>:该区域10公里内的房屋数量，<code class="fe of og oh nl b">median_houses</code>:这些房屋的平均质量分数，<br/>重要的是，有许多房屋选择，但前提是它们足够好。为了创建这种交互，我们可以在这两个变量之间创建一个简单的乘积:<code class="fe of og oh nl b">house_score</code> = <code class="fe of og oh nl b">number_of_houses</code> <strong class="lb iu"> x </strong> <code class="fe of og oh nl b">median_houses</code>。</li><li id="4f63" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><strong class="lb iu">两个特征的商:</strong>以疫情冠状病毒为例，我们可以通过<code class="fe of og oh nl b">mortality_rate</code> = <code class="fe of og oh nl b">numberOfDeaths</code> / <code class="fe of og oh nl b">numberOfCases</code>生成死亡率特征。</li></ul><h1 id="8f3e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="dd2c" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">特征工程将你的输入转化为算法可以理解的东西。</p><p id="2229" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">生成太多的特征会混淆你的模型并降低性能，我们应该总是选择最有贡献的特征，并删除未使用的和多余的特征，最重要的是不要使用你的目标变量作为指标(这包括非常接近的滞后特征)，这可能会给你非常误导的结果。</p><p id="7a1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那都是乡亲们！顺便说一下，这是我的第一篇文章，希望你喜欢。</p><p id="f5a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">别忘了..相信数据，不要相信观点。</p><p id="40ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据来源:<a class="ae ky" href="https://www.kaggle.com/robikscube/hourly-energy-consumption" rel="noopener ugc nofollow" target="_blank">https://www.kaggle.com/robikscube/hourly-energy-consumption</a></p><p id="ff4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">其他来源:</strong></p><ul class=""><li id="cd77" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">Alice Zheng &amp; Amanda Casari，机器学习的特征工程<br/>，数据科学家的原理与技术<em class="nh"/>(2018)，<a class="ae ky" href="http://oreilly.com/catalog/errata.csp?isbn=9781491953242" rel="noopener ugc nofollow" target="_blank"/></li><li id="4a46" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">查普曼&amp;霍尔/CRC，机器学习和数据分析的特征工程(2018)，<a class="ae ky" href="https://www.crcpress.com/Chapman--HallCRC-Data-Mining-and-Knowledge-Discovery-Series/book-series/CHDAMINODIS" rel="noopener ugc nofollow" target="_blank">https://www.crcpress.com/Chapman-霍尔CRC数据挖掘和知识发现系列/图书系列</a></li></ul></div></div>    
</body>
</html>