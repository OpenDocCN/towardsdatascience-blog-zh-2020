<html>
<head>
<title>Graph Query Searches (Part 3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">图形查询搜索(第 3 部分)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/graph-query-searches-part-3-a8bff845c3f1?source=collection_archive---------53-----------------------#2020-06-02">https://towardsdatascience.com/graph-query-searches-part-3-a8bff845c3f1?source=collection_archive---------53-----------------------#2020-06-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0d3a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用 TigerGragh 云编写 GSQL 查询</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f9f25303265efd59b54a8b9d40c6cad7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*86F8G_NMameuzKNuGQThvQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@andrewtneel?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">安德鲁·尼尔</a>在<a class="ae ky" href="https://unsplash.com/s/photos/search?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><h1 id="7f8f" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">议程</h1><ol class=""><li id="8ead" class="lr ls it lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">在图表中建模发布数据</li><li id="e3d0" class="lr ls it lt b lu mj lw mk ly ml ma mm mc mn me mf mg mh mi bi translated">什么是图形查询</li><li id="ff4e" class="lr ls it lt b lu mj lw mk ly ml ma mm mc mn me mf mg mh mi bi translated">编写图形查询</li><li id="2b27" class="lr ls it lt b lu mj lw mk ly ml ma mm mc mn me mf mg mh mi bi translated">结论</li></ol><h1 id="7310" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">1.在图表中建模发布数据</h1><p id="a978" class="pw-post-body-paragraph mo mp it lt b lu lv ju mq lw lx jx mr ly ms mt mu ma mv mw mx mc my mz na me im bi translated">这是探索数据提取和建模系列文章的第 3 部分。如果到目前为止您已经了解了这个系列，欢迎回来！。如果你是新来的，我会简单介绍一下我们到目前为止所做的工作。在<a class="ae ky" rel="noopener" target="_blank" href="/using-scispacy-for-named-entity-recognition-785389e7918d">第一部分</a>中，我们探索了在与新冠肺炎相关的生物医学文献上使用自然语言处理和实体抽取。在第 2 部分的<a class="ae ky" rel="noopener" target="_blank" href="/linking-documents-in-a-semantic-graph-732ab511a01e">中，我们学习了如何使用 TigerGraph Cloud 获取数据并建模。查看这些文章，深入了解我们到目前为止所做的一切。</a></p><p id="0fff" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">现在，在第 3 部分中，我们将研究如何编写图形搜索查询来轻松分析图形中的数据。你需要一个完整的图形来编写查询。你可以按照<a class="ae ky" rel="noopener" target="_blank" href="/linking-documents-in-a-semantic-graph-732ab511a01e">第二部分</a>中的步骤从头创建一个图，或者你可以将我们创建的图导入到 TigerGraph Cloud 中。该图表以及我们使用的所有数据可以在<a class="ae ky" href="https://gofile.io/d/fyijVS" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="63e4" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">为了导入图表，按照这些步骤创建一个空白溶液<a class="ae ky" href="https://www.youtube.com/watch?v=JARd9ULRP_I" rel="noopener ugc nofollow" target="_blank">。在您的解决方案主页上，单击<strong class="lt iu">导入现有解决方案</strong>。</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/742ac71ab9b6eebcac42969d037199f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hKDBXINukFzWeLDArnfuRA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在主页上导入解决方案</p></figure><p id="7d06" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">不幸的是，您仍然需要手动映射和加载数据。但是，在议程项目 4 和 5 下的第 2 部分<a class="ae ky" rel="noopener" target="_blank" href="/linking-documents-in-a-semantic-graph-732ab511a01e">中，我将带您了解如何做到这一点。</a></p><h1 id="dbc5" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">2.什么是图查询？</h1><p id="07f4" class="pw-post-body-paragraph mo mp it lt b lu lv ju mq lw lx jx mr ly ms mt mu ma mv mw mx mc my mz na me im bi translated">在我们开始编写查询之前，我们可能应该了解它们是什么。图形查询本质上是搜索图形并执行某些操作的命令。查询可以用来查找某些顶点或边，进行计算，甚至更新图形。由于图形也有可视化表示，所有这些也可以通过 UI 来完成，如 TigerGraph Cloud 提供的 UI。但是，当处理大量数据或试图创建微调的图形搜索时，使用可视化界面是非常低效的。因此，我们可以编写查询来快速遍历一个图，并提取或插入我们想要的任何数据。</p><h1 id="ef01" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">3.查询结构</h1><p id="6a14" class="pw-post-body-paragraph mo mp it lt b lu lv ju mq lw lx jx mr ly ms mt mu ma mv mw mx mc my mz na me im bi translated">GSQL 提供了许多不同的查询方法。我们将专注于搜索。图搜索的核心是一个叫做<strong class="lt iu"> SELECT </strong>语句的东西。顾名思义，select 语句用于选择一组顶点或边。<strong class="lt iu"> SELECT </strong>语句带有几个参数来缩小搜索范围。</p><p id="3978" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">来自子句的<strong class="lt iu">指定了你选择的边或顶点的类型。</strong></p><p id="a2be" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated"><strong class="lt iu"> WHERE </strong>子句允许您声明顶点或边的特定条件。</p><p id="0bc3" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated"><strong class="lt iu"> ACCUM </strong>和<strong class="lt iu"> POST-ACCUM </strong>子句让您处理<a class="ae ky" href="https://docs.tigergraph.com/dev/gsql-ref/querying/accumulators" rel="noopener ugc nofollow" target="_blank"> <em class="nh">累加器</em> </a>，它们是特殊的 GSQL 变量，在您搜索时收集信息(信息可以是数字、顶点集或边集等。).</p><p id="4e68" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated"><strong class="lt iu">有</strong>子句，类似于<strong class="lt iu"> WHERE </strong>子句，让你提供附加条件；但是，这些将在前面的条款之后应用。</p><p id="df1e" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">通过<strong class="lt iu"> ORDER BY </strong>子句，您可以根据某个属性值对聚集的边或顶点进行排序。</p><p id="d074" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">最后，<strong class="lt iu"> LIMIT </strong>子句限制了搜索结果的数量。</p><p id="8d29" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">您可以在<a class="ae ky" href="https://docs.tigergraph.com/dev/gsql-ref/querying/select-statement#select-statement-data-flow" rel="noopener ugc nofollow" target="_blank"> TigerGraph 文档页面</a>上找到所有这些细节，以及其他参数和查询方法。</p><h1 id="79c7" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">3.编写图形查询</h1><p id="d64a" class="pw-post-body-paragraph mo mp it lt b lu lv ju mq lw lx jx mr ly ms mt mu ma mv mw mx mc my mz na me im bi translated">几乎任何你能想到的对图的搜索都可以用<strong class="lt iu"> SELECT </strong>语句及其相应的子句来处理。为了证明这一事实，让我们练习编写一些查询。</p><p id="32da" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">以下所有的疑问都可以在我的<a class="ae ky" href="https://github.com/akash-kaul/GSQL-Query-Searches.git" rel="noopener ugc nofollow" target="_blank"> GitHub 页面</a>找到。</p><p id="0dfd" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">这些查询按照从最简单到最复杂的顺序排列。</p><h2 id="3167" class="ni la it bd lb nj nk dn lf nl nm dp lj ly nn no ll ma np nq ln mc nr ns lp nt bi translated">具有给定许可证的出版物</h2><p id="acec" class="pw-post-body-paragraph mo mp it lt b lu lv ju mq lw lx jx mr ly ms mt mu ma mv mw mx mc my mz na me im bi translated"><strong class="lt iu">目标:</strong>找到<strong class="lt iu"> </strong>属于给定许可类型的所有出版物。</p><p id="a674" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated"><strong class="lt iu">代码:</strong></p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="eb60" class="ni la it nv b gy nz oa l ob oc">CREATE QUERY LicensePub(String l) FOR GRAPH MyGraph {</span><span id="0995" class="ni la it nv b gy od oa l ob oc">/* Finds all publications with a given license type   <br/>   Sample Inputs: cc0, cc-by, green-oa, cc-by-nc, no-cc  */</span><span id="ab22" class="ni la it nv b gy od oa l ob oc">Seed = {LICENSE.*};</span><span id="2293" class="ni la it nv b gy od oa l ob oc">Pubs = SELECT p</span><span id="b7b6" class="ni la it nv b gy od oa l ob oc">           FROM Seed:s-(PUB_HAS_LICENSE:e)-PUBLICATION:p</span><span id="7236" class="ni la it nv b gy od oa l ob oc">           WHERE s.id == l;</span><span id="3651" class="ni la it nv b gy od oa l ob oc">PRINT Pubs[Pubs.id] AS Publications;<br/>}</span></pre><p id="2b5b" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated"><strong class="lt iu">解释:</strong>我们来分解一下<strong class="lt iu"> </strong>我们的代码在做什么。<strong class="lt iu"> </strong>我们要选择连接到特定许可证顶点的所有发布顶点。因此，我们从所有的<strong class="lt iu">许可证</strong>顶点遍历到所有的<strong class="lt iu">发布</strong>顶点，条件是许可证<strong class="lt iu"> id </strong>是我们指定的(即 cc0、no-cc 等)。).然后，我们只打印我们的结果。在我们的打印声明中有两件事需要注意。</p><ol class=""><li id="48cf" class="lr ls it lt b lu nb lw nc ly oe ma of mc og me mf mg mh mi bi translated">如果我们简单地写<code class="fe oh oi oj nv b">PRINT Pubs</code>，我们的输出将打印出版物及其所有相关数据(标题、摘要等)。因此，为了过滤输出数据，我们可以使用括号指定我们想要的属性。在我们的例子中，我们只通过写<code class="fe oh oi oj nv b">PRINT Pubs[Pubs.id]</code>打印出 id。</li><li id="b1dd" class="lr ls it lt b lu mj lw mk ly ml ma mm mc mn me mf mg mh mi bi translated">将<strong class="lt iu">用作</strong>语句纯粹是装饰性的，它只是改变了打印出的结果列表的名称。这在您提取要在其他上下文中使用的数据时很有用，但对于编写查询来说不是必需的。</li></ol><p id="39a2" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">现在，让我们保存并安装我们的代码。当我们运行它时，我们得到一个类似这样的输入框:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/fd006749717ad0f1408c69d5254b2d24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MUQhRKiFU_Zm4Vf4OpBNVQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">运行许可证查询后的界面</p></figure><p id="7909" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">例如，我输入“cc0”作为许可证代码。当我单击“运行查询”时，我会看到如下所示的图像:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/332301306c1f97cc1c1f7d753f38d6a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*noSM27rqGxgKC_cUusUN9g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">运行许可查询后产生的发布顶点</p></figure><p id="2815" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">这显示了拥有我们指定的许可证的每个发布顶点。但是，这种观点相当混乱。我们可以点击左侧的<strong class="lt iu"> &lt; … &gt; </strong>图标来查看 JSON 输出。JSON 输出应该是这样的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/86c7f08a1bc2dd0cfe3b8c07991696d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-ZgxGCZkAwuMqABfTjBbaA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">许可证查询的 JSON 输出</p></figure><p id="16ee" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">这个看起来干净多了！我们还可以看到打印报表调整的效果。结果列表的名称是“Publications”，打印的唯一顶点属性是 id。</p><p id="dd5a" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">对于下面的查询，我将只显示 JSON 输出。</p><h2 id="f2f1" class="ni la it bd lb nj nk dn lf nl nm dp lj ly nn no ll ma np nq ln mc nr ns lp nt bi translated">大多数出版物的作者</h2><p id="c25f" class="pw-post-body-paragraph mo mp it lt b lu lv ju mq lw lx jx mr ly ms mt mu ma mv mw mx mc my mz na me im bi translated"><strong class="lt iu">目标:</strong>找到发表文章次数最多的作者。</p><p id="a73e" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated"><strong class="lt iu">代码:</strong></p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="b79e" class="ni la it nv b gy nz oa l ob oc">CREATE QUERY AuthorMostPubs() FOR GRAPH MyGraph {</span><span id="fb10" class="ni la it nv b gy od oa l ob oc">/* This query finds the author with the most publications   <br/>Change the limit to see top 'x' authors */</span><span id="63a6" class="ni la it nv b gy od oa l ob oc">SumAccum&lt;INT&gt; @pubNum;</span><span id="121c" class="ni la it nv b gy od oa l ob oc">Seed={AUTHOR.*};</span><span id="6c2e" class="ni la it nv b gy od oa l ob oc">Author = SELECT a</span><span id="e693" class="ni la it nv b gy od oa l ob oc">             FROM Seed:a-()-:t</span><span id="9351" class="ni la it nv b gy od oa l ob oc">             ACCUM a.@pubNum +=1</span><span id="61ef" class="ni la it nv b gy od oa l ob oc">             ORDER BY a.@pubNum DESC</span><span id="c200" class="ni la it nv b gy od oa l ob oc">             LIMIT 1;  <br/> <br/>PRINT Author;<br/>}</span></pre><p id="ab80" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated"><strong class="lt iu">解释:</strong>我们从选择<strong class="lt iu">作者</strong>顶点开始。注意这里的<strong class="lt iu"> SELECT </strong>语句看起来有所不同。这是因为我们没有指定边或目标顶点。因为我们知道<strong class="lt iu">作者</strong>顶点只连接到<strong class="lt iu">出版物</strong>顶点，所以我们可以使用这种“懒惰”语法来避免指定边名和目标顶点。</p><p id="7aa4" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">我们也第一次看到累加器(在这里参考文档<a class="ae ky" href="https://docs.tigergraph.com/dev/gsql-ref/querying/accumulators" rel="noopener ugc nofollow" target="_blank"/>)。在这种情况下，我们使用一个名为 pubNum 的本地累加器。一个局部累加器作为每个顶点的唯一变量，一个<strong class="lt iu"> SumAccum </strong>是一种存储累加和的累加器。</p><p id="00a2" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">那么这个累加器是怎么工作的呢？当我们从每个<strong class="lt iu">作者</strong>顶点遍历到其连接的<strong class="lt iu">出版物</strong>顶点时，我们添加到我们的累加器中。因此，在<strong class="lt iu"> ACCUM </strong>子句中，累加器将连接数(也是发布数)作为变量存储在每个<strong class="lt iu"> AUTHOR </strong>顶点中。</p><p id="f6e1" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">下一步使用的是<strong class="lt iu"> ORDER BY </strong>子句。我们用它来按照累加器值的降序排列结果作者。因此，拥有最多出版物的作者将会在列表的顶端</p><p id="24f9" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">最后，我们使用<strong class="lt iu"> LIMIT </strong>子句将输出限制为 1 个作者(列表中的第一个作者)。</p><p id="7f4d" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">当我们运行该函数时，我们的输出如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/64462602f24ed4fc4b135d0e364a842e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kQ5XUoLYZUJTngpFAvYGMQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者查询的输出</p></figure><p id="792d" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">注意作者<strong class="lt iu"> id </strong>是“南”。这是出版物没有作者时使用的<strong class="lt iu"> id </strong>。所以，我们可以看到 2437 篇文章没有列出作者。这是很好的信息，但不完全是我们想要的。若要查看更多结果，请更改限制。作为一个例子，我将把限制改为 5。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/843a49cd80c742ec51db715186443ceb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7dsENgwM9NrMaNXdJoGSTg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者搜索的 JSON 输出，限制 5</p></figure><p id="7f59" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">现在我们可以看到出版最多的作者有 173 本出版物(哇，太多了！)</p><h2 id="fd84" class="ni la it bd lb nj nk dn lf nl nm dp lj ly nn no ll ma np nq ln mc nr ns lp nt bi translated">出版物最多的期刊</h2><p id="b68d" class="pw-post-body-paragraph mo mp it lt b lu lv ju mq lw lx jx mr ly ms mt mu ma mv mw mx mc my mz na me im bi translated">我们可以运行一个类似于作者搜索的查询，但是要搜索发表文章最多的期刊。</p><p id="14ac" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">目标:找到发表文章最多的期刊</p><p id="417c" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated"><strong class="lt iu">代码:</strong></p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="0a88" class="ni la it nv b gy nz oa l ob oc">CREATE QUERY JournalMostPubs() FOR GRAPH MyGraph {</span><span id="6719" class="ni la it nv b gy od oa l ob oc">/* This query finds the journal with the most publications     Change the limit to find the top 'x' journals  */</span><span id="1658" class="ni la it nv b gy od oa l ob oc">SumAccum&lt;INT&gt; @pubNum;</span><span id="5540" class="ni la it nv b gy od oa l ob oc">Seed = {PUBLICATION.*};</span><span id="a31c" class="ni la it nv b gy od oa l ob oc">Pubs = SELECT t</span><span id="9956" class="ni la it nv b gy od oa l ob oc">           FROM Seed:s-(PUB_HAS_JOURNAL) -:t          <br/>           <br/>           ACCUM t.@pubNum +=1</span><span id="bd16" class="ni la it nv b gy od oa l ob oc">           ORDER BY t.@pubNum DESC</span><span id="993c" class="ni la it nv b gy od oa l ob oc">           LIMIT 1;</span><span id="7c3e" class="ni la it nv b gy od oa l ob oc">PRINT Pubs[Pubs.id, Pubs.@pubNum] AS Most_Published_Journal;<br/>}</span></pre><p id="43d6" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated"><strong class="lt iu">解释:</strong>代码本质上和以前一样，但是我们改为搜索期刊而不是作者。我们还使用前面描述的打印过滤器来使我们的输出更好。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/ff626b3579e47238f280f24b599630aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1LFi9FWWhRlwuHfF_Xq6DA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">日记帐查询的 JSON 输出</p></figure><p id="74c6" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">我们看到有 205 篇出版物的“Arch Virol”是我们搜索的顶级期刊。</p><h2 id="cb6b" class="ni la it bd lb nj nk dn lf nl nm dp lj ly nn no ll ma np nq ln mc nr ns lp nt bi translated">对某一类类型引用最多的出版物</h2><p id="f272" class="pw-post-body-paragraph mo mp it lt b lu lv ju mq lw lx jx mr ly ms mt mu ma mv mw mx mc my mz na me im bi translated"><strong class="lt iu">目标:</strong>给定一个类别类型，找出该类别中医学术语最多的出版物。</p><p id="57bf" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">示例类别类型:DNA、疾病、癌症、有机体、分类单元。</p><p id="be0f" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">完整的名单可以在这里找到<a class="ae ky" href="https://allenai.github.io/scispacy/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="c2e2" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated"><strong class="lt iu">代码:</strong></p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="4e65" class="ni la it nv b gy nz oa l ob oc">CREATE QUERY ClassPub(String c, Int k) FOR GRAPH MyGraph{<br/>/* This query finds the top articles related to a class     <br/>   Sample Input: CANCER, 5 */</span><span id="4e2d" class="ni la it nv b gy od oa l ob oc">SumAccum&lt;INT&gt; @entNum;</span><span id="274b" class="ni la it nv b gy od oa l ob oc">Seed = {CLASS.*};</span><span id="69e1" class="ni la it nv b gy od oa l ob oc">Ents = SELECT e        <br/> <br/>          FROM Seed:s-(ENTITY_HAS_CLASS)-ENTITY:e       <br/>         <br/>          WHERE s.id == c;</span><span id="90fc" class="ni la it nv b gy od oa l ob oc">Pubs = SELECT p</span><span id="ef43" class="ni la it nv b gy od oa l ob oc">           FROM Ents:e -(PUB_HAS_ENTITY)-PUBLICATION:p       <br/>       <br/>           ACCUM p.@entNum += 1</span><span id="d1bb" class="ni la it nv b gy od oa l ob oc">           ORDER BY p.@entNum DESC</span><span id="a2e0" class="ni la it nv b gy od oa l ob oc">           LIMIT k;</span><span id="196b" class="ni la it nv b gy od oa l ob oc">PRINT Pubs[Pubs.id, Pubs.@entNum];<br/> }</span></pre><p id="3381" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">解释:这是我们第一次看到两跳搜索。第一跳选择与给定类别类型相关的所有实体或关键字，第二跳查找包含这些实体的所有出版物，并对它们进行排名。作为一个例子，让我们给我们的查询分类为<strong class="lt iu">癌症</strong>，并选择顶部的<strong class="lt iu"> 5 </strong>。我们的输出看起来像这样。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/6076daef57cfe1af3e03c4e41bcf1be9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kAlvf2iA4WjvY11VMtJcnA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">类搜索的 JSON 输出</p></figure><p id="fb62" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">我们现在可以看到哪些出版物对癌症的引用最多，以及每个出版物的引用数量。</p><h2 id="a152" class="ni la it bd lb nj nk dn lf nl nm dp lj ly nn no ll ma np nq ln mc nr ns lp nt bi translated">类似出版物</h2><p id="9547" class="pw-post-body-paragraph mo mp it lt b lu lv ju mq lw lx jx mr ly ms mt mu ma mv mw mx mc my mz na me im bi translated"><strong class="lt iu">目标:</strong>给定一篇论文，根据它们共享的关键词找到相似的论文。</p><p id="855d" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">我们将使用 Jaccard 相似度来确定两篇论文的相关程度。这种算法本质上是计算两篇论文在关键词总数上的共同关键词数。你可以在这里阅读更多关于算法<a class="ae ky" href="https://en.wikipedia.org/wiki/Jaccard_index" rel="noopener ugc nofollow" target="_blank">的内容。你可以在</a><a class="ae ky" href="https://github.com/tigergraph/gsql-graph-algorithms/blob/master/algorithms/schema-free/jaccard_nbor_ap_json.gsql" rel="noopener ugc nofollow" target="_blank"> TigerGraph GitHub </a>上看到这个公式的一个例子，以及许多其他很酷的图形公式。</p><p id="a85d" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated"><strong class="lt iu">代码:</strong></p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="013e" class="ni la it nv b gy nz oa l ob oc">CREATE QUERY SimilarEnt(STRING doi, INT top) FOR GRAPH MyGraph {</span><span id="52d8" class="ni la it nv b gy od oa l ob oc">/* Use Jaccard Similarity to find top similar articles of a given article based on the key medical terms used   <br/>Sample Input: 10.1186/1471-2164-7-117, 5 */</span><span id="6859" class="ni la it nv b gy od oa l ob oc">SumAccum&lt;INT&gt; @intersection_size, @@set_sizeA, @set_sizeB;</span><span id="481d" class="ni la it nv b gy od oa l ob oc">SumAccum&lt;FLOAT&gt; @similarity;</span><span id="3b24" class="ni la it nv b gy od oa l ob oc">VERTEX check;</span><span id="197f" class="ni la it nv b gy od oa l ob oc">Seed = {PUBLICATION.*};</span><span id="2111" class="ni la it nv b gy od oa l ob oc">Start = SELECT p</span><span id="5251" class="ni la it nv b gy od oa l ob oc">            FROM Seed:p</span><span id="d9c8" class="ni la it nv b gy od oa l ob oc">            WHERE p.id == doi</span><span id="6901" class="ni la it nv b gy od oa l ob oc">            ACCUM check = p,    <br/>                         @@set_sizeA+=p.outdegree("PUB_HAS_ENTITY");</span><span id="a88a" class="ni la it nv b gy od oa l ob oc">Subjects = SELECT t</span><span id="7f5e" class="ni la it nv b gy od oa l ob oc">            FROM Start:s-(PUB_HAS_ENTITY)-:t;</span><span id="664d" class="ni la it nv b gy od oa l ob oc">Others = SELECT t</span><span id="da08" class="ni la it nv b gy od oa l ob oc">            FROM Subjects:s -(PUB_HAS_ENTITY) - :t</span><span id="8b32" class="ni la it nv b gy od oa l ob oc">            WHERE t!= check</span><span id="6dca" class="ni la it nv b gy od oa l ob oc">            ACCUM t.@intersection_size +=1,                  <br/>                  t.@set_sizeB = t.outdegree("PUB_HAS_ENTITY")                            <br/> <br/>            POST-ACCUM t.@similarity = t.@intersection_size  <br/>                       *1.0/(@@set_sizeA+t.@set_sizeB- <br/>                       t.@intersection_size)</span><span id="58c4" class="ni la it nv b gy od oa l ob oc">            ORDER BY t.@similarity DESC</span><span id="f679" class="ni la it nv b gy od oa l ob oc">            LIMIT top;</span><span id="5926" class="ni la it nv b gy od oa l ob oc">PRINT Start[Start.id] AS SOURCE_PUBLICATION;  <br/>PRINT Others[Others.@similarity] AS SIMILAR_PUBLICATIONS;<br/>}</span></pre><p id="f43f" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated"><strong class="lt iu">解释:</strong>我们首先创建 4 个累加器。每一个都代表 Jaccard 公式中使用的一个值。对于我们的第一个<strong class="lt iu"> SELECT </strong>语句，我们选择与输入<strong class="lt iu"> doi </strong>匹配的发布，并将连接到该顶点的所有边收集到一个累加器中。对于第二条语句，我们选择该发布中的所有实体。对于我们的第三个语句，我们找到了具有我们刚刚收集的任意数量的实体的所有出版物，并找到了交集大小(与原始论文相同的实体的数量)。最后，我们计算 Jaccard 索引，并将相似度最高的出版物排在输出列表的顶部。</p><p id="bc2d" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">让我们看一个例子。我用了<strong class="lt iu">doi</strong>= 10.1186/s 40413–016–0096–1 和<strong class="lt iu"> top </strong> =5。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/5742b3995b0d2bcf3a295da952ef1771.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mu1w-Kiwkh3iB1LpjvUmMA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">相似性查询的 JSON 输出</p></figure><p id="71a1" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">我们可以看到我们的起始出版物以及前 5 个类似的出版物，每个出版物都有各自的相似性得分。</p><h1 id="ac2a" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">4.结论</h1><p id="5951" class="pw-post-body-paragraph mo mp it lt b lu lv ju mq lw lx jx mr ly ms mt mu ma mv mw mx mc my mz na me im bi translated">如果你跟随这篇文章，我为你鼓掌！这份材料并不容易，学习一门像 GSQL 这样的新语言可能会很棘手。我希望这个 GSQL 查询的演练对您有所启发。我强烈推荐阅读我的其他论文，以获得我们今天所讨论的所有内容的更好的背景。如果您想了解更多的查询算法和结构，请查阅 GSQL 的<a class="ae ky" href="https://docs.tigergraph.com/" rel="noopener ugc nofollow" target="_blank"> TigerGraph 文档。如果你正在寻找更多的内容，请继续关注！我将很快发布第 4 部分。在这个系列的最后一部分，我将介绍如何使用我们的图形数据库和查询来输出信息，我们可以使用 Plotly </a>的<a class="ae ky" href="https://plotly.com/dash/" rel="noopener ugc nofollow" target="_blank"> UI 平台 Dash 来直观地表示这些信息。这样，如果您遵循了所有 4 个部分，您将完成一个完整的端到端应用程序！</a></p><p id="57d0" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">如果你喜欢这篇文章，一定要看看我的其他文章，并关注我的更多内容！</p><h1 id="87d6" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">资源</h1><ol class=""><li id="2fbd" class="lr ls it lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/using-scispacy-for-named-entity-recognition-785389e7918d">https://towards data science . com/using-scispacy-for-named-entity-recognition-785389 e 7918d</a></li><li id="bf83" class="lr ls it lt b lu mj lw mk ly ml ma mm mc mn me mf mg mh mi bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/linking-documents-in-a-semantic-graph-732ab511a01e">https://towards data science . com/linking-documents-in-a-semantic-graph-732 ab 511 a01e</a></li><li id="06cc" class="lr ls it lt b lu mj lw mk ly ml ma mm mc mn me mf mg mh mi bi translated"><a class="ae ky" href="https://gofile.io/d/fyijVS" rel="noopener ugc nofollow" target="_blank">https://gofile.io/d/fyijVS</a></li><li id="f67b" class="lr ls it lt b lu mj lw mk ly ml ma mm mc mn me mf mg mh mi bi translated"><a class="ae ky" href="https://www.youtube.com/watch?v=JARd9ULRP_I" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=JARd9ULRP_I</a></li><li id="ddbf" class="lr ls it lt b lu mj lw mk ly ml ma mm mc mn me mf mg mh mi bi translated"><a class="ae ky" href="https://docs.tigergraph.com/dev/gsql-ref/querying/accumulators" rel="noopener ugc nofollow" target="_blank">https://docs . tiger graph . com/dev/gsql-ref/query/accumulators</a></li><li id="6e16" class="lr ls it lt b lu mj lw mk ly ml ma mm mc mn me mf mg mh mi bi translated"><a class="ae ky" href="https://docs.tigergraph.com/dev/gsql-ref/querying/select-statement#select-statement-data-flow" rel="noopener ugc nofollow" target="_blank">https://docs . tiger graph . com/dev/gsql-ref/query/select-statement # select-statement-data-flow</a></li><li id="bcca" class="lr ls it lt b lu mj lw mk ly ml ma mm mc mn me mf mg mh mi bi translated"><a class="ae ky" href="https://github.com/akash-kaul/GSQL-Query-Searches.git" rel="noopener ugc nofollow" target="_blank">https://github.com/akash-kaul/GSQL-Query-Searches.git</a></li><li id="ab24" class="lr ls it lt b lu mj lw mk ly ml ma mm mc mn me mf mg mh mi bi translated"><a class="ae ky" href="https://allenai.github.io/scispacy/" rel="noopener ugc nofollow" target="_blank">https://allenai.github.io/scispacy/</a></li><li id="35e8" class="lr ls it lt b lu mj lw mk ly ml ma mm mc mn me mf mg mh mi bi translated"><a class="ae ky" href="https://github.com/tigergraph/gsql-graph-algorithms/blob/master/algorithms/schema-free/jaccard_nbor_ap_json.gsql" rel="noopener ugc nofollow" target="_blank">https://github . com/tiger graph/gsql-graph-algorithms/blob/master/algorithms/schema-free/JAC card _ nbor _ AP _ JSON . gsql</a></li><li id="6d4c" class="lr ls it lt b lu mj lw mk ly ml ma mm mc mn me mf mg mh mi bi translated"><a class="ae ky" href="https://docs.tigergraph.com/" rel="noopener ugc nofollow" target="_blank">https://docs.tigergraph.com/</a></li><li id="4ea4" class="lr ls it lt b lu mj lw mk ly ml ma mm mc mn me mf mg mh mi bi translated"><a class="ae ky" href="https://plotly.com/dash/" rel="noopener ugc nofollow" target="_blank">https://plotly.com/dash/</a></li></ol></div></div>    
</body>
</html>