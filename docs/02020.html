<html>
<head>
<title>Recommendation System in Python: LightFM</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中的推荐系统:LightFM</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/recommendation-system-in-python-lightfm-61c85010ce17?source=collection_archive---------0-----------------------#2020-02-26">https://towardsdatascience.com/recommendation-system-in-python-lightfm-61c85010ce17?source=collection_archive---------0-----------------------#2020-02-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/24c481af85d40f5fc016851b7a74cbc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0HVVNKQt1Qweb9vlJ0wJUw.jpeg"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated"><a class="ae jd" href="https://www.needpix.com/photo/642084/needle-hay-needle-in-a-haystack" rel="noopener ugc nofollow" target="_blank">https://www . needpix . com/photo/642084/needle-hay-大海捞针</a></p></figure><h2 id="c906" class="je jf jg bd b dl jh ji jj jk jl jm dk jn translated" aria-label="kicker paragraph"><a class="ae ep" href="https://medium.com/towards-data-science/in-depth-analysis/home" rel="noopener"> <strong class="ak">深度解析</strong> </a></h2><div class=""/><div class=""><h2 id="ae89" class="pw-subtitle-paragraph km jp jg bd b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dk translated">使用 LightFM 在 Python 中构建推荐系统的分步指南</h2></div><p id="bf2a" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">推荐系统或推荐系统可以被认为是信息过滤系统的一个子类，该信息过滤系统寻求预测用户将给予项目的最佳“评级”或“偏好”,该最佳“评级”或“偏好”通常通过优化诸如总点击、总收入和总销售额之类的目标来获得。</p><blockquote class="ma mb mc"><p id="4799" class="le lf md lg b lh li kq lj lk ll kt lm me lo lp lq mf ls lt lu mg lw lx ly lz ij bi translated">推荐算法工作的基本原理是什么？</p></blockquote><p id="b5b7" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">推荐的基本原则是，以用户为中心的活动和以项目为中心的活动之间存在显著的依赖关系。例如，对纽约市的酒店感兴趣的用户更可能对纽约市的其他酒店感兴趣，而不是波士顿。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="7645" class="mo mp jg bd mq mr ms mt mu mv mw mx my kv mz kw na ky nb kz nc lb nd lc ne nf bi translated">介绍</h1><p id="5efd" class="pw-post-body-paragraph le lf jg lg b lh ng kq lj lk nh kt lm ln ni lp lq lr nj lt lu lv nk lx ly lz ij bi translated">尽管任何推荐系统的主要商业目标是为用户提供个性化的体验；从问题设置的角度来看，我们可以将推荐者大致分为两类:</p><ul class=""><li id="cc6e" class="nl nm jg lg b lh li lk ll ln nn lr no lv np lz nq nr ns nt bi translated"><strong class="lg jq">预测问题:</strong>第一种方法是我们希望预测用户-项目组合的评级值，假设训练数据可用于指示用户对其他项目的偏好。设想 m × n 矩阵，其中 m 是用户数，n 是项目数，目标是预测缺失(或未观察到)的值。</li></ul><figure class="nu nv nw nx gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/0f8350b8fbc6d5d7ca6d224830c42ca1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O4G-aWIB1Ea6dKymtKS3lQ.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated"><a class="ae jd" href="https://www.google.com/url?sa=i&amp;url=https%3A%2F%2Fwww.needpix.com%2Fphoto%2F18235%2Frating-stars-chart-poor-performance-result-statistical-success-symbols&amp;psig=AOvVaw2TxYq_-XgJ5B65nDAszvSr&amp;ust=1582730198563000&amp;source=images&amp;cd=vfe&amp;ved=0CAIQjRxqFwoTCOiLz9D_7OcCFQAAAAAdAAAAABAE" rel="noopener ugc nofollow" target="_blank">图像来源</a></p></figure><ul class=""><li id="9941" class="nl nm jg lg b lh li lk ll ln nn lr no lv np lz nq nr ns nt bi translated"><strong class="lg jq">排名问题:</strong>其他时候，我们希望为特定用户推荐前 k 个项目，或者确定特定主题的前 k 个目标用户。这个问题也被称为 top-k 推荐问题，是推荐问题的排名提法。想想搜索引擎，取决于谁在搜索；您希望显示 top-k 项目，以根据他们过去的偏好和最近的活动提供个性化的结果。</li></ul><figure class="nu nv nw nx gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ny"><img src="../Images/bfdee8beb383d08855ccb19d5cd27a89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tl-Y0ppbZ4O9FqNd1Dmvxg.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated"><a class="ae jd" href="https://www.google.com/url?sa=i&amp;url=https%3A%2F%2Factionml.com%2Fblog%2Fpersonalized_search&amp;psig=AOvVaw125Jk0lya25z8gCv9C4IwX&amp;ust=1582412856268000&amp;source=images&amp;cd=vfe&amp;ved=0CAIQjRxqFwoTCOCA-rXh4-cCFQAAAAAdAAAAABAJ" rel="noopener ugc nofollow" target="_blank">图像来源</a></p></figure><h1 id="3d34" class="mo mp jg bd mq mr nz mt mu mv oa mx my kv ob kw na ky oc kz nc lb od lc ne nf bi translated">推荐建模方法的基础</h1><p id="e74a" class="pw-post-body-paragraph le lf jg lg b lh ng kq lj lk nh kt lm ln ni lp lq lr nj lt lu lv nk lx ly lz ij bi translated">概括地说，大多数推荐系统利用两种类型的数据:</p><ul class=""><li id="a4fc" class="nl nm jg lg b lh li lk ll ln nn lr no lv np lz nq nr ns nt bi translated"><em class="md">交互数据</em>，如评分和浏览行为，以及</li><li id="7ee6" class="nl nm jg lg b lh oe lk of ln og lr oh lv oi lz nq nr ns nt bi translated"><em class="md">归属信息</em>，关于每个用户和物品</li></ul><p id="6062" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">依赖于前者数据的建模方法一般称为<code class="fe oj ok ol om b">Collaborative Filtering</code>方法，使用后者的方法称为<code class="fe oj ok ol om b">Content Base Filtering</code>方法。还有另一类被称为<code class="fe oj ok ol om b">Knowledge-Based</code>的推荐系统，它基于明确指定的用户需求。</p><blockquote class="ma mb mc"><p id="58a9" class="le lf md lg b lh li kq lj lk ll kt lm me lo lp lq mf ls lt lu mg lw lx ly lz ij bi translated">当然，每种方法都有其优点和缺点，这取决于它们用于哪些应用程序以及可用的数据量。</p></blockquote><p id="d7e3" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><code class="fe oj ok ol om b">Hybrid Systems</code>然后用于结合这些方法的优势，在各种应用中拥有一个健壮的执行系统。</p><figure class="nu nv nw nx gt is gh gi paragraph-image"><div class="gh gi on"><img src="../Images/ce8ccb6c352372c3e4131cf2b61acab3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/1*dRlaa2hDetPQYLXsvk9I_A.jpeg"/></div></figure><ul class=""><li id="ee57" class="nl nm jg lg b lh li lk ll ln nn lr no lv np lz nq nr ns nt bi translated"><strong class="lg jq">协作过滤方法:</strong>这些类型的模型使用多个用户提供的评级的协作能力来进行推荐，并且主要依赖于利用项目间相关性或用户间交互来进行预测过程。直觉上，它依赖于一个潜在的概念，即对项目进行相似评级的两个用户很可能对其他项目具有相似的偏好。</li><li id="305d" class="nl nm jg lg b lh oe lk of ln og lr oh lv oi lz nq nr ns nt bi translated">有两种类型的方法常用于协同过滤:</li></ul><blockquote class="ma mb mc"><p id="54a1" class="le lf md lg b lh li kq lj lk ll kt lm me lo lp lq mf ls lt lu mg lw lx ly lz ij bi translated"><strong class="lg jq">基于记忆的</strong>方法也称为基于邻域的协同过滤算法，其中用户-项目组合的评级是基于它们的邻域来预测的。这些邻域可以进一步定义为(1)基于用户，和(2)基于项目</p><p id="8f24" class="le lf md lg b lh li kq lj lk ll kt lm me lo lp lq mf ls lt lu mg lw lx ly lz ij bi translated">在<strong class="lg jq">基于模型的</strong>方法中，ML 技术用于在给定优化框架的上下文中学习模型参数</p></blockquote><ul class=""><li id="5642" class="nl nm jg lg b lh li lk ll ln nn lr no lv np lz nq nr ns nt bi translated"><strong class="lg jq">基于内容的过滤方法:</strong>在这些类型的系统中，使用项目/用户的描述性属性来进行推荐。术语“内容”指的是这些描述。在基于内容的方法中，用户的评级和交互行为与项目中可用的内容信息相结合。</li><li id="e2ef" class="nl nm jg lg b lh oe lk of ln og lr oh lv oi lz nq nr ns nt bi translated"><strong class="lg jq">混合方法:</strong>在许多情况下，有更多种类的输入可用；在这种情况下，存在许多混合的机会，来自不同类型系统的各个方面被结合起来，以实现所有世界的最佳。该方法与传统的集成分析方法相当，在传统的集成分析方法中，多种类型的机器学习算法的能力被组合以创建更鲁棒的模型。</li></ul><p id="c114" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">还有更多不同类型的方法，以及每种方法的细微差别；如果你有兴趣了解更多，我强烈推荐 Deepak Agarwal 的《推荐系统的统计方法》一书。</p><h1 id="376e" class="mo mp jg bd mq mr nz mt mu mv oa mx my kv ob kw na ky oc kz nc lb od lc ne nf bi translated">LightFM 入门</h1><p id="3392" class="pw-post-body-paragraph le lf jg lg b lh ng kq lj lk nh kt lm ln ni lp lq lr nj lt lu lv nk lx ly lz ij bi translated">有许多跨不同语言的开源推荐系统框架和库，可以帮助您开始首次实现推荐模型。</p><p id="3bf5" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">在本文中，我们将探索其中一个我在工作中发现的有价值的算法，并涵盖各种用例的各种底层算法，称为<code class="fe oj ok ol om b">LighFM</code></p><p id="7c10" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">LightFM 是针对隐式和显式反馈类型的几种流行推荐算法的 Python 实现。</p><p id="f1da" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">重要的是，它允许您将项目和用户元数据合并到传统的矩阵分解算法中，从而可以推广到新项目(通过项目功能)和新用户(通过用户功能)。</p><p id="a859" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">要了解更多，你可以查看它的文档<a class="ae jd" href="https://making.lyst.com/lightfm/docs/home.html" rel="noopener ugc nofollow" target="_blank">这里</a>。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="039a" class="mo mp jg bd mq mr ms mt mu mv mw mx my kv mz kw na ky nb kz nc lb nd lc ne nf bi translated">履行</h1><p id="972d" class="pw-post-body-paragraph le lf jg lg b lh ng kq lj lk nh kt lm ln ni lp lq lr nj lt lu lv nk lx ly lz ij bi translated">完整的代码可以在 GitHub 的<a class="ae jd" href="https://github.com/kapadias/mediumposts/blob/master/recommender/published_notebooks/recommendation_python_lightfm.ipynb" rel="noopener ugc nofollow" target="_blank"> Jupyter 笔记本上找到</a></p><ul class=""><li id="391d" class="nl nm jg lg b lh li lk ll ln nn lr no lv np lz nq nr ns nt bi translated"><strong class="lg jq">加载数据</strong></li><li id="d01b" class="nl nm jg lg b lh oe lk of ln og lr oh lv oi lz nq nr ns nt bi translated"><strong class="lg jq">数据检查和准备</strong></li><li id="0460" class="nl nm jg lg b lh oe lk of ln og lr oh lv oi lz nq nr ns nt bi translated"><strong class="lg jq">数据预处理</strong></li><li id="a98c" class="nl nm jg lg b lh oe lk of ln og lr oh lv oi lz nq nr ns nt bi translated"><strong class="lg jq">模特培训</strong></li><li id="0292" class="nl nm jg lg b lh oe lk of ln og lr oh lv oi lz nq nr ns nt bi translated"><strong class="lg jq">前 n 条建议</strong></li></ul><h1 id="e440" class="mo mp jg bd mq mr nz mt mu mv oa mx my kv ob kw na ky oc kz nc lb od lc ne nf bi translated">加载数据</h1><p id="bdfa" class="pw-post-body-paragraph le lf jg lg b lh ng kq lj lk nh kt lm ln ni lp lq lr nj lt lu lv nk lx ly lz ij bi translated">对于本教程，我们将使用 Goodreads 的书评数据。这些数据集是在 2017 年底从 goodreads.com 收集的，从用户的公共书架上收集数据，即每个人都可以在网上看到它，而无需登录。用户 id 和评论 id 是匿名的。</p><figure class="nu nv nw nx gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/2f6a30ba70ae839ae93ae8cbcd822bd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WrLUUm4vbIdumOm_Tv2u9w.png"/></div></div></figure><p id="298c" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">收集该数据集仅用于学术用途。请不要重新分发或用于商业目的。</p><p id="edc3" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">有三组数据集:</p><ul class=""><li id="27f0" class="nl nm jg lg b lh li lk ll ln nn lr no lv np lz nq nr ns nt bi translated">书籍的元数据</li><li id="5ad8" class="nl nm jg lg b lh oe lk of ln og lr oh lv oi lz nq nr ns nt bi translated">用户-图书交互</li><li id="6196" class="nl nm jg lg b lh oe lk of ln og lr oh lv oi lz nq nr ns nt bi translated">用户的详细书评</li></ul><p id="3d3c" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">这些数据集可以通过匹配图书/用户/评论 id 合并在一起。对于本教程，我们将只使用前两个。</p><p id="491b" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">您可以从这里下载本文中使用的数据集:</p><ul class=""><li id="f951" class="nl nm jg lg b lh li lk ll ln nn lr no lv np lz nq nr ns nt bi translated">书籍元数据:<a class="ae jd" href="https://drive.google.com/uc?id=1H6xUV48D5sa2uSF_BusW-IBJ7PCQZTS1" rel="noopener ugc nofollow" target="_blank">https://drive.google.com/uc?id = 1 h6 xuv 48 D5 sa 2 usf _ BusW-ibj 7 pcqzts 1</a></li><li id="f562" class="nl nm jg lg b lh oe lk of ln og lr oh lv oi lz nq nr ns nt bi translated">用户与图书的互动:<a class="ae jd" href="https://drive.google.com/uc?id=17G5_MeSWuhYnD4fGJMvKRSOlBqCCimxJ" rel="noopener ugc nofollow" target="_blank">https://drive.google.com/uc?id = 17 G5 _ mes wuhynd 4 fgjmvkrsolbqccimxj</a></li></ul><pre class="nu nv nw nx gt oo om op bn oq or bi"><span id="fc69" class="os mp jg om b be ot ou l ov ow">%%time<br/>books_metadata = pd.read_json('./data/goodreads_books_poetry.json', lines=True)<br/>interactions = pd.read_json('./data/goodreads_interactions_poetry.json', lines=True)</span></pre><h1 id="3057" class="mo mp jg bd mq mr nz mt mu mv oa mx my kv ob kw na ky oc kz nc lb od lc ne nf bi translated">数据检查和准备</h1><h2 id="755f" class="ox mp jg bd mq oy oz dn mu pa pb dp my ln pc pd na lr pe pf nc lv pg ph ne jm bi translated">书籍元数据</h2><p id="8af3" class="pw-post-body-paragraph le lf jg lg b lh ng kq lj lk nh kt lm ln ni lp lq lr nj lt lu lv nk lx ly lz ij bi translated">让我们从检查书籍的元数据信息开始。为了开发一个可靠和稳健的 ML 模型，有必要对现有数据进行全面的理解。</p><p id="7bd6" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">作为第一步，让我们看看所有可用的字段和示例数据</p><pre class="nu nv nw nx gt oo om op bn oq or bi"><span id="ad7e" class="os mp jg om b be ot ou l ov ow">books_metadata.sample(2)</span></pre><figure class="nu nv nw nx gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pi"><img src="../Images/ae6cc8df56190c787cd345f4828971ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ynf6_Ub29KIOMkfClADwQA.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">书籍元数据(示例)</p></figure><p id="c429" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">虽然所有可用的信息对于提取上下文信息以便能够训练更好的推荐系统是至关重要的，但是对于本例，我们将只关注需要最少操作的选定字段。</p><pre class="nu nv nw nx gt oo om op bn oq or bi"><span id="ff07" class="os mp jg om b be ot ou l ov ow"># Limit the books metadata to selected fields<br/>books_metadata_selected = books_metadata[['book_id', <br/>'average_rating', 'is_ebook', 'num_pages', 'publication_year', <br/>'ratings_count', 'language_code']]<br/>books_metadata_selected.sample(5)</span></pre><figure class="nu nv nw nx gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pj"><img src="../Images/8336584d799acb6cb30d3d38d69ffe78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IFsUTjeDj_qATDOn4MPU2Q.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">过滤的图书元数据(示例)</p></figure><p id="d584" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">现在我们已经有了包含所选字段的数据，接下来，我们将通过 pandas profiler 运行它来执行初步的探索性数据分析，以帮助我们更好地理解可用数据</p><pre class="nu nv nw nx gt oo om op bn oq or bi"><span id="f6c2" class="os mp jg om b be ot ou l ov ow">import pandas_profiling<br/>import numpy as np<br/># replace blank cells with NaN<br/>books_metadata_selected.replace('', np.nan, inplace=True)<br/># not taking book_id into the profiler report<br/>profile = \<br/>pandas_profiling.ProfileReport(books_metadata_selected[['average_rating', <br/>'is_ebook', 'num_pages', 'publication_year', 'ratings_count']])<br/>profile.to_file('./results/profiler_books_metadata_1.html')</span></pre><figure class="nu nv nw nx gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pk"><img src="../Images/8ed5363803b68ffbd5ce4759a644ed6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NGkv6bJqEUfNMl538Gdp1A.png"/></div></div></figure><p id="3a2d" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">考虑到探查器的结果，我们将对数据集执行以下转换:</p><ul class=""><li id="3406" class="nl nm jg lg b lh li lk ll ln nn lr no lv np lz nq nr ns nt bi translated">用另一个值替换分类值中缺少的值，以创建新的类别</li><li id="9cc0" class="nl nm jg lg b lh oe lk of ln og lr oh lv oi lz nq nr ns nt bi translated">将数值变量的 bin 值转换为离散区间</li></ul><pre class="nu nv nw nx gt oo om op bn oq or bi"><span id="3575" class="os mp jg om b be ot ou l ov ow"># using pandas cut method to convert fields into discrete intervals<br/>books_metadata_selected['num_pages'].replace(np.nan, -1, inplace=True)<br/>books_metadata_selected['num_pages'] = pd.to_numeric(books_metadata_selected['num_pages'])<br/>books_metadata_selected['num_pages'] = pd.cut(books_metadata_selected['num_pages'], bins=25)<br/># rounding ratings to neares .5 score<br/>books_metadata_selected['average_rating'] = books_metadata_selected['average_rating'].apply(lambda x: round(x*2)/2)<br/># using pandas qcut method to convert fields into quantile-based discrete intervals<br/>books_metadata_selected['ratings_count'] = pd.qcut(books_metadata_selected['ratings_count'], 25)<br/># replacing missing values to year 2100<br/>books_metadata_selected['publication_year'].replace(np.nan, 2100, inplace=True)<br/># replacing missing values to 'unknown'<br/>books_metadata_selected['language_code'].replace(np.nan, 'unknown', inplace=True)<br/># convert is_ebook column into 1/0 where true=1 and false=0<br/>books_metadata_selected['is_ebook'] = books_metadata_selected.is_ebook.map(<br/>    lambda x: 1.0*(x == 'true'))<br/>profile = pandas_profiling.ProfileReport(books_metadata_selected[['average_rating', 'is_ebook', 'num_pages', <br/>                                                        'publication_year', 'ratings_count']])<br/>profile.to_file('./results/profiler_books_metadata_2.html')</span></pre><figure class="nu nv nw nx gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pk"><img src="../Images/9fd72dd821d97c7a7ba93b8ad5dc2800.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MvvnlalFrV4Qsvjdkkx_XQ.png"/></div></div></figure><h2 id="5b06" class="ox mp jg bd mq oy oz dn mu pa pb dp my ln pc pd na lr pe pf nc lv pg ph ne jm bi translated">交互数据</h2><p id="a1f8" class="pw-post-body-paragraph le lf jg lg b lh ng kq lj lk nh kt lm ln ni lp lq lr nj lt lu lv nk lx ly lz ij bi translated">作为第一步，让我们看看所有可用的字段和示例数据</p><pre class="nu nv nw nx gt oo om op bn oq or bi"><span id="d210" class="os mp jg om b be ot ou l ov ow">interactions.sample(5)</span></pre><figure class="nu nv nw nx gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pl"><img src="../Images/4495c4a62f4737255baa89cc04583bb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tHobvGI2Wrau5eaO6Uyisw.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">交互数据(示例)</p></figure><p id="748a" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">将数据仅限于选定的字段</p><pre class="nu nv nw nx gt oo om op bn oq or bi"><span id="2b52" class="os mp jg om b be ot ou l ov ow"># Limit the books metadata to selected fields<br/>interactions_selected = interactions[['user_id', 'book_id', 'is_read', 'rating']]<br/># mapping boolean to string<br/>booleanDictionary = {True: 'true', False: 'false'}<br/>interactions_selected['is_read'] = interactions_selected['is_read'].replace(booleanDictionary)<br/>profile = pandas_profiling.ProfileReport(interactions_selected[['is_read', 'rating']])<br/>profile.to_file('./results/profiler_interactions.html')</span></pre><figure class="nu nv nw nx gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pm"><img src="../Images/0fb5a678a7ae6efcaf565ac22aabfe29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FSVm9B1B60_mB_6RwMQpsQ.png"/></div></div></figure><p id="6541" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">考虑到分析器的结果，我们将 is_read 列转换为 1/0</p><pre class="nu nv nw nx gt oo om op bn oq or bi"><span id="31d1" class="os mp jg om b be ot ou l ov ow"># convert is_read column into 1/0 where true=1 and false=0<br/>interactions_selected['is_read'] = interactions_selected.is_read.map(<br/>    lambda x: 1.0*(x == 'true'))</span></pre><p id="feb1" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">因为我们有两个字段表示用户和书之间的交互，“is_read”和“rating”——让我们看看我们有多少数据点，用户没有读过这本书，但给出了评级。</p><pre class="nu nv nw nx gt oo om op bn oq or bi"><span id="9c7b" class="os mp jg om b be ot ou l ov ow">interactions_selected.groupby(['rating', 'is_read']).size().reset_index().pivot(columns='rating', index='is_read', values=0)</span></pre><figure class="nu nv nw nx gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pn"><img src="../Images/ea4c62d9fe6b38ae059d2f37f3f27d76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pFfx0dnK1UUEo-Kn_uH9Gw.png"/></div></div></figure><p id="201d" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">从上面的结果，我们可以得出结论，评分&gt; = 1 的用户都读过这本书。因此，我们将使用“评级”作为最终得分，删除“is_read”为假的交互，并限制随机 5000 个用户的交互，以限制进一步分析的数据大小</p><h1 id="dc61" class="mo mp jg bd mq mr nz mt mu mv oa mx my kv ob kw na ky oc kz nc lb od lc ne nf bi translated">数据预处理</h1><p id="7d5c" class="pw-post-body-paragraph le lf jg lg b lh ng kq lj lk nh kt lm ln ni lp lq lr nj lt lu lv nk lx ly lz ij bi translated">现在，让我们将可用的数据转换成可用于矩阵运算的 CSR 稀疏矩阵。我们将通过创建 books_metadata matrix 开始这个过程，它是 NP . float 64 CSR _ matrix of shape([n _ books，n_books_features]) —每一行都包含该书相对于功能的权重。然而，在我们创建一个稀疏矩阵之前，我们将首先创建一个条目字典用于将来的引用</p><pre class="nu nv nw nx gt oo om op bn oq or bi"><span id="cf33" class="os mp jg om b be ot ou l ov ow">item_dict ={}<br/>df = books_metadata[['book_id', 'title']].sort_values('book_id').reset_index()<br/>for i in range(df.shape[0]):<br/>    item_dict[(df.loc[i,'book_id'])] = df.loc[i,'title']<br/># dummify categorical features<br/>books_metadata_selected_transformed = pd.get_dummies(books_metadata_selected, columns = ['average_rating', 'is_ebook', 'num_pages',                          'publication_year', 'ratings_count', 'language_code'])<br/>books_metadata_selected_transformed = books_metadata_selected_transformed.sort_values('book_id').reset_index().drop('index', axis=1)<br/>books_metadata_selected_transformed.head(5)<br/># convert to csr matrix<br/>books_metadata_csr = csr_matrix(books_metadata_selected_transformed.drop('book_id', axis=1).values)</span></pre><p id="6fb8" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">接下来，我们将创建一个迭代矩阵，它是 NP . float 64 CSR _ matrix of shape([n _ users，n_books])。我们还将为未来的用例创建一个用户字典</p><pre class="nu nv nw nx gt oo om op bn oq or bi"><span id="ed45" class="os mp jg om b be ot ou l ov ow">user_book_interaction = pd.pivot_table(interactions_selected, index='user_id', columns='book_id', values='rating')<br/># fill missing values with 0<br/>user_book_interaction = user_book_interaction.fillna(0)<br/>user_id = list(user_book_interaction.index)<br/>user_dict = {}<br/>counter = 0 <br/>for i in user_id:<br/>    user_dict[i] = counter<br/>    counter += 1<br/># convert to csr matrix<br/>user_book_interaction_csr = csr_matrix(user_book_interaction.values)<br/>user_book_interaction_csr</span></pre><h1 id="433d" class="mo mp jg bd mq mr nz mt mu mv oa mx my kv ob kw na ky oc kz nc lb od lc ne nf bi translated">模特培训</h1><p id="b199" class="pw-post-body-paragraph le lf jg lg b lh ng kq lj lk nh kt lm ln ni lp lq lr nj lt lu lv nk lx ly lz ij bi translated">理想情况下，我们将为我们的推荐系统构建、训练和评估几个模型，以确定哪个模型最有希望进行进一步优化(超参数调整)。</p><p id="01ae" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">然而，对于本教程，我们将使用随机选择的输入参数来训练基本模型。</p><pre class="nu nv nw nx gt oo om op bn oq or bi"><span id="d02e" class="os mp jg om b be ot ou l ov ow">model = LightFM(loss='warp',<br/>                random_state=2016,<br/>                learning_rate=0.90,<br/>                no_components=150,<br/>                user_alpha=0.000005)<br/>model = model.fit(user_book_interaction_csr,<br/>                  epochs=100,<br/>                  num_threads=16, verbose=False)</span></pre><h1 id="bf30" class="mo mp jg bd mq mr nz mt mu mv oa mx my kv ob kw na ky oc kz nc lb od lc ne nf bi translated">前 n 条建议</h1><p id="cf8e" class="pw-post-body-paragraph le lf jg lg b lh ng kq lj lk nh kt lm ln ni lp lq lr nj lt lu lv nk lx ly lz ij bi translated">为了找回前 n 名的推荐，我们将通过<a class="ae jd" href="https://github.com/aayushmnit" rel="noopener ugc nofollow" target="_blank">Aayush agr awal</a>T2 重新使用代码</p><pre class="nu nv nw nx gt oo om op bn oq or bi"><span id="f310" class="os mp jg om b be ot ou l ov ow">def sample_recommendation_user(model, interactions, user_id, user_dict, <br/>                               item_dict,threshold = 0,nrec_items = 5, show = True):<br/>    <br/>    n_users, n_items = interactions.shape<br/>    user_x = user_dict[user_id]<br/>    scores = pd.Series(model.predict(user_x,np.arange(n_items), item_features=books_metadata_csr))<br/>    scores.index = interactions.columns<br/>    scores = list(pd.Series(scores.sort_values(ascending=False).index))<br/>    <br/>    known_items = list(pd.Series(interactions.loc[user_id,:] \<br/>                                 [interactions.loc[user_id,:] &gt; threshold].index).sort_values(ascending=False))<br/>    <br/>    scores = [x for x in scores if x not in known_items]<br/>    return_score_list = scores[0:nrec_items]<br/>    known_items = list(pd.Series(known_items).apply(lambda x: item_dict[x]))<br/>    scores = list(pd.Series(return_score_list).apply(lambda x: item_dict[x]))<br/>    if show == True:<br/>        print ("User: " + str(user_id))<br/>        print("Known Likes:")<br/>        counter = 1<br/>        for i in known_items:<br/>            print(str(counter) + '- ' + i)<br/>            counter+=1<br/>print("\n Recommended Items:")<br/>        counter = 1<br/>        for i in scores:<br/>            print(str(counter) + '- ' + i)<br/>            counter+=1</span></pre><p id="52ca" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">让我们检查结果</p><pre class="nu nv nw nx gt oo om op bn oq or bi"><span id="7d21" class="os mp jg om b be ot ou l ov ow">sample_recommendation_user(model, user_book_interaction, 'ff52b7331f2ccab0582678644fed9d85', user_dict, item_dict)</span></pre><figure class="nu nv nw nx gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi po"><img src="../Images/1260ccb8527722b4d274ee65dc0fe7ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OCzGPWkKMRIWyksBRZJDdQ.png"/></div></div></figure></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="a215" class="mo mp jg bd mq mr ms mt mu mv mw mx my kv mz kw na ky nb kz nc lb nd lc ne nf bi translated">结束语</h1><p id="eecf" class="pw-post-body-paragraph le lf jg lg b lh ng kq lj lk nh kt lm ln ni lp lq lr nj lt lu lv nk lx ly lz ij bi translated">在过去的十年中，机器学习变得越来越受欢迎，计算可用性的最新进展导致人们寻求新方法如何被结合以推进推荐系统领域的方法呈指数级增长。</p><p id="d986" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">通常，我们将推荐系统视为黑盒算法。尽管如此，希望这篇文章能够揭示底层的数学原理、背后的直觉，以及让你开始构建你的第一个推荐模型的高级代码。</p><p id="a6af" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">在下一篇文章中，我们将更深入地了解如何评估这些模型的性能，调整其超参数以获得更直观和可靠的结果。</p><h1 id="269e" class="mo mp jg bd mq mr nz mt mu mv oa mx my kv ob kw na ky oc kz nc lb od lc ne nf bi translated">参考</h1><p id="d8da" class="pw-post-body-paragraph le lf jg lg b lh ng kq lj lk nh kt lm ln ni lp lq lr nj lt lu lv nk lx ly lz ij bi translated">[1]<a class="ae jd" href="https://en.wikipedia.org/wiki/Recommender_system" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Recommender_system</a></p><p id="7fa4" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">[2]迪帕克·阿加瓦尔..推荐系统的统计方法。剑桥大学出版社。Kindle 版</p><p id="5d61" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">[3] Charu，A. (1997 年)。推荐系统教科书。在美国计算机学会的<em class="md">通讯中(第 40 卷)</em></p><p id="e4a4" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">[4]万，朱利安·麦考利，【关于单调行为链的项目建议】，载于<em class="md"> RecSys'18 </em></p><p id="cb7f" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">[5]万，里沙布·米斯拉，恩达帕·纳卡肖勒，朱利安·麦考利，“大规模评论语料库中的<a class="ae jd" href="https://www.google.com/url?q=https%3A%2F%2Fwww.aclweb.org%2Fanthology%2FP19-1248&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNG8xlMi09lyuzzMI8lCW58wrBEGsQ" rel="noopener ugc nofollow" target="_blank">细粒度扰流板检测</a>”，载于<em class="md"> ACL'19 </em></p><p id="823f" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">[6]<a class="ae jd" href="https://github.com/aayushmnit/cookbook/blob/master/recsys.py" rel="noopener ugc nofollow" target="_blank">https://github . com/aayushmnit/cookbook/blob/master/rec sys . py</a></p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><p id="4fdb" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">感谢阅读。<em class="md">如果你有任何反馈，请联系我，在</em><a class="ae jd" href="https://www.linkedin.com/in/shashankkapadia/" rel="noopener ugc nofollow" target="_blank"><em class="md">LinkedIn</em></a><em class="md">给我发邮件(shmkapadia[at]gmail.com) </em></p><p id="4137" class="pw-post-body-paragraph le lf jg lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">如果你喜欢这篇文章，请阅读我在 NLP 上的其他文章</p><div class="ip iq gp gr ir pp"><a rel="noopener follow" target="_blank" href="/end-to-end-topic-modeling-in-python-latent-dirichlet-allocation-lda-35ce4ed6b3e0"><div class="pq ab fo"><div class="pr ab ps cl cj pt"><h2 class="bd jq gy z fp pu fr fs pv fu fw jp bi translated">Python 中的主题建模:潜在狄利克雷分配(LDA)</h2><div class="pw l"><h3 class="bd b gy z fp pu fr fs pv fu fw dk translated">如何开始使用 Python 中的 LDA 进行主题建模</h3></div><div class="px l"><p class="bd b dl z fp pu fr fs pv fu fw dk translated">towardsdatascience.com</p></div></div><div class="py l"><div class="pz l qa qb qc py qd ix pp"/></div></div></a></div><div class="ip iq gp gr ir pp"><a rel="noopener follow" target="_blank" href="/evaluate-topic-model-in-python-latent-dirichlet-allocation-lda-7d57484bb5d0"><div class="pq ab fo"><div class="pr ab ps cl cj pt"><h2 class="bd jq gy z fp pu fr fs pv fu fw jp bi translated">评估主题模型:潜在狄利克雷分配(LDA)</h2><div class="pw l"><h3 class="bd b gy z fp pu fr fs pv fu fw dk translated">构建可解释主题模型的分步指南</h3></div><div class="px l"><p class="bd b dl z fp pu fr fs pv fu fw dk translated">towardsdatascience.com</p></div></div><div class="py l"><div class="qe l qa qb qc py qd ix pp"/></div></div></a></div></div></div>    
</body>
</html>