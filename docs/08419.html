<html>
<head>
<title>The Big O Notation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">大O符号</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-big-o-notation-d35d52f38134?source=collection_archive---------4-----------------------#2020-06-19">https://towardsdatascience.com/the-big-o-notation-d35d52f38134?source=collection_archive---------4-----------------------#2020-06-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5cfd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">算法复杂性变得简单——这不是矛盾修饰法！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8da41336faeb2655b9c5af3456a37dc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OJrEy6AwyuR7QAqV"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图为<a class="ae ky" href="https://unsplash.com/@dollargill?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">美元吉尔</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="c6fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个算法的性能取决于它需要的步骤数。计算机科学家从数学界借用了术语“大O符号”来准确描述算法的效率。许多自学成才的<strong class="lb iu">开发人员和数据科学家要么满足于一个“可行”的解决方案，而不考虑如何提高他们代码的性能，要么在没有真正理解基础知识的情况下进行优化。他们的尝试要么是徒劳的，要么影响很小，而且大多是偶然的。</strong></p><p id="9eaf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">衡量一个算法的复杂性并不是一个难以理解的概念——尽管这听起来像是一个矛盾的说法——事实并非如此！<br/>在本文中，我们将省去<a class="ae ky" href="https://en.wikipedia.org/wiki/Big_O_notation" rel="noopener ugc nofollow" target="_blank">数学术语</a>，并以一种<strong class="lb iu">易于理解的方式</strong>解释Big-O概念。我们将通过独立的Python片段来完善我们的理解，并且我们将通过一个一体化的备忘单来结束我们的旅程，以供将来参考。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2dcd" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">介绍</h1><h2 id="9684" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">时间复杂度</h2><p id="282c" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">Big-O不再关注时间单位，而是将<strong class="lb iu">步数</strong>放在聚光灯下。硬件因素已从等式中剔除。因此，我们不是在讨论<em class="nl">运行时间</em>，而是在讨论<em class="nl">时间复杂度</em>。<br/> ⚠我们将不讨论<em class="nl">空间复杂度</em>，即一个算法占用多少<em class="nl">内存</em>。我们下次再说:)</p><h2 id="b53a" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">大O定义</h2><p id="699c" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">一个算法的Big-O符号取决于它如何响应给定数据集的不同大小。例如，当我们向它传递1个元素和10，000个元素时，它的性能如何。</p><p id="5eb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">o代表 的<strong class="lb iu"> <em class="nl">阶，所以<code class="fe nm nn no np b">O(N)</code>读作“N阶”——它是给定N个输入元素的算法持续时间的一个<strong class="lb iu">近似值</strong>。它回答了这样一个问题:“<em class="nl">随着输入数据元素的增加，步数是如何变化的？</em></em></strong></p><blockquote class="nq"><p id="e731" class="nr ns it bd nt nu nv nw nx ny nz lu dk translated">O(N)描述了一个算法根据它所作用的元素的数量需要多少步。</p><p id="8915" class="nr ns it bd nt nu nv nw nx ny nz lu dk translated">⭐️就是这么简单！！</p></blockquote><h2 id="4fbf" class="mu md it bd me mv oa dn mi mx ob dp mm li oc na mo lm od nc mq lq oe ne ms nf bi translated">最佳与最差情景</h2><p id="a67c" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">从一个简单的例子开始:给定一个输入<code class="fe nm nn no np b">array[N]</code>和一个值<code class="fe nm nn no np b">X</code>，我们的算法将通过从头开始遍历数组直到找到该值来搜索值<code class="fe nm nn no np b">X</code>。</p><p id="c763" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">给定这个5元素数组:<code class="fe nm nn no np b">[<strong class="lb iu">2</strong>,1,6,3,<strong class="lb iu">8</strong>]</code>如果我们搜索<code class="fe nm nn no np b">X=8</code>，算法需要5步才能找到它，但是如果我们搜索<code class="fe nm nn no np b">X=2</code>，只需要1步。因此，最好的情况是我们在第<em class="nl">个单元格</em>中寻找一个值，最坏的情况是该值在最后一个单元格<em class="nl">中，或者根本不在那里。</em></p><p id="34d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Big-O符号对性能采取悲观的方法，指的是最坏的情况。当我们描述下面的复杂性时，以及当你试图计算你自己的算法的复杂性时，这真的很重要:<em class="nl">总是想到最坏的情况</em>。</p><p id="7107" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经定义了规则和词汇，不再多说，让我们深入了解您可能遇到的最常见的复杂性…</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2055" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">O(1) —常数</h1><p id="82a4" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated"><code class="fe nm nn no np b">O(1)</code>表示无论传入多少数据，算法都要执行相同数量的步骤。</p><h2 id="6519" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">例子</h2><pre class="kj kk kl km gt of np og oh aw oi bi"><span id="3fb7" class="mu md it np b gy oj ok l ol om">✏️ Determine if the <strong class="np iu">i-th element</strong> of an array is an odd number.</span></pre><p id="62ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不管我们是访问第1个、第2个还是第100万个条目，都没有关系…我们可以通过使用索引操作符<code class="fe nm nn no np b">array[i]</code>直接访问它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/bebda661e1dbbdb8257a96979415c727.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eX2vo735WWU35Sz3usNCzQ.png"/></div></div></figure><h2 id="3465" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">情节</h2><p id="50fb" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">如果我们要表示步骤数(y轴)对输入元素数(x轴)，<code class="fe nm nn no np b">O(1)</code>是一条完美的水平线，因为无论有多少数据，算法中的步骤数都保持不变。这就是为什么叫<em class="nl">恒时</em>的原因。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/d92e73f24a8aae77b774821d180180b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*MH3BmdZKRuqHyLNnaI9eRg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">O(1)</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9c26" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">O(N) — <em class="op">线性</em></h1><p id="494f" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">一个<code class="fe nm nn no np b">O(N)</code>算法将采取和数据元素一样多的步骤。所以当数组的大小增加一个元素时，一个<code class="fe nm nn no np b">O(N)</code>算法就会增加一个步长。</p><h2 id="4c08" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">例子</h2><pre class="kj kk kl km gt of np og oh aw oi bi"><span id="c3d9" class="mu md it np b gy oj ok l ol om">✏️ <strong class="np iu">Traverse</strong> an array and print each element.</span></pre><p id="d514" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们需要逐个访问所有元素，因此计算时间与输入同步增长。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/b0239b7eb1498da15d6a4249cf4e702a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rLwlvwOyBCkioaW9Pbdb1Q.png"/></div></div></figure><h2 id="6849" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">情节</h2><p id="3638" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated"><code class="fe nm nn no np b">O(N)</code>是一条完美的对角线，每增加一条数据，算法就多走一步。这就是为什么它也被称为<em class="nl">线性时间</em>的原因。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/762f5d1fb153599999e6770b3ed2fa27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*onjErRnvJBpEfFbTdFjw2Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">O(N)</p></figure><p id="0db5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们将<code class="fe nm nn no np b">O(1)</code>和<code class="fe nm nn no np b">O(N)</code>算法绘制在同一个图中，并假设<code class="fe nm nn no np b">O(1)</code>算法持续进行50步。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/612205c64b79f33e15033151f5eb9b74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*OWkUhdYdVcSN9UI9ibziFg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">O(1)对O(N)</p></figure><p id="d0c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们能观察到什么？</p><p id="5c3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">→当输入数组少于50个元素时，<code class="fe nm nn no np b">O(N)</code>更有效。<br/> →正好在50个元素处，两种算法采取相同数量的步骤。<br/> →随着数据的增加，<code class="fe nm nn no np b">O(N)</code>采取更多的步骤。</p><p id="9870" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于Big-O符号关注的是当数据增长到<strong class="lb iu">无穷大</strong>时算法的表现，这就是为什么<code class="fe nm nn no np b">O(N)</code>被认为不如<code class="fe nm nn no np b">O(1)</code>有效的原因。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2db1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">O(N ) — <em class="op">二次型</em></h1><p id="0c23" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated"><code class="fe nm nn no np b">O(N²)</code>代表算法的复杂度，其性能与输入元素大小的平方成正比。它通常很慢:如果输入数组有1个元素，它将执行1次操作，如果有10个元素，它将执行100次操作，依此类推。</p><h2 id="3d44" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">例子</h2><pre class="kj kk kl km gt of np og oh aw oi bi"><span id="3142" class="mu md it np b gy oj ok l ol om">✏️ Find <strong class="np iu">duplicates</strong> in an array.</span></pre><p id="3c05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个“幼稚”的实现，但是它遍历数组两次:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/93cc63aaa74fe8bb13a618ee05eab584.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w14fnGabon9wj5BAazWNbg.png"/></div></div></figure><p id="26cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过输入增加更多的嵌套迭代将增加算法的复杂性:例如，如果迭代次数是3，那么它的复杂性将是<code class="fe nm nn no np b">O(N³)</code>等等。通常我们要远离<em class="nl">多项式</em>运行次数(二次、三次、<code class="fe nm nn no np b">Nˣ</code>等)。</p><h2 id="ac30" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">情节</h2><p id="ad06" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated"><code class="fe nm nn no np b">O(N²)</code>线是一个急转弯:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/5d3f8fc497f80d221ebe5b42f70b8af7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*h34O9norWzUHK2hmoRgn5g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">O(N)</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bb3b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">O(logN) —对数</h1><p id="c1d3" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">简单来说，<code class="fe nm nn no np b">O(logN)</code>描述了一种算法，它的运算次数在数据每增加一倍时增加一。</p><pre class="kj kk kl km gt of np og oh aw oi bi"><span id="56f5" class="mu md it np b gy oj ok l ol om"><strong class="np iu">📌 Logarithms Refresher:<br/></strong><br/>You may not remember what logarithms are, but you probably know what exponents are:<br/>2³ = 2 * 2 * 2 = 8 — Here we multiply the number 2, 3 times.</span><span id="2d0c" class="mu md it np b gy os ok l ol om"><strong class="np iu">Logarithms are the flips of exponents.</strong><br/>log₂8 answers the question: how many 2s do we multiply together to get 8? The answer is 3.</span><span id="58d5" class="mu md it np b gy os ok l ol om">In other words, if we keep dividing 8 by 2 until we end up to 1, how many 2s do we have in our equation?</span><span id="5c51" class="mu md it np b gy os ok l ol om">8 / <strong class="np iu">2</strong> / <strong class="np iu">2</strong> / <strong class="np iu">2</strong> = 1. The answer is 3 again.</span></pre><h2 id="04bd" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">例子</h2><p id="307b" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">对数时间复杂性通常适用于每次将问题分成两半的算法。</p><pre class="kj kk kl km gt of np og oh aw oi bi"><span id="ca6d" class="mu md it np b gy oj ok l ol om">✏️ <strong class="np iu">Dictionary</strong> lookup (aka binary search).</span></pre><p id="923d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">1)中间打开字典，查第一个单词。如果我们的单词按字母顺序更重要，就看右半部分，否则就看左半部分。再次将余数分成两半，重复步骤2和3，直到找到我们要的单词。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/7b84383ab2009ca5d1e104345f06e826.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eL4En2cry-jDQ2CHczPn-A.png"/></div></div></figure><p id="dc17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们每次迭代只能选择一种可能性，并且我们的可能匹配池在每次迭代中被除以2。这使得二分搜索法的时间复杂度<code class="fe nm nn no np b">O(logN)</code>。</p><h2 id="f2bb" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">情节</h2><p id="7bef" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">随着输入的增加，步骤的数量几乎没有增加(即，每次数据翻倍时只需增加一个步骤):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/0454c27a6494e9f5ae103cdfcc24514a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*cIQNNJwW-LF8DS1QJ0q9UA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">o(登录)</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1508" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">诸如此类…</h1><p id="4f74" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">到目前为止，我们已经学习了四个最重要的Big-O分类法。当然还有一些，但是我相信你能够理解它们。让我们快速覆盖它们:</p><h2 id="1a31" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">O(N logN) —对数线性</h2><p id="bd46" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">这种复杂度的算法要做<code class="fe nm nn no np b">log(N)</code>次<code class="fe nm nn no np b">N</code>次工作，因此它的性能比<code class="fe nm nn no np b">O(N)</code>稍差。许多实用的算法都属于这一类(从<a class="ae ky" href="https://en.wikipedia.org/wiki/Merge_sort" rel="noopener ugc nofollow" target="_blank">排序</a>，到<a class="ae ky" href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm" rel="noopener ugc nofollow" target="_blank">寻路</a>，到<a class="ae ky" href="https://en.wikipedia.org/wiki/Huffman_coding" rel="noopener ugc nofollow" target="_blank">压缩</a>，所以我们为了完整起见才提到它。</p><p id="697d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> ✏️示例</strong>:合并排序——这是一个“分治”算法:它将输入数组分成两半，对每一半调用自己，然后合并排序后的两半。<br/>💡<strong class="lb iu">可扩展性</strong>:一般。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="3862" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">O(2ᴺ) —指数</h2><p id="8c4d" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">指数增长意味着每增加一个新元素，算法需要两倍的时间。</p><p id="bd07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> ✏️示例</strong>:查找数据集中的所有子集。<br/>💡<strong class="lb iu">扩展性</strong>:差。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="5175" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">O(N！)—阶乘</h2><p id="085b" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">这类算法的运行时间与输入大小的阶乘成正比:<code class="fe nm nn no np b">n! = n * (n-1) * (n-2) * (n-3) * . . . * 1</code>。</p><p id="f02e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> ✏️例子</strong>:找出数据集中所有不同的排列。<br/>💡<strong class="lb iu">扩展性</strong>:非常差。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1b65" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">增长层次</h1><p id="6853" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">Big-O符号提供了一种一致的机制来比较任何两种算法，从而帮助我们使代码更快、更具可伸缩性。将所有的复杂性放在一个图表中，我们可以直观地观察它们在性能方面的比较:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/7208e3d612120c4ba65a6624c1f9a5c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*qpw9Hil7AOfZoMT5EWWcJw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Big-O复杂性类</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d045" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="3411" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">我希望你现在意识到Big-O符号毕竟不是一个可怕的概念！</p><h2 id="cd66" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">概述</h2><ul class=""><li id="1285" class="ot ou it lb b lc ng lf nh li ov lm ow lq ox lu oy oz pa pb bi translated">算法速度不是以秒来衡量的，而是以增长来衡量的</li><li id="bf24" class="ot ou it lb b lc pc lf pd li pe lm pf lq pg lu oy oz pa pb bi translated">Big-O符号告诉我们算法如何根据输入数据集大小的变化进行扩展</li><li id="4e38" class="ot ou it lb b lc pc lf pd li pe lm pf lq pg lu oy oz pa pb bi translated">O代表的<em class="nl">顺序，因此大O符号是近似的</em></li><li id="db57" class="ot ou it lb b lc pc lf pd li pe lm pf lq pg lu oy oz pa pb bi translated">算法运行时间以不同的速度增长:</li></ul><pre class="kj kk kl km gt of np og oh aw oi bi"><span id="dd25" class="mu md it np b gy oj ok l ol om">O(1) &lt; O(logN) &lt; O(N) &lt; O(N logN) &lt; O(N²) &lt; O(2ᴺ) &lt; O(N!)</span></pre><h2 id="1982" class="mu md it bd me mv mw dn mi mx my dp mm li mz na mo lm nb nc mq lq nd ne ms nf bi translated">更多资源</h2><ul class=""><li id="7cee" class="ot ou it lb b lc ng lf nh li ov lm ow lq ox lu oy oz pa pb bi translated">如果你想更深入地挖掘Big-O背后的数学知识，看看斯坦福大学的免费Coursera课程。</li><li id="48a3" class="ot ou it lb b lc pc lf pd li pe lm pf lq pg lu oy oz pa pb bi translated"><a class="ae ky" href="https://www.bigocheatsheet.com" rel="noopener ugc nofollow" target="_blank">Big-O备忘单</a></li><li id="9999" class="ot ou it lb b lc pc lf pd li pe lm pf lq pg lu oy oz pa pb bi translated">我的备忘单:</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ph"><img src="../Images/c51f9a318f0030b9773d1b0553ed920a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-nM9NNb8FW9uUT64rzhkOA.png"/></div></div></figure><p id="9527" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="a2b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nl">我定期在媒体上写关于领导力、技术&amp;的数据——如果你想阅读我未来的帖子，请</em><a class="ae ky" href="https://medium.com/@semika" rel="noopener"><em class="nl">‘关注’我</em> </a> <em class="nl">！</em></p></div></div>    
</body>
</html>