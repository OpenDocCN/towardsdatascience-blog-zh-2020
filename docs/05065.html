<html>
<head>
<title>Top Coding Algorithms — Depth First Search</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">顶级编码算法—深度优先搜索</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/top-coding-algorithms-depth-first-search-38ba378e6093?source=collection_archive---------43-----------------------#2020-05-01">https://towardsdatascience.com/top-coding-algorithms-depth-first-search-38ba378e6093?source=collection_archive---------43-----------------------#2020-05-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="7bea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所有可以被格式化为树形结构的编码问题都很可能通过广度优先搜索或深度优先搜索来解决。与使用堆栈实现的广度优先搜索不同，深度优先搜索采用分而治之的方法，使用递归实现。</p><h1 id="7519" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">伪码</h1><p id="6f1d" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated"><strong class="js iu">输入</strong>:一个图<em class="lr"> G </em>和 G 的一个顶点<em class="lr"> v </em></p><p id="0423" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">输出</strong>:从<em class="lr"> v </em>可达的所有顶点被标记为已发现</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="1e5e" class="mb kp it lx b gy mc md l me mf"><strong class="lx iu">procedure</strong> DFS(<em class="lr">G</em>, <em class="lr">v</em>) <strong class="lx iu">is</strong><br/>    label <em class="lr">v</em> as discovered<br/>    <strong class="lx iu">for all</strong> edges from <em class="lr">v</em> to <em class="lr">w that are</em> <strong class="lx iu">in</strong> <em class="lr">G</em>.adjacentEdges(<em class="lr">v</em>) <strong class="lx iu">do</strong><br/>        <strong class="lx iu">if</strong> vertex <em class="lr">w</em> is not labeled as discovered <strong class="lx iu">then</strong><br/>            recursively call DFS(<em class="lr">G</em>, <em class="lr">w</em>)</span><span id="a5e4" class="mb kp it lx b gy mg md l me mf">(from <a class="ae mh" href="https://en.wikipedia.org/wiki/Depth-first_search" rel="noopener ugc nofollow" target="_blank">wiki</a>)</span></pre><p id="bbb8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">(注意，只有当顶点<em class="lr"> w </em>未被访问时，我们才继续，这避免了图或树中的循环)</p><p id="8213" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">之所以可以用递归来解决问题，是因为一个大问题可以分成多个子问题，每个子问题遵循相同的逻辑和结构。</strong>例如，在这里如果我们想在一个树形结构中找到从 A 点到 B 点的路径，你可以把这个过程总结为一个重复的公式:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="ad58" class="mb kp it lx b gy mc md l me mf">path = current_path + DFS(sub_tree)</span></pre><h1 id="0257" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">例子</h1><p id="bef4" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">考虑下面的问题，</p><figure class="ls lt lu lv gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mi"><img src="../Images/0c4d0bc7e3f73329de49fd3e7899757a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OYi28yHk9CMNuyBFfh5v9g.png"/></div></div></figure><p id="6f91" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">找到从<em class="lr">点 0 </em>到<em class="lr">点 6 </em>的所有路径。</p><p id="3911" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意，图中有一个循环(双箭头)(1 和 4)。</p><figure class="ls lt lu lv gt mj"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="c9d8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">节点连接存储在字典中。递归在到达终点或叶节点时停止。</p><figure class="ls lt lu lv gt mj"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="f58f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这给出了结果:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="46fd" class="mb kp it lx b gy mc md l me mf">find solution path [0, 1, 4, 6]<br/>find solution path [0, 2, 5, 6]<br/>find solution path [0, 2, 5, 4, 6]</span></pre><h1 id="fb20" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">变化</h1><p id="498d" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">考虑以下问题:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="ee72" class="mb kp it lx b gy mc md l me mf">Given a n-ary tree, find its maximum depth.</span><span id="5af0" class="mb kp it lx b gy mg md l me mf">The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</span><span id="856b" class="mb kp it lx b gy mg md l me mf">Input: root = [1,null,3,2,4,null,5,6]<br/>Output: 3</span></pre><figure class="ls lt lu lv gt mj gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/2ed26bc6be916fcac3767a5ae16da640.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/format:webp/1*Ysp_hvE5CzApROE4L8HPCA.png"/></div></figure><p id="2e9a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了将问题分成子问题，它遵循以下公式</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="b636" class="mb kp it lx b gy mc md l me mf">max_depth = 1 + max(max_depth(child_1), max_depth(child_2), ...)</span></pre><h2 id="79d7" class="mb kp it bd kq mt mu dn ku mv mw dp ky kb mx my lc kf mz na lg kj nb nc lk nd bi translated">解决办法</h2><figure class="ls lt lu lv gt mj"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="639b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">(结帐代码<a class="ae mh" href="https://github.com/MJeremy2017/algorithms/tree/master/depth-first-search" rel="noopener ugc nofollow" target="_blank">此处</a>)</p></div></div>    
</body>
</html>