# 练习 Python 理解

> 原文：<https://towardsdatascience.com/practice-with-python-comprehensions-af6f484a6e1e?source=collection_archive---------60----------------------->

## 用于数据准备和特征提取

![](img/d0a2167bad247a7baab2a54f4fc2b563.png)

在 [Unsplash](https://unsplash.com/s/photos/python?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上由 [Hitesh Choudhary](https://unsplash.com/@hiteshchoudhary?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 拍摄的照片

在这篇文章中，我们在数据准备和特征提取的各种例子上练习 Python 理解。我们希望让读者了解使用这种 Python 机制可以完成的各种任务。这篇文章也会引起数据科学新手的兴趣。

首先，我们先列举两个在数据科学建模中重复出现的核心数据模式。在数据准备和特征提取中。即使在机器学习算法中，尤其是对向量和矩阵进行操作的算法中。

图案是*聚合器*和*变压器*。两者都在 python 集合上操作。

一个聚合器从一个集合中计算一个标量，这个集合概括了它的某些方面。例子包括对列表中的值求和、查找列表中的最大值、查找列表的长度等。

转换器将一个集合映射到另一个集合。一个例子是将计数向量转换成概率向量。变换器模式在特征提取中是有用的。

虽然这些模式在概念上看起来很简单，但是用 Python 练习编码将帮助读者认识到何时应用它们，然后轻松地实现它们。

Python 理解在实现转换器时尤其有用。

让我们开始吧。首先，让我们做好准备。我们将关注三种类型的数据。

1.  一个特征向量。
2.  代表文本文件的一包单词。
3.  一种二进制图像的表示。

特征向量只是一个集合，它捕获了我们希望建模的一些固定属性的值。比方说我们要用三个特征来描述一个房子:*卧室数量*，*卫生间数量*，*面积*。我们可以将其建模为一个 python 列表，其元素是三个特性的值。因此[4，2，2000]代表一栋有四间卧室、两间浴室的房子，其面积为 2000 平方英尺。

文本文档的单词包表示捕获每个单词在其中出现的次数。在 python 中，用字典表示一袋单词很方便。这里有一个例子。

```
bag = { ‘the ’: 5, ‘art’ : 2, ‘of’ : 2, … }
```

我们将通过二维 python 列表来表示二进制图像。这里有一个例子。

```
image = [[1,1,1],[1,0,1],[1,1,1]]
```

**聚合器示例**

假设我们想从文档的包中知道文档的总字数。在 python 中，我们就是这样做的

```
sum(bag.values())
```

假设我们想计算图像中黑色像素的数量。在 python 中，我们会做

```
import numpy as np
np.sum(image)
```

我们使用 NumPy，因为它支持任意形状数组上的聚合器。我们的图像是二维的。

**变压器实例**

假设我们想要将文档的单词包表示转换为单词的概率分布。后者是长度规范化的，这一特性在某些用例中很有吸引力。在 python 中，我们会做

```
denom = sum(bag.values())
pbag = { word : float(count)/denom for word, count in bag.items() }
```

第二行使用了*字典理解*。

考虑我们的图像，想象它是灰度的。这只是意味着 image[i][j]是一个介于 0 和 1 之间的值，而不仅仅是它的极值。对于下游处理，我们可能希望将此图像转换为二进制图像。在 python 中，我们可以

```
def binarize(x):
   if x >= 0.5:
     return 1
   else:
     return 0binarized_image = [[binarize(pixel) for pixel in pixel_row] for pixel_row in image]
```

在最后一行，我们正在做的可能被称为*二维列表理解*。

**特征提取作为一种变换**

假设我们有一个输入向量数组。我们想把它转换成一组特征向量。

以我们的房子为例。有理由推测各个维度是相互关联的。也就是说，更大的房子会有更多的卧室、更多的浴室和更大的面积。我们可能对从这三个特征中派生出一个特征感到好奇。或许，它可以很好地区分大小房屋。

首先，让我们将我们的特征定义为输入向量中三个值的乘积。所以我们正在从三维空间向一维空间转变。(有时候，少可以多。)在 python 中，我们可以将输入向量数组转换为特征向量数组，如下所示。

```
feature_vectors = [x[0]*x[1]*x[2] for x in input_vectors]
```

一般来说，特征提取比我们在简单例子中看到的要复杂得多。我们可以将所有的复杂性抽象成一个函数`to_feature_vector(x)`，它将输入向量 x 作为一个参数。然后我们在理解中简单地使用这个函数

```
feature_vectors = [to_feature_vector(x) for x in input_vectors]
```

接下来，让我们看一个涉及缺失数据的例子

**特征向量的相似度(有缺失数据)**

假设我们有两个相同维数的数值向量 X 和 Y，并且缺少一些值。在 python 中，X 和 Y 可能是长度相同的列表，有些值是`None`。我们想要计算两个向量的相似性度量，考虑它们的缺失值。

下面我们将在忽略 X 或 Y 的值为 None 的维度后计算所谓的点积。

```
def dp(x,y):
  return sum([x[i]*y[i] for i in range(len(x)) if x[i] and y[i]])
```

让我们看一个数字例子。让我们看看我们的房屋示例中的三个特征向量:

```
X = [4,2,2000]
Y = [4,None,1800]
Z = [None,1,500]
```

dp(X，Y)和 dp(X，Z)分别是 3600016 和 1000002。这表明 X 和 Y 比 X 和 z 更相似。这有直观的意义。

也就是说，如果输入向量没有被适当地归一化，dp 会给出非常误导的结果。这是因为矢量的分量处于不同的尺度。在我们的例子中，卧室的数量和浴室的数量通常在 0 到 6 之间，而面积可能在 100 到 1000 之间。

**规格化一个数字特征的列**

以我们的房子为例。正如上一段所讨论的，平方英尺与前两个(卧室的数量，浴室的数量)有很大的不同。让我们看一个这种规模差异导致的问题的例子。

认为

```
X = [4,2,2000]
Y = [1,0,2000]
Z = [4,2,1800]
```

dp(X，Y)，dp(X，Z)，dp(Y，Z)分别约为 400K，360K，360K。x 和 Z 像 Y 和 Z 一样相似没有意义。

好了，正常化吧！这种规范化将对要素列进行操作，每个要素一列。我们将特征列中的值除以该列的 L2 范数。什么是 L2 规范？您在下面包含`denom`的行的 rhs 上看到的内容。

```
import math
def normalize(fc):
   denom = math.sqrt(sum([v**2 for v in fc]))
   return [v/denom for v in fc]
```

`normalize(fc)`输入一个特征列，并将其标准化。

接下来，让我们准备三个特性列，以便可以使用 normalize(fc)。

```
fcs = [[xyz[i] for xyz in [X,Y,Z]] for i in range(3)]
```

我们看到 fcs 等于

```
[[4, 1, 4], [2, 0, 2], [2000, 2000, 1800]]
```

所以 fcs[i]是特性 I 的值列表。

好了，现在让我们正常化

```
nfcs = [normalize(fc) for fc in fcs]
```

让我们看看 NFC。

```
[
[0.6963106238227914, 0.17407765595569785, 0.6963106238227914], [0.7071067811865475, 0.0,                 0.7071067811865475], 
[0.5965499862718936, 0.5965499862718936,  0.5368949876447042]
]
```

这三栋房子的标准平方英尺大致相同。第二所房子的卧室和浴室的标准数量远远低于第一所和第三所房子。理应如此。

下一步是在标准化的特征向量上使用 dp。为此，我们首先需要将规范化的特征列转换成规范化的特征向量。

```
XYZ = list(zip(nfcs[0],nfcs[1],nfcs[2])
X,Y,Z = [list(XYZ[i]) for i in range(3)]
```

x、Y 和 Z 现在是三个房屋的特征向量的归一化版本。

```
X = [0.6963106238227914, 0.7071067811865475, 0.5965499862718936]
Y = [0.17407765595569785, 0.0, 0.5965499862718936]
Z = [0.6963106238227914, 0.7071067811865475, 0.5368949876447042]
```

我们看到 dp(X，Y)，dp(X，Z)，dp(Y，Z)分别是 0.477，1.30，0.44。好多了。X 和 Z 比 Y 和 Z(或者 Y 和 X)更相似。

**结论**

在这篇文章中，我们用简单的例子讨论了在数据表示、准备和特征提取中反复出现的一些核心问题。我们讨论了涉及数字特征向量的例子，以及如何归一化它们，考虑丢失的数据。我们还介绍了单词示例和二进制图像操作。

所有这些例子的共同点是我们使用了 Python 理解。从中得出的信息是，在 Python 中学习和实践这一机制在数据科学环境中非常有帮助。