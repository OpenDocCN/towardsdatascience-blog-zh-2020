<html>
<head>
<title>My Python Code for Flexible Recommendations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我的灵活推荐Python代码</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/my-python-code-for-flexible-recommendations-b4d838e9e0e0?source=collection_archive---------50-----------------------#2020-05-11">https://towardsdatascience.com/my-python-code-for-flexible-recommendations-b4d838e9e0e0?source=collection_archive---------50-----------------------#2020-05-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e5f6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我的额外定制Python代码，使您能够基于Surprise library的K-Nearest neighborhood样式模型运行更灵活的推荐。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/62aa8c3d2a62805ab3d1311bd3475521.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GY-mxZICFeHarQu6aVdRow.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@merittthomas?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">merit Thomas</a>在<a class="ae ky" href="https://unsplash.com/s/photos/cupcake?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="5bd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的<a class="ae ky" rel="noopener" target="_blank" href="/how-to-build-a-memory-based-recommendation-system-using-python-surprise-55f3257b2cf4">上一篇博文</a>中，我详细讨论了如何使用惊奇库在Python中使用推荐系统，从数据处理到预测和前N名推荐。如果你不熟悉这个主题，我建议你先阅读这篇文章，作为对协同过滤推荐系统的介绍，我不会重复其中的段落让你厌烦。</p><p id="d0dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在开始我的上一篇文章时打了一个比方，蛋糕店里的纸杯蛋糕排起了长队，作为一个消费者，由于资源有限，你无法尝试所有的蛋糕，因此推荐系统非常重要。继续这个类比，如果在我们分析了所有可用的纸杯蛋糕后，有人想出了一个额外的纸杯蛋糕，我们宁愿产生结果而不是重新开始整个过程。(我真的很期待我能弄清楚如何继续类比，以及什么样的封面图片将符合我接下来要写的基于模型的推荐系统的逻辑...)</p><p id="236d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在使用Surprise时，我不喜欢的一点是，为了给新用户做推荐，你必须将用户的评级添加到大量的训练数据中，然后重新拟合你的整个模型。其原因是预测模型建立在相同的类结构之上，对于使用矩阵分解的更复杂的模型，重新拟合是唯一的选择。</p><p id="ddb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将展示如何在不重新运行模型的情况下进行推荐。我们将构建一个推荐器类</p><ul class=""><li id="f1c6" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">使用Surprise library在大群体中只需计算一次参数，</li><li id="c3be" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">当您输入新的单个用户评级时，返回推荐项目的有序列表。</li></ul><p id="a8fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们关注的是<code class="fe mj mk ml mm b">KNNWithMeans</code>模型，这是在我的项目中导致最高<code class="fe mj mk ml mm b">RMSE</code>分数的模型类型，但是该方法也可以很容易地针对<code class="fe mj mk ml mm b">KNNBasic</code>或<code class="fe mj mk ml mm b">KNNWithZScores</code>模型进行调整。你可以在我的<a class="ae ky" href="https://github.com/MatePocs/boardgame_recommendation" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>里找到整个项目的代码。</p><h2 id="eddb" class="mn mo it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">数学背景</h2><p id="d6c9" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">正如我提到的，我不想重复我以前的帖子，但我认为有一个关于<code class="fe mj mk ml mm b">KNNWithMeans</code>模型背后的数学公式的快速提醒是很好的。<em class="nl"> rᵤᵢ </em>是用户<em class="nl"> u </em>对项目<em class="nl"> i </em>的评分，<em class="nl"> μᵢ </em>是对项目<em class="nl">I【nᵤᵏ(i】所有评分的平均值)</em>是用户<em class="nl"> u </em>评分的项目中“最接近<em class="nl">I】</em>项目的最大<em class="nl"> k </em>数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/4378879c3f2ebf71d8c07217cbcfed0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*jaOk6u_yJuqcQ6EqK5qQ5A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">surprise的KNNWithMeans模型中的估计用户评分</p></figure><h2 id="7d10" class="mn mo it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">计划</h2><p id="5565" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">我们将利用这一事实来估计用户<em class="nl"> u </em>将如何基于他们的其他评价来评价项目<em class="nl"> i </em>，我们需要的是:</p><ul class=""><li id="509f" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">其他项目的平均评分，或<em class="nl">μᵢ</em>；</li><li id="04d2" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">物品之间的相似性，或者说<em class="nl"> sim </em> ( <em class="nl"> i，j </em>)。</li></ul><p id="0a82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将创建一个名为<code class="fe mj mk ml mm b">KNNWithMeans_Recommender</code>的类，它有三个参数:</p><ul class=""><li id="ed23" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">sim_dataframe</code>:一个<code class="fe mj mk ml mm b">pandas</code> <code class="fe mj mk ml mm b">DataFrame</code>对象，一个带有项目间相似性的方阵。我们不关心使用哪种方法，可以是<code class="fe mj mk ml mm b">cosine</code>、<code class="fe mj mk ml mm b">pearson</code>或<code class="fe mj mk ml mm b">MSD</code>。列名应该与索引名(项目的名称)相同，顺序相同。</li><li id="31bb" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">average_ratings_by_item</code> : a <code class="fe mj mk ml mm b">pandas</code> <code class="fe mj mk ml mm b">Series</code>，每个项目的平均评分，其中指数为项目名称。这将提供<code class="fe mj mk ml mm b">KNN</code>模型的“带手段”部分。</li><li id="7669" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">k_factor</code>:一个整数，用于限制我们在评估评级时考虑的相邻项目的数量。</li></ul><p id="4df6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们稍后将研究如何创建这些参数，现在，我们将重点放在推荐器类上。当我们初始化一个对象时，保存这些参数就是全部了。</p><p id="3a5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该类将有两个功能:<code class="fe mj mk ml mm b">estimate_all_for_user</code>和<code class="fe mj mk ml mm b">estimate_item</code>。</p><p id="6dac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，当我们与类交互时，我们将使用<code class="fe mj mk ml mm b">estimate_all_for_user</code>。它将有一个参数，<code class="fe mj mk ml mm b">user_input_dict</code>,这是一个字典，其中条目名称是键，等级是值。(后面我们会看到一个例子。)该函数遍历用户没有评级的项目，并使用<code class="fe mj mk ml mm b">estimate_item</code>函数来估计评级。该函数将返回一个字典，其中键是项目名称，值是估计的评级。</p><p id="68be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个函数，<code class="fe mj mk ml mm b">estimate_item</code>将基本上是我们前面看到的数学公式，使用相似性和每个项目的平均评分。</p><h2 id="6062" class="mn mo it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">密码</h2><p id="ce9b" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">下一个块包含我们刚刚描述的类的Python代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="728e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，考虑到我们刚刚讨论了结构，我省略了上面要点中的大部分文档字符串和注释。如果你确实想使用代码，我建议从我的GitHub repo中复制<a class="ae ky" href="https://github.com/MatePocs/boardgame_recommendation/blob/master/recomm_func.py" rel="noopener ugc nofollow" target="_blank">原文</a>。(有一些命名上的区别，我的项目本来是一个boardgame推荐系统，所以“物品”和“游戏”是可以互换使用的。)</p><h2 id="d6b5" class="mn mo it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">如何使用—输入参数</h2><p id="67b7" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">首先，我们将讨论如何为我们的<code class="fe mj mk ml mm b">KNNWithMeans_Recommender</code>对象创建所需的参数。</p><p id="d823" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">先说<code class="fe mj mk ml mm b">average_ratings_by_item</code>，我们需要一个<code class="fe mj mk ml mm b">pandas</code> <code class="fe mj mk ml mm b">Series</code>，其中项目名称是指标，评分是数值。我认为您不能从<code class="fe mj mk ml mm b">surprise</code>库中生成这个，但是您可以简单地使用<code class="fe mj mk ml mm b">groupby</code>方法，假设您在一个名为<code class="fe mj mk ml mm b">df</code>的对象中有所有的评级:</p><pre class="kj kk kl km gt np mm nq nr aw ns bi"><span id="c46f" class="mn mo it mm b gy nt nu l nv nw">avg_ratings_by_item = \<br/>    df.groupby('item_name').mean()['rating'].copy()</span></pre><p id="49fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mj mk ml mm b">sim_dataframe</code>稍微复杂一点。我打算先把所有东西都保存在一个文件里，这样以后更容易利用。我们需要两样东西:相似性和项目名称。</p><p id="3e75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe mj mk ml mm b">surprise</code>中，kNN类型的模型有一个<code class="fe mj mk ml mm b">sim</code>方法，该方法将以<code class="fe mj mk ml mm b">numpy</code> <code class="fe mj mk ml mm b">array</code>格式返回相似性矩阵，不包含索引。我使用<code class="fe mj mk ml mm b">numpy</code>将它保存在一个名为pearson_sim的<code class="fe mj mk ml mm b">csv</code>文件中。</p><pre class="kj kk kl km gt np mm nq nr aw ns bi"><span id="a885" class="mn mo it mm b gy nt nu l nv nw">my_sim_option = {'name':'pearson', 'user_based':False}<br/>model = KNNWithMeans(sim_options = my_sim_option, verbose = False)<br/>model.fit(trainsetfull)</span><span id="5644" class="mn mo it mm b gy nx nu l nv nw">np.savetxt('./results/pearson_sim.csv', model.sim, delimiter=',')</span></pre><p id="1091" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要注意两件事:</p><ul class=""><li id="6bb9" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">在上面的代码中，我使用了<code class="fe mj mk ml mm b">pearson</code>相似度，但是还有其他可用的相似度，参见<a class="ae ky" href="https://surprise.readthedocs.io/en/stable/similarities.html" rel="noopener ugc nofollow" target="_blank">文档</a>。我使用了<code class="fe mj mk ml mm b">pearson</code>,因为这导致了我的项目中最高的<code class="fe mj mk ml mm b">RMSE</code>分数。</li><li id="488b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">对于这一步，你从惊喜库中使用哪个KNN模型可能并不重要，相似性是以同样的方式计算的。为了保持一致，我们可以使用<code class="fe mj mk ml mm b">KNNWithMeans</code>。</li></ul><p id="8ecd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一步是获取项目名称，它们将被用作索引和列名。我们可以使用惊喜库的<code class="fe mj mk ml mm b">all_items</code>和<code class="fe mj mk ml mm b">to_raw_iid</code>功能(再次请参考<a class="ae ky" rel="noopener" target="_blank" href="/how-to-build-a-memory-based-recommendation-system-using-python-surprise-55f3257b2cf4">我之前的帖子</a>了解详情)。</p><pre class="kj kk kl km gt np mm nq nr aw ns bi"><span id="c6dc" class="mn mo it mm b gy nt nu l nv nw">trainsetfull_iids = list(trainsetfull.all_items())<br/>iid_converter = lambda x: trainsetfull.to_raw_iid(x)<br/>trainsetfull_raw_iids = list(map(iid_converter, trainsetfull_iids))</span></pre><p id="b1b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我还将这些保存在一个<code class="fe mj mk ml mm b">csv</code>文件中:</p><pre class="kj kk kl km gt np mm nq nr aw ns bi"><span id="e891" class="mn mo it mm b gy nt nu l nv nw">with open('./results/item_ids_for_sim_matrix.csv', 'w') as f:<br/>    writer = csv.writer(f)<br/>    writer.writerows(zip(trainsetfull_raw_iids, trainsetfull_iids))</span></pre><p id="460c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后在项目的后期，我将这两个文件，评级和项目列表合并到一个名为<code class="fe mj mk ml mm b">pearson_sim</code>的<code class="fe mj mk ml mm b">DataFrame</code>中。这将是我们创建推荐对象时要传递的参数。</p><pre class="kj kk kl km gt np mm nq nr aw ns bi"><span id="9275" class="mn mo it mm b gy nt nu l nv nw">pearson_sim = \<br/>    pd.read_csv('./results/pearson_sim.csv', header = None)</span><span id="5351" class="mn mo it mm b gy nx nu l nv nw">sim_matrix_itemlist = \  <br/>    pd.read_csv(<br/>        './results/item_ids_for_sim_matrix.csv', header = None)</span><span id="28f2" class="mn mo it mm b gy nx nu l nv nw">pearson_sim.columns = sim_matrix_itemlist[0]<br/>pearson_sim.index = sim_matrix_itemlist[0]</span></pre><p id="b451" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将结果保存在文件中并将它们组合起来并不是最有效的解决方案，但是我发现这是一种干净的结构，可以方便地在过程的不同区域处理这些结果。</p><h2 id="07d8" class="mn mo it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">如何使用—预测</h2><p id="55e5" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">好了，有趣的部分来了！</p><p id="6a8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们需要导入该类，假设您将文件命名为recomm_func.py:</p><pre class="kj kk kl km gt np mm nq nr aw ns bi"><span id="bb87" class="mn mo it mm b gy nt nu l nv nw">from recomm_func import kNNWithMeans_Recommender</span></pre><p id="b594" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，您可以通过传递我们刚刚讨论过的两个输入参数和一个用于<code class="fe mj mk ml mm b">k_factor</code>的整数来初始化一个新对象:</p><pre class="kj kk kl km gt np mm nq nr aw ns bi"><span id="8a9e" class="mn mo it mm b gy nt nu l nv nw">recommender = kNNWithMeans_Recommender(<br/>    pearson_sim, average_ratings_by_item, 10)</span></pre><p id="ff18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我提到的，我用这个项目来建立一个棋盘游戏推荐器，一个用户输入的例子是，如果你喜欢棋盘游戏，你可以看到这个测试用户更喜欢欧洲风格的标题:</p><pre class="kj kk kl km gt np mm nq nr aw ns bi"><span id="099c" class="mn mo it mm b gy nt nu l nv nw">user_input = {<br/>    'Le Havre': 8,<br/>    'Concordia': 9,<br/>    'The Castles of Burgundy': 8,<br/>    'Mansions of Madness: Second Edition': 5,<br/>    'Kingdom Death: Monster':6<br/>}</span></pre><p id="01e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mj mk ml mm b">estimate_all_for_user</code>方法返回一个包含所有项目和估计评分的字典，下面块中的下一行根据评分对它们进行排序，这样我们可以很容易地确定推荐给用户的前N个游戏。</p><pre class="kj kk kl km gt np mm nq nr aw ns bi"><span id="2d79" class="mn mo it mm b gy nt nu l nv nw">estimated_ratings = recommender.estimate_all_for_user(user_input)</span><span id="afd0" class="mn mo it mm b gy nx nu l nv nw">sorted_ratings = \<br/>    sorted(estimated_ratings.items(), key=lambda x: x[1])</span></pre><p id="65eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过对sorted_ratings进行切片，我们可以获得前10个推荐:</p><pre class="kj kk kl km gt np mm nq nr aw ns bi"><span id="ee57" class="mn mo it mm b gy nt nu l nv nw">sorted_ratings[-10:]</span></pre><p id="fbb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将返回以下列表:</p><pre class="kj kk kl km gt np mm nq nr aw ns bi"><span id="94e8" class="mn mo it mm b gy nt nu l nv nw">[('Agricola', 7.436929246134879),<br/>('Agricola (Revised Edition)', 7.456466489174002),<br/>('Through the Ages: A New Story of Civilization', 7.46818223297934),<br/>('Orléans', 7.4808225652209),<br/>('Terra Mystica', 7.498203401133102),<br/>('Terraforming Mars', 7.5063889188525685),<br/>('Gaia Project', 7.621611348138763),<br/>('Puerto Rico', 7.665136353318606),<br/>('Great Western Trail', 7.786750410443334),<br/>('Brass: Birmingham', 7.82265622044594)]</span></pre><p id="1491" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">再一次，作为一个桌游爱好者，这些建议对我这个特定的测试用户来说是有意义的。</p><p id="3533" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过从前面分割<code class="fe mj mk ml mm b">sorted_ratings</code>列表，该代码还可以用于制作反推荐，即用户可能不喜欢的项目。如果你对其他不同的测试用户推荐感兴趣，请查看<a class="ae ky" href="https://github.com/MatePocs/boardgame_recommendation/blob/master/04_results_data_and_predictions.ipynb" rel="noopener ugc nofollow" target="_blank">这款Jupyter笔记本的结尾</a>。</p><h2 id="32a1" class="mn mo it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">结论</h2><p id="fee4" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">这就结束了我们在定制推荐功能上的工作。在我看来，一旦建立起来，这个类使用起来真的很方便，而且它使我的项目的代码结构更加精简。一个额外的优势是，你可以利用从早期阶段保存的惊喜库的结果，而不必依赖于当前环境中的库。</p><p id="282e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你觉得它有用，请随意在你的项目中使用代码，如果你遇到任何问题，请告诉我。</p><h2 id="6cb5" class="mn mo it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">参考</h2><div class="ny nz gp gr oa ob"><a href="https://surprise.readthedocs.io/en/stable/index.html" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd iu gy z fp og fr fs oh fu fw is bi translated">欢迎使用“惊喜”文档！-惊喜1文档</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">如果您对惊喜感到陌生，我们邀请您看一看入门指南，在那里您会找到一系列…</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">surprise.readthedocs.io</p></div></div></div></a></div><div class="ny nz gp gr oa ob"><a rel="noopener follow" target="_blank" href="/how-to-build-a-memory-based-recommendation-system-using-python-surprise-55f3257b2cf4"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd iu gy z fp og fr fs oh fu fw is bi translated">如何使用Python Surprise构建基于内存的推荐系统</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">使用Python中的Surprise库实现kNN风格推荐引擎的分步指南，来自data…</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">towardsdatascience.com</p></div></div><div class="ok l"><div class="ol l om on oo ok op ks ob"/></div></div></a></div></div></div>    
</body>
</html>