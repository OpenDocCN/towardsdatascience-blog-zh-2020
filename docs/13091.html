<html>
<head>
<title>Regular expressions in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中的正则表达式</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/regular-expressions-in-python-2f79e37f8dff?source=collection_archive---------45-----------------------#2020-09-08">https://towardsdatascience.com/regular-expressions-in-python-2f79e37f8dff?source=collection_archive---------45-----------------------#2020-09-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="24aa" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在 re 模块中搜索并拆分<strong class="ak">功能</strong></h2></div><h2 id="600a" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">简介</strong></h2><p id="83ea" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj ko lk ll lm ks ln lo lp kw lq lr ls lt ij bi translated">正则表达式或<em class="lu"> regex </em>是一个字符序列，用于检查每个文本(字符串)中是否存在模式，例如，找出“123”是否存在于“Practical123DataScie”中。regex 解析器将“123”解释为在字符串中只匹配自身的普通字符。但是正则表达式的真正威力在于当一个<em class="lu">模式</em>包含称为<strong class="ld ir"> <em class="lu">元字符</em> </strong>的特殊字符时。这些对于正则表达式匹配引擎有着独特的意义，并极大地增强了搜索能力。</p><p id="85c3" class="pw-post-body-paragraph lb lc iq ld b le lv jr lg lh lw ju lj ko lx ll lm ks ly lo lp kw lz lr ls lt ij bi translated">Regex 功能驻留在一个名为<code class="fe ma mb mc md b"><em class="lu">re</em></code>的模块中。因此，像 Python 中的所有模块一样，我们只需要如下导入它就可以开始工作了。</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="4946" class="kf kg iq md b gy mm mn l mo mp">import re</span></pre><p id="cf6d" class="pw-post-body-paragraph lb lc iq ld b le lv jr lg lh lw ju lj ko lx ll lm ks ly lo lp kw lz lr ls lt ij bi translated">本教程涵盖了<em class="lu"> re </em>模块中非常有用的函数，例如分别用于搜索和替换的<em class="lu"> search() </em>和<em class="lu"> split() </em>。您还将学习用元字符创建复杂的匹配模式。</p><h2 id="d958" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">我)。搜索()功能</strong></h2><p id="b477" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj ko lk ll lm ks ln lo lp kw lq lr ls lt ij bi translated">正则表达式搜索通常被写成:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="0617" class="kf kg iq md b gy mm mn l mo mp">re.search(<em class="lu">pattern</em>, <em class="lu">string</em>)</span></pre><p id="ddc6" class="pw-post-body-paragraph lb lc iq ld b le lv jr lg lh lw ju lj ko lx ll lm ks ly lo lp kw lz lr ls lt ij bi translated">这个函数遍历字符串，找到与模式匹配的第一个位置。如果不匹配，则返回 None。让我们看看下面的例子:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="0944" class="kf kg iq md b gy mm mn l mo mp">s1= "Practical123DataScie"<br/>re.search("123", s1)</span><span id="0497" class="kf kg iq md b gy mq mn l mo mp">Output: &lt;re.Match object; span=(9, 12), match='123'&gt;</span></pre><p id="131b" class="pw-post-body-paragraph lb lc iq ld b le lv jr lg lh lw ju lj ko lx ll lm ks ly lo lp kw lz lr ls lt ij bi translated">输出为您提供了大量信息。它告诉你有一个匹配，并位于字符串的 s[9:12]。这是一个简单的例子，我们可能需要搜索复杂的模式。现在想象一下，你想找三个类似“456”或者“789”的连续数字。在这种情况下，我们需要使用模式，因为我们在寻找连续的数字，而我们不知道这些数字到底是什么。它们可能是“124”、“052”等等。我们如何做到这一点？</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="d5d0" class="kf kg iq md b gy mm mn l mo mp">s2 = “PracticalDataScie052”<br/>re.search(‘[0–9][0–9][0–9]’, s2)</span><span id="671d" class="kf kg iq md b gy mq mn l mo mp">Output: &lt;re.Match object; span=(17, 20), match='052'&gt;</span></pre><p id="c04f" class="pw-post-body-paragraph lb lc iq ld b le lv jr lg lh lw ju lj ko lx ll lm ks ly lo lp kw lz lr ls lt ij bi translated">这里有很多概念要讲。这里用的图案是<code class="fe ma mb mc md b">‘[0-9][0-9][0-9]’. </code>先来说说方括号<em class="lu"> ([]) </em>。正则表达式或模式<em class="lu"> […] </em>告诉你匹配方括号中的任何单个字符。例如:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="c95d" class="kf kg iq md b gy mm mn l mo mp">re.search(‘[0]’, s2)</span><span id="3b64" class="kf kg iq md b gy mq mn l mo mp">Output: &lt;re.Match object; span=(17, 18), match='0'&gt;</span></pre><p id="ab2f" class="pw-post-body-paragraph lb lc iq ld b le lv jr lg lh lw ju lj ko lx ll lm ks ly lo lp kw lz lr ls lt ij bi translated">这个模式'[0]'告诉在 s2 字符串中定位字符 0，如果匹配就打印出来。如果我需要定位更多字符，比如三个数字，我可以写:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="9219" class="kf kg iq md b gy mm mn l mo mp">re.search(‘[0][5][2]’, s2)</span><span id="ec57" class="kf kg iq md b gy mq mn l mo mp">Output: &lt;re.Match object; span=(17, 20), match='052'&gt;</span></pre><p id="f6a4" class="pw-post-body-paragraph lb lc iq ld b le lv jr lg lh lw ju lj ko lx ll lm ks ly lo lp kw lz lr ls lt ij bi translated">好吧，你是对的。我可以只输入' 052 '作为一个模式，在 s2 字符串中定位它，但是现在事情变得有趣了。我可以在方括号内创建另一个正则表达式，例如用于范围。我这么说是什么意思？这意味着使用<em class="lu"> (-) </em>，我可以定位一系列字符。例如:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="2bed" class="kf kg iq md b gy mm mn l mo mp">re.search(‘[0–9]’, s2)</span><span id="303a" class="kf kg iq md b gy mq mn l mo mp">Output: &lt;re.Match object; span=(17, 18), match='0'&gt;</span></pre><p id="7977" class="pw-post-body-paragraph lb lc iq ld b le lv jr lg lh lw ju lj ko lx ll lm ks ly lo lp kw lz lr ls lt ij bi translated">意思是找出 s2 内从 0 到 9 的任意一个数字。现在，让我们回到定位三个连续数字的问题上来。为此，我可以简单地写:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="366c" class="kf kg iq md b gy mm mn l mo mp">re.search(‘[0–9][0–9][0–9]’, s2)</span><span id="13c5" class="kf kg iq md b gy mq mn l mo mp">Output: &lt;re.Match object; span=(17, 20), match='052'&gt;</span></pre><p id="99ec" class="pw-post-body-paragraph lb lc iq ld b le lv jr lg lh lw ju lj ko lx ll lm ks ly lo lp kw lz lr ls lt ij bi translated">每个方括号内的每个范围告诉你在 s2 字符串中找出一个数字。我也可以使用字母范围。例如:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="bd65" class="kf kg iq md b gy mm mn l mo mp">re.search(‘[a-z][0–9]’, s2)</span><span id="71a9" class="kf kg iq md b gy mq mn l mo mp">Output: &lt;re.Match object; span=(16, 18), match='x0'&gt;</span></pre><p id="f32c" class="pw-post-body-paragraph lb lc iq ld b le lv jr lg lh lw ju lj ko lx ll lm ks ly lo lp kw lz lr ls lt ij bi translated">这个例子告诉我们定位两个字符。第一个，任何小写字母，第二个字符应该是数字。输出(' x0 ')正是我们期望得到的。正则表达式<em class="lu"> '\d' </em>等于' 0–9 '。所以，对于前面的例子，我也可以用:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="bc17" class="kf kg iq md b gy mm mn l mo mp">re.search(‘[a-z][\d]’, s2)</span><span id="4b9e" class="kf kg iq md b gy mq mn l mo mp">Output: &lt;re.Match object; span=(16, 18), match='x0'&gt;</span></pre><h2 id="fce3" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">二世)。split()函数</strong></h2><p id="1e4d" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj ko lk ll lm ks ln lo lp kw lq lr ls lt ij bi translated">与搜索函数类似，正则表达式拆分通常写成:</p><p id="ce31" class="pw-post-body-paragraph lb lc iq ld b le lv jr lg lh lw ju lj ko lx ll lm ks ly lo lp kw lz lr ls lt ij bi translated">重新拆分(<em class="lu">图案</em>、<em class="lu">串</em>)</p><p id="685d" class="pw-post-body-paragraph lb lc iq ld b le lv jr lg lh lw ju lj ko lx ll lm ks ly lo lp kw lz lr ls lt ij bi translated">这个函数使用模式作为分隔符分割字符串，并将子字符串作为列表返回。让我们看看下面的例子:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="9074" class="kf kg iq md b gy mm mn l mo mp">re.split(‘[;]’, ‘Data;Science and; Data Analysis;courses’)</span><span id="76b6" class="kf kg iq md b gy mq mn l mo mp">Output: ['Data', 'Science and', ' Data Analysis', 'courses']</span></pre><p id="ed90" class="pw-post-body-paragraph lb lc iq ld b le lv jr lg lh lw ju lj ko lx ll lm ks ly lo lp kw lz lr ls lt ij bi translated">在这个例子中，模式是[；]，这意味着我们有分号(；)作为分隔符。只要字符串中有分号，它就会在那个位置被拆分并保存在一个列表中。我们可以有不止一个分隔符。让我们看一个更复杂的例子。</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="64ee" class="kf kg iq md b gy mm mn l mo mp">string = “Data12Science567programbyAWS025GoogleCloud”<br/>re.split(‘\d+’, string)</span><span id="75b4" class="kf kg iq md b gy mq mn l mo mp">Output: ['Data', 'Science', 'programbyAWS', 'GoogleCloud']</span></pre><p id="90cb" class="pw-post-body-paragraph lb lc iq ld b le lv jr lg lh lw ju lj ko lx ll lm ks ly lo lp kw lz lr ls lt ij bi translated">在这个例子中，我们的模式是' \d+'，我们都知道' \d '模式表示任何数字(0 到 9)。通过在末尾添加一个“+”符号，将使模式匹配至少一个或多个数字。因此，在这种情况下，我们看到任何连续的数字都将被认为是分隔的，并且子字符串在列表中返回。</p><p id="cb65" class="pw-post-body-paragraph lb lc iq ld b le lv jr lg lh lw ju lj ko lx ll lm ks ly lo lp kw lz lr ls lt ij bi translated">让我们考虑下面的字符串。我有两门【课程号】【编程语言】【课程名称】格式的课程。字符串写在两个不同的行中，单词之间的间距不相等。</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="4a62" class="kf kg iq md b gy mm mn l mo mp">string = ‘’’101              Python       DataScience <br/>                  102           R      DataAnalysis’’’<br/>re.split(‘\s+’, string)</span><span id="f68c" class="kf kg iq md b gy mq mn l mo mp">Output: ['101', 'Python', 'DataScience', '102', 'R', 'DataAnalysis']</span></pre><p id="0c03" class="pw-post-body-paragraph lb lc iq ld b le lv jr lg lh lw ju lj ko lx ll lm ks ly lo lp kw lz lr ls lt ij bi translated">在本例中，' \s '模式匹配任何空白字符。通过在其末尾添加加号“+”，该模式将匹配至少 1 个或更多空格。</p><h2 id="2c79" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak"> III)结论</strong></h2><p id="87d8" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj ko lk ll lm ks ln lo lp kw lq lr ls lt ij bi translated">本教程中已经讨论了 re 模块中的搜索和分割功能。使用元字符创建不同的模式，在文本挖掘中会非常有益。</p></div></div>    
</body>
</html>