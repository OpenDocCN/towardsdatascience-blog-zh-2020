<html>
<head>
<title>Methods in Python: Fundamentals for Data Scientists</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中的方法:数据科学家的基础</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/methods-in-python-fundamentals-for-data-scientists-6a9393b2c2e7?source=collection_archive---------47-----------------------#2020-06-08">https://towardsdatascience.com/methods-in-python-fundamentals-for-data-scientists-6a9393b2c2e7?source=collection_archive---------47-----------------------#2020-06-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9dd9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用一个具体的例子来理解基础！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7e9091513cf5aa5509bab18118ff9ca3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*l-NTlJbZuW7rIXbU"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">制造者在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae ky" href="https://unsplash.com/@nesabymakers?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> NESA 的照片</a></p></figure><p id="5edb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python 类可以保存以下函数:</p><ul class=""><li id="b123" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">一个类的一部分<strong class="lb iu">(类方法)</strong></li><li id="8ccd" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">实例的一部分<strong class="lb iu">(实例方法)</strong></li><li id="1605" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">既不属于类也不属于实例<strong class="lb iu">(静态方法)</strong></li></ul><p id="d50e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每种方法都有不同的用例。如果你理解了基本原理，你就可以非常清晰地编写面向对象的 Python 代码。</p><p id="3f45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章将向你介绍这些方法的基础知识和它们的用例。</p><p id="edf4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用 Python3 编写一个包含所有三种方法类型的简单示例的类；</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="a5a7" class="mo mp it mk b gy mq mr l ms mt">import pandas as pd<br/>import random</span><span id="3418" class="mo mp it mk b gy mu mr l ms mt"><em class="mv">class</em> CSVGetInfo:<br/><strong class="mk iu">""" This class displays the summary of the tabular data contained in a CSV file """</strong></span><span id="f4da" class="mo mp it mk b gy mu mr l ms mt"><strong class="mk iu"># Initializer / Instance Attributes</strong><br/><em class="mv">def</em> __init__(<em class="mv">self</em>, <em class="mv">path</em>, <em class="mv">file_name</em>):<br/> CSVGetInfo.increase_instance_count()<br/> self.path = path<br/> self.file_name = file_name</span><span id="3b21" class="mo mp it mk b gy mu mr l ms mt"><strong class="mk iu"># Instance Methods</strong><br/><em class="mv">def</em> display_summary(<em class="mv">self</em>):<br/> data = pd.read_csv(self.path + self.file_name)<br/> print(self.file_name)<br/> print(data.head(self.generate_random_number(10)))<br/> print(data.info())</span><span id="86e8" class="mo mp it mk b gy mu mr l ms mt"><strong class="mk iu"># Class Methods<br/></strong>@<em class="mv">classmethod<br/>def</em> increase_instance_count(<em class="mv">cls</em>):<br/> cls.instance_count += 1<br/> print(cls.instance_count)</span><span id="f0ae" class="mo mp it mk b gy mu mr l ms mt">@<em class="mv">classmethod<br/>def</em> read_file_1(<em class="mv">cls</em>):<br/> return cls("/Users/erdemisbilen/Lessons/", "data_by_artists.csv")</span><span id="94a1" class="mo mp it mk b gy mu mr l ms mt">@<em class="mv">classmethod<br/>def</em> read_file_2(<em class="mv">cls</em>):<br/> return cls("/Users/erdemisbilen/Lessons/", "data_by_genres.csv")</span><span id="68a1" class="mo mp it mk b gy mu mr l ms mt"><strong class="mk iu"># Static Methods</strong><br/>@<em class="mv">staticmethod<br/>def</em> generate_random_number(<em class="mv">limit</em>):<br/> return random.randint(1, limit)</span><span id="9984" class="mo mp it mk b gy mu mr l ms mt">if __name__ == '__main__':<br/> data_by_artists = CSVGetInfo.read_file_1()<br/> data_by_genres = CSVGetInfo.read_file_2()</span><span id="385b" class="mo mp it mk b gy mu mr l ms mt"> data_by_artists.display_summary()<br/> data_by_genres.display_summary()</span></pre></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/b7f41dd4a4a02bf835fca7d2cbfffed6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7xAu_LBNX64u09DB"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@skylarfaithfilm?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Skylar Sahakian </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="873d" class="ne mp it bd nf ng nh ni nj nk nl nm nn jz no ka np kc nq kd nr kf ns kg nt nu bi translated">实例方法</h1><p id="c975" class="pw-post-body-paragraph kz la it lb b lc nv ju le lf nw jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">实例方法是类结构中最常用的方法。任何在类结构中定义的函数都是一个实例方法，除非用 decorators 声明。所以，你不需要装饰器来定义实例方法。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="4380" class="mo mp it mk b gy mq mr l ms mt"><strong class="mk iu"># Instance Method</strong></span><span id="0716" class="mo mp it mk b gy mu mr l ms mt"><em class="mv">def</em> display_summary(<em class="mv">self</em>):<br/> data = pd.read_csv(self.path + self.file_name)<br/> print(self.file_name)<br/> print(data.head(self.generate_random_number(10)))<br/> print(data.info())</span></pre><p id="ec0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们采用一个隐式参数，<strong class="lb iu"> <em class="mv"> self </em> </strong> <em class="mv">，</em>表示方法被调用时实例本身。</p><p id="f4d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">借助<strong class="lb iu"><em class="mv">self</em></strong><em class="mv"/>参数，实例方法可以访问实例变量(属性)和同一对象中的其他实例方法。</p><h1 id="e78b" class="ne mp it bd nf ng nh ni nj nk nl nm nn jz no ka np kc nq kd nr kf ns kg nt nu bi translated">何时使用实例方法</h1><p id="6e34" class="pw-post-body-paragraph kz la it lb b lc nv ju le lf nw jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">实例方法是类结构的核心，它们定义了类的行为。</p><p id="9f95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用特定于实例的数据来执行实例方法中定义的任务。他们可以在<strong class="lb iu"> <em class="mv"> self </em> </strong>参数的帮助下访问实例中包含的唯一数据。</p><p id="22bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的示例中，我们有两个<strong class="lb iu"> CSVGetInfo </strong>类的实例，它们分别存储不同的文件名值“data_by_artists.csv”和“data _ by _ genres.csv”。<strong class="lb iu"><em class="mv">display _ summary(self)</em></strong>的实例方法通过访问每个实例特有的值来执行任务。</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/eae8a63abeed3f8aa1f2241c9a258cb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FzGveRh5fqMyw6J8"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@travisgergen?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Travis Gergen </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="e0fb" class="ne mp it bd nf ng nh ni nj nk nl nm nn jz no ka np kc nq kd nr kf ns kg nt nu bi translated">类方法</h1><p id="9fd6" class="pw-post-body-paragraph kz la it lb b lc nv ju le lf nw jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">代替实例方法接受的<strong class="lb iu"> <em class="mv"> self </em> </strong>参数，类方法接受一个<strong class="lb iu"> <em class="mv"> cls </em> </strong>隐式参数。<strong class="lb iu"> <em class="mv"> cls </em> </strong>代表类本身，而不是类(对象)的实例。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="e1ce" class="mo mp it mk b gy mq mr l ms mt"><strong class="mk iu"># Class Methods</strong></span><span id="0946" class="mo mp it mk b gy mu mr l ms mt">@<em class="mv">classmethod<br/>def</em> increase_instance_count(<em class="mv">cls</em>):<br/> cls.instance_count += 1<br/> print(cls.instance_count)</span><span id="6965" class="mo mp it mk b gy mu mr l ms mt">@<em class="mv">classmethod<br/>def</em> read_file_1(<em class="mv">cls</em>):<br/> return cls("/Users/erdemisbilen/Lessons/", "data_by_artists.csv")</span><span id="d955" class="mo mp it mk b gy mu mr l ms mt">@<em class="mv">classmethod<br/>def</em> read_file_2(<em class="mv">cls</em>):<br/> return cls("/Users/erdemisbilen/Lessons/", "data_by_genres.csv")</span></pre><p id="14f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，类方法不能修改对象的状态，因为我们需要<strong class="lb iu"> <em class="mv"> self </em> </strong>参数来这样做。相反，他们可以修改对该类的所有实例都有效的类状态。</p><p id="752a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类方法的编写类似于任何其他方法，但用<strong class="lb iu"> '@classmethod' </strong>修饰，并采用<strong class="lb iu"> <em class="mv"> cls </em> </strong>参数。</p><h1 id="2be2" class="ne mp it bd nf ng nh ni nj nk nl nm nn jz no ka np kc nq kd nr kf ns kg nt nu bi translated">何时使用类方法</h1><p id="b305" class="pw-post-body-paragraph kz la it lb b lc nv ju le lf nw jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">您不必为了使用类方法而创建实例，因为类方法直接绑定到类，而不是绑定到特定的实例/对象。</p><p id="441c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此它们用于管理类级操作，如下所列；</p><ul class=""><li id="8b4c" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><strong class="lb iu">实例创建:</strong>类方法可用作对象的工厂，以简化设置和实例化工作。</li><li id="7b4b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">实例管理:</strong>我们可以限制一个类可以创建的实例数量。</li><li id="ad94" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">班级水平查询:它们可以用来提供有关班级的有用信息，例如；创建的实例数。</li><li id="29b2" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">测试</strong></li><li id="bb01" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">例子:</strong>类方法可以提供类用法的例子，这样其他人可以很容易地理解如何使用类。</li></ul></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="f028" class="ne mp it bd nf ng ob ni nj nk oc nm nn jz od ka np kc oe kd nr kf of kg nt nu bi translated">静态方法</h1><p id="b45c" class="pw-post-body-paragraph kz la it lb b lc nv ju le lf nw jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">静态方法不带任何隐式参数。由于不能带<strong class="lb iu"> <em class="mv"> self </em> </strong>和<strong class="lb iu"> <em class="mv"> cls </em> </strong>参数，所以既不能修改对象状态，也不能修改类状态。</p><p id="e13b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们就像带有<strong class="lb iu"> '@staticmethod' </strong>修饰的类的名称空间内的独立方法。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="b571" class="mo mp it mk b gy mq mr l ms mt"><strong class="mk iu"># Static Methods</strong></span><span id="471c" class="mo mp it mk b gy mu mr l ms mt">@<em class="mv">staticmethod<br/>def</em> generate_random_number(<em class="mv">limit</em>):<br/> return random.randint(1, limit)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/bbc6bb45b929ecb2b53be3ab0bd565a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SJgCM6SCOue7JUWT"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@zhenhappy?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">潘晓珍</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><h1 id="ae51" class="ne mp it bd nf ng nh ni nj nk nl nm nn jz no ka np kc nq kd nr kf ns kg nt nu bi translated">何时使用静态方法</h1><p id="0843" class="pw-post-body-paragraph kz la it lb b lc nv ju le lf nw jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">由于静态方法是完全独立的代码，它们不能访问类中的任何东西。它们主要使用传递给它们的参数来处理实用程序任务。因此，它们被用作助手或实用函数。</p><h1 id="d24e" class="ne mp it bd nf ng nh ni nj nk nl nm nn jz no ka np kc nq kd nr kf ns kg nt nu bi translated">关键外卖</h1><p id="74da" class="pw-post-body-paragraph kz la it lb b lc nv ju le lf nw jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">使用 decorators 并正确地标记方法可以让其他人更好地理解我们的意图和类结构。随着其他人更好地理解我们的类架构和正确分配的装饰器，其他开发人员不正确使用我们的类的可能性就更小了。它提供了维护的好处，并有助于防止错误和失误。</p><h1 id="dc82" class="ne mp it bd nf ng nh ni nj nk nl nm nn jz no ka np kc nq kd nr kf ns kg nt nu bi translated"><strong class="ak">结论</strong></h1><p id="9e7f" class="pw-post-body-paragraph kz la it lb b lc nv ju le lf nw jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">在这篇文章中，我解释了 Python 中方法类型的基础。</p><p id="8558" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章中的代码和使用的 CSV 文件可以在<a class="ae ky" href="https://github.com/eisbilen/MethodsExampleClass" rel="noopener ugc nofollow" target="_blank">我的 GitHub 库中找到。</a></p><p id="740c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这篇文章对你有用。</p><p id="b956" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读！</p></div></div>    
</body>
</html>