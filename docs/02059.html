<html>
<head>
<title>Writing good SQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写优秀的 SQL</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/writing-good-sql-ccb578ff9919?source=collection_archive---------7-----------------------#2020-02-27">https://towardsdatascience.com/writing-good-sql-ccb578ff9919?source=collection_archive---------7-----------------------#2020-02-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2e6c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过适配层来进一步结构化查询语言</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/952b147d8a62b9ae8a4595d7874219c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*D3gRPl7eWfc3h9pI"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@nci?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">国家癌症研究所</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="5d1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你想写出好的 SQL 吗？当然，但是“好”实际上是什么意思？</p><p id="3462" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在某些实时环境中，只有性能被认为是“好的”,并且您以毫秒来度量您的执行时间。在商业智能和数据仓库环境中，性能仍然很重要，但通常可维护性更有价值。这可能是一个更好的解决方案，产生可读和可维护的 SQL 代码，即使它每月都要耗费大量的资金。请记住理解复杂查询的时间成本、潜在错误产生的成本以及修复错误的时间。根据您的数据库引擎优化器，您通常会两者兼得。因此，在本文中，我们关注可读性和可维护性。</p><p id="7535" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我假设您已经知道 SQL 的基本和更高级的元素:连接、分组、子查询或分析函数。结合这些元素，你可以很快产生一个大混乱。但是，我们能做些什么来保持具有数百行和 20 个或更多表格的大型查询的可读性呢？</p><h1 id="50d5" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">最基本的</h1><p id="34f7" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">当我们说可读性时，我们不得不谈论风格。Simon Holywel  l 有一篇很棒的<a class="ae ky" href="https://www.sqlstyle.guide" rel="noopener ugc nofollow" target="_blank"> SQL 风格指南，看看吧。但是如果你很匆忙，你可以用这三个建议走得很远:</a></p><ul class=""><li id="0399" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">对所有保留的关键字使用大写，如 SELECT、FROM 或 WHERE，对列、表和符号名称使用小写</li><li id="c777" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">通过将关键字对齐到右边，将值对齐到左边，创建一个间隙</li></ul><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="0e7a" class="nl lw it nh b gy nm nn l no np">SELECT first_name, last_name, birth_date<br/>  FROM emp.employees<br/> WHERE gender = ‘F’;</span></pre><ul class=""><li id="55d4" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">每当查询变得比简单的 SELECT/FROM/WHERE 语句复杂时，就使用注释</li></ul><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="1616" class="nl lw it nh b gy nm nn l no np"> /* find highest actual salary for each employee */<br/>SELECT first_name, last_name, MAX(salary)<br/>  FROM emp.employees e<br/>  JOIN emp.salaries s<br/>    ON e.emp_no = s.emp_no<br/> WHERE current_date BETWEEN from_date AND to_date -- filter date<br/> GROUP BY first_name, last_name;</span></pre><p id="8c02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这些基本规则，您的 SQL 将很容易达到至少中等的可读性水平。随着您的 SQL 变得越来越大和越来越复杂，您将达到一定的极限，在这里您需要比样式指南提供的更多的结构。</p><h1 id="e39b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">子查询，或者痛苦从哪里开始</h1><p id="dcc1" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">你知道子查询吗？子查询非常适合将问题封装在查询块中。基本上，SELECT 语句中有三种类型的子查询:</p><ul class=""><li id="18ed" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">在 FROM 子句中，作为具有别名的派生表</li></ul><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="c38b" class="nl lw it nh b gy nm nn l no np">SELECT COUNT(*)<br/>  FROM (SELECT gender<br/>          FROM emp.employees) e</span></pre><ul class=""><li id="b028" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">作为限定符放在 WHERE 子句中</li></ul><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="5577" class="nl lw it nh b gy nm nn l no np">SELECT *<br/>  FROM emp.employees e<br/> WHERE 0 &lt; (SELECT COUNT(*)<br/>              FROM emp.salaries s<br/>             WHERE s.emp_no=e.emp_no<br/>               AND salary &gt; 3000)</span></pre><p id="78ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，这也是一个相关子查询，应该小心使用(参见<a class="ae ky" href="https://en.wikipedia.org/wiki/Correlated_subquery" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Correlated_subquery</a>)。</p><ul class=""><li id="2e9f" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">标量子查询(也称为相关子查询)</li></ul><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="6e0c" class="nl lw it nh b gy nm nn l no np">SELECT last_name, (SELECT MAX(salary)<br/>                     FROM emp.salaries<br/>                    WHERE emp_no=e.emp_no)<br/>  FROM emp.employees e</span></pre><h1 id="d903" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">那么问题出在哪里呢？</h1><p id="7cc8" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">子查询可以有更多任意深度的子查询。当您从子查询开始时，随着时间的推移，很可能会出现更多的子查询。其他人会以你为榜样。每个子查询都需要缩进，行变得越来越长。这是更复杂语句可读性的主要问题。</p><p id="5c2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更重要的是，每个子查询都将周围的查询分成代码“before”和“after”。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/c3c9eb5e99e554b58bf59b67614ccd25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/0*Q9CLrPWlGjOAk4-8"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">查询中间的子查询</p></figure><p id="f037" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在过程化时代，编码的黄金法则之一是:</p><blockquote class="nr"><p id="9074" class="ns nt it bd nu nv nw nx ny nz oa lu dk translated">不要写比你的屏幕大的块</p></blockquote><p id="c0f0" class="pw-post-body-paragraph kz la it lb b lc ob ju le lf oc jx lh li od lk ll lm oe lo lp lq of ls lt lu im bi translated">(一个屏幕有 25 行)。但是如果中间有一个子查询，那么在 SELECT 块和 WHERE 子句的列之间可以有数百行。</p><p id="abbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这导致了一种有趣的阅读 SQL 查询的方式。通常，你从中间的某个地方开始，慢慢地向边缘发展。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/3b4697aec78f80b9ce4f019f60283759.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/0*zm--fSIMaoTxlUUK"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">带有子查询的读取方向</p></figure><p id="1017" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种“从里到外”的阅读方向与我们通常的从上到下的阅读方向相反，我们大多数人都很习惯这种阅读方向。</p><h1 id="b94d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">的力量</h1><p id="9043" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们中的一些人编写 SQL 多年，但从未使用过 WITH 子句。试试看，值得！</p><p id="e8be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在 WITH 子句中，可以给子查询一个符号名，就像在 FROM 子句中一样，同时将它移到语句的开头。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="ba0e" class="nl lw it nh b gy nm nn l no np">WITH t_avg_salary AS (<br/>    --averagy salary for every employee<br/>    SELECT emp_no, AVG(salary) avg_salary<br/>      FROM emp.salaries<br/>     GROUP BY emp_no<br/>)<br/>SELECT e.last_name, avg_salary<br/>  FROM emp.employees e<br/>  JOIN t_avg_salary<br/>    ON e.emp_no = t_avg_salary.emp_no<br/> WHERE avg_salary &lt; 3000;</span></pre><p id="ed3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并且您可以构建一个子查询的“管道”,这些子查询相互建立</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="8290" class="nl lw it nh b gy nm nn l no np">WITH t_avg_salary AS (<br/>    -- average salary for every employee<br/>    SELECT emp_no, AVG(salary) avg_salary<br/>      FROM emp.salaries<br/>     GROUP BY emp_no<br/>),<br/>t_avg_salary_3k AS (<br/>    -- limit to avg. salary smaller 3k<br/>    SELECT *<br/>      FROM t_avg_salary<br/>     WHERE avg_salary &lt; 3000<br/>),<br/>t_employee AS (<br/>    -- Join employee and salary<br/>    SELECT e.last_name, avg_salary<br/>      FROM emp.employees e<br/>      JOIN t_avg_salary_3k<br/>        ON e.emp_no = t_avg_salary_3k.emp_no<br/>)<br/>SELECT *<br/>  FROM t_employee;</span></pre><p id="22db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这带来了以下进步:</p><ul class=""><li id="efee" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">因为每个子查询本身都是一个块，所以功能是相互分离的</li><li id="70f5" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">每个子查询都可以获得自己的标题注释，这明显提高了可理解性</li><li id="14ea" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">你可以自上而下地阅读你的代码，这对可读性很好</li><li id="b24b" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">每个子查询都以固定的缩进量从行首开始。因此，遵循团队的编码风格指南会有更少的问题，该指南通常将行长度限制在 80 个字符以内</li><li id="0729" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">向查询中添加功能(或更多子查询)不会强制您重新格式化整个查询。这导致了你的版本控制系统的细微变化。例如，取消平均工资限额:</li></ul><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="c08f" class="nl lw it nh b gy nm nn l no np">7,12d6<br/>&lt; t_avg_salary_3k AS (<br/>&lt;     -- limit to avg. salary smaller 3k<br/>&lt;     SELECT *<br/>&lt;       FROM t_avg_salary<br/>&lt;      WHERE avg_salary &lt; 3000<br/>&lt; ),<br/>17c11<br/>&lt; JOIN t_avg_salary_3k<br/> ---<br/>&gt; JOIN t_avg_salary</span></pre><p id="4579" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">保持子查询块较小，重点放在单一功能上。不要混合功能，例如连接、过滤、分组、映射。</p><p id="4013" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后但同样重要的是，使最后一个块非常简单，只有 SELECT 和 FROM。把它想象成一个层模型。第一个模块用于数据采集，最后一个模块仅用于输出。如果你把更多的功能放进去，你会像开始时一样结束。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/106e7298eb7f5cc50c708553dd9893e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/0*ib7cedqjjZR_4-w2"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用多个子查询分层</p></figure><h1 id="f9d0" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">额外收获:构建特性在 SQL 中切换</h1><p id="a650" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在大型系统中使用 SQL 时，通常会涉及到变量替换。如果您试图在 SQL 的两个功能之间切换，很快就会得到难看的代码。</p><p id="6815" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用 WITH，您可以轻松地将数据库名称、表名称或不同的配置参数放入配置节中。而且，您可以使用它来打开和关闭块的使用。</p><p id="5688" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您有一个前面讨论过的子查询流。其中一个实现了对“薪金&lt; 3000”的限制，这应该只在您的代码的较新版本中有效。</p><p id="6894" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将最后一个子查询中的连接表替换为变量“t_avg_salary”(此处为 python f-string 格式):</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="1d93" class="nl lw it nh b gy nm nn l no np">WITH<br/>…<br/>t_emp_join AS (<br/>    -- Join employee and salary<br/>    SELECT last_name, avg_salary<br/>      FROM t_employee e<br/>      JOIN t_avg_salary_3k s<br/>        ON e.emp_no = s.emp_no<br/>)<br/>SELECT *<br/>  FROM t_employee;</span></pre><p id="e32b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">“t_avg_salary”的可能值现在是“t_avg_salary”和“t_avg_salary_3k”。</p><p id="8945" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过更改“t_avg_salary”切换变量，您可以更改 SQL 的输出，而无需更改代码。您是创建一个伪派生表，还是简单地使用下面的派生表取决于您。</p><p id="dfe0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单地跳过中间的子查询。</p></div></div>    
</body>
</html>