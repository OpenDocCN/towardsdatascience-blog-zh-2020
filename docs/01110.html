<html>
<head>
<title>Power of Parallel Processing in Data Science.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据科学中并行处理的力量。</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/power-of-parallel-processing-in-data-science-ea64ec3dcd61?source=collection_archive---------28-----------------------#2020-01-31">https://towardsdatascience.com/power-of-parallel-processing-in-data-science-ea64ec3dcd61?source=collection_archive---------28-----------------------#2020-01-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f560" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">知道何时进入并行模式以及如何充分利用并行模式的艺术。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c5e5a2ff31b7d4d2683f9ebbadc88015.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*D2FMxQB-0fczdIpb"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@tirzavandijk?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">蒂尔扎·范·迪克</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="0329" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我们大多数人都有平行做事的习惯。想象一下，你去杂货店，接到一个朋友的电话，于是你们开始聊天，同时买东西。单词“<strong class="lf ir">同时”</strong>暗示了我们将注意力分配到不同任务的能力。但是注意力的分散经常会降低效率和表现，因为我们的大脑一次只能专注于一件事。</p><p id="ff96" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">同样的概念是否适用于并行解决数据科学的问题？</p><p id="d1e1" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">答案是:<strong class="lf ir"> <em class="lz">取决于手头的问题和可用的计算资源</em> </strong>。</p><p id="c718" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">因此，让我们打开构建并行解决方案所需的组件</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="47b6" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">划分问题空间</h1><p id="e9ac" class="pw-post-body-paragraph ld le iq lf b lg ms jr li lj mt ju ll lm mu lo lp lq mv ls lt lu mw lw lx ly ij bi translated">默认情况下，并行问题需要被分割成块，以便每个块可以被馈送到不同的计算节点。这样，我们可以将它们分为两种类型:</p><ul class=""><li id="671a" class="mx my iq lf b lg lh lj lk lm mz lq na lu nb ly nc nd ne nf bi translated"><strong class="lf ir">按任务</strong>:想到盖房子。您可以并行执行许多任务，例如，管道、电气、安装窗户等。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">并行工作的工人</p></figure><p id="ee07" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">现在，在数据科学的背景下，考虑从相同的人口数据中导出的两个模型，一个用于理解<em class="lz">出生因素</em>，另一个用于<em class="lz">推理死亡</em>。</p><ul class=""><li id="8bd7" class="mx my iq lf b lg lh lj lk lm mz lq na lu nb ly nc nd ne nf bi translated"><strong class="lf ir">按数据</strong>:相同的任务，但在不同的数据块上。例如，在同一栋房子里，所有的窗户都可以平行安装。在数据科学场景中，我们会遇到需要对不同的数据集/数据子集应用相同的建模函数的情况。例如，使用直方图绘制全球不同国家的温度分布。</li></ul><p id="3529" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">了解划分技术只是解决并行问题的第一步。最重要的方面是了解您想要在其上训练或部署模型的系统。无论是在台式机、网络系统还是超级计算机上完成的工作都很重要，因为它构成了执行计算的骨干处理器。所以让我们解开它的建筑概念。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="4382" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated"><strong class="ak">并行计算的标准</strong></h1><ol class=""><li id="ebaf" class="mx my iq lf b lg ms lj mt lm ni lq nj lu nk ly nl nd ne nf bi translated">需要至少两个处理器(核心)或通过网络连接的单核/多核计算机集群。例如，<a class="ae kv" href="https://www.kaggle.com/notebooks" rel="noopener ugc nofollow" target="_blank"> kaggle 内核</a>提供了四核功能，现在几乎所有系统都具备这种功能，甚至我们的手机也不例外。</li><li id="4550" class="mx my iq lf b lg nm lj nn lm no lq np lu nq ly nl nd ne nf bi translated"><a class="ae kv" href="https://en.wikipedia.org/wiki/Shared_memory" rel="noopener ugc nofollow" target="_blank">共享内存模型</a>帮助进程共享相同的数据，从而节省时间。</li><li id="841f" class="mx my iq lf b lg nm lj nn lm no lq np lu nq ly nl nd ne nf bi translated"><a class="ae kv" href="https://en.wikipedia.org/wiki/Distributed_memory" rel="noopener ugc nofollow" target="_blank">分布式内存</a>:进程不能访问另一个进程的内存。称为消息传递系统，因为进程通过相互发送消息来进行通信。</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/29154b7c8e725fb956e1108945c06815.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m5QncFhAha5icM7g4r2Pzw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">共享内存和分布式内存</p></figure><p id="649c" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">因此，为了使用编程语言构建模型，它们的大多数实例(会话)利用系统的单核。R 和 Python<em class="lz">就是这样的例子。默认情况下，它们运行在单核上，除非您明确指定和构建代码以适应并行环境。</em></p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="bcb5" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">将并行问题融入编程环境</h1><p id="5e1e" class="pw-post-body-paragraph ld le iq lf b lg ms jr li lj mt ju ll lm mu lo lp lq mv ls lt lu mw lw lx ly ij bi translated">当构建并行代码<strong class="lf ir">时，主从模型</strong>用于描述并行工作场景</p><ul class=""><li id="43c4" class="mx my iq lf b lg lh lj lk lm mz lq na lu nb ly nc nd ne nf bi translated">它<strong class="lf ir"> </strong>用于主创建工人并在他们之间分配任务的情况。工作进程执行它们任务并将结果返回给主进程，主进程反过来执行</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/e33d18d89bc4902399daf41b9d105bb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hR61UaxlDrOX2e5uHbdwkA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">主工人模型</p></figure><ul class=""><li id="653b" class="mx my iq lf b lg lh lj lk lm mz lq na lu nb ly nc nd ne nf bi translated">对于需要综合解决方案的问题，master 向工人交付第一批任务，然后等待结果。在收集完所有结果后，它发送第二批任务，再次等待结果，以此类推。</li><li id="bb4e" class="mx my iq lf b lg nm lj nn lm no lq np lu nq ly nc nd ne nf bi translated">虽然主工人模式看起来很有益，但它缺乏处理负载平衡问题的能力。例如，假设有 4 个工人，主人给他们第一批任务。其中 2 名工人完成了任务，2 名工人仍在工作。现在，主人需要等待所有 4 名工人的结果，才能给第二批任务。因此，增加了两个空闲工人的等待时间。</li></ul></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="129f" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated"><strong class="ak">令人尴尬的平行问题</strong></h1><p id="730b" class="pw-post-body-paragraph ld le iq lf b lg ms jr li lj mt ju ll lm mu lo lp lq mv ls lt lu mw lw lx ly ij bi translated">通常情况下，并行任务之间不存在依赖关系，因此使用术语“令人尴尬的并行问题”。例如，从目录中读取不同的文件。</p><p id="a675" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">这种并行问题倾向于很少或不需要任务之间的中间结果的通信，因此不同于需要任务之间通信的分布式计算问题。</p><h1 id="1278" class="ma mb iq bd mc md nt mf mg mh nu mj mk jw nv jx mm jz nw ka mo kc nx kd mq mr bi translated">结束注释</h1><p id="2130" class="pw-post-body-paragraph ld le iq lf b lg ms jr li lj mt ju ll lm mu lo lp lq mv ls lt lu mw lw lx ly ij bi translated">在这篇博客中，主要目标是理解并行处理的领域。不是所有的问题都可以用并行处理来解决，也不是所有的并行问题都可以节省时间。</p><p id="3cde" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">对于较小的任务，使用并行任务的计算效果可能不那么富有成效，但是当处理依赖于多个数据源的复杂问题集时，将并行处理集成到解决方案中的能力可能是有益的。</p><p id="4c4d" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">要在编程环境中实现并行问题，请尝试浏览以下博客:</p><div class="ny nz gp gr oa ob"><a href="https://www.business-science.io/code-tools/2016/12/18/multidplyr.html" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd ir gy z fp og fr fs oh fu fw ip bi translated">加速您的代码:使用 multidplyr 进行并行处理</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">没有什么比等待长时间运行的 R 脚本迭代运行更令人沮丧的了。我最近遇到了…</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">www .商业科学. io</p></div></div><div class="ok l"><div class="ol l om on oo ok op kp ob"/></div></div></a></div><div class="ny nz gp gr oa ob"><a href="https://blog.dominodatalab.com/multicore-data-science-r-python/" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd ir gy z fp og fr fs oh fu fw ip bi translated">使用 R 和 Python 的多核数据科学</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">本文摘自 R 和 Python 中多核数据科学的完整视频。观看完整视频了解…</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">blog.dominodatalab.com</p></div></div><div class="ok l"><div class="oq l om on oo ok op kp ob"/></div></div></a></div><div class="ny nz gp gr oa ob"><a href="https://www.kaggle.com/gravc91/introduction-to-parallel-programming-in-r" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd ir gy z fp og fr fs oh fu fw ip bi translated">R 语言并行编程简介</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">使用 Kaggle 笔记本探索和运行机器学习代码|使用来自非数据源的数据</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">www.kaggle.com</p></div></div><div class="ok l"><div class="or l om on oo ok op kp ob"/></div></div></a></div></div></div>    
</body>
</html>