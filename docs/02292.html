<html>
<head>
<title>Distributed Text Preprocessing with Python and Dask</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于 Python 和 Dask 的分布式文本预处理</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/distributed-text-preprocessing-with-python-and-dask-5312a4d26ae?source=collection_archive---------30-----------------------#2020-03-04">https://towardsdatascience.com/distributed-text-preprocessing-with-python-and-dask-5312a4d26ae?source=collection_archive---------30-----------------------#2020-03-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="1b92" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://medium.com/tag/daskdistributedml/latest" rel="noopener">用 Python 和 Dask 进行分布式机器学习</a></h2><div class=""/><div class=""><h2 id="a616" class="pw-subtitle-paragraph ka jc it bd b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dk translated"><em class="jz">一种扩展您的数据争论任务的方法</em></h2></div><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ks"><img src="../Images/9f1e87f0d8a173132d8fc598df9770a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KX_Souy44oqP6DM5_gXimA.jpeg"/></div></div><p class="le lf gj gh gi lg lh bd b be z dk translated">照片由<a class="ae li" href="https://unsplash.com/@ilumire?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Jelleke Vanooteghem </a>在<a class="ae li" href="https://unsplash.com/s/photos/words?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><p id="0e30" class="pw-post-body-paragraph lq lr it ls b lt lu ke lv lw lx kh ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">如果你已经<a class="ae li" rel="noopener" target="_blank" href="/set-up-a-dask-cluster-for-distributed-machine-learning-31f587b1b553">组装了一个独立的集群</a>，并且对<a class="ae li" rel="noopener" target="_blank" href="/distributed-machine-learning-with-python-and-dask-introduction-328a86571049">Dask 如何在后台<em class="mm">工作</em></a>有了足够的了解，那么是时候学习一些实用的数据科学了。对了，你可以在我的<a class="ae li" href="https://github.com/PabloSalvadorLopez10" rel="noopener ugc nofollow" target="_blank"> GitHub 账号</a>里找到我所有的源代码和数据。</p><h2 id="c795" class="mn mo it bd mp mq mr dn ms mt mu dp mv lz mw mx my md mz na nb mh nc nd ne iz bi translated">我们试图预测什么？</h2><p id="0209" class="pw-post-body-paragraph lq lr it ls b lt nf ke lv lw ng kh ly lz nh mb mc md ni mf mg mh nj mj mk ml im bi translated">我想根据文本将亚马逊产品的评论分为正面或负面。显然，在将数据输入到 ML 训练管道之前，我需要对数据进行一些转换。</p><h2 id="daf4" class="mn mo it bd mp mq mr dn ms mt mu dp mv lz mw mx my md mz na nb mh nc nd ne iz bi translated"><strong class="ak">数据呢？</strong></h2><p id="3506" class="pw-post-body-paragraph lq lr it ls b lt nf ke lv lw ng kh ly lz nh mb mc md ni mf mg mh nj mj mk ml im bi translated">我使用的是亚马逊提供的公开数据集，有 300 万条评论和评级。这是一个 1.5 GB 的中型数据集，但是本文的目的是展示如何以及为什么使用<strong class="ls jd"> Dask </strong>来处理更大的数据集。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h2 id="d29d" class="mn mo it bd mp mq mr dn ms mt mu dp mv lz mw mx my md mz na nb mh nc nd ne iz bi translated"><em class="jz">加载集群</em></h2><p id="d435" class="pw-post-body-paragraph lq lr it ls b lt nf ke lv lw ng kh ly lz nh mb mc md ni mf mg mh nj mj mk ml im bi translated">在进入我们的笔记本之前，我们需要几个快速命令来准备好我们的独立集群。如果您遇到问题，这篇文章将指导您创建一个好的独立集群。</p><p id="6038" class="pw-post-body-paragraph lq lr it ls b lt lu ke lv lw lx kh ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">首先，与您的每台机器建立一个 SSH 连接。让我们从您想要选择作为调度程序的机器开始。您只需要输入以下命令:</p><pre class="kt ku kv kw gt nk nl nm nn aw no bi"><span id="f5b7" class="mn mo it nl b gy np nq l nr ns">dask-scheduler</span></pre><p id="c91e" class="pw-post-body-paragraph lq lr it ls b lt lu ke lv lw lx kh ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我的独立 Dask 集群有两个工人(机器)。如果要将这些节点与调度程序连接，需要在“Worker node”终端运行以下命令:</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi nt"><img src="../Images/895ade481d2cebb6980905e3f9fd6541.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NtiNwN9BB4zC5D-z32nbkQ.jpeg"/></div></div><p class="le lf gj gh gi lg lh bd b be z dk translated">调度程序节点</p></figure><p id="5a06" class="pw-post-body-paragraph lq lr it ls b lt lu ke lv lw lx kh ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">现在，您必须将其他机器作为工作节点连接起来。为此，您需要在调度程序终端输入以下命令。在下面的例子中，调度器节点的 IP 是<code class="fe nu nv nw nl b">10.1.1.93</code>，Dask 应该连接的端口是<code class="fe nu nv nw nl b">8786</code>。</p><pre class="kt ku kv kw gt nk nl nm nn aw no bi"><span id="83cb" class="mn mo it nl b gy np nq l nr ns"># You should specify the IP and port of the scheduler node as below. </span><span id="d6ab" class="mn mo it nl b gy nx nq l nr ns">dask-worker tcp://10.1.1.93:8786</span></pre><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ny"><img src="../Images/d2c3d8e6f447fe65bbc73a3a81c1f052.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mAUKrnS5ELKSV9v2tLzKzw.jpeg"/></div></div><p class="le lf gj gh gi lg lh bd b be z dk translated">将第一个工作线程连接到调度程序节点</p></figure><p id="5672" class="pw-post-body-paragraph lq lr it ls b lt lu ke lv lw lx kh ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我将再连接四台机器作为工作节点，这使得我的最终集群有一个调度器节点和五个工作节点。连接每个节点后，您应该会在调度程序终端中看到类似这样的内容:</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi nz"><img src="../Images/42c727f6d6027edd4103489bc7a160d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ce4mEMA8ga3tbr4f6UiyDA.jpeg"/></div></div><p class="le lf gj gh gi lg lh bd b be z dk translated">连接五个工作节点后调度虚拟机</p></figure><p id="23a5" class="pw-post-body-paragraph lq lr it ls b lt lu ke lv lw lx kh ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">恭喜你。现在，您可以开始使用 Jupyter 笔记本了。</p><p id="c994" class="pw-post-body-paragraph lq lr it ls b lt lu ke lv lw lx kh ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">Dask 提供了一个漂亮的仪表板，您可以在其中看到正在运行的进程的所有指标。您可以使用以下命令让它运行:</p><pre class="kt ku kv kw gt nk nl nm nn aw no bi"><span id="cb04" class="mn mo it nl b gy np nq l nr ns"># load the cluster<br/>import dask <br/>from sklearn.externals import joblib<br/>from dask.distributed import Client</span><span id="cf7e" class="mn mo it nl b gy nx nq l nr ns"># IP of the scheduler node.</span><span id="febd" class="mn mo it nl b gy nx nq l nr ns">c = dask.distributed.Client('tcp://10.1.1.93:8786')</span><span id="5594" class="mn mo it nl b gy nx nq l nr ns"># call the cluster </span><span id="577f" class="mn mo it nl b gy nx nq l nr ns">c </span></pre><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/7cb6fdb6e37d2f4546a5246bfaf8e198.png" data-original-src="https://miro.medium.com/v2/resize:fit:1326/format:webp/1*BmtU1Xxd8OGj_7XWIVUwtw.jpeg"/></div></figure><p id="85ca" class="pw-post-body-paragraph lq lr it ls b lt lu ke lv lw lx kh ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">单击 dashboard 链接，它应该会在您的浏览器中打开一个新选项卡。Dask 的仪表板可以让你实时看到每个工人正在做的所有计算。太棒了，对吧？</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ob"><img src="../Images/55b698f48731e5ab5855c24eca2922b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-T4WmgQCTXn1YaPZGT4QfQ.jpeg"/></div></div><p class="le lf gj gh gi lg lh bd b be z dk translated">Dask 仪表板</p></figure><h2 id="b18a" class="mn mo it bd mp mq mr dn ms mt mu dp mv lz mw mx my md mz na nb mh nc nd ne iz bi translated">Dask 数据帧</h2><p id="a307" class="pw-post-body-paragraph lq lr it ls b lt nf ke lv lw ng kh ly lz nh mb mc md ni mf mg mh nj mj mk ml im bi translated">按照以下示例将数据加载到 Dask 数据帧中。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi oc"><img src="../Images/09b06456b44be8235f8a89bbf9988ae4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uM-zqmRDzyLYFQp5dS7WCA.png"/></div></div></figure><p id="34ac" class="pw-post-body-paragraph lq lr it ls b lt lu ke lv lw lx kh ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">让我们看看 Dask 生成的数据帧:</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div class="gh gi od"><img src="../Images/4e4276ca5c592b16484529d9aebc8c4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*A5RVEOQqFArOw5NnbcKqhg.jpeg"/></div><p class="le lf gj gh gi lg lh bd b be z dk translated">Dask 数据帧</p></figure><p id="85a4" class="pw-post-body-paragraph lq lr it ls b lt lu ke lv lw lx kh ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">哇！它看起来和熊猫的数据帧很不一样，对吗？这是因为两个主要原因:</p><ul class=""><li id="a220" class="oe of it ls b lt lu lw lx lz og md oh mh oi ml oj ok ol om bi translated">Dask 的<code class="fe nu nv nw nl b">read_csv</code>函数将数据分成小熊猫分区，让我们可以处理大数据集。在我们的例子中，Dask 将 1.5 GB 的数据集分成 22 个分区，使我们有 68.18 MB 的分区。作为一般建议，当您处理较大的数据集时，您的数据块应该足够小，以便它们中的大部分可以一次放入一个工作者的可用内存中。当您选择 Dask 数据帧中的分区大小或 Dask 数组中的块大小时，您可以控制这一点。</li><li id="be48" class="oe of it ls b lt on lw oo lz op md oq mh or ml oj ok ol om bi translated">Dask 使用<a class="ae li" rel="noopener" target="_blank" href="/distributed-machine-learning-with-python-and-dask-introduction-328a86571049">惰性计算</a>比如 Spark。Dask 是一个图形执行引擎，所以所有不同的任务都被延迟，这意味着在您点击函数<code class="fe nu nv nw nl b">.compute()</code>之前，没有任何函数被实际执行。在上面的例子中，我们有 66 个延迟的任务。</li></ul><p id="6d4a" class="pw-post-body-paragraph lq lr it ls b lt lu ke lv lw lx kh ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">让我们点击<code class="fe nu nv nw nl b">.compute()</code>，看看会发生什么。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div class="gh gi os"><img src="../Images/d89e16427f874d11ca8129dee42ee9cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/format:webp/1*qT62ZvWEeHIYwxBFdN8kmQ.jpeg"/></div></figure><p id="7a99" class="pw-post-body-paragraph lq lr it ls b lt lu ke lv lw lx kh ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated"><code class="fe nu nv nw nl b">.compute</code>函数将 22 个小分区组装成一个包含 300 万条评论的 pandas DataFrame。如果您的数据集很大，不要这样做，因为这样做会使您将数据集放入单台机器的本地内存中，这是 Dask 试图避免的。</p><h2 id="632a" class="mn mo it bd mp mq mr dn ms mt mu dp mv lz mw mx my md mz na nb mh nc nd ne iz bi translated">缺少值</h2><p id="abe3" class="pw-post-body-paragraph lq lr it ls b lt nf ke lv lw ng kh ly lz nh mb mc md ni mf mg mh nj mj mk ml im bi translated">检查缺失值类似于在熊猫数据帧上执行<code class="fe nu nv nw nl b">.isnull() </code>功能。但是记住，如果你想看到结果，你必须点击<code class="fe nu nv nw nl b">.compute()</code>。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ot"><img src="../Images/d637aaca94ad22557412d4bba11dfc66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eEUw9ANt36tzXjaFHdzEPg.jpeg"/></div></div><p class="le lf gj gh gi lg lh bd b be z dk translated">缺少值</p></figure><p id="fb4a" class="pw-post-body-paragraph lq lr it ls b lt lu ke lv lw lx kh ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">好消息是，在我们的示例数据集中没有需要处理的缺失值。</p><h2 id="2771" class="mn mo it bd mp mq mr dn ms mt mu dp mv lz mw mx my md mz na nb mh nc nd ne iz bi translated">描述统计学</h2><p id="4d6b" class="pw-post-body-paragraph lq lr it ls b lt nf ke lv lw ng kh ly lz nh mb mc md ni mf mg mh nj mj mk ml im bi translated">让我们简要地看一下 table 中的前五行数据，这样我们就可以看到我们正在处理哪种类型的值。Dask dataframes 允许您使用 pandas 功能，如<code class="fe nu nv nw nl b">.head()</code>、<code class="fe nu nv nw nl b">.groupby()</code>、<code class="fe nu nv nw nl b">.loc()</code>、<code class="fe nu nv nw nl b">.merge()</code>等。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ou"><img src="../Images/9a0f25c7cc0669f2e288be3cd1ab6d9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sZi3u_XL2DkkRK4R998PQA.jpeg"/></div></div><p class="le lf gj gh gi lg lh bd b be z dk translated">数据帧</p></figure><p id="4c9e" class="pw-post-body-paragraph lq lr it ls b lt lu ke lv lw lx kh ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我们有三个栏目:<em class="mm">标题、评论和评分</em>。我想知道我们是否正在处理数据中的不平衡，因此我将计算我的目标变量(评级)的值。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ov"><img src="../Images/40d22244984f4ef1f2ef215dba53fd6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m92z-e_16GPkgZxFc3O6gw.jpeg"/></div></div></figure><p id="b8b7" class="pw-post-body-paragraph lq lr it ls b lt lu ke lv lw lx kh ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">这看起来是一个非常好的“训练”数据集，因为这些类被平等地表示。我们不需要担心应用技术来解决不平衡的数据。</p><p id="5348" class="pw-post-body-paragraph lq lr it ls b lt lu ke lv lw lx kh ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">您肯定可以使用更复杂的 EDA 进行文本分析，如查找最常用的术语、LDA 主题检测、基于产品的聚类评论等，从而为您的训练数据集添加新功能。然而，这些主题超出了本文的范围。</p><p id="59fc" class="pw-post-body-paragraph lq lr it ls b lt lu ke lv lw lx kh ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">到目前为止，我认为您已经明白了这一点——Dask 是 Python 用户的友好库，允许您使用<strong class="ls jd">大数据</strong>。</p><h2 id="c0df" class="mn mo it bd mp mq mr dn ms mt mu dp mv lz mw mx my md mz na nb mh nc nd ne iz bi translated">数据争论</h2><p id="954e" class="pw-post-body-paragraph lq lr it ls b lt nf ke lv lw ng kh ly lz nh mb mc md ni mf mg mh nj mj mk ml im bi translated">例如，如果我们要建立一个二元分类问题，我们需要将评论分为“正面”或“负面”。亚马逊用户将这些评论评为 1-5 星。为了转换这一点，我假设将从 1 到 3 颗星的评级分类为负面，并用值 0 标记它们，反之亦然。</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="7958" class="pw-post-body-paragraph lq lr it ls b lt lu ke lv lw lx kh ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">请记住——Dask 以这样一种方式转换您的场景，即使您的数据很大，您也可以处理小块的 pandas 数据帧，因此这是迭代所有分区的最优雅和有效的方式。</p><p id="3810" class="pw-post-body-paragraph lq lr it ls b lt lu ke lv lw lx kh ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">让我们来看看数据帧“df2”:</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi oy"><img src="../Images/432d4fa4e39540c1f2fb30f59dfb31f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QLuIb-WGzCEFlOHf9tMQuw.jpeg"/></div></div><p class="le lf gj gh gi lg lh bd b be z dk translated">df2</p></figure><p id="3ee9" class="pw-post-body-paragraph lq lr it ls b lt lu ke lv lw lx kh ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我们创建了一个包含 177 个任务的 DAG。记住，我们不会做任何计算，直到我们点击<code class="fe nu nv nw nl b">.compute()</code>。</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="915f" class="pw-post-body-paragraph lq lr it ls b lt lu ke lv lw lx kh ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">让我们看看转换的输出。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi oz"><img src="../Images/1078c9f27ac71f091c837dc8fa63df6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*moLjLH6AoJvGj62qxwHaGg.jpeg"/></div></div><p class="le lf gj gh gi lg lh bd b be z dk translated">新目标变量</p></figure><p id="6e27" class="pw-post-body-paragraph lq lr it ls b lt lu ke lv lw lx kh ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我们已经成功地将这个问题转化为二进制文本分类。</p><p id="2cb2" class="pw-post-body-paragraph lq lr it ls b lt lu ke lv lw lx kh ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">在清除文本中的干扰之前，我还将“标题”和“评论”功能结合起来。根据这种情况，很明显，最重要的数据点存在于评论中，但有时，重要的数据点也存在于标题中。我想确保我两者都考虑到了。</p><h2 id="40db" class="mn mo it bd mp mq mr dn ms mt mu dp mv lz mw mx my md mz na nb mh nc nd ne iz bi translated">管理内存</h2><p id="27fd" class="pw-post-body-paragraph lq lr it ls b lt nf ke lv lw ng kh ly lz nh mb mc md ni mf mg mh nj mj mk ml im bi translated">在继续之前，了解如何使用 Dask 管理 RAM 的使用是很重要的。</p><p id="2b61" class="pw-post-body-paragraph lq lr it ls b lt lu ke lv lw lx kh ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated"><code class="fe nu nv nw nl b">dask.distributed</code>将任务的结果存储在工作节点的分布式内存中。中央调度程序节点跟踪集群上的所有数据，并确定何时应该释放数据。完成的结果通常会尽快从内存中清除，以便为更多的计算腾出空间。但是，如果您想将数据帧存储在 RAM 中，您应该使用函数<code class="fe nu nv nw nl b">persist</code>。</p><p id="2af0" class="pw-post-body-paragraph lq lr it ls b lt lu ke lv lw lx kh ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated"><strong class="ls jd"/><code class="fe nu nv nw nl b"><strong class="ls jd">compute</strong></code><strong class="ls jd">和</strong> <code class="fe nu nv nw nl b"><strong class="ls jd">persist</strong></code> <strong class="ls jd">有什么区别？</strong></p><p id="6cb8" class="pw-post-body-paragraph lq lr it ls b lt lu ke lv lw lx kh ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated"><code class="fe nu nv nw nl b">compute</code>返回每个输入的单个输出，而<code class="fe nu nv nw nl b">persist</code>返回每个块(或分区)的集合的副本，由单个输出代替。简而言之，使用 persist 在集群上保存一个完整的集合，当您想要一个小的结果作为离散输出时，使用 compute。</p><p id="a9da" class="pw-post-body-paragraph lq lr it ls b lt lu ke lv lw lx kh ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated"><strong class="ls jd">但是你可能会奇怪为什么我要用</strong> <code class="fe nu nv nw nl b"><strong class="ls jd">persist</strong></code> <strong class="ls jd">？</strong></p><p id="9624" class="pw-post-body-paragraph lq lr it ls b lt lu ke lv lw lx kh ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">从 RAM 访问数据通常比从磁盘访问数据快得多。一旦您的数据集处于干净的状态，并且:</p><ol class=""><li id="af20" class="oe of it ls b lt lu lw lx lz og md oh mh oi ml pa ok ol om bi translated">适合内存，而且</li><li id="a5a3" class="oe of it ls b lt on lw oo lz op md oq mh or ml pa ok ol om bi translated">足够干净，你会想尝试许多不同的分析，</li></ol><p id="4273" class="pw-post-body-paragraph lq lr it ls b lt lu ke lv lw lx kh ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">那么这就是把你的数据保存在内存中的好时机。</p><p id="24cd" class="pw-post-body-paragraph lq lr it ls b lt lu ke lv lw lx kh ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">让我们看一个例子:</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi pb"><img src="../Images/0dbfcbc544f5a9927ff8ca8c032603f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HX6iF89TrmE56OAutVkVoQ.jpeg"/></div></div><p class="le lf gj gh gi lg lh bd b be z dk translated">前一部分生成的 df3</p></figure><p id="d02e" class="pw-post-body-paragraph lq lr it ls b lt lu ke lv lw lx kh ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">让我们坚持 df3...</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi pc"><img src="../Images/f58c2547b36425f65d6746d0fc0751be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tsMgq5E5up-AnOdLcPtEJQ.jpeg"/></div></div><p class="le lf gj gh gi lg lh bd b be z dk translated">持续 df</p></figure><p id="606d" class="pw-post-body-paragraph lq lr it ls b lt lu ke lv lw lx kh ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">所以基本上<code class="fe nu nv nw nl b">persist()</code>为每个 Dask 任务返回一个副本，包括它们以前的懒惰计算，现在提交到集群上运行。否则，您可以选择将数据帧保存到本地(不推荐)或以拼花格式保存到集群。</p><p id="9958" class="pw-post-body-paragraph lq lr it ls b lt lu ke lv lw lx kh ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">将 df3 保存到拼花地板:</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="ow ox l"/></div></figure><h2 id="c0e4" class="mn mo it bd mp mq mr dn ms mt mu dp mv lz mw mx my md mz na nb mh nc nd ne iz bi translated">用于机器学习的干净文本</h2><p id="c00c" class="pw-post-body-paragraph lq lr it ls b lt nf ke lv lw ng kh ly lz nh mb mc md ni mf mg mh nj mj mk ml im bi translated">当我们对文本进行矢量化时，我们会将我们的语料库(评论)转换为所谓的“<strong class="ls jd">稀疏矩阵”。稀疏矩阵是主要由零值组成的矩阵。矩阵的稀疏性可以用分数来量化，分数是矩阵中零值的个数除以矩阵中元素的总数。这可能导致空间和时间复杂性方面的问题。因此，清除评论中的噪声对于提高训练和结果模型的性能变得至关重要。我附上了我的清理算法的一部分，但你会在我的 GitHub 上找到更多的部分。</strong></p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="ow ox l"/></div><p class="le lf gj gh gi lg lh bd b be z dk translated">清理数据</p></figure><p id="2184" class="pw-post-body-paragraph lq lr it ls b lt lu ke lv lw lx kh ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">但是我们还需要一个步骤——我们需要对所有的分区应用 clean 函数。为此，使用 Dask 提供的<code class="fe nu nv nw nl b">map_partitons()</code>函数，而不是 pandas 的<code class="fe nu nv nw nl b">map()</code>。</p><p id="0020" class="pw-post-body-paragraph lq lr it ls b lt lu ke lv lw lx kh ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">当你叫<code class="fe nu nv nw nl b">map_partitions</code>(就像你在熊猫上叫<code class="fe nu nv nw nl b">.apply()</code>一样。DataFrame)，您尝试映射(或应用)的函数会将 dataframe 作为第一个参数。</p><p id="2608" class="pw-post-body-paragraph lq lr it ls b lt lu ke lv lw lx kh ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">在<code class="fe nu nv nw nl b">dask.dataframe.map_partitions</code>的情况下，第一个参数将是<strong class="ls jd">一个分区</strong>，在<code class="fe nu nv nw nl b">pandas.DataFrame.apply</code>的情况下，它将是一个完整的数据帧。这意味着您的函数必须接受 dataframe 分区作为第一个参数，您的代码可能如下所示:</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi pd"><img src="../Images/44f406c9aef89bd2386d9920093b9097.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3DmA4zS0AXGch9CvWixHqA.jpeg"/></div></div><p class="le lf gj gh gi lg lh bd b be z dk translated">地图 _ 分区</p></figure><p id="b09b" class="pw-post-body-paragraph lq lr it ls b lt lu ke lv lw lx kh ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">让我们检查结果！</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/2b45f06cfd0ac3f0d0b179627d979dab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*TywXUDCiIYrku8BsR2L09w.jpeg"/></div><p class="le lf gj gh gi lg lh bd b be z dk translated">清洁 df</p></figure><p id="e1f4" class="pw-post-body-paragraph lq lr it ls b lt lu ke lv lw lx kh ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">不错！！我们已经用 Dask 清理了我们的文本！下一部分将展示如何用 Dask 加速你的<a class="ae li" rel="noopener" target="_blank" href="/distributed-machine-learning-with-python-and-dask-2d6bae91a726">算法。</a></p><p id="45f3" class="pw-post-body-paragraph lq lr it ls b lt lu ke lv lw lx kh ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">感谢大量阅读。</p><div class="pf pg gp gr ph pi"><a href="https://github.com/PabloSalvadorLopez10" rel="noopener  ugc nofollow" target="_blank"><div class="pj ab fo"><div class="pk ab pl cl cj pm"><h2 class="bd jd gy z fp pn fr fs po fu fw jc bi translated">PabloSalvadorLopez10 -概述</h2><div class="pp l"><h3 class="bd b gy z fp pn fr fs po fu fw dk translated">在 GitHub 上注册你自己的个人资料，这是托管代码、管理项目和构建软件的最佳地方…</h3></div><div class="pq l"><p class="bd b dl z fp pn fr fs po fu fw dk translated">github.com</p></div></div><div class="pr l"><div class="ps l pt pu pv pr pw lc pi"/></div></div></a></div><h2 id="8e78" class="mn mo it bd mp mq mr dn ms mt mu dp mv lz mw mx my md mz na nb mh nc nd ne iz bi translated">链接</h2><p id="b85a" class="pw-post-body-paragraph lq lr it ls b lt nf ke lv lw ng kh ly lz nh mb mc md ni mf mg mh nj mj mk ml im bi translated"><a class="ae li" href="https://docs.dask.org/en/latest/best-practices.html" rel="noopener ugc nofollow" target="_blank">https://docs.dask.org/en/latest/best-practices.html</a></p><p id="9fc8" class="pw-post-body-paragraph lq lr it ls b lt lu ke lv lw lx kh ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated"><a class="ae li" href="https://docs.dask.org/en/latest/dataframe.html" rel="noopener ugc nofollow" target="_blank">https://docs.dask.org/en/latest/dataframe.html</a></p></div></div>    
</body>
</html>