<html>
<head>
<title>Learning Python 10 minutes a day #24</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">每天 10 分钟学习 Python # 24</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/learning-python-10-minutes-a-day-24-71adee92cb2d?source=collection_archive---------27-----------------------#2020-09-03">https://towardsdatascience.com/learning-python-10-minutes-a-day-24-71adee92cb2d?source=collection_archive---------27-----------------------#2020-09-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/861a215f083567059b0616591c415d2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kjLLayjOlfsSupnd.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae jg" href="https://unsplash.com/@jeremy_justin?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">杰瑞米·拉帕克</a>在<a class="ae jg" href="/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的原始照片。</p></figure><h2 id="83a4" class="jh ji jj bd b dl jk jl jm jn jo jp dk jq translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/10minutespython" rel="noopener" target="_blank">每天 10 分钟 Python 速成班</a></h2><div class=""/><div class=""><h2 id="b1be" class="pw-subtitle-paragraph kp js jj bd b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dk translated">父母、子女和遗产</h2></div><p id="8b06" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这是一个<a class="ae jg" href="https://python-10-minutes-a-day.rocks" rel="noopener ugc nofollow" target="_blank">系列</a>10 分钟的简短 Python 文章，帮助您提高 Python 知识。我试着每天发一篇文章(没有承诺)，从最基础的开始，到更复杂的习惯用法。如果您对 Python 的特定主题有任何问题或要求，请随时通过 LinkedIn 联系我。</p><p id="2980" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">昨天，我们讨论了类以及如何使用面向对象编程(OOP)范例来解决问题。我们创建的对象可以模仿现实生活中的对象，数据和方法都捆绑在类中。我们还讨论了 Python 的一些内部工作方式:它使用<em class="md"> dunder-methods </em>来定义对象之间的交互。我们还没有提到的东西被认为是 OOP 的主要好处:继承。继承是创建一个新的所谓子类的能力，该子类从其父类继承属性。让我们看一个例子来说明这是什么意思:</p><figure class="me mf mg mh gt iv"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="1116" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">虽然这很好，但我们都知道正方形是一种特殊类型的长方形，其长度和宽度都相同。编写两个单独的类看起来很湿，因为对象非常相关，我们可以利用继承:</p><figure class="me mf mg mh gt iv"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="01fc" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在代码方面，我们有一个小小的好处，因为我们不必重复周长和面积的方法。然而，最大的好处是我们在一个地方而不是两个地方有这些方法的定义。如果我们在这两个方法中的一个上犯了错误，我们只需要修正一个定义。</p><p id="c241" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在让我们分析这里实际发生了什么。Rectangle 类没有改变，所以没什么好讨论的。然而，在主定义中，Square 类在括号之间添加了 Rectangle 类。使用这种语法，我们定义 Square 类是以矩形为基础构建的，因此继承了它的所有属性。接下来，我们定义一个构造函数，但是当我们从 Rectangle 类继承所有属性时，我们实际上覆盖了继承的构造函数。新的构造函数只取长度，因为正方形的所有边大小相等。现在来点特别的:我们调用构造函数或父类。为了访问父类，Python 有 super()函数。它返回父类的定义，通过直接调用<em class="md"> dunder init 方法</em>，我们可以调用原始构造函数。原始构造函数需要一个长度和宽度，我们通过输入两次长度来提供。原始构造函数将这些值添加到保存实例数据的<em class="md"> self </em>对象中。新定义也覆盖了<em class="md"> repr dunder 方法</em>。如果我们没有覆盖该方法，它将使用 Rectangle 类中的方法。这是另一个例子:</p><figure class="me mf mg mh gt iv"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="dfeb" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在这个例子中，我们还有一个更一般的类叫做 Animal，还有一个类是 Animal 类的子类。由于继承，Bird 类从 Animal 类获得所有属性。因为它是一只鸟，所以它得到了另一个名为 Fly()的方法，我们覆盖了这个构造函数，这样就简单了一些。</p><figure class="me mf mg mh gt iv gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/6f5ab7e47541b0cfa7f023166ac688ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1178/format:webp/1*FTbU-SUXe9Cot7gX1F2bNQ.jpeg"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">使用 Imgflip.com 生成的迷因</p></figure><p id="250b" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们可以让它变得更有趣。一个子类可以有多个父类，因此可以从多个其他类继承属性。虽然这听起来很神奇，但很快就会变得非常混乱。让我们来看一个有三个不同父类的子类，它们实际上是独立的类，即不是专门为多类继承设计的:</p><figure class="me mf mg mh gt iv"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="b6da" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这里我们有三个独立工作的类。使用多重继承，我们将这三个类组合成一个定义:HeavyRedSquare 类。新类必须调用所有其他构造函数来初始化这些值。我们可以使用 super()函数来做到这一点，但是这看起来很混乱。第一个 super()调用，不带任何参数，调用第一个父类构造函数(括号中最左边的那个)。在第二个 super()调用中，我们传递了两个参数。第一个参数是几何类，第二个参数是该类的实例对象。这里发生的事情是，我们在几何类中，它本身有颜色类作为父类。调用 super()，现在访问 Color()的构造函数。同样的情况发生在第三个 super()调用中。在这个定义中，权重类是颜色类的父类。以这种方式调用 super，可以访问 Weight 类的构造函数。对于更高级别的构造函数，我们需要传递 self 对象。在第一级，即普通超级()中，它被自动传递。这种写作方式让我很困惑。因此，还有另一种方式我更喜欢，在我看来更干净:</p><figure class="me mf mg mh gt iv"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="34d7" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这种方式直接调用类构造函数。因此，我们需要传递 self 对象，即属于这个实例的数据。这是一种我们可以组合对象的方式，也可以独立工作。大多数情况下，当使用继承时，类被设计成一起工作。从这个简单的例子可以看出，它很快就会变得非常复杂。</p><p id="c2a9" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">更常见的是对象是链式继承的。这意味着一个类有一个父类，这个类本身也有一个父类，等等。在 Python 中，一切都是对象，我们已经多次提到过。但我们实际上是指字面意思。Python 中的所有类型都基于对象类型。有一个特殊的<em class="md"> dunder 属性</em>(它不是一个方法)跟踪所有的父节点，顺序是:</p><figure class="me mf mg mh gt iv"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="4d85" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">所有这些继承的一个恼人之处是在对象中找到方法的源代码。当手动查找特定方法的源代码时，我经常不得不在层次结构中从一个类向上查找另一个类。当使用更高级的 IDE 时，这可能更简单一些。</p><p id="6583" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">了解最后一种特殊类型的继承是很重要的:mixins。mixin 是一种设计用来与其他类结合的类，单独实例化没有意义。除了没有构造函数之外，与常规类没有太大区别:</p><figure class="me mf mg mh gt iv"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="5d3a" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">Mixins 非常适合在函数中添加一个通用的保存到磁盘的函数，同样有助于集中您的代码。从这一课中可以学到很多东西。如果你没有得到全部，不要太担心。掌握正在发生的事情是最重要的。继承经常被使用，多重继承不太多。看到后者大多是一个很好的了解。</p><h1 id="3406" class="ml mm jj bd mn mo mp mq mr ms mt mu mv ky mw kz mx lb my lc mz le na lf nb nc bi translated">今天的练习:</h1><p id="1671" class="pw-post-body-paragraph lh li jj lj b lk nd kt lm ln ne kw lp lq nf ls lt lu ng lw lx ly nh ma mb mc im bi translated">继承和混合是很好的概念。让我们一起玩吧。这里有两类形状:</p><figure class="me mf mg mh gt iv"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="5ce2" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jt">赋值:</strong> <br/>写一个 Mixin 来数每个形状的角。</p><p id="1a50" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">一个解决方案是<a class="ae jg" href="https://gist.github.com/dennisbakhuis/1238a441ce9df9b3aceb1290d32a4aac" rel="noopener ugc nofollow" target="_blank">在我的 Github 上发布</a>。</p><p id="23f3" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如有任何问题，欢迎通过<a class="ae jg" href="https://www.linkedin.com/in/dennisbakhuis/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>联系我。</p></div></div>    
</body>
</html>