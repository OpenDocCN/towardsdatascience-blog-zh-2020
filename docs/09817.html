<html>
<head>
<title>The Curious Case of MySQL, PostgreSQL, and Hive</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MySQL、PostgreSQL 和 Hive 的奇特案例</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-curious-case-of-mysql-postgresql-and-hive-9e7cae9e52f4?source=collection_archive---------16-----------------------#2020-07-12">https://towardsdatascience.com/the-curious-case-of-mysql-postgresql-and-hive-9e7cae9e52f4?source=collection_archive---------16-----------------------#2020-07-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2c34" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">MySQL、PostgreSQL 和 Hive 在相同的 SQL 语法下如何表现不同</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c8cb088adb73d4d34618358108d808f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tfJFFaSYmkE8SFjQoI5GRA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@florianolv?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">弗洛里安·奥利佛</a>在<a class="ae ky" href="https://unsplash.com/s/photos/programming?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="66d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在大数据时代，数据的数量、大小和速度都在快速增长，对于数据分析师和数据科学家来说，了解 SQL 仍然是必不可少的。SQL 帮助我们管理传统关系数据库(RDBMS)、分布式集群甚至云环境中的数据。</p><p id="6668" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们在传统的 RDBMS 中处理数据，我们通常会使用像 MySQL 或 PostgreSQL 这样的数据库引擎。然而，随着数据的数量和大小迅速增长，我们不能只使用 RDBMS 来存储所有的数据。这就是我们需要分布式集群来存储和处理大量数据的地方，Hadoop 为我们提供了便利。</p><p id="5acb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您正在使用 Hadoop 生态系统，那么您很可能会使用 Apache Hive 来管理和查询驻留在 Hadoop 分布式文件系统或 HDFS 中的结构化数据。</p><p id="23fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">MySQL、PostgreSQL 和 Hive 都有相似的 SQL 语法，有时我们假设它们会根据给定的 SQL 查询表现相似。然而，事实并非如此。让我们深入一些场景，在相同的 SQL 语法下，PostgreSQL、MySQL 和 Apache Hive 中至少有一个表现不同。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1e3a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">整数的除法运算</h1><p id="0aa0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">除法是 SQL 引擎需要解释的一种复杂的算术运算，不像加法、减法和乘法等其他运算。如果你将两个整数相加、相减或相乘，你将总是得到一个整数，而除法不是这样。您可以将两个整数相除，得到一个小数或一个舍入整数作为结果，这取决于您使用的 SQL 引擎。</p><p id="a12c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在 Hive 和 MySQL 中，如果用<code class="fe mz na nb nc b">/ </code>运算符对两个整数进行除法运算，总会得到一个小数结果。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="b833" class="nh md it nc b gy ni nj l nk nl"><strong class="nc iu">SELECT 32/5</strong></span><span id="7e07" class="nh md it nc b gy nm nj l nk nl">&gt;&gt; result: 6.400000</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/a877bbc7a046a120893fa22c6b624a72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*IA46B533GpBuS57Sb3v5Iw.png"/></div></div></figure><p id="0b42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与此同时，在 PostgreSQL 中，如果您使用<code class="fe mz na nb nc b">/ </code>运算符对两个整数进行除法运算，您将始终得到一个整数结果。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="757b" class="nh md it nc b gy ni nj l nk nl"><strong class="nc iu">SELECT 32/5</strong></span><span id="275c" class="nh md it nc b gy nm nj l nk nl">&gt;&gt; result: 6</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/4373b27e2755c1483c6992d95e03f5d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*JMl7AhZY4MNYnrPP7FfNuw.png"/></div></figure><p id="6819" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，如果您使用 PostgreSQL，记住您期望的输出类型是很重要的。如果您想要一个整数结果，您可以像上面一样编写您的 SQL 查询。但是，如果您想要像 Hive 和 MySQL 中那样精确的十进制结果，您需要显式地将其中一个操作数转换为十进制数。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="ca6e" class="nh md it nc b gy ni nj l nk nl"><strong class="nc iu">SELECT 32.0/5</strong></span><span id="febe" class="nh md it nc b gy nm nj l nk nl">&gt;&gt; result: 6.4</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/a49ca13256f0f68f61e2e974f137a18d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/1*f0iylVMgPbcniVysLk7c3g.png"/></div></figure><p id="dbbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你使用 MySQL 或 Hive，并且你想在执行两个整数的除法后得到一个整数结果，你需要使用<code class="fe mz na nb nc b">DIV</code>运算符来代替。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="e228" class="nh md it nc b gy ni nj l nk nl"><strong class="nc iu">SELECT 32 DIV 5</strong></span><span id="c54b" class="nh md it nc b gy nm nj l nk nl">&gt;&gt; result: 6</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/ac8baf4392ff42dc0b285bea635c81a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*cJDDoOcHFnqULNVNb9ggZA.png"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="80db" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">区分大小写:字符串比较</h1><p id="182e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">比较两个字符串也可能在不同的 SQL 引擎上产生不同的结果。Apache Hive 和 PostgreSQL 在进行字符串比较时是区分大小写的，这意味着大写字母和小写字母很重要。让我们看看下面的例子。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="d0d1" class="nh md it nc b gy ni nj l nk nl"><strong class="nc iu">SELECT</strong> 'One' = 'one'</span><span id="2826" class="nh md it nc b gy nm nj l nk nl">&gt;&gt; result: False</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/8e6b97c5f22ec26e073524a37dc43b78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1138/format:webp/1*nhw5_q2TIeoLTuMKDjPnLg.png"/></div></figure><p id="b270" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管两个字符串有相同的字母，查询将返回<strong class="lb iu"> FALSE </strong>，因为 Hive 和 PostgreSQL 都区分大小写。</p><p id="83b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同时，如果你使用 MySQL，同样的查询将返回 1 或<strong class="lb iu"> TRUE </strong>，因为 MySQL 在字符串比较时不区分大小写。这意味着只要两个字符串具有相同的字母，MySQL 就会将它们解释为相同的，不管它们是大写还是小写。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="24bb" class="nh md it nc b gy ni nj l nk nl"><strong class="nc iu">SELECT</strong> 'One' = 'one'</span><span id="2b23" class="nh md it nc b gy nm nj l nk nl">&gt;&gt; result: 1</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/ec731b29d35d6e521c71d995c1dadb55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1106/format:webp/1*eQxWE-ikY1l-m41vDoWQqg.png"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="80c7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">区分大小写:表引用</h1><p id="b51e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这取决于您使用的 SQL 引擎，当您引用数据库中的表时，需要注意区分大小写。如果使用 PostgreSQL 和 Hive，那么在引用表时就不需要担心大小写，因为它们总是将字母转换成小写。</p><p id="7d02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了更清楚地说明这一点，让我们看看下面的例子。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/62337ce987ce3032869016df1d6117e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mHuTHZhS2HK5xRZLxW4U8A.png"/></div></div></figure><p id="2e4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据库中有一个名为“<em class="nu">客户</em>的表。但是，我们在查询中将其称为<em class="nu">客户</em>。Hive 和 PostgreSQL 总是将字母转换成小写，因此它们理解我们想要引用表<em class="nu">‘CusTomers’</em>而不是<em class="nu">‘CusTomers’</em></p><p id="c15b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，MySQL 却不是这样。在 MySQL 中，当表被写入数据库时，您需要引用它。如果您将该表引用为<em class="nu">‘CusTomers’</em>，而它应该是<em class="nu">‘CusTomers</em>’，那么 MySQL 将抛出一个错误。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/92c8295ef94af7467a05d0a97354dbaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*80x5HqxT6XYGeyZM8yHiCA.png"/></div></div></figure><p id="9255" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果我们完全按照数据库中写的那样引用该表，MySQL 将返回我们完全想要的信息。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/2d95865bc94bcc848520bc036dbfc816.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NMzhOBgwU4uqKalWI7Yxvw.png"/></div></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fd89" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">在 SELECT 和 GROUP BY 语句中使用别名</h1><p id="a0e6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">创建别名是创建更高效、更简洁的 SQL 查询的一种非常有用的方法。此外，它为长查询提供了一个快捷方式，提高了查询的可读性，特别是如果我们要在 GROUP BY 子句中使用别名。让我们看一个例子来理解 alias 是如何工作的。</p><p id="95cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们有一个名为<em class="nu">‘inventory’</em>的表，包含以下列和内容。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/d6a370f23afeaab53d1880b912810f3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*km1h2aM9j4R8c52X7w5Kxg.png"/></div></div></figure><p id="43b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，假设我们希望纯粹基于数量状态对上表进行分组和聚合，即<code class="fe mz na nb nc b">qty</code>是大于还是小于 5。为此，我们将编写一个类似这样的 SQL 查询:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="aa30" class="nh md it nc b gy ni nj l nk nl"><strong class="nc iu">SELECT CASE  WHEN</strong> qty &gt; 5 <strong class="nc iu">THEN</strong> 'more than 5'<br/>             <strong class="nc iu">ELSE</strong> 'less than 5'<br/>        <strong class="nc iu">END</strong>,<br/>        COUNT(*)<br/><strong class="nc iu">FROM</strong> inventory<br/><strong class="nc iu">GROUP BY</strong> <strong class="nc iu">CASE WHEN</strong> qty &gt; 5 <strong class="nc iu">THEN</strong> 'more than 5'<br/>              <strong class="nc iu">ELSE</strong> 'less than 5'<br/>         <strong class="nc iu">END</strong></span></pre><p id="87c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的 SQL 查询可以工作，但是不够简洁，可读性显然还可以提高。这就是别名派上用场的地方。我们可以将<strong class="lb iu"> SELECT </strong>语句中的<strong class="lb iu"> CASE </strong>转换成别名，并通过子句在<strong class="lb iu">组中引用该别名，如下所示:</strong></p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="e5dc" class="nh md it nc b gy ni nj l nk nl"><strong class="nc iu">SELECT CASE  WHEN</strong> qty &gt; 5 <strong class="nc iu">THEN</strong> 'more than 5'<br/>             <strong class="nc iu">ELSE</strong> 'less than 5'<br/>        <strong class="nc iu">END AS</strong> inventory_status,<br/>        COUNT(*)<br/><strong class="nc iu">FROM</strong> inventory<br/><strong class="nc iu">GROUP BY</strong> inventory_status</span></pre><p id="040f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的 SQL 查询更短、更简洁，尤其是当我们有一个很长的<strong class="lb iu"> CASE </strong>语句时。</p><p id="3e14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果使用 MySQL 和 PostgreSQL，可以在<strong class="lb iu"> SELECT </strong>语句中编写一个带有别名的 SQL 查询，并通过子句引用<strong class="lb iu"> GROUP 中的别名。下面是通过</strong>子句引用<strong class="lb iu">组中的别名的查询结果。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/c1ad4a365f653ee66689a39089c89e9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*syBFT7X3_48OBVh4EWdaXA.png"/></div></div></figure><p id="e575" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同时，如果你使用 Hive，你不能通过子句引用<strong class="lb iu">组中的别名，因为它会抛出一个错误。这是因为在处理<strong class="lb iu"> SELECT </strong>语句之前，Hive 将首先通过</strong>子句处理<strong class="lb iu">组。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/196391b21c2a4c48a28bde97d5c4366b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NKrGbLiOO3sUIYkWTVrIQw.png"/></div></div></figure><p id="4ea4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，如果您正在使用 Hive，唯一的方法就是删除别名，并重写 GROUP BY 子句中的<strong class="lb iu"> CASE </strong>语句，就像没有别名的原始查询一样。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="39cc" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">非数字字符串到数字类型的转换</h1><p id="51eb" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">使用 SQL，我们可以用<strong class="lb iu"> CAST </strong>命令转换表中一列的数据类型。如果我们想把一个字符串列转换成一个整数，我们可以这样做。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="6ca4" class="nh md it nc b gy ni nj l nk nl"><strong class="nc iu">SELECT CAST</strong>(column_name <strong class="nc iu">AS INT</strong>) <strong class="nc iu">FROM</strong> table_name</span></pre><p id="2550" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，如果您尝试将值不代表数字的字符串列的数据类型转换为数字列，查询将返回意外的结果，这取决于您使用的 SQL 引擎。为了解释这一现象，让我们用与前面相同的例子来说明'<em class="nu">库存</em>'表。</p><p id="521c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在 Hive 中，如果您尝试将'<em class="nu"> game </em>'列转换为整数，查询将导致缺少值或<strong class="lb iu"> NULL </strong>值。回想一下，'<em class="nu">游戏</em>'列的数据类型是<strong class="lb iu">字符串</strong>，并且所有的值都是非数字的(<em class="nu">大富翁、线索、糖果乐园</em>)。当您将该列转换为数字列时，例如 integer 或 float，那么查询将返回空值，因为没有办法将这些字符串转换为数字表示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/be168ad85009987aa1ee8027e438411e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1138/format:webp/1*RNIgf0kHv_ImDqz0mPnYNg.png"/></div></figure><p id="e3ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们来看看我们是否使用 MySQL。在 MySQL 中，如果用相同的 SQL 语法对同一列进行数据类型转换，会得到列中的值，但都是零。这不同于我们在 Hive 中得到的缺失值(<strong class="lb iu"> NULL </strong>)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/24497947f79da9c83ce389b4935387d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/1*XfAxWDyJJyKWNhYAt7Y0QQ.png"/></div></figure><p id="872d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同时，如果您在 PostgreSQL 中使用相同的语法对相同的列尝试相同的数据类型转换，您将会得到一个错误。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/f463acb1f9370f398ee8552f23a7257d.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*NFUg_a7wcYOIdS-ET5-6xg.png"/></div></figure><p id="3be0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不同的 SQL 引擎有不同的方法来处理像这样的数据类型转换问题。因此，当您尝试将字符串列的数据类型转换为数字列，并且一个或多个字符串值不代表数字时，提前了解您使用的 SQL 引擎以及您期望得到的结果是很重要的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="da00" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">没有连接条件的连接语法</h1><p id="2e1c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">JOIN 语法是 SQL 中最重要的语法之一，尤其是在处理关系数据库时。SQL 中的<strong class="lb iu">连接</strong>有不同的类型:<strong class="lb iu">内连接</strong>、<strong class="lb iu">左连接</strong>、<strong class="lb iu">右连接</strong>、<strong class="lb iu">外连接</strong>、<strong class="lb iu">交叉连接</strong>。</p><p id="61a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为本文的重点不是解释不同的<strong class="lb iu">连接</strong>语法是如何工作的，所以我不打算详细讨论这个问题。但是，如果你想知道关于不同的<strong class="lb iu"> JOIN </strong>语法彼此有何不同的详细信息，我推荐<a class="ae ky" rel="noopener" target="_blank" href="/sql-join-8212e3eb9fde">这篇文章</a>和<a class="ae ky" rel="noopener" target="_blank" href="/combining-tables-using-sql-f6ddfd5f8b6f">这篇文章</a>。</p><p id="7bb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了补充<strong class="lb iu">连接</strong>语法，通常我们还应该在子句上使用<strong class="lb iu">或者在</strong>子句上使用<strong class="lb iu">来提供连接条件。为了更清楚地说明这一点，我们假设有两个不同的表，一个名为'<em class="nu"> toys </em>'，另一个名为'<em class="nu"> makers </em>'。下面是这两个表的列和内容的图示。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/f7a54993c3af13a34afc7b6bbd1d832c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VCeaGrIJWGBlGhw2s-QqeQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">“玩具”表的列和内容</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/58e2e4352e971c9d4a0fb8a7cd808dc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/1*Z-TU9_dQc_pOC89IzmQmMg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">“制造商”表的列和内容</p></figure><p id="c283" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在的目标是根据'<em class="nu">玩具</em>'表中的制造商 ID，将'<em class="nu">玩具</em>'表和'<em class="nu">制造商</em>'表组合起来。为此，我们可以使用下面的 SQL 查询。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="4d0d" class="nh md it nc b gy ni nj l nk nl"><strong class="nc iu">SELECT</strong> * <br/><strong class="nc iu">FROM</strong> toys <strong class="nc iu">JOIN</strong> makers <br/><strong class="nc iu">ON</strong> toys.maker_id = makers.id</span></pre><p id="ab17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上述查询产生以下结果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/dbb56c3068c82d8c32f7d49591350cae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yZlIxd-6ghR1bNVhU5c1Rw.png"/></div></div></figure><p id="29c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我们没有详细指定我们希望在查询中使用哪个<strong class="lb iu"> JOIN </strong>语法。然而，因为我们提供了连接条件，即子句上的<strong class="lb iu">，所以 SQL 引擎将<strong class="lb iu">连接</strong>语法解释为<strong class="lb iu">左连接</strong>。</strong></p><p id="1322" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果由于某些原因我们忘记提供连接条件，会发生什么呢？</p><p id="3631" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你使用 PostgreSQL，你会很幸运，因为它会直接抛出一个错误，告诉你你的语法无效。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/f1aa5a3e35c346dc855702eda71ca4b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sWC1XFVqOyE5KRK27_LPrA.png"/></div></div></figure><p id="1f94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同时，如果您正在使用 MySQL 或 Hive，并且忘记添加连接条件，查询仍然会运行。但是，它会将您的<strong class="lb iu">连接</strong>语法解释为<strong class="lb iu">交叉连接</strong>。查询的结果如下。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/ab80545d262707c3eb98c30e78024a3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GrmttDx6uoiaH8QUB0xarQ.png"/></div></div></figure><p id="2e45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了更好地理解一个<strong class="lb iu">交叉连接</strong>实际上是做什么的，让我们用下面的图表来举例说明。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/c77e0a53cbb2ca10838f22a47ea6bb4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KI9UWk5SlpvPuB2osOS_Qw.png"/></div></div></figure><p id="16c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<strong class="lb iu"> Cross JOIN </strong>，来自左表和右表的行的每一种可能的组合都将包含在最终结果中。用作示例的两个表只包含 3 行，现在想象一下，如果您的数据库包含许多行，而您忘记了添加连接条件。结果将是一个包含大量行的新表，您可能会被这个结果误导。</p><p id="e9fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了避免这种情况，最好明确告诉 SQL 引擎应该在查询中执行哪种<strong class="lb iu">连接</strong>语法。另外，在<strong class="lb iu"> join </strong>语法之后提供 JOIN 条件也是必须的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="0e8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仅此而已。这些是相同的 SQL 语法在 MySQL、PostgreSQL 和 Apache Hive 中表现不同的情况，至少据我所知是这样。如果你知道其他他们表现不同的案例，如果你能和我分享，我会很高兴。</p></div></div>    
</body>
</html>