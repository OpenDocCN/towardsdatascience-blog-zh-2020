<html>
<head>
<title>Model Management in productive ML software</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">生产ML软件中的模型管理</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/model-management-in-productive-ml-software-110d2d2cb456?source=collection_archive---------29-----------------------#2020-05-11">https://towardsdatascience.com/model-management-in-productive-ml-software-110d2d2cb456?source=collection_archive---------29-----------------------#2020-05-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4833" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">MLflow简介-</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/31d280345f62b07d8bad463ee177ea83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*llz67IO_HCeOzrjI8Iz4sg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">乌默尔·萨亚姆在<a class="ae ky" href="https://unsplash.com/s/photos/bridge?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="7f85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为机器学习问题开发一个好的概念证明有时会很困难。您正在处理成吨成吨的数据工程层，测试许多不同的模型，直到您最终“破解了代码”，并在测试集上取得了好成绩。万岁！这是一个好消息，因为现在乐趣真正开始了，你的模型可能会帮助你的公司赚钱或省钱。如果是这样的话，你必须围绕你的模型来构建高效的软件。那是什么意思？您需要一个支持实时数据流的解决方案架构、一个可随数据流扩展的计算组件、一个真正的前端和一个良好的存储解决方案。而这些只是你的主要组件！您还需要一个监控解决方案，以防您的任何软件运行出错，还需要一个DevOps工具，负责测试您的新代码版本并将其发布到生产环境中。这只是你的日常数据用例，如果你试图构建人工智能软件，你可能会处理大量数据和非常密集的数据工程层，以将你的原始数据转化为可用于训练/推断机器学习模型的形式。最有可能的是，您将需要一个ETL管道工具来在每天的运行中编排您的数据工程。但最后一件事可能是最重要的一块拼图，你需要知道你的ML模型随着时间的推移在做什么！</p><ul class=""><li id="b604" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">今天的模型与昨天的模型相比有多好？</li><li id="d59a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">它接受了哪些功能的培训？</li><li id="b8d1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">什么是最优超参数？它们会随着时间而改变吗？</li><li id="ae7b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">训练和测试数据如何随时间变化？</li><li id="544f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">哪个模型处于生产/集成状态？</li><li id="5c37" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">我如何在这种设置中引入主要的模型更新？</li></ul><p id="c7ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有这些问题都源于机器学习生命周期的复杂性。因为数据会随着时间的推移而变化，即使在生产性的ML环境中，我们也经常处于收集数据、探索模型、提炼模型、最后测试/评估、部署并最终监控我们的模型的循环中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/a036a2651c36ed0008e188be75d137a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wMbO2fpDm9I9Ld5PAbZXLw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">ML生命周期</p></figure><blockquote class="mk"><p id="5771" class="ml mm it bd mn mo mp mq mr ms mt lu dk translated">我们如何才能保持对这个不断进化的复杂循环的控制？</p></blockquote><p id="665a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">实际上有一个非常简单的解决方法——把一切都写下来！或者用计算机术语来说:</p><blockquote class="mk"><p id="63de" class="ml mm it bd mn mo mz na nb nc nd lu dk translated">记录所有相关信息！</p></blockquote><p id="e372" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">一个有趣的名字是机器学习模型管理，这是MLOps的重要组成部分。在软件执行过程中捕获相关信息并基于这些信息做出自动决策的持续过程。准备、训练和评估期间的指标，以及经过训练的模型、预处理管道和超参数。所有这些都被整齐地保存在一个模型数据库中，以备比较、分析和用于挑选一个特定的模型作为预测层。现在，理论上你可以使用任何普通的数据库作为后端，并编写自己的API来测量和存储所有这些信息。然而，在实践中，我们可以利用一些非常酷的预建框架来帮助完成这项任务。<a class="ae ky" href="https://azure.microsoft.com/de-de/services/machine-learning/" rel="noopener ugc nofollow" target="_blank"> Azure机器学习</a>、<a class="ae ky" href="https://polyaxon.com/" rel="noopener ugc nofollow" target="_blank"> Polyaxon </a>、<a class="ae ky" href="https://mldb.ai/" rel="noopener ugc nofollow" target="_blank"> mldb.ai </a>只是几个例子。本文重点介绍<a class="ae ky" href="https://mlflow.org/" rel="noopener ugc nofollow" target="_blank"> MLflow </a>。MLflow由D <a class="ae ky" href="https://databricks.com/blog/2018/06/05/introducing-mlflow-an-open-source-machine-learning-platform.html" rel="noopener ugc nofollow" target="_blank"> atabricks </a>的人员开发，并无缝集成到他们的生态系统中。由于我已经在Databricks上完成了所有的ETL和超参数调优(使用<a class="ae ky" href="https://github.com/hyperopt/hyperopt" rel="noopener ugc nofollow" target="_blank"> hyperopt </a>框架),所以这是模型管理框架的一个简单选择。</p></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="5d7d" class="nl nm it bd nn no np nq nr ns nt nu nv jz nw ka nx kc ny kd nz kf oa kg ob oc bi translated">MLflow深潜</h1><p id="f698" class="pw-post-body-paragraph kz la it lb b lc od ju le lf oe jx lh li of lk ll lm og lo lp lq oh ls lt lu im bi translated">MLflow是一个“机器学习生命周期的开源平台”。<a class="ae ky" href="https://databricks.com/" rel="noopener ugc nofollow" target="_blank"> Databricks </a>上的管理版本特别易于使用，您甚至可以通过点击下面的“新MLflow实验”使用用户界面创建一个空MLflow实验。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/d0d605bb708852e20b291a1a3a92846c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*4DvlP_mGx4NAlMKw-ErgBw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://azure.microsoft.com/de-de/services/databricks/" rel="noopener ugc nofollow" target="_blank"> Azure数据块</a></p></figure><p id="11db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您不必担心设置后端数据库，一切都会自动处理。一旦实验可用，就可以在您的代码中使用<a class="ae ky" href="https://www.mlflow.org/docs/latest/tracking.html#where-runs-are-recorded" rel="noopener ugc nofollow" target="_blank"> MLflow tracking API </a>来记录各种信息。为了快速浏览，让我们看一个例子:</p><h2 id="993b" class="oj nm it bd nn ok ol dn nr om on dp nv li oo op nx lm oq or nz lq os ot ob ou bi translated">Sklearn的葡萄酒数据集</h2><p id="24ed" class="pw-post-body-paragraph kz la it lb b lc od ju le lf oe jx lh li of lk ll lm og lo lp lq oh ls lt lu im bi translated">我看了一下sklearn的开源葡萄酒数据集。它包含来自不同意大利葡萄酒种植者的三种不同葡萄酒类型的化学分析数据。目标是创建一个分类器，使用给定的特征(如酒精、镁、颜色强度等)来预测葡萄酒的类别。</p><p id="8726" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，您可以打开一个新的Databricks笔记本，并加载以下软件包(确保它们已安装):</p><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="15d2" class="oj nm it ow b gy pa pb l pc pd">import warnings<br/>from sklearn import datasets<br/>from sklearn.ensemble import RandomForestClassifier<br/>from sklearn.model_selection import train_test_split<br/>from sklearn.metrics import accuracy_score, f1_score<br/>import pandas as pd<br/>import numpy as np<br/>import mlflow<br/>import mlflow.sklearn</span><span id="223e" class="oj nm it ow b gy pe pb l pc pd">warnings.filterwarnings(“ignore”)</span></pre><p id="0f5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您可以将数据加载到熊猫数据框架中:</p><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="c149" class="oj nm it ow b gy pa pb l pc pd"># Load wine dataset<br/>wine = datasets.load_wine()<br/>X = wine.data<br/>y = wine.target</span><span id="f5e4" class="oj nm it ow b gy pe pb l pc pd">#create pandas df:<br/>Y = np.array([y]).transpose()<br/>d = np.concatenate((X, Y), axis=1)<br/>cols = ["Alcohol", "Malic acid", "Ash", "Alcalinity of ash", "Magnesium", "Total phenols", "Flavanoids", "Nonflavanoid phenols", "Proanthocyanins", "Color intensity", "Hue", "OD280/OD315 of diluted wines", "Proline", "class"]<br/>data = pd.DataFrame(d, columns=cols)</span></pre><h2 id="a02f" class="oj nm it bd nn ok ol dn nr om on dp nv li oo op nx lm oq or nz lq os ot ob ou bi translated">设置日志记录</h2><p id="1f8d" class="pw-post-body-paragraph kz la it lb b lc od ju le lf oe jx lh li of lk ll lm og lo lp lq oh ls lt lu im bi translated">首先，我们需要决定在培训阶段我们想记录什么。原则上，MLflow允许我们记录任何东西。是的，任何事！在最基本的形式中，我们可以将任何信息写入文件，并让MLflow将其作为工件记录。预建的日志记录功能包括:</p><ul class=""><li id="5e84" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">运行ID</li><li id="c595" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">日期</li><li id="6f8c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">参数(例如:超参数)</li><li id="a937" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">韵律学</li><li id="9d24" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">模型(训练模型)</li><li id="458d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">工件(例如:经过训练的编码器、预处理管道等)</li><li id="0edb" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">标签(例如:型号版本、型号名称、其他元信息)</li></ul><p id="3e14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本例中，我们将坚持基本原则，记录2个指标、所有超参数以及训练模型，并给它一个模型版本标签。为了简单一点，我们围绕scikit-learn构建了一个小包装器。负责MLflow日志记录的fit()方法。然后，我们可以调用包装器，传入不同的超参数，并查看性能如何变化，一切都记录到我们的MLflow后端。</p><p id="c499" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从评估函数开始，包括准确性和F1分数:</p><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="6540" class="oj nm it ow b gy pa pb l pc pd">from sklearn.metrics import accuracy_score, f1_score</span><span id="6ee8" class="oj nm it ow b gy pe pb l pc pd">def eval_metrics(actual, pred):<br/>    acc = accuracy_score(actual, pred)<br/>    f1 = f1_score(actual, pred, average = "weighted")<br/>    return acc, f1</span></pre><p id="0f8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后围绕scikit-learn的RandomForestClassifier编写我们的包装器，给它两个超参数来调整，即森林中的树的数量，以及树中每个决策拆分使用的特征列的比例。</p><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="5cc5" class="oj nm it ow b gy pa pb l pc pd">def train_winedata(data, in_n_estimators,  in_max_features):<br/>  <br/>  warnings.filterwarnings("ignore")<br/>  np.random.seed(40)</span><span id="d549" class="oj nm it ow b gy pe pb l pc pd"># Split the data into training and test sets. (0.75, 0.25) split.<br/>  train, test = train_test_split(data, stratify= data["class"])</span><span id="45e2" class="oj nm it ow b gy pe pb l pc pd"># The predicted column is "class"<br/>  train_x = train.drop(["class"], axis=1)<br/>  test_x = test.drop(["class"], axis=1)<br/>  train_y = train[["class"]]<br/>  test_y = test[["class"]]<br/>  <br/>  <br/>  # start run<br/>  with mlflow.start_run():<br/>    rf = RandomForestClassifier(n_estimators = in_n_estimators, <br/>                                max_features= in_max_features)<br/>    rf.fit(train_x, train_y)  <br/>    acc, f1 = eval_metrics(test_y, rf.predict(test_x))<br/>    print("  Accuracy: %s" % acc)<br/>    print("  F1 Score: %s" % f1)<br/>    <br/>    #log metrics <br/>    mlflow.log_metric("F1", f1)<br/>    mlflow.log_metric("Accuracy", acc)<br/>    #log params<br/>    mlflow.log_param("n_estimator", in_n_estimators)<br/>    mlflow.log_param("max_features", in_max_features)<br/>    <br/>    # add tags<br/>    mlflow.set_tag("model_name", "Wineforest")<br/>    # save the trained model<br/>    mlflow.sklearn.log_model(rf, "model")</span></pre><h2 id="666e" class="oj nm it bd nn ok ol dn nr om on dp nv li oo op nx lm oq or nz lq os ot ob ou bi translated">训练模型</h2><p id="9fc4" class="pw-post-body-paragraph kz la it lb b lc od ju le lf oe jx lh li of lk ll lm og lo lp lq oh ls lt lu im bi translated">在运行培训之前，我们需要告诉我们的MLflow客户端在哪里记录所有这些信息。我们将让它指向我们之前通过Databricks UI创建的空MLflow实验:</p><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="739b" class="oj nm it ow b gy pa pb l pc pd">mlflow.set_experiment("/<a class="ae ky" href="mailto:Users/maxibe@emea.corpdir.net" rel="noopener ugc nofollow" target="_blank">Users/</a>&lt;your user&gt;/WineClassifier")</span></pre><p id="b39d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以运行第一组超参数:</p><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="709c" class="oj nm it ow b gy pa pb l pc pd">train_winedata(data, in_n_estimators= 1, in_max_features= 0.1)</span><span id="4d5b" class="oj nm it ow b gy pe pb l pc pd">Accuracy: 0.733   F1 Score: 0.731</span></pre><p id="e3da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到，单个树每次分裂仅使用10%的特征就获得了相当不错的准确度和F1分数。</p><p id="b4bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在以max_features的50%重新运行训练:</p><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="4596" class="oj nm it ow b gy pa pb l pc pd">train_winedata(data, in_n_estimators= 1, in_max_features= 0.5)</span><span id="48bc" class="oj nm it ow b gy pe pb l pc pd">Accuracy: 0.933   F1 Score: 0.931</span></pre><p id="eb37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">已经给了很高的分数。但是，在随机森林中包含100棵树可以进一步提高性能:</p><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="446f" class="oj nm it ow b gy pa pb l pc pd">train_winedata(data, in_n_estimators= 100,  in_max_features= 0.5)</span><span id="0c29" class="oj nm it ow b gy pe pb l pc pd">Accuracy: 0.98   F1 Score: 0.98</span></pre><p id="75a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们快速浏览一下MLflow实验的结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pf"><img src="../Images/b9661840b66f4063a36c466c2b26c183.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4T5ErsXyM3NIo-OpNjRzzw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">MLflow用户界面</p></figure><p id="408e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到一个漂亮的GUI，其中包含了我们所有的登录信息。我们还可以通过点击日期深入了解单次跑步。在那里，我们发现日志模型作为一个工件，准备好被加载并用于进行预测。现在，我们可以设置我们的服务层来获取最佳模型(例如，根据F1分数)，并自动将我们的生产环境部署到该层。当进行广泛的网格搜索时，可以探索不同超参数日志的影响，以潜在地调整超参数网格中的搜索空间。</p></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="f0f0" class="nl nm it bd nn no np nq nr ns nt nu nv jz nw ka nx kc ny kd nz kf oa kg ob oc bi translated">生产级机器学习的架构设置</h1><p id="22b8" class="pw-post-body-paragraph kz la it lb b lc od ju le lf oe jx lh li of lk ll lm og lo lp lq oh ls lt lu im bi translated">当构建高效的软件时，我们必须时刻牢记，一个单一的环境很可能不会成功。如果我们有一个生产性的设置在运行，并且我们想要对代码进行更改，我们至少需要一个集成环境，在那里我们可以首先测试任何更改。</p><p id="36f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着训练数据随着时间的推移而增加和变化，我们还需要定义重新训练我们的模型、重做超参数调整甚至重新评估机器学习模型整体类型的周期。这需要以自动化的方式发生，并且已经在集成环境中成功测试的最佳模型(在固定的外部数据集上测试)需要一直部署在生产中。如果我们决定改变外部测试数据集或者代码发生重大变化，我们可能想要合并一个新的模型版本，并且只比较比该版本旧的部署模型，等等。有点复杂的过程。</p><p id="0e60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">MLflow中的模型注册中心提供了一个工具，可以帮助完成这个过程。在这里，我们可以用不同的名称、版本和阶段注册来自MLflow后端的已训练模型。从“无”、过渡到“准备”到“生产”的阶段。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/de942a72d80c7146339631fd537fff68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BDKP2It787pbJuFRwXi-Cg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">模型“winetest”的模型注册表项</p></figure><p id="af20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记录我们之前的葡萄酒分类器，我们只需要从MLflow获取model_uri并运行:</p><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="376c" class="oj nm it ow b gy pa pb l pc pd">mlflow.register_model(model_uri=model_uri, name="winetest")</span></pre><p id="eeaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们更仔细地看一下如何使用这个设置管理两个基本的ML生命周期场景:定期重新训练和调整已经部署的PROD模型，以及将新的或更新的模型代码部署到生产系统中。主要区别:后者需要在INT上经历一个测试阶段，因为代码已经改变，而前者没有。代码保持不变，只是模型的性能可能发生了变化。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ph"><img src="../Images/9c18477dd4f40ec72f85331344a15d08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g41NuTJrarY14nDw3EiPtQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用MLflow的模型管理设置</p></figure><p id="f66f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想想下面的场景:目前1.0版中一个名为AImodel的模型注册为“Production”，并部署在PROD上。我们每x天对模型进行一次再培训和重新调整。一旦进行了重新训练和重新调整，我们就可以从注册表中获取模型，运行我们的训练和调整管道，将AImodel版的新模型性能记录到MLflow中。现在，我们可以通过比较新训练的AImodel 1.0的性能和AImodel 1.0在外部数据集上的所有现有性能来启动自动选择过程，并通过用我们选择的模型覆盖“生产”阶段位于模型注册表中的当前AImodel 1.0来部署最佳模型(由于某种度量)。现在，我们仍然在产品中使用AImodel 1.0，只不过(希望)有更好的性能，因为它是在更新(更多)的数据上训练出来的。</p><p id="57ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这非常简单，允许在生产中不断部署最好的AImodel 1.0。如果我们想改变AImodel 1.0的代码，甚至引入MLmodel 1.0来与AImodel 1.0竞争生产位置，该怎么办？我们需要利用我们的集成环境！</p><p id="7a83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将代码部署到环境中是由DevOps管道管理的，它分别由int或master Git分支上的拉请求触发。这就给了我们INT或PROD版本的代码到各自的环境中。让我们想象一下，我们在AImodel 1.0的代码中包含了分布式培训。我们通过DevOps将INT Git分支上的内容部署到我们的INT环境中，并运行新配置的培训，再次登录MLflow(给模型一个INT标记)，并将模型注册为AImodel 2.0以及“Staging”。现在的关键概念是:我们的两个环境会根据一些标准(如上面使用性能指标所解释的)自动选择用作服务层的模型。由于我们只希望AImodel 2.0在INT上使用(因此被测试)，而不是在PROD上，我们引入了每个环境的模型版本容差。这意味着仅允许PROD从≤1.0版的型号中选择，而允许INT选择≤ 2.0版(或如果我们特别想测试2.0版:=2.0)。在完成INT的测试阶段后，我们可以将模型转换到注册表中的“生产”，并将PROD中的模型版本容差提高到≤ 2.0(或=2.0或1.0≤PROD版本≤2.0等)。现在，新代码(新模型)已经为PROD环境做好了准备。因此，基本上，在INT的每个新的训练循环中，我们都在比较并潜在地用一个模型子集替换“Staging”中的当前模型，这是根据MLflow中INT的版本容差(例如，模型标签模型名称等)进行的。根据产品上的版本余量，使用“生产”中的模型，在产品上也会发生同样的事情。如果我们对代码进行了重大更新(比如想要使用一个完全不同的模型)，我们总是可以用一个新的名字注册这个模型，并从头开始1.0版。</p><p id="d50d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种设置允许自动部署性能最佳的模型，同时仍然可以将新的代码和模型顺利地引入系统。然而，这仍然是一些基本的设置，因为在大多数情况下，调优和训练将异步完成，因为调优工作是非常计算密集型的，因此可能仅在例如每10个训练循环中发生一次。现在我们可以考虑使用不同的MLflow后端，一个用于调优，一个用于训练，以保持事情清晰和可管理。</p><p id="bb66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总的来说，MLflow中可用的工具允许非常灵活的模型管理设置，可以直接根据用例的需求进行定制，并满足生产级需求。我们还可以想象在我们的MLflow后端之上构建一个仪表板，允许高级用户跟踪性能、版本状态以及参数和功能选择，而无需打开数据块。</p><p id="dbe7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尝试一下，让你的机器学习应用更上一层楼:)</p><h2 id="70a6" class="oj nm it bd nn ok ol dn nr om on dp nv li oo op nx lm oq or nz lq os ot ob ou bi translated"><strong class="ak">参考文献:</strong></h2><p id="a067" class="pw-post-body-paragraph kz la it lb b lc od ju le lf oe jx lh li of lk ll lm og lo lp lq oh ls lt lu im bi translated"><strong class="lb iu"> MLflow </strong></p><div class="pi pj gp gr pk pl"><a href="https://mlflow.org/" rel="noopener  ugc nofollow" target="_blank"><div class="pm ab fo"><div class="pn ab po cl cj pp"><h2 class="bd iu gy z fp pq fr fs pr fu fw is bi translated">MLflow -机器学习生命周期的平台</h2><div class="ps l"><h3 class="bd b gy z fp pq fr fs pr fu fw dk translated">机器学习生命周期的开源平台MLflow是一个开源平台，用于管理机器学习生命周期</h3></div><div class="pt l"><p class="bd b dl z fp pq fr fs pr fu fw dk translated">mlflow.org</p></div></div><div class="pu l"><div class="pv l pw px py pu pz ks pl"/></div></div></a></div><p id="1b19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> MLflow车型注册</strong></p><div class="pi pj gp gr pk pl"><a href="https://docs.databricks.com/applications/mlflow/model-registry.html?_ga=2.191901866.1832504560.1588601145-536696397.1564753281#model-registry-concepts" rel="noopener  ugc nofollow" target="_blank"><div class="pm ab fo"><div class="pn ab po cl cj pp"><h2 class="bd iu gy z fp pq fr fs pr fu fw is bi translated">在MLflow模型注册表中管理MLflow模型的生命周期</h2><div class="ps l"><h3 class="bd b gy z fp pq fr fs pr fu fw dk translated">MLflow Model Registry是一个集中式模型存储和一个UI以及一组API，使您能够管理整个生命周期…</h3></div><div class="pt l"><p class="bd b dl z fp pq fr fs pr fu fw dk translated">docs.databricks.com</p></div></div></div></a></div></div></div>    
</body>
</html>