<html>
<head>
<title>Bootstrapping Confidence Intervals: the basics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自举置信区间:基础</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/bootstrapping-confidence-intervals-the-basics-b4f28156a8da?source=collection_archive---------27-----------------------#2020-05-17">https://towardsdatascience.com/bootstrapping-confidence-intervals-the-basics-b4f28156a8da?source=collection_archive---------27-----------------------#2020-05-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bf7c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何在没有t检验和p值的情况下计算任何指标的置信区间</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0c00ef89129b2c02fa39e34e52005449.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5UBGh1SVV7ujYMjk.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="ky">两个AB测试:在左边，测试组之间没有统计学上的显著差异；在右边，这样的差异存在(图片作者)</em></p></figure><p id="dc00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">如果你是数据驱动型公司的数据科学家、数据分析师或产品经理，你会对你的产品做很多实验，通常，你会做很多AB测试。让我们假设你有一个控制组和治疗组的AB测试。当分析结果时，您比较测试组中订单/访问/查看的平均数(或任何其他指标)。显然，您可以计算指标的平均值，甚至可以使用t检验和p值，如果两个平均值之间存在统计上的显著差异。但是通常，他们说不要只看p值，要看置信区间。在这篇博文中，我们发现了如何使用自举来计算置信区间。Bootstrapping是一种很酷的估计置信区间的方法，因为它不依赖于任何数据分布的假设(例如，与流行的Welch t-test相比)，并且它很容易自己实现(下面我分享了一个我的实现的链接)。</em></p><h1 id="bc24" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">自举定义和原理</h1><p id="f617" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">bootstrap是一种估计标准误差和计算置信区间的方法。自举始于1970年<a class="ae mt" href="https://projecteuclid.org/euclid.aos/1176344552#info" rel="noopener ugc nofollow" target="_blank">布拉德利·埃夫隆</a>；它已经存在了40多年，因此从那时起，开发了许多不同类型和方法的自举。</p><p id="ca52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管有许多变化，<em class="lv">所有的引导步骤看起来如下:</em></p><ol class=""><li id="b0a4" class="mu mv it lb b lc ld lf lg li mw lm mx lq my lu mz na nb nc bi translated">定义<em class="lv"> u </em> —从样本中计算出的统计数据(平均值、中值等)。</li><li id="9848" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated">替换原始数据样本的样本。让它成为<em class="lv"> F* </em> —经验分布。重复<em class="lv"> n </em>次(<em class="lv"> n </em>为引导迭代)。</li><li id="4df5" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated">计算<em class="lv"> u* </em> —从每个重采样中计算的统计量。</li></ol><p id="3ded" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后自举原理说:</p><p id="dc13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上所述，bootstrap可用于不同的目标:</p><ul class=""><li id="ca97" class="mu mv it lb b lc ld lf lg li mw lm mx lq my lu ni na nb nc bi translated">估计置信区间</li><li id="4229" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu ni na nb nc bi translated">假设检验</li><li id="d371" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu ni na nb nc bi translated">偏差消除</li></ul><p id="fb0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个话题都应该有一个单独的帖子，今天我们只关注自举置信区间。</p><h1 id="f0e8" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">自举置信区间的方法</h1><p id="3eb5" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">当我研究这个主题时，我还没有找到一个一次性包含所有bootstraps方法的单一来源，每个引用都有自己的类型。最常见的如下所示:</p><p id="9eb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之，这种方法近似于自举均值和样本均值之间的差异。</p><p id="4de8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们考虑一个例子(其他方法也是如此):估计基础分布的均值<em class="lv"> μ </em>，给出一个80%的bootstrap置信区间。</p><p id="759e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">经验自举说:</p><ul class=""><li id="2927" class="mu mv it lb b lc ld lf lg li mw lm mx lq my lu ni na nb nc bi translated">从重新采样开始，替换原始数据<em class="lv"> n </em>次。</li><li id="6ea5" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu ni na nb nc bi translated">对于每个自举，计算平均值<em class="lv"> x* </em>。</li><li id="156d" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu ni na nb nc bi translated">计算每个引导样本的<em class="lv">δ* = x *—x</em>(<em class="lv">x</em>是原始数据的平均值)，将它们从最小到最大排序。</li><li id="c74c" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu ni na nb nc bi translated">选择<em class="lv"> δ.1 </em>作为第90个百分位数，<em class="lv"> δ.9 </em>作为<em class="lv"> δ* </em>排序列表的第10个百分位数，得到80%的置信区间<em class="lv">[x-δ. 1，x-δ. 9】</em>。</li></ul><p id="dd07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae mt" href="https://link.springer.com/book/10.1007/978-0-387-21736-9" rel="noopener ugc nofollow" target="_blank">乏色曼的《统计学大全》一书</a>为经验自助法提供了以下数学符号:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/0563b811a0df7fce60e649aaa43f0685.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*p-wvgdt4VAZAiP6R"/></div></div></figure><p id="07ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中<em class="lv"> x </em>是原始数据的平均值，<em class="lv"> x* </em>是自举平均值。</p><p id="8319" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.<strong class="lb iu">百分位自助法</strong></p><p id="8616" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">bootstrap percentile方法使用bootstrap样本统计的分布作为数据样本统计的直接近似值，而不是计算差值<em class="lv"> δ* </em>。</p><p id="96c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于百分位引导:</p><ul class=""><li id="609d" class="mu mv it lb b lc ld lf lg li mw lm mx lq my lu ni na nb nc bi translated">从重新采样开始，替换原始数据<em class="lv"> n </em>次。</li><li id="7ca9" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu ni na nb nc bi translated">对于每个引导计算平均值<em class="lv"> x* </em>，从最小到最大排序。</li><li id="772d" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu ni na nb nc bi translated">选择<em class="lv"> x*.1 </em>为第10个百分位数，<em class="lv"> x*.9 </em>为<em class="lv"> x* </em>排序列表的第90个百分位数，得到80%的置信区间<em class="lv"> [x*.1，x*.9】。</em></li></ul><p id="cb17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者换句话说:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/a089d756085ac9fef7ba20c578b11c51.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/0*HAJ4E-gelkDiQ1rU"/></div></figure><p id="e2ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">bootstrap百分位法非常简单，但它依赖于基于特定样本的bootstrap分布，该分布很好地逼近了<em class="lv"> x </em>的真实分布(因此，<a class="ae mt" href="http://www-math.mit.edu/~dav/05.dir/class24-prep-a.pdf" rel="noopener ugc nofollow" target="_blank">该来源</a>建议不要使用百分位bootstrap)。</p><p id="b6d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3.<strong class="lb iu">正常自举</strong></p><p id="9337" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正常的bootstrap方法不是取bootstrap均值的百分位数，而是计算这些bootstrap均值的置信区间。</p><ul class=""><li id="c1ce" class="mu mv it lb b lc ld lf lg li mw lm mx lq my lu ni na nb nc bi translated">从重新采样开始，替换原始数据<em class="lv"> n </em>次。</li><li id="c28e" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu ni na nb nc bi translated">对于每个引导，计算平均值<em class="lv"> x* </em>。</li><li id="6a3f" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu ni na nb nc bi translated">使用例如学生t检验，计算<em class="lv"> x* </em>数组的80%置信区间:</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/5bbe7fbf1207cd978d1086b1cc33f73e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/0*bxOlJwqhDaDVOIAn"/></div></figure><p id="cb0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中<em class="lv"> x* </em>是来自bootstrap均值的样本均值，<em class="lv"> se </em>是bootstrap均值的<a class="ae mt" href="https://en.wikipedia.org/wiki/Standard_error_of_the_mean" rel="noopener ugc nofollow" target="_blank">标准差</a> s，<em class="lv"> z* </em>是临界值(从正态CDF的分布表中找到)。</p><p id="fde6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我将这种方法与其他方法比较时，它的CI与其他方法相比总是很窄，这让我很困惑。据我所知，这是因为该定义强烈依赖于关于数据正态分布的假设。</p><p id="f04c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">过了一段时间，我在乏色曼的《统计学》中偶然发现了这种方法略有不同的措辞。计算仅在一个参数上有所不同，但它会产生巨大的差异。</p><p id="bb7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">4.<strong class="lb iu">正常区间自举</strong></p><p id="1191" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正常间隔引导重复正常引导的所有步骤，但对CI使用以下公式:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/7d0bbed03d69721aecc9617e890cee38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/0*6JxwEofPg19NOjM5"/></div></figure><p id="7195" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中<em class="lv"> se_boot </em>是标准差的bootstrap估计值。</p><p id="64e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除非x*的分布接近正态，否则这个区间是不准确的。</p><p id="434a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本上，这里的公式没有除以<em class="lv"> n. </em>的平方根，我还没有找到为什么要这样做的解释。如果你有任何想法，请在评论中分享。</p><p id="5242" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">5.<strong class="lb iu">参数自举</strong></p><p id="1ff7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">参数自举非常接近经验方法，唯一的区别是自举样本的来源。对于参数bootstrap，我们从参数化分布中生成bootstrap样本。它通常用于贝叶斯后验分布的有效计算，而不是用于实验分析，所以我在这里不详细介绍它。</p><h1 id="cceb" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">比较方法</h1><p id="b1a4" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">正如前面承诺的，<a class="ae mt" href="https://github.com/LizaLebedeva/bootstrap-experiments" rel="noopener ugc nofollow" target="_blank">在这里</a>你可以找到Python实现的所有方法。目标是估计目标度量平均值的95% bootstrap置信区间。我尝试了自举方法、自举样本的数量和数据本身的样本大小。</p><p id="ca95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的主要问题是:<em class="lv">哪种bootstrap方法会显示更可靠的结果</em>。首先，正态bootstrap显然产生了过于狭窄的CI(因为正态假设)。在样本足够大的情况下，其他3种方法通常相互接近。百分位数和经验类型的优势在于，它们从左侧和右侧提供不同的区间(与正常区间自举相反)。通常，它更好，因为它考虑了数据的分布。正如您在下图中所看到的，百分位数和经验值的区间从左侧开始，在人口平均值所在的一侧。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/8517457d8b7a567733ae00b527196811.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QRKAFL2_LRThDhsX"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="ky">采用不同方法的自举置信区间(图片由作者提供)</em></p></figure><p id="804e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在百分位数和经验方法之间选择，我更倾向于百分位数方法，因为它简单。它的结果非常接近于经验方法，同时在计算中要求少一步。</p><p id="5402" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个重要的问题是:要做多少bootstrap抽样。这取决于数据大小。如果数据点少于1000个，合理的做法是将引导数据库数量减少不超过数据大小的两倍(如果有400个样本，则使用不超过200个引导数据库，进一步增加不会带来任何改进)。如果您有更多的数据，100到500之间的引导数量就足够了(更大的数量通常不会提高CI的准确性)。</p><h1 id="a19f" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">而不是结论</h1><p id="d286" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">使用自举应该记住的一个关键的评论是<strong class="lb iu">它不能改善点估计</strong>，这意味着自举的质量取决于收集的数据的质量。如果样本数据有偏差，不能很好地代表总体数据，bootstrap估计也会出现同样的情况。因此，请始终记住，在实验过程中收集的数据应该是总体数据的良好近似值。</p><p id="b6bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇博文中，我描述并比较了基本的bootstrap方法。实际上，还存在更多的方法(如<a class="ae mt" href="https://en.wikipedia.org/wiki/Bootstrapping_(statistics)" rel="noopener ugc nofollow" target="_blank">泊松、高斯、阻塞等</a>)。此外，bootstrap不仅与置信区间有关，还用于估计中位数的标准误差、75%百分位数、假设检验等。所有这些都是下一篇博文的好主题🙂</p><h1 id="2d9a" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">参考</h1><ul class=""><li id="c42d" class="mu mv it lb b lc mo lf mp li no lm np lq nq lu ni na nb nc bi translated">【https://projecteuclid.org/euclid.aos/1176344552#info T4】</li><li id="8446" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu ni na nb nc bi translated"><a class="ae mt" href="http://www-math.mit.edu/~dav/05.dir/class24-prep-a.pdf" rel="noopener ugc nofollow" target="_blank">http://www-math.mit.edu/~dav/05.dir/class24-prep-a.pdf</a></li><li id="1993" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu ni na nb nc bi translated"><a class="ae mt" href="https://en.wikipedia.org/wiki/Bootstrapping_(statistics)" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Bootstrapping _(statistics)</a></li></ul></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><p id="b732" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">原载于2020年5月17日https://elizavetalebedeva.com</em><a class="ae mt" href="https://elizavetalebedeva.com/bootstrapping-confidence-intervals-the-basics/" rel="noopener ugc nofollow" target="_blank"><em class="lv"/></a><em class="lv">。</em></p></div></div>    
</body>
</html>