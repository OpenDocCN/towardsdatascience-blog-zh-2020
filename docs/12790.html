<html>
<head>
<title>5 advanced Scikit-learn features that will transform the way you code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">5 个高级 sci kit-了解将改变您编码方式的特性</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/5-advanced-scikit-learn-features-that-will-transform-the-way-you-code-48262282ef0d?source=collection_archive---------43-----------------------#2020-09-02">https://towardsdatascience.com/5-advanced-scikit-learn-features-that-will-transform-the-way-you-code-48262282ef0d?source=collection_archive---------43-----------------------#2020-09-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/23a4b30ec1b52c4e4a44e2edb9b96669.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4WPidStTrafB3XRRq6hXMA.jpeg"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated"><em class="kf">照片由</em> <a class="ae kg" href="https://unsplash.com/@dallimonti?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> <em class="kf">安德烈斯·达利蒙提</em> </a> <em class="kf">上</em> <a class="ae kg" href="https://unsplash.com/s/photos/cockpit?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> <em class="kf"> Unsplash </em> </a></p></figure><p id="7625" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">很少有软件包能成功达到 sklearn 所达到的水平。这不仅是因为它们提供了几乎所有常用的<strong class="kj iu"> ML 算法</strong>，也是因为它们提供这些算法的方式。Sklearn 的核心代码是用<strong class="kj iu"> Cython </strong>编写的，提供了优化的性能。他们的<strong class="kj iu"> API </strong>被设计成提供一致性、可读性和可扩展性。在核心的 ML 算法之上，sklearn 为您提供了创建<strong class="kj iu">端到端管道</strong>的附加功能。如果有一个形容词可以形容这个包，它应该是“<strong class="kj iu"><em class="lf"/></strong><em class="lf">”。</em></p><p id="1dc2" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">如果你曾经和 sklearn 合作过，你大概会对 fit，predict，transform 等常用方法比较熟悉。也许您还会熟悉一些其他的预处理方法。但是这个软件包的功能远远超出了常用的功能。</p><p id="f862" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><strong class="kj iu">这篇文章的目标是</strong> <strong class="kj iu">突出 sklearn </strong>的一些非常强大但不太为人所知的特性。这些功能将使您能够释放 sklearn 的最大潜力。您将快速了解这些功能是什么以及如何使用它们。将提供一个非常短的代码片段，随后是更多详细信息的参考。代码片段的目的只是为了说明<strong class="kj iu">的功能和语法</strong>。这些片段并不代表完整的工作流程。最后，使用了<em class="lf"> 0.22.1 </em>。</p></div><div class="ab cl lg lh hx li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="im in io ip iq"><h1 id="98c6" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">1.管道</h1><p id="f14c" class="pw-post-body-paragraph kh ki it kj b kk ml km kn ko mm kq kr ks mn ku kv kw mo ky kz la mp lc ld le im bi translated">您的模型将总是由<strong class="kj iu">多个连续阶段</strong>组成，其中一个阶段的输出将是下一个阶段的输入。例如，高维输入的分类器通常包括归一化、维度减少和分类模型。</p><p id="aa51" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">Sklearn 的管道提供了一个<strong class="kj iu">优雅的包装器</strong>来链接这些连续的步骤。当您将使用管道时，您将不必担心管理中间对象。您需要做的就是指定步骤并调用<code class="fe mq mr ms mt b">fit</code>方法。在持久化你的模型的时候，你只需要 pickle 一个对象，就是管道。使用管道将提高代码的可读性，减少错误，并减轻训练模型的持久性。</p><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="4b86" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><a class="ae kg" href="https://scikit-learn.org/stable/modules/compose.html" rel="noopener ugc nofollow" target="_blank">阅读更多</a></p></div><div class="ab cl lg lh hx li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="im in io ip iq"><h1 id="1bb6" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">2.内嵌目标转换器</h1><p id="66bd" class="pw-post-body-paragraph kh ki it kj b kk ml km kn ko mm kq kr ks mn ku kv kw mo ky kz la mp lc ld le im bi translated">在某些情况下，在训练你的模型之前，你可以从目标的<strong class="kj iu">非线性变换</strong>中受益匪浅。例如，对于重尾目标的对数变换通常是非常明智的步骤。当使用模型预测新数据时，您需要确保您<strong class="kj iu">对预测的这个转换</strong>进行逆运算。</p><p id="8d1a" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">这里有一些好消息:您不需要使用 Pandas 或 Numpy 来创建这些转换。您可以<strong class="kj iu">使用 Sklearn </strong>直接应用目标变换，如下图所示:</p><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="277c" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><em class="lf">下面的事情会在引擎盖下自动发生:</em> <strong class="kj iu"> <em class="lf"> </em> </strong> <em class="lf">一边训练:</em> <code class="fe mq mr ms mt b">regressor.fit(X,func(y))</code> <em class="lf">一边预测:</em> <code class="fe mq mr ms mt b">inverse_func(regressor.predict(X))</code></p><p id="3e2c" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><a class="ae kg" href="https://scikit-learn.org/stable/modules/generated/sklearn.compose.TransformedTargetRegressor.html" rel="noopener ugc nofollow" target="_blank">阅读更多</a></p></div><div class="ab cl lg lh hx li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="im in io ip iq"><h1 id="3df5" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">3.特征联合</h1><p id="6a33" class="pw-post-body-paragraph kh ki it kj b kk ml km kn ko mm kq kr ks mn ku kv kw mo ky kz la mp lc ld le im bi translated">即使使用 sklearn 提供的顺序步骤，您也不会被每个步骤只有一个转换器所限制。你可以使用<strong class="kj iu">多个变压器</strong>和<strong class="kj iu">连接</strong>的结果在一个单一的步骤。</p><p id="ee82" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">在上面的流水线示例中，我们在训练之前使用了单个 PCA 来转换标准化数据。让我们举一个例子，除了线性 PCA 之外，我们还想使用内核 PCA:</p><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="abef" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">也可以在管线中插入特征联合。当然，你也可以编写自己的变形金刚。</p><p id="c5d4" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><a class="ae kg" href="https://scikit-learn.org/0.18/auto_examples/hetero_feature_union.html" rel="noopener ugc nofollow" target="_blank">阅读更多</a></p></div><div class="ab cl lg lh hx li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="im in io ip iq"><h1 id="d586" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">4.滚动预测的链接模型</h1><p id="f1b4" class="pw-post-body-paragraph kh ki it kj b kk ml km kn ko mm kq kr ks mn ku kv kw mo ky kz la mp lc ld le im bi translated">有时您会面临这样的情况，您需要链接多个模型，例如第一个模型的<strong class="kj iu">输出是第二个模型的</strong>输入。这种链接的一个非常常见的用例是在时间序列模型中:如果我们需要预测两个时间步，<code class="fe mq mr ms mt b">y(t+1)</code>的预测将是在<code class="fe mq mr ms mt b">y(t+2)</code>进行预测的输入。</p><p id="fe18" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">使用 sklearn，您可以选择自动创建链接。功能为<code class="fe mq mr ms mt b">RegressorChain</code>或<code class="fe mq mr ms mt b">ClassifierChain</code>。您的<code class="fe mq mr ms mt b">y</code>将不是一个数组，而是一个包含多个相关目标的矩阵。<code class="fe mq mr ms mt b">RegressorChain</code>将自动包括<strong class="kj iu">前一个目标，以预测下一个</strong>。在预测过程中，该链将根据上一个目标的预测来预测下一个目标。您需要做的就是像往常一样使用<code class="fe mq mr ms mt b">fit</code>和<code class="fe mq mr ms mt b">predict</code>方法。</p><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="4961" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><a class="ae kg" href="https://machinelearningmastery.com/multi-output-regression-models-with-python/" rel="noopener ugc nofollow" target="_blank">阅读更多</a></p></div><div class="ab cl lg lh hx li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="im in io ip iq"><h1 id="6d8c" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">5.使用排列的特征重要性</h1><p id="72e6" class="pw-post-body-paragraph kh ki it kj b kk ml km kn ko mm kq kr ks mn ku kv kw mo ky kz la mp lc ld le im bi translated">特征重要性通常是我们能够拥有并呈现给最终用户的最重要的建模洞察力之一。但是，根据您使用的算法，获取它们并不总是直截了当的。</p><p id="7011" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">置换可用于<strong class="kj iu">推断每个特征的重要性</strong>，而不考虑建模方法。背后的核心思想非常直观:单个特征被随机洗牌，模型得分的降低被量化。变化越大，特性越重要。</p><figure class="mu mv mw mx gt ju"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="c4a8" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><a class="ae kg" href="https://scikit-learn.org/stable/modules/permutation_importance.html" rel="noopener ugc nofollow" target="_blank">阅读更多</a></p></div><div class="ab cl lg lh hx li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="im in io ip iq"><blockquote class="na"><p id="22a2" class="nb nc it bd nd ne nf ng nh ni nj le dk translated"><strong class="ak">现在轮到你了:在 Sklearn 中分享另一个让你的代码变得更好的高级方法。把这个方法写在下面的评论里</strong></p></blockquote></div></div>    
</body>
</html>