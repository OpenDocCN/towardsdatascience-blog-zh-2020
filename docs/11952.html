<html>
<head>
<title>DeepChem — A framework for using ML and DL for Life Science and Chemoinformatics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">deep chem——在生命科学和化学信息学中使用 ML 和 DL 的框架</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/deepchem-a-framework-for-using-ml-and-dl-for-life-science-and-chemoinformatics-92cddd56a037?source=collection_archive---------28-----------------------#2020-08-18">https://towardsdatascience.com/deepchem-a-framework-for-using-ml-and-dl-for-life-science-and-chemoinformatics-92cddd56a037?source=collection_archive---------28-----------------------#2020-08-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="29e2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使 ML 和 DL 在药物发现、材料科学、量子化学和生物学中的使用民主化。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3fac483082e3ab5e1ce5cf7d8c8131d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Fm24ZPr_zhlPLNDMB8Pnw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:<a class="ae ky" href="https://pixabay.com/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="8f77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将机器学习和深度学习应用于药物发现、基因组学、显微观察和量子化学可以产生根本性的影响，并有可能显著加快医学研究和疫苗开发的进程，这是任何像 Covid19 这样的疫情所必需的。</p><p id="67d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们开始之前，这篇文章是一篇非常高水平的文章，专门针对对药物发现感兴趣的数据科学家和 ML 研究人员，尤其是在像 Covid19 <em class="lv">这样的现有疫情时期。</em></p><p id="d70a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">DeepChem 是一个开源框架，内部使用 TensorFlow，该框架专门用于简化各种生命科学应用的深度学习模型的创建。</p><p id="7c55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本教程中，我们将了解如何设置 DeepChem，以及如何将 DeepChem 用于:</p><blockquote class="lw lx ly"><p id="3142" class="kz la lv lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">1.训练一个可以预测分子毒性的模型</p><p id="fe40" class="kz la lv lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">2.训练预测分子溶解度的模型</p><p id="c207" class="kz la lv lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">3.使用智能字符串查询分子结构。</p></blockquote><h2 id="6bd6" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">设置 DeepChem</h2><p id="c22c" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">虽然，在多个来源中，我看到用户表达了他们对在 Windows、Linux 和 Mac 环境中设置 DeepChem 的关注，但是我发现使用 pip 安装程序很容易做到这一点。</p><p id="105e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">DeepChem 开发团队非常活跃，他们确实提供每日构建，所以我希望每个人都能看看他们的 pypi 页面:<a class="ae ky" href="https://pypi.org/project/deepchem/#history" rel="noopener ugc nofollow" target="_blank">https://pypi.org/project/deepchem/#history</a>并安装一个合适的版本，以防最新版本有任何问题。一个简单的<em class="lv"> pip 安装 deepchem </em>将会安装最新的版本。</p><p id="dea6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，除了 DeepChem，您还需要安装 TensorFlow。我已经使用<em class="lv"> pip install tensorflow </em>和开源化学信息学软件包 RDkit 安装了最新版本的 TensorFlow。对于 RDkit 和在 Windows 中安装，我没有找到任何可靠的 pip 安装程序，所以使用 conda 安装程序从<a class="ae ky" href="https://anaconda.org/rdkit/rdkit" rel="noopener ugc nofollow" target="_blank">https://anaconda.org/rdkit/rdkit</a>安装它:<em class="lv">conda install-c RDkit RDkit</em></p><p id="96a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦这三个模块安装完毕，我们就可以开始实验了。</p><h2 id="9ab8" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">预测分子的毒性</h2><p id="b806" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">分子毒性可以被定义为一种物质对任何有机体表现出的副作用的总和。计算方法实际上可以利用分子的化学和结构特性来确定给定化合物的毒性，并利用分子描述符(Dong 等人，<a class="ae ky" href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5714866/#B8" rel="noopener ugc nofollow" target="_blank"> 2015 </a>)和指纹(薛和 Bajorath，【2000】)来确定分子特征，可以有效地提取任何给定分子固有的化学和结构信息，用于基于预测的方法。</p><p id="1839" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了预测毒性，我们将使用 MoleculeNet 的 Tox21 毒性数据集，并使用 DeepChem 加载所需的数据集。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="6f8a" class="mc md it nb b gy nf ng l nh ni">import numpy as np<br/>import deepchem as dc<br/>tox21_tasks, tox21_datasets, transformers = dc.molnet.load_tox21()</span></pre><p id="e61f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在此之后，我们将看到所有的毒性类，只是打印到 21_tasks</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="9209" class="mc md it nb b gy nf ng l nh ni">['NR-AR',<br/> 'NR-AR-LBD',<br/> 'NR-AhR',<br/> 'NR-Aromatase',<br/> 'NR-ER',<br/> 'NR-ER-LBD',<br/> 'NR-PPAR-gamma',<br/> 'SR-ARE',<br/> 'SR-ATAD5',<br/> 'SR-HSE',<br/> 'SR-MMP',<br/> 'SR-p53']</span></pre><p id="9892" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过以下方式将整个数据集分为训练、测试和验证数据集:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="2bed" class="mc md it nb b gy nf ng l nh ni">train_dataset, valid_dataset, test_dataset = tox21_datasets</span></pre><p id="81fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们检查数据集的分布，我们会发现数据集是不平衡的，因此我们需要平衡数据集，因为通常我们会尝试解决多类分类问题。因此，如果数据集不平衡，多数类会给分类器增加偏差，这会扭曲结果。因此，默认使用的 transformer 对象是一个平衡转换器。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="3cd0" class="mc md it nb b gy nf ng l nh ni">print(transformers)<br/>[&lt;deepchem.trans.transformers.BalancingTransformer at 0x26b5642dc88&gt;]</span></pre><p id="ea3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，对于培训部分:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="0adb" class="mc md it nb b gy nf ng l nh ni">model = dc.models.MultitaskClassifier(n_tasks=12, n_features=1024, layer_sizes=[1000])<br/>model.fit(train_dataset, nb_epoch=10)<br/>metric = dc.metrics.Metric(dc.metrics.roc_auc_score, np.mean)<br/>train_scores = model.evaluate(train_dataset, [metric], transformers)<br/>test_scores = model.evaluate(test_dataset, [metric], transformers)</span></pre><p id="ab51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，DeepChem 的子模块包含各种<strong class="lb iu"> dc.models </strong>不同的生命科学专用模型。</p><p id="7755" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后我们看到，最终的 AUC-ROC 分数是:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="48fc" class="mc md it nb b gy nf ng l nh ni">{'training mean-roc_auc_score': 0.9556297601807405}<br/>{'testing mean-roc_auc_score': 0.7802496964641786}</span></pre><p id="7cfe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这向我们表明，在模型中存在一些过度拟合，因为与训练集相比，测试数据集度量得分要少得多。但是，尽管如此，现在我们确实有了一个可以预测分子毒性的模型！</p><h2 id="b9b8" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">预测分子的溶解度</h2><p id="536a" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">溶解度是一种度量，它显示了分子在水中溶解的难易程度。对于任何药物发现，检查化合物的溶解度是非常重要的，因为药物应该溶解到患者的血流中，以达到所需的治疗效果。通常，药物化学家花费大量时间来修饰分子以增加溶解性。在本节中，我们将使用 DeepChem 来预测分子的溶解度。</p><p id="3770" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用 MoleculeNet 的<strong class="lb iu"> delaney 数据集来预测分子溶解度，该数据集也可在 DeepChem 中获得。</strong></p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="deb8" class="mc md it nb b gy nf ng l nh ni"># load the featurized data <br/>tasks, datasets, transformers = dc.molnet.load_delaney(featurizer='GraphConv')</span><span id="2eb0" class="mc md it nb b gy nj ng l nh ni"># Split into traintest-validation dataset<br/>train_dataset, valid_dataset, test_dataset = datasets</span><span id="d9f8" class="mc md it nb b gy nj ng l nh ni"># Fit the model<br/>model = dc.models.GraphConvModel(n_tasks=1, mode='regression', dropout=0.2)<br/>model.fit(train_dataset, nb_epoch=100)</span><span id="ad1c" class="mc md it nb b gy nj ng l nh ni"># Use r2 score as model evaluation metric<br/>metric = dc.metrics.Metric(dc.metrics.pearson_r2_score)<br/>print(model.evaluate(train_dataset, [metric], transformers))<br/>print(model.evaluate(test_dataset, [metric], transformers))</span></pre><p id="7218" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">甚至在第一遍中，我们从模型评估结果中看到一些过度拟合。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="6c61" class="mc md it nb b gy nf ng l nh ni">{'training pearson_r2_score': 0.9203419837932797}<br/>{'testing pearson_r2_score': 0.7529095508565846}</span></pre><p id="6282" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看如何预测一组新分子的溶解度:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="936c" class="mc md it nb b gy nf ng l nh ni">smiles = ['COC(C)(C)CCCC(C)CC=CC(C)=CC(=O)OC(C)C',<br/>'CCOC(=O)CC',<br/>'CSc1nc(NC(C)C)nc(NC(C)C)n1',<br/>'CC(C#C)N(C)C(=O)Nc1ccc(Cl)cc1',<br/>'Cc1cc2ccccc2cc1C']</span></pre><p id="793b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们需要从它们的 SMILES 格式来描述这些新的分子</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="fef9" class="mc md it nb b gy nf ng l nh ni">from rdkit import Chem<br/>mols = [Chem.MolFromSmiles(s) for s in smiles]<br/>featurizer = dc.feat.ConvMolFeaturizer()<br/>x = featurizer.featurize(mols)</span><span id="5510" class="mc md it nb b gy nj ng l nh ni">predicted_solubility = model.predict_on_batch(x)<br/>predicted_solubility</span></pre><p id="7c7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们可以看到预测的溶解度值:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="9c90" class="mc md it nb b gy nf ng l nh ni">array([[-0.45654652],<br/>       [ 1.5316172 ],<br/>       [ 0.19090167],<br/>       [ 0.44833142],<br/>       [-0.32875094]], dtype=float32)</span></pre><p id="570f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们很容易看到 DeepChem 如何使上述两个用例变得非常容易，这可能需要一个人类化学家花很多时间来解决这些问题！</p><p id="8ae1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于最后一部分，我们将看到一些可视化和查询技术作为 RDkit 的一部分，这是任何人在处理这种用例时都非常需要的。</p><h2 id="f5c5" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated"><strong class="ak">智能字符串来查询分子结构</strong></h2><p id="ac8a" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">SMARTS 是前面描述的 SMILES 语言的扩展，可用于创建查询。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="01d4" class="mc md it nb b gy nf ng l nh ni"># To gain a visual understanding of compounds in our dataset, let's draw them using rdkit. We define a couple of helper functions to get started</span><span id="6bd1" class="mc md it nb b gy nj ng l nh ni">import tempfile<br/>from rdkit import Chem<br/>from rdkit.Chem import Draw<br/>from itertools import islice<br/>from IPython.display import Image, display</span><span id="3346" class="mc md it nb b gy nj ng l nh ni">def display_images(filenames):<br/>    """Helper to pretty-print images."""<br/>    for file in filenames:<br/>          display(Image(file))</span><span id="1e9f" class="mc md it nb b gy nj ng l nh ni">def mols_to_pngs(mols, basename="test"):<br/>    """Helper to write RDKit mols to png files."""<br/>    filenames = []<br/>    for i, mol in enumerate(mols):<br/>        filename = "%s%d.png" % (basename, i)<br/>        Draw.MolToFile(mol, filename)<br/>        filenames.append(filename)<br/>    return filenames</span></pre><p id="544a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们来看一个微笑的样本，并想象它的分子结构。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="638c" class="mc md it nb b gy nf ng l nh ni">from rdkit import Chem<br/>from rdkit.Chem.Draw import MolsToGridImage<br/>smiles_list = ["CCCCC","CCOCC","CCNCC","CCSCC"]<br/>mol_list = [Chem.MolFromSmiles(x) for x in smiles_list]<br/>display_images(mols_to_pngs(mol_list))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/f0d074d04fdf77141c211fdcbc6852ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:360/format:webp/1*KEQ-Dfz90BGirL1Goyyi4Q.png"/></div></figure><p id="6026" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是视觉结构是如何从微笑字符串形成的。</p><p id="e5da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，假设我们想要查询具有三个相邻碳的微笑字符串。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="4141" class="mc md it nb b gy nf ng l nh ni">query = Chem.MolFromSmarts("CCC")<br/>match_list = [mol.GetSubstructMatch(query) for mol in<br/>mol_list]<br/>MolsToGridImage(mols=mol_list, molsPerRow=4,<br/>highlightAtomLists=match_list)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/a0712313572e2f126c058c0a9315ef2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n6-iMmKY1VOnRMxgxRoVPA.png"/></div></div></figure><p id="f670" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到，突出显示的部分，代表有三个相邻碳的化合物。</p><p id="58c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，让我们看看一些通配符查询和其他子结构查询选项。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="19a5" class="mc md it nb b gy nf ng l nh ni">query = Chem.MolFromSmarts("C*C")<br/>match_list = [mol.GetSubstructMatch(query) for mol in<br/>mol_list]<br/>MolsToGridImage(mols=mol_list, molsPerRow=4,<br/>highlightAtomLists=match_list)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/275afc429035835715f1083e179372bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v_w7OVTXyAt8BlFXXsIUyA.png"/></div></div></figure><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="27a4" class="mc md it nb b gy nf ng l nh ni">query = Chem.MolFromSmarts("C[C,N,O]C")<br/>match_list = [mol.GetSubstructMatch(query) for mol in<br/>mol_list]<br/>MolsToGridImage(mols=mol_list, molsPerRow=4,<br/>highlightAtomLists=match_list)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/96c8918207a6d6caa2e6779118e9dd5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ee4P_YU3Yned4R-lkX25aw.png"/></div></div></figure><p id="a9d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们可以看到，选择性子查询也可以很容易地处理。</p><p id="0658" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">因此，这就把我们带到了本文的结尾。我知道这篇文章水平很高，专门针对对药物发现感兴趣的数据科学家和 ML 研究人员，尤其是在 Covid19 等现有疫情的时代。希望我能帮上忙！如果你在生物信息学或化学信息学方面有很强的背景，并希望进入数据科学领域，请通过这里提到的</em><a class="ae ky" href="https://aditya-bhattacharya.net/contact-me/" rel="noopener ugc nofollow" target="_blank"><em class="lv"/></a><em class="lv">中的任何选项联系我。继续关注:</em><a class="ae ky" href="https://medium.com/@adib0073" rel="noopener"><em class="lv">https://medium.com/@adib0073</em></a><em class="lv">和我的网站:</em><a class="ae ky" href="https://aditya-bhattacharya.net/" rel="noopener ugc nofollow" target="_blank">https://www.aditya-bhattacharya.net/</a><em class="lv">了解更多</em>！</p></div></div>    
</body>
</html>