<html>
<head>
<title>Common Image Processing Techniques in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中常用的图像处理技术</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/common-image-processing-techniques-in-python-e768d32813a8?source=collection_archive---------31-----------------------#2020-06-01">https://towardsdatascience.com/common-image-processing-techniques-in-python-e768d32813a8?source=collection_archive---------31-----------------------#2020-06-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="21ce" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用 PIL 和 OpenCV 学习简单而强大的图像处理技术</h2></div><p id="81df" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">在这篇文章中，你将学习</em></p><ul class=""><li id="7677" class="lf lg it kk b kl km ko kp kr lh kv li kz lj ld lk ll lm ln bi translated"><em class="le">使用 PIL 和 OpenCV 的常见图像处理技术，如将 RGB 图像转换为灰度图像、旋转图像、去除图像噪声、检测图像边缘以及裁剪图像中的感兴趣区域</em></li><li id="ab1b" class="lf lg it kk b kl lo ko lp kr lq kv lr kz ls ld lk ll lm ln bi translated"><em class="le">使用 OpenCV 的模板匹配在图像中搜索物体</em></li></ul><h2 id="7f88" class="lt lu it bd lv lw lx dn ly lz ma dp mb kr mc md me kv mf mg mh kz mi mj mk ml bi translated">必需的库:</h2><p id="da20" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">PIL、OpenCV 和 imutils</p><p id="eddd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="le">为什么需要学习图像处理技术？</em>T9】</strong></p><p id="2627" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">深度学习用于分析、识别和生成对图像中对象的智能理解。一些常见的应用是<strong class="kk iu">图像分类、对象检测、实例分割、</strong>等。因此，必须对图像处理技术有深入的了解，如图像增强，包括裁剪图像、去除图像中存在的噪声或旋转图像等。，以建立更好的训练数据集。</p><p id="1437" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">图像处理技术同样有助于光学字符识别(OCR)</p><blockquote class="mr"><p id="a326" class="ms mt it bd mu mv mw mx my mz na ld dk translated">图像处理技术通过帮助识别关键特征或从图像中读取文本来增加图像的可解释性，以分类或检测图像中存在的对象。</p></blockquote><figure class="nc nd ne nf ng nh gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nb"><img src="../Images/1bd2396dab34760cc29c7c23a544dfad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lVOi38NjNepRaXULg2dB0w.png"/></div></div><p class="no np gj gh gi nq nr bd b be z dk translated">照片由<a class="ae ns" href="https://unsplash.com/@jannerboy62?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">缺口缺口</a>在<a class="ae ns" href="https://unsplash.com/s/photos/sign-board?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">缺口</a>处拍摄</p></figure><p id="30d3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此处提供代码和图片<a class="ae ns" href="https://github.com/arshren/Image-Processing/blob/master/Image%20Processing_1.ipynb" rel="noopener ugc nofollow" target="_blank"/></p><p id="4f62" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">导入所需的库</strong></p><pre class="nt nu nv nw gt nx ny nz oa aw ob bi"><span id="f3db" class="lt lu it ny b gy oc od l oe of"><strong class="ny iu">import cv2<br/>from PIL import Image</strong></span></pre><p id="50b2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="le">让我们先用 OpenCV 和 PIL </em> </strong>显示图像</p><p id="4d5c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">使用 OpenCV 读取并显示图像</strong></p><pre class="nt nu nv nw gt nx ny nz oa aw ob bi"><span id="60ea" class="lt lu it ny b gy oc od l oe of"># Reading and Displaying the file<br/><strong class="ny iu">image = cv2.imread(r'love.jpg')<br/>cv2.imshow("Image", image)<br/>cv2.waitKey(0)</strong></span></pre><p id="c093" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果图像太大，那么显示图像的窗口将不适合屏幕。</p><p id="c0df" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="le">那么我如何在屏幕上显示完整的图像呢？</em>T29】</strong></p><p id="00ae" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">默认情况下，当显示超大图像时，您会看到裁剪后的显示。要查看完整图像，您将使用 OpenCV 的<strong class="kk iu"> <em class="le"> namedWindow(name，flag) </em> </strong>创建一个新窗口。第一个参数，<strong class="kk iu"> <em class="le"> name，</em> </strong>是窗口的标题，将被用作标识符。当您将<strong class="kk iu"> <em class="le">标志</em> </strong>设置为<strong class="kk iu"> cv2 时。WINDOW_NORMAL，</strong>然后显示完整图像，您可以调整窗口大小。flag 参数还有其他选项。</p><pre class="nt nu nv nw gt nx ny nz oa aw ob bi"><span id="2b0c" class="lt lu it ny b gy oc od l oe of"># Resizing the image for the user to resize the window <br/><strong class="ny iu">image = cv2.imread(r'love.jpg')<br/>cv2.namedWindow('Normal Window', cv2.WINDOW_NORMAL)<br/>cv2.imshow('Normal Window', image)<br/>cv2.waitKey(0)</strong></span></pre><p id="3840" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">调整图像大小</strong></p><p id="8f61" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们调整图像大小时，我们改变图像的高度和/或宽度，并保持纵横比。图像的宽高比是图像的宽高比。</p><pre class="nt nu nv nw gt nx ny nz oa aw ob bi"><span id="44be" class="lt lu it ny b gy oc od l oe of"><strong class="ny iu">image= cv2.imread(r'taj.jpg')</strong><br/><strong class="ny iu">scale_percent =200</strong> # percent of original size<br/><strong class="ny iu">width = int(image.shape[1] * scale_percent / 100)</strong><br/><strong class="ny iu">height = int(image.shape[0] * scale_percent / 100)<br/>dim = (width, height)<br/>resized = cv2.resize(image, dim, interpolation = cv2.INTER_AREA)<br/>cv2.imshow("Resize", resized)<br/>cv2.waitKey(0)</strong></span></pre><p id="f7ec" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">使用 PIL 读取并显示图像</strong></p><p id="9b87" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您将使用<strong class="kk iu"> <em class="le"> open() </em> </strong>加载图像，然后使用<strong class="kk iu"> <em class="le"> show() </em> </strong>进行显示。</p><p id="463c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="le">形象。</em>show()</strong>创建一个临时文件。</p><pre class="nt nu nv nw gt nx ny nz oa aw ob bi"><span id="bdd6" class="lt lu it ny b gy oc od l oe of"><strong class="ny iu">pil_image= Image.open(r'love.jpg')<br/>pil_image.show("PIL Image")</strong></span></pre><p id="9803" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="le">如果你对识别图像中的边缘或其他特征感兴趣怎么办？</em> </strong></p><p id="6295" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">灰度图像用于识别边缘。灰度图像还有助于理解图像中存在的对比度或阴影梯度，以及理解它们在分析图像特征中的作用。</p><p id="effa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与灰度图像的 2D 通道相比，RGB 图像有三个通道:红色、绿色和蓝色。与彩色图像相比，灰度图像的每像素信息更少，因此灰度图像的处理时间更快。</p><h2 id="4361" class="lt lu it bd lv lw lx dn ly lz ma dp mb kr mc md me kv mf mg mh kz mi mj mk ml bi translated">利用 OpenCV 实现彩色图像的灰度化</h2><p id="55c7" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">我们正在使用<strong class="kk iu"> <em class="le"> cvtColor()，</em> </strong>将彩色图像转换为灰度图像，这将把图像从一个色彩空间保存到另一个色彩空间。</p><pre class="nt nu nv nw gt nx ny nz oa aw ob bi"><span id="716b" class="lt lu it ny b gy oc od l oe of">#Converting image to grayscale<br/><strong class="ny iu">image = cv2.imread(r'love.jpg')<br/>gray_image= cv2.cvtColor(image, cv2.COLOR_RGB2GRAY)<br/>cv2.namedWindow('Gray Image', cv2.WINDOW_NORMAL)<br/>cv2.imshow('Gray Image', gray_image)<br/>cv2.waitKey(0)</strong></span></pre><figure class="nt nu nv nw gt nh gh gi paragraph-image"><div class="gh gi og"><img src="../Images/cbd2bb63e21f18335f40a25f325cf161.png" data-original-src="https://miro.medium.com/v2/resize:fit:702/format:webp/1*Pj0ts90TBHGRXYPMlf_lUw.png"/></div></figure><h2 id="fcf6" class="lt lu it bd lv lw lx dn ly lz ma dp mb kr mc md me kv mf mg mh kz mi mj mk ml bi translated">使用 PIL 对彩色图像进行灰度缩放</h2><p id="d220" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated"><strong class="kk iu"><em class="le">【convert()</em></strong>返回此图像的转换副本；灰度使用“L”模式，彩色使用“RGB”模式。</p><pre class="nt nu nv nw gt nx ny nz oa aw ob bi"><span id="ab85" class="lt lu it ny b gy oc od l oe of"># Gray image using PIL<br/><strong class="ny iu">pil_image= Image.open(r'love.jpg')<br/>gray_pil=pil_image.convert('L')<br/>gray_pil.show()</strong></span></pre><h2 id="d500" class="lt lu it bd lv lw lx dn ly lz ma dp mb kr mc md me kv mf mg mh kz mi mj mk ml bi translated">使用 OpenCV 进行边缘检测</h2><p id="af15" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">使用<strong class="kk iu"> canny 边缘检测器</strong>检测图像中的边缘。<strong class="kk iu">Canny 边缘检测器通过多阶段算法使用灰度图像</strong>。</p><p id="a425" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="le"> Canny() </em> : </strong>第一个参数是<strong class="kk iu">输入图像，</strong>第二个和第三个参数是<strong class="kk iu"> threshold1 </strong>和<strong class="kk iu"> threshold2 </strong>值。</p><p id="955e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">强度梯度大于阈值 2 的边缘被认为是边缘，而低于阈值 1 的边缘被认为是非边缘。非边缘将被移除。两个阈值之间的任何梯度强度值基于它们的连通性被分类为边缘或非边缘。</p><pre class="nt nu nv nw gt nx ny nz oa aw ob bi"><span id="ee94" class="lt lu it ny b gy oc od l oe of"><strong class="ny iu">image= cv2.imread(r'taj.jpg')<br/>cv2.namedWindow("Edge", cv2.WINDOW_NORMAL)<br/>denoised_image = cv2.Canny(image, 100,200 )<br/>cv2.imshow("Edge", denoised_image)<br/>cv2.waitKey(0)</strong></span></pre><figure class="nt nu nv nw gt nh gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/e22c6b6024a2c52c2d0eac7356127152.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/1*iCizwbIKrSXtEwRURIfwNA.png"/></div><p class="no np gj gh gi nq nr bd b be z dk translated">Canny 边缘检测器</p></figure><p id="8bc7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="le">如果图像有歪斜或轻微旋转，想对图像进行纠偏怎么办？</em>T3】</strong></p><p id="8441" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">倾斜文本的 OCR 效果不好，因此我们需要进行倾斜校正。可以使用 OpenCV 和 PIL 的<strong class="kk iu"> <em class="le"> rotate() </em> </strong>对图像进行纠偏。</p><h2 id="3089" class="lt lu it bd lv lw lx dn ly lz ma dp mb kr mc md me kv mf mg mh kz mi mj mk ml bi translated">使用 OpenCV 旋转图像</h2><p id="f5e2" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated"><strong class="kk iu"> <em class="le"> rotate() </em> </strong>将根据<strong class="kk iu"> rotationCode，</strong>旋转图像，该代码为旋转函数的第二个参数<strong class="kk iu"> </strong>。</p><p id="830d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">旋转码</strong>的值为</p><ul class=""><li id="3007" class="lf lg it kk b kl km ko kp kr lh kv li kz lj ld lk ll lm ln bi translated">cv2。顺时针旋转 90 度，</li><li id="98f9" class="lf lg it kk b kl lo ko lp kr lq kv lr kz ls ld lk ll lm ln bi translated">cv2。逆时针旋转 90 度</li><li id="90f7" class="lf lg it kk b kl lo ko lp kr lq kv lr kz ls ld lk ll lm ln bi translated">cv2。旋转 _180 度</li></ul><pre class="nt nu nv nw gt nx ny nz oa aw ob bi"><span id="f195" class="lt lu it ny b gy oc od l oe of">#Rotating the image<br/><strong class="ny iu">image = cv2.imread(r'love.jpg')<br/>cv2.namedWindow("Rotated Image", cv2.WINDOW_NORMAL)<br/>rotated_img= cv2.rotate(image,cv2.ROTATE_90_CLOCKWISE )<br/>cv2.imshow("Rotated Image", rotated_img)<br/>cv2.waitKey(0)</strong></span></pre><figure class="nt nu nv nw gt nh gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/a566666292569d3cc865e68a0c5ceff8.png" data-original-src="https://miro.medium.com/v2/resize:fit:732/format:webp/1*1vWLwTEyMW87jQYqsbOvDA.png"/></div><p class="no np gj gh gi nq nr bd b be z dk translated">使用 OpenCV 顺时针旋转 90 度的图像</p></figure><p id="d3ee" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="le">如果我想只旋转图像一个特定的角度怎么办？</em> </strong></p><p id="3d19" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">根据特定角度旋转图像</strong></p><p id="7d8d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在下面的代码中，使用<strong class="kk iu"> imutils </strong>的<strong class="kk iu"> <em class="le"> rotate() </em> </strong>将图像旋转 60 度</p><pre class="nt nu nv nw gt nx ny nz oa aw ob bi"><span id="7023" class="lt lu it ny b gy oc od l oe of"><strong class="ny iu">import imutils<br/>import numpy as np</strong></span><span id="01b1" class="lt lu it ny b gy oj od l oe of"><strong class="ny iu">image = cv2.imread(r'love.jpg')</strong></span><span id="2d5a" class="lt lu it ny b gy oj od l oe of"># loop over the rotation angles<br/><strong class="ny iu">for angle in np.arange(0, 360, 60):<br/>    cv2.namedWindow("Rotated", cv2.WINDOW_NORMAL)<br/>    rotated = imutils.rotate(image, angle)<br/>    cv2.imshow("Rotated", rotated)<br/>    cv2.waitKey(0)</strong></span></pre><figure class="nt nu nv nw gt nh gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi ok"><img src="../Images/c1d7e18a9729a457aa9dfe95898e5802.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_a3_tI3GEz6uQhb0q5tPoQ.png"/></div></div><p class="no np gj gh gi nq nr bd b be z dk translated">使用 imutils 以 60 度为增量旋转图像</p></figure><h2 id="17e0" class="lt lu it bd lv lw lx dn ly lz ma dp mb kr mc md me kv mf mg mh kz mi mj mk ml bi translated">使用 PIL 旋转图像</h2><p id="0ee7" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">这里的图像使用 PIL 旋转了 110 度</p><pre class="nt nu nv nw gt nx ny nz oa aw ob bi"><span id="b7ef" class="lt lu it ny b gy oc od l oe of"># Rotate image using PIL<br/><strong class="ny iu">pil_image= Image.open(r'love.jpg')<br/>rotate_img_pil=pil_image.rotate(110)<br/>rotate_img_pil.show()</strong></span></pre><figure class="nt nu nv nw gt nh gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/0cf4a84ff2d5da67d96d97f2a8547b7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/format:webp/1*gUsIBo8J9AVRwxWVOCdXEQ.png"/></div><p class="no np gj gh gi nq nr bd b be z dk translated">使用 PIL 旋转 110 度的图像</p></figure><p id="979a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="le">当图像质量因噪声的存在而变差并影响图像分析时，如何增强图像质量？</em> </strong></p><h2 id="1dc0" class="lt lu it bd lv lw lx dn ly lz ma dp mb kr mc md me kv mf mg mh kz mi mj mk ml bi translated">利用 OpenCV 实现图像去噪</h2><p id="1fc4" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">噪声是不想要的信号，就图像而言，它是颜色的随机变化。</p><p id="da3d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用 OpenCV 最小化图像中的噪声。</p><pre class="nt nu nv nw gt nx ny nz oa aw ob bi"><span id="1da5" class="lt lu it ny b gy oc od l oe of"><strong class="ny iu">image= cv2.imread(r'taj.jpg')<br/>cv2.namedWindow("Noised Image", cv2.WINDOW_NORMAL)<br/>cv2.imshow("Noised Image", image)<br/>cv2.waitKey(0)</strong></span></pre><figure class="nt nu nv nw gt nh gh gi paragraph-image"><div class="gh gi om"><img src="../Images/5ad143fe575f3145501781dcbba9c3a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*4lLY8gFurGStfzQ72GZ8Lg.png"/></div></figure><p id="8a33" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">OpenCV 中有不同的方法来去除图像中的噪声。下面用的是<a class="ae ns" href="https://docs.opencv.org/3.4/d1/d79/group__photo__denoise.html#ga03aa4189fc3e31dafd638d90de335617" rel="noopener ugc nofollow" target="_blank"><strong class="kk iu">cv . fastnlmeansdenoisingcolored(</strong></a><strong class="kk iu">)，</strong>就是去除彩色图像中的噪点。</p><p id="ec4e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">fast nimeans 降噪</strong>方法的常见参数有</p><ul class=""><li id="a1cf" class="lf lg it kk b kl km ko kp kr lh kv li kz lj ld lk ll lm ln bi translated"><strong class="kk iu"> src </strong>:来源图片</li><li id="cc83" class="lf lg it kk b kl lo ko lp kr lq kv lr kz ls ld lk ll lm ln bi translated"><strong class="kk iu"> dst </strong>:输出与 src 相同大小和类型的图像</li><li id="86ee" class="lf lg it kk b kl lo ko lp kr lq kv lr kz ls ld lk ll lm ln bi translated"><strong class="kk iu"> h </strong>:调节过滤强度。较高的 h 值完美地去除了图像细节中的噪声，较小的 h 值将保留图像细节和一些噪声。</li><li id="a418" class="lf lg it kk b kl lo ko lp kr lq kv lr kz ls ld lk ll lm ln bi translated"><strong class="kk iu"> hForColorComponents </strong>:与 h 相同，但仅用于彩色图像，通常与 h 相同</li><li id="c8ab" class="lf lg it kk b kl lo ko lp kr lq kv lr kz ls ld lk ll lm ln bi translated"><strong class="kk iu"> templateWindowSize </strong>:应该是奇数。(推荐 7)</li><li id="a54f" class="lf lg it kk b kl lo ko lp kr lq kv lr kz ls ld lk ll lm ln bi translated"><strong class="kk iu"> searchWindowSize </strong>:应该是奇数。(推荐 21)</li></ul><pre class="nt nu nv nw gt nx ny nz oa aw ob bi"><span id="a0c6" class="lt lu it ny b gy oc od l oe of"><strong class="ny iu">image= cv2.imread(r'taj.jpg')<br/>cv2.namedWindow("Denoised Image", cv2.WINDOW_NORMAL)<br/>denoised_image = cv2.fastNlMeansDenoisingColored(image,None, h=5)<br/>cv2.imshow("Denoised Image", denoised_image)<br/>cv2.waitKey(0)</strong></span></pre><figure class="nt nu nv nw gt nh gh gi paragraph-image"><div class="gh gi on"><img src="../Images/ce12728a35f897f514211871460710bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*LB6GKz9zWMr6bbgCddTxwQ.png"/></div></figure><p id="a141" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="le">如何从一幅图像中提取某些感兴趣的区域？</em>T57】</strong></p><h2 id="fa5e" class="lt lu it bd lv lw lx dn ly lz ma dp mb kr mc md me kv mf mg mh kz mi mj mk ml bi translated">裁剪图像</h2><p id="5a43" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">裁剪图像可让您提取图像中感兴趣的区域。</p><p id="47c9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将裁剪泰姬陵的图像，只保留泰姬陵，并删除图像中的其他细节。</p><p id="4607" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">使用 OpenCV 裁剪图像</strong></p><p id="d28b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">OpenCV 中的裁剪是通过对图像数组进行切片来完成的，我们通过 y 坐标的起点和终点，然后是 x 坐标的起点和终点。</p><p id="241c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">图像【y_start:y_end，x _ start:x _ end】</strong></p><pre class="nt nu nv nw gt nx ny nz oa aw ob bi"><span id="81fc" class="lt lu it ny b gy oc od l oe of"><strong class="ny iu">image= cv2.imread(r'taj.jpg')<br/>resized_img= image[15:170, 20:200]<br/>cv2.imshow("Resize", resized_img)<br/>cv2.waitKey(0)</strong></span></pre><figure class="nt nu nv nw gt nh gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/388c9ac72a0965e68a95d29bea1f9d83.png" data-original-src="https://miro.medium.com/v2/resize:fit:550/format:webp/1*O1LEJx8RoQIuPJ_a0tVVaA.png"/></div></figure><p id="e4ff" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">使用 PIL 裁剪图像</strong></p><p id="899e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">PIL 的<strong class="kk iu"> <em class="le"> crop() </em> </strong>允许我们裁剪图像的一个矩形区域，参数<strong class="kk iu"> <em class="le"> crop() </em> </strong>是<strong class="kk iu"> <em class="le">左坐标、上坐标、右坐标和下像素坐标。</em> </strong></p><pre class="nt nu nv nw gt nx ny nz oa aw ob bi"><span id="2d96" class="lt lu it ny b gy oc od l oe of"># Opens a image in RGB mode <br/><strong class="ny iu">pil_image = Image.open(r'taj.jpg') </strong><br/>  <br/># Get the Size of the image in pixels <br/><strong class="ny iu">width, height = pil_image.size </strong><br/>  <br/># Setting the cropped image co-ordinates<br/><strong class="ny iu">left = 3<br/>top = height /25<br/>right = 200<br/>bottom = 3 * height / 4</strong><br/>  <br/># Crop the  image based on the above dimension <br/><strong class="ny iu">cropped_image = pil_image.crop((left, top, right, bottom))</strong><br/>  <br/># Shows the image in image viewer <br/><strong class="ny iu">cropped_image.show()</strong></span></pre><figure class="nt nu nv nw gt nh gh gi paragraph-image"><div class="gh gi op"><img src="../Images/b9d7da790b6a729eab004e8a5ff51540.png" data-original-src="https://miro.medium.com/v2/resize:fit:596/format:webp/1*_HW-_TyP__B6Ypz1KkL0ew.png"/></div><p class="no np gj gh gi nq nr bd b be z dk translated">使用 PIL 裁剪图像</p></figure><h2 id="3757" class="lt lu it bd lv lw lx dn ly lz ma dp mb kr mc md me kv mf mg mh kz mi mj mk ml bi translated">模板匹配</h2><p id="83cf" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">您可以提供一个模板，并使用 OpenCV 的<strong class="kk iu"><em class="le">match template()</em></strong>在图像中搜索该模板并提取其位置。</p><p id="df8f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">模板像卷积神经网络一样在整个图像上滑动，并试图将模板与输入图像匹配。</p><p id="5cff" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> minMaxLoc() </strong>用于<strong class="kk iu"> </strong>获取最大/最小值，它将是矩形的左上角连同宽度和高度。</p><p id="6ac0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有 6 种方法可用于模板匹配</p><ul class=""><li id="f10f" class="lf lg it kk b kl km ko kp kr lh kv li kz lj ld lk ll lm ln bi translated">cv2。TM_SQDIFF</li><li id="cf5a" class="lf lg it kk b kl lo ko lp kr lq kv lr kz ls ld lk ll lm ln bi translated">cv2。TM_SQDIFF_NORMED</li><li id="ca69" class="lf lg it kk b kl lo ko lp kr lq kv lr kz ls ld lk ll lm ln bi translated">cv2。TM_CCORR</li><li id="01e9" class="lf lg it kk b kl lo ko lp kr lq kv lr kz ls ld lk ll lm ln bi translated">cv2。TM_CCORR_NORMED</li><li id="2e29" class="lf lg it kk b kl lo ko lp kr lq kv lr kz ls ld lk ll lm ln bi translated">cv2。TM_CCOEFF</li><li id="3291" class="lf lg it kk b kl lo ko lp kr lq kv lr kz ls ld lk ll lm ln bi translated">cv2。TM_CCOEFF_NORMED</li></ul><p id="cef7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在下面的例子中，我从主图像中裁剪了一小部分来创建模板。</p><p id="5777" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">用于模板匹配的方法是 TM_CCOEFF_NORMED。匹配的阈值设置为 0.95。它定位具有大于 95%的较高匹配概率的位置，然后在对应于匹配的区域周围绘制矩形。</p><pre class="nt nu nv nw gt nx ny nz oa aw ob bi"><span id="2844" class="lt lu it ny b gy oc od l oe of">import cv2<br/><strong class="ny iu">import numpy as np<br/>from matplotlib import pyplot as plt<br/>img = cv2.imread(r'love.jpg',0)</strong></span><span id="8c32" class="lt lu it ny b gy oj od l oe of"><strong class="ny iu">cv2.imshow("main",img)<br/>cv2.waitKey(0)</strong></span><span id="ce45" class="lt lu it ny b gy oj od l oe of"><strong class="ny iu">template = cv2.imread(r'template1.png',0)<br/>cv2.imshow("Template",template</strong>)<br/><strong class="ny iu">cv2.waitKey(0)</strong></span><span id="c614" class="lt lu it ny b gy oj od l oe of"><strong class="ny iu">w, h = template.shape[::-1]<br/>methods = [ 'cv2.TM_CCOEFF_NORMED']</strong></span><span id="32ff" class="lt lu it ny b gy oj od l oe of"><strong class="ny iu">for meth in methods:<br/>    <br/>    method = eval(meth)</strong></span><span id="bb3f" class="lt lu it ny b gy oj od l oe of"># Apply template Matching<br/>    <strong class="ny iu">res = cv2.matchTemplate(img,template,method)<br/>    min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res)<br/>    threshold=0.95<br/>    loc=np.where(res&gt;threshold)<br/>    if len(loc[0])&gt;0:</strong></span><span id="f3f2" class="lt lu it ny b gy oj od l oe of"># If the method is TM_SQDIFF or TM_SQDIFF_NORMED, take minimum<br/>        <strong class="ny iu">if method in [ cv2.TM_SQDIFF_NORMED]:<br/>            top_left = min_loc<br/>        bottom_right = (top_left[0] + w, top_left[1] + h)</strong></span><span id="cc25" class="lt lu it ny b gy oj od l oe of"><strong class="ny iu">cv2.rectangle(img,top_left, bottom_right,100,20)</strong></span><span id="e900" class="lt lu it ny b gy oj od l oe of"><strong class="ny iu">plt.subplot(121),plt.imshow(res,cmap = 'gray')<br/>        plt.title('Matching Result'), plt.xticks([]), plt.yticks([])<br/>        plt.subplot(122),plt.imshow(img,cmap = 'gray')<br/>        plt.title('Detected Point'), plt.xticks([]), plt.yticks([])<br/>        plt.suptitle(meth)</strong></span><span id="2c77" class="lt lu it ny b gy oj od l oe of"><strong class="ny iu">plt.show()<br/>    else:<br/>        print("Template not matched")</strong></span></pre><figure class="nt nu nv nw gt nh gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/b1dbc36d8cd37bd6c54a37d36b18280b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*Bw6E_kOwOxuTEBjC5J8CNA.png"/></div></figure><h2 id="5679" class="lt lu it bd lv lw lx dn ly lz ma dp mb kr mc md me kv mf mg mh kz mi mj mk ml bi translated">结论:</h2><p id="3f5a" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">我们已经讨论了最常见的图像处理技术，这些技术可用于图像分类、对象检测以及 OCR 的图像分析。</p><h2 id="3cad" class="lt lu it bd lv lw lx dn ly lz ma dp mb kr mc md me kv mf mg mh kz mi mj mk ml bi translated">参考资料:</h2><div class="or os gp gr ot ou"><a href="https://docs.opencv.org/master/d4/dc6/tutorial_py_template_matching.html" rel="noopener  ugc nofollow" target="_blank"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd iu gy z fp oz fr fs pa fu fw is bi translated">OpenCV:模板匹配</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">在本章中，您将学习模板匹配是一种搜索和查找模板位置的方法…</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">docs.opencv.org</p></div></div><div class="pd l"><div class="pe l pf pg ph pd pi nm ou"/></div></div></a></div><div class="or os gp gr ot ou"><a href="https://pillow.readthedocs.io/en/3.1.x/reference/" rel="noopener  ugc nofollow" target="_blank"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd iu gy z fp oz fr fs pa fu fw is bi translated">参考—枕头(PIL 叉)3.1.2 文件</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">编辑描述</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">pillow.readthedocs.io</p></div></div></div></a></div><p id="358b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae ns" href="https://opencv-python-tutroals.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">https://opencv-python-tutroals.readthedocs.io/en/latest/</a></p></div></div>    
</body>
</html>