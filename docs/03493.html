<html>
<head>
<title>End-to-end Quantitative Analysis — Moving from SKLearn to Spark</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">端到端定量分析—从 SKLearn 到 Spark</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/end-to-end-aws-quantitative-analysis-moving-from-sklearn-to-pyspark-f20f883bec90?source=collection_archive---------32-----------------------#2020-04-02">https://towardsdatascience.com/end-to-end-aws-quantitative-analysis-moving-from-sklearn-to-pyspark-f20f883bec90?source=collection_archive---------32-----------------------#2020-04-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/e7015c453587e51c2a90041d8c942284.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*11DoUz1iZt4Fs6R_5SB_NA.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">来自<a class="ae jg" href="https://www.pexels.com/photo/interior-of-office-building-325229/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>的<a class="ae jg" href="https://www.pexels.com/@artunchained?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Manuel Geissinger </a>的照片</p></figure><h2 id="80ae" class="jh ji jj bd b dl jk jl jm jn jo jp dk jq translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/building-an-aws-pipeline" rel="noopener" target="_blank">构建 AWS 管道</a></h2><div class=""/><p id="f898" class="pw-post-body-paragraph kp kq jj kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在之前的一篇文章中，我描述了如何使用 Amazon Web Services (AWS)建立一个自动化的工作流程。我们已经探索了如何使用 AWS 的命令行工具 awscli 来加速弹性 Map Reduce (EMR)集群。<br/>在那篇文章中，我们已经看到了如何使用 sklearn 的<code class="fe ln lo lp lq b">DecisionTreeClassifier</code>将价格运动分类为“上升”或“下降”(1 或 0，二元分类问题)。</p><p id="ed74" class="pw-post-body-paragraph kp kq jj kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">使用 sklearn 的一个缺点是，它使用一台机器来执行所有计算。这种设置会随着数据的增加而增加运行时间，即使我们的 EMR 集群可以包含多台能够进行分布式计算的机器。这就是 Spark 推出其版本的<code class="fe ln lo lp lq b">DecisionTreeClassifier</code>的原因。我们将在本教程中比较 sklearn 和 Spark 的使用。</p><h1 id="e893" class="lr ls jj bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">火花和 PySpark</h1><p id="94e2" class="pw-post-body-paragraph kp kq jj kr b ks mp ku kv kw mq ky kz la mr lc ld le ms lg lh li mt lk ll lm im bi translated">Spark 是一个 Apache 框架，旨在跨多台机器进行并行和分布式处理。这个想法是将工作分解成独立的块，这些块都可以被计算(<strong class="kr jt">划分</strong>数据)，然后汇集独立计算的结果。Spark 非常强大，但是，对于 Python 程序员来说，可悲的是，它是用 Java 编写的。这就是 PySpark 发挥作用的地方。它是围绕 Spark 框架的 python 包装器。</p><p id="464a" class="pw-post-body-paragraph kp kq jj kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">Spark 结合了来自 pandas 的几个抽象，比如 dataframes，以及来自 sklearn 的几个抽象，比如转换和机器学习技术。</p><h1 id="d70a" class="lr ls jj bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">将我们的数据转换成火花数据帧</h1><p id="f2b8" class="pw-post-body-paragraph kp kq jj kr b ks mp ku kv kw mq ky kz la mr lc ld le ms lg lh li mt lk ll lm im bi translated">我们要做的第一件事是将我们的熊猫数据帧转换成 spark 数据帧。这是一个非常常见的操作，因此 PySpark 有一个内置函数来完成这个操作。</p><figure class="mu mv mw mx gt iv"><div class="bz fp l di"><div class="my mz l"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">将我们的库存熊猫数据框架转换为 spark 数据框架</p></figure><p id="6a0f" class="pw-post-body-paragraph kp kq jj kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">注意，我们使用了 Spark 的内置类型来指定转换的模式。这一步是<strong class="kr jt">强烈推荐</strong>并节省大量加工时间。如果不这样做，Spark 会尝试自己推断模式。<br/>还要注意，我们在模式中将<code class="fe ln lo lp lq b">nullable</code>属性设置为<code class="fe ln lo lp lq b">False</code>。这也节省了处理时间，因为 Spark 在进行转换时不必担心某些列包含空值。<br/>完成后，您会注意到我们可以打印 spark 数据帧的模式来查看其结构:</p><pre class="mu mv mw mx gt na lq nb nc aw nd bi"><span id="e13c" class="ne ls jj lq b gy nf ng l nh ni">root<br/> | — Open_pct: double (nullable = false)<br/> | — Close_pct: double (nullable = false)<br/> | — High_pct: double (nullable = false)<br/> | — Low_pct: double (nullable = false)<br/> | — Volume_pct: double (nullable = false)<br/> | — Target: double (nullable = false)</span></pre><h1 id="9a37" class="lr ls jj bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">将特征转换成矢量</h1><p id="28b2" class="pw-post-body-paragraph kp kq jj kr b ks mp ku kv kw mq ky kz la mr lc ld le ms lg lh li mt lk ll lm im bi translated">Scikit-learn 模型用于表格数据；numpy 数组或 pandas 数据帧。然而，Spark 机器学习模型需要稍微不同的架构。</p><p id="7fdf" class="pw-post-body-paragraph kp kq jj kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">虽然 pandas 和 numpy 利用单台机器上的高效内存使用，但 Spark 更关心如何轻松地将数据分布到不同的机器上。因此，它需要将每个数据点封装在一个<code class="fe ln lo lp lq b">vector</code>类中。我们需要使用一个<code class="fe ln lo lp lq b">VectorAssembler</code>将我们的特性列转换成一个包含向量的列。我们必须告诉<code class="fe ln lo lp lq b">VectorAssembler</code>哪些列要插入到这个新列中。</p><figure class="mu mv mw mx gt iv"><div class="bz fp l di"><div class="my mz l"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">使用向量汇编程序创建向量列</p></figure><pre class="mu mv mw mx gt na lq nb nc aw nd bi"><span id="8699" class="ne ls jj lq b gy nf ng l nh ni">root<br/> |-- Open_pct: double (nullable = false)<br/> |-- Close_pct: double (nullable = false)<br/> |-- High_pct: double (nullable = false)<br/> |-- Low_pct: double (nullable = false)<br/> |-- Volume_pct: double (nullable = false)<br/> |-- Target: double (nullable = false)<br/> |-- features: vector (nullable = true)</span></pre><p id="35f8" class="pw-post-body-paragraph kp kq jj kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在，当我们检查模式时，我们看到我们添加了一个存储数据的 vector 类型的单列。在这种方法下，每个数据点都是一个封装的项目，可以在我们的集群中发送。</p><h1 id="6224" class="lr ls jj bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">使用决策树分类器</h1><p id="4cd4" class="pw-post-body-paragraph kp kq jj kr b ks mp ku kv kw mq ky kz la mr lc ld le ms lg lh li mt lk ll lm im bi translated">Spark 有两个主要的机器学习库；<a class="ae jg" href="https://spark.apache.org/docs/latest/api/python/pyspark.mllib.html" rel="noopener ugc nofollow" target="_blank"> MLlib </a>和<a class="ae jg" href="https://spark.apache.org/docs/latest/api/python/pyspark.ml.html" rel="noopener ugc nofollow" target="_blank"> ML </a>。首选的库是 ML，因为 MLlib 正在慢慢淡出。我们将使用 ML 中的决策树分类器。</p><p id="35c7" class="pw-post-body-paragraph kp kq jj kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这部分和我们使用 sklearn 还蛮像的；我们初始化我们的模型，拟合它，然后要求预测。有两个主要区别:<br/> 1)我们必须在同一个数据框架中指定特性和目标列。决策树希望所有特征都位于一列(vector 类型)中。<br/> 2)与 sklearn 决策树不同，这里没有单独的<code class="fe ln lo lp lq b">predict</code>和<code class="fe ln lo lp lq b">predict_proba</code>方法。一个非常详细的数据帧作为我们的预测返回，其中包含硬类预测、概率预测和许多其他项目。</p><p id="22d7" class="pw-post-body-paragraph kp kq jj kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们将运行以下代码来使用决策树:</p><figure class="mu mv mw mx gt iv"><div class="bz fp l di"><div class="my mz l"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">运行决策树分类器</p></figure><p id="d168" class="pw-post-body-paragraph kp kq jj kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们已经采取了几个步骤，让我们来分解一下:</p><ol class=""><li id="14b4" class="nj nk jj kr b ks kt kw kx la nl le nm li nn lm no np nq nr bi translated">我们将数据分为 80%的训练数据和 20%的测试数据。请注意，与 sklearn 不同的是，这里没有专门的函数，但它是数据帧的一个特性</li><li id="dc66" class="nj nk jj kr b ks ns kw nt la nu le nv li nw lm no np nq nr bi translated">我们将数据帧分成 10 个分区。每个分区都是我们的数据的一个原子块，当它在节点之间传递时不会被进一步分割。每个分区将驻留在单个节点上，这意味着我们已经将数据帧切割成 10 个可以四处发送的数据块。<br/>这一步必须包括在内，因为默认情况下 Spark 只使用 2 个分区，这使得大量数据被发送。</li><li id="6bea" class="nj nk jj kr b ks ns kw nt la nu le nv li nw lm no np nq nr bi translated">我们必须初始化决策树，并明确告诉它应该对哪些列进行操作。我们说我们有一个“features”列(vector 类型)和一个“Target”列(double 类型)。一旦我们的树被初始化，我们可以使用<code class="fe ln lo lp lq b">fit</code>方法使它适合训练数据。</li><li id="4cc1" class="nj nk jj kr b ks ns kw nt la nu le nv li nw lm no np nq nr bi translated">用一种<code class="fe ln lo lp lq b">transform</code>方法(而不是<code class="fe ln lo lp lq b">predict</code>)抓住我们的预测。这些预测来自它们自己的火花数据框架。</li><li id="65dc" class="nj nk jj kr b ks ns kw nt la nu le nv li nw lm no np nq nr bi translated">打印该模型的总运行时间。在我的例子中，打印输出是:<br/> <code class="fe ln lo lp lq b">run-time: 3.55</code></li><li id="544f" class="nj nk jj kr b ks ns kw nt la nu le nv li nw lm no np nq nr bi translated">打印出我们的预测数据框架的模式和预测。请注意，预测数据帧也包含测试数据帧的所有列:</li></ol><pre class="mu mv mw mx gt na lq nb nc aw nd bi"><span id="2e7e" class="ne ls jj lq b gy nf ng l nh ni">root<br/> | — Open_pct: double (nullable = false)<br/> | — Close_pct: double (nullable = false)<br/> | — High_pct: double (nullable = false)<br/> | — Low_pct: double (nullable = false)<br/> | — Volume_pct: double (nullable = false)<br/> | — Target: double (nullable = false)<br/> | — features: vector (nullable = true)<br/> | — rawPrediction: vector (nullable = true)<br/> | — probability: vector (nullable = true)<br/> | — prediction: double (nullable = false)</span><span id="28a3" class="ne ls jj lq b gy nx ng l nh ni"><br/>+--------------+----------+-----------+<br/>| rawPrediction|prediction|probability|<br/>+--------------+----------+-----------+<br/>|[0.0,131301.0]|       1.0|  [0.0,1.0]|<br/>|[0.0,131301.0]|       1.0|  [0.0,1.0]|<br/>|[0.0,131301.0]|       1.0|  [0.0,1.0]|<br/>|[0.0,131301.0]|       1.0|  [0.0,1.0]|<br/>|[0.0,131301.0]|       1.0|  [0.0,1.0]|<br/>|[0.0,131301.0]|       1.0|  [0.0,1.0]|<br/>|[0.0,131301.0]|       1.0|  [0.0,1.0]|<br/>|[0.0,131301.0]|       1.0|  [0.0,1.0]|<br/>|[0.0,131301.0]|       1.0|  [0.0,1.0]|<br/>|[0.0,131301.0]|       1.0|  [0.0,1.0]|<br/>|[0.0,131301.0]|       1.0|  [0.0,1.0]|<br/>|[0.0,131301.0]|       1.0|  [0.0,1.0]|<br/>|[0.0,131301.0]|       1.0|  [0.0,1.0]|<br/>|[0.0,131301.0]|       1.0|  [0.0,1.0]|<br/>|[0.0,131301.0]|       1.0|  [0.0,1.0]|<br/>|[0.0,131301.0]|       1.0|  [0.0,1.0]|<br/>|[0.0,131301.0]|       1.0|  [0.0,1.0]|<br/>|[0.0,131301.0]|       1.0|  [0.0,1.0]|<br/>|[0.0,131301.0]|       1.0|  [0.0,1.0]|<br/>|[0.0,131301.0]|       1.0|  [0.0,1.0]|<br/>+--------------+----------+-----------+<br/>only showing top 20 rows</span></pre><h1 id="ce07" class="lr ls jj bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">AWSCLI 的配置</h1><p id="4c6f" class="pw-post-body-paragraph kp kq jj kr b ks mp ku kv kw mq ky kz la mr lc ld le ms lg lh li mt lk ll lm im bi translated">我们将需要使用一个新的命令，其中包含了更多的信息</p><pre class="mu mv mw mx gt na lq nb nc aw nd bi"><span id="c7b2" class="ne ls jj lq b gy nf ng l nh ni">aws2 emr create-cluster \<br/>--name “Spark cluster with step” \<br/>--release-label emr-5.29.0\<br/>--applications Name=Spark \<br/>--log-uri s3://<strong class="lq jt">logs</strong>/logs/ \<br/>--ec2-attributes KeyName=<strong class="lq jt">my-key-pair</strong>,AvailabilityZone=us-west-2a \<br/>--instance-groups <strong class="lq jt">file://instanceGroupConfig.json</strong> \<br/>--bootstrap-actions Path=s3://<strong class="lq jt">scripts-and-set-up</strong>/bootstrap_file.sh \<br/>--configuration <strong class="lq jt">file://config.json</strong> \<br/>--steps Name=”Command Runner”,Jar=”command-runner.jar”,Args=[“spark-submit”,<br/>”--conf”,”spark.executor.memory=18g”,\<br/>”--conf”,”spark.driver.memory=16g”,\<br/>”--conf”,”spark.rpc.message.maxSize=1500",\<br/>”--deploy-mode=cluster”,”s3://<strong class="lq jt">workflow-scripts/process_data.py</strong>, s3://<strong class="lq jt">data-files</strong>/AAPL.csv”] \<br/>--use-default-roles \<br/>--auto-terminate</span></pre><p id="d2a2" class="pw-post-body-paragraph kp kq jj kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我不会探究每一个新的参数，因为我在之前的<a class="ae jg" rel="noopener" target="_blank" href="/end-to-end-quantitative-trading-automating-ml-using-awscli-83035b4f6d03">帖子</a>中探究了<code class="fe ln lo lp lq b">create-cluster</code>命令。但是，我要指出的是，您必须将 s3 存储桶设置为您自己的存储桶。<br/>说到这里，让我们来看看我们添加的几个新参数:</p><ul class=""><li id="9d2c" class="nj nk jj kr b ks kt kw kx la nl le nm li nn lm ny np nq nr bi translated"><code class="fe ln lo lp lq b">--instance-groups file://instanceGroupConfig.json</code> —我们实际上可以使用一个配置文件来指定部署多少个节点以及部署哪种类型的节点。我的集群使用了 4 个节点；1 个主节点、1 个任务节点和 2 个核心节点</li></ul><figure class="mu mv mw mx gt iv"><div class="bz fp l di"><div class="my mz l"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">instanceGroupConfig.json</p></figure><ul class=""><li id="74aa" class="nj nk jj kr b ks kt kw kx la nl le nm li nn lm ny np nq nr bi translated">这是我们集群的另一个配置文件，但是它概述了我们的资源管理器(YARN)应该如何工作。它基本上允许我们在主节点上消耗大量内存</li></ul><figure class="mu mv mw mx gt iv"><div class="bz fp l di"><div class="my mz l"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">配置. json</p></figure><ul class=""><li id="fbb6" class="nj nk jj kr b ks kt kw kx la nl le nm li nn lm ny np nq nr bi translated">我们这里有相当多的火花配置参数。它们控制整体内存管理。每个执行器应该分配高达 18Gb 的内存来运行，控制所有执行器的驱动程序应该分配 16Gb 的内存来运行，最后 Spark 应该能够在执行器和驱动程序之间一次发送高达 1.5Gb 的数据包。我花了一些时间通过反复试验来调整这些参数。我不会说它们是最优的，但它们允许进行比较。</li></ul><h1 id="1c48" class="lr ls jj bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">比较两个决策树的运行时间</h1><p id="18d2" class="pw-post-body-paragraph kp kq jj kr b ks mp ku kv kw mq ky kz la mr lc ld le ms lg lh li mt lk ll lm im bi translated">为了便于比较，让我们来看看我之前用于 sklearn 树和 Spark 树的代码。</p><figure class="mu mv mw mx gt iv"><div class="bz fp l di"><div class="my mz l"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">使用 sklearn 的决策树分类器</p></figure><p id="a0ec" class="pw-post-body-paragraph kp kq jj kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><code class="fe ln lo lp lq b">&gt;&gt;&gt; run-time: 9.19</code></p><figure class="mu mv mw mx gt iv"><div class="bz fp l di"><div class="my mz l"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">使用 Spark 的 ML 决策树分类器</p></figure><p id="3e3f" class="pw-post-body-paragraph kp kq jj kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><code class="fe ln lo lp lq b">&gt;&gt;&gt; run-time: 3.55</code></p><p id="eb82" class="pw-post-body-paragraph kp kq jj kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">使用 Spark 的决策树最终会使数据处理速度提高一倍以上。这符合我们的预期，因为 Spark 可以削减任务和核心节点之间的工作。然而，这个特殊的例子变得稍微复杂一些。</p><p id="013f" class="pw-post-body-paragraph kp kq jj kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">虽然 Spark 的决策树显示了明显的优越性能，但在这种情况下，使用 Spark 并没有快多少。</p><figure class="mu mv mw mx gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nz"><img src="../Images/040688d0e2d7b18a8213a7f5f399457e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oY4Fi5vNQLXxS354A1xUFQ.png"/></div></div></figure><p id="74c5" class="pw-post-body-paragraph kp kq jj kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">使用 sklearn 决策树的集群总共运行了 14 分钟，而 Spark 集群运行了 13 分钟。运行时间接近是因为将数据帧转换成 Spark 数据帧本身就是一项成本高昂的操作。</p><p id="fd10" class="pw-post-body-paragraph kp kq jj kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">然而，我们在这个实例中探索的数据只有大约 4GB 大小。随着数据大小和集群大小的增加，这种差异肯定会增加。Spark 被设计为运行在万亿字节的数据上，甚至更多。所以这个例子仅仅说明了部署基于 Spark 的机器学习工作流的过程。</p><p id="0e92" class="pw-post-body-paragraph kp kq jj kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">用于 PySpark 处理的整个脚本如下所示:</p><figure class="mu mv mw mx gt iv"><div class="bz fp l di"><div class="my mz l"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">process _ data _ with _ 火花. py</p></figure><h1 id="b634" class="lr ls jj bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">结论</h1><p id="e504" class="pw-post-body-paragraph kp kq jj kr b ks mp ku kv kw mq ky kz la mr lc ld le ms lg lh li mt lk ll lm im bi translated">Spark 可用于加速您的机器学习需求，由于它包含许多与 sklearn 相同的算法，转换非常容易。一旦您熟悉了 Spark 框架，PySpark 接口允许几乎无缝的转换。然而，为了达到熟悉的程度，人们必须超越机器学习算法的通常知识，并深入了解配置和内存管理知识，以允许 Spark 应用程序发挥其全部潜力。</p><p id="76d7" class="pw-post-body-paragraph kp kq jj kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我写这篇文章的时候很开心，我希望你读的时候也开心。关于 Spark，我还有一些东西需要学习，但我希望能让您的学习体验更轻松。</p><h1 id="bdff" class="lr ls jj bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">迄今为止的成本</h1><p id="c335" class="pw-post-body-paragraph kp kq jj kr b ks mp ku kv kw mq ky kz la mr lc ld le ms lg lh li mt lk ll lm im bi translated">在试验 3-4 个节点的集群时，以及花了相当多的时间来实现指定显式模式节省了相当多的处理时间，我不得不花更多的钱来学习如何使用 Spark。我希望这篇教程确实能为阅读它的人节省时间和金钱，但是对我来说总的花费大约是 60 美元。我建议你在使用 Spark 和 EMR 进行原型开发时要小心，因为这很容易增加费用，但是如果不尝试和失败，你就无法学会如何使用这些工具。</p></div></div>    
</body>
</html>