<html>
<head>
<title>DBSCAN — Make density-based clusters by hand</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">DBSCAN —手动创建基于密度的集群</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/dbscan-make-density-based-clusters-by-hand-2689dc335120?source=collection_archive---------11-----------------------#2020-05-04">https://towardsdatascience.com/dbscan-make-density-based-clusters-by-hand-2689dc335120?source=collection_archive---------11-----------------------#2020-05-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c182dff658cbcb3e10e9db54b2b76565.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*czkOPW-1Z6nN99JwoiSVWQ.jpeg"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@ellenqin?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Ellen Qin </a>在<a class="ae kc" href="https://unsplash.com/s/photos/balls?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="8e4c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这篇文章也发表在<a class="ae kc" href="https://www.wildregressor.com/2020/05/dbscan-make-density-based-clusters-by.html" rel="noopener ugc nofollow" target="_blank">这里</a></p><p id="fec7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">DBSCAN代表带噪声的基于密度的空间聚类应用。它是一种无监督的机器学习算法，根据数据点的密度或数据的接近程度来进行聚类。也就是说，密集区域之外的点被排除在外，并被视为噪声或异常值。DBSCAN算法的这一特性使其非常适合异常值检测和生成任意形状的聚类。像<a class="ae kc" href="https://www.wildregressor.com/2020/04/k-means-clustering-one-rule-to-group.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> K-Means聚类</strong> </a>这样的算法缺乏这种特性，并且只产生球形聚类，并且对异常值非常敏感。就敏感性而言，我的意思是通过K-Means得到的球形聚类很容易受到单个异常值的影响，因为它们也包括在内。</p><p id="08f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">关于DBSCAN的教程/文章通常包含大量数据集和核心程序，这使得读者很难理解核心概念，但在本文中，我们将把该算法应用于一个非常小的数据集来解释它。跳过一些计算，直接显示计算表。建议验证所有这样的计算，这样会让概念对你来说更形象。让我们取一个包含13个点的数据集，如下图所示:</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lb"><img src="../Images/cd3e86bc4112f28b0d0fe3ad1d7d8bed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*e1RBm6VUjIuOrDTq.png"/></div></div></figure><p id="b91f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">二维数据便于可视化和理解，否则DBSCAN也可以处理多维数据。数据中可能的聚类在上图中已被标记，以可视化我们想要的聚类。上图中的点(1，5) (4，3) (5，6)位于标记之外，因此应视为异常值。DBSCAN算法实际上应该生成聚类并排除异常值，正如我们在图中所做的那样。我们先来了解一下算法，以及其中涉及的各个步骤。</p><p id="ee00" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">逻辑和步骤:</strong></p><p id="75ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">DBSCAN算法有两个输入参数。每个点周围的半径(<em class="lg"> eps </em>)和在该半径内该点周围的最小数据点数(<em class="lg"> MinPts </em>)。例如，考虑点(1.5，2.5)，如果我们取<em class="lg"> eps </em> = 0.3，那么半径= 0.3的点周围的圆将只包含它内部的另一个点(1.2，2.5)，如下所示:</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lh"><img src="../Images/f41b4f3abcd46187d262da6a93e86c61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*y5HKVMPnEBasSCan.png"/></div></div></figure><p id="be19" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，对于(1.5，2.5)，当<em class="lg"> eps </em> = 0.3时，邻域点的数量仅为1。在DBSCAN中，针对这两个参数检查每个点，并通过以下步骤做出关于聚类的决定:</p><ol class=""><li id="2aa8" class="li lj iq kf b kg kh kk kl ko lk ks ll kw lm la ln lo lp lq bi translated">为<em class="lg"> eps </em>和<em class="lg"> MinPts </em>选择一个值</li><li id="c7ef" class="li lj iq kf b kg lr kk ls ko lt ks lu kw lv la ln lo lp lq bi translated">对于特定的数据点(<strong class="kf ir"> x </strong>)，计算其与其他数据点的距离。</li><li id="dc42" class="li lj iq kf b kg lr kk ls ko lt ks lu kw lv la ln lo lp lq bi translated">找出<strong class="kf ir"> x </strong>的所有落在半径为<em class="lg"> eps </em>的圆内的邻域点，或者仅仅是到<strong class="kf ir"> x </strong>的距离小于等于<em class="lg"> eps的邻域点。</em></li><li id="2226" class="li lj iq kf b kg lr kk ls ko lt ks lu kw lv la ln lo lp lq bi translated">将<strong class="kf ir"> x </strong>视为<strong class="kf ir">访问过的</strong>并且如果<strong class="kf ir"> x </strong>周围的邻域点的数量大于或等于<em class="lg"> MinPts </em>那么将<strong class="kf ir"> x </strong>视为<strong class="kf ir">核心点</strong>，如果它没有被分配给任何聚类，则创建一个新的聚类并将其分配给该聚类。</li><li id="9368" class="li lj iq kf b kg lr kk ls ko lt ks lu kw lv la ln lo lp lq bi translated">如果<strong class="kf ir"> x </strong>周围的邻域点的数量小于MinPts，并且在其邻域中有一个核心点，则将其视为边界点。</li><li id="08f2" class="li lj iq kf b kg lr kk ls ko lt ks lu kw lv la ln lo lp lq bi translated">包括所有的<strong class="kf ir">密度连接点</strong>作为一个单独的集群。(密度连接点的含义将在后面描述)</li><li id="061a" class="li lj iq kf b kg lr kk ls ko lt ks lu kw lv la ln lo lp lq bi translated">对数据集中的每个未访问点重复上述步骤，找出所有核心点、边界点和离群点。</li></ol><p id="db74" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，上述步骤构成了一个递归过程。第一次循环计算后，一个点可能不会被视为任何核心点的边界点，但在下一次循环中可能会被视为边界点。</p><p id="95e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果<strong class="kf ir"> x </strong>周围的邻域点的数量大于或等于MinPts，则<strong class="kf ir"> x </strong>被视为核心点，如果<strong class="kf ir"> x </strong>周围的邻域点小于MinPts但接近核心点，则<strong class="kf ir"> x </strong>被视为边界点。如果<strong class="kf ir"> x </strong>既不是核心点也不是边界点，则<strong class="kf ir"> x </strong>被视为异常值。下图给出了一个想法。我们选择eps = 0.6，MinPts =4，标记为核心点的点在其邻域内有4个其他点(&gt;= min pts)&amp;，标记为边界点的点在核心点的邻域内，但在其邻域内只有一个点(&lt; MinPts)。离群点既不是边界点，也不是核心点。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lh"><img src="../Images/1773ff50546d2e519d5dac5bde7df986.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KRKEZY1zVHJc-Uw1joV8FA.png"/></div></div></figure><p id="541f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">运行中的算法</strong></p><p id="384a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们将DBSCAN算法应用于上述数据集，以找出聚类。我们必须首先选择<em class="lg"> eps </em>和<em class="lg"> MinPts </em>的值。我们选<em class="lg">EPS</em>= 0.6<em class="lg">min pts</em>= 4。让我们考虑数据集(1，2) &amp;中的第一个数据点，计算它与数据集中每隔一个数据点的距离。计算值如下所示:</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/ebfe8a69931cda02b20725cda42ca7fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:560/format:webp/0*TPfS40czsPiyZqXC.png"/></div></figure><p id="edd8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从上表可以明显看出，对于<em class="lg"> eps </em>的假设值，点(1，2)在其邻域中只有两个其他点(1，2.5)，(1.2，2.5)，由于其小于MinPts，我们不能将其声明为核心点。让我们对数据集中的每个点重复上述过程，并找出每个点的邻域。重复时的计算可总结如下:</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/1d3ec572d15d807f902d7213da3266f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/0*7QcFrSyOnmZsd-Ut.png"/></div></figure><p id="3de6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">仔细观察上表，最左边的一列包含了我们数据集中所有的点。在它们的右边是在它们附近的数据点，即距离它们的距离小于或等于<em class="lg"> eps </em>值的点。在数据集中有三个点，(2.8，4.5) (1.2，2.5) (1，2.5)，它们周围有4个邻域点，因此它们被称为核心点，并且如已经提到的，如果核心点没有被分配给任何聚类，则形成新的聚类。因此，(2.8，4.5)被分配给新的聚类，聚类1，点(1.2，2.5)，聚类2也是如此。还观察到核心点(1.2，2.5)和(1，2.5)共享至少一个公共邻域点(1，2)，因此，它们被分配到相同的集群。下表显示了所有数据点的分类，分为核心点、边界点和异常点。看一看:</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ly"><img src="../Images/c1e3845267361814d95c89a8551f3ff7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*oYleoU9KoClPFlGw.png"/></div></div></figure><p id="c144" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">DBSCAN算法在数据集中检测到三种类型的点:核心点、边界点和异常点。每个核心点将被分配到一个新的聚类中，除非一些核心点共享邻域点，否则它们将被包括在同一个聚类中。每个边界点将基于其邻域中的核心点被分配给聚类，例如，第一点(1，2)是边界点，并且在其邻域中具有核心点(1.2，2.5)，其被包括在聚类2中，因此，点(1，2)也将被包括在聚类2中。整个分类可以总结如下:</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/eac5b9c4c83b1af30d599c29946bdc18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/0*lrkM2zUvMXfakMfj.png"/></div></figure><p id="1924" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了理解DBSCAN，需要理解三个术语:</p><p id="985d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">1.<strong class="kf ir">直接密度可达</strong>:如果一个点在其邻域内有一个核心点，则称该点为直接密度可达。考虑点(1，2)，它在其邻域中有一个核心点(1.2，2.5)，因此，它将是一个直接密度可达点。</p><p id="5d06" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2.<strong class="kf ir">密度可达</strong>:如果一个点和另一个点通过一系列核心点连接，则称这两个点为密度可达。例如，考虑点(1，3)和(1.5，2.5)，因为它们通过一个核心点(1.2，2.5)连接，所以它们被称为彼此可达的密度。</p><p id="d851" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">3.<strong class="kf ir">密度连通</strong>:如果有一个核心点是从这两点密度可达的，那么这两点称为密度连通。</p><p id="c513" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">到目前为止，DBSCAN的算法必须是清晰的。它很漂亮，因为它排除了离群点，并使聚类具有任意形状，而不像<a class="ae kc" href="https://www.wildregressor.com/2020/04/k-means-clustering-one-rule-to-group.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> k-means聚类</strong> </a>。</p><p id="2e53" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">关于这篇文章的任何建议，你可以在下面发表你的评论或者通过<a class="ae kc" href="https://www.linkedin.com/in/tanvirhurra/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> LinkedIn </strong> </a>联系我。</p><p id="1fa1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">谢谢，</p><p id="586a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">祝你玩得愉快😊</p></div></div>    
</body>
</html>