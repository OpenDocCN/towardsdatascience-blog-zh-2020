<html>
<head>
<title>Conda (+ pip) and Docker FTW!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">康达(+ pip)和Docker FTW！</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/conda-pip-and-docker-ftw-d64fe638dc45?source=collection_archive---------2-----------------------#2020-04-28">https://towardsdatascience.com/conda-pip-and-docker-ftw-d64fe638dc45?source=collection_archive---------2-----------------------#2020-04-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3c48" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">困扰数据科学项目的环境和包管理问题的解决方案。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9dd913c2b7d1695b7764da906332e1e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hjDLgpAbSlxTEVGpyXTMLg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">结合Conda envs和Docker容器可以提高数据科学工作流的可重复性。<a class="ae ky" href="https://www.anaconda.com/" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><h1 id="7e4b" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">进入鲸鱼！</h1><p id="903f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">因为这篇文章的重点是将Docker整合到现有的Conda (+ pip)工作流中，所以我假设您已经在使用Conda (+ pip)来管理数据科学项目的环境。如果您不熟悉Conda的基础知识，或者还没有使用Conda管理特定项目的环境，那么我建议您查看我最近的文章<a class="ae ky" href="https://medium.com/@davidrpugh/managing-project-specific-environments-with-conda-b8b50aa8be0e" rel="noopener"><em class="mn">Conda</em></a>入门和<a class="ae ky" rel="noopener" target="_blank" href="/managing-project-specific-environments-with-conda-406365a539ab"> <em class="mn">使用Conda </em> </a> <em class="mn">管理特定项目的环境。</em></p><p id="7a6c" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">我还假设您对Docker背后的基本思想有所了解。如果没有，那么我推荐你看一看杰夫·黑尔的这个优秀的系列文章</p><h1 id="54cf" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">为什么不用康达(+ pip)？</h1><p id="9b8a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">虽然Conda (+ pip)解决了我的大多数日常数据科学环境和包管理问题，但将<a class="ae ky" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker </a>整合到我的Conda (+ pip)开发工作流中，使我的数据科学工作流从我的笔记本电脑/工作站移植到远程云计算资源变得更加容易。将Docker整合到我的开发工作流程中，通过消除不明显的操作系统级依赖性(特别是当从运行Mac OSX和Windows的本地笔记本电脑/工作站迁移到运行Linux的远程服务器时)，也使我的工作更具可重复性。</p><p id="712a" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">然而，让Conda (+ pip)像预期的那样在Docker容器中工作比我预想的要困难得多。我遇到的大多数困难涉及到如何在图像内部正确激活环境，以便在容器内部使用Conda (+ pip)时的UX与在容器外部使用Conda (+ pip)时的UX相同。</p><p id="3672" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">所有这些困难都可以通过使docker文件“恰到好处”来解决。在下一节中，我将一步一步地向您介绍我开发的Dockerfile文件。</p><h1 id="1af7" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">写作<code class="fe mv mw mx my b">Dockerfile</code></h1><p id="354d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">让Conda (+ pip)和Docker顺利合作的诀窍是编写一个好的<code class="fe mv mw mx my b">Dockerfile</code>。在这一节中，我将带你一步一步地了解我开发的<code class="fe mv mw mx my b">Dockerfile</code>的各个部分。希望你可以在下一个数据科学项目中不加修改地使用这个<code class="fe mv mw mx my b">Dockerfile</code>。</p><p id="3a54" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">从这里开始，我假设您已经组织了类似于我的<a class="ae ky" href="https://github.com/kaust-vislab/python-data-science-project" rel="noopener ugc nofollow" target="_blank"> Python数据科学项目模板</a>的项目目录。特别是，我将假设您存储了所有与Docker相关的文件，特别是项目根目录下的<code class="fe mv mw mx my b">docker</code>子目录中的<code class="fe mv mw mx my b">Dockerfile</code>。</p><h2 id="05e2" class="mz la it bd lb na nb dn lf nc nd dp lj ma ne nf ll me ng nh ln mi ni nj lp nk bi translated">使用标准基础图像</h2><p id="4223" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">每个<code class="fe mv mw mx my b">Dockefile</code>都有一个基础或父映像。对于父映像，我使用的是<a class="ae ky" href="http://releases.ubuntu.com/16.04/" rel="noopener ugc nofollow" target="_blank"> Ubuntu 16.04 </a>，这是数据科学社区中最常用的Linux版本之一(恰好也是我的工作站上安装的同一操作系统)。</p><pre class="kj kk kl km gt nl my nm nn aw no bi"><span id="85cc" class="mz la it my b gy np nq l nr ns">FROM ubuntu:16.04</span></pre><h2 id="7f69" class="mz la it bd lb na nb dn lf nc nd dp lj ma ne nf ll me ng nh ln mi ni nj lp nk bi translated">将<code class="fe mv mw mx my b">bash</code>设为默认外壳</h2><p id="53bf" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">构建Docker映像时用于运行<code class="fe mv mw mx my b">Dockerfile</code>命令的默认shell是<code class="fe mv mw mx my b">/bin/sh</code>。不幸的是<code class="fe mv mw mx my b">/bin/sh</code>目前不是<code class="fe mv mw mx my b">conda init</code>命令支持的shells之一。幸运的是，可以使用<code class="fe mv mw mx my b"><a class="ae ky" href="https://docs.docker.com/engine/reference/builder/#shell" rel="noopener ugc nofollow" target="_blank">SHELL</a></code>指令改变用于运行<code class="fe mv mw mx my b">Dockerfile</code>命令的默认shell。</p><pre class="kj kk kl km gt nl my nm nn aw no bi"><span id="79c3" class="mz la it my b gy np nq l nr ns">SHELL [ "/bin/bash", "--login", "-c" ]</span></pre><p id="aebd" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">注意<code class="fe mv mw mx my b">--login</code>标志的使用，它确保<code class="fe mv mw mx my b">~/.profile</code>和<code class="fe mv mw mx my b">~/.bashrc</code>都有正确的来源。为了使用各种<code class="fe mv mw mx my b">conda</code>命令在Docker映像中构建Conda环境，正确地提供<code class="fe mv mw mx my b">~/.profile</code>和<code class="fe mv mw mx my b">~/.bashrc</code>是必要的。</p><h2 id="a15d" class="mz la it bd lb na nb dn lf nc nd dp lj ma ne nf ll me ng nh ln mi ni nj lp nk bi translated">创建非超级用户</h2><p id="0497" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在您的Docker映像中创建一个非root用户是一个<a class="ae ky" href="https://snyk.io/blog/10-docker-image-security-best-practices/" rel="noopener ugc nofollow" target="_blank"> Docker安全“最佳实践”</a>。我创建非根用户的首选方法是使用构建参数来定制非根用户的<code class="fe mv mw mx my b">username</code>、<code class="fe mv mw mx my b">uid</code>和<code class="fe mv mw mx my b">gid</code>。我对<code class="fe mv mw mx my b">uid</code>和<code class="fe mv mw mx my b">gid</code>使用标准默认值；默认用户名设置为<code class="fe mv mw mx my b"><a class="ae ky" href="https://en.wikipedia.org/wiki/Muhammad_ibn_Musa_al-Khwarizmi" rel="noopener ugc nofollow" target="_blank">al-khawarizmi</a></code>(为了纪念这位著名的波斯学者，他的名字就在我工作的大楼上)</p><pre class="kj kk kl km gt nl my nm nn aw no bi"><span id="f4be" class="mz la it my b gy np nq l nr ns"># Create a non-root user<br/>ARG username=al-khawarizmi<br/>ARG uid=1000<br/>ARG gid=100<br/>ENV USER $username<br/>ENV UID $uid<br/>ENV GID $gid<br/>ENV HOME /home/$USER</span><span id="e049" class="mz la it my b gy nt nq l nr ns">RUN adduser --disabled-password \<br/>    --gecos "Non-root user" \<br/>    --uid $UID \<br/>    --gid $GID \<br/>    --home $HOME \<br/>    $USER</span></pre><h2 id="9fdf" class="mz la it bd lb na nb dn lf nc nd dp lj ma ne nf ll me ng nh ln mi ni nj lp nk bi translated">复制配置文件</h2><p id="21db" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">创建非root用户后，我复制了创建Conda环境所需的所有配置文件(即<code class="fe mv mw mx my b">environment.yml</code>、<code class="fe mv mw mx my b">requirements.txt</code>、<code class="fe mv mw mx my b">postBuild</code>)。我还复制了一个Bash脚本，我将把它用作Docker <code class="fe mv mw mx my b">ENTRYPOINT</code>(下面将详细介绍)。</p><pre class="kj kk kl km gt nl my nm nn aw no bi"><span id="ff5e" class="mz la it my b gy np nq l nr ns">COPY environment.yml requirements.txt /tmp/<br/>RUN chown $UID:$GID /tmp/environment.yml /tmp/requirements.txt</span><span id="2383" class="mz la it my b gy nt nq l nr ns">COPY postBuild /usr/local/bin/postBuild.sh<br/>RUN chown $UID:$GID /usr/local/bin/postBuild.sh &amp;&amp; \<br/>    chmod u+x /usr/local/bin/postBuild.sh</span><span id="7781" class="mz la it my b gy nt nq l nr ns">COPY docker/entrypoint.sh /usr/local/bin/<br/>RUN chown $UID:$GID /usr/local/bin/entrypoint.sh &amp;&amp; \<br/>    chmod u+x /usr/local/bin/entrypoint.sh</span></pre><p id="2571" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">Docker的新版本支持以非根用户的身份复制文件，但是DockerHub上的Docker版本还不支持以非根用户的身份复制文件，所以如果你想为你的Git存储库设置<a class="ae ky" href="https://docs.docker.com/docker-hub/builds/" rel="noopener ugc nofollow" target="_blank">自动构建</a>，你需要以根用户的身份复制所有文件。</p><h2 id="e354" class="mz la it bd lb na nb dn lf nc nd dp lj ma ne nf ll me ng nh ln mi ni nj lp nk bi translated">以非根用户的身份安装Miniconda。</h2><p id="555d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">作为root用户复制配置文件后，我切换到非root用户并安装<a class="ae ky" href="https://docs.conda.io/en/latest/miniconda.html" rel="noopener ugc nofollow" target="_blank"> Miniconda </a>。</p><pre class="kj kk kl km gt nl my nm nn aw no bi"><span id="fe11" class="mz la it my b gy np nq l nr ns">USER $USER</span><span id="dbf8" class="mz la it my b gy nt nq l nr ns"># install miniconda<br/>ENV MINICONDA_VERSION 4.8.2<br/>ENV CONDA_DIR $HOME/miniconda3<br/>RUN wget --quiet https://repo.anaconda.com/miniconda/Miniconda3-$MINICONDA_VERSION-Linux-x86_64.sh -O ~/miniconda.sh &amp;&amp; \<br/>    chmod +x ~/miniconda.sh &amp;&amp; \<br/>    ~/miniconda.sh -b -p $CONDA_DIR &amp;&amp; \<br/>    rm ~/miniconda.sh</span><span id="33e5" class="mz la it my b gy nt nq l nr ns"># make non-activate conda commands available<br/>ENV PATH=$CONDA_DIR/bin:$PATH</span><span id="1000" class="mz la it my b gy nt nq l nr ns"># make conda activate command available from /bin/bash --login shells<br/>RUN echo ". $CONDA_DIR/etc/profile.d/conda.sh" &gt;&gt; ~/.profile</span><span id="37d5" class="mz la it my b gy nt nq l nr ns"># make conda activate command available from /bin/bash --interative shells<br/>RUN conda init bash</span></pre><h2 id="7b9a" class="mz la it bd lb na nb dn lf nc nd dp lj ma ne nf ll me ng nh ln mi ni nj lp nk bi translated">创建项目目录</h2><p id="7274" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">接下来，我在非根用户主目录中创建一个项目目录。Conda环境将在项目目录中的<code class="fe mv mw mx my b">env</code>子目录中创建，然后所有其他项目文件和目录可以挂载到这个目录中。</p><pre class="kj kk kl km gt nl my nm nn aw no bi"><span id="344f" class="mz la it my b gy np nq l nr ns"># create a project directory inside user home<br/>ENV PROJECT_DIR $HOME/app<br/>RUN mkdir $PROJECT_DIR<br/>WORKDIR $PROJECT_DIR</span></pre><h2 id="81e4" class="mz la it bd lb na nb dn lf nc nd dp lj ma ne nf ll me ng nh ln mi ni nj lp nk bi translated">构建康达环境</h2><p id="0adf" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在我已经准备好构建Conda环境了。请注意，我可以使用与我在笔记本电脑或工作站上为项目构建Conda环境几乎相同的<code class="fe mv mw mx my b">conda</code>命令序列。</p><pre class="kj kk kl km gt nl my nm nn aw no bi"><span id="2b28" class="mz la it my b gy np nq l nr ns"># build the conda environment<br/>ENV ENV_PREFIX $PWD/env<br/>RUN conda update --name base --channel defaults conda &amp;&amp; \<br/>    conda env create --prefix $ENV_PREFIX --file /tmp/environment.yml --force &amp;&amp; \<br/>    conda clean --all --yes</span><span id="472f" class="mz la it my b gy nt nq l nr ns"># run the postBuild script to install any JupyterLab extensions<br/>RUN conda activate $ENV_PREFIX &amp;&amp; \<br/>    /usr/local/bin/postBuild.sh &amp;&amp; \<br/>    conda deactivate</span></pre><h2 id="77e9" class="mz la it bd lb na nb dn lf nc nd dp lj ma ne nf ll me ng nh ln mi ni nj lp nk bi translated">确保运行时激活Conda环境</h2><p id="b473" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">快完成了！倒数第二步是使用一个<code class="fe mv mw mx my b"><a class="ae ky" href="https://docs.docker.com/engine/reference/builder/#entrypoint" rel="noopener ugc nofollow" target="_blank">ENTRYPOINT</a></code>脚本来确保Conda环境在运行时被正确激活。</p><pre class="kj kk kl km gt nl my nm nn aw no bi"><span id="1b27" class="mz la it my b gy np nq l nr ns">ENTRYPOINT [ "/usr/local/bin/entrypoint.sh" ]</span></pre><p id="f709" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">下面是<code class="fe mv mw mx my b">/usr/local/bin/entrypoint.sh</code>脚本，供参考。</p><pre class="kj kk kl km gt nl my nm nn aw no bi"><span id="b5f5" class="mz la it my b gy np nq l nr ns">#!/bin/bash --login<br/>set -e</span><span id="d43d" class="mz la it my b gy nt nq l nr ns">conda activate $ENV_PREFIX<br/>exec "$@"</span></pre><h2 id="81fe" class="mz la it bd lb na nb dn lf nc nd dp lj ma ne nf ll me ng nh ln mi ni nj lp nk bi translated">为Docker容器指定默认命令</h2><p id="c80f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">最后，我使用<code class="fe mv mw mx my b"><a class="ae ky" href="https://docs.docker.com/engine/reference/builder/#cmd" rel="noopener ugc nofollow" target="_blank">CMD</a></code>指令来指定Docker容器启动时运行的默认命令。因为我在所有的Conda环境中都安装了JupyerLab，所以在执行容器时，我倾向于默认启动一个JupyterLab服务器。</p><pre class="kj kk kl km gt nl my nm nn aw no bi"><span id="650e" class="mz la it my b gy np nq l nr ns"># default command will launch JupyterLab server for development<br/>CMD [ "jupyter", "lab", "--no-browser", "--ip", "0.0.0.0" ]</span></pre><h1 id="f681" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">建立码头工人形象</h1><p id="67d5" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">下面的命令(应该从包含<code class="fe mv mw mx my b">Dockefile</code>的<code class="fe mv mw mx my b">docker</code>子目录中运行)用定制的<code class="fe mv mw mx my b">$USER</code>(以及相关的<code class="fe mv mw mx my b">$UID</code>和<code class="fe mv mw mx my b">$GID</code>)以及特定的<code class="fe mv mw mx my b">$IMAGE_NAME</code>和<code class="fe mv mw mx my b">$IMAGE_TAG</code>为您的项目构建一个新的映像。这个命令应该在项目的<code class="fe mv mw mx my b">docker</code>子目录中运行，因为Docker构建上下文被设置为<code class="fe mv mw mx my b">../</code>，它应该是项目根目录。</p><pre class="kj kk kl km gt nl my nm nn aw no bi"><span id="4d92" class="mz la it my b gy np nq l nr ns">docker image build \<br/>  --build-arg username=$USER \<br/>  --build-arg uid=$UID \<br/>  --build-arg gid=$GID \<br/>  --file Dockerfile \<br/>  --tag $IMAGE_NAME:$IMAGE_TAG \<br/>  ../</span></pre><h1 id="c09a" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">运行Docker容器</h1><p id="94e7" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">一旦构建了映像，下面的命令将运行基于映像的容器<code class="fe mv mw mx my b">$IMAGE_NAME:$IMAGE_TAG</code>。该命令应该从项目的根目录中运行。</p><pre class="kj kk kl km gt nl my nm nn aw no bi"><span id="9231" class="mz la it my b gy np nq l nr ns">docker container run \<br/>  --rm \<br/>  --tty \<br/>  --volume ${pwd}/bin:/home/$USER/app/bin \<br/>  --volume ${pwd}/data:/home/$USER/app/data \ <br/>  --volume ${pwd}/doc:/home/$USER/app/doc \<br/>  --volume ${pwd}/notebooks:/home/$USER/app/notebooks \<br/>  --volume ${pwd}/results:/home/$USER/app/results \<br/>  --volume ${pwd}/src:/home/$USER/app/src \<br/>  --publish 8888:8888 \<br/>  $IMAGE_NAME:$IMAGE_TAG</span></pre><h1 id="2058" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">使用Docker撰写</h1><p id="5add" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">手写上述docker命令时很容易出现打字错误。一种不太容易出错的方法是使用<a class="ae ky" href="https://docs.docker.com/compose/" rel="noopener ugc nofollow" target="_blank"> Docker Compose </a>。上述docker命令可以封装到<code class="fe mv mw mx my b">docker-compose.yml</code>配置文件中，如下所示。</p><pre class="kj kk kl km gt nl my nm nn aw no bi"><span id="48f5" class="mz la it my b gy np nq l nr ns">version: "3.7"</span><span id="1cd2" class="mz la it my b gy nt nq l nr ns">services:<br/>  jupyterlab-server:<br/>    build:<br/>      args:<br/>        - username=${USER}<br/>        - uid=${UID}<br/>        - gid=${GID}<br/>      context: ../<br/>      dockerfile: docker/Dockerfile<br/>    ports:<br/>      - "8888:8888"<br/>    volumes:<br/>      - ../bin:/home/${USER}/app/bin<br/>      - ../data:/home/${USER}/app/data<br/>      - ../doc:/home/${USER}/app/doc<br/>      - ../notebooks:/home/${USER}/app/notebooks<br/>      - ../results:/home/${USER}/app/results<br/>      - ../src:/home/${USER}/app/src<br/>    init: true<br/>    stdin_open: true<br/>    tty: true</span></pre><p id="8da3" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">以上<code class="fe mv mw mx my b">docker-compose.yml</code>文件依靠<a class="ae ky" href="https://docs.docker.com/compose/environment-variables/#the-env-file" rel="noopener ugc nofollow" target="_blank">变量替换</a>。获取<code class="fe mv mw mx my b">$USER</code>、<code class="fe mv mw mx my b">$UID</code>和<code class="fe mv mw mx my b">$GID</code>的值。这些值可以存储在一个名为<code class="fe mv mw mx my b">.env</code>的文件中，如下所示。</p><pre class="kj kk kl km gt nl my nm nn aw no bi"><span id="ff7a" class="mz la it my b gy np nq l nr ns">USER=$USER<br/>UID=$UID<br/>GID=$GID</span></pre><p id="0d8c" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">您可以通过在项目的<code class="fe mv mw mx my b">docker</code>子目录中运行以下命令来测试您的<code class="fe mv mw mx my b">docker-compose.yml</code>文件。</p><pre class="kj kk kl km gt nl my nm nn aw no bi"><span id="d611" class="mz la it my b gy np nq l nr ns">docker-compose config</span></pre><p id="14a4" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">该命令获取<code class="fe mv mw mx my b">docker-compose.yml</code>文件并替换<code class="fe mv mw mx my b">.env</code>文件中提供的值，然后返回结果。</p><p id="3b2d" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">一旦您确信<code class="fe mv mw mx my b">.env</code>文件中的值被正确地替换到了<code class="fe mv mw mx my b">docker-compose.yml</code>文件中，就可以使用下面的命令来打开一个基于项目Docker映像的容器，并启动JupyterLab服务器。这个命令也应该从项目的<code class="fe mv mw mx my b">docker</code>子目录中运行。</p><pre class="kj kk kl km gt nl my nm nn aw no bi"><span id="d2e6" class="mz la it my b gy np nq l nr ns">docker-compose up --build</span></pre><p id="6cb2" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">当您完成开发并关闭JupyterLab服务器后，下面的命令将拆除正在运行的容器的网络基础设施。</p><pre class="kj kk kl km gt nl my nm nn aw no bi"><span id="1d22" class="mz la it my b gy np nq l nr ns">docker-compose down</span></pre><h1 id="442e" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">摘要</h1><p id="ac79" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在这篇文章中，我经历了一个将Conda (+ pip)环境注入Docker映像的<code class="fe mv mw mx my b">Dockerfile</code>。我还详细介绍了如何使用Docker Compose构建结果图像和启动容器。</p><p id="8a37" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">如果你正在寻找一个生产质量的解决方案，概括上述方法，那么我会鼓励你看看<code class="fe mv mw mx my b"><a class="ae ky" href="https://repo2docker.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">jupyter-repo2docker</a></code>。</p><p id="9be9" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated"><code class="fe mv mw mx my b">jupyter-repo2docker</code>是一个从源代码库中构建、运行和推送Docker映像的工具。<code class="fe mv mw mx my b">repo2docker</code>获取一个存储库(从GitHub、GitLab、Zenodo、Figshare、Dataverse installations、Git存储库或本地目录)并构建一个可以执行代码的容器映像。映像构建过程基于存储库中的配置文件。</p><p id="372a" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">Conda (+ pip)和Docker的结合显著提高了我的数据科学开发速度，同时提高了我的数据科学工作流的可移植性和可重复性。</p><p id="7d71" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">希望这篇文章可以帮助你在下一个数据科学项目中将这三个伟大的工具结合起来！</p></div></div>    
</body>
</html>