<html>
<head>
<title>Simplify Calculus for Machine Learning with SymPy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 SymPy 简化机器学习微积分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/simplify-calculus-for-machine-learning-with-sympy-8a84e57b30bb?source=collection_archive---------27-----------------------#2020-09-06">https://towardsdatascience.com/simplify-calculus-for-machine-learning-with-sympy-8a84e57b30bb?source=collection_archive---------27-----------------------#2020-09-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/8c4b1cbe7e1f472a4ead64310c3d1f5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uRYLv7uBLfIPLUgurNGYZg.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">凯文·Ku 在<a class="ae jg" href="https://unsplash.com/s/photos/machine-learning?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><div class=""/><div class=""><h2 id="666d" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">快速浏览用于机器学习的微积分，以及如何使用 SymPy 将它添加到您的代码中</h2></div><p id="e4b0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">机器学习需要一些微积分。许多在线机器学习课程并不总是涵盖微积分的基础，假设用户已经有了基础。如果你和我一样，你可能需要复习一下。让我们来看看一些基本的微积分概念，以及如何使用 SymPy 在代码中编写它们。</p><p id="17e1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">很多时候，我们需要微积分来寻找最优化问题中的导数。这有助于我们决定是增加还是减少重量。我们的最终目标是找到一个极值点，它将是函数中的局部最小值或最大值点。</p><p id="70f9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们通过以下步骤来完成寻找极值点的过程。</p><ol class=""><li id="0140" class="lu lv jj la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">安装和学习 Sympy 的基础知识。</li><li id="0339" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">求线性函数的斜率。</li><li id="bf60" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">发现切线和割线。</li><li id="2e7a" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">用我们的斜率和切线知识来求极限。</li><li id="9aa4" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">理解什么是函数的导数。</li><li id="294e" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">用导数求极值点。</li><li id="5f80" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">决定极值点是局部最小值还是最大值点。</li></ol><h1 id="8257" class="mi mj jj bd mk ml mm mn mo mp mq mr ms kp mt kq mu ks mv kt mw kv mx kw my mz bi translated">SymPy 入门</h1><p id="30b7" class="pw-post-body-paragraph ky kz jj la b lb na kk ld le nb kn lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated"><a class="ae jg" href="https://www.sympy.org/en/index.html" rel="noopener ugc nofollow" target="_blank"> SymPy </a>是一个 Python 库，可以让你使用<em class="nf">符号</em>来计算各种数学方程。它包括计算微积分方程的函数。它还包括许多其他函数，用于一些更高级的数学。</p><p id="2dbf" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">安装 SymPy 很简单，你可以在这里找到完整的安装说明。如果您已经在使用 Anaconda，那么 SymPy 也包括在内。有了 Anacona，您可以通过一个简单的:</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="c79b" class="np mj jj nl b gy nq nr l ns nt">conda update sympy</span></pre><p id="7f65" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您没有使用 Anaconda，pip 是安装新 Python 库的好方法。</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="8ff0" class="np mj jj nl b gy nq nr l ns nt">pip install sympy</span></pre><p id="f620" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">SymPy 依赖于 mpmath 库，所以你也需要安装它。</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="b60d" class="np mj jj nl b gy nq nr l ns nt">conda install mpmath<br/>#or<br/>pip install mpmath</span></pre><p id="ac8f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用 SymPy，我们可以像在数学方程中一样创建变量。我们需要将这些变量设置为符号，这样 SymPy 就知道将它们与常规的 Python 变量区别对待。这很简单，使用<strong class="la jk"> symbols() </strong>函数即可完成。</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="99d8" class="np mj jj nl b gy nq nr l ns nt">import sympy<br/>x2, y = sympy.symbols('x2 y')</span></pre><p id="7192" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们已经安装了 SymPy，让我们后退一步，看看微积分的基础。</p><h1 id="37fa" class="mi mj jj bd mk ml mm mn mo mp mq mr ms kp mt kq mu ks mv kt mw kv mx kw my mz bi translated">线性方程和斜率</h1><p id="c2ca" class="pw-post-body-paragraph ky kz jj la b lb na kk ld le nb kn lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">如上所述，我们需要微积分的一个主要原因是寻找极值点。为了说明这一点，让我们假设你每年都参加年度土豆大炮大赛。每年你都输给可怕的丹尼·麦克道格。今年你雇了一个教练来帮你打败丹尼。要打败丹尼，教练需要你给他三样东西。</p><p id="8a64" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">1.当丹尼的土豆在最高点时。</p><p id="7bab" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">2.土豆到达最高点需要多长时间。</p><p id="90b1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">3.土豆最高点的斜度。</p><p id="4176" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">先说坡度。</p><p id="28c1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果丹尼在土豆永远上升的地方建造了一个魔法炮，找到斜坡会很容易，但不会有最大高度。这种类型的马铃薯飞行路径是一个线性方程，如 y = 3x+2(y 截距形式)。</p><p id="8f84" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以使用 NumPy 和 Matplotlib 来可视化这个线性函数马铃薯飞行。如果您没有安装 NumPy 和 Matplotlib，过程就像上面的 SymPy 安装一样。更多详情见<a class="ae jg" href="https://numpy.org/install/" rel="noopener ugc nofollow" target="_blank">此处</a>和<a class="ae jg" href="https://matplotlib.org/3.3.1/users/installing.html" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="780c" class="np mj jj nl b gy nq nr l ns nt">import matplotlib.pyplot as plt<br/>import numpy as np</span><span id="7e33" class="np mj jj nl b gy nu nr l ns nt">#create 100 values for x ranging from 0 to 6<br/>x = np.linspace(0,6,100)</span><span id="8873" class="np mj jj nl b gy nu nr l ns nt">#our linear function<br/>y = 3*x + 2</span><span id="1baf" class="np mj jj nl b gy nu nr l ns nt">#add some aesthetics to out plot<br/>plt.grid(color='b', linestyle='--', linewidth=.5)<br/>plt.plot(x,y, label="potato flight")<br/>plt.xlim(0, 6)<br/>plt.ylim(0,20)<br/>plt.legend(loc='best')<br/>plt.xlabel("Seconds")<br/>plt.ylabel("Feet(x10)")</span><span id="9c68" class="np mj jj nl b gy nu nr l ns nt">#show the plot we created<br/>plt.show()</span></pre><p id="0c9d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们要检查斜率，因此我们将在两个随机点上添加标记:(1，5)和(4，14)。</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="c538" class="np mj jj nl b gy nq nr l ns nt">plt.plot(1, 5, 'x', color='red')<br/>plt.plot(4, 14, 'x', color='red')</span></pre><figure class="ng nh ni nj gt iv gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/2468ef94aa36bd3d0eaf80d6a3f7251d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*ZZ5tREcxpieL7rf5cSshJg.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">马铃薯以线性函数飞行</p></figure><p id="2a5c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们有一个线性函数时，我们的斜率是常数，我们可以通过观察任意两点，计算 y 的变化除以 x 的变化来计算斜率，让我们来看看我们之前标记的两点。</p><figure class="ng nh ni nj gt iv gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/bf7a302f2271dc7021378941ca70e59c.png" data-original-src="https://miro.medium.com/v2/resize:fit:766/1*TSFCvf7gF-ukBhaZ0HTLfg.gif"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">求斜率的方程</p></figure><p id="a54e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在 y 截距形式(y = mx + b)中，<em class="nf"> m </em>总是斜率。这与我们之前的函数 y = 3x + 2 相符。</p><h1 id="68ae" class="mi mj jj bd mk ml mm mn mo mp mq mr ms kp mt kq mu ks mv kt mw kv mx kw my mz bi translated">土豆一定要下来——非线性函数</h1><p id="4881" class="pw-post-body-paragraph ky kz jj la b lb na kk ld le nb kn lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">线性函数的斜率很容易，但土豆必须下降。我们需要一种方法来计算随每个点变化的斜率。让我们从可视化一个更真实的土豆飞行路径开始。</p><p id="b406" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们的教练很棒，他知道代表土豆飞行的函数是 f(x) = -(x ) +4x。</p><p id="e8e2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们再一次用 Matplotlib 可视化这个土豆的飞行路径。</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="e9e5" class="np mj jj nl b gy nq nr l ns nt">x = np.linspace(0,5,100)<br/>y = -(x**2) + 4*x</span><span id="d95c" class="np mj jj nl b gy nu nr l ns nt">plt.xlim(0, 4.5)<br/>plt.ylim(0,4.5)<br/>plt.xlabel("Seconds")<br/>plt.ylabel("Height in Feet(x10)")<br/>plt.grid(color='b', linestyle='--', linewidth=.5)<br/>plt.plot(x, y, label="potato")<br/>plt.legend(loc='best')</span><span id="0d36" class="np mj jj nl b gy nu nr l ns nt">plt.show()</span></pre><figure class="ng nh ni nj gt iv gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/45311abeaf7eebf37781547022599a57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*ZpJOM4EcjWQAxB6opRcbtg.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">马铃薯的非线性飞行</p></figure><p id="4c47" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从函数的可视化来看，我们看到在大约 2 秒钟内，马铃薯达到了大约 40 英尺的高度。该图很有帮助，但我们仍然需要最大高度的斜率。另外我们需要一些确凿的证据带回给教练。让我们继续用微积分证明这个高度和时间。</p><h1 id="006f" class="mi mj jj bd mk ml mm mn mo mp mq mr ms kp mt kq mu ks mv kt mw kv mx kw my mz bi translated">割线</h1><p id="34c4" class="pw-post-body-paragraph ky kz jj la b lb na kk ld le nb kn lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">曲线的割线是一条至少在两个不同点处与曲线相交的线。当我们有非线性函数时，我们仍然可以找到两点之间的斜率，或一条割线。由于(2，4)看起来像我们的马铃薯路径的顶部，让我们看看我们新的非线性马铃薯路径上的 2 个点:(1，3)和(2，4)。</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="658b" class="np mj jj nl b gy nq nr l ns nt">#adding this code to our above plot<br/>x2 = np.linspace(1,2,100)<br/>y2 = x2 + 2<br/>plt.plot(x2,y2, color='green')</span></pre><figure class="ng nh ni nj gt iv gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/d8f28bd1e024f4f58b55b5cda372d12b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*_lJI9Ma4ZgkMhW6qIkCOFg.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">割线 x + 2</p></figure><p id="a0b0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以看到(1，3)和(2，4)的斜率是 1。让我们更进一步，看看当我们试图只找到点(2，4)的斜率时会发生什么。为了做到这一点，我们需要一条线，能够代表通过一个点。</p><h1 id="5c81" class="mi mj jj bd mk ml mm mn mo mp mq mr ms kp mt kq mu ks mv kt mw kv mx kw my mz bi translated">切线</h1><p id="fdea" class="pw-post-body-paragraph ky kz jj la b lb na kk ld le nb kn lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">让我们看看越接近(2，4)线的斜率会发生什么变化。所以我们再画几条割线。我们将端点保持在(2，4)，但一条线将从(1.5，3，75)开始，另一条线从(1.95，3.9975)开始。这又给了我们两条割线 y3 = .5x + 3 和 y4 = .05x + 3.9。</p><figure class="ng nh ni nj gt iv gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/76c2401ff419b97129118f205e7e396d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*JEGQKWGRp11ACcPSOuzmHg.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">两条割线</p></figure><p id="342b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们最终到达(2，4)作为我们的起点时，一条线形成了，这就是 y = 0x +4。这是(2，4)的切线。通过求解极限并将其代入 y 截距线性方程来计算切线。更多关于极限的内容。函数中的每一点都有一条切线，这就是我们如何计算函数中每一点的斜率。</p><figure class="ng nh ni nj gt iv gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/e60f37b2a404ad70d5e73e82b7d7e808.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*CEWBk3gkFsxB_Z_7ZZoP8A.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">点(2，4)的切线</p></figure><p id="6f36" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">记住，我们的主要目标是找到一个极值点，土豆的最大高度。极值点将出现在切线斜率为零的时候，因为这表示函数改变了方向。例如，让我们看看穿过(1，3)和穿过(3，3)的切线的斜率。</p><figure class="ng nh ni nj gt iv gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/42c0d8dab64ed03b6c3ba8284b02d8b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*Fx66EnYe5LKSc9Xa8iuM5Q.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">3 条切线</p></figure><p id="8b12" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们来看看这三个点的切线斜率发生了什么变化。</p><ul class=""><li id="497f" class="lu lv jj la b lb lc le lf lh lw ll lx lp ly lt nx ma mb mc bi translated">点(1，3)，切线为 y = 2x + 1，斜率为<strong class="la jk"> 2 </strong></li><li id="eb30" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt nx ma mb mc bi translated">点(2，4)，切线为 y = 0x + 4，斜率为<strong class="la jk"> 0 </strong></li><li id="ca59" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt nx ma mb mc bi translated">点(3，3)，切线是 y = -2x + 9，斜率是- <strong class="la jk"> 2 </strong></li></ul><p id="8fb1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">0°之后，斜率改变方向。很好，我们需要找到切线斜率为零的点。这些点将告诉我们最大或最小点，因为切线斜率的方向总是在 0°之后改变。</p><p id="9760" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">太好了！所以我们需要在函数上找到一个斜率为零的点。如果有一种方法可以创建一个函数，给出原始函数中任意一点的斜率就好了。有，这就是导数！在我们进入衍生品之前，让我们先看看<strong class="la jk">极限</strong>。</p><h1 id="c1eb" class="mi mj jj bd mk ml mm mn mo mp mq mr ms kp mt kq mu ks mv kt mw kv mx kw my mz bi translated">限制</h1><p id="7deb" class="pw-post-body-paragraph ky kz jj la b lb na kk ld le nb kn lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">极限允许我们找到函数接近某个 x 值时的斜率。如果我们把极限解成割线，那就简单了。我们代入两个 x 值和两个 y 值，就可以求解斜率方程。这种极限定义了。但是，我们想要找到一个未定义的极限，因为我们想要点到点(2，4)的切线的斜率。</p><p id="a009" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们接近(2，4)时，我们需要斜率。我们不能得到从(2，4)到(2，4)的割线的斜率，因为如果我们把这些数字代入斜率方程，我们得到 0/0。这是行不通的，因为正如一位数学老师曾经说过的:“生活中有两件事你不能做，把果冻钉在墙上，然后除以零”。因为我们不能被零除，我们需要找到未定义的极限。</p><p id="8590" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">极限是通过将我们的函数代入斜率方程并分解出来解决的。我们可以使用之前的斜率公式，用点(2，4)代替 x1/y1 值，然后用 f(x)和 x 代替 x2/y2 值。我们的极限值是我们正在逼近的 x 值，在这个例子中是 2。函数-(x ) +4x 的极限 2 的新斜率方程为:</p><figure class="ng nh ni nj gt iv gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/d6515f56a5cc462e8ca5f7a8d6c43276.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/1*C9oWKH-cpJSKO30ZhFNlwQ.gif"/></div></figure><p id="713b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们的目标是去掉分母上的 x，所以让我们展开-(x)并抵消分母上的 x。</p><figure class="ng nh ni nj gt iv gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/b4ab32828270edf722959d15029504ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/1*iZpO6s0z2AIpm4wVUfzrWA.gif"/></div></figure><p id="504d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们已经把 x 从分母中去掉了，我们可以把 plug 2 放回 x 中。</p><figure class="ng nh ni nj gt iv gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/20d12d1641be0707f72dcef3ff73476b.png" data-original-src="https://miro.medium.com/v2/resize:fit:642/1*kFLOPkFhNVABUi6ChcKQZw.gif"/></div></figure><p id="ac85" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们知道了极限是如何求解的，让我们启动 SymPy，这样我们就可以在代码中求解极限了。</p><p id="0ac2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">SymPy 有一个名为<strong class="la jk"> limit() </strong>的函数，它有 3 个参数。</p><ul class=""><li id="6925" class="lu lv jj la b lb lc le lf lh lw ll lx lp ly lt nx ma mb mc bi translated">我们正在寻找极限的函数</li><li id="bc9a" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt nx ma mb mc bi translated">输入变量</li><li id="70e7" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt nx ma mb mc bi translated">输入变量接近的数字</li></ul><p id="e7a5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为我们的极限是未定义的，我们需要像上面一样替换 x 和 y 值。</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="e27b" class="np mj jj nl b gy nq nr l ns nt">import sympy<br/>x2, y = sympy.symbols('x2 y')<br/>#store our substituted function as a y variable<br/>y = (-(x2**2) + 4 * x2 -4) / (x2 -2)<br/>limit = sympy.limit(y, x2, 2)<br/>// 0</span></pre><p id="0d75" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们的上限是 0！</p><h1 id="7b1c" class="mi mj jj bd mk ml mm mn mo mp mq mr ms kp mt kq mu ks mv kt mw kv mx kw my mz bi translated"><strong class="ak">衍生品</strong></h1><p id="ee41" class="pw-post-body-paragraph ky kz jj la b lb na kk ld le nb kn lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">导数是一个函数，它将给出函数中任意一点切线的斜率。</p><p id="988c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们明白了极限线和切线是什么，我们可以朝着我们的最终目标前进，用导数来寻找函数中的极值点。求函数导数的过程是<a class="ae jg" href="https://en.wikipedia.org/wiki/Derivative#Differentiation" rel="noopener ugc nofollow" target="_blank"> <strong class="la jk">微分</strong> </a> <strong class="la jk">。</strong></p><p id="674d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">求解导数需要用到一些代数和上面的斜率公式。因为我们不是在求解一个特定的点，所以我们不会替换任何值。对于此示例，我们也用更常见的形式替换 x1 和 x2，即使用 x 和 x +h。这将为我们提供以下公式来求解 f′(x)的导数，f′(x)表示 x 的函数的导数:</p><figure class="ng nh ni nj gt iv gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/602f14f25706757a8ac90df26fc71304.png" data-original-src="https://miro.medium.com/v2/resize:fit:616/1*KTgTEboyV_WrgcsHl75UQA.gif"/></div></figure><p id="467c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们把函数代入这里，我们得到:</p><figure class="ng nh ni nj gt iv gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/ad3662037cd1da9916c1de825ef3b549.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/1*4BrttfYMZJOwdYGx4iV7VQ.gif"/></div></figure><p id="ef49" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后我们可以用解决极限的方法来解决这个问题。我们还可以使用<a class="ae jg" href="https://en.wikipedia.org/wiki/Power_rule" rel="noopener ugc nofollow" target="_blank">幂法则</a>来求解，从而使用以下等式轻松找到我们的导数。</p><figure class="ng nh ni nj gt iv gh gi paragraph-image"><div class="gh gi od"><img src="../Images/e797d77f7ec89e6c772d6a2085f10ec4.png" data-original-src="https://miro.medium.com/v2/resize:fit:334/1*dCVArlFrBnzXgyWVl9nV1w.gif"/></div></figure><p id="4579" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用该规则，我们可以看到函数<strong class="la jk"> -(x ) +4x </strong>的导数是- <strong class="la jk"> 2x +4 </strong>。</p><p id="b8ce" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们用 SymPy 来求导，而不是通过手动的步骤来求导。</p><p id="972a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">SymPy 为我们提供了一个名为<strong class="la jk"> diff() </strong>的函数，它将执行微分过程并返回导数。</p><p id="3799" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">diff 函数有两个参数:</p><ul class=""><li id="62b6" class="lu lv jj la b lb lc le lf lh lw ll lx lp ly lt nx ma mb mc bi translated">我们要求导数的函数</li><li id="f572" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt nx ma mb mc bi translated">输入变量</li></ul><p id="9933" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们用我们原来的函数<strong class="la jk"> -(x ) +4x </strong>来试试这个函数。</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="921e" class="np mj jj nl b gy nq nr l ns nt"># set x as the variable<br/>x = sympy.symbols('x')</span><span id="40e9" class="np mj jj nl b gy nu nr l ns nt">#help make the out easier to read<br/>sympy.init_printing(use_unicode=True)</span><span id="b3d2" class="np mj jj nl b gy nu nr l ns nt">#enter the our argumnets to th diff funtion<br/>d= sympy.diff(-(x**2) + 4*x, x)</span><span id="7a02" class="np mj jj nl b gy nu nr l ns nt">#print our derivative<br/>print(d)<br/>//-2*x + 4</span></pre><p id="e080" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">函数的极值点是导数等于零的地方。这是因为当导数等于 0 时，函数的方向已经改变，正如我们上面所探讨的。</p><p id="22d4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了找到 x 值，我们将导数设为 0，然后求解 x，<strong class="la jk"> -2x + 4 = 0。</strong></p><p id="1eef" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是通过使用函数<strong class="la jk"> solveset() </strong>用 SymPy 解决的。Solvest 有两个参数:</p><ul class=""><li id="4832" class="lu lv jj la b lb lc le lf lh lw ll lx lp ly lt nx ma mb mc bi translated">Eq 函数<em class="nf">，它有两个参数:等式和等式需要等于的值</em></li><li id="3b2a" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt nx ma mb mc bi translated">我们试图解决的变量</li></ul><p id="b546" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Solvset 将返回所有解方程的数的集合。</p><p id="c26b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当导数等于 0 时，使用 solvset 来查找 x 值将如下所示:</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="c674" class="np mj jj nl b gy nq nr l ns nt">answer = sympy.solveset(sympy.Eq(d, 0),x)<br/>print(answer)<br/>//{2}</span></pre><p id="50f5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">完美！我们的 x 值是<strong class="la jk"> 2 </strong>，如果我们把它代入原始函数，我们得到<strong class="la jk"> 4 </strong>作为我们的 y 值。</p><p id="c1ae" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们可以确定，在 2 秒钟时，麦克道戈尔的土豆正好在空中 40 英尺处，并且该点的斜率为 0！我们可以把它带给教练，我们一定会赢得下一场土豆大炮比赛！</p><h1 id="ccf5" class="mi mj jj bd mk ml mm mn mo mp mq mr ms kp mt kq mu ks mv kt mw kv mx kw my mz bi translated">我们的极值点是最小值还是最大值？</h1><p id="fdc7" class="pw-post-body-paragraph ky kz jj la b lb na kk ld le nb kn lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">我们知道我们的土豆的极限点一定是最大点，因为这些土豆大炮不是用来击落土豆的。但是如果我们没有图或者不知道函数的方向，我们怎么知道极值点是局部最小值还是局部最大值？我们已经知道，将导数的 x 值设置为 2 会导致斜率为 0。如果我们在我们的导函数中再插入两个数，一个数会大于 2，另一个会小于 2，会发生什么？我们将使用 1 和 3 来尝试。</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="6fe4" class="np mj jj nl b gy nq nr l ns nt">test1 = -2*1 + 4<br/>test2 = -2*3 + 4<br/>print(test1)<br/>//2<br/>print(test2)<br/>//-2</span></pre><p id="e6c0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们看到，在极值点之前，斜率是正的，而在极值点之后，斜率是负的。斜率从正到负的变化告诉我们极值点是最大值。如果斜率从负变为正，我们就知道极值点是最小值点。如果有多个极值点，我们希望在每个点之间选择一个值。例如，如果我们有极值点 1 和 5，我们将重复这个过程三次:</p><ul class=""><li id="717b" class="lu lv jj la b lb lc le lf lh lw ll lx lp ly lt nx ma mb mc bi translated">选择一个小于 1 的随机数</li><li id="b142" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt nx ma mb mc bi translated">选择一个大于 1 但小于 5 的随机数</li><li id="1995" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt nx ma mb mc bi translated">选择一个大于 5 的随机数</li></ul><p id="a69b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">很可能非线性函数不会只有一个极值点。在这种情况下，所有的步骤都是一样的，但是当我们求解导数等于零时，我们得到了多个解。</p><h1 id="711f" class="mi mj jj bd mk ml mm mn mo mp mq mr ms kp mt kq mu ks mv kt mw kv mx kw my mz bi translated">结论</h1><p id="fa32" class="pw-post-body-paragraph ky kz jj la b lb na kk ld le nb kn lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">SymPy 是一个庞大的库，是一个很好的方法来寻找导数和函数的局部极值点。SymPy 易于使用和阅读，为任何需要微积分的机器学习项目增加了简单性和可读性。我们只涉及了这个<a class="ae jg" href="https://www.sympy.org/en/index.html" rel="noopener ugc nofollow" target="_blank">库</a>的许多可用函数中的一小部分。我鼓励您进一步探索它，看看还有什么可以用来将数学融入到您的数据科学项目中。</p></div></div>    
</body>
</html>