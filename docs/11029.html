<html>
<head>
<title>From graph db to graph embedding</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从图形数据库到图形嵌入</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/from-graph-db-to-graph-embedding-a2f2c38e7c6d?source=collection_archive---------40-----------------------#2020-07-31">https://towardsdatascience.com/from-graph-db-to-graph-embedding-a2f2c38e7c6d?source=collection_archive---------40-----------------------#2020-07-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/c88eca8b0c05ac39d61ac0e05457fe4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ci307DltU_9Mk9E6YbLOoQ.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片由<a class="ae jg" href="https://pixabay.com/users/theandrasbarta-2004841/" rel="noopener ugc nofollow" target="_blank"> TheAndrasBarta </a>，<a class="ae jg" href="https://pixabay.com/service/license/" rel="noopener ugc nofollow" target="_blank">授权</a>。</p></figure><div class=""/><div class=""><h2 id="ea65" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">7 个简单的步骤</h2></div><p id="21ad" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所有的创新技术最终都会越过一个“膨胀预期的顶峰”，当所述技术得到大量营销资金的支持时，这种现象尤其如此，这些资金主要用于助长炒作和加剧公众预期。</p><p id="90fe" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">机器学习的前景正在慢慢成熟，超越了它的“<em class="lu">我是一把锤子，一切都是钉子”的框架，诞生于过去十年左右市场营销热情的爆发。</em></p><p id="481a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于图形数据库也是如此；曾经被誉为每个企业圣诞节必备的热门新技术，它们已经达到了成为系统工程师剧本的一部分的快乐境界。</p><p id="c3bc" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当它们<em class="lu">与</em>一起使用时，它们比传统的 RDBMS 提供了显著的优势，RDBMS 在过去的 40 多年里一直统治着数据库领域。简单地说，它们只是做 SQL 数据库做不到的某些事情(反过来也是如此)。</p><p id="d478" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">考虑到这一点，我们来找点乐子吧。</p><p id="190e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面，我为安装图形数据库、获取数据集、创建图形的矢量嵌入表示以及可视化输出做了一个简单的入门指南。</p><p id="95c2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本教程中，我们将使用 Linux 基金会支持的图形数据库<a class="ae jg" href="https://janusgraph.org/" rel="noopener ugc nofollow" target="_blank"> JanusGraph </a>。JanusGraph 被设计用来处理数十亿个顶点和边，但是为了本教程，我们将保持它的简洁。不过，我会给你一些建议，告诉你如何扩展你的解决方案。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="fabe" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在开始之前，让我们先解决一些潜在的问题。</p><ol class=""><li id="00d6" class="mc md jj la b lb lc le lf lh me ll mf lp mg lt mh mi mj mk bi translated"><em class="lu">为什么不直接用 NetworkX？</em>尽管 NetworkX 功能丰富，但它的可扩展性并不好。虽然下面的步骤显然不符合给定表格中的<em class="lu">，但它们代表了可能的基础。(例如，将 JanusGraph 部署到集群，并使用 Spark 运行以下所有操作)</em></li><li id="e273" class="mc md jj la b lb ml le mm lh mn ll mo lp mp lt mh mi mj mk bi translated"><em class="lu">为什么是 JanusGraph 而不是另一个 db？有许多伟大的图形数据库可供选择。我在下面使用它是因为 JanusGraph 维护得很好，在<a class="ae jg" href="https://en.wikipedia.org/wiki/Apache_License" rel="noopener ugc nofollow" target="_blank"> Apache 2.0 </a>下获得许可，可伸缩，并且使用最接近通用图查询语言的东西:Gremlin。您还可以使用 gremlin-python 实现轻松地将 gremlin 嵌入到我们的 python 代码中。(虽然 Cypher 在 StackOverflow 上通过 Q &amp;更受欢迎，但 Gremlin 得到了更多图形数据库的支持)。</em></li><li id="74b7" class="mc md jj la b lb ml le mm lh mn ll mo lp mp lt mh mi mj mk bi translated"><em class="lu">node 2 vec 的特性比定制的、手工构建的特性更有用吗？嗯，那要看情况。Node2Vec 允许我们轻松地将图形的拓扑表示编码成一系列实数，而不必繁琐地尝试手动创建它们。这节省了时间和精力，并且最终包含了比手工创建的图表更多的信息。</em></li></ol><p id="fa1a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将用来加载的数据将是 Kelvin Lawrence 的机场数据集。在这里可以找到他的数据<a class="ae jg" href="https://github.com/krlawrence/graph/tree/master/sample-data" rel="noopener ugc nofollow" target="_blank">，在这里</a>可以找到他关于 Gremlin(一种流行的图形查询语言)的(优秀)书籍。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="18d6" class="mq mr jj bd ms mt mu dn mv mw mx dp my lh mz na nb ll nc nd ne lp nf ng nh ni bi translated">步骤 1 —下载骏利图表</h2><p id="d4a0" class="pw-post-body-paragraph ky kz jj la b lb nj kk ld le nk kn lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">导航到<a class="ae jg" href="https://github.com/JanusGraph/janusgraph/releases" rel="noopener ugc nofollow" target="_blank"> JanusGraph 发布页面</a>并下载最新版本(在撰写本文时是 0.52-文件名<em class="lu">Janus graph-full-0 . 5 . 2 . zip</em>)</p><figure class="np nq nr ns gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi no"><img src="../Images/193ec16364b29f9ec170e31ba6918e3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_g0qkKm-qjKywFc-8iWDYA.png"/></div></div></figure><h2 id="6a38" class="mq mr jj bd ms mt mu dn mv mw mx dp my lh mz na nb ll nc nd ne lp nf ng nh ni bi translated">步骤 2-启动骏利图像服务器</h2><p id="9669" class="pw-post-body-paragraph ky kz jj la b lb nj kk ld le nk kn lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">下载后，将文件解压缩，并将光盘放入可执行文件和 shell 脚本所在的<code class="fe nt nu nv nw b">bin/</code>目录。</p><p id="7f80" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要启动服务器(基本后端是 Cassandra、ElasticSearch 和 gremlin-server)，使用命令<code class="fe nt nu nv nw b">./janusgraph.sh start</code>。您应该会看到以下输出:</p><figure class="np nq nr ns gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nx"><img src="../Images/5c2f7910f4c46b76854911c4f3e6cb0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QJLPu4DlYH0dFFr-RkS7ew.png"/></div></div></figure><h2 id="bc73" class="mq mr jj bd ms mt mu dn mv mw mx dp my lh mz na nb ll nc nd ne lp nf ng nh ni bi translated">步骤 3-将数据集加载到数据库中</h2><p id="752b" class="pw-post-body-paragraph ky kz jj la b lb nj kk ld le nk kn lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">有多种方法来序列化您的图形数据。下面，我将摄取一个<code class="fe nt nu nv nw b">graphml</code>文件，但你也可以轻松地使用<code class="fe nt nu nv nw b">graphson</code>或<code class="fe nt nu nv nw b">csv</code>。</p><p id="98aa" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">将以下内容保存到扩展名为<code class="fe nt nu nv nw b">.groovy</code>的文件中。</p><figure class="np nq nr ns gt iv"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="f62b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所有对 JanusGraph 的远程访问都是通过 Gremlin 服务器进行的；我们可以通过首先进入 gremlin 控制台来访问/加载我们的数据。通过使用命令——仍然在 bin 目录中— <code class="fe nt nu nv nw b">./gremlin.sh</code>来完成。您应该会看到以下输出:</p><figure class="np nq nr ns gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oa"><img src="../Images/503511e21c6df42f0dfda0d1e19f436c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b6Qx3mQN2wa-QajJms8N6g.png"/></div></div></figure><p id="9366" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">进入 gremlin 控制台后，使用以下命令加载机场数据。根据数据集的大小，所需的时间会有所不同。</p><p id="00fe" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nt nu nv nw b">:load path/to/file/load_airports.groovy</code></p><p id="4bb2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以通过运行计数<code class="fe nt nu nv nw b">g.V().count()</code>来验证它是否正常工作。尽管这对于大量数据来说会很慢——在这种情况下，设置一个顶点索引并从那里开始计数。</p><p id="e21c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">扩展选项:</strong>部署 JanusGraph 到集群，玩玩后端组件，批量加载，增加线程，增加工人等。关于这个主题的精彩文章，请点击<a class="ae jg" href="https://www.experoinc.com/post/janusgraph-nuts-and-bolts-part-1-write-performance" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><h2 id="0fcd" class="mq mr jj bd ms mt mu dn mv mw mx dp my lh mz na nb ll nc nd ne lp nf ng nh ni bi translated">步骤 4-创建随机漫步</h2><p id="f2c9" class="pw-post-body-paragraph ky kz jj la b lb nj kk ld le nk kn lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">word 2 vec——node 2 vec 的下游等价物——需要一组序列作为输入。我们可以使用随机漫步从我们的图中构造序列。简而言之，我们将使用节点，而不是单词，我们使用随机漫步，而不是句子。在这个过程中，我们将节点映射到实数。</p><p id="c8ff" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们创建这些随机漫步。对于每个顶点，我们将创建 50 个深度为 6 的随机行走(根据需要进行调整，这只是一个演示)。下面的代码使用了<code class="fe nt nu nv nw b"><a class="ae jg" href="https://pypi.org/project/gremlinpython/" rel="noopener ugc nofollow" target="_blank">gremlinpython</a></code>实现，它可以无缝集成到我们的 Python 脚本中。</p><p id="9aba" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从 3619 个顶点中，我们提取了 181k 个随机游走。</p><p id="82de" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意，下面的查询实际上是随机漫步的一个不完美的表示，它将被提供给 Node2Vec。Node2Vec 指定了两个额外的超参数来控制顶点之间的转移概率，因此您可以控制您的行走是局部的(广度优先搜索)还是全局的(深度优先搜索)。</p><figure class="np nq nr ns gt iv"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="9a2b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">扩展选项:</strong>通过使用多处理库，您可以轻松地垂直扩展该解决方案。通过使用 PySpark 这样的 Spark 实现来查询 JanusGraph，您可以横向扩展这个解决方案。要提取顶点 id，最好是直接查询弹性索引，而不是尝试 g.V()查询，或者在加载数据时梳理出来。</p><h2 id="d286" class="mq mr jj bd ms mt mu dn mv mw mx dp my lh mz na nb ll nc nd ne lp nf ng nh ni bi translated">步骤 5— Word2Vec/Node2Vec 嵌入</h2><p id="5c19" class="pw-post-body-paragraph ky kz jj la b lb nj kk ld le nk kn lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">神奇的事情就发生在这里。让我们在随机行走的集合上训练一个 Word2Vec 模型，得到一个实数的输出。</p><figure class="np nq nr ns gt iv"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="9421" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出<code class="fe nt nu nv nw b">X</code>是矢量集，形状为 181,000 x 50。如果你要训练一个 ML 模型，这是你可能会用到的数据。</p><p id="39b6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">缩放选项:</strong>使用<a class="ae jg" href="https://spark.apache.org/docs/2.1.1/api/java/org/apache/spark/mllib/feature/Word2Vec.html" rel="noopener ugc nofollow" target="_blank"> Word2Vec </a>的 Spark 实现。</p><h2 id="4efb" class="mq mr jj bd ms mt mu dn mv mw mx dp my lh mz na nb ll nc nd ne lp nf ng nh ni bi translated">步骤 6 —降维</h2><p id="45e3" class="pw-post-body-paragraph ky kz jj la b lb nj kk ld le nk kn lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">想象 50 维几乎是不可能的。我们可以使用降维技术来提取数据集中包含的大量差异，并将其压缩到更少的维度。这个过程是有损耗的，但如果我们能够保留足够的信息，同时能够在低维(~2D)空间中查看数据的全局结构，这是很值得的。</p><p id="ad44" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">虽然这里可以使用 PCA 或 TSNE，但我选择了 UMAP，因为它很好地保留了全局结构，而且速度很快。以下参数将需要调整。</p><figure class="np nq nr ns gt iv"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="8fea" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是一篇关于 UMAP 的好文章。</p><p id="fa7c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">缩放选项</strong>:虽然我找不到 UMAP 的 Spark 实现，但你可以尝试使用 MLlib <a class="ae jg" href="https://spark.apache.org/docs/latest/mllib-dimensionality-reduction" rel="noopener ugc nofollow" target="_blank"> PCA </a>实现。</p><h2 id="20ce" class="mq mr jj bd ms mt mu dn mv mw mx dp my lh mz na nb ll nc nd ne lp nf ng nh ni bi translated">第七步——想象</h2><p id="ce8a" class="pw-post-body-paragraph ky kz jj la b lb nj kk ld le nk kn lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">让我们把 50 维数据简化成两个部分，并把它们可视化。对于悬停数据和颜色数据，屏幕外有一些多余的添加。如果有足够的兴趣，我会张贴整个笔记本供参考。</p><figure class="np nq nr ns gt iv"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="1b84" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是输出——试着将鼠标悬停在上面，摆弄数据。</p><figure class="np nq nr ns gt iv"><div class="bz fp l di"><div class="ob nz l"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">Plotly 图可以直接嵌入介质？非常酷。</p></figure><p id="a96c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢您的阅读，祝您编码愉快！</p></div></div>    
</body>
</html>