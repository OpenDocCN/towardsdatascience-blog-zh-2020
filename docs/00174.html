<html>
<head>
<title>5 Gotchas With Pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">熊猫的 5 个陷阱</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/5-gotchas-with-pandas-974df6595e61?source=collection_archive---------15-----------------------#2020-01-06">https://towardsdatascience.com/5-gotchas-with-pandas-974df6595e61?source=collection_archive---------15-----------------------#2020-01-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0ccb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用熊猫做数据分析是非常简单的……但事实并非如此！在这篇博文中，我提出了一些你需要注意的关于熊猫的问题。</h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/7621e92ed5fb837632c386e2e02a172f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*haUJ7elh9B4MoCqNmhtPgg.png"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">用<a class="ae kz" href="https://imgflip.com/memegenerator" rel="noopener ugc nofollow" target="_blank"> ImgFlip </a>生成的熊猫迷因</p></figure><p id="f10b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><em class="lw">运行示例下载本</em> <a class="ae kz" href="https://romanorac.github.io/assets/notebooks/2019-12-23-few-gotchas-with-pandas.ipynb" rel="noopener ugc nofollow" target="_blank"> <em class="lw"> Jupyter 笔记本</em> </a> <em class="lw">。</em></p><p id="8890" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">这里有几个你可能会感兴趣的链接:</strong></p><pre class="kk kl km kn gt lx ly lz ma aw mb bi"><span id="36b0" class="mc md it ly b gy me mf l mg mh">- <a class="ae kz" href="https://www.humanfirst.ai/" rel="noopener ugc nofollow" target="_blank">Labeling and Data Engineering for Conversational AI and Analytics</a></span><span id="4cac" class="mc md it ly b gy mi mf l mg mh">- <a class="ae kz" href="https://imp.i115008.net/c/2402645/880006/11298" rel="noopener ugc nofollow" target="_blank">Data Science for Business Leaders</a> [Course]</span><span id="dff9" class="mc md it ly b gy mi mf l mg mh">- <a class="ae kz" href="https://imp.i115008.net/c/2402645/788201/11298" rel="noopener ugc nofollow" target="_blank">Intro to Machine Learning with PyTorch</a> [Course]</span><span id="2a1c" class="mc md it ly b gy mi mf l mg mh">- <a class="ae kz" href="https://imp.i115008.net/c/2402645/803127/11298" rel="noopener ugc nofollow" target="_blank">Become a Growth Product Manager</a> [Course]</span><span id="cf8c" class="mc md it ly b gy mi mf l mg mh">- <a class="ae kz" href="https://amzn.to/3ncTG7D" rel="noopener ugc nofollow" target="_blank">Deep Learning (Adaptive Computation and ML series)</a> [Ebook]</span><span id="c588" class="mc md it ly b gy mi mf l mg mh">- <a class="ae kz" href="https://aigents.co/skills" rel="noopener ugc nofollow" target="_blank">Free skill tests for Data Scientists &amp; Machine Learning Engineers</a></span></pre><p id="3897" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><em class="lw">上面的一些链接是附属链接，如果你通过它们购买，我会赚取佣金。请记住，我链接课程是因为它们的质量，而不是因为我从你的购买中获得的佣金。</em></p><p id="3056" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">要升级你的熊猫游戏，请阅读:</p><div class="mj mk gp gr ml mm"><a rel="noopener follow" target="_blank" href="/pandas-analytics-server-d9abceec888b"><div class="mn ab fo"><div class="mo ab mp cl cj mq"><h2 class="bd iu gy z fp mr fr fs ms fu fw is bi translated">熊猫分析服务器</h2><div class="mt l"><h3 class="bd b gy z fp mr fr fs ms fu fw dk translated">一个开源项目，简化了熊猫与实时数据的连接，测试假设和可视化…</h3></div><div class="mu l"><p class="bd b dl z fp mr fr fs ms fu fw dk translated">towardsdatascience.com</p></div></div><div class="mv l"><div class="mw l mx my mz mv na kt mm"/></div></div></a></div><h1 id="7c50" class="nb md it bd nc nd ne nf ng nh ni nj nk jz nl ka nm kc nn kd no kf np kg nq nr bi translated">1.读取多个文件</h1><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi ns"><img src="../Images/a3dd7086e409e768a2a6e8a05ec8264e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q55X1gfHjKi1knx96UVdZQ.png"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">图片来自<a class="ae kz" href="https://me.me/i/dontworry-its-all-gonna-panda-out-dont-worry-its-all-35c9094c786b4a16a4236d032c4fbdc2" rel="noopener ugc nofollow" target="_blank"> Meme </a></p></figure><p id="67e4" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">假设我们想从一个文件夹中读取多个文件到一个熊猫数据帧中。Python 有一个路径库，可以列出某个文件夹中的所有文件，但我发现 glob 更容易使用。glob 支持正则表达式，这给了我们对想要读取的文件的粒度控制。注意，没有必要解压压缩文件，因为熊猫可以在阅读时自动解压。</p><p id="fa3c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">为了指定我们想要读取哪些文件，我们在 glob 中使用了<code class="fe nt nu nv ly b">*.gz</code>。</p><pre class="kk kl km kn gt lx ly lz ma aw mb bi"><span id="c7e6" class="mc md it ly b gy me mf l mg mh">filepaths <strong class="ly iu">=</strong> glob<strong class="ly iu">.</strong>glob('data/*.gz')</span><span id="4b27" class="mc md it ly b gy mi mf l mg mh"># Output<br/>['data/20191210.csv.gz', 'data/20191209.csv.gz', 'data/20191211.csv.gz']</span></pre><p id="d48f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">glob 检测文件，但是它们没有排序。列表中日期为 2019-12-10 的文件在 2019-12-09 之前。如果我们像在这个例子中一样处理时间序列数据，这是一个问题。</p><p id="2e76" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">为了获得时序数据的正确顺序，我们有两个选择(一个比另一个好):</p><ul class=""><li id="35f6" class="nw nx it lc b ld le lg lh lj ny ln nz lr oa lv ob oc od oe bi translated">将文件按名称排序并按排序顺序读取(坏)，</li><li id="b394" class="nw nx it lc b ld of lg og lj oh ln oi lr oj lv ob oc od oe bi translated">在数据帧中读取所有数据后，按列对数据进行排序(首选)。</li></ul><h2 id="0875" class="mc md it bd nc ok ol dn ng om on dp nk lj oo op nm ln oq or no lr os ot nq ou bi translated">1.1 按文件名排序</h2><p id="a460" class="pw-post-body-paragraph la lb it lc b ld ov ju lf lg ow jx li lj ox ll lm ln oy lp lq lr oz lt lu lv im bi translated">让我们按名称对文件进行分类，以说明为什么这是个坏主意。</p><pre class="kk kl km kn gt lx ly lz ma aw mb bi"><span id="1641" class="mc md it ly b gy me mf l mg mh">filepaths <strong class="ly iu">=</strong> sorted(filepaths)</span><span id="1fbd" class="mc md it ly b gy mi mf l mg mh"># Output<br/>['data/20191209.csv.gz', 'data/20191210.csv.gz', 'data/20191211.csv.gz']</span></pre><p id="6c32" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在本例中，对文件名进行排序是可行的，但是我们需要注意，对字符串进行排序不同于对整数进行排序，如下例所示。这是因为编程语言逐字符进行比较。依靠文件名来保证数据的正确顺序是一个坏主意。</p><p id="9ddb" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在下面的例子中，我们分别对字符串和整数进行排序。</p><pre class="kk kl km kn gt lx ly lz ma aw mb bi"><span id="ca34" class="mc md it ly b gy me mf l mg mh">sorted(['100', '200', '1000', '20000', '9'])</span><span id="e0c2" class="mc md it ly b gy mi mf l mg mh"># Output<br/>['100', '1000', '200', '20000', '9']<br/></span><span id="3682" class="mc md it ly b gy mi mf l mg mh">sorted([100, 200, 1000, 20000, 9])</span><span id="d485" class="mc md it ly b gy mi mf l mg mh"># Output<br/>[9, 100, 200, 1000, 20000]</span></pre><h2 id="b8d5" class="mc md it bd nc ok ol dn ng om on dp nk lj oo op nm ln oq or no lr os ot nq ou bi translated">1.2 按列对整个数据帧进行排序</h2><p id="409c" class="pw-post-body-paragraph la lb it lc b ld ov ju lf lg ow jx li lj ox ll lm ln oy lp lq lr oz lt lu lv im bi translated">如上所述，按列对数据帧进行排序是一个更好的选择，但是我们需要注意列数据类型。</p><p id="6a8b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们来读数据。</p><pre class="kk kl km kn gt lx ly lz ma aw mb bi"><span id="b0c5" class="mc md it ly b gy me mf l mg mh">df_list <strong class="ly iu">=</strong> []<br/><strong class="ly iu">for</strong> filepath <strong class="ly iu">in</strong> filepaths:<br/>    df_ <strong class="ly iu">=</strong> pd<strong class="ly iu">.</strong>read_csv(filepath)<br/>    df_list<strong class="ly iu">.</strong>append(df_)</span><span id="4f7e" class="mc md it ly b gy mi mf l mg mh">df <strong class="ly iu">=</strong> pd<strong class="ly iu">.</strong>concat(df_list)</span></pre><p id="1ae3" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">DataFrame 有多列，我们希望按时间戳对其进行排序。</p><pre class="kk kl km kn gt lx ly lz ma aw mb bi"><span id="af73" class="mc md it ly b gy me mf l mg mh">df<strong class="ly iu">.</strong>head()</span></pre><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi pa"><img src="../Images/2b60b865c31260ba8a4596d49157d232.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F3oTAGOPe6UO7CebW8aZ3Q.png"/></div></div></figure><p id="c2a4" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">没那么快！让我们看看时间戳列的数据类型。</p><pre class="kk kl km kn gt lx ly lz ma aw mb bi"><span id="1afc" class="mc md it ly b gy me mf l mg mh">df<strong class="ly iu">.</strong>timestamp</span><span id="98ef" class="mc md it ly b gy mi mf l mg mh"># Output<br/>0         2019-12-09D00:00:18.265072000<br/>1         2019-12-09D00:00:42.503391000<br/>2         2019-12-09D00:01:50.513620000<br/>3         2019-12-09D00:02:35.189775000<br/>4         2019-12-09D00:03:49.934950000<br/>                      ...              <br/>389905    2019-12-11D23:35:26.637330000<br/>389906    2019-12-11D23:35:26.637330000<br/>389907    2019-12-11D23:37:25.166632000<br/>389908    2019-12-11D23:40:09.701271000<br/>389909    2019-12-11D23:55:46.793512000<br/>Name: timestamp, Length: 1578327, dtype: object</span></pre><p id="acf1" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">时间戳列有一个对象类型。当我们对一个对象类型进行排序时会发生什么？</p><pre class="kk kl km kn gt lx ly lz ma aw mb bi"><span id="35fa" class="mc md it ly b gy me mf l mg mh">pd<strong class="ly iu">.</strong>Series(['100', '200', '1000', '20000', '9'])<strong class="ly iu">.</strong>sort_values()</span><span id="fd57" class="mc md it ly b gy mi mf l mg mh"># Output<br/>0      100<br/>2     1000<br/>1      200<br/>3    20000<br/>4        9<br/>dtype: object</span></pre><p id="10b6" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">熊猫对象类型用于文本或混合数值和非数值。为了获得时间戳列的正确顺序，我们需要将其更改为 datetime64 类型。</p><pre class="kk kl km kn gt lx ly lz ma aw mb bi"><span id="1425" class="mc md it ly b gy me mf l mg mh">df<strong class="ly iu">.</strong>timestamp <strong class="ly iu">=</strong> pd<strong class="ly iu">.</strong>to_datetime(df<strong class="ly iu">.</strong>timestamp<strong class="ly iu">.</strong>str<strong class="ly iu">.</strong>replace("D", "T"))<br/>df<strong class="ly iu">.</strong>timestamp</span><span id="82a0" class="mc md it ly b gy mi mf l mg mh"># Output<br/>0        2019-12-09 00:00:18.265072<br/>1        2019-12-09 00:00:42.503391<br/>2        2019-12-09 00:01:50.513620<br/>3        2019-12-09 00:02:35.189775<br/>4        2019-12-09 00:03:49.934950<br/>                    ...            <br/>389905   2019-12-11 23:35:26.637330<br/>389906   2019-12-11 23:35:26.637330<br/>389907   2019-12-11 23:37:25.166632<br/>389908   2019-12-11 23:40:09.701271<br/>389909   2019-12-11 23:55:46.793512<br/>Name: timestamp, Length: 1578327, dtype: datetime64[ns]</span></pre><p id="d9b3" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">timestamp 列具有 datetime64 类型，我们现在可以继续排序了。</p><pre class="kk kl km kn gt lx ly lz ma aw mb bi"><span id="a34e" class="mc md it ly b gy me mf l mg mh">df <strong class="ly iu">=</strong> df<strong class="ly iu">.</strong>sort_values("timestamp")<br/>df<strong class="ly iu">.</strong>head()</span></pre><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi pb"><img src="../Images/88a575fe5619d642d189ea6a9953c48e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MW92f-pqeHboLVVUp1V62g.png"/></div></div></figure><h1 id="acae" class="nb md it bd nc nd ne nf ng nh ni nj nk jz nl ka nm kc nn kd no kf np kg nq nr bi translated">2.描述统计学</h1><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/6fab45dd4bc308aad9decc92e0d08422.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/1*Vr9M8K4UZDc2gESTQlzsfg.png"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">图片来自 MemeGenerator</p></figure><p id="70a3" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">当我不熟悉数据集时，describe 是我通常运行的第一个命令。我简要回顾了描述性统计数据，如计数、最小值和最大值，以查看数据是否被正确读取。</p><pre class="kk kl km kn gt lx ly lz ma aw mb bi"><span id="4513" class="mc md it ly b gy me mf l mg mh">df<strong class="ly iu">.</strong>describe()</span></pre><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi pd"><img src="../Images/5794bb46f8980c57f7f4964e0c994e69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VC_uES-VxfotKsDJRd3ARw.png"/></div></div></figure><p id="f326" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我有一段时间没有注意到的是，describe 只输出数字列的描述性统计数据。这是有意义的，因为我们不能用其他数据类型如字符串来计算它们。</p><p id="0f1e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">当我们输出列时，我们看到有时间戳、符号等列。，上面没有列出。</p><pre class="kk kl km kn gt lx ly lz ma aw mb bi"><span id="813c" class="mc md it ly b gy me mf l mg mh">df<strong class="ly iu">.</strong>columns</span><span id="e448" class="mc md it ly b gy mi mf l mg mh"># Output<br/>Index(['timestamp', 'symbol', 'side', 'size', 'price', 'tickDirection', 'trdMatchID', 'grossValue', 'homeNotional', 'foreignNotional'], dtype='object')</span></pre><p id="af13" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">幸运的是，describe 使用 include 参数，我们可以指定包含所有列。Include 参数也接受一个列表，我们可以在其中指定列的子集。</p><pre class="kk kl km kn gt lx ly lz ma aw mb bi"><span id="9e55" class="mc md it ly b gy me mf l mg mh">df<strong class="ly iu">.</strong>describe(include<strong class="ly iu">=</strong>'all')</span></pre><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi pe"><img src="../Images/f64688985268a5d543d8bcf70b187fe3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*75X_GLDNUlPZ41MB1dVs1A.png"/></div></div></figure><h1 id="405b" class="nb md it bd nc nd ne nf ng nh ni nj nk jz nl ka nm kc nn kd no kf np kg nq nr bi translated">3.可视化离群值</h1><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi pf"><img src="../Images/52ad994c3d7ca9b0b0674b530dba09ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dqw6cxT-T39saOUJnwOxBQ.jpeg"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">来自<a class="ae kz" href="https://www.pinterest.com/pin/792352128176205493/" rel="noopener ugc nofollow" target="_blank"> Pinterest </a>的熊猫迷因</p></figure><p id="76e4" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">Pandas <code class="fe nt nu nv ly b">plot</code>功能使我们能够快速可视化某一列的分布情况。</p><p id="a7ed" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">为了可视化某一列的异常值，我们可以使用一个箱线图。</p><pre class="kk kl km kn gt lx ly lz ma aw mb bi"><span id="1472" class="mc md it ly b gy me mf l mg mh">df["size"]<strong class="ly iu">.</strong>plot(kind<strong class="ly iu">=</strong>"box")</span></pre><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/331f19658ff714931455a9b2145021bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*9ZiEbjanFBN9-eaCAEAyZA.png"/></div></figure><p id="16d4" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在上面的图中，我们可以观察到<strong class="lc iu">大小</strong>有许多异常值，这使得箱形图没有信息。</p><p id="26dc" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我的解决方案是去掉底部和顶部的 1%分位数。</p><pre class="kk kl km kn gt lx ly lz ma aw mb bi"><span id="c657" class="mc md it ly b gy me mf l mg mh">df['size_clip'] <strong class="ly iu">=</strong> df['size']<strong class="ly iu">.</strong>clip(df['size']<strong class="ly iu">.</strong>quantile(0.01), df['size']<strong class="ly iu">.</strong>quantile(0.99))</span><span id="8d6c" class="mc md it ly b gy mi mf l mg mh">df<strong class="ly iu">.</strong>size_clip<strong class="ly iu">.</strong>plot(kind<strong class="ly iu">=</strong>'box')</span></pre><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/f547d7a8059b49526e95cd9e3f90bd10.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/format:webp/1*meW0vhZXgR9JY-Bs-Yf_3A.png"/></div></figure><p id="2094" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这使得盒图更具信息量，但我们需要尝试不同的分位数值，并在数据帧中添加一个新列。出现了一个问题，我们应该使用哪一列。有没有更好的办法？</p><p id="a696" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">Plot 函数采用 ylim 参数，在这里我们可以指定 y 轴的边界。这使得一个方框图更能提供信息，我们不需要在数据框中增加新的一列。</p><pre class="kk kl km kn gt lx ly lz ma aw mb bi"><span id="467b" class="mc md it ly b gy me mf l mg mh">df["size"]<strong class="ly iu">.</strong>plot(kind<strong class="ly iu">=</strong>"box", ylim<strong class="ly iu">=</strong>(0, 5000))</span></pre><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi pi"><img src="../Images/06902c1be36004d3cff8ef5ecc3575e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*pTe_2avfQWtqF-RZ8-ai3Q.png"/></div></div></figure><h1 id="7750" class="nb md it bd nc nd ne nf ng nh ni nj nk jz nl ka nm kc nn kd no kf np kg nq nr bi translated">4.宁滨数据</h1><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/44b6f4902518e8a13f6181b87bff9e53.png" data-original-src="https://miro.medium.com/v2/resize:fit:626/0*4MhTZp4GyvJyjk6K.gif"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">来自<a class="ae kz" href="https://giphy.com/" rel="noopener ugc nofollow" target="_blank"> Giphy </a>的熊猫玩耍</p></figure><p id="e8db" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">假设我们想将一个数值列转换成一个离散列。</p><h1 id="b807" class="nb md it bd nc nd ne nf ng nh ni nj nk jz nl ka nm kc nn kd no kf np kg nq nr bi translated">4.1 将值装入离散区间</h1><p id="6564" class="pw-post-body-paragraph la lb it lc b ld ov ju lf lg ow jx li lj ox ll lm ln oy lp lq lr oz lt lu lv im bi translated">最直接的方法是指定 n 个间隔，并相应地绑定数据。熊猫有这样的功能。</p><p id="a8b2" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">让我们将价格列绑定到 5 个离散值。</p><pre class="kk kl km kn gt lx ly lz ma aw mb bi"><span id="8b62" class="mc md it ly b gy me mf l mg mh">df['price_discrete_bins'] <strong class="ly iu">=</strong> pd<strong class="ly iu">.</strong>cut(df<strong class="ly iu">.</strong>price, 5)</span><span id="120b" class="mc md it ly b gy mi mf l mg mh"># Output<br/>0            (7462.2, 7575.6]<br/>1            (7462.2, 7575.6]<br/>2            (7462.2, 7575.6]<br/>3            (7462.2, 7575.6]<br/>4            (7462.2, 7575.6]<br/>                  ...        <br/>1309666    (7121.433, 7235.4]<br/>1309667    (7121.433, 7235.4]<br/>1309668    (7121.433, 7235.4]<br/>1309669    (7121.433, 7235.4]<br/>1309670    (7121.433, 7235.4]<br/>Name: price_discrete_bins, Length: 1309671, dtype: category<br/>Categories (5, interval[float64]): [(7121.433, 7235.4] &lt; (7235.4, 7348.8] &lt; (7348.8, 7462.2] &lt; (7462.2, 7575.6] &lt; (7575.6, 7689.0]]</span></pre><p id="0688" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">正如我们所料，price_discrete_bins 有 5 个不同的值，每个 bin 一个。</p><pre class="kk kl km kn gt lx ly lz ma aw mb bi"><span id="29f3" class="mc md it ly b gy me mf l mg mh">df['price_discrete_bins']<strong class="ly iu">.</strong>value_counts()</span><span id="4f61" class="mc md it ly b gy mi mf l mg mh"># Output<br/>(7121.433, 7235.4]    419820<br/>(7235.4, 7348.8]      367043<br/>(7462.2, 7575.6]      301654<br/>(7348.8, 7462.2]      200231<br/>(7575.6, 7689.0]       20923<br/>Name: price_discrete_bins, dtype: int64</span></pre><p id="3e14" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">剪切功能还使我们能够指定箱标签。另请参见 retbins 参数，它输出间隔和标签。</p><pre class="kk kl km kn gt lx ly lz ma aw mb bi"><span id="6f7c" class="mc md it ly b gy me mf l mg mh">df['price_discrete_labels'] <strong class="ly iu">=</strong> pd<strong class="ly iu">.</strong>cut(df<strong class="ly iu">.</strong>price, 5, labels<strong class="ly iu">=</strong>['very low', 'low', 'mid', 'high', 'very high'])</span><span id="8bab" class="mc md it ly b gy mi mf l mg mh"># Output<br/>0              high<br/>1              high<br/>2              high<br/>3              high<br/>4              high<br/>             ...   <br/>1309666    very low<br/>1309667    very low<br/>1309668    very low<br/>1309669    very low<br/>1309670    very low<br/>Name: price_discrete_labels, Length: 1309671, dtype: category<br/>Categories (5, object): [very low &lt; low &lt; mid &lt; high &lt; very high]</span><span id="9e96" class="mc md it ly b gy mi mf l mg mh">df<strong class="ly iu">.</strong>price_discrete_labels<strong class="ly iu">.</strong>value_counts(normalize<strong class="ly iu">=</strong>True)</span><span id="cb24" class="mc md it ly b gy mi mf l mg mh"># Output<br/>very low     0.320554<br/>low          0.280256<br/>high         0.230328<br/>mid          0.152886<br/>very high    0.015976<br/>Name: price_discrete_labels, dtype: float64</span></pre><h1 id="4a56" class="nb md it bd nc nd ne nf ng nh ni nj nk jz nl ka nm kc nn kd no kf np kg nq nr bi translated">4.2 将值装入大小相等的桶中</h1><p id="a7eb" class="pw-post-body-paragraph la lb it lc b ld ov ju lf lg ow jx li lj ox ll lm ln oy lp lq lr oz lt lu lv im bi translated">在进行数据分析时，最直接的方式并不总是最好的方式(或者我认为是其他方式)😊).上面我没有指出的是，极高值(0.015%)明显比其他值(都超过 15%)代表的少。如果我们打算在这个数据集上训练一个预测模型，这可能会带来一个问题:</p><ul class=""><li id="9c9f" class="nw nx it lc b ld le lg lh lj ny ln nz lr oa lv ob oc od oe bi translated">算法可能会过度拟合“非常高”的值，因为该值非常罕见，</li><li id="9ede" class="nw nx it lc b ld of lg og lj oh ln oi lr oj lv ob oc od oe bi translated">算法可以将“非常高”值的出现归因于错误，并完全跳过它。</li></ul><p id="cb97" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">有办法避免这个问题吗？</p><p id="5519" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">有。让我们将价格分成大小相等的箱，这样每个箱都有相同数量的值。</p><pre class="kk kl km kn gt lx ly lz ma aw mb bi"><span id="d686" class="mc md it ly b gy me mf l mg mh">df['price_discrete_equal_bins'] <strong class="ly iu">=</strong> pd<strong class="ly iu">.</strong>qcut(df<strong class="ly iu">.</strong>price, 5)</span><span id="7404" class="mc md it ly b gy mi mf l mg mh"># Output<br/>0            (7477.0, 7689.0]<br/>1            (7477.0, 7689.0]<br/>2            (7477.0, 7689.0]<br/>3            (7477.0, 7689.0]<br/>4            (7477.0, 7689.0]<br/>                  ...        <br/>1309666    (7121.999, 7212.5]<br/>1309667    (7121.999, 7212.5]<br/>1309668    (7121.999, 7212.5]<br/>1309669    (7121.999, 7212.5]<br/>1309670    (7121.999, 7212.5]<br/>Name: price_discrete_equal_bins, Length: 1309671, dtype: category<br/>Categories (5, interval[float64]): [(7121.999, 7212.5] &lt; (7212.5, 7292.5] &lt; (7292.5, 7348.5] &lt; (7348.5, 7477.0] &lt; (7477.0, 7689.0]]<br/></span><span id="b002" class="mc md it ly b gy mi mf l mg mh">df<strong class="ly iu">.</strong>price_discrete_equal_bins<strong class="ly iu">.</strong>value_counts()</span><span id="9a56" class="mc md it ly b gy mi mf l mg mh"># Output<br/>(7121.999, 7212.5]    264009<br/>(7292.5, 7348.5]      262610<br/>(7348.5, 7477.0]      262396<br/>(7477.0, 7689.0]      260412<br/>(7212.5, 7292.5]      260244<br/>Name: price_discrete_equal_bins, dtype: int64</span></pre><h1 id="9ba5" class="nb md it bd nc nd ne nf ng nh ni nj nk jz nl ka nm kc nn kd no kf np kg nq nr bi translated">5.处理缺失数据</h1><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/397028e79a6474fdd6e1bd6bdfb16d3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:830/0*pN1ugQABYbeg1igw.gif"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">来自<a class="ae kz" href="https://giphy.com/gifs/panda-angry-breaking-EPcvhM28ER9XW" rel="noopener ugc nofollow" target="_blank"> Giphy </a>的愤怒熊猫</p></figure><p id="ff6d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在熊猫中，多个值表示一个缺失值:</p><ul class=""><li id="576f" class="nw nx it lc b ld le lg lh lj ny ln nz lr oa lv ob oc od oe bi translated">NaN 表示数值/对象缺失值，</li><li id="5d24" class="nw nx it lc b ld of lg og lj oh ln oi lr oj lv ob oc od oe bi translated">DateTime 的 NaT 缺少值，</li><li id="52d1" class="nw nx it lc b ld of lg og lj oh ln oi lr oj lv ob oc od oe bi translated">None，来自 Python。</li></ul><p id="fa48" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">造成这种混乱的原因是(来自<a class="ae kz" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/missing_data.html" rel="noopener ugc nofollow" target="_blank"> pandas 文档</a>):<br/>T5】选择在内部使用 NaN 来表示丢失的数据很大程度上是出于简单和性能的原因。我们希望 NumPy 很快能够提供一个本地 NA 类型的解决方案(类似于 R ),其性能足以用于熊猫。</p><p id="d4eb" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">让我惊讶的是 Python 中的 None 等于 None，而 numpy 中的 nan 不等于 nan。</p><pre class="kk kl km kn gt lx ly lz ma aw mb bi"><span id="04e6" class="mc md it ly b gy me mf l mg mh">None <strong class="ly iu">==</strong> None<br/>True</span><span id="f04c" class="mc md it ly b gy mi mf l mg mh">pd<strong class="ly iu">.</strong>np<strong class="ly iu">.</strong>nan <strong class="ly iu">==</strong> pd<strong class="ly iu">.</strong>np<strong class="ly iu">.</strong>nan<br/>False</span></pre><p id="bfd5" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这一点很重要，这样我们就不会按“无”来筛选值:</p><pre class="kk kl km kn gt lx ly lz ma aw mb bi"><span id="fe79" class="mc md it ly b gy me mf l mg mh">df[df.some_column == None]</span><span id="cdbd" class="mc md it ly b gy mi mf l mg mh"># instead use:<br/>df[df.some_column.isnull()]</span></pre><p id="1e7f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">numpy nan 不等于自身的原因是什么？让我们潜入更深的地方。某些函数在不可计算时返回 nan。</p><pre class="kk kl km kn gt lx ly lz ma aw mb bi"><span id="3d05" class="mc md it ly b gy me mf l mg mh">pd<strong class="ly iu">.</strong>np<strong class="ly iu">.</strong>log(<strong class="ly iu">-</strong>1)</span><span id="72bd" class="mc md it ly b gy mi mf l mg mh">nan<br/></span><span id="d8dd" class="mc md it ly b gy mi mf l mg mh">pd<strong class="ly iu">.</strong>np<strong class="ly iu">.</strong>arccos(2)</span><span id="4576" class="mc md it ly b gy mi mf l mg mh">nan</span></pre><p id="5464" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这是否意味着函数的结果应该是相同的？显然不是。</p><pre class="kk kl km kn gt lx ly lz ma aw mb bi"><span id="4542" class="mc md it ly b gy me mf l mg mh">pd<strong class="ly iu">.</strong>np<strong class="ly iu">.</strong>log(<strong class="ly iu">-</strong>1) <strong class="ly iu">==</strong> pd<strong class="ly iu">.</strong>np<strong class="ly iu">.</strong>arccos(2)</span><span id="f4b9" class="mc md it ly b gy mi mf l mg mh">False</span></pre><p id="0912" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">关于缺失值行为的一些重要细节摘自<a class="ae kz" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/missing_data.html" rel="noopener ugc nofollow" target="_blank"> pandas 文档</a>:</p><ul class=""><li id="e4a3" class="nw nx it lc b ld le lg lh lj ny ln nz lr oa lv ob oc od oe bi translated">GroupBy 中的 NA 组被自动排除。</li><li id="e244" class="nw nx it lc b ld of lg og lj oh ln oi lr oj lv ob oc od oe bi translated">对数据求和时，NA(缺失)值将被视为零。</li><li id="d860" class="nw nx it lc b ld of lg og lj oh ln oi lr oj lv ob oc od oe bi translated">如果数据都是 NA，结果会是 0。</li><li id="4b38" class="nw nx it lc b ld of lg og lj oh ln oi lr oj lv ob oc od oe bi translated">像 cumsum()和 cumprod()这样的累积方法默认情况下忽略 NA 值，但是将它们保留在结果数组中。</li></ul><h1 id="cc25" class="nb md it bd nc nd ne nf ng nh ni nj nk jz nl ka nm kc nn kd no kf np kg nq nr bi translated">结论</h1><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/0f029b9589840871a00e0729c928c0c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/0*djs8NqhAjQ49m_Mx.gif"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">来自<a class="ae kz" href="https://giphy.com/gifs/panda-critters-TRuV1HrNrNmP6" rel="noopener ugc nofollow" target="_blank"> Giphy </a>的强壮熊猫</p></figure><p id="64b3" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这些是你在做数据分析时需要小心的一些关于熊猫的问题。希望你学到了新的东西。</p><h1 id="73ae" class="nb md it bd nc nd ne nf ng nh ni nj nk jz nl ka nm kc nn kd no kf np kg nq nr bi translated">在你走之前</h1><p id="dea3" class="pw-post-body-paragraph la lb it lc b ld ov ju lf lg ow jx li lj ox ll lm ln oy lp lq lr oz lt lu lv im bi translated">在<a class="ae kz" href="https://twitter.com/romanorac" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我，在那里我定期<a class="ae kz" href="https://twitter.com/romanorac/status/1328952374447267843" rel="noopener ugc nofollow" target="_blank">发布关于数据科学和机器学习的</a>消息。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi pm"><img src="../Images/b5d426b68cc5a21b1a35d0a157ebc4f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*69rP1pwjJi9mLSFE"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">在<a class="ae kz" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kz" href="https://unsplash.com/@cmhedger?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Courtney hedge</a>拍摄的照片</p></figure></div></div>    
</body>
</html>