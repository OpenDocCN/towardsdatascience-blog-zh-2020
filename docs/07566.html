<html>
<head>
<title>Understand zip() — A Hidden Gem in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解zip()—Python中隐藏的瑰宝</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/understand-zip-a-hidden-gem-in-python-9488a255f45d?source=collection_archive---------35-----------------------#2020-06-07">https://towardsdatascience.com/understand-zip-a-hidden-gem-in-python-9488a255f45d?source=collection_archive---------35-----------------------#2020-06-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="be04" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">有效地合并未知数量的列表</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1e28e51111d51393e20d1151b919f8d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*p6D1fWfkZ1QgHuCc"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@fabrizioverrecchia" rel="noopener ugc nofollow" target="_blank"> Fabrizio Verrecchia </a>在<a class="ae ky" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="a59c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated"><span class="l lw lx ly bm lz ma mb mc md di">在</span> Python中，有几种方法可以合并2个列表/元组/集/字典。我所说的“合并”不仅仅是将一个元素附加到另一个元素上，而是将具有相同索引的元素分组。如果你在面试中，面试官要求你实现以下逻辑，你的第一个“蛮力”回答会是什么？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi me"><img src="../Images/f0e133c7250e0a1a1f2354fed6c9f4b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/1*5octaXD8BO5Xax53jF_oEA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者:高</p></figure><p id="ffb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大概你会想出这样的东西。程序遍历<code class="fe mf mg mh mi b">city</code>的长度，每次都从具有相同索引的<code class="fe mf mg mh mi b">country</code>和<code class="fe mf mg mh mi b">city</code>中获取值，然后将它们放入一个元组中。这绝对是一个可行的解决方案，但不是你的面试官所期待的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/762de9e7fa30f88435b8840acb3fe8c9" rel="noopener ugc nofollow" target="_blank">蛮干. py </a></p></figure><p id="4957" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">稍微改进一下，可以用<code class="fe mf mg mh mi b">enumerate</code>迭代<code class="fe mf mg mh mi b">city</code>。<code class="fe mf mg mh mi b">enumerate</code>返回列表中每个元素的索引和值。所以我们可以用<code class="fe mf mg mh mi b">ci</code>代替<code class="fe mf mg mh mi b">city[i]</code>。但这仍然不是理想的答案。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/4dd01295a240982a981088471c7b219f" rel="noopener ugc nofollow" target="_blank"> enumerate.py </a></p></figure></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h2 id="3be2" class="ms mt it bd mu mv mw dn mx my mz dp na li nb nc nd lm ne nf ng lq nh ni nj nk bi translated">zip()内置函数</h2><p id="f82a" class="pw-post-body-paragraph kz la it lb b lc nl ju le lf nm jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">Python有许多隐藏的宝石，而<code class="fe mf mg mh mi b">zip()</code>就是其中之一。它能够以更干净的方式解决同样的问题。我们都喜欢干净的代码，不是吗？</p><blockquote class="nq nr ns"><p id="9e09" class="kz la nt lb b lc ld ju le lf lg jx lh nu lj lk ll nv ln lo lp nw lr ls lt lu im bi translated">根据官方Python文档，<code class="fe mf mg mh mi b">zip(*iterables)</code>创建了一个迭代器，它聚集了来自每个迭代器的元素。</p></blockquote><p id="355f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">向拆包操作员重述(*) </strong></p><p id="f635" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">单个星号(*)意味着它解包迭代器。例如，如果您有两个列表<code class="fe mf mg mh mi b">list1=["a1","a2"]</code>和<code class="fe mf mg mh mi b">list2=["b1","b2"]</code>，您不必创建一个新的参数列表并将其传递给类似<code class="fe mf mg mh mi b">zip([list1,list2])</code>的函数，相反，您可以只做<code class="fe mf mg mh mi b">zip(list1, list2)</code>。</p><p id="bc3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您不知道函数的参数个数时，可以使用解包运算符(*)。<strong class="lb iu"> </strong>比如你可以计算一个未知数量的自变量之和。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/6d8d028521bfbd9e89ad1540fe8ff2dc" rel="noopener ugc nofollow" target="_blank">拆包. py </a></p></figure><p id="938d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个拆包操作符是(**)。两个星号代表字典。这意味着每个参数必须有一个键，这就是为什么你通常把<code class="fe mf mg mh mi b">**kwargs</code>(关键字参数)作为输入名。明确一下，你可以给它取任何名字，比如<code class="fe mf mg mh mi b">**nums</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/78564cc88601f946edac6eecfc334235" rel="noopener ugc nofollow" target="_blank"> kwargs.py </a></p></figure><p id="30f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想了解更多关于<code class="fe mf mg mh mi b">*args</code>和<code class="fe mf mg mh mi b">**kwargs</code>的知识，我推荐你阅读<a class="ae ky" href="https://realpython.com/python-kwargs-and-args/" rel="noopener ugc nofollow" target="_blank"> <em class="nt"> Python args和kwargs:来自真实Python的去神秘化</em> </a>。</p><div class="nx ny gp gr nz oa"><a href="https://realpython.com/python-kwargs-and-args/" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd iu gy z fp of fr fs og fu fw is bi translated">Python参数和kwargs:去神秘化——真正的Python</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">在这个循序渐进的教程中，您将学习如何在Python中使用args和kwargs来为您的…</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">realpython.com</p></div></div><div class="oj l"><div class="ok l ol om on oj oo ks oa"/></div></div></a></div><p id="e507" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mf mg mh mi b"><strong class="lb iu">zip()</strong></code><strong class="lb iu">vs</strong><code class="fe mf mg mh mi b"><strong class="lb iu">zip_longest()</strong></code></p><p id="367b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">再来说说<code class="fe mf mg mh mi b">zip()</code>。我们知道<code class="fe mf mg mh mi b">zip(*iterables)</code>的输入是一些迭代器。迭代器可以是一个<em class="nt">字符串</em>、<em class="nt">列表</em>、<em class="nt">元组、集合或字典。</em>在内部，<code class="fe mf mg mh mi b">zip()</code>对所有迭代器进行多轮循环。在每一轮中，它对每个迭代器调用<code class="fe mf mg mh mi b">next()</code>函数，并将值放入一个元组中，在这一轮结束时<strong class="lb iu">产生</strong>元组。然后继续下一轮。<strong class="lb iu">如果任何迭代器用尽，循环将结束</strong>。也许看代码更容易。Python文档给出了下面的代码来帮助读者理解<code class="fe mf mg mh mi b">zip()</code>是如何工作的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/1a387695ece6b04456f0691f5f8dcd56" rel="noopener ugc nofollow" target="_blank"> zip_implementation.py </a>(来源:<a class="ae ky" href="https://docs.python.org/3.3/library/functions.html#zip" rel="noopener ugc nofollow" target="_blank"> python doc </a>)</p></figure><p id="4627" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那我们用<code class="fe mf mg mh mi b">zip()</code>来解决前面的问题吧。每次都会产生一个元组。使用yield的一个优点是节省RAM的使用，因为我们不需要将整个结果序列存储在内存中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/09de348916edfd389d1b6472903cbb31" rel="noopener ugc nofollow" target="_blank"> zip-example.py </a></p></figure><p id="c93c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认的<code class="fe mf mg mh mi b">zip()</code>遵循<em class="nt">坎尼金定律</em>，这意味着合并结果的长度取决于最短的输入迭代。这就是为什么在前面的例子中，您在输出中看不到国家<code class="fe mf mg mh mi b">X</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/b8c797c2b131b4ff379f4fd0b547cb60.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/0*dxmDScqrry2P9Xvc.jpg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="oq">康尼金定律(</em>来源:<a class="ae ky" href="http://keropokleko.blogspot.com/2015/06/effects.html" rel="noopener ugc nofollow" target="_blank">博客</a>)</p></figure><p id="3236" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，如果希望合并后的结果与最长的<strong class="lb iu">输入迭代器对齐，可以使用<code class="fe mf mg mh mi b"><a class="ae ky" href="https://docs.python.org/3.3/library/itertools.html#itertools.zip_longest" rel="noopener ugc nofollow" target="_blank">itertools.zip_longest</a></code>。在这种情况下，缺少的值将由用户定义的<code class="fe mf mg mh mi b">fillvalue</code>填充。</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/ec88ae0684c7da1c78abf2a8d56243fb" rel="noopener ugc nofollow" target="_blank"> zip-longest.py </a></p></figure><p id="4bb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">拉开</strong></p><p id="68eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们可以“压缩”2个迭代器，我们也必须能够“解压缩”它。逻辑是<code class="fe mf mg mh mi b">unzipped = zip(*zip(*iterables))</code>。在示例代码中，<code class="fe mf mg mh mi b">zipped</code>和<code class="fe mf mg mh mi b">unzipped</code>对象都有类<code class="fe mf mg mh mi b">zip</code>，它们是不可读的。我们可以将它们转换成一个<em class="nt">列表</em>或一个<em class="nt">元组</em>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/d0c2fac18cb52506c7aded18b22dff49" rel="noopener ugc nofollow" target="_blank"> unzip.py </a></p></figure><p id="fe74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">边缘案例</strong></p><p id="9015" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对输入迭代器的数量没有限制。它可以是0、1或更多。拥有0个或1个输入迭代器的情况并不常见，但这仍然是可能的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/58b44a60e2a8f77883a49d4e1d0efd37" rel="noopener ugc nofollow" target="_blank"> zip-edge-cases.py </a></p></figure><p id="38d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">字典中的</strong> <code class="fe mf mg mh mi b"><strong class="lb iu">zip()</strong></code></p><p id="a0a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下代码的结果会是什么？在进一步阅读之前思考一下。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/d210af80c179ae60cc9d58970a33bfb4" rel="noopener ugc nofollow" target="_blank"> zip-dictionary.py </a></p></figure><p id="bdaf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">答案是<code class="fe mf mg mh mi b">("city", "city", "city")</code>和<code class="fe mf mg mh mi b">(“country”, “country”, “country”)</code>。为什么我们只有钥匙？</p><p id="a6e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据我们之前看到的，在内部<code class="fe mf mg mh mi b">zip()</code>对每个输入参数执行<code class="fe mf mg mh mi b">iter()</code>。所以问题是<code class="fe mf mg mh mi b">iter(nl)</code>的产量是多少？如果我们执行<code class="fe mf mg mh mi b">print(iter(nl))</code>，我们将得到<code class="fe mf mg mh mi b">&lt;dict_keyiterator object at 0x10e1e3f50&gt;</code>。这就是为什么我们在结果中只接收键。</p><p id="4a26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更好的方法是使用<code class="fe mf mg mh mi b">nl.items()</code>作为输入。在这种情况下，我们能够在循环中接收键和值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/ba9fb892fdef9548d5b332e58217ac31" rel="noopener ugc nofollow" target="_blank"> zip-dictionary-2.py </a></p></figure><p id="db12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">中的<strong class="lb iu">混合型<code class="fe mf mg mh mi b"><strong class="lb iu">zip()</strong></code></strong></p><p id="dfe5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">迭代器的类型也没有限制。在下面的代码中，我们使用混合类型作为输入参数。结果会怎样？想一想。这个例子只是出于教育目的。它不应该是你见过的最好的代码。🙂</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="a4e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧，答案是:</p><pre class="kj kk kl km gt or mi os ot aw ou bi"><span id="a742" class="ms mt it mi b gy ov ow l ox oy">('w', 'Amsterdam', ('key1', 'Netherlands'))<br/>('o', 'Berlin', ('key2', 'Germany'))<br/>('r', 'Chongqing', ('key3', 'China'))</span></pre><p id="57a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个<code class="fe mf mg mh mi b">ele</code>是来自3个输入参数的3个元素的元组。<code class="fe mf mg mh mi b">string</code>的长度应该考虑为5，而不是1。每个循环将返回1个字符。程序总共循环3次，因为输入的最短长度是3。</p><p id="16e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你能回答这个问题并解释背后的原因，那么你已经掌握了这一章。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h2 id="5b44" class="ms mt it bd mu mv mw dn mx my mz dp na li nb nc nd lm ne nf ng lq nh ni nj nk bi translated">结论</h2><p id="33e4" class="pw-post-body-paragraph kz la it lb b lc nl ju le lf nm jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated"><code class="fe mf mg mh mi b">zip()</code>给了我们用干净的代码合并未知数量的迭代器的便利。当我们有许多大小相同的迭代器时，效果最好。<code class="fe mf mg mh mi b">zip()</code>创建一个生成器，因此它能够处理长输入并节省RAM的使用。</p><p id="34de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同时，我们应该注意<code class="fe mf mg mh mi b">zip()</code>的一些行为:</p><ul class=""><li id="008a" class="oz pa it lb b lc ld lf lg li pb lm pc lq pd lu pe pf pg ph bi translated"><code class="fe mf mg mh mi b">zip()</code>遵循<em class="nt">康尼金定律。它不断产生元组，直到所有迭代器都用完为止。如果迭代器的长度不匹配，它不会抛出异常。</em></li><li id="e8b5" class="oz pa it lb b lc pi lf pj li pk lm pl lq pm lu pe pf pg ph bi translated"><code class="fe mf mg mh mi b">itertools.zip_longest</code>通过用用户自定义的<code class="fe mf mg mh mi b">fillvalue</code>填充缺失值，解决了“长度”问题。</li><li id="6e5e" class="oz pa it lb b lc pi lf pj li pk lm pl lq pm lu pe pf pg ph bi translated">使用<code class="fe mf mg mh mi b">zip()</code>中的<code class="fe mf mg mh mi b">str</code>和<code class="fe mf mg mh mi b">dict</code>时要小心。你需要很好地理解<code class="fe mf mg mh mi b">iter</code>如何与<code class="fe mf mg mh mi b">str</code>和<code class="fe mf mg mh mi b">dict</code>一起工作。</li></ul><p id="1c62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢这篇文章！如果你有任何想法，请在下面留下你的评论。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h2 id="5e27" class="ms mt it bd mu mv mw dn mx my mz dp na li nb nc nd lm ne nf ng lq nh ni nj nk bi translated">参考</h2><div class="nx ny gp gr nz oa"><a href="https://docs.python.org/3.3/library/functions.html#zip" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd iu gy z fp of fr fs og fu fw is bi translated">2.内置函数- Python 3.3.7文档</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">Python解释器内置了许多始终可用的函数和类型。它们被列出…</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">docs.python.org</p></div></div></div></a></div><div class="nx ny gp gr nz oa"><a href="https://appdividend.com/2019/04/09/python-zip-example-python-zip-function-tutorial/" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd iu gy z fp of fr fs og fu fw is bi translated">Python zip示例|用于迭代的Python zip()函数</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">Python zip()是一个返回zip对象的内置函数，该对象是元组的迭代器，其中第一项…</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">appdividend.com</p></div></div><div class="oj l"><div class="pn l ol om on oj oo ks oa"/></div></div></a></div></div></div>    
</body>
</html>