<html>
<head>
<title>Time Series Processing In Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中的时间序列处理</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/time-series-processing-in-python-32a8d085e6e5?source=collection_archive---------42-----------------------#2020-05-20">https://towardsdatascience.com/time-series-processing-in-python-32a8d085e6e5?source=collection_archive---------42-----------------------#2020-05-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6234" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">第一部分:使用熊猫的基本分析</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/948d47b4243cc7986568ee14d74ec8fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d4CsN19s0qc_yuxV6xeUvw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@aleskrivec?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Ales Krivec </a>在<a class="ae ky" href="https://unsplash.com/s/photos/time-series?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="8669" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">时间序列是一段时间内的一系列值。旧金山过去 30 天的日平均气温就是一个例子。</p><p id="f9d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">时间序列出现在各行各业，从天气到经济到产品销售到健康指标。</p><p id="983a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么要分析时间序列？因为这可以揭示趋势和其他模式。从中可以预测未来的价值。</p><p id="5421" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章通过一个简单的运行和发展的例子，介绍了 Python 中 Pandas 库中处理时间序列的各种特性。</p><p id="1d2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">熊猫时间序列特征可以分为两类:时间序列中的值的特征和这些值后面的时间指数的特征。本帖涵盖前者。后者本身就是一个完整的主题，将在后续的帖子中讨论。</p><p id="85cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">示例设置:温度</strong></p><p id="1989" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要开始使用熊猫，只需</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="3f33" class="ma mb it lw b gy mc md l me mf">import pandas as pd</span></pre><p id="15d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们创建我们的第一个时间序列。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="2fee" class="ma mb it lw b gy mc md l me mf">temps = pd.Series([70,75,65,70,75,70,30, 100, 80,72,76,79,85,76,81,69, 78])</span></pre><p id="4702" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">把<code class="fe mg mh mi lw b">temps</code>想象成存储旧金山连续几天的日平均温度。日期隐含在索引中<em class="mj"> t </em> = 0，1，2，…</p><p id="22e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Pandas 支持更精细的时间指数。例如，我们可以存储 temps 封面的实际日期。我们不会在这里讨论这些。因此，我们可以将重点放在值的操作上，这些值有很大的变化。</p><p id="2087" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">温度最小值、最大值、平均值、可变性</strong></p><p id="7d41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mg mh mi lw b">temps</code>的平均(或最低或最高)温度是多少？简单:只需做<code class="fe mg mh mi lw b">temps.mean()</code>、<code class="fe mg mh mi lw b">temps.min()</code>或<code class="fe mg mh mi lw b">temps.max()</code>。气温波动有多大？Do: <code class="fe mg mh mi lw b">temps.std()</code>获得数量感。它会给出标准差。</p><p id="e05a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从数据中感受一下。<code class="fe mg mh mi lw b">temps.mean()</code>返回约 73.58。这接近于人们仅仅通过观察数据所猜测的。<code class="fe mg mh mi lw b">temps.min()</code>和<code class="fe mg mh mi lw b">temps.max()</code>分别是 30 和 100。范围很广。</p><p id="ea17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mg mh mi lw b">temps.std()</code>返回约 13.74。因此，大多数温度徘徊在平均值的 13 度以内——正负。我们一眼就能看出这一点。</p><p id="ee46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一种方法是通过计算第 5 和第 95 个百分点，这可以被认为是 min 和 max 的软化。<code class="fe mg mh mi lw b">temps.quantile(0.05)</code>为 58.0，<code class="fe mg mh mi lw b">temps.quantile(0.95)</code>约为 88。所以这也给了我们一个相似的范围。</p><p id="8c7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们给<code class="fe mg mh mi lw b">temps</code>添加一个异常值，看看它如何影响我们的分析。这种异常值可能是由数据输入错误引起的。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="bb0e" class="ma mb it lw b gy mc md l me mf">temps_with_outlier = pd.Series([70,75,65,70,75,70,30, 100, 80,72,76,79,<strong class="lw iu">10000</strong>,85,76,81,69, 78])</span></pre><p id="802b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到<code class="fe mg mh mi lw b">temps_with_outlier.mean()</code>是一个巨大的 625.055！而<code class="fe mg mh mi lw b">temps_with_outlier.std()</code>安，更是高达 2339.715！由此得出的教训是，无论是均值还是标准差，对异常值都不稳健。</p><p id="6e97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">统计学家建议，在这种情况下，我们应该使用中位数和平均绝对偏差(mad)来代替。它们是对异常值稳健的均值和标准差版本。<code class="fe mg mh mi lw b">temps_with_outlier.<strong class="lb iu">median</strong>()</code>是 75.5。哇！<code class="fe mg mh mi lw b">temps_with_outlier.<strong class="lb iu">mad</strong>()</code>是 1041.66。有点帮助。不够。经验教训:一定要用中位数。</p><p id="7869" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">从华氏温度转换到摄氏温度</strong></p><p id="021d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能已经猜到我们的温度目前是华氏温度。怎样才能让这些进入摄氏温度？不多。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="f94a" class="ma mb it lw b gy mc md l me mf">temps_celcius = (temps-32)*5/9</span></pre><p id="9324" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相当多的事情发生在幕后。首先，从<code class="fe mg mh mi lw b">temps</code>中的每个值中减去 32，得到一个新的时间序列。接下来，结果时间序列中的每个值都乘以 5/9。</p><p id="8a38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">关联邻近城市的温度</strong></p><p id="1cb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们根据旧金山的估计温度虚构一个圣何塞的估计温度时间序列(尽管是真实的)。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="8f77" class="ma mb it lw b gy mc md l me mf">temps_sj = temps + 10</span></pre><p id="7c05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的想法是，圣何塞往往比旧金山暖和几度，因为它远离海洋，在一个避风的山谷里。</p><p id="403c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们注意到<code class="fe mg mh mi lw b">temps</code>和<code class="fe mg mh mi lw b">temps_sj</code>是相关的，即它们一起移动。在任何一天，<code class="fe mg mh mi lw b">temps_sj</code>中的值总是比 temps 中的值高 10 度。</p><p id="5fc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这让我们不禁要问:如何度量同一时间点上的两个时间序列是相关的？在探讨这个之前，我们先设置一个“控制”。这将与温度无关。所以我们可以衡量我们的措施有多有效。通过比较<code class="fe mg mh mi lw b">temps</code>和<code class="fe mg mh mi lw b">temps_sj</code>相对于<code class="fe mg mh mi lw b">temps</code>和控制的公式相关性。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="f8a8" class="ma mb it lw b gy mc md l me mf">import random<br/>temps_random = pd.Series(random.sample(range(58,88),len(temps)))</span></pre><p id="1b1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里发生了很多事。我们来解释一下。</p><p id="af18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mg mh mi lw b">random.sample(range(58,88),len(temps))</code>从 58 到 88 的范围内独立均匀地采样<code class="fe mg mh mi lw b">len(temps)</code>值。我们试图近似我们在<code class="fe mg mh mi lw b">temps</code>中看到的数值范围，同时平均分配这些数值。这就是为什么<code class="fe mg mh mi lw b">temps</code>和<code class="fe mg mh mi lw b">temps_random</code>有相似的值，只是它们不相关。</p><p id="2c1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提出相关性度量的第一个合理尝试是将这两个时间序列的各个部分相乘，以产生一个新的时间序列。然后对这个时间序列中的所有值求和。让我们来看看实际情况。先应用到<code class="fe mg mh mi lw b">temps</code>和<code class="fe mg mh mi lw b">temps_sj</code>上吧。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="e069" class="ma mb it lw b gy mc md l me mf">m = temps*temps_sj<br/>m.sum()</span></pre><p id="11d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mg mh mi lw b">m</code>中的前两个值是 5600 和 6375。5600 等于<code class="fe mg mh mi lw b">temps[0]*temps_sj[0]</code>，6375 等于<code class="fe mg mh mi lw b">temps[1]*temps_sj[1]</code>。</p><p id="9e97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mg mh mi lw b">*</code>操作也称为点积。</p><p id="76ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mg mh mi lw b">m.sum()</code>等于 107593。价值大。我们不知道这是怎么回事。这就是控制权的来源。如果我们的相关性度量很好，如果我们用<code class="fe mg mh mi lw b">temps_random</code>代替<code class="fe mg mh mi lw b">temps_sj</code>，那么<code class="fe mg mh mi lw b">m.sum()</code>的值应该会低得多。</p><p id="e900" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mg mh mi lw b">(temps*temps_random).sum()</code>等于 88480。所以确实低了，意料之中！也就是说，它应该更低，对不对？</p><p id="2981" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嗯，让我们试试不同的东西。在进行点积之前，让我们先将<code class="fe mg mh mi lw b">temps</code>和<code class="fe mg mh mi lw b">temps_random</code>分别居中。随着代码变得越来越复杂，让我们把它封装成一个函数。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="6333" class="ma mb it lw b gy mc md l me mf">def centered_dot_product(time_series_1,time_series_2):<br/>    ts1_centered = time_series_1- time_series_1.mean()<br/>    ts2_centered = time_series_2- time_series_2.mean()<br/>    return (ts1_centered*ts2_centered).sum()</span></pre><p id="aeed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mg mh mi lw b">centered_dot_product(temps,temps_sj)</code>返回 3024.11，而<code class="fe mg mh mi lw b">centered_dot_product(temps,temps_random)</code>返回-414.58。那好多了。区别更加明显。</p><p id="266f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么前者效果不好？因为在所有的时间序列中，大部分温度都在 58 到 88 度之间。点积发现了这种相似性。先定中心“减去”这种相似性，这样得到的测量结果可以不关注时间序列中的值，而是关注它们如何<em class="mj">共变</em>。</p><p id="4632" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以在这个指标上进一步改进，但我们不会。我们希望涵盖其他功能。</p><p id="9ffd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">发现温度异常值</strong></p><p id="f93f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑一下<code class="fe mg mh mi lw b">temps_with_outlier</code>。以前我们用它来说明处理异常值的统计数据。在这里，我们研究如何找到离群值。</p><p id="85a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经将发现异常值封装到一个函数中。它的代码有点复杂。我们建议先读一遍，然后看看我们接下来的解释，如果你还有点不清楚的话，可能还会再读一遍。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="8aa9" class="ma mb it lw b gy mc md l me mf">def outliers(time_series,lowp,highp):<br/>   low = time_series.quantile(lowp)<br/>   high = time_series.quantile(highp)<br/>   in_range = time_series.between(low,high)<br/>   outliers = []<br/>   for t,v in in_range.items():<br/>      if not v:<br/>          outliers.append([t,time_series[t]])<br/>   return outliers</span></pre><p id="1406" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在解释幕后发生的事情之前，让我们打个电话给它，看看它会有什么回报。此外，这也给了我们一个解释参数<code class="fe mg mh mi lw b">lowp</code>和<code class="fe mg mh mi lw b">highp</code>的机会。</p><p id="7444" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mg mh mi lw b">outliers(temps_with_outlier,0.01,0.99)</code>返回[[6，30]，[12，10000]]。这表明温度 30 和 10000 被视为异常值，分别出现在时间点 6 和 12。有道理！</p><p id="616c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在决定什么是离群值时有多严格？这是由分位数的下限和上限指定的，我们在此图中选择的值是 0.01 和 0.99。提高下限和降低上限将放宽离群值标准。让我们看看这是如何运作的。</p><p id="d1d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mg mh mi lw b">outliers(temps_with_outlier,0.1,0.9)</code>返回[[2，65]，[6，30]，[7，100]，[12，10000]]。在我们之前的异常值列表中又增加了两个:65 度和 100 度。新发现的可能被合理地解释为分别是“异常冷”和“异常热”。</p><p id="f5d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不错。</p><p id="3388" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">气温上升了吗？</strong></p><p id="5ad4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑<code class="fe mg mh mi lw b">temps</code>的以下变体:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="8656" class="ma mb it lw b gy mc md l me mf">temps = pd.Series([60,65,62,68,65,67,70,67,73,67,75,66,77,69,77,69,79])</span></pre><p id="aeca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你看到了什么？气温呈上升趋势。通过适当区分时间序列，可以使这种趋势更加生动。让我们看看这个效果如何。</p><p id="62da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先尝试<code class="fe mg mh mi lw b">temps.diff(1)</code>。这导致了<code class="fe mg mh mi lw b">temps</code>中一步差的时间序列。即:NaN，temps[1]-temps[0]，temps[2]-temps[1]，…第一个值是 NaN，因为<code class="fe mg mh mi lw b">temps[-1]</code>未定义。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="5ec2" class="ma mb it lw b gy mc md l me mf">nan 5.0 -3.0 6.0 -3.0 2.0 3.0 -3.0 6.0 -6.0 8.0 -9.0 11.0 -8.0 8.0 -8.0 10.0</span></pre><p id="63e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嗯，还没那么生动。让我们试试<code class="fe mg mh mi lw b">temps.diff(<strong class="lb iu">4</strong>)</code>。这导致了<code class="fe mg mh mi lw b">temps</code>中 4 步差的时间序列。结果中的第个条目是<code class="fe mg mh mi lw b">temps[i]-temps[i-4]</code>。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="3f0e" class="ma mb it lw b gy mc md l me mf">nan nan nan nan 5.0 2.0 8.0 -1.0 8.0 0.0 5.0 -1.0 4.0 2.0 2.0 3.0 2.0</span></pre><p id="152f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好多了！趋势暴露了。</p><p id="d737" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们做<code class="fe mg mh mi lw b">temps.diff(4).mean()</code>，这导致了 3.0。这可以被解释为平均每 4 天气温升高 3 度。</p><p id="7aa5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看通过不同的计算得到了什么:<code class="fe mg mh mi lw b">temps.diff(10).mean()</code>给出了 7.85。请注意，3.0/4 大致等于 7.85/10。换句话说，两者都表明平均气温每天上升约 0.75 度。不错。</p><p id="a348" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">温度<em class="mj">上升的百分比</em>是多少？</strong></p><p id="f296" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们想知道<code class="fe mg mh mi lw b">temps</code>每天的平均<em class="mj">百分比</em>增长。熊猫里的<code class="fe mg mh mi lw b">shift</code>操作员会在这里帮忙。</p><p id="3c7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将逐步构建我们的解决方案，因为它有点复杂。让我们从<code class="fe mg mh mi lw b">temps.shift(4)</code>开始。这产生了一个版本的<code class="fe mg mh mi lw b">temps</code>，其中时间移动了 4 步。下面是原始版本和转换后的版本</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="e96d" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">Original</strong>: 60 65 62 68 65 67 70 67 73 67 75 66 77 69 77 69 79<br/><strong class="lw iu">Shifted</strong>: nan nan nan nan 60.0 65.0 62.0 68.0 65.0 67.0 70.0 67.0 73.0 67.0 75.0 66.0 77.0</span></pre><p id="6ae2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们选择移动 4 步，因为这 4 步的差异在之前对相同的数据进行了很好的计算。</p><p id="f85a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，注意<code class="fe mg mh mi lw b">temps — temps.shift(4)</code>相当于<code class="fe mg mh mi lw b">temps.diff(4)</code>。</p><p id="1646" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们最后的表达是</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="debd" class="ma mb it lw b gy mc md l me mf">100.0*(temps-temps.shift(4))/temps.shift(4)</span></pre><p id="6044" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将时间序列<code class="fe mg mh mi lw b">temps-temps.shift(4)</code>除以时间序列<code class="fe mg mh mi lw b">temps.shift(4)</code>得到分数变化的时间序列。(请注意，这种划分是针对组件的。)乘以 100.0 以百分比表示。</p><p id="163f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">消除温度波动</strong></p><p id="b9db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">均线是对时间序列的一种重要操作。它产生一个新的时间序列，其值是前一个时间序列中相邻值的平均值。这具有消除瞬时波动的效果。</p><p id="feb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">认为</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="9f1c" class="ma mb it lw b gy mc md l me mf">temps = pd.Series([60,65,62,68,65,67,70,67,73,67,75,66,77,69,77,69,79])<br/>temps_smoothed = temps.rolling(2).mean()</span></pre><p id="cccc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们先来看结果，在<code class="fe mg mh mi lw b">temps_smoothed</code>。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="b92c" class="ma mb it lw b gy mc md l me mf">nan 62.5 63.5 65.0 66.5 66.0 68.5 68.5 70.0 70.0 71.0 70.5 71.5 73.0 73.0 73.0 74.0</span></pre><p id="fe74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哇——这些绝对是平滑的！它们更生动地揭示了上升趋势。</p><p id="9d7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们来解释一下幕后发生了什么。告诉熊猫建造宽度为 2 的滚动窗户。<code class="fe mg mh mi lw b">mean()</code>然后计算窗口中的平均值。这个滚动过程产生平滑的时间序列。</p><p id="d52e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，窗口在右边，不居中。我们可以通过检查结果来推测这一点。注意<code class="fe mg mh mi lw b">temps_smoothed[1]</code>是 62.5，是<code class="fe mg mh mi lw b">temps[0]</code>的平均值，是 60，<code class="fe mg mh mi lw b">temps[1]</code>是 65。</p></div></div>    
</body>
</html>