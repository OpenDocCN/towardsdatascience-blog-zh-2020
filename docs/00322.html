<html>
<head>
<title>Achieving Stationarity With Time Series Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用时间序列数据实现平稳性</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/achieving-stationarity-with-time-series-data-abd59fd8d5a0?source=collection_archive---------10-----------------------#2020-01-10">https://towardsdatascience.com/achieving-stationarity-with-time-series-data-abd59fd8d5a0?source=collection_archive---------10-----------------------#2020-01-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/9d7192f23bac80aae472666c714d704c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xdblkZyg6YmmReAkZHUksw.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">平稳性原理的说明，来源:<a class="ae kf" href="https://beingdatum.com/time-series-forecasting/" rel="noopener ugc nofollow" target="_blank">是数据</a></p></figure><p id="12d1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">大多数时间序列模型都假设基本的<a class="ae kf" href="https://blogs.wsj.com/economics/2012/07/05/is-data-is-or-is-data-aint-a-plural/" rel="noopener ugc nofollow" target="_blank">数据是</a>稳定的，也就是说，均值、方差和协方差都不依赖于时间。您的时间序列很可能不是平稳的，这意味着您必须识别序列中的趋势，并操纵数据使其变得平稳。在趋势被移除之后，您可以应用高级建模技术，同时保持分离趋势的有价值的知识，这将在以后被使用。</p><p id="1921" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在过去的几周里，我已经讨论了一些时间序列主题，我将在这里建立这些主题，包括<a class="ae kf" rel="noopener" target="_blank" href="/ohlc-charts-with-python-libraries-c58c1ff080b0"> OHLC可视化</a>、<a class="ae kf" rel="noopener" target="_blank" href="/working-with-time-series-data-a8872ebcac3">时间序列数据EDA </a>和<a class="ae kf" href="https://medium.com/datadriveninvestor/time-series-and-trend-analysis-6a4f255f3d6e" rel="noopener">趋势分析</a>。</p><p id="af58" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在消除趋势方面，数据科学家有几个选择:数据转换、消除滚动统计和<a class="ae kf" href="https://machinelearningmastery.com/time-series-trends-in-python/" rel="noopener ugc nofollow" target="_blank">差异</a>。下面我将使用从下面的<a class="ae kf" href="https://unibit.ai/" rel="noopener ugc nofollow" target="_blank"> UniBit API </a>获得的历史标准普尔500指数价格数据来介绍这些方法。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div class="gh gi le"><img src="../Images/42593ee352ab12a9667629f25779dea7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*S-J5Xi7lhOL1B0E_HDnGrg.png"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">标准普尔500历史价格——由UniBit API提供</p></figure><h2 id="1d78" class="lj lk it bd ll lm ln dn lo lp lq dp lr kr ls lt lu kv lv lw lx kz ly lz ma mb bi translated">1)转型</h2><p id="c45e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我把我的价格数据组织在一个熊猫数据框架中。索引设置为日期列，日期按升序排序。我获得了截至2020年1月9日的一年OHLC价格。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/50214c117c2518933b6f1978a48a73de.png" data-original-src="https://miro.medium.com/v2/resize:fit:976/format:webp/1*s6A4N7sQ3hOKaUwQ1Hmh1g.png"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">按升序排列的标准普尔500数据帧的头部</p></figure><p id="439f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Python的<a class="ae kf" href="https://docs.scipy.org/doc/numpy/reference/routines.math.html" rel="noopener ugc nofollow" target="_blank"> NumPy库</a>中有几种可用的转换，包括对数、平方根等等。我为其中的一些转换创建了一个新列，方法是将它们应用于调整后的收盘价列。</p><figure class="lf lg lh li gt ju"><div class="bz fp l di"><div class="mi mj l"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">时间序列数据的NumPy转换示例，注意数据帧被称为“inx_df”</p></figure><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mk"><img src="../Images/fa48bc7da7731ebee86f87d6c4eef4ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SQ9J1ASpERvwmFZyMUGsIw.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">应用NumPy变换后的数据帧</p></figure><p id="0da0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">没有一种单一的转换方法能让所有的时间序列都变得平稳，你必须自己测试它们。对数变换的可视化如下。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ml"><img src="../Images/b03544b6d491a0db2f3e0028f9fc2010.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vIN3UHqX1MWGZRTXoeE3_A.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">调整后收盘价的标准普尔500对数变换</p></figure><p id="6496" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个特殊的转换没有完全实现这个系列的平稳性。价格的范围发生了巨大的变化，该系列的上升趋势已经减弱，这是一个良好的开端。对数函数是同底数的指数函数的<a class="ae kf" href="http://www.themathpage.com/aPreCalc/logarithmic-exponential-functions.htm" rel="noopener ugc nofollow" target="_blank">逆</a>。</p><h2 id="fb3b" class="lj lk it bd ll lm ln dn lo lp lq dp lr kr ls lt lu kv lv lw lx kz ly lz ma mb bi translated">2)滚动方式</h2><p id="e301" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">您可以从时间序列中减去滚动平均值。当平均值依赖于时间时，这种方法特别有效。A <a class="ae kf" href="https://machinelearningmastery.com/moving-average-smoothing-for-time-series-forecasting-python/" rel="noopener ugc nofollow" target="_blank">滚动平均值</a>是系列中先前<em class="mm"> x </em>次观察的平均值，其中每次观察之间的时间是一致的。您必须决定哪个时间窗口最适合您的数据。因为我使用的是每日交易数据，所以我选择了20天的窗口，因为这是一个月中有多少个交易日，尽管这不是金融数据的通用窗口。</p><p id="b8a4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Pandas的<code class="fe mn mo mp mq b">.rolling()</code>方法可以用来计算这个滚动平均值。例如，计算我的数据的20天滚动平均值的代码是:</p><p id="c2b8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mn mo mp mq b">inx_df[‘adj_close’].rolling(window = 20).mean()</code></p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mr"><img src="../Images/145bb76af184316385915b8f2b72915c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aseFip1EWhBS8kmGA3vaJA.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">标准普尔500和二十天滚动平均</p></figure><p id="93cb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我创建了一个从原始收盘价中减去滚动平均值的新数组，并将其绘制在下面，以查看这是否改善了序列的平稳性。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ms"><img src="../Images/66e032b29d5481dcd19087541cac9fe0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*esTaHGZmUqncSG1h7ydk2Q.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">从标准普尔500的调整收盘价中减去二十天滚动平均值</p></figure><p id="270c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这一系列似乎更接近平稳性。上升趋势实际上已经消失，但差异仍然明显。对于金融数据，从原始数据中移除<a class="ae kf" href="https://www.investopedia.com/ask/answers/071414/whats-difference-between-moving-average-and-weighted-moving-average.asp" rel="noopener ugc nofollow" target="_blank">加权滚动平均值</a>也是完全合理的。加权滚动平均值为最近的观测值分配更大的权重。在Python中，这是用<code class="fe mn mo mp mq b"><a class="ae kf" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.ewm.html" rel="noopener ugc nofollow" target="_blank">.ewm()</a></code> <a class="ae kf" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.ewm.html" rel="noopener ugc nofollow" target="_blank">方法</a>计算的，对于我的数据，代码如下:</p><p id="db87" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mn mo mp mq b">inx_df[‘adj_close’].ewm().mean()</code></p><p id="f295" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该方法中有几个参数可用于确定观察值的单个权重，包括com、跨度和半衰期。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mt"><img src="../Images/c11b7b5813026769f096c33214734d22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cFIBY51ixtn-_sxWhgekoQ.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">从标准普尔500调整收盘价中减去的指数滚动平均值。半衰期参数设置为2。</p></figure><h2 id="e1bc" class="lj lk it bd ll lm ln dn lo lp lq dp lr kr ls lt lu kv lv lw lx kz ly lz ma mb bi translated">3)差异</h2><p id="1bfa" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">另一种去除时间序列数据趋势的方法是差分法。这是用一个观察值减去另一个观察值的过程<em class="mm"> x </em>之前的周期数，其中<em class="mm"> x </em>是时间周期滞后。例如，在S &amp; P 500的例子中，如果滞后一年，那么2020年1月1日的差异值等于2020年1月1日观察到的实际价格减去2019年1月1日观察到的值。Pandas库的<code class="fe mn mo mp mq b">.diff(periods=<em class="mm">x</em>)</code>方法可以用来计算一组不同的值。周期参数表示使用的滞后。我的值以日为增量，这意味着滞后365等于一年，滞后1等于一天。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mt"><img src="../Images/4a5199b1faa4f2dc17ec1f1724a9aebb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qdVXTGM5e2SXd3g_-uUMOg.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">标准普尔500调整收盘价格差异，滞后一天</p></figure><p id="1314" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">差异也消除了时间序列的上升趋势，尽管方差仍然是时间相关的。</p><h1 id="a33b" class="mu lk it bd ll mv mw mx lo my mz na lr nb nc nd lu ne nf ng lx nh ni nj ma nk bi translated">摘要</h1><p id="b144" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">Python的NumPy和Pandas库有许多针对时间序列数据的转换和趋势分析方法。你必须用不同的参数尝试许多方法，看看什么能帮助你的序列最接近平稳性。一旦你应用了这些变换，你就可以应用像Dickey-Fuller这样的统计测试来比较你的结果。</p></div></div>    
</body>
</html>