<html>
<head>
<title>Building an application of question answering system from scratch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从零开始构建问答系统的应用程序</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-an-application-of-question-answering-system-from-scratch-2dfc53f760aa?source=collection_archive---------8-----------------------#2020-07-09">https://towardsdatascience.com/building-an-application-of-question-answering-system-from-scratch-2dfc53f760aa?source=collection_archive---------8-----------------------#2020-07-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="afa2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">初学者的循序渐进指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ecc201fcd505cb733d4df7b3da7f5ff4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-7ko6BD0O7a54Vra.jpg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">阿尔弗莱德·西斯莱/公共领域来自<a class="ae ky" href="https://commons.wikimedia.org/wiki/File:Allee_de_chataigniers_-_Alfred_Sisley.jpg" rel="noopener ugc nofollow" target="_blank">维基媒体</a></p></figure><p id="02c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">问答(QA) </strong>系统是对用英语、汉语等自然语言表达的问题给出适当答案的系统。例如，假设一个用户问“亚伯拉罕·林肯什么时候被暗杀的？”在这种情况下，问答系统预计返回“1865 年 4 月 15 日”。下面是一个问答配对的例子。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/5ffb1a49f1bc8d9a9b96e18dbc142af4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DNPX4CtISPmQ-yeNQSbdrQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自<a class="ae ky" href="https://web.stanford.edu/~jurafsky/slp3/" rel="noopener ugc nofollow" target="_blank">演讲和语言处理</a>第 25 章的问答配对示例。</p></figure><p id="eae8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个问题回答系统将帮助你有效地找到信息。一般来说，当我们在网上寻找一些信息时，我们会使用搜索引擎来搜索相关的文档。但是，因为它们向您显示文档，所以您必须阅读文档并确定它们是否包含您需要的信息。真麻烦。因此，商业搜索引擎有一个问题回答功能，让你可以有效地找到信息。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/14aea5bb7b96cb3ebac3683457e154ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*zeIcuAtNWQBwxkGQxIFEPw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">必应搜索问答。</p></figure><p id="5954" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">问答系统有多种模式，但主要使用两种模式:基于知识的和基于信息检索的问答系统。人类在回答一个问题时，首先尝试用自己的知识来回答问题。如果他们不能回答这个问题，他们就在网上或书中寻找答案。问答系统类似于人类。前者对应于基于知识的系统，后者对应于基于信息检索的系统。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/44fb3e800d0f818cd7f14df7e312e88a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/format:webp/1*PkN2VvQg-N5EtUnt-mhbJw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">两种质量保证系统。</p></figure><p id="2832" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本帖中，我们将构建一个基于信息检索的问答系统。首先，我们将问题转换成搜索查询。接下来，我们使用 MediaWiki API 来获取文档。最后，我们使用预先训练的 BERT 从文档中提取答案。整个系统可以分为四个部分:问题处理、文档检索、段落检索和答案抽取。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ly"><img src="../Images/f4197a8880c07085f523bf518db2118e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0GuDd4P7CaxlSl4N5sTEFw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">基于 IR 的问答系统架构来自<a class="ae ky" href="https://web.stanford.edu/~jurafsky/slp3/" rel="noopener ugc nofollow" target="_blank">语音和语言处理</a>第 25 章。</p></figure><p id="3a5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我只展示了重要的部分，但是整个系统可以在下面的 GitHub 库中找到。代码很小，很容易理解。请看一看:</p><ul class=""><li id="a251" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated"><a class="ae ky" href="https://github.com/Hironsan/WikipediaQA" rel="noopener ugc nofollow" target="_blank">https://github.com/Hironsan/WikipediaQA</a></li></ul><p id="9a57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该员额的其余部分组织如下:</p><ol class=""><li id="ac96" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu mi mf mg mh bi translated">询问处理</li><li id="59e8" class="lz ma it lb b lc mj lf mk li ml lm mm lq mn lu mi mf mg mh bi translated">文档检索</li><li id="c1a1" class="lz ma it lb b lc mj lf mk li ml lm mm lq mn lu mi mf mg mh bi translated">段落检索</li><li id="ed34" class="lz ma it lb b lc mj lf mk li ml lm mm lq mn lu mi mf mg mh bi translated">答案抽取</li></ol><h1 id="0211" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">步骤 1:查询处理</h1><p id="8b96" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">问题处理将问题转换成搜索查询。通常会删除停用词和具有特定词性的词。此外，随着深度学习技术最近的发展，创建可以很好地表达句子意思的向量已经成为可能，因此还使用了将问题转换为向量并将其用作查询的方法。</p><p id="ff09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一次，我们将使用 spaCy 生成一个搜索查询。首先，对问题进行解析，并标注词性标签。接下来，我们根据词类标签删除单词。具体来说，除专有名词(PROPN)、数字(NUM)、动词(VERB)、名词(NOUN)和形容词(ADJ)之外的单词将被删除。比如问题“亚马逊的创始人是谁？”生成查询“创始人亚马逊”。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/edea55537215515f206eabc27fbd8457.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LLMlnTKD9gKNTjAjBFcq7g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">查询处理的一个例子。</p></figure><p id="74e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请看看 QueryProcessor 类:</p><ul class=""><li id="7369" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated"><a class="ae ky" href="https://github.com/Hironsan/WikipediaQA/blob/2c296107ca9e62acafc08c0a890912a68458b1bb/src/components.py#L12-L21" rel="noopener ugc nofollow" target="_blank">查询处理器</a></li></ul><h1 id="ca72" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">步骤 2:文档检索</h1><p id="e4f7" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">在文档检索中，我们将使用生成的查询来检索相关的文档。在后续的处理中，由于会从这些文档中提取答案，所以需要尽可能地搜索可能包含答案的文档。与问题处理类似，深度学习技术允许我们将文档转换为向量[1]。</p><p id="aba1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一次，我们将搜索维基百科。维基百科提供了一个叫做<a class="ae ky" href="https://www.mediawiki.org/wiki/API:Main_page" rel="noopener ugc nofollow" target="_blank"> MediaWiki API </a>的 API。我们可以使用 API 来搜索与查询相关的文档。这里的过程包括两个步骤。首先，我们发送一个查询来获取相关页面的列表。然后我们获取各个页面的内容。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/e35c8b23accbef4f658dd99a57fec1ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:562/format:webp/1*PnkbzNTpNGArN2yqKfwhcw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">文献检索流程。</p></figure><p id="07a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请看看 DocumentRetrieval 类:</p><ul class=""><li id="19ed" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated"><a class="ae ky" href="https://github.com/Hironsan/WikipediaQA/blob/2c296107ca9e62acafc08c0a890912a68458b1bb/src/components.py#L24-L67" rel="noopener ugc nofollow" target="_blank">文档检索</a></li></ul><h1 id="1951" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">第三步:段落检索</h1><p id="2cfa" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">在段落检索中，文档被分成更小的单元(段落)，例如句子和段落，并且选择可能包含答案的段落。如果文档很短，这是不必要的，但是如果文档很长，段落选择是有效的，因为我们不知道查询匹配了文档的哪一部分。通常，后续的答案抽取过程需要很长时间才能完成，因此选择段落还有加快整个系统速度的好处。</p><p id="449a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一次，我们将选择与问题相似的段落。为了计算相似性，我们使用 BM25 来创建问题和段落的向量。一旦我们创建了向量，我们就可以使用点积和余弦相似度来计算问题和文章之间的相似度。因为 BM25 功能强大，所以经常被用作段落检索的基线。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/e49f19b8d0d5dc0d2c1a6b075da01e24.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/format:webp/1*ukW4K0jAVB2HAwaBJ3N9fQ.png"/></div></figure><p id="56da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请看看 PassageRetrieval 类:</p><ul class=""><li id="5b2c" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated"><a class="ae ky" href="https://github.com/Hironsan/WikipediaQA/blob/2c296107ca9e62acafc08c0a890912a68458b1bb/src/components.py#L70-L93" rel="noopener ugc nofollow" target="_blank">通行里程</a></li></ul><h1 id="e50f" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">步骤 4:答案抽取</h1><p id="90ea" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">答案提取从段落中提取答案。这里，问题和段落被输入到答案提取模型，并且模型输出带有分数的答案偏移。然后，它根据分数对答案进行排序，并将分数最高的答案作为最终答案呈现给用户。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/a3b4fbf00d11359c722ebe2960253626.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T5w_ve0rBOmleqtbl6r7Hg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">从文本中提取答案。在这种情况下，对于“流域内有多少平方公里的雨林被转化？”，模型将返回“5，500，000”作为答案。来自<a class="ae ky" href="https://rajpurkar.github.io/SQuAD-explorer/explore/v2.0/dev/" rel="noopener ugc nofollow" target="_blank">小队 2.0 </a>。</p></figure><p id="587d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一次，我们将答案抽取公式化为上下文感知问答，并使用 BERT 进行求解。通过将问题和文章输入到 BERT 中，我们可以得到答案的偏移量。已知 BERT 可以很好地解决答案抽取，在 SQuAD 数据集上表现优于人类[2][3]。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/e83ae9994e56a361ab00768cb6d09584.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6lDnHXHU5NMscvuGB-HWiw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">鸣谢:<a class="ae ky" href="https://arxiv.org/pdf/1810.04805.pdf" rel="noopener ugc nofollow" target="_blank">伯特:语言理解深度双向变压器前期训练</a></p></figure><p id="c95b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请看看 AnswerExtraction 类:</p><ul class=""><li id="b591" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated"><a class="ae ky" href="https://github.com/Hironsan/WikipediaQA/blob/2c296107ca9e62acafc08c0a890912a68458b1bb/src/components.py#L96-L113" rel="noopener ugc nofollow" target="_blank">答案提取</a></li></ul><p id="9145" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一下应用程序。以下是一个问题回答的例子。当“谁是亚马逊的创始人？”发布后，应用程序将问题转换为查询，通过 MediaWiki API 检索文档，选择段落并从中提取答案。因此，应用程序返回“杰夫·贝索斯”作为首选答案:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/a53cd43bdd83a518e6f9834e2f1bc7f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*EkrMrYBGO5yijKyXS0xTMw.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">GitHub 存储库中可用的示例应用程序。</p></figure><h1 id="3b3a" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">为了进一步改进</h1><p id="68a9" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">作为进一步改进的第一步，有一种方法可以通过以更复杂的方式嵌入问题和文档来提高文档检索性能。众所周知，使用 BERT 或通用语句编码器而不是使用 BM25[1][4][5]对它们进行矢量化可以提高性能。</p><p id="0262" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还提出了一种方法，其中信息检索和答案提取被联合训练[6]。这次分别进行信息检索和答案抽取。因为信息检索不同于问题回答，所以系统是局部优化的。通过同时训练信息检索和答案抽取，系统可以得到很好的优化。</p><p id="d14b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，你可以使用更好的答案抽取模型。根据<a class="ae ky" href="https://rajpurkar.github.io/SQuAD-explorer/" rel="noopener ugc nofollow" target="_blank">小队 2.0 排行榜</a>显示，有几款比 BERT 性能更好。比如艾伯特[7]，伊莱克特拉[8]，罗伯塔[9]，XLNet[10]等等。你可以很容易地使用这些模型，因为 Huggingface transformers 支持它们。更多细节见<a class="ae ky" href="https://huggingface.co/transformers/index.html" rel="noopener ugc nofollow" target="_blank">变压器文档</a>。</p><p id="71bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">GitHub 资源库:</p><ul class=""><li id="c088" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated">【https://github.com/Hironsan/WikipediaQA T4】</li></ul><h1 id="3338" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">参考</h1><ol class=""><li id="60f0" class="lz ma it lb b lc ng lf nh li nr lm ns lq nt lu mi mf mg mh bi translated"><a class="ae ky" href="https://arxiv.org/abs/1905.01758" rel="noopener ugc nofollow" target="_blank">为段落重新排序调查 BERT 的成功与失败</a></li><li id="f291" class="lz ma it lb b lc mj lf mk li ml lm mm lq mn lu mi mf mg mh bi translated"><a class="ae ky" href="https://www.aclweb.org/anthology/N19-1423/" rel="noopener ugc nofollow" target="_blank"> BERT:用于语言理解的深度双向转换器的预训练</a></li><li id="4263" class="lz ma it lb b lc mj lf mk li ml lm mm lq mn lu mi mf mg mh bi translated"><a class="ae ky" href="https://www.aclweb.org/anthology/D16-1264/" rel="noopener ugc nofollow" target="_blank">小队:100，000+用于文本机器理解的问题</a></li><li id="beb0" class="lz ma it lb b lc mj lf mk li ml lm mm lq mn lu mi mf mg mh bi translated"><a class="ae ky" href="https://arxiv.org/abs/2004.04906" rel="noopener ugc nofollow" target="_blank">面向开放领域问答的密集段落检索</a></li><li id="fddf" class="lz ma it lb b lc mj lf mk li ml lm mm lq mn lu mi mf mg mh bi translated"><a class="ae ky" href="https://arxiv.org/abs/1907.04780" rel="noopener ugc nofollow" target="_blank"> ReQA:对端到端答案检索模型的评估</a></li><li id="97d3" class="lz ma it lb b lc mj lf mk li ml lm mm lq mn lu mi mf mg mh bi translated"><a class="ae ky" href="https://www.aclweb.org/anthology/P19-1612/" rel="noopener ugc nofollow" target="_blank">弱监督开放领域问答的潜在检索</a></li><li id="7f62" class="lz ma it lb b lc mj lf mk li ml lm mm lq mn lu mi mf mg mh bi translated"><a class="ae ky" href="https://arxiv.org/abs/1909.11942" rel="noopener ugc nofollow" target="_blank"> ALBERT:一个用于语言表达自我监督学习的 Lite BERT</a></li><li id="1fa3" class="lz ma it lb b lc mj lf mk li ml lm mm lq mn lu mi mf mg mh bi translated"><a class="ae ky" href="https://arxiv.org/abs/2003.10555" rel="noopener ugc nofollow" target="_blank"> ELECTRA:将文本编码器预先训练成鉴别器而不是生成器</a></li><li id="4b05" class="lz ma it lb b lc mj lf mk li ml lm mm lq mn lu mi mf mg mh bi translated"><a class="ae ky" href="https://arxiv.org/abs/1907.11692" rel="noopener ugc nofollow" target="_blank"> RoBERTa:一种稳健优化的 BERT 预训练方法</a></li><li id="b9f8" class="lz ma it lb b lc mj lf mk li ml lm mm lq mn lu mi mf mg mh bi translated"><a class="ae ky" href="https://arxiv.org/abs/1906.08237" rel="noopener ugc nofollow" target="_blank"> XLNet:用于语言理解的广义自回归预训练</a></li></ol></div></div>    
</body>
</html>