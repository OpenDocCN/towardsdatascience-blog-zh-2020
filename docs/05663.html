<html>
<head>
<title>Comparative Performance of Deep Learning Optimization Algorithms Using Numpy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Numpy 的深度学习优化算法的性能比较</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/comparative-performance-of-deep-learning-optimization-algorithms-using-numpy-24ce25c2f5e2?source=collection_archive---------46-----------------------#2020-05-11">https://towardsdatascience.com/comparative-performance-of-deep-learning-optimization-algorithms-using-numpy-24ce25c2f5e2?source=collection_archive---------46-----------------------#2020-05-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="313f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我们将通过计算二次凸函数的最优点，从数值上比较主要深度学习优化算法的性能。</p><h1 id="fc29" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated"><strong class="ak">简介:</strong></h1><p id="bed2" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">深度学习被称为人工智能的未来。如今，神经网络被称为通用函数逼近器，即它们有能力表示这个宇宙中的任何复杂函数。计算这个具有数百万个参数的通用函数背后的想法来自优化的基础数学。优化可以通过多种方式完成，但对于本文，我们将重点关注基于梯度下降的优化技术。</p><p id="2c21" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">非凸函数的优化是主要的研究领域。多年来，不同的科学家提出了不同的优化算法来优化神经网络的成本函数。这些算法中的大多数都是基于基于梯度的方法，只是稍加修改。在这篇文章中，我们将讨论五个主要的基于下降的算法-梯度下降，动量，Adagrad，RMSprop，Adam。</p><h1 id="e373" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated"><strong class="ak">进场- </strong></h1><p id="765f" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">为了了解每个算法在实际中是如何工作的，我们将使用一个凸二次函数。我们将每种算法运行固定的迭代次数(20 次),以比较它们在达到最佳点时的收敛速度和轨迹。下面给出了该任务所选函数的方程，以及使用 Matplotlib 绘制的该函数的三维图形和水平集。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/c2554d5a1233ed542391364b7d056a10.png" data-original-src="https://miro.medium.com/v2/resize:fit:574/format:webp/1*0zbSQbYrRQnww2IORwPmIA.png"/></div><p class="lz ma gj gh gi mb mc bd b be z dk translated"><strong class="bd md">函数方程</strong></p></figure><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi me"><img src="../Images/f636485d0523efc89f9329d7d9e4d6de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ipvi55_Hxh4jq6ZxY6jBqg.jpeg"/></div></div><p class="lz ma gj gh gi mb mc bd b be z dk translated"><strong class="bd md">功能的 3D 图</strong></p></figure><figure class="ls lt lu lv gt lw"><div class="bz fp l di"><div class="mj mk l"/></div><p class="lz ma gj gh gi mb mc bd b be z dk translated"><strong class="ak">3D 绘图的数字实现</strong></p></figure><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi ml"><img src="../Images/7f5f6d44141740c63be0c7d4cafb8034.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AIMD7iuPd1FO-HCnXawHOg.png"/></div></div><p class="lz ma gj gh gi mb mc bd b be z dk translated"><strong class="bd md">二次函数的水平集</strong></p></figure><p id="0696" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最初，我们将从最基本的算法梯度下降开始，然后我们将跟随他们发展的趋势，以支持每个算法发展背后的思想。所以趋势会是这样的-</p><p id="910e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">1-梯度下降</strong></p><p id="92f8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">2-动量</strong></p><p id="1bb4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">3-阿达格勒</strong></p><p id="1b38" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> 4-RMSprop </strong></p><p id="5bd2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">5-亚当</p><p id="ff3d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为所有这些算法在更新规则的每次迭代中都需要梯度。因此，下面给出了函数的梯度，它将用于在每次迭代中更新两个变量。对于所有算法，我们将使用学习率的固定值=0.4。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi mm"><img src="../Images/e8b6f1354d9a863564ca264277356b0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:636/format:webp/1*f7UJGmwhlAIE-NdoZM-LwA.png"/></div></div><p class="lz ma gj gh gi mb mc bd b be z dk translated"><strong class="bd md">渐变矢量</strong></p></figure><h1 id="fd59" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated"><strong class="ak">1-梯度下降:</strong></h1><p id="f2cb" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">梯度下降是寻找最优解的最传统的技术。在该算法中，使用当前梯度(gt)乘以某个称为学习率的因子来更新当前权重，<em class="mn"> α。</em>更新规则的等式如下所示。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/81f280d05b04ed54eaef0f2c54f1ca58.png" data-original-src="https://miro.medium.com/v2/resize:fit:538/format:webp/1*47Sv8n8F3D9urfSeoFYkdQ.png"/></div><p class="lz ma gj gh gi mb mc bd b be z dk translated"><strong class="bd md">更新梯度下降规则</strong></p></figure><figure class="ls lt lu lv gt lw"><div class="bz fp l di"><div class="mj mk l"/></div><p class="lz ma gj gh gi mb mc bd b be z dk translated">梯度下降的数值实现</p></figure><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi mp"><img src="../Images/93b7cc501a06be015da7e9c9d0c7d70c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OaTk2RG_x79pU9xMLTWQtA.png"/></div></div><p class="lz ma gj gh gi mb mc bd b be z dk translated"><strong class="bd md">轨迹使用梯度下降</strong></p></figure><figure class="ls lt lu lv gt lw"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="2f34" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如我们在上面的图中看到的，梯度下降经历了许多振荡，收敛非常缓慢。因此，在后面的部分，我们将研究梯度下降的修改，帮助我们实现稳定和更快的收敛。</p><h1 id="596b" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated"><strong class="ak">2-势头:</strong></h1><p id="aa13" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">带动量的梯度下降是一种非常常用的优化器，它消除了由标准梯度下降引起的振荡，并加速了收敛到最佳点。当它加速水平方向时，它减慢垂直方向。在这种杰出行为的帮助下，它使我们在学习率方向上迈出了一大步。除此之外，动量比标准梯度下降稳定得多。</p><p id="e0f0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它不是在当前时间步长计算梯度，而是通过参数动量更新权重，动量是当前和过去梯度的指数移动平均值的集合。下面给出的等式解释了更新规则</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/90822795857feea7efa65edcd9f2e774.png" data-original-src="https://miro.medium.com/v2/resize:fit:846/format:webp/1*GQXthVxpSIUBAodE5hzUIQ.png"/></div><p class="lz ma gj gh gi mb mc bd b be z dk translated">动量更新规则</p></figure><figure class="ls lt lu lv gt lw"><div class="bz fp l di"><div class="mj mk l"/></div><p class="lz ma gj gh gi mb mc bd b be z dk translated"><strong class="ak"> Numpy 实现的动量</strong></p></figure><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi mr"><img src="../Images/54485b15b5872796a2b989bf36e721c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1wZ7F8KSlcBL15a-0dCkqw.png"/></div></div><p class="lz ma gj gh gi mb mc bd b be z dk translated"><strong class="bd md">梯度下降 vs 动量</strong></p></figure><figure class="ls lt lu lv gt lw"><div class="bz fp l di"><div class="mj mk l"/></div></figure><h1 id="76d3" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated"><strong class="ak">3-阿达格拉德</strong></h1><p id="6aef" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">自适应梯度下降算法是一种学习梯度下降算法。它的主要区别是 Adagrad 根据网络中参数的重要性对每个权重使用不同的学习率。换句话说，当不必要的参数以较高的学习率训练时，重要的参数以较小的学习率训练以更稳定地收敛。这导致在不允许失真的情况下加速算法。更新公式类似于动量公式，这里每一步的动量都是用先前的动量和梯度的平方来计算的。下面的等式显示了 Adagrad 中的更新规则。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/5bd0e3be1b82b34aa5479080da36ee54.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/1*MSh27XmaN8617enBdGpEzw.png"/></div></figure><p id="c1fc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，Gt 是由过去梯度的平方和组成的对角矩阵，<strong class="js iu"> ϵ是</strong>平滑项。此外,⊙表示矩阵-矢量积运算。</p><figure class="ls lt lu lv gt lw"><div class="bz fp l di"><div class="mj mk l"/></div><p class="lz ma gj gh gi mb mc bd b be z dk translated"><strong class="ak">Adagrad 的 Numpy 实现</strong></p></figure><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi mr"><img src="../Images/bbb7bc80fd66b26ad11dedcc077670f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xJtbL7-MaaqtYTGoC2iOLQ.png"/></div></div><p class="lz ma gj gh gi mb mc bd b be z dk translated"><strong class="bd md">动量 vs 阿达格拉德</strong></p></figure><figure class="ls lt lu lv gt lw"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="603d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从上图可以看出，虽然阿达格拉德呈现出平滑的运动，没有振荡，但是收敛能力不足。为了解决这个问题，Geoffrey Hinton 引入了一个更有效的优化器 RMSprop。</p><h1 id="1c4a" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated"><strong class="ak"> 4-RMSprop </strong></h1><p id="661e" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">Rmsprop 是由著名计算机科学家 Geoffrey Hinton ( <a class="ae mt" href="http://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf" rel="noopener ugc nofollow" target="_blank"> Hinton et al .，2012 </a>)提出的另一种高效优化算法。这种算法的工作原理与 Adagrad 相似，只是稍加修改。我们采用这些梯度的指数移动平均值，而不是像 AdaGrad 那样采用梯度平方的累积和。使用指数平均的原因是，较新的梯度更新比不太新的梯度更新更重要。下面的等式显示了 Rmsprop 的更新规则。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/7466910633cdb0b94820ba5229c093b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:770/format:webp/1*A0zncMDwtkNe_jRfXBhUrw.png"/></div></figure><figure class="ls lt lu lv gt lw"><div class="bz fp l di"><div class="mj mk l"/></div><p class="lz ma gj gh gi mb mc bd b be z dk translated">RMSprop 的 Numpy 实现</p></figure><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi mr"><img src="../Images/f7874ea4951e841bf187bbb6802a1229.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yYVgIgzcSrfMAqf0SzFImQ.png"/></div></div><p class="lz ma gj gh gi mb mc bd b be z dk translated"><strong class="bd md">动量 vs 阿达格拉德 vs RMSprop </strong></p></figure><figure class="ls lt lu lv gt lw"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="7fb2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">可以明显看出，当向最优点收敛时，梯度下降算法在垂直方向上产生巨大的振荡，RMSprop 限制垂直方向的运动并加速水平方向的运动。此外，尽管动量减少了振荡，RMSprop 提供了更可靠和更快的收敛。</p><h1 id="9e0d" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated"><strong class="ak">5-亚当</strong></h1><p id="91b1" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">自适应矩估计是为每个参数计算自适应学习率的另一种类型的优化器。与其他优化器相比，它表现得更加鲁棒和可靠，因为它基本上结合了动量和 RMSprop(即，类似梯度的动量的移动平均和使用平方梯度来调整类似 RMSprop 的学习速率)。更准确地说，Adam 算法执行如下</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/00a5c8e913dda2306ce244f708ca8c54.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/format:webp/1*0QdunvPUOAtp-n85i5eNrw.png"/></div></figure><figure class="ls lt lu lv gt lw"><div class="bz fp l di"><div class="mj mk l"/></div><p class="lz ma gj gh gi mb mc bd b be z dk translated">Adam 的 Numpy 实现</p></figure><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi mw"><img src="../Images/2b983990fc3f4b7ed23db178e2bd909f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CLyHQy_wrnSWzWyS7BDnqA.png"/></div></div><p class="lz ma gj gh gi mb mc bd b be z dk translated"><strong class="bd md">动量 vs Adagrad vs RMSprop 和 Adam 收敛期间的轨迹</strong></p></figure><figure class="ls lt lu lv gt lw"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="12b2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如最后一幅图所示，Adam 优化器在直线路径上实现了最快的收敛。对于 Adam，它通过累加之前梯度的总和来抑制振荡，并且由于与 RMSprop 类似的平方梯度项，它遵循一条直线。这导致了一个明显的结论，即 Adam 是 momentum 和 RMSprop 的组合版本。从上图我们不难看出，为什么 Adam 是深度学习中最受欢迎的优化器。即使从远离最优(-6，-6)的点开始，Adam 也能以最少的迭代收敛得最快。</p><p id="ce8c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如需了解详情，请访问—<a class="ae mt" href="https://github.com/Saket-Uoft/Deep-Learning-Optimizers" rel="noopener ugc nofollow" target="_blank">https://github.com/Saket-Uoft/Deep-Learning-Optimizers</a></p><p id="3447" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">感谢阅读！</strong></p><p id="5454" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你喜欢我的工作，想支持我。支持我的最好方式是在<strong class="js iu">媒体上关注我。</strong></p><h2 id="3a91" class="mx kp it bd kq my mz dn ku na nb dp ky kb nc nd lc kf ne nf lg kj ng nh lk ni bi translated">参考资料:</h2><p id="7bb3" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated"><a class="ae mt" href="https://medium.com/@sdoshi579/optimizers-for-training-neural-network-59450d71caf6" rel="noopener">https://medium . com/@ sdoshi 579/optimizer-for-training-neural-network-59450d 71 caf 6</a></p></div></div>    
</body>
</html>