<html>
<head>
<title>Semantic Segmentation using a Django API — DeepLabV3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Django API——DeepLabV3 进行语义分割</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/semantic-segmentation-using-a-django-api-deeplabv3-7b7904ddfed9?source=collection_archive---------53-----------------------#2020-08-31">https://towardsdatascience.com/semantic-segmentation-using-a-django-api-deeplabv3-7b7904ddfed9?source=collection_archive---------53-----------------------#2020-08-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="dccf" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">构建一个 Django API，使用语义分段执行后台定制</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/684db36353a33d79662160e23f774cf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wx3Mnw2T5LzZ6H7FYeYKyA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Sole D'Alessandro G. 在<a class="ae ky" href="https://unsplash.com/@s___d___g?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的原始照片</p></figure><h1 id="0c90" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="3de2" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">图像分割一直是热门话题。涉及分割的各种用例出现在许多不同的领域，机器视觉、医学成像、物体检测、识别任务、交通控制系统、视频监控等等。这些智能系统背后的直觉是捕捉形成图像的各种组件，从而教会计算机视觉模型掌握更多洞察力，更好地理解场景和背景。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mn"><img src="../Images/469ec3a6a4d1ba55a579d3caed1e99ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ViCkHTMOGfzdShSWrm-J5A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">左边是<a class="ae ky" href="https://unsplash.com/@melodyjacob1?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Melody Jacob </a>在<a class="ae ky" href="https://unsplash.com/@melodyjacob1?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的原图，右边是分段版</p></figure><p id="ceab" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">常用的两种图像分割类型是:</p><ul class=""><li id="131c" class="mt mu it lt b lu mo lx mp ma mv me mw mi mx mm my mz na nb bi translated"><strong class="lt iu">语义分割</strong>:识别图像中的不同类别，并<em class="nc">相应地分割</em></li><li id="1963" class="mt mu it lt b lu nd lx ne ma nf me ng mi nh mm my mz na nb bi translated"><strong class="lt iu">实例分割</strong>:预先确定图像中的不同类别，识别每个类别包含的实例数量。图像被分解成与模型被训练的不同类实例相关的多个标记区域。</li></ul></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><p id="52bb" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">在本文中，我将使用 Google DeepLab V3 分割模型的 Pytorch 实现来自定义图像的背景。其目的是分割前景，并将其与其余部分分离，同时用一幅完全不同的图片替换剩余的背景。该模型将通过 Django REST API 提供服务。</p><h2 id="e130" class="np la it bd lb nq nr dn lf ns nt dp lj ma nu nv ll me nw nx ln mi ny nz lp oa bi translated">概观</h2><ol class=""><li id="23c9" class="mt mu it lt b lu lv lx ly ma ob me oc mi od mm oe mz na nb bi translated">DeepLab V3 的一点背景知识</li><li id="8080" class="mt mu it lt b lu nd lx ne ma nf me ng mi nh mm oe mz na nb bi translated">使用 Pytorch 的 DeepLab V3-Resnet101 实现</li><li id="b32a" class="mt mu it lt b lu nd lx ne ma nf me ng mi nh mm oe mz na nb bi translated">设置 Django API</li><li id="b3a7" class="mt mu it lt b lu nd lx ne ma nf me ng mi nh mm oe mz na nb bi translated">结论</li></ol><p id="7322" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">你可以在我的 Gihut repo 下查看这个项目的全部代码。</p><div class="of og gp gr oh oi"><a href="https://github.com/aymanehachcham/Background-Customization" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">aymanehachham/背景-定制</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">在 GitHub 上创建一个帐户，为 aymanehachham/后台定制开发做贡献。</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">github.com</p></div></div><div class="or l"><div class="os l ot ou ov or ow ks oi"/></div></div></a></div></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="cc19" class="kz la it bd lb lc ox le lf lg oy li lj jz oz ka ll kc pa kd ln kf pb kg lp lq bi translated">1.DeepLab V3 的一点背景知识</h1><p id="64ed" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">分割模型使用完全卷积神经网络<strong class="lt iu"> FCNN </strong>在之前的图像检测阶段，将遮罩和边界放置到位，然后通过深度极大的网络处理输入，在该网络中，累积的卷积和汇集会导致图像的分辨率和质量显著降低，因此产生的结果会损失大量信息。DeepLab 模型利用阿特鲁卷积和阿特鲁空间金字塔池(ASPP)架构解决了这一挑战。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/9675137ba91c75ae3ebcd9fe4a9ff112.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CYS5EAJKKLHOnumZG11KzA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">不同分割模型之间的差异和比较，鸣谢:Francisco Massa，<a class="ae ky" href="https://pytorch.org/blog/torchvision03/" rel="noopener ugc nofollow" target="_blank"> Torchvision 0.3:分割、检测模型、新数据集等</a></p></figure><p id="6a0d" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">在 DeepLab 架构的正向流程中涉及四个主要阶段:</p><ul class=""><li id="71b1" class="mt mu it lt b lu mo lx mp ma mv me mw mi mx mm my mz na nb bi translated">用主干模型提取图像特征。我们案例中使用的主干是 Resnet 101 对象检测模型，作为第一个卷积管道来捕捉和屏蔽重要的特征图。</li><li id="c3e1" class="mt mu it lt b lu nd lx ne ma nf me ng mi nh mm my mz na nb bi translated">为了控制输出特征图的大小，在主干的最后几层中使用阿特鲁卷积。</li><li id="5a67" class="mt mu it lt b lu nd lx ne ma nf me ng mi nh mm my mz na nb bi translated">在最后阶段，ASPP 架构对输出图像的不同像素进行分类，并通过 1 x 1 卷积层进行处理，以恢复其原始大小。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/d3f5c3ee718a96d8e394d489c0889b37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6yDxlM5lCaD3RyzcRICNUQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">具有 atrous 卷积(ASPP)的并行模块，增强了图像级特征，信用:<a class="ae ky" href="https://arxiv.org/pdf/1706.05587.pdf" rel="noopener ugc nofollow" target="_blank"> <strong class="bd pe">重新思考用于语义图像分割的阿特鲁卷积</strong> </a></p></figure><h1 id="eba3" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">2.使用 Pytorch 的 DeepLab V3-Resnet101 实现</h1><p id="891a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">让我们通过创建一个包装原始 DeepLab V3 模型的 Pytorch 模块来开始这个过程。最初，Pytorch 团队已经提出了他们在 COCO 数据集上预先训练的 Google DeepLab V3 架构的实现，以及可供选择的各种主干。对于我们的特定任务，我们将使用可从<code class="fe pf pg ph pi b">torchvision.models.segmentation</code> API 包轻松加载的 deeplabv3-resnet101 预训练模块。</p><h2 id="86e6" class="np la it bd lb nq nr dn lf ns nt dp lj ma nu nv ll me nw nx ln mi ny nz lp oa bi translated">创建您的 python 虚拟环境</h2><p id="ffb9" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">使用<code class="fe pf pg ph pi b">pip virtualenv</code>设置您的 python 虚拟环境，并安装所有需要的包:</p><p id="02a7" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated"><strong class="lt iu">我</strong>。指定 python 虚拟环境的路径:</p><p id="a97d" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated"><code class="fe pf pg ph pi b">virtualenv absolute/path/to/virtual/env/pytorch-en</code></p><p id="a071" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated"><strong class="lt iu">二。</strong>激活您的虚拟环境:</p><p id="71ad" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated"><code class="fe pf pg ph pi b">source /absolute/path/pytorch-env/bin/activate</code></p><p id="558e" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated"><strong class="lt iu">三。</strong>安装所需的库:</p><p id="aeff" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated"><code class="fe pf pg ph pi b">pip install torch torchvision</code></p><p id="dc23" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated"><code class="fe pf pg ph pi b">pip install opencv-python</code></p><p id="000b" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated"><code class="fe pf pg ph pi b">pip install numpy</code></p><p id="7f6b" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated"><code class="fe pf pg ph pi b">pip install Pillow=2.2.1</code></p><h2 id="1771" class="np la it bd lb nq nr dn lf ns nt dp lj ma nu nv ll me nw nx ln mi ny nz lp oa bi translated">实现数据集示例</h2><p id="25b6" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在编写 Pytorch 包装器之前，您需要定义一个 Pytorch 数据集类，用多种方法将输入图像文件采样到一个高级对象中。这样，模型将处理被采样的对象，而不是转换和处理所有相关的文件。</p><p id="da37" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated"><code class="fe pf pg ph pi b">def __init__(self, root_dir, image_file, device)</code>init 方法负责将图像文件转换为<code class="fe pf pg ph pi b">Pillow</code>图像对象，然后转换为 torch 张量，在内部定义一组预处理规则，将初始张量转换为更适合 deeplabv3 模型的输入。目的是生成一个形状良好的张量，以避免图像文件和模型之间任何令人讨厌的不匹配。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pj pk l"/></div></figure><h2 id="8374" class="np la it bd lb nq nr dn lf ns nt dp lj ma nu nv ll me nw nx ln mi ny nz lp oa bi translated">为 DeepLab V3 推理创建 Pytorch 包装器模块</h2><p id="146e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><code class="fe pf pg ph pi b">SemanticSeg(nn.Module)</code>包装器模块有三个主要方法:</p><ul class=""><li id="e149" class="mt mu it lt b lu mo lx mp ma mv me mw mi mx mm my mz na nb bi translated"><code class="fe pf pg ph pi b">def __init__(self, pretrained, device)</code>用预训练值初始化加载一个已经训练好的 deeplabv3-resnet101 模块，设备参数指定处理推理时的<em class="nc"> CPU </em>或<em class="nc"> GPU </em>加速。</li><li id="4e92" class="mt mu it lt b lu nd lx ne ma nf me ng mi nh mm my mz na nb bi translated"><code class="fe pf pg ph pi b">def forwar(self, input)</code>对<code class="fe pf pg ph pi b">SegmentationSample</code>输入应用模块推理，并返回预测张量。</li><li id="d114" class="mt mu it lt b lu nd lx ne ma nf me ng mi nh mm my mz na nb bi translated"><code class="fe pf pg ph pi b">def load_model(self, pretrained=False)</code>从<code class="fe pf pg ph pi b">torchvision.models.segmentation</code> API 加载 deeplabv3-resnet101 模块。</li></ul><p id="8c1f" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">添加一个方法来帮助处理结果。请记住，输出张量有 21 个通道与模型训练的每个目标类的预测结果相匹配。因此，我们需要解码张量形状，以便能够输出正确的图像结果。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pj pk l"/></div></figure><p id="d47d" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated"><code class="fe pf pg ph pi b">background_custom(self, input_image, source, background_source, channel=21)</code>该方法采用具有<code class="fe pf pg ph pi b">[1, 21, H, W]</code>形状的输出张量图像、图像文件的路径、背景图像文件的路径以及已经设置为 21 的通道数。目标是从输出中提取人物通道(<em class="nc"> class 15 </em>)，排除所有标记为背景的剩余通道，最后将定义的背景与新的图像源合并。</p><h1 id="c667" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">设置 Django API</h1><p id="d868" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们将使用 Django REST 框架为我们的模型构建一个简单的 API。关键的想法是配置所有需要的文件，包括模型、路由管道和视图，这样我们就可以通过一个简单的转发 POST 和 GET 请求轻松地测试推理。</p><p id="ddfc" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">你也可以遵循 Bennett Garner 的教程，它详细介绍了让你的 API 运行的所有必要步骤。</p><div class="of og gp gr oh oi"><a href="https://medium.com/swlh/build-your-first-rest-api-with-django-rest-framework-e394e39a482c" rel="noopener follow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">用 Django REST 框架构建您的第一个 REST API</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">在 Django 中构建 REST API 非常简单。在本教程中，我们将逐步完成您的第一个 API</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">medium.com</p></div></div><div class="or l"><div class="pn l ot ou ov or ow ks oi"/></div></div></a></div><p id="2cef" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">通常，API 是数据库的一个窗口。API 后端处理数据库查询和响应格式化。您收到的是一个静态响应，通常是 JSON 格式的，是您请求的任何资源的静态响应。</p><h2 id="5aa0" class="np la it bd lb nq nr dn lf ns nt dp lj ma nu nv ll me nw nx ln mi ny nz lp oa bi translated">建立 Django 项目</h2><p id="4b64" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">安装<code class="fe pf pg ph pi b">django</code>和<code class="fe pf pg ph pi b">djangorestframework</code> : <code class="fe pf pg ph pi b">pip install django</code> <code class="fe pf pg ph pi b">pip install djangorestframework</code>。</p><p id="83a3" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">前往你将要工作的地方，开始你的项目:<code class="fe pf pg ph pi b">django-admin startproject semanticsegmentation</code>。</p><p id="3e5b" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">在<code class="fe pf pg ph pi b">semanticsegmentation/</code>文件夹中，您将找到一个<code class="fe pf pg ph pi b">manage.py</code>脚本来运行您的 localhost 项目:<code class="fe pf pg ph pi b">python manage.py runserver</code>。</p><p id="9423" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">在 127.0.0.1:8080 港口，您应该登陆欢迎 Django 页面:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi po"><img src="../Images/9f655aeeb12ad0291c4b33611ad7978d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ASsmJb5_lybT9WIuk1F2Ng.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Django 本地主机 127.0.0.1:8080</p></figure><p id="643d" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">从现在开始，你的 Django 后端已经正确设置并运行了。</p><h2 id="9b4b" class="np la it bd lb nq nr dn lf ns nt dp lj ma nu nv ll me nw nx ln mi ny nz lp oa bi translated">创建您的 API 应用程序</h2><p id="ff12" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">您将在前一个文件夹中生成一个专门用于 API 管理的新应用程序。</p><p id="3b08" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">运行以下命令创建文件夹:<code class="fe pf pg ph pi b">python manage.py startapp api</code></p><p id="62ce" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">向项目文件夹注册新的 API app:转到<code class="fe pf pg ph pi b">semanticsegmentation/settings.py</code>添加 API 的路径，</p><pre class="kj kk kl km gt pp pi pq pr aw ps bi"><span id="9ab8" class="np la it pi b gy pt pu l pv pw">INSTALLED_APPS = [<br/>'api.apps.ApiConfig',<br/>'django.contrib.admin',<br/>'django.contrib.auth',<br/>...<br/>]</span></pre><h2 id="30de" class="np la it bd lb nq nr dn lf ns nt dp lj ma nu nv ll me nw nx ln mi ny nz lp oa bi translated">定义您的模型并使用 Django ORM 管理它们</h2><p id="886e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在，为了从 Django 数据库中保存和检索对象，您需要构建一个模型类来表示我们将在 API 请求中处理的实体。对于我们的特殊情况，我们需要张贴图像，应用模型推理来获得语义过滤器，然后恢复它们。因此，最合适的是一个具有两个属性的类，用于将输入和输出图像文件上传到服务器，一个特定的 id <code class="fe pf pg ph pi b">models.UUIDField</code>链接到每个存储的图像，一个名称<code class="fe pf pg ph pi b">CharField</code>用于标识它们，并且可选地，一个<code class="fe pf pg ph pi b">DateTimeField</code>用于保存它们被存储的确切时间。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pj pk l"/></div></figure><p id="fac5" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">在单独的脚本中定义处理文件上传逻辑的方法:</p><p id="b760" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated"><code class="fe pf pg ph pi b">get_input_image_path</code></p><p id="c765" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated"><code class="fe pf pg ph pi b">get_output_image_path</code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pj pk l"/></div></figure><p id="445f" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">将您的更改迁移到数据库:<code class="fe pf pg ph pi b">python manage.py makemigrations</code></p><p id="e492" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated"><code class="fe pf pg ph pi b">python manage.py migrate</code></p><p id="a85d" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">定义与模型类匹配的序列化程序，一个序列化程序用于输入图像，另一个用于输出结果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pj pk l"/></div></figure><p id="7f53" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">在管理站点<code class="fe pf pg ph pi b">admin.site.register(ImageSegmentation)</code>注册你的新模型</p><h2 id="30c5" class="np la it bd lb nq nr dn lf ns nt dp lj ma nu nv ll me nw nx ln mi ny nz lp oa bi translated">建立你的观点</h2><p id="f5ec" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们将创建简单的 get 和 post 方法来处理简单的操作:</p><ul class=""><li id="8a3e" class="mt mu it lt b lu mo lx mp ma mv me mw mi mx mm my mz na nb bi translated"><strong class="lt iu"> <em class="nc"> POST api_view </em> </strong>:发送两个文件图像，应用模型推理进行处理，保存到对应的输入输出文件夹。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pj pk l"/></div></figure><ul class=""><li id="f6d1" class="mt mu it lt b lu mo lx mp ma mv me mw mi mx mm my mz na nb bi translated"><strong class="lt iu"> GET api_view: </strong>检索保存的图像，并将其作为静态资源。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pj pk l"/></div></figure><h2 id="4cbc" class="np la it bd lb nq nr dn lf ns nt dp lj ma nu nv ll me nw nx ln mi ny nz lp oa bi translated">配置 URL 端点并运行您的 API</h2><ol class=""><li id="2be3" class="mt mu it lt b lu lv lx ly ma ob me oc mi od mm oe mz na nb bi translated">在<code class="fe pf pg ph pi b">semanticsegmentation/urls.py</code>文件中设置 url 模式:</li></ol><pre class="kj kk kl km gt pp pi pq pr aw ps bi"><span id="c656" class="np la it pi b gy pt pu l pv pw">urlpatterns = [<br/>   path('admin', admin.site.urls),<br/>   path(r'bg_custom_api', include('API.urls'))<br/>]</span></pre><p id="413f" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">2.在<code class="fe pf pg ph pi b">api.urls</code>文件中定义 API 端点的地址:</p><pre class="kj kk kl km gt pp pi pq pr aw ps bi"><span id="56b1" class="np la it pi b gy pt pu l pv pw">urlurlpatterns = [<br/> path(r'test/', views.test_api, name='test_api_communication'),<br/> path(r'images/', views.get_images, name='get_images'),<br/> path(r'api/', views.run_inference, name='run_inference_on_images'),<br/>]</span></pre><h2 id="3d7d" class="np la it bd lb nq nr dn lf ns nt dp lj ma nu nv ll me nw nx ln mi ny nz lp oa bi translated">在邮递员上运行您的 API</h2><p id="0e19" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><a class="ae ky" href="http://softwaretestingmaterial.com/install-postman/" rel="noopener ugc nofollow" target="_blank">下载 Postman </a>并开始在本地测试您的 API。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi px"><img src="../Images/1e802b00b8bc582993cb23aebe285e99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fYX4BVjaI3Utzp7Kx1UAsQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">截屏(<em class="py">邮递员</em>)127 . 0 . 0 . 1 上的 post 请求:8000/api/inference/</p></figure><ul class=""><li id="26a6" class="mt mu it lt b lu mo lx mp ma mv me mw mi mx mm my mz na nb bi translated">在<strong class="lt iu">127 . 0 . 0 . 1:8080/API/gray/</strong>上运行灰度推断</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pz"><img src="../Images/cdff551f169574ed05d40fa08f60a2f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ly5beNWBKcD21NrX4ZzBLg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">左上角的<a class="ae ky" href="https://unsplash.com/@calvinlupiya?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Calvin Lupiya </a>在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的原始照片，其右侧为灰度版本，左下角的<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@cdc?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> CDC </a>的原始彩色照片，其右侧为分段版本。</p></figure><ul class=""><li id="4853" class="mt mu it lt b lu mo lx mp ma mv me mw mi mx mm my mz na nb bi translated">在<strong class="lt iu">127 . 0 . 0 . 1:8080/API/inference/</strong>上运行后台自定义推理</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qa"><img src="../Images/78918b76ae80774465d72a77fe4d70f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vlVNkL-_cq80dJa2cK9MPw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">乔安娜·尼克斯-沃克普在<a class="ae ky" href="https://unsplash.com/@joanna_nix?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片<a class="ae ky" href="https://unsplash.com/@joanna_nix?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">和</a><a class="ae ky" href="https://unsplash.com/@capturedby_kiana?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Kiana Bosman </a>在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="94ee" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">结论</h1><p id="0b6b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">一旦你设置了 API 正确运行所需的所有组件，你就可以开始用 DeepLab V3 尝试一些非常酷的功能，包括背景自定义、背景灰度、背景模糊以及我相信你能想到的许多其他创造性的东西。</p><p id="7af1" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">在为模型服务构建 API 之后，一个自然的步骤是开发一个小的移动应用程序，作为与 Django 后端交互的客户端，因此您可以测试并获取之前看到的所有结果。我愿意在我的下一篇文章中考虑这个选项，所以请继续关注第二部分。</p><p id="2cd5" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">如果您对代码有任何疑问，请与我联系，不要犹豫，给我发电子邮件到<a class="ae ky" href="mailto:aymanehachchaming@gmail.com" rel="noopener ugc nofollow" target="_blank">aymanehachchaming@gmail.com</a></p><p id="09a8" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">本文的整个项目代码可以在我的 GitHub repo 中找到:</p><div class="of og gp gr oh oi"><a href="https://github.com/aymanehachcham/Background-Customization" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">aymanehachham/背景-定制</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">在 GitHub 上创建一个帐户，为 aymanehachham/后台定制开发做贡献。</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">github.com</p></div></div><div class="or l"><div class="qb l ot ou ov or ow ks oi"/></div></div></a></div><h2 id="633e" class="np la it bd lb nq nr dn lf ns nt dp lj ma nu nv ll me nw nx ln mi ny nz lp oa bi translated">本文的参考资料</h2><ul class=""><li id="d528" class="mt mu it lt b lu lv lx ly ma ob me oc mi od mm my mz na nb bi translated"><a class="ae ky" href="https://pytorch.org/hub/pytorch_vision_deeplabv3_resnet101/" rel="noopener ugc nofollow" target="_blank">py torch 团队开发的配有 ResNet-101 主干网的 DeepLabV3 型号</a></li><li id="4f57" class="mt mu it lt b lu nd lx ne ma nf me ng mi nh mm my mz na nb bi translated">谷歌团队【2017 arXiv】【DeepLabv3】<a class="ae ky" href="https://arxiv.org/pdf/1706.05587.pdf" rel="noopener ugc nofollow" target="_blank">重新思考语义图像分割的阿特鲁卷积</a></li><li id="ae7e" class="mt mu it lt b lu nd lx ne ma nf me ng mi nh mm my mz na nb bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/review-deeplabv3-atrous-convolution-semantic-segmentation-6d818bfd1d74"> DeepLab V3 阿特鲁卷积</a>由<a class="ae ky" href="https://towardsdatascience.com/@sh.tsang?source=post_page-----6d818bfd1d74----------------------" rel="noopener" target="_blank"> Sik-Ho Tsang </a></li><li id="6380" class="mt mu it lt b lu nd lx ne ma nf me ng mi nh mm my mz na nb bi translated">感谢艾哈迈德·巴布切的帮助。</li></ul></div></div>    
</body>
</html>