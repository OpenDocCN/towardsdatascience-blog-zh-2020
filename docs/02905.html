<html>
<head>
<title>A Practical Guide for Data Analysis with Pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">熊猫数据分析实用指南</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-practical-guide-for-data-analysis-with-pandas-e24e467195a9?source=collection_archive---------9-----------------------#2020-03-20">https://towardsdatascience.com/a-practical-guide-for-data-analysis-with-pandas-e24e467195a9?source=collection_archive---------9-----------------------#2020-03-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2c36" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">加快您的数据分析过程</h2></div><p id="37d3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">数据科学项目中最耗时的部分是数据清理和准备。然而，有许多强有力的工具可以加速这个过程。其中之一是Pandas，它是一个广泛使用的Python数据分析库。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/c58a26ee3b41b01798ff573f1c1cf6aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TKRMzr-NJwYdrYi3AnJPXA.jpeg"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated"><a class="ae lu" href="https://favpng.com/png_view/report-data-analysis-big-data-management-data-processing-png/SDbMSLFj" rel="noopener ugc nofollow" target="_blank">图像来源</a></p></figure><p id="8d72" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章中，我将介绍一个典型的熊猫数据清理过程。我将举一个例子，因为一如既往，熟能生巧。</p><p id="1e56" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">主要议题是:</p><ul class=""><li id="35f2" class="lv lw it kk b kl km ko kp kr lx kv ly kz lz ld ma mb mc md bi translated">创建数据框架</li><li id="6a45" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld ma mb mc md bi translated">数据概述</li><li id="4d87" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld ma mb mc md bi translated">缺少值</li><li id="ccf7" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld ma mb mc md bi translated">选择数据</li></ul><p id="991c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们总是从导入所需的库开始:</p><pre class="lf lg lh li gt mj mk ml mm aw mn bi"><span id="b9d6" class="mo mp it mk b gy mq mr l ms mt">import pandas as pd<br/>import numpy as np</span></pre><h1 id="ff92" class="mu mp it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated"><strong class="ak">创建数据帧</strong></h1><p id="8535" class="pw-post-body-paragraph ki kj it kk b kl nl ju kn ko nm jx kq kr nn kt ku kv no kx ky kz np lb lc ld im bi translated">在现实生活中，我们通常从文件中读取数据，而不是创建数据帧。Pandas提供了<a class="ae lu" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html" rel="noopener ugc nofollow" target="_blank">函数</a>，通过从各种文件类型中读取数据来创建数据帧。在这篇文章中，我将使用字典来创建一个示例数据帧。</p><pre class="lf lg lh li gt mj mk ml mm aw mn bi"><span id="24b5" class="mo mp it mk b gy mq mr l ms mt">df = pd.DataFrame({'a':np.random.rand(10),<br/>                 'b':np.random.randint(10, size=10),<br/>                 'c':[True,True,True,False,False,np.nan,np.nan,<br/>                      False,True,True],<br/>                 'b':['London','Paris','New York','Istanbul',<br/>                      'Liverpool','Berlin',np.nan,'Madrid',<br/>                      'Rome',np.nan],<br/>                 'd':[3,4,5,1,5,2,2,np.nan,np.nan,0],<br/>                 'e':[1,4,5,3,3,3,3,8,8,4]})<br/>df</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/a528ce5d5bb3dbe5ea3902df5e57c371.png" data-original-src="https://miro.medium.com/v2/resize:fit:538/format:webp/1*ddotCsWWSHgmTFdNHF1ZHQ.png"/></div></figure><h1 id="66b6" class="mu mp it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated"><strong class="ak">数据概述</strong></h1><p id="2fda" class="pw-post-body-paragraph ki kj it kk b kl nl ju kn ko nm jx kq kr nn kt ku kv no kx ky kz np lb lc ld im bi translated">Pandas describe函数为数值(int或float)列提供汇总统计信息。它计算值的数量，并显示平均值、标准差、最小值和最大值以及25%、50%和75%的分位数。</p><pre class="lf lg lh li gt mj mk ml mm aw mn bi"><span id="bfa2" class="mo mp it mk b gy mq mr l ms mt">df.describe()</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/b0d3bc8a9bb64372813698f5550bdcbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:530/format:webp/1*s5HPXLlLrvdICiL8JHDzzw.png"/></div></figure><p id="299e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然所有的列都有相同的行数，但是d列的计数不同，因为describe函数不计算NaN(缺失)值。</p><p id="4d4d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> value_counts() </strong>以出现次数显示列中的值:</p><pre class="lf lg lh li gt mj mk ml mm aw mn bi"><span id="9504" class="mo mp it mk b gy mq mr l ms mt">df.c.value_counts()<br/>True     5<br/>False    3<br/>Name: c, dtype: int64</span></pre><p id="881b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">value_counts()不计算NaN(缺失)值。</p><p id="b43d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还应该检查数据类型，并在我们的分析中考虑它们。有些功能只能在某些数据类型上执行。我们可以使用<strong class="kk iu"> dtypes </strong>轻松检查数据类型:</p><pre class="lf lg lh li gt mj mk ml mm aw mn bi"><span id="2f4d" class="mo mp it mk b gy mq mr l ms mt">df.dtypes<br/>a    float64<br/>b     object<br/>c     object<br/>d    float64<br/>e      int64<br/>dtype: object</span></pre><p id="003c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">“d”和“e”列都有整数，但“d”列的数据类型是float。原因是列d中的NaN值。NaN值被认为是浮点型的，因此该列中的整数值被向上转换为浮点数据类型。</p><p id="7c63" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Pandas 1.0.1允许使用NaN作为整数数据类型。我们只需要显式地将dtype表示为<strong class="kk iu"> pd。Int64Dtype(): </strong></p><pre class="lf lg lh li gt mj mk ml mm aw mn bi"><span id="d708" class="mo mp it mk b gy mq mr l ms mt">pd.Series([1, 2, 3, np.nan], dtype=pd.Int64Dtype())<br/>0      1<br/>1      2<br/>2      3<br/>3    NaN<br/>dtype: Int64</span></pre><p id="c3d8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果pd。不使用Int64Dtype()，整数值被强制转换为浮点数:</p><pre class="lf lg lh li gt mj mk ml mm aw mn bi"><span id="e99b" class="mo mp it mk b gy mq mr l ms mt">pd.Series([1, 2, 3, np.nan])<br/>0    1.0<br/>1    2.0<br/>2    3.0<br/>3    NaN<br/>dtype: float64</span></pre><h1 id="6af9" class="mu mp it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated"><strong class="ak">缺失值</strong></h1><p id="c605" class="pw-post-body-paragraph ki kj it kk b kl nl ju kn ko nm jx kq kr nn kt ku kv no kx ky kz np lb lc ld im bi translated">处理缺失值是数据清理和准备过程的重要部分，因为现实生活中几乎所有的数据都有一些缺失值。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/818bd2538f5978103184aeec0c598256.png" data-original-src="https://miro.medium.com/v2/resize:fit:510/format:webp/1*iDPaOjgw9jnPh3zt0mFDFA.png"/></div></figure><p id="c159" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在处理缺失值之前，我们需要检查数据帧中缺失值的数量。这一步很重要，因为行或列中缺失值的比率在如何处理它们方面起着关键作用。<strong class="kk iu"> isna() </strong>检查条目是否为NaN(缺失)。当与sum方法结合使用时，它会给出每列中缺失值的总数:</p><pre class="lf lg lh li gt mj mk ml mm aw mn bi"><span id="a8c4" class="mo mp it mk b gy mq mr l ms mt">df.isna().sum()<br/>a    0<br/>b    2<br/>c    2<br/>d    2<br/>e    0<br/>dtype: int64</span></pre><p id="87b1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当与any()结合使用时，它返回一个布尔值，指示该列中是否有任何缺少的值:</p><pre class="lf lg lh li gt mj mk ml mm aw mn bi"><span id="8599" class="mo mp it mk b gy mq mr l ms mt">df.isna().any()<br/>a    False<br/>b     True<br/>c     True<br/>d     True<br/>e    False<br/>dtype: bool</span></pre><p id="ce52" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有许多方法可以处理丢失的值，没有一个“最佳”的选择可以用于每项任务。它高度依赖于数据的任务和特征。我将在这里列出几种处理缺失值的不同方法。</p><p id="f12b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以用一列中的最大值替换该列中缺少的值:</p><pre class="lf lg lh li gt mj mk ml mm aw mn bi"><span id="af61" class="mo mp it mk b gy mq mr l ms mt">df.d.fillna(df.d.max(), inplace=True)</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/3c1302586c687c6f6fd4685f45bd31cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*UgIPG893W5d08QtI40UMnw.png"/></div></figure><blockquote class="nu nv nw"><p id="4c9d" class="ki kj nx kk b kl km ju kn ko kp jx kq ny ks kt ku nz kw kx ky oa la lb lc ld im bi translated">将<strong class="kk iu">原位</strong>参数设置为真很重要。否则不会保存更改。</p></blockquote><p id="b22d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">根据具体情况，如果缺少的值太多，我们可能会决定删除一行或一列。在没有先验知识的情况下填充许多缺失值可能会对我们的分析产生负面影响。我们的数据框架中有5列，我只想保留至少有4个值的样本(行)。换句话说，至少有两个缺失值的行将被删除。我们可以使用带有<strong class="kk iu"> thresh </strong>参数的<strong class="kk iu"> dropna </strong>函数。轴参数用于指示行(0)或列(1)。</p><pre class="lf lg lh li gt mj mk ml mm aw mn bi"><span id="aa8e" class="mo mp it mk b gy mq mr l ms mt">df.dropna(thresh=4, axis=0, inplace=True)</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/e4e624a13714cd844669db164677451b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/format:webp/1*iBz5spTuSaKeNuh4MfpzBg.png"/></div></figure><blockquote class="nu nv nw"><p id="e037" class="ki kj nx kk b kl km ju kn ko kp jx kq ny ks kt ku nz kw kx ky oa la lb lc ld im bi translated">thresh参数的变元是一行或一列需要不被删除的非缺失值的数量。</p></blockquote><p id="54dd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以用它之前或之后的值来填充丢失的值。这种方法多用于时间序列数据。<strong class="kk iu">方法</strong>参数与'<strong class="kk iu"> ffill </strong>'(向前传播)或'<strong class="kk iu"> bfill </strong>'(向后传播)参数一起使用:</p><pre class="lf lg lh li gt mj mk ml mm aw mn bi"><span id="e296" class="mo mp it mk b gy mq mr l ms mt">df.b.fillna(method='ffill', inplace=True)</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/af0a29bc3159ae114f4a4bd7e8e710d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*7UGlC5qwLRMHdiEFZuLCzg.png"/></div></figure><p id="7312" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以用该列中最常见的<strong class="kk iu">值来填充缺失值。Value_counts()根据值在列中出现的次数对它们进行排序。所以我们可以使用value_counts()的索引来获取最常见的值:</strong></p><pre class="lf lg lh li gt mj mk ml mm aw mn bi"><span id="51cc" class="mo mp it mk b gy mq mr l ms mt">df.c.fillna(df.c.value_counts().index[0], inplace=True)</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/97972eead35e534905c37d87635029cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*Ps-_vZdmfkFbS6Iil-pt8g.png"/></div></figure><h1 id="7a1b" class="mu mp it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated"><strong class="ak">选择数据</strong></h1><p id="6ad9" class="pw-post-body-paragraph ki kj it kk b kl nl ju kn ko nm jx kq kr nn kt ku kv no kx ky kz np lb lc ld im bi translated"><strong class="kk iu"> iloc </strong>和<strong class="kk iu"> loc </strong>允许选择数据帧的一部分。</p><ul class=""><li id="6b01" class="lv lw it kk b kl km ko kp kr lx kv ly kz lz ld ma mb mc md bi translated">iloc:按职位选择</li><li id="52c2" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld ma mb mc md bi translated">位置:按标签选择</li></ul><p id="d803" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们来看一些例子，因为一如既往，熟能生巧。</p><p id="11a3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">国际劳工组织理事会</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi od"><img src="../Images/df87ec47942f3d79d12d24fa5ddefbb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:502/format:webp/1*nQ2lEnyKpZ84xEoi-94qWw.png"/></div></figure><p id="6284" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">选择第二行:</p><pre class="lf lg lh li gt mj mk ml mm aw mn bi"><span id="00ba" class="mo mp it mk b gy mq mr l ms mt">df.iloc[1] <br/>a    0.835929<br/>b       Paris<br/>c        True<br/>d           4<br/>e           4<br/>Name: 1, dtype: object</span></pre><p id="aa97" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">选择第一行，第二列(即第一行中的第二个值):</p><pre class="lf lg lh li gt mj mk ml mm aw mn bi"><span id="df42" class="mo mp it mk b gy mq mr l ms mt">df.iloc[0,1] <br/>'London'</span></pre><p id="fa2f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所有行，第三列(与选择第二列相同，但我只想展示':'的用法):</p><pre class="lf lg lh li gt mj mk ml mm aw mn bi"><span id="69e8" class="mo mp it mk b gy mq mr l ms mt">df.iloc[:,2]<br/>0     True<br/>1     True<br/>2     True<br/>3    False<br/>4    False<br/>5     True<br/>7    False<br/>8     True<br/>9     True<br/>Name: c, dtype: bool</span></pre><p id="249d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">前两行，第二列:</p><pre class="lf lg lh li gt mj mk ml mm aw mn bi"><span id="cc69" class="mo mp it mk b gy mq mr l ms mt">df.iloc[:2,1]<br/>0    London<br/>1     Paris<br/>Name: b, dtype: object</span></pre><p id="f2fe" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> loc </strong></p><p id="0262" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最多2行，列“b”:</p><pre class="lf lg lh li gt mj mk ml mm aw mn bi"><span id="a376" class="mo mp it mk b gy mq mr l ms mt">df.loc[:2,'b']<br/>0      London<br/>1       Paris<br/>2    New York<br/>Name: b, dtype: object</span></pre><p id="c83f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最多2行和最多“b”列:</p><pre class="lf lg lh li gt mj mk ml mm aw mn bi"><span id="70dc" class="mo mp it mk b gy mq mr l ms mt">df.loc[:2, :'b']</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/e67cdb9baa652d3654abd2e02d5237b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:312/format:webp/1*k2PPx3TNWdxl2ba6hH9a9A.png"/></div></figure><p id="c4dc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第“2”行和第“b”列:</p><pre class="lf lg lh li gt mj mk ml mm aw mn bi"><span id="8bed" class="mo mp it mk b gy mq mr l ms mt">df.loc[2, :'b']<br/>a     0.16649<br/>b    New York<br/>Name: 2, dtype: object</span></pre><blockquote class="nu nv nw"><p id="65db" class="ki kj nx kk b kl km ju kn ko kp jx kq ny ks kt ku nz kw kx ky oa la lb lc ld im bi translated">您可能想知道为什么我们在loc和iloc中对行使用相同的值。原因是数字指数。Loc按位置选择，但行的位置与索引相同。</p></blockquote><p id="0f85" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们创建一个带有非数字索引的新数据帧，这样我们就可以看到不同之处:</p><pre class="lf lg lh li gt mj mk ml mm aw mn bi"><span id="8b7a" class="mo mp it mk b gy mq mr l ms mt">index = ['aa','bb','cc','dd','ee']<br/>df2 = pd.DataFrame({'a':np.random.rand(5),<br/>                 'b':np.random.randint(10, size=5)},<br/>                   index = index)<br/>df2</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi of"><img src="../Images/5869c123355a1ae56798b45bf7a5c083.png" data-original-src="https://miro.medium.com/v2/resize:fit:230/format:webp/1*pxmWxZzjRK0mWtcwkiFgOg.png"/></div></figure><pre class="lf lg lh li gt mj mk ml mm aw mn bi"><span id="70be" class="mo mp it mk b gy mq mr l ms mt">df2.loc['bb','b']<br/>1</span><span id="2811" class="mo mp it mk b gy og mr l ms mt">df2.loc[:'cc','a']<br/>aa    0.892290<br/>bb    0.174937<br/>cc    0.600939<br/>Name: a, dtype: float64</span></pre><p id="a94b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">完成数据清理或预处理后，最好将其保存到文件中，这样下次处理项目时就不必再经历相同的步骤。Pandas提供了许多IO工具来读写不同的文件格式。最常见的是<strong class="kk iu"> to_csv </strong>:</p><pre class="lf lg lh li gt mj mk ml mm aw mn bi"><span id="3644" class="mo mp it mk b gy mq mr l ms mt">df.to_csv("df_cleaned.csv")</span></pre><h1 id="92a8" class="mu mp it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated">结论</h1><p id="5e6d" class="pw-post-body-paragraph ki kj it kk b kl nl ju kn ko nm jx kq kr nn kt ku kv no kx ky kz np lb lc ld im bi translated">我在这里介绍的只是熊猫在数据分析过程中的一小部分能力，但肯定会在你的项目中有用。试图一下子全部学会是不合理的。相反，学习小块和通过实践吸收信息将帮助你建立全面的数据分析技能。</p><h1 id="58e5" class="mu mp it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated">我关于数据操作和分析的其他帖子</h1><ul class=""><li id="c119" class="lv lw it kk b kl nl ko nm kr oh kv oi kz oj ld ma mb mc md bi translated"><a class="ae lu" rel="noopener" target="_blank" href="/time-series-analysis-with-pandas-e6281a5fcda0">与熊猫的时间序列分析</a></li><li id="b034" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld ma mb mc md bi translated"><a class="ae lu" rel="noopener" target="_blank" href="/time-series-analysis-handling-time-zones-b6fcb324c7b">时间序列分析—处理时区</a></li><li id="04c1" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld ma mb mc md bi translated"><a class="ae lu" rel="noopener" target="_blank" href="/the-most-underrated-tool-in-data-science-numpy-68d8fcbde524">数据科学中最被低估的工具:NumPy </a></li><li id="27d7" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld ma mb mc md bi translated"><a class="ae lu" href="https://medium.com/swlh/the-most-underrated-tool-in-data-science-numpy-part-2-d9bfb4b2313a" rel="noopener">数据科学中最被低估的工具:NumPy(第二部分)</a></li><li id="b72d" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld ma mb mc md bi translated"><a class="ae lu" rel="noopener" target="_blank" href="/combining-dataframes-using-pandas-b9e2e83b9869">使用熊猫组合数据帧</a></li><li id="ff8e" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld ma mb mc md bi translated"><a class="ae lu" rel="noopener" target="_blank" href="/handling-missing-values-with-pandas-b876bf6f008f">用熊猫处理缺失值</a></li><li id="0d0f" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld ma mb mc md bi translated"><a class="ae lu" href="https://medium.com/@soneryildirim1988/3-useful-functionalities-of-pandas-f4cb342a77ab" rel="noopener">熊猫的3个有用功能</a></li></ul></div></div>    
</body>
</html>