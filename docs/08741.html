<html>
<head>
<title>Dive into Queue Module in Python — It’s more than FIFO</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深入研究 Python 中的队列模块——它不仅仅是 FIFO</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/dive-into-queue-module-in-python-its-more-than-fifo-ce86c40944ef?source=collection_archive---------14-----------------------#2020-06-24">https://towardsdatascience.com/dive-into-queue-module-in-python-its-more-than-fifo-ce86c40944ef?source=collection_archive---------14-----------------------#2020-06-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="59cf" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">多线程的良好候选</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9232a17e37c7d74bd6fc0f4a70b6e439.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bzaNeOEmV1iza52T"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">micha Parzuchowski 在<a class="ae ky" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="4955" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">队列是一种非常实用的数据结构。通常与<em class="lv">栈</em>、<em class="lv">数组</em>、<em class="lv">链表、</em>等<em class="lv">线性数据结构</em>相比较。线性结构与其他结构的不同之处在于添加和删除发生的位置。</p><p id="ee51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">队列数据结构有三种类型:<strong class="lb iu"> FIFO、LIFO </strong>和<strong class="lb iu">优先级队列</strong>。Python 中的队列模块实现了所有这些类型。此外，它在<strong class="lb iu">线程编程</strong>中也非常有用，这使得这个模块更加闪亮。</p><p id="d7e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将首先帮助您更新关于数据结构的知识，并学习如何使用模块<code class="fe lw lx ly lz b">queue</code>。然后我将向您展示如何使用<code class="fe lw lx ly lz b">queue</code>来解决 2 个不同的多线程问题。最后我会说说这个模块的利弊。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h2 id="2c34" class="mh mi it bd mj mk ml dn mm mn mo dp mp li mq mr ms lm mt mu mv lq mw mx my mz bi translated">数据结构</h2><p id="0cad" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">在讨论一些高级特性之前，让我们先来讨论一下队列数据结构，并学习如何使用该模块来创建一个“简单”的队列。</p><p id="dde2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="lv">先进先出——先进先出</em> </strong></p><p id="3f56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是队列的基本类型。首先插入的元素将首先被删除，这类似于现实世界中的等待列表。越早加入名单，你就能越早得到音乐会的门票。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/03bbf1e1fbebf67be4faf3536a53d07a.png" data-original-src="https://miro.medium.com/v2/resize:fit:732/format:webp/1*2jbpFradIkDF9677ws3sVA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">先进先出(<a class="ng nh ep" href="https://medium.com/u/2adc5a07e772?source=post_page-----ce86c40944ef--------------------------------" rel="noopener" target="_blank">高</a>)</p></figure><p id="ebb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python 模块提供了实现 FIFO 队列的<code class="fe lw lx ly lz b">queue.Queue()</code>和<code class="fe lw lx ly lz b">queue.SimpleQueue()</code>。<code class="fe lw lx ly lz b">queue.SimpleQueue()</code>是 Python 3.7 中的新特性。它们之间有两个不同之处:</p><ol class=""><li id="9725" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated"><code class="fe lw lx ly lz b">SimpleQueue()</code>线程编程中不做任务跟踪。线程编程将在后面讨论。</li><li id="4111" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated"><code class="fe lw lx ly lz b">SimpleQueue()</code>是一个无界 FIFO 队列，而<code class="fe lw lx ly lz b">Queue()</code>可以有一个上限。在这两个类中，如果队列为空，<code class="fe lw lx ly lz b">get()</code>操作将被阻塞，直到新元素被插入。在<code class="fe lw lx ly lz b">Queue()</code>中，如果队列已满，<code class="fe lw lx ly lz b">put()</code>操作也将被阻塞，直到元素被移除。这种情况绝不会发生在<code class="fe lw lx ly lz b">SimpleQueue()</code>身上。根据<a class="ae ky" href="https://docs.python.org/3/library/queue.html#queue.SimpleQueue" rel="noopener ugc nofollow" target="_blank"> Python 文档</a>，可以在<code class="fe lw lx ly lz b">get()</code>和<code class="fe lw lx ly lz b">put()</code>中使用<code class="fe lw lx ly lz b">block=False</code>来禁用该块，然后你会立即收到一个<code class="fe lw lx ly lz b">queue.Full</code>和<code class="fe lw lx ly lz b">queue.Empty</code>异常。</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/31e37fde0763a253a1dfd10d6daba255" rel="noopener ugc nofollow" target="_blank"> queue-fifo.py </a></p></figure><p id="36a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="lv">后进先出法</em> </strong></p><p id="19ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">LIFO 队列还有一个名字:Stack。最后插入的元素将首先被移除。这就像超市的货架一样。人们通常会拿第一排最近添加的项目。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/f6fa360544de4b77a020a90e7dbb29d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:712/format:webp/1*SXvNt0aIxrMSRG7ypKtM7Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">后进先出(<a class="ng nh ep" href="https://medium.com/u/2adc5a07e772?source=post_page-----ce86c40944ef--------------------------------" rel="noopener" target="_blank">高</a>)</p></figure><p id="25c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这在<code class="fe lw lx ly lz b">queue.LifoQueue()</code>类中实现。除了移除元素的顺序之外，界面与<code class="fe lw lx ly lz b">queue.Queue()</code>相同。如果您将结果与之前的结果进行比较，您应该会看到打印结果的差异。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/ee9bf9cd726c8483720d89a227b47deb" rel="noopener ugc nofollow" target="_blank"> queue-lifo.py </a></p></figure><p id="49ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="lv">优先级队列</em> </strong></p><p id="2907" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">顾名思义，优先级队列赋予队列中的每个元素一个优先级。它首先弹出优先级最高的元素。在下图中，元素 5 具有最高优先级，因此它将是情况 2 和 3 中弹出的第一个元素。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/c747543ef7d7f2fd1c65f3920d34b66f.png" data-original-src="https://miro.medium.com/v2/resize:fit:910/format:webp/1*GIIoPrHtv36mM6VZRLXMTg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">优先队列(<a class="ng nh ep" href="https://medium.com/u/2adc5a07e772?source=post_page-----ce86c40944ef--------------------------------" rel="noopener" target="_blank">高</a>)</p></figure><p id="0182" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在的问题是 Python 如何决定优先级？在队列模块中，<a class="ae ky" href="https://docs.python.org/3/library/queue.html#queue.PriorityQueue" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">最低值的条目首先被检索</strong> </a>。该值越低，其优先级越高。那么在前面的例子中，2 实际上比 5 具有更高的优先级。这是因为 Python 优先级队列内部使用了<a class="ae ky" href="https://docs.python.org/3/library/heapq.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">最小堆队列算法</strong> </a>。最小堆的一个特性是最小的元素是第一个元素。</p><p id="934a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">堆实际上是一棵二叉树，其中节点的值小于其子节点的值。当一个新节点被推送到树中时，树将被再次排序。根节点总是下一个要检索的元素。<code class="fe lw lx ly lz b">push()</code>和<code class="fe lw lx ly lz b">pop()</code>操作的时间复杂度分别为 O(log n)和 O(1)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/155a32632726c12889cb79fc463b0ac8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/1*v9hT9_ki5r2VKjaSn-r01Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">闵堆(<a class="ng nh ep" href="https://medium.com/u/2adc5a07e772?source=post_page-----ce86c40944ef--------------------------------" rel="noopener" target="_blank">高</a>)</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/ad7685a0ec174820ba2cd743bdbb295e" rel="noopener ugc nofollow" target="_blank">queue-priority-simple . py</a></p></figure><p id="69c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">优先级队列不仅适用于数字，也适用于复杂的数据类型，如<em class="lv">元组</em>或<em class="lv"> </em>定制类，只要对象是可比较的。为了使一个类对象具有可比性，你需要实现几个丰富的比较方法。更简单的方法是使用<code class="fe lw lx ly lz b"><a class="ae ky" rel="noopener" target="_blank" href="/understand-how-to-use-namedtuple-and-dataclass-in-python-e82e535c3691">@dataclass</a></code>，dataclass 可以用 config <code class="fe lw lx ly lz b"><a class="ae ky" href="https://docs.python.org/3/library/dataclasses.html#module-level-decorators-classes-and-functions" rel="noopener ugc nofollow" target="_blank">order=True</a></code>为你实现这些方法。</p><p id="834a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本例中，对象首先按<em class="lv">键</em>排序，然后按<em class="lv">值</em>排序。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/853ab436ab3cb6e2de68edcd3c9a2e4a" rel="noopener ugc nofollow" target="_blank">queue-priority-advanced . py</a></p></figure></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h2 id="37ee" class="mh mi it bd mj mk ml dn mm mn mo dp mp li mq mr ms lm mt mu mv lq mw mx my mz bi translated">线程编程</h2><p id="d69f" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">队列数据结构有很多应用。一个众所周知的用例必须是消息队列，其中我们有一个生产者和一个消费者。生产者和消费者通常位于不同的线程中。幸运的是，<code class="fe lw lx ly lz b">Queue()</code>类有一个线程安全的实现，带有所有需要的锁定机制。因此，来自不同线程的生产者和消费者可以安全方便地使用同一个队列实例。</p><p id="d824" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本质上，队列存储了许多要完成的“任务”，线程可以将任务插入队列，并在任务可用时从队列中取出任务，然后完成任务并返回进行下一个任务。</p><p id="4de4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你是 Python 线程的新手，我强烈推荐你阅读 Real Python 的<em class="lv">Python 线程介绍</em>。这是一篇非常好的文章。</p><div class="ob oc gp gr od oe"><a href="https://realpython.com/intro-to-python-threading/" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">Python 线程介绍——真正的 Python</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">立即观看本教程有一个由真正的 Python 团队创建的相关视频课程。和书面的一起看…</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">realpython.com</p></div></div><div class="on l"><div class="oo l op oq or on os ks oe"/></div></div></a></div><p id="9e3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好的，我假设你已经阅读了这篇文章，并且很好地理解了<code class="fe lw lx ly lz b">threading</code>模块在 Python 中是如何工作的。让我们把它与<code class="fe lw lx ly lz b">Queue()</code>课结合起来。我在这里举了两个例子。它们是略有不同的用例。</p><p id="8389" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="lv">例 1 </em> </strong>:创建一个图片 URL 队列，用多线程“并行”下载那些图片。(如果你不明白我为什么在这里加引号，请阅读上面的文章)</p><p id="fb4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将在这个例子中使用<code class="fe lw lx ly lz b">save_image</code>函数。</p><pre class="kj kk kl km gt ot lz ou ov aw ow bi"><span id="14b5" class="mh mi it lz b gy ox oy l oz pa">def save_image(id, url):<br/>    with open(f'pic{id}.jpg','wb') as image:<br/>        response = requests.get(url, stream=True)<br/>        for block in response.iter_content(1024):<br/>            if not block:<br/>                break<br/>            image.write(block)</span></pre><p id="c64b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个<code class="fe lw lx ly lz b">Thread</code>对象都有启动线程的<code class="fe lw lx ly lz b">start()</code>方法，还有通知主线程等待直到线程 x 完成运行的<code class="fe lw lx ly lz b">join()</code>方法。我们可以这样解决问题:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/5f2f22aeba1ec0cf5e8682a1661f876b" rel="noopener ugc nofollow" target="_blank"> download-images-1.py </a></p></figure><p id="ee85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于<code class="fe lw lx ly lz b">Queue()</code>是为多线程设计的，它还提供了<a class="ae ky" href="https://docs.python.org/3/library/queue.html#queue.Queue.task_done" rel="noopener ugc nofollow" target="_blank"> 2 个方法</a>，支持任务跟踪:<code class="fe lw lx ly lz b">Queue.task_done()</code>和<code class="fe lw lx ly lz b">Queue.join()</code>。<code class="fe lw lx ly lz b">Queue.task_done()</code>表示队列中的一个任务已经被处理，通常在<code class="fe lw lx ly lz b">get()</code>之后调用。<code class="fe lw lx ly lz b">Queue.join()</code>类似于<code class="fe lw lx ly lz b">Thread.join()</code>，它将阻塞主线程，直到队列中的所有任务都被处理完。但是你不必创建一个工人列表<code class="fe lw lx ly lz b">workers</code>并在最后做一个循环来加入每个线程，只需做一个单独的<code class="fe lw lx ly lz b">queue.join()</code>。让我们检查一下代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/9d3b6f21db4eb7f330ea12c0963d9d86" rel="noopener ugc nofollow" target="_blank">下载-图片-2.py </a></p></figure><p id="9aed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="lv">例 2 </em> </strong>:创建一个消息队列，一个生产者，一个消费者。来自不同线程的生产者和消费者能够与同一个队列实例进行交互。生产者将发送一个警告消息告诉消费者停止这个过程。</p><p id="7585" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在示例 1 中，我们让 10 个不同的线程执行相同的功能。但是在这个例子中，两个线程正在做完全不同的工作。由于 Python 线程中没有真正的“并行处理”，所以一个线程将首先完成这项工作。在这种情况下，首先触发生产者线程，然后触发消费者线程。您也可以在结果中看到这种行为。</p><p id="0e10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我取消第 9 行的注释，结果会是什么？想想吧！😄</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/9832cc9531ba75699e3f939cb08277a3" rel="noopener ugc nofollow" target="_blank">生产者-消费者-队列. py </a></p></figure><p id="d2cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我在每个<code class="fe lw lx ly lz b">put()</code>操作之前暂停生产者线程，那么我们将更清楚地看到生产者和消费者之间的交互。</p><pre class="kj kk kl km gt ot lz ou ov aw ow bi"><span id="160c" class="mh mi it lz b gy ox oy l oz pa">Insert element 0<br/>Retrieve element 0<br/>Insert element 1<br/>Retrieve element 1<br/>Insert element 2<br/>Retrieve element 2<br/>Insert element 3<br/>Retrieve element 3<br/>Insert element 4<br/>Insert sentinel<br/>Retrieve element 4<br/>Receive SENTINEL, the consumer will be closed.</span></pre></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h2 id="5dcf" class="mh mi it bd mj mk ml dn mm mn mo dp mp li mq mr ms lm mt mu mv lq mw mx my mz bi translated">结论</h2><p id="cca3" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated"><strong class="lb iu"/><code class="fe lw lx ly lz b"><strong class="lb iu">queue</strong></code><strong class="lb iu">的一个明显优势就是它的线程安全特性</strong>。但我们不能把这种便利视为理所当然。如果我们没有线程安全<code class="fe lw lx ly lz b">queue</code>会发生什么？如果我想在多个线程之间共享一个字典或者一个定制的类对象怎么办？</p><p id="968e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于初学者来说，他们可能会遇到<a class="ae ky" href="https://realpython.com/intro-to-python-threading/#race-conditions" rel="noopener ugc nofollow" target="_blank">比赛条件</a>的问题。同样，<a class="ae ky" href="https://realpython.com/intro-to-python-threading/#race-conditions" rel="noopener ugc nofollow" target="_blank">同一篇文章</a>有一个关于竞态条件的非常直观的例子。基本上，相同的值不会在线程间同步。一个解决方法是使用<code class="fe lw lx ly lz b">threading.Lock()</code>。但是它需要一些额外的代码和额外的注意力来控制线程。</p><p id="710b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">另一个优势是避免潜在的内存爆炸</strong>。如果生产者的工作速度比消费者快得多，那么任务将被存储在“管道”中，直到到达内存边界。在这种情况下，<code class="fe lw lx ly lz b">maxsize</code>属性可以避免这个问题。</p><p id="f64a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lw lx ly lz b"><strong class="lb iu">queue</strong></code> <strong class="lb iu">也有助于程序减少繁忙的等待。</strong>程序不需要一直试图从“管道”中拉东西，但是线程会被阻塞，直到数据可用。</p><p id="afd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同时，我们也应该理解<code class="fe lw lx ly lz b">queue</code>的局限性。<code class="fe lw lx ly lz b">queue</code>使用多线程，所以程序不会因此运行得更快。另外，<code class="fe lw lx ly lz b">maxsize</code>指的是队列中的项目数，而不是内存大小。所以，还是有可能达到极限的。</p><p id="4eec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢这篇文章！如果你有任何想法，请在下面留下你的评论。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h2 id="a107" class="mh mi it bd mj mk ml dn mm mn mo dp mp li mq mr ms lm mt mu mv lq mw mx my mz bi translated">参考资料:</h2><div class="ob oc gp gr od oe"><a href="https://docs.python.org/3/library/queue.html" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">队列——一个同步的队列类——Python 3 . 8 . 3 文档</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">源代码:Lib/queue.py 该模块实现了多生产者、多消费者队列。它在…方面特别有用</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">docs.python.org</p></div></div></div></a></div><div class="ob oc gp gr od oe"><a href="https://docs.python.org/3/library/heapq.html" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">heapq -堆队列算法- Python 3.8.3 文档</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">源代码:Lib/heapq.py 这个模块提供了堆队列算法的实现，也称为…</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">docs.python.org</p></div></div></div></a></div></div></div>    
</body>
</html>