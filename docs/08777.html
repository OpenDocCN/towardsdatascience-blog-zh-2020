<html>
<head>
<title>A Novel Solution to Cleaning Extremely Dirty Unstructured text</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一种新颖的清理极脏非结构化文本的方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-novel-solution-to-cleaning-extremely-dirty-unstructured-text-490d4ba934de?source=collection_archive---------50-----------------------#2020-06-24">https://towardsdatascience.com/a-novel-solution-to-cleaning-extremely-dirty-unstructured-text-490d4ba934de?source=collection_archive---------50-----------------------#2020-06-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/94c5311df0cf3777b5dd8724506c5b7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4r5XEaCywB--5nFQ"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">你好，我是尼克🎞 on <a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><div class=""/></div><div class="ab cl kg kh hx ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="im in io ip iq"><p id="2b4c" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">经过整整两周的反复试验，几乎认为这是不可能的…</p><p id="0003" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated"><strong class="kp jk">我做到了。</strong></p><p id="cb39" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我设法把这个:</p><blockquote class="ll"><p id="5d0d" class="lm ln jj bd lo lp lq lr ls lt lu lk dk translated">"这是一个很难解决的问题. "</p></blockquote><p id="11b7" class="pw-post-body-paragraph kn ko jj kp b kq lv ks kt ku lw kw kx ky lx la lb lc ly le lf lg lz li lj lk im bi translated">变成这样:</p><blockquote class="ll"><p id="0cde" class="lm ln jj bd lo lp lq lr ls lt lu lk dk translated">“这是一个很难解决的问题”</p></blockquote><p id="84e9" class="pw-post-body-paragraph kn ko jj kp b kq lv ks kt ku lw kw kx ky lx la lb lc ly le lf lg lz li lj lk im bi translated">我以为在和类似<a class="ae jg" rel="noopener" target="_blank" href="/creating-word-embeddings-for-out-of-vocabulary-oov-words-such-as-singlish-3fe33083d466">新加坡式英语</a>甚至<a class="ae jg" rel="noopener" target="_blank" href="/are-deeper-networks-better-a-case-study-6ee9bcb0725b">推特</a>的人合作后，我已经见识了这一切。</p><p id="8721" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">但我从未想过我会遇到如此肮脏的非结构化文本数据。</p><p id="e9af" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我显然夸大了上面的例子，但问题归结为以下两点:</p><ul class=""><li id="c178" class="ma mb jj kp b kq kr ku kv ky mc lc md lg me lk mf mg mh mi bi translated">拼写错误的检测和解决</li><li id="c019" class="ma mb jj kp b kq mj ku mk ky ml lc mm lg mn lk mf mg mh mi bi translated">处理单词之间的随机空格</li></ul><p id="be1f" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">作为人类，我们可以很容易地将上面的陈述解读为:</p><p id="796e" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated"><strong class="kp jk">“这是一个很难解决的问题”</strong></p><p id="9cee" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">然而，提出一种方法来解决这样一个数据问题被证明比预期更具挑战性。</p><p id="8cc6" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">在这篇文章中，我将介绍一个新颖的解决方案，它是我用来清理一个非常脏的非结构化文本数据集的。</p><p id="9379" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">以下是这些数据的大概情况:</p><figure class="mp mq mr ms gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mo"><img src="../Images/6b0c9f7094cce15fed297fc4334f70c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6518ArT4PPFfDXHSTkdGqA.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">肮脏的非结构化文本的例子</p></figure><blockquote class="mt mu mv"><p id="b189" class="kn ko mw kp b kq kr ks kt ku kv kw kx mx kz la lb my ld le lf mz lh li lj lk im bi translated">注意:这只是脏数据的一个例子，而不是实际的数据。</p></blockquote><p id="9bd9" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">今天不会有太多的代码片段，但在这篇文章结束时，如果你曾经遇到过这种数据问题，你会对解决这种问题的方法有所了解。</p></div><div class="ab cl kg kh hx ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="im in io ip iq"><h1 id="2a10" class="na nb jj bd nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx bi translated">数据质量问题 1:拼写错误的检测和解决</h1><p id="8075" class="pw-post-body-paragraph kn ko jj kp b kq ny ks kt ku nz kw kx ky oa la lb lc ob le lf lg oc li lj lk im bi translated">在我以前的一篇关于处理拼写错误的帖子中，我使用了单词向量，并进行了大量的翻译，以形成一个通用的翻译向量来处理拼写错误。</p><div class="is it gp gr iu od"><a rel="noopener follow" target="_blank" href="/using-a-generalised-translation-vector-for-handling-misspellings-and-out-of-vocabulary-oov-words-494cd142cd31"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd jk gy z fp oi fr fs oj fu fw ji bi translated">使用广义翻译向量来处理拼写错误和不在词汇表中(OOV)的单词…</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">我的实验和结果是用一种新颖的方法来处理拼写错误和 OOV 单词。希望你能找到他们…</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">towardsdatascience.com</p></div></div><div class="om l"><div class="on l oo op oq om or ja od"/></div></div></a></div><p id="74ff" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">在这篇文章中，我将依靠算法来处理拼写错误。</p><p id="6a5c" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">这一部分包括两个部分:</p><ol class=""><li id="d755" class="ma mb jj kp b kq kr ku kv ky mc lc md lg me lk os mg mh mi bi translated">检测拼写错误的单词</li><li id="a44a" class="ma mb jj kp b kq mj ku mk ky ml lc mm lg mn lk os mg mh mi bi translated">解决拼写错误的单词</li></ol><p id="c1a1" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我使用了<a class="ae jg" href="https://www.sas.com/en_sg/software/viya.html#products" rel="noopener ugc nofollow" target="_blank"> SAS Viya 的</a>开箱即用的拼写错误动作<strong class="kp jk"> tpSpell </strong>来做这件事。</p><blockquote class="mt mu mv"><p id="c36e" class="kn ko mw kp b kq kr ks kt ku kv kw kx mx kz la lb my ld le lf mz lh li lj lk im bi translated">注意:SAS 与称为<strong class="kp jk">动作集</strong>的东西一起工作，动作集是 Python 包的同义词。在每个动作集中，有许多可以执行的<strong class="kp jk">动作</strong>。</p></blockquote><h2 id="0e26" class="ot nb jj bd nc ou ov dn ng ow ox dp nk ky oy oz no lc pa pb ns lg pc pd nw pe bi translated">第 1 部分:检测拼写错误的单词</h2><p id="ae7e" class="pw-post-body-paragraph kn ko jj kp b kq ny ks kt ku nz kw kx ky oa la lb lc ob le lf lg oc li lj lk im bi translated">在这一步中，tpSpell 动作执行所谓的<strong class="kp jk">候选提取。</strong></p><p id="9b93" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">候选提取将单词分为两类:</p><ul class=""><li id="6f79" class="ma mb jj kp b kq kr ku kv ky mc lc md lg me lk mf mg mh mi bi translated">拼写正确的候选单词</li><li id="6993" class="ma mb jj kp b kq mj ku mk ky ml lc mm lg mn lk mf mg mh mi bi translated">拼写错误的候选单词</li></ul><p id="8e05" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">在运行该过程之前，由预定的参数(“最小亲本”)来确定拼写正确的候选单词。</p><p id="6b66" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">此参数指定一个术语要被视为拼写正确的候选单词，必须出现在多少个文档中。</p><p id="ba81" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">所有拼写正确的候选单词都采用<code class="fe pf pg ph pi b">&lt;term&gt;-&lt;role&gt;-&lt;parent&gt;</code>的形式。</p><p id="127e" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">例如，参考下面的图 1:</p><figure class="mp mq mr ms gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pj"><img src="../Images/57178c07b9bfdd3efa63dec28b4912fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fb4CNDJfYF9gvUfr.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图 1 —拼写正确的候选示例(<a class="ae jg" href="https://go.documentation.sas.com/?cdcId=pgmsascdc&amp;cdcVersion=9.4_3.4&amp;docsetId=casvtapg&amp;docsetTarget=n1v6fwv203gwamn12k2plw3hsstl.htm&amp;locale=en" rel="noopener ugc nofollow" target="_blank">来源</a>)</p></figure><p id="68d7" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">请注意，潜在的候选名称是如何将“Term”、“Role”和“Parent”列连接起来形成“algorithms-N-algorithm”的。</p><p id="0962" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">这是逻辑的分解。</p><ol class=""><li id="013e" class="ma mb jj kp b kq kr ku kv ky mc lc md lg me lk os mg mh mi bi translated">如果潜在候选名称“algorithms-N-algorithm”在 4 个文档中出现 5 次，那么它出现的文档的<strong class="kp jk"> </strong>数量等于 4。</li><li id="d342" class="ma mb jj kp b kq mj ku mk ky ml lc mm lg mn lk os mg mh mi bi translated">如果称为“最小双亲”的预定参数被设置为 3，因为 4 比 3 大，所以单词“algorithms-N-algorithms”被添加到拼写正确的候选列表中。</li></ol><p id="bd52" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">那么，拼写错误的候选单词列表呢？那么我们如何创建这个表呢？</p><p id="bf11" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">就像拼写正确的单词候选列表一样，还有另一个预先确定的参数要设置。</p><p id="7789" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">这次叫“最大子女”。</p><p id="add3" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">例如，请看下面的图 2:</p><figure class="mp mq mr ms gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pk"><img src="../Images/a2b29e52f52aff42e230af11ec37a46b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gI7zHDO2sBIAyBMb.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图 2 —拼写错误的候选示例(<a class="ae jg" href="https://go.documentation.sas.com/?cdcId=pgmsascdc&amp;cdcVersion=9.4_3.4&amp;docsetId=casvtapg&amp;docsetTarget=n1v6fwv203gwamn12k2plw3hsstl.htm&amp;locale=en" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="8efe" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">逻辑很简单。</p><p id="55ce" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">如果“maximum children”参数设置为 3 <strong class="kp jk">并且</strong>出现类似“algoxxxthzs-N-algoxxxthzs”的潜在候选名称的文档数量小于 3，则“algoxxxthzs-N-algoxxxthzs”被添加到拼写错误的单词候选列表中。</p><p id="3653" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">对图 2 中指定的整个表重复这个逻辑。</p><p id="bd98" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">现在我们已经得到了一个<strong class="kp jk">拼写正确的候选列表</strong>和一个<strong class="kp jk">拼写错误的单词候选列表</strong>，接下来是将拼写正确的单词分配给其各自的错误拼写的逻辑。</p><h2 id="3ae1" class="ot nb jj bd nc ou ov dn ng ow ox dp nk ky oy oz no lc pa pb ns lg pc pd nw pe bi translated">第 2 部分:拼写错误的解决方案</h2><p id="5935" class="pw-post-body-paragraph kn ko jj kp b kq ny ks kt ku nz kw kx ky oa la lb lc ob le lf lg oc li lj lk im bi translated">在该步骤中，执行<strong class="kp jk">候选比较</strong>以解决拼写错误。</p><p id="4252" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">该算法现在将对照拼写正确的列表中的所有单词来检查拼写错误的列表中的所有单词。</p><p id="9ed6" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">它将拼写错误的候选单词与每个拼写正确的候选单词进行比较，并计算它们之间的距离。</p><p id="a161" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">另一个被称为“最大拼写距离”的预定参数确定拼写错误的单词是否具有正确的拼写。</p><p id="5d76" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">例如，如果单词“algoxxxthzs”是给定的拼写错误的单词<strong class="kp jk">并且</strong>单词“算法”是正确拼写的候选，那么计算出的“algoxxxthzs”和“算法”之间的距离将是 50。</p><p id="62d9" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">如果“最大法术距离”设置为 20。由于 50 大于 20，正确拼写的候选“算法”现在被认为是单词“algoxxxthzs”的正确拼写。</p><p id="34dd" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">您还可以在这里设置其他高级参数，以考虑多个术语，如“消防车”、“继续”或“加入”等。你可以在这里阅读文档<a class="ae jg" href="https://go.documentation.sas.com/?cdcId=pgmsascdc&amp;cdcVersion=9.4_3.4&amp;docsetId=casvtapg&amp;docsetTarget=n1v6fwv203gwamn12k2plw3hsstl.htm&amp;locale=en" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="38da" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">虽然我在上面说得听起来很复杂…</p><p id="15e5" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated"><strong class="kp jk">不是。</strong></p><p id="a6e4" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">下面是如何运行以上所有操作的方法。</p><pre class="mp mq mr ms gt pl pi pm pn aw po bi"><span id="f464" class="ot nb jj pi b gy pp pq l pr ps">proc cas;<br/> textParse.tpSpell /<br/>  table={name="pos", caslib="public"}<br/>  minParents=3<br/>  maxChildren=6<br/>  maxSpellDist=15<br/>  casOut={name="tpSpell_Out", replace=true};<br/>   run;<br/>quit;</span></pre><p id="b94c" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">结果将是这样的:</p><figure class="mp mq mr ms gt iv gh gi paragraph-image"><div class="gh gi pt"><img src="../Images/b3460a830951f9de1bc6fdfb17ea08bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/format:webp/0*xn0jePsXfVMDkTqs.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图 3 —拼写错误的解析结果</p></figure><p id="e311" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我喜欢 SAS 编程的一点是，只用几行代码就能轻松利用复杂的算法。</p><p id="2d04" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">是的，Python 包做同样的事情，但是有时，这些包没有 SAS 高级。</p><p id="a3cb" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">一个很好的例子是 SAS 如何优化深度学习超参数和层内参数。有趣的是，在 SAS 中进行超参数调优真的很容易。</p><p id="7706" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">SAS 将拉丁超立方体与用超带方法优化的遗传算法相结合，以说明资源利用率。此外，一切都是自动多线程的。</p><p id="424a" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">用 Python 编写 SAS 的现成代码肯定会花费更多的时间和精力，更不用说如何用 Python 分配处理、计算资源分配和利用所需的知识了——我认为大多数人对此并不熟悉。</p></div><div class="ab cl kg kh hx ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="im in io ip iq"><h1 id="377e" class="na nb jj bd nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx bi translated">数据质量问题 2:处理随机空白</h1><p id="b0c6" class="pw-post-body-paragraph kn ko jj kp b kq ny ks kt ku nz kw kx ky oa la lb lc ob le lf lg oc li lj lk im bi translated">这个问题确实让我测试了多种方法。所有这些都表现不好，除了我现在要讲的方法。</p><blockquote class="ll"><p id="d15b" class="lm ln jj bd lo lp lq lr ls lt lu lk dk translated">为了恢复你的记忆，你的问题就像这样</p></blockquote><p id="ca1d" class="pw-post-body-paragraph kn ko jj kp b kq lv ks kt ku lw kw kx ky lx la lb lc ly le lf lg lz li lj lk im bi translated">上面有几个值得指出的数据质量问题:</p><ol class=""><li id="6209" class="ma mb jj kp b kq kr ku kv ky mc lc md lg me lk os mg mh mi bi translated">单词之间的空格，如“probl em”</li><li id="3a1b" class="ma mb jj kp b kq mj ku mk ky ml lc mm lg mn lk os mg mh mi bi translated">缺少字符，即“锁定”</li><li id="cdf0" class="ma mb jj kp b kq mj ku mk ky ml lc mm lg mn lk os mg mh mi bi translated">交换字符，即“thsi”</li><li id="4ec7" class="ma mb jj kp b kq mj ku mk ky ml lc mm lg mn lk os mg mh mi bi translated">双重字符，即“你”</li><li id="2ec3" class="ma mb jj kp b kq mj ku mk ky ml lc mm lg mn lk os mg mh mi bi translated">问题的组合，即“m emry”——1 和 2 的组合。</li></ol><p id="91d5" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我必须找到一种方法来解决单词之间的空格，同时解决拼写错误(数字 2、3 和 4)。</p><p id="4e8b" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">幸运的是，处理拼写错误相对容易，正如我在上面用 tpSpell 展示的那样。</p><p id="0740" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">但是问题的组合带来了复杂性(第五点)。</p><p id="6ea4" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">对于像这样的组合问题，我首先需要在应用拼写错误解决方案之前解决空白。</p><p id="e348" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">在思考这项工作的最佳解决方案时，我从编码器-解码器网络的工作方式中获得了灵感。</p><blockquote class="ll"><p id="aaa1" class="lm ln jj bd lo lp lq lr ls lt lu lk dk translated"><em class="pu">我能以某种方式“编码”句子，然后“解码”它们吗？</em></p></blockquote><p id="accb" class="pw-post-body-paragraph kn ko jj kp b kq lv ks kt ku lw kw kx ky lx la lb lc ly le lf lg lz li lj lk im bi translated">显然我在这里用词不当。我说的“编码”实际上是指删除单词间的所有空白<strong class="kp jk">。像这样:</strong></p><blockquote class="ll"><p id="f4cf" class="lm ln jj bd lo lp lq lr ls lt lu lk dk translated"><em class="pu">torefreshyyourmerytheekedlikethsi</em></p></blockquote><p id="a3c7" class="pw-post-body-paragraph kn ko jj kp b kq lv ks kt ku lw kw kx ky lx la lb lc ly le lf lg lz li lj lk im bi translated">通过“解码”，我的意思是在解决拼写错误后，将单词重新分解成它们各自的单词:</p><blockquote class="ll"><p id="f784" class="lm ln jj bd lo lp lq lr ls lt lu lk dk translated"><em class="pu">提醒你一下，问题是这样的</em></p></blockquote><h2 id="437d" class="ot nb jj bd nc ou pv dn ng ow pw dp nk ky px oz no lc py pb ns lg pz pd nw pe bi translated">“解码”的问题第 1 部分</h2><p id="68f5" class="pw-post-body-paragraph kn ko jj kp b kq ny ks kt ku nz kw kx ky oa la lb lc ob le lf lg oc li lj lk im bi translated">我必须解决的最大问题之一是，一旦字符串被“编码”，何时插入空格。</p><p id="fca1" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">就拿“<em class="mw"> torefresh </em>这个词来说吧。</p><p id="bbf0" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">如何知道在“<em class="mw">到</em>和“<em class="mw">刷新</em>”之间插入一个空格？为什么不是“<em class="mw">到</em>”、“<em class="mw"> re </em>”和“<em class="mw"> fresh </em>”？</p><p id="20c7" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">下面是我是如何做到的，以及我的 SAS 脚本的逻辑。</p><p id="f024" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">解码的单词基于单词的<strong class="kp jk">最长匹配</strong>。</p><p id="d6b7" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">例如，如果我看到单词“<em class="mw"> helloworld </em>”，我将首先在预定义的潜在候选列表中查找单词“<em class="mw"> hell </em>”。即字典表</p><p id="268f" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">直到下一个角色“<em class="mw"> o </em>出现，既然“<em class="mw">hell+o</em>”=“<em class="mw">hello</em>”，“<em class="mw"> hello </em>”就成了比较好的潜在候选人。</p><p id="91b3" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我放弃单词“<em class="mw"> hell </em>”作为主要候选，保留单词“<em class="mw"> hello </em>”作为新的主要候选。</p><p id="9503" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">随着下一个字符被读入，"<em class="mw">hello+w</em>" = "<em class="mw">hellow</em>"，由于"<em class="mw"> hellow </em>"在潜在候选列表中不是一个合适的单词，所以最好的候选是"<em class="mw"> hello </em>"。</p><p id="283d" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">一旦这些检查完成，我就在"<em class="mw"> hello </em>"后面添加一个空格，并继续上面的逻辑，用于"<em class="mw"> w </em>"、"<em class="mw"> o </em>"、"<em class="mw"> r </em>"、"<em class="mw"> l </em>"和"<em class="mw"> d </em>"直到我得到"<em class="mw"> hello world </em>"</p><blockquote class="ll"><p id="b320" class="lm ln jj bd lo lp lq lr ls lt lu lk dk translated">那么这个潜在候选列表是什么，我是怎么得到这本字典的？</p></blockquote><p id="f522" class="pw-post-body-paragraph kn ko jj kp b kq lv ks kt ku lw kw kx ky lx la lb lc ly le lf lg lz li lj lk im bi translated">这是我根据前面的 tpSpell 操作生成的拼写正确的单词列表创建的字典。</p><p id="bd4a" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">也就是说，所有拼写正确的单词都放在这个字典表中，以便我在“解码”每个字符串时查找。</p><h2 id="f821" class="ot nb jj bd nc ou ov dn ng ow ox dp nk ky oy oz no lc pa pb ns lg pc pd nw pe bi translated">“解码”的问题第 2 部分</h2><p id="8089" class="pw-post-body-paragraph kn ko jj kp b kq ny ks kt ku nz kw kx ky oa la lb lc ob le lf lg oc li lj lk im bi translated">要让“解码器”工作，还有其他问题需要解决。</p><p id="6214" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">也就是说，我必须删除停用词，所有形式的标点符号，小写所有单词，只保留父术语。</p><p id="a73e" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">为什么？</p><p id="b9c0" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">因为如果我不这么做，就会有很多问题浮出水面。</p><p id="7554" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">以这句话为例:</p><blockquote class="ll"><p id="1e2a" class="lm ln jj bd lo lp lq lr ls lt lu lk dk translated"><em class="pu">《丛书》</em></p></blockquote><p id="b098" class="pw-post-body-paragraph kn ko jj kp b kq lv ks kt ku lw kw kx ky lx la lb lc ly le lf lg lz li lj lk im bi translated">在“编码”之后，它将是:</p><blockquote class="ll"><p id="8270" class="lm ln jj bd lo lp lq lr ls lt lu lk dk translated"><em class="pu">《系列丛书》</em></p></blockquote><p id="8974" class="pw-post-body-paragraph kn ko jj kp b kq lv ks kt ku lw kw kx ky lx la lb lc ly le lf lg lz li lj lk im bi translated">回想一下，我创建的算法在“解码”过程中采用了<strong class="kp jk"> </strong>字典中的<strong class="kp jk">最长匹配</strong>。</p><p id="2532" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">如果我保留所有停止字，“解码器”会将第一个字解析为“<em class="mw">这些</em>”，而不是“<em class="mw">这些</em>”。</p><p id="a137" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">正因为如此，单词"<em class="mw">se</em><strong class="kp jk"><em class="mw">ries</em></strong>中的下一个字符"<strong class="kp jk"> <em class="mw"> ries </em> </strong>"将不再是我的字典中的一个单词，并将被丢弃。</p><p id="5f72" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">这意味着“解码的”字符串将会以“<em class="mw">这些书</em>”结束，这显然是不正确的。</p><p id="8e3b" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">影响“解码器”的另一个复杂因素如下所示:</p><blockquote class="ll"><p id="7b0d" class="lm ln jj bd lo lp lq lr ls lt lu lk dk translated"><em class="pu">“自行车运动”→“自行车竞技”→“自行车港口”(错误)</em></p></blockquote><p id="322d" class="pw-post-body-paragraph kn ko jj kp b kq lv ks kt ku lw kw kx ky lx la lb lc ly le lf lg lz li lj lk im bi translated">为了解决这个问题，我只在字典表中保留了<strong class="kp jk">父术语</strong>。</p><p id="7fc4" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">例子 1:自行车<strong class="kp jk"> s </strong> →自行车</p><p id="b8ee" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">示例 2:运动<strong class="kp jk"> s </strong> →运动</p><p id="166f" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">通过只查看父术语，我的输出如下所示:</p><blockquote class="ll"><p id="03e4" class="lm ln jj bd lo lp lq lr ls lt lu lk dk translated"><em class="pu">“自行车运动”→“自行车运动”→“自行车运动”(正确)</em></p></blockquote><p id="b573" class="pw-post-body-paragraph kn ko jj kp b kq lv ks kt ku lw kw kx ky lx la lb lc ly le lf lg lz li lj lk im bi translated">因为“<em class="mw">自行车</em> <strong class="kp jk"> <em class="mw"> s </em> </strong>”已经不在我的字典里而“<em class="mw">自行车</em>在，解码器解析正确，<strong class="kp jk">没有</strong>输出“自行车端口”。</p></div><div class="ab cl kg kh hx ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="im in io ip iq"><p id="ee09" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">所以你有它！</p><p id="0bd4" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我自己的“编码器-解码器”方法来清理非常肮脏的非结构化文本！😉</p><p id="c8d8" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">这不是一个完美的解决方案，但它确实足够让我开始我的下游 NLP 任务。</p><h1 id="b309" class="na nb jj bd nc nd qa nf ng nh qb nj nk nl qc nn no np qd nr ns nt qe nv nw nx bi translated">亲眼目睹这一切！</h1><p id="803c" class="pw-post-body-paragraph kn ko jj kp b kq ny ks kt ku nz kw kx ky oa la lb lc ob le lf lg oc li lj lk im bi translated">为了向您展示运行代码后的样子，我对一个存在模拟数据质量问题的图书评论语料库运行了代码。</p><p id="b9c2" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">下面是示例和流程的样子:</p><figure class="mp mq mr ms gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi qf"><img src="../Images/84e326f6719c00d5b3ae3043585b059c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*g8epJYHdGPqd1ARY.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图 4 —数据清理过程正在进行</p></figure></div><div class="ab cl kg kh hx ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="im in io ip iq"><h1 id="d8de" class="na nb jj bd nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx bi translated">结尾注释</h1><p id="ff4a" class="pw-post-body-paragraph kn ko jj kp b kq ny ks kt ku nz kw kx ky oa la lb lc ob le lf lg oc li lj lk im bi translated">嗯，那就这样吧！</p><p id="55f4" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我希望你觉得这篇文章很有见地！😃</p><p id="2627" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">尽管花了将近 2 周的时间尝试了许多方法，但我从中获得了巨大的乐趣！</p><p id="d05f" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">下次见，再见！</p><p id="d401" class="pw-post-body-paragraph kn ko jj kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">领英简介:<a class="ae jg" href="https://www.linkedin.com/in/timothy-tan-97587190" rel="noopener ugc nofollow" target="_blank">蒂莫西·谭</a></p></div></div>    
</body>
</html>