<html>
<head>
<title>The Math Behind “Big O” and Other Asymptotic Notations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">“大O”和其他渐近符号背后的数学</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-math-behind-big-o-and-other-asymptotic-notations-64487889f33f?source=collection_archive---------17-----------------------#2020-05-21">https://towardsdatascience.com/the-math-behind-big-o-and-other-asymptotic-notations-64487889f33f?source=collection_archive---------17-----------------------#2020-05-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5a6c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">像“大O”、“大ω”和“大θ”这样的符号的正式定义。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7f5acd87e0aacaf869d6c006010756bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6lxnj88gFP_zSiUJ3B3_rw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">舒巴姆·莎兰在<a class="ae kv" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="0042" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="ls">大O </em> </strong>(读作“大oh”)是计算机科学中广泛使用的一种数学符号，用于描述算法的效率，无论是计算时间还是内存空间。这个和其他所谓的<em class="ls">渐近符号</em>的主要目的是通过比较它们的“增长顺序”来描述数学函数的行为。</p><p id="361b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我首先简要介绍了大O符号在实践中是如何用来描述算法效率的。后来，我提出了它的数学定义，以及其他类似的符号，如“大ω”(ω)和“大θ”(θ)。此外，我还提供了一些正式的方法，您可以使用这些方法根据这些定义对数学函数进行分类。</p><h1 id="7354" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">简而言之就是“大O”</h1><p id="dda5" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated"><em class="ls">注意:如果你习惯于和算法打交道，你可能以前用过或见过大O符号。如果您认为您已经对大O的含义以及如何用它来描述算法的效率有了大致的了解，那么您可以跳到下一节，在那里您将找到大O和其他类似符号的数学定义。</em></p><p id="b6fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">大O符号通常用于将算法分成几个<em class="ls">基本效率类</em>，比如<em class="ls">O(log(n)】</em>、<em class="ls"> O(n) </em>、<em class="ls"> O(n*log(n)) </em>、<em class="ls"> O(n ) </em>等等。我们说一个标准的<a class="ae kv" href="https://www.geeksforgeeks.org/linear-search/" rel="noopener ugc nofollow" target="_blank">线性搜索</a>算法<em class="ls">在O(n) </em>中运行，因为它的运行时间预计会随着它的输入大小线性增加。同样，我们知道<a class="ae kv" href="https://www.geeksforgeeks.org/binary-search/" rel="noopener ugc nofollow" target="_blank">二进制搜索</a>是<em class="ls"> O(log(n)) </em>，最高效的<a class="ae kv" href="https://www.geeksforgeeks.org/sorting-algorithms/" rel="noopener ugc nofollow" target="_blank">排序算法</a>可以运行在<em class="ls"> O(n*log(n)) </em>。</p><p id="d570" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，说一个算法是<em class="ls"> O(n ) </em>并不意味着它对给定大小为<em class="ls"> n </em>的输入执行精确的<em class="ls"> n </em>运算。假设算法A总是执行<em class="ls"> f(n)=2n +n+1 </em>运算。人们通常对这个函数做的是去掉它的非支配项(像+ <em class="ls"> n </em>和+ <em class="ls"> 1 </em>)和它的常数(像<em class="ls"> 2n </em>中的<em class="ls"> 2 </em>)得到它的渐近符号<em class="ls"> O(n ) </em>。如果有一个算法B总是执行<em class="ls"> f(n)=4n +3n+3 </em>运算，也可以描述为<em class="ls"> O(n ) </em>，虽然它对<em class="ls"> n </em>的任意值执行的运算都是算法A的两倍以上。</p><p id="d0d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但这并没有错。当我们使用像大O这样的渐近符号时，我们感兴趣的是比较增长的顺序，而不是关心精确的数字。此分析的主要目的是描述算法所需的运行时间或内存空间如何根据输入大小<em class="ls"> n </em>增加，尤其是当<em class="ls"> n </em>相当大时。</p><p id="3dda" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果一个算法是<em class="ls"> O(n)，</em>这意味着如果我们将输入大小加倍，那么执行的操作数将是<em class="ls">大约</em>的四倍。通过将<em class="ls"> n=100 </em>增加到<em class="ls"> n=200 </em>，算法A执行的运算次数将从20，101次增加到80，201次，而算法B的运算次数将从40，303次增加到160，603次。每个算法执行的操作数大约乘以<em class="ls">4(尽管不精确)。</em></p><p id="8ae3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，算法是<em class="ls"> O(2ⁿ) </em>或<em class="ls"> O(n！)</em>具有高得多的增长阶数，甚至对于<em class="ls"> n </em>的小值也可以注意到这一点。例如，简单地从<em class="ls"> n=10 </em>到<em class="ls"> n=20 </em>将导致<em class="ls"> O(2ⁿ) </em>算法多执行大约1024次运算。而且，对于一个<em class="ls"> O(n！)</em>算法<em class="ls">，</em>这将意味着比以前多6700亿次运算。</p></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><h1 id="a991" class="lt lu iq bd lv lw mx ly lz ma my mc md jw mz jx mf jz na ka mh kc nb kd mj mk bi translated">渐近符号的形式定义</h1><p id="1e6f" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">如果您不太熟悉大O符号，我希望上面的快速介绍足以让您大致了解像大O这样的渐近符号是如何工作的，以及为什么在评估算法效率时应用这种形式主义如此有意义。如果你觉得你仍然没有完全理解这个概念，也许你应该在进入这篇文章将要讨论的更复杂的数学定义之前，查看其他有额外例子的文章(<a class="ae kv" rel="noopener" target="_blank" href="/understanding-time-complexity-with-python-examples-2bda6e8158a7">像这个</a>)。</p><p id="ba49" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下文中，我将更深入地探讨O在数学上是如何定义的。我还将介绍一些其他类似的渐近符号，它们也在计算机科学中用于评估算法的效率。</p><h2 id="c896" class="nc lu iq bd lv nd ne dn lz nf ng dp md lf nh ni mf lj nj nk mh ln nl nm mj nn bi translated">大O:上限</h2><p id="394c" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">到目前为止，我一直以最常用的方式使用大O符号:作为对算法效率的精确描述。然而，这在技术上是不正确的——正如我将在下面展示的，大O只提供了一种表示<em class="ls">上限的方法。</em>所以请记住，从现在开始，我将根据<em class="ls">对</em>的数学定义来称呼大O，而不是通常在实践中使用的<em class="ls"/>。(如果你有兴趣对这个非常普遍的误解进行更深入的讨论，可以查看<a class="ae kv" href="https://levelup.gitconnected.com/what-big-o-really-means-e5f15044c9d2" rel="noopener ugc nofollow" target="_blank">我之前的这篇文章</a>。)</p><p id="3df8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">非正式地说，<em class="ls"> O(g(n)) </em>可以理解为包含所有不<em class="ls"/><em class="ls"/>比<em class="ls"> g(n) </em>增长更快的<em class="ls">数学函数集合</em>。例如，<em class="ls"> O(n ) </em>是包含<em class="ls"> n +3n </em>、<em class="ls"> 3n </em>、<em class="ls"> n </em>、<em class="ls"> log(n) </em>以及其他无限个当<em class="ls"> n → ∞ </em>时增长速度不超过<em class="ls"> f(n)=n </em>的函数的集合。</p><p id="1e5d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，这里是大O的正式定义:</p><blockquote class="no np nq"><p id="9682" class="kw kx ls ky b kz la jr lb lc ld ju le nr lg lh li ns lk ll lm nt lo lp lq lr ij bi translated">f(n)∈ O(g(n)) <em class="iq">当且仅当存在某个正常数</em> c <em class="iq">和某个非负整数</em> nₒ <em class="iq">使得</em> f(n) ≤ cg(n) <em class="iq">对于所有</em> n ≥ nₒ.</p></blockquote><p id="4ba2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，让我们检查一下<em class="ls"> 3n∈ O(n ) </em>。取<em class="ls"> c=1 </em>并绘制函数<em class="ls"> f(n)=3n </em>和<em class="ls"> cg(n)=1n </em>，我们可以看到两者相交于<em class="ls"> nₒ </em> =3:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/daac56f4765cb6e229f6d1940d283823.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*feeagZ9FyfbzeJ_ZDj_S0Q.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">绘图<em class="nv"> f(n)=3n </em>和<em class="nv"> cg(n)=1n </em>。请注意n∈ℕ，但为了清晰起见，我将功能域标为ℝ。用Matplotlib创建。</p></figure><p id="e5e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看图我们不难看出，对于所有的<em class="ls"> n≥3 </em>来说<em class="ls"> 3n ≤ 1n </em>。但这还不够，因为我们需要实际上<em class="ls">证明</em>这一点。我们可以用<a class="ae kv" href="https://www.mathsisfun.com/algebra/mathematical-induction.html" rel="noopener ugc nofollow" target="_blank">数学归纳法</a>来做。事情是这样的:</p><ol class=""><li id="fb6e" class="nw nx iq ky b kz la lc ld lf ny lj nz ln oa lr ob oc od oe bi translated">我们需要一个基础案例<em class="ls"> nₒ </em>，我们知道<em class="ls"> f(nₒ) ≤ cg(nₒ) </em>。但是我们已经有一个了，因为我们知道我们可以使用nₒ=3。</li><li id="1b99" class="nw nx iq ky b kz of lc og lf oh lj oi ln oj lr ob oc od oe bi translated">然后我们假设对于给定的<em class="ls"> n≥nₒ </em>，f(n)≤cg(n) 。在我们的例子中，我们假设对于给定的<em class="ls"> n≥3 </em>，3n ≤ 1n 。</li><li id="176d" class="nw nx iq ky b kz of lc og lf oh lj oi ln oj lr ob oc od oe bi translated">现在我们需要证明，如果<em class="ls"> f(n)≤cg(n) </em>，那么<em class="ls"> f(n+1) ≤ cg(n+1) </em>。在我们的例子中，我们需要证明如果我们上面的假设(2)成立，那么<em class="ls"> 3(n+1) ≤ (n+1) </em>也成立。这也可以写成<em class="ls"> 3n+3 ≤ n + 2n + 1 </em>。但是，由于我们从(2)中已经知道<em class="ls"> 3n ≤ n </em>，我们可以从不等式的左边减去<em class="ls"> 3n </em>，从右边减去<em class="ls"> n </em>，而不影响它的关系。这就给了我们<em class="ls"> 3 ≤ 2n+1 </em>。我们知道<em class="ls"> n≥3 </em>，只要(2)成立，这个不等式就永远成立。这就完成了对于所有的<em class="ls"> n≥3，</em>以及<em class="ls">3n∈O(n)<em class="ls">3n≤1n</em>的证明。</em></li></ol><p id="ebce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意:对于两个给定的函数<em class="ls"> f(n) </em>和<em class="ls"> g(n) </em>，有一个更方便的方法来检查<em class="ls"> f(n)∈ O(g(n)) </em>。这将在本文中进一步讨论，在我们完成介绍一些其他渐近函数的正式定义之后。</p><p id="6b24" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">大ω(ω):下界</strong></p><p id="0ec3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="ls">大ω</em></strong>的定义方式与大O类似，只不过它代表的是下界而不是上界。因此，它的形式定义只是颠倒了<em class="ls"> f(n) </em>和<em class="ls"> cg(n)之间的关系。</em>换句话说，“≤”变成了“≥”:</p><blockquote class="no np nq"><p id="a39a" class="kw kx ls ky b kz la jr lb lc ld ju le nr lg lh li ns lk ll lm nt lo lp lq lr ij bi translated">f(n)∈ω(g(n))<em class="iq">当且仅当存在某个正常数</em> c <em class="iq">和某个非负整数</em> nₒ <em class="iq">使得</em> f(n)≥cg(n) <em class="iq">对于所有</em> n ≥ nₒ.</p></blockquote><p id="c683" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">举个例子，考虑<em class="ls">n∈ω(2n+n)</em>。为了证明这种说法，你可以试试<em class="ls"> c=1/3 </em>和<em class="ls"> n=1 </em>，使用如上所述的归纳法。这是一个图形表示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/b395f49c8cf289d577b613cdbf7ca773.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*xm7Z-4-hpf84NFPUarKlNA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">绘图<em class="nv"> f(n)=n </em>和<em class="nv"> cg(n)=(1/3)(2n +n) </em>。用Matplotlib创建。</p></figure><p id="9e50" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">大θ(θ):紧界</strong></p><p id="b2a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="ls">位θ</em></strong>用于表示函数的紧界。说<em class="ls">f(n)∈θ(g(n))</em>是指<em class="ls"> f(n) </em>与<em class="ls"> g(n)有<em class="ls">恰好</em> <em class="ls">相同的</em>增长顺序。</em></p><p id="0730" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">基本上，大θ是大O和大ω的交集。基于这一事实，这里有两个关于大θ的简单定义:</p><blockquote class="no np nq"><p id="1391" class="kw kx ls ky b kz la jr lb lc ld ju le nr lg lh li ns lk ll lm nt lo lp lq lr ij bi translated">1)f(n)∈θ(g(n))<em class="iq">当且仅当</em> f(n) ∈ O(g(n)) <em class="iq">和</em>f(n)∈ω(g(n))。</p><p id="802c" class="kw kx ls ky b kz la jr lb lc ld ju le nr lg lh li ns lk ll lm nt lo lp lq lr ij bi translated"><em class="iq">2)</em>θ(g(n))= o(g(n))⋂ω(g(n))。</p></blockquote><p id="a1a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，大θ也可以定义为类似于我们如何定义大O和大ω，通过将两个定义合并在一起:</p><blockquote class="no np nq"><p id="1fec" class="kw kx ls ky b kz la jr lb lc ld ju le nr lg lh li ns lk ll lm nt lo lp lq lr ij bi translated">f(n)∈θ(g(n))<em class="iq">当且仅当存在一些正常数</em> <em class="iq"> c </em> ₁ <em class="iq">和</em> c₂ <em class="iq">和一些非负整数</em> nₒ <em class="iq">使得c</em>₁<em class="iq">g(n)≤</em>f(n)≤c₂g(n)<em class="iq">对于所有</em> n ≥ nₒ.</p></blockquote><p id="a23a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就像我们对大ω做的一样，我们也可以证明<em class="ls">n∈θ(2n+n)。</em>为此，考虑<em class="ls"> c₁=1/3 </em>、<em class="ls"> c₂=1/2 </em>和<em class="ls"> nₒ=1 </em>:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/4f318f893e9a5147707cdf77dc05b937.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*dJyQbFHuBMiAqRJeQmSZfA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">绘图<em class="nv">c</em>₂<em class="nv">g(n)=(1/2)(2n+n)，f(n)=n </em>，以及<em class="nv">c</em>₁<em class="nv">g(n)=(1/3)(2n+n)</em>。用Matplotlib创建。</p></figure><h2 id="ca05" class="nc lu iq bd lv nd ne dn lz nf ng dp md lf nh ni mf lj nj nk mh ln nl nm mj nn bi translated">小ω(ω)和小O (o):松边界</h2><p id="4438" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">没错，渐近符号并不总是很大。还有这两个<em class="ls">小</em>记法:<strong class="ky ir"> <em class="ls">小ω</em></strong>(ω)和<strong class="ky ir"> <em class="ls">小O </em> </strong> (o)。它们没有大的用得多，但是为了完整起见，我喜欢提到它们。</p><p id="e037" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这两种符号用于表示不“紧”的下限或上限。更具体地说，<em class="ls"> ω(g(n)) </em>包括所有在<em class="ls">ω(g(n))</em>中但不在<em class="ls">θ(g(n))</em>中的函数。形式上，<em class="ls">ω(g(n))=ω(g(n))–θ(g(n))</em>。同样，<em class="ls">O(g(n))= O(g(n))–θ(g(n))。</em></p><p id="a84c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">比如<em class="ls"> n ∈ o(n ) </em>，但是<em class="ls"> n ∉ o(n ) </em>。</p><p id="25fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是这两个小符号的正式定义:</p><blockquote class="no np nq"><p id="2c9c" class="kw kx ls ky b kz la jr lb lc ld ju le nr lg lh li ns lk ll lm nt lo lp lq lr ij bi translated">f(n)∈ o(g(n)) <em class="iq">当且仅当存在一个非负整数</em> nₒ <em class="iq">使得</em> f(n)≤cg(n) <em class="iq">对于所有</em> n ≥ nₒ <em class="iq">和对于</em><strong class="ky ir"><em class="iq"/></strong><em class="iq">任何一个正常数</em> <strong class="ky ir"> <em class="iq"> </em> </strong> c</p><p id="4060" class="kw kx ls ky b kz la jr lb lc ld ju le nr lg lh li ns lk ll lm nt lo lp lq lr ij bi translated">f(n)∈ ω(g(n)) <em class="iq">当且仅当存在一个非负整数</em> nₒ <em class="iq">使得</em> f(n)≥cg(n) <em class="iq">对于所有</em> n ≥ nₒ <em class="iq">和对于</em> <strong class="ky ir"> <em class="iq">任何</em> </strong> <em class="iq">正常数</em><strong class="ky ir"/>c</p></blockquote><p id="9afb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你看出区别了吗？虽然对于大ω和大O来说，<em class="ls"> c </em>的单个值就足够了，但是小ω和小O要求属性对于<em class="ls">c</em>的任何值都有效。</p><h1 id="f642" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">使用极限比较两个函数</h1><p id="b187" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在上面的例子中，我已经展示了如何使用数学归纳法来证明对于任意两个函数<em class="ls"> f(n) </em>和<em class="ls"> g(n)】，是否<em class="ls">f(n)∈O(g(n)】</em>。</em>但是有一个更方便的方法来系统地建立两个函数之间的比较，当涉及到它们的增长顺序时<em class="ls">。</em></p><p id="1293" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为此，你需要计算当<em class="ls"> n → ∞时的极限L = <em class="ls"> lim(f(n)/g(n)) </em>。如果存在这样一个极限，当比较<em class="ls"> f(n) </em>和<em class="ls"> g(n) </em>时，它的值马上告诉你哪个渐近符号是有效的:</em></p><ol class=""><li id="f538" class="nw nx iq ky b kz la lc ld lf ny lj nz ln oa lr ob oc od oe bi translated">如果<em class="ls"> L=0 </em>，那么<em class="ls"> f(n)∈ O(g(n)) </em>和<em class="ls"> f(n)∈ o(g(n)) </em>。</li><li id="f025" class="nw nx iq ky b kz of lc og lf oh lj oi ln oj lr ob oc od oe bi translated">如果<em class="ls"> L → ∞ </em>，那么<em class="ls">f(n)∈ω(g(n))</em>和<em class="ls"> f(n)∈ </em> ω <em class="ls"> (g(n)) </em>。</li><li id="fcf3" class="nw nx iq ky b kz of lc og lf oh lj oi ln oj lr ob oc od oe bi translated">对于<em class="ls"> L </em>的其他常数值，则<em class="ls">f(n)∈θ(g(n))</em>。</li></ol><p id="35af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为例子，再考虑一下<em class="ls"> f(n)=n </em>和<em class="ls"> g(n)=2n +n. </em>对于这些函数，你会发现L=1/2，也就是说<em class="ls">n∈θ(2n+n)。(</em>但是注意，根据定义，它也意味着<em class="ls">n∈ω(2n+n)</em>和<em class="ls"> n ∈ O(2n +n)。)</em></p></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><h1 id="7350" class="lt lu iq bd lv lw mx ly lz ma my mc md jw mz jx mf jz na ka mh kc nb kd mj mk bi translated">最后的想法</h1><p id="1662" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">为了使用像大O这样的渐近符号，你并不需要对它们背后的数学有深入的理解。然而，知道它们的含义和定义可能是有用的，特别是当两个函数之间的关系不是很明显的时候。<em class="ls">θ(log(n))</em>比<em class="ls">θ(√n)</em>快吗？<em class="ls"> O(2ⁿ) </em>和<em class="ls"> O(3ⁿ) </em>一样吗？ω<em class="ls">(log₂(n))</em><em class="ls">ω(ln(n))</em>呢？现在你知道了这些符号是如何被数学定义的，你可以试着自己去寻找这类问题的答案。</p></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><h1 id="91a2" class="lt lu iq bd lv lw mx ly lz ma my mc md jw mz jx mf jz na ka mh kc nb kd mj mk bi translated">参考</h1><ul class=""><li id="cd8f" class="nw nx iq ky b kz ml lc mm lf ok lj ol ln om lr on oc od oe bi translated"><a class="ae kv" href="https://www.amazon.com/gp/product/0201743957/ref=as_li_tl?ie=UTF8&amp;tag=chaulio0b-20&amp;camp=1789&amp;creative=9325&amp;linkCode=as2&amp;creativeASIN=0201743957&amp;linkId=aff0d43922d6a31ae64de969b8441371" rel="noopener ugc nofollow" target="_blank">Anany Levitin的设计介绍&amp;算法分析</a>。</li></ul></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><p id="b455" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">披露:这篇文章包含一个或多个亚马逊服务有限责任公司协会项目的链接。作为代销商，我从通过这些链接购买的商品中获得佣金，客户无需支付额外费用。</em></p></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><h1 id="8b20" class="lt lu iq bd lv lw mx ly lz ma my mc md jw mz jx mf jz na ka mh kc nb kd mj mk bi translated">相关文章</h1><div class="oo op gp gr oq or"><a href="https://levelup.gitconnected.com/what-big-o-really-means-e5f15044c9d2" rel="noopener  ugc nofollow" target="_blank"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd ir gy z fp ow fr fs ox fu fw ip bi translated">“大O”的真正含义是什么</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">大多数时候，大O符号的用法都有点不正确。</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="pa l"><div class="pb l pc pd pe pa pf kp or"/></div></div></a></div><div class="oo op gp gr oq or"><a href="https://levelup.gitconnected.com/8-ways-to-measure-execution-time-in-c-c-48634458d0f9" rel="noopener  ugc nofollow" target="_blank"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd ir gy z fp ow fr fs ox fu fw ip bi translated">C/C++中测量执行时间的8种方法</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">不幸的是，没有放之四海而皆准的解决方案。在这里你会找到一些可用的选项。</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="pa l"><div class="pg l pc pd pe pa pf kp or"/></div></div></a></div><div class="oo op gp gr oq or"><a rel="noopener follow" target="_blank" href="/understanding-time-complexity-with-python-examples-2bda6e8158a7"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd ir gy z fp ow fr fs ox fu fw ip bi translated">通过Python示例理解时间复杂性</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">如今，面对我们每天消耗和生成的所有这些数据，算法必须足够好才能处理…</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">towardsdatascience.com</p></div></div><div class="pa l"><div class="ph l pc pd pe pa pf kp or"/></div></div></a></div></div></div>    
</body>
</html>