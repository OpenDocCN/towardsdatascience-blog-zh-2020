# NumPy 速成班——从零到英雄

> 原文：<https://towardsdatascience.com/numpy-crash-course-zero-to-hero-c1788a8a48ac?source=collection_archive---------41----------------------->

## 对于那些有 Python 经验但想学习 NumPy 的人来说，这是你必须去的地方

![](img/850262146bf8e098e9c9fc3c30e96cca.png)

尼克·希利尔在 [Unsplash](https://unsplash.com/collections/10620294/medium-shortlist?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上的照片

本文的目的是向任何具有 Python 知识的人提供一个关于 numPy 功能的快速速成课程，以及他们应该根据自己的用例详细阅读的内容。

## 什么？怎么会？为什么？

在我们开始探索 numPy 之前，让我们回答任何人都会想到的 3 个基本问题:

*   什么是 numPy？
*   人们为什么使用 numPy？
*   numPy 是怎么写的？

## 什么是 numPy？

numPy 或 numerical Python 是一个库，用于高级数学计算，同时保持高水平的性能。根据维基百科，“NumPy 是 Python 编程语言的库，增加了对大型多维数组和矩阵的支持，以及对这些数组进行操作的大量高级数学函数”

## 人们为什么使用 numPy？

数字有很多不同的用途。让我们列出其中的一些:

*   与 Python 列表相比，它有一个高效的存储机制
*   能够指定 numPy 数组的数据类型
*   更快的操作 numPy 数组上的操作比 Python 列表上的操作更快，主要是因为它的同质性
*   n 维数组的创建和操作——Python 列表在多维中是非常原始的，而 numPy 使这方面的工作变得非常容易
*   随机数据的创建——numPy 可以创建几乎符合所能想到的规范的随机数据，这在许多不同的情况下都非常有用

## numPy 是怎么写的？

*   numPy 是用 C 编写的，是 SciPy 项目的一部分，但后来被分离出来，因为用户不希望仅仅为了 numPy 提供的数组操作而安装庞大的 SciPy 包

## 设置 numPy

```
>> import numpy as np
```

numpy 作为 **np** 进口的唯一原因是惯例。你可以自由地使用另一个别名，但不推荐使用，因为这是你在任何地方都能找到的别名，最好坚持使用标准

```
>> np.__version__'1.18.1'
```

## 钕阵列

numpy 速度快的主要原因是它使用 nd-array 类型来存储和操作数据

ndarray 是同构数据的通用多维容器。它提供了矢量化的算术运算和复杂的广播功能。每个 ndarray 都有两个属性:shape 和 dtype。shape 是一个元组，提供数组的维度，dtype 提供数组的数据类型。

在定义数组时，也可以显式指定数组的 dtype，从而对数组进行微调控制。

让我们从一个数组创建一个 numpy 数组。这可以通过将数组作为输入传递给函数 *np.array* 来实现

```
>> nparray = np.array([1,2,3])array([1, 2, 3])
```

numpy 数组有许多属性，这些属性提供了关于它们的更多信息。

**数组的数据类型**

```
>> nparray.dtypedtype('int32')
```

**数组的大小**

```
>> nparray.size3
```

**阵列的形状**

```
>> nparray.shape(3,)
```

下面两个单元的代码保证了详细的解释。 *itemsize* 参数返回数组中单个项目的大小。在这种情况下，我们有一个整数数组，它为单个项目占用 32 位空间，这相当于 4 个字节(1 字节= 8 位)。下面的单元格展示了 *nbytes* 参数，该参数返回整个数组的字节大小，从而提供了一个 12 字节的值(4 字节* 3 项)。

简而言之: *itemsize* 提供数组中单个项目的大小，而 *nbytes* 返回整个数组的大小。

```
>> nparray.itemsize4>> nparray.nbytes12
```

numpy 的 nd-array 比 Python 的原生 list 快是有原因的。让我们在下面的单元格中深入了解这一点

```
>> %timeit pythonList = [i for i in range(10000)]545 µs ± 24 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)>> %timeit npList = np.arange(10000)7.82 µs ± 256 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
```

numpy 数组是同构的，在内存中处理速度更快。现在将它与 Python 列表进行比较，在 Python 列表中可以放入任何东西；Python 列表中的每个条目都是一个 Python 对象，这导致了计算开销。这是 numpy 数组比传统 Python 列表快得多的主要原因

现在让我们看看使 numpy 成为一个灵活方便的库的一些函数。

## 使用 numpy 生成数据

*arange* 生成所传递数字范围内的数字列表

```
>> np.arange(10)array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
```

*linspace* 返回作为输入传递的范围内的一组线性间隔的项目。在 linspace 中，起始位、结束位以及作为输入传递的所需位数。基本上，它返回一个数组，该数组具有指定间隔内所需的位数

```
>> np.linspace(0, 10, 5)array([ 0\. ,  2.5,  5\. ,  7.5, 10\. ])
```

T21 创建了一个充满 1 的数组。作为输入传递的参数是所需数组的大小

```
>> np.ones(5)array([1., 1., 1., 1., 1.])
```

*零*创建一个用零填充的数组。作为输入传递的参数是所需数组的大小

```
>> np.zeros(5)array([0., 0., 0., 0., 0.])
```

*zeros_like* 创建一个与作为输入传递的数组大小相同的数组。生成的数组将以零作为元素

```
>> np.zeros_like(np.arange(5))array([0, 0, 0, 0, 0])
```

*眼*创建一个单位矩阵。生成的矩阵将是作为输入传递的整数的维数

```
>> np.eye(5)array([[1., 0., 0., 0., 0.],
       [0., 1., 0., 0., 0.],
       [0., 0., 1., 0., 0.],
       [0., 0., 0., 1., 0.],
       [0., 0., 0., 0., 1.]])
```

创建一个用垃圾值填充的数组，通常是零。作为输入传递的参数是所需数组的大小

```
>> np.empty(5) array([1., 1., 1., 1., 1.])
```

## 索引

在索引和切片方面，numpy 遵循 Python 的常规规则。我在下面列出了几个例子，你可以尝试一下:

```
>> nparray[1]2>> nparray[-1]3
```

## 限幅

```
>> nparray[1:2]array([2])>> nparray[:2]array([1, 2])>> nparray[:]array([1, 2, 3])>> nparray[1:]array([2, 3])>> largeArray = np.arange(100)>> largeArray[::20]array([ 0, 20, 40, 60, 80])>> largeArray[1:10:2]array([1, 3, 5, 7, 9])>> largeArray[::-20]array([99, 79, 59, 39, 19])>> largeArray[10:1:-2]array([10,  8,  6,  4,  2])
```

在 numpy 中使用切片时要记住的一件重要事情是，切片本质上是引用(视图),因此，您对切片数据所做的任何更改都会反映在父数据中。让我们看一个例子

```
>> smallArray = largeArray[:10]>> smallArrayarray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])>> largeArray[:10]array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])>> smallArray[0] = 666>> smallArrayarray([666,   1,   2,   3,   4,   5,   6,   7,   8,   9])>> largeArray[:10]array([666,   1,   2,   3,   4,   5,   6,   7,   8,   9])
```

copy()方法可以用来创建副本，而不是这样的视图

## 轴线

numpy 数组可以是多维的。它还使您能够将现有数组更改为您喜欢的形状，前提是它满足多个约束

*重塑*让你完全按照名字说的去做。它允许您将数组调整为作为输入传递的维度。如果您没有传递一个可以对数组进行整形的维度，那么该函数将返回一个错误。比方说，该数组有 10 个元素，您试图将其整形为形状为 3x5 的数组，那么整形将返回一个错误

```
>> np.arange(1, 7).reshape((2, 3))array([[1, 2, 3],
       [4, 5, 6]])>> np.arange(1, 4)array([1, 2, 3])>> np.arange(1, 4).reshape(1,3)array([[1, 2, 3]])
```

*newaxis* 用于在数据中创建新轴。它通常在研究建模技术时使用，因为模型要求数据以某种方式成形。如下图所示，如果 *newaxis* 参数位于第一个位置，那么将会生成一个新的行向量。如果在第二个位置，那么将创建一个列，每个元素是一个单独的向量。

```
>> np.arange(1, 4)[np.newaxis, :]array([[1, 2, 3]])>> np.arange(1, 4)[:, np.newaxis]array([[1],
       [2],
       [3]])
```

## 数组串联

可以使用 *concatenate* 方法在 numpy 中连接数组。要连接的数组列表将作为输入传递给 concatenate 函数。

```
>> np.concatenate([smallArray, largeArray])array([666,   1,   2,   3,   4,   5,   6,   7,   8,   9, 666,   1,   2,
         3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,  15,
        16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,  28,
        29,  30,  31,  32,  33,  34,  35,  36,  37,  38,  39,  40,  41,
        42,  43,  44,  45,  46,  47,  48,  49,  50,  51,  52,  53,  54,
        55,  56,  57,  58,  59,  60,  61,  62,  63,  64,  65,  66,  67,
        68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  78,  79,  80,
        81,  82,  83,  84,  85,  86,  87,  88,  89,  90,  91,  92,  93,
        94,  95,  96,  97,  98,  99])>> np.concatenate([smallArray, largeArray, [888, 999]])array([666,   1,   2,   3,   4,   5,   6,   7,   8,   9, 666,   1,   2,
         3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,  15,
        16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,  28,
        29,  30,  31,  32,  33,  34,  35,  36,  37,  38,  39,  40,  41,
        42,  43,  44,  45,  46,  47,  48,  49,  50,  51,  52,  53,  54,
        55,  56,  57,  58,  59,  60,  61,  62,  63,  64,  65,  66,  67,
        68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  78,  79,  80,
        81,  82,  83,  84,  85,  86,  87,  88,  89,  90,  91,  92,  93,
        94,  95,  96,  97,  98,  99, 888, 999])
```

## 数字函数

Ufunc 的主要目的是能够加速对 numpy 数组中的值的重复操作。它既可以在一个标量值和一个数组之间工作，也可以在两个数组之间工作

```
>> 3 * np.arange(0, 10)array([ 0,  3,  6,  9, 12, 15, 18, 21, 24, 27])>> np.arange(0, 10) + np.arange(20, 30)array([20, 22, 24, 26, 28, 30, 32, 34, 36, 38])
```

这不仅在语法上更好更直观，而且速度更快。让我们在下面尝试一下

```
>> %timeit 3 * smallArray1.22 µs ± 61.4 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each)>> %%timeit

>> for i in range(len(smallArray)):
       3 * smallArray[i]7.15 µs ± 182 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
```

从上面可以看出，ufunc 比循环版本的代码快很多倍。随着所涉及的计算逻辑变得越来越复杂，这种差异变得越来越明显

## 聚合

在这一节中，我们将探索 numpy 提供的各种聚合函数。numpy 附带了一个标准的 *sum()* 函数，该函数返回数组中所有元素的总和。你可能会问，原生 Python 函数和 numpy 函数有什么区别！毕竟他们做的是同样的功能；提供元素的总和。下面就来看看吧

```
>> np.sum(smallArray)711>> sum(smallArray)711>> hugeArray = np.random.randint(100000, size=1000000)
>> %timeit np.sum(hugeArray)
>> %timeit sum(hugeArray)526 µs ± 9.48 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)
271 ms ± 11 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
```

从上面的代码块可以明显看出，与原生函数相比，numpy 的速度有多快。这适用于 numpy 中可用的大多数(如果不是全部)聚合函数

```
>> np.min(smallArray)1>> np.max(smallArray)666>> np.std(smallArray)198.31512801599376>> np.mean(smallArray)71.1np.median(smallArray)5.5
```

使用聚合函数时需要注意的一点是，在您使用它们时，这些函数容易出现 NaN 值，也就是说，如果您的数组中有 NaN 值，这些聚合函数将会失败。在这种情况下，您可以使用它们的 NaN 安全替代方案。给你一个例子:nansum()是 sum 函数的 NaN-safe 替代

```
>> np.nanmean(np.array([1, 2, np.nan]))1.5>> np.mean(np.array([1, 2, np.nan]))nan
```

## 广播

我们现在要看一个你可能经常使用但没有概念上的理解的操作。在广播中，对具有不同形状/尺寸的实体执行操作。

一个简单的例子是向 numpy 数组添加一个标量。基本上，您可以认为复制的值是为了匹配数组的维数，然后是要执行的操作。

广播是一个可以详细阐述的操作，但这不是我这篇文章的目标

```
>> a = np.arange(1, 7)
>> aarray([1, 2, 3, 4, 5, 6])>> a + 1array([2, 3, 4, 5, 6, 7])
```

## 逻辑运算

有时候，您会希望对一段数据执行逻辑检查。numpy 提供了您所期望的所有常规逻辑操作:大于、小于和等于检查。逻辑函数返回一组布尔值结果，表明它们是否满足条件

```
>> x = np.array([1, 2, 3, 4])>> x > 2array([False, False,  True,  True])>> x == 2array([False,  True, False, False])
```

numpy 还提供了一些有用的函数，比如 any()和 all()，用于执行以下检查:是否有任何元素满足条件，或者是否所有元素都满足条件。它们提供一个布尔值作为输出来指示结果

```
>> np.any(x == 2)True>> np.all(x == 2)False
```

从以上两个代码块中；可以理解以下内容:

*   any(x == 2):检查数组中的元素是否满足传递的条件
*   all(x == 2):它检查数组中的所有元素是否满足传递的条件

假设我们需要满足这个特定条件的值的计数，您可以使用 sum()方法，如下所示。它计算数组中真值的数量

```
>> np.sum(x == 2)1
```

这也可以组合起来检查多种情况。对于*的任何*和*的所有*功能，也可以进行同样的操作

```
>> np.sum((x == 2) | (x == 3))2>> np.any((x == 2) | (x == 3))True
```

## 掩饰

您可能已经看到了上面的以布尔数组形式提供值的数组，并且想知道这有什么帮助，因为您仍然需要提供进一步的操作来理解输出。这就是掩蔽的用武之地；真/假数组可以通过*传入*数组，只提供那些满足条件的值

```
>> x[x == 2]array([2])>> x[x > 2]array([3, 4])
```

## 花式索引

花哨的索引不过是一次访问数组中多个元素的能力

```
>> xarray([1, 2, 3, 4])>> x[[0, 2, 3]]array([1, 3, 4])
```

您可能已经猜到了，我们也可以将一个数组作为索引列表传入

```
>> indexList = [0, 2, 3]
>> x[indexList]array([1, 3, 4])
```

当它与切片、索引和广播等技术相结合时，花式索引的真正威力就显现出来了

## 整理

numpy 提供的排序算法非常高效。有两种方法可以对 numpy 数组进行排序；并通过调用返回排序数组的 numpy 排序函数

让我们首先打乱我们的数组，以便我们可以对它进行排序和处理

```
>> np.random.shuffle(x)
>> xarray([1, 3, 4, 2])
```

在数组上调用 *np.sort* 将返回一个已排序的数组副本，但不会对数组进行排序，如下所示

```
>> np.sort(x)array([1, 2, 3, 4])>> xarray([1, 3, 4, 2])
```

如果你在数组上调用 *sort* ，那么数组将被就地排序，没有必要保存到另一个数组。这两种方法执行相同的功能，并且根据所需的用例来使用

```
>> x.sort()
>> xarray([1, 2, 3, 4])
```

## 结束语

numPy 有更多的功能，尤其是在高维数据方面。numPy 可以轻松地处理和操作更高维度的数据。我还没有决定进入这样的细节，因为这将挫败这个职位的目的。

我已经用这个博客的全部内容编辑了一个笔记本。

有很多事情我没有涉及，因为它超出了本博客的范围，但是，如果你有兴趣阅读更多关于 numpy 的内容，我强烈推荐以下资源:

*   [Python 数据科学手册](https://jakevdp.github.io/PythonDataScienceHandbook/)——《数据科学手册》是 Dat 科学领域非常受欢迎的书籍，其电子书版本免费提供。它会让你更详细地了解 numpy，如果你感兴趣，还有 pandas，matplotlib & scikit-learn
*   [用于数据分析的 Python](http://shop.oreilly.com/product/0636920023784.do)——由熊猫的创造者撰写，你可以通过这本书深入了解 numpy 的用法示例
*   当然， [numpy 文档](https://numpy.org/doc/) —如果你是一个经验丰富的开发人员，并且确切地知道你在寻找什么，你可以直接去 numpy 文档，因为它有许多用户指南和教程，而不仅仅是一个托管参考文档的网站