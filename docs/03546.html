<html>
<head>
<title>Multivariate time series forecasting</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">多元时间序列预测</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/multivariate-time-series-forecasting-653372b3db36?source=collection_archive---------3-----------------------#2020-04-04">https://towardsdatascience.com/multivariate-time-series-forecasting-653372b3db36?source=collection_archive---------3-----------------------#2020-04-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="41ee" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Python中向量自回归(VAR)的实现</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/40a0fad9949a0cf3f6800481aae4b327.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yH8y9MA1W4aVoSMB"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@aronvisuals?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿伦视觉</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="ffe0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用时间序列数据来了解过去和预测未来是经济和公共服务的每个部门的商业决策的一个基本部分。零售企业需要了解下个月他们需要多少存货；电力公司需要知道他们是否应该增加容量以跟上未来10年的需求；呼叫中心需要知道他们是否应该雇佣新员工来应对更高的呼叫量——所有这些决策都需要进行短期和长期预测，而时间序列数据分析是预测过程的重要组成部分。</p><p id="9bae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">单变量时间序列建模是最常用的预测方法。例如，如果您知道历史收入数据的增长率、趋势和季节性，您就可以预测未来一段时间的收入。然而，这一过程背后有一个很大的假设，即影响收入的所有其他因素(如产品需求)将继续以类似的方式产生影响。但是，当影响产品需求的因素发生变化时(例如，新的竞争产品进入市场)，这种假设往往会失效。理解这种复杂的行为需要的不仅仅是简单的单变量时间序列预测，这就是多变量时间序列分析发挥作用的地方。</p><p id="fafc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文的目的是逐步实现一种叫做<a class="ae ky" href="https://www.statsmodels.org/dev/vector_ar.html" rel="noopener ugc nofollow" target="_blank">向量自回归</a> (VAR)的多元时间序列预测技术。首先，我会给出一个直觉，并展示它如何在一个简短的4步实施中工作，然后我会像一个典型的机器学习算法实施一样稍微深入一点，例如探索性数据分析和可视化，将数据分成训练和测试集，模型构建，性能评估等。</p><p id="339e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以让我们开始吧。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ee82" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">简短版</h1><p id="f3f2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">短版真的很短；不应该超过10行Python代码，我只用4个简单的步骤就展示了这些代码</p><p id="c235" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 1)导入库</strong></p><p id="e9a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此时只需要两个库:<code class="fe mz na nb nc b">pandas</code>用于处理数据，和<code class="fe mz na nb nc b">statmodels</code> API用于导入向量自回归模型。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="b6e3" class="nh md it nc b gy ni nj l nk nl">import pandas as pd<br/>import statsmodels.api as sm<br/>from statsmodels.tsa.api import VAR</span></pre><p id="b0ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 2)加载数据:</strong></p><p id="9285" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我正在从<code class="fe mz na nb nc b">statsmodels</code> API加载一个玩具数据集。该数据有几个变量，但我只加载其中的几个进行演示。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="9bc9" class="nh md it nc b gy ni nj l nk nl">macrodata = sm.datasets.macrodata.load_pandas().data<br/>data = macrodata.iloc[:, 2:4]<br/>data.tail(2)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/6a0dde3b0c6ae9c7373790a4fba59249.png" data-original-src="https://miro.medium.com/v2/resize:fit:392/format:webp/1*wUsTpPndYusRcQnHa_s8KQ.png"/></div></figure><p id="baef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 3)合体模特</strong></p><p id="c516" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，用<code class="fe mz na nb nc b">VAR()</code>实例化模型，然后用<code class="fe mz na nb nc b">fit()</code>方法拟合模型。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="cfec" class="nh md it nc b gy ni nj l nk nl">model = VAR(data)<br/>model_fit = model.fit()</span></pre><p id="58eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 4)做一个预测</strong></p><p id="8248" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您可以使用模型提前一步进行预测了。结果打印出两个变量的数组。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="dfb8" class="nh md it nc b gy ni nj l nk nl">pred = model_fit.forecast(model_fit.y, steps=1)<br/>print(pred)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/2e942399d4ed40e9c346f79fa7c4ab7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/format:webp/1*5m89mqTu2pmZD2HzGfKf6Q.png"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bbb6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">长篇版本</h1><p id="7c05" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">短版本很短，但长版本可能很长，这取决于你想在哪里停下来。您可以从将时间序列数据转换成一个<em class="no"> ts </em>对象开始，根据项目目标，进行各种各样的<a class="ae ky" rel="noopener" target="_blank" href="/introduction-to-interactive-time-series-visualizations-with-plotly-in-python-d3219eb7a7af">时间序列EDA </a>(探索性数据分析)来调整和评估模型性能。</p><h2 id="f668" class="nh md it bd me np nq dn mi nr ns dp mm li nt nu mo lm nv nw mq lq nx ny ms nz bi translated">1)导入库</h2><p id="ba06" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">所需的初始库集与“短”版本相同，但是我们添加了一个绘图库<code class="fe mz na nb nc b">matplotlib</code>来可视化时间序列对象。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="e8db" class="nh md it nc b gy ni nj l nk nl"># loading essential libraries first<br/>import pandas as pd<br/>import statsmodels.api as sm<br/>from statsmodels.tsa.api import VAR<br/>import matplotlib.pyplot as plt</span></pre><h2 id="f8ad" class="nh md it bd me np nq dn mi nr ns dp mm li nt nu mo lm nv nw mq lq nx ny ms nz bi translated">2)导入、检查和争论数据</h2><p id="a1e3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">导入数据后，您应该经历您通常的数据争论仪式(选择感兴趣的列、重命名、汇总统计等。).但是一个必要的步骤是找出是否有NA值，如果有，你需要处理它们(<a class="ae ky" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/missing_data.html" rel="noopener ugc nofollow" target="_blank">见这里</a>)。作为数据争论的一部分，出于可视化的目的，您可能还想以不同的方式分割/转换数据。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="485a" class="nh md it nc b gy ni nj l nk nl"># data<br/>mdata = sm.datasets.macrodata.load_pandas().data<br/>df  = mdata.iloc[:, 2:4]<br/>df.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/5abfe902dc4d1818cae699aa18b864fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:344/format:webp/1*ul09tQuWwJk5BG6b2Mq1pg.png"/></div></figure><h2 id="ccbe" class="nh md it bd me np nq dn mi nr ns dp mm li nt nu mo lm nv nw mq lq nx ny ms nz bi translated">3)想象</h2><p id="f4fd" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果您想对时间序列数据进行EDA，您还需要做一些额外的工作，比如将数据转换成时间序列对象。但至少，您可能希望将数据可视化，以查看趋势线的样子以及它们之间的比较。它为您提供了模型评估所需的必要直觉。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="32f4" class="nh md it nc b gy ni nj l nk nl">plt.plot(df)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/39b9e8815c6aa0251432329ee21461d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/format:webp/1*50n0jT1fVeul-w0JJyd73Q.png"/></div></div></figure><h2 id="a3b5" class="nh md it bd me np nq dn mi nr ns dp mm li nt nu mo lm nv nw mq lq nx ny ms nz bi translated">3)因果关系测试</h2><p id="0def" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">你会想看看变量之间是否有关联。为此，你可以运行格兰杰因果关系测试。虽然顾名思义，这真的不是一个“因果关系”的测试，你不能说一个是另一个的原因，你只能说变量之间是否有关联。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="6aeb" class="nh md it nc b gy ni nj l nk nl"># import for Granger's Causality Test<br/>from statsmodels.tsa.stattools import grangercausalitytests</span><span id="0283" class="nh md it nc b gy oc nj l nk nl">granger_test = sm.tsa.stattools.grangercausalitytests(df, maxlag=2, verbose=True)<br/>granger_test</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/e6fc58881ebc1aed052b5423814a770c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1178/format:webp/1*DBAbI7BMfjAmyZK_1ozmGA.png"/></div></figure><h2 id="6033" class="nh md it bd me np nq dn mi nr ns dp mm li nt nu mo lm nv nw mq lq nx ny ms nz bi translated">4)拆分数据</h2><p id="28c9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">与大多数机器学习算法一样，将数据分成训练集和测试集是一个好主意。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="8409" class="nh md it nc b gy ni nj l nk nl">nobs = 4<br/>df_train, df_test = df[0:-nobs], df[-nobs:]</span></pre><h2 id="cddb" class="nh md it bd me np nq dn mi nr ns dp mm li nt nu mo lm nv nw mq lq nx ny ms nz bi translated">5a)检查稳定性</h2><p id="d82d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">对于时间序列建模，数据需要是静态的——这意味着如果数据中有趋势，你需要摆脱它。为了检查数据是否是稳定的，有一种测试叫做扩展的Dickey-Fuller (ADF)测试。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="12a4" class="nh md it nc b gy ni nj l nk nl"># Augmented Dickey-Fuller Test (ADF Test)/unit root test<br/>from statsmodels.tsa.stattools import adfuller</span><span id="49e5" class="nh md it nc b gy oc nj l nk nl">def adf_test(ts, signif=0.05):<br/>    dftest = adfuller(ts, autolag='AIC')<br/>    adf = pd.Series(dftest[0:4], index=['Test Statistic','p-value','# Lags','# Observations'])<br/>    for key,value in dftest[4].items():<br/>       adf['Critical Value (%s)'%key] = value<br/>    print (adf)<br/>    </span><span id="fd28" class="nh md it nc b gy oc nj l nk nl">    p = adf['p-value']</span><span id="c93c" class="nh md it nc b gy oc nj l nk nl">    if p &lt;= signif:<br/>        print(f" Series is Stationary")<br/>    else:<br/>        print(f" Series is Non-Stationary")</span><span id="7dd2" class="nh md it nc b gy oc nj l nk nl">#apply adf test on the series<br/>adf_test(df_train["realgdp"])<br/>adf_test(df_train["realcons"])</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/e04541c9985e28e1f3af2b6bbd170dce.png" data-original-src="https://miro.medium.com/v2/resize:fit:566/format:webp/1*zNCZ2dYbqC17i7CVjz-Wsg.png"/></div></figure><h2 id="d027" class="nh md it bd me np nq dn mi nr ns dp mm li nt nu mo lm nv nw mq lq nx ny ms nz bi translated">5b)制作数据文具</h2><p id="cd8e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果数据不是稳定的，你可以用几种方法，但最简单的一种是采用<a class="ae ky" href="https://people.duke.edu/~rnau/411diff.htm" rel="noopener ugc nofollow" target="_blank">一阶差分</a>。在进行第一次差分后，您需要返回到上一步，再次测试数据现在是否是稳定的。如果不是，第二个区别可能是必要的。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="699a" class="nh md it nc b gy ni nj l nk nl"># 1st difference<br/>df_differenced = df_train.diff().dropna()</span><span id="22cd" class="nh md it nc b gy oc nj l nk nl"># stationarity test again with differenced data<br/>adf_test(df_differenced["realgdp"])</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/15bb0a985a34941248f7d84ac57297b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:622/format:webp/1*b10QYM2JIp9WOsMVLluLJQ.png"/></div></figure><h2 id="4bd4" class="nh md it bd me np nq dn mi nr ns dp mm li nt nu mo lm nv nw mq lq nx ny ms nz bi translated">6)建模</h2><p id="3cdd" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在，您可以用<code class="fe mz na nb nc b">VAR()</code>实例化模型，然后使模型适合第一个差异数据。运行模型后，您可以查看下面的总结结果。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="1955" class="nh md it nc b gy ni nj l nk nl"># model fitting<br/>model = VAR(df_differenced)<br/>results = model.fit(maxlags=15, ic='aic')<br/>results.summary()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/abc735bb529c74ae232a6fcc4692c17a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*-fwKs0-8Y2lRU86UvtJJ7Q.png"/></div></figure><h2 id="08a7" class="nh md it bd me np nq dn mi nr ns dp mm li nt nu mo lm nv nw mq lq nx ny ms nz bi translated">7)预测</h2><p id="c636" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">既然你已经建立了你的模型，是时候玩它并做实际的预测了。在这里，我要求模型预测未来5步。该模型为这两个变量返回5个预测值的数组。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="6c31" class="nh md it nc b gy ni nj l nk nl"># forecasting<br/>lag_order = results.k_ar<br/>results.forecast(df.values[-lag_order:], 5)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/1bc0bcf9d20f80fe942780eb2a3e9886.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/format:webp/1*MUFlweqxgNL9zrrEk_EZKA.png"/></div></figure><h2 id="9c13" class="nh md it bd me np nq dn mi nr ns dp mm li nt nu mo lm nv nw mq lq nx ny ms nz bi translated">8)绘图</h2><p id="c40e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在可以绘制预测值以及相关的标准误差。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="edd1" class="nh md it nc b gy ni nj l nk nl"># plotting<br/>results.plot_forecast(20)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/53d291ac30197f0668b6d8bf8892a002.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/format:webp/1*TAJgsKJlMHC8kHQr0fbLQg.png"/></div></figure><h2 id="4336" class="nh md it bd me np nq dn mi nr ns dp mm li nt nu mo lm nv nw mq lq nx ny ms nz bi translated">9)评估</h2><p id="ed23" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这是使用<code class="fe mz na nb nc b">fevd()</code>函数的预测误差方差分解(FEVD)方法评估预测模型的额外步骤。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="e5a4" class="nh md it nc b gy ni nj l nk nl"># Evaluation<br/>fevd = results.fevd(5)<br/>fevd.summary()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/e1623239eef6b7bbf479e013352cebd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:392/format:webp/1*BqAZgkmTzfauAO16JfdkgQ.png"/></div></figure><h2 id="9ee6" class="nh md it bd me np nq dn mi nr ns dp mm li nt nu mo lm nv nw mq lq nx ny ms nz bi translated">10)反转</h2><p id="0cea" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">还有最后一步。您没有使模型适合原始数据，因为您必须在步骤5b中转换(第一次差分)它以使数据稳定。所以预测结果需要倒回到原来的形式。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="9021" class="nh md it nc b gy ni nj l nk nl"># forecasting<br/>pred = results.forecast(results.y, steps=nobs)<br/>df_forecast = pd.DataFrame(pred, index=df.index[-nobs:], columns=df.columns + '_1d')<br/>df_forecast.tail()</span><span id="71d3" class="nh md it nc b gy oc nj l nk nl"># inverting transformation<br/>def invert_transformation(df_train, df_forecast, second_diff=False):<br/>    """Revert back the differencing to get the forecast to original scale."""<br/>    df_fc = df_forecast.copy()<br/>    columns = df_train.columns<br/>    for col in columns:        <br/>        # Roll back 2nd Diff<br/>        if second_diff:<br/>            df_fc[str(col)+'_1d'] = (df_train[col].iloc[-1]-df_train[col].iloc[-2]) + df_fc[str(col)+'_1d'].cumsum()<br/>        # Roll back 1st Diff<br/>        df_fc[str(col)+'_forecast'] = df_train[col].iloc[-1] + df_fc[str(col)+'_1d'].cumsum()<br/>    return df_fc</span><span id="6c4b" class="nh md it nc b gy oc nj l nk nl"># show inverted results in a dataframe<br/>df_results = invert_transformation(df_train, df_forecast, second_diff=True)        <br/>df_results.loc[:, ['realgdp_forecast', 'realcons_forecast']]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/c56947b5590da4c33298ef4668660e6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:538/format:webp/1*FLrghIaEimwUl_ae2sxFcg.png"/></div></figure><h1 id="d0c8" class="mc md it bd me mf ok mh mi mj ol ml mm jz om ka mo kc on kd mq kf oo kg ms mt bi translated">离别笔记</h1><p id="c7fd" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">时间序列数据分析是商业决策的基本组成部分，因此决策者和数据科学家/分析师可以从对预测模型机制的某种程度的熟悉中受益。文章首先介绍了多元时间序列的概念及其在不同行业中的应用。然后，我提供了一个简短的python实现，作为一种使用机器学习方法为更复杂的实现提供直觉的方式。</p><p id="60ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如有任何相关问题，可以通过<a class="ae ky" href="https://twitter.com/DataEnthus" rel="noopener ugc nofollow" target="_blank">推特</a>联系我。</p></div></div>    
</body>
</html>