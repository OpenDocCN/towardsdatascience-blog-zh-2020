<html>
<head>
<title>Virtual Background in webcam with Body Segmentation technique</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有身体分割技术的网络摄像机中的虚拟背景</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/virtual-background-in-webcam-with-body-segmentation-technique-fc8106ca3038?source=collection_archive---------14-----------------------#2020-05-23">https://towardsdatascience.com/virtual-background-in-webcam-with-body-segmentation-technique-fc8106ca3038?source=collection_archive---------14-----------------------#2020-05-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ceff" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">网络摄像头背景变化不仅限于现在缩放，我只是用tensorflow.js body-pix模型在浏览器里做了一下</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0f805ae9c4a14fd56a797111c82ee5d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7JZFg4utLSm5qSXxDs-hnA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://bensonruan.com/selfie-anywhere-person-segmentation-with-bodypix/" rel="noopener ugc nofollow" target="_blank">bensonruan.com</a></p></figure><p id="a130" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你有没有过这样的时刻，当你在社交媒体上浏览那些漂亮的旅行自拍时，你会自言自语:“我希望我能在那里”？你猜怎么着，我们今天要让它成真。利用最新的人物分割技术，我们可以在像素级上将身体部分与背景分开。</p><p id="3742" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">非常类似于视频会议软件Zoom的改变背景功能，可以把你身后凌乱的房间隐藏起来，把你运送到一个荒岛或者宁静的海滩。</p><p id="5fbc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将向你展示如何构建一个随处自拍应用程序，它可以通过实时改变自拍的背景，让你置身于那些美丽的旅行场景中。不需要Photoshop，也不需要绿屏。让我们找点乐子，倒数“3，2，1…说茄子”！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/f05890295923b4f79d648af27d3b976a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wI5UkUo1KziqXX2c5ocAaQ.jpeg"/></div></div></figure><p id="404b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">自己试试吧，演示在下面的链接里:</p><div class="lw lx gp gr ly lz"><a href="https://bensonruan.com/selfie-anywhere-person-segmentation-with-bodypix/" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd iu gy z fp me fr fs mf fu fw is bi translated">使用BodyPix - Benson技术进行随处自拍-人物分割</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">你有没有过这样的时刻，当你在社交媒体上浏览那些漂亮的旅行自拍时，你会自言自语:“我希望我…</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">bensonruan.com</p></div></div><div class="mi l"><div class="mj l mk ml mm mi mn ks lz"/></div></div></a></div></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="7d8a" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">履行</h1><p id="4432" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">你在上面拍了一些自拍照，然后给你的朋友看了吗？我希望你喜欢它，这个应用程序利用了一种叫做<strong class="lb iu">身体分割</strong>的先进技术，它可以识别图像或视频流中的人，并从背景中分割出前景身体。</p><p id="16d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今年早些时候，谷歌发布了<a class="ae ky" href="https://github.com/tensorflow/tfjs-models/tree/master/body-pix" rel="noopener ugc nofollow" target="_blank"> BodyPix </a>，这是一个开源的机器学习模型，允许在浏览器中使用<a class="ae ky" href="https://js.tensorflow.org/" rel="noopener ugc nofollow" target="_blank"> TensorFlow.js </a>进行人和身体部位分割。我对这项技术感到惊讶，并产生了构建上述自拍随处应用程序的想法。下面请跟随我了解我是如何实现它的。</p><h2 id="29a8" class="ns mw it bd mx nt nu dn nb nv nw dp nf li nx ny nh lm nz oa nj lq ob oc nl od bi translated">#步骤1:包含tfjs和body-pix</h2><p id="a2e6" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">首先，简单的在html文件的&lt;头&gt;部分包含脚本<code class="fe oe of og oh b">Tensorflow.js</code>及其<code class="fe oe of og oh b">body-pix</code>模型。</p><pre class="kj kk kl km gt oi oh oj ok aw ol bi"><span id="ff9c" class="ns mw it oh b gy om on l oo op">&lt;script src="<a class="ae ky" href="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.2" rel="noopener ugc nofollow" target="_blank">https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.2</a>"&gt;&lt;/script&gt;</span><span id="e3bd" class="ns mw it oh b gy oq on l oo op">&lt;script src="<a class="ae ky" href="https://cdn.jsdelivr.net/npm/@tensorflow-models/body-pix@2.0" rel="noopener ugc nofollow" target="_blank">https://cdn.jsdelivr.net/npm/@tensorflow-models/body-pix@2.0</a>"&gt;&lt;/script&gt;</span></pre><p id="6bb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者您可以通过npm安装它，以便在TypeScript / ES6项目中使用</p><pre class="kj kk kl km gt oi oh oj ok aw ol bi"><span id="567c" class="ns mw it oh b gy om on l oo op">npm install @tensorflow-models/body-pix</span></pre><h2 id="ee07" class="ns mw it bd mx nt nu dn nb nv nw dp nf li nx ny nh lm nz oa nj lq ob oc nl od bi translated">#步骤2:将网络摄像头传输到浏览器</h2><p id="9f1a" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">为了让你的网络摄像头进入浏览器，我使用了JavaScript库<code class="fe oe of og oh b">navigator.mediaDevices.getUserMedia</code>。要了解更多细节，请参考我以前的文章:</p><div class="lw lx gp gr ly lz"><a href="https://medium.com/swlh/how-to-access-webcam-and-take-picture-with-javascript-b9116a983d78" rel="noopener follow" target="_blank"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd iu gy z fp me fr fs mf fu fw is bi translated">如何使用JavaScript访问网络摄像头并拍照</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">介绍网络摄像头-简易npm模块</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">medium.com</p></div></div><div class="mi l"><div class="or l mk ml mm mi mn ks lz"/></div></div></a></div><h2 id="79ef" class="ns mw it bd mx nt nu dn nb nv nw dp nf li nx ny nh lm nz oa nj lq ob oc nl od bi translated">#步骤3:加载BodyPix模型</h2><p id="f0cd" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">为了进行分割，我们首先需要通过调用<code class="fe oe of og oh b">bodyPix.load(modelConfig)</code>的API来加载预先训练好的BodyPix模型。BodyPix附带了几个不同版本的模型，具有不同的性能特征，在模型大小和预测时间与准确性之间进行权衡。</p><p id="f611" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，BodyPix加载一个带有<code class="fe oe of og oh b">0.75</code>乘法器的MobileNetV1架构。对于配有中端/低端GPU的计算机，建议这样做。对于移动设备，建议使用带有<code class="fe oe of og oh b">0.50</code>乘数的型号。ResNet体系结构推荐用于具有更强大GPU的计算机。</p><pre class="kj kk kl km gt oi oh oj ok aw ol bi"><span id="ec62" class="ns mw it oh b gy om on l oo op"><strong class="oh iu">bodyPix.load</strong>({<br/>    architecture: 'MobileNetV1',<br/>    outputStride: 16,<br/>    multiplier: 0.75,<br/>    quantBytes: 2<br/>})</span></pre><h2 id="dc77" class="ns mw it bd mx nt nu dn nb nv nw dp nf li nx ny nh lm nz oa nj lq ob oc nl od bi translated">#第四步:身体分割</h2><p id="6ecb" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">接下来，我们通过调用<code class="fe oe of og oh b">net.estimatePersonSegmentation(video, outputStride, segmentationThreshold)</code>的API，开始通过body-pix模型馈送网络摄像机流以执行人物分割。它将图像分割成像素，这些像素是和不是人的一部分。它返回一个二进制数组，对于作为人的一部分的像素为1，否则为0。数组大小对应于图像中的像素数。</p><pre class="kj kk kl km gt oi oh oj ok aw ol bi"><span id="8854" class="ns mw it oh b gy om on l oo op"><strong class="oh iu">net.segmentPerson</strong>(webcamElement,  {<br/>    flipHorizontal: true,<br/>    internalResolution: 'medium',<br/>    segmentationThreshold: 0.5<br/>  })<br/>  <strong class="oh iu">.then(personSegmentation</strong> =&gt; {<br/>    if(personSegmentation!=null){<br/>        drawBody(personSegmentation);<br/>    }<br/>});<br/>cameraFrame = requestAnimFrame(detectBody);</span></pre><p id="2703" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oe of og oh b">flipHorizontal</code>默认为假。如果分割&amp;姿态应该水平翻转/镜像。对于默认水平翻转的视频(即网络摄像头)，此选项应设置为true，并且您希望分段&amp;姿势以正确的方向返回。</p><p id="7765" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oe of og oh b">segmentationThreshold</code>用于确定像素分数的最小值，该值必须被视为一个人的一部分。本质上，较高的值将在人的周围创建更紧密的裁剪，但是可能导致作为人的一部分的一些像素被从返回的分段掩码中排除。</p><p id="bdfe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它返回一个用<code class="fe oe of og oh b">SemanticPersonSegmentation</code>对象解析的<code class="fe oe of og oh b">Promise</code>。图像中的多个人被合并到一个二元蒙版中。除了<code class="fe oe of og oh b">width</code>、<code class="fe oe of og oh b">height</code>和<code class="fe oe of og oh b">data</code>字段，它还返回一个包含所有人姿势的字段<code class="fe oe of og oh b">allPoses</code>。所有人的数据数组，包含307200个值，640x480图像的每个像素一个值。</p><pre class="kj kk kl km gt oi oh oj ok aw ol bi"><span id="b866" class="ns mw it oh b gy om on l oo op">{<br/>  width: 640,<br/>  height: 480,<br/>  data: Uint8Array(307200) [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, …],<br/>  allPoses: [{"score": 0.4, "keypoints": […]}, …]<br/>}</span></pre><h2 id="2774" class="ns mw it bd mx nt nu dn nb nv nw dp nf li nx ny nh lm nz oa nj lq ob oc nl od bi translated">#第五步:去除背景</h2><p id="166c" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">在上面的函数中，我们用二进制数组来表示像素是否属于人体，现在我们可以用它来去除背景，只在画布上画出人体。在ImageData对象中，每个像素保存红色、绿色、蓝色和alpha(透明度)的值，移除背景的技巧是将像素的<code class="fe oe of og oh b">transparency</code>值设置为0。</p><pre class="kj kk kl km gt oi oh oj ok aw ol bi"><span id="44f3" class="ns mw it oh b gy om on l oo op">const canvasPerson = document.getElementById("canvasPerson");<br/>let contextPerson = canvasPerson.getContext('2d');<br/> <br/>function drawBody(personSegmentation)<br/>{<br/>    contextPerson.drawImage(camera, 0, 0, camera.width, camera.height);<br/>    var imageData = contextPerson.getImageData(0,0, camera.width, camera.height);<br/>    var pixel = imageData.data;<br/>    for (var p = 0; p&lt;pixel.length; p+=4)<br/>    {<br/>      <strong class="oh iu">if (personSegmentation.data[p/4] == 0) {<br/>          pixel[p+3] = 0;<br/>      }</strong><br/>    }<br/>    contextPerson.imageSmoothingEnabled = true;<br/>    contextPerson.putImageData(imageData,0,0);<br/>}</span></pre><h2 id="b80f" class="ns mw it bd mx nt nu dn nb nv nw dp nf li nx ny nh lm nz oa nj lq ob oc nl od bi translated">#第六步:在背景图片上覆盖画布</h2><p id="0e7b" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">一旦我们有了只包含透明背景的身体的画布，那么我们只需要将它覆盖在令人惊叹的自然场景的背景图像上。</p><pre class="kj kk kl km gt oi oh oj ok aw ol bi"><span id="0c99" class="ns mw it oh b gy om on l oo op">&lt;video id="webcam" autoplay playsinline width="640" height="480"&gt;&lt;/video&gt;<br/>&lt;div id="selfie-container"&gt;<br/>    <strong class="oh iu">&lt;div id="background-container"&gt;&lt;/div&gt;</strong><br/>    &lt;canvas id="canvasPerson" width="640" height="480"&gt;&lt;/canvas&gt;<br/>&lt;/div&gt;</span></pre><p id="67a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面应用css样式</p><pre class="kj kk kl km gt oi oh oj ok aw ol bi"><span id="aff6" class="ns mw it oh b gy om on l oo op">#background-container {<br/>    height: 100vh;<br/>    width: 100vw;<br/>    <strong class="oh iu">background-image: url(../images/greatwall.jpg);</strong><br/>    background-position: center center;<br/>    background-repeat: no-repeat;<br/>    background-size: cover;<br/>    background-color: transparent;<br/>}<br/> <br/>#canvasPerson{<br/> <strong class="oh iu">background-color: transparent;</strong><br/> position: absolute;<br/> width: 100vw;<br/> height: auto;<br/> z-index: 9999;<br/> margin: auto;<br/> top: 0;<br/> bottom: 0;<br/> left: 0;<br/> right: 0;<br/> margin-left: auto;<br/> margin-right: auto;<br/> -moz-transform: scale(-1, 1);<br/> -webkit-transform: scale(-1, 1);<br/> -o-transform: scale(-1, 1);<br/> transform: scale(-1, 1);<br/> filter: FlipH;<br/>}</span></pre><h2 id="f87b" class="ns mw it bd mx nt nu dn nb nv nw dp nf li nx ny nh lm nz oa nj lq ob oc nl od bi translated">#第七步:截图</h2><p id="f208" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">为了拍照，我使用了第三方JavaScript库<a class="ae ky" href="https://html2canvas.hertzen.com/" rel="noopener ugc nofollow" target="_blank"> html2canvas.js </a>。它允许你直接在用户浏览器上截取网页或部分网页的“截图”。</p><pre class="kj kk kl km gt oi oh oj ok aw ol bi"><span id="198d" class="ns mw it oh b gy om on l oo op">$("#take-photo").click(function () {<br/>    beforeTakePhoto();<br/>    var captureElement= document.getElementById('selfie-container');<br/>    var appendElement= document.getElementById('webcam-container');<br/>    <strong class="oh iu">html2canvas(captureElement)</strong>.then(function(canvas) {<br/>        canvas.id='captureCanvas';<br/>        appendElement.appendChild(canvas);<br/>        document.querySelector('#download-photo').href = canvas.toDataURL('image/png');<br/>        afterTakePhoto();<br/>    });<br/>});</span></pre><p id="e374" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码就这么多了！除此之外，只是使演示看起来不错。选择一个壮观的场景，摆好你最喜欢的姿势，微笑吧！</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="9ed1" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">GitHub知识库</h1><p id="b987" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">您可以通过下面的链接下载上述演示的完整代码:</p><div class="lw lx gp gr ly lz"><a href="https://github.com/bensonruan/Selfie-Anywhere" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd iu gy z fp me fr fs mf fu fw is bi translated">本森阮/自拍-任何地方</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">实例分割将人体与背景分离。通过改变，让自己置身于美丽的自然风景中…</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">github.com</p></div></div><div class="mi l"><div class="os l mk ml mm mi mn ks lz"/></div></div></a></div></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="7bba" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">结论</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/f4117b410414341570714d84d315ed26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8fn1OfDPeaoqmSIXrKVrCQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自<a class="ae ky" href="https://www.pexels.com/photo/photo-of-child-sitting-by-the-table-while-looking-at-the-imac-4145153/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>的<a class="ae ky" href="https://www.pexels.com/@julia-m-cameron?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">茱莉亚·M·卡梅隆</a>的照片</p></figure><p id="9828" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实例分割技术的进步现在显示出从自动驾驶汽车到医疗诊断等许多领域的前景。有了深度学习神经网络，模型现在变得越来越准确。我希望这篇文章只是你学习更多图像分割和计算机视觉的旅程的开始。</p><p id="8d26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读。如果你喜欢这篇文章，请在脸书或推特上分享。如果你有任何问题，请在评论中告诉我。在<a class="ae ky" href="https://github.com/bensonruan/" rel="noopener ugc nofollow" target="_blank"> GitHub </a>和<a class="ae ky" href="https://www.linkedin.com/in/benson-ruan/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>上关注我。</p></div></div>    
</body>
</html>