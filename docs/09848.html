<html>
<head>
<title>Docker Handbook</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">码头工人手册</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-concise-guide-to-docker-f6b6d5fb56f4?source=collection_archive---------47-----------------------#2020-07-12">https://towardsdatascience.com/a-concise-guide-to-docker-f6b6d5fb56f4?source=collection_archive---------47-----------------------#2020-07-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c963" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">码头工人简明指南</h2></div><p id="13a2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有几门关于这个主题的课程。有些非常短，除了“入门课程”之外没有任何其他用途，而另一些则非常长，需要你花几天时间来学习和理解一切。我写这篇教程的目的是在简洁和详尽之间找到平衡。</p><p id="52a4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来的部分更多的是 Docker 的欣赏部分。如果你已经知道 Docker 是什么以及它是如何有用的，你可以跳到下一节来节省一些时间。</p><ol class=""><li id="3815" class="le lf it kk b kl km ko kp kr lg kv lh kz li ld lj lk ll lm bi translated">简介(你来了！)</li><li id="93fb" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><a class="ae ls" href="https://medium.com/@gyani91/docker-file-179b5e3d9171" rel="noopener"> Docker 文件</a></li><li id="21b4" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><a class="ae ls" href="https://medium.com/@gyani91/docker-commands-bbf02780b785" rel="noopener">基本对接命令</a></li><li id="ece7" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><a class="ae ls" href="https://medium.com/@gyani91/port-and-volume-mapping-c8bb09221f82" rel="noopener">端口和卷映射</a></li><li id="57d2" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><a class="ae ls" href="https://medium.com/@gyani91/docker-networking-919461b7f498" rel="noopener"> Docker 联网</a></li><li id="8a40" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><a class="ae ls" href="https://medium.com/@gyani91/docker-storage-598e385f4efe" rel="noopener">码头仓库</a></li><li id="f638" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><a class="ae ls" href="https://medium.com/@gyani91/docker-compose-44a8112c850a" rel="noopener"> Docker 撰写</a></li><li id="f397" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><a class="ae ls" href="https://medium.com/@gyani91/deleting-docker-entities-2f90e4a0a765" rel="noopener">删除 Docker 实体</a></li></ol><p id="826a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Docker 是一个工具，旨在通过使用容器更容易地创建、部署和运行应用程序。容器允许开发人员将应用程序所需的所有部分打包，如库和其他依赖项，并作为一个包发送出去。</p><p id="6643" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当您的应用程序需要多个组件相互交互时，通常会出现依赖库的版本需求冲突。一旦所有组件之间就其依赖关系的版本达成一致，添加另一个组件或甚至升级其中一个组件都会破坏这一协议。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi lt"><img src="../Images/ee0c2ad9ee056500c9a7135722a42f6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KtdNBk5bjGJL2CHx7lQc4g.png"/></div></div><p class="mf mg gj gh gi mh mi bd b be z dk translated">没有码头工人的生活</p></figure><p id="408f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Docker 解决这个问题的方法是将这些组件放入单独的隔离环境中，称为“容器”,并带有各自的依赖关系。所有这些容器仍然共享同一个内核。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi mj"><img src="../Images/fa912ecf2e364f9e802a18e7b6da436b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rArd_BeHJo-hglkcMv64zA.png"/></div></div><p class="mf mg gj gh gi mh mi bd b be z dk translated">简单的 docker 示例</p></figure><p id="df44" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与虚拟机相比，Docker 容器更轻(尺寸更小)，启动时间更短，并且不是完全隔离的。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi mk"><img src="../Images/d595f26af82e9515117b051907096308.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rt80Qxnl3sinRqZRlH6log.png"/></div></div><p class="mf mg gj gh gi mh mi bd b be z dk translated">虚拟机架构</p></figure><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi ml"><img src="../Images/e163655e4dbcf6f94b5989be0a717476.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ROZ6p3JftLik_NCNoFcSSA.png"/></div></div><p class="mf mg gj gh gi mh mi bd b be z dk translated">码头建筑</p></figure><p id="10c8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">问题不在于使用虚拟机还是 Docker 容器。现代生产部署同时使用这两者。这种体系结构允许您减少虚拟机数量，从而减少资源消耗并加快启动速度。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi mm"><img src="../Images/1643509ea6e94dfda190bec604274763.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UT6sAZpdXhU-KGL1RPRzWQ.png"/></div></div><p class="mf mg gj gh gi mh mi bd b be z dk translated">docker-虚拟机架构</p></figure><p id="7c69" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">简单地说，docker 映像是应用程序及其环境的模板。我们可以从一个图像中旋转出多个容器。映像包含运行应用程序所需的一切，包括源代码、库、配置文件和环境变量。docker 容器是这个映像的运行时实例。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi mn"><img src="../Images/591c247a01c98622c6b39a0199c79d4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CjUyho9o7itLqSul6kWMBg.png"/></div></div><p class="mf mg gj gh gi mh mi bd b be z dk translated">Docker 图像及其容器</p></figure><p id="9d6e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Docker image 是一个超级强大的机制，可以扩展您的应用程序。您可以从单个映像运行任意数量的容器，所有容器都将支持完全相同的依赖关系。如果你正在使用一个容器编制器，像<a class="ae ls" href="https://kubernetes.io" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>一样，你只需要说明你想要多少容器用于一个特定的图像，编制器就会在你所有的 Docker 服务器上创建和维护它们。</p><p id="3ab5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您使用 Docker 容器并且没有停机时间，那么升级生产系统是无缝的！您只需指示 orchestrator 您想要运行一个新的映像版本，它就会逐渐用运行新版本的容器替换每个容器。</p><p id="7fcd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<a class="ae ls" href="https://medium.com/@gyani91/docker-file-179b5e3d9171" rel="noopener">的下一节</a>中，我们将看到什么是 Dockerfile 以及如何编写 docker file？</p><p id="3059" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">参考:</p><p id="536d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">[1] Docker，<a class="ae ls" href="https://docs.docker.com/get-started/overview/" rel="noopener ugc nofollow" target="_blank"> Docker 概述</a> (2020)，Docker 文档</p><p id="d2fe" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">[2]穆姆沙德·曼南贝斯，<a class="ae ls" href="https://kodekloud.com/p/docker-for-the-absolute-beginner-hands-on" rel="noopener ugc nofollow" target="_blank">为绝对初学者准备的 Docker</a>(2020)，KodeKloud.com</p></div></div>    
</body>
</html>