<html>
<head>
<title>Quicksort in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中的快速排序</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/quicksort-in-python-dbefa7dcf9cc?source=collection_archive---------8-----------------------#2020-05-07">https://towardsdatascience.com/quicksort-in-python-dbefa7dcf9cc?source=collection_archive---------8-----------------------#2020-05-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f7ec" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Python 中“快速排序”的介绍</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b0b13a1b7f8bc75e81f5727adee9838c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*41TKUCBEWq4TCXce73PdWQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://www.pexels.com/photo/time-lapse-photography-of-brown-concrete-building-842654/" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="27f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">排序算法是计算机科学中最重要的算法之一。排序涉及对列表或数组中的元素进行排序的任务。排序最常见的用法是数字排序和字典排序。在这篇文章中，我们将讨论如何在 python 中实现一个“快速排序”算法，我们将使用它对列表进行数字排序。</p><p id="c06d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们开始吧！</p><p id="a908" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">“快速排序”算法的基本过程是划分。分区的工作方式是首先选择一个枢轴。枢轴选项包括:</p><ol class=""><li id="8373" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">第一元素</li><li id="f388" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">最后一个元素</li><li id="b3b9" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">随机元素</li><li id="d0ad" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">中间分子</li></ol><p id="77c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在选择枢轴后，我们根据枢轴值划分数组的元素。也就是说，对于一个输入数组和 pivot，我们将所有小于 pivot 的元素放在 pivot 之前，将所有大于 pivot 的元素放在 pivot 之后。为了看到这一点，让我们考虑下面的列表:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/e9fdbf49b9c6823e68ee3d8c9d5286fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y29NIRUt7JeoPVE1mevT9g.png"/></div></div></figure><p id="39d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们选择最后一个元素“3”作为我们的轴心:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mk"><img src="../Images/4b0aef3179c0b652975fcba21ef5d028.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Njux2syraq38jzBvkNPbQg.png"/></div></div></figure><p id="4387" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们创建两个子列表，左边的列表包含小于主元的值，右边的子列表包含大于子列表的值:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ml"><img src="../Images/8c2ae6750bbd4e899b5d242587207905.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q-8787kpdwT57YKVAacEEQ.png"/></div></div></figure><p id="681a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们找到子列表的中枢，并重复划分过程。左侧子列表的枢轴是 1，右侧子列表的枢轴是 6:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mm"><img src="../Images/fa0a089592db3454e80013eca37fdfdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hDJi4Rx7bzLVGtUKNGRyMA.png"/></div></div></figure><p id="5d57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们围绕它们的支点划分子列表:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mn"><img src="../Images/f669893e07ccb27031cb8b066093836a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3_3zrlr1daGA-8A1RMR6kw.png"/></div></div></figure><p id="d219" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，让我们为最后一组子列表选择枢轴，左边 6 个，右边 8 个:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mo"><img src="../Images/9db9c8762af6bc40bfc04131e68f09e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S4fwEGRJJ__WLT7GcevQ-w.png"/></div></div></figure><p id="2193" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们完成最后一个分区:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mp"><img src="../Images/e02abd03da84e99ad8f7e2d2f4864813.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3q7OwlzKKN6WP1FsF5VC2g.png"/></div></div></figure><p id="8823" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们最终得到了下面的排序列表:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mq"><img src="../Images/7c5ae9bdea73ac78ca07aca5d95c2e82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mc7Y6XmggbtNIqpDCJ8TgQ.png"/></div></div></figure><p id="28e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看如何用 python 实现这个算法。首先，让我们定义我们的配分函数。我们的函数将接受一个列表，一个“低”变量和一个“高”变量。“低”是较小元素的索引(我们将在列表中从这里开始)，而“高”是透视的索引，这将是最后一个元素。我们将最小元素的索引初始化为“低”-1，并将轴心定义为最后一个元素的值:</p><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="d19a" class="mw mx it ms b gy my mz l na nb">def <!-- -->partition(list,low,high):<br/>    i = (low - 1)<br/>    pivot = array[high]</span></pre><p id="1637" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将编写一个从“低”到“高”迭代的“for-loop”:</p><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="52a6" class="mw mx it ms b gy my mz l na nb">def <!-- -->partition(list,low,high):<br/>    i = (low - 1)<br/>    pivot = array[high]<br/>    for j in range(low, high):</span></pre><p id="8f15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们检查“for-loop”中当前索引处的值是否小于或等于 pivot。如果当前值小于轴心值，我们将递增较小元素的索引:</p><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="d3f8" class="mw mx it ms b gy my mz l na nb">def partition(input_list,low,high):<br/>    i = (low - 1)<br/>    pivot = input_list[high]<br/>    for j in range(low, high):<br/>        if input_list[j] &lt;= pivot:<br/>            i = i + 1<br/>            input_list[i], input_list[j] =  input_list[j], input_list[i]</span></pre><p id="b72f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">否则，如果当前值大于中枢，我们将较大的值与中枢交换。我们还返回索引:</p><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="a40e" class="mw mx it ms b gy my mz l na nb">def partition(input_list,low,high):<br/>    i = (low - 1)<br/>    pivot = input_list[high]<br/>    for j in range(low, high):<br/>        if input_list[j] &lt;= pivot:<br/>            i = i + 1<br/>            input_list[i], input_list[j] =  input_list[j], input_list[i]<br/>    input_list[i+1],input_list[high] = input_list[high],input_list[i+1]<br/>    return (i+1)</span></pre><p id="4680" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们定义我们的“快速排序”函数。我们首先检查“低”的值是否小于“高”，如果条件为真，我们定义分区索引:</p><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="6d1c" class="mw mx it ms b gy my mz l na nb">def quickSort(<!-- -->input_list<!-- -->, low, high):<br/>    if low &lt; high:<br/>        partition_index = <!-- -->partition(input_list,low,high)</span></pre><p id="eb20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们递归调用“快速排序”并在分区前对元素进行排序:</p><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="3b0a" class="mw mx it ms b gy my mz l na nb">def quickSort(<!-- -->input_list<!-- -->, low, high):<br/>    if low &lt; high:<br/>        partition_index = <!-- -->partition(input_list,low,high)<br/>        <!-- -->quickSort(<!-- -->input_list<!-- -->, low, partition_index - 1)</span></pre><p id="02f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并对分区后的元素进行排序:</p><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="fe69" class="mw mx it ms b gy my mz l na nb">def quickSort(<!-- -->input_list<!-- -->, low, high):<br/>    if low &lt; high:<br/>        partition_index = <!-- -->partition(input_list,low,high)<br/>        <!-- -->quickSort(<!-- -->input_list<!-- -->, low, partition_index - 1)<br/>        <!-- -->quickSort(<!-- -->input_list<!-- -->, partition_index + 1, high)</span></pre><p id="95e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以测试我们的“快速排序”功能。让我们用我们在最初的例子中使用的列表来测试它:</p><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="3add" class="mw mx it ms b gy my mz l na nb">input_l = [9, -3, 5, 2, 6, 8, -6, 1, 3]</span></pre><p id="153c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们定义我们的“高”变量，它将是列表的长度:</p><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="b4e0" class="mw mx it ms b gy my mz l na nb">list_length = len(input_l)</span></pre><p id="24f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">“低”变量将是 0，因为在 python 中列表是零索引的。现在让我们用我们的列表、我们的“低”值(0)和“list _ length”-1 来调用“快速排序”方法:</p><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="1d4e" class="mw mx it ms b gy my mz l na nb">quickSort(input_l, 0, list_length -1)</span></pre><p id="31da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们的数组应该排序了。让我们打印我们的数组:</p><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="3d72" class="mw mx it ms b gy my mz l na nb">print(input_l)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/bf8022cceeaf40e79bdf58745a0352ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/format:webp/1*x95x86a5ujCnsgX4MxFcjg.png"/></div></figure><p id="a4d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到我们的函数成功地对列表进行了排序。我就讲到这里，但是我鼓励你自己去研究代码。</p><h1 id="5195" class="nd mx it bd ne nf ng nh ni nj nk nl nm jz nn ka no kc np kd nq kf nr kg ns nt bi translated">结论</h1><p id="0188" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">总之，在这篇文章中，我们讨论了快速排序算法，并展示了如何用 python 实现它。如果你有兴趣学习更多关于排序算法的知识，我鼓励你去探索一下 realpython.com，它涉及到其他排序算法，比如“合并排序”、“插入排序”和“冒泡排序”。我希望你觉得这篇文章有用/有趣。这篇文章的代码可以在<a class="ae ky" href="https://github.com/spierre91/medium_code/tree/master/data_structures_and_algorithms" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。感谢您的阅读！</p></div></div>    
</body>
</html>