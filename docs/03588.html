<html>
<head>
<title>Avoid These Rookie Python Mistakes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">避免这些Python新手的错误</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/avoid-these-rookie-python-mistakes-9cc17cccd051?source=collection_archive---------5-----------------------#2020-04-05">https://towardsdatascience.com/avoid-these-rookie-python-mistakes-9cc17cccd051?source=collection_archive---------5-----------------------#2020-04-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b748" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">他们可能会工作，但他们可以工作得更好。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d231ca77ce7213799b7e57e51c9d0173.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*259ESgrcrbjaZKKU-qaUmA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(python徽标由http://python.org/提供)</p></figure><p id="064b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">随着大量的实践，编程将逐渐变得容易，但底线是</p><blockquote class="lu"><p id="3ac7" class="lv lw it bd lx ly lz ma mb mc md lt dk translated">编程很难。</p></blockquote><p id="fb8a" class="pw-post-body-paragraph ky kz it la b lb me ju ld le mf jx lg lh mg lj lk ll mh ln lo lp mi lr ls lt im bi translated">假设和自己解决问题的不幸组合会使事情变得更加困难。尤其是在没有导师的情况下，甚至很难知道你做事的方式是否是错的。我们当然都为以后进入代码和重构而感到内疚，因为我们都在不断学习如何以更好的方式做事。幸运的是，如果有足够的意识，纠正这些错误可以让你成为一个更好的程序员。</p><p id="52fb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">成为伟大程序员的最好方法是克服错误和问题。做事情总有更好的方法，找到更好的方法才是有挑战性的。习惯做这样或那样的事情很容易，但有时需要一点改变，才能真正成为一名伟大的工程师。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="9a4c" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">未实施</h1><p id="8649" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">虽然“未实现”错误可能是这个列表中最不常见的错误之一，但我认为发布一个提醒是很重要的。在Python中引发NotImplemented不会引发NotImplemented错误，但会引发类型错误。我写了一个函数来说明这一点:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="99b1" class="ns mr it no b gy nt nu l nv nw">def implementtest(num):<br/>    if num == 5:<br/>        raise(NotImplemented)</span></pre><p id="151d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每当我们试图运行“num”等于5的函数时，看看会发生什么:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/ad32e9250ee96e566ea1b625764c9421.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/format:webp/1*gVBbdaeO9OgKqzlCXPmrJw.png"/></div></figure><p id="9f84" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">引发正确异常的解决方案是引发NotImplementedError，而不是引发NotImplemented。为此，我修改了我们的函数:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="0f5f" class="ns mr it no b gy nt nu l nv nw">def implementtest(num):<br/>    if num == 5:<br/>        raise(NotImplemented)<br/>    if num == 10:<br/>        raise(NotImplementedError('This is the right way!'))</span></pre><p id="6114" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">运行这个会给我们正确的输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/2ffa9fcecd99696489bd5a972f7c2da1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pxJvLZRBetQJSHsGlF1BCg.png"/></div></div></figure><h1 id="cb03" class="mq mr it bd ms mt nz mv mw mx oa mz na jz ob ka nc kc oc kd ne kf od kg ng nh bi translated">可变默认值</h1><blockquote class="lu"><p id="9748" class="lv lw it bd lx ly lz ma mb mc md lt dk translated">(这是我犯的错)</p></blockquote><p id="609d" class="pw-post-body-paragraph ky kz it la b lb me ju ld le mf jx lg lh mg lj lk ll mh ln lo lp mi lr ls lt im bi translated">Python中的默认参数被求值一次<em class="oe">，</em>，求值发生在执行函数定义的<em class="oe"> </em>时。假设这些参数只计算一次，那么每个inbound元素都会在每个调用中使用，这意味着每次在函数中访问变量时，变量中包含的数据都是可变的。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="bb4b" class="ns mr it no b gy nt nu l nv nw"><strong class="no iu">def</strong> <strong class="no iu">add</strong>(item, items<strong class="no iu">=</strong>[]):<br/>    items<strong class="no iu">.</strong>append(item)</span></pre><p id="aaf9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们应该做的是将参数的值设置为nothing，并添加一个条件来修改列表，如果它不存在的话</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="0018" class="ns mr it no b gy nt nu l nv nw"><strong class="no iu">def</strong> <strong class="no iu">add</strong>(item, items<strong class="no iu">=</strong>None):<br/>    <strong class="no iu">if</strong> items <strong class="no iu">is</strong> None:<br/>        items <strong class="no iu">=</strong> []<br/>    items<strong class="no iu">.</strong>append(item)</span></pre><p id="afc8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">尽管这主要适用于Python用户的统计/DS/ML方面，但根据具体情况，拥有不可变的数据是普遍重要的。</p><h1 id="8c38" class="mq mr it bd ms mt nz mv mw mx oa mz na jz ob ka nc kc oc kd ne kf od kg ng nh bi translated">全局变量</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/eba8e282d0c1f334fed2de9c8eac9c3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*1hFYMuK83SkOL72vpjtqaQ.png"/></div></figure><p id="8537" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在面向对象的编程语言中，全局变量应该保持在最低限度。然而，我认为，通过解释全局变量当然是必要的，并且在某些情况下很好，给这种说法加上副标题是很重要的。这方面的一个很好的例子是数据科学，这是实际上正在进行的有限数量的面向对象编程，Python的功能性比通常情况下更强。</p><p id="4ad2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当多个函数调用并依赖同一个值时，全局变量会导致命名和隐私问题。我认为全局变量的一个很好的例子是类似于文件路径的东西，特别是要和Python文件打包在一起的。即使在编写Gtk类和移动图形用户界面构建器时，也应该私下进行，而不是全局进行。</p><h1 id="f5d3" class="mq mr it bd ms mt nz mv mw mx oa mz na jz ob ka nc kc oc kd ne kf od kg ng nh bi translated">收到。</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/9dbc827c9c856e73aea770d8c2f5a20d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w4Lxh1czKpax05Mw_1VJiQ.png"/></div></div></figure><p id="f183" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用copy在客观上可以比使用normal赋值更好。正常的赋值操作只是将新变量指向现有对象，而不是创建一个新对象。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="b2f0" class="ns mr it no b gy nt nu l nv nw">d = 5<br/>h = d</span></pre><p id="6553" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用Python的复制模块可以执行两种主要类型的复制，</p><blockquote class="lu"><p id="6909" class="lv lw it bd lx ly lz ma mb mc md lt dk translated">浅层复制和深层复制。</p></blockquote><p id="29f9" class="pw-post-body-paragraph ky kz it la b lb me ju ld le mf jx lg lh mg lj lk ll mh ln lo lp mi lr ls lt im bi translated">这两种类型的副本之间的区别在于您希望通过函数传递的变量的类型。当对包含在单字节数据中的变量(如整数、浮点、布尔<strong class="la iu">或</strong>字符串)使用深度复制时，浅复制和深复制之间的差异是感觉不到的。然而，当处理列表、元组和字典时，我建议总是进行深度复制。</p><p id="9644" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">浅层拷贝构造一个新的复合对象，然后(尽可能地)向其中插入对原始对象的引用。深度拷贝构造一个新的复合对象，然后递归地将原始对象的拷贝插入其中。有了这些定义，就很容易理解为什么要对给定的数据类型使用其中的一种。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="e52e" class="ns mr it no b gy nt nu l nv nw">import copy<br/>l = [10,15,20]<br/>h = 5<br/>hcopy = copy.copy(h)<br/>z = copy.deepcopy(l)</span></pre><p id="2192" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了测试我们的结果，我们可以简单地检查它们的变量id是否与条件语句相同:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="67d0" class="ns mr it no b gy nt nu l nv nw">print id(h) == id(hcopy)<!-- --> <br/>False</span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="0543" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">最后</h1><p id="3839" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">成为一名伟大的程序员需要不断提高，希望随着时间的推移，一些错误的观念能够被消除。这是一个渐进而痛苦的过程，但是通过大量的练习和更多的信息，遵循这样简单的指导和建议肯定会有所收获。像这样分享“不要做的事情”通常会成为很好的话题，让每个人都成为伟大的程序员，所以我认为讨论这个肯定是有益的，不管你在你的<strong class="la iu">无尽的</strong>编程之旅中走了多远。</p></div></div>    
</body>
</html>