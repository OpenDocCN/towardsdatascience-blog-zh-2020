<html>
<head>
<title>Matching estimator is powerful, and simple</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">匹配估计器功能强大且简单</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/matching-estimator-is-powerful-and-simple-82350f08515a?source=collection_archive---------55-----------------------#2020-05-22">https://towardsdatascience.com/matching-estimator-is-powerful-and-simple-82350f08515a?source=collection_archive---------55-----------------------#2020-05-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a94f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">您可以使用13行R代码手动进行匹配</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/48a44ee37d9b35384cec9e267cc7072a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i7HAh3TD1recKFErr_G1Iw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">upslash.com</p></figure><h1 id="b26f" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">背景</h1><p id="89dc" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">为获得<a class="ae mm" href="https://medium.com/@bowenchen_9406/the-you-know-who-in-economics-a9ef41b8e82e" rel="noopener">因果关系</a>的许多观察研究面临的挑战是自我选择——在许多情况下，人们出于某些原因选择接受治疗，因此，接受治疗的人不能直接与未接受治疗的人进行比较。例如，来自富裕家庭的学生可能更有可能选择上私立大学。如果我们想知道上私立大学对收入的因果影响，我们应该排除(或控制)家庭背景的影响。</p><p id="fd3e" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">匹配估计量已广泛应用于统计学、经济学、社会学、政治学等学科，用于估计因果关系。这是一种准实验方法，目的是在许多未处理单元中寻找与处理单元相当的反事实单元。</p><p id="6a73" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">匹配很简单，从技术上讲，很大程度上是数据处理。然而，我已经看到许多资料，使简单的方法难以理解。这太令人沮丧了！所以我决定通过这个方法向您展示，您可以用少于15行的R代码实现这个方法。我保证！</p><h1 id="b824" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">运行倾向评分匹配的r代码</h1><p id="393f" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我在这里重点介绍倾向得分匹配，因为它是一种流行的匹配方法。其他匹配方法和这个差不多。</p><p id="684e" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">首先，我们用下面的R代码模拟一些数据。这些都是不必要的。复制粘贴即可。在这些代码中，我指定了两个协变量:W1和W2。a是二元处理，Y是观察结果。Y.0和Y.1是潜在的结果，所以真实的治疗效果只是Y.0和Y.1的差别。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="5bdc" class="mx kz it mt b gy my mz l na nb"># Make the libraries ready<br/>library(dplyr)<br/>library(Matching)</span><span id="2404" class="mx kz it mt b gy nc mz l na nb">generateData&lt;- function(n) {<br/> # Generate baseline covariates:<br/> W1 &lt;- runif(n, min = 0.02, max = 0.7) <br/> W2 &lt;- rnorm(n, mean = (0.2 + 0.125*W1), sd = 1) <br/> # Generate binary treatment indicator<br/> A &lt;- rbinom(n, 1, plogis(-.7 + 1.8*W1–1.4*W2))<br/> # Generate the potential outcomes<br/> Y.0 &lt;- rnorm(n, mean = (-.5 + 2*poly(W1,2) — W2), sd=1)<br/> Y.1 &lt;- rnorm(n, mean = (-.5 + 2*poly(W1,2) — W2 + 1.5 + 2*poly(W1,2) — W2), sd=1)<br/> # Generate the observed outcome<br/> Y &lt;- ifelse(A == 1, Y.1, Y.0)<br/> return(data.frame(W1,W2,A,Y,Y.1,Y.0))<br/>}<br/>set.seed(101)<br/>data &lt;- generateData(n = 1000) # Generate 1000 data.</span></pre><p id="501c" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">用于匹配的r代码:</p><p id="0b16" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">第一步。估计logit模型以获得倾向得分:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="6865" class="mx kz it mt b gy my mz l na nb">logitmodel &lt;- glm(A ~ W1 + W2, data = data, family=’binomial’) # L1</span></pre><p id="7a9b" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">第二步。在与已处理单元的估计倾向得分差异最小的未处理单元中进行搜索。发现的单元然后被用作反事实单元，用于估算处理单元的潜在结果。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="0aaa" class="mx kz it mt b gy my mz l na nb"># Add the estimated ps to the data. <br/>data &lt;- mutate(data, pscore = logitmodel$fitted.values) #L2<br/>data1 &lt;- filter(data, A == 1) # Treated units data #L3<br/>data0 &lt;- filter(data, A == 0) # Untreated units data #L4</span><span id="eba6" class="mx kz it mt b gy nc mz l na nb">match.data &lt;- data1 #Make a copy of treated units data #L5<br/>for(i in 1:nrow(match.data)){#Now find counterfactual units #L6<br/> temp &lt;- data0 %&gt;% # Search among untreated units #L7<br/> mutate(pscorei = data1$pscore[i], # PS of the treated unit i #L8<br/>      dif.score = abs(pscorei — pscore)) %&gt;% # Score difference<br/>      arrange(dif.score) %&gt;% # Arrange the data  #L10<br/>      slice(1) %&gt;% # Choose the top one with lowest score dif<br/>      dplyr::select(!!colnames(match.data)) # Keep needed cols# L11<br/> match.data[i,] &lt;- temp[1,] # Replace with the found unit #L12<br/>}</span></pre><p id="d499" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">第三步。计算观察到的Y和匹配的Y之间的平均差异。该平均差异是被治疗者的平均治疗效果(ATT)。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="0f84" class="mx kz it mt b gy my mz l na nb">mean(data1$Y — match.data$Y) #L13</span></pre><h1 id="0363" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">结束</h1><p id="698d" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我刚刚展示了如何使用13行R代码进行匹配。还有其他方法可以加速编码，计算标准误差，估计治疗对未治疗者的影响，等等。但这些都不是本文的目标。敬请关注我的下一篇文章！</p><p id="6fd5" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">万一你不相信我，你可以运行下面的代码从<em class="nd">匹配</em>包得到相同的ATT值。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="aee2" class="mx kz it mt b gy my mz l na nb">m.out &lt;- Match(Y = data$Y, Tr = data$A, X = data$pscore, distance.tolerance = 0)<br/>summary(m.out)</span><span id="dba2" class="mx kz it mt b gy nc mz l na nb">mean(data1$Y.1 - data1$Y.0) # True ATT</span></pre></div></div>    
</body>
</html>