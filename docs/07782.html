<html>
<head>
<title>Time Series Forecasting with Autoregressive Processes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有自回归过程的时间序列预测</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/time-series-forecasting-with-autoregressive-processes-ba629717401?source=collection_archive---------5-----------------------#2020-06-10">https://towardsdatascience.com/time-series-forecasting-with-autoregressive-processes-ba629717401?source=collection_archive---------5-----------------------#2020-06-10</a></blockquote><div><div class="fc ij ik il im in"/><div class="io ip iq ir is"><div class=""/><div class=""><h2 id="699e" class="pw-subtitle-paragraph js iu iv bd b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj dk translated">Python中时间序列分析的AR(p)过程实践教程</h2></div><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi kk"><img src="../Images/ea39f75f826ecc03a83067b623b58961.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mAPY-6ft4c2dds7u"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">伊莲娜·科伊切娃在<a class="ae la" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="e2cd" class="lb lc iv bd ld le lf lg lh li lj lk ll kb lm kc ln ke lo kf lp kh lq ki lr ls bi translated">介绍</h1><p id="9295" class="pw-post-body-paragraph lt lu iv lv b lw lx jw ly lz ma jz mb mc md me mf mg mh mi mj mk ml mm mn mo io bi translated">在本实践教程中，我们将讨论使用自回归过程进行时间序列建模的主题。</p><p id="eb35" class="pw-post-body-paragraph lt lu iv lv b lw mp jw ly lz mq jz mb mc mr me mf mg ms mi mj mk mt mm mn mo io bi translated">本文将涵盖时间序列分析中的以下关键要素:</p><ul class=""><li id="0fcd" class="mu mv iv lv b lw mp lz mq mc mw mg mx mk my mo mz na nb nc bi translated">自回归过程</li><li id="7c09" class="mu mv iv lv b lw nd lz ne mc nf mg ng mk nh mo mz na nb nc bi translated">尤尔-沃克方程</li><li id="f36e" class="mu mv iv lv b lw nd lz ne mc nf mg ng mk nh mo mz na nb nc bi translated">平稳性</li><li id="a11c" class="mu mv iv lv b lw nd lz ne mc nf mg ng mk nh mo mz na nb nc bi translated">扩充的迪克-富勒试验</li></ul><p id="f02d" class="pw-post-body-paragraph lt lu iv lv b lw mp jw ly lz mq jz mb mc mr me mf mg ms mi mj mk mt mm mn mo io bi translated">确保准备好Jupyter笔记本，以便跟进。代码和数据集可在<a class="ae la" href="https://github.com/marcopeix/time-series-analysis" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p><p id="5b47" class="pw-post-body-paragraph lt lu iv lv b lw mp jw ly lz mq jz mb mc mr me mf mg ms mi mj mk mt mm mn mo io bi translated">我们开始吧！</p><blockquote class="ni"><p id="ea73" class="nj nk iv bd nl nm nn no np nq nr mo dk translated">了解如何使用更复杂的模型，如SARIMAX、VARMAX，并应用深度学习模型(LSTM、CNN、ResNet、自回归LSTM)进行时间序列分析，并使用Python中的<a class="ae la" href="https://www.datasciencewithmarco.com/offers/tdU2mtVK" rel="noopener ugc nofollow" target="_blank">应用时间序列分析</a>！</p></blockquote><h1 id="2d09" class="lb lc iv bd ld le lf lg lh li lj lk ll kb ns kc ln ke nt kf lp kh nu ki lr ls bi translated">自回归过程</h1><p id="addc" class="pw-post-body-paragraph lt lu iv lv b lw lx jw ly lz ma jz mb mc md me mf mg mh mi mj mk ml mm mn mo io bi translated">一个<strong class="lv iw">自回归模型</strong>使用目标过去值的线性组合进行预测。当然，回归是针对目标本身进行的。数学上，AR(p)模型表示为:</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi nv"><img src="../Images/3a7ea325900a6b2f2ee9e104d591f240.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*leVNdf2HTIZbPjb5Fi3PZQ.png"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">自回归模型</p></figure><p id="b955" class="pw-post-body-paragraph lt lu iv lv b lw mp jw ly lz mq jz mb mc mr me mf mg ms mi mj mk mt mm mn mo io bi translated">其中:</p><ul class=""><li id="35ab" class="mu mv iv lv b lw mp lz mq mc mw mg mx mk my mo mz na nb nc bi translated">p:这是命令吗</li><li id="33d4" class="mu mv iv lv b lw nd lz ne mc nf mg ng mk nh mo mz na nb nc bi translated">c:是常数</li><li id="f6ce" class="mu mv iv lv b lw nd lz ne mc nf mg ng mk nh mo mz na nb nc bi translated">ε:噪声</li></ul><p id="1d00" class="pw-post-body-paragraph lt lu iv lv b lw mp jw ly lz mq jz mb mc mr me mf mg ms mi mj mk mt mm mn mo io bi translated">AR(p)模型非常灵活，可以模拟许多不同类型的时间序列模式。当我们模拟自回归过程时，这是很容易想象的。</p><p id="ec8a" class="pw-post-body-paragraph lt lu iv lv b lw mp jw ly lz mq jz mb mc mr me mf mg ms mi mj mk mt mm mn mo io bi translated">通常，自回归模型仅适用于平稳时间序列。这限制了参数<em class="nw">φ</em>的范围。</p><p id="fc1d" class="pw-post-body-paragraph lt lu iv lv b lw mp jw ly lz mq jz mb mc mr me mf mg ms mi mj mk mt mm mn mo io bi translated">例如，AR(1)模型会将<em class="nw"> phi </em>限制在-1和1之间。随着模型阶数的增加，这些约束变得更加复杂，但是在Python中建模时会自动考虑这些约束。</p><h2 id="c37b" class="nx lc iv bd ld ny nz dn lh oa ob dp ll mc oc od ln mg oe of lp mk og oh lr oi bi translated">AR(2)过程的模拟</h2><p id="f56b" class="pw-post-body-paragraph lt lu iv lv b lw lx jw ly lz ma jz mb mc md me mf mg mh mi mj mk ml mm mn mo io bi translated">让我们用Python模拟一个AR(2)流程。</p><p id="eda4" class="pw-post-body-paragraph lt lu iv lv b lw mp jw ly lz mq jz mb mc mr me mf mg ms mi mj mk mt mm mn mo io bi translated">我们从导入一些库开始。并非所有这些都将用于模拟，但它们将是本教程其余部分所必需的。</p><pre class="kl km kn ko gt oj ok ol om aw on bi"><span id="54c9" class="nx lc iv ok b gy oo op l oq or">from statsmodels.graphics.tsaplots import plot_pacf<br/>from statsmodels.graphics.tsaplots import plot_acf<br/>from statsmodels.tsa.arima_process import ArmaProcess<br/>from statsmodels.tsa.stattools import pacf<br/>from statsmodels.regression.linear_model import yule_walker<br/>from statsmodels.tsa.stattools import adfuller<br/>import matplotlib.pyplot as plt<br/>import numpy as np</span><span id="b56f" class="nx lc iv ok b gy os op l oq or">%matplotlib inline</span></pre><p id="7dac" class="pw-post-body-paragraph lt lu iv lv b lw mp jw ly lz mq jz mb mc mr me mf mg ms mi mj mk mt mm mn mo io bi translated">我们将使用<em class="nw"> ArmaProcess </em>库来模拟时间序列。它要求我们定义我们的参数。</p><p id="92b1" class="pw-post-body-paragraph lt lu iv lv b lw mp jw ly lz mq jz mb mc mr me mf mg ms mi mj mk mt mm mn mo io bi translated">我们将模拟以下过程:</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi ot"><img src="../Images/8fd10d40ea027d0d4b3417c118762810.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A3EX_W7l_q1a7htqjCDevQ.png"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">AR(2)过程</p></figure><p id="7578" class="pw-post-body-paragraph lt lu iv lv b lw mp jw ly lz mq jz mb mc mr me mf mg ms mi mj mk mt mm mn mo io bi translated">因为我们正在处理一个2阶的自回归模型，我们需要定义滞后0，1和2的系数。</p><p id="983a" class="pw-post-body-paragraph lt lu iv lv b lw mp jw ly lz mq jz mb mc mr me mf mg ms mi mj mk mt mm mn mo io bi translated">此外，我们将取消移动平均线过程的影响。</p><p id="d856" class="pw-post-body-paragraph lt lu iv lv b lw mp jw ly lz mq jz mb mc mr me mf mg ms mi mj mk mt mm mn mo io bi translated">最后，我们将生成10 000个数据点。</p><p id="392c" class="pw-post-body-paragraph lt lu iv lv b lw mp jw ly lz mq jz mb mc mr me mf mg ms mi mj mk mt mm mn mo io bi translated">在代码中:</p><pre class="kl km kn ko gt oj ok ol om aw on bi"><span id="bfb4" class="nx lc iv ok b gy oo op l oq or">ar2 = np.array([1, 0.33, 0.5])<br/>ma = np.array([1])</span><span id="5444" class="nx lc iv ok b gy os op l oq or">simulated_AR2_data = ArmaProcess(ar2, ma).generate_sample(nsample=10000)</span></pre><p id="1d05" class="pw-post-body-paragraph lt lu iv lv b lw mp jw ly lz mq jz mb mc mr me mf mg ms mi mj mk mt mm mn mo io bi translated">我们可以绘制时间序列:</p><pre class="kl km kn ko gt oj ok ol om aw on bi"><span id="6c49" class="nx lc iv ok b gy oo op l oq or">plt.figure(figsize=[10, 7.5]); # Set dimensions for figure<br/>plt.plot(simulated_AR2_data)<br/>plt.title("Simulated AR(2) Process")<br/>plt.show()</span></pre><p id="6271" class="pw-post-body-paragraph lt lu iv lv b lw mp jw ly lz mq jz mb mc mr me mf mg ms mi mj mk mt mm mn mo io bi translated">您应该会得到类似这样的结果:</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/f0f0d6d2cd296b47a9b98a27e6bd736b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/1*MMPphG5YqvZ_DVnwu6NCfg.png"/></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">模拟AR(2)过程的图</p></figure><p id="5a31" class="pw-post-body-paragraph lt lu iv lv b lw mp jw ly lz mq jz mb mc mr me mf mg ms mi mj mk mt mm mn mo io bi translated">现在，让我们来看看自相关图(相关图):</p><pre class="kl km kn ko gt oj ok ol om aw on bi"><span id="bcf5" class="nx lc iv ok b gy oo op l oq or">plot_acf(simulated_AR2_data);</span></pre><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/078d80ab3a8a9c2c64e964a3de691f8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*-BgAphN-80muyhqQhl6Kww.png"/></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">AR(2)过程的相关图</p></figure><p id="d7f2" class="pw-post-body-paragraph lt lu iv lv b lw mp jw ly lz mq jz mb mc mr me mf mg ms mi mj mk mt mm mn mo io bi translated">你可以看到系数在慢慢衰减。这意味着它不太可能是一个<a class="ae la" rel="noopener" target="_blank" href="/basic-statistics-for-time-series-analysis-in-python-4cb147d56535">移动平均过程</a>，这表明时间序列可能可以用一个自回归过程来建模(这是有意义的，因为这正是我们正在模拟的)。</p><p id="1989" class="pw-post-body-paragraph lt lu iv lv b lw mp jw ly lz mq jz mb mc mr me mf mg ms mi mj mk mt mm mn mo io bi translated">为了确保这是正确的，让我们绘制偏自相关图:</p><pre class="kl km kn ko gt oj ok ol om aw on bi"><span id="373a" class="nx lc iv ok b gy oo op l oq or">plot_pacf(simulated_AR2_data);</span></pre><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/365bec3f7124660e16ae2f8d6e5057c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/1*0OaEBcdxiczmF7NK3S4niQ.png"/></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">AR(2)过程的偏自相关图</p></figure><p id="a27e" class="pw-post-body-paragraph lt lu iv lv b lw mp jw ly lz mq jz mb mc mr me mf mg ms mi mj mk mt mm mn mo io bi translated">正如你所看到的，滞后2之后，系数并不显著。因此，部分自相关图对于确定AR(p)过程的阶数是有用的。</p><p id="8b30" class="pw-post-body-paragraph lt lu iv lv b lw mp jw ly lz mq jz mb mc mr me mf mg ms mi mj mk mt mm mn mo io bi translated">您还可以通过运行以下命令来检查每个系数的值:</p><pre class="kl km kn ko gt oj ok ol om aw on bi"><span id="5d6e" class="nx lc iv ok b gy oo op l oq or">pacf_coef_AR2 = pacf(simulated_AR2_data)<br/>print(pacf_coef_AR2)</span></pre><p id="c97d" class="pw-post-body-paragraph lt lu iv lv b lw mp jw ly lz mq jz mb mc mr me mf mg ms mi mj mk mt mm mn mo io bi translated">现在，在真实的项目设置中，可以很容易地找到AR(p)过程的阶，但是我们需要找到一种方法来估计系数<em class="nw">φ</em>。</p><p id="dd44" class="pw-post-body-paragraph lt lu iv lv b lw mp jw ly lz mq jz mb mc mr me mf mg ms mi mj mk mt mm mn mo io bi translated">为此，我们使用了尤尔-沃克方程。这个方程允许我们在已知阶数的情况下估计AR(p)模型的系数。</p><pre class="kl km kn ko gt oj ok ol om aw on bi"><span id="e54d" class="nx lc iv ok b gy oo op l oq or">rho, sigma = yule_walker(simulated_AR2_data, 2, method='mle')<br/>print(f'rho: {-rho}')<br/>print(f'sigma: {sigma}')</span></pre><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi ox"><img src="../Images/62d3c44e4bb14b40b261fed6e2710fa4.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*1GuOqYFdxW9ZQcVmnhjrmQ.png"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">尤尔-沃克系数估计</p></figure><p id="2f79" class="pw-post-body-paragraph lt lu iv lv b lw mp jw ly lz mq jz mb mc mr me mf mg ms mi mj mk mt mm mn mo io bi translated">如你所见，Yule-Walker方程在估算我们的系数方面做得不错，非常接近0.33和0.5。</p><h2 id="ca4d" class="nx lc iv bd ld ny nz dn lh oa ob dp ll mc oc od ln mg oe of lp mk og oh lr oi bi translated">AR(3)过程的模拟</h2><p id="7463" class="pw-post-body-paragraph lt lu iv lv b lw lx jw ly lz ma jz mb mc md me mf mg mh mi mj mk ml mm mn mo io bi translated">现在，让我们模拟一个AR(3)过程。具体来说，我们将模拟:</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi oy"><img src="../Images/82be40e5b34ede169b83dd0e98c87d76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*00BoHSfbvvAL992AKvULrg.png"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">AR(3)过程模拟</p></figure><p id="bd79" class="pw-post-body-paragraph lt lu iv lv b lw mp jw ly lz mq jz mb mc mr me mf mg ms mi mj mk mt mm mn mo io bi translated">类似于之前所做的，让我们定义我们的系数并生成10 000个数据点:</p><pre class="kl km kn ko gt oj ok ol om aw on bi"><span id="3257" class="nx lc iv ok b gy oo op l oq or">ar3 = np.array([1, 0.33, 0.5, 0.07])<br/>ma = np.array([1])</span><span id="b74c" class="nx lc iv ok b gy os op l oq or">simulated_AR3_data = ArmaProcess(ar3,ma).generate_sample(nsample=10000)</span></pre><p id="5974" class="pw-post-body-paragraph lt lu iv lv b lw mp jw ly lz mq jz mb mc mr me mf mg ms mi mj mk mt mm mn mo io bi translated">然后，我们可以将时间序列可视化:</p><pre class="kl km kn ko gt oj ok ol om aw on bi"><span id="86aa" class="nx lc iv ok b gy oo op l oq or">plt.figure(figsize=[10, 7.5]); # Set dimensions for figure<br/>plt.plot(simulated_AR3_data)<br/>plt.title("Simulated AR(3) Process")<br/>plt.show()</span></pre><p id="afa5" class="pw-post-body-paragraph lt lu iv lv b lw mp jw ly lz mq jz mb mc mr me mf mg ms mi mj mk mt mm mn mo io bi translated">您应该会看到类似如下的内容:</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi oz"><img src="../Images/f27557f180c8c1f02c40781a71415137.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eAdOlUQba0kGhBDoUa5y9A.png"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">模拟AR(3)过程</p></figure><p id="f4fb" class="pw-post-body-paragraph lt lu iv lv b lw mp jw ly lz mq jz mb mc mr me mf mg ms mi mj mk mt mm mn mo io bi translated">现在，看看PACF和ACF:</p><pre class="kl km kn ko gt oj ok ol om aw on bi"><span id="ade0" class="nx lc iv ok b gy oo op l oq or">plot_pacf(simulated_AR3_data);<br/>plot_acf(simulated_AR3_data);</span></pre><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/c7cbebdfe69510a8c6bc9e3c73aa8552.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*z9eCgqQ5sD6yF6SGUoejHA.png"/></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">AR(3)流程的PACF和ACF</p></figure><p id="3dda" class="pw-post-body-paragraph lt lu iv lv b lw mp jw ly lz mq jz mb mc mr me mf mg ms mi mj mk mt mm mn mo io bi translated">你可以看到，对于PACF函数来说，滞后3之后的系数并不像预期的那样显著。</p><p id="c76f" class="pw-post-body-paragraph lt lu iv lv b lw mp jw ly lz mq jz mb mc mr me mf mg ms mi mj mk mt mm mn mo io bi translated">最后，让我们使用尤尔-沃克方程来估计系数:</p><pre class="kl km kn ko gt oj ok ol om aw on bi"><span id="e09d" class="nx lc iv ok b gy oo op l oq or">rho, sigma = yule_walker(simulated_AR3_data, 3, method='mle')<br/>print(f'rho: {-rho}')<br/>print(f'sigma: {sigma}')</span></pre><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/484167879dff48fc394197680e29469f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1086/format:webp/1*5ASgSkbDbP3wDHQqsnFtoA.png"/></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">尤尔-沃克系数估计</p></figure><p id="895c" class="pw-post-body-paragraph lt lu iv lv b lw mp jw ly lz mq jz mb mc mr me mf mg ms mi mj mk mt mm mn mo io bi translated">同样，估计值相当接近实际值。</p><h1 id="f4b4" class="lb lc iv bd ld le lf lg lh li lj lk ll kb lm kc ln ke lo kf lp kh lq ki lr ls bi translated">项目—预测强生公司的季度每股收益</h1><p id="896e" class="pw-post-body-paragraph lt lu iv lv b lw lx jw ly lz ma jz mb mc md me mf mg mh mi mj mk ml mm mn mo io bi translated">现在，让我们将自回归过程的知识应用到项目设置中。</p><p id="153f" class="pw-post-body-paragraph lt lu iv lv b lw mp jw ly lz mq jz mb mc mr me mf mg ms mi mj mk mt mm mn mo io bi translated">目标是模拟强生公司1960年至1980年间的每股季度收益(EPS)。</p><p id="8bcb" class="pw-post-body-paragraph lt lu iv lv b lw mp jw ly lz mq jz mb mc mr me mf mg ms mi mj mk mt mm mn mo io bi translated">首先，我们来读一下<a class="ae la" href="https://github.com/marcopeix/time-series-analysis" rel="noopener ugc nofollow" target="_blank">数据集</a>:</p><pre class="kl km kn ko gt oj ok ol om aw on bi"><span id="21fd" class="nx lc iv ok b gy oo op l oq or">import pandas as pd</span><span id="9335" class="nx lc iv ok b gy os op l oq or">data = pd.read_csv('jj.csv')<br/>data.head()</span></pre><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/92ebfc3ccfc676a67b141479468b0d8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:450/format:webp/1*sQk1-ngn_AXZoSKHVRx9ug.png"/></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">数据集的前五行</p></figure><p id="87c4" class="pw-post-body-paragraph lt lu iv lv b lw mp jw ly lz mq jz mb mc mr me mf mg ms mi mj mk mt mm mn mo io bi translated">现在，前五行对我们来说不是很有用。让我们绘制整个数据集，以获得更好的可视化表示。</p><pre class="kl km kn ko gt oj ok ol om aw on bi"><span id="59df" class="nx lc iv ok b gy oo op l oq or">plt.figure(figsize=[15, 7.5]); # Set dimensions for figure<br/>plt.scatter(data['date'], data['data'])<br/>plt.title('Quaterly EPS for Johnson &amp; Johnson')<br/>plt.ylabel('EPS per share ($)')<br/>plt.xlabel('Date')<br/>plt.xticks(rotation=90)<br/>plt.grid(True)<br/>plt.show()</span></pre><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi pd"><img src="../Images/79e05087b34d78d12ea8dcd6ccd47bcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*95_vk1ViW-5VQfj2uvZidQ.png"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">强生公司1960年至1980年间的每股收益</p></figure><p id="846f" class="pw-post-body-paragraph lt lu iv lv b lw mp jw ly lz mq jz mb mc mr me mf mg ms mi mj mk mt mm mn mo io bi translated">厉害！现在我们可以看到数据有明显的上升趋势。虽然这对公司来说可能是一个好迹象，但就时间序列建模而言，这并不好，因为这意味着时间序列不是平稳的。</p><p id="3136" class="pw-post-body-paragraph lt lu iv lv b lw mp jw ly lz mq jz mb mc mr me mf mg ms mi mj mk mt mm mn mo io bi translated">如前所述，AR(p)过程仅适用于平稳序列。</p><p id="5101" class="pw-post-body-paragraph lt lu iv lv b lw mp jw ly lz mq jz mb mc mr me mf mg ms mi mj mk mt mm mn mo io bi translated">因此，我们必须对数据进行一些转换，使其保持稳定。</p><p id="8e64" class="pw-post-body-paragraph lt lu iv lv b lw mp jw ly lz mq jz mb mc mr me mf mg ms mi mj mk mt mm mn mo io bi translated">在这种情况下，将取对数差。这相当于取每个值的对数，减去前一个值。</p><pre class="kl km kn ko gt oj ok ol om aw on bi"><span id="07bc" class="nx lc iv ok b gy oo op l oq or"># Take the log difference to make data stationary</span><span id="5bb5" class="nx lc iv ok b gy os op l oq or">data['data'] = np.log(data['data'])<br/>data['data'] = data['data'].diff()<br/>data = data.drop(data.index[0])<br/>data.head()</span></pre><p id="78af" class="pw-post-body-paragraph lt lu iv lv b lw mp jw ly lz mq jz mb mc mr me mf mg ms mi mj mk mt mm mn mo io bi translated">绘制转换后的时间序列:</p><pre class="kl km kn ko gt oj ok ol om aw on bi"><span id="cffc" class="nx lc iv ok b gy oo op l oq or">plt.figure(figsize=[15, 7.5]); # Set dimensions for figure<br/>plt.plot(data['data'])<br/>plt.title("Log Difference of Quaterly EPS for Johnson &amp; Johnson")<br/>plt.show()</span></pre><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi pe"><img src="../Images/0615704bff48cc2348ab2732cc8b3efe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nufc3uhZBxX2LL7DXpqEuQ.png"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">强生公司季度每股收益的对数差异</p></figure><p id="d469" class="pw-post-body-paragraph lt lu iv lv b lw mp jw ly lz mq jz mb mc mr me mf mg ms mi mj mk mt mm mn mo io bi translated">现在，似乎我们消除了这种趋势。然而，在用AR(p)过程建模之前，我们必须确保我们的序列是平稳的。</p><p id="fbfe" class="pw-post-body-paragraph lt lu iv lv b lw mp jw ly lz mq jz mb mc mr me mf mg ms mi mj mk mt mm mn mo io bi translated">因此，我们将使用扩展的Dicker-Fuller检验。这将给我们统计上的信心，我们的时间序列确实是平稳的。</p><pre class="kl km kn ko gt oj ok ol om aw on bi"><span id="f5f0" class="nx lc iv ok b gy oo op l oq or">ad_fuller_result = adfuller(data['data'])<br/>print(f'ADF Statistic: {ad_fuller_result[0]}')<br/>print(f'p-value: {ad_fuller_result[1]}')</span></pre><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/f37e92c3620b58ab4e8a3ae27904f921.png" data-original-src="https://miro.medium.com/v2/resize:fit:926/format:webp/1*VdAp7y3YxlOvbZjok4uBSw.png"/></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">ADF测试的结果</p></figure><p id="13be" class="pw-post-body-paragraph lt lu iv lv b lw mp jw ly lz mq jz mb mc mr me mf mg ms mi mj mk mt mm mn mo io bi translated">由于我们得到一个大的负ADF统计量和小于0.05的p值，我们可以拒绝零假设，说我们的时间序列是平稳的。</p><p id="6402" class="pw-post-body-paragraph lt lu iv lv b lw mp jw ly lz mq jz mb mc mr me mf mg ms mi mj mk mt mm mn mo io bi translated">现在，让我们通过绘制PACF来找到该过程的顺序:</p><pre class="kl km kn ko gt oj ok ol om aw on bi"><span id="cd27" class="nx lc iv ok b gy oo op l oq or">plot_pacf(data['data']);<br/>plot_acf(data['data']);</span></pre><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi ov"><img src="../Images/233e0d758d8e1aeee3590a2cf2e600dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*2Y1mXKjprG8O8uy7yvhJnQ.png"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">PACF和ACF</p></figure><p id="f40a" class="pw-post-body-paragraph lt lu iv lv b lw mp jw ly lz mq jz mb mc mr me mf mg ms mi mj mk mt mm mn mo io bi translated">正如你所看到的，在滞后4之后，PACF系数不再重要。因此，我们将假设一个4阶的自回归过程。</p><p id="3e13" class="pw-post-body-paragraph lt lu iv lv b lw mp jw ly lz mq jz mb mc mr me mf mg ms mi mj mk mt mm mn mo io bi translated">现在，我们将利用这些信息，通过Yule-Walker方程来估算系数:</p><pre class="kl km kn ko gt oj ok ol om aw on bi"><span id="ed1c" class="nx lc iv ok b gy oo op l oq or"># Try a AR(4) model<br/>rho, sigma = yule_walker(data['data'], 4)<br/>print(f'rho: {-rho}')<br/>print(f'sigma: {sigma}')</span></pre><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi pg"><img src="../Images/fa41a05858095019ecd3c9db6b8e4497.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fqAVwRfAb62ZP9-Dr6tZ8A.png"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">尤尔-沃克系数估计</p></figure><p id="b58f" class="pw-post-body-paragraph lt lu iv lv b lw mp jw ly lz mq jz mb mc mr me mf mg ms mi mj mk mt mm mn mo io bi translated">因此，该函数近似为:</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi ph"><img src="../Images/086e093acdcd8b0945008053a1f448cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f9TSZlVPeISQsjSt6RwUKw.png"/></div></div></figure><p id="9378" class="pw-post-body-paragraph lt lu iv lv b lw mp jw ly lz mq jz mb mc mr me mf mg ms mi mj mk mt mm mn mo io bi translated">请注意，此等式模拟了转换后的序列。</p><h1 id="d0c5" class="lb lc iv bd ld le lf lg lh li lj lk ll kb lm kc ln ke lo kf lp kh lq ki lr ls bi translated">结论</h1><p id="e858" class="pw-post-body-paragraph lt lu iv lv b lw lx jw ly lz ma jz mb mc md me mf mg mh mi mj mk ml mm mn mo io bi translated">恭喜你！您现在了解了什么是自回归模型，如何识别自回归过程，如何确定其顺序，以及如何使用它来模拟现实生活中的时间序列。</p><p id="10d3" class="pw-post-body-paragraph lt lu iv lv b lw mp jw ly lz mq jz mb mc mr me mf mg ms mi mj mk mt mm mn mo io bi translated">提高您的时间序列分析技能，并学习Python中时间序列分析的最新最佳实践:</p><ul class=""><li id="0812" class="mu mv iv lv b lw mp lz mq mc mw mg mx mk my mo mz na nb nc bi translated"><a class="ae la" href="https://www.datasciencewithmarco.com/offers/tdU2mtVK" rel="noopener ugc nofollow" target="_blank">在Python中应用时间序列分析</a></li></ul><p id="5f5a" class="pw-post-body-paragraph lt lu iv lv b lw mp jw ly lz mq jz mb mc mr me mf mg ms mi mj mk mt mm mn mo io bi translated">干杯🍺</p></div></div>    
</body>
</html>