<html>
<head>
<title>Image Processing and Data Augmentation Techniques for Computer Vision</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">计算机视觉的图像处理和数据增强技术</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/image-processing-techniques-for-computer-vision-11f92f511e21?source=collection_archive---------14-----------------------#2020-02-05">https://towardsdatascience.com/image-processing-techniques-for-computer-vision-11f92f511e21?source=collection_archive---------14-----------------------#2020-02-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e75592b6ba9b7410c3ae8b5c5d2edfe5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JoWEV6jvmno0MHF_T9ei7Q.jpeg"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://www.topbots.com/most-important-ai-computer-vision-research/" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="1cd0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">图像处理是计算机视觉的一个组成部分。我们几乎总是想要调整图像的大小，增加数据，查看网格中的图像，等等。<a class="ae kc" href="https://docs.opencv.org/master/d9/df8/tutorial_root.html" rel="noopener ugc nofollow" target="_blank"> OpenCV </a>(开源计算机视觉)、<a class="ae kc" href="https://scikit-image.org/" rel="noopener ugc nofollow" target="_blank"> scikit-image </a>、<a class="ae kc" href="https://pillow.readthedocs.io/en/stable/index.html" rel="noopener ugc nofollow" target="_blank"> Pillow </a>是Python中比较流行的一些图像处理库。在本文中，我介绍了一些最常用的图像处理技术。</p><p id="219a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是我在这篇文章中使用的Jupyter笔记本:<a class="ae kc" href="https://jovian.ml/aakanksha-ns/image-processing" rel="noopener ugc nofollow" target="_blank">https://jovian.ml/aakanksha-ns/image-processing</a></p><h1 id="9f22" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">1)读取图像</h1><p id="47ee" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">图像表示为由像素值组成的数组。8位图像的像素值范围从0(黑色)到255(白色)。根据色阶的不同，图像中有不同的<a class="ae kc" href="https://en.wikipedia.org/wiki/Channel_(digital_image)" rel="noopener ugc nofollow" target="_blank">通道</a>，每个通道代表一种特定颜色的像素值。RGB(红、绿、蓝)是最常用的色标，我在示例中使用的所有图像都是RGB图像。</p><p id="35ed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用OpenCV中的<code class="fe me mf mg mh b">imread</code>函数轻松读取图像数组。这里需要记住的一点是，OpenCV默认按照BGR顺序读取图像。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><h1 id="ff4e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">2)裁剪</h1><p id="78e8" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">裁剪是一种广泛使用的增强技术。然而，注意不要裁剪图像的重要部分(非常明显，但是当你有太多不同大小的图像时容易被忽略)。因为图像是用数组表示的，所以裁剪相当于从数组中取出一个切片:</p><p id="609d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">中心裁剪:</strong></p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="b054" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">随机裁剪:</strong></p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><h1 id="d911" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">3)调整大小</h1><p id="7821" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">大多数深度学习模型架构期望所有输入图像都具有相同的维度。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><h1 id="38ea" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">4)翻转图像</h1><p id="247d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">这是另一种非常流行的图像增强技术。这里唯一要记住的是，翻转应该对您的用例有意义。例如，如果您正在对建筑类型进行分类，您不会在测试集中遇到任何倒置的建筑，因此在这种情况下进行垂直翻转是没有意义的。</p><p id="53eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">垂直翻转:</strong></p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="b035" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">水平翻转:</strong></p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><h1 id="6a0d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">5)旋转图像:</h1><p id="d11a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在大多数情况下，可以将图像旋转一个小角度。在某些情况下，这种天真的做法可能会改变图像的整个方向，就像这样:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="1a4b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，更好的旋转方式是使用OpenCV进行仿射变换。仿射变换保留了共线性和距离比(例如:即使在变换后，线段的中点仍然是中点)。您也可以使用<code class="fe me mf mg mh b">BORDER_REFLECT</code>标志来填充边框。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><h1 id="b434" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">6)更改亮度和对比度:</h1><p id="42ce" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">这包括对每个像素应用以下函数:</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/145cbed70b37a009f24a899e014ff1ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:520/format:webp/1*Ec2ulriPY9293I9mDIlz8A.png"/></div></figure><p id="45b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里α(&gt; 0)称为增益，β称为偏置，这些参数据说分别控制对比度和亮度。因为我们使用数组表示图像，所以可以通过遍历数组将该函数应用于每个像素:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="8a32" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，对于较大的图像(如下图所示)，这可能需要一段时间，因此您需要使用优化的库函数:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">增加对比度</p></figure><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">增加亮度</p></figure><h1 id="29c1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">7)显示包围盒:</h1><p id="9554" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">目标检测是一个非常流行的计算机视觉问题，涉及到寻找包围感兴趣的目标的包围盒。在图片上显示包围盒可以帮助我们直观地检查问题和需求。在处理这些问题时要记住的一件事是，如果你打算翻转图像，确保你也相应地翻转了框坐标。这里有一个简单的方法来显示图像及其边界框。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><h1 id="a1a5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">8)在网格中显示多个图像:</h1><p id="4307" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们通常希望一次检查多幅图像。使用matplotlib中的子情节可以很容易地做到这一点。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><h1 id="d931" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">9)将图像转换为黑白图像:</h1><p id="afce" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">虽然没有在计算机视觉中广泛使用，但知道如何将彩色图像转换为灰度图像还是很不错的。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><h1 id="9929" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">10)模糊:</h1><p id="82d1" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">这项技术有助于使您的模型对图像质量问题更加稳健。如果一个模型可以在模糊的图像上表现良好，这可能表明该模型总体上表现良好。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><p id="eb7d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，还有很多针对特定问题的图像处理技术。例如，对于自动驾驶汽车，您可能想要标记道路上的其他汽车，并从各种角度查看它。但是，对于大多数问题，上述函数应该是有用的！</p></div></div>    
</body>
</html>