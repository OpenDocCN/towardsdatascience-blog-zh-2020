<html>
<head>
<title>Predicting Reddit Flairs using Machine Learning and Deploying the Model using Heroku — Part 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用机器学习预测 Reddit Flairs 并使用 Heroku 部署模型—第 3 部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/predicting-reddit-flairs-using-machine-learning-and-deploying-the-model-using-heroku-part-3-c3cd19374596?source=collection_archive---------61-----------------------#2020-05-31">https://towardsdatascience.com/predicting-reddit-flairs-using-machine-learning-and-deploying-the-model-using-heroku-part-3-c3cd19374596?source=collection_archive---------61-----------------------#2020-05-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/8c846340a5f70a52f9b315d93bebfcd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*P-rDm5bN9enOL7Dl"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">SpaceX 在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的<a class="ae jg" href="https://unsplash.com/@spacex?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"/></p></figure><h2 id="5180" class="jh ji jj bd b dl jk jl jm jn jo jp dk jq translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/reddit-flair-prediction" rel="noopener" target="_blank"> REDDIT 天赋预测系列</a></h2><div class=""/><div class=""><h2 id="eeb4" class="pw-subtitle-paragraph kp js jj bd b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dk translated">创建 web 应用程序并部署机器学习模型</h2></div><p id="611b" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果你被困在付费墙后面，点击<a class="ae jg" rel="noopener" target="_blank" href="/predicting-reddit-flairs-using-machine-learning-and-deploying-the-model-using-heroku-part-3-c3cd19374596?source=friends_link&amp;sk=388a869381f067253609f48647a17cd8">这里</a>获取我的朋友链接并查看这篇文章。</p><p id="b873" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">欢迎来到本系列的第 3 部分，我将继续解决<strong class="lj jt"> Reddit Flair 检测问题</strong>。在<a class="ae jg" href="https://medium.com/@prakharrathi25/predicting-reddit-flairs-using-machine-learning-and-deploying-the-model-on-heroku-part-1-574b69098d9a" rel="noopener">第 1 部分</a>中，我讨论了问题的背景和数据收集方法，在<a class="ae jg" rel="noopener" target="_blank" href="/predicting-reddit-flairs-using-machine-learning-and-deploying-the-model-using-heroku-part-2-d681e397f258">第 2 部分</a>中，我建立了一个机器学习模型来预测相应的 Fla。强烈建议您在开始这一篇之前通读这两篇文章，因为我已经分享了数据收集和模型构建过程背后的见解和推理。如果你已经完成了第一部分和第二部分，是时候恭喜你自己了，我真的为你完成了两个非常乏味的任务感到骄傲。你已经收集、整理、分析和模拟了大量数据，并且还建立了一个 ML 模型。大多数 ML 从业者通常在这里停下来，但是这是我们在第 3 部分中继续学习的地方。</p><p id="59c6" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在这一部分中，我们将继续使用我们在上一篇文章中构建的模型，并使用该模型根据 Reddit 帖子在 India subreddit 中的 URL 对任何新条目进行预测。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="cdd8" class="mk ml jj bd mm mn mo mp mq mr ms mt mu ky mv kz mw lb mx lc my le mz lf na nb bi translated">概述</h1><p id="8949" class="pw-post-body-paragraph lh li jj lj b lk nc kt lm ln nd kw lp lq ne ls lt lu nf lw lx ly ng ma mb mc im bi translated">到目前为止，我们已经使用 PRAW 图书馆收集了来自 India Subreddit 的数据。在执行文本分析后，我们尝试了 4 种机器学习模型，并根据性能选择了其中一种。我还在一个管道中转换了模型和数据预处理，以提高执行效率。我将使用逻辑回归，因为它是一个简单的模型，易于部署。这也不会在 Heroku 内部引发任何问题。你可以为此选择你自己的模型。这就是我们如何制作管道和训练模型。</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="0d21" class="nq ml jj nm b gy nr ns l nt nu">model = Pipeline([(‘vect’, CountVectorizer()),<br/>                   (‘tfidf’, TfidfTransformer()),<br/>                   (‘model’, LogisticRegression()),<br/>         ])</span><span id="2e28" class="nq ml jj nm b gy nv ns l nt nu"># Fit Model to the Data<br/>model.fit(X_train, y_train)</span></pre><h1 id="4cf5" class="mk ml jj bd mm mn nw mp mq mr nx mt mu ky ny kz mw lb nz lc my le oa lf na nb bi translated">部署</h1><p id="ec88" class="pw-post-body-paragraph lh li jj lj b lk nc kt lm ln nd kw lp lq ne ls lt lu nf lw lx ly ng ma mb mc im bi translated">部署过程有几个步骤:-</p><ul class=""><li id="100a" class="ob oc jj lj b lk ll ln lo lq od lu oe ly of mc og oh oi oj bi translated">保存模型</li><li id="12a1" class="ob oc jj lj b lk ok ln ol lq om lu on ly oo mc og oh oi oj bi translated">创建 web 应用程序界面</li><li id="c128" class="ob oc jj lj b lk ok ln ol lq om lu on ly oo mc og oh oi oj bi translated">创建烧瓶应用程序</li><li id="4acd" class="ob oc jj lj b lk ok ln ol lq om lu on ly oo mc og oh oi oj bi translated">把所有的都集中在一起</li></ul><h2 id="c0f1" class="nq ml jj bd mm op oq dn mq or os dp mu lq ot ou mw lu ov ow my ly ox oy na jp bi translated">保存模型</h2><p id="4f6f" class="pw-post-body-paragraph lh li jj lj b lk nc kt lm ln nd kw lp lq ne ls lt lu nf lw lx ly ng ma mb mc im bi translated">一旦您将您的模型保存为变量<code class="fe oz pa pb nm b">model</code>中的管道，并使其适合训练数据，现在是时候将它保存到一个文件中，以便我们稍后可以加载它以部署到我们的 web 应用程序中。我们使用一种叫做<strong class="lj jt">序列化</strong>的技术来保存我们的模型。简而言之，序列化是一种在磁盘上编写 python 对象的方法，该对象可以传输到任何地方，稍后可以由 python 脚本反序列化(读取)回来。有两种方法可以实现这一点[1]。</p><ol class=""><li id="0553" class="ob oc jj lj b lk ll ln lo lq od lu oe ly of mc pc oh oi oj bi translated"><strong class="lj jt">利用</strong> <a class="ae jg" href="https://docs.python.org/2/library/pickle.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lj jt">腌制</strong> </a></li></ol><figure class="nh ni nj nk gt iv gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/a1c8fc879f1586e5e3742d49e1927bdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*82jApwQQ1nHyuWA70Np71g.jpeg"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片由来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1520638" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae jg" href="https://pixabay.com/users/PhotoMIX-Company-1546875/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1520638" rel="noopener ugc nofollow" target="_blank">照片合成</a></p></figure><p id="a1f3" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">当然，图片是一个笑话，但泡菜图书馆其实真的很受欢迎，超级有用。(有趣的事实:泡菜只是蘸了醋的黄瓜)。总之，Pickle 是 Python 中序列化对象的标准方式。您可以使用 pickle 操作来序列化您的机器学习算法，并将序列化格式保存到文件中。稍后，您可以加载此文件来反序列化您的模型，并使用它来进行新的预测。</p><figure class="nh ni nj nk gt iv"><div class="bz fp l di"><div class="pe pf l"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">使用 pickle 库保存模型</p></figure><p id="1536" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jt"> 2。使用</strong><a class="ae jg" href="https://pypi.python.org/pypi/joblib" rel="noopener ugc nofollow" target="_blank"><strong class="lj jt">Joblib</strong></a><strong class="lj jt"/>(推荐用于较大型号)</p><p id="ffe7" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">Joblib 是 SciPy 生态系统的一部分，它提供了管道化 Python 作业的工具。因此，这就是我在这个项目中使用的。它提供了<a class="ae jg" href="https://pythonhosted.org/joblib/generated/joblib.dump.html" rel="noopener ugc nofollow" target="_blank">实用程序来有效地保存和加载利用 NumPy 数据结构的 Python 对象</a>。</p><p id="6fed" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这对于保存大量参数或者有时甚至存储整个数据集的机器学习算法是有用的。对于深度学习模型，我们通常会切换到. h5 文件。</p><figure class="nh ni nj nk gt iv"><div class="bz fp l di"><div class="pe pf l"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">使用 joblib 库保存模型</p></figure><h2 id="5b6d" class="nq ml jj bd mm op oq dn mq or os dp mu lq ot ou mw lu ov ow my ly ox oy na jp bi translated">创建 flask 应用程序及其接口。</h2><p id="0c91" class="pw-post-body-paragraph lh li jj lj b lk nc kt lm ln nd kw lp lq ne ls lt lu nf lw lx ly ng ma mb mc im bi translated">这一步对机器学习从业者来说有些新，这就是为什么我会给出我对大多数步骤的见解。我也会尽量不要用信息轰炸你。这里的可以参考整个代码<a class="ae jg" href="https://github.com/prakharrathi25/reddit-flair-predictor" rel="noopener ugc nofollow" target="_blank">。为此，我们将使用 flask。</a></p><p id="5396" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jt">注意:- </strong>这是一条非常重要的注意事项，请务必注意！很多人更喜欢下一步用 python 创建一个虚拟环境。这是因为它有助于通过为不同的项目创建独立的 python 虚拟环境来保持不同项目所需的依赖关系。这是大多数 Python 开发人员使用的最重要的工具之一。然而，对于本教程，我不是创建一个虚拟环境。如果你想创建一个虚拟环境，你可以在这里找到教程<a class="ae jg" href="https://packaging.python.org/guides/installing-using-pip-and-virtual-environments/" rel="noopener ugc nofollow" target="_blank"/>。如果您继续进行虚拟环境，那么您将需要的依赖项列表可以在<a class="ae jg" href="https://github.com/prakharrathi25/reddit-flair-predictor/blob/master/requirements.txt" rel="noopener ugc nofollow" target="_blank">这里</a>找到。确保下载文件并在虚拟环境中运行命令。</p><pre class="nh ni nj nk gt nl nm nn no aw np bi"><span id="ca06" class="nq ml jj nm b gy nr ns l nt nu">pip install -r requirements.txt</span><span id="66f2" class="nq ml jj nm b gy nv ns l nt nu">or </span><span id="879d" class="nq ml jj nm b gy nv ns l nt nu">pip3 install -r requirements.txt</span></pre><p id="03e6" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这个文件对于虚拟 env 和非虚拟 env 用户都是必需的，但是，那些不使用虚拟环境的用户可能已经满足了大部分要求。</p><p id="0057" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jt">为什么是烧瓶？【2】</strong></p><ul class=""><li id="11ec" class="ob oc jj lj b lk ll ln lo lq od lu oe ly of mc og oh oi oj bi translated">好用。</li><li id="a942" class="ob oc jj lj b lk ok ln ol lq om lu on ly oo mc og oh oi oj bi translated">内置的开发服务器和调试器。</li><li id="c539" class="ob oc jj lj b lk ok ln ol lq om lu on ly oo mc og oh oi oj bi translated">集成单元测试支持。</li><li id="e5ef" class="ob oc jj lj b lk ok ln ol lq om lu on ly oo mc og oh oi oj bi translated">RESTful 请求调度。</li><li id="9779" class="ob oc jj lj b lk ok ln ol lq om lu on ly oo mc og oh oi oj bi translated">大量记录。</li></ul><p id="ac9b" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们开始吧！您可以在这里访问存储库<a class="ae jg" href="https://github.com/prakharrathi25/reddit-flair-predictor" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h2 id="ee38" class="nq ml jj bd mm op oq dn mq or os dp mu lq ot ou mw lu ov ow my ly ox oy na jp bi translated">前端</h2><p id="f467" class="pw-post-body-paragraph lh li jj lj b lk nc kt lm ln nd kw lp lq ne ls lt lu nf lw lx ly ng ma mb mc im bi translated">让我们从使用 HTML 为用户输入帖子的 URL 的前端开始。我将保持这个相当简单和实用，因为这不是一个前端开发课程。这个页面看起来非常简单。为此你需要三个文件，我已经把它们放在模板库<a class="ae jg" href="https://github.com/prakharrathi25/reddit-flair-predictor/blob/master/templates" rel="noopener ugc nofollow" target="_blank">下面了</a>。</p><ol class=""><li id="bb84" class="ob oc jj lj b lk ll ln lo lq od lu oe ly of mc pc oh oi oj bi translated"><strong class="lj jt"> base.html: </strong>基础文件</li><li id="8459" class="ob oc jj lj b lk ok ln ol lq om lu on ly oo mc pc oh oi oj bi translated"><strong class="lj jt"> index.html: </strong>接受输入的启动页面</li><li id="4e93" class="ob oc jj lj b lk ok ln ol lq om lu on ly oo mc pc oh oi oj bi translated"><strong class="lj jt"> show.html: </strong>显示结果的页面</li></ol><p id="4f88" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我已经使用 Django 模板扩展前端。如果你不知道那是什么，那么你不必担心。这是一个简单的概念，通过类可以更好地理解。我已经定义了一个<strong class="lj jt">基础</strong>文件，它在索引和显示文件中被扩展，这样我就不必一次又一次地编写引导程序和头文件代码。基本文件从存储在名为<a class="ae jg" href="https://pypi.org/project/Flask-Bootstrap/" rel="noopener ugc nofollow" target="_blank"> Flask_Bootstrap </a>的 Python 库中的引导基本文件中获取内容。你可以在这里阅读更多关于扩展<a class="ae jg" href="https://tutorial.djangogirls.org/en/template_extending/" rel="noopener ugc nofollow" target="_blank">的内容</a>。</p><figure class="nh ni nj nk gt iv"><div class="bz fp l di"><div class="pe pf l"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">从引导基本文件继承的基本文件</p></figure><figure class="nh ni nj nk gt iv"><div class="bz fp l di"><div class="pe pf l"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">默认起始页的索引文件</p></figure><p id="50e1" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这是输出的样子。我说过，这只是为了我们的效用。你可以自由添加你自己的 CSS。事实上，我对来自任何想为这个页面贡献和添加样式的人的<a class="ae jg" href="https://github.com/prakharrathi25/reddit-flair-predictor/pulls" rel="noopener ugc nofollow" target="_blank">拉请求</a>持开放态度。</p><figure class="nh ni nj nk gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pg"><img src="../Images/d452f8793e4419cba65d2ddf84ce5189.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eKPj6WxTTTI2P0AVc1dFgQ.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">索引页</p></figure><p id="5890" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">show.html 网页将按以下方式设计。当我显示弹出的结果时，我会在最后显示输出。你可以把这三个都放在<strong class="lj jt">模板</strong>文件夹中，而任何图像和样式都放在<strong class="lj jt">静态</strong>文件夹中(这是惯例)。</p><figure class="nh ni nj nk gt iv"><div class="bz fp l di"><div class="pe pf l"/></div></figure><p id="a535" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jt">接收数据并显示结果的 API</strong></p><p id="957c" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">下一步是创建一个 API 来接收 URL，然后在预测之后显示结果。所有这些都要通过 GUI 来完成。基本概念是，我们需要创建一个执行以下步骤的接口:-</p><ol class=""><li id="50bb" class="ob oc jj lj b lk ll ln lo lq od lu oe ly of mc pc oh oi oj bi translated">使用表单将 URL 作为索引页面的输入</li><li id="29d3" class="ob oc jj lj b lk ok ln ol lq om lu on ly oo mc pc oh oi oj bi translated">从 Reddit 网站上抓取数据</li><li id="0d6b" class="ob oc jj lj b lk ok ln ol lq om lu on ly oo mc pc oh oi oj bi translated">取消模型的序列化</li><li id="aca6" class="ob oc jj lj b lk ok ln ol lq om lu on ly oo mc pc oh oi oj bi translated">使用反序列化的模型对数据进行预测</li><li id="d4a8" class="ob oc jj lj b lk ok ln ol lq om lu on ly oo mc pc oh oi oj bi translated">显示输出</li></ol><p id="262c" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在，在一个文件中完成所有这些是可能的，但是，我认为如果有两个不同的文件，这只会使过程更加直观和灵活。当您必须通过单个文件处理多个 POST 请求时，这也很有帮助。我将创建两个文件— <code class="fe oz pa pb nm b"><strong class="lj jt">app.py</strong></code>文件，在这里我将通过来自<code class="fe oz pa pb nm b">index.html</code>文件的 POST 请求从表单中获取数据，在<code class="fe oz pa pb nm b"><strong class="lj jt">inference.py </strong></code>文件中我将反序列化模型并获取预测。我将把预测的类返回到<code class="fe oz pa pb nm b">app.py</code>文件，并通过<code class="fe oz pa pb nm b">show.html</code>文件显示结果。有道理，对吧？</p><figure class="nh ni nj nk gt iv"><div class="bz fp l di"><div class="pe pf l"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">获取数据并发送输出的 app.py 文件</p></figure><figure class="nh ni nj nk gt iv"><div class="bz fp l di"><div class="pe pf l"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">做出预测的推论</p></figure><p id="06a1" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">您可以看到 app.py 文件导入了推理模块并调用了方法<code class="fe oz pa pb nm b">get_flair(text=url).</code>。我已经将推理文件中的模型反序列化，并将其作为参数与 URL 一起发送给了方法。其他一切都发生在推理文件中。您可能已经注意到，这些是我们在第 1 部分和第 2 部分中遵循的步骤。我们下载并清理数据，然后将其发送到我们的模型，该模型对数据进行矢量化和转换。然后，该模型进行预测并返回预测的类，该类存储在第 6 行的<code class="fe oz pa pb nm b">show.html </code>文件选取的<code class="fe oz pa pb nm b">result</code>变量中。</p><p id="a702" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">让我们来看看这个应用程序的运行情况。这是到我测试过的帖子的<a class="ae jg" href="https://www.reddit.com/r/india/comments/gtwkls/indian_support_for_george_floyd_while_we_remain/" rel="noopener ugc nofollow" target="_blank">链接。</a></p><figure class="nh ni nj nk gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ph"><img src="../Images/adc79859cfe36384252ba38dc8dcce5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PZPi5eLSyCgvcz8x6YS1sA.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">上传链接。</p></figure><figure class="nh ni nj nk gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pi"><img src="../Images/b52608a05ffb5859f0b52d398496b601.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iau0x681Gif8arG4U4gIBg.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">输出</p></figure><p id="246f" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果这种风格不像<a class="ae jg" href="https://www.reddit.com/r/todayilearned/comments/gu54po/til_when_congress_imposed_a_gag_rule_in_1836_to/" rel="noopener ugc nofollow" target="_blank">这个</a>那样来自印度 Subreddit，那么我们就用这个。</p><figure class="nh ni nj nk gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pj"><img src="../Images/e4d75d4b6b0643e5923a0f9544ca0faf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qk10QjlSIVv3AidQD-aesA.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">不正确的子编辑</p></figure><h1 id="200f" class="mk ml jj bd mm mn nw mp mq mr nx mt mu ky ny kz mw lb nz lc my le oa lf na nb bi translated">结论</h1><p id="c19e" class="pw-post-body-paragraph lh li jj lj b lk nc kt lm ln nd kw lp lq ne ls lt lu nf lw lx ly ng ma mb mc im bi translated">本文展示了一种部署机器学习模型的非常简单的方法。你可以利用在本博客中获得的知识制作一些很酷的模型，并投入生产。到目前为止，这是一个漫长的旅程，我们已经做了很多事情，如废弃数据、建立模型并最终部署它们。一定很忙。所以，接下来的部分不再有机器学习了。在第 4 部分中，我将讨论如何使用 Heroku 使您的应用程序上线，Heroku 是一个平台即服务(PaaS ),它使开发人员能够完全在云中构建、运行和操作应用程序。您将能够像我在这里  <strong class="lj jt">所做的那样<a class="ae jg" href="https://flair-prediction-app.herokuapp.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="lj jt">部署您的应用程序。</strong></a></strong></p><p id="9938" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">继续<a class="ae jg" href="https://medium.com/@prakharrathi25/predicting-reddit-flairs-using-machine-learning-and-deploying-the-model-using-heroku-part-4-7d5cb923d3d3?sk=546da054ceb84146643e73e874123e81" rel="noopener">第 4 部分</a>！本系列的最后一部分。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="5e54" class="mk ml jj bd mm mn mo mp mq mr ms mt mu ky mv kz mw lb mx lc my le mz lf na nb bi translated">参考</h1><ol class=""><li id="5ed9" class="ob oc jj lj b lk nc ln nd lq pk lu pl ly pm mc pc oh oi oj bi translated"><a class="ae jg" href="https://machinelearningmastery.com/save-load-machine-learning-models-python-scikit-learn/" rel="noopener ugc nofollow" target="_blank">https://machine learning mastery . com/save-load-machine-learning-models-python-sci kit-learn/</a></li><li id="64ca" class="ob oc jj lj b lk ok ln ol lq om lu on ly oo mc pc oh oi oj bi translated"><a class="ae jg" rel="noopener" target="_blank" href="/how-to-easily-deploy-machine-learning-models-using-flask-b95af8fe34d4">https://towards data science . com/how-to-easy-deploy-machine-learning-models-using-flask-b 95 af 8 Fe 34d 4</a></li></ol></div></div>    
</body>
</html>