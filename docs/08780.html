<html>
<head>
<title>How to extend a Keras Model</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何扩展Keras模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-extend-a-keras-model-5effc083265c?source=collection_archive---------53-----------------------#2020-06-24">https://towardsdatascience.com/how-to-extend-a-keras-model-5effc083265c?source=collection_archive---------53-----------------------#2020-06-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2aea" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用Keras模型时传递实例键和特征</h2></div><p id="d395" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通常，您只需要Keras模型返回预测值，但是在某些情况下，您希望您的预测保留一部分输入。一个常见的例子是在执行批量预测时转发唯一的“实例键”。在这篇博客和<a class="ae lb" href="https://github.com/GoogleCloudPlatform/training-data-analyst/blob/master/blogs/batch_predictions/batch_predictions_keras.ipynb" rel="noopener ugc nofollow" target="_blank">对应的笔记本代码</a>中，我将演示如何修改一个经过训练的Keras模型的签名，以将特性转发到输出或传递实例键。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lc"><img src="../Images/76c3825dabd98a6e6e043272ae3522cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2QRpOIQZDoMmCdId"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">通过实例键排序。照片由<a class="ae lb" href="https://unsplash.com/@contradirony?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Samantha Lam </a>在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="0c33" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">如何将实例键转发到输出</h1><p id="2cca" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">有时，您会有一个与每一行相关联的唯一实例键，并且您希望该键与预测一起输出，以便您知道该预测属于哪一行。当使用类似<a class="ae lb" href="http://l" rel="noopener ugc nofollow" target="_blank">云人工智能平台批量预测</a>的服务执行分布式批量预测时，您需要添加密钥。此外，如果您正在对模型执行连续评估，并且想要记录有关预测的元数据以供以后分析。<a class="mp mq ep" href="https://medium.com/u/247b0630b5d6?source=post_page-----5effc083265c--------------------------------" rel="noopener" target="_blank"> Lak Lakshmanan </a>展示了<a class="ae lb" rel="noopener" target="_blank" href="/how-to-extend-a-canned-tensorflow-estimator-to-add-more-evaluation-metrics-and-to-pass-through-ddf66cd3047d">如何使用张量流估值器</a>实现这一点，但是Keras呢？</p><p id="70c8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设您有一个以前训练过的模型，它已经用<code class="fe mr ms mt mu b">tf.saved_model.save()</code>保存了。运行以下代码，您可以检查模型的服务签名，并查看预期的输入和输出:</p><pre class="ld le lf lg gt mv mu mw mx aw my bi"><span id="4496" class="mz lt iq mu b gy na nb l nc nd">tf.saved_model.save(model, MODEL_EXPORT_PATH)</span><span id="3688" class="mz lt iq mu b gy ne nb l nc nd">!saved_model_cli show — tag_set serve — signature_def serving_default — dir {MODEL_EXPORT_PATH}</span><span id="2ad0" class="mz lt iq mu b gy ne nb l nc nd">The given SavedModel SignatureDef contains the following input(s):<br/>  inputs['image'] tensor_info:<br/>      dtype: DT_FLOAT<br/>      shape: (-1, 28, 28)<br/>      name: serving_default_image:0<br/>The given SavedModel SignatureDef contains the following output(s):<br/>  outputs['preds'] tensor_info:<br/>      dtype: DT_FLOAT<br/>      shape: (-1, 10)<br/>      name: StatefulPartitionedCall:0<br/>Method name is: tensorflow/serving/predict</span></pre><p id="a79f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要传递唯一的行键和先前保存的模型，请加载您的模型，创建一个替代的服务函数，然后重新保存，如下所示:</p><pre class="ld le lf lg gt mv mu mw mx aw my bi"><span id="c6ba" class="mz lt iq mu b gy na nb l nc nd">loaded_model = tf.keras.models.load_model(MODEL_EXPORT_PATH)</span><span id="3d47" class="mz lt iq mu b gy ne nb l nc nd">@tf.function(input_signature=[tf.TensorSpec([None], dtype=tf.string),tf.TensorSpec([None, 28, 28], dtype=tf.float32)])<br/>def keyed_prediction(key, image):<br/>    pred = loaded_model(image, training=False)<br/>    return {<br/>        'preds': pred,<br/>        'key': key<br/>    }</span><span id="d616" class="mz lt iq mu b gy ne nb l nc nd"># Resave model, but specify new serving signature<br/>KEYED_EXPORT_PATH = './keyed_model/'</span><span id="6014" class="mz lt iq mu b gy ne nb l nc nd">loaded_model.save(KEYED_EXPORT_PATH, signatures={'serving_default': keyed_prediction})</span></pre><p id="0c9d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，当我们检查模型的服务签名时，我们会看到它将键作为输入和输出:</p><pre class="ld le lf lg gt mv mu mw mx aw my bi"><span id="7e82" class="mz lt iq mu b gy na nb l nc nd">!saved_model_cli show --tag_set serve --signature_def serving_default --dir {KEYED_EXPORT_PATH}</span><span id="c503" class="mz lt iq mu b gy ne nb l nc nd">The given SavedModel SignatureDef contains the following input(s):<br/>  inputs['image'] tensor_info:<br/>      dtype: DT_FLOAT<br/>      shape: (-1, 28, 28)<br/>      name: serving_default_image:0<br/>  inputs['key'] tensor_info:<br/>      dtype: DT_STRING<br/>      shape: (-1)<br/>      name: serving_default_key:0<br/>The given SavedModel SignatureDef contains the following output(s):<br/>  outputs['key'] tensor_info:<br/>      dtype: DT_STRING<br/>      shape: (-1)<br/>      name: StatefulPartitionedCall:0<br/>  outputs['preds'] tensor_info:<br/>      dtype: DT_FLOAT<br/>      shape: (-1, 10)<br/>      name: StatefulPartitionedCall:1<br/>Method name is: tensorflow/serving/predict</span></pre><p id="7384" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您的模型服务现在将在任何预测调用中同时期待一个<code class="fe mr ms mt mu b">image</code>张量和一个<code class="fe mr ms mt mu b">key</code>，并将在其响应中输出<code class="fe mr ms mt mu b">preds</code>和<code class="fe mr ms mt mu b">key</code>。这种方法的一个好处是，您不需要访问生成模型的代码，只需要访问序列化的SavedModel。</p><h1 id="3214" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">如何利用多个服务签名</h1><p id="2283" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">有时保存具有两个服务签名的模型是方便的，或者是出于兼容性原因(即默认签名是未加密的)，或者是为了使单个服务基础结构可以处理加密和未加密的预测，并且用户决定执行哪一个。您需要从加载的模型中提取服务函数，并在再次保存时将其指定为服务签名之一:</p><pre class="ld le lf lg gt mv mu mw mx aw my bi"><span id="d066" class="mz lt iq mu b gy na nb l nc nd">inference_function = loaded_model.signatures['serving_default']</span><span id="9c95" class="mz lt iq mu b gy ne nb l nc nd">loaded_model.save(DUAL_SIGNATURE_EXPORT_PATH, signatures={'serving_default': keyed_prediction,<br/>    'unkeyed_signature': inference_function})</span></pre><h1 id="0460" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">如何将输入要素转发到输出</h1><p id="698d" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">出于模型调试的目的，您可能还希望转发某些输入要素，或者计算特定数据切片的评估指标(例如，根据婴儿是早产还是足月来计算婴儿体重的RMSE)。</p><p id="84ce" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本例假设您使用了多个命名输入，如果您想利用TensorFlow特性列，您可以这样做，如这里的<a class="ae lb" rel="noopener" target="_blank" href="/how-to-build-a-wide-and-deep-model-using-keras-in-tensorflow-2-0-2f7a236b5a4b">所述</a>。您的第一个选择是像往常一样训练模型，并利用Keras Functional API创建略有不同的模型签名，同时保持相同的权重:</p><pre class="ld le lf lg gt mv mu mw mx aw my bi"><span id="897e" class="mz lt iq mu b gy na nb l nc nd">tax_rate = Input(shape=(1,), dtype=tf.float32, name="tax_rate")<br/>rooms = Input(shape=(1,), dtype=tf.float32, name="rooms")</span><span id="8da9" class="mz lt iq mu b gy ne nb l nc nd">x = tf.keras.layers.Concatenate()([tax_rate, rooms])<br/>x = tf.keras.layers.Dense(64, activation='relu')(x)<br/>price = tf.keras.layers.Dense(1, activation=None, name="price")(x)</span><span id="b428" class="mz lt iq mu b gy ne nb l nc nd"># Functional API model instead of Sequential<br/>model = Model(inputs=[tax_rate, rooms], outputs=[price])</span><span id="dba3" class="mz lt iq mu b gy ne nb l nc nd"># Compile, train, etc...<br/>#<br/>#<br/>#</span><span id="c853" class="mz lt iq mu b gy ne nb l nc nd">forward_model = Model(inputs=[tax_rate, rooms], outputs=[price, tax_rate])</span></pre><p id="7c9f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一种方法，如果您没有生成模型的代码，则特别有用，就是像使用键控预测模型一样修改服务签名:</p><pre class="ld le lf lg gt mv mu mw mx aw my bi"><span id="52cd" class="mz lt iq mu b gy na nb l nc nd">@tf.function(input_signature=[tf.TensorSpec([None, 1], dtype=tf.float32), tf.TensorSpec([None, 1], dtype=tf.float32)])<br/>def feature_forward_prediction(tax_rate, rooms):<br/>    pred = model([tax_rate, rooms], training=False)<br/>    return {<br/>        'price': pred,<br/>        'tax_rate': tax_rate<br/>    }</span><span id="c429" class="mz lt iq mu b gy ne nb l nc nd">model.save(FORWARD_EXPORT_PATH, signatures={'serving_default': feature_forward_prediction})</span></pre><p id="a55b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽情享受吧！</p><p id="b78c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nf">感谢</em> <a class="ae lb" href="https://medium.com/@lakshmanok" rel="noopener"> <em class="nf">拉克什马南</em> </a> <em class="nf">帮我把他原来的估计器帖子更新到Keras。</em></p></div></div>    
</body>
</html>