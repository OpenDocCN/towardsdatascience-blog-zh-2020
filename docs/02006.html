<html>
<head>
<title>Quick and easy model evaluation with Yellowbrick</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Yellowbrick进行快速简单的模型评估</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/quick-and-easy-model-evaluation-with-yellowbrick-295cb0752bce?source=collection_archive---------26-----------------------#2020-02-25">https://towardsdatascience.com/quick-and-easy-model-evaluation-with-yellowbrick-295cb0752bce?source=collection_archive---------26-----------------------#2020-02-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ef61" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">回顾一下机器学习工作流程的便捷工具</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/53080e892b45ca5244dfaff83444ec54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0OGTG5WOHEiE26gYaNWFQA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">JR克里奇摄，2016。</p></figure><p id="b996" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我偶尔会遇到一个Python包，它有可能简化我经常做的一项任务。当这种情况发生时，我总是很兴奋地尝试它，如果它很棒，就分享我的新知识。</p><p id="284e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">几个月前，我在浏览Twitter时，看到了一条关于模型可视化包Yellowbrick的推文。我试过，喜欢，现在把它纳入我的机器学习工作流程。在这篇文章中，我将向你展示它能做什么的几个例子(你也可以随时去<a class="ae lu" href="https://www.scikit-yb.org/en/latest/quickstart.html" rel="noopener ugc nofollow" target="_blank">查看文档</a>)。</p><h1 id="c5f1" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">快速事实</h1><p id="de34" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">关于Yellowbrick的一些快速事实:</p><ul class=""><li id="54a7" class="ms mt it la b lb lc le lf lh mu ll mv lp mw lt mx my mz na bi translated">其目的是模型可视化，即帮助您直观地了解给定模型如何处理您的数据，以便您可以就是否选择该模型或如何调整它做出明智的选择。</li><li id="13b9" class="ms mt it la b lb nb le nc lh nd ll ne lp nf lt mx my mz na bi translated">它的界面很像<a class="ae lu" href="https://scikit-learn.org/stable/" rel="noopener ugc nofollow" target="_blank"> scikit-learn </a>的界面。如果您熟悉实例化模型、使其适合训练数据、然后在一行代码中进行评分或预测的工作流程，那么您将很快学会Yellowbrick。</li><li id="b8aa" class="ms mt it la b lb nb le nc lh nd ll ne lp nf lt mx my mz na bi translated">Yellowbrick包含基于<a class="ae lu" href="https://matplotlib.org/" rel="noopener ugc nofollow" target="_blank"> Matplotlib </a>的“visualizers”(一个特定于该包的类)，用于主要类型的建模应用，包括回归、分类、聚类、时间序列建模等。，因此可能有一个可以帮助您处理大多数日常建模情况。</li></ul><h1 id="132d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">总体意见</h1><p id="be3a" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">总的来说，我喜欢使用Yellowbrick，因为它为我节省了一些日常任务的时间。例如，我有自己的代码来可视化特性的重要性或生成一个颜色比例的混淆矩阵，我从一个项目复制到另一个项目，但是Yellowbrick让我可以用更少的代码行快速轻松地生成一个有吸引力的图。</p><p id="c939" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当然，这种简单实现的缺点是，您无法像自己编码那样控制图形的外观。如果视觉化只是为了你的利益，很好；但是，如果您需要以任何方式操纵情节，请准备好钻研文档。当然，这是一个公平的交易，但是在你开始之前要考虑你的地块的最终用户，这样你就不用做两次了(一次在Yellowbrick，一次在Matplotlib/Seaborn/等等)。).</p><p id="5223" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">说到做事两次，我们来看看Yellowbrick v. Matplotlib中同样的可视化套路。</p><h1 id="4051" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">Yellowbrick诉Matplotlib的特征重要性</h1><p id="fe03" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">对于这个小案例研究，我将为UCI葡萄酒数据集拟合一个随机森林分类器<a class="ae lu" href="https://archive.ics.uci.edu/ml/datasets/Wine" rel="noopener ugc nofollow" target="_blank">，然后使用一个柱状图来可视化每个特征对于预测的重要性。数据集很小(178行，13列)，分类的目的是基于各种特征预测一种葡萄酒包含三种栽培品种中的哪一种。</a></p><p id="5ef3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，基础知识:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="4954" class="nl lw it nh b gy nm nn l no np"># Import basic packages<br/>import pandas as pd<br/>import numpy as np<br/>import matplotlib.pyplot as plt<br/><br/># In Jupyter Notebook, run this to display plots inline<br/>%matplotlib inline<br/><br/># Get the dataset from sklearn<br/>from sklearn.datasets import load_wine<br/>data = load_wine()<br/><br/># Prep features and target for use<br/>X = data.data<br/>X = pd.DataFrame(X)<br/>X.columns = [x.capitalize() for x in data.feature_names]<br/><br/>y = data.target</span></pre><p id="1490" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的代码中，我使用sklearn的内置load_wine()类获取数据，并将其分成特性(X)和目标(y)。请注意，我采取了额外的步骤，将X转换为DataFrame，并给列起了漂亮的大写名称。这将使我的生活更容易的时候，建立情节。</p><p id="2020" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">先来看看Yellowbrick的套路。我将实例化一个RandomForestClassifier()和一个FeatureImportances()可视化工具，然后调整可视化工具并显示绘图。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="b0a8" class="nl lw it nh b gy nm nn l no np"># Import model and visualizer<br/>from yellowbrick.model_selection import FeatureImportances<br/>from sklearn.ensemble import RandomForestClassifier</span><span id="bd62" class="nl lw it nh b gy nq nn l no np"># Instantiate model and visualizer<br/>model = RandomForestClassifier(n_estimators=10, random_state=1)<br/>visualizer = FeatureImportances(model)</span><span id="b536" class="nl lw it nh b gy nq nn l no np"># Fit and display visualizer<br/>visualizer.fit(X, y)<br/>visualizer.show();</span></pre><p id="8dec" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这就是你得到的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/51a08f140f5e46f46969a2d6ce4db3bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HGTIs40D4vo_dwFWo0DT0g.png"/></div></div></figure><p id="7364" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在四行代码中(不包括导入语句)，我得到了一个看起来不错的特性重要性图。我一眼就可以看出，脯氨酸对于识别品种非常重要，而苹果酸和灰分的碱度则不重要。</p><p id="827f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一些小小的抱怨:</p><ul class=""><li id="e610" class="ms mt it la b lb lc le lf lh mu ll mv lp mw lt mx my mz na bi translated">颜色不能传达任何真实的信息，所以如果我手工编写代码，我会让所有的条形保持相同的颜色。</li><li id="9148" class="ms mt it la b lb nb le nc lh nd ll ne lp nf lt mx my mz na bi translated">x轴已被重新标记，以最重要功能的重要性百分比来表示每个功能的相对重要性。所以脯氨酸，最重要的特征，在100%，灰分的碱度在5%左右。我更愿意看到由随机森林模型计算出的要素重要性值，因为即使是最重要的要素也只能解释数据中很小一部分的差异。黄砖图掩盖了绝对特征的重要性，有利于呈现相对重要性，我们可以从图中条形的长度推断出相对重要性！</li></ul><p id="9245" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，让我向您展示如何在Matplotlib中手工构建完全相同的图。我将从拟合RandomForestClassifier()开始:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="d2ba" class="nl lw it nh b gy nm nn l no np"># Fit a RandomForestClassifier<br/>from sklearn.ensemble import RandomForestClassifier<br/>model = RandomForestClassifier(n_estimators=10, random_state=1)<br/>model.fit(X, y)</span></pre><p id="7a8f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意，我用与上面相同数量的估计器和随机状态实例化了模型，所以特性重要性值应该完全相同。</p><p id="8d27" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是我在绘制特性重要性时通常使用的基本代码:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="8a82" class="nl lw it nh b gy nm nn l no np"># Plot feature importances<br/>n_features = X.shape[1]<br/>plt.figure(figsize=(8,6))<br/>plt.barh(range(n_features), model.feature_importances_, align='center') <br/>plt.yticks(np.arange(n_features), X.columns) <br/>plt.xlabel("relative importance")<br/>plt.title('Feature Importances of 13 Features Using RandomForestClassifier')<br/>plt.show();</span></pre><p id="b0c1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">情节是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/07dc75a8408346c39e0ef067a882dbfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jSDvcw7UwChXtANE6PehJw.png"/></div></div></figure><p id="6eff" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，默认情况下，所有的条形都是相同的颜色，x轴代表实际的要素重要性值，这是我喜欢的。不幸的是，这些条没有按照我喜欢的从最宽到最窄的顺序排列。例如，看着当前的图，我很难判断非类黄酮酚或镁更重要。</p><p id="db04" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看如何在Matplotlib中精确地再现Yellowbrick图。首先，我要按照重要性对特性进行排序。这很棘手，因为model.feature_importances_只是返回一个没有标签的值数组，其顺序与数据帧中要素的顺序相同。为了对它们进行排序，我需要将值与特性名称相关联，排序，然后将它们分割回来传递给Matplotlib。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="f4b4" class="nl lw it nh b gy nm nn l no np"># Zip and sort feature importance labels and values<br/># (Note that reverse=False by default, but I included it for emphasis)<br/>feat_imp_data = sorted(list(zip(X.columns, model.feature_importances_)), key=lambda datum: datum[1], reverse=False)<br/><br/># Unzip the values and labels<br/>widths = [x[1] for x in feat_imp_data]<br/>yticks = [x[0] for x in feat_imp_data]<br/>n_features = X.shape[1]<br/><br/># Build the figure<br/>plt.figure(figsize=(8,6))<br/>plt.barh(range(n_features), widths, align='center') <br/>plt.yticks(np.arange(n_features), yticks) <br/>plt.xlabel("relative importance")<br/>plt.title('Feature Importances of 13 Features Using RandomForestClassifier')<br/>plt.show();</span></pre><p id="4acc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一个快速但重要的提示:看到我是如何按照<em class="nt">升序</em>排列特性重要性的了吗？这是因为Matplotlib会从底部开始绘制它们。相信我，因为我学到了一个艰难的方法:如果你想以<em class="nt">降序</em>顺序(从上到下)显示值，将它们以<em class="nt">升序</em>顺序传递给Matplotlib。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/9a3658fed630afa6494ec084e781576f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RxBUgugasPKc3pKQEom_1Q.png"/></div></div></figure><p id="c2fd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那就好读多了！现在，如果我<em class="nt">真的</em>想要复制Matplotlib中的Yellowbrick图，我还需要提供颜色和x-tick标签，并删除水平网格线。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="bcb6" class="nl lw it nh b gy nm nn l no np"># First set up colors, ticks, labels, etc.<br/>colors = ['steelblue', 'yellowgreen', 'crimson', 'mediumvioletred', 'khaki', 'skyblue']<br/>widths = [x[1] for x in feat_imp_data]<br/>xticks = list(np.linspace(0.00, widths[-1], 6)) + [0.25]<br/>x_tick_labels = ['0', '20', '40', '60', '80', '100', '']<br/>yticks = [x[0] for x in feat_imp_data]<br/>n_features = len(widths)</span><span id="efe0" class="nl lw it nh b gy nq nn l no np"># Now build the figure<br/>plt.figure(figsize=(8,6))<br/>plt.barh(range(n_features), widths, align='center', color=colors)<br/>plt.xticks(xticks, x_tick_labels)<br/>plt.yticks(np.arange(n_features), yticks) <br/>plt.grid(b=False, axis='y')<br/>plt.xlabel("relative importance")<br/>plt.title('Feature Importances of 13 Features Using RandomForestClassifier')<br/>plt.show();</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/612e8eb96e9c051f1273226a3cc12eea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wWJPJg8EN77EZlq--u0WwA.png"/></div></div></figure><p id="4ae3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你想知道，我花了大约一个小时的时间在Matplotlib重建Yellowbrick地块。这包括从最大到最小对条形进行排序，猜测颜色并努力按正确的顺序排列，将x轴刻度和标签重置为100%刻度，并删除水平网格线。</p><p id="3dbb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个故事的寓意:如果一个黄砖地块能满足你的需求，那么这是一个比通过Matplotlib更快的方法。当然，在控制粒度方面，你永远也不会胜过普通的Matplotlib。</p><h1 id="8324" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">黄砖带来更多乐趣</h1><p id="0598" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">使用Yellowbrick，您可以做更多的事情来可视化您的机器学习模型；请务必<a class="ae lu" href="https://www.scikit-yb.org/en/latest/quickstart.html" rel="noopener ugc nofollow" target="_blank">查阅文档</a>。以下是几个简单的例子:</p><p id="f347" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">例1 </strong>:一个颜色编码的混淆矩阵(使用与上面相同的葡萄酒数据和随机森林模型)。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="923e" class="nl lw it nh b gy nm nn l no np"># Import what we need<br/>from sklearn.model_selection import train_test_split<br/>from yellowbrick.classifier import ConfusionMatrix</span><span id="9bd8" class="nl lw it nh b gy nq nn l no np"># Split the data for validation<br/>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=1)</span><span id="c069" class="nl lw it nh b gy nq nn l no np"># Instantiate model and visualizer<br/>model = RandomForestClassifier(n_estimators=10, random_state=1)<br/>matrix = ConfusionMatrix(model, classes=['class_0', 'class_1', 'class_2'])</span><span id="0387" class="nl lw it nh b gy nq nn l no np"># Fit, score, and display the visualizer<br/>matrix.fit(X_train, y_train)<br/>matrix.score(X_test, y_test)<br/>matrix.show();</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/c8506acdff6ba13da10ded1d5eb5def0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Iawh3teHIZxeId4K55CRyA.png"/></div></div></figure><p id="1d94" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是我在最近的机器学习项目<a class="ae lu" href="https://github.com/jrkreiger/random-forest-trees" rel="noopener ugc nofollow" target="_blank">中使用的代码</a>来自己构建类似的东西。注意，我的函数获取真实值和预测值，我必须事先计算这些值，而Yellowbrick从。score()方法。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="7bce" class="nl lw it nh b gy nm nn l no np"># Define a function to visualize a confusion matrix<br/>def pretty_confusion(y_true, y_pred, model_name):<br/>    '''Display normalized confusion matrix with color scale.<br/>    <br/>    Edit the class_names variable to include appropriate classes.<br/>    <br/>    Keyword arguments:<br/>    y_true: ground-truth labels<br/>    y_pred: predicted labels<br/>    model_name: name to print in the plot title<br/>    <br/>    Dependencies:<br/>    numpy aliased as np<br/>    sklearn.metrics.confusion_matrix<br/>    matplotlib.pyplot aliased as plt<br/>    seaborn aliased as sns<br/>    '''<br/>    <br/>    # Calculate the confusion matrix<br/>    matrix = confusion_matrix(y_true, y_pred)<br/>    matrix = matrix.astype('float') / matrix.sum(axis=1)[:, np.newaxis]<br/>    <br/>    # Build the plot<br/>    plt.figure(figsize=(16,7))<br/>    sns.set(font_scale=1.4)<br/>    sns.heatmap(matrix, annot=True, annot_kws={'size':10}, cmap=plt.cm.Greens, linewidths=0.2)<br/>    <br/>    # Add labels to the plot<br/>    class_names = ['Spruce/Fir', 'Lodgepole Pine', 'Ponderosa Pine', 'Cottonwood/Willow', 'Aspen', 'Douglas-fir', 'Krummholz']<br/>    tick_marks = np.arange(len(class_names))<br/>    tick_marks2 = tick_marks + 0.5<br/>    plt.xticks(tick_marks, class_names, rotation=25)<br/>    plt.yticks(tick_marks2, class_names, rotation=0)<br/>    plt.xlabel('Predicted label')<br/>    plt.ylabel('True label')<br/>    plt.title('Confusion Matrix for {}'.format(model_name)) <br/>    plt.tight_layout()<br/>    plt.show();</span><span id="9511" class="nl lw it nh b gy nq nn l no np"># Plot the confusion matrix<br/>pretty_confusion(y_true, y_pred, 'Random Forest Model')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/988dd455926d56fa9d675199d0c3170c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pg1GWXCcZfFrqVM-A8m5YA.png"/></div></div></figure><p id="fcb7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">例2 </strong>:显示两类文本如何重叠的t-SNE图。关于数据和模型我就不在这里赘述了，不过你可以<a class="ae lu" href="https://github.com/jrkreiger/helpful-reviews" rel="noopener ugc nofollow" target="_blank">在我的GitHub </a>上查看相关项目。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="3bba" class="nl lw it nh b gy nm nn l no np"># Import needed packages<br/>from sklearn.feature_extraction.text import TfidfVectorizer<br/>from yellowbrick.text import TSNEVisualizer</span><span id="bde4" class="nl lw it nh b gy nq nn l no np"># Prepare the data<br/>tfidf = TfidfVectorizer()<br/>X = tfidf.fit_transform(data.text)<br/>y = data.target</span><span id="4001" class="nl lw it nh b gy nq nn l no np"># Plot t-SNE<br/>tsne = TSNEVisualizer()<br/>tsne.fit(X, y)<br/>tsne.show();</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/928df623307dd8c20fd3b100e9a516f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/format:webp/1*2pY4a7Q1hUJ6QPUb1mQv5A.png"/></div></figure><p id="4eda" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我甚至不知道这在Matplotlib中会有多难，因为我从未尝试过。我从Yellowbrick得到的结果足以回答我的问题，我能够获得这些信息并迅速继续前进。</p><p id="723a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望你能抽出时间来试验一下<a class="ae lu" href="https://www.scikit-yb.org/en/latest/index.html" rel="noopener ugc nofollow" target="_blank">黄砖</a>。在使用它的过程中，我获得了乐趣并学到了一些新的模型可视化技术，我打赌您也会这样。</p><p id="9240" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="nt">跨贴自</em><a class="ae lu" href="http://jrkreiger.net" rel="noopener ugc nofollow" target="_blank"><em class="nt">【jrkreiger.net】</em></a><em class="nt">。</em></p></div></div>    
</body>
</html>