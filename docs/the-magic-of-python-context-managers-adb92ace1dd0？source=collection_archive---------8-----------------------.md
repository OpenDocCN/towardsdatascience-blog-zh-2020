# Python 上下文管理器的魔力

> 原文：<https://towardsdatascience.com/the-magic-of-python-context-managers-adb92ace1dd0?source=collection_archive---------8----------------------->

## [入门](https://towardsdatascience.com/tagged/getting-started)

## 使用和创建令人敬畏的 Python 上下文管理器的方法，这将使您的代码更可读、更可靠、更不容易出错…

资源管理是任何编程语言都需要做的事情之一。无论您处理的是锁、文件、会话还是数据库连接，您都必须确保关闭并释放这些资源，以便它们正常运行。通常，人们会使用`try/finally`来完成这个任务——使用`try`块中的资源，并在`finally`块中释放它。然而在 Python 中，有一种更好的方法——使用`with`语句实现*上下文管理协议*。

因此，在这篇文章中，我们将探索它是什么，它是如何工作的，最重要的是你可以在哪里找到以及如何实现你自己的令人敬畏的*上下文管理器*！

![](img/1422a793a368cdbad938043198ce5132.png)

[大卫·贝克尔](https://unsplash.com/@beckerworks?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)在 [Unsplash](https://unsplash.com/?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄的照片

# 什么是上下文管理器？

即使你没有听说过 Python 的*上下文管理器*，你也已经知道——根据介绍——它是`try/finally`块的替代品。使用打开文件时常用的`with`语句实现。与`try/finally`相同，引入这种模式是为了保证某些操作将在程序块的末尾执行，即使出现异常或程序终止。

从表面上看，*上下文管理协议*只是围绕代码块的`with`语句。实际上，它包括两个特殊的( *dunder* )方法- `__enter__`和`__exit__` -分别方便设置和拆卸。

当代码中遇到`with`语句时，`__enter__`方法被触发，其返回值被放入`as`限定符后面的变量中。在`with`块的主体执行后，`__exit__`方法被调用来执行 teardown -完成`finally`块的角色。

上面的代码展示了使用`try/finally`的版本和使用`with`语句实现简单定时器的更优雅的版本。我在上面提到过，实现这样的*上下文管理器*需要`__enter__`和`__exit__`，但是我们如何着手创建它们呢？让我们看看这个`Timer`类的代码:

这段代码片段显示了实现了`__enter__`和`__exit__`方法的`Timer`类。`__enter__`方法只启动定时器并返回`self`，它将在`with ... as some_var`中被赋值。在`with`语句体完成后，用 3 个参数调用`__exit__`方法——异常类型、异常值和回溯。如果在`with`语句体中一切顺利，这些都等于`None`。如果出现异常，就会用异常数据填充，我们可以在`__exit__`方法中处理这些数据。在这种情况下，我们忽略异常处理，只停止计时器并计算运行时间，将其存储在上下文管理器的属性中。

我们已经在这里看到了`with`语句的实现和示例用法，但是为了有更多的关于*实际上发生了什么的可视化示例，让我们看看在没有 Python 的语法糖的情况下，这些特殊的方法是如何被调用的:*

既然我们已经确定了什么是上下文管理器，它是如何工作的以及如何实现它，让我们看看使用它的好处——只是为了有更多的动力从`try/finally`语句切换到`with`语句。

第一个好处是整个安装和拆卸都在上下文管理器对象的控制下进行。这可以防止错误并减少样板代码，从而使 API 更安全、更易于使用。使用它的另一个原因是`with`块突出了关键部分，并鼓励您减少该部分的代码量，这通常也是一个好的实践。最后，也是最重要的一点，这是一个很好的重构工具，它将常见的设置和拆卸代码分离出来，并转移到一个地方，即`__enter__`和`__exit__`方法。

也就是说，如果你以前没有使用过上下文管理器，我希望我说服你开始使用它们而不是`try/finally`。所以，现在让我们看看一些很酷很有用的上下文管理器，你应该开始把它们包含在你的代码中！

# 使用`@contextmanager`使其变得简单

在上一节中，我们探讨了如何使用`__enter__`和`__exit__`方法实现上下文管理器。这很简单，但是我们可以使用`contextlib`，更具体地使用`@contextmanager`，让它变得更简单。

`@contextmanager`是一个装饰器，可以用来编写独立的上下文管理函数。因此，我们不需要创建整个类并实现`__enter__`和`__exit__`方法，我们只需要创建一个生成器:

这个代码片段实现了与上一节中的`Timer`类非常相似的上下文管理器。然而这一次，我们需要更少的代码。这段代码有两部分——在`yield`之前的所有内容和在`yield`之后的所有内容。`yield`之前的代码接替`__enter__`方法的工作，`yield`本身就是`__enter__`方法的`return`语句。`yield`之后的一切都是`__exit__`方法的一部分。

正如您在上面看到的，像这样使用单个函数创建上下文管理器需要使用`try/finally`，因为如果在`with`语句体中出现异常，它将在带有`yield`的行中被引发，我们将需要在对应于`__exit__`方法的`finally`块中处理它。

正如我已经提到的，这可以用于自包含的上下文管理器。然而，它不适合需要成为对象一部分的上下文管理器，例如连接或锁。

尽管使用单一函数构建上下文管理器会迫使您使用`try/finally`，并且只能用于更简单的用例，但在我看来，这仍然是构建更精简的上下文管理器的优雅而实用的选择。

# 现实生活中的例子

现在让我们从理论转到实际有用的上下文管理器，您可以自己构建它。

# 日志记录上下文管理器

当需要尝试找出代码中的一些 bug 时，您可能会首先查看日志来找到问题的根源。然而，这些日志可能被默认设置为*错误*或*警告*级别，这可能不足以用于调试目的。更改整个程序的日志级别应该很容易，但是更改特定代码段的日志级别可能会更复杂——不过，这可以通过下面的上下文管理器轻松解决:

# 超时上下文管理器

在本文的开始，我们是在玩代码的计时块。相反，我们将尝试为由`with`语句包围的块设置超时:

上面的代码为这个上下文管理器声明了名为`timeout`的类，因为这个任务不能在单个函数中完成。为了能够实现这种超时，我们还需要使用信号——更具体地说是`SIGALRM`。我们首先使用`signal.signal(...)`将 handler 设置为`SIGALRM`，这意味着当内核引发`SIGALRM`时，我们的 handler 函数将被调用。至于这个处理函数(`_timeout_handler`)，它所做的只是抛出`TimeoutError`，如果没有及时完成，它将停止执行`with`语句的主体。处理程序就绪后，我们还需要开始指定秒数的倒计时，这由`signal.alarm(self.seconds)`完成。

至于`__exit__`方法——如果上下文管理器的主体设法在时间到期前完成，那么`SIGALRM`将被`signal.alarm(0)`取消，程序可以继续。另一方面，如果由于超时而产生信号，那么`_timeout_handler`将产生`TimeoutError`，而`TimeoutError`将被`__exit__`捕获并抑制，那么`with`语句的主体将被中断，代码的剩余部分可以继续执行。

# 利用已经存在的东西

除了上面的上下文管理器，在标准库或者其他常用的库中已经有很多有用的了，比如`request`或者`sqlite3`。让我们看看能在里面找到什么。

# 临时更改小数精度

如果您正在进行大量的数学运算并需要特定的精度，那么您可能会遇到需要临时更改十进制数精度的情况:

上面的代码演示了没有上下文管理器和有上下文管理器的两个选项。第二种选择显然更简短，可读性更强。它还排除了临时上下文，使其不容易出错。

# 从`contextlib`开始的所有事情

当使用`@contextmanager`时，我们已经偷看了`contextlib`，但是还有更多我们可以使用的东西——作为第一个例子，让我们看看`redirect_stdout`和`redirect_stderr`:

如果你有工具或者函数默认输出所有数据到`stdout`或者`stderr`，但是你更喜欢它输出数据到其他地方——比如文件——那么这两个上下文管理器可能会很有帮助。和前面的例子一样，这极大地提高了代码的可读性，并消除了不必要的视觉干扰。

另一个来自`contextlib`的便利工具是`suppress`上下文管理器，它将抑制任何不想要的异常和错误:

正确处理异常当然更好，但是有时候你只需要去掉那个讨厌的`DeprecationWarning`，这个上下文管理器至少会让它可读。

我要提到的`contextlib`中的最后一个实际上是我最喜欢的，它叫做`closing`:

这个上下文管理器将关闭作为参数传递给它的任何资源——在上面的例子中——这将是`page`对象。至于在后台实际发生了什么——上下文管理器实际上只是强制调用`page`对象的`.close()`方法，就像使用`try/finally`选项一样。

# 用于更好测试的上下文管理器

如果你想让人们使用、阅读或维护你写的测试，你必须让它们易读易懂，而`mock.patch`上下文管理器可以帮助你做到这一点:

将`mock.patch`与上下文管理器一起使用可以让您摆脱不必要的`.start()`和`.stop()`调用，并帮助您定义这个特定模拟的明确范围。这个工具的好处是它既能与`unittest`一起工作，也能与`pytest`一起工作，尽管它是标准库的一部分(因此也是`unittest`)。

说到`pytest`，让我们也从这个库中展示至少一个非常有用的上下文管理器:

这个例子展示了`pytest.raises`的非常简单的用法，它断言代码块引发了所提供的异常。如果没有，那么测试失败。这对于测试预计会引发异常或以其他方式失败的代码路径非常方便。

# 跨请求保持会话

从`pytest`前往另一个伟大的图书馆——`requests`。通常，您可能需要在 HTTP 请求之间保留 cookies，需要保持 TCP 连接活动，或者只想对同一台主机执行多个请求。`requests`提供了良好的上下文管理器来帮助应对这些挑战，即管理会话:

除了解决上述问题，这个上下文管理器还可以帮助提高性能，因为它将重用底层连接，从而避免为每个请求/响应对打开新的连接。

# 管理 SQLite 事务

最后但同样重要的是，还有用于管理 SQLite 事务的上下文管理器。除了让你的代码更整洁，这个上下文管理器还提供了在异常情况下回滚更改的能力，以及在`with`语句体成功完成时自动提交:

在这个例子中，您还可以看到`closing`上下文管理器的良好使用，它有助于处理不再使用的连接对象，这进一步简化了代码，并确保我们不会让任何连接挂起。

# 结论

我想强调的一点是，上下文管理器不仅仅是资源管理工具，而是一种特性，它允许您提取和分解任何一对操作的常见设置和拆卸，而不仅仅是像锁或网络连接这样的常见用例。这也是 python 的一大特色，你可能在其他语言中找不到。它简洁而优雅，所以希望本文向您展示了上下文管理器的强大功能，并向您介绍了在代码中使用它们的更多方法。🙂

*本文最初发布于*[*martinheinz . dev*](https://martinheinz.dev/blog/34?utm_source=tds&utm_medium=referral&utm_campaign=blog_post_34)

[](/ultimate-setup-for-your-next-python-project-179bda8a7c2c) [## 下一个 Python 项目的最终设置

### 从零开始任何项目都可能是一项艰巨的任务…但如果您有这个最终的 Python 项目蓝图就不会了！

towardsdatascience.com](/ultimate-setup-for-your-next-python-project-179bda8a7c2c) [](/writing-more-idiomatic-and-pythonic-code-c22e900eaf83) [## 编写更加地道和 Pythonic 化的代码

### 使你的 Python 代码可读、有效、简洁和可靠的习惯用法和惯例。

towardsdatascience.com](/writing-more-idiomatic-and-pythonic-code-c22e900eaf83) [](/ultimate-guide-to-python-debugging-854dea731e1b) [## Python 调试终极指南

### 让我们探索使用 Python 日志记录、回溯、装饰器等等进行调试的艺术…

towardsdatascience.com](/ultimate-guide-to-python-debugging-854dea731e1b)