<html>
<head>
<title>Numpy Cheat Sheet</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Numpy 备忘单</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/numpy-cheat-sheet-4e3858d0ff0e?source=collection_archive---------9-----------------------#2020-07-23">https://towardsdatascience.com/numpy-cheat-sheet-4e3858d0ff0e?source=collection_archive---------9-----------------------#2020-07-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1468" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Python Numpy 库基础的快速指南，包括代码示例。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6b3627d4d2249ad1322115ac7111e9a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JlQX9lpPtLeOCCzU"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">查尔斯·德鲁维奥在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="3651" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">NumPy 是一个库，它赋予 Python 快速处理数据的能力。与数据清理和操作相比，Numpy 有几个优点。它允许对机器学习中经常使用的数据结构进行有效的操作:向量、矩阵和张量。</p><p id="a18b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我第一次学习 NumPy 时，我很难记住所有需要的函数和方法。所以我把最常用的 Numpy 操作放在一起。我有时会回过头来看看这张便条，以唤起我的记忆。如果这对你的旅程有所帮助，我也很高兴。</p><p id="462d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这张纸条的结构是:</p><ol class=""><li id="7823" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">n 维数组</li><li id="38eb" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">阵列形状操作</li><li id="6ddd" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">数组上的数值运算</li><li id="7fe6" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">数组操作例程(选择和分割)</li><li id="118a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">统计操作</li></ol></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><p id="3124" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一封长信，给自己泡杯茶，我们开始吧！</p><p id="12c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和往常一样，我们需要导入 NumPy 库:</p><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="4e83" class="mv mw it mr b gy mx my l mz na">import numpy as np</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/f24ed35079dd634b6f09b12fa874a466.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*UINoi3u10Y7K7uxeFqINhg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://me.me/i/import-pandas-as-np-import-numpy-as-p-15191942" rel="noopener ugc nofollow" target="_blank"> me.me </a></p></figure><h1 id="43a5" class="nc mw it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">1.n 维数组</h1><h2 id="f510" class="mv mw it bd nd nt nu dn nh nv nw dp nl li nx ny nn lm nz oa np lq ob oc nr od bi translated">什么是数组？</h2><p id="8f03" class="pw-post-body-paragraph kz la it lb b lc oe ju le lf of jx lh li og lk ll lm oh lo lp lq oi ls lt lu im bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Array_data_structure" rel="noopener ugc nofollow" target="_blank">数组</a>是存储相同类型元素的数据结构。存储在数组中的每一项称为一个元素。数组中元素的每个位置都有一个数字索引，用于标识元素。</p><h2 id="2675" class="mv mw it bd nd nt nu dn nh nv nw dp nl li nx ny nn lm nz oa np lq ob oc nr od bi translated">1D vs 2D 阵列</h2><p id="5f37" class="pw-post-body-paragraph kz la it lb b lc oe ju le lf of jx lh li og lk ll lm oh lo lp lq oi ls lt lu im bi translated">1D 数组(即一维数组)存储同一数据类型的变量列表。使用索引可以访问每个变量。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/ec9c037c61cfa481d400e5cf431368c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qlRqv3c89DK7lw6pihnPhw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">1D 阵列</p></figure><p id="d21f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2D 数组(即多维数组)以由行和列组成的格式存储数据。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/c80e86029c8b87e063ddc72010b5e195.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vbO4YKQz68HHhHLVHEf4QQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">2D 阵列</p></figure><h2 id="6240" class="mv mw it bd nd nt nu dn nh nv nw dp nl li nx ny nn lm nz oa np lq ob oc nr od bi translated">数组与列表</h2><ul class=""><li id="d565" class="lv lw it lb b lc oe lf of li ol lm om lq on lu oo mb mc md bi translated">数组比列表使用更少的内存</li><li id="0dc4" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu oo mb mc md bi translated">阵列有更多的功能</li><li id="a38a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu oo mb mc md bi translated">数组要求数据是同质的；列表不</li><li id="b332" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu oo mb mc md bi translated">数组上的算术运算类似于矩阵乘法</li></ul><p id="24c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">NumPy 用于处理数组。NumPy 中的数组对象叫做<code class="fe op oq or mr b">ndarray</code>。</p><h2 id="b61e" class="mv mw it bd nd nt nu dn nh nv nw dp nl li nx ny nn lm nz oa np lq ob oc nr od bi translated">创建一个向量</h2><p id="ecf2" class="pw-post-body-paragraph kz la it lb b lc oe ju le lf of jx lh li og lk ll lm oh lo lp lq oi ls lt lu im bi translated">要创建一个<a class="ae ky" href="https://www.mathsisfun.com/algebra/vectors.html" rel="noopener ugc nofollow" target="_blank">向量</a>，我们只需创建一个一维数组。就像向量一样，这些数组可以水平(即行)或垂直(即列)表示。</p><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="3e65" class="mv mw it mr b gy mx my l mz na"># Create 1 dimensional array (vector)<br/>vector_row = np.array([1,2,3]) # Create vector as a row<br/>&gt;&gt;&gt; array([1, 2, 3])</span><span id="ae9e" class="mv mw it mr b gy os my l mz na">vector_column = np.array([[1],[2],[3]]) #Create vector as a column<br/>&gt;&gt;&gt; array([[1],<br/>           [2],  <br/>           [3]])</span></pre><h2 id="d78c" class="mv mw it bd nd nt nu dn nh nv nw dp nl li nx ny nn lm nz oa np lq ob oc nr od bi translated">创建矩阵</h2><p id="bf58" class="pw-post-body-paragraph kz la it lb b lc oe ju le lf of jx lh li og lk ll lm oh lo lp lq oi ls lt lu im bi translated">为了创建一个<a class="ae ky" href="https://en.wikipedia.org/wiki/Matrix_(mathematics)" rel="noopener ugc nofollow" target="_blank">矩阵</a>，我们可以使用一个 NumPy 二维数组。在我们的解决方案中，矩阵包含三行和两列。</p><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="0c34" class="mv mw it mr b gy mx my l mz na">matrix = np.array([(1,2,3),(4,5,6)]) # Two dimensional array<br/>&gt;&gt;&gt; array([[1, 2, 3],<br/>          [4, 5, 6]])</span></pre><h2 id="9966" class="mv mw it bd nd nt nu dn nh nv nw dp nl li nx ny nn lm nz oa np lq ob oc nr od bi translated">创建稀疏矩阵</h2><p id="436c" class="pw-post-body-paragraph kz la it lb b lc oe ju le lf of jx lh li og lk ll lm oh lo lp lq oi ls lt lu im bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Sparse_matrix" rel="noopener ugc nofollow" target="_blank">稀疏矩阵</a>是大部分元素为零的矩阵。稀疏矩阵只存储非零元素，并假设所有其他值为零，从而节省大量计算资源。</p><p id="8992" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想象一个矩阵，其中列是媒体上的每篇文章，行是每个媒体读者，值是一个人阅读该特定文章的时间(分钟)。这个矩阵会有数万列和数百万行！然而，由于大多数读者不会阅读所有文章，因此绝大多数元素都是零。</p><p id="1b17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">比方说，我们想创建一个有两个非零值的 NumPy 数组，然后把它转换成一个稀疏矩阵。如果我们查看稀疏矩阵，我们可以看到只有非零值被存储:</p><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="5b8b" class="mv mw it mr b gy mx my l mz na">from scipy import sparse<br/>matrix_large = np.array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],<br/>                         [0, 1, 0, 0, 0, 0, 0, 0, 0, 0],<br/>                         [3, 0, 0, 0, 0, 0, 0, 0, 0, 0]])</span><span id="d480" class="mv mw it mr b gy os my l mz na"># Create compressed sparse row (CSR) matrix<br/>matrix_large_sparse = sparse.csr_matrix(matrix_large)<br/>print(matrix_large_sparse)<br/>&gt;&gt;&gt;   (1, 1)	1<br/>      (2, 0)	3</span></pre><p id="49eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，<code class="fe op oq or mr b">(1, 1)</code>和<code class="fe op oq or mr b">(2, 0)</code>分别代表非零值<code class="fe op oq or mr b">1</code>和<code class="fe op oq or mr b">3</code>的索引。例如，元素<code class="fe op oq or mr b">1</code>位于第二行第二列。</p><h2 id="6be3" class="mv mw it bd nd nt nu dn nh nv nw dp nl li nx ny nn lm nz oa np lq ob oc nr od bi translated">创建特殊数组</h2><p id="91c5" class="pw-post-body-paragraph kz la it lb b lc oe ju le lf of jx lh li og lk ll lm oh lo lp lq oi ls lt lu im bi translated"><code class="fe op oq or mr b"><strong class="lb iu">np.zeros()</strong></code>函数返回给定形状和类型的新数组，用零填充。</p><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="f5b5" class="mv mw it mr b gy mx my l mz na"># Create  1d array of zeros, length 3<br/>np.zeros(3) <br/>&gt;&gt;&gt; array([0., 0., 0.])</span><span id="64a2" class="mv mw it mr b gy os my l mz na"># 2x3 array of zeros<br/>np.zeros((2,3))<br/>&gt;&gt;&gt;array([[0., 0., 0.],<br/>         [0., 0., 0.]])</span></pre><p id="3e81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数返回一个给定形状和类型的新数组，用 1 填充。</p><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="49a4" class="mv mw it mr b gy mx my l mz na"># Create 3x4 array of ones<br/>np.ones((3,4)) <br/>&gt;&gt;&gt; array([[1., 1., 1., 1.],<br/>           [1., 1., 1., 1.],<br/>           [1., 1., 1., 1.]])</span></pre><p id="9b5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe op oq or mr b"><strong class="lb iu">np.eye()</strong></code>函数返回对角线上有 1 而其他地方有 0 的矩阵。</p><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="9ad3" class="mv mw it mr b gy mx my l mz na"># Create 5x5 array of 0 with 1 on diagonal (Identity matrix)<br/>np.eye(5) <br/>&gt;&gt;&gt; array([[1., 0., 0., 0., 0.],<br/>           [0., 1., 0., 0., 0.],<br/>           [0., 0., 1., 0., 0.],<br/>           [0., 0., 0., 1., 0.],<br/>           [0., 0., 0., 0., 1.]])</span></pre><p id="11d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe op oq or mr b"><strong class="lb iu">np.linspace()</strong></code>函数返回指定间隔内均匀分布的序列。</p><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="abd6" class="mv mw it mr b gy mx my l mz na"># Create an array of 6 evenly divided values from 0 to 100<br/>np.linspace(0,100,6) <br/>&gt;&gt;&gt; array([  0.,  20.,  40.,  60.,  80., 100.])</span></pre><p id="5e62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe op oq or mr b"><strong class="lb iu">np.arange(start, stop, step)</strong></code>函数返回在给定范围内包含均匀间隔值的<code class="fe op oq or mr b">ndarray</code>对象。</p><p id="1c21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些参数决定了值的范围:</p><ol class=""><li id="098a" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe op oq or mr b">start</code>定义数组中的第一个值。</li><li id="a423" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe op oq or mr b">stop</code>定义数组的结尾，不包含在数组中。</li><li id="fba3" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe op oq or mr b">step</code>是定义数组中每两个连续值之间的间距(差)的数字，默认为<code class="fe op oq or mr b">1</code>。</li></ol><p id="a389" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi ot translated"><span class="l ou ov ow bm ox oy oz pa pb di"> N </span>注:<code class="fe op oq or mr b">step</code>不能为零。否则我们会得到一个<code class="fe op oq or mr b">ZeroDivisionError</code>。如果增量或减量是<code class="fe op oq or mr b">0</code>，我们就不能离开<code class="fe op oq or mr b">start</code>任何地方。</p><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="47fc" class="mv mw it mr b gy mx my l mz na"># Array of values from 0 to less than 10 with step 3 <br/>np.arange(0,10,3)<br/>&gt;&gt;&gt; array([0, 3, 6, 9])</span></pre><p id="8af7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe op oq or mr b"><strong class="lb iu">np.full(shape, fill_value)</strong></code>函数返回一个指定形状的新数组，用<code class="fe op oq or mr b">fill_value</code>填充。</p><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="303a" class="mv mw it mr b gy mx my l mz na"># 2x3 array with all values 5<br/>np.full((2,3),5)<br/>&gt;&gt;&gt; array([[5, 5, 5],<br/>           [5, 5, 5]])</span></pre><p id="2179" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe op oq or mr b"><strong class="lb iu">np.random.rand()</strong></code>函数返回指定形状的数组，并用随机值填充。</p><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="6fea" class="mv mw it mr b gy mx my l mz na"># 2x3 array of random floats between 0–1<br/>np.random.rand(2,3)<br/>&gt;&gt;&gt; array([[0.37174775, 0.59954596, 0.50488967],<br/>           [0.22703386, 0.59914441, 0.68547572]])</span><span id="4496" class="mv mw it mr b gy os my l mz na"># 2x3 array of random floats between 0–100<br/>np.random.rand(2,3)*100<br/>&gt;&gt;&gt; array([[23.17345972, 98.62743214, 21.40831291],<br/>           [87.08603104, 84.23376262, 63.90231179]])</span><span id="b667" class="mv mw it mr b gy os my l mz na"># 2x3 array with random ints between 0–4<br/>np.random.randint(5,size=(2,3))<br/>&gt;&gt;&gt; array([[2, 3, 4],<br/>           [4, 4, 0]])</span></pre><h1 id="8bbc" class="nc mw it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">2.阵列形状操作</h1><h2 id="2648" class="mv mw it bd nd nt nu dn nh nv nw dp nl li nx ny nn lm nz oa np lq ob oc nr od bi translated">形状</h2><p id="5f6e" class="pw-post-body-paragraph kz la it lb b lc oe ju le lf of jx lh li og lk ll lm oh lo lp lq oi ls lt lu im bi translated">检查一个数组的形状和大小对于进一步的计算和简单地在一些操作后进行检查是有价值的。</p><p id="b689" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">NumPy 数组有一个名为<code class="fe op oq or mr b">shape</code>的属性，它返回一个元组，每个索引都有相应元素的数量。</p><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="a5ae" class="mv mw it mr b gy mx my l mz na">arr = np.array([(1,2,3),(4,5,6)])<br/>arr.shape # Returns dimensions of arr (rows,columns)<br/>&gt;&gt;&gt; (2, 3)</span></pre><p id="1c1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，<code class="fe op oq or mr b">(2, 3)</code>表示数组有 2 个维度，每个维度有 3 个元素。</p><h2 id="d3ea" class="mv mw it bd nd nt nu dn nh nv nw dp nl li nx ny nn lm nz oa np lq ob oc nr od bi translated">使再成形</h2><p id="e998" class="pw-post-body-paragraph kz la it lb b lc oe ju le lf of jx lh li og lk ll lm oh lo lp lq oi ls lt lu im bi translated">了解如何重塑 NumPy 数组很重要，这样我们的数据才能满足特定 Python 库的期望。例如，Scikit- learn 要求输出变量<code class="fe op oq or mr b">y</code>的一维数组的形状像一个二维数组，其中一列和每行的结果。</p><p id="2f52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一些算法，如 Keras 中的长短期记忆递归神经网络，需要将输入指定为由样本、时间步长和特征组成的三维数组。</p><p id="967f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe op oq or mr b">reshape()</code>允许我们重新构建一个数组，这样我们可以维护相同的数据，但是它被组织成不同数量的行和列。</p><p id="fdc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi ot translated"><span class="l ou ov ow bm ox oy oz pa pb di"> N </span>注:原矩阵和新矩阵的形状包含相同数量的元素(即相同的大小)</p><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="0fa7" class="mv mw it mr b gy mx my l mz na">arr1 = np.arange(1, 11)  # numbers 1 to 10<br/>&gt;&gt;&gt; array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10])</span><span id="8870" class="mv mw it mr b gy os my l mz na">print(arr1.shape) # Prints a tuple for the one dimension.<br/>&gt;&gt;&gt; (10,)</span></pre><p id="77b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用<code class="fe op oq or mr b">reshape()</code>方法将我们的数组整形为一个 2 乘 5 维的数组。</p><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="c82d" class="mv mw it mr b gy mx my l mz na">arr1_2d = arr1.reshape(2, 5)</span><span id="b8b4" class="mv mw it mr b gy os my l mz na">print(arr1_2d)<br/>&gt;&gt;&gt; array([[ 1,  2,  3,  4,  5],<br/>           [ 6,  7,  8,  9, 10]])</span></pre><p id="f38e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们希望 NumPy 自动确定特定维度的大小/长度，那么将维度指定为-1，这实际上意味着“需要多少就有多少”例如，<code class="fe op oq or mr b">reshape(2, -1)</code>表示两行和任意多列。</p><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="89e3" class="mv mw it mr b gy mx my l mz na">arr1.reshape(2, 5)<br/>arr1.reshape(-1, 5)  # same as above: arr1.reshape(2, 5)<br/>arr1.reshape(2, -1)  # same as above: arr1.reshape(2, 5)</span></pre><h2 id="3624" class="mv mw it bd nd nt nu dn nh nv nw dp nl li nx ny nn lm nz oa np lq ob oc nr od bi translated">移项</h2><p id="99de" class="pw-post-body-paragraph kz la it lb b lc oe ju le lf of jx lh li og lk ll lm oh lo lp lq oi ls lt lu im bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Transpose" rel="noopener ugc nofollow" target="_blank">转置</a>是线性代数中的常见操作，其中每个元素的列和行索引被交换。</p><p id="8f09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在最后一个例子中，<code class="fe op oq or mr b">arr1_2d</code>是一个 2×5 维的数组，我们希望用它的列来交换它的行。</p><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="89d9" class="mv mw it mr b gy mx my l mz na">arr1_2d.T<br/>&gt;&gt;&gt; array([[ 1,  6],<br/>          [ 2,  7],<br/>          [ 3,  8],<br/>          [ 4,  9],<br/>          [ 5, 10]])</span></pre><h2 id="367c" class="mv mw it bd nd nt nu dn nh nv nw dp nl li nx ny nn lm nz oa np lq ob oc nr od bi translated">展平矩阵</h2><p id="90ca" class="pw-post-body-paragraph kz la it lb b lc oe ju le lf of jx lh li og lk ll lm oh lo lp lq oi ls lt lu im bi translated"><code class="fe op oq or mr b">flatten()</code>是将一个矩阵转换成一维数组的简单方法。</p><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="7983" class="mv mw it mr b gy mx my l mz na">arr1_2d.flatten()<br/>&gt;&gt;&gt; array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10])</span></pre><h2 id="801b" class="mv mw it bd nd nt nu dn nh nv nw dp nl li nx ny nn lm nz oa np lq ob oc nr od bi translated">调整矩阵大小</h2><p id="b01c" class="pw-post-body-paragraph kz la it lb b lc oe ju le lf of jx lh li og lk ll lm oh lo lp lq oi ls lt lu im bi translated"><code class="fe op oq or mr b"><strong class="lb iu">resize(arr, new_shape)</strong></code>函数返回指定形状的新数组。<br/>如果新数组比原数组大，那么新数组用<code class="fe op oq or mr b">arr</code>的重复副本填充。</p><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="c77d" class="mv mw it mr b gy mx my l mz na"># Resize arr1_2d to 3 rows, 4 columns <br/>resize_arr = np.resize(arr1_2d, (3,4))<br/>resize_arr<br/>&gt;&gt;&gt; array([[ 1,  2,  3,  4],<br/>           [ 5,  6,  7,  8],<br/>           [ 9, 10,  1,  2]])</span></pre><h2 id="5c40" class="mv mw it bd nd nt nu dn nh nv nw dp nl li nx ny nn lm nz oa np lq ob oc nr od bi translated">矩阵求逆</h2><p id="fc58" class="pw-post-body-paragraph kz la it lb b lc oe ju le lf of jx lh li og lk ll lm oh lo lp lq oi ls lt lu im bi translated">矩阵 A 的<a class="ae ky" href="https://en.wikipedia.org/wiki/Invertible_matrix" rel="noopener ugc nofollow" target="_blank">逆</a>是这样一个矩阵，当乘以 A 时得到恒等式。一个很好的例子是在线性回归中寻找系数值的向量。</p><p id="9068" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用 NumPy 的线性代数<code class="fe op oq or mr b">inv</code>方法:</p><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="d697" class="mv mw it mr b gy mx my l mz na">matrix = np.array([[1, 2],<br/>                   [3, 4]])</span><span id="66aa" class="mv mw it mr b gy os my l mz na"># Calculate inverse of matrix<br/>np.linalg.inv(matrix)<br/>&gt;&gt;&gt; array([[-2. ,  1. ],<br/>          [ 1.5, -0.5]])</span></pre><h2 id="d042" class="mv mw it bd nd nt nu dn nh nv nw dp nl li nx ny nn lm nz oa np lq ob oc nr od bi translated">将数组转换为列表，反之亦然</h2><p id="05a4" class="pw-post-body-paragraph kz la it lb b lc oe ju le lf of jx lh li og lk ll lm oh lo lp lq oi ls lt lu im bi translated">当我第一次学习 Python 时，我经常遇到的一个错误——有时现在仍然会遇到——是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/02493e22d193b77b84d9bb69615e4c6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y5pqMdfVcNtgde3Z_TOptg.png"/></div></div></figure><p id="df1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数组需要声明，而列表不需要声明，因为它们是 Python 语法的一部分。这就是列表比数组更常用的原因。但是在对我们的列表执行一些算术函数的情况下，我们应该用数组来代替。</p><p id="3054" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想要存储大量数据，我们应该考虑数组，因为它们可以非常紧凑和高效地存储数据。</p><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="ce58" class="mv mw it mr b gy mx my l mz na">arr = np.array([(1,2,3),(4,5,6)])<br/>&gt;&gt;&gt; array([[1, 2, 3],<br/>          [4, 5, 6]])</span><span id="4c3d" class="mv mw it mr b gy os my l mz na">arr_to_list = arr.tolist() # Convert arr to a Python list<br/>&gt;&gt;&gt; [[1, 2, 3], [4, 5, 6]]</span><span id="40dd" class="mv mw it mr b gy os my l mz na">np.array(arr_to_list) # Convert list to array <br/>&gt;&gt;&gt; array([[1, 2, 3],<br/>          [4, 5, 6]])</span></pre><p id="16a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">描述阵列的其他有用函数:</p><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="e84d" class="mv mw it mr b gy mx my l mz na">arr.size # Return number of elements in arr<br/>len(arr) #Length of arrayarr.ndim # Number of array dimension<br/>arr.dtype # Return type of elements in arr<br/>arr.dtype.name # Name of data type<br/>arr.astype(int) # Convert an array to a different type<br/>arr.astype(dtype) # Convert arr elements to type dtype<br/>np.info(np.eye) # View documentation for np.eye</span></pre><h1 id="b7d6" class="nc mw it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">3.数组上的数值运算</h1><h2 id="d588" class="mv mw it bd nd nt nu dn nh nv nw dp nl li nx ny nn lm nz oa np lq ob oc nr od bi translated">迹(线性代数)</h2><p id="4949" class="pw-post-body-paragraph kz la it lb b lc oe ju le lf of jx lh li og lk ll lm oh lo lp lq oi ls lt lu im bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Trace_(linear_algebra)" rel="noopener ugc nofollow" target="_blank">轨迹</a>是一个方阵的所有对角元素的总和。</p><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="76e7" class="mv mw it mr b gy mx my l mz na">arr = np.array([[2, 0, 0], [0, 2, 0], [0, 0, 2]])<br/>np.trace(arr)<br/>&gt;&gt;&gt; 6</span></pre><h2 id="c1a0" class="mv mw it bd nd nt nu dn nh nv nw dp nl li nx ny nn lm nz oa np lq ob oc nr od bi translated">决定因素</h2><p id="087d" class="pw-post-body-paragraph kz la it lb b lc oe ju le lf of jx lh li og lk ll lm oh lo lp lq oi ls lt lu im bi translated"><a class="ae ky" href="https://www.mathsisfun.com/algebra/matrix-determinant.html" rel="noopener ugc nofollow" target="_blank">行列式</a>矩阵是一种特殊的数，可以从方阵中计算出来。计算矩阵的行列式有时会很有用。NumPy 用<code class="fe op oq or mr b">det()</code>让这变得简单。</p><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="73b5" class="mv mw it mr b gy mx my l mz na">matrix = np.array([[1, 2, 3],<br/>                   [2, 4, 6],<br/>                   [3, 8, 9]])</span><span id="e0a0" class="mv mw it mr b gy os my l mz na"># Return determinant of matrix<br/>np.linalg.det(matrix)<br/>&gt;&gt;&gt; 0.0</span></pre><h2 id="4e77" class="mv mw it bd nd nt nu dn nh nv nw dp nl li nx ny nn lm nz oa np lq ob oc nr od bi translated">求矩阵的秩</h2><p id="d52a" class="pw-post-body-paragraph kz la it lb b lc oe ju le lf of jx lh li og lk ll lm oh lo lp lq oi ls lt lu im bi translated">矩阵的秩是矩阵中线性无关的行或列的数量的估计。知道矩阵的秩很重要。在解线性方程组时，秩可以告诉我们<code class="fe op oq or mr b">Ax = 0</code>是有一个解还是多个解。</p><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="7655" class="mv mw it mr b gy mx my l mz na">matrix = np.array([[1, 1, 3],<br/>                   [1, 2, 4],<br/>                   [1, 3, 0]])</span><span id="1a15" class="mv mw it mr b gy os my l mz na"># Return matrix rank<br/>np.linalg.matrix_rank(matrix)<br/>&gt;&gt;&gt; 3</span></pre><h2 id="fc8e" class="mv mw it bd nd nt nu dn nh nv nw dp nl li nx ny nn lm nz oa np lq ob oc nr od bi translated">求特征值和特征向量</h2><p id="7a85" class="pw-post-body-paragraph kz la it lb b lc oe ju le lf of jx lh li og lk ll lm oh lo lp lq oi ls lt lu im bi translated">许多机器学习问题可以用线性代数建模，其解来自<a class="ae ky" href="https://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors" rel="noopener ugc nofollow" target="_blank">特征值和特征向量</a>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/c125b9b5e92c9f9a9a95a09d050187fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MiwDIV03jVT1hYKVNxEPvQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">特征值和特征向量</p></figure><p id="5869" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在 NumPy 的线性代数工具集中，<code class="fe op oq or mr b">eig</code>让我们计算任何方阵的特征值和特征向量。</p><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="9758" class="mv mw it mr b gy mx my l mz na">matrix = np.array([[0, 1, 2],<br/>                   [3, 4, 5],<br/>                   [6, 7, 8]])</span><span id="a76a" class="mv mw it mr b gy os my l mz na"># Calculate eigenvalues and eigenvectors<br/>eigenvalues, eigenvectors = np.linalg.eig(matrix)<br/>eigenvalues<br/>&gt;&gt;&gt; array([ 1.33484692e+01, -1.34846923e+00, -2.48477279e-16])<br/>eigenvectors<br/>&gt;&gt;&gt; array([[ 0.16476382,  0.79969966,  0.40824829],<br/>           [ 0.50577448,  0.10420579, -0.81649658],<br/>           [ 0.84678513, -0.59128809,  0.40824829]])</span></pre><h2 id="5a5c" class="mv mw it bd nd nt nu dn nh nv nw dp nl li nx ny nn lm nz oa np lq ob oc nr od bi translated">标量运算</h2><p id="c9a2" class="pw-post-body-paragraph kz la it lb b lc oe ju le lf of jx lh li og lk ll lm oh lo lp lq oi ls lt lu im bi translated">当我们对一个矩阵加、减、乘或除一个数时，这就叫做标量运算。在标量操作期间，标量值应用于数组中的每个元素，因此，该函数返回一个具有相同行数和列数的新矩阵。</p><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="d0e7" class="mv mw it mr b gy mx my l mz na">new_arr = np.arange(1,10)<br/>&gt;&gt;&gt; array([1, 2, 3, 4, 5, 6, 7, 8, 9])</span><span id="1ee0" class="mv mw it mr b gy os my l mz na"># Add 1 to each array element<br/>np.add(new_arr,1)<br/>&gt;&gt;&gt; array([ 2,  3,  4,  5,  6,  7,  8,  9, 10])</span></pre><p id="e920" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，我们可以使用下面的函数对矩阵进行减法、乘法或除法运算:</p><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="f4f4" class="mv mw it mr b gy mx my l mz na">np.subtract(arr,2) # Subtract 2 from each array element<br/>np.multiply(arr,3) # Multiply each array element by 3<br/>np.divide(arr,4) # Divide each array element by 4 (returns np.nan for division by zero)<br/>np.power(arr,5) # Raise each array element to the 5th power</span></pre><h2 id="c0c1" class="mv mw it bd nd nt nu dn nh nv nw dp nl li nx ny nn lm nz oa np lq ob oc nr od bi translated">矩阵运算</h2><p id="99f9" class="pw-post-body-paragraph kz la it lb b lc oe ju le lf of jx lh li og lk ll lm oh lo lp lq oi ls lt lu im bi translated">如果两个矩阵具有相同的维数，即它们必须具有相同的行数和列数，则只能将一个矩阵与另一个矩阵相加(或相减)。</p><p id="9951" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">矩阵相乘时，我们取第一个矩阵的行，乘以第二个<em class="pe"> </em>矩阵对应的列。</p><p id="e3b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi ot translated">注意:记住“行优先，列第二”</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pf"><img src="../Images/45bfec57bc8c37f766f1884115336227.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0Byi5zPY_7jCoJtIA7qbZQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">乘法矩阵</p></figure><p id="947f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">了解矩阵的形状是很重要的。然后矩阵操作使用 NumPy 库是简单的。</p><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="3dce" class="mv mw it mr b gy mx my l mz na">np.add(arr1,arr2) # Elementwise add arr2 to arr1<br/>np.subtract(arr1,arr2) # Elementwise subtract arr2 from arr1<br/>np.multiply(arr1,arr2) # Elementwise multiply arr1 by arr2<br/>np.divide(arr1,arr2) # Elementwise divide arr1 by arr2<br/>np.power(arr1,arr2) # Elementwise raise arr1 raised to the power of arr2<br/>np.array_equal(arr1,arr2) # Returns True if the arrays have the same elements and shape</span></pre><p id="5e37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其他数学运算:</p><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="e7cf" class="mv mw it mr b gy mx my l mz na">np.sqrt(arr) # Square root of each element in the array<br/>np.sin(arr) # Sine of each element in the array<br/>np.log(arr) # Natural log of each element in the array<br/>np.abs(arr) # Absolute value of each element in the array<br/>np.ceil(arr) # Rounds up to the nearest int<br/>np.floor(arr) # Rounds down to the nearest int<br/>np.round(arr) # Rounds to the nearest int</span></pre><h1 id="1760" class="nc mw it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">4.数组操作例程</h1><h2 id="4203" class="mv mw it bd nd nt nu dn nh nv nw dp nl li nx ny nn lm nz oa np lq ob oc nr od bi translated">添加/删除元素</h2><p id="d8ef" class="pw-post-body-paragraph kz la it lb b lc oe ju le lf of jx lh li og lk ll lm oh lo lp lq oi ls lt lu im bi translated"><code class="fe op oq or mr b"><strong class="lb iu">append()</strong></code>函数用于将值追加到给定数组的末尾。</p><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="0a99" class="mv mw it mr b gy mx my l mz na">np.append ([0, 1, 2], [[3, 4, 5], [6, 7, 8]])<br/>&gt;&gt;&gt; array([0, 1, 2, 3, 4, 5, 6, 7, 8])</span><span id="0314" class="mv mw it mr b gy os my l mz na">np.append([[0, 1, 2], [3, 4, 5]],[[6, 7, 8]], axis=0)<br/>&gt;&gt;&gt; array([[0, 1, 2],<br/>           [3, 4, 5],<br/>           [6, 7, 8]])</span></pre><p id="dd10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">沿其追加值的轴。如果没有给定轴，数组和值在使用前都被展平。</p><p id="dee2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe op oq or mr b"><strong class="lb iu">insert()</strong></code>:用于在数组的给定索引前插入元素。</p><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="5359" class="mv mw it mr b gy mx my l mz na">arr = np.arange(1,6)<br/>np.insert(arr,2,10) # Inserts 10 into arr before index 2<br/>&gt;&gt;&gt;array([ 1,  2, 10,  3,  4,  5])</span></pre><p id="000b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe op oq or mr b"><strong class="lb iu">delete()</strong></code>我们可以从<code class="fe op oq or mr b">ndarray</code>中删除任何行和列</p><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="ee67" class="mv mw it mr b gy mx my l mz na">arr = np.arange(12).reshape(3, 4)<br/>&gt;&gt;&gt; [[ 0  1  2  3]<br/>     [ 4  5  6  7]<br/>     [ 8  9 10 11]]</span><span id="3f73" class="mv mw it mr b gy os my l mz na">np.delete(arr,2,axis=0) # Deletes row on index 2 of arr<br/>&gt;&gt;&gt; array([[0, 1, 2, 3],<br/>           [4, 5, 6, 7]])</span><span id="1ea1" class="mv mw it mr b gy os my l mz na">np.delete(arr,3,axis=1) # Deletes column on index 3 of arr<br/>&gt;&gt;&gt; array([[ 0,  1,  2],<br/>           [ 4,  5,  6],<br/>           [ 8,  9, 10]])</span></pre><p id="5c5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe op oq or mr b"><strong class="lb iu">sort()</strong></code>函数可以用来对列表进行升序和降序排序。</p><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="4761" class="mv mw it mr b gy mx my l mz na">oned_arr = np.array([3,8,5,1])<br/>np.sort(oned_arr)<br/>&gt;&gt;&gt; array([1, 3, 5, 8])</span><span id="7eae" class="mv mw it mr b gy os my l mz na">arr = np.array([[5, 4, 6, 8],<br/>                [1, 2, 4, 8],<br/>                [1, 5, 2, 4]])</span><span id="f8a3" class="mv mw it mr b gy os my l mz na"># sort each column of arr<br/>np.sort(arr, axis=0)<br/>&gt;&gt;&gt; array([[1, 2, 2, 4],<br/>           [1, 4, 4, 8],<br/>          [5, 5, 6, 8]])</span><span id="8d41" class="mv mw it mr b gy os my l mz na"># sort each row of X<br/>np.sort(arr, axis=1)<br/>&gt;&gt;&gt; array([[4, 5, 6, 8],<br/>          [1, 2, 4, 8],<br/>          [1, 2, 4, 5]])</span></pre><h2 id="e8f9" class="mv mw it bd nd nt nu dn nh nv nw dp nl li nx ny nn lm nz oa np lq ob oc nr od bi translated">加入 NumPy 数组</h2><p id="a36d" class="pw-post-body-paragraph kz la it lb b lc oe ju le lf of jx lh li og lk ll lm oh lo lp lq oi ls lt lu im bi translated">连接意味着将两个或多个数组的内容放在一个数组中。在 NumPy 中，我们通过轴连接数组。我们传递一系列我们想要加入到<code class="fe op oq or mr b">concatenate()</code>函数中的数组，以及轴。如果没有显式传递该轴，则该轴被视为 0。</p><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="b116" class="mv mw it mr b gy mx my l mz na"># Adds arr2 as rows to the end of arr1<br/>arr1 = np.array([1, 2, 3])<br/>arr2 = np.array([4, 5, 6])<br/>arr = np.concatenate((arr1, arr2), axis=0)<br/>&gt;&gt;&gt; array([1, 2, 3, 4, 5, 6])</span><span id="278d" class="mv mw it mr b gy os my l mz na"># Adds arr2 as columns to end of arr1<br/>arr1 = np.array([[1, 2, 3],[4, 5, 6]])<br/>arr2 = np.array([[7, 8, 9],[10, 11, 12]])<br/>arr = np.concatenate((arr1,arr2),axis=1)<br/>&gt;&gt;&gt; array([[ 1,  2,  3,  7,  8,  9],<br/>           [ 4,  5,  6, 10, 11, 12]])</span></pre><h2 id="75d3" class="mv mw it bd nd nt nu dn nh nv nw dp nl li nx ny nn lm nz oa np lq ob oc nr od bi translated">拆分 NumPy 数组</h2><p id="6b84" class="pw-post-body-paragraph kz la it lb b lc oe ju le lf of jx lh li og lk ll lm oh lo lp lq oi ls lt lu im bi translated">酷，现在我们知道如何将多个阵列合并成一个。如何把一个数组拆成多个？我们使用<code class="fe op oq or mr b">array_split()</code>来分割数组，我们传递给它我们想要分割的数组和分割的数目。</p><p id="262b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi ot translated"><span class="l ou ov ow bm ox oy oz pa pb di"> N </span>注意:如果数组的元素比要求的少，它将从末尾进行相应的调整。</p><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="0450" class="mv mw it mr b gy mx my l mz na"># Splits arr into 4 sub-arrays<br/>arr = np.array([1, 2, 3, 4, 5, 6])<br/>new_arr = np.array_split(arr, 4) <br/>&gt;&gt;&gt; [array([1, 2]), array([3, 4]), array([5]), array([6])]</span><span id="19ef" class="mv mw it mr b gy os my l mz na"># Splits arr horizontally on the 2nd index<br/>arr = np.array([1, 2, 3, 4, 5, 6])<br/>new_arr = np.hsplit(arr, 2)<br/>&gt;&gt;&gt; [array([1, 2, 3]), array([4, 5, 6])]</span></pre><h2 id="f4d7" class="mv mw it bd nd nt nu dn nh nv nw dp nl li nx ny nn lm nz oa np lq ob oc nr od bi translated">选择元素</h2><p id="7a02" class="pw-post-body-paragraph kz la it lb b lc oe ju le lf of jx lh li og lk ll lm oh lo lp lq oi ls lt lu im bi translated">NumPy 为索引和分割数组中的元素或元素组提供了多种方法。</p><p id="1350" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi ot translated">注意:NumPy 数组是零索引的，这意味着第一个元素的索引是 0，而不是 1。</p><p id="19cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们有两个数组，一个包含 user_name，另一个存储这个人阅读的文章数量。</p><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="ef70" class="mv mw it mr b gy mx my l mz na">user_name = np.array(['Katie','Bob','Scott','Liz','Sam'])<br/>articles = np.array([100, 38, 91, 7, 25])</span><span id="6024" class="mv mw it mr b gy os my l mz na">user_name[4] # Return the element at index 4<br/>&gt;&gt;&gt; 'Sam'</span><span id="f07d" class="mv mw it mr b gy os my l mz na">articles[3] = 17 # Assign array element on index 1 the value 4<br/>&gt;&gt;&gt;array([100,  38,  91,  17,  25])</span><span id="e1b0" class="mv mw it mr b gy os my l mz na">user_name[0:3] # Return the elements at indices 0,1,2<br/>&gt;&gt;&gt; array(['Katie', 'Bob', 'Scott'], dtype='&lt;U5')</span><span id="c27f" class="mv mw it mr b gy os my l mz na">user_name[:2] # Return the elements at indices 0,1<br/>&gt;&gt;&gt; array(['Katie', 'Bob'], dtype='&lt;U5')</span><span id="6633" class="mv mw it mr b gy os my l mz na">articles&lt;50 # Return an array with boolean values<br/>&gt;&gt;&gt; array([False,  True, False,  True,  True])</span><span id="85ff" class="mv mw it mr b gy os my l mz na">articles[articles &lt; 50] # Return the element values<br/>array([38,  7, 25])</span><span id="2118" class="mv mw it mr b gy os my l mz na"># Return the user_name that read more than 50 articles but less than 100 articles<br/>user_name[(articles &lt; 100 ) &amp; (articles &gt;50)]<br/>&gt;&gt;&gt; array(['Scott'], dtype='&lt;U5')</span></pre><p id="963a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用类似的方法来选择多维数组中的元素:</p><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="cacb" class="mv mw it mr b gy mx my l mz na">arr[2,5] # Returns the 2D array element on index [2][5]<br/>arr[1,3]=10 # Assigns array element on index [1][3] the value 10<br/>arr[0:3] # Returns rows 0,1,2<br/>arr[0:3,4] # Returns the elements on rows 0,1,2 at column 4<br/>arr[:2] # Returns returns rows 0,1<br/>arr[:,1] # Returns the elements at index 1 on all rows</span></pre><h1 id="f99b" class="nc mw it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">5.统计操作</h1><h2 id="8fb5" class="mv mw it bd nd nt nu dn nh nv nw dp nl li nx ny nn lm nz oa np lq ob oc nr od bi translated">求最大值和最小值</h2><p id="d1ed" class="pw-post-body-paragraph kz la it lb b lc oe ju le lf of jx lh li og lk ll lm oh lo lp lq oi ls lt lu im bi translated">通常我们想知道数组或数组子集的最大值和最小值。这可以通过<code class="fe op oq or mr b">max</code>和<code class="fe op oq or mr b">min</code>方法完成。使用<code class="fe op oq or mr b">axis</code>参数，我们也可以沿某个轴进行操作:</p><p id="0e63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们将一个人每月的文章数量存储在一个数组中。</p><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="f2bb" class="mv mw it mr b gy mx my l mz na">articles = np.array([[10, 23, 17],<br/>                   [41, 54, 65],<br/>                   [71, 18, 89]])</span><span id="7791" class="mv mw it mr b gy os my l mz na"># Return maximum element<br/>np.max(articles)<br/>&gt;&gt;&gt; 89<br/>np.max(articles,<!-- --> <!-- -->axis=0) <em class="pe"># Find maximum element in each column<br/>&gt;&gt;&gt; </em>array([71, 54, 89])<br/>np.max(articles, axis=1) # Find maximum element in each row<br/>&gt;&gt;&gt; array([23, 65, 89])</span></pre><p id="ab78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以用类似的方法找到最小元素:</p><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="d2e3" class="mv mw it mr b gy mx my l mz na">np.min(arr) # Return minimum element<br/>np.min(arr,exis=0)<!-- --># Find minimum element in each column<br/>np.min(arr,axis=1)# Find minimum element in each row</span></pre><h2 id="ff0e" class="mv mw it bd nd nt nu dn nh nv nw dp nl li nx ny nn lm nz oa np lq ob oc nr od bi translated">计算平均值、方差和标准差</h2><p id="fe74" class="pw-post-body-paragraph kz la it lb b lc oe ju le lf of jx lh li og lk ll lm oh lo lp lq oi ls lt lu im bi translated">就像使用<code class="fe op oq or mr b">max()</code>和<code class="fe op oq or mr b">min()</code>一样，我们可以很容易地获得整个矩阵的描述性统计数据，或者沿着单个轴进行计算。</p><pre class="kj kk kl km gt mq mr ms mt aw mu bi"><span id="a858" class="mv mw it mr b gy mx my l mz na">np.mean(arr,axis=0) # Return mean along specific axis<br/>arr.sum() # Return sum of arr<br/>b.cumsum(axis=1) # Cumulative sum of the elements<br/>np.var(arr) # Return the variance of array<br/>np.std(arr,axis=1) # Return the standard deviation of specific axis<br/>arr.corrcoef() # Return correlation coefficient of array</span></pre><p id="006b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本笔记中的代码可在<a class="ae ky" href="https://github.com/Nothingaholic/Python-Cheat-Sheet/blob/master/numpy.ipynb" rel="noopener ugc nofollow" target="_blank"> Github </a>上获得。</p><h1 id="f8ac" class="nc mw it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">就是这样！</h1><p id="f07b" class="pw-post-body-paragraph kz la it lb b lc oe ju le lf of jx lh li og lk ll lm oh lo lp lq oi ls lt lu im bi translated">我认为这个音符是 NumPy 的基础。在工作中阅读现有代码或在线学习教程时，您可能会反复遇到这些函数。当我发现更多有用的 Numpy 函数时，我会不断更新它。</p><p id="43a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有的学习活动都是在时间和经历中进行的。在几个小时内学会 Python 是不可能的。记住，任何努力最困难的部分是开始，你已经度过了，继续努力，继续努力！！！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/e3d48cf16095db147249ae24a8678507.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6qFZlJ2VBrIXf3wWbnGZEg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://www.kindpng.com/imgv/TJTwob_meme-linear-algebra-funny-hd-png-download/" rel="noopener ugc nofollow" target="_blank">模因</a></p></figure><h1 id="d375" class="nc mw it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">资源</h1><p id="9be2" class="pw-post-body-paragraph kz la it lb b lc oe ju le lf of jx lh li og lk ll lm oh lo lp lq oi ls lt lu im bi translated">Numpy 是一个非常重要的库，几乎每个数据科学或机器学习 Python 包(如 SciPy、Matplotlib、Scikit-learn)都在一定程度上依赖于它。对基本面有很强的理解是很重要的。方便的是，有一些很棒的资源可以帮助完成这项任务。下面我列出了一些我最喜欢的，其中一些深入到线性代数的各个方面；如果您渴望了解更多信息，请查看它们！</p><ol class=""><li id="4c77" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><a class="ae ky" href="https://ocw.mit.edu/courses/mathematics/18-06-linear-algebra-spring-2010/" rel="noopener ugc nofollow" target="_blank">线性代数，麻省理工</a></li><li id="6c50" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/linear-algebra-for-deep-learning-f21d7e7d7f23">深度学习的基础线性代数</a></li><li id="1f51" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">【NumPy 数组和 matrics 的区别</li><li id="d9c7" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://docs.scipy.org/doc/scipy/reference/sparse.html" rel="noopener ugc nofollow" target="_blank">稀疏矩阵，SciPy 文档</a></li><li id="fa74" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/reshaping-numpy-arrays-in-python-a-step-by-step-pictorial-tutorial-aed5f471cf0b">NP . shape()一步一步来</a></li><li id="ad5d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://medium.com/fintechexplained/what-are-eigenvalues-and-eigenvectors-a-must-know-concept-for-machine-learning-80d0fd330e47" rel="noopener">机器学习—特征值和特征向量</a></li></ol></div></div>    
</body>
</html>