<html>
<head>
<title>Sorting and Subsetting in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中的排序和子集化</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/sorting-and-subsetting-in-python-f9dd2e14caa0?source=collection_archive---------38-----------------------#2020-07-08">https://towardsdatascience.com/sorting-and-subsetting-in-python-f9dd2e14caa0?source=collection_archive---------38-----------------------#2020-07-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0ad6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用熊猫图书馆进行动手数据分析</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9c72271da70b9956d82c441f671532e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yVfmx_jmrIa58w80YPt7vA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://www.pexels.com/@ann-h-45017?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">安 H </a>从<a class="ae ky" href="https://www.pexels.com/photo/contemporary-art-2838545/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">派克斯</a>拍摄</p></figure><p id="af6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated"><span class="l lw lx ly bm lz ma mb mc md di">在本帖中，我们将通过熊猫图书馆学习一些强大的数据分析技术。探索数据集是数据分析的第一个关键步骤。为了更好地理解数据，有许多方法可以做到这一点。但是今天，我们将介绍两种最简单也是最重要的方法来找到数据帧中有趣的部分。排序和子集化是本文将要讨论的两个内容。介绍完了，让我给你介绍一个叫<em class="me">熊猫、</em>的朋友，他将在这次旅程中帮助我们。</span></p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="cc89" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">熊猫</h1><p id="8404" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">Pandas 构建在两个基本 python 包之上:NumPy 和 Matplotlib。</p><ul class=""><li id="8b6b" class="nj nk it lb b lc ld lf lg li nl lm nm lq nn lu no np nq nr bi translated">NumPy 提供了多维数组对象来方便数据操作，pandas 用它来存储数据。</li><li id="cb8b" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">Matplotlib 具有强大的数据可视化功能，pandas 利用了这一点。</li></ul><p id="b466" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">存储用于分析的数据有多种方式，但矩形数据(也称为“表格数据”)是最常用的一种。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/66d76fcf5cfa7af39ff5d74bb575d509.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ptkRjJ0sh_IzvxwH"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">data.csv</p></figure><p id="ced6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如在下表中；每个观察或每个人都是一行。每个变量或者说每个人的财产是一列。</p><p id="fd46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Pandas 设计用于处理矩形数据，就像我们拥有的这个。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="5561" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">熊猫数据框</h1><p id="2f27" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">在 pandas 中，矩形数据被表示为 DataFrame 对象。每一种用于数据分析的编程语言都有类似熊猫的东西。比如 R 也有数据框，SQL 有个叫数据库表的东西。</p><p id="6518" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">列中的每个值都具有相同的数据类型，可以是文本或数字，但是不同的列可以包含不同的数据类型。</p><h2 id="08b1" class="ny mn it bd mo nz oa dn ms ob oc dp mw li od oe my lm of og na lq oh oi nc oj bi translated">输入数据</h2><p id="cee6" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">首先，我们必须导入 pandas，然后使用一种称为“read_csv”的特殊方法读取“data.csv”文件。您可以在 excel 或任何电子表格程序中创建自己的数据文档，然后将其导出为 csv 文件。</p><pre class="kj kk kl km gt ok ol om on aw oo bi"><span id="6760" class="ny mn it ol b gy op oq l or os">import pandas as pd <br/>df = pd.read_csv("data.csv")</span><span id="cb88" class="ny mn it ol b gy ot oq l or os">print(df)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/f492c6f9cd5666b87c44c46942652e5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cTnEeTDuNQgRx8BO"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">结果</p></figure><p id="bf6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您第一次收到一个新数据集时，您想做的第一件事是快速浏览并了解数据。熊猫有一些很好的方法来探索甚至操纵数据。今天，我将向您介绍以下方法:对数据进行排序和子集化。我将向你们展示它们每一个的结果，以便更好地理解它是如何工作的。让我们从排序值开始。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="92f5" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">排序值</h1><p id="15f7" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">我们要做的第一件事是通过排序来改变行的顺序。通过这种方式，您将能够在数据框架的顶部看到数据的最终收益。可以使用 sort_values 方法对行进行排序。您必须传入您想要按数据框架排序的列名。</p><p id="0d21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们对 weight_kg 列名应用 sort_values 方法，我们将根据它们的重量对它们进行排序。我们将把最轻的人放在上面，最重的放在下面。</p><pre class="kj kk kl km gt ok ol om on aw oo bi"><span id="b9be" class="ny mn it ol b gy op oq l or os">df.sort_values('Weight (kg)')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/70a2d4a9e5b72c3b29ec609e5ddfbe4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PhOnkGOK6SCCkm2o"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">结果</p></figure><p id="1c14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想知道是否可以根据多个列名对数据帧进行排序，是的，这是可能的。我们所要做的就是在 sort_values 方法中将列名作为一个列表传递。</p><pre class="kj kk kl km gt ok ol om on aw oo bi"><span id="da4c" class="ny mn it ol b gy op oq l or os">df.sort_values(['Weight (kg)','Height (cm)'])</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/b71bc13c20dce0aaa4e53a66d0836f06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vuMAdts03o5yRKGJ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">结果</p></figure><p id="32c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要改变值的排序方向，我们所要做的就是添加另一个名为 ascending 的属性，然后向该属性传递一个列表。在我们的例子中，人们现在按照从最高到最低的顺序排列。</p><pre class="kj kk kl km gt ok ol om on aw oo bi"><span id="cd71" class="ny mn it ol b gy op oq l or os">df.sort_values(['Weight (kg)','Height (cm)'], ascending=[True, False])</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/db94fffd6e3325f66f3b1c0b3a83c1b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AFN0cRPUna0rXX1O"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">结果</p></figure></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="12b7" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">子集化</h1><h2 id="97b4" class="ny mn it bd mo nz oa dn ms ob oc dp mw li od oe my lm of og na lq oh oi nc oj bi translated">子集化列</h2><p id="635c" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">子集化是探索数据和了解数据的另一种方式。假设您只想查看一列的值。我们可以使用 DataFrame 的名称，后跟括号内的列名来实现这一点。</p><pre class="kj kk kl km gt ok ol om on aw oo bi"><span id="d470" class="ny mn it ol b gy op oq l or os">df['Name']</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/87de6a7e81f71df4d1d2fef74549a6b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BqmNzRyOnyQTN0rr"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">结果</p></figure><p id="6209" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想查看多列而不是一列，这也非常容易。你只需要在括号内的列名列表中传递。我通常使用这种方法来查看列之间是否有密切的关系。</p><pre class="kj kk kl km gt ok ol om on aw oo bi"><span id="f121" class="ny mn it ol b gy op oq l or os">df[['Name', 'Height (cm)']]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/225726f6ba221b6614e6c2d34aa8bb76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/0*rlQ12kW2oqLpDylb"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">结果</p></figure><h2 id="81b3" class="ny mn it bd mo nz oa dn ms ob oc dp mw li od oe my lm of og na lq oh oi nc oj bi translated">子集化行</h2><p id="86fe" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">对行进行子集化是了解数据的另一种方式。有许多方法可以对行进行子集化，但是我们将在本文中介绍的方法是最常见的方法，即创建一个逻辑条件过滤方法。</p><p id="939e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，假设我们要过滤身高超过 170cm 的人。我们可以用下面的代码行来实现:</p><pre class="kj kk kl km gt ok ol om on aw oo bi"><span id="8a59" class="ny mn it ol b gy op oq l or os">df[df['Height (cm)'] &gt; 170]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/94746bb6dd7b21b759f2cbe5efaeb8ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oUCBsvlEtZaomXtS"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">结果</p></figure><p id="fdfd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可能有字符串类型的列，还有另一种过滤文本数据的方法。逻辑表达式将类似于我们所做的，但这一次我们将使用两个等号来做检查。</p><pre class="kj kk kl km gt ok ol om on aw oo bi"><span id="029e" class="ny mn it ol b gy op oq l or os">df[df['Zodiac Sign'] == 'Leo']</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/8a84eeae225227097581e2950c6426a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*g54mFIOC-kbPYBW1"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">结果</p></figure><p id="6a00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，如果您希望根据多个条件对行进行子集化，我们所要做的就是使用逻辑运算符(如“and”或“or”)来组合这些条件。我们来做一个快速的例子，过滤身高超过 160cm，生肖是狮子座的人。一个很好的方法是在不同的行中创建两个不同的条件，然后在最后使用“and”操作符将它们组合起来。</p><pre class="kj kk kl km gt ok ol om on aw oo bi"><span id="e3ca" class="ny mn it ol b gy op oq l or os">tall_cond = df['Height (cm)'] &gt; 160<br/>sign_cond = df['Zodiac Sign'] == 'Leo'</span><span id="7f12" class="ny mn it ol b gy ot oq l or os">df[tall_cond &amp; sign_cond]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/b76692358f96248d2722b3ccf7af22ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vmpg1pZYitNAa2-1"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">结果</p></figure><p id="b2ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您也可以在一行中完成这个子集设置，如下所示:</p><pre class="kj kk kl km gt ok ol om on aw oo bi"><span id="905c" class="ny mn it ol b gy op oq l or os">df[(df['Height (cm)'] &gt; 160) &amp; (df['Zodiac Sign'] == 'Leo')]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/e3fbf040192933643db60461d83908be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*scA3L2EXpc_2-c6C"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">结果</p></figure><h1 id="e779" class="mm mn it bd mo mp pd mr ms mt pe mv mw jz pf ka my kc pg kd na kf ph kg nc nd bi translated">最后一个提示</h1><p id="8c82" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">最后，这是子集化行的最佳实践之一。有一个特殊的方法叫做“isin()”，正如您可以理解它的名字一样，它过滤具有特定值的行。当根据特定值进行子集设置时，此方法很有用，因此没有范围。在下面的例子中，我将筛选出黄道十二宫与白羊座相匹配的行。</p><pre class="kj kk kl km gt ok ol om on aw oo bi"><span id="f73f" class="ny mn it ol b gy op oq l or os">leo_zodiac = df['Zodiac Sign'].isin(['Aries'])</span><span id="8b78" class="ny mn it ol b gy ot oq l or os">leo_zodiac</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pi"><img src="../Images/27996f1a28bb30ab156d274e3aee8010.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0y0xiEDgU_gnZYg2"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">结果</p></figure></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><p id="3734" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章到此为止，现在我们对如何使用 Pandas 库分析数据有了更好的理解。我们在小数据上做了实践练习，但是我强烈建议在大数据上练习这些方法。可以勾选<a class="ae ky" href="https://www.kaggle.com" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>下载数据。这也是一个发现数据科学挑战并尝试解决它们的好地方。跟上时代的最好方法是练习。</p><p id="79f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢你阅读这篇文章，我希望你今天喜欢并学到了一些新东西。以后我会分享更多的熊猫方法来帮助你分析你的数据。保持安全和快乐的编码！:)</p><blockquote class="pj pk pl"><p id="db8a" class="kz la me lb b lc ld ju le lf lg jx lh pm lj lk ll pn ln lo lp po lr ls lt lu im bi translated"><em class="it">跟随我的</em> <a class="ae ky" href="https://medium.com/@lifexplorer" rel="noopener">博客</a> <em class="it">和</em> <a class="ae ky" href="https://towardsdatascience.com/" rel="noopener" target="_blank">走向数据科学</a> <em class="it">留下灵感。</em></p></blockquote></div></div>    
</body>
</html>