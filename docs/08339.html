<html>
<head>
<title>3 Key Differences Between Merge and Concat Functions of Pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Pandas 的 Merge 和 Concat 功能之间的 3 个主要区别</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/3-key-differences-between-merge-and-concat-functions-of-pandas-ab2bab224b59?source=collection_archive---------6-----------------------#2020-06-18">https://towardsdatascience.com/3-key-differences-between-merge-and-concat-functions-of-pandas-ab2bab224b59?source=collection_archive---------6-----------------------#2020-06-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4cc4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">何时以及如何使用它。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b6aacaa25b7d9eaaaa9dc1e636db14f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qbK7OlZRsUKv5f5IHXLqBw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">安德烈·亨特在<a class="ae ky" href="/s/photos/different?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="d131" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Pandas 是一个高效且广泛使用的数据分析工具。Pandas 的核心数据结构是 dataframe，它用带有标签的行和列的表格形式表示数据。DataFrame 有许多强大而灵活的功能和方法，可以简化和加快数据清理和分析过程。</p><p id="2873" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据科学项目通常需要我们从不同的来源收集数据。因此，作为数据准备的一部分，我们可能需要组合数据框架。<strong class="lb iu"> concat </strong>和<strong class="lb iu"> merge </strong>功能都用于合并数据帧。在这篇文章中，我将解释它们之间的 3 个主要区别。</p><h1 id="c890" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak"> 1。结合的方式</strong></h1><p id="4c4c" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><strong class="lb iu"> Concat </strong>函数沿行或列连接数据帧。我们可以把它想象成多个数据帧的叠加。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/59ef1ec1e33243b6a0ca9f226607a55d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0wu6DunCzPC4o9FIyRTW4w.png"/></div></div></figure><p id="6c28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">合并</strong>根据共享列中的值合并数据帧。与 concat 函数相比，Merge 函数提供了更大的灵活性，因为它允许基于条件的组合。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mt"><img src="../Images/ce97ae9025953e86723f30a2303c1d8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-uSHoxrzM57syqnKnms2iA.png"/></div></div></figure><p id="6571" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您有一个包含信用卡交易的数据集。您有一组关于交易细节的列和一个指示客户 ID 的列。另一个数据帧包括关于客户和客户 ID 的更详细的信息。为了组合这两个数据框架，我们可以在“客户 ID”列上合并它们，以便条目匹配。我们使用 concat 的一个例子是合并包含 2019 年和 2020 年信用卡交易的数据帧。我们可以用 concat 函数把它们堆叠起来。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="8ecf" class="lv lw it bd lx ly nb ma mb mc nc me mf jz nd ka mh kc ne kd mj kf nf kg ml mm bi translated"><strong class="ak"> 2。轴参数</strong></h1><p id="0090" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">只有 concat 函数有轴参数。Merge 用于根据共享列中的值并排组合数据帧，因此不需要轴参数。</p><p id="05ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据 axis 参数的值，我们可以将数据帧按行(上下重叠)或列(并排)连接起来。axis 参数的默认值为 0，表示沿行组合。</p><p id="8402" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们来做几个例子。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="1255" class="nl lw it nh b gy nm nn l no np">import numpy as np<br/>import pandas as pd</span><span id="1591" class="nl lw it nh b gy nq nn l no np">df1 = pd.DataFrame({<br/>'A':[1,2,3,4],<br/>'B':[True,False,True,True],<br/>'C':['C1','C2','C3','C4']<br/>})</span><span id="a3a4" class="nl lw it nh b gy nq nn l no np">df2 = pd.DataFrame({<br/>'A':[5,7,8,5],<br/>'B':[False,False,True,False],<br/>'C':['C1','C3','C5','C8']<br/>})</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/47c496ee8519023f949c28e2d6c28c3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:978/format:webp/1*U8nW_ZOAoIyVig5uyPaT2w.png"/></div></figure><p id="6217" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">轴=0: </strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/17d295e793e8b3e39f5b74c170309711.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*8OJ4o5IVAbh1M9GB3C-hiQ.png"/></div></figure><p id="7c26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">轴=1: </strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/9bb5ca24f80ff54e6dc32e109c2b5b16.png" data-original-src="https://miro.medium.com/v2/resize:fit:986/format:webp/1*G8yWkEY7IXxwcs3p2CmedA.png"/></div></figure></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="9dbb" class="lv lw it bd lx ly nb ma mb mc nc me mf jz nd ka mh kc ne kd mj kf nf kg ml mm bi translated"><strong class="ak"> 3。加入 vs 如何加入</strong></h1><p id="1691" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">Join 是 concat 函数的参数，how 是 merge 函数的参数。他们的目标是一样的，但是他们工作的方式有点不同。</p><p id="f9d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Join 指定在数据帧具有不同索引的情况下如何处理索引。让我们用不同的索引创建前面的数据帧。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="7f39" class="nl lw it nh b gy nm nn l no np">df2 = pd.DataFrame({<br/>'A':[5,7,8,5],<br/>'B':[False,False,True,False],<br/>'C':['C1','C3','C5','C8']},<br/>index=[2,3,4,5]<br/>)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/0ef8aa8209e749f1961b0ce8316f999d.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/format:webp/1*gN4Cq5ycdsfX8HcBhmx7Xg.png"/></div></figure><p id="98c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们只是通过将索引值传递给<strong class="lb iu"> index </strong>参数来更改第二个数据帧的索引。</p><p id="c740" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Join 参数取两个值，<strong class="lb iu">外</strong>和<strong class="lb iu">内</strong>。</p><ul class=""><li id="a59e" class="nv nw it lb b lc ld lf lg li nx lm ny lq nz lu oa ob oc od bi translated">外部:取所有索引(<strong class="lb iu"> join </strong>参数的默认值)</li><li id="f0dd" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated">内部:仅采用共享索引</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/5db941b44785360cb24426a06b3f73ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*IKERfmeoyggNZhKF9bb9ZQ.png"/></div></figure><p id="8b9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们获取所有索引，但是第二个数据帧没有索引为 0 和 1 的行。因此，第二个数据帧中的值用 NaN(缺省缺失值标记)填充。类似地，第一个数据帧中的行 4 和行 5 被填充 NaN 值。</p><p id="42b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们将 join 设置为<strong class="lb iu"> inner </strong>，那么只有存在于两个数据帧中的索引才会显示出来。因此，我们不会因为连接而丢失任何值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/99ca983ed98aac10a4584833450846fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*wgXB3ivAkdpNcLzvIkmguw.png"/></div></figure></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><p id="d384" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">合并功能的<strong class="lb iu">参数</strong>的工作方式类似。<strong class="lb iu">如何</strong>的可能值为<strong class="lb iu">内</strong>、<strong class="lb iu">外</strong>、<strong class="lb iu">左</strong>、<strong class="lb iu">右</strong>。</p><ul class=""><li id="c637" class="nv nw it lb b lc ld lf lg li nx lm ny lq nz lu oa ob oc od bi translated">inner:只有在参数<strong class="lb iu">指定的列中有相同值的行(<strong class="lb iu"> how </strong>参数的默认值)</strong></li><li id="711b" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated">外部:所有行</li><li id="b816" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated">左侧:左侧数据帧中的所有行</li><li id="3f11" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated">右侧:右侧数据帧中的所有行</li></ul><p id="2c59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的数字更清楚地代表了参数的概念。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/0bf434d5d260daa0b1543ee5cf9579e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/0*jvwnytz9fTIv4FhP.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/a108564de031af6ec1cd8dbadebc69ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/format:webp/0*AqfCfCL_1lJYXLU6.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi om"><img src="../Images/20458ceb847e1e0b05267f74565e058e.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/format:webp/0*Imm6FiKATHSLLQ-t.png"/></div></figure><p id="4792" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在做一些例子之前，让我们先回忆一下我们的数据框架。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/27f7ee42c89de9edf065ce827d0bcf79.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/format:webp/1*eftxSRXY1_MV02heBThllw.png"/></div></figure><p id="deaf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将在列‘C’上合并 df1 和 df1 <strong class="lb iu">。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/4f84146c90c412f61f523a97783f455e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*MnES8tppZtg6WvMK-Q2eYA.png"/></div></figure><p id="a663" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">df1 和 df1 在列 C 中的值都是 C1 和 C3，因此当 how 设置为“inner”时，只有这些值才会显示。</p><p id="72b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">外面怎么样？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/00b890bbaa7493c42930dc9dda7cc3e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1030/format:webp/1*z43YI1zkymuDpkHPcQtrTQ.png"/></div></figure><p id="1a43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当选择<strong class="lb iu"> outer </strong>作为 how 参数时，合并的数据帧包括列“C”的所有值。公共值不重复，df1 或 df2 中不存在的值用 NaN 填充。</p><p id="2b57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当选择<strong class="lb iu"> left </strong>作为 how 参数时，合并的数据帧包括左侧数据帧中的所有行。如果列“C”(传递给 on 参数的列)中的值不在右数据帧中，则来自右数据帧的列将填充 NaN 值。<strong class="lb iu">右</strong>选项很少使用，因为我们可以只改变 merge 函数中 dataframe 的顺序(而不是(df1，df2)使用(df2，df1))。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/2adcb0d35b96dd876f472e9f117dcd9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/format:webp/1*Mwfd-ov4lRuAFWuXnvZUiw.png"/></div></figure></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><p id="a096" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读。如果您有任何反馈，请告诉我。</p></div></div>    
</body>
</html>