<html>
<head>
<title>Picture me rollin’ with Pandas in 4 minutes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">想象我在4分钟内和熊猫一起打滚</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/picture-me-rollin-with-pandas-in-4-minutes-7f35d57eb00f?source=collection_archive---------15-----------------------#2020-01-25">https://towardsdatascience.com/picture-me-rollin-with-pandas-in-4-minutes-7f35d57eb00f?source=collection_archive---------15-----------------------#2020-01-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="608f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">对Pandas DataFrame.rolling()的简短介绍，它提供了一种执行滚动窗口计算的简单方法。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/cb887e1b5b038eab711a9f153617325a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nkPe3MyFMH6cGbWcYv1LYg.png"/></div></div></figure><p id="1857" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">几个星期以来，我一直在研究一个用于机器学习的足球数据集。我的特色之一是比赛日统计，比如射门、角球和控球。当然，我不能得到相应比赛的数据来预测它，因为它只能在赛后得到。所以我想用前三个比赛日的平均值来预测下一个比赛日。我的第一个想法是编写一个循环来聚合数据，但后来我发现了更好的东西:pandas.DataFrame.rolling. </p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h2 id="515f" class="ly lz it bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated"><strong class="ak">问题</strong></h2><p id="de09" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">我在介绍中已经说过，我正在研究一个足球预测模型。想象以下数据帧:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mw"><img src="../Images/0fa9a7b157a46aaea73a46f6066994ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pL6fmTRALghoOSmYl0Un9Q.png"/></div></div></figure><p id="4be6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我有匹配统计数据，这是我的特征，也是我想用算法分类的目标。但是我不能使用这种形式的比赛统计，因为我在比赛前没有这种信息。因此，我想使用最近3个游戏日的平均值作为一个特征。</p><h2 id="26af" class="ly lz it bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated"><strong class="ak">一个可能的解决方案</strong></h2><p id="5542" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">我的第一个意图是用以下逻辑编写一个循环:对于行<em class="lq"> x </em>，我们对行<em class="lq"> x-3 </em>到<em class="lq"> x-1 </em>求和，并将结果除以3:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mx"><img src="../Images/cb07483ce76801a565529b70248123c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b3J6iWR1XycTJgqO-OpXJQ.png"/></div></div></figure><p id="ec6a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如你所看到的，这个循环花了<strong class="kw iu"> 2.64秒完成了31行</strong>。由于我的数据集包含大约9000个游戏，这个解决方案对我来说太耗时了。不管怎样，我至少得到了想要的结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi my"><img src="../Images/05dfd2414b83566ce3b9a0afc34d3863.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IcgUkUTjXeRkosp-ST8fTQ.png"/></div></div></figure><h2 id="b5b7" class="ly lz it bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated"><strong class="ak">更好的解决方案</strong></h2><p id="4ff4" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">我做了一些调查，发现了熊猫。DataFrame.rolling  这应该是我要求的完美解决方案。它提供了滚动窗口计算的选项。<strong class="kw iu">滚动窗口背后的基本概念是定义一个特定大小的窗口，在其中执行特定的计算</strong>。它常用于时间序列分析。在<a class="ae mz" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.rolling.html" rel="noopener ugc nofollow" target="_blank"> Pandas文档</a>中，您会发现以下参数:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi na"><img src="../Images/b267b18d5356cca805c845d36e0517b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*qrkc1McE7z2VBu90pfinkQ.png"/></div></figure><p id="32c1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了重现第一次循环的结果，我们只需要定义窗口的大小。我们还需要添加shift (1 ),以便以1:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="5ae7" class="ly lz it nc b gy ng nh l ni nj">df_chelsea['Goals Team 1_avg'] = df_chelsea['Goals Team 1'].shift(1).rolling(3).mean()</span><span id="4f6f" class="ly lz it nc b gy nk nh l ni nj">df_chelsea['Goals Team 2_avg'] = df_chelsea['Goals Team 2'].shift(1).rolling(3).mean()</span><span id="2643" class="ly lz it nc b gy nk nh l ni nj">df_chelsea['Shots Team 1_avg'] = df_chelsea['Shots Team 1'].shift(1).rolling(3).mean()</span><span id="ec69" class="ly lz it nc b gy nk nh l ni nj">df_chelsea['Shots Team 2_avg'] = df_chelsea['Shots Team 2'].shift(1).rolling(3).mean()</span></pre><p id="c282" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">结果与上一节完全相同:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/aacc4de2d22759a79a5bb87898243d4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o3HPI-7ut4CXKpRJKW_s3A.png"/></div></div></figure><p id="ab08" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">执行<strong class="kw iu">只用了19毫秒</strong>，比之前的循环少了很多。如果我们定义了min_periods参数，我们还可以填充一些“NaN ”:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="58ea" class="ly lz it nc b gy ng nh l ni nj">df_chelsea['Goals Team 1_avg'] = df_chelsea['Goals Team 1'].shift(1).rolling(3,min_periods=1).mean()</span><span id="4a26" class="ly lz it nc b gy nk nh l ni nj">df_chelsea['Goals Team 2_avg'] = df_chelsea['Goals Team 2'].shift(1).rolling(3,min_periods=1).mean()</span><span id="4460" class="ly lz it nc b gy nk nh l ni nj">df_chelsea['Shots Team 1_avg'] = df_chelsea['Shots Team 1'].shift(1).rolling(3,min_periods=1).mean()</span><span id="a99c" class="ly lz it nc b gy nk nh l ni nj">df_chelsea['Shots Team 2_avg'] = df_chelsea['Shots Team 2'].shift(1).rolling(3,min_periods=1).mean()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/9eb8591c44e0eb90dc84102572939c9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OkHlASlyiphhlKYg10Ea2Q.png"/></div></div></figure></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h2 id="ee18" class="ly lz it bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated">结论</h2><p id="c04d" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">如果您觉得用Python分析数据花费的时间太长，通常有一种更有效的方法。这里的情况也是如此。Pandas提供了一个内置函数来执行滚动窗口计算，而不是一个简单的循环，这要舒服得多，并提供了许多附加功能。它也比循环耗时少，执行时间只占循环的0.7%。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><p id="fd30" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae mz" href="https://medium.com/@droste.benedikt/membership" rel="noopener">如果您喜欢中级和高级数据科学，并且还没有注册，请随时使用我的推荐链接加入社区。</a></p></div></div>    
</body>
</html>