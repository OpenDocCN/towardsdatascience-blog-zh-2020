<html>
<head>
<title>How to Learn Julia When You Already Know Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">已经会 Python 了怎么学 Julia</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-learn-julia-when-you-already-know-python-641ed02b3fa7?source=collection_archive---------7-----------------------#2020-07-18">https://towardsdatascience.com/how-to-learn-julia-when-you-already-know-python-641ed02b3fa7?source=collection_archive---------7-----------------------#2020-07-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3cc3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">跳到好的方面</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/32c30b5894417e9cbd75c36132a1ff37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qmlhTODc28nBjbiu"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">鲍里斯·斯莫克罗维奇在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="2bae" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">朱莉娅是新来的吗？</h1><p id="c76c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Julia 是一种较新的获奖编程语言，学起来像 Python 一样简单，但执行起来像 c 一样快，不信？确实是真的。(点击<a class="ae ky" href="https://github.com/astrojhgu/adaptrapezoid_benchmark" rel="noopener ugc nofollow" target="_blank">此处</a>进行多语言速度对比。)</p><p id="4818" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">Julia 提供的不仅仅是语法和速度。为了解释他们开发这种语言的原因，朱莉娅的创造者说:</p><p id="8b1c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">“我们想要 C 的速度和 Ruby 的活力。我们想要一种同形异义的语言，既有像 Lisp 那样的真正的宏，又有像 Matlab 那样明显、熟悉的数学符号。我们想要像 Python 一样可用于一般编程，像 R 一样易于统计，像 Perl 一样自然用于字符串处理，像 Matlab 一样强大用于线性代数，像 shell 一样善于将程序粘合在一起。这种东西学习起来非常简单，却能让最严肃的黑客感到高兴。[1]" </p><p id="54ad" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">陪审团还没有决定，但感觉他们已经做出了决定。当 Julia 1.0 发布时，一种有潜力实现大部分(如果不是全部)目标的语言的框架就诞生了。</p><p id="1170" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">同时，Julia 要达到主流编程语言的成熟还有很长的路要走。Julia 的软件包需要改进，它的文档和学习资源也需要改进。幸运的是，一个活跃的(甚至是热心的)开发者社区正在解决这些问题。</p><p id="c238" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">尽管这种语言正在发展，但有很多理由学习 Julia ，尤其是如果你对机器学习、数据科学或科学计算感兴趣的话。</p><h1 id="751e" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">懂 Python 想学 Julia？</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mt"><img src="../Images/fe53c35125795afdf5c3e126388c82f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mgfNjVWfhlAiSXlW"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@arifriyanto?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Arif Riyanto </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="f1f2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">Python 用户通常能够很快学会 Julia 语法。语法类似于 Python，有许多 Python 用户熟悉的约定。</p><p id="0dea" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然而，用 Julia 编程与用 Python 编程有着根本的不同。很有可能，Python 用户编写的第一个 Julia 代码在外观和行为上都很像 Python。虽然这种方法没有什么大问题，但看起来像 Python 的 Julia 可能会效率低下，并且会错过该语言的重要方面。</p><p id="0cda" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">Julia 在不同的范例下运行——通用函数、巧妙的调度和深思熟虑的类型(仅举几个例子),这些想法中有许多根本没有出现在 Python 中。因此，本文的目标是教授三个简单而重要的 Julia 概念:类型层次<strong class="lt iu">、<strong class="lt iu">多分派</strong>和<strong class="lt iu">用户定义类型</strong>。选择这些概念是为了帮助加速 Pythonic Julia 程序，说明 Julia 与 Python 的不同之处，并向 Python 用户介绍新的编程思想。</strong></p><p id="c288" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">因此，因为我侧重于概念，所以我不会在这里介绍安装 Julia 和学习基本语法。对于安装和语法，我推荐以下资源:</p><ul class=""><li id="1cf8" class="mu mv it lt b lu mn lx mo ma mw me mx mi my mm mz na nb nc bi translated">Changhyun Kwon 的《Julia 运筹学编程》的第一章包含了一个优秀的安装和设置指南。</li><li id="9e86" class="mu mv it lt b lu nd lx ne ma nf me ng mi nh mm mz na nb nc bi translated">由 J. Fernandez-Villaverde 编写的安装和语法综合指南。</li><li id="db1f" class="mu mv it lt b lu nd lx ne ma nf me ng mi nh mm mz na nb nc bi translated">通过例子向<a class="ae ky" href="https://juliabyexample.helpmanual.io/" rel="noopener ugc nofollow" target="_blank"> Julia 学习语法。</a></li><li id="6f75" class="mu mv it lt b lu nd lx ne ma nf me ng mi nh mm mz na nb nc bi translated">从德里克·巴纳斯的<a class="ae ky" href="https://www.youtube.com/watch?v=sE67bP2PnOo" rel="noopener ugc nofollow" target="_blank">视频</a>中学习语法。</li></ul><h1 id="230e" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">三个重要的朱莉娅概念</h1><h2 id="6023" class="ni la it bd lb nj nk dn lf nl nm dp lj ma nn no ll me np nq ln mi nr ns lp nt bi translated"><strong class="ak"> 1。类型层次</strong></h2><p id="41d3" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Julia 的许多速度、多功能性和可组合性优势部分归功于打字系统。在 Python 中，类型可能是事后才想到的，所以通过类型思考可能会显得乏味。然而，Julia 保持简单，并以速度提升奖励仔细思考。</p><p id="0e3a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">具体/原始类型</strong></p><p id="3685" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">Julia 使用两种不同的类型:具体类型和抽象类型。每一个都有不同的用途。具体类型包括典型的<code class="fe nu nv nw nx b">String</code>、<code class="fe nu nv nw nx b">Bool</code>、<code class="fe nu nv nw nx b">Int64</code>等。并用于标准计算。类型<code class="fe nu nv nw nx b">Float64</code>是一个具体类型，意味着<code class="fe nu nv nw nx b">Float64</code>可以被实例化并用于计算。</p><p id="f2e1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">抽象类型</strong></p><p id="1208" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">类型<code class="fe nu nv nw nx b">Union{}</code>、<code class="fe nu nv nw nx b">AbstractFloat</code>、<code class="fe nu nv nw nx b">Real</code>和<code class="fe nu nv nw nx b">Any</code>都是抽象类型。抽象类型不能实例化。相反，抽象类型是将相似类型的数据组合在一起的容器。它们通常用于向编译器表明可以在抽象类型的任何子类型上调用函数。</p><pre class="kj kk kl km gt ny nx nz oa aw ob bi"><span id="29c3" class="ni la it nx b gy oc od l oe of">""" This function accepts Float16, Float32, Float64 <br/>    because they are all subtypes of AbstractFloat<br/>"""<br/>function g(a::AbstractFloat)<br/>    return floor(Int, a) <br/>end</span></pre><p id="71bd" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">类型<code class="fe nu nv nw nx b">Any</code>和<code class="fe nu nv nw nx b">Union{}</code>是特殊的。<code class="fe nu nv nw nx b">Union{}</code>被预定义为所有类型的子类型。它是类型层次结构的底部。类似地，每个类型都是<code class="fe nu nv nw nx b">Any</code>的子类型，使其成为类型层次结构的顶层。</p><p id="fbae" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">为什么使用抽象类型？</strong></p><p id="a813" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">抽象类型很有用，因为定义为作用于抽象类型的函数能够作用于抽象类型的所有子类型。</p><p id="4c55" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">举个例子，假设一个开发人员需要一个类似数组的数据结构。在 Julia 中，他们可以定义自己的应用程序特定结构，并确保它满足<code class="fe nu nv nw nx b">AbstractArray</code>类型的要求。然后，Julia 生态系统中定义为对<code class="fe nu nv nw nx b">AbstractArray</code>数据进行操作的所有函数将在开发人员的类似数组的数据结构上工作。由于这个特性，Julia 的许多包可以顺利地一起工作，即使它们不是一起设计的。</p><p id="f2cf" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">与 Python 包形成对比。几乎每一个使用数组的包都是为使用<code class="fe nu nv nw nx b">numpy</code>数组而设计的。这就造成了对<code class="fe nu nv nw nx b">numpy</code>的巨大依赖。如果一个程序员想创建自己的数组并在上面调用<code class="fe nu nv nw nx b">numpy</code>函数，这可能会引发错误。很少有 Python 库能处理自定义对象。相比之下，Julia 中的抽象类型给了开发人员更多的灵活性，并有助于使包更具可组合性。</p><p id="e201" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">操作员</strong></p><p id="91fb" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">二元运算符<code class="fe nu nv nw nx b">::</code>用于断言变量是某种类型。更具体地说，运算符可以将变量初始化为特定类型，表明函数参数必须是特定类型，或者断言预定义变量是特定类型。下面演示了其中的每一种用法。</p><pre class="kj kk kl km gt ny nx nz oa aw ob bi"><span id="82b9" class="ni la it nx b gy oc od l oe of"># Initialize a Float64<br/>x::Float64 = 100</span><span id="b908" class="ni la it nx b gy og od l oe of"># Argument z must be an Int64<br/><strong class="nx iu">function</strong> f(z::Int64)<br/>   <strong class="nx iu">return</strong> z^2<br/><strong class="nx iu">end</strong></span><span id="6aae" class="ni la it nx b gy og od l oe of"># Assert x is a Float64 <br/>x::Float64 # (Does nothing)</span><span id="9b63" class="ni la it nx b gy og od l oe of"># Assert that x is an Int64 <br/>x::Int64 # (Raises error)</span></pre><p id="ad96" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">值得一提的是，我们可以在没有类型断言的情况下声明变量或定义函数，例如<code class="fe nu nv nw nx b">x = 100</code>。(在这种情况下，变量<code class="fe nu nv nw nx b">x</code>将是一个<code class="fe nu nv nw nx b">Int64</code>。)</p><p id="d0f7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">子类型运算符<code class="fe nu nv nw nx b">&lt;:</code>确定一个类型是否是另一个类型的子类型。如果我们想比较两个变量<code class="fe nu nv nw nx b">x</code>和<code class="fe nu nv nw nx b">y</code>的类型，如果变量<code class="fe nu nv nw nx b">x</code>的类型是变量<code class="fe nu nv nw nx b">y’s</code>类型的子类型，那么计算表达式<code class="fe nu nv nw nx b">typeof(x) &lt;: typeof(y)</code>将返回<code class="fe nu nv nw nx b">true</code>。作为另一个例子，考虑以下表达式:</p><pre class="kj kk kl km gt ny nx nz oa aw ob bi"><span id="77c6" class="ni la it nx b gy oc od l oe of">Union{} &lt;: Float64 &lt;: AbstractFloat &lt;: Real &lt;: Any</span></pre><p id="8b21" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这评估为<code class="fe nu nv nw nx b">true</code>,表示我们已经在类型层次结构中对类型进行了正确排序。(<code class="fe nu nv nw nx b">&lt;:</code>操作符可以比较这些对象，因为它们是类型而不是变量。)</p><p id="c8b1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">更多关于类型的阅读:</strong></p><ul class=""><li id="d962" class="mu mv it lt b lu mn lx mo ma mw me mx mi my mm mz na nb nc bi translated">关于类型的文档</li><li id="e3de" class="mu mv it lt b lu nd lx ne ma nf me ng mi nh mm mz na nb nc bi translated">一个很棒的关于类型的<a class="ae ky" href="https://scls.gitbooks.io/ljthw/content/_chapters/06-ex3.html" rel="noopener ugc nofollow" target="_blank">教程</a>来自《艰难地学习茱莉亚》</li><li id="712c" class="mu mv it lt b lu nd lx ne ma nf me ng mi nh mm mz na nb nc bi translated">Julia 的创造者之一，(Stephan Karpinski) <a class="ae ky" href="https://stackoverflow.com/questions/28078089/is-julia-dynamically-typed" rel="noopener ugc nofollow" target="_blank">讲解栈溢出上的类型系统</a>。</li></ul><h2 id="516b" class="ni la it bd lb nj nk dn lf nl nm dp lj ma nn no ll me np nq ln mi nr ns lp nt bi translated">2.多重调度</h2><p id="ed19" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这个概念可能是了解朱莉娅最重要的概念。从开发的角度来看，Julia 提供的许多优势都源于多重调度。</p><p id="73a6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">多重分派是指函数根据其参数的类型表现不同。它类似于函数重载，但<a class="ae ky" href="https://discourse.julialang.org/t/is-multiple-dispatch-the-same-as-function-overloading/4145/8" rel="noopener ugc nofollow" target="_blank">不完全相同</a>。</p><p id="71ab" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">当程序员将类型注释添加到函数定义中时，会发生多重分派。考虑下面的例子:</p><p id="dfd9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们需要一个函数<code class="fe nu nv nw nx b">f</code>来平方它的输入，然后计算它的值 mod 4。在 Julia 中，有 3 种等价的方式来定义<code class="fe nu nv nw nx b">f</code>:</p><pre class="kj kk kl km gt ny nx nz oa aw ob bi"><span id="19a3" class="ni la it nx b gy oc od l oe of"># Verbose definition<br/><strong class="nx iu">function</strong> f(x)<br/>    <strong class="nx iu">return</strong> x^2 % 4<br/><strong class="nx iu">end</strong></span><span id="5c01" class="ni la it nx b gy og od l oe of"># Mathematical notation<br/>f(x) = x^2 % 4 </span><span id="ecd2" class="ni la it nx b gy og od l oe of"># Like a Python lambda <br/>f = x -&gt; x^2 % 4</span></pre><p id="fca5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">假设我们总是需要<code class="fe nu nv nw nx b">f</code>输出一个整数，但是它的输入<code class="fe nu nv nw nx b">x</code>可以是一个<code class="fe nu nv nw nx b">String</code>、<code class="fe nu nv nw nx b">Float64</code>或者<code class="fe nu nv nw nx b">Int64</code>，直到运行时我们才会知道<code class="fe nu nv nw nx b">x</code>的类型。在 Python 中，这是通过以下方式解决的:</p><pre class="kj kk kl km gt ny nx nz oa aw ob bi"><span id="b664" class="ni la it nx b gy oc od l oe of"><strong class="nx iu">def</strong> f_py(x):<br/>    <strong class="nx iu">if</strong> type(x) == string:<br/>        x = float(x)<br/>    <strong class="nx iu">if</strong> type(x) == float:<br/>        x = ceil(x)<br/>    <strong class="nx iu">return</strong> x**2 % 4</span></pre><p id="0dcd" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在 Julia 中，我们<em class="ms">可以</em>编写一个类似上面 Python 函数的函数:</p><pre class="kj kk kl km gt ny nx nz oa aw ob bi"><span id="104f" class="ni la it nx b gy oc od l oe of"><strong class="nx iu">function</strong> f_py(x)<br/>    <strong class="nx iu">if</strong> isa(x, String)<br/>        x = parse(Float64, x)<br/>    <strong class="nx iu">end</strong><br/>    <strong class="nx iu">if</strong> isa(x, Float64)<br/>        x = ceil(Int64,x)<br/>    <strong class="nx iu">end</strong><br/>    x^2 % 4<br/><strong class="nx iu">end</strong></span></pre><p id="0634" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然而，我们最好这样写:</p><pre class="kj kk kl km gt ny nx nz oa aw ob bi"><span id="ccb6" class="ni la it nx b gy oc od l oe of">f(x::Int64) = x^2 % 4<br/>f(x::Float64) = f(ceil(Int64, x))<br/>f(x::String) = f(parse(Float64, x))</span></pre><p id="6284" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这个定义集合与 Python 函数<code class="fe nu nv nw nx b">f_py</code>做同样的事情。但是<code class="fe nu nv nw nx b">f</code>对<code class="fe nu nv nw nx b">x</code>的作用取决于<code class="fe nu nv nw nx b">x</code>的类型。三个定义中的每一个都指定了<code class="fe nu nv nw nx b">f</code>将对特定类型做什么。</p><ol class=""><li id="2840" class="mu mv it lt b lu mn lx mo ma mw me mx mi my mm oh na nb nc bi translated">如果<code class="fe nu nv nw nx b">f</code>被传递了一个<code class="fe nu nv nw nx b">Int64</code>，它将把它的平方和 mod 减四。</li><li id="559e" class="mu mv it lt b lu nd lx ne ma nf me ng mi nh mm oh na nb nc bi translated">如果向<code class="fe nu nv nw nx b">f</code>传递了一个<code class="fe nu nv nw nx b">Float64</code>，它将计算高于 float 的整数上限，并对该整数调用<code class="fe nu nv nw nx b">f</code>。这将调用 1 中描述的整数版本的<code class="fe nu nv nw nx b">f</code>。</li><li id="e5c8" class="mu mv it lt b lu nd lx ne ma nf me ng mi nh mm oh na nb nc bi translated">如果<code class="fe nu nv nw nx b">f</code>被传递了一个<code class="fe nu nv nw nx b">String</code>，它将把它转换成一个<code class="fe nu nv nw nx b">Float64</code>，然后在 float 上调用<code class="fe nu nv nw nx b">f</code>，这将调用<code class="fe nu nv nw nx b">f</code>的 float 版本，如 2 中所述。正如我们已经看到的，<code class="fe nu nv nw nx b">Float64</code>版本转换为<code class="fe nu nv nw nx b">Int64</code>，并调用<code class="fe nu nv nw nx b">f</code>的<code class="fe nu nv nw nx b">Int64</code>版本。</li></ol><p id="4710" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">当这些函数在一个有 300 万个混合类型元素的数组上广播时，被调度的函数在 0.039 秒内完成。Python 版的<code class="fe nu nv nw nx b">f_py</code>比<code class="fe nu nv nw nx b">f</code>慢<a class="ae ky" href="https://github.com/djpasseyjr/SideProjects/tree/master/Medium%20Articles/LearnJuliaWhenYouKnowPython/DispatchSpeed" rel="noopener ugc nofollow" target="_blank"> 50 倍</a>。此外，调度函数<code class="fe nu nv nw nx b">f</code>的速度是 pythonic Julia 的两倍。</p><p id="03f0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">一方面，Julia 基本上比 Python 快，但是我们也看到多分派比 pythonic Julia 快。这是因为在 Julia 中，<code class="fe nu nv nw nx b">f</code>的正确版本是在运行时通过查找表确定的，这避免了多次<code class="fe nu nv nw nx b">if</code>语句求值。</p><p id="1837" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">正如您所看到的，多重分派速度很快，可以有效地解决各种编程挑战，使其成为 Julia 语言最有用的工具之一。</p><p id="f6f1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">更上多分派</strong></p><ul class=""><li id="16ff" class="mu mv it lt b lu mn lx mo ma mw me mx mi my mm mz na nb nc bi translated"><a class="ae ky" href="https://medium.com/swlh/how-julia-uses-multiple-dispatch-to-beat-python-8fab888bb4d8" rel="noopener">Julia 如何使用多重调度击败 Python </a>。来自 DJ Passey 的多个调度的更多例子。</li><li id="31c1" class="mu mv it lt b lu nd lx ne ma nf me ng mi nh mm mz na nb nc bi translated"><a class="ae ky" href="https://www.youtube.com/watch?v=kc9HwsxE1OY" rel="noopener ugc nofollow" target="_blank">多次派遣的不合理效力</a>。斯蒂芬·卡尔平斯基的演讲。</li><li id="2799" class="mu mv it lt b lu nd lx ne ma nf me ng mi nh mm mz na nb nc bi translated">关于 Erik Schnetter 的博客文章<a class="ae ky" href="https://eschnett.github.io/julia/2016/06/23/some-thoughts-on-generic-programming-in-julia" rel="noopener ugc nofollow" target="_blank">泛型编程</a>的一些想法。</li></ul><h2 id="83a7" class="ni la it bd lb nj nk dn lf nl nm dp lj ma nn no ll me np nq ln mi nr ns lp nt bi translated">3.复合类型(结构)</h2><p id="ec65" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这可能令人震惊，但事实证明，Julia 不是面向对象的。没有类，也没有具有成员函数的对象。然而，通过利用多重分派和类型系统，Julia 获得了面向对象编程语言的优点和额外的灵活性。</p><p id="c8b9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">Julia 不使用对象，而是使用用户定义的复合类型结构。结构没有内部函数。它们只是命名类型的集合。在下面的例子中，我们定义了一个 NBA 球员结构:</p><pre class="kj kk kl km gt ny nx nz oa aw ob bi"><span id="34e9" class="ni la it nx b gy oc od l oe of"><strong class="nx iu">struct </strong>NBAPlayer<br/>    name::String<br/>    height::Int    <br/>    points::Float64<br/>    rebounds::Float64<br/>    assists::Float64<br/><strong class="nx iu">end</strong></span></pre><p id="0e75" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">类型<code class="fe nu nv nw nx b">NBAPlayer</code>有一个默认的构造函数:</p><pre class="kj kk kl km gt ny nx nz oa aw ob bi"><span id="b2e2" class="ni la it nx b gy oc od l oe of">doncic = NBAPlayer("Luka Doncic", 79, 24.4, 8.5, 7.1)</span></pre><p id="e1af" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">每个字段都可以用熟悉的点符号访问:<code class="fe nu nv nw nx b">doncic.name</code>、<code class="fe nu nv nw nx b">doncic.height</code>、<code class="fe nu nv nw nx b">doncic.points</code>、<code class="fe nu nv nw nx b">doncic.rebounds</code>和<code class="fe nu nv nw nx b">doncic.assists</code>。</p><p id="6615" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">您可以定义额外的构造函数，只要它们接受不同于默认的类型组合。这是多重调度在起作用:</p><pre class="kj kk kl km gt ny nx nz oa aw ob bi"><span id="830f" class="ni la it nx b gy oc od l oe of"># Constructor with no arguments</span><span id="e26f" class="ni la it nx b gy og od l oe of"><strong class="nx iu">function</strong> NBAPlayer()<br/>    # Make an empty player<br/>    <strong class="nx iu">return </strong>NBAPlayer("", 0.0, 0.0, 0.0)<br/><strong class="nx iu">end</strong></span></pre><p id="8fa7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">有了定义的结构，我们可以给 Julia 库中的函数新的定义:</p><pre class="kj kk kl km gt ny nx nz oa aw ob bi"><span id="4840" class="ni la it nx b gy oc od l oe of"><strong class="nx iu">function</strong> Base.show(io::IO, player::NBAPlayer)<br/>    print(io, player.name)<br/>    print(io, ": ")<br/>    print(io, (player.points, player.rebounds, player.assists))<br/><strong class="nx iu">end</strong></span></pre><p id="a305" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这定义了结构<code class="fe nu nv nw nx b">NBAPlayer</code>在打印时的显示方式。这类似于在 Python 中为一个类定义一个<code class="fe nu nv nw nx b">__repr__()</code>函数。然而，与我们在 Python 中定义内部函数不同，在 Julia 中，我们为外部函数如何作用于结构提供了新的定义。</p><p id="0250" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">Python 允许开发者用<a class="ae ky" href="https://rszalski.github.io/magicmethods/" rel="noopener ugc nofollow" target="_blank">魔法方法</a>来决定某些操作符应该如何作用于一个类。程序员可以为<code class="fe nu nv nw nx b">+, -, +=</code>和其他人应该如何作用于一个类编写他们自己的定义。但是，这从根本上受限于具有魔法方法的操作符列表。在 Julia 中，任何函数都可以被赋予任意类型或结构组合的定义。</p><h2 id="1df1" class="ni la it bd lb nj nk dn lf nl nm dp lj ma nn no ll me np nq ln mi nr ns lp nt bi translated"><strong class="ak">结论</strong></h2><p id="3d59" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">尽管 Julia 很容易上手，但掌握起来却很棘手。学习这些概念使开发人员走上了掌握 Julia 的道路。通过实践和尝试这些想法，您可以开发出编写高质量 Julia 程序所必需的技能。</p><h2 id="7828" class="ni la it bd lb nj nk dn lf nl nm dp lj ma nn no ll me np nq ln mi nr ns lp nt bi translated">参考</h2><p id="8ccf" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">[1] J. Bezanson，S. Karpinski V. Shah，A. Edelman，<a class="ae ky" href="https://julialang.org/blog/2012/02/why-we-created-julia/" rel="noopener ugc nofollow" target="_blank">为什么我们创造了 Julia </a> (2012)，JuliaLang.org</p></div><div class="ab cl oi oj hx ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="im in io ip iq"><div class="kj kk kl km gt op"><a href="https://medium.com/swlh/how-julia-uses-multiple-dispatch-to-beat-python-8fab888bb4d8" rel="noopener follow" target="_blank"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">Julia 如何利用多重调度击败 Python</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">亲自看</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">medium.com</p></div></div><div class="oy l"><div class="oz l pa pb pc oy pd ks op"/></div></div></a></div><div class="pe pf gp gr pg op"><a rel="noopener follow" target="_blank" href="/a-scenic-look-at-the-julia-language-e8ba53dea5bd"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">朱莉娅语言的风景照</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">体验朱莉娅，而不必做任何困难的事情</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">towardsdatascience.com</p></div></div><div class="oy l"><div class="ph l pa pb pc oy pd ks op"/></div></div></a></div><div class="pe pf gp gr pg op"><a rel="noopener follow" target="_blank" href="/deep-learning-side-by-side-julia-v-s-python-5ac0645587f6"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">深度学习并驾齐驱:Julia v.s. Python</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">你能说出哪一种是未来的语言吗？</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">towardsdatascience.com</p></div></div><div class="oy l"><div class="pi l pa pb pc oy pd ks op"/></div></div></a></div></div></div>    
</body>
</html>