<html>
<head>
<title>How to Build a Baseline Model</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何构建基线模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-build-a-baseline-model-be6ce42389fc?source=collection_archive---------16-----------------------#2020-06-06">https://towardsdatascience.com/how-to-build-a-baseline-model-be6ce42389fc?source=collection_archive---------16-----------------------#2020-06-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="e38c" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">探索性数据分析框架</h2><div class=""/><div class=""><h2 id="ea16" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">构建基线模型以了解数据的实用方法</h2></div><p id="d1b5" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">免责声明:您正在阅读本系列的第 2 部分。在 <a class="ae lo" href="https://medium.com/@tatianasennikova/code-and-techniques-for-exploratory-data-analysis-a44c50953502" rel="noopener"> <em class="ln">第 1 部分</em> </a> <em class="ln">中，我提出了一个探索性的数据分析框架，这是开始这里描述的建模部分之前的必要步骤。</em></p><h1 id="354f" class="lp lq it bd lr ls lt lu lv lw lx ly lz ki ma kj mb kl mc km md ko me kp mf mg bi translated">介绍</h1><p id="d487" class="pw-post-body-paragraph kr ks it kt b ku mh kd kw kx mi kg kz la mj lc ld le mk lg lh li ml lk ll lm im bi translated">直接投入研究并实现尖端的深度学习解决方案是非常诱人的。然而，在这一点上，我通常告诉自己保持务实，首先建立一个体面的基线。许多数据科学家低估了基线的重要性。我喜欢基线模型，因为它们能够以 10%的努力交付 90%的价值。两天内 80%准确的模型比四周内 81.5%准确的模型要好，这是与客户合作时最重要的。一个像样的基线模型的美妙之处在于，它很难被击败，而前沿模型只能实现对它的微小改进。好的基线模型有几个要求:</p><ol class=""><li id="23f1" class="mm mn it kt b ku kv kx ky la mo le mp li mq lm mr ms mt mu bi translated">基线模型应该简单。简单模型不太可能过度拟合。如果你发现你的基线已经过度拟合了，那么去做更复杂的建模是没有意义的，因为复杂性会扼杀性能。</li><li id="3361" class="mm mn it kt b ku mv kx mw la mx le my li mz lm mr ms mt mu bi translated">基线模型应该是可解释的。可解释性将帮助你更好地理解你的数据，并为你指明特征工程的方向。</li></ol><p id="73c7" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这两个原因让我们选择了我最喜欢的基线模型，它们是来自决策树家族的模型。关于树的另一个惊人的事实是，基于树的模型是非参数化的，不需要数据呈正态分布。</p><p id="94d5" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在决定了一个模型之后，让我们进入数据准备阶段。在<a class="ae lo" href="https://medium.com/@tatianasennikova/code-and-techniques-for-exploratory-data-analysis-a44c50953502" rel="noopener">第 1 部分</a>中，我们对<a class="ae lo" href="https://data.gov.uk/dataset/cb7ae6f0-4be6-4935-9277-47e5ce24a11f/road-safety-data" rel="noopener ugc nofollow" target="_blank">道路安全数据集</a>进行了探索性数据分析。两部分的完整代码可在<a class="ae lo" href="https://github.com/tsennikova/road-accidents-analysis/blob/master/road_accidents_analysis.ipynb" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p><figure class="nb nc nd ne gt nf gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi na"><img src="../Images/30d906c906db8ab35ef32c88076b5fc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mtl07yWV1pThetxzh51Jtg.jpeg"/></div></div><p class="nm nn gj gh gi no np bd b be z dk translated">马克·卡马洛夫<strong class="bd nq">/</strong>unsplash.com 摄影</p></figure><h1 id="e2d2" class="lp lq it bd lr ls lt lu lv lw lx ly lz ki ma kj mb kl mc km md ko me kp mf mg bi translated">问题陈述</h1><p id="4d23" class="pw-post-body-paragraph kr ks it kt b ku mh kd kw kx mi kg kz la mj lc ld le mk lg lh li ml lk ll lm im bi translated">最终目标是开发一个模型来预测警察参与事故的概率。我们还应该评估我们所掌握的数据的质量，并展示哪些因素对模型的决策有最大的影响。</p><h1 id="5d75" class="lp lq it bd lr ls lt lu lv lw lx ly lz ki ma kj mb kl mc km md ko me kp mf mg bi translated">数据准备</h1><p id="de99" class="pw-post-body-paragraph kr ks it kt b ku mh kd kw kx mi kg kz la mj lc ld le mk lg lh li ml lk ll lm im bi translated">在第 1 部分中，我们创建了一些新变量:</p><figure class="nb nc nd ne gt nf"><div class="bz fp l di"><div class="nr ns l"/></div><p class="nm nn gj gh gi no np bd b be z dk translated">勘探阶段产生的变量</p></figure><p id="831b" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">为了简洁起见，我将这些变量从 data dataframe(我们在探索阶段使用的那个)复制到我们的原始 dataframe acc_df。在生产系统中，应该实现数据处理管道的相关步骤。</p><figure class="nb nc nd ne gt nf"><div class="bz fp l di"><div class="nr ns l"/></div><p class="nm nn gj gh gi no np bd b be z dk translated">加入在勘探阶段设计的变量</p></figure><p id="0690" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们最初在<em class="ln">上了 3 节课，警察出席了事故现场。</em>类别 2 和类别 3 需要合并到负面类别中，因为我们只对估计警察参与事故的概率感兴趣。</p><p id="4c6a" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">事故数据集中的响应变量包含两个不平衡的类。因此，我们以这样的方式分割数据集，即我们在训练和测试数据集中保留相同比例的否定类。</p><figure class="nb nc nd ne gt nf"><div class="bz fp l di"><div class="nr ns l"/></div><p class="nm nn gj gh gi no np bd b be z dk translated">将数据拆分为训练数据集和测试数据集</p></figure><p id="651c" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在让我们开始创建数据转换器，稍后我们将把它们加入数据处理管道。为了保持模型简单并避免过度拟合，我们需要删除带有相关变量的列。</p><figure class="nb nc nd ne gt nf"><div class="bz fp l di"><div class="nr ns l"/></div><p class="nm nn gj gh gi no np bd b be z dk translated">移除相关变量</p></figure><p id="e204" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">然后我们需要将<em class="ln">的 LSOA _ 事故 _ 地点</em>的类别名称编码为整数。此变量的某些值很少见，只包含在测试数据集中。与此同时，未来可能会突然出现新的未知类别。标准的 sklearn 实现没有解决这个问题，因此我们需要通过引入一个“未知”类别来实现另一个解决方案，所有以前不可见的值都将属于这个类别。为此，我使用了 Vinoj John Hosan 的实现。</p><figure class="nb nc nd ne gt nf"><div class="bz fp l di"><div class="nr ns l"/></div><p class="nm nn gj gh gi no np bd b be z dk translated">编码分类变量</p></figure><p id="db83" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">下一步是填充缺失的值。我实施了两个策略。缺省值表示带有特殊类别“-1”的缺失值。第二种策略是训练模型，根据数据集中存在的值来填充缺失值。在调整超参数时，我们可以通过随机搜索来测试这两种方法。</p><figure class="nb nc nd ne gt nf"><div class="bz fp l di"><div class="nr ns l"/></div><p class="nm nn gj gh gi no np bd b be z dk translated">填充 NaN 值</p></figure><p id="9376" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们应该注意的最后一件事是重新调整连续值。严格地说，对于树模型来说，这是不必要的，但是如果我们将来想要将这个管道与其他分类模型一起使用，那么拥有它是很好的。</p><figure class="nb nc nd ne gt nf"><div class="bz fp l di"><div class="nr ns l"/></div><p class="nm nn gj gh gi no np bd b be z dk translated">重新缩放连续变量</p></figure><p id="0ac3" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在，我们可以将所有预处理步骤加入到一个管道中，并运行它来准备训练和测试数据集。</p><figure class="nb nc nd ne gt nf"><div class="bz fp l di"><div class="nr ns l"/></div><p class="nm nn gj gh gi no np bd b be z dk translated">准备训练和测试数据集</p></figure><h1 id="26a7" class="lp lq it bd lr ls lt lu lv lw lx ly lz ki ma kj mb kl mc km md ko me kp mf mg bi translated">训练模型</h1><p id="868e" class="pw-post-body-paragraph kr ks it kt b ku mh kd kw kx mi kg kz la mj lc ld le mk lg lh li ml lk ll lm im bi translated">RandomForest 分类器是所有决策树模型中最稳定的，不太可能过度拟合。因此，这是一个很好的选择。</p><figure class="nb nc nd ne gt nf"><div class="bz fp l di"><div class="nr ns l"/></div><p class="nm nn gj gh gi no np bd b be z dk translated">模特培训</p></figure><p id="8d2a" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">由于我们正在处理一个不平衡的数据集，我平衡了类权重，并使用加权 F1 分数作为超参数调整和模型评估的评分标准。</p><p id="9bb2" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">具有最佳超参数选择的验证集的平均 F1 分数为 0.785。现在，让我们检查训练和测试数据集的 F1 分数，以确保模型不会过度拟合。</p><figure class="nb nc nd ne gt nf"><div class="bz fp l di"><div class="nr ns l"/></div><p class="nm nn gj gh gi no np bd b be z dk translated">使用最佳估计器评估训练和测试数据集</p></figure><p id="f821" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">哎呀，我们的加权 F1 在训练数据集上是 0.96，在测试数据集上是 0.79，这意味着我们过度调整了超参数，模型严重过度拟合。我们需要规范这个模型。</p><p id="4d84" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">RandomForest 分类器有相当多的参数需要调整。如何记住需要调整哪些参数以减少过拟合的一个小提示是，您通常需要降低以<em class="ln"> max_ </em>开头的参数值，并增加以<em class="ln"> min_ 开头的参数值。</em>我将减少树的深度，增加最小样本分割。</p><figure class="nb nc nd ne gt nf"><div class="bz fp l di"><div class="nr ns l"/></div><p class="nm nn gj gh gi no np bd b be z dk translated">使用正则化估计器评估训练和测试数据集</p></figure><p id="08a4" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在，训练和测试数据集的 F1 分数看起来更好了。然而，仍有改进的余地。提高模型泛化能力的方法之一是使用<a class="ae lo" href="https://en.wikipedia.org/wiki/Principal_component_analysis" rel="noopener ugc nofollow" target="_blank">主成分分析</a> (PCA)，这已被证明是树模型的一个非常有效的数据转换步骤。由于树模型喜欢正交的决策边界，旋转数据集可能有助于构建一个不太复杂的树。在训练之前对数据集应用 PCA 通常会导致特征的更好的定向和模型的总体更好的概括能力。我们在训练基线模型之前不应用 PCA 的原因是 PCA 将特征转换成失去其可解释性的主要成分。然而，可解释性是基线模型的主要要求。</p><p id="5ac4" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在，让我们检查一些其他评估指标，以确保分类有意义。</p><figure class="nb nc nd ne gt nf"><div class="bz fp l di"><div class="nr ns l"/></div><p class="nm nn gj gh gi no np bd b be z dk translated">混淆矩阵</p></figure><p id="1a96" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">该模型正确分类了 66%的警官没有参与事故的情况和 81%的警官参与事故的情况。不出所料，少数类的查全率和查准率比多数类差。这可以通过增加数据集中负类样本的数量来改善，或者使用更高级的采样技术，如<a class="ae lo" href="https://bmcbioinformatics.biomedcentral.com/articles/10.1186/1471-2105-14-106" rel="noopener ugc nofollow" target="_blank"> SMOTE </a>。但是，请记住，使用 SMOTE 进行过采样的计算开销很大，可能需要在云环境中运行。</p><p id="798e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">让我们得到警察参与事故的概率，并检查基线模型的 ROC 曲线下的面积。</p><figure class="nb nc nd ne gt nf"><div class="bz fp l di"><div class="nr ns l"/></div><p class="nm nn gj gh gi no np bd b be z dk translated">AUC ROC 曲线我们的随机森林分类器与随机</p></figure><p id="017c" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">ROC 曲线下的面积为 0.83，这对于基线模型来说是相当不错的表现。</p><h1 id="988d" class="lp lq it bd lr ls lt lu lv lw lx ly lz ki ma kj mb kl mc km md ko me kp mf mg bi translated">特征重要性</h1><p id="d5bf" class="pw-post-body-paragraph kr ks it kt b ku mh kd kw kx mi kg kz la mj lc ld le mk lg lh li ml lk ll lm im bi translated">我谈了很多关于模型可解释性的重要性。在我们实际研究它之前，我想花点时间谈谈决策树模型中特征重要性的特征属性。决策树算法中衡量分裂质量的函数是基尼系数或熵。两者都旨在以一种获得的类样本尽可能纯净的方式分割树节点。因此，高基数分类特征以及连续特征具有很高的重要性，这仅仅是因为它们通过小而纯的类样本产生大量分裂。然而，由于我们的目标是了解每个特征对于做出分类决策的有用程度，我们需要使用另一种方法。一种方法是计算置换特征重要性。置换特征的重要性回答了这样一个问题:“如果我们随机置换一列数据，而将其他列留在原位，我们的模型的准确性会受到怎样的影响”。这听起来像是特性重要性的一个更有用的定义。</p><figure class="nb nc nd ne gt nf"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="e20e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">实现的分类器的特征重要性与探索性数据分析部分中提供的发现一致。<em class="ln"> Junction_Control、</em>Geo 变量和<em class="ln"> Ploice_Force </em>是具有最高鉴别能力的特征。从设计特征来看，最重要的是<em class="ln">周期</em>和<em class="ln">高峰时间</em>。通过引入新的地理相关变量或提高<em class="ln"> Junction_Control </em>变量的质量，我们可以将这些见解用于未来的特征工程。</p><h1 id="43da" class="lp lq it bd lr ls lt lu lv lw lx ly lz ki ma kj mb kl mc km md ko me kp mf mg bi translated">结论</h1><p id="7cf8" class="pw-post-body-paragraph kr ks it kt b ku mh kd kw kx mi kg kz la mj lc ld le mk lg lh li ml lk ll lm im bi translated">在这一部分中，我们看了好的基线模型的几个要求。然后，我们看到了如何利用定制转换器进行数据处理。训练了一个 RandomForest 分类器，我们看到了如何减少决策树模型的过度拟合。最后，我们计算了每个特征对于做出分类决策的重要性，并表明我们的模型做出的决策与之前执行的探索性数据分析一致。</p></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><div class="nb nc nd ne gt oa"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd jd gy z fp of fr fs og fu fw jc bi translated">编写面试问题</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">一个完整的平台，在这里我会教你找到下一份工作所需的一切，以及…</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">技术开发</p></div></div><div class="oj l"><div class="ok l ol om on oj oo nk oa"/></div></div></a></div></div></div>    
</body>
</html>