<html>
<head>
<title>Solving a Quadratic Problem (QP) in an open source linear solver</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在开源线性求解器中求解二次问题(QP)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/solving-a-quadratic-problem-qp-in-an-open-source-linear-solver-56ed6bb468e8?source=collection_archive---------37-----------------------#2020-04-27">https://towardsdatascience.com/solving-a-quadratic-problem-qp-in-an-open-source-linear-solver-56ed6bb468e8?source=collection_archive---------37-----------------------#2020-04-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b47e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何线性化二次函数以在线性解算器中使用它，(也就是说，我没有钱支付 Gurobi)使用零售示例</h2></div><p id="9481" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以，我上大学的时候用了很多花哨的优化软件(有学生许可证),比如 AMPL、CPLEX 和 Gurobi，我非常兴奋，因为“给我模型”和“我会解决它”。唯一的问题是，这些超级牛逼的解决方案是 f̶*̶ ̶e̶x̶p̶e̶n̶s̶i̶v̶e̶不便宜，许多小公司没有钱购买许可证，或者也许他们不愿意支付，除非他们看到的价值。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/d5637ebef3f92477e330275dadc94d18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HYIwGvO51orRoDCvSFquzg.jpeg"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">来源:<a class="ae lu" href="https://www.funny-memes.org/2014/01/in-terms-of-money-we-have-no-money.html" rel="noopener ugc nofollow" target="_blank">funny-memes.org</a>，转自:<a class="ae lu" href="https://www.pinterest.cl/pin/189432728053114696/" rel="noopener ugc nofollow" target="_blank">梅丽莎·伊莱亚斯</a></p></figure><p id="2c51" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以，像我一样，你发现有许多<a class="ae lu" href="https://en.wikipedia.org/wiki/List_of_optimization_software" rel="noopener ugc nofollow" target="_blank">开源线性解算器可用</a>，但是它们<a class="ae lu" href="https://www.gurobi.com/es/resource/switching-from-open-source/" rel="noopener ugc nofollow" target="_blank">没有你的学生授权的奇妙解算器</a>那么快和先进，当然，它们有局限性。我最怀念的一个功能是解决 QP 模型的能力。</p><p id="a8bf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，如果你正在寻找一种在开源线性求解器(比如<a class="ae lu" href="https://en.wikipedia.org/wiki/COIN-OR" rel="noopener ugc nofollow" target="_blank"> COIN-CBC </a>)中求解 QP 模型的方法，这篇文章可能适合你。</p><p id="b54a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">如果你熟悉什么是</strong> <a class="ae lu" href="https://en.wikipedia.org/wiki/Quadratic_programming" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> QP 车型</strong> </a> <strong class="kk iu">你可以跳过下一节</strong>。如果你想知道<em class="lv">我为什么要关心二次函数？</em> <strong class="kk iu"> <em class="lv"> </em> </strong>保持阅读。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="e736" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">我为什么要关心二次函数？</h1><p id="e280" class="pw-post-body-paragraph ki kj it kk b kl mv ju kn ko mw jx kq kr mx kt ku kv my kx ky kz mz lb lc ld im bi translated">(又名不应该是求解一个<strong class="kk iu"> <em class="lv">线性</em> </strong>模型？).我认为介绍 QP 模型重要性的最简单的方法是通过一个例子。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi na"><img src="../Images/55dbdb289acfc2c4ace62ca7437dad02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7E7B0XpQZ73E2PjW"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">由<a class="ae lu" href="https://unsplash.com/@burgessbadass?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">伯吉斯·米尔纳</a>在<a class="ae lu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="4886" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们假设你要计划一整季从仓库到零售店的 t 恤发货(姑且称之为<em class="lv"> i ∈ I </em> a 店和<em class="lv"> e{i，t} </em>在<em class="lv"> t(第 t 天)</em>期间到店的发货<em class="lv"> i </em>)。让我们想象一下，通过某种超级酷的机器学习算法，你对每个商店和时间段进行了预测(让我们称之为<em class="lv"> d{i，t} </em>需求预测<em class="lv"> i ∈ I，t ∈ T </em>)。</p><p id="ee67" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">比方说，在这个例子中，我们对 t 恤衫的需求激增(因为夏天),我们可能无法满足所有需求。如果我们为三家商店(1、2、4)绘制预测图，我们将得到:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi nb"><img src="../Images/9a12f825de38d2e43449053294880ca1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0wv7xf5lbUgI3dgQFQLl4Q.png"/></div></div></figure><p id="c834" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，让我们建立一个线性模型来最小化每个商店上的未履行订单(<em class="lv"> u{i，t} </em>)。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi nc"><img src="../Images/21de112817478d03baf56953ba763659.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i43i_nO-gYvBrwh6h5VRIA@2x.png"/></div></div></figure><p id="e32d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">好的，这里没有什么特别的，只是一个标准的线性模型。我们用 python 实现了我们最喜欢的线性建模库(<a class="ae lu" href="https://www.python-mip.com/" rel="noopener ugc nofollow" target="_blank"> python-mip </a> ❤️)</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nd ne l"/></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">完整代码在<a class="ae lu" href="https://github.com/pabloazurduy/qp-mip/blob/master/model.py" rel="noopener ugc nofollow" target="_blank">https://github.com/pabloazurduy/qp-mip</a></p></figure><p id="ad2f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有了模型结果，我们就可以按商店绘制未完成订单，只关注两家商店<em class="lv"> (1，4) </em>。在此图中，虚线表示已完成的订单，实线表示预测的需求，这两条线之间的差距就是未完成的数量。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi nf"><img src="../Images/e7b41a5072fc5c091f0c21206e13726d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tAuP7OpM6RhH5GvMMpM_iw.png"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">需求(实线)和满足的需求(虚线)之间的差距</p></figure><p id="c00a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以从上图中观察到一些有趣的事情:</p><ol class=""><li id="d7d2" class="ng nh it kk b kl km ko kp kr ni kv nj kz nk ld nl nm nn no bi translated">在第 20 天之后差距才开始出现。这意味着，在第一阶段，我可能能够完成所有订单，但在第二阶段(旺季)，我开始有大量未完成的订单。</li><li id="7831" class="ng nh it kk b kl np ko nq kr nr kv ns kz nt ld nl nm nn no bi translated"><strong class="kk iu">给定商店的未履行订单数量与实际数量相差甚远</strong>。如果我们关注商店 1(蓝线)，我们可以看到第 20 天我们有 0 个订单，第二天我们完成了所有订单，第三天又有 0 个订单。</li><li id="3e8f" class="ng nh it kk b kl np ko nq kr nr kv ns kz nt ld nl nm nn no bi translated"><strong class="kk iu">店铺间未成交订单数量也不一致</strong>。我们可以看到，在第 20 天到第 25 天之间，有些日子我们履行了商店 4 的所有订单，但没有履行商店 1 的任何订单，第二天情况正好相反。</li></ol><p id="24a3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们有一个问题… <strong class="kk iu">解决方案在商店之间不“公平”</strong>。如果我手动解决这个问题，并且只有 120 个单位在不同地点之间分配，我会“更平均地”分割它们，因为我知道我将有未完成的订单。但是，至少我会在每家商店实现 60%的<a class="ae lu" href="https://en.wikipedia.org/wiki/Service_level#.CE.B2_service_level_.28type_2.2C_also_known_as_.22fill_rate.22.29" rel="noopener ugc nofollow" target="_blank">填充率</a>，而不是让一些商店 100%填充率，另一些商店 0%填充率，保持更好的跨商店服务水平。</p><p id="0c9d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个问题从何而来？问题是我们的模型只关心<strong class="kk iu">未履行订单总量</strong> (min ∑ u{i，t})因此对于模型来说相当于一家店有 100 个未履行订单，另一家店有 0 个，或者每家店有 50 个未履行订单，因为成本是相同的(100 个单位)。那么我们如何解决这个问题呢？U <strong class="kk iu">唱一个二次函数。</strong></p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/35c42a7b4783d5e9b70011007b16ae13.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*h5ZUQd84AD7OeoCxcizSmg@2x.png"/></div></figure><p id="7e3a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，有了<em class="lv">“二次惩罚”</em>，成本在商店和期间之间不是线性的，因此，最好有一个更平均分布的未完成订单数(100 + 0 &gt; 50 + 50)。这是二次函数最常见的应用之一。那么，<em class="lv">我们如何在线性求解器中实现它呢？</em></p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="968b" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">(二次函数的)线性化问题</h1><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/345252b71b187f11863d8acaa3d28172.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*PPv3_NfsSyaC0NKaTVMpnQ.jpeg"/></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">来源:<a class="ae lu" href="https://makeameme.org/meme/BEWARE--math" rel="noopener ugc nofollow" target="_blank">makeameme.org</a></p></figure><p id="f60a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">解决 QP 模型有许多可能的解决方案，但是我们将实现可能是最简单的一个，继续使用我们的线性解算器，线性化。如果我们绘制二次函数，我们将得到类似左图的结果:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi nw"><img src="../Images/44755295af0634b43a2edc1ae99727d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nHng2b9z5HCoGWGtIUkBQA.png"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">线性化概念图</p></figure><p id="217b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们要做的是将这条曲线变换成一系列(<em class="lv"> k </em>)线，这些线可以是原始曲线的近似。我们只对近似值<em class="lv"> x </em>的一定精度感兴趣，因此我们可以在域的边界之间选择有限数量的点(<em class="lv"> x{k} </em>点)。更多的点将导致原始函数的更好的近似。那些点<em class="lv"> x{k} </em>被称为<a class="ae lu" href="https://en.wikipedia.org/wiki/Linearization#Uses_of_linearization" rel="noopener ugc nofollow" target="_blank">兴趣点</a>。使用<a class="ae lu" href="https://en.wikipedia.org/wiki/Taylor_series" rel="noopener ugc nofollow" target="_blank">泰勒展开式</a>的第一项，我们将找到每个感兴趣点的线性化。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi nx"><img src="../Images/02913549e5265ed08c7ba6c681d0d856.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JTiY0RTVEJByxaCnehvAcg@2x.png"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">线的定义(L=ax+b)</p></figure><p id="a180" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了说明这一点，我们假设我们有 6 个兴趣点。绘制原始曲线和六条线，我们得到下图:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi ny"><img src="../Images/dcf06dc50b486fc86c3d6cd180ff9e26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ohLEVeAsGsaPSQpI"/></div></div></figure><p id="98f7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以观察到，我们添加的点越多，近似结果就越精确。但是，正如我们将很快观察到的，更多的行将增加模型的复杂性。</p><h2 id="941b" class="nz me it bd mf oa ob dn mj oc od dp mn kr oe of mp kv og oh mr kz oi oj mt ok bi translated">将此线性化添加到线性模型中</h2><p id="708b" class="pw-post-body-paragraph ki kj it kk b kl mv ju kn ko mw jx kq kr mx kt ku kv my kx ky kz mz lb lc ld im bi translated">我们可以利用<em class="lv"> x </em>函数是<a class="ae lu" href="https://en.wikipedia.org/wiki/Convex_function" rel="noopener ugc nofollow" target="_blank">凸</a>的事实。有了那个性质，我们可以假设所有的线<em class="lv"> L(x) </em>总是<em class="lv"> f(x) </em>的一个“下盖”。记住这一点，我们可以使用 max 函数得到曲线~f(x)的离散近似，因为是所有直线的最大值(<em class="lv"> L(x) </em>)。因此使用一个<a class="ae lu" href="https://math.stackexchange.com/questions/2446606/linear-programming-set-a-variable-the-max-between-two-another-variables/3568461#3568461" rel="noopener ugc nofollow" target="_blank">已知编码</a>我们可以将其添加到模型中</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi ol"><img src="../Images/af2c01185d5e5bffbd19420b5b819b45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VAKfStZI7hmPWjgaWFuB3A.png"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">线性化的编码</p></figure><p id="7b82" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以看到，对于我们添加到线性化中的每个离散点，我们也向模型添加了一个新的二元变量(<em class="lv"> bk </em>)，因此，<strong class="kk iu"> <em class="lv">更精细的近似将导致更高的执行时间。</em>T29】</strong></p><h2 id="ec8e" class="nz me it bd mf oa ob dn mj oc od dp mn kr oe of mp kv og oh mr kz oi oj mt ok bi translated">Python 实现</h2><p id="0271" class="pw-post-body-paragraph ki kj it kk b kl mv ju kn ko mw jx kq kr mx kt ku kv my kx ky kz mz lb lc ld im bi translated">我构建了一个助手，它可以将我们从这种近似中抽象出来:</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nd ne l"/></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">完整代码在<a class="ae lu" href="https://github.com/pabloazurduy/qp-mip/blob/master/model.py" rel="noopener ugc nofollow" target="_blank">https://github.com/pabloazurduy/qp-mip</a></p></figure><p id="b4a9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以简单地将它添加到我们之前的模型实现中</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="aa55" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们运行它，看看新的结果:</p><pre class="lf lg lh li gt om on oo op aw oq bi"><span id="b2c9" class="nz me it on b gy or os l ot ou">OptimizationStatus.FEASIBLE<br/>Objective value: 23390.00000000<br/>Lower bound: 18454.285<br/>Gap: 0.27<br/>Enumerated nodes: 35926<br/>Total iterations: 7133610<br/>Time (CPU seconds): 1939.06<br/>Time (Wallclock seconds): 2001.06</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi nf"><img src="../Images/b79a55f514f2ffee66ac280d1b3abad4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6Qmf6LNhMuVerNhjbmt83g.png"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">需求(实线)和满足需求(虚线)之间的差距，二次模型</p></figure><p id="3750" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以从情节中观察到一些有趣的东西</p><ol class=""><li id="6a4c" class="ng nh it kk b kl km ko kp kr ni kv nj kz nk ld nl nm nn no bi translated"><strong class="kk iu">门店日间未完成订单数比较稳定</strong>:我们可以观察到，旺季没有缺货的日子，第二天也没有积压的日子。即使是库存较少的商店(如 4 号店)，我们也看到我们总是完成一定数量的订单。</li><li id="6d8e" class="ng nh it kk b kl np ko nq kr nr kv ns kz nt ld nl nm nn no bi translated"><strong class="kk iu">门店间未完成订单数量更加一致</strong>。我们可以看到，差距的数量也得到更好的分配，特别是在这一时期结束时。我们注意到，在第一个周期中，商店 4 比商店 1 有更多的短缺，这是因为实例中还有其他商店(总共 5 个)，这也可能是由于离散化点的数量少造成的，如果间隙更小，函数是常数。</li><li id="b88f" class="ng nh it kk b kl np ko nq kr nr kv ns kz nt ld nl nm nn no bi translated"><strong class="kk iu">该解决方案在各门店间的服务水平较高。</strong>该解决方案不仅提高了客户体验，因为店与店之间以及不同日子同一店内的可靠性更高。</li></ol><p id="c6e1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们找到了。现在，我们可以看到，结果更加一致。按店铺/天计算，使用 5 个兴趣点的时间会稍微长一点，但是，如果我们要在一个季度内解决一次这个问题，那也没什么大不了的</p><p id="6da5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">感谢您的阅读！！</strong>，这是我写的第一篇文章，所以请随意给我任何反馈。A <strong class="kk iu">本项目所有源代码均可用</strong> <a class="ae lu" href="https://github.com/pabloazurduy/qp-mip" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">此处为</strong> </a>，任何问题请留在回购中。</p></div></div>    
</body>
</html>