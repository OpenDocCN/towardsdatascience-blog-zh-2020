<html>
<head>
<title>How to extract Review Classifier model to reuse for real time classification</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何提取评论分类器模型以重用于实时分类</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-deploy-a-review-classifier-in-any-application-c1c0e5a0e8ff?source=collection_archive---------25-----------------------#2020-01-20">https://towardsdatascience.com/how-to-deploy-a-review-classifier-in-any-application-c1c0e5a0e8ff?source=collection_archive---------25-----------------------#2020-01-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="da51" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使分类器可重用简介</h2></div><p id="b171" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有很多教程和例子都是关于用大部分可用数据集训练一个评论分类器，并用剩余部分测试它，看看它的表现如何。</p><p id="8497" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">很高兴看到如何建立一个分类器，以及它是如何执行的，但是我们如何导出这个分类器，并在任何应用程序中安装、运行，以便我们可以进行实时检查分类呢？</p><p id="16d8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本帖中，首先我们将利用欧洲515，000条酒店评论数据构建一个评论分类器，并对其进行一些领域调整，使其更加通用，而不是针对特定酒店，然后<strong class="kk iu">我们将导出带有特征索引的分类器，以应用于我们选择的任何应用程序。</strong></p><blockquote class="le lf lg"><p id="9544" class="ki kj lh kk b kl km ju kn ko kp jx kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">如果你只对我们如何在其他应用程序中提取和应用分类器感兴趣，你可以去我们有一个分类器，现在做什么？部分。</p></blockquote><p id="ae49" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">点击这里下载数据集<a class="ae ll" href="https://www.kaggle.com/jiashenliu/515k-hotel-reviews-data-in-europe" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="3c1b" class="lm ln it bd lo lp lq dn lr ls lt dp lu kr lv lw lx kv ly lz ma kz mb mc md me bi translated">酒店数据集调查</h2><p id="bee8" class="pw-post-body-paragraph ki kj it kk b kl mf ju kn ko mg jx kq kr mh kt ku kv mi kx ky kz mj lb lc ld im bi translated">我们这里有一个庞大的酒店数据集，它有许多功能，酒店地址，评论日期，平均分数，正面评论，负面评论等等。数据集中的每个条目都来自一个特定酒店的用户。每个用户都被要求对他们住过的酒店提供正面和负面的评价。值得一提的是，在某些情况下，用户只能选择其中之一。当用户未分别提供正面和负面评价时，我们会看到以下特征值:</p><ul class=""><li id="2b22" class="mk ml it kk b kl km ko kp kr mm kv mn kz mo ld mp mq mr ms bi translated">没有阳性</li><li id="c6b1" class="mk ml it kk b kl mt ko mu kr mv kv mw kz mx ld mp mq mr ms bi translated">没有负面影响</li></ul><p id="998a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章中，我们将只关注正面评论和负面评论，而不管哪个用户写了哪个酒店。</p><h1 id="ec80" class="my ln it bd lo mz na nb lr nc nd ne lu jz nf ka lx kc ng kd ma kf nh kg md ni bi translated">预处理</h1><p id="f5ea" class="pw-post-body-paragraph ki kj it kk b kl mf ju kn ko mg jx kq kr mh kt ku kv mi kx ky kz mj lb lc ld im bi translated">我们需要对数据集做一些预处理。首先，我们将创建一个新的数据集，只获取1%的原始数据集的正面和负面评论。(在本文中，我们将只使用5K个数据条目，但是您可以稍后尝试使用整个数据集进行构建)。然后，我们将清除遗漏的评论(无负面、正面、无等等)。</p><h2 id="f2a2" class="lm ln it bd lo lp lq dn lr ls lt dp lu kr lv lw lx kv ly lz ma kz mb mc md me bi translated">删除空洞和无价的评论</h2><p id="0b6c" class="pw-post-body-paragraph ki kj it kk b kl mf ju kn ko mg jx kq kr mh kt ku kv mi kx ky kz mj lb lc ld im bi translated">让我们为项目创建一个文件夹，在该文件夹中找到数据集，然后创建一个新的python文件进行预处理。我把它命名为hotel_review_pre_processor。</p><p id="40c8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我们将导入pandas和numpy，然后加载原始数据集的1%。</p><pre class="nj nk nl nm gt nn no np nq aw nr bi"><span id="edc5" class="lm ln it no b gy ns nt l nu nv">import pandas as pd<br/>import numpy as np</span><span id="bbbc" class="lm ln it no b gy nw nt l nu nv"># load data<br/>reviews_df = pd.read_csv("Hotel_Reviews.csv")</span><span id="87c5" class="lm ln it no b gy nw nt l nu nv">#only get 1 percent of data. because the data is huge<br/>reviews_df = reviews_df.sample(frac = 0.01, replace = False, random_state=42)</span></pre><p id="17d9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，让我们创建一个新的空数据框架，其中包含点评和is_positive特征，稍后我们将使用酒店数据集中的点评填充这些特征。</p><pre class="nj nk nl nm gt nn no np nq aw nr bi"><span id="b8f2" class="lm ln it no b gy ns nt l nu nv">df = pd.DataFrame(columns=('review', 'is_positive'))</span></pre><p id="8dbe" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，我们将用空字符串替换数据集中的非正值和非负值，然后用NaN替换它们，最后删除它们:</p><pre class="nj nk nl nm gt nn no np nq aw nr bi"><span id="7412" class="lm ln it no b gy ns nt l nu nv">#replace missing review info with empty strings<br/>reviews_df = reviews_df.replace(['No Negative', 'No Positive'], ['', ''])</span><span id="ba08" class="lm ln it no b gy nw nt l nu nv">#replace empty strings with NaN value (null) and then drop them.<br/>reviews_df = reviews_df.replace(r'^\s*$', np.nan, regex=True)<br/>reviews_df = reviews_df.dropna()</span></pre><p id="eead" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们将执行以下操作:</p><ul class=""><li id="dcb7" class="mk ml it kk b kl km ko kp kr mm kv mn kz mo ld mp mq mr ms bi translated">仅从数据集中获取负面评论和正面评论列。</li><li id="010d" class="mk ml it kk b kl mt ko mu kr mv kv mw kz mx ld mp mq mr ms bi translated">为它们中的每一个创建单独的数据框</li><li id="f930" class="mk ml it kk b kl mt ko mu kr mv kv mw kz mx ld mp mq mr ms bi translated">对于每个数据框中的每个条目，使用review和相应的is_positive值(0表示负面评论，1表示正面评论)向我们的新数据框(df)添加一个新条目。</li><li id="c303" class="mk ml it kk b kl mt ko mu kr mv kv mw kz mx ld mp mq mr ms bi translated">然后，我们会将新的数据框保存为reviews.csv。</li></ul><pre class="nj nk nl nm gt nn no np nq aw nr bi"><span id="46b4" class="lm ln it no b gy ns nt l nu nv">#only get reviews.<br/>reviews_df = reviews_df[["Negative_Review", "Positive_Review"]]</span><span id="43cb" class="lm ln it no b gy nw nt l nu nv">#separate them<br/>negative_reviews_df = reviews_df[["Negative_Review"]]<br/>positive_reviews_df = reviews_df[["Positive_Review"]]</span><span id="0ff5" class="lm ln it no b gy nw nt l nu nv">#add all negative and positive reviews with related label 'is_positive' 0 for negative, 1 for positive.<br/>for index, row in negative_reviews_df.iterrows():<br/>    if "nothing" in row["Negative_Review"]:<br/>        pass<br/>    elif "Nothing" in row["Negative_Review"]:<br/>        pass<br/>    else:<br/>        df = df.append({'review': row["Negative_Review"], 'is_positive': 0}, ignore_index=True)</span><span id="b275" class="lm ln it no b gy nw nt l nu nv">for index, row in positive_reviews_df.iterrows():<br/>    if "nothing" in row["Positive_Review"]:<br/>        pass<br/>    elif "Nothing" in row["Positive_Review"]:<br/>        pass<br/>    else:<br/>        df = df.append({'review': row["Positive_Review"], 'is_positive': 1}, ignore_index=True)</span><span id="b3a0" class="lm ln it no b gy nw nt l nu nv">#save the cleaned data as reviews.csv<br/>endResult = df.to_csv('reviews.csv',index=False)</span></pre><p id="3cd4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们完成了预处理。我们将酒店数据集中的评论放入一个名为reviews.csv的新数据集中，该数据集中有review和is_positive功能。现在我们应该有大约6500条评论可供我们分析。正如我前面提到的，通过在下面一行中更改frac参数，您可以增加或减少您使用的数据集部分:</p><pre class="nj nk nl nm gt nn no np nq aw nr bi"><span id="ae90" class="lm ln it no b gy ns nt l nu nv">reviews_df = reviews_df.sample(frac = 0.01, replace = False, random_state=42)</span></pre><h2 id="4ecf" class="lm ln it bd lo lp lq dn lr ls lt dp lu kr lv lw lx kv ly lz ma kz mb mc md me bi translated">使评论更加通用</h2><p id="65af" class="pw-post-body-paragraph ki kj it kk b kl mf ju kn ko mg jx kq kr mh kt ku kv mi kx ky kz mj lb lc ld im bi translated">现在我们已经处理了这些评论，并将它们重构为一个新的数据集，其中包含了我们感兴趣的特性，但是我们仍然有一个问题。由于原始数据集来自酒店评论，它们很可能包含酒店行业特有的词，如:酒店、床、淋浴、早餐等。如果我们想让我们的分类器以后变得通用，我们需要去掉这样的词。</p><p id="f1d1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是首先，我们将去掉停用词(没有任何上下文含义的词，如:for、the、a、or、what和etc ),然后对评论中现有的词进行词干处理以删除重复的词。作为一个例子，当词干分析应用于下面的任何一个单词时，它们都将导致<strong class="kk iu">运行</strong>。</p><ul class=""><li id="27ac" class="mk ml it kk b kl km ko kp kr mm kv mn kz mo ld mp mq mr ms bi translated">(跑步，跑步，跑步)-&gt;跑步</li></ul><p id="6138" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">继续创建一个名为review_cleaner.py的文件。</p><p id="812f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将把它创建为一个单独的类，因为我们稍后将从多个文件中再次需要这个方法:</p><pre class="nj nk nl nm gt nn no np nq aw nr bi"><span id="1d00" class="lm ln it no b gy ns nt l nu nv">import nltk<br/>from nltk.corpus import stopwords<br/>from nltk.stem.porter import PorterStemmer</span><span id="ffbd" class="lm ln it no b gy nw nt l nu nv">class ReviewCleaner:<br/>    <a class="ae ll" href="http://twitter.com/staticmethod" rel="noopener ugc nofollow" target="_blank">@staticmethod</a><br/>    def clean_review(review):<br/>        review = review.lower()<br/>        review = review.split()</span><span id="0da2" class="lm ln it no b gy nw nt l nu nv">        ps = PorterStemmer()</span><span id="e6ee" class="lm ln it no b gy nw nt l nu nv">        review = [ps.stem(word) for word in review<br/>                    if not word in set(stopwords.words('english'))]</span><span id="d7b0" class="lm ln it no b gy nw nt l nu nv">        review = ' '.join(review)</span><span id="c9f2" class="lm ln it no b gy nw nt l nu nv">        return review</span></pre><p id="a9ea" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该方法将如下工作:</p><ul class=""><li id="49be" class="mk ml it kk b kl km ko kp kr mm kv mn kz mo ld mp mq mr ms bi translated">接受名为review的字符串参数</li><li id="9701" class="mk ml it kk b kl mt ko mu kr mv kv mw kz mx ld mp mq mr ms bi translated">降低所有字符并拆分单词</li><li id="fd24" class="mk ml it kk b kl mt ko mu kr mv kv mw kz mx ld mp mq mr ms bi translated">对每个单词应用词干并删除任何停用词(如果存在)。</li><li id="11a7" class="mk ml it kk b kl mt ko mu kr mv kv mw kz mx ld mp mq mr ms bi translated">用带词干的单词创建一个名为review的新字符串并返回它</li></ul><blockquote class="le lf lg"><p id="5d82" class="ki kj lh kk b kl km ju kn ko kp jx kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">如果您曾经得到以下错误:“资源停用词没有找到”，即使您有nltk库。打开终端并执行以下命令:</p><p id="075f" class="ki kj lh kk b kl km ju kn ko kp jx kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">- python3</p><p id="3a39" class="ki kj lh kk b kl km ju kn ko kp jx kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">-导入nltk</p><p id="af7e" class="ki kj lh kk b kl km ju kn ko kp jx kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">- nltk.download('停用字词')</p><p id="b61d" class="ki kj lh kk b kl km ju kn ko kp jx kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">-这应该可以修复错误。</p></blockquote><p id="6573" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，让我们创建一个名为review _ generifier.py的文件，并添加以下代码块:</p><pre class="nj nk nl nm gt nn no np nq aw nr bi"><span id="d00b" class="lm ln it no b gy ns nt l nu nv">import pandas as pd<br/>import numpy as np<br/>from collections import Counter<br/>from review_cleaner import ReviewCleaner as rc</span><span id="8813" class="lm ln it no b gy nw nt l nu nv">reviews_df = pd.read_csv("reviews.csv")</span><span id="7ef2" class="lm ln it no b gy nw nt l nu nv">for index, row in reviews_df.iterrows():<br/>    cleared_review = rc.clean_review(row['review'])<br/>    reviews_df.at[index, 'review'] = cleared_review</span><span id="3ea8" class="lm ln it no b gy nw nt l nu nv">most_common_100_words = Counter(" ".join(reviews_df["review"]).split()).most_common(100)</span><span id="2a06" class="lm ln it no b gy nw nt l nu nv">print(most_common_100_words)</span></pre><blockquote class="le lf lg"><p id="bf2f" class="ki kj lh kk b kl km ju kn ko kp jx kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">请注意，根据您的机器，对数据集中的每个数据条目应用清除需要一段时间。</p></blockquote><p id="d3e1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里，我们将ReviewCleaner类中的clean_review方法应用于数据集中可用的每个评论。然后我们打印出出现次数最多的100个单词以及出现次数。(为简单起见，仅显示了20个):</p><pre class="nj nk nl nm gt nn no np nq aw nr bi"><span id="1a73" class="lm ln it no b gy ns nt l nu nv">[('room', 3067), ('staff', 1697), ('locat', 1596), ('hotel', 1499), ('breakfast', 1171), ('good', 1057), ('bed', 831), ('great', 771), ('help', 665), ('clean', 658), ('nice', 637), ('friendli', 636), ('comfort', 540), ('small', 513), ('stay', 478), ('excel', 469), ('bathroom', 393), ('love', 384), ('would', 382), ('could', 358)]</span></pre><p id="8e23" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如你所见，有这样的词；房间、员工、酒店、早餐等(你可以在整个打印列表上看到更多)都是酒店行业特有的。如果我们想使它通用，我们不希望这样的词被输入到我们的分类器中。因此，我们现在要删除这些词。</p><p id="540a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，让我们创建一个要从评论中删除的单词列表:</p><pre class="nj nk nl nm gt nn no np nq aw nr bi"><span id="fccf" class="lm ln it no b gy ns nt l nu nv">unwanted_words = ['room', 'staff', 'locat', 'hotel', 'breakfast', 'bed', 'shower']</span></pre><blockquote class="le lf lg"><p id="f982" class="ki kj lh kk b kl km ju kn ko kp jx kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">您还可以/应该尝试删除其他单词，看看它是否会影响您的分类器的准确性。</p></blockquote><p id="13f4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们需要导入<strong class="kk iu"> re </strong>来删除不需要的单词。使用其他导入在文件顶部导入re，如下所示:</p><pre class="nj nk nl nm gt nn no np nq aw nr bi"><span id="3811" class="lm ln it no b gy ns nt l nu nv">import re</span></pre><p id="9507" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，让我们从数据框中删除不需要的单词，如下所示:</p><pre class="nj nk nl nm gt nn no np nq aw nr bi"><span id="a39e" class="lm ln it no b gy ns nt l nu nv">reviews_df['review'] = reviews_df['review'].str.replace('|'.join(map(re.escape, unwanted_words)), '')</span></pre><p id="7918" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以获取常用单词并在更新数据框后再次打印它们，您应该会看到在wanted_words中声明的单词现在已经消失了。</p><p id="8a0a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，我们将把更新后的数据集保存为<strong class="kk iu"> cleared_reviews.csv </strong>，并在末尾添加以下代码:</p><pre class="nj nk nl nm gt nn no np nq aw nr bi"><span id="b2e0" class="lm ln it no b gy ns nt l nu nv">#save the cleaned data as cleared_reviews.csv<br/>endResult = reviews_df.to_csv('cleared_reviews.csv')</span></pre><p id="c465" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从现在开始，我们将使用cleared_reviews.csv数据集:)</p><h1 id="63a0" class="my ln it bd lo mz na nb lr nc nd ne lu jz nf ka lx kc ng kd ma kf nh kg md ni bi translated">用随机森林分类器训练评论分类器</h1><p id="7b02" class="pw-post-body-paragraph ki kj it kk b kl mf ju kn ko mg jx kq kr mh kt ku kv mi kx ky kz mj lb lc ld im bi translated">现在我们有了通用数据集，我们可以训练一个随机森林分类器(RFC)<a class="ae ll" rel="noopener" target="_blank" href="/understanding-random-forest-58381e0602d2">【1】</a>模型作为我们的通用分类器。(请注意，审查分类器可以用许多不同的方法实现，我只想用RFC)。</p><p id="6552" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，让我们创建一个新文件rf_classifier_training.py，并添加以下代码:</p><pre class="nj nk nl nm gt nn no np nq aw nr bi"><span id="ffbe" class="lm ln it no b gy ns nt l nu nv">import pandas as pd<br/>import numpy as np<br/>import pickle<br/>import json</span><span id="69fb" class="lm ln it no b gy nw nt l nu nv">dataset = pd.read_csv('cleared_reviews.csv')</span><span id="08ec" class="lm ln it no b gy nw nt l nu nv">from sklearn.feature_extraction.text import CountVectorizer<br/>cv = CountVectorizer(max_features = 1500)<br/>X = cv.fit_transform(dataset["review"].values.astype('U')).toarray()<br/>y = dataset["is_positive"]</span><span id="df70" class="lm ln it no b gy nw nt l nu nv">from sklearn.model_selection import train_test_split</span><span id="5e74" class="lm ln it no b gy nw nt l nu nv">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.25)</span><span id="4695" class="lm ln it no b gy nw nt l nu nv">from sklearn.ensemble import RandomForestClassifier</span><span id="7250" class="lm ln it no b gy nw nt l nu nv">model = RandomForestClassifier(n_estimators = 501,<br/>                            criterion = 'entropy')</span><span id="4d84" class="lm ln it no b gy nw nt l nu nv">model.fit(X_train, y_train)<br/>y_pred = model.predict(X_test)</span><span id="1a70" class="lm ln it no b gy nw nt l nu nv">print('Score: ', model.score(X_test, y_test))</span></pre><p id="142e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里我们训练一个分类器如下:</p><ul class=""><li id="e99e" class="mk ml it kk b kl km ko kp kr mm kv mn kz mo ld mp mq mr ms bi translated">初始化CountVectorizer以从我们的评论中获取1500个特征，这里每个特征对应一个词(它选择数据集中出现最多的1500个词)。</li><li id="2172" class="mk ml it kk b kl mt ko mu kr mv kv mw kz mx ld mp mq mr ms bi translated">将数据集拆分为75%和25%，分别用于定型和预测。</li><li id="5609" class="mk ml it kk b kl mt ko mu kr mv kv mw kz mx ld mp mq mr ms bi translated">创建一个RFC模型，包含n个估计量和标准参数(不同的参数值可以提高性能，如果你愿意可以试试)</li><li id="2177" class="mk ml it kk b kl mt ko mu kr mv kv mw kz mx ld mp mq mr ms bi translated">训练模型，然后根据测试数据进行预测</li><li id="7a85" class="mk ml it kk b kl mt ko mu kr mv kv mw kz mx ld mp mq mr ms bi translated">最后打印出分类得分的分数。</li></ul><p id="7bd0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">打印分数应该在0.90左右，这意味着每10篇评论中，有9篇被成功归类为当前标签(正面或负面)。我认为这对RFC来说是相当好的，因为我们没有试图优化它的参数。</p><h1 id="6263" class="my ln it bd lo mz na nb lr nc nd ne lu jz nf ka lx kc ng kd ma kf nh kg md ni bi translated">我们有了一个分类器，现在怎么办？</h1><p id="fc9a" class="pw-post-body-paragraph ki kj it kk b kl mf ju kn ko mg jx kq kr mh kt ku kv mi kx ky kz mj lb lc ld im bi translated">现在我们有了一个分类器，可以将评论分为正面或负面。但是我们如何提取它，以便在应用程序中对新数据进行分类呢？</p><p id="1cd2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为此，我们需要保存我们的模型。但这还不够。因为如果我们对特征(单词)一无所知，我们如何将新数据放入这个模型。更具体地说，我们不知道哪个词在特征空间中有什么索引。因此，我们还将为每个单词找到特征索引，并分别保存它们。</p><p id="527d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在rf_classifier_training.py中打印分数后，立即添加以下代码:</p><pre class="nj nk nl nm gt nn no np nq aw nr bi"><span id="3c72" class="lm ln it no b gy ns nt l nu nv">words = cv.vocabulary_<br/>words_for_json = {}</span><span id="5eeb" class="lm ln it no b gy nw nt l nu nv">for k, v in words.items():<br/>    words_for_json[k] = int(v)</span><span id="01a3" class="lm ln it no b gy nw nt l nu nv">pickle.dump(model, open('reviewClassifier.pkl','wb'))<br/>with open('word_feature_space.json', 'w') as fp:<br/>    json.dump(words_for_json, fp)</span></pre><p id="facf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">[word: index]字典保存为word_feature_space.json下的json键值，分类器模型保存为reviewClassifier.pkl。</p><p id="de97" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在再次运行rf_classifier_training.py来保存json和pkl文件。</p><blockquote class="le lf lg"><p id="cfa7" class="ki kj lh kk b kl km ju kn ko kp jx kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">这些文件不会包含在github repo中，因为模型的大小大约为100 Mb。所以你必须运行rf_classifier_training.py来获取这些文件。</p></blockquote><h2 id="00d9" class="lm ln it bd lo lp lq dn lr ls lt dp lu kr lv lw lx kv ly lz ma kz mb mc md me bi translated">编写可以在任何应用程序中使用的分类器服务</h2><p id="2247" class="pw-post-body-paragraph ki kj it kk b kl mf ju kn ko mg jx kq kr mh kt ku kv mi kx ky kz mj lb lc ld im bi translated">现在我们有了模型和json，我们可以编写一个服务来为任何给定的文本提供分类。</p><p id="45e3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的服务如下:</p><ul class=""><li id="75e0" class="mk ml it kk b kl km ko kp kr mm kv mn kz mo ld mp mq mr ms bi translated">清理收到的审核</li><li id="64c5" class="mk ml it kk b kl mt ko mu kr mv kv mw kz mx ld mp mq mr ms bi translated">用收到的评论创建一个向量</li><li id="2bfc" class="mk ml it kk b kl mt ko mu kr mv kv mw kz mx ld mp mq mr ms bi translated">将这个向量拟合到模型中并进行预测</li><li id="05f0" class="mk ml it kk b kl mt ko mu kr mv kv mw kz mx ld mp mq mr ms bi translated">以二进制形式返回预测值(0 =负，1 =正)</li></ul><p id="873a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们创建review_classifier_service.py，如下所示:</p><figure class="nj nk nl nm gt nx"><div class="bz fp l di"><div class="ny nz l"/></div><p class="oa ob gj gh gi oc od bd b be z dk translated">ReviewClassifierService</p></figure><p id="2540" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">值得从评论中给出关于向量创建的更多细节，我们检查评论中的每个词，如果它存在于我们的词空间(word_feature_space.json)中，我们将它添加到向量空间并增加字数，但是如果它不存在，我们就简单地丢弃它。</p><h2 id="bdfd" class="lm ln it bd lo lp lq dn lr ls lt dp lu kr lv lw lx kv ly lz ma kz mb mc md me bi translated">请求</h2><p id="268c" class="pw-post-body-paragraph ki kj it kk b kl mf ju kn ko mg jx kq kr mh kt ku kv mi kx ky kz mj lb lc ld im bi translated">现在，我们将向服务发出一个示例请求，以查看我们的分类器如何处理新数据，让我们创建example_request.py:</p><pre class="nj nk nl nm gt nn no np nq aw nr bi"><span id="3976" class="lm ln it no b gy ns nt l nu nv">from review_classifier_service import ReviewClassifierService</span><span id="8257" class="lm ln it no b gy nw nt l nu nv">service = ReviewClassifierService()</span><span id="56f6" class="lm ln it no b gy nw nt l nu nv">positive_sample = "It was great"<br/>negative_sample = "It was horrible"<br/>print(service.classify(positive_sample))<br/>print(service.classify(negative_sample))</span></pre><p id="600f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">输出是:</p><pre class="nj nk nl nm gt nn no np nq aw nr bi"><span id="a9b2" class="lm ln it no b gy ns nt l nu nv">{"outcome": 1}<br/>{"outcome": 0}</span></pre><p id="1b2f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如您所见，我们的分类器服务可以提供一个json响应，值1表示肯定，值0表示否定。为了简单起见，我在这里没有尝试不同的评论，但是它应该工作得很好，除非你提供一个棘手的评论(一个有许多正面和负面单词的评论=D)。请继续尝试不同的评论。</p><h1 id="7a46" class="my ln it bd lo mz na nb lr nc nd ne lu jz nf ka lx kc ng kd ma kf nh kg md ni bi translated">结论</h1><p id="ad69" class="pw-post-body-paragraph ki kj it kk b kl mf ju kn ko mg jx kq kr mh kt ku kv mi kx ky kz mj lb lc ld im bi translated">在本文中，我们看到了如何处理数据以使其有用，如何使数据集更通用，如何构建评论分类器，更重要的是，如何提取该分类器模型并使其能够应用于我们想要的任何应用程序。您可以使用这些或类似的方法来获得您的分类器，然后将它们部署在您的后端，并为许多应用程序和客户端提供服务。</p><p id="3a33" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以在这里找到完整的存储库<a class="ae ll" href="https://github.com/emrepun/PunReviewClassifier" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="1946" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">保重:)</p></div></div>    
</body>
</html>