<html>
<head>
<title>Underrated Machine Learning Algorithms — APRIORI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">被低估的机器学习算法——APRIORI</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/underrated-machine-learning-algorithms-apriori-1b1d7a8b7bc?source=collection_archive---------3-----------------------#2020-01-28">https://towardsdatascience.com/underrated-machine-learning-algorithms-apriori-1b1d7a8b7bc?source=collection_archive---------3-----------------------#2020-01-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3205" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Python从头开始构建分步模块</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1b8aeabe04d1c0802da7068efdd732f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uju7aWZpiiqS3wDsz8kxJQ.jpeg"/></div></div></figure><h1 id="fa8c" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">先验导论</h1><p id="025d" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">Apriori是一种用于关联规则挖掘的算法。它在数据集中搜索一系列频繁出现的项目集。它建立在项目集之间的关联和相关性上。这是你在推荐平台上常见的“你可能也会喜欢”背后的算法。</p><h1 id="1fc2" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">什么是关联规则挖掘？</h1><p id="0cc2" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">关联规则挖掘是数据科学中的重要技术之一。在ARM中，在项目集中识别数据集中模式和关联的频率，然后用于预测集合中的下一个相关项目。这种ARM技术主要用于根据客户购买情况做出商业决策。</p><p id="e5e5" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">例如:在沃尔玛，如果Ashok购买牛奶和面包，他购买黄油的机会是通过关联规则挖掘技术预测的。</p><blockquote class="mn mo mp"><p id="95f6" class="lm ln mq lo b lp mi ju lr ls mj jx lu mr mk lx ly ms ml mb mc mt mm mf mg mh im bi translated">在本模块中，我们将在给定的数据集上从头开始构建一个apriori算法，并将其用作客户购买的推荐系统。</p></blockquote><h1 id="17b3" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">有些定义需要记住</h1><p id="8f67" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在我们开始之前，先看一下下面解释的一些术语。</p><p id="0b38" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">SUPPORT _ COUNT项目集出现的事务数。</p><p id="9c84" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">MINIMUM _ SUPPORT _ COUNT数据集中项目集的最小频率。</p><p id="e5c1" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">CANDIDATE_SET —数据集中每个项目的C(k) support_count。</p><p id="408b" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">ITEM _ SET-L(k)将候选集支持计数中的每个项目与minimum_support_count进行比较，并过滤出不频繁项目集。</p><p id="5704" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">支持-数据库中的事务百分比遵循规则。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="4cf6" class="mz kv it mv b gy na nb l nc nd">Support(A-&gt;B) = Support_count(A U B)</span></pre><p id="b71d" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">信心——购买了A的顾客也购买了b的顾客的百分比</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="f0cc" class="mz kv it mv b gy na nb l nc nd">Confidence(A-&gt;B) = [Support_count(AUB)/Support_count(A)]*100</span></pre><h1 id="e5cb" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">获取数据</h1><p id="e60c" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在这个实验中，我们考虑了来自Kaggle的名为<a class="ae ne" href="https://www.kaggle.com/shazadudwadia/supermarket" rel="noopener ugc nofollow" target="_blank">杂货店数据集</a>的数据集。它由一家超市的20笔一般商品交易组成。这个数据集更容易理解模式和关联。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/f440f343cf5341b3dfd2bd4e2c228697.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*bAVLKN2TZjAh1toZ8d287g.png"/></div><p class="ng nh gj gh gi ni nj bd b be z dk translated"><a class="ae ne" href="https://www.kaggle.com/shazadudwadia/supermarket" rel="noopener ugc nofollow" target="_blank">杂货店数据集</a></p></figure><p id="90da" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在这里，我们可以看到20组食品杂货交易，即牛奶、面包、饼干、玉米片、茶、BOURNVITA、果酱、MAGGI、咖啡、公鸡和糖。</p><blockquote class="mn mo mp"><p id="a6eb" class="lm ln mq lo b lp mi ju lr ls mj jx lu mr mk lx ly ms ml mb mc mt mm mf mg mh im bi translated">尽管这个数据集很小，但我们不需要生成参数数据集。这足以开发Apriori算法。</p></blockquote><h1 id="404b" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">准备数据</h1><p id="2c96" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">需要处理这些数据以生成记录和项目列表。将minimum_support_count视为2。Pandas库用于导入CSV文件。</p><blockquote class="mn mo mp"><p id="bd1d" class="lm ln mq lo b lp mi ju lr ls mj jx lu mr mk lx ly ms ml mb mc mt mm mf mg mh im bi translated">先决条件:PYTHON中级</p><p id="f33a" class="lm ln mq lo b lp mi ju lr ls mj jx lu mr mk lx ly ms ml mb mc mt mm mf mg mh im bi translated">Geeksforgeeks: <a class="ae ne" href="https://www.geeksforgeeks.org/apriori-algorithm/amp/" rel="noopener ugc nofollow" target="_blank"> Apriori算法</a>(基于理论)</p></blockquote><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="79b8" class="mz kv it mv b gy na nb l nc nd">import pandas as pd<br/>import itertools</span><span id="4866" class="mz kv it mv b gy nk nb l nc nd">data = pd.read_csv('GroceryStoreDataSet.csv')</span><span id="4ce7" class="mz kv it mv b gy nk nb l nc nd">minimum_support_count = 2<br/>records = []<br/>for i in range(0, 20):<br/>    records.append([str(data.values[i,j]) for j in range(0, 4)])</span><span id="dfe0" class="mz kv it mv b gy nk nb l nc nd">items = sorted([item for sublist in records for item in sublist if item != 'nan'])</span></pre><h1 id="eaff" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">构建算法</h1><p id="c04e" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">让我们在构建算法之前修改Apriori的关键属性，</p><blockquote class="mn mo mp"><p id="ee38" class="lm ln mq lo b lp mi ju lr ls mj jx lu mr mk lx ly ms ml mb mc mt mm mf mg mh im bi translated">频繁项目集的所有子集必须是频繁的。如果一个项目集是不频繁的，那么它的所有超集都是不频繁的。</p></blockquote><h2 id="577a" class="mz kv it bd kw nl nm dn la nn no dp le lv np nq lg lz nr ns li md nt nu lk nv bi translated">第一步</h2><p id="15a7" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在阶段1中，通过测量数据集中每个项目的support_count来生成候选集C1。通过比较C1支持计数和最小支持计数，生成项目集L1。这里k=1。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="cf39" class="mz kv it mv b gy na nb l nc nd">def stage_1(items, minimum_support_count):<br/>    c1 = {i:items.count(i) for i in items}<br/>    l1 = {}<br/>    for key, value in c1.items():<br/>        if value &gt;= minimum_support_count:<br/>           l1[key] = value <br/>    <br/>    return c1, l1</span><span id="e752" class="mz kv it mv b gy nk nb l nc nd">c1, l1 = stage_1(items, minimum_support_count)</span></pre><p id="5fa7" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">步骤1的结果是项目集L1，</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/4c538e25f4fe4bab96ec237d77ed3469.png" data-original-src="https://miro.medium.com/v2/resize:fit:368/format:webp/1*tGHdx-ZY23wrwUcwR_jrFw.png"/></div><p class="ng nh gj gh gi ni nj bd b be z dk translated">项目集L1</p></figure><p id="26eb" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在这种情况下，candidate_set中不存在最小支持计数的低频率项目。因此，候选人集C1 =项目集L1。</p><h2 id="37ce" class="mz kv it bd kw nl nm dn la nn no dp le lv np nq lg lz nr ns li md nt nu lk nv bi translated">第二步</h2><p id="681c" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在此阶段，使用上一步中的项目集L1生成候选集C2。检查项目集中的所有子集是否是频繁的，如果不是，从列表中删除相应的项目集。项目集L2是通过将候选集C2与最小值支持计数进行比较而生成的。这里k=2。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="9e00" class="mz kv it mv b gy na nb l nc nd">def stage_2(l1, records, minimum_support_count):<br/>    l1 = sorted(list(l1.keys()))<br/>    L1 = list(itertools.combinations(l1, 2))<br/>    c2 = {}<br/>    l2 = {}<br/>    for iter1 in L1:<br/>        count = 0<br/>        for iter2 in records:<br/>            if sublist(iter1, iter2):<br/>                count+=1<br/>        c2[iter1] = count<br/>    for key, value in c2.items():<br/>        if value &gt;= minimum_support_count:<br/>            if check_subset_frequency(key, l1, 1):<br/>                l2[key] = value <br/>    <br/>    return c2, l2</span><span id="a9e5" class="mz kv it mv b gy nk nb l nc nd">c2, l2 = stage_2(l1, records, minimum_support_count)</span></pre><p id="78b1" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">为了检查一个项集的子集是否频繁，我们应该传递当前阶段的项集、前一阶段的项集(在本例中是L1)和k-1。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="277e" class="mz kv it mv b gy na nb l nc nd">def check_subset_frequency(itemset, l, n):<br/>    if n&gt;1:    <br/>        subsets = list(itertools.combinations(itemset, n))<br/>    else:<br/>        subsets = itemset<br/>    for iter1 in subsets:<br/>        if not iter1 in l:<br/>            return False<br/>    return True</span></pre><p id="ef0e" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">步骤2的结果是项目集L2，</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/b0eea34f9fd57460807a0331156ba059.png" data-original-src="https://miro.medium.com/v2/resize:fit:706/format:webp/1*37UWGDKXAKAgzAbFc2LdoQ.png"/></div><p class="ng nh gj gh gi ni nj bd b be z dk translated">项目集L2</p></figure><p id="3bc4" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在这种情况下，由于低频率类别，即低于minimum_support_count，需要消除项目集中的31个项目。</p><h2 id="737f" class="mz kv it bd kw nl nm dn la nn no dp le lv np nq lg lz nr ns li md nt nu lk nv bi translated">第三步</h2><p id="5970" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在此阶段，使用上一步中的项目集L2生成候选集C3。检查项目集中的所有子集是否是频繁的，如果不是，从列表中删除相应的项目集。通过将候选集C3与最小支持计数进行比较，生成项目集L3。这里k=3。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="7fef" class="mz kv it mv b gy na nb l nc nd">def stage_3(l2, records, minimum_support_count):<br/>    l2 = list(l2.keys())<br/>    L2 = sorted(list(set([item for t in l2 for item in t])))<br/>    L2 = list(itertools.combinations(L2, 3))<br/>    c3 = {}<br/>    l3 = {}<br/>    for iter1 in L2:<br/>        count = 0<br/>        for iter2 in records:<br/>            if sublist(iter1, iter2):<br/>                count+=1<br/>        c3[iter1] = count<br/>    for key, value in c3.items():<br/>        if value &gt;= minimum_support_count:<br/>            if check_subset_frequency(key, l2, 2):<br/>                l3[key] = value <br/>        <br/>    return c3, l3</span><span id="a1ce" class="mz kv it mv b gy nk nb l nc nd">c3, l3 = stage_3(l2, records, minimum_support_count)</span></pre><p id="025a" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">步骤3的结果是项目集L3，</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/3f40fae952c500d5259c01260445f615.png" data-original-src="https://miro.medium.com/v2/resize:fit:688/format:webp/1*mQOEjsOZ05reXuNEbqvCmg.png"/></div><p class="ng nh gj gh gi ni nj bd b be z dk translated">项目集L3</p></figure><h2 id="c6b3" class="mz kv it bd kw nl nm dn la nn no dp le lv np nq lg lz nr ns li md nt nu lk nv bi translated">步骤4</h2><p id="2c07" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在此阶段，使用上一步中的项目集L3生成候选集C4。检查项目集中的所有子集是否是频繁的，如果不是，从列表中删除相应的项目集。项目集L4是通过将候选集C4与最小支持计数进行比较而生成的。这里k=4。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="b35f" class="mz kv it mv b gy na nb l nc nd">def stage_4(l3, records, minimum_support_count):<br/>    l3 = list(l3.keys())<br/>    L3 = sorted(list(set([item for t in l3 for item in t])))<br/>    L3 = list(itertools.combinations(L3, 4))<br/>    c4 = {}<br/>    l4 = {}<br/>    for iter1 in L3:<br/>        count = 0<br/>        for iter2 in records:<br/>            if sublist(iter1, iter2):<br/>                count+=1<br/>        c4[iter1] = count<br/>    for key, value in c4.items():<br/>        if value &gt;= minimum_support_count:<br/>            if check_subset_frequency(key, l3, 3):<br/>                l4[key] = value <br/>        <br/>    return c4, l4</span><span id="f339" class="mz kv it mv b gy nk nb l nc nd">c4, l4 = stage_4(l3, records, minimum_support_count)</span></pre><p id="223c" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">步骤4的结果是项目集L4，</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/06fb685edb5d1385bc7596a7be6871ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:706/format:webp/1*WIwitUEDevg8hjwWgbmwOQ.png"/></div><p class="ng nh gj gh gi ni nj bd b be z dk translated">项目集L4</p></figure><p id="5fa8" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我们可以在这里停下来，因为没有进一步发现频繁子集。</p><h1 id="c0b0" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">生成关联规则</h1><p id="6981" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">为了生成数据集的关联规则，我们需要计算每个规则的置信度。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="4357" class="mz kv it mv b gy na nb l nc nd">''' Rule generation of itemset '''</span><span id="088c" class="mz kv it mv b gy nk nb l nc nd">'''<br/>Confidence:</span><span id="c1bb" class="mz kv it mv b gy nk nb l nc nd">Confidence(A-&gt;B)=Support_count(A∪B)/Support_count(A)</span><span id="4245" class="mz kv it mv b gy nk nb l nc nd">Confidence((COCK, COFFEE)-&gt;CORNFLAKES) = Support_count(‘COCK’, ‘COFFEE’, ‘CORNFLAKES’)/Support_count(‘COCK’, ‘COFFEE’)</span><span id="a856" class="mz kv it mv b gy nk nb l nc nd">'''</span></pre><p id="89e3" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">让我们考虑关联规则的项目集L3。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="d499" class="mz kv it mv b gy na nb l nc nd">sets = []<br/>for iter1 in list(l3.keys()):<br/>    subsets = list(itertools.combinations(iter1, 2))<br/>    sets.append(subsets)</span></pre><p id="598b" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在L3生成的集合上实现关联规则</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="db2d" class="mz kv it mv b gy na nb l nc nd">def support_count(itemset, itemlist):<br/>    return itemlist[itemset]</span><span id="a869" class="mz kv it mv b gy nk nb l nc nd">list_l3 = list(l3.keys())<br/>for i in range(0, len(list_l3)):<br/>    for iter1 in sets[i]:<br/>        a = iter1<br/>        b = set(list_l3[i]) - set(iter1)<br/>        confidence = (support_count(list_l3[i], itemlist)/support_count(iter1, itemlist))*100<br/>        print("Confidence{}-&gt;{} = ".format(a,b), confidence)</span></pre><p id="31dd" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">假设最小置信度为50%</p><h2 id="42ed" class="mz kv it bd kw nl nm dn la nn no dp le lv np nq lg lz nr ns li md nt nu lk nv bi translated">结果</h2><p id="880f" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">信心('饼干'，'公鸡')--&gt; { '玉米片' } = 100.0 <br/>信心('饼干'，'玉米片')- &gt; { '公鸡' } = 66.666666666666666<br/>信心('饼干'，'玉米片')- &gt; { '饼干' } = 100.0 <br/>信心('饼干'，'马奇')- &gt; { '茶' } = 100.0 <br/>信心('饼干'，'茶')-【信心 奶')- &gt; { '饼干' } = 50.0 <br/>信心('面包'，'咖啡')- &gt; { '糖' } = 66.66666666666666666<br/>信心('面包'，'糖')- &gt; { '咖啡' } = 50.0 <br/>信心('咖啡'，'糖')- &gt; { '面包' } = 50.0 <br/>信心('面包'，'糖')-【MAGGI)-&gt; 茶')- &gt; { '面包' } = 100.0 <br/>信心('面包'，'茶')- &gt; {'BOURNVITA'} = 50.0 <br/>信心('饼干'，'公鸡')- &gt; { '咖啡' } = 100.0 <br/>信心('饼干'，'咖啡')- &gt; { '公鸡' } = 100.0 <br/>信心('公鸡'，'咖啡')- &gt; { '饼干' } = 66.66</p><h1 id="4bb3" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">结论</h1><p id="0694" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">这种关联规则挖掘技术是由亚马逊、网飞、谷歌、Flipkart和Spotify等巨头在其推荐平台中实现的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/fe06350b258b5705240353772ff20434.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QC5t7Fg0Z-YWMQJoYfwvjw.jpeg"/></div></div><p class="ng nh gj gh gi ni nj bd b be z dk translated"><a class="ae ne" href="https://inspirationfeed.com/dynamic-content-the-secret-ingredient-for-email-marketing/impact-of-recommendation-engine-on-amazon-and-netflix-3/" rel="noopener ugc nofollow" target="_blank">吸气进给</a></p></figure><p id="0a75" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这种算法也用作大多数销售产品组合的折扣营销技术。</p><p id="98ca" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">今天，我们已经学习了如何构建Apriori算法，并在超市的一般杂货数据集上实现关联规则挖掘。</p><p id="bd49" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">数据集和全部代码可以在我的<a class="ae ne" href="https://github.com/HarshaManoj/apriori" rel="noopener ugc nofollow" target="_blank"> Git仓库</a>中找到。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure></div></div>    
</body>
</html>