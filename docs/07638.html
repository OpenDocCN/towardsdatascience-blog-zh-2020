<html>
<head>
<title>My quarantine project: a real-time face mask detector using Tensorflow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我的隔离项目:使用 Tensorflow 的实时面罩检测器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/my-quarantine-project-a-real-time-face-mask-detector-using-tensorflow-3e7c61a42c40?source=collection_archive---------35-----------------------#2020-06-08">https://towardsdatascience.com/my-quarantine-project-a-real-time-face-mask-detector-using-tensorflow-3e7c61a42c40?source=collection_archive---------35-----------------------#2020-06-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jq jr js jt"><div class="bz fp l di"><div class="ju jv l"/></div></figure><h2 id="1fdf" class="jw jx it bd jy jz ka dn kb kc kd dp ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">检疫项目</h2><p id="bd46" class="pw-post-body-paragraph ks kt it ku b kv kw kx ky kz la lb lc kf ld le lf kj lg lh li kn lj lk ll lm im bi translated">在新冠肺炎封锁的最初几天，我决定做一些与疫情有关的项目，这些项目可能会变得有用。有很多伟大的项目使用了疫情的数据，所以我想专注于一些独特的东西。</p><p id="750f" class="pw-post-body-paragraph ks kt it ku b kv ln kx ky kz lo lb lc kf lp le lf kj lq lh li kn lr lk ll lm im bi translated">随着该国开始经历重新开放的各个阶段，口罩已经成为我们日常生活中的一个重要元素，并将继续存在。为了社交或开展业务，需要佩戴口罩(并正确佩戴)。因此，我决定创建一个应用程序，利用摄像头来检测一个人是否戴着面具，以及面具是否被正确使用。</p><h2 id="1865" class="jw jx it bd jy jz ka dn kb kc kd dp ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">Kaggle，Tensorflow 和合作实验室</h2><p id="84cb" class="pw-post-body-paragraph ks kt it ku b kv kw kx ky kz la lb lc kf ld le lf kj lg lh li kn lj lk ll lm im bi translated">在 Kaggle 上导航时，我遇到了一个由带注释的面具图片组成的小数据集。这是一个很好的注解，这是一个完美的起点。</p><p id="8a4c" class="pw-post-body-paragraph ks kt it ku b kv ln kx ky kz lo lb lc kf lp le lf kj lq lh li kn lr lk ll lm im bi translated">鉴于我对 Tensorflow <a class="ae ls" href="https://github.com/tensorflow/models/tree/master/research/object_detection" rel="noopener ugc nofollow" target="_blank">对象检测 API </a>有些熟悉，我决定使用预先训练好的 COCO 数据集模型。这些<a class="ae ls" href="https://github.com/tensorflow/models/blob/master/research/object_detection/g3doc/detection_model_zoo.md" rel="noopener ugc nofollow" target="_blank">预先训练的模型</a>对于 COCO 中已经存在的 90 个类别(例如，人类、汽车、狗等)的开箱即用推理非常棒。它们还特别适用于作为初始化新模型以训练全新数据集的基线。</p><p id="bfb3" class="pw-post-body-paragraph ks kt it ku b kv ln kx ky kz lo lb lc kf lp le lf kj lq lh li kn lr lk ll lm im bi translated">有许多在浏览器中编写和执行 Python 的好方法，比如<a class="ae ls" href="https://aws.amazon.com/sagemaker/" rel="noopener ugc nofollow" target="_blank"> AWS SageMake </a> r，但是 Google Colaboratory 提供免费的 GPU 计算，所以我选择使用 Colab 笔记本来运行我的所有培训。后来，我决定升级到专业帐户，以保证我总是有 GPU 和内存可用。</p><figure class="lu lv lw lx gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi lt"><img src="../Images/967694fae50aa8b207fc74a36c623389.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4pfAnCr4Vx6RFL4HOfyoyQ.png"/></div></div><p class="me mf gj gh gi mg mh bd b be z dk translated">Google 协作配置</p></figure><p id="d041" class="pw-post-body-paragraph ks kt it ku b kv ln kx ky kz lo lb lc kf lp le lf kj lq lh li kn lr lk ll lm im bi translated">不是巧合，卡格尔。Tensorflow 和 Colaboratory 是谷歌的产品。我确信我可以找到类似的 AWS 或微软的产品，但是没有什么比免费的更好。</p><h2 id="94e6" class="jw jx it bd jy jz ka dn kb kc kd dp ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">为训练准备数据集</h2><p id="691e" class="pw-post-body-paragraph ks kt it ku b kv kw kx ky kz la lb lc kf ld le lf kj lg lh li kn lj lk ll lm im bi translated">带有遮罩批注的元数据文件是 XML 文件，包含有关图像的信息和每个元素的边界框信息。他们使用 PASCAL VOC 格式，这是一种常见的结构。</p><pre class="lu lv lw lx gt mi mj mk ml aw mm bi"><span id="3895" class="jw jx it mj b gy mn mo l mp mq">&lt;annotation&gt;<br/> &lt;folder&gt;images&lt;/folder&gt;<br/><strong class="mj iu"> &lt;filename&gt;1_13.jpg&lt;/filename&gt;<br/></strong> &lt;path&gt;P:\mask_mouth\images\1_13.jpg&lt;/path&gt;<br/> &lt;source&gt;<br/>  &lt;database&gt;Unknown&lt;/database&gt;<br/> &lt;/source&gt;<br/><strong class="mj iu"> &lt;size&gt;<br/></strong>  &lt;width&gt;918&lt;/width&gt;<br/>  &lt;height&gt;506&lt;/height&gt;<br/>  &lt;depth&gt;3&lt;/depth&gt;<br/> &lt;/size&gt;<br/> &lt;segmented&gt;0&lt;/segmented&gt;<br/> &lt;object&gt;<br/><strong class="mj iu">  &lt;name&gt;good&lt;/name&gt;<br/></strong>  &lt;pose&gt;Unspecified&lt;/pose&gt;<br/>  &lt;truncated&gt;0&lt;/truncated&gt;<br/>  &lt;difficult&gt;0&lt;/difficult&gt;<br/><strong class="mj iu">  &lt;bndbox&gt;<br/></strong>   &lt;xmin&gt;133&lt;/xmin&gt;<br/>   &lt;ymin&gt;109&lt;/ymin&gt;<br/>   &lt;xmax&gt;215&lt;/xmax&gt;<br/>   &lt;ymax&gt;201&lt;/ymax&gt;<br/>  &lt;/bndbox&gt;<br/> &lt;/object&gt;</span></pre><p id="0001" class="pw-post-body-paragraph ks kt it ku b kv ln kx ky kz lo lb lc kf lp le lf kj lq lh li kn lr lk ll lm im bi translated"><code class="fe mr ms mt mj b">name</code>字段包含对象的类。在这个数据集的情况下，三个类名有些混乱:<code class="fe mr ms mt mj b">good</code>代表戴面具的人，<code class="fe mr ms mt mj b">bad</code>代表不戴面具的人，<code class="fe mr ms mt mj b">none</code>代表面具放置不正确。这很傻，但这给我带来了问题，使这个项目花费了更长的时间，因为我使用了不同类名的 labelmap 进行推理。</p><p id="df58" class="pw-post-body-paragraph ks kt it ku b kv ln kx ky kz lo lb lc kf lp le lf kj lq lh li kn lr lk ll lm im bi translated"><strong class="ku iu">生成 CSV 文件</strong></p><p id="17b4" class="pw-post-body-paragraph ks kt it ku b kv ln kx ky kz lo lb lc kf lp le lf kj lq lh li kn lr lk ll lm im bi translated">需要做一些调整来规范化数据集。有些文件是 png，有些是 jpg，有些没有相应的 XML 文件，反之亦然。在确保它们都是一致的之后，我将它们随机分成训练集和测试集(80/20)。来自 XMLs 的数据然后被导入到一个 CSV 文件中。每行对应一个注释。CSV 列有:<code class="fe mr ms mt mj b">filename</code>、<code class="fe mr ms mt mj b">width</code>、<code class="fe mr ms mt mj b">height</code>、<code class="fe mr ms mt mj b">class</code>、<code class="fe mr ms mt mj b">xmin</code>、<code class="fe mr ms mt mj b">ymin</code>、<code class="fe mr ms mt mj b">xmax</code>、<code class="fe mr ms mt mj b">ymax</code>。</p><pre class="lu lv lw lx gt mi mj mk ml aw mm bi"><span id="4724" class="jw jx it mj b gy mn mo l mp mq">train_xml_df.to_csv(train_path_csv + 'train_labels.csv', index=None)<br/>test_xml_df.to_csv(test_path_csv + 'test_labels.csv', index=None)</span></pre><p id="b1a1" class="pw-post-body-paragraph ks kt it ku b kv ln kx ky kz lo lb lc kf lp le lf kj lq lh li kn lr lk ll lm im bi translated"><strong class="ku iu">生成 TFRecord </strong></p><p id="a99d" class="pw-post-body-paragraph ks kt it ku b kv ln kx ky kz lo lb lc kf lp le lf kj lq lh li kn lr lk ll lm im bi translated">TFRecord 是一种存储二进制记录序列的简单格式。所以我的下一步是使用 CSV 创建一个 TFRecord 文件，用于训练网络。为拆分的训练集和测试集分别生成了不同的 TFRecord 文件。</p><pre class="lu lv lw lx gt mi mj mk ml aw mm bi"><span id="5088" class="jw jx it mj b gy mn mo l mp mq">generate_tfrecord(train_csv_file, HOME_DIR, 'train.record', train_path_images)<br/>generate_tfrecord(test_csv_file, HOME_DIR, 'test.record', test_path_images)</span></pre><h2 id="c10e" class="jw jx it bd jy jz ka dn kb kc kd dp ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">培训 TFRecords</h2><p id="a94f" class="pw-post-body-paragraph ks kt it ku b kv kw kx ky kz la lb lc kf ld le lf kj lg lh li kn lj lk ll lm im bi translated">在 TFRecords 可用的情况下，下一步是从 Tensorflow 模型动物园中选择一个预训练的模型，并使用它来训练 TFRecords。</p><p id="3fb5" class="pw-post-body-paragraph ks kt it ku b kv ln kx ky kz lo lb lc kf lp le lf kj lq lh li kn lr lk ll lm im bi translated">在对一些模型进行了一些调查后，我决定使用<code class="fe mr ms mt mj b">ssd_inception_v2_coco</code>，因为它可以很好地平衡速度和<a class="ae ls" href="http://cocodataset.org/#detection-eval" rel="noopener ugc nofollow" target="_blank">平均精度</a>(地图)。</p><p id="00d0" class="pw-post-body-paragraph ks kt it ku b kv ln kx ky kz lo lb lc kf lp le lf kj lq lh li kn lr lk ll lm im bi translated">关于 Tensorflow 对象检测 API 的事情是，它不被最新的 2。张量流的 x 个版本。遗留代码不是向后兼容的，所以需要做一些工作来找出可以工作的最佳版本。该过程的一部分是编译协议缓冲区，并确保它们包含在<code class="fe mr ms mt mj b">PYTHONPATH</code>中。堆栈溢出很方便地帮助我解决了必须降级<code class="fe mr ms mt mj b">gast(==0.2.2)</code>和<code class="fe mr ms mt mj b">numpy(==1.17.4)</code>的问题，并避免在训练中途崩溃。</p><pre class="lu lv lw lx gt mi mj mk ml aw mm bi"><span id="4d52" class="jw jx it mj b gy mn mo l mp mq"># Testing Object Detection works</span><span id="43d7" class="jw jx it mj b gy mu mo l mp mq">from tensorflow.contrib import slim<br/>from nets import inception_resnet_v2<br/>from object_detection.builders import model_builder<br/>from object_detection.protos import input_reader_pb2</span></pre><p id="ea96" class="pw-post-body-paragraph ks kt it ku b kv ln kx ky kz lo lb lc kf lp le lf kj lq lh li kn lr lk ll lm im bi translated"><strong class="ku iu">型号配置</strong></p><p id="d23a" class="pw-post-body-paragraph ks kt it ku b kv ln kx ky kz lo lb lc kf lp le lf kj lq lh li kn lr lk ll lm im bi translated">在能够训练之前，我必须用 TFRecords 的参数和文件位置修改<code class="fe mr ms mt mj b">ssd_inception_v2_coco</code>配置文件。每一篇关于物体检测的文章都会详尽地告诉你如何去做。</p><figure class="lu lv lw lx gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi mv"><img src="../Images/223035d3bc155d59972e399fb69d0daa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1eQAqXJ4niAkp6dSd8L6Gg.png"/></div></div><p class="me mf gj gh gi mg mh bd b be z dk translated">ssd_inception_v2_coco.config 摘录</p></figure><p id="e0f7" class="pw-post-body-paragraph ks kt it ku b kv ln kx ky kz lo lb lc kf lp le lf kj lq lh li kn lr lk ll lm im bi translated">拥有可用的 GPU 和 RAM 很有帮助，甚至尝试了大量的步骤。笔记本电脑可以在夜间运行，不会出现大的问题。当有事情发生时，我总是可以从检查点恢复。</p><pre class="lu lv lw lx gt mi mj mk ml aw mm bi"><span id="748a" class="jw jx it mj b gy mn mo l mp mq">python ./models/research/object_detection/<strong class="mj iu">model_main.py</strong> \<br/>--pipeline_config_path={pipeline_fname} \<br/>--model_dir={model_dir} --alsologtostderr \<br/>--num_train_steps={num_steps} --num_eval_steps={num_eval_steps}</span></pre><figure class="lu lv lw lx gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi mw"><img src="../Images/fb87b8adc6dc287c1b15081f0f64fef4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*NEJfu6ALY1Xzxh8PrM1-AA.png"/></div></div><p class="me mf gj gh gi mg mh bd b be z dk translated">培训损失</p></figure><h2 id="0b3f" class="jw jx it bd jy jz ka dn kb kc kd dp ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">导出训练好的推理图</h2><p id="e304" class="pw-post-body-paragraph ks kt it ku b kv kw kx ky kz la lb lc kf ld le lf kj lg lh li kn lj lk ll lm im bi translated">一旦训练工作完成，下一步是提取新训练的推理图，该推理图稍后将用于执行对象检测。这可以使用 Tensorflow 对象检测程序来完成。</p><pre class="lu lv lw lx gt mi mj mk ml aw mm bi"><span id="544f" class="jw jx it mj b gy mn mo l mp mq">python object_detection/<strong class="mj iu">export_inference_graph.py</strong> \<br/>--input_type image_tensor --pipeline_config_path {pipeline_fname} \<br/>--trained_checkpoint_prefix {last_model_path} \<br/>--output_directory /content/mask-detection/training/exported_graph</span></pre><p id="54ef" class="pw-post-body-paragraph ks kt it ku b kv ln kx ky kz lo lb lc kf lp le lf kj lq lh li kn lr lk ll lm im bi translated">这个过程生成<code class="fe mr ms mt mj b">frozen_inference_graph.pb</code>，它是一个<em class="mx"> protobuf </em>文件，包含图形定义以及模型的所有权重。有了这个文件，我们就可以运行训练好的模型并进行推理。</p><p id="008e" class="pw-post-body-paragraph ks kt it ku b kv ln kx ky kz lo lb lc kf lp le lf kj lq lh li kn lr lk ll lm im bi translated">在一些训练图像中运行检测工作得相当好。</p><div class="lu lv lw lx gt ab cb"><figure class="my jt mz na nb nc nd paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><img src="../Images/8045f674975aa360ba41d760e2b00a00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*-qCkwFJh5ck81Hc-fNqMVw.png"/></div></figure><figure class="my jt ne na nb nc nd paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><img src="../Images/a7cb746603521a262ef44e1859338f70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*bA24rGch6InzqoELV_HOtA.png"/></div></figure></div><div class="ab cb"><figure class="my jt nf na nb nc nd paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><img src="../Images/d7edb839728647f8d6725fbe59e3be49.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/format:webp/1*wg8nUohQhJ0IrM1Q7e1xKw.png"/></div></figure><figure class="my jt ng na nb nc nd paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><img src="../Images/6cbc948c007c9c6e474026ac492b28da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1106/format:webp/1*-YDhzvQUmcmuDEyaXBNabA.png"/></div><p class="me mf gj gh gi mg mh bd b be z dk nh di ni nj translated">训练图像上的目标检测。</p></figure></div><p id="77d2" class="pw-post-body-paragraph ks kt it ku b kv ln kx ky kz lo lb lc kf lp le lf kj lq lh li kn lr lk ll lm im bi translated">我更进一步，将它转换成一个<code class="fe mr ms mt mj b">tflite_graph.pb</code>文件作为输入，最终得到一个 TensorFlow Lite flatbuffer 格式<code class="fe mr ms mt mj b">detect.tflite</code></p><pre class="lu lv lw lx gt mi mj mk ml aw mm bi"><span id="3857" class="jw jx it mj b gy mn mo l mp mq">python object_detection/<strong class="mj iu">export_tflite_ssd_graph.py</strong> \<br/>--pipeline_config_path={pipeline_fname} \<br/>--trained_checkpoint_prefix={last_model_path} \<br/>--output_directory /content/mask-detection/tflite \<br/>--add_postprocessing_op=true</span><span id="c1e1" class="jw jx it mj b gy mu mo l mp mq"><strong class="mj iu">tflite_convert</strong> --graph_def_file=/content/mask-detection/tflite/tflite_graph.pb \<br/>--output_file=/content/mask-detection/tflite/detect.tflite \<br/>--output_format=TFLITE --input_shapes=1,300,300,3 \<br/>--input_arrays=normalized_input_image_tensor \<br/>--output_arrays ='TFLite_Detection_PostProcess','TFLite_Detection_PostProcess:1','TFLite_Detection_PostProcess:2','TFLite_Detection_PostProcess:3' \<br/>--allow_custom_ops --mean_values=128 --std_dev_values=127 \<br/>--change_concat_input_ranges=false --allow_custom_ops</span></pre><p id="00ee" class="pw-post-body-paragraph ks kt it ku b kv ln kx ky kz lo lb lc kf lp le lf kj lq lh li kn lr lk ll lm im bi translated">TensorFlow Lite 文件可用于在移动、嵌入式和物联网设备上运行模型。它们支持低延迟和小二进制大小的设备上推断。</p><p id="f5d0" class="pw-post-body-paragraph ks kt it ku b kv ln kx ky kz lo lb lc kf lp le lf kj lq lh li kn lr lk ll lm im bi translated">在我的下一篇关于在 Raspberry PI 4 上运行 TF Lite 的文章中，请遵循我的中等配置文件。这是这个项目的 Github <a class="ae ls" href="https://github.com/cacheop/facemask-detection" rel="noopener ugc nofollow" target="_blank">库</a>。</p></div></div>    
</body>
</html>