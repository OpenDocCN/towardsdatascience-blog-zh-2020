<html>
<head>
<title>A Peek Into Missing Data with Pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一瞥缺失的熊猫数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-peek-into-missing-data-with-pandas-2fb9e5df8bd0?source=collection_archive---------42-----------------------#2020-07-19">https://towardsdatascience.com/a-peek-into-missing-data-with-pandas-2fb9e5df8bd0?source=collection_archive---------42-----------------------#2020-07-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="4cc4" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/pytrix-series" rel="noopener" target="_blank"> PyTrix 系列</a></h2><div class=""/><div class=""><h2 id="777b" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">PyTrix #6:检测缺失数据</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/e367e5b634e2713df13473ff21fb90f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BKYQtAHTyCbCZhu7"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">凯莉·西克玛在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="3662" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当我们观察到数据中缺少值时，这是因为没有数据值存储在观察的特定变量中。缺失数据在实践中极为常见，并且会对从数据中得出的结论产生很大影响，因此数据科学家的大部分时间都花在了数据清理上。</p><p id="50b2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可能会有缺失数据的各种原因，例如，可能有未被调查者，可能只有在已经收集了一定数量的观察值后才开始收集特定特征，数据输入中出现错误，或者在某些情况下，参与者可能会随着时间的推移而退出-一般来说，可能有各种原因。</p><p id="55fc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">无论如何，给定一些先决条件(即，我们有一个想要解决的已定义的问题)，我们想要从我们处理的数据中提取有意义的见解，这将意味着在我们开始处理数据集之前要面对缺失数据的问题。这样我们就避免了对一个仅由 45%的观察值代表的变量做出任何具体的结论。此外，在训练我们的机器学习算法时，缺失值可能会被我们的模型视为 0 或无穷大，这可能会对我们的训练结果产生一些严重的影响。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="b3fc" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated">熊猫的例子</h2><blockquote class="nd ne nf"><p id="ce6c" class="li lj ng lk b ll lm kd ln lo lp kg lq nh ls lt lu ni lw lx ly nj ma mb mc md im bi translated">注意:对于此任务，我们将使用来自 Kaggle 的数据集，具体来说就是<a class="ae lh" href="https://www.kaggle.com/c/cat-in-the-dat/data?select=train.csv" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd">分类特征编码挑战</strong> </a> <strong class="lk jd">。</strong>代码可在下面的链接中找到。</p></blockquote><div class="nk nl gp gr nm nn"><a href="https://github.com/kurtispykes/demo/blob/master/pytrix/pytrix_missing_data.ipynb" rel="noopener  ugc nofollow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd jd gy z fp ns fr fs nt fu fw jc bi translated">kurtispykes/演示</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">permalink dissolve GitHub 是超过 5000 万开发人员的家园，他们一起工作来托管和审查代码，管理…</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">github.com</p></div></div><div class="nw l"><div class="nx l ny nz oa nw ob lb nn"/></div></div></a></div><p id="4270" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们将从使用<code class="fe oc od oe of b">pd.read_csv</code> — <a class="ae lh" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html" rel="noopener ugc nofollow" target="_blank">文档</a>读入数据开始。</p><pre class="ks kt ku kv gt og of oh oi aw oj bi"><span id="744f" class="ml mm it of b gy ok ol l om on">import pandas as pd </span><span id="f674" class="ml mm it of b gy oo ol l om on"><em class="ng"># load and peek at data</em><br/>df = pd.read_csv("../data/categorical_feature_engineering_raw/train.csv")<br/>df.head()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi op"><img src="../Images/21f38f36edc0169a3efac584620d45d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aQgxyVNb7aU4ctfZV_W1Tw.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图 1:df . head()；该表太大，无法放入图像中(并且太大，无法显示列，因此出现省略号)。</p></figure><p id="909f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在用于数据操作的 Python 框架 Pandas 中，缺失值被表示为<code class="fe oc od oe of b">Nan</code>或<code class="fe oc od oe of b">None</code>，并且有多种方法来检查我们的数据中是否存在缺失值:</p><ul class=""><li id="a91a" class="oq or it lk b ll lm lo lp lr os lv ot lz ou md ov ow ox oy bi translated"><strong class="lk jd"> pd.isnull() </strong></li><li id="8b12" class="oq or it lk b ll oz lo pa lr pb lv pc lz pd md ov ow ox oy bi translated"><strong class="lk jd"> pd.notnull() </strong></li><li id="6f2f" class="oq or it lk b ll oz lo pa lr pb lv pc lz pd md ov ow ox oy bi translated"><strong class="lk jd"> pd.isna() </strong></li><li id="6229" class="oq or it lk b ll oz lo pa lr pb lv pc lz pd md ov ow ox oy bi translated"><strong class="lk jd"> pd.notna() </strong></li><li id="7f2c" class="oq or it lk b ll oz lo pa lr pb lv pc lz pd md ov ow ox oy bi translated"><strong class="lk jd"> df.isna() </strong></li><li id="63b0" class="oq or it lk b ll oz lo pa lr pb lv pc lz pd md ov ow ox oy bi translated"><strong class="lk jd"> df.notna() </strong></li><li id="6caf" class="oq or it lk b ll oz lo pa lr pb lv pc lz pd md ov ow ox oy bi translated"><strong class="lk jd"> df.isnull() </strong></li><li id="40df" class="oq or it lk b ll oz lo pa lr pb lv pc lz pd md ov ow ox oy bi translated"><strong class="lk jd"> df.notnull() </strong></li></ul><p id="fdee" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">是的，我知道你在想什么，<em class="ng">我应该用哪一个？嗯，你会发现它们之间最大的不同是，4 个是顶级函数，另外 4 个是 pandas dataframe 类(<code class="fe oc od oe of b">pd.DataFrame.isna()</code>)的方法。本质上，在数据帧级别上<code class="fe oc od oe of b">df.isna()</code>和<code class="fe oc od oe of b">df.isnull()</code>是相同的，同样<code class="fe oc od oe of b">df.notna()</code>和<code class="fe oc od oe of b">df.notnull()</code>也是相同的(它们实际上有相同的文档)——这种现象也适用于顶级函数。</em></p><p id="9050" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为什么名称不同的多个方法做同样的事情？Pandas 建立在 NumPy 之上，NumPy 使用<code class="fe oc od oe of b">np.isnan()</code>来检测丢失的值，因此它既没有<code class="fe oc od oe of b"><strong class="lk jd">Na</strong></code>也没有<code class="fe oc od oe of b"><strong class="lk jd">Null</strong></code>值。然而，Pandas 使用基于 R 数据帧的数据帧，并且 R 中的<code class="fe oc od oe of b"><strong class="lk jd">Na</strong></code>和<code class="fe oc od oe of b"><strong class="lk jd">Null</strong></code>是不同的东西——在这里阅读更多关于 R <code class="fe oc od oe of b"><strong class="lk jd">Na</strong></code>和<code class="fe oc od oe of b"><strong class="lk jd">Null</strong></code>T35 的信息，在这里查看我的答案来源<a class="ae lh" href="https://datascience.stackexchange.com/questions/37878/difference-between-isna-and-isnull-in-pandas" rel="noopener ugc nofollow" target="_blank">。</a></p><blockquote class="nd ne nf"><p id="293a" class="li lj ng lk b ll lm kd ln lo lp kg lq nh ls lt lu ni lw lx ly nj ma mb mc md im bi translated">所以我想在这个意义上，我们可以选择让熊猫成为我们自己的，这是熊猫框架中的一个共同主题。</p></blockquote><p id="dfb2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我通常使用<code class="fe oc od oe of b">df.isna()</code>和相反的<code class="fe oc od oe of b">df.notna()</code>，主要是因为它比<code class="fe oc od oe of b">df.isnull()</code>和<code class="fe oc od oe of b">df.notnull()</code>需要输入的字符少。此外，我更喜欢用点符号直接访问数据帧，这排除了顶级函数(它们要求您将数据帧或系列对象作为参数传递)。</p><pre class="ks kt ku kv gt og of oh oi aw oj bi"><span id="bf18" class="ml mm it of b gy ok ol l om on"><em class="ng"># see what .isna() returns</em><br/>df.isna()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pe"><img src="../Images/b2bc92df3137d203f3652590d5d22851.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LepsNH1sn4bnRRGI_lXIGA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图 2: df.isna()为 DataFrame 中的每个元素返回一个 bool 值的掩码，指示一个元素是否不是安娜值。</p></figure><p id="7cd9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">作为理智检查，我将对<code class="fe oc od oe of b">pd.isna()</code>做同样的事情…</p><pre class="ks kt ku kv gt og of oh oi aw oj bi"><span id="bd6b" class="ml mm it of b gy ok ol l om on">pd.isna(df)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pe"><img src="../Images/b2bc92df3137d203f3652590d5d22851.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LepsNH1sn4bnRRGI_lXIGA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图 3: pd.isna(df)返回一个布尔值，表明是否缺少每个相应的元素。</p></figure><p id="ccfd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">好吧，这是一样的(你注意到你必须为顶层函数路径键入几个额外的字母吗——是的，我很懒)。现在我们可以检查<code class="fe oc od oe of b">df.notna()</code>是否真的是<code class="fe oc od oe of b">df.isna()</code>的倒数…</p><pre class="ks kt ku kv gt og of oh oi aw oj bi"><span id="129d" class="ml mm it of b gy ok ol l om on"><em class="ng"># see what .notna() returns<br/></em>df.notna()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pf"><img src="../Images/3b0c61c5adffa7578213a3ce325b9c81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aJGd3QXNaTW4ZIzw-QOjbQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图 4: df.notna()</p></figure><p id="5810" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">尽管<code class="fe oc od oe of b">df.notna()</code>的文档说明这个方法返回的东西和<code class="fe oc od oe of b">df.isna()</code>完全一样(我个人觉得很困惑)，<code class="fe oc od oe of b">df.notna()</code>确实是相反的。</p><p id="2b5d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">除此之外，让我们进一步挖掘我们的数据，以检查丢失的值。</p><pre class="ks kt ku kv gt og of oh oi aw oj bi"><span id="821b" class="ml mm it of b gy ok ol l om on">df.isna().sum()</span><span id="1522" class="ml mm it of b gy oo ol l om on">&gt;&gt;&gt;&gt; <br/>id        0<br/>bin_0     0<br/>bin_1     0<br/>bin_2     0<br/>bin_3     0<br/>bin_4     0<br/>nom_0     0<br/>nom_1     0<br/>nom_2     0<br/>nom_3     0<br/>nom_4     0<br/>nom_5     0<br/>nom_6     0<br/>nom_7     0<br/>nom_8     0<br/>nom_9     0<br/>ord_0     0<br/>ord_1     0<br/>ord_2     0<br/>ord_3     0<br/>ord_4     0<br/>ord_5     0<br/>day       0<br/>month     0<br/>target    0<br/>dtype: int64</span></pre><p id="3884" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Oooops，看起来我们有一个没有缺失值的数据集——这在现实世界中不太可能发生，所以我们将利用我们在<a class="ae lh" href="https://towardsdatascience.com/tagged/pytrix-series" rel="noopener" target="_blank"> PyTrix 系列</a>第 4 集中学到的一些技能来添加一些缺失值——链接如下。</p><div class="nk nl gp gr nm nn"><a rel="noopener follow" target="_blank" href="/slicing-and-indexing-with-pandas-2bff05ec361e"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd jd gy z fp ns fr fs nt fu fw jc bi translated">用熊猫切片和索引</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">PyTrix #4:用熊猫访问数据</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">towardsdatascience.com</p></div></div><div class="nw l"><div class="pg l ny nz oa nw ob lb nn"/></div></div></a></div><pre class="ks kt ku kv gt og of oh oi aw oj bi"><span id="5d28" class="ml mm it of b gy ok ol l om on"><em class="ng"># inputting NaN's randomly into data</em><br/>df.loc[2:1000:100, ["bin_0"]] = <strong class="of jd">None</strong><br/>df.loc[:300:20, ["ord_4", "ord_5"]] = <strong class="of jd">None</strong> <br/>df.loc[500::50, ["nom_4", "bin_4"]] = <strong class="of jd">None</strong></span><span id="eeef" class="ml mm it of b gy oo ol l om on">df.isna().sum()</span><span id="8c61" class="ml mm it of b gy oo ol l om on">&gt;&gt;&gt;&gt; <br/>id           0<br/>bin_0       10<br/>bin_1        0<br/>bin_2        0<br/>bin_3        0<br/>bin_4     5990<br/>nom_0        0<br/>nom_1        0<br/>nom_2        0<br/>nom_3        0<br/>nom_4     5990<br/>nom_5        0<br/>nom_6        0<br/>nom_7        0<br/>nom_8        0<br/>nom_9        0<br/>ord_0        0<br/>ord_1        0<br/>ord_2        0<br/>ord_3        0<br/>ord_4       16<br/>ord_5       16<br/>day          0<br/>month        0<br/>target       0<br/>dtype: int64</span></pre><p id="9065" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">太棒了。这意味着当我们使用逆方法时，<code class="fe oc od oe of b">df.notna()</code>应该发生的是，缺失值的数量应该从特定列的行数中扣除，对吗？</p><pre class="ks kt ku kv gt og of oh oi aw oj bi"><span id="ec0e" class="ml mm it of b gy ok ol l om on"><em class="ng"># how man non-null values? </em><br/>df.notna().sum()</span><span id="b8f7" class="ml mm it of b gy oo ol l om on">&gt;&gt;&gt;&gt;<br/>id        300000<br/>bin_0     299990<br/>bin_1     300000<br/>bin_2     300000<br/>bin_3     300000<br/>bin_4     294010<br/>nom_0     300000<br/>nom_1     300000<br/>nom_2     300000<br/>nom_3     300000<br/>nom_4     294010<br/>nom_5     300000<br/>nom_6     300000<br/>nom_7     300000<br/>nom_8     300000<br/>nom_9     300000<br/>ord_0     300000<br/>ord_1     300000<br/>ord_2     300000<br/>ord_3     300000<br/>ord_4     299984<br/>ord_5     299984<br/>day       300000<br/>month     300000<br/>target    300000<br/>dtype: int64</span></pre><p id="ca93" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">没错。</p><p id="7d14" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了只查看有特定缺失观察值的行，我们可以在调用 dataframe 后将一个条件语句传递到括号(<code class="fe oc od oe of b">[]</code>)中，如下所示…</p><pre class="ks kt ku kv gt og of oh oi aw oj bi"><span id="1248" class="ml mm it of b gy ok ol l om on"><em class="ng"># viewing only the rows where bin_4 = NaN </em><br/>df[df["bin_4"].isna()]</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ph"><img src="../Images/f8ad207304e213082f2c480e6c751dd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9_7hz8SJ7hMUrhRAhTAz6A.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图 bin _ 4 是缺失值的行</p></figure><p id="e80f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在不深入研究我们如何处理缺失值的情况下——这可能会在另一篇文章中讨论——接下来的几行代码将展示处理缺失值的最简单的方法<strong class="lk jd">(尽管不总是最好的方法)</strong>…删除它们！</p><pre class="ks kt ku kv gt og of oh oi aw oj bi"><span id="198d" class="ml mm it of b gy ok ol l om on"><em class="ng"># priginal df shape</em><br/>df.shape<br/>&gt;&gt;&gt;&gt; (300000, 25)</span><span id="07b7" class="ml mm it of b gy oo ol l om on"><em class="ng"># df shape after dropping rows with any missing values </em><br/>df.dropna(how="any").shape<br/>&gt;&gt;&gt;&gt; (293984, 25)</span><span id="d4a8" class="ml mm it of b gy oo ol l om on"><em class="ng"># df shape  after dropping rows with all missing values</em><br/>df.dropna(how="all").shape<br/>&gt;&gt;&gt;&gt; (300000, 25)</span><span id="af79" class="ml mm it of b gy oo ol l om on"><em class="ng"># dropping any row if it has NaN in ord_4 or ord_5</em><br/>df.dropna(subset=["ord_4", "ord_5"], how="any").shape<br/>&gt;&gt;&gt;&gt; (299984, 25)</span></pre><p id="1bab" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你们中的一些人可能已经注意到，当我在图 5 的<em class="ng">中返回 bin_4 缺少值的行时，</em>bin _ 4 列返回了一个<code class="fe oc od oe of b">None</code>值，而不是<code class="fe oc od oe of b">NaN</code>，如果您这样做了，请不要担心！这是另一个例子…</p><pre class="ks kt ku kv gt og of oh oi aw oj bi"><span id="1664" class="ml mm it of b gy ok ol l om on">df[df["ord_4"].isna()]["ord_4"]</span><span id="63ab" class="ml mm it of b gy oo ol l om on">&gt;&gt;&gt;&gt;<br/>0      None<br/>20     None<br/>40     None<br/>60     None<br/>80     None<br/>100    None<br/>120    None<br/>140    None<br/>160    None<br/>180    None<br/>200    None<br/>220    None<br/>240    None<br/>260    None<br/>280    None<br/>300    None<br/>Name: ord_4, dtype: object</span><span id="4971" class="ml mm it of b gy oo ol l om on">df[df["bin_0"].isna()]["bin_0"]</span><span id="267e" class="ml mm it of b gy oo ol l om on">&gt;&gt;&gt;&gt;<br/>2     NaN<br/>102   NaN<br/>202   NaN<br/>302   NaN<br/>402   NaN<br/>502   NaN<br/>602   NaN<br/>702   NaN<br/>802   NaN<br/>902   NaN<br/>Name: bin_0, dtype: float64</span></pre><p id="2fc5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">还记得我之前说的<code class="fe oc od oe of b">np.nan</code>吗？很好。原来<code class="fe oc od oe of b">NaN</code>是数据类型 float，因此当它在 object 数据类型列中使用时，它将其转换为<code class="fe oc od oe of b">None</code>，当它在 int 上使用时，它将其转换为 dtype，如上面的示例代码所示。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="fde8" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated">包裹</h2><p id="3496" class="pw-post-body-paragraph li lj it lk b ll pi kd ln lo pj kg lq lr pk lt lu lv pl lx ly lz pm mb mc md im bi translated">Pandas 使检测数据帧中的缺失值变得非常容易，这在任何数据科学/机器学习工作流中都很重要。虽然我们没有通过 PyTrix 来处理丢失的值，因为这将是下周的主题，但是您现在知道如何在数据帧中发现丢失的值。</p><p id="fb71" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">非常感谢你读到这个故事的结尾。如果您认为我遗漏了什么，或者您想向我指出什么，或者如果您仍然不确定什么，您的反馈是有价值的。发个回应！然而，如果你想和我联系，我在 LinkedIn 上是最活跃的，我也很乐意和你联系。</p><div class="nk nl gp gr nm nn"><a href="https://www.linkedin.com/in/kurtispykes/" rel="noopener  ugc nofollow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd jd gy z fp ns fr fs nt fu fw jc bi translated">Kurtis Pykes -人工智能作家-走向数据科学| LinkedIn</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">在世界上最大的职业社区 LinkedIn 上查看 Kurtis Pykes 的个人资料。Kurtis 有一个工作列在他们的…</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">www.linkedin.com</p></div></div><div class="nw l"><div class="pn l ny nz oa nw ob lb nn"/></div></div></a></div></div></div>    
</body>
</html>