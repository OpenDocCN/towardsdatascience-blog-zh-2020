<html>
<head>
<title>How to Auto-Detect Errors in a Dataset</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何自动检测数据集中的错误</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-auto-detect-format-errors-in-a-dataset-6609a9e9aacc?source=collection_archive---------19-----------------------#2020-03-11">https://towardsdatascience.com/how-to-auto-detect-format-errors-in-a-dataset-6609a9e9aacc?source=collection_archive---------19-----------------------#2020-03-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3eb0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">引入泛化树和泛化语言来自动检测结构化数据集中的损坏值。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d567b891face215ad0784a73e9147a2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*obL5Pc6-Kv-TYdBoDppA3A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">乔治·贝克在<a class="ae ky" href="https://www.pexels.com/search/mistake/" rel="noopener ugc nofollow" target="_blank">的照片</a></p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="d4da" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">给定一个大型的结构化数据集，比如excel电子表格或CSV文件，有没有办法<strong class="li iu">避免检测不可避免的错误这种令人疲惫不堪、影响工作效率的琐事</strong>？</p><p id="e317" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在这个故事中，我们应用<a class="ae ky" href="https://scholar.google.com/citations?user=WdEqRxEAAAAJ&amp;hl=en&amp;oi=sra" rel="noopener ugc nofollow" target="_blank">黄志鹏</a>和叶烨他在<a class="ae ky" href="https://dl.acm.org/doi/abs/10.1145/3183713.3196889?casa_token=SAUDUyrv2lwAAAAA:Aao6vxthGuNfNSEJyUYX_CyjUyrn0LM6fXrRsUvpGfB8GiQBBSJ6ZFJS-Q2_SQ3u3dPDzGwTJmYSTw" rel="noopener ugc nofollow" target="_blank"> <em class="mc">“自动检测:表中数据驱动的错误检测”</em> </a>中提出的思想，自动检测表格数据中的格式错误。</p><blockquote class="md me mf"><p id="f8db" class="lg lh mc li b lj lk ju ll lm ln jx lo mg lq lr ls mh lu lv lw mi ly lz ma mb im bi translated"><a class="ae ky" href="https://mailchi.mp/d2d2d4a109b5/learning-rate-newsletter" rel="noopener ugc nofollow" target="_blank">学习率</a>是为那些对AI和MLOps的世界感到好奇的人准备的时事通讯。你会在每周五收到我关于最新人工智能新闻和文章的更新和想法。在这里订阅<a class="ae ky" href="https://mailchi.mp/d2d2d4a109b5/learning-rate-newsletter" rel="noopener ugc nofollow" target="_blank"/>！</p></blockquote><h1 id="4be2" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">问题陈述</h1><p id="2731" class="pw-post-body-paragraph lg lh it li b lj nb ju ll lm nc jx lo lp nd lr ls lt ne lv lw lx nf lz ma mb im bi translated">损坏的数据或丢失的值会对分析管道产生严重的负面影响。垃圾输入垃圾输出这个短语简洁地表达了这个问题。<strong class="li iu">然而，由于这些错误的异质性，检测这些错误可能是一个非常具有挑战性的问题；简单的打字错误、格式错误、与陈旧数据的集成、拒绝约束等。</strong></p><p id="c616" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">为了解决这个问题，数据科学家设计了许多技术，大致分为两类:<em class="mc">单列</em>方法，用于检测单个列中发生的错误；以及<em class="mc">多列</em>方法，用于识别诸如拒绝约束之类的违规。</p><blockquote class="ng"><p id="3596" class="nh ni it bd nj nk nl nm nn no np mb dk translated">错误检测技术大致分为两类:单列和多列方法。</p></blockquote><p id="85c4" class="pw-post-body-paragraph lg lh it li b lj nq ju ll lm nr jx lo lp ns lr ls lt nt lv lw lx nu lz ma mb im bi translated">在这个故事中，我们关注一个单列方法，并讨论如何自动检测格式错误。事实证明，格式错误不仅会影响下游分析结果的质量，还会彻底破坏自动化管道。假设有一个数据列，其格式为<code class="fe nv nw nx ny b">03/11/2020</code>，并且有一个使用格式<code class="fe nv nw nx ny b">02.11.2020</code>的值。最好的情况是提取日期的自动化作业会抛出异常。最坏的结果将会产生难以调试的逻辑错误。</p><p id="0688" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">让我们来讨论这个问题的定义。给定一个结构化数据集，我们构造一个包含其列的集合。<strong class="li iu">我们想要的是检测单个列中存在低概率的值。</strong>在上述示例中，如果大部分日期符合第一种格式，我们希望为遵循不同日期模式的值分配低概率。</p><p id="b30f" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><strong class="li iu">天真的解决方案</strong></p><p id="ab78" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们生活在大数据时代，因此，一个解决方案是收集大量的表格数据(如维基百科表格、公开可用的excel表格等)。)并提取一个集合<code class="fe nv nw nx ny b">C</code>，它包含这个集合中存在的所有列。</p><p id="bd0f" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们希望这些列在很大程度上是干净的，因此，它们可以为两个值<code class="fe nv nw nx ny b">v, u</code>的列内共现提供良好的统计测量。<strong class="li iu">直觉上，如果两个值</strong> <code class="fe nv nw nx ny b"><strong class="li iu">v,u</strong></code> <strong class="li iu">在列中频繁共存，那么它们应该是兼容的。</strong></p><p id="7ee5" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">为此，我们可以使用一种叫做<em class="mc">逐点互信息</em> (PMI) <em class="mc">的统计度量。首先，我们计算在列中遇到值<code class="fe nv nw nx ny b">v</code>的概率。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/a1a498745277ab8b1851f184de511320.png" data-original-src="https://miro.medium.com/v2/resize:fit:422/format:webp/1*1bKXGpwO3phVqk36L6wvKQ.png"/></div></figure><p id="8fa4" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在该公式中，<code class="fe nv nw nx ny b">c(v)</code>表示值为<code class="fe nv nw nx ny b">v</code>的列数，而<code class="fe nv nw nx ny b">|C|</code>是列数。相应地，我们计算两个值<code class="fe nv nw nx ny b">v,u</code>同时出现的概率。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/f83f779ca60c5a1b82360e035e9b551b.png" data-original-src="https://miro.medium.com/v2/resize:fit:566/format:webp/1*b3Rb8LVCc9Totvm2C9Q5XA.png"/></div></figure><p id="9a3b" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">现在，<code class="fe nv nw nx ny b">c(u,v)</code>表示包含<code class="fe nv nw nx ny b">u</code>和<code class="fe nv nw nx ny b">v</code>的列数。我们现在准备计算值<code class="fe nv nw nx ny b">v,u</code>的PMI。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/bc825d823e7d45aaab4fa05ec4037134.png" data-original-src="https://miro.medium.com/v2/resize:fit:826/format:webp/1*bqOwG6zysqqCtOvZCfwnag.png"/></div></figure><p id="d230" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">结果范围从负无穷大到正无穷大。因此，我们通过除以<code class="fe nv nw nx ny b">-log p(v,u)</code>得到标准化的PMI (NPMI)来标准化它。<strong class="li iu">注意，如果</strong> <code class="fe nv nw nx ny b"><strong class="li iu">v</strong></code> <strong class="li iu">和</strong> <code class="fe nv nw nx ny b"><strong class="li iu">u</strong></code> <strong class="li iu">是偶然同现</strong> <code class="fe nv nw nx ny b"><strong class="li iu">p(u,v)</strong></code> <strong class="li iu">等于</strong> <code class="fe nv nw nx ny b"><strong class="li iu">p(v)p(u)</strong></code> <strong class="li iu">，则比值为</strong> <code class="fe nv nw nx ny b"><strong class="li iu">1</strong></code> <strong class="li iu">和PMI </strong> <code class="fe nv nw nx ny b"><strong class="li iu">0</strong></code> <strong class="li iu">为无相关性。另一方面，如果这些值频繁地同时出现并且正相关，则PMI大于</strong><code class="fe nv nw nx ny b"><strong class="li iu">0</strong></code><strong class="li iu">；否则，PMI取值小于</strong> <code class="fe nv nw nx ny b"><strong class="li iu">0</strong></code> <strong class="li iu">。</strong></p><p id="eb24" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">让我们看一个具体的例子。让<code class="fe nv nw nx ny b">v = 1</code>和<code class="fe nv nw nx ny b">u = 2</code>。假设我们的集合<code class="fe nv nw nx ny b">C</code>中有<code class="fe nv nw nx ny b">100M</code>列，我们有<code class="fe nv nw nx ny b">c(v) = 1M</code>、<code class="fe nv nw nx ny b">c(u) = 2M</code>、<code class="fe nv nw nx ny b">c(u,v) = 500K</code>。我们可以计算出<code class="fe nv nw nx ny b">p(v) = 0.01</code>、<code class="fe nv nw nx ny b">p(u) = 0.02</code>和<code class="fe nv nw nx ny b">p(u,v) = 0.005</code>。有了这些值，我们可以计算出NPMI等于<code class="fe nv nw nx ny b">0.6</code>，它大于<code class="fe nv nw nx ny b">0</code>。<strong class="li iu">我们可以直观地说，价值观</strong> <code class="fe nv nw nx ny b"><strong class="li iu">u</strong></code> <strong class="li iu">和</strong> <code class="fe nv nw nx ny b"><strong class="li iu">v</strong></code> <strong class="li iu">高度契合。如果这两个值中的一个是很少发生的错误，你可以试试会发生什么。</strong></p><h1 id="e865" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">泛化树和泛化语言</h1><p id="9117" class="pw-post-body-paragraph lg lh it li b lj nb ju ll lm nc jx lo lp nd lr ls lt ne lv lw lx nf lz ma mb im bi translated">我们有一个有希望的解决方案，但这是一个幼稚的方案。例如，假设我们有两个日期:<code class="fe nv nw nx ny b">03.17.2019</code>和<code class="fe nv nw nx ny b">03.18.2019</code>。这些看起来非常适合出现在同一列中，因为它们符合相同的日期模式。尽管如此，没有什么能保证我们会在同一列中看到这些精确的值，不管我们的列集<code class="fe nv nw nx ny b">|C|</code>有多大。因此，我们的方法会将它们标记为导致许多假阳性的潜在错误。稀疏是这里的一个问题。</p><p id="4bc5" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">解决方案是将值概括成模式；我们可以将它们归纳为类似于<code class="fe nv nw nx ny b">\d{2}.\d{2}.\d{4}</code>的模式，而不是让值为<code class="fe nv nw nx ny b">03.17.2019</code>和<code class="fe nv nw nx ny b">03.18.2019</code>。现在，只要一个具有这种日期格式的列就可以给出我们想要的信息。我们可以使用<em class="mc">泛化树</em>和<em class="mc">泛化语言</em>来实现这种类型的泛化。下图给出了一个泛化树的示例。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/11ee70c6c90d8698ff16436cd707a979.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f9BoOdqYGzTdcowFjQwV9w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">泛化树</p></figure><p id="ad72" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">从那棵树，我们可以实例化许多泛化语言。我们可以认为泛化语言是一个将任意输入映射到泛化树任意层的函数。为了更好地理解它，让我们构建两个由图中的树派生的一般化语言。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/07efa9ce38b9f533e9e92afa8c419bf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/1*TC_Sk74CPDvUPOhsjpR0iQ.png"/></div></figure><p id="1f77" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">第一种语言会将<code class="fe nv nw nx ny b">03.17.2019</code>转化为<code class="fe nv nw nx ny b">\A{2}.\A{2}.\A{4}</code>。看来我们已经解决了我们的问题，对吗？嗯，不完全是；让我们看看另一种语言的定义。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/5d671e78d3c4f8f378b96f918df7e4b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*jTVi0-ixHUSRN6aijU7k1A.png"/></div></figure><p id="afce" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">使用第二种语言<code class="fe nv nw nx ny b">03.17.2019</code>变成了<code class="fe nv nw nx ny b">\D{2}\S\D{2}\S\D{4}</code>。但是<code class="fe nv nw nx ny b">03-17-2019</code>呢？泛化语言2将其转换成完全相同的模式。我们无法发现这里的问题。正如我们所见，选择正确的语言至关重要。</p><h1 id="b80d" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">权衡取舍</h1><p id="842f" class="pw-post-body-paragraph lg lh it li b lj nb ju ll lm nc jx lo lp nd lr ls lt ne lv lw lx nf lz ma mb im bi translated">上一节的例子展示了为每种情况选择正确语言的重要性。请注意，我们可以选择多种语言，然后找到一种巧妙的方法来汇总结果。</p><p id="6b49" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">无论如何，有两个问题我们需要考虑:</p><ul class=""><li id="30bf" class="of og it li b lj lk lm ln lp oh lt oi lx oj mb ok ol om on bi translated"><em class="mc">敏感性与鲁棒性</em>:正如我们所看到的，<strong class="li iu">一种语言越一般化，它就越能以牺牲敏感性为代价对抗稀疏性。</strong>例如，如果一种语言将所有东西都推广到根级别(All [A])，我们可以缓解稀疏性问题，但这样我们将无法捕捉任何格式差异。在另一个极端，如果我们将所有东西都推广到叶子级别，我们最终会得到一个高度敏感的语言，由于数据稀疏，它会产生许多误报。</li><li id="276d" class="of og it li b lj oo lm op lp oq lt or lx os mb ok ol om on bi translated"><em class="mc">内存问题</em>:很明显，不同的泛化语言消耗不同的内存量。<strong class="li iu">一种语言越概括，它需要的内存空间就越少。</strong>另一方面，一种将一切都推广到叶子级别的语言需要数百千兆字节的内存。</li></ul><p id="4dc3" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">因此，这个问题实际上是一个约束优化难题:<strong class="li iu">给定一个泛化树，选择特定数量的泛化语言，这些语言可以捕获不同类型的格式错误，服从一个精度度量和内存预算。</strong></p><h1 id="fcbe" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">结论</h1><p id="f63c" class="pw-post-body-paragraph lg lh it li b lj nb ju ll lm nc jx lo lp nd lr ls lt ne lv lw lx nf lz ma mb im bi translated">在这个故事中，我们提出了一个由和何提出的想法，并把它用于自动检测结构化数据集中的格式错误。我们展示了如何使用逐点互信息解决这个问题，并给出了泛化树和泛化语言的定义。</p><p id="6b57" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">最后，我们得出结论，我们的问题归结为约束优化的挑战:给定一个泛化树，选择特定数量的泛化语言，这些语言可以捕获不同类型的格式错误，服从精度度量和内存预算。这个问题的建议解决方案可以在下面的故事中找到。</p><div class="ot ou gp gr ov ow"><a rel="noopener follow" target="_blank" href="/how-to-auto-detect-errors-in-a-dataset-part-ii-683b114865be"><div class="ox ab fo"><div class="oy ab oz cl cj pa"><h2 class="bd iu gy z fp pb fr fs pc fu fw is bi translated">如何使用泛化语言自动检测数据集中的错误</h2><div class="pd l"><h3 class="bd b gy z fp pb fr fs pc fu fw dk translated">使用远程监督和汇总预测结果生成验证数据，就像大海捞针一样。</h3></div><div class="pe l"><p class="bd b dl z fp pb fr fs pc fu fw dk translated">towardsdatascience.com</p></div></div><div class="pf l"><div class="pg l ph pi pj pf pk ks ow"/></div></div></a></div><blockquote class="md me mf"><p id="962e" class="lg lh mc li b lj lk ju ll lm ln jx lo mg lq lr ls mh lu lv lw mi ly lz ma mb im bi translated"><strong class="li iu">我叫Dimitris Poulopoulos，是希腊比雷埃夫斯大学<em class="it"/></strong><a class="ae ky" href="https://bigdatastack.eu/" rel="noopener ugc nofollow" target="_blank"><strong class="li iu">BigDataStack</strong></a><strong class="li iu"><em class="it"/>的机器学习研究员和博士(c)。我曾为欧洲委员会、欧盟统计局、国际货币基金组织、欧洲中央银行、经合组织和宜家等主要客户设计和实施人工智能和软件解决方案。如果你有兴趣阅读更多关于机器学习、深度学习和数据科学的帖子，请在twitter上关注我的</strong><a class="ae ky" href="https://medium.com/@dpoulopoulos" rel="noopener"><strong class="li iu"/></a><strong class="li iu"/><a class="ae ky" href="https://www.linkedin.com/in/dpoulopoulos/" rel="noopener ugc nofollow" target="_blank"><strong class="li iu">LinkedIn</strong></a><strong class="li iu">或</strong><a class="ae ky" href="https://twitter.com/james2pl" rel="noopener ugc nofollow" target="_blank"><strong class="li iu">@ james2pl</strong></a><strong class="li iu">。</strong></p></blockquote></div></div>    
</body>
</html>