<html>
<head>
<title>Design Patterns for MongoDB</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MongoDB的设计模式</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/design-patterns-for-mongodb-894767315905?source=collection_archive---------6-----------------------#2020-02-14">https://towardsdatascience.com/design-patterns-for-mongodb-894767315905?source=collection_archive---------6-----------------------#2020-02-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9dcf" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">每个全栈开发人员在构建MongoDB模式时需要做出的设计决策</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/654c2238a95722a8507b2425038e3c8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IectJw0-XunCx9xedifD4w.png"/></div></div></figure><p id="0ecc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">自从计算出现以来，数据一直在增长，这对存储、处理和分析技术的需求产生了直接影响。在过去的十年中，开发人员已经从SQL数据库转移到NoSQL数据库，MongoDB作为企业应用程序世界中的运营数据存储库，在受欢迎程度方面占据了主导地位。</p><p id="fc74" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你读过我最近的文章或者亲自了解我，你可能会意识到我是多么重视软件架构和模式。大多数人认为它们只适用于服务器端。我真的相信后端设计不应该是事后的想法，而是架构的关键部分。糟糕的设计选择明显影响了解决方案的可伸缩性和性能。</p><p id="1487" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，今天我将向您介绍一些<strong class="kw iu">实用的</strong> MongoDB设计模式，任何全栈开发人员在使用MEAN均值技术集合时都应该了解这些模式:</p><ul class=""><li id="01ea" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated"><a class="ae lq" href="#8739" rel="noopener ugc nofollow">多态模式</a></li><li id="ba1e" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated"><a class="ae lq" href="#464d" rel="noopener ugc nofollow">聚合数据模型</a></li></ul><pre class="kj kk kl km gt mf mg mh mi aw mj bi"><span id="1010" class="mk ml it mg b gy mm mn l mo mp">❗️<strong class="mg iu">Assumption: </strong>Basic familiarity with MongoDB is necessary, so is some understanding of relational modelling (because we will refer to SQL as a contrasting approach).</span></pre></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="8739" class="mx ml it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">宏伟的计划(或模式😄)的东西</h1><p id="db46" class="pw-post-body-paragraph ku kv it kw b kx no ju kz la np jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">通常，我们认为MongoDB是一个无模式数据库，但这并不完全正确！它确实有模式，但是它是动态的，也就是说，该模式不在相同集合的文档上实施，相反，它具有改变和变形的能力；这就是为什么它被称为多态模式。这意味着不同的数据集可以存储在一起，这是蓬勃发展的非结构化大数据的竞争优势。</p><h2 id="e09a" class="mk ml it bd my nt nu dn nc nv nw dp ng ld nx ny ni lh nz oa nk ll ob oc nm od bi translated">遗传和多态性</h2><p id="2c80" class="pw-post-body-paragraph ku kv it kw b kx no ju kz la np jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">特别是当涉及到面向对象编程(OOP)和继承时，MongoDB的多态功能变得非常方便，因为开发人员可以将同一层次结构(父子)的不同类的实例序列化到同一集合中，然后将它们反序列化为对象。</p><p id="9a7a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这在关系数据库中不是很直接，因为表有固定的模式。例如，考虑一个交易系统:一个<code class="fe oe of og mg b">Security</code>基类可以派生为<code class="fe oe of og mg b">Stock</code>、<code class="fe oe of og mg b">Equity</code>、<code class="fe oe of og mg b">Option</code>等。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/d8e874b43b0c1ef68c52149102cb84fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/format:webp/1*KxCFT38rsFYF1vVIQlQCHA.png"/></div></figure><p id="ad41" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在MongoDB中，我们可以将派生类型存储在一个名为<code class="fe oe of og mg b">Security</code>的集合中，并在每个文档上添加一个鉴别器(<code class="fe oe of og mg b">_t</code>)，而在关系数据库中，我们有以下建模选择:</p><ul class=""><li id="af73" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated">包含<code class="fe oe of og mg b">Stock</code>、<code class="fe oe of og mg b">Equity</code>、<code class="fe oe of og mg b">Option</code>字段联合的单个表，产生一个<strong class="kw iu">稀疏填充的</strong>模式。</li><li id="3474" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">三个表，分别对应<code class="fe oe of og mg b">Stock</code>、<code class="fe oe of og mg b">Equity</code>、<code class="fe oe of og mg b">Option</code>的具体实现，导致<strong class="kw iu">冗余</strong>(因为<code class="fe oe of og mg b">Security</code>属性有重复的基础信息)，以及<strong class="kw iu">检索所有类型证券的复杂查询</strong>。</li><li id="835d" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">一个表用于<code class="fe oe of og mg b">Security</code>的公共内容，三个表用于<code class="fe oe of og mg b">Stock</code>、<code class="fe oe of og mg b">Equity</code>、<code class="fe oe of og mg b">Option</code>，它们将有一个<code class="fe oe of og mg b">SecurityID</code>，并且将只包含各自的属性。这个选项解决了冗余问题，但是查询仍然会变得复杂。</li></ul><p id="9e40" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如您所见，这里包含的代码比多态MongoDb集合中的多得多！</p><h2 id="f09c" class="mk ml it bd my nt nu dn nc nv nw dp ng ld nx ny ni lh nz oa nk ll ob oc nm od bi translated">图式进化</h2><p id="d142" class="pw-post-body-paragraph ku kv it kw b kx no ju kz la np jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">生活中唯一不变的事情就是变化——这当然适用于数据库模式，当涉及到传统的关系数据库系统时，它经常会带来挑战和一些麻烦。一个表格模式的致命弱点是，对一个表的小改动会引起整个数据库的连锁反应，并且会影响到服务器端的应用程序代码。</p><p id="5d03" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">典型的方法是停止应用程序，进行备份，运行复杂的<strong class="kw iu">迁移</strong>脚本以支持新模式，发布新版本的应用程序以支持新模式，然后重启应用程序。由于持续部署(CD)负责该版本的应用程序方面，需要<strong class="kw iu">长时间停机</strong>的最耗时任务被限制在数据库迁移上。一些在大表上执行的<code class="fe oe of og mg b">ALTER</code>命令甚至需要几天才能完成…</p><p id="b5a4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，在MongoDB中，向后兼容性是现成的，所以开发人员在服务器端代码本身中考虑这些变化。一旦应用程序被更新以处理缺少字段的情况，我们就可以在后台迁移正在讨论的集合，同时应用程序还在运行(假设涉及不止一个节点)。当整个集合被迁移时，我们可以替换我们的应用程序代码来真正忘记旧字段。</p><p id="ef00" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">数据库设计不是一成不变的，在遗留的表格数据库中，模式更改可能会令人烦恼(如果不是瘫痪的话)，所以MongoDB的多态特性确实非常强大。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/e152cd5587a8cdb7dcbddbe035c463f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/1*auS-d6T1KiNF-MYr_5o2lg.gif"/></div></figure></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="464d" class="mx ml it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">嵌入还是不嵌入:这是个问题！</h1><p id="ed53" class="pw-post-body-paragraph ku kv it kw b kx no ju kz la np jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">如果你有任何OOP经验，你一定在你的职业生涯中遇到过Eric Evan的经典著作<a class="ae lq" href="https://www.amazon.co.uk/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/" rel="noopener ugc nofollow" target="_blank">领域驱动设计</a>，它介绍了<strong class="kw iu">集合模型</strong>。聚合是我们作为一个单元进行交互的数据集合，通常比传统的行/记录具有更复杂的结构，即它可以包含嵌套列表、字典或其他复合类型。</p><p id="35ea" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">仅在单个聚合的内容中支持原子性；换句话说，聚集形成了一个<a class="ae lq" href="https://en.wikipedia.org/wiki/ACID" rel="noopener ugc nofollow" target="_blank"> ACID操作</a>的边界(阅读MongoDB手册中的<a class="ae lq" href="https://docs.mongodb.com/manual/core/write-operations-atomicity/" rel="noopener ugc nofollow" target="_blank">)。处理聚合间的关系比聚合内的关系更困难:<strong class="kw iu">连接</strong>在内核中不被直接支持，而是在应用程序代码中或者用有点复杂的</a><a class="ae lq" href="https://docs.mongodb.com/manual/aggregation/" rel="noopener ugc nofollow" target="_blank">聚合管道</a>框架来管理。</p><p id="f5a6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本质上，在是否将<strong class="kw iu">相关对象嵌入另一个</strong>相关对象或者<strong class="kw iu">通过ID引用</strong>相关对象上有一个很好的平衡，并且作为建模中的大多数事情，没有关于如何做出这个决定的一站式解决方案。它在很大程度上是特定于上下文的，因为它取决于应用程序如何与数据交互。</p><p id="abc6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们继续之前，我们需要了解嵌入的优势是什么:</p><pre class="kj kk kl km gt mf mg mh mi aw mj bi"><span id="aece" class="mk ml it mg b gy mm mn l mo mp">🔴 The main reason for embedding documents is read performance which is connected to the very nature of the way <strong class="mg iu">computer disks</strong> are built: when looking for a particular record, they may take a while to locate it (high latency); but once they do, accessing any additional bytes happens fast (high bandwidth). So collocating related information makes sense as it can be retrieved in one go.</span><span id="a63d" class="mk ml it mg b gy oj mn l mo mp">🔴 Another aspect is that it reduces the <strong class="mg iu">round trips</strong> to the database that we had to program in order to query separate collections.</span></pre></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><p id="c274" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，让我们根据两个实体之间的关系类型，探讨一些在设计MongoDB模式时需要考虑的问题:</p><h2 id="7e11" class="mk ml it bd my nt nu dn nc nv nw dp ng ld nx ny ni lh nz oa nk ll ob oc nm od bi">1:1</h2><p id="ffaa" class="pw-post-body-paragraph ku kv it kw b kx no ju kz la np jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">一对一关系是一种描述两个实体之间关系的基数类型，其中实体A中的一条记录与实体b中的一条记录相关联。它可以通过两种方式建模:将关系嵌入为子文档，或者链接到单独集合中的文档(没有强制外键约束，因此关系只存在于应用程序级架构中)。这完全取决于应用程序访问数据的方式、频率以及数据集的生命周期(例如，如果实体A被删除，实体B是否仍然存在？)</p><pre class="kj kk kl km gt mf mg mh mi aw mj bi"><span id="7743" class="mk ml it mg b gy mm mn l mo mp"><strong class="mg iu">Golden Rule #1:</strong> If an object B needs to be accessed on its own  (i.e. outside the context of the parent object A) then use reference, otherwise embed.</span></pre><h2 id="2807" class="mk ml it bd my nt nu dn nc nv nw dp ng ld nx ny ni lh nz oa nk ll ob oc nm od bi translated">1:N</h2><p id="9595" class="pw-post-body-paragraph ku kv it kw b kx no ju kz la np jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">一对多关系是指两个实体A和B之间的关系，其中一方可以有一个或多个到另一方的链接，而相反的是单边的。像1:1关系一样，它也可以通过利用嵌入或引用来建模。<br/>以下是需要考虑的主要因素:</p><p id="3b17" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果对象的嵌套数组将不受控制地增加，则不建议嵌入，因为:</p><ul class=""><li id="217f" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated">每个文档不能超过16MB。</li><li id="f7b2" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">需要为不断增长的文档分配新的空间，还需要更新索引，这会影响写入性能。</li></ul><p id="cc79" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这种情况下，引用是优选的，并且实体A和B被建模为独立的集合。然而，一个代价是我们需要执行第二次查询来获得实体B的细节，因此读取性能可能会受到影响。一个<strong class="kw iu">应用级连接</strong>来拯救我们:通过正确的<strong class="kw iu">索引</strong>(用于内存优化)和使用<strong class="kw iu">投影</strong>(用于减少网络带宽)，服务器端连接比推送到DB引擎的连接稍微贵一些。应该很少需要<code class="fe oe of og mg b">$lookup</code>操作符。如果我们需要它很多，有一个模式气味！</p><p id="654b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另一种选择是使用预聚合集合(充当<a class="ae lq" href="https://en.wikipedia.org/wiki/OLAP_cube" rel="noopener ugc nofollow" target="_blank"> OLAP立方体</a>)来简化其中一些连接。</p><pre class="kj kk kl km gt mf mg mh mi aw mj bi"><span id="5599" class="mk ml it mg b gy mm mn l mo mp"><strong class="mg iu">Golden Rule # 2:</strong> Arrays should not grow without bound.<br/>- If there are less than a couple of hundred narrow documents on the B side, it is safe to embed them;<br/>— If there are more than a couple of hundred documents on the B side, we don’t embed the whole document; we link them by having an array of B objectID references;<br/>— If there are more than a few thousand documents on the B side, we use a parent-reference to the A-side in the B objects.</span></pre><p id="a83d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">和</p><pre class="kj kk kl km gt mf mg mh mi aw mj bi"><span id="4eab" class="mk ml it mg b gy mm mn l mo mp"><strong class="mg iu">Golden Rule # 3:</strong> Application-level joins are common practice and not to be frowned upon; in these cases indexing selection makes or breaks the querying performance.</span></pre><p id="3f4c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> ❗️Denormalisation: </strong>使我们的文档非规范化的两个因素是:</p><ul class=""><li id="e1d6" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated">更新将不再是原子性的；</li><li id="46a5" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">高读写比(即经常被读取且很少被更新的字段是反规范化的良好候选)。</li></ul><h2 id="90cf" class="mk ml it bd my nt nu dn nc nv nw dp ng ld nx ny ni lh nz oa nk ll ob oc nm od bi translated">男:男</h2><p id="a3d0" class="pw-post-body-paragraph ku kv it kw b kx no ju kz la np jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">多对多关系是指两个实体A和B之间的关系，其中双方可以有一个或多个到另一方的链接。在关系数据库中，这些情况用连接表建模，然而在MongoDB中我们可以使用<strong class="kw iu">双向嵌入</strong>，所以我们查询A来搜索B对象的嵌入引用，然后用<code class="fe oe of og mg b">$in</code>操作符查询B来找到这些返回的引用(反过来也是可能的)。反之亦然。</p><p id="5ebe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里的复杂性来自于在A和B之间建立一个<strong class="kw iu">平衡</strong>，因为16MB的阈值也可能被打破。在这些情况下，建议使用单向嵌入。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/9fe3c8d947c40669c588ee34327f0db8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*voFoKHr8wAzf4lKdHAha2Q.png"/></div></div></figure></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="1193" class="mx ml it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">推荐阅读</h1><ul class=""><li id="7991" class="lr ls it kw b kx no la np ld ol lh om ll on lp lw lx ly lz bi translated"><a class="ae lq" href="https://www.amazon.co.uk/NoSQL-Distilled-Emerging-Polyglot-Persistence/dp/0321826620" rel="noopener ugc nofollow" target="_blank"> NoSQL蒸馏</a></li><li id="d32a" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated"><a class="ae lq" href="https://www.mongodb.com/blog/post/building-with-patterns-a-summary" rel="noopener ugc nofollow" target="_blank"> MongoDB大学:有模式的建筑</a></li><li id="4e22" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated"><a class="ae lq" href="https://www.slideshare.net/mongodb/mongodb-world-2019-raiders-of-the-antipatterns-a-journey-towards-fixing-schema-mistakes-in-mongodb" rel="noopener ugc nofollow" target="_blank"> MongoDB反模式(MongoDb World 2019) </a></li><li id="c503" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated"><a class="ae lq" href="https://dddcommunity.org" rel="noopener ugc nofollow" target="_blank">领域驱动设计</a></li></ul></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="1f30" class="mx ml it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">收场白</h1><p id="5ea5" class="pw-post-body-paragraph ku kv it kw b kx no ju kz la np jx lc ld nq lf lg lh nr lj lk ll ns ln lo lp im bi translated">所有这些的结果是，MongoDB使我们能够设计我们的模式来满足我们的应用程序的需求，这样我们就可以充分利用它们。这种灵活性非常强大，但是这种力量需要根据我们在应用程序中使用的模式来加以利用。—我们需要记住，性能问题通常是由糟糕的模式设计引起的，因此，第一次就把它做好是至关重要的。</p><p id="1c9f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢阅读！</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><p id="0738" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="oo">我经常在媒体上写关于领导力、技术&amp;的数据——如果你想阅读我未来的帖子，请</em><a class="ae lq" href="https://medium.com/@semika" rel="noopener"><em class="oo">‘关注’我</em> </a> <em class="oo">！</em></p></div></div>    
</body>
</html>