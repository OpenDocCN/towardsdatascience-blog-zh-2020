# 使用 Python 绘制栅格数据散点图

> 原文：<https://towardsdatascience.com/raster-data-scatter-plot-using-python-4bcdc8286769?source=collection_archive---------17----------------------->

## 地理信息系统

## 在某些情况下，您可能需要查看两个栅格数据集之间的关系。在 GUI 应用程序中这样做可能会令人恼火，因为存在滞后、不一致等问题。处理大分辨率栅格时甚至更糟。使用 Python 编写脚本可能是一种替代解决方案，可以为您提供可靠、快速、自动化和一致的结果。本文将指导您使用基本和流行的 Python 库来显示两个栅格数据集的散点图。

# 介绍

栅格数据基本上是一种图像或矩阵。作为图像或矩阵，它由数组组成，可以形成数据框或电子表格。甚至可以在 Adobe Photoshop 或者 [Ms. Excel](https://excelcharts.com/) 中可视化光栅数据！每个栅格像元包含一个数值，该数值可以表示任何内容，具体取决于上下文。该值可以是高程、土地覆盖指数、NDVI(归一化植被指数)，具体取决于具体环境。

![](img/480920813f78878e0a880157e3b77776.png)

栅格数据(来源:作者，2020 年)

在某些情况下，我们可能想要查看栅格之间的关系。比如坡度对绿化有影响吗？NDVI 和 NDBI 是什么关系？与交通设施的距离是否与二氧化氮或其他污染气体相关？

虽然一些软件提供了显示两个栅格数据之间散点图的方法，但我总是觉得这很令人恼火。显示绘图需要大量的 ram 和 CPU 资源，因此经常会导致延迟。窗格需要时间来加载，更改内容或绘图属性也需要时间来加载。此外，有时，我们需要自动化我们的工作，而不必做繁琐的任务，如布局和美化我们的图表一次又一次。当我们处理需要更多 RAM 或 CPU 的高分辨率栅格时，情况会变得更糟！

幸运的是，Python 有一种方法来完成这样的任务，而不必做那些繁琐的事情。使用 Python，在显示散点图时也可以减少对 RAM 和 CPU 容量的需求，因为不需要 GUI，并且可以最小化显示。我想分享这个过程，因此，**本文的主要目的是向您展示如何预处理栅格数据**(使用 GIS) **并使用 Python 将它们显示在散点图中。**

# 逻辑过程

散点图需要 2 个输入，并且**两个输入都需要是一维的。**栅格数据，就其本质而言，是二维数据，所以我们需要将数据重塑为一维。这种整形是通过拆纱完成[。](https://www.w3resource.com/numpy/manipulation/ravel.php)

在拆纱之前，在我们开始拆纱过程之前，必须满足一些标准。必须确保栅格的每个像元在空间上对齐。这确保了一维松散的数据是合乎逻辑的，并且类似于对应关系。如果两个栅格数据之间存在空间不匹配，则生成的散点图将绘制错误的绘图。此外，关于标准将在**数据标准**部分中解释。

总之，raveling 产生一个长度为列乘以行的一维数组。确保两个栅格数据具有相同的列和行意味着确保行进数据的长度精确。

![](img/8ef2146a4571ac4dbf217cc7668b8539.png)

栅格数据散点图的思维过程(来源:作者，2020)

# 先验知识和要求

如果你想继续，建议你理解

*   **GIS 分析的基础**，做一些栅格掩蔽/提取
*   **地理空间数据类型**(栅格数据)，了解栅格数据的属性
*   **投影系统**，转换栅格数据的空间度量。
*   **Python** 。库: **NumPy** (处理数组) **matplotlib** (绘图和数据可视化)，图像分析(使用 **PIL(枕头)**)。嗯，我们只需要图像分析部分来读取光栅数据并将其转换为 NumPy 数组，因此只要您可以读取图像光栅数据，它就会进行检查。我推荐 PIL，因为 OpenCV 或 Matplotlib Imread 不能直接完成这项工作，因为我们将处理单波段图像。

# 数据标准

如果我们要将两个栅格绘制成散点图，则必须满足一些标准:

*   **这两个栅格必须具有相同的维度。**这意味着两个栅格必须具有相同数量的**列和行，以及相同的像素大小**。这个标准很重要，因为阵列之间的对应关系必须一致，这样每个单元都有一个到另一个单元的连接。绘图时，对于一个 X 输入会返回一个 Y 值，在只有 1 个 X 输入的情况下，如果返回 2 个 Y 值，会比较混乱；函数不是这样工作的，散点图就是一个函数。
*   **这两个栅格必须在空间上对齐并重叠。**一个散点图并不表示空间对齐和重叠，因此这一标准必须使用 GIS 进行独立评估。
*   **这两个栅格必须具有相同的坐标参考。我不认为这很关键，只要列数和行数相同。应该首先满足这个标准，因为我们必须匹配像素大小和空间相邻性。**
*   **如果一个栅格中的像元为空值，则另一个栅格的对应像元应改为空值。**还是那句话，标绘这样的数据不符合逻辑。例如，一个 X 输入返回一个空值…我们应该如何绘制？Null 不是 0，所以最好直接删除这个值。

# 利用地理信息系统进行数据预处理:符合标准

如果您的栅格数据不符合标准(通常不符合)，则必须进行一些地理空间预处理。我将解释如何使用 ArcGIS 工具集，对于其他软件，如 QGis，甚至是 Python 包，如 RasterIO 或 Geopandas，应该有等效的工具。请原谅我…

**假设我们有 2 个栅格:X 轴栅格和 Y 轴栅格。这两个栅格彼此重叠**，我们想要概述这种关系。我们可以把 x 轴栅格想象成 NDVI 栅格，把 Y 轴栅格想象成高程数据 aster。由于来源和采集方法不同，这两种栅格具有不同的属性。因此，需要进行一些预处理。

## **预处理步骤 1/3:决定一个光栅数据参考(例如 X 轴光栅)**

选择一个参考栅格。我更喜欢最低比例的栅格(最低分辨率；最小数量的列和行)。您可以在 GIS 软件中查看属性，并找到栅格的列、行和像素大小。在本例中，我的栅格参考(我将其命名为 X 轴栅格)有 203 列、210 列和 158(米)像素大小。

![](img/8c7ec1d0ea848c543847c34dce38a750.png)

x 轴栅格属性(来源:作者)

## **预处理步骤 2/3Y 轴光栅概述**

例如，Y 轴栅格具有不同的属性，如下图所示。我们必须对此 Y 轴栅格进行更改，使其具有与 X 轴栅格参考相同的属性。

![](img/5f5c52b8b85ac3ee9ed8d25c7a2c5420.png)

预处理前的 y 轴(来源:作者)

## **预处理步骤 3/3:使用 GIS 对 Y 轴和 X 轴栅格进行空间处理**

有 3 个主要过程。

*   [**将**](https://pro.arcgis.com/en/PRO-APP/TOOL-REFERENCE/DATA-MANAGEMENT/project.htm)**Y 轴光栅投影到与 X 轴光栅相同的坐标系中。**如果 Y 轴光栅具有相同的坐标参考，则不需要该步骤。这保证了像素大小有相同的单位。在这种情况下，我的 Y 轴栅格具有非常小的像元大小，这是因为 Y 轴具有不同的投影参考。
*   [**重采样**](https://pro.arcgis.com/en/pro-app/tool-reference/data-management/resample.htm) **投影后的 Y 轴:**投影后，Y 轴光栅的像元大小应该与 X 轴光栅具有相同的度量，但它们可能大小不同。重采样聚合或插值 Y 轴值以调整 Y 轴分辨率，使其与 X 轴分辨率相同。所以…将 Y 轴栅格重采样到 X 轴栅格的分辨率。
*   **双重** [**通过相互屏蔽**](https://desktop.arcgis.com/en/arcmap/10.3/tools/spatial-analyst-toolbox/extract-by-mask.htm) **提取栅格:**双重屏蔽确保消除与非空值重叠的空值。所以，首先用 X 轴屏蔽 Y 轴(返回屏蔽的 Y 轴)，然后用屏蔽的 Y 轴提取 X 轴。**现在您应该有 2 个符合条件的预处理栅格了！屏蔽的 Y 轴栅格和屏蔽的 X 轴栅格。**
*   最后，**将这些栅格导出为 TIFF 格式**，32 位浮点像素类型，无数据值为-10(或任何其他数字！你必须注意这个没有数据值！)

![](img/0e8b745aef61d529775840271c820f30.png)

导出栅格(来源:作者)

# 使用 Python 散点图绘制栅格

现在，资料都准备好了，该做饭了。步骤真的很简单！

*   **定义拆纱功能。**读取光栅、清理光栅和移动光栅。函数声明缩短了脚本。
*   [**将**](https://www.w3resource.com/w3r_images/numpy-manipulation-ravel-function-image-1.png) **每个光栅数据分解成一维数组**(使用分解功能)
*   绘制每个散开的栅格！

我们将需要这些库:

*   Numpy 负责整理和管理数组
*   [枕](https://pypi.org/project/Pillow/2.2.1/)读取光栅
*   [Matplotlib](https://matplotlib.org/) 可视化散点图

## 绘图，步骤 1/3:定义松散函数

正如我在逻辑部分解释的，我们必须遍历每个栅格。我们将使用下面的 **fetch_data** 函数遍历栅格。 **fetch_data** 函数读取并清理光栅数据。清理很重要，因为 TIF 图像包含应该为空的值，但还不为空。清理会将这些值转换为空值，以便以后删除。 **fetch_data** 返回松散的、干净的、准备绘制的光栅。

## 绘图，步骤 2/3:分析数据

定义函数后，我们使用 fetch_data 函数移动 X 轴栅格和 Y 轴栅格。现在我们有了 x_data 和 y_data。

```
#path to each raster data
x_data_path = "folder/x_raster.tif"
y_data_path = "folder/y_raster.tif"#raveling the data
y_data = fetch_data(y_data_path)
X_data = fetch_data(x_data_path)
```

## 绘制，步骤 3/3:绘制数据

这部分只是 matplotlib 可视化基础。您可以使用简单的分散代码，如下所示。

```
import matplotlib.pyplot as plt
plt.rcParams["font.family"] = "Times New Roman"#Declaring the figure, and hiding the ticks' labels
fig, ax = plt.subplots(figsize=(15,8))
ax.set_yticklabels([])
ax.set_xticklabels([])#Actually Plotting the data
plt.scatter(x_data,y_data, s=0.1, c='black')#Making the graph pretty and informative!
plt.title("Raster Data Scatter Plot", fontsize=28)
plt.xlabel("X-Axis Raster", fontsize=22)
plt.ylabel("Y-Axis Raster", fontsize=22)
plt.show()
```

# 结果呢

使用上面的代码，我们应该有这个绘图结果。你有它！两个栅格的散点图！

![](img/34636941569ed12233b26c9fc113700a.png)

绘制栅格(来源:作者，2020 年)

# 结束语

绘图过程相当直接，但使用 GIS 的预处理是棘手的。在这种情况下，GIS 预处理需要人工监督，因此您必须充分了解并小心谨慎。

仅当栅格输入在空间上对齐时，松散才有效。这种空间排列可能是应该彻底检查的最重要的方面。这一步至关重要，因为只要维度相同，对数据进行分析和绘图总是会产生散点图。这种虚幻的散点图会产生误导，因为它没有任何空间对齐的指示，但本质上，它显示的是空间未对齐的信息。

例如，从技术上讲，34x78 维 10m 分辨率栅格可以用 78x34 维 10m 分辨率栅格进行绘制。拆开时，它们产生相同的一维长度，34x78=2652。您也可以从技术上绘制这些栅格，但它们没有任何意义。如果两个栅格不重叠，情况会更糟。

**因此，请始终仔细检查栅格数据是否在相同的维度上，并且在空间上对齐。祝你好运！**