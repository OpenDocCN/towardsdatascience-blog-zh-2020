<html>
<head>
<title>Virtual Background For Video Conferencing In Python and OpenCV — A Silly Approach</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python和OpenCV中视频会议的虚拟背景——一种愚蠢的方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/virtual-background-for-video-conferencing-in-python-and-opencv-a-silly-approach-5f5ad1a5abef?source=collection_archive---------24-----------------------#2020-03-26">https://towardsdatascience.com/virtual-background-for-video-conferencing-in-python-and-opencv-a-silly-approach-5f5ad1a5abef?source=collection_archive---------24-----------------------#2020-03-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="38d7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">用Python和OpenCV创建视频会议的虚拟背景。基本方法教程和思想。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/2ef0d03526f3906b51ce9127c34439a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hpgvHxikNXNg-qER"/></div></div><p class="lb lc gj gh gi ld le bd b be z dk translated"><a class="ae lf" href="https://unsplash.com/@the_roaming_platypus?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> timJ </a>在<a class="ae lf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="af9a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虚拟背景是目前远程工作的员工的热门话题之一。由于新冠肺炎疫情，我们中的一些人目前被隔离，许多人不得不进行视频通话，以便继续他们的工作。一些用于视频会议的软件工具允许设置虚拟背景，以便用户可以为接听这些电话营造更友好的氛围。</p><p id="8933" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">作为一名程序员，我第一次使用这样的虚拟背景时，自然被激起了兴趣。我想知道它是如何工作的。我能建立这样的虚拟背景吗？如果是的话，我该怎么做？<em class="ko">剧透:进展不顺利！尽管如此，我认为这是一个很好的教育练习，在研究这个话题的时候，我没有找到太多的信息。因此，正如我对所学的一切所做的那样，我决定把它记录在这里，也许其他人会从中受益。</em></p><p id="0d16" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，在本教程中，我们将尝试一种用计算机视觉技术构建虚拟背景的基本方法，使用Python和OpenCV。</p><h1 id="9a94" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">介绍</h1><p id="2134" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">这个项目的目标是拍摄一段视频，试着找出视频的背景和前景，去掉背景部分，用一张图片代替——虚拟背景。因为在这个项目中，我们将使用平凡的方法，我们将需要假设，在一般情况下，前景将有不同于背景的颜色。但是首先，让我们看看我们的工具是什么。</p><h2 id="d887" class="mj lh it bd li mk ml dn lm mm mn dp lq kb mo mp lu kf mq mr ly kj ms mt mc mu bi translated">计算机视觉</h2><p id="8419" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">计算机视觉是一个跨学科领域，研究计算机如何处理和(也许)理解图像和视频。我们说它是一个<em class="ko">跨学科</em>领域，因为它从不同学科(计算机科学、代数、几何等等)借用了很多概念，并将它们结合起来解决了很多不同的复杂任务，比如图像和视频中的<strong class="js iu">对象跟踪</strong>、<strong class="js iu">对象检测、</strong> <strong class="js iu">对象识别</strong>、<strong class="js iu">对象分割</strong>。</p><h2 id="7977" class="mj lh it bd li mk ml dn lm mm mn dp lq kb mo mp lu kf mq mr ly kj ms mt mc mu bi translated">OpenCV</h2><p id="3870" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated"><a class="ae lf" href="https://opencv.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> OpenCV </strong> </a>是为解决计算机视觉任务而构建的库。它是开源的，可用于几种编程语言，包括Python和C++。它有大量的计算机视觉功能，其中一些基于数学和统计方法，另一些基于机器学习。</p><h2 id="66dc" class="mj lh it bd li mk ml dn lm mm mn dp lq kb mo mp lu kf mq mr ly kj ms mt mc mu bi translated">计算机编程语言</h2><p id="bf28" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">如果您已经阅读了本文，那么您可能知道Python是什么😀</p><h1 id="f3e1" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">构建虚拟背景</h1><p id="df9c" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">我尝试的方法如下。我将展示每一步的代码片段，在文章的最后，您将看到完整的代码。</p><ol class=""><li id="6321" class="mv mw it js b jt ju jx jy kb mx kf my kj mz kn na nb nc nd bi translated">导入依赖项</li></ol><pre class="kq kr ks kt gt ne nf ng nh aw ni bi"><span id="cc3c" class="mj lh it nf b gy nj nk l nl nm">import numpy as np<br/>import cv2</span></pre><p id="aa94" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">2.从本地环境加载视频并初始化数据</p><pre class="kq kr ks kt gt ne nf ng nh aw ni bi"><span id="9297" class="mj lh it nf b gy nj nk l nl nm">ap = cv2.VideoCapture('video6.mp4')<br/>ret = True<br/>frameCounter = 0<br/>previousFrame = None<br/>nextFrame = None<br/>iterations = 0</span></pre><p id="45e0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">3.从本地环境加载替换背景图像</p><pre class="kq kr ks kt gt ne nf ng nh aw ni bi"><span id="0cab" class="mj lh it nf b gy nj nk l nl nm">backgroundImage = cv2.imread("image1.jpg")</span></pre><p id="2b93" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">4.逐帧分割视频</p><pre class="kq kr ks kt gt ne nf ng nh aw ni bi"><span id="b565" class="mj lh it nf b gy nj nk l nl nm">while (ret):<br/>	ret, frame = cap.read()</span></pre><p id="a3fb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">5.取每一对两帧</p><pre class="kq kr ks kt gt ne nf ng nh aw ni bi"><span id="e7b6" class="mj lh it nf b gy nj nk l nl nm">if frameCounter % 2 == 1:<br/>            nextFrame = frame</span><span id="23e9" class="mj lh it nf b gy nn nk l nl nm">        if frameCounter % 2 == 0:<br/>            frameCounter = 0<br/>            previousFrame = frame</span><span id="679a" class="mj lh it nf b gy nn nk l nl nm">        frameCounter = frameCounter + 1<br/>        iterations = iterations + 1</span></pre><p id="4a76" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">6.求两帧的绝对差值并转换成灰度-&gt;获取蒙版。</p><pre class="kq kr ks kt gt ne nf ng nh aw ni bi"><span id="b99c" class="mj lh it nf b gy nj nk l nl nm">if iterations &gt; 2:<br/>            diff = cv2.absdiff(previousFrame, nextFrame)<br/>            mask = cv2.cvtColor(diff, cv2.COLOR_BGR2GRAY)</span></pre><p id="b826" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每幅图像都由像素组成——你可以把它想象成一个由行和列组成的2D矩阵，矩阵中的每个单元都是图像中的一个像素(当然，对于彩色图像，我们有不止2个维度，但为了简单起见，我们可以忽略这一点)。</p><p id="a679" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们通过在第一幅图像中逐个像素地(在第一矩阵中逐个单元地)替换另一幅图像中的相应像素(在另一矩阵中的相应单元)来获得差异。</p><p id="ca21" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里有一个窍门:如果在两帧之间，一个像素没有被修改，那么结果当然会是<strong class="js iu"> 0 </strong>。<em class="ko">2帧之间像素怎么会不一样？</em>如果视频是完全静态的(图像中没有任何东西移动)，那么所有像素的每一帧之间的差异将为0，因为没有任何东西发生变化。<strong class="js iu">但是，如果图像中有物体移动，那么我们可以通过检测像素差异来识别物体在图像中的移动位置。我们可以假设，在视频会议中，移动的东西在前景中——也就是你——而静止的部分是背景。</strong></p><p id="fbbe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">还有这个<strong class="js iu"> 0 </strong>有什么重要的？图像中每个为0的像素将显示黑色，我们将利用这一点。</p><p id="dc1e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">7.找到遮罩中超过阈值的单元格—我选择了<strong class="js iu"> 3 </strong>作为阈值，但是您可以使用不同的值。较大的值将从背景中移除更多，但也可能从前景中移除更多。</p><pre class="kq kr ks kt gt ne nf ng nh aw ni bi"><span id="6def" class="mj lh it nf b gy nj nk l nl nm">th = 3<br/>            isMask = mask &gt; th<br/>            nonMask = mask &lt;= th</span></pre><p id="33bd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">8.创建一个空图像(每个单元格为0)，大小为两个帧中的任意一个。</p><pre class="kq kr ks kt gt ne nf ng nh aw ni bi"><span id="f5cd" class="mj lh it nf b gy nj nk l nl nm">result = np.zeros_like(nextFrame, np.uint8)</span></pre><p id="4083" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">9.调整背景图像的大小，使其与框架大小相同。</p><pre class="kq kr ks kt gt ne nf ng nh aw ni bi"><span id="1a18" class="mj lh it nf b gy nj nk l nl nm">resized = cv2.resize(backgroundImage, (result.shape[1], result.shape[0]), interpolation = cv2.INTER_AREA)</span></pre><p id="c79b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">10.对于遮罩中大于阈值的每个单元，从原始帧复制。</p><pre class="kq kr ks kt gt ne nf ng nh aw ni bi"><span id="0663" class="mj lh it nf b gy nj nk l nl nm">result[isMask] = nextFrame[isMask]</span></pre><p id="adcc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">11.对于低于阈值的遮罩中的每个单元格，从替换背景图像中复制。</p><pre class="kq kr ks kt gt ne nf ng nh aw ni bi"><span id="9f96" class="mj lh it nf b gy nj nk l nl nm">result[nonMask] = resized[nonMask]</span></pre><p id="c325" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">12.将结果帧保存到本地环境。</p><pre class="kq kr ks kt gt ne nf ng nh aw ni bi"><span id="cba8" class="mj lh it nf b gy nj nk l nl nm">cv2.imwrite("output" + str(iterations) + ".jpg", result)</span></pre><h1 id="ea2c" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">结果和结论</h1><p id="9cee" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">那么结果如何呢？老实说，我对这个结果有点失望。然后我做了更多的研究，原因变得更加明显。你需要更先进的方法来解决这个问题，大公司在这类问题上投入大量资源也就不足为奇了。</p><p id="4ba5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面是我试的视频截图。基本上就是我的手在墙前移动的视频。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi no"><img src="../Images/30828d582921c406fa1d07a98a560bdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*mJu-x-yuT-bZb7a_kEzW4w.jpeg"/></div><p class="lb lc gj gh gi ld le bd b be z dk translated">虚拟背景Python和OpenCV教程—输入</p></figure><p id="07f5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是输出图像的截图。作为背景，我用了一张我在罗马尼亚拉斯诺夫的照片。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi no"><img src="../Images/116ce9309df7cd40ea01724ad52f6102.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*1J0dI7EqLcfyQzO2P8cJqA.jpeg"/></div><p class="lb lc gj gh gi ld le bd b be z dk translated">虚拟背景Python和OpenCV教程—输出</p></figure><p id="a5d2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如我所说的，我对结果不是很满意。但是我对从这个项目中学到的东西很满意。这是一次有趣的学习经历，也是一种很好的方式来花时间处理我不习惯处理的概念。</p><h1 id="1e8f" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">创建虚拟背景的其他方法</h1><p id="7ef0" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">如果你认为一个问题非常复杂，需要你在计算机软件中看到的不寻常的智能水平，那么答案可能是机器学习。😀</p><p id="aaf6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">已经有深度学习模型可以执行这种任务。但是这样一个模型需要大量的数据集来训练和大量的处理能力，而在我写这篇文章的时候，我还没有这样的能力。这样的深度学习模型要解决的任务叫做图像分割。</p><p id="4fe7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一种方法是计算机视觉方法，用于寻找照相机和图像中的物体之间的距离。然后你可以建立一个阈值来区分前景和背景。在那之后，你可以使用我用来移除背景的相同遮罩，并引入一个新的遮罩。</p><p id="4d93" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">本文原载于</em> <a class="ae lf" href="https://programmerbackpack.com/virtual-background-python-opencv/" rel="noopener ugc nofollow" target="_blank"> <em class="ko">程序员背包博客</em> </a> <em class="ko">。如果你想阅读更多这类的故事，一定要访问这个博客。</em></p><p id="eafe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">非常感谢您阅读本文！对更多这样的故事感兴趣？在Twitter上关注我，地址是</em><a class="ae lf" href="https://twitter.com/b_dmarius" rel="noopener ugc nofollow" target="_blank"><em class="ko">@ b _ dmarius</em></a><em class="ko">，我会在那里发布每一篇新文章。</em></p></div></div>    
</body>
</html>