<html>
<head>
<title>Develop an Interactive Drawing Recognition App based on CNN — Deploy it with Flask</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">开发基于CNN的交互式绘图识别应用程序——使用Flask部署</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/develop-an-interactive-drawing-recognition-app-based-on-cnn-deploy-it-with-flask-95a805de10c0?source=collection_archive---------20-----------------------#2020-04-26">https://towardsdatascience.com/develop-an-interactive-drawing-recognition-app-based-on-cnn-deploy-it-with-flask-95a805de10c0?source=collection_archive---------20-----------------------#2020-04-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="605a" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">数据科学项目</h2><div class=""/><div class=""><h2 id="9c05" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">关于数据科学项目的基本技术的快速简单的教程。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/c8fc13054e29a5f1dcc62229364e6dbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MrU0UZm1gCXQsbc9"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@drieaugu?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Dries Augustyns </a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="17c1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">建立机器学习模型是一项常见的任务，你可能会觉得很舒服。然而，一旦你离线训练和测试的模型让你满意了，你该怎么做呢？你会如何向你的非技术型老板或客户展示它？你将如何在线部署它，以便其他人可以使用它？</p><p id="086f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在本文中，我将尝试解决那些在学校里通常不会详细讨论的问题，尽管这些问题是数据科学项目中非常重要的一部分。</p><p id="9041" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为此，我决定以一个<strong class="lk jd">绘图应用程序</strong>为例，它使用一个<strong class="lk jd">卷积神经网络</strong>模型对用户绘制的绘图进行分类。</p><p id="3290" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">工作流程如下:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/3ea0d00184afcb2176f3c466e9f9132b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xEsFewOr2FFT7imPWJNpKw.jpeg"/></div></div></figure><p id="af30" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我将首先介绍模型，然后描述应用程序的开发。通读之后，我希望本文对您未来的数据科学项目部署有所帮助！</p><p id="904b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">以下所有代码都可以在我的<a class="ae lh" href="https://github.com/hugom1997/Flask-Cnn-Recognition-App" rel="noopener ugc nofollow" target="_blank"> github </a>上找到。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="cb05" class="mm mn it bd mo mp mq mr ms mt mu mv mw ki mx kj my kl mz km na ko nb kp nc nd bi translated">CNN模型</h1><p id="e1ce" class="pw-post-body-paragraph li lj it lk b ll ne kd ln lo nf kg lq lr ng lt lu lv nh lx ly lz ni mb mc md im bi translated">这个项目的第一部分是准备数据和建立我们的模型！</p><p id="1085" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我已经决定使用来自<em class="nj">的数据，‘快，画！’</em>游戏中用户需要尽可能快地绘制任意对象。数据集在<a class="ae lh" href="https://console.cloud.google.com/storage/browser/quickdraw_dataset/full/numpy_bitmap/?pli=1" rel="noopener ugc nofollow" target="_blank">这里</a>可用。</p><p id="7ea0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我将我的用例集中在<em class="nj"> 6 </em>动物上:猫、长颈鹿、羊、蝙蝠、章鱼和骆驼，使任务成为<strong class="lk jd">多类分类</strong>。<strong class="lk jd"> </strong>下面是一个数据示例:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nk"><img src="../Images/c8d7f994208ca235cb7ce60d8d29bd31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l9ZpMJGQa7fqkQXmDNGnsQ.jpeg"/></div></div></figure><h2 id="0358" class="nl mn it bd mo nm nn dn ms no np dp mw lr nq nr my lv ns nt na lz nu nv nc iz bi translated"><strong class="ak">预处理</strong></h2><p id="20f5" class="pw-post-body-paragraph li lj it lk b ll ne kd ln lo nf kg lq lr ng lt lu lv nh lx ly lz ni mb mc md im bi translated">幸运的是，来自这个数据集的图像已经被预处理成统一的<em class="nj"> 28*28 </em>像素图像大小。以下是接下来的步骤:</p><ul class=""><li id="76d7" class="nw nx it lk b ll lm lo lp lr ny lv nz lz oa md ob oc od oe bi translated">我们需要结合我们的数据，以便我们可以使用它进行培训和测试。我只为这个模型使用了10 000个样本。</li><li id="a79b" class="nw nx it lk b ll of lo og lr oh lv oi lz oj md ob oc od oe bi translated">然后，我们可以分割要素和标注(X和y)。</li><li id="10db" class="nw nx it lk b ll of lo og lr oh lv oi lz oj md ob oc od oe bi translated">最后，我们按照通常的(<em class="nj">80–20</em>)比率在训练和测试之间分割数据。当灰度图像的像素位于0和255之间时，我们还归一化了<em class="nj"> 0 </em>和<em class="nj"> 1 </em> (X/255)之间的值。</li></ul><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">预处理. py</p></figure><h2 id="a9e1" class="nl mn it bd mo nm nn dn ms no np dp mw lr nq nr my lv ns nt na lz nu nv nc iz bi translated"><strong class="ak">架构</strong></h2><p id="2d92" class="pw-post-body-paragraph li lj it lk b ll ne kd ln lo nf kg lq lr ng lt lu lv nh lx ly lz ni mb mc md im bi translated">一旦一切准备就绪，让我们使用Keras建立我们的模型！该模型将具有以下结构:</p><ul class=""><li id="da9f" class="nw nx it lk b ll lm lo lp lr ny lv nz lz oa md ob oc od oe bi translated"><strong class="lk jd">卷积层</strong> : 30个滤波器，(3 * 3)内核大小</li><li id="22ad" class="nw nx it lk b ll of lo og lr oh lv oi lz oj md ob oc od oe bi translated"><strong class="lk jd">最大池层数</strong> : (2 * 2)池大小</li><li id="c20e" class="nw nx it lk b ll of lo og lr oh lv oi lz oj md ob oc od oe bi translated"><strong class="lk jd">卷积层</strong> : 15个滤波器，(3 * 3)内核大小</li><li id="894c" class="nw nx it lk b ll of lo og lr oh lv oi lz oj md ob oc od oe bi translated"><strong class="lk jd">最大池层</strong> : (2 * 2)池大小</li><li id="d33d" class="nw nx it lk b ll of lo og lr oh lv oi lz oj md ob oc od oe bi translated"><strong class="lk jd">脱落层</strong>:脱落20%的神经元。</li><li id="405f" class="nw nx it lk b ll of lo og lr oh lv oi lz oj md ob oc od oe bi translated"><strong class="lk jd">展平图层</strong></li><li id="aa17" class="nw nx it lk b ll of lo og lr oh lv oi lz oj md ob oc od oe bi translated"><strong class="lk jd">密集/全连接层</strong> : 128个神经元，Relu激活功能</li><li id="8d5d" class="nw nx it lk b ll of lo og lr oh lv oi lz oj md ob oc od oe bi translated"><strong class="lk jd">密集/全连接层</strong> : 50个神经元，Softmax激活功能</li></ul><p id="aa20" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">下面是相应的代码:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">Cnn模型</p></figure><p id="3481" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在我们的模型已经准备好了，我们只需要训练它并评估它的性能。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi om"><img src="../Images/356ae7ad61f4d8c3d55994bd5f803298.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/format:webp/1*XEMv3j8p7F_qWCeaZkKWWA.jpeg"/></div></figure><p id="16b3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">经过<strong class="lk jd"> 15 </strong>个时期后，我们的分类器达到了<strong class="lk jd"> 92.7% </strong>的准确率，这对于我们的识别app来说已经足够了！让我们检查一下混淆矩阵。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi on"><img src="../Images/dd3c6632efba2ba3bd2fc406d3e683de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*55udUNdKDj8rLnf9ltJQUg.jpeg"/></div></div></figure><p id="a839" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">正如我们所看到的，大部分的画都被很好的分类了。然而，有些类别似乎比其他类别更难区分:例如，猫与蝙蝠或骆驼与羊。这可以用它们形状的相似性来解释！</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/93382dec8978b5b96874128e47d58047.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*NM8jV6_EehURMvPloyUFjQ.jpeg"/></div></figure><p id="5a17" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是一些被我们的模型错误分类的图片。这些图像中的大部分很容易被误认为是错误的，甚至是被人眼误认为是错误的！别忘了我们的数据集收集了玩<strong class="lk jd">‘快，画吧！’的手工人类图画</strong>游戏。因此，许多图像可能与一个类无关。</p><h2 id="8b36" class="nl mn it bd mo nm nn dn ms no np dp mw lr nq nr my lv ns nt na lz nu nv nc iz bi translated"><strong class="ak">保存模型</strong></h2><p id="d8b8" class="pw-post-body-paragraph li lj it lk b ll ne kd ln lo nf kg lq lr ng lt lu lv nh lx ly lz ni mb mc md im bi translated">现在我们的模型已经准备好了，我们想把它嵌入到一个<strong class="lk jd">Flask Web App</strong>中。为此，使用<strong class="lk jd"> pickle </strong>保存(序列化)我们的模型会更方便。</p><p id="123c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">注意:你可以直接将你的模型训练到flask中，但是这将会非常耗时，而且对用户不友好。</p><pre class="ks kt ku kv gt op oq or os aw ot bi"><span id="b158" class="nl mn it oq b gy ou ov l ow ox"><strong class="oq jd">import</strong> <strong class="oq jd">pickle</strong><br/><strong class="oq jd">with</strong> open('model_cnn.pkl', 'wb') <strong class="oq jd">as</strong> file:<br/>      pickle.dump(model_cnn, file)</span></pre></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="abbb" class="mm mn it bd mo mp mq mr ms mt mu mv mw ki mx kj my kl mz km na ko nb kp nc nd bi translated">用Flask开发我们的绘图应用程序</h1><h2 id="9071" class="nl mn it bd mo nm nn dn ms no np dp mw lr nq nr my lv ns nt na lz nu nv nc iz bi translated"><strong class="ak">烧瓶</strong></h2><p id="b50b" class="pw-post-body-paragraph li lj it lk b ll ne kd ln lo nf kg lq lr ng lt lu lv nh lx ly lz ni mb mc md im bi translated">Flask是一个用Python编写的web微框架。它允许你设计一个可靠和专业的web应用程序。</p><h2 id="7a5e" class="nl mn it bd mo nm nn dn ms no np dp mw lr nq nr my lv ns nt na lz nu nv nc iz bi translated">它是如何工作的？</h2><p id="d0c8" class="pw-post-body-paragraph li lj it lk b ll ne kd ln lo nf kg lq lr ng lt lu lv nh lx ly lz ni mb mc md im bi translated">虽然它不需要特定体系结构，但是有一些好的实践可以遵循:</p><ul class=""><li id="8fda" class="nw nx it lk b ll lm lo lp lr ny lv nz lz oa md ob oc od oe bi translated">app.py :是运行Flask应用程序的主要代码。它将包含我们的应用程序的不同路由，响应HTTP请求并决定在模板中显示什么。在我们的例子中，它还会调用我们的<strong class="lk jd"> CNN分类器</strong>、<strong class="lk jd">、</strong>对我们的输入数据进行<strong class="lk jd">预处理</strong>步骤，并进行<strong class="lk jd">预测</strong>。</li><li id="80bc" class="nw nx it lk b ll of lo og lr oh lv oi lz oj md ob oc od oe bi translated"><strong class="lk jd">模板文件夹</strong>:模板是一个HTML文件，可以接收Python对象，链接到Flask应用。因此，我们的html页面将存储在这个文件夹中。</li><li id="9057" class="nw nx it lk b ll of lo og lr oh lv oi lz oj md ob oc od oe bi translated"><strong class="lk jd">静态文件夹</strong>:样式表、脚本、图片等永远不会动态生成的元素必须存放在这个文件夹中。我们将把Javascript和CSS文件放在里面。</li></ul><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/783beefcf2e9682bebb0fb6ab9f93ea1.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/1*WJYie3eQJaBuPKwLzZUahg.jpeg"/></div></figure><p id="0dcc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">该项目将需要:</p><ul class=""><li id="d3e2" class="nw nx it lk b ll lm lo lp lr ny lv nz lz oa md ob oc od oe bi translated">两个静态文件:<em class="nj"> draw.js </em>和<em class="nj"> styles_draw.css </em></li><li id="6848" class="nw nx it lk b ll of lo og lr oh lv oi lz oj md ob oc od oe bi translated">两个模板文件:<em class="nj">draw.html</em>和<em class="nj">results.html</em>。</li><li id="b326" class="nw nx it lk b ll of lo og lr oh lv oi lz oj md ob oc od oe bi translated">我们的主文件:<em class="nj"> app.py </em></li><li id="3801" class="nw nx it lk b ll of lo og lr oh lv oi lz oj md ob oc od oe bi translated">我们的<em class="nj"> model_cnn.plk </em>早存了。</li></ul><blockquote class="oz"><p id="474e" class="pa pb it bd pc pd pe pf pg ph pi md dk translated">现在，让我们来构建我们的应用程序吧！</p></blockquote><h1 id="e1f7" class="mm mn it bd mo mp pj mr ms mt pk mv mw ki pl kj my kl pm km na ko pn kp nc nd bi translated">获取用户输入</h1><p id="e6ad" class="pw-post-body-paragraph li lj it lk b ll ne kd ln lo nf kg lq lr ng lt lu lv nh lx ly lz ni mb mc md im bi translated">这个项目的第二部分是获得用户输入<strong class="lk jd"/>:一个将被我们训练好的模型分类的绘图。为此，我们将首先使用<strong class="lk jd"> javascript </strong>和<strong class="lk jd"> HTML5 </strong>设计绘图区域。我不会在本文中介绍<em class="nj"> styles_draw.css </em>但是你可以在我的<a class="ae lh" href="https://github.com/hugom1997/Flask-Cnn-Recognition-App" rel="noopener ugc nofollow" target="_blank"> github </a>上找到它。</p><h2 id="2804" class="nl mn it bd mo nm nn dn ms no np dp mw lr nq nr my lv ns nt na lz nu nv nc iz bi translated"><strong class="ak">draw.html</strong></h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">draw.html</p></figure><ul class=""><li id="ebbd" class="nw nx it lk b ll lm lo lp lr ny lv nz lz oa md ob oc od oe bi translated">我们使用<code class="fe po pp pq oq b">{{url_for('static',filename='styles_draws.css’)}}</code>和<code class="fe po pp pq oq b">{{url_for('static',filename='draw.js’)}}</code>导入位于静态文件夹中的css和js文件。这是<a class="ae lh" href="https://jinja.palletsprojects.com/en/2.11.x/templates/" rel="noopener ugc nofollow" target="_blank"> Jinja </a>导入文件的语法。</li><li id="8216" class="nw nx it lk b ll of lo og lr oh lv oi lz oj md ob oc od oe bi translated">我们用<code class="fe po pp pq oq b">&lt;canvas&gt;</code>标签设置我们的绘图区域。</li><li id="c8a5" class="nw nx it lk b ll of lo og lr oh lv oi lz oj md ob oc od oe bi translated">我们调用<em class="nj"> draw.js </em>中包含的drawCanvas() javascript函数。</li><li id="81f8" class="nw nx it lk b ll of lo og lr oh lv oi lz oj md ob oc od oe bi translated">我们初始化表单，这样就可以使用<code class="fe po pp pq oq b">POST</code>方法将数据发送到flask实例/ <em class="nj"> app.py </em>。</li><li id="8af4" class="nw nx it lk b ll of lo og lr oh lv oi lz oj md ob oc od oe bi translated"><code class="fe po pp pq oq b">action = “{{url_for('predict')}”</code>又是金贾句法。它指定了提交表单时将在<em class="nj"> app.py </em>中使用的路径。</li><li id="7e29" class="nw nx it lk b ll of lo og lr oh lv oi lz oj md ob oc od oe bi translated">我们在表单中添加了一个额外的隐藏字段，用于传输图像。<code class="fe po pp pq oq b">&lt;input type = “hidden“ id =’url' name = ‘url' value = “”&gt;</code></li><li id="ef13" class="nw nx it lk b ll of lo og lr oh lv oi lz oj md ob oc od oe bi translated">仅此而已！简单对吗？</li></ul><p id="c5bb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们现在必须使用javascript来使它更加动态！否则，你的画布什么也做不了…</p><h2 id="a4e0" class="nl mn it bd mo nm nn dn ms no np dp mw lr nq nr my lv ns nt na lz nu nv nc iz bi translated"><strong class="ak"> draw.js </strong></h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">draw.js</p></figure><p id="764f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这段Javascript代码允许我们设计绘图区域并与之交互。</p><ul class=""><li id="8570" class="nw nx it lk b ll lm lo lp lr ny lv nz lz oa md ob oc od oe bi translated"><em class="nj"> drawCanvas() </em>旨在初始化画布的主要功能(mouseUp、mouseDown、…)，这些功能将允许与用户的鼠标进行交互。</li><li id="5fd0" class="nw nx it lk b ll of lo og lr oh lv oi lz oj md ob oc od oe bi translated"><em class="nj"> addClick() </em>保存用户点击画布时光标的位置。</li><li id="3f77" class="nw nx it lk b ll of lo og lr oh lv oi lz oj md ob oc od oe bi translated"><em class="nj"> redraw() </em>每次调用该函数时，清除画布并重新绘制所有内容。</li></ul><p id="2fad" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在我画完之后，画布看起来是这样的(顺便说一下，这是一只长颈鹿) :</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pr"><img src="../Images/11a3f531a7f70635099a10bfb5752075.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bh6xRrovr7nhcbF7m4Wohg.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">Draw.html</p></figure><p id="ad7a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在我们的画布已经准备好获取用户的绘图，我们需要确保图像能够到达我们在<em class="nj"> app.py </em>中的应用程序。</p><p id="a9fa" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">通常我们可以直接使用<code class="fe po pp pq oq b">POST</code>函数，通过一个表单提交数据。然而，目前不能用这种方法提交原始图像。此外，我不希望用户保存然后上传他的画，因为这会影响他的体验的流畅性。</p><p id="8fee" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我用来克服这个问题的一个小技巧是，在通过表单发送之前，使用之前在<em class="nj">results.html</em>中设置的隐藏输入字段，在<em class="nj"> base64 </em>中对图像进行编码。该编码过程将在<em class="nj"> app.py. </em>中反向进行</p><ul class=""><li id="6728" class="nw nx it lk b ll lm lo lp lr ny lv nz lz oa md ob oc od oe bi translated">当用户点击<em class="nj">‘预测’</em>按钮时，调用<em class="nj"> save() </em>。它将通过表单发送<em class="nj"> base64 </em>编码的图像。</li></ul></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="93a0" class="mm mn it bd mo mp mq mr ms mt mu mv mw ki mx kj my kl mz km na ko nb kp nc nd bi translated">做预测</h1><p id="e6b5" class="pw-post-body-paragraph li lj it lk b ll ne kd ln lo nf kg lq lr ng lt lu lv nh lx ly lz ni mb mc md im bi translated">既然我们能够获得用户输入，那么是时候使用它来进行预测了！为此，我们只需要一个文件:</p><h2 id="26d5" class="nl mn it bd mo nm nn dn ms no np dp mw lr nq nr my lv ns nt na lz nu nv nc iz bi translated"><strong class="ak"> app.py </strong></h2><p id="6f32" class="pw-post-body-paragraph li lj it lk b ll ne kd ln lo nf kg lq lr ng lt lu lv nh lx ly lz ni mb mc md im bi translated">如前所述，<strong class="lk jd"> app.py </strong>是我们项目的主文件，Flask应用程序在其中被实例化。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">app.py</p></figure><p id="61a9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">本规范的要点:</p><p id="2ef7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> 1) </strong>初始化app，指定模板文件夹。我们可以使用这行代码来实现:</p><p id="5e72" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe po pp pq oq b">app = flask.Flask(__name__, template_folder =’templates’)</code></p><p id="add9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> 2) </strong>定义路线(我们的应用程序只有两条) :</p><ul class=""><li id="9263" class="nw nx it lk b ll lm lo lp lr ny lv nz lz oa md ob oc od oe bi translated"><em class="nj"> @app.route('/') </em>:是我们默认的路径——它会返回默认的<em class="nj">draw.html</em>模板。</li><li id="f024" class="nw nx it lk b ll of lo og lr oh lv oi lz oj md ob oc od oe bi translated"><em class="nj"> @app.route('/predict') </em>:点击<em class="nj">‘预测’</em>按钮时调用。处理用户输入后返回<em class="nj">results.html</em>模板。</li></ul><p id="0cae" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">3)</strong><em class="nj">预测</em>功能将由表单中的<code class="fe po pp pq oq b">POST</code>动作触发(还记得我们在<em class="nj">result.html</em>中设置此路径时感谢Jinja语法！).然后，它将按如下方式进行:</p><ul class=""><li id="b70c" class="nw nx it lk b ll lm lo lp lr ny lv nz lz oa md ob oc od oe bi translated">用<code class="fe po pp pq oq b">request.form['url']</code>访问<em class="nj"> base64 </em>编码图形输入，其中“url”是包含编码图像的表单中隐藏输入字段的<strong class="lk jd">名称</strong>。</li><li id="72a8" class="nw nx it lk b ll of lo og lr oh lv oi lz oj md ob oc od oe bi translated">解码图像并将其设置为一个数组。</li><li id="0953" class="nw nx it lk b ll of lo og lr oh lv oi lz oj md ob oc od oe bi translated">调整图像的大小和形状，为我们的模型获得一个28 * 28的输入。我们关心的是保持它的比例。</li><li id="e11f" class="nw nx it lk b ll of lo og lr oh lv oi lz oj md ob oc od oe bi translated">使用我们的CNN分类器进行预测。</li><li id="ae57" class="nw nx it lk b ll of lo og lr oh lv oi lz oj md ob oc od oe bi translated">由于<code class="fe po pp pq oq b">model.predict()</code>返回单个数组中每个类的概率，我们必须找到数组的最高概率，并使用预定义的字典获得相应的类。</li><li id="e47d" class="nw nx it lk b ll of lo og lr oh lv oi lz oj md ob oc od oe bi translated">最后返回<em class="nj">results.html</em>模板，并将之前做的预测作为参数传递:</li></ul><p id="425d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe po pp pq oq b">return render_template('results.html', prediction= final_pred)</code></p><p id="68dc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="nj">注</em>:</p><p id="2f73" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">—我们的<em class="nj"> base64 </em>编码图像看起来会像这样:<code class="fe po pp pq oq b">data:image/png;base64,iVBOR…</code>。因此，我们只需要删除第一个<strong class="lk jd"> 21 </strong>字符就可以得到干净的url。为此，我们使用了<code class="fe po pp pq oq b">draw[init_base64:]</code>行代码。—</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="c313" class="mm mn it bd mo mp mq mr ms mt mu mv mw ki mx kj my kl mz km na ko nb kp nc nd bi translated">显示结果</h1><p id="9b0a" class="pw-post-body-paragraph li lj it lk b ll ne kd ln lo nf kg lq lr ng lt lu lv nh lx ly lz ni mb mc md im bi translated">仅此而已！几乎一切都搞定了。下一步是展示我们的结果。</p><h2 id="c004" class="nl mn it bd mo nm nn dn ms no np dp mw lr nq nr my lv ns nt na lz nu nv nc iz bi translated">results.html</h2><p id="4f1c" class="pw-post-body-paragraph li lj it lk b ll ne kd ln lo nf kg lq lr ng lt lu lv nh lx ly lz ni mb mc md im bi translated">最后，我们使用<em class="nj">results.html</em>来显示在<em class="nj"> app.py中计算的预测。</em>我们将再次需要使用<em class="nj"> Jinja </em>语法来显示预测<em class="nj">。</em></p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ok ol l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">results.html</p></figure><p id="f828" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">下面是我们预测是“长颈鹿”时的渲染图:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ps"><img src="../Images/3d7d7b89e1056fd706cfb648208b3443.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GyPqK7C8XGiBxTUBAD-cpQ.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">显示结果</p></figure></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="6998" class="mm mn it bd mo mp mq mr ms mt mu mv mw ki mx kj my kl mz km na ko nb kp nc nd bi translated">运行应用程序</h1><p id="c3de" class="pw-post-body-paragraph li lj it lk b ll ne kd ln lo nf kg lq lr ng lt lu lv nh lx ly lz ni mb mc md im bi translated">最后一步是启动我们的应用程序！你可以进入你的绘图应用文件夹(你可以在根目录下找到<strong class="lk jd"> app.py </strong>并使用<code class="fe po pp pq oq b">flask run.</code></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pt"><img src="../Images/f13294e13ac046fe7abfa22c8133cdd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v8A18n_4P-KSj6vLtyMaGA.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">烧瓶运行</p></figure><p id="18e2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您的应用将在本地服务器上运行。默认为<a class="ae lh" href="http://localhost:5000/" rel="noopener ugc nofollow" target="_blank"> 127.0.0.1:5000 </a>。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pu"><img src="../Images/2e9bd612fb33a1449f6c11f2db4f3a14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1310/1*PC-KbQTMxKuKrtFqCxZnDQ.gif"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">绘图应用程序</p></figure></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="aca6" class="mm mn it bd mo mp mq mr ms mt mu mv mw ki mx kj my kl mz km na ko nb kp nc nd bi translated">结论</h1><p id="1b1b" class="pw-post-body-paragraph li lj it lk b ll ne kd ln lo nf kg lq lr ng lt lu lv nh lx ly lz ni mb mc md im bi translated">就是这样！在本文中，我们看到了如何开发一个烧瓶绘图应用程序，它使用以前构建的CNN模型对用户绘制的绘图进行分类。</p><p id="873c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是Flask部署机器学习模型的众多可能用途之一。事实上，可以找到无限的用例，我希望这个具体的项目将帮助您构建其他ML web应用程序，使您的代码更容易被他人访问！</p><p id="7d5a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">所有代码在我的</strong><a class="ae lh" href="https://github.com/hugom1997/Flask-Cnn-Recognition-App" rel="noopener ugc nofollow" target="_blank"><strong class="lk jd">github</strong></a><strong class="lk jd">上都有！</strong></p><p id="1b0f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">祝您愉快！</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="1c72" class="mm mn it bd mo mp mq mr ms mt mu mv mw ki mx kj my kl mz km na ko nb kp nc nd bi translated">参考</h1><p id="244a" class="pw-post-body-paragraph li lj it lk b ll ne kd ln lo nf kg lq lr ng lt lu lv nh lx ly lz ni mb mc md im bi translated">当然，这不是我一个人做的。我在这里找到了一些灵感:</p><div class="pv pw gp gr px py"><a href="https://www.datacareer.de/blog/quick-draw-classifying-drawings-with-python/" rel="noopener  ugc nofollow" target="_blank"><div class="pz ab fo"><div class="qa ab qb cl cj qc"><h2 class="bd jd gy z fp qd fr fs qe fu fw jc bi translated">“快，画！”-使用Python对图形进行分类</h2><div class="qf l"><h3 class="bd b gy z fp qd fr fs qe fu fw dk translated">图像识别一直是机器学习中的一个主要挑战，与大规模标记数据集一起工作来训练…</h3></div><div class="qg l"><p class="bd b dl z fp qd fr fs qe fu fw dk translated">www.datacareer.de</p></div></div><div class="qh l"><div class="qi l qj qk ql qh qm lb py"/></div></div></a></div><div class="pv pw gp gr px py"><a href="https://flask.palletsprojects.com/en/1.1.x/" rel="noopener  ugc nofollow" target="_blank"><div class="pz ab fo"><div class="qa ab qb cl cj qc"><h2 class="bd jd gy z fp qd fr fs qe fu fw jc bi translated">欢迎使用Flask - Flask文档(1.1.x)</h2><div class="qf l"><h3 class="bd b gy z fp qd fr fs qe fu fw dk translated">欢迎阅读Flask的文档。开始安装，然后了解快速入门概述。有…</h3></div><div class="qg l"><p class="bd b dl z fp qd fr fs qe fu fw dk translated">flask.palletsprojects.com</p></div></div><div class="qh l"><div class="qn l qj qk ql qh qm lb py"/></div></div></a></div><div class="pv pw gp gr px py"><a href="http://www.williammalone.com/articles/create-html5-canvas-javascript-drawing-app/" rel="noopener  ugc nofollow" target="_blank"><div class="pz ab fo"><div class="qa ab qb cl cj qc"><h2 class="bd jd gy z fp qd fr fs qe fu fw jc bi translated">使用HTML5 Canvas和JavaScript创建一个绘图应用程序</h2><div class="qf l"><h3 class="bd b gy z fp qd fr fs qe fu fw dk translated">威廉·马隆:本教程将带你一步一步地开发一个简单的网络绘图应用程序…</h3></div><div class="qg l"><p class="bd b dl z fp qd fr fs qe fu fw dk translated">www.williammalone.com</p></div></div><div class="qh l"><div class="qo l qj qk ql qh qm lb py"/></div></div></a></div><div class="pv pw gp gr px py"><a href="https://machinelearningmastery.com/handwritten-digit-recognition-using-convolutional-neural-networks-python-keras/" rel="noopener  ugc nofollow" target="_blank"><div class="pz ab fo"><div class="qa ab qb cl cj qc"><h2 class="bd jd gy z fp qd fr fs qe fu fw jc bi translated">用Python中的卷积神经网络进行手写数字识别</h2><div class="qf l"><h3 class="bd b gy z fp qd fr fs qe fu fw dk translated">深度学习技术能力的最新流行演示是图像中的对象识别…</h3></div><div class="qg l"><p class="bd b dl z fp qd fr fs qe fu fw dk translated">machinelearningmastery.com</p></div></div><div class="qh l"><div class="qp l qj qk ql qh qm lb py"/></div></div></a></div></div></div>    
</body>
</html>