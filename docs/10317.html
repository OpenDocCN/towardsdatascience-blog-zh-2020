<html>
<head>
<title>Customer Churn Prediction within Music Streaming using PySpark</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 PySpark 预测音乐流中的客户流失</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/customer-churn-prediction-within-music-streaming-using-pyspark-a96edd4beae8?source=collection_archive---------45-----------------------#2020-07-20">https://towardsdatascience.com/customer-churn-prediction-within-music-streaming-using-pyspark-a96edd4beae8?source=collection_archive---------45-----------------------#2020-07-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ad5a60040888315435429a1b303536ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fDKTpMwyWBiKMPZ_uO3QVw.jpeg"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="kc kd ep" href="https://medium.com/u/2053395ac335?source=post_page-----a96edd4beae8--------------------------------" rel="noopener" target="_blank"> Unsplash </a>照片由<a class="ae ke" href="https://unsplash.com/photos/IJthre6PHHQ" rel="noopener ugc nofollow" target="_blank"> Cezar Sampaio </a>拍摄</p></figure><p id="bcd8" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">音乐流媒体业务<strong class="kh ir">的关键是识别可能流失的用户，即有可能从付费和免费订阅降级到取消服务的用户。</strong>如果一家音乐流媒体公司提前准确地识别出这些用户，他们可以向他们提供折扣或其他类似的激励措施，从而节省数百万美元的收入。众所周知，获得一个新客户比留住一个现有客户的成本更高。这是因为回头客可能会在你公司的产品和服务上多花 67%的钱。</p><h1 id="f0a0" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">1.1 项目概述</h1><p id="f665" class="pw-post-body-paragraph kf kg iq kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc ij bi translated">我们希望<strong class="kh ir"> <em class="mg">确定可能会取消其帐户并离开服务</em> </strong>的用户。我们在这个项目中的目标是帮助一个虚构的企业(类似于 Spotify 和 Pandora)，方法是建立和训练一个二进制分类器，该分类器能够根据从用户过去的活动和与该服务的交互中获得的模式，准确识别取消音乐流媒体服务的用户。</p><ul class=""><li id="a611" class="mh mi iq kh b ki kj km kn kq mj ku mk ky ml lc mm mn mo mp bi translated">定义流失变量:<strong class="kh ir"> 1 </strong> —在观察期内取消订阅的用户，以及<strong class="kh ir"> 0 </strong> —始终保持服务的用户</li></ul><p id="70c1" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">由于数据集的规模，该项目是通过利用 Apache Spark 分布式集群计算框架功能，使用 Python API for Spark，PySpark 来实施的。</p><h1 id="173e" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">1.2 加载数据</h1><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mq"><img src="../Images/fd074445f7b7469a50f8a03c481a4e51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aWslnulJfqOWjoSIDKwLBA.png"/></div></div></figure><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="6929" class="na le iq mw b gy nb nc l nd ne"><strong class="mw ir"># import libraries</strong></span><span id="ad4e" class="na le iq mw b gy nf nc l nd ne">from pyspark import SparkContext, SparkConf<br/>from pyspark.sql import SparkSession<br/>from pyspark.sql import Window<br/>from pyspark.sql.functions import udf, col, concat, count, lit, avg, lag, first, last, when<br/>from pyspark.sql.functions import min as Fmin, max as Fmax, sum as Fsum, round as Fround<br/>from pyspark.sql.types import IntegerType, DateType, TimestampType</span><span id="cead" class="na le iq mw b gy nf nc l nd ne">from pyspark.ml import Pipeline<br/>from pyspark.ml.feature import VectorAssembler, Normalizer, StandardScaler<br/>from pyspark.ml.regression import LinearRegression<br/>from pyspark.ml.classification import LogisticRegression, RandomForestClassifier, GBTClassifier<br/>from pyspark.ml.clustering import KMeans<br/>from pyspark.ml.tuning import CrossValidator, ParamGridBuilder<br/>from pyspark.ml.evaluation import BinaryClassificationEvaluator,</span><span id="dfd1" class="na le iq mw b gy nf nc l nd ne"><strong class="mw ir"># create a Spark session</strong><br/>spark = SparkSession \<br/>.builder \<br/>.appName(‘CustomerChurn’) \<br/>.getOrCreate()</span><span id="be39" class="na le iq mw b gy nf nc l nd ne"><strong class="mw ir"># Check Spark configuration</strong><br/>spark.sparkContext.getConf().getAll()</span><span id="90c6" class="na le iq mw b gy nf nc l nd ne">path = "mini_sparkify_event_data.json"<br/>df = spark.read.json(path)</span></pre><h1 id="513e" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">2.数据理解</h1><p id="72d8" class="pw-post-body-paragraph kf kg iq kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc ij bi translated">该数据集包含 2018 年 10 月 1 日至 2018 年 12 月 1 日期间记录的用户活动日志。完整数据集包含大约 2600 万行/日志，而子集包含 286 500 行。完整的数据集收集了 22，277 个不同用户的日志，而子集仅涵盖 225 个用户的活动。子集数据集包含 58 300 个免费用户和 228 000 个付费用户。两个数据集都有 18 列，如下所示。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="805f" class="na le iq mw b gy nb nc l nd ne">root<br/> |-- artist: string (nullable = true)<br/> |-- auth: string (nullable = true)<br/> |-- firstName: string (nullable = true)<br/> |-- gender: string (nullable = true)<br/> |-- itemInSession: long (nullable = true)<br/> |-- lastName: string (nullable = true)<br/> |-- length: double (nullable = true)<br/> |-- level: string (nullable = true)<br/> |-- location: string (nullable = true)<br/> |-- method: string (nullable = true)<br/> |-- page: string (nullable = true)<br/> |-- registration: long (nullable = true)<br/> |-- sessionId: long (nullable = true)<br/> |-- song: string (nullable = true)<br/> |-- status: long (nullable = true)<br/> |-- ts: long (nullable = true)<br/> |-- userAgent: string (nullable = true)<br/> |-- userId: string (nullable = true)</span></pre><p id="3050" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">每个活动日志都属于一个特定的用户。数据集中的七列代表静态的<strong class="kh ir">用户级信息</strong>(对于属于特定用户的所有日志是固定的):</p><p id="38f8" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><strong class="kh ir">艺术家:</strong>用户正在听的艺术家<br/> <strong class="kh ir"> userId </strong>:用户标识；<br/> <strong class="kh ir"> sessionId: <em class="mg"> </em> </strong>标识服务的用户的单个连续使用时段的唯一 Id。多个用户可以使用相同的 sessionId <br/> <strong class="kh ir">名</strong>:用户的名<br/> <strong class="kh ir">姓</strong>:用户的姓<br/> <strong class="kh ir">性别</strong>:用户的性别；2 类(<em class="mg"> M </em>和<em class="mg"> F </em> ) <br/> <strong class="kh ir">位置</strong>:用户位置<br/> <strong class="kh ir"> userAgent </strong>:用户访问流媒体服务使用的代理；57 不同类别<br/> <strong class="kh ir">注册</strong>:用户的注册时间戳<br/> <strong class="kh ir">级别</strong>(非静态):订阅级别；2 类(<em class="mg">免费</em>和<em class="mg">付费</em> ) <br/> <strong class="kh ir">页面:</strong>该事件生成时用户正在访问哪个页面。不同类型的页面将在下一节中详细介绍</p><p id="ad89" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><strong class="kh ir">页面</strong>列包含用户在应用程序中访问过的所有页面的日志。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="c274" class="na le iq mw b gy nb nc l nd ne">&gt;&gt;&gt; df.select('page').distinct().show(10)<br/>+--------------------+<br/>|                page|<br/>+--------------------+<br/>|              Cancel|<br/>|    Submit Downgrade|<br/>|         Thumbs Down|<br/>|                Home|<br/>|           Downgrade|<br/>|         Roll Advert|<br/>|              Logout|<br/>|       Save Settings|<br/>|Cancellation Conf...|<br/>|               About|<br/>+--------------------</span></pre><p id="b570" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">根据执行的分析，仍然属于同一个会话的两个连续日志之间的最大时间似乎是一个小时。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="8070" class="na le iq mw b gy nb nc l nd ne"># Explore the auth column<br/>df.groupby('auth').count().show()</span><span id="d211" class="na le iq mw b gy nf nc l nd ne">+----------+------+<br/>|      auth| count|<br/>+----------+------+<br/>|Logged Out|  8249|<br/>| Cancelled|    52|<br/>|     Guest|    97|<br/>| Logged In|278102|<br/>+----------+------+</span></pre><p id="822b" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">我们还可以看到用户相当活跃，其中一个顶级用户总共列出了大约 8000 首歌曲。下面的图表表明，被搅动的用户通常来自加州和新泽西州，大多数付费用户正在离开音乐应用程序，而更多的男性比女性倾向于取消他们的订阅。加利福尼亚州和纽约州的人口往往更密集，因此可以预期更高的流失率和更高的整体参与度。从下图中很容易看出，所提供的 Sparkify 数据集是一个<strong class="kh ir">不平衡数据集</strong>的例子，因为与 174 相比，被搅动用户的份额仅略高于 20% (52)。</p><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/849bd5bdf53aa1a41f6400de5babaf3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*phRpSXH1Qbbn6w_mF3oVFg.png"/></div></div></figure><div class="mr ms mt mu gt ab cb"><figure class="nh jr ni nj nk nl nm paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><img src="../Images/2214dafd0efc28192f70b9fb03d4311b.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*-Nzou86RwOzrrPjLIu1l7g.png"/></div></figure><figure class="nh jr nn nj nk nl nm paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><img src="../Images/52f508ceb36410c7853e1282eb3c02d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*nxeJdbys_M3Ue5JMk12yjQ.png"/></div></figure></div><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/9fc0abade5e37880510cdfd8536f7757.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_7yksD5S3QGtXDPy35R9UQ.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">分类特征(last level 0-免费，1-付费；性别 0-男性，1-女性)</p></figure><h1 id="5931" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">3.特征工程</h1><p id="c3d0" class="pw-post-body-paragraph kf kg iq kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc ij bi translated">首先，我们必须将原始数据集(每个日志一行)转换成具有用户级信息或统计数据的数据集(每个用户一行)。我们通过执行几个映射实现了这一点(例如，获取用户的性别、观察期的长度等。)和聚合步骤。</p><h1 id="bd44" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">3.1 转换</h1><p id="97f2" class="pw-post-body-paragraph kf kg iq kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc ij bi translated">对于 10 月 1 日之后注册的少数用户，注册时间与实际日志时间戳和活动类型不一致。因此，我们必须通过在<em class="mg">页面</em>列中查找<em class="mg">提交注册</em>日志来识别延迟注册。这一步并不简单，因为此类日志事件没有映射到任何<em class="mg">用户 Id </em>，所以必须从<em class="mg">会话 Id </em>信息中提取这些事件。</p><p id="0bc6" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">对于少数注册较晚的用户，观察开始时间被设置为他们第一次日志的时间戳，而对于所有其他用户，则使用默认的 10 月 1 日。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="e572" class="na le iq mw b gy nb nc l nd ne"># Lag the page column<br/>windowsession = Window.partitionBy('sessionId').orderBy('ts')<br/>df = df.withColumn("lagged_page", lag(df.page).over(windowsession))</span><span id="ea8f" class="na le iq mw b gy nf nc l nd ne">windowuser = Window.partitionBy('userId').orderBy('ts').rangeBetween(Window.unboundedPreceding, Window.unboundedFollowing)</span><span id="c445" class="na le iq mw b gy nf nc l nd ne"># Identify users that registered after the start of observation, and infer the start date accordingly<br/>df = df.withColumn("beforefirstlog", first(col('lagged_page')).over(windowuser))<br/>df = df.withColumn("firstlogtime", first(col('ts')).over(windowuser))<br/>df = df.withColumn("obsstart", <br/>                   when(df.beforefirstlog == "Submit Registration", df.firstlogtime).otherwise(obs_start_default))</span><span id="fd6a" class="na le iq mw b gy nf nc l nd ne"># For each log compute the time from the beginning of observation...<br/>df = df.withColumn("timefromstart", col('ts')-col("obsstart"))<br/># ...and time before the end of observation<br/>df = df.withColumn("timebeforeend", col('obsend')-col('ts'))</span></pre><p id="95ef" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">与上面类似的还有在默认观察期结束前取消服务的<em class="mg">用户，即所谓的被搅动用户。对于每个这样的用户，相应观察期的结束已经被设置为他/她的最后日志条目的时间戳，而对于所有其他用户，默认为 12 月 1 日。</em></p><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/028296bacb3d89ba0787cc7c1b3a009d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zcqmvUau_An0wur7QdCJUQ.png"/></div></div></figure><h1 id="c786" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">3.2 特征工程—汇总统计数据</h1><p id="80cb" class="pw-post-body-paragraph kf kg iq kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc ij bi translated">新创建的<strong class="kh ir">用户级数据集</strong>包括以下栏目:</p><p id="46a5" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><strong class="kh ir"> lastlevel </strong>:用户最后的订阅级别，转换为二进制格式(1 —付费层，0 —免费层)<br/> <strong class="kh ir">性别</strong> : <em class="mg"> </em>性别，转换为二进制格式(1 —女性，<br/> <strong class="kh ir"> obsstart，obsend </strong>:用户特定观察期的开始和结束</p><p id="b387" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><strong class="kh ir"> endstate </strong>:用户在观察期内的最后一次交互<br/> <strong class="kh ir"> nact </strong>:用户在观察期内的总交互次数<br/> <strong class="kh ir"> nsongs、ntbup、ntbdown、nfriend、nplaylist、ndgrade、nupgrade、nhome、nadvert、nhelp、nsettings、nerror </strong>:播放的歌曲数、竖起大拇指、竖起大拇指向下拇指、添加的朋友、添加到播放列表的歌曲、降级、升级、主页访问</p><p id="4628" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><strong class="kh ir"> nact_recent，nact_oldest: <em class="mg"> </em> </strong>用户在观察窗最后一天和第一天<em class="mg"> k </em>的活动，<em class="mg">分别为<br/> </em> <strong class="kh ir"> nsongs_recent，nsongs_oldest </strong>:观察窗最后一天和第一天<em class="mg"> k </em>播放的歌曲，<em class="mg">分别为</em></p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="52a8" class="na le iq mw b gy nb nc l nd ne"># Aggregation by userId<br/>df_user = df.groupby(‘userId’)\<br/>.agg(<br/> # User-level features<br/> first(when(col(‘lastlevel’) == ‘paid’, 1).otherwise(0)).<br/>alias(‘lastlevel’),<br/> first(when(col(‘gender’) == “F”, 1).otherwise(0)).alias(‘gender’),<br/> first(col(‘obsstart’)).alias(‘obsstart’),<br/> first(col(‘obsend’)).alias(‘obsend’),<br/> first(col(‘endstate’)).alias(‘endstate’),<br/> <br/> # Aggregated activity statistics<br/> count(col(‘page’)).alias(‘nact’),<br/>Fsum(when(col(‘page’) == “NextSong”, 1).otherwise(0)).alias(“nsongs”),<br/> Fsum(when(col(‘page’) == “Thumbs Up”, 1).otherwise(0)).alias(“ntbup”),<br/> Fsum(when(col(‘page’) == “Thumbs Down”, 1).otherwise(0)).alias(“ntbdown”),<br/> Fsum(when(col(‘page’) == “Add Friend”, 1).otherwise(0)).alias(“nfriend”),<br/> Fsum(when(col(‘page’) == “Add to Playlist”, 1).otherwise(0)).alias(“nplaylist”), <br/> Fsum(when(col(‘page’) == “Submit Downgrade”, 1).otherwise(0)).alias(“ndgrade”),<br/> Fsum(when(col(‘page’) == “Submit Upgrade”, 1).otherwise(0)).alias(“nugrade”),<br/> Fsum(when(col(‘page’) == “Home”, 1).otherwise(0)).alias(“nhome”),<br/> Fsum(when(col(‘page’) == “Roll Advert”, 1).otherwise(0)).alias(“nadvert”),<br/> Fsum(when(col(‘page’) == “Help”, 1).otherwise(0)).alias(“nhelp”),<br/> Fsum(when(col(‘page’) == “Settings”, 1).otherwise(0)).alias(“nsettings”),<br/> Fsum(when(col(‘page’) == “Error”, 1).otherwise(0)).alias(“nerror”),<br/> <br/> # Aggregated activity statistics in different periods <br/> Fsum(when(col(‘timebeforeend’) &lt; trend_est, 1).otherwise(0)).alias(“nact_recent”),<br/> Fsum(when(col(‘timefromstart’) &lt; trend_est, 1).otherwise(0)).alias(“nact_oldest”),<br/> Fsum(when((col(‘page’) == “NextSong”) &amp; (col(‘timebeforeend’) &lt; trend_est), 1).otherwise(0)).alias(“nsongs_recent”),<br/> Fsum(when((col(‘page’) == “NextSong”) &amp; (col(‘timefromstart’) &lt; trend_est), 1).otherwise(0)).alias(“nsongs_oldest”) )</span></pre><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nq"><img src="../Images/a918cdec5dfb5beefd913c6abdcd9c3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GOF01-Xp3zfEQ4nbrQlD_g.png"/></div></div></figure><h2 id="5fa2" class="na le iq bd lf nr ns dn lj nt nu dp ln kq nv nw lr ku nx ny lv ky nz oa lz ob bi translated"><strong class="ak">汇总活动统计</strong></h2><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oc"><img src="../Images/82fb263d45e5520fd75c87c3229eb0ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ixr6z_9chIkfFf1pPH4mJA.png"/></div></div></figure><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi od"><img src="../Images/ad65b612654146b2685b3b1bf66be278.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFswC2XDhk8E4Gke8rhHAg.png"/></div></div></figure><h1 id="39e3" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">4.探索性数据分析</h1><p id="71c0" class="pw-post-body-paragraph kf kg iq kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc ij bi translated">完成特征工程步骤后，我们分析了构建特征之间的相关性。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="97b6" class="na le iq mw b gy nb nc l nd ne"># For visualization purposes we switch to pandas dataframes<br/>df_user_pd = df_user.toPandas()</span><span id="b19c" class="na le iq mw b gy nf nc l nd ne"># Calculate correlations between numerical features<br/>cormat = df_user_pd[['nact_perh','nsongs_perh', 'nhome_perh', 'ntbup_perh','ntbdown_perh', 'nfriend_perh','nplaylist_perh', <br/>'nadvert_perh', 'nerror_perh', 'upgradedowngrade', 'songratio', 'positiveratio','negativeratio', <br/>'updownratio', 'trend_act', 'trend_songs', 'avgsessionitems',  'avgsessionlength','avgsongs']].corr()</span><span id="07ef" class="na le iq mw b gy nf nc l nd ne"># Plot correlations<br/>plt.rcParams['figure.figsize'] = (10,10)<br/>plt.subplots_adjust(left=0.20, right=0.9, top=0.95, bottom=0.15)<br/>sns.heatmap(cormat, cmap = "YlGnBu", square = True, vmin = -1, vmax = 1);<br/>plt.title('Feature correlations');<br/>plt.savefig('correlations.png')</span></pre><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oe"><img src="../Images/2f58d4d876c0fe7d94d599cf39ad1fc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I0y9heYIzWUptuHGCXTfEg.png"/></div></div></figure><p id="d9b3" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">上面的热图描述了变量<strong class="kh ir"> nact_perh </strong>和<strong class="kh ir"> nsongs_perh 之间的高度相关性。</strong>这是意料之中的，因为听歌显然是最常见的用户活动。出于同样的原因，在<strong class="kh ir"> trend_act </strong>和<strong class="kh ir"> trend_songs </strong>之间有很高的相关性。在这两种情况下，我们决定简单地从所有进一步的分析中删除，只保留衡量最重要的交互的变量——播放歌曲。</p><p id="bed8" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">为了进一步减少数据中的多重共线性，我们还决定在模型中不使用<strong class="kh ir"> nhome_perh </strong>和<strong class="kh ir"> nplaylist_perh </strong>。此外，<strong class="kh ir"> avgsessionlength </strong>与每个会话中的平均项目高度相关，因此也可以忽略。</p><h1 id="7e9c" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">4.1 与搅动变量的关系</h1><p id="6e3e" class="pw-post-body-paragraph kf kg iq kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc ij bi translated">从下面呈现的可视化中，可以得出以下观察结果:</p><ul class=""><li id="cfc4" class="mh mi iq kh b ki kj km kn kq mj ku mk ky ml lc mm mn mo mp bi translated">平均而言，喝醉的用户每小时会播放更多的歌曲；</li><li id="0c81" class="mh mi iq kh b ki of km og kq oh ku oi ky oj lc mm mn mo mp bi translated">受刺激的用户每小时明显会拒绝更多的广告，平均不得不看更多的广告；</li><li id="306a" class="mh mi iq kh b ki of km og kq oh ku oi ky oj lc mm mn mo mp bi translated">对于喝醉的用户，歌曲和积极互动相对于总活动的比率通常较低</li><li id="f5ef" class="mh mi iq kh b ki of km og kq oh ku oi ky oj lc mm mn mo mp bi translated">被搅动的用户平均每次对话互动较少</li><li id="6e0b" class="mh mi iq kh b ki of km og kq oh ku oi ky oj lc mm mn mo mp bi translated">免费订阅计划的用户流失率更高</li><li id="4445" class="mh mi iq kh b ki of km og kq oh ku oi ky oj lc mm mn mo mp bi translated">男性用户的流失率略高</li></ul><p id="3c61" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">根据此分析，没有删除任何功能。</p><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ok"><img src="../Images/ee107e490aa0e52dc55d806fc61942fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*238C4VPVTDvd5H0A9mfNkQ.png"/></div></div></figure><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ok"><img src="../Images/e58a5198eccbf1b67f8e2243b1423eab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6FJ5JHr3aI3yYwyN_lH3aQ.png"/></div></div></figure><h1 id="de2c" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">4.建模和评估</h1><p id="18e9" class="pw-post-body-paragraph kf kg iq kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc ij bi translated">我们首先通过交叉验证执行网格搜索来测试几个参数组合的性能，所有这些都是基于从较小的 Sparkify 用户活动数据集获得的用户级数据。基于在交叉验证中获得的性能结果(通过 AUC 和 F1 分数衡量)，我们确定了性能最好的模型实例，并在整个训练集上对它们进行了重新训练。</p><h1 id="a71a" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">4.1 网格搜索方法</h1><h2 id="f746" class="na le iq bd lf nr ns dn lj nt nu dp ln kq nv nw lr ku nx ny lv ky nz oa lz ob bi translated">逻辑回归</h2><ul class=""><li id="82db" class="mh mi iq kh b ki mb km mc kq ol ku om ky on lc mm mn mo mp bi translated"><strong class="kh ir"> <em class="mg"> maxIter </em> </strong>(最大迭代次数，默认= 100):<strong class="kh ir">【10，30】</strong></li><li id="5f3e" class="mh mi iq kh b ki of km og kq oh ku oi ky oj lc mm mn mo mp bi translated"><strong class="kh ir"> <em class="mg"> regParam </em> </strong>(正则化参数，默认= 0.0):<strong class="kh ir">【0.0，0.1】</strong></li><li id="4a6e" class="mh mi iq kh b ki of km og kq oh ku oi ky oj lc mm mn mo mp bi translated"><strong class="kh ir"><em class="mg">elasticNetParam</em></strong>(混合参数—L2 罚 0，L1 罚 1，默认= 0.0):<strong class="kh ir">【0.0，0.5】</strong></li></ul><h2 id="e886" class="na le iq bd lf nr ns dn lj nt nu dp ln kq nv nw lr ku nx ny lv ky nz oa lz ob bi translated"><strong class="ak">随机森林分类器</strong></h2><ul class=""><li id="b004" class="mh mi iq kh b ki mb km mc kq ol ku om ky on lc mm mn mo mp bi translated"><strong class="kh ir"><em class="mg"/></strong>(最大树深，默认= 5):<strong class="kh ir">【4，5，6，7】</strong></li><li id="c903" class="mh mi iq kh b ki of km og kq oh ku oi ky oj lc mm mn mo mp bi translated"><strong class="kh ir"><em class="mg"/></strong>(树的数量，默认= 20):<strong class="kh ir">【20，40】</strong></li></ul><h2 id="a62b" class="na le iq bd lf nr ns dn lj nt nu dp ln kq nv nw lr ku nx ny lv ky nz oa lz ob bi translated"><strong class="ak">梯度增强树分类器</strong></h2><ul class=""><li id="951e" class="mh mi iq kh b ki mb km mc kq ol ku om ky on lc mm mn mo mp bi translated"><strong class="kh ir"><em class="mg"/>max depth</strong>(最大树深，默认= 5):<strong class="kh ir">【4，5】</strong></li><li id="00b9" class="mh mi iq kh b ki of km og kq oh ku oi ky oj lc mm mn mo mp bi translated"><strong class="kh ir"><em class="mg"/></strong>(最大迭代次数，默认= 20):<strong class="kh ir">【20，100】</strong></li></ul><p id="21df" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">在定义的网格搜索对象中，每个参数组合的性能默认通过在<strong class="kh ir">四重交叉验证</strong>中获得的平均<strong class="kh ir"> AUC </strong>分数(ROC 下的面积)来衡量。下文第 4.4 节简要解释了 AUC。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="ec99" class="na le iq mw b gy nb nc l nd ne">numeric_columns = [‘nsongs_perh’, ‘ntbup_perh’,’ntbdown_perh’, ‘nfriend_perh’, <br/>‘nadvert_perh’, ‘nerror_perh’, ‘upgradedowngrade’, ‘songratio’, ‘positiveratio’,’negativeratio’, <br/>‘updownratio’, ‘trend_songs’, ‘avgsessionitems’,’avgsongs’]</span><span id="b918" class="na le iq mw b gy nf nc l nd ne"># Combining multiple numerical features using VectorAssembler<br/>numeric_assembler = VectorAssembler(inputCols = numeric_columns, outputCol = “numericvectorized”)</span><span id="a87d" class="na le iq mw b gy nf nc l nd ne"># Standardizing numerical features<br/>scaler = StandardScaler(inputCol = “numericvectorized”, outputCol = “numericscaled”, withStd = True, withMean = True)</span><span id="769f" class="na le iq mw b gy nf nc l nd ne"># Adding the two binary features<br/>binary_columns = [‘lastlevel’, ‘gender’]<br/>total_assembler = VectorAssembler(inputCols = binary_columns + [“numericscaled”], outputCol = “features”)</span><span id="f2e9" class="na le iq mw b gy nf nc l nd ne"># Defining three different pipelines with three different classifiers, all with default parameters<br/># Logistic regression <br/>lr = LogisticRegression()<br/>pipeline_lr = Pipeline(stages = [numeric_assembler, scaler, total_assembler, lr])</span><span id="35ee" class="na le iq mw b gy nf nc l nd ne"># Random forest classifier<br/>rf = RandomForestClassifier()<br/>pipeline_rf = Pipeline(stages = [numeric_assembler, scaler, total_assembler, rf])</span><span id="94c3" class="na le iq mw b gy nf nc l nd ne"># Gradient-boosted tree classifier<br/>gb = GBTClassifier()<br/>pipeline_gb = Pipeline(stages = [numeric_assembler, scaler, total_assembler, gb])</span></pre><h1 id="1d5d" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">4.2 绩效指标</h1><p id="4d68" class="pw-post-body-paragraph kf kg iq kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc ij bi translated"><strong class="kh ir"> F1 分数</strong>是这个问题的首选性能指标。输入的用户级数据集不平衡。音乐流媒体服务旨在识别大部分可能流失的用户(<strong class="kh ir">目标是高召回</strong>，但同时不希望无缘无故给予太多折扣(<strong class="kh ir">目标是高精度</strong>)，即给予实际上对服务满意的用户(误报)——这可以帮助音乐流媒体业务防止财务损失。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="e419" class="na le iq mw b gy nb nc l nd ne">class F1score(Evaluator):<br/>def __init__(self, predictionCol = “prediction”, labelCol=”label”):<br/> self.predictionCol = predictionCol<br/> self.labelCol = labelCol</span><span id="721e" class="na le iq mw b gy nf nc l nd ne">def _evaluate(self, dataset):<br/> <br/> # Calculate F1 score <br/> tp = dataset.where((dataset.label == 1) &amp; (dataset.prediction == 1)).count()<br/> fp = dataset.where((dataset.label == 0) &amp; (dataset.prediction == 1)).count()<br/> tn = dataset.where((dataset.label == 0) &amp; (dataset.prediction == 0)).count()<br/> fn = dataset.where((dataset.label == 1) &amp; (dataset.prediction == 0)).count()<br/> <br/> # Add epsilon to prevent division by zero<br/> precision = tp / (tp + fp + 0.00001)<br/> recall = tp / (tp + fn + 0.00001)<br/> <br/> f1 = 2 * precision * recall / (precision + recall + 0.00001)<br/> <br/> return f1</span><span id="37bd" class="na le iq mw b gy nf nc l nd ne">def isLargerBetter(self):<br/> return True</span></pre><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oo"><img src="../Images/387e3ab05b7a87ce50732f10fe29caae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HvQyAhPQYgY0gjOOGeaY1w.png"/></div></div></figure><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi op"><img src="../Images/d839b357f52ce05026c780789ad01c29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R3S2ulRC7sy40Tze5Hyq3g.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">在完整数据集上测试</p></figure><p id="9fcc" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">表现最好的模型的 AUC 值为 0.981，F1 值为 0.855。</p><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oq"><img src="../Images/664298cb9858b8f1c700b97f7b78c1ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eu_RJ5U1M22TMuu7QIHwOQ.png"/></div></div></figure><p id="de5a" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">如上图所示，识别混乱用户最重要的特性是<strong class="kh ir"> nerror_perh </strong>，它测量每小时向用户显示多少个错误页面。用户经历的错误越多，他/她对服务不满意的可能性就越大。</p><p id="66b1" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">第二个和第三个最重要的特征也是如此，<strong class="kh ir"> ntbdown_perh </strong>和<strong class="kh ir"> nadvert_perh </strong>分别测量每小时给出的拇指向下数和每小时看到的广告数。</p><p id="4b32" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">最有趣的功能是<strong class="kh ir"> trend_songs </strong>变量，它测量用户的歌曲收听活动趋势，这是第四个最重要的功能。</p><h1 id="adec" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">5.结论和改进</h1><p id="638c" class="pw-post-body-paragraph kf kg iq kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc ij bi translated">梯度增强的树分类器的 F1 值(精度和召回率)为 0.855，可以根据过去的用户活动和与音乐流媒体服务的交互来识别被搅动的用户，这可以帮助企业防止严重的财务损失。</p><p id="6b9b" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">一些改进是在完整的 Sparkify 数据集上对模型执行<strong class="kh ir">全面的网格搜索</strong>。<strong class="kh ir">利用到目前为止已经被忽略的歌曲级特征</strong>，例如，根据在指定的观察期内收听的不同歌曲/艺术家来计算用户的收听多样性等。<strong class="kh ir">建立新特征</strong>，例如歌曲收听会话的平均长度、跳过或部分收听歌曲的比率等。</p><p id="cfed" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">关于这个项目的更多细节，请点击这里查看我的 Github 链接。</p></div></div>    
</body>
</html>