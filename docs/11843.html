<html>
<head>
<title>From Scripts To Prediction API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从脚本到预测 API</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/from-scripts-to-prediction-api-2372c95fb7c7?source=collection_archive---------32-----------------------#2020-08-16">https://towardsdatascience.com/from-scripts-to-prediction-api-2372c95fb7c7?source=collection_archive---------32-----------------------#2020-08-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="cd48" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">submission.csv？不用了，谢谢！</h2></div><p id="781e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是我上一篇文章的延续:</p><p id="20f9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lb" rel="noopener" target="_blank" href="/from-jupyter-notebook-to-sc-582978d3c0c">从 Jupyter 笔记本到脚本</a></p><p id="b81f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上次我们讨论了如何将 Jupyter Notebook 转换成脚本，以及各种基本的工程实践，如 CI、单元测试、包环境、配置、日志记录等</p><p id="8c4b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">即使是脚本形式，它仍然需要我们更改配置并运行脚本，这对于 Kaggle 比赛来说是可以的，因为你所需要的只是<strong class="kh ir"> submission.csv </strong>，但是你可能不想全天候坐在计算机后面，每当用户向你发送预测请求时就点击运行🙁</p><p id="f515" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将讨论如何利用我们上次构建的模型，并使用 FastAPI 创建预测 API 来提供模型服务！</p><blockquote class="lc ld le"><p id="8211" class="kf kg lf kh b ki kj jr kk kl km ju kn lg kp kq kr lh kt ku kv li kx ky kz la ij bi translated">对于 ML/DL 的乡亲们，我们说的是<a class="ae lb" href="https://fastapi.tiangolo.com/" rel="noopener ugc nofollow" target="_blank"> FastAPI </a>，不是<a class="ae lb" href="https://www.fast.ai/" rel="noopener ugc nofollow" target="_blank"> fast.ai </a>！！！</p></blockquote><h1 id="1af8" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">背景:FastAPI</h1><p id="71cc" class="pw-post-body-paragraph kf kg iq kh b ki mb jr kk kl mc ju kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">Python 生态系统中有很多针对 API 的框架，我最初的想法是用 Flask。但是我对 FastAPI 的简单和直观印象深刻，并且喜欢在这个迷你项目中尝试它！</p><p id="7184" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">“冰冻三尺，非一日之寒”，FastAPI 从 Django、Flask、APIStar 等之前的框架中学到了很多，我无法比创作者本人更好的解释<a class="ae lb" href="https://fastapi.tiangolo.com/history-design-future/" rel="noopener ugc nofollow" target="_blank">这篇文章</a>太棒了！</p><h1 id="2201" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">无聊但必要的设置</h1><p id="ba8d" class="pw-post-body-paragraph kf kg iq kh b ki mb jr kk kl mc ju kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">东西都在<a class="ae lb" href="https://github.com/G-Hung/model-productization_article" rel="noopener ugc nofollow" target="_blank"> one repo </a>这大概不是一个好的做法，应该是真实用例中不同的 GitHub repo，可能我以后会<em class="lf">重构</em>【专业的说法“清理我以前的 sxxt”】！</p><p id="abf7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">*CS 的人总是说<em class="lf">单一责任原则</em>，而不是说“不要把不同功能的代码放在一起”，下次也许你可以说“我们应该遵循单一责任原则！”</p><p id="2168" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，让我们用新的包更新 requirements.txt，正如我们上次提到的，我们应该指定<strong class="kh ir">确切的版本</strong>，这样其他人就可以复制这个作品了！</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="fce6" class="mp lk iq ml b gy mq mr l ms mt"># for last article<br/>pytest==6.0.1<br/>pandas==1.0.1<br/>Click==7.0<br/>scikit-learn==0.22.1<br/>black==19.10b0<br/>isort==4.3.21<br/>PyYAML==5.2</span><span id="b3d4" class="mp lk iq ml b gy mu mr l ms mt"># for FastAPI<br/>fastapi==0.61.0<br/>uvicorn==0.11.8<br/>chardet==3.0.4</span></pre><p id="4cd2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这之后，我们需要在 conda env 中再次安装 requirements.txt 因为我们有了新的包]</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="da27" class="mp lk iq ml b gy mq mr l ms mt"><em class="lf"># You can skip the line below if you have created conda env</em><br/>conda create - name YOU_CHANGE_THIS python=3.7 -y</span><span id="3ff8" class="mp lk iq ml b gy mu mr l ms mt">conda activate YOU_CHANGE_THIS</span><span id="90f8" class="mp lk iq ml b gy mu mr l ms mt">pip install –r requirements.txt</span></pre><h1 id="b12b" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">游戏计划</h1><p id="907c" class="pw-post-body-paragraph kf kg iq kh b ki mb jr kk kl mc ju kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">让我们想想发生了什么，我们希望有 API 端点来做预测，具体来说，如果用户给<strong class="kh ir"> us </strong>输入，我们需要使用模型来预测并返回预测。</p><p id="3521" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们没有让<strong class="kh ir">us</strong>【human】处理传入的请求，而是创建一个 API 服务器来等待请求、解析输入、进行预测并返回结果。API 只是与我们的计算机对话并请求服务的结构化方式[在这种情况下是预测]</p><figure class="mg mh mi mj gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi mv"><img src="../Images/79c61de3b2d0e17cfad5be1c7a0296e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GsXTWSGM4l1NsK7427Riyg.png"/></div></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">高层正在发生什么</p></figure><p id="d99e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是伪代码:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="588d" class="mp lk iq ml b gy mq mr l ms mt"><em class="lf"># Load trained model</em><br/>trained_model = load_model(model_path)</span><span id="bf35" class="mp lk iq ml b gy mu mr l ms mt"><em class="lf"># Let's create a API that can receive user request</em><br/>api = CreateAPI()</span><span id="0f98" class="mp lk iq ml b gy mu mr l ms mt"><em class="lf"># If user send us the request to `predict` endpoint</em><br/>when user sends request to `api`.`predict`:<br/>    input = api[`predict`].get(input) # get input<br/>    prediction = trained_model(input) # apply model<br/>    return prediction                 # return prediction</span></pre><p id="4ce1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这对快乐流有好处！但是我们应该<em class="lf">永远不要</em>相信用户，问问你自己，你会在日常生活中阅读用户手册吗？</p><p id="b12f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们期望从用户那里得到{'a': 1，' b': 2，' c': 3}，但是我们可能得到:</p><ul class=""><li id="dc16" class="nh ni iq kh b ki kj kl km ko nj ks nk kw nl la nm nn no np bi translated">顺序错误{'b': 2，' a': 1，' c': 3}，或</li><li id="a3f9" class="nh ni iq kh b ki nq kl nr ko ns ks nt kw nu la nm nn no np bi translated">错误的键{'a': 1，' b': 2，' d': 3}，或者</li><li id="dc3c" class="nh ni iq kh b ki nq kl nr ko ns ks nt kw nu la nm nn no np bi translated">缺少密钥{'a': 1，' b': 2}，或者</li><li id="491c" class="nh ni iq kh b ki nq kl nr ko ns ks nt kw nu la nm nn no np bi translated">负值{'a': -1，' b': 2，' c': 3}，或</li><li id="da9e" class="nh ni iq kh b ki nq kl nr ko ns ks nt kw nu la nm nn no np bi translated">错误的类型{ ' a ':' HELLO WORLD '，' b': 2，' c': 3}，或者</li><li id="d1af" class="nh ni iq kh b ki nq kl nr ko ns ks nt kw nu la nm nn no np bi translated">等等等等</li></ul><p id="3e80" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这对我们的 API 是致命的，因为我们的模型不知道如何对此做出响应。我们需要引入一些输入结构来保护我们！因此，我们应该更新我们的伪代码！</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="4b4d" class="mp lk iq ml b gy mq mr l ms mt"><strong class="ml ir"># Define input schema<br/>input_schema = {......}</strong></span><span id="8308" class="mp lk iq ml b gy mu mr l ms mt"><em class="lf"># Load trained model</em><br/>trained_model = load_model(model_path)</span><span id="2a3a" class="mp lk iq ml b gy mu mr l ms mt"><em class="lf"># Let's create a API that can receive user request</em><br/>api = CreateAPI()</span><span id="99eb" class="mp lk iq ml b gy mu mr l ms mt"><em class="lf"># If user send us the request to `predict` endpoint</em><br/>when user sends request to `api`.`predict`:<br/>    input = api[`predict`].get(input) # get input<strong class="ml ir">           <br/>    transformed_input = apply(input_schema, input)<br/>    if not transformed_input.valid(): return Error<br/></strong>    prediction = trained_model(<strong class="ml ir">transformed_input</strong>) # apply model<br/>    return prediction                 # return prediction</span></pre><h1 id="58be" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">代码</h1><p id="1aea" class="pw-post-body-paragraph kf kg iq kh b ki mb jr kk kl mc ju kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">我现在觉得不错！让我们用 FastAPI 一部分一部分地翻译它们吧！</p><p id="9527" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">输入模式</strong></p><p id="4737" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看起来有很多行，但事情是一样的，正如你所猜测的，我们定义了一个名为“Sample”的类，它将每个预测器定义为<em class="lf"> float </em>和<em class="lf">大于[gt] zero！</em></p><figure class="mg mh mi mj gt mw"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="4b0c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">负载模型</strong></p><p id="183e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们加载训练好的模型，嗯嗯什么是‘预测器’？它只是一个用不同方法包装模型的定制类，因此我们可以调用一个方法，而不是在 API 服务器中实现逻辑</p><figure class="mg mh mi mj gt mw"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="9d7a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">创建一个 API 服务器</strong></p><p id="28bf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们使用 FastAPI 创建 API 伪代码几乎已经是代码了</p><figure class="mg mh mi mj gt mw"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="7b10" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">预测终点</strong></p><p id="4e54" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这看起来很复杂，但是非常简单</p><p id="9f42" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不是说<em class="lf">“当用户向‘API’发送请求时。‘predict’”</em></p><p id="63d5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们说:<em class="lf">"嘿，app，如果有人发送"</em><strong class="kh ir"><em class="lf">GET</em></strong><em class="lf">请求"为了`预测'，请运行函数 predict_item，我们期望输入遵循我们在`示例`中定义的模式"</em></p><p id="92d4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lf"> predict_item </em>所做的只是转换输入形状，馈送给训练好的模型并返回预测，简单的 Python 函数</p><blockquote class="lc ld le"><p id="ab7a" class="kf kg lf kh b ki kj jr kk kl km ju kn lg kp kq kr lh kt ku kv li kx ky kz la ij bi translated">如果你想了解更多关于<a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods" rel="noopener ugc nofollow" target="_blank"> HTTP 请求方法</a></p></blockquote><figure class="mg mh mi mj gt mw"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="34d4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是你可能会问:哎！少了一行！！！输入验证在哪里？如果用户提供了错误的数据类型/键或者遗漏了一个字段，该怎么办？</p><p id="fbf1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">嗯……还记得我们已经为输入模式定义了“Sample”类吗？快速 API <strong class="kh ir">自动</strong>根据模式为我们验证它，我们不需要关心这个！！！这为构建一个健壮的、经过良好测试的 API 节省了大量的脑力和代码！</p><h1 id="d9ac" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">尝试使用</h1><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="a89a" class="mp lk iq ml b gy mq mr l ms mt"># At project root, we can run this<br/># --reload is for development, API server autorefresh<br/># when you change the code</span><span id="c068" class="mp lk iq ml b gy mu mr l ms mt">uvicorn prediction_api.main:app --reload</span></pre><p id="c062" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你应该能看到这些，API 服务器现在运行在“http://127.0.0.1:8000”上！</p><figure class="mg mh mi mj gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nx"><img src="../Images/45cad740f37e2165bf5b3175f533f754.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xs5rUO80zSvDT7o-skVubw.png"/></div></div></figure><p id="cd8a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根据您的环境，有不同的方法来试验 API，您可以在 Python 中使用<em class="lf">请求，在命令行中使用</em>或<em class="lf"> cURL。</em> BTW 有一个好用的工具叫做<a class="ae lb" href="https://www.postman.com/" rel="noopener ugc nofollow" target="_blank">邮差</a>，试试吧，这是一个非常直观和人性化的 API 工具！</p><p id="22a9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将在下面的例子中使用 Python 请求，你可以在<a class="ae lb" href="https://github.com/G-Hung/model-productization_article/blob/master/notebook/prediction_API_test.ipynb" rel="noopener ugc nofollow" target="_blank">这本笔记本</a>中看到它们【有时 Jupyter 是有帮助的😎]</p><blockquote class="lc ld le"><p id="ae23" class="kf kg lf kh b ki kj jr kk kl km ju kn lg kp kq kr lh kt ku kv li kx ky kz la ij bi translated">下面的例子使用了一个有效的输入:耶！😍我们成功了！端点返回预测！！！</p></blockquote><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="7e7e" class="mp lk iq ml b gy mq mr l ms mt">payload = {<br/>    "fixed_acidity": 10.5,<br/>    "volatile_acidity": 0.51,<br/>    "citric_acid": 0.64,<br/>    "residual_sugar": 2.4,<br/>    "chlorides": 0.107,<br/>    "free_sulfur_dioxide": 6.0,<br/>    "total_sulfur_dioxide": 15.0,<br/>    "density": 0.9973,<br/>    "pH": 3.09,<br/>    "sulphates": 0.66,<br/>    "alcohol": 11.8,<br/>}</span><span id="2ff2" class="mp lk iq ml b gy mu mr l ms mt">result = requests.get("<a class="ae lb" href="http://127.0.0.1:8000/predict" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8000/predict</a>", data = json.dumps(payload))</span><span id="3634" class="mp lk iq ml b gy mu mr l ms mt">print(result.json())</span><span id="8d64" class="mp lk iq ml b gy mu mr l ms mt"><strong class="ml ir">Output</strong><br/>{'prediction': 1, 'utc_ts': 1597537570, 'model': 'RandomForestClassifier'}</span></pre><blockquote class="lc ld le"><p id="d69f" class="kf kg lf kh b ki kj jr kk kl km ju kn lg kp kq kr lh kt ku kv li kx ky kz la ij bi translated">下面的例子遗漏了一个字段，FastAPI 帮助我们根据我们定义的模式来处理它，除了模式类，我什么也没写</p></blockquote><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="8ee0" class="mp lk iq ml b gy mq mr l ms mt">payload = {<br/>    "volatile_acidity": 0.51,<br/>    "citric_acid": 0.64,<br/>    "residual_sugar": 2.4,<br/>    "chlorides": 0.107,<br/>    "free_sulfur_dioxide": 6.0,<br/>    "total_sulfur_dioxide": 15.0,<br/>    "density": 0.9973,<br/>    "pH": 3.09,<br/>    "sulphates": 0.66,<br/>    "alcohol": 11.8,<br/>}</span><span id="70b9" class="mp lk iq ml b gy mu mr l ms mt">result = requests.get("<a class="ae lb" href="http://127.0.0.1:8000/predict" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8000/predict</a>", data = json.dumps(payload))</span><span id="5f49" class="mp lk iq ml b gy mu mr l ms mt">print(result.json())</span><span id="aa22" class="mp lk iq ml b gy mu mr l ms mt"><strong class="ml ir">Output</strong><br/>{'detail': [{'loc': ['body', 'fixed_acidity'], 'msg': 'field required', 'type': 'value_error.missing'}]}</span></pre><p id="8bbd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">只是为了好玩，我还实现了一个<em class="lf"> update_model </em> PUT API 来交换模型，例如，最初我们使用随机森林，我将其更新为渐变 Boosting☺️</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="4f96" class="mp lk iq ml b gy mq mr l ms mt">result = requests.put("<a class="ae lb" href="http://127.0.0.1:8000/update_model" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8000/update_model</a>")</span><span id="238f" class="mp lk iq ml b gy mu mr l ms mt">print(result.json())</span><span id="9e9f" class="mp lk iq ml b gy mu mr l ms mt"><strong class="ml ir">Output</strong><br/>{'old_model': 'RandomForestClassifier', 'new_model': 'GradientBoostingClassifier', 'utc_ts': 1597537156}</span></pre><h1 id="f2ab" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">自动生成的文档</h1><p id="05e9" class="pw-post-body-paragraph kf kg iq kh b ki mb jr kk kl mc ju kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">其中一个很酷的 FastAPI 特性是 auto-document，只需进入<a class="ae lb" href="http://127.0.0.1:8000/docs#/" rel="noopener ugc nofollow" target="_blank">http://127 . 0 . 0 . 1:8000/docs #/</a>即可获得开箱即用的交互式强大 API 文档！如此直观，我不需要细说</p><figure class="mg mh mi mj gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi ny"><img src="../Images/4f200ed783a50850459d4e9f60900043.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z9kx20rUhTZU6FhqZVtr1A.png"/></div></div></figure><h1 id="ff86" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">重访 pytest</h1><p id="ba39" class="pw-post-body-paragraph kf kg iq kh b ki mb jr kk kl mc ju kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">我再怎么强调单元测试的重要性也不为过，它验证了函数正在做我们期望它们做的事情，这样你就不会不小心弄坏东西了！</p><p id="2a3c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，如果我试图涵盖每一个测试，这将是太无聊和冗长。我打算在这里分享一些我会无脑测试的领域&amp;一些[可能有用的]文章。然后我会讲一个叫参数化单元测试的 pytest 特性，以及 pytest 中的一些测试选项。激励自己学习单元测试最简单的方法就是尝试重构你之前的代码，越大越好！</p><p id="9d32" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">单元测试</strong></p><p id="b386" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每当你发现编写/理解单元测试有困难时，你可能需要首先回顾你的代码结构。以下是我会不假思索考虑的 4 个方面:</p><ol class=""><li id="274b" class="nh ni iq kh b ki kj kl km ko nj ks nk kw nl la nz nn no np bi translated">输入数据:dimension [eg: df.shape]，type [eg: str]，值域[eg: -/0/+]</li><li id="be5f" class="nh ni iq kh b ki nq kl nr ko ns ks nt kw nu la nz nn no np bi translated">输出数据:dimension [eg: df.shape]，type [eg: str]，取值范围[eg: -/0/+]</li><li id="dfc4" class="nh ni iq kh b ki nq kl nr ko ns ks nt kw nu la nz nn no np bi translated">比较:输出和预期结果</li><li id="21dd" class="nh ni iq kh b ki nq kl nr ko ns ks nt kw nu la nz nn no np bi translated">我调试后，防止它再次发生</li></ol><p id="69fd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我非常关注下面的输出维度、类型和值范围。这似乎很简单，但如果你修改任何输出格式，它会提醒你什么是预期的格式！</p><figure class="mg mh mi mj gt mw"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="1c26" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">FYR 的一些文章:</p><p id="34be" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lb" rel="noopener" target="_blank" href="/unit-testing-for-data-scientists-dc5e0cd397fb">数据科学家的单元测试</a></p><p id="bf62" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lb" href="https://medium.com/@keeper6928/how-to-unit-test-machine-learning-code-57cf6fd81765" rel="noopener">如何单元测试机器学习代码</a>【深度学习】</p><p id="551e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">参数化单元测试</strong></p><p id="d055" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设您有 100 个模拟数据[用 D_i，i: 1 标注..100]并且你想为它们中的每一个运行相同的单元测试，你会怎么做呢？</p><blockquote class="lc ld le"><p id="00fc" class="kf kg lf kh b ki kj jr kk kl km ju kn lg kp kq kr lh kt ku kv li kx ky kz la ij bi translated"><em class="iq">蛮力大法</em></p></blockquote><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="c6f1" class="mp lk iq ml b gy mq mr l ms mt">def test_d1():<br/>    assert some_operation(D_1)</span><span id="470a" class="mp lk iq ml b gy mu mr l ms mt">def test_d2():<br/>    assert some_operation(D_2)</span><span id="cbde" class="mp lk iq ml b gy mu mr l ms mt">def test_d3():<br/>    assert some_operation(D_3)</span><span id="0e6e" class="mp lk iq ml b gy mu mr l ms mt">......</span><span id="96d2" class="mp lk iq ml b gy mu mr l ms mt">def test_d100():<br/>    assert some_operation(D_100)</span></pre><p id="5b45" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是如果你需要修改“some_operation ”,你需要修改 100 次 LOL……虽然你可以把它作为一个实用函数，但这使得测试很难阅读，而且非常冗长</p><blockquote class="lc ld le"><p id="71c6" class="kf kg lf kh b ki kj jr kk kl km ju kn lg kp kq kr lh kt ku kv li kx ky kz la ij bi translated"><em class="iq">更好的方法也许是 for-loop？</em></p></blockquote><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="4f40" class="mp lk iq ml b gy mq mr l ms mt">def test_d():<br/>    for D in [D_1, D_2, D_3, ..., D_100]:<br/>        assert some_operation(D)</span></pre><p id="c4bd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是你不能确切地知道哪些测试失败了，因为这 100 个测试都在一个测试中</p><blockquote class="lc ld le"><p id="0bc2" class="kf kg lf kh b ki kj jr kk kl km ju kn lg kp kq kr lh kt ku kv li kx ky kz la ij bi translated"><em class="iq"> pytest 为我们提供了一个名为</em> <strong class="kh ir"> <em class="iq">参数化</em> </strong>的特性</p></blockquote><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="b576" class="mp lk iq ml b gy mq mr l ms mt"><a class="ae lb" href="http://twitter.com/pytest" rel="noopener ugc nofollow" target="_blank">@pytest</a>.mark.parametrize("test_object", [D_1, D_2, ..., D_100])<br/>def test_d(test_object):<br/>    assert some_operation(test_object)</span></pre><p id="d207" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">常见 pytest 选项</strong></p><blockquote class="lc ld le"><p id="bf3e" class="kf kg lf kh b ki kj jr kk kl km ju kn lg kp kq kr lh kt ku kv li kx ky kz la ij bi translated"><strong class="kh ir"> pytest 文件夹</strong></p></blockquote><p id="2f11" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上次我们提到我们可以在命令行中运行`<strong class="kh ir">pytest</strong>', pytest 会在文件夹下找到所有的<strong class="kh ir">测试。但是有时我们可能不想在开发过程中运行所有的单元测试[也许一些测试花费了很长时间，但是与您当前的任务无关]</strong></p><p id="83dc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种情况下，你可以简单地运行<strong class="kh ir"> pytest 文件夹</strong>，例如:` pytest。/scripts '或' pytest。演示中的/prediction_api '</p><blockquote class="lc ld le"><p id="6986" class="kf kg lf kh b ki kj jr kk kl km ju kn lg kp kq kr lh kt ku kv li kx ky kz la ij bi translated"><strong class="kh ir">并行 pytest </strong></p></blockquote><p id="e62a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有时你的测试用例太重，并行运行可能是个好主意！您可以安装<strong class="kh ir"> pytest-xdist </strong>并在您的命令中用 py.test 替换 pytest，例如:py.test -n 4</p><blockquote class="lc ld le"><p id="569a" class="kf kg lf kh b ki kj jr kk kl km ju kn lg kp kq kr lh kt ku kv li kx ky kz la ij bi translated"><strong class="kh ir"> pytest -v </strong></p></blockquote><p id="dc67" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是个人喜好，我更喜欢冗长的输出，看到绿色通过✅开始我的一天</p><figure class="mg mh mi mj gt mw gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/113346765a25413b3ad39e145a2b82f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1290/format:webp/1*sUDohl0QJYRXPYH4UI1Afw.png"/></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">pytest</p></figure><figure class="mg mh mi mj gt mw gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/607c7d1b096e83f3f3562543fd209a47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/format:webp/1*4DnxRvvL1ajmXBrkQWh-VQ.png"/></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">pytest -v</p></figure><blockquote class="lc ld le"><p id="037e" class="kf kg lf kh b ki kj jr kk kl km ju kn lg kp kq kr lh kt ku kv li kx ky kz la ij bi translated">您可以从以下材料中了解更多信息:</p><p id="40b9" class="kf kg lf kh b ki kj jr kk kl km ju kn lg kp kq kr lh kt ku kv li kx ky kz la ij bi translated"><a class="ae lb" href="https://docs.pytest.org/en/stable/" rel="noopener ugc nofollow" target="_blank">https://docs.pytest.org/en/stable/</a></p><p id="20c1" class="kf kg lf kh b ki kj jr kk kl km ju kn lg kp kq kr lh kt ku kv li kx ky kz la ij bi translated"><a class="ae lb" href="https://www.guru99.com/pytest-tutorial.html#5" rel="noopener ugc nofollow" target="_blank">https://www.guru99.com/pytest-tutorial.html#5</a></p></blockquote><h2 id="810d" class="mp lk iq bd ll oc od dn lp oe of dp lt ko og oh lv ks oi oj lx kw ok ol lz om bi translated">最后，我希望你能和我一样喜欢这个 1 分钟的 Youtube 视频😆</h2><h1 id="d090" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">结论</h1><p id="37e1" class="pw-post-body-paragraph kf kg iq kh b ki mb jr kk kl mc ju kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">Yooo✋:我们已经创建了一个使用我们模型的预测 API，用户现在可以发送请求并获得预测，而无需人工参与，这过度简化了现实[吞吐量、延迟、模型管理、身份验证、AB 测试等]，但这就是我们的想法！</p><p id="c861" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">至少如果你的原型达到了这个水平，工程师们会更乐意接手，从而加快整个过程，你可以向他们展示你知道一些东西😈</p><p id="f845" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们:</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="dfa4" class="mp lk iq ml b gy mq mr l ms mt">a. Update conda env [requirements.txt]<br/>b. Brainstorm pseudocode and convert to code [FastAPI, uvicorn]<br/>c. Utilize API [cURL, requests, Postman]<br/>d. Talk about Auto-generated documents by FastAPI<br/>e. Some pytest techniques [parallel, parameterized, -v]</span></pre><p id="5fb8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面的文件树显示了开发步骤</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="9610" class="mp lk iq ml b gy mq mr l ms mt">.<br/>├── notebook<br/>│   ├── prediction-of-quality-of-wine.ipynb<br/>│   └── prediction_API_test.ipynb           [c] &lt;-consume API<br/>├── prediction_api<br/>│   ├── __init__.py<br/>│   ├── api_utility.py                      [b] &lt;-wrap up methods<br/>│   ├── main.py                             [b] &lt;-modify demo<br/>│   ├── mock_data.py                        [e] &lt;-Unit test<br/>│   ├── test_api_utility.py                 [e] &lt;-Unit test<br/>│   └── test_main.py                        [e] &lt;-Unit test<br/>├── requirements.txt                        [a] &lt;-FastAPI doc<br/>.<br/>.<br/>.</span></pre><p id="1272" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">但是</strong>(还是那句话，坏消息通常以 BUT 开头)它们还在我的<strong class="kh ir">本地</strong>电脑上。</p><p id="df92" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽管我们不需要坐在后面点击 Run，但是用户请求不能到达 API 端点。即使他们这样做了，这也意味着我不能关闭我的 Macbook，这意味着如果有许多传入的预测请求，我就不能扩展😱！！！</p><p id="c0b6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们在上一篇文章中提到的，逃离这个地狱的方法是，要么购买另一台计算机，要么从 AWS 等云提供商那里租用服务器</p><p id="7144" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是首先，我们还需要确保代码在那里工作正常！怎么会？</p><p id="a43b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">简答:Docker</p><p id="8250" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">旁白:</strong></p><p id="913c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然我没有尝试过，但有一家名为<a class="ae lb" href="https://docs.cortex.dev/" rel="noopener ugc nofollow" target="_blank"> Cortex </a>的初创公司专注于开源机器学习 API 框架，他们<a class="ae lb" rel="noopener" target="_blank" href="/why-we-switched-from-flask-to-fastapi-for-production-machine-learning-765aab9b3679">也在幕后使用 FastAPI </a>！</p><p id="c59a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">到现在，你应该能理解他们的教程了，简而言之，他们在幕后解决了滚动更新、DL 模型推理、与 AWS 集成、自动缩放等许多生产层面的问题……这些都是<em class="lf"> DevOps </em>关心的问题？或者用一个更好的术语:<em class="lf"> MLOps </em></p><p id="35e2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是从用户的角度来看，他们使用声明性的 yml 部署 APIs 类似于我们在上一篇文章中配置模型的方式]，有一个预测器类[类似于我们的预测器类]，trainer . py[类似于上一篇文章中的 train.py</p></div><div class="ab cl on oo hu op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="ij ik il im in"><p id="15fe" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">编写代码相对容易，但是为代码写一篇文章却很难，如果你觉得这篇文章有用，你可以留下一些评论</p><p id="7403" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者你可以开始我的<a class="ae lb" href="https://github.com/G-Hung/model-productization_article" rel="noopener ugc nofollow" target="_blank">回购</a>！</p><p id="6855" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者<a class="ae lb" href="https://www.linkedin.com/in/geoffreyhung/" rel="noopener ugc nofollow" target="_blank">我的 LinkedIn </a>【欢迎但请留话表示你不是僵尸】！</p></div></div>    
</body>
</html>