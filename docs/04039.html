<html>
<head>
<title>K-Means Clustering Explained: Algorithm And Sklearn Implementation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">K-Means 聚类讲解:算法和 Sklearn 实现</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/k-means-clustering-explained-algorithm-and-sklearn-implementation-1fe8e104e822?source=collection_archive---------57-----------------------#2020-04-13">https://towardsdatascience.com/k-means-clustering-explained-algorithm-and-sklearn-implementation-1fe8e104e822?source=collection_archive---------57-----------------------#2020-04-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2bcb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><em class="ki">聚类和 k-means 聚类简介。详细概述和 sklearn 实现。</em></h2></div><p id="72d1" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><strong class="kl iu"> K-Means </strong>聚类是数据科学和机器学习领域中最强大的聚类算法之一。它非常简单，但却能产生非常好的效果。因为聚类是理解数据集的一个非常重要的步骤，所以在本文中，我们将讨论什么是聚类，我们为什么需要它，以及 k-means 聚类在数据科学中对我们有什么帮助。</p><h1 id="30e1" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">文章概述:</h1><ul class=""><li id="2933" class="lx ly it kl b km lz kp ma ks mb kw mc la md le me mf mg mh bi translated">什么是集群</li><li id="153d" class="lx ly it kl b km mi kp mj ks mk kw ml la mm le me mf mg mh bi translated">什么是无监督机器学习</li><li id="8c45" class="lx ly it kl b km mi kp mj ks mk kw ml la mm le me mf mg mh bi translated">集群应用</li><li id="e41b" class="lx ly it kl b km mi kp mj ks mk kw ml la mm le me mf mg mh bi translated">k-均值聚类解释</li><li id="0643" class="lx ly it kl b km mi kp mj ks mk kw ml la mm le me mf mg mh bi translated">k-均值聚类算法</li><li id="ca64" class="lx ly it kl b km mi kp mj ks mk kw ml la mm le me mf mg mh bi translated">使用 Scikit-Learn 和 Python 实现 K-Means 聚类</li></ul><h1 id="d1a9" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">什么是集群</h1><p id="ae97" class="pw-post-body-paragraph kj kk it kl b km lz ju ko kp ma jx kr ks mn ku kv kw mo ky kz la mp lc ld le im bi translated"><strong class="kl iu">聚类</strong>的任务是根据数据的属性，更确切地说是根据数据中或多或少明显的某些模式，将数据分组为两个或多个组。我们的目标是找到数据中的那些模式，帮助我们确定，给定数据集中的某个项目，我们将能够正确地将该项目放在正确的组中，以便它与该组中的其他项目相似，但与其他组中的项目不同。</p><p id="4100" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">这意味着聚类实际上由两部分组成:一部分是识别组，另一部分是尽可能将每个项目放在正确的组中。</p><p id="b4d8" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">聚类分析算法的理想结果是同一组中的两个项目尽可能相似，而不同组中的两个项目尽可能不同。</p><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi mq"><img src="../Images/49afb7bd7c70170618d29a1dbf4fcd56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v_FsOLPh96Hvha8UiLXr5A.png"/></div></div><p class="nc nd gj gh gi ne nf bd b be z dk translated">聚类示例—来源:<a class="ae ng" href="https://en.wikipedia.org/wiki/Cluster_analysis" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></figure><p id="8040" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">一个真实的例子是<strong class="kl iu">客户细分</strong>。作为一家销售各种产品/服务的企业，很难为每个客户找到完美的商业策略。但我们可以明智地将我们的客户分成几个小组，了解这些客户的共同点，并针对每个小组调整我们的业务策略。向客户提出错误的商业策略可能意味着失去该客户，因此我们实现了良好的市场聚类非常重要。</p><h1 id="03b0" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">什么是无监督机器学习</h1><p id="fa92" class="pw-post-body-paragraph kj kk it kl b km lz ju ko kp ma jx kr ks mn ku kv kw mo ky kz la mp lc ld le im bi translated">无监督机器学习是一种机器学习算法，它试图在没有任何先验知识的情况下推断数据中的模式。与之相反的是监督机器学习，我们有一个训练集，算法将通过将输入与预定义的输出进行匹配来试图找到数据中的模式。</p><p id="73f5" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我写这个的原因是因为<strong class="kl iu">聚类一个无监督的机器学习任务</strong>。当应用聚类算法时，我们事先不知道类别(尽管我们可以设置想要被识别的类别的数量)。</p><p id="5d88" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">分类将从分析数据的算法中产生。正因为如此，我们可以称聚类为探索性的机器学习任务，因为我们只知道类别的数量，而不知道它们的属性。然后，我们可以尝试使用不同数量的类别，看看我们的数据是否有更好的聚类。</p><p id="19e6" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">然后，我们必须了解我们的集群，这实际上可能是最不同的任务。让我们重新使用客户细分的例子。假设我们运行了一个聚类算法，将我们的客户分为 3 组。但是那些群体是什么呢？为什么算法决定这些客户适合这个组，而那些客户适合那个组？这是你需要非常熟练的数据科学家以及非常了解你的业务的人的部分。他们会查看数据，尝试分析每个类别中的一些项目，并尝试猜测一些标准。一旦他们找到一个有效的模式，他们就会从那里进行推断。</p><p id="9e01" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">当我们得到一个新客户时会发生什么？我们必须将该客户放入我们已经拥有的一个聚类中，这样我们就可以通过我们的算法运行关于该客户的数据，并且该算法将使我们的客户适合我们的一个聚类。此外，在未来，在我们获得大量新客户后，我们可能需要重建我们的集群——可能新的集群会出现，也可能旧的集群会消失。</p><h1 id="ae7d" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">集群应用</h1><p id="61ea" class="pw-post-body-paragraph kj kk it kl b km lz ju ko kp ma jx kr ks mn ku kv kw mo ky kz la mp lc ld le im bi translated"><strong class="kl iu">有哪些常见的集群应用？</strong>在我们爱上聚类算法之前，我们需要了解什么时候可以使用它们，什么时候不可以。</p><p id="1773" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">最常见的用例是我们已经讨论过的:<strong class="kl iu">客户/市场细分</strong>。公司无时无刻不在进行这种类型的分析，以便了解他们的客户和市场，并调整他们的商业策略、服务和产品，使之更适合他们。</p><p id="6ac4" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">另一个常见的用例由<strong class="kl iu">信息提取任务</strong>表示。在信息抽取任务中，我们经常需要发现实体、单词、文档等之间的关系。现在，如果你的直觉告诉你，我们有更大的机会找到彼此更相似的项目之间的关系，那么你是对的，因为对我们的数据点进行聚类可能会帮助我们找出在哪里寻找关系。(注:如果想了解更多关于信息抽取的内容，也可以试试这篇文章:<a class="ae ng" href="https://programmerbackpack.com/python-nlp-tutorial-information-extraction-and-knowledge-graphs/" rel="noopener ugc nofollow" target="_blank"> Python NLP 教程:信息抽取和知识图</a>)。</p><p id="b278" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">另一个非常流行的用例是使用聚类进行<strong class="kl iu">图像分割</strong>。图像分割是观察图像并试图识别图像中不同项目的任务。我们可以使用聚类来分析图像的像素，并识别图像中的哪个项目包含哪个像素。</p><h1 id="3862" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">k-均值聚类解释</h1><p id="c94b" class="pw-post-body-paragraph kj kk it kl b km lz ju ko kp ma jx kr ks mn ku kv kw mo ky kz la mp lc ld le im bi translated"><strong class="kl iu">K-Means 聚类算法</strong>是一种迭代聚类算法，它试图将数据点准确地分配到我们预定义的<em class="nh"> K </em>个聚类中的一个聚类。</p><p id="76f6" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">与任何其他聚类算法一样，它试图使一个聚类中的项目尽可能相似，同时也使这些聚类尽可能互不相同。这是通过确保一个聚类中的数据点与该聚类的<strong class="kl iu">质心</strong>之间的平方距离之和最小来实现的。聚类的质心是聚类中所有值的平均值<strong class="kl iu"/>。你也可以从这一段了解到<strong class="kl iu">K-的意思是</strong>的来源。</p><p id="9d87" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">用更专业的术语来说，我们试图将数据放入一个尽可能<em class="nh">同质</em>的集群，同时尽可能<em class="nh">异质</em>的集群。K 数是我们试图获得的集群数。我们可以摆弄 K，直到我们对结果满意为止。</p><h1 id="5ed2" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">k-均值聚类算法</h1><p id="da52" class="pw-post-body-paragraph kj kk it kl b km lz ju ko kp ma jx kr ks mn ku kv kw mo ky kz la mp lc ld le im bi translated">K-Means 聚类算法只需要几个简单的步骤。</p><ol class=""><li id="2171" class="lx ly it kl b km kn kp kq ks ni kw nj la nk le nl mf mg mh bi translated">分配<em class="nh"> K </em>组数</li><li id="cc89" class="lx ly it kl b km mi kp mj ks mk kw ml la mm le nl mf mg mh bi translated">混洗数据并将每个数据点随机分配到<em class="nh"> K </em>个簇中的一个，并分配初始随机质心。</li><li id="b6c4" class="lx ly it kl b km mi kp mj ks mk kw ml la mm le nl mf mg mh bi translated">计算每个数据点和所有质心之间的平方和。</li><li id="87ac" class="lx ly it kl b km mi kp mj ks mk kw ml la mm le nl mf mg mh bi translated">根据步骤 3 的计算，将每个数据点重新分配到最近的质心。</li><li id="0a6a" class="lx ly it kl b km mi kp mj ks mk kw ml la mm le nl mf mg mh bi translated">通过计算每个聚类的平均值来重新分配质心</li><li id="4dbe" class="lx ly it kl b km mi kp mj ks mk kw ml la mm le nl mf mg mh bi translated">重复步骤 3、4、5，直到我们不再需要更改集群中的任何内容</li></ol><p id="6f57" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">运行 K 均值聚类算法所需的时间取决于数据集的大小、我们定义的 K 数以及数据中的模式。</p><h1 id="6be6" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">使用 Scikit-Learn 和 Python 实现 K-Means 聚类</h1><p id="b316" class="pw-post-body-paragraph kj kk it kl b km lz ju ko kp ma jx kr ks mn ku kv kw mo ky kz la mp lc ld le im bi translated">我们将使用<strong class="kl iu"> Sckikit-Learn Python </strong>库在一个小数据集上运行 K-Means 聚类算法。</p><h1 id="829e" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">K 均值聚类算法的数据集</h1><p id="4311" class="pw-post-body-paragraph kj kk it kl b km lz ju ko kp ma jx kr ks mn ku kv kw mo ky kz la mp lc ld le im bi translated">该数据由关于伦敦、巴黎和柏林的 3 个文本组成。我们将提取维基百科中关于这三个城市的文章的摘要部分，并通过我们的聚类算法来运行它们。</p><p id="d0b4" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">然后，我们将提供 3 个我们自己的新句子，并检查它们是否被正确地分配到各个组。如果发生这种情况，我们就知道我们的聚类算法起作用了。</p><h1 id="a4d6" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">k-均值聚类实现</h1><p id="2206" class="pw-post-body-paragraph kj kk it kl b km lz ju ko kp ma jx kr ks mn ku kv kw mo ky kz la mp lc ld le im bi translated">首先让我们安装我们的依赖项。</p><pre class="mr ms mt mu gt nm nn no np aw nq bi"><span id="9a3b" class="nr lg it nn b gy ns nt l nu nv"># Sklearn library for our cluster<br/>pip3 install scikit-learn<br/># We will use nltk(Natural Language Toolkit) to remove stopwords from the text<br/>pip3 install nltk<br/># We will use the wikipedia library to download our texts from the Wikipedia pages<br/>pip3 install wikipedia</span></pre><p id="8cd3" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">现在让我们定义一个小类来帮助我们从维基百科页面收集文本。我们将文本存储到本地的 3 个文件中，这样我们就不会在每次运行算法时再次下载文本。第一次运行算法时使用 class，第二次运行时可以注释第 8-12 行，取消第 13-15 行的注释。</p><pre class="mr ms mt mu gt nm nn no np aw nq bi"><span id="1095" class="nr lg it nn b gy ns nt l nu nv">import wikipedia<br/><br/><br/>class TextFetcher:<br/><br/>    def __init__(self, title):<br/>        self.title = title<br/>        page = wikipedia.page(title) # 8<br/>        f = open(title + ".txt", "w") # 9<br/>        f.write(page.summary) # 10<br/>        f.close() # 11<br/>        self.text = page.summary # 12<br/>        #f = open(title + ".txt", "r")<br/>        #self.text = f.read()<br/>        #f.close()<br/><br/>    def getText(self):<br/>        return self.text<!-- --> </span></pre><p id="5272" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">现在让我们构建数据集。我们将获取关于每个城市的文本，并删除<strong class="kl iu">停用词</strong>。<strong class="kl iu"> </strong>停用词是我们通常在每次文本处理任务之前过滤掉的词。它们是英语中非常常见的单词，不会给文本带来任何价值和意义。因为它们中的大多数在任何地方都被使用，它们将阻止我们正确地对我们的文本进行聚类。</p><pre class="mr ms mt mu gt nm nn no np aw nq bi"><span id="f01a" class="nr lg it nn b gy ns nt l nu nv">from text_fetcher import TextFetcher<br/>from nltk.corpus import stopwords<br/>from nltk.tokenize import word_tokenize<br/>from sklearn.feature_extraction.text import TfidfVectorizer<br/>from sklearn.cluster import KMeans<br/>import nltk<br/><br/>def preprocessor(text):<br/>    nltk.download('stopwords')<br/>    tokens = word_tokenize(text)<br/>    return (" ").join([word for word in tokens if word not in stopwords.words()])<br/><br/><br/>if __name__ == "__main__":<br/>    textFetcher = TextFetcher("London")<br/>    text1 = preprocessor(textFetcher.getText())<br/>    textFetcher = TextFetcher("Paris")<br/>    text2 = preprocessor(textFetcher.getText())<br/>    textFetcher = TextFetcher("Berlin")<br/>    text3 = preprocessor(textFetcher.getText())<br/><br/>    docs = [text1, text2, text3]</span></pre><h1 id="efbc" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">单词矢量化技术</h1><p id="0f4c" class="pw-post-body-paragraph kj kk it kl b km lz ju ko kp ma jx kr ks mn ku kv kw mo ky kz la mp lc ld le im bi translated">众所周知，计算机非常不擅长理解文本，但它们在处理数字方面表现得更好。因为我们的数据集是由单词组成的，所以我们需要将单词转换成数字。</p><p id="4e01" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><strong class="kl iu">单词嵌入或单词矢量化</strong>代表一组用于将单词分配给实数向量的技术，这些技术可由机器学习用于某些目的，其中之一是文本聚类。</p><p id="06fe" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">Scikit-Learn 库包含一些单词矢量器，但是对于本文，我们将选择<em class="nh">tfidfvector。</em></p><pre class="mr ms mt mu gt nm nn no np aw nq bi"><span id="bb4b" class="nr lg it nn b gy ns nt l nu nv">tfidf_vectorizer = TfidfVectorizer()<br/>tfidf = tfidf_vectorizer.fit_transform(docs)</span></pre><p id="2a12" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">现在是时候应用我们的 K 均值聚类算法了。幸运的是，Scikit-Learn 有一个非常好的 K-Means 算法实现，我们将使用它。因为我们知道要将文本分为 3 类(每个城市一类),所以我们将定义 K 值为 3。</p><pre class="mr ms mt mu gt nm nn no np aw nq bi"><span id="6dd4" class="nr lg it nn b gy ns nt l nu nv">kmeans = KMeans(n_clusters=3).fit(tfidf)<br/>print (kmeans)<br/><br/># Output: [0 1 2]</span></pre><p id="c48b" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我知道，就这么简单！现在我们的产量意味着什么？简单地说，这 3 个值就是我们的 3 个集群。</p><p id="1d2a" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">为了测试它们，我们现在可以提供 3 个文本，我们确定它们应该在不同的簇中，看看它们是否被正确分配。我们必须确保不要忘记对这 3 个文本进行矢量化，以便我们的算法能够理解它们。</p><pre class="mr ms mt mu gt nm nn no np aw nq bi"><span id="26ae" class="nr lg it nn b gy ns nt l nu nv">    test = ["This is one is about London.", "London is a beautiful city", "I love London"]<br/>    results = kmeans.predict(tfidf_vectorizer.transform(test))<br/>    print (results)<br/>    <br/>    # Prints [0, 0, 0]<br/><br/>    test = ["This is one is about Paris.", "Paris is a beautiful city", "I love Paris"]<br/>    results = kmeans.predict(tfidf_vectorizer.transform(test))<br/>    print (results)<br/>    <br/>    # Prints [2, 2, 2]<br/><br/>    test = ["This is one is about Berlin.", "Berlin is a beautiful city", "I love Berlin"]<br/>    results = kmeans.predict(tfidf_vectorizer.transform(test))<br/>    print(results)<br/>    <br/>    # Prints [1, 1, 1]<br/><br/>    test = ["This is about London", "This is about Paris", "This is about Vienna"]<br/>    results = kmeans.predict(tfidf_vectorizer.transform(test))<br/>    print (results)<br/>    <br/>    # Prints [0, 2, 1]</span></pre><p id="3c83" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">看起来我们的集群成功了！现在让我们假设我们会得到另一个我们一无所知的文本。我们可以将该文本通过我们的分类器，看看它属于哪个类别。我认为这是一个非常好和有效的文本分类器。</p><h1 id="0fb5" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">结论</h1><p id="2947" class="pw-post-body-paragraph kj kk it kl b km lz ju ko kp ma jx kr ks mn ku kv kw mo ky kz la mp lc ld le im bi translated">今天我们讨论了 K 均值聚类算法。我们首先对聚类算法和无监督机器学习技术进行了概述，然后讨论了 K-Means 算法，并使用 Scikit-Learn Python 库实现了它。</p><p id="2eed" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><em class="nh">本文原载于</em> <a class="ae ng" href="https://programmerbackpack.com/k-means-clustering-explained/" rel="noopener ugc nofollow" target="_blank"> <em class="nh">程序员背包博客</em> </a> <em class="nh">。如果你想阅读更多这类的故事，一定要访问这个博客。</em></p><p id="1435" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">非常感谢你阅读这篇文章！对更多这样的故事感兴趣？在 Twitter 上关注我，在<a class="ae ng" href="https://twitter.com/b_dmarius" rel="noopener ugc nofollow" target="_blank"><em class="nh">@ b _ dmarius</em></a><em class="nh">我会在那里发布每一篇新文章。</em></p></div></div>    
</body>
</html>