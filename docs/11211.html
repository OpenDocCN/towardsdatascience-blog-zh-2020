<html>
<head>
<title>Machine Learning for Building Recommender System in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Python 构建推荐系统的机器学习</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/machine-learning-for-building-recommender-system-in-python-9e4922dd7e97?source=collection_archive---------4-----------------------#2020-08-04">https://towardsdatascience.com/machine-learning-for-building-recommender-system-in-python-9e4922dd7e97?source=collection_archive---------4-----------------------#2020-08-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c8be" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">利用 Python 中基于模型的协同过滤构建推荐系统</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bfcfc3b18c951283f8864687b3b2bed5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S6limxUVQ50yIHZpaNXUeQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片</p></figure><p id="d7a3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae lu" href="https://en.wikipedia.org/wiki/Recommender_system" rel="noopener ugc nofollow" target="_blank">推荐系统</a>广泛应用于产品推荐，如音乐、电影、书籍、新闻、研究文章、餐厅等的推荐。[1][5][9][10].</p><p id="8f9d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">构建推荐系统有两种流行的方法:</p><ul class=""><li id="b7f7" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated"><a class="ae lu" href="https://en.wikipedia.org/wiki/Collaborative_filtering" rel="noopener ugc nofollow" target="_blank">协同过滤</a>【3】【4】【5】【10】</li><li id="fa1f" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><a class="ae lu" href="https://developers.google.com/machine-learning/recommendation/content-based/basics" rel="noopener ugc nofollow" target="_blank">基于内容的过滤</a>【6】【9】</li></ul><p id="682c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">协作过滤方法[5][10]通过从许多其他用户(协作)收集偏好信息来预测(过滤)用户对产品的兴趣。协同过滤方法背后的假设是，如果一个人 P1 和另一个人 P2 在一个问题上有相同的观点，P1 比随机选择的人更有可能在不同的问题上分享 P2 的观点[5]。</p><p id="c2df" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">基于内容的过滤方法[6][9]利用产品特征/属性，根据其他用户以前的行为或明确的反馈(如对产品的评级)，推荐与用户喜欢的产品相似的其他产品。</p><p id="66f1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">推荐系统可以使用这两种方法中的一种或两种。</p><p id="783e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我使用 Kaggle 网飞奖数据[2]来演示如何使用基于模型的协同过滤方法在 Python 中构建一个推荐系统。</p><p id="7af1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">文章的其余部分安排如下:</p><ul class=""><li id="645c" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">协同过滤概述</li><li id="7fc7" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">用 Python 构建推荐系统</li><li id="94d8" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">摘要</li></ul><h1 id="2434" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">1.协同过滤概述</h1><p id="5bd1" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">正如[5]中所描述的，协同过滤背后的主要思想是一个人经常从另一个有相似兴趣的人那里得到最好的推荐。协同过滤使用各种技术来匹配具有相似兴趣的人，并基于共同兴趣进行推荐。</p><p id="b598" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">协同过滤系统的高级工作流程可以描述如下:</p><ul class=""><li id="5571" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">用户对项目(例如，电影、书籍)进行评级以表达他或她对项目的偏好</li><li id="10bc" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">系统将评级视为用户对项目兴趣的近似表示</li><li id="b91c" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">系统将该用户的评分与其他用户的评分进行匹配，并找到评分最相似的人</li><li id="629d" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">系统推荐相似用户已经评级很高但是还没有被该用户评级的项目</li></ul><p id="f72b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">典型地，协同过滤系统分两步向给定用户推荐产品[5]:</p><ul class=""><li id="538c" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">步骤 1:寻找与给定用户具有相同评级模式的人</li><li id="f1db" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">步骤 2:使用在步骤 1 中找到的人的评分来计算给定用户对产品的评分预测</li></ul><p id="3dd5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这被称为基于用户的协同过滤。该方法的一个具体实现是基于用户的<a class="ae lu" href="https://en.wikipedia.org/wiki/K-nearest_neighbors_algorithm" rel="noopener ugc nofollow" target="_blank">最近邻算法</a>。</p><p id="250d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">作为替代，基于项目的协作过滤(例如，对 x 感兴趣的用户也对 y 感兴趣)以项目为中心的方式工作:</p><ul class=""><li id="62c1" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">步骤 1:建立项目对之间评级关系的项目-项目矩阵</li><li id="378f" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">步骤 2:通过检查矩阵和匹配用户的评级数据来预测当前用户对产品的评级</li></ul><p id="765e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有两种类型的协同过滤系统:</p><ul class=""><li id="0312" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">基于模型的</li><li id="a986" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">基于记忆的</li></ul><p id="dac7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在基于模型的系统中，我们使用不同的<a class="ae lu" href="https://en.wikipedia.org/wiki/Machine_learning" rel="noopener ugc nofollow" target="_blank">机器学习</a>算法来开发模型，以预测用户对未评级项目的评级【5】。基于模型的协同过滤算法有很多，如<a class="ae lu" href="https://en.wikipedia.org/wiki/Matrix_factorization_(recommender_systems)#:~:text=Matrix%20factorization%20is%20a%20class,two%20lower%20dimensionality%20rectangular%20matrices." rel="noopener ugc nofollow" target="_blank">矩阵分解</a>算法(如<a class="ae lu" href="https://en.wikipedia.org/wiki/Singular_value_decomposition" rel="noopener ugc nofollow" target="_blank">奇异值分解</a> (SVD)、交替最小二乘(ALS)算法【8】)、<a class="ae lu" href="https://en.wikipedia.org/wiki/Bayesian_networks" rel="noopener ugc nofollow" target="_blank">贝叶斯网络</a>、<a class="ae lu" href="https://en.wikipedia.org/wiki/Cluster_Analysis" rel="noopener ugc nofollow" target="_blank">聚类模型</a>等。<a class="ae lu" href="https://en.wikipedia.org/wiki/Collaborative_filtering#cite_note-Suetal2009-5" rel="noopener ugc nofollow" target="_blank">【5】</a>。</p><p id="8c2e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">基于记忆的系统使用用户的评级数据来计算用户或项目之间的相似性。这类系统的典型例子是基于邻域的方法和基于项目/基于用户的 top-N 推荐[5]。</p><p id="8935" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本文描述了如何使用 SVD 模型构建基于模型的协同过滤系统。</p><h1 id="e48f" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">2.用 Python 构建推荐系统</h1><p id="b3b3" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">本节描述如何用 Python 构建推荐系统。</p><h2 id="d5c6" class="ng mk it bd ml nh ni dn mp nj nk dp mt lh nl nm mv ll nn no mx lp np nq mz nr bi translated">2.1 安装库</h2><p id="f16c" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">有多个 Python 库可用于构建推荐系统(例如，Python scikit<a class="ae lu" href="http://surpriselib.com/" rel="noopener ugc nofollow" target="_blank">Surprise</a>【7】，<a class="ae lu" href="https://spark.apache.org/docs/latest/mllib-collaborative-filtering.html#:~:text=Tutorial-,Collaborative%20filtering,commonly%20used%20for%20recommender%20systems.&amp;text=mllib%20currently%20supports%20model%2Dbased,spark." rel="noopener ugc nofollow" target="_blank"> Spark 基于 RDD 的协同过滤 API</a>【8】)。我在本文中使用 Python scikit Surprise 库进行演示。</p><p id="4872" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">惊喜库可以按如下方式安装:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="b189" class="ng mk it nt b gy nx ny l nz oa">pip install scikit-surprise</span></pre><h2 id="51fa" class="ng mk it bd ml nh ni dn mp nj nk dp mt lh nl nm mv ll nn no mx lp np nq mz nr bi translated">2.2 加载数据</h2><p id="5b88" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">如前所述，我在本文中使用了 Kaggle 网飞奖数据[2]。有多个数据文件用于不同的目的。本文中使用了以下数据文件:</p><p id="6087" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">训练数据:</strong></p><ul class=""><li id="4211" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">组合 _ 数据 _1.txt</li><li id="e92a" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">组合 _ 数据 _2.txt</li><li id="aa08" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">组合 _ 数据 _3.txt</li><li id="19fb" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">组合 _ 数据 _4.txt</li></ul><p id="63f6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">电影片头数据文件:</strong></p><ul class=""><li id="363b" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">电影 _ 标题. csv</li></ul><p id="27d4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">训练数据集太大，无法在笔记本电脑上处理。因此，出于演示目的，我只从每个训练数据文件中加载前 100，000 条记录。</p><p id="6f91" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦将训练数据文件下载到本地机器上，来自每个训练数据文件的前 100，000 条记录可以作为熊猫数据帧加载到内存中，如下所示:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="bf5a" class="ng mk it nt b gy nx ny l nz oa">def readFile(file_path, rows=100000):<br/>    data_dict = {'Cust_Id' : [], 'Movie_Id' : [], 'Rating' : [], 'Date' : []}<br/>    f = open(file_path, "r")<br/>    count = 0<br/>    for line in f:<br/>        count += 1<br/>        if count &gt; rows:<br/>            break<br/>            <br/>        if ':' in line:<br/>            movidId = line[:-2] # remove the last character ':'<br/>            movieId = int(movidId)<br/>        else:<br/>            customerID, rating, date = line.split(',')<br/>            data_dict['Cust_Id'].append(customerID)<br/>            data_dict['Movie_Id'].append(movieId)<br/>            data_dict['Rating'].append(rating)<br/>            data_dict['Date'].append(date.rstrip("\n"))<br/>    f.close()<br/>            <br/>    return pd.DataFrame(data_dict)</span><span id="dd0a" class="ng mk it nt b gy ob ny l nz oa">df1 = readFile('./data/netflix/combined_data_1.txt', rows=100000)<br/>df2 = readFile('./data/netflix/combined_data_2.txt', rows=100000)<br/>df3 = readFile('./data/netflix/combined_data_3.txt', rows=100000)<br/>df4 = readFile('./data/netflix/combined_data_4.txt', rows=100000)</span><span id="73fa" class="ng mk it nt b gy ob ny l nz oa">df1['Rating'] = df1['Rating'].astype(float)<br/>df2['Rating'] = df2['Rating'].astype(float)<br/>df3['Rating'] = df3['Rating'].astype(float)<br/>df4['Rating'] = df4['Rating'].astype(float)</span></pre><p id="8542" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">训练数据的不同部分的不同数据帧被组合成如下一个:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="c335" class="ng mk it nt b gy nx ny l nz oa">df = df1.copy()<br/>df = df.append(df2)<br/>df = df.append(df3)<br/>df = df.append(df4)</span><span id="68f8" class="ng mk it nt b gy ob ny l nz oa">df.index = np.arange(0,len(df))<br/>df.head(10)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/98a405bbc26a75f2c5c4a98b4335f8ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*z1w6upJwyqawn1LbF5DEsQ.png"/></div></figure><p id="a357" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">电影标题文件可以作为熊猫数据帧载入存储器:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="45cc" class="ng mk it nt b gy nx ny l nz oa">df_title = pd.read_csv('./data/netflix/movie_titles.csv', encoding = "ISO-8859-1", header = None, names = ['Movie_Id', 'Year', 'Name'])<br/>df_title.head(10)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/d12856d5d56bc2536302a64cc44fae7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*rnFiAIsUXuY_MV6n0ked0w.png"/></div></figure><h2 id="9765" class="ng mk it bd ml nh ni dn mp nj nk dp mt lh nl nm mv ll nn no mx lp np nq mz nr bi translated">2.3 培训和评估模式</h2><p id="3ec9" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated"><em class="oe"> Surprise </em>中的<em class="oe">数据集</em>模块提供了从文件、Pandas 数据帧或内置数据集(如 ml-100k(movie lens 100k)【4】加载数据的不同方法:</p><ul class=""><li id="8868" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">Dataset.load_builtin()</li><li id="2061" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">Dataset.load_from_file()</li><li id="a150" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">Dataset.load_from_df()</li></ul><p id="c245" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我使用<em class="oe"> load_from_df </em>()方法从 Pandas DataFrame 加载数据。</p><p id="eb80" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="oe"> Surprise </em>中的<em class="oe"> Reader </em>类用于解析包含用户、项目和用户对项目的评分的文件。默认的格式是每个评分按空格分隔的顺序存储在单独的行中:<em class="oe">用户</em> <em class="oe">项目</em> <em class="oe">评分</em></p><p id="25a8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该顺序和分隔符可使用以下参数进行配置:</p><ul class=""><li id="04a8" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated"><strong class="la iu"> line_format </strong>是一个类似于“<em class="oe">item</em>T28】userT30】rating 的字符串，表示数据的顺序，字段名之间用空格隔开</li><li id="b0ce" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><strong class="la iu"> sep </strong>用于指定字段之间的分隔符，如空格、'、'等。</li><li id="4d99" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><strong class="la iu"> rating_scale </strong>是指定评级尺度。默认值为(1，5)</li><li id="84c7" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><strong class="la iu"> skip_lines </strong>表示文件开头要跳过的行数，默认为 0</li></ul><p id="5cfd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我在本文中使用默认设置。<em class="oe">项</em>、<em class="oe">用户</em>、<em class="oe">评分</em>分别对应数据帧的<em class="oe">客户标识</em>、<em class="oe">电影标识</em>和<em class="oe">评分</em>栏。</p><p id="568f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">惊喜库[7]包含用于构建推荐系统的多种模型/算法的实现，例如奇异值分解、概率矩阵分解(PMF)、非负矩阵分解(NMF)等。本文使用了 SVD 模型。</p><p id="efbe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面的代码从 Pandas DataFrame 加载数据并创建一个 SVD 模型实例:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="b0c1" class="ng mk it nt b gy nx ny l nz oa">from surprise import Reader, Dataset, SVD<br/>from surprise.model_selection.validation import cross_validate</span><span id="a50d" class="ng mk it nt b gy ob ny l nz oa">reader = Reader()</span><span id="e8f7" class="ng mk it nt b gy ob ny l nz oa">data = Dataset.load_from_df(df[['Cust_Id', 'Movie_Id', 'Rating']], reader)</span><span id="d005" class="ng mk it nt b gy ob ny l nz oa">svd = SVD()</span></pre><p id="7422" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦用于产品推荐的数据和模型准备就绪，就可以使用交叉验证来评估模型，如下所示:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="a69e" class="ng mk it nt b gy nx ny l nz oa"># Run 5-fold cross-validation and print results<br/>cross_validate(svd, data, measures=['RMSE', 'MAE'], cv=5, verbose=True)</span></pre><p id="5b5d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是 SVD 模型的交叉验证结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/e8d584e5b51c08ef6ff83f7af7b2800b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*urLw-GaitHMfH2ZwNceNzw.png"/></div></div></figure><p id="272f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦模型评估达到我们的满意程度，我们就可以使用整个训练数据集来重新训练模型:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="d5f3" class="ng mk it nt b gy nx ny l nz oa">trainset = data.build_full_trainset()<br/>svd.fit(trainset)</span></pre><h2 id="3555" class="ng mk it bd ml nh ni dn mp nj nk dp mt lh nl nm mv ll nn no mx lp np nq mz nr bi translated">2.4 推荐产品</h2><p id="47b0" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">在推荐模型被适当地训练之后，它可以被用于预测。</p><p id="8620" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，给定用户(例如，客户 Id 785314)，我们可以使用经训练的模型来预测用户对不同产品(即，电影名称)给出的评级:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="3a2a" class="ng mk it nt b gy nx ny l nz oa">titles = df_title.copy()</span><span id="a0b0" class="ng mk it nt b gy ob ny l nz oa">titles['Estimate_Score'] = titles['Movie_Id'].apply(lambda x: svd.predict(785314, x).est)</span></pre><p id="4664" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了向给定用户推荐产品(即电影)，我们可以按照预测评级的降序对电影列表进行排序，并将前<em class="oe"> N </em>部电影作为推荐:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="67dd" class="ng mk it nt b gy nx ny l nz oa">titles = titles.sort_values(by=['Estimate_Score'], ascending=False)<br/>titles.head(10)</span></pre><p id="26ac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是向客户 Id 为 785314 的用户推荐的前 10 部电影:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/e0bc27d71912df4b7eae2758484e77e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wy9FJKQ-7_oautmtn0MB5w.png"/></div></div></figure><h1 id="abb7" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">3.摘要</h1><p id="6e8e" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">在本文中，我使用 scikit 惊喜库[7]和 Kaggle 网飞奖数据[2]来演示如何使用基于模型的协同过滤方法在 Python 中构建推荐系统。</p><p id="3723" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如本文开头所述，数据集太大，无法在笔记本电脑或任何典型的个人电脑上处理。因此，出于演示目的，我只从每个训练数据集文件中加载了前 100，000 条记录。</p><p id="60fa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在真实应用的设置中，我会推荐用 Surprise 搭配<a class="ae lu" href="https://github.com/databricks/koalas" rel="noopener ugc nofollow" target="_blank">考拉</a>或者用 Spark MLLib 中的 ALS 算法实现协同过滤系统，在 Spark cluster 上运行[8]。</p><p id="11dd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Github [11]中提供了 Jupyter 笔记本以及本文中使用的所有源代码。</p><h1 id="5102" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">参考</h1><ol class=""><li id="a7d1" class="lv lw it la b lb nb le nc lh oh ll oi lp oj lt ok mb mc md bi translated">DLao，<a class="ae lu" href="https://www.kaggle.com/laowingkin/netflix-movie-recommendation" rel="noopener ugc nofollow" target="_blank">网飞——电影推荐</a></li><li id="47cb" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ok mb mc md bi translated"><a class="ae lu" href="https://www.kaggle.com/netflix-inc/netflix-prize-data?select=qualifying.txt" rel="noopener ugc nofollow" target="_blank"> Netflix 获奖数据，来自网飞竞赛的数据集，用于改进他们的推荐算法</a></li><li id="00d2" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ok mb mc md bi translated"><a class="ae lu" href="https://en.wikipedia.org/wiki/Recommender_system" rel="noopener ugc nofollow" target="_blank">推荐系统</a></li><li id="2913" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ok mb mc md bi translated">A.Ajitsaria，<a class="ae lu" href="https://realpython.com/build-recommendation-engine-collaborative-filtering/" rel="noopener ugc nofollow" target="_blank">用协同过滤建立推荐引擎</a></li><li id="068f" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ok mb mc md bi translated"><a class="ae lu" href="https://en.wikipedia.org/wiki/Collaborative_filtering" rel="noopener ugc nofollow" target="_blank">协同过滤</a></li><li id="e25f" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ok mb mc md bi translated"><a class="ae lu" href="https://developers.google.com/machine-learning/recommendation/content-based/basics" rel="noopener ugc nofollow" target="_blank">基于内容的过滤</a></li><li id="8884" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ok mb mc md bi translated"><a class="ae lu" href="http://surpriselib.com/" rel="noopener ugc nofollow" target="_blank">惊喜</a></li><li id="48e6" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ok mb mc md bi translated">南 Ryza，U. Laserson 等。艾尔。，Spark 高级分析，奥赖利，2015 年 4 月</li><li id="53eb" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ok mb mc md bi translated">N.S. Chauhan，<a class="ae lu" href="https://medium.com/analytics-vidhya/how-to-build-a-restaurant-recommendation-engine-part-1-21aadb5dac6e" rel="noopener">如何构建餐厅推荐引擎</a>(第一部分)</li><li id="c768" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ok mb mc md bi translated">N.S. Chauhan，<a class="ae lu" href="https://medium.com/analytics-vidhya/how-to-build-a-restaurant-recommendation-engine-part-2-71e2d0721084" rel="noopener">如何构建餐厅推荐引擎</a>(第二部分)</li><li id="b6f9" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ok mb mc md bi translated">Y.<a class="ae lu" href="https://github.com/yzzhang/machine-learning/tree/master/recommender" rel="noopener ugc nofollow" target="_blank"> Github </a>中的张、Jupyter 笔记本</li></ol></div></div>    
</body>
</html>