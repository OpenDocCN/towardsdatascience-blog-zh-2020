<html>
<head>
<title>Pythonic MetaProgramming With MetaClasses</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有元类的 Pythonic 元编程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/pythonic-metaprogramming-with-metaclasses-19b0df1e1760?source=collection_archive---------45-----------------------#2020-04-27">https://towardsdatascience.com/pythonic-metaprogramming-with-metaclasses-19b0df1e1760?source=collection_archive---------45-----------------------#2020-04-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3235" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你的装饰和元类生存指南。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/d278bcf50977b39cd4602854c4e6f5b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*uXzmBEhPFd0kc7jM7KCPeQ.png"/></div></figure><h1 id="a75c" class="kq kr it bd ks kt ku kv kw kx ky kz la jz lb ka lc kc ld kd le kf lf kg lg lh bi translated">介绍</h1><p id="35aa" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">元编程是操作代码的代码构造，可以在语法上产生一些非常有趣和富有表现力的结果。元编程并不是一个通常与 Python 联系在一起的概念，但事实是 Python 和 meta 实际上以许多很酷且独特的方式结合在一起。如果你曾经在 Python 中使用过元类或装饰器，那么你实际上是在用 Python 进行元编程。</p><p id="bb48" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">像大多数高级编程语言一样，在 Python 中，每个单独的变量或对象都有一个类型。类型很重要，因为它们决定了每个变量的数据在内存中的存储方式。Python 中的每种类型都由一个类定义，我们可以通过使用标准库中的 type()函数来说明这一点:</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="0fef" class="mo kr it mk b gy mp mq l mr ms">string = "example"<br/>print(type(string))</span><span id="c63f" class="mo kr it mk b gy mt mq l mr ms">&lt;class 'str'&gt;</span></pre><p id="0e38" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">string 类型的类是“str”类，它包含 split()之类的方法，这些方法通常用于解析字符。对于任何 Python 程序员来说，这可能都不是一个新概念，但是我们可以更进一步，使用元类来操纵类，而不需要编写它们。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="d71d" class="kq kr it bd ks kt nb kv kw kx nc kz la jz nd ka lc kc ne kd le kf nf kg lg lh bi translated">基本用法</h1><p id="642a" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">与 C、Java 甚至 C++中 int、char 和 float 是主要的数据类型不同，在 Python 中，它们是类中的一个对象。这对 Python 有利也有弊，因为对象是通常不可通用读取的数据类型。这意味着数据经常会卡在 Python 中，但也意味着 Python 中使用的数据是一个类的实例，也就是一个元类的实例。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi ng"><img src="../Images/535844ec0cdf30666eb036180482ff19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2Sq_Rz3bzQ8WI_5IRDSTog.jpeg"/></div></div></figure><p id="ac8a" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">我们首先需要的是一名室内装潢师。Python 中装饰者的工作是创建一个设计模式，允许我们在不修改类的情况下向类中添加新功能。使用 decorators 将使我们的类保持静态变得非常容易，同时还可以根据需要添加额外的特性。我喜欢让我的类装饰者继承函数装饰者，因为它在我们的代码之间创建了一个更大的边界，这是我们试图避免变异的。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="be99" class="mo kr it mk b gy mp mq l mr ms">from functools import wraps</span><span id="f883" class="mo kr it mk b gy mt mq l mr ms">def debug(func): <br/> '''decorator; debugs function when passed.'''<br/> <br/> <a class="ae nl" href="http://twitter.com/wraps" rel="noopener ugc nofollow" target="_blank">@wraps</a>(func) <br/> def wrapper(*args, **kwargs): <br/>  print("Full name of this method:", func.__qualname__) <br/>  return func(*args, **kwargs) <br/> return wrapper</span></pre><p id="4309" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">现在我们可以添加实际的类装饰器了:</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="2ef5" class="mo kr it mk b gy mp mq l mr ms">def debugmethods(cls): <br/> '''class decorator to use debug method'''<br/> <br/> for key, val in vars(cls).items(): <br/>  if callable(val): <br/>   setattr(cls, key, debug(val)) <br/> return cls</span></pre><p id="cfb7" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">因此，我们的元类:</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="ff84" class="mo kr it mk b gy mp mq l mr ms">class debugMeta(type): <br/> '''meta class which feed created class object <br/> to debugmethod to get debug functionality <br/> enabled objects'''<br/> <br/> def __new__(cls, clsname, bases, clsdict): <br/>  obj = super().__new__(cls, clsname, bases, clsdict) <br/>  obj = debugmethods(obj) <br/>  return obj </span></pre><p id="3de8" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">现在，我们可以通过使用参数(metaclass=)创建一个新类来继承这个新类的数据。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="859a" class="mo kr it mk b gy mp mq l mr ms"># now all the subclass of this <br/># will have debugging applied <br/>class Base(metaclass=debugMeta):pass</span></pre><p id="80a9" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">现在我们可以使用面向对象的继承将元类的属性继承到我们的新类中。每次修改“debugMeta”时，依赖于它的所有子元素都将继承这些更改。这产生了一些有趣的语法，我们可以在不需要修改它的情况下，自动向我们的类添加功能。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="bb87" class="mo kr it mk b gy mp mq l mr ms"># inheriting Base <br/>class Calc(Base): <br/> def add(self, x, y): <br/>  return x+y</span></pre><p id="35ff" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">现在使用计算器:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/ca95d25ce5cf3d6c24ccbbe24b1b8203.png" data-original-src="https://miro.medium.com/v2/resize:fit:628/format:webp/1*EIyiVXxUpYsn-vnrnGpzxg.png"/></div></figure><p id="20f8" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">我们的 calculator 类实际上使用了我们用元类设置的调试行为，但是注意数据不是我们对象的子对象:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nn"><img src="../Images/1281f59a078e6ba736e6304f8da74c0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XEAFMyQLUh8qEmSFz2Jicg.png"/></div></div></figure></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="7d39" class="kq kr it bd ks kt nb kv kw kx nc kz la jz nd ka lc kc ne kd le kf nf kg lg lh bi translated">结论</h1><p id="4b07" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">虽然 Python 通常不会与元编程的概念联系在一起，但它不仅能够通过其独特的装饰器完美地实现这一概念，而且还在很多方面使用它。我认为 Python 相对于元编程为标准的许多其他语言的最大优势是 Python 的继承性。对于我上面所做的，如果没有继承，这一切都是不可能的，而且在我看来 Python 继承得非常好。由于我们经常将元编程与 Lisp 或 Scheme 之类的语言联系在一起，所以看到元编程以完全不同的方式完成是非常有趣的——而且是以完全不同的语言和完全不同的范式以非常酷的方式完成。最重要的是，decorators 肯定是一个很酷的概念，我真的希望更多的语言会采用它，因为它使元编程的过程变得非常简单和直接。</p><p id="fef6" class="pw-post-body-paragraph li lj it lk b ll me ju ln lo mf jx lq lr mg lt lu lv mh lx ly lz mi mb mc md im bi translated">当将 Python 与其他语言进行比较时，尤其是与我用于元编程的函数式语言进行比较时，情况更是如此。经常折腾宏和表达式可能是强大的，但同时它可能令人难以置信地混乱，我认为 Python 在面对那个确切的问题时很好地利用了它的语法。</p></div></div>    
</body>
</html>