<html>
<head>
<title>What’s Tidy Data?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是整齐的数据？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/whats-tidy-data-how-to-organize-messy-datasets-in-python-with-melt-and-pivotable-functions-5d52daa996c9?source=collection_archive---------8-----------------------#2020-01-15">https://towardsdatascience.com/whats-tidy-data-how-to-organize-messy-datasets-in-python-with-melt-and-pivotable-functions-5d52daa996c9?source=collection_archive---------8-----------------------#2020-01-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a72a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何用Melt和pivot函数在Python中组织杂乱的数据集</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d3e0092bd61996eb30bd954d35ceb74c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7jjzhy4KknPz9hJVnC_w7w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">资料来源:R for Data Science(Hadley Wickham &amp; Garrett grole mund)</p></figure><p id="4d1e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">数据科学家花费大约80%的时间清理和组织数据。整齐的数据是一种组织数据集以促进分析的方式。</p><p id="c4e3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">2014年，Hadley Wickham发表了一篇名为Tidy Data 的精彩论文<a class="ae lu" href="https://vita.had.co.nz/papers/tidy-data.pdf" rel="noopener ugc nofollow" target="_blank">，描述了用r整理数据集的过程，我这篇文章的目标是总结这些步骤并展示Python中的代码。</a></p><p id="3073" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在<strong class="la iu">整理数据</strong>:</p><ol class=""><li id="7bc2" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">每个变量都必须有自己的列。</li><li id="858b" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">每个观察必须有自己的行。</li><li id="d2c8" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">每种类型的观测单位形成一张表。</li></ol><p id="9468" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">杂乱数据是数据的任何其他排列。</p><h1 id="4831" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">杂乱的数据</h1><p id="0af3" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">我们将在这里探讨5个杂乱数据的例子:</p><ul class=""><li id="bc9f" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ng mb mc md bi translated">列标题是值，不是变量名。</li><li id="361b" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ng mb mc md bi translated">多个变量存储在一列中。</li><li id="93d5" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ng mb mc md bi translated">变量存储在行和列中。</li><li id="a06f" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ng mb mc md bi translated">多种类型的观测单位存储在同一个表中。</li><li id="995e" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ng mb mc md bi translated">一个观察单位存储在多个表中。</li></ul><p id="fd45" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当然，还有更多类型的脏乱没有在上面显示出来，但它们可以用类似的方式来整理。</p><h2 id="3933" class="nh mk it bd ml ni nj dn mp nk nl dp mt lh nm nn mv ll no np mx lp nq nr mz ns bi translated">列标题是值，不是变量名。</h2><p id="5c38" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">对于这个例子，我们将使用数据集“relinc.csv ”,它探索了收入和宗教之间的关系。注意，尽管很乱，这种安排在某些情况下还是有用的，所以我们将学习如何整理和不整理它。</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="bab0" class="nh mk it nu b gy ny nz l oa ob">import pandas as pd</span><span id="9d4d" class="nh mk it nu b gy oc nz l oa ob">df_relinc=pd.read_csv("relinc.csv")<br/>df_relinc.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/ebecec3392c66c3417d1831d163a9c90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EEOa37nAPNW9sQFP0MUlWw.png"/></div></div></figure><p id="1897" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个数据集中有三个变量:宗教、收入和频率。列标题是值，而不是变量名，所以我们需要将列(income)中的变量转换为行。我们将使用熊猫的功能<strong class="la iu">融化。</strong></p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="dcf3" class="nh mk it nu b gy ny nz l oa ob"># Applying melt (to a long format)</span><span id="8837" class="nh mk it nu b gy oc nz l oa ob">df_relinc=df_relinc.melt(id_vars=["religion"],var_name=["income"],value_name="frequency")</span><span id="42df" class="nh mk it nu b gy oc nz l oa ob">df_relinc.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/38675f9c27ef34ea439472b5c153b3d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lK-ZSuZ0t4fGV6VHsr9Fpw.png"/></div></div></figure><p id="2d63" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面的输出是我们数据集的整洁版本。</p><p id="2c9c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了将数据集返回到宽格式，我们将使用Panda的函数<strong class="la iu"> pivot_table </strong>。</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="b7f0" class="nh mk it nu b gy ny nz l oa ob"># Applying pivot_table (to a wide format)</span><span id="d96c" class="nh mk it nu b gy oc nz l oa ob">df_relinc=(df_relinc.pivot_table(index = "religion", columns = "income", values = "frequency")<br/>   .reset_index() <br/>   .rename_axis(None, axis = 1))</span><span id="caf8" class="nh mk it nu b gy oc nz l oa ob">df_relinc.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/76b57f69c92e08335bdc743e3d2d6e4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K_YiJqZfUUQO4vT0TwMd8g.png"/></div></div></figure><h2 id="319e" class="nh mk it bd ml ni nj dn mp nk nl dp mt lh nm nn mv ll no np mx lp nq nr mz ns bi translated">多个变量存储在一列中。</h2><p id="2b3f" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">现在我们将研究来自世界卫生组织的结核病数据集。这些记录显示了按国家、年份和人口统计组分列的肺结核病例数。</p><p id="db39" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">人口统计组按性别(男，女)和年龄(0-14岁，15-24岁，25-34岁，35-44岁，45-54岁，55-64岁，65岁以上，未知)细分。</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="e306" class="nh mk it nu b gy ny nz l oa ob">df_tb=pd.read_csv('tb.csv')<br/>df_tb.columns</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/ec6fc4652fb0bd127ed7555a2a58fdf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Px5g3Mg_dby-aRnYAxbV8Q.png"/></div></div></figure><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="2d51" class="nh mk it nu b gy ny nz l oa ob">df_tb.tail()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/ce5613083b3a772c272a4b56b1f3c679.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9P45U4mC3EERt374AVjhCQ.png"/></div></div></figure><p id="9ced" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些列包含性别和年龄值。请注意0和缺失值(NaN)的混合。这是由于数据收集过程造成的，这种区别对于该数据集非常重要。</p><p id="2777" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，我们将收集非变量列，将年龄范围和性别移到一列中。为此，我们将使用<strong class="la iu">熔体。</strong></p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="9c50" class="nh mk it nu b gy ny nz l oa ob"># Applying melt (to a long format)</span><span id="8884" class="nh mk it nu b gy oc nz l oa ob">df_tb=df_tb.melt(id_vars=["iso2","year"],var_name=["demographic"],value_name="cases")</span><span id="ba89" class="nh mk it nu b gy oc nz l oa ob">df_tb.sample(5)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/08f9199388aadb40cece56c0252774eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g2Nuhppw7zKlJXJPSEx9fw.png"/></div></div></figure><p id="1d7f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们需要拆分人口统计列，得到两列变量性别和年龄。</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="d8b2" class="nh mk it nu b gy ny nz l oa ob"># Creating new columns for sex and age</span><span id="88c5" class="nh mk it nu b gy oc nz l oa ob">df_tb=(df_tb.assign(</span><span id="c850" class="nh mk it nu b gy oc nz l oa ob">sex = lambda x: x.demographic.str[0].astype(str),<br/>age = lambda x: x.demographic.str[1:].astype(str))<br/>      .drop("demographic",axis=1))</span><span id="4366" class="nh mk it nu b gy oc nz l oa ob">df_tb.sample(5)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/8fd7788d5d341162e74592e5f4b4c518.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5kmayl7gerJCiZYjbJ8Cgw.png"/></div></div></figure><p id="fd0e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，每个观察都有自己的行，每个变量都有自己的列。我们刚刚整理了我们的数据集！在继续之前，让我们清理数据。</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="b132" class="nh mk it nu b gy ny nz l oa ob"># Styling the dataset</span><span id="3289" class="nh mk it nu b gy oc nz l oa ob">df_tb.update(pd.DataFrame({"age":[age[:2]+'-'+age[2:] if len(age) == 4 else (age) for age in df_tb["age"]]}))</span><span id="4334" class="nh mk it nu b gy oc nz l oa ob">df_tb=(df_tb.replace(to_replace =["m","f","014","65","u"],value =["Male","Female","0-14","65+","unknown"])<br/>            .dropna())</span><span id="17b6" class="nh mk it nu b gy oc nz l oa ob">df_tb.sample(10)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/c5cc82132d1a9bb7325af73252ec6a75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1s_RfdsiIxmckGRAO5F89Q.png"/></div></div></figure><h2 id="f172" class="nh mk it bd ml ni nj dn mp nk nl dp mt lh nm nn mv ll no np mx lp nq nr mz ns bi translated">变量存储在行和列中。</h2><p id="0270" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">我们将使用来自全球历史气候学网络的数据，这些数据代表了墨西哥2010年五个月的每日气象站(MX17004)。</p><p id="54d3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它在单个列(id，year，month)中有变量，跨列(day，D1–d31)和跨行(tmin，tmax)(最低和最高温度)。少于31天的月份的最后一天有结构缺失值。为了更好的可视化，已经省略了列d9至d31。</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="981a" class="nh mk it nu b gy ny nz l oa ob">import datetime</span><span id="be7c" class="nh mk it nu b gy oc nz l oa ob">df_weather = pd.read_csv('weather-raw.csv')</span><span id="b2f6" class="nh mk it nu b gy oc nz l oa ob">df_weather.sample(5)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/15e3084d3e75f9272a8e346bc25673e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*og3a7tzqW78COCXf4lcMxA.png"/></div></div></figure><p id="0d0d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如上所示，数据集是杂乱的。变量存储在行(tmin，tmax)和列(days)中。让我们从d1、d2、d3…列开始。</p><p id="5601" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将应用<strong class="la iu"> melt </strong>为day变量的每个记录创建一行。</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="985c" class="nh mk it nu b gy ny nz l oa ob"># Applying melt (to a long format)</span><span id="bf34" class="nh mk it nu b gy oc nz l oa ob">df_weather=df_weather.melt(id_vars=["id","year","month","element"],var_name=["day"],value_name="temp")<br/>df_weather.update(pd.DataFrame({"day":[day[1:] for day in df_weather["day"]]}))</span><span id="da98" class="nh mk it nu b gy oc nz l oa ob">df_weather.sample(5)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/8cb2c8b3e6514e54d40b3c7deec6e766.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s0WHQ__JoyBAtLmBpMYi-A.png"/></div></div></figure><p id="118c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们将使用<strong class="la iu"> pivot_table </strong>函数为tmin和tmax创建新列，一旦它们是变量。</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="7c21" class="nh mk it nu b gy ny nz l oa ob"># applying pivot_table to create columns for tmin and tmax</span><span id="153b" class="nh mk it nu b gy oc nz l oa ob">df_weather=(df_weather.pivot_table(index = ["year","month","day","id"], columns = "element", values = "temp")<br/>       .reset_index().rename_axis(None, axis = 1))</span><span id="2fe1" class="nh mk it nu b gy oc nz l oa ob">df_weather</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/9201cc93a2572519fdeca0396b9493b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hsk6JP-uYb2ol7Ylr4iuhg.png"/></div></div></figure><p id="d61f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">数据集看起来更好，但我们仍然需要改进它。让我们为日期创建一个列并对其进行分组。</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="cc21" class="nh mk it nu b gy ny nz l oa ob"># Creating a date column</span><span id="dc59" class="nh mk it nu b gy oc nz l oa ob">df_weather=(df_weather.assign(date = lambda x: x.year.astype("str") +"/"+ x.month.astype("str").str.zfill(2) +"/"+ x.day.astype("str").str.zfill(2))<br/>            .drop(["year", "month","day"],axis=1))<br/>df_weather['date'] =  pd.to_datetime(df_weather['date'], format='%Y/%m/%d')</span><span id="02a7" class="nh mk it nu b gy oc nz l oa ob"># Grouping by date</span><span id="e3fb" class="nh mk it nu b gy oc nz l oa ob">df_weather=(df_weather.filter(["date", "tmax","tmin"]).groupby("date").aggregate("mean").reset_index())</span><span id="2239" class="nh mk it nu b gy oc nz l oa ob">df_weather</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/ec503349579b07fe0f7c563cf1290042.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vnX7rWTS5CAuseEQm30yew.png"/></div></div></figure><p id="d47e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们最终整理了我们的数据集。</p><h2 id="dd16" class="nh mk it bd ml ni nj dn mp nk nl dp mt lh nm nn mv ll no np mx lp nq nr mz ns bi translated">多种类型的观测单位存储在同一个表中。</h2><p id="335e" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">该数据集显示了2000年的Billboard热门歌曲。这个数据集记录了一首歌首次进入Billboard Top 100的日期。它包含艺术家、曲目、输入日期、峰值日期、流派、时间、排名和星期等变量。</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="e7fe" class="nh mk it nu b gy ny nz l oa ob">import pandas as pd<br/>import re<br/>import numpy as np<br/>import datetime</span><span id="e759" class="nh mk it nu b gy oc nz l oa ob">df_bill = pd.read_csv('billboard.csv',header=0,encoding = 'unicode_escape')</span><span id="c057" class="nh mk it nu b gy oc nz l oa ob">df_bill.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/7181c61e065e9d92832a19389375137f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J2FVVptdEBcMWzDGkTLxww.png"/></div></div></figure><p id="58a0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">进入前100名后的每周排名记录在76列中，从第1周到第76周。如果一首歌进入前100名的时间少于76周，则剩余的列用NaN填充。</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="7caf" class="nh mk it nu b gy ny nz l oa ob">df_bill.columns</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/b9631671477c5e3300ded6bc6bb8d2fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qwTlwH-jiE17-eH6e2IrkQ.png"/></div></div></figure><p id="0757" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个数据集包含对两种类型的观察单位的观察:歌曲和它在每个星期的排名。因此，艺术家和时间会在每周的每首歌曲中重复出现。在将Billboard数据集一分为二之前，我们需要对其进行整理。让我们从收集所有的周专栏开始。</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="bd95" class="nh mk it nu b gy ny nz l oa ob"># Applying melt (to a long format)<br/>df_bill=(df_bill.melt(id_vars=["year","artist.inverted","track","genre","date.entered","date.peaked","time"],var_name=["week"],value_name="rank"))</span><span id="c682" class="nh mk it nu b gy oc nz l oa ob"># Week to number <br/>df_bill.update(pd.DataFrame({"week": np.ravel([list(map(int, re.findall(r'\d+', i))) for i in df_bill["week"]])}))</span><span id="42e4" class="nh mk it nu b gy oc nz l oa ob">df_bill.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/7b14ec8f6c0a444ac6cde8d279973802.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zCHcjCYwg7RqHKYMnO4fsA.png"/></div></div></figure><p id="041b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">更好看！现在我们有一个可变周的列。顺便说一下，我们可以使用输入的日期和星期中的信息来创建一个新列，它将成为日期列。</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="ebed" class="nh mk it nu b gy ny nz l oa ob"># creating a date column from date.entered and week</span><span id="7081" class="nh mk it nu b gy oc nz l oa ob">df_bill['date.entered'] =  pd.to_datetime(df_bill['date.entered'], format='%Y/%m/%d')</span><span id="bf81" class="nh mk it nu b gy oc nz l oa ob">df_bill=(df_bill.assign(date= [df_bill['date.entered'][i]+datetime.timedelta(weeks = df_bill["week"][i]-1) for i in range(len(df_bill["week"]))])<br/>         .drop(['date.entered','date.peaked','week'], axis=1)<br/>         .sort_values('artist.inverted', ascending=True)<br/>         .reset_index(drop=True))</span><span id="402f" class="nh mk it nu b gy oc nz l oa ob">df_bill.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/5ddea328b45ed8f0232c0002f83127bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pn29xYo7JvFssqP6IgDj7Q.png"/></div></div></figure><p id="28d6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们将从轨道创建一个id。每首歌曲必须有一个唯一的id号。为此，我们将使用熊猫的功能<strong class="la iu">因式分解。</strong></p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="9d68" class="nh mk it nu b gy ny nz l oa ob"># creating an id column from track</span><span id="f555" class="nh mk it nu b gy oc nz l oa ob">labels,unique=pd.factorize(list(df_bill["track"]))<br/>df_bill["id"]=labels+1<br/>df_bill.reset_index(drop=True)<br/>df_bill.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/611b6b00a324c2137c108584cfb0233e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B2e3f55MLvLn6luq0pwN7A.png"/></div></div></figure><p id="98e0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，我们将把数据集分成两个数据集:歌曲数据集和排名数据集。</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="cd7b" class="nh mk it nu b gy ny nz l oa ob"># creating a new dataframe for rank</span><span id="63dc" class="nh mk it nu b gy oc nz l oa ob">df_rank=df_bill.filter(["id", "date", "rank"]).dropna()<br/>df_rank=df_rank.sort_values(by=['id','date']).reset_index(drop=True)</span><span id="fe0f" class="nh mk it nu b gy oc nz l oa ob"># creating a new dataframe for song</span><span id="507c" class="nh mk it nu b gy oc nz l oa ob">df_song=df_bill.filter(["id", "artist.inverted", "track","time"])<br/>df_song=df_song.drop_duplicates('id').reset_index(drop=True)</span><span id="a844" class="nh mk it nu b gy oc nz l oa ob">df_rank.head(10)<br/>df_song.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/488729d18214900d017de1b7adee6603.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L_SMPrntfcxDGOLjc98JlA.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/18e551fc291006475819f1eb81641102.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TPtiuxEAGBKExgt3DQf0sA.png"/></div></div></figure><p id="bc8b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们刚刚解决了在同一个表中存储多种类型的观测单位的问题！</p><h2 id="fb11" class="nh mk it bd ml ni nj dn mp nk nl dp mt lh nm nn mv ll no np mx lp nq nr mz ns bi translated">一个观察单位存储在多个表中。</h2><p id="bf46" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">这个问题过去很容易解决。我们基本上需要读取这些表，添加一个记录原始文件名的新列，最后将所有表合并成一个表。</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="0f43" class="nh mk it nu b gy ny nz l oa ob">import pandas as pd</span><span id="1c2f" class="nh mk it nu b gy oc nz l oa ob">df_baby14 = pd.read_csv("2014-baby-names-illinois.csv")<br/>df_baby15 = pd.read_csv("2015-baby-names-illinois.csv")</span><span id="43b7" class="nh mk it nu b gy oc nz l oa ob">df_baby14.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/598a3c3c72461387cb4f3987264d2aed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zcNPh9b-DXqY1d6NX5yiFw.png"/></div></div></figure><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="4f36" class="nh mk it nu b gy ny nz l oa ob">df_baby15.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/204893e39b668fa2001873468076240d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FHbNj3hX3QDoHRa8JK9lOQ.png"/></div></div></figure><p id="2f23" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们根据文件名在每个数据集中创建一个列year。最后，我们将应用Panda的<strong class="la iu"> concat </strong>函数来连接数据帧。</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="256e" class="nh mk it nu b gy ny nz l oa ob"># Creating a column for the year<br/>df_baby14["year"]="2014"<br/>df_baby15["year"]="2015"</span><span id="4ad1" class="nh mk it nu b gy oc nz l oa ob"># Concatenating the datasets<br/>df_baby = pd.concat([df_baby14, df_baby15]).sort_values(by=['rank'])</span><span id="3934" class="nh mk it nu b gy oc nz l oa ob">(df_baby.set_index('rank', inplace=True))</span><span id="3d19" class="nh mk it nu b gy oc nz l oa ob">df_baby.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/0aac0cde7ba976c2f5d727f9200ad6dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ch5PiLbRHim-RDaqF8vQRw.png"/></div></div></figure><h1 id="d195" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">最终意见</h1><p id="890f" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">本文的目标是解释整洁数据的概念，包括五种最常见的杂乱数据，以及如何用Python组织和清理这些数据集。</p><p id="8ccc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你发现任何错误，请不要犹豫与我联系！我最近开始在数据科学世界里冲浪，尽管我很喜欢，但我是个傻瓜。</p><p id="f6e2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我的代码和数据集可以在Github上找到:<a class="ae lu" href="https://github.com/rodrigomf5/Tidydata" rel="noopener ugc nofollow" target="_blank">https://github.com/rodrigomf5/Tidydata</a>。另外，这里是Hadley Github，它提供了更多关于Tidy Data的信息:【https://github.com/hadley<a class="ae lu" href="https://github.com/hadley" rel="noopener ugc nofollow" target="_blank"/></p></div></div>    
</body>
</html>