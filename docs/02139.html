<html>
<head>
<title>Serverless: A Painless AWS Boilerplate</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无服务器:无痛的 AWS 样板文件</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/serverless-a-painless-aws-boilerplate-e5ec3b4fb609?source=collection_archive---------16-----------------------#2020-02-29">https://towardsdatascience.com/serverless-a-painless-aws-boilerplate-e5ec3b4fb609?source=collection_archive---------16-----------------------#2020-02-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2bdf" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">为 AWS lambda 部署提供支持离线测试的样板文件</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1aa74ae68b4ac0f81c3d9196366fd634.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CDmSsi6sat9Dx5UkZyUQ8A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://aws.amazon.com/lambda/" rel="noopener ugc nofollow" target="_blank"> AWS Lambda </a></p></figure><p id="57e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">无服务器开发由于易于部署而受到关注。此外，鉴于 AWS lambda 能够将其他服务与 AWS SDK 集成，它已经成为一种流行的选择。然而，如果你不具备可伸缩性，当你扩展你的 API 时，从小处着手可能会给你留下巨大的重构空间。因此，在这里，我将总结我在一家初创公司的经验，并分享一个很好的样板文件，通过以一个简单的 REST API 作为起点，它将使您的开发变得快速和可伸缩。我假设您对 AWS 部署如何工作和云形成有所了解。</p><h2 id="8fd1" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">要记住的要点</h2><ol class=""><li id="724c" class="ml mm iq ky b kz mn lc mo lf mp lj mq ln mr lr ms mt mu mv bi translated">Cloudformation 模板将只允许每个部署 200 个资源。(<a class="ae kv" href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/cloudformation-limits.html" rel="noopener ugc nofollow" target="_blank">文档</a>)。因此，服务部署应该以更细粒度的方式完成。</li><li id="5891" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated">每个部署的服务将拥有多个资源，并独立访问其他服务。</li><li id="2980" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated">如果我们有单独的服务，我们可以单独捆绑，使捆绑包的大小更小。</li></ol><p id="e2d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，让我们关注第一个限制。针对这一限制的唯一可行的解决方法是使用只关注一个任务的隔离服务(这确实是使用微服务的动机。).让我们使用无服务器框架来制作样板文件(入门指南:<a class="ae kv" href="https://serverless.com/framework/docs/getting-started/" rel="noopener ugc nofollow" target="_blank">此处为</a>)。还有，你需要无服务器离线插件(获取:<a class="ae kv" href="https://github.com/dherault/serverless-offline" rel="noopener ugc nofollow" target="_blank">这里</a>)。</p><h1 id="1488" class="nb lt iq bd lu nc nd ne lx nf ng nh ma jw ni jx md jz nj ka mg kc nk kd mj nl bi translated">构建无服务器配置</h1><p id="b693" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">简而言之，我们将为每个服务建立单独的文件夹，并为每个文件夹建立一个<code class="fe np nq nr ns b">service.yml</code>。在无服务器框架中，当我们部署或运行离线插件时，我们可以使用<code class="fe np nq nr ns b">--option VALUE</code>提供任何选项。我们将利用这个工具来选择单独的服务进行部署或离线运行。我们将在命令行中使用<code class="fe np nq nr ns b">--service</code>选项加载每个服务，并使用<code class="fe np nq nr ns b">--stage</code>选项进行分段。</p><p id="b710" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个样板文件中，我将如下组织我的文件夹结构。</p><pre class="kg kh ki kj gt nt ns nu nv aw nw bi"><span id="a93d" class="ls lt iq ns b gy nx ny l nz oa">- serverless.yml (main serverless config file)<br/>- prod.env.yml (configs for the prod environment)<br/>- dev.env.yml (configs for the dev environment)<br/>- offline-serverless.js (offline runner for testing)<br/>- package.json (node modules neede, for nodejs)</span><span id="2b20" class="ls lt iq ns b gy ob ny l nz oa">// Folders containing the application logic</span><span id="cfd7" class="ls lt iq ns b gy ob ny l nz oa">- first-service<br/>-- service.yml<br/>-- main.js</span><span id="040a" class="ls lt iq ns b gy ob ny l nz oa">- second-service<br/>-- service.yml<br/>-- main.js</span><span id="2eff" class="ls lt iq ns b gy ob ny l nz oa">// Utils for routing<br/>- utils<br/>-- lambda-router.js<br/>-- errors.js (Error message, not essential)<br/>-- db-util.js (Managing the database connection)</span></pre><h2 id="c9a0" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">serverless.yml 的内容</h2><p id="ea49" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">这是我们服务结构的核心。在 YML 中，我们可以构造符号，以便在运行时填充部分文件。在我们的例子中，从每个服务的<code class="fe np nq nr ns b">service.yml</code>文件中选择与服务相关的内容。</p><p id="13e6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的<code class="fe np nq nr ns b">serverless.yml</code>如下所示。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">无服务器. yml</p></figure><p id="c670" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里,<code class="fe np nq nr ns b">package</code>将携带要包含的文件夹，而<code class="fe np nq nr ns b">functions</code>将携带每个服务内部的功能。这些将从每个服务的文件夹的<code class="fe np nq nr ns b">service.yml</code>文件中加载。</p><p id="e980" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">部署脚本命令示例:</p><p id="adb4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe np nq nr ns b">serverless deploy --stage dev --service service1</code></p><h2 id="0eaa" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">用于测试的离线配置</h2><p id="ad4f" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">离线运行命令的示例如下所示:</p><p id="076f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe np nq nr ns b">serverless offline start --stage dev --service service1 --port 3000</code></p><p id="7942" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，为了测试，我们必须在不同的端口上运行每个服务。下面是一个脚本，使我们的任务变得简单。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">无服务器-offline.js</p></figure><p id="4045" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里<code class="fe np nq nr ns b">PATH1</code>和<code class="fe np nq nr ns b">PATH2</code>是基本路径(例如；<code class="fe np nq nr ns b">users/</code>为用户服务，<code class="fe np nq nr ns b">posts/</code>为帖子服务)。这在服务内部是不相关的，因此，请注意，我已经删除了基本路径；在第 24 行。每个服务都专注于一件事，所以拥有一个单独的基本路径是多余的(然而我们将在最终的 API 部署中拥有它)。</p><p id="0db6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以简单地离线运行我们所有的服务进行测试；</p><p id="efae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe np nq nr ns b">node offline-serverless.js</code></p><h2 id="98ce" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">每个服务内部的内容</h2><p id="1b33" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">每个服务应包含所需的资源。在这个例子中，我们将放置 REST API 端点。这段代码将如下所示。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">service.yml</p></figure><p id="4db9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，这里我们包括了<code class="fe np nq nr ns b">node_modules</code> <code class="fe np nq nr ns b">utils</code>和携带逻辑的文件。</p><h1 id="ec4e" class="nb lt iq bd lu nc nd ne lx nf ng nh ma jw ni jx md jz nj ka mg kc nk kd mj nl bi translated">部署</h1><p id="0fa0" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">部署就像普通的无服务器框架部署一样。然而，在 API 网关中有一些值得注意的事情。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/ee1891352dbdac5159e946f291865e1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lx6SrFT_1t5xvwSpoWksVQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">具有多个服务的示例部署视图</p></figure><p id="d019" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如前所述，尽管我们的应用程序有端点，如<code class="fe np nq nr ns b">users/profile-detail</code>，但我们的用户服务将只接受<code class="fe np nq nr ns b">profile-details</code>，因为它的唯一目的是处理用户。然而，我们需要 API 知道<code class="fe np nq nr ns b">users/</code>请求必须提供给用户服务 lambda。我们就是这么做的。</p><p id="cab6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">转到—API，然后转到自定义域名。您将看到以下视图。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/65f5386674428cca1c27476ffae75592.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PVeiEMy_iWXYCLatPpI3_A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">自定义域名</p></figure><p id="772c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，您可以单击编辑并添加自定义映射。例如，在上面的设置中，我将它们添加如下。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/ff8cb14d7fcd1e6984d0827b048a8d9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0kaYS7wtXFCG8lW4V55vyQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">基本路径、服务和阶段的映射</p></figure><p id="f2a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于这个 API，生产环境只有一个映射。如果你有几个在线测试的环境，你必须这样设置。在这里，我已经购买了一个域，并为我的 API 链接了子域。然而，您可以使用无域 API，但是这样您将不得不依赖 AWS 为每个服务随机生成的 URL(不整洁！).</p><h1 id="bb8b" class="nb lt iq bd lu nc nd ne lx nf ng nh ma jw ni jx md jz nj ka mg kc nk kd mj nl bi translated">清盘</h1><ul class=""><li id="762e" class="ml mm iq ky b kz mn lc mo lf mp lj mq ln mr lr oh mt mu mv bi translated">路径是相对于<code class="fe np nq nr ns b">serverless.yml</code>记录的，所以加载外部文件时要小心。总是使用<code class="fe np nq nr ns b">__dirname + ‘/file.extension’</code>来加载文件。</li><li id="9652" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr oh mt mu mv bi translated">我为这个样板文件做了一个<a class="ae kv" href="https://github.com/anuradhawick/aws-lambda-serverless-boilerplate" rel="noopener ugc nofollow" target="_blank"> repo </a>，包括我的 lambda 路由器和 DB 处理器。看一看，星，叉，提高，发个 PR 给我。<br/><a class="ae kv" href="https://github.com/anuradhawick/aws-lambda-serverless-boilerplate" rel="noopener ugc nofollow" target="_blank">https://github . com/anuradhawick/AWS-lambda-server less-boilerplate</a></li><li id="4cca" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr oh mt mu mv bi translated">看看 lambda 路由器吧，它非常简单，支持<code class="fe np nq nr ns b">LAMBDA_PROXY</code>集成(请看这里的<a class="ae kv" href="https://github.com/anuradhawick/aws-lambda-serverless-boilerplate/blob/master/utils/lambda-router.js" rel="noopener ugc nofollow" target="_blank"/>)。你可以在这里看到我是如何使用它的<a class="ae kv" href="https://github.com/anuradhawick/aws-lambda-serverless-boilerplate/blob/master/first-service/first-main.js" rel="noopener ugc nofollow" target="_blank">。</a></li><li id="1998" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr oh mt mu mv bi translated">如果您计划向<code class="fe np nq nr ns b">serverless-offline.js</code>添加更多服务，请选择不同的端口及其基本路径。更新第 4 行中的<code class="fe np nq nr ns b">services</code>数组。</li></ul><p id="3aed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">相信这篇文章会对日以继夜辛勤工作的开发者有所帮助。<br/>感谢阅读！干杯！</p></div></div>    
</body>
</html>