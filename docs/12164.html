<html>
<head>
<title>Delta lake with Spark: What and Why?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">有火花的三角洲湖:什么和为什么？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/delta-lake-with-spark-what-and-why-6d08bef7b963?source=collection_archive---------6-----------------------#2020-08-22">https://towardsdatascience.com/delta-lake-with-spark-what-and-why-6d08bef7b963?source=collection_archive---------6-----------------------#2020-08-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5ab1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解支持 ACID 和 Spark 更新的存储层</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0caa3141cefc25befc38b8991ddb998c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yPZap7X4nhqiLrkQZe-6wQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">弗兰基·查马基在<a class="ae ky" href="https://unsplash.com/s/photos/big-data?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="13f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我首先介绍两个问题，这是我在使用 Apache Spark 的过程中反复遇到的问题:</p><ol class=""><li id="92eb" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">同一路径上的数据“覆盖”会在作业失败时导致数据丢失。</li><li id="078f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">数据的更新。</li></ol><p id="ab24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时我通过设计变更解决上述问题，有时通过引入另一个层，如 Aerospike，或者有时通过维护历史增量数据。</p><p id="8e8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">维护历史数据通常是一个直接的解决方案，但是我不太喜欢处理<strong class="lb iu">的历史增量数据</strong>，如果不是真的需要的话，因为(至少对我来说)它会在失败的情况下引入回填的痛苦，虽然失败可能不太可能，但是不可避免。</p><p id="34d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以上两个问题都是“问题”，因为 Apache Spark 并不真正支持 ACID。我知道 Spark 从来没有处理事务的用例(你好，你不可能拥有一切)，但有时，可能会有这样的场景(就像我上面的两个问题)，ACID 合规性会派上用场。</p><p id="1e8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我读到德尔塔湖和它的耐酸性时，我认为它是我的两个问题的可能解决方案之一。请继续阅读，了解这两个问题如何与酸性合规失败相关联，以及三角洲湖如何被视为救世主？</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="5449" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">三角洲湖是什么？</h1><p id="2248" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">三角洲湖文档将三角洲湖介绍为:</p><blockquote class="nn no np"><p id="b8a9" class="kz la nq lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi translated"><a class="ae ky" href="https://delta.io/" rel="noopener ugc nofollow" target="_blank"> Delta Lake </a>是<a class="ae ky" href="https://github.com/delta-io/delta" rel="noopener ugc nofollow" target="_blank">开源存储层</a>，为<a class="ae ky" href="https://databricks.com/discover/data-lakes/introduction" rel="noopener ugc nofollow" target="_blank">数据湖</a>带来可靠性。Delta Lake 提供了 ACID 事务、可扩展的元数据处理，并统一了流式和批量数据处理。Delta Lake 运行在您现有的数据湖之上，并且与 Apache Spark APIs 完全兼容。</p></blockquote><p id="204f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">三角洲湖关键点:</p><ul class=""><li id="b1ac" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nu mb mc md bi translated">支持酸</li><li id="0f83" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nu mb mc md bi translated">实现时间旅行</li><li id="ee60" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nu mb mc md bi translated">启用 UPSERT</li></ul><h1 id="14cc" class="mq mr it bd ms mt nv mv mw mx nw mz na jz nx ka nc kc ny kd ne kf nz kg ng nh bi translated">火花如何失败酸？</h1><p id="5601" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">考虑下面这段从数据集中删除重复项的代码:</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="ab5a" class="of mr it ob b gy og oh l oi oj"># Read from HDFS<br/>df = spark.read.parquet("/path/on/hdfs") # Line 1<br/># Remove duplicates<br/>df = df.distinct() # Line 2<br/># Overwrite the data<br/>df.cache() # Line 3<br/>df.write.parquet("/path/on/hdfs", mode="overwrite") # Line 4</span></pre><p id="bfe8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于运行在这段代码上的 spark 应用程序，考虑一个场景，它在第 4 行失败，也就是在写入数据时失败。这可能会也可能不会导致数据丢失。【问题#1:如上所述】。您可以通过创建测试数据集来复制该场景，并在作业处于<em class="nq">写</em>阶段时终止作业。</p><p id="a5c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们试着用上面的场景来理解 spark 中的酸失效。</p><h2 id="0057" class="of mr it bd ms ok ol dn mw om on dp na li oo op nc lm oq or ne lq os ot ng ou bi translated">酸中的 a 代表原子数，</h2><ul class=""><li id="5256" class="lv lw it lb b lc ni lf nj li ov lm ow lq ox lu nu mb mc md bi translated"><em class="nq">什么是原子性:</em>要么所有的变化都发生，要么都不发生，系统永远不会处于中途状态。</li><li id="5acf" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nu mb mc md bi translated">【spark 如何失败:在写入数据时，(上面第 4 行)，如果在旧数据被删除而新数据尚未写入的阶段发生失败，则发生数据丢失。我们丢失了旧数据，并且由于作业失败、原子性失败，我们无法写入新数据。[它可以根据使用的文件输出提交器而变化，请务必阅读文件输出提交器，以了解数据写入是如何发生的，我解释的场景是针对 v2 的]</li></ul><h2 id="1be9" class="of mr it bd ms ok ol dn mw om on dp na li oo op nc lm oq or ne lq os ot ng ou bi translated">酸中的 c 代表一致性，</h2><ul class=""><li id="84d6" class="lv lw it lb b lc ni lf nj li ov lm ow lq ox lu nu mb mc md bi translated"><em class="nq">什么是一致性</em>:数据在系统中必须始终保持一致和有效。</li><li id="a302" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nu mb mc md bi translated">【Spark 如何失败:如上所述，在失败和数据丢失的情况下，我们在系统中留下无效数据，一致性失败。</li></ul><h2 id="8837" class="of mr it bd ms ok ol dn mw om on dp na li oo op nc lm oq or ne lq os ot ng ou bi translated">酸中的 I 代表隔离，</h2><ul class=""><li id="95d8" class="lv lw it lb b lc ni lf nj li ov lm ow lq ox lu nu mb mc md bi translated"><em class="nq">什么是隔离:</em>多个事务隔离发生</li><li id="a1cb" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nu mb mc md bi translated"><em class="nq">spark 如何失败:</em>考虑并行运行的两个作业，一个如上所述，另一个也使用相同的数据集，如果一个作业覆盖数据集，而另一个仍在使用它，可能会发生失败，隔离失败。</li></ul><h2 id="6a7a" class="of mr it bd ms ok ol dn mw om on dp na li oo op nc lm oq or ne lq os ot ng ou bi translated">酸中的 d 代表耐久性，</h2><ul class=""><li id="ee48" class="lv lw it lb b lc ni lf nj li ov lm ow lq ox lu nu mb mc md bi translated"><em class="nq">什么是持久性:</em>更改一旦做出就永远不会丢失，即使在系统出现故障的情况下。</li><li id="14f9" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nu mb mc md bi translated"><em class="nq">Spark 可能如何失败:</em> Spark 确实不影响耐用性，它主要由存储层管理，但由于我们在作业失败的情况下会丢失数据，在我看来，这是一个耐用性故障。</li></ul><h1 id="cb8c" class="mq mr it bd ms mt nv mv mw mx nw mz na jz nx ka nc kc ny kd ne kf nz kg ng nh bi translated">三角洲湖如何支持酸？</h1><p id="c773" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">Delta lake 在写入数据的路径中维护一个 Delta 日志。增量日志维护如下详细信息:</p><ul class=""><li id="fd2e" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nu mb mc md bi translated">类似于<br/>的元数据-写入操作中添加的路径。<br/> -写入操作中移除的路径。<br/> -数据大小<br/> -数据的变化</li><li id="b826" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nu mb mc md bi translated">数据模式</li><li id="ef52" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nu mb mc md bi translated">提交信息，如<br/> -输出行数<br/> -输出字节数<br/> -时间戳</li></ul><p id="e6f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在某些操作后创建的 _delta_log_ directory 中的示例日志文件:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/8fb4036a3de8ca1a7d1a89124ab8924f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ujCytzYqP8iY-0P64UAMnw.png"/></div></div></figure><p id="976a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">成功执行后，会在 _delta_log_ 目录中创建一个日志文件。重要的是要注意，当你保存你的数据作为增量，没有文件一旦写入被删除。这个概念类似于版本控制。</p><p id="d3cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过在 _delta_log_ 中跟踪删除、添加的路径和其他元数据信息，Delta lake 是 ACID 兼容的。</p><p id="1823" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">版本控制启用了 Delta Lake 的时间旅行属性，也就是说，我可以回到任何数据状态，因为所有这些信息都保存在 _delta_log_ 中。</p><h1 id="2cbf" class="mq mr it bd ms mt nv mv mw mx nw mz na jz nx ka nc kc ny kd ne kf nz kg ng nh bi translated">三角洲湖如何解决我上面提到的两个问题？</h1><ul class=""><li id="0fed" class="lv lw it lb b lc ni lf nj li ov lm ow lq ox lu nu mb mc md bi translated">有了对 ACID 的支持，如果我的作业在“覆盖”操作期间失败，数据不会丢失，因为更改不会提交到 _delta_log_ directory 的日志文件。此外，由于 Delta Lake 不会在“覆盖操作”中删除旧文件，因此我的数据会保持旧状态，不会有数据丢失。(是的，我测试过)</li><li id="03f7" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nu mb mc md bi translated">Delta lake 支持上面提到的更新操作，因此它使得处理数据更新更加容易。</li></ul><p id="b6fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nq">下次见，<br/>再见。</em></p></div></div>    
</body>
</html>