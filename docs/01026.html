<html>
<head>
<title>Tradable Patterns Hiding in Plain Sight</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">隐藏在众目睽睽之下的交易模式</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/tradable-patterns-hiding-in-plain-sight-350cc58f0860?source=collection_archive---------22-----------------------#2020-01-29">https://towardsdatascience.com/tradable-patterns-hiding-in-plain-sight-350cc58f0860?source=collection_archive---------22-----------------------#2020-01-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/5bb0d888f880f4bef8d482866bd1727d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bwqDfb8L8yF-n3O8ECKr1w.jpeg"/></div></div></figure><div class=""/><div class=""><h2 id="7a48" class="pw-subtitle-paragraph kb jd je bd b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dk translated">股票市场中有更长期的可交易模式，你不需要成为专业交易员或统计学博士也能搞清楚。</h2></div><p id="a77f" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我在投资研究公司和资本市场数据供应商的销售和业务开发部门工作了14年。我现在正在将我的职业生涯从数据销售转向数据分析。我正在学习许多关于人工智能、机器学习以及如何使用Python代码来利用这些技术进行投资的很酷的东西。我发现学习新事物最快的方法是尝试去教它。所以我想分享一下我在学习过程中所学到的东西。</p><p id="6200" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">去年夏天，我去了一个零售“交易展”,发现了一个我认为值得研究的想法。这个想法是，有一些股票在一年中的特定时间可靠地上涨，年复一年，往往不是这样。在展会上谈论这一想法的演讲者当然是在推销一种订阅提醒服务，以便在发现这种交易“机会”时通知投资者。</p><p id="6720" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">但我想，“等一下。任何人都应该能够通过查看历史价格模式来验证这一想法，而我自己就有这样的技能和工具！”我是Excel高手，我最近学会了一些Python技巧，我知道如何从雅虎下载免费的历史价格数据。为什么不看看这个好玩的呢？</p><p id="2036" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">因此，我用Python编写了一个脚本来下载数据，运行一些统计数据，并将数据导出到一个潜在交易列表中，每个股票都有一个支持的Excel表格。我是这样做的。</p><p id="dc27" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">第一步——从那些规模大、信誉好、盈利能力强的公司开始，这样我就有足够的历史数据可以利用，而且短期内我不必太担心基本面。我选择从标准普尔500指数中的上市公司开始。</p><p id="ae44" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">接下来，我从哪里获取数据？幸运的是，雅虎财经免费提供大多数股票的完整历史收盘数据。雅虎的每个历史数据页面都包括一个免费的“下载数据”链接，只需几行VBA代码就可以轻松插入Excel。此外，一个名叫<a class="ae lp" href="https://aroussi.com/author/Ran-Aroussi" rel="noopener ugc nofollow" target="_blank">的Python天才建立了一个免费的库</a><a class="ae lp" href="https://aroussi.com/post/python-yahoo-finance" rel="noopener ugc nofollow" target="_blank"> yFinance </a>，它用Python以最少的代码从雅虎下载数据。上帝保佑他！！</p><p id="0033" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">最后，现在我有了所有的数据，我应该计算什么样的指标才能让我找到表现出可靠的季节性表现模式的股票呢？我对“可靠”的定义是百分之八十的时间。那符合我的风险承受能力。我想找到在一年中可预测的时间上涨的股票，至少十年中有八年是这样。</p><p id="45f2" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我如何定义“可预测”？我决定查看1个月、2个月和3个月的滚动时间段，每天递增，计算代表理论持有期结束的每个交易日的百分比回报。为了找到一个可靠的模式，我寻找稳定的时间段，跨越几天或几年，持有期回报持续为正。就百分比而言，这是大多数交易者的想法，我想找到这样的情况:一年中至少有25个交易日(10%)，最好是连续几天，一只股票在过去十年或更长时间里至少有8个交易日表现稳定。</p><p id="ee96" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">如果您要在Excel电子表格中直观显示这一点，每列代表一年，每行代表一年中的一个交易日，每个单元格包含一个持有期的百分比回报计算，以绿色显示正回报，您将会看到绿色的实心块遍布整个工作表。</p><p id="82a7" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">体育用品制造商VF公司(纽约证券交易所代码:VFC)的情况如下。每一列都是一年，从2001年到2019年。每一行是一天，从三月到四月。这张表显示VF的股票价格在过去20年的16到17年中每年的3月和4月都在上涨。事实上，VF的趋势周期从2月开始，3个月的平均收益约为6%。乘以四，你会得到大约24%的年化收益率。</p><figure class="lr ls lt lu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lq"><img src="../Images/44a3a9488ea68293cb39284b8c7e1331.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aK-ta_w4QgkRQWtVJE8Hbg.png"/></div></div><p class="lv lw gj gh gi lx ly bd b be z dk translated">VFC 3月至4月的3个月滚动回报</p></figure><p id="f689" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">然而，我不想花几个小时查看500个电子表格。而是写了一个脚本，计算每只股票的一组统计数据，告诉我几分钟内想知道的事情。以下是我为每只股票计算的一些数据。</p><p id="f0b6" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf"> %就VF Corp .而言，这一比例约为18%。这意味着在250个交易日中的45个交易日，你有80%的机会获得正回报，从而结束了3个月的持有期。这45天的大部分时间是在二月到四月。我更愿意看到这个数字在10%或以上。</strong></p><p id="e1b9" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf">平均上涨回报率</strong>:回报率为正的每个滚动期的平均回报率。如上所述，VF在我的计算中显示为6%。这一开始听起来并不多，但是请记住，它只需要三个月就能实现。如果你将其乘以12个月，你会得到约24%的年化回报率。</p><p id="2284" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf"> Avg StDev </strong>:所有滚动周期的收益标准差。这意味着预期回报应该在平均67%的时间的+/-范围内。对于VF，平均StDev为11.4%。</p><p id="a3ed" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf"> %下跌</strong>:预期平均收益减去标准差。这意味着你至少应该在67%的时间里超过这个回报。VF公司的平均标准差为11.4%。6.01%减去11.37%等于-5.4%。这意味着你可能会在几年内损失5.4%或更多。这是一个很好的止损阈值，它给了你一个风险与回报的指标。</p><p id="ba48" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf">最小痛点</strong>:最佳情况下，在最佳时机内下降67%的时间间隔。这用于确定最低风险时间范围，即进入和退出交易的最佳日期。</p><p id="f7ae" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf">最大连续80%</strong>:10年中至少有8年获得正回报的最长连续滚动周期数。你希望看到超过连续几年的上涨，以保证趋势是强劲的。对于VF来说，这个数字是38天，这已经很不错了。我通常喜欢看到20个或更多。</p><p id="143e" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在过滤了超过10%的上涨百分比和至少10年的历史后，我列出了大约37只股票，这些股票在10年中至少有8年显示出可靠的季节性上涨趋势。</p><p id="f69f" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我会建议立即执行这个清单上的交易吗？号码</p><p id="3f64" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">首先，这种策略只有在整体市场上涨时才是可靠的。在查看了每只股票的回报细节后，我发现大多数股票在2000年至2002年、2008年至2009年期间一直呈现负回报，许多股票在2015年和2018年底呈现负回报。然而，当我修改代码以生成一个卖空候选人列表时，没有一个符合连续年下跌期的80%阈值。</p><p id="2a9f" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">因此，这种技术将简单地产生一个建议的多头交易列表，其中赔率肯定是对你有利的。但是在执行之前，您应该仔细看看每一个。在交易之前，你至少应该检查每只股票的技术和基本面。您可能还想在不同的回看时间范围内运行这个脚本。</p><p id="e43d" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">时间框架很重要。我分析了20年的历史时间框架，但也许5年或10年更合适。例如，看看苹果公司(纽约证券交易所代码:AAPL)。回顾过去20年，交易AAPL的最佳3个月时间是每年的2月1日到4月30日。但是如果你看下面这张AAPL的表格，你会发现你只有75%的时间有正回报。这对一些人来说可能没问题，但对我来说不是(白色太多，绿色不够)。</p><figure class="lr ls lt lu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lq"><img src="../Images/4caea84f1cfefc2a4485bd2351c691d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4mLhq2aNHgDbTjP4kTjeMA.png"/></div></div><p class="lv lw gj gh gi lx ly bd b be z dk translated">AAPL 3月至4月的3个月滚动回报</p></figure><p id="aebe" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">然而，如果你向下滚动工作表，查看过去10年中从9月中旬到10月下旬结束的时间段，你会看到更多的纯绿色。这个时间框架给你80%的机会获得持续的正回报。</p><figure class="lr ls lt lu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lq"><img src="../Images/e2a2e8293a078c14107a901b08311261.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-1CrSVG2kt4zl0XXhD0jBg.png"/></div></div><p class="lv lw gj gh gi lx ly bd b be z dk translated">AAPL 3个月滚动回报9月至10月</p></figure><p id="39a6" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这种模式背后的原因可能与苹果每年9月宣布新品发布的习惯有关。如果可以的话，深入了解每家公司并找出这些模式背后的基本驱动力会有所帮助。</p><p id="e155" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">对于Python代码，以下是基本步骤:</p><ol class=""><li id="4914" class="lz ma je kv b kw kx kz la lc mb lg mc lk md lo me mf mg mh bi translated">从Yahoo下载数据，并将其保存在CSV文件中:</li></ol><pre class="lr ls lt lu gt mi mj mk ml aw mm bi"><span id="9923" class="mn mo je mj b gy mp mq l mr ms">for index, ticker in df_sp500_tickers.iterrows():<br/>    <br/>    my_ticker = ticker['Symbol']<br/>    <br/>    yf_ticker = yf.Ticker(my_ticker)<br/>    data = yf_ticker.history(period="max")<br/>    df = pd.DataFrame(data)<br/>    df.reset_index(level=0, inplace=True)<br/>    df['Symbol'] = my_ticker<br/>    df = df[['Symbol','Date','Close']]<br/>    #Yahoo has a tendency to duplicate the last row.<br/>    df.drop_duplicates(subset ="Date", keep = 'first', inplace = True) <br/>    df.to_csv(path_or_buf = my_path + "/data/" + my_ticker +".csv", index=False)</span></pre><p id="4440" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">2.基于每月20个交易日，将价格转换为持有期回报。</p><pre class="lr ls lt lu gt mi mj mk ml aw mm bi"><span id="3d2e" class="mn mo je mj b gy mp mq l mr ms">def convert_prices_to_periods():</span><span id="5979" class="mn mo je mj b gy mt mq l mr ms">    # dperiods is defined as 20, 40 or 60 days in a separate module<br/>    dfr = df.pct_change(periods = dperiods)<br/>    dfr.reset_index(level=0, inplace=True)<br/>    dfr.rename(columns={'Close':'Returns'}, inplace=True)<br/>    dfr = dfr.round(4)</span></pre><p id="4f15" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">3.将日期列分成月、年和日值，然后旋转数据框以创建一个顶部带有年份的表格。</p><pre class="lr ls lt lu gt mi mj mk ml aw mm bi"><span id="3d02" class="mn mo je mj b gy mp mq l mr ms">def separate_date_column():<br/>    <br/>    dfr['Month'] = pd.DatetimeIndex(dfr['Date']).month<br/>    dfr['Day'] = pd.DatetimeIndex(dfr['Date']).day<br/>    dfr['Year'] = pd.DatetimeIndex(dfr['Date']).year<br/>    dfr['M-D'] = dfr['Month'].astype(str)+'-'+dfr['Day'].astype(str)<br/>    pd.set_option('display.max_rows', len(dfr))</span><span id="a21e" class="mn mo je mj b gy mt mq l mr ms">def pivot_the_table():<br/><br/>    dfr_pivot = dfr.pivot(index='M-D', columns='Year', values='Returns')<br/>    dfr_pivot.reset_index(level=0, inplace=True)<br/>    dfr_pivot = pd.DataFrame(dfr_pivot)<br/>    dfr_pivot.columns.name="Index"</span><span id="671f" class="mn mo je mj b gy mt mq l mr ms"># Fill empty cells with EOD values from the previous trading day.<br/>    dfr_pivot.fillna(method='ffill', inplace=True)<br/>    <br/>    # Drop the 2020 year column.<br/>    if 2020 in dfr_pivot.columns:<br/>        dfr_pivot.drop(2020, axis=1, inplace=True)</span></pre><p id="681f" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">4.添加额外的计算列，以便于每种股票的统计计算。</p><pre class="lr ls lt lu gt mi mj mk ml aw mm bi"><span id="b81d" class="mn mo je mj b gy mp mq l mr ms">def add_calculated_items():<br/>    <br/>    # The lookback figure is the number (must be an integer) of years back from last year (2019) that you want to include in the analysis, i.e. the calculations below. It's probably a good idea to keep it at 20 years or less to reflect more recent market conditions.</span><span id="a39d" class="mn mo je mj b gy mt mq l mr ms">    lookback = 20<br/>    start = 1<br/>    <br/>    if lookback &gt; len(dfr_pivot.columns) - 1:<br/>        start = 1<br/>    else:<br/>        start = len(dfr_pivot.columns) - lookback<br/>    <br/>    dfr_pivot['YearCount'] = dfr_pivot.count(axis=1, numeric_only=True)<br/>    dfr_pivot['Lookback'] = lookback<br/>    dfr_pivot['UpCount'] = dfr_pivot[dfr_pivot.iloc[:,start:len(dfr_pivot.columns)-2] &gt; 0].count(axis=1)<br/>    dfr_pivot['DownCount'] = dfr_pivot[dfr_pivot.iloc[:,start:len(dfr_pivot.columns)] &lt; 0].count(axis=1)<br/>    dfr_pivot['PctUp'] = dfr_pivot['UpCount']/dfr_pivot['Lookback']<br/>    dfr_pivot['PctDown'] = dfr_pivot['DownCount']/dfr_pivot['Lookback']<br/>    dfr_pivot['AvgReturn'] = dfr_pivot.iloc[:,start:len(dfr_pivot.columns)-6].mean(axis=1)<br/>    dfr_pivot['StDevReturns'] = dfr_pivot.iloc[:,start:len(dfr_pivot.columns)-7].std(axis=1)<br/>    dfr_pivot['67PctDownside'] = dfr_pivot['AvgReturn']-dfr_pivot['StDevReturns']<br/>    dfr_pivot['MaxReturn'] = dfr_pivot.iloc[:,start:len(dfr_pivot.columns)-9].max(axis=1)<br/>    dfr_pivot['MinReturn'] = dfr_pivot.iloc[:,start:len(dfr_pivot.columns)-10].min(axis=1)</span></pre><p id="e20d" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">5.计算股票滚动持有期的交易统计数据。</p><pre class="lr ls lt lu gt mi mj mk ml aw mm bi"><span id="18d5" class="mn mo je mj b gy mp mq l mr ms">def calc_trading_stats():<br/>    <br/>    pct_uprows = (dfr_pivot.loc[dfr_pivot['PctUp'] &gt; threshold, 'PctUp'].count() / dfr_pivot.loc[:, 'PctUp'].count()).astype(float).round(4)<br/>    max_up_return = dfr_pivot.loc[dfr_pivot['PctUp'] &gt; threshold, 'MaxReturn'].max()<br/>    min_up_return = dfr_pivot.loc[dfr_pivot['PctUp'] &gt; threshold, 'MinReturn'].min()<br/>    avg_up_return = dfr_pivot.loc[dfr_pivot['PctUp'] &gt; 0.5, 'AvgReturn'].mean()<br/>    avg_up_return = np.float64(avg_up_return).round(4)<br/>    avg_down_return = dfr_pivot.loc[dfr_pivot['PctDown'] &gt; 0.5, 'AvgReturn'].mean()<br/>    avg_down_return = np.float64(avg_down_return).round(4)<br/>    exp_return = dfr_pivot['AvgReturn'].mean().round(4)<br/>    stdev_returns = dfr_pivot['StDevReturns'].mean()<br/>    stdev_returns = np.float64(stdev_returns).round(4)<br/>    worst_return = dfr_pivot['MinReturn'].min()<br/>    pct_downside = exp_return - stdev_returns<br/>    pct_downside = np.float64(pct_downside).round(4)<br/>    least_pain_pt = dfr_pivot.loc[dfr_pivot['PctUp'] &gt; threshold, '67PctDownside'].max()<br/>    total_years = dfr_pivot['YearCount'].max()<br/>    analyzed_years = lookback<br/>    <br/>    n_consec = 0<br/>    max_n_consec = 0</span><span id="f849" class="mn mo je mj b gy mt mq l mr ms">    for x in dfr_pivot['PctUp']:<br/>        if (x &gt; threshold):<br/>            n_consec += 1<br/>        else: # check for new max, then start again from 1<br/>            max_n_consec = max(n_consec, max_n_consec)<br/>            n_consec = 1</span><span id="1219" class="mn mo je mj b gy mt mq l mr ms">    max_consec_beat = max_n_consec</span><span id="4d15" class="mn mo je mj b gy mt mq l mr ms">    try:<br/>        best_sell_date = dfr_pivot.loc[dfr_pivot['67PctDownside'] == least_pain_pt, 'M-D'].iloc[0]<br/>    except:<br/>        best_sell_date = "nan"</span><span id="475a" class="mn mo je mj b gy mt mq l mr ms">    try:<br/>        row = dfr_pivot.loc[dfr_pivot['M-D'] == best_sell_date, 'M-D'].index[0] - interval<br/>        col = dfr_pivot.columns.get_loc('M-D')<br/>        best_buy_date = dfr_pivot.iloc[row,col]<br/>    except:<br/>        best_buy_date = "nan"</span></pre><p id="a0ab" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">6.如果满足% Up行和历史条件，则创建stat值数组并将其附加到推荐交易列表中。</p><pre class="lr ls lt lu gt mi mj mk ml aw mm bi"><span id="0558" class="mn mo je mj b gy mp mq l mr ms">def filter_and_append_stats():<br/>    <br/>    # Save the stats data separately to export to Excel for further research on each ticker if desired.<br/>    statsdata = np.array([my_ticker, hold_per, pct_uprows, max_up_return, min_up_return, avg_up_return, avg_down_return, exp_return, stdev_returns, pct_downside, worst_return, least_pain_pt, total_years, max_consec_beat, best_buy_date, best_sell_date, analyzed_years])<br/>    df_statsdata = pd.DataFrame(statsdata.reshape(-1, len(statsdata)), columns=['my_ticker', 'hold_per', 'pct_uprows', 'max_up_return', 'min_up_return', 'avg_up_return', 'avg_down_return', 'exp_return', 'stdev_returns', 'pct_downside', 'worst_return', 'least_pain_pt', 'total_years', 'max_consec_beat', 'best_buy_date', 'best_sell_date', 'analyzed_years'])<br/>    <br/>    if pct_uprows &gt; 0.1:<br/>        if total_years &gt; 9:<br/>            df_tradelist = df_tradelist.append(dict(zip(df_tradelist.columns, statsdata)), ignore_index=True)</span></pre><p id="8afc" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">7.最后，将所有这些放在一个模块中，该模块提取每个CSV文件，计算统计数据，将它们加载到推荐交易表中，然后将数据保存在格式化的Excel文件中，用于每个报价器，如上所示。</p><pre class="lr ls lt lu gt mi mj mk ml aw mm bi"><span id="d770" class="mn mo je mj b gy mp mq l mr ms">def calc_3month_returns():<br/> <br/>    dperiods = 60<br/>    hold_per = "3 Mos"<br/>    interval = 90<br/>    <br/>    convert_prices_to_periods()<br/>    <br/>    separate_date_column()</span><span id="fd51" class="mn mo je mj b gy mt mq l mr ms">    pivot_the_table()</span><span id="d578" class="mn mo je mj b gy mt mq l mr ms">    add_calculated_items()</span><span id="23c0" class="mn mo je mj b gy mt mq l mr ms">    sortbydate_resetindex_export()<br/>    <br/>    # Export the pivot table to CSV for further research if desired.<br/>    #dfr_pivot.to_csv(path_or_buf = my_path + "/data/" + my_ticker + "_dfr_pivot_3mo.csv", index=False)<br/>    <br/>    # Save dfr_pivot to separate dataframe for exporting to Excel<br/>    dfr_3mo = pd.DataFrame(dfr_pivot)</span><span id="a615" class="mn mo je mj b gy mt mq l mr ms">    calc_trading_stats()<br/>    <br/>    filter_and_append_stats()<br/>    <br/>    # Save statsdata to separate dataframe for exporting to Excel<br/>    df_statsdata_3mo = df_statsdata.copy()</span><span id="e7da" class="mn mo je mj b gy mt mq l mr ms">for index, ticker in df_sp500_tickers.iterrows():<br/>    <br/>    global df<br/>    global dfr<br/>    <br/>    my_ticker = ticker['Symbol']</span><span id="f6f3" class="mn mo je mj b gy mt mq l mr ms">    df = pd.read_csv (my_path + "/data/" + my_ticker + ".csv")<br/>    df.set_index('Date', inplace=True)<br/>    df = df['Close']<br/>    df = pd.DataFrame(df, columns=['Close'])<br/>    <br/>    calc_1month_returns()<br/>    <br/>    calc_2month_returns()<br/>    <br/>    calc_3month_returns()<br/>    <br/>    export_to_excel()</span></pre><p id="4803" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">Excel导出模块相当广泛。我使用了一个名为<a class="ae lp" href="https://xlsxwriter.readthedocs.io/introduction.html" rel="noopener ugc nofollow" target="_blank"> XlsxWriter </a>的Python库来完成这项工作。下面是这段代码的样子:</p><pre class="lr ls lt lu gt mi mj mk ml aw mm bi"><span id="8e0a" class="mn mo je mj b gy mp mq l mr ms">def export_to_excel():<br/>    <br/>    excel_file_path = my_path + "/data/" + my_ticker + ".xlsx"<br/>    <br/>    # Create a Pandas Excel writer using XlsxWriter as the engine.<br/>    writer = pd.ExcelWriter(excel_file_path, engine='xlsxwriter')</span><span id="0aee" class="mn mo je mj b gy mt mq l mr ms"># Convert the dataframe to an XlsxWriter Excel object.<br/>    df_statsdata_1mo.to_excel(writer, sheet_name='Stats', index=False)<br/>    df_statsdata_2mo.to_excel(writer, sheet_name='Stats', startrow=2, header=False, index=False)<br/>    df_statsdata_3mo.to_excel(writer, sheet_name='Stats', startrow=3, header=False, index=False)<br/>    dfr_1mo.to_excel(writer, sheet_name='1 Mo Returns', index=False)<br/>    dfr_2mo.to_excel(writer, sheet_name='2 Mo Returns', index=False)<br/>    dfr_3mo.to_excel(writer, sheet_name='3 Mo Returns', index=False)</span><span id="fc3e" class="mn mo je mj b gy mt mq l mr ms"># Get the xlsxwriter objects from the dataframe writer object.<br/>    workbook  = writer.book<br/>    worksheet1 = writer.sheets['Stats']<br/>    worksheet2 = writer.sheets['1 Mo Returns']<br/>    worksheet3 = writer.sheets['2 Mo Returns']<br/>    worksheet4 = writer.sheets['3 Mo Returns']<br/>    <br/>    # Add conditional formatting to highlight positive returns in green<br/>    end_column = dfr_1mo.columns.get_loc("YearCount")<br/>    grn_format = workbook.add_format({'bg_color':   '#C6EFCE','font_color': '#006100'})<br/>    worksheet2.conditional_format(1, 2, 365, end_column - 1,{'type':'cell','criteria':'&gt;','value':0,'format':grn_format})<br/>    worksheet3.conditional_format(1, 2, 365, end_column - 1,{'type':'cell','criteria':'&gt;','value':0,'format':grn_format})<br/>    worksheet4.conditional_format(1, 2, 365, end_column - 1,{'type':'cell','criteria':'&gt;','value':0,'format':grn_format})<br/>    <br/>    # Freeze panes for scrolling<br/>    worksheet2.freeze_panes(1, 2)<br/>    worksheet3.freeze_panes(1, 2)<br/>    worksheet4.freeze_panes(1, 2)<br/>    <br/>    # Save the file<br/>    writer.save()</span></pre><p id="9d7a" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">交易列表输出如下所示，按最佳买入日期排序:</p><figure class="lr ls lt lu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lq"><img src="../Images/4e6ed10100dc8c8e197f1d60ea3864f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sREljnbd39-ts64oZQKnYg.png"/></div></div><p class="lv lw gj gh gi lx ly bd b be z dk translated">基于3个月滚动季节性回报的建议交易</p></figure><p id="a811" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我的主要观点是，你不需要成为一个数学博士或者是一个高速日内交易者来发现股市中的重复模式，你可以用它来增加对你有利的机会。你只需要知道去哪里找，并掌握一点编码技巧就能有效地完成。</p><p id="38b8" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在这种情况下，我使用Python，但这也可以用Excel中的VBA代码轻松完成。你可以在<a class="ae lp" href="https://github.com/bnsheehy/Seasonal-Trade-Analysis/blob/master/Seasonal_Analysis.ipynb" rel="noopener ugc nofollow" target="_blank"> Github </a>上看到完整的Python脚本。请在<a class="ae lp" href="https://www.linkedin.com/in/bryantsheehy/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上给我发消息，告诉我你想提供的任何反馈。</p><p id="3b3c" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">编码和交易快乐！！</p><p id="4035" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf"> <em class="mu">来自《走向数据科学》编辑的提示:</em> </strong> <em class="mu">虽然我们允许独立作者根据我们的</em> <a class="ae lp" rel="noopener" target="_blank" href="/questions-96667b06af5"> <em class="mu">规则和指南</em> </a> <em class="mu">发表文章，但我们并不认可每个作者的贡献。你不应该在没有寻求专业建议的情况下依赖一个作者的作品。详见我们的</em> <a class="ae lp" rel="noopener" target="_blank" href="/readers-terms-b5d780a700a4"> <em class="mu">读者术语</em> </a> <em class="mu">。</em></p></div></div>    
</body>
</html>