<html>
<head>
<title>Find the Intersection of Two Sets of Coordinates and Sort By Colors Using Python OOP</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Python OOP 找到两组坐标的交集并按颜色排序</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/find-the-intersection-of-two-sets-of-coordinates-and-sort-by-colors-using-python-oop-7785f47a93b3?source=collection_archive---------65-----------------------#2020-06-02">https://towardsdatascience.com/find-the-intersection-of-two-sets-of-coordinates-and-sort-by-colors-using-python-oop-7785f47a93b3?source=collection_archive---------65-----------------------#2020-06-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="eee9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">解决两个编程问题，一个用排序算法，另一个用 Python 中的 OOP。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d6ebbea95666a3fb445471bb02e10531.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xNtpizsqgzTU5-F_dRYoZg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">资料来源:马丁·w·柯斯特的《Unsplash》</p></figure><p id="693b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章是关于一些编程练习的。如果你是一个初学者，正在学习 Python 中的数据结构和面向对象编程，这可能对你有帮助。我将解决两个问题，并尽可能多的解释。我假设您了解 Python 编程基础和 OOP 基础。我是从 Coursera 的课程《算法》第一部分得到这两个问题的想法的。</p><h2 id="e930" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">问题 1</h2><p id="2dfb" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">开发一种算法，它采用两个坐标列表并返回它们的交集。我们需要找到两个列表中的共同坐标。</p><p id="636a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">解决方案</strong></p><p id="2110" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解决这个问题有 4 个步骤</p><ol class=""><li id="5ee5" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated">连接两个列表，并从两个列表中生成一个列表。</li><li id="b396" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">首先按 x 坐标，然后按 y 坐标对这个合并列表进行排序。因此，如果有任何共同的项目，他们将并排。</li><li id="d645" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">然后返回重复的坐标。</li></ol><p id="40dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是完整的代码。函数“concArray”将连接列表。函数“sortList”将对坐标进行排序。如果两个连续坐标相同，函数“clash”将返回。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="9e4c" class="lv lw it ni b gy nm nn l no np">class Intersection():<br/>    def __init__ (self, sets):<br/>        self.sets = sets</span><span id="45d3" class="lv lw it ni b gy nq nn l no np">def concArrays(self):<br/>        self.sets = self.sets[0] + self.sets[1]<br/>        return self.sets</span><span id="8d64" class="lv lw it ni b gy nq nn l no np">def sortList(self):<br/>        self.sets = sorted(self.sets, key=lambda x: x[0])<br/>        return sorted(self.sets, key=lambda x: x[1])<br/>        <br/>    def clash(self):<br/>        return [self.sets[i] for i in range(0, len(self.sets)-1) if self.sets[i] == self.sets[i+1]]</span></pre><p id="144a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们检查算法是否正常工作:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="b38c" class="lv lw it ni b gy nm nn l no np">sets = [[(2,4),(5,3),(2,6),(6,2),(4,9)],[(4,9),(10,8),(9,3),(5,3),(1,7)]]<br/>inter = Intersection(sets)<br/>inter.concArrays()<br/>inter.sortList()<br/>print(inter.clash())</span></pre><p id="32c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它返回[(4，9)，(5，3)]。如果你注意到我们的集合变量，这是两个公共坐标。由于我们的列表不太大，我们可以通过查看来检查。</p><h2 id="179a" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">问题 2</h2><p id="9f5a" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">给定 n 个桶的列表，每个桶包含蓝色、白色或红色卵石。按照红、白、蓝的顺序按颜色排序。</p><p id="2b93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">解决方案</strong></p><p id="7c6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可能有不同的解决方法。我展示了两个解决方案。第一个是使用排序算法。这里我使用了插入排序。任何其他排序算法都将以同样的方式工作。</p><p id="456d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是步骤:</p><ol class=""><li id="18dc" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated">制作一个字典，其中颜色是关键字，值是整数。</li><li id="b334" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">在排序算法中，比较两种颜色时使用字典中的值。</li></ol><p id="57fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是完整的代码:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="aebb" class="lv lw it ni b gy nm nn l no np">def sortColor(a):<br/>    color = {'red': 1, 'white': 2, 'blue': 3}<br/>    for i in range(1, len(a)):<br/>        value = a[i]<br/>        hole = i<br/>        while (hole &gt; 0) and (color[a[hole -1]]&gt;color[value]):<br/>            a[hole] = a[hole -1]<br/>            hole = hole -1<br/>        a[hole] = value<br/>    return a</span></pre><p id="8f60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用以下颜色列表检查该算法:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="4cae" class="lv lw it ni b gy nm nn l no np">print(sortColor(['red', 'white', 'red', 'blue', 'white', 'blue']))</span></pre><p id="65a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出是完美的。请尝试一下。</p><p id="9a84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我还想展示一个两行代码的解决方案。如果你知道如何使用 lambda，这是给你的。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="b31f" class="lv lw it ni b gy nm nn l no np">def sortColor1(a):<br/>    color = {'red': 1, 'white': 2, 'blue': 3}<br/>    return sorted(a, key=lambda x: a[color[x]], reverse=True)</span></pre><p id="226a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望它有帮助。</p><p id="076e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">附加阅读:</p><ol class=""><li id="474e" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated"><a class="ae ky" href="https://regenerativetoday.com/lambda-map-filter-and-sorted-efficient-programming-with-python/" rel="noopener ugc nofollow" target="_blank">在 Python 中使用 Lambda、Map 和 Filter</a>。</li></ol></div></div>    
</body>
</html>