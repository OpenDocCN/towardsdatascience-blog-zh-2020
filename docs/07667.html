<html>
<head>
<title>Go, Neo4J, and AWS Lambda….</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go，Neo4J，还有AWS Lambda…</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/go-neo4j-and-aws-lambda-4cdd1af8886d?source=collection_archive---------64-----------------------#2020-06-08">https://towardsdatascience.com/go-neo4j-and-aws-lambda-4cdd1af8886d?source=collection_archive---------64-----------------------#2020-06-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="986f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">以及让它们一起工作的本质</h2></div><p id="551e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我几乎每天都与Neo4j一起工作，作为一名Python开发人员，我通常将他们两人结合在一起编写我的大部分逻辑。然而，在过去的几天里，自从我开始使用Golang，我似乎对它产生了强烈的亲和力。</p><p id="87b6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我想使用AWS Lambda构建一个简单的服务，对我的Neo4j数据库执行简单的查询，并决定使用Go来改变一下。得知Neo4j有官方的Go驱动程序，我明显松了一口气。但是最初的几次尝试完全失败了。</p><p id="5395" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不过不要担心，好消息是，你肯定可以一起使用AWS Lambda、Go和Neo4j。只有几个额外的步骤需要首先执行。</p><h1 id="9d82" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">问题是…</h1><blockquote class="lu lv lw"><p id="3f5e" class="kf kg lx kh b ki kj jr kk kl km ju kn ly kp kq kr lz kt ku kv ma kx ky kz la ij bi translated">是的，Neo4j有一个<a class="ae lb" href="https://github.com/neo4j/neo4j-go-driver" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir">官方驱动给Golang </strong> </a>。</p><p id="18a1" class="kf kg lx kh b ki kj jr kk kl km ju kn ly kp kq kr lz kt ku kv ma kx ky kz la ij bi translated">不，不是纯围棋写的。</p></blockquote><p id="d9f2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是什么意思？neo4j-go-driver依赖名为“<a class="ae lb" href="https://github.com/neo4j-drivers/seabolt" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> Seabolt </strong> </a>”的C库通过bolt协议连接到数据库实例。</p><p id="c563" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着在开始执行Neo4j的Go代码之前，您必须显式地安装这个库。此外，seabolt反过来要求在您的本地系统上安装<strong class="kh ir"> OpenSSL(对于Windows是TLS)</strong>才能正常工作。</p><p id="eb9b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本地机器上安装OpenSSL和Seabolt非常容易。事实上，OpenSSL预装在许多操作系统中。(我使用的Linux系统已经有了OpenSSL，我所要做的就是按照这些<strong class="kh ir">指令</strong> 安装Seabolt)</p><p id="88f4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们想要使用AWS Lambda复制同样的东西时，挑战就出现了。Go作为一种静态类型语言<strong class="kh ir">首先被编译成二进制文件，然后作为Lambda函数的处理程序。通常，如果所有的依赖项都是基于Go的，或者如果您在本地系统上工作，这不会导致任何问题。</strong></p><p id="3283" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，在我们的例子中，Go二进制依赖于外部C目标文件，并在运行时链接它们。但是我们如何让这些C文件对lambda函数可用呢？</p><h1 id="2a33" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">解决方案</h1><p id="3583" class="pw-post-body-paragraph kf kg iq kh b ki mb jr kk kl mc ju kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">在花了相当多的时间在互联网上寻找可能的解决方案后，我找不到任何具体的东西，尤其是围棋。大多数解决方案都是针对python的(因为某些python库也使用C依赖)，我几乎想回到我的老朋友Python。但是，即使语言不同，概念是相同的。</p><h2 id="b210" class="mg ld iq bd le mh mi dn li mj mk dp lm ko ml mm lo ks mn mo lq kw mp mq ls mr bi translated">进入AWS Lambda层…</h2><p id="abc8" class="pw-post-body-paragraph kf kg iq kh b ki mb jr kk kl mc ju kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">从最简单的意义上来说，<a class="ae lb" href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html" rel="noopener ugc nofollow" target="_blank"> Lambda层</a>是一段可以被不同服务共享的代码。通常，一个层将由大多数功能所需的重量级依赖项组成。在我们的例子中，我们将把我们的C依赖打包在一起，并使用层使它们对lambda函数可用。</p><h2 id="f10c" class="mg ld iq bd le mh mi dn li mj mk dp lm ko ml mm lo ks mn mo lq kw mp mq ls mr bi translated">TL；速度三角形定位法(dead reckoning)</h2><p id="c361" class="pw-post-body-paragraph kf kg iq kh b ki mb jr kk kl mc ju kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">包括lambda函数示例和安装说明的完整代码在我的GitHub库的<a class="ae lb" href="https://github.com/vedashree29296/neo4j-go-lambda-connector" rel="noopener ugc nofollow" target="_blank">中。</a></p><h2 id="31b6" class="mg ld iq bd le mh mi dn li mj mk dp lm ko ml mm lo ks mn mo lq kw mp mq ls mr bi translated">步骤1:打包C库</h2><p id="3310" class="pw-post-body-paragraph kf kg iq kh b ki mb jr kk kl mc ju kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">由于AWS经常使用基于<strong class="kh ir"> CentOS的</strong>容器来部署lambda函数，<strong class="kh ir"> Docker </strong>成为下载和编译C依赖项的明显选择。</p><p id="b4f2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用<strong class="kh ir">lambda-base</strong>映像作为基础映像创建一个定制的docker映像，并在其上安装我们所有的依赖项。</p><figure class="ms mt mu mv gt mw"><div class="bz fp l di"><div class="mx my l"/></div><p class="mz na gj gh gi nb nc bd b be z dk translated">安装海锚的文件</p></figure><p id="a900" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">基本映像已经安装并配置了OpenSSL。现在唯一需要的图书馆是Seabolt。</p><p id="e267" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Seabolt作为<strong class="kh ir">下载。tar包</strong>并提取到docker映像中的<strong class="kh ir"> /usr/local/lib64 </strong>目录。为了使它对Lambda函数可用，我们将内容移动到<strong class="kh ir"> /opt/lib </strong>目录，这是运行时链接期间搜索的目录之一。(这是在名为<strong class="kh ir"> LD_LIBRARY_PATH </strong>的环境变量中指定的)</p><p id="bb97" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦构建了映像，我们需要将<strong class="kh ir"> /opt/lib </strong>文件夹的内容转储到本地系统上的一个文件夹中，该文件夹稍后将被转换为一个层</p><figure class="ms mt mu mv gt mw"><div class="bz fp l di"><div class="mx my l"/></div><p class="mz na gj gh gi nb nc bd b be z dk translated">打包依赖项的脚本</p></figure><p id="d33a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">运行这个脚本将创建一个名为<strong class="kh ir">图层</strong>的目录，其中包含。所以在<strong class="kh ir">层/lib </strong>文件夹中的文件是针对Seabolt的。</p><h2 id="be1b" class="mg ld iq bd le mh mi dn li mj mk dp lm ko ml mm lo ks mn mo lq kw mp mq ls mr bi translated">步骤2:创建一个层</h2><p id="3e04" class="pw-post-body-paragraph kf kg iq kh b ki mb jr kk kl mc ju kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">现在，我们要做的就是创建一个层。有两种方法可以做到这一点。首先，我们使用AWS控制台或CLI创建一个层，并将层/目录的内容作为. zip文件上传。</p><p id="65f1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一种方法是使用<a class="ae lb" href="https://www.serverless.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir">无服务器框架</strong> </a>，它会为你做所有的工作。你所需要的只是一个文件调用<strong class="kh ir"> serverless.yml </strong>来指定你的层的细节。</p><figure class="ms mt mu mv gt mw"><div class="bz fp l di"><div class="mx my l"/></div><p class="mz na gj gh gi nb nc bd b be z dk translated">用于创建图层的serverlee.yml</p></figure><p id="c0fa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从您的工作目录中运行run <code class="fe nd ne nf ng b">serverless deploy</code>。</p><p id="82dc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你将为你新创建的层获得<strong class="kh ir"> ARN URL </strong>，你可以很容易地将它附加到你的lambda函数上。</p><h2 id="de27" class="mg ld iq bd le mh mi dn li mj mk dp lm ko ml mm lo ks mn mo lq kw mp mq ls mr bi translated">下一步:创建自己的Go处理函数</h2><p id="fd49" class="pw-post-body-paragraph kf kg iq kh b ki mb jr kk kl mc ju kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">一旦成功地创建了这个层，您就可以继续创建您的自定义处理函数来与Neo4J通信。</p><p id="7288" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">GitHub库包括一个示例处理函数，它在Neo4j中创建一个简单的节点，这个节点是使用无服务器框架部署的。关于如何使用Go和serverless创建Lambda函数的更多参考，这是一个<a class="ae lb" href="https://www.serverless.com/examples/aws-golang-http-get-post/" rel="noopener ugc nofollow" target="_blank">有用的链接，可以从</a>开始。</p></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><p id="74c3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>