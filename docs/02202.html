<html>
<head>
<title>Code in Java, Execute as C++.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java中的代码，作为C++执行。</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/code-in-java-execute-as-c-921f5db45f20?source=collection_archive---------22-----------------------#2020-03-02">https://towardsdatascience.com/code-in-java-execute-as-c-921f5db45f20?source=collection_archive---------22-----------------------#2020-03-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="06de" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何使用GraalVM原生映像从C++调用Java方法而不遭受大量的性能下降。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8916c54b3770a5e028edce0bb3ff5c7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Q7VZwq1M4y7SHz4K"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">马克西米利安·魏斯贝克尔在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="6ad1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Java和C++仍然是两种最流行的编程语言。这两种语言有不同的设计和特点。根据问题的不同，一个可能比另一个更好。然而，在某些时候，我们需要集成这些语言，例如调用用Java编写的方法到你的C++代码中。需要集成Java和C++并不是什么新鲜事。事实上，我们可以在<a class="ae kv" href="https://www.javaworld.com/article/2077513/java-tip-17--integrating-java-with-c--.html" rel="noopener ugc nofollow" target="_blank">找到一个可以追溯到1996年的教程</a>。从那以后，这两种语言有了显著的发展。</p><p id="b4e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本教程中，我们将学习如何使用GraalVM本机映像从C++调用java方法。如果这是你第一次听说GraalVM，你可能会有兴趣看看他们的<a class="ae kv" href="https://www.graalvm.org/" rel="noopener ugc nofollow" target="_blank">主页</a>。GraalVM是一个虚拟机，可以用来运行Java应用程序。它基于JVM，但是增加了额外的特性，比如提前编译、更少的内存占用和其他高级优化。此外，GraalVM提供了一个本机映像插件，您可以使用它将Java应用程序编译成本机应用程序。这意味着您的应用程序可以在不需要安装和运行JVM的情况下运行。有趣的是，您还可以使用这个原生图像插件将您的Java应用程序编译成一个共享库，并从您的C++代码中加载它。当你的代码主要是用C++写的，但是你想在它的某个部分使用一个现有的Java库时，这就非常方便了。</p><h1 id="e702" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">它是如何工作的</h1><p id="f797" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在深入教程之前，我们先来看看这个东西是如何工作的。基本上，你要做的如下:</p><ol class=""><li id="6c2d" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">用Java写你的方法。</li><li id="33a7" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">使用GraalVM将Java代码编译成C++共享库(yourlib.so)和头文件(yourlib.h)。</li><li id="54fc" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">将库和头文件加载到C++项目中。</li></ol><p id="fdbc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个例子中，我们将模拟一个用例，您想要在您的C++项目中使用来自第三方Java库的函数。特别是，我们有兴趣使用谷歌番石榴库<a class="ae kv" href="https://github.com/google/guava" rel="noopener ugc nofollow" target="_blank">中的一个数学函数。</a></p><h1 id="d32a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">准备Java项目</h1><p id="d542" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">首先，我们需要为我们的java方法建立一个maven项目。在maven中构建我们的项目有助于我们导入依赖项，并利用GraalVM原生映像插件来创建共享库。创建项目后，将依赖项添加到Guava库(或您需要的任何库)中，并将GraalVM库添加到pom.xml文件中:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="161e" class="ni lt iq ne b gy nj nk l nl nm">&lt;dependencies&gt;<br/>    &lt;!-- https://mvnrepository.com/artifact/org.graalvm.nativeimage/svm --&gt;<br/>    &lt;dependency&gt;<br/>        &lt;groupId&gt;org.graalvm.nativeimage&lt;/groupId&gt;<br/>        &lt;artifactId&gt;svm&lt;/artifactId&gt;<br/>        &lt;version&gt;19.3.1&lt;/version&gt;<br/>    &lt;/dependency&gt;<br/>    &lt;dependency&gt;<br/>        &lt;groupId&gt;com.google.guava&lt;/groupId&gt;<br/>        &lt;artifactId&gt;guava&lt;/artifactId&gt;<br/>        &lt;version&gt;28.2-jre&lt;/version&gt;<br/>    &lt;/dependency&gt;<br/>&lt;/dependencies&gt;</span></pre><p id="9484" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，添加以下插件，将java代码构建到C++共享库中:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="5ef7" class="ni lt iq ne b gy nj nk l nl nm">&lt;build&gt;<br/><strong class="ne ir">    &lt;finalName&gt;libmymath&lt;/finalName&gt;<br/></strong>    &lt;plugins&gt;<br/>        &lt;plugin&gt;<br/>            &lt;groupId&gt;com.oracle.substratevm&lt;/groupId&gt;<br/>            &lt;artifactId&gt;native-image-maven-plugin&lt;/artifactId&gt;<br/><strong class="ne ir">            &lt;version&gt;20.0.0&lt;/version&gt;<br/></strong>            &lt;executions&gt;<br/>                &lt;execution&gt;<br/>                    &lt;goals&gt;<br/>                        &lt;goal&gt;native-image&lt;/goal&gt;<br/>                    &lt;/goals&gt;<br/>                    &lt;phase&gt;package&lt;/phase&gt;<br/>                &lt;/execution&gt;<br/>            &lt;/executions&gt;<br/>            &lt;configuration&gt;<br/><strong class="ne ir">                &lt;buildArgs&gt;--shared -H:Name=libmymath&lt;/buildArgs&gt;<br/></strong>            &lt;/configuration&gt;<br/>        &lt;/plugin&gt;<br/>    &lt;/plugins&gt;<br/>&lt;/build&gt;</span></pre><p id="d3e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们来看看加粗的部分。在<em class="nn"> &lt; finalName &gt; </em>标签上，输入您想要的库名。记下您在<em class="nn"> &lt;版本&gt; </em>标签上指定的版本，因为您稍后会需要它。在<em class="nn"> &lt; buildArgs &gt;，</em>上，我们指定了<em class="nn"> shared </em>和<em class="nn"> name </em>参数来指示GraalVM本机映像创建一个共享库，而不是一个本机可执行文件。将与<em class="nn"> finalName </em>相同的名称放在<em class="nn"> Name </em>参数上。</p><p id="6f60" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们准备我们的Java方法。给定一个整数输入<em class="nn"> x </em>，我们感兴趣的是计算2的最大幂<em class="nn"> x </em>。例如，如果x是14，它将返回16，因为16是大于14的最接近2的幂。下面是我们函数的代码片段。注意，我们需要放置一个额外的第一个参数<em class="nn">类型的线程</em>isolate thread来桥接我们的Java和C++执行。该参数必须在第一个位置。我们还需要在<em class="nn">centry point</em>annotation<em class="nn">中指定方法的名称。这是我们将在C++代码<em class="nn">中引用的方法名。</em>你可以在<a class="ae kv" href="https://github.com/dpanugroho/graalvm-java-method-embedding" rel="noopener ugc nofollow" target="_blank">这个库</a>里查看完整的java项目。</em></p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="60f4" class="ni lt iq ne b gy nj nk l nl nm">import <strong class="ne ir">com.google.common.math.IntMath</strong>;<br/>import <strong class="ne ir">org.graalvm.nativeimage.IsolateThread</strong>;<br/>import <strong class="ne ir">org.graalvm.nativeimage.c.function.</strong>CEntryPoint;<br/><br/>public class <strong class="ne ir">MyMath </strong>{<br/>    @CEntryPoint (name = "ceilingPowerOfTwo")<br/>    public static int ceilingPowerOfTwo(<strong class="ne ir">IsolateThread </strong>thread, int x) {<br/>       return <strong class="ne ir">IntMath</strong>.<em class="nn">ceilingPowerOfTwo</em>(x);<br/>    }<br/>}</span></pre><h1 id="3f4e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">设置GraalVM</h1><p id="9433" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">设置好项目后，我们现在需要运行<em class="nn"> mvn包</em>来将我们的Java方法编译到一个共享库中。然而，由于该功能仅在GraalVM上可用，我们需要设置GraalVM并将JAVA_HOME指向GraalVM二进制文件。因此，您需要执行以下操作:</p><ol class=""><li id="319f" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated"><a class="ae kv" href="https://github.com/graalvm/graalvm-ce-builds/releases" rel="noopener ugc nofollow" target="_blank">下载GraalVM </a>。确保您选择了正确的架构、java版本以及您在<em class="nn"> pom.xml </em>中指定的GraalVM版本。具体来说，这个示例项目使用GraalVM 20.0.0 for Java 8。</li><li id="7069" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">使用gu二进制文件安装本机映像扩展。在Unix环境中，您可以使用:<br/><em class="nn">&lt;path _ to _ graalvm _ directory&gt;</em>graalvm-ce-Java 8–20 . 0 . 0 2<em class="nn">bin/gu install native-image</em></li><li id="41fe" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">更新JAVA_HOME以指向下载的GraalVM目录。在Unix环境下，可以使用export JAVA _ HOME =&lt;<em class="nn">path _ to _ graalvm _ directory/</em>graalvm-ce-JAVA 8–20 . 0 . 0 2/&gt;。</li></ol><h1 id="339d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">编译到共享库</h1><p id="a608" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">现在您可以调用<em class="nn"> mvn包</em> install来构建共享库。会生成几个文件:<em class="nn"> graal_isolate.h </em>、<em class="nn"> graal_isolate_dynamic.h </em>、<em class="nn"> libmymath.h </em>、<em class="nn"> libmymath_dynamic.h、libmymath.so </em>(或者其他OS中的其他格式)。除了我们自己的库，它还会生成Graal VM C++库。</p><h1 id="e523" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">将库导入到C++代码中</h1><p id="f31a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">现在让我们在下面的简单C++项目中使用我们的共享库。将生成的文件放在这个C++项目的目录中。例如，您可以创建一个<em class="nn"> include </em>文件夹，并将这些文件放在这个文件夹中。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="48fd" class="ni lt iq ne b gy nj nk l nl nm">#include &lt;iostream&gt;<br/>#include &lt;libmymath.h&gt;<br/><br/>int main() {<br/>    graal_isolate_t *isolate = NULL;<br/>    graal_isolatethread_t *thread = NULL;<br/><br/>    if (graal_create_isolate(NULL, &amp;isolate, &amp;thread) != 0) {<br/>        fprintf(stderr, "initialization error\n");<br/>        return 1;<br/>    }<br/><br/>    printf("Result&gt; %d\n",ceilingPowerOfTwo(thread, 14));<br/>    return 0;<br/>}</span></pre><p id="4dc1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用以下命令编译C++代码，并尝试运行它。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="68ff" class="ni lt iq ne b gy nj nk l nl nm"><em class="nn">g++ ceilingPowerOfTwoCpp.cpp -L includes/ -I includes/ -lmymath -o ceilingPowerOfTwoCpp</em></span></pre><p id="c879" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意:您可能需要使用以下命令将<em class="nn"> includes </em>目录设置为LD_LIBRARY_PATH:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="0aee" class="ni lt iq ne b gy nj nk l nl nm">export LD_LIBRARY_PATH=&lt;path_to_includes_directory&gt;</span></pre><h1 id="b452" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="5e63" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在编程语言同时发展的世界里，互操作性是一个不可避免的要求。GraalVM原生映像的共享库特性提供了一种将Java方法嵌入到C++程序的简单方法，这使得能够编写复杂的用户定义函数和使用第三方库。一个有希望的例子可能是开发一个以高性能和高级API为目标的数据处理框架。</p><p id="7b05" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想了解更多关于GraalVM的内容，请访问他们的主页。本教程的完整代码可以在<a class="ae kv" href="https://github.com/dpanugroho/graalvm-java-method-embedding" rel="noopener ugc nofollow" target="_blank">这个资源库</a>中找到。</p></div></div>    
</body>
</html>