<html>
<head>
<title>Iterators &amp; Iterables in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中的迭代器和可迭代对象</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/iterators-iterables-in-python-e713a55dfe1f?source=collection_archive---------22-----------------------#2020-04-01">https://towardsdatascience.com/iterators-iterables-in-python-e713a55dfe1f?source=collection_archive---------22-----------------------#2020-04-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2c3d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">迭代器和可迭代对象简介</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ce57a8ffe2e6d3af804bff2db864c211.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IANLvFQTg7lEn4LcAXfSYA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://www.pexels.com/photo/iphone-desk-laptop-notebook-7100/" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="f134" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我们将讨论 python 迭代器和可迭代对象。我们将回顾每个对象的定义，并努力理解每个对象背后的基本概念。</p><p id="d6ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们开始吧！</p><p id="5c09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> Iterables </strong>是 python 中能够一次返回一个元素的对象。此外，这些对象有一个名为“__iter__()”的双下划线(也称为<em class="lv"> dunder </em>)方法，其中“__iter__()”方法返回一个迭代器(稍后将详细介绍)。列表就是 iterable 的一个例子。为了帮助我们理解列表作为可迭代对象意味着什么，让我们定义一个列表。让我们根据<a class="ae ky" href="https://www.rollingstone.com/music/music-lists/500-greatest-albums-of-all-time-156826/the-beatles-rubber-soul-53553/" rel="noopener ugc nofollow" target="_blank"> <em class="lv">滚石</em> </a> <em class="lv"> : </em>来定义一个包含有史以来最好的五张专辑的列表</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="7942" class="mb mc it lx b gy md me l mf mg">best_albums = ["Sgt. Pepper’s Lonely Hearts Club Band", "Pet Sounds", "Revolver", "Highway 61 Revisited",  "Rubber Soul"]</span></pre><p id="83f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们对 iterables 定义的第一部分指出，它们允许我们一个接一个地返回它们的元素。让我们通过循环我们的列表来演示这一点:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="8477" class="mb mc it lx b gy md me l mf mg">for album in best_albums:<br/>    print(album)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/1e4cb0bd74767059ed820c525484f475.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*80RoAXjj32qe2LYGkA_LcA.png"/></div></figure><p id="ba1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">iterables 的这个特性非常明显。我们还指定了“__iter__()”方法，该方法也将 python 对象限定为可迭代对象。我们可以使用内置的“dir()”方法检查对象可用的方法和属性:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="44b6" class="mb mc it lx b gy md me l mf mg">print(dir(best_albums))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mi"><img src="../Images/f84d63442bb74bee66b256e8e7733962.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0m2EHxmUHzybTFALBzmwWw.png"/></div></div></figure><p id="8db6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到“__iter__()”方法出现在对象的方法和属性列表中。一般来说，任何带有“__iter__()”方法的对象都可以循环。</p><p id="5640" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，当我们在 iterables 上使用 for 循环时，我们调用“__iter__()”方法。当调用“__iter__()”方法时，它返回一个迭代器。</p><p id="90c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们定义迭代器。</p><p id="9c34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">迭代器</strong>是有状态的对象，其中状态指定迭代期间的当前值。迭代器还有一个名为“__next__()”的 dunder 方法，允许我们访问后续值。如果我们查看列表的属性和方法，我们可以看到没有' __next__()'，这意味着列表不是迭代器。</p><p id="baca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过尝试使用列表中的“下一个”方法来证明这一点:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="2167" class="mb mc it lx b gy md me l mf mg">print(next(best_albums))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/e577334d457b84a5ea04026b08407971.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*DLD1BG4TeUE-PfK4tA-ayA.png"/></div></figure><p id="ab85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们得到一个错误，告诉我们列表对象不是迭代器。因为我们知道列表对象是可迭代的，这意味着它们有“__iter__()”方法，所以我们可以在列表上调用“__iter__()”来返回一个迭代器:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="0933" class="mb mc it lx b gy md me l mf mg">iter_best_albums = best_albums.__iter__()</span></pre><p id="b8b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">定义迭代器的一种更简洁的等效方法如下:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="3114" class="mb mc it lx b gy md me l mf mg">iter_best_albums = iter(best_albums)</span></pre><p id="b3ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们打印我们的迭代器:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="5e1c" class="mb mc it lx b gy md me l mf mg">print(iter_best_albums)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/ab19b95baf87964bde4b1eda5219352c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*VLNi__LLhO2Vx5nLYBByzA.png"/></div></figure><p id="95a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到我们的对象确实是一个迭代器。现在，让我们打印迭代器对象的属性和方法:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="598b" class="mb mc it lx b gy md me l mf mg">print(dir(iter_best_albums))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ml"><img src="../Images/1751d599df2138a928bec69ef5a509d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hSrpnoQYeMfSGhqN7SPnVQ.png"/></div></div></figure><p id="75ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到我们的迭代器对象有“__next__()”方法。让我们在迭代器上调用这个方法:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="11a7" class="mb mc it lx b gy md me l mf mg">print(next(iter_best_albums))<br/>print(next(iter_best_albums))<br/>print(next(iter_best_albums))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/bdeeba94d57d9a26f9157fdd27a42638.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*gQUobgEziaYRgN5ZUWTgIQ.png"/></div></figure><p id="daed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到，每次我们调用“next”时，我们的对象会记住它停止的地方,“next”方法会指向后续的值。让我们看看如果我们调用' next '直到用完所有值会发生什么。我们再打 6 次电话:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="9c2a" class="mb mc it lx b gy md me l mf mg">print(next(iter_best_albums))<br/>print(next(iter_best_albums))<br/>print(next(iter_best_albums))<br/>print(next(iter_best_albums))<br/>print(next(iter_best_albums))<br/>print(next(iter_best_albums))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/68ae4459a781d44481ceb9ec8230ea3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/1*CAOfu_OmciuCD9oqz68_Vg.png"/></div></figure><p id="a4b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以用“StopIteration”异常来处理此错误:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="f276" class="mb mc it lx b gy md me l mf mg">while True:<br/>    try:<br/>        element = next(iter_best_albums)<br/>        print(element)<br/>    except(StopIteration):<br/>        break</span></pre><p id="1954" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们得到的结果和之前循环链表得到的结果是一样的。当我们用 for 循环遍历列表时，这就是本质上发生的事情。</p><p id="a4ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我就讲到这里，但是您可以自己随意摆弄代码。如果你有兴趣学习更多关于迭代器和可迭代对象的知识，科里·斯查费的 YouTube 教程是一个很好的资源。</p><h2 id="839a" class="mb mc it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">结论</h2><p id="ea9c" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">总之，在这篇文章中，我们讨论了 python 中的迭代和迭代器。Iterables 是具有方法“__iter__()”的对象，该方法返回迭代器对象。迭代器是具有方法' __next()__ '的对象，该方法允许我们访问后续值。此外，迭代器有关于迭代过程中状态的信息。简而言之，迭代器是 python 中每个 for 循环背后发生的事情。我希望你觉得这有用/有趣。这篇文章的代码可以在<a class="ae ky" href="https://github.com/spierre91/medium_code/tree/master/basic_python" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。感谢您的阅读！</p></div></div>    
</body>
</html>