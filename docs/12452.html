<html>
<head>
<title>K-means clustering using Spotify song features</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Spotify 歌曲特征的 K-means 聚类</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/k-means-clustering-using-spotify-song-features-9eb7d53d105c?source=collection_archive---------16-----------------------#2020-08-27">https://towardsdatascience.com/k-means-clustering-using-spotify-song-features-9eb7d53d105c?source=collection_archive---------16-----------------------#2020-08-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b1e3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><em class="ki">使用高维数据聚类自动创建播放列表</em></h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/fc54920ec3f9a23e781caefd8dd310ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TLgok3XDsYDq34aMZHkxHw.jpeg"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">由<a class="ae kz" href="https://unsplash.com/@maltewingen?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">马尔特·温根</a>在<a class="ae kz" href="https://unsplash.com/s/photos/music?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="ae18" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">spotify API 允许我们创建一个简单的服务器端应用程序，从 spotify 应用程序中访问用户相关数据。它还可以让你获得应用程序上没有的信息，如艺术家受欢迎程度、歌曲指标、专辑封面图片等。它允许你创建、删除和修改用户帐户中的现有播放列表。</p><blockquote class="lw lx ly"><p id="ff76" class="la lb lz lc b ld le ju lf lg lh jx li ma lk ll lm mb lo lp lq mc ls lt lu lv im bi translated">这个项目的目标是使用聚类算法将一个大的播放列表分解成更小的播放列表。为此，使用了歌曲度量标准，如“可跳性”、“效价”、“速度”、“活跃度”、“语速”。</p></blockquote><h2 id="f1ce" class="md me it bd mf mg mh dn mi mj mk dp ml lj mm mn mo ln mp mq mr lr ms mt mu mv bi translated">在这篇文章中，你会发现:</h2><ul class=""><li id="ce34" class="mw mx it lc b ld my lg mz lj na ln nb lr nc lv nd ne nf ng bi translated">使用 Spotify API 收集数据</li><li id="ea2d" class="mw mx it lc b ld nh lg ni lj nj ln nk lr nl lv nd ne nf ng bi translated">寻找理想的集群数量</li><li id="5ba1" class="mw mx it lc b ld nh lg ni lj nj ln nk lr nl lv nd ne nf ng bi translated">肘方法和轮廓分析</li><li id="fdd6" class="mw mx it lc b ld nh lg ni lj nj ln nk lr nl lv nd ne nf ng bi translated">特征选择</li><li id="2533" class="mw mx it lc b ld nh lg ni lj nj ln nk lr nl lv nd ne nf ng bi translated">聚类算法</li><li id="1661" class="mw mx it lc b ld nh lg ni lj nj ln nk lr nl lv nd ne nf ng bi translated">播放列表创建和性能分析</li></ul></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><p id="4413" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果您还不是会员，请在此获得您的中级会员资格<a class="ae kz" href="https://medium.com/@alejandra.vlerick/membership" rel="noopener">！</a></p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h1 id="c61d" class="nt me it bd mf nu nv nw mi nx ny nz ml jz oa ka mo kc ob kd mr kf oc kg mu od bi translated">数据收集</h1><pre class="kk kl km kn gt oe of og oh aw oi bi"><span id="498d" class="md me it of b gy oj ok l ol om">import spotipy<br/>from spotipy.oauth2 import SpotifyOAuth<br/>from spotipy.oauth2 import SpotifyClientCredentials</span></pre><p id="30ea" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">连接 spotify API 非常简单，内容也有很好的文档记录。这个<a class="ae kz" href="https://spotipy.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">链接</a>将为您提供连接所需的所有信息，而<a class="ae kz" href="https://developer.spotify.com/documentation/web-api/" rel="noopener ugc nofollow" target="_blank">这个</a>将为您提供 python 示例代码。</p><p id="3058" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">前往<a class="ae kz" href="https://developer.spotify.com/dashboard/" rel="noopener ugc nofollow" target="_blank">https://developer.spotify.com/dashboard/</a>，点击<strong class="lc iu">创建客户端 ID </strong>或<strong class="lc iu">创建 App </strong>，获取您的“<em class="lz">客户端 ID </em>”和“<em class="lz">客户端密码</em>”。之后，重定向 URI 必须被更改到你在 Spotify 应用程序的设置中决定的任何页面。</p><pre class="kk kl km kn gt oe of og oh aw oi bi"><span id="18c2" class="md me it of b gy oj ok l ol om">scope = "user-library-read playlist-modify-private"<br/>OAuth = SpotifyOAuth(<br/>        scope=scope,         <br/>        redirect_uri='http://localhost:8888/callback',<br/>        client_id = 'client_id',<br/>        client_secret = 'client_secret',<br/>        username= 'username')</span></pre><p id="0c5b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">变量“sp”将作为 spotify 数据的访问键，并允许我们使用所有功能来获取和发布 Spotify 的请求。</p><pre class="kk kl km kn gt oe of og oh aw oi bi"><span id="beb4" class="md me it of b gy oj ok l ol om">sp = spotipy.Spotify(auth_manager=OAuth)</span></pre><h1 id="16c3" class="nt me it bd mf nu on nw mi nx oo nz ml jz op ka mo kc oq kd mr kf or kg mu od bi translated">保存的曲目数据收集</h1><p id="0913" class="pw-post-body-paragraph la lb it lc b ld my ju lf lg mz jx li lj os ll lm ln ot lp lq lr ou lt lu lv im bi translated">下一步是从我的“<strong class="lc iu"> <em class="lz">喜欢的歌曲</em> </strong>”播放列表中收集数据。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi ov"><img src="../Images/b6446656633e6e2378a7d7416f6ec033.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RRG569SRZVvGxpZwpmQMVA.png"/></div></div></figure><p id="0a59" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">API 一次只能提取 50 首歌曲，因此我们运行一个 while 循环，以 50 首为一组遍历整个播放列表。用来访问我个人喜欢的歌曲的函数是<strong class="lc iu"><em class="lz">current _ user _ saved _ tracks()。</em> </strong></p><pre class="kk kl km kn gt oe of og oh aw oi bi"><span id="6e26" class="md me it of b gy oj ok l ol om">offset = 0<strong class="of iu"><br/></strong>songs = []<br/>items = []<br/>ids = []<br/>while True:<br/>    content = sp.current_user_saved_tracks(limit=<strong class="of iu">50, </strong>offset=offset)<br/>    songs += content['items']<br/>    if content['next'] is not None:<br/>        offset += <strong class="of iu">100<br/>    </strong>else:<br/>        break</span></pre><p id="3c4c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">下面的步骤是使用<strong class="lc iu"> <em class="lz"> audio_features() </em> </strong>函数提取每首歌曲的音频特征:</p><pre class="kk kl km kn gt oe of og oh aw oi bi"><span id="59e3" class="md me it of b gy oj ok l ol om">for i in songs:<br/>   ids.append(i['track']['id'])</span><span id="c404" class="md me it of b gy ow ok l ol om">while index &lt; len(ids):<br/>    audio_features += sp.audio_features(ids[index:index + 50])<br/>    index += 50</span><span id="b868" class="md me it of b gy ow ok l ol om">features_list = []<br/>for features in audio_features:<br/>    features_list.append([features['energy']<strong class="of iu">, </strong>features['liveness']<strong class="of iu">,<br/>                          </strong>features['tempo']<strong class="of iu">,</strong>features['speechiness']<strong class="of iu">,<br/>                          ...<br/>                          </strong>features['mode']<strong class="of iu">, </strong>features['type']<strong class="of iu">,<br/>                          </strong>features['uri']])<br/><br/>df = pd.DataFrame(features_list<strong class="of iu">, </strong>columns=['energy'<strong class="of iu">, </strong>'liveness'<strong class="of iu">,<br/>                                          </strong>'tempo'<strong class="of iu">, </strong>'speechiness'<strong class="of iu">,<br/>                                          </strong>...<strong class="of iu"> <br/>                                          </strong>'mode'<strong class="of iu">, </strong>'type'<strong class="of iu">,</strong>'uri'])</span></pre><p id="47b3" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">结果是一个 pandas 数据帧，它收集了行上的歌曲和列上它们各自的特征。每首歌曲都由它唯一的<strong class="lc iu"> <em class="lz"> uri </em> </strong>来标识。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi ox"><img src="../Images/b93c2b1b9c17dacd76faa272a9524a1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hyiKvcN1hb6eh63msqqGEw.png"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">数据框的右侧</p></figure><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi oy"><img src="../Images/88320d4f6651ee16e3834e48e7105814.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MBRRZMCPvSdYFg6mrFuZPg.png"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">数据框的左侧</p></figure><p id="8a8c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">只是为了好玩，我决定查看播放列表中所有歌曲的特征值分布情况:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi oz"><img src="../Images/4980d8b05ba7601ad654e5c3edd7dd0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DwruOh6kdOlvvQUxgwBTFg.png"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">歌曲特征(标准化后):</p></figure><p id="3436" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我很快得出结论，这些指标之间没有很强的相关性。歌曲并没有根据它们的类型遵循固定的模式。当尝试基于所有 12 个特征执行聚类时，结果并不理想…为此，我决定使用较少数量的指标，并测试所有可能产生最佳聚类的特征组合。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi pa"><img src="../Images/1a0e24104c0efc7c3ee7ad092be38468.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_d_sXlnz_aOeL-iqK8NXfQ.png"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">不同指标之间没有真正的相关性…</p></figure><h1 id="93cd" class="nt me it bd mf nu on nw mi nx oo nz ml jz op ka mo kc oq kd mr kf or kg mu od bi translated">寻找理想的集群数量</h1><p id="a0f4" class="pw-post-body-paragraph la lb it lc b ld my ju lf lg mz jx li lj os ll lm ln ot lp lq lr ou lt lu lv im bi translated">在对所有 12 个特征尝试聚类算法之前，我决定精选几个特征进行聚类，希望它能产生更好的聚类质量。</p><p id="062a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">第一步是归一化所有的值，使它们位于[0；1].</p><pre class="kk kl km kn gt oe of og oh aw oi bi"><span id="479a" class="md me it of b gy oj ok l ol om">from sklearn import preprocessing</span><span id="76a7" class="md me it of b gy ow ok l ol om">x = df.values <br/>min_max_scaler = preprocessing.MinMaxScaler()<br/>x_scaled = min_max_scaler.fit_transform(x)<br/>df = pd.DataFrame(x_scaled)</span></pre><p id="c81e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">接下来的步骤是基于一些特征的选择找到一个聚类质量度量。我做的第一件事是创建一个包含所有歌曲指标的列表，然后使用<strong class="lc iu"> permutations() </strong>函数创建一组当时使用三个歌曲特征的所有可能组合。</p><pre class="kk kl km kn gt oe of og oh aw oi bi"><span id="5d64" class="md me it of b gy oj ok l ol om">columns = ["energy"<strong class="of iu">,  </strong>"speechiness"<strong class="of iu">, </strong>"acousticness"<strong class="of iu">, </strong>"instrumentalness"<strong class="of iu">, </strong>"loudness"<strong class="of iu">,</strong>"tempo"<strong class="of iu">,</strong>"danceability"<strong class="of iu">,</strong>'valence' <strong class="of iu">, </strong>"liveness", "time_signature", "key"]<br/><br/>perm = permutations(columns<strong class="of iu">, 3</strong>)<br/>output = set(map(lambda x: tuple(sorted(x))<strong class="of iu">,</strong>perm))</span></pre><p id="27b3" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">对于每个排列，我使用<strong class="lc iu">肘方法计算了一个聚类分数。</strong></p><blockquote class="lw lx ly"><p id="1fe1" class="la lb lz lc b ld le ju lf lg lh jx li ma lk ll lm mb lo lp lq mc ls lt lu lv im bi translated"><strong class="lc iu">肘法</strong> <em class="it">是一种启发式方法，用于确定数据集中的聚类数。</em> <strong class="lc iu"> <em class="it">方法</em> </strong> <em class="it">包括绘制所解释的变异作为聚类数的函数，并拾取曲线的</em> <strong class="lc iu"> <em class="it">【肘形】</em> </strong> <em class="it">作为聚类数来使用。</em></p></blockquote><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi pb"><img src="../Images/a94fec27d55b566d587ae384052854e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0djLU_z0ogQTsZvo5LyItQ.png"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">x 轴为肘值，y 轴为分数。每条线对应不同的排列。</p></figure><p id="5c15" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">对于每个排列，我提取了一个肘分数和一个肘值。<strong class="lc iu">分数</strong>告诉我该排列的聚类有多好，<strong class="lc iu">肘值</strong>告诉我该排列的理想聚类数。</p><pre class="kk kl km kn gt oe of og oh aw oi bi"><span id="5c96" class="md me it of b gy oj ok l ol om">model = KMeans(random_state=<strong class="of iu">0</strong>)<br/>visualizer = KElbowVisualizer(model<strong class="of iu">, </strong>k=(<strong class="of iu">2,12</strong>)<strong class="of iu">, </strong>metric='silhouette'<strong class="of iu">, </strong>timings=False)<br/>visualizer.fit(x_scaled)<br/>score = visualizer.elbow_score_<br/>value = visualizer.elbow_value_</span></pre><p id="a11a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">结果是一个熊猫数据帧的特征排列和他们相应的理想数量的集群和质量评分这些集群。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi pc"><img src="../Images/3454966143e837fd7f0788e774be67f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JIuNQostk6AIby7CyBNnww.png"/></div></div></figure><p id="23e1" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">一旦计算出每个排列的分数，我决定选择大于 0.4 的排列，并将它们保存在一个单独的数据框中。</p><pre class="kk kl km kn gt oe of og oh aw oi bi"><span id="1215" class="md me it of b gy oj ok l ol om">if score&gt;<strong class="of iu">0.4</strong>:<br/>    idx = df.columns<br/>    mylist = idx.tolist()<br/>    dict = {<br/>        "features": mylist<strong class="of iu">,<br/>        </strong>"score": score<strong class="of iu">,<br/>        </strong>"elbow": value<br/>    }<br/>    df2 = df2.append(dict<strong class="of iu">, </strong>ignore_index=True)</span></pre><h1 id="4a71" class="nt me it bd mf nu on nw mi nx oo nz ml jz op ka mo kc oq kd mr kf or kg mu od bi translated">集群和播放列表创建</h1><p id="6ad9" class="pw-post-body-paragraph la lb it lc b ld my ju lf lg mz jx li lj os ll lm ln ot lp lq lr ou lt lu lv im bi translated">有许多排列产生了很好的结果，得分甚至超过 0.5。</p><p id="97c2" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">排列<strong class="lc iu">[‘工具性’，‘语音性’，‘化合价’]</strong>建议创建 4 个集群，得分为 0.504。这是我在创建播放列表时选择的一个。</p><p id="f934" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我缩放了一个只包含这三个指标的数据帧，然后使用<strong class="lc iu"> KMeans() </strong>函数执行了聚类。</p><pre class="kk kl km kn gt oe of og oh aw oi bi"><span id="ebed" class="md me it of b gy oj ok l ol om">from sklearn.cluster import KMeans</span><span id="89b2" class="md me it of b gy ow ok l ol om">kmeans = KMeans(init="k-means++"<strong class="of iu">,<br/>                </strong>n_clusters=<strong class="of iu">4,<br/>                </strong>random_state=<strong class="of iu">15,<br/>                </strong>max_iter = <strong class="of iu">500</strong>).fit(x_scaled)<br/>df1['kmeans'] = kmeans.labels_<br/>df1.columns = ['energy'<strong class="of iu">, </strong>'instrumentalness'<strong class="of iu">, </strong>'loudness'<strong class="of iu">,</strong>'kmeans' ]</span></pre><p id="9913" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">结果是数据帧包含每行一首歌曲，标签[0，1，2，3]对应于特定歌曲被分配到的每个簇。<strong class="lc iu">特征分布清楚地表明，能量和响度在所有集群中分布不同。</strong></p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi pd"><img src="../Images/9952a38955bbea196f2ca09fb447074c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ncTzcx9oYNbu-uXgIbnX1g.png"/></div></div></figure><p id="5412" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">3D 散点图给出了不同的视角，显示了较高的乐器度值被分类到相同的群中，而能量和响度区分了其余三个群。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi pe"><img src="../Images/d1a25573fadd33016a51984a34db2188.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IB6ozDb6vGiInZuIx7MkKQ.png"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">聚类的三维散点图</p></figure><h1 id="051c" class="nt me it bd mf nu on nw mi nx oo nz ml jz op ka mo kc oq kd mr kf or kg mu od bi translated">非常感谢你的阅读！</h1><p id="d9c3" class="pw-post-body-paragraph la lb it lc b ld my ju lf lg mz jx li lj os ll lm ln ot lp lq lr ou lt lu lv im bi translated">更多类似的文章，请点击在 Medium <a class="ae kz" href="https://towardsdatascience.com/medium.com/@alejandra.vlerick" rel="noopener" target="_blank">上找到我！</a></p><p id="e3a6" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果您有任何关于如何改进的<strong class="lc iu">问题</strong>、<strong class="lc iu">建议</strong>或<strong class="lc iu">想法</strong>，请在下面留下评论或通过 LinkedIn <a class="ae kz" href="https://www.linkedin.com/in/alejandra-g-283595b8" rel="noopener ugc nofollow" target="_blank">这里</a>取得联系。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/b9e69c51ca7e3ad1b00168b67c9c0a51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wlSofLFSYGTiFKMv0ektRA.jpeg"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://unsplash.com/@wilhelmgunkel?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">威廉·冈克尔</a>在<a class="ae kz" href="https://unsplash.com/s/photos/thank-you?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="fb97" class="nt me it bd mf nu on nw mi nx oo nz ml jz op ka mo kc oq kd mr kf or kg mu od bi translated">Github 知识库</h1><p id="c890" class="pw-post-body-paragraph la lb it lc b ld my ju lf lg mz jx li lj os ll lm ln ot lp lq lr ou lt lu lv im bi translated">所有的代码都可以在 Github <a class="ae kz" href="https://github.com/alejandra-gutierrez/SpotifyAPI" rel="noopener ugc nofollow" target="_blank">这里</a>找到。排列脚本可以在<em class="lz"> analysis_v2.py </em>中找到，聚类可以在<em class="lz"> feature_analysis.py </em>中找到。</p></div></div>    
</body>
</html>