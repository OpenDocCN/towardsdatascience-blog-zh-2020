<html>
<head>
<title>Data Classes in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中的数据类</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/data-classes-in-python-8d1a09c1294b?source=collection_archive---------4-----------------------#2020-05-27">https://towardsdatascience.com/data-classes-in-python-8d1a09c1294b?source=collection_archive---------4-----------------------#2020-05-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/1b88a76b205acf4e2b7d8fbab93d0221.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ygY3KuGOgmu5rU3ijQNRxg.jpeg"/></div></div></figure><p id="189b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">数据类适用于 Python 3.7 或更高版本。您可以将数据类用作数据容器，但不仅限于此。数据类还为您编写模板代码，并简化创建类的过程，因为它附带了一些免费实现的方法。让我们开始吧！</p><h1 id="f854" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">你的第一个数据类</h1><p id="1ad6" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">让我们创建一个数据类，它表示 3d 坐标系中的一个点。</p><p id="e73e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mc md me mf b">@dataclass</code> decorator 用于创建一个数据类。<code class="fe mc md me mf b">x</code>、<code class="fe mc md me mf b">y</code>和<code class="fe mc md me mf b">z</code>是我们数据类中的字段。请注意，您需要使用类型注释来指定字段的数据类型，并且记住类型注释不是静态类型声明，这意味着某人仍然可以为<code class="fe mc md me mf b">x</code>、<code class="fe mc md me mf b">y</code>或<code class="fe mc md me mf b">z</code>字段传递除<code class="fe mc md me mf b">int</code>之外的任何数据类型。</p><figure class="mg mh mi mj gt ju"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="439f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">默认情况下，数据类带有实现的<code class="fe mc md me mf b">__init__</code>、<code class="fe mc md me mf b">__repr__</code>和<code class="fe mc md me mf b">__eq__</code>方法，因此您不必自己实现这些方法。</p><p id="5f95" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而<code class="fe mc md me mf b">__init__</code>、<code class="fe mc md me mf b">__repr__</code>和<code class="fe mc md me mf b">__eq__</code>没有在我的<code class="fe mc md me mf b">Coordinate</code>类中实现，由于数据类，我仍然可以使用这些方法。这对节省时间很有好处。</p><figure class="mg mh mi mj gt ju"><div class="bz fp l di"><div class="mk ml l"/></div></figure><h1 id="3e84" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">字段的默认值</h1><p id="ad85" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">您可以为字段分配默认值。让我们把重点放在例子上。正如您在<code class="fe mc md me mf b">pi</code>字段中看到的，您可以为数据类中的字段分配一个默认值。</p><figure class="mg mh mi mj gt ju"><div class="bz fp l di"><div class="mk ml l"/></div></figure><h1 id="d3a2" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">自定义字段和数据类</h1><p id="da64" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">您可以通过使用 dataclass decorator 或 field 函数的参数来自定义字段和数据类。当我在例子中定制任何东西的时候，我会解释，我也会在文章的最后给出字段和数据类的所有参数。</p><h1 id="6b5d" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">数据类是可变的还是不可变的？</h1><p id="ccbe" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">默认情况下，数据类是可变的，这意味着您可以为字段赋值。但是，您仍然可以通过将<code class="fe mc md me mf b">frozen</code>参数设置为<code class="fe mc md me mf b">True</code>来使其不可变</p><p id="1c90" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">易变的例子</strong></p><figure class="mg mh mi mj gt ju"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="ffc2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">不可变的例子</strong></p><p id="b5dc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我们将<code class="fe mc md me mf b">frozen</code>设置为<code class="fe mc md me mf b">True</code>时，我们不能再给字段赋值了。您可以在下面的示例中看到异常输出。</p><figure class="mg mh mi mj gt ju"><div class="bz fp l di"><div class="mk ml l"/></div></figure><h1 id="1d5e" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">比较数据类</h1><p id="9675" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">假设您想要创建一个表示一个<code class="fe mc md me mf b">Vector</code>的数据类，并且您想要比较它们。你会怎么做？为此，你需要像<code class="fe mc md me mf b">__lt__</code>或<code class="fe mc md me mf b">__gt__</code>这样的方法来比较它们。</p><p id="799e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">默认情况下，数据类的<code class="fe mc md me mf b">order</code>参数为<code class="fe mc md me mf b">False</code>。当你设置为<code class="fe mc md me mf b">True</code>时；<code class="fe mc md me mf b">__lt__</code>、<code class="fe mc md me mf b">__le__</code>、<code class="fe mc md me mf b">__gt__</code>和<code class="fe mc md me mf b">__ge__</code>方法将自动为您的数据类生成。所以你可以比较对象，就好像它们是字段<strong class="kd iu">的元组一样。</strong></p><p id="6bf2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们来看看下面的例子。我们可以比较<code class="fe mc md me mf b">v2</code>和<code class="fe mc md me mf b">v1</code>，因为我们将<code class="fe mc md me mf b">order</code>设置为<code class="fe mc md me mf b">True</code>。但是这里有一个比较逻辑的问题。当你说<code class="fe mc md me mf b">v2 &gt; v1</code>时，它会像<code class="fe mc md me mf b">(8, 15) &gt; (7, 20)</code>一样比较这两个向量。所以<code class="fe mc md me mf b">v2 &gt; v1</code>的输出会是<code class="fe mc md me mf b">True</code>。</p><blockquote class="mm mn mo"><p id="4fa6" class="kb kc mp kd b ke kf kg kh ki kj kk kl mq kn ko kp mr kr ks kt ms kv kw kx ky im bi translated">回想一下，元组比较是逐个位置进行的。它首先将<code class="fe mc md me mf b">8</code>与<code class="fe mc md me mf b">7</code>进行比较，其结果为<code class="fe mc md me mf b">True</code>，然后比较结果为<code class="fe mc md me mf b">True</code>。如果它们相等，那么它将比较<code class="fe mc md me mf b">15</code> &gt; <code class="fe mc md me mf b">20</code>，然后结果将是<code class="fe mc md me mf b">False</code>。</p></blockquote><figure class="mg mh mi mj gt ju"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="49b9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">回想了一下元组是怎么比较的，很明显这个比较没有任何意义。我想用向量的大小来比较它们。这里的问题是，当创建每个实例时，你不想自己计算一个<code class="fe mc md me mf b">Vector</code>的大小。</p><p id="418c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这种情况下，我们将受益于<code class="fe mc md me mf b">field</code>函数和<code class="fe mc md me mf b">__post_init__</code>方法。<code class="fe mc md me mf b">field</code>功能将帮助我们自定义<code class="fe mc md me mf b">magnitude</code>字段。<code class="fe mc md me mf b">__post_init__</code>方法将帮助我们确定初始化后向量的大小。</p><p id="4839" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们通过使用来自数据类的<code class="fe mc md me mf b">field</code>函数来定制<code class="fe mc md me mf b">magnitude</code>字段。通过将<code class="fe mc md me mf b">init</code>设置为<code class="fe mc md me mf b"><em class="mp">False</em></code>，我们基本上是说我们不想要<code class="fe mc md me mf b">__init__</code>方法中的<code class="fe mc md me mf b">magnitude</code>参数。因为我们希望在初始化后使用<code class="fe mc md me mf b">__post_init__</code>方法来确定它的值</p><figure class="mg mh mi mj gt ju"><div class="bz fp l di"><div class="mk ml l"/></div></figure><h1 id="3bc7" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">将其转换为字典或元组</h1><p id="3f4f" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">你可以在一个元组或字典中得到你的数据类的属性。您所需要的就是从数据类中导入<code class="fe mc md me mf b">asdict</code>和<code class="fe mc md me mf b">astuple</code>函数。</p><figure class="mg mh mi mj gt ju"><div class="bz fp l di"><div class="mk ml l"/></div></figure><h1 id="aa12" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">遗产</h1><p id="8639" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">可以像 Python 中的普通类一样对数据类进行子类化。</p><figure class="mg mh mi mj gt ju"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="3dda" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用继承时有一个常见的错误。当默认设置<code class="fe mc md me mf b">lang</code>字段为<code class="fe mc md me mf b">Python</code>时，必须为<code class="fe mc md me mf b">lang</code>字段之后的字段提供默认值。</p><figure class="mg mh mi mj gt ju"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="c923" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要了解原因，让我们看看我们的<code class="fe mc md me mf b">__init__</code>方法是什么样子的。回想一下，有默认值的参数应该在没有默认值的参数之后。</p><figure class="mg mh mi mj gt ju"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="4ba8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们通过为<code class="fe mc md me mf b">salary</code>字段提供默认值来修复它。</p><figure class="mg mh mi mj gt ju"><div class="bz fp l di"><div class="mk ml l"/></div></figure><h1 id="abf0" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">从老虎机中获益</h1><p id="1f8d" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">默认情况下，属性存储在字典中。我们可以从插槽中获得更快的属性访问，并使用更少的内存。请注意，我不会详细讨论插槽，因为这是另一个要讨论的主题。</p><figure class="mg mh mi mj gt ju"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="07da" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以使用插槽来使用更少的内存和更快地访问属性。</p><figure class="mg mh mi mj gt ju"><div class="bz fp l di"><div class="mk ml l"/></div></figure><h1 id="6b8b" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">数据类参数</h1><p id="0bec" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">我们已经更改了 dataclass decorator 中的一些参数来定制我们的数据类。让我给你一个参数列表。</p><ul class=""><li id="8696" class="mt mu it kd b ke kf ki kj km mv kq mw ku mx ky my mz na nb bi translated"><code class="fe mc md me mf b">init</code> : <code class="fe mc md me mf b">__init__</code>方法将在您的数据类中生成，如果<code class="fe mc md me mf b">True</code>。(默认为<code class="fe mc md me mf b">True</code>)</li><li id="dbc6" class="mt mu it kd b ke nc ki nd km ne kq nf ku ng ky my mz na nb bi translated"><code class="fe mc md me mf b">repr</code> : <code class="fe mc md me mf b">__repr__</code>方法将在您的数据类中生成，如果<code class="fe mc md me mf b">True</code>。(默认为<code class="fe mc md me mf b">True</code>)</li><li id="dbb4" class="mt mu it kd b ke nc ki nd km ne kq nf ku ng ky my mz na nb bi translated"><code class="fe mc md me mf b">eq</code> : <code class="fe mc md me mf b">__eq__</code>方法将在您的数据类中生成，如果<code class="fe mc md me mf b">True</code>。(默认为<code class="fe mc md me mf b">True</code>)</li><li id="e4c0" class="mt mu it kd b ke nc ki nd km ne kq nf ku ng ky my mz na nb bi translated"><code class="fe mc md me mf b">order</code> : <code class="fe mc md me mf b">__lt__</code>、<code class="fe mc md me mf b">__le__</code>、<code class="fe mc md me mf b">__gt__</code>和<code class="fe mc md me mf b">__ge__</code>方法将在您的数据类中生成，如果<code class="fe mc md me mf b">True</code>。(默认为<code class="fe mc md me mf b">False</code>)</li><li id="ca4e" class="mt mu it kd b ke nc ki nd km ne kq nf ku ng ky my mz na nb bi translated"><code class="fe mc md me mf b">unsafe_hash</code> : <code class="fe mc md me mf b">__hash__</code>方法将在您的数据类中生成，如果<code class="fe mc md me mf b">True</code>。(默认为<code class="fe mc md me mf b">False</code>)</li><li id="7333" class="mt mu it kd b ke nc ki nd km ne kq nf ku ng ky my mz na nb bi translated"><code class="fe mc md me mf b">frozen</code>:如果<code class="fe mc md me mf b">True</code>，则不能分配给字段。(默认为<code class="fe mc md me mf b">False</code>。)</li></ul><p id="4bbf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请注意，如果<code class="fe mc md me mf b">order</code>为<code class="fe mc md me mf b">True</code>，则<code class="fe mc md me mf b">eq</code>必须为<code class="fe mc md me mf b">True</code>，否则<code class="fe mc md me mf b">ValueError</code>将引发异常。</p><h1 id="e2b3" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">字段参数</h1><ul class=""><li id="a38f" class="mt mu it kd b ke lx ki ly km nh kq ni ku nj ky my mz na nb bi translated"><code class="fe mc md me mf b">init</code>:如果<code class="fe mc md me mf b">True</code>，该字段包含在生成的<code class="fe mc md me mf b">__init__</code>方法中。(默认为<code class="fe mc md me mf b">True</code>)</li><li id="a6d1" class="mt mu it kd b ke nc ki nd km ne kq nf ku ng ky my mz na nb bi translated"><code class="fe mc md me mf b">repr</code>:如果<code class="fe mc md me mf b">True</code>，该字段包含在生成的<code class="fe mc md me mf b">__repr__</code>方法中。(默认为<code class="fe mc md me mf b">True</code>)</li><li id="ef9d" class="mt mu it kd b ke nc ki nd km ne kq nf ku ng ky my mz na nb bi translated"><code class="fe mc md me mf b">compare</code>:如果<code class="fe mc md me mf b">True</code>，该字段包含在生成的比较和相等方法中。(默认为<code class="fe mc md me mf b">True</code>)</li><li id="8ef1" class="mt mu it kd b ke nc ki nd km ne kq nf ku ng ky my mz na nb bi translated"><code class="fe mc md me mf b">hash</code>:如果<code class="fe mc md me mf b">True</code>，该字段包含在生成的<code class="fe mc md me mf b">__hash__</code>方法中。(默认为<code class="fe mc md me mf b">None</code>)</li><li id="eee4" class="mt mu it kd b ke nc ki nd km ne kq nf ku ng ky my mz na nb bi translated"><code class="fe mc md me mf b">default</code>:如果提供，这将是该字段的默认值。</li><li id="bc17" class="mt mu it kd b ke nc ki nd km ne kq nf ku ng ky my mz na nb bi translated"><code class="fe mc md me mf b">default_factory</code>:如果提供，这必须是一个零参数的可调用函数，当该字段需要默认值时，将调用该函数。</li><li id="3dbe" class="mt mu it kd b ke nc ki nd km ne kq nf ku ng ky my mz na nb bi translated"><code class="fe mc md me mf b">metadata</code>:这可以是一个映射，也可以是一个空字典。</li></ul><h1 id="78ce" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">结论</h1><p id="3b2e" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">这是对数据类的温和介绍。我希望你喜欢它。感谢您的阅读，别忘了在 Medium 上关注我！</p></div></div>    
</body>
</html>