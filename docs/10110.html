<html>
<head>
<title>Confidential Machine Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">机密机器学习</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/confidential-machine-learning-f45efb0dc2fc?source=collection_archive---------44-----------------------#2020-07-16">https://towardsdatascience.com/confidential-machine-learning-f45efb0dc2fc?source=collection_archive---------44-----------------------#2020-07-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6276" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在培训之前、期间和之后保密</h2></div><p id="fceb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">机密机器学习- <em class="lb"> ConfML - </em>是数据所有者在与 ML 服务共享训练数据时遵循的协议。该协议在训练过程中保持训练数据的机密性。</p><p id="d493" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">静态数据和传输中数据的机密性可以通过加密来确保。数据在训练开始之前就被解密，并且在训练过程结束之前一直是易受攻击的。ConfML 解决了这个漏洞:它确保了训练过程中训练数据的机密性。</p><p id="550b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">ConfML 协议由两个步骤组成，这两个步骤结束了培训过程:</p><ol class=""><li id="1dae" class="lc ld iq kh b ki kj kl km ko le ks lf kw lg la lh li lj lk bi translated">数据所有者在将训练数据文件发送到 ML 服务之前，使用秘密密钥对它们进行加扰。秘密密钥不与 ML 服务共享。</li><li id="8498" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated">在从 ML 服务接收到<em class="lb">网络训练加扰数据</em>后，数据所有者使用步骤 1 的秘密密钥将该网络转换成一个行为相同的网络，就好像它是在原始的未加扰数据上训练的一样。</li></ol><p id="246d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这两个步骤确保 ML 服务永远看不到原始数据，而数据所有者获得他们想要的网络。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi lq"><img src="../Images/6dc18be51f2217f2a55f6505046deaec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m6isD2HN8ZrH_NYO9JgWMw.png"/></div></div><p class="mc md gj gh gi me mf bd b be z dk translated">机密机器学习(图片由作者提供)</p></figure><h2 id="f5bd" class="mg mh iq bd mi mj mk dn ml mm mn dp mo ko mp mq mr ks ms mt mu kw mv mw mx my bi translated">scramble_files.py</h2><p id="c686" class="pw-post-body-paragraph kf kg iq kh b ki mz jr kk kl na ju kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">数据所有者可以使用类似于以下程序的东西来扰乱将用于训练完全连接的前馈深度神经网络的特征和标签文件。</p><p id="8af7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该程序使用密钥对特征和标签 CSV 文件中列的<em class="lb">顺序进行加密。这种列顺序的混乱使得入侵者很难理解数据，但对训练质量几乎没有影响。</em></p><pre class="lr ls lt lu gt ne nf ng nh aw ni bi"><span id="0d40" class="mg mh iq nf b gy nj nk l nl nm">#scramble_files.py</span><span id="5545" class="mg mh iq nf b gy nn nk l nl nm">import random<br/>import pandas</span><span id="03c9" class="mg mh iq nf b gy nn nk l nl nm">def bld_scram_idx(lst_len, key_secret):  #random list based on a key<br/>   my_seed = int(''.join(list(map(str, map(ord, key_secret)))))<br/>   random.seed(my_seed * lst_len)<br/>   scram_idx = list(range(lst_len))<br/>   random.shuffle(scram_idx)<br/>   <em class="lb">return</em> scram_idx</span><span id="54b6" class="mg mh iq nf b gy nn nk l nl nm">def scram_list(lst, scram_idx):  #scramble a list of integers<br/>    scram_lst = [0] * len(lst)<br/>    <em class="lb">for</em> i, item <em class="lb">in</em> enumerate(lst):<br/>        scram_lst[i] = scram_idx.index(item)<br/>    <em class="lb">return</em> scram_lst</span><span id="0ef4" class="mg mh iq nf b gy nn nk l nl nm">def scram_df(df, scram_idx):  #scramble a dataframe<br/>    cols_idx = list(range(len(df.columns)))<br/>    cols_idx_scram = scram_list(cols_idx, scram_idx)<br/>    <em class="lb">return </em>df.reindex(labels = cols_idx_scram, axis='columns')</span><span id="94af" class="mg mh iq nf b gy nn nk l nl nm">def read_csv_file_write_scram_version(csv_fname, key_secret):<br/>    df_csv = pandas.read_csv(csv_fname, header=None)<br/>    scram_idx = bld_scram_idx(len(df_csv.columns), key_secret)<br/>    df_csv = scram_df(df_csv, scram_idx)<br/>    csv_scram_fname = csv_fname.split('.csv')[0] + '_scrambled.csv'<br/>    df_csv.to_csv(csv_scram_fname, header=None, index=None)<br/>    print(csv_scram_fname + ' file written to disk')</span><span id="4d35" class="mg mh iq nf b gy nn nk l nl nm">KEY_SECRET, FT_CSV_FNAME, LB_CSV_FNAME = "", "", ""  #insert values<br/>read_csv_file_write_scram_version(FT_CSV_FNAME, KEY_SECRET)<br/>read_csv_file_write_scram_version(LB_CSV_FNAME, KEY_SECRET)</span></pre><h2 id="dd26" class="mg mh iq bd mi mj mk dn ml mm mn dp mo ko mp mq mr ks ms mt mu kw mv mw mx my bi translated">解读 _net.py</h2><p id="595b" class="pw-post-body-paragraph kf kg iq kh b ki mz jr kk kl na ju kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">数据所有者使用该程序，结合用于对训练数据文件进行加扰的密钥，将<em class="lb">网络训练加扰数据</em>转换成一个网络，该网络的行为就好像是对原始数据进行训练一样。</p><p id="c193" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种转换的结果将是网络在原始数据上具有与<em class="lb">网络训练加扰数据的</em>在加扰数据上相同的精度。</p><p id="7555" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个程序的细节根据网络如何用代码实现而有所不同。然而，主要思想是根据<code class="fe no np nq nf b">scramble_files.py</code>程序中建立的加扰指数恢复网络输入和输出的顺序。</p></div></div>    
</body>
</html>