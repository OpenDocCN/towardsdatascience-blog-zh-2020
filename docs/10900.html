<html>
<head>
<title>Improving Plotly’s Polar Bar Charts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">改进 Plotly 的极坐标条形图</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/improving-plotlys-polar-bar-charts-43f6eec867b7?source=collection_archive---------33-----------------------#2020-07-29">https://towardsdatascience.com/improving-plotlys-polar-bar-charts-43f6eec867b7?source=collection_archive---------33-----------------------#2020-07-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8184" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">超越默认设置，创建漂亮且可复制的图表</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f38edb1eeefde644cf4faab960b558ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kSw-njRsFwVlqbTElIX8oQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@ikukevk?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">凯文·Ku</a>在<a class="ae ky" href="https://unsplash.com/s/photos/python-code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="a3df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想将更多的注意力吸引到具有更高值的类别上，极坐标条形图是显示分类信息的好方法。它们在《华尔街日报》关于亚马逊 HQ2 候选名单的文章中发挥了巨大作用。但是，即使有了强大的可视化工具，制作这样的图表也需要一些跑腿的工作。</p><p id="af7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天我在这里向你们提供将<a class="ae ky" href="https://plotly.com/python/polar-chart/#polar-bar-chart" rel="noopener ugc nofollow" target="_blank"> Plotly 的极坐标条形图</a>转化为视觉上可接受的东西所需的几何图形。到最后，你可以把这些烦人的内务代码扔进一个函数里，再也不去想它了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/65ce5d7831451640448a79b575748af0.png" data-original-src="https://miro.medium.com/v2/resize:fit:602/format:webp/1*rm0Bz66-_aastaXIZLAP_A.png"/></div></figure><p id="e89c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是 Plotly 的教程代码产生的情节。</p><p id="aab3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然我知道他们在演示如何用更少的代码行创建 Matplotlib 徽标，但是这个例子对于实际应用程序并没有什么用处。</p><p id="69e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面，我将以一种可重现的方式解决我在这个例子中遇到的主要问题。这些问题是:</p><ul class=""><li id="9c57" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">图和背景的切片在数量上是不同的，并且没有对齐。</li><li id="0ab0" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">图切片之间的间隙不一致。</li><li id="1e0f" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">从例子看不清楚怎么做传奇。</li></ul><p id="c86c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像往常一样，您可以跳到最后查看完整的代码片段。</p><h2 id="b9c7" class="mk ml it bd mm mn mo dn mp mq mr dp ms li mt mu mv lm mw mx my lq mz na nb nc bi translated">切片对齐又称角度窗格条</h2><p id="aea2" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">让我们从框定我们的问题开始。我们有一组值，我们希望将每个值映射到一个圆形切片的半径。也许我们也有每个值的标签。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="1102" class="mk ml it nj b gy nn no l np nq">vals = [3, 2, 5, 1, 2]<br/>labels = ["Strength", "Intelligence", "Dexterity", "Wisdom", "Stealth"]</span></pre><p id="8f9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仅从这些值，我们想要确定切片和背景的定位和对齐。</p><p id="6ce5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个切片的半径、位置和宽度分别由<a class="ae ky" href="https://plotly.github.io/plotly.py-docs/generated/plotly.graph_objects.Barpolar.html" rel="noopener ugc nofollow" target="_blank"> Plotly barpolar </a>函数的<code class="fe nr ns nt nj b">r</code>、<code class="fe nr ns nt nj b">theta</code>和<code class="fe nr ns nt nj b">width</code>参数决定。注意<code class="fe nr ns nt nj b">theta</code>对应每个切片的<em class="nu">中心</em>的角度。</p><p id="5cd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们希望切片之间没有间隔，并且宽度相等，我们可以从原始值的长度推断出这些参数。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="da1b" class="mk ml it nj b gy nn no l np nq">num_slices = len(vals)<br/>theta = [(i + 1.5) * 360 / num_slices for i in range(num_slices)]<br/>width = [360 / num_slices for _ in range(num_slices)]</span></pre><p id="2a1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里“+ 1.5”将确保我们的第一个切片的右边缘在零度。</p><p id="9340" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我喜欢做的另一件事是通过调色板(如粉彩)为我的切片产生一个颜色序列:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="ac72" class="mk ml it nj b gy nn no l np nq">color_seq = px.colors.qualitative.Pastel<br/>color_indices = range(0, len(color_seq), len(color_seq) // num_slices)<br/>colors = [color_seq[i] for i in color_indices]</span></pre><p id="45d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看我们的进展:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="d4d5" class="mk ml it nj b gy nn no l np nq">fig = go.Figure(go.Barpolar(r=vals, theta=theta, width=width, marker_color=colors))<br/>fig.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/4f2845849937b18d0773f66a79d8fd97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DKmLB7YNzAmbOv3ONmSNew.png"/></div></div></figure><p id="8e8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">越来越好了！如您所见，切片从零度开始，间隔均匀。但是背景还是完全不对齐。</p><h2 id="224d" class="mk ml it bd mm mn mo dn mp mq mr dp ms li mt mu mv lm mw mx my lq mz na nb nc bi translated">角窗格条第 2 部分:背景对齐</h2><p id="2bd1" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">对齐背景就是调整图形的<code class="fe nr ns nt nj b">polar_angularaxis_tickvals</code>布局选项。我们将推断角度的顺序，类似于我们对切片所做的那样。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="202b" class="mk ml it nj b gy nn no l np nq">angular_tickvals = [(i + 1) * 360 / num_slices for i in range(num_slices)]<br/>fig.update_layout(polar_angularaxis_tickvals=angular_tickvals)</span><span id="ef50" class="mk ml it nj b gy nw no l np nq">fig.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/4ebbfe086b72222dda2fe0f7b95fc1b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*okJp4jHhS_2a4kK7EMs3Ag.png"/></div></div></figure><p id="d1fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很好，现在背景和切片对齐了。你可以用<code class="fe nr ns nt nj b">update_layout</code>调整更多的选项，让剧情更有美感。最后我会给你们留下一些。</p><h2 id="dae7" class="mk ml it bd mm mn mo dn mp mq mr dp ms li mt mu mv lm mw mx my lq mz na nb nc bi translated">痕迹和传说带来的麻烦</h2><p id="09d5" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">现在，如何添加将标签与每个切片相关联的图例？如果你只是使用<code class="fe nr ns nt nj b">name</code>参数，你会遇到一个问题:Plotly 将我们所有的切片视为一个单独的<em class="nu">轨迹</em>，它只能与一个单独的名字相关联。</p><p id="f6ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们如何将每个单独的切片与其自己的名称关联起来？</p><p id="d4ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这并不理想，但目前我发现为每个切片制作一个单独的条形图是最好的方法。我希望存在一种更好的方法，或者至少一种方法将很快被开发出来。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="58d6" class="mk ml it nj b gy nn no l np nq">barpolar_plots = [go.Barpolar(r=[r], theta=[t], width=[w], name=n, marker_color=[c])<br/>for r, t, w, n, c in zip(vals, theta, width, labels, colors)]</span><span id="a598" class="mk ml it nj b gy nw no l np nq">fig = go.Figure(barpolar_plots)</span><span id="a701" class="mk ml it nj b gy nw no l np nq">angular_tickvals = [(i + 1) * 360 / num_slices for i in range(num_slices)]<br/>fig.update_layout(polar_angularaxis_tickvals=angular_tickvals)</span><span id="5b2f" class="mk ml it nj b gy nw no l np nq">fig.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/57076c81d2ae334bd51d6f4416b3fec1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EWR5XiBrF2aT91F7QN92-A.png"/></div></div></figure><h2 id="34e2" class="mk ml it bd mm mn mo dn mp mq mr dp ms li mt mu mv lm mw mx my lq mz na nb nc bi translated">将所有东西打包在一起</h2><p id="82bc" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">因为我们只是从原始值中推断出所有的角度参数，所以将所有的工作打包到一个函数中是有意义的。我已经用一些额外的布局选项演示了它的用法。您可以在<a class="ae ky" href="https://plotly.com/python/reference/" rel="noopener ugc nofollow" target="_blank"> Plotly 图参考</a>中找到更多信息。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/f1e56d4c5f08494d2fe6a33102761f33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uv2iGhfOAoQ1MdKD1cbEwQ.png"/></div></div></figure></div><div class="ab cl nz oa hx ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="im in io ip iq"><p id="624e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目前，从 Plotly 的教程极坐标条形图到一些可用的东西需要一点工作。特别是，需要一些角度格来对齐切片和背景。此外，添加图例并没有想象中那么简单。</p><p id="8b09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我已经完成了进行这种调整所需的步骤，并将它们打包到一个可重用的函数中。希望对你有帮助。</p></div></div>    
</body>
</html>