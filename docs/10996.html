<html>
<head>
<title>Financial Signal Processing — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">金融信号处理—第一部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/financial-signal-processing-part-1-69c20fd5ad6d?source=collection_archive---------7-----------------------#2020-07-31">https://towardsdatascience.com/financial-signal-processing-part-1-69c20fd5ad6d?source=collection_archive---------7-----------------------#2020-07-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="de55" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为统计分析和机器学习处理财务数据</h2></div><p id="d7e3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">算法交易很难。你不能只是把一打技术分析信号塞进一个神经网络，就指望下个月成为百万富翁。这是因为处理财务数据都是关于细节的。抛开初学者可能犯的所有潜在偏见和错误，大多数金融机器学习和算法交易项目都失败了，因为他们忽略了金融环境中的微妙假设。</p><p id="d24a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为此，今天我将回顾并讨论金融信号处理的基本原理。我将研究金融数据的各种属性，何时以及如何以特定的方式处理它们，以及如何通过机器学习技术来分析它们。</p><p id="8503" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">(<a class="ae le" href="https://www.yaoleixu.com/quant-finance" rel="noopener ugc nofollow" target="_blank">你可以在这里找到完整的代码和其他资源</a></p><h1 id="8996" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">1.对平稳性的需求</h1><blockquote class="lx ly lz"><p id="813d" class="ki kj ma kk b kl km ju kn ko kp jx kq mb ks kt ku mc kw kx ky md la lb lc ld im bi translated">大多数机器学习技术都假设数据是平稳的。然而，在金融中很少发现平稳性，这会导致几个问题。</p></blockquote><p id="0f28" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在深入研究金融信号之前，提到平稳性的概念很重要，因为它是大多数现代机器学习技术背后的基本假设。</p><h2 id="b55d" class="me lg it bd lh mf mg dn ll mh mi dp lp kr mj mk lr kv ml mm lt kz mn mo lv mp bi translated">1.1.什么是平稳性</h2><p id="ffdd" class="pw-post-body-paragraph ki kj it kk b kl mq ju kn ko mr jx kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">抛开严格的数学定义，平稳性意味着基础信号的统计数据(例如均值和方差)在一段时间内是恒定的。</p><p id="a75e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，考虑涉及猫和狗的分类的最大似然问题，其中动物的潜在生物学不会每天都发生巨大的变化。生物特征的平稳性允许 ML 模型挑选将随时间保持真实的模式，这允许模型在样本外很好地概括。</p><h2 id="a6cd" class="me lg it bd lh mf mg dn ll mh mi dp lp kr mj mk lr kv ml mm lt kz mn mo lv mp bi translated">1.1.金融中的平稳性和潜在问题</h2><p id="05b5" class="pw-post-body-paragraph ki kj it kk b kl mq ju kn ko mr jx kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">然而，在金融领域，稳定性是一个大问题。例如，考虑下图中苹果的价格信号。不需要严格的统计测试就能看出平均价格不会随着时间的推移而保持不变。</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi mv"><img src="../Images/9c5ab5cc3f53b579b63eff53cac2dd04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1AhiWH95JXltkybYHCwQsg.png"/></div></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">作者图片</p></figure><p id="160d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">考虑一个具有上述数据的训练-测试拆分框架，其中 2019 年之前的价格信号用于训练，其余用于测试。如果有人天真地将价格范围从[100，400]扩大到[0，1]，就会导致<strong class="kk iu"> <em class="ma">前瞻偏差</em> </strong>(测试集信息泄露给训练集)。这将导致不切实际的更好的性能，因为 ML 模型通过缩放隐含地知道将来的最高价格。</p><p id="6e79" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">直觉上，如果你在 2019 年实施这种 ML 模型，你不可能知道 AAPL 的价格在 2020 年最终会达到 400 英镑左右(如果你知道，你首先就不需要 ML)。</p><p id="7fb6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们使用训练集来调整价格范围会怎么样？将价格范围从[100，250]缩放到[0，1]将不会导致前瞻偏差，但是测试集中所有大于 250 的价格都将被缩放到大于 1。这对于需要特征在某个比例范围内的 ML 模型来说尤其成问题，例如神经网络。</p><p id="961d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">更好的解决方案是通过对数差分来处理上述信号，如下所述。</p><h1 id="93fe" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">2.对数差分和对数回归</h1><blockquote class="lx ly lz"><p id="0d11" class="ki kj ma kk b kl km ju kn ko kp jx kq mb ks kt ku mc kw kx ky md la lb lc ld im bi translated">对价格数据进行差分可以生成适用于机器学习技术的平稳信号，这通常比原始价格信号更好。</p></blockquote><h2 id="3bf3" class="me lg it bd lh mf mg dn ll mh mi dp lp kr mj mk lr kv ml mm lt kz mn mo lv mp bi translated">2.1.日志返回的属性</h2><p id="a403" class="pw-post-body-paragraph ki kj it kk b kl mq ju kn ko mr jx kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">对数差分计算在时间<strong class="kk iu"> <em class="ma"> t-1 </em> </strong>和<strong class="kk iu"> <em class="ma"> t </em> </strong>的对数值之间的差值，这通常也称为对数回归，如下所示。</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nl"><img src="../Images/f618499342d825c9fab6063ed3b66772.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kHFhaawFT9kPwZSqdBZh2w.png"/></div></div></figure><p id="d248" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过对数收益处理的价格信号有许多优点:(1)它使原始信号变得平稳，如下图所示。通过简单的观察，我们可以看到新信号有一个大约为 0 的恒定平均值，以及一个更恒定的方差。(2)对数收益比价格数据更趋于正态分布，这对于依赖于正态假设的经典统计模型来说是很好的。(3)对数回归是时间累加的，这允许我们通过简单的加法计算回测(参见<a class="ae le" rel="noopener" target="_blank" href="/backtest-trading-strategies-with-pandas-vectorized-backtesting-26001b0ba3a5">文章，此处</a>有更详细的解释)。</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi mv"><img src="../Images/50011da54a29f972f37a25f297779c1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rHTBlAWPPPmb77-ZYtpJ7A.png"/></div></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">作者图片</p></figure><h2 id="7614" class="me lg it bd lh mf mg dn ll mh mi dp lp kr mj mk lr kv ml mm lt kz mn mo lv mp bi translated"><strong class="ak"> 2.2。何时不使用日志返回</strong></h2><p id="2a5e" class="pw-post-body-paragraph ki kj it kk b kl mq ju kn ko mr jx kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">log-return 的主要缺点是它删除了存储部分，这破坏了定价信息。在大多数应用程序中，这通常不是问题。例如，投资组合优化、动量策略、均值回归策略等方面的大量量化金融文献。依靠多少资产价格一起变化。因此，对数收益的比较比价格的比较更有意义。</p><p id="b707" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，对于大宗商品期货等其他金融工具，确切的价格可能会对依赖这些大宗商品的行业产生现实影响。因此，在这种情况下，定价信息可能比对数收益更有意义。</p><p id="3130" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，在对数收益的计算中可能有一些额外的微妙之处，可以通过基于体积的采样和分数差分进行调整。这些技术将在以后的文章中讨论。</p><h1 id="0b29" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">3.处理日志-返回</h1><blockquote class="lx ly lz"><p id="96ae" class="ki kj ma kk b kl km ju kn ko kp jx kq mb ks kt ku mc kw kx ky md la lb lc ld im bi translated">R <!-- -->对数收益的滚动统计可以通过机器学习方法进行处理，从而提供市场洞察力。</p></blockquote><h2 id="e428" class="me lg it bd lh mf mg dn ll mh mi dp lp kr mj mk lr kv ml mm lt kz mn mo lv mp bi translated">3.1.滚动统计</h2><p id="70b0" class="pw-post-body-paragraph ki kj it kk b kl mq ju kn ko mr jx kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">如前所述，对数收益往往遵循更好的分布。对于短期窗口，通常需要分析与该分布相关的不同统计数据，如均值、标准差、偏斜度和峰度，这些数据也趋于稳定。</p><p id="2b16" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在 Python 中，这些可以通过 pandas 中的滚动函数轻松计算:</p><pre class="mw mx my mz gt nm nn no np aw nq bi"><span id="161e" class="me lg it nn b gy nr ns l nt nu">w = 22 # number of trading days in a month</span><span id="d94a" class="me lg it nn b gy nv ns l nt nu">s1 = rs.rolling(w).mean() # moving average<br/>s2 = rs.rolling(w).std() # moving standard deviation<br/>s3 = rs.rolling(w).skew() # moving skewness<br/>s4 = rs.rolling(w).kurt() # moving kurtosis</span><span id="4878" class="me lg it nn b gy nv ns l nt nu">signals = pd.concat([s1, s2, s3, s4], axis=1)<br/>signals.columns = ['mean', 'std dev', 'skew', 'kurtosis']<br/>signals.plot(subplots=True, figsize=(10,7), legend=True);</span></pre><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nw"><img src="../Images/51735b5e0b6b4e03a14caace7c34112e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fv74iGFupqlXrEoNNu5erw.png"/></div></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">作者图片</p></figure><p id="7452" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">特别是，标准差的滚动计算在分析<em class="ma">市场波动</em>时非常有用。</p><h2 id="9319" class="me lg it bd lh mf mg dn ll mh mi dp lp kr mj mk lr kv ml mm lt kz mn mo lv mp bi translated">3.1.波动性和市场机制</h2><p id="2b9d" class="pw-post-body-paragraph ki kj it kk b kl mq ju kn ko mr jx kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">波动性在金融机器学习中有着特殊的作用。直观地说，波动性衡量市场中存在多少不确定性/运动/混乱。此外，它还可用于衡量市场中存在的“风险”量(尽管存在其他/更好的风险定义，如“敞口”)。</p><p id="62be" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">波动性的概念也与市场机制的概念紧密相连，市场机制可以用来识别不同的市场条件。例如，我们可以对 SP500 在不同时间的波动水平运行聚类算法:</p><pre class="mw mx my mz gt nm nn no np aw nq bi"><span id="75e9" class="me lg it nn b gy nr ns l nt nu">from sklearn.mixture import GaussianMixture</span><span id="1678" class="me lg it nn b gy nv ns l nt nu">w = 22<br/>vol = rs.rolling(w).std()<br/>vol = vol.dropna()</span><span id="b34c" class="me lg it nn b gy nv ns l nt nu">labels = GaussianMixture(2).fit_predict(vol.values.reshape(-1,1))</span><span id="b149" class="me lg it nn b gy nv ns l nt nu">prices = prices.reindex(vol.index)<br/>prices[labels==0].plot(style='bo', alpha=0.2)<br/>prices[labels==1].plot(style='ro', alpha=0.2)<br/>plt.title('Volatility Regimes SPY')</span></pre><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nw"><img src="../Images/01e8eb19daddc9ed043ca2a57896ef33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oHMYMVsZtaT6AAk7A5IaJA.png"/></div></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">作者图片</p></figure><p id="705d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过在观察到的波动水平上拟合高斯混合，ML 模型自动推断出看涨和看跌的市场机制。这是直观的，因为市场抛售往往是由恐慌性抛售决定驱动的，这可能导致大幅下跌，加剧市场混乱，导致更高的波动性。相比之下，牛市的特点是价值稳定增长，导致波动性降低。</p><p id="1279" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">识别市场机制对于金融机器学习尤其重要，因为在牛市中训练的模型不太可能在熊市中表现良好，反之亦然。</p></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><p id="0731" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="ma">来自《走向数据科学》编辑的提示:</em> </strong> <em class="ma">虽然我们允许独立作者根据我们的</em> <a class="ae le" rel="noopener" target="_blank" href="/questions-96667b06af5"> <em class="ma">规则和指导方针</em> </a> <em class="ma">发表文章，但我们不认可每个作者的贡献。你不应该在没有寻求专业建议的情况下依赖一个作者的作品。详见我们的</em> <a class="ae le" rel="noopener" target="_blank" href="/readers-terms-b5d780a700a4"> <em class="ma">读者术语</em> </a> <em class="ma">。</em></p><p id="68d0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我希望你喜欢这篇文章！如果你想看更多这样的内容，请关注我。</p><p id="a115" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，查看我的网站的完整代码和其他资源。</p></div></div>    
</body>
</html>