<html>
<head>
<title>Shallow &amp; Deep Copies — Stop Making These Common Slicing Mistakes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">浅层和深层拷贝——停止犯这些常见的切片错误</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/shallow-deep-copies-stop-making-these-slicing-mistakes-12d02ffa2f7f?source=collection_archive---------29-----------------------#2020-08-02">https://towardsdatascience.com/shallow-deep-copies-stop-making-these-slicing-mistakes-12d02ffa2f7f?source=collection_archive---------29-----------------------#2020-08-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/d3349875bedd69a5c711875c695571b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HX65UArr1gD-RMP_.jpg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">来源:<a class="ae jg" href="https://pixabay.com/photos/sea-water-holidays-blue-background-2755908/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><div class=""/><div class=""><h2 id="bf54" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">正确管理你的记忆</h2></div><p id="b6b9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当编写高效的代码和正确管理有限的内存时，浅副本和深副本是理解的基础。不知道浅副本和深副本上的操作也会导致切片和其他操作中的一些严重错误。幸运的是，它们是很容易理解的概念！</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><p id="62e6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">考虑一个 NumPy 数组。我可以选择两个路径，一个是浅拷贝(也称为视图，原因您很快就会看到)或深拷贝。</p><ul class=""><li id="1211" class="mf mg jj la b lb lc le lf lh mh ll mi lp mj lt mk ml mm mn bi translated">浅层复制:<code class="fe mb mc md me b">x_view = x_list.view()</code></li><li id="b08c" class="mf mg jj la b lb mo le mp lh mq ll mr lp ms lt mk ml mm mn bi translated">深度复制:<code class="fe mb mc md me b">x_copy = x_list.copy()</code></li></ul><p id="e660" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这两个副本有什么不同？</p><p id="ecde" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">浅层拷贝实际上并不拷贝每个元素的值。相反，它们<em class="mt">引用<code class="fe mb mc md me b">x_list</code>中每个值的存储位置</em>。这意味着他们实际上是这样存储数据的:<code class="fe mb mc md me b">np.array([first element in x_list, second element in x_list, …])</code>。因此，这些类型的拷贝依赖于原始阵列。因为浅拷贝本质上是与原始数据相同的数组，但是以不同的名称记录，所以它们可以被认为是原始数据的“视图”。</p><p id="af84" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一方面，深度副本复制每个值，并在内存中分配新的空间。不是存储值的存储位置，而是记录物理元素:<code class="fe mb mc md me b">np.array([1,2,3,4,5])</code>。深层副本独立于原始数组，使用它们会占用更多的存储空间。</p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mu"><img src="../Images/6d9597b9ed8592af3fc97d9fe1247b60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CjpbN8aeTknduPptFiE3Mw.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">objx =存储在内存中的对象</p></figure><p id="943f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">把浅层复制想象成用两根吸管喝同一种饮料(数据)(访问机制)，而深层复制则是点同一种饮料，并分别从那种饮料中喝。在浅层复制中，如果两个饮酒者中的一个把吸管吐到饮料中，另一个的饮料(和食欲)也会改变。然而，在深度复制中，一个饮酒者不愉快的习惯不会影响到另一个人的饮料，两个人都可以随意改变他们的饮料，而不会影响到另一个人。</p><p id="7252" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">列表也是如此。假设我做了一个改动:<code class="fe mb mc md me b">x_list[0] = 10</code>，把<code class="fe mb mc md me b">x_list</code>的第一个元素，也就是原来的数组，设置为等于 10。</p><ul class=""><li id="e37b" class="mf mg jj la b lb lc le lf lh mh ll mi lp mj lt mk ml mm mn bi translated"><code class="fe mb mc md me b">x_view</code>(浅抄):<code class="fe mb mc md me b">array([10, 2, 3, 4, 5])</code></li><li id="d60f" class="mf mg jj la b lb mo le mp lh mq ll mr lp ms lt mk ml mm mn bi translated"><code class="fe mb mc md me b">x_copy</code>(深度复制):<code class="fe mb mc md me b">array([1, 2, 3, 4, 5])</code></li></ul><p id="5bf5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">只有浅层副本受到影响，因为它是与原始(<code class="fe mb mc md me b">x_list</code>)完全相同的数组，只是名称不同。</p><p id="06b8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这就引出了一个问题:如果浅拷贝附加在原始列表上，为什么还会有人使用它呢？</p><p id="d317" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">答案在于许多人所说的复制列表的最有效的方法——使用<code class="fe mb mc md me b">x_list[:]</code>,它是一个“空片”,或者是一个没有边界的片，因此复制整个列表。所有切片，像<code class="fe mb mc md me b">x_list[1:4]</code>和空切片，都是浅拷贝。这有道理；切片操作只是获取现有列表的一部分，因此创建深度副本和复制现有值是低效的。</p><p id="a90c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">切片只是一个关于如何显示原始列表中的数据的命令。如果我使用<code class="fe mb mc md me b">x_slice = x_list[1:4]</code>并使用<code class="fe mb mc md me b">x_slice</code>，程序简单地引用回<code class="fe mb mc md me b">x_list</code>并从中提取值(即第一个到第三个索引)。浅层拷贝存在于复杂操作的每个方面，有助于提高内存存储的效率。</p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mz"><img src="../Images/af2638ddafb8871410e6a747841ff1de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iIN3q4m7Z4reKB22pYhn9g.png"/></div></div></figure><p id="3aeb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为许多人没有意识到切片是一种浅拷贝操作，他们没有意识到像<code class="fe mb mc md me b">x_slice[0]=10</code>这样的东西会把原来的切片列表变成<code class="fe mb mc md me b">array([ 1, 10, 3, 4, 5])</code>。这是因为从第一个索引开始的切片的第 0 个索引是原始数组中的第一个索引。</p><p id="e498" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对各种操作都要小心——理解它们是深层副本还是浅层副本，因为理解失败可能会导致您意外地更改原始列表中的值。除了切片，还有几个接口会让你认为是深层拷贝，但实际上是浅层拷贝。如果需要执行值变更，最好搜索文档，看看操作是使用浅层副本还是深层副本。</p><p id="808d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一般来说，浅拷贝的黄金法则是使它们不可改变。一旦你做了一个浅拷贝(或者一个变体，比如通过切片)，不要改变原件或者拷贝，这样就不会出现意想不到的改变。如果您确实要编辑副本，请确保您完全了解它不仅会对原始数组产生影响，还会对由该原始数组制作的任何其他浅层副本产生影响。</p><p id="a232" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">许多 Python 对象，比如字典，都有默认的浅层复制函数，比如<code class="fe mb mc md me b">dict.copy()</code>。但是，您也可以使用<code class="fe mb mc md me b">copy</code>模块(<code class="fe mb mc md me b">import copy</code>)，调用<code class="fe mb mc md me b">copy.copy()</code>进行浅层复制，调用<code class="fe mb mc md me b">copy.deepcopy</code>进行深层复制。这些就像用于深层和浅层拷贝的 NumPy 命令一样。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><div class="mv mw mx my gt na"><a rel="noopener follow" target="_blank" href="/advanced-numpy-array-indexing-made-easy-fc49fdaef367"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd jk gy z fp nf fr fs ng fu fw ji bi translated">高级 NumPy 数组索引，变得简单</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">理解[::2，[0，3，4]，…，2:5]是什么意思</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">towardsdatascience.com</p></div></div><div class="nj l"><div class="nk l nl nm nn nj no ja na"/></div></div></a></div><p id="aded" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">除了由作者创建的标题之外的所有图像。</p></div></div>    
</body>
</html>