<html>
<head>
<title>4 Coding Mistakes I Did When I Was Learning Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我在学习Python时犯的4个编码错误</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/4-coding-mistakes-i-did-when-i-was-learning-python-bbc6824bdd8c?source=collection_archive---------24-----------------------#2020-06-22">https://towardsdatascience.com/4-coding-mistakes-i-did-when-i-was-learning-python-bbc6824bdd8c?source=collection_archive---------24-----------------------#2020-06-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="9727" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">更好的编程</h2><div class=""/><div class=""><h2 id="194b" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">一起学习我最纠结的Python概念</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/3802cc78a2aa82a6600dea1812b84af1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cjoTe1ydGwUA0i0ULI4tLw.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@neonbrand?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> NeONBRAND </a>在<a class="ae lh" href="/s/photos/mistake?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="d036" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">几年前，我开始了学习Python的冒险，我已经知道了一些其他的编程语言，比如PHP(第一种将我引入web开发的语言)，JavaScript(我已经很擅长了，并且正在编写一个UI库)和C#，这是我当时收入的来源。</p><p id="80ae" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我通过自己开发一个应用程序来学习Python，因此我将许多JavaScript和C#的做事方式融入到我的代码中，这很糟糕，尽管有时它会工作。我花了一些时间，阅读他人的代码，并与他人合作，实际上提高了语言水平。今天我想和你一起回顾一下我在学习Python时犯的一些错误(代码方面的)。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="8751" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">#1误解Python范围</h1><p id="7b1e" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">Python范围解析基于所谓的<strong class="lk jd"> LEGB </strong>规则，这是<strong class="lk jd"> L </strong> ocal、<strong class="lk jd"> E </strong> nclosing、<strong class="lk jd"> G </strong> lobal、<strong class="lk jd"> B </strong>内建的简写。尽管看起来非常简单，但当时我还是有点迷惑，例如，考虑下面的例子:</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="ba9b" class="nn mm it nj b gy no np l nq nr">x = 5<br/>def foo():<br/>    x += 1<br/>    print(x)</span><span id="ee2c" class="nn mm it nj b gy ns np l nq nr">foo()</span><span id="6780" class="nn mm it nj b gy ns np l nq nr">-----------<br/>Output<br/>-----------<br/>Traceback (most recent call last):<br/>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>  File "&lt;stdin&gt;", line 2, in foo<br/>UnboundLocalError: local variable 'x' referenced before assignment</span></pre><p id="e71f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于上面的代码，我希望它能够工作，并修改全局变量<code class="fe nt nu nv nj b">x</code>以最终打印<code class="fe nt nu nv nj b">6</code>。但是，事情可能会变得更奇怪，让我们来看看下面修改过的代码:</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="4ac1" class="nn mm it nj b gy no np l nq nr">y = 5<br/>def foo_y():<br/>    print(y)</span><span id="10d3" class="nn mm it nj b gy ns np l nq nr">foo_y()</span><span id="649b" class="nn mm it nj b gy ns np l nq nr">-----------<br/>Output<br/>-----------<br/>5</span></pre><p id="6ecc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这到底是怎么回事？在一段代码中，全局变量<code class="fe nt nu nv nj b">X</code>给出了一个<code class="fe nt nu nv nj b">UnboundLocalError</code>，然而，当我们试图打印变量时，它工作了。原因与范围有关。当你在一个作用域(比如函数作用域)中给一个变量赋值时，这个变量就变成了这个作用域的局部变量，并且隐藏了外部作用域中任何相似命名的变量。这是我们拍摄《T4》时第一个场景中发生的事情。</p><p id="719e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果我们打算像函数<code class="fe nt nu nv nj b">foo()</code>一样访问全局变量<code class="fe nt nu nv nj b">x</code>，我们可以这样做:</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="7459" class="nn mm it nj b gy no np l nq nr">x = 5<br/>def foo():<br/>    global x<br/>    x += 1<br/>    print(x)</span><span id="5c05" class="nn mm it nj b gy ns np l nq nr">foo()</span><span id="1f39" class="nn mm it nj b gy ns np l nq nr">-----------<br/>Output<br/>-----------<br/>6</span></pre><p id="0669" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">通过使用关键字<code class="fe nt nu nv nj b">global</code>允许内部作用域访问全局作用域中声明的变量，这意味着变量没有在任何函数中定义。类似地，我们可以使用<code class="fe nt nu nv nj b">nonlocal</code>来产生类似的效果:</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="0a2a" class="nn mm it nj b gy no np l nq nr">def foo():<br/>    x = 5<br/>    def bar():<br/>        nonlocal x<br/>        x += 1<br/>        print(x)<br/>    bar()</span><span id="bc3d" class="nn mm it nj b gy ns np l nq nr">foo()</span><span id="c3a3" class="nn mm it nj b gy ns np l nq nr">-----------<br/>Output<br/>-----------<br/>6</span></pre><p id="7f28" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe nt nu nv nj b">nonlocal</code>正如<code class="fe nt nu nv nj b">global</code>允许你从外部作用域访问变量，然而，在<code class="fe nt nu nv nj b">nonlocal</code>的情况下，你可以绑定到一个父作用域或全局作用域上的一个对象。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="d4b4" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">#2迭代时修改列表</h1><p id="fbaa" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">虽然这个错误不仅在Python中很常见，但我发现它在新的Python开发人员中很常见，甚至对一些有经验的开发人员也是如此。虽然有时可能看起来不那么明显，但在某些情况下，我们最终会修改当前正在迭代的数组，导致不恰当的行为，或者如果我们幸运的话，我们会得到一个错误并很容易注意到它。</p><p id="e21c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是让我给你一个例子来说明我的意思，假设给定一个数组，你需要减少数组，只包含偶数元素，你可以尝试这样做:</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="1f50" class="nn mm it nj b gy no np l nq nr">def odd(x): return bool(x % 2)<br/>numbers = [n for n in range(10)]<br/>for i in range(len(numbers)):<br/>    if odd(numbers[i]):<br/>        del numbers[i]</span><span id="007f" class="nn mm it nj b gy ns np l nq nr">-----------<br/>Output<br/>-----------<br/>Traceback (most recent call last):<br/>  File "&lt;stdin&gt;", line 2, in &lt;module&gt;<br/>IndexError: list index out of range</span></pre><p id="5ba8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在所描述的场景中，当在迭代过程中删除一个列表或数组的元素时，我们会得到一个错误，因为我们试图访问一个不再存在的项目。这是一种不好的做法，应该避免，在python中有更好的方法来实现类似的事情，其中包括:</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="7207" class="nn mm it nj b gy no np l nq nr">def odd(x): return bool(x % 2)<br/>numbers = [n for n in range(10)]<br/>numbers[:] = [n for n in numbers if not odd(n)]<br/>print(numbers)</span><span id="92b7" class="nn mm it nj b gy ns np l nq nr">-----------<br/>Output<br/>-----------<br/>[0, 2, 4, 6, 8]</span></pre><p id="950a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您也可以使用<code class="fe nt nu nv nj b">filter</code>函数来实现同样的功能，虽然它可以工作，但有些人认为这不是Pythonic的工作方式，我也有点同意，但我不想卷入这场讨论。我宁愿给你选择，你可以研究和决定:</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="97a2" class="nn mm it nj b gy no np l nq nr">def even(x): return not bool(x % 2)<br/>numbers = [n for n in range(10)]<br/>numbers = list(filter(even, numbers))<br/>numbers</span><span id="1215" class="nn mm it nj b gy ns np l nq nr">-----------<br/>Output<br/>-----------<br/>[0, 2, 4, 6, 8]</span></pre></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="f398" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">#3闭包中的变量绑定</h1><p id="5eff" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">我想从我在twitter ( <a class="ae lh" href="https://twitter.com/livecodestream" rel="noopener ugc nofollow" target="_blank"> @livecodestream </a>)上发布的一个测试开始，我问人们他们认为下面的片段会是什么结果:</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="017e" class="nn mm it nj b gy no np l nq nr">def create_multipliers():<br/>    return [lambda x : i * x for i in range(5)]</span><span id="dc5e" class="nn mm it nj b gy ns np l nq nr">for multiplier in create_multipliers():<br/>    print(multiplier(2))</span><span id="4a63" class="nn mm it nj b gy ns np l nq nr">-----------<br/>Output<br/>-----------<br/>8<br/>8<br/>8<br/>8<br/>8</span></pre><p id="db8d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对许多人来说，包括我自己，当我们第一次遇到这个问题时，我们认为结果会是:</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="cd34" class="nn mm it nj b gy no np l nq nr">0<br/>2<br/>4<br/>6<br/>8</span></pre><p id="919c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，代码实际上导致了完全不同的结果，我们对此感到非常困惑。实际发生的是Python会做一个后期绑定行为，根据这个行为，在调用内部函数的时候会查找闭包中使用的变量值。所以在我们的例子中，无论何时调用任何返回的函数，在调用它的时候都在周围的范围内查找<code class="fe nt nu nv nj b">i</code>的值。</p><p id="6d6b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这个问题的解决方案可能看起来有点粗糙，但它确实有效</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="960e" class="nn mm it nj b gy no np l nq nr">def create_multipliers():<br/>    return [lambda x, i=i : i * x for i in range(5)]</span><span id="c147" class="nn mm it nj b gy ns np l nq nr">for multiplier in create_multipliers():<br/>    print(multiplier(2))</span><span id="2376" class="nn mm it nj b gy ns np l nq nr">-----------<br/>Output<br/>-----------<br/>0<br/>2<br/>4<br/>6<br/>8</span></pre><p id="3cc4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">通过使用lambda函数的默认参数来传递<code class="fe nt nu nv nj b">i</code>的值，我们可以生成函数来执行所需的行为。我对这个解决方案感到非常困惑，我仍然认为它不是很优雅，但是，有些人喜欢它。如果你知道这个问题的另一个可能的解决方案，请在评论中告诉我，我很乐意阅读。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="c4df" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">#4名称与Python标准库模块冲突这个问题实际上在我刚开始的时候相当普遍，即使是现在，有时我也会犯这个错误。这个问题是由于将一个模块命名为与Python附带的标准库中的一个模块同名而引起的。(例如，您的代码中可能有一个名为email.py的模块，这将与同名的标准库模块相冲突)。</p><p id="7b4b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">也许名称冲突本身不会对您的代码产生任何问题，但有时我们会覆盖Python标准库的函数或模块，这些函数或模块稍后会在已安装的库中使用，并且它会因抛出错误或行为不当而发生冲突。无论如何，这是一个糟糕的情况。</p><p id="2ab6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一个典型的错误如下:</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="488c" class="nn mm it nj b gy no np l nq nr">a = list()<br/>print(a)</span><span id="7e9d" class="nn mm it nj b gy ns np l nq nr">list = [1, 2, 3] # This is where we break it<br/>a = list()</span><span id="02b7" class="nn mm it nj b gy ns np l nq nr">-----------<br/>Output<br/>-----------<br/>[]<br/>Traceback (most recent call last):<br/>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>TypeError: 'list' object is not callable</span></pre><p id="d774" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">通过简单地创建一个名为<code class="fe nt nu nv nj b">list</code>的变量，我们中断了对<code class="fe nt nu nv nj b">list</code>函数的访问。而且，即使有其他的访问方式(比如<code class="fe nt nu nv nj b">__builtins__.list()</code>，我们也要避免这种名字。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="d33e" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">结论</h1><p id="658c" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">本文并没有涵盖开发人员在用Python编码时会犯的所有常见错误，而是那些我最纠结的事情。如果您想了解更多关于如何编写出色的Python代码以及避免其他一些错误的信息，我推荐您阅读:</p><div class="nw nx gp gr ny nz"><a href="https://medium.com/swlh/make-your-code-great-python-style-3223c1160299" rel="noopener follow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd jd gy z fp oe fr fs of fu fw jc bi translated">让你的代码变得伟大，Python风格</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">让我们一起学习一些简单的技巧来编写更多的Pythonic代码。</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">medium.com</p></div></div><div class="oi l"><div class="oj l ok ol om oi on lb nz"/></div></div></a></div><p id="95fc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">感谢阅读！</p></div></div>    
</body>
</html>