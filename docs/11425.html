<html>
<head>
<title>Robust 2 DataFrames verification with Pandas 1.1.0</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Pandas 1.1.0 进行可靠的 2 数据帧验证</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/robust-2-dataframes-verification-with-pandas-1-1-0-af22f328e622?source=collection_archive---------48-----------------------#2020-08-07">https://towardsdatascience.com/robust-2-dataframes-verification-with-pandas-1-1-0-af22f328e622?source=collection_archive---------48-----------------------#2020-08-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="91d1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用最近添加的 DataFrame.compare()进行可靠的资格检查。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3fad023b4a3267192575e14122116257.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gGx-Tk3-XtPynIFX"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">库纳尔·卡拉在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="a042" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Pandas 是数据科学家和数据工程师最常用的 Python 库之一。今天，我想分享一些 Python 技巧来帮助我们在两个数据帧之间进行<strong class="ky ir">资格</strong>检查。</p><p id="dbab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，我用了这个词:<strong class="ky ir">资格</strong>，而不是完全相同。相同很容易检查，但是<strong class="ky ir">资格</strong>是一个松散的检查。它是基于商业逻辑的。因此，更难实现。</p><h1 id="e59b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">不是重新发明轮子</h1><p id="8e66" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在 1.1.0 版本中——发布于 2020 年 7 月 28 日，8 天前——Pandas 引入了内置的<a class="ae kv" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/merging.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">比较</strong>功能</a>。我们接下来的所有步骤都是基于它构建的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/9ca4575142a3ecba1cebd526d539b7aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cfw7rH_w_KjPruzkWjSxWA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">用于比较的官方文档截图</p></figure><p id="a69e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">提示</strong>:如果您正在使用 Anacondas 发行版，您应该使用下面的命令行来升级您的 Pandas 版本。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h1 id="bcdf" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">低垂的果实</h1><p id="5ce6" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">总是先检查两帧之间的列数。在某些情况下，这种简单的检查可以发现问题。</p><p id="d4b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在某些情况下，如浓缩变化，我们可以有不同数量的列。合格的定义可以是:对于在 2 个数据帧之间具有相同值的所有前面的列。因此，我们将确定要检查的列，并将它们保存在变量<strong class="ky ir">列</strong>中，以备后用。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h1 id="d6a8" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">开锁的钥匙</h1><p id="0f7e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在实际应用中，我们会有不同的 id 来标识一个记录，比如 user-id、order_id 等。为了进行唯一的查询，我们可能需要使用这些键的组合。<strong class="ky ir">最终，我们希望验证具有相同关键字的记录具有相同的列值。</strong></p><p id="6127" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一步是编写组合键。这就是数据框架<strong class="ky ir">应用</strong>的亮点所在。我们可以使用 df.apply(lambda: x: func(x)，<strong class="ky ir"> axis = 1 </strong>)进行任何数据转换。在<strong class="ky ir">轴= 1 </strong>的情况下，我们告诉熊猫一排排做同样的操作<strong class="ky ir">。(轴= 0，逐列)</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h1 id="c000" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">处理值错误</h1><p id="0791" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">对于新的 DataFrame.compare 函数，下面的错误是最令人困惑的。让我解释一下。</p><blockquote class="ms mt mu"><p id="f939" class="kw kx mv ky b kz la jr lb lc ld ju le mw lg lh li mx lk ll lm my lo lp lq lr ij bi translated"><strong class="ky ir">值错误</strong>:只能比较标签相同的 DataFrame 对象</p></blockquote><p id="e173" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">出现此错误的原因是两个数据框之间的列的形状和顺序不相同。是的。DataFrame.compare 仅适用于相同检查，不适用于资格检查。</p><p id="c788" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">解决问题的方法是:使用之前创建的<strong class="ky ir"> keyColumn </strong>，比较具有相同 keyColumn 值的数据帧之间的子集。对每个 keyColumn 值都这样做。</p><p id="1db6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果两个数据框架中键列的尺寸不同，则提出问题并跳过检查。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h1 id="4145" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">带走:</h1><p id="b59b" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">使用最新的 Pandas 1.1.0 DataFrame.compare 进行可靠的 DataFrame 资格检查。为了处理 ValueError，我们使用 keyColumn 进行多个子数据帧检查，并返回最终决定。</p></div></div>    
</body>
</html>