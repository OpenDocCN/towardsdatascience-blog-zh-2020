<html>
<head>
<title>Structuring Jupyter Notebooks For Fast and Iterative Machine Learning Experiments</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为快速迭代机器学习实验构建 Jupyter 笔记本</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/structuring-jupyter-notebooks-for-fast-and-iterative-machine-learning-experiments-e09b56fa26bb?source=collection_archive---------13-----------------------#2020-05-07">https://towardsdatascience.com/structuring-jupyter-notebooks-for-fast-and-iterative-machine-learning-experiments-e09b56fa26bb?source=collection_archive---------13-----------------------#2020-05-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1e8a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">这是为那些需要在整洁的 Jupyter 工作空间中快速运行大量建模实验的忙碌的 ML 实践者准备的备忘单。</h2></div><h1 id="b97d" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">“模块化”你的代码在机器学习项目中很难</h1><p id="5302" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">与软件世界不同，术语“可重用组件”可能很难应用于建模世界。实验通常是一次性的，没有多少代码被重用。如果你是一个干净的代码倡导者，喜欢花时间重构每一行代码来遵循“不要重复自己”(DRY)的原则，你很容易花太多时间这样做。</p><p id="fbd0" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">然而，我并不是建议去“不要重复自己”原则的对立面。我见过非常杂乱无章的 Jupyter 笔记本目录。然而，我们应该努力理解我们应该重用哪些组件。在本文中，我将根据我两年多来使用 Jupyter 笔记本对数据进行预处理和建模的经验，重点介绍机器学习项目中倾向于重用的组件。</p><h1 id="c3e6" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">首先，我们为什么要用 Jupyter？</h1><p id="40f4" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们在建模项目中使用 Jupyter 的主要原因是我们希望速度更快。我们想快速实验，快速失败，快速学习。数据处理需要时间，机器学习训练更需要时间。不像软件世界里“热重装”是一个东西，我们在建模世界里通常没有它。准备一个实验和实验本身都要花很多时间。为了更快，我们需要使用 Jupyter，它让我们能够只在一小部分代码上测试运行，而不是整个脚本。</p><blockquote class="mb mc md"><p id="1ecb" class="la lb me lc b ld lw ju lf lg lx jx li mf ly ll lm mg lz lp lq mh ma lt lu lv im bi translated">这是一个迭代的过程。你越快完成这个循环，你的进步就越快。</p><p id="d9ec" class="la lb me lc b ld lw ju lf lg lx jx li mf ly ll lm mg lz lp lq mh ma lt lu lv im bi translated">—吴恩达，机器学习向往</p></blockquote><p id="bebd" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">现在，知道我们不应该在一开始就写脚本，而是应该使用 Jupyter 笔记本，让我们看看我们应该如何组织我们的项目。</p><h1 id="4dd3" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">概观</h1><p id="90d0" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">以下是我们将在这篇文章中涵盖的内容的概述:</p><ol class=""><li id="b4a4" class="mi mj it lc b ld lw lg lx lj mk ln ml lr mm lv mn mo mp mq bi translated"><strong class="lc iu">拥有“小数据”有助于</strong> —为什么以及如何在编写代码时拥有小数据集。</li><li id="278d" class="mi mj it lc b ld mr lg ms lj mt ln mu lr mv lv mn mo mp mq bi translated"><strong class="lc iu">使用 git </strong> —如何使用 git 对你的笔记本进行版本控制。</li><li id="bae1" class="mi mj it lc b ld mr lg ms lj mt ln mu lr mv lv mn mo mp mq bi translated"><strong class="lc iu">关注点分离</strong>——如何构建你的 Jupyter 文件目录。</li><li id="50ff" class="mi mj it lc b ld mr lg ms lj mt ln mu lr mv lv mn mo mp mq bi translated"><strong class="lc iu">预处理、建模笔记本&amp;报告笔记本</strong> —这里我们讨论如何构建 3 个笔记本以及笔记本中包含的内容</li><li id="4848" class="mi mj it lc b ld mr lg ms lj mt ln mu lr mv lv mn mo mp mq bi translated"><strong class="lc iu">主笔记本</strong> —如何从一个笔记本调用其他笔记本以及如何记录输出</li></ol><h1 id="b671" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated"><strong class="ak">拥有“小数据”有助于</strong></h1><p id="12b6" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">首先，在我们开始为我们的数据处理和数据模型编写代码之前，我们应该有一组“小数据”作为我们的数据。主要的直觉是有一个非常小的数据集，可以快速处理。通过这样做，当我们第一次运行我们的代码时，我们不必等几个小时才知道我们的代码中有一个简单的 bug。</p><p id="0b76" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">例如，如果我们希望在 1000 万张图片上训练一个模型，那么试着每类只采样 50 张图片来编写代码。或者，如果我们正在训练 1 亿行销售数据，我们可以尝试采样 2000 行销售数据作为我们的“小数据”。</p><p id="fddf" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">“小数据”应该有多大取决于样本的代表性和处理它的时间。就样本而言，每节课至少要有 5 个样本。就时间而言，经验法则是“小数据”从数据处理到完成模型训练所需的时间应该在 10 分钟以内。</p><p id="374e" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">你可以在笔记本的开头使用下面的代码来打开和关闭<code class="fe mw mx my mz b">SMALL_DATA_MODE</code>。</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="f703" class="ni kj it mz b gy nj nk l nl nm">SMALL_DATA_MODE = True</span><span id="ffc7" class="ni kj it mz b gy nn nk l nl nm">if SMALL_DATA_MODE:<br/>    DATA_FILE = "path/to/smallData.csv"<br/>else:<br/>    DATA_FILE = "path/to/originalData.csv"</span></pre><h1 id="c882" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">使用 git</h1><p id="5cd1" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">随着您运行越来越多的实验，很可能会删除旧代码并用新代码替换它们。仅仅为了代码上的一个小变化而创建一个新的笔记本是不好的，因为我们将来可能甚至不需要它们，它会占用我们的工作空间。</p><p id="1ec7" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">使用 git 有助于我们在保持工作场所整洁的同时对笔记本进行版本控制。如果需要，您可以通过返回到之前的 git 提交来恢复到旧版本。此外，如果我们定期将代码推送到远程存储库，我们就不必担心代码丢失。如果你独自做这个项目，你可以把所有的事情都推到主分支，如果你在一个团队中，你可以推到不同的分支。</p><p id="a242" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated"><strong class="lc iu">安装 git，</strong></p><p id="dca1" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">在 Windows 上，转到<a class="ae no" href="https://git-scm.com/download/win" rel="noopener ugc nofollow" target="_blank">https://git-scm.com/download/win</a></p><p id="8786" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">在 macOS 上，在终端中运行<code class="fe mw mx my mz b">git --version</code>。如果您还没有安装 git，它会提示您进行安装。</p><p id="bd1f" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">在 Linux Ubuntu 上，运行<code class="fe mw mx my mz b">sudo apt install git-all</code></p><p id="0280" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">安装后，在项目目录中运行以下命令</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="b370" class="ni kj it mz b gy nj nk l nl nm">git init</span></pre><p id="630c" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">同样，让我们指定不想用 git 跟踪的文件。创建一个名为<code class="fe mw mx my mz b">.gitignore</code>的新文件，并将以下文本放入该文件。我们将忽略 Jupyter 检查点、python 缓存和数据目录。</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="1f44" class="ni kj it mz b gy nj nk l nl nm">.ipynb_checkpoints/<br/>data/<br/>__pycache__/</span></pre><p id="f81b" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">要提交，请使用以下内容(如果您以前加入过软件项目，您应该对这些内容很熟悉)。如果没有，我建议查看 git 教程。</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="13b4" class="ni kj it mz b gy nj nk l nl nm">git add .<br/>git commit -m "Give a clear message here on what's changing compared to last time you commit"</span><span id="2e6f" class="ni kj it mz b gy nn nk l nl nm"># remember to set a remote named `origin` for this:<br/>git push origin master</span></pre><h1 id="7af7" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">关注点分离</h1><figure class="na nb nc nd gt nq gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi np"><img src="../Images/4cb202a07d2d023c0f693fccb1d9d4f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LIP5xM0uEsANCoDsKjrR9w.png"/></div></div><p class="nx ny gj gh gi nz oa bd b be z dk translated">图中显示了机器学习项目的推荐结构</p></figure><p id="5523" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">一个机器学习项目通常会有多个使用相同数据和相同模型的实验。与其把所有东西都封在一个目录里，一个好办法是把<strong class="lc iu">数据</strong>、<strong class="lc iu">预处理</strong>、<strong class="lc iu">建模</strong>和<strong class="lc iu">实验输出(exp) </strong>分开。</p><h2 id="f74a" class="ni kj it bd kk ob oc dn ko od oe dp ks lj of og ku ln oh oi kw lr oj ok ky ol bi translated"><strong class="ak">这是我最喜欢的文件结构:</strong></h2><ul class=""><li id="817f" class="mi mj it lc b ld le lg lh lj om ln on lr oo lv op mo mp mq bi translated"><code class="fe mw mx my mz b">data/</code> —各种数据(原始数据、预处理数据等)的存储桶</li><li id="7277" class="mi mj it lc b ld mr lg ms lj mt ln mu lr mv lv op mo mp mq bi translated"><code class="fe mw mx my mz b">exp/ </code> —这里是实验的输出(保存的模型+实际和预测的标签)</li><li id="d37a" class="mi mj it lc b ld mr lg ms lj mt ln mu lr mv lv op mo mp mq bi translated"><code class="fe mw mx my mz b">logs/</code> —只是放置我们预处理数据和建模的日志文件</li><li id="f6fa" class="mi mj it lc b ld mr lg ms lj mt ln mu lr mv lv op mo mp mq bi translated"><code class="fe mw mx my mz b">a_MASTER0.ipynb </code> —“主”Jupyter 笔记本，可以调用其他“从”笔记本(预处理、建模、报告)。我们将在下一节展示如何从一个笔记本中调用另一个笔记本。</li><li id="d1a8" class="mi mj it lc b ld mr lg ms lj mt ln mu lr mv lv op mo mp mq bi translated"><code class="fe mw mx my mz b">a_MASTER1.ipynb</code> —只是另一个并行运行另一个实验的“主”笔记本。您可以根据需要添加任意数量的主笔记本。</li><li id="95db" class="mi mj it lc b ld mr lg ms lj mt ln mu lr mv lv op mo mp mq bi translated"><code class="fe mw mx my mz b">b_preprocess.ipynb</code> —预处理笔记本，接收来自<code class="fe mw mx my mz b">data/raw</code>的原始数据，并将数据输出到<code class="fe mw mx my mz b">data/{dir}</code></li><li id="6885" class="mi mj it lc b ld mr lg ms lj mt ln mu lr mv lv op mo mp mq bi translated"><code class="fe mw mx my mz b">c_model_svm.ipynb</code> —该笔记本接收预处理的输出，稍加修改以适应 SVM 模型，然后将建模结果(如学习的模型参数、预测等)输出到<code class="fe mw mx my mz b">exp/</code>。</li><li id="37c5" class="mi mj it lc b ld mr lg ms lj mt ln mu lr mv lv op mo mp mq bi translated"><code class="fe mw mx my mz b">c_model_randomForest.ipynb </code> —如果你有另一个型号，就这样命名。</li><li id="24c6" class="mi mj it lc b ld mr lg ms lj mt ln mu lr mv lv op mo mp mq bi translated"><code class="fe mw mx my mz b">d_reporting.ipynb </code> —这将从<code class="fe mw mx my mz b">exp/</code>中读取并为您的报告绘制表格或图像。</li></ul><h1 id="5336" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">预处理笔记本</h1><p id="3f68" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在这里，我将展示当我们第一次在笔记本中运行代码时应该做什么，我们应该用笔记本的参数启动笔记本。</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="b829" class="ni kj it mz b gy nj nk l nl nm"># PARAMETER<br/>#-------------</span><span id="de03" class="ni kj it mz b gy nn nk l nl nm"># check if IS_MASTER exists, this variable will only exist if it's being called by MASTER notebook.<br/># if it does not exist, set it to False<br/>try: IS_MASTER<br/>except: IS_MASTER = False</span><span id="e71d" class="ni kj it mz b gy nn nk l nl nm"># The code below will only run if it's NOT being called from MASTER notebook<br/>if IS_MASTER:<br/>    DATA_DIR = './data/temp/' # <br/>    RAW_FILE = f'/path/to/smallData.csv' # use "small data" here<br/>    PROCESSED_FILE = f'{DATA_DIR}processed.pkl' # always use pickle for fast I/O!<br/>    OTHER_PREPROCESS_PARAMETER = ... # e.g. batch size, sliding window size, etc</span></pre><p id="1d03" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">上面的代码为我们的笔记本设置了默认参数。我们将只使用一个临时目录<code class="fe mw mx my mz b">TMP_DIR</code>(在<code class="fe mw mx my mz b">data/</code>目录下)来存储我们的输出。这是为了确保快速迭代。当我们写代码时，我们应该总是使用“小数据”。</p><p id="b960" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">您可以继续编写预处理部分。既然您在这个“开发”阶段使用“小数据”,那么您应该很快！当你完成预处理后，记得使用<code class="fe mw mx my mz b">pickle</code>库输出一个 Pickle 文件:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="9b4d" class="ni kj it mz b gy nj nk l nl nm">import pickle<br/>with open(PROCESSED_FILE, 'wb') as f:<br/>    pickle.dump(python_object, f)</span></pre><p id="e698" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">或者，使用<code class="fe mw mx my mz b">pandas</code>快捷键:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="8248" class="ni kj it mz b gy nj nk l nl nm">df.to_pickle(PROCESSED_FILE)</span></pre><p id="c6c7" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">我们使用 Pickle 而不是 CSV 格式来实现持久性和快速读写。这个<code class="fe mw mx my mz b">PROCESSED_FILE</code>将在下一部分的建模笔记本中读到。</p><h1 id="71c0" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">建模笔记本</h1><p id="162c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">从这个开始我们的模型笔记本:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="5ebc" class="ni kj it mz b gy nj nk l nl nm"># PARAMETER<br/>#-------------</span><span id="d27c" class="ni kj it mz b gy nn nk l nl nm"># check if IS_MASTER exists, this variable will only exist if it's being called by MASTER notebook.<br/># if it does not exist, set it to False<br/>try: IS_MASTER<br/>except: IS_MASTER = False</span><span id="c3b1" class="ni kj it mz b gy nn nk l nl nm"># The code below will only run if it's NOT being called from MASTER notebook<br/>if IS_MASTER:<br/>    DATA_DIR = './data/temp/'<br/>    EXP_DIR = './exp/temp/'<br/>    PROCESSED_FILE = f'{DATA_DIR}processed.pkl'<br/>    MODEL_FILE = f'{EXP_DIR}model.pkl'<br/>    PREDICTION_FILE = f'{EXP_DIR}ypred.pkl'<br/>    OTHER_MODEL_PARAMETERS = ... # like N_ESTIMATOR, GAMMA, etc</span></pre><p id="94ec" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">请注意，<code class="fe mw mx my mz b">DATA_DIR</code>和<code class="fe mw mx my mz b">PROCESSED_FILE</code>与之前预处理笔记本的输出相同，并与之相连。</p><p id="6f8d" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">在本建模笔记本中，您应该做 3 件事(此处未显示，因为每个模型都不一样):</p><ol class=""><li id="0f79" class="mi mj it lc b ld lw lg lx lj mk ln ml lr mm lv mn mo mp mq bi translated">读取处理过的数据，并做一点小小的修改，使数据适合模型。</li><li id="cbd2" class="mi mj it lc b ld mr lg ms lj mt ln mu lr mv lv mn mo mp mq bi translated">训练和评估模型</li><li id="9235" class="mi mj it lc b ld mr lg ms lj mt ln mu lr mv lv mn mo mp mq bi translated">将模型的学习参数<code class="fe mw mx my mz b">MODEL_FILE</code>和预测<code class="fe mw mx my mz b">PREDICTION_FILE</code>输出到<code class="fe mw mx my mz b">EXP_DIR</code>目录。对于预测输出，将实际标注和预测标注放在同一个数据框中(便于报告)。</li></ol><h1 id="d506" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">报告笔记本</h1><p id="557a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">报告笔记本是一个快捷的笔记本，它只需要从<code class="fe mw mx my mz b">exp/</code>目录中读取。其输入通过<code class="fe mw mx my mz b">EXP_DIR</code>、<code class="fe mw mx my mz b">MODEL_FILE</code>和<code class="fe mw mx my mz b">PREDICTION_FILE</code>连接到造型笔记本的输出。</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="1689" class="ni kj it mz b gy nj nk l nl nm"># PARAMETER<br/>#-------------</span><span id="0f09" class="ni kj it mz b gy nn nk l nl nm"># check if IS_MASTER exists, this variable will only exist if it's being called by MASTER notebook.<br/># if it does not exist, set it to False<br/>try: IS_MASTER<br/>except: IS_MASTER = False</span><span id="f852" class="ni kj it mz b gy nn nk l nl nm"># The code below will only run if it's NOT being called from MASTER notebook<br/>if IS_MASTER:<br/>    EXP_DIR = './exp/temp/'<br/>    MODEL_FILE = f'{EXP_DIR}model.pkl'<br/>    PREDICTION_FILE = f'{EXP_DIR}ypred.pkl'</span></pre><p id="51b6" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">在这里，您可以将预测的标签与实际标签进行比较。在这里，您可以使用精度、召回率或 ROC AUC 等指标。您还可以在这里运行图表和绘图的代码。</p><h1 id="3795" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">主笔记本</h1><p id="530e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">最后，大师笔记本！</p><p id="9641" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">主笔记本是调用所有其他笔记本的笔记本。在这个笔记本中，您将监督整个数据管道(从原始数据预处理到建模和报告)。</p><p id="d5c7" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">主笔记本也是您调用其他(经过良好测试的)预处理和建模笔记本来运行实际“大数据”的地方。我还将介绍一个日志技巧(因为如果“大数据”出错，我们想知道原因)。</p><p id="8d53" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">我们也将在这里使用 Jupyter 魔法命令<code class="fe mw mx my mz b">%run</code>。</p><p id="e457" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">首先，创建一个名为<code class="fe mw mx my mz b">print_n_log.py</code>的文件，并将下面的代码粘贴到其中:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="f188" class="ni kj it mz b gy nj nk l nl nm">"""<br/>Returns a modified print() method that returns TEE to both stdout and a file<br/>"""<br/>import logging</span><span id="d73e" class="ni kj it mz b gy nn nk l nl nm">def run(logger_name, log_file, stream_level='ERROR'):<br/>    stream_level = {<br/>        'DEBUG': logging.DEBUG,<br/>        'INFO': logging.INFO,<br/>        'WARNING': logging.WARNING,<br/>        'ERROR': logging.ERROR,<br/>        'CRITICAL': logging.CRITICAL,<br/>    }[stream_level]<br/>    <br/>    # create logger with 'logger_name'<br/>    logger = logging.getLogger(logger_name)<br/>    logger.setLevel(logging.DEBUG)<br/>    # create file handler which logs even debug messages<br/>    fh = logging.FileHandler(log_file)<br/>    fh.setLevel(logging.DEBUG)<br/>    # create console handler with a higher log level<br/>    ch = logging.StreamHandler()<br/>    ch.setLevel(stream_level)<br/>    # create formatter and add it to the handlers<br/>    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')<br/>    fh.setFormatter(formatter)<br/>    ch.setFormatter(formatter)<br/>    # add the handlers to the logger<br/>    logger.addHandler(fh)<br/>    logger.addHandler(ch)<br/>    def modified_print(*args):<br/>        s = ' '.join([str(a) for a in args])<br/>        logger.info(s)<br/>    return modified_print</span></pre><p id="2a6b" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">上面的代码将创建一个修改过的<code class="fe mw mx my mz b">print()</code>方法，该方法将输出(stdout)和错误(stderr)重定向到主笔记本单元的输出和日志文件。</p><p id="e61c" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">接下来，将此模块导入您的主笔记本:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="b271" class="ni kj it mz b gy nj nk l nl nm">import print_n_log</span></pre><p id="57a2" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">在您的下一个单元格中，让我们尝试调用预处理笔记本:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="8875" class="ni kj it mz b gy nj nk l nl nm"># Parameters for Preprocessing Notebook<br/>#---------------------------------------------<br/>IS_MASTER = True # Remember this? We need to set this to True in MASTER Notebook so that it does not use the default parameters in processing notebook.<br/>RAW_FILE = f'/path/to/smallData.csv' # use "small data" here<br/>PROCESSED_FILE = f'{DATA_DIR}processed.pkl' # always use pickle for fast I/O!<br/>OTHER_PREPROCESS_PARAMETER = ... # like batch size, sliding</span><span id="e671" class="ni kj it mz b gy nn nk l nl nm"># Let's save the original print method in ori_print<br/>#---------------------------------------------------<br/>ori_print = print</span><span id="6247" class="ni kj it mz b gy nn nk l nl nm"># Now we set the print method to be modified print<br/>#--------------------------------------------------<br/>print = <!-- -->print_n_log<!-- -->.run('preproc', './logs/preprocess.log', 'DEBUG')</span><span id="d317" class="ni kj it mz b gy nn nk l nl nm"># Now, we run the Preprocessing Notebook using the %run magic<br/>#-------------------------------------------------------------<br/>%run 'c_preprocess.ipynb'</span><span id="1036" class="ni kj it mz b gy nn nk l nl nm"># Finally, after running notebook, we set the print method back to the original print method.<br/>#-----------------------------------------------------<br/>print = ori_print</span></pre><p id="8919" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">注意，我们使用<code class="fe mw mx my mz b">%run</code>魔法来运行预处理笔记本。这是一个 IPython 魔术，让我们从当前的笔记本运行其他 Python 文件和 Jupyter 笔记本。我们使用这个命令来运行预处理笔记本中的所有代码。</p><p id="ec38" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">通过调用<code class="fe mw mx my mz b">print_n_log.run('preproc', './logs/preprocess.log', 'DEBUG')</code>，我们修改了原始的 Python 内置<code class="fe mw mx my mz b">print()</code>方法，将输出重定向到屏幕和日志文件。<code class="fe mw mx my mz b">'preproc'</code>只是我们记录器的一个名字，你可以使用任何其他名字。运行后，您可以转到<code class="fe mw mx my mz b">'./logs/preproc.log'</code>来查看运行预处理笔记本记录的输出。最后一个参数<code class="fe mw mx my mz b">'DEBUG'</code>只是说“打印每个输出到屏幕上”。如果您只想在屏幕上看到错误(无输出)，也可以使用<code class="fe mw mx my mz b">'ERROR'</code>。</p><p id="4959" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">是的，就是这样！您可以使用相同的模板来调用建模笔记本和报告笔记本。但是，提示一下，您可能不希望记录报告笔记本的输出，所以您可以对它使用原始的 print()方法。</p><h1 id="38ce" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">结论</h1><p id="d770" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这里的关键思想是将 Jupyter 笔记本中与其他部分没有太多纠缠的部分“模块化”，同时对整个数据管道有一个概览。</p><p id="c92b" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">与封装的软件哲学不同，我们实际上并不想将代码封装在 python 文件中，然后再也看不到它们(尽管我们可以对一些实用程序方法这样做)。我们希望将大部分代码保存在笔记本中，因为在设计实验时，每个部分都应该是可变的。当一个部分被改变时，我们也想让它们可测试。通过留在 Jupyter notebook，我们知道我们的代码在用“小数据”运行时是可测试的。通过遵循这些指导方针，我们将拥有一个组织化和模块化的 Jupyter 项目，然而每个部分都是易于编辑和测试的。</p><p id="724a" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">要获得我帖子的通知，请在 Medium、<a class="ae no" href="https://twitter.com/desmondyeoh" rel="noopener ugc nofollow" target="_blank"> Twitter </a>或<a class="ae no" href="https://www.facebook.com/desmond.yeoh" rel="noopener ugc nofollow" target="_blank">脸书</a>上关注我。</p></div></div>    
</body>
</html>