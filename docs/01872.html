<html>
<head>
<title>Solving Satisfiability Problems with Grover’s Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Grover算法解决可满足性问题</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/solving-satisfiability-problems-with-grovers-algorithm-quantum-computing-c9d6c177b966?source=collection_archive---------19-----------------------#2020-02-21">https://towardsdatascience.com/solving-satisfiability-problems-with-grovers-algorithm-quantum-computing-c9d6c177b966?source=collection_archive---------19-----------------------#2020-02-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/517c2945d5d0bf9a00fca76337591681.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cqplQJoWpKVNkbx1"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">迈克尔·泽兹奇在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><div class=""/><div class=""><h2 id="2ff4" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">增强机器学习的量子计算</h2></div><p id="d167" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">除了数据库搜索，<a class="ae jg" href="https://medium.com/@uwashingtongold/grovers-algorithm-quantum-computing-1171e826bcfb" rel="noopener"> Grover的算法</a>还有几个应用，其中之一就是解决可满足性问题。我们将探讨什么是可满足性(SAT)问题，以及它们的解决方案如何记录在qi skit(IBM的量子计算Python库)中。</p><h1 id="43a8" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">SAT问题</h1><p id="39ba" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">布尔SAT问题是确定布尔函数中是否有某些输入使得输出为真的问题。这是一个搜索问题，这也是为什么Grover的算法非常适合解决这些问题。</p><p id="6383" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，考虑下面的布尔函数<em class="mr"> f </em>:</p><figure class="mt mu mv mw gt iv gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/94a951c7bdf95629e5a6818119a1c644.png" data-original-src="https://miro.medium.com/v2/resize:fit:1134/format:webp/1*NJt41BE0XhsgCnEe4WzHEw.png"/></div></figure><p id="06d0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一些符号:</p><ul class=""><li id="7d19" class="mx my jj la b lb lc le lf lh mz ll na lp nb lt nc nd ne nf bi translated">是一个布尔NOT，它翻转下一个布尔值</li><li id="a55a" class="mx my jj la b lb ng le nh lh ni ll nj lp nk lt nc nd ne nf bi translated">∨是布尔或</li><li id="819b" class="mx my jj la b lb ng le nh lh ni ll nj lp nk lt nc nd ne nf bi translated">∧是布尔与</li></ul><p id="389c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，函数用文字表示:对于输入v.1、v.2和v.3(其中。表示sub)，函数<em class="mr"> f </em>输出的真值为NOT v.1或NOT v.2或NOT v.3，AND，v.1或v.2或NOT v.3，AND，v.1或NOT v.2或NOT v.3，AND，NOT v.1或v.2或v.3。</p><p id="6515" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">天真的解决方案是尝试每一种可能的组合(在这个场景中只有2 = 8，但是随着变量数量的增加会呈指数级飙升)，并检查哪些是解决方案。</p><figure class="mt mu mv mw gt iv gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/6377381b934f6d880e9e0aebe8eb21ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:892/format:webp/1*bDRKlWHw9s11JJfoFeDD1g.png"/></div></figure><p id="772a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用Grover的算法，可以一次查询所有结果。IBM的量子计算Python库Qiskit使这个过程变得非常简单。</p><h1 id="4598" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">Qiskit中的实现</h1><p id="e549" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">Qiskit接受一个描述函数的多行字符串。必须遵循以下语法:</p><p id="d5c0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">-以“c”开头的行是注释</p><p id="447f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">-第一个非注释行必须采用“p cnf nbvar nbclauses”形式，其中:</p><ul class=""><li id="23bc" class="mx my jj la b lb lc le lf lh mz ll na lp nb lt nc nd ne nf bi translated">cnf表示输入是CNF格式的</li><li id="cdbc" class="mx my jj la b lb ng le nh lh ni ll nj lp nk lt nc nd ne nf bi translated">nbvar是文件中出现的变量的确切数量</li><li id="8a97" class="mx my jj la b lb ng le nh lh ni ll nj lp nk lt nc nd ne nf bi translated">nbclauses是文件中子句的确切数目</li><li id="d6f7" class="mx my jj la b lb ng le nh lh ni ll nj lp nk lt nc nd ne nf bi translated">例如，p cnf 3 5将是上述函数的第一个非注释行。</li></ul><p id="ff2f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">-对于每个子句，都有一行:</p><ul class=""><li id="8351" class="mx my jj la b lb lc le lf lh mz ll na lp nb lt nc nd ne nf bi translated">正数表示相应的变量</li><li id="4c45" class="mx my jj la b lb ng le nh lh ni ll nj lp nk lt nc nd ne nf bi translated">负数表示相应变量的负数</li><li id="e987" class="mx my jj la b lb ng le nh lh ni ll nj lp nk lt nc nd ne nf bi translated">该行必须以0结尾。</li><li id="e983" class="mx my jj la b lb ng le nh lh ni ll nj lp nk lt nc nd ne nf bi translated">-1 2 3 0 '对应于子句v.1 ∨ v.2 ∨ v.3。</li></ul><pre class="mt mu mv mw gt nm nn no np aw nq bi"><span id="b09f" class="nr lv jj nn b gy ns nt l nu nv">import numpy <strong class="nn jk">as</strong> np<br/>from qiskit import BasicAer<br/>from qiskit.visualization import plot_histogram<br/><strong class="nn jk">%config</strong> InlineBackend.figure_format = 'svg'<br/>from qiskit.aqua import QuantumInstance, run_algorithm<br/>from qiskit.aqua.algorithms import Grover<br/>from qiskit.aqua.components.oracles import LogicalExpressionOracle, TruthTableOracle</span><span id="f87b" class="nr lv jj nn b gy nw nt l nu nv">#Input function encoding<br/>input_3sat <strong class="nn jk">=</strong> '''<br/>c example DIMACS-CNF 3-SAT<br/>p cnf 3 5<br/>-1 -2 -3 0<br/>1 -2 3 0<br/>1 2 -3 0<br/>1 -2 -3 0<br/>-1 2 3 0<br/>'''</span><span id="96f4" class="nr lv jj nn b gy nw nt l nu nv">oracle = LogicalExpressionOracle(input_3sat)<br/>grover = Grover(oracle)<br/>backend = BasicAer.get_backend('qasm_simulator')<br/>quantum_instance = QuantumInstance(backend, shots = 1024)<br/>result = grover.run(quantum_instance)<br/>print(result['result'])</span></pre><p id="0c12" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="mt mu mv mw gt nm nn no np aw nq bi"><span id="be9d" class="nr lv jj nn b gy ns nt l nu nv">[1, -2, 3]</span></pre><p id="af17" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以画出结果:</p><pre class="mt mu mv mw gt nm nn no np aw nq bi"><span id="1856" class="nr lv jj nn b gy ns nt l nu nv">plot_histogram(result['measurement'])</span></pre><figure class="mt mu mv mw gt iv gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/b06416b2ad5aaf1398577895cf04c90c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*VcUKZJTJAaZqaxt_L8FsgQ.png"/></div></figure><p id="8954" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">可满足性问题的三个结果是000、011和101。</p></div><div class="ab cl ny nz hx oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="im in io ip iq"><p id="0485" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是格罗弗算法的许多有趣应用之一——SAT问题可以适用于几个现实生活中的问题。</p><p id="bfab" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你喜欢这篇文章，可以看看我的其他文章，比如这篇<a class="ae jg" rel="noopener" target="_blank" href="/how-ai-could-become-sentient-9246d3e1883b?source=your_stories_page---------------------------"> one </a>讨论了本文探索的类似算法如何创造有感知能力的人工智能。</p></div></div>    
</body>
</html>