<html>
<head>
<title>Understanding 8 types of Cross-Validation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解 8 种交叉验证</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/understanding-8-types-of-cross-validation-80c935a4976d?source=collection_archive---------3-----------------------#2020-09-13">https://towardsdatascience.com/understanding-8-types-of-cross-validation-80c935a4976d?source=collection_archive---------3-----------------------#2020-09-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e8ea" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">交叉验证及其类型的深入解释</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/787714e3bd54b08c56dab548bebc74c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qzbtTSFRmJjMekrQTT-ZSA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://pixabay.com/users/mohamed_hassan-5229782/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=4028234" rel="noopener ugc nofollow" target="_blank">穆罕默德·哈桑</a>来自<a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=4028234" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="6638" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">交叉验证</strong>也被称为<strong class="lb iu">抽样外技术</strong>是数据科学项目的一个基本要素。这是一个重采样过程，用于评估机器学习模型，并评估该模型在独立测试数据集上的表现。</p><p id="6e1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，你可以读到 8 种不同的交叉验证技术，它们各有利弊，如下所列:</p><ol class=""><li id="72eb" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><strong class="lb iu"> <em class="me">留 p 不交叉验证</em> </strong></li><li id="59a7" class="lv lw it lb b lc mf lf mg li mh lm mi lq mj lu ma mb mc md bi translated"><strong class="lb iu"> <em class="me">漏项交叉验证</em> </strong></li><li id="7da7" class="lv lw it lb b lc mf lf mg li mh lm mi lq mj lu ma mb mc md bi translated"><strong class="lb iu"> <em class="me">维持交叉验证</em> </strong></li><li id="9170" class="lv lw it lb b lc mf lf mg li mh lm mi lq mj lu ma mb mc md bi translated"><strong class="lb iu"> <em class="me">重复随机子采样验证</em> </strong></li><li id="42bd" class="lv lw it lb b lc mf lf mg li mh lm mi lq mj lu ma mb mc md bi translated"><strong class="lb iu"> <em class="me"> k 倍交叉验证</em> </strong></li><li id="a22f" class="lv lw it lb b lc mf lf mg li mh lm mi lq mj lu ma mb mc md bi translated"><strong class="lb iu"> <em class="me">分层 k 倍交叉验证</em> </strong></li><li id="9598" class="lv lw it lb b lc mf lf mg li mh lm mi lq mj lu ma mb mc md bi translated"><strong class="lb iu"> <em class="me">时间序列交叉验证</em> </strong></li><li id="97d3" class="lv lw it lb b lc mf lf mg li mh lm mi lq mj lu ma mb mc md bi translated"><strong class="lb iu"> <em class="me">嵌套交叉验证</em> </strong></li></ol><p id="1005" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在讨论交叉验证技术之前，让我们了解一下为什么要在数据科学项目中使用交叉验证。</p><h2 id="74fd" class="mk ml it bd mm mn mo dn mp mq mr dp ms li mt mu mv lm mw mx my lq mz na nb nc bi translated">为什么交叉验证很重要？</h2><p id="c6f5" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">我们经常将数据集随机分为训练数据和测试数据，以开发机器学习模型。训练数据用于训练 ML 模型，并且在独立的测试数据上测试相同的模型，以评估模型的性能。</p><p id="a7af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着分裂的随机状态的改变，模型的精度也改变，因此我们不能实现模型的固定精度。测试数据应该独立于训练数据，这样就不会发生数据泄漏。在使用训练数据开发 ML 模型期间，需要评估模型性能。这就是交叉验证数据的重要性。</p><p id="4342" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据需要分成:</p><ul class=""><li id="bebc" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ni mb mc md bi translated"><strong class="lb iu">训练数据:</strong>用于模型开发</li><li id="9498" class="lv lw it lb b lc mf lf mg li mh lm mi lq mj lu ni mb mc md bi translated"><strong class="lb iu">验证数据:</strong>用于验证同一型号的性能</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/bcb3670d7ff93c5ed4da07b6588d7a42.png" data-original-src="https://miro.medium.com/v2/resize:fit:734/format:webp/1*f5EpP3dfLNdpqWGEwPIoqw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)，验证分割</p></figure><p id="0131" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单来说，交叉验证使我们能够更好地利用我们的数据。你可以进一步阅读、工作和实施 7 种类型的交叉验证技术。</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="0f38" class="nr ml it bd mm ns nt nu mp nv nw nx ms jz ny ka mv kc nz kd my kf oa kg nb ob bi translated">1.留下 p-out 交叉验证:</h1><p id="5c1e" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">保留 p-out 交叉验证(LpOCV)是一种详尽的交叉验证技术，它使用 p-观察值作为验证数据，其余数据用于训练模型。以各种方式重复这一过程，以在一组<em class="me"> p </em>观察值和一组训练集上切割原始样本。</p><p id="72d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">p=2 的 LpOCV 的一种变体称为留对交叉验证，已被推荐为一种近乎无偏的方法，用于估计二元分类器的<a class="ae ky" href="https://en.wikipedia.org/wiki/ROC_curve" rel="noopener ugc nofollow" target="_blank"> ROC 曲线</a>下的面积。</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="8b9a" class="nr ml it bd mm ns nt nu mp nv nw nx ms jz ny ka mv kc nz kd my kf oa kg nb ob bi translated">2.留一交叉验证:</h1><p id="6aa5" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">留一法交叉验证(LOOCV)是一种详尽的交叉验证技术。这是一个 p=1 的 LpOCV 范畴。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/c56965a0fcd43b74acaccdb7866c09bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/1*26vyRHpqGbVAwJq_csUqZQ.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(<a class="ae ky" href="https://en.wikipedia.org/wiki/File:LOOCV.gif" rel="noopener ugc nofollow" target="_blank">来源</a>)，LOOCV 运营部</p></figure><p id="6cb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于具有 n 行的数据集，选择第一行进行验证，其余(n-1)行用于训练模型。对于下一次迭代，选择第 2 行进行验证，其余的用于训练模型。类似地，重复该过程，直到 n 个步骤或期望的操作次数。</p><p id="8511" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以上两种交叉验证技术都是穷举交叉验证的类型。穷举交叉验证方法是以所有可能的方式学习和测试的交叉验证方法。它们具有相同的优点和缺点，讨论如下:</p><h2 id="834e" class="mk ml it bd mm mn mo dn mp mq mr dp ms li mt mu mv lm mw mx my lq mz na nb nc bi translated">优点:</h2><ol class=""><li id="8c80" class="lv lw it lb b lc nd lf ne li od lm oe lq of lu ma mb mc md bi translated">简单、易于理解和实施。</li></ol><h2 id="8d63" class="mk ml it bd mm mn mo dn mp mq mr dp ms li mt mu mv lm mw mx my lq mz na nb nc bi translated">缺点:</h2><ol class=""><li id="bb48" class="lv lw it lb b lc nd lf ne li od lm oe lq of lu ma mb mc md bi translated">该模型可能导致较低的偏差。</li><li id="e0aa" class="lv lw it lb b lc mf lf mg li mh lm mi lq mj lu ma mb mc md bi translated">所需的计算时间很长。</li></ol></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="1a20" class="nr ml it bd mm ns nt nu mp nv nw nx ms jz ny ka mv kc nz kd my kf oa kg nb ob bi translated">3.维持交叉验证:</h1><p id="c114" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">维持技术是一种彻底的交叉验证方法，它根据数据分析将数据集随机拆分为定型数据和测试数据。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/c9f32972c9d0356f3f393983e9419fb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:734/format:webp/1*kUcJBJmkSUbmkO0tm_rdyg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)，70:30 将数据分别拆分为训练数据和验证数据</p></figure><p id="659d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在维持交叉验证的情况下，数据集被随机分为定型数据和验证数据。一般来说，训练数据的分裂多于测试数据。训练数据用于归纳模型，验证数据用于评估模型的性能。</p><p id="b99d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用于训练模型的数据越多，模型就越好。对于维持交叉验证方法，大量数据是从训练中分离出来的。</p><h2 id="f981" class="mk ml it bd mm mn mo dn mp mq mr dp ms li mt mu mv lm mw mx my lq mz na nb nc bi translated">优点:</h2><ol class=""><li id="7dd5" class="lv lw it lb b lc nd lf ne li od lm oe lq of lu ma mb mc md bi translated">和以前一样。</li></ol><h2 id="ea8f" class="mk ml it bd mm mn mo dn mp mq mr dp ms li mt mu mv lm mw mx my lq mz na nb nc bi translated">缺点:</h2><ol class=""><li id="c79c" class="lv lw it lb b lc nd lf ne li od lm oe lq of lu ma mb mc md bi translated">不适合不平衡的数据集。</li><li id="2ad0" class="lv lw it lb b lc mf lf mg li mh lm mi lq mj lu ma mb mc md bi translated">许多数据是从训练模型中分离出来的。</li></ol></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="17ea" class="nr ml it bd mm ns nt nu mp nv nw nx ms jz ny ka mv kc nz kd my kf oa kg nb ob bi translated">4.k 倍交叉验证:</h1><p id="5089" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">在 k 折叠交叉验证中，原始数据集被均等地划分成 k 个子部分或折叠。对于每次迭代，从 k 个折叠或组中选择一个组作为验证数据，并且选择剩余的(k-1)个组作为训练数据。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/3a77b31909dcf1e5ca9934c334d047a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/1*2rRcNnIokzJU_-NXm29IMA.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(<a class="ae ky" href="https://en.wikipedia.org/wiki/File:KfoldCV.gif" rel="noopener ugc nofollow" target="_blank">来源</a>)，k 倍交叉验证</p></figure><p id="5299" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该过程重复 k 次，直到每组被视为有效，并作为训练数据保留。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/7159561bc37283c17ba8b6a3b20407f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/format:webp/1*ZAtq4R-CnEoACJQ4HJ6YwQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)，k 倍交叉验证</p></figure><p id="3ee9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过取 k-模型验证数据的平均精度来计算模型的最终精度。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/4ef1fe4f078c52c4ad33a247db87e693.png" data-original-src="https://miro.medium.com/v2/resize:fit:346/format:webp/1*xUaAYAI_Dql1NtfV-0ycqQ.png"/></div></figure><blockquote class="oj"><p id="be30" class="ok ol it bd om on oo op oq or os lu dk translated">LOOCV 是 k 倍交叉验证的变体，其中 k=n</p></blockquote><h2 id="d2cf" class="mk ml it bd mm mn ot dn mp mq ou dp ms li ov mu mv lm ow mx my lq ox na nb nc bi translated">优点:</h2><ol class=""><li id="a181" class="lv lw it lb b lc nd lf ne li od lm oe lq of lu ma mb mc md bi translated">该模型具有较低的偏差</li><li id="8859" class="lv lw it lb b lc mf lf mg li mh lm mi lq mj lu ma mb mc md bi translated">低时间复杂度</li><li id="f9ba" class="lv lw it lb b lc mf lf mg li mh lm mi lq mj lu ma mb mc md bi translated">整个数据集用于训练和验证。</li></ol><h2 id="c8b0" class="mk ml it bd mm mn mo dn mp mq mr dp ms li mt mu mv lm mw mx my lq mz na nb nc bi translated">缺点:</h2><ol class=""><li id="656a" class="lv lw it lb b lc nd lf ne li od lm oe lq of lu ma mb mc md bi translated">不适合不平衡的数据集。</li></ol></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="4305" class="nr ml it bd mm ns nt nu mp nv nw nx ms jz ny ka mv kc nz kd my kf oa kg nb ob bi translated">5.重复随机子采样验证:</h1><p id="0fa3" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">重复随机子采样验证也称为蒙特卡罗交叉验证，它将数据集随机分为训练和验证。不太可能将数据集 k 倍交叉验证拆分为非分组或折叠，但在这种情况下是随机拆分。</p><p id="eadf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">迭代的次数不是固定的，而是由分析决定的。然后对分割的结果进行平均。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/f0d4490c6e54a8f8c79968663326d287.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*MiLCGYdMlPkjd6OB5v_4ag.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)，重复随机子采样验证</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/4ef1fe4f078c52c4ad33a247db87e693.png" data-original-src="https://miro.medium.com/v2/resize:fit:346/format:webp/1*xUaAYAI_Dql1NtfV-0ycqQ.png"/></div></figure><h2 id="ac14" class="mk ml it bd mm mn mo dn mp mq mr dp ms li mt mu mv lm mw mx my lq mz na nb nc bi translated">优点:</h2><ol class=""><li id="99e6" class="lv lw it lb b lc nd lf ne li od lm oe lq of lu ma mb mc md bi translated">训练和验证分割的比例不依赖于迭代或分区的数量。</li></ol><h2 id="1c22" class="mk ml it bd mm mn mo dn mp mq mr dp ms li mt mu mv lm mw mx my lq mz na nb nc bi translated">缺点:</h2><ol class=""><li id="9f31" class="lv lw it lb b lc nd lf ne li od lm oe lq of lu ma mb mc md bi translated">一些样本可能不会被选择用于训练或验证。</li><li id="b7bc" class="lv lw it lb b lc mf lf mg li mh lm mi lq mj lu ma mb mc md bi translated">不适合不平衡的数据集。</li></ol></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="4cb9" class="nr ml it bd mm ns nt nu mp nv nw nx ms jz ny ka mv kc nz kd my kf oa kg nb ob bi translated">6.分层 k 倍交叉验证:</h1><p id="5f3b" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">对于上面讨论的所有交叉验证技术，它们可能不适用于不平衡的数据集。分层 k-fold 交叉验证解决了不平衡数据集的问题。</p><p id="4c0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在分层 k 折叠交叉验证中，数据集被划分成 k 个组或折叠，使得验证数据具有相同数量的目标类标签实例。这确保了一个特定的类不会过度出现在验证或训练数据中，尤其是当数据集不平衡时。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/e239a78817a71f2ff89f28aa1a6e163d.png" data-original-src="https://miro.medium.com/v2/resize:fit:594/format:webp/1*heFAp1evlvrI_1MGHgvB8w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)，分层 k-fold 交叉验证，每个 fold 都有相同的目标类实例</p></figure><p id="b012" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过取每个折叠得分的平均值来计算最终得分。</p><h2 id="a830" class="mk ml it bd mm mn mo dn mp mq mr dp ms li mt mu mv lm mw mx my lq mz na nb nc bi translated">优点:</h2><ol class=""><li id="f6d4" class="lv lw it lb b lc nd lf ne li od lm oe lq of lu ma mb mc md bi translated">适用于不平衡的数据集。</li></ol><h2 id="a22a" class="mk ml it bd mm mn mo dn mp mq mr dp ms li mt mu mv lm mw mx my lq mz na nb nc bi translated">缺点:</h2><ol class=""><li id="bfb1" class="lv lw it lb b lc nd lf ne li od lm oe lq of lu ma mb mc md bi translated">现在适用于时间序列数据集。</li></ol></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="fb74" class="nr ml it bd mm ns nt nu mp nv nw nx ms jz ny ka mv kc nz kd my kf oa kg nb ob bi translated">7.时间序列交叉验证:</h1><p id="3f7d" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">数据的顺序对于时间序列相关问题非常重要。对于时间相关数据集，将数据随机分割或 k 倍分割成训练和验证可能不会产生好的结果。</p><p id="855d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于时间序列数据集，根据时间将数据拆分为训练和验证，也称为<strong class="lb iu">正向链接法</strong>或<strong class="lb iu">滚动交叉验证</strong>。对于特定的迭代，训练数据的下一个实例可以被视为验证数据。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/3555093adafbade9f7cc1fd618511425.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/format:webp/1*c99ETyWfeteaC_564CDnLw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)，时间序列交叉验证</p></figure><p id="c9f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上图所示，对于第一次迭代，前 3 行被视为训练数据，下一个实例 T4 是验证数据。训练和验证数据选择机会被转发用于进一步的迭代。</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="42a6" class="nr ml it bd mm ns nt nu mp nv nw nx ms jz ny ka mv kc nz kd my kf oa kg nb ob bi translated">8.嵌套交叉验证:</h1><p id="70d6" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">在 k-fold 和分层 k-fold 交叉验证的情况下，我们在训练和测试数据中得到一个差的误差估计。在早期的方法中，超参数调整是单独进行的。当交叉验证同时用于调整超参数和推广误差估计时，需要嵌套交叉验证。</p><p id="5322" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嵌套交叉验证可适用于 k 倍和分层 k 倍变异。阅读下面的文章，了解更多关于嵌套交叉验证及其实现的信息:</p><div class="pb pc gp gr pd pe"><a href="https://machinelearningmastery.com/nested-cross-validation-for-machine-learning-with-python/" rel="noopener  ugc nofollow" target="_blank"><div class="pf ab fo"><div class="pg ab ph cl cj pi"><h2 class="bd iu gy z fp pj fr fs pk fu fw is bi translated">使用 Python 进行机器学习的嵌套交叉验证——机器学习掌握</h2><div class="pl l"><h3 class="bd b gy z fp pj fr fs pk fu fw dk translated">k-fold 交叉验证程序用于评估机器学习模型的性能。</h3></div><div class="pm l"><p class="bd b dl z fp pj fr fs pk fu fw dk translated">machinelearningmastery.com</p></div></div><div class="pn l"><div class="po l pp pq pr pn ps ks pe"/></div></div></a></div></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="941b" class="nr ml it bd mm ns nt nu mp nv nw nx ms jz ny ka mv kc nz kd my kf oa kg nb ob bi translated">结论:</h1><p id="aad9" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">交叉验证用于比较和评估 ML 模型的性能。在本文中，我们讨论了 8 种交叉验证技术及其优缺点。k-fold 和分层 k-fold 交叉验证是最常用的技术。时间序列交叉验证最适用于与时间序列相关的问题。</p><p id="e057" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些交叉验证的实现可以在 sklearn 包中找到。阅读<a class="ae ky" href="https://scikit-learn.org/stable/modules/cross_validation.html" rel="noopener ugc nofollow" target="_blank">该 sklearn 文档</a>了解更多详情。</p><h1 id="acdb" class="nr ml it bd mm ns pt nu mp nv pu nx ms jz pv ka mv kc pw kd my kf px kg nb ob bi translated">参考资料:</h1><p id="6ddb" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">[1]维基百科:<a class="ae ky" href="https://en.wikipedia.org/wiki/Cross-validation_(statistics)" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Cross-validation _(statistics)</a></p><blockquote class="oj"><p id="a135" class="ok ol it bd om on py pz qa qb qc lu dk translated">感谢您的阅读</p></blockquote></div></div>    
</body>
</html>