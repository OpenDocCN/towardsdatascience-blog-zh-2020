<html>
<head>
<title>Pytorch: Step by Step implementation 3D Convolution Neural Network</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Pytorch:逐步实现三维卷积神经网络</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/pytorch-step-by-step-implementation-3d-convolution-neural-network-8bf38c70e8b3?source=collection_archive---------1-----------------------#2020-04-14">https://towardsdatascience.com/pytorch-step-by-step-implementation-3d-convolution-neural-network-8bf38c70e8b3?source=collection_archive---------1-----------------------#2020-04-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="dce7" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">深度学习</h2><div class=""/><div class=""><h2 id="9833" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">了解如何编写 3d CNN 的 PyTorch 实现</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/2ba5bf94224666d70e31c1c024016991.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NW6WueNHs9jDDZeFqToBLg.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">照片由来自<a class="ae lh" href="https://www.pexels.com/photo/photo-of-mountain-with-ice-covered-with-black-and-gray-cloud-640781/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">佩克斯</a>的埃伯哈德·格罗斯加斯泰格拍摄</p></figure><p id="811f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在本文中，我们将简要解释什么是 3d CNN，以及它与普通的 2d CNN 有何不同。然后我们会一步步教你如何用<strong class="lk jd"> Pytorch </strong>实现自己的 3D 卷积神经网络。</p><p id="f51a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这篇文章的一个非常重要的部分可以在我的另一篇关于 3d CNN 在 Keras 的实现的文章中找到。所以如果你倾向于用 Tensorflow/Keras 编码，那么这个链接可能是合适的。</p><p id="e271" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">本文将围绕这<strong class="lk jd"> 4 部分</strong>展开:</p><ul class=""><li id="78bf" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md mj mk ml mm bi translated"><strong class="lk jd"> 1】什么是 3D 卷积神经网络？</strong></li><li id="d65c" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated"><strong class="lk jd">2】3d 数据是什么样子的？(例如 MNIST) </strong></li><li id="55bc" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated"><strong class="lk jd"> 3】现在如何实施？！</strong></li><li id="4e65" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated"><strong class="lk jd"> 4】但是然后一个 3d？为什么</strong></li></ul><div class="ms mt gp gr mu mv"><a rel="noopener follow" target="_blank" href="/step-by-step-implementation-3d-convolutional-neural-network-in-keras-12efbdd7b130"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd jd gy z fp na fr fs nb fu fw jc bi translated">一步一步实现:Keras 中的 3D 卷积神经网络</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">了解如何实现您自己的 3D CNN</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">towardsdatascience.com</p></div></div><div class="ne l"><div class="nf l ng nh ni ne nj lb mv"/></div></div></a></div><h1 id="ec96" class="nk nl it bd nm nn no np nq nr ns nt nu ki nv kj nw kl nx km ny ko nz kp oa ob bi translated">1]什么是 3D 卷积神经网络？</h1><p id="3bf3" class="pw-post-body-paragraph li lj it lk b ll oc kd ln lo od kg lq lr oe lt lu lv of lx ly lz og mb mc md im bi translated">不管我们怎么说，3d CNN 仍然是一个与 2d CNN 非常相似的 CNN。不同之处在于以下几点(非穷尽列举):</p><p id="7292" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> 3d 卷积层</strong></p><p id="a76c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最初，2d 卷积层是输入和不同滤波器之间的逐条目乘法，其中滤波器和输入是 2d 矩阵。(图 1)</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oh"><img src="../Images/15a546b1242ab500760a57e523402e72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wPdQuqvh8Nj8JCU8F0Z9tA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图 1(权利:拥有)</p></figure><p id="23e3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在 3d 卷积层中，使用相同的操作。我们在多对 2d 矩阵上进行这些操作。(图 2)</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oi"><img src="../Images/1f501fa0a4a6bd09fbf734745d0db312.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YM7pKmruZp66oK-rVFWS2w.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图 2(权利:拥有)</p></figure><p id="14d2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">填充选项和幻灯片步长选项的工作方式相同。</p><h1 id="3b3f" class="nk nl it bd nm nn no np nq nr ns nt nu ki nv kj nw kl nx km ny ko nz kp oa ob bi translated">3d 最大池图层</h1><p id="6f62" class="pw-post-body-paragraph li lj it lk b ll oc kd ln lo od kg lq lr oe lt lu lv of lx ly lz og mb mc md im bi translated">2d Maxpool Layers (2x2 filter)是从输入中提取一个 2x2 小正方形的最大元素。(图 3)</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/7859442355a35166bd37d16a15880fe2.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*JlHQg8879Y7MBn5ZyNLwKQ.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图 3(权利:拥有)</p></figure><p id="0033" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，在 3d Maxpool (2x2x2)中，我们寻找宽度为 2 的立方体中的最大元素。此立方体代表由输入的 2x2x2 区域界定的空间。(图 4)</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ok"><img src="../Images/e9689801952b7033879692271df90ff3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nKeWyNasQ4-fxwjlfjPVwg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图 4(权限:拥有)</p></figure><p id="905e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">请注意，操作的数量(与 2d CNN 层相比)乘以所使用的过滤器的大小(不管该层是最大池还是卷积层)，还乘以输入本身的大小。</p><h1 id="77b4" class="nk nl it bd nm nn no np nq nr ns nt nu ki nv kj nw kl nx km ny ko nz kp oa ob bi translated">2]<strong class="ak">3d 数据是什么样子的？</strong></h1><p id="9761" class="pw-post-body-paragraph li lj it lk b ll oc kd ln lo od kg lq lr oe lt lu lv of lx ly lz og mb mc md im bi translated">那么 3d CNN 的数据点是什么样的呢？</p><p id="2acd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">描绘它的一种方法是使用下面的图像(图 5):</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/61f3984510bfc2140d9e2c4b7926103b.png" data-original-src="https://miro.medium.com/v2/resize:fit:588/format:webp/1*YCA3S5A_U-fiPPxlBKU6BA.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图 5(权限:拥有)</p></figure><p id="078d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">其他可用于 CNN 的现有数据集有:</p><ul class=""><li id="c776" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md mj mk ml mm bi translated">RGB-D 设备:<a class="ae lh" href="http://get.google.com/tango/" rel="noopener ugc nofollow" target="_blank">谷歌 Tango </a>，<a class="ae lh" href="https://developer.microsoft.com/en-us/windows/kinect" rel="noopener ugc nofollow" target="_blank">微软 Kinect </a>等。</li><li id="96fa" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated"><a class="ae lh" href="https://en.wikipedia.org/wiki/Lidar" rel="noopener ugc nofollow" target="_blank">激光雷达</a></li><li id="e965" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated"><a class="ae lh" href="https://en.wikipedia.org/wiki/3D_reconstruction_from_multiple_images" rel="noopener ugc nofollow" target="_blank">多幅图像的三维重建</a></li></ul><h1 id="08c5" class="nk nl it bd nm nn no np nq nr ns nt nu ki nv kj nw kl nx km ny ko nz kp oa ob bi translated">3] <strong class="ak">现在如何实现？！</strong></h1><p id="bf33" class="pw-post-body-paragraph li lj it lk b ll oc kd ln lo od kg lq lr oe lt lu lv of lx ly lz og mb mc md im bi translated">您可以亲自尝试我们正在使用的来自<a class="ae lh" href="https://www.kaggle.com/daavoo/3d-mnist" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>的数据集上的代码。</p><p id="9c3f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">笔记本中将使用多个库。这是它的清单。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="635a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">首先，由于数据集有点特殊，我们使用下面的 to helper 函数在将它们提供给网络之前对它们进行处理。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="e9d6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">另外，数据集存储为 h5 文件，因此要提取实际的数据点，我们需要从 h5 文件中读取数据，并使用 to _ categorical 函数将其转换为向量。在这一步中，我们还要准备交叉验证。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="06dc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">假设变量 X_train/X_test 应该分别具有 shape (10000，16，16，16，3)和(2000，16，16，16，3)以及 targets _ train/targets _ test(10000，)(2000，)。但是我们现在再一次把它们转换成 PyTorch 张量格式。我们是这样做的。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="1d94" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里的模型是我们将使用的<strong class="lk jd">架构</strong>:</p><p id="c67e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> 2 套 ConvMake: </strong></p><ul class=""><li id="2f31" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md mj mk ml mm bi translated">一个 3d 卷积层，两个集合的过滤器大小为 3x3x3，跨距为 1x1x1</li><li id="1b8f" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">泄漏的 Relu 激活功能</li><li id="2c43" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">具有过滤器大小(2x2x2)和跨距(2x2x2)的 3d MaxPool 层</li></ul><p id="e06b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> 2 个 FC 层</strong>，分别有<strong class="lk jd"> 512 </strong>和<strong class="lk jd"> 128 个节点。</strong></p><p id="fc31" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">第一 FC 层后的 1 个脱落层</strong>。</p><p id="ef95" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然后，按照以下方式将模型转换成代码:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="772f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">就参数而言，注意你的第一个完全卷积层的输入节点数。我们的数据集的形状是(16，16，16，3)，这就是我们如何得到大小为(2x2x2)的过滤输出。</p><p id="9c61" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果您不熟悉 PyTorch 上的 CNN(即模型的参数或训练),那么可以考虑阅读 PyTorch 上的 CNN 简介！</p><div class="ms mt gp gr mu mv"><a href="https://medium.com/@michaelchan_2146/pytorch-real-step-by-step-implementation-of-cnn-on-mnist-304b7140605a" rel="noopener follow" target="_blank"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd jd gy z fp na fr fs nb fu fw jc bi translated">py torch:CNN 在 MNIST 的一步一步的实施</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">这里有一个关于如何在 PyTorch 中实现 CNN 及其优点的快速教程。我们一行一行地检查，以便您…</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">medium.com</p></div></div><div class="ne l"><div class="oo l ng nh ni ne nj lb mv"/></div></div></a></div><p id="7cf2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是训练的代码。没什么特别的，你显然可以优化(更多！)例如，通过将优化器改为 Adam，调整学习速率(有一些动力)等等…</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="ab0a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">供您参考，经过小样本训练，我们得到了以下准确度和损耗。(图 6 和图 7)</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi op"><img src="../Images/c03622ce75cf490d85b3927edf85f06c.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*Gk3kQ6YHcTlipMoH97aI8g.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图 6(权限:拥有)</p></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/166c6ae2109b7f22b89e3ef8236c6941.png" data-original-src="https://miro.medium.com/v2/resize:fit:794/format:webp/1*z2CRWDboyg1I_uz8ozzXbA.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图 7(权限:拥有)</p></figure><h1 id="c187" class="nk nl it bd nm nn no np nq nr ns nt nu ki nv kj nw kl nx km ny ko nz kp oa ob bi translated">4]但是然后一个 3d？为什么</h1><p id="01f0" class="pw-post-body-paragraph li lj it lk b ll oc kd ln lo od kg lq lr oe lt lu lv of lx ly lz og mb mc md im bi translated">3d CNN 碰巧有许多应用，例如:</p><ul class=""><li id="93fe" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md mj mk ml mm bi translated">IRM 的数据处理和由此得出的推论</li><li id="bef2" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">自驾</li><li id="b3f8" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">距离估计</li></ul><p id="d71a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">好了，差不多就这些了。我希望你尝试一下这项技术！源代码在这里<a class="ae lh" href="https://github.com/miki998/3D_CNN" rel="noopener ugc nofollow" target="_blank">结束</a>！</p></div><div class="ab cl or os hx ot" role="separator"><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow"/></div><div class="im in io ip iq"><p id="c5c4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">感谢您的阅读，如果您喜欢，请关注我、我的<a class="ae lh" href="http://aitechfordummies.com/" rel="noopener ugc nofollow" target="_blank">网站</a>和我的<a class="ae lh" href="https://www.facebook.com/aitechfordummies/" rel="noopener ugc nofollow" target="_blank">脸书</a>页面！</p></div></div>    
</body>
</html>