<html>
<head>
<title>Why We Use Sparse Matrices for Recommender Systems</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么我们在推荐系统中使用稀疏矩阵</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/why-we-use-sparse-matrices-for-recommender-systems-2ccc9ab698a4?source=collection_archive---------23-----------------------#2020-05-09">https://towardsdatascience.com/why-we-use-sparse-matrices-for-recommender-systems-2ccc9ab698a4?source=collection_archive---------23-----------------------#2020-05-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="99b2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">SciPy的稀疏模块介绍</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/43d864a534f068ca5c30262f5fe7ef0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BURO3us9jeELFVoT"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">诺德伍德主题公司在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="51a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在推荐系统中，我们通常使用非常稀疏的矩阵，因为项目领域非常大，而单个用户通常与项目领域的非常小的子集进行交互。以YouTube为例，用户通常会观看数百甚至数千个视频，相比之下，YouTube的语料库中有数百万个视频，导致稀疏度超过99%。</p><p id="fe1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着当我们在一个矩阵中表示<em class="lv">用户</em>(作为行)和<em class="lv">项目</em>(作为列)时，结果是一个由许多零值组成的极其稀疏的矩阵(见下文)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lw"><img src="../Images/09eabf743ce3d4e6dde5cde672948a0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*93klE87pTFwbKKpQ8TkpXQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">稀疏用户-项目矩阵(来源按作者)</p></figure><p id="3a72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在现实生活中，我们如何最好地表示这样一个稀疏的<em class="lv">用户-项目</em>交互矩阵？</p><p id="3cf5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">为什么我们不能只使用<em class="lv"> Numpy数组</em>或<em class="lv"> Pandas DataFrames </em>？</strong></p><p id="ec04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了理解这一点，我们必须了解计算的两个主要约束条件— <strong class="lb iu">时间</strong>和<strong class="lb iu">内存</strong>。前者就是我们所知的“<em class="lv">一个程序运行</em>需要多少时间”，而后者是“<em class="lv">程序使用了多少ram </em>”。前者非常简单，但对于后者，确保我们的程序不消耗所有内存是非常重要的，尤其是当我们处理大型数据集时，否则我们会遇到著名的“<em class="lv">内存不足</em>”错误。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/6a86d55004e9a121e9ffd3c2993ac399.png" data-original-src="https://miro.medium.com/v2/resize:fit:1078/format:webp/0*2tlJGM6WaSXDbaLE.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:stack exchange by<a class="ae ky" href="https://apple.stackexchange.com/questions/158639/your-system-has-run-out-of-application-memory-how-is-that-possible" rel="noopener ugc nofollow" target="_blank">alessandro 308</a></p></figure><p id="9761" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是的，我们电脑上的每个程序和应用程序都使用一些内存(见下图)。当我们运行矩阵计算，并希望将这些稀疏矩阵存储为<em class="lv"> Numpy数组</em>或<em class="lv"> Pandas DataFrame </em>时，它们也会消耗内存。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ly"><img src="../Images/7546acdf3e074ad39bbeaca27f2a8aa6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*op7RBFa5pAeuhh8xOrpgwA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Mac的活动监视器(来源作者)</p></figure><p id="ca31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了形式化这两个约束，它们被称为<strong class="lb iu">时间</strong>和<strong class="lb iu">空间复杂度</strong>(内存)。</p><h2 id="624f" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">空间复杂性</h2><p id="4abc" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">当处理稀疏矩阵时，将它们存储为完整的矩阵(从这一点上称为<strong class="lb iu"> <em class="lv">密集</em> </strong>矩阵)是非常低效的。这是因为一个完整的数组为每个条目的<em class="lv">占用一块内存，所以一个<code class="fe mx my mz na b">n x m</code>数组需要<code class="fe mx my mz na b">n x m</code>块内存。从简单的逻辑角度来看，存储这么多零根本没有意义！</em></p><p id="11e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从数学的角度来看，如果我们有一个<code class="fe mx my mz na b">100,000 x 100,000</code>矩阵，这将需要我们有<code class="fe mx my mz na b">100,000 x 100,000 x 8 = 80 GB</code>的内存来存储这个矩阵(因为每个<em class="lv"> double </em>使用8个字节)！</p><h2 id="d9aa" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">时间复杂度</h2><p id="e26a" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">除了空间复杂性之外，密集矩阵也恶化了我们的运行时。我们将用下面的例子来说明。</p><p id="6381" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么我们如何表示这些矩阵呢？</p><h1 id="4e71" class="nb ma it bd mb nc nd ne me nf ng nh mh jz ni ka mk kc nj kd mn kf nk kg mq nl bi translated">介绍… SciPy的稀疏模块</h1><p id="7192" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">在Python中，稀疏数据结构是在<em class="lv"> scipy.sparse </em>模块中有效实现的，它主要基于<em class="lv"> Numpy </em>数组。实现背后的思想很简单:不是将所有值存储在一个密集的矩阵中，而是以某种格式存储非零值(例如，使用它们的行和列索引)。</p><p id="86c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们深入CSR之前，让我们比较一下使用<em class="lv"> numpy数组</em>和<em class="lv">稀疏矩阵</em>在时间和空间复杂度上的效率差异。</p><pre class="kj kk kl km gt nm na nn no aw np bi"><span id="426c" class="lz ma it na b gy nq nr l ns nt">import numpy as np<br/>from scipy import sparse<br/>from sys import getsizeof</span><span id="0f5d" class="lz ma it na b gy nu nr l ns nt"># <strong class="na iu">Matrix 1</strong>: <em class="lv">Create a dense matrix (stored as a full matrix).</em><br/>A_full = np.random.rand(600, 600)</span><span id="f4b3" class="lz ma it na b gy nu nr l ns nt"># <strong class="na iu">Matrix 2</strong>: <em class="lv">Store A_full as a sparse matrix (though it is dense).</em><br/>A_sparse = sparse.csc_matrix(A_full)</span><span id="4272" class="lz ma it na b gy nu nr l ns nt"># <strong class="na iu">Matrix 3</strong>: <em class="lv">Create a sparse matrix (stored as a full matrix).</em><br/>B_full = np.diag(np.random.rand(600))</span><span id="2f65" class="lz ma it na b gy nu nr l ns nt"># <strong class="na iu">Matrix 4</strong>: <em class="lv">Store B_full as a sparse matrix.</em><br/>B_sparse = sparse.csc_matrix(B_full)</span><span id="dfc4" class="lz ma it na b gy nu nr l ns nt"># Create a square function to return the square of the matrix<br/>def square(A):<br/>    return np.power(A, 2)</span></pre><p id="dc94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们计算这些以不同形式存储的不同矩阵的时间，以及它们使用了多少内存。</p><pre class="kj kk kl km gt nm na nn no aw np bi"><span id="4484" class="lz ma it na b gy nq nr l ns nt">%timeit square(A_full)<br/>print(getsizeof(A_full))</span><span id="3c8e" class="lz ma it na b gy nu nr l ns nt">&gt;&gt;&gt; 6.91 ms ± 84.5 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)<br/>&gt;&gt;&gt; 2880112</span><span id="49c6" class="lz ma it na b gy nu nr l ns nt">%timeit square(A_sparse)<br/>print(getsizeof(A_sparse))</span><span id="5331" class="lz ma it na b gy nu nr l ns nt">&gt;&gt;&gt; 409 ms ± 11.5 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)<br/>&gt;&gt;&gt; 56</span><span id="36ac" class="lz ma it na b gy nu nr l ns nt">%timeit square(B_full)<br/>print(getsizeof(B_full))</span><span id="f5ad" class="lz ma it na b gy nu nr l ns nt">&gt;&gt;&gt; 2.18 ms ± 56.5 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)<br/>&gt;&gt;&gt; 2880112</span><span id="76cd" class="lz ma it na b gy nu nr l ns nt">%timeit square(B_sparse)<br/>print(getsizeof(B_sparse))</span><span id="89bd" class="lz ma it na b gy nu nr l ns nt">&gt;&gt;&gt; 187 µs ± 5.24 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each)<br/>&gt;&gt;&gt; 56</span></pre><p id="15e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显然，当我们使用<em class="lv">稀疏</em>模块存储稀疏矩阵时，可以获得时间和空间方面的最佳性能。</p><h2 id="2e61" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">压缩稀疏行(CSR)</h2><p id="cb4c" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">尽管在<em class="lv"> SciPy </em>中有许多类型的稀疏矩阵，如键的字典(DOK)和列表的列表(LIL)，我将只涉及<strong class="lb iu"> <em class="lv">压缩稀疏行</em> </strong> (CSR)，因为它是最常用和广为人知的格式。</p><p id="b423" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> CSR </strong>(还有CSC，又名压缩稀疏列)用于一次写入多次读取任务[1]。为了有效地表示稀疏矩阵，CSR使用三个numpy数组来存储一些相关信息，包括:</p><ol class=""><li id="ded7" class="nv nw it lb b lc ld lf lg li nx lm ny lq nz lu oa ob oc od bi translated"><code class="fe mx my mz na b">data</code>:非零值的值——这些非零值存储在稀疏矩阵中</li><li id="166d" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated"><code class="fe mx my mz na b">indices</code>:列索引的数组—从第一行开始(从左到右)，我们标识非零位置并返回它们在该行中的索引。在下图中，第一个非零值出现在第0行第5列，因此5作为第一个值出现在<code class="fe mx my mz na b">indices</code>数组中，后面是1(第1行，<strong class="lb iu">第1列</strong>)。</li><li id="6650" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated"><code class="fe mx my mz na b">indptr</code>:代表索引指针，返回一个行开始的数组。这个定义让我困惑，我选择这样解释:它告诉我们每行包含多少个值。在下面的例子中，我们看到第一行包含一个值<code class="fe mx my mz na b">a</code>，因此我们用<code class="fe mx my mz na b">0:1</code>对其进行索引。第二行包含两个值<code class="fe mx my mz na b">b, c</code>，我们从<code class="fe mx my mz na b">1:3</code>开始索引，依此类推。<code class="fe mx my mz na b">len(indptr) = len(data) + 1 = len(indices) + 1</code>因为对于每一行，我们用开始和结束索引来表示它(类似于我们如何索引一个列表)。</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/7d11548c3b5810b9bfcf86ed978b96f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*74DQ3WR5_YjANfOcAyq5oQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:StackOverflow作者<a class="ae ky" href="https://stackoverflow.com/questions/52299420/scipy-csr-matrix-understand-indptr" rel="noopener ugc nofollow" target="_blank"> Tanguy </a></p></figure><h2 id="f205" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">构建csr_matrix有哪些方法？</h2><p id="2704" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated"><strong class="lb iu">创建一个全矩阵并将其转换为稀疏矩阵</strong></p><pre class="kj kk kl km gt nm na nn no aw np bi"><span id="3e9c" class="lz ma it na b gy nq nr l ns nt">some_dense_matrix = np.random.random(600, 600)<br/>some_sparse_matrix = sparse.csr_matrix(some_dense_matrix)</span></pre><p id="c2c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如前所述，这种方法效率不高，因为我们必须先获得这个密集矩阵，这非常耗费内存，然后才能将其转换为稀疏矩阵。</p><p id="22aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">创建一个空的稀疏矩阵</strong></p><pre class="kj kk kl km gt nm na nn no aw np bi"><span id="43db" class="lz ma it na b gy nq nr l ns nt"># format: csr_matrix((row_len, col_len))<br/>empty_sparse_matrix = sparse.csr_matrix((600, 600))</span></pre><p id="2f53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我们<strong class="lb iu">不应该</strong>创建一个空的稀疏矩阵并随后填充它们，因为<code class="fe mx my mz na b">csr_matrix</code>被设计为一次写入多次读取。写入<code class="fe mx my mz na b">csr_matrix</code>将是低效的，应该考虑其他类型的稀疏矩阵，如列表的列表<em class="lv">列表</em>在操纵稀疏结构方面更有效。</p><p id="50ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">用数据创建一个稀疏矩阵</strong></p><pre class="kj kk kl km gt nm na nn no aw np bi"><span id="87af" class="lz ma it na b gy nq nr l ns nt"># <strong class="na iu">method 1</strong><br/># format: csr_matrix((data, (row_ind, col_ind)), [shape=(M, N)])<br/># where a[row_ind[k], col_ind[k]] = data[k]</span><span id="0098" class="lz ma it na b gy nu nr l ns nt">data = [3, 9, 5]<br/>rows = [0, 1, 1]<br/>cols = [2, 1, 2]</span><span id="7a2f" class="lz ma it na b gy nu nr l ns nt">sparse_matrix = sparse.csr_matrix((data, (rows, cols)), <br/>                                  shape=(len(rows), len(cols))<br/>sparse_matrix.toarray()</span><span id="465f" class="lz ma it na b gy nu nr l ns nt">&gt;&gt;&gt; array([[0, 0, 3],<br/>           [0, 9, 5],<br/>           [0, 0, 0]], dtype=int64)</span><span id="5659" class="lz ma it na b gy nu nr l ns nt"># <strong class="na iu">method 2</strong><br/># format: csr_matrix((data, indices, indptr), [shape=(M, N)])<br/># column indices for row i: indices[indptr[i]:indptr[i+1]]<br/># data values: data[indptr[i]:indptr[i+1]]</span><span id="2216" class="lz ma it na b gy nu nr l ns nt">data = [3, 9, 5]<br/>indices = [2, 1, 2]<br/>indptr = [0, 1, 3, 3]</span><span id="f24b" class="lz ma it na b gy nu nr l ns nt">sparse_matrix = sparse.csr_matrix((data, indices, indptr))<br/>sparse_matrix.toarray()</span><span id="0d4b" class="lz ma it na b gy nu nr l ns nt">&gt;&gt;&gt; array([[0, 0, 3],<br/>           [0, 9, 5],<br/>           [0, 0, 0]], dtype=int64)</span></pre><p id="c4c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望这有助于你开始使用稀疏矩阵！</p></div><div class="ab cl ok ol hx om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="im in io ip iq"><p id="73bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="lv">支持我！</em> </strong> —如果你喜欢我的内容并且<em class="lv">没有</em>订阅Medium，请考虑支持我并通过我在这里的推荐链接<a class="ae ky" href="https://davidcjw.medium.com/membership" rel="noopener">订阅</a> ( <em class="lv">注意:你的一部分会员费将作为推荐费</em>分摊给我)。</p><h2 id="8ed1" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">参考</h2><p id="6fc2" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">[1]<a class="ae ky" href="https://rushter.com/blog/scipy-sparse-matrices/" rel="noopener ugc nofollow" target="_blank">Python中的稀疏数据结构</a></p><p id="c880" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[2] <a class="ae ky" href="http://www.acme.byu.edu/wp-content/uploads/2015/11/Vol1Lab4Complexity.pdf" rel="noopener ugc nofollow" target="_blank">复杂性和稀疏矩阵</a></p></div></div>    
</body>
</html>