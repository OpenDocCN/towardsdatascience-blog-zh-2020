<html>
<head>
<title>Exponential Smoothing Approaches In Time Series Forecasting</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">时间序列预测中的指数平滑方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/exponential-smoothing-approaches-to-forecasting-time-series-34e4957ed1a?source=collection_archive---------31-----------------------#2020-09-13">https://towardsdatascience.com/exponential-smoothing-approaches-to-forecasting-time-series-34e4957ed1a?source=collection_archive---------31-----------------------#2020-09-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a773" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">对各种时间序列简单有效</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fe1a36e480d93efea80aaa73ecd91dfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YE-sfncoBLy4DpYMtoIt-Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@oceanng?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Ocean Ng </a>在<a class="ae ky" href="https://unsplash.com/s/photos/clock?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="b821" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我们描述并解释了一些预测时间序列未来值的经典算法。这些算法被称为指数平滑器，已经被广泛使用了几十年。我们用例子传达直觉，一些例子在附录中增加了 Python 代码</p><p id="edbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">指数平滑器在深度机器学习的现代继续保持吸引力。它们简单且易于实现。它们对于短期预测也惊人地有效。尤其是在快速变化的时间序列上。</p><p id="84a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">指数平滑器也有助于增量学习，这通常是快速变化的时间序列的必备工具。这是为了使算法能够跟上变化的特征。例如趋势时间序列突然开始振荡。</p><p id="14ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">基本概念</strong></p><p id="5e48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">时间序列是一段时间内的一系列值。比如某个城市的日平均气温，某只股票的日收盘价，iPhone 11 的月销量。</p><p id="babf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的兴趣在于从时间序列的历史值预测其未来值。(在一个更广泛的公式中，我们不会在这里讨论，我们可能会包括额外的预测，甚至额外的时间序列。)</p><p id="0d0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个问题非常有趣。企业希望预测未来的销售。交易者希望尽可能预测股票或指数价格。我们都想预报天气。</p><p id="516b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，一个关键概念。<em class="lv">预测范围</em>，一个正整数<em class="lv"> h </em>，是我们想要预测的未来步骤数。因此，对于每日时间序列，预测范围 1 将预测第二天的值，预测范围 7 将预测未来 7 天的值。</p><p id="5fdc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们从天真的预测者开始。虽然用起来太幼稚，但它可以作为一个有用的基线来与各种指数平滑器进行比较。</p><p id="7f0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">天真的预测者预测<em class="lv">x</em>(<em class="lv">t</em>+<em class="lv">h</em>)为<em class="lv"> x </em> ( <em class="lv"> t </em>)。注意，不管<em class="lv"> h </em>是什么，预测总是<em class="lv"> x </em> ( <em class="lv"> t </em>)。</p><p id="52e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们的第一个指数平滑器。</p><p id="dd26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">简单指数平滑</strong></p><p id="cfa2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们对时间序列建模如下:</p><p id="4d7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">x</em>(t)=<em class="lv">f</em>(<em class="lv">t</em>)+噪音</p><p id="156f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里<em class="lv"> f </em> ( <em class="lv"> t </em>)是<em class="lv"> t </em>的确定性函数，通过从合适的分布中采样，例如标准正态，在每个时间步长独立产生噪声。这个模型既丰富又直观。<em class="lv"> f </em> ( <em class="lv"> t </em>)对时间序列的确定性分量进行建模。这可能相当复杂，包括多种趋势和多个季节，如果我们愿意的话。<em class="lv">噪声</em>模拟随机波动和其他未建模的影响。</p><p id="90ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一些例子</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="c069" class="mb mc it lx b gy md me l mf mg"><em class="lv">x</em>(<em class="lv">t</em>) = <em class="lv">t</em> + noise<br/><em class="lv">x</em>(<em class="lv">t</em>) = log(<em class="lv">t</em>) + noise<br/><em class="lv">x</em>(<em class="lv">t</em>) = <em class="lv">t</em>² + noise<br/><em class="lv">x</em>(<em class="lv">t</em>) = sin(<em class="lv">t</em>) + noise</span></pre><p id="5ce8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SES 中的主要思想是从<em class="lv"> x </em> ( <em class="lv"> t </em>)，<em class="lv"> x </em> ( <em class="lv"> t </em> -1)，估计<em class="lv"> f </em> ( <em class="lv"> t </em>)，然后用这个估计来预测<em class="lv"> x </em>的未来值。</p><p id="9345" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SES 对<em class="lv"> f </em> ( <em class="lv"> t </em>)的估计是<em class="lv"> x </em> ( <em class="lv"> t </em>)、<em class="lv"> x </em> ( <em class="lv"> t </em> -1)、<em class="lv"> x </em> ( <em class="lv"> t </em> -2)等的指数加权平均值。<em class="lv"> x </em> ( <em class="lv"> t </em>)贡献最多，<em class="lv"> x </em> ( <em class="lv"> t </em> -1)第二多，<em class="lv"> x </em> ( <em class="lv"> t </em> -2)第三多，以此类推。该贡献以指数方式衰减，其速率由衰减参数<em class="lv"> a </em>控制。</p><p id="7ce9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可以递归地表示为</p><p id="79b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">f</em>^(<em class="lv">t</em>)=<em class="lv">ax</em>(<em class="lv">t</em>)+(1-<em class="lv">a</em>)<em class="lv">f</em>^(<em class="lv">t-1</em>)</p><p id="89f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">^在那里提醒我们，这是对<em class="lv"> f. </em>的估计，而不是<em class="lv"> f </em>本身，它对我们是隐藏的。</p><p id="713b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在的预测简直是<em class="lv">x</em>^(<em class="lv">t</em>+<em class="lv">h</em>)=<em class="lv">f</em>^(<em class="lv">t</em>。NF 是 SES 的一个特例，其中<em class="lv">f</em>^(<em class="lv">t</em>)=<em class="lv">x</em>(<em class="lv">t</em>)。</p><p id="01c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单来说，SES 对于一步预测非常有效，即<em class="lv"> h </em> =1。其原因是 SES 不仅平滑噪声，而且它还局部地适合<em class="lv"> f </em> ( <em class="lv"> t </em>)，即在时间<em class="lv"> t </em>时，这在时间序列快速变化时很重要。NF 也适合局部<em class="lv"> f </em> ( <em class="lv"> t </em>)，但是，它并不能平滑噪点。SES 对长期预测无效，即<em class="lv"> h </em> &gt; 1。</p><p id="0719" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">简单指数平滑+趋势(TrES) </strong></p><p id="9c52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如前所述，SES 对长期预测无效。通过向 SES 添加趋势组件，我们可以改善这种情况。直觉很简单。如果在<em class="lv"> x </em> ( <em class="lv"> t </em>)存在局部趋势，趋势组件可以估计它，并使用它来预测稍微更长的时间范围。(这类似于推理:如果你知道一个物体当前的位置和速度，你就可以预测它稍后会在哪里。)</p><p id="86b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个简单的例子。考虑<em class="lv"> x </em> ( <em class="lv"> t </em> ) = <em class="lv"> t </em> +噪声。比方说，我们算出<em class="lv"> x </em> ( <em class="lv"> t </em>)在每个时间单位内增长 1(噪声除外)。知道了这一点，我们可以预测出<em class="lv"> x </em>的值<em class="lv"> h </em>时间单位之后将是其当前值加上<em class="lv"> h </em>。</p><p id="acd4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，让我们更彻底地描述一下算法。为此，让我们将时间序列重新表述为</p><p id="c75c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">x</em>(<em class="lv">t</em>)=<em class="lv">f</em>(<em class="lv">t</em>-1)+<em class="lv">df</em>(<em class="lv">t</em>-1)+噪音</p><p id="5d1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里<em class="lv"> f </em> ( <em class="lv"> t </em>')是<em class="lv"> t </em>'的函数，<em class="lv"> df </em> ( <em class="lv"> t </em>')是时间<em class="lv"> t </em>'的局部趋势。我们把它写成<em class="lv">df</em>(<em class="lv">t</em>’)，因为它是<em class="lv"> f </em>在<em class="lv">t</em>’的一阶导数的离散模拟。</p><p id="575a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个模型相当于我们的第一个模型。我们只是将<em class="lv"> f </em> ( <em class="lv"> t </em>)分解为<em class="lv">f</em>(<em class="lv">t</em>-1)+<em class="lv">df</em>(<em class="lv">t</em>-1)。</p><p id="0f88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一些重构的例子。</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="90b3" class="mb mc it lx b gy md me l mf mg"><em class="lv">x</em>(<em class="lv">t</em>) = (<em class="lv">t</em>-1) + 1 + noise<br/><em class="lv">x</em>(<em class="lv">t</em>) = (<em class="lv">t</em>-1)² + 2<em class="lv">t</em> + noise</span></pre><p id="8a58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种保理有什么意义？我们可以分别估计两项<em class="lv"> f </em> ( <em class="lv"> t </em> -1)和<em class="lv"> df </em> ( <em class="lv"> t </em> -1)。这允许我们对可以精确估计<em class="lv"> df </em> ( <em class="lv"> t </em>)的系列做出合理的长期预测。如在<em class="lv">x</em>(<em class="lv">t</em>)=<em class="lv">t</em>+噪声。在因式分解<em class="lv">x</em>(<em class="lv">t</em>)=(<em class="lv">t</em>-1)+1+噪声下我们看到<em class="lv"> df </em> ( <em class="lv"> t </em>)等于 1。利用这一估计，我们可以对未来做出明智的预测。</p><p id="d99c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们如何估算<em class="lv"> f </em> ( <em class="lv"> t </em> -1)和<em class="lv"> df </em> ( <em class="lv"> t </em> -1)？都是通过指数平滑。<em class="lv"> f </em> ( <em class="lv"> t </em>)的估计是<em class="lv"> x </em> ( <em class="lv"> t </em>)，<em class="lv"> x </em> ( <em class="lv"> t </em> -1)，…。<em class="lv"> df </em> ( <em class="lv"> t </em>)的估计是<em class="lv">x</em>(<em class="lv">t</em>)-<em class="lv">x</em>(<em class="lv">t</em>-1)、<em class="lv">x</em>(<em class="lv">t</em>-1)-<em class="lv">x</em>(<em class="lv">t</em>-2)、<em class="lv"> x </em>()</p><p id="8f7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">姑且把这些估算分别叫做<em class="lv"> f </em> ^( <em class="lv"> t </em>和<em class="lv"> df </em> ^( <em class="lv"> t </em>)吧。现在的天气预报是</p><p id="6e61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">x</em>^(<em class="lv">t</em>+<em class="lv">h</em>)=<em class="lv">f</em>^(<em class="lv">t</em>)+<em class="lv">h</em>*<em class="lv">df</em>^(<em class="lv">t</em>)</p><p id="1abd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意<em class="lv"> f </em> ^( <em class="lv"> t </em>)和<em class="lv"> df </em> ^( <em class="lv"> t </em>)都是局部估计。因此算法适应于<em class="lv"> f </em> ( <em class="lv"> t </em>)以及<em class="lv"> df </em> ( <em class="lv"> t </em>)的变化。我们可以使用<em class="lv"> a </em>和<em class="lv"> b </em>分别作为估计<em class="lv"> f </em>和<em class="lv"> df </em>的指数衰减参数。这给了我们更多的调整余地。(按照下面的例子，我们将讨论调整这些旋钮一点。)</p><p id="2adc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">例子</strong></p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="22b9" class="mb mc it lx b gy md me l mf mg">t           1   2    3    4    5     ...<br/>x           1   2    3    4    5     ...<br/>f^(a=½)     2   2.5  3.25 ... <br/>df^(b=½)    1   1    1    ...</span></pre><p id="ea1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们已经将其初始化为<em class="lv"> x </em> (2)，所以 f  ^(2)为 2。<em class="lv"> df </em> ^(2)为 1 是因为我们已经将其初始化为<em class="lv">x</em>(2)——<em class="lv">x</em>(1)。我们看到，算法已经推导出序列在每个时间步长中增长 1 的趋势。</p><p id="cc41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们在时间<em class="lv"> t </em> =4 时计算<em class="lv"> x </em> ^( <em class="lv"> t </em> +1)。就是<em class="lv">f</em>^(4)+<em class="lv">df</em>^(4)= 3.25+1 = 4.25。接近实际值 x(5) = 5，尽管有点滞后。滞后是指数平滑的结果。我们可以通过提高最近的权重来减少延迟，但这可能会在其他地方产生成本。我们将在下一段讨论这方面的权衡。</p><p id="f2b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们来计算<em class="lv"> x </em> ^( <em class="lv"> t </em> +3)在时间<em class="lv"> t </em> = 4。就是<em class="lv">f</em>^(4)+3 *<em class="lv">df</em>^(4)= 3.25+3 * 1 = 6.25。显然，我们已经能够利用这一趋势来预测未来！x(7)是 7。在这种情况下，长期预测与一步预测一样准确！滞后没有增加。</p><p id="3031" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">平滑参数为我们提供了控制滞后的方法。在我们的例子中，增加<em class="lv"> a </em>的值将减少滞后。另一方面，在我们示例的噪声版本中，过大的<em class="lv"> a </em>值将无法消除噪声。所以，是的，滞后会减少，但预测质量不会。就好像我们在追逐最近的值，随着其中的噪声移动。</p><p id="9ba5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似的推理适用于参数<em class="lv"> b </em>。除了它适用于<em class="lv"> df </em>，即斜率。在我们的例子中，斜率总是相同的，1。所以改变<em class="lv"> b </em>不会有任何效果。然而，如果斜率大于 1 并且其中有乘性噪声，例如<em class="lv"> df </em>是 5 *噪声，其中噪声的平均值为 1 并且围绕其波动，改变<em class="lv"> b </em>可能会影响<em class="lv"> df </em> ^滞后<em class="lv"> df </em>的程度与<em class="lv"> df </em> ^追赶<em class="lv"> df </em>中的噪声的程度。</p><p id="5887" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的方法是在输入数据的适当切片上自动调整这些参数。也就是说，机器学习它们以最小化合适的损失函数。这里就不赘述了。</p><p id="5e63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">简单指数平滑+趋势+季节性(TrSeES) </strong></p><p id="9814" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">参见<strong class="lb iu">，</strong>虽然<strong class="lb iu"> </strong>对呈现局部线性趋势的序列有效，但对具有周期结构的序列并不总是有效。</p><p id="49b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑时间序列</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="505a" class="mb mc it lx b gy md me l mf mg">1, 2, 3, 1, 2, 3, 1, 2, 3, … </span></pre><p id="ec28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SeES 将预测<em class="lv"> x </em> ^(3)接近 4。现实中，<em class="lv"> x </em> (3)是 1。这是一个很大的区别。如果我们知道时间序列每三个时间步重复一次，我们就可以用这个信息来改进预测。</p><p id="53ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们如何改进 TrES？假设序列有单一的季节性，即单一的重复成分，我们知道它的顺序，即<em class="lv"> k </em>。我们可以如下模拟这样的时间序列。</p><p id="c940" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">x</em>(<em class="lv">t</em>)=<em class="lv">tr</em>(<em class="lv">t</em>)+<em class="lv">s</em>(<em class="lv">t</em>)+噪音</p><p id="db41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">s</em>(<em class="lv">t</em>)=<em class="lv">s</em>(<em class="lv">t</em>-<em class="lv">k</em>)</p><p id="3fdf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里<em class="lv"> s </em> ( <em class="lv"> t </em>)是一个重复的时间序列。<em class="lv"> x </em> ( <em class="lv"> t </em>)是将<em class="lv"> s </em> ( <em class="lv"> t </em>)加到另一个时间序列上得到的，我们称之为<em class="lv"> tr </em> ( <em class="lv"> t </em>)。我们称之为<em class="lv"> tr </em> ( <em class="lv"> t </em>)是因为我们认为它是建模<em class="lv"> x </em> ( <em class="lv"> t </em>)的趋势分量。也就是说，现实中，<em class="lv"> tr </em> ( <em class="lv"> t </em>)建模的是从<em class="lv"> x </em> ( <em class="lv"> t </em>)中去掉<em class="lv"> s </em> ( <em class="lv"> t </em>)后剩下的东西。它还可能有其他重复成分。<em class="lv"> tr </em> ( <em class="lv"> t </em>)只是比<em class="lv"> x </em> ( <em class="lv"> t </em>)不太及时。当我们看到下面的算法时会变得很清楚，即使去掉一个季节性也是一种进步。</p><p id="e62c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个这样表达的例子。</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="4120" class="mb mc it lx b gy md me l mf mg"><em class="lv">t</em>   1  2  3  4  5  6  7  8  9<br/><em class="lv">s</em>   <strong class="lx iu">1  2  3</strong>  1  2  3  1  2  3<br/><em class="lv">tr</em>  1  2  3  4  5  6  7  8  9<br/><em class="lv">x</em>   2  4  6  5  7  9  8  10 12</span></pre><p id="2d42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们如何估算<em class="lv"> tr </em> ( <em class="lv"> t </em>)和<em class="lv"> s </em> ( <em class="lv"> t </em>)？首先，我们假设我们知道顺序<em class="lv"> k </em>。一个合理的方法是获得一个新的时间序列<em class="lv">yk</em>(<em class="lv">t</em>)=<em class="lv">x</em>(<em class="lv">t</em>)-<em class="lv">x</em>(<em class="lv">t</em>-<em class="lv">k</em>)，去掉季节性的影响。然后我们可以应用 TrES 来预测<em class="lv">yk</em>^(<em class="lv">t</em>+<em class="lv">h</em>。然后我们将<em class="lv">x</em>(<em class="lv">t</em>+<em class="lv">h</em>-<em class="lv">k</em>)与<em class="lv">yk</em>^(<em class="lv">t</em>+<em class="lv">h</em>)相加，这给我们一个合理的预测<em class="lv">x</em>^(<em class="lv">t</em>+<em class="lv">h</em></p><p id="c681" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看上面的例子是如何进行的。</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="0723" class="mb mc it lx b gy md me l mf mg">t   1  2  3  4  5  6  7  8  9<br/>x   2  4  6  5  7  9  8  10 12<br/>y3  3  3  3  3  3  3</span></pre><p id="83eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了，y3 很容易预测。其值始终为 3。消除季节性的影响帮助很大！TrES 会很快算出 y3 是常数。</p><p id="9073" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们来预测一下<em class="lv">x</em>(<em class="lv">t</em>+3 = 12)在<em class="lv"> t </em> =9。首先我们预测 y<em class="lv">y</em>3(12)是 3。然后我们把<em class="lv"> x </em> (9) = 12 加到这个预测上。我们得到<em class="lv"> x </em> ^(12) = 3+12 = 15。除非未来发生变化，否则这个预测是准确的。</p><p id="2563" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只要<em class="lv"> h </em>小于或等于<em class="lv"> k </em>我们就可以这样做。(如果<em class="lv"> h </em>大于<em class="lv"> k </em>，<em class="lv">t</em>+<em class="lv">h</em>-<em class="lv">k</em>将大于<em class="lv"> t </em>，即进入未来！)</p><p id="74ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">平滑季节性</strong></p><p id="bec8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以进一步改进。在从<em class="lv">y</em>^<em class="lv">k</em>(<em class="lv">t</em>+<em class="lv">h</em>)推导<em class="lv"> x </em> ^( <em class="lv"> t </em> + <em class="lv"> h </em>时，我们可以添加它的平滑版本，而不是添加<em class="lv">x</em>(<em class="lv">t</em>+<em class="lv">h</em>-<em class="lv">k</em>)。用什么方法抚平？取<em class="lv">x</em>(<em class="lv">t</em>+<em class="lv">h</em>-<em class="lv">k</em>)、<em class="lv">x</em>(<em class="lv">t</em>+<em class="lv">h</em>-2<em class="lv">k</em>)、<em class="lv">x</em>(<em class="lv">t</em>+<em class="lv">h</em>-3<em class="lv">k 的指数加权平均值</em></p><p id="abb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么我们认为平滑季节性可以进一步改善旅游？考虑季节性成分中含有乘性噪声的情况。即，</p><p id="94ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv"> s </em> ( <em class="lv"> t </em> ) =噪声*<em class="lv">s</em>(<em class="lv">t</em>-<em class="lv">k</em>)</p><p id="d872" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中，为了便于说明，假设该噪声是一个均值为 1、标准差大于 0 但远小于 1 的高斯噪声。这样的季节性模型是现实的。</p><p id="4724" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，<em class="lv">x</em>(<em class="lv">t</em>+<em class="lv">h</em>-<em class="lv">k</em>)，x(<em class="lv">t</em>+<em class="lv">h</em>-2<em class="lv">k</em>)，<em class="lv">x</em>(<em class="lv">t</em>+<em class="lv">h</em>-3TrES 将解决我们之前遇到的附加噪声问题。但不是这种乘法噪声。使用从<em class="lv">x</em>(<em class="lv">t</em>-<em class="lv">k</em>)、x(<em class="lv">t</em>+<em class="lv">h-</em>2<em class="lv">得到的<em class="lv">x</em>(<em class="lv">t</em>+<em class="lv">h</em>-<em class="lv">k</em>)的指数平滑估计值</em></p><p id="09c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> Python 代码</strong></p><p id="52ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我把它放在这里，这样人们可以看到一些实际的代码。也就是说，它有些部分是不完整的。也可能有 bug。所以，如果你想让它正常工作，就要准备做一些额外的工作。</p><p id="8f57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">时间序列发生器</strong></p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="2d74" class="mb mc it lx b gy md me l mf mg">import numpy as np<br/>noise = np.random.normal<br/>f = lambda t: &lt;<strong class="lx iu">some function of t</strong>&gt;<br/>x = [f(t) + noise for t in range(n)]</span></pre><p id="8e00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过适当地选择 f，我们可以生成各种时间序列。包括有趋势的，有周期的，两者都有。</p><p id="3e65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们展示各种指数平滑器的代码。作为所有这些语句的第一条语句，添加</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="57f2" class="mb mc it lx b gy md me l mf mg">x = [1,2,3,4,5,6,7]</span></pre><p id="e063" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，更好的方法是，使用时间序列生成器生成 x。</p><p id="bd92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> SES 算法</strong></p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="49b3" class="mb mc it lx b gy md me l mf mg">&lt;<strong class="lx iu">initialize x here</strong>&gt;<br/>f = x[0]<br/>y = {}<br/>a = 0.5<br/>for t in range(len(x)):<br/>   xhat_tplus1 = f        # <strong class="lx iu">forecast next value</strong><br/>   f = a*x[t] + (1-a)*f</span></pre><p id="3822" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> TrES 算法</strong></p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="b20f" class="mb mc it lx b gy md me l mf mg">&lt;<strong class="lx iu">initialize x here</strong>&gt;<br/>f,df    = x[1], x[1]-x[0]<br/>y       = {}<br/>h, a, b = 3, 0.5, 0.5</span><span id="ed1c" class="mb mc it lx b gy mh me l mf mg">for t in range(2,len(x)):<br/>   x_hat_tplush = f + h*df # <strong class="lx iu">forecast h steps ahead</strong><br/>   f  = a*x[t] + (1-a)*f<br/>   df = b*(x[t]-x[t-1]) + (1-b)*df</span></pre><p id="aed5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> TrSeES </strong></p><p id="4d3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这需要更多的工作来实现端到端。它也不能平滑季节性。</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="f5ad" class="mb mc it lx b gy md me l mf mg">&lt;<strong class="lx iu">initialize x here</strong>&gt;<br/>yk = [x[t] — x[t-k] for t in range(k,n)]</span><span id="d3cb" class="mb mc it lx b gy mh me l mf mg">&lt;<strong class="lx iu">Run TrES on yk</strong>&gt;</span><span id="7e1f" class="mb mc it lx b gy mh me l mf mg"># Forecast x. forecast_y(t+h) uses the forecast model built earlier on yk using TrES.</span><span id="71d8" class="mb mc it lx b gy mh me l mf mg">xhat_tplus_h = forecast_y(t+h) + x[t+h-k]</span></pre><p id="42df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">延伸阅读</strong></p><ol class=""><li id="c921" class="mi mj it lb b lc ld lf lg li mk lm ml lq mm lu mn mo mp mq bi translated">https://otexts.com/fpp2/第七章是关于指数平滑法。</li></ol></div></div>    
</body>
</html>