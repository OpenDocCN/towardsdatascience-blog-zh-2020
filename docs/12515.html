<html>
<head>
<title>Analyzing PyPI package download statistics and building a data application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分析 PyPI 包下载统计数据并构建数据应用程序</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/analyzing-pypi-package-download-statistics-and-building-a-data-application-c30f4f708e38?source=collection_archive---------39-----------------------#2020-08-28">https://towardsdatascience.com/analyzing-pypi-package-download-statistics-and-building-a-data-application-c30f4f708e38?source=collection_archive---------39-----------------------#2020-08-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="28fe" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用数据堆栈构建数据应用程序</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4e8a9aed32540651c8892758471bb60c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ji3-53BXBA8SPSI2"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用数据堆栈构建的最终数据应用程序</p></figure><p id="a93d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">尽管 Jupyter 笔记本对于编写代码和与数据进行交互是必不可少的，但仍然需要为非技术受众构建应用程序。幸运的是，Python 生态系统提供了一个广泛而活跃的开源生态系统，不仅用于数据分析，还用于使用数据和可视化库构建数据应用程序。</p><p id="3404" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这篇文章中，我将尝试向您概述如何使用<a class="ae lu" href="https://github.com/dstackai/dstack" rel="noopener ugc nofollow" target="_blank"> dstack </a>构建交互式数据应用程序。我们还将学习如何使用 Python、pandas 和<a class="ae lu" href="http://plot.ly/" rel="noopener ugc nofollow" target="_blank"> plot.ly </a>分析和可视化数据，以及使用 Python 和<code class="fe lv lw lx ly b">pandas</code>查询来自 Google 的 BigQuery 的数据。</p><p id="fc55" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">出于教学目的，我们将分析 Python 包的下载统计数据，并使我们的应用程序可视化以下内容:</p><ul class=""><li id="452e" class="lz ma it la b lb lc le lf lh mb ll mc lp md lt me mf mg mh bi translated">下载次数最多的软件包</li><li id="8da6" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">过去一个月、六个月和十二个月的下载次数</li><li id="ca2e" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">每个版本的包、操作系统和 Python 版本的下载次数</li></ul><p id="93b5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将使用<a class="ae lu" href="https://github.com/dstackai/dstack" rel="noopener ugc nofollow" target="_blank"> dstack </a>构建一个交互式应用程序，以仪表板的形式可视化这些统计数据。本教程中构建的应用程序可以在<a class="ae lu" href="https://dstack.ai/gallery/pypi/downloads" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="61d5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于渴望在分析数据的背景下学习 Python 的初级数据科学家来说，本教程可能会很有意思。</p><p id="517a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意，本笔记本中的分析仅用于教育目的。如果您发现错误或对代码或结果有疑问，请发送电子邮件至<a class="ae lu" href="mailto:team@dstack.ai" rel="noopener ugc nofollow" target="_blank"> team@dstack.ai </a>。</p><p id="3108" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本教程最初灵感来自<a class="ae lu" href="http://pepy.tech/" rel="noopener ugc nofollow" target="_blank"> pepy.tech </a>。</p><h1 id="255d" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">关于 Python 包下载统计数据集</h1><p id="c4f9" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">为什么在本教程中使用 Python 包下载统计？首先，因为数据是公开的。其次，因为 PyPI 提供了方便地访问这些数据的方法。第三，制作一个应用程序来可视化这些数据可能是用 Python 构建数据应用程序的一个很好的例子。</p><p id="c894" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该分析的数据来自哪里？Python 包的下载数据由 PyPI 存储在 Google 的 BigQuery 中。每天的下载数据存储在与模式<code class="fe lv lw lx ly b">the-psf:pypi.downloadsYYYYMMDD</code>匹配的单独的表中。这些表有<a class="ae lu" href="https://s.caremad.io/lPpTF6rxWZ/Screen-Shot-2016-05-21-14-17-45.png" rel="noopener ugc nofollow" target="_blank">这个</a>模式。</p><p id="1d51" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意，BigQuery 中的这些数据只有在你有自己的 Google Cloud 账号的情况下才能访问。要访问这些数据，您必须按照 BigQuery 的定价(每 TB 5.00 美元)付费。考虑到数据量，查询可能非常昂贵。你查询的越多，扫描的数据就越多，你支付的费用也就越多。</p><h1 id="a800" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">传递谷歌云凭证</h1><p id="56b8" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">要连接到 Google 的 BigQuery，我们必须进行身份验证。BigQuery 是 Google Cloud 的一部分，用于身份验证，需要通过 OAuth 2.0 传递 Google 凭证。</p><p id="b737" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">可以通过多种方式从 Python 连接到 BigQuery。在本教程中，我们将使用 pandas，这是使用 BigQueryusing <a class="ae lu" href="https://pandas-gbq.readthedocs.io/" rel="noopener ugc nofollow" target="_blank"> pandas_gbq </a>最简单的方法。</p><p id="9001" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于认证，<code class="fe lv lw lx ly b">pandas_gbq</code>集成了<a class="ae lu" href="https://google-auth.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> google-auth </a>库。</p><p id="bdce" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了开始使用 pandas_gbq，您必须传递凭证以及与凭证相关联的项目名称。</p><p id="5cb7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本教程中，我们将使用服务帐户凭据。这种类型的凭证必须通过 Google Cloud 控制台创建。一旦创建了凭证，就必须下载相应的 JSON 文件，以便在这个笔记本上使用。</p><p id="f8dd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意，带有凭证的 JSON 文件必须只存储在安全的环境中。</p><p id="caa6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将使用以下代码从 Python 加载凭证:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="9d95" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们必须用获得的凭证和项目名称初始化<code class="fe lv lw lx ly b">pandas_gbq</code>的上下文:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="84bb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在使用<code class="fe lv lw lx ly b">pandas_gbq</code>之前，请确保您已经为此项目启用了 BigQuery API，并且与获取的凭证相关联的服务角色具有访问 BigQuery 和运行 BigQuery 作业的权限。</p><p id="c898" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们已经准备好从 Python 查询 PyPI 包下载统计数据。</p><h1 id="590d" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">在我们将要构建的应用程序上</h1><p id="7c46" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">在这个例子中，我们将使用<code class="fe lv lw lx ly b">dstack</code>来构建一个应用程序，它显示按项目版本、Python 版本和操作系统分组的各个项目的下载。为了使教程足够简单，我们将限制它只显示下载最多的前 100 个项目的数据。</p><p id="b007" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为什么是<code class="fe lv lw lx ly b">dstack</code>？首先，与其他框架相比，构建和部署<code class="fe lv lw lx ly b">dstack</code>应用程序需要几天时间。其次，<code class="fe lv lw lx ly b">dstack</code>不要求你做 web 编程，写 UI 脚本，或者其他开发和部署应用程序通常需要的事情。不用编写应用程序，您可以将数据推送到一个<code class="fe lv lw lx ly b">dstack</code>服务器，并提供一个声明性的逻辑，说明它应该如何与用户输入交互。开始时，你会对这种方法感到惊讶，但后来你会发现它是多么简单而强大。</p><p id="f435" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">应用程序将如何工作？在我们的应用程序中，我们将使用<code class="fe lv lw lx ly b">pandas_gbq</code>查询数据，使用“plotly”进行可视化，并推送与以下参数相关的结果可视化:</p><ul class=""><li id="56c0" class="lz ma it la b lb lc le lf lh mb ll mc lp md lt me mf mg mh bi translated">项目的名称</li><li id="ff55" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">时间段(例如，过去 30 天、过去 6 个月、过去 12 个月)</li><li id="0e2b" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">数据的维度(例如，按项目版本、Python 版本或操作系统分组)</li></ul><p id="aacb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦我们推送带有所有参数的可视化效果，<code class="fe lv lw lx ly b">dstack</code>会自动将其编译到一个仪表板中。本教程中构建的应用程序可以在这里找到<a class="ae lu" href="https://dstack.ai/gallery/pypi/downloads" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="9c98" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本教程的大部分内容都是一个简单步骤的重复:</p><ol class=""><li id="2946" class="lz ma it la b lb lc le lf lh mb ll mc lp md lt nm mf mg mh bi translated">运行 SQL 查询，聚合<code class="fe lv lw lx ly b">X</code>期间的下载，按项目名称、<code class="fe lv lw lx ly b">Y</code>和<code class="fe lv lw lx ly b">Z</code>分组，其中</li><li id="1697" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt nm mf mg mh bi translated"><code class="fe lv lw lx ly b">X</code> / <code class="fe lv lw lx ly b">Y</code>可能是<code class="fe lv lw lx ly b">30 days</code> / <code class="fe lv lw lx ly b">day</code>、<code class="fe lv lw lx ly b">6 months</code> / <code class="fe lv lw lx ly b">week</code>、<code class="fe lv lw lx ly b">12 months</code> / <code class="fe lv lw lx ly b">month</code></li><li id="5f29" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt nm mf mg mh bi translated"><code class="fe lv lw lx ly b">Z</code>可以是<code class="fe lv lw lx ly b">project version</code>、<code class="fe lv lw lx ly b">python version</code>和<code class="fe lv lw lx ly b">operational system</code></li><li id="52b8" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt nm mf mg mh bi translated">制作一个情节</li><li id="913d" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt nm mf mg mh bi translated">用相应的参数如<code class="fe lv lw lx ly b">project name</code>、<code class="fe lv lw lx ly b">X</code>、<code class="fe lv lw lx ly b">Z</code>到<code class="fe lv lw lx ly b">dstack</code>将图推送到<code class="fe lv lw lx ly b">dstack</code></li></ol><h1 id="0af4" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">放弃</h1><p id="b403" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">请注意，下面的一些查询可能会查询超过 6 个月或更长时间的 BigQuery 数据。避免在不必要的时候运行整个笔记本。阅读关于如何避免对 BigQuery 运行不必要的查询的章节<code class="fe lv lw lx ly b">Optimization </code>。</p><h1 id="4883" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">获得 100 个下载量最高的 PyPI 项目</h1><p id="4cdd" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">在本教程中，我们将只关注下载次数最多的前 100 个项目。我们要做的第一件事是获取这 100 个项目的名称。为此，我们将按项目汇总过去 30 天的下载量，按降序排列，并取前 100 个。</p><p id="cab6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是我们如何用<code class="fe lv lw lx ly b">pandas_gbq</code>来做这件事:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="cef1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如您所见，<code class="fe lv lw lx ly b">pandas_gbq.read_gbq</code>函数的结果是一个<code class="fe lv lw lx ly b">pandas.DataFrame</code>。</p><p id="6e68" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">查询中最重要的部分是表名<code class="fe lv lw lx ly b">the-psf.pypi.downloads*</code>和使用<code class="fe lv lw lx ly b">_TABLE_SUFFIX</code>的<code class="fe lv lw lx ly b">WHERE</code>子句。它是做什么的？它只扫描从<code class="fe lv lw lx ly b">the-psf.pypi.downloads</code>开始到当前日期的最后 30 天内结束的表中的数据。这样，我们可以确保查询只扫描最近 30 天内的数据。为什么这很重要？这很重要，因为我们使用 BigQuery，我们按每 TB 扫描数据付费。为了优化查询成本，限制被扫描的数据量总是很重要的。在这篇文章的后面，我们将再次回到定价因素，并看看优化它的其他方法。</p><p id="fa16" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">同时，让我们声明一个变量<code class="fe lv lw lx ly b">top_projects</code>，并将其分配给下载量最高的前 100 个项目的名称列表:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h1 id="b6c1" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">获取过去 30 天每个项目版本的下载量</h1><p id="21a7" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">下面是第一个 SQL 查询:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="c5dd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们已经有了一个包含我们需要的数据的数据框，我们将为项目的每个版本制作一个下载图。前五个版本将作为单独的图表。剩下的将是一个名为<code class="fe lv lw lx ly b">Other</code>的图表。下面是项目<code class="fe lv lw lx ly b">pandas</code>的一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/d6123ad17bd61fef97eb44e828b2f64d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2GtBm8tFRsBNauLo"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">过去 30 天每个项目版本的下载量</p></figure><h1 id="fb0f" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">获取过去 30 天每个 Python 版本的下载量</h1><p id="7136" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">下面是与上面几乎相同的查询，但是现在它按照主要 Python 版本(<code class="fe lv lw lx ly b">REGEXP_EXTRACT(details.python, r'^\d*')</code>)对数据进行分组:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="ce32" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">项目的样本地块<code class="fe lv lw lx ly b">pandas</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/a1b330ad9c2226e32602f0f5e0753cff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gh4E66Mgn04vv43w"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">过去 30 天每个 Python 版本的下载量</p></figure><h1 id="6eff" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">获取过去 30 天每个操作系统的下载量</h1><p id="0b53" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">下面是另一个查询，现在按<code class="fe lv lw lx ly b">operational system</code>分组:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="fcbb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">项目的样本地块<code class="fe lv lw lx ly b">pandas</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/fe5eddcee64b6dee98578dd725d417b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yq5sBNPeNfP8tjYd"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">过去 30 天每个操作系统的下载量</p></figure><h1 id="f9a6" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">获取过去 6 个月每个项目版本的下载量</h1><p id="a979" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">在下面的单元格中，我们将重复上述步骤，但现在是针对不同的<code class="fe lv lw lx ly b">X</code>、<code class="fe lv lw lx ly b">Y</code>、<code class="fe lv lw lx ly b">Z</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="b3dd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">项目的样本地块<code class="fe lv lw lx ly b">pandas</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/a4d1aaf984003f60c34afd6285706512.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vSDcaZip4Dg4mwso"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">获取过去 6 个月每个项目版本的下载量</p></figure><h1 id="b0fa" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">获取过去 6 个月每个 Python 版本的下载量</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="f7b0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">项目的样本地块<code class="fe lv lw lx ly b">pandas</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/1daf268aa53bded59dcf0ae1b5d56dad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*N1cVAyn4ojOEu74F"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">过去 6 个月每个 Python 版本的下载量</p></figure><p id="6793" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这段代码最有趣的部分是对<code class="fe lv lw lx ly b">fig.update_xaxes</code>的调用。为了确保图表中显示的所有数据在给定的一周内都是完整的，我们将图的边界相应地向右和向左移动一周，以排除可能具有不完整数据的周。</p><h1 id="d53d" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">获取过去 6 个月每个操作系统的下载量</h1><p id="b9a4" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">项目的样本地块<code class="fe lv lw lx ly b">pandas</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/7e55146b3fb2167155970ef8191db315.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5ffNZVrSEembVUfe"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">过去 6 个月每个操作系统的下载量</p></figure><h1 id="77d7" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">获取过去 12 个月每个项目版本的下载量</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="3868" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">项目的样本地块<code class="fe lv lw lx ly b">pandas</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/0b414a0fa665d755782c89618c1fe4f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*krLozW29L3_MjBxg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">过去 12 个月每个项目版本的下载量</p></figure><h1 id="02fd" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">获取过去 12 个月每个 Python 版本的下载量</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/df030130e4ebe76bd5796c69952a5666.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CJJ3QmV_m-ZslR8A"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">过去 12 个月每个 Python 版本的下载量</p></figure><h1 id="7964" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">获取过去 12 个月每个操作系统的下载量</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/7aa149c6fd12c651e3cb0ecfeb5fbe1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Oz2Z1_HWzrXmEIPk"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">过去 12 个月每个操作系统的下载量</p></figure><h1 id="afde" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">设置数据堆栈</h1><p id="1156" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">现在我们已经有了数据和可视化，我们准备设置一个<code class="fe lv lw lx ly b">dstack</code>服务器并构建应用程序。</p><p id="cc62" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lv lw lx ly b">dstack</code>是一个开源框架，可以通过 pip 安装</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="6b90" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">或者使用 conda:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="5168" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lv lw lx ly b">dstack</code>有两个组件:</p><ol class=""><li id="c99d" class="lz ma it la b lb lc le lf lh mb ll mc lp md lt nm mf mg mh bi translated">托管数据并运行已发布应用程序的服务器</li><li id="e307" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt nm mf mg mh bi translated">将数据推送到服务器的客户端 Python 包</li></ol><p id="970e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">服务器可以在本地启动，也可以在专用服务器上启动。为了在本地启动 dstack 服务器，必须运行以下命令:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="2c17" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦服务器启动，用户就可以使用 Python 客户端包来推送数据。</p><h1 id="da80" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">最佳化</h1><p id="e518" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">现在我们已经设置了一个<code class="fe lv lw lx ly b">dstack</code>服务器，这里有一个重要的说明，关于如何使用 BigQuery 或类似的按扫描数据量收费的服务。使用此类服务的最佳方式是避免重新运行不必要的查询，这可能会非常昂贵。这可以通过在盘上本地缓存数据或其他方式来容易地完成。如果您必须定期更新可视化效果，这一点尤其重要。</p><p id="347e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有趣的是，您也可以使用<code class="fe lv lw lx ly b">dstack</code>来存储缓存数据。这可以通过以下方式实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="068c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里发生的是日期被放入两个“堆栈”:<code class="fe lv lw lx ly b">"pypi/top-projects"</code>和<code class="fe lv lw lx ly b">"pypi/raw-data"</code>。这个“堆栈”的概念概括了<code class="fe lv lw lx ly b">dstack</code>是如何建造的。每个栈都被版本化(意味着它在被更新时存储所有的修订)，并且可以包含一个或多个与参数相关联的工件。这样的工件可以包括数据帧、ML 模型或可视化。在上面的代码中，我们使用堆栈来存储数据帧。一旦发布了工件，就可以通过<code class="fe lv lw lx ly b">dstack</code>的 web 界面访问它，或者通过 Python 代码获取它。下面是实现这一点的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="733c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，变量被赋予我们存储的实际数据帧。推送时，提取的数据框具有完全相同的方案。当按计划以自动化方式进行处理时，这种方法特别有用。</p><h1 id="ce68" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">使用数据堆栈制作数据应用程序</h1><p id="00cb" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">既然我们已经介绍了如何设置一个<code class="fe lv lw lx ly b">dstack</code>服务器以及如何在那里缓存数据，那么让我们把所有的东西放在一起，最终构建一个应用程序。您会惊讶地发现，从头开始构建一个应用程序所需要做的工作是如此之少。</p><p id="8292" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是构建整个应用程序的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="6984" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们在这段代码中做的是:</p><ol class=""><li id="3c22" class="lz ma it la b lb lc le lf lh mb ll mc lp md lt nm mf mg mh bi translated">创建一个框架(功能<code class="fe lv lw lx ly b">dstack.create_frame</code></li><li id="5bc9" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt nm mf mg mh bi translated">对于每个可视化，在框架内创建一个附件以及可视化图形和相关参数，如<code class="fe lv lw lx ly b">"Project"</code>、<code class="fe lv lw lx ly b">"Period"</code>和<code class="fe lv lw lx ly b">"Group by"</code>(函数<code class="fe lv lw lx ly b">dstack.StackFrame.commit</code>)</li><li id="b2fd" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt nm mf mg mh bi translated">推动框架(功能<code class="fe lv lw lx ly b">dstack.StackFrame.push</code>)</li></ol><p id="2a3e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果将构建可视化效果的代码移动到单独的函数中，可以显著简化该代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="423c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如你所看到的，与应用程序本身相关的代码甚至比专用于绘图的代码还要少。</p><p id="f3b2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">将这些数据推送到<code class="fe lv lw lx ly b">dstack</code>服务器后会发生什么？服务器动态构建一个交互式应用程序，您可以在其中更改<code class="fe lv lw lx ly b">Project</code>、<code class="fe lv lw lx ly b">Period</code>和<code class="fe lv lw lx ly b">Group by</code>的值，并查看与所选值相对应的可视化效果。由于数据是预先计算的，因此可以从缓存中提供，从而在高负载下高效扩展(例如，如果应用程序由大型团队使用)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4e8a9aed32540651c8892758471bb60c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ji3-53BXBA8SPSI2"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用数据堆栈构建的最终数据应用程序</p></figure><h1 id="2501" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">计划常规作业</h1><p id="210c" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">正如您在上面看到的，在<code class="fe lv lw lx ly b">dstack</code>中的数据应用程序可以是一个静态报告，可以定期手动或自动更新。</p><p id="3142" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">自动化将要求您设置运行上述代码的常规作业。虽然 12 个月和 6 个月的数据可以按月计划，但每日作业可以每天或每周运行。这样，您可以优化成本，并确保数据始终是最新的。</p><p id="dbe2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae lu" href="https://hub.docker.com/repository/docker/dstackai/dstack" rel="noopener ugc nofollow" target="_blank"> Docker </a>版本的<code class="fe lv lw lx ly b">dstack</code>以及<a class="ae lu" href="https://dstack.ai/" rel="noopener ugc nofollow" target="_blank"> in-cloud </a>版本确实提供内置工作。使用这些作业，您可以按照需要的节奏安排更新堆栈。</p><p id="d450" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">暂时就这样了。希望这篇文章能帮助你学习如何用 Python 和 stack 构建数据应用。感谢您抽出时间阅读本文。</p><p id="6819" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lv lw lx ly b">dstack</code>是一个非常新的工具，目前提供非常基本的功能，他们计划在接下来的几个月内推出更多高级功能。欢迎您查看他们的<a class="ae lu" href="https://trello.com/b/CJOnEjrr/public-roadmap" rel="noopener ugc nofollow" target="_blank">公共路线图</a>，向他们的<a class="ae lu" href="https://github.com/dstackai/dstack/issues/" rel="noopener ugc nofollow" target="_blank">问题跟踪者</a>提交特性请求，当然，也可以在他们的<a class="ae lu" href="https://discord.gg/8xfhEYa" rel="noopener ugc nofollow" target="_blank">不和谐聊天</a>中分享您的反馈。</p><h1 id="2e42" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">资源</h1><p id="242d" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">以下是您可能会发现有用的资源列表:</p><ul class=""><li id="d512" class="lz ma it la b lb lc le lf lh mb ll mc lp md lt me mf mg mh bi translated"><a class="ae lu" href="https://packaging.python.org/guides/analyzing-pypi-package-downloads/" rel="noopener ugc nofollow" target="_blank">分析 PyPI 包下载量</a></li><li id="59ba" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated"><a class="ae lu" href="https://cloud.google.com/bigquery/docs/quickstarts/quickstart-web-ui" rel="noopener ugc nofollow" target="_blank">使用云控制台的 BigQuery 快速入门</a></li><li id="5451" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated"><a class="ae lu" href="https://console.cloud.google.com/bigquery?pli=1&amp;p=the-psf&amp;d=pypi&amp;t=downloads&amp;page=table" rel="noopener ugc nofollow" target="_blank"> PyPi 下载双查询表</a></li><li id="3dd0" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated"><a class="ae lu" href="https://pandas-gbq.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">熊猫-gbq 的文件</a></li><li id="70d9" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">google-auth 的文档</li><li id="9db4" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated"><a class="ae lu" href="http://docs.dstack.ai/" rel="noopener ugc nofollow" target="_blank"> dstack 的文档</a></li><li id="b9e9" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated"><a class="ae lu" href="https://github.com/dstackai/dstack-tutorials-py/blob/master/pypi-downloads.ipynb" rel="noopener ugc nofollow" target="_blank">GitHub 上的源代码</a></li><li id="29e7" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated"><a class="ae lu" href="https://dstack.ai/gallery/pypi/downloads" rel="noopener ugc nofollow" target="_blank">dstack . ai 上的最终应用</a></li></ul></div></div>    
</body>
</html>