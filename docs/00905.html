<html>
<head>
<title>A Swift Introduction To Common Lisp</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Common Lisp 快速入门</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-swift-introduction-to-common-lisp-16a2f154c423?source=collection_archive---------18-----------------------#2020-01-26">https://towardsdatascience.com/a-swift-introduction-to-common-lisp-16a2f154c423?source=collection_archive---------18-----------------------#2020-01-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9af5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">熟悉有史以来第二种高级编程语言。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f626963b5edf148e8152c5bc34f93f8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LwO2bPfbgg0lW55xDVmqZQ.jpeg"/></div></div></figure><p id="7c50" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi lq translated">在 1958 年，一个新成员以第二高级和第一函数式编程语言 Lisp 的形式出现了。Lisp 是一种伟大的开源语言，尽管它已经存在了很长时间，但这些年来一直在不断地发展。此外，Lisp 已经发展成许多更小的方言，这些方言通常允许在 Lisp 内部更容易地完成特定的任务。Lisp 是一种很棒的语言，因为它得到了很好的支持，有很好的文档记录，并且非常受人尊敬。最流行的现代 Lisp 方言有 Common Lisp、闭包、Scheme、Machine Lisp、Arc，当然还有 Emacs Lisp。</p><p id="283a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你来自任何一种不是基于 Lisp 本身的语言，Lisp 是一种非常不同的语言。Lisp 编程非常具有功能性，它围绕着使用宏来断言数据的功能。这是一件需要注意的重要事情，因为语法一点都不相似。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="6074" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">获取 CLisp</h1><p id="5617" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">Common Lisp (CLisp)实际上是可爱的 GNU 基金会的产品，并且是完全免费和开源的。要在非 Unix 系统上安装 Common Lisp，您需要从 SourceForge 或其他地方找到的镜像下载二进制文件。由于我不知道如何在 Windows 上安装应用程序，我就不讲我不知道如何做的东西了。至于 Linux，你当然可以使用你的包管理器，在我的例子中是 dnf。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="ca22" class="ni mh it ne b gy nj nk l nl nm">sudo dnf install clisp</span></pre><p id="1906" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">至于 MacOS，你也可以通过你的软件包管理器来安装它:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="1eeb" class="ni mh it ne b gy nj nk l nl nm">brew install clisp</span></pre><blockquote class="nn"><p id="bfb7" class="no np it bd nq nr ns nt nu nv nw lp dk translated"><a class="ae nx" href="https://formulae.brew.sh/formula/clisp" rel="noopener ugc nofollow" target="_blank">(这里是公式化)</a></p></blockquote><p id="d036" class="pw-post-body-paragraph ku kv it kw b kx ny ju kz la nz jx lc ld oa lf lg lh ob lj lk ll oc ln lo lp im bi translated">要测试您的 CLisp 安装，只需在终端中输入以下命令就可以进入 REPL</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="dece" class="ni mh it ne b gy nj nk l nl nm">clisp</span></pre><p id="c025" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">变成巴什。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="97d2" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">基本语法</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/404190d9d05beb25988543a1ea181d50.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*6XyGmRKePjjVYFeY7HGukQ.jpeg"/></div></figure><p id="b280" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">今天，我将专门在 REPL 工作。这是为了确保文本编辑保持编译器、编辑器和语法高亮之间的一致性，而且我们不必保存文件。因此，首先，我将像之前一样使用命令进入 CLisp REPL</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="c0a1" class="ni mh it ne b gy nj nk l nl nm">clisp</span></pre><p id="bd14" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">关于 Lisp 首先需要了解的是语法。Lisp 的语法当然很漂亮，也很酷，但最重要的是它是独一无二的。在 Lisp 中，几乎所有的命令都包含在括号中，并且使用空格作为语法，所有的命令都不区分大小写(所有的命令都是大写的)。)在我开始解释 Lisp 之前，我认为需要解释 Lisp 的范例，函数式编程范例。这对于学习 Lisp 非常重要，尤其是在学习非函数式语言的时候。</p><blockquote class="nn"><p id="1cc9" class="no np it bd nq nr oe of og oh oi lp dk translated"><a class="ae nx" rel="noopener" target="_blank" href="/functional-programming-is-awesome-c94bcd150ae6">阅读更多关于函数式编程的内容(由我！)</a></p></blockquote><p id="4962" class="pw-post-body-paragraph ku kv it kw b kx ny ju kz la nz jx lc ld oa lf lg lh ob lj lk ll oc ln lo lp im bi translated">首先，构造类型只能保存数据，不能保存函数。Lisp 的独特之处在于数据可以作为代码使用，甚至可以在后台编写代码。构造类型被称为构造函数，与面向对象的类不同，尽管它们填补了同样的空白。换句话说，如果不使用多态，我们就不能将函数作为构造函数的属性来应用。例如，在 Python 中，我们可以有一个名为 cl 的类，该类可以有一个子类，并有可以用 cl.function 或 cl.subclass 调用的子方法。</p><p id="61ff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">换句话说，Lisp 函数调用总是以方法开头，而不是以变量开头。这也可以和另外两种函数式语言相提并论，它们是我一生的挚爱，</p><blockquote class="nn"><p id="19e7" class="no np it bd nq nr oe of og oh oi lp dk translated">朱莉娅</p></blockquote><p id="5c06" class="pw-post-body-paragraph ku kv it kw b kx ny ju kz la nz jx lc ld oa lf lg lh ob lj lk ll oc ln lo lp im bi translated">另一个很酷，</p><blockquote class="nn"><p id="ce10" class="no np it bd nq nr oe of og oh oi lp dk translated">稀有</p></blockquote><p id="0efa" class="pw-post-body-paragraph ku kv it kw b kx ny ju kz la nz jx lc ld oa lf lg lh ob lj lk ll oc ln lo lp im bi translated">所以很可能来自这两种语言会让你更接近。所以让我们从定义一个变量开始。当我们命名一个变量时，注意语法的结构是很重要的。在下面的例子中，我使用 setq，它将生成一个全局变量。我们使用 setq 的方式与使用 Lisp 中任何其他函数的方式基本相同。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="bc40" class="ni mh it ne b gy nj nk l nl nm"> v-method   vvv-Variable Value<br/>(setq x '(5 4 8 4))<br/>      ^-Variable Name</span></pre><p id="1534" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这将创建一个我们可以用列表类型的 x 调用的变量，它是通过在括号前放一个'来定义的。下面是 Lisp 中的简单加法:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="d8f5" class="ni mh it ne b gy nj nk l nl nm">   vvv Parameters<br/>(+ 5 5)<br/> ^ Method (addition)</span></pre><p id="3547" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里有一个类似的例子，打印一个字符串:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="c1d1" class="ni mh it ne b gy nj nk l nl nm">(prin1 "Hello World!")</span></pre><p id="fa62" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要记住的最重要的事情是方法和变量是如何对齐的，因为这将使你更习惯于在 Lisp 中调用函数的方式。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="a365" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">函数和 For 循环</h1><p id="bd0e" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">Lisp 中的函数是用 defunc 定义的。我们可以定义一个函数，它有一个名字，和一组参数，参数之间用空格分开，放在一组单独的括号中。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="8cd9" class="ni mh it ne b gy nj nk l nl nm">(defunc add (x y)<br/>; (We'll add logic later)<br/>)</span></pre><p id="158b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个函数定义非常典型，就好像我们把它与 Python、Julia 和 R 相比，R 是唯一一个显著不同的。</p><h2 id="f387" class="ni mh it bd mi oj ok dn mm ol om dp mq ld on oo ms lh op oq mu ll or os mw ot bi translated">计算机编程语言</h2><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="f1bc" class="ni mh it ne b gy nj nk l nl nm">def add(x, y):</span></pre><h2 id="dad3" class="ni mh it bd mi oj ok dn mm ol om dp mq ld on oo ms lh op oq mu ll or os mw ot bi translated">朱莉娅</h2><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="d698" class="ni mh it ne b gy nj nk l nl nm">function add(x, y)</span></pre><h2 id="5f1d" class="ni mh it bd mi oj ok dn mm ol om dp mq ld on oo ms lh op oq mu ll or os mw ot bi translated">稀有</h2><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="63dd" class="ni mh it ne b gy nj nk l nl nm">add &lt;- function(x, y){</span><span id="06ef" class="ni mh it ne b gy ou nk l nl nm">}</span></pre><p id="3cd6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，给定我前面展示的添加 5 + 5 的代码，很容易猜到我们在这里需要做什么，特别是有了其他语言的经验之后。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="648c" class="ni mh it ne b gy nj nk l nl nm">(defunc add (x y) (+ x y))</span></pre><blockquote class="nn"><p id="2b6f" class="no np it bd nq nr ns nt nu nv nw lp dk translated">是的，真的就这么简单。</p></blockquote><p id="8815" class="pw-post-body-paragraph ku kv it kw b kx ny ju kz la nz jx lc ld oa lf lg lh ob lj lk ll oc ln lo lp im bi translated">当我学习一门新语言时，我总是喜欢写一个函数，它是一个均值函数。虽然这是非常基本的，但是尝试写一个需要 sigma(总和)和 n(样本大小)。)求和以及样本大小对于很多编程都是必不可少的，尤其是统计编程，这也是我特别使用 Lisp 的原因。</p><p id="2165" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如上所述，我们需要两个东西，n 和σx。幸运的是，Lisp 有一个长度函数，可以这样使用:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="10e0" class="ni mh it ne b gy nj nk l nl nm">(length x)</span></pre><p id="ac17" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">很简单，对吧？唯一的问题是求和没那么简单。为了对数组求和，我们需要使用 reduce。我们可以通过简单的操作做到这一点:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="23e7" class="ni mh it ne b gy nj nk l nl nm">(defun sum  (x) (reduce '+ y)<br/>)</span></pre><p id="a0aa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Lisp 中的 Reduce 是一种简单的说法，即从开始处开始，到列表的末尾。为了进行这样的操作，因为它是基于数组的，我们需要使用'+操作数，而不是+操作数。现在，我们可以用我们的函数来总结一个数组:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="45d2" class="ni mh it ne b gy nj nk l nl nm">(sum x)</span></pre><p id="0dfd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们已经有了求和的方法，我们需要决定如何来设计这个函数。以最简洁的方式，不定义任何变量，并通过计算建立回报。这当然是编写这个函数的最佳方式，但是以这种方式思考公式可能会特别令人困惑——所以在这种情况下，我每次都会使用它，而且在大多数情况下我都会这样做。然而，当有大量的数学运算时，这可能会很困难，有时会导致使用更多的编译能力和内存。)</p><p id="defa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是首先，让我们写出我们的平均函数。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="2674" class="ni mh it ne b gy nj nk l nl nm">(defunc mean (x) (/ (sum x) (length x))</span></pre><p id="3027" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了更好地理解这一点，我们首先在括号中进一步计算数学(运算顺序)，然后对 sigma 和 n 执行除法运算。</p><p id="add4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了使用我们的函数，记住‘是指数组，所以在 Lisp 中创建一个数组，我们使用:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="4211" class="ni mh it ne b gy nj nk l nl nm">(setq x '(5 8 4 6 8))</span></pre><p id="0774" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所有的暗都被空间隔开。</p><p id="6993" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">至于 for 循环，想象一下 Python、Julia 或 R 中典型的简明 for 循环:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="9ce6" class="ni mh it ne b gy nj nk l nl nm">x = [u = u * 5 for u in x]</span></pre><p id="326f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在 Lisp 中，我们将完全遵循这种循环风格，除了一个例外，我们将首先在括号中使用 loop，并且逻辑将需要翻转，使用单词“do”来代替，就像这样:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="94d8" class="ni mh it ne b gy nj nk l nl nm">(loop for w in array do (+ w 1))</span></pre><p id="3e73" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这当然只是给每个元素加一。另一个需要记住的重要事情是，do 后面的括号之外的任何逻辑都不会包含在循环中，这意味着层次结构中的所有内容都将期待一个返回，类似于我们的 mean 函数，操作的顺序决定了先做什么。</p><h1 id="2316" class="mg mh it bd mi mj ov ml mm mn ow mp mq jz ox ka ms kc oy kd mu kf oz kg mw mx bi translated">再用力一点…</h1><p id="f6e9" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">最后一部分，我们要写一个函数来计算标准差。为了计算一个数组的标准差，我们需要μ。幸运的是，我们刚刚创建了一个函数，它将为我们提供 mu。使用 mean 函数和 setq，我前面谈到的全局变量定义(这会使 dims 公开，这并不总是一个好主意，但我认为知道如何使用全局变量比私有变量更好。)我们可以将平均值定义为μ，并使用一个简单的 for 循环来计算。在 for 循环内部，我们有(x 减去 mu)，我们可以通过将这个数乘以它本身来执行。</p><p id="2d41" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如我前面讨论的，这个选项可能不总是优于 setq，为了看起来更简洁，可能不值得这样做。无论如何，在我们将这个 for 循环应用到我们的列表之后，我们将能够求平均值的平方根并返回标准偏差。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="a559" class="ni mh it ne b gy nj nk l nl nm">(defun std (x) (setq μ (mean x)) (loop for y in x do<br/>  (* (- x μ) (- x μ)))) (sqrt (mean x)<br/>)</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="44dc" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">总结一下…</h1><p id="7da6" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">我喜欢编写 Lisp，我真的希望这篇文章能为有兴趣学习它的人提供很多信息。我有可能在未来做类似的工作。在我看来，Lisp 是一种美丽的语言，它在我心中占有一席之地。虽然 Lisp 肯定不同于许多其他语言，但我认为它的语法看起来很酷也很漂亮。在相关新闻中，<a class="ae nx" href="http://lathe.ai" rel="noopener ugc nofollow" target="_blank">我的 Julia 模块，用于机器学习、统计和数据处理的车床</a>即将进入 Lisp、Python 和 R，Python 和 R 在 Julia 中本地运行包，Lisp 从包的 Lisp 端口本地运行包。此外，这让我对 Lisp 感到兴奋和激动。</p></div></div>    
</body>
</html>