<html>
<head>
<title>Get the Most out of scikit-learn with Object-Oriented Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">充分利用scikit——学习面向对象编程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/get-the-most-out-of-scikit-learn-with-object-oriented-programming-d01fef48b448?source=collection_archive---------28-----------------------#2020-06-25">https://towardsdatascience.com/get-the-most-out-of-scikit-learn-with-object-oriented-programming-d01fef48b448?source=collection_archive---------28-----------------------#2020-06-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2d15" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">浏览一个数据科学示例，增强您的Python编码能力！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/e928857ebf3ef3cb24d72f193c461bf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/1*hMGRmj9Wz-xGVJhlc08szQ.png"/></div></figure><p id="ce34" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">作为数据科学家，我们都熟悉<a class="ae lm" href="https://scikit-learn.org/" rel="noopener ugc nofollow" target="_blank"> scikit-learn </a>，这是Python中最常用的机器学习和数据分析库之一。我个人在我的大部分专业项目中都使用它和熊猫。</p><p id="36c9" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">然而，直到最近，当我需要构建一个定制的回归估计器时，我才充分利用了scikit-learn。我惊喜地发现，创建一个新的兼容的估计器类是如此容易，这都归功于scikit-learn组件的面向对象设计。</p><p id="f014" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在本文中，我将带您了解一个常见的数据科学工作流，并演示面向对象编程(OOP)的一个用例。特别是，您将学习如何使用继承的概念来定制transformer对象，这允许我们扩展现有类的功能。由于继承，这个转换器将很容易适合scikit-learn管道，以构建一个简单的机器学习模型。</p><h2 id="410d" class="ln lo it bd lp lq lr dn ls lt lu dp lv kz lw lx ly ld lz ma mb lh mc md me mf bi translated">激励人心的例子。</h2><p id="dae6" class="pw-post-body-paragraph kq kr it ks b kt mg ju kv kw mh jx ky kz mi lb lc ld mj lf lg lh mk lj lk ll im bi translated">为了更清楚地说明问题，让我们看一个受零售商营销启发的实际例子。假设我有一个<a class="ae lm" href="https://github.com/andrew-alberts/transformer-example/blob/master/sample_rfm_data.csv" rel="noopener ugc nofollow" target="_blank">数据集</a>，其中每条记录代表一个客户，并且有与购买<a class="ae lm" href="https://www.investopedia.com/terms/r/rfm-recency-frequency-monetary-value.asp" rel="noopener ugc nofollow" target="_blank">最近、频率和货币价值</a>相关的度量(即特征)。使用这些功能，我们希望预测客户是否会加入零售商的奖励卡计划。这模拟了一个真实的场景，我们希望预测哪些客户是营销的最佳目标。请参见下面的客户记录数据示例:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi ml"><img src="../Images/b364b5129308ff68d29c14c10575ae34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IKXvpkefXEgMQG-poY3uxQ.png"/></div></div><p class="mq mr gj gh gi ms mt bd b be z dk translated">我们客户数据的前十行。请注意用红色圈出的缺失值。</p></figure><p id="ae9a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">数据的一个显著特点是缺失，即在观察值中存在缺失值。这些值将被渲染为NaN的，一旦被熊猫读取，将不会在我们的机器学习模型中工作。为了构建我们的模型，我们需要估算缺失特征的值(即，用推断的数量替换缺失值)。虽然有多种数据插补技术，但为了简单起见，假设我们想尝试对任何缺失值进行列均值或中值插补。</p><p id="d84a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">那么，我们应该使用哪个统计量，平均值还是中间值？找出答案的一个简单方法是尝试两个选项，并评估哪一个在网格搜索中产生最佳性能，也许可以使用scikit-learn的<a class="ae lm" href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.GridSearchCV.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ks iu"> GridSearchCV </strong> </a>。</p><p id="935b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">一个错误是计算整个训练集的平均值和中值，然后用这些值进行估算。更严格地说，我们需要计算这些数据的统计数据，不包括坚持折叠。这看起来很复杂，但是多亏了OOP，我们可以通过<em class="mu">继承</em>轻松实现我们自己的转换器，它将与scikit-learn兼容。从那里，我们可以将transformer插入到scikit-learn <a class="ae lm" href="https://scikit-learn.org/stable/modules/generated/sklearn.pipeline.Pipeline.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ks iu">管道</strong> </a>中，这是一个与transformer对象列表以及estimator对象一起排序的对象，用于构建我们的模型。</p><h2 id="1d72" class="ln lo it bd lp lq lr dn ls lt lu dp lv kz lw lx ly ld lz ma mb lh mc md me mf bi translated">构建自定义输入转换器。</h2><p id="5eab" class="pw-post-body-paragraph kq kr it ks b kt mg ju kv kw mh jx ky kz mi lb lc ld mj lf lg lh mk lj lk ll im bi translated">为了开始为我们的转换器构建类，我们将编写类定义和构造函数。特别注意(<strong class="ks iu"> TransformerMixin </strong>，<strong class="ks iu"> BaseEstimator </strong>)，这表明我们继承了这两个类。这将使我们创建的<a class="ae lm" href="https://github.com/andrew-alberts/transformer-example/blob/master/custom_impute_transformer.py" rel="noopener ugc nofollow" target="_blank"><strong class="ks iu">custom impute transformer</strong></a>类的对象与scikit-learn的其他组件兼容，方法是提供<strong class="ks iu"> GridSearchCV </strong>(如<strong class="ks iu"> <em class="mu"> get_params </em> </strong>)所期望的方法的实现，并指示我们创建的对象是正确的类型(如transformers)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="1396" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">接下来，我们将实现<strong class="ks iu"> <em class="mu"> fit </em> </strong>方法。给定数据集<em class="mu">X</em>,<strong class="ks iu"><em class="mu">fit</em></strong>计算每列的平均值或中值，可用于以后的插补。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="51e1" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">最后，我们编写了<strong class="ks iu"> <em class="mu">转换</em> </strong>的方法。该方法将我们希望转换的数据集作为参数，应用已经计算的“估算值”并用它们填充NaN值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="3739" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">下面是一个在小样本上使用自定义transformer对象的例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="fe03" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">以下是打印到控制台的结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/f10e9e7517f243ef3f82a67f1380112b.png" data-original-src="https://miro.medium.com/v2/resize:fit:810/format:webp/1*PV30ZacxuVjQ2W_OQCeXYw.png"/></div><p class="mq mr gj gh gi ms mt bd b be z dk translated">红色表示x1的平均值，蓝色表示特征x2的平均值。</p></figure><p id="2e22" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">注意，我们创建的功能已经在scikit-learn的<a class="ae lm" href="https://scikit-learn.org/stable/modules/generated/sklearn.impute.SimpleImputer.html" rel="noopener ugc nofollow" target="_blank"><strong class="ks iu">simple impute</strong></a>类中可用。我决定在这里从头实现它，因为它易于构建，并且很好地展示了创建更复杂的转换器所需的内容。</p><h2 id="c541" class="ln lo it bd lp lq lr dn ls lt lu dp lv kz lw lx ly ld lz ma mb lh mc md me mf bi translated">将转换结果传输到ML模型中。</h2><p id="ba04" class="pw-post-body-paragraph kq kr it ks b kt mg ju kv kw mh jx ky kz mi lb lc ld mj lf lg lh mk lj lk ll im bi translated">我们将创建一个管道，将自定义转换器的结果级联到逻辑回归模型中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="2fea" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">加载数据。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="e845" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">通过传递元组列表来创建管道。每个元组都有流水线阶段的名称(在这个例子中是<em class="mu">估算</em>和<em class="mu">模型</em>)以及用于估计器的变换器的对象。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="0617" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">对于网格搜索，我们将搜索以确定哪种类型的插补是最好的，因此在<em class="mu"> param_grid </em>中有条目" imput _ _ imput _ type ":[" mean "，" median"]。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="f22d" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们将获得最好的管道，并从中获得训练预测。注意，我们可以在best_pipe对象上调用<strong class="ks iu"> <em class="mu">预测</em> </strong>函数。这有效地将首先从<strong class="ks iu">custom impute transformer</strong>运行<strong class="ks iu"> <em class="mu">转换</em> </strong>，然后从逻辑回归运行<strong class="ks iu"> <em class="mu">预测</em> </strong>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="607a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">最佳流水线和训练精度的输出如下。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi my"><img src="../Images/a28298e4266052884bcd3ee788bd0b2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*83Uh3iI80W1G4jQkmABsVw.png"/></div></div><p class="mq mr gj gh gi ms mt bd b be z dk translated">GridSearchCV确定的最佳管道。请注意红色方框中的最佳超参数值。</p></figure><h2 id="207f" class="ln lo it bd lp lq lr dn ls lt lu dp lv kz lw lx ly ld lz ma mb lh mc md me mf bi translated">演示变压器做我们想要的。</h2><p id="9da5" class="pw-post-body-paragraph kq kr it ks b kt mg ju kv kw mh jx ky kz mi lb lc ld mj lf lg lh mk lj lk ll im bi translated">在这个例子中，我们清楚地表明，我们需要transformer来计算除了保留折叠之外的所有折叠的统计数据。为了证明我们的代码确实做到了这一点，我们将进一步利用继承来构建一个impute transformer对象，该对象完全执行我们最初的transformer所做的事情，并添加了在交叉验证的每次迭代中输出不同统计数据的功能。</p><p id="0939" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们将再次使用继承来创建<a class="ae lm" href="https://github.com/andrew-alberts/transformer-example/blob/master/custom_impute_output_transformer.py" rel="noopener ugc nofollow" target="_blank"><strong class="ks iu">customimputoutputtransformer</strong></a>，它是<strong class="ks iu">customimputtransformer</strong>的子类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="7394" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们唯一需要实现的功能就是<strong class="ks iu"> <em class="mu"> fit </em> </strong>。事实上，我们将使用通过使用<a class="ae lm" href="https://docs.python.org/3/library/functions.html#super" rel="noopener ugc nofollow" target="_blank"><strong class="ks iu"><em class="mu"/></strong></a>调用标准<strong class="ks iu"> <em class="mu"> fit </em> </strong>函数得到的结果，并简单地用控制台输出扩充它，如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="1e66" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">现在我们需要做的就是改变我们在管道中使用的对象，并在运行它时监视输出是什么。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="b0bd" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">为了简洁起见，我可视化了一个特性的输出。你可以在<a class="ae lm" href="https://github.com/andrew-alberts/transformer-example/blob/master/verbose_output.txt" rel="noopener ugc nofollow" target="_blank"> Github </a>上看到实际的打印输出。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/82267b8635fbaa90458b038c64a21969.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*PHEXQXe2eSrfRJ7BuY8wkw.png"/></div></figure><p id="154f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">它的行为符合预期。<strong class="ks iu"> GridSearchCV </strong>的每次迭代都产生四个训练折叠的统计数据，而不是计算一个全局值。</p><h2 id="90e9" class="ln lo it bd lp lq lr dn ls lt lu dp lv kz lw lx ly ld lz ma mb lh mc md me mf bi translated">结论</h2><p id="5be9" class="pw-post-body-paragraph kq kr it ks b kt mg ju kv kw mh jx ky kz mi lb lc ld mj lf lg lh mk lj lk ll im bi translated">在本文中，我们了解了如何使用继承(OOP的一个基础方面)来解决现实世界中的数据科学问题。我展示的例子很简单，但是，您可以使用相同的框架为您的项目构建更复杂的类。</p><p id="e8d6" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">所有的代码、数据和结果都可以从这个<a class="ae lm" href="https://github.com/andrew-alberts/transformer-example" rel="noopener ugc nofollow" target="_blank"> Github repo </a>中提取。本文中展示的例子是完全可复制的，所以您可以随意提取代码并自己使用它。</p></div></div>    
</body>
</html>