<html>
<head>
<title>Implementing Linear and Polynomial Regression From Scratch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从头开始实现线性和多项式回归</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/implementing-linear-and-polynomial-regression-from-scratch-f1e3d422e6b4?source=collection_archive---------13-----------------------#2020-02-16">https://towardsdatascience.com/implementing-linear-and-polynomial-regression-from-scratch-f1e3d422e6b4?source=collection_archive---------13-----------------------#2020-02-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="f0ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本教程中，我们将介绍如何使用最小二乘法拟合数据来实现简单的线性回归模型。之后，我们将模型扩展到多项式回归模型，以便捕捉更复杂的信号。我们将使用均方差来衡量我们生成的每个模型的拟合质量。你可以从我的<a class="ae kl" href="https://github.com/christam96/Linear-And-Polynomial-Regression-From-Scratch" rel="noopener ugc nofollow" target="_blank"> Github repo </a>下载我用来写这篇文章的所有资源👍。</p><h2 id="1d25" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">加载和绘制数据</h2><p id="f50a" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">让我们首先将训练数据加载到内存中，并将其绘制成图表，以了解我们正在处理的内容。将<code class="fe lk ll lm ln b">train_features</code>视为 x 值，将<code class="fe lk ll lm ln b">train_desired_outputs</code>视为 y 值。下图是所有值的散点图。</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="lt lu l"/></div></figure><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/0882bdeeab151c43dfa82005a98fec8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/format:webp/1*xoqD6XWPNxGIb0TjQF0eJg.png"/></div><p class="ly lz gj gh gi ma mb bd b be z dk translated">我们训练数据的散点图</p></figure><p id="a4bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在是时候写一个<a class="ae kl" href="https://en.wikipedia.org/wiki/Simple_linear_regression" rel="noopener ugc nofollow" target="_blank">简单线性回归</a>模型来尝试拟合数据了。我们的目标是找到一条与图中所示的训练数据的基本模式最相似的线。我们将使用<a class="ae kl" href="https://en.wikipedia.org/wiki/Least_squares" rel="noopener ugc nofollow" target="_blank">最小二乘法</a>用最能描述训练集的系数来参数化我们的模型，然后再看看该模型对以前从未见过的数据的概括程度。回想一下，简单的线性回归模型是由 y 轴截距和回归线的斜率来参数化的。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/cdaf344ae4403a38d3e3b08dbb220881.png" data-original-src="https://miro.medium.com/v2/resize:fit:610/format:webp/1*8DCyu8BWpT3MvMS3jZ9oHw.png"/></div><p class="ly lz gj gh gi ma mb bd b be z dk translated">简单线性回归模型</p></figure><h2 id="dd8d" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">训练我们的线性回归模型</h2><p id="4e4b" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">寻找参数以使我们的模型符合训练数据的过程称为“训练”我们的模型。给定一个设计矩阵<em class="md"> X </em>和一个目标输出的列向量<em class="md"> y </em>，我们可以使用下面的等式通过最小二乘回归找到我们的线性模型的最佳截距和斜率系数(要深入了解该等式背后的线性代数概念，请参见本文):</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi me"><img src="../Images/8d13ff084fbed3dcdc1709218063f769.png" data-original-src="https://miro.medium.com/v2/resize:fit:728/format:webp/1*lrn3WqEZDc5XNY-PiHF2fw.png"/></div></figure><p id="4d0f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们是这样编码的。我们首先创建一个设计矩阵<em class="md"> X </em>，其中包含一列 1(为了估计 y 轴截距)和另一列 1，用于保存我们的解释变量<em class="md"> x </em>的值。然后，我们取 X 与其转置的点积的倒数，并将其与 X 转置和 training _ desired _ outputs 的 y 值)的点积进行点积。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mf"><img src="../Images/6b89850763cd82c767b930afb08cc1e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:352/format:webp/1*beeVfsfqhGXMtSwnWRcTmQ.png"/></div></div><p class="ly lz gj gh gi ma mb bd b be z dk translated">我们的设计矩阵 X</p></figure><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="71d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是我们的模型如何拟合训练数据。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/4ac129e233c94c013381d65d6dfacb17.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*yloTczTA6vGMwH_qGJ8IxQ.png"/></div></figure><p id="045c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以通过使用<a class="ae kl" href="https://en.wikipedia.org/wiki/Mean_squared_error" rel="noopener ugc nofollow" target="_blank">均方误差</a> (MSE)来计算我们的线和训练集中实际数据点之间的平均平方差，从而量化我们的模型与数据的拟合程度。MSE 计算如下:</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="lt lu l"/></div></figure><pre class="lo lp lq lr gt ml ln mm mn aw mo bi"><span id="d6a0" class="km kn iq ln b gy mp mq l mr ms">Mean squared error on the training set:  2.1739455790492586</span></pre><p id="e4ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还不错！均方误差是对估计量质量的一种度量，在我们的例子中，估计量是我们的线性回归模型。MSE 总是非负的，值越接近零越好。</p><h2 id="b2ea" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">测试我们的线性回归模型</h2><p id="d602" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">现在让我们看看我们的模型对 T2 以前没有见过的数据预测得有多好。我们称这一步为测试阶段。记住，我们的模型是由返回的系数定义的</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi me"><img src="../Images/8d13ff084fbed3dcdc1709218063f769.png" data-original-src="https://miro.medium.com/v2/resize:fit:728/format:webp/1*lrn3WqEZDc5XNY-PiHF2fw.png"/></div></figure><p id="f22a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，上面的函数返回 w，其中包含 y 轴截距和斜率的系数。<strong class="jp ir">我们将使用用于训练模型的相同值来测试我们的模型。</strong></p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="8a50" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是我们的模型如何拟合测试数据:</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/77ec90e45ff053b39676d21bc1dd9991.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*QAMD4B0U08h-zFlGRsH5Ew.png"/></div></figure><p id="67ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，我们将使用 MSE 来评估我们的模型与数据的拟合程度(我使用的是前面 MSE.py gist 中提供的相同代码)。</p><pre class="lo lp lq lr gt ml ln mm mn aw mo bi"><span id="2f87" class="km kn iq ln b gy mp mq l mr ms">Mean squared error on the testing set:  2.3118753456727985</span></pre><p id="ce4a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的测试误差略高于我们的训练误差。这是有意义的，因为训练误差通常应该低于测试误差。<strong class="jp ir">一个模型很少会根据它以前没有见过的数据比它接受训练的数据预测得更准确。</strong></p><h2 id="5cbd" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">多项式回归</h2><p id="9a3d" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">要实现多项式回归，我们需要做的就是采用我们的线性回归模型并添加更多的特性。回想一下线性回归模型的形式，并将其与多项式回归模型的形式进行比较</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/4fb49fcec279b0c1f47348eb73c0b2d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*A0TvS57wSAT4VcBtLGAaWg.png"/></div><p class="ly lz gj gh gi ma mb bd b be z dk translated">多项式回归模型的形式</p></figure><p id="ee4f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以看到，我们需要一个额外的系数为每一个额外的功能，表示为 x …xᵐ.多项式回归模型的阶数取决于模型中包含的特征数量，因此具有<em class="md"> m </em>个特征的模型是一个<em class="md"> mᵗʰ- </em>次或<em class="md"> mᵗʰ- </em>阶<em class="md"> </em>多项式回归。我们将从二阶多项式回归开始，您会注意到增加回归模型的复杂性非常容易(增加模型复杂性并不总是一件好事，可能会导致<a class="ae kl" href="https://en.wikipedia.org/wiki/Overfitting" rel="noopener ugc nofollow" target="_blank"> <em class="md">过度拟合</em> </a> <em class="md">！！！).</em></p><h2 id="715f" class="km kn iq bd ko kp kq dn kr ks kt dp ku jy kv kw kx kc ky kz la kg lb lc ld le bi translated">二阶多项式回归</h2><p id="e2cc" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">因为我们在模型中加入了另一个特性，所以我们必须通过在设计矩阵中加入另一个术语来说明这一点。具有<em class="md"> m- </em>度的设计矩阵的一般形式如下</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/e4da738a497ba66746047d409da66314.png" data-original-src="https://miro.medium.com/v2/resize:fit:930/format:webp/1*9f0KQGINaMJtNjsZF7SuaA.png"/></div><p class="ly lz gj gh gi ma mb bd b be z dk translated">多项式回归设计矩阵的矩阵形式</p></figure><p id="b5d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们继续用代码构建它:</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="ed85" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，我们是如何在设计矩阵<em class="md"> X </em>的右侧包含一列 X 特性的。产生的三个系数存储在<em class="md">系数中。</em>让我们将模型应用于我们的训练数据，并打印出回归线。</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="9e36" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是我们的二阶多项式回归模型如何拟合训练数据:</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/a61c0e86548b419614567a2bb65d26c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*7AK0nA5Xqcc10xLP0YbOJA.png"/></div><p class="ly lz gj gh gi ma mb bd b be z dk translated">二阶多项式回归拟合散点图。</p></figure><pre class="lo lp lq lr gt ml ln mm mn aw mo bi"><span id="1fb7" class="km kn iq ln b gy mp mq l mr ms">Mean squared error on the training set:  0.4846845031271553</span></pre><p id="83d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们将我们的模型应用于测试数据。</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="a30f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是它的合适之处。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/cfefb67c12dc4b823c73e2d5c5cb025a.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*tn5HqIbSE8dgl050jedHQw.png"/></div></figure><pre class="lo lp lq lr gt ml ln mm mn aw mo bi"><span id="a399" class="km kn iq ln b gy mp mq l mr ms">Mean squared error on the testing set:  0.757363565551813</span><span id="3d3f" class="km kn iq ln b gy mv mq l mr ms">2nd-order polynomial regression is a better fit than linear regression. </span></pre><p id="c1f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当比较我们的线性回归模型和二阶多项式回归模型的 MSE 时，我们看到后者比前者更适合测试集。万岁！我们能够通过增加复杂性来提高模型的准确性。然而，要注意的是，增加模型的复杂性并不总是会带来更好的准确性。</p><p id="59f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了进一步扩展该模型，尝试通过在设计矩阵<em class="md"> X </em>中为特征<em class="md"> x </em>添加一个立方项来实现三阶多项式回归，如下所示:</p><pre class="lo lp lq lr gt ml ln mm mn aw mo bi"><span id="908e" class="km kn iq ln b gy mp mq l mr ms">X = np.c_[np.ones(N), train_features_vals, np.square(train_features), np.power(train_features, 3)]</span></pre><p id="8845" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">确保在绘制回归线时，修改<em class="md"> y_pred </em>来考虑这个额外的项。</p><pre class="lo lp lq lr gt ml ln mm mn aw mo bi"><span id="1292" class="km kn iq ln b gy mp mq l mr ms">y_pred = b[3]*np.power(x_line, 3) + b[2]*np.square(x_line) + b[1]*x_line + b[0]</span></pre><p id="e907" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我希望这篇教程对你有所帮助！我很乐意回答任何问题或评论，所以请在下面留下你的想法或私人笔记。干杯！</p></div></div>    
</body>
</html>