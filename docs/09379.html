<html>
<head>
<title>How I would explain building “LightFM Hybrid Recommenders” to a 5-year old!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我将如何向一个 5 岁的孩子解释构建“LightFM 混合推荐器”!</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-i-would-explain-building-lightfm-hybrid-recommenders-to-a-5-year-old-b6ee18571309?source=collection_archive---------4-----------------------#2020-07-05">https://towardsdatascience.com/how-i-would-explain-building-lightfm-hybrid-recommenders-to-a-5-year-old-b6ee18571309?source=collection_archive---------4-----------------------#2020-07-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="52c0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">构建用户/项目功能以解决冷启动问题并预测新用户评级的示例。</h2></div><p id="6acc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">注意:5 岁的孩子必须掌握 Python 的工作知识！</em></p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi lf"><img src="../Images/880d0b221c1017f31cb27a7be0e009fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1226/format:webp/1*IK15sp_OV8tTDqNH3UvZ2A.jpeg"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">来源:作者在<a class="ae lr" href="https://imgflip.com/i/47bj0b" rel="noopener ugc nofollow" target="_blank"> imgflip </a>上创建</p></figure><h1 id="7b84" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">为什么对冷启动问题大惊小怪？</h1><p id="31ca" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">在推荐系统中，<strong class="kk iu">冷启动问题</strong>指的是将项目推荐给一个完全<em class="le"/><em class="le">新</em> <em class="le">用户</em>的问题，即一个没有与你的数据库中的任何现有项目进行过交互的用户。换句话说，如果您从初始训练数据创建用户-项目矩阵，您将找不到这个新用户的行。类似的类比可用于解释在<em class="le">全新项目</em>的情况下的冷启动问题。</p><p id="bb11" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作为应用程序开发人员，这可能会给你带来很大的不便，例如，当听众试图寻找新的播客建议来听时，你得到的是——zip，zilch，nada，什么都没有。这正是我们播客应用程序<a class="ae lr" href="https://podurama.com/" rel="noopener ugc nofollow" target="_blank"> Podurama </a>最初开发阶段的问题。让我们看看 LightFM 是如何帮助我们解决这个问题的…</p><h1 id="a26f" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">LightFM 如何帮助解决冷启动问题？</h1><p id="cc99" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">LightFM 的一个优点是，该模型不会遭受冷启动问题，无论是用户还是项目冷启动。原因是 LightFM 允许构建一个<strong class="kk iu">混合推荐系统</strong>。</p><blockquote class="mp mq mr"><p id="1935" class="ki kj le kk b kl km ju kn ko kp jx kq ms ks kt ku mt kw kx ky mu la lb lc ld im bi translated">混合推荐器是一种特殊的推荐器，它使用协同过滤和基于内容的过滤来进行推荐。</p></blockquote><p id="12f6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">简而言之，LightFM 可以使用普通的用户-项目交互来为已知的<em class="le"/><em class="le">用户做出预测。</em>在 n 个<em class="le">电子战用户的情况下，</em>如果它知道关于这些新用户的一些<em class="le">附加信息</em>，它可以做出预测。这些附加信息可以是性别、年龄、种族等特征，并且在训练期间必须将<strong class="kk iu">输入到算法中。</strong></p><h1 id="9e03" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">让我们直接进入编码</h1><p id="cd01" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">我将使用(非常)小的虚拟评级数据和特征数据，因为我希望能够显示每个阶段的中间输出。如果你想跟着去，这里有一本<a class="ae lr" href="https://github.com/V-Sher/LightFm_HybridRecommenderSystem/blob/master/LightFM%20Worked%20Example.ipynb" rel="noopener ugc nofollow" target="_blank"> Jupyter 笔记本</a>。</p><h2 id="0b3d" class="mv lt it bd lu mw mx dn ly my mz dp mc kr na nb me kv nc nd mg kz ne nf mi ng bi translated">评级数据框架</h2><p id="3280" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">它包含来自三个用户(u1、u2、u3)和四个项目(i1、i2、i3、i4)的数据。</p><pre class="lg lh li lj gt nh ni nj nk aw nl bi"><span id="ee35" class="mv lt it ni b gy nm nn l no np"># create dummy dataset<br/>data = {'user': ['u1','u1','u2','u2', 'u3', 'u3', 'u3'], <br/>        'item': ['i1', 'i3', 'i2', 'i3', 'i1', 'i4', 'i2'], <br/>        'r': [1,2,1,3,4,5,2]<br/>       }<br/>df = pd.DataFrame(data,  columns = ['user', 'item', 'r'])</span></pre><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/84044f0ec57bdffc9a49f89498f3bcb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:454/format:webp/1*JVzN3U1e4YonWBw3DUuAqg.png"/></div></figure><h2 id="8ad2" class="mv lt it bd lu mw mx dn ly my mz dp mc kr na nb me kv nc nd mg kz ne nf mi ng bi translated">用户特征数据框架</h2><p id="9564" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">我们有关于每个用户的四条附加信息——三个布尔特征——f1、f2、f3，以及一个位置特征——loc，现在可以取两个值——德里或孟买。</p><pre class="lg lh li lj gt nh ni nj nk aw nl bi"><span id="9e64" class="mv lt it ni b gy nm nn l no np"><em class="le">#dummy user features</em><br/>data = {'user': ['u1','u2','u3', 'loc'], <br/>        'f1': [1, 0, 1, 'del'], <br/>        'f2': [1, 1, 1, 'mum'],<br/>        'f3': [0, 0, 1, 'del']<br/>       }<br/>features = pd.DataFrame(data,  columns = ['user', 'f1', 'f2', 'f3', 'loc'])</span></pre><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/535424303100c91183147fb0c33483d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:704/format:webp/1*tNM_7XOe-emTEuHt7zjsLA.png"/></div></figure><h2 id="402c" class="mv lt it bd lu mw mx dn ly my mz dp mc kr na nb me kv nc nd mg kz ne nf mi ng bi translated">创建符合 LightFM 的数据集</h2><p id="305d" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">如果您浏览过 LightFM 文档，就会知道它喜欢特定格式的输入数据。因此，我们必须服从。</p><pre class="lg lh li lj gt nh ni nj nk aw nl bi"><span id="7161" class="mv lt it ni b gy nm nn l no np">from lightfm.data import Dataset<br/>dataset1 = Dataset()</span></pre><h2 id="c734" class="mv lt it bd lu mw mx dn ly my mz dp mc kr na nb me kv nc nd mg kz ne nf mi ng bi translated">调用 fit 方法</h2><p id="be36" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">我们需要调用 fit 方法来告诉 LightFM 用户是谁，我们正在处理什么项目，以及任何用户/项目特性。</p><p id="f245" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将向 fit 方法传递三个输入:</p><ul class=""><li id="e130" class="ns nt it kk b kl km ko kp kr nu kv nv kz nw ld nx ny nz oa bi translated"><code class="fe ob oc od ni b">users</code>:所有用户列表</li><li id="0be4" class="ns nt it kk b kl oe ko of kr og kv oh kz oi ld nx ny nz oa bi translated"><code class="fe ob oc od ni b">items</code>:列出所有项目</li><li id="d895" class="ns nt it kk b kl oe ko of kr og kv oh kz oi ld nx ny nz oa bi translated"><code class="fe ob oc od ni b">user_features</code>:附加用户功能列表</li></ul><p id="e0a7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">传递用户和项目列表非常简单——只需使用<code class="fe ob oc od ni b">df</code>中的“用户”和“项目”列。</p><p id="99f8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当谈到传递<code class="fe ob oc od ni b">user_features</code>时，我会<strong class="kk iu">强烈</strong>推荐传递一个列表，其中每个元素都是类似于<code class="fe ob oc od ni b">'feature_name:feature_value'</code>的格式(我保证我会解释为什么我更喜欢这样做，以及是否有其他选择，但是现在，请耐心等待)。</p><p id="c5d0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着我们的<code class="fe ob oc od ni b">user_features</code>应该是这样的:<br/> <code class="fe ob oc od ni b">['f1:1', 'f1:0', 'f2:1', 'f3:0', 'f3:1', 'loc:mum', 'loc:del']</code>。</p><p id="2583" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如你所猜测的，这个列表是通过考虑在训练集中可能遇到的所有可能的对来生成的。例如，对于等于<code class="fe ob oc od ni b">loc</code>的<code class="fe ob oc od ni b">feature_name</code>，可以有两个<code class="fe ob oc od ni b">feature_values</code>，即<code class="fe ob oc od ni b">mum</code>和<code class="fe ob oc od ni b">del</code>。</p><p id="231b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我写了一小段代码，让我生成这样一个列表(我称之为<code class="fe ob oc od ni b">uf</code>):</p><pre class="lg lh li lj gt nh ni nj nk aw nl bi"><span id="efad" class="mv lt it ni b gy nm nn l no np">uf = []<br/>col = ['f1']*len(features.f1.unique()) + ['f2']*len(features.f2.unique()) + ['f3']*len(features.f3.unique()) + ['loc']*len(features['loc'].unique())<br/>unique_f1 = list(features.f1.unique()) + list(features.f2.unique()) + list(features.f3.unique()) + list(features['loc'].unique())<br/>#print('f1:', unique_f1)<br/>for x,y in zip(col, unique_f1):<br/>    res = str(x)+ ":" +str(y)<br/>    uf.append(res)<br/>    print(res)</span></pre><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/5400df92e1c5fbff365a287e8004624d.png" data-original-src="https://miro.medium.com/v2/resize:fit:248/format:webp/1*bKNAoWXDDIIZTZIcf-3ABA.png"/></div></figure><p id="1a06" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，有了所有可用的部分，让我们对数据集调用 fit 方法:</p><pre class="lg lh li lj gt nh ni nj nk aw nl bi"><span id="031f" class="mv lt it ni b gy nm nn l no np"><em class="le"># we call fit to supply userid, item id and user/item features</em><br/>dataset1.fit(<br/>        df['user'].unique(), <em class="le"># all the users</em><br/>        df['item'].unique(), <em class="le"># all the items</em><br/>        user_features = uf <em class="le"># additional user features</em><br/>)</span></pre><p id="8d46" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">既然我们已经准备好了框架数据集，我们就可以将实际的交互和评级插入其中了。</p><h2 id="710d" class="mv lt it bd lu mw mx dn ly my mz dp mc kr na nb me kv nc nd mg kz ne nf mi ng bi translated">建立互动</h2><p id="2655" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated"><code class="fe ob oc od ni b">build_interactions</code>方法的输入是交互的 iterable，其中每个交互是一个包含三个元素的元组:</p><ul class=""><li id="e8fa" class="ns nt it kk b kl km ko kp kr nu kv nv kz nw ld nx ny nz oa bi translated">用户</li><li id="fabc" class="ns nt it kk b kl oe ko of kr og kv oh kz oi ld nx ny nz oa bi translated">项目</li><li id="171a" class="ns nt it kk b kl oe ko of kr og kv oh kz oi ld nx ny nz oa bi translated">交互权重(可选)</li></ul><p id="a385" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">交互权重仅仅意味着如果用户‘u’与项目‘I’交互，那么这个交互<em class="le">有多重要。从我们示例的角度来看，权重是我们对每个(用户、商品)对的评级。</em></p><p id="e423" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">插入权重可能有用的另一个例子是，如果我们正在处理(用户、歌曲)交互数据。在这种情况下，我可以给那些用户听了超过 3/4 歌曲的交互分配一个较高的权重。</p><pre class="lg lh li lj gt nh ni nj nk aw nl bi"><span id="0f05" class="mv lt it ni b gy nm nn l no np"><em class="le"># plugging in the interactions and their weights</em><br/>(interactions, weights) = dataset1.build_interactions([(x[0], x[1], x[2]) for x in df.values ])</span></pre><blockquote class="mp mq mr"><p id="be14" class="ki kj le kk b kl km ju kn ko kp jx kq ms ks kt ku mt kw kx ky mu la lb lc ld im bi translated">总之，<code class="fe ob oc od ni b">interactions</code>矩阵告诉我们用户是否与某个项目进行了交互，而<code class="fe ob oc od ni b">weights</code>矩阵量化了特定的交互。</p></blockquote><p id="b725" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以看看这两个输出矩阵是什么样的。由于这些是稀疏矩阵，我们可以使用<code class="fe ob oc od ni b">.todense()</code>方法。在这两个矩阵中，行是用户，列是项目。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ol om di on bf oo"><div class="gh gi ok"><img src="../Images/caab53877f6f1b28e8c21c9acba29d75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dxdKPw3eZakuQl42sWo_4w.png"/></div></div></figure><p id="1351" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你现在还和我在一起，我向你致敬。理解下一部分非常重要，这样你也可以为你自己的推荐系统实现它。(有趣的事实:LightFM Github 页面上的许多公开问题都与构建用户/物品特性主题有关)。</p><h2 id="90a4" class="mv lt it bd lu mw mx dn ly my mz dp mc kr na nb me kv nc nd mg kz ne nf mi ng bi translated">构建用户特征</h2><p id="8e89" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated"><code class="fe ob oc od ni b">build_user_features</code>方法需要以下格式的输入:<br/> [ <br/>(用户 1，[特征 1，特征 2，特征 3，…。])，<br/>(用户 2，[功能 1，功能 2，功能 3，…。])，<br/>(用户 3，[功能 1，功能 2，功能 3，…。])，<br/>。<br/>。<br/></p><blockquote class="mp mq mr"><p id="f941" class="ki kj le kk b kl km ju kn ko kp jx kq ms ks kt ku mt kw kx ky mu la lb lc ld im bi translated">这里需要记住的一件超级重要的事情是，<code class="fe ob oc od ni b">feature1</code>、<code class="fe ob oc od ni b">feature2</code>、<code class="fe ob oc od ni b">feature3</code>等应该是我们一开始传递给<code class="fe ob oc od ni b">fit</code>方法的<code class="fe ob oc od ni b">user_features</code>列表中的项目之一。</p></blockquote><p id="715a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">只是重申一下，这是我们的<code class="fe ob oc od ni b">user_features</code>列表目前的样子:<br/> <code class="fe ob oc od ni b">['f1:1', 'f1:0', 'f2:1', 'f3:0', 'f3:1', 'loc:mum', 'loc:del']</code>。</p><p id="94de" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，对于我们特定的虚拟数据，<code class="fe ob oc od ni b">build_user_features</code>的输入应该是这样的:</p><pre class="lg lh li lj gt nh ni nj nk aw nl bi"><span id="ce53" class="mv lt it ni b gy nm nn l no np">[<br/>     ('u1', ['f1:1', 'f2:1', 'f3:0', 'loc:del']),<br/>     ('u2', ['f1:0', 'f2:1', 'f3:0', 'loc:mum']),<br/>     ('u3', ['f1:1', 'f2:1', 'f3:1', 'loc:del'])<br/> ]</span></pre><p id="7ef7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，我已经编写了一个(不那么小的)代码片段，让我生成这样一个列表:</p><pre class="lg lh li lj gt nh ni nj nk aw nl bi"><span id="c9ae" class="mv lt it ni b gy nm nn l no np"><strong class="ni iu"><em class="le"># Helper function that takes the user features and converts them into the proper "feature:value" format</em></strong><br/>def feature_colon_value(my_list):<br/>    """<br/>    Takes as input a list and prepends the columns names to respective values in the list.<br/>    For example: if my_list = [1,1,0,'del'],<br/>    resultant output = ['f1:1', 'f2:1', 'f3:0', 'loc:del']<br/>   <br/>    """<br/>    result = []<br/>    ll = ['f1:','f2:', 'f3:', 'loc:']<br/>    aa = my_list<br/>    for x,y in zip(ll,aa):<br/>        res = str(x) +""+ str(y)<br/>        result.append(res)<br/>    return result</span><span id="3c71" class="mv lt it ni b gy op nn l no np"><strong class="ni iu"><em class="le"># Using the helper function to generate user features in proper format for ALL users<br/></em></strong>ad_subset = features[["f1", 'f2','f3', 'loc']] <br/>ad_list = [list(x) for x in ad_subset.values]<br/>feature_list = []<br/>for item in ad_list:<br/>    feature_list.append(feature_colon_value(item))<br/>print(f'Final output: {feature_list}')</span></pre><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ol om di on bf oo"><div class="gh gi oq"><img src="../Images/061b596abfd79496c4286e8d79a147a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WOWn69H4WNtH6DaAWGeTWw.png"/></div></div></figure><p id="77b5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们必须将<code class="fe ob oc od ni b">feature_list</code>的每个元素与相应的用户 id 相关联。</p><pre class="lg lh li lj gt nh ni nj nk aw nl bi"><span id="f3b8" class="mv lt it ni b gy nm nn l no np">user_tuple = list(zip(features.user, feature_list))</span></pre><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ol om di on bf oo"><div class="gh gi or"><img src="../Images/bbbd0686060ae14419df08d13d1f6143.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8R-FM5UIRppkrnWNFCDHEQ.png"/></div></div></figure><p id="771c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">瞧，我们有了<code class="fe ob oc od ni b">build_user_features</code>方法所需的输入。让我们继续称之为:</p><pre class="lg lh li lj gt nh ni nj nk aw nl bi"><span id="ea2a" class="mv lt it ni b gy nm nn l no np">user_features = dataset1.build_user_features(user_tuple, normalize= False)</span></pre><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ol om di on bf oo"><div class="gh gi os"><img src="../Images/d318671062ae8147067ccf161389ca48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AN3kDBpHsRAxVhMm8t4XYA.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">图 1</p></figure><p id="7235" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的<code class="fe ob oc od ni b">user_features</code>矩阵中，行是用户，列是用户特征。每当用户在训练数据中具有该特定用户特征时，就存在 1。</p><p id="1d52" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以看到总共有 10 列，这意味着存在 10 个用户特性。但是为什么你问，让我们看看！</p><pre class="lg lh li lj gt nh ni nj nk aw nl bi"><span id="589b" class="mv lt it ni b gy nm nn l no np">user_id_map, user_feature_map, item_id_map, item_feature_map = dataset1.mapping()<br/>user_feature_map</span></pre><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/32338379062f3227399d23350d35666f.png" data-original-src="https://miro.medium.com/v2/resize:fit:588/format:webp/1*VNBRnKUrvn14OkTB5CNlKA.png"/></div></figure><p id="8b1a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你看看上面的输出，就会明白为什么我们有 10 个用户特性。默认情况下，用户 id 本身也是一个特性，所以我们有三个。剩下的七个一定很熟悉，因为我们在一开始就创建了它们。</p><h2 id="c494" class="mv lt it bd lu mw mx dn ly my mz dp mc kr na nb me kv nc nd mg kz ne nf mi ng bi translated">是时候建立模型了</h2><p id="27a5" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">这一步非常简单，也非常通用。当然，您可以遵循<a class="ae lr" href="https://making.lyst.com/lightfm/docs/index.html" rel="noopener ugc nofollow" target="_blank">文档</a>并尝试不同的<code class="fe ob oc od ni b">loss</code>值或<code class="fe ob oc od ni b">learning_schedule</code>选项。</p><pre class="lg lh li lj gt nh ni nj nk aw nl bi"><span id="32c3" class="mv lt it ni b gy nm nn l no np">model = LightFM(loss='warp')<br/>model.fit(interactions,<br/>      user_features= user_features,<br/>      sample_weight= weights,<br/>      epochs=10)</span></pre><h2 id="70ee" class="mv lt it bd lu mw mx dn ly my mz dp mc kr na nb me kv nc nd mg kz ne nf mi ng bi translated">打印 AUC 分数</h2><pre class="lg lh li lj gt nh ni nj nk aw nl bi"><span id="5eeb" class="mv lt it ni b gy nm nn l no np">from lightfm.evaluation import auc_score<br/>train_auc = auc_score(model,<br/>                      interactions,<br/>                      user_features=user_features<br/>                     ).mean()<br/>print('Hybrid training set AUC: %s' % train_auc)</span><span id="8cec" class="mv lt it ni b gy op nn l no np"><strong class="ni iu">Output: Hybrid training set AUC: 0.9166667</strong></span></pre><p id="4648" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我再说一遍，不要对高 AUC 过于兴奋。记住这只是虚拟数据。</p><h2 id="cdd5" class="mv lt it bd lu mw mx dn ly my mz dp mc kr na nb me kv nc nd mg kz ne nf mi ng bi translated">为已知用户做预测</h2><p id="fc49" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated"><code class="fe ob oc od ni b">predict</code>方法有两个输入:</p><ul class=""><li id="5b78" class="ns nt it kk b kl km ko kp kr nu kv nv kz nw ld nx ny nz oa bi translated">用户 id 映射(例如:要获得对“u1”的预测，必须传递 0；对于‘U2’，传递 1，以此类推。).这些映射可从<code class="fe ob oc od ni b">user_id_map </code>字典中访问。</li><li id="3239" class="ns nt it kk b kl oe ko of kr og kv oh kz oi ld nx ny nz oa bi translated">条目 id 的列表(同样不是 i1、i2，而是映射；可从<code class="fe ob oc od ni b">item_id_map</code>获得您想要的推荐。</li></ul><pre class="lg lh li lj gt nh ni nj nk aw nl bi"><span id="230b" class="mv lt it ni b gy nm nn l no np"><em class="le"># predict for existing user</em><br/>user_x = user_id_map['u3']<br/>n_users, n_items = interactions.shape <em class="le"># no of users * no of items</em><br/>model.predict(user_x, np.arange(n_items)) <em class="le"># means predict for all </em></span><span id="3b7d" class="mv lt it ni b gy op nn l no np"><strong class="ni iu">Output: array([-0.18600112, -0.91691172, -0.295421  , -0.06632421])</strong></span></pre><h2 id="4faf" class="mv lt it bd lu mw mx dn ly my mz dp mc kr na nb me kv nc nd mg kz ne nf mi ng bi translated">为未知用户做预测</h2><p id="20f8" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">这就是我们最初构建混合推荐器的原因。</p><p id="d71c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于一个新用户，这是我们所知道的- (s)他有 f1，f2，f3 的值，分别为 1，1 和 0。此外，他们的位置是德里。</p><pre class="lg lh li lj gt nh ni nj nk aw nl bi"><span id="18d3" class="mv lt it ni b gy nm nn l no np">user_feature_list = ['f1:1', 'f2:1', 'f3:0', 'loc:del']</span></pre><p id="3277" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，我们不能将它直接提供给<code class="fe ob oc od ni b">predict</code>方法。我们必须将这种输入转换成 lightFM 模型可以理解的形式。</p><p id="5ac1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">理想情况下，输入应该类似于<code class="fe ob oc od ni b">user_features</code>矩阵中的一行(见上面的图 1)。</p><p id="75b2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我在<a class="ae lr" href="https://stackoverflow.com/questions/46924119/lightfm-handling-user-and-item-cold-start" rel="noopener ugc nofollow" target="_blank"> Stackoverflow </a>上找到了一段代码，它就是这样做的——将<code class="fe ob oc od ni b">user_feature_list</code>转换成所需的格式(在我们的例子中是一个有 10 列的稀疏矩阵)。我只是稍微修改了原始代码，并将其封装在一个可重用的函数<code class="fe ob oc od ni b">format_newuser_input</code>中，如下所示:</p><pre class="lg lh li lj gt nh ni nj nk aw nl bi"><span id="a7fe" class="mv lt it ni b gy nm nn l no np">from scipy import sparse</span><span id="a519" class="mv lt it ni b gy op nn l no np">def format_newuser_input(user_feature_map, user_feature_list):<br/>  num_features = len(user_feature_list)<br/>  normalised_val = 1.0 <br/>  target_indices = []<br/>  for feature in user_feature_list:<br/>    try:<br/>        target_indices.append(user_feature_map[feature])<br/>    except KeyError:<br/>        print("new user feature encountered '{}'".format(feature))<br/>        pass<br/><br/>  new_user_features = np.zeros(len(user_feature_map.keys()))<br/>  for i in target_indices:<br/>    new_user_features[i] = normalised_val<br/>  new_user_features = sparse.csr_matrix(new_user_features)<br/>  return(new_user_features)</span></pre><p id="8eb4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们可以开始预测新用户:</p><pre class="lg lh li lj gt nh ni nj nk aw nl bi"><span id="0e77" class="mv lt it ni b gy nm nn l no np">new_user_features = format_newuser_input(user_feature_map, user_feature_list)<br/>model.predict(0, np.arange(n_items), user_features=new_user_features)</span></pre><p id="3339" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里，第一个参数(即 0)不再指用户 u1 的映射 id。相反，它的意思是——选择<code class="fe ob oc od ni b">new_user_features</code>稀疏矩阵的第一行。传递除 0 以外的任何值都会引发一个错误，这是理所当然的，因为在<code class="fe ob oc od ni b">new_user_features</code>中没有超过 row0 的行。</p><h2 id="8896" class="mv lt it bd lu mw mx dn ly my mz dp mc kr na nb me kv nc nd mg kz ne nf mi ng bi translated">万岁！！我们做到了。我们的虚拟混合推荐系统已经准备好了。</h2></div><div class="ab cl ou ov hx ow" role="separator"><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz"/></div><div class="im in io ip iq"><h2 id="abfc" class="mv lt it bd lu mw mx dn ly my mz dp mc kr na nb me kv nc nd mg kz ne nf mi ng bi translated">创建用户/项目特征的其它方式</h2><p id="b9db" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">回到我在开始时所做的承诺，除了构建<code class="fe ob oc od ni b">user_features</code>矩阵，还有其他选择，<strong class="kk iu">假设</strong> <strong class="kk iu">你的数据是一种特定的格式</strong>。</p><p id="f2c9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，考虑如下所示的用户特征数据帧:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ol om di on bf oo"><div class="gh gi pb"><img src="../Images/e1b52b0b3f9f9798bdba8ce93cee8a09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k7FeUxgvemJilBQiZjzg_A.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">来源:<a class="ae lr" href="https://github.com/lyst/lightfm/issues/372" rel="noopener ugc nofollow" target="_blank">https://github.com/lyst/lightfm/issues/372</a></p></figure><p id="1f3a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你仔细观察，这三个特征——种族、性别、30 岁以下，每一个都有不重叠的值。换句话说，<em class="le">种族列中的可能值不同于性别列中的可能值，性别列中的可能值又不同于 under_30yo 列中的可能值</em>。</p><p id="e12d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果是这种情况，我们可以简单地将表单<code class="fe ob oc od ni b">[Asian, Hispanic, Female, Male, no, yes]</code>的<code class="fe ob oc od ni b">user_features</code>列表传递给<code class="fe ob oc od ni b">fit</code>。随后，我们<strong class="kk iu">必须</strong>也更新我们构建用户特性的方式，因此<code class="fe ob oc od ni b">.build_user_features()</code>的输入应该是这样的:</p><pre class="lg lh li lj gt nh ni nj nk aw nl bi"><span id="1730" class="mv lt it ni b gy nm nn l no np">[<br/>     ('u1', ['Asian', 'Female', 'No']),<br/>     ('u2', ['Hispanic', 'Male', 'Yes']),<br/>     ('u3', ['Hispanic', 'Male', 'No'])<br/> ]</span></pre><p id="42ae" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这看起来很棒。但是现在回答这个？</p><p id="0bac" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我有一个关于每个用户的额外信息时，比如一个新列“height_under_5ft”可以取值 yes 或 no，会发生什么？</p><p id="86c9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这种情况下，可能很难从年龄和身高来区分是/否。因此，为了避免歧义，最好使用我们在开始时谈到的<code class="fe ob oc od ni b">feature:value</code>格式，并将<code class="fe ob oc od ni b">user_features = ['eth:Asian', 'eth:Hispanic', 'gender:Male', 'gender:Female', 'age:yes', 'age:no', 'height:yes', 'height:no]</code>传递给<code class="fe ob oc od ni b">fit</code>，并将以下输入传递给<code class="fe ob oc od ni b">.build_usear_features()</code></p><pre class="lg lh li lj gt nh ni nj nk aw nl bi"><span id="6ff7" class="mv lt it ni b gy nm nn l no np">[<br/>     ('u1', ['eth:Asian', 'gender:Female', 'age:No', <!-- -->'height:yes'<!-- -->]),<br/>     ('u2', ['eth:Hispanic', 'gender:Male', 'age:No', <!-- -->'height:no'<!-- -->])<br/>     ('u3', ['eth:Asian', 'gender:Female', 'age:No', <!-- -->'height:yes'<!-- -->])<br/> ]</span></pre></div><div class="ab cl ou ov hx ow" role="separator"><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz"/></div><div class="im in io ip iq"><h1 id="6e1d" class="ls lt it bd lu lv pc lx ly lz pd mb mc jz pe ka me kc pf kd mg kf pg kg mi mj bi translated">结尾注释</h1><p id="d250" class="pw-post-body-paragraph ki kj it kk b kl mk ju kn ko ml jx kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">有很多不同的方法可以推进这个教程。首先，尝试插入真实数据集而不是虚拟数据，看看你的推荐系统表现如何。您甚至可以尝试使用我们在本教程中讨论的类似方法来创建<code class="fe ob oc od ni b">item_features</code>。</p><p id="e70a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我没有过多地讨论过模型调优、模型评估、交叉验证等等，但那是以后的事了。我希望你喜欢阅读，并随时在 Github 上分享我的代码，以满足你的需求。一如既往，我很想知道是否有更好的方法来做我提到的一些事情。</p><p id="7b18" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">直到下次:)</p></div><div class="ab cl ou ov hx ow" role="separator"><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz"/></div><div class="im in io ip iq"><p id="6ba8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">哦，我差点忘了，“<em class="le">如果你喜欢这篇文章，你可能也会喜欢</em>”😜)</p><p id="0cfb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我喜欢写循序渐进的初学者指南、操作指南、面试问题、ML/AI 中使用的解码术语等。如果你想完全访问我的所有文章(以及其他文章)，那么你可以注册使用 <a class="ae lr" href="https://varshitasher.medium.com/membership" rel="noopener"> <strong class="kk iu"> <em class="le">我的链接</em></strong></a><strong class="kk iu"><em class="le"/></strong><em class="le">这里</em> <strong class="kk iu"> <em class="le">。</em> </strong></p><div class="ph pi gp gr pj pk"><a rel="noopener follow" target="_blank" href="/how-to-make-most-of-your-python-debugger-in-vscode-9e05dfce533f"><div class="pl ab fo"><div class="pm ab pn cl cj po"><h2 class="bd iu gy z fp pp fr fs pq fu fw is bi translated">如何在 VSCode 中充分利用你的 python 调试器？</h2><div class="pr l"><h3 class="bd b gy z fp pp fr fs pq fu fw dk translated">观察变量，使用条件断点，调用堆栈，异常断点等——当在大型项目中工作时</h3></div><div class="ps l"><p class="bd b dl z fp pp fr fs pq fu fw dk translated">towardsdatascience.com</p></div></div><div class="pt l"><div class="pu l pv pw px pt py ll pk"/></div></div></a></div><div class="ph pi gp gr pj pk"><a rel="noopener follow" target="_blank" href="/understanding-python-imports-init-py-and-pythonpath-once-and-for-all-4c5249ab6355"><div class="pl ab fo"><div class="pm ab pn cl cj po"><h2 class="bd iu gy z fp pp fr fs pq fu fw is bi translated">了解 Python 导入，__init__。py 和 pythonpath —一劳永逸</h2><div class="pr l"><h3 class="bd b gy z fp pp fr fs pq fu fw dk translated">了解如何导入包和模块(以及两者之间的区别)</h3></div><div class="ps l"><p class="bd b dl z fp pp fr fs pq fu fw dk translated">towardsdatascience.com</p></div></div><div class="pt l"><div class="pz l pv pw px pt py ll pk"/></div></div></a></div><div class="ph pi gp gr pj pk"><a rel="noopener follow" target="_blank" href="/time-series-analysis-using-pandas-in-python-f726d87a97d8"><div class="pl ab fo"><div class="pm ab pn cl cj po"><h2 class="bd iu gy z fp pp fr fs pq fu fw is bi translated">使用 Python 中的 Pandas 进行时间序列分析</h2><div class="pr l"><h3 class="bd b gy z fp pp fr fs pq fu fw dk translated">对季节性、趋势、自相关等关键词的额外介绍。</h3></div><div class="ps l"><p class="bd b dl z fp pp fr fs pq fu fw dk translated">towardsdatascience.com</p></div></div><div class="pt l"><div class="qa l pv pw px pt py ll pk"/></div></div></a></div><div class="ph pi gp gr pj pk"><a rel="noopener follow" target="_blank" href="/deploying-h2o-models-as-apis-using-flask-42065a4fa567"><div class="pl ab fo"><div class="pm ab pn cl cj po"><h2 class="bd iu gy z fp pp fr fs pq fu fw is bi translated">使用 FLASK 将 H2o 模型部署为 API</h2><div class="pr l"><h3 class="bd b gy z fp pp fr fs pq fu fw dk translated">模型训练、调优和创建简单 API 的端到端示例(没有技术术语)。</h3></div><div class="ps l"><p class="bd b dl z fp pp fr fs pq fu fw dk translated">towardsdatascience.com</p></div></div><div class="pt l"><div class="qb l pv pw px pt py ll pk"/></div></div></a></div></div></div>    
</body>
</html>