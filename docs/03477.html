<html>
<head>
<title>When you should use Constraint Solvers instead of Machine Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">何时应该使用约束求解器而不是机器学习</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/where-you-should-drop-deep-learning-in-favor-of-constraint-solvers-eaab9f11ef45?source=collection_archive---------16-----------------------#2020-04-02">https://towardsdatascience.com/where-you-should-drop-deep-learning-in-favor-of-constraint-solvers-eaab9f11ef45?source=collection_archive---------16-----------------------#2020-04-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="06cd" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">约束求解器的实际应用。学习其他技术可以为您节省几天的数据清理和模型训练时间。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7f5f3a20c501b78ffafebe270770e0c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bb2DXzaHNkZGQaWwl7FxuA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><em class="kv">魔方可以被建模为约束满足问题【1】，</em>图片由<a class="ae kw" href="https://unsplash.com/@neonbrand?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> NeONBRAND </a>在<a class="ae kw" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上发布</p></figure><p id="7f74" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi lt translated"><span class="l lu lv lw bm lx ly lz ma mb di">M</span>T8】achine Learning 和<em class="mc"> Deep Learning </em>是业界正在流行的词汇。品牌领先于功能导致深度学习在许多人工智能应用中被过度使用。</p><p id="8a3a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这篇文章将提供对约束满足的快速理解，这是一种强大但未被充分利用的方法，可以解决人工智能和计算机科学其他领域的大量问题，从物流和调度到时间推理和图形问题。</p><h1 id="2dbe" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">解决现实世界的问题</h1><p id="7caf" class="pw-post-body-paragraph kx ky iq kz b la mv jr lc ld mw ju lf lg mx li lj lk my lm ln lo mz lq lr ls ij bi translated">让我们考虑一个事实性和高度话题性的问题。</p><blockquote class="na"><p id="2770" class="nb nc iq bd nd ne nf ng nh ni nj ls dk translated">一个疫情正在崛起。医院必须迅速组织起来治疗病人。</p></blockquote><p id="52de" class="pw-post-body-paragraph kx ky iq kz b la nk jr lc ld nl ju lf lg nm li lj lk nn lm ln lo no lq lr ls ij bi translated">这个世界需要一种算法，在给定多种标准的情况下，如疾病的严重程度、患者年龄和位置、医院容量和设备等，该算法将感染者和医院匹配在一起。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/821aa461718789c9c7bed65643fa918b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*oruYfqau-ebqqaPXhtrvHQ.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><em class="kv">图 1:疫情地图，简化为 3 个参数:患者和医院的位置，患者的严重程度</em></p></figure><p id="9a70" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">许多人会说，神经网络将是最适合它的:不同的配置，从广泛的参数范围，需要减少到一个独特的解决方案。</p><p id="0172" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">然而，有一些不利因素会破坏这种方法:</p><ul class=""><li id="84fd" class="nq nr iq kz b la lb ld le lg ns lk nt lo nu ls nv nw nx ny bi translated">模型需要训练，因此需要以前案例的历史数据，</li><li id="5389" class="nq nr iq kz b la nz ld oa lg ob lk oc lo od ls nv nw nx ny bi translated">清理和整合数据集会浪费大量时间，</li><li id="074d" class="nq nr iq kz b la nz ld oa lg ob lk oc lo od ls nv nw nx ny bi translated">各种各样的架构都需要通过长时间的培训来测试。</li></ul><p id="3b0b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">另一方面，如果用布尔可满足性问题来表述，这种情况不会有任何上述缺点，同时仍然在不确定的多项式时间内给出次优解(NP-完全问题)，并且不需要任何历史数据。</p><p id="93a2" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><em class="mc">免责声明:这篇文章的目的是快速浏览 CSP。理论和问题公式将被忽视。对于更严格的方法，请参考[2][3][4]。</em></p><h1 id="a49e" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">抽象问题</h1><p id="3212" class="pw-post-body-paragraph kx ky iq kz b la mv jr lc ld mw ju lf lg mx li lj lk my lm ln lo mz lq lr ls ij bi translated">这篇文章将为约束编程提供一个<em class="mc">温和的介绍，旨在解决这个案例研究。这张疫情地图(1)展示了我们算法的输出结果，它将感染者与医院进行匹配。约束求解有几种框架。<a class="ae kw" href="https://developers.google.com/optimization" rel="noopener ugc nofollow" target="_blank">谷歌优化工具(又名，或-Tools) </a>是一个解决组合优化问题的开源软件套件。我们的问题将使用 Python 中的这个框架来建模。</em></p><pre class="kg kh ki kj gt oe of og oh aw oi bi"><span id="7112" class="oj me iq of b gy ok ol l om on">from ortools.sat.python import cp_model</span></pre><div class="oo op gp gr oq or"><a href="https://colab.research.google.com/drive/1vFkt5yIQtyelqvCh2TsJ9UDeM5miXqui" rel="noopener  ugc nofollow" target="_blank"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd ir gy z fp ow fr fs ox fu fw ip bi translated">查看这篇文章的互动笔记本</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">在一片混乱中把病人和医院联系起来</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">colab.research.google.com</p></div></div><div class="pa l"><div class="pb l pc pd pe pa pf kp or"/></div></div></a></div><h2 id="898f" class="oj me iq bd mf pg ph dn mj pi pj dp mn lg pk pl mp lk pm pn mr lo po pp mt pq bi translated">因素</h2><p id="8d56" class="pw-post-body-paragraph kx ky iq kz b la mv jr lc ld mw ju lf lg mx li lj lk my lm ln lo mz lq lr ls ij bi translated">现在，让我们将问题简化为 4 个参数(1):</p><ul class=""><li id="f508" class="nq nr iq kz b la lb ld le lg ns lk nt lo nu ls nv nw nx ny bi translated">受感染者的位置</li><li id="8f3a" class="nq nr iq kz b la nz ld oa lg ob lk oc lo od ls nv nw nx ny bi translated">感染者的严重程度</li><li id="6a65" class="nq nr iq kz b la nz ld oa lg ob lk oc lo od ls nv nw nx ny bi translated">医院的位置</li><li id="9076" class="nq nr iq kz b la nz ld oa lg ob lk oc lo od ls nv nw nx ny bi translated">每所医院的床位数</li></ul><p id="1d0d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">让我们用 python 来定义这些参数:</p><pre class="kg kh ki kj gt oe of og oh aw oi bi"><span id="63b6" class="oj me iq of b gy ok ol l om on"># Number of hospitals<br/>n_hospitals = 3<br/># Number of infected people<br/>n_patients = 200<br/># Number of beds in every hospital<br/>n_beds_in_hospitals = [30,50,20]<br/># Location of infected people -- random integer tuple (x,y)<br/>patients_loc = [(randint(0, 100), randint(0, 100)) <strong class="of ir">for</strong> _ <strong class="of ir">in</strong> range(n_patients)]<br/># Location of hospitals -- random integer tuple (x,y)<br/>hospitals_loc = [(randint(0, 100), randint(0, 100)) <strong class="of ir">for</strong> _ <strong class="of ir">in</strong> range(n_hospitals)]  <br/># Illness severity -- 1 = mild -&gt; 5 = severe<br/>patients_severity = [randint(1, 5) <strong class="of ir">for</strong> _ <strong class="of ir">in</strong> range(n_patients)]</span></pre><h2 id="0dbd" class="oj me iq bd mf pg ph dn mj pi pj dp mn lg pk pl mp lk pm pn mr lo po pp mt pq bi translated">变量</h2><p id="1f68" class="pw-post-body-paragraph kx ky iq kz b la mv jr lc ld mw ju lf lg mx li lj lk my lm ln lo mz lq lr ls ij bi translated">约束满足问题由一组变量组成，这些变量必须以满足一组约束的方式赋值。</p><ul class=""><li id="8c07" class="nq nr iq kz b la lb ld le lg ns lk nt lo nu ls nv nw nx ny bi translated">设<em class="mc"> I </em>为医院集合</li><li id="d717" class="nq nr iq kz b la nz ld oa lg ob lk oc lo od ls nv nw nx ny bi translated">让<em class="mc"> Jᵢ </em>成为医院<em class="mc"> i </em>的床位集合</li><li id="2fae" class="nq nr iq kz b la nz ld oa lg ob lk oc lo od ls nv nw nx ny bi translated">设<em class="mc"> K </em>为患者集合。</li></ul><p id="34c0" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">让我们将变量的索引族定义为:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/b4cb5212abc6b228473b6ec1e08d35fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:656/format:webp/1*y_V3_x5oT1DCC1wr0Tu7Ug.png"/></div></figure><p id="b415" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果在医院里<em class="mc">我</em>，床<em class="mc"> j </em>被人<em class="mc"> k </em>那么<em class="mc"> xᵢⱼₖ = 1 </em>。为了将医院的每张病床与一个病人相关联，目标是找到一组满足所有约束的变量。</p><p id="960c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们可以将这些变量添加到我们的模型中:</p><pre class="kg kh ki kj gt oe of og oh aw oi bi"><span id="38e7" class="oj me iq of b gy ok ol l om on">model = cp_model.CpModel()<br/>x = {}<br/><strong class="of ir">for</strong> i <strong class="of ir">in</strong> range(n_hospitals):<br/>  <strong class="of ir">for</strong> j <strong class="of ir">in</strong> range(n_beds_in_hospitals[i]):<br/>    <strong class="of ir">for</strong> k <strong class="of ir">in</strong> range(n_patients):<br/>      x[(i,j,k)] = model.NewBoolVar("x(%d,%d,%d)" % (i,j,k))</span></pre><h2 id="f8c3" class="oj me iq bd mf pg ph dn mj pi pj dp mn lg pk pl mp lk pm pn mr lo po pp mt pq bi translated">硬约束</h2><p id="07a8" class="pw-post-body-paragraph kx ky iq kz b la mv jr lc ld mw ju lf lg mx li lj lk my lm ln lo mz lq lr ls ij bi translated">硬约束定义了我们模型的目标。这些问题至关重要，如果不解决，问题就无法解决:</p><ul class=""><li id="59e7" class="nq nr iq kz b la lb ld le lg ns lk nt lo nu ls nv nw nx ny bi translated">每张床上最多只能有<strong class="kz ir"/>一个人，</li><li id="c224" class="nq nr iq kz b la nz ld oa lg ob lk oc lo od ls nv nw nx ny bi translated">每个人最多只能有一张单人床。</li></ul><p id="63a6" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">让我们关注第一个硬约束。每个医院的每个床位<em class="mc">j</em>I:</p><ul class=""><li id="07a5" class="nq nr iq kz b la lb ld le lg ns lk nt lo nu ls nv nw nx ny bi translated">要么有一个独特的病人，</li><li id="5a49" class="nq nr iq kz b la nz ld oa lg ob lk oc lo od ls nv nw nx ny bi translated">要么床是空的。</li></ul><p id="5250" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">因此，它可以用以下方式表示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ps"><img src="../Images/3c823c49371b36b7e4c12fd6242b2255.png" data-original-src="https://miro.medium.com/v2/resize:fit:862/format:webp/1*qhXJj1KjwjkxnmCwFX9IBg.png"/></div></figure><p id="0dc8" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们的求解器是一个组合优化求解器，它只能处理整数约束。因此，必须变成一个整数方程:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pt"><img src="../Images/30fff30ba1eb4922a36ed59805d46670.png" data-original-src="https://miro.medium.com/v2/resize:fit:504/format:webp/1*Bfoqf_z-1IDBVNXovJHrRA.png"/></div></figure><p id="dd6c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这个不等式可以添加到我们的模型中。</p><pre class="kg kh ki kj gt oe of og oh aw oi bi"><span id="8b68" class="oj me iq of b gy ok ol l om on"># Each bed must host at most one person<br/><strong class="of ir">for</strong> i <strong class="of ir">in</strong> range(n_hospitals):<br/>  <strong class="of ir">for</strong> j <strong class="of ir">in</strong> range(n_beds_in_hospitals[i]):<br/>    model.Add(sum(x[(i,j,k)] <strong class="of ir">for</strong> k <strong class="of ir">in</strong> range(n_patients)) &lt;= 1)</span></pre></div><div class="ab cl pu pv hu pw" role="separator"><span class="px bw bk py pz qa"/><span class="px bw bk py pz qa"/><span class="px bw bk py pz"/></div><div class="ij ik il im in"><p id="00d1" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">接下来，第二个硬约束:对于每个患者<em class="mc"> k </em>:</p><ul class=""><li id="dfc5" class="nq nr iq kz b la lb ld le lg ns lk nt lo nu ls nv nw nx ny bi translated">要么他在一个独特的医院的独特的病床上，</li><li id="a6c1" class="nq nr iq kz b la nz ld oa lg ob lk oc lo od ls nv nw nx ny bi translated">要么他在家。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qb"><img src="../Images/a4d7359d36079450b41eb8ab08075d86.png" data-original-src="https://miro.medium.com/v2/resize:fit:872/format:webp/1*5W29pw0Ko5CFiUgObxrS6g.png"/></div></figure><p id="a6aa" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">同样，可以转化为一个整数不等式:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qc"><img src="../Images/3a81feed575b6663872ee6618a51fd41.png" data-original-src="https://miro.medium.com/v2/resize:fit:444/format:webp/1*yE2L71R3Q2eLBHG6qvOyiA.png"/></div></figure><p id="17e0" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">最后，这个约束可以添加到模型中。</p><pre class="kg kh ki kj gt oe of og oh aw oi bi"><span id="6211" class="oj me iq of b gy ok ol l om on"># Each person must be placed in at most one bed<br/><strong class="of ir">for</strong> k <strong class="of ir">in</strong> range(n_patients):<br/>  inner_sum = []<br/>  <strong class="of ir">for</strong> i <strong class="of ir">in</strong> range(n_hospitals):<br/>    inner_sum.append(sum(x[(i,j,k)] <strong class="of ir">for</strong> j <strong class="of ir">in</strong> range(n_beds_in_hospitals[i]))) <br/>  model.Add(sum(inner_sum) &lt;= 1)</span></pre><h2 id="4c69" class="oj me iq bd mf pg ph dn mj pi pj dp mn lg pk pl mp lk pm pn mr lo po pp mt pq bi translated">软约束</h2><p id="2c6a" class="pw-post-body-paragraph kx ky iq kz b la mv jr lc ld mw ju lf lg mx li lj lk my lm ln lo mz lq lr ls ij bi translated">接下来，还有<em class="mc">软约束</em>。这些都是非常需要的:我们的解决方案必须尽可能地满足它们，但是它们对于找到解决方案并不是必不可少的:</p><ul class=""><li id="983b" class="nq nr iq kz b la lb ld le lg ns lk nt lo nu ls nv nw nx ny bi translated">每个病人都应该被放在床上，</li><li id="e057" class="nq nr iq kz b la nz ld oa lg ob lk oc lo od ls nv nw nx ny bi translated">每个人都应该由最近的医院处理，</li><li id="e50a" class="nq nr iq kz b la nz ld oa lg ob lk oc lo od ls nv nw nx ny bi translated">在没有足够床位的情况下，<em class="mc">病情严重的病人应</em>优先处理。</li></ul><p id="2556" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">当硬约束被建模为等式或不等式时，软约束是最小化或最大化的表达式。</p><p id="1bde" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">设<em class="mc">ω</em>为满足硬约束的所有解的集合。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qd"><img src="../Images/bb671552629d55df7d0b291d0665e470.png" data-original-src="https://miro.medium.com/v2/resize:fit:372/format:webp/1*a4UNeEiU7AFEc7RMBAEb6w.png"/></div></figure><p id="6923" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><em class="mc">每个病人都应该被安排到一张病床上</em>的意思是最大限度地增加被占用的病床数量。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qe"><img src="../Images/d4802616ad0c3d4871c6b57ade557f68.png" data-original-src="https://miro.medium.com/v2/resize:fit:534/format:webp/1*3OhkMv3vxrqjf37cPteLAQ.png"/></div></figure><p id="ac27" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><em class="mc">每个人都应由最近的医院处理</em>是指尽量缩短每个病人与其指定医院之间的距离。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qf"><img src="../Images/a3976f44fe9f7901ba8cecdf43a314a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:652/format:webp/1*SuHVn9rMIKlZF9207zbqsw.png"/></div></figure><p id="2e58" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><em class="mc">当没有足够的床位时，应首先处理病情严重的病人</em>是指最大化所有处理病人的总严重程度。通过表示<em class="mc"> sev(k) </em>患者的严重程度<em class="mc"> k </em>:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qg"><img src="../Images/e9b58bade951d087a713f1ad7ed03c1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:664/1*3Z_J-0bjIA9LSgWOVREBoA.gif"/></div></figure><p id="5080" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">然后，我们可以将所有软约束简化为一个目标:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qh"><img src="../Images/f4e78e0f52efa423fc357e5b3be14d3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*U0aSJ5grhTxAYEIKAU7BXQ.png"/></div></figure><p id="a650" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">人们需要小心:这些软约束没有相同的域。</p><ul class=""><li id="e53d" class="nq nr iq kz b la lb ld le lg ns lk nt lo nu ls nv nw nx ny bi translated">患者最大化约束范围从<em class="mc"> 0 </em>到<em class="mc"> n </em>，其中 n 为患者人数，</li><li id="decd" class="nq nr iq kz b la nz ld oa lg ob lk oc lo od ls nv nw nx ny bi translated">严重性约束范围从<em class="mc"> 0 </em>到<em class="mc"> 5n </em></li><li id="dea7" class="nq nr iq kz b la nz ld oa lg ob lk oc lo od ls nv nw nx ny bi translated">距离约束范围从<em class="mc"> 0 </em>到所有<em class="mc"> i </em>和<em class="mc"> k </em>的最大欧几里德距离。</li></ul><p id="9003" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">假设所有这些约束共享相同的优先级，我们必须定义惩罚因子来平衡不同的约束。</p><p id="b0fe" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">下面是相应的代码:</p><pre class="kg kh ki kj gt oe of og oh aw oi bi"><span id="f4cd" class="oj me iq of b gy ok ol l om on"># Integer distance function<br/>idist = <strong class="of ir">lambda</strong> xy1, xy2: <strong class="of ir">int</strong>(((xy1[0]-xy2[0])**2 + (xy1[1]-xy2[1])**2)**0.5)</span><span id="e810" class="oj me iq of b gy qi ol l om on"># Gain factors (1/penalty factors)<br/>gain_max_patients = 140<br/>gain_severity = <strong class="of ir">int</strong>(140/5)<br/>gain_distance = -1</span><span id="116a" class="oj me iq of b gy qi ol l om on"># Maximization objective<br/>soft_csts = []<br/><strong class="of ir">for</strong> i <strong class="of ir">in</strong> range(n_hospitals):<br/>  <strong class="of ir">for</strong> j <strong class="of ir">in</strong> range(n_beds_in_hospitals[i]):<br/>    <strong class="of ir">for</strong> k <strong class="of ir">in</strong> range(n_patients):<br/>      factor = \<br/>        gain_max_patients \<br/>        + gain_distance * idist(hospitals_loc[i], patients_loc[k]) \<br/>        + gain_severity * patients_severity[k]<br/>      soft_csts.append(factor * x[(i,j,k)])</span><span id="12cf" class="oj me iq of b gy qi ol l om on">model.Maximize(sum(soft_csts))</span></pre><h1 id="eddc" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">解决者</h1><p id="204c" class="pw-post-body-paragraph kx ky iq kz b la mv jr lc ld mw ju lf lg mx li lj lk my lm ln lo mz lq lr ls ij bi translated">现在我们可以启动求解器了。它会尝试在指定的时间限制内找到最优解。如果它无法找到最优解，它将返回最接近的次优解。</p><pre class="kg kh ki kj gt oe of og oh aw oi bi"><span id="6b98" class="oj me iq of b gy ok ol l om on">solver = cp_model.CpSolver()<br/>solver.parameters.max_time_in_seconds = 60.0<br/>status = solver.Solve(model)</span></pre><p id="077e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在我们的例子中，求解器在 2.5 秒内返回一个<strong class="kz ir">最优解</strong> (2)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/333f77c34652c530ef0fc5d0a3f8e188.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3xmEqKZZdmrF4WGqy0ZxcQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><em class="kv">图 2:求解器返回的解</em></p></figure><h1 id="c1a8" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">结论</h1><p id="b34b" class="pw-post-body-paragraph kx ky iq kz b la mv jr lc ld mw ju lf lg mx li lj lk my lm ln lo mz lq lr ls ij bi translated">要创建这个解决方案，只需要<strong class="kz ir"> 1 小时的研究和 30 分钟的编程</strong>。</p><blockquote class="qj qk ql"><p id="dc04" class="kx ky mc kz b la lb jr lc ld le ju lf qm lh li lj qn ll lm ln qo lp lq lr ls ij bi translated">对于深度学习的对手，人们可以预测几天的数据清洗，至少一天的时间来测试不同的架构，另一天用于训练。</p></blockquote><p id="c09d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">此外，如果模型化良好，CP-SAT 模型是非常稳健的。以下是不同模拟参数的结果(3)。在许多不同的情况下，结果仍然是一致的，随着模拟参数的增加(3000 名患者，1000 张病床)，解决方案推断只需不到 3 分钟。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi qp"><img src="../Images/2208e3746fc5e4ab4ce29d3d6a1b6ed6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JzV4oaxp_ip1qYPN7l6XIQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><em class="kv">图 3:不同的模拟参数</em></p></figure><p id="178d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">当然，CSP 几乎不适用于计算机视觉和 NLP 等主题，在这些主题中，深度学习有时是最好的方法。然而，在物流，调度和计划，它往往是要走的路。</p></div><div class="ab cl pu pv hu pw" role="separator"><span class="px bw bk py pz qa"/><span class="px bw bk py pz qa"/><span class="px bw bk py pz"/></div><div class="ij ik il im in"><p id="cc4b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">深度学习炒作激发了一些人<a class="ae kw" rel="noopener" target="_blank" href="/detecting-covid-19-with-97-accuracy-beware-of-the-ai-hype-9074248af3e1">尝试一些疯狂的举动</a>来获得认可。有时，最好是通过阅读几篇关于你正在研究的问题的调查论文来回归基础。</p><p id="4c93" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><a class="ae kw" href="https://www.antoinechampion.com/Blog?articleId=4" rel="noopener ugc nofollow" target="_blank"> <em class="mc">安托万冠军 2020 年 4 月 1 日</em> </a></p><h1 id="4836" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">参考</h1><p id="fe87" class="pw-post-body-paragraph kx ky iq kz b la mv jr lc ld mw ju lf lg mx li lj lk my lm ln lo mz lq lr ls ij bi translated">[1]陈景超，<em class="mc">利用 SAT 求解器求解魔方</em>，arXiv:1105.1436，2011 .</p><p id="fb8e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">[2] Biere，a .，Heule，m .，和 van Maaren，H. <em class="mc">可满足性手册</em>，第 185 卷。IOS 出版社，2009 年 a</p><p id="0410" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">[3] Knuth，D. E .，<em class="mc">计算机编程的艺术</em>，第 4 卷，分册 6:可满足性。艾迪森-韦斯利专业公司，2015 年</p><p id="9103" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">[4] Vipin Kumar，<em class="mc">约束满足问题的算法:一项调查</em>，AI 杂志第 13 卷，第 1 期，1992 年。</p></div></div>    
</body>
</html>