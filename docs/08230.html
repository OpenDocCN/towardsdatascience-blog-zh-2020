<html>
<head>
<title>How to Build a Travel Planning Application with Memgraph, Cypher &amp; Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Memgraph、Cypher和Python构建旅行规划应用程序</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-build-a-travel-planning-application-with-memgraph-cypher-python-a1b0b346d529?source=collection_archive---------42-----------------------#2020-06-16">https://towardsdatascience.com/how-to-build-a-travel-planning-application-with-memgraph-cypher-python-a1b0b346d529?source=collection_archive---------42-----------------------#2020-06-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="bbfc" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解如何利用广度优先搜索(BFS)和Dijkstra算法，用Memgraph、Cypher和Python构建一个简单的旅行规划应用程序。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/43396d0de8a9491ee60bb2fd867e15fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*NMJPC48Zleq5VxU-.jpg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><em class="kv">Christopher Czermak在Unsplash上拍摄的照片</em></p></figure><h1 id="afed" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">介绍</h1><p id="2a3b" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">背包旅行是一种在预算范围内探索世界的好方法。凭借其良好的交通网络、经济实惠的住宿条件和数以千计的景点，欧洲是背包客的完美旅行目的地。</p><p id="a9a4" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在本教程中，您将学习如何利用Memgraph、Cypher和Python构建一个简单的旅行规划应用程序。您将学习如何使用图形数据库，以及如何使用Python语言驱动程序查询它。您还将学习如何利用流行的图形算法，包括<a class="ae mp" href="https://en.wikipedia.org/wiki/Breadth-first_search" rel="noopener ugc nofollow" target="_blank">广度优先搜索(BFS) </a>和<a class="ae mp" href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm" rel="noopener ugc nofollow" target="_blank"> Dijkstra的算法</a>。</p><h1 id="4a7c" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">先决条件</h1><p id="d846" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">要跟进，您需要以下内容:</p><ul class=""><li id="ee00" class="mq mr iq lq b lr mk lu ml lx ms mb mt mf mu mj mv mw mx my bi translated">运行Linux的机器。</li><li id="8378" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated">Memgraph的本地安装。您可以参考<a class="ae mp" href="https://docs.memgraph.com/memgraph/quick-start" rel="noopener ugc nofollow" target="_blank">Memgraph文档</a>。</li><li id="d583" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated">Python内存图客户端。</li><li id="5e02" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated">Python编程语言的基础知识。在本教程中，我们将使用Python 3。</li><li id="f2cf" class="mq mr iq lq b lr mz lu na lx nb mb nc mf nd mj mv mw mx my bi translated">Cypher查询语言的基础知识。</li></ul><h1 id="cdff" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">步骤2 —构建数据模型</h1><p id="ded0" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">首先，我们必须定义我们将用来构建您的应用程序的数据模型。用于图形分析的最常见的数据模型之一是标签属性图(LPG)模型。这个模型被定义为一组顶点(即节点)和边(即关系)以及它们的属性和标签。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/7a06783b033f791ed1b55791eddbddb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*UJ6Fr_43_2wN8s4Z.png"/></div></div></figure><p id="ac8d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在本教程中，您将使用欧洲背包客指数(2018)数据集，该数据集包含位于36个欧洲国家的56个城市的信息。您的模型将包含两个类型为<code class="fe nf ng nh ni b">City</code>和<code class="fe nf ng nh ni b">Country</code>的顶点，三个类型为<code class="fe nf ng nh ni b">Inside</code>、<code class="fe nf ng nh ni b">CloseTo</code>和<code class="fe nf ng nh ni b">Borders</code>的边，以及一些属性，如名称、排名、当地货币等。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nj"><img src="../Images/44b0b96e1b988d11767d36cf4395c02b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RWkauXa6VURtb8HX.png"/></div></div></figure><p id="98e3" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">既然已经定义了数据模型，下一步就是将数据导入Memgraph。</p><h1 id="400d" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">步骤3—使用Cypher和Python将数据导入Memgraph</h1><p id="2bba" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">为了将数据导入Memgraph，您将通过Python客户端<code class="fe nf ng nh ni b">pymgclient</code>使用Cypher查询。</p><p id="6259" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">pymgclient是Python编程语言的Memgraph数据库适配器，符合PEP 249描述的DB-API 2.0规范。</p><p id="5680" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">Cypher是一种声明式查询语言，被许多人认为是处理属性图数据库的行业标准。</p><p id="1654" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在开始之前，你必须安装<code class="fe nf ng nh ni b">pymgclient</code>。这将允许您连接到Memgraph并运行您的查询。为此，我们将运行以下命令:</p><pre class="kg kh ki kj gt nk ni nl nm aw nn bi"><span id="b83c" class="no kx iq ni b gy np nq l nr ns">pip install pymgclient</span></pre><p id="f1f4" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在我们已经安装了<code class="fe nf ng nh ni b">pymgclient</code>，我们准备导入它并连接到Memgraph数据库。为此，我们将使用以下Python代码:</p><pre class="kg kh ki kj gt nk ni nl nm aw nn bi"><span id="e556" class="no kx iq ni b gy np nq l nr ns">import mgclient</span><span id="e78a" class="no kx iq ni b gy nt nq l nr ns"># Connect to the database<br/>connection = mgclient.connect(<br/>    host='127.0.0.1',<br/>    port=7687,<br/>    sslmode=mgclient.MG_SSLMODE_REQUIRE)<br/>connection.autocommit = True</span></pre><p id="67fe" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">既然我们的python客户机已经连接到Memgraph，我们就可以开始运行查询了。为了加速数据导入，我们在<code class="fe nf ng nh ni b">City</code>和<code class="fe nf ng nh ni b">Country</code>顶点的<code class="fe nf ng nh ni b">id</code>属性上创建索引。这将有助于Memgraph在创建边时快速找到城市和国家。注意，我们可以在另一个属性上创建索引，比如<code class="fe nf ng nh ni b">name</code>，我们将获得相同的结果。</p><p id="2673" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">[注意]数据库索引实质上是创建数据库中某些数据的冗余副本，以提高索引数据的搜索效率。然而，这是以额外的存储空间和更多的写入为代价的，因此决定索引什么和不索引什么是一个重要的决定。</p><p id="aaaa" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">为了创建索引，我们将执行以下查询:</p><pre class="kg kh ki kj gt nk ni nl nm aw nn bi"><span id="0cd6" class="no kx iq ni b gy np nq l nr ns">connection.cursor().execute("""<br/>CREATE INDEX ON :City (id)<br/>""")<br/>connection.cursor().execute("""<br/>CREATE INDEX ON :Country (id)<br/>""")</span></pre><p id="cea1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">既然我们的索引已经创建，我们将开始导入我们的，从国家开始。为此，我们将运行下面的<a class="ae mp" href="https://download.memgraph.com/dataset/europe-backpacking/python/countries.txt" rel="noopener ugc nofollow" target="_blank">查询</a>。</p><p id="2808" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">正如您所看到的，这个查询使用了<code class="fe nf ng nh ni b">CREATE</code>子句来创建一个带有一个标签<code class="fe nf ng nh ni b">Country</code>和两个属性<code class="fe nf ng nh ni b">id</code>和<code class="fe nf ng nh ni b">name</code>的顶点。</p><p id="9c7a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">接下来，我们将添加<code class="fe nf ng nh ni b">City</code>节点及其所有属性，如当地货币、餐饮的平均价格、交通费用等。为此，我们将使用下面的<a class="ae mp" href="https://download.memgraph.com/dataset/europe-backpacking/python/cities.txt" rel="noopener ugc nofollow" target="_blank">查询</a>。</p><p id="523e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如您所见，该查询使用相同的<code class="fe nf ng nh ni b">CREATE</code>子句创建标签为<code class="fe nf ng nh ni b">City</code>的节点，以及14个不同的属性。</p><p id="c692" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在我们已经创建了图表中的所有节点，我们准备开始添加边。为此，我们将运行下面的<a class="ae mp" href="https://download.memgraph.com/dataset/europe-backpacking/python/edges.txt" rel="noopener ugc nofollow" target="_blank">查询</a>。</p><p id="f1e4" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在这个查询中，我们首先使用<code class="fe nf ng nh ni b">MATCH</code>子句获取两个<code class="fe nf ng nh ni b">City</code>节点，我们将在这两个节点之间创建一条边，然后使用<code class="fe nf ng nh ni b">CREATE</code>子句创建一条标签为<code class="fe nf ng nh ni b">CloseTo</code>的边和一个值为<code class="fe nf ng nh ni b">True</code>或<code class="fe nf ng nh ni b">False</code>的属性<code class="fe nf ng nh ni b">eu_border</code>。</p><p id="b59f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">恭喜你。现在，您已经将所有数据集导入Memgraph。现在，您可以开始执行查询和算法了。</p><h1 id="0ef1" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">步骤4—用Python运行简单的密码查询</h1><p id="89f4" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">首先，我们可以运行一些简单的查询，比如获得旅馆最便宜的前10个城市。为此，您将运行以下查询:</p><pre class="kg kh ki kj gt nk ni nl nm aw nn bi"><span id="d8ea" class="no kx iq ni b gy np nq l nr ns">cursor = connection.cursor()<br/>cursor.execute("""<br/>MATCH (n:City)<br/>RETURN n.name, n.cheapest_hostel, n.cost_per_night_USD, n.hostel_url<br/>ORDER BY n.cost_per_night_USD LIMIT 10<br/>""")<br/>print(cursor.fetchall())</span></pre><p id="4886" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">该查询匹配所有标签为<code class="fe nf ng nh ni b">City</code>的顶点，并返回城市名称、最便宜的旅馆名称、该旅馆每晚的费用以及旅馆URL。然后，它根据最便宜的旅馆每晚的费用对结果进行排名，并返回前10个结果。</p><p id="723d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如果你去意大利旅游，想知道哪些城市适合背包客，哪家旅社对他们来说最便宜，该怎么办？要获得答案，您将运行以下查询:</p><pre class="kg kh ki kj gt nk ni nl nm aw nn bi"><span id="8759" class="no kx iq ni b gy np nq l nr ns">cursor = connection.cursor()<br/>cursor.execute("""<br/>MATCH (c:City)-[:Inside]-&gt;(:Country {name: "Italy"})<br/>RETURN c.name, c.cheapest_hostel, c.total_USD<br/>ORDER BY c.total_USD;<br/>""")<br/>print(cursor.fetchall())</span></pre><p id="3628" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如您所见，该查询类似于我们之前使用的查询，但是我们没有匹配所有城市，而是只匹配通过类型<code class="fe nf ng nh ni b">Inside</code>的边缘连接到意大利的城市</p><h1 id="b9d8" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">步骤5—使用广度优先搜索算法查找和过滤路径</h1><p id="f7d3" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">尽管这些查询给了我们一些有趣的见解和结果，但它们并不是图数据库特别感兴趣的东西。当我们开始询问涉及遍历任意数量的边的更复杂的问题时，图数据库变得很有价值。这些类型的寻路查询对于传统数据库来说可能会有问题，因为它们通常需要多个连接。</p><p id="4e8a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">假设您想要从西班牙旅行到俄罗斯，但是您想要选择穿过最少边界的路线。这就是像广度优先搜索(BSF)这样的图算法派上用场的地方。要获得答案，您将使用以下查询:</p><pre class="kg kh ki kj gt nk ni nl nm aw nn bi"><span id="c12f" class="no kx iq ni b gy np nq l nr ns">cursor = connection.cursor()<br/>cursor.execute("""<br/>MATCH p = (n:Country {name: "Spain"})<br/>          -[r:Borders * bfs]-<br/>          (m:Country {name: "Russia"})<br/>UNWIND (nodes(p)) AS rows<br/>RETURN rows.name;<br/>""")<br/>print(cursor.fetchall())</span></pre><p id="6312" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">该查询使用类型为<code class="fe nf ng nh ni b">Borders</code>的边评估西班牙和俄罗斯之间的所有可能路径，计算每条路径的过境次数，并返回过境次数最少的路径。</p><p id="b68a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如果您想根据特定标准过滤路径，该怎么办？假设您想从布拉迪斯拉发开车到马德里，并想计划您的路线以尽量减少停靠站的数量。你也想只去那些把欧元作为当地货币的国家，因为那是你唯一剩下的货币。为此，您将使用以下查询:</p><pre class="kg kh ki kj gt nk ni nl nm aw nn bi"><span id="d1a3" class="no kx iq ni b gy np nq l nr ns">cursor = connection.cursor()<br/>cursor.execute("""<br/>MATCH p = (:City {name: "Bratislava"})<br/>          -[:CloseTo * bfs (e, v | v.local_currency = "Euro")]-<br/>          (:City {name: "Madrid"})<br/>UNWIND (nodes(p)) AS rows<br/>RETURN rows.name;<br/>""")<br/>print(cursor.fetchall())</span></pre><p id="c2c6" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如您所见，我们向查询<code class="fe nf ng nh ni b">(e, v | v.local_currency = "Euro")</code>添加了一个特殊的语法。这被称为过滤λ函数。过滤器λ取一个边符号<code class="fe nf ng nh ni b">e</code>和一个顶点符号<code class="fe nf ng nh ni b">v</code>，并通过返回true或false(或Null)来决定该边和顶点对在广度优先扩展中是否应该被认为是有效的。在本例中，如果城市顶点<code class="fe nf ng nh ni b">v</code>的类型<code class="fe nf ng nh ni b">v.local_currency</code>的属性值等于Euro，lambda函数返回true。一旦确定了最佳路径，查询将返回该路径上的城市列表，并且<code class="fe nf ng nh ni b">UNWIND</code>子句将该列表解包到单独的行中。</p><h1 id="172f" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">步骤6-使用Dijkstra算法寻找最短路径</h1><p id="5ad9" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">到目前为止，您使用了广度优先搜索算法来查找穿过最少边数的路径。但是，如果你想找到一条最短的路径，并考虑到沿途每个城市的住宿价格，那该怎么办呢？换句话说，如果你想找到最短最便宜的路径呢？这是广度优先搜索算法达到极限的地方。只有当所有的边和顶点都没有权重或者具有相同的权重时，BFS才会准确地计算最短路径。</p><p id="8c5d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">当涉及到在图中寻找边和顶点不具有相同权重的最短路径时，您将需要使用Dijkstra算法。</p><p id="d076" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">例如，假设你想从布鲁塞尔旅行到雅典，而你的预算很紧。为了找到最便宜的路线，您可以使用以下查询:</p><pre class="kg kh ki kj gt nk ni nl nm aw nn bi"><span id="98a3" class="no kx iq ni b gy np nq l nr ns">cursor = connection.cursor()<br/>cursor.execute("""<br/>MATCH p = (:City {name: "Brussels"})<br/>          -[:CloseTo * wShortest (e, v | v.cost_per_night_USD) total_cost]-<br/>          (:City {name: "Athens"})<br/>WITH extract(city in nodes(p) | city.name) AS trip, total_cost<br/>RETURN trip, total_cost;<br/>""")<br/>print(cursor.fetchall())</span></pre><p id="aa9c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如您所见，语法几乎与我们的BFS查询相同。我们使用加权最短路径<code class="fe nf ng nh ni b">wShortest</code>并指定<code class="fe nf ng nh ni b">cost_per_night</code>属性类型作为我们的权重。权重lambda表示使用给定边<code class="fe nf ng nh ni b">v.cost_per_night_USD</code>扩展到指定顶点的成本，<code class="fe nf ng nh ni b">total cost</code>符号计算行程成本。extract函数仅用于显示城市名称。要获得完整的城市信息，您应该返回<code class="fe nf ng nh ni b">nodes(p)</code>。</p><h1 id="1708" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">结论</h1><p id="cb6d" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">你有它！您刚刚学习了如何使用图形数据库、Cypher和Python构建一个简单的旅行路线规划应用程序。您还了解了如何使用广度优先搜索算法和Dijkstra算法在复杂的互联数据网络中导航，并使用强大而灵活的lambda函数过滤结果。</p></div></div>    
</body>
</html>