<html>
<head>
<title>How to parse JSON data with Python Pandas?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用 Python 熊猫解析 JSON 数据？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-parse-json-data-with-python-pandas-f84fbd0b1025?source=collection_archive---------0-----------------------#2020-07-04">https://towardsdatascience.com/how-to-parse-json-data-with-python-pandas-f84fbd0b1025?source=collection_archive---------0-----------------------#2020-07-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="abe5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用 Pandas 读取 JSON 数据并将其规范化为平面表的一行程序。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b61d6010ee71c8799cdbc7635f6d2cec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f8c7_-niT0vO5WGBY9TXeA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:作者图片</p></figure><p id="f8c3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您正在从事与数据相关的工作，无论是数据工程、数据分析，甚至是数据科学，您肯定会遇到 JSONs。</p><p id="8954" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">JSON (JavaScript Object Notation)是在 web 上交换数据最常用的数据格式之一。像 MongoDB 这样基于 NoSQL 的数据库以这种格式存储数据。尽管这种格式很适合存储数据，但需要将其转换成表格形式以便进一步分析。</p><p id="a7fb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个故事中，我们将看到解析 JSON 数据并将其转换成表格形式是多么容易。您可以从下面提到的 GitHub 资源库下载示例数据。此外，请查看笔记本，了解有关所用数据和 API 的更多详细信息。</p><div class="lu lv gp gr lw lx"><a href="https://github.com/ankitgoel1602/data-science/tree/master/json-data" rel="noopener  ugc nofollow" target="_blank"><div class="ly ab fo"><div class="lz ab ma cl cj mb"><h2 class="bd iu gy z fp mc fr fs md fu fw is bi translated">ankitgoel 1602/数据科学</h2><div class="me l"><h3 class="bd b gy z fp mc fr fs md fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="mf l"><p class="bd b dl z fp mc fr fs md fu fw dk translated">github.com</p></div></div><div class="mg l"><div class="mh l mi mj mk mg ml ks lx"/></div></div></a></div><h2 id="8c71" class="mm mn it bd mo mp mq dn mr ms mt dp mu lh mv mw mx ll my mz na lp nb nc nd ne bi translated">数据细节</h2><p id="bc1d" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">我将使用我在处理机器学习聚类问题时生成的数据。不必担心这些数据没有意义，因为它们仅用于演示目的。我将使用两种不同的 JSON</p><ol class=""><li id="78b2" class="nk nl it la b lb lc le lf lh nm ll nn lp no lt np nq nr ns bi translated">没有嵌套列表/字典的简单 JSON。</li></ol><p id="38e8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这已经是扁平化的 JSON，只需要最少的处理。</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="5323" class="mm mn it nu b gy ny nz l oa ob">Sample Record:<br/>{<br/>    "Scaler": "Standard",<br/>    "family_min_samples_percentage": 5,<br/>    "original_number_of_clusters": 4,<br/>    "eps_value": 0.1,<br/>    "min_samples": 5,<br/>    "number_of_clusters": 9,<br/>    "number_of_noise_samples": 72,<br/>    "adjusted_rand_index": 0.001,<br/>    "adjusted_mutual_info_score": 0.009,<br/>    "homogeneity_score": 0.330,<br/>    "completeness_score": 0.999,<br/>    "v_measure_score": 0.497,<br/>    "fowlkes_mallows_score": 0.0282,<br/>    "silhouette_coefficient": 0.653,<br/>    "calinski_harabasz_score": 10.81,<br/>    "davies_bouldin_score": 1.70<br/>}</span></pre><p id="e4cf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">2.带有嵌套列表/字典的 JSON。</p><p id="e716" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这可能看起来有点复杂，一般来说，需要你写一个扁平化的脚本。稍后，我们将看到如何用一行代码将它转换成 DataFrame。</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="1029" class="mm mn it nu b gy ny nz l oa ob">Sample Record:<br/>{<br/>  'Scaler': 'Standard',<br/>  'family_min_samples_percentage': 5,<br/>  'original_number_of_clusters': 4,<br/>  'Results': <br/>  [<br/>      {<br/>        'eps_value': 0.1,<br/>        'min_samples': 5,<br/>        'number_of_clusters': 9,<br/>        'number_of_noise_samples': 72,<br/>        'scores': <br/>            {<br/>             'adjusted_rand_index': 0.001,<br/>             'adjusted_mutual_info_score': 0.009,<br/>             'homogeneity_score': 0.331,<br/>             'completeness_score': 0.999,<br/>             'v_measure_score': 0.497,<br/>             'fowlkes_mallows_score': 0.028,<br/>             'silhouette_coefficient': 0.653,<br/>             'calinski_harabasz_score': 10.81,<br/>             'davies_bouldin_score': 1.70<br/>            }<br/>      },<br/>      {<br/>        'eps_value': 0.1,<br/>        'min_samples': 10,<br/>        'number_of_clusters': 6,<br/>        'number_of_noise_samples': 89,<br/>        'scores': <br/>            {<br/>             'adjusted_rand_index': 0.001,<br/>             'adjusted_mutual_info_score': 0.008,<br/>             'homogeneity_score': 0.294,<br/>             'completeness_score': 0.999,<br/>             'v_measure_score': 0.455,<br/>             'fowlkes_mallows_score': 0.026,<br/>             'silhouette_coefficient': 0.561,<br/>             'calinski_harabasz_score': 12.528,<br/>             'davies_bouldin_score': 1.760<br/>            }<br/>      }<br/>  ]<br/>}</span></pre><h2 id="136d" class="mm mn it bd mo mp mq dn mr ms mt dp mu lh mv mw mx ll my mz na lp nb nc nd ne bi translated">熊猫阅读 _json()</h2><p id="1066" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">Pandas 的这个 API 有助于读取 JSON 数据，对于已经扁平化的数据非常有用，就像我们在示例 1 中看到的那样。你可以从<a class="ae oc" href="https://github.com/ankitgoel1602/data-science/blob/master/json-data/level_1.json" rel="noopener ugc nofollow" target="_blank">这里</a>下载 JSON。</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="0f87" class="mm mn it nu b gy ny nz l oa ob"># Reading JSON<br/>pd.read_json('level_1.json')</span></pre><p id="a7a6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">只是看了 JSON 就把它转换成了下面的平面表。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/2e825bbb986f72e383634a37100cd939.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VVaYLoQKgxSQAWaEOwDKtw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者使用 read_json()展平数据</p></figure><p id="9c81" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当 JSON 数据是半结构化的，即包含嵌套的列表或字典时，就像我们在示例 2 中看到的那样，这样做效果不好。</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="248a" class="mm mn it nu b gy ny nz l oa ob"># Example 2 JSON<br/>pd.read_json('multiple_levels.json')</span></pre><p id="ba82" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在阅读了这个 JSON 之后，我们可以在下面看到我们的嵌套列表被放在一个单独的列“Results”中。在下一节中，我们将了解如何扁平化这些数据。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/eb1ce93b46699aee5549a8a698d071b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gi3R3PXXGpUaJ7uwFNDUvA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:作者图片</p></figure><h2 id="756c" class="mm mn it bd mo mp mq dn mr ms mt dp mu lh mv mw mx ll my mz na lp nb nc nd ne bi translated">熊猫 json_normalize()</h2><p id="2e8f" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">这个 API 主要用于将半结构化的 JSON 数据转换成平面表或数据帧。你可以从<a class="ae oc" href="https://github.com/ankitgoel1602/data-science/blob/master/json-data/multiple_levels.json" rel="noopener ugc nofollow" target="_blank">这里</a>下载 JSON 的例子。</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="6ebf" class="mm mn it nu b gy ny nz l oa ob"># load data using Python JSON module<br/>with open('multiple_levels.json','r') as f:<br/>    data = json.loads(f.read())</span><span id="6bf8" class="mm mn it nu b gy of nz l oa ob"># Normalizing data<br/>multiple_level_data = pd.json_normalize(data, record_path =['Results'], meta =['original_number_of_clusters','Scaler','family_min_samples_percentage'], meta_prefix='config_params_', record_prefix='dbscan_')</span><span id="e65d" class="mm mn it nu b gy of nz l oa ob"># Saving to CSV format<br/>multiple_level_data.to_csv('multiplelevel_normalized_data.csv', index=False)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/00efc586bae8854a1f9b4f7cb92cab0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lMyy88ZAOhSvuBzIiZRDJA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者使用 json_normalize()平面化数据</p></figure><p id="cbfa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，让我们来理解我在这里使用的将 JSON 转换成平面表的一个神奇的代码行。这个 API 提供了不同的参数，你可以在这里阅读更多关于它们的信息<a class="ae oc" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.json_normalize.html" rel="noopener ugc nofollow" target="_blank">。这里我们使用了-</a></p><ul class=""><li id="a60b" class="nk nl it la b lb lc le lf lh nm ll nn lp no lt oh nq nr ns bi translated">记录路径</li><li id="1732" class="nk nl it la b lb oi le oj lh ok ll ol lp om lt oh nq nr ns bi translated">记录前缀</li><li id="d562" class="nk nl it la b lb oi le oj lh ok ll ol lp om lt oh nq nr ns bi translated">自指的</li><li id="60f5" class="nk nl it la b lb oi le oj lh ok ll ol lp om lt oh nq nr ns bi translated">元前缀</li></ul><p id="ef19" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们一个一个地看一遍。</p><p id="9180" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">T3】记录 _ 路径 T5】</strong></p><p id="5753" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是我们想要展平的嵌套数组或列表的路径。在我们的例子中,“结果”有多个包含算法超参数和度量分数的嵌套字典。</p><p id="5c61" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> <em class="on">记录 _ 前缀</em> </strong></p><p id="3f28" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">默认情况下，json_normalize 会根据父数据为嵌套字典添加一个前缀(字符串),就像我们的示例中 davies_bouldin_score 转换为 scores.davies_bouldin_score 一样。对于嵌套列表，我们可以使用 record_prefix 添加到扁平数据中。在我们的示例中,“结果”列表中的每个值都与 DBSCAN 算法相关，因此我们可以追加相同的值(dbscan_)。这将把 scores.davies_bouldin_score 转换为 db scan _ scores . Davies _ boul din _ score。</p><p id="eeef" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> <em class="on">元</em> </strong></p><p id="41e7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该参数有助于将每个记录的元数据添加到结果表中。此处，元数据将位于记录路径之外，即 Scaler、original_number_of_clusters 或 family_min_samples_percentage。</p><p id="1d93" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> <em class="on">元 _ 前缀</em> </strong></p><p id="cda7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">与 record_prefix 类似，meta_prefix 会将字符串附加到定义为“meta”一部分的元数据中。在我们的例子中，所有的元数据都与 ML 问题的配置参数相关，因此我们在每个元数据后面附加了‘config _ params _’。</p></div><div class="ab cl oo op hx oq" role="separator"><span class="or bw bk os ot ou"/><span class="or bw bk os ot ou"/><span class="or bw bk os ot"/></div><div class="im in io ip iq"><p id="a8c1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望这篇文章能在您下次处理 JSON 数据时有所帮助。我过去常常编写 python 脚本来扁平化数据，或者使用各种包来解决问题，而现在只需要 10 秒钟。如果你对数据科学感兴趣，或者想了解一些很酷的 python 库，那么看看我的另一个博客- <a class="ae oc" href="https://towardsdatascience.com/swlh/start-your-data-science-journey-today-37366ee463f" rel="noopener" target="_blank">今天就开始你的数据科学之旅</a>。</p><p id="62b6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意安全！！！继续学习！！！</p></div></div>    
</body>
</html>