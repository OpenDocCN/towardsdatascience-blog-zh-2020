<html>
<head>
<title>Drawing financial stock market charts using OpenGL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用OpenGL绘制金融股票行情图</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/drawing-financial-stock-market-charts-using-opengl-93254883bca7?source=collection_archive---------26-----------------------#2020-04-08">https://towardsdatascience.com/drawing-financial-stock-market-charts-using-opengl-93254883bca7?source=collection_archive---------26-----------------------#2020-04-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bc08" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">利用GPU核心通过GLSL卸载CPU</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/8d6c2d122da62a54faa19eb9e6610669.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/0*l5o2FJOeOUsEvK1D.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">OpenGL图表图像。来源:<a class="ae ku" href="https://commons.wikimedia.org/wiki/File:Krita%27s_OpenGL_canvas_drawing_quality.png" rel="noopener ugc nofollow" target="_blank">维基共享资源</a>。</p></figure><h1 id="2318" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated">介绍</h1><p id="1fde" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">我一直致力于将OpenGL作为显示图形的终极方式。在本文中，我将描述如何将数据从CPU转移到GPU。虽然这是正常的方法，但我发现的所有信息都专注于提供与3D渲染过程直接相关的数据(位置、颜色、法线)，我花了很长时间来理解和定位关于如何将更高抽象数据移动到GPU的信息，比传统的3D模型点更远。在这种情况下，OpenGL社区和可用的信息也没有多大帮助，因为大多数活跃在论坛中的人通常都参与3D引擎。</p><p id="8a14" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">说白了，我正试图让GPU从与图形无关的数据中完成实际的图形模型，这似乎是一个不太常见的OpenGL任务。这可以认为是做纯渲染(OpenGL)和做纯计算(OpenCL)的中间步骤。我们正在将计算过程卸载到GPU中，但它仍然是与渲染相关的代码。</p><p id="58b7" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">在我的例子中，我正在处理2D股票市场数据，我希望GPU负责处理所有的金融数据，以显示一切。对于那些不熟悉财务图表的人来说，举一个可能更容易理解的例子，假设您正在绘制一个有许多树的森林场景。您可能传递给GPU的信息包括树的位置、树的类型的整数(我们可能有不同类型的树要渲染)、树的高度和宽度。GPU可以从这些简单的信息中为每棵树构建数百个图元。通过这样做，CPU不需要将我们高度抽象的木材模型(位置、树的类型、宽度和高度)转换成可绘制的模型。性能的提升是巨大的，因为我们利用了GPU的大量内核。另一个好处是，我们还将图形部分从应用程序中分离出来，将所有的渲染和图形模型构建例程转移到GLSL。</p><p id="a134" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">GPU拥有强大的能力。由于我目前正在开发要求不那么高的2D应用程序，我已经使用旧的廉价NVIDIA Quadro卡在旧的OpenGL标准(3.3)中稳定了我的开发，这些卡在旧的交易工作站中很常见。我这样做是为了确保我的应用程序可以在遗留硬件中使用。我正在处理的卡有16个内核，这并不令人印象深刻，但现代卡现在有数百个内核(在撰写本文时，Nvidia GeForce RTX 2080 Ti代表了4352个内核的最先进水平)。在一台经济实惠的电脑上搭载4000多枚内核简直太棒了。然而，与使用CPU在应用程序级别实现图形的传统方法相比，即使是普通的传统卡也能大大提高图形性能。作为一种权衡，编程GLSL并将图形卸载到GPU会使编程变得更加复杂:调试GLSL具有挑战性，有时甚至令人沮丧。</p><p id="05ac" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">在这篇文章中，我将描述我遇到问题的地方，主要是因为我没有做非常传统的事情(比如将整数传递给顶点着色器)和理解步幅和偏移。我把注意力集中在令我烦恼的特定概念和代码部分。</p><h1 id="38de" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated">顶点数据涉及任意数据</h1><p id="9f96" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">尽管顾名思义，你是在表示顶点(顺便提一下，这是最常见的用例)，但顶点只是你移入GPU的缓冲数据，特别是移入顶点着色器。这些数据可以包含绘制实际模型所需的任意信息。通常这将包括关于位置的某些信息，但是它可能意味着更高的抽象模型，其中位置由该抽象模型隐式地定义。</p><p id="a89f" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">在我们的例子中，我们将制作一张简单的蜡烛图。因此，我们的输入数据将是:</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="fe9a" class="mt kw it mp b gy mu mv l mw mx">open price, high price, low price, close price, volume, timestamp</span></pre><p id="395b" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">除此之外，我们希望GLSL画出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi my"><img src="../Images/356b5fb3da3a84a22104b857b5e60cee.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/1*zALwPx6eOsI_v-rkNolkPA.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">OpenGL中绘制蜡烛的“hello world”</p></figure><p id="10b3" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">所以我们的顶点信息不包含传统意义上的x/y位置。并且它绝对不涉及图形元素(点/线/三角形)。我们只需将蜡烛信息移入GPU，并让卡片完成所有绘图。通过这样做:</p><ol class=""><li id="1d91" class="mz na it lp b lq mj lt mk lw nb ma nc me nd mi ne nf ng nh bi translated">应用程序现在更容易编码，因为它管理实际的现实生活数据(所有应用程序都应该尝试这样做)，绘制实际蜡烛的问题缩小到GPU。</li><li id="dec9" class="mz na it lp b lq ni lt nj lw nk ma nl me nm mi ne nf ng nh bi translated">性能的提升是巨大的，因为我们利用我们的GPU核心来执行构建图元时涉及的简单操作。</li><li id="6d4e" class="mz na it lp b lq ni lt nj lw nk ma nl me nm mi ne nf ng nh bi translated">我们已经在模型层和表示层之间做了最好的解耦——软件开发中的解耦是少数几个<em class="nn">几乎总是有意义的建议之一——</em>。</li></ol><h1 id="1813" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated">GLSL数据类型</h1><p id="2b1d" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">与传统编程相比，使用GLSL编程GPU有一定的局限性。最后，我们正在处理为渲染而优化的小内核。GLSL深受C语言的影响，所以它继承了一些C类型，但同时，它有特殊的类型用于处理多达4个元素的向量和矩阵。我仍然在研究可变大小的数组是否可以被移入GPU，但目前我使用的是基本类型:</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="ceef" class="mt kw it mp b gy mu mv l mw mx">bool - boolean type (true/false)<br/>float - 4 bytes<br/>double - 8 bytes<br/>int - 4 bytes signed integer<br/>uint - 4 bytes unsigned integer<br/>vec2 - 2 float vector (vec2.x, vec2.y)<br/>vec3 - 3 float vector (vec3.x, vec3.y, vec3.z)<br/>vec4 - 4 float vector (vec4.x, vec4.y, vec4.z, vec4.w)<br/>ivec2 - 2 int vector (ivec2.x, ivec2.y)<br/>ivec3 - 3 int vector (ivec3.x, ivec3.y, ivec3.z)<br/>ivec4 - 4 int vector (ivec4.x, ivec4.y, ivec4.z, ivec4.w)</span></pre><p id="e02d" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">关于GLSL数据类型的全面而简明的指南可以在这里找到。</p><p id="567d" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">这意味着在我们的例子中，我们有6个整数值(我使用整数而不是双精度浮点数来表示价格，以保持精确值)，我们不能使用类似于<code class="fe no np nq mp b">ivec6</code>的东西，因为它不存在。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">我们的“Hello World”示例绘制了三根蜡烛</p></figure><p id="a8da" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">源代码(在Java中使用JOGL，但在C++中类似)创建了一个包含所有信息和三个vbo(顶点缓冲对象)的数组。</p><p id="4272" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">这个数组将被用来为每个缓冲区提供数据。我们需要处理的信息是<code class="fe no np nq mp b">stride</code>和<code class="fe no np nq mp b">offset </code>,这样OpenGL顶点着色器可以稍后定位数据。使用的具体<code class="fe no np nq mp b">glVertexAttribPointers</code>有:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">我们的“Hello World”示例定义了顶点属性，包括每个数据的步幅和偏移</p></figure><p id="019e" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">注意我们是如何使用<code class="fe no np nq mp b">glVertexAttribIPointer</code>而不是<code class="fe no np nq mp b">glVertexAttribPointer</code>的，因为我们处理的是整数数据。出于某种原因，我没有能够传递负整数，即使使用了<code class="fe no np nq mp b">GL_INT</code>而不是<code class="fe no np nq mp b">GL_UNSIGNED_INT</code>。</p><p id="449a" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">Vertex如何工作的一个很好的定义可以在这里<a class="ae ku" href="https://www.khronos.org/opengl/wiki/Vertex_Specification" rel="noopener ugc nofollow" target="_blank">找到</a>，它对我理解相关概念很有用。</p><h1 id="62a1" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated">顶点和几何体着色器</h1><p id="b33f" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">顶点着色器现在可以拾取全部数据:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">顶点着色器代码</p></figure><p id="8348" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">对于输入数据，位置布局属性定义了我们正在收集的具体属性，数字必须与<code class="fe no np nq mp b">glVertexAttribIPointer</code>中使用的数字相匹配。该信息是使用变量<code class="fe no np nq mp b">gs_ohlc</code>、<code class="fe no np nq mp b">gs_volume</code>和<code class="fe no np nq mp b">gs_timestamp</code>从几何着色器收集的。请注意顶点着色器中的输出变量名必须与几何着色器中的输入变量名相匹配。还要注意我们没有使用<code class="fe no np nq mp b">gl_Position</code>,因为我们还没有处理任何位置，只是高级抽象数据。没有必要，您仍然可以将任意数据从顶点传递到几何着色器。</p><p id="0ead" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">几何着色器收集高级数据并构建图元。它甚至根据蜡烛线是看涨还是看跌来给它们上色:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">几何着色器代码</p></figure><p id="8ba8" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">我们基于OHLC和时间戳数据构建原语(在本例中为line_strips)。这个例子很粗糙，缺少绘制整个图表所需的所有额外细节。但是它说明了如何将抽象数据移入GPU来实现图形原语。</p><h1 id="8891" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated">摘要</h1><p id="de0f" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">在本文中，我回顾了一些在OpenGL教程或文档中不常讨论的概念；不是因为它们没有被记录，而是因为它们不属于传递浮动顶点信息来执行3D渲染的最常见用例。</p><p id="b180" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">虽然代码并不完整，但对于那些已经在OpenGL中运行了第一个教程并希望更好地理解如何将数据移动到着色器的人来说，它是有用的。它也缺少绘制整个图表所需的其他方面，但它代表了令我感到麻烦的方面和OpenGL语法。</p><p id="747c" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">我仍在研究整个数据是否可以作为6个元素的数组传递，以包括可能的其他情况，我们可能希望将更大的数据块移动到GPU。我还需要涵盖的东西，如滚动，缩放和缩放。GLSL被证明是一个深思熟虑的从零开始学习的迷人话题。如前所述，我仍然有一些简单的问题，比如将负整数传入顶点着色器。这是一个明显的迹象，表明GLSL不像其他技术那样直观。事实上，大多数学习材料都集中在3D上，而我使用的是Java JOGL(大多数材料使用C++)，这也不利于这个过程。</p><p id="a957" class="pw-post-body-paragraph ln lo it lp b lq mj ju ls lt mk jx lv lw ml ly lz ma mm mc md me mn mg mh mi im bi translated">GPU的能力是惊人的，我也有动力在未来学习如何通过OpenCL或CUDA将这种能力用于一般计算。对于数据工程、回溯测试软件和ML等活动来说，这是一个非常好的选择。</p></div></div>    
</body>
</html>