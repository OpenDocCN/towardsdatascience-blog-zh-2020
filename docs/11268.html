<html>
<head>
<title>Why developers are falling in love with functional programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么开发人员会爱上函数式编程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/why-developers-are-falling-in-love-with-functional-programming-13514df4048e?source=collection_archive---------0-----------------------#2020-08-05">https://towardsdatascience.com/why-developers-are-falling-in-love-with-functional-programming-13514df4048e?source=collection_archive---------0-----------------------#2020-08-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4921" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从 Python 到 Haskell，这种趋势不会很快消失</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7bdf8047dfbece89829d39ac05583157.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d13Cp7wVtUTXIqLQwyhpqQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">功能代码目前正在兴起。布鲁克·卡吉尔在<a class="ae ky" href="https://unsplash.com/collections/10472559/dc%2Frwa?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="22bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated"><span class="l lw mf bm di mg"> <img alt="F" class="ks mh mi mj mk ml fc n ih dh bf" src="../Images/6c6b353ec68b1a29419be8a008cc3f16.png" width="79" height="79" loading="lazy" data-original-src="https://miro.medium.com/v2/resize:fit:158/1*RJ27zqjDXvRTjrb2nulZQg.jpeg"/> <span class="l lw lx ly bm lz ma mb mc md di me"> F </span> </span>函数式编程已经存在了<a class="ae ky" href="https://www.cs.kent.ac.uk/people/staff/dat/tfp12/tfp12.pdf" rel="noopener ugc nofollow" target="_blank">过去 60 年</a>，但迄今为止它一直是一个小众现象。尽管像谷歌这样的游戏规则改变者依赖于它的关键概念，但今天的普通程序员对此知之甚少甚至一无所知。</p><p id="e85e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种情况即将改变。不仅仅是像 Java 或 Python 这样的语言采用了越来越多来自函数式编程的概念。像 Haskell 这样的新语言正在走向完全函数化。</p><p id="6049" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单来说，函数式编程就是为不可变变量构建函数。相比之下，面向对象编程是关于拥有一组相对固定的函数，你主要是修改或添加新的变量。</p><p id="dada" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于其本质，函数式编程非常适合按需任务，如<a class="ae ky" href="https://www.haskell.org/communities/05-2018/html/report.html" rel="noopener ugc nofollow" target="_blank">数据分析</a>和<a class="ae ky" rel="noopener" target="_blank" href="/functional-programming-for-deep-learning-bc7b80e347e9">机器学习</a>。这并不意味着你应该告别面向对象编程，转而采用完全函数式编程。然而，了解基本原则是很有用的，这样你就可以在适当的时候利用它们。</p><div class="mm mn gp gr mo mp"><a href="https://medium.com/@elizarov/functional-programing-is-on-the-rise-ebd5c705eaef" rel="noopener follow" target="_blank"><div class="mq ab fo"><div class="mr ab ms cl cj mt"><h2 class="bd iu gy z fp mu fr fs mv fu fw is bi translated">函数式编程正在兴起</h2><div class="mw l"><h3 class="bd b gy z fp mu fr fs mv fu fw dk translated">编程语言有一种更加函数化的趋势。这意味着什么，我们在这条路上处于什么位置？</h3></div><div class="mx l"><p class="bd b dl z fp mu fr fs mv fu fw dk translated">medium.com</p></div></div><div class="my l"><div class="mz l na nb nc my nd ks mp"/></div></div></a></div><h1 id="502c" class="ne nf it bd ng nh ni nj nk nl nm nn no jz np ka nq kc nr kd ns kf nt kg nu nv bi translated">这都是为了消除副作用</h1><p id="1609" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">要理解函数式编程，首先需要理解函数。这听起来可能很无聊，但归根结底，这很有见地。所以继续读下去。</p><p id="3ea5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">天真地说，函数是一种将一些输入转换成一些输出的东西。只不过事情并不总是那么简单。考虑 Python 中的这个函数:</p><pre class="kj kk kl km gt ob oc od oe aw of bi"><span id="fc4f" class="og nf it oc b gy oh oi l oj ok">def square(x):<br/>    return x*x</span></pre><p id="318d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个函数很简单；它接受一个变量<code class="fe ol om on oc b">x</code>，大概是一个<code class="fe ol om on oc b">int</code>，或者一个<code class="fe ol om on oc b">float</code>或者<code class="fe ol om on oc b">double</code>，并计算出它的平方。</p><p id="c963" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在考虑这个函数:</p><pre class="kj kk kl km gt ob oc od oe aw of bi"><span id="6534" class="og nf it oc b gy oh oi l oj ok">global_list = []</span><span id="e64e" class="og nf it oc b gy oo oi l oj ok">def append_to_list(x):<br/>    global_list.append(x)</span></pre><p id="3e64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">乍一看，这个函数似乎接受了一个变量<code class="fe ol om on oc b">x</code>，无论是哪种类型，都不返回任何值，因为没有<code class="fe ol om on oc b">return</code>语句。但是等等！</p><p id="867e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果事先没有定义<code class="fe ol om on oc b">global_list</code>,这个函数就不会工作，它的输出是同一个列表，尽管有所修改。尽管<code class="fe ol om on oc b">global_list</code>从未被声明为输入，但当我们使用该函数时，它会发生变化:</p><pre class="kj kk kl km gt ob oc od oe aw of bi"><span id="2bd6" class="og nf it oc b gy oh oi l oj ok">append_to_list(1)<br/>append_to_list(2)<br/>global_list</span></pre><p id="8352" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将返回<code class="fe ol om on oc b">[1,2]</code>，而不是一个空列表。这表明列表确实是函数的一个输入，尽管我们没有明确说明。这可能是个问题。</p><h2 id="62e2" class="og nf it bd ng op oq dn nk or os dp no li ot ou nq lm ov ow ns lq ox oy nu oz bi translated">对功能不诚实</h2><p id="3ded" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">这些隐性输入——或者在其他情况下称为输出——有一个官方名称:<em class="pa">副作用</em>。虽然我们只是使用了一个简单的例子，但是在更复杂的程序中，这些会导致真正的困难。</p><p id="6cd1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想想你将如何测试<code class="fe ol om on oc b">append_to_list</code>:你需要阅读整个定义，理解它在做什么，定义<code class="fe ol om on oc b">global_list</code>，并以这种方式测试它，而不是仅仅阅读第一行并用任何<code class="fe ol om on oc b">x</code>测试函数。当您处理具有数千行代码的程序时，本例中的简单内容会很快变得乏味。</p><p id="a607" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好消息是有一个简单的解决方法:诚实地对待函数的输入。这要好得多:</p><pre class="kj kk kl km gt ob oc od oe aw of bi"><span id="5dea" class="og nf it oc b gy oh oi l oj ok">newlist = []</span><span id="1228" class="og nf it oc b gy oo oi l oj ok">def append_to_list2(x, some_list):<br/>    some_list.append(x)</span><span id="3198" class="og nf it oc b gy oo oi l oj ok">append_to_list2(1,newlist)<br/>append_to_list2(2,newlist)<br/>newlist</span></pre><p id="2e7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们其实没怎么变。输出仍然是<code class="fe ol om on oc b">[1,2]</code>，其他都保持不变。</p><p id="feae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我们改变了一件事:代码现在没有副作用了。这是个好消息。</p><p id="b4fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你现在看函数声明的时候，你就知道到底发生了什么。因此，如果程序没有按预期运行，您可以很容易地单独测试每个函数，并指出哪个函数有问题。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/9c961300496e77bcd2e18f81dd497fc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y4YcKl8i0kdfPyB19pkSVQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">保持你的功能的纯净就是保持它们的可维护性。照片由<a class="ae ky" href="https://unsplash.com/@wocintechchat?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">克里斯蒂娜@ wocintechchat.com</a>在<a class="ae ky" href="https://unsplash.com/collections/10472559/dc%2Frwa?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h2 id="2f71" class="og nf it bd ng op oq dn nk or os dp no li ot ou nq lm ov ow ns lq ox oy nu oz bi translated">函数式编程就是编写纯函数</h2><p id="0780" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">一个明确声明了输入和输出的函数是没有副作用的。而一个没有副作用的函数就是纯函数。</p><p id="7dd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数式编程的一个非常简单的定义是:只用纯函数编写程序。纯函数从不修改变量，只创建新的变量作为输出。(在上面的例子中我作弊了一点:它遵循了函数式编程的思路，但仍然使用了全局列表。你可以找到<a class="ae ky" href="https://stackoverflow.com/questions/44036657/side-effects-in-python" rel="noopener ugc nofollow" target="_blank">更好的例子</a>，但这里讲的是基本原理。)</p><p id="c2c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，你可以从一个给定输入的纯函数中得到一定的输出。相反，不纯函数可能依赖于某个全局变量；因此，如果全局变量不同，相同的输入变量可能导致不同的输出。后者会使调试和维护代码变得更加困难。</p><p id="ca23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">发现副作用有一个简单的规则:因为每个函数都必须有某种输入和输出，所以没有任何输入或输出的函数声明一定是不纯的。如果您采用函数式编程，这些是您可能想要更改的第一个声明。</p><h1 id="8bc0" class="ne nf it bd ng nh ni nj nk nl nm nn no jz np ka nq kc nr kd ns kf nt kg nu nv bi translated">什么函数式编程不是(唯一的)</h1><h2 id="541d" class="og nf it bd ng op oq dn nk or os dp no li ot ou nq lm ov ow ns lq ox oy nu oz bi translated"><code class="fe ol om on oc b">Map</code>和<code class="fe ol om on oc b">reduce</code></h2><p id="fae1" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">循环不是函数式编程中的东西。考虑这些 Python 循环:</p><pre class="kj kk kl km gt ob oc od oe aw of bi"><span id="1337" class="og nf it oc b gy oh oi l oj ok">integers = [1,2,3,4,5,6]<br/>odd_ints = []<br/>squared_odds = []<br/>total = 0</span><span id="2d1e" class="og nf it oc b gy oo oi l oj ok">for i in integers:<br/>    if i%2 ==1<br/>        odd_ints.append(i)</span><span id="2922" class="og nf it oc b gy oo oi l oj ok">for i in odd_ints:<br/>    squared_odds.append(i*i)</span><span id="8811" class="og nf it oc b gy oo oi l oj ok">for i in squared_odds:<br/>    total += i</span></pre><p id="9762" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于您尝试进行的简单操作，这段代码相当长。它也不是函数式的，因为你在修改全局变量。</p><p id="4376" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，请考虑以下情况:</p><pre class="kj kk kl km gt ob oc od oe aw of bi"><span id="17b0" class="og nf it oc b gy oh oi l oj ok">from functools import reduce</span><span id="9f39" class="og nf it oc b gy oo oi l oj ok">integers = [1,2,3,4,5,6]<br/>odd_ints = filter(lambda n: n % 2 == 1, integers)<br/>squared_odds = map(lambda n: n * n, odd_ints)<br/>total = reduce(lambda acc, n: acc + n, squared_odds)</span></pre><p id="c443" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是全功能的。它更短。这样更快，因为你不需要遍历数组中的很多元素。一旦你理解了<code class="fe ol om on oc b">filter</code>、<code class="fe ol om on oc b">map</code>和<code class="fe ol om on oc b">reduce</code>是如何工作的，代码也就不难理解了。</p><p id="47ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那个<a class="ae ky" href="http://blog.jenkster.com/2015/12/which-programming-languages-are-functional.html#fnref:1" rel="noopener ugc nofollow" target="_blank">不代表</a>所有功能代码都用<code class="fe ol om on oc b">map</code>、<code class="fe ol om on oc b">reduce</code>之类的。这也不意味着你需要函数式编程来理解<code class="fe ol om on oc b">map</code>和<code class="fe ol om on oc b">reduce</code>。只是当你抽象循环时，这些函数会频繁出现。</p><h2 id="cf08" class="og nf it bd ng op oq dn nk or os dp no li ot ou nq lm ov ow ns lq ox oy nu oz bi translated">λ函数</h2><p id="62f3" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">当谈到函数式编程的历史时，许多人会从 lambda 函数的发明说起。尽管 lambdas 毫无疑问是函数式编程的基石，但它们不是根本原因。</p><p id="5da2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Lambda 函数是可以用来使程序功能化的工具。但是你也可以在面向对象编程中使用 lambdas。</p><h2 id="0d35" class="og nf it bd ng op oq dn nk or os dp no li ot ou nq lm ov ow ns lq ox oy nu oz bi translated">静态打字</h2><p id="2ae7" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">上面的例子不是静态类型的。然而，它是实用的。</p><p id="fb94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管静态类型给你的代码增加了一层额外的安全性，但它并不一定是实用的。不过，这也是一个不错的补充。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/da01dc13331584dfcae4387f7bbc512c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TmMx57r6bip396X7ksU3Jw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">函数式编程在某些语言中比在其他语言中更容易。照片由<a class="ae ky" href="https://unsplash.com/@wocintechchat?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">克里斯蒂娜@ wocintechchat.com</a>在<a class="ae ky" href="https://unsplash.com/collections/10472559/dc%2Frwa?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="e5cd" class="ne nf it bd ng nh ni nj nk nl nm nn no jz np ka nq kc nr kd ns kf nt kg nu nv bi translated">一些语言变得比其他语言更加实用</h1><h2 id="36c8" class="og nf it bd ng op oq dn nk or os dp no li ot ou nq lm ov ow ns lq ox oy nu oz bi translated">Perl 语言</h2><p id="b2a1" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">Perl 对副作用采取了与大多数编程语言非常不同的方法。它包括一个神奇的论点，<code class="fe ol om on oc b">$_</code>，这使得副作用成为其核心特征之一。Perl 确实有它的优点，但是我不会用它来尝试函数式编程。</p><h2 id="eebb" class="og nf it bd ng op oq dn nk or os dp no li ot ou nq lm ov ow ns lq ox oy nu oz bi translated">Java 语言(一种计算机语言，尤用于创建网站)</h2><p id="6c5d" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">祝你用 Java 写函数代码好运。不仅你的程序有一半是由关键字组成的；大多数其他 Java 开发人员也会认为你的程序是一种耻辱。</p><p id="3e42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这并不是说 Java 不好。但是它不是为那些最好用函数式编程解决的问题而设计的，比如数据库管理或机器学习应用程序。</p><h2 id="30b0" class="og nf it bd ng op oq dn nk or os dp no li ot ou nq lm ov ow ns lq ox oy nu oz bi translated">斯卡拉</h2><p id="0248" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">这是一个有趣的问题:Scala 的目标是统一面向对象和函数式编程。如果你发现这种奇怪，你并不孤单:虽然函数式编程的目标是完全消除副作用，面向对象编程试图将它们保留在对象内部。</p><p id="8d91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，许多开发人员将 Scala 视为一种帮助他们从面向对象过渡到函数式编程的语言。这可能会使它们在未来几年更容易充分发挥作用。</p><div class="mm mn gp gr mo mp"><a href="https://medium.com/madhash/what-exactly-is-functional-programming-ea02c86753fd" rel="noopener follow" target="_blank"><div class="mq ab fo"><div class="mr ab ms cl cj mt"><h2 class="bd iu gy z fp mu fr fs mv fu fw is bi translated">到底什么是函数式编程？</h2><div class="mw l"><h3 class="bd b gy z fp mu fr fs mv fu fw dk translated">解密一个看似复杂的概念</h3></div><div class="mx l"><p class="bd b dl z fp mu fr fs mv fu fw dk translated">medium.com</p></div></div><div class="my l"><div class="pd l na nb nc my nd ks mp"/></div></div></a></div><h2 id="f115" class="og nf it bd ng op oq dn nk or os dp no li ot ou nq lm ov ow ns lq ox oy nu oz bi translated">计算机编程语言</h2><p id="43a3" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">Python 积极鼓励函数式编程。您可以从以下事实中看出这一点:默认情况下，每个函数至少有一个输入<code class="fe ol om on oc b">self</code>。这很像 Python 的<a class="ae ky" href="https://www.python.org/dev/peps/pep-0020/" rel="noopener ugc nofollow" target="_blank">禅:显式比隐式好！</a></p><h2 id="2736" class="og nf it bd ng op oq dn nk or os dp no li ot ou nq lm ov ow ns lq ox oy nu oz bi translated">Clojure</h2><p id="1de1" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">据其创建者称，Clojure 大约有 80%的功能。默认情况下，所有值都是不可变的，就像在函数式编程中需要它们一样。但是，您可以通过在这些不可变值周围使用可变值包装器来解决这个问题。当你打开这样的包装，你得到的东西又是不可改变的。</p><h2 id="acde" class="og nf it bd ng op oq dn nk or os dp no li ot ou nq lm ov ow ns lq ox oy nu oz bi translated">哈斯克尔</h2><p id="f5fd" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">这是为数不多的纯函数式静态类型语言之一。虽然这看起来像是开发过程中的时间消耗器，但是当你调试程序的时候，这是非常值得的。不像其他语言那么容易学，但是绝对值得投入！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/c8fb46523beb841ba53f8bc8ab33d9d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VBP29x3rYenflFKGWC7bFA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这还只是大数据时代的开始。由<a class="ae ky" href="https://unsplash.com/@austindistel?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">奥斯汀·迪斯特尔</a>在<a class="ae ky" href="https://unsplash.com/collections/9967779/ielts?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="9e6c" class="ne nf it bd ng nh ni nj nk nl nm nn no jz np ka nq kc nr kd ns kf nt kg nu nv bi translated">大数据来了。它带来了一个朋友:函数式编程。</h1><p id="cd36" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">与面向对象编程相比，函数式编程仍然是一种小众现象。然而，如果在<a class="ae ky" href="https://docs.python.org/3/howto/functional.html" rel="noopener ugc nofollow" target="_blank"> Python </a>和其他语言中包含函数式编程原则有任何意义的话，那么函数式编程似乎正在获得牵引力。</p><p id="b35c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这很有道理:函数式编程非常适合大型数据库、并行编程和机器学习。所有这些都在过去十年里蓬勃发展。</p><p id="635a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然面向对象代码有无数的优点，但是函数式代码的优点也不应该被忽视。作为一名开发者，学习一些基本原则通常足以提升你的水平，并为未来做好准备。</p><p id="5ff0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="pa">感谢阅读！如果您想知道如何在 Python 代码中实现更多的函数式编程元素，请继续关注。我将在下一篇文章中介绍这一点。</em></p></div></div>    
</body>
</html>