<html>
<head>
<title>The Way We Learn Convolution</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我们学习卷积的方式</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-way-we-learn-convolution-7c2ecdeddac?source=collection_archive---------26-----------------------#2020-09-17">https://towardsdatascience.com/the-way-we-learn-convolution-7c2ecdeddac?source=collection_archive---------26-----------------------#2020-09-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="876d" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">一篇关于如何理解卷积的短文</h2><div class=""/><div class=""><h2 id="7272" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">卷积是每个通信工程专业的学生首先学习的概念之一。它对于信号和系统的研究是如此的基础，然而，它是以一个方程的形式给出的，其解释集中于如何卷积而不是为什么卷积。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/f7b1970d869ab32e1edc5da40573e843.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b6zBIUNaBC0x3DIte1j5mw.jpeg"/></div></div></figure><p id="4b7e" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们教和学卷积的方式是错综复杂的:)</p><p id="4959" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">还记得我们是怎么学的吗？如果 LTI 系统的输入中的 x[n]具有脉冲响应 h[n]，则输出 y[n]由卷积运算给出:</p><p id="fd72" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf jd"> y[n] = ∑ₖ h[k] x[n-k] </strong></p><p id="e903" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">哎呀，很好的等式，但是它意味着什么，我们问。我们得到了视觉翻转，滑动和乘法积累！</p><p id="e7f9" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">假设我给你两个序列:</p><pre class="ks kt ku kv gt lz ma mb mc aw md bi"><span id="f1b9" class="me mf it ma b gy mg mh l mi mj">x1 = [1, 2, 1, 0, 0, 2, 1, 2]<br/>x2 = [3, 0, 0, 3, 0, 0, 1]</span></pre><p id="9a96" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我问你卷积输出。你会怎么做？尤其是如果你没有 Matlab 或者 Octave 或者 Python。你会评价上面两个序列的<strong class="lf jd"> y[n] = ∑ₖ h[k] x[n-k] </strong>方程吗？</p><p id="2c03" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">相反，只要启动你的常规计算器。将两个数字相乘(通过从右到左的顺序得到):<strong class="lf jd"> 21200121 </strong> x <strong class="lf jd"> 1003003 </strong>。你得到的结果(<strong class="lf jd"> 21263784963363 </strong>)就是卷积输出！没错，卷积来自普通的乘法运算。不相信我？试试吧！</p><p id="493e" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">为了交叉检查答案是否正确，下面是使用 Python 的 scipy 的卷积输出。信号:</p><pre class="ks kt ku kv gt lz ma mb mc aw md bi"><span id="a52a" class="me mf it ma b gy mg mh l mi mj">from scipy import signal<br/>yc = signal.convolve(x1, x2)<br/>print(yc)</span><span id="f904" class="me mf it ma b gy mk mh l mi mj">[3 6 3 3 6 9 4 8 7 3 6 2 1 2]</span></pre><p id="d7e0" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我再举一个例子:x1 =[2，1，1，0，0，0，2，2]，x2 =[1，0，0，0，2，0，2]。乘以<strong class="lf jd">22000112</strong>x<strong class="lf jd">22020001</strong>=<strong class="lf jd">48442488240112</strong>，从右向左读取，即为卷积输出。</p><p id="b99a" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">当然，对于那些理解卷积到底是什么的人来说，这并不奇怪。毕竟，我们对于 1 序列的乘法模式已经暗示了这一点:<br/><strong class="lf jd">11</strong>x<strong class="lf jd">11</strong>=<strong class="lf jd">121<br/>111 x 111 = 12321</strong><br/><strong class="lf jd">1111 x 1111 = 1234321</strong><br/>等等。认出模式了吗？两个方波的卷积产生一个三角形。</p><p id="cb0a" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">对于幼徒来说，上面的技巧并不适用于所有的场景。你可以看到，即使是只有数字 1 的数字，这种模式在长度为 10 时也会中断:<strong class="lf jd">1111111111111</strong>x<strong class="lf jd">1111111111</strong>=<strong class="lf jd">123456789<em class="ml">00</em>987654321</strong>。不再是三角形了——注意中间的两个零。</p><p id="b5b8" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">那么，为什么这个乘法技巧行得通，为什么不是对所有序列都行得通呢？它之所以有效，是因为卷积运算就像两个序列相乘一样基本。我们如何将两个序列相乘？当然是把它们变成多项式的系数！假设我们有两个序列[a0，a1，a2]和[b0，b1，b2]。创建多项式<br/><em class="ml">(A0+a1x+a2x)<br/>(B0+b1x+b2x)</em></p><p id="4125" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">乘法和分组项:<br/><em class="ml">(a0b 0)+(a0b 1+a1b 0)* x+(a0b 2+a1 B1+a2 b 0)* x+(a1 B2+a2 B1)* x+(a2b2)*x⁴</em></p><p id="9a68" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">现在，您可以将卷积输出作为结果多项式的系数读出。</p><p id="877c" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">乘法口诀什么时候不起作用？当输出多项式的任何系数大于 10 时。因为卷积不像十进制表示那样“携带”数字。</p><p id="76c5" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">另一个检查:长度为 m 的序列和长度为 n 的序列的卷积，输出长度为<strong class="lf jd"> m+n-1 </strong>。长度为 m 的序列是 m-1 次多项式，因此高阶项将是 x⁽ⁿ⁻ ⁾ * x⁽ᵐ⁻ ⁾= x⁽ⁿ⁺ᵐ⁻ ⁾.如果一个多项式有次数(m+n-2)，它有 m + n — 1 个系数。</p><p id="ade8" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这给了我们直觉。毕竟，我们在学校学的是代数，而在工程课程中，我们只在信号与系统 101 中学习卷积。为什么不在我们已经学过的和熟悉的基础上发展呢？</p><p id="550e" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这并不是说翻转和相乘没有用。当你看 2D 卷积时，这种解释是非常有用的。您可以将它想象为翻转(水平和垂直)您的 2D 核，将其重叠在您的 2D 数据的第一个样本(左上角)上，然后简单地向下拖动核，直到您到达第一列的最后一行，重置为第二列的顶行，向下拖动。冲洗并重复，直到到达最后一列最后一行的样品。下面是一个快速而复杂的 Python 代码，它将一个 8×8 的输入与一个 4×4 的内核进行卷积:</p><pre class="ks kt ku kv gt lz ma mb mc aw md bi"><span id="43aa" class="me mf it ma b gy mg mh l mi mj">import numpy as np<br/>import matplotlib.pyplot as plt<br/>from scipy import signal<br/><br/>hker = np.random.randint(low=0, high=4, size=(4,4))<br/>hkerf = hker[::-1,:]<br/>hkerf = hkerf[:,::-1]<br/>x2d = np.random.randint(low=0, high=4, size=(8,8))<br/>x2dpad = np.zeros((14,14))<br/>x2dpad[3:3+8,3:3+8]=x2d<br/>y2d = np.zeros((11,11))<br/><br/>for row in range(11):<br/>  for col in range(11):<br/>    y2d[row,col]=np.dot(hkerf.flatten(),x2dpad[row:row+4,col:col+4].flatten())<br/><br/>y2dc = signal.convolve2d(hker,x2d)<br/><br/>plt.stem(y2d.flatten(), use_line_collection=True)<br/>plt.plot(y2dc.flatten(),'ro')</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="ab gu cl mm"><img src="../Images/1d161dde6d3a2976fc08172c0edaccc2.png" data-original-src="https://miro.medium.com/v2/format:webp/1*FslN_U5Rqx_6_hYrRzKtGA.png"/></div></figure><p id="e8dd" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">方程<strong class="lf jd"> y[n] = ∑ₖ h[k]x[n-k] </strong>的建立方式也是理解数字滤波器和利用离散傅里叶变换进行计算的重要基础。然而，虽然我们必须接受严格的训练，但我们不能在这个过程中失去直觉。</p><p id="e1f5" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">对了，我本来可以一段话把这个帖子写完，说卷积和多项式乘法一样。但是这有什么意思呢？！</p></div></div>    
</body>
</html>