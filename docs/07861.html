<html>
<head>
<title>A Data Engineering Perspective on Go vs. Python (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go 与 Python 的数据工程观点(第 1 部分)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-data-engineering-perspective-on-go-vs-python-part-1-5dfb8bc08e7?source=collection_archive---------22-----------------------#2020-06-11">https://towardsdatascience.com/a-data-engineering-perspective-on-go-vs-python-part-1-5dfb8bc08e7?source=collection_archive---------22-----------------------#2020-06-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><h1 id="765d" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">介绍</h1><blockquote class="ko kp kq"><p id="e23c" class="kr ks kt ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="it">探索 golang——我们能放弃 Python 吗？我们(比如“经常处理大量数据的人”)最终找到 go 的用例了吗？第 1 部分探讨了 Python 和 go 之间的高级差异，并给出了这两种语言的具体示例，旨在基于 Apache Beam 和 Google Dataflow 作为真实示例来回答这个问题。</em></p></blockquote><p id="575b" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated"><a class="ae lt" href="https://beam.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache Beam </a>是我以前在这个博客上使用过几次的东西:它是一个针对批处理和流用例的统一编程模型，可以处理<a class="ae lt" href="https://en.wikipedia.org/wiki/Embarrassingly_parallel" rel="noopener ugc nofollow" target="_blank">令人愉快的并行工作负载</a>，允许许多自定义 I/O 和其他连接器，并运行在多种执行平台上，最著名的是 Flink、Spark 和 Google Cloud 的数据流。</p><p id="b199" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">您可以使用它来传输或批处理数据，以分析数据、运行 ETL、丰富数据——应有尽有。我其实几年前就用过<code class="fe lu lv lw lx b">Beam</code><a class="ae lt" href="https://chollinger.com/blog/2018/06/analyzing-reddits-top-posts-images-with-google-cloud-part-1/#introducing-data-flow" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="2f7c" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">现在，如果你去 Beam 的网站，你会发现这个奇妙的图形:</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi ly"><img src="../Images/4410ab75f48805245f0bff30f63dd550.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Dag5_h5osKPOm446.png"/></div></div><p class="mk ml gj gh gi mm mn bd b be z dk translated"><a class="ae lt" href="https://beam.apache.org/" rel="noopener ugc nofollow" target="_blank">https://beam.apache.org/</a></p></figure><p id="39b3" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">它告诉你 Beam 要么用<code class="fe lu lv lw lx b">Java</code>要么用<code class="fe lu lv lw lx b">Python</code>来写，其他的都属于“其他语言”。</p><p id="5ed1" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">然而，有一个“实验性的”(<a class="ae lt" href="https://github.com/apache/beam/tree/master/sdks/go" rel="noopener ugc nofollow" target="_blank"> GitHub </a>)承诺我们使用<code class="fe lu lv lw lx b">go</code>而不是<code class="fe lu lv lw lx b">Python</code>——这让我很兴奋。</p><p id="3e84" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">下一节将尝试对<code class="fe lu lv lw lx b">go</code>做一个“简短的”(~3，000 字)介绍，并根据不同的处理数据工程特定用例以及在使用多线程应用时，将其与<code class="fe lu lv lw lx b">Python</code>进行比较。请注意，这绝不是完全的比较。</p><blockquote class="ko kp kq"><p id="4447" class="kr ks kt ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="it">这是第 1 部分，共 2 部分，重点介绍两种语言和 Apache Beam SDK 的当前状态。在第 2 部分(即将推出)，我们将探索如何使用</em> <code class="fe lu lv lw lx b"><em class="it">Beam</em></code> <em class="it"> </em> <code class="fe lu lv lw lx b"><em class="it">go</em></code> <em class="it"> SDK，我们将在 GCP 面临哪些限制，以及数据工程师的</em> <code class="fe lu lv lw lx b"><em class="it">go</em></code> <em class="it">之旅将走向何方。</em></p></blockquote><p id="faa7" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated"><em class="kt">所有示例代码在</em> <a class="ae lt" href="https://github.com/otter-in-a-suit/chollinger-blog/tree/master/content/posts/2020/06/a-data-engineering-perspective-on-go-vs-python-part-1/code" rel="noopener ugc nofollow" target="_blank"> <em class="kt"> GitHub </em> </a> <em class="kt">上都有。</em></p><p id="35cc" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated"><em class="kt">最初发表于</em><a class="ae lt" href="https://chollinger.com/blog/2020/06/a-data-engineering-perspective-on-go-vs.-python-part-1" rel="noopener ugc nofollow" target="_blank"><em class="kt">https://chollinger.com</em></a></p><h1 id="fa90" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">Go vs. Python</h1><p id="1aa7" class="pw-post-body-paragraph kr ks it ku b kv mo kx ky kz mp lb lc lq mq lf lg lr mr lj lk ls ms ln lo lp im bi translated">如果你不熟悉，让我引用维基百科:</p><blockquote class="ko kp kq"><p id="d5dd" class="kr ks kt ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Go 是一种静态类型的编译编程语言，由 Robert Griesemer、Rob Pike 和 Ken Thompson 在 Google 设计。Go 在语法上类似于 C，但是具有内存安全、垃圾收集、结构化类型和 CSP 风格的并发性。</p><p id="1806" class="kr ks kt ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae lt" href="https://en.wikipedia.org/wiki/Go_(programming_language)" rel="noopener ugc nofollow" target="_blank"><em class="it">https://en . Wikipedia . org/wiki/Go _(编程 _ 语言)</em> </a></p></blockquote><p id="a70d" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated"><code class="fe lu lv lw lx b">Go</code>有许多概念，应该会让您对处理数据的并行执行框架感到兴奋。在接下来的几节中，我们将探索一些精选的概念和示例，并以一个更长、更深入的并发示例结束。</p><h1 id="6501" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">速度</h1><p id="5039" class="pw-post-body-paragraph kr ks it ku b kv mo kx ky kz mp lb lc lq mq lf lg lr mr lj lk ls ms ln lo lp im bi translated"><code class="fe lu lv lw lx b">go</code>是一种编译语言，而不是解释语言，<a class="ae lt" href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/go-python3.html" rel="noopener ugc nofollow" target="_blank">应该比 Python </a>快。它还倾向于非常快速地编译东西，将编译好的代码发送给最终用户要比试图用 Python 做同样的事情容易几个数量级。</p><p id="37bb" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">你可以在下面找到一些实际操作的例子。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/67b58cf1d8e55511f0704c21229bf85f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/0*Ec_vgwQk6MNMJAOA.png"/></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">使用 matplotlib 生成；CC BY-SA 3.0</p></figure><h1 id="7ddb" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">静态打字</h1><p id="652a" class="pw-post-body-paragraph kr ks it ku b kv mo kx ky kz mp lb lc lq mq lf lg lr mr lj lk ls ms ln lo lp im bi translated">与<code class="fe lu lv lw lx b">Python</code>的动态类型相反，静态避免了在正确的时刻使用正确的数据类型带来的许多类型问题。</p><blockquote class="ko kp kq"><p id="7ba3" class="kr ks kt ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我并不想对静态和动态类型以及 Python 的复杂性进行一般性的比较，而只是从我的经验来看，特别是在数据空间中，每天都是如此。</p></blockquote><p id="b589" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">在数据驱动的项目中，您会经常发现自己在处理非常严格的数据类型定义，这通常是某个领域的一个工件(理所当然如此),在这个领域中，所有公司数据都不可避免地存储在大型 RDMBs 中，例如 Oracle，强制执行严格的类型。</p><p id="4133" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">基于 Python 的框架，比如<code class="fe lu lv lw lx b">pySpark</code>甚至<code class="fe lu lv lw lx b">pandas</code>，都自带了提供类型的抽象层。</p><p id="aa97" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">以这段代码为例，它是为<code class="fe lu lv lw lx b">pySpark</code>编写的，这是一个流行的数据处理框架，在 Python(以及其他语言)中可用，使用了 NYC Yellow Cab 数据[0]。</p><p id="77f1" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">首先，将一个 CSV 文件读入一个<code class="fe lu lv lw lx b">RDD</code>，一个“有弹性的分布式数据集”，并对数据集中的每一行应用一些转换 lambdas。</p><pre class="lz ma mb mc gt mu lx mv mw aw mx bi"><span id="4b6c" class="my jr it lx b gy mz na l nb nc"># Read data<br/>rdd = sc.textFile('data/yellow_tripdata_2019-01.csv')<br/># Parse the RDD<br/>rdd = rdd.map(lambda r: r.split(','))\<br/>         .map(lambda r: (r[10],r[13])) # Take 'fare_amount' and 'tip_amount'<br/>rdd = rdd.filter(lambda r: 'fare_amount' not in r) # filter header<br/>rdd.take(1)</span></pre><p id="91e0" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">这产生了:</p><pre class="lz ma mb mc gt mu lx mv mw aw mx bi"><span id="adc8" class="my jr it lx b gy mz na l nb nc">[('7', '1.65'), ('14', '1'), ('4.5', '0'), ('3.5', '0'), ('52', '0')]</span></pre><p id="c759" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">如果我们研究其中一个元组:</p><pre class="lz ma mb mc gt mu lx mv mw aw mx bi"><span id="ca13" class="my jr it lx b gy mz na l nb nc">type(rdd.take(1)[0][0])</span></pre><p id="abfe" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">我们将把<code class="fe lu lv lw lx b">str</code>视为数据类型。</p><p id="89f4" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">现在，如果我们要减少这个数来合计出租车费和小费金额:</p><pre class="lz ma mb mc gt mu lx mv mw aw mx bi"><span id="0233" class="my jr it lx b gy mz na l nb nc">def sum_fares(fare, tip):<br/>    return fare + tip<br/><br/>rdd.map(lambda r: sum_fares(*r)).take(5)</span></pre><p id="5d00" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">正如上面输出中的引号所示，结果是一个串联的<code class="fe lu lv lw lx b">strings</code>列表。</p><pre class="lz ma mb mc gt mu lx mv mw aw mx bi"><span id="ec95" class="my jr it lx b gy mz na l nb nc">['71.65', '141', '4.50', '3.50', '520']</span></pre><p id="231f" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">而不是数学上正确的:</p><pre class="lz ma mb mc gt mu lx mv mw aw mx bi"><span id="0aca" class="my jr it lx b gy mz na l nb nc">rdd.map(lambda r: sum_fares(*[float(x) for x in r])).take(5)<br/># [8.65, 15.0, 4.5, 3.5, 52.0]</span></pre><p id="3d32" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">新版本的 Python 支持<code class="fe lu lv lw lx b">type hints</code>，Python 解释器跟踪变量类型。然而，正如上面的例子所强调的，我个人发现很难维护一个一致的、可读的、可维护的代码库，尤其是在复杂的应用程序上。</p><p id="2b81" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">另一方面，<code class="fe lu lv lw lx b">go</code>是静态类型的。</p><pre class="lz ma mb mc gt mu lx mv mw aw mx bi"><span id="40e5" class="my jr it lx b gy mz na l nb nc">package main<br/><br/>import (<br/>	"fmt"<br/>	"reflect"<br/>)<br/><br/>func main() {<br/>    // Implicit<br/>	str := "A String"<br/>	fmt.Printf("%s is %s\n", str, reflect.TypeOf(str))<br/><br/>    // Explicit<br/>	var x float64 = 3.14<br/>	fmt.Printf("%v is %s\n", x, reflect.TypeOf(x))<br/>}</span></pre><p id="0515" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">将产生:</p><pre class="lz ma mb mc gt mu lx mv mw aw mx bi"><span id="c11b" class="my jr it lx b gy mz na l nb nc">go run test.go<br/>A String is string<br/>3.14 is float64</span></pre><p id="f0f5" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">鉴于此:</p><pre class="lz ma mb mc gt mu lx mv mw aw mx bi"><span id="045b" class="my jr it lx b gy mz na l nb nc">str = x</span></pre><p id="2a68" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">不会编译:</p><pre class="lz ma mb mc gt mu lx mv mw aw mx bi"><span id="61e1" class="my jr it lx b gy mz na l nb nc">go run testvar.go<br/># command-line-arguments<br/>./test.go:15:6: cannot use x (type float64) as type string in assignment</span></pre><p id="6d4f" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">Go 不支持<code class="fe lu lv lw lx b">Generics</code>，但<code class="fe lu lv lw lx b">Python</code>也不支持。</p><blockquote class="ko kp kq"><p id="63a7" class="kr ks kt ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="it">我跳过了</em><code class="fe lu lv lw lx b"><em class="it">go</em></code><em class="it"/><code class="fe lu lv lw lx b"><em class="it">empty interface{}</em></code><em class="it">的概念，以支持任意值和处理未知类型；在需要弱类型抽象的情况下，可以使用这个概念</em></p></blockquote><p id="e6dc" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated"><em class="kt">【0】</em><code class="fe lu lv lw lx b"><em class="kt">Spark</em></code><em class="kt">的 SQL 接口将推断字符串类型，并允许对字符串进行数学运算，如果它们一致</em></p><h1 id="ee82" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">接口和结构</h1><p id="3e3b" class="pw-post-body-paragraph kr ks it ku b kv mo kx ky kz mp lb lc lq mq lf lg lr mr lj lk ls ms ln lo lp im bi translated"><code class="fe lu lv lw lx b">Python</code>确实有一个<code class="fe lu lv lw lx b">class</code>结构(我已经广泛使用过了)，而<code class="fe lu lv lw lx b">go</code>使用了<code class="fe lu lv lw lx b">structs</code>和<code class="fe lu lv lw lx b">interfaces</code>(这是一个可怕的简化)。<code class="fe lu lv lw lx b">go</code>没有继承，依赖于接口和组合。</p><p id="83f3" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">在数据世界中，拥有严格的类结构，例如抽象转换、统计模型或简单的旧数据结构，可能既是痛苦也是诅咒。</p><p id="365a" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated"><code class="fe lu lv lw lx b">Python</code>广泛使用了<code class="fe lu lv lw lx b">dicts</code>,它可以保存任意的键值对和嵌套结构，在语法上类似于<code class="fe lu lv lw lx b">JSON</code>,并且为数据的结构化抽象定义了<code class="fe lu lv lw lx b">class</code>。几乎每个数据框架都有自己的<code class="fe lu lv lw lx b">schema</code>类。从理论上讲，<code class="fe lu lv lw lx b">go</code>可以通过组合<code class="fe lu lv lw lx b">interfaces</code>(用于标准)、静态类型(确保在正确的时刻使用正确的数据类型)和<code class="fe lu lv lw lx b">structs</code>来定义结构和逻辑，从而避免这种情况。</p><p id="59c3" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">这里有一个非常有用的例子，它使用接口<code class="fe lu lv lw lx b">CoordinateData</code>和函数<code class="fe lu lv lw lx b">calculateDistance</code>，在世界上最差的 GIS 分析平台上计算两个坐标元组之间的距离:)</p><pre class="lz ma mb mc gt mu lx mv mw aw mx bi"><span id="24c1" class="my jr it lx b gy mz na l nb nc">package main<br/><br/>import (<br/>	"fmt"<br/>	"math"<br/>)<br/><br/>// A Resource we're trying to access<br/>type CoordinateData interface {<br/>	calculateDistance(latTo, lonTo float64) float64<br/>}</span></pre><p id="ea3b" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">然后，我们实现地理空间数据和哈弗辛函数(以近似地球上的距离):</p><pre class="lz ma mb mc gt mu lx mv mw aw mx bi"><span id="31b2" class="my jr it lx b gy mz na l nb nc">type GeospatialData struct {<br/>	lat, lon float64<br/>}<br/><br/>const earthRadius = float64(6371)<br/>func (d GeospatialData) calculateDistance(latTo, lonTo float64) float64 {<br/>	// Haversine distance<br/>	var deltaLat = (latTo - d.lat) * (math.Pi / 180)<br/>	var deltaLon = (lonTo - d.lon) * (math.Pi / 180)<br/>	<br/>	var a = math.Sin(deltaLat / 2) * math.Sin(deltaLat / 2) + <br/>		math.Cos(d.lat * (math.Pi / 180)) * math.Cos(latTo * (math.Pi / 180)) *<br/>		math.Sin(deltaLon / 2) * math.Sin(deltaLon / 2)<br/>	var c = 2 * math.Atan2(math.Sqrt(a),math.Sqrt(1-a))<br/>	<br/>	return earthRadius * c<br/>}</span></pre><p id="77a6" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">在一个简单的二维平面上也是如此:</p><pre class="lz ma mb mc gt mu lx mv mw aw mx bi"><span id="dca3" class="my jr it lx b gy mz na l nb nc">type CartesianPlaneData struct {<br/>	x, y float64<br/>}<br/><br/>func (d CartesianPlaneData) calculateDistance(xTo, yTo float64) float64 {<br/>	// Simple 2-dimensional Euclidean distance <br/>	dx := (xTo - d.x)<br/>	dy := (yTo - d.y)<br/>	return math.Sqrt( dx*dx + dy*dy )<br/>}</span></pre><p id="201e" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">在这种情况下，<code class="fe lu lv lw lx b">main()</code>函数只计算两种完全不同的距离:</p><pre class="lz ma mb mc gt mu lx mv mw aw mx bi"><span id="cd82" class="my jr it lx b gy mz na l nb nc">func main() {<br/>	atlanta := GeospatialData{33.753746, -84.386330}<br/>	distance := atlanta.calculateDistance(33.957409, -83.376801) // to Athens, GA<br/>	fmt.Printf("The Haversine distance between Atlanta, GA and Athens, GA is %v\n", distance)<br/><br/>	pointA := CartesianPlaneData{1, 1}<br/>	distanceA := pointA.calculateDistance(5, 5) <br/>	fmt.Printf("The Pythagorean distance from (1,1) to (5,5) is %v\n", distanceA)<br/>}</span></pre><p id="73e0" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">当然，这是一个非常简单的例子，简单地将结构强加到你的结构上。然而，与 Python 相比，我的选择有限:</p><pre class="lz ma mb mc gt mu lx mv mw aw mx bi"><span id="5a7c" class="my jr it lx b gy mz na l nb nc">class CoordinateData:<br/>    def calculateDistance(self, latTo, lonTo):<br/>        pass <br/><br/>class GeospatialData(CoordinateData):<br/>    def __init__(self, lat, lon):<br/>        self.lat = lat<br/>        self.long = lon<br/><br/>    def calculateDistance(self, latTo, lonTo):<br/>        # Haversine goes here :)<br/>        return 95.93196816811724<br/><br/>class CartesianPlaneData(CoordinateData):<br/>    def __init__(self, x, y):<br/>        self.x = y<br/>        self.x = y<br/><br/>    # Let's not implement calculateDistance()<br/><br/>if __name__ == "__main__":<br/>    atlanta = GeospatialData(33.753746, -84.386330)<br/>    distance = atlanta.calculateDistance(33.957409, -83.376801) # to Athens, GA<br/>    print('The Haversine distance between Atlanta, GA and Athens, GA is {}'.format(distance))<br/><br/>    pointA = CartesianPlaneData(1,1)<br/>    distanceA = pointA.calculateDistance(5, 5)<br/>    print('The Pythagorean distance from (1,1) to (5,5) is {}'.format(distanceA))<br/>    print('pointA is of type {}'.format(pointA.__class__.__bases__))</span></pre><p id="e33e" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">这是有效的 Python — <code class="fe lu lv lw lx b">CartesianPlaneData</code>是<code class="fe lu lv lw lx b">CoordinateData</code>的子类(<em class="kt">不是接口</em>—Python 使用 duck-typing)，因此，简单地使用没有返回类型的<code class="fe lu lv lw lx b">calculateDistance</code>方法(参见上面的静态与动态类型)，运行并返回:</p><pre class="lz ma mb mc gt mu lx mv mw aw mx bi"><span id="b2dc" class="my jr it lx b gy mz na l nb nc">python3 interface_example.py<br/>The Haversine distance between Atlanta, GA and Athens, GA is 95.93196816811724<br/>The Pythagorean distance from (1,1) to (5,5) is None<br/>pointA is of type (&lt;class '__main__.CoordinateData'&gt;,)</span></pre><p id="d234" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">Python 仍然允许接口抽象，你完全可以使用类来定义层次和逻辑，正如我在下面的<code class="fe lu lv lw lx b">PluginInterceptor</code>中所做的，来确定一个定制插件是否是一个已定义基类的一部分；然而，这并不是在运行时强制执行的，如果您不正确地实现它，可能会失败。</p><pre class="lz ma mb mc gt mu lx mv mw aw mx bi"><span id="cb67" class="my jr it lx b gy mz na l nb nc">class PluginInterceptor:<br/>    """Loads all allowed plugins, when they are a subclass of `BasePlugin` and have the constant `name` set (not `__name__`)<br/>    """<br/>    def __init__(self):<br/>        self.cls = BasePlugin<br/>        self.allowed_plugins = self.__load__allowed_plugins__()<br/>        <br/>    def __get_all_subclasses__(self, cls):<br/>        return set(cls.__subclasses__()).union(<br/>            [s for c in cls.__subclasses__() for s in self.__get_all_subclasses__(c)]) <br/>    <br/>    def __load__allowed_plugins__(self):<br/>        __allowed_plugins__ = {}<br/>        for cls in self.__get_all_subclasses__(self.cls):<br/>            if cls.name:<br/>                __allowed_plugins__[cls.name] = cls<br/>        return __allowed_plugins__</span></pre><p id="3dff" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated"><a class="ae lt" href="https://github.com/otter-in-a-suit/scarecrow/blob/master/plugin_base/interceptor.py#L5" rel="noopener ugc nofollow" target="_blank">https://github . com/otter-in-a-suit/稻草人/blob/master/plugin _ base/interceptor . py # L5</a></p><p id="e77f" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">您还可以在下面的 Mandelbrot 示例中找到一个结构示例。</p><h1 id="f794" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">两颗北极指极星</h1><p id="952c" class="pw-post-body-paragraph kr ks it ku b kv mo kx ky kz mp lb lc lq mq lf lg lr mr lj lk ls ms ln lo lp im bi translated"><code class="fe lu lv lw lx b">go</code>懂指针，不懂指针算术。<code class="fe lu lv lw lx b">go</code>中的指针用于按指针传递操作，与按值传递相反。我不会深入讨论这个问题，给你一个来自<code class="fe lu lv lw lx b">go</code>的例子，你可以参考<a class="ae lt" href="https://robertheaton.com/2014/02/09/pythons-pass-by-object-reference-as-explained-by-philip-k-dick/" rel="noopener ugc nofollow" target="_blank">这篇关于 Python 的精彩文章</a>。</p><pre class="lz ma mb mc gt mu lx mv mw aw mx bi"><span id="1483" class="my jr it lx b gy mz na l nb nc">package main<br/><br/>import "fmt"<br/><br/>func main() {<br/>	i, j := 42, 2701<br/><br/>	p := &amp;i         // point to i<br/>	fmt.Println(*p) // read i through the pointer<br/>	*p = 21         // set i through the pointer<br/>	fmt.Println(i)  // see the new value of i<br/><br/>	p = &amp;j         // point to j<br/>	*p = *p / 37   // divide j through the pointer<br/>	fmt.Println(j) // see the new value of j<br/>}</span></pre><p id="08e4" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">(来自<a class="ae lt" href="https://tour.golang.org/moretypes/1" rel="noopener ugc nofollow" target="_blank">https://tour.golang.org/moretypes/1</a></p><p id="930b" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">我对<code class="fe lu lv lw lx b">go</code>的简短总结是:作为一名开发人员，我能够控制我是喜欢标准的<code class="fe lu lv lw lx b">C</code>风格的行为——按值传递——还是一个指针，我仍然按值传递——但是在这种情况下，一个指向值的<em class="kt">指针作为函数参数。</em></p><h1 id="5c54" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">Mandelbrot 集的并发性</h1><p id="15e9" class="pw-post-body-paragraph kr ks it ku b kv mo kx ky kz mp lb lc lq mq lf lg lr mr lj lk ls ms ln lo lp im bi translated">简单、开箱即用、易于使用的并发是<code class="fe lu lv lw lx b">go</code>中最精彩的事情之一。从同步到并发总共需要两个字母- <code class="fe lu lv lw lx b">go</code>。</p><p id="0f1b" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">让我们使用一种“令人愉快的并行”算法，即<strong class="ku iu">曼德尔布罗集合</strong>。</p><blockquote class="ko kp kq"><p id="176d" class="kr ks kt ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="ku iu"> Mandelbrot 集合</strong>是函数<code class="fe lu lv lw lx b">f_c(z) = z² + c</code>从<code class="fe lu lv lw lx b">z = 0</code>开始迭代时不发散的复数<code class="fe lu lv lw lx b">c</code>的集合，即序列<code class="fe lu lv lw lx b">f_c(0, f_c(f_c(0))</code>等。，保持绝对值有界。</p><p id="671e" class="kr ks kt ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae lt" href="https://en.wikipedia.org/wiki/Mandelbrot_set" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Mandelbrot_set</a></p></blockquote><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi nd"><img src="../Images/bbcf72e550853c0a63cac2ba62cd1d7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*GMDBZ1MRtBUcaNih.png"/></div></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">Mandelbrot 算法的输出；CC BY-SA 3.0</p></figure><h1 id="fd51" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">计算机编程语言</h1><p id="3f88" class="pw-post-body-paragraph kr ks it ku b kv mo kx ky kz mp lb lc lq mq lf lg lr mr lj lk ls ms ln lo lp im bi translated">我们先来看 Python。</p><p id="41d3" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">Python 提供了多种方式来表达并发性——<code class="fe lu lv lw lx b">threading</code>、<code class="fe lu lv lw lx b">multiprocessing</code>、<code class="fe lu lv lw lx b">subprocesses</code>、<code class="fe lu lv lw lx b">concurrent.futures</code>等等——但是选择正确的方式<em class="kt">和</em>编写清晰的代码是一个挑战。请允许我引用文件:</p><blockquote class="ko kp kq"><p id="54d5" class="kr ks kt ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="it">本章描述的模块为代码的并发执行提供支持。工具的适当选择将取决于要执行的任务(CPU 受限与 IO 受限)和首选的开发风格(事件驱动的协作多任务与抢占式多任务)</em><a class="ae lt" href="https://docs.python.org/3/library/concurrency.html" rel="noopener ugc nofollow" target="_blank"><em class="it"/></a></p></blockquote><p id="b61f" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">我不会详细讨论什么情况下什么是正确的选择，全球 Python 解释器(GIL)如何影响它，或者一切是如何工作的，因为在网上可以很容易地找到数百篇关于这个主题的文章。然而，我想关注的是代码风格、易用性和性能。</p><h2 id="7ac2" class="my jr it bd js ne nf dn jw ng nh dp ka lq ni nj ke lr nk nl ki ls nm nn km no bi translated">单线程的</h2><p id="f716" class="pw-post-body-paragraph kr ks it ku b kv mo kx ky kz mp lb lc lq mq lf lg lr mr lj lk ls ms ln lo lp im bi translated">这可以这样表达(由<a class="ae lt" href="https://github.com/danyaal/mandelbrot" rel="noopener ugc nofollow" target="_blank"> danyaal </a>作出，由你真正调整):</p><blockquote class="ko kp kq"><p id="626d" class="kr ks kt ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="it">请记住，有更多、更快、优化的版本，但也有更多</em>复杂的<em class="it">版本；下面的例子应该是简单明了的&amp;，并且可以在</em> <code class="fe lu lv lw lx b"><em class="it">go</em></code> <em class="it">和</em> <code class="fe lu lv lw lx b"><em class="it">Python</em></code>之间几乎 1:1 地翻译</p></blockquote><p id="c060" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">首先，我们定义算法的迭代。这是可以并行运行的部分，我们马上就会看到。</p><pre class="lz ma mb mc gt mu lx mv mw aw mx bi"><span id="afbf" class="my jr it lx b gy mz na l nb nc">import numpy as np<br/>import matplotlib.pyplot as plt<br/><br/># counts the number of iterations until the function diverges or<br/># returns the iteration threshold that we check until<br/>def countIterationsUntilDivergent(c, threshold):<br/>    z = complex(0, 0)<br/>    for iteration in range(threshold):<br/>        z = (z*z) + c<br/><br/>        if abs(z) &gt; 4:<br/>            break<br/>            pass<br/>        pass<br/>    return iteration</span></pre><p id="6994" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">下一个函数有点庞大，但最后，它简单地创建了实轴和虚轴，将它们分配给一个二维数组，然后运行循环。</p><pre class="lz ma mb mc gt mu lx mv mw aw mx bi"><span id="3ea2" class="my jr it lx b gy mz na l nb nc">def mandelbrot(threshold, density):<br/>    # location and size of the atlas rectangle<br/>    # realAxis = np.linspace(-2.25, 0.75, density)<br/>    # imaginaryAxis = np.linspace(-1.5, 1.5, density)<br/>    realAxis = np.linspace(-0.22, -0.219, 1000)<br/>    imaginaryAxis = np.linspace(-0.70, -0.699, 1000)<br/>    realAxisLen = len(realAxis)<br/>    imaginaryAxisLen = len(imaginaryAxis)<br/><br/>    # 2-D array to represent mandelbrot atlas<br/>    atlas = np.empty((realAxisLen, imaginaryAxisLen))<br/><br/>    print('realAxisLen: {}, imaginaryAxisLen: {}'.format(realAxisLen, imaginaryAxisLen))<br/>    <br/>    # color each point in the atlas depending on the iteration count<br/>    for ix in range(realAxisLen):<br/>        for iy in range(imaginaryAxisLen):<br/>            cx = realAxis[ix]<br/>            cy = imaginaryAxis[iy]<br/>            c = complex(cx, cy)<br/><br/>            atlas[ix, iy] = countIterationsUntilDivergent(c, threshold)<br/>            pass<br/>        pass<br/><br/>    return atlas.T</span></pre><p id="c074" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">计算在单个线程上进行，如下所示:</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi np"><img src="../Images/7dd0f1014c5b724ba5fe3264e0441ee4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*B8MAauJWaCDTMk3Z.png"/></div></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">htop</p></figure><h2 id="e46a" class="my jr it bd js ne nf dn jw ng nh dp ka lq ni nj ke lr nk nl ki ls nm nn km no bi translated">多线程</h2><p id="2d74" class="pw-post-body-paragraph kr ks it ku b kv mo kx ky kz mp lb lc lq mq lf lg lr mr lj lk ls ms ln lo lp im bi translated">现在，为了在多线程中运行它，我们可以使用<code class="fe lu lv lw lx b">multiprocessing</code>模块并像这样运行它。</p><p id="318e" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated"><code class="fe lu lv lw lx b">calc_row()</code>函数可以简化，但它指出了我们的不同之处:逐行计算图像，而不是一次一个点。</p><pre class="lz ma mb mc gt mu lx mv mw aw mx bi"><span id="8211" class="my jr it lx b gy mz na l nb nc">import multiprocessing as mp<br/>import itertools<br/><br/>def calc_row(cx, cy, threshold=120):<br/>    c = complex(cx[1], cy[1])<br/>    return (cx[0], cy[0], countIterationsUntilDivergent(c, threshold))</span></pre><p id="0953" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">接下来，我做了一个有问题的决定，通过使用<code class="fe lu lv lw lx b">starmap</code>和<code class="fe lu lv lw lx b">Pool</code>来简化循环，直接将嵌套循环的排列作为参数。</p><p id="ef53" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">换句话说，无论我们给进程池多少个进程，我们都在运行<code class="fe lu lv lw lx b">calc_row(cx, cy, threshold)</code>。<code class="fe lu lv lw lx b">multiprocessing</code>库负责分别传递来自<code class="fe lu lv lw lx b">list</code>或<code class="fe lu lv lw lx b">iterator</code>的参数。</p><p id="7ee8" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">我们还返回了一个看起来很奇怪的元组，所以我们可以跟踪图像中的索引。</p><pre class="lz ma mb mc gt mu lx mv mw aw mx bi"><span id="4349" class="my jr it lx b gy mz na l nb nc">def mandelbrot_multi(threshold, density, cpus=4):<br/>    realAxis = np.linspace(-0.22, -0.219, 1000)<br/>    imaginaryAxis = np.linspace(-0.70, -0.699, 1000)<br/>    realAxisLen = len(realAxis)<br/>    imaginaryAxisLen = len(imaginaryAxis)<br/>    atlas = np.empty((realAxisLen, imaginaryAxisLen))<br/>    <br/>    # Create list of permutations<br/>    realAxis = [(i,e ) for i,e in enumerate(realAxis)] <br/>    imaginaryAxis = [(i,e ) for i,e in enumerate(imaginaryAxis)] <br/><br/>    paramlist = list(itertools.product(realAxis, imaginaryAxis))<br/>    paramlist = list(map(lambda t: t + (threshold,),paramlist))<br/>    <br/>    # Create a multiprocessing pool<br/>    pool = mp.Pool(cpus)<br/>    <br/>    n = pool.starmap(calc_row, paramlist)<br/>    pool.close()<br/>    pool.join()<br/>    return n, atlas</span></pre><p id="777d" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">它更巧妙的利用了我们现有的资源:</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi nq"><img src="../Images/3ce9008e6fc7a114da2c764462bcd6d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*p_F-ILDOCHlr33e9.png"/></div></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">htop</p></figure><p id="9cb2" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">从性能的角度来看，我们在单个 CPU 上同时使用了<strong class="ku iu"> 8.4s </strong>和<strong class="ku iu"> 2.53s </strong>，由于使用了<code class="fe lu lv lw lx b">mutliprocessing</code>模块，内存开销很大。</p><blockquote class="ko kp kq"><p id="b9e8" class="kr ks kt ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="it">当然，有很多不同的方法可以加速这一过程，比如</em><code class="fe lu lv lw lx b"><em class="it">Cython</em></code><em class="it"/><code class="fe lu lv lw lx b"><em class="it">numpy</em></code><em class="it"/><code class="fe lu lv lw lx b"><em class="it">tensorflow</em></code><em class="it">，等等，但是看看现成的并发，让我们将它与</em> <code class="fe lu lv lw lx b"><em class="it">go</em></code> <em class="it">进行比较。我不擅长选择例子，分形很漂亮。:)</em></p></blockquote><h1 id="ef29" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">去</h1><p id="cf48" class="pw-post-body-paragraph kr ks it ku b kv mo kx ky kz mp lb lc lq mq lf lg lr mr lj lk ls ms ln lo lp im bi translated">让我们看看它在<code class="fe lu lv lw lx b">go</code>是什么样子。</p><h2 id="f375" class="my jr it bd js ne nf dn jw ng nh dp ka lq ni nj ke lr nk nl ki ls nm nn km no bi translated">单线程的</h2><p id="e7b9" class="pw-post-body-paragraph kr ks it ku b kv mo kx ky kz mp lb lc lq mq lf lg lr mr lj lk ls ms ln lo lp im bi translated">单线程版本没有太大的不同。我重复使用了相同的代码，但是简单地在<code class="fe lu lv lw lx b">go</code>中重写了它。</p><blockquote class="ko kp kq"><p id="60a7" class="kr ks kt ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="it">大多数</em> <code class="fe lu lv lw lx b"><em class="it">go</em></code> <em class="it">实现都使用</em> <code class="fe lu lv lw lx b"><em class="it">Image</em></code> <em class="it">包来生成 go 中的映像——这对于一个独立的项目来说是有意义的。然而，在这里，我将数组写到磁盘并在</em> <code class="fe lu lv lw lx b"><em class="it">numpy</em></code> <em class="it">中读取，因此，</em> <code class="fe lu lv lw lx b"><em class="it">Python</em></code> <em class="it">，以保持代码简洁。</em> <code class="fe lu lv lw lx b"><em class="it">Python</em></code> <em class="it">和</em> <code class="fe lu lv lw lx b"><em class="it">go</em></code> <em class="it">的性能数字都是</em> <strong class="ku iu"> <em class="it">只是计算</em> </strong> <em class="it">，不是 I/O 或绘图像素！</em></p></blockquote><p id="af9b" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">首先，我们导入所需的包并编写一个<code class="fe lu lv lw lx b">np.linespace()</code>等价物，它返回指定间隔内的均匀分布的数字。</p><pre class="lz ma mb mc gt mu lx mv mw aw mx bi"><span id="4580" class="my jr it lx b gy mz na l nb nc">package main<br/><br/>import (<br/>	"bytes"<br/>	"fmt"<br/>	"log"<br/>	"math/cmplx"<br/>	"os"<br/>	"strings"<br/>	"time"<br/><br/>	"encoding/binary"<br/>)<br/><br/>func linspace(start, end float64, num int) []float64 {<br/>	result := make([]float64, num)<br/>	step := (end - start) / float64(num-1)<br/>	for i := range result {<br/>		result[i] = start + float64(i)*step<br/>	}<br/>	return result<br/>}</span></pre><p id="cb89" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">代码的其余部分应该看起来很熟悉——注意非常具体的强类型数据类型和返回类型。</p><pre class="lz ma mb mc gt mu lx mv mw aw mx bi"><span id="7244" class="my jr it lx b gy mz na l nb nc">func countIterationsUntilDivergent(c complex128, threshold int64) int64 {<br/>	z := complex(0, 0)<br/>	var ix int64 = 0<br/>	for i := int64(0); i &lt; threshold; i++ {<br/>		ix = i<br/>		z = (z * z) + c<br/>		if cmplx.Abs(z) &gt; 4 {<br/>			return i<br/>		}<br/>	}<br/>	return ix<br/>}<br/><br/>func mandelbrot(threshold, density int64) [][]int64 {<br/>	realAxis := linspace(-0.22, -0.219, 1000)<br/>	imaginaryAxis := linspace(-0.70, -0.699, 1000)<br/>	fmt.Printf("realAxis %v\n", len(realAxis))<br/>	fmt.Printf("imaginaryAxis %v\n", len(imaginaryAxis))<br/>	atlas := make([][]int64, len(realAxis))<br/>	for i := range atlas {<br/>		atlas[i] = make([]int64, len(imaginaryAxis))<br/>	}<br/>	fmt.Printf("atlas %v\n", len(atlas))<br/>	for ix, _ := range realAxis {<br/>		for iy, _ := range imaginaryAxis {<br/>			cx := realAxis[ix]<br/>			cy := imaginaryAxis[iy]<br/>			c := complex(cx, cy)<br/>			//fmt.Printf("ix, iy: %v %v\n", ix, iy)<br/>			atlas[ix][iy] = countIterationsUntilDivergent(c, threshold)<br/>		}<br/>	}<br/>	return atlas<br/>}</span></pre><h2 id="5872" class="my jr it bd js ne nf dn jw ng nh dp ka lq ni nj ke lr nk nl ki ls nm nn km no bi translated">多线程</h2><p id="32fe" class="pw-post-body-paragraph kr ks it ku b kv mo kx ky kz mp lb lc lq mq lf lg lr mr lj lk ls ms ln lo lp im bi translated">通过使用一个叫做<code class="fe lu lv lw lx b">goroutines</code>的概念，Go 使这变得容易多了。我们可以简单地使用<code class="fe lu lv lw lx b">go</code>指令，而不必处理 Python <code class="fe lu lv lw lx b">mutltiprocessing</code>模块、<code class="fe lu lv lw lx b">pools</code>、<code class="fe lu lv lw lx b">map</code> vs. <code class="fe lu lv lw lx b">starmap</code>以及 Python 解释器的复杂性。</p><blockquote class="ko kp kq"><p id="96f0" class="kr ks kt ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="it">正如我前面提到的，这里的代码是有意简单的，可以进行简单的优化，但是我尽量让</em> <code class="fe lu lv lw lx b"><em class="it">go</em></code> <em class="it">代码尽可能接近</em> <code class="fe lu lv lw lx b"><em class="it">Python</em></code> <em class="it">代码。请原谅任何简化。</em></p></blockquote><p id="6b60" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">首先，我们将从 Python 中重新创建<code class="fe lu lv lw lx b">calc_row</code>方法，这一次使用一个<code class="fe lu lv lw lx b">struct</code>来返回索引和值，因为我们将在第二步中使用的<code class="fe lu lv lw lx b">channel</code>不会采用多种返回类型:</p><pre class="lz ma mb mc gt mu lx mv mw aw mx bi"><span id="2e41" class="my jr it lx b gy mz na l nb nc">type triple struct {<br/>	ix, iy int64<br/>	c      int64<br/>}<br/><br/>func calcRow(ix, iy int64, c complex128, threshold int64) triple {<br/>	return triple{ix, iy, countIterationsUntilDivergent(c, threshold)}<br/>}</span></pre><p id="dcc9" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">我们的主要功能将使用两个概念:<code class="fe lu lv lw lx b">channels</code>和前面提到的<code class="fe lu lv lw lx b">goroutine</code>。</p><p id="e9fd" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">一个<a class="ae lt" href="https://golang.org/doc/effective_go.html#goroutines" rel="noopener ugc nofollow" target="_blank"> goroutine </a>有一个简单的模型:它是一个与相同地址空间中的其他 goroutine 同时执行的函数。go 文档将其与 Unix shell <code class="fe lu lv lw lx b">&amp;</code>操作符进行了比较，我发现这是一个很好的类比。</p><p id="26f9" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">我们正在使用的<a class="ae lt" href="https://golang.org/doc/effective_go.html#channels" rel="noopener ugc nofollow" target="_blank">通道</a>是一个<em class="kt">缓冲</em>通道，其作用类似于我们并发函数的管道，因为非缓冲通道天生就是阻塞的。</p><p id="a91a" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">这导致了下面的代码，该代码包装了内部循环(见上面关于琐碎优化的评论和这里的缺乏——我相信甚至一个指向<code class="fe lu lv lw lx b">goroutine</code>中的<code class="fe lu lv lw lx b">WaitGroup</code>和一个更小的<code class="fe lu lv lw lx b">channel buffer</code>的指针可能会加速这个过程，但是我还没有测试过它)。</p><pre class="lz ma mb mc gt mu lx mv mw aw mx bi"><span id="0484" class="my jr it lx b gy mz na l nb nc">func mandelbrot(threshold, density int64) [][]int64 {<br/>	realAxis := linspace(-0.22, -0.219, 1000)<br/>	imaginaryAxis := linspace(-0.70, -0.699, 1000)<br/>	atlas := make([][]int64, len(realAxis))<br/>	for i := range atlas {<br/>		atlas[i] = make([]int64, len(imaginaryAxis))<br/>	}<br/>	// Make a buffered channel<br/>	ch := make(chan triple, int64(len(realAxis))*int64(len(imaginaryAxis)))<br/><br/>	for ix, _ := range realAxis {<br/>		go func(ix int) {<br/>			for iy, _ := range imaginaryAxis {<br/>				cx := realAxis[ix]<br/>				cy := imaginaryAxis[iy]<br/>				c := complex(cx, cy)<br/>				res := calcRow(int64(ix), int64(iy), c, threshold)<br/>				ch &lt;- res<br/>			}<br/>		}(ix)<br/>	}<br/><br/>	for i := int64(0); i &lt; int64(len(realAxis))*int64(len(imaginaryAxis)); i++ {<br/>		select {<br/>		case res := &lt;-ch:<br/>			atlas[res.ix][res.iy] = res.c<br/>		}<br/>	}<br/>	return atlas<br/>}</span></pre><p id="ccc5" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">现在，对于<code class="fe lu lv lw lx b">go</code>，我们看到的是在单个 CPU 上的<strong class="ku iu">0.38 秒</strong>和代码中的<strong class="ku iu">0.18 秒</strong>，虽然相似，但要简洁得多。</p><h1 id="18bc" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">最终性能</h1><p id="27d0" class="pw-post-body-paragraph kr ks it ku b kv mo kx ky kz mp lb lc lq mq lf lg lr mr lj lk ls ms ln lo lp im bi translated">我要把这个留在这里。正如我之前概述的那样，<code class="fe lu lv lw lx b">go</code>和<code class="fe lu lv lw lx b">Python</code>代码都可以进一步优化，但是我们仍然可以获得大约 45 倍的加速</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/1dc0fb4f37daa7262fdf732613a8994b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/0*zt-XWZ4Xya91xeZo.png"/></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">使用 matplotlib 生成；CC BY-SA 3.0</p></figure><h1 id="64fb" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">现实生活中的考虑</h1><p id="04bc" class="pw-post-body-paragraph kr ks it ku b kv mo kx ky kz mp lb lc lq mq lf lg lr mr lj lk ls ms ln lo lp im bi translated">谈论理论概念可能很有趣，但这只是难题中相对较小的一部分。虽然我确信 2020 年将是<code class="fe lu lv lw lx b">Haskell</code>被广泛用于生产的一年，但我选择、使用和推荐人们学习一门语言的方法主要是基于现实生活中的使用，而不是学术理想。</p><h1 id="f222" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">语言流行度</h1><p id="763e" class="pw-post-body-paragraph kr ks it ku b kv mo kx ky kz mp lb lc lq mq lf lg lr mr lj lk ls ms ln lo lp im bi translated">这总是一个有趣的问题。</p><p id="f606" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">根据<a class="ae lt" href="https://insights.stackoverflow.com/trends?tags=go%2Cpython" rel="noopener ugc nofollow" target="_blank"> StackOverflow </a>的说法，围棋相关问题的受欢迎程度甚至还赶不上主要玩家 Python。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi nr"><img src="../Images/72d0a772811c7b165ca24686442298f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LZI_NEIKDBKjR0hhyxmNxA.png"/></div></div><p class="mk ml gj gh gi mm mn bd b be z dk translated"><a class="ae lt" href="https://insights.stackoverflow.com/trends?tags=go%2Cpython" rel="noopener ugc nofollow" target="_blank">https://insights.stackoverflow.com/trends?tags=go%2Cpython</a></p></figure><p id="b9b8" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">将此与其他一些大大小小的玩家——Java、Haskell、Scala、Lisp——进行对比，结果相似:</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi nr"><img src="../Images/98b82eda8bed1f5635daaf4d916d323a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XRTBAfjCUBo89vuKGNUvgw.png"/></div></div><p class="mk ml gj gh gi mm mn bd b be z dk translated"><a class="ae lt" href="https://insights.stackoverflow.com/trends?tags=go%2Cpython%2Cjava%2Cscala%2Chaskell%2Clisp" rel="noopener ugc nofollow" target="_blank">https://insights.stackoverflow.com/trends?tags = go % 2c python % 2c Java % 2c Scala % 2c haskell % 2c lisp</a></p></figure><p id="c84d" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">现在:提问的百分比是一个很好的衡量标准吗？大概不会。Python 是一门非常受欢迎的学习语言——我自己刚刚参与了它的培训准备——自然会吸引大量的初学者和经验丰富的专业人士。</p><p id="bf21" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">谷歌趋势显示了一个类似的故事:</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi ns"><img src="../Images/a6e529be044b7ceee4cfffe23f09cd34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*NETPMV82EJae-aC_.png"/></div></div><p class="mk ml gj gh gi mm mn bd b be z dk translated"><a class="ae lt" href="https://trends.google.com" rel="noopener ugc nofollow" target="_blank">https://trends.google.com</a></p></figure><p id="5289" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">(红色—<code class="fe lu lv lw lx b">Python</code>；蓝色- <code class="fe lu lv lw lx b">go</code>)</p><p id="a585" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">我认为可以公平地说 Python 更受欢迎——但是<code class="fe lu lv lw lx b">go</code>至少有一个利基市场，如果不是一个上升轨道的话。借助欺骗性可视化的力量，我们可以放大上面的 StackOverflow 图:</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi nr"><img src="../Images/2718a5e2b0b290552fdbca1acec7260c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zLm27sDA0M2EGC6GamIGzQ.png"/></div></div><p class="mk ml gj gh gi mm mn bd b be z dk translated"><a class="ae lt" href="https://insights.stackoverflow.com/trends?tags=go" rel="noopener ugc nofollow" target="_blank">https://insights.stackoverflow.com/trends?tags=go</a></p></figure><p id="e31e" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">事实上，找到了一个上升的轨迹。</p><p id="a853" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">此外，如果 StackOverflow 的年度<a class="ae lt" href="https://insights.stackoverflow.com/survey/2019#most-popular-technologies" rel="noopener ugc nofollow" target="_blank">开发者调查</a>可信，当被问及“最受欢迎的技术”时，<code class="fe lu lv lw lx b">go</code>从 2018 年的 7.2%上升到 2019 年的 8.8%，并在<a class="ae lt" href="https://insights.stackoverflow.com/survey/2020#technology-programming-scripting-and-markup-languages-professional-developers" rel="noopener ugc nofollow" target="_blank"> 2020 年</a>上升到 9.4%。</p><p id="c63b" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">根据<a class="ae lt" href="https://insights.stackoverflow.com/survey/2020#technology-what-languages-are-associated-with-the-highest-salaries-worldwide-united-states" rel="noopener ugc nofollow" target="_blank">的同一项调查</a>，美国<code class="fe lu lv lw lx b">go</code>的程序员也以每年 14 万美元的薪酬排名第二(高于 2019 年的第三)，仅次于<code class="fe lu lv lw lx b">Scala</code>(15 万美元)。</p><p id="c3e9" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">有希望！:)</p><h1 id="32d7" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">生态系统</h1><p id="b45b" class="pw-post-body-paragraph kr ks it ku b kv mo kx ky kz mp lb lc lq mq lf lg lr mr lj lk ls ms ln lo lp im bi translated">解释前两张图的部分原因是 Python 的巨大生态系统——后端、前端、统计、机器学习、深度学习、图形分析、GIS、机器人——它就在那里，它将有成千上万的贡献者和成千上万的用户。</p><p id="2e14" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">这里有对应的词，我试着总结了它们，以及它们在 GitHub 上的相对受欢迎程度:</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi nt"><img src="../Images/beb20c6eef168360f1d82c6bdc961885.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cxiO1fHcQIXGsw18qkwj5w.png"/></div></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">此处链接:<a class="ae lt" href="https://chollinger.com/blog/2020/06/a-data-engineering-perspective-on-go-vs.-python-part-1/#ecosystem" rel="noopener ugc nofollow" target="_blank">https://CHOL linger . com/blog/2020/06/a-data-engineering-perspective-on-go-vs .-python-part-1/#生态系统</a></p></figure><p id="3d2d" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">很明显，至少从数据工程和数据科学的角度来看，围棋生态系统还有很长的路要走。</p><p id="1955" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated"><em class="kt">【1】阿帕奇光束不能替代 Spark </em></p><h1 id="a55c" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">学习曲线</h1><p id="dd95" class="pw-post-body-paragraph kr ks it ku b kv mo kx ky kz mp lb lc lq mq lf lg lr mr lj lk ls ms ln lo lp im bi translated">这个是主观的——我个人觉得<code class="fe lu lv lw lx b">Python</code>只在表面上更容易学。如果你真的想理解底层的概念、架构和库，<code class="fe lu lv lw lx b">Python</code>真的是一个兔子洞，不像<code class="fe lu lv lw lx b">Java</code>。</p><p id="f309" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">另一方面，<code class="fe lu lv lw lx b">go</code>是一种相当简单的语言，它关注于某些元素。请允许我引用:</p><blockquote class="ko kp kq"><p id="8427" class="kr ks kt ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="it">设计 Go 的时候，Java 和 C++是编写服务器最常用的语言，至少在 Google 是这样。我们觉得这些语言需要太多的记账和重复。一些程序员以效率和类型安全为代价，转向更动态、更流畅的语言，如 Python。我们觉得在单一语言中实现高效、安全和流畅应该是可能的。</em></p><p id="a8fa" class="kr ks kt ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="it"> Go 试图在单词的两个意义上减少打字量。在整个设计过程中，我们努力减少混乱和复杂性。没有转发声明，也没有头文件；所有东西都声明一次。初始化是富于表现力的、自动的和易于使用的。语法干净，关键字少。口吃(foo。Foo* myFoo = new(foo。Foo))通过使用:= declare-and-initialize 构造的简单类型派生来减少。也许最根本的是，没有类型层次结构:类型就是类型，它们不需要声明它们之间的关系。这些简化使得 Go 既有表现力又易于理解，同时又不牺牲复杂性。</em></p><p id="325a" class="kr ks kt ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="it">另一个重要原则是保持概念的正交性。可以为任何类型实现方法；结构代表数据，而接口代表抽象；诸如此类。正交性使得更容易理解当事物组合时会发生什么。</em></p><p id="9095" class="kr ks kt ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae lt" href="https://golang.org/doc/faq#creating_a_new_language" rel="noopener ugc nofollow" target="_blank"><em class="it">https://golang.org/doc/faq#creating_a_new_language</em></a></p></blockquote><p id="d851" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">快速浏览一下<code class="fe lu lv lw lx b">LinkedIn Learning</code>就会发现<code class="fe lu lv lw lx b">go</code>总共有 4 道菜<code class="fe lu lv lw lx b">Python</code>有 168 道菜。</p><p id="4582" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">在我自己的经验中，最有帮助的事情是通过<a class="ae lt" href="https://gobyexample.com/" rel="noopener ugc nofollow" target="_blank">逐个例子</a>并真正阅读文档。另一方面，Python 作为更广泛层次的外部教程、课程、认证、博客帖子[&amp;mldr；]来自我这样的人，大学，大公司。</p><blockquote class="ko kp kq"><p id="683c" class="kr ks kt ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="it">在谷歌上查询“go 语言教程”会返回 17 亿条结果，而“python 语言教程”会返回 1620 亿条结果</em></p></blockquote><h1 id="c3f9" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">阿帕奇波束</h1><p id="d1e8" class="pw-post-body-paragraph kr ks it ku b kv mo kx ky kz mp lb lc lq mq lf lg lr mr lj lk ls ms ln lo lp im bi translated">现在，我们已经讨论了很多关于<code class="fe lu lv lw lx b">go</code>和<code class="fe lu lv lw lx b">Python</code>的一般性问题。但是这个帖子的开篇是什么——<code class="fe lu lv lw lx b">Beam</code>和<code class="fe lu lv lw lx b">Dataflow</code>在哪里？</p><blockquote class="ko kp kq"><p id="e67f" class="kr ks kt ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="it">这一部分将在本文的第 2 部分进行简要阐述</em></p></blockquote><p id="420e" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">一般来说，<code class="fe lu lv lw lx b">beam</code> <code class="fe lu lv lw lx b">go</code> SDK 确实提供了运行相对简单的任务所需的核心功能。然而，在撰写本文时(2020-06-11)，它确实有一系列的缺点。</p><h1 id="1bcd" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">转换</h1><p id="77f7" class="pw-post-body-paragraph kr ks it ku b kv mo kx ky kz mp lb lc lq mq lf lg lr mr lj lk ls ms ln lo lp im bi translated">让我们看看跨<code class="fe lu lv lw lx b">beam</code>语言的可用转换。我挑选了几个，但是请随意参考所有的文档以获得完整的图片:</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi nu"><img src="../Images/3a4bcec09cbb74a13b9057c1f8dd60dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fTicxtGPSsmxJYtComOhqw.png"/></div></div><p class="mk ml gj gh gi mm mn bd b be z dk translated"><a class="ae lt" href="https://chollinger.com/blog/2020/06/a-data-engineering-perspective-on-go-vs.-python-part-1/#transformations" rel="noopener ugc nofollow" target="_blank">https://CHOL linger . com/blog/2020/06/a-data-engineering-perspective-on-go-vs .-python-part-1/# transformations</a></p></figure><p id="5153" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">对于来自<code class="fe lu lv lw lx b">Python</code>的人来说，最显著的不同将是管道的整体外观。</p><p id="d1df" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">这是在<code class="fe lu lv lw lx b">Python</code>中如何完成的(旁注:没有什么可以阻止你调用<code class="fe lu lv lw lx b">data.apply(func)</code>，因为操作符只是过载了):</p><pre class="lz ma mb mc gt mu lx mv mw aw mx bi"><span id="1f7c" class="my jr it lx b gy mz na l nb nc">class CountWords(beam.PTransform):<br/>  def expand(self, pcoll):<br/>    return (<br/>        pcoll<br/>        # Convert lines of text into individual words.<br/>        | 'ExtractWords' &gt;&gt;<br/>        beam.FlatMap(lambda x: re.findall(r'[A-Za-z\']+', x))<br/><br/>        # Count the number of times each word occurs.<br/>        | beam.combiners.Count.PerElement())<br/><br/>counts = lines | CountWords()</span></pre><p id="50a3" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">在<code class="fe lu lv lw lx b">go</code>中，它看起来更像一个常规的旧函数:</p><pre class="lz ma mb mc gt mu lx mv mw aw mx bi"><span id="15be" class="my jr it lx b gy mz na l nb nc">func CountWords(s beam.Scope, lines beam.PCollection) beam.PCollection {<br/>	s = s.Scope("CountWords")<br/><br/>	// Convert lines of text into individual words.<br/>	col := beam.ParDo(s, extractFn, lines)<br/><br/>	// Count the number of times each word occurs.<br/>	return stats.Count(s, col)<br/>}</span></pre><blockquote class="ko kp kq"><p id="6131" class="kr ks kt ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将在第二部分探讨这些细节</p></blockquote><h1 id="2ba5" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">输入－输出</h1><p id="1e64" class="pw-post-body-paragraph kr ks it ku b kv mo kx ky kz mp lb lc lq mq lf lg lr mr lj lk ls ms ln lo lp im bi translated">I/O 可能是<code class="fe lu lv lw lx b">go</code> sdk 中最受限制的部分，有许多连接器不可用于 go。</p><blockquote class="ko kp kq"><p id="f76a" class="kr ks kt ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="it">请参见</em> <a class="ae lt" href="https://beam.apache.org/documentation/io/built-in/" rel="noopener ugc nofollow" target="_blank"> <em class="it">此链接</em> </a> <em class="it">了解最新概况。</em></p></blockquote><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi nv"><img src="../Images/a4910f38aa00b3558c8f5c5087140198.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4CMl6z-i9PBlZXU_Cu-i5g.png"/></div></div><p class="mk ml gj gh gi mm mn bd b be z dk translated"><a class="ae lt" href="https://beam.apache.org/documentation/io/built-in/" rel="noopener ugc nofollow" target="_blank">https://beam.apache.org/documentation/io/built-in/</a></p></figure><p id="975a" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">如果要我总结的话:<code class="fe lu lv lw lx b">beam</code>上的<code class="fe lu lv lw lx b">go</code>支持基本的<code class="fe lu lv lw lx b">Google Cloud</code>服务和地方发展，而<code class="fe lu lv lw lx b">Java</code>则涵盖了几乎所有情况。[2]</p><p id="6f1d" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated"><em class="kt"> [2]请记住，一些连接器，如</em> <code class="fe lu lv lw lx b"><em class="kt">DatabaseIO</em></code> <em class="kt">，本质上是特定于语言的</em></p><h1 id="66db" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">滑行装置</h1><p id="e391" class="pw-post-body-paragraph kr ks it ku b kv mo kx ky kz mp lb lc lq mq lf lg lr mr lj lk ls ms ln lo lp im bi translated">最后，看看可用的运行器，<code class="fe lu lv lw lx b">go</code>或多或少地受限于<code class="fe lu lv lw lx b">Direct</code>和<code class="fe lu lv lw lx b">Dataflow</code>，这符合我在 I/O 上的声明。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi nw"><img src="../Images/1d131094f0be49cea9271ca8af89e3ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PuxMbuwVcIGg9kVS-7Li4Q.png"/></div></div><p class="mk ml gj gh gi mm mn bd b be z dk translated"><a class="ae lt" href="https://chollinger.com/blog/2020/06/a-data-engineering-perspective-on-go-vs.-python-part-1/#runners" rel="noopener ugc nofollow" target="_blank">https://CHOL linger . com/blog/2020/06/a-data-engineering-perspective-on-go-vs .-python-part-1/# runners</a></p></figure><blockquote class="ko kp kq"><p id="cba8" class="kr ks kt ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="it">答(是)表示这些跑步者有局限性</em></p></blockquote><h1 id="9c2e" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">逐行示例</h1><p id="420f" class="pw-post-body-paragraph kr ks it ku b kv mo kx ky kz mp lb lc lq mq lf lg lr mr lj lk ls ms ln lo lp im bi translated">我建议通过<code class="fe lu lv lw lx b"><a class="ae lt" href="https://beam.apache.org/get-started/wordcount-example/#minimalwordcount-example" rel="noopener ugc nofollow" target="_blank">WordCount</a></code>。</p><p id="abd4" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated"><code class="fe lu lv lw lx b">WordCount</code>是一个很好的例子，因为它展示了以下概念:</p><ul class=""><li id="c7e9" class="nx ny it ku b kv kw kz la lq nz lr oa ls ob lp oc od oe of bi translated">创建管道</li><li id="bcb2" class="nx ny it ku b kv og kz oh lq oi lr oj ls ok lp oc od oe of bi translated">将转换应用于管道</li><li id="cac7" class="nx ny it ku b kv og kz oh lq oi lr oj ls ok lp oc od oe of bi translated">阅读输入</li><li id="fcf7" class="nx ny it ku b kv og kz oh lq oi lr oj ls ok lp oc od oe of bi translated">应用帕尔多变换</li><li id="f9bb" class="nx ny it ku b kv og kz oh lq oi lr oj ls ok lp oc od oe of bi translated">应用 SDK 提供的转换</li><li id="f7e3" class="nx ny it ku b kv og kz oh lq oi lr oj ls ok lp oc od oe of bi translated">写入输出(在本例中:写入文本文件)</li><li id="8255" class="nx ny it ku b kv og kz oh lq oi lr oj ls ok lp oc od oe of bi translated">运行管道</li></ul><p id="c8c0" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">为了简洁起见，我不会在这一点上深入那些细节。</p><h1 id="2475" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">结论</h1><p id="50dc" class="pw-post-body-paragraph kr ks it ku b kv mo kx ky kz mp lb lc lq mq lf lg lr mr lj lk ls ms ln lo lp im bi translated">首先要问的问题之一应该是:比较这两种语言有意义吗？我的答案可能是显而易见的——虽然<code class="fe lu lv lw lx b">go</code>可能是为不同的用例设计的(通用脚本和机器学习用例与系统/“云”编程)，但从数据工程的角度来看，上面概述的概念仍然让我兴奋不已。</p><p id="b3b3" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated"><code class="fe lu lv lw lx b">go</code>有许多概念，不需要庞大的<code class="fe lu lv lw lx b">pip</code>依赖树就能工作，产生干净的代码，易于编译，非常快，而且(在我看来)对未来的数据和 ML 用例有很大的潜力。</p><p id="8ebe" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated"><strong class="ku iu">总之:</strong> <code class="fe lu lv lw lx b"><strong class="ku iu">go</strong></code> <strong class="ku iu">和</strong> <code class="fe lu lv lw lx b"><strong class="ku iu">Python</strong></code> <strong class="ku iu">显然是非常不同的语言——正如我在上面的</strong>中用我精选的例子成功概括的那样。</p><h1 id="178f" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">后续步骤</h1><p id="5556" class="pw-post-body-paragraph kr ks it ku b kv mo kx ky kz mp lb lc lq mq lf lg lr mr lj lk ls ms ln lo lp im bi translated">由于我在这篇文章中只浏览了<code class="fe lu lv lw lx b">Apache Beam</code>的表面，下一篇文章将关注以下问题，以将<code class="fe lu lv lw lx b">Dataflow</code>用作“野外的<code class="fe lu lv lw lx b">go</code>”的真实示例:</p><ul class=""><li id="d652" class="nx ny it ku b kv kw kz la lq nz lr oa ls ob lp oc od oe of bi translated"><code class="fe lu lv lw lx b">go</code> Beam SDK 有多成熟？</li><li id="a4a1" class="nx ny it ku b kv og kz oh lq oi lr oj ls ok lp oc od oe of bi translated">它支持什么？少了什么？</li><li id="dfd0" class="nx ny it ku b kv og kz oh lq oi lr oj ls ok lp oc od oe of bi translated">什么是根本区别？</li><li id="c763" class="nx ny it ku b kv og kz oh lq oi lr oj ls ok lp oc od oe of bi translated">(如何)我们可以在<code class="fe lu lv lw lx b">GCP</code>运行<code class="fe lu lv lw lx b">Dataflow</code>作业？</li></ul><p id="8321" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated">所有的开发和基准测试都是在 GNU/Linux [PopOS！内核 5.4 上的 19.10]在 2019 System76 Gazelle 笔记本电脑上使用 12 个英特尔 i7–9750h v cores @ 4.5 GHz 和 16GB RAM</p></div><div class="ab cl ol om hx on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="im in io ip iq"><p id="517b" class="pw-post-body-paragraph kr ks it ku b kv kw kx ky kz la lb lc lq le lf lg lr li lj lk ls lm ln lo lp im bi translated"><em class="kt">原载于 2020 年 6 月 11 日 https://chollinger.com</em><em class="kt">的</em> <a class="ae lt" href="https://chollinger.com/blog/2020/06/a-data-engineering-perspective-on-go-vs.-python-part-1" rel="noopener ugc nofollow" target="_blank"> <em class="kt">。</em></a></p></div></div>    
</body>
</html>