<html>
<head>
<title>How to create a Binomial distribution graph using Plotly, Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Plotly、Python创建二项式分布图</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/create-binomial-distribution-graph-using-plotly-python-18eb92c2c78?source=collection_archive---------41-----------------------#2020-04-26">https://towardsdatascience.com/create-binomial-distribution-graph-using-plotly-python-18eb92c2c78?source=collection_archive---------41-----------------------#2020-04-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/321e630e17809d3a34dfcabdd03bcf33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*Ape7mTPlBcQJs9j4v9_BvQ.gif"/></div></figure><p id="cd8d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">有时，Python图表是您的论点或您试图构建的数据案例的必要元素。本教程是关于创建二项式或正态分布图。我们将从声明一个二项式分布的数字数组开始。我们只需从scipy.stats导入binom就可以做到这一点。</p><pre class="ks kt ku kv gt kw kx ky kz aw la bi"><span id="4594" class="lb lc iq kx b gy ld le l lf lg">from scipy.stats import binom<br/>n = 1024<br/>size = 1000<br/>prob = 0.1<br/>y = binom.rvs(n, prob, size=size)</span></pre><p id="2ea8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这段代码生成1000个数字，共1024次，成功概率为0.1。一旦完成了这个，接下来我们要计算数组中数字的频率。我们可以通过将此作为数据帧并使用以下逻辑创建频率仓来实现这一点。</p><pre class="ks kt ku kv gt kw kx ky kz aw la bi"><span id="d59d" class="lb lc iq kx b gy ld le l lf lg">import numpy as np<br/>import pandas as pd</span><span id="30e3" class="lb lc iq kx b gy lh le l lf lg"># Creating X array for numbers between the maximum and minimum values of y and making it a dataframe<br/>x = np.arange(y.min(), y.max())<br/>xx = pd.DataFrame(x)</span><span id="f947" class="lb lc iq kx b gy lh le l lf lg"># Making y a dataframe and generating an empty array yy<br/>d = pd.DataFrame(y, columns  = ['Data'])<br/>yy = []</span><span id="e27a" class="lb lc iq kx b gy lh le l lf lg"># Calculating frequency of all numbers between maxiumum and minimum values<br/>for k in range(len(x)):<br/>        yy.append(d[d['Data'] == x[k]].count()[0])</span><span id="b5b0" class="lb lc iq kx b gy lh le l lf lg"># Making frequency data frame and concatenating it with the xx <br/>freq = pd.DataFrame(yy, columns=['Frequency'])<br/>data = pd.concat([xx, freq], axis=1)<br/>data.columns = ['Score', 'Frequency']</span></pre><p id="b91e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在我们有了分数和频率箱。我们可以使用plotly.graph使用这些数据生成一个二项式图。</p><pre class="ks kt ku kv gt kw kx ky kz aw la bi"><span id="bf13" class="lb lc iq kx b gy ld le l lf lg">import plotly.graph_objects as go<br/>fig = go.Figure(</span><span id="1402" class="lb lc iq kx b gy lh le l lf lg">    # Loading the data into the figur<br/>    data=[go.Scatter(x=data['Score'], y=data['Frequency'],<br/>                     mode="lines",<br/>                     line=dict(width=2, color="blue"))],</span><span id="0631" class="lb lc iq kx b gy lh le l lf lg">    # Setting the layout of the graph<br/>    layout=go.Layout(<br/>        xaxis=dict(range=[y.min(), y.max()], autorange=False),<br/>        yaxis=dict(range=[data['Frequency'].min(), data['Frequency'].max()], autorange=False),<br/>        title="Binomial Curve",<br/>        updatemenus=[dict(<br/>            type="buttons",<br/>            buttons=[dict(label="Play",<br/>                          method="animate",<br/>                          args=[None])])]<br/>    ))<br/>fig.show()</span></pre><p id="8b62" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">下图是使用上面的代码生成的。</p><figure class="ks kt ku kv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi li"><img src="../Images/548a38a8cf7a935a9e5e71c474e10e7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ynidTkE5o20hsKhY8C3LUQ.png"/></div></div></figure><p id="074d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">正如我们所看到的，曲线展示了一个基本的二项式行为，有很多噪声，随机徘徊在预期路径的上方和下方。但是通过重复这个过程很多次并平均结果，它可以很容易地变成一个完整的二项式图。在我的例子中，我执行了1500次上述步骤。请查看下面的代码:</p><pre class="ks kt ku kv gt kw kx ky kz aw la bi"><span id="6827" class="lb lc iq kx b gy ld le l lf lg">n = 1024<br/>size = 1000<br/>prob = p / 10<br/>x = np.arange(70, 135)<br/>yy = []<br/>tt = []</span><span id="2f1f" class="lb lc iq kx b gy lh le l lf lg"># Repeating the step 1500 times, rest code is same as above<br/>for a in range(1500):</span><span id="510a" class="lb lc iq kx b gy lh le l lf lg">    y = binom.rvs(n, prob, size=size)<br/>    d = pd.DataFrame(y, columns  = ['Data'])<br/>    <br/>    for k in range(len(x)):<br/>        yy.append(d[d['Data'] == x[k]].count()[0])<br/>        <br/>    tt.append(yy)<br/>    yy = []<br/>    y = []</span><span id="1cd5" class="lb lc iq kx b gy lh le l lf lg">kk = pd.DataFrame(tt).T<br/>y = kk.mean(axis=1)<br/>N = len(y)</span></pre><p id="414b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">上面的代码生成了一个新的数组“y ”,它对数据中所有分数的频率进行了平均。我们可以使用下面的代码生成一个新的数据框并查看数据:</p><pre class="ks kt ku kv gt kw kx ky kz aw la bi"><span id="400b" class="lb lc iq kx b gy ld le l lf lg">data = pd.DataFrame([x,y]).T<br/>data.columns = ['Score', 'Frequency']<br/>data.head()</span></pre><p id="2563" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">使用plotly代码再次绘制这些数据，我们得到了一个好看的二项式图。</p><figure class="ks kt ku kv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi ln"><img src="../Images/e2e21b1ece1a9c88003ebca3e62cb2d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6czMjU6JUlfqAeBzXDb7KA.png"/></div></div></figure><p id="400a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">有了上面的图表，我们可以对数据做更多的处理，比如我们可以用plotly来制作图表的梯度或它在每一点的导数的动画。</p><p id="5408" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">任何一点的导数都可以用下面的公式进行数值计算。</p><figure class="ks kt ku kv gt jr gh gi paragraph-image"><div class="gh gi lo"><img src="../Images/b6fbf39ee15f5df66fb25586cece16b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:524/format:webp/1*fJTy4z62xPczRcNeTlKRFg.jpeg"/></div></figure><p id="e2ed" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们可以使用pandas实现这个公式，计算所有相关点的梯度值。</p><pre class="ks kt ku kv gt kw kx ky kz aw la bi"><span id="e103" class="lb lc iq kx b gy ld le l lf lg"># Declaring an empty array<br/>deri = []</span><span id="3615" class="lb lc iq kx b gy lh le l lf lg"># Setting first derivative to zero<br/>fir = 0<br/>deri.append(fir)</span><span id="0ef9" class="lb lc iq kx b gy lh le l lf lg"># Calculating the derivative all points other than first and last points<br/>for a in range(1,64):<br/>    diff = (data['Frequency'][a+1] - data['Frequency'][a-1])/2<br/>    deri.append(diff)</span><span id="0f7c" class="lb lc iq kx b gy lh le l lf lg"># Setting last derivative to zero<br/>end = 0<br/>deri.append(end)</span><span id="e0fb" class="lb lc iq kx b gy lh le l lf lg">der = pd.DataFrame(deri, columns = ['Derivatives'])<br/>data = pd.concat([data, der], axis = 1)</span></pre><p id="4e61" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">请注意，我们特意将零作为数据中第一个和最后一个点的值。这样做是因为导数公式需要前值和后值。第一个值缺少前一个值，最后一个值缺少后一个值。此后，为了方便起见，两者都保持为零。</p><p id="90fd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在我们有了导数，我们需要计算我们需要在plotly上制作动画的渐变线的开始和结束坐标。</p><pre class="ks kt ku kv gt kw kx ky kz aw la bi"><span id="9a36" class="lb lc iq kx b gy ld le l lf lg">sx = []<br/>sy = []<br/>ex = []<br/>ey = []<br/>Gap = 3.5</span><span id="9841" class="lb lc iq kx b gy lh le l lf lg">for b in range(0,65):<br/>    #Computing Start Coordinates<br/>    ssx =data['Score'][b] - Gap<br/>    sx.append(ssx)<br/>    ssy = data['Frequency'][b] - Gap * data['Derivatives'][b]<br/>    sy.append(ssy)<br/>    #Computing End Coordinates<br/>    eex = data['Score'][b] + Gap<br/>    ex.append(eex)<br/>    eey = data['Frequency'][b] + Gap * data['Derivatives'][b]<br/>    ey.append(eey)</span><span id="c412" class="lb lc iq kx b gy lh le l lf lg">cord = pd.DataFrame([sx, sy, ex, ey]).T<br/>cord.columns = ['XStart', 'YStart', 'XEnd', 'YEnd']</span></pre><p id="8035" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在我们已经完成了，我们可以可视化产生的动画。</p><figure class="ks kt ku kv gt jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/321e630e17809d3a34dfcabdd03bcf33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*Ape7mTPlBcQJs9j4v9_BvQ.gif"/></div></figure><p id="cb2c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">此外，如果我们想要在该图上标记区域并添加文本，我们可以使用下面的代码片段轻松完成。</p><pre class="ks kt ku kv gt kw kx ky kz aw la bi"><span id="9e5c" class="lb lc iq kx b gy ld le l lf lg">fig.add_trace(go.Scatter(x=[70,85,85,70], y=[0,0,50,50], fill='toself', mode='lines', line_color='#FF5A5F', opacity = 0.3))<br/>fig.add_trace(go.Scatter(x=[85,102,102,85], y=[0,0,50,50], fill='toself', mode='lines', line_color='#C81D25', opacity = 0.3))<br/>fig.add_trace(go.Scatter(x=[102,119,119,102], y=[0,0,50,50], fill='toself', mode='lines', line_color='#0B3954', opacity = 0.3))<br/>fig.add_trace(go.Scatter(x=[119,135,135,119], y=[0,0,50,50], fill='toself', mode='lines', line_color='#087E8B', opacity = 0.3))</span><span id="d996" class="lb lc iq kx b gy lh le l lf lg">fig.add_trace(go.Scatter(<br/>    x=[77.5, 93.5, 110.5, 127],<br/>    y=[40, 40, 40, 40],<br/>    mode="text",<br/>    name="Regions",<br/>    text=["Low Risk", "High Risk", "Stabilization", "Recovery"],<br/>    textposition="top center",<br/>    textfont=dict(<br/>        family="sans serif",<br/>        size=20,<br/>        color="black"<br/>    )<br/>))</span><span id="9588" class="lb lc iq kx b gy lh le l lf lg">fig.show()</span></pre><p id="5386" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们最终得到下图。</p><figure class="ks kt ku kv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi lp"><img src="../Images/aa4a8acc777d418197e1b106ebda76c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1SrUAFUXndvhQ1DVdil5ag.png"/></div></div></figure><p id="01f3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果你仍然对我在做什么感到好奇，请看看我的下一个博客，在这里，所有这些技术都被用来可视化“新冠肺炎的全球地位”。敬请期待，干杯。</p><p id="8f01" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">二项式曲线的完整Jupyter笔记本实现可以在<a class="ae lq" href="https://github.com/usamatrq94/BinomialCurve/blob/master/Binomial_Graphs.ipynb" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p></div></div>    
</body>
</html>