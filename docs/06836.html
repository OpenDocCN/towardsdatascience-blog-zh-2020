<html>
<head>
<title>Dockerize, Deploy, and Call my SDR Email Detector Model via API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过API对接、部署和调用我的SDR电子邮件检测器模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/dockerize-deploy-and-call-my-sdr-email-detector-model-via-api-68e238b7ecff?source=collection_archive---------66-----------------------#2020-05-27">https://towardsdatascience.com/dockerize-deploy-and-call-my-sdr-email-detector-model-via-api-68e238b7ecff?source=collection_archive---------66-----------------------#2020-05-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="a9a6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是我<a class="ae ko" rel="noopener" target="_blank" href="/minimizing-sales-emails-in-my-inbox-with-natural-language-processing-38296b562da7">之旅的第二部分，建立一个系统，最大限度地减少我每天处理的销售邮件数量。概括地说，该系统通过OAuth连接到用户的Gmail，确定收到的电子邮件是否来自销售开发代表(<code class="fe kp kq kr ks b">from_SDR=1</code>)，并将这些电子邮件移动到一个特殊的文件夹中“稍后阅读”如果电子邮件不是<code class="fe kp kq kr ks b">from_SDR</code>，那么它会将分类邮件留在主收件箱中。</a></p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/87b6e3609cd06177a04c550ed7b4c6fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l1kFxuTvlzfAlFbwqZjdDQ.png"/></div></div><p class="lf lg gj gh gi lh li bd b be z dk translated">使用自然语言处理的SDR电子邮件检测器</p></figure><p id="ce5d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<a class="ae ko" rel="noopener" target="_blank" href="/minimizing-sales-emails-in-my-inbox-with-natural-language-processing-38296b562da7">我的最后一篇帖子</a>中，我从收件箱中取出带标签的电子邮件，训练一个机器学习模型来分类电子邮件是否来自SDR，并评估该模型的性能。在这里，我描述了如何将我的模型部署到API端点，这样我就可以从Gmail小程序中调用它。</p><p id="2ab5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有很多方法可以让你的模型进入云端。我从AWS找到了这个例子，<a class="ae ko" href="https://github.com/awslabs/amazon-sagemaker-examples/blob/master/advanced_functionality/scikit_bring_your_own/scikit_bring_your_own.ipynb" rel="noopener ugc nofollow" target="_blank">自带Sci-kit模型</a>，它是最简单的，解释得最好的，也最适用于我的项目。下面的步骤展示了我如何将我的模型容器化，将容器推入Sagemaker服务器，然后使用Chalice管理该服务器的API端点。</p><h2 id="e451" class="lj lk it bd ll lm ln dn lo lp lq dp lr kb ls lt lu kf lv lw lx kj ly lz ma mb bi translated">设置我的Docker容器</h2><p id="ee79" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">Docker提供了一种将代码打包成映像的方法，该映像可以作为一个自包含的环境在服务器上运行。<em class="mh"> Dockerfile </em>指定应该如何创建图像。在这种情况下，我制作了一个Docker映像，它可以运行Python 3.7.7来匹配我的本地环境，并导入必要的包来执行我在<a class="ae ko" rel="noopener" target="_blank" href="/minimizing-sales-emails-in-my-inbox-with-natural-language-processing-38296b562da7">第一部分</a>中描述的培训脚本。</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="f42a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您正在关注这个<a class="ae ko" href="https://github.com/awslabs/amazon-sagemaker-examples/blob/master/advanced_functionality/scikit_bring_your_own/scikit_bring_your_own.ipynb" rel="noopener ugc nofollow" target="_blank"> AWS示例</a>，请注意这些使其与Python 3一起工作所需的重要更新:(I)我在第3行升级到了Python 3.7.7，这(ii)改变了第17行中的包的位置。</p><p id="75bd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我从AWS示例中复制了<a class="ae ko" href="https://github.com/awslabs/amazon-sagemaker-examples/tree/master/advanced_functionality/scikit_bring_your_own" rel="noopener ugc nofollow" target="_blank">容器目录</a>，它提供了打包Amazon SageMager算法所必需的文件。例如，该目录包含用于<em class="mh">构建和使用<code class="fe kp kq kr ks b">docker push</code>将容器映像推</em>到AWS ECR的shell代码。请注意，我修改了示例代码以与AWS CLI v2配合使用(参见第45–50行):</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="5a35" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是在我构建和推送AWS ECR之前，我必须在容器目录中准备执行训练和预测步骤的文件。</p><h2 id="43c6" class="lj lk it bd ll lm ln dn lo lp lq dp lr kb ls lt lu kf lv lw lx kj ly lz ma mb bi translated">将我的训练脚本添加到容器中</h2><p id="b8d4" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">我用我自己的训练脚本替换了示例容器中的<code class="fe kp kq kr ks b">train</code>文件(参见本系列的<a class="ae ko" rel="noopener" target="_blank" href="/minimizing-sales-emails-in-my-inbox-with-natural-language-processing-38296b562da7">第一部分</a>了解详细信息):</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="d2b2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意从<code class="fe kp kq kr ks b">preprocess.py</code>引入的两个模块，它们将数据转换成我的机器学习模型可以接受的格式。这些类和函数包含在同一个文件夹中:</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="2cd4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，我修改了示例容器中的<code class="fe kp kq kr ks b">predictor.py</code>文件，如下所示:</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="0519" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我的更改主要反映在第64–78行，在那里我更新了AWS示例<a class="ae ko" href="https://github.com/awslabs/amazon-sagemaker-examples/blob/master/advanced_functionality/scikit_bring_your_own/container/decision_trees/predictor.py" rel="noopener ugc nofollow" target="_blank">以使用最新版本的StringIO，并在<code class="fe kp kq kr ks b">data</code>数据帧上包含标题以匹配我的模型的预期输入。</a></p><p id="2b54" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">编辑完这些文件后，我运行了构建和推送脚本:</p><pre class="ku kv kw kx gt mk ks ml mm aw mn bi"><span id="4c00" class="lj lk it ks b gy mo mp l mq mr">$ sh build_and_push.sh sg_linearsvm</span></pre><p id="a735" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它创建了Docker容器并将其推送到AWS ECR。</p><h2 id="e83d" class="lj lk it bd ll lm ln dn lo lp lq dp lr kb ls lt lu kf lv lw lx kj ly lz ma mb bi translated">部署算法之前在本地主机上测试它</h2><p id="2d4c" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">在部署模型之前，确定容器化的代码是否正常工作是很有用的。<a class="ae ko" href="https://github.com/awslabs/amazon-sagemaker-examples/tree/master/advanced_functionality/scikit_bring_your_own/container/local_test" rel="noopener ugc nofollow" target="_blank"> AWS示例</a>为此提供了一个子目录<code class="fe kp kq kr ks b">local_test</code>。我克隆了那个repo，并将我的样本训练数据添加到适当的文件夹<code class="fe kp kq kr ks b">/local_test/test_dir/input/data/training</code>中，然后运行:</p><pre class="ku kv kw kx gt mk ks ml mm aw mn bi"><span id="a891" class="lj lk it ks b gy mo mp l mq mr">$ ./train_local.sh sg_linearsvm</span></pre><p id="09ae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该shell脚本以<code class="fe kp kq kr ks b">train</code>模式运行docker映像:</p><pre class="ku kv kw kx gt mk ks ml mm aw mn bi"><span id="ccc7" class="lj lk it ks b gy mo mp l mq mr">image=$1<br/>mkdir -p test_dir/model<br/>mkdir -p test_dir/output<br/>rm test_dir/model/*<br/>rm test_dir/output/*<br/>docker run -v $(pwd)/test_dir:/opt/ml --rm ${image} train</span></pre><p id="6226" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用我的容器的<code class="fe kp kq kr ks b">local_test</code>版本，我能够诊断和解决与将我的脚本从Google Colab移植到Docker容器相关的各种问题。一旦这些问题得到解决，我还必须测试<code class="fe kp kq kr ks b">serve</code>的功能。所以我跑了:</p><pre class="ku kv kw kx gt mk ks ml mm aw mn bi"><span id="8f2e" class="lj lk it ks b gy mo mp l mq mr">./serve_local.sh sg_linearsvm</span></pre><p id="de7e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是一个执行以下代码的shell脚本:</p><pre class="ku kv kw kx gt mk ks ml mm aw mn bi"><span id="5ec8" class="lj lk it ks b gy mo mp l mq mr">image=$1<br/>docker run -v $(pwd)/test_dir:/opt/ml -p 8080:8080 --rm ${image} serve</span></pre><p id="ae3c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦Docker服务器运行本地映像，我就能够从我的终端命令行得到一个预测:</p><pre class="ku kv kw kx gt mk ks ml mm aw mn bi"><span id="ad83" class="lj lk it ks b gy mo mp l mq mr">./predict.sh payload.csv text/csv</span></pre><p id="695e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其中<code class="fe kp kq kr ks b">payload.csv</code>是一个模拟模型预期输入的CSV文件:</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/d6dbe133a92d849c069331eb08cb8cf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/1*VsqA82c1PBXBSH7kIOXN_Q.png"/></div></figure><p id="6347" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下是响应，显示该容器的行为符合预期:</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/1b7faa6889e0370a9ba0e6a6ead66968.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/1*XQsupGJp7BcNx7udtC4sEA.png"/></div></figure><p id="2d2f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我需要将我的容器放入SageMaker服务器，这样我就可以在web上训练和托管我的模型。</p><h2 id="8482" class="lj lk it bd ll lm ln dn lo lp lq dp lr kb ls lt lu kf lv lw lx kj ly lz ma mb bi translated">将我的容器部署到Amazon SageMaker</h2><p id="5600" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">首先，我设置了环境，指定了S3 bucket和SageMaker角色。我还创建了<code class="fe kp kq kr ks b">sess</code>来记住连接参数，我用它来执行各种SageMaker操作。</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="6299" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我指定了模型应该在S3的哪里找到我的训练数据(第1-3行)，并使用适当的帐户、地区和容器名称(第5-11行)标识了<code class="fe kp kq kr ks b">image</code>。</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="d2c1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了适应我的算法，我创建了一个SageMaker估计器，它定义了如何使用容器进行训练(下面的第1–4行)。然后我使用<code class="fe kp kq kr ks b">estimator</code>上的<code class="fe kp kq kr ks b">.fit</code>来训练我上传到<code class="fe kp kq kr ks b">data_location</code>的数据(下面第6行)。</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="9811" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将模型部署到SageMaker主机需要对fitted模型进行部署调用(上面的第9行)。该调用接受实例计数、实例类型以及可选的序列化程序和反序列化程序函数。</p><p id="b029" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有了这个，我就有了一个训练有素的模型来获得实时预测。在下一节中，我将描述如何公开一个web可访问的API端点。</p><h2 id="d4a0" class="lj lk it bd ll lm ln dn lo lp lq dp lr kb ls lt lu kf lv lw lx kj ly lz ma mb bi translated">通过API访问模型</h2><p id="ab29" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">对于这个项目，我选择了<a class="ae ko" href="https://chalice.readthedocs.io/en/latest/quickstart.html#creating-your-project" rel="noopener ugc nofollow" target="_blank"> AWS Chalice </a>来使用Amazon API Gateway和AWS Lambda创建和部署应用程序。开箱即用，它提供:</p><blockquote class="mu mv mw"><p id="84b7" class="jq jr mh js b jt ju jv jw jx jy jz ka mx kc kd ke my kg kh ki mz kk kl km kn im bi translated">用于创建、部署和管理应用程序的命令行工具<br/>熟悉且易于使用的API，用于在python代码中声明视图<br/>自动生成IAM策略</p></blockquote><p id="2a27" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从命令行，我运行:</p><pre class="ku kv kw kx gt mk ks ml mm aw mn bi"><span id="e34f" class="lj lk it ks b gy mo mp l mq mr">$ chalice new-project sg_to_api</span></pre><p id="eaff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，我导航到那个文件夹并编辑了<code class="fe kp kq kr ks b">app.py</code>文件，它定义了视图和结果逻辑。我是这样配置我的API的:</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="ce08" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我获取一个传入的请求并解码它(第24–25行)。然后，我遍历数据来构建一个字典(第27–36行),将它输入到Pandas数据帧(第38–39行),这样我就可以将文本重新格式化为一个漂亮的CSV有效负载(第40行)。接下来，在第46–51行，我调用了<code class="fe kp kq kr ks b">sagemaker.invoke_endpoint()</code>，引用了本文前面部分中的端点名称。最后，结果被存储并作为HTML响应传递(第53–92行),这样我就可以在web浏览器上演示了。</p><p id="b840" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了部署这个应用程序，我导航到<code class="fe kp kq kr ks b">sg_to_api</code>目录并运行<code class="fe kp kq kr ks b">chalice deploy</code>:</p><pre class="ku kv kw kx gt mk ks ml mm aw mn bi"><span id="45a9" class="lj lk it ks b gy mo mp l mq mr">$ chalice deploy<br/>...<br/>Initiating first time deployment...<br/>https://xyz123.execute-api.us-east-1.amazonaws.com/api/</span></pre><p id="3465" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">就是这样。我使用API Gateway和Lambda启动并运行了一个API。</p><p id="d505" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">(我喜欢更新<code class="fe kp kq kr ks b">app.py</code>文件，然后通过再次运行<code class="fe kp kq kr ks b">chalice deploy</code>快速重新部署API变更。)</p><h2 id="fe6a" class="lj lk it bd ll lm ln dn lo lp lq dp lr kb ls lt lu kf lv lw lx kj ly lz ma mb bi translated">在野外测试我的API端点</h2><p id="3fe6" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">虽然我可以使用<code class="fe kp kq kr ks b">curl</code>来运行我的API，但我渴望向一些不习惯使用命令行的非技术朋友展示这一点。对于他们，我使用S3托管了一个静态网页，它接受文本输入并向我的端点发出POST请求，并从<code class="fe kp kq kr ks b">app.py</code>输出HTML响应。</p><p id="a236" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，我创建了一个S3桶:</p><pre class="ku kv kw kx gt mk ks ml mm aw mn bi"><span id="3424" class="lj lk it ks b gy mo mp l mq mr">$ aws s3api create-bucket --bucket sg-learner-test-1 --region us-east-1</span></pre><p id="fbc3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后我<a class="ae ko" href="https://docs.aws.amazon.com/AmazonS3/latest/dev/WebsiteHosting.html" rel="noopener ugc nofollow" target="_blank">配置我的桶</a>支持静态网站托管:</p><pre class="ku kv kw kx gt mk ks ml mm aw mn bi"><span id="c267" class="lj lk it ks b gy mo mp l mq mr">$ aws s3 website s3://sg-learner-test-1/ --index-document index.html --error-document error.html</span></pre><p id="28f3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，我创建了一个<code class="fe kp kq kr ks b">index.html</code>文件，并将其复制到我的具有全局访问权限的S3存储桶中:</p><pre class="ku kv kw kx gt mk ks ml mm aw mn bi"><span id="81aa" class="lj lk it ks b gy mo mp l mq mr">$ aws s3 cp index.html s3://sg-learner-test-1/index.html --grants read=uri=http://acs.amazonaws.com/groups/global/AllUsers</span></pre><p id="cc63" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了这个例子，我没有花任何时间美化网页——请忍受它的丑陋:</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="3102" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">输入代码后，我翻遍收件箱，将邮件粘贴到网页的“邮件正文”部分。如果我从来没有给发件人发过邮件，那么我把“冷联系”字段设为1，否则，我输入0。</p><p id="177d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">看到结果感觉像魔术一样！虽然我很乐意在这里提供端点，以便您可以自己测试模型，但是托管SageMaker端点每小时的费用是0.28美元(每月大约201美元)，这对于您想使用它的可能性来说有点高😉</p><p id="c069" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">相反，我为你记录了几个例子:</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi na"><img src="../Images/82159c871011f88ae049653904b5b120.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*mXw6aKQxGTUASDynYPZsgw.gif"/></div></div><p class="lf lg gj gh gi lh li bd b be z dk translated">3通过网络可访问的SDR电子邮件检测器进行演示检测</p></figure><p id="0952" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">(你在想为什么上面的动画里会有一个<em class="mh">火腿</em>？简单:<a class="ae ko" href="https://cwiki.apache.org/confluence/display/SPAMASSASSIN/Ham" rel="noopener ugc nofollow" target="_blank"> ham是一种标记“非垃圾邮件”的更快捷的方式</a></p><h2 id="8355" class="lj lk it bd ll lm ln dn lo lp lq dp lr kb ls lt lu kf lv lw lx kj ly lz ma mb bi translated">未来方向</h2><p id="d698" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">我冒险的下一步是跳过网页界面，从另一个应用程序调用我的API端点。很快会有更多的报道！</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><p id="46b8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让这个帖子成为可能，要感谢的人太多了。这里有几个人极大地指导了我的旅程:<a class="ni nj ep" href="https://medium.com/u/8a2f7df48b90?source=post_page-----68e238b7ecff--------------------------------" rel="noopener" target="_blank"> Quinn Lanners </a>(关于<a class="ae ko" rel="noopener" target="_blank" href="/deploying-a-scikit-learn-model-on-aws-using-sklearn-estimators-local-jupyter-notebooks-and-the-d94396589498">在AWS </a>上部署Scikit-Learn模型)；<a class="ni nj ep" href="https://medium.com/u/65a12f624874?source=post_page-----68e238b7ecff--------------------------------" rel="noopener" target="_blank">Leon Gerritsen</a>(关于<a class="ae ko" href="https://machine-learning-company.nl/deploy-machine-learning-model-rest-api-using-aws/" rel="noopener ugc nofollow" target="_blank">用Chalice </a>创建REST API)；<a class="ni nj ep" href="https://medium.com/u/d9b3a7de1139?source=post_page-----68e238b7ecff--------------------------------" rel="noopener" target="_blank">Patrick Michel Berger</a>(关于部署无服务器ML微服务)；<a class="ae ko" href="https://github.com/djarpin" rel="noopener ugc nofollow" target="_blank">David Arpin</a>、<a class="ae ko" href="https://github.com/tomfaulhaber" rel="noopener ugc nofollow" target="_blank"> Tom Faulhaber </a>等(关于<a class="ae ko" href="https://github.com/awslabs/amazon-sagemaker-examples/blob/master/advanced_functionality/scikit_bring_your_own/scikit_bring_your_own.ipynb" rel="noopener ugc nofollow" target="_blank">构建您的</a></p></div></div>    
</body>
</html>