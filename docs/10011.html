<html>
<head>
<title>20 Pandas Functions That Will Boost Your Data Analysis Process</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">20 个熊猫功能将加速您的数据分析过程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/20-pandas-functions-that-will-boost-your-data-analysis-process-f5dfdb2f9e05?source=collection_archive---------3-----------------------#2020-07-15">https://towardsdatascience.com/20-pandas-functions-that-will-boost-your-data-analysis-process-f5dfdb2f9e05?source=collection_archive---------3-----------------------#2020-07-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7d80" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">举例说明。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/aea74b5a35afa8860a221408a7e0ca6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*iRZ5TCE12NhArRWQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@hengfilms?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">恒电影</a>在<a class="ae ky" href="https://unsplash.com/s/photos/style?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="f324" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Pandas 是一个主要使用的 python 数据分析库。它提供了许多功能和方法来加快数据分析过程。使 pandas 如此普遍的是它的功能性、灵活性和简单的语法。</p><p id="5bf6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将举例说明熊猫的 20 个功能。其中一些很常见，我相信你以前也用过。其中一些对你来说可能是新的。但是，所有这些都会为您的数据分析过程增加价值。</p><p id="dc5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们开始吧。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="7f19" class="ma mb it lw b gy mc md l me mf">import numpy as np<br/>import pandas as pd</span></pre><h1 id="fc20" class="mg mb it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated"><strong class="ak"> 1。查询</strong></h1><p id="7873" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">我们有时需要根据条件过滤数据帧或应用掩码来获得某些值。过滤数据帧的一个简单方法是<strong class="lb iu">查询</strong>函数。让我们首先创建一个样本数据帧。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="3c80" class="ma mb it lw b gy mc md l me mf">values_1 = np.random.randint(10, size=10)<br/>values_2 = np.random.randint(10, size=10)<br/>years = np.arange(2010,2020)<br/>groups = ['A','A','B','A','B','B','C','A','C','C']</span><span id="24ad" class="ma mb it lw b gy nc md l me mf">df = pd.DataFrame({'group':groups, 'year':years, 'value_1':values_1, 'value_2':values_2})</span><span id="eedf" class="ma mb it lw b gy nc md l me mf">df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/0860ff4951cf92dc35653f3c3de7db11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/format:webp/1*bydL2Z_wFlSgZeaYEIiCng.png"/></div></figure><p id="8e0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用查询功能非常简单，只需编写过滤条件即可。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="17bb" class="ma mb it lw b gy mc md l me mf">df.query('value_1 &lt; value_2')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/431a347af98ec80628bff84de3b60f64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1178/format:webp/1*ia6VEIWa7lyiEJ9v1sS2cw.png"/></div></figure><h1 id="33e8" class="mg mb it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated"><strong class="ak"> 2。插入</strong></h1><p id="c34d" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">当我们想在数据帧中添加一个新列时，默认情况下它会被添加到末尾。然而，pandas 提供了使用<strong class="lb iu">插入</strong>功能在任意位置添加新列的选项。</p><p id="b84e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要通过传递一个索引作为第一个参数来指定位置。该值必须是整数。列索引从零开始，就像行索引一样。第二个参数是列名，第三个参数是包含值的对象，这些值可以是<strong class="lb iu">系列</strong>或类似于<strong class="lb iu">数组的</strong>对象。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="6d8a" class="ma mb it lw b gy mc md l me mf">#new column<br/>new_col = np.random.randn(10)</span><span id="2aa7" class="ma mb it lw b gy nc md l me mf">#insert the new column at position 2<br/>df.insert(2, 'new_col', new_col)</span><span id="71e2" class="ma mb it lw b gy nc md l me mf">df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/4256948d43192fe22f883f3300e9907f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/1*L1x48O3Qvn4WM1MC8yM9Ww.png"/></div></figure><h1 id="aac7" class="mg mb it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated"><strong class="ak"> 3。累计和</strong></h1><p id="68b5" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">数据框架包含 3 个不同组的一些年值。我们可能只对每年的值感兴趣，但在某些情况下，我们也需要一个累计和。Pandas 提供了一个简单易用的函数来计算累计和，即<strong class="lb iu"> cumsum </strong>。</p><p id="1755" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们只应用累计和，组(A，B，C)将被忽略。这种累积值在某些情况下可能没有用，因为我们无法区分不同的组。放心吧！这个问题有一个非常简单方便的解决方案。我们可以通过应用<strong class="lb iu">分组，然后再应用<strong class="lb iu">累加</strong>函数。</strong></p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="52e2" class="ma mb it lw b gy mc md l me mf">df['cumsum_2'] = df[['value_2','group']].groupby('group').cumsum()</span><span id="776f" class="ma mb it lw b gy nc md l me mf">df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/d0f4df2d3d33f90a0f20bebdecf46346.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*A4H5wv_MAW9v7KPeb1UeYQ.png"/></div></figure><h1 id="54df" class="mg mb it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated"><strong class="ak"> 4。样品</strong></h1><p id="0da8" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">样本方法允许您从<strong class="lb iu">系列</strong>或<strong class="lb iu">数据帧</strong>中随机选择数值。当我们想从分布中选择一个随机样本时，这是很有用的。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="a8cd" class="ma mb it lw b gy mc md l me mf">sample1 = df.sample(n=3)<br/>sample1</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/f67c0e9e9ce4f9af1af2dbe0042fff7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*5PEgF-QRYIAiesH_XUJqlA.png"/></div></figure><p id="c631" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们用 n 参数指定值的数量，但是我们也可以将一个比率传递给<strong class="lb iu"> frac </strong>参数。例如，0.5 将返回一半的行。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="86ff" class="ma mb it lw b gy mc md l me mf">sample2 = df.sample(frac=0.5)<br/>sample2</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/d95ccf67173150707bbc8fb41633ad41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*nyQkk9CP5rNtDrqrBe7FfQ.png"/></div></figure><p id="0dfb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了获得可再现的样本，我们可以使用<strong class="lb iu"> random_state </strong>参数。如果将整数值传递给 random_state，则每次运行代码时都会产生相同的样本。</p><h1 id="50bf" class="mg mb it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated"><strong class="ak"> 5。其中</strong></h1><p id="e55f" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">“Where”用于根据条件替换行或列中的值。默认的替换值是 NaN，但是我们也可以指定替换值。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="2056" class="ma mb it lw b gy mc md l me mf">df['new_col'].where(df['new_col'] &gt; 0 , 0)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/933fed03c0e7a649b81fe6e222753727.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/1*X8scAfh2vrbYMiWA6Owk2Q.png"/></div></figure><p id="a3b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">“where”的工作方式是选择符合条件的值，并用指定的值替换剩余的值。<strong class="lb iu">其中(df['new_col'] &gt; 0，0) </strong>选择“new_col”中所有大于 0 的值，其余值替换为 0。因此，where 也可以被认为是一个掩码操作。</p><p id="756f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">重要的一点是,<strong class="lb iu">这里的</strong>对于熊猫和 NumPy 来说并不完全一样。我们可以获得相同的结果，但语法略有不同。使用<strong class="lb iu"> DataFrame.where </strong>，选择符合条件的值<strong class="lb iu">作为</strong>，其他值替换为指定值。<strong class="lb iu"> Np.where </strong>还要求指定符合条件的值。以下两行返回相同的结果:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="7e08" class="ma mb it lw b gy mc md l me mf">df['new_col'].where(df['new_col'] &gt; 0 , 0)</span><span id="fc43" class="ma mb it lw b gy nc md l me mf">np.where(df['new_col'] &gt; 0, df['new_col'], 0)</span></pre><h1 id="bf77" class="mg mb it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated"><strong class="ak"> 6。Isin </strong></h1><p id="1a07" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">在处理数据帧时，我们经常使用过滤或选择方法。<strong class="lb iu"> Isin </strong>方法是一种高级过滤。例如，我们可以根据选择列表过滤值。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="c5ce" class="ma mb it lw b gy mc md l me mf">years = ['2010','2014','2017']<br/>df[df.year.isin(years)]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/46c84a32d9a16ac8f238c767602506bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/format:webp/1*-dWrHdmh2XzaEdjQbAbeCw.png"/></div></figure><h1 id="89c7" class="mg mb it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated"><strong class="ak"> 7。Loc 和 iloc </strong></h1><p id="96de" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">Loc 和 iloc 用于选择行和列。</p><ul class=""><li id="b448" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated">位置:按标签选择</li><li id="89ce" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">iloc:按职位选择</li></ul><p id="e978" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> loc </strong>用于通过标签选择数据。列的标签是列名。我们需要小心行标签。如果我们不指定任何特定的索引，pandas 默认创建整数索引。因此，行标签是从 0 开始向上的整数。与<strong class="lb iu"> iloc </strong>一起使用的行位置也是从 0 开始的整数。</p><p id="a02e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用 iloc 选择前 3 行和前 2 列:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/b182bd52c14af553bea81de352a6e008.png" data-original-src="https://miro.medium.com/v2/resize:fit:1174/format:webp/1*5LI3twwqIf97BuV8SFfKqw.png"/></div></figure><p id="ebe6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用 loc 选择前 3 行和前 2 列:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/c891cd2ed6c2a854f85221e42c3d331d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*WJEb6R0mx9-ZRqKZuOeauw.png"/></div></figure><p id="5ae0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注</strong>:当使用 loc 时，包括指数的上限，而使用 iloc 时不包括。</p><p id="b903" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">选择行“1”、“3”、“5”和列“年”和“值 _1”:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/39d471c95179b8e96d200dd23197171d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*VrMh2ql8KlzVMJwDuUXdaA.png"/></div></figure><h1 id="80e9" class="mg mb it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">8。Pct_change </h1><p id="0229" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">此函数用于通过系列中的值计算百分比变化。假设我们有一个包含[2，3，6]的系列。如果我们将 pct_change 应用于这个序列，返回的序列将是[NaN，0.5，1.0]。从第一个元素到第二个元素有 50%的增加，从第二个到第三个元素有 100%的增加。Pct_change 函数在比较时间序列中元素的变化百分比时非常有用。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="16f3" class="ma mb it lw b gy mc md l me mf">df.value_1.pct_change()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/25316a09ea2435e76fb832461e996549.png" data-original-src="https://miro.medium.com/v2/resize:fit:1170/format:webp/1*ceArmyx4omfsaSpPFcg-Tw.png"/></div></figure><h1 id="f533" class="mg mb it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">9。排名</h1><p id="d461" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">Rank 函数为值分配等级。假设我们有一个包含[1，7，5，3]的序列 s。分配给这些值的等级将是[1，4，3，2]。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="f05a" class="ma mb it lw b gy mc md l me mf">df['rank_1'] = df['value_1'].rank()<br/>df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/5f6f4e1410fa81059e1550c11deffd2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*GFczKQYXgJmOgrMRT6u9XQ.png"/></div></figure><h1 id="889d" class="mg mb it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">10。融化</h1><p id="5212" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">Melt 用于将宽数据帧转换为窄数据帧。我所说的宽是指具有大量列的数据帧。一些数据帧的结构是连续的测量值或变量用列来表示。在某些情况下，将这些列表示为行可能更适合我们的任务。考虑以下数据帧:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/8291904fed6311f91fc06cb71c7e8e89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1106/format:webp/1*UeLN7xFVsyLjg2S70AhO1Q.png"/></div></figure><p id="ae27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有三个不同的城市，在不同的日子进行测量。我们决定用一列中的行来表示这些日子。还会有一列显示测量结果。我们可以通过使用<strong class="lb iu">融化</strong>功能轻松实现这一点:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="2537" class="ma mb it lw b gy mc md l me mf">df_wide.melt(id_vars=['city'])</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/afc38b553b91fc683443bb580fa5a66f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/1*GCQze6VTEOSfTctoShPBRA.png"/></div></figure><p id="b281" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，变量和值列的名称是给定的。我们可以使用 melt 函数的参数<strong class="lb iu"> var_name </strong>和<strong class="lb iu"> value_name </strong>来指定新的列名。</p><h1 id="e9ae" class="mg mb it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated"><strong class="ak"> 11。爆炸</strong></h1><p id="410d" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">假设您的数据集在单个观测值(行)中包含一个要素的多个条目，但您希望在单独的行中对它们进行分析。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/595d525cf224b5ca1b3d1cc028640ecc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*DYRXyqPGyYm3SjCuOatnGQ.png"/></div></figure><p id="9128" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们希望在单独的行上看到第“1”天“c”的测量值，使用<strong class="lb iu"> explode 很容易做到这一点。</strong></p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="4993" class="ma mb it lw b gy mc md l me mf">df1.explode('measurement').reset_index(drop=True)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/8e67b9db54410e7169380ca440b1170f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1154/format:webp/1*hZalLwsblM6OM_3vzrjTFQ.png"/></div></figure><h1 id="40da" class="mg mb it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated"><strong class="ak"> 12。努尼克</strong></h1><p id="075a" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">Nunique 计算列或行中唯一条目的数量。它在分类特征中非常有用，尤其是在我们事先不知道类别数量的情况下。让我们看看我们的初始数据框架:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/8f12365a7ff33db7a8b2cb88853332ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*S1YjNHsJJ6J6XvgTFBvR2g.png"/></div></figure><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="8bab" class="ma mb it lw b gy mc md l me mf">df.year.nunique()<br/>10</span><span id="9d7a" class="ma mb it lw b gy nc md l me mf">df.group.nunique()<br/>3</span></pre><p id="a703" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以直接对数据帧应用唯一函数，并查看每列中唯一值的数量:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/6a33f4595f2d04ba47c24adb7b9c640f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1154/format:webp/1*oElI2Mxcpn0ypt-bbkQPvQ.png"/></div></figure><p id="594d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果<strong class="lb iu">轴</strong>参数设置为 1，nunique 返回每行中唯一值的数量。</p><h1 id="8204" class="mg mb it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated"><strong class="ak"> 13。查找</strong></h1><p id="269a" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">它可用于根据其他行、列对上的值在数据帧中查找值。这个函数最好通过一个例子来解释。假设我们有以下数据帧:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/1cee9b5fba92d3fca8cfb7d64868ebc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/0*QgXdb3coNz2CuKrD.png"/></div></figure><p id="7a9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于每一天，我们有 4 个人的测量值和一个包含这 4 个人的名字的列。我们希望创建一个新列，在“个人”列中显示个人的度量。因此，对于第一行，新列中的值将是 4(列“Alex”中的值)。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="a8aa" class="ma mb it lw b gy mc md l me mf">df['Person_point'] = df.lookup(df.index, df['Person'])<br/>df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/4cff8afd828aae54e65c13003e48f5f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/0*Tk-kafGf3Wua9g9K.png"/></div></figure><h1 id="f52c" class="mg mb it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated"><strong class="ak"> 14。推断 _ 对象</strong></h1><p id="c482" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">Pandas 支持广泛的数据类型，其中之一是<strong class="lb iu">对象</strong>。对象包含文本或混合(数字和非数字)值。但是，如果有不同的选项可用，则不建议使用对象数据类型。使用更具体的数据类型可以更快地执行某些操作。例如，我们更喜欢用整数或浮点数据类型来表示数值。</p><p id="7921" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> infer_objects </strong>尝试为对象列推断更好的数据类型。考虑以下数据帧:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/543f887b371d8a87dba4a32d66ebc2e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/format:webp/1*bZE1Qv2TwMWOpiRzpmanGw.png"/></div></figure><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="be43" class="ma mb it lw b gy mc md l me mf">df2.dtypes<br/>A    object <br/>B    object <br/>C    object <br/>D    object <br/>dtype: object</span></pre><p id="f5e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有的数据类型都是对象。让我们看看推断的数据类型是什么:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="6bbc" class="ma mb it lw b gy mc md l me mf">df2.infer_objects().dtypes</span><span id="6f92" class="ma mb it lw b gy nc md l me mf">A      int64 <br/>B    float64 <br/>C       bool <br/>D     object <br/>dtype: object</span></pre><p id="e1fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可能看起来微不足道，但是在有很多列的情况下绝对有用。</p><h1 id="ec9b" class="mg mb it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">15。内存使用量</h1><p id="3ebe" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">Memory_usage()以字节为单位返回每列使用的内存量。这在我们处理大型数据帧时尤其有用。考虑下面有一百万行的数据帧。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="01f7" class="ma mb it lw b gy mc md l me mf">df_large = pd.DataFrame({'A': np.random.randn(1000000),<br/>                    'B': np.random.randint(100, size=1000000)})</span><span id="65d9" class="ma mb it lw b gy nc md l me mf">df_large.shape<br/>(1000000, 2)</span></pre><p id="a009" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以及每列的内存使用量(以字节为单位):</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="5b36" class="ma mb it lw b gy mc md l me mf">df_large.memory_usage()<br/>Index        128 <br/>A        8000000 <br/>B        8000000 <br/>dtype: int64</span></pre><p id="281d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">整个数据帧的内存使用量，以兆字节为单位:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="669c" class="ma mb it lw b gy mc md l me mf">df_large.memory_usage().sum() / (1024**2) #converting to megabytes</span><span id="a391" class="ma mb it lw b gy nc md l me mf">15.2589111328125</span></pre><h1 id="3a6b" class="mg mb it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated"><strong class="ak"> 16。描述</strong></h1><p id="a87e" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">Describe 函数计算数字列的基本统计数据，包括计数、平均值、标准偏差、最小值和最大值、中值、第一个和第三个四分位数。因此，它提供了数据帧的统计摘要。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/86bdc8471a9008298e0bd7ac3da1107f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1370/format:webp/1*AIOqNNdI9O53gHx-IaCBoA.png"/></div></figure><h1 id="10bd" class="mg mb it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated"><strong class="ak"> 17。合并</strong></h1><p id="7076" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">Merge()根据共享列中的值组合数据帧。考虑以下两个数据帧。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/79b833b920ccf701945338eb10956a48.png" data-original-src="https://miro.medium.com/v2/resize:fit:612/format:webp/0*5eFKveWR0l1O-tHK.png"/></div></figure><p id="6f5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以基于列中的共享值来合并它们。设置合并条件的参数是“<strong class="lb iu"> on </strong>参数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi om"><img src="../Images/058a72a324fcb7ce37989bac9cc28b97.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/0*D-U9lDrr3s-Zs51f.png"/></div></figure><p id="6521" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基于 column_a 中的公共值合并 df1 和 df2。merge 函数的<strong class="lb iu"> how </strong>参数允许以不同方式组合数据帧。how 的可能值为“内部”、“外部”、“左侧”、“右侧”。</p><ul class=""><li id="a124" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated">inner:只有在<strong class="lb iu">对</strong>参数指定的列中具有相同值的行(默认值为<strong class="lb iu"> how </strong>参数)</li><li id="59b9" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">外部:所有行</li><li id="5122" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">左侧:左侧数据帧中的所有行</li><li id="a19a" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">右侧:右侧数据帧中的所有行</li></ul><h1 id="abd8" class="mg mb it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">18。Select_dtypes </h1><p id="f832" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">Select_dtypes 函数根据对数据类型设置的条件返回数据帧列的子集。它允许使用<strong class="lb iu"> include </strong>和<strong class="lb iu"> exlude </strong>参数来包含或排除某些数据类型。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="c063" class="ma mb it lw b gy mc md l me mf">df.select_dtypes(include='int64')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/517814051587623c8cbcda8a795e0b3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1138/format:webp/1*WGOzYTalUlVcVxwbWX8IVA.png"/></div></figure><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="6edf" class="ma mb it lw b gy mc md l me mf">df.select_dtypes(exclude='int64')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/e79b71fc186e14422a2954d2b4223be7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*JQHlpi6JhvyuZ-i7RnHgdw.png"/></div></figure><h1 id="fe34" class="mg mb it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">19。替换</h1><p id="75b3" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">顾名思义，它允许替换数据帧中的值。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="d956" class="ma mb it lw b gy mc md l me mf">df.replace('A', 'A_1')</span></pre><p id="ee54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个参数是要替换的值，第二个参数是新值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/fc00407603f747569990eecc5fe6729a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*AiKXVAPsadSEfL9CrZRvag.png"/></div></figure><p id="022b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以同时传入一个字典进行多次替换。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="8767" class="ma mb it lw b gy mc md l me mf">df.replace({'A':'A_1', 'B':'B_1'})</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/3a635086cf2b76b43a1b0362ba98383c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/1*0ePSl9uY5kRVCXTkfR0Hrw.png"/></div></figure><h1 id="cde5" class="mg mb it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">20。应用地图</h1><p id="fc9b" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">Applymap 函数用于将函数应用于数据帧的元素。请注意，如果操作的矢量化版本可用，它应该优先于 applymap。例如，如果我们想将每个元素乘以一个数，我们不需要也不应该使用 applymap 函数。在这种情况下，简单的矢量化运算(例如 df * 4)要快得多。</p><p id="b127" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，在某些情况下，我们可能没有矢量化运算的选项。例如，我们可以使用熊猫数据帧的<strong class="lb iu"> Style </strong>属性来改变数据帧的样式。以下函数将负值的颜色更改为红色。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="c095" class="ma mb it lw b gy mc md l me mf">def color_negative_values(val):<br/>   color = 'red' if val &lt; 0 else 'black'<br/>   return 'color: %s' % color</span></pre><p id="c428" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要使用 applymap 函数将该函数应用于数据帧。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="4a7e" class="ma mb it lw b gy mc md l me mf">df3.style.applymap(color_negative_values)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/f77448fef764aaf57f2555539a989cbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*Wf-1GV5fwy_gCwByn-3Yug.png"/></div></figure></div><div class="ab cl os ot hx ou" role="separator"><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox"/></div><div class="im in io ip iq"><p id="c36a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读。如果您有任何反馈，请告诉我。</p></div></div>    
</body>
</html>