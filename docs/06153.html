<html>
<head>
<title>data.table: R’s Best Data Object</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">data.table: R的最佳数据对象</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/data-table-rs-best-data-object-c95b7d5f0104?source=collection_archive---------57-----------------------#2020-05-18">https://towardsdatascience.com/data-table-rs-best-data-object-c95b7d5f0104?source=collection_archive---------57-----------------------#2020-05-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="cd32" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">data.frame太2016了</h2></div><p id="b344" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">data.table是我更喜欢用R而不是Python工作的主要原因。尽管R是一种众所周知的慢语言，但data.table通常比Python的pandas ( <a class="ae lb" href="https://h2oai.github.io/db-benchmark/" rel="noopener ugc nofollow" target="_blank"> benchmark </a>)运行得更快，只要R能够处理如此大规模的数据，它甚至可以与Spark一较高下。更好的是，data.table非常简洁，只需要一点点输入就可以支持像窗口函数这样的复杂操作。</p><p id="a6fe" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我相信<strong class="kh ir"> data.table是最重要的R包</strong>。任何形式的争论最好使用data.table。它是我们需要的数据超级英雄。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lc"><img src="../Images/05bb4dfb3e38e74970c53df30cfca240.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bGEqgZYgnlA_C-dt5PnrwQ.jpeg"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated"><a class="ae lb" href="https://www.needpix.com/photo/download/271646/superhero-girl-speed-runner-running-lights-space-cyber-suit" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="dde2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除了函数不接受data.table .我个人不喜欢tidyverse(抱歉！)因为它使用data.frame和tibble，因此运行起来比较慢——需要两倍的打字量。(最近Wickham发布了<a class="ae lb" href="https://www.tidyverse.org/blog/2019/11/dtplyr-1-0-0/" rel="noopener ugc nofollow" target="_blank"> dtplyr </a>，它将dplyr代码翻译成data.table操作。你得到dplyr语法和数据表速度，如果那是你的事情。)</p><p id="35fd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文将指导您如何使用data.table，以及让您更快更轻松地处理数据的提示和技巧。</p><h1 id="6f96" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">构建数据表</h1><p id="ac30" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">除了使用read.csv()之类的方法，您还可以使用fread()将数据直接加载到data.table中。一旦有了大小适中的数据，就可以看到fread()比read.csv()快多少。</p><p id="1b12" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您也可以使用data.table()函数构造一个，就像您对data.frame()所做的那样。请注意，字符串不再自动转换为因子。</p><p id="f9cd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您已经有一个data.frame，data.table()函数将转换它。</p><p id="9d4d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您的数据被分割成多个文件，您可以将每个文件加载到它自己的data.table中，存储到一个列表中，然后使用rbindlist()。这类似于do.call("rbind "，……)，但效率更高。</p><pre class="ld le lf lg gt mp mq mr ms aw mt bi"><span id="582e" class="mu lt iq mq b gy mv mw l mx my">library(data.table)</span><span id="50d0" class="mu lt iq mq b gy mz mw l mx my">dt &lt;- fread('mydata.csv')<br/>dt &lt;- data.table(x = 1:10, y = 1:10)<br/>dt &lt;- data.table(mydataframe)</span><span id="af19" class="mu lt iq mq b gy mz mw l mx my">templist &lt;- list()<br/>for(i in 1:length(filenames)){<br/>  templist[[i]] &lt;- fread(filenames[i])<br/>}<br/>dt &lt;- rbindlist(templist)</span></pre><h1 id="e0de" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">类似SQL的语法</h1><p id="c60f" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">SQL是事实上的数据语言(还记得NoSQL被说成“不仅仅是SQL”吗？)并且应该为大多数数据专业人员所熟悉。如果能写SQL，就能写数据，表语法:</p><pre class="ld le lf lg gt mp mq mr ms aw mt bi"><span id="0b1d" class="mu lt iq mq b gy mv mw l mx my">FROM[WHERE, SELECT, GROUP BY][ORDER BY]</span></pre><p id="9e4c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设您想要运行以下查询:</p><pre class="ld le lf lg gt mp mq mr ms aw mt bi"><span id="2c0a" class="mu lt iq mq b gy mv mw l mx my">SELECT <br/>  col1, <br/>  count(1) as num_obs, <br/>  sum(col2) AS group_sum<br/>FROM mydt<br/>WHERE col3 &gt; 0<br/>GROUP BY col1<br/>ORDER BY 2 DESC</span></pre><p id="727b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在data.table中，这变成了</p><pre class="ld le lf lg gt mp mq mr ms aw mt bi"><span id="e7b2" class="mu lt iq mq b gy mv mw l mx my">mydt[<br/>  col3 &gt; 0, <br/>  .(num_obs = .N,<br/>    group_sum = sum(col2)), <br/>  by = col1<br/>][<br/>  order(-num_obs)<br/>]</span></pre><p id="8504" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就是这样！最少的输入，不需要管道传输大量的函数。这确实需要一些时间来适应，但一旦你掌握了窍门，这就很有意义了。</p><p id="e008" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">的。()是list()的简称。在SELECT语句中使用它将返回一个data.table(将在下一节中解释)。</p><p id="adec" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了data.table，您在引用字段时不再需要重复键入表名。使用data.frame您需要键入</p><pre class="ld le lf lg gt mp mq mr ms aw mt bi"><span id="c36f" class="mu lt iq mq b gy mv mw l mx my">mydt[mydt$col3 &gt; 0]</span></pre><p id="503f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是data.table知道方括号内的内容可能是指它的列，所以您可以输入</p><pre class="ld le lf lg gt mp mq mr ms aw mt bi"><span id="d0ae" class="mu lt iq mq b gy mv mw l mx my">mydt[col3 &gt; 0]</span></pre><p id="aace" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这看起来并不多，但当您键入数百行代码时，这是生活质量的巨大提高。</p><h1 id="bf00" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">快速转化和变异</h1><p id="3b59" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">SELECT语句采用两种形式之一:</p><ul class=""><li id="1bad" class="na nb iq kh b ki kj kl km ko nc ks nd kw ne la nf ng nh ni bi translated">。()返回一个新的数据表</li><li id="108e" class="na nb iq kh b ki nj kl nk ko nl ks nm kw nn la nf ng nh ni bi translated">:=就地修改数据表</li></ul><p id="394e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">来自的输出。除非创建新的对象，否则()不会存储在任何位置。对于示例任务，data.table X有两列:grp(分组变量)和val(数值)。</p><p id="e820" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">任务1:创建所有值的平均值的标量。</p><pre class="ld le lf lg gt mp mq mr ms aw mt bi"><span id="7c06" class="mu lt iq mq b gy mv mw l mx my">X[,mean(val)]</span></pre><p id="0a91" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">任务2:创建一个包含组均值的新data.table X_agg。</p><pre class="ld le lf lg gt mp mq mr ms aw mt bi"><span id="379a" class="mu lt iq mq b gy mv mw l mx my">X_agg &lt;- X[,.(avg = mean(val)), by = grp]</span></pre><p id="7f43" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">任务3:在X中创建一个包含组平均值的新列。</p><pre class="ld le lf lg gt mp mq mr ms aw mt bi"><span id="65ef" class="mu lt iq mq b gy mv mw l mx my">X[,avg := mean(val), by = grp]</span></pre><p id="9068" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">任务4:在X中创建新列，说明观察值是否大于组平均值。</p><pre class="ld le lf lg gt mp mq mr ms aw mt bi"><span id="daba" class="mu lt iq mq b gy mv mw l mx my">X[,is_greater := val &gt; mean(val), by = grp]</span></pre><p id="1978" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">任务5:在X中为组avg和stdev创建两个新列。</p><pre class="ld le lf lg gt mp mq mr ms aw mt bi"><span id="9a62" class="mu lt iq mq b gy mv mw l mx my">X[,<br/>  ':='(avg = mean(val), stdev = sd(val)),<br/>  by = grp<br/>]</span></pre><p id="4988" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有时，您有许多列需要按两个字段分组，grp1和grp2。您可以:</p><pre class="ld le lf lg gt mp mq mr ms aw mt bi"><span id="f21a" class="mu lt iq mq b gy mv mw l mx my">X_agg &lt;- X[,lapply(.SD, mean), by = .(grp1, grp2)]</span></pre><p id="629d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">的。SD是除用于分组的列之外的所有列的简写。注意所有这些任务的代码有多短！</p><h1 id="057e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">快速搜索和加入</h1><p id="16ef" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">与data.frame不同，data.table支持使用setkey()函数进行索引:</p><pre class="ld le lf lg gt mp mq mr ms aw mt bi"><span id="85a0" class="mu lt iq mq b gy mv mw l mx my">X &lt;- data.table(<br/>  grp = sample(1:10),<br/>  xval = rnorm(10)<br/>)<br/>Y &lt;- data.table(<br/>  grp = sample(rep(1:10, 2)),<br/>  yval = rnorm(20)<br/>)<br/>setkey(X, grp)<br/>setkey(Y, grp)<br/>X[Y]</span></pre><p id="b0c5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后一行X[Y]使用指定的索引合并两个表，比使用base merge()要快得多。当您希望查找特定值时，索引还使data.table能够使用二分搜索法。</p><h1 id="8740" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">窗口功能</h1><p id="7b2e" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">在SQL中，您可以使用一些有趣的累积和，例如</p><pre class="ld le lf lg gt mp mq mr ms aw mt bi"><span id="3a0f" class="mu lt iq mq b gy mv mw l mx my">SELECT <br/>  grp, <br/>  obs_date, <br/>  sum(val) over (<br/>    partition by grp <br/>    order by obs_date <br/>    rows unbounded preceding<br/>  ) as cumulative<br/>FROM mydt</span></pre><p id="25fc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以在data.table中快速完成同样的操作:</p><pre class="ld le lf lg gt mp mq mr ms aw mt bi"><span id="4ae7" class="mu lt iq mq b gy mv mw l mx my">mydt[<br/>  order(obs_date),<br/>  .(obs_date,<br/>    cumulative = cumsum(val)),<br/>  by = grp<br/>][<br/>  order(obs_date)<br/>]</span></pre><p id="cb57" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">data.table甚至自带了shift()和frank()等快速窗口函数——后者用于快速排序。</p><h1 id="c32c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">最后</h1><p id="e7c4" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">如果您还没有在R工作中使用过data.table，我强烈建议您尝试并学习它。你会回过头来想，如果没有它，你以前是怎么工作的。它速度更快，内存效率更高，而且比r中的其他任何东西都更简洁。</p><p id="000e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与纯粹使用SQL相比，一个主要的优势是您可以保持中间表组织良好，而不是创建视图。在Rstudio中，可以使用环境窗口来跟踪所有对象。</p></div></div>    
</body>
</html>