<html>
<head>
<title>Minimal Pandas Subset for Data Scientists on GPU</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GPU 上数据科学家的最小熊猫子集</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/minimal-pandas-subset-for-data-scientist-on-gpu-d9a6c7759c7f?source=collection_archive---------15-----------------------#2020-01-14">https://towardsdatascience.com/minimal-pandas-subset-for-data-scientist-on-gpu-d9a6c7759c7f?source=collection_archive---------15-----------------------#2020-01-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/88cdaf2ef03cb08e99cc56ce84306dc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JzbLsax95Aadhg8I4Kayqw.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">所有这些小而强壮的熊猫，<a class="ae jg" href="https://m.media-amazon.com/images/M/MV5BMTc4NDE0MTk3N15BMl5BanBnXkFtZTgwMDQwODM1NzE@._V1_QL50_SY1000_SX675_AL_.jpg" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><div class=""/><div class=""><h2 id="9430" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">使用 GPU 进行数据预处理</h2></div><p id="5cb3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于 pandas 来说，数据操作轻而易举，它已经成为 it 的一个标准，许多并行化库，如 Rapids 和 Dask，都是按照 Pandas 的语法创建的。</p><p id="b5b0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有时，我会写一些我经常使用的熊猫功能的<a class="ae jg" rel="noopener" target="_blank" href="/minimal-pandas-subset-for-data-scientists-6355059629ae">子集</a>。<strong class="la jk"> <em class="lu">在这篇文章中，我将讨论在 GPU 上使用 cuDF 处理 Python 中的大多数数据操作案例。</em> </strong></p><p id="0770" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通篇都是一些零星的建议。</p><p id="6d87" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> <em class="lu"> PS: </em> </strong>为了进行基准测试，下面所有的实验都是在一台 128 GB RAM 的机器和一台 24 GB RAM 的泰坦 RTX GPU 上完成的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1700" class="mc md jj bd me mf mg mh mi mj mk ml mm kp mn kq mo ks mp kt mq kv mr kw ms mt bi translated">什么是 Rapids CuDF，为什么要使用它？</h1><blockquote class="mu mv mw"><p id="d53e" class="ky kz lu la b lb lc kk ld le lf kn lg mx li lj lk my lm ln lo mz lq lr ls lt im bi translated">cuDF 基于<a class="ae jg" href="http://arrow.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache Arrow </a>列内存格式构建，是一个 GPU 数据帧库，用于加载、连接、聚合、过滤和其他操作数据。</p></blockquote><p id="e645" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">简单地说，Rapids CuDF 是一个旨在为 GPU 带来 pandas 功能的库。除了 CuDF 之外，Rapids 还提供了对 cuML 和 cuGraph 的访问，它们分别用于在 GPU 上处理机器学习算法和<a class="ae jg" rel="noopener" target="_blank" href="/4-graph-algorithms-on-steroids-for-data-scientists-with-cugraph-43d784de8d0e">图形。</a></p><p id="ee3c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这有什么好处呢？</p><p id="7d71" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">典型的 GPU 有超过 2000 个 CUDA 核心。当使用 Dask 或多处理进行并行化时，Pandas 可以使用您的机器拥有的 8 个核心或 16 个 CPU 核心。现在，这些 CPU 内核的能力各不相同，但 CUDA 内核可以快速完成简单的计算，因此可以为我们提供显著的加速。</p><p id="6700" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我的 GPU 泰坦 RTX 有大约 4600 个核心。这意味着我应该能够使用 GPU 并行化我的计算。</p><p id="c9c3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但问题是，编写运行 GPU 的代码很难。而 Rapids CuDF 解决了这个问题。</p><p id="9511" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们进一步讨论之前，这里有一个简单的例子来说明 cuDF 如何帮助您。在这里，我试图得到我的随机数据帧中所有列的平均值，该数据帧有 1 亿行和 5 列。</p><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi na"><img src="../Images/fee66f62bdd3b937ba47126c59a5c12d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P0Pfc8Vr8t1CJw8LOk-dZA.png"/></div></div></figure><p id="7c15" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> <em class="lu">使用 cuDF 加速了大约 350 倍！！！代码基本保持不变。请记住，我使用的是 128 GB 内存的系统。</em>T19】</strong></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c751" class="mc md jj bd me mf mg mh mi mj mk ml mm kp mn kq mo ks mp kt mq kv mr kw ms mt bi translated">安装— RAPIDS cuDF</h1><p id="5215" class="pw-post-body-paragraph ky kz jj la b lb nf kk ld le ng kn lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">所以现在我们确信 cuDF 是有益的，安装 RAPIDS 最简单的方法就是去<a class="ae jg" href="https://rapids.ai/start.html" rel="noopener ugc nofollow" target="_blank">站点</a>并使用发布选择器工具检查你需要什么。</p><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nk"><img src="../Images/3885416153fba4a2d3eb516f85cdd551.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LL5OiZJki3GSs1qpdvC78A.png"/></div></div></figure><p id="225d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对我来说，安装命令是:</p><pre class="nb nc nd ne gt nl nm nn no aw np bi"><span id="dfae" class="nq md jj nm b gy nr ns l nt nu">conda install -c rapidsai -c nvidia -c conda-forge -c defaults rapids=0.11 python=3.7 cudatoolkit=10.1</span></pre><p id="85f9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于启动或学习，您也可以从 Google Colab 笔记本开始，它预装了所需的 RAPIDS 环境。</p><p id="d492" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本帖中，我将使用<a class="ae jg" href="https://www.kaggle.com/sobhanmoosavi/us-accidents" rel="noopener ugc nofollow" target="_blank">美国事故数据集</a>来展示 CuDF 数据框架的能力。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8a69" class="mc md jj bd me mf mg mh mi mj mk ml mm kp mn kq mo ks mp kt mq kv mr kw ms mt bi translated">使用 CuDF 读取数据</h1><p id="e0a4" class="pw-post-body-paragraph ky kz jj la b lb nf kk ld le ng kn lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">我们做的第一件事是读取数据源。我们可以从本地文件系统读取 cudf 中的数据</p><pre class="nb nc nd ne gt nl nm nn no aw np bi"><span id="1091" class="nq md jj nm b gy nr ns l nt nu">import cudf<br/>gdf = cudf.read_csv('US_Accidents_May19.csv')</span></pre><p id="fe94" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我使用<code class="fe nv nw nx nm b">pd.read_csv</code>功能读取时，这个命令花费了大约 1 秒，而不是 13 秒</p><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ny"><img src="../Images/efc279a4d00e8d36a8f29af94ef493ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jeb-WQdcNs2v7L9hzNORpQ.png"/></div></div></figure><p id="4f9d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们也可以使用以下方式从 pandas 数据帧中读取数据:</p><pre class="nb nc nd ne gt nl nm nn no aw np bi"><span id="4ce5" class="nq md jj nm b gy nr ns l nt nu">pdf = pd.read_csv('US_Accidents_May19.csv')<br/>gdf = cudf.DataFrame.from_pandas(pdf)</span></pre><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nz"><img src="../Images/a444c68b3cfe711db221aae712e42b37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pn-ktKfU4MWbpSSWl1Q6dw.png"/></div></div></figure><p id="5a2f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，我们可以将 cuDF 数据框架转换回 Pandas 数据框架，以便在需要时利用更成熟的 Pandas 生态系统。</p><pre class="nb nc nd ne gt nl nm nn no aw np bi"><span id="0b51" class="nq md jj nm b gy nr ns l nt nu">pdf = gdf.to_pandas()</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1a95" class="mc md jj bd me mf mg mh mi mj mk ml mm kp mn kq mo ks mp kt mq kv mr kw ms mt bi translated">数据快照</h1><p id="e536" class="pw-post-body-paragraph ky kz jj la b lb nf kk ld le ng kn lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">看到一些数据总是有用的。首先，让我们尝试简单的 Head 和 Tail 命令:</p><p id="4f5e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以使用简单的<code class="fe nv nw nx nm b">head</code>和<code class="fe nv nw nx nm b">tail</code>命令来指定行数。</p><pre class="nb nc nd ne gt nl nm nn no aw np bi"><span id="828b" class="nq md jj nm b gy nr ns l nt nu"># top 5 rows<br/>gdf.head()</span><span id="f81c" class="nq md jj nm b gy oa ns l nt nu"># top 50 rows<br/>gdf.head(50)</span><span id="8efc" class="nq md jj nm b gy oa ns l nt nu"># last 5 rows<br/>gdf.tail()</span><span id="ad12" class="nq md jj nm b gy oa ns l nt nu"># last 50 rows<br/>gdf.tail(50)</span></pre><p id="1d49" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您还可以使用以下命令查看简单的数据帧统计信息。</p><pre class="nb nc nd ne gt nl nm nn no aw np bi"><span id="c701" class="nq md jj nm b gy nr ns l nt nu"># To get statistics of numerical columns<br/>gdf.describe()</span></pre><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ob"><img src="../Images/2e86642ebefea939085c3185cf646275.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CceGSUJeLD9U9uWNeQr1Vw.png"/></div></div></figure><p id="4393" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您也可以使用普通函数，如:</p><pre class="nb nc nd ne gt nl nm nn no aw np bi"><span id="163f" class="nq md jj nm b gy nr ns l nt nu">print(<!-- -->gdf['TMC'].mean()<!-- -->)</span><span id="9049" class="nq md jj nm b gy oa ns l nt nu"># no of rows in dataframe<br/>print(len(gdf))</span><span id="2a06" class="nq md jj nm b gy oa ns l nt nu"># Shape of Dataframe<br/>print(gdf.shape)</span><span id="5a28" class="nq md jj nm b gy oa ns l nt nu">---------------------------------------------------------------<br/>207.35274265463238<br/>2243939<br/>(2243939, 49)</span></pre><p id="f539" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> <em class="lu">推荐:</em> </strong>一般用 Jupyter 笔记本工作，<strong class="la jk"> <em class="lu">我特别注意让笔记本的前几个单元格包含这些数据的快照</em> </strong>。这有助于我随时看到数据的结构。如果我不遵循这个实践，我会发现我在代码中重复了很多次<code class="fe nv nw nx nm b">.head()</code>命令。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="eae2" class="mc md jj bd me mf mg mh mi mj mk ml mm kp mn kq mo ks mp kt mq kv mr kw ms mt bi translated">处理数据框架中的列</h1><h2 id="e76a" class="nq md jj bd me oc od dn mi oe of dp mm lh og oh mo ll oi oj mq lp ok ol ms om bi translated">a.选择列</h2><p id="e3ac" class="pw-post-body-paragraph ky kz jj la b lb nf kk ld le ng kn lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">与熊猫一样，CuDF 允许您以两种方式选择列。像<code class="fe nv nw nx nm b">df.Title</code>一样使用点运算符，像<code class="fe nv nw nx nm b">df['Title']</code>一样使用方括号</p><p id="9bf1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我更喜欢第二个版本。为什么？</p><p id="a98c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从长远来看，使用方括号版本会更好，这有几个原因。</p><ul class=""><li id="fd6f" class="on oo jj la b lb lc le lf lh op ll oq lp or lt os ot ou ov bi translated">如果您的列名包含空格，那么点版本将不起作用。例如，<code class="fe nv nw nx nm b">df.Revenue (Millions)</code>不会工作，而<code class="fe nv nw nx nm b">df['Revenue (Millions)]’</code>会。</li><li id="a0aa" class="on oo jj la b lb ow le ox lh oy ll oz lp pa lt os ot ou ov bi translated">如果您的列名是<code class="fe nv nw nx nm b">count</code>或<code class="fe nv nw nx nm b">mean</code>或任何预定义的函数，它也不会工作。</li><li id="4158" class="on oo jj la b lb ow le ox lh oy ll oz lp pa lt os ot ou ov bi translated">有时您可能需要在列名上创建一个 for 循环，其中列名可能在变量中。在这种情况下，点符号将不起作用。例如，这是可行的:</li></ul><pre class="nb nc nd ne gt nl nm nn no aw np bi"><span id="d8e9" class="nq md jj nm b gy nr ns l nt nu">colname = 'height'<br/>df[colname]</span></pre><p id="f4d5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">虽然这不会:</p><pre class="nb nc nd ne gt nl nm nn no aw np bi"><span id="58fd" class="nq md jj nm b gy nr ns l nt nu">colname = 'height'<br/>df.colname</span></pre><p id="f9d5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">相信我。省几个字不值得。</p><p id="dc74" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> <em class="lu">建议:停止使用点运算符</em> </strong>。</p><h2 id="b998" class="nq md jj bd me oc od dn mi oe of dp mm lh og oh mo ll oi oj mq lp ok ol ms om bi translated">b.获取列表中的列名</h2><p id="8b0b" class="pw-post-body-paragraph ky kz jj la b lb nf kk ld le ng kn lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">它也像熊猫一样工作。</p><pre class="nb nc nd ne gt nl nm nn no aw np bi"><span id="3fd0" class="nq md jj nm b gy nr ns l nt nu">columnnames = cuda_df.columns</span></pre><h2 id="0e8f" class="nq md jj bd me oc od dn mi oe of dp mm lh og oh mo ll oi oj mq lp ok ol ms om bi translated">c.指定用户定义的列名:</h2><p id="44c4" class="pw-post-body-paragraph ky kz jj la b lb nf kk ld le ng kn lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">有时您想根据自己的喜好更改列名。我不喜欢我的列名中有空格或括号，所以我这样更改它们。</p><figure class="nb nc nd ne gt iv"><div class="bz fp l di"><div class="pb pc l"/></div></figure><h2 id="756a" class="nq md jj bd me oc od dn mi oe of dp mm lh og oh mo ll oi oj mq lp ok ol ms om bi translated">d.设置特定列的子集:</h2><p id="2090" class="pw-post-body-paragraph ky kz jj la b lb nf kk ld le ng kn lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">有时，您只需要处理数据帧中的特定列。例如，分离数字列和分类列，或者移除不必要的列。假设在我们的例子中，我们只需要几列</p><pre class="nb nc nd ne gt nl nm nn no aw np bi"><span id="dfb3" class="nq md jj nm b gy nr ns l nt nu">gdf = gdf[['ID', 'Source', 'TMC', 'Severity', 'Start_Time', 'End_Time','Start_Lat', 'Start_Lng', 'End_Lat', 'End_Lng']]</span></pre><h2 id="ca7a" class="nq md jj bd me oc od dn mi oe of dp mm lh og oh mo ll oi oj mq lp ok ol ms om bi translated">e.查看列类型:</h2><p id="4891" class="pw-post-body-paragraph ky kz jj la b lb nf kk ld le ng kn lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">调试时非常有用。如果您的代码抛出一个错误，说您不能添加一个<code class="fe nv nw nx nm b">str</code>和<code class="fe nv nw nx nm b">int</code>，您将希望运行这个命令。</p><pre class="nb nc nd ne gt nl nm nn no aw np bi"><span id="09f1" class="nq md jj nm b gy nr ns l nt nu">gdf.dtypes</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2602" class="mc md jj bd me mf mg mh mi mj mk ml mm kp mn kq mo ks mp kt mq kv mr kw ms mt bi translated">在 CuDF 中应用和 Lambda</h1><p id="aa1c" class="pw-post-body-paragraph ky kz jj la b lb nf kk ld le ng kn lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated"><code class="fe nv nw nx nm b">apply</code>和<code class="fe nv nw nx nm b">lambda</code>是我在熊猫身上学到的最好的东西。每当我为新的列或过滤器构建复杂的逻辑时遇到困难，我就会使用<code class="fe nv nw nx nm b">apply</code>和<code class="fe nv nw nx nm b">lambda</code>。让我们看看是否可以在 CuDF 中使用它们。</p><h2 id="18be" class="nq md jj bd me oc od dn mi oe of dp mm lh og oh mo ll oi oj mq lp ok ol ms om bi translated">a.创建列</h2><p id="8b2f" class="pw-post-body-paragraph ky kz jj la b lb nf kk ld le ng kn lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">您可以通过多种方式创建新列。</p><p id="bc3f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你想要一个列是列的和或差，你可以使用简单的基本算法。</p><pre class="nb nc nd ne gt nl nm nn no aw np bi"><span id="6c9e" class="nq md jj nm b gy nr ns l nt nu">gdf['Somecol'] = (gdf['TMC'] + gdf['Severity']/10)/2</span></pre><p id="70d5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您也可以使用<code class="fe nv nw nx nm b">applymap</code>对系列进行简单应用:</p><pre class="nb nc nd ne gt nl nm nn no aw np bi"><span id="4198" class="nq md jj nm b gy nr ns l nt nu">def somefunc(x):<br/>    return x+2<br/>gdf['Somecol'] = gdf['TMC'].applymap(somefunc)</span></pre><p id="cd64" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是有时我们可能需要围绕使用多个列创建新列来构建复杂的逻辑。</p><p id="f389" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">举个例子，假设我们要根据 Lats 和 Longs 计算哈弗线距离。</p><p id="37e0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> <em class="lu">我们怎么做呢？</em>T13】</strong></p><p id="d8d9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每当我遇到这样的问题，我就使用<code class="fe nv nw nx nm b">apply/lambda</code>。让我首先向你展示我将如何用熊猫来做这件事。这里的许多代码摘自这篇<a class="ae jg" href="https://medium.com/rapids-ai/user-defined-functions-in-rapids-cudf-2d7c3fc2728d" rel="noopener">文章</a>。</p><figure class="nb nc nd ne gt iv"><div class="bz fp l di"><div class="pb pc l"/></div></figure><p id="64aa" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了在 CuDF 中做同样的事情，我们必须使用<code class="fe nv nw nx nm b">apply_rows</code>对多行应用一个函数。</p><figure class="nb nc nd ne gt iv"><div class="bz fp l di"><div class="pb pc l"/></div></figure><p id="3219" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">看看哈弗辛距离函数的结构是如何变化的，以及我们如何用不同的方式来称呼它。注意这个函数以<code class="fe nv nw nx nm b">hDistance</code>为参数，所以我们甚至在函数调用中指定了输出。</p><p id="9a78" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在后端，它使用 Numba 进行计算。</p><p id="959c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在这一切都很好，但有几个警告:</p><ul class=""><li id="c104" class="on oo jj la b lb lc le lf lh op ll oq lp or lt os ot ou ov bi translated">它不接受字符串作为输入，所以如果你想使用字符串列，你不能。这是 CuDF 特性列表中的内容。</li><li id="0e98" class="on oo jj la b lb ow le ox lh oy ll oz lp pa lt os ot ou ov bi translated">只有 CUDA python 支持的一些函数可以使用，而不是所有的 python 函数。支持功能的完整列表在<a class="ae jg" href="https://numba.pydata.org/numba-doc/dev/cuda/cudapysupported.html" rel="noopener ugc nofollow" target="_blank">这里</a>。</li></ul><p id="f0e0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那么我们为什么要使用它呢？在这个特殊的例子中，熊猫用了 48 秒，而 CuDF 只用了 295 毫秒。这是一个 160 倍的加速。 </p><h2 id="b0c1" class="nq md jj bd me oc od dn mi oe of dp mm lh og oh mo ll oi oj mq lp ok ol ms om bi translated">b.过滤数据帧</h2><p id="dd4a" class="pw-post-body-paragraph ky kz jj la b lb nf kk ld le ng kn lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">熊猫使数据帧的过滤和子集化变得相当容易。您可以使用标准运算符和<code class="fe nv nw nx nm b">&amp;,|,~</code>运算符对数据帧进行过滤和子集化。你可以用 cuDF 做同样的事情。</p><pre class="nb nc nd ne gt nl nm nn no aw np bi"><span id="8352" class="nq md jj nm b gy nr ns l nt nu"># Single condition</span><span id="b229" class="nq md jj nm b gy oa ns l nt nu">df_dis_gt_2 = gdf[gdf['hDistance']&gt;2]</span><span id="3a9a" class="nq md jj nm b gy oa ns l nt nu"># Multiple conditions: AND</span><span id="be56" class="nq md jj nm b gy oa ns l nt nu">And_df = gdf[(gdf['hDistance']&gt;8) &amp; (gdf['TMC']&gt;200)]</span><span id="1293" class="nq md jj nm b gy oa ns l nt nu"># Multiple conditions: OR</span><span id="5e4d" class="nq md jj nm b gy oa ns l nt nu">Or_df = gdf[(gdf['hDistance']&gt;8) | (gdf['TMC']&gt;200)]</span><span id="044a" class="nq md jj nm b gy oa ns l nt nu"># Multiple conditions: NOT</span><span id="48b5" class="nq md jj nm b gy oa ns l nt nu">Not_df = gdf[~((gdf['hDistance']&gt;8) | (gdf['TMC']&gt;200))]</span></pre><p id="4a1c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">很简单的东西。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e3c0" class="mc md jj bd me mf mg mh mi mj mk ml mm kp mn kq mo ks mp kt mq kv mr kw ms mt bi translated">数据帧上的聚集:<code class="fe nv nw nx nm b">groupby</code></h1><p id="49b6" class="pw-post-body-paragraph ky kz jj la b lb nf kk ld le ng kn lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated"><code class="fe nv nw nx nm b">groupby</code>会出现很多次，每当你想聚集你的数据。Pandas 通过<code class="fe nv nw nx nm b">groupby</code>功能让您高效地做到这一点，比如:</p><p id="612f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nv nw nx nm b">df.groupby(list of columns to groupby on).aggregate({'colname':func1, 'colname2':func2}).reset_index()</code></p><p id="9928" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你必须担心提供两个主要的信息。</p><ul class=""><li id="6bbd" class="on oo jj la b lb lc le lf lh op ll oq lp or lt os ot ou ov bi translated">列列表至<code class="fe nv nw nx nm b">groupby</code> on，和</li><li id="add3" class="on oo jj la b lb ow le ox lh oy ll oz lp pa lt os ot ou ov bi translated">列和要应用于这些列的函数的字典</li></ul><p id="9e67" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nv nw nx nm b">reset_index()</code>是一个重置数据帧索引的函数。每当我执行 groupby 时，我总是使用这个函数，您可能会认为它是 groupby 操作的默认语法。</p><p id="8bc6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有益的是，cuDF 的语法保持不变。</p><pre class="nb nc nd ne gt nl nm nn no aw np bi"><span id="38d3" class="nq md jj nm b gy nr ns l nt nu">gdf_gby = gdf.groupby(['Traffic_Calming','Sunrise_Sunset']).agg({'TMC':'mean','Severity':'mean'}).reset_index()</span></pre><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/493ba97be2dcc393a852d82ffbcd2783.png" data-original-src="https://miro.medium.com/v2/resize:fit:1130/format:webp/1*Xc4zEh0H2quPJDno-EC2cg.png"/></div></figure><p id="d430" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> <em class="lu">告诫:</em> </strong>我先试了一下<code class="fe nv nw nx nm b">np.mean</code>这个函数，没用。它只提供基本功能<code class="fe nv nw nx nm b">sum</code>、<code class="fe nv nw nx nm b">mean</code>、<code class="fe nv nw nx nm b">min</code>和<code class="fe nv nw nx nm b">max</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ce56" class="mc md jj bd me mf mg mh mi mj mk ml mm kp mn kq mo ks mp kt mq kv mr kw ms mt bi translated">处理多个数据帧:连接和合并:</h1><h2 id="5149" class="nq md jj bd me oc od dn mi oe of dp mm lh og oh mo ll oi oj mq lp ok ol ms om bi translated"><code class="fe nv nw nx nm b">a. Concat</code></h2><p id="a8a7" class="pw-post-body-paragraph ky kz jj la b lb nf kk ld le ng kn lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">有时我们从不同的来源获得数据。或者有人带着多个文件来找你，每个文件都有特定年份的数据。</p><p id="7bfb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> <em class="lu">我们如何从这些多个数据帧中创建单个数据帧？</em> </strong></p><p id="8216" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里我们将人工创建用例，因为我们只有一个文件。我们首先使用已知的基本过滤操作创建两个数据帧。</p><pre class="nb nc nd ne gt nl nm nn no aw np bi"><span id="0ad8" class="nq md jj nm b gy nr ns l nt nu">severity_lt_3 = gdf[gdf['Severity']&lt;3]<br/>severity_gte_3 = gdf[gdf['Severity']&gt;=3]</span></pre><p id="e251" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里我们从两个数据帧开始:severity_lt_3 包含严重性小于 3 的事故信息，severity_gte_3 提供严重性大于或等于 3 的事故信息。我们希望创建一个包含两种事故的单一数据框架。</p><pre class="nb nc nd ne gt nl nm nn no aw np bi"><span id="9712" class="nq md jj nm b gy nr ns l nt nu">fullseverity = cudf.concat([severity_lt_3,severity_gte_3])</span></pre><h2 id="8584" class="nq md jj bd me oc od dn mi oe of dp mm lh og oh mo ll oi oj mq lp ok ol ms om bi translated">b.合并</h2><p id="053e" class="pw-post-body-paragraph ky kz jj la b lb nf kk ld le ng kn lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">您将遇到的大多数数据永远不会出现在单个文件中。其中一个文件可能包含特定电影的评级，另一个文件可能提供电影的投票数。</p><p id="aaca" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，我们有两个需要合并的数据帧，这样我们就可以在一个视图中拥有所有的信息。</p><p id="5f5d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里我们将人工创建用例，因为我们只有一个文件。我们首先使用已知的基本列子集操作创建两个数据帧。</p><pre class="nb nc nd ne gt nl nm nn no aw np bi"><span id="b4c2" class="nq md jj nm b gy nr ns l nt nu">accident_times_dataframe = gdf[['ID','Start_Time','End_Time']]<br/>accident_locations_dataframe = gdf[['ID','Start_Lat','Start_Lng','End_Lat','End_Lng']]</span></pre><div class="nb nc nd ne gt ab cb"><figure class="pe iv pf pg ph pi pj paragraph-image"><img src="../Images/b98648070ff539aafee364008640ac79.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/format:webp/1*FwpdL9JhkBgOVXo66lyc_A.png"/></figure><figure class="pe iv pk pg ph pi pj paragraph-image"><img src="../Images/335ce0b781473c2dd42f6ce0b38cb1c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*AGyp56nFPlU8547KBek1Aw.png"/></figure></div><p id="1079" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们需要在一个数据框架中包含所有这些信息。我们该怎么做？这个语法也和熊猫一样。</p><pre class="nb nc nd ne gt nl nm nn no aw np bi"><span id="5772" class="nq md jj nm b gy nr ns l nt nu">information_df = cudf.merge(accident_times_dataframe,accident_locations_dataframe,on='ID',how='left')</span></pre><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pl"><img src="../Images/9aeac2c7c4a0a5faab665b13ae7edead.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sEf7Xgtz94HZyxMCxcdIuA.png"/></div></div></figure><p id="a483" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们为这个合并函数提供了四个属性——第一个 DF、第二个 DF、在哪一列上连接以及连接标准:<code class="fe nv nw nx nm b">['left','right','inner','outer']</code></p><p id="c7ab" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> <em class="lu">就计时而言，当我们使用 cudf 进行连接时，我们再次获得了 10 倍的加速。</em> </strong></p><figure class="nb nc nd ne gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pm"><img src="../Images/f1f101df1ca06e946656802b0c3f93dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a59khwxBSb0YMCSn2XXV5g.png"/></div></div></figure><p id="8ca6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> <em class="lu">推荐:</em> </strong>我通常最后总是用<code class="fe nv nw nx nm b">left</code> join。你很少需要使用<code class="fe nv nw nx nm b">outer</code>或<code class="fe nv nw nx nm b">right.</code>来连接，实际上无论何时你需要做一个<code class="fe nv nw nx nm b">right </code>连接，你实际上只需要一个左连接，在合并函数中数据帧的顺序是相反的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5b7e" class="mc md jj bd me mf mg mh mi mj mk ml mm kp mn kq mo ks mp kt mq kv mr kw ms mt bi translated">结论</h1><p id="8a41" class="pw-post-body-paragraph ky kz jj la b lb nf kk ld le ng kn lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated"><strong class="la jk"> <em class="lu"> CuDF 是朝着正确方向迈出的一步，因为它提供了用于数据处理的 GPU，这占用了数据科学管道中的大量时间。</em> </strong></p><p id="6a6e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> <em class="lu">这里我试着说一下我经常使用的 cuDF 中的一些功能。NVIDIA 的人正在尝试实现更多的东西，所以请看看<a class="ae jg" href="https://docs.rapids.ai/api/cudf/stable/" rel="noopener ugc nofollow" target="_blank">文档</a>。</em></strong></p><p id="6e48" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> <em class="lu">虽然熊猫的一些功能还没有实现，</em> </strong>但这不应该阻止我们利用已经为时间关键型应用和 Kaggle 实现的功能。</p><p id="e8d5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就我自己而言，在我的数据准备笔记本中，我在 cudf 和 pandas 数据框架之间切换了多次。</p><p id="5287" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每当我有点赶时间的时候，它确实帮了我很大的忙。</p><p id="1b17" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望这篇文章对你有用，值得你花时间。我试图让这尽可能简单，但你可能总是<strong class="la jk">问我</strong>或查看文档中的疑问。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="e45b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">全部代码都发布在我的<a class="ae jg" href="https://github.com/MLWhiz/data_science_blogs/tree/master/cudf" rel="noopener ugc nofollow" target="_blank"> Github Repo </a>中，我在那里保存了我所有帖子的代码。你可以在<a class="ae jg" href="https://www.kaggle.com/sobhanmoosavi/us-accidents" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>找到数据。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="c687" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另外，如果你想学习更多关于 Python 3 的知识，我想从密歇根大学调出一门关于学习<a class="ae jg" href="https://bit.ly/2XshreA" rel="noopener ugc nofollow" target="_blank">中级 Python </a>的优秀课程。一定要去看看。</p><p id="f7a1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我以后也会写更多这样的帖子。让我知道你对他们的看法。在<a class="ae jg" href="https://medium.com/@rahul_agarwal" rel="noopener"><strong class="la jk"/></a>关注我或者订阅我的<a class="ae jg" href="http://eepurl.com/dbQnuX" rel="noopener ugc nofollow" target="_blank"> <strong class="la jk">博客</strong> </a>了解他们。一如既往，我欢迎反馈和建设性的批评，可以通过 Twitter <a class="ae jg" href="https://twitter.com/MLWhiz" rel="noopener ugc nofollow" target="_blank"> @mlwhiz </a>联系。</p></div></div>    
</body>
</html>