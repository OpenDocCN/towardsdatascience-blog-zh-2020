<html>
<head>
<title>How to deploy ML models using Flask + Gunicorn + Nginx + Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Flask + Gunicorn + Nginx + Docker部署ML模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-deploy-ml-models-using-flask-gunicorn-nginx-docker-9b32055b3d0?source=collection_archive---------2-----------------------#2020-04-30">https://towardsdatascience.com/how-to-deploy-ml-models-using-flask-gunicorn-nginx-docker-9b32055b3d0?source=collection_archive---------2-----------------------#2020-04-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ec97" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一个配置Flask + Gunicorn + Nginx + Docker的模板，并附有详细的解释，这应该会让你更接近使用微服务、构建MVP等等。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6d3f436c87a7d575a8f0224adf78d1cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*No_PfHiKia5YW1Z2dpvFcw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://www.flickr.com/photos/appleboy/" rel="noopener ugc nofollow" target="_blank">吴伯毅</a> via flickr</p></figure><p id="25c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开发一个好的机器学习模型可能很棘手，但即使有人成功做到了，在你部署它以便其他人可以访问它之前，它仍然几乎没有用处。</p><p id="5b8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">部署模型有很多方法，我想谈谈一个非常简单的适用于基本MVP的解决方案——用Flask为您的模型编写一个API，用Gunicorn为应用服务器编写API，用Nginx为web服务器编写API，用Docker包装它，这样就可以更容易地部署在其他机器上(特别是AWS和GCP)。</p><p id="ebe3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">完整代码</strong>可以在<a class="ae ky" href="https://github.com/ivanpanshin/flask_gunicorn_nginx_docker" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>中找到。</p><h1 id="93d8" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">设置服务器</h1><p id="e232" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我更喜欢在我专门租用的服务器上用新配置做实验，而不是使用我的个人或工作硬件。这样，如果你把什么东西弄坏了，也没什么大不了的。我推荐使用Linode 来实现这些目的，因为我个人在我的实验中使用它们，它们的硬件工作得很好。但是你可以随意使用任何其他服务，只要是在LTS Ubuntu 18.04上。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/cc93e452be8aab1c8aa8e9f26621b9fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YZQx2LIo0PSP0Zu9IfIW4Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">曼努埃尔·盖辛格</p></figure><p id="aaed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你决定使用Linode，那么这一部分就是为你准备的。导航至Linodes并点击“添加Linode”。有几件事你应该填写。在发行版中，我建议选择Ubuntu 18.04 LTS映像、区域—任何离你更近的地方(我使用法兰克福，DE)、Linode计划— Nanode(每月仅花费5美元，但对于我们的目的来说已经足够了)、root password —你的密码，然后单击“创建”。一段时间后(大约几分钟)，你可以进入“网络”，在那里你可以找到通过SSH访问你的服务器的信息。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mt"><img src="../Images/300f69f9f86d749927b7ed9633d37ee2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R-yGZPjQAYU5YLD9xqXByA.png"/></div></div></figure><p id="a2a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我建议做的下一件事是连接到服务器并创建具有sudo特权的非root用户。该操作背后的逻辑相当简单:您不希望以root用户身份运行任何东西来扰乱服务器，因为这样更容易破坏东西。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="ec61" class="mz lw it mv b gy na nb l nc nd">adduser username</span><span id="3489" class="mz lw it mv b gy ne nb l nc nd">usermod -aG sudo username</span></pre><p id="7934" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，切换到您的新用户:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="a57a" class="mz lw it mv b gy na nb l nc nd">su — username</span></pre><h1 id="08fd" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">创建应用程序容器</h1><p id="23c3" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">整个系统配置分为两部分:应用容器(Flask + Gunicorn)和web容器(Nginx web服务器)。先说第一个。</p><h2 id="43fe" class="mz lw it bd lx nf ng dn mb nh ni dp mf li nj nk mh lm nl nm mj lq nn no ml np bi translated">步骤0 —安装Docker和Docker Compose</h2><p id="6bb0" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">Docker和docker-compose安装非常容易。它们分别在4行和2行中完成。因此，我建议遵循以下页面:</p><blockquote class="nq nr ns"><p id="5dd6" class="kz la nt lb b lc ld ju le lf lg jx lh nu lj lk ll nv ln lo lp nw lr ls lt lu im bi translated"><a class="ae ky" href="https://docs.docker.com/engine/install/ubuntu/" rel="noopener ugc nofollow" target="_blank">码头工人安装</a></p><p id="ac36" class="kz la nt lb b lc ld ju le lf lg jx lh nu lj lk ll nv ln lo lp nw lr ls lt lu im bi translated"><a class="ae ky" href="https://docs.docker.com/engine/install/linux-postinstall/" rel="noopener ugc nofollow" target="_blank">让Docker无根运行</a></p><p id="1a33" class="kz la nt lb b lc ld ju le lf lg jx lh nu lj lk ll nv ln lo lp nw lr ls lt lu im bi translated"><a class="ae ky" href="https://docs.docker.com/compose/install/" rel="noopener ugc nofollow" target="_blank">码头工人作曲装置</a></p></blockquote><h2 id="a36a" class="mz lw it bd lx nf ng dn mb nh ni dp mf li nj nk mh lm nl nm mj lq nn no ml np bi translated">步骤1 —创建Flask应用程序和WSGI入口点</h2><p id="981f" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在主目录中创建<em class="nt"> flask_app </em>目录，并将以下文件放在那里。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="5ff9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是最基本的Flask应用程序，几乎没有任何功能。我们不加载任何模型，不添加任何GET/POST请求之类的东西。那是以后的事。目前，我们只有一个在主页上显示“hello world”的应用程序。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="598a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个非常简单的部分——我们只需为Gunicorn创建一个单独的文件，让它在端口8000上运行。</p><h2 id="07b6" class="mz lw it bd lx nf ng dn mb nh ni dp mf li nj nk mh lm nl nm mj lq nn no ml np bi translated">步骤2 —为Flask创建一个Docker映像</h2><p id="f999" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在，我们需要创建一个Dockerfile来使用这些文件，并创建一个稍后可以运行的映像。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="3202" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于那些不熟悉Docker的人来说，这个脚本的作用如下:导入Python 3.6.7图像，为所有文件设置工作目录，复制包含Flask、Gunicorn和运行Flask应用程序所需的所有内容的需求文件。之后，通过RUN命令安装来自需求的所有包，最后我们将所有文件从flask dir复制到容器内的<em class="nt"> usr/scr/flask_app </em>。</p><p id="6e6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你只需要把这个文件放在同一个flask_app目录下，并添加<em class="nt"> requirements.txt </em>。在这种特殊情况下，这是非常基本的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="0736" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nt">附言</em>记住，如果你对目录之类的东西有点困惑，可以在文章末尾查看完整的项目结构，或者访问GitHub repo。</p><h2 id="4339" class="mz lw it bd lx nf ng dn mb nh ni dp mf li nj nk mh lm nl nm mj lq nn no ml np bi translated">步骤3 —创建Nginx文件</h2><p id="6939" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">为了运行Nginx，您需要进行一些配置。但是在我们继续之前，在您的主目录中创建nginx目录(与<em class="nt"> flask_app </em>在同一层)。之后，我们需要的第一个文件是<em class="nt"> nginx.conf </em>，它包含了所有基本的nginx信息和变量。一个非常基本的Nginx设置示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="d419" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个文件—我们特定应用程序的配置。有两种流行的方法可以做到这一点。第一种是在<em class="nt">/etc/nginx/sites-available/your _ project</em>中创建一个配置文件，然后创建一个指向<em class="nt">/etc/nginx/sites-enabled/your _ project</em>的符号链接。第二种方法是在主Nginx目录中创建一个<em class="nt"> project.conf </em>。我们将采用第二种方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="512a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有几件事你应该注意。首先看一下<em class="nt">听80。这个命令指定了你的应用程序将在哪个端口运行。作为默认端口，我们选择80。其次，服务器名。你可以指定你从Linode得到的IP地址，或者你可以只使用你的docker镜像名称。最后但同样重要的是，<em class="nt">代理传递</em>命令，将您的Nginx配置指向flask项目。由于flask容器名为flask_app(我们稍后会用到它)，所以我们只使用容器的名称，以及我们在flask项目中指定的端口。</em></p><h2 id="2421" class="mz lw it bd lx nf ng dn mb nh ni dp mf li nj nk mh lm nl nm mj lq nn no ml np bi translated">步骤4 —为Nginx创建一个Docker映像</h2><p id="235c" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这个特定的Docker图像相当简单。和Flask的情况一样，它也只包含5行代码，只做了两件事:导入nginx图像，复制我们的文件，并用默认文件替换它们。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><h2 id="df15" class="mz lw it bd lx nf ng dn mb nh ni dp mf li nj nk mh lm nl nm mj lq nn no ml np bi translated">步骤5-用docker-compose组合docker文件</h2><p id="2a6f" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">所以，现在我们有两个docker文件:一个用于Flask + Gunicorn，另一个用于Nginx。是时候让他们互相交流，运行整个系统了。为了做到这一点，我们需要docker-compose。</p><p id="8642" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要做的唯一基本更改是在主目录中创建docker-compose.yml文件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="b430" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了理解它是如何工作的，我们应该解决几个重要的问题。首先，<em class="nt"> docker-compose </em>拆分成2个部分(2个服务):<em class="nt"> flask_app </em>和<em class="nt"> nginx </em>。从下面几行可以看出，flask_app容器执行Gunicorn，guni corn运行flask应用程序，并使用1个worker将其转换为8000端口。而第二个容器只是在80端口上运行Nginx。另外，注意<em class="nt">依赖于</em>部分。它告诉docker-compose首先启动<em class="nt"> flask_app </em>容器，然后才启动<em class="nt"> nginx </em>容器，因为它们相互依赖。</p><p id="4e0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际上，我们还应该添加一个东西，这样就可以更容易地运行这个docker设置。那就是<em class="nt"> run_docker.sh </em>文件</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="827e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它只是运行docker-compose，但首先确保此时没有旧的docker进程处于活动状态。</p><h2 id="dfbd" class="mz lw it bd lx nf ng dn mb nh ni dp mf li nj nk mh lm nl nm mj lq nn no ml np bi translated">第六步——把所有东西放在一起</h2><p id="8f16" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">好的，请记住，当前的项目结构应该是这样的:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="6a99" class="mz lw it mv b gy na nb l nc nd">.<br/>├── flask_app <br/>│   ├── app.py          <br/>│   ├── wsgi.py<br/>│   └── Dockerfile<br/>├── nginx<br/>│   ├── nginx.conf          <br/>│   ├── project.conf<br/>│   └── Dockerfile<br/>├── docker-compose.yml<br/>└── run_docker.sh</span></pre><p id="1d84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">确保一切就绪后，就该运行docker了:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="f933" class="mz lw it mv b gy na nb l nc nd">bash run_docker.sh</span></pre><p id="0179" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过导航到您从Linode获得的IP地址，在浏览器中查看主页:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/85ba27521eb04f2bc8ba44dbc673be54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*PvN0bh118RsrYVLf5_zlOA.png"/></div></div></figure><h2 id="0d7e" class="mz lw it bd lx nf ng dn mb nh ni dp mf li nj nk mh lm nl nm mj lq nn no ml np bi translated">第7步—我什么也没得到。我该怎么办？</h2><p id="ce1d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">嗯，首先在Linode租一个服务器，安装docker和docker-compose，然后克隆git库，运行<em class="nt"> bash run_docker.sh. </em>在你确定运行成功后，开始改东西。玩玩Flask、Dockerfiles或docker-compose，直到你打破一些东西。之后，试着找出问题所在并修复它。</p><p id="77f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，如果你不精通Flask、Gunicorn、Nginx或Docker，我强烈推荐这些教程:</p><blockquote class="nq nr ns"><p id="de91" class="kz la nt lb b lc ld ju le lf lg jx lh nu lj lk ll nv ln lo lp nw lr ls lt lu im bi translated"><a class="ae ky" href="https://docker-curriculum.com/" rel="noopener ugc nofollow" target="_blank">初学者Docker</a></p><p id="14e8" class="kz la nt lb b lc ld ju le lf lg jx lh nu lj lk ll nv ln lo lp nw lr ls lt lu im bi translated"><a class="ae ky" href="https://www.tutorialspoint.com/flask/index.htm" rel="noopener ugc nofollow" target="_blank">学烧瓶</a></p><p id="95f9" class="kz la nt lb b lc ld ju le lf lg jx lh nu lj lk ll nv ln lo lp nw lr ls lt lu im bi translated"><a class="ae ky" href="https://www.digitalocean.com/community/tutorials/how-to-serve-flask-applications-with-gunicorn-and-nginx-on-ubuntu-18-04-ru" rel="noopener ugc nofollow" target="_blank">烧瓶+ Gunicorn + Nginx </a></p></blockquote><h2 id="f8a7" class="mz lw it bd lx nf ng dn mb nh ni dp mf li nj nk mh lm nl nm mj lq nn no ml np bi translated">第八步——好吧，我明白了。下一步是什么？</h2><p id="6ef4" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">接下来要添加的是Flask App中的POST请求支持。这样，您可以向您的模型发送请求，并获得响应。所以，我们需要两样东西。第一个是处理请求的模型。第二— POST请求支持本身。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="1342" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了简单起见，本例中的模型只返回颜色列表的第I个元素。但是运行的是哪种模型并不重要，只需在所有方法之上创建模型的实例(<em class="nt">)就可以了，这里有server = Flask(__name__) </em>。</p><p id="1c96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果您导航到您的IP地址，您将看到一条消息"<em class="nt">模型已启动并正在运行。</em>发送POST请求”，因为<em class="nt"> </em>只是去IP就有资格成为GET请求。然而，让我们试着发送一个包含模型索引的json文件的POST请求。就我个人而言，我使用Postman，但您可以使用任何您喜欢的名称(即Curl)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/66b31704246dfcf625dbc59db8f9e29f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zSTjW6ILhvFXJx7QYg7zBA.png"/></div></div></figure><p id="0eb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嘿，成功了！现在，您可以添加能够接收GET/POST请求的附加路由。这个想法背后的原因是，您可以加载几个模型，并根据URL向特定的模型发送请求。</p><h2 id="7d66" class="mz lw it bd lx nf ng dn mb nh ni dp mf li nj nk mh lm nl nm mj lq nn no ml np bi translated">第九步——更进一步怎么样？</h2><p id="9f6f" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">实际上还有一件大事要做。为了部署这个docker设置，将它部署在云中可能是个好主意。例如，我建议看一看将Docker部署到Amazon ECS的<a class="ae ky" href="https://medium.com/underscoretec/deploy-your-own-custom-docker-image-on-amazon-ecs-b1584e62484" rel="noopener">。这种方法的主要优点之一是AWS将负责集群管理基础设施。</a></p><h1 id="7f18" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="7cef" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们已经用Gunicorn + Nginx + Docker在Flask应用程序中运行了一个模型。请注意，如果您有任何问题，请随时在评论、GitHub问题或我的电子邮件地址ivan.panshin@protonmail.com联系我</p></div></div>    
</body>
</html>