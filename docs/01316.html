<html>
<head>
<title>Analyzing the Superbowl History Dataset (1967–2020)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分析超级碗历史数据集(1967-2020)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/analyzing-the-superbowl-history-dataset-1967-2020-fdee01a760c9?source=collection_archive---------33-----------------------#2020-02-05">https://towardsdatascience.com/analyzing-the-superbowl-history-dataset-1967-2020-fdee01a760c9?source=collection_archive---------33-----------------------#2020-02-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="22ee" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">历史超级碗数据的探索性数据分析</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5494c349731ba30cd0eb59cfb967a0cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*akK7uE5l_qSQmNvx7IexqA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Jean-Daniel Francoeur 在<a class="ae ky" href="https://www.pexels.com/photo/selective-focus-close-up-photo-of-brown-wilson-pigskin-football-on-green-grass-2570139/" rel="noopener ugc nofollow" target="_blank"> Pexels </a>上拍摄的照片</p></figure><p id="5fd4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">超级碗是一年一度的比赛，决定了美国国家橄榄球联盟(NFL)的冠军。这是世界上最受关注的年度体育赛事之一，拥有大量的国内观众。平均每年美国有超过 1 亿人收看超级碗比赛。</p><p id="3980" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本帖中，我们将分析<em class="lv">超级碗历史数据集(1967–2020)</em>。我们将为获胜球队、体育场、获胜点数和最有价值球员等信息生成汇总统计数据和数据可视化。我们将使用的数据可以在<a class="ae ky" href="https://www.kaggle.com/timoboz/superbowl-history-1967-2020" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="c3cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们开始吧。</p><p id="cd13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们使用 pandas 导入数据:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="d8a6" class="mb mc it lx b gy md me l mf mg">import pandas as pd<br/>df = pd.read_csv("superbowl.csv")</span></pre><p id="343f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们可以打印列的列表:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="a27c" class="mb mc it lx b gy md me l mf mg">print(df.columns)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/599d41e9401d41ef1e124fc60e789603.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/format:webp/1*rX8xXnn2p9LGaALawtjUqw.png"/></div></figure><p id="17d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，有 10 列。让我们打印前五行:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="c45e" class="mb mc it lx b gy md me l mf mg">print(df.head())</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/bfa544ff4bc0d12b4d07cf4c493e6f19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/format:webp/1*OKwX-R3-eCtnkJkBtWWZjA.png"/></div></figure><p id="d396" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到有几个分类列。让我们定义一个将数据框、列名和限制作为输入的函数。当被调用时，它打印分类值的字典以及它们出现的频率:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="dfb3" class="mb mc it lx b gy md me l mf mg">def return_counter(data_frame, column_name, limit):<br/>   from collections import Counter    print(dict(Counter(data_frame[column_name].values).most_common(limit)))</span></pre><p id="df82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们将我们的函数应用到最有价值球员(“MVP”)一栏，并将我们的结果限制在五个最常见的值:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="9505" class="mb mc it lx b gy md me l mf mg">return_counter(df, 'MVP', 5)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/b154963b5862f5035dbb58b17c7cc04a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*2XK5n7eWQl0b-O3ZHHOhew.png"/></div></figure><p id="191d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到汤姆·布拉迪拥有最多的 MVP 记录，其次是乔·蒙塔纳。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mk"><img src="../Images/5b9483808c7fa62e4e912d8e8d8210e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZYFRW_1omgqe_1bEC_hQdg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://sports.yahoo.com/tom-bradys-says-im-not-going-anywhere-in-super-bowl-ad-that-followed-up-cryptic-tweet-001945992.html" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="1710" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们将函数应用于“Stadium”列:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="2178" class="mb mc it lx b gy md me l mf mg">return_counter(df, 'Stadium', 5)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ml"><img src="../Images/98172a8a4c980cc4a9b63d62d8d5606a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5Qz6fj5dWfUou8SP3pd-pw.png"/></div></div></figure><p id="6fa2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">路易斯安那州的 Superdome、Rose Bowl 和 Orange Bowl 在数据集中出现了五次。</p><p id="6684" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们试试“获胜者”栏，它对应于获胜的团队:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="6c61" class="mb mc it lx b gy md me l mf mg">return_counter(df, 'Winner', 5)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mm"><img src="../Images/f847abb0b782518f87042f04a5345cfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PmGqm5pTfW_Yl6khjl4ydg.png"/></div></div></figure><p id="a186" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">新英格兰爱国者队和匹兹堡钢人队并列六胜。</p><p id="70c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我鼓励您将此函数应用于剩余的分类列，如“州”、“城市”和“失败者”。</p><p id="febd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您所看到的，这是一个有用的快速测试，可以查看数据中是否有任何明显的不平衡，这通常是建模时需要处理的一个关键问题。</p><p id="3c1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，从数字列(如“Winner Pts ”,即获胜团队获得的分数)中生成汇总统计数据会很有用。让我们定义一个采用数据框、分类列和数字列的函数。每个类别的数字列的平均值和标准偏差存储在数据框中，并且数据框根据平均值以降序排序。如果您想要快速查看特定类别对于特定数字列是否具有更高或更低的平均值和/或标准偏差值，这将非常有用。</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="2d1c" class="mb mc it lx b gy md me l mf mg">def return_statistics(data_frame, categorical_column, numerical_column):<br/>    mean = []<br/>    std = []<br/>    field = []<br/>    for i in set(list(data_frame[categorical_column].values)):<br/>        new_data = data_frame[data_frame[categorical_column] == i]<br/>        field.append(i)<br/>        mean.append(new_data[numerical_column].mean())<br/>        std.append(new_data[numerical_column].std())<br/>    df = pd.DataFrame({'{}'.format(categorical_column): field, 'mean {}'.format(numerical_column): mean, 'std in {}'.format(numerical_column): std})<br/>    df.sort_values('mean {}'.format(numerical_column), inplace = True, ascending = False)<br/>    df.dropna(inplace = True)<br/>    return df</span></pre><p id="2112" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以查看“获胜者”和“获胜者分数”的汇总统计数据:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="ac06" class="mb mc it lx b gy md me l mf mg">stats = return_statistics(df, 'Winner', 'Winner Pts')<br/>print(stats.head(15))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/241c48cdf5607bb8298cae8fcee6e3a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*Qq-MCn5sD5FcMT8hw0fVAQ.png"/></div></figure><p id="6cb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">旧金山 49 人队的平均“赢家分数”和“赢家分数”的标准差最高。</p><p id="8e53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将使用箱线图来显示基于最小值、最大值、中值、第一个四分位数和第三个四分位数的数值分布。如果您对它们不熟悉，可以看看文章<a class="ae ky" rel="noopener" target="_blank" href="/understanding-boxplots-5e2df7bcbd51">了解 Boxplots </a>。</p><p id="0ed8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与汇总统计函数类似，此函数采用数据框、分类列和数值列，并根据限制显示最常见类别的箱线图:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="dec3" class="mb mc it lx b gy md me l mf mg">def get_boxplot_of_categories(data_frame, categorical_column, numerical_column, limit):<br/>    import seaborn as sns<br/>    from collections import Counter<br/>    keys = []<br/>    for i in dict(Counter(df[categorical_column].values).most_common(limit)):<br/>        keys.append(i)<br/>    print(keys)<br/>    df_new = df[df[categorical_column].isin(keys)]<br/>    sns.set()<br/>    sns.boxplot(x = df_new[categorical_column], y =      df_new[numerical_column])</span></pre><p id="4c36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们为 5 个最常见的获胜团队的“获胜者分数”生成箱线图:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="9054" class="mb mc it lx b gy md me l mf mg">get_boxplot_of_categories(df, 'Winner', 'Winner Pts', 5)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mo"><img src="../Images/7bea8394faf5441ff99522494e37c584.png" data-original-src="https://miro.medium.com/v2/resize:fit:1218/format:webp/1*yBRiIiXo1PUD2HTITxz65A.png"/></div></div></figure><p id="a5f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以定义一个函数来显示获胜点的时间序列图。首先，让我们将“日期”转换成日期时间对象:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="7089" class="mb mc it lx b gy md me l mf mg">df['Date'] = pd.to_datetime(df['Date'])</span></pre><p id="f011" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们定义一个函数，该函数将数据框和数字列作为输入，并显示“Winner Pts”的时间序列图:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="9b0a" class="mb mc it lx b gy md me l mf mg">def get_time_series(data_frame, numerical_column):<br/>    import matplotlib.pyplot as plt<br/>    df_new = data_frame<br/>    plt.scatter(df_new['Date'], df_new[numerical_column])<br/>    plt.xlabel('Date')<br/>    plt.ylabel(numerical_column)</span></pre><p id="c8c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用数据帧和“赢家 Pts”调用函数:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="94f6" class="mb mc it lx b gy md me l mf mg">get_time_series(df, 'Winner Pts')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/d888bb62dcf4940a10abfc6fe0ccd986.png" data-original-src="https://miro.medium.com/v2/resize:fit:798/format:webp/1*BG1FA--2cYDHuzFsla2WZA.png"/></div></figure><p id="bae3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，让我们定义一个函数，它将一个数据框和一个数字列作为输入，并显示一个直方图:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="8863" class="mb mc it lx b gy md me l mf mg">def get_histogram(data_frame, numerical_column):<br/>    df_new = data_frame<br/>    df_new[numerical_column].hist(bins=100)</span></pre><p id="7917" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们使用数据框调用函数，并生成优胜点直方图:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="23c2" class="mb mc it lx b gy md me l mf mg">get_histogram(df, 'Winner Pts')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/10aabbe80cc8b239a968d1346dd4e9e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/format:webp/1*anPdjZcrDddvgM92j5Zmlw.png"/></div></figure><p id="19ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我就讲到这里，但是请随意处理数据并自己编码。</p><p id="aeb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">概括地说，我回顾了几种分析<em class="lv">超级碗历史数据集的方法。</em>这包括定义生成汇总统计数据的函数，如平均值、标准差和分类值的计数。我们还定义了用箱线图、直方图和时间序列图来可视化数据的函数。我希望这篇文章有趣。这篇文章的代码可以在<a class="ae ky" href="https://github.com/spierre91/medium_code" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。感谢您的阅读！</p></div></div>    
</body>
</html>