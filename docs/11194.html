<html>
<head>
<title>Practical Pandas Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实用熊猫指南</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/practical-pandas-guide-b3eedeb3e88?source=collection_archive---------59-----------------------#2020-08-03">https://towardsdatascience.com/practical-pandas-guide-b3eedeb3e88?source=collection_archive---------59-----------------------#2020-08-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="da1e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">举例说明各种功能和方法。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/58367e36cb36b7ac21e18c4c6658f51c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rbzA8JIQVFrwwNzH.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@hengfilms?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">恒电影</a>在<a class="ae ky" href="https://unsplash.com/s/photos/style?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="566b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Pandas 是一个非常强大和通用的 Python 数据分析库，它加速了数据分析和探索过程。学习熊猫提供的功能和方法的最好方法是练习。</p><blockquote class="lv"><p id="67c3" class="lw lx it bd ly lz ma mb mc md me lu dk translated">熟能生巧。</p></blockquote><p id="0fd3" class="pw-post-body-paragraph kz la it lb b lc mf ju le lf mg jx lh li mh lk ll lm mi lo lp lq mj ls lt lu im bi translated">在本帖中，我们将通过大量的例子来探索熊猫的各种能力。我们将通过简单和高级的例子来看看熊猫的能力。</p><p id="4367" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一如既往，我们从进口熊猫开始。</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="6487" class="mp mq it ml b gy mr ms l mt mu">import pandas as pd<br/>import numpy as np</span></pre><p id="2bf5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们首先创建一个样本数据框架。我们可以将字典传递给熊猫的<strong class="lb iu">数据帧</strong>函数。</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="00ee" class="mp mq it ml b gy mr ms l mt mu">df = pd.DataFrame({'num_1':np.random.random(100),<br/>                   'num_2':np.random.random(100),<br/>                   'num_3':np.random.randint(0,5,100),<br/>                   'num_4':np.random.randint(0,100,100)})</span><span id="674e" class="mp mq it ml b gy mv ms l mt mu">df.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/54ccaf079e83accc713a48ab427005de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1118/format:webp/1*iXTrEK4wNKqE6DNYE0OZWw.png"/></div></figure><p id="f50c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用 numpy 数组来创建数字列。让我们也添加分类列到我们的数据框架。</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="2dfb" class="mp mq it ml b gy mr ms l mt mu">from random import sample</span><span id="ea88" class="mp mq it ml b gy mv ms l mt mu">name = ['Linda','John','Ashley','Xavi','Betty','Mike'] * 100<br/>cat = ['A','B','C','D'] * 100</span><span id="8e2a" class="mp mq it ml b gy mv ms l mt mu">names = sample(name, 100)<br/>cats = sample(cat, 100)</span></pre><p id="9c13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">列表“姓名”和“猫”包含从更长的列表“姓名”和“猫”中随机选择的 100 个样本。我们使用了 python 的<strong class="lb iu">随机</strong>模块中的<strong class="lb iu">样本</strong>函数。</p><p id="7f18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是时候将这两个分类特征添加到数据框架中了。</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="bfa5" class="mp mq it ml b gy mr ms l mt mu">df.insert(0, 'names', names)<br/>df['cats'] = cats</span><span id="9123" class="mp mq it ml b gy mv ms l mt mu">df.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/ac1537eea1b17130f5af08eae72d75c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/format:webp/1*F9yjhjQ-aCRcpBQCFMQatQ.png"/></div></figure><p id="4b22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们用两种不同的方式添加了两个新列。df['col'] = col 在末尾添加新列。我们可以使用<strong class="lb iu"> insert </strong>函数指定新列的位置，就像我们对“names”列所做的那样。</p><p id="0eab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们对“数量 1”大于“数量 2”的行感兴趣。下面两行代码完成了这项任务，并显示了前五行。</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="6015" class="mp mq it ml b gy mr ms l mt mu">df[df.num_1 &gt; df.num_2][:5]</span><span id="3407" class="mp mq it ml b gy mv ms l mt mu">df.query('num_1 &gt; num_2')[:5]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi my"><img src="../Images/cd3eca4d024b577b8e7d924c594ccfe5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*if-DfbCy52XdlHvgvou-9g.png"/></div></figure><p id="94ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以使用任何一个，但我更喜欢<strong class="lb iu">查询</strong>功能。我认为在更复杂的过滤器的情况下更简单。如果我们希望看到基于不同类别(“cats”)的“num_1”和“num_2”的比较，我们可以对过滤后的数据帧应用<strong class="lb iu"> groupby </strong>函数。</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="f7ab" class="mp mq it ml b gy mr ms l mt mu">df1 = df.query('num_1 &gt; num_2') [['cats','names']].groupby('cats').count().reset_index()<br/>df1</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/4cc1c6995bf0002036a6db6381feb32e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*BdJV2Y9UMuHzgFF4dvQKiw.png"/></div></figure><p id="287b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">“names”列在这里是不相关的，只是为了能够计算行数而选择的。似乎类别 C 和 D 有更多的行，其中“num_1”比“num_2”高。但是，除非我们知道每个类别在整个数据帧中有多少行，否则这些数字没有意义。</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="800c" class="mp mq it ml b gy mr ms l mt mu">ser = df['cats'].value_counts()</span><span id="d162" class="mp mq it ml b gy mv ms l mt mu">df2 = pd.concat((df1,ser), axis=1)</span><span id="354c" class="mp mq it ml b gy mv ms l mt mu">df2.rename(columns={'names':'num_1&gt;num_2', 'cats':'total'}, inplace=True)</span><span id="26d3" class="mp mq it ml b gy mv ms l mt mu">df2</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi na"><img src="../Images/e7b0186bc4d26522411f7d3b1f837f55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*XWHv_c-t7V2UdRn63BU-PQ.png"/></div></figure><p id="2303" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用<strong class="lb iu"> value_counts </strong>创建了一个包含 cats 列中每个类别的计数的序列。然后，我们将 df1 和 ser 与<strong class="lb iu"> concat </strong>函数结合起来，并重命名这些列。最终的 dataframe df2 显示了每个类别的总行数以及符合过滤参数的行数。</p><p id="acae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们希望在“num_4”中看到“cats”中每个类别的平均值，但是我们只希望看到几个名字的平均值。在这种情况下，我们可以使用<strong class="lb iu"> isin </strong>方法进行过滤，然后应用<strong class="lb iu"> groupby </strong>。</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="fe49" class="mp mq it ml b gy mr ms l mt mu">name = ['Ashley','Betty','Mike']</span><span id="eeae" class="mp mq it ml b gy mv ms l mt mu">df[df.names.isin(name)][['cats','num_4']].groupby('cats').mean()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/0bfb79d36cbd3f3ccdd7bd129452cca9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1226/format:webp/1*z2xprG8YUohpl0wzsYgL0A.png"/></div></figure><p id="951f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果还需要出现的次数，我们可以在 groupby 上应用多个聚合函数。</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="2276" class="mp mq it ml b gy mr ms l mt mu">name = ['Ashley','Betty','Mike']</span><span id="61e4" class="mp mq it ml b gy mv ms l mt mu">df[df.names.isin(name)][['cats','num_4']].groupby('cats').agg(['mean','count'])</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/33f5f89a3eb44ffb7fa2f50ad472b31d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/1*05c9IWFPEqYZVfpnhsXYVw.png"/></div></figure><p id="eff8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在 4 个不同的列中存储了 4 个不同的测量值。我们可以将它们合并在一列中，并在另一列中指明测量的名称。这是原始数据帧:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/d668836fe42c5c215299e0c90a618178.png" data-original-src="https://miro.medium.com/v2/resize:fit:1322/format:webp/1*5zL8WvQEYEGmGTgzlVSxWw.png"/></div></figure><p id="0d7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">融化</strong>功能可以用来实现我刚才描述的功能。</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="d03d" class="mp mq it ml b gy mr ms l mt mu">df_melted = df.melt(id_vars=['names','cats'])</span><span id="8cdb" class="mp mq it ml b gy mv ms l mt mu">df_melted.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/0827fa1428f25d36027a24908a63fdc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/1*J-7daoxghUhNM83KU53aGQ.png"/></div></figure><p id="89b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当处理宽数据帧(即大量特征)时，Melt 特别有用。例如，如果我们有 100 个不同的测量值(num_1 到 num_100)，那么在一个熔化的数据帧上进行分析就容易多了。</p><p id="f656" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的数据帧包含测量值，因此我们很可能通过添加新的测量值来更新数据帧。假设我们用下面的 new_row 更新了 dataframe。</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="8f54" class="mp mq it ml b gy mr ms l mt mu">new_row = {'names':'Mike', 'num_1':0.678, 'num_2':0.345,<br/>           'num_3':3, 'num_4':[68,80], 'cats':'C'}</span><span id="5e34" class="mp mq it ml b gy mv ms l mt mu">df_updated = df.append(new_row, ignore_index=True)<br/>df_updated.tail()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/f06bcfd1f3b960ab08dfb1848efe3771.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*LX_WltIsAL7z8fYXwJCSAA.png"/></div></figure><p id="e0e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">new_row 已添加，但存在一个问题。它包含“num_4”中的几个值。我们应该让他们分开坐。熊猫的<strong class="lb iu">爆炸</strong>功能可以用来做这个任务。</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="f7ae" class="mp mq it ml b gy mr ms l mt mu">df_updated = df_updated.explode('num_4').reset_index(drop=True)<br/>df_updated.tail()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/e9a9937167034dd84a2c57fb2c2793ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*rSUXKvUE22a3laXkrGGYfg.png"/></div></figure><p id="47a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经将“num_4”中的值分开了。可能会有这样的情况，一列在许多行中包含许多组合值。在这些情况下，分解功能可能会派上用场。</p><p id="0c90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在某些情况下，我们可能需要替换一些值。熊猫<strong class="lb iu">替换</strong>功能让它变得非常简单。我们甚至可以通过传递一个字典来替换多个值。</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="0700" class="mp mq it ml b gy mr ms l mt mu">replacement = {'D':'F', 'C':'T'}<br/>df.cats.replace(replacement, inplace=True)</span><span id="7896" class="mp mq it ml b gy mv ms l mt mu">df.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/944d6e79595ed5a2ba44ab933ddfb43a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*w41PbLUFT4uwX_caaQ81Fg.png"/></div></figure><p id="4c31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们需要根据一个条件替换一些值。条件被指定为“num_1 中低于 0.5 的值将被替换为 0”。在这种情况下，我们可以使用<strong class="lb iu"> where </strong> function。</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="fad7" class="mp mq it ml b gy mr ms l mt mu">df['num_1'] = df['num_1'].where(df['num_1'] &gt;= 0.5, 0)</span><span id="f53d" class="mp mq it ml b gy mv ms l mt mu">df.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/810dba4c50b708e945ce9c97736e2a70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*CoZAApla0a8By_kUwZ_y_g.png"/></div></figure><p id="71f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">“where”的工作方式是选择符合条件的值，并用指定的值替换剩余的值。<strong class="lb iu">其中(df['num_1']≥0.5，0) </strong>选择“num_1”中所有大于 0.5 的值，其余值替换为 0。</p><p id="6c63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据帧包含 4 个数值特征和 2 个分类特征。我们可能需要看到一个关于数值如何基于类别变化的快速总结。Pandas <strong class="lb iu"> pivot_table </strong>函数可以提供这种汇总，并且在显示选项方面非常灵活。</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="846d" class="mp mq it ml b gy mr ms l mt mu">df.pivot_table(index='names', columns='cats', values='num_2', aggfunc='mean', margins=True)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/7fe2c316070653b97f22de08a87570f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/format:webp/1*8pEYzCO3hDhXly7Mo2Kl6Q.png"/></div></figure><p id="6b24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此表显示了 num_2 值如何根据名称-类别组合而变化。最好将<strong class="lb iu"> margin </strong>参数设置为 True，以查看与整体值的比较。<strong class="lb iu"> aggfunc </strong>参数有许多选项，如计数、最小值、最大值。</p><p id="b9bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据帧的一个常见任务是处理缺失值。我们创建的数据帧没有任何缺失值。我们先随机添加一些缺失值。</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="1897" class="mp mq it ml b gy mr ms l mt mu">a = np.random.randint(0,99,20)<br/>df.iloc[a, 3] = np.nan</span></pre><p id="18e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们用 0 到 99 之间的 20 个随机整数创建了一个数组。然后我们在 iloc 中使用它作为索引。第四列(列索引为 3)中的 20 行被替换为 np.nan，这是熊猫的一个缺失值表示。</p><p id="b2ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">df.isna()。sum()返回每列中缺失值的数量。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/0ab30a98ebb62b94ec7db063c9134805.png" data-original-src="https://miro.medium.com/v2/resize:fit:1064/format:webp/1*98C4-7Qf1uSKIlAuq-utfA.png"/></div></figure><p id="99f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然我们传入了 20 个索引，但是缺少的值的数量似乎是 15 个。这是因为数组 a 中的重复值。</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="8f4d" class="mp mq it ml b gy mr ms l mt mu">len(np.unique(a))<br/>15</span></pre><p id="cba8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以用<strong class="lb iu"> fillna </strong>函数替换缺失值。我们可以使用一个常数来替换缺失值或列的统计数据，如平均值或中值。</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="9b70" class="mp mq it ml b gy mr ms l mt mu">df['num_3'].fillna(df['num_3'].mean(), inplace=True)<br/>df.isna().sum()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/7353e9412fd41e40e504826b954a3ac3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/1*lL2pYfmWbzLPgXvgJgecJw.png"/></div></figure></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><p id="38f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这只是你能为熊猫做的一小部分。你用它做得越多，你就会发现越多有用和实用的方法。我建议用不同的方法处理问题，永远不要给自己设限。</p><p id="961f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你努力寻找一个问题的解决方案时，你学到的东西几乎总是比手头问题的解决方案要多。您将逐步提高自己的技能，以建立一个强大而高效的数据分析流程。</p><p id="0f69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读。如果您有任何反馈，请告诉我。</p></div></div>    
</body>
</html>