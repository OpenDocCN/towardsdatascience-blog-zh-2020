<html>
<head>
<title>Fn Graph — Lightweight pipelines in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Fn 图 Python 中的轻量级管道</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/fn-graph-lightweight-pipelines-in-python-121f8d5f9ef6?source=collection_archive---------38-----------------------#2020-05-28">https://towardsdatascience.com/fn-graph-lightweight-pipelines-in-python-121f8d5f9ef6?source=collection_archive---------38-----------------------#2020-05-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/0e5ae4f2fc42eeca9666b6b2b5f7fce7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gKWs4h01dGOmxIu3PR8AMA.png"/></div></div></figure><div class=""/><div class=""><h2 id="8739" class="pw-subtitle-paragraph jy ja jb bd b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp dk translated">管理、维护和操作数据科学、财务或任何其他复杂的业务逻辑</h2></div><p id="e7c5" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">今天我们发布我们新的 Python 建模管道(或函数图)库<a class="ae lm" href="https://fn_graph.businessoptics.biz/" rel="noopener ugc nofollow" target="_blank"> <em class="ln"> fn_graph </em> </a>。过去十年来，我们一直在构建和运营各种类型的计算模型，无论是机器学习模型、金融模型还是通用数据管道。这个图书馆是我们过去所有学习的成果。</p><h1 id="ffb3" class="lo lp jb bd lq lr ls lt lu lv lw lx ly kh lz ki ma kk mb kl mc kn md ko me mf bi translated"><strong class="ak">什么是 fn_graph？</strong></h1><p id="4dcb" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated"><em class="ln"> fn_graph </em>是一个轻量级的库，让您可以轻松地在 python 中构建和可视化数据流样式的模型，然后轻松地将它们移动到您的生产环境中或嵌入到您的模型支持产品中。</p><p id="2721" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><em class="ln"> fn_graph </em>旨在改善车型生命周期的开发阶段、生产阶段和维护阶段。</p><h1 id="760f" class="lo lp jb bd lq lr ls lt lu lv lw lx ly kh lz ki ma kk mb kl mc kn md ko me mf bi translated"><strong class="ak">等等，我们说的模型是什么意思？</strong></h1><p id="357b" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated">模型是一个非常超载的术语，但这里我们指的是整体意义上的。这包括统计和机器学习模型，它们之前的数据准备逻辑，以及更经典的定量模型，如金融模型。与模型相关联的是进行测试、评估和配置的所有逻辑。</p><h1 id="fe18" class="lo lp jb bd lq lr ls lt lu lv lw lx ly kh lz ki ma kk mb kl mc kn md ko me mf bi translated"><strong class="ak">标准方法有什么“错误”？</strong></h1><p id="4dc7" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated">开发模型并将它们集成到生产系统或产品中的标准方法有许多令人恼火和低效的地方。标准模型开发生命周期可以(非常粗略地)分为 3 个阶段:</p><h2 id="0ec4" class="ml lp jb bd lq mm mn dn lu mo mp dp ly kz mq mr ma ld ms mt mc lh mu mv me mw bi translated">模型开发</h2><p id="5108" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated">模型开发需要调查任何基础数据、设计解决方案、准备数据、训练任何机器学习模型以及测试任何结果。这通常发生在 Jupyter 笔记本电脑中，也经常发生在分析师的笔记本电脑(或个人云实例)上。在这个阶段，快速迭代、尝试新想法并与相关利益相关者分享这些结果的能力是至关重要的。</p><p id="1adf" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">笔记本是数据社区的一大进步，但它们也有一些不尽人意的品质。主要问题是它们主要是为实验而构建的，而不是构建可重用的东西。这在学术界是很好的，在那里你主要是想展示一些可以做的事情或者证明一个特定的结果，用相关的可爱的标记、图表和一个写得很好的文化编程风格的叙述。不幸的是，令许多数据科学家新手失望的是，这不是工业界想要的。行业希望能够不止一次地运营某项业务，以便有希望实现盈利。</p><p id="d155" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">普遍的现实甚至更糟糕，大多数时候你不会得到一个漂亮的唐纳德·克努特风格的笔记本。相反，由于笔记本的性质，它不利于模块化，你会得到一堆难看的非常非结构化、未封装的代码，这些代码通常不会运行，除非这些单元以一种连作者都不知道的神奇顺序运行。对于一个适当复杂的领域，笔记本可能会变得非常长(因为记住将事情分解成模块并不容易，当你这样做时，你会失去轻松查看中间结果的能力)并且非常笨拙。</p><p id="3375" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这些考虑进一步扩展到模型生命周期中，我们将会谈到，但也横向扩展到可扩展性、可重用性和跨团队维护技术和机构知识的容易性等方面。</p><h2 id="5dc2" class="ml lp jb bd lq mm mn dn lu mo mp dp ly kz mq mr ma ld ms mt mc lh mu mv me mw bi translated"><strong class="ak">模型生产</strong></h2><p id="f042" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated">一旦分析师/数据科学家/建模师完成了他们的模型，结果得到了验证，所有的数字看起来都不错，下一个阶段就是将模型投入生产。对于不同的项目，这可能意味着不同的事情，但也可能是将它作为某种预定的任务转移到生产数据源之外，或者将其包装到 API 中，或者将其更深入地集成到现有产品的代码库中。</p><p id="01ce" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">无论是哪种情况，需求都与基于笔记本的模型开发阶段有很大的不同。模型开发阶段优先考虑能够快速尝试新事物，并能够深入检查模型的所有步骤和内部工作。相反，生产阶段优先考虑对模型进行清晰的封装，这种封装易于配置，并且可以端到端地重复运行。</p><p id="6177" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">所以经常发生的是笔记本被扔给生产工程师，他现在想要写模块化的合理可重用的代码，必须把它分成不同的函数、类等等。这不可避免地会产生微妙的错误，需要很长时间才能消除，特别是在统计模型中，测试比仅仅检查最终结果是否相等要困难得多。</p><p id="42eb" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如果模型没有被重写，它就会被包裹在一个可怕的大函数中，这使得调试、测试和维护变得非常困难，同时效率也非常低。</p><p id="9fd0" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">无论发生什么，该模型的一个版本已经准备好投入生产..事实就是如此。</p><h2 id="7c60" class="ml lp jb bd lq mm mn dn lu mo mp dp ly kz mq mr ma ld ms mt mc lh mu mv me mw bi translated"><strong class="ak">车型维护</strong></h2><p id="3c5e" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated">模型投入生产一段时间后，是时候做出改变了。这可能是因为需求发生了微小的变化，或者现在有了更多的数据和使用，结果没有给出最初期望的行为。</p><p id="0802" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这些变化需要分析师/数据科学家/建模师的技能，而不是生产工程师的技能，来进行和验证这些变化。请记住，我们实际上有两个版本的代码，分析师的笔记本和工程师的模块。这些人在行为上可能也有一些不同。</p><p id="f10b" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">分析师不能只使用工程师的产品代码，因为它被很好地封装，所以很难到达中间步骤，这可能是你需要研究的。因此，要么必须对原始笔记本进行修补和更新，以适应任何差异，要么必须将生产代码翻过来，平铺到另一个笔记本中。</p><p id="f85d" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">然后可以进行更改，必须重复之前的生产过程。这种情况会持续到产品的有效寿命。没那么有趣。</p><h1 id="2565" class="lo lp jb bd lq lr ls lt lu lv lw lx ly kh lz ki ma kk mb kl mc kn md ko me mf bi translated"><strong class="ak">fn _ graph 有什么帮助？</strong></h1><p id="08d9" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated">fn_graph 让你从普通的 python 函数中构建可组合的数据流风格管道(真正的图形)。它用最少的样板文件做到了这一点。这种结构允许在模型开发过程中探索和询问模型的细节，并且可以轻松地将整个管道导入到生产代码中，而无需任何更改。</p><p id="324d" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">该库的核心技巧是，它将函数参数名与函数名进行匹配，以构建图形。这留下了一个非常清晰的实现，其中一切都只是一个函数，但因为我们知道函数图的结构，它可以询问它并访问中间结果，这使得检查非常容易。因为每个函数都可以而且应该是纯的，因为它不应该有任何副作用，所以代码非常可靠并且容易推理。一旦这个我们称之为<strong class="ks jc"> Composer </strong>的函数图完成，它就是一个普通的 python 对象，可以导入到生产代码中，并调用结果。这在示例中更容易看到(取自<em class="ln"> fn_graph </em>信用模型示例)。</p><h1 id="ca15" class="lo lp jb bd lq lr ls lt lu lv lw lx ly kh lz ki ma kk mb kl mc kn md ko me mf bi translated">信贷建模示例</h1><p id="a16d" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated">我们有一个<code class="fe mx my mz na b">credit_data.csv</code>文件，该文件包含贷款账簿中大量贷款的信息，并且它有一个状态栏，其中包含值已付、违约和存活。其中已付表示贷款已还清，违约表示客户在还清贷款前已停止付款，最后还活着表示贷款仍在偿还。此外，它还具有贷款的许多属性以及剩余的未偿余额。这里的目标是训练一个模型，预测哪些贷款将被偿还，并最终计算出剩余图书的价值。</p><figure class="nb nc nd ne gt is"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="0ac5" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">现在我们将它们链接起来，添加到链接它们的<code class="fe mx my mz na b">Composer</code>:</p><figure class="nb nc nd ne gt is"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="48e6" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这将通过函数名和参数名链接两个函数(注意<code class="fe mx my mz na b">loan_data</code>是函数名，<code class="fe mx my mz na b">training_data</code>是参数名)。</p><p id="bcc2" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们可以通过(这在笔记本电脑环境中有效)查看这个(非常简单的图表):</p><figure class="nb nc nd ne gt is"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="2ebc" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这应该能让我们得到这个。</p><figure class="nb nc nd ne gt is gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/fa40abf136c58707795146d495cab648.png" data-original-src="https://miro.medium.com/v2/resize:fit:446/format:webp/1*kwo-XeSueUS_LBru40CyhA.png"/></div></figure><p id="7705" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们可以通过函数名查询结果:</p><figure class="nb nc nd ne gt is"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="b8a9" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这会给我们带来这样的结果</p><figure class="nb nc nd ne gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ni"><img src="../Images/9cc173c15020bffc3d07c5ae7de9a3e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ETzYBx4tIpR8ubfsu_tymg.png"/></div></div></figure><p id="a8a3" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这显然非常简单，所以让我们扩展一下。您可以浏览代码，细节并不重要，但应该是不言自明的。</p><figure class="nb nc nd ne gt is"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="1db3" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这就给出了下面的函数图:</p><figure class="nb nc nd ne gt is"><div class="bz fp l di"><div class="nf ng l"/></div></figure><figure class="nb nc nd ne gt is gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/d96b5ab0df8f456c97f71018c9df4cea.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/format:webp/1*WIO2ddymnbDQ09qnX1NkMQ.png"/></div></figure><p id="2b68" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">需要注意的是，很容易一眼就能对模型的流程有一个总体的感觉。此外，它在锅炉钢板上的含量极低。唯一的额外代码是每个函数多一行。fn_graph 也没有将你束缚于任何特定的数据结构或库，我们自由地将普通的 python 数据结构与 Pandas 数据帧甚至绘图混合。</p><p id="f7d7" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如果我们想调查，也可以很容易地查询中间结果:</p><figure class="nb nc nd ne gt is"><div class="bz fp l di"><div class="nf ng l"/></div></figure><h1 id="31c3" class="lo lp jb bd lq lr ls lt lu lv lw lx ly kh lz ki ma kk mb kl mc kn md ko me mf bi translated">Fn 图形工作室</h1><p id="11d6" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated">访问功能图的显式调用结构允许我们创建一些非常有趣的工具。一个与<em class="ln"> fn_graph </em>的兄弟项目是<a class="ae lm" href="https://github.com/BusinessOptics/fn_graph_studio/" rel="noopener ugc nofollow" target="_blank"> fn_graph_studio </a>，这是一个为<em class="ln"> fn_graph </em>作曲家设计的基于网络的浏览器。它允许用户浏览功能图，查看和操作结果。这在模型开发阶段是非常有用的(它伴随着热重新加载)，一旦部署，它可以被用来允许不太技术化的涉众仍然获得对模型的良好理解。工作室值得拥有自己的职位，但它是一个非常强大的机器，可以很好地增强笔记本电脑。</p><figure class="nb nc nd ne gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nk"><img src="../Images/c969394d2baf0db94ca0ee51a5bae550.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ei3X_4CtHxNKoRkkGlL9WA.png"/></div></div><p class="nl nm gj gh gi nn no bd b be z dk translated">Fn 图形工作室显示了作曲家的图形和熊猫的结果</p></figure><figure class="nb nc nd ne gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nk"><img src="../Images/6b52486f54ed0c04a3fef41b2ea28924.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bjGjuoS6yeG3FMWrchkL9Q.png"/></div></div><p class="nl nm gj gh gi nn no bd b be z dk translated">Fn Graph Studio 显示了 composer 图和 Seaborn 图</p></figure><h1 id="fcc6" class="lo lp jb bd lq lr ls lt lu lv lw lx ly kh lz ki ma kk mb kl mc kn md ko me mf bi translated">转向生产</h1><p id="7706" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated">因此，尽管 fn_graph 使模型开发变得更加容易和清晰，我们还没有讨论它如何使模型生产变得更加容易。最重要的是，您可以通过编程轻松地操作编写器，顾名思义，它允许您编写和管理逻辑。</p><p id="6a80" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">为了举例，让我们假设我们想把我们的风险模型打包在一个 API 中，这个 API 接受一个贷款帐本名称，根据某种映射从 S3 加载相关数据，然后返回结果。基本上，我们只是创建了一个函数，它接受一个字符串作为参数并返回一个数字。</p><p id="7cf6" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们能做的就是导入我们的 composer，然后更新它。</p><figure class="nb nc nd ne gt is"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="529f" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这更新了 loan_data 函数，用一个接受字符串输入并从 S3 加载相关文件的函数替换了以前从文件系统加载的函数。如果我们查看它的 graphviz，我们会看到 loan_data 函数现在接受了一个尚未提供的输入(因此它显示为一个红色错误节点)。</p><figure class="nb nc nd ne gt is gh gi paragraph-image"><div class="gh gi np"><img src="../Images/00ce4e23a3cb2aef6c700577794c982b.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/format:webp/1*TXNWhZea8_E3OGFwHvvgPQ.png"/></div></figure><p id="091f" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">对于像这样的情况，我们只想将输入输入到一个 composer 中，我们可以使用参数。最简单的例子是:</p><figure class="nb nc nd ne gt is"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="f4c2" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">它设置 loan_book 参数，然后调用结果。这非常容易用一个函数来包装:</p><figure class="nb nc nd ne gt is"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="8eeb" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">您可以在 flask endpoint 或任何其他地方轻松地调用它。</p><p id="2c97" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">请注意，我们不需要以任何方式重构我们的初始模型，如果对它进行了更改，它们会自动流入到产品中。</p><p id="d884" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">同样，如果您需要调查一个特定的结果，您可以下载一个文件并使用原始的 composer，或者直接调查生产 composer。这是可能的，因为您可以直接处理中间结果。例如:</p><figure class="nb nc nd ne gt is"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="4fbe" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这在通常封装的代码中是不可能的，比如生产工程师编写的代码，它会隐藏模型的内部。在这里，我们得到了两个世界的最好的东西，我们有一个很好的封装接口，能够调用最终结果(<code class="fe mx my mz na b">value_of_live_book</code>)，同时还可以访问内部工作。</p><h1 id="1086" class="lo lp jb bd lq lr ls lt lu lv lw lx ly kh lz ki ma kk mb kl mc kn md ko me mf bi translated">一些其他功能</h1><p id="0fc3" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated">其他几个功能被包括在内，或者自然地从<em class="ln"> fn_graph </em>中掉出。</p><h2 id="488d" class="ml lp jb bd lq mm mn dn lu mo mp dp ly kz mq mr ma ld ms mt mc lh mu mv me mw bi translated">复杂的组合和名称空间</h2><p id="1100" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated">一旦模型变大，它们就变得难以组织。为了帮助这个<em class="ln">，fn_graph </em>有了名称空间的概念。名称空间允许您将更小的子模型组合成更大的模型，确保它们没有命名冲突。与<em class="ln"> fn_graph_studio </em>相结合，它使得处理非常复杂的模型变得简单得多，更重要的是更容易解释和协作。我们已经建立了包含数百个函数的非常大的模型，如下所示，同时能够轻松地讨论和实现正在进行的更改。</p><figure class="nb nc nd ne gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nq"><img src="../Images/c83f4f19d7365f16109c32b0a3894846.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1ijx-yv5Fprxnncg6CqGJg.png"/></div></div></figure><h2 id="2476" class="ml lp jb bd lq mm mn dn lu mo mp dp ly kz mq mr ma ld ms mt mc lh mu mv me mw bi translated">贮藏</h2><p id="09c8" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated">分析师和数据科学家在他们的笔记本上反复实现的一个常见的东西是缓存。当处理甚至稍微大一点的数据集时，如果整个模型必须为每个变更完全重新运行，那么它会大大降低迭代时间(或者是完全禁止的)。这经常导致在笔记本上散布 if 语句，这些语句控制是计算一个值还是仅仅从先前保存的文件中提取它。随着一些灵巧的无序单元执行，这种工作方式会留下凌乱的笔记本，并且很难重现，逻辑中更糟糕的变化可能会被无意中忽略(缓存无效错误)，导致各种错误和浪费时间。</p><p id="7ab0" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">然而，由于<em class="ln"> fn_graph </em>具有依赖图或被称为缓存的函数，缓存失效变成了一个可以统一自动应用的简单练习。<em class="ln"> fn_graph </em>附带多个缓存后端，包括一个<code class="fe mx my mz na b">development_cache</code>，它将智能地缓存到磁盘，并在函数更改时使缓存无效。这使得缓存对用户完全透明。</p><h2 id="28b9" class="ml lp jb bd lq mm mn dn lu mo mp dp ly kz mq mr ma ld ms mt mc lh mu mv me mw bi translated">这只是普通的 Python 函数</h2><p id="0fa4" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated"><em class="ln"> fn_graph </em>的最大优势在于它实际上只是普通的 python 函数。没有必须学习的重量级对象模型，也没有复杂的运行时。</p><p id="ddc2" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">它对您可以使用的工具包没有任何限制，因为它实际上只是编排函数调用。你可以把它和你最喜欢的机器学习库、熊猫、纯 python 数据结构或者任何你需要的利基库一起使用。您可以集成到任何 web 服务器或您可能拥有的其他任务系统中，只要它可以调用 python 函数，就没有任何限制。</p><h1 id="c4aa" class="lo lp jb bd lq lr ls lt lu lv lw lx ly kh lz ki ma kk mb kl mc kn md ko me mf bi translated">听起来有趣吗？</h1><p id="7e95" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated">可以用 pip 安装<em class="ln"> fn_graph </em>，</p><pre class="nb nc nd ne gt nr na ns nt aw nu bi"><span id="56cf" class="ml lp jb na b gy nv nw l nx ny">pip install fn_graph</span></pre><p id="8c4d" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">你可能想安装<em class="ln"> fn_graph_studio </em>(它作为一个依赖项被分离出来，因为生产系统不需要它)，以及示例的依赖项。</p><pre class="nb nc nd ne gt nr na ns nt aw nu bi"><span id="3d68" class="ml lp jb na b gy nv nw l nx ny">pip install fn_graph_studio</span></pre><p id="9620" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">然后运行我们在这里提到的例子:</p><pre class="nb nc nd ne gt nr na ns nt aw nu bi"><span id="48dc" class="ml lp jb na b gy nv nw l nx ny">fn_graph_studio example credit</span></pre><p id="d3be" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">您也可以在<a class="ae lm" href="https://fn_graph.businessoptics.biz/" rel="noopener ugc nofollow" target="_blank">https://fn _ graph . business optics . biz/</a>找到实时画廊网站。你可以在<a class="ae lm" href="https://fn-graph.readthedocs.io/" rel="noopener ugc nofollow" target="_blank">https://fn-graph.readthedocs.io/en/latest/</a>找到文档，并查看 github 库:</p><ul class=""><li id="a8b4" class="nz oa jb ks b kt ku kw kx kz ob ld oc lh od ll oe of og oh bi translated"><a class="ae lm" href="https://github.com/BusinessOptics/fn_graph" rel="noopener ugc nofollow" target="_blank">https://github.com/BusinessOptics/fn_graph</a></li><li id="ac5d" class="nz oa jb ks b kt oi kw oj kz ok ld ol lh om ll oe of og oh bi translated"><a class="ae lm" href="https://github.com/BusinessOptics/fn_graph_studio" rel="noopener ugc nofollow" target="_blank">https://github.com/BusinessOptics/fn_graph_studio</a></li></ul><p id="658f" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们希望听到您的反馈。</p></div></div>    
</body>
</html>