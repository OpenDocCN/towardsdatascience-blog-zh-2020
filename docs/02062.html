<html>
<head>
<title>Movie Recommender System: Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">电影推荐系统:第一部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/movie-recommender-system-part-1-7f126d2f90e2?source=collection_archive---------10-----------------------#2020-02-27">https://towardsdatascience.com/movie-recommender-system-part-1-7f126d2f90e2?source=collection_archive---------10-----------------------#2020-02-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3f69" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何使用惊喜库构建推荐系统</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e2409118313fa6a7da2a0b99b1fbb910.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*56TfKdVVgmd9oGkl"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">查尔斯·德鲁维奥在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="1c84" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">简介:</h1><p id="ce11" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">所有的娱乐网站或网店都有几百万/几十亿的商品。对于客户来说，选择正确的产品变得非常困难。在这种情况下，推荐系统进入画面，并通过减少选项来帮助用户找到正确的项目。</p><p id="b143" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">什么是推荐系统？</strong></p><p id="c84c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">它通过建议一个可能的项目列表来帮助用户选择正确的项目，因此它已经成为电子商务、电影和音乐呈现网站的一个不可或缺的部分，并且这个列表还在继续。它们正在成为近年来变得越来越重要的机器学习的最流行的应用之一。两种最受欢迎的方法是:</p><p id="3a10" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">1- <a class="ae ky" href="https://en.wikipedia.org/wiki/Recommender_system#Content-based_filtering" rel="noopener ugc nofollow" target="_blank">基于内容的过滤</a></p><p id="781b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">2- <a class="ae ky" href="https://en.wikipedia.org/wiki/Recommender_system#Collaborative_filtering" rel="noopener ugc nofollow" target="_blank">协同过滤</a></p><p id="c4cb" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在这篇文章中，我们将关注<strong class="lt iu">矩阵分解</strong>，这是一种协同过滤的方法。</p><p id="e3a0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">矩阵分解</strong></p><p id="194a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在协同过滤中，<strong class="lt iu">矩阵分解</strong>是解决稀疏数据问题的最先进的解决方案，尽管它是从<a class="ae ky" href="https://www.netflixprize.com/" rel="noopener ugc nofollow" target="_blank"> <em class="ms"> Netflix 奖挑战赛</em> </a>开始广为人知的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mt"><img src="../Images/cde23f0cbba58492c501b89a415fbec4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YuR5gR7EVC8BsMP-y1YOsQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自本<a class="ae ky" href="https://medium.com/@connectwithghosh/simple-matrix-factorization-example-on-the-movielens-dataset-using-pyspark-9b7e3f567536" rel="noopener">网站</a></p></figure><p id="2c7f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在协同过滤的情况下，<strong class="lt iu">矩阵分解</strong>算法通过<strong class="lt iu">将</strong>用户-项目交互矩阵分解成两个<strong class="lt iu">低维度矩形矩阵</strong>的乘积来工作。一个矩阵可以被视为用户矩阵，其中行代表用户，列是潜在因素。另一个矩阵是项目矩阵，其中行是潜在因素，列代表项目。”——<a class="ae ky" href="https://en.wikipedia.org/wiki/Matrix_factorization_(recommender_systems)" rel="noopener ugc nofollow" target="_blank">维基百科</a></p><p id="02de" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们将与电影分级数据集<strong class="lt iu"> MoiveLens </strong> <a class="ae ky" href="https://grouplens.org/datasets/movielens/100k/" rel="noopener ugc nofollow" target="_blank">数据集</a>合作，使用<a class="ae ky" href="http://surpriselib.com/" rel="noopener ugc nofollow" target="_blank">T5】SurpriseT7】库“用于推荐系统的 Python scikit”开发一个推荐系统。我们开始吧！</a></p><h1 id="18d8" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">数据</h1><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="2d22" class="mz la it mv b gy na nb l nc nd">ratings = pd.read_csv('data/ratings.csv')</span><span id="8d74" class="mz la it mv b gy ne nb l nc nd">ratings.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/01d1135c293a6ece13d7b05e205dc39d.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*uBWPj-1VNP_GgG4NKbGsyA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">评分表的屏幕截图</p></figure><p id="f616" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为了从上面的 pandas 数据框加载数据集，我们将使用<strong class="lt iu"> load_from_df() </strong>方法，我们还需要一个<strong class="lt iu"> Reader 对象</strong>，并且必须指定<strong class="lt iu"> rating_scale </strong>参数。</p><p id="801d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">数据框必须有三列，依次对应于用户 id、项目 id 和等级。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="6f63" class="mz la it mv b gy na nb l nc nd">reader = Reader(rating_scale=(0.5, 5.0))</span><span id="9a95" class="mz la it mv b gy ne nb l nc nd">data = Dataset.load_from_df(df[['userID', 'itemID', 'rating']], reader)</span></pre><p id="02ce" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">评级分布</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/8c37a88cd5603fbdb47a0cbc53fc5c49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tVug5_UYkae5_Xe_ow9rNA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 1</p></figure><p id="f802" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">项目评级分布</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/dcc6dbebdac3b8a3eba21e6c8087af3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MSBcHGp3pPdF24qHRNAqaA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 2</p></figure><p id="c912" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">按用户的评分分布</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/888f920d4246699f3d2787ec1abeaed4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wPHvg9ZzyubZM5V36dq2fA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 3</p></figure></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="99c4" class="kz la it bd lb lc no le lf lg np li lj jz nq ka ll kc nr kd ln kf ns kg lp lq bi translated">惊喜——型号选择</h1><p id="048a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><a class="ae ky" href="http://surpriselib.com/" rel="noopener ugc nofollow" target="_blank"> Surprise </a>是一个 Python scikit，用于构建和分析处理显式评级数据的推荐系统。由 Nicolas Hug 维护。</p><p id="e2f2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">使用 pip(你需要 NumPy 和一个 C 编译器。Windows 用户可能更喜欢使用 conda):</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="3cf9" class="mz la it mv b gy na nb l nc nd">!pip install numpy</span><span id="679f" class="mz la it mv b gy ne nb l nc nd">!pip install scikit-surprise</span><span id="cf3e" class="mz la it mv b gy ne nb l nc nd">#For Windows users<br/>conda install -c conda-forge scikit-surprise</span></pre><p id="3b53" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们将使用<a class="ae ky" href="https://en.wikipedia.org/wiki/Root-mean-square_deviation" rel="noopener ugc nofollow" target="_blank"><strong class="lt iu"/></a><strong class="lt iu"/>作为我们预测的准确性度量。</p><p id="5fe7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们将比较<strong class="lt iu">奇异值分解、NMF、正常预测值、KNN 基本值</strong>，并将使用具有最小 RMSE 值的一个。</p><p id="c3e0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在我们开始应用之前对算法有一些了解。</p><p id="71f0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu"> 1:正态预测器:</strong>它根据训练集的分布预测一个随机的评级，假设它是正态的。这是一个基本的算法，不需要做太多的工作，但对于比较精度仍然很有用。</p><p id="5261" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu"> 2: SVD: </strong>它是由西蒙·芬克在网飞奖期间推广的，是一种矩阵分解算法。如果不使用基线，它相当于 PMF。</p><p id="caf0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu"> 3: NMF: </strong>基于非负矩阵分解，类似于 SVD。</p><p id="b467" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu"> 4: KNN 基本:</strong>这是一种基本的协同过滤算法方法。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="8d09" class="mz la it mv b gy na nb l nc nd">benchmark = []</span><span id="fc1d" class="mz la it mv b gy ne nb l nc nd"># Iterate over all algorithms<br/>for algorithm in [SVD(), NMF(), NormalPredictor(), KNNBasic()]:</span><span id="5e23" class="mz la it mv b gy ne nb l nc nd"># Perform cross validation<br/>results = cross_validate(algorithm, data, measures=['RMSE'], cv=3, verbose=False)</span><span id="8ae8" class="mz la it mv b gy ne nb l nc nd"># Get results &amp; append algorithm name<br/>tmp = pd.DataFrame.from_dict(results).mean(axis=0)</span><span id="5e1d" class="mz la it mv b gy ne nb l nc nd">tmp = tmp.append(pd.Series([str(algorithm).split(' ')[0].split('.')[-1]],index=['Algorithm']))</span><span id="b747" class="mz la it mv b gy ne nb l nc nd">benchmark.append(tmp)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/0a9ca621c162a99f53171ef0943f498e.png" data-original-src="https://miro.medium.com/v2/resize:fit:814/format:webp/1*mus9FgTzEdG-Cjtce2ImgQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">结果截图</p></figure><p id="63d9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">由于奇异值分解具有最小的 RMSE 值，我们将调整奇异值分解的超参数。</p><p id="f41a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">使用<strong class="lt iu"> GridSearchCV </strong>调整算法参数，找到算法的最佳参数。</p><p id="9891" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">SVD 的默认值为:</p><p id="5641" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">n _ factors</strong>—100 |<strong class="lt iu">n _ epochs</strong>—20 |<strong class="lt iu">lr _ all</strong>—0.005 |<strong class="lt iu">reg _ all</strong>—0.02</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="26e0" class="mz la it mv b gy na nb l nc nd">param_grid = {'n_factors': [25, 30, 35, 40, 100], 'n_epochs': [15, 20, 25], 'lr_all': [0.001, 0.003, 0.005, 0.008],               'reg_all': [0.08, 0.1, 0.15, 0.02]}</span><span id="0a56" class="mz la it mv b gy ne nb l nc nd">gs = GridSearchCV(SVD, param_grid, measures=['rmse', 'mae'], cv=3)<br/>gs.fit(data) algo = gs.best_estimator['rmse']</span><span id="6f8c" class="mz la it mv b gy ne nb l nc nd">print(gs.best_score['rmse']) <br/>print(gs.best_params['rmse'])</span><span id="feb2" class="mz la it mv b gy ne nb l nc nd"><em class="ms">#Assigning values<br/></em>t = gs.best_params factors = t['rmse']['n_factors']<br/>epochs = t['rmse']['n_epochs'] <br/>lr_value = t['rmse']['lr_all']<br/>reg_value = t['rmse']['reg_all']</span></pre><p id="77e0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><em class="ms">输出</em> : 0.8682 {'n_factors': 35，' n_epochs': 25，' lr_all': 0.008，' reg_all': 0.08}</p><p id="251c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在，我们有了一组正确的超参数值，让我们将数据分成训练:测试和拟合模型。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="8dc7" class="mz la it mv b gy na nb l nc nd">trainset, testset = train_test_split(data, test_size=0.25)</span><span id="62d8" class="mz la it mv b gy ne nb l nc nd">algo = SVD(n_factors=factors, n_epochs=epochs, lr_all=lr_value, reg_all=reg_value)</span><span id="d582" class="mz la it mv b gy ne nb l nc nd">predictions = algo.fit(trainset).test(testset)<br/>accuracy.rmse(predictions)</span></pre><p id="7277" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><em class="ms">产量:</em> RMSE: 0.8662</p><h2 id="0fc0" class="mz la it bd lb nu nv dn lf nw nx dp lj ma ny nz ll me oa ob ln mi oc od lp oe bi translated">让我们来看看我们的预测是好是坏:</h2><p id="79ab" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">以下函数将创建一个包含以下列的 pandas 数据框:</p><p id="4081" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu"> UID: </strong>用户标识</p><p id="5451" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu"> iid: </strong>项目 id</p><p id="9784" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">芮:</strong>用户给出的评分</p><p id="71f6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">预计:</strong>由模型估计的评级</p><p id="4853" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu"> Iu: </strong>用户评分的项目数</p><p id="3a80" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu"> UI: </strong>对此项目评分的用户数</p><p id="1e28" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu"> err: </strong> abs 预测评级与实际评级之间的差异。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="f792" class="mz la it mv b gy na nb l nc nd">def get_Iu(uid):</span><span id="47fb" class="mz la it mv b gy ne nb l nc nd">"""<br/>args: <br/>uid: the id of the user</span><span id="7c00" class="mz la it mv b gy ne nb l nc nd">returns:<br/>the number of items rated by the user<br/>"""</span><span id="92e1" class="mz la it mv b gy ne nb l nc nd">try:<br/>    return len(trainset.ur[trainset.to_inner_uid(uid)])<br/>except ValueError: # user was not part of the trainset<br/>    return 0</span><span id="5566" class="mz la it mv b gy ne nb l nc nd">def get_Ui(iid):</span><span id="417f" class="mz la it mv b gy ne nb l nc nd">"""<br/>args:<br/>iid: the raw id of the item</span><span id="b366" class="mz la it mv b gy ne nb l nc nd">returns:<br/>the number of users that have rated the item.<br/>"""</span><span id="5dfa" class="mz la it mv b gy ne nb l nc nd">try:<br/>   return len(trainset.ir[trainset.to_inner_iid(iid)])<br/>except ValueError:<br/>   return 0</span><span id="a7f4" class="mz la it mv b gy ne nb l nc nd">df_predictions = pd.DataFrame(predictions, columns=['uid', 'iid', 'rui', 'est', 'details'])</span><span id="5384" class="mz la it mv b gy ne nb l nc nd">df_predictions['Iu'] = df_predictions.uid.apply(get_Iu)</span><span id="8c0b" class="mz la it mv b gy ne nb l nc nd">df_predictions['Ui'] = df_predictions.iid.apply(get_Ui)</span><span id="560f" class="mz la it mv b gy ne nb l nc nd">df_predictions['err'] = abs(df_predictions.est - df_predictions.rui)</span></pre><p id="c1ae" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">最佳预测:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="1052" class="mz la it mv b gy na nb l nc nd">best_predictions = df_predictions.sort_values(by='err')[:10]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/4706dacd69630feb0b018d1e069f6654.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/1*QOynzXmEo3bMy7tlI3hnKg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">最佳预测的屏幕截图</p></figure><p id="c275" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">最坏的预测:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="ae0a" class="mz la it mv b gy na nb l nc nd">worst_predictions = df_predictions.sort_values(by='err')[-10:]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/6dbcd2e8f2d2ef0c4420a0484e2d5d0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*o8g62XYs5NzgmYaGMEu8IA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">最差预测截图</p></figure><p id="468e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">最糟糕的预测看起来相当令人惊讶。让我们来看看“3996”项的更多细节，它的评分为 0.5，我们的 SVD 算法预测为 4.4</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/102864229c9b61afee1927f3b616c281.png" data-original-src="https://miro.medium.com/v2/resize:fit:506/format:webp/1*vRhD0D5m5FsgUnZOMyDSQA.png"/></div></figure><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="d894" class="mz la it mv b gy na nb l nc nd">df.loc[df['itemID'] == 3996]['rating'].describe()</span><span id="44f6" class="mz la it mv b gy ne nb l nc nd">temp = df.loc[df['itemID'] == 3996]['rating']</span><span id="c13c" class="mz la it mv b gy ne nb l nc nd"># Create trace<br/>trace = go.Histogram(x = temp.values, name = 'Ratings', xbins = dict(start = 0, end = 5, size=.3))</span><span id="daaf" class="mz la it mv b gy ne nb l nc nd"># Create layout<br/>layout = go.Layout(title = 'Number of ratings item 3996 has received', xaxis = dict(title = 'Number of Ratings Per Item'), yaxis = dict(title = 'Count'), bargap = 0.2)</span><span id="4c6b" class="mz la it mv b gy ne nb l nc nd"># Create plot<br/>fig = go.Figure(data=[trace], layout=layout)<br/>iplot(fig)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/d1322a170e4c47553442c8d7c2290290.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gzRTA_sM2JmygauUJXfLeA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 4</p></figure><p id="6ba1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">事实证明，该商品获得的大多数评级都在“3 到 5”之间，只有<strong class="lt iu"> 1% </strong>的用户评级为“0.5”，有一个用户的评级低于 3。似乎对于每一个预测，用户都是某种<strong class="lt iu">离群值</strong>并且这个项目被评价的次数很少。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><p id="dfc3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">看起来你很喜欢这篇文章！</p><ul class=""><li id="2435" class="oi oj it lt b lu mn lx mo ma ok me ol mi om mm on oo op oq bi translated">您刚刚阅读了第 1 部分，其中介绍了如何使用 Surprise library 在显式数据上构建模型。</li><li id="e21b" class="oi oj it lt b lu or lx os ma ot me ou mi ov mm on oo op oq bi translated"><strong class="lt iu"> Part 2 </strong>将通过计算 K 处的精度和召回率，然后推荐 K 部电影，来涵盖我们应该推荐多少部电影。</li></ul><p id="e6d9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">完整的代码，你可以在这里找到 Jupyter 笔记本<a class="ae ky" href="https://github.com/divensambhwani/MovieLens-100K_Recommender-System/blob/master/MovieLens-100K-Recommeder%20System-SVD.ipynb" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="1058" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果你有任何想法或建议，请不吝赐教。你也可以通过 LinkedIn 联系我</p><p id="d5c8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">编码快乐！</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h2 id="0f41" class="mz la it bd lb nu nv dn lf nw nx dp lj ma ny nz ll me oa ob ln mi oc od lp oe bi translated">参考资料:</h2><p id="593d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">[1]<a class="ae ky" href="https://surprise.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank">https://surprise.readthedocs.io/en/stable/</a></p><p id="187f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">[2]<a class="ae ky" rel="noopener" target="_blank" href="/prototyping-a-recommender-system-step-by-step-part-2-alternating-least-square-als-matrix-4a76c58714a1">https://towards data science . com/prototyping-a-recommender-system-step-by-step-part-2-alternating-least-square-als-matrix-4a 76 c 58714 a 1</a></p><p id="861c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">[3]<a class="ae ky" href="https://medium.com/@connectwithghosh/simple-matrix-factorization-example-on-the-movielens-dataset-using-pyspark-9b7e3f567536" rel="noopener">https://medium . com/@ connectwithgosh/simple-matrix-factorization-example-on-the-movie lens-dataset-using-py spark-9b 7 E3 f 567536</a></p><p id="9728" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">[4]<a class="ae ky" href="https://en.wikipedia.org/wiki/Matrix_factorization_(recommender_systems)" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Matrix _ factorization _(recommender _ systems)</a></p></div></div>    
</body>
</html>