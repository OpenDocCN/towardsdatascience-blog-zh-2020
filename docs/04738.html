<html>
<head>
<title>Get started with Graph Theory</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">图论入门</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/get-started-with-graph-theory-2b4460eeafc?source=collection_archive---------31-----------------------#2020-04-26">https://towardsdatascience.com/get-started-with-graph-theory-2b4460eeafc?source=collection_archive---------31-----------------------#2020-04-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="da7e" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="http://towardsdatascience.com/tagged/graph-theory-simplified" rel="noopener" target="_blank">图论简化版</a></h2><div class=""/><div class=""><h2 id="f462" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">图论简介</h2></div><blockquote class="kr ks kt"><p id="5ff1" class="ku kv kw kx b ky kz kd la lb lc kg ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这是我全新系列<a class="ae lr" href="https://medium.com/@kelvinjose/graph-theory-go-hero-1b5917da4fc1" rel="noopener"> <strong class="kx jd">图论:围棋英雄</strong> </a> <strong class="kx jd">的第一个帖子。查看本系列下一篇文章的索引页面。它总是得到很好的维护和更新。</strong></p></blockquote><p id="01d1" class="pw-post-body-paragraph ku kv it kx b ky kz kd la lb lc kg ld ls lf lg lh lt lj lk ll lu ln lo lp lq im bi translated">图论本质上是对图或网络的性质和应用的研究。正如我上面提到的，这是一个巨大的主题，本系列的目标是了解如何应用图论来解决现实世界的问题。如果我们看看我们生活的前提，我们可以看到许多问题突然出现，这些问题又可以被建模为图表。例如，从所有给定的类别中选择一个服装组合可以被认为是一个完美的场景。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi lv"><img src="../Images/416999b57f8baf3c89125209f81aef54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9NaTWnSvRXPv4bewvIhMNQ.png"/></div></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">作者照片</p></figure><p id="eda4" class="pw-post-body-paragraph ku kv it kx b ky kz kd la lb lc kg ld ls lf lg lh lt lj lk ll lu ln lo lp lq im bi translated">如果我们从每个类别中选择一件商品，比如从帽子中选择一件，从T恤衫中选择另一件，等等，我们最终会有n个可能的选项。我们这里的限制是，每个类别只有有限数量的资源。尽管如此，我们还是有相当多的组合。在这种情况下，我们可以使用图表来展示每个<strong class="kx jd">节点</strong>中不同类别的服装，以及它们之间通过<strong class="kx jd">边</strong>的关系。希望节点和边背后的想法大家都知道。如果没有，节点可以被认为是每个类别的每个项目，例如，红色的帽子是一个节点，绿色的裤子也是一个节点。不同节点之间的关系可以使用边来描述，即从红色帽子到蓝色t恤。</p><p id="5551" class="pw-post-body-paragraph ku kv it kx b ky kz kd la lb lc kg ld ls lf lg lh lt lj lk ll lu ln lo lp lq im bi translated">图的另一个典型例子是朋友的社交网络。将数据可视化到图表上使我们能够生成并回答关于数据的不同有趣问题。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi ml"><img src="../Images/25b89b53b38afc9ce6a2d1552ad13cbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kiLOLZ6ERMeJ_wHmjgHitQ.png"/></div></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">来自<a class="ae lr" href="https://images.app.goo.gl/Hvgbm5xkk4o9qFNA9" rel="noopener ugc nofollow" target="_blank">触摸屏</a>的截图</p></figure><p id="6f4d" class="pw-post-body-paragraph ku kv it kx b ky kz kd la lb lc kg ld ls lf lg lh lt lj lk ll lu ln lo lp lq im bi translated">在社交网络的情况下，我们可以问这样的问题:约翰有多少朋友，或者凯西和米兰之间有多少共同的朋友。</p><h2 id="4d16" class="mm mn it bd mo mp mq dn mr ms mt dp mu ls mv mw mx lt my mz na lu nb nc nd iz bi translated">图形的类型</h2><p id="6864" class="pw-post-body-paragraph ku kv it kx b ky ne kd la lb nf kg ld ls ng lg lh lt nh lk ll lu ni lo lp lq im bi translated">有不同类型的图形表示可用，我们必须确保在编程解决包含图形的问题时，我们理解我们正在处理的图形的类型。</p><ul class=""><li id="635a" class="nj nk it kx b ky kz lb lc ls nl lt nm lu nn lq no np nq nr bi translated"><strong class="kx jd">无向图</strong></li></ul><p id="7694" class="pw-post-body-paragraph ku kv it kx b ky kz kd la lb lc kg ld ls lf lg lh lt lj lk ll lu ln lo lp lq im bi translated">顾名思义，节点之间不会有任何指定的方向。因此，从节点A到B的边与从B到A的边是相同的。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi ns"><img src="../Images/87956f93eff892b7198957246f723a59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6Msjx8JlREi8qqhGZq6-fg.png"/></div></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">照片<a class="ae lr" href="https://www.researchgate.net/profile/Hakan_Terelius" rel="noopener ugc nofollow" target="_blank">researchgate.net的哈坎·特拉利乌斯</a></p></figure><p id="3053" class="pw-post-body-paragraph ku kv it kx b ky kz kd la lb lc kg ld ls lf lg lh lt lj lk ll lu ln lo lp lq im bi translated">在上图中，每个节点可以代表不同的城市，边显示双向道路。</p><ul class=""><li id="0f93" class="nj nk it kx b ky kz lb lc ls nl lt nm lu nn lq no np nq nr bi translated"><strong class="kx jd">有向图</strong></li></ul><p id="a890" class="pw-post-body-paragraph ku kv it kx b ky kz kd la lb lc kg ld ls lf lg lh lt lj lk ll lu ln lo lp lq im bi translated">与无向图不同，有向图在不同的节点之间有方向或者说<strong class="kx jd">方向</strong>。这意味着如果你有一条从节点A到B的边，你只能从A移动到B。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi nt"><img src="../Images/7d7c01e47db4415c586f6337fd577c14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oaDzFhFJ_efgg98kvwqv3g.png"/></div></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">来自<a class="ae lr" href="https://upload.wikimedia.org/wikipedia/commons/5/51/Directed_graph.svg" rel="noopener ugc nofollow" target="_blank">维基媒体</a>的截图</p></figure><p id="90c7" class="pw-post-body-paragraph ku kv it kx b ky kz kd la lb lc kg ld ls lf lg lh lt lj lk ll lu ln lo lp lq im bi translated">和前面的例子一样，如果我们把节点看作城市，我们有一个从城市1到城市2的方向。这意味着，你可以从城市1开车到城市2，但不能回到城市1，因为没有从城市2回到城市1的方向。但是如果我们仔细观察图表，我们可以看到双向的城市。例如，城市3和4有指向两边的方向。</p><ul class=""><li id="dee6" class="nj nk it kx b ky kz lb lc ls nl lt nm lu nn lq no np nq nr bi translated"><strong class="kx jd">加权图</strong></li></ul><p id="b0c1" class="pw-post-body-paragraph ku kv it kx b ky kz kd la lb lc kg ld ls lf lg lh lt lj lk ll lu ln lo lp lq im bi translated">许多图可以有包含权重的边，以表示真实世界的含义，如成本、距离、数量等</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/af944daee3a49f84a104997c20d2fc39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*2bQp_HBMw600MEzCIehZxQ.png"/></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">照片由<a class="ae lr" href="https://www.freecodecamp.org/news/author/estefaniacn/" rel="noopener ugc nofollow" target="_blank">Estefania Cassingena Navone</a>通过<a class="ae lr" href="https://cdn-media-1.freecodecamp.org/images/H1ASU4s0MP52QUyuqo4LIjlvZcR4kn7lkq2V" rel="noopener ugc nofollow" target="_blank">freecodecamp.org</a>拍摄</p></figure><p id="f5f0" class="pw-post-body-paragraph ku kv it kx b ky kz kd la lb lc kg ld ls lf lg lh lt lj lk ll lu ln lo lp lq im bi translated">加权图可以是有向图，也可以是无向图。在这个例子中，我们有一个无向加权图。从绿色节点到橙色节点的成本或距离是3，反之亦然。我们可以将这种关系表示为类似于<strong class="kx jd"> (u，v，w) </strong>的三元组，该三元组显示了边从哪里进入、去往哪里以及两个节点之间的成本或距离。就像我们之前的例子一样，如果你想在两个城市之间旅行，比如城市绿色和橙色，我们将不得不支付3美元的费用，或者换句话说，我们将不得不开车3英里。这些指标是自定义的，可以根据情况进行更改。对于一个更详细的例子，考虑你必须从绿色到粉红色的城市。如果你看看城市图，我们找不到两个城市之间的任何直接道路或边缘。所以我们能做的就是经由另一个城市旅行。最有希望的路线是从绿色开始，经过橙色和蓝色，变成粉红色。如果权重是城市之间的成本，我们将不得不花费11美元通过蓝色到达粉红色，但如果我们通过橙色选择另一条路线，我们将只需支付10美元。</p><h2 id="e837" class="mm mn it bd mo mp mq dn mr ms mt dp mu ls mv mw mx lt my mz na lu nb nc nd iz bi translated">特殊图形</h2><p id="67c7" class="pw-post-body-paragraph ku kv it kx b ky ne kd la lb nf kg ld ls ng lg lh lt nh lk ll lu ni lo lp lq im bi translated">除了上面的划分，我们还有另一组图叫做特殊图。</p><ul class=""><li id="2eec" class="nj nk it kx b ky kz lb lc ls nl lt nm lu nn lq no np nq nr bi translated"><strong class="kx jd">树</strong></li></ul><p id="fb59" class="pw-post-body-paragraph ku kv it kx b ky kz kd la lb lc kg ld ls lf lg lh lt lj lk ll lu ln lo lp lq im bi translated">最重要的特殊图是树。这是一个没有圈的无向图。等价地，它有<strong class="kx jd"> N </strong>个节点和<strong class="kx jd"> N — 1 </strong>条边。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi nv"><img src="../Images/f484443577f74a7ba9bbc5cad5bdd5e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SOn1af6II3-ULdl-hoK4Hw.png"/></div></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">作者照片</p></figure><p id="8890" class="pw-post-body-paragraph ku kv it kx b ky kz kd la lb lc kg ld ls lf lg lh lt lj lk ll lu ln lo lp lq im bi translated">上面给出的所有图都是树，甚至最左边的图也是，因为它没有圈。</p><ul class=""><li id="fdf8" class="nj nk it kx b ky kz lb lc ls nl lt nm lu nn lq no np nq nr bi translated"><strong class="kx jd">有根树</strong></li></ul><p id="28c7" class="pw-post-body-paragraph ku kv it kx b ky kz kd la lb lc kg ld ls lf lg lh lt lj lk ll lu ln lo lp lq im bi translated">有根树是具有指定的根节点的树，其中所有其他节点或者朝向根或者远离根。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi nw"><img src="../Images/5d097852f50d8d532e508e835433d381.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*djNshdU76nK9JbdEzemRJA.png"/></div></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">作者照片</p></figure><p id="fb0b" class="pw-post-body-paragraph ku kv it kx b ky kz kd la lb lc kg ld ls lf lg lh lt lj lk ll lu ln lo lp lq im bi translated">红色的节点是根节点。最左边的树被称为<strong class="kx jd">树内</strong>，因为所有其他节点都向根节点靠近。另外两棵树是<strong class="kx jd">外树</strong>，因为所有其他节点都离开了根。</p><ul class=""><li id="c4f5" class="nj nk it kx b ky kz lb lc ls nl lt nm lu nn lq no np nq nr bi translated"><strong class="kx jd">有向无环图</strong> ( <strong class="kx jd"> DAG </strong> s)</li></ul><p id="a3c5" class="pw-post-body-paragraph ku kv it kx b ky kz kd la lb lc kg ld ls lf lg lh lt lj lk ll lu ln lo lp lq im bi translated">Dag是没有圈的有向图。这些图在表示具有依赖关系的结构(如调度程序和编译器)时起着重要的作用。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/05ace8ae867eb5eb2306c1efd931969f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*7SkwwALwvBgNnYAFp-oS_A.png"/></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">作者照片</p></figure><p id="8779" class="pw-post-body-paragraph ku kv it kx b ky kz kd la lb lc kg ld ls lf lg lh lt lj lk ll lu ln lo lp lq im bi translated">我们可以用这个图来表示有意义的事物之间的拓扑顺序。例如，如果我们在流程管理器中使用DAGs，我们可以说子流程x和y应该在继续处理z之前完成。</p><ul class=""><li id="a08c" class="nj nk it kx b ky kz lb lc ls nl lt nm lu nn lq no np nq nr bi translated"><strong class="kx jd">二部图</strong></li></ul><p id="8303" class="pw-post-body-paragraph ku kv it kx b ky kz kd la lb lc kg ld ls lf lg lh lt lj lk ll lu ln lo lp lq im bi translated">二部图的顶点可以分成两个不相交的集合，比如U和V，其中图中的每条边连接U和V之间的顶点。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/d4a6f29da0af0727c699758328445e18.png" data-original-src="https://miro.medium.com/v2/resize:fit:912/1*7xQtzFVm8s9faeqdk1a0hQ.gif"/></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">截图来自<a class="ae lr" href="https://mathworld.wolfram.com/BipartiteGraph.html" rel="noopener ugc nofollow" target="_blank"> Wolfram Mathworld </a></p></figure><p id="b428" class="pw-post-body-paragraph ku kv it kx b ky kz kd la lb lc kg ld ls lf lg lh lt lj lk ll lu ln lo lp lq im bi translated">如果我们看这个图，我们可以看到每个图可以分成两个不相交的集合(U，V ),每个边连接U和V之间的节点。</p><ul class=""><li id="7da3" class="nj nk it kx b ky kz lb lc ls nl lt nm lu nn lq no np nq nr bi translated"><strong class="kx jd">完整图形</strong></li></ul><p id="be60" class="pw-post-body-paragraph ku kv it kx b ky kz kd la lb lc kg ld ls lf lg lh lt lj lk ll lu ln lo lp lq im bi translated">我们称一个图为完全的当且仅当，每一对顶点之间有唯一的边连接。具有n个顶点的完整图被表示为<strong class="kx jd"> Kn。</strong></p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/0fdb4f550473b2a649e2316cb58e456c.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/1*sQ2GOzcoevWrv9shpgygpA.gif"/></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">截图来自<a class="ae lr" href="https://mathworld.wolfram.com/CompleteGraph.html" rel="noopener ugc nofollow" target="_blank"> Wolfrom Mathworld </a></p></figure><p id="465f" class="pw-post-body-paragraph ku kv it kx b ky kz kd la lb lc kg ld ls lf lg lh lt lj lk ll lu ln lo lp lq im bi translated">由于要遍历的边的数量，完全图被认为是最坏情况图。</p><h2 id="4f57" class="mm mn it bd mo mp mq dn mr ms mt dp mu ls mv mw mx lt my mz na lu nb nc nd iz bi translated">图形的表示</h2><p id="6588" class="pw-post-body-paragraph ku kv it kx b ky ne kd la lb nf kg ld ls ng lg lh lt nh lk ll lu ni lo lp lq im bi translated">在这里，我们讨论如何在内存中存储一个图形，以便进一步处理。</p><ul class=""><li id="47cc" class="nj nk it kx b ky kz lb lc ls nl lt nm lu nn lq no np nq nr bi translated"><strong class="kx jd">邻接矩阵</strong></li></ul><p id="1384" class="pw-post-body-paragraph ku kv it kx b ky kz kd la lb lc kg ld ls lf lg lh lt lj lk ll lu ln lo lp lq im bi translated">有效的方法是使用大小为NxN的矩阵，其中N是节点的数量。我们称这个矩阵为邻接矩阵。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/9f229cf9e80e98a9c483c07e7a7968b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/1*zgir6kheFy-ghRR8n3eI3A.png"/></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">截图来自<a class="ae lr" href="https://www.softwaretestinghelp.com/graph-implementation-cpp/" rel="noopener ugc nofollow" target="_blank">softwaretestinghelp.com</a></p></figure><p id="e83e" class="pw-post-body-paragraph ku kv it kx b ky kz kd la lb lc kg ld ls lf lg lh lt lj lk ll lu ln lo lp lq im bi translated">上面给出的是一个有向加权图及其对应的邻接矩阵<strong class="kx jd"> M </strong>。该矩阵的大小为5×5，因为总共有5个节点。从节点A到B的成本是4，在<strong class="kx jd"> M[A][B]中给出。</strong>类似地，从一个节点到其自身的成本是零，因此所有对角线元素将总是零。这是存储密集结构的图形信息的空间有效的方法，并且边查找将总是花费恒定的时间。但是，随着节点数量的增加，跟踪边信息所需的空间也将呈指数增长。如果大部分的边都没有适当的信息，我们将最终建立一个稀疏矩阵。</p><ul class=""><li id="b687" class="nj nk it kx b ky kz lb lc ls nl lt nm lu nn lq no np nq nr bi translated"><strong class="kx jd">邻接表</strong></li></ul><p id="3cb2" class="pw-post-body-paragraph ku kv it kx b ky kz kd la lb lc kg ld ls lf lg lh lt lj lk ll lu ln lo lp lq im bi translated">我们用来存储节点和边信息的另一个重要结构是邻接表。这是从节点到边列表的映射。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi ns"><img src="../Images/e1dec802060a3a60446bdfd5178c4452.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hp2KqklR9nTYWxE2u-EGVA.png"/></div></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">摄影:苏伦德·巴斯瓦纳经由researchgate.net</p></figure><p id="23fa" class="pw-post-body-paragraph ku kv it kx b ky kz kd la lb lc kg ld ls lf lg lh lt lj lk ll lu ln lo lp lq im bi translated">给出的例子是一个无向加权图。如果我们看最右边的图，我们可以看到从每个顶点开始的几个列表。节点1有两条输出边，即2和5，我们用它的成本来表示这些信息。列表中的每个元素都有目标节点和相应的成本或权重。</p><p id="ceb6" class="pw-post-body-paragraph ku kv it kx b ky kz kd la lb lc kg ld ls lf lg lh lt lj lk ll lu ln lo lp lq im bi translated">如果邻接表是稀疏的，则邻接表是存储图信息的有效机制，即，与相同情况下的邻接矩阵相比，邻接表将占用更少的存储器。但是，这仍然是一个比邻接矩阵稍微复杂的表示。</p><ul class=""><li id="03f7" class="nj nk it kx b ky kz lb lc ls nl lt nm lu nn lq no np nq nr bi translated"><strong class="kx jd">边缘列表</strong></li></ul><p id="0917" class="pw-post-body-paragraph ku kv it kx b ky kz kd la lb lc kg ld ls lf lg lh lt lj lk ll lu ln lo lp lq im bi translated">边列表是一种简单地将图表示为无序边列表的方式。假设任何三元组(u，v，w)的符号表示:<br/>“<em class="kw">从u到v的成本是w </em>”。</p><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/37f1459bac59a6312933657974da8e9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*3mcmIFQNr28ssfz5ZXZ-DQ.png"/></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">作者照片</p></figure><p id="1986" class="pw-post-body-paragraph ku kv it kx b ky kz kd la lb lc kg ld ls lf lg lh lt lj lk ll lu ln lo lp lq im bi translated">对应于左侧的有向加权图，右侧给出了边列表。列表中的每一对都显示了两个节点之间的边信息以及相关的权重。</p><blockquote class="kr ks kt"><p id="abdc" class="ku kv kw kx b ky kz kd la lb lc kg ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在接下来的帖子中，我们将讨论可以通过图论解决的不同问题。</p></blockquote><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi oc"><img src="../Images/12a42ea150b669878b350084c16af78d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lgzROdVHD1jDW91xwO8mVA.png"/></div></div></figure></div></div>    
</body>
</html>