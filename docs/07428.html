<html>
<head>
<title>7 Python Mistakes You Don’t Want to Make</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你不想犯的 7 个 Python 错误</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/7-python-mistakes-you-dont-want-to-make-77ac068c847?source=collection_archive---------13-----------------------#2020-06-05">https://towardsdatascience.com/7-python-mistakes-you-dont-want-to-make-77ac068c847?source=collection_archive---------13-----------------------#2020-06-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/f5a69bca988ba20603fcbee6b2bb9e62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qakZqGE9AUBTNbFF"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://unsplash.com/@ivalex?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">伊万·阿列克西奇</a>在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><div class=""/><div class=""><h2 id="5a1a" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">注意这些可以节省几天的调试时间</h2></div><p id="17e3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">早上开始得很完美。甚至在我喝完咖啡之前，我就已经完成了一部新电影。我的生产率直线上升。那时候我还不知道，好得不像真的。</p><p id="6201" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个问题只花了几个小时就浮出水面了。然而，找到问题的根源需要更多的时间。修复需要一整天的时间。那时我还是个初学者。由此，我学到了关于 Python 中列表的重要一课。</p><p id="4d76" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这听起来熟悉吗？这发生在每个人身上，但是从别人的错误中学习总是更好的。在本帖中，我收集了其中的七个，可以为你节省无数个小时的调试时间。</p><h1 id="d5e4" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">1.有副作用的函数</h1><p id="58df" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">由于 Python 不是像 Haskell 那样的纯函数式语言，函数会产生副作用。严格来说，这不算是<em class="mr">失误</em>，但是很容易无意中把事情搞砸。下面的例子说明了这个问题。</p><figure class="mt mu mv mw gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ms"><img src="../Images/1eed0939a7eb94fea3a8999038c3f997.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d2U957Us8QcfH0kepDYEDQ.png"/></div></div></figure><p id="819a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在 Python 中，对象是<em class="mr">引用类型。所以当你传递一个列表作为参数时，传递的是一个引用而不是值。这意味着如果你在一个函数中改变它们，这些变化将会反映到外部。</em></p><p id="359e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这可能会导致一些令人讨厌的意外和数小时的调试。(见我的介绍。)提防这些，早点给自己省事。</p><h1 id="e568" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">2.默认参数中的函数调用</h1><p id="dd35" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">默认参数有时会很难使用。看看下面。</p><figure class="mt mu mv mw gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mx"><img src="../Images/687504cf1961affbae3dcad8288cb299.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iM1fij78w7i1f7r3pjvBNA.png"/></div></div></figure><p id="b2ed" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为什么每次调用的返回值都一样？原因是 Python 在定义函数时会计算默认参数中的表达式。如果希望动态生成默认参数，可以执行以下操作。</p><figure class="mt mu mv mw gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mx"><img src="../Images/df8292d0c26f1c180ce2e84e1497b41c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z4Yr1FPZ9tx9BYDoow9BKw.png"/></div></div></figure><h1 id="8464" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">3.可变默认参数</h1><p id="dc8f" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">这个问题是以上两者的结合。你遇到过以下场景吗？</p><figure class="mt mu mv mw gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ms"><img src="../Images/18aa4064a8dbb00141f0b02e67648983.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-_NNrU1JOcxVslQKsQUv_w.png"/></div></div></figure><p id="16a1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里发生了两件事。</p><ol class=""><li id="e6e6" class="my mz jj la b lb lc le lf lh na ll nb lp nc lt nd ne nf ng bi translated">当函数被定义时，Python 对表达式<code class="fe nh ni nj nk b">[]</code>求值。(这相当于调用<code class="fe nh ni nj nk b">list()</code>。)</li><li id="a2c9" class="my mz jj la b lb nl le nm lh nn ll no lp np lt nd ne nf ng bi translated">此对象的引用被绑定到参数。因此，无论何时调用该函数，都将使用同一个对象。</li></ol><p id="ae61" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，使用可变对象作为默认参数不是一个好主意。你永远不应该那样做。</p><h1 id="2853" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">4.意外的参考分配</h1><p id="3385" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">正如我们所见，Python 中的每个对象都是一个引用类型。除了将它们传递给函数之外，这会导致一些混乱。请参见以下示例:</p><figure class="mt mu mv mw gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mx"><img src="../Images/d783b465224aeb0e7041d9094769abaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YWRFQrDPdwDT0D5ycivpvg.png"/></div></div></figure><p id="9ba4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当你执行<code class="fe nh ni nj nk b">b = a</code>时，你实际上存储的是<code class="fe nh ni nj nk b">a</code>的<em class="mr">引用</em>。因此，<code class="fe nh ni nj nk b">a</code>和<code class="fe nh ni nj nk b">b</code>指向同一个对象。要解决这个问题，你应该使用内置的<code class="fe nh ni nj nk b">deepcopy</code>函数。这会递归地将所有的<em class="mr">值类型</em>属性复制到新变量中。</p><figure class="mt mu mv mw gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mx"><img src="../Images/f19d59ed1aecf440262e8e70e62d692f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TuO3J0qKhWKGSVNC2UmB1w.png"/></div></div></figure><p id="268f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你用整数而不是列表来做同样的尝试，一切都会如你所料。原因是整数类型是不可变的，所以当你改变它们时，你覆盖了引用。</p><h1 id="fbac" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">5.从进口的东西*</h1><p id="9662" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">我知道，我们都曾经这样做过。这有几个缺点。</p><p id="b87e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，不同名称空间中的函数可能具有相同的名称，这会在整个代码库中造成混乱。</p><p id="2dac" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第二，当您在 Python 中导入一个模块时，该模块中的所有代码都将被执行。如果有许多子模块要导入，这会大大降低速度。因此，如果您只导入 NumPy 来生成随机数，那么您可能更适合使用</p><pre class="mt mu mv mw gt nq nk nr ns aw nt bi"><span id="4564" class="nu lv jj nk b gy nv nw l nx ny">from numpy.random import random</span></pre><p id="064b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">比</p><pre class="mt mu mv mw gt nq nk nr ns aw nt bi"><span id="0d82" class="nu lv jj nk b gy nv nw l nx ny">import numpy as np</span></pre><h1 id="318c" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">6.用字符串串联连接路径</h1><p id="6ea4" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">假设您必须从变量<code class="fe nh ni nj nk b">data_folder</code>给出的文件夹中打开一个名为<code class="fe nh ni nj nk b">data.csv</code>的文件。应该如何确定文件路径？如果你在做</p><pre class="mt mu mv mw gt nq nk nr ns aw nt bi"><span id="7d73" class="nu lv jj nk b gy nv nw l nx ny">data_path = data_folder + "/data.csv"</span></pre><p id="0bbd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那你做的不对。例如，这在 Windows 上是行不通的。您可能没有亲身经历，但是您的使用不同开发设置的同事肯定会感受到这种痛苦。</p><p id="31d4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要解决这个问题，您应该使用 Python 的内置工具<code class="fe nh ni nj nk b">pathlib</code>，或者简单地使用<code class="fe nh ni nj nk b">os.path.join</code>函数:</p><pre class="mt mu mv mw gt nq nk nr ns aw nt bi"><span id="bc62" class="nu lv jj nk b gy nv nw l nx ny">data_path = os.path.join(data_folder, "data.csv")</span></pre><h1 id="0a9e" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">7.低测试覆盖率</h1><p id="e6e0" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">这是一个高层次的问题。尤其是当你是一个初学者时，单元测试的好处并不清楚。然而，每个经验丰富的开发人员都可以告诉你，这是绝对必要的。使用未经测试的代码就像玩打地鼠游戏:修复一个错误，引入另一个错误。</p><p id="e5e1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从项目一开始就要避免这种情况。一旦您添加了一个特性(甚至是一个功能)，您就应该编写测试用例来验证实现。这方面有几个很棒的库，例如内置的<a class="ae jg" href="https://docs.python.org/3.4/library/unittest.html" rel="noopener ugc nofollow" target="_blank"> unittest </a>或者非常流行的<a class="ae jg" href="https://docs.pytest.org/en/latest/" rel="noopener ugc nofollow" target="_blank"> pytest </a>。</p><p id="8dc7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你应该认真投入时间测试你的代码。这可能需要一些时间，但这是一项长期投资。您将节省更多的调试时间。</p></div><div class="ab cl nz oa hx ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="im in io ip iq"><h1 id="c9a8" class="lu lv jj bd lw lx og lz ma mb oh md me kp oi kq mg ks oj kt mi kv ok kw mk ml bi translated">摘要</h1><p id="13f5" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">简而言之，这是你在 Python 中可能犯的七个最痛苦的错误。在您追求 Python 熟练程度的过程中，您肯定会遇到更多。然而，有了这个指南，你将有知识避免最常见的错误。</p><p id="ab0e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在去建造一些令人敬畏的东西吧！:)</p><p id="41f6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">(通过适当的单元测试。)</p></div><div class="ab cl nz oa hx ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="im in io ip iq"><p id="9a30" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae jg" href="https://www.tivadardanka.com/blog" rel="noopener ugc nofollow" target="_blank"> <strong class="la jk"> <em class="mr">如果你喜欢把机器学习概念拆开，理解是什么让它们运转，我们有很多共同点。看看我的博客，我经常在那里发表这样的技术文章！</em> </strong> </a></p></div></div>    
</body>
</html>