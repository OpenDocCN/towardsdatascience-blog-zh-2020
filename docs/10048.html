<html>
<head>
<title>Let’s Talk Test-Driven Development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们谈谈测试驱动的开发</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/lets-talk-test-driven-development-c73551ca2871?source=collection_archive---------40-----------------------#2020-07-15">https://towardsdatascience.com/lets-talk-test-driven-development-c73551ca2871?source=collection_archive---------40-----------------------#2020-07-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="5988" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">干净的代码</h2><div class=""/><div class=""><h2 id="4c18" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">它的意思是通过在“如何”之前关注“什么”来支持你。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/fbaad8cb8b5f3c374e8bbf8f2fa1c600.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*52VfjCgUITswkrFF"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@kaip?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">凯·皮尔格</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="471c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">许多程序员认为在编写代码之前编写测试的想法是荒谬的。他们认为这是没有用的，并减缓了开发过程。从某种意义上说，这是正确的，它确实影响了发展的速度。但是如果你的系统没有弹性，那么开发的速度就没什么关系了。</p><p id="6c7a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">开发人员的工作是交付不仅实用，而且可读和可维护的代码。测试驱动的开发可以帮助你做到这一点。</p><p id="126a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">根据 Martin Fowler 的说法，TDD 是:</p><ul class=""><li id="51cd" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md mj mk ml mm bi translated">为您想要添加的下一个功能编写测试。</li><li id="21c5" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">编写功能代码，直到测试通过。</li><li id="f8de" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">重构新旧代码，使其结构良好。</li></ul><p id="f0d2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">TDD 最重要的一个方面是它将焦点从如何转移到问题的什么上。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="354b" class="mz na it bd nb nc nd ne nf ng nh ni nj ki nk kj nl kl nm km nn ko no kp np nq bi translated">让我们编码</h1><p id="d27b" class="pw-post-body-paragraph li lj it lk b ll nr kd ln lo ns kg lq lr nt lt lu lv nu lx ly lz nv mb mc md im bi translated">我们将把 TDD 应用到面试中普遍被问到的一个问题上，并尝试提出一个解决方案。这个问题叫做<a class="ae lh" href="https://leetcode.com/problems/evaluate-reverse-polish-notation/" rel="noopener ugc nofollow" target="_blank">反向波兰符号</a>。</p><p id="6f29" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="nw">在逆波兰记法中，运算符跟在它们的操作数后面；例如，要将 3 和 4 相加，可以写成</em> <code class="fe nx ny nz oa b"><em class="nw">3 4 +</em></code> <em class="nw">而不是</em> <code class="fe nx ny nz oa b"><em class="nw">3 + 4</em></code> <em class="nw">。如果有多个操作，操作符在第二个操作数后立即给出；因此，在传统符号中，表达式被写成</em> <code class="fe nx ny nz oa b"><em class="nw">3 − 4 + 5</em></code> <em class="nw">，而在逆波兰符号中，表达式被写成</em> <code class="fe nx ny nz oa b"><em class="nw">3 4 − 5 +</em></code> <em class="nw">:首先从 3 中减去 4，然后加 5。</em></p><p id="d452" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们将把问题分成更小的步骤，并思考每一步期望我们做什么。我们稍后将考虑“如何”。用来求解的语言是 Java。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="4ed4" class="mz na it bd nb nc nd ne nf ng nh ni nj ki nk kj nl kl nm km nn ko no kp np nq bi translated">测试 1</h1><p id="ec99" class="pw-post-body-paragraph li lj it lk b ll nr kd ln lo ns kg lq lr nt lt lu lv nu lx ly lz nv mb mc md im bi translated">我们的起始状态是一个输入字符串:<code class="fe nx ny nz oa b">3 4 +</code></p><p id="f791" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们想要实现的是对每个 char 进行控制，以便我们可以对其进行操作。所以我们想从一个字符串中得到一个字符串数组。</p><p id="0028" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们的测试将如下所示:</p><pre class="ks kt ku kv gt ob oa oc od aw oe bi"><span id="aa52" class="of na it oa b gy og oh l oi oj"><a class="ae lh" href="http://twitter.com/Test" rel="noopener ugc nofollow" target="_blank">@Test</a><br/>public void removeSpacesFromTheString() {<br/>        ReversePolishNotation rpn = new ReversePolishNotation();<br/>        String[] result = rpn.getStringArray("3 4 +");<br/>        assertEquals("3", result[0]);<br/>        assertEquals("4", result[1]);<br/>        assertEquals("+", result[2]);<br/>    }</span></pre><p id="ec68" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一旦我们有了确定<strong class="lk jd">我们需要什么的测试，我们将考虑<strong class="lk jd">如何</strong>去做。将字符串转换成字符串数组非常简单。</strong></p><pre class="ks kt ku kv gt ob oa oc od aw oe bi"><span id="d77c" class="of na it oa b gy og oh l oi oj">public String[] getStringArray(String s) {<br/>        return s.split(" ");<br/>    }</span></pre></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="3f90" class="mz na it bd nb nc nd ne nf ng nh ni nj ki nk kj nl kl nm km nn ko no kp np nq bi translated">测试 2</h1><p id="00f0" class="pw-post-body-paragraph li lj it lk b ll nr kd ln lo ns kg lq lr nt lt lu lv nu lx ly lz nv mb mc md im bi translated">我们的第一个测试及其实现已经准备好了。让我们看看下一步我们想要什么。我们希望将运算符应用于我们遇到的数字。</p><p id="51e9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">所以在这种情况下，我们想把两个数相加。</p><pre class="ks kt ku kv gt ob oa oc od aw oe bi"><span id="8809" class="of na it oa b gy og oh l oi oj"><a class="ae lh" href="http://twitter.com/Test" rel="noopener ugc nofollow" target="_blank">@Test</a><br/>public void addNumbersWhenPlusOperatorIsFound() {<br/>        ReversePolishNotation rpn = new ReversePolishNotation();<br/>        double result = rpn.evaluate("3 4 +");<br/>        assertEquals(7.0, result, 0.1);<br/>    }</span></pre><p id="e22f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，我们需要一种方法将运算符应用于我们的数字。因为我们只有两个数，我们可以把它们相加。</p><pre class="ks kt ku kv gt ob oa oc od aw oe bi"><span id="2591" class="of na it oa b gy og oh l oi oj">public double evaluate(String s) {<br/>        String[] elements = getStringArray(s);<br/>        double result = 0.0;<br/>        for (int i = 0; i &lt; elements.length; i++) {<br/>            String c = elements[i];<br/>            if (c.equals("+") &amp;&amp; i &gt;= 2) {<br/>                result = parseDouble(elements[i - 1]) + parseDouble(elements[i - 2]);<br/>            }<br/>        }<br/>        return result;<br/>    }</span></pre><p id="0bcc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们迭代数组，并添加我们遇到的数字<code class="fe nx ny nz oa b">+</code>。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="b2e5" class="mz na it bd nb nc nd ne nf ng nh ni nj ki nk kj nl kl nm km nn ko no kp np nq bi translated">测试 3</h1><p id="544e" class="pw-post-body-paragraph li lj it lk b ll nr kd ln lo ns kg lq lr nt lt lu lv nu lx ly lz nv mb mc md im bi translated">现在让我们通过在字符串中添加多个<code class="fe nx ny nz oa b">+</code>操作符来增加趣味性。我们的测试会失败，因为它是硬编码的。对于输入<code class="fe nx ny nz oa b">5 5 2 + +</code>，我们的实现会失败。</p><p id="51d2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们希望我们的函数返回这个字符串<code class="fe nx ny nz oa b">5 + (5 + 2)</code>的结果。我们的代码应该这样评估。</p><pre class="ks kt ku kv gt ob oa oc od aw oe bi"><span id="73f7" class="of na it oa b gy og oh l oi oj"><a class="ae lh" href="http://twitter.com/Test" rel="noopener ugc nofollow" target="_blank">@Test</a><br/>public void evaluateWhenMultiplePlusOperatorsAreFound() {<br/>    ReversePolishNotation rpn = new ReversePolishNotation();<br/>    double result = rpn.evaluate("5 5 2 + +");<br/>    assertEquals(12.0, result, 0.1);<br/>}</span></pre><p id="d0a6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">要做到这一点，我们需要想出一种方法，使用某种数据结构来处理运算符和数字。在这种情况下，我们可以使用一个<code class="fe nx ny nz oa b">Stack</code>来推动数字，直到我们找到一个操作符，并通过弹出最后两个值来应用它。</p><pre class="ks kt ku kv gt ob oa oc od aw oe bi"><span id="1e0d" class="of na it oa b gy og oh l oi oj">public double evaluate(String s) {<br/>        String[] elements = getStringArray(s);<br/>        Stack&lt;Double&gt; numbers = new Stack();<br/>        double result = 0.0;<br/>        for (int i = 0; i &lt; elements.length; i++) {<br/>            String c = elements[i];<br/>            if (c.equals("+") &amp;&amp; i &gt;= 2) {<br/>                result = numbers.push(numbers.pop() + numbers.pop());<br/>            } else {<br/>                numbers.push(Double.parseDouble(c));<br/>            }<br/>        }<br/>        return result;<br/>    }</span></pre></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="89b5" class="mz na it bd nb nc nd ne nf ng nh ni nj ki nk kj nl kl nm km nn ko no kp np nq bi translated">测试 4</h1><p id="332a" class="pw-post-body-paragraph li lj it lk b ll nr kd ln lo ns kg lq lr nt lt lu lv nu lx ly lz nv mb mc md im bi translated">下一步是确保我们能够应用所有的四个操作符，这现在非常简单。我们只需要检查不同的操作符，并相应地应用它们。</p><pre class="ks kt ku kv gt ob oa oc od aw oe bi"><span id="54f0" class="of na it oa b gy og oh l oi oj"><a class="ae lh" href="http://twitter.com/Test" rel="noopener ugc nofollow" target="_blank">@Test</a><br/>public void addNumbersWhenMinusOperatorIsFound() {<br/>    ReversePolishNotation rpn = new ReversePolishNotation();<br/>    double result = rpn.evaluate("5 5 2 + -");<br/>    assertEquals(2.0, result, 0.1);<br/>}</span><span id="2281" class="of na it oa b gy ok oh l oi oj"><a class="ae lh" href="http://twitter.com/Test" rel="noopener ugc nofollow" target="_blank">@Test</a><br/>public void multiplyNumbersWhenMultiplyOperatorIsFound() {<br/>    ReversePolishNotation rpn = new ReversePolishNotation();<br/>    double result = rpn.evaluate("5 5 2 + *");<br/>    assertEquals(35.0, result, 0.1);<br/>}</span></pre><p id="a9e2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以跳过一步，为所有操作符实现该方法。它也会处理乘法和除法。</p><pre class="ks kt ku kv gt ob oa oc od aw oe bi"><span id="0339" class="of na it oa b gy og oh l oi oj">public double evaluate(String s) {<br/>    String[] elements = getStringArray(s);<br/>    Stack&lt;Double&gt; numbers = new Stack();<br/>    double result = 0.0;<br/>    for (String c : elements) {<br/>        switch (c) {<br/>            case "+":<br/>               result = numbers.push(numbers.pop() + numbers.pop());<br/>               break;<br/>            case "-":<br/>               result = numbers.push(numbers.pop() - numbers.pop());<br/>               break;<br/>            case "*":<br/>               result = numbers.push(numbers.pop() * numbers.pop());<br/>               break;<br/>            case "/":<br/>               result = numbers.push(numbers.pop() / numbers.pop());<br/>               break;<br/>            default:<br/>                numbers.push(Double.parseDouble(c));<br/>                break;<br/>        }<br/>    }<br/>    return result;<br/>}</span></pre></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="f31b" class="mz na it bd nb nc nd ne nf ng nh ni nj ki nk kj nl kl nm km nn ko no kp np nq bi translated">最后试验</h1><p id="86e8" class="pw-post-body-paragraph li lj it lk b ll nr kd ln lo ns kg lq lr nt lt lu lv nu lx ly lz nv mb mc md im bi translated">一切正常，似乎我们已经达到了我们的最终结果。我们来测试一下大输入<code class="fe nx ny nz oa b">10 6 9 3 + -11 * / * 17 + 5 +</code>。输入包含多个运算符和负数。</p><pre class="ks kt ku kv gt ob oa oc od aw oe bi"><span id="eefd" class="of na it oa b gy og oh l oi oj"><a class="ae lh" href="http://twitter.com/Test" rel="noopener ugc nofollow" target="_blank">@Test</a><br/>public void evaluateWhenAllOperatorAreFound() {<br/>    ReversePolishNotation rpn = new ReversePolishNotation();<br/>    double result = rpn.evaluate("10 6 9 3 + -11 * / * 17 + 5 +");<br/>    assertEquals(21.5, result, 0.1);<br/>}</span></pre><p id="f09d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们在这一点上的实现失败了。这有点令人惊讶，因为它应该已经工作了，但似乎操作符<code class="fe nx ny nz oa b">—</code>和<code class="fe nx ny nz oa b">\</code>的工作方式与<code class="fe nx ny nz oa b">+</code>和<code class="fe nx ny nz oa b">*</code>不同。让我们更改实现来处理这个问题。</p><pre class="ks kt ku kv gt ob oa oc od aw oe bi"><span id="0158" class="of na it oa b gy og oh l oi oj">public double evaluate(String s) {<br/>    String[] elements = getStringArray(s);<br/>    Stack&lt;Double&gt; n = new Stack();<br/>    double result = 0.0;<br/>    for (String c : elements) {<br/>        switch (c) {<br/>            case "+": {<br/>                result = n.push(n.pop() + n.pop());<br/>                break;<br/>            }<br/>            case "-": {<br/>                double fNumber = n.pop();<br/>                double sNumber = n.pop();<br/>                result = n.push(sNumber - fNumber);<br/>                break;<br/>            }<br/>            case "*": {<br/>                result = n.push(n.pop() * n.pop());<br/>                break;<br/>            }<br/>            case "/": {<br/>                double fNumber = n.pop();<br/>                double sNumber = n.pop();<br/>                result = n.push(sNumber / fNumber);<br/>                break;<br/>            }<br/>            default:<br/>                n.push(Double.<em class="nw">parseDouble</em>(c));<br/>                break;<br/>        }<br/>    }<br/>    return result;<br/>}</span></pre></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="4166" class="mz na it bd nb nc nd ne nf ng nh ni nj ki nk kj nl kl nm km nn ko no kp np nq bi translated">优势</h1><p id="01dd" class="pw-post-body-paragraph li lj it lk b ll nr kd ln lo ns kg lq lr nt lt lu lv nu lx ly lz nv mb mc md im bi translated">我们已经找到了最终的解决方案。花点时间理解这一点。在我们开始实现算法之前，焦点总是在我们期望从算法中得到什么。TDD 的优势是真实的:</p><ul class=""><li id="301e" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md mj mk ml mm bi translated">你写出更好的软件。</li><li id="5cd5" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">你避免过度工程化。</li><li id="62ca" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">引入新功能时，您会受到保护。</li><li id="a7e0" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">你的软件是自我记录的。</li></ul><p id="a712" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果您想了解如何在解决方案中消除切换阶梯，您可以阅读这篇文章。</p><div class="ol om gp gr on oo"><a href="https://levelup.gitconnected.com/how-to-get-rid-of-if-else-ladder-b70f36cd834d" rel="noopener  ugc nofollow" target="_blank"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd jd gy z fp ot fr fs ou fu fw jc bi translated">如何摆脱 If-Else 阶梯</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">使用高阶函数和 HashMaps 编写干净代码的简单方法</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="ox l"><div class="oy l oz pa pb ox pc lb oo"/></div></div></a></div></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="f5cc" class="mz na it bd nb nc nd ne nf ng nh ni nj ki nk kj nl kl nm km nn ko no kp np nq bi translated">最终想法</h1><p id="bba8" class="pw-post-body-paragraph li lj it lk b ll nr kd ln lo ns kg lq lr nt lt lu lv nu lx ly lz nv mb mc md im bi translated">我试图解释为什么我们应该使用测试驱动开发。有更好的文章可以帮助你理解如何去做。其中一个是这里的<a class="ae lh" href="https://www.infoq.com/articles/test-driven-design-java/" rel="noopener ugc nofollow" target="_blank"/>。TDD 实际上是一种设计技术。TDD 的基础集中在使用小型测试以紧急的方式从头开始设计系统。</p><p id="ae62" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一开始可能看起来很慢，但是通过练习，你会获得动力。</p><p id="7399" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我希望这有助于您理解 TDD 背后的原因。</p></div></div>    
</body>
</html>