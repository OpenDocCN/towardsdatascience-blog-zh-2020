<html>
<head>
<title>How to Use Generator and yield in Javascript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在 Javascript 中使用 Generator 和 yield</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-use-generator-and-yield-in-javascript-d1771bf698cd?source=collection_archive---------49-----------------------#2020-06-17">https://towardsdatascience.com/how-to-use-generator-and-yield-in-javascript-d1771bf698cd?source=collection_archive---------49-----------------------#2020-06-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="ae7d" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">更好的编程</h2><div class=""/><div class=""><h2 id="a618" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">你知道 JavaScript 里有个叫“生成器”的东西吗？</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/c12e6177c5ecc94f42febc76fe34da1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DGJ6R22ON4zfBVW9"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/@thomasreaubourg?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Thomas re abourg</a>在<a class="ae lh" href="/s/photos/wind-turbine?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="91aa" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">前段时间我写了一篇文章解释了<a class="ae lh" href="https://medium.com/@bajcmartinez/how-to-use-generator-and-yield-in-python-c481cea097d7" rel="noopener">生成器的概念以及如何在 Python </a>中使用它们，但是你知道 JavaScript 也有自己版本的生成器吗？这其实是一个很多开发 JavaScript 应用的人都不知道它存在的概念，所以今天我们要介绍的是 JavaScript 中的生成器。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="b638" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">什么是发电机？</h1><p id="1813" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">在 ES6 中，我们引入了伟大的新功能，如<a class="ae lh" href="https://medium.com/@bajcmartinez/when-not-to-use-javascript-arrow-functions-a7340630d4a8" rel="noopener">箭头函数</a>、<a class="ae lh" href="https://medium.com/@bajcmartinez/how-to-use-the-spread-operator-in-javascript-3aff104adb71" rel="noopener">扩展操作符</a>和生成器等等，但是什么是生成器呢？生成器是一个与普通函数相反的函数，它允许函数退出并在以后重新进入，并在重新进入时保留其上下文(变量绑定)。</p><p id="6ec3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们把它分解开来，一步一步地研究发电机，这样我们都可以理解它们是如何工作的。当我们执行一个常规函数时，解释器会将所有代码运行到那个函数中，直到函数完成(或者抛出一个错误)。这就是所谓的<strong class="lk jd">运行至完成</strong>模型。</p><p id="2be0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们以一个非常简单的函数为例:</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="e894" class="nn mm it nj b gy no np l nq nr">function regularFunction() {<br/>    console.log("I'm a regular function")<br/>    console.log("Surprise surprice")<br/>    console.log("This is the end")<br/>}</span><span id="280d" class="nn mm it nj b gy ns np l nq nr">regularFunction()</span><span id="f94a" class="nn mm it nj b gy ns np l nq nr">-----------------<br/>Output<br/>-----------------<br/>I'm a regular function<br/>Surprise surprice<br/>This is the end</span></pre><p id="6000" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">还没有什么新奇的东西，正如你所期望的，这是一个常规函数，它会一直执行到最后或者返回值。但是如果我们只想在任意点停止函数来返回值，然后继续呢？这时，发电机就出现了。</p><h1 id="ff49" class="ml mm it bd mn mo nt mq mr ms nu mu mv ki nv kj mx kl nw km mz ko nx kp nb nc bi translated">我的第一个生成器函数</h1><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="5467" class="nn mm it nj b gy no np l nq nr">function* generatorFunction() {<br/>    yield "This is the first return"<br/>    console.log("First log!")<br/>    yield "This is the second return"<br/>    console.log("Second log!")<br/>    return "Done!"<br/>}</span></pre><p id="d5f1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在我们执行这个函数之前，你可能会想知道一些事情，首先什么是<code class="fe ny nz oa nj b">function*</code>？这就是我们用来将函数声明为生成器的语法。而<code class="fe ny nz oa nj b">yield</code>呢？与 return 不同的是，<code class="fe ny nz oa nj b">yield</code>将通过保存函数的所有状态来暂停函数，并在随后的调用中从该点继续。在这两种情况下，表达式都将返回给调用方执行。</p><p id="419a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们的功能到底发生了什么？让我们通过调用函数来找出答案:</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="5aa0" class="nn mm it nj b gy no np l nq nr">generatorFunction()</span><span id="c444" class="nn mm it nj b gy ns np l nq nr">-----------------<br/>Output<br/>-----------------<br/>generatorFunction {&lt;suspended&gt;} {<br/>    __proto__: Generator<br/>    [[GeneratorLocation]]: VM272:1<br/>    [[GeneratorStatus]]: "suspended"<br/>    [[GeneratorFunction]]: ƒ* generatorFunction()<br/>    [[GeneratorReceiver]]: Window<br/>    [[Scopes]]: Scopes[3]<br/>}</span></pre><p id="cb7d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">等等，什么？当我们调用一个生成器函数时，这个函数不会被自动触发，而是返回一个迭代器对象。这个对象的特别之处在于，当调用方法 next()时，生成器函数的主体被执行，直到第一个<code class="fe ny nz oa nj b">yield</code>或<code class="fe ny nz oa nj b">return</code>表达式。让我们来看看它的实际应用:</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="34a1" class="nn mm it nj b gy no np l nq nr">const myGenerator = generatorFunction()<br/>myGenerator.next()</span><span id="3745" class="nn mm it nj b gy ns np l nq nr">-----------------<br/>Output<br/>-----------------<br/>{value: "This is the first return", done: false}</span></pre><p id="54d0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如前所述，生成器一直运行到第一条<code class="fe ny nz oa nj b">yield</code>语句，并生成一个包含<code class="fe ny nz oa nj b">value</code>属性和<code class="fe ny nz oa nj b">done</code>属性的对象。</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="10d5" class="nn mm it nj b gy no np l nq nr">{ value: ..., done: ... }</span></pre><ul class=""><li id="3984" class="ob oc it lk b ll lm lo lp lr od lv oe lz of md og oh oi oj bi translated"><code class="fe ny nz oa nj b">value</code>属性等于我们产生的值</li><li id="f8cc" class="ob oc it lk b ll ok lo ol lr om lv on lz oo md og oh oi oj bi translated"><code class="fe ny nz oa nj b">done</code>属性是一个布尔值，它只在生成器函数返回值时设置为<code class="fe ny nz oa nj b">true</code>。(未屈服)</li></ul><p id="3a1c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们再次调用<code class="fe ny nz oa nj b">next()</code>，看看我们会得到什么</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="a176" class="nn mm it nj b gy no np l nq nr">myGenerator.next()</span><span id="f54d" class="nn mm it nj b gy ns np l nq nr">-----------------<br/>Output<br/>-----------------<br/>First log!<br/>{value: "This is the second return", done: false}</span></pre><p id="418e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这次我们首先看到我们的生成器主体中的<code class="fe ny nz oa nj b">console.log</code>被执行并打印<code class="fe ny nz oa nj b">First log!</code>，以及第二个生成的对象。我们可以继续这样做:</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="79ea" class="nn mm it nj b gy no np l nq nr">myGenerator.next()</span><span id="c001" class="nn mm it nj b gy ns np l nq nr">-----------------<br/>Output<br/>-----------------<br/>Second log!<br/>{value: "Done!", done: true}</span></pre><p id="cb53" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在第二个<code class="fe ny nz oa nj b">console.log</code>语句被执行，我们得到一个新的返回对象，但是这次属性<code class="fe ny nz oa nj b">done</code>被设置为<code class="fe ny nz oa nj b">true</code>。</p><p id="c899" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">属性的值不仅仅是一个标志，它是一个非常重要的标志，因为我们只能迭代一个生成器对象一次！。不相信我？尝试再次呼叫<code class="fe ny nz oa nj b">next()</code>:</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="c0e0" class="nn mm it nj b gy no np l nq nr">myGenerator.next()</span><span id="ff9d" class="nn mm it nj b gy ns np l nq nr">-----------------<br/>Output<br/>-----------------<br/>{value: undefined, done: true}</span></pre><p id="129e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">还好它没有崩溃，但是我们只是得到了未定义的结果，因为<code class="fe ny nz oa nj b">value</code>和<code class="fe ny nz oa nj b">done</code>属性仍然设置为 true。</p><h1 id="a409" class="ml mm it bd mn mo nt mq mr ms nu mu mv ki nv kj mx kl nw km mz ko nx kp nb nc bi translated">产生迭代器</h1><p id="2b49" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">在我们进入一些场景之前，yield 操作符还有一个特殊性，那就是<code class="fe ny nz oa nj b">yield*</code>。让我们通过创建一个函数来解释它，这个函数允许我们迭代一个数组，我们可以天真地想到这样做:</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="2f10" class="nn mm it nj b gy no np l nq nr">function* yieldArray(arr) {<br/>    yield arr<br/>}</span><span id="30f6" class="nn mm it nj b gy ns np l nq nr">const myArrayGenerator1 = yieldArray([1, 2, 3])<br/>myArrayGenerator1.next()</span><span id="baca" class="nn mm it nj b gy ns np l nq nr">-----------------<br/>Output<br/>-----------------<br/>{value: Array(3), done: false}</span></pre><p id="7c5d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但这并不是我们想要的，我们想要产生数组中的每个元素，所以我们可以尝试这样做:</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="9fc0" class="nn mm it nj b gy no np l nq nr">function* yieldArray(arr) {<br/>    for (element of arr) {<br/>        yield element<br/>    }<br/>}</span><span id="d0de" class="nn mm it nj b gy ns np l nq nr">const myArrayGenerator2 = yieldArray([1, 2, 3])<br/>myArrayGenerator2.next()<br/>myArrayGenerator2.next()<br/>myArrayGenerator2.next()</span><span id="c32d" class="nn mm it nj b gy ns np l nq nr">-----------------<br/>Output<br/>-----------------<br/>{value: 1, done: false}<br/>{value: 2, done: false}<br/>{value: 3, done: false}</span></pre><p id="7acb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在我们得到了想要的结果，但是我们能做得更好吗？是的，我们可以:</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="53d3" class="nn mm it nj b gy no np l nq nr">function* yieldArray(arr) {<br/>    yield* arr<br/>}</span><span id="7bf5" class="nn mm it nj b gy ns np l nq nr">const myArrayGenerator3 = yieldArray([1, 2, 3])<br/>myArrayGenerator3.next()<br/>myArrayGenerator3.next()<br/>myArrayGenerator3.next()</span><span id="ca5f" class="nn mm it nj b gy ns np l nq nr">-----------------<br/>Output<br/>-----------------<br/>{value: 1, done: false}<br/>{value: 2, done: false}<br/>{value: 3, done: false}</span></pre><p id="d60f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">太棒了，通过使用 yield* expression，我们可以迭代操作数，并产生它返回的每个值。这适用于其他生成器，数组，字符串，任何可迭代的对象。</p><p id="7667" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">既然您已经了解了 JavaScript 中的所有生成器，那么它们有什么用处呢？</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="210a" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">发电机的使用</h1><p id="1114" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">关于生成器的伟大之处在于它们是惰性计算的，这意味着在调用<code class="fe ny nz oa nj b">next()</code>方法后返回的值，只有在我们明确请求后才被计算。这使得生成器成为解决多种场景(如下所示)的好选择。</p><h1 id="9624" class="ml mm it bd mn mo nt mq mr ms nu mu mv ki nv kj mx kl nw km mz ko nx kp nb nc bi translated">生成一个无限序列</h1><p id="9d75" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">正如我们在 Python 文章中看到的，生成器适合生成无限序列，这可以是从质数到简单计数的任何东西:</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="fa2f" class="nn mm it nj b gy no np l nq nr">function* infiniteSequence() {<br/>    let num = 0<br/>    while (true) {<br/>        yield num<br/>        num += 1<br/>    }<br/>}</span><span id="65a7" class="nn mm it nj b gy ns np l nq nr">for(i of infiniteSequence()) {<br/>    if (i &gt;= 10) {<br/>        break<br/>    }<br/>    console.log(i)<br/>}</span><span id="5354" class="nn mm it nj b gy ns np l nq nr">-----------------<br/>Output<br/>-----------------<br/>0<br/>1<br/>2<br/>3<br/>4<br/>5<br/>6<br/>7<br/>8<br/>9</span></pre><p id="99e3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">注意，在这种情况下，我在<code class="fe ny nz oa nj b">i &gt;= 10</code>时退出循环，否则，它将永远运行(或者直到手动停止)。</p><h1 id="e91a" class="ml mm it bd mn mo nt mq mr ms nu mu mv ki nv kj mx kl nw km mz ko nx kp nb nc bi translated">实现 iterables</h1><p id="9ab5" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">当你需要实现一个迭代器时，你必须用一个<code class="fe ny nz oa nj b">next()</code>方法手工创建一个对象。此外，您必须手动保存状态。</p><p id="b907" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">假设我们想创建一个只返回<code class="fe ny nz oa nj b">I</code>、<code class="fe ny nz oa nj b">am</code>、<code class="fe ny nz oa nj b">iterable</code>的 iterable。如果不使用发电机，我们将不得不做这样的事情:</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="b1db" class="nn mm it nj b gy no np l nq nr">const iterableObj = {<br/>  [Symbol.iterator]() {<br/>    let step = 0;<br/>    return {<br/>      next() {<br/>        step++;<br/>        if (step === 1) {<br/>          return { value: 'I', done: false};<br/>        } else if (step === 2) {<br/>          return { value: 'am', done: false};<br/>        } else if (step === 3) {<br/>          return { value: 'iterable.', done: false};<br/>        }<br/>        return { value: '', done: true };<br/>      }<br/>    }<br/>  },<br/>}<br/>for (const val of iterableObj) {<br/>  console.log(val);<br/>}</span><span id="d678" class="nn mm it nj b gy ns np l nq nr">-----------------<br/>Output<br/>-----------------<br/>I<br/>am<br/>iterable.</span></pre><p id="9946" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">有了发电机，这就简单多了:</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="f148" class="nn mm it nj b gy no np l nq nr">function* iterableObj() {<br/>    yield 'I'<br/>    yield 'am'<br/>    yield 'iterable.'<br/>}</span><span id="2036" class="nn mm it nj b gy ns np l nq nr">for (const val of iterableObj()) {<br/>  console.log(val);<br/>}</span><span id="1ef7" class="nn mm it nj b gy ns np l nq nr">-----------------<br/>Output<br/>-----------------<br/>I<br/>am<br/>iterable.</span></pre><h1 id="230f" class="ml mm it bd mn mo nt mq mr ms nu mu mv ki nv kj mx kl nw km mz ko nx kp nb nc bi translated">更好的异步？</h1><p id="cf81" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">一些人认为生成器有助于改进承诺和回调的使用，尽管我更喜欢简单地使用 await/async。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="00cf" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">警告</h1><p id="4cf4" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">当我们使用发电机时，并不是所有的东西都闪闪发光。设计有一些限制，有两个非常重要的考虑因素:</p><ul class=""><li id="89d6" class="ob oc it lk b ll lm lo lp lr od lv oe lz of md og oh oi oj bi translated">生成器对象只能一次性访问。一旦用完，就不能再迭代了。为此，您必须创建一个新的生成器对象。</li><li id="099b" class="ob oc it lk b ll ok lo ol lr om lv on lz oo md og oh oi oj bi translated">生成器对象尽可能不允许随机访问，例如数组。由于值是一个接一个生成的，您无法获得特定索引的值，您将不得不手动调用所有的<code class="fe ny nz oa nj b">next()</code>函数，直到您到达所需的位置，但是之后，您将无法访问先前生成的元素。</li></ul></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="6a12" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">结论</h1><p id="01f3" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">生成器函数对于优化我们的应用程序的性能非常有用，并且有助于简化构建迭代器所需的代码。</p><p id="0a29" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我希望您现在已经很好地理解了 JavaScript 中的生成器，并且可以在您的下一个项目中使用它们。</p><p id="4da4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">感谢阅读！</p></div></div>    
</body>
</html>