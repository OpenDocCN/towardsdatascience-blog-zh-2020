<html>
<head>
<title>Using Reinforcement Learning to Produce Better Join Ordering Strategy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用强化学习产生更好的连接排序策略</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/using-reinforcement-learning-to-produce-better-join-ordering-strategy-2fd2761ebf3a?source=collection_archive---------19-----------------------#2020-01-18">https://towardsdatascience.com/using-reinforcement-learning-to-produce-better-join-ordering-strategy-2fd2761ebf3a?source=collection_archive---------19-----------------------#2020-01-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="15e7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">我们可以训练一个AI模型来决定首先加入哪些表吗？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b4e685dbcdd5a28f3084a5319255d079.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lFBJ--ByH_W2vCzx"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">连接表格。由<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kv" href="https://unsplash.com/@chuttersnap?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> chuttersnap </a>拍摄</p></figure><p id="6770" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设您在RDBMS上有以下查询:</p><blockquote class="ls lt lu"><p id="fbe5" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">从A、B、C、D中选择*</p></blockquote><p id="d2cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你是要先加入<em class="lv"> A </em> &amp; <em class="lv"> B </em>再加入结果跟<em class="lv">C</em>&amp;T10】D吗？还是先把<em class="lv"> A </em> &amp; <em class="lv"> C </em>加入，再把结果用<em class="lv"> B </em>加入，再把结果用<em class="lv"> D </em>加入比较好？</p><p id="89fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">今天我们将讨论一篇有趣的论文，作者是Ryan Marcus和Olga Papaemmanouil，题目是“连接顺序枚举的深度强化学习”本文将机器学习世界与数据库世界交叉。他们试图训练一个强化学习代理来决定连接关系的顺序，即首先连接哪些关系(RDBMS表)，接下来是哪些关系，等等。作为一个具体的例子，假设我们有四个关系A、B、C和D。我们希望代理决定是加入A &amp; B，然后将结果关系加入C并最终加入D，还是先加入A &amp; C，然后加入B &amp; D，然后加入两个结果关系，或者任何其他排序可能性。</p><p id="8773" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">连接排序策略是数据库查询优化的一部分，其目标是产生一个低延迟运行的物理查询计划。我们可以把这个问题看作是搜索所有可能的连接顺序并选择最便宜的一个。如果我们可以生成一个可以减少初始步骤中的行数的顺序，那么我们就可以省去后续步骤来联接最终将被丢弃的行。目前，DBMSs使用试探法来决定连接顺序。System-R使用动态规划寻找一个代价最低的左深树，而PostgreSQL使用贪婪算法选择一个代价低的对，直到构建出整个订单。然而，这些策略在某种程度上是静态的，并且数据库不从反馈中学习(例如，基数、查询延迟)。因此，他们可能会重复使用同样糟糕的连接排序策略。</p><h1 id="ea52" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">重新加入枚举器</h1><p id="2142" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">现在让我们来谈谈ReJOIN，这是一个通过使用强化学习来枚举和选择连接顺序的解决方案。</p><h2 id="4fd5" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated">强化学习</h2><p id="383a" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我们将把连接顺序枚举问题建模成强化学习问题。在强化学习中，我们训练一个与<em class="lv">环境</em>交互的<em class="lv">代理</em>。环境将告诉代理当前状态<em class="lv"> s </em>以及在 = { <em class="lv"> a₀、a₁、.。。，一个当前状态下可以拍的</em> }。然后，代理必须选择一个动作，并进入下一个状态，在该状态下，它将接收一组新的动作。代理反复执行这个过程，直到它到达一个<em class="lv">终端状态</em>，在这里没有更多的动作可用。此时，代理完成了一个<em class="lv">集</em>，并将根据其采取的行动获得<em class="lv">奖励</em>。代理的目标是通过从经验中学习来最大化回报。</p><h2 id="b793" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated">将连接顺序问题映射到强化学习的术语</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/e25a649fb73c0d28dc90a44a23b203c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eJfMiji-1wN84LNGmyjSFQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图1:二元连接树(Marcus &amp; Papaemmanouil，2018)</p></figure><p id="2eb6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">连接排序可以表示为一棵二叉连接树，如上图所示。为了采用强化学习来连接排序问题，我们将使用以下映射:</p><ul class=""><li id="1a3c" class="nj nk iq ky b kz la lc ld lf nl lj nm ln nn lr no np nq nr bi translated">每个<em class="lv">状态</em>将代表一个二元连接树。然后，我们将这个二元连接树转换成一个状态向量，并添加更多的信息，如连接谓词和选择谓词。</li><li id="f5c0" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated">每个动作代表将两个子树合并成一个树。</li><li id="ea9e" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated">当我们已经加入所有关系时，一集<em class="lv">就结束了。</em></li><li id="8645" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated"><em class="lv">奖励</em>将基于结果连接排序的成本模型评估来计算。</li></ul><h2 id="8310" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated">状态向量</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/092cd9090dc1c5fc05ea0f18ffbf6853.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Odnc9Oub-v2g2xK3BOaUYA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图2:作为向量的状态表示(Marcus &amp; Papaemmanouil，2018)</p></figure><p id="9831" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如前所述，我们将二叉连接树和进一步的连接信息表示为向量。我们将每个子树编码为大小为<em class="lv"> n </em>的向量<em class="lv"> v </em>，其中<em class="lv"> n </em>是数据库中关系的总数。如果关系不在二元连接树中，<em class="lv"> vᵢ </em>的值为0，并且<em class="lv"> 1/h(i，x) </em>其中<em class="lv"> h(i，x) </em>是关系<em class="lv"> i </em>在子树<em class="lv"> x </em>中的高度(到根的距离)。例如，在图2的最左边，我们可以看到我们将子树A表示为[1 0 0 0],因为在这种情况下，关系A的高度为1，其他关系不存在于子树中。在左起第二张图片上，假设我们连接了<em class="lv"> A </em>和<em class="lv"> C </em>，产生了新的关系A ⨝ C。现在A &amp; C的高度为2，因此我们用1/2填充A &amp; C列上的值。列B和D保持为0，因为它们不在这个子树中。</p><p id="0b17" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，我们添加了连接谓词和列选择谓词向量。连接谓词将是一个n×n二进制矩阵m，其中如果在和之间存在连接谓词，则<em class="lv"> m(i，j) </em>的值将为1，否则为0。在图2中，<em class="lv"> m(1，2) </em> = <em class="lv"> m(2，1) </em>的值是1，因为我们在A和B之间有一个连接谓词(A.id == B.id)。<em class="lv"> m(1，3) </em> = <em class="lv"> m(3，1) </em>的值也是1，因为我们在A和C之间有一个连接谓词(<em class="lv"> A.id == C.id </em>)</p><p id="9429" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">列选择谓词是一个k维二元向量，其中k是所有关系的属性总数。如果我们在这个属性中有选择谓词，那么这个向量中的项的值将为1，否则为0。在图2中，B.a2的值是1，因为在SQL查询中，我们有一个选择谓词<em class="lv"> B.a2 &gt; 100 </em>。</p><h2 id="e13c" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated">训练模型</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/3acd37a128504a0563b2c5a650c1410a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pQCOgA9qtpS1UNVCIK1Nww.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图3:重新加入的架构(Marcus &amp; Papaemmanouil，2018)</p></figure><p id="69df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们通过寻找产生最高回报的优化策略来训练强化学习代理。我们通过训练神经网络来实现这一点，该神经网络将状态向量作为输入，并将动作向量作为输出。动作向量是一个保存了<em class="lv"> n </em>个项目的向量，每个项目代表一个可能采取的动作。我们在中间放置了两个隐藏层。我们训练模型来优化产生高回报行动的权重。</p><p id="d64d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">ReJOIN将前几集的信息记录为一对权重及其奖励<em class="lv"> (θ，r) </em>。然后，它使用此信息中的样本来估计接下来事件的政策梯度。</p><h2 id="fccb" class="mw ma iq bd mb mx my dn mf mz na dp mj lf nb nc ml lj nd ne mn ln nf ng mp nh bi translated">结果</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/9cc819701cc7b66ff0b821ac0161ce44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dQOnNlIE_0EqDkfK64_B-w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图3:性能比较(Marcus &amp; Papaemmanouil，2018年)</p></figure><p id="dc95" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上图显示了使用PostgreSQL和ReJOIN生成的计划执行查询的比较。作者通过使用连接顺序基准数据集和查询来执行这个基准测试。正如我们所看到的，最初，ReJOIN给出了一个糟糕的执行计划(例如，比PostgreSQL差9倍)。在几千集之后，它开始实现与PostgreSQL相同的性能，并且在某个时候，开始产生更好的执行计划。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/aa36d66e59c43f9971e837e2fcf18f46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1ngPkaOVUpBAWBEXHfSUCw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图4:计划时间对比(Marcus &amp; Papaemmanouil，2018)</p></figure><p id="d060" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文的另一个极好的结果是，当我们向查询中添加更多的关系时，重加入的计划时间不会变长。在PostgreSQL的情况下，它花费更多的时间来计划更多关系的连接，因为可能的连接组合需要计算更多的成本。</p><p id="c071" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你也可以在<a class="ae kv" href="https://github.com/antonismand/ReJOIN" rel="noopener ugc nofollow" target="_blank">这个库</a>中找到关于这篇论文的实现和扩展实验。</p><h1 id="1cf2" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论和公开挑战</h1><p id="9cf2" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">这项研究显示了利用强化学习进行数据库优化的一些潜力。它显示了积极的结果，在某些查询上，该模型生成的连接顺序在执行性能和计划时间方面可以超过PostgreSQL生成的连接顺序。</p><p id="b4eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，它花费了大量的片段(查询执行)来达到一个好的结果。然后，作者提出了未来研究的一些机遇和挑战，例如:</p><ul class=""><li id="d70b" class="nj nk iq ky b kz la lc ld lf nl lj nm ln nn lr no np nq nr bi translated"><strong class="ky ir">使用实际查询延迟作为奖励</strong>。目前提出的方法是使用成本模型作为奖励。成本模型支持快速训练，但也容易出错，因为实际的查询延迟可能与成本模型不一致。</li><li id="03c3" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated"><strong class="ky ir">扩展优化器</strong>。在查询优化的世界里，重加入只处理连接顺序问题。研究社区可以进一步研究在查询优化的其他方面应用类似技术的可能性，比如选择物理操作符、使用索引和合并谓词。</li></ul><p id="0fe6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">参考文献:</strong></p><p id="7b37" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[1] Marcus，r .，&amp; Papaemmanouil，O. (2018年6月)。连接顺序枚举的深度强化学习。在<em class="lv">第一届利用人工智能技术进行数据管理的国际研讨会会议录</em>(第3页)。ACM。</p></div></div>    
</body>
</html>