<html>
<head>
<title>Full review on optimizing neural network training with Optimizer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用优化器优化神经网络训练综述</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/full-review-on-optimizing-neural-network-training-with-optimizer-9c1acc4dbe78?source=collection_archive---------35-----------------------#2020-06-14">https://towardsdatascience.com/full-review-on-optimizing-neural-network-training-with-optimizer-9c1acc4dbe78?source=collection_archive---------35-----------------------#2020-06-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d168" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过调整 Tensorflow 中的优化器来加速深度神经网络训练</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/cba1bfa3f3d31cd6e55c1db1d26984b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0reKPSZRPkGivG2H"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片由<a class="ae kv" href="https://unsplash.com/@greg_rosenke" rel="noopener ugc nofollow" target="_blank"> Greg Rosenke </a>在<a class="ae kv" href="https://unsplash.com/photos/0vXelw6zOow" rel="noopener ugc nofollow" target="_blank"> Upsplash </a>上拍摄</p></figure><p id="98c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">训练深度神经网络是一项极其耗时的任务，尤其是对于复杂的问题。对网络使用更快的优化器是加快训练速度的有效方法，而不是简单地使用常规的梯度下降优化器。下面，我将讨论并展示 5 种流行的优化器方法的训练结果/速度:<strong class="ky ir">动量梯度下降和内斯特罗夫加速梯度、AdaGrad、RMSProp、Adam 和 Nadam 优化</strong>。</p><p id="8980" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用不适当的优化器的一个危险是，模型需要很长时间才能收敛到全局最小值，否则它将停留在局部最小值，导致更差的模型。因此，知道哪个优化器最适合这个问题将会节省您大量的培训时间。</p><p id="057d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">优化器调优的主要目的是加快训练速度，但它也有助于提高模型的性能。</p><h2 id="2711" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">1.梯度下降</h2><p id="ea19" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">计算关于每个θ的相关成本函数的梯度，并得到指向上坡的梯度向量，然后使用下面的等式在与向量方向相反的方向(下坡)前进:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/4979d7ca68810387b756bff3e0b123b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:712/format:webp/1*wzdyk4RsZ57F_gAIZ4HYlQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="8597" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，梯度下降优化器的速度仅取决于学习率参数(eta)。在一个小的学习率下，GD 会在一个平缓的表面上以小而不变的步伐向下，在一个陡峭的表面上以稍快的步伐向下。因此，在一个大型神经网络中，它会重复数百万个缓慢的步骤，直到达到全局最小值(或陷入局部最小值)。因此，运行时间变得非常慢。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/384c71dceae73f51c6b60fa7911a9dfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/format:webp/1*4TCz_Gz7SzacBuW8UiTgnw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在每个历元之后，精确度慢慢增加</p></figure><p id="0815" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还有其他版本的梯度下降，如<strong class="ky ir">批量梯度下降</strong>(在完整数据集上运行)、<strong class="ky ir">小批量梯度下降</strong>(在数据集的随机子集上运行)、<strong class="ky ir">随机梯度下降— SGD </strong>(在每一步选择一个随机实例)，并且都有优点和缺点。<strong class="ky ir">批量梯度下降</strong>可以以非常慢的速度达到全局最小值。<strong class="ky ir">小批量梯度下降</strong>比 BGD 更快地到达全局最小值，但是更容易陷入局部最小值，并且与其他两个相比，SGD 通常更难到达全局最小值。</p><h2 id="a351" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">2.动量优化</h2><p id="4e35" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">让我们想象一下，当一个球从山顶滚下斜坡到山脚时，它会开始缓慢，然后随着动量的增加而增加速度，最终以很快的速度达到最小值。这就是<strong class="ky ir">动量优化</strong>的工作原理。这是通过添加一个<em class="ms">动量向量 m </em>并用来自<em class="ms">动量向量(m) </em>的这个新权重来更新θ参数来实现的</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/d76d7644b5ac51d49a58b230a3dca11a.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/format:webp/1*5gZaJ__zdhCC-Gclh_uuLw.png"/></div></figure><p id="1344" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">梯度下降不考虑以前的梯度。通过添加动量向量，它在每次迭代后更新权重<em class="ms"> m </em>。动量β <em class="ms"> </em>是控制终端速度有多快的参数，通常设置为 0.9，但应该从 0.5 调整到 0.9。因此，<em class="ms">动量优化器</em>比 SGD 收敛得更好更快。</p><pre class="kg kh ki kj gt mu mv mw mx aw my bi"><span id="0127" class="ls lt iq mv b gy mz na l nb nc"># Implement Momentum optimizer in Tensorflow<br/>optimizer=keras.optimizers.SGD(lr=0.001, momentum=0.99)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/aca93a1d3ede022d1bfa4a60a308d6f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/format:webp/1*TbKrVIsMZg28TK-rxeoAIg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">动量收敛更快，最终达到比 SGD 更好的结果</p></figure><h2 id="869d" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">3.内斯特罗夫加速梯度</h2><p id="c105" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">动量优化器的另一个变体是 NAG。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/d258b08a0c3467c6d9ac7d711a901c57.png" data-original-src="https://miro.medium.com/v2/resize:fit:810/format:webp/1*dKLSkXj2QFaI95h_po1dhQ.png"/></div></figure><p id="4d7e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">代价函数的梯度在位置θ+βm 处测量(而不是原始动量优化中的θ)。这背后的原因是动量优化已经指向了正确的方向，所以我们应该使用稍微靠前的位置(大约在θ的下一个位置)来适度加快收敛速度。</p><pre class="kg kh ki kj gt mu mv mw mx aw my bi"><span id="1f00" class="ls lt iq mv b gy mz na l nb nc"># Implement Nesterov Accelerated Gradient optimizer in Tensorflow<br/>optimizer=keras.optimizers.SGD(lr=0.001, momentum=0.9,nesterov=True</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/1be35a3bfe62250b704af2bf2f271970.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/format:webp/1*xgw6o3546a5BRq01se8Ffg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">NAG 仅取得了比最初势头稍好的结果</p></figure><h2 id="06ce" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">4.阿达格拉德</h2><p id="2ebd" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">一种自适应学习速率方法，在这种方法中，算法在陡坡上比在缓坡上走得更快。<em class="ms"> AdaGrad </em>在简单的二次问题中表现良好，但在训练神经网络时表现不佳，因为它往往会变慢得太快，并在达到全局最小值之前停止。由于这个缺点，我通常不使用<em class="ms"> AdaGrad </em>用于神经网络，而是使用<em class="ms"> RMSProp </em>，这是<em class="ms"> AdaGrad </em>的替代方案。</p><h2 id="6bd0" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">5.RMSProp —均方根 Prop</h2><p id="feb8" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">这是最常用的优化器之一，它延续了<em class="ms">阿达格拉德</em>的想法，试图最小化垂直移动，并在水平方向朝着全局最小值更新模型。</p><p id="7653" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ms"> Adagrad </em>对第一次迭代的梯度求和，这就是为什么它通常不会收敛到全局最小值，而 RMSProp 会累加前一次迭代的梯度:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/b6be08a0c44291c00371f7c6e7cdefce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zMXDobMGkMylDMsAfByGPA.png"/></div></div></figure><pre class="kg kh ki kj gt mu mv mw mx aw my bi"><span id="cbd3" class="ls lt iq mv b gy mz na l nb nc"># Implement RMSProp optimizer in Tensorflow<br/>optimizer=keras.optimizers.RMSprop(lr=0.001, rho=0.9)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/5d8667f6fc0b491114596d20cd98f807.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/format:webp/1*K-0KqOJW9aGv8-KgOTCTsA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">RMSProp 比 Adagrad 收敛得更好，Adagrad 在平稳状态下会丢失</p></figure><h2 id="8dd5" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">6.圣经》和《古兰经》传统中）亚当（人类第一人的名字</h2><p id="dd77" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">Adam 优化器是 momentum 和 RMSProp 优化器的组合。换句话说，它考虑了过去梯度的指数衰减平均值和过去平方梯度的指数衰减平均值。</p><p id="4da0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了这些特性，Adam 适合处理具有复杂数据和大量特征的复杂问题上的稀疏梯度。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/bd4745e236755305b7bc21a9eabe75b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z82P13qkXgwnWBptwv2Pfw.png"/></div></div></figure><pre class="kg kh ki kj gt mu mv mw mx aw my bi"><span id="96a7" class="ls lt iq mv b gy mz na l nb nc"># Implement Adam optimizer in Tensorflow<br/>optimizer=keras.optimizers.Adam(lr=0.001, beta_1=0.9, beta_2=0.999)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/8f6ccd076c9129f30006839c63363d48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/format:webp/1*7z5n_s7WQiLF8mX3pLwrbw.png"/></div></figure><h2 id="2baa" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">7.那达慕</h2><p id="eac2" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">亚当的另一个变化是那达慕(使用亚当优化与内斯特罗夫技术)，导致比亚当稍快的训练时间。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/9f08e56639037d2a4f963f93af984444.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/format:webp/1*PvA_P1xQPZQOpzhIVxI8PQ.png"/></div></figure><pre class="kg kh ki kj gt mu mv mw mx aw my bi"><span id="f051" class="ls lt iq mv b gy mz na l nb nc"># Implement Nadam optimizer in Tensorflow<br/>optimizer=keras.optimizers.Nadam(lr=0.001, beta_1=0.9, beta_2=0.999)</span></pre><p id="d166" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ms"> Adagrad、RMSProp、Ada、Nadam </em>和<em class="ms"> Adamax </em>是<em class="ms">自适应学习率算法</em>，对超参数的调整要求较少。如果模型的性能没有达到您的预期，您可以尝试换回<em class="ms">动量</em>优化器或<em class="ms">内斯特罗夫加速梯度</em></p><h1 id="dc9b" class="ng lt iq bd lu nh ni nj lx nk nl nm ma jw nn jx md jz no ka mg kc np kd mj nq bi translated">最后的话🖖</h1><p id="4824" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">总之，大多数时候，<em class="ms">自适应学习速率算法</em>在速度方面优于梯度下降及其变体，尤其是在深度神经网络中。然而，<em class="ms">自适应学习率算法</em>不能确保绝对收敛到全局最小值。</p><p id="9578" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您的模型不是太复杂，只有少量的特征，并且训练时间不是您的优先事项，使用动量、内斯特罗夫加速梯度或 SGD 是最佳起点，然后调整学习率、激活函数、改变初始化技术来改进模型，而不是使用<em class="ms">自适应学习率</em>优化器，因为后者会阻碍不收敛到全局最小值的风险。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/da8d9ca43d7e611cd0511837931efacc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d46LmLktXkwzyJ2PhloO5w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">比较不同优化器模型的损失</p></figure><ul class=""><li id="e34b" class="ns nt iq ky b kz la lc ld lf nu lj nv ln nw lr nx ny nz oa bi translated">常规<em class="ms"> SGD </em>或常规<em class="ms">梯度下降</em>需要更多时间收敛到全局最小值。阿达格拉德经常在达到全局最小值之前过早停止，所以它最终成为最差的优化器。</li><li id="69e3" class="ns nt iq ky b kz ob lc oc lf od lj oe ln of lr nx ny nz oa bi translated">利用<a class="ae kv" href="https://github.com/zalandoresearch/fashion-mnist" rel="noopener ugc nofollow" target="_blank">时尚 MNIST </a>数据集，<em class="ms">亚当/那达慕</em>最终表现优于<em class="ms"> RMSProp </em>和<em class="ms">动量/内斯特罗夫加速梯度</em>。这取决于型号，通常，<em class="ms">那达慕</em>比<em class="ms">亚当</em>表现更好，但有时<em class="ms"> RMSProp </em>表现最好。</li><li id="ecf1" class="ns nt iq ky b kz ob lc oc lf od lj oe ln of lr nx ny nz oa bi translated">以我的经验，我发现<em class="ms"> Momentum，RMSProp </em>，和<em class="ms"> Adam </em>(或<em class="ms"> Nadam </em>)应该是模型的初试。</li></ul><h2 id="b9a8" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">摘要</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/111ffa6b2084ee4b4ae45494165b1c2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L0m6JSx2RWzK0i09SmrJcA.png"/></div></div></figure></div><div class="ab cl oh oi hu oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="ij ik il im in"><p id="c146" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在这里找到源代码<a class="ae kv" href="https://github.com/geniusnhu/DNN-Improvement/blob/master/Tuning_Optimizer.ipynb" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="35ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过调整<strong class="ky ir">初始化、激活函数和批量归一化</strong>来提高深度神经网络性能和训练速度的详细说明在这里是<a class="ae kv" rel="noopener" target="_blank" href="/speed-up-training-and-improve-performance-in-deep-neural-net-5732274d51a2"/>。</p></div></div>    
</body>
</html>