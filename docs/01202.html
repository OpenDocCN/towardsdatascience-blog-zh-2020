<html>
<head>
<title>5 New Features in pandas 1.0 You Should Know About</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你应该知道的熊猫1.0的5个新特性</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/5-new-features-in-pandas-1-0-you-should-know-about-fc31c83e396b?source=collection_archive---------10-----------------------#2020-02-03">https://towardsdatascience.com/5-new-features-in-pandas-1-0-you-should-know-about-fc31c83e396b?source=collection_archive---------10-----------------------#2020-02-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d181" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">动态窗口功能，更快的应用和更多。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/aeb14d62ee29f1431f5daf72c0053a1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JO4NxIeeqMG31iHq.jpg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自imgflip.com的熊猫迷因</p></figure><p id="a35a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">熊猫1.0于2020年1月29日发布。版本从0.25跳到了1.0，并没有像一些熊猫用户期望的那样有太大的变化。版本的增加仅仅反映了数据处理库的成熟。</p><p id="801a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然没有多少突破性的变化，但有一些你应该知道。</p><p id="acfc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">这里有几个你可能会感兴趣的链接:</strong></p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="36b0" class="ma mb it lw b gy mc md l me mf">- <a class="ae ky" href="https://www.humanfirst.ai/" rel="noopener ugc nofollow" target="_blank">Labeling and Data Engineering for Conversational AI and Analytics</a></span><span id="4cac" class="ma mb it lw b gy mg md l me mf">- <a class="ae ky" href="https://imp.i115008.net/c/2402645/880006/11298" rel="noopener ugc nofollow" target="_blank">Data Science for Business Leaders</a> [Course]</span><span id="dff9" class="ma mb it lw b gy mg md l me mf">- <a class="ae ky" href="https://imp.i115008.net/c/2402645/788201/11298" rel="noopener ugc nofollow" target="_blank">Intro to Machine Learning with PyTorch</a> [Course]</span><span id="2a1c" class="ma mb it lw b gy mg md l me mf">- <a class="ae ky" href="https://imp.i115008.net/c/2402645/803127/11298" rel="noopener ugc nofollow" target="_blank">Become a Growth Product Manager</a> [Course]</span><span id="cf8c" class="ma mb it lw b gy mg md l me mf">- <a class="ae ky" href="https://amzn.to/3ncTG7D" rel="noopener ugc nofollow" target="_blank">Deep Learning (Adaptive Computation and ML series)</a> [Ebook]</span><span id="c588" class="ma mb it lw b gy mg md l me mf">- <a class="ae ky" href="https://aigents.co/skills" rel="noopener ugc nofollow" target="_blank">Free skill tests for Data Scientists &amp; Machine Learning Engineers</a></span></pre><p id="3897" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mh">上面的一些链接是附属链接，如果你通过它们进行购买，我会赚取佣金。请记住，我链接课程是因为它们的质量，而不是因为我从你的购买中获得的佣金。</em></p><p id="03fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要升级你的熊猫游戏，请阅读:</p><div class="mi mj gp gr mk ml"><a rel="noopener follow" target="_blank" href="/pandas-analytics-server-d9abceec888b"><div class="mm ab fo"><div class="mn ab mo cl cj mp"><h2 class="bd iu gy z fp mq fr fs mr fu fw is bi translated">熊猫分析服务器</h2><div class="ms l"><h3 class="bd b gy z fp mq fr fs mr fu fw dk translated">一个开源项目，简化了熊猫与实时数据的连接，测试假设和可视化…</h3></div><div class="mt l"><p class="bd b dl z fp mq fr fs mr fu fw dk translated">towardsdatascience.com</p></div></div><div class="mu l"><div class="mv l mw mx my mu mz ks ml"/></div></div></a></div><h1 id="838b" class="na mb it bd nb nc nd ne nf ng nh ni nj jz nk ka nl kc nm kd nn kf no kg np nq bi translated">1.具有滚动功能的动态窗口大小</h1><p id="11d2" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">处理时间序列数据时，滚动窗口函数非常有用(例如，移动平均值的计算)。以前版本的pandas要求我们传递窗口大小参数，例如计算3个周期的移动平均值。在pandas 1.0中，我们可以绕过这个要求，如下例所示。</p><p id="755d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们计算值的移动平均值，直到当前数字不大于10。首先，我们创建一个数据帧，其中3个值大于或等于10。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="24a3" class="ma mb it lw b gy mc md l me mf">df <strong class="lw iu">=</strong> pd<strong class="lw iu">.</strong>DataFrame({'col1': [1, 2, 3, 10, 2, 3, 11, 2, 3, 12, 1, 2]})<br/>df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/5705e1014f4a9a2b958df8d6202aafb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sZx3Rjma4kPmtpyiDbDplw.png"/></div></div></figure><p id="f40b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">车窗功能应展开，直到没有达到大于或等于10的值。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="05cd" class="ma mb it lw b gy mc md l me mf">use_expanding <strong class="lw iu">=</strong>  (df<strong class="lw iu">.</strong>col1 <strong class="lw iu">&gt;=</strong> 10)<strong class="lw iu">.</strong>tolist()<br/>use_expanding </span><span id="410d" class="ma mb it lw b gy mg md l me mf"># output<br/>[False,<br/> False,<br/> False,<br/> True,<br/> False,<br/> False,<br/> True,<br/> False,<br/> False,<br/> True,<br/> False,<br/> False]</span></pre><p id="ea8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于动态大小窗口函数，我们需要实现一个自定义索引器，它继承自pandas BaseIndexer类。BaseIndexer类有一个get_window_bounds函数，它计算每个窗口的开始和结束。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="908a" class="ma mb it lw b gy mc md l me mf">from pandas.api.indexers import BaseIndexer</span><span id="d127" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">class</strong> <strong class="lw iu">CustomIndexer</strong>(BaseIndexer):</span><span id="635c" class="ma mb it lw b gy mg md l me mf">    <strong class="lw iu">def</strong> <strong class="lw iu">get_window_bounds</strong>(self, num_values, min_periods, center, closed):<br/>        start <strong class="lw iu">=</strong> np<strong class="lw iu">.</strong>empty(num_values, dtype<strong class="lw iu">=</strong>np<strong class="lw iu">.</strong>int64)<br/>        end <strong class="lw iu">=</strong> np<strong class="lw iu">.</strong>empty(num_values, dtype<strong class="lw iu">=</strong>np<strong class="lw iu">.</strong>int64)<br/>        start_i <strong class="lw iu">=</strong> 0<br/>        <strong class="lw iu">for</strong> i <strong class="lw iu">in</strong> range(num_values):<br/>            <strong class="lw iu">if</strong> self<strong class="lw iu">.</strong>use_expanding[i]:<br/>                start[i] <strong class="lw iu">=</strong> start_i<br/>                start_i <strong class="lw iu">=</strong> end[i] <strong class="lw iu">=</strong> i <strong class="lw iu">+</strong> 1<br/>            <strong class="lw iu">else</strong>:<br/>                start[i] <strong class="lw iu">=</strong> start_i<br/>                end[i] <strong class="lw iu">=</strong> i <strong class="lw iu">+</strong> self<strong class="lw iu">.</strong>window_size<br/>        <strong class="lw iu">print</strong>('start', start)<br/>        <strong class="lw iu">print</strong>('end', end)<br/>        <strong class="lw iu">return</strong> start, end<br/></span><span id="336a" class="ma mb it lw b gy mg md l me mf">indexer <strong class="lw iu">=</strong> CustomIndexer(window_size<strong class="lw iu">=</strong>1, use_expanding<strong class="lw iu">=</strong>use_expanding)</span></pre><p id="8aec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将索引器类放入滚动函数中，并计算每个窗口的平均值。我们还可以观察每个窗口的开始和结束索引。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="15ea" class="ma mb it lw b gy mc md l me mf">df<strong class="lw iu">.</strong>rolling(indexer)<strong class="lw iu">.</strong>mean()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/421306e6c111c1b0a9b3a1f081996ea9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FxCF5aLlP_lcXpUTKajP6w.png"/></div></div></figure><h1 id="f68a" class="na mb it bd nb nc nd ne nf ng nh ni nj jz nk ka nl kc nm kd nn kf no kg np nq bi translated">2.更快的滚动应用</h1><p id="53c2" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">Pandas使用Cython作为滚动应用的默认执行引擎。在pandas 1.0中，我们可以将Numba指定为执行引擎，并获得不错的加速。</p><p id="5bc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有几件事需要注意:</p><ul class=""><li id="2df0" class="ny nz it lb b lc ld lf lg li oa lm ob lq oc lu od oe of og bi translated">需要安装Numba依赖项:pip安装numba，</li><li id="bb40" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">第一次使用Numba引擎运行函数会很慢，因为Numba会有一些函数编译开销。但是，滚动对象将缓存该函数，后续调用将会很快，</li><li id="7c7d" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">Numba引擎具有较大数量的数据点(例如1百万以上)，</li><li id="cfce" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">raw参数需要设置为True，这意味着该函数将接收numpy对象而不是pandas系列，以获得更好的性能。</li></ul><p id="0a42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建一个包含100万个值的数据框架。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="b800" class="ma mb it lw b gy mc md l me mf">df <strong class="lw iu">=</strong> pd<strong class="lw iu">.</strong>DataFrame({"col1": pd<strong class="lw iu">.</strong>Series(range(1_000_000))})<br/>df<strong class="lw iu">.</strong>head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/032f2ba5232f0c72754847f1d8f2f814.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VBa7qMY12HWanlrnP-VN8w.png"/></div></div></figure><p id="d382" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">some_function计算值的总和并加5。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="3e27" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">def</strong> <strong class="lw iu">some_function</strong>(x):<br/>    <strong class="lw iu">return</strong> np<strong class="lw iu">.</strong>sum(x) <strong class="lw iu">+</strong> 5</span></pre><p id="3fd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用Cython执行引擎来测量执行时间。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="0ed2" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">%%</strong>timeit</span><span id="c765" class="ma mb it lw b gy mg md l me mf">df<strong class="lw iu">.</strong>col1<strong class="lw iu">.</strong>rolling(100)<strong class="lw iu">.</strong>apply(some_function, engine<strong class="lw iu">=</strong>'cython', raw<strong class="lw iu">=</strong>True)</span><span id="373b" class="ma mb it lw b gy mg md l me mf">4.03 s ± 76.3 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</span></pre><p id="77df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Cython计算这个函数需要4.03秒。Numba更快吗？让我们试一试。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="e2c9" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">%%</strong>timeit</span><span id="4fe5" class="ma mb it lw b gy mg md l me mf">df<strong class="lw iu">.</strong>col1<strong class="lw iu">.</strong>rolling(100)<strong class="lw iu">.</strong>apply(some_function, engine<strong class="lw iu">=</strong>'numba', raw<strong class="lw iu">=</strong>True)</span><span id="d804" class="ma mb it lw b gy mg md l me mf">500 ms ± 11.5 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</span></pre><p id="9c27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到Numba在这个玩具例子中快了8倍。</p><h1 id="e075" class="na mb it bd nb nc nd ne nf ng nh ni nj jz nk ka nl kc nm kd nn kf no kg np nq bi translated">3.新NA值</h1><p id="3515" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">熊猫1.0引入了新的实验性pd。表示标量缺失值的NA值。</p><blockquote class="on"><p id="feb5" class="oo op it bd oq or os ot ou ov ow lu dk translated">我知道你在想什么——又一个空值？已经有nan，None和NaT了！</p></blockquote><p id="6053" class="pw-post-body-paragraph kz la it lb b lc ox ju le lf oy jx lh li oz lk ll lm pa lo lp lq pb ls lt lu im bi translated">pd的目标。NA将提供跨数据类型的一致性。它目前由Int64、boolean和新的string数据类型使用</p><p id="3599" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建一系列无整数。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="3ef6" class="ma mb it lw b gy mc md l me mf">s <strong class="lw iu">=</strong> pd<strong class="lw iu">.</strong>Series([3, 6, 9, None], dtype<strong class="lw iu">=</strong>"Int64")<br/>s</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/6ef42f22ebc97ec01ef2fcc6cedee698.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*em_SKef4XE-ZgSDj40O_BA.png"/></div></div></figure><p id="6e3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我惊讶的是，NA == NA产生NA，而np.nan == np.nan产生False。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="3dbf" class="ma mb it lw b gy mc md l me mf">s<strong class="lw iu">.</strong>loc[3] <strong class="lw iu">==</strong> s<strong class="lw iu">.</strong>loc[3]</span><span id="b563" class="ma mb it lw b gy mg md l me mf"># output<br/>&lt;NA&gt;<br/></span><span id="01e5" class="ma mb it lw b gy mg md l me mf">np<strong class="lw iu">.</strong>nan <strong class="lw iu">==</strong> np<strong class="lw iu">.</strong>nan</span><span id="cb79" class="ma mb it lw b gy mg md l me mf"># output<br/>False</span></pre><h1 id="94a8" class="na mb it bd nb nc nd ne nf ng nh ni nj jz nk ka nl kc nm kd nn kf no kg np nq bi translated">4.新字符串类型</h1><p id="e558" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">熊猫1.0终于有了一个专用的(实验性的)字符串类型。在1.0之前，字符串是作为对象存储的，所以我们不能确定这个系列是只包含字符串，还是混合了其他数据类型，如下所示。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="0ba8" class="ma mb it lw b gy mc md l me mf">s <strong class="lw iu">=</strong> pd<strong class="lw iu">.</strong>Series(['an', 'ban', 'pet', 'podgan', None])<br/>s</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/4e300eb590a27b08b8ee94ab19fa5f9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iNapnZ5UQjBrig-gfhLb5A.png"/></div></div></figure><p id="3b5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们无意中将字符串与整数或浮点数混合在一起时，将字符串存储为对象就成了一个问题——数据类型仍然是对象。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="bab5" class="ma mb it lw b gy mc md l me mf">s <strong class="lw iu">=</strong> pd<strong class="lw iu">.</strong>Series(['an', 'ban', 5, 'pet', 5.0, 'podgan', None])<br/>s</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/8e4082b58155721d6eb4923ff595b3c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jVVw9idjOvXJ8IZIVaHBbg.png"/></div></div></figure><p id="36d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了测试新的字符串dtype，我们需要设置dtype='string '。</p><blockquote class="on"><p id="7e17" class="oo op it bd oq or os ot ou ov ow lu dk translated">新的字符串数据类型返回序列中整数或浮点数的异常。进步很大！</p></blockquote><pre class="pe pf pg ph pi lv lw lx ly aw lz bi"><span id="075c" class="ma mb it lw b gy mc md l me mf">s <strong class="lw iu">=</strong> pd<strong class="lw iu">.</strong>Series(['an', 'ban', 'pet', 'podgan', None], dtype<strong class="lw iu">=</strong>'string')<br/>s</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/e451a5e32f792f8a022d9a179e4dd1b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bc4NYNspBTpOEkLHTcjlig.png"/></div></div></figure><h1 id="3457" class="na mb it bd nb nc nd ne nf ng nh ni nj jz nk ka nl kc nm kd nn kf no kg np nq bi translated">5.忽略排序数据帧上的索引</h1><p id="8c06" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">当我们按某一列对数据帧进行排序时，索引也会被排序。有时候我们不想这样。在pandas 1.0中，sort_values函数采用忽略索引，正如参数名称所示。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="41cb" class="ma mb it lw b gy mc md l me mf">df <strong class="lw iu">=</strong> pd<strong class="lw iu">.</strong>DataFrame({"col1": [1, 3, 5, 2, 3, 7, 1, 2]})</span><span id="b769" class="ma mb it lw b gy mg md l me mf">df<strong class="lw iu">.</strong>sort_values('col1')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/3c3b34471a51fad874edeb668dfd7c52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c3MYjwL2h4fNC9wAqNyuzQ.png"/></div></div></figure><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="a6f0" class="ma mb it lw b gy mc md l me mf">df<strong class="lw iu">.</strong>sort_values('col1', ignore_index<strong class="lw iu">=</strong>True)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pj"><img src="../Images/5875cb04b1503e578a670aa1097c0a64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_yb2-gvO1DkxoodSfoeVDA.png"/></div></div></figure><h1 id="2e36" class="na mb it bd nb nc nd ne nf ng nh ni nj jz nk ka nl kc nm kd nn kf no kg np nq bi translated">结论</h1><p id="b6c0" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">根据我的观点，这是5个最有趣的熊猫特征。从长远来看，缺失值的新NA可以给熊猫带来很多清晰度。函数如何处理丢失的值，它们是否跳过它们。</p><p id="274b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">折旧政策也有变化:</p><ul class=""><li id="2f9a" class="ny nz it lb b lc ld lf lg li oa lm ob lq oc lu od oe of og bi translated">次要版本(如1.1.0)中将引入弃用，</li><li id="90c6" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">在主要版本(如2.0.0)中，将强制实施不推荐使用和突破API的更改。我们应该升级还是继续使用当前的熊猫版本</li></ul><p id="4255" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">新的弃用政策提出了这个问题:“我应该更新熊猫吗？”比较好回答。似乎我们还可以期待未来更频繁的重大发布。要了解更多关于熊猫1.0的新特性，请阅读1.0.0的新特性。</p><h1 id="324c" class="na mb it bd nb nc nd ne nf ng nh ni nj jz nk ka nl kc nm kd nn kf no kg np nq bi translated">在你走之前</h1><p id="dea3" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">在<a class="ae ky" href="https://twitter.com/romanorac" rel="noopener ugc nofollow" target="_blank">推特</a>上关注我，在那里我定期<a class="ae ky" href="https://twitter.com/romanorac/status/1328952374447267843" rel="noopener ugc nofollow" target="_blank">发关于数据科学和机器学习的推特</a>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pk"><img src="../Images/b5d426b68cc5a21b1a35d0a157ebc4f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*69rP1pwjJi9mLSFE"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@cmhedger?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Courtney hedge</a>在<a class="ae ky" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure></div></div>    
</body>
</html>