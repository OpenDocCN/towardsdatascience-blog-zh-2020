<html>
<head>
<title>Build a Custom ResNetV2 with the desired depth from scratch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从头开始构建具有所需深度的自定义 ResNetV2</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/build-a-custom-resnetv2-with-the-desired-depth-92892ec79d4b?source=collection_archive---------18-----------------------#2020-04-05">https://towardsdatascience.com/build-a-custom-resnetv2-with-the-desired-depth-92892ec79d4b?source=collection_archive---------18-----------------------#2020-04-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="85c5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">本教程将帮助您从头开始构建一个具有任意深度/层数的 ResNet 模型</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e412be608f8e20ac39def93be666a993.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*chCna4p3A09VDC5hgLlfHg.png"/></div></div></figure><p id="39c2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">ResNet 一直是我最喜欢的架构之一，我已经多次使用其跳过连接的核心思想。它现在已经相当老了，因为 2015 年&amp; 2016 年<a class="ae ln" href="https://arxiv.org/abs/1512.03385" rel="noopener ugc nofollow" target="_blank"> ResNetV1 </a>(用于图像识别的深度残差学习)<a class="ae ln" href="https://arxiv.org/abs/1603.05027" rel="noopener ugc nofollow" target="_blank"> ResNetV2 </a>(深度残差网络中的身份映射)都出现了，但今天它的核心概念仍被广泛使用。所以你一定在想…为什么要在 2020 年出这个教程。</p><p id="fc71" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">本教程有两个主要原因:</p><ol class=""><li id="5580" class="lo lp iq kt b ku kv kx ky la lq le lr li ls lm lt lu lv lw bi translated">构建任意深度的 ResNetV2，而不仅仅是 ResNet50、ResNet101 或 ResNet152(包含在 keras 应用程序中)</li><li id="d9ca" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">Tensorflow 2.xx 的使用</li></ol><p id="d882" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">本教程分为两部分。第 1 部分将简要讨论 ResNet，第 2 部分将重点讨论编码部分。请记住，本教程的主要目标是展示从头开始构建具有任意深度/层数的 ResNet 模型的编码部分。</p></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="d9fe" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">第 1 部分:ResNet 简介</h1><p id="7d83" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">任何深度学习网络的最大问题之一是消失，爆炸梯度。这限制了我们深入网络。如果你不知道或不想更新，请参考视频。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h2 id="fc2b" class="ni mk iq bd ml nj nk dn mp nl nm dp mt la nn no mv le np nq mx li nr ns mz nt bi translated">所以问题是 ResNet 如何解决这个问题？</h2><p id="135f" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">我会试着用简单的话来表达。ResNet 的核心思想是基于跳过连接，也就是说，它允许从一个层获取激活，并将其提供给未来的层(可以更深)。考虑梯度消失的问题，当我们深入时，一些神经元将不会有任何贡献，因为它们的权重已经显著降低。但现在，如果我们从早期层激活，并在激活前添加到当前层，现在它肯定会有所贡献。</p><p id="109f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">参考这段视频，从数学角度更好地理解它</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="c533" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，不浪费时间，让我们转向编码部分</p></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="52d7" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">第 2 部分:编码</h1><p id="82f7" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">注意:我已经发布了包含所有代码的回购协议，可以在这里找到<a class="ae ln" href="https://github.com/Akashdesarda/ResNet-builder" rel="noopener ugc nofollow" target="_blank"/>。</p><ol class=""><li id="9c37" class="lo lp iq kt b ku kv kx ky la lq le lr li ls lm lt lu lv lw bi translated">首先，我们必须创建一个剩余块，它是 ResNet 的构建块。它被用作跳过连接器。ResNetV2 带来了一个微小的修改，与 V1 相反，首先使用卷积层，然后批量归一化。</li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nh l"/></div></figure><p id="42b7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在网络内部，有时不会首先使用卷积层，因此我们必须使用 if-else 循环。</p><p id="d94b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">2.接下来是添加层。出于同样的目的，我们将使用 Keras functional API</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nh l"/></div></figure><p id="89cf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">让我们一行一行来</strong></p><p id="d8b1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">→在第 7 行，我们接受输入</p><p id="53e4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">→第 10 行用于在分成两个路径之前创建卷积层。这里，我们使用的是之前创建的同一个剩余块。</p><p id="58b1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">→从第 13 行到第 55 行，用于创建剩余单元的堆栈。让我们更详细地讨论这个问题。在第 10 行之后，网络被分成两部分&amp;稍后添加。现在在第一部分中执行三个操作，</p><p id="f070" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">批量定额→激活→ Conv。</strong></p><p id="a0cb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个过程重复三次，最后相加。从 ResNet 的角度来看，在分裂之后，在一个子网中，我们执行一些操作(如上所述),并将其激活添加到我们分裂的状态中。所以你可以看到我们跳过了三层。</p><blockquote class="nv nw nx"><p id="a1ea" class="kr ks ny kt b ku kv jr kw kx ky ju kz nz lb lc ld oa lf lg lh ob lj lk ll lm ij bi translated">为什么是三层？这取决于你的直觉。它可以是两个或四个或任何东西。我发现用三层效果最好&amp;作者也建议用两层或三层。</p></blockquote><p id="d705" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">是时候深入研究代码了…稍微…:)</p><p id="c7f1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">→第 13 行开始在 for 循环中追加剩余块的堆栈。(这里跳过所需层的一个简单技巧是在该范围内循环开始)</p><p id="52f7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">→第 30–44 行用于在执行分割后，在一个子网中添加卷积层。</p><blockquote class="nv nw nx"><p id="57dc" class="kr ks ny kt b ku kv jr kw kx ky ju kz nz lb lc ld oa lf lg lh ob lj lk ll lm ij bi translated">这里你可以看到我已经用了三个剩余块。为什么是三个？因为我跳过了三次激活</p></blockquote><p id="0402" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">→第 45–53 行:执行分割后，第二个子网络必须是卷积层，可以跳过，稍后添加。</p><p id="2545" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">→第 54 行是所有魔法发生的地方:)。这里我们添加我们的两个子网络。</p><p id="4c21" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">3.最后一部分是连接一个<strong class="kt ir"> <em class="ny">完全连接到</em> </strong>层网络之上。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nh l"/></div></figure><p id="51e1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这部分你可以随意定制。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/d4c830fb79100ee957cb46ff1d966ed2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*DdX8LzxdU9tpa8yT7e1gvQ.png"/></div><p class="od oe gj gh gi of og bd b be z dk translated">深度为 11 的模型架构示例</p></figure><h2 id="da8f" class="ni mk iq bd ml nj nk dn mp nl nm dp mt la nn no mv le np nq mx li nr ns mz nt bi translated">一些需要注意的关键事项</h2><ol class=""><li id="8beb" class="lo lp iq kt b ku nb kx nc la oh le oi li oj lm lt lu lv lw bi translated">我写了一个注释“深度应该是 9n+2 ”,因为这里我跳过了三个激活，为了匹配分割前后的张量形状，深度必须根据公式选择。</li><li id="b27d" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">在步幅和内核大小上做了大量的调整来匹配张量的形状。我建议你在纸上写下一个循环，看看所有的调整，更彻底地理解它。</li><li id="0ec1" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">不要被跳过的连接器或残留的块所迷惑。它们之间的连接如下:在执行分割之后，创建了两条路径。路径一将具有三层或三个<strong class="kt ir"> <em class="ny">残余块</em> </strong>，路径二将具有一层或一个<strong class="kt ir"> <em class="ny">残余块</em> </strong>(现在该块与分割前相同)。现在，来自路径二的这个剩余块将被带到路径一，并在激活之前被添加。因此，该块跳过或跳过了三个块&amp;，从而成为一个<strong class="kt ir"> <em class="ny">跳过连接器。</em> </strong></li></ol></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="0190" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">第 3 部分:结尾注释和一些附加内容</h1><p id="d5b2" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">我建议你浏览一下我的 GitHub repo '<a class="ae ln" href="https://github.com/Akashdesarda/ResNet-builder" rel="noopener ugc nofollow" target="_blank">ResNet-builder</a>，因为它包含了很多我认为可能超出了本博客范围的 API。这个博客仅限于建立一个 ResNet 网络。但是要构建一个完整的 ResNet 系统，我们将需要更多的功能，如数据加载器、推理生成器、可视化模型性能等。我已经包含了所有这些 API。</p><p id="dc58" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">回购还支持多种配置来构建模型。</p><p id="1e66" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我试图让 API 尽可能直观，尽管如果你有任何困惑，你可以通过<a class="ae ln" href="https://www.linkedin.com/in/akashdesarda/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>联系我。</p></div></div>    
</body>
</html>