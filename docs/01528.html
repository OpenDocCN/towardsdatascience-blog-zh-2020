<html>
<head>
<title>How to Encode Categorical Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何对分类数据进行编码</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-encode-categorical-data-d44dde313131?source=collection_archive---------9-----------------------#2020-02-11">https://towardsdatascience.com/how-to-encode-categorical-data-d44dde313131?source=collection_archive---------9-----------------------#2020-02-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fe7a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从基础到高级的12种不同的编码技术</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9e380a9c75cdeb33e4e2e91a780d5ae7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CkBpCBIL5D4CxJcC0EYmnA.png"/></div></div></figure><p id="955a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这本笔记本中，我将介绍编码分类数据的不同方法。我想用简单的语言写出来，并加入一点数学知识。它们是你应该放入工具箱的基本编码方案。为了方便起见，我还会提供<code class="fe lq lr ls lt b">scikit-learn</code>版本和每个方法对应的库。</p><p id="1525" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这篇文章结束时，我希望你会对如何处理分类数据有一个更好的想法。你可以在这里找到我的代码<a class="ae lu" href="https://github.com/williamhuybui/Blog-Encoding-Scheme" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="368d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">目录</h1><p id="6c9b" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">对字符串数据类型进行编码有三种主要方法:</p><p id="dce4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">经典编码器:</strong>广为人知，应用广泛</p><ol class=""><li id="321a" class="ms mt it kw b kx ky la lb ld mu lh mv ll mw lp mx my mz na bi translated"><a class="ae lu" href="#6c53" rel="noopener ugc nofollow">序数</a></li><li id="8498" class="ms mt it kw b kx nb la nc ld nd lh ne ll nf lp mx my mz na bi translated"><a class="ae lu" href="#7033" rel="noopener ugc nofollow"> OneHot </a></li><li id="45a9" class="ms mt it kw b kx nb la nc ld nd lh ne ll nf lp mx my mz na bi translated"><a class="ae lu" href="#4aaf" rel="noopener ugc nofollow">二进制</a></li><li id="33d0" class="ms mt it kw b kx nb la nc ld nd lh ne ll nf lp mx my mz na bi translated"><a class="ae lu" href="#aecd" rel="noopener ugc nofollow">频率</a></li><li id="f3c9" class="ms mt it kw b kx nb la nc ld nd lh ne ll nf lp mx my mz na bi translated"><a class="ae lu" href="#a79a" rel="noopener ugc nofollow">散列法</a></li></ol><p id="9fda" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">对比编码器:</strong><strong class="kw iu"/>通过查看不同层次的特征对数据进行编码的创新方法</p><p id="22f2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">6.<a class="ae lu" href="#22a7" rel="noopener ugc nofollow">赫尔默特</a></p><p id="80a6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">7.<a class="ae lu" href="#0a4a" rel="noopener ugc nofollow">向后差异</a></p><p id="4f40" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">贝叶斯编码器:</strong>一种更高级的方法，使用目标作为编码的基础</p><p id="928b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">8.<a class="ae lu" href="#ffb7" rel="noopener ugc nofollow">目标</a></p><p id="14e2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">9.<a class="ae lu" href="#769d" rel="noopener ugc nofollow">漏掉一个</a></p><p id="a3b6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">10.<a class="ae lu" href="#2c52" rel="noopener ugc nofollow">证据的权重</a></p><p id="b268" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">11.詹姆斯-斯坦</p><p id="f600" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">12.<a class="ae lu" href="#0797" rel="noopener ugc nofollow">M-估计器</a></p><p id="a3a0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">而且还有很多！然而，一旦你知道这些最常见的编码方案是如何工作的，你会发现谷歌搜索另一种编码方案是相当容易的。</p><p id="3aa6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们创建一个随机的口袋妖怪数据集！</p><h1 id="120e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">资料组</h1><p id="fae3" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">我是一个超级粉丝，也是一个努力的口袋妖怪研磨者。我经常去口袋妖怪数据库看看我的队伍里应该有哪个口袋妖怪。有4个特征会影响我的选择:类型、大小、属性和传奇。我创建了这个只有10个观察值的样本数据，以更好地说明不同的编码技术，并给自己带来一些快乐！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/f830fad6866abb02cd6f8c7b3569d794.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YnetvZxA5tJ_OkBqEtuU_w.png"/></div></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">来源:<a class="ae lu" href="https://github.com/williamhuybui/Blog-Encoding-Scheme" rel="noopener ugc nofollow" target="_blank"> Huy Bui </a></p></figure><h1 id="948a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">I .经典编码器</h1><p id="9598" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">我们从最基本的技术开始，经典的编码器。顾名思义，这些编码器是众所周知的和广泛使用的。他们的概念也非常直接。</p><h2 id="4569" class="nl lw it bd lx nm nn dn mb no np dp mf ld nq nr mh lh ns nt mj ll nu nv ml nw bi translated">1)顺序编码</h2><p id="723d" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">序数特征是具有顺序的特征。这种类型的数据也称为<strong class="kw iu">序数数据</strong>。让我们看看数据框中的<code class="fe lq lr ls lt b">Height</code>列。这些类别是:<code class="fe lq lr ls lt b"><em class="nx">very short,</em></code><em class="nx"/><code class="fe lq lr ls lt b"><em class="nx">short</em></code><em class="nx"/><code class="fe lq lr ls lt b"><em class="nx">normal</em></code><em class="nx"/><code class="fe lq lr ls lt b"><em class="nx">tall</em></code><em class="nx"/><code class="fe lq lr ls lt b"><em class="nx">very tal</em>l</code>，按升序/降序排列是有意义的。通过手动编码列，我们可以显著提高模型性能。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/90ead249b9c5cb6fc0a8745f91e8409e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O2h-DtiO4ceqTJpNHP-r8Q.png"/></div></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">来源:<a class="ae lu" href="https://github.com/williamhuybui/Blog-Encoding-Scheme" rel="noopener ugc nofollow" target="_blank"> Huy Bui </a></p></figure><h2 id="d096" class="nl lw it bd lx nm nn dn mb no np dp mf ld nq nr mh lh ns nt mj ll nu nv ml nw bi translated">2)一键编码</h2><p id="007a" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">再来看专栏<code class="fe lq lr ls lt b">Type</code>。这是与<code class="fe lq lr ls lt b">Height</code>栏中的<strong class="kw iu">序号数据</strong>相反的<strong class="kw iu">名义</strong>数据。将该列转换为数字的最简单方法是通过以下两个步骤使用<strong class="kw iu">一键编码</strong></p><ul class=""><li id="3f89" class="ms mt it kw b kx ky la lb ld mu lh mv ll mw lp nz my mz na bi translated">将一列中的所有类别拆分到不同的列中</li><li id="9f35" class="ms mt it kw b kx nb la nc ld nd lh ne ll nf lp nz my mz na bi translated">将勾号<em class="nx"> 1 </em>放在适当的位置</li></ul><p id="4cd4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">熊猫的<code class="fe lq lr ls lt b">get_dummies</code>功能可以达到这个目的</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/f163af1b2d9d847ea1e58f2bf62ceb9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UH1hq5hWKzEZRccwBTIw6A.png"/></div></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">来源:<a class="ae lu" href="https://github.com/williamhuybui/Blog-Encoding-Scheme" rel="noopener ugc nofollow" target="_blank"> Huy Bui </a></p></figure><h2 id="4aaf" class="nl lw it bd lx nm nn dn mb no np dp mf ld nq nr mh lh ns nt mj ll nu nv ml nw bi translated">3)二进制编码</h2><p id="3691" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">想象你有<code class="fe lq lr ls lt b">200</code>个不同的类别。一键编码将创建200个不同的列。大量的列会占用大量的内存。与此同时，<strong class="kw iu">二进制编码</strong>只需要8列。它利用了二进制系统，所以一行中可能有多个1。二进制编码背后的逻辑解释是:</p><ul class=""><li id="7a63" class="ms mt it kw b kx ky la lb ld mu lh mv ll mw lp nz my mz na bi translated">沿着列往下，每次看到一个新的类别，它都会给出一个数字，从1开始(下一个是2)</li><li id="a562" class="ms mt it kw b kx nb la nc ld nd lh ne ll nf lp nz my mz na bi translated">将这些数字转换成二进制</li><li id="70ea" class="ms mt it kw b kx nb la nc ld nd lh ne ll nf lp nz my mz na bi translated">将该二进制中的每个数字放在单独的列中。</li></ul><p id="20aa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在下面的代码中，我将添加<code class="fe lq lr ls lt b">encounter step</code>列，这样您可以看到它是如何工作的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/ca0f0f279c3b10affd7e0e868921ea38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6TGbbF5CLa5_VBt99SrquQ.png"/></div></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">来源:<a class="ae lu" href="https://github.com/williamhuybui/Blog-Encoding-Scheme" rel="noopener ugc nofollow" target="_blank"> Huy Bui </a></p></figure><h2 id="aecd" class="nl lw it bd lx nm nn dn mb no np dp mf ld nq nr mh lh ns nt mj ll nu nv ml nw bi translated">4)频率编码</h2><p id="1208" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">给每个类别一个<strong class="kw iu">概率</strong>(发生/总事件)。这意味着，如果一列中有两个具有相同概率的类别(3 <code class="fe lq lr ls lt b">fire</code>和3 <code class="fe lq lr ls lt b">bugs</code>)，在进行频率编码后，您无法真正区分它们。代价是不会引入新的列。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/fa6f17d12ba5a464757ed8278e7c0473.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wpxqYX6mk-tl5K9pBHPySQ.png"/></div></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">资料来源:<a class="ae lu" href="https://github.com/williamhuybui/Blog-Encoding-Scheme" rel="noopener ugc nofollow" target="_blank"> Huy Bui </a></p></figure><h2 id="a79a" class="nl lw it bd lx nm nn dn mb no np dp mf ld nq nr mh lh ns nt mj ll nu nv ml nw bi translated">5)散列编码</h2><p id="5667" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">哈希将分类变量转换为更高维的整数空间。由于scikit-learn 已经很好地解释了这个方法，所以我不会在这里过多地评论它。</p><p id="8636" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">n_feature</code>是要添加的列数。这些新列区分相应的类别。但是，您可以调整到任何数字。这就像类固醇上的二进制编码！</p><p id="5e4c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">优势</strong></p><ul class=""><li id="1784" class="ms mt it kw b kx ky la lb ld mu lh mv ll mw lp nz my mz na bi translated">处理大规模分类特征</li><li id="0f5a" class="ms mt it kw b kx nb la nc ld nd lh ne ll nf lp nz my mz na bi translated">高速和减少的内存使用</li></ul><p id="d8ba" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">缺点</strong></p><ul class=""><li id="839e" class="ms mt it kw b kx ky la lb ld mu lh mv ll mw lp nz my mz na bi translated">无逆变换方法</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/5b969f0e3010cf3d25e93f022cb01e2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8u1sqB4KEJidqWrXUm3TMw.png"/></div></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">来源:<a class="ae lu" href="https://github.com/williamhuybui/Blog-Encoding-Scheme" rel="noopener ugc nofollow" target="_blank"> Huy Bui </a></p></figure><p id="4d18" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">注:</strong>什么是好的回特征数？如果<code class="fe lq lr ls lt b">m</code>是明显的特征，而<code class="fe lq lr ls lt b">n_feature=k</code>，那么<code class="fe lq lr ls lt b">m&lt;2^k</code></p><h1 id="77f0" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">二。对比度编码器</h1><p id="4fd6" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">对比编码允许类别变量重新居中，使得模型的截距不是类别的一个级别的平均值，而是数据集中所有数据点的平均值。</p><p id="0acf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">许多人认为这些编码不是很有效。但是，我将它们留在这里作为参考。</p><h2 id="22a7" class="nl lw it bd lx nm nn dn mb no np dp mf ld nq nr mh lh ns nt mj ll nu nv ml nw bi translated">6)赫尔默特(反向)编码</h2><p id="397e" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated"><strong class="kw iu">赫尔默特编码</strong>将分类变量的每个级别与后续级别的平均值进行比较。<a class="ae lu" href="https://stats.idre.ucla.edu/r/library/r-library-contrast-coding-systems-for-categorical-variables/#HELMERT" rel="noopener ugc nofollow" target="_blank">多读书。</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/703c02ab05f3e719357ec730a84ebe90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mqqcne2bTYQQVpGy3juBhw.png"/></div></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">资料来源:<a class="ae lu" href="https://github.com/williamhuybui/Blog-Encoding-Scheme" rel="noopener ugc nofollow" target="_blank"> Huy Bui </a></p></figure><h2 id="0a4a" class="nl lw it bd lx nm nn dn mb no np dp mf ld nq nr mh lh ns nt mj ll nu nv ml nw bi translated">7)后向差分编码</h2><p id="7be5" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">在<strong class="kw iu">后向差分编码</strong>中，一个级别因变量的平均值与前一个级别因变量的平均值进行比较。<a class="ae lu" href="http://www.statsmodels.org/dev/contrasts.html" rel="noopener ugc nofollow" target="_blank">阅读更多</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/35033557adf2117e8218fafd62c1f41b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nVKOpbVHYu3g13cBkbIdZw.png"/></div></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">来源:<a class="ae lu" href="https://github.com/williamhuybui/Blog-Encoding-Scheme" rel="noopener ugc nofollow" target="_blank"> Huy Bui </a></p></figure><h1 id="f3d1" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">三。贝叶斯目标编码器</h1><p id="a82d" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">这种方法的总体思想是考虑目标。</p><p id="7ca0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">优势:</strong></p><ul class=""><li id="2557" class="ms mt it kw b kx ky la lb ld mu lh mv ll mw lp nz my mz na bi translated">只需很少的工作，只需为该特性中任意数量的类别创建一个列</li><li id="edc8" class="ms mt it kw b kx nb la nc ld nd lh ne ll nf lp nz my mz na bi translated">Kaggle竞赛中最受欢迎的编码方案</li></ul><p id="4763" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">缺点:</strong></p><ul class=""><li id="7a7a" class="ms mt it kw b kx ky la lb ld mu lh mv ll mw lp nz my mz na bi translated">只为监督学习工作(因此，本质上是有漏洞的)。这意味着在处理无监督数据时，情况会变得更糟！</li><li id="a93c" class="ms mt it kw b kx nb la nc ld nd lh ne ll nf lp nz my mz na bi translated">由于前面的原因，需要正规化</li></ul><h2 id="ffb7" class="nl lw it bd lx nm nn dn mb no np dp mf ld nq nr mh lh ns nt mj ll nu nv ml nw bi translated">8)目标编码</h2><p id="5dc2" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated"><strong class="kw iu">基于目标的编码</strong>基本上是指使用目标对分类特征进行编码。它的公式是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/13857f0d5714f08e543a331c17c54f84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cVlcd1LTa7xkYImmJXajcA.png"/></div></div></figure><p id="b846" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在下表中，<code class="fe lq lr ls lt b">Legendary</code>是我们的目标。由于<code class="fe lq lr ls lt b">3</code> <code class="fe lq lr ls lt b">Fire</code>口袋妖怪中只有<code class="fe lq lr ls lt b">1</code>是传说中的，所以它的价值就是<code class="fe lq lr ls lt b">1/3</code>。把目标编码想象成目标上的频率编码！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/2b814fe9f1945c1c801f4852106d31e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-ydyD5NiAwb7coZAzWw4lg.png"/></div></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">资料来源:<a class="ae lu" href="https://github.com/williamhuybui/Blog-Encoding-Scheme" rel="noopener ugc nofollow" target="_blank"> Huy Bui </a></p></figure><p id="dc33" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">注意:</strong>有一些不同的版本将输出乘以一个<code class="fe lq lr ls lt b">(Laplace)smoothing value.</code>这是为了避免数据泄漏。</p><h2 id="769d" class="nl lw it bd lx nm nn dn mb no np dp mf ld nq nr mh lh ns nt mj ll nu nv ml nw bi translated">9)省去一个编码</h2><p id="f44f" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated"><strong class="kw iu">留一个编码(LOOE) </strong>与目标编码非常相似，但在计算某个级别的平均目标以减少异常值的影响时，会排除当前行的目标。</p><p id="1141" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，您可以通过在0和1之间更改sigma值，向数据中添加一些(高斯)噪声，以防止过度拟合。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/dc54a097eb8c40d4f7c96817244388b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SqeySvgF_Jnd6lb20TA8pA.png"/></div></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">来源:<a class="ae lu" href="https://github.com/williamhuybui/Blog-Encoding-Scheme" rel="noopener ugc nofollow" target="_blank"> Huy Bui </a></p></figure><h2 id="2c52" class="nl lw it bd lx nm nn dn mb no np dp mf ld nq nr mh lh ns nt mj ll nu nv ml nw bi translated">10)证据权重编码</h2><p id="ab51" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">证据权重编码(WoE)是对证据支持或破坏假设程度的衡量。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/d2e110fb9ecddd184f8d30a160c2e376.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cjDxC4tILAAYcJ7FwlVqEg.png"/></div></div></figure><p id="8a85" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">其中<code class="fe lq lr ls lt b">adj</code>是相邻因子，是一个避免除以0的函数。</p><p id="ac07" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">优势:</strong></p><ul class=""><li id="2567" class="ms mt it kw b kx ky la lb ld mu lh mv ll mw lp nz my mz na bi translated">与逻辑回归配合良好，因为WoE转换具有相同的逻辑标度。</li><li id="8e1a" class="ms mt it kw b kx nb la nc ld nd lh ne ll nf lp nz my mz na bi translated">可以使用WoE来比较不同特性，因为它们的值是标准化的。</li></ul><p id="f94e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">缺点:</strong></p><ul class=""><li id="f683" class="ms mt it kw b kx ky la lb ld mu lh mv ll mw lp nz my mz na bi translated">可能会丢失信息，因为某些类别可能具有相同的WoE</li><li id="93f7" class="ms mt it kw b kx nb la nc ld nd lh ne ll nf lp nz my mz na bi translated">不考虑特征相关性</li><li id="e81d" class="ms mt it kw b kx nb la nc ld nd lh ne ll nf lp nz my mz na bi translated">过度拟合</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/50c8181cc891772326ca4f0584bbf575.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fqt047rnZ_2LQiNIdc7KJQ.png"/></div></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">来源:<a class="ae lu" href="https://github.com/williamhuybui/Blog-Encoding-Scheme" rel="noopener ugc nofollow" target="_blank"> Huy Bui </a></p></figure><p id="2a6b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">注:</strong>我们可以通过改变正则化来调整<code class="fe lq lr ls lt b">adj</code>因子。(默认情况下为1)。当将其设置为0时。你回到原来的悲哀，可能会遇到除以0</p><h2 id="bbad" class="nl lw it bd lx nm nn dn mb no np dp mf ld nq nr mh lh ns nt mj ll nu nv ml nw bi translated">11)詹姆士-斯坦编码(JSE)</h2><p id="fd38" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">这是目标编码，但更健壮。<strong class="kw iu"> James-Stein (JS) </strong>对于具有正态分布的特征，它是最有效的。JS由以下公式定义:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/e6b9ca37525662bca1b4768ee7ca7d74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n9iszZLd-zvQtilgclEjLA.png"/></div></div></figure><p id="95fa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">权重<code class="fe lq lr ls lt b">B</code>取决于方差<code class="fe lq lr ls lt b"><em class="nx">σ(y)</em></code>和<code class="fe lq lr ls lt b"><em class="nx">σ(yi)</em></code>。更多关于这个方法的<a class="ae lu" href="https://kiwidamien.github.io/james-stein-encoder.html" rel="noopener ugc nofollow" target="_blank">在这里</a>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/d50f9491db60182008fe1d543a4be36a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TkR1WkzX7A_GVDToTYv3mg.png"/></div></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">资料来源:<a class="ae lu" href="https://github.com/williamhuybui/Blog-Encoding-Scheme" rel="noopener ugc nofollow" target="_blank"> Huy Bui </a></p></figure><h2 id="0797" class="nl lw it bd lx nm nn dn mb no np dp mf ld nq nr mh lh ns nt mj ll nu nv ml nw bi translated">12) M估计编码</h2><p id="b450" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated"><strong class="kw iu"> M估计编码器</strong>是目标编码器的简化版本。代表最大似然型。它只有一个超参数<code class="fe lq lr ls lt b">m</code>，代表正规化的力量。m值越高，收缩越强。推荐值<code class="fe lq lr ls lt b">m</code>在<code class="fe lq lr ls lt b">1</code>到<code class="fe lq lr ls lt b">100</code>的范围内。更多关于它的<a class="ae lu" href="https://en.wikipedia.org/wiki/M-estimator" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/c2147bd79b0c8ff8c8ee4f032b6a5caa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*haQTcP9N2E_xdhWqeD7FpQ.png"/></div></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">来源:<a class="ae lu" href="https://github.com/williamhuybui/Blog-Encoding-Scheme" rel="noopener ugc nofollow" target="_blank"> Huy Bui </a></p></figure><h1 id="a582" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">动词 （verb的缩写）结论</h1><p id="3ccc" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">对特征进行编码没有单一的公式。然而，如果你理解我上面介绍的<code class="fe lq lr ls lt b">12</code>编码技术，你将能够快速移动。此外，尝试所有适用于该特性的技术并决定哪一种效果最好总是值得的。尝试输入不同的正则化系数值，看看它们是否增加你的分数。下面的备忘单将帮助你做一些初步的决定。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/79fbe7ed3c98d35123d5012600e6d0bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Br3ZcQIf95TvcQozWctgIA.png"/></div></div><p class="nh ni gj gh gi nj nk bd b be z dk translated">分类编码备忘单</p></figure><p id="fe89" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">玩编码器玩得开心！</p></div></div>    
</body>
</html>