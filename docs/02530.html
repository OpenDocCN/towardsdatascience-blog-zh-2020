<html>
<head>
<title>8 Useful Tree Data Structures Worth Knowing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">值得了解的8种有用的树数据结构</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/8-useful-tree-data-structures-worth-knowing-8532c7231e8c?source=collection_archive---------3-----------------------#2020-03-11">https://towardsdatascience.com/8-useful-tree-data-structures-worth-knowing-8532c7231e8c?source=collection_archive---------3-----------------------#2020-03-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7edc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">8种不同树形数据结构的概述</h2></div><p id="9e6d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当你想到一棵树时，你会想到什么？根、枝、叶？你可能会想到一棵有根、有枝、有叶的大橡树。同样，在计算机科学中，树形数据结构有根，有枝，有叶，但是画倒了。树是一种分层数据结构，可以表示不同节点之间的关系。在本文中，我将简要介绍8种类型的树数据结构。</p><h2 id="7bbb" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">树的属性</h2><ul class=""><li id="ecec" class="lx ly it kk b kl lz ko ma kr mb kv mc kz md ld me mf mg mh bi translated">一个树可以不包含任何节点，也可以包含一个称为根<strong class="kk iu">的特殊节点，根</strong>有零个或多个子树。</li><li id="fad1" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated">树的每条边都直接或间接地起源于根。</li><li id="c5df" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated">每个孩子只有一个父母，但一个父母可以有很多孩子。</li></ul><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi mn"><img src="../Images/2e155ea2d6f6d43ec6c97c2b0383604f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PWJiwTxRdQy8A_Y0hAv5Eg.png"/></div></div><p class="mz na gj gh gi nb nc bd b be z dk translated">图一。树木术语</p></figure><p id="18f5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我将简要解释以下10种树数据结构及其用法。</p><ol class=""><li id="381c" class="lx ly it kk b kl km ko kp kr nd kv ne kz nf ld ng mf mg mh bi translated">通用树</li><li id="5417" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld ng mf mg mh bi translated">二叉树</li><li id="8c4a" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld ng mf mg mh bi translated">二叉查找树</li><li id="8c87" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld ng mf mg mh bi translated">AVL树</li><li id="e2b6" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld ng mf mg mh bi translated">红黑树</li><li id="1a1a" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld ng mf mg mh bi translated">八字树</li><li id="b9d0" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld ng mf mg mh bi translated">Treap</li><li id="b7fd" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld ng mf mg mh bi translated">B树</li></ol><h1 id="d560" class="nh lf it bd lg ni nj nk lj nl nm nn lm jz no ka lp kc np kd ls kf nq kg lv nr bi translated">1.通用树</h1><p id="102b" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr ns kt ku kv nt kx ky kz nu lb lc ld im bi translated">一个<strong class="kk iu">通用树</strong>是一个树形数据结构，其中没有对层次结构的约束。</p><h2 id="b14a" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">性能</h2><ol class=""><li id="33d3" class="lx ly it kk b kl lz ko ma kr mb kv mc kz md ld ng mf mg mh bi translated">遵循树的属性。</li><li id="d025" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld ng mf mg mh bi translated">一个节点可以有任意数量的子节点。</li></ol><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi nv"><img src="../Images/87082bb57189e625b6ea760583b9c4ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rInucvqb9X8bqM5yE143SQ.png"/></div></div><p class="mz na gj gh gi nb nc bd b be z dk translated">图二。通用树</p></figure><h2 id="2ff2" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">使用</h2><ol class=""><li id="3738" class="lx ly it kk b kl lz ko ma kr mb kv mc kz md ld ng mf mg mh bi translated">用于存储分层数据，如文件夹结构。</li></ol><h1 id="3839" class="nh lf it bd lg ni nj nk lj nl nm nn lm jz no ka lp kc np kd ls kf nq kg lv nr bi translated">1.二叉树</h1><p id="4458" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr ns kt ku kv nt kx ky kz nu lb lc ld im bi translated">一个<strong class="kk iu">二叉树</strong>是一个树形数据结构，其中可以找到以下属性。</p><h2 id="19e5" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">性能</h2><ol class=""><li id="698e" class="lx ly it kk b kl lz ko ma kr mb kv mc kz md ld ng mf mg mh bi translated">遵循树的属性。</li><li id="1eb4" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld ng mf mg mh bi translated">一个节点最多可以有两个子节点(子节点)。</li><li id="30e3" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld ng mf mg mh bi translated">这两个子节点被称为<strong class="kk iu"> <em class="nw">左子节点</em> </strong>和<strong class="kk iu"> <em class="nw">右子节点</em> </strong>。</li></ol><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi nx"><img src="../Images/470b78a1a82c430b9a299412ae4e560b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*abunFFnReygaqVt93xNr2A.png"/></div></div><p class="mz na gj gh gi nb nc bd b be z dk translated">图三。二叉树</p></figure><h2 id="0b64" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">使用</h2><ol class=""><li id="10eb" class="lx ly it kk b kl lz ko ma kr mb kv mc kz md ld ng mf mg mh bi translated">由编译器用来构建语法树。</li><li id="af4b" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld ng mf mg mh bi translated">用于实现表达式解析器和表达式求解器。</li><li id="b3f9" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld ng mf mg mh bi translated">用于存储路由器中的路由表。</li></ol><h1 id="36af" class="nh lf it bd lg ni nj nk lj nl nm nn lm jz no ka lp kc np kd ls kf nq kg lv nr bi translated">3.二叉查找树</h1><p id="bb4f" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr ns kt ku kv nt kx ky kz nu lb lc ld im bi translated">二叉查找树是二叉树的一个更严格的扩展。</p><h2 id="66c8" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">性能</h2><ol class=""><li id="f839" class="lx ly it kk b kl lz ko ma kr mb kv mc kz md ld ng mf mg mh bi translated">遵循二叉树的属性。</li><li id="8e41" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld ng mf mg mh bi translated">有一个独特的属性叫做<strong class="kk iu">二叉搜索树属性</strong>。该属性声明给定节点的左子节点的值(或键)应该小于或等于父节点的值，右子节点的值应该大于或等于父节点的值。</li></ol><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi ny"><img src="../Images/d8d3498494d9300e2e749a600e074a8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jBgV9A847f_pHMbO67tcgw.png"/></div></div><p class="mz na gj gh gi nb nc bd b be z dk translated">图4。二叉查找树</p></figure><h2 id="97fd" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">使用</h2><ol class=""><li id="557e" class="lx ly it kk b kl lz ko ma kr mb kv mc kz md ld ng mf mg mh bi translated">用于实现简单的排序算法。</li><li id="83ce" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld ng mf mg mh bi translated">可以用作优先级队列。</li><li id="7b40" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld ng mf mg mh bi translated">在许多数据不断进出的搜索应用程序中使用。</li></ol><h1 id="027b" class="nh lf it bd lg ni nj nk lj nl nm nn lm jz no ka lp kc np kd ls kf nq kg lv nr bi translated">4.AVL树</h1><p id="741d" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr ns kt ku kv nt kx ky kz nu lb lc ld im bi translated">AVL树是一种自平衡二叉查找树。这是第一棵自动平衡高度的树。</p><h2 id="b9d1" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">性能</h2><ol class=""><li id="fdd4" class="lx ly it kk b kl lz ko ma kr mb kv mc kz md ld ng mf mg mh bi translated">遵循二分搜索法树的属性。</li><li id="34a6" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld ng mf mg mh bi translated">自我平衡。</li><li id="800a" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld ng mf mg mh bi translated">每个节点存储一个名为<strong class="kk iu">平衡因子</strong>的值，该值是其左侧子树和右侧子树之间的高度差。</li><li id="fd1d" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld ng mf mg mh bi translated">所有节点的平衡系数必须为-1、0或1。</li></ol><p id="68c4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在执行插入或删除之后，如果至少有一个节点不具有-1、0或1的平衡因子，则应该执行旋转来平衡树(自平衡)。你可以从<a class="ae nz" rel="noopener" target="_blank" href="/self-balancing-binary-search-trees-101-fc4f51199e1d"> <strong class="kk iu">这里</strong> </a>阅读我之前文章中关于旋转操作的更多内容。</p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi oa"><img src="../Images/070ca7aa217505409e69c06a62e395ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aI575o1BBE3B4cAFUG73pw.png"/></div></div><p class="mz na gj gh gi nb nc bd b be z dk translated">图五。AVL树</p></figure><h2 id="d7fa" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">使用</h2><ol class=""><li id="f90a" class="lx ly it kk b kl lz ko ma kr mb kv mc kz md ld ng mf mg mh bi translated">用于需要频繁插入的情况。</li><li id="fe7b" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld ng mf mg mh bi translated">在Linux内核的内存管理子系统中使用，用于在抢占期间搜索进程的内存区域。</li></ol><h1 id="7791" class="nh lf it bd lg ni nj nk lj nl nm nn lm jz no ka lp kc np kd ls kf nq kg lv nr bi translated">5.红黑树</h1><p id="66f6" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr ns kt ku kv nt kx ky kz nu lb lc ld im bi translated">红黑树是一个自我平衡的二叉查找树，每个节点都有一种颜色；红色或黑色。节点的颜色用于确保树在插入和删除过程中保持近似平衡。</p><h2 id="046e" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">性能</h2><ol class=""><li id="ee8a" class="lx ly it kk b kl lz ko ma kr mb kv mc kz md ld ng mf mg mh bi translated">遵循二分搜索法树的属性。</li><li id="aae5" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld ng mf mg mh bi translated">自我平衡。</li><li id="3788" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld ng mf mg mh bi translated">每个节点不是红色就是黑色。</li><li id="4f5d" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld ng mf mg mh bi translated">根是黑色的(有时省略)。</li><li id="e1ca" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld ng mf mg mh bi translated">所有的叶子(标记为NIL)都是黑色的。</li><li id="b12e" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld ng mf mg mh bi translated">如果一个节点是红色的，那么它的两个子节点都是黑色的。</li><li id="06d7" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld ng mf mg mh bi translated">从给定节点到它的任何叶节点的每条路径必须经过相同数量的黑节点。</li></ol><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi ob"><img src="../Images/11493ef153a0f0ae5e7b4eab790f2f46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*11zvjUozpAenuez03oUeYA.png"/></div></div><p class="mz na gj gh gi nb nc bd b be z dk translated">图六。AVL树</p></figure><h2 id="d452" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">使用</h2><ol class=""><li id="f891" class="lx ly it kk b kl lz ko ma kr mb kv mc kz md ld ng mf mg mh bi translated">作为计算几何中使用的数据结构的基础。</li><li id="bff8" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld ng mf mg mh bi translated">用于当前Linux内核中使用的<em class="nw">完全公平调度器</em>。</li><li id="8f4e" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld ng mf mg mh bi translated">用于Linux内核的<em class="nw"> epoll </em>系统调用实现。</li></ol><h1 id="1e23" class="nh lf it bd lg ni nj nk lj nl nm nn lm jz no ka lp kc np kd ls kf nq kg lv nr bi translated">6.八字树</h1><p id="b53b" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr ns kt ku kv nt kx ky kz nu lb lc ld im bi translated">八字形采油树是一种自平衡二叉查找树。</p><h2 id="5313" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">性能</h2><ol class=""><li id="ab7d" class="lx ly it kk b kl lz ko ma kr mb kv mc kz md ld ng mf mg mh bi translated">遵循二分搜索法树的属性。</li><li id="a3ee" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld ng mf mg mh bi translated">自我平衡。</li><li id="fb20" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld ng mf mg mh bi translated">最近访问过的元素可以快速地再次访问。</li></ol><p id="44b9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在执行搜索、插入或删除后，张开树执行一个称为<strong class="kk iu">张开</strong>的动作，其中树被重新排列(使用旋转),使得特定元素被放置在树的根部。</p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi oc"><img src="../Images/b096aecf567bdbf91d59ba225792842b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w5MA0XAEk1vX1lef4cUbdA.png"/></div></div><p class="mz na gj gh gi nb nc bd b be z dk translated">图7。显示树搜索</p></figure><h2 id="2340" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">使用</h2><ol class=""><li id="3b01" class="lx ly it kk b kl lz ko ma kr mb kv mc kz md ld ng mf mg mh bi translated">用于实现缓存</li><li id="78db" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld ng mf mg mh bi translated">用于垃圾收集器。</li><li id="55d2" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld ng mf mg mh bi translated">用于数据压缩</li></ol><h1 id="e5b3" class="nh lf it bd lg ni nj nk lj nl nm nn lm jz no ka lp kc np kd ls kf nq kg lv nr bi translated">7.Treap</h1><p id="4dcb" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr ns kt ku kv nt kx ky kz nu lb lc ld im bi translated">一个<strong class="kk iu">树堆</strong>(这个名字来源于<strong class="kk iu">树+堆</strong>)就是一个二叉查找树。</p><h2 id="9930" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">性能</h2><ol class=""><li id="6795" class="lx ly it kk b kl lz ko ma kr mb kv mc kz md ld ng mf mg mh bi translated">每个节点有两个值；一个<strong class="kk iu">键</strong>和一个<strong class="kk iu">优先级</strong>。</li><li id="8d22" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld ng mf mg mh bi translated">这些键遵循二进制搜索树属性。</li><li id="f994" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld ng mf mg mh bi translated">优先级(随机值)遵循堆属性。</li></ol><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div class="gh gi od"><img src="../Images/99be85449499956c4b80b887be12b164.png" data-original-src="https://miro.medium.com/v2/resize:fit:676/format:webp/1*iH-zgLTHTHYe2E56aa2MWw.png"/></div><p class="mz na gj gh gi nb nc bd b be z dk translated">图8。Treap(红色字母键遵循BST属性，蓝色数值遵循最大堆顺序)</p></figure><h2 id="af2e" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">使用</h2><ol class=""><li id="ac05" class="lx ly it kk b kl lz ko ma kr mb kv mc kz md ld ng mf mg mh bi translated">用于维护公钥密码系统中的授权证书。</li><li id="8c6c" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld ng mf mg mh bi translated">可用于执行快速设置操作。</li></ol><h1 id="afad" class="nh lf it bd lg ni nj nk lj nl nm nn lm jz no ka lp kc np kd ls kf nq kg lv nr bi translated">8.B树</h1><p id="ee32" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr ns kt ku kv nt kx ky kz nu lb lc ld im bi translated">b树是一个自平衡搜索树，它包含多个节点，这些节点按照排序的顺序保存数据。每个节点有2个或更多的子节点，并由多个键组成。</p><h2 id="9032" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">性能</h2><ol class=""><li id="dafc" class="lx ly it kk b kl lz ko ma kr mb kv mc kz md ld ng mf mg mh bi translated">每个节点x都有以下内容:</li></ol><p id="855e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">— x.n(键的数量)</p><p id="fb94" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">— x.keyᵢ(以升序存储的密钥)</p><p id="6829" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">— x.leaf(无论x是否为叶子)</p><p id="5960" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">2.每个节点x都有(x.n + 1)个子节点。</p><p id="d88a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">3.键x.keyᵢ分隔每个子树中存储的键的范围。</p><p id="50e0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">4.所有的树叶都有相同的深度，也就是树高。</p><p id="20bd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">5.节点对可以存储的键的数量有上限和下限。这里我们考虑一个值t≥2，称为B树的<strong class="kk iu">最小度</strong>(或<strong class="kk iu">分支因子</strong>)。</p><p id="7a40" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">—根必须至少有一个键。</p><p id="bb40" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">—每个其他节点必须至少有(t-1)个键，最多有(2t-1)个键。因此，每个节点将至少有t个子节点，最多有2t个子节点。如果节点有(2t-1)个键，我们说它是<strong class="kk iu">满的</strong>。</p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi oe"><img src="../Images/cbff4bc9c3875f854d19a065b22e6b01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GXwr5PFqDNOOk8ae-8W5zA.png"/></div></div><p class="mz na gj gh gi nb nc bd b be z dk translated">图九。B树</p></figure><h2 id="05fa" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">使用</h2><ol class=""><li id="6240" class="lx ly it kk b kl lz ko ma kr mb kv mc kz md ld ng mf mg mh bi translated">用于数据库索引，以加快搜索速度。</li><li id="2efc" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld ng mf mg mh bi translated">在文件系统中用来实现目录。</li></ol><h1 id="a3f1" class="nh lf it bd lg ni nj nk lj nl nm nn lm jz no ka lp kc np kd ls kf nq kg lv nr bi translated">最后的想法</h1><p id="1088" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr ns kt ku kv nt kx ky kz nu lb lc ld im bi translated">数据结构操作的时间复杂性的备忘单可以在这个<a class="ae nz" href="https://www.bigocheatsheet.com/" rel="noopener ugc nofollow" target="_blank">链接</a>中找到。</p><p id="e2a7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我希望作为对树结构的简单介绍，这篇文章对您有用。我很想听听你的想法。😇</p><p id="8e88" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请继续关注关于更多数据结构的后续文章。如果你没有读过我以前写的关于数据结构的文章，可以通过下面的链接来看看。</p><div class="of og gp gr oh oi"><a rel="noopener follow" target="_blank" href="/8-common-data-structures-every-programmer-must-know-171acf6a1a42"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">每个程序员都必须知道的8种常见数据结构</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">数据结构是一种在计算机中组织和存储数据的专门方法，以这种方式我们可以执行…</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">towardsdatascience.com</p></div></div><div class="or l"><div class="os l ot ou ov or ow mx oi"/></div></div></a></div><div class="of og gp gr oh oi"><a rel="noopener follow" target="_blank" href="/self-balancing-binary-search-trees-101-fc4f51199e1d"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">自平衡二分搜索法树101</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">自平衡二分搜索法树简介</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">towardsdatascience.com</p></div></div><div class="or l"><div class="ox l ot ou ov or ow mx oi"/></div></div></a></div><p id="4b36" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">非常感谢你的阅读！</p><p id="c210" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">干杯！😃</p><h1 id="a412" class="nh lf it bd lg ni nj nk lj nl nm nn lm jz no ka lp kc np kd ls kf nq kg lv nr bi translated">参考</h1><p id="061b" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr ns kt ku kv nt kx ky kz nu lb lc ld im bi translated">[1]《算法导论》(第三版)，作者:Thomas H. Cormen、Charles E. Leiserson、Ronald L. Livest和Clifford Stein。</p><p id="c288" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae nz" href="https://en.wikipedia.org/wiki/List_of_data_structures" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/List_of_data_structures</a></p></div></div>    
</body>
</html>