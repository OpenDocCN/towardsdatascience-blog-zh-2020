<html>
<head>
<title>Build your first ML integrated ChatBot on DialogFlow!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在DialogFlow上构建您的第一个ML集成聊天机器人！</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/build-your-first-ml-integrated-chatbot-on-dialogflow-7543bf768619?source=collection_archive---------23-----------------------#2020-05-02">https://towardsdatascience.com/build-your-first-ml-integrated-chatbot-on-dialogflow-7543bf768619?source=collection_archive---------23-----------------------#2020-05-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/e7dd6b945fe13453a07f1e2a1f7354dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*W3Vh_sg94J1M5sFk"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">丹尼尔·科尔派在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><blockquote class="kg kh ki"><p id="a03e" class="kj kk kl km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">您在Google的DialogFlow上的第一个机器学习集成聊天机器人只需4个步骤！</p></blockquote></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><p id="9989" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">任何机器学习模型都是无用的，除非你把它应用到现实生活中。在Jupyter笔记本上运行模型，吹嘘99.99%的准确率，都于事无补。你需要把它做成一个端到端的应用程序，把它呈现给外界。聊天机器人是一种有趣又简单的方式。</p><p id="6ca0" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">构建聊天机器人从未如此简单。谷歌的DialogFlow是一个显而易见的选择，因为它非常简单，快速和免费！在继续之前，先自己试用一下这个应用程序<a class="ae kf" href="http://t.me/Irispredictor_bot" rel="noopener ugc nofollow" target="_blank">这里</a>！</p><h1 id="185c" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">流动</h1><p id="7111" class="pw-post-body-paragraph kj kk it km b kn mq kp kq kr mr kt ku lp ms kx ky lq mt lb lc lr mu lf lg lh im bi translated">现在您已经尝试过了，接下来要构建完整的应用程序，我们将讨论以下步骤:</p><ol class=""><li id="2cdc" class="mv mw it km b kn ko kr ks lp mx lq my lr mz lh na nb nc nd bi translated">你的机器学习模型(这里是Iris)</li><li id="4fba" class="mv mw it km b kn ne kr nf lp ng lq nh lr ni lh na nb nc nd bi translated">获取用户输入的对话流聊天机器人</li><li id="db8a" class="mv mw it km b kn ne kr nf lp ng lq nh lr ni lh na nb nc nd bi translated">部署在任何公共主机上的Flask应用程序，用于呈现请求和响应</li><li id="4138" class="mv mw it km b kn ne kr nf lp ng lq nh lr ni lh na nb nc nd bi translated">聊天机器人对flask api进行的webhook调用，用于发送数据和获取结果</li><li id="d7c5" class="mv mw it km b kn ne kr nf lp ng lq nh lr ni lh na nb nc nd bi translated">集成DialogFlow和Telegram</li></ol><p id="2735" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">我们将一个接一个地检查每个步骤。让我们先来看看我们的完整应用程序的架构会是什么样子:</p><figure class="nk nl nm nn gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nj"><img src="../Images/9ba711c2c1fa971cf506725e7e8e2d91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-bhf2gOKKILiKLN8HjyOTA.jpeg"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">建筑</p></figure><h1 id="1e7d" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">发生了什么事？</h1><p id="3022" class="pw-post-body-paragraph kj kk it km b kn mq kp kq kr mr kt ku lp ms kx ky lq mt lb lc lr mu lf lg lh im bi translated">因此，用户可以访问Telegram聊天机器人，我们将建立在DialogFlow上，稍后与Telegram集成。对话开始，聊天机器人提示用户输入数据，这些数据是花的尺寸(花瓣长度、花瓣宽度、萼片长度和萼片宽度)。一旦聊天机器人接收到最后一个输入，它将触发对flask API的webhook调用，该API将部署在公共主机上。这个flask API由我们的应用程序组成，它将检索4个数据点，并将其与我们的机器学习模型相匹配，然后将预测回复给聊天机器人。你可以在我的<a class="ae kf" href="https://github.com/chayankathuria/Iris-Dialogflow" rel="noopener ugc nofollow" target="_blank"> Github </a>找到完整的代码。</p><p id="9934" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">现在让我们来看一下每一步！</p><h1 id="8b4e" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">构建组件</h1><h2 id="7d95" class="no lt it bd lu np nq dn ly nr ns dp mc lp nt nu mg lq nv nw mk lr nx ny mo nz bi translated">ML模型</h2><p id="d826" class="pw-post-body-paragraph kj kk it km b kn mq kp kq kr mr kt ku lp ms kx ky lq mt lb lc lr mu lf lg lh im bi translated">首先，让我们建立一个基本的最大似然模型，该模型采用虹膜尺寸并预测虹膜类型。这里没有火箭科学。只是一个非常基本的模型，它能以相当高的精度呈现结果。下面是快速实现这一点的基本代码。</p><pre class="nk nl nm nn gt oa ob oc od aw oe bi"><span id="cfe1" class="no lt it ob b gy of og l oh oi">#Load data<br/>iris = load_iris() <br/>X = iris.data      <br/>y = iris.target<br/><br/>#Train test split<br/>X_train, X_test, y_train, y_test = train_test_split(X, y, random_state = 42, test_size = 0.25)<br/><br/>#Define and fit to the model<br/>clf = RandomForestClassifier(n_estimators=10)<br/>clf.fit(X_train, y_train)<br/>predicted = clf.predict(X_test)<br/>print(accuracy_score(predicted, y_test))<br/>print(clf.predict(X_test))<br/><br/>#Save the model as Pickle<br/>import pickle<br/>with open(r'rf.pkl','wb') as model_pkl:<br/>    pickle.dump(clf, model_pkl, protocol=2)</span></pre><p id="937d" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">我们只需加载数据，并使其适合随机森林分类器。不需要清理数据，因为数据集已经非常小了。我不会为了避免复杂性而在这里进行任何优化，因为我们的主要目标不是模型的准确性，而是完整的应用程序。然后只需<a class="ae kf" href="https://www.geeksforgeeks.org/understanding-python-pickling-example/" rel="noopener ugc nofollow" target="_blank"> pickle </a>这个模型，之后这个模型、<em class="kl">‘RF . pkl’、</em>就会被加载到我们的flask应用中。</p><h1 id="7c4b" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">对话流聊天机器人</h1><p id="3369" class="pw-post-body-paragraph kj kk it km b kn mq kp kq kr mr kt ku lp ms kx ky lq mt lb lc lr mu lf lg lh im bi translated">现在让我们直接进入DialogFlow来制作我们的聊天机器人。您也可以使用其他API和框架来构建聊天机器人，但Google的DialogFlow是一个显而易见的选择，因为它简单、免费且构建速度极快！前往<a class="ae kf" href="https://dialogflow.cloud.google.com/" rel="noopener ugc nofollow" target="_blank"> DialogFlow </a>，用你的谷歌账户登录。然后点击“创建代理”来创建您的聊天机器人。</p><figure class="nk nl nm nn gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oj"><img src="../Images/a228dcde7b6a105407862a5d3f9cfd53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rwG-rt2FkWGMFpQOvQ4l0g.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">创建代理</p></figure><p id="e1ae" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">接下来，我们需要创建一个向用户请求数据并进行webhook调用的意图。让我们首先编辑默认的欢迎意图，让它要求用户回答“是”或“否”。</p><figure class="nk nl nm nn gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ok"><img src="../Images/aeb28cf0b8afc8e1363f9773170cb243.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U5p9mnYfffVeiB-2tQ3-5w.png"/></div></div></figure><p id="f716" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">现在，只要用户键入“Yes”，DialogFlow就会调用另一个intent，要求用户输入并将数据点存储在“Entities”中。这里我们处理简单的随机数，所以我们不需要创建自定义实体。DialogFlow有默认的实体来处理这样的数据。因此，我们需要为这个意图创建一个“Yes-follow-Intent ”,因为该意图将在用户的肯定回复之后被调用。</p><figure class="nk nl nm nn gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ol"><img src="../Images/abfcd6a91a5a11392aaa54e5ead0b256.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iYxjg7sfsoC0RKjig0jA6w.png"/></div></div></figure><p id="d598" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">点击“添加跟进意向”&gt;“是”。如果您愿意，可以将此意图重命名为其他名称。我将把它重命名为“IrisData”。现在我们需要添加实体，这些实体将保存从用户那里收到的数据。我们将在这里为所有4个输入使用默认的<em class="kl"> @sys.number </em>实体。为用户需要的4个数据点设置4个不同的参数——花瓣长度、花瓣宽度、萼片长度、萼片宽度。确保添加提示，并要求用户单独输入。</p><figure class="nk nl nm nn gt ju gh gi paragraph-image"><div class="gh gi om"><img src="../Images/bc32f2ad1989a803cb6be4a6ed37b88f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/format:webp/1*Y7H-R4ka3XIOYxr-jwg9LQ.png"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">添加参数</p></figure><figure class="nk nl nm nn gt ju gh gi paragraph-image"><div class="gh gi on"><img src="../Images/2c58726610b795a257ef41375ae05e35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1194/format:webp/1*_q4VGTS0MtsVTn6_jKR7rw.png"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">添加提示</p></figure><p id="3e29" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">用一些输入来训练模型，以便它知道会发生什么。您现在可以在右侧面板测试聊天机器人，检查它是否相应地运行。</p><p id="743a" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">完成后，您需要通过“为此目的启用webhook调用”来启用履行。通过这样做，这个特定的意图将对我们部署在公共主机Heroku上的应用程序进行webhook调用。我们现在需要构建flask应用程序，并将其部署在Heroku上，然后将URL放在左侧的“Fulfillment”选项卡中。</p><h1 id="3a6a" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">Heroku上的Flask应用程序</h1><p id="75b2" class="pw-post-body-paragraph kj kk it km b kn mq kp kq kr mr kt ku lp ms kx ky lq mt lb lc lr mu lf lg lh im bi translated">我们现在需要构建我们的flask应用程序，它从我们的chatbot获取webhook调用，检索数据，然后适应ML模型(rf.pkl ),并将履行文本和预测一起返回给DialogFlow。下面是代码:</p><pre class="nk nl nm nn gt oa ob oc od aw oe bi"><span id="a810" class="no lt it ob b gy of og l oh oi"># Importing necessary libraries<br/>import numpy as np<br/>from flask import Flask, request, make_response<br/>import json<br/>import pickle<br/>from flask_cors import cross_origin<br/><br/># Declaring the flask app<br/>app = Flask(__name__)<br/><br/>#Loading the model from pickle file<br/>model = pickle.load(open('rf.pkl', 'rb'))<br/><br/><br/># geting and sending response to dialogflow<br/>@app.route('/webhook', methods=['POST'])<br/>@cross_origin()<br/>def webhook():<br/><br/><br/>    req = request.get_json(silent=True, force=True)<br/>    res = processRequest(req)<br/>    res = json.dumps(res, indent=4)<br/>    r = make_response(res)<br/>    r.headers['Content-Type'] = 'application/json'<br/>    return r</span></pre><p id="8ca8" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">一旦完成，我们需要处理来自DialogFlow的JSON格式的实现请求来检索数据。履行请求看起来像这样:</p><figure class="nk nl nm nn gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oo"><img src="../Images/bb22e796bd5893e304a3a7978160d918.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ixOaNDc9ht83ibZAPQfg6g.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">API请求格式</p></figure><p id="2523" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">所以我们需要进入' query result ' &gt; &gt; ' parameters ' &gt; &gt; ' number '，' number1 '，' number2 '，' number4 '。一旦检索到，我们将把这些数据点转储到一个数组中，并将其应用到我们的模型中，从而得到预测。</p><pre class="nk nl nm nn gt oa ob oc od aw oe bi"><span id="5758" class="no lt it ob b gy of og l oh oi"># processing the request from dialogflow<br/>def processRequest(req):<br/><br/><br/>    result = req.get("queryResult")<br/>    <br/>    #Fetching the data points<br/>    parameters = result.get("parameters")<br/>    Petal_length=parameters.get("number")<br/>    Petal_width = parameters.get("number1")<br/>    Sepal_length=parameters.get("number2")<br/>    Sepal_width=parameters.get("number3")<br/>    int_features = [Petal_length,Petal_width,Sepal_length,Sepal_width]<br/>    <br/>    #Dumping the data into an array<br/>    final_features = [np.array(int_features)]<br/>    <br/>    #Getting the intent which has fullfilment enabled<br/>    intent = result.get("intent").get('displayName')<br/>    <br/>    #Fitting out model with the data points<br/>    if (intent=='IrisData'):<br/>        prediction = model.predict(final_features)<br/>    <br/>        output = round(prediction[0], 2)<br/>    <br/>    	<br/>        if(output==0):<br/>            flowr = 'Setosa'<br/>    <br/>        if(output==1):<br/>            flowr = 'Versicolour'<br/>        <br/>        if(output==2):<br/>            flowr = 'Virginica'<br/>            <br/>        #Returning back the fullfilment text back to DialogFlow<br/>        fulfillmentText= "The Iris type seems to be..  {} !".format(flowr)<br/>        #log.write_log(sessionID, "Bot Says: "+fulfillmentText)<br/>        return {<br/>            "fulfillmentText": fulfillmentText<br/>        }<br/><br/><br/>if __name__ == '__main__':<br/>    app.run()</span></pre><p id="9def" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">一旦完成，我们只需要在公共主机上部署代码。我再次选择了Heroku，它简单、免费、超级快捷！你只需要添加以下文件到你的新Github库:flask应用程序，模型pickle文件，一个Procfile(这是非常重要的，帮助Heroku定位flask应用程序)，和一个需求文本文件，告诉Heroku要正确运行应用程序需要预装哪些库和版本。</p><p id="f266" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">只需在Github上创建一个存储库，然后访问Heroku。创建一个“新应用”,并在那里“连接”你的Github库。一旦连接，只需点击部署按钮，你就大功告成了！</p><figure class="nk nl nm nn gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi op"><img src="../Images/c22e7892a999dc1e423a9ab7f29fe3fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ze1PWDlCLd6w1PUwU2YPDg.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">将Github repo连接到Heroku应用程序</p></figure><h1 id="5315" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">Webhook调用</h1><p id="4a8e" class="pw-post-body-paragraph kj kk it km b kn mq kp kq kr mr kt ku lp ms kx ky lq mt lb lc lr mu lf lg lh im bi translated">现在进入最后一步。我们现在需要将部署的应用程序连接到我们的聊天机器人。只需输入部署您的应用程序的URL，并在其中添加“/webhook”即可。记住上面的flask代码，应用程序被路由到“/webhook”。只需转到DialogFlow左侧面板的“履行”选项卡，启用“网页挂钩”并添加<your_app>/网页挂钩即可。</your_app></p><figure class="nk nl nm nn gt ju gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/0bd24e6605adaab835c08c055b61d282.png" data-original-src="https://miro.medium.com/v2/resize:fit:1386/format:webp/1*iYrPtS6bKu-Tk1wFhmLn0A.png"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">在DialogFlow上启用Webhook</p></figure><p id="a798" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">我们完了。(不要忘记点击保存按钮！)您可以在右侧面板上通过发起聊天来测试webhook请求/响应是否工作正常。您应该得到带有预测的实现响应。</p><h1 id="0bc5" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">与电报集成</h1><p id="d00c" class="pw-post-body-paragraph kj kk it km b kn mq kp kq kr mr kt ku lp ms kx ky lq mt lb lc lr mu lf lg lh im bi translated">到了最后一步。这里没什么要做的，因为将web应用程序与DialogFlow集成非常容易。我们首先需要去<a class="ae kf" href="https://web.telegram.org/" rel="noopener ugc nofollow" target="_blank">电报</a>那里生成一个虚拟机器人，并生成它的令牌。搜索“机器人父亲”并点击“新机器人”。它会问你机器人的名字。根据需要输入任何名称。然后它会提示您输入用户名。</p><p id="64df" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">在你完成之后，你的机器人的一个令牌和一个链接将会在这里生成。只需复制令牌并转到左边的DialogFlow“集成”面板。在那里启用Telegram，粘贴您刚刚生成的令牌，然后单击start。就是这样！现在只需进入电报机器人链接，并尝试应用程序！</p></div></div>    
</body>
</html>