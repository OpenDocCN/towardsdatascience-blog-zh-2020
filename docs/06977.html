<html>
<head>
<title>OCT Image Segmentation using U-Nets</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于U-网的OCT图像分割</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/segmentation-of-optical-coherence-tomography-images-with-diabetic-macular-edema-the-gluon-82093cfd8e24?source=collection_archive---------39-----------------------#2020-05-29">https://towardsdatascience.com/segmentation-of-optical-coherence-tomography-images-with-diabetic-macular-edema-the-gluon-82093cfd8e24?source=collection_archive---------39-----------------------#2020-05-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="1a6d" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" rel="noopener" target="_blank" href="https://towardsdatascience.com/inside-ai/home?gi=d53b80ec612">内部AI </a></h2><div class=""/><div class=""><h2 id="fd21" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">使用基于Apache Mxnet和Gluon框架的光学相干断层扫描报告诊断糖尿病性黄斑水肿的深度学习方法</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/75631afa4017f2853b9a66e1b80d89dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*r7ZEGfln7WTZPVaS"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated"><a class="ae le" href="https://unsplash.com/@makuph?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克劳迪亚·拉米雷斯</a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><h2 id="1f13" class="lf lg iq bd lh li lj dn lk ll lm dp ln lo lp lq lr ls lt lu lv lw lx ly lz iw bi translated"><strong class="ak">糖尿病性黄斑水肿</strong></h2><p id="3ae2" class="pw-post-body-paragraph ma mb iq mc b md me ka mf mg mh kd mi lo mj mk ml ls mm mn mo lw mp mq mr ms ij bi translated">糖尿病性黄斑水肿是由称为糖尿病性视网膜病变的II型糖尿病引起的恶化。糖尿病性视网膜病变是最常见的糖尿病性眼病之一，通常会导致失明。粗略估计，770万美国人被诊断患有这种糖尿病，其中大约75万人患有糖尿病性黄斑水肿。</p><h2 id="0152" class="lf lg iq bd lh li lj dn lk ll lm dp ln lo lp lq lr ls lt lu lv lw lx ly lz iw bi translated">光学相干断层扫描(OCT)</h2><p id="ec21" class="pw-post-body-paragraph ma mb iq mc b md me ka mf mg mh kd mi lo mj mk ml ls mm mn mo lw mp mq mr ms ij bi translated">OCT是对DME的诊断测试。这项测试使用一种特殊的光源和一台相机来获得视网膜的全面内细胞层。它可以感知视网膜的厚度，并有助于确定视网膜的肿胀程度。</p><h2 id="ad4a" class="lf lg iq bd lh li lj dn lk ll lm dp ln lo lp lq lr ls lt lu lv lw lx ly lz iw bi translated">u型网</h2><p id="2e60" class="pw-post-body-paragraph ma mb iq mc b md me ka mf mg mh kd mi lo mj mk ml ls mm mn mo lw mp mq mr ms ij bi translated">在2015年5月18日，Olaf Ronneberger、Philipp Fischer和Thomas Brox发表了一篇关于用于生物医学图像分割的卷积神经网络(CNN)的论文。传统上，细胞神经网络用于图像分类和目标检测。这种方法并不适合，因为期望的输出是定位的输出，其中类标签被分配给每个像素。因为与图像分类问题或物体检测问题相比，生物医学任务没有大量的正样本。Ciresan等人试图训练一个网络，使用滑动窗口设置，通过使用感兴趣区域或像素周围的小块作为输入特征来预测每个像素的类别标签。这种方法虽然新颖，但却相当稳定，并且由于补丁重叠而导致大量冗余。此外，在小块尺寸和定位精度之间有一个折衷。斑块大小越大，背景越高，但这会导致最大池层数增加，从而减少空间信息，导致定位精度降低。如果小块尺寸减小了，那么上下文也就减小了。这导致了U型网络的产生，这是一种伪全连接网络</p><p id="5d8f" class="pw-post-body-paragraph ma mb iq mc b md mu ka mf mg mv kd mi lo mw mk ml ls mx mn mo lw my mq mr ms ij bi translated">主要建议是提供一个连续层的正常卷积网络。最大池层被上采样层取代，从而提高了像素密度，最终提高了分辨率。来自卷积路径的这些较高分辨率特征与上采样输出连接。添加连续的卷积层作为扩展路径，这导致特征通道的数量增加，以使网络能够将空间信息传递到高分辨率层。该模型不包含任何完全连接的层，并使用每个特征提取器的最重要部分(卷积)。整体结构呈U形，因此得名U形网。在较大图像的情况下，通过翻转输入图像和对输入图像执行不同的增强来产生缺失的上下文，这不会改变图像的含义，但是有助于提取每个输入图像的更多特征。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mz"><img src="../Images/c172a8f65741d63e6d3fa51a45038aa5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pYqOu9ctS98v0paIAZ0yQg.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">来源:“U-Net:生物医学图像分割的卷积网络”</p></figure><p id="a7e8" class="pw-post-body-paragraph ma mb iq mc b md mu ka mf mg mv kd mi lo mw mk ml ls mx mn mo lw my mq mr ms ij bi translated">参考上面的图像，论文的作者使用了具有ReLu激活功能的连续Conv3D层。最低分辨率为32×32像素。卷积层的每个连续块被最大化汇集并相互堆叠。为了形成U-Net的基础，为了数据一致性，创建了由3个卷积层组成的平台块，其具有相同数量的输入和输出通道。后来通过转置卷积层对它们进行了上采样。反过来，这些层与相应的深度卷积块连接在一起。连接的输出被传递到U-Net的上升分支或扩展块。在每一个深度级别，空间信息通过连接不断传递。</p><p id="a142" class="pw-post-body-paragraph ma mb iq mc b md mu ka mf mg mv kd mi lo mw mk ml ls mx mn mo lw my mq mr ms ij bi translated">你可以在<a class="ae le" href="https://arxiv.org/abs/1505.04597" rel="noopener ugc nofollow" target="_blank">https://arxiv.org/abs/1505.04597</a>查看原文，了解更多细节。</p><h2 id="70c6" class="lf lg iq bd lh li lj dn lk ll lm dp ln lo lp lq lr ls lt lu lv lw lx ly lz iw bi translated">资料组</h2><p id="48c3" class="pw-post-body-paragraph ma mb iq mc b md me ka mf mg mh kd mi lo mj mk ml ls mm mn mo lw mp mq mr ms ij bi translated">我使用了OCT图像的分割:<em class="mt">光学相干断层扫描(OCT)和糖尿病性黄斑水肿(DME)数据集</em>，该数据集由Paul Mooney在kaggle上提供。你可以在https://www.kaggle.com/paultimothymooney/chiu-2015<a class="ae le" href="https://www.kaggle.com/paultimothymooney/chiu-2015" rel="noopener ugc nofollow" target="_blank">的</a>亲自看看</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi na"><img src="../Images/dd68db3bcf0ad0604081f8d39b7584a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BAg9ILH25HkO91wESPRC-g.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">截图来自“kaggle.com”</p></figure><p id="7104" class="pw-post-body-paragraph ma mb iq mc b md mu ka mf mg mv kd mi lo mw mk ml ls mx mn mo lw my mq mr ms ij bi translated">数据集由以下文件组成</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nb"><img src="../Images/f952a03554cdac3fa326ba95e6308f0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cVQFGt_0CkO5iRhIGCOt7w.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">来自我的文件浏览器的屏幕截图</p></figure><h2 id="3e82" class="lf lg iq bd lh li lj dn lk ll lm dp ln lo lp lq lr ls lt lu lv lw lx ly lz iw bi translated">完整的源代码</h2><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nc"><img src="../Images/a4f007784e0722e709148ab37f012f0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WSQ2gIGdX2SRCFAB"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">由<a class="ae le" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马库斯·斯皮斯克</a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="edb6" class="pw-post-body-paragraph ma mb iq mc b md mu ka mf mg mv kd mi lo mw mk ml ls mx mn mo lw my mq mr ms ij bi translated">您可以在我的GitHub资源库中找到我的实现的完整源代码。</p><div class="nd ne gp gr nf ng"><a href="https://github.com/sid0312/OCTImageSegmentation" rel="noopener  ugc nofollow" target="_blank"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd ja gy z fp nl fr fs nm fu fw iz bi translated">sid 0312/oct image分段</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">从头开始建立使用Apache MxNet和胶子图像分割光学相干断层扫描图像与…</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">github.com</p></div></div><div class="np l"><div class="nq l nr ns nt np nu ky ng"/></div></div></a></div><p id="194e" class="pw-post-body-paragraph ma mb iq mc b md mu ka mf mg mv kd mi lo mw mk ml ls mx mn mo lw my mq mr ms ij bi translated"><strong class="mc ja">使用MxNet的UNet】</strong></p><p id="d91b" class="pw-post-body-paragraph ma mb iq mc b md mu ka mf mg mv kd mi lo mw mk ml ls mx mn mo lw my mq mr ms ij bi translated">我使用<strong class="mc ja"> Apache MxNet框架和Gluon API </strong>从头开始构建了一个U-Net，它类似于Tensorflow框架的Keras</p><p id="3450" class="pw-post-body-paragraph ma mb iq mc b md mu ka mf mg mv kd mi lo mw mk ml ls mx mn mo lw my mq mr ms ij bi translated">我的存储库中的model.py如下所示</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="74e8" class="pw-post-body-paragraph ma mb iq mc b md mu ka mf mg mv kd mi lo mw mk ml ls mx mn mo lw my mq mr ms ij bi translated"><strong class="mc ja">现在让我们逐行查看我们的model.py文件</strong></p><ul class=""><li id="cafa" class="nx ny iq mc b md mu mg mv lo nz ls oa lw ob ms oc od oe of bi translated"><strong class="mc ja">导入我们的依赖关系</strong></li></ul><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nv nw l"/></div></figure><ul class=""><li id="f574" class="nx ny iq mc b md mu mg mv lo nz ls oa lw ob ms oc od oe of bi translated"><strong class="mc ja">为U-Net创建类</strong></li></ul><p id="9d4f" class="pw-post-body-paragraph ma mb iq mc b md mu ka mf mg mv kd mi lo mw mk ml ls mx mn mo lw my mq mr ms ij bi translated">U-Net被实现为一个混合胶子块。</p><pre class="kp kq kr ks gt og oh oi oj aw ok bi"><span id="1477" class="lf lg iq oh b gy ol om l on oo">class network(gluon.nn.HybridBlock):</span></pre><ul class=""><li id="7240" class="nx ny iq mc b md mu mg mv lo nz ls oa lw ob ms oc od oe of bi translated"><strong class="mc ja">创建卷积零件功能</strong></li></ul><p id="1697" class="pw-post-body-paragraph ma mb iq mc b md mu ka mf mg mv kd mi lo mw mk ml ls mx mn mo lw my mq mr ms ij bi translated">这作为单个收缩块，可以在卷积路径中多次使用。它由3个Conv2D层组成，每个层的内核大小为3，ReLu激活函数和BatchNorm层用于规范化输入，最后是一个max pooling层。它是混合顺序块，因为信息需要顺序传递。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nv nw l"/></div></figure><ul class=""><li id="1ec7" class="nx ny iq mc b md mu mg mv lo nz ls oa lw ob ms oc od oe of bi translated"><strong class="mc ja">创建去卷积零件功能</strong></li></ul><p id="97ab" class="pw-post-body-paragraph ma mb iq mc b md mu ka mf mg mv kd mi lo mw mk ml ls mx mn mo lw my mq mr ms ij bi translated">这就像是U型网络的一个单独的组成部分。它也可以在U-Net架构中多次使用。它由Conv2D层组成，每个层的内核大小为3，ReLu激活函数和BatchNorm层用于规范化输入，Conv2DTranspose层用于扩展输入大小(换句话说就是增加特征图的大小)</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nv nw l"/></div></figure><ul class=""><li id="1582" class="nx ny iq mc b md mu mg mv lo nz ls oa lw ob ms oc od oe of bi translated"><strong class="mc ja">创建坪块功能</strong></li></ul><p id="cb0a" class="pw-post-body-paragraph ma mb iq mc b md mu ka mf mg mv kd mi lo mw mk ml ls mx mn mo lw my mq mr ms ij bi translated">这一层充当了U-Net的瓶颈。它是为数据一致性而创建的，具有相同数量的输入和输出通道。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nv nw l"/></div></figure><ul class=""><li id="4ca6" class="nx ny iq mc b md mu mg mv lo nz ls oa lw ob ms oc od oe of bi translated"><strong class="mc ja">创建输出层功能</strong></li></ul><p id="7fb5" class="pw-post-body-paragraph ma mb iq mc b md mu ka mf mg mv kd mi lo mw mk ml ls mx mn mo lw my mq mr ms ij bi translated">该层充当U-Net的输出分段图。它紧接在广阔的道路之后发生。请注意，这几乎类似于卷积部分函数，但它包含一个用于鲁棒特征提取的额外参数。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nv nw l"/></div></figure><ul class=""><li id="5002" class="nx ny iq mc b md mu mg mv lo nz ls oa lw ob ms oc od oe of bi translated"><strong class="mc ja">创建连接功能</strong></li></ul><p id="b8ba" class="pw-post-body-paragraph ma mb iq mc b md mu ka mf mg mv kd mi lo mw mk ml ls mx mn mo lw my mq mr ms ij bi translated">这是model.py文件中最重要的函数之一。它将从卷积路径获得的较高分辨率特征与最初来自平台块的上采样输出层连接起来。它还填充这些层以给出适当形状的合成层。我花了很长时间来编写这个函数，由于形状不一致，它有很多错误。</p><p id="166d" class="pw-post-body-paragraph ma mb iq mc b md mu ka mf mg mv kd mi lo mw mk ml ls mx mn mo lw my mq mr ms ij bi translated">然而，这个函数现在工作得非常好。我们使用了边缘填充，以便用输入数组的边缘值填充特征图。简要地看一下mxnet在http://beta.mxnet.io/r/api/mx.nd.pad.html的官方文档会对理解下面的代码有很大的帮助。也试着在http://beta.mxnet.io/r/api/mx.nd.concat.html的<a class="ae le" href="http://beta.mxnet.io/r/api/mx.nd.concat.html" rel="noopener ugc nofollow" target="_blank">查阅mxnet.nd.concat文档</a></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nv nw l"/></div></figure><ul class=""><li id="f5c6" class="nx ny iq mc b md mu mg mv lo nz ls oa lw ob ms oc od oe of bi translated">创建__init__函数来分配层</li></ul><p id="5016" class="pw-post-body-paragraph ma mb iq mc b md mu ka mf mg mv kd mi lo mw mk ml ls mx mn mo lw my mq mr ms ij bi translated">我们已经为每个层创建了函数，但是要真正创建层，我们需要在__init__方法中创建层。请注意，**kwargs对于混合顺序块参数很重要。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nv nw l"/></div></figure><ul class=""><li id="1765" class="nx ny iq mc b md mu mg mv lo nz ls oa lw ob ms oc od oe of bi translated">创建hybrid_forward方法</li></ul><p id="f132" class="pw-post-body-paragraph ma mb iq mc b md mu ka mf mg mv kd mi lo mw mk ml ls mx mn mo lw my mq mr ms ij bi translated">我们已经分配了层，但是我们需要顺序地堆叠它们，传递输入ndarray并获得输出ndarray。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nv nw l"/></div></figure><ul class=""><li id="98f5" class="nx ny iq mc b md mu mg mv lo nz ls oa lw ob ms oc od oe of bi translated">为网络类创建对象</li></ul><pre class="kp kq kr ks gt og oh oi oj aw ok bi"><span id="76d1" class="lf lg iq oh b gy ol om l on oo">net = network(input_channels=1,output_channels=2)</span></pre><p id="50c0" class="pw-post-body-paragraph ma mb iq mc b md mu ka mf mg mv kd mi lo mw mk ml ls mx mn mo lw my mq mr ms ij bi translated"><strong class="mc ja">我们已经完成了整个模型。py. </strong>是时候可视化我们的模型了</p><pre class="kp kq kr ks gt og oh oi oj aw ok bi"><span id="822f" class="lf lg iq oh b gy ol om l on oo">print(net)</span></pre><p id="5a23" class="pw-post-body-paragraph ma mb iq mc b md mu ka mf mg mv kd mi lo mw mk ml ls mx mn mo lw my mq mr ms ij bi translated">输出:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi op"><img src="../Images/96012cca8b1268b6d557d53fa55c042f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/format:webp/1*u2zfquemN_RjDJJr6JKHHQ.jpeg"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">我的谷歌实验室笔记本截图</p></figure><p id="c795" class="pw-post-body-paragraph ma mb iq mc b md mu ka mf mg mv kd mi lo mw mk ml ls mx mn mo lw my mq mr ms ij bi translated">让我们使用Xavier初始化初始化网络的权重，并在获得上下文(无论代码是在gpu还是cpu上运行)后，使用形状的样本数组(5，1，284，284)检查模型摘要</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="a57f" class="pw-post-body-paragraph ma mb iq mc b md mu ka mf mg mv kd mi lo mw mk ml ls mx mn mo lw my mq mr ms ij bi translated">输出:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/0b9a80a619f53b7fa8ea3eb0cae38777.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*017mVv_NB_5_6GH53j43BA.jpeg"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">来自我的google colab笔记本的截图</p></figure><p id="6dd1" class="pw-post-body-paragraph ma mb iq mc b md mu ka mf mg mv kd mi lo mw mk ml ls mx mn mo lw my mq mr ms ij bi translated">足够的可视化。现在让我们使用prepare_data.py来准备我们的数据</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="0e2f" class="pw-post-body-paragraph ma mb iq mc b md mu ka mf mg mv kd mi lo mw mk ml ls mx mn mo lw my mq mr ms ij bi translated">create_pipeline方法有助于创建输入管道，即使用。数据集的mat文件。</p><p id="2af6" class="pw-post-body-paragraph ma mb iq mc b md mu ka mf mg mv kd mi lo mw mk ml ls mx mn mo lw my mq mr ms ij bi translated">load_dataset方法将输入管道分为两部分，即训练和验证</p><p id="74f8" class="pw-post-body-paragraph ma mb iq mc b md mu ka mf mg mv kd mi lo mw mk ml ls mx mn mo lw my mq mr ms ij bi translated">现在我们已经有了我们的训练特征、训练标签、验证特征和验证，是时候训练我们的模型了！！</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="a0e1" class="pw-post-body-paragraph ma mb iq mc b md mu ka mf mg mv kd mi lo mw mk ml ls mx mn mo lw my mq mr ms ij bi translated">我们的批量大小为6，运行100个时期的训练。</p><p id="ad8c" class="pw-post-body-paragraph ma mb iq mc b md mu ka mf mg mv kd mi lo mw mk ml ls mx mn mo lw my mq mr ms ij bi translated">这里使用的损失函数是mxnet . gluon . loss . softmaxcrossentropyloss()。可以在<a class="ae le" href="https://mxnet.incubator.apache.org/api/python/docs/api/gluon/loss/index.html" rel="noopener ugc nofollow" target="_blank">https://mxnet . incubator . Apache . org/API/python/docs/API/gluon/loss/index . html</a>了解更多亏损情况</p><p id="9fa8" class="pw-post-body-paragraph ma mb iq mc b md mu ka mf mg mv kd mi lo mw mk ml ls mx mn mo lw my mq mr ms ij bi translated">使用的优化器是一个胶子教练对象。使用的优化算法是随机梯度下降，学习率为0.0004。你可以在<a class="ae le" href="https://mxnet.incubator.apache.org/api/python/docs/api/gluon/trainer.html" rel="noopener ugc nofollow" target="_blank">https://mxnet . incubator . Apache . org/API/python/docs/API/gluon/trainer . html</a>了解更多关于gluon训练师的信息</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi or"><img src="../Images/1990ff8c40e0f88e242c0229a0725047.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iN9KgI4mIWaxfnL4oCRLpw.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">我训练的一些日志</p></figure><p id="c1a6" class="pw-post-body-paragraph ma mb iq mc b md mu ka mf mg mv kd mi lo mw mk ml ls mx mn mo lw my mq mr ms ij bi translated">我获得了88 %的验证准确率，这是相当不错的。</p><p id="0f03" class="pw-post-body-paragraph ma mb iq mc b md mu ka mf mg mv kd mi lo mw mk ml ls mx mn mo lw my mq mr ms ij bi translated">在训练我们的模型之后，我们获得我们的模型参数，我们把它保存在一个文件中，比如说，net.params</p><p id="659f" class="pw-post-body-paragraph ma mb iq mc b md mu ka mf mg mv kd mi lo mw mk ml ls mx mn mo lw my mq mr ms ij bi translated">我们可以使用model.params文件加载我们的模型以进行进一步的预测</p><p id="5c65" class="pw-post-body-paragraph ma mb iq mc b md mu ka mf mg mv kd mi lo mw mk ml ls mx mn mo lw my mq mr ms ij bi translated">让我们使用results.py文件绘制一些结果</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="570c" class="pw-post-body-paragraph ma mb iq mc b md mu ka mf mg mv kd mi lo mw mk ml ls mx mn mo lw my mq mr ms ij bi translated">为了理解这个文件需要一些matplotlib.pyplot的知识，你可以在<a class="ae le" href="https://matplotlib.org/users/pyplot_tutorial.html" rel="noopener ugc nofollow" target="_blank">https://matplotlib.org/users/pyplot_tutorial.html</a>获得这些数据可视化的知识</p><p id="77ba" class="pw-post-body-paragraph ma mb iq mc b md mu ka mf mg mv kd mi lo mw mk ml ls mx mn mo lw my mq mr ms ij bi translated"><strong class="mc ja">结果</strong></p><p id="ce31" class="pw-post-body-paragraph ma mb iq mc b md mu ka mf mg mv kd mi lo mw mk ml ls mx mn mo lw my mq mr ms ij bi translated">以下是我在使用训练好的模型后获得的一些结果</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi os"><img src="../Images/c4f728bc541fa58fd81a3be60b248df5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ypq-KMT_IEoqA43iltSJ_w.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">在我的谷歌协作笔记本上绘制训练示例和结果</p></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ot"><img src="../Images/7c1a51e8dc2889fb0c62fd1e71e46c6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y0gdi0WvStnuAkf5rsXSPA.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">我们的验证示例的性能</p></figure><p id="aa6e" class="pw-post-body-paragraph ma mb iq mc b md mu ka mf mg mv kd mi lo mw mk ml ls mx mn mo lw my mq mr ms ij bi translated"><strong class="mc ja">结论</strong></p><p id="08af" class="pw-post-body-paragraph ma mb iq mc b md mu ka mf mg mv kd mi lo mw mk ml ls mx mn mo lw my mq mr ms ij bi translated">U-Nets给出了比滑动窗口分割模型更好的结果。他们也处理最少的数据。</p><p id="7ed7" class="pw-post-body-paragraph ma mb iq mc b md mu ka mf mg mv kd mi lo mw mk ml ls mx mn mo lw my mq mr ms ij bi translated"><strong class="mc ja">进一步改进</strong></p><p id="4afc" class="pw-post-body-paragraph ma mb iq mc b md mu ka mf mg mv kd mi lo mw mk ml ls mx mn mo lw my mq mr ms ij bi translated">请注意，我在这个数据集上使用了Conv2D操作。Conv3D在4维数据集上会工作得更好，这通常是光学相干断层扫描图像的情况，因为会保留3维空间信息。</p><p id="73b3" class="pw-post-body-paragraph ma mb iq mc b md mu ka mf mg mv kd mi lo mw mk ml ls mx mn mo lw my mq mr ms ij bi translated"><strong class="mc ja">作者注</strong></p><p id="c408" class="pw-post-body-paragraph ma mb iq mc b md mu ka mf mg mv kd mi lo mw mk ml ls mx mn mo lw my mq mr ms ij bi translated">准确性不是一个合适的参数(灵敏度和特异性才是),用来判断为医疗目的而制作的模型的稳健性，但本笔记本旨在使用Apache MXNet框架解释UNet架构，而不是目前的评估指标。请继续关注仓库，了解关于指标的进一步更新</p><p id="8168" class="pw-post-body-paragraph ma mb iq mc b md mu ka mf mg mv kd mi lo mw mk ml ls mx mn mo lw my mq mr ms ij bi translated">快乐的计算机视觉和快乐的深度学习。非常感谢你的时间。真的激励我去开发更多，写更多。</p></div></div>    
</body>
</html>