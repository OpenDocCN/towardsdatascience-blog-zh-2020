<html>
<head>
<title>Retrieving, Analyzing and Visualizing georeferenced data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">检索、分析和可视化地理参考数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/retrieve-analyze-and-visualize-georeferenced-data-aec1af28445b?source=collection_archive---------54-----------------------#2020-07-12">https://towardsdatascience.com/retrieve-analyze-and-visualize-georeferenced-data-aec1af28445b?source=collection_archive---------54-----------------------#2020-07-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="99c2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用叶地图和标准 Python 库</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0056d22daebb41950acffefd3327f5d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_GIcjsR6hKQIYnqfINGyQg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3167693" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae ky" href="https://pixabay.com/users/Tumisu-148124/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3167693" rel="noopener ugc nofollow" target="_blank">图米苏</a></p></figure><p id="8df2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在地理数据科学中，往往很难得到准确可靠的数据进行分析和展示。地理数据来自不同的来源，在不同的时间通过不同的技术收集，因此，人们总是关注用于从地理空间数据中获取信息的数据的质量和可靠性[1]。获取地理空间数据是每个地理信息系统(GIS)项目的关键步骤。据估计，获取阶段通常会消耗<strong class="lb iu">花费在 GIS 项目上的 70%到 80%的时间和金钱</strong>。</p><p id="ce4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有两种类型的地理空间数据捕获:原始数据捕获(PDC)和二次数据捕获(SDC)。PDC 指的是直接数据采集，通常与使用全球定位系统(<a class="ae ky" href="https://en.wikipedia.org/wiki/Global_Positioning_System" rel="noopener ugc nofollow" target="_blank"> GPS </a>)或<a class="ae ky" href="https://en.wikipedia.org/wiki/Total_station" rel="noopener ugc nofollow" target="_blank">全站仪</a>【2】的现场勘测相关。在这一类别中，我们包括来自卫星、无人驾驶飞机、飞机和其他类型的太空、空中或手持传感器的遥感数据。</p><p id="bd34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SDC 涉及检索地理空间数据的间接方法。有大量的在线资源允许我们为我们的地理空间项目挖掘在线资源。这些来源包括来自国际机构、政府、大学、商业网站和数据仓库的数据。这些类型的数据通常是免费的，并且格式与许多 GIS 软件兼容。在这一类别中，我们还包括可以从非数字格式检索的其他地理空间信息来源，例如纸质地图[2]。</p><p id="32c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将讨论获取地理空间数据的 SDC 方式。具体来说，我们将简要展示如何检索、分析和可视化自 1964 年以来斐济<a class="ae ky" href="https://es.wikipedia.org/wiki/Fiyi" rel="noopener ugc nofollow" target="_blank">附近地震的地理参考数据。为此，我们写了一套三本</a><a class="ae ky" href="https://jupyter.org/" rel="noopener ugc nofollow" target="_blank">木星笔记本</a>:</p><ol class=""><li id="0992" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><a class="ae ky" href="https://github.com/acoiman/mapping_earthquakes/blob/master/reading_dataset.ipynb" rel="noopener ugc nofollow" target="_blank"> reading_dataset </a>:包含读取数据集集合并查找包含单词<strong class="lb iu"> <em class="me">纬度</em> </strong>或<strong class="lb iu"> <em class="me">经度</em> </strong>的数据集链接的代码。</li><li id="7e12" class="lv lw it lb b lc mf lf mg li mh lm mi lq mj lu ma mb mc md bi translated"><a class="ae ky" href="https://github.com/acoiman/mapping_earthquakes/blob/master/db_earthquakes.ipynb" rel="noopener ugc nofollow" target="_blank">db _ seismics</a>从选择的数据集创建一个数据库，并计算一些空间统计数据。</li><li id="6882" class="lv lw it lb b lc mf lf mg li mh lm mi lq mj lu ma mb mc md bi translated"><a class="ae ky" href="https://github.com/acoiman/mapping_earthquakes/blob/master/map_earthquakes.ipynb" rel="noopener ugc nofollow" target="_blank">地图 _ 地震</a>获取数据库数据并使用<a class="ae ky" href="https://pypi.org/project/folium/" rel="noopener ugc nofollow" target="_blank">叶子</a>包创建网络地图。</li></ol><p id="919c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不会给你很多关于我们使用的代码的细节。如果你想访问整个库，点击<a class="ae ky" href="https://github.com/acoiman/mapping_earthquakes" rel="noopener ugc nofollow" target="_blank">这里</a>或者这篇文章的末尾。</p><h1 id="b39a" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">读取数据集</h1><p id="fd86" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">我们使用了来自数据集的可用数据集列表。CSV 格式的列表被导入、打开和阅读。然后，我们在每个数据集的 HTML 代码<a class="ae ky" href="https://en.wikipedia.org/wiki/Web_crawler" rel="noopener ugc nofollow" target="_blank">(网页抓取)</a>中寻找单词<code class="fe nh ni nj nk b">latitude</code>或<code class="fe nh ni nj nk b">longitude</code>。最后，从结果列表中，我们选择了一个用于创建数据库和地图的数据集。</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="5ac1" class="np ml it nk b gy nq nr l ns nt"># open the collection dataset<br/>with open('datasets.csv', newline='') as csvfile:<br/>    reader = csv.DictReader(csvfile)<br/>    # append in a list all the content of the Doc column <br/>    for row in reader:<br/>        url_list.append(row['Doc'])<br/>    for url in url_list:<br/>        ctx = ssl.create_default_context()<br/>        ctx.check_hostname = False<br/>        ctx.verify_mode = ssl.CERT_NONE<br/>        r = requests.get(url)<br/>        if r.status_code == 200:<br/>            html = urlopen(url, context=ctx).read()<br/>            soup = BeautifulSoup(html, "html.parser")<br/>            for item in soup:<br/>                # find latitude or longitude word<br/>                if soup.find_all(text=re.compile(r'\blatitude\b | \blongitude\b', flags=re.I | re.X)):<br/>                    sel_list.append(url)<br/>                else:<br/>                    continue<br/>        else:<br/>            continue<br/>    for item2 in sel_list:<br/>        if item2 not in sel_list2:<br/>            sel_list2.append(item2)<br/>    print('List of datasets containing the terms latitude or longitude: \n', sel_list2)</span></pre><p id="1137" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从 1340 个数据集中，我们获得了 20 个包含单词纬度或经度的 HTML 链接，接下来我们为接下来的步骤选择了一个数据集。</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="b230" class="np ml it nk b gy nq nr l ns nt">print('The selected dataset is: ', sel_list2[8])</span></pre><p id="a256" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所选数据集是:</p><p id="47c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://raw.githubusercontent.com/vincentarelbundock/Rdatasets/master/doc/datasets/quakes.html" rel="noopener ugc nofollow" target="_blank">https://raw . githubusercontent . com/vincentarelbundock/rdata sets/master/doc/datasets/quakes . html</a></p><h1 id="9acf" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">创建数据库和计算空间统计数据</h1><p id="a78d" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">我们使用了所选数据集的 CSV 文件。该数据集包含自 1964 年以来斐济附近发生的地震事件的位置数据、深度和震级。然后，我们创建了一个数据库，并使用这个 CSV 文件填充它。最后，我们查询数据库并计算一些统计数据。</p><p id="a129" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们创建了一个轻量级的<a class="ae ky" href="https://www.sqlite.org/index.html" rel="noopener ugc nofollow" target="_blank"> SQLite </a>数据库和一个名为<code class="fe nh ni nj nk b">quakes</code>的表，与所选数据集具有相同的列名。为此，我们使用了<a class="ae ky" href="https://www.w3schools.com/sql/sql_create_table.asp" rel="noopener ugc nofollow" target="_blank"> SQL CREATE TABLE 语句</a>。</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="895a" class="np ml it nk b gy nq nr l ns nt"><em class="me"># create database</em><br/>conn = sqlite3.connect('eartquakes.sqlite')<br/>cur = conn.cursor()</span><span id="fda4" class="np ml it nk b gy nu nr l ns nt"><em class="me"># create table</em> <br/>cur.execute('''CREATE TABLE IF NOT EXISTS quakes     (id INTEGER PRIMARY KEY, lat REAL, lon REAL, depth INTEGER,     mag REAL, stations INTEGER)''')</span></pre><p id="c62c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们用地震数据填充数据库。我们检索 URL 的数据集，并使用这些数据填充数据库。然后，我们丢下一些行代码和 SQL 语句来计算:总地震、平均震级和深度、最强和最小地震。</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="3b12" class="np ml it nk b gy nq nr l ns nt"><em class="me"># get and read data (on line)</em><br/><strong class="nk iu">with</strong> closing(requests.get(url, stream=<strong class="nk iu">True</strong>)) <strong class="nk iu">as</strong> r:<br/>    f = (line.decode('utf-8') <strong class="nk iu">for</strong> line <strong class="nk iu">in</strong> r.iter_lines())<br/>    reader = csv.reader(f, delimiter=',', quotechar='"')<br/>    next(reader)<br/>    <br/>    <em class="me"># populate the database</em><br/>    list = []<br/>    <strong class="nk iu">for</strong> row <strong class="nk iu">in</strong> reader:<br/>        list.append(row)<br/>    <strong class="nk iu">for</strong> item <strong class="nk iu">in</strong> list:<br/>        cur.execute('INSERT OR IGNORE INTO quakes (id, lat, lon, depth, mag, stations) VALUES ( ?, ?, ?, ?, ?, ?)', ( item[0],item[1],item[2],item[3],item[4],item[5], ) )<br/>    conn.commit()<br/>    <br/>    <em class="me"># total earthquakes</em><br/>    cur.execute("SELECT COUNT(*) from quakes")<br/>    <strong class="nk iu">for</strong> row <strong class="nk iu">in</strong> cur:<br/>        count = row[0]<br/>    <br/>    <em class="me"># average magnitude</em><br/>    cur.execute("SELECT AVG(mag) from quakes")<br/>    <strong class="nk iu">for</strong> row <strong class="nk iu">in</strong> cur:<br/>        magAvg = row[0]<br/>    <br/>    <em class="me"># average depth</em><br/>    cur.execute("SELECT AVG(depth) from quakes")<br/>    <strong class="nk iu">for</strong> row <strong class="nk iu">in</strong> cur:<br/>        depAvg = row[0]<br/>    <br/>    <em class="me"># strong and first minor earthquake in the dataset</em><br/>    cur.execute("SELECT MAX(mag), id, lat, lon, depth FROM quakes")<br/>    <strong class="nk iu">for</strong> row <strong class="nk iu">in</strong> cur:<br/>        mag = row[0]<br/>        id = row[1]<br/>        lat = row[2]<br/>        lon = row[3]<br/>        depth = row[4]<br/>    cur.execute("SELECT MIN(mag), id, lat, lon, depth FROM quakes")<br/>    <strong class="nk iu">for</strong> row <strong class="nk iu">in</strong> cur:<br/>        mag2 = row[0]<br/>        id2 = row[1]<br/>        lat2 = row[2]<br/>        lon2 = row[3]<br/>        depth2 = row[4]</span><span id="5b60" class="np ml it nk b gy nu nr l ns nt"><em class="me"># id and magnitude dictionary</em><br/>    cur.execute("SELECT id, mag FROM quakes")<br/>    dict = {rows[0]:rows[1] <strong class="nk iu">for</strong> rows <strong class="nk iu">in</strong> cur}<br/>    cur.close()</span></pre><p id="f074" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当打印结果时，我们得到在我们的研究区域有 1000 次地震，平均震级为 4.6，平均深度为 311.37 千米。此外，我们计算出最强地震的震级为 6.4，深度为 127 公里，而最小地震的震级为 4.0，深度为 649 公里。</p><p id="d944" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们计算了最大和最小震级之间的距离。为了做到这一点，我们使用了计算两个坐标之间最短距离的哈弗辛公式。这与<a class="ae ky" href="https://en.wikipedia.org/wiki/Euclidean_distance" rel="noopener ugc nofollow" target="_blank">欧几里德距离</a>非常相似，除了它允许我们考虑地球的球形形状【3】。</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="5fec" class="np ml it nk b gy nq nr l ns nt"><em class="me"># Haversine distance formula</em><br/><strong class="nk iu">import</strong> <strong class="nk iu">math</strong><br/>x_dist = math.radians(lon2-lon)<br/>y_dist = math.radians(lat2-lat)<br/>y1_rad = math.radians(lat)<br/>y2_rad = math.radians(lat2)<br/>a = math.sin(y_dist/2)**2 + math.sin(x_dist/2)**2 \<br/>* math.cos(y1_rad) * math.cos(y2_rad)<br/>c = 2*math.asin(math.sqrt(a))<br/>distance = c * 6371 <em class="me"># kilometers</em><br/>print()<br/>print("Distance between the strongest earthquake (ID:"+str(id) +") and weakest earthquake <strong class="nk iu">\</strong><br/>(ID:"+str(id2)+"): "+str(round(distance,2))+" km.<strong class="nk iu">\n</strong>")</span></pre><p id="e380" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的结果显示，最强地震(ID:152)和最小地震(ID:5)之间的距离为 1609.06 公里。</p><p id="13f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们根据<a class="ae ky" href="https://en.wikipedia.org/wiki/Modified_Mercalli_intensity_scale" rel="noopener ugc nofollow" target="_blank">麦卡利烈度表</a>对地震进行了震级分类。我们遍历了之前创建的包含每个事件的<em class="me"> id </em>和震级数据的字典，然后根据麦卡利等级阈值过滤这些事件，并计算发生的百分比。</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="0a2b" class="np ml it nk b gy nq nr l ns nt"><em class="me"># dictionary length</em><br/>dictLen= len(dict)</span><span id="90a0" class="np ml it nk b gy nu nr l ns nt"><em class="me"># calculate percentage mercaly intensity I</em><br/>mer_I = [item <strong class="nk iu">for</strong> item, occurrences <strong class="nk iu">in</strong> dict.items() <strong class="nk iu">if</strong> occurrences &lt; 2.0]<br/>merIPerc = round((len(mer_I)/dictLen)*100, 2)</span><span id="e138" class="np ml it nk b gy nu nr l ns nt"><em class="me"># calculate percentage mercaly intensity II</em><br/>mer_II = [item <strong class="nk iu">for</strong> item, occurrences <strong class="nk iu">in</strong> dict.items() <strong class="nk iu">if</strong> occurrences &gt;= 2.0 <strong class="nk iu">and</strong> occurrences &lt;= 2.9 ]<br/>merIIPerc = round((len(mer_II)/dictLen)*100,2)</span><span id="9f0a" class="np ml it nk b gy nu nr l ns nt"><em class="me"># calculate percentage mercaly intensity III</em><br/>mer_III = [item <strong class="nk iu">for</strong> item, occurrences <strong class="nk iu">in</strong> dict.items() <strong class="nk iu">if</strong> occurrences &gt;= 3.0 <strong class="nk iu">and</strong> occurrences &lt;= 3.9 ]<br/>merIIIPerc = round((len(mer_III)/dictLen)*100,2)</span><span id="98ef" class="np ml it nk b gy nu nr l ns nt">...</span></pre><p id="b2a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据我们的结果，研究区内 80%的<strong class="lb iu"><em class="me"/></strong>地震属于麦卡利烈度表<strong class="lb iu"> <em class="me"> IV-V </em> </strong>。这些类型的事件被分类为轻度到中度地震。许多人在室内都能感觉到。轻)，几乎每个人都感觉到了(中等)[4]。</p><h1 id="00d2" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">绘制地震事件图</h1><p id="69a3" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">在我们系列笔记本的最后一部分，我们使用了在第 2 部分中创建的数据库，其中包含自 1964 年以来在斐济附近发生的地震事件的位置数据(经度和纬度)、深度和震级。从那个数据库中，我们通过<a class="ae ky" href="https://python-visualization.github.io/folium/" rel="noopener ugc nofollow" target="_blank">叶子</a>地图库提取了一些构建地震事件网络地图所需的数据。该 web 地图包含一个基础图层、地震事件位置和两个热图:地震的震级和深度。</p><p id="7514" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们阅读了我们的数据库并提取了以下数据:地震事件的纬度、经度、震级和深度。这些数据存储在列表对象中。为此，我们使用了嵌入在 Python 代码中的 SQL 语句。Python 有自己的内置模块来连接 Python 程序和数据库。</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="27ae" class="np ml it nk b gy nq nr l ns nt"><em class="me"># read dataset</em><br/>conn = sqlite3.connect('eartquakes.sqlite')<br/>cur = conn.cursor()</span><span id="cf66" class="np ml it nk b gy nu nr l ns nt"><em class="me"># create a list of latitude, longitude, mag and depth</em><br/>lats=[]<br/>lons =[]<br/>mags =[]<br/>depths =[]<br/>cur.execute("SELECT lat, lon, mag, depth FROM quakes")<br/><strong class="nk iu">for</strong> row <strong class="nk iu">in</strong> cur:<br/>    lat = row[0]<br/>    lon = row[1]<br/>    mag = row[2]<br/>    depth = row[3]<br/>    lats.append(lat)<br/>    lons.append(lon)<br/>    mags.append(mag)<br/>    depths.append(depth)<br/>cur.close()</span><span id="c88f" class="np ml it nk b gy nu nr l ns nt"><em class="me"># get a list of latitude and longitude values</em><br/>locations = list(zip(lats, lons))</span><span id="e756" class="np ml it nk b gy nu nr l ns nt"><em class="me"># get a list of  magnitude and depth values</em><br/>magdepth = list(zip(mags, depths))</span></pre><p id="c4ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用了<a class="ae ky" href="https://python-visualization.github.io/folium/" rel="noopener ugc nofollow" target="_blank">的</a>地图库来建立我们的地震事件网络地图。首先，我们配置了一个<a class="ae ky" href="https://www.webopedia.com/TERM/P/pop_up_window.html" rel="noopener ugc nofollow" target="_blank">弹出窗口</a>来显示每个地震的震级和深度。接下来，我们建立了<a class="ae ky" href="https://carto.com/blog/getting-to-know-positron-and-dark-matter/" rel="noopener ugc nofollow" target="_blank"> Cartodb 正电子</a>作为<a class="ae ky" href="http://maps.macog.com/MACOG/Help/Content/Client_APIs/SV_User/SVU_AboutBaseMaps.htm" rel="noopener ugc nofollow" target="_blank">底图</a>。我们利用标记聚类技术来制作地震事件的动画点聚类可视化。最后，我们创建了地震震级和地震深度的热图。更多关于热图技术<a class="ae ky" href="https://en.wikipedia.org/wiki/Heat_map" rel="noopener ugc nofollow" target="_blank">的信息请点击</a>。</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="d3c8" class="np ml it nk b gy nq nr l ns nt"><em class="me"># configure map popup</em><br/>popups = ['magnitude:<strong class="nk iu">{}</strong>&lt;br&gt;depth:<strong class="nk iu">{}</strong>'.format(mags, depths) <strong class="nk iu">for</strong> (mags, depths) <strong class="nk iu">in</strong> magdepth]</span><span id="575c" class="np ml it nk b gy nu nr l ns nt"><em class="me"># create basemap</em><br/>map = folium.Map(<br/>    location=[np.mean(lats), np.mean(lons)],<br/>    tiles='Cartodb Positron',<br/>    zoom_start=5<br/>)</span><span id="00e4" class="np ml it nk b gy nu nr l ns nt"><em class="me"># create marker clusters</em><br/>marker_cluster = MarkerCluster(<br/>    locations=locations,<br/>    popups=popups,<br/>    name='Earthquake Locations',<br/>    overlay=<strong class="nk iu">True</strong>,<br/>    control=<strong class="nk iu">True</strong>,</span><span id="f779" class="np ml it nk b gy nu nr l ns nt">)<br/>marker_cluster.add_to(map)</span><span id="186b" class="np ml it nk b gy nu nr l ns nt"><em class="me"># create heatmap of earthquake magnitude</em><br/>data_heat_mag = list(zip(lats, lons, mags))<br/>mag_hm = plugins.HeatMap(data_heat_mag,<br/>                         name='Heatmap of Earthquake Magnitudes',<br/>                         overlay=<strong class="nk iu">True</strong>,<br/>                         control=<strong class="nk iu">True</strong>,<br/>                         show=<strong class="nk iu">False</strong><br/>                        )<br/>mag_hm.add_to(map)</span><span id="7e9c" class="np ml it nk b gy nu nr l ns nt"><em class="me"># create heatmap of earthquake depth</em><br/>data_heat_depth = list(zip(lats, lons,depths))<br/>dep_hm = plugins.HeatMap(data_heat_depth,<br/>                         name='Heatmap of Earthquake Depths',<br/>                         overlay=<strong class="nk iu">True</strong>,<br/>                         control=<strong class="nk iu">True</strong>,<br/>                         show=<strong class="nk iu">False</strong><br/>                        )<br/>dep_hm.add_to(map)</span><span id="2500" class="np ml it nk b gy nu nr l ns nt"><em class="me"># add map control layer</em><br/>folium.LayerControl(collapsed=<strong class="nk iu">False</strong>).add_to(map)</span></pre><p id="94c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们的最终地图</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/af93a04784d81e055bb8d3fe02f2b816.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e3rlV-HOHp7G-mDnxrIQpg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">点击<a class="ae ky" href="https://acoiman.github.io/maps/earthquake_fiji/map/" rel="noopener ugc nofollow" target="_blank">此处</a>获取网络版(<em class="nw">图片作者)</em></p></figure><h1 id="4fc3" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">结论</h1><p id="8ddf" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">尽管使用像<a class="ae ky" href="https://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank"> pandas </a>和<a class="ae ky" href="https://geopandas.org/" rel="noopener ugc nofollow" target="_blank"> geopandas </a>这样的专业库也有可能达到我们在这里提出的相同目标，但是我们演示了(可能更详细)，通过 Folium 和标准 Python 库检索、分析和可视化地理参考数据是可能的。一如既往，欢迎任何与此相关的反馈！</p></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><h1 id="3b6d" class="mk ml it bd mm mn oe mp mq mr of mt mu jz og ka mw kc oh kd my kf oi kg na nb bi translated">参考</h1><p id="3b33" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">[1] Gervais，m .，Bédard，y .，Andree Levesque，m .，Bernier，e .，Devillers，R. (2009 年)。数据质量问题和地理知识发现。在米勒，h，韩，j。)地理数据挖掘和知识发现(第 99–115 页)，美国纽约:泰勒&amp;弗朗西斯集团。</p><p id="cb24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[2]<a class="ae ky" href="https://2012books.lardbucket.org/books/geographic-information-system-basics/s09-01-geographic-data-acquisition.html." rel="noopener ugc nofollow" target="_blank">https://2012 books . lardbucket . org/books/Geographic-information-system-basics/s09-01-Geographic-Data-Acquisition . html</a>地理数据采集。</p><p id="31da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[3]https://en.wikipedia.org/wiki/Haversine_formula<a class="ae ky" href="https://en.wikipedia.org/wiki/Haversine_formula" rel="noopener ugc nofollow" target="_blank"/>。哈弗辛公式。</p><p id="2b23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[4]<a class="ae ky" href="https://en.wikipedia.org/wiki/Modified_Mercalli_intensity_scale" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Modified _ Mercalli _ intensity _ scale</a>。改良麦卡利烈度表。</p></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><div class="kj kk kl km gt oj"><a href="https://github.com/acoiman/mapping_earthquakes" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd iu gy z fp oo fr fs op fu fw is bi translated">acoi man/制图 _ 地震</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">检索、分析和可视化 1964 年以来斐济附近地震的地理参考数据</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">github.com</p></div></div><div class="os l"><div class="ot l ou ov ow os ox ks oj"/></div></div></a></div></div></div>    
</body>
</html>