<html>
<head>
<title>CNN vs. Prophet: Forecasting the Copper Producer Price Index</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">CNN vs. Prophet:预测铜生产者价格指数</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/cnn-vs-prophet-forecasting-the-copper-producer-price-index-af4da63bd93d?source=collection_archive---------44-----------------------#2020-09-15">https://towardsdatascience.com/cnn-vs-prophet-forecasting-the-copper-producer-price-index-af4da63bd93d?source=collection_archive---------44-----------------------#2020-09-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="507c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">哪个模型在预测铜价方面做得更好？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/77e2540e6febb062f2c4baf6f98409c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9dpqj2HWtWlVB8yqouUXdQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:图片由<a class="ae ky" href="https://pixabay.com/users/3844328-3844328/" rel="noopener ugc nofollow" target="_blank"> 3844328 </a>发自<a class="ae ky" href="https://pixabay.com/photos/stock-trading-monitor-business-1863880/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="021f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">免责声明:本文是在“原样”的基础上编写的，没有担保。它旨在提供数据科学概念的概述，不应被解释为投资建议或任何其他类型的专业建议。</em></p><p id="7265" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在之前关于数据科学的文章中，我试图使用 Prophet 模型来预测铜生产者价格指数。数据来源于<a class="ae ky" href="https://fred.stlouisfed.org/series/WPUSI019011" rel="noopener ugc nofollow" target="_blank">弗雷德经济数据</a>使用 Quandl。</p><p id="5d20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是数据图(请注意，在本练习中，所有价格均以对数表示):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/fc887c5ff4f0cfde6364c681a3a2f128.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/format:webp/1*OvZ4ZoELt6GGRx8MvMZIlw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">资料来源:弗雷德经济数据</p></figure><p id="0db0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所讨论的时间序列从 1985 年 9 月到 2020 年 7 月，平均绝对误差为 0.257(相比之下，整个测试集的平均值为 5.917)。</p><p id="7c2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是预测值与实际值的对比图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/46aa86dda1b9f4d4762289dedef126a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/format:webp/1*vh_ldJpf7fQeiTIghGwYEA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:Jupyter 笔记本输出</p></figure><p id="b3e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然 Prophet 模型在检测季节性和趋势成分方面很有效，并且还提供了通过适当修改变化点来改进预测的能力，但在捕捉一个时间段到下一个时间段的波动性时，这种模型不一定做得特别好。</p><p id="3a8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这方面，我决定使用卷积神经网络(以下简称为 CNN)模型对这些数据进行建模，以研究该模型是否能更有效地预测这一时间序列。</p><p id="c63d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为一个警告，下面的例子更多的是一个学术练习，而不是预测资产价格的真实尝试。鉴于我们正在处理月度数据，神经网络更容易捕捉到不同时间段的波动。</p><p id="2fbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在现实生活场景中，时间序列是在更短的时间间隔(小时、分钟甚至秒)内预测的，数据集中存在更多的随机性(或随机性)。这可能会显著影响预测的准确性。此外，多变量时间序列可能证明在更普遍地预测经济时间序列方面更有效——假设这种时间序列受到许多干预。</p><p id="d9a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，使用 CNN 来模拟月度数据将被用作这一目的的起点。</p><p id="f19b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，下面的示例使用了来自 Udacity 的深度学习课程 TensorFlow 简介<a class="ae ky" href="https://www.udacity.com/course/intro-to-tensorflow-for-deep-learning--ud187" rel="noopener ugc nofollow" target="_blank">中的模型模板——这一特定主题可在 Aurélien Géron 的第 8 课:时间序列预测中找到。</a></p><p id="0c3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，原 Jupyter 笔记本(版权 2018，TensorFlow 作者)也可以在<a class="ae ky" href="https://colab.research.google.com/github/tensorflow/examples/blob/master/courses/udacity_intro_to_tensorflow_for_deep_learning/l08c09_forecasting_with_cnn.ipynb#scrollTo=PgYwn9VM8OJi" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h1 id="8612" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">CNN 模型的背景</h1><p id="f59d" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">我之前在我的上一篇文章中详细阐述了 CNN 模型的构建模块，标题是<a class="ae ky" rel="noopener" target="_blank" href="/cnn-lstm-predicting-daily-hotel-cancellations-e1c75697f124">“CNN-LSTM:预测每天的酒店取消量”</a>。因此，我在此不再赘述，但可以说，CNN 通过使用先前的时间步长(基于特定的窗口大小)来产生数据点输出，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mv"><img src="../Images/df1779d6e7c2c4dfd0fe0f0cf1912693.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*txcanSbbYXnpp0rHN9cW3w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:图片由作者创作。采用自 Udacity 的模板—深度学习 TensorFlow 简介:时间序列预测</p></figure><p id="387f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">CNN 具有通过<strong class="lb iu"> WaveNet </strong>架构学习时间序列中短期和长期相关性的内在能力，其中几个 Conv1D(一维卷积)层堆叠在一起。这允许较低层学习短期依赖性，而较高层学习长期依赖性。在我们试图预测的时间序列的背景下，这个模型似乎适合这个目的。</p><h1 id="7592" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">模型配置</h1><p id="4b3c" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">对数据执行 80/20 分割，时间序列中的前 334 个数据点用于训练 CNN 模型，其余的点用于验证目的。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="71cf" class="nb lz it mx b gy nc nd l ne nf">split_time = 334<br/>time_train = time[:split_time]<br/>x_train = series[:split_time]<br/>time_valid = time[split_time:]<br/>x_valid = series[split_time:]</span></pre><p id="b7d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">选择窗口大小为 64，批量大小为 128，训练超过 500 个时期。使用<a class="ae ky" href="https://www.analyticsvidhya.com/blog/2019/08/detailed-guide-7-loss-functions-machine-learning-python-code/" rel="noopener ugc nofollow" target="_blank"> Huber 损失</a>作为损失函数，以确保模型精度读数不受异常值的影响。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="7912" class="nb lz it mx b gy nc nd l ne nf">keras.backend.clear_session()<br/>tf.random.set_seed(42)<br/>np.random.seed(42)</span><span id="8fca" class="nb lz it mx b gy ng nd l ne nf">window_size = 64<br/>train_set = seq2seq_window_dataset(x_train, window_size,<br/>                                   batch_size=128)<br/>valid_set = seq2seq_window_dataset(x_valid, window_size,<br/>                                   batch_size=128)</span><span id="fe1c" class="nb lz it mx b gy ng nd l ne nf">model = keras.models.Sequential()<br/>model.add(keras.layers.InputLayer(input_shape=[None, 1]))<br/>for dilation_rate in (1, 2, 4, 8, 16, 32):<br/>    model.add(<br/>      keras.layers.Conv1D(filters=32,<br/>                          kernel_size=2,<br/>                          strides=1,<br/>                          dilation_rate=dilation_rate,<br/>                          padding="causal",<br/>                          activation="relu")<br/>    )<br/>model.add(keras.layers.Conv1D(filters=1, kernel_size=1))<br/>optimizer = keras.optimizers.Adam(lr=3e-4)<br/>model.compile(loss=keras.losses.Huber(),<br/>              optimizer=optimizer,<br/>              metrics=["mae"])</span><span id="fa59" class="nb lz it mx b gy ng nd l ne nf">model_checkpoint = keras.callbacks.ModelCheckpoint(<br/>    "my_checkpoint.h6", save_best_only=True)<br/>early_stopping = keras.callbacks.EarlyStopping(patience=50)<br/>history = model.fit(train_set, epochs=500,<br/>                    validation_data=valid_set,<br/>                    callbacks=[early_stopping, model_checkpoint])</span></pre><p id="8452" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，在上述示例中，训练模型时使用了双倍膨胀率。如上所述，这样做的原因是为了让网络学习时间序列中的短期和长期模式。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="a179" class="nb lz it mx b gy nc nd l ne nf">cnn_forecast = model_forecast(model, series[..., np.newaxis], window_size)<br/>cnn_forecast = cnn_forecast[split_time - window_size:-1, -1, 0]<br/>plt.figure(figsize=(10, 6))<br/>plot_series(time_valid, x_valid)<br/>plot_series(time_valid, cnn_forecast)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/471845cce448aa64936a867d91f3c86f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/format:webp/1*hLmSOwz6V0SbPJn89t5xVQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:Jupyter 笔记本输出</p></figure><p id="ef9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">平均绝对误差计算如下:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="043b" class="nb lz it mx b gy nc nd l ne nf">&gt;&gt;&gt; keras.metrics.mean_absolute_error(x_valid, cnn_forecast).numpy()<br/>0.027838342</span></pre><h1 id="9b7d" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">先知</h1><p id="f4a5" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">脸书的<a class="ae ky" href="https://facebook.github.io/prophet/docs/trend_changepoints.html" rel="noopener ugc nofollow" target="_blank"> Prophet 时间序列模型</a>的一个有用特性是能够识别<strong class="lb iu">变点</strong>，或者时间序列中重大结构变化的时期。准确识别这些点反过来可以改进时间序列预测。</p><p id="94d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上所述，先知模型的 MAE 值为<strong class="lb iu"> 0.257 </strong>，与 CNN 得出的结果相比，这个值要高得多。</p><p id="8e53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 12 </strong>在 Prophet 模型中定义了变化点(或趋势的显著偏差)。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="5993" class="nb lz it mx b gy nc nd l ne nf">pro_change= Prophet(n_changepoints=12)<br/>forecast = pro_change.fit(train_dataset).predict(future)<br/>fig= pro_change.plot(forecast);<br/>a = add_changepoints_to_plot(fig.gca(), pro_change, forecast)future_data = pro_change.make_future_dataframe(periods=43, freq = 'm')<br/> <br/>#forecast the data for future data<br/>forecast_data = pro_change.predict(future_data)<br/>pro_change.plot(forecast_data);</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/f58494218f2e7f836a7a02a510a16ad6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CBwKbqcSJt0LZAhQd9iodQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:Jupyter 笔记本输出</p></figure><p id="03b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，让我们再次看看预测值与实际值的对比图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/46aa86dda1b9f4d4762289dedef126a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/format:webp/1*vh_ldJpf7fQeiTIghGwYEA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:Jupyter 笔记本输出</p></figure><p id="1e17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显然，CNN 在预测铜价的月度波动方面表现得更好——尽管 Prophet 模型的 MAE 相对于平均值仍然较低——我们看到实际时间序列中的波动性明显更大，而预测的时间序列没有显示出来。</p><h1 id="fd87" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">结论</h1><p id="74eb" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">如前所述，预测这样的时间序列确实存在固有的局限性，因为不知道 CNN 是否会在更短的时间内表现得更好，具有更大的随机性。此外，这种时间序列受到各种干预的影响，而这些干预是过去的值所不能解释的。</p><p id="172c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，在这种情况下，CNN 在捕捉铜价的月度波动方面做得相当好。</p><p id="8a6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们介绍了:</p><ul class=""><li id="4ca6" class="nj nk it lb b lc ld lf lg li nl lm nm lq nn lu no np nq nr bi translated">如何配置 CNN 来预测时间序列</li><li id="26a5" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">CNN 和 Prophet 模型之间的差异</li><li id="e9e2" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">这种模型在预测经济时间序列中的局限性</li></ul><p id="aae9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">非常感谢您的宝贵时间，非常感谢您的任何问题或反馈。</p><p id="97da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">免责声明:本文是在“原样”的基础上编写的，没有任何担保。它旨在提供数据科学概念的概述，不应被解释为投资建议或任何其他类型的专业建议。</em></p></div></div>    
</body>
</html>