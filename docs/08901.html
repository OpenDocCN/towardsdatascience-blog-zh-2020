<html>
<head>
<title>Comparing Grakn to Semantic Web Technologies — Part 2/3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">比较 Grakn 和语义 Web 技术—第 2/3 部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/comparing-grakn-to-semantic-web-technologies-part-2-3-4602b56969fc?source=collection_archive---------42-----------------------#2020-06-26">https://towardsdatascience.com/comparing-grakn-to-semantic-web-technologies-part-2-3-4602b56969fc?source=collection_archive---------42-----------------------#2020-06-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ce3b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">探索共同的概念和差异</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5720cfbb040f15e5ce406412d22a016f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fyI_GvKDzixTFb2_UESkQw.png"/></div></div></figure><p id="c83d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是比较语义网技术和 Grakn 的第二部分。在 <a class="ae lr" href="https://medium.com/@tasabat/comparing-grakn-to-semantic-web-technologies-part-1-3-3558c447214a" rel="noopener"> <em class="lq">第一部分中，</em> </a> <em class="lq">我们看了 RDF 与 Grakn 的比较。在这一部分中，我们将特别关注 SPARQL 和 RDFS。如果你还没看完第 1 部分，跟着</em> <a class="ae lr" href="https://medium.com/@tasabat/comparing-grakn-to-semantic-web-technologies-part-1-3-3558c447214a" rel="noopener"> <em class="lq">这个链接</em> </a> <em class="lq">。</em></p><p id="78eb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lq">要了解更多信息，请务必通过</em> <a class="ae lr" href="https://discuss.grakn.ai/t/were-taking-our-summer-tour-online/1947/2" rel="noopener ugc nofollow" target="_blank"> <em class="lq">此链接</em> </a> <em class="lq">参加我们即将举办的网络研讨会。</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ls lt l"/></div></figure><h1 id="2a8a" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">SPARQL</h1><h2 id="4f55" class="mm lv it bd lw mn mo dn ma mp mq dp me ld mr ms mg lh mt mu mi ll mv mw mk mx bi translated">什么是 SPARQL</h2><p id="4fdb" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">SPARQL 是一种 W3C 标准化语言，用于从数据库中查询可以映射到 RDF 的信息。与 SQL 类似，SPARQL 允许插入和查询数据。与 SQL 不同，查询不仅限于一个数据库，还可以跨多个 HTTP 端点进行联合。</p><p id="ac57" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">作为 Grakn 的查询语言，Graql 是等价的查询语言。和 SPARQL 一样，Graql 允许插入和查询数据。然而，鉴于 Graql 不是作为开放的 Web 语言构建的，它不允许跨多个端点进行本地查询(这可以通过 Grakn 的一个客户端驱动程序来实现)。因此，Graql 更类似于 SQL 和其他传统的数据库管理系统。</p><h2 id="bc0e" class="mm lv it bd lw mn mo dn ma mp mq dp me ld mr ms mg lh mt mu mi ll mv mw mk mx bi translated">使用 SPARQL 插入数据</h2><p id="afc1" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">为了将数据添加到默认的图形存储中，这个代码片段描述了如何使用 SPARQL 插入两个 RDF 三元组:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="b694" class="mm lv it ne b gy ni nj l nk nl">PREFIX dc: &lt;http://purl.org/dc/elements/1.1/&gt;<br/>INSERT DATA<br/>{ <br/>  &lt;http://example/book1&gt; dc:title "A new book" ;<br/>                         dc:creator "A.N.Other" .<br/>}</span></pre><p id="e3c3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在 Graql 中，我们以<code class="fe nm nn no ne b">insert</code>语句开始，声明要插入数据。变量<code class="fe nm nn no ne b">$b</code>被分配给实体类型<code class="fe nm nn no ne b">book</code>，它有一个值为“一本新书”的<code class="fe nm nn no ne b">title</code>和一个值为“A.N.Other”的<code class="fe nm nn no ne b">creator</code>。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="b1a0" class="mm lv it ne b gy ni nj l nk nl">insert<br/>$b isa book, has title "A new book", has creator "A.N.Other";</span></pre><h2 id="e5a3" class="mm lv it bd lw mn mo dn ma mp mq dp me ld mr ms mg lh mt mu mi ll mv mw mk mx bi translated">使用 SPARQL 查询</h2><p id="a844" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">在 SPARQL 中，我们首先声明我们想要从中检索数据的端点，我们可以将这些端点附加到某个前缀上。在陈述我们想要返回的数据之前，实际的查询从<code class="fe nm nn no ne b">SELECT</code>开始。然后，在<code class="fe nm nn no ne b">WHERE</code>子句中，我们说明了 SPARQL 将找到匹配数据的图形模式。在这个查询中，我们使用名称空间<code class="fe nm nn no ne b">foaf</code>和<code class="fe nm nn no ne b">vCard</code>查找“Adam Smith”认识的所有人:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="d9c3" class="mm lv it ne b gy ni nj l nk nl">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;<br/>PREFIX vCard: &lt;http://www.w3.org/2001/vcard-rdf/3.0#&gt;</span><span id="54af" class="mm lv it ne b gy np nj l nk nl">SELECT ?whom<br/>WHERE {<br/>	 ?person rdf:type  foaf:Person .<br/>	 ?person vcard:family-name "Smith" .<br/>    	 ?person vcard:given-name  "Adam" .<br/>	 ?person foaf:knows ?whom .<br/> }</span></pre><p id="1a59" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在 Graql 中，我们以<code class="fe nm nn no ne b">match</code>语句开始，声明我们想要检索数据。我们匹配类型为<code class="fe nm nn no ne b">person</code>的实体，它有一个<code class="fe nm nn no ne b">family-name</code>“史密斯”和一个<code class="fe nm nn no ne b">given-name</code>“亚当”。然后，我们通过一个<code class="fe nm nn no ne b">knows</code>关系类型将它连接到<code class="fe nm nn no ne b">$p2</code>。因为我们想知道“亚当·斯密”认识谁，所以我们希望返回到<code class="fe nm nn no ne b">$p2</code>，这在<code class="fe nm nn no ne b">get</code>语句中声明:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="55f7" class="mm lv it ne b gy ni nj l nk nl">match $p isa person, has family-name "Smith", has given-name "Adam"; <br/>($p, $p2) isa knows; <br/>get $p2;</span></pre><p id="7c39" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们来看一个不同的查询:<em class="lq">给我詹姆斯·迪恩演过的导演和电影，其中也有一个女人演过角色，并且那个女人在约翰·福特导演的电影中演过角色。下面是 SPARQL 代码和这个遍历类型查询的可视化表示。</em></p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="b14a" class="mm lv it ne b gy ni nj l nk nl">PREFIX  movie: &lt;http://example.com/moviedb/0.1/&gt;<br/>PREFIX  rdf:  &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;<br/>PREFIX  foaf: &lt;http://xmlns.com/foaf/0.1/&gt;<br/> <br/>SELECT  ?director ?movie<br/>WHERE{	<br/>?actor    	 rdf:type             foaf:Man ;<br/>          	 movie:name          "James Dean" ;<br/>          	 movie:playedIn       ?movie .<br/>?actress  	 movie:playedIn       ?movie ;<br/>          	 rdf:type             foaf:Woman ;<br/>          	 movie:playedIn       ?anotherMovie .<br/>?JohnFord 	 rdf:type             foaf:Man ;<br/>          	 movie:name           "John Ford" .<br/>?anotherMovie	 movie:directedBy  ?JohnFord .<br/>}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/d1d1a9af0100f48e624f6953676fa567.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qukfeXppBYOu5zY2.png"/></div></div><p class="nr ns gj gh gi nt nu bd b be z dk translated"><em class="nv">Sparql 遍历查询的可视化表示。</em></p></figure><p id="598f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在 Grakn，我们可以这样问同样的问题:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="1a2a" class="mm lv it ne b gy ni nj l nk nl">match <br/>$p isa man, has name "James Dean"; <br/>$w isa woman; <br/>(actor: $p, actress: $w, casted-movie: $m) isa casting; <br/>(actress: $w, casted-movie: $m2) isa casting; <br/>$d isa man, has name "John Ford"; <br/>($m2, $d) isa directorship; get $d, $m;</span></pre><p id="5de6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里，我们将具有属性<code class="fe nm nn no ne b">name</code>和值“James Dean”的实体类型<code class="fe nm nn no ne b">man</code>分配给变量<code class="fe nm nn no ne b">$p</code>。然后我们说<code class="fe nm nn no ne b">$w</code>是实体类型<code class="fe nm nn no ne b">woman</code>。这两个与<code class="fe nm nn no ne b">movie</code>以称为<code class="fe nm nn no ne b">casting</code>的三向关系连接。<code class="fe nm nn no ne b">woman</code>也在另一个<code class="fe nm nn no ne b">casting</code>关系中起作用，其中<code class="fe nm nn no ne b">movie</code>实体通过<code class="fe nm nn no ne b">directorship</code>关系连接到与此<code class="fe nm nn no ne b">movie</code>相关的“John Ford”。</p><p id="1014" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的例子中，Grakn 中的超级关系<code class="fe nm nn no ne b">casting</code>表示 SPARQL 中的两个<code class="fe nm nn no ne b">playedIn</code>属性。然而，在 SPARQL 中我们只能有两条边将<code class="fe nm nn no ne b">woman</code>和“詹姆斯·迪恩”与<code class="fe nm nn no ne b">movie</code>连接起来，而不能在它们之间。这显示了 Grakn 中的建模与 RDF 中的建模有多么根本的不同，因为 RDF 具有超图建模的能力。Grakn 允许在一个关系中自然地表示 N 个角色扮演者，而不必具体化模型。</p><p id="729c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">示意性地，这是上面查询的可视化表示方式(注意三元关系<code class="fe nm nn no ne b">casting</code>):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/c1c9b56584521dca335acdfbab72f36b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*q2LkQnQ8p4THNGDF.png"/></div></div><p class="nr ns gj gh gi nt nu bd b be z dk translated"><em class="nv">Grakn 中查询的可视化表示。</em></p></figure><h2 id="d439" class="mm lv it bd lw mn mo dn ma mp mq dp me ld mr ms mg lh mt mu mi ll mv mw mk mx bi translated">否认</h2><p id="354c" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">在 SPARQL 中，我们还可以使用关键字<code class="fe nm nn no ne b">NOT EXISTS</code>在查询中指定某些数据不存在。这将找到一个只有在子图不匹配时才匹配的图模式。在下面的例子中，我们寻找曾出演电影《巨人》但尚未去世的演员:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="6a55" class="mm lv it ne b gy ni nj l nk nl">PREFIX movie: &lt;http://example.com/moviedb/0.1/&gt;</span><span id="6efd" class="mm lv it ne b gy np nj l nk nl">SELECT ?actor<br/>WHERE {<br/>	  ?actor movie:playedIn movie:Giant .<br/>	  NOT EXISTS {?actor movie:diedOn ?deathdate .<br/>}</span></pre><p id="44ee" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用封闭世界假设，Grakn 支持否定。这是通过使用关键字<code class="fe nm nn no ne b">not</code>后跟要求反的模式来完成的。上面的例子表示如下:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="0699" class="mm lv it ne b gy ni nj l nk nl">match <br/>$m isa movie, has name "Giant"; ($a, $m) isa played-in; <br/>not {$a has death-date $dd;}; get $a;</span></pre><p id="b0ca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这里，我们寻找一个名为“Giant”的实体类型<code class="fe nm nn no ne b">movie</code>，它通过类型<code class="fe nm nn no ne b">played-in</code>的关系连接到<code class="fe nm nn no ne b">$a</code>和<code class="fe nm nn no ne b">actor</code>。在<code class="fe nm nn no ne b">not</code>子查询中，我们指定<code class="fe nm nn no ne b">$a</code>不能有带有任何值的<code class="fe nm nn no ne b">death-date</code>类型的属性。我们接着<code class="fe nm nn no ne b">get</code>演员<code class="fe nm nn no ne b">$a</code>。</p><h1 id="bf6a" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">RDF 模式</h1><p id="a1e1" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">由于 RDF 只是一种数据交换模型，它本身是“无模式的”。这就是为什么引入 RDF Schema (RDFS)来用基本的本体论语义扩展 RDF。例如，这些允许 RDF 数据上的简单类型层次。在 Grakn 中，Graql 被用作它的模式语言。</p><h2 id="27e4" class="mm lv it bd lw mn mo dn ma mp mq dp me ld mr ms mg lh mt mu mi ll mv mw mk mx bi translated">RDFS 班级</h2><p id="e8f2" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">RDFS 扩展了 RDF 词汇表，允许描述类和属性的分类法。RDFS 类将 RDFS 资源声明为其他资源的类。我们可以用<code class="fe nm nn no ne b">rdfs:Class</code>来简化它。使用 XML，创建一个带有子类<code class="fe nm nn no ne b">horse</code>的类<code class="fe nm nn no ne b">animal</code>，如下所示:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="df82" class="mm lv it ne b gy ni nj l nk nl">&lt;?xml version="1.0"?&gt;</span><span id="78a7" class="mm lv it ne b gy np nj l nk nl">&lt;rdf:RDF<br/>xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"<br/>xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"<br/>xml:base="http://www.animals.fake/animals#"&gt;</span><span id="c36d" class="mm lv it ne b gy np nj l nk nl">&lt;rdfs:Class rdf:ID="animal" /&gt;<br/>&lt;rdfs:Class rdf:ID="horse"&gt;<br/>  &lt;rdfs:subClassOf rdf:resource="#animal"/&gt;<br/>&lt;/rdfs:Class&gt;<br/>&lt;/rdf:RDF&gt;</span></pre><p id="a670" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要在 Grakn 中做同样的事情，我们应该这样写:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="9076" class="mm lv it ne b gy ni nj l nk nl">define <br/>animal sub entity; <br/>horse sub animal;</span></pre><p id="bd12" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">RDFS 还允许<code class="fe nm nn no ne b">Properties</code>的子类型:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="0b83" class="mm lv it ne b gy ni nj l nk nl">&lt;?xml version="1.0"?&gt;</span><span id="2daf" class="mm lv it ne b gy np nj l nk nl">&lt;rdf:RDF<br/>xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"<br/>xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"<br/>xml:base="http://www.animals.fake/animals#"&gt;</span><span id="7a60" class="mm lv it ne b gy np nj l nk nl">&lt;rdfs:Class rdf:ID="mammal" /&gt;</span><span id="cb51" class="mm lv it ne b gy np nj l nk nl">&lt;rdfs:Class rdf:ID="human"&gt;<br/>  &lt;rdfs:subClassOf rdf:resource="#mammal"/&gt;<br/>&lt;/rdfs:Class&gt;</span><span id="9d67" class="mm lv it ne b gy np nj l nk nl">&lt;rdfs:Property rdf:ID="employment" /&gt;</span><span id="d80b" class="mm lv it ne b gy np nj l nk nl">&lt;rdfs:Property rdf:ID="part-time-employment"&gt;<br/>  &lt;rdfs:subPropertyOf rdf:resource="#employment"/&gt;<br/>&lt;/rdfs:Property&gt;</span><span id="f0e0" class="mm lv it ne b gy np nj l nk nl">&lt;/rdf:RDF&gt;</span></pre><p id="2e6f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在 Grakn 中是这样的:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="8e3c" class="mm lv it ne b gy ni nj l nk nl">mammal sub entity; <br/>human sub mammal;<br/>employment sub relation;<br/>part-time-employment sub employment;</span></pre><p id="0b7c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如示例所示，RDFS 主要描述了对象类型的构造(<code class="fe nm nn no ne b">Classes</code>)、相互继承(<code class="fe nm nn no ne b">subClasses</code>)、描述对象的属性(<code class="fe nm nn no ne b">Properties</code>)以及相互继承(<code class="fe nm nn no ne b">subProperty</code>)。这种子类型行为可以通过 Graql 的<code class="fe nm nn no ne b">sub</code>关键字获得，该关键字可用于创建 Grakn 中任何<code class="fe nm nn no ne b">thing</code> ( <code class="fe nm nn no ne b">entities</code>、<code class="fe nm nn no ne b">relations</code>和<code class="fe nm nn no ne b">attributes</code>)的类型层次结构。</p><p id="93ef" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，在 Grakn 中的<code class="fe nm nn no ne b">class</code>到<code class="fe nm nn no ne b">entity</code>或者在 Grakn 中的<code class="fe nm nn no ne b">property</code>到<code class="fe nm nn no ne b">relation</code>之间创建一对一的映射，尽管它们看起来很相似，但不应该总是这样做。这是因为 RDF 中的模型是使用较低级别的数据模型构建的，以三元组工作，而 Grakn 能够在较高级别建模。</p><h2 id="0348" class="mm lv it bd lw mn mo dn ma mp mq dp me ld mr ms mg lh mt mu mi ll mv mw mk mx bi translated">多重遗传</h2><p id="64fd" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">Grakn 和语义网之间一个重要的建模差异是关于多重继承。在 RDFS，一个类可以有许多命名的或逻辑推断的超类。让我们举这个例子:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="8c0e" class="mm lv it ne b gy ni nj l nk nl">company      rdf:type  rdfs:Class<br/>government   rdf:type  rdfs:Class</span><span id="a5a0" class="mm lv it ne b gy np nj l nk nl">employer     rdf:type         rdfs:Class<br/>employer     rdfs:subClassOf  company<br/>employer     rdfs:subClassOf  government</span></pre><p id="4097" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这将一个<code class="fe nm nn no ne b">employer</code>建模为类<code class="fe nm nn no ne b">company</code>和<code class="fe nm nn no ne b">government</code>。然而，尽管这看起来可能是正确的，问题是多重继承，作为一个建模概念，经常没有以正确的方式使用。多重继承应该对事物进行分组，而不是对“类型”进行子类化，其中每个类型都是其他事物的定义。换句话说，我们不想表示数据的实例。这是一个常见的错误。</p><p id="9f75" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Grakn 支持单一类型继承，而不是多重继承，在这种情况下，我们应该分配<code class="fe nm nn no ne b">role</code>而不是多重类。一个<code class="fe nm nn no ne b">role</code>在一个<code class="fe nm nn no ne b">relation</code>的上下文中定义了一个<code class="fe nm nn no ne b">thing</code>的行为和方面，我们可以将多个<code class="fe nm nn no ne b">role</code>分配给一个<code class="fe nm nn no ne b">thing</code>(注意，当类型继承另一个类型时，角色被继承)。</p><p id="9d10" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">比如一个<code class="fe nm nn no ne b">government</code>可以雇佣一个<code class="fe nm nn no ne b">person</code>，一个<code class="fe nm nn no ne b">company</code>可以雇佣一个<code class="fe nm nn no ne b">person</code>。有人可能会建议创建一个继承了可以使用<code class="fe nm nn no ne b">person</code>的<code class="fe nm nn no ne b">government</code>和<code class="fe nm nn no ne b">company</code>的类，并以子类化这两者的<code class="fe nm nn no ne b">employer</code>类结束(如上例所示)。</p><p id="87ce" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，这是对继承的滥用。在这种情况下，我们应该创建一个角色<code class="fe nm nn no ne b">employer</code>，它与一个<code class="fe nm nn no ne b">employment</code>关系相关联，并将一个<code class="fe nm nn no ne b">company</code>或<code class="fe nm nn no ne b">government</code>如何参与到该关系中联系起来(通过扮演<code class="fe nm nn no ne b">employer</code>的角色)。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="56dc" class="mm lv it ne b gy ni nj l nk nl">company sub entity,<br/>    plays employer;</span><span id="a50f" class="mm lv it ne b gy np nj l nk nl">government sub entity,<br/>    plays employer;</span><span id="b4f6" class="mm lv it ne b gy np nj l nk nl">employment sub relation,<br/>    relates employer;</span></pre><h2 id="ba24" class="mm lv it bd lw mn mo dn ma mp mq dp me ld mr ms mg lh mt mu mi ll mv mw mk mx bi translated">rdfs:域和 rdfs:范围</h2><p id="9b9d" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated"><code class="fe nm nn no ne b">rdf:property</code>的两个常用实例包括<code class="fe nm nn no ne b">domain</code>和<code class="fe nm nn no ne b">range</code>。这些用于分别声明属性的成员或值是一个或多个类的实例。下面是一个<code class="fe nm nn no ne b">rdfs:domain</code>的例子:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="7bc1" class="mm lv it ne b gy ni nj l nk nl">:publishedOn rdfs:domain :PublishedBook</span></pre><p id="9d37" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里，<code class="fe nm nn no ne b">rdfs:domain</code>将类<code class="fe nm nn no ne b">Person</code>分配给<code class="fe nm nn no ne b">hasBrother</code>属性的主题。</p><p id="1f0e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一个<code class="fe nm nn no ne b">rdfs:range</code>的例子:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="8181" class="mm lv it ne b gy ni nj l nk nl">:hasBrother rdfs:range :Male</span></pre><p id="c5df" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里，<code class="fe nm nn no ne b">rdfs:range</code>将类<code class="fe nm nn no ne b">Male</code>分配给<code class="fe nm nn no ne b">hasBrother</code>属性的对象。</p><p id="1838" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在 Grakn 中，没有直接实现<code class="fe nm nn no ne b">range</code>和<code class="fe nm nn no ne b">domain</code>。从它们中得出的基本推断要么已经通过使用<code class="fe nm nn no ne b">role</code>在 Grakn 数据模型中被本地表示，要么我们可以创建<code class="fe nm nn no ne b">rule</code>来表示我们想要推断的逻辑。</p><p id="4141" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是，请记住，在 Grakn 中使用规则可以提供更多的表达能力，允许我们表示我们想要进行的推理类型。简而言之，将<code class="fe nm nn no ne b">range</code>和<code class="fe nm nn no ne b">domain</code>翻译成 Grakn 应该根据具体情况进行。</p><p id="b0cc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的例子中，<code class="fe nm nn no ne b">rdfs:domain</code>可以翻译成 Grakn，即当一个实体有一个属性类型<code class="fe nm nn no ne b">published-date</code>时，它在一个<code class="fe nm nn no ne b">publishing</code>关系类型中扮演<code class="fe nm nn no ne b">published-book</code>的角色。这体现在 Grakn 规则中:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="510d" class="mm lv it ne b gy ni nj l nk nl">when {<br/>	$b has published-date $pd; <br/>}, then {<br/>	(published-book: $b) is publishing; <br/>};</span></pre><p id="c32c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">可以使用以下 Grakn 规则创建<code class="fe nm nn no ne b">rdfs:range</code>的示例，该规则添加值为“男性”的属性类型<code class="fe nm nn no ne b">gender</code>，前提是在任何<code class="fe nm nn no ne b">siblingship</code>关系中，a <code class="fe nm nn no ne b">person</code>扮演角色<code class="fe nm nn no ne b">brother</code>，其中其他兄弟的数量为 n</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="a558" class="mm lv it ne b gy ni nj l nk nl">when {<br/>	$r (brother: $p) isa siblingship; <br/>}, then {<br/>	$p has gender "male";  <br/>};</span></pre><p id="f0f3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们再来看另一个例子。在海事环境中，如果我们有一艘<code class="fe nm nn no ne b">DepartingVessel</code>级的船只，它具有指定的属性<code class="fe nm nn no ne b">nextDeparture</code>，我们可以声明:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="0fd5" class="mm lv it ne b gy ni nj l nk nl">ship:Vessel rdf:type rdfs:Class .<br/>ship:DepartingVessel rdf:type rdfs:Class .<br/>ship:nextDeparture rdf:type rdf:Property .<br/>ship:QEII a ship:Vessel .<br/>ship:QEII ship:nextDeparture "Mar 4, 2010" .</span></pre><p id="bee2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过下面的<code class="fe nm nn no ne b">rdfs:Domain</code>，任何指定了<code class="fe nm nn no ne b">nextDeparture</code>的船只将被推断为<code class="fe nm nn no ne b">DepartingVessel</code>类的成员。在这个例子中，这意味着 QEII 被分配了<code class="fe nm nn no ne b">DepartingVessel</code>类。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="6fcb" class="mm lv it ne b gy ni nj l nk nl">ship:nextDeparture rdfs:domain ship:DepartingVessel .</span></pre><p id="c82a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了在 Grakn 中做同样的事情，我们可以编写一个规则，找到所有具有属性<code class="fe nm nn no ne b">next-departure</code>的实体，并将它们分配给一个扮演<code class="fe nm nn no ne b">departing-vessel</code>角色的关系<code class="fe nm nn no ne b">departure</code>。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="d2af" class="mm lv it ne b gy ni nj l nk nl">when {<br/>	$s has next-departure $nd; <br/>}, then {<br/>	(departing-vessel: $s) isa departure; <br/>};</span></pre><p id="81c0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，如果该数据被摄取:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="9a0a" class="mm lv it ne b gy ni nj l nk nl">$s isa vessel, has name "QEII", has next-departure "Mar 4, 2010";</span></pre><p id="b226" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Grakn 推断 QEII 号船在<code class="fe nm nn no ne b">departure</code>关系中扮演<code class="fe nm nn no ne b">departing-vessel</code>的角色，相当于本案例中的<code class="fe nm nn no ne b">nextDeparture</code>级。</p><p id="d732" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在 web 环境中使用<code class="fe nm nn no ne b">rdfs:domain</code>和<code class="fe nm nn no ne b">rdfs:range</code>非常有用，在 web 环境中，联邦数据经常会被发现是不完整的。由于 Grakn 不存在于 web 上，所以对这些概念的需求减少了。此外，这些推断数据的大部分已经在 Grakn 的概念模型中进行了本地表示。这很大程度上是由于它的高层模型和规则的使用。因此，在 Grakn 中将<code class="fe nm nn no ne b">rdfs:range</code>和<code class="fe nm nn no ne b">rdfs:domain</code>直接映射到一个概念通常是幼稚的，会导致冗余。相反，将这些概念转换成 Grakn 应该使用规则和角色根据具体情况来完成。</p><p id="6b8f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lq">在最后的第 3 部分(</em> <a class="ae lr" href="https://medium.com/@tasabat/comparing-grakn-to-semantic-web-technologies-part-3-3-cb2fb233fbd5" rel="noopener"> <em class="lq">链接此处</em> </a> <em class="lq">)，我们看看 Grakn 是如何比较 OWL 和 SHACL 的。要了解更多信息，请务必通过</em> <a class="ae lr" href="https://discuss.grakn.ai/t/were-taking-our-summer-tour-online/1947/2" rel="noopener ugc nofollow" target="_blank"> <em class="lq">此链接</em> </a> <em class="lq">参加我们即将举办的网络研讨会。</em></p></div></div>    
</body>
</html>