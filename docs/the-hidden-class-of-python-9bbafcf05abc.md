# Python 的隐藏类

> 原文：<https://towardsdatascience.com/the-hidden-class-of-python-9bbafcf05abc?source=collection_archive---------36----------------------->

![](img/04f6f404410533a8719d3ce5685bffaa.png)

由 [Nam Hoang](https://unsplash.com/@puonqnam217?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

在本文中，我们将探索 python 的两个强大特性，它们存在于标准库中，但由于缺乏宣传而几乎总是被忽略。

## 数据类

最近，我有幸获得了代码审查。在其他程序员检查我的代码的错误、瑕疵和其他编程小精灵的过程中，不止一个人(实际上是两个)问过这是怎么回事:

```
@dataclass
class Car:
 doors: int
 …
```

在 Python 3.7+的上下文中，“this”是一个数据类，一个很少有人遇到的强大而有趣的特性。不管外表如何，它也是有效的代码，这总是一个优势。在 Python 中引入数据类是为了尽可能快地编写代码，同时减少重复，使代码看起来更专业。它只需要定义要存储的数据就可以实现这一点。定义数据变得很容易，我们只需在数据类缩进中列出变量。当然，其他所有事情都是以内部优化的方式为我们完成的，最显著的是包括 __init__ 构造函数方法的创建、所有变量的赋值以及其他一些东西。一个**完整的**例子就这么简单:

```
from dataclasses import dataclass@dataclass 
class Car:
 doors: int
 windows: int
 paint_work: str
```

只需几行代码，我们就可以创建和初始化实例、赋值并免费创建访问器方法。我们可以用命名参数或位置参数创建每个新的实例对象，Python 会理解我们传递的内容，并给正确的变量赋值。

```
mustang = Car(doors=4, windows=8, paint_work=”black”)
mustang = Car(4, 8, “black”)
```

上面的两个初始化调用都创建了一个有效的新“Car”data class 对象，可以用点(.)语法:

```
print(“My mustang is {}”.format(mustang.paint_work))
```

我们受益于将这一点推进到我们的编码工具箱中，因为我们的脚本变得更可读和更快，正如我们所讨论的那样，但这还不是全部。我们还获得了许多其他“特殊”的 python 方法。dataclass 附带了一个 __repr__ 方法，用于将类表示为字符串，一个相等测试方法 __eq__ 和其他允许 dataclass 对象比较的方法。这意味着我们可以编写清晰的语句，如 mustang > dodge，并让它返回一个 bool。回到 __repr__ 方法，我们能够打印一个实例(字面意思是 print(mustang))并实际看到一些有用的东西！

```
print(mustang)[Out]: Car(doors=4, windows=2, paint_work=’black’)
```

这是一个大问题，因为当我们试图打印一个“普通”类时，默认的输出是令人惊讶的无用:

```
[Out]: <__main__.BadCar object at 0x7f0be5c96190>
```

浏览文档([https://docs.python.org/3/library/dataclasses.html](https://docs.python.org/3/library/dataclasses.html))是很有价值的，因为有大量更具体的功能和用例，可以很好地探索和应用到项目的需求中。

## 装修工

简而言之，让我们探索一下在编写数据类时会发生什么。首先，我们用@dataclass 装饰器‘装饰’这个类(这难道不是一个很好的清晰的循环解释吗)。真正的装饰者本身就值得写一整篇文章，因为他们提供了一种方法来截取和修改对象/方法的输入和输出，同时保留所有原始方法的代码。它们通常被描述为方法包装器。将一种或多种方法与另一种方法包装在一起有助于使代码看起来更专业，并减少重复。

## 类型化变量

类属性(我们通常必须通过 self.our_attribute = "cow "来定义)是用 int 和 strings 类型化的。我不得不承认，在 python 中，类型化看起来很奇怪，但它是区分数据类字段和静态属性(也称为静态变量)的一种简单方法，并且在访问数据源和在 ide 中完成代码时都可以从类型化中受益。如果我们不为数据类提供变量类型(例如，只有 doors = 4)，我们就不会创建数据类字段，而是创建一个静态属性。静态属性错过了 __init__ 函数中自动赋值的好处和所有其他优点。另一方面，静态属性的默认值特性可以应用于数据类(wheels: int = 4)。我们只是在类型后面提供了一个默认值，这意味着如果 __init__ 构造函数没有为一个具有默认值的字段传递一个参数，那么该字段将毫无疑问地采用默认值。

## 命名的元组

另一个具有特殊 python 功能的隐藏对象是命名元组。数据类提供了许多简洁的特性，但是默认情况下，它们不能像列表或数组那样被索引(可下标的，像 mustang[2])。通过用 __getitem__(self，I)的签名实现 getitem 方法，我们可以很容易地为任何类添加索引功能，其中“I”是我们要返回的列表/数组中的项目的索引。然而，NamedTuples 提供了一种更简单的无类方法，只需一行代码就可以实现双重访问:

```
from collections import namedtuple
Coordinate = namedtuple(“Coordinate”, (“x”, “y”))
point = Coordinate(3, 7)print(point.x)
print(point[0])
```

两个打印语句给出了相同的结果。如果您处理的是类似坐标类型的东西，通过索引和名称方便地访问对象是有益的，那么这就很有用。导入 namedtuple 后，我们创建了 namedtuple 的*类型*,方法是将其名称指定为字符串，将其变量的名称指定为元组内的字符串。通过索引和点语法联合访问的好处是清晰。通过点语法访问和分配的变量很清楚(索引可读性差，更容易出错)，另一方面，我们仍然受益于循环和数学运算中的索引，在这些运算中，使用名称访问会导致重复代码，因为只有变量的名称会被更改。

## 可供选择的事物

虽然在任何编程语言中发现新的有用的工具都是非常令人兴奋的。)，一旦我们冷静下来，我们可能会问自己为什么不使用字典？

car = {"doors": 0，" windows": 4，" paint_work": "red"}

虽然字典确实工作得很好，但字典也会带来问题。首先，像任何动态定义的类型一样，特别是当使用字符串访问器时，字典的查找和赋值很慢，因为每个操作都需要解析关键字符串。它们也很难翻译成 C 之类的语言，并且无法从将 Python 代码编译成 Cython 所带来的速度提升(减少执行时间)中获益。更重要的是，通过使用字符串访问键，字典很容易出现运行时错误。因为不正确的密钥串只会产生运行时错误，所以程序只有在使用特定的错误密钥时才会崩溃。很容易写:

```
print(car[“colour”])
[Out]: KeyError: ‘colour’…
```

忘记了我们还没有在字典中添加颜色项，或者忘记了我们使用了“colour”的英式拼法，而真正的关键字是没有 u 的美式拼法。我们都容易犯拼写错误。

## 摘要

数据类允许简洁快速地定义对象和它们的字段变量，帮助我们编写干净的、分区化的代码。数据类是只有 Python 3.7+才有的新特性。

命名元组允许我们通过索引和点语法来访问数据，并且通常在所有 Python 3 版本中都可用。

字典通过关键字串提供访问，因此速度慢并且容易出现运行时错误。用数据类和命名元组替换我们的字典是有意义的。

## 脚注

1:如果你使用的是 Python <= 3.6，那么它就不是有效的代码，你将不得不对这篇文章感到愤怒，或者使用命名元组来代替。或者直接升级。

2:令人惊讶的是,“特殊方法”是这些默认方法的官方术语，而不仅仅是我自己的一个半生不熟的新词。

3:毕竟重要的是我们的代码看起来很好，尤其重要的是我们的代码在崩溃时看起来很好。