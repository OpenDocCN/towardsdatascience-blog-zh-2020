<html>
<head>
<title>How To Analyse A Single Time Series Variable</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何分析单个时间序列变量</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-analyse-a-single-time-series-variable-11dcca7bf16c?source=collection_archive---------19-----------------------#2020-04-05">https://towardsdatascience.com/how-to-analyse-a-single-time-series-variable-11dcca7bf16c?source=collection_archive---------19-----------------------#2020-04-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="2ed9" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/time-series-modeling" rel="noopener" target="_blank">探索时间序列建模</a></h2><div class=""/><div class=""><h2 id="0e57" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">用Python代码进行时间序列建模</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/1c09f1de0da0e4f634274af87d4c6bc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gKl1DNdDCa9jii1N"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae lh" href="https://unsplash.com/@tangib?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> tangi bertin </a>拍摄的照片</p></figure><p id="e792" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">欢迎回来！这是<a class="ae lh" href="https://towardsdatascience.com/tagged/time-series-modeling" rel="noopener" target="_blank">专栏</a>的第二篇文章，探索用Python代码对时间序列数据进行分析和建模。如果你不熟悉基本的统计学概念，比如估计量、假设检验、p值等，可以看看我之前的帖子:<a class="ae lh" rel="noopener" target="_blank" href="/fundamental-statistics-7770376593b"> <strong class="lk jd"> <em class="me">用Python代码进行时间序列建模:基本面统计</em> </strong> </a>。</p><p id="7363" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这篇文章中，我们将开始探索分析一个单一的时间序列变量。给定一个时间序列变量，我们应该从哪里开始分析？我们如何深入了解这些数据？老实说，我第一次被要求对一个. csv文件格式的时间序列数据进行分析时，没有任何关于数据源和应用程序的进一步信息，我不知道从哪里开始。在这篇文章之后，希望下次你会有一些关于如何开始分析一个时间序列变量的想法。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><p id="7d25" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这里，我将分析历史苹果股票价格数据。的。csv文件可以从<a class="ae lh" href="https://sg.finance.yahoo.com/quote/AAPL/" rel="noopener ugc nofollow" target="_blank">雅虎财经</a>下载。我下载了去年的AAPL数据，从2019年3月13日到2020年3月13日。原始数据包括每日开盘价、最高价、最低价、收盘价、调整收盘价和成交量。在这篇文章中，我将分析AAPL的每日收盘价。</p><pre class="ks kt ku kv gt mm mn mo mp aw mq bi"><span id="86f4" class="mr ms it mn b gy mt mu l mv mw">import numpy as np<br/>import pandas as pd<br/>import matplotlib.pyplot as plt</span><span id="14e8" class="mr ms it mn b gy mx mu l mv mw">AAPL_price = pd.read_csv('AAPL.csv',usecols=['Date', 'Close'])<br/>AAPL_price.set_index('Date',inplace=True,drop=True)</span><span id="5ea9" class="mr ms it mn b gy mx mu l mv mw">AAPL_price.plot(legend=False)<br/>plt.title('AAPL Daily Close Price')</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi my"><img src="../Images/15714cb936828c6c80784c76ed5f53c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*L-zAYamsx-OzT-VV2m1gZw.png"/></div></figure><h1 id="e83b" class="mz ms it bd na nb nc nd ne nf ng nh ni ki nj kj nk kl nl km nm ko nn kp no np bi translated">1.滚动平均值和方差</h1><p id="4f1a" class="pw-post-body-paragraph li lj it lk b ll nq kd ln lo nr kg lq lr ns lt lu lv nt lx ly lz nu mb mc md im bi translated">样本参数不是恒定的，它们也是随时间变化的。单点样本均值或样本方差不会向我们透露太多信息。如果不知道样本参数的方差，我们就无法知道样本参数对总体参数的估计有多好。因此，我们不能依赖点样本均值或样本方差来估计总体参数。</p><p id="bc2c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们将应用滚动窗口方法获得一年期间的多个样本均值和样本方差值，而不是从一年的AAPL股票价格数据计算一个点的样本均值和样本方差值。以下代码显示了如何以10、30和50的不同窗口大小显示样本均值。</p><pre class="ks kt ku kv gt mm mn mo mp aw mq bi"><span id="faff" class="mr ms it mn b gy mt mu l mv mw">import numpy as np<br/>import pandas as pd<br/>import matplotlib.pyplot as plt</span><span id="7369" class="mr ms it mn b gy mx mu l mv mw">AAPL_price = pd.read_csv('AAPL.csv',usecols=['Date', 'Close'])<br/>AAPL_price.set_index('Date',inplace=True,drop=True)</span><span id="4c87" class="mr ms it mn b gy mx mu l mv mw">ax = AAPL_price.plot(legend=False)<br/>ax.set_title('AAPL Daily Close Price')</span><span id="24be" class="mr ms it mn b gy mx mu l mv mw">AAPL_price.rolling(window=10).mean().plot(ax=ax)<br/>AAPL_price.rolling(window=30).mean().plot(ax=ax)<br/>AAPL_price.rolling(window=50).mean().plot(ax=ax)</span><span id="1756" class="mr ms it mn b gy mx mu l mv mw">ax.legend(['Daily price', 'm=10', 'm=20', 'm=30'])</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi my"><img src="../Images/dde7ea8c637e1716069336cd331a21ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*40M4dbdenTRXfY2IswbumQ.png"/></div></figure><p id="73a2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">类似地，我们可以用不同的窗口大小来可视化样本方差。</p><pre class="ks kt ku kv gt mm mn mo mp aw mq bi"><span id="d316" class="mr ms it mn b gy mt mu l mv mw">import numpy as np<br/>import pandas as pd<br/>import matplotlib.pyplot as plt</span><span id="2cf4" class="mr ms it mn b gy mx mu l mv mw">AAPL_price = pd.read_csv('AAPL.csv',usecols=['Date', 'Close'])<br/>AAPL_price.set_index('Date',inplace=True,drop=True)</span><span id="2c4e" class="mr ms it mn b gy mx mu l mv mw">ax = AAPL_price.plot(legend=False)<br/>ax.set_title('AAPL Daily Close Price')</span><span id="f732" class="mr ms it mn b gy mx mu l mv mw">AAPL_price.rolling(window=10).var().plot(ax=ax)<br/>AAPL_price.rolling(window=30).var().plot(ax=ax)<br/>AAPL_price.rolling(window=50).var().plot(ax=ax)</span><span id="bb6d" class="mr ms it mn b gy mx mu l mv mw">ax.legend(['Daily price', 'm=10', 'm=30', 'm=50'])</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi my"><img src="../Images/b248f958561888b914259f878d891c53.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*p6bfTIMlukm6j3Y79wXXDA.png"/></div></figure><p id="abe9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当选择窗口大小时，总是有一个折衷。以滚动样本均值为例，我们会发现较大的窗口大小会生成更平滑的滚动样本均值图。我喜欢从过拟合和欠拟合的角度来考虑窗口大小的选择。小窗口尺寸倾向于捕捉每个时间点的更详细的信息，而大窗口尺寸包括更长时间段的更全面的信息。这样，小的窗口大小可能会造成过拟合，因为它过于关注每个时间点的移动。而大的窗口尺寸可能导致拟合不足，因为它捕捉了太多的整体趋势，但忽略了每个点的局部运动。因此，应仔细选择合适的窗口大小，以避免过度拟合和欠拟合。</p><h1 id="64ac" class="mz ms it bd na nb nc nd ne nf ng nh ni ki nj kj nk kl nl km nm ko nn kp no np bi translated">2.平稳性和弱相关性</h1><p id="0cc6" class="pw-post-body-paragraph li lj it lk b ll nq kd ln lo nr kg lq lr ns lt lu lv nt lx ly lz nu mb mc md im bi translated">为了用普通最小二乘法(OLS)来估计生成过程，时间序列数据需要平稳和弱相关。OLS是线性回归中常用的方法，将在本系列第4篇文章中详细讨论:<strong class="lk jd"> <em class="me">用Python代码进行时间序列建模:如何用线性回归对时间序列数据建模。</em>T3】</strong></p><p id="2f5e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">平稳性有三个要求。时间序列数据的均值和方差都是常数。此外，具有滞后(h)的两个时间点的协方差是滞后的函数，而不应依赖于时间点(t)。</p><p id="66c3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">弱相关性要求当滞后h变得无穷大时，两个时间点的相关性变为零。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nv"><img src="../Images/ea82ef65e8ea9e3991f3bcba190eb201.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pe_mnQW9CI__CKVpksGJTg.png"/></div></div></figure><h1 id="0b08" class="mz ms it bd na nb nc nd ne nf ng nh ni ki nj kj nk kl nl km nm ko nn kp no np bi translated">3.自回归过程和移动平均过程</h1><p id="c7fa" class="pw-post-body-paragraph li lj it lk b ll nq kd ln lo nr kg lq lr ns lt lu lv nt lx ly lz nu mb mc md im bi translated">常见的时间序列过程有两种:自回归过程和移动平均过程。我们将详细讨论这两个过程。</p><p id="61f6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> 3.1自回归过程性质</strong></p><p id="398b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于自回归过程，时间序列数据依赖于自身，具有时滞。当时间序列数据仅依赖于自身且时滞为1时，该过程称为AR(1)。如果时间序列数据依赖于自身，滞后时间为N，那么这个过程称为AR(N)。</p><p id="5c45" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里以AR(1)为例。如果满足两个要求，AR(1)过程是平稳的和弱相关的:第一个时间点的期望值为零，时间序列依赖于前一个时间点，乘法参数位于-1和1之间。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nw"><img src="../Images/11150f221423c4f863f8d73155d9bb76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HdMpyGDxQUijupgjBs5v4Q.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">AR(1)流程属性</p></figure><p id="d49f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在AR(1)过程中，ρ的值决定了AR(1)过程是否平稳。以下是ρ如何影响AR(1)过程的简单可视化。从结果中我们可以看出，当ρ越接近1时，AR(1)过程穿越零线的频率越低。</p><pre class="ks kt ku kv gt mm mn mo mp aw mq bi"><span id="95e2" class="mr ms it mn b gy mt mu l mv mw">import numpy as np<br/>import matplotlib.pyplot as plt</span><span id="1cc6" class="mr ms it mn b gy mx mu l mv mw">N = 10000<br/>rho = 1</span><span id="57d5" class="mr ms it mn b gy mx mu l mv mw">sigma = np.random.normal(loc=0, scale=1, size=N)<br/>x = [0]<br/>for i in range(1,N):<br/>    x.append(rho*x[-1]+sigma[i])</span><span id="f156" class="mr ms it mn b gy mx mu l mv mw">plt.plot(x, label='rho=1')<br/>plt.legend()<br/>plt.xlim(0,N)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nx"><img src="../Images/d7fa71a1529151ca8bc0f617eabe5908.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mXaS2V2phOC3AgznrpBLWw.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">ρ为0.9，0.99，1的AR(1)过程</p></figure><p id="ab38" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> 3.2移动平均过程属性</strong></p><p id="c25f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">MA(1)过程是平稳的、弱相关的。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ny"><img src="../Images/1cb7c4dc9e734519ae3db1f28d2d55a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r9pWtRa1Me5iBUAFeETHtw.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">MA(1)流程属性</p></figure><p id="e2fd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> 3.3自相关函数(ACF)和偏自相关函数(PACF) </strong></p><p id="6d78" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">根据上述MA(1)和AR(1)的性质，我们可以将相关性写为:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nz"><img src="../Images/2b69699bb30daf71a777b9f165204e8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6Y6LG30Cpt0IjXVgmcp5CQ.png"/></div></div></figure><p id="9583" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">通过绘制不同时滞的相关性，我们可以清楚地看到AR(1)过程和MA(1)过程的区别。这个相关图被称为自相关函数(ACF)。AR过程的ACF图显示指数下降，并且在几个时间点之后相关性下降到几乎为零。然而，MA(1)过程的ACF图显示，在前两个时间点之后，相关性迅速下降到零。</p><pre class="ks kt ku kv gt mm mn mo mp aw mq bi"><span id="3382" class="mr ms it mn b gy mt mu l mv mw">import numpy as np<br/>import matplotlib.pyplot as plt<br/>from statsmodels.graphics.tsaplots import plot_acf</span><span id="6e2e" class="mr ms it mn b gy mx mu l mv mw">N = 10000<br/>rho = 0.5</span><span id="e664" class="mr ms it mn b gy mx mu l mv mw">sigma = np.random.normal(loc=0, scale=1, size=N)<br/>x = [0]<br/>for i in range(1,N):<br/>    x.append(rho*x[-1]+sigma[i])</span><span id="c7b2" class="mr ms it mn b gy mx mu l mv mw">plot_acf(np.array(x),lags=10)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi my"><img src="../Images/dd695f95413f11742a118aa6e9df852d.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*Yfnf_W58xEH6r_97grHsDQ.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">AR(1)过程的ACF</p></figure><pre class="ks kt ku kv gt mm mn mo mp aw mq bi"><span id="025b" class="mr ms it mn b gy mt mu l mv mw">import numpy as np<br/>import matplotlib.pyplot as plt<br/>from statsmodels.graphics.tsaplots import plot_acf</span><span id="3160" class="mr ms it mn b gy mx mu l mv mw">N = 10000<br/>theta = 0.5</span><span id="c0d0" class="mr ms it mn b gy mx mu l mv mw">sigma = np.random.normal(loc=0, scale=1, size=N+1)<br/>x = []<br/>for i in range(1,N+1):<br/>    x.append(sigma[i]+theta*sigma[i-1])</span><span id="822a" class="mr ms it mn b gy mx mu l mv mw">plot_acf(np.array(x),lags=10)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi my"><img src="../Images/33053e703f0c66add32a2cb119ad8a7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*kHweLnI-k_rs5DZpL6AaPw.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">MA(1)过程的ACF</p></figure><p id="8e2c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">虽然ACF图可以用来区分MA和AR过程，但它不能很好地区分AR(1)过程和AR(2)过程。偏自相关函数(PACF)可以用来区分AR(1)和AR(2)过程。如下例所示，AR(1)过程的PACF显示相关性在前2个时间点后迅速下降到零，而AR(2)过程的PACF显示相关性在前3个时间点后下降到零。</p><pre class="ks kt ku kv gt mm mn mo mp aw mq bi"><span id="202f" class="mr ms it mn b gy mt mu l mv mw">import numpy as np<br/>import matplotlib.pyplot as plt<br/>from statsmodels.graphics.tsaplots import plot_pacf</span><span id="3903" class="mr ms it mn b gy mx mu l mv mw">N = 10000<br/>rho = 0.5<br/>rho2 = 0.4</span><span id="019a" class="mr ms it mn b gy mx mu l mv mw">sigma = np.random.normal(loc=0, scale=1, size=N)<br/>x = [0,0]<br/>for i in range(2,N):<br/>    x.append(rho*x[-1]+rho2*x[-2]+sigma[i])</span><span id="093a" class="mr ms it mn b gy mx mu l mv mw">plot_pacf(np.array(x),lags=10)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oa"><img src="../Images/c29a691e0e08c3cc66929363c09f129b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qvVd3kZfqeS-O2YmM2zv3g.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">AR(1)和AR(2)过程的PACF</p></figure><h1 id="be9d" class="mz ms it bd na nb nc nd ne nf ng nh ni ki nj kj nk kl nl km nm ko nn kp no np bi translated">4.整合过程的顺序</h1><p id="0e5e" class="pw-post-body-paragraph li lj it lk b ll nq kd ln lo nr kg lq lr ns lt lu lv nt lx ly lz nu mb mc md im bi translated"><strong class="lk jd"> 4.1单位根和迪基-富勒检验</strong></p><p id="70b0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如上图，当ρ为1时，AR(1)过程是非平稳的。AR过程中ρ=1的情况称为单位根。下面是单位根为什么是非平稳的一个简单证明。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ob"><img src="../Images/81031f5defc7a75b1c3d5ac9bcaa6e3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VCUrWHYTlXh4FfXIYqmw-Q.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">单位根是非平稳的一个简单证明</p></figure><p id="1085" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">单位根可以用扩展的Dickey-Fuller (ADF)检验。</p><pre class="ks kt ku kv gt mm mn mo mp aw mq bi"><span id="9138" class="mr ms it mn b gy mt mu l mv mw">import pandas as pd<br/>from statsmodels.tsa.stattools import adfuller</span><span id="75fd" class="mr ms it mn b gy mx mu l mv mw">AAPL_price = pd.read_csv('AAPL.csv',usecols=['Close'])<br/>result = adfuller(AAPL_price.iloc[:,0].values)<br/>print(f'p value is {result[1]}')</span></pre><p id="98e8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">输出:</p><p id="f7a6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">p值为0.5961654850033034</p><p id="ceb9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">由于p值大于0.05的显著性水平，我们不能拒绝时间序列数据是非平稳的零假设。因此，时间序列数据是非平稳的。</p><p id="435d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">具有单位根的AR过程是序列相关的。然而，序列相关的时间序列数据不一定是具有单位根的AR过程。</p><p id="9fa7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> 4.2整合过程的顺序</strong></p><p id="52ed" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于有单位根的AR过程，如果时间序列数据的一阶差分是平稳的，那么时间序列数据遵循I(1)过程。类似地，如果需要二阶差分来获得平稳数据，则该过程遵循I(2)过程。为了找出整合过程的顺序，需要测试一系列ADF。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oc"><img src="../Images/5e6316ef0bc9c28a63f4b168bd87981f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K24Lceam_VQnVuOJTJgTXg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">如何检验整合过程的顺序</p></figure></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="a4bc" class="mz ms it bd na nb od nd ne nf oe nh ni ki of kj nk kl og km nm ko oh kp no np bi translated">摘要</h1><p id="c81b" class="pw-post-body-paragraph li lj it lk b ll nq kd ln lo nr kg lq lr ns lt lu lv nt lx ly lz nu mb mc md im bi translated">在这篇文章中，我们讨论了如何分析单个时间序列变量。通常，我们可以通过绘制时间序列数据的滚动平均值和方差来开始分析。然后我们可以用ACF检验来看时间序列数据是遵循自回归过程还是移动平均过程。如果数据遵循自回归过程，那么我们可以使用PACF检验来寻找自回归过程的阶。此外，我们可以使用Dickey-Fuller测试来确定时间序列数据是否遵循积分过程。</p><p id="8e07" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在下一篇文章中，我们将继续讨论如何分析多个时间序列变量。敬请关注！</p></div></div>    
</body>
</html>