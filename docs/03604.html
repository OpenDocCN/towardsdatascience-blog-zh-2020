<html>
<head>
<title>MedCAT | Extracting Diseases from Electronic Health Records</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从电子健康记录中提取疾病</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/medcat-extracting-diseases-from-electronic-health-records-f53c45b3d1c1?source=collection_archive---------21-----------------------#2020-04-05">https://towardsdatascience.com/medcat-extracting-diseases-from-electronic-health-records-f53c45b3d1c1?source=collection_archive---------21-----------------------#2020-04-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="80e6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">深入探究MedCAT库:从构建概念数据库到无监督训练和文档注释。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/dcb623ee590e603ae120f77a532e64a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r3gNLipHyVt93TJHhDZaxA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自<a class="ae ky" href="https://unsplash.com/photos/hIgeoQjS_iE" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>的<a class="ae ky" href="https://unsplash.com/@impulsq" rel="noopener ugc nofollow" target="_blank">网络营销</a>的照片。</p></figure><p id="12c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章的重点完全是关于MedCAT以及如何使用它从EHRs中提取信息。典型的MedCAT工作流程:</p><ol class=""><li id="4ef3" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">建立一个概念数据库(CDB)和词汇(Vocab)，或使用现有的模型。</li><li id="81c6" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">对包含大量文档的目标域中的任何数据集进行无监督学习。</li><li id="2929" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">为在线/监督学习准备数据。</li><li id="784d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">微调NER+L模型，并通过MedCATtrainer添加元注释。</li><li id="b5c7" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">将所有内容打包到一个MedCAT管道中，并注释文档(EHR)</li></ol><p id="16cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章将涵盖步骤1、2和3，而一篇关于监督培训的文章将经历步骤4和5。</p><h1 id="e471" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">构建定制模型</h1><p id="3511" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated"><a class="ae ky" href="https://colab.research.google.com/drive/1nz2zMDQ3QrlTgpW7FfGaXeV1ZAtZeOe2" rel="noopener ugc nofollow" target="_blank">谷歌Colab </a></p><p id="3bc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">MedCAT在其管道中使用两种主要模型:</p><ul class=""><li id="e790" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ng mb mc md bi translated">词汇表(Vocab) —词汇表用于拼写检查和单词嵌入。它可以使用任何类型的单词嵌入(从Word2Vec到BERT)。如果数据集来自非常特定的领域，通常建议您创建嵌入。</li><li id="9cc9" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ng mb mc md bi translated">概念数据库(CDB) —概念数据库包含特定案例的所有相关概念。在医疗应用中，像UMLS或SNOMED这样的大型数据库是标准的，然后过滤出所需的概念。MedCAT适用于任何类型的概念数据库，无论其规模有多大。</li></ul><p id="b353" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章的其余部分将展示如何从头开始构建这些模型。</p><h2 id="f129" class="nh mk it bd ml ni nj dn mp nk nl dp mt li nm nn mv lm no np mx lq nq nr mz ns bi translated">建立新词汇</h2><p id="bf89" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">运行MedCAT时需要的两个模型中的第一个是词汇模型(Vocab)。该模型用于两件事:(1)拼写检查；以及(2)单词嵌入。</p><p id="8438" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Vocab非常简单，您可以从一个结构如下的文件中构建它:</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="dbc0" class="nh mk it nu b gy ny nz l oa ob">&lt;token&gt;\t&lt;word_count&gt;\t&lt;vector_embedding_separated_by_spaces&gt;</span></pre><ul class=""><li id="85f6" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ng mb mc md bi translated">通常是一个字或子字，如果你使用字节对编码或类似的东西。</li><li id="cca9" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ng mb mc md bi translated"><code class="fe oc od oe nu b">word_count</code>这个词在你的数据集或任何大型数据集中的数量(维基百科也很好)。</li><li id="ff6b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ng mb mc md bi translated"><code class="fe oc od oe nu b">vector_embedding_separated_by_spaces</code>预先计算好的矢量嵌入，它可以是从Word2Vec到BERT的任何东西。</li></ul><p id="e04d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用三维矢量嵌入构建词汇表的文件示例(这是一个没有标题的TSV文件):</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="4188" class="nh mk it nu b gy ny nz l oa ob">house    34444     0.3232 0.123213 1.231231<br/>dog    14444    0.76762 0.76767 1.45454<br/>.<br/>.<br/>.</span></pre><p id="6c10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，如果拼写很重要(或者如果您希望MedCAT稍后能够纠正拼写错误)，词汇表中的所有单词都必须拼写正确。</p><p id="5ea7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，要构建vocab:</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="7975" class="nh mk it nu b gy ny nz l oa ob">from medcat.utils.vocab import Vocab</span><span id="a54b" class="nh mk it nu b gy of nz l oa ob">vocab = Vocab()<br/>vocab.add_words(path=&lt;path_to_the_tsv_file&gt;)<br/># Save the new Vocab<br/>vocab.save_dict(&lt;save_path&gt;)</span></pre><h2 id="c152" class="nh mk it bd ml ni nj dn mp nk nl dp mt li nm nn mv lm no np mx lq nq nr mz ns bi translated">建立新概念数据库(CDB)</h2><p id="a9a8" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">使用MedCAT时需要的第二个模型是概念数据库(CDB)。这个数据库包含了我们想要检测和链接的所有概念的列表。对于大量的医疗用例，我们将使用大型数据库，如UMLS或SNOMED。但这不是一个要求，MedCAT可以用于任何数据库，不管它有多大。</p><p id="ec84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">CSV是构建CDB所必需的(下面显示的结构/标题是必需的，并且必须存在):</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="3e06" class="nh mk it nu b gy ny nz l oa ob">cui,str<br/>1,kidney failure<br/>7,CoVid 2<br/>7,coronavirus</span></pre><p id="aac3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是用于构建CDB的CSV文件的最基本版本:</p><blockquote class="og oh oi"><p id="6ebd" class="kz la oj lb b lc ld ju le lf lg jx lh ok lj lk ll ol ln lo lp om lr ls lt lu im bi translated"><code class="fe oc od oe nu b"><em class="it">cui</em></code> -概念唯一标识符，这只是你数据库中的一个<code class="fe oc od oe nu b"><em class="it">ID</em></code>，可以是一个数字或一个字符串。</p><p id="6a7b" class="kz la oj lb b lc ld ju le lf lg jx lh ok lj lk ll ol ln lo lp om lr ls lt lu im bi translated"><code class="fe oc od oe nu b"><em class="it">str</em></code>——概念的串/名。为感兴趣的概念写下所有可能的名称和缩写是很重要的。如果您有一个具有多个不同名称的概念(就像上面cui=7的那个)，您可以简单地添加多个具有相同概念ID的行，MedCAT将在构建阶段合并这些行。</p></blockquote><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="6a3a" class="nh mk it nu b gy ny nz l oa ob">from medcat.utils.vocab import Vocab<br/>from medcat.prepare_cdb import PrepareCDB</span><span id="e864" class="nh mk it nu b gy of nz l oa ob">vocab = Vocab()<br/>vocab.load_dict(&lt;path_to_a_vocab_model&gt;)</span><span id="6f08" class="nh mk it nu b gy of nz l oa ob"># Build the concept databse from a simple CSV<br/>prep_cdb = PrepareCDB(vocab=vocab)</span><span id="aeab" class="nh mk it nu b gy of nz l oa ob"># Crete an array for paths to CSV files that will be used to build<br/>#our CDB<br/>paths = [&lt;path_to_our_csv_file&gt;]<br/>cdb = prep_cdb.prepare_csvs(paths)</span><span id="1175" class="nh mk it nu b gy of nz l oa ob"># Save the new model<br/>cdb.save_dict(&lt;save_path&gt;)</span></pre><p id="50c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要打印我们的CDB内容(当CDB非常大时，请小心使用此功能):</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="90af" class="nh mk it nu b gy ny nz l oa ob">print(cdb.cui2original_names)</span><span id="bb3a" class="nh mk it nu b gy of nz l oa ob">#Output: {'1': {'kidney failure'}, '7': {'coronavirus', 'CoVid 2'}}</span></pre><p id="9ea1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，MedCAT用<code class="fe oc od oe nu b">cui=7</code>将这两个概念结合起来，并合并了不同的名称。</p><p id="2169" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">完整的CSV规格</strong></p><p id="e61a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oc od oe nu b">CSV</code>可以包含附加信息，所有可能的字段都在下面的示例中指定:</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="5f26" class="nh mk it nu b gy ny nz l oa ob">cui,str,onto,tty,tui,sty,desc,examples<br/>1,Kidney Failure,SNOMED,PN,T047,Disease,Description of the concept,The patient was diagnosed with kidney failure<br/>1,Failure of Kidneys|KF|K. Failure,,,,,,<br/>.<br/>.</span></pre><p id="2d67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些字段都是可选的，可以包含在您的CSV中，也可以省略:</p><blockquote class="og oh oi"><p id="d14d" class="kz la oj lb b lc ld ju le lf lg jx lh ok lj lk ll ol ln lo lp om lr ls lt lu im bi translated"><code class="fe oc od oe nu b"><em class="it">onto</em></code> -源本体，如HPO、SNOMED、HPC、...</p><p id="9fbf" class="kz la oj lb b lc ld ju le lf lg jx lh ok lj lk ll ol ln lo lp om lr ls lt lu im bi translated"><code class="fe oc od oe nu b"><em class="it">tty</em></code> -术语类型，如PN -主要名称。主要姓名很重要，我建议在创建CDB时添加这些字段。</p><p id="149c" class="kz la oj lb b lc ld ju le lf lg jx lh ok lj lk ll ol ln lo lp om lr ls lt lu im bi translated"><code class="fe oc od oe nu b"><em class="it">tui</em></code> -语义类型标识符-如T047(取自<a class="ae ky" href="https://metamap.nlm.nih.gov/Docs/SemanticTypes_2018AB.txt" rel="noopener ugc nofollow" target="_blank"> UMLS </a>)。</p><p id="dab5" class="kz la oj lb b lc ld ju le lf lg jx lh ok lj lk ll ol ln lo lp om lr ls lt lu im bi translated"><code class="fe oc od oe nu b"><em class="it">sty</em></code> -语义类型-如疾病</p><p id="08aa" class="kz la oj lb b lc ld ju le lf lg jx lh ok lj lk ll ol ln lo lp om lr ls lt lu im bi translated"><code class="fe oc od oe nu b"><em class="it">desc</em></code> -这一概念的描述</p><p id="9510" class="kz la oj lb b lc ld ju le lf lg jx lh ok lj lk ll ol ln lo lp om lr ls lt lu im bi translated"><code class="fe oc od oe nu b"><em class="it">examples</em></code> -这个概念在一个句子中的例子(使用简短的例子，而不是整个文档)。</p></blockquote><p id="25dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">只有一行需要有关于概念的完整信息。</strong></p><p id="68b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从这个CSV构建CDB的代码与上面相同，唯一的不同是构建的CDB上的额外功能:</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="100f" class="nh mk it nu b gy ny nz l oa ob">from medcat.utils.vocab import Vocab<br/>from medcat.prepare_cdb import PrepareCDB</span><span id="d51b" class="nh mk it nu b gy of nz l oa ob">vocab = Vocab()<br/>vocab.load_dict(&lt;path_to_a_vocab_model&gt;)</span><span id="462b" class="nh mk it nu b gy of nz l oa ob"># Build the concept databse from a simple CSV<br/>prep_cdb = PrepareCDB(vocab=vocab)</span><span id="6bde" class="nh mk it nu b gy of nz l oa ob"># Crete an array for paths to CSV files that will be used to build<br/>#our CDB<br/>paths = [&lt;path_to_our_csv_file&gt;]<br/>cdb = prep_cdb.prepare_csvs(paths)</span><span id="e5cd" class="nh mk it nu b gy of nz l oa ob">print(cdb.cui2original_names)<br/># Output: {'1': {'KF', 'Kidney Failure', 'failure of kidneys'}}</span><span id="b62b" class="nh mk it nu b gy of nz l oa ob">print(cdb.tui2cuis)<br/># Output: {'T047': {'1'}}</span><span id="e61d" class="nh mk it nu b gy of nz l oa ob">print(cdb.cui2tui)<br/># Output: {'1': 'T047'}</span><span id="48dc" class="nh mk it nu b gy of nz l oa ob">print(cdb.cui2desc)<br/># Output: {'1': 'Description of the concept'}</span></pre><h2 id="9179" class="nh mk it bd ml ni nj dn mp nk nl dp mt li nm nn mv lm no np mx lq nq nr mz ns bi translated">UMLS和斯诺梅德</h2><p id="bbac" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">如果你能接触到UMLS或T2的SNOMED，你也可以建立大型的医疗CDB。构建CDB仍然使用与上面相同的代码，您只需要将UMLS/SNOMED概念放入具有上述格式的CSV文件中。</p><p id="2215" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很少有用例需要完整的UMLS数据库，我建议使用您的用例/领域所需的子集。构建一个包含完整UMLS数据库的CDB当然是可能的，但是请注意这个过程可能需要36个小时，并且需要大约16Gb的内存。</p><p id="0434" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意</strong>:对于UMLS，我准备了创建CSV文件的脚本，因为我们在PostgreSQL数据库中有UMLS。<a class="ae ky" href="https://arxiv.org/abs/1912.10166" rel="noopener ugc nofollow" target="_blank"> MedCAT论文</a>中的附录A。或者，如果您想构建SNOMED，这里有一个存储库<a class="ae ky" href="https://github.com/antsh3k/Clinical-Coding-Pilot" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="2954" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">无监督训练</h1><p id="da3d" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated"><a class="ae ky" href="https://colab.research.google.com/drive/1q29RbHlZoFK7TcvMKITi3ABbE-E_fw30" rel="noopener ugc nofollow" target="_blank">谷歌Colab </a></p><p id="23ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将使用的模型是从<a class="ae ky" href="https://www.nlm.nih.gov/research/umls/index.html" rel="noopener ugc nofollow" target="_blank"> UMLS </a>创建的；不幸的是，UMLS是不公开的。您可以在这里请求访问UMLS <a class="ae ky" href="https://www.nlm.nih.gov/research/umls/index.html" rel="noopener ugc nofollow" target="_blank">并构建您的模型，如前一节所述。</a></p><p id="b1be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于那些想跟随教程，但不想去UMLS的人，我已经创建了使用UMLS的免费子集的模型。你可以在这里下载CDB模型<a class="ae ky" href="https://s3-eu-west-1.amazonaws.com/zkcl/cdb-medmen.dat" rel="noopener ugc nofollow" target="_blank">，在这里</a>下载词汇表<a class="ae ky" href="https://s3-eu-west-1.amazonaws.com/zkcl/vocab.dat" rel="noopener ugc nofollow" target="_blank">，这些模型更小，但在许多用例中仍然有用(Google Colab已经包含了下载模型的所有代码)。</a></p><p id="6fdb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们加载模型(如果您已经创建了模型，就可以使用它们):</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="ad57" class="nh mk it nu b gy ny nz l oa ob">from medcat.cat import CAT<br/>from medcat.cdb import CDB<br/>from medcat.utils.vocab import Vocab</span><span id="7fab" class="nh mk it nu b gy of nz l oa ob"># Create and load the CDB (Concept Database)<br/>cdb = CDB()<br/>cdb.load_dict(cdb_path)</span><span id="82c2" class="nh mk it nu b gy of nz l oa ob"># Create and load the Vocabulary<br/>vocab = Vocab()<br/>vocab.load_dict(vocab_path)</span><span id="d637" class="nh mk it nu b gy of nz l oa ob"># Create CAT - the main class from medcat used for concept annotation<br/>cat = CAT(cdb=cdb, vocab=vocab)</span></pre><p id="8d5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们将设置几个参数(完整列表将在<a class="ae ky" href="https://github.com/CogStack/MedCAT" rel="noopener ugc nofollow" target="_blank"> github </a>上提供):</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="539c" class="nh mk it nu b gy ny nz l oa ob">cat.spacy_cat.PREFER_FREQUENT = True # Frequent conceps are pref<br/>cat.spacy_cat.PREFER_ICD10 = False # Useful only for clinical coding<br/>cat.spacy_cat.WEIGHTED_AVG = True # The way context is calculated<br/>cat.spacy_cat.MIN_CONCEPT_LENGTH = 3 # Ignore concepts &lt;= 3 characters</span></pre><p id="5cc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在准备运行无人监督的训练。我准备了一个小数据集，可以用来测试无监督训练，但请注意，像MIMIC-III这样的大数据集将产生更好的结果。如果您在本地运行(Google Colab已经有了所有的东西)，下面的代码块假设您已经从存储库中下载了数据(或者您已经有了MIMIC-III):</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="8251" class="nh mk it nu b gy ny nz l oa ob">DATA_DIR = "./data/"<br/>data = pd.read_csv(DATA_DIR + "pt_notes.csv")</span><span id="a5c8" class="nh mk it nu b gy of nz l oa ob"># Enable the unsupervised training<br/>cat.train = True</span><span id="0607" class="nh mk it nu b gy of nz l oa ob"># Print statistics on the CDB model before training<br/>cat.cdb.print_stats()</span><span id="cf6d" class="nh mk it nu b gy of nz l oa ob"># Run the annotation procedure <br/>for i, text in enumerate(data['text'].values):<br/>    # This will now run the training in the background <br/>    _ = cat(text)<br/>    <br/>    # So we know how things are moving<br/>    if i % 100 == 0:<br/>        print("Finished {} - text blocks".format(i))</span><span id="4898" class="nh mk it nu b gy of nz l oa ob"># Print statistics on the CDB after training<br/>cat.cdb.print_stats()</span><span id="5576" class="nh mk it nu b gy of nz l oa ob"># Disable the training mode<br/>cat.train = False</span></pre><p id="6c18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就结束了无监督的训练，如果你看看<code class="fe oc od oe nu b">print_stats</code>函数的输出，你会看到我们有多少概念接受了训练。剩下的就是保存训练好的模型(只有CDB模型接受训练，vocab始终保持不变):</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="afc7" class="nh mk it nu b gy ny nz l oa ob">cdb.save_dict(&lt;save_path&gt;)</span></pre><h1 id="f880" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">注释文档</h1><p id="7fb5" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">现在培训已经结束，我们可以继续文档注释了。</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="7471" class="nh mk it nu b gy ny nz l oa ob">text = "He was diagnosed with Kidney failure"<br/>doc = cat(text)</span><span id="5c93" class="nh mk it nu b gy of nz l oa ob">print(doc.ents)<br/># out: (diagnosed, kidney failure)</span></pre><p id="dae3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仅此而已，没别的了。如果您愿意，也可以使用displacy from spacy查看带注释的文档(适用于Jupyter笔记本):</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="1bc6" class="nh mk it nu b gy ny nz l oa ob">from spacy import displacy</span><span id="12e9" class="nh mk it nu b gy of nz l oa ob">displacy.render(doc, style='ent')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/2d5f3496ca13a45416bc51ff86a4ea4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3j5Dawi5fVtpicTWNlUsvw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图0。MedCAT注释的显示输出。</p></figure><p id="bc48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">底层的CDB模型是基于UMLS的(甚至是公开可用的MedMentions模型)，这允许我们过滤注释，只获得我们感兴趣的概念(对于我们的用例是T047——疾病或综合征；以及T048——精神或行为障碍)，完整列表<a class="ae ky" href="https://metamap.nlm.nih.gov/Docs/SemanticTypes_2018AB.txt" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="43fc" class="nh mk it nu b gy ny nz l oa ob">TUI_FILTER = ['T047', 'T048']<br/>cat.spacy_cat.TUI_FILTER = TUI_FILTER</span><span id="f9c2" class="nh mk it nu b gy of nz l oa ob"># Annotating documents will now give only the concepts<br/>#that have one of the two TUIs defined in the filter.</span><span id="c48e" class="nh mk it nu b gy of nz l oa ob">text = "He was diagnosed with Kidney failure"<br/>doc = cat(text)<br/>#out: (kidney failure)</span></pre><h1 id="c63c" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">为MedCATtrainer准备数据</h1><p id="7b99" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">无监督学习非常有用，因为它不需要我们进行任何注释工作，但它可以学习一些奇怪的东西。为了修复缺失和错误，我们将通过MedCATtrainer使用在线/监督培训对模型进行微调。这样，大部分工作都由无监督学习来完成，我们只需要投入一点时间来完善它。</p><p id="fba6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">再次查看分析年龄和疾病之间关系的用例，我们可以仔细选择使用哪些文档来微调模型。目标是显示年龄和疾病之间联系的一般人口统计，这意味着最流行的疾病(精神和身体)是最重要的。对于微调，选择已经由MedCAT模型检测到的最常见疾病(无监督)并检查错误(或可能的改进)是有意义的。更正式地说，以下是必要的:</p><ul class=""><li id="135d" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ng mb mc md bi translated">用感兴趣的概念(T047和T048)的现有MedCAT模型注释所有文档。</li><li id="0526" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ng mb mc md bi translated">找出最常见的疾病和精神障碍。</li><li id="e03d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ng mb mc md bi translated">查找出现所选最频繁概念的文档。</li><li id="af2c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ng mb mc md bi translated">对于两组(T047和T048)中前100种疾病中的每一种，随机选择N=2份文件，用于验证MedCAT完成的检测。</li></ul><p id="ff2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，我们将只查看感兴趣的概念出现的文档，而不是可能没有提到相关概念的随机文档集。</p><p id="a50f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了注释数据集中的所有文档，我们将使用MedCAT中的<code class="fe oc od oe nu b">multi_processing</code>函数，它允许在多个处理器上更快地运行(如果我们有处理器的话)。在注释过程中，我们将记录每个CUI出现在哪个文档中。</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="8136" class="nh mk it nu b gy ny nz l oa ob"># This will be a map from CUI to a list of documents where it appears: {"cui": [&lt;doc_id&gt;, &lt;doc_id&gt;, ...], ..}<br/>cui_location = {}</span><span id="f786" class="nh mk it nu b gy of nz l oa ob">batch_size = 10000 <br/>batch = []<br/>cnt = 0<br/>for id, row in data.iterrows():<br/>    text = row['text']<br/>    # Skip text if under 10 characters, not really necessary as we <br/>    # have filtered before, but I like to be sure.<br/>    if len(text) &gt; 10:<br/>        batch.append((id, text))<br/>    <br/>    if len(batch) &gt; batch_size or id == len(data) - 1:<br/>        # Update the number of processors depending on your machine.<br/>        #We are using the only_cui option, means the <br/>        #returned entities will only have a CUI (no other <br/>        #information, try both if interested).<br/>        results = cat.multi_processing(batch, nproc=2,only_cui=True)<br/>        <br/>        for pair in results:<br/>            row_id = pair[0]</span><span id="b059" class="nh mk it nu b gy of nz l oa ob"># Convert to set to get unique CUIs<br/>            cui_list = set(pair[1]['entities']) <br/>            <br/>            for cui in cui_list:<br/>                if cui in cui_location:<br/>                    cui_location[cui].append(row_id)<br/>                else:<br/>                    cui_location[cui] = [row_id]<br/>        <br/>        # Reset the batch<br/>        batch = []</span></pre><p id="a60d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经有了每个CUI出现的文档，我们还可以在我们的数据集中绘制最常见的CUI(疾病)(下图)。更完整的代码库请参考<a class="ae ky" href="https://colab.research.google.com/drive/1q29RbHlZoFK7TcvMKITi3ABbE-E_fw30" rel="noopener ugc nofollow" target="_blank">笔记本</a>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/7f93996c69bdc935e8d8c54d14632c5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VznBEvvjuSaGUz-YGJ_WnQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图一。按患者划分的MIMIC-III中前30种疾病/障碍的分布。请不要认为这张图表是理所当然的，它是基于检测疾病的提及，忽略它们是否被否定/历史/假设/与患者无关等。所有这些属性都是下面解释的元注释。</p></figure><p id="3a23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">剩下的是选择最常见的疾病，并为每个疾病随机选择两个文档，并以MedCATtrainer要求的格式保存它们。这是一个简单的<code class="fe oc od oe nu b">CSV </code>文件，结构如下:</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="3fd7" class="nh mk it nu b gy ny nz l oa ob">name,text<br/>&lt;name of a document&gt;,&lt;text of a document&gt;</span></pre><h1 id="a1f6" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">梅德卡特雷纳</h1><p id="2570" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">是一个基于web的界面，可用于改进(或训练新的)MedCAT模型。完整的教程可以在<a class="ae ky" href="https://github.com/CogStack/MedCATtrainer" rel="noopener ugc nofollow" target="_blank">资源库</a> + <a class="ae ky" href="https://medium.com/@tomsearle/medcattrainer-a-tool-for-inspecting-improving-and-customising-medcat-880a11297ebe" rel="noopener">博客文章</a>中找到。培训师支持许多功能，但我们的重点是:</p><ol class=""><li id="b796" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">改善NER+L，教练让我们看到由MedCAT检测到的概念，并为每一个说正确/不正确。如果遗漏了什么，我们还可以添加新的概念(注释)。在此过程中，模型会在后台进行更新和微调。</li><li id="b98e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">元注释，对于每个检测到的概念(在我们的例子中是一种疾病)，我们将添加元注释来表示该概念的上下文相关属性。</li></ol><h2 id="8562" class="nh mk it bd ml ni nj dn mp nk nl dp mt li nm nn mv lm no np mx lq nq nr mz ns bi translated">元注释</h2><p id="9c32" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">对于许多用例来说，仅仅从EHR中提取医疗概念是不够的。通常需要提取每个检测到的概念的元注释(属性/特性)。一些可能的元注释是:</p><ul class=""><li id="f6fc" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ng mb mc md bi translated">否定:概念在文本中是否被否定(例如，患者患有癌症，而患者没有癌症)</li><li id="29d6" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ng mb mc md bi translated">体验者:疾病是否会影响患者或其他人(例如，患者患有癌症，而患者的父母患有癌症)</li><li id="c4ba" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ng mb mc md bi translated">暂时性:该疾病目前影响患者还是过去影响患者(例如，患者发烧与患者两年前发烧)。</li><li id="fa95" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ng mb mc md bi translated">不确定性:有时临床医生会在电子病历中写下假设的陈述(例如，这看起来像肾衰竭)</li><li id="0db8" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ng mb mc md bi translated">有许多其他元注释可以提取，这完全取决于用例。</li></ul><p id="cb0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个例子，在图2中，对于概念<code class="fe oc od oe nu b">lung disease</code>，有2个元注释告诉我们这个概念是否定的(意味着某人没有肺病)，并且体验是耐心的(意味着某人是病人)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/1fca9832dc8ab3b85786e64ac710863e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fHqLO_qRmp1lCGechAvxaQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图二。EHR中的元注释示例。</p></figure><p id="da6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">MedCATtrainer使我们能够训练模型，这些模型稍后将自动进行这些元注释。对于我们的用例，一个元注释就足够了:</p><ul class=""><li id="9fca" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ng mb mc md bi translated">状态(已确认/其他):如果未被否定且当前影响患者，则标记为<code class="fe oc od oe nu b">Confirmed</code>，其他情况下标记为<code class="fe oc od oe nu b">Other</code>。请注意，我们的元注释实际上是否定、经验者、时间性和不确定性的结合。</li></ul><h1 id="11ed" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">结束了</h1><p id="40aa" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">如果你对更多关于MedCAT和电子健康记录的帖子感兴趣，请看这里的<a class="ae ky" href="https://towardsdatascience.com/tagged/medcat" rel="noopener" target="_blank">。</a></p></div></div>    
</body>
</html>