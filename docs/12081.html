<html>
<head>
<title>Reimplementing popular Python functionalities in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 JavaScript 重新实现流行的 Python 功能</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/reimplementing-popular-python-functionalities-in-javascript-b3cfe8e7849f?source=collection_archive---------20-----------------------#2020-08-20">https://towardsdatascience.com/reimplementing-popular-python-functionalities-in-javascript-b3cfe8e7849f?source=collection_archive---------20-----------------------#2020-08-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8f5b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">学习如何应对一个新的世界，并充分利用现有的工具。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/914c891c0217d17e27538c0d711882ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DekBGbiWlOG9G-4j"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@etiennedelorieux?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">艾蒂安·德洛里欧</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="f2fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated">我的第一语言是 Python。我喜欢 Python 的多功能性、易用性和精彩的社区。</p><p id="5eec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">几个月前，我开始冒险深入 JavaScript 丛林，因为我已经开始构建<a class="ae ky" href="http://www.viteach.de" rel="noopener ugc nofollow" target="_blank"> ViTeach </a>(目前只有德语版本)。ViTeach 是一个数学平台，旨在使用机器学习和自然语言处理来快速跟踪和个性化数学学习。但是这篇文章不是为了宣传我的项目。这篇文章是关于我在使用 JavaScript 时错过的一些基本的 Python 功能。但不要担心，经过一段时间的语言适应后，事情开始变得非常相似。</p><p id="b8c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将讨论三种常见的模式/功能，对于来自 Python 的人来说，它们在 JavaScript 中并不十分明显:</p><ul class=""><li id="d486" class="me mf it lb b lc ld lf lg li mg lm mh lq mi lu mj mk ml mm bi translated"><strong class="lb iu">范围</strong></li><li id="ebe2" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated"><strong class="lb iu">列出理解</strong></li><li id="f11a" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated"><strong class="lb iu">字典理解</strong>(并使用结果来获得大型数组操作的性能提升)</li></ul></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="31a2" class="mz na it bd nb nc nd ne nf ng nh ni nj jz nk ka nl kc nm kd nn kf no kg np nq bi translated">①范围</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7205dd69eeed48e204f7f12cbbf39c8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*v0UbJV7uV3NfnlJj"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Ashkan Forouzani 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="9b94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我感到惊讶的第一件事是 JavaScript 没有 Python 钟爱的<code class="fe nr ns nt nu b">range</code>的实现。Python 中的 range 函数返回一个所谓的 sequence 对象，这就是为什么我们必须将它解析为一个列表(或者循环遍历它)来打印出值(例如，在 Jupyter 笔记本中)。但是大多数情况下，您无论如何都只是迭代这些值，因此很少需要 step。<code class="fe nr ns nt nu b">range</code>为 0 索引，取:</p><ul class=""><li id="6820" class="me mf it lb b lc ld lf lg li mg lm mh lq mi lu mj mk ml mm bi translated">一个(最大)，</li><li id="b718" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated">两个(最小和最大)，</li><li id="0502" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated">或者三个参数(最小值、最大值和步长)。</li></ul><p id="0886" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，<code class="fe nr ns nt nu b">range</code>的参数是<em class="nv">位置参数</em> (args)，而不是<em class="nv">关键字参数</em> (kwargs)。</p><h2 id="7a3f" class="nw na it bd nb nx ny dn nf nz oa dp nj li ob oc nl lm od oe nn lq of og np oh bi translated">计算机编程语言</h2><pre class="kj kk kl km gt oi nu oj ok aw ol bi"><span id="03db" class="nw na it nu b gy om on l oo op"><strong class="nu iu">IN: (One Argument - only max value)<br/></strong>list(range(10))<br/><strong class="nu iu">OUT:<br/></strong>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><span id="16d8" class="nw na it nu b gy oq on l oo op"><strong class="nu iu">IN: (Two Arguments - min and max value)<br/></strong>list(range(3,11))<br/><strong class="nu iu">OUT:<br/></strong>[3, 4, 5, 6, 7, 8, 9, 10]</span><span id="a462" class="nw na it nu b gy oq on l oo op"><strong class="nu iu">IN: (Three Arguments - min, max and step value)<br/></strong>list(range(7,34,3))<br/><strong class="nu iu">OUT:<br/></strong>[7, 10, 13, 16, 19, 22, 25, 28, 31]</span></pre><h2 id="05c3" class="nw na it bd nb nx ny dn nf nz oa dp nj li ob oc nl lm od oe nn lq of og np oh bi translated">Java Script 语言</h2><p id="7d50" class="pw-post-body-paragraph kz la it lb b lc or ju le lf os jx lh li ot lk ll lm ou lo lp lq ov ls lt lu im bi translated">尤普，JavaScript 中没有<code class="fe nr ns nt nu b">range</code>函数。对于第一种情况(仅 max ),我们可以得到最接近的结果如下:</p><pre class="kj kk kl km gt oi nu oj ok aw ol bi"><span id="c67c" class="nw na it nu b gy om on l oo op"><strong class="nu iu">IN:<br/></strong>[...Array(5).keys()]<br/><strong class="nu iu">OUT:<br/></strong>[0,1,2,3,4]</span></pre><p id="4ba2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">真的吗？！？这里到底发生了什么？让我们仔细分析一下。首先，我们实例化一个长度为 5 的数组(<code class="fe nr ns nt nu b">Array(5)</code>)。此时，数组的每个值都是<code class="fe nr ns nt nu b">undefined</code>。然后我们通过<code class="fe nr ns nt nu b">.keys()</code>得到每个元素的索引(即在数组中的位置)，最后通过<code class="fe nr ns nt nu b">destructuring</code> ( <code class="fe nr ns nt nu b">…</code>)操作符<code class="fe nr ns nt nu b">destructure</code>将索引列表放到一个新的数组中，从而创建一个浅层副本。哇，那确实是一把。</p><p id="9014" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二种情况(min 和 max)和第三种情况(min、max 和 step)需要更多的自定义逻辑，这就是为什么我决定编写我的实现，并在此后的几乎每个项目中使用它。</p><pre class="kj kk kl km gt oi nu oj ok aw ol bi"><span id="1fe2" class="nw na it nu b gy om on l oo op">const range = (min, max, steps = 1) =&gt; {</span><span id="9881" class="nw na it nu b gy oq on l oo op"><strong class="nu iu">// Step 1)</strong><br/>  const arr = Array.from(<br/>    new Array(max - min), <br/>    (_, idx) =&gt; idx + min<br/>  );</span><span id="77b6" class="nw na it nu b gy oq on l oo op"><strong class="nu iu">// Step 2)</strong><br/>  return arr.filter((_, idx) =&gt; idx % steps === 0);<br/>};</span><span id="d3f5" class="nw na it nu b gy oq on l oo op"><strong class="nu iu">IN:<br/></strong>range(3,11)<br/><strong class="nu iu">OUT:<br/></strong>[3, 4, 5, 6, 7, 8, 9, 10]</span><span id="a9b0" class="nw na it nu b gy oq on l oo op"><strong class="nu iu">IN:<br/></strong>range(7,34,3)<br/><strong class="nu iu">OUT:<br/></strong>[7, 10, 13, 16, 19, 22, 25, 28, 31]</span></pre><p id="760f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们快速解释一下这是干什么的:</p><ol class=""><li id="17f5" class="me mf it lb b lc ld lf lg li mg lm mh lq mi lu ow mk ml mm bi translated"><code class="fe nr ns nt nu b">Array.from()</code>接受一个数组和一个映射函数，并将该函数应用于一个类似数组或可迭代对象的每个元素，想想 Python 中的<code class="fe nr ns nt nu b">[func(idx,val) for (idx,val) in enumerate(arr)]</code>。我们给每个值加上最小值，现在有了一个从最小值到最大值的列表。注意，除了<code class="fe nr ns nt nu b">new Array(max-min)</code>，我们还可以使用之前使用的函数(<code class="fe nr ns nt nu b">[...Array(max-min).keys()]</code>)，但是正如我提到的，我发现语法有点奇怪。</li><li id="f18c" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu ow mk ml mm bi translated"><code class="fe nr ns nt nu b">arr.filter()</code>过滤我们的数组，使得结果数组只包含符合过滤标准的元素。在我们的例子中,<code class="fe nr ns nt nu b">idx</code>,即数组模步长中的位置必须是 0(即该数必须是没有余数的整除数)。因此只取每第 n 个元素(其中 n =步长)</li></ol></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="2127" class="mz na it bd nb nc nd ne nf ng nh ni nj jz nk ka nl kc nm kd nn kf no kg np nq bi translated">②列表理解</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/87c3e8904fc12ba6fcbd841f5c520b50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bKl3LpSoTtAUbhch"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">尼克·希利尔在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="d1f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对我来说，列表理解是 Python 的主要特征之一，也是 Python 编码方式的象征。它们允许去掉 for 循环，这通常会使代码更加易读和简洁。让我们看看一些常见的使用案例。</p><h2 id="3368" class="nw na it bd nb nx ny dn nf nz oa dp nj li ob oc nl lm od oe nn lq of og np oh bi translated">计算机编程语言</h2><p id="37e0" class="pw-post-body-paragraph kz la it lb b lc or ju le lf os jx lh li ot lk ll lm ou lo lp lq ov ls lt lu im bi translated">典型的情况是<strong class="lb iu">从数组中过滤</strong>元素，然后返回一个只包含满足条件的元素的数组(例如，类型检查)。</p><pre class="kj kk kl km gt oi nu oj ok aw ol bi"><span id="8689" class="nw na it nu b gy om on l oo op"><strong class="nu iu">IN:</strong><br/>values = [1,2,3,5,"x",10]<br/>[_ for _ in values if isinstance(_,int)]</span><span id="5982" class="nw na it nu b gy oq on l oo op"><strong class="nu iu">OUT:<br/></strong>[1, 2, 3, 5, 10]</span></pre><p id="64b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个主要用例是<strong class="lb iu">对列表中的每个元素</strong>应用一个函数，返回一个包含更新值的新列表，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">对列表中的每个元素应用一个函数</p></figure><p id="b549" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">额外收获:你甚至可以像这样做嵌套列表理解:</p><pre class="kj kk kl km gt oi nu oj ok aw ol bi"><span id="f7ae" class="nw na it nu b gy om on l oo op"><strong class="nu iu">IN:</strong><br/>matrix = [<br/>  [1, 2], <br/>  [3, 4], <br/>  [5, 6], <br/>  [7, 8]<br/>]</span><span id="338f" class="nw na it nu b gy oq on l oo op">multiply_by_two = [<br/>  [cell * 2 for cell in row] for row in matrix<br/>]</span><span id="7424" class="nw na it nu b gy oq on l oo op"><strong class="nu iu">OUT:<br/></strong>[<br/>  [2 , 4 ], <br/>  [6 , 8 ], <br/>  [10, 12], <br/>  [14, 16]<br/>]</span></pre><h2 id="1885" class="nw na it bd nb nx ny dn nf nz oa dp nj li ob oc nl lm od oe nn lq of og np oh bi translated">Java Script 语言</h2><p id="927f" class="pw-post-body-paragraph kz la it lb b lc or ju le lf os jx lh li ot lk ll lm ou lo lp lq ov ls lt lu im bi translated">pythonic 列表理解语法确实存在于 JavaScript 中，尽管只是在实验版本中。ECMAScript 4 曾讨论过这个问题，但在 ECMAScript 6 中被永久放弃了。他们可能会在未来带回某种形式的一般理解(即适用于所有可重复的作品)。但是现在，箭头函数和<code class="fe nr ns nt nu b"><strong class="lb iu">map, filter and find</strong></code> <strong class="lb iu"> </strong>就可以了。让我们回顾一下前面的例子。我将使用<code class="fe nr ns nt nu b">_</code>作为标记“丢弃变量”的一种方式(因为下划线不会占用太多空间)。让我们从<strong class="lb iu">过滤</strong>开始:</p><pre class="kj kk kl km gt oi nu oj ok aw ol bi"><span id="82e4" class="nw na it nu b gy om on l oo op"><strong class="nu iu">IN:</strong><br/>const values = [1,2,3,5,"x",10]<br/>values.<strong class="nu iu">filter</strong>(_ =&gt; Number.isInteger(_))</span><span id="cb79" class="nw na it nu b gy oq on l oo op"><strong class="nu iu">OUT:<br/></strong>[1, 2, 3, 5, 10]</span></pre><p id="970c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nr ns nt nu b">filter</code>的一个特例是<code class="fe nr ns nt nu b">find</code>，我发现它非常有用。Find 返回匹配条件的第一个元素。</p><pre class="kj kk kl km gt oi nu oj ok aw ol bi"><span id="5e50" class="nw na it nu b gy om on l oo op"><strong class="nu iu">IN:</strong><br/>const values = [1,2,3,5,"x",10]<br/>values.<strong class="nu iu">find</strong>(_ =&gt; _ &gt; 4)</span><span id="3b5d" class="nw na it nu b gy oq on l oo op"><strong class="nu iu">OUT:<br/></strong>5</span></pre><p id="032c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>如果没有元素满足条件:</p><ul class=""><li id="2475" class="me mf it lb b lc ld lf lg li mg lm mh lq mi lu mj mk ml mm bi translated"><code class="fe nr ns nt nu b"><strong class="lb iu">find</strong></code> <strong class="lb iu"> </strong>将返回<code class="fe nr ns nt nu b"><strong class="lb iu">undefined</strong></code><strong class="lb iu"/>(<strong class="lb iu">falsy</strong>T23】value)</li><li id="65b4" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated">而<code class="fe nr ns nt nu b"><strong class="lb iu">filter</strong></code>将返回<code class="fe nr ns nt nu b"><strong class="lb iu">[]</strong></code><strong class="lb iu"/>(<strong class="lb iu">truthy value</strong>)这在 Python 中尤其奇怪，在 Python 中空数组肯定是错误的——我提到过 JavaScript 有时很奇怪吗？)</li></ul><p id="7f56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来是对列表中的每个元素应用函数。通过<code class="fe nr ns nt nu b"><strong class="lb iu">map</strong></code>可以轻松实现该功能。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="ak">对数组中的每个元素应用 JavaScript 函数</strong></p></figure><h1 id="c83b" class="mz na it bd nb nc pa ne nf ng pb ni nj jz pc ka nl kc pd kd nn kf pe kg np nq bi translated">③词典理解</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pf"><img src="../Images/9a56ecafe21811bf07588bf6815556a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xMscsM5j5B0mF2vk"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@claybanks?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">粘土堤</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="7fdd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">比列表理解稍微不常见的是字典理解，我发现它在构建映射对象时非常强大。假设有一个场景，在这个场景中，你有一个列表中的<strong class="lb iu"> lot </strong>个对象，假设所有的对象都有<strong class="lb iu">个唯一的 id</strong>和其他一些数据，如下所示:</p><pre class="kj kk kl km gt oi nu oj ok aw ol bi"><span id="9760" class="nw na it nu b gy om on l oo op">{<br/>  '_id': '850f200c0b8f4b0ea80513e71fad93a0',<br/>  'name': 'qHvbtkRxrj',<br/>  'net_worth': 32000<br/>}</span></pre><p id="cf6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您从数据库中获得了这个列表，并希望进行一些基于 id 的操作。然后你将不得不无数次地遍历这个列表。更简单的方法是将列表转换成哈希表，其中<code class="fe nr ns nt nu b">_id</code>成为键，对象本身成为值。</p><pre class="kj kk kl km gt oi nu oj ok aw ol bi"><span id="990e" class="nw na it nu b gy om on l oo op">hash_table = {<br/>...,<br/>'<strong class="nu iu">850f200c0b8f4b0ea80513e71fad93a0</strong>': {<br/>  '_id': '<strong class="nu iu">850f200c0b8f4b0ea80513e71fad93a0</strong>',<br/>  'name': 'qHvbtkRxrj',<br/>  'net_worth': 32000<br/>},<br/>...<br/>}</span></pre><p id="c7f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，当我们想要改变一个特定条目的净值时，我们可以通过它的 _id 快速查找，改变对象，因为对象的条目是通过引用存储的，因此改变了原始列表。</p><p id="5291" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">巨蟒</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="ak">Python 中的字典理解</strong></p></figure><p id="f670" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，您也可以使用新生成的 hash_table 来快速检索特定 _id 的<code class="fe nr ns nt nu b">net_worth</code>。与一次又一次地查找 _ids 相比，使用散列表带来了巨大的性能提升<strong class="lb iu"> (10⁵) </strong>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/1d366c6a2b3693e6b276eca63a8ddb07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iTDpptlUGxeggLRvB4Xwlg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ph">通过使用哈希表提高因子 1⁰⁵的性能</strong></p></figure><h2 id="f49b" class="nw na it bd nb nx ny dn nf nz oa dp nj li ob oc nl lm od oe nn lq of og np oh bi translated">Java Script 语言</h2><p id="66dd" class="pw-post-body-paragraph kz la it lb b lc or ju le lf os jx lh li ot lk ll lm ou lo lp lq ov ls lt lu im bi translated">JavaScript 中的字典理解比 Python 中的稍微复杂一点，但实现起来仍然相当简单。我们将使用<code class="fe nr ns nt nu b">reduce</code>来达到预期的结果。<code class="fe nr ns nt nu b">Reduce</code>取一个初始值，然后遍历数组中的所有值，不断更新初始值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="ak">JavaScript 中的字典理解</strong></p></figure></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><p id="695b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，你学习了如何在冒险进入一个新的、看似可怕的世界时找回一些工具。</p></div></div>    
</body>
</html>