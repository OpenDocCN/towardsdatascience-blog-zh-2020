<html>
<head>
<title>Predicting vehicle fuel efficiency</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">预测车辆燃油效率</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/predicting-vehicle-fuel-efficiency-c6065479a72f?source=collection_archive---------20-----------------------#2020-09-07">https://towardsdatascience.com/predicting-vehicle-fuel-efficiency-c6065479a72f?source=collection_archive---------20-----------------------#2020-09-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b879" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">比较 XGBoost(使用 GridSearchCV)和 PyTorch 神经网络来拟合回归模型，并根据汽车特征预测里程</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5b8fb98fb445d9f9613132f862e9ef27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oay_8_BSyeQ2LUYz"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">米卡·鲍梅斯特在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="89e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的<a class="ae ky" href="https://medium.com/@rangys3" rel="noopener">以前的帖子</a>关注的是机器学习和神经网络在石油行业数据集中的应用。这些努力让我有信心成功地实现 XGBoost 和人工神经网络，以预测我工作的炼油厂的重大安全隐患。我非常自豪的重大成功！</p><p id="4ba6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了锻炼一些通用性，我想在这个应用程序中使用 PyTorch 和 GridSearchCV，首先想在一个更简单、更小的数据集上进行实践——即来自 UCI 资源库的<a class="ae ky" href="https://archive.ics.uci.edu/ml/datasets/Auto%2BMPG" rel="noopener ugc nofollow" target="_blank"> Auto MPG 数据集。</a></p><p id="824b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和以前一样，我提出了一个分步的方法来确保系统化的应用:</p><p id="4f58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">第一步</strong> =在深入建模之前了解目标和大局。</p><p id="ff94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">步骤 2 </strong> =加载并获得数据的高级洞察</p><p id="a1b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">第三步</strong> =进一步可视化以探索数据。目标:尽早了解最具杠杆作用的特性。</p><p id="00f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">第四步</strong> =建模计划。这里的关键是为训练和测试模型准备好数据。</p><p id="62c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">步骤 5 </strong> =执行建模并评估性能。根据需要完成灵敏度分析</p><p id="458a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第六步 =从工作中得出结论，让最终用户受益</p><p id="67e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是 GitHub repo 中的代码片段和完整代码。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="83fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">第一步</strong>:我们的目标是根据各种特征预测汽车的里程。通过建模工作，我们可以了解是什么使汽车高效，以及如何实现目标里程消耗。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="d93e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">第二步:</strong>将输入数据读入 Python 并使用。describe()，。head()函数获取关键的统计数据和初步的数据。我还想命名列，因为这在原始数据中是不可用的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mc"><img src="../Images/a1c2ab7908ee1f49f6929b14596053c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XpFvZmDXZhV_VXLEf1RxFw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 1:首先看看数据，有一些高层次的见解</p></figure><p id="605a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">高级外卖:</p><ul class=""><li id="b15c" class="md me it lb b lc ld lf lg li mf lm mg lq mh lu mi mj mk ml bi translated">数据集的变量涵盖了很大范围的数字；如果我们使用像 kNN 这样的算法，这表明需要缩放。</li><li id="22b9" class="md me it lb b lc mm lf mn li mo lm mp lq mq lu mi mj mk ml bi translated">似乎我们有连续变量和离散变量的混合，其中一个是非数字的。这表明需要某种编码。</li><li id="7c02" class="md me it lb b lc mm lf mn li mo lm mp lq mq lu mi mj mk ml bi translated">有 398 个条目，平均里程为 23 英里，3 个可能的来源，5 个可能的车型年。</li></ul><p id="f1c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">单独的检查(此处未显示)显示数据集的“马力”特征有 6 个空值。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="2027" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">步骤 3a) </strong>将相关性绘制为 Seaborn 热图</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mr"><img src="../Images/9d6186a767ade056943648736811eb93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*prGX66uMVEki5Kc7eyYSPg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 2:皮尔逊相关系数的 Seaborn 热图</p></figure><p id="638e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上面可以得出什么结论？</p><ul class=""><li id="eb7c" class="md me it lb b lc ld lf lg li mf lm mg lq mh lu mi mj mk ml bi translated">车重和排量与里程负相关最强。很好地符合直觉，大型悍马不是最有效的汽油使用者</li><li id="3691" class="md me it lb b lc mm lf mn li mo lm mp lq mq lu mi mj mk ml bi translated">马力和气缸数也与里程数呈强烈的负相关关系——这也符合快速跑车比轿车需要更多汽油的直觉</li><li id="fcf0" class="md me it lb b lc mm lf mn li mo lm mp lq mq lu mi mj mk ml bi translated">汽车产地和车型年份是分类数字变量，让我们用柱状图来形象化这些变量。</li></ul><p id="07b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出于建模的目的，我将首先使用所有这些特性。然而，如果我想要一个更紧凑的特征集来防止任何潜在的过度拟合，我可以删除气缸/排量/汽车重量(给定高相关系数)。</p><p id="f0bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">步骤 3b) </strong>让我们使用柱状图了解更多关于分类数字特征的信息:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/ee1618896065590b759e9f032d1bc2c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pVmI_UsJl5NL84_nUVyVDg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 3:汽车产地和车型年的直方图</p></figure><p id="8423" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从图 3 直方图得出的结论:原产地 1 的汽车更具代表性，这表明 mpg 结果更适合该原产地——无论原产地可能代表什么，例如制造国。我们注意到车型年份分布在 12 年中，1970、1976、1982 比其他年份更有代表性。</p><p id="8138" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些数字分类变量应该被编码吗？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mt"><img src="../Images/67ff089175d994917d8dcd91c2a819a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jPMnvnvStm2EBvdPzp1P6g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 4:汽车产地和车型年与 mpg 的柱状图</p></figure><p id="a2f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从图 4 柱状图得出的结论:mpg 随着汽车来源数量的增加而略微增加。对于车型年来说，相关性更少，但是现在，<strong class="lb iu"> </strong>我不会对这些变量进行编码。我不介意保留这些特性。</p><p id="1b26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">步骤 3c) </strong>上面的分析让我对因变量(即目标，即我们试图预测的东西)产生了好奇。这是向哪个方向倾斜的吗？下面的图 4 显示了特征的右偏度，表明<strong class="lb iu">我们可能想要对特征数据进行对数转换，以用于建模。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/17bc4058a158ef5061d0e17d30b8a769.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*mDhGFdkdjuXEq9vIDJUr-A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 mpg 的直方图</p></figure><p id="8385" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">步骤 4: </strong>除了做更多的数据准备和为建模创建测试/训练集，我还将设置 GridSearch CV</p><p id="51e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 4a) </strong>输入缺失数据并创建训练和测试集。还要对汽车品牌进行编码，去掉汽车型号——因为后者是无关的细节。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="d3f5" class="na nb it mw b gy nc nd l ne nf"><strong class="mw iu"># The code below one-hot encodes car make and drops car model.</strong></span><span id="0b33" class="na nb it mw b gy ng nd l ne nf">Data['car make'] = Data['car name'] <br/>Data['car make'] = Data['car name'].apply(lambda x: x.split()[0])</span><span id="321e" class="na nb it mw b gy ng nd l ne nf">Data.drop(columns=['car name'],inplace=True)</span><span id="2693" class="na nb it mw b gy ng nd l ne nf">Data = pd.get_dummies(Data,columns=['car make'])</span><span id="66b3" class="na nb it mw b gy ng nd l ne nf"><strong class="mw iu"># Next: creating x and y below</strong></span><span id="fcf4" class="na nb it mw b gy ng nd l ne nf">x_no_log = Data.drop(columns=['mpg'])<br/>y_no_log = Data['mpg']</span><span id="bb7f" class="na nb it mw b gy ng nd l ne nf"><strong class="mw iu"># Imputing missing car horsepower values.</strong></span><span id="11f7" class="na nb it mw b gy ng nd l ne nf">imp = SimpleImputer(missing_values=np.nan,strategy='median')<br/>x_no_log['horsepower'] = imp.fit(x_no_log['horsepower'].values.reshape(-1, 1)).transform(x_no_log['horsepower'].values.reshape(-1, 1))</span></pre><p id="f75b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 4b) </strong>设置 GridSearchCV——这允许我们循环遍历超参数，根据所选评分指标(在我的例子中为均方差)找到最佳组合。GitHub repo 对 RandomForest 进行了类似的操作。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="d1d0" class="na nb it mw b gy nc nd l ne nf">xgb_params = {'nthread':[4], <br/>              'learning_rate': [.03, 0.05, .07], <br/>              'max_depth': [5, 6, 7],<br/>              'min_child_weight': [4],<br/>              'subsample': [0.7],<br/>              'colsample_bytree': [0.7],<br/>              'n_estimators': [500,1000]}</span></pre><p id="c869" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 4c) </strong>设置 PyTorch —下面的代码导入必要的包，用输入维度、隐层节点数和输出节点设置神经网络，然后构建模型。</p><p id="a9b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我还将均方误差声明为优化的损失度量，我将在测试集上评估 XGBoost 和 RandomForest 的性能时使用相同的度量。</p><p id="1e2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，设置 Adam 优化算法来操纵梯度下降函数，如下图 6 所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/6dcd4a41b7b521cc71b94bd9c5518b88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o7-cwOs-QH5_VkBFCSzGvw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 6:使用 PyTorch 的代码摘录</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="f60a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 5) </strong>所有设置完成后，是时候实际运行模型并评估结果了。</p><p id="8b05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 5a) </strong>我将首先使用 GridCV 和之前设置的超参数网格，根据训练集中的性能找到性能最佳的 XGBoost 模型(GitHub repo 中对 RandomForest 进行了类似的练习)。</p><p id="6a78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我将训练创建的 PyTorch 神经网络</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="27a4" class="na nb it mw b gy nc nd l ne nf">gsXGB = GridSearchCV(xgbr, xgb_params, cv = 7, scoring='neg_mean_squared_error', <br/>                     refit=True, n_jobs = 5, verbose=True)<br/>gsXGB.fit(xtrain,ytrain)</span><span id="c3e1" class="na nb it mw b gy ng nd l ne nf">XGB_best = gsXGB.best_estimator_</span><span id="9706" class="na nb it mw b gy ng nd l ne nf">train_error = []<br/>iters = 600</span><span id="53fa" class="na nb it mw b gy ng nd l ne nf">Y_train_t = torch.FloatTensor(ytrain.values).reshape(-1,1) #Converting numpy array to torch tensor</span><span id="4b5f" class="na nb it mw b gy ng nd l ne nf">for i in range(iters):<br/>    X_train_t = torch.FloatTensor(xtrain.values)  <strong class="mw iu"><em class="ni">#Converting numpy array to torch tensor</em></strong><br/>    y_hat = torch_model(X_train_t)<br/>    loss = loss_func(y_hat, Y_train_t)<br/>    loss.backward()<br/>    optimizer.step()<br/>    optimizer.zero_grad()</span></pre><p id="61a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 5c) </strong>模型训练完成后，我现在可以根据测试数据评估性能了。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="948e" class="na nb it mw b gy nc nd l ne nf"><strong class="mw iu"># Evaluating best-performing XGBoost model on testing data<br/></strong>ypred = XGB_best.predict(xtest)<br/>explained_variance_score(ytest,ypred)<br/>mean_absolute_error(ytest,ypred)<br/>mean_squared_error(ytest,ypred,squared=True)</span><span id="fc20" class="na nb it mw b gy ng nd l ne nf"><strong class="mw iu"># Evaluating PyTorch model on testing data</strong><br/>X_test_t = torch.FloatTensor(xtest.values) <strong class="mw iu"><em class="ni">#Converting numpy array to Torch Tensor.</em></strong><br/>ypredict = torch_model(X_test_t)<br/>mean_squared_error(ytest,ypredict.detach().numpy(),squared=True)</span></pre><p id="d5da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过超参数调整得到的 XGBoost 模型的均方误差为<strong class="lb iu"> 0.0117 mpg。</strong>给定原始数据集中 23.5 mpg 的平均值，这可以解释为<strong class="lb iu">99.9%的准确度</strong></p><p id="d2c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">PyTorch 神经网络的均方误差为<strong class="lb iu"> 0.107 mpg </strong>。使用上述方法，这可以转化为 99.5%的<strong class="lb iu">准确度。</strong></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="b5ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们为客户完成了什么？我们有一个模型可以预测各种汽车的燃料里程；我们的客户可以利用这一点来规划达到理想燃油效率水平的汽车。</p><p id="a03e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们还可以告知我们的客户——根据下图 7——体重是预测里程数的最有影响力的变量，其次是加速度。马力、排量、加速度在影响上比较接近。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/09a3029c714ea0c0d626124578800d07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UM3KF5gXN9NfhZK162LVUA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 7:预测里程的特征重要性</p></figure><p id="e1a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这些细节，我们的客户可以计划未来的汽车生产或购买计划。</p><p id="ec75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一如既往，我欢迎任何反馈。</p></div></div>    
</body>
</html>