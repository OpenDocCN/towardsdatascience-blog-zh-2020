<html>
<head>
<title>How to embed your Julia code into Python to speed up performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何将 Julia 代码嵌入 Python 以提高性能</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-embed-your-julia-code-into-python-to-speed-up-performance-e3ff0a94b6e?source=collection_archive---------7-----------------------#2020-09-16">https://towardsdatascience.com/how-to-embed-your-julia-code-into-python-to-speed-up-performance-e3ff0a94b6e?source=collection_archive---------7-----------------------#2020-09-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0265" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用 Julia 作为 Python 包来轻松提升性能。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e7fbdf9c4b2457de0d6ed0c5c461f8da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F1vuFJg5UotXqRKVlUtWrA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">unsplash 的图像</p></figure><h1 id="490b" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">介绍</h1><p id="a0e9" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">这篇博客文章是关于 Python 和 Julia 的合作，主要面向那些想要快速提高运行时性能的 Python 数据科学家，并通过另一种在<a class="ae mm" href="https://julia.mit.edu/" rel="noopener ugc nofollow" target="_blank">大学</a>、<a class="ae mm" href="https://juliacomputing.com/media/2017/09/19/julia-the-ai-language-for-next-150-years.html" rel="noopener ugc nofollow" target="_blank">公司</a>和用户中广受欢迎的编程语言来实现。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mn"><img src="../Images/2a2df5239f0be327ade49b8da989b698.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0pKcyGS7yuOmJmT-VW5Neg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片:Julia Computing(GitHub stars for Julia)</p></figure><p id="3934" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz mq mb mc md mr mf mg mh ms mj mk ml im bi translated">在这篇文章结束时，你将获得:</p><ul class=""><li id="fc87" class="mt mu it ls b lt mo lw mp lz mv md mw mh mx ml my mz na nb bi translated">一个 docker image 环境，也包含 Julia 和 Python</li><li id="2464" class="mt mu it ls b lt nc lw nd lz ne md nf mh ng ml my mz na nb bi translated">Julia 和 Python 在速度上的直接比较。</li><li id="f65a" class="mt mu it ls b lt nc lw nd lz ne md nf mh ng ml my mz na nb bi translated">将 Julia 代码嵌入 Python 的三种不同方法。</li></ul><p id="db3b" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz mq mb mc md mr mf mg mh ms mj mk ml im bi translated">我希望你会发现它内容丰富！</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="f7a2" class="ky kz it bd la lb no ld le lf np lh li jz nq ka lk kc nr kd lm kf ns kg lo lp bi translated">装置</h1><p id="d558" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">为了设置环境，我使用了这个包含 Julia、Python 和 Jupyter 的 docker 映像:</p><blockquote class="nt nu nv"><p id="7fc4" class="lq lr nw ls b lt mo ju lv lw mp jx ly nx mq mb mc ny mr mf mg nz ms mj mk ml im bi translated">【https://hub.docker.com/r/jupyter/datascience-notebook T4】</p></blockquote><p id="c015" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz mq mb mc md mr mf mg mh ms mj mk ml im bi translated">在参考资料部分可以找到码头工人的逐步指南。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="8806" class="ky kz it bd la lb no ld le lf np lh li jz nq ka lk kc nr kd lm kf ns kg lo lp bi translated">Julia 与 Python 在 for 循环上的速度测试</h1><p id="b4d1" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">在我演示如何将 Julia 代码嵌入 Python 以提高性能之前，我想让您相信使用 Julia 是有价值的，并且在使用 for 循环时，它可以比 Python 快得多。<br/>那么，让我们在 Julia 和 Python 中运行一个简单的 for 循环，并比较它们的运行时间:</p><p id="8e57" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz mq mb mc md mr mf mg mh ms mj mk ml im bi translated">在 Python 中:</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="79d8" class="of kz it ob b gy og oh l oi oj">def for_loop(iterations = 100):<br/> <br/>   a = 0<br/>   for i in range(iterations):<br/> <br/>       a = a+1<br/> <br/>   return a</span></pre><p id="8b5b" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz mq mb mc md mr mf mg mh ms mj mk ml im bi translated">大概用了 1 秒。</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="2a4e" class="of kz it ob b gy og oh l oi oj">%%time<br/>res = for_loop(iterations = 10_000_000)<br/>&gt;&gt;&gt; CPU times: user 953 ms, sys: 0 ns, total: 953 ms<br/>&gt;&gt;&gt; Wall time: 951 ms</span></pre><p id="d4ff" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz mq mb mc md mr mf mg mh ms mj mk ml im bi translated">在朱丽亚身上:</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="674a" class="of kz it ob b gy og oh l oi oj">function for_loop(iterations = 100)<br/>    <br/>    a = 0    <br/>    for i in 1:iterations       <br/>        a = a+1<br/>    end        <br/>    return a<br/>end</span></pre><p id="4c7d" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz mq mb mc md mr mf mg mh ms mj mk ml im bi translated">用了 0.000001 秒:</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="fab0" class="of kz it ob b gy og oh l oi oj">@time res = for_loop(10_000_000)<br/>&gt;&gt;&gt; 0.000001 seconds (1 allocation: 16 bytes)</span></pre><p id="54cc" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz mq mb mc md mr mf mg mh ms mj mk ml im bi translated">差别很大！</p><p id="a217" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz mq mb mc md mr mf mg mh ms mj mk ml im bi translated">但这只是一个极端的例子；通常，差异不会<strong class="ls iu">那么</strong>显著。</p><h1 id="7189" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">将 Julia 代码嵌入 Python</h1><p id="5dfb" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">因此，在我们确信这里有一些潜力之后，让我们看看机器学习中 NLP 领域的一个真实例子。我们将挑选一个涉及到 for loop 的任务来使用 Julia 的力量。<br/>我们将使用<strong class="ls iu">词干</strong>任务(不熟悉这个任务的读者可以在这里了解:<a class="ae mm" href="https://en.wikipedia.org/wiki/Stemming%29." rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Stemming)。</a></p><h2 id="3917" class="of kz it bd la ok ol dn le om on dp li lz oo op lk md oq or lm mh os ot lo ou bi translated">数据</h2><p id="785a" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我们将在 NLTK 包中使用来自莎士比亚-哈姆雷特数据集的数据。可以这样访问它:</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="c354" class="of kz it ob b gy og oh l oi oj">from nltk.corpus import gutenberg<br/>data = gutenberg.raw('shakespeare-hamlet.txt')<br/>data = data.replace("\n", " ")<br/>data = data.replace("  ", " ")</span></pre><p id="0dab" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz mq mb mc md mr mf mg mh ms mj mk ml im bi translated">数据看起来是这样的:</p><blockquote class="nt nu nv"><p id="db11" class="lq lr nw ls b lt mo ju lv lw mp jx ly nx mq mb mc ny mr mf mg nz ms mj mk ml im bi translated">”《哈姆雷特的悲剧》由威廉·莎士比亚于 1599 年创作。斯科纳·普里马。进入巴纳德和弗朗西斯科两个世纪。巴纳德。谁在那里？弗兰。不要回答我:站起来，收起你自己的棍子。朗·刘鹗国王弗兰。巴纳德？巴录书他叫弗兰。你小心翼翼地来到你的酒吧。现在是午夜，去睡觉吧，弗兰斯科·弗兰。对于这封信，我非常感谢:天气很冷，我在谷仓里感到很不舒服。豪埃尔你有安静的警卫？弗兰。没有一只老鼠蠢蠢欲动……”</p></blockquote><h2 id="47b9" class="of kz it bd la ok ol dn le om on dp li lz oo op lk md oq or lm mh os ot lo ou bi translated">使用 Python 进行词干分析</h2><p id="b083" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我们还将使用 NLTK 来完成词干部分:</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="a72c" class="of kz it ob b gy og oh l oi oj">import nltk<br/>from nltk.stem import PorterStemmer</span><span id="cd7a" class="of kz it ob b gy ov oh l oi oj">porter = PorterStemmer()</span><span id="d79f" class="of kz it ob b gy ov oh l oi oj">%%time<br/>stem_words = []<br/>nltk_tokens = nltk.word_tokenize(data)<br/>for token in nltk_tokens:    <br/>    new_token = porter.stem(token)<br/>    stem_words.append(new_token)</span><span id="558b" class="of kz it ob b gy ov oh l oi oj">&gt;&gt;&gt; CPU times: user 1.52 s, sys: 0 ns, total: 1.52 s<br/>&gt;&gt;&gt; Wall time: 1.57 s</span></pre><p id="6cff" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz mq mb mc md mr mf mg mh ms mj mk ml im bi translated">我们花了 1.57 秒。</p><h2 id="ccd2" class="of kz it bd la ok ol dn le om on dp li lz oo op lk md oq or lm mh os ot lo ou bi translated">使用 Julia 进行词干分析</h2><p id="6aa1" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">现在是有趣的部分。</p><p id="c678" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz mq mb mc md mr mf mg mh ms mj mk ml im bi translated">将 Julia 代码嵌入 Python 的方法很少，我们将介绍其中的三种:</p><ul class=""><li id="dd54" class="mt mu it ls b lt mo lw mp lz mv md mw mh mx ml my mz na nb bi translated">运行朱莉娅的整个表达式</li><li id="8dde" class="mt mu it ls b lt nc lw nd lz ne md nf mh ng ml my mz na nb bi translated">用“魔法”命令运行 Julia</li><li id="29c2" class="mt mu it ls b lt nc lw nd lz ne md nf mh ng ml my mz na nb bi translated">用脚本运行 Julia</li></ul><p id="bf6b" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz mq mb mc md mr mf mg mh ms mj mk ml im bi translated">首先，我们将导入相关模块:</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="8ce4" class="of kz it ob b gy og oh l oi oj">from julia.api import Julia<br/>jl = Julia(compiled_modules=False)</span><span id="df11" class="of kz it ob b gy ov oh l oi oj">from julia import Main</span><span id="19e4" class="of kz it ob b gy ov oh l oi oj">jl.using("TextAnalysis")</span></pre><p id="672c" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz mq mb mc md mr mf mg mh ms mj mk ml im bi translated">(我们从 Python 和 Julia 导入了相关的包)。</p><h2 id="31d3" class="of kz it bd la ok ol dn le om on dp li lz oo op lk md oq or lm mh os ot lo ou bi translated">运行整个表达式</h2><p id="4e0f" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">让我们运行代码，然后理解这里发生了什么:</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="4a8a" class="of kz it ob b gy og oh l oi oj">%%time</span><span id="be5d" class="of kz it ob b gy ov oh l oi oj">Main.data = data<br/>Main.token_data = jl.eval("tokens_data = TokenDocument(data) ; return(tokens_data)")<br/>stem_list = jl.eval("stem!(tokens_data);stem_tokens_data =  tokens(tokens_data) ; return(stem_tokens_data)")</span><span id="034e" class="of kz it ob b gy ov oh l oi oj">&gt;&gt;&gt; CPU times: user 747 ms, sys: 112 µs, total: 747 ms<br/>&gt;&gt;&gt; Wall time: 741 ms</span></pre><p id="b1bd" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz mq mb mc md mr mf mg mh ms mj mk ml im bi translated">因此，在第一行中，我们将<em class="nw">数据</em>变量存储在<em class="nw">主数据</em>变量中，这样 Julia 就可以读取这个变量。</p><p id="6d89" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz mq mb mc md mr mf mg mh ms mj mk ml im bi translated"><strong class="ls iu"> Main </strong>是我们从 Julia 导入的一个模块。我们在这里使用它来存储 Julia 格式的数据变量，以便稍后使用(当我们调用 TokenDocument(data)时)。<br/>请注意，如果我们没有写那一行(Main.data = data)，Julia 无法识别任何名为‘data’的变量。<br/>接下来，我们对 Julia 中的数据进行标记化，并将其存储在<em class="nw"> Main.token_data 变量中。</em> ( <em class="nw">注</em>:我们要用 return 命令来存储变量)。<br/>然后，我们对标记化的数据进行词干提取，并将其存储在一个常规的 python 列表中。</p><p id="2c6c" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz mq mb mc md mr mf mg mh ms mj mk ml im bi translated">所以，在 Python 中运行 Julia 的表达式，我们需要做的就是使用<em class="nw"> jl.eval </em>函数，用“<em class="nw">连接 Julia 的表达式；</em>"之间，并以<em class="nw">返回</em>命令结束。</p><p id="541b" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz mq mb mc md mr mf mg mh ms mj mk ml im bi translated">我们花了大约 740 毫秒——大约是 Python 的一半时间。</p><h2 id="2ebd" class="of kz it bd la ok ol dn le om on dp li lz oo op lk md oq or lm mh os ot lo ou bi translated">用“魔法”命令运行</h2><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="6ba7" class="of kz it ob b gy og oh l oi oj">%load_ext julia.magic</span></pre><p id="1902" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz mq mb mc md mr mf mg mh ms mj mk ml im bi translated">要使用 magic 命令，我们首先需要加载它。<br/>请注意，此方法仅适用于 Jupyter 笔记本。% %时间</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="a874" class="of kz it ob b gy og oh l oi oj">tokens = %julia TokenDocument($data)<br/>%julia stem!($tokens)<br/>stem_list = %julia tokens($tokens)</span><span id="c0a2" class="of kz it ob b gy ov oh l oi oj">&gt;&gt;&gt; CPU times: user 849 ms, sys: 3.39 ms, total: 852 ms<br/>&gt;&gt;&gt; Wall time: 845 ms</span></pre><p id="05b5" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz mq mb mc md mr mf mg mh ms mj mk ml im bi translated">所以，在我们加载了<em class="nw"> julia.magic，</em>之后，我们运行这三行代码。</p><p id="ed5d" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz mq mb mc md mr mf mg mh ms mj mk ml im bi translated">我们应该注意两件事:</p><ul class=""><li id="2b28" class="mt mu it ls b lt mo lw mp lz mv md mw mh mx ml my mz na nb bi translated">在使用 Julia 的语法之前加上符号<em class="nw"> % </em>。</li><li id="8488" class="mt mu it ls b lt nc lw nd lz ne md nf mh ng ml my mz na nb bi translated">在引用 python 变量之前使用<em class="nw"> $ </em>符号。</li></ul><p id="c222" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz mq mb mc md mr mf mg mh ms mj mk ml im bi translated">像以前一样，我们首先将数据标记化，然后对其进行词干处理，并将其精细地存储为 Python 列表。</p><h2 id="eff2" class="of kz it bd la ok ol dn le om on dp li lz oo op lk md oq or lm mh os ot lo ou bi translated">使用 Julia 脚本运行</h2><p id="3515" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">在这个方法中，我们可以编写一个完整的独立的 Julia 脚本，并从 python 中调用它。</p><p id="7949" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz mq mb mc md mr mf mg mh ms mj mk ml im bi translated">因此，如果我们编写一个名为<em class="nw"> julia_stemming.jl </em>的脚本，并在其中存储这个 julia 函数:</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="159f" class="of kz it ob b gy og oh l oi oj">function stemming_document(document_string)<br/>    <br/>    tokens_data = TokenDocument(document_string)<br/>    stem!(tokens_data)<br/>    stem_tokens_data =  tokens(tokens_data)<br/>    <br/>    return stem_tokens_data<br/>end</span></pre><p id="1bab" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz mq mb mc md mr mf mg mh ms mj mk ml im bi translated">我们可以从我们的 Python 脚本/笔记本中调用这个函数:</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="68f6" class="of kz it ob b gy og oh l oi oj">%%time</span><span id="365c" class="of kz it ob b gy ov oh l oi oj">jl.eval('include("julia_stemming.jl")')<br/>Main.data = data<br/>stem_list = jl.eval("stemming_document(data)")</span><span id="4d58" class="of kz it ob b gy ov oh l oi oj">&gt;&gt;&gt; CPU times: user 602 ms, sys: 3.24 ms, total: 606 ms<br/>&gt;&gt;&gt; Wall time: 602 ms</span></pre><p id="d8e7" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz mq mb mc md mr mf mg mh ms mj mk ml im bi translated">首先，我们<em class="nw">包含</em>这个脚本以使它可用，然后我们调用其中的函数。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="786f" class="ky kz it bd la lb no ld le lf np lh li jz nq ka lk kc nr kd lm kf ns kg lo lp bi translated">最终速度测试</h1><p id="27ae" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我们展示了对于这个特定的数据集(<em class="nw"> shakespeare-hamlet.txt </em>)，Julia 比 Python 快两倍多。但是当我们使用更大的数据集时会发生什么呢？</p><p id="63b8" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz mq mb mc md mr mf mg mh ms mj mk ml im bi translated">我们使用不同的数据集长度(复制我们的原始数据集)多次执行词干函数，并绘制结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/84eeb03f4b6b6b648f290214ece40b93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/format:webp/1*bgf5XP4z0m-1GIFeLISQSA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="47b5" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz mq mb mc md mr mf mg mh ms mj mk ml im bi translated">如您所见，数据集越大，运行时间之间的差异就越显著——这使得 Julia 在处理大型数据集和 for 循环时非常有用。</p><p id="3c27" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz mq mb mc md mr mf mg mh ms mj mk ml im bi translated">我们用这个代码来计算差异:</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="6b7f" class="of kz it ob b gy og oh l oi oj">time_list_python = []<br/>time_list_julia = []<br/>dataset_length = []</span><span id="fc6a" class="of kz it ob b gy ov oh l oi oj">duplicates_list = [1,2,5,10]<br/>for t in duplicates_list:<br/>    data_repeat = ' '.join([data] * t)<br/>    dataset_length.append(len(data_repeat))<br/>    <br/>    time_start_python = time.perf_counter()<br/>    <br/>    stemming_python(data_repeat)<br/>        <br/>    time_end_python = time.perf_counter()</span><span id="573b" class="of kz it ob b gy ov oh l oi oj">query_time_python = time_end_python - time_start_python<br/>    time_list_python.append(query_time_python)<br/>    <br/>    <br/>    time_start_julia = time.perf_counter()<br/>    <br/>    Main.data_repeat = data_repeat<br/>    jl.eval("stemming_document(data_repeat)")<br/>        <br/>    time_end_julia = time.perf_counter()</span><span id="d4e8" class="of kz it ob b gy ov oh l oi oj">query_time_julia = time_end_julia - time_start_julia<br/>    time_list_julia.append(query_time_julia)</span></pre><p id="45ec" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz mq mb mc md mr mf mg mh ms mj mk ml im bi translated">这段代码用来绘制:</p><pre class="kj kk kl km gt oa ob oc od aw oe bi"><span id="e5bf" class="of kz it ob b gy og oh l oi oj">import pandas as pd<br/>import matplotlib.pyplot as plt</span><span id="abe2" class="of kz it ob b gy ov oh l oi oj">df = pd.DataFrame({"running_time_python" : time_list_python,<br/>                   "running_time_julia" :  time_list_julia,<br/>                   "dataset_length" : dataset_length})<br/>df.set_index("dataset_length", inplace=True)</span><span id="d509" class="of kz it ob b gy ov oh l oi oj">df.plot(figsize = (10,6), title = "Python vs Julia running time comparison")<br/>plt.ylabel('seconds', fontsize = 20)<br/>plt.xlabel('dataset_length', fontsize = 20)<br/>plt.show()</span></pre></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="d56e" class="ky kz it bd la lb no ld le lf np lh li jz nq ka lk kc nr kd lm kf ns kg lo lp bi translated">摘要</h1><p id="482f" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我希望我让你相信了将 Julia 和 Python 联系起来的好处。</p><p id="d27b" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz mq mb mc md mr mf mg mh ms mj mk ml im bi translated">据我所见，纯 Python 在多个领域仍然更好——比如处理矢量化计算(比如 NumPy ),所以我们需要确保切换到 Julia 是值得的。</p><p id="9593" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz mq mb mc md mr mf mg mh ms mj mk ml im bi translated">感谢您的阅读，当然，我会很高兴听到您的回应。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="0ee9" class="ky kz it bd la lb no ld le lf np lh li jz nq ka lk kc nr kd lm kf ns kg lo lp bi translated">参考</h1><blockquote class="nt nu nv"><p id="c1b6" class="lq lr nw ls b lt mo ju lv lw mp jx ly nx mq mb mc ny mr mf mg nz ms mj mk ml im bi translated">https://julia.mit.edu/(使用茱莉亚的大学)</p><p id="03a0" class="lq lr nw ls b lt mo ju lv lw mp jx ly nx mq mb mc ny mr mf mg nz ms mj mk ml im bi translated"><a class="ae mm" href="https://juliacomputing.com/media/2017/09/19/julia-the-ai-language-for-next-150-years.html" rel="noopener ugc nofollow" target="_blank">https://julia computing . com/media/2017/09/19/Julia-the-ai-language-for-next-150 years . html</a>(使用 Julia 的公司)</p><p id="5780" class="lq lr nw ls b lt mo ju lv lw mp jx ly nx mq mb mc ny mr mf mg nz ms mj mk ml im bi translated"><a class="ae mm" href="https://juliacomputing.com/blog/2018/12/04/december-newsletter.html" rel="noopener ugc nofollow" target="_blank">https://Julia computing . com/blog/2018/12/04/12 月-newsletter . html</a>(GitHub stars)</p><p id="1f2b" class="lq lr nw ls b lt mo ju lv lw mp jx ly nx mq mb mc ny mr mf mg nz ms mj mk ml im bi translated"><a class="ae mm" href="https://hub.docker.com/r/jupyter/datascience-notebook" rel="noopener ugc nofollow" target="_blank">https://hub.docker.com/r/jupyter/datascience-notebook</a>(我们使用的图片)</p><p id="56fb" class="lq lr nw ls b lt mo ju lv lw mp jx ly nx mq mb mc ny mr mf mg nz ms mj mk ml im bi translated"><a class="ae mm" href="https://dagshub.com/blog/setting-up-data-science-workspace-with-docker/" rel="noopener ugc nofollow" target="_blank">https://dagshub . com/blog/setting-up-data-science-workspace-with-docker/</a>(docker 分步指南)</p><p id="52f6" class="lq lr nw ls b lt mo ju lv lw mp jx ly nx mq mb mc ny mr mf mg nz ms mj mk ml im bi translated"><a class="ae mm" href="https://pyjulia.readthedocs.io/_/downloads/en/latest/pdf/" rel="noopener ugc nofollow" target="_blank">https://pyjulia.readthedocs.io/_/downloads/en/latest/pdf/</a>(py Julia 包文档)</p><p id="e2a9" class="lq lr nw ls b lt mo ju lv lw mp jx ly nx mq mb mc ny mr mf mg nz ms mj mk ml im bi translated"><a class="ae mm" href="https://pyjulia.readthedocs.io/en/latest/usage.html#high-level-interface" rel="noopener ugc nofollow" target="_blank">https://py Julia . readthedocs . io/en/latest/usage . html #高层接口</a> (PyJulia 包文档)</p><p id="2e5c" class="lq lr nw ls b lt mo ju lv lw mp jx ly nx mq mb mc ny mr mf mg nz ms mj mk ml im bi translated"><a class="ae mm" href="https://juliatext.github.io/TextAnalysis.jl/latest/documents/" rel="noopener ugc nofollow" target="_blank">https://Julia Text . github . io/Text analysis . JL/latest/documents/</a>(文本分析包)</p></blockquote></div></div>    
</body>
</html>