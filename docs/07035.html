<html>
<head>
<title>The Best Way to Generate Indices in BigQuery</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 BigQuery 中生成索引的最佳方式</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-best-way-to-generate-indices-in-bigquery-f3a09f71b175?source=collection_archive---------20-----------------------#2020-05-30">https://towardsdatascience.com/the-best-way-to-generate-indices-in-bigquery-f3a09f71b175?source=collection_archive---------20-----------------------#2020-05-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="85a2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">对直方图使用 GENERATE_ARRAY 等等</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/732a6f05f3210df0095af5f6b4199a50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x4Z1vOkwfzMUFrarkbDWzg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">是的，我在截图的时候不小心高亮了 GENERATE_ARRAY，但是它有点工作，不是吗？</p></figure><p id="d0ec" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当您偶然发现在 BigQuery 中创建直方图的第一个任务时，您可能会用一个简单的 GROUP BY 来处理它，类似于:</p><pre class="kj kk kl km gt lu lv lw lx aw ly bi"><span id="c9d3" class="lz ma it lv b gy mb mc l md me">SELECT<br/>    hour,<br/>    COUNT(*) AS num_accesses<br/>FROM<br/>    accesses<br/>GROUP BY<br/>    hour<br/>ORDER BY<br/>    hour</span></pre><p id="d3d7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这很好，它做了一件体面的工作，会让你友好的同事拍拍你的背。但是它没有处理丢失时间的情况。例如，您可能在一天的大部分时间都有访问，但是在凌晨 3 点没有人访问您的站点，对不起。这会在你的直方图上留下一个缺口，这不是很好，是吗？在某些情况下，看起来很傻。</p><p id="7332" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">相反，我们可以使用各种技术来获得额外的一小时，我最喜欢的是结合 UNNEST 和 GENERATE_ARRAY 的和谐组合。</p><p id="3b0e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">总体思路是生成一个包含所有可能值的数组，将该数组转换为行，然后使用这些行作为索引将结果连接到——您说这是初等的！让我们试试这个:</p><pre class="kj kk kl km gt lu lv lw lx aw ly bi"><span id="6dca" class="lz ma it lv b gy mb mc l md me">SELECT * FROM UNNEST(GENERATE_ARRAY(0, 23)) AS hour</span></pre><p id="7ee2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该查询将生成一个包含数字 0、1、…、23 的数组，传递给 UNNEST，UNNEST 获取这些值并将其放入行中，最后标记为 hour。</p><p id="78e7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有了这个索引，我们就可以做一个左连接(我们希望保留索引中的空行，否则一切都是徒劳的)。我们最后的查询看起来像这样:</p><pre class="kj kk kl km gt lu lv lw lx aw ly bi"><span id="02fb" class="lz ma it lv b gy mb mc l md me">WITH index AS (SELECT * FROM UNNEST(GENERATE_ARRAY(0, 23)) AS hour),</span><span id="408a" class="lz ma it lv b gy mf mc l md me">hourly_counts AS (<br/>    SELECT<br/>        hour,<br/>        COUNT(*) AS num_accesses<br/>    FROM<br/>        accesses<br/>    GROUP BY<br/>        hour<br/>    )</span><span id="6679" class="lz ma it lv b gy mf mc l md me">SELECT<br/>   hour,<br/>   COALESCE(num_accesses, 0) AS num_accesses<br/>FROM<br/>    index<br/>    LEFT JOIN hourly_counts USING (hour)<br/>ORDER BY<br/>    hour</span></pre><h2 id="663e" class="lz ma it bd mg mh mi dn mj mk ml dp mm lh mn mo mp ll mq mr ms lp mt mu mv mw bi translated">可变界限</h2><p id="06a9" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">代替我们上面使用的方便的预定义边界，您可能有可变的边界。例如，如果您试图生成一天中访问次数的直方图。同样，您可以尝试应用一个<code class="fe nc nd ne lv b">GROUP BY</code>，但是您不会有丢失的索引。</p><pre class="kj kk kl km gt lu lv lw lx aw ly bi"><span id="9037" class="lz ma it lv b gy mb mc l md me">WITH daily_accesses AS (<br/>    SELECT<br/>        day,<br/>        COUNT(*) AS num_accesses<br/>    FROM<br/>        accesses<br/>    GROUP BY<br/>        day<br/>    )</span><span id="cc06" class="lz ma it lv b gy mf mc l md me">SELECT<br/>    num_accesses,<br/>    COUNT(*) AS num_days<br/>FROM<br/>    daily_accesses<br/>GROUP BY<br/>    num_accesses<br/>ORDER BY<br/>    num_accesses</span></pre><p id="b3e7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不行！因此，让我们再次尝试生成索引，但这次使用可变边界，因为任何给定日期的<code class="fe nc nd ne lv b">num_accesses</code>都是不受约束的。</p><pre class="kj kk kl km gt lu lv lw lx aw ly bi"><span id="f550" class="lz ma it lv b gy mb mc l md me">SELECT<br/>    *<br/>FROM<br/>    UNNEST(GENERATE_ARRAY(<br/>        (SELECT MIN(num_accesses) FROM daily_accesses)mi,<br/>        (SELECT MAX(num_accesses) FROM daily_accesses)ma<br/>        )) AS num_accesses</span></pre><p id="cb8f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从我们的每日访问表中，我们取出了最小值和最大值，分别给出了下限和上限。将所有这些结合在一起，我们得到:</p><pre class="kj kk kl km gt lu lv lw lx aw ly bi"><span id="50c0" class="lz ma it lv b gy mb mc l md me">WITH daily_accesses AS (<br/>    SELECT<br/>        day,<br/>        COUNT(*) AS num_accesses<br/>    FROM<br/>        accesses<br/>    GROUP BY<br/>        day<br/>    ),</span><span id="d65f" class="lz ma it lv b gy mf mc l md me">day_counts AS (<br/>    SELECT<br/>        num_accesses,<br/>        COUNT(*) AS num_days<br/>    FROM<br/>        daily_accesses<br/>    GROUP BY<br/>        num_accesses<br/>    ),</span><span id="43d8" class="lz ma it lv b gy mf mc l md me">index AS (<br/>    SELECT<br/>        *<br/>    FROM<br/>        UNNEST(GENERATE_ARRAY(<br/>            (SELECT MIN(num_accesses) FROM daily_accesses)mi,<br/>            (SELECT MAX(num_accesses) FROM daily_accesses)ma<br/>            )) AS num_accesses<br/>    )</span><span id="e0cd" class="lz ma it lv b gy mf mc l md me">SELECT<br/>    num_accesses,<br/>    COALESCE(num_days, 0) AS num_days<br/>FROM<br/>    index<br/>    LEFT JOIN day_counts USING (num_accesses)<br/>ORDER BY<br/>    num_accesses</span></pre><p id="bb01" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">比上一个例子稍微复杂一点，但是原理是一样的。</p><h2 id="cd29" class="lz ma it bd mg mh mi dn mj mk ml dp mm lh mn mo mp ll mq mr ms lp mt mu mv mw bi translated">日期索引</h2><p id="1a98" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">最后，在数据之旅中，您可能会遇到日期索引。您可以使用 GENERATE_ARRAY 生成一个数字，然后使用 DATE_ADD 之类的东西来获取日期，但是 Bigquery 有一个内置函数 GENERATE_DATE_ARRAY。</p><p id="829e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在考虑一下，如果我们想获得 2020 年网站的日访问量(现在是复习时间！).因为这是充满变数的一年，可能会有几天没有任何访问。</p><p id="6246" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">同样，我们的基本查询:</p><pre class="kj kk kl km gt lu lv lw lx aw ly bi"><span id="a6ea" class="lz ma it lv b gy mb mc l md me">SELECT<br/>    date,<br/>    COUNT(*) AS num_accesses<br/>FROM<br/>    accesses<br/>GROUP BY<br/>    date<br/>ORDER BY<br/>    date</span></pre><p id="5cb6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们创建的索引是这样的:</p><pre class="kj kk kl km gt lu lv lw lx aw ly bi"><span id="392f" class="lz ma it lv b gy mb mc l md me">SELECT * FROM UNNEST(GENERATE_DATE_ARRAY(<br/>    <!-- -->'2020-01-01',<br/>    CURRENT_DATE()<br/>    )) AS date</span></pre><p id="2105" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这将为 2020 年的今天之前的每一天创建一个日期。给出最终的查询。</p><pre class="kj kk kl km gt lu lv lw lx aw ly bi"><span id="a9e8" class="lz ma it lv b gy mb mc l md me">WITH index AS (<br/>    SELECT * FROM UNNEST(GENERATE_DATE_ARRAY(<br/>        <!-- -->'2020-01-01',<br/>        CURRENT_DATE()<br/>        )) AS date<br/>   ),</span><span id="fecf" class="lz ma it lv b gy mf mc l md me">daily_counts AS (<br/>    SELECT<br/>        date,<br/>        COUNT(*) AS num_accesses<br/>    FROM<br/>        accesses<br/>    GROUP BY<br/>        date<br/>    )</span><span id="0eca" class="lz ma it lv b gy mf mc l md me">SELECT<br/>   date,<br/>   COALESCE(num_accesses, 0) AS num_accesses<br/>FROM<br/>    index<br/>    LEFT JOIN daily_counts USING (date)<br/>ORDER BY<br/>    date</span></pre><h2 id="7a02" class="lz ma it bd mg mh mi dn mj mk ml dp mm lh mn mo mp ll mq mr ms lp mt mu mv mw bi translated">间隔</h2><p id="18dc" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">到目前为止，在所有的例子中，我们假设间隔是 1(或 1 天)，但是使用不同的步长是完全合理的，比如每 7 天。为了实现这一点，您可以向 GENERATE 函数传递一个额外的参数，该函数将返回一个调整后的索引。在这种情况下，在如何连接底层数据方面，您需要更加巧妙一些，但是对于坚定的数据鼓吹者来说，这是可以实现的！</p></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><p id="88f1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">希望这种生成索引的简单方法能在下次需要定义良好的索引时帮到你。如往常一样，如果您想了解更多信息，请查看<a class="ae nm" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/array_functions#generate_array" rel="noopener ugc nofollow" target="_blank"> Bigquery 文档</a>。</p><p id="340a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你使用任何其他有趣或方便的方法，请告诉我！</p></div></div>    
</body>
</html>