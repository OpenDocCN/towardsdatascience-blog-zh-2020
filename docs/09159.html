<html>
<head>
<title>Dependencies between DAGs in Apache Airflow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Apache 气流中 Dag 之间的依赖关系</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/dependencies-between-dags-in-apache-airflow-2f5935cde3f0?source=collection_archive---------3-----------------------#2020-07-01">https://towardsdatascience.com/dependencies-between-dags-in-apache-airflow-2f5935cde3f0?source=collection_archive---------3-----------------------#2020-07-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/cce62c77ec39ce7e6908e4e2cb94d005.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3GQKEFzEdmkLY-0AujU1fw.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">仅在两个上游 DAG 成功完成后运行“再见”任务的 DAG。这篇文章解释了如何在 Apache Airflow 中创建这样的 DAG</p></figure><p id="1e94" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在 Apache Airflow 中，我们可以有非常复杂的 Dag，包含几个任务，以及任务之间的依赖关系。</p><p id="5a8a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">但是，如果我们有跨 DAG 的依赖关系，并且我们想创建 DAG 中的 DAG，该怎么办呢？通常，我们会尝试将所有有依赖关系的任务放在同一个 DAG 中。但是有时您不能修改 Dag，并且您可能仍然希望在 Dag 之间添加依赖关系。</p><p id="9dbf" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为此，我们可以使用<em class="la">外部任务传感器</em>。</p><p id="2981" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">该传感器将查找 DAG 和任务的过去执行，并将匹配那些与我们的 DAG 共享相同的<em class="la"> execution_date </em>的 DAG。然而，名字<em class="la"> execution_date </em>可能会引起误解:它不是一个日期，而是一个瞬间。因此，它们之间相互依赖的 Dag 需要在同一时刻运行，或者以恒定的时间量一个接一个地运行。总之，<strong class="ke ir">我们需要在执行日期和时间上保持一致。</strong></p><p id="0762" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们看一个例子。我们有两个上游 DAG，我们希望在前两个 DAG 成功完成后运行另一个 DAG。</p><p id="d5bc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这是第一个 DAG。它只有两个虚拟任务。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="e32e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">第二个上游 DAG 和这个很像，这里就不展示代码了，不过<a class="ae lh" href="https://gist.github.com/iht/85c352f6451ff1c274b6b94a442dadb5" rel="noopener ugc nofollow" target="_blank">你可以看看 Github </a>里的代码。</p><p id="1407" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">重要的一点是两个 DAG 具有相同的计划和开始日期(请参见<a class="ae lh" href="https://gist.github.com/iht/2c9c2c7135cb3fc6d7ccef2fd8fb1bde#file-parent_dag_1-py-L10-L11" rel="noopener ugc nofollow" target="_blank"> DAG 1 </a>和<a class="ae lh" href="https://gist.github.com/iht/85c352f6451ff1c274b6b94a442dadb5#file-parent_dag_2-py-L10-L11" rel="noopener ugc nofollow" target="_blank"> DAG 2 </a>中的相应行)。请注意，dag 每分钟都在运行。那只是为了这个演示。在真实环境中，这将是一个非常高的频率，所以如果您为自己的 Dag 复制粘贴一些代码，请小心。</p><p id="60fc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当两个上游 DAG 都成功时，将执行下游 DAG。这是下游 DAG 的代码:</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="7b0e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一些需要注意的要点。<a class="ae lh" href="https://gist.github.com/iht/bbb81c28e6139a1d9b9a5074274ab946#file-child_master_dag-py-L10-L11" rel="noopener ugc nofollow" target="_blank">计划和开始日期与上游 Dag</a>相同。<strong class="ke ir">这对于该 DAG 响应上游 DAG 是至关重要的，即，在上游 DAG 的运行和该 DAG 的运行之间添加依赖性。</strong></p><p id="79c1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果执行日期不匹配，但我仍然想添加一个依赖项，该怎么办？如果开始日期相差固定的时间量，您可以使用<em class="la">外部任务传感器</em>的执行<em class="la"> _delta </em>参数。更多详情，<a class="ae lh" href="https://airflow.apache.org/docs/stable/_api/airflow/sensors/external_task_sensor/index.html#airflow.sensors.external_task_sensor.ExternalTaskSensor" rel="noopener ugc nofollow" target="_blank">查看 ExternalTaskSensor </a>的文档。</p><p id="c736" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Airflow 的文档包括一篇关于跨 DAG 依赖的文章:<a class="ae lh" href="https://airflow.apache.org/docs/stable/howto/operator/external.html" rel="noopener ugc nofollow" target="_blank">https://air flow . Apache . org/docs/stable/how to/operator/external . html</a></p></div><div class="ab cl li lj hu lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ij ik il im in"><p id="1453" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果我想根据前面 Dag 的结果在不同的下游 Dag 上进行分支，该怎么办？为此，您可以使用分支操作符和 XCOM 在 Dag 之间传递值。</p><p id="2f7d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="la"> ExternalTaskSensor </em>将仅接收与“感应到的”DAG 相对应的成功或失败状态，但不接收任何输出值。如果需要根据任务中计算出的值进行分支，可以使用<em class="la">branch python operator</em>(<a class="ae lh" href="https://airflow.apache.org/docs/stable/concepts.html#branching" rel="noopener ugc nofollow" target="_blank">https://air flow . Apache . org/docs/stable/concepts . html # branch</a></p><p id="3cfb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">上游 DAG 必须在 XCOM 中发布值，下游 DAG 需要向分支操作符提供回调函数。这个回调函数将使用上游的<em class="la"> task_id </em>读取 XCOM，然后它将返回这个任务之后要继续执行的任务的<em class="la"> id </em>(在分支操作符之后的下游要执行的潜在任务列表中)——我将在以后的文章中用代码片段介绍这个例子！</p></div><div class="ab cl li lj hu lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ij ik il im in"><p id="bc4c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当您无法修改现有 Dag 时，这并不意味着您无法在这些 Dag 之间创建依赖关系。这篇文章展示了如何创建这些依赖关系，即使您不控制上游 DAG:添加一个依赖于使用<em class="la"> ExternalTaskSensor </em>的新 DAG(每个上游 DAG 一个传感器)，将 DAG 之间的依赖关系编码为传感器任务之间的依赖关系，在与上游 DAG 相同的时间表中运行编码依赖关系的 DAG，如果 DAG 的时间表移动了恒定的时间量，则使用<a class="ae lh" href="https://airflow.apache.org/docs/stable/_api/airflow/sensors/external_task_sensor/index.html#airflow.sensors.external_task_sensor.ExternalTaskSensor" rel="noopener ugc nofollow" target="_blank">相应的<em class="la"> execution_delta </em> </a>配置传感器。</p></div></div>    
</body>
</html>