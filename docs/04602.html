<html>
<head>
<title>Python Stack Frames and Tail-Call Optimization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python堆栈框架和尾部调用优化</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-stack-frames-and-tail-call-optimization-4d0ea55b0542?source=collection_archive---------10-----------------------#2020-04-24">https://towardsdatascience.com/python-stack-frames-and-tail-call-optimization-4d0ea55b0542?source=collection_archive---------10-----------------------#2020-04-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4675" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用尾递归避免Python中的堆栈溢出</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/00a0a882ad91f782eb7f439a4603bde4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Vy9CAyZ1h8heOlRK4t3wQ.jpeg"/></div></div></figure><p id="5881" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">计算机科学中的递归是一种解决问题的方法，在这种方法中，函数从自己的代码中调用自己。这种方法非常有用，可以应用于许多类型的问题，但是，它有一个限制。函数使用堆栈来保存它们的局部变量，堆栈的大小是有限的。因此，如果递归太深，最终会耗尽堆栈空间，这被称为堆栈溢出。然而，一些编译器实现了<a class="ae lq" href="https://en.wikipedia.org/wiki/Tail-call_optimization" rel="noopener ugc nofollow" target="_blank">尾调用优化</a>，允许无限递归发生而不会出现堆栈溢出。在本文中，我将首先讨论Python堆栈框架，然后解释尾调用优化的概念，并向您展示如何在Python中实现它。</p><p id="2f39" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">堆叠帧</strong></p><p id="d189" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">堆栈是一种采用LIFO(后进先出)顺序的数据结构，它有两个主要操作:</p><ul class=""><li id="b8d9" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated"><em class="ma"> push:将一个元素添加到堆栈中</em></li><li id="4965" class="lr ls it kw b kx mb la mc ld md lh me ll mf lp lw lx ly lz bi translated"><em class="ma">弹出:删除最近添加的元素</em></li></ul><p id="2f89" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，添加或推入堆栈的最后一个元素是要移除或弹出的第一个元素。使用堆栈存储数据的优点是内存是为您管理的。从堆栈中读取和写入非常快，但是堆栈的大小是有限的。Python解释器使用调用栈来运行Python程序。当在Python中调用一个函数时，一个新的<em class="ma">帧</em>被推送到调用栈上用于它的本地执行，并且每次函数调用返回时，它的帧被弹出调用栈。程序运行的模块有最底层的框架，称为<em class="ma">全局框架</em>或<em class="ma">模块框架</em>。这些帧保存了函数本地执行所需的数据，即函数参数及其本地变量。</p><p id="a0dd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，考虑以下源代码:</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="626e" class="ml mm it mh b gy mn mo l mp mq"># Listing 1<br/>a = 1<br/>def f(x):<br/>    b = 2<br/>    return b+x<br/>y = f(a)<br/>print(y)</span></pre><p id="3683" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">运行该程序的模块在调用堆栈中有一个最底层的框架，即模块框架。全局变量<code class="fe mr ms mt mh b">a</code>存储在该帧中。当我们调用<code class="fe mr ms mt mh b">f(a)</code>时，<code class="fe mr ms mt mh b">f</code>的一个新框架被推到调用栈顶，并且<code class="fe mr ms mt mh b">f</code>的参数和它的局部变量<code class="fe mr ms mt mh b">b</code>被存储在那里。当<code class="fe mr ms mt mh b">f</code>返回它的值时，这个帧被弹出调用堆栈(图1)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/53222774161fa80471111220498f6c3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*weLqZwbCdAKuE-2ItbenUA.png"/></div></div><p class="mv mw gj gh gi mx my bd b be z dk translated">图1</p></figure><p id="5b28" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在Python中，可以很容易地访问这些帧。Python将调用栈中每个帧的所有信息存储在一个frame对象中。frame对象包含帧地址、它所属文件的名称、源代码中访问该帧的行号以及它所属函数的名称。我们可以使用<code class="fe mr ms mt mh b">inspect</code>模块来检查帧。</p><p id="70d9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以使用<code class="fe mr ms mt mh b">inspect.<strong class="kw iu">stack(context=1)</strong></code>来获取当前存在于调用堆栈中的所有帧。可选参数<code class="fe mr ms mt mh b">context</code>指定要返回的<em class="ma">代码</em> <em class="ma">上下文</em>的行数，其中一些是源代码中以<em class="ma">当前行</em>为中心的代码行。当前行<em class="ma"> </em>是源代码中访问或检查该帧的行，<em class="ma">当前行号</em>是源代码中该行的编号。当程序执行时，调用栈中的帧是动态变化的，知道栈在哪一行被检查是很重要的。功能:</p><p id="0573" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mr ms mt mh b">inspect.<strong class="kw iu">stack(context=1)</strong></code></p><p id="2a62" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">返回名为元组的<a class="ae lq" href="https://docs.python.org/3/glossary.html#term-named-tuple" rel="noopener ugc nofollow" target="_blank">列表:</a></p><p id="8664" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mr ms mt mh b">FrameInfo(frame, filename, lineno, function, code_context, index)</code></p><p id="1ff2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">其中<code class="fe mr ms mt mh b">frame</code>是框架对象，<code class="fe mr ms mt mh b">filename</code>是该框架所属文件的名称，<code class="fe mr ms mt mh b">lineo</code>是源代码中的当前行号，<code class="fe mr ms mt mh b">function</code>是该框架所属函数的名称，<code class="fe mr ms mt mh b">code_context</code>是源代码中上下文行的列表，<code class="fe mr ms mt mh b">index</code>是该列表中当前行的索引。</p><p id="dc15" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们来试试这个函数。如果你跑步:</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="ce15" class="ml mm it mh b gy mn mo l mp mq">&gt;&gt;&gt;import inspect<br/>&gt;&gt;&gt;inspect.stack()</span></pre><p id="dbb8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在Python控制台中，您将获得:</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="c889" class="ml mm it mh b gy mn mo l mp mq">[FrameInfo(frame=&lt;frame at 0x000001A97248EAD8, file ‘&lt;stdin&gt;’, line 1, code &lt;module&gt;&gt;, filename=’&lt;stdin&gt;’, lineno=1, function=’&lt;module&gt;’, code_context=None, index=None)]</span></pre><p id="14fa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以返回的列表只有一个名为tuple的<code class="fe mr ms mt mh b">FrameInfo</code>元素。因为我们在模块级，所以我们在调用栈上只有模块级，并且这个列表只有一个元素对应于模块框架。元组的第一个元素是帧对象:</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="7d01" class="ml mm it mh b gy mn mo l mp mq">&lt;frame at 0x000001A97248EAD8, file ‘&lt;stdin&gt;’, line 1, code &lt;module&gt;&gt;</span></pre><p id="e59f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">帧地址在那里，文件名是<code class="fe mr ms mt mh b">stdin</code>。因为我们只有一行代码，所以该帧是在第1行被访问的，很明显该帧属于<code class="fe mr ms mt mh b">&lt;module&gt;</code>。值得注意的是，如果您从像Anaconda这样的Python平台上运行这段代码，您可能会得到更长的输出。您会注意到在模块框架下有更多的框架，这些是Anaconda自己正在执行的模块，我们不需要担心它们。Python控制台为<code class="fe mr ms mt mh b">code_context</code>返回<code class="fe mr ms mt mh b">None</code>，为<code class="fe mr ms mt mh b">index</code>。要获得它们的值，您应该在终端中将这段代码作为Python脚本运行。例如，您可以在Python脚本中存储以下代码:</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="29a7" class="ml mm it mh b gy mn mo l mp mq">import inspect<br/>print(inspect.stack())</span></pre><p id="8c48" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">并在终端中运行它。输出将是:</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="f2bb" class="ml mm it mh b gy mn mo l mp mq">[FrameInfo(frame=&lt;frame at 0x000002A7EEBFE9F8, file ‘t1.py’, line 2, code &lt;module&gt;&gt;, filename=’t1.py’, lineno=2, function=’&lt;module&gt;’, code_context=[‘print(inspect.stack())\n’], index=0)]</span></pre><p id="8bd2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于<code class="fe mr ms mt mh b">stack()</code>中参数<code class="fe mr ms mt mh b">context</code>的默认值是1，所以只显示检查该帧的代码行及其索引也是<code class="fe mr ms mt mh b">0</code>。</p><p id="d5d2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如前所述，该列表的第一个元素与调用堆栈顶部的当前框架相关。我们可以通过<code class="fe mr ms mt mh b">inspect.stack()[0]</code>访问它。<code class="fe mr ms mt mh b">Inspect</code>模块也为此提供了特定的功能:</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="3326" class="ml mm it mh b gy mn mo l mp mq">inspect.<strong class="mh iu">currentframe</strong>()</span></pre><p id="fe10" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它给出了列表中第一个元素(当前帧)的frame对象。所以相当于<code class="fe mr ms mt mh b">inspect.stack()[0][0]</code>。</p><p id="0fc5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在让我们在清单1的源代码中尝试这个函数:</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="5038" class="ml mm it mh b gy mn mo l mp mq"># Listing 2<br/>import inspect<br/>a = 1<br/>print(inspect.stack()[0], "\n")<br/>def f(x):<br/>    b=2<br/>    print(inspect.stack()[0:2], "\n")<br/>    return x+b<br/>y = f(a)<br/>print(inspect.stack(3)[0])<br/>print(y)</span></pre><p id="e8bd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">输出将是:</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="d8c2" class="ml mm it mh b gy mn mo l mp mq">FrameInfo(frame=&lt;frame at 0x000001FDB52AC908, file '&lt;ipython-input-34-3128af912523&gt;', line 3, code &lt;module&gt;&gt;, filename='&lt;ipython-input-34-3128af912523&gt;', lineno=3, function='&lt;module&gt;', code_context=['print(inspect.stack()[0], "\\n")\n'], index=0) <br/><br/>[FrameInfo(frame=&lt;frame at 0x000001FDB520E1C8, file '&lt;ipython-input-34-3128af912523&gt;', line 6, code f&gt;, filename='&lt;ipython-input-34-3128af912523&gt;', lineno=6, function='f', code_context=['    print(inspect.stack()[0:2], "\\n")\n'], index=0), FrameInfo(frame=&lt;frame at 0x000001FDB50C4938, file '&lt;ipython-input-34-3128af912523&gt;', line 8, code &lt;module&gt;&gt;, filename='&lt;ipython-input-34-3128af912523&gt;', lineno=8, function='&lt;module&gt;', code_context=['y = f(a)\n'], index=0)] <br/><br/>FrameInfo(frame=&lt;frame at 0x000001FDB52AFD88, file '&lt;ipython-input-34-3128af912523&gt;', line 9, code &lt;module&gt;&gt;, filename='&lt;ipython-input-34-3128af912523&gt;', lineno=9, function='&lt;module&gt;', code_context=['y = f(a)\n', 'print(inspect.stack(3)[0])\n', 'print(y)\n'], index=1)<br/>3</span></pre><p id="11cc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最初，我们在模块级添加了<code class="fe mr ms mt mh b">inspect.stack()[0]</code>(因为我在Anaconda中运行它，所以我只获得了返回列表的一部分，没有显示模块框架下的Anaconda框架)。<code class="fe mr ms mt mh b">inspect.stack()</code>返回的列表头显示当前帧的<code class="fe mr ms mt mh b">FrameInfo</code>元组，当前帧是模块帧。</p><p id="3372" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，我们在函数<code class="fe mr ms mt mh b">f</code>中添加了<code class="fe mr ms mt mh b">print(inspect.stack()[0:2], "\n")</code>。当<code class="fe mr ms mt mh b">f</code>被调用时，<code class="fe mr ms mt mh b">f</code>的一个新框架被推到模块框架的顶部，因此显示在列表顶部的当前框架对应于该功能:</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="4127" class="ml mm it mh b gy mn mo l mp mq">[FrameInfo(frame=&lt;frame at 0x00000240610678E0, file '&lt;ipython-input-237-6d513e166f46&gt;', line 7, code f&gt;, filename='&lt;ipython-input-237-6d513e166f46&gt;', lineno=7, function='f', code_context=['    print(inspect.stack()[0:2], "\\n")\n'], index=0), </span><span id="0afb" class="ml mm it mh b gy mz mo l mp mq">FrameInfo(frame=&lt;frame at 0x00000240610B2378, file '&lt;ipython-input-237-6d513e166f46&gt;', line 9, code &lt;module&gt;&gt;, filename='&lt;ipython-input-237-6d513e166f46&gt;', lineno=9, function='&lt;module&gt;', code_context=['y = f(a)\n'], index=0)]</span></pre><p id="dc5c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">框架对象和<code class="fe mr ms mt mh b">FrameInfo</code>都显示<code class="fe mr ms mt mh b">f</code>的名称。这个框架下面是模块框架，所以它是列表的下一个元素。</p><p id="24bc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，我们放置<code class="fe mr ms mt mh b">print(inspect.stack(3)[0])</code>以在调用函数后获取当前帧的<code class="fe mr ms mt mh b">FrameInfo</code>。现在函数框架从调用堆栈中弹出，所以当前框架又是模块框架。这里我们用了<code class="fe mr ms mt mh b">stack()</code>中的<code class="fe mr ms mt mh b">context=3</code>。所以输出是:</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="7c73" class="ml mm it mh b gy mn mo l mp mq">FrameInfo(frame=&lt;frame at 0x000002405E787678, file '&lt;ipython-input-237-6d513e166f46&gt;', line 10, code &lt;module&gt;&gt;, filename='&lt;ipython-input-237-6d513e166f46&gt;', lineno=10, function='&lt;module&gt;', code_context=['y = f(a)\n', 'print(inspect.stack(3)[0])\n', 'print(y)\n'], index=1)</span></pre><p id="9587" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们有3行代码用于代码上下文，带有<code class="fe mr ms mt mh b">index=1</code>的中间一行是检查当前帧的代码。</p><p id="7d9b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">框架对象属性</strong></p><p id="dece" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">框架对象有一些有用的属性，这里我们只讨论其中的一部分(你可以查看<code class="fe mr ms mt mh b"><a class="ae lq" href="https://docs.python.org/3/library/inspect.html" rel="noopener ugc nofollow" target="_blank">inspect</a></code> <a class="ae lq" href="https://docs.python.org/3/library/inspect.html" rel="noopener ugc nofollow" target="_blank">模块网页</a>查看全部):</p><p id="9416" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mr ms mt mh b">f_back</code>:这个属性给出了下一个外部框架对象(它是这个框架的调用者，在调用堆栈中位于它的下面)</p><p id="7549" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mr ms mt mh b">f_code</code>:该帧中正在执行的代码对象</p><p id="23fc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mr ms mt mh b">f_locals</code>:这个框架看到的本地命名空间。它是一个字典，给出了这个框架中存在的所有局部变量的名称和值。这包括该帧所属的函数的自变量)。如果这是模块框架，那么所有的全局变量都将包含在内。</p><p id="9e94" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，如果我们将清单2改为:</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="90a6" class="ml mm it mh b gy mn mo l mp mq"># Listing 3<br/>a = 1<br/>def f(x):<br/>    b=2<br/>    print(inspect.currentframe().f_code, "\n")<br/>    print(inspect.currentframe().f_back, "\n")<br/>    print(inspect.currentframe().f_locals)<br/>    return x+b<br/>y = f(a)</span></pre><p id="08e1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们得到:</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="452d" class="ml mm it mh b gy mn mo l mp mq">&lt;code object f at 0x00000240610A4D20, file "&lt;ipython-input-236-6a2fc4ce42af&gt;", line 3&gt; <br/><br/>&lt;frame at 0x000002405E556C28, file '&lt;ipython-input-236-6a2fc4ce42af&gt;', line 9, code &lt;module&gt;&gt; <br/><br/>{'x': 1, 'b': 2}</span></pre><p id="b8ca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以<code class="fe mr ms mt mh b">f_code</code>返回<code class="fe mr ms mt mh b">f</code>的代码对象，<code class="fe mr ms mt mh b">f_back</code>返回它的调用方框架，也就是模块框架。最后，<code class="fe mr ms mt mh b">f_locals</code>返回一个字典，其中包含函数的参数(<code class="fe mr ms mt mh b">x</code>)及其本地值<code class="fe mr ms mt mh b">b</code>以及它们在帧被检查时的值。</p><p id="7fa5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在使用这些属性，我将定义一个新的函数<code class="fe mr ms mt mh b">print_frames</code>来打印帧的局部范围:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="939f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该函数获取<code class="fe mr ms mt mh b">FrameInfo</code>元组列表(由<code class="fe mr ms mt mh b">inspect.stack()</code>返回)并打印当前帧及其下所有帧的局部范围，直到它到达模块帧，我们将使用该函数在接下来的部分中检查这些帧。下面是使用该函数的一个示例:</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="c2a0" class="ml mm it mh b gy mn mo l mp mq"># Listing 4<br/>a = 1<br/>def f(x):<br/>    b=2<br/>    print_frames(inspect.stack())<br/>    return b*x<br/>def g(x):<br/>    return 2*f(x)<br/>y = g(a)</span><span id="5771" class="ml mm it mh b gy mz mo l mp mq">------------------------------------------------------------<br/>Output:<br/>  [Frame 2 'f': {'x': 1, 'b': 2}]<br/>  [Frame 1 'g': {'x': 1}]<br/>  [Frame '&lt;module&gt;']</span></pre><p id="1efe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如你所见，当<code class="fe mr ms mt mh b">g</code>调用<code class="fe mr ms mt mh b">f</code>时，当前帧属于<code class="fe mr ms mt mh b">f</code>，而<code class="fe mr ms mt mh b">g</code>和<code class="fe mr ms mt mh b">module</code>的帧在它的下面。</p><p id="1e87" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">在闭包中堆叠框架</strong></p><p id="bfa5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如清单4所示，当一个函数调用另一个函数时，它的框架保持在被调用函数的框架之下。对于闭包来说，这是不正确的。闭包是由外部函数返回的内部函数。它还有一个扩展的范围，包含了外部函数的非局部变量(你可以参考这篇<a class="ae lq" rel="noopener" target="_blank" href="/closures-and-decorators-in-python-2551abbc6eb6">文章</a>来了解更多关于闭包的知识)。所以当一个闭包被调用时，调用者函数的框架已经从调用栈中弹出。让我给你举个例子:</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="0bbf" class="ml mm it mh b gy mn mo l mp mq"># Listing 5<br/>def f(x):<br/>    def g(y):<br/>        def h(z):<br/>            print_frames(inspect.stack())<br/>            return x+z<br/>        print_frames(inspect.stack())<br/>        return h<br/>    print_frames(inspect.stack())<br/>    return g</span></pre><p id="93e2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里我们在<code class="fe mr ms mt mh b">f</code>中有两个闭包定义。现在如果我们写:</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="abdd" class="ml mm it mh b gy mn mo l mp mq">f(1)(2)(3)</span></pre><p id="9b20" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">输出将是:</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="629d" class="ml mm it mh b gy mn mo l mp mq">  [Frame 1 'f': {'g': &lt;function f.&lt;locals&gt;.g at 0x00000240610617B8&gt;, 'x': 1}]<br/>  [Frame '&lt;module&gt;']</span><span id="64cc" class="ml mm it mh b gy mz mo l mp mq"><br/>  [Frame 1 'g': {'y': 2, 'h': &lt;function f.&lt;locals&gt;.g.&lt;locals&gt;.h at 0x00000240610F1158&gt;, 'x': 1}]<br/>  [Frame '&lt;module&gt;']</span><span id="c6f2" class="ml mm it mh b gy mz mo l mp mq"><br/>  [Frame 1 'h': {'z': 3, 'x': 1}]<br/>  [Frame '&lt;module&gt;']</span><span id="4436" class="ml mm it mh b gy mz mo l mp mq">4</span></pre><p id="7aa5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以当<code class="fe mr ms mt mh b">f</code>返回<code class="fe mr ms mt mh b">g</code>时，<code class="fe mr ms mt mh b">f</code>的框架被弹出调用堆栈，而<code class="fe mr ms mt mh b">g</code>的框架被推到<code class="fe mr ms mt mh b">module</code>框架的顶部。<code class="fe mr ms mt mh b">g</code>的框架不仅存储其参数(<code class="fe mr ms mt mh b">y</code>)，还存储<code class="fe mr ms mt mh b">x</code>，它是<code class="fe mr ms mt mh b">f</code>的参数，也是<code class="fe mr ms mt mh b">g</code>的一个非局部变量。类似地，当调用<code class="fe mr ms mt mh b">h</code>时，<code class="fe mr ms mt mh b">g</code>的帧已经被弹出调用堆栈。<code class="fe mr ms mt mh b">h</code>的框架也存储了非局部变量<code class="fe mr ms mt mh b">x</code>。</p><p id="3b8e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">使用系统模块</strong>检查堆栈框架</p><p id="089e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">到目前为止，我们使用了<code class="fe mr ms mt mh b">inspect</code>模块来检查堆栈框架。我们也可以使用<code class="fe mr ms mt mh b">sys</code>模块来做同样的事情。功能:</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="b514" class="ml mm it mh b gy mn mo l mp mq"> <!-- -->sys.<strong class="mh iu">_getframe</strong>(<em class="ma">depth=0</em>)</span></pre><p id="6785" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从调用堆栈返回一个frame对象。如果给定了可选的整数<em class="ma">深度</em>，它将返回堆栈顶部以下许多调用的框架对象。例如，<code class="fe mr ms mt mh b">depth=1</code>返回当前帧下面的下一个外框对象。<em class="ma">深度</em>的默认值为零，它返回位于调用堆栈顶部的当前帧。所以我们可以使用这个函数重写清单3:</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="ec69" class="ml mm it mh b gy mn mo l mp mq"># Listing 6<br/>import sys<br/>a = 1<br/>def f(x):<br/>    b=2<br/>    print(sys._getframe().f_code, "\n")<br/>    print(sys._getframe().f_back, "\n")<br/>    print(sys._getframe().f_locals)<br/>    return x+b<br/>y = f(a)</span></pre><p id="4864" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">并获得与清单3相同的输出。此外，代替<code class="fe mr ms mt mh b">sys._getframe().f_back</code>，我们可以写<code class="fe mr ms mt mh b">sys._getframe(1)</code>来获得下一个外部框架对象。</p><p id="3956" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">递归函数</strong></p><p id="0912" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在递归函数中，函数从自己的代码中调用自己。这里有一个简单的例子。一个数<em class="ma"> n </em>的阶乘可以定义为:</p><p id="0ec2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="ma">阶乘(n) = n × (n-1) × (n-2) × … × 1 </em></p><p id="0382" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以定义一个递归函数来计算阶乘:</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="ddd9" class="ml mm it mh b gy mn mo l mp mq"># Listing 7<br/>def fact(n):<br/>    if n==0:<br/>        return 1<br/>    else:<br/>        return n*fact(n-1)</span></pre><p id="1f20" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">函数<code class="fe mr ms mt mh b">fact(n)</code>通过将<code class="fe mr ms mt mh b">n</code>乘以<code class="fe mr ms mt mh b">n-1</code>的阶乘来计算<code class="fe mr ms mt mh b">n</code>的阶乘。当<code class="fe mr ms mt mh b">n</code>等于1时，它简单地返回1，因此<code class="fe mr ms mt mh b">n=1</code>定义了递归函数的<em class="ma">基本情况</em>。基本情况是返回值，而不进行任何后续的递归调用。</p><p id="56ea" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们可以将<code class="fe mr ms mt mh b">print_frames</code>添加到这个函数中，看看堆栈帧是如何生成的。</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="62b5" class="ml mm it mh b gy mn mo l mp mq"># Listing 8<br/>def fact(n):<br/>    if n==0:<br/>        print("fact({}) called:".format(n))<br/>        print_frames(inspect.stack())<br/>        print("fact({}) returned {}".format(n, 1))<br/>        return 1<br/>    else:<br/>        print("fact({}) called:".format(n))<br/>        print_frames(inspect.stack())<br/>        result = n*fact(n-1)<br/>        print_frames(inspect.stack())<br/>        print("fact({}) returned {}".format(n, result))<br/>        return result</span></pre><p id="e162" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们也想看到函数的返回值，所以先把返回值存储在<code class="fe mr ms mt mh b">result</code>里，打印出来，然后由函数返回。来试试<code class="fe mr ms mt mh b">n=3</code>:</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="9792" class="ml mm it mh b gy mn mo l mp mq">fact(3)<br/>-----------------------------------------------------------------<br/>Output:</span><span id="96fd" class="ml mm it mh b gy mz mo l mp mq">fact(3) called:<br/>  [Frame 1 'fact': {'n': 3}]<br/>  [Frame '&lt;module&gt;']<br/><br/>fact(2) called:<br/>  [Frame 2 'fact': {'n': 2}]<br/>  [Frame 1 'fact': {'n': 3}]<br/>  [Frame '&lt;module&gt;']<br/><br/>fact(1) called:<br/>  [Frame 3 'fact': {'n': 1}]<br/>  [Frame 2 'fact': {'n': 2}]<br/>  [Frame 1 'fact': {'n': 3}]<br/>  [Frame '&lt;module&gt;']<br/><br/>fact(0) called:<br/>  [Frame 4 'fact': {'n': 0}]<br/>  [Frame 3 'fact': {'n': 1}]<br/>  [Frame 2 'fact': {'n': 2}]<br/>  [Frame 1 'fact': {'n': 3}]<br/>  [Frame '&lt;module&gt;']<br/><br/>fact(0) returned 1<br/>  [Frame 3 'fact': {'n': 1, 'result': 1}]<br/>  [Frame 2 'fact': {'n': 2}]<br/>  [Frame 1 'fact': {'n': 3}]<br/>  [Frame '&lt;module&gt;']<br/><br/>fact(1) returned 1<br/>  [Frame 2 'fact': {'n': 2, 'result': 2}]<br/>  [Frame 1 'fact': {'n': 3}]<br/>  [Frame '&lt;module&gt;']<br/><br/>fact(2) returned 2<br/>  [Frame 1 'fact': {'n': 3, 'result': 6}]<br/>  [Frame '&lt;module&gt;']<br/><br/>fact(3) returned 6</span><span id="7aae" class="ml mm it mh b gy mz mo l mp mq">6</span></pre><p id="4988" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如你所见，每次函数调用自己时，<code class="fe mr ms mt mh b">f</code>的一个新帧被推到前面的帧之上，直到它到达递归的底部(<code class="fe mr ms mt mh b">fact(0)</code>)。然后基础用例返回<code class="fe mr ms mt mh b">1</code>，它的框架被弹出调用堆栈。然后<code class="fe mr ms mt mh b">fact(1)</code>返回<code class="fe mr ms mt mh b">1×1</code>，弹出其框架。剩余的<code class="fe mr ms mt mh b">fact</code>帧被逐个弹出，直到<code class="fe mr ms mt mh b">fact(3)</code>返回最终值(<code class="fe mr ms mt mh b">6</code>)并被弹出调用栈。因此很明显，对于<code class="fe mr ms mt mh b">fact(3)</code>,我们将4个框架放在模块框架的顶部，以达到基本情况。一般来说，为了计算<code class="fe mr ms mt mh b">fact(n)</code>，最多会将<code class="fe mr ms mt mh b">n+1</code>帧推到堆栈顶部。但是如果<code class="fe mr ms mt mh b">n</code>变成5000这样的大数字会怎么样呢？</p><p id="36cf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如前所述，调用堆栈的大小是有限的。因此，通过增加<code class="fe mr ms mt mh b">n</code>的值，我们最终达到了调用堆栈的极限，并且不能在此基础上推进更多的帧。这被称为<em class="ma">堆栈溢出</em>，这意味着<em class="ma"> </em>我们用尽了内存来保存调用堆栈中的帧。为了避免堆栈溢出，Python为调用堆栈可以容纳的总帧数设置了限制。限制是999(调用堆栈可以容纳的最大帧数)。现在记住<code class="fe mr ms mt mh b">fact(n)</code>需要<code class="fe mr ms mt mh b">n+1</code>帧。此外，还应包括模块框架。所以，其实我们需要<code class="fe mr ms mt mh b">n+2</code>帧。因此，我们可以使用的<code class="fe mr ms mt mh b">n</code>的最大值是997，需要999帧。现在我们来试试<code class="fe mr ms mt mh b">n=998</code>。如果我们将清单9存储在Python脚本中，并在终端中运行它:</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="f55b" class="ml mm it mh b gy mn mo l mp mq"># Listing 9<br/>def fact(n):<br/>    if n==0:<br/>        return 1<br/>    else:<br/>        return n*fact(n-1)<br/>print(fact(998))</span></pre><p id="59e7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们得到这个错误:</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="1689" class="ml mm it mh b gy mn mo l mp mq">Traceback (most recent call last):<br/>  File "fact.py", line 6, in &lt;module&gt;<br/>    print(fact(998))<br/>  File "fact.py", line 5, in fact<br/>    return n*fact(n-1)<br/>  File "fact.py", line 5, in fact<br/>    return n*fact(n-1)<br/>  File "fact.py", line 5, in fact<br/>    return n*fact(n-1)<br/>  [Previous line repeated 995 more times]<br/>  File "fact.py", line 2, in fact<br/>    if n==0:<br/>RecursionError: maximum recursion depth exceeded in comparison</span></pre><p id="e964" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这意味着我们已经超过了极限。在像Anaconda这样的平台中，您可能对总帧数有更高的限制。比如在我的系统里，是3000。</p><p id="4d50" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您也可以更改此限制，以便拥有更多帧。功能:</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="4d43" class="ml mm it mh b gy mn mo l mp mq">sys.<strong class="mh iu">getrecursionlimit()</strong></span></pre><p id="43ce" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">给出递归和函数的当前限制</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="e20d" class="ml mm it mh b gy mn mo l mp mq">sys.<strong class="mh iu">setrecursionlimit(limit)</strong> </span></pre><p id="443d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">用于设置调用堆栈可以容纳的最大帧数的限制。</p><p id="f5dc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意，最大递归深度的限制只是防止程序进入堆栈溢出，并不改变调用堆栈的实际大小。所以更改限制应该小心，因为过高的限制会导致Python崩溃。</p><p id="1f81" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另一个解决方案是减少递归函数需要推送的帧数，并使其表现得像非递归函数一样。这样，函数永远不会达到那个极限，无论输入数据有多大，都不会出现堆栈溢出。正如您将在下一节中看到的，这可以通过使用尾部递归和尾部调用优化来实现。</p><p id="e1d9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">尾递归</strong></p><p id="143a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当递归调用是函数执行的最后一件事时，递归函数是尾递归的。例如，清单7中的函数<code class="fe mr ms mt mh b">fact(n)</code>不是尾递归的。在这个函数中，递归调用是<code class="fe mr ms mt mh b">fact(n-1)</code>。然而，这并不是这个函数在返回结果之前做的最后一件事。它将<code class="fe mr ms mt mh b">fact(n-1)</code>乘以<code class="fe mr ms mt mh b">n</code>，然后返回结果。所以乘以<code class="fe mr ms mt mh b">n</code>不允许它是尾递归的。</p><p id="1767" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">可以将<code class="fe mr ms mt mh b">fact(n)</code>修改为尾递归。清单10显示了<code class="fe mr ms mt mh b">fact</code>的尾递归版本:</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="a8f3" class="ml mm it mh b gy mn mo l mp mq"># Listing 10<br/>def fact1(n, acc=1):<br/>    if n == 0:<br/>        return acc<br/>    else:<br/>        return fact1(n-1, n*acc) </span><span id="508d" class="ml mm it mh b gy mz mo l mp mq">fact1(4, 1)</span></pre><p id="3105" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个函数有第二个参数<code class="fe mr ms mt mh b">acc</code>，它扮演累加器的角色。当我们调用<code class="fe mr ms mt mh b">fact1</code>时，我们用1初始化它。在<code class="fe mr ms mt mh b">fact1</code>的每次调用中，<code class="fe mr ms mt mh b">n</code>乘以<code class="fe mr ms mt mh b">acc</code>，当到达基例时，只需要返回<code class="fe mr ms mt mh b">acc</code>。现在我们可以将<code class="fe mr ms mt mh b">print_frames</code>添加到这个函数中，看看帧是如何生成的。我们还将返回值存储在<code class="fe mr ms mt mh b">result</code>中，并打印出来以查看函数的返回值。</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="a539" class="ml mm it mh b gy mn mo l mp mq"># Listing 11<br/>def fact1(n, acc=1):<br/>    if n == 0:<br/>        print("fact1({},{}) called:".format(n, acc))<br/>        print_frames(inspect.stack())<br/>        print("fact1({0},{1}) returned {1}".format(n, acc))<br/>        return acc<br/>    else:<br/>        print("fact1({},{}) called:".format(n, acc))<br/>        print_frames(inspect.stack())<br/>        result = fact1(n-1, n*acc) <br/>        print_frames(inspect.stack())<br/>        print("fact1({},{}) returned {}".format(n, acc, result))<br/>        return result</span></pre><p id="4333" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你应该注意到这不是一个真正的尾递归函数，因为递归调用不是函数执行的最后一件事。实际上，在执行递归调用<code class="fe mr ms mt mh b">fact1(n-1, n*acc)</code>后，我们将其返回值赋给<code class="fe mr ms mt mh b">result</code>，然后调用<code class="fe mr ms mt mh b">print_function</code>和<code class="fe mr ms mt mh b">print</code>，最后返回<code class="fe mr ms mt mh b">result</code>。然而，我们只是出于调试的目的添加它们，以展示这个函数是如何工作的，并且我们在递归调用之后不改变<code class="fe mr ms mt mh b">result</code>的值，所以对返回值没有计算。因此，这个函数给出了与清单10中尾递归函数相同的结果。</p><p id="bbb4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，如果我们执行<code class="fe mr ms mt mh b">fact1(3,1)</code>，输出将是:</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="a595" class="ml mm it mh b gy mn mo l mp mq">fact1(3,1) called:<br/>  [Frame 1 'fact1': {'n': 3, 'acc': 1}]<br/>  [Frame '&lt;module&gt;']<br/><br/>fact1(2,3) called:<br/>  [Frame 2 'fact1': {'n': 2, 'acc': 3}]<br/>  [Frame 1 'fact1': {'n': 3, 'acc': 1}]<br/>  [Frame '&lt;module&gt;']<br/><br/>fact1(1,6) called:<br/>  [Frame 3 'fact1': {'n': 1, 'acc': 6}]<br/>  [Frame 2 'fact1': {'n': 2, 'acc': 3}]<br/>  [Frame 1 'fact1': {'n': 3, 'acc': 1}]<br/>  [Frame '&lt;module&gt;']<br/><br/>fact1(0,6) called:<br/>  [Frame 4 'fact1': {'n': 0, 'acc': 6}]<br/>  [Frame 3 'fact1': {'n': 1, 'acc': 6}]<br/>  [Frame 2 'fact1': {'n': 2, 'acc': 3}]<br/>  [Frame 1 'fact1': {'n': 3, 'acc': 1}]<br/>  [Frame '&lt;module&gt;']<br/><br/>fact1(0,6) returned 6<br/>  [Frame 3 'fact1': {'n': 1, 'acc': 6, 'result': 6}]<br/>  [Frame 2 'fact1': {'n': 2, 'acc': 3}]<br/>  [Frame 1 'fact1': {'n': 3, 'acc': 1}]<br/>  [Frame '&lt;module&gt;']<br/><br/>fact1(1,6) returned 6<br/>  [Frame 2 'fact1': {'n': 2, 'acc': 3, 'result': 6}]<br/>  [Frame 1 'fact1': {'n': 3, 'acc': 1}]<br/>  [Frame '&lt;module&gt;']<br/><br/>fact1(2,3) returned 6<br/>  [Frame 1 'fact1': {'n': 3, 'acc': 1, 'result': 6}]<br/>  [Frame '&lt;module&gt;']<br/><br/>fact1(3,1) returned 6</span><span id="344b" class="ml mm it mh b gy mz mo l mp mq">6</span></pre><p id="825b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可以看到，当这个递归函数达到它的基本情况时，<code class="fe mr ms mt mh b">acc</code>等于<em class="ma">阶乘(3) </em>。然后相同的值被返回给调用者函数fact1(1，6)，fac1(2，3) …最后<code class="fe mr ms mt mh b">fact1(3,1)</code>返回<code class="fe mr ms mt mh b">acc</code>作为这个函数的最终结果。所以当它到达基本用例时，它不需要将结果返回给前面的调用方，函数执行可以通过返回<code class="fe mr ms mt mh b">acc</code>来终止。</p><p id="d6b3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这与清单8中的输出<code class="fe mr ms mt mh b">fact(n)</code>完全不同。那个函数不是尾递归的，所以当它到达基本情况(<code class="fe mr ms mt mh b">f(0)</code>)时，它只得到基本情况返回值<code class="fe mr ms mt mh b">1</code>。这个值需要返回给调用者<code class="fe mr ms mt mh b">f(1)</code>乘以1，然后返回给<code class="fe mr ms mt mh b">f(2)</code>乘以2，依此类推。1,2, ...是<code class="fe mr ms mt mh b">f</code>的参数，并且存储在它的框架中，所以当我们想要将这些参数乘以函数的返回值时，我们需要前面的框架能够访问这些参数。</p><p id="5e86" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在尾递归的<code class="fe mr ms mt mh b">fact1</code>中，我们不需要在调用栈中保存之前的帧。我们只需要当前帧，直到我们到达基本情况，然后我们可以终止函数。因此尾递归函数不需要其当前帧下面的帧。然而，正如输出所示，Python仍然像递归函数一样执行它，并保留所有帧。当尾部递归函数调用自身时，我们需要Python丢弃前一帧。</p><p id="fc3f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">尾音优化</strong></p><p id="718b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">尾调用优化是一种允许尾递归函数无限递归而不发生堆栈溢出的方法。尾部调用优化将递归调用转换为循环。递归调用被替换为以下代码:</p><ul class=""><li id="6d06" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated">首先用递归调用的相应参数值替换函数的参数</li><li id="6f6f" class="lr ls it kw b kx mb la mc ld md lh me ll mf lp lw lx ly lz bi translated">跳回到函数的开头。</li></ul><p id="1efc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">尾调用优化只能用于尾递归函数。原因是新代码在递归调用后跳回到函数的开头，并忽略其后的任何语句。</p><p id="d15b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我用一个例子来展示它。假设我们想对清单10中的<code class="fe mr ms mt mh b">fact1</code>函数应用尾调用优化。我们可以使用清单12中的伪代码来实现。</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="997c" class="ml mm it mh b gy mn mo l mp mq"># Listing 12<br/>def fact1(n, acc=1):<br/>    START: <br/>    if n == 0:<br/>        return acc<br/>    else:<br/>        #  return fact1(n-1, n*acc) is replaced with:<br/>        acc = n * acc<br/>        n = n -1<br/>        goto START</span></pre><p id="ed08" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里我们用一个新的代码替换递归调用<code class="fe mr ms mt mh b">fact1(n-1, n*acc)</code>。如果<code class="fe mr ms mt mh b">n</code>不等于零，函数<code class="fe mr ms mt mh b">n</code>和<code class="fe mr ms mt mh b">acc</code>的参数将被替换为递归调用<code class="fe mr ms mt mh b">n-1</code>、<code class="fe mr ms mt mh b">n*acc</code>的相应参数的值，然后跳转到函数的开头。这是一个伪代码，因为Python没有<code class="fe mr ms mt mh b">goto</code>关键字。然而，我们可以使用一个<code class="fe mr ms mt mh b">while</code>循环来实现它:</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="0952" class="ml mm it mh b gy mn mo l mp mq"># Listing 13<br/>def fact2(n, acc=1):<br/>    while True:<br/>        if n == 0:<br/>            return acc<br/>        else:<br/>            acc = n * acc<br/>            n = n - 1</span></pre><p id="0e19" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Python中不支持尾部调用优化，但是我们可以通过更改函数内部的代码来应用它，然而，我们更喜欢使用装饰器自动完成它，而不更改函数的代码。我们可以用两种不同的方法来做这件事，这将在下一节中解释。</p><p id="ed53" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">使用堆栈帧进行尾部调用优化</strong></p><p id="6773" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">第一种方法使用<code class="fe mr ms mt mh b">inspect</code>模块并检查堆栈帧以防止递归和新帧的创建。清单14显示了一个装饰器，它可以将尾调用优化应用到目标尾递归函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="05d6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们可以用<code class="fe mr ms mt mh b">tail_rec</code>来装饰<code class="fe mr ms mt mh b">fact1</code>:</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="09ef" class="ml mm it mh b gy mn mo l mp mq">@tail_rec<br/>def fact1(n, acc=1):<br/>    if n == 0:<br/>        return acc<br/>    else:<br/>        return fact1(n-1, n*acc)<br/>        <br/>fact1(4)</span></pre><p id="f101" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我解释一下这个装饰器是如何工作的。当我们用<code class="fe mr ms mt mh b">tail_rec</code>修饰<code class="fe mr ms mt mh b">fact1</code>时，变量<code class="fe mr ms mt mh b">rec_flag</code>、<code class="fe mr ms mt mh b">targs</code>和<code class="fe mr ms mt mh b">tkwargs</code>被初始化。现在<code class="fe mr ms mt mh b">fact1</code>指的是<code class="fe mr ms mt mh b">helper</code>的定义。所以当我们调用<code class="fe mr ms mt mh b">fact1(4)</code>时，<code class="fe mr ms mt mh b">helper</code>被调用(这里我们称之为第一个<code class="fe mr ms mt mh b">helper</code>)。变量<code class="fe mr ms mt mh b">rec_flag</code>、<code class="fe mr ms mt mh b">targs</code>和<code class="fe mr ms mt mh b">tkwargs</code>是<code class="fe mr ms mt mh b">helper</code>的非局部变量，所以它可以访问它们。<code class="fe mr ms mt mh b">helper</code>首先获取当前帧。然后检查<code class="fe mr ms mt mh b">f.f_code</code>是否等于<code class="fe mr ms mt mh b">f.f_back.f_back.f_code</code>。如前所述，属性<code class="fe mr ms mt mh b">f_code</code>指的是框架中正在执行的代码对象，它指示哪个函数创建了这个框架。所以<code class="fe mr ms mt mh b">f.f_code</code>指的是当前帧的编码对象，也就是<code class="fe mr ms mt mh b">helper</code>的编码对象。另外，<code class="fe mr ms mt mh b">f.f_back.f_back</code>是指比当前帧低两级的帧(当前帧的祖辈)。</p><p id="7843" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最初，<code class="fe mr ms mt mh b">helper</code>的帧在<code class="fe mr ms mt mh b">module</code>帧的上面，<code class="fe mr ms mt mh b">module</code>帧是最下面的帧，所以当前帧的祖辈是<code class="fe mr ms mt mh b">None</code>并且<code class="fe mr ms mt mh b">if</code>块中的测试失败。(在Anaconda这样的平台中，祖父不是<code class="fe mr ms mt mh b">None</code>，但是它的代码对象与<code class="fe mr ms mt mh b">helper</code>不同，所以测试再次失败)。所以它进入<code class="fe mr ms mt mh b">else</code>块并执行<code class="fe mr ms mt mh b">while</code>循环。在<code class="fe mr ms mt mh b">while</code>循环中<code class="fe mr ms mt mh b">func(*args, **kwargs)</code>被调用。<code class="fe mr ms mt mh b">func</code>是指<code class="fe mr ms mt mh b">fact1</code>的定义。所以<code class="fe mr ms mt mh b">fact1(4)</code>被执行，因为它是一个递归函数，它调用<code class="fe mr ms mt mh b">fact1(3, 4)</code>。</p><p id="5224" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是，<code class="fe mr ms mt mh b">fact1</code>是修饰函数，所以引用的是<code class="fe mr ms mt mh b">helper</code>。所以调用<code class="fe mr ms mt mh b">fact1(3, 4)</code>再次执行<code class="fe mr ms mt mh b">helper</code>，如图2所示(我们称之为第二个<code class="fe mr ms mt mh b">helper</code>)。这次当前帧属于第二个<code class="fe mr ms mt mh b">helper</code>，当前帧的祖辈是第一个<code class="fe mr ms mt mh b">helper</code>。因此两个帧具有相同的代码对象(属于相同的函数)并且<code class="fe mr ms mt mh b">if</code>部分中的条件为真。现在，helper的参数存储在非局部变量<code class="fe mr ms mt mh b">targs</code>和<code class="fe mr ms mt mh b">tkwargs</code>中。此外，标志<code class="fe mr ms mt mh b">rec_flag</code>被设置为<code class="fe mr ms mt mh b">True</code>。</p><p id="05b1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">事实上，<code class="fe mr ms mt mh b">if</code>语句通过检查帧的代码对象来检测目标函数中递归的开始。当检测到递归的开始时，应该抑制附加帧的创建。因此，第二个<code class="fe mr ms mt mh b">helper</code>存储递归调用的参数，并更改<code class="fe mr ms mt mh b">rec_flag</code>以通知递归调用的存在，然后返回<code class="fe mr ms mt mh b">None</code>。它的调用者是<code class="fe mr ms mt mh b">fact1</code>,它将同样的内容返回给第一个<code class="fe mr ms mt mh b">helper</code>函数，它的框架也被弹出调用堆栈(图2)。</p><p id="0df0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在第一个<code class="fe mr ms mt mh b">helper</code>中，<code class="fe mr ms mt mh b">if</code>语句的条件为真，所以它将<code class="fe mr ms mt mh b">targs</code>和<code class="fe mr ms mt mh b">tkwargs</code>的值赋给<code class="fe mr ms mt mh b">args</code>和<code class="fe mr ms mt mh b">kwargs</code>。while循环再次调用<code class="fe mr ms mt mh b">func(*aregs, **kwargs)</code>,因此<code class="fe mr ms mt mh b">fact1(3, 4)</code>会用它最后一次递归调用的参数再次被调用。然而，这不是递归调用。事实上，当调用<code class="fe mr ms mt mh b">fact1(3, 4)</code>时，调用堆栈中没有先前的<code class="fe mr ms mt mh b">fact1</code>帧。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/e2d0dede490b1820e2b59ba1d98151df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YnbG0fRM1WFo2K432XUP5A.png"/></div></div><p class="mv mw gj gh gi mx my bd b be z dk translated">图2</p></figure><p id="4d46" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个过程继续下去，每次当<code class="fe mr ms mt mh b">fact1</code>试图递归调用自己时，<code class="fe mr ms mt mh b">helper</code>就把它变成一个具有相同参数的非递归调用。最后，当我们到达基本情况(<code class="fe mr ms mt mh b">n=0</code>)时，将不会有递归调用，<code class="fe mr ms mt mh b">fact1</code>返回存储在<code class="fe mr ms mt mh b">while</code>循环内的<code class="fe mr ms mt mh b">result</code>中的<code class="fe mr ms mt mh b">acc</code>。因为没有递归调用发生，<code class="fe mr ms mt mh b">rec_flag</code>保持<code class="fe mr ms mt mh b">False</code>。当<code class="fe mr ms mt mh b">rec_flag</code>为<code class="fe mr ms mt mh b">Fasle</code>时，执行<code class="fe mr ms mt mh b">else</code>块，<code class="fe mr ms mt mh b">helper</code>返回<code class="fe mr ms mt mh b">result</code>。</p><p id="d7d3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看看如果我们使用一个非尾部递归函数和这个装饰器会发生什么。例如，我们可以使用清单7中的factorial函数:</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="2a83" class="ml mm it mh b gy mn mo l mp mq">@tail_rec<br/>def fact(n):<br/>    if n==0:<br/>        return 1<br/>    else:<br/>        return n*fact(n-1)<br/>print(fact(3))</span></pre><p id="bd27" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您将得到以下异常输出:</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="214c" class="ml mm it mh b gy mn mo l mp mq"><strong class="mh iu">Exception</strong>: It is possible that the decorated function is not tail recursive</span></pre><p id="6c7a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，如果您修饰一个函数，对递归调用的返回值进行一些计算，它可以检测到它。语句<code class="fe mr ms mt mh b">result=func(*args,**kwargs)</code>位于捕获<code class="fe mr ms mt mh b">TypeError</code>异常的<code class="fe mr ms mt mh b">try</code>块内。如果用这个装饰器来装饰一个非尾部递归函数，将会引发一个<code class="fe mr ms mt mh b">TypeError</code>异常。原因是当<code class="fe mr ms mt mh b">helper</code>检测到递归时，它返回<code class="fe mr ms mt mh b">None</code>，所以在<code class="fe mr ms mt mh b">fact</code>的最后一行，<code class="fe mr ms mt mh b">fact(n-1)</code>也返回<code class="fe mr ms mt mh b">None</code>。当该函数试图将<code class="fe mr ms mt mh b">n</code>乘以<code class="fe mr ms mt mh b">None</code>时，会引发<code class="fe mr ms mt mh b">TypeError</code>。当然，有可能在函数的其他地方有一个<code class="fe mr ms mt mh b">TypeError</code>,所以得到这样一个异常并不一定意味着你有一个非尾递归的函数。</p><p id="307a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">重要的是要注意，如果你使用的函数不是尾递归的，但是对递归调用的返回值不做任何计算，装饰器不会抱怨。例如，它可用于正确修饰以下函数:</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="a66a" class="ml mm it mh b gy mn mo l mp mq"># Listing 15<br/>def fact2(n, acc=1):<br/>    if n == 0:<br/>        return acc<br/>    else:<br/>        result = fact2(n-1, n*acc)<br/>        return result</span></pre><p id="8e09" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个装饰器有一个不同的版本，其中递归的检测是通过引发一个异常来发出信号的，并且在装饰器中没有使用非局部变量。然而，在这种情况下，如果您对非尾递归函数使用装饰器，它将不会检测到它，而是返回错误的结果。</p><p id="031d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">使用字节码注入的尾部调用优化</strong></p><p id="bc5e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还可以通过改变函数的字节码来防止递归(如果你不熟悉字节码注入，可以参考这篇<a class="ae lq" rel="noopener" target="_blank" href="/understanding-python-bytecode-e7edaae8734d">文章</a>)。还记得清单12中的伪代码吗，我们用新代码替换了递归调用。新代码首先用递归调用的相应参数的值替换函数的参数，然后跳回到函数的开头。我们可以用类似的方式编写一个装饰器来改变目标函数的字节码。让我们看看清单10中<code class="fe mr ms mt mh b">fact1</code>的字节码是什么样子的。我们使用<code class="fe mr ms mt mh b">dis</code>模块来反汇编这个函数的字节码:</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="3a3f" class="ml mm it mh b gy mn mo l mp mq">import dis<br/>dis.dis(fact1)</span></pre><p id="cf71" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">输出是:</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="5315" class="ml mm it mh b gy mn mo l mp mq">  2           0 LOAD_FAST                0 (n)<br/>              2 LOAD_CONST               1 (0)<br/>              4 COMPARE_OP               2 (==)<br/>              6 POP_JUMP_IF_FALSE       12<br/><br/>  3           8 LOAD_FAST                1 (acc)<br/>             10 RETURN_VALUE<br/><br/>  5     &gt;&gt;   12 LOAD_GLOBAL              0 (fact1)<br/>             14 LOAD_FAST                0 (n)<br/>             16 LOAD_CONST               2 (1)<br/>             18 BINARY_SUBTRACT<br/>             20 LOAD_FAST                0 (n)<br/>             22 LOAD_FAST                1 (acc)<br/>             24 BINARY_MULTIPLY<br/>             26 CALL_FUNCTION            2<br/>             28 RETURN_VALUE<br/>             30 LOAD_CONST               0 (None)<br/>             32 RETURN_VALUE</span></pre><p id="5db4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在第5行，函数调用自己。使用<code class="fe mr ms mt mh b">LOAD_GLOBAL</code>将<code class="fe mr ms mt mh b">fact1</code>的可调用对象推送到堆栈上。然后将函数的参数一个接一个地推到堆栈上，最右边的参数放在最上面。最后，使用<code class="fe mr ms mt mh b">CALL_FUNCTION</code>调用该函数。它的oparg(它的参数是<code class="fe mr ms mt mh b">2</code>)表示位置参数的数量。它首先将所有参数和可调用对象弹出堆栈，然后用这些参数调用可调用对象，最后将返回值推到堆栈顶部。指令<code class="fe mr ms mt mh b">RETURN_VALUE</code>将栈顶返回给函数的调用者。</p><p id="3a8b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们应该用一些新的字节码指令替换<code class="fe mr ms mt mh b">CALL_FUNCTION</code>和<code class="fe mr ms mt mh b">RETURN_VALUE</code>。新代码应该从堆栈中弹出递归调用的所有参数，并将它们存储在当前函数的参数中，然后跳回到函数的开头。所以它应该是这样的:</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="f8e3" class="ml mm it mh b gy mn mo l mp mq">  2     &gt;&gt;    0 LOAD_FAST                0 (n)<br/>              2 LOAD_CONST               1 (0)<br/>              4 COMPARE_OP               2 (==)<br/>              6 POP_JUMP_IF_FALSE       12<br/><br/>  3           8 LOAD_FAST                1 (acc)<br/>             10 RETURN_VALUE<br/><br/>  5     &gt;&gt;   12 LOAD_GLOBAL              0 (fact1)<br/>             14 LOAD_FAST                0 (n)<br/>             16 LOAD_CONST               2 (1)<br/>             18 BINARY_SUBTRACT<br/>             20 LOAD_FAST                0 (n)<br/>             22 LOAD_FAST                1 (acc)<br/>             24 BINARY_MULTIPLY<br/>             26 STORE_FAST               1 (acc)<br/>             28 STORE_FAST               0 (n)<br/>             30 POP_TOP<br/>             32 JUMP_ABSOLUTE            0<br/>             34 LOAD_CONST               0 (None)<br/>             36 RETURN_VALUE</span></pre><p id="d8b9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此处<code class="fe mr ms mt mh b">CALL_FUNCTION 2</code>在偏移量26处被移除。此时，递归调用的所有参数都在栈顶。所以用<code class="fe mr ms mt mh b">STORE_FAST</code>把它们一个一个弹出来，存储在<code class="fe mr ms mt mh b">fact1</code>的参数里。然后使用<code class="fe mr ms mt mh b">POP_TOP</code>将它们下面的函数的可调用对象弹出堆栈，因为我们不再需要它了。之后，使用<code class="fe mr ms mt mh b">JUMP_ABSOLUTE 0</code>跳回到偏移量0处的函数开始处。所以递归调用被转换成一个循环。</p><p id="5fb0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">清单16中的装饰器采用了一个尾递归函数，并以类似的方式更改了它的字节码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="12fb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它使用在名为<code class="fe mr ms mt mh b">tailrec</code>的模块中定义的两个函数<code class="fe mr ms mt mh b">disassemble_to_list</code>和<code class="fe mr ms mt mh b">assemble</code>(这些函数已经在本文<a class="ae lq" rel="noopener" target="_blank" href="/understanding-python-bytecode-e7edaae8734d">中详细讨论过了</a>)。<code class="fe mr ms mt mh b">disassemble_to_list</code>取函数的代码对象，将字节码反汇编成一些人性化的指令。它返回一个列表，其中每个元素显示一个字节码指令及其参数。这个列表可以很容易地用新指令替换字节码指令。修改指令后，<code class="fe mr ms mt mh b">assemble</code>将这个列表转换成字节码。带有这个新字节码的新代码对象被创建并分配给目标函数。</p><p id="213b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在装饰器内部，有一个while循环，它搜索字节码列表以找到所有的递归调用。事实上，它搜索的是后面跟有<code class="fe mr ms mt mh b">RETURN_VALUE</code>的<code class="fe mr ms mt mh b">CALL_FUNCTION</code>或<code class="fe mr ms mt mh b">CALL_FUNCTION_KW</code>指令。<code class="fe mr ms mt mh b">CALL_FUNCTION_KW</code>用于有关键字参数的函数。在这种情况下，堆栈顶部的元素包含一组关键字参数名，它们是由之前的指令推入的。下面是关键字参数，下面是位置参数，最右边的参数在最上面。参数下面是要调用的可调用对象。</p><p id="3f5b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当它发现一个递归调用时，它会添加<code class="fe mr ms mt mh b">STORE_FAST</code>指令，将递归调用参数存储在函数的参数中。它使用代码对象的<code class="fe mr ms mt mh b">co_varnames</code>属性来获取函数参数的名称。然后将添加一个<code class="fe mr ms mt mh b">JUMP_ABSOLUTE 0</code>以跳回到函数的开头。因为我们在原始函数中添加了更多的字节码指令，所以我们也应该更新具有相对或绝对跳转目标的指令(它们的操作码在<code class="fe mr ms mt mh b">dis.<strong class="kw iu">hasjrel</strong></code>或<code class="fe mr ms mt mh b">dis.<strong class="kw iu">hasjabs</strong></code>中),并且我们应该修正它们跳转目标的偏移量。</p><p id="6125" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个装饰器还可以检测一个非尾递归的函数，并引发一个异常。然而，与清单14中的装饰器不同，该函数应该是真正的尾递归，并且在递归调用之后不允许任何指令。所以清单15中的函数不能用这个装饰器来装饰，并引发了一个异常。</p><p id="4c13" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">尾调用优化可以使用这两种装饰器中的任何一种来完成，但是第二种要快得多。我们来比较一下他们的表现。我们首先定义两个设置函数<code class="fe mr ms mt mh b">s1</code>和<code class="fe mr ms mt mh b">s2</code>来使用每个装饰器计算<code class="fe mr ms mt mh b">15</code>的阶乘。</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="d027" class="ml mm it mh b gy mn mo l mp mq">@tail_rec<br/>def fact_1(n, acc=1):<br/>    if n == 0:<br/>        return acc<br/>    else:<br/>        return fact_1(n-1, n*acc)<br/>    <br/>@tail_recursion<br/>def fact_2(n, acc=1):<br/>    if n == 0:<br/>        return acc<br/>    else:<br/>        return fact_2(n-1, n*acc)</span><span id="0082" class="ml mm it mh b gy mz mo l mp mq">def s1():<br/>    return fact_1(15)</span><span id="f071" class="ml mm it mh b gy mz mo l mp mq">def s2():<br/>    return fact_2(15)</span></pre><p id="e6cb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们可以使用<code class="fe mr ms mt mh b">timit</code>模块比较这些设置的运行时间:</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="a2cc" class="ml mm it mh b gy mn mo l mp mq">import timeit<br/>t1 = timeit.timeit(s1, number=100000)<br/>t2 = timeit.timeit(s2, number=100000)<br/>print("Running time (tail-call optimization using stack frames)=", t1)<br/>print("Running time (tail-call optimization using bytecode injection)=", t2)</span></pre><p id="a709" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">输出是:</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="1eaa" class="ml mm it mh b gy mn mo l mp mq">Running time (tail-call optimization using stack frames)= 6.038<br/>Running time (tail-call optimization using bytecode injection)= 0.367</span></pre><p id="e19d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如你看到的，使用字节码注入的装饰器快了10倍以上。原因是它消除了函数调用，用一个循环代替了它们。</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><p id="0007" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我希望你喜欢阅读这篇文章。本文的所有代码清单都可以从以下网址下载:</p><p id="ab5f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">【https://github.com/reza-bagheri/tail-rec T4】</p></div></div>    
</body>
</html>