<html>
<head>
<title>Unboxing Lasso regularization with proximal gradient method</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用近似梯度法解套索正则化</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/unboxing-lasso-regularization-with-proximal-gradient-method-ista-iterative-soft-thresholding-b0797f05f8ea?source=collection_archive---------19-----------------------#2020-03-30">https://towardsdatascience.com/unboxing-lasso-regularization-with-proximal-gradient-method-ista-iterative-soft-thresholding-b0797f05f8ea?source=collection_archive---------19-----------------------#2020-03-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ec32" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">迭代软阈值算法</h2></div><p id="371f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">我首先告诉你，我不是数学家，因为这个话题需要一些</em><strong class="kh ir"><em class="lb"/></strong><em class="lb">数学知识(振作起来！)我想说明的是，它不会完全严谨。</em></p><p id="c197" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">本文旨在总结应用</em> ISTA(迭代软阈值算法)<em class="lb">解决梯度下降优化套索正则化问题的整个过程。</em></p><p id="fa9b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，我假设如果你正在阅读，至少你对我们将要谈论的内容有所暗示，我希望我的帖子会有所帮助。</p><p id="38e0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">让我们首先构建一个数学难题，它将引导我们理解如何使用梯度下降计算lasso正则化，即使成本函数不是完全可微的，如Lasso的情况。</em></p><h2 id="3a98" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated"><em class="lv">子梯度</em></h2><p id="6d7a" class="pw-post-body-paragraph kf kg iq kh b ki lw jr kk kl lx ju kn ko ly kq kr ks lz ku kv kw ma ky kz la ij bi translated"><em class="lb">首先要掌握的概念是</em>凸函数<em class="lb">的定义。</em></p><p id="aff1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">一个完全可微的函数</em> <strong class="kh ir"> <em class="lb"> f </em> </strong> <em class="lb">被说成是凸的如果:</em></p><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/67e724291feb19977541b47c1c9bd82b.png" data-original-src="https://miro.medium.com/v2/resize:fit:874/format:webp/1*4lNo65LypHjiTQb-5baj_Q.png"/></div></figure><p id="6397" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">换句话说，其局部</em> <a class="ae mj" href="https://www.khanacademy.org/math/ap-calculus-bc/bc-series-new/bc-10-11/v/maclaurin-and-taylor-series-intuition" rel="noopener ugc nofollow" target="_blank"> <em class="lb">线性逼近</em> </a> <em class="lb">(泰勒展开)总是低估</em> <strong class="kh ir"> <em class="lb"> f </em> </strong> <em class="lb">。这种凸函数的一个例子是我们钟爱的均方误差。</em></p><p id="6e3a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">让我们更进一步，从凸函数直接得出</em>次梯度<em class="lb">，当我们处理一个在每一点都不可微的函数时，这个工具是必要的，而且由于套索使用了我们变量(绝对值)的</em> <a class="ae mj" href="https://mathworld.wolfram.com/L1-Norm.html" rel="noopener ugc nofollow" target="_blank"> <em class="lb"> L1范数</em> </a> <em class="lb">我们知道这个函数在零点</em> <strong class="kh ir"> <em class="lb">不可微</em> </strong> <em class="lb">。</em></p><p id="8cc9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">次梯度</em> <strong class="kh ir"> <em class="lb"> </em> </strong> <em class="lb">是一种概括凸函数在不可微点处梯度的方法。凸函数</em> <strong class="kh ir"> <em class="lb"> f </em> </strong> <em class="lb">在x点的次梯度是任意的</em> <strong class="kh ir"> <em class="lb"> g </em> </strong> <em class="lb">这样:</em></p><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/5dd8766ce40742cac5c6dccbdfd34620.png" data-original-src="https://miro.medium.com/v2/resize:fit:634/format:webp/1*PuSj7ZES7XasWCwF1u698w.png"/></div></figure><p id="0338" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">该表达式也是对</em> <strong class="kh ir"> <em class="lb"> f </em> </strong> <em class="lb">的线性近似，其中我们使用次梯度来代替梯度，次梯度在满足上述条件的值的</em> <strong class="kh ir"> <em class="lb">集合</em> </strong> <em class="lb">内。</em></p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi ml"><img src="../Images/897de758477da0f374ccdab9d8d94e02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_7n_A20GV9ME1sTS9fcIBw.png"/></div></div><p class="mq mr gj gh gi ms mt bd b be z dk translated">凸函数f(x)的次梯度。点x1是可微的，我们有一个唯一的梯度，而在点x2(不可微的)我们有一组符合上述条件的可能的子梯度值</p></figure><p id="4720" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb"> g </em> 1 <em class="lb">，g </em> 2 <em class="lb">，g</em>3<strong class="kh ir"><em class="lb"/></strong><em class="lb">是</em> <strong class="kh ir"> <em class="lb"> f </em> </strong> <em class="lb">在</em><strong class="kh ir"><em class="lb"/></strong><em class="lb">x</em>1<em class="lb">，x </em> 2 <em class="lb">的子渐变。</em></p><p id="d938" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">在函数可微的点(x </em> 1 <em class="lb">)上，次梯度是</em> <strong class="kh ir"> <em class="lb">唯一的</em> </strong> <em class="lb">确切地说是:g=∇f(x)、</em> <strong class="kh ir"> <em class="lb"> </em> </strong> <em class="lb">相反，在x </em> 2 <em class="lb">上，我们可能有无限数量的次梯度(在上图中，我们只能看到其中的几个)</em></p><p id="ec12" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">在f(x)=|x|的情况下，x = 0处的子梯度g如下图所示，它们的范围在</em><strong class="kh ir"><em class="lb"/></strong><em class="lb">[-1，1]中包含的所有可能值之间。任何一条斜率在此范围</em> <strong class="kh ir"> <em class="lb">内穿过x = 0的直线，都会对函数</em> </strong> <em class="lb">进行下界。</em></p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi mu"><img src="../Images/3109de488a1c1085f9d4c2419ed7251b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8oJy2v6uGGP9dUU8AKyEVQ.png"/></div></div><p class="mq mr gj gh gi ms mt bd b be z dk translated">x=0时f(x)=|x|的一些次梯度</p></figure><p id="68de" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">凸f的所有次梯度的集合称为次微分:</em></p><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/6fad7e9b18c36774279398cd140cf422.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*if5HmnUbNHRMzf40axxtxQ.png"/></div></figure><p id="0da0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">次微分定义可以推广到各种凸函数，无论可微与否。主要的一点是，当一个函数在它的定义域中的每一点都是完全可微的，那么次微分是由整个梯度集合(分别是唯一的值)组成的，相反，当一个函数不是处处可微时，次梯度就来了。</em></p><p id="21f3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">再次考虑单变量x的L1范数:</em></p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi mw"><img src="../Images/4e1709a331343f15d9370fce1ad8e195.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9QX5q5y6mFgcVPITujfk8Q.png"/></div></div><p class="mq mr gj gh gi ms mt bd b be z dk translated">绝对值函数(左)及其次微分∂f(x)作为x的函数(右)</p></figure><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/60dcbfdd9f1e11b717243af874f8c109.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/format:webp/1*FvAjacUNN1tdbN235MRpYw.png"/></div><p class="mq mr gj gh gi ms mt bd b be z dk translated">f(x) = |x|的次微分；这种情况下k=1，2，3</p></figure><p id="e2ff" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">给定次微分，则任意</em> <strong class="kh ir"> <em class="lb"> f </em> </strong> <em class="lb">(可微或不可微)的最优性条件为:</em></p><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi my"><img src="../Images/ca4c46417614966bbf72617756510579.png" data-original-src="https://miro.medium.com/v2/resize:fit:794/format:webp/1*jfzTTa_Lc6_wOkIcNmeGuA.png"/></div></figure><p id="5eed" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> <em class="lb"> x* </em> </strong> <em class="lb">是极小元当且仅当</em> <strong class="kh ir"> <em class="lb"> 0 </em> </strong> <em class="lb">是</em><strong class="kh ir"><em class="lb">f</em></strong><em class="lb">at</em><strong class="kh ir"><em class="lb">x *</em></strong><em class="lb">的次梯度。这叫做</em> <strong class="kh ir"> <em class="lb">次梯度最优性条件</em> </strong> <em class="lb">。</em></p><p id="f490" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">为什么？简单，g= 0是次梯度意味着对于所有y: </em></p><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/214bde4090fb78b4cd31a0f4ef25f0c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*D9ddKOGw7v50VXGI09TTTw.png"/></div></figure><p id="568e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">注意一个凸且可微的函数f的含义:</em></p><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi na"><img src="../Images/176c303448b242f230c736f43ddf82d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:346/format:webp/1*e97fm9nKKbwnGrTE9z81kw.png"/></div></figure></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><h2 id="6ab5" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated"><em class="lv">近端标测</em></h2><p id="98e0" class="pw-post-body-paragraph kf kg iq kh b ki lw jr kk kl lx ju kn ko ly kq kr ks lz ku kv kw ma ky kz la ij bi translated">现在我们已经熟悉了次梯度，我们需要了解的其他工具有:近似算子和软阈值算子。</p><p id="acc6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> <em class="lb">近端操作符</em> </strong> <em class="lb">定义:</em></p><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/0fb34b258c8571e95c48daeef8b1a802.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*hXiekuadZuoK0hd1n21vgw.png"/></div></figure><p id="e1da" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">这里我们搜索的是点</em><strong class="kh ir"><em class="lb">【x *】</em></strong><em class="lb">，它最小化了一个通用凸函数f</em><strong class="kh ir"><em class="lb"/></strong><em class="lb"/><strong class="kh ir"><em class="lb"/></strong><em class="lb">但是</em> <strong class="kh ir"> <em class="lb"> </em> </strong> <em class="lb">同时保持接近一个参考点</em> <strong class="kh ir">我们通过<strong class="kh ir"><em class="lb">α</em></strong><em class="lb">选择接近多少作为这些术语</em>之间的相对权重或权衡参数</strong></p><p id="02e0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> <em class="lb">软阈值算子</em> </strong> <em class="lb">定义:</em></p><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/ae49968ad7387e60c5c6ff5ed6b1b066.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/format:webp/1*Al6pHLzg12ID1v5qVEIPdQ.png"/></div></figure><p id="1adc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">或者更简洁的形式:</em></p><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/3cb352c2a5224689e9f7830e399e8363.png" data-original-src="https://miro.medium.com/v2/resize:fit:644/format:webp/1*rKxQp-xOnZHm6HLFtMM1eQ.png"/></div><p class="mq mr gj gh gi ms mt bd b be z dk translated">例如给定λ= 1，如果x = 3，sign(3) = 1，max((| 3 |–1)，0) = max(2，0)= 2-&gt;<strong class="bd nl">1 * 2 = 2</strong>；如果x = -0.5，sign(-0.5) = -1，max((|-0.5 |–1)，0) = max(-0.5，0)= 0-&gt;<strong class="bd nl">-1 * 0 = 0</strong>；如果x = -3，sign(-3) = -1，max((|-3 |–1)，0) = max(2，0) = 2 - &gt; <strong class="bd nl"> -1 * 2 = -2 </strong></p></figure></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><p id="5a97" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">好吧，我知道，你在想:</em> <strong class="kh ir"> <em class="lb">为什么是他们？？？</em></strong><em class="lb"/><strong class="kh ir"><em class="lb">我要啤酒不要操作员！</em>T113】</strong></p><p id="4218" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我理解你的兄弟姐妹。但是在你喝啤酒之前，你需要经历最艰难的部分。继续战斗！</p><p id="ba88" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">那么，让我试着解释一下所有这些，并开始应用近似运算符。</em></p><p id="473e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">定义</em> <strong class="kh ir"> <em class="lb"> f </em> </strong> <em class="lb">为局部线性逼近在</em><strong class="kh ir"><em class="lb"/></strong><em class="lb">x</em>k<em class="lb">对于一个通用函数，我们假设</em> <strong class="kh ir"> <em class="lb"> </em> </strong> <em class="lb">凸且可微，我们把它代入最接近的算子:</em></p><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/d66f98aa12d516e72198508868cd9e11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*UnTWSBDYhH61ShOhy0tDTA.png"/></div></figure><p id="c6ad" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">已知，点</em> <strong class="kh ir"> <em class="lb"> x* </em> </strong> <em class="lb">是局部极小点如果:</em></p><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/cae42495a4b5f6517379a9e8c6cefd56.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*sghEqCwdCif2jEIt_rOUUg.png"/></div></figure><p id="8fad" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">我敢打赌这提醒了你一些事情……等等，我用一种更熟悉的符号来写:</em></p><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi no"><img src="../Images/f10063c68ef0ca44471db1366f5b6c04.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/format:webp/1*WUAS8tZXrjxSVn33gGdQqg.png"/></div></figure><p id="148b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">现在好些了吗？是的，这是一个梯度下降步骤，仅用线性近似的近似映射来计算。事实上，梯度下降和近似算子是非常亲密的朋友。</em></p></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><p id="fa71" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">下一轮我们将使用不同的函数:</em></p><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi np"><img src="../Images/ff262fa89bd53fe1f0ca1ada8c22ca18.png" data-original-src="https://miro.medium.com/v2/resize:fit:296/format:webp/1*jog3TI88oH95g1tSj2S0Vg.png"/></div></figure><p id="5b13" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">同样，我们可以将它插入到prox操作符中，我们得到:</em></p><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/67adb74e1a707c7b575d4fc835363418.png" data-original-src="https://miro.medium.com/v2/resize:fit:986/format:webp/1*7nm23T-0z8aWEx8Ahw_ZMg.png"/></div></figure><p id="a909" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">从L1和L2范数的定义我们得到:</em></p><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/74e42fc1c69bf69ba40a6ed15c1ac699.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*TDXcyaOCnrMgSJWHIYR9LQ.png"/></div></figure><p id="9720" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">这些是可分离的函数，因此我们可以将它们作为组件式标量问题来解决:</em></p><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/af4b77e218d354fe0363b8602abed15e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*-PHDqhKwR98sJeeUa7RWOg.png"/></div></figure><p id="fd83" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">由于h是凸的，但在x = 0处不可微，我们用它的次微分来工作并回忆:</em></p><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/6e7cc1ffc82a8ede9aca4cc6b012fe3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/format:webp/1*UhwDCmiBy6s8vN6ijVIB_A.png"/></div></figure><p id="3156" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">于是我们得到了最后的结果:</em></p><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/db1c50389cd5cf3927607c40d7775421.png" data-original-src="https://miro.medium.com/v2/resize:fit:892/format:webp/1*dhU3jNcFjjJiC3VYnbQBKA.png"/></div></figure><p id="ef26" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">或者用上面介绍的软阈值运算符重新排列:</em></p><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/fb92d91816f6745246435e08ef78d657.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/1*Ffvp8K0GC7MTNVc9bLmlKQ.png"/></div></figure><p id="aa5d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">最后这个结果可能有点棘手，让我解释一下是怎么回事。根据绝对值的次微分和上面获得的最优性条件，我们有3种可能的情况:</em></p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi nw"><img src="../Images/a628a6834d41288ed8792b232cc2a459.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*604svReagsH74MRjnD1nJA.png"/></div></div></figure><p id="ebd1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">所以最后我们可以概括为:</em></p><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/508e869b9db34d19d732d455ccc3e740.png" data-original-src="https://miro.medium.com/v2/resize:fit:470/format:webp/1*T3au3n4k8q5_8XVug0Nb9g.png"/></div></figure><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi ny"><img src="../Images/8ad69d04b688ec05741ed9d700a64b61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*v7hl3V-uN8UrclqV9vICPQ.gif"/></div></div><p class="mq mr gj gh gi ms mt bd b be z dk translated">图片来源<a class="ae mj" href="https://pierreablin.com/" rel="noopener ugc nofollow" target="_blank">皮埃尔·阿布林</a></p></figure></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><p id="06f2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">开始吧，最后一轮…阿德里亚娜！</p><p id="86e9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">现在考虑:</em></p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi nz"><img src="../Images/0dcf7e407a1f5cdf0729dae33a34c0d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:406/format:webp/1*_gtd9vSU0oiov6KrMB7feQ.png"/></div></div></figure><p id="1587" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">作为一个一般的凸可微函数g(即最小二乘)加上一个凸不可微函数h的和，在我们的情况下是L1范数，我们想最小化它。为此，我们首先将一个</em> <a class="ae mj" href="https://www.khanacademy.org/math/multivariable-calculus/applications-of-multivariable-derivatives/quadratic-approximations/v/what-do-quadratic-approximations-look-like" rel="noopener ugc nofollow" target="_blank"> <em class="lb">局部二次近似</em> </a> <em class="lb">应用于g，并保留</em> <strong class="kh ir"> <em class="lb"> </em> </strong> <em class="lb"> h不变。</em></p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi oa"><img src="../Images/6c87646254e5ac84a6030471f1e237ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*g0XUk4HHQhVzS8ZkCBOf1A.png"/></div></div></figure><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi ob"><img src="../Images/745fb15b3da9f60c04195b7fd4b8fcf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*79_RTcL4KOEUJ5n8ishsdQ.png"/></div></div><p class="mq mr gj gh gi ms mt bd b be z dk translated"><em class="lv">在x=1时，具有不同alphas的一般g(x)的局部二次近似</em></p></figure><p id="c8c1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">注意，我们在没有Hessian的情况下获得的局部二次近似只是我们之前计算出的线性近似的近似算子。</em></p><p id="a87d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了我们的目的，我们还需要重新排列g: </p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi oc"><img src="../Images/1f2ba2244a57dac17ff96e49683bd2be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RLuBhkrAMmZWa8AR_3BRfA.png"/></div></div></figure><p id="aa85" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在去掉不依赖于x的常数项并加上h后，我们可以最小化整个f: </p><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi od"><img src="../Images/a0ee234266ec0e79282b069edc25ee3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/1*lsshBWCMbpGswPMaCO4TyQ.png"/></div></figure><p id="2c24" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">经过大量的数学计算，最终我们可以将 <strong class="kh ir"> ISTA </strong>(迭代收缩阈值算法)<em class="lb">定义为:</em></p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi oe"><img src="../Images/ebea5d3c200e24ea6d90a19b409bb73a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NgDwoI2a2tnuR8_rw7z04w.png"/></div></div></figure><p id="cf36" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">对于我们的n变量可分函数的每个分量。</em></p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi of"><img src="../Images/12f631f87d50101d95f73e10a4e93c2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jscind48Qjsh5vg_NgxPKg.png"/></div></div></figure><p id="e101" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">是的，看起来很糟糕，但并不像看起来那么糟糕。您只需像往常一样计算梯度下降，唯一的区别是在将值传递给下一次迭代之前，使用软阈值操作符应用进一步的变换。</p><p id="4d3a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，对于梯度下降，你可以定义一个规则来停止迭代并非常接近函数的最小值。</p><p id="115a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">值得一提的是，这个结果不依赖于g，它可以像我们想要的那样复杂，我们只需要能够计算它的梯度。</em></p><p id="5fbe" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> <em class="lb">搞定！从现在开始，不再有数学，只有啤酒。我们应得的。</em> </strong></p></div></div>    
</body>
</html>