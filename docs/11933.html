<html>
<head>
<title>Knowing these, You Can Cover 99% of File Operations in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">知道了这些，你就可以覆盖 Python 中 99%的文件操作</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/knowing-these-you-can-cover-99-of-file-operations-in-python-84725d82c2df?source=collection_archive---------9-----------------------#2020-08-18">https://towardsdatascience.com/knowing-these-you-can-cover-99-of-file-operations-in-python-84725d82c2df?source=collection_archive---------9-----------------------#2020-08-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f5b3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">提高您处理文件的效率</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/eabdfd9005a136f7a21aa5c9744fa4fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VIn_B5FFJyLRWLTP"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Maksym Kaharlytskyi 在<a class="ae ky" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="30f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated">处理文件是我们每天最常见的任务之一。Python 有几个内置模块，用于执行文件操作，比如读取文件、移动文件、获取文件属性等。本文总结了许多您需要了解的函数，以涵盖 Python 中最常见的文件操作和良好实践。</p><p id="b4f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是您将在本文中看到的模块/函数的图表。要了解每个操作的更多信息，请继续阅读。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi me"><img src="../Images/1b1d81e8844f69404fcee2b80c897963.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mC64ozWudXsUWHFDFPMxEw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者:高</p></figure></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h2 id="2f82" class="mm mn it bd mo mp mq dn mr ms mt dp mu li mv mw mx lm my mz na lq nb nc nd ne bi translated">打开和关闭文件</h2><p id="d454" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">当你想读或写一个文件时，首先要做的是打开文件。Python 有一个内置函数<code class="fe nk nl nm nn b">open</code>，它打开文件并返回一个 file 对象。文件对象的类型取决于打开文件的<strong class="lb iu">模式</strong>。它可以是文本文件对象、原始二进制文件和缓冲二进制文件。每个文件对象都有像<code class="fe nk nl nm nn b">read()</code>和<code class="fe nk nl nm nn b">write()</code>这样的方法。</p><p id="2d7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="no">这个代码块有问题，能认出来吗？我们以后再讨论。</em></p><pre class="kj kk kl km gt np nn nq nr aw ns bi"><span id="0585" class="mm mn it nn b gy nt nu l nv nw">file = open("test_file.txt","w+")<br/>file.read()<br/>file.write("a new line")</span></pre><p id="4eef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python <a class="ae ky" href="https://docs.python.org/3/library/functions.html#open" rel="noopener ugc nofollow" target="_blank">文档</a>列出了所有可能的文件模式。下表列出了最常见的模式。<strong class="lb iu">一个重要的规则是，任何</strong> <code class="fe nk nl nm nn b"><strong class="lb iu">w</strong></code> <strong class="lb iu">相关的模式都会先截断文件(如果存在的话)，然后创建一个新文件。如果你不想覆盖文件，小心使用这种模式，如果可能的话，使用<code class="fe nk nl nm nn b">a</code>追加模式。</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="51e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">前面代码块中的问题是我们只打开了文件，而没有关闭它。处理文件时，务必关闭文件。拥有一个打开的文件对象会导致不可预知的行为，比如资源泄漏。有两种方法可以确保文件被正确关闭。</p><ol class=""><li id="582b" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated"><strong class="lb iu">使用</strong>T5】</li></ol><p id="5daa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一种方式是显式使用<code class="fe nk nl nm nn b">close()</code>。一个好的做法是将它放在<code class="fe nk nl nm nn b">finally</code>中，这样我们可以确保文件在任何情况下都会被关闭。它使代码更加清晰，但另一方面，开发人员应该负起责任，不要忘记关闭它。</p><pre class="kj kk kl km gt np nn nq nr aw ns bi"><span id="5afc" class="mm mn it nn b gy nt nu l nv nw">try:<br/>    file = open("test_file.txt","w+")<br/>    file.write("a new line")<br/>exception Exception as e:<br/>    logging.exception(e)<br/>finally:<br/>    file.close()</span></pre><p id="4748" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 2。使用上下文管理器</strong> <code class="fe nk nl nm nn b"><strong class="lb iu">with open(...) as f</strong></code></p><p id="bd9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二种方法是使用上下文管理器。如果你不熟悉上下文管理器，那么看看 Dan Bader 的<a class="ae ky" href="https://dbader.org/blog/python-context-managers-and-with-statement" rel="noopener ugc nofollow" target="_blank">上下文管理器和 Python </a>中的“with”语句。<code class="fe nk nl nm nn b">with open() as f</code>语句实现了<code class="fe nk nl nm nn b">__enter__</code>和<code class="fe nk nl nm nn b">__exit__</code>方法来打开和关闭文件。此外，它在上下文管理器中封装了 try/finally 语句，这意味着我们永远不会忘记关闭文件。</p><pre class="kj kk kl km gt np nn nq nr aw ns bi"><span id="63ea" class="mm mn it nn b gy nt nu l nv nw">with open("test_file","w+") as file:<br/>    file.write("a new line")</span></pre><p id="6714" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个上下文管理器解决方案总是比<code class="fe nk nl nm nn b">close()</code>好吗？看你用在什么地方了。以下示例实现了将 50，000 条记录写入文件的 3 种不同方式。正如您从输出中看到的，<code class="fe nk nl nm nn b">use_context_manager_2()</code>函数与其他函数相比性能极低。这是因为<code class="fe nk nl nm nn b">with</code>语句是在一个单独的函数中，它基本上为每条记录打开和关闭文件。如此昂贵的 I/O 操作会极大地影响性能。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">比较<code class="fe nk nl nm nn b">with</code>语句和 close()方法</p></figure><h2 id="9f4d" class="mm mn it bd mo mp mq dn mr ms mt dp mu li mv mw mx lm my mz na lq nb nc nd ne bi translated">读取和写入文件</h2><p id="6853" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">打开文件后，您必须想读取或写入该文件。file 对象提供了<a class="ae ky" href="https://docs.python.org/3/tutorial/inputoutput.html#methods-of-file-objects" rel="noopener ugc nofollow" target="_blank"> 3 个方法</a>来读取一个文件，分别是<code class="fe nk nl nm nn b">read()</code>、<code class="fe nk nl nm nn b">readline()</code>和<code class="fe nk nl nm nn b">readlines()</code>。</p><p id="15e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，<code class="fe nk nl nm nn b">read(size=-1)</code>返回文件的全部内容。如果文件大于内存，可选参数<code class="fe nk nl nm nn b">size</code>可以帮助您限制返回字符(文本模式)或字节(二进制模式)的大小。</p><p id="fc38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nk nl nm nn b">readline(size=-1)</code>返回一整行，末尾包含字符<code class="fe nk nl nm nn b">\n</code>。如果<code class="fe nk nl nm nn b">size</code>大于 0，将返回该行的最大<code class="fe nk nl nm nn b">size</code>字符数。</p><p id="00e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nk nl nm nn b">readlines(hint=-1)</code>返回列表中文件的所有行。可选参数<code class="fe nk nl nm nn b">hint</code>表示如果返回的字符数超过<code class="fe nk nl nm nn b">hint</code>，将不再返回更多的行。</p><p id="38dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这 3 种方法中，<code class="fe nk nl nm nn b">read()</code>和<code class="fe nk nl nm nn b">readlines()</code>的内存效率较低，因为默认情况下，它们以字符串或列表的形式返回完整的文件。一种更节省内存的方法是使用<code class="fe nk nl nm nn b">readline()</code>，让它停止读取，直到返回一个空字符串。空字符串<code class="fe nk nl nm nn b">""</code>意味着指针到达了文件的末尾。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">以节省内存的方式读取文件</p></figure><p id="70a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就写作而言，有两种方法<code class="fe nk nl nm nn b">write()</code>和<code class="fe nk nl nm nn b">writelines()</code>。顾名思义，<code class="fe nk nl nm nn b">write()</code>是写字符串，<code class="fe nk nl nm nn b">writelines()</code>是写字符串列表。<strong class="lb iu">开发人员负责在末尾加上</strong> <code class="fe nk nl nm nn b"><strong class="lb iu">\n</strong></code> <strong class="lb iu">。</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">将行写入文件</p></figure><p id="105f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您将文本写入特殊的文件类型，如 JSON 或 csv，那么您应该在 file 对象之上使用 Python 内置模块<code class="fe nk nl nm nn b">json</code>或<code class="fe nk nl nm nn b">csv</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><h2 id="0802" class="mm mn it bd mo mp mq dn mr ms mt dp mu li mv mw mx lm my mz na lq nb nc nd ne bi translated">在文件内移动指针</h2><p id="b6fc" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">当我们打开一个文件时，我们得到一个指向某个位置的文件处理程序。在<code class="fe nk nl nm nn b">r</code>和<code class="fe nk nl nm nn b">w</code>模式下，处理程序指向文件的开头。在<code class="fe nk nl nm nn b">a</code>模式下，处理程序指向文件的结尾。</p><p id="2c61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nk nl nm nn b"><strong class="lb iu"><em class="no">tell()</em></strong></code><strong class="lb iu"><em class="no"/></strong><code class="fe nk nl nm nn b"><strong class="lb iu"><em class="no">seek()</em></strong></code></p><p id="deca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们从文件中读取时，指针移动到下一次读取将开始的地方，除非我们告诉指针四处移动。您可以使用两种方法完成此操作:<code class="fe nk nl nm nn b">tell()</code>和<code class="fe nk nl nm nn b">seek()</code>。</p><p id="9762" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nk nl nm nn b">tell()</code>从文件开始以字节/字符数的形式返回指针的当前位置。<code class="fe nk nl nm nn b">seek(offset,whence=0)</code>将处理器移动到距离<code class="fe nk nl nm nn b">whence</code>有<code class="fe nk nl nm nn b">offset</code>个字符的位置。<code class="fe nk nl nm nn b">whence</code>可以是:</p><ul class=""><li id="14cb" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oi of og oh bi translated">0:从文件的开头开始</li><li id="9038" class="nz oa it lb b lc oj lf ok li ol lm om lq on lu oi of og oh bi translated">1:从当前位置</li><li id="904e" class="nz oa it lb b lc oj lf ok li ol lm om lq on lu oi of og oh bi translated">2:从文件末尾开始</li></ul><p id="e624" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在文本模式下，<code class="fe nk nl nm nn b">whence</code>只能为 0，<code class="fe nk nl nm nn b">offset</code>应≥0。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">讲述()和寻找()</p></figure><h2 id="cde5" class="mm mn it bd mo mp mq dn mr ms mt dp mu li mv mw mx lm my mz na lq nb nc nd ne bi translated">了解文件状态</h2><p id="5418" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">操作系统上的文件系统可以告诉你许多关于文件的实用信息。例如，文件的大小、创建和修改时间。要在 Python 中获得这些信息，可以使用<code class="fe nk nl nm nn b">os</code>或<code class="fe nk nl nm nn b">pathlib</code>模块。其实<code class="fe nk nl nm nn b">os</code>和<code class="fe nk nl nm nn b">pathlib.</code>之间有很多共同点<code class="fe nk nl nm nn b">pathlib</code>是一个比<code class="fe nk nl nm nn b">os</code>更面向对象的模块。</p><p id="e805" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="no"> os </em> </strong></p><p id="b090" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">获得完整状态的一种方法是使用<code class="fe nk nl nm nn b">os.stat("test.txt")</code>。它返回一个结果对象，带有许多统计信息，如<code class="fe nk nl nm nn b">st_size</code>(文件的大小，以字节为单位)<code class="fe nk nl nm nn b">st_atime</code>(最近一次访问的时间戳)<code class="fe nk nl nm nn b">st_mtime</code>(最近一次修改的时间戳)等。</p><pre class="kj kk kl km gt np nn nq nr aw ns bi"><span id="82d1" class="mm mn it nn b gy nt nu l nv nw">print(os.stat("text.txt"))</span><span id="72c7" class="mm mn it nn b gy oo nu l nv nw">&gt;&gt;&gt; os.stat_result(st_mode=33188, st_ino=8618932538, st_dev=16777220, st_nlink=1, st_uid=501, st_gid=20, st_size=16, st_atime=1597527409, st_mtime=1597527409, st_ctime=1597527409)</span></pre><p id="9c9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您也可以使用<code class="fe nk nl nm nn b">os.path</code>单独获取统计数据。</p><pre class="kj kk kl km gt np nn nq nr aw ns bi"><span id="22c6" class="mm mn it nn b gy nt nu l nv nw">os.path.getatime()<br/>os.path.getctime()<br/>os.path.getmtime()<br/>os.path.getsize()</span></pre><p id="13d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="no"> Pathlib </em> </strong></p><p id="ec6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">获得完整状态的另一种方法是使用<code class="fe nk nl nm nn b">pathlib.Path("text.txt").stat()</code>。它返回与<code class="fe nk nl nm nn b">os.stat()</code>相同的对象。</p><pre class="kj kk kl km gt np nn nq nr aw ns bi"><span id="da05" class="mm mn it nn b gy nt nu l nv nw">print(<!-- -->pathlib.Path("text.txt").stat())</span><span id="dd04" class="mm mn it nn b gy oo nu l nv nw">&gt;&gt;&gt; os.stat_result(st_mode=33188, st_ino=8618932538, st_dev=16777220, st_nlink=1, st_uid=501, st_gid=20, st_size=16, st_atime=1597528703, st_mtime=1597528703, st_ctime=1597528703)</span></pre><p id="82dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将在以下章节中比较<code class="fe nk nl nm nn b">os</code>和<code class="fe nk nl nm nn b">pathlib</code>的更多方面。</p><h2 id="4e78" class="mm mn it bd mo mp mq dn mr ms mt dp mu li mv mw mx lm my mz na lq nb nc nd ne bi translated">复制、移动和删除文件</h2><p id="e3f7" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">Python 有许多处理文件移动的内置模块。在你相信 Google 返回的第一个答案之前，你要意识到模块的不同选择会导致不同的表现。有些模块会阻塞线程，直到文件移动完成，而其他模块可能会异步执行。</p><p id="f742" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"><em class="no"/></strong></p><p id="f7c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nk nl nm nn b">shutil</code>是最著名的移动、复制和删除文件和文件夹的模块。它提供了 4 种方法来复制一个文件。<code class="fe nk nl nm nn b">copy()</code>、<code class="fe nk nl nm nn b">copy2()</code>和<code class="fe nk nl nm nn b">copyfile()</code>。</p><p id="5cf9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nk nl nm nn b"><strong class="lb iu">copy()</strong></code> <strong class="lb iu"> v.s. </strong> <code class="fe nk nl nm nn b"><strong class="lb iu">copy2()</strong></code> : <code class="fe nk nl nm nn b">copy2()</code>和<code class="fe nk nl nm nn b">copy()</code>很像。不同的是，<code class="fe nk nl nm nn b">copy2()</code>还会复制文件的元数据，比如最近的访问时间、最近的修改时间。但是根据<a class="ae ky" href="https://docs.python.org/3/library/shutil.html" rel="noopener ugc nofollow" target="_blank">的 Python 文档</a>，由于操作系统的限制，即使<code class="fe nk nl nm nn b">copy2()</code>也无法复制所有的元数据。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">副本()与副本 2()</p></figure><p id="6a31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nk nl nm nn b"><strong class="lb iu">copy()</strong></code> <strong class="lb iu"> v.s. </strong> <code class="fe nk nl nm nn b"><strong class="lb iu">copyfile()</strong></code> : <code class="fe nk nl nm nn b">copy()</code>设置新文件的权限与原文件相同，但<code class="fe nk nl nm nn b">copyfile()</code>不复制其权限模式。其次，<code class="fe nk nl nm nn b">copy()</code>的目的地可以是一个目录。如果存在同名文件，它将被覆盖，否则，将创建一个新文件。但是，<code class="fe nk nl nm nn b">copyfile()</code>的目的地必须是目标文件名。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">copy() v.s. copyfile()</p></figure><p id="b1bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="no"> os </em> </strong></p><p id="8ede" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nk nl nm nn b">os</code>模块有一个功能<code class="fe nk nl nm nn b">system()</code>，允许你在子外壳中执行命令。您需要将命令作为参数传递给<code class="fe nk nl nm nn b">system()</code>。这与在操作系统上执行的命令具有相同的效果。对于移动和删除文件，您也可以使用<code class="fe nk nl nm nn b">os</code>模块中的专用功能。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">操作系统移动 _ 复制</p></figure><p id="93d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="no">异步复制/移动文件</em> </strong></p><p id="da19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止，解决方案总是同步的，这意味着如果文件很大并且需要更多时间移动，程序可能会被阻塞。如果想让程序异步，可以使用<code class="fe nk nl nm nn b">threading</code>、<code class="fe nk nl nm nn b">multiprocessing</code>或者<code class="fe nk nl nm nn b">subprocess</code>模块，让文件操作在单独的线程或者单独的进程中运行。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">异步方式的文件操作</p></figure><h2 id="5e45" class="mm mn it bd mo mp mq dn mr ms mt dp mu li mv mw mx lm my mz na lq nb nc nd ne bi translated">搜索文件</h2><p id="2a9d" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">复制和移动文件后，您可能希望搜索与特定模式匹配的文件名。Python 提供了许多内置函数供您选择。</p><p id="957a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="no">全球</em> </strong></p><blockquote class="op oq or"><p id="4ba5" class="kz la no lb b lc ld ju le lf lg jx lh os lj lk ll ot ln lo lp ou lr ls lt lu im bi translated"><code class="fe nk nl nm nn b"><a class="ae ky" href="https://docs.python.org/3.8/library/glob.html#module-glob" rel="noopener ugc nofollow" target="_blank">glob</a></code>模块根据 Unix shell 使用的规则找到所有匹配指定模式的路径名。它支持通配符，如*？[].</p></blockquote><p id="5a33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nk nl nm nn b">glob.glob("*.csv")</code>在当前目录中搜索所有扩展名为<code class="fe nk nl nm nn b">csv</code>的文件。<code class="fe nk nl nm nn b">glob</code>模块也可以搜索子目录中的文件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">搜索文件名—全局</p></figure><p id="fa72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="no"> os </em> </strong></p><p id="8804" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nk nl nm nn b">os</code>模块功能强大，基本上可以做一切与文件有关的操作。我们可以简单地使用<code class="fe nk nl nm nn b">os.listdir()</code>列出目录中的所有文件，并使用<code class="fe nk nl nm nn b">file.endswith()</code>和<code class="fe nk nl nm nn b">file.startswith()</code>来检测模式。如果你想遍历目录，那么使用<code class="fe nk nl nm nn b">os.walk()</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">搜索文件名—操作系统</p></figure><p id="329f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="no"> pathlib </em> </strong></p><p id="bffd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nk nl nm nn b">pathlib</code>具有与<code class="fe nk nl nm nn b">glob</code>模块相似的功能。也可以递归搜索文件名。与之前基于<code class="fe nk nl nm nn b">os</code>的解决方案相比，<code class="fe nk nl nm nn b">pathlib</code>拥有更少的代码，提供了更面向对象的解决方案。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">搜索文件名—路径库</p></figure><h2 id="d8e3" class="mm mn it bd mo mp mq dn mr ms mt dp mu li mv mw mx lm my mz na lq nb nc nd ne bi translated">摆弄文件路径</h2><p id="fb78" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">使用文件路径是我们做的另一项常见任务。它可以得到一个文件的相对路径和绝对路径。它也可以是连接多个路径和寻找父目录等。</p><p id="9639" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="no">相对和绝对路径</em> </strong></p><p id="1704" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nk nl nm nn b">os</code>和<code class="fe nk nl nm nn b">pathlib</code>都提供了获取文件或目录的相对路径和绝对路径的函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">文件的相对和绝对路径</p></figure><p id="075d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="no">加入路径</em> </strong></p><p id="76da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是我们如何独立于环境连接<code class="fe nk nl nm nn b">os</code>和<code class="fe nk nl nm nn b">pathlib</code>中的路径。<code class="fe nk nl nm nn b">pathlib</code>使用斜杠创建子路径。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">连接文件路径</p></figure><p id="7bfd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="no">获取父目录</em> </strong></p><p id="0746" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nk nl nm nn b">dirname()</code>是在<code class="fe nk nl nm nn b">os</code>中获取父目录的功能，而在<code class="fe nk nl nm nn b">pathlib</code>中，你只需使用<code class="fe nk nl nm nn b">Path().parent</code>就可以获取父文件夹。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">获取父文件夹</p></figure><h2 id="233d" class="mm mn it bd mo mp mq dn mr ms mt dp mu li mv mw mx lm my mz na lq nb nc nd ne bi translated">os 对 s. pathlib</h2><p id="9a88" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">最后，我想简单说一下<code class="fe nk nl nm nn b">os</code>和<code class="fe nk nl nm nn b">pathlib</code>。正如<a class="ae ky" href="https://docs.python.org/3/library/pathlib.html" rel="noopener ugc nofollow" target="_blank"> Python 文档</a>所说，<code class="fe nk nl nm nn b">pathlib</code>比<code class="fe nk nl nm nn b">os</code>更面向对象。它将每个文件路径表示为适当的对象，而不是字符串。这给开发者带来了很多好处，比如更容易连接多个路径，在不同的操作系统上更加一致，方法可以直接从对象中访问。</p><p id="dd39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这篇文章能提高你处理文件的效率。</p><h2 id="1f31" class="mm mn it bd mo mp mq dn mr ms mt dp mu li mv mw mx lm my mz na lq nb nc nd ne bi translated">参考:</h2><div class="ov ow gp gr ox oy"><a href="https://realpython.com/read-write-files-python/#buffered-binary-file-types" rel="noopener  ugc nofollow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd iu gy z fp pd fr fs pe fu fw is bi translated">用 Python 读写文件(指南)-真正的 Python</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">在本教程中，您将学习如何在 Python 中读写文件。您将涵盖从文件是什么…</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">realpython.com</p></div></div><div class="ph l"><div class="pi l pj pk pl ph pm ks oy"/></div></div></a></div><div class="ov ow gp gr ox oy"><a href="https://treyhunner.com/2018/12/why-you-should-be-using-pathlib/#:~:text=The%20os%20module%20is%20a,nested%20string%2Diful%20function%20calls." rel="noopener  ugc nofollow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd iu gy z fp pd fr fs pe fu fw is bi translated">为什么应该使用 pathlib</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">几年前当我发现 Python 的新 pathlib 模块时，我最初认为它是一个稍微更…</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">treyhunner.com</p></div></div><div class="ph l"><div class="pn l pj pk pl ph pm ks oy"/></div></div></a></div></div></div>    
</body>
</html>