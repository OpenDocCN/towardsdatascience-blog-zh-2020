<html>
<head>
<title>Managing dependencies between data pipelines in Apache Airflow &amp; Prefect</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">管理 Apache Airflow &amp; Prefect 中数据管道之间的依赖关系</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/managing-dependencies-between-data-pipelines-in-apache-airflow-prefect-f4eba65886df?source=collection_archive---------15-----------------------#2020-09-04">https://towardsdatascience.com/managing-dependencies-between-data-pipelines-in-apache-airflow-prefect-f4eba65886df?source=collection_archive---------15-----------------------#2020-09-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b0d7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">管理工作流之间依赖关系的简单方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a0eb00731b25af64f3be03973fae6c0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gfgM1ggVUzE_cNv0"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">凯利·西克玛在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="1bd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated"><span class="l lw lx ly bm lz ma mb mc md di">如果</span>你曾经为相互依赖的业务流程构建过数据管道，你可能会注意到，将公司的所有业务逻辑整合到一个单一的工作流程中并不能很好地工作，而且很快会变成一场维护的噩梦。许多工作流调度系统允许我们管理单个数据管道内的依赖关系，但它们不支持我们管理工作流之间的<strong class="lb iu">依赖关系。</strong></p><p id="5bd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解决这个问题的一个自然方法是将一个大管道分成许多小管道，并以某种父子关系协调它们之间的依赖关系。然而，有许多可能的方法来解决这个问题，我想分享一个对我很有效的简单方法。我希望它可以帮助您管理数据管道之间的依赖关系。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="d062" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">气流组织如何试图解决这个问题</h1><p id="2452" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">在 GoDataDriven 的两位数据工程师编写的关于 Apache Airflow [1]的书<a class="ae ky" href="https://www.manning.com/books/data-pipelines-with-apache-airflow" rel="noopener ugc nofollow" target="_blank">中，有一章是关于管理依赖关系的<strong class="lb iu">。他们是这样总结这个问题的:</strong></a></p><blockquote class="ni nj nk"><p id="dcc4" class="kz la nl lb b lc ld ju le lf lg jx lh nm lj lk ll nn ln lo lp no lr ls lt lu im bi translated">“Airflow 管理单个 DAG 内任务<strong class="lb iu">之间的依赖关系，但是<strong class="lb iu">它不提供 DAG 间依赖关系的机制</strong>。”</strong></p></blockquote><h2 id="549a" class="np mm it bd mn nq nr dn mr ns nt dp mv li nu nv mx lm nw nx mz lq ny nz nb oa bi translated">子标签</h2><p id="c2bd" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">组织相互依赖的数据管道的一般问题是众所周知的，人们试图解决它的一种方法是使用<strong class="lb iu">子标记</strong>抽象。将工作流组织成子标签最初看起来是个好主意，但是很快<strong class="lb iu">导致了许多问题</strong>:</p><ul class=""><li id="1393" class="ob oc it lb b lc ld lf lg li od lm oe lq of lu og oh oi oj bi translated">一个子 Dag 被解释为父数据管道中的图中的一个节点，即使该子 DAG 可能由许多任务组成</li><li id="e754" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated">这意味着子 DAG 中的每个任务一次按顺序运行一个，这可能会导致调度过程中的死锁。</li></ul><p id="6858" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是<a class="ae ky" href="https://www.astronomer.io/guides/subdags/" rel="noopener ugc nofollow" target="_blank">另一个引用</a> [2]很好地总结了关于子标签有用性的讨论:</p><blockquote class="ni nj nk"><p id="aa73" class="kz la nl lb b lc ld ju le lf lg jx lh nm lj lk ll nn ln lo lp no lr ls lt lu im bi translated">天文学家强烈建议远离子袋。</p></blockquote><h2 id="5062" class="np mm it bd mn nq nr dn mr ns nt dp mv li nu nv mx lm nw nx mz lq ny nz nb oa bi translated">外部任务传感器</h2><p id="0c84" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">另一个想法是在父 DAG 中使用一个<a class="ae ky" href="https://airflow.apache.org/docs/stable/_api/airflow/sensors/external_task_sensor/index.html" rel="noopener ugc nofollow" target="_blank">传感器</a>,它定期探测子 DAG 的执行状态。这似乎是一个比子包更好的主意。然而，<strong class="lb iu">它只在父 DAG 和子 DAG 之间的时间表对齐的情况下才起作用</strong>，这是一个非常强的假设，在我的情况下<strong class="lb iu">几乎从未为真</strong>。想象一下，当您手动<em class="nl">触发这个父 DAG 时会发生什么？它将永远运行，直到超时，因为子 DAG 不按相同的计划运行。</em></p><h2 id="7910" class="np mm it bd mn nq nr dn mr ns nt dp mv li nu nv mx lm nw nx mz lq ny nz nb oa bi translated">TriggerDagRunOperator</h2><p id="42cc" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">另一种方式是从父 DAG 触发子 DAG。我更喜欢这个想法，因为:</p><ul class=""><li id="218d" class="ob oc it lb b lc ld lf lg li od lm oe lq of lu og oh oi oj bi translated">不存在产生死锁的风险</li><li id="8ac8" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated">它还会在管道被意外触发时运行，例如。通过手动触发器。</li></ul><p id="0818" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不过，当我在 Airflow 中尝试时，我发现当前的<a class="ae ky" href="https://airflow.apache.org/docs/stable/_modules/airflow/operators/dagrun_operator.html" rel="noopener ugc nofollow" target="_blank"><em class="nl">TriggerDagRunOperator</em></a>实现是以一种<em class="nl">一劳永逸</em>的方式工作的。这意味着父 DAG 不会等到触发的子 DAG 完成后才开始下一个任务！如果我们希望管理数据管道之间的依赖关系，这不是我们想要的。</p><p id="a2aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了说明这一点，让我们看看下面的管道:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/e782faf60214cbb2e5bc353477acf23e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vcjx09THONd48wL_17l2gQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="b8ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们将<code class="fe oq or os ot b">TriggerDagRunOperator</code>用于父 DAG 中的<em class="nl">业务逻辑层</em>,它将触发子 DAG 的 DagRun，但随后它将立即启动<em class="nl">数据集市</em>任务，然后等待子 DAG 中的所有<code class="fe oq or os ot b">bus_logic_ETL_x</code>任务完成。</p><h2 id="9d64" class="np mm it bd mn nq nr dn mr ns nt dp mv li nu nv mx lm nw nx mz lq ny nz nb oa bi translated">我用气流解决的方法</h2><p id="47c8" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">我的解决方案是:</p><ul class=""><li id="992a" class="ob oc it lb b lc ld lf lg li od lm oe lq of lu og oh oi oj bi translated">在每个子 DAG 的末尾添加一个虚拟任务<code class="fe oq or os ot b">finish</code></li><li id="766a" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated">实施<code class="fe oq or os ot b">WaitForCompletion</code>传感器，该传感器在气流元数据数据库中检查子 DAG 的最后 DagRun 的状态。我们将子 DAG 的最后一个 DagRun 标识如下:它必须以<code class="fe oq or os ot b">"trig__"</code>开头，因为每个由外部 DAG 触发的 DagRun 都是这样命名的。然后，我们按照执行日期降序排列这些 DagRun，并使用<code class="fe oq or os ot b">LIMIT 1</code>获得最后一个→这正是我们想要寻找的 Dag run。</li><li id="5c9e" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated">在这个传感器中，我们探测这个 DagRun 中的<code class="fe oq or os ot b">finish</code>任务的状态。如果是<code class="fe oq or os ot b">success</code>，则传感器完成任务，并可以继续执行父管道中的<em class="nl">数据集市</em>任务。但是只要<strong class="lb iu">不是<em class="nl">成功</em> </strong>，这就意味着要么任务仍在运行，要么它失败了。在这两种情况下，这意味着我们不能继续进行<em class="nl">数据集市</em>任务。</li></ul><p id="5347" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是传感器的实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="d016" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我在父 DAG 中使用该传感器的方式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ou ov l"/></div></figure><h1 id="2856" class="ml mm it bd mn mo ow mq mr ms ox mu mv jz oy ka mx kc oz kd mz kf pa kg nb nc bi translated">提督是如何处理这个问题的</h1><p id="d1be" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">Prefect 包括许多开箱即用的有用抽象。其中之一是<code class="fe oq or os ot b">FlowRunTask</code>，它包含一个参数<code class="fe oq or os ot b">wait=True</code>，该参数将与我的<code class="fe oq or os ot b">WaitForCompletion</code>在气流中具有相同的效果，而无需我实现任何执行定期数据库查找的传感器。这将:</p><ul class=""><li id="4c5d" class="ob oc it lb b lc ld lf lg li od lm oe lq of lu og oh oi oj bi translated">触发子流程</li><li id="3c74" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated">等待子流程完成，然后再继续下一个任务。</li></ul><h2 id="6c7d" class="np mm it bd mn nq nr dn mr ns nt dp mv li nu nv mx lm nw nx mz lq ny nz nb oa bi translated">主流(<em class="pb">即父流</em>)</h2><p id="97f6" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">父流的整个实现就这么简单:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ou ov l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/f92438ab06b1164eeb58262a76166c31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GLAoSAUs72MV8d4QgI2LQw.png"/></div></div></figure><p id="5bed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们通过运行<code class="fe oq or os ot b">flow.visualize</code>来可视化这个流，我们可以看到子流甚至以不同的方式被可视化，以便容易地区分普通任务和由<code class="fe oq or os ot b">FlowRunTask</code> ( <em class="nl">或其他类型的任务(如 ex)触发的流。映射的任务</em>)。</p><h2 id="dc61" class="np mm it bd mn nq nr dn mr ns nt dp mv li nu nv mx lm nw nx mz lq ny nz nb oa bi translated">子流程</h2><p id="f2d7" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">我还创建了一些非常基本的子流，这样我们就可以运行一个完整的示例，并在 UI 中看到输出。在下面的脚本中，您可以看到三个子流程，每个子流程有三个任务:</p><ul class=""><li id="9414" class="ob oc it lb b lc ld lf lg li od lm oe lq of lu og oh oi oj bi translated"><code class="fe oq or os ot b">staging_area</code>流量</li><li id="ba5e" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated"><code class="fe oq or os ot b">business_logic_layer</code>流量</li><li id="a109" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated"><code class="fe oq or os ot b">data_mart</code>流量</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ou ov l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ou ov l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="06cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们通过注册父流(<code class="fe oq or os ot b">MasterFlow</code>)和三个子流来运行完整的示例，并确认流之间的依赖关系如预期的那样工作。</p><div class="kj kk kl km gt ab cb"><figure class="pd kn pe pf pg ph pi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/89411950743040752160849a2703cda8.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/1*53d9bvCemg00ytTnh_qK0A.png"/></div></figure><figure class="pd kn pj pf pg ph pi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/149fa42a81eedd390c95183b43fd8217.png" data-original-src="https://miro.medium.com/v2/resize:fit:658/format:webp/1*luZNOI_aeFhPB1Nxly4uMw.png"/></div></figure><figure class="pd kn pk pf pg ph pi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/8807dc3517e40764daa36b27a2f4a178.png" data-original-src="https://miro.medium.com/v2/resize:fit:664/format:webp/1*OFgVqC1YU3sOMkdWpk-8WQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk pl di pm pn translated">完美的云用户界面:由父流(主流)按照我们指定的顺序触发的子流——图片由作者提供</p></figure></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi po"><img src="../Images/4e76f88a54c22a422b42c2d246fc44c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:868/format:webp/1*9zjlcCTer_Es2_getgavBg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">完美云用户界面:父流(主流)按预期最后完成，因为它等待子流的完成—图片由作者提供</p></figure><p id="5b94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只有在<em class="nl">暂存区</em>和<em class="nl">业务逻辑层</em>流程都完成后，我们才能确认依赖关系得到了尊重，并且<em class="nl">数据集市</em>才开始运行。</p><p id="2696" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果出现故障，我们可以很容易地导航到相应的子流来检查日志:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pp"><img src="../Images/6be0137576c00769610f7b8070e863e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EGsmkUlsrVos7RxZJfs06A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Prefect Cloud UI:检查来自子流的日志——按作者排序的图片</p></figure><h1 id="078b" class="ml mm it bd mn mo ow mq mr ms ox mu mv jz oy ka mx kc oz kd mz kf pa kg nb nc bi translated">如何调度相互依赖的数据管道？</h1><p id="9be3" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">为了正确地构建和调度这些父子依赖关系，我们可以使用“主”数据管道(<em class="nl">也可以称之为“父数据管道”或“协调数据管道”</em>)，如上例所示，而<strong class="lb iu">只调度那些父管道</strong>。因为子流是直接从父流触发的，所以不需要对它们进行调度。</p><p id="5e70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用一个<strong class="lb iu">具体的例子</strong>来展示一下。让我们假设，目前，这些子流具有以下执行运行时:</p><ul class=""><li id="689f" class="ob oc it lb b lc ld lf lg li od lm oe lq of lu og oh oi oj bi translated"><strong class="lb iu">暂存区</strong> : 2.5 小时</li><li id="d9b9" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated"><strong class="lb iu">业务逻辑</strong> : 1.5 小时</li><li id="cb0d" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated"><strong class="lb iu">数据集市</strong> : 2 小时。</li></ul><p id="9a72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着如果我们安排<code class="fe oq or os ot b">MasterFlow</code>在晚上 2 点运行，它将在凌晨 2 点运行<em class="nl"> staging_area </em>开始，然后<em class="nl"> business_logic </em>将在凌晨 4:30 开始，<em class="nl"> data_mart </em>将在早上 6 点开始，整个 ETL 将在早上 8 点完成。</p><p id="a4c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要实现这一点，我们只需在第 6 行和第 9 行向<code class="fe oq or os ot b">MasterFlow</code>添加一个调度，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="33ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注:</strong>此时间表适用于 UTC。要使用时区特定的计划，请使用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ou ov l"/></div></figure><h1 id="dbd5" class="ml mm it bd mn mo ow mq mr ms ox mu mv jz oy ka mx kc oz kd mz kf pa kg nb nc bi translated">这种主流方法的好处是什么？</h1><p id="c417" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">假设您想要修改<em class="nl">业务逻辑层</em>并向其添加一个任务:通过使用这种方法，您可以在不影响<em class="nl">临时区域</em>和<em class="nl">数据集市</em>工作流的情况下进行修改。你不需要重新安排任何事情，你也不会陷入任何僵局。</p><h2 id="d6fc" class="np mm it bd mn nq nr dn mr ns nt dp mv li nu nv mx lm nw nx mz lq ny nz nb oa bi translated">从用户的角度来看，哪种实现更容易？</h2><p id="d2b9" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">总的来说，我发现完美的实现更容易，因为我不必编写任何定制的传感器逻辑来正确反映数据管道之间的依赖关系，并且它开箱即用。在这些抽象的设计中，它显示了很多远见。</p><p id="5d68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提督社区也在讨论 Github 第<a class="ae ky" href="https://github.com/PrefectHQ/prefect/issues/1745" rel="noopener ugc nofollow" target="_blank">期</a>【3】中的子流程——如果你有兴趣的话，请继续关注。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="53b7" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">结论</h1><p id="3d13" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">在本文中，我们研究了<strong class="lb iu">如何管理数据管道</strong>之间的依赖性。我们展示了历史上气流是如何解决这个问题的。</p><p id="538b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我提出了一个解决这个问题的简单方法，它基于一个原则:<strong class="lb iu">创建一个主数据管道来调度和触发子工作流</strong>，同时确保当被触发时，<strong class="lb iu">主数据管道等待</strong>直到子工作流完成，然后再触发下一个工作流。</p><p id="dd4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">“触发+等待”范式</strong>似乎比根据时间表调整相互依赖的管道更安全，并且让我们以简单的方式管理工作流之间的依赖关系。</p><p id="2d9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读！如果这篇文章有帮助，请随时关注我的下一篇文章。</p><p id="931f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">参考文献:</strong></p><p id="48cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[1]“带有阿帕奇气流的数据管道”——<em class="nl">巴斯·p·哈伦斯拉克和朱利安·鲁特格尔·德·鲁特</em></p><p id="c7bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[2]天文学家博客:<a class="ae ky" href="https://www.astronomer.io/guides/subdags/" rel="noopener ugc nofollow" target="_blank">https://www.astronomer.io/guides/subdags/</a></p><p id="1919" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[3]关于子流的提督社区:<a class="ae ky" href="https://github.com/PrefectHQ/prefect/issues/1745" rel="noopener ugc nofollow" target="_blank">https://github.com/PrefectHQ/prefect/issues/1745</a></p></div></div>    
</body>
</html>