<html>
<head>
<title>Creating custom plotting functions with matplotlib</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用matplotlib创建自定义绘图函数</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/creating-custom-plotting-functions-with-matplotlib-1f4b8eba6aa1?source=collection_archive---------5-----------------------#2020-04-27">https://towardsdatascience.com/creating-custom-plotting-functions-with-matplotlib-1f4b8eba6aa1?source=collection_archive---------5-----------------------#2020-04-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="abac" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一个简短的教程，学习如何创建模块化函数，包括使用matplotlib绘图</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/538b791b377b5f943deed346558ba01d.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*ORWXNAlgLR_1rGSQHcWvxw.png"/></div></figure><p id="0092" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">TLDR:使用以下语法定义您自己的函数，这些函数涉及绘制到特定的轴上:</p><pre class="kg kh ki kj gt lj lk ll lm aw ln bi"><span id="f315" class="lo lp iq lk b gy lq lr l ls lt">def custom_plot(x, y, ax=None, **plt_kwargs):<br/>    if ax is None:<br/>        ax = plt.gca()<br/>    ax.plot(x, y, **plt_kwargs) ## example plot here<br/>    return(ax)</span><span id="9d99" class="lo lp iq lk b gy lu lr l ls lt">def multiple_custom_plots(x, y, ax=None, plt_kwargs={}, sct_kwargs={}):<br/>    if ax is None:<br/>        ax = plt.gca()<br/>    ax.plot(x, y, **plt_kwargs) #example plot1<br/>    ax.scatter(x, y, **sct_kwargs) #example plot2<br/>    return(ax)</span></pre><p id="6be7" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">你可以在<a class="ae lv" href="https://github.com/maticalderini/tutorial_matplotlibCustomPlots" rel="noopener ugc nofollow" target="_blank">这个链接</a>找到原始代码库。</p><h1 id="6a26" class="lw lp iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">介绍</h1><p id="34d2" class="pw-post-body-paragraph kn ko iq kp b kq mn jr ks kt mo ju kv kw mp ky kz la mq lc ld le mr lg lh li ij bi translated">在之前的一篇文章中，我向你展示了如何更好地组织你的数据。我们看到了如何使用支线剧情整齐地显示不同的情节，如何添加自由浮动轴，以及如何使用GridSpec轻松地创建轴的平铺组织。</p><p id="ebac" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">因为这篇文章的重点是总体图的一般结构和表示，所以绘图本身非常简单，因为它们只使用了一个预定义的matplotlib函数，比如带有默认参数的<code class="fe ms mt mu lk b">.plot</code>或<code class="fe ms mt mu lk b">.hist</code>。通常，在您在前一篇文章中学习的漂亮的平铺结构中，您将需要绘制自己的特定绘图，该绘图结合了来自不同类型的基本绘图函数的信息以及对其他一些数据生成或数据处理函数的调用。例如，在顶部绘制随机样本的分布及其相应的理论密度函数。</p><p id="1e14" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在这里，我将向您展示如何创建您自己的自定义绘图函数，可以通过在您组织的绘图中调用这些函数来轻松使用这些函数，如下所示:</p><pre class="kg kh ki kj gt lj lk ll lm aw ln bi"><span id="12ce" class="lo lp iq lk b gy lq lr l ls lt">fig, axes = plt.subplots(number_of_subplots)<br/>for ax in axes:<br/>    my_custom_plotting_function(ax=ax, function_kwargs)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi mv"><img src="../Images/5fdb6f63de626d1f29f65b3aa3640648.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qoQfykkyANPfnxxzAvpI6Q.png"/></div></div></figure><p id="a40f" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">加上支线剧情的良好组织，这将有助于您最大限度地利用matplotlib上的静态绘图(预示着动力学绘图后续教程…也许……)并利用来自不同地块的信息来分享您的数据的综合情况。</p><h1 id="6765" class="lw lp iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">基本语法</h1><h1 id="a377" class="lw lp iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">传递轴</h1><p id="f98e" class="pw-post-body-paragraph kn ko iq kp b kq mn jr ks kt mo ju kv kw mp ky kz la mq lc ld le mr lg lh li ij bi translated">在图形中拥有一系列自定义图的第一步是能够将单个自定义图连接到单个轴。第一步是能够将我们想要绘制的轴传递给我们的自定义函数。这可以像这样简单地完成:</p><pre class="kg kh ki kj gt lj lk ll lm aw ln bi"><span id="b3fb" class="lo lp iq lk b gy lq lr l ls lt">def custom_plot(x, y, ax=None, **plt_kwargs):<br/>    if ax is None:<br/>        ax = plt.gca()<br/>    ax.plot(x, y, **plt_kwargs) ## example plot here<br/>    return(ax)</span></pre><p id="3756" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我在那里做了什么？这里第一个相关的部分是<code class="fe ms mt mu lk b">ax</code>的论证。如果你以前用过seaborn，你可能已经知道如何使用它了。本质上，<code class="fe ms mt mu lk b">ax</code>将获取您想要绘制的轴对象。这可以是一个子图轴或一个简单的自由浮动的嵌入轴。这个想法是，情节的组织部分将在这个功能之外处理，可能由另一个功能处理。</p><p id="58d7" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">为什么<code class="fe ms mt mu lk b">ax</code>会默认为<code class="fe ms mt mu lk b">None</code>？这可以用下面的句子来更好地回答:</p><pre class="kg kh ki kj gt lj lk ll lm aw ln bi"><span id="faee" class="lo lp iq lk b gy lq lr l ls lt">if ax is None:<br/>        ax = plt.gca()</span></pre><p id="104e" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们看到，如果在<code class="fe ms mt mu lk b">ax</code>中没有提供axes对象，它默认为<code class="fe ms mt mu lk b">None</code>并触发这个<code class="fe ms mt mu lk b">if</code>条件。在这种情况下，由于没有给定轴，默认情况下，该函数将查找当前图形中使用的最后一个轴，或者如果没有可用的轴，则使用函数<code class="fe ms mt mu lk b">.gca</code>(代表<em class="na">获取当前轴</em>)创建一个轴，并将其用作绘图轴。在函数的最后，我们还返回这个ax，以防我们想用它进行其他定制(在某些情况下不是必需的，但很实用)。</p><p id="0e9d" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">让我们测试一下，首先在不指定轴的情况下绘图，然后提供一个特定的轴:</p><pre class="kg kh ki kj gt lj lk ll lm aw ln bi"><span id="3987" class="lo lp iq lk b gy lq lr l ls lt"># Without providing axes (default to None -&gt; gca())<br/>plt.figure(figsize=(10, 5))<br/>custom_plot([1, 2], [10, 20])<br/>plt.title('Our custom plot with no axes provided (defaults to .gca())')<br/>plt.xlabel('x')<br/>plt.ylabel('y')<br/>plt.show()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi nb"><img src="../Images/b5de7ea968fde213a0f2a460f5ad1809.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8h5XnFU-XT8JA09gOtrXIQ.png"/></div></div></figure><pre class="kg kh ki kj gt lj lk ll lm aw ln bi"><span id="1a5d" class="lo lp iq lk b gy lq lr l ls lt"># Providing the axes<br/>fig, axes = plt.subplots(2, figsize=(10, 5))</span><span id="2ba2" class="lo lp iq lk b gy lu lr l ls lt"># Plotting with our function<br/>custom_plot([2, 3], [4, 15], ax=axes[0])<br/>axes[0].set(xlabel='x', ylabel='y', title='This is our custom plot on the specified axes')</span><span id="6db5" class="lo lp iq lk b gy lu lr l ls lt"># Example plot to fill the second subplot (nothing to do with our function)<br/>axes[1].hist(np.random.normal(size=100))<br/>axes[1].set_title('This plot has nothing to do with our function. Just a histogram of some random numbers')</span><span id="d30e" class="lo lp iq lk b gy lu lr l ls lt">plt.tight_layout() #This to avoid overlap of labels and titles across plots<br/>plt.show()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi nb"><img src="../Images/206c6d0c798721f08a9ad642f7566410.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OCl3te0am_-upQ2GjJigdw.png"/></div></div></figure><h1 id="a30f" class="lw lp iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">传递图的关键字参数</h1><p id="b0c2" class="pw-post-body-paragraph kn ko iq kp b kq mn jr ks kt mo ju kv kw mp ky kz la mq lc ld le mr lg lh li ij bi translated">到目前为止还不错；我们可以创建一个函数来绘制数据，并可以将它连接到我们的绘图的特定轴(如果没有提供轴，它甚至会自己处理)。那么<code class="fe ms mt mu lk b">**plt_kwargs</code>呢？</p><p id="670a" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">如果您不习惯在函数中使用<code class="fe ms mt mu lk b">**kwargs</code>(如在关键字参数中)(参数的实际名称并不重要，您可以将其命名为<code class="fe ms mt mu lk b">**kwargs</code>、<code class="fe ms mt mu lk b">**plt_kwargs</code>、<code class="fe ms mt mu lk b">**literally_anything_else</code>，只要您加上双星号“**”)，那么首先创建并使用一个没有<code class="fe ms mt mu lk b">**kwargs</code>的新函数会更容易解释。</p><p id="af4e" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">顺便说一句，如果你以前真的没有见过这种类型的星号符号，那么在python中使用单星号<code class="fe ms mt mu lk b">*</code>和双星号<code class="fe ms mt mu lk b">**</code>在很多情况下都非常有用，无论是在函数内部还是外部，绝对值得在google上搜索一下(甚至可以写一篇关于它的博文....可能...).无论如何，回到我们没有<code class="fe ms mt mu lk b">**kwargs</code>的<code class="fe ms mt mu lk b">custom_plot</code>的例子:</p><pre class="kg kh ki kj gt lj lk ll lm aw ln bi"><span id="c3cf" class="lo lp iq lk b gy lq lr l ls lt">def no_kwargs_plot(x, y, ax=None):<br/>    if ax is None:<br/>        ax = plt.gca()<br/>    ax.plot(x, y) ## example plot here<br/>    return(ax)</span><span id="780b" class="lo lp iq lk b gy lu lr l ls lt">plt.figure(figsize=(10, 5))<br/>no_kwargs_plot([1, 2], [10, 20])<br/>plt.show()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi nb"><img src="../Images/94fec051e8768027864e514fb3372330.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nA9adDQezFRoMTO-hHltZw.png"/></div></div></figure><p id="1eb7" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">没有错误，没有问题…但是，如果你想让线条变粗呢？通常在<code class="fe ms mt mu lk b">.plot()</code>中，我们会简单地将参数<code class="fe ms mt mu lk b">linewidth</code>设置为一个更厚的值。我们可以将<code class="fe ms mt mu lk b">linewidth</code>添加到<code class="fe ms mt mu lk b">no_kwargs_plot</code>的输入列表中，然后像这样将其传递给<code class="fe ms mt mu lk b">.plot()</code>:</p><pre class="kg kh ki kj gt lj lk ll lm aw ln bi"><span id="01cd" class="lo lp iq lk b gy lq lr l ls lt">def no_kwargs_plot(x, y, ax=None, linewidth=1):<br/>    if ax is None:<br/>        ax = plt.gca()<br/>    ax.plot(x, y, linewidth) ## example plot here</span></pre><p id="5ad6" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">那会解决问题。但是所有其他可能的论点呢？剧情()。必须将它们连同它们的默认值一起写在我们的函数中，这将会很长，并且不太实际:</p><pre class="kg kh ki kj gt lj lk ll lm aw ln bi"><span id="52b3" class="lo lp iq lk b gy lq lr l ls lt">def no_kwargs_plot(x, y, ax=None, linewidth=1, other=1,...):<br/>    if ax is None:<br/>        ax = plt.gca()<br/>    ax.plot(x, y, linewidth, other,....) ## example plot here</span></pre><p id="14de" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这就是使用<code class="fe ms mt mu lk b">**</code>符号(<code class="fe ms mt mu lk b">**kwargs</code>)有用的地方。当用于自由键值元素时，比如我们函数中的孤立输入(在我们的例子中，这些输入与预定义的参数x、y和ax无关)<code class="fe ms mt mu lk b">**name</code>会将所有这些元素打包到一个字典中，并将它们存储在变量<code class="fe ms mt mu lk b">name</code>中。</p><p id="d292" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">例如，如果我们将绘图函数用作<code class="fe ms mt mu lk b">custom_plot(x=xdata, y=ydata, ax=axes[0], linewidth=2, c='g')</code>，那么得到的<code class="fe ms mt mu lk b">plt_kwargs</code>字典将是<code class="fe ms mt mu lk b">{'linewidth':2, 'c':'g'}</code>。如果这还不太清楚，看看下面的示例代码，输出(&gt; &gt;)和下面的模式:</p><pre class="kg kh ki kj gt lj lk ll lm aw ln bi"><span id="0654" class="lo lp iq lk b gy lq lr l ls lt">def print_kwargs_only(x, y, ax=None, **plt_kwargs):<br/>    print(plt_kwargs) #to print the dictionary with all the orphan kwargs</span><span id="3fba" class="lo lp iq lk b gy lu lr l ls lt">print_kwargs_only(x=[1, 2], y=[10, 20], not_xyax=1,   random_orphan_kwarg='so lonely', linewidth=2, c='g')</span><span id="195f" class="lo lp iq lk b gy lu lr l ls lt">&gt;&gt; {'not_xyax': 1, 'random_orphan_kwarg': 'so lonely', 'linewidth': 2, 'c': 'g'}</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/26f27edb7f0ea4babea9c4a898cac63c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*IC_FgduXII6PC8Xnj1AT7A.png"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi nd"><img src="../Images/135de7754cd84bed635c0f1dd81fed55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P0E8Z4MMC1UVXajYZOuYOg.png"/></div></div></figure><p id="70d3" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">因此，使用<code class="fe ms mt mu lk b">**</code>解决了将所有可能的绘图输入放入我们的函数中的问题，而不需要显式地预定义它们，并让它们准备好在字典中使用。但是，这本补充关键字参数词典是如何使用的呢？</p><p id="7dd4" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">之前，我提到过<code class="fe ms mt mu lk b">**</code>在自由元素上使用时表现得像一个打包函数。当你在一个字典上使用<code class="fe ms mt mu lk b">**</code>时(不管它是否被<code class="fe ms mt mu lk b">**</code>打包过)，实际上<code class="fe ms mt mu lk b">**</code>会做与之前相反的动作:它会将字典解包成不同的自由元素。在<code class="fe ms mt mu lk b">custom_function</code>中，当我们在<code class="fe ms mt mu lk b">.plot()</code>、<em class="na">即</em> <code class="fe ms mt mu lk b">ax.plot(x, y, **plt_kwargs)</code>中编写<code class="fe ms mt mu lk b">**plt_kwargs</code>时，我们实际上是在要求python获取字典<code class="fe ms mt mu lk b">plt_kwargs</code>并将它的所有键值对分别解包到<code class="fe ms mt mu lk b">.plot()</code>函数中作为单独的输入。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi ne"><img src="../Images/b24f50f394684aafe19588a998130ca5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IUyaKxZTyVz2hqF8SNsdww.png"/></div></div></figure><p id="ec9f" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这样，在不知道将使用多少和哪些绘图定制的情况下，我们可以将它们全部传递给将进行绘图的函数部分。</p><p id="cb9a" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们可以再次使用我们最初的<code class="fe ms mt mu lk b">custom_plot</code>函数看到这一点(您可能注意到，这次我使用了该函数返回的轴来展示如何使用它):</p><pre class="kg kh ki kj gt lj lk ll lm aw ln bi"><span id="2f99" class="lo lp iq lk b gy lq lr l ls lt">plt.figure(figsize=(10, 5))<br/>out_ax = custom_plot([1, 2], [10, 20], linewidth=5, c='g')<br/>out_ax.set(xlabel='xlabel', ylabel='ylabel', title='Testing out the usefulness of **kwargs')<br/>plt.show()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi nb"><img src="../Images/0f2d78c614aab9bb7d3399f5d48c72eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SHXntrWoNi_zXhgXsdfYGA.png"/></div></div></figure><h1 id="8eaf" class="lw lp iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">基本语法的扩展</h1><p id="7c49" class="pw-post-body-paragraph kn ko iq kp b kq mn jr ks kt mo ju kv kw mp ky kz la mq lc ld le mr lg lh li ij bi translated">这就是基本的语法。有了这些，你应该已经能够开始创作一些更有趣的情节了。</p><p id="c957" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">不过在使用ham之前，我们需要注意一个你在使用<code class="fe ms mt mu lk b">**kwargs</code>时可能会遇到的潜在问题。也就是说，如果您在<code class="fe ms mt mu lk b">custom_plot</code>函数中进行多个绘图会怎么样？例如，如果你正在绘制两条线，其中一条应该是虚线，而另一条是实线。<code class="fe ms mt mu lk b">**kwargs</code>怎么知道哪个论点进入了哪个情节？</p><p id="2291" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">答案是“<code class="fe ms mt mu lk b">**kwargs</code>包装机”不能再工作了，需要更换，但是“<code class="fe ms mt mu lk b">**kwargs</code>拆包机”可以正常工作。我这么说是什么意思？让我们定义一个名为<code class="fe ms mt mu lk b">multiple_custom_plots</code>的新函数来阐明它:</p><pre class="kg kh ki kj gt lj lk ll lm aw ln bi"><span id="6df0" class="lo lp iq lk b gy lq lr l ls lt">def multiple_custom_plots(x, y, ax=None, plt_kwargs={}, sct_kwargs={}):<br/>    if ax is None:<br/>        ax = plt.gca()<br/>    ax.plot(x, y, **plt_kwargs)<br/>    ax.scatter(x, y, **sct_kwargs)<br/>    return(ax)</span></pre><p id="78e4" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这里有什么不同，我们应该如何使用它？首先，看看可能的输入列表。现在，我们没有了<code class="fe ms mt mu lk b">**kwargs</code>，而是有了两个新的参数，一个用于我们的一个情节。此外，默认情况下，这些参数是空字典。</p><p id="3446" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">如果你听了我之前关于<code class="fe ms mt mu lk b">**kwargs</code>的解释，希望你已经很清楚了。想法是，因为我们不能要求函数自动将所有孤立输入打包到一个字典中(我们现在需要两个独立的字典)，我们将不得不自己提供预打包的每个绘图参数字典。</p><p id="9492" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">稍后用双星号使用它们与最初的<code class="fe ms mt mu lk b">custom_plot</code>没有什么不同，因为在字典上使用<code class="fe ms mt mu lk b">**</code>仍然意味着我们希望它的值被解包。我们使用空字典作为缺省值，因为如果您没有提供定制字典，我们在试图用<code class="fe ms mt mu lk b">**</code>解包它们(或缺少它们)时会遇到问题。如果没有提供任何内容，空字典本质上是用来将任何内容解包到函数中的。</p><p id="e015" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">让我们看看如何使用它:</p><pre class="kg kh ki kj gt lj lk ll lm aw ln bi"><span id="fe05" class="lo lp iq lk b gy lq lr l ls lt">plot_params = {'linewidth': 2, 'c': 'g', 'linestyle':'--'}<br/>scatter_params = {'c':'red', 'marker':'+', 's':100}<br/>xdata = [1, 2]<br/>ydata = [10, 20]</span><span id="8f65" class="lo lp iq lk b gy lu lr l ls lt">plt.figure(figsize=(10, 5))<br/>multiple_custom_plots(xdata, ydata, plt_kwargs=plot_params, sct_kwargs=scatter_params)<br/>plt.show()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi nb"><img src="../Images/6396ed57757b33bae898366b5906a6ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Pckq4hOF-f_9qN_uwbs5w.png"/></div></div></figure><h1 id="178f" class="lw lp iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">快速应用</h1><p id="a00c" class="pw-post-body-paragraph kn ko iq kp b kq mn jr ks kt mo ju kv kw mp ky kz la mq lc ld le mr lg lh li ij bi translated">因此，当要创建自定义函数来进行绘图时，上一节应该足以让您在一段时间内享受到静态绘图的乐趣。在下一节中，我将简单地给你一个使用自定义函数的绘图示例，希望能启发你去做一些自己的绘图。</p><h1 id="aaa1" class="lw lp iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">随机样本的样本容量和核密度估计</h1><p id="c99d" class="pw-post-body-paragraph kn ko iq kp b kq mn jr ks kt mo ju kv kw mp ky kz la mq lc ld le mr lg lh li ij bi translated">假设您想了解给定随机变量的样本大小如何影响对其潜在概率分布的估计。</p><p id="d52d" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">假设我们有一个连续的随机变量X，正态分布，均值为μ(μ)，标准差为σ(σ)(<em class="na">即X</em>∞N(<em class="na">μ</em>，<em class="na"> σ </em>))。我们想知道scipy的核密度估计量(kde)如何受到我们随机样本大小的影响(我们从正态分布中随机抽样的次数),方法是将其与潜在的真实概率密度分布(pdf)的估计量进行比较。</p><p id="5733" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们将通过绘制不同n值的样本本身、它们的kde和它们的潜在pdf来做到这一点。</p><pre class="kg kh ki kj gt lj lk ll lm aw ln bi"><span id="8580" class="lo lp iq lk b gy lq lr l ls lt">def sample_plot(mu=0, sigma=1, N=100, sct_kwargs={}, pdf_kwargs={}, kde_kwargs={}, ax=None):<br/>    # generate sample<br/>    sample = np.random.normal(loc=mu, scale=sigma, size=N)<br/>    <br/>    # generate pdf<br/>    xrange = mu + 5*sigma*np.linspace(-1, 1, 100)<br/>    pdf = stats.norm.pdf(xrange, loc=mu, scale=sigma)<br/>    <br/>    # generate kde<br/>    estimation = stats.gaussian_kde(sample)<br/>    kde = estimation(xrange)<br/>    <br/>    #Plotting<br/>    if ax is None:<br/>        ax = plt.gca()   <br/>    ax.scatter(sample, np.zeros_like(sample), **sct_kwargs)<br/>    ax.plot(xrange, pdf, **pdf_kwargs)<br/>    ax.plot(xrange, kde, **kde_kwargs)<br/>    return(xrange)</span></pre><p id="1fce" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">让我们一步一步地解构这个函数:</p><p id="ccc1" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">首先是投入。这里，我们将从高斯随机数生成器创建自己的数据，而不是请求数据数组。所以我们需要询问相关的统计参数μ和σ(分别为高斯分布的均值和标准差)。我们还需要问要取的样本数N。实际上，我们将在后面迭代N的不同值，以查看样本大小对估计的影响。这个想法是将样本绘制成散点，将pdf和kde绘制成常规线图。因此，我们将为它们各自的绘图参数(线宽、标记大小等)提供一个字典作为输入。).最后，我们将询问我们想要在其上绘制这三样东西的图形的轴。</p><p id="3a2b" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">该函数的第一部分将简单地从所提供的统计参数中生成大小为N的随机高斯样本。</p><p id="429e" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">代码的第二部分将创建对应于由μ和σ给出的正态分布的pdf的线图的x-y对。我们将pdf的范围限制为5个标准偏差，因为任何一边的任何其他值都将非常小。</p><p id="b2a3" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">代码的第三部分首先计算样本的kde，然后将其应用到与pdf相同的x轴上的值范围。</p><p id="af35" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">最后，在代码的第四部分，我们简单地将x轴(高度为0)上的所有采样值绘制成散点图，并将pdf和kde绘制成线图。这三个都有各自的绘图关键字参数。</p><pre class="kg kh ki kj gt lj lk ll lm aw ln bi"><span id="62ae" class="lo lp iq lk b gy lq lr l ls lt"># Sample parameters<br/>sample_sizes = (10, 20, 100, 250, 500, 2_000)<br/>mean = 100<br/>std = 15</span><span id="b881" class="lo lp iq lk b gy lu lr l ls lt"># Plotting parameters<br/>scatter_params = {'alpha':0.1, 'c':'g', 's':100, 'label':'samples'}<br/>pdf_params = {"linewidth":2, 'c':'k', 'label':'pdf'}<br/>kde_params = {"linewidth":3, 'ls':'--', 'c':'g', 'label':'kde'}</span><span id="ff8a" class="lo lp iq lk b gy lu lr l ls lt"># Plotting<br/>fig, axes = plt.subplots(6, figsize=(15, 20))<br/>for ax, n in zip(axes, sample_sizes):<br/>    sample_plot(mu=mean, sigma=std, N=n, ax=ax,<br/>                sct_kwargs=scatter_params, pdf_kwargs=pdf_params, kde_kwargs=kde_params)<br/>    ax.set_title(f'N={n}')</span><span id="46df" class="lo lp iq lk b gy lu lr l ls lt">axes[0].legend()<br/>axes[-1].set_xlabel('Sample Value', fontsize=13)<br/>plt.tight_layout()<br/>plt.savefig('finalplot')<br/>plt.show()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi mv"><img src="../Images/263d08ec26f2ecead1a3bafd17244e58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UxgpC6NjYmyIG16t7g1K1w.png"/></div></div></figure><p id="551a" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">就是这样！希望您已经学会了如何通过正确传递相应的轴和关键字参数来为函数添加绘图功能。这将有助于您拥有越来越模块化的代码来快速浏览和可视化您的数据。</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><p id="796b" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><em class="na">原载于2020年4月28日</em><a class="ae lv" href="https://maticalderini.github.io/blog/tutorial/2020/04/27/customPlots.html" rel="noopener ugc nofollow" target="_blank"><em class="na">https://matic derini . github . io</em></a><em class="na">。</em></p></div></div>    
</body>
</html>