<html>
<head>
<title>What You Should Know About Unsigned, Signed Integers and Casting in Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于无符号、有符号整数和 Rust 中的造型，你应该知道什么</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/unsinged-signed-integers-and-casting-in-rust-9a847bfc398f?source=collection_archive---------16-----------------------#2020-07-24">https://towardsdatascience.com/unsinged-signed-integers-and-casting-in-rust-9a847bfc398f?source=collection_archive---------16-----------------------#2020-07-24</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="cccb" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">理解符号和幅度、一的补码和二的补码</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/07e98d125e3754b564aef6bd1d62ee74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RcoaOw8iSS7_hBDzWf7O6g.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">由<a class="ae kz" href="http://www.freepik.com" rel="noopener ugc nofollow" target="_blank"> Freepik </a>设计</p></figure><p id="773d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">[更新于 2021 年 2 月 18 日。代码更改为要点并添加了链接]</p><pre class="kk kl km kn gu lw lx ly lz aw ma bi"><span id="0a1e" class="mb mc iu lx b gz md me l mf mg"><strong class="lx iv">Table of Contents</strong></span><span id="575b" class="mb mc iu lx b gz mh me l mf mg"><a class="ae kz" href="#a73e" rel="noopener ugc nofollow"><strong class="lx iv">Introduction</strong></a></span><span id="2221" class="mb mc iu lx b gz mh me l mf mg">🦀 <a class="ae kz" href="#f4ce" rel="noopener ugc nofollow">Unsigned Integer Types</a><br/>🦀 <a class="ae kz" href="#3e54" rel="noopener ugc nofollow">Signed Integer Types</a><br/>🦀 <a class="ae kz" href="#ac74" rel="noopener ugc nofollow">Signed, Ones’ Complement and Two’s Complement</a><br/>🦀 <a class="ae kz" href="#7b01" rel="noopener ugc nofollow">Sign-and-Magnitude</a><br/>🦀 <a class="ae kz" href="#fbfa" rel="noopener ugc nofollow">Ones’ Complement</a><br/>🦀 <a class="ae kz" href="#41ce" rel="noopener ugc nofollow">Two’s Complement</a><br/>🦀 <a class="ae kz" href="#6677" rel="noopener ugc nofollow">4-bit Signed Binary Number Comparison</a><br/>🦀 <a class="ae kz" href="#0a26" rel="noopener ugc nofollow">Rust signed two’s complement integer types</a><br/>🦀 <a class="ae kz" href="#0883" rel="noopener ugc nofollow">Casting in Rust</a><br/>🦀 <a class="ae kz" href="#edbc" rel="noopener ugc nofollow">Casting to an Unsigned Type</a><br/>🦀 <a class="ae kz" href="#47e3" rel="noopener ugc nofollow">Casting to a Signed Type</a><br/>🦀 <a class="ae kz" href="#108b" rel="noopener ugc nofollow">Bitwise Negation</a><br/>🦀 <a class="ae kz" href="#baae" rel="noopener ugc nofollow">Adding a Negative Number</a></span><span id="369d" class="mb mc iu lx b gz mh me l mf mg"><a class="ae kz" href="#6f4b" rel="noopener ugc nofollow"><strong class="lx iv">Conclusion</strong></a></span></pre><h1 id="a73e" class="mi mc iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">介绍</h1><p id="e643" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">Rust 有两个<a class="ae kz" href="https://doc.rust-lang.org/book/ch03-02-data-types.html" rel="noopener ugc nofollow" target="_blank">数据类型子集</a>，标量和复合。标量类型有整数、浮点数、布尔值和字符。复合类型是数组和元组。</p><p id="d171" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在本文中，我们将了解以下代码失败的原因:</p><pre class="kk kl km kn gu lw lx ly lz aw ma bi"><span id="0bf1" class="mb mc iu lx b gz md me l mf mg">fn main() {<br/>    let a: i16 = 2;<br/>    let b: u16 = 4;<br/>    println!("{}", a+b);<br/>}</span></pre><p id="caa4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">还有为什么选角<code class="fe ne nf ng lx b">128</code>到<code class="fe ne nf ng lx b">i8</code>是<code class="fe ne nf ng lx b">-128</code>。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nh ni l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://tech.io/snippet/TlBrkrg" rel="noopener ugc nofollow" target="_blank">网上试试这个 Rust lang 代码。</a></p></figure><p id="3346" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">输出:</p><pre class="kk kl km kn gu lw lx ly lz aw ma bi"><span id="d7ab" class="mb mc iu lx b gz md me l mf mg">128 as a i8 is : -128</span></pre><p id="e3e7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">为了更好地理解造型，我们需要回顾一下有符号、一的补码和二的补码。</p><p id="3226" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们还将讨论添加负数、按位求反以及将二进制转换为无符号和有符号十进制。</p><p id="06d7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们先从 Rust 整数类型开始。</p></div><div class="ab cl nj nk hy nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="in io ip iq ir"><div class="kk kl km kn gu nq"><a rel="noopener follow" target="_blank" href="/learning-rust-by-converting-python-to-rust-259e735591c6"><div class="nr ab fp"><div class="ns ab nt cl cj nu"><h2 class="bd iv gz z fq nv fs ft nw fv fx it bi translated">通过将 Python 转换成 Rust 来学习 Rust</h2><div class="nx l"><h3 class="bd b gz z fq nv fs ft nw fv fx dk translated">Rust 基础入门教程</h3></div><div class="ny l"><p class="bd b dl z fq nv fs ft nw fv fx dk translated">towardsdatascience.com</p></div></div><div class="nz l"><div class="oa l ob oc od nz oe kt nq"/></div></div></a></div></div><div class="ab cl nj nk hy nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="in io ip iq ir"><h1 id="f4ce" class="mi mc iu bd mj mk of mm mn mo og mq mr ka oh kb mt kd oi ke mv kg oj kh mx my bi translated">无符号整数类型</h1><p id="1baf" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">Rust 中的无符号整数类型以<code class="fe ne nf ng lx b">u</code>开始，它有 8 位、16 位、32 位、64 位和 128 位。最小值和最大值从<strong class="lc iv"> 0 到 2ⁿ-1 </strong>。</p><p id="8fab" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">例如<code class="fe ne nf ng lx b">u8</code>有 0 到 2⁸-1，也就是 255。下表显示了无符号整数的所有详细信息。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ok"><img src="../Images/6f63dc10fc8efc3370d76e2bddc7027c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6cxauTwFFEcu-LMTWMMPnw.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">信任无符号整数类型。图片由作者提供。</p></figure><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nh ni l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">寻找无符号整数类型的最大值。<a class="ae kz" href="https://tech.io/snippet/wZSxuY6" rel="noopener ugc nofollow" target="_blank">网上试试这个 Rust lang 代码。</a></p></figure><p id="eac3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">输出:</p><pre class="kk kl km kn gu lw lx ly lz aw ma bi"><span id="d1ae" class="mb mc iu lx b gz md me l mf mg">u8 has the max value of 255.<br/>u16 has the max value of 65535.<br/>u32 has the max value of 4294967295.<br/>u64 has the max value of 18446744073709551615.<br/>u128 has the max value of 340282366920938463463374607431768211455.</span></pre><p id="1539" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果试图将负数赋给无符号类型，将会失败。</p><pre class="kk kl km kn gu lw lx ly lz aw ma bi"><span id="6da1" class="mb mc iu lx b gz md me l mf mg">fn main() {<br/>    let u:u32 = -1;<br/>    println!("{} in binary is {:b}", u, u);<br/>}</span><span id="8830" class="mb mc iu lx b gz mh me l mf mg">error[E0600]: cannot apply unary operator `-` to type `u32`<br/> --&gt; main.rs" data-line="2" data-column="17"&gt;main.rs:2:17<br/>  |<br/>2 |     let u:u32 = -1;<br/>  |                 ^^ cannot apply unary operator `-`<br/>  |<br/>  = note: unsigned values cannot be negated</span></pre><p id="9d8e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe ne nf ng lx b">-</code>是 Rust 的<a class="ae kz" href="https://doc.rust-lang.org/reference/expressions/operator-expr.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lc iv">一元</strong> <strong class="lc iv">运算符</strong> </a>之一，是有符号整数类型和浮点类型的非运算符。</p><h1 id="3e54" class="mi mc iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">有符号整数类型</h1><p id="278c" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">Rust 中的<strong class="lc iv">默认</strong>整数类型为<code class="fe ne nf ng lx b">i32</code>。Rust 中的有符号整数类型以<code class="fe ne nf ng lx b">i</code>开始，它有 8 位、16 位、32 位、64 位和 128 位。最小值和最大值是从<strong class="lc iv"> -(2ⁿ⁻到 2ⁿ⁻ -1 </strong>。<code class="fe ne nf ng lx b">n-1</code>中的<code class="fe ne nf ng lx b">-1</code>是符号位(正或负)，我们将在下一节中介绍。</p><p id="7a39" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">例如<code class="fe ne nf ng lx b">i8</code>有-(2⁷)到 2⁷-1，也就是-128 到 127。下表显示了有符号整数的所有详细信息。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ol"><img src="../Images/4f6a56334d7df672c427ff39f004a557.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MxVEixCs1iS1shQs2JVTYg.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">信任有符号整数类型。图片由作者提供。</p></figure><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nh ni l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">寻找有符号整数类型的最小值和最大值。在线尝试这个 Rust lang 代码。</p></figure><p id="f6fa" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">输出:</p><pre class="kk kl km kn gu lw lx ly lz aw ma bi"><span id="f0d3" class="mb mc iu lx b gz md me l mf mg">i8 has the min value of -128.<br/>i8 has the max value of 127.<br/>i16 has the min value of -32768.<br/>i16 has the max value of 32767.<br/>i32 has the min value of -2147483648.<br/>i32 has the max value of 2147483647.<br/>i64 has the min value of -9223372036854775808.<br/>i64 has the max value of 9223372036854775807.<br/>i128 has the min value of -170141183460469231731687303715884105728.<br/>i128 has the max value of 170141183460469231731687303715884105727.</span></pre><h1 id="ac74" class="mi mc iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">有符号、一的补码和二的补码</h1><p id="7f21" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">在计算中，需要用<strong class="lc iv">有符号的数字表示法</strong>来对二进制数字系统中的负数进行编码。让我们检查一下<a class="ae kz" href="https://www.wikiwand.com/en/Signed_number_representations#Sign-and-magnitude_method" rel="noopener ugc nofollow" target="_blank">符号和幅度</a>、<a class="ae kz" href="https://www.wikiwand.com/en/Signed_number_representations#Ones%27_complement" rel="noopener ugc nofollow" target="_blank">一进制补码</a>和<a class="ae kz" href="https://www.wikiwand.com/en/Signed_number_representations#Two%27s_complement" rel="noopener ugc nofollow" target="_blank">二进制补码</a>。</p><h1 id="7b01" class="mi mc iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">符号和幅度</h1><p id="ee72" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated"><strong class="lc iv">符号和幅度</strong>也称为<strong class="lc iv">符号幅度</strong>。第一位(称为最高有效位或 MSB)表示它是正 0 还是负 1。其余的称为幅度位。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj om"><img src="../Images/0d5683ec47711d56d961ff5badea13eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:650/format:webp/1*VRl-H1hvKodBgqBg4x8DHg.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">+5 的 4 位有符号幅度。图片由作者提供。</p></figure><p id="3ae9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">正如我之前提到的，有符号整数类型具有从<strong class="lc iv"> -(2ⁿ⁻到 2ⁿ⁻ -1 </strong>的最小值和最大值，其中 n 代表位数。因为我们将第一位用于正负符号，所以在<strong class="lc iv"> 2ⁿ⁻ </strong>中有<code class="fe ne nf ng lx b">n-1</code>。</p><p id="edf8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">对于 4 位，最小值和最大值从-(2)到 2–1，即-8 到+7。</p><p id="eb82" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">正如你在上图中看到的，除了符号位之外，正数和负数有相同的数字。</p><p id="057d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">有符号幅度的问题是有两个零，<code class="fe ne nf ng lx b">0000</code>和<code class="fe ne nf ng lx b">1000</code>。</p><h1 id="fbfa" class="mi mc iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">一的补码</h1><p id="f81a" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">第一位(MSB)与带符号幅度相同。它以 0 表示正，以 1 表示负。其余的位将接受补码，这意味着如果它为 1，补码为 0，如果它为 0，则补码为 1。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj om"><img src="../Images/0d2d057facc4072b3c31c076398e592d.png" data-original-src="https://miro.medium.com/v2/resize:fit:650/format:webp/1*gqAjX5UhDsXlnKMsZLJORA.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">+5 的一进制补码(4 位)。图片由作者提供。</p></figure><p id="0c47" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">有符号一的补码与有符号幅度具有相同的问题。有两个零，<code class="fe ne nf ng lx b">0000</code>和<code class="fe ne nf ng lx b">1111</code>。</p><h1 id="41ce" class="mi mc iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">二进制补码</h1><p id="7d47" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">在<strong class="lc iv">二进制</strong>计数系统中，基数(基数)是二。这就是为什么基数补码被称为二进制补码，而减基数补码被称为一进制补码。</p><p id="fd7c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">二进制补码可以避免 0 的多重表示，并且避免在溢出的情况下跟踪进位。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj on"><img src="../Images/dc01ce58ef65ce9114f48c6ec7fe8427.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*zgprx2SkITHc1iuXhZurHA.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">+5 的二进制补码(4 位)。图片由作者提供。</p></figure><p id="abda" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们再次将第一位(MSB)用于<code class="fe ne nf ng lx b">+</code>和<code class="fe ne nf ng lx b">-</code>符号。我们取这个数的补数，加上<code class="fe ne nf ng lx b">1</code>得到相反的数。这从正到负起作用，反之亦然。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj on"><img src="../Images/db89d1a1c77a49573e6ef93bc485d179.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*SNFyrjFPjOb7fhMThSs0gA.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">-5 的二进制补码(4 位)。图片由作者提供。</p></figure><p id="a2dd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">对于二进制中的零<code class="fe ne nf ng lx b">0000</code>，补码是<code class="fe ne nf ng lx b">1111</code>，加上<code class="fe ne nf ng lx b">1</code>得到<code class="fe ne nf ng lx b">1 0000</code>。<code class="fe ne nf ng lx b">1</code>被称为“溢出”位。当最高有效(最左边)列的总和产生结转时，发生溢出。该溢出位或进位位可以忽略。</p><p id="d9a8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下表显示了三种有符号数字表示法的比较。</p><h1 id="6677" class="mi mc iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">4 位有符号二进制数比较</h1><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oo"><img src="../Images/1ad159b627dcc4c2c7493b75e51bb441.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fK5tJ6Kw5ic75OHeZO34Iw.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">4 位有符号二进制数比较。图片由作者提供。</p></figure><h1 id="0a26" class="mi mc iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">Rust 有符号二进制补码整数类型</h1><p id="c955" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">现在让我们将上表中的有符号二进制补码的负数(从-1 到-7)与 Rust 的有符号整数进行比较。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nh ni l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://tech.io/snippet/mI3rvun" rel="noopener ugc nofollow" target="_blank">网上试试这个 Rust lang 代码。</a></p></figure><p id="1459" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">输出:</p><pre class="kk kl km kn gu lw lx ly lz aw ma bi"><span id="e39c" class="mb mc iu lx b gz md me l mf mg">-1 in binary is 11111111111111111111111111111111<br/>-2 in binary is 11111111111111111111111111111110<br/>-3 in binary is 11111111111111111111111111111101<br/>-4 in binary is 11111111111111111111111111111100<br/>-5 in binary is 11111111111111111111111111111011<br/>-6 in binary is 11111111111111111111111111111010<br/>-7 in binary is 11111111111111111111111111111001</span></pre><p id="b589" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">除了 Rust 使用默认的 32 位之外，它们完全相同。Rust 的有符号整数类型被称为<strong class="lc iv">有符号二进制补码整数类型</strong>。</p><h1 id="0883" class="mi mc iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">生锈的铸件</h1><p id="65ad" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated"><a class="ae kz" href="https://doc.rust-lang.org/rust-by-example/types/cast.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lc iv">造型</strong> </a>是将一条数据的数据类型从一种类型改变为另一种类型。</p><p id="a35c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe ne nf ng lx b"><a class="ae kz" href="https://doc.rust-lang.org/std/keyword.as.html" rel="noopener ugc nofollow" target="_blank">as</a></code> <a class="ae kz" href="https://doc.rust-lang.org/std/keyword.as.html" rel="noopener ugc nofollow" target="_blank">关键字</a>将原始类型转换为其他原始类型。我们可以使用<code class="fe ne nf ng lx b">as</code>关键字来解决简介中的代码。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nh ni l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">铸造 u16 到 i16。<a class="ae kz" href="https://tech.io/snippet/Fy9iH89" rel="noopener ugc nofollow" target="_blank">网上试试这个 Rust lang 代码。</a></p></figure><p id="83ce" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当你从小长度转换到大长度时，比如从 8 位转换到 16 位，不会有任何问题，但是当你向下转换时，就有问题了。</p><h1 id="edbc" class="mi mc iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">强制转换为无符号类型</h1><p id="737e" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated"><strong class="lc iv">方法一</strong></p><p id="6b6b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当您强制转换为无符号类型时，会加上或减去 T，T::MAX + 1，直到该值适合新类型。</p><p id="a163" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">示例 1:从默认的<code class="fe ne nf ng lx b">i32</code>到<code class="fe ne nf ng lx b">u8</code>铸造 1000</p><p id="cc71" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe ne nf ng lx b">u8</code>的最大数是 255，所以我们减去 255+1，也就是从 1000 减去 256，直到小于 255。</p><pre class="kk kl km kn gu lw lx ly lz aw ma bi"><span id="55dc" class="mb mc iu lx b gz md me l mf mg">1000 - 256             = 744 <br/>1000 - 256 - 256       = 488 <br/>1000 - 256 - 256 - 256 = 232</span></pre><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nh ni l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">铸造 1000 个 i32 到 u8。<a class="ae kz" href="https://tech.io/snippet/Ln7SgIv" rel="noopener ugc nofollow" target="_blank">网上试试这个 Rust lang 代码。</a></p></figure><p id="bef0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">输出:</p><pre class="kk kl km kn gu lw lx ly lz aw ma bi"><span id="7e2a" class="mb mc iu lx b gz md me l mf mg">1000 as a u8 is : 232</span></pre><p id="f169" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">方法二</strong></p><p id="8ab5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">十进制的 1000₁₀是二进制的 1 1110 1000₂。我们可以取后 8 位，也就是<code class="fe ne nf ng lx b">1110 1000</code>，十进制是 232。</p><p id="74f9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">一个有趣的数字是 256₁₀.</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nh ni l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">铸造 256 i32 到 u8。<a class="ae kz" href="https://tech.io/snippet/Rmafm8K" rel="noopener ugc nofollow" target="_blank">网上试试这个 Rust lang 代码。</a></p></figure><p id="b0ee" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">输出:</p><pre class="kk kl km kn gu lw lx ly lz aw ma bi"><span id="606e" class="mb mc iu lx b gz md me l mf mg">256 as a u8 is : 0</span></pre><p id="004b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">256₁₀是二进制的 100000000₂。如果取最后 8 位，就是<code class="fe ne nf ng lx b">00000000</code>。</p><h1 id="47e3" class="mi mc iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">强制转换为有符号类型</h1><p id="c9df" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated"><strong class="lc iv">方法一</strong></p><p id="3fbc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这与上面的相同，但是您需要注意数据类型的最小/最大数量。</p><p id="0982" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe ne nf ng lx b">i8</code>的最小和最大数字是-128 和 127。所以这个数字必须介于两者之间。</p><p id="5a8d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">铸造 128 到<code class="fe ne nf ng lx b">i8</code>:</p><pre class="kk kl km kn gu lw lx ly lz aw ma bi"><span id="2fc0" class="mb mc iu lx b gz md me l mf mg">128-256=-128</span></pre><p id="c2fd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">铸造 1000 到 i8:</p><pre class="kk kl km kn gu lw lx ly lz aw ma bi"><span id="b3fe" class="mb mc iu lx b gz md me l mf mg">1000 - 256 = 744<br/>1000 - 256 - 256 = 488<br/>1000 - 256 - 256 - 256 = 232<br/>1000 - 256 - 256 - 256 - 256 = -24</span></pre><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nh ni l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">将 i32 数字转换为 i8。<a class="ae kz" href="https://tech.io/snippet/sefhUMo" rel="noopener ugc nofollow" target="_blank">网上试试这个 Rust lang 代码。</a></p></figure><p id="236d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">输出:</p><pre class="kk kl km kn gu lw lx ly lz aw ma bi"><span id="4250" class="mb mc iu lx b gz md me l mf mg">128 as a i8 is : -128<br/>1000 as a i8 is : -24<br/>232 as a i8 is : -24<br/>257 as a i8 is : 1<br/>130 as a i8 is : -126<br/>514 as a i8 is : 2</span></pre><p id="fc48" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">方法二</strong></p><p id="f6dc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">十进制的 1000₁₀是二进制的 11 <strong class="lc iv"> 1 </strong> 110 1000₂。8 位以内的 MSB 是 1，所以是负数。然后用 2 的补码。补足语是 00010111₂，我们加上 1₂就成了 00011000₂.最后，是-24₁₀.</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj op"><img src="../Images/c30db31c54851942ab9809b6d1b36e5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/format:webp/1*R1g39MNmnk2rcQusjJjA4A.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">图片由作者提供。</p></figure><p id="fcd5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当 8 位以内的 MSB 为 0 时，为正数。然后取前 8 个最低有效位(LSB)。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj oq"><img src="../Images/e3ff51e4599745a833376b9307d5758e.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/format:webp/1*-vLLE-tFJQKQXS9Pnz_Uzg.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">图片由作者提供。</p></figure><h1 id="108b" class="mi mc iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">逐位求反</h1><p id="9b44" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">Rust 使用<code class="fe ne nf ng lx b">!</code>进行逐位求反(逐位非)。这根据类型产生不同的结果。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nh ni l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://tech.io/snippet/9d6KeRo" rel="noopener ugc nofollow" target="_blank">网上试试这个锈郎代码。</a></p></figure><p id="7d85" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">输出:</p><pre class="kk kl km kn gu lw lx ly lz aw ma bi"><span id="b395" class="mb mc iu lx b gz md me l mf mg">u is 2<br/>u in binary is 10<br/>i is 2<br/>i in binary is 10<br/>Bitwise negation !u is 4294967293<br/>Bitwise negation !i is -3</span></pre><p id="e8c2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">正如你看到的<code class="fe ne nf ng lx b">!2</code>带有无符号类型返回<code class="fe ne nf ng lx b">4294967293</code>，带有有符号类型返回<code class="fe ne nf ng lx b">-3</code>。</p><p id="7c0c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">有符号整数上的按位求反返回二进制补码，正如我们之前在<a class="ae kz" href="#0a26" rel="noopener ugc nofollow">信任有符号二进制补码整数类型</a>中看到的。</p><h1 id="baae" class="mi mc iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">添加负数</h1><p id="e90d" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">减法和负数的加法是一样的。</p><pre class="kk kl km kn gu lw lx ly lz aw ma bi"><span id="c8ba" class="mb mc iu lx b gz md me l mf mg">5 - 2 = 5 + (-2) = 3</span></pre><p id="513d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这也适用于二进制。</p><pre class="kk kl km kn gu lw lx ly lz aw ma bi"><span id="36db" class="mb mc iu lx b gz md me l mf mg">0101 - 0010 <br/>= 0101 + (-0010) // (1)<br/>= 0101 + 1110    // (2)<br/>= 0011           // this is 3 in decimal number.</span></pre><p id="e2dc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们通过找到<code class="fe ne nf ng lx b">0010</code>的二进制补码即<code class="fe ne nf ng lx b">1110</code>来找到<code class="fe ne nf ng lx b">-0010</code>。</p><h1 id="6f4b" class="mi mc iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">结论</h1><p id="187d" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">我们讨论了 Rust 整数类型、三种类型的有符号二进制数、转换为无符号类型和有符号类型。我希望你在处理 Rust integers 和 casting 时，对发生的事情有更好的了解。</p><p id="7e8b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">请继续关注下一篇文章。</p></div><div class="ab cl nj nk hy nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="in io ip iq ir"><p id="a030" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">通过</strong> <a class="ae kz" href="https://blog.codewithshin.com/membership" rel="noopener ugc nofollow" target="_blank"> <strong class="lc iv">成为</strong> </a> <strong class="lc iv">会员，可以完全访问媒体上的每一个故事。</strong></p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj or"><img src="../Images/0be3ee559fee844cb75615290e4a8b29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*DjTM9iFtVc2wlcWcOms7VQ.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://blog.codewithshin.com/subscribe" rel="noopener ugc nofollow" target="_blank">https://blog.codewithshin.com/subscribe</a></p></figure></div><div class="ab cl nj nk hy nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="in io ip iq ir"><div class="kk kl km kn gu nq"><a rel="noopener follow" target="_blank" href="/you-want-to-learn-rust-but-you-dont-know-where-to-start-fc826402d5ba"><div class="nr ab fp"><div class="ns ab nt cl cj nu"><h2 class="bd iv gz z fq nv fs ft nw fv fx it bi translated">你想学 Rust 但是不知道从哪里开始</h2><div class="nx l"><h3 class="bd b gz z fq nv fs ft nw fv fx dk translated">Rust 初学者的完整资源</h3></div><div class="ny l"><p class="bd b dl z fq nv fs ft nw fv fx dk translated">towardsdatascience.com</p></div></div><div class="nz l"><div class="os l ob oc od nz oe kt nq"/></div></div></a></div></div></div>    
</body>
</html>