<html>
<head>
<title>Solve sudokus automatically</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自动解决数独</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/solve-sudokus-automatically-4032b2203b64?source=collection_archive---------2-----------------------#2020-01-11">https://towardsdatascience.com/solve-sudokus-automatically-4032b2203b64?source=collection_archive---------2-----------------------#2020-01-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div class="gh gi ir"><img src="../Images/762575f45f81f6e8bc461e66ce98a141.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/1*d3I_xZ3aNZxzCM3B9UC1zw.gif"/></div></figure><div class=""/><div class=""><h2 id="1121" class="pw-subtitle-paragraph jx iz ja bd b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko dk translated">通过用 Python 实现数独求解算法，并用 PyAutoGUI 自动化人机交互</h2></div><p id="bae5" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">在这篇文章中，我将介绍如何制作自己的脚本来解决数独难题。此外，PyAutoGUI 增强了这个脚本，使数独求解相当自动化(您只需执行代码)。</p><p id="69ff" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我把这篇文章分成以下几部分:</p><ol class=""><li id="bbe1" class="ll lm ja kr b ks kt kv kw ky ln lc lo lg lp lk lq lr ls lt bi translated">数独入门——这个简短的部分涵盖了必须牢记的基本规则；</li><li id="ac59" class="ll lm ja kr b ks lu kv lv ky lw lc lx lg ly lk lq lr ls lt bi translated">数独解决算法——这部分从定义必要的数据结构开始，我们将创建一个算法来解决任何给定的难题；</li><li id="65f8" class="ll lm ja kr b ks lu kv lv ky lw lc lx lg ly lk lq lr ls lt bi translated">自动化——如果你的脚本知道一个谜题的一步一步的解决方法，那就太酷了。如果你的代码与网页交互并自动解决数独，那就更酷了。</li></ol><p id="601e" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我希望您已经安装了 Python、Pillow 和 PyAutoGUI 模块。如果你还没有 PyAutoGUI，那么你应该按照这里的<a class="ae lz" href="https://pyautogui.readthedocs.io/en/latest/install.html" rel="noopener ugc nofollow" target="_blank"><strong class="kr jb"/></a>安装。</p><h1 id="d92f" class="ma mb ja bd mc md me mf mg mh mi mj mk kg ml kh mm kj mn kk mo km mp kn mq mr bi translated">数独规则</h1><figure class="mt mu mv mw gt iv gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/6281cb961f2940f42918d1a601c78194.png" data-original-src="https://miro.medium.com/v2/resize:fit:890/format:webp/1*4fqzGBs9HY9hmbZSZmIPtw.jpeg"/></div><p class="mx my gj gh gi mz na bd b be z dk translated">数独术语解释。来源:https://www.pinterest.com/pin/468796642443225725/<a class="ae lz" href="https://www.pinterest.com/pin/468796642443225725/" rel="noopener ugc nofollow" target="_blank"/></p></figure><p id="0633" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">重要的事情先来。如果你不熟悉数独游戏的规则，不要害怕。它们非常简单:</p><p id="afea" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">您必须用 1 到 9 的数字填充 9x9 网格的方框，以使每行、每列和 3x3 块中没有重复出现的数字。</p><p id="ab66" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">如果你看一下这张图片，左上角的框中唯一合适的数字是 2，因为它是唯一一个没有出现在这一行、列和框中的数字。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="a116" class="ma mb ja bd mc md ni mf mg mh nj mj mk kg nk kh mm kj nl kk mo km nm kn mq mr bi translated">数独和数据结构示例</h1><figure class="mt mu mv mw gt iv gh gi paragraph-image"><div class="gh gi ir"><img src="../Images/11b38f61cac9af61846e7e01df39ecb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/format:webp/1*zuHkoiGByZi6DFNYLPe8mA.png"/></div><p class="mx my gj gh gi mz na bd b be z dk translated">来自互联网的随机难题</p></figure><p id="75cb" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我们从网上随便拿一个数独谜题，试着用 Python 来解。我建议我们将这个难题作为一个二维 Python 数组来处理，其中空盒子用零表示，其他盒子用相应的数字表示。我们应该获得以下内容:</p><pre class="mt mu mv mw gt nn no np nq aw nr bi"><span id="4ad7" class="ns mb ja no b gy nt nu l nv nw">sudoku =    [[8, 1, 0, 0, 3, 0, 0, 2, 7], <br/>            [0, 6, 2, 0, 5, 0, 0, 9, 0], <br/>            [0, 7, 0, 0, 0, 0, 0, 0, 0], <br/>            [0, 9, 0, 6, 0, 0, 1, 0, 0], <br/>            [1, 0, 0, 0, 2, 0, 0, 0, 4], <br/>            [0, 0, 8, 0, 0, 5, 0, 7, 0], <br/>            [0, 0, 0, 0, 0, 0, 0, 8, 0], <br/>            [0, 2, 0, 0, 1, 0, 7, 5, 0], <br/>            [3, 8, 0, 0, 7, 0, 0, 4, 2]]</span></pre><p id="318d" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">当试图从第<em class="nx"> i </em>行和第<em class="nx"> j </em>列访问某个元素时，只需调用</p><pre class="mt mu mv mw gt nn no np nq aw nr bi"><span id="34d1" class="ns mb ja no b gy nt nu l nv nw">sudoku[i][j]</span></pre><h1 id="037c" class="ma mb ja bd mc md me mf mg mh mi mj mk kg ml kh mm kj mn kk mo km mp kn mq mr bi translated">让它看起来更像一个真正的数独游戏</h1><p id="f767" class="pw-post-body-paragraph kp kq ja kr b ks ny kb ku kv nz ke kx ky oa la lb lc ob le lf lg oc li lj lk im bi translated">当然，这个二维 python 数组看起来不像没有任何网格线的真正的数独。因此，最好能打印出谜题的当前状态。下面是代码示例及其输出。</p><pre class="mt mu mv mw gt nn no np nq aw nr bi"><span id="06fd" class="ns mb ja no b gy nt nu l nv nw">def printsudoku():<br/>    print("\n\n\n\n\n")<br/>    for i in range(len(sudoku)):<br/>        line = ""<br/>        if i == 3 or i == 6:<br/>            print("---------------------")<br/>        for j in range(len(sudoku[i])):<br/>            if j == 3 or j == 6:<br/>                line += "| "<br/>            line += str(sudoku[i][j])+" "<br/>        print(line)</span></pre><figure class="mt mu mv mw gt iv gh gi paragraph-image"><div class="gh gi od"><img src="../Images/3e6c80578e1787084ec5bca3b885d164.png" data-original-src="https://miro.medium.com/v2/resize:fit:466/format:webp/1*DrUSRW5GcaaZjS03He7daA.png"/></div><p class="mx my gj gh gi mz na bd b be z dk translated">一个<em class="oe"> printsudoku </em>函数的示例输出</p></figure><p id="4b63" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我们开始吧！现在我们已经准备好一步一步地创建算法。</p><p id="1c68" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">免责声明:我没有完全自己创造这个数独解决算法。想法和实现都是从麻省理工学院 open 课件 Youtube 频道抄袭来的，更具体的说是从这个 <a class="ae lz" href="https://www.youtube.com/watch?v=auK3PSZoidc" rel="noopener ugc nofollow" target="_blank"> <em class="nx">视频</em> </a> <em class="nx">。然而，它被-NC-SA 许可为知识共享，这给我的共享开了绿灯。</em></p><h2 id="a6fa" class="ns mb ja bd mc of og dn mg oh oi dp mk ky oj ok mm lc ol om mo lg on oo mq op bi translated">第一步。寻找未填充的单元格</h2><p id="b064" class="pw-post-body-paragraph kp kq ja kr b ks ny kb ku kv nz ke kx ky oa la lb lc ob le lf lg oc li lj lk im bi translated">要求解某个单元格，我们必须首先找到空单元格的行号和列号。下面的函数完成了这个任务。</p><pre class="mt mu mv mw gt nn no np nq aw nr bi"><span id="2b66" class="ns mb ja no b gy nt nu l nv nw">def findNextCellToFill(sudoku):<br/>    for x in range(9):<br/>        for y in range(9):<br/>            if sudoku[x][y] == 0:<br/>                return x, y<br/>    return -1, -1</span></pre><p id="e7d5" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">这将遍历第一行中的所有列，然后是第二行，依此类推。每当遇到空单元格时，该函数都会返回相应的索引。简单！</p><h2 id="fd12" class="ns mb ja bd mc of og dn mg oh oi dp mk ky oj ok mm lc ol om mo lg on oo mq op bi translated">第二步。验证条目</h2><p id="8783" class="pw-post-body-paragraph kp kq ja kr b ks ny kb ku kv nz ke kx ky oa la lb lc ob le lf lg oc li lj lk im bi translated">假设我们有一个条目。我们需要一个函数来检查当放置到第<em class="nx"> i </em>行和第<em class="nx"> j </em>列时是否违反了数独的三个主要规则。如果没有违反这三个规则，下面的函数返回<em class="nx"> True </em>。否则，该函数将返回<em class="nx">假</em>。</p><pre class="mt mu mv mw gt nn no np nq aw nr bi"><span id="04b0" class="ns mb ja no b gy nt nu l nv nw">def isValid(sudoku, i, j, e):<br/>    rowOk = all([e != sudoku[i][x] for x in range(9)])<br/>    if rowOk:<br/>        columnOk = all([e != sudoku[x][j] for x in range(9)])<br/>        if columnOk:<br/>            secTopX, secTopY = 3*(i//3), 3*(j//3)<br/>            for x in range(secTopX, secTopX+3):<br/>                for y in range(secTopY, secTopY+3):<br/>                    if sudoku[x][y] == e:<br/>                        return False<br/>            return True<br/>    return False</span></pre><p id="91ce" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">检查了三个规则:</p><ol class=""><li id="3f73" class="ll lm ja kr b ks kt kv kw ky ln lc lo lg lp lk lq lr ls lt bi translated">rowOk:这个检查第<em class="nx"> i </em>行是否没有重复的数字；</li><li id="6b11" class="ll lm ja kr b ks lu kv lv ky lw lc lx lg ly lk lq lr ls lt bi translated">columnOk:这个函数确保第<em class="nx"> j </em>列中没有重复的数字；</li><li id="c342" class="ll lm ja kr b ks lu kv lv ky lw lc lx lg ly lk lq lr ls lt bi translated">如果 rowOk 和 columnOk 都为<em class="nx">真</em>，那么第 6–10 行检查该条目是否适合某个块。</li></ol><h2 id="21ad" class="ns mb ja bd mc of og dn mg oh oi dp mk ky oj ok mm lc ol om mo lg on oo mq op bi translated">第三步。解开谜题</h2><p id="c903" class="pw-post-body-paragraph kp kq ja kr b ks ny kb ku kv nz ke kx ky oa la lb lc ob le lf lg oc li lj lk im bi translated">现在一切都是为了解决给定的数独。我们将使用以下函数来实现:</p><pre class="mt mu mv mw gt nn no np nq aw nr bi"><span id="d0fa" class="ns mb ja no b gy nt nu l nv nw">def solveSudoku(sudoku, i=0, j=0):<br/>    i, j = findNextCellToFill(sudoku)<br/>    if i == -1:<br/>        return True</span><span id="b032" class="ns mb ja no b gy oq nu l nv nw">    for e in range(1, 10):<br/>        if isValid(sudoku, i, j, e):<br/>            sudoku[i][j] = e<br/>            if solveSudoku(sudoku, i, j):<br/>                return True<br/>            sudoku[i][j] = 0<br/>    return False</span></pre><p id="4f20" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">该函数的前三行确保我们的拼图中有一个空单元格。如果 I = 1，那么我们就完成了解谜。</p><p id="4de5" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">如果在第<em class="nx"> i </em>行和第<em class="nx"> j </em>列有一个空单元格，那么它会尝试将 1 到 9 的所有可能条目放入这个框中。如果条目有效(由<em class="nx"> isValid </em>函数验证),则尝试在假设这是正确条目的情况下递归求解数独。</p><p id="e6ec" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">如果我们的假设是错误的，那么第 9 行将返回<em class="nx">假</em>，这将把第<em class="nx"> i </em>行和第<em class="nx"> j </em>列中的单元格的值设置为零。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><p id="7dca" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">要解决我们的数独，进行以下函数调用:</p><pre class="mt mu mv mw gt nn no np nq aw nr bi"><span id="f318" class="ns mb ja no b gy nt nu l nv nw">solveSudoku(sudoku)<br/>printsudoku()</span></pre><p id="5f4c" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">第一个解决了我们的难题，后者给出了解决方案。太好了！</p><h1 id="d37e" class="ma mb ja bd mc md me mf mg mh mi mj mk kg ml kh mm kj mn kk mo km mp kn mq mr bi translated">从解决方案到自动化</h1><p id="49bb" class="pw-post-body-paragraph kp kq ja kr b ks ny kb ku kv nz ke kx ky oa la lb lc ob le lf lg oc li lj lk im bi translated">自动化部分分为两个部分:</p><ol class=""><li id="6ac1" class="ll lm ja kr b ks kt kv kw ky ln lc lo lg lp lk lq lr ls lt bi translated">在数独网格上定位数字。这样我们可以解决任何数独，而不必手动填充<em class="nx">数独</em>变量。</li><li id="49f8" class="ll lm ja kr b ks lu kv lv ky lw lc lx lg ly lk lq lr ls lt bi translated">用数字填充空白单元格。</li></ol><p id="386c" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我们通过使用 PyAutoGUI 模块来实现自动化。请在您的代码中导入它。</p><pre class="mt mu mv mw gt nn no np nq aw nr bi"><span id="be68" class="ns mb ja no b gy nt nu l nv nw">import pyautogui as pag</span></pre><h1 id="4331" class="ma mb ja bd mc md me mf mg mh mi mj mk kg ml kh mm kj mn kk mo km mp kn mq mr bi translated">从我们的显示器上读取数独</h1><h2 id="28ac" class="ns mb ja bd mc of og dn mg oh oi dp mk ky oj ok mm lc ol om mo lg on oo mq op bi translated">准备</h2><p id="885b" class="pw-post-body-paragraph kp kq ja kr b ks ny kb ku kv nz ke kx ky oa la lb lc ob le lf lg oc li lj lk im bi translated">我们将要解决来自<a class="ae lz" href="https://www.websudoku.com/?level=2" rel="noopener ugc nofollow" target="_blank"> <strong class="kr jb">网络数独</strong> </a>的随机数独难题。打开一个随机拼图，保存每个数字的图像片段。它们都应该保存到与 Python 脚本相同的文件夹中。确保文件格式为. png。</p><figure class="mt mu mv mw gt iv gh gi paragraph-image"><div class="gh gi or"><img src="../Images/746eb3d905594791fdc954fedc06bd63.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/format:webp/1*4tCswzw2U8GdPsessf_P3g.png"/></div><p class="mx my gj gh gi mz na bd b be z dk translated">保存每个号码的图像片段</p></figure><p id="e177" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">这些片段可以有不同的尺寸，只要它们都只在白色背景上显示一个数字。我们先把它们命名为“1.png”、“2.png”等。</p><h2 id="fa18" class="ns mb ja bd mc of og dn mg oh oi dp mk ky oj ok mm lc ol om mo lg on oo mq op bi translated">定位号码</h2><p id="ef89" class="pw-post-body-paragraph kp kq ja kr b ks ny kb ku kv nz ke kx ky oa la lb lc ob le lf lg oc li lj lk im bi translated">PyAutoGUI 模块有一个在屏幕上定位给定图像的功能。就我而言</p><pre class="mt mu mv mw gt nn no np nq aw nr bi"><span id="d3d1" class="ns mb ja no b gy nt nu l nv nw">for pos in pag.locateOnScreen("3.png"):<br/>    print(pos)</span></pre><p id="fa13" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">返回屏幕上第三个位置的所有信息:</p><pre class="mt mu mv mw gt nn no np nq aw nr bi"><span id="7d27" class="ns mb ja no b gy nt nu l nv nw">Box(left=1124, top=510, width=32, height=33)<br/>Box(left=959, top=845, width=32, height=33)</span></pre><p id="e35e" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">前两个参数(left 和 top)给出了图像左上角的像素坐标。第三个和第四个给了我们图像的尺寸，但是现在我们不需要它们。</p><p id="f29b" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">要获取所有数字的位置，请使用以下命令:</p><pre class="mt mu mv mw gt nn no np nq aw nr bi"><span id="d391" class="ns mb ja no b gy nt nu l nv nw">for i in range(1, 10):<br/>    for pos in pag.locateAllOnScreen(str(i)+'.png'):<br/>        print(pos)</span></pre><h2 id="33d7" class="ns mb ja bd mc of og dn mg oh oi dp mk ky oj ok mm lc ol om mo lg on oo mq op bi translated">填充数独数组</h2><p id="7f63" class="pw-post-body-paragraph kp kq ja kr b ks ny kb ku kv nz ke kx ky oa la lb lc ob le lf lg oc li lj lk im bi translated">因为我们不打算使用之前的<em class="nx">数独</em>数组，所以让我们把这个数组中的所有数字都变为零:</p><pre class="mt mu mv mw gt nn no np nq aw nr bi"><span id="7a2f" class="ns mb ja no b gy nt nu l nv nw">sudoku =    [[0, 0, 0, 0, 0, 0, 0, 0, 0], <br/>            [0, 0, 0, 0, 0, 0, 0, 0, 0], <br/>            [0, 0, 0, 0, 0, 0, 0, 0, 0], <br/>            [0, 0, 0, 0, 0, 0, 0, 0, 0], <br/>            [0, 0, 0, 0, 0, 0, 0, 0, 0], <br/>            [0, 0, 0, 0, 0, 0, 0, 0, 0], <br/>            [0, 0, 0, 0, 0, 0, 0, 0, 0], <br/>            [0, 0, 0, 0, 0, 0, 0, 0, 0], <br/>            [0, 0, 0, 0, 0, 0, 0, 0, 0]]</span></pre><p id="6a8c" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">现在让我们定义拼图上两个单元格的像素坐标:左上和右下。在我的案例中，数字是:</p><pre class="mt mu mv mw gt nn no np nq aw nr bi"><span id="6b40" class="ns mb ja no b gy nt nu l nv nw">topleftx = 975<br/>toplefty = 507<br/>bottomrightx = 1307<br/>bottomrighty = 846</span></pre><p id="bd60" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">现在我们有了它们，让我们定义一个盒子的宽度和高度:</p><pre class="mt mu mv mw gt nn no np nq aw nr bi"><span id="6c5a" class="ns mb ja no b gy nt nu l nv nw">boxwidth = (bottomrightx - topleftx)/8<br/>boxheight = (bottomrighty - toplefty)/8</span></pre><p id="e5c2" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated"><em class="nx">解释:看一行单元格时，最左边的单元格到最右边的单元格的距离是 8 个框宽。这同样适用于列。因此，我们必须将坐标差除以 8。</em></p><p id="fcf3" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">现在我们必须定义一个函数，用正确的数字替换数独数组中的零。</p><pre class="mt mu mv mw gt nn no np nq aw nr bi"><span id="aa3e" class="ns mb ja no b gy nt nu l nv nw">def fillsudoku(nr, pos):<br/>    global sudoku<br/>    indexlocx = int((pos[0] - topleftx + boxwidth/2)//boxwidth)<br/>    indexlocy = int((pos[1] - toplefty + boxheight/2)//boxwidth)<br/>    sudoku[indexlocy][indexlocx] = nr</span></pre><p id="094b" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我不打算解释数学，但它需要一个<em class="nx"> Box </em>对象，并找到我们的数字的“索引坐标”。如果到目前为止你已经正确地做了每件事，那么它将完美地工作。</p><p id="d95b" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">最后，让我们用屏幕上的信息填充数组:</p><pre class="mt mu mv mw gt nn no np nq aw nr bi"><span id="27ad" class="ns mb ja no b gy nt nu l nv nw">for i in range(1, 10):<br/>    for pos in pag.locateAllOnScreen(str(i)+'.png'):<br/>        fillsudoku(i, pos)</span></pre><p id="ef58" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">如果您从 IDE 跳转到 web 浏览器的速度不够快，请在代码的开头添加以下延迟方法:</p><pre class="mt mu mv mw gt nn no np nq aw nr bi"><span id="b704" class="ns mb ja no b gy nt nu l nv nw">import time</span><span id="dfb1" class="ns mb ja no b gy oq nu l nv nw">time.sleep(5)  #this makes a 5 second delay to executing the script</span></pre><h2 id="bb57" class="ns mb ja bd mc of og dn mg oh oi dp mk ky oj ok mm lc ol om mo lg on oo mq op bi translated">填充空单元格</h2><p id="c43f" class="pw-post-body-paragraph kp kq ja kr b ks ny kb ku kv nz ke kx ky oa la lb lc ob le lf lg oc li lj lk im bi translated">太好了！现在我们有了一个使用屏幕信息填充我们的<em class="nx">数独</em>数组的方法。既然我们有了求解算法，那么我们可以立即求解。为此，我们只需要以下函数:</p><pre class="mt mu mv mw gt nn no np nq aw nr bi"><span id="02b3" class="ns mb ja no b gy nt nu l nv nw">def fillcell(nr, x, y):<br/>    xcoord = topleftx + boxwidth * x<br/>    ycoord = toplefty + boxheight * y<br/>    pag.click(xcoord, ycoord)<br/>    pag.press(str(nr))</span></pre><p id="72ee" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">这里我们有三个输入参数:</p><ul class=""><li id="47b4" class="ll lm ja kr b ks kt kv kw ky ln lc lo lg lp lk os lr ls lt bi translated"><em class="nx"> nr </em>:这是我们要插入的号码；</li><li id="0c05" class="ll lm ja kr b ks lu kv lv ky lw lc lx lg ly lk os lr ls lt bi translated"><em class="nx"> x </em>:我们要插入的单元格的列索引<em class="nx">NR；</em></li><li id="c979" class="ll lm ja kr b ks lu kv lv ky lw lc lx lg ly lk os lr ls lt bi translated"><em class="nx"> y </em>:我们要插入的单元格的行索引<em class="nx">NR</em>；</li></ul><p id="cc90" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">第 2–3 行找到单元格中点的近似坐标，我们必须插入数字。第 4-5 行单击该单元格并写下该数字。</p><p id="b3e9" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">哦是的！还有一件事。在解数独之前，请创建一个数独数组的副本。稍后我会解释。</p><pre class="mt mu mv mw gt nn no np nq aw nr bi"><span id="0c23" class="ns mb ja no b gy nt nu l nv nw">import copy</span><span id="7fce" class="ns mb ja no b gy oq nu l nv nw">sudokucopy = copy.deepcopy(sudoku)</span></pre><h1 id="01b1" class="ma mb ja bd mc md me mf mg mh mi mj mk kg ml kh mm kj mn kk mo km mp kn mq mr bi translated">将碎片拼在一起</h1><p id="4a7c" class="pw-post-body-paragraph kp kq ja kr b ks ny kb ku kv nz ke kx ky oa la lb lc ob le lf lg oc li lj lk im bi translated">为了保持一致，我将在下面嵌入一个 Github 要点:</p><figure class="mt mu mv mw gt iv"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="4cbe" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">到目前为止，我们从屏幕上读取了数独并解决了它。在试图解决它之前，我们也有两个相同的数独数组:<em class="nx"> sudoku </em>和<em class="nx"> sudokucopy </em>。</p><p id="7768" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">制作<em class="nx">数独游戏</em>是为了比较我们拼图的初始和最终状态，并填充空白单元格。</p><pre class="mt mu mv mw gt nn no np nq aw nr bi"><span id="bf1d" class="ns mb ja no b gy nt nu l nv nw">for x in range(9):<br/>    for y in range(9):<br/>        if sudokucopy[x][y] == 0:<br/>            fillcell(sudoku[x][y], y, x)</span></pre><h1 id="ece0" class="ma mb ja bd mc md me mf mg mh mi mj mk kg ml kh mm kj mn kk mo km mp kn mq mr bi translated">接下来呢？</h1><p id="bed2" class="pw-post-body-paragraph kp kq ja kr b ks ny kb ku kv nz ke kx ky oa la lb lc ob le lf lg oc li lj lk im bi translated">现在可以执行了，如果您的配置是正确的，它应该是这样的:</p><figure class="mt mu mv mw gt iv gh gi paragraph-image"><div class="gh gi ir"><img src="../Images/752997d87d62afb992eae68137e87a60.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/1*mpHLRA-XtJDwWsEAa3O4ag.gif"/></div></figure><p id="2a7f" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">当然，可以做一些改进:</p><ol class=""><li id="9d1c" class="ll lm ja kr b ks kt kv kw ky ln lc lo lg lp lk lq lr ls lt bi translated">我花了大约 20 秒将数据从屏幕加载到<em class="nx">数独</em>数组。您可以使用一些不同的模块(或创建自己的模块)来加快速度。</li><li id="feb0" class="ll lm ja kr b ks lu kv lv ky lw lc lx lg ly lk lq lr ls lt bi translated">修改数独求解算法，使自动求解部分看起来更像人类的思维。现实生活中没有人能解决上面动画中显示的难题。</li></ol><p id="90ac" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">请随意修改这个实现，并在不同的谜题上测试它(甚至是最极端的谜题)。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><p id="197c" class="pw-post-body-paragraph kp kq ja kr b ks kt kb ku kv kw ke kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">如果你读完整篇文章，我想感谢你。如果你有任何想法或者修改了代码，让我在评论区知道。:)</p></div></div>    
</body>
</html>