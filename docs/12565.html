<html>
<head>
<title>Data Labelling</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据标记</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-triple-barrier-method-251268419dcd?source=collection_archive---------5-----------------------#2020-08-30">https://towardsdatascience.com/the-triple-barrier-method-251268419dcd?source=collection_archive---------5-----------------------#2020-08-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="ae7d" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" rel="noopener" target="_blank" href="/feature-engineering-feature-selection-8c1d57af18d2">📈Python for finance 系列</a></h2><div class=""/><div class=""><h2 id="f72e" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">三重屏障法</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/532fa590a169b098739bf728638c6be8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bVGbvLJ6RPr3pxEOe335JA.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="http://skuawk.com/" rel="noopener ugc nofollow" target="_blank">戴夫·甘迪</a>根据<a class="ae lh" href="https://creativecommons.org/licenses/publicdomain/" rel="noopener ugc nofollow" target="_blank">公共领域专用许可</a>拍摄的照片</p></figure><p id="7642" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> <em class="me">来自《走向数据科学》编辑的提示:</em> </strong> <em class="me">虽然我们允许独立作者根据我们的</em> <a class="ae lh" rel="noopener" target="_blank" href="/questions-96667b06af5"> <em class="me">规则和指南</em> </a> <em class="me">发表文章，但我们并不认可每个作者的贡献。你不应该在没有寻求专业建议的情况下依赖一个作者的作品。详见我们的</em> <a class="ae lh" rel="noopener" target="_blank" href="/readers-terms-b5d780a700a4"> <em class="me">读者术语</em> </a> <em class="me">。</em></p><p id="d242" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">警告:这里没有神奇的公式或圣杯，尽管一个新的世界可能会为你打开大门。</p><p id="707c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">注 1: </strong>如何安装<a class="ae lh" href="https://github.com/hudson-and-thames/mlfinlab" rel="noopener ugc nofollow" target="_blank"> mlfinlab </a>包没有错误信息可以在<a class="ae lh" href="https://medium.com/@kegui/how-to-install-mlfinlab-without-error-messages-896e2fb43c2f" rel="noopener">这里找到</a>。</p><p id="17b9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">注 2: </strong>如果你正在读马科斯·普拉多的<a class="ae lh" href="https://www.amazon.com/Advances-Financial-Machine-Learning-Marcos/dp/1119482089" rel="noopener ugc nofollow" target="_blank">金融机器学习进展</a>。<strong class="lk jd">第七期<em class="me">。</em> </strong> <a class="ae lh" href="https://medium.com/swlh/fractionally-differentiated-features-9c1947ed2b55" rel="noopener"> <strong class="lk jd"> <em class="me">细分特征</em></strong></a><strong class="lk jd"><em class="me"/></strong>是第五章关于<a class="ae lh" href="https://medium.com/swlh/fractionally-differentiated-features-9c1947ed2b55" rel="noopener">细分特征</a>。<strong class="lk jd"> <em class="me"> 8。</em> </strong> <a class="ae lh" rel="noopener" target="_blank" href="/the-triple-barrier-method-251268419dcd"> <strong class="lk jd"> <em class="me">数据标注</em> </strong> </a>是第三章关于三重障法。<em class="me">和</em> <strong class="lk jd"> <em class="me"> 9。</em> </strong> <a class="ae lh" rel="noopener" target="_blank" href="/meta-labeling-and-stacking-f17a7f9804ec"> <strong class="lk jd"> <em class="me">元标注</em></strong></a><strong class="lk jd"><em class="me"/></strong><em class="me">是第 50 页第 3.6 章。我计划一步一步地看完每一章，因为我还没有找到每一章中那些概念的详细解释。敬请关注！</em></p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h2 id="3174" class="mm mn it bd mo mp mq dn mr ms mt dp mu lr mv mw mx lv my mz na lz nb nc nd iz bi translated">📈Python For Finance 系列</h2><ol class=""><li id="b687" class="ne nf it lk b ll ng lo nh lr ni lv nj lz nk md nl nm nn no bi translated"><a class="ae lh" href="https://medium.com/python-in-plain-english/identifying-outliers-part-one-c0a31d9faefa" rel="noopener">识别异常值</a></li><li id="9376" class="ne nf it lk b ll np lo nq lr nr lv ns lz nt md nl nm nn no bi translated"><a class="ae lh" href="https://medium.com/better-programming/identifying-outliers-part-two-4c00b2523362" rel="noopener">识别异常值—第二部分</a></li><li id="62cb" class="ne nf it lk b ll np lo nq lr nr lv ns lz nt md nl nm nn no bi translated"><a class="ae lh" href="https://medium.com/swlh/identifying-outliers-part-three-257b09f5940b" rel="noopener">识别异常值—第三部分</a></li><li id="58d2" class="ne nf it lk b ll np lo nq lr nr lv ns lz nt md nl nm nn no bi translated"><a class="ae lh" rel="noopener" target="_blank" href="/data-whispering-eebb77a422da">程式化的事实</a></li><li id="53ed" class="ne nf it lk b ll np lo nq lr nr lv ns lz nt md nl nm nn no bi translated"><a class="ae lh" href="https://medium.com/@kegui/feature-engineering-feature-selection-8c1d57af18d2" rel="noopener">特征工程&amp;特征选择</a></li><li id="eae1" class="ne nf it lk b ll np lo nq lr nr lv ns lz nt md nl nm nn no bi translated"><a class="ae lh" rel="noopener" target="_blank" href="/data-transformation-e7b3b4268151">数据转换</a></li><li id="2d00" class="ne nf it lk b ll np lo nq lr nr lv ns lz nt md nl nm nn no bi translated"><a class="ae lh" href="https://medium.com/swlh/fractionally-differentiated-features-9c1947ed2b55" rel="noopener">微小差异特征</a></li><li id="6243" class="ne nf it lk b ll np lo nq lr nr lv ns lz nt md nl nm nn no bi translated"><a class="ae lh" rel="noopener" target="_blank" href="/the-triple-barrier-method-251268419dcd">数据标签</a></li><li id="d898" class="ne nf it lk b ll np lo nq lr nr lv ns lz nt md nl nm nn no bi translated"><a class="ae lh" rel="noopener" target="_blank" href="/meta-labeling-and-stacking-f17a7f9804ec">元标签和堆叠</a></li></ol></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><p id="10ad" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">三重障碍法根据马科斯·普拉多在<a class="ae lh" href="https://www.amazon.com/Advances-Financial-Machine-Learning-Marcos/dp/1119482089" rel="noopener ugc nofollow" target="_blank">金融机器学习进展</a>第三章中介绍的三个障碍中的第一个障碍来标记观察结果。标记数据的传统方法是使用第二天(滞后)回报和固定时间范围方法。这种方法可以描述如下。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/6c6c96a354cd4940be760830cfe1e07a.png" data-original-src="https://miro.medium.com/v2/resize:fit:536/format:webp/1*AWMzL20Y5dEb-s3plU9AZw.png"/></div></figure><p id="d9c0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">和</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/0c0aa39c975f310f4120864850c155fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*zL47Cf0sWlBoFhyUV7i5og.png"/></div></figure><p id="4ade" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这种流行的传统标签方法有几个缺点。首先，时间条没有表现出良好的统计特性。第二，不管观察到的波动性如何，都应用相同的阈值𝜏。基本上，标签不能反映投资的当前状态。</p><p id="0aad" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">此外，在真实情况下，第二天你可能不想卖出。因此，三重屏障方法在实践中更有意义，因为它是路径相关的。你可以根据你计划持有股票的天数以及在此期间股票的变化做出合理的决定。</p><p id="1f91" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">来自<a class="ae lh" href="https://www.amazon.com/Advances-Financial-Machine-Learning-Marcos/dp/1119482089" rel="noopener ugc nofollow" target="_blank">金融机器学习进展</a>第三章的原代码是为高频交易而创建的，使用高频数据，而且大部分是日内数据。如果您使用每日数据，我们需要稍微调整一下代码。我还从书中摘录了大部分代码，通过大量使用<code class="fe nw nx ny nz b">padas</code> <code class="fe nw nx ny nz b">DataFrame</code>结构将所有信息存储在一个地方，使其对初学者友好。通过这种方式，当你开始分析或绘制数据时，以后的生活会变得容易得多。与此同时，我采用了更复杂的方法，如<a class="ae lh" href="https://en.wikipedia.org/wiki/Average_true_range" rel="noopener ugc nofollow" target="_blank">平均真实范围</a>作为每日波动率。你可以在本文末尾看到所有的代码。</p><h1 id="f079" class="oa mn it bd mo ob oc od mr oe of og mu ki oh kj mx kl oi km na ko oj kp nd ok bi translated">直觉</h1><p id="7fe8" class="pw-post-body-paragraph li lj it lk b ll ng kd ln lo nh kg lq lr ol lt lu lv om lx ly lz on mb mc md im bi translated">这种直觉就像我以前的文章中描述的发现异常值一样。异常值就像股票交易中的突破，它定义了所有的障碍，为你做出买入或卖出的决定提供了一个窗口。如果你没看过，你可以随时回到<a class="ae lh" href="https://medium.com/python-in-plain-english/identifying-outliers-part-one-c0a31d9faefa" rel="noopener">这里</a>，这里<a class="ae lh" href="https://medium.com/@kegui/identifying-outliers-part-two-4c00b2523362" rel="noopener">这里</a>，这里<a class="ae lh" href="https://medium.com/swlh/identifying-outliers-part-three-257b09f5940b" rel="noopener">这里</a>。</p><p id="d10a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">根据马科斯·普拉多的<a class="ae lh" href="https://www.amazon.com/Advances-Financial-Machine-Learning-Marcos/dp/1119482089" rel="noopener ugc nofollow" target="_blank">金融机器学习进展</a>，三重障碍法是:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oo"><img src="../Images/b3b321ade6e314c2e1ad8cff2651cc1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TLOp56_F6TcJadpiG9y6UQ.png"/></div></div></figure><p id="d8b6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">基本上，我们现在做的是:</p><p id="b0c5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们会买入一只股票(比如苹果)，并持有 10 天。如果价格下跌并触发止损警报，我们在止损点退出，或者如果价格上涨，我们在某一点获利。在一个极端的例子中，股价横向波动，我们持有一段时间后在某一天退出。</p><p id="da6e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">假设我们有一个简单的股权管理规则:</p><ul class=""><li id="e8ec" class="ne nf it lk b ll lm lo lp lr op lv oq lz or md os nm nn no bi translated">在一次交易中，不要冒险超过你总资本的 2%。</li><li id="160e" class="ne nf it lk b ll np lo nq lr nr lv ns lz nt md os nm nn no bi translated">永远只看那些你会有 3:1 收益比的交易机会。</li></ul><p id="8114" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">基于这些简单的规则，我们在投资股票之前会制定一个交易计划。要把这个交易计划融入股价运动，我们需要三个障碍。这三个障碍是什么？四条线形成一个框架，定义一个窗口，如下所示。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ot"><img src="../Images/064ce6bd2540d67ac6edf0e998f81826.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*613xZLRkVcV9KtG5V6QqUQ.png"/></div></div></figure><p id="8662" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">x 轴是日期时间，y 轴是股票价格。a、d 线属于 x 轴，即 datatime 指数，b、c 线属于 y 轴，即股价。</p><p id="9e5a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">甲:开始日期</p><p id="747f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">b:止损出场价格</p><p id="cef2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">c:获利退出价格</p><p id="e191" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">d:开始日期+您计划持有的天数。</p><p id="03ce" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">b 和 c 不必相同。请记住，我们要设置获利了结和止损限额，它们是押注风险的函数。我们总是希望只交易那些盈利率为 3:1 的机会。这里设置<em class="me"> c = 3 * b </em>就行了。</p><p id="af7a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">关于这个话题的视频很少，我刚在 YouTube 上找到一个。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="c066" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">好了，事不宜迟，让我们深入代码。</p><h1 id="539f" class="oa mn it bd mo ob oc od mr oe of og mu ki oh kj mx kl oi km na ko oj kp nd ok bi translated">1.数据准备</h1><p id="9b72" class="pw-post-body-paragraph li lj it lk b ll ng kd ln lo nh kg lq lr ol lt lu lv om lx ly lz on mb mc md im bi translated">为了保持一致，在所有的<a class="ae lh" href="https://medium.com/swlh/identifying-outliers-part-three-257b09f5940b" rel="noopener">📈Python for finance 系列</a>，我会尽量重用相同的数据。关于数据准备的更多细节可以在<a class="ae lh" href="https://medium.com/python-in-plain-english/identifying-outliers-part-one-c0a31d9faefa" rel="noopener">这里</a>，这里<a class="ae lh" href="https://medium.com/@kegui/identifying-outliers-part-two-4c00b2523362" rel="noopener">这里</a>和<a class="ae lh" href="https://medium.com/swlh/identifying-outliers-part-three-257b09f5940b" rel="noopener">这里</a>找到，或者你可以参考我之前的<a class="ae lh" href="https://medium.com/@kegui/feature-engineering-feature-selection-8c1d57af18d2" rel="noopener">文章</a>。或者，如果你愿意，你可以忽略下面的所有代码，使用你手头上任何干净的数据，这不会影响我们将要一起做的事情。</p><pre class="ks kt ku kv gt ow nz ox oy aw oz bi"><span id="48d7" class="mm mn it nz b gy pa pb l pc pd">import pandas as pd<br/>import numpy as np<br/>import matplotlib.pyplot as plt<br/>plt.style.use('seaborn')</span><span id="ff9d" class="mm mn it nz b gy pe pb l pc pd">plt.rcParams['figure.figsize'] = [16, 9]<br/>plt.rcParams['figure.dpi'] = 300<br/>plt.rcParams['font.size'] = 20<br/>plt.rcParams['axes.labelsize'] = 20<br/>plt.rcParams['axes.titlesize'] = 24<br/>plt.rcParams['xtick.labelsize'] = 16<br/>plt.rcParams['ytick.labelsize'] = 16<br/>plt.rcParams['font.family'] = 'serif'</span><span id="155e" class="mm mn it nz b gy pe pb l pc pd">import yfinance as yf</span><span id="efa4" class="mm mn it nz b gy pe pb l pc pd">def get_data(symbols, begin_date=None,end_date=None):<br/>    df = yf.download('AAPL', start = begin_date,<br/>                     auto_adjust=True,#only download adjusted data<br/>                     end= end_date) <br/>    #my convention: always lowercase<br/>    df.columns = ['open','high','low',<br/>                  'close','volume'] <br/>    <br/>    return df</span><span id="a500" class="mm mn it nz b gy pe pb l pc pd">Apple_stock = get_data('AAPL', '2000-01-01', '2010-12-31')   <br/>price = Apple_stock['close']</span></pre><h1 id="d5e6" class="oa mn it bd mo ob oc od mr oe of og mu ki oh kj mx kl oi km na ko oj kp nd ok bi translated">2.每日波动</h1><p id="df98" class="pw-post-body-paragraph li lj it lk b ll ng kd ln lo nh kg lq lr ol lt lu lv om lx ly lz on mb mc md im bi translated">获取日波动率的原始代码(如下)是针对日内数据的，日内数据是没有周末、非工作日等的连续数据<em class="me">。</em>。</p><pre class="ks kt ku kv gt ow nz ox oy aw oz bi"><span id="cb8f" class="mm mn it nz b gy pa pb l pc pd">def getDailyVol(close,span0=100):<br/>    # daily vol, reindexed to close<br/>    df0=close.index.searchsorted(close.index-pd.Timedelta(days=1))<br/>    df0=df0[df0&gt;0]<br/>    df0=pd.Series(close.index[df0 – 1], <br/>                  index=close.index[close.shape[0]-df0.shape[0]:])<br/>    df0=close.loc[df0.index]/close.loc[df0.values].values-1 <br/>    # daily returns<br/>    df0=df0.ewm(span=span0).std()<br/>    return df0</span></pre><p id="be01" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你运行这个函数，你会得到一个错误信息:<code class="fe nw nx ny nz b"><strong class="lk jd">SyntaxError:</strong> invalid character in identifier</code>，那是因为<code class="fe nw nx ny nz b">close.index[df0–1]</code>。可以这样解决:</p><pre class="ks kt ku kv gt ow nz ox oy aw oz bi"><span id="5c76" class="mm mn it nz b gy pa pb l pc pd">def getDailyVol(close,span0=100):<br/>    # daily vol, reindexed to close<br/>    df0=close.index.searchsorted(close.index-pd.Timedelta(days=1))<br/>    df0=df0[df0&gt;0]<br/>    a = df0 -1 #using a variable to avoid the error message.<br/>    df0=pd.Series(close.index[a], <br/>                  index=close.index[close.shape[0]-df0.shape[0]:])<br/>    df0=close.loc[df0.index]/close.loc[df0.values].values-1 <br/>    # daily returns<br/>    df0=df0.ewm(span=span0).std()<br/>    return df0</span></pre><p id="aed3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你使用每日数据而不是日内数据，你将会得到很多重复的数据，因为日期向后移动了一天，并且会导致很多非工作日的数据。</p><pre class="ks kt ku kv gt ow nz ox oy aw oz bi"><span id="06b9" class="mm mn it nz b gy pa pb l pc pd">df0=close.index.searchsorted(close.index-pd.Timedelta(days=1))<br/>pd.Series(df0).value_counts()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/e781b3264889045c2cbe82113a993bcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:348/format:webp/1*dsn3HsFwu7aXn-USFSITkg.png"/></div></figure><p id="3713" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">2766–2189 = 577 个副本。</p><p id="6a32" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于每日数据，我们可以使用简单的百分比回报率的指数加权移动平均线(EWM)作为波动率。</p><pre class="ks kt ku kv gt ow nz ox oy aw oz bi"><span id="cbec" class="mm mn it nz b gy pa pb l pc pd">def get_Daily_Volatility(close,span0=20):<br/>    # simple percentage returns<br/>    df0=close.pct_change()<br/>    # 20 days, a month EWM's std as boundary<br/>    df0=df0.ewm(span=span0).std()<br/>    df0.dropna(inplace=True)<br/>    return df0</span><span id="6a87" class="mm mn it nz b gy pe pb l pc pd">df0 = get_Daily_Volatility(price)<br/>df0</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/7a4d35c7e7eb2ae69b5b35e0363dbbca.png" data-original-src="https://miro.medium.com/v2/resize:fit:538/format:webp/1*RI6cQOsfki7QxKohiWvMPg.png"/></div></figure><p id="cf53" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">根据问题的类型，我们可以选择更复杂的方法，如<a class="ae lh" href="https://www.investopedia.com/terms/a/atr.asp#:~:text=Average%20true%20range%20(ATR)%20is%20a%20technical%20indicator%20measuring%20market,to%20all%20types%20of%20securities." rel="noopener ugc nofollow" target="_blank">平均真实范围</a>(技术分析指标<a class="ae lh" href="https://www.investopedia.com/articles/trading/08/average-true-range.asp" rel="noopener ugc nofollow" target="_blank">衡量市场波动</a>)。</p><p id="c02d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">ATR 的公式是:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/442a713c7c083f3b10af05cc22552d39.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/1*gscL3oGZ-RDfQEwUSkFjxA.png"/></div></figure><p id="67a6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">计算 ATR 的第一步是找到一系列股票价格的真实范围值。给定交易日的资产价格范围就是其最高价减去最低价，而真实范围是当前最高价减去当前最低价；当前高点的<a class="ae lh" href="https://www.investopedia.com/terms/a/absolute-value.asp" rel="noopener ugc nofollow" target="_blank">绝对值</a>减去前一次收盘；和当前低点减去前一个收盘点的绝对值。平均真实范围是真实范围的<a class="ae lh" href="https://www.investopedia.com/terms/m/movingaverage.asp" rel="noopener ugc nofollow" target="_blank">移动平均</a>，通常使用 14 天。</p><pre class="ks kt ku kv gt ow nz ox oy aw oz bi"><span id="ccbd" class="mm mn it nz b gy pa pb l pc pd">def get_atr(stock, win=14):<br/>    <br/>    atr_df = pd.Series(index=stock.index)<br/>    high = pd.Series(Apple_stock.high.rolling( \<br/>                     win, min_periods=win))<br/>    low = pd.Series(Apple_stock.low.rolling( \<br/>                    win, min_periods=win))<br/>    close = pd.Series(Apple_stock.close.rolling( \<br/>                      win, min_periods=win))    <br/>          <br/>    for i in range(len(stock.index)):<br/>        tr=np.max([(high[i] - low[i]), \<br/>                  np.abs(high[i] - close[i]), \<br/>                  np.abs(low[i] - close[i])], \<br/>                  axis=0)</span><span id="caf4" class="mm mn it nz b gy pe pb l pc pd">        atr_df[i] = tr.sum() / win<br/>     <br/>    return  atr_df</span><span id="6240" class="mm mn it nz b gy pe pb l pc pd">get_atr(Apple_stock, 14)<br/>atr_df</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/faa3ae3632ec8e517c0b503c45044c1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:418/format:webp/1*3ke517e0fmhUesmN2Csi7g.png"/></div></figure><h1 id="8e41" class="oa mn it bd mo ob oc od mr oe of og mu ki oh kj mx kl oi km na ko oj kp nd ok bi translated">3.三重屏障</h1><p id="c869" class="pw-post-body-paragraph li lj it lk b ll ng kd ln lo nh kg lq lr ol lt lu lv om lx ly lz on mb mc md im bi translated">在我们开始研究护栏之前，需要确定几个参数。</p><pre class="ks kt ku kv gt ow nz ox oy aw oz bi"><span id="175a" class="mm mn it nz b gy pa pb l pc pd">#set the boundary of barriers, based on 20 days EWM<br/>daily_volatility = get_Daily_Volatility(price)<br/># how many days we hold the stock which set the vertical barrier<br/>t_final = 10 <br/>#the up and low boundary multipliers<br/>upper_lower_multipliers = [2, 2]</span><span id="6432" class="mm mn it nz b gy pe pb l pc pd">#allign the index<br/>prices = price[daily_volatility.index]</span></pre><p id="7f9c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里，我将使用<code class="fe nw nx ny nz b">pd.DataFrame</code>作为容器，将所有信息添加到一个地方。</p><pre class="ks kt ku kv gt ow nz ox oy aw oz bi"><span id="7d12" class="mm mn it nz b gy pa pb l pc pd">def get_3_barriers():<br/>    #create a container<br/>    barriers = pd.DataFrame(columns=['days_passed', <br/>              'price', 'vert_barrier', \<br/>              'top_barrier', 'bottom_barrier'], \<br/>               index = daily_volatility.index)</span><span id="5fb2" class="mm mn it nz b gy pe pb l pc pd">    for day, vol in daily_volatility.iteritems():<br/>        days_passed = len(daily_volatility.loc \<br/>                      [daily_volatility.index[0] : day])</span><span id="790d" class="mm mn it nz b gy pe pb l pc pd">        #set the vertical barrier <br/>        if (days_passed + t_final &lt; len(daily_volatility.index) \<br/>            and t_final != 0):<br/>            vert_barrier = daily_volatility.index[<br/>                                days_passed + t_final]<br/>        else:<br/>            vert_barrier = np.nan</span><span id="69e7" class="mm mn it nz b gy pe pb l pc pd">        #set the top barrier<br/>        if upper_lower_multipliers[0] &gt; 0:<br/>            top_barrier = prices.loc[day] + prices.loc[day] * \<br/>                          upper_lower_multipliers[0] * vol<br/>        else:<br/>            #set it to NaNs<br/>            top_barrier = pd.Series(index=prices.index)</span><span id="9767" class="mm mn it nz b gy pe pb l pc pd">        #set the bottom barrier<br/>        if upper_lower_multipliers[1] &gt; 0:<br/>            bottom_barrier = prices.loc[day] - prices.loc[day] * \<br/>                          upper_lower_multipliers[1] * vol<br/>        else: <br/>            #set it to NaNs<br/>            bottom_barrier = pd.Series(index=prices.index)</span><span id="f387" class="mm mn it nz b gy pe pb l pc pd">        barriers.loc[day, ['days_passed', 'price', <br/>        'vert_barrier','top_barrier', 'bottom_barrier']] = \<br/>         days_passed, prices.loc[day], vert_barrier, <br/>         top_barrier, bottom_barrier</span><span id="785f" class="mm mn it nz b gy pe pb l pc pd">   return barriers</span></pre><p id="d27b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们看看所有的障碍。</p><pre class="ks kt ku kv gt ow nz ox oy aw oz bi"><span id="a974" class="mm mn it nz b gy pa pb l pc pd">barriers = get_barriers()<br/>barriers</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/c96d5bb19d2763cd9eb349ecfbf8169c.png" data-original-src="https://miro.medium.com/v2/resize:fit:930/format:webp/1*A_OeDEWBu22MfrYDL66Axg.png"/></div></figure><p id="215b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">并仔细查看所有数据信息。</p><pre class="ks kt ku kv gt ow nz ox oy aw oz bi"><span id="8b06" class="mm mn it nz b gy pa pb l pc pd">barriers.info()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/bcd18097ae8d1d5f6e5ea9c34a9a8798.png" data-original-src="https://miro.medium.com/v2/resize:fit:694/format:webp/1*gUlCa1wtPET-l5LNRJ_gww.png"/></div></figure><p id="a9aa" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">只有<code class="fe nw nx ny nz b">vert_barrier</code>最后有 11 个<code class="fe nw nx ny nz b">NaN</code>值，因为<code class="fe nw nx ny nz b">t_final</code>被设置为 10 天。</p><p id="9aa4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">下一步是根据哪个障碍首先被触及来标记每个条目。我在<code class="fe nw nx ny nz b">barriers</code>的末尾添加了一个新列<code class="fe nw nx ny nz b">‘out’</code>。</p><pre class="ks kt ku kv gt ow nz ox oy aw oz bi"><span id="bbd8" class="mm mn it nz b gy pa pb l pc pd">barriers['out'] = None<br/>barriers.head()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/15cf15cab292cad727f5f8d22a42a25b.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*1FxoHFStXTw1xOx9rOwBbg.png"/></div></figure><p id="b27c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，我们可以在标签上工作。</p><pre class="ks kt ku kv gt ow nz ox oy aw oz bi"><span id="185b" class="mm mn it nz b gy pa pb l pc pd">def get_labels():<br/>'''<br/>start: first day of the window<br/>end:last day of the window<br/>price_initial: first day stock price<br/>price_final:last day stock price<br/>top_barrier: profit taking limit<br/>bottom_barrier:stop loss limt<br/>condition_pt:top_barrier touching conditon<br/>condition_sl:bottom_barrier touching conditon</span><span id="931a" class="mm mn it nz b gy pe pb l pc pd">'''</span><span id="9150" class="mm mn it nz b gy pe pb l pc pd">    for i in range(len(barriers.index)):</span><span id="d11b" class="mm mn it nz b gy pe pb l pc pd">        start = barriers.index[i]<br/>        end = barriers.vert_barrier[i]</span><span id="300e" class="mm mn it nz b gy pe pb l pc pd">        if pd.notna(end):<br/>            # assign the initial and final price<br/>            price_initial = barriers.price[start]<br/>            price_final = barriers.price[end]</span><span id="beac" class="mm mn it nz b gy pe pb l pc pd">            # assign the top and bottom barriers<br/>            top_barrier = barriers.top_barrier[i]<br/>            bottom_barrier = barriers.bottom_barrier[i]</span><span id="d15b" class="mm mn it nz b gy pe pb l pc pd">            #set the profit taking and stop loss conditons<br/>            condition_pt = (barriers.price[start: end] &gt;= \<br/>             top_barrier).any()<br/>            condition_sl = (barriers.price[start: end] &lt;= \<br/>             bottom_barrier).any()</span><span id="baea" class="mm mn it nz b gy pe pb l pc pd">            #assign the labels<br/>            if condition_pt: <br/>                barriers['out'][i] = 1<br/>            elif condition_sl: <br/>                barriers['out'][i] = -1    <br/>            else: <br/>                barriers['out'][i] = max(<br/>                          [(price_final - price_initial)/ <br/>                           (top_barrier - price_initial), \<br/>                           (price_final - price_initial)/ \<br/>                           (price_initial - bottom_barrier)],\<br/>                            key=abs)<br/> return</span><span id="4207" class="mm mn it nz b gy pe pb l pc pd">get_labels()<br/>barriers</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/8c6e9f0486a0d8792cd538d5b7ff0467.png" data-original-src="https://miro.medium.com/v2/resize:fit:1038/format:webp/1*7sQVW9YvSAHEL0sk7kxk-w.png"/></div></figure><p id="6f4e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以画出‘out’来看它的分布。</p><pre class="ks kt ku kv gt ow nz ox oy aw oz bi"><span id="fa51" class="mm mn it nz b gy pa pb l pc pd">plt.plot(barriers.out,'bo')</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/db1c0e76f4468a264b4e4de8f053bfbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*8q08G8hZz9Fe0QsbmI1bbQ.png"/></div></figure><p id="2816" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">并计算触发了多少获利回吐和止损限制。</p><pre class="ks kt ku kv gt ow nz ox oy aw oz bi"><span id="5fac" class="mm mn it nz b gy pa pb l pc pd">barriers.out.value_counts()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi po"><img src="../Images/df7baf6cac179c82f652d309587531ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:510/format:webp/1*Dybc4iHXwbKGa2FRfCqX0w.png"/></div></figure><p id="e327" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">2764 个数据点中有 1385 个获利了结，837 个止损。542 个案例退出是因为时间到了。</p><p id="2760" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们也可以选择一个随机的日期，并在图表上显示出来。</p><pre class="ks kt ku kv gt ow nz ox oy aw oz bi"><span id="0474" class="mm mn it nz b gy pa pb l pc pd">fig,ax = plt.subplots()<br/>ax.set(title='Apple stock price',<br/>       xlabel='date', ylabel='price')<br/>ax.plot(barriers.price[100: 200])</span><span id="ce19" class="mm mn it nz b gy pe pb l pc pd">start = barriers.index[120]<br/>end = barriers.vert_barrier[120]<br/>upper_barrier = barriers.top_barrier[120]<br/>lower_barrier = barriers.bottom_barrier[120]<br/>ax.plot([start, end], [upper_barrier, upper_barrier], 'r--');<br/>ax.plot([start, end], [lower_barrier, lower_barrier], 'r--');<br/>ax.plot([start, end], [(lower_barrier + upper_barrier)*0.5, \<br/>                       (lower_barrier + upper_barrier)*0.5], 'r--');<br/>ax.plot([start, start], [lower_barrier, upper_barrier], 'r-');<br/>ax.plot([end, end], [lower_barrier, upper_barrier], 'r-');</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ot"><img src="../Images/7ee5ec76cd232f8d0ca67fb75636a89a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LE9GlD1dVy-M1Y7hmOON4Q.png"/></div></div></figure><p id="0560" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们还可以用 easy 绘制一个动态图。</p><pre class="ks kt ku kv gt ow nz ox oy aw oz bi"><span id="0d1a" class="mm mn it nz b gy pa pb l pc pd">fig,ax = plt.subplots()<br/>ax.set(title='Apple stock price',<br/>       xlabel='date', ylabel='price')<br/>ax.plot(barriers.price[100: 200])</span><span id="892d" class="mm mn it nz b gy pe pb l pc pd">start = barriers.index[120]<br/>end = barriers.index[120+t_final]<br/>upper_barrier = barriers.top_barrier[120]<br/>lower_barrier = barriers.bottom_barrier[120]<br/>ax.plot(barriers.index[120:120+t_final+1], barriers.top_barrier[start:end], 'r--');<br/>ax.plot(barriers.index[120:120+t_final+1], barriers.bottom_barrier[start:end], 'r--');<br/>ax.plot([start, end], [(lower_barrier + upper_barrier)*0.5, \<br/>                       (lower_barrier + upper_barrier)*0.5], 'r--');<br/>ax.plot([start, start], [lower_barrier, upper_barrier], 'r-');<br/>ax.plot([end, end], [barriers.bottom_barrier[end], barriers.top_barrier[end]], 'r-');</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/53acb4908669d5f48b98dc5967f3e630.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*aRd48lCCxHeESnOptLW7ag.png"/></div></figure><p id="f436" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">回顾我们拥有的参数:</strong></p><ul class=""><li id="f12a" class="ne nf it lk b ll lm lo lp lr op lv oq lz or md os nm nn no bi translated">数据:苹果 10 年股价</li><li id="3b18" class="ne nf it lk b ll np lo nq lr nr lv ns lz nt md os nm nn no bi translated">保持时间:不超过 10 天</li><li id="7483" class="ne nf it lk b ll np lo nq lr nr lv ns lz nt md os nm nn no bi translated">获利回吐界限:20 天返回 EWM 标准的 2 倍</li><li id="567d" class="ne nf it lk b ll np lo nq lr nr lv ns lz nt md os nm nn no bi translated">止损边界:20 天返回 EWM 标准的 2 倍</li></ul><p id="124f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">我们在真实案例中期待的规则:</strong></p><ul class=""><li id="908f" class="ne nf it lk b ll lm lo lp lr op lv oq lz or md os nm nn no bi translated">永远只关注那些你将会有 3:1 盈利率的交易机会。</li><li id="0fe7" class="ne nf it lk b ll np lo nq lr nr lv ns lz nt md os nm nn no bi translated">在一次交易中，不要冒险超过你总资本的 2%。</li></ul><p id="ddee" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">第一条规则可以通过设置<code class="fe nw nx ny nz b">upper_lower_multipliers = [3, 1]</code>轻松实现。第二个是关于交易规模，边乘以规模将使我们能够计算风险(保证金/优势)。这将是下一篇文章中的元标签。所以，敬请期待！</p><p id="a2d8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">以下是所有代码:</p><pre class="ks kt ku kv gt ow nz ox oy aw oz bi"><span id="b156" class="mm mn it nz b gy pa pb l pc pd">import pandas as pd<br/>import numpy as np<br/>import matplotlib.pyplot as plt<br/>plt.style.use('seaborn')</span><span id="4558" class="mm mn it nz b gy pe pb l pc pd">plt.rcParams['figure.figsize'] = [16, 9]<br/>plt.rcParams['figure.dpi'] = 300<br/>plt.rcParams['font.size'] = 20<br/>plt.rcParams['axes.labelsize'] = 20<br/>plt.rcParams['axes.titlesize'] = 24<br/>plt.rcParams['xtick.labelsize'] = 16<br/>plt.rcParams['ytick.labelsize'] = 16<br/>plt.rcParams['font.family'] = 'serif'</span><span id="4fb2" class="mm mn it nz b gy pe pb l pc pd">import yfinance as yf</span><span id="0b88" class="mm mn it nz b gy pe pb l pc pd">def get_data(symbols, begin_date=None,end_date=None):<br/>    df = yf.download('AAPL', start = begin_date,<br/>                     auto_adjust=True,#only download adjusted data<br/>                     end= end_date) <br/>    #my convention: always lowercase<br/>    df.columns = ['open','high','low',<br/>                  'close','volume'] <br/>    <br/>    return df</span><span id="375c" class="mm mn it nz b gy pe pb l pc pd">Apple_stock = get_data('AAPL', '2000-01-01', '2010-12-31')   <br/>price = Apple_stock['close']</span><span id="858a" class="mm mn it nz b gy pe pb l pc pd">def get_Daily_Volatility(close,span0=20):<br/>    # simple percentage returns<br/>    df0=close.pct_change()<br/>    # 20 days, a month EWM's std as boundary<br/>    df0=df0.ewm(span=span0).std()<br/>    df0.dropna(inplace=True)<br/>    return df0</span><span id="95bd" class="mm mn it nz b gy pe pb l pc pd">df0 = get_Daily_Volatility(price)</span><span id="a35f" class="mm mn it nz b gy pe pb l pc pd">def get_atr(stock, win=14):<br/>    <br/>    atr_df = pd.Series(index=stock.index)<br/>    high = pd.Series(Apple_stock.high.rolling( \<br/>                     win, min_periods=win))<br/>    low = pd.Series(Apple_stock.low.rolling( \<br/>                    win, min_periods=win))<br/>    close = pd.Series(Apple_stock.close.rolling( \<br/>                      win, min_periods=win))    <br/>          <br/>    for i in range(len(stock.index)):<br/>        tr=np.max([(high[i] - low[i]), \<br/>                  np.abs(high[i] - close[i]), \<br/>                  np.abs(low[i] - close[i])], \<br/>                  axis=0)</span><span id="2a7b" class="mm mn it nz b gy pe pb l pc pd">    atr_df[i] = tr.sum() / win<br/>     <br/>    return  atr_df</span><span id="6a7d" class="mm mn it nz b gy pe pb l pc pd">#set the boundary of barriers, based on 20 days EWM<br/>daily_volatility = get_Daily_Volatility(price)<br/># how many days we hold the stock which set the vertical barrier<br/>t_final = 10 <br/>#the up and low boundary multipliers<br/>upper_lower_multipliers = [2, 2]</span><span id="c310" class="mm mn it nz b gy pe pb l pc pd">#allign the index<br/>prices = price[daily_volatility.index]</span><span id="acef" class="mm mn it nz b gy pe pb l pc pd">def get_3_barriers():<br/>    #create a container<br/>    barriers = pd.DataFrame(columns=['days_passed', <br/>              'price', 'vert_barrier', \<br/>              'top_barrier', 'bottom_barrier'], \<br/>               index = daily_volatility.index)</span><span id="1742" class="mm mn it nz b gy pe pb l pc pd">   for day, vol in daily_volatility.iteritems():<br/>        days_passed = len(daily_volatility.loc \<br/>                      [daily_volatility.index[0] : day])</span><span id="8556" class="mm mn it nz b gy pe pb l pc pd">        #set the vertical barrier <br/>        if (days_passed + t_final &lt; len(daily_volatility.index) \<br/>            and t_final != 0):<br/>            vert_barrier = daily_volatility.index[<br/>                                days_passed + t_final]<br/>        else:<br/>            vert_barrier = np.nan</span><span id="de67" class="mm mn it nz b gy pe pb l pc pd">        #set the top barrier<br/>        if upper_lower_multipliers[0] &gt; 0:<br/>            top_barrier = prices.loc[day] + prices.loc[day] * \<br/>                          upper_lower_multipliers[0] * vol<br/>        else:<br/>            #set it to NaNs<br/>            top_barrier = pd.Series(index=prices.index)</span><span id="a457" class="mm mn it nz b gy pe pb l pc pd">        #set the bottom barrier<br/>        if upper_lower_multipliers[1] &gt; 0:<br/>            bottom_barrier = prices.loc[day] - prices.loc[day] * \<br/>                          upper_lower_multipliers[1] * vol<br/>        else: <br/>            #set it to NaNs<br/>            bottom_barrier = pd.Series(index=prices.index)</span><span id="863e" class="mm mn it nz b gy pe pb l pc pd">        barriers.loc[day, ['days_passed', 'price', \<br/>        'vert_barrier','top_barrier', 'bottom_barrier']] = \<br/>         days_passed, prices.loc[day], vert_barrier, \<br/>         top_barrier, bottom_barrier</span><span id="9485" class="mm mn it nz b gy pe pb l pc pd">return barriers</span><span id="95ed" class="mm mn it nz b gy pe pb l pc pd">def get_labels():<br/>'''<br/>start: first day of the window<br/>end:last day of the window<br/>price_initial: first day stock price<br/>price_final:last day stock price<br/>top_barrier: profit taking limit<br/>bottom_barrier:stop loss limt<br/>condition_pt:top_barrier touching conditon<br/>condition_sl:bottom_barrier touching conditon</span><span id="9d7f" class="mm mn it nz b gy pe pb l pc pd">'''</span><span id="d9df" class="mm mn it nz b gy pe pb l pc pd">for i in range(len(barriers.index)):</span><span id="7d0b" class="mm mn it nz b gy pe pb l pc pd">start = barriers.index[i]<br/>        end = barriers.vert_barrier[i]</span><span id="bc15" class="mm mn it nz b gy pe pb l pc pd">if pd.notna(end):<br/>            # assign the initial and final price<br/>            price_initial = barriers.price[start]<br/>            price_final = barriers.price[end]</span><span id="7545" class="mm mn it nz b gy pe pb l pc pd"># assign the top and bottom barriers<br/>            top_barrier = barriers.top_barrier[i]<br/>            bottom_barrier = barriers.bottom_barrier[i]</span><span id="e94a" class="mm mn it nz b gy pe pb l pc pd">#set the profit taking and stop loss conditons<br/>            condition_pt = (barriers.price[start: end] &gt;= \<br/>             top_barrier).any()<br/>            condition_sl = (barriers.price[start: end] &lt;= \<br/>             bottom_barrier).any()</span><span id="6808" class="mm mn it nz b gy pe pb l pc pd">#assign the labels<br/>            if condition_pt: <br/>                barriers['out'][i] = 1<br/>            elif condition_sl: <br/>                barriers['out'][i] = -1    <br/>            else: <br/>                barriers['out'][i] = max(<br/>                          [(price_final - price_initial)/ <br/>                           (top_barrier - price_initial), \<br/>                           (price_final - price_initial)/ \<br/>                           (price_initial - bottom_barrier)],\<br/>                            key=abs)<br/> return</span><span id="5a9e" class="mm mn it nz b gy pe pb l pc pd">get_labels()<br/>barriers</span><span id="ff8a" class="mm mn it nz b gy pe pb l pc pd">fig,ax = plt.subplots()<br/>ax.set(title='Apple stock price',<br/>       xlabel='date', ylabel='price')<br/>ax.plot(barriers.price[100: 200])</span><span id="a1ff" class="mm mn it nz b gy pe pb l pc pd">start = barriers.index[120]<br/>end = barriers.vert_barrier[120]<br/>upper_barrier = barriers.top_barrier[120]<br/>lower_barrier = barriers.bottom_barrier[120]<br/>ax.plot([start, end], [upper_barrier, upper_barrier], 'r--');<br/>ax.plot([start, end], [lower_barrier, lower_barrier], 'r--');<br/>ax.plot([start, end], [(lower_barrier + upper_barrier)*0.5, \<br/>                       (lower_barrier + upper_barrier)*0.5], 'r--');<br/>ax.plot([start, start], [lower_barrier, upper_barrier], 'r-');<br/>ax.plot([end, end], [lower_barrier, upper_barrier], 'r-');</span><span id="0974" class="mm mn it nz b gy pe pb l pc pd">#dynamic graph<br/>fig,ax = plt.subplots()<br/>ax.set(title='Apple stock price',<br/>       xlabel='date', ylabel='price')<br/>ax.plot(barriers.price[100: 200])</span><span id="5a22" class="mm mn it nz b gy pe pb l pc pd">start = barriers.index[120]<br/>end = barriers.index[120+t_final]<br/>upper_barrier = barriers.top_barrier[120]<br/>lower_barrier = barriers.bottom_barrier[120]<br/>ax.plot(barriers.index[120:120+t_final+1], barriers.top_barrier[start:end], 'r--');<br/>ax.plot(barriers.index[120:120+t_final+1], barriers.bottom_barrier[start:end], 'r--');<br/>ax.plot([start, end], [(lower_barrier + upper_barrier)*0.5, \<br/>                       (lower_barrier + upper_barrier)*0.5], 'r--');<br/>ax.plot([start, start], [lower_barrier, upper_barrier], 'r-');<br/>ax.plot([end, end], [barriers.bottom_barrier[end], barriers.top_barrier[end]], 'r-');</span></pre></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="91fd" class="oa mn it bd mo ob pq od mr oe pr og mu ki ps kj mx kl pt km na ko pu kp nd ok bi translated">参考</h1><ol class=""><li id="1f9c" class="ne nf it lk b ll ng lo nh lr ni lv nj lz nk md nl nm nn no bi translated"><a class="ae lh" href="https://www.quantopian.com/posts/introduction-to-advances-in-financial-machine-learning-by-lopez-de-prado" rel="noopener ugc nofollow" target="_blank">洛佩兹·德·普拉多的《金融机器学习的进展》简介</a></li></ol></div></div>    
</body>
</html>