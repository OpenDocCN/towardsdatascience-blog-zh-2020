# 无服务器计算简介

> 原文：<https://towardsdatascience.com/a-brief-introduction-to-serverless-computing-e867eb71b54b?source=collection_archive---------43----------------------->

## [入门](https://towardsdatascience.com/tagged/getting-started)

![](img/53bf41fae86c2f41c44e06c163bfeca4.png)

泰勒·维克在 Upsplash 上拍摄的照片

# 变得抽象

在过去的一二十年里，云计算已经主导了开发“现代”软件所需的许多技能和过程。对于相邻的领域也是如此，包括数据科学领域(以及其他领域)。这种全面转向“云”的趋势之一是，关于开发团队如何与运行他们的应用程序的基础设施进行交互的抽象水平不断提高。

可以说，在这个抽象金字塔的顶端是无服务器计算的概念，它建立在这样的想法上(顾名思义)，开发人员不需要花时间配置服务器和编写样板应用程序代码，而是应该直接编写和部署“真正”推动商业价值的代码。这还可以让开发人员、数据科学家和其他人非常容易地部署简单的应用程序和服务，而几乎没有或根本没有配置部署“经典”web 应用程序所需的基础架构的经验。如果这听起来对你有用，那太好了！这篇文章旨在为你提供:

*   对无服务器计算的高度理解。
*   了解无服务器计算的相对优点及其一些缺点。
*   在 Google Cloud 上设置自己的无服务器 Python 函数的简短指南。

让我们开始吧。

**经典方法**

要了解无服务器计算的潜在优势，不妨后退一步，看看在云中为最新、最棒的应用程序设置新服务器的“经典”工作流程。如果你以前做过这个(也许是用[烧瓶](https://flask.palletsprojects.com/en/1.1.x/)或 [Express](https://expressjs.com/) 应用程序)，这可能看起来很熟悉:

1.  在您选择的云提供商上创建一个新的虚拟机:选择您的系统资源(内存、CPU 数量等。)，选择您想要使用的操作系统，或许还可以创建一些凭证来远程访问您的新机器。
2.  将您的新机器配置为接受特定端口上的公共流量。
3.  设置 [NGINX](https://www.nginx.com/) (或其他网络服务器)将请求从这个端口转发到你的应用。
4.  配置自动缩放规则(如果需要)。
5.  编写应用程序的特定于框架的样板文件，如请求处理程序和其他服务器代码。
6.  **写出你的商业逻辑。**

虽然这是一个*小*做作，但事实仍然是，使用这种“经典”工作流部署你自己的应用程序需要花费大量的时间和精力在任务*而不是*上，而不是编写你的“核心”应用程序代码。更重要的是:你将为你的服务器运行的每一秒钟付费，不管它被使用了多少。如果你的应用程序有很长的静默期(比如说一整夜)，这可能会在你(或你公司)的口袋里烧一个洞。

**进入无服务器**

您可能已经看到了这一点:如果您不需要做大量的(通常是死记硬背的)配置，而是直接投入到具体的编码问题中，会发生什么？这是无服务器计算背后的核心理念。从根本上说，服务器仍然以某种形式存在，但是公开应用程序的服务器的设置和配置被抽象掉了。从实际角度来看，这意味着:

*   您不必手动配置和维护您的虚拟机。
*   你不必写(*多*)样板框架代码。
*   您不需要配置任何防火墙规则、端口转发或自动扩展。

本质上，无服务器计算的一个关键目标是通过最大化开发人员花费在编写最终驱动业务价值的业务逻辑上的时间，以及更少的编写逻辑的时间，来显著减少开发人员的典型工作量。作为开发人员，您编写一个函数来捕获一些有价值的业务逻辑，并可以立即将其作为可大规模扩展的服务发布。理论上，这是缩短价值实现时间的好方法。借用谷歌的说法，无服务器计算允许任何人使用他们的应用程序:

> *“从原型到生产再到星球规模。”*

还有一件事。您只需为您使用的东西付费。如果你对你的服务的需求很低，你付的钱就少。对于上面讨论的传统虚拟机部署，这不太可能是真的。

# 事件驱动架构

那么它是如何做到这一点的呢？

无服务器计算的关键使能技术之一是所谓的“微虚拟机”，如[鞭炮](https://firecracker-microvm.github.io/)。此类技术允许云提供商快速“启动”新虚拟机，以便按需运行您的代码，然后在不使用时快速关闭它们。这就是“事件驱动架构”这个术语的由来:你的代码和它所在的虚拟机只有在被一个事件触发时才会运行(例如，对函数的请求，或者其他一些触发，比如来自调度器的在特定时间运行函数的信号)。

额外的好处是，云提供商将根据需要“启动”尽可能多的虚拟机来满足您的服务需求，这意味着您的功能/应用程序可以近乎无限地扩展(尽管这将变得非常昂贵！).实际上，这意味着在最小的情况下，您需要做的就是用您选择的语言编写一个简单的函数，并告诉您选择的提供者将其公开为无服务器函数。

> 实际上，这意味着在最小的情况下，你需要做的就是用你选择的语言写一个简单的函数，并告诉你选择的提供者将其公开为无服务器函数。

你所需要做的就是坚持一些规则和惯例，它将会开箱即用。一会儿你就会明白这句话是多么的字面意思。听起来很酷，对吧？

# 秘密地

这一切似乎好得令人难以置信。许多这样的工具和框架落入了夸大其词的陷阱，结果只是把问题拖来拖去。但是在无服务器的情况下，真的*能*那么好吗。至少有时候是这样。通常情况下。前提是你至少同意一些(可能很小，但可能是致命的)警告。以下是一些需要注意的主要问题:

*   **冷启动**——如你所见，当不使用时，管理你的无服务器代码的“实际”服务器可能会停止运转。这为您节省了资金，但是当您向无服务器功能发送请求以启动机器时，也会增加(通常很短)延迟。这种延迟可能是一两秒的量级，特别是对于一些众所周知启动时间[很慢的解释语言。当你的功能重新启动后，它将在几分钟内保持高度响应，在此之后，如果没有使用，它将重新关闭。如果您的应用程序不能容忍这种延迟，那么无服务器功能可能会有问题。](https://lwn.net/Articles/730915/)
*   **资源有限&可配置性** —无服务器计算的好处之一也是其潜在的缺点之一:它限制了运行代码的环境、操作系统和“硬件”的可配置性。如果您想运行大量 CPU 或内存密集型操作的代码，这就很麻烦了(许多数据科学问题都有这种情况)。如果你需要大量的 CPU 和 RAM 来运行你的函数，你可能需要去别处看看。
*   **调试** —这个可能会有问题。由于您对代码运行的环境没有相同级别的控制，因此很难有效地调试一些问题，并且在开发期间建立一个有代表性的测试环境比正常情况下更难。此外，如果您的应用程序最终运行多个无服务器功能作为其架构的一部分，那么随着应用程序复杂性的增加，跟踪正在发生的事情和发生的位置会变得非常困难。
*   **供应商锁定** —最后，云提供商通常会提供自己的框架来在其平台上部署无服务器功能。这使得将代码从一个提供者迁移到另一个提供者变得更加困难。

综上所述，如果你有一个应用程序可以忍受低需求时期的偶尔延迟，你的工作负载对资源的要求相对较低，并且你不介意潜在地依赖于特定的云提供商，那么无服务器很可能是解决你的问题的理想解决方案。

# 是时候写点代码了

还感兴趣吗？很好。这里有一个简单的例子，说明如何将自己的 Python 函数部署为[Google Cloud Function](https://cloud.google.com/functions?hl=hu)——Google 的无服务器计算产品。首先，如果你还没有一个谷歌云账户，你应该[去注册一个新账户](https://cloud.google.com/free)。新注册的用户可以获得 300 美元的积分，所以这个例子不会花你一分钱。

接下来，安装 Google `gcloud`命令行工具。[谷歌的文档](https://cloud.google.com/sdk/docs/quickstarts)给出了如何在你的平台上做这件事的演示。

好了，该编码了。下面是您将要部署的代码:

```
def say_hello(request): 
    name = request.args.get("name") 
    return f"Hello there, {name}!"
```

这很简单。您真正需要理解的唯一一件事是，这个函数的`request`参数是一个 [Flask 请求上下文](https://flask.palletsprojects.com/en/1.1.x/reqcontext/)。如您所料，该对象包含特定于您的请求的信息，包括作为 URL 的一部分传递的参数。在这种情况下，您将从 URL 中取出`name`参数。具体地说，如果你向`some.domain.name/say-hello?name=Jane`发送一个请求，这将提取`name`参数。通过这种方式，您可以让函数访问任意的有效负载。

接下来，在您选择的新目录中，将这段代码复制到名为`main.py`的文件中。Google 的框架期望一个这个名字的文件，所以最好打球。如果您想安装额外的包，您可以在与您的`main.py`相同的目录中包含一个`requirements.txt`文件，这些将在您的功能部署时为您安装。现在，您已经准备好部署您的功能了。

要进行部署，您可以运行:

```
gcloud functions deploy say-hello --entry-point=say_hello --runtime=python37 --project={project} --allow-unauthenticated --trigger-http
```

让我们打开包装。

*   命令`gcloud functions deploy`告诉`gcloud`你想要部署一个函数，下一个参数`say-hello`就是你的云函数的名字。这也将用作您的功能的路线(即，它将在`/say-hello`可访问)；
*   `--entry-point`指向`main.py`中您想要公开的函数，而`--runtime`告诉部署工具您想要将代码部署到哪个云函数运行时(在本例中是 Python 3.7)；
*   然后,`--project`参数指定您希望在其上部署云功能的 Google Cloud 项目 ID(请确保在这里输入您自己的项目 ID！);
*   最后，`--allow-unauthenticated`标志告诉部署工具公开公开该函数(您可能希望在生产中更改这一点！)，而`--trigger-http`请求告诉它在 HTTP 请求时被触发。

运行该命令，几分钟后，您应该能够转到如下 URL(记住替换您自己的子域—您可以在上面命令的控制台输出中找到它):

```
[https://{subdomain}.cloudfunctions.net/say-hello?name=World](https://{subdomain}.cloudfunctions.net/say-hello?name=World)
```

你应该会得到回应:

```
Hello there, World!
```

好了，你已经部署了一个谷歌云功能！

*原载于 2020 年 7 月 22 日*[*https://mark . douthwaite . io*](https://mark.douthwaite.io/a-brief-introduction-to-serverless-computing/)*。*