<html>
<head>
<title>Exploring confusion matrix evolution on tensorboard</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索张量板上混淆矩阵的演化</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/exploring-confusion-matrix-evolution-on-tensorboard-e66b39f4ac12?source=collection_archive---------15-----------------------#2020-05-18">https://towardsdatascience.com/exploring-confusion-matrix-evolution-on-tensorboard-e66b39f4ac12?source=collection_archive---------15-----------------------#2020-05-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1ada" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">训练卷积神经网络对来自数据集的图像进行分类，并使用TensorBoard来探索其混淆矩阵如何演变。</h2></div></div><div class="ab cl kf kg hu kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="ij ik il im in"><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/aaf58180ab4c8fb39063c45054aea393.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PFzmSYbKoH6GtXNDLK1iZA.png"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">张量板上的混淆矩阵演化</p></figure><p id="8f64" class="pw-post-body-paragraph lc ld iq le b lf lg jr lh li lj ju lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">Tensorboard是在训练和验证神经网络时可视化许多指标的最佳工具。在大多数情况下，我们需要寻找更多的细节，比如模型如何处理验证数据。有时训练和验证损失和准确性是不够的，我们需要弄清楚验证数据的性能。一种方法是使用混淆矩阵来可视化。</p><h1 id="096c" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">混淆矩阵</h1><p id="7825" class="pw-post-body-paragraph lc ld iq le b lf mq jr lh li mr ju lk ll ms ln lo lp mt lr ls lt mu lv lw lx ij bi translated">在<a class="ae mv" href="https://en.wikipedia.org/wiki/Machine_learning" rel="noopener ugc nofollow" target="_blank">机器学习</a>领域，特别是<a class="ae mv" href="https://en.wikipedia.org/wiki/Statistical_classification" rel="noopener ugc nofollow" target="_blank">统计分类</a>问题中，<strong class="le ir">混淆矩阵</strong>，也被称为误差矩阵，是一种特定的表格布局，允许算法性能的可视化，通常是<a class="ae mv" href="https://en.wikipedia.org/wiki/Supervised_learning" rel="noopener ugc nofollow" target="_blank">监督学习</a>算法(在<a class="ae mv" href="https://en.wikipedia.org/wiki/Unsupervised_learning" rel="noopener ugc nofollow" target="_blank">非监督学习</a>中，它通常被称为<strong class="le ir">匹配矩阵</strong>)。<a class="ae mv" href="https://en.wikipedia.org/wiki/Matrix_(mathematics)" rel="noopener ugc nofollow" target="_blank">矩阵</a>的每一行代表预测类中的实例，而每一列代表实际类中的实例(反之亦然)。该名称源于这样一个事实，即它可以很容易地看出系统是否混淆了两个类(即通常将一个类误标为另一个类)。</p><h1 id="a001" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">让我们建立一个混淆矩阵</h1><p id="799f" class="pw-post-body-paragraph lc ld iq le b lf mq jr lh li mr ju lk ll ms ln lo lp mt lr ls lt mu lv lw lx ij bi translated">我不会深入研究编码，我将只强调重要的代码部分，展示如何用python在tensorboard中设置和实现自定义回调。如果你想查看完整的代码，你可以查看我的知识库，我在这个故事的底部添加了一个链接。</p><p id="31bb" class="pw-post-body-paragraph lc ld iq le b lf lg jr lh li lj ju lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">我假设您已经构建并编译了一个Keras序列模型。</p><p id="115b" class="pw-post-body-paragraph lc ld iq le b lf lg jr lh li lj ju lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated"><strong class="le ir">定义绘制cm的函数</strong></p><pre class="kn ko kp kq gt mw mx my mz aw na bi"><span id="b6da" class="nb lz iq mx b gy nc nd l ne nf">def plot_confusion_matrix(cm, class_names):<br/>    """<br/>    Returns a matplotlib figure containing the plotted confusion matrix.<br/>    <br/>    Args:<br/>       cm (array, shape = [n, n]): a confusion matrix of integer classes<br/>       class_names (array, shape = [n]): String names of the integer classes<br/>    """<br/>    <br/>    figure = plt.figure(figsize=(8, 8))<br/>    plt.imshow(cm, interpolation='nearest', cmap=plt.cm.Blues)<br/>    plt.title("Confusion matrix")<br/>    plt.colorbar()<br/>    tick_marks = np.arange(len(class_names))<br/>    plt.xticks(tick_marks, class_names, rotation=45)<br/>    plt.yticks(tick_marks, class_names)<br/>    <br/>    # Normalize the confusion matrix.<br/>    cm = np.around(cm.astype('float') / cm.sum(axis=1)[:, np.newaxis], decimals=2)<br/>    <br/>    # Use white text if squares are dark; otherwise black.<br/>    threshold = cm.max() / 2.<br/>    <br/>    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):<br/>        color = "white" if cm[i, j] &gt; threshold else "black"<br/>        plt.text(j, i, cm[i, j], horizontalalignment="center", color=color)<br/>        <br/>    plt.tight_layout()<br/>    plt.ylabel('True label')<br/>    plt.xlabel('Predicted label')<br/>    return figure</span></pre><h1 id="d24a" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">设置tensorboard回调</h1><p id="a260" class="pw-post-body-paragraph lc ld iq le b lf mq jr lh li mr ju lk ll ms ln lo lp mt lr ls lt mu lv lw lx ij bi translated">我们现在准备训练CNN，并在此过程中定期记录混淆矩阵。使用下面的代码，您将创建一个<a class="ae mv" href="https://www.tensorflow.org/api_docs/python/tf/keras/callbacks/TensorBoard" rel="noopener ugc nofollow" target="_blank"> Keras TensorBoard回调</a>来记录基本指标。</p><pre class="kn ko kp kq gt mw mx my mz aw na bi"><span id="820d" class="nb lz iq mx b gy nc nd l ne nf">logdir = "logs/image/" + datetime.now().strftime("%Y%m%d-%H%M%S")</span><span id="e86d" class="nb lz iq mx b gy ng nd l ne nf">tensorboard_callback = keras.callbacks.TensorBoard(log_dir = logdir, histogram_freq = 1)</span><span id="df1e" class="nb lz iq mx b gy ng nd l ne nf">file_writer_cm = tf.summary.create_file_writer(logdir + '/cm')</span></pre><h1 id="25ea" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">将Matplotlib图形转换为PNG</h1><p id="af6e" class="pw-post-body-paragraph lc ld iq le b lf mq jr lh li mr ju lk ll ms ln lo lp mt lr ls lt mu lv lw lx ij bi translated">遗憾的是，Matplotlib文件格式不能作为图像记录，但PNG文件格式可以记录。因此，我们将创建一个helper函数，它接受一个Matplotlib图形，并将其转换为PNG格式，以便可以编写。</p><pre class="kn ko kp kq gt mw mx my mz aw na bi"><span id="dd3a" class="nb lz iq mx b gy nc nd l ne nf">def plot_to_image(figure):<br/>    """<br/>    Converts the matplotlib plot specified by 'figure' to a PNG image and<br/>    returns it. The supplied figure is closed and inaccessible after this call.<br/>    """<br/>    <br/>    buf = io.BytesIO()<br/>    <br/>    # Use plt.savefig to save the plot to a PNG in memory.<br/>    plt.savefig(buf, format='png')<br/>    <br/>    # Closing the figure prevents it from being displayed directly inside<br/>    # the notebook.<br/>    plt.close(figure)<br/>    buf.seek(0)<br/>    <br/>    # Use tf.image.decode_png to convert the PNG buffer<br/>    # to a TF image. Make sure you use 4 channels.<br/>    image = tf.image.decode_png(buf.getvalue(), channels=4)<br/>    <br/>    # Use tf.expand_dims to add the batch dimension<br/>    image = tf.expand_dims(image, 0)<br/>    <br/>    return image</span></pre><h1 id="59d7" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">计算混淆矩阵</h1><p id="82e0" class="pw-post-body-paragraph lc ld iq le b lf mq jr lh li mr ju lk ll ms ln lo lp mt lr ls lt mu lv lw lx ij bi translated">我们将定义一个计算混淆矩阵的函数。</p><pre class="kn ko kp kq gt mw mx my mz aw na bi"><span id="cf91" class="nb lz iq mx b gy nc nd l ne nf">def log_confusion_matrix(epoch, logs):<br/>    <br/>    # Use the model to predict the values from the test_images.<br/>    test_pred_raw = model.predict(test_images)<br/>    <br/>    test_pred = np.argmax(test_pred_raw, axis=1)<br/>    <br/>    # Calculate the confusion matrix using sklearn.metrics<br/>    cm = sklearn.metrics.confusion_matrix(test_labels, test_pred)<br/>    <br/>    figure = plot_confusion_matrix(cm, class_names=class_names)<br/>    cm_image = plot_to_image(figure)<br/>    <br/>    # Log the confusion matrix as an image summary.<br/>    with file_writer_cm.as_default():<br/>        tf.summary.image("Confusion Matrix", cm_image, step=epoch)</span></pre><h1 id="0904" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">设置张量板以记录混淆矩阵</h1><p id="54f3" class="pw-post-body-paragraph lc ld iq le b lf mq jr lh li mr ju lk ll ms ln lo lp mt lr ls lt mu lv lw lx ij bi translated">我们将在纪元结束时设置tensorboard回调来记录混淆矩阵</p><pre class="kn ko kp kq gt mw mx my mz aw na bi"><span id="c029" class="nb lz iq mx b gy nc nd l ne nf">cm_callback = keras.callbacks.LambdaCallback(on_epoch_end=log_confusion_matrix)</span></pre><h1 id="cbb1" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated"><strong class="ak">开始冲浪板和训练</strong></h1><p id="6f48" class="pw-post-body-paragraph lc ld iq le b lf mq jr lh li mr ju lk ll ms ln lo lp mt lr ls lt mu lv lw lx ij bi translated">我们需要将值指定为model.fit中回调参数的列表，以指定Keras在训练时使用我们的自定义回调函数。</p><pre class="kn ko kp kq gt mw mx my mz aw na bi"><span id="a78a" class="nb lz iq mx b gy nc nd l ne nf"># Start TensorBoard.<br/>%tensorboard --logdir logs/image</span><span id="8a25" class="nb lz iq mx b gy ng nd l ne nf"># Train the classifier.<br/>model.fit(train_images,<br/>          train_labels,<br/>          epochs=5,<br/>          verbose=0, # Suppress chatty output<br/>          callbacks=[tensorboard_callback, cm_callback],<br/>          validation_data=(test_images, test_labels))</span></pre><p id="afcb" class="pw-post-body-paragraph lc ld iq le b lf lg jr lh li lj ju lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">默认情况下，tensorboard服务器运行在端口6006上，如果您想要指定任何其他端口，您需要将该端口指定为tensorboard命令的参数。<br/> Jupyter用户只需在第一个单元格中键入<code class="fe nh ni nj mx b">%load_ext tensorboard</code>并在导入库之前运行，这将在Jupyter笔记本中加载tensorboard。</p><h1 id="1ad2" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">让我们看看我们的困惑矩阵</h1><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/56da57d6a512eb2af517757606d7724c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/1*eDB6V0wZySvazHwOoP1Z-Q.png"/></div></figure><p id="5fe9" class="pw-post-body-paragraph lc ld iq le b lf lg jr lh li lj ju lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated"><strong class="le ir">想试试自己吗</strong></p><div class="nl nm gp gr nn no"><a href="https://github.com/novasush/Tensorboard-with-Fashion-MNIST" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd ir gy z fp nt fr fs nu fu fw ip bi translated">novas ush/tensor board-时尚MNIST</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">训练一个卷积神经网络来分类时尚MNIST数据集的图像，并使用TensorBoard来探索…</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">github.com</p></div></div><div class="nx l"><div class="ny l nz oa ob nx oc kw no"/></div></div></a></div><p id="5f64" class="pw-post-body-paragraph lc ld iq le b lf lg jr lh li lj ju lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">参考我的Github回购链接。我在时尚Mnist数据集上训练了一个CNN分类器，并设置了一个混淆矩阵。以上输出来自我的tensorboard服务器。</p><h1 id="0bdd" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">额外资源</h1><ol class=""><li id="0137" class="od oe iq le b lf mq li mr ll of lp og lt oh lx oi oj ok ol bi translated"><a class="ae mv" href="https://neptune.ai/blog/tensorboard-tutorial" rel="noopener ugc nofollow" target="_blank"> <strong class="le ir">深度潜入张量板:教程附实例</strong></a><strong class="le ir"><br/></strong><a class="ae mv" href="https://neptune.ai/blog/tensorboard-tutorial" rel="noopener ugc nofollow" target="_blank">https://neptune.ai/blog/tensorboard-tutorial</a></li></ol></div></div>    
</body>
</html>