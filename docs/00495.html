<html>
<head>
<title>Ultimate Setup for Your Next Python Project</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">下一个 Python 项目的最终设置</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/ultimate-setup-for-your-next-python-project-179bda8a7c2c?source=collection_archive---------0-----------------------#2020-01-15">https://towardsdatascience.com/ultimate-setup-for-your-next-python-project-179bda8a7c2c?source=collection_archive---------0-----------------------#2020-01-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b5fc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从零开始任何项目都可能是一项艰巨的任务…但如果你有这个终极的<em class="ki"> Python </em>项目蓝图就不会了！</h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/fc9d35b26663080bd0fa81ef8e67da91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z3_WZhfnYaszO5bLQNnU_Q.jpeg"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">Unsplash 上<a class="ae kz" href="http://twitter.com/sxoxm" rel="noopener ugc nofollow" target="_blank"> @sxoxm </a>的原图</p></figure><p id="15e5" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">无论您是在从事一些机器学习/人工智能项目，在 Flask 中构建 web 应用程序，还是只是编写一些快速的 Python 脚本，为您的项目提供一些满足您所有需求的模板总是有用的，即:预定义的目录结构，所有必要的配置文件，如<code class="fe lw lx ly lz b">pytest.ini</code>或<code class="fe lw lx ly lz b">requirements.txt</code>，测试，林挺和静态代码分析设置，CI/CD 工具，应用程序的 dockering，以及在自动化之上使用<em class="ma"> Makefile </em>。因此，在这里，我为您带来的正是这个<em class="ma">“终极”通用 Python 项目设置</em>。</p><p id="8fc2" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><em class="ma">TL；博士:这是我的储存库，里面有完整的源代码和文档:</em><a class="ae kz" href="https://github.com/MartinHeinz/python-project-blueprint" rel="noopener ugc nofollow" target="_blank">【https://github.com/MartinHeinz/python-project-blueprint】T21</a></p><h1 id="e853" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">目录结构</h1><p id="1f51" class="pw-post-body-paragraph la lb it lc b ld mt ju lf lg mu jx li lj mv ll lm ln mw lp lq lr mx lt lu lv im bi translated">当我为<em class="ma"> Golang </em> ( <a class="ae kz" rel="noopener" target="_blank" href="/ultimate-setup-for-your-next-golang-project-1cc989ad2a96">此处为</a>)写这类文章时，我很难用<em class="ma"> Python </em>弄清楚<em class="ma">理想的</em>项目结构，不过，这很简单:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="3011" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">让我们从顶部开始，概述一下我们这里有什么:</p><ul class=""><li id="b9ae" class="na nb it lc b ld le lg lh lj nc ln nd lr ne lv nf ng nh ni bi translated"><code class="fe lw lx ly lz b">blueprint</code> -这是我们的源代码目录，应该根据你正在使用的应用程序或软件包来命名。在里面，我们有通常的<code class="fe lw lx ly lz b">__init__.py</code>文件，表明它是一个<em class="ma"> Python </em>包，接下来是<code class="fe lw lx ly lz b">__main__.py</code>，当我们想用<code class="fe lw lx ly lz b">python -m blueprint</code>直接运行我们的应用程序时会用到它。这里的最后一个源文件是<code class="fe lw lx ly lz b">app.py</code>，这里只是为了演示。在真实的项目中，你会有更少的顶级源文件和更多的目录(内部包),而不是这个<code class="fe lw lx ly lz b">app.py</code>。稍后我们将讨论这些文件的内容。最后，我们这里还有<code class="fe lw lx ly lz b">resources</code>目录，用于您的应用程序可能需要的任何静态内容，例如图像、密钥库等。</li><li id="0b7d" class="na nb it lc b ld nj lg nk lj nl ln nm lr nn lv nf ng nh ni bi translated">这个目录中存放着我们的测试套件。我不会在这里讲太多的细节，因为我们将把整个部分用于测试，但只是简单地说:</li></ul><ol class=""><li id="71fa" class="na nb it lc b ld le lg lh lj nc ln nd lr ne lv no ng nh ni bi translated"><code class="fe lw lx ly lz b">test_app.py</code>是源目录中<code class="fe lw lx ly lz b">app.py</code>对应的测试文件</li><li id="b6cc" class="na nb it lc b ld nj lg nk lj nl ln nm lr nn lv no ng nh ni bi translated">如果你曾经使用过<em class="ma"> Pytest </em>，那么<code class="fe lw lx ly lz b">conftest.py</code>可能对你来说很熟悉——这是一个用于指定<em class="ma"> Pytest fixtures </em>，钩子或者加载外部插件的文件。</li><li id="3142" class="na nb it lc b ld nj lg nk lj nl ln nm lr nn lv no ng nh ni bi translated"><code class="fe lw lx ly lz b">context.py</code>通过操纵类路径，帮助从<code class="fe lw lx ly lz b">blueprint</code>目录导入源代码文件。我们将在稍后看到它是如何工作的。</li></ol><ul class=""><li id="a466" class="na nb it lc b ld le lg lh lj nc ln nd lr ne lv nf ng nh ni bi translated">这是我们在这个项目中的最后一个目录。它保存了我们用于 CI/CD 的<em class="ma"> GitHub 动作</em>的配置。我们有两个文件，第一个- <code class="fe lw lx ly lz b">build-test.yml</code>负责构建、测试和林挺我们每次推送的源代码。第二个文件- <code class="fe lw lx ly lz b">push.yml</code>在每次我们在 GitHub 上创建标签/发布时，将我们构建的应用程序推送到<em class="ma"> GitHub 包注册表</em>。在另一篇博客文章中有更多关于这方面的内容。</li><li id="0d84" class="na nb it lc b ld nj lg nk lj nl ln nm lr nn lv nf ng nh ni bi translated"><code class="fe lw lx ly lz b">Makefile</code> -除了目录之外，我们的项目中还有一些顶级文件，其中第一个——<code class="fe lw lx ly lz b">Makefile</code>包含目标，帮助我们自动化通常执行的任务，如构建、测试、林挺或清理我们的项目</li><li id="cda4" class="na nb it lc b ld nj lg nk lj nl ln nm lr nn lv nf ng nh ni bi translated">这是一个方便的脚本，为你建立一个项目。它实际上重命名并替换了这个项目模板中的虚拟值来代替真实值，比如项目名或包名。很方便，对吧？</li></ul><p id="b8e2" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这里的其余文件是我们将在这个项目中使用的所有工具的配置文件。让我们跳到下一部分，探索它们的功能和内容。</p><h1 id="90dc" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">配置文件</h1><p id="ce61" class="pw-post-body-paragraph la lb it lc b ld mt ju lf lg mu jx li lj mv ll lm ln mw lp lq lr mx lt lu lv im bi translated">在设置<em class="ma"> Python </em>项目时，有一件事可能会变得相当混乱，那就是当你使用一堆工具时，你最终会得到的配置文件汤，比如<em class="ma"> pylint </em>、<em class="ma"> coverage.py </em>、<em class="ma"> flake8 </em>等等。这些工具中的每一个都希望有自己的文件，通常是像<code class="fe lw lx ly lz b">.flake8</code>或<code class="fe lw lx ly lz b">.coveragerc</code>这样的文件，这会在你的项目的根目录中产生许多不必要的混乱。为了避免这种情况，我将所有这些文件合并成一个文件- <code class="fe lw lx ly lz b">setup.cfg</code>:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="d06e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果您不熟悉这里使用的所有工具，我将快速描述一下:</p><ul class=""><li id="ba8f" class="na nb it lc b ld le lg lh lj nc ln nd lr ne lv nf ng nh ni bi translated"><em class="ma">flake 8</em>——是一个在你的项目中强制代码风格的工具——换句话说——它是类似于<em class="ma"> pylint </em>的 linter，我们也将使用它。为什么两个都用？它们确实有重叠，但是它们都有一些规则，而另一个没有，所以以我的经验来看，它们都值得使用。</li><li id="97c0" class="na nb it lc b ld nj lg nk lj nl ln nm lr nn lv nf ng nh ni bi translated"><em class="ma"> Bandit </em> —是一个在<em class="ma"> Python </em>代码中寻找常见安全问题的工具。它的工作原理是从你的代码中创建 AST(抽象语法树),并针对其节点运行插件。开发人员通常不是安全专家，而且我们所有人都会犯这样或那样的错误，所以有一个工具能够为我们发现至少一些安全错误总是很好的。</li><li id="68e8" class="na nb it lc b ld nj lg nk lj nl ln nm lr nn lv nf ng nh ni bi translated"><em class="ma"> Coverage.py </em> —是一个测量<em class="ma"> Python </em>程序代码覆盖率的工具。当我们用<em class="ma"> Pytest </em>运行测试套件并从测试运行中生成覆盖率报告时，它被触发。这些报告可以是终端输出的形式，也可以是 XML 格式，然后可以被 CI 工具使用。</li></ul><p id="3b8f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">说完这些，让我们来回顾一下<code class="fe lw lx ly lz b">setup.cfg</code>中的内容。对于<em class="ma"> Flake8 </em>我们定义了排除模式，这样我们就不会忽略我们不关心的代码。下面是一个空的<code class="fe lw lx ly lz b">ignore</code>部分，以防我们需要全局忽略一些规则。我们还将最大线长度设置为 120，因为在我看来，对于今天的屏幕尺寸来说，将线长度保持为 80 是不合理的。Final line 将<em class="ma"> McCabe </em>复杂度阈值设置为 10，如果你不熟悉<em class="ma">圈复杂度</em>你可以在这里找到更多<a class="ae kz" href="https://en.wikipedia.org/wiki/Cyclomatic_complexity" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="bcf9" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">接下来是<em class="ma"> Bandit </em>，我们在这里配置的只是目标目录，这是我们的包的名称。我们这样做是为了避免在命令行上指定目标。</p><p id="3e8c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">之后是<em class="ma"> Coverage.py </em>。首先，我们启用<em class="ma">分支覆盖</em>，这意味着在程序中的一行可能会跳转到多个下一行的地方，<em class="ma"> Coverage.py </em>会跟踪实际访问了那些目的行中的哪些。接下来，我们省略了一些不应该或者不能包含在覆盖率测量中的文件，比如测试本身或者虚拟环境文件。我们也排除特定的行，例如标有<code class="fe lw lx ly lz b">pragma: no cover</code>注释的行。最后一个<em class="ma"> Coverage.py </em>配置行告诉工具将生成的报告存储在<code class="fe lw lx ly lz b">reports</code>目录中。如果该目录不存在，将自动创建。</p><p id="bd3c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们需要配置的最后一个工具是<em class="ma"> Pylint </em>，不过这个配置<em class="ma">非常</em>广泛，大概有 100 多行……所以，我就不写这个了，在这里给你指出源代码<a class="ae kz" href="https://github.com/MartinHeinz/python-project-blueprint/blob/master/setup.cfg" rel="noopener ugc nofollow" target="_blank">以及在<em class="ma"> Pylint </em>仓库</a><a class="ae kz" href="https://github.com/PyCQA/pylint/blob/master/pylintrc" rel="noopener ugc nofollow" target="_blank">这里</a>的注释和解释<code class="fe lw lx ly lz b">pylintrc</code>。</p><p id="0a72" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们检查了<code class="fe lw lx ly lz b">setup.cfg</code>中的所有工具，但是还有一个工具不能添加到<code class="fe lw lx ly lz b">setup.cfg</code>中，那就是<em class="ma">Pytest</em>——尽管<em class="ma"> Pytest </em>医生告诉你可以使用<code class="fe lw lx ly lz b">setup.cfg</code>，但这并不完全正确...根据<a class="ae kz" href="https://github.com/pytest-dev/pytest/issues/3062#issuecomment-393523260" rel="noopener ugc nofollow" target="_blank">本期</a>，使用<code class="fe lw lx ly lz b">setup.cfg</code>的选项已被否决，并且存在一些错误，如插值错误，这些错误不会被修复，因此我们还需要<code class="fe lw lx ly lz b">pytest.ini</code>文件来配置<em class="ma"> Pytest </em>:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="9c21" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们在这里做的第一件事是设置一组命令行参数——我们在终端输出中启用颜色，然后我们为<code class="fe lw lx ly lz b">blueprint</code>目录启用覆盖报告，之后我们启用 XML 和 stdout ( <code class="fe lw lx ly lz b">term</code>)覆盖报告的生成。最后两个参数(<code class="fe lw lx ly lz b">-ra</code>)告诉<em class="ma"> Pytest </em>输出未通过测试的简短摘要。</p><p id="e020" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在下一行，我们有<code class="fe lw lx ly lz b">filterwarnings</code>选项，它允许我们禁用输出中一些烦人的警告，例如，来自我们无法控制的某个库的不赞成警告。</p><p id="27b9" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">配置的其余部分设置日志记录。第一个只是打开它，其他 3 个配置级别，格式和日期时间格式。比解释格式配置更容易的是查看输出本身，这将在下一节中显示。</p><p id="696c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">有了<code class="fe lw lx ly lz b">pytest.ini</code>中的所有配置，我们运行测试套件所需要做的就是运行<code class="fe lw lx ly lz b">pytest</code>，甚至不需要包参数！</p><p id="0e00" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们拥有的最后一个实际配置文件是<code class="fe lw lx ly lz b">requirement.txt</code>，它包含了我们的依赖项列表。在这个文件中你能找到的就是一个<em class="ma"> Python </em>包的列表，每行一个<em class="ma">可选</em>版本的包。如上所述，包版本是可选的，但是我强烈建议您在<code class="fe lw lx ly lz b">requirements.txt</code>中锁定版本，以避免在构建和部署期间下载更新的、<em class="ma">不兼容的</em>包，并最终破坏您的应用程序。</p><p id="c635" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">还有两个文件实际上不是配置文件——我们的<em class="ma">docker 文件</em>，即<code class="fe lw lx ly lz b">dev.Dockerfile</code>和<code class="fe lw lx ly lz b">prod.Dockerfile</code>，分别用于开发和生产映像。我将暂时不讨论这些内容，因为我们将在另一篇文章中探讨这些内容，在那篇文章中，我们将讨论 CI/CD 和部署。但是，您可以在这里的<em class="ma"> GitHub </em>存储库中查看这些文件-<a class="ae kz" href="https://github.com/MartinHeinz/python-project-blueprint/blob/master/dev.Dockerfile" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/Martin Heinz/python-project-blue print/blob/master/dev。文档文件</a>。</p><h1 id="1fb3" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">实际源代码</h1><p id="884e" class="pw-post-body-paragraph la lb it lc b ld mt ju lf lg mu jx li lj mv ll lm ln mw lp lq lr mx lt lu lv im bi translated">我们已经做了很多，甚至没有提到我们的应用程序的源代码，但是我认为是时候看看项目框架中的几行代码了:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="49ee" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这个蓝图中唯一实际的源代码就是这个带有静态方法的类。这真的是不需要的，这样我们就可以运行一些东西，得到一些输出并测试它。这也是整个应用程序的入口点。在实际项目中，您可以使用<code class="fe lw lx ly lz b">run()</code>方法来初始化您的应用程序或 web 服务器。</p><p id="f72e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">那么，我们实际上如何运行这段代码呢？</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="d2c0" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在一个特别命名的文件<code class="fe lw lx ly lz b">__main__.py</code>中的这一小段是我们在项目中需要的，这样我们就可以使用<code class="fe lw lx ly lz b">python -m blueprint</code>运行整个包。这个文件和它的内容的好处是，它将只<em class="ma">用那个命令运行</em>，因此，如果我们想从这个包的源代码导入一些东西而不运行整个东西，那么我们可以这样做而不触发<code class="fe lw lx ly lz b">Blueprint.run()</code>。</p><p id="80bf" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们的包中还有一个特殊的文件，那就是<code class="fe lw lx ly lz b">__init__.py</code>文件。通常，你会让它为空，只用来告诉 Python 这个目录是一个包。然而，在这里，我们将使用它从我们的包中导出类、变量和函数。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="2b1d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果没有上面的这一行，你将无法从这个包的外部调用<code class="fe lw lx ly lz b">Blueprint.run()</code>。这样我们可以避免人们使用我们代码中不应该公开的内部部分。</p><p id="c0d9" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这就是我们软件包的全部代码，但是测试呢？首先，我们来看看<code class="fe lw lx ly lz b">context.py</code></p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="0d4b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">通常当你使用某人的包时，你像<code class="fe lw lx ly lz b">import blueprint</code>或<code class="fe lw lx ly lz b">from blueprint import Blueprint</code>一样导入它，为了在我们的测试中模仿它，因此使它尽可能接近真实使用，我们使用<code class="fe lw lx ly lz b">context.py</code>文件将包导入到我们的测试环境中。我们还将项目根目录插入到系统路径中。当用<code class="fe lw lx ly lz b">pytest</code>运行测试时，这实际上是不必要的，但是如果你用<code class="fe lw lx ly lz b">python ./tests/context.py</code>直接运行<code class="fe lw lx ly lz b">context.py</code>，或者可能用<code class="fe lw lx ly lz b">unittest</code>而不包括<code class="fe lw lx ly lz b">sys.path.insert...</code>，那么你将得到<code class="fe lw lx ly lz b">ModuleNotFoundError: No module named 'blueprint'</code>，所以这一行有点像<em class="ma">保险单</em>。</p><p id="0705" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">现在，让我们来看看测试示例:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="4af3" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们这里有一个简单的测试，它使用内置的<em class="ma"> Pytest </em>夹具<code class="fe lw lx ly lz b">capsys</code>(捕获系统输出)来检查<code class="fe lw lx ly lz b">Blueprint.run()</code>的标准输出。那么，当我们运行测试套件时会发生什么呢？</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="9b7b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我从输出中删除了几行，这样您可以更好地看到相关的部分。这里有什么要注意的？嗯，我们的测试通过了！除此之外，我们还可以看到覆盖率报告，我们还可以看到该报告按照<code class="fe lw lx ly lz b">pytest.ini</code>中的配置写入<code class="fe lw lx ly lz b">coverage.xml</code>。输出中还有一件事是来自<code class="fe lw lx ly lz b">conftest.py</code>的 2 条日志消息。这是怎么回事？</p><p id="e4b6" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">您可能已经注意到，除了<code class="fe lw lx ly lz b">capsys</code>夹具，我们还在小测试的参数中使用了<code class="fe lw lx ly lz b">example_fixture</code>。该夹具驻留在<code class="fe lw lx ly lz b">conftest.py</code>中，我们制作的所有定制夹具也应如此:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="ec77" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">顾名思义，这真的只是一个示例设备。它所做的只是记录一条消息，然后让测试运行，最后再记录一条消息。关于<code class="fe lw lx ly lz b">conftest.py</code>文件的好处是它被<em class="ma"> Pytest </em>自动发现，所以你甚至不需要将它导入到你的测试文件中。如果你想了解更多，那么你可以看看我以前关于<em class="ma">Pytest</em>T19】这里或者 docs <a class="ae kz" href="https://docs.pytest.org/en/latest/fixture.html#conftest-py-sharing-fixture-functions" rel="noopener ugc nofollow" target="_blank">这里</a>的帖子。</p><h1 id="c32a" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">一个命令搞定一切</h1><p id="5382" class="pw-post-body-paragraph la lb it lc b ld mt ju lf lg mu jx li lj mv ll lm ln mw lp lq lr mx lt lu lv im bi translated">如果我们分别运行我们的每个工具，并且必须记住它们的参数，即使它们总是相同的，这将是非常费力的。同样，如果后来我们决定将所有这些工具放入 CI/CD(下一篇文章！)，对吧？所以，让我们用<code class="fe lw lx ly lz b">Makefile</code>来简化事情:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="b721" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在这个<code class="fe lw lx ly lz b">Makefile</code>中，我们有 4 个目标。首先，- <code class="fe lw lx ly lz b">run</code>使用我们在源文件夹的根目录下创建的<code class="fe lw lx ly lz b">__main__.py</code>运行我们的应用程序。接下来，<code class="fe lw lx ly lz b">test</code>只是运行<code class="fe lw lx ly lz b">pytest</code>。感谢<code class="fe lw lx ly lz b">pytest.ini</code>中的所有配置，就是这么简单。这里最长的目标- <code class="fe lw lx ly lz b">lint</code> -运行我们所有的林挺工具。首先，它对项目中的所有<code class="fe lw lx ly lz b">.py</code>文件运行<code class="fe lw lx ly lz b">pylint</code>，包括测试文件。之后，它运行<code class="fe lw lx ly lz b">flake8</code>并最终运行<code class="fe lw lx ly lz b">bandit</code>。对于这两个，它只针对<code class="fe lw lx ly lz b">blueprint</code>目录中的源运行。如果这些工具中的任何一个发现我们的代码有问题，它会以非零代码退出，这意味着目标会失败，这在 CI/CD 中很有用。该文件中的最后一个目标是<code class="fe lw lx ly lz b">clean</code>，哪口井...清理我们的项目——它删除所有由前面提到的工具生成的文件。</p><h1 id="aa83" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">结论</h1><p id="19d0" class="pw-post-body-paragraph la lb it lc b ld mt ju lf lg mu jx li lj mv ll lm ln mw lp lq lr mx lt lu lv im bi translated">在本文中，我们已经构建了 project skeleton，它可以用于您可能正在从事或正在考虑的任何类型的<em class="ma"> Python </em>项目，因此，如果您想尝试或更深入地挖掘，请查看我的资源库中的源代码:【https://github.com/MartinHeinz/python-project-blueprint】。Repo 还包括关于如何使用方便的脚本设置您的项目的信息，以及一些更多的文档。如果你喜欢这种内容，请随时以问题的形式留下反馈/建议，或者直接开始。🙂</p><p id="18ab" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在未来，我们会考虑将 CI/CD 加入到<em class="ma"> GitHub 动作</em>和<em class="ma"> GitHub 包注册表</em>的组合中。我们还将对我们的项目进行 Docker 化，创建可调试和优化的生产就绪 Docker 映像，并使用<em class="ma"> CodeClimate </em>和<em class="ma"> SonarCloud </em>添加更多代码质量工具。</p><h2 id="ddcc" class="np mc it bd md nq nr dn mh ns nt dp ml lj nu nv mn ln nw nx mp lr ny nz mr oa bi translated">资源</h2><ul class=""><li id="bbb3" class="na nb it lc b ld mt lg mu lj ob ln oc lr od lv nf ng nh ni bi translated"><a class="ae kz" href="https://github.com/navdeep-G/samplemod" rel="noopener ugc nofollow" target="_blank">示例 Python 模块库</a></li><li id="db99" class="na nb it lc b ld nj lg nk lj nl ln nm lr nn lv nf ng nh ni bi translated"><a class="ae kz" href="https://docs.pytest.org/en/latest/contents.html" rel="noopener ugc nofollow" target="_blank"> Pytest 文档</a></li><li id="64ae" class="na nb it lc b ld nj lg nk lj nl ln nm lr nn lv nf ng nh ni bi translated"><a class="ae kz" href="https://github.com/PyCQA" rel="noopener ugc nofollow" target="_blank"> Python 代码质量权威</a></li></ul></div><div class="ab cl oe of hx og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="im in io ip iq"><p id="3107" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><em class="ma">本文最初发布于</em><a class="ae kz" href="https://martinheinz.dev/blog/14" rel="noopener ugc nofollow" target="_blank"><em class="ma">martinheinz . dev</em></a></p></div></div>    
</body>
</html>