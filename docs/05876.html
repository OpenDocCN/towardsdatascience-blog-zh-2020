<html>
<head>
<title>Finding patterns with rules, using Knowledge Graphs and Semantic Reasoning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用知识图和语义推理寻找有规则的模式</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/finding-patterns-with-rules-4227ee4e8f58?source=collection_archive---------38-----------------------#2020-05-14">https://towardsdatascience.com/finding-patterns-with-rules-4227ee4e8f58?source=collection_archive---------38-----------------------#2020-05-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8aec" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">概念和示例</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d9f7d2cbb3d792509d9fabfe3a428c37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*clh7D9W9nrpFnR0T"/></div></div></figure><p id="4ee1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">机器学习算法现在等同于在数据中寻找模式，但并非所有模式都适合基于统计的数据驱动技术，例如当这些模式没有明确标记的学习目标时。</p><p id="4175" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在某些情况下，这些模式可以精确地表达为一个规则。推理是匹配基于规则的模式或验证它们在图中不存在的过程。因为这些模式是用演绎逻辑发现的，所以与从数据中归纳的机器学习模式相比，它们可以被更有效地发现和更容易地解释。</p><p id="9987" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本文将介绍一些常见的模式，以及如何使用牛津语义技术公司开发的知识图和语义推理引擎<a class="ae lq" href="https://www.oxfordsemantic.tech/product" rel="noopener ugc nofollow" target="_blank"> RDFox </a>，用规则语言 Datalog 来表达它们。RDFox 是基于标准的，<a class="ae lq" href="https://www.w3.org/RDF/" rel="noopener ugc nofollow" target="_blank">RDF</a>-三重存储，我们将使用<a class="ae lq" href="https://www.w3.org/TR/rdf-sparql-query/" rel="noopener ugc nofollow" target="_blank"> SPARQL </a>对其进行查询。如果你还不熟悉知识图和推理，你可以在这里阅读发表在《走向数据科学<a class="ae lq" rel="noopener" target="_blank" href="/the-intuitions-behind-knowledge-graphs-and-reasoning-59df2f1ad054">上的介绍。如果您没有 RDF 数据，请阅读我们的简单教程</a><a class="ae lq" href="https://www.oxfordsemantic.tech/importing-data-into-rdfox" rel="noopener ugc nofollow" target="_blank">将 CSV 和 SQL 数据导入 RDF 图。</a></p><h1 id="d09c" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">传递关系模式</h1><p id="7702" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">“位于”关系在直觉上是可传递的，但可能无法在图中完全表达。例如，一个图形可能包含以下三元组:</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="b4ba" class="mt ls it mp b gy mu mv l mw mx">@prefix : &lt;https://oxfordsemantic.tech/RDFox/tutorial/&gt; .</span><span id="603f" class="mt ls it mp b gy my mv l mw mx">:oxford       :located_in :oxfordshire .<br/>:oxfordshire  :located_in :england .<br/>:england      :located_in :uk .</span></pre><p id="dee8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">SPARQL 查询不会返回牛津位于英格兰，因为它缺少三个字符:</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="ca30" class="mt ls it mp b gy mu mv l mw mx">:oxford       :located_in :england .</span></pre><p id="261d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该三元组可以一次性添加，但这很快在较大的图表上变得不切实际，因为位于牛津郡的其他城镇也可能会缺少位于英格兰边缘的城镇。</p><p id="3fce" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这种情况下，传递关系规则可以毫不费力地自动绘制相关的:located_in 边:</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="d642" class="mt ls it mp b gy mu mv l mw mx">[?x, :located_in, ?z] :- <br/>   [?x, :located_in, ?y], <br/>   [?y, :located_in, ?z] .</span></pre><p id="773f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">第一部分是规则的头，如果在图中找到符号<code class="fe mz na nb mp b">:-</code>后的模式，该规则将变为<code class="fe mz na nb mp b">?x :located_in ?z </code>三元组。</p><p id="1b41" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们的例子中，规则将变量<code class="fe mz na nb mp b">?x</code>绑定到<code class="fe mz na nb mp b">:oxford</code>，变量<code class="fe mz na nb mp b">?y</code>绑定到<code class="fe mz na nb mp b">:oxfordshire</code>，变量<code class="fe mz na nb mp b">?z</code>绑定到<code class="fe mz na nb mp b">:england</code>，然后作为满足规则的逻辑结果，通过用<code class="fe mz na nb mp b">:oxford</code>替换<code class="fe mz na nb mp b">?x</code>和用<code class="fe mz na nb mp b">:england</code>替换<code class="fe mz na nb mp b">?z</code>来创建<code class="fe mz na nb mp b">:oxford :located_in :england</code>三元组。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/b5ab01dbdc486d9399cb2805812c1142.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*nmyR7rd-FmsApDgbiaN9NA.png"/></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">原始数据被规则扩展，新的关系在这里显示为绿色。</p></figure><p id="5207" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">无论何时在图表中添加或删除新的数据点，RDFox 都会在运行中逐渐实现规则，这使得它成为动态数据源的有效解决方案。</p><h1 id="8ab6" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">传递闭包模式</h1><p id="54b0" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">传递闭包模式有助于将图中尚不存在但可能存在的传递关系具体化。例如，一些 Twitter 关注者可以用下图来表示:</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="3c9f" class="mt ls it mp b gy mu mv l mw mx">:alice :follows :bob .<br/>:bob   :follows :charlie .<br/>:diana :follows :alice .</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/b6802524b1f114d68eca5c1d6a1078a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:770/format:webp/1*J4VDBqojf2oA_wqy6PWwzA.png"/></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">将图表可视化。</p></figure><p id="5140" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当向用户推荐以下建议时，我们可能希望使用以下规则将缺失的连接计算为<code class="fe mz na nb mp b">:follows_closure</code>边:</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="47ea" class="mt ls it mp b gy mu mv l mw mx">[?x, :follows_closure, ?y] :- <br/>   [?x, :follows, ?y] .</span><span id="96fa" class="mt ls it mp b gy my mv l mw mx">[?x, :follows_closure, ?z] :-<br/>   [?x, :follows, ?y], <br/>   [?y, :follows_closure, ?z] .</span></pre><p id="0b7a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">第一个规则指定新关系<code class="fe mz na nb mp b">:follows_closure</code>是关系<code class="fe mz na nb mp b">:follows</code>的扩展。第二个规则实现了闭包，它说如果一个人<code class="fe mz na nb mp b">?x</code>直接跟随<code class="fe mz na nb mp b">?y</code>并且<code class="fe mz na nb mp b">?y</code>(直接或间接)跟随人<code class="fe mz na nb mp b">?z</code>，那么<code class="fe mz na nb mp b">?x</code>(间接)跟随<code class="fe mz na nb mp b">?z</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/a589a722cb65fcb8b0d7567af83bebd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:758/format:webp/1*C8tRtqiDk_7SCmPJ2WaqWA.png"/></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">更新的关系显示添加了:follows_closure 边。</p></figure><p id="de6b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，最初不是<code class="fe mz na nb mp b">:follows</code>关系的新<code class="fe mz na nb mp b">:follows_closure</code>关系是:</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="387c" class="mt ls it mp b gy mu mv l mw mx">:diana :charlie .<br/>:alice :charlie .<br/>:diana :bob .</span></pre><p id="2d03" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些简单的规则可以被增强以包括用户兴趣、地理、语言、共同的追随者等。</p><h1 id="b673" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">将关系定义为其他关系的组合</h1><p id="9f94" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">知识图的一个重要实际用途是支持开放式问答(Open QA)应用程序或聊天机器人，其中用户用自然语言提出一个问题，然后自动根据图进行回答。开放式问答系统通常很难解释涉及图中几个“跳”的问题。例如，考虑由下面给出的三元组组成的图。</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="61c3" class="mt ls it mp b gy mu mv l mw mx">:douglas_adams :born_in  :uk .<br/>:uk            rdf:type  :country.</span></pre><p id="a064" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">用户可能会问道格拉斯·亚当斯出生在哪个国家。为了获得这些信息，系统需要在图中构建一个包含两跳的查询。特别是 SPARQL 查询</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="1961" class="mt ls it mp b gy mu mv l mw mx">select ?c where {<br/>   :douglas_adams :born_in ?c .<br/>   ?c rdf:type :country .<br/>}</span></pre><p id="2716" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">会返回<code class="fe mz na nb mp b">:uk</code>作为答案。</p><p id="8753" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果只需一跳就能获得所需的信息，那么开放式质量保证系统的结果将会大大提高。在这种情况下，可以使用 RDFox 规则来提供一个干净的解决方案。特别是，我们可以使用规则来定义一个新的<code class="fe mz na nb mp b">:country_of_birth</code>关系，为直接访问所需信息提供一条“捷径”。</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="f7e2" class="mt ls it mp b gy mu mv l mw mx">[?x, :country_of_birth, ?y] :- <br/>   [?x, :born_in, ?y], <br/>   [?y, rdf:type, :country] .</span></pre><p id="8a5f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">规则说，如果一个人<code class="fe mz na nb mp b">?x</code>出生在一个地方<code class="fe mz na nb mp b">?y</code>，而那个地方<code class="fe mz na nb mp b">?y</code>是一个<code class="fe mz na nb mp b">:country</code>，那么<code class="fe mz na nb mp b">?y</code>就是<code class="fe mz na nb mp b">?x</code>的出生国。</p><p id="f550" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，RDFox 会推断出道格拉斯·亚当斯的出生国是英国。开放的 QA 系统现在只需要构造以下更简单的查询，该查询涉及图中的单跳，以获得期望的信息。</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="8ba1" class="mt ls it mp b gy mu mv l mw mx">select ?x ?y where {?x :country_of_birth ?y}</span></pre><p id="0ef0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如我们已经看到的，规则可以建立在其他规则的结果上，因此这种模式与第一个传递关系相结合，可以满足包括道格拉斯·亚当斯出生地点的更多完整细节的数据。比如:</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="50d4" class="mt ls it mp b gy mu mv l mw mx">:douglasAdams   :born_in    :cambridge .<br/>:cambridge      :located_in :cambridgeshire .<br/>:cambridgeshire :located_in :england .<br/>:england        :located_in :uk .<br/>:uk             rdf:type    :country .</span></pre><p id="8acb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当这些规则应用于这些数据时，它们会生成下图。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/ba36698d8e4d58e75ced4cfc122f4652.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/1*TR-xUcRAvmiZLQll5cpgUw.png"/></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">输入数据以及由规则导出的边的图表。</p></figure><h1 id="0304" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">循环检测</h1><p id="cac5" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">知识图中的一个常见任务是识别循环关系。例如，部分经济关系通常是非循环的(例如，如果引擎是汽车的一部分，我们不会期望汽车也是引擎的一部分！).在这些情况下，可能需要循环检测来检测图表中的错误，从而提供数据验证。通过识别例如网络中不应该存在的通信关系，周期检测对于检测欺诈或内部交易也是有用的。</p><p id="8e15" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">考虑下图中的“部分”关系:</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="82aa" class="mt ls it mp b gy mu mv l mw mx">:piston :part_of :engine .<br/>:engine :part_of :car .<br/>:car    :part_of :piston .</span></pre><p id="3774" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该图包含一个循环路径<code class="fe mz na nb mp b">:piston</code>-&gt;-<code class="fe mz na nb mp b">:engine</code>-&gt;-<code class="fe mz na nb mp b">:car</code>-&gt;-<code class="fe mz na nb mp b">:piston</code>。通过<code class="fe mz na nb mp b">:part_of</code>关系。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/13e22de39e9c9b27c595838b2e1b3f6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:474/format:webp/1*cpqA2A03iD8mhVvESYQkYQ.png"/></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">通过查看这个小图表，很明显有些地方不对劲。想象一个更大的东西，在结构中有许多层次的嵌套和分支。</p></figure><p id="27bb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该关系自然是可传递的，并且可以用以下规则来定义:</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="ac51" class="mt ls it mp b gy mu mv l mw mx">[?x, :part_of, ?z] :- <br/>   [?x, :part_of, ?y], <br/>   [?y, :part_of, ?z] .</span></pre><p id="54be" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面的 SPARQL 查询将返回(直接或间接)属于其他元素的元素</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="4503" class="mt ls it mp b gy mu mv l mw mx">select ?x ?y where {?x :part_of ?y}</span></pre><p id="fd39" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这给了我们以下结果</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="93eb" class="mt ls it mp b gy mu mv l mw mx">:piston :piston .<br/>:car. :car .<br/>:engine :engine .<br/>:piston :car .<br/>:car :piston .<br/>:engine :car .<br/>:piston :engine .</span></pre><p id="8397" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一个循环通过自循环的存在来表明它自己(例如<code class="fe mz na nb mp b">:piston</code>被导出为它自己的一部分)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/79fe976a43fa186900179008c24e1ff0.png" data-original-src="https://miro.medium.com/v2/resize:fit:534/format:webp/1*nH4-A5nLT61f3DgF5Bk7Zg.png"/></div></figure><p id="2548" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，可以用下面的 SPARQL 查询检测关系的循环部分。</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="e2dd" class="mt ls it mp b gy mu mv l mw mx">ask {?x :part_of ?x}</span></pre><p id="a570" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">或者，我们可以用以下规则定义循环关系:</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="8d02" class="mt ls it mp b gy mu mv l mw mx">[:part_of, rdf:type, :cyclic_relation] :- <br/>   [?x, :part_of, ?x] .</span></pre><p id="a0a6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它告诉我们，如果任何物体被确定为自身的一部分，那么部分命名关系就是循环的。</p><p id="cf72" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们现在可以很容易地检索图中的循环关系列表。</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="eb2f" class="mt ls it mp b gy mu mv l mw mx">select ?x where {?x rdf:type :cyclic_relation}</span></pre><p id="63c0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">获得:作为结果的一部分。</p><h1 id="2c0f" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">排序模式</h1><p id="0ea9" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">许多关系自然意味着某种顺序，在这种情况下，我们可能有兴趣找到这种顺序的第一个和最后一个元素。</p><p id="b897" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，考虑一家公司的管理结构。</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="ad25" class="mt ls it mp b gy mu mv l mw mx">:alice  :manages :bob .<br/>:bob    :manages :jeremy .<br/>:bob    :manages :emma .<br/>:emma   :manages :david .<br/>:jeremy :manages :monica .</span></pre><p id="6f30" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们希望认可公司中哪些人是“高层管理者”。我们可以用一个规则来定义一个高层管理者，他管理一个人，而不被其他任何人管理。</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="6aaa" class="mt ls it mp b gy mu mv l mw mx">[?x, rdf:type, :top_level_manager] :-<br/>   [?x, :manages, ?y], <br/>   not exists ?z in ([?z, :manages, ?x]) .</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/cbdbcd6a8a827f934da7b294625825d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/format:webp/1*ed5BKls_g4t0qcBseB1KLA.png"/></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">如此处所示，Alice 符合规则的模式，因此标记为类型:top_level_manager。</p></figure><p id="575c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该查询</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="b3fe" class="mt ls it mp b gy mu mv l mw mx">select ?x where {?x rdf:type :top_level_manager}</span></pre><p id="06d2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">询问高层经理的名单，答案是<code class="fe mz na nb mp b">:alice</code>。</p><p id="dacb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们现在可以用一个规则来定义“初级员工”为那些有一个经理但自己不管理其他任何人的人。</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="e211" class="mt ls it mp b gy mu mv l mw mx">[?x, rdf:type, :junior_employee] :- <br/>   [?y, :manages, ?x], <br/>   not exists ?z in ([?x, :manages, ?z]) .</span></pre><p id="fa17" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对初级雇员的查询是</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="b367" class="mt ls it mp b gy mu mv l mw mx">select ?x where {?x rdf:type :junior_employee}</span></pre><p id="99f6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这将返回<code class="fe mz na nb mp b">:monica</code>和<code class="fe mz na nb mp b">:david</code>作为答案。</p><h1 id="0322" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">在实践中寻找模式</h1><p id="9292" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">这是对基于规则的模式示例的简短介绍，我将在下一篇文章中用更多的例子和应用来扩展它。想象一下，将这些规则与其他规则相结合，并在您的数据上大规模运行，会有什么样的效果。</p><p id="8a21" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您想自己搜索基于规则的模式，请访问<a class="ae lq" href="https://www.oxfordsemantic.tech/product" rel="noopener ugc nofollow" target="_blank"> RDFox 的</a>入门指南。</p><h1 id="f040" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">关于牛津语义技术</h1><p id="7c4b" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">牛津语义技术<a class="ae lq" href="https://www.oxfordsemantic.tech/team" rel="noopener ugc nofollow" target="_blank">背后的团队</a>于 2011 年在牛津大学计算机科学系开始研究 RDFox，他们坚信灵活和高性能的推理是数据广泛应用的一种可能性，而不会危及结果的正确性。RDFox 是第一个面向市场的知识图，它是基于推理从头开始设计的。牛津语义技术公司是牛津大学的一个分支，由主要投资者支持，包括三星风险投资公司(<a class="ae lq" href="https://www.samsungventure.co.kr/english_main.do" rel="noopener ugc nofollow" target="_blank"><strong class="kw iu">【SVIC</strong></a>)、牛津科学创新公司(<a class="ae lq" href="https://www.oxfordsciencesinnovation.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu"> OSI </strong> </a>)和牛津大学的投资部门(<a class="ae lq" href="https://innovation.ox.ac.uk/" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu"> OUI </strong> </a>)。笔者很自豪能成为这个团队的一员。</p><p id="9f5d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="nn">照片由</em> <a class="ae lq" href="https://unsplash.com/@pawel_czerwinski?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> <em class="nn">波维切维斯基</em> </a> <em class="nn">上</em> <a class="ae lq" href="https://unsplash.com/s/photos/fractal?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> <em class="nn"> Unsplash </em> </a></p></div></div>    
</body>
</html>