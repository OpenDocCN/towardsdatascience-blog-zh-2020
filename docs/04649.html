<html>
<head>
<title>Creating RESTful Web APIs using Flask and Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Flask 和 Python 创建 RESTful Web APIs</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/creating-restful-apis-using-flask-and-python-655bad51b24?source=collection_archive---------0-----------------------#2020-04-25">https://towardsdatascience.com/creating-restful-apis-using-flask-and-python-655bad51b24?source=collection_archive---------0-----------------------#2020-04-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="b904" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">编程；编排</h2><div class=""/><div class=""><h2 id="d782" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">用 Flask 构建 Web APIs 的综合指南</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ko"><img src="../Images/1c5d35fa1148efa189149be0eb045685.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*U1Heg6nin4CUAbD_BD8fSw.jpeg"/></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">图片来自<a class="ae la" href="https://pixabay.com/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=2682712" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae la" href="https://pixabay.com/users/geralt-9301/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=2682712" rel="noopener ugc nofollow" target="_blank"> Gerd Altmann </a></p></figure><p id="a75b" class="pw-post-body-paragraph lb lc iq ld b le lf ka lg lh li kd lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi lx translated">lask 是一个广泛使用的微型 web 框架，用于在 Python 中创建 API。这是一个简单而强大的 web 框架，旨在快速轻松地开始使用，并能够扩展到复杂的应用程序。</p><p id="e108" class="pw-post-body-paragraph lb lc iq ld b le lf ka lg lh li kd lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated">从<a class="ae la" href="https://flask.palletsprojects.com/en/1.1.x/foreword/" rel="noopener ugc nofollow" target="_blank">文档</a>中，</p><blockquote class="mg mh mi"><p id="a845" class="lb lc mj ld b le lf ka lg lh li kd lj mk ll lm ln ml lp lq lr mm lt lu lv lw ij bi translated">“微型”并不意味着您的整个 web 应用程序必须适合一个 Python 文件(尽管它确实可以)，也不意味着 Flask 缺乏功能。微框架中的“微”意味着 Flask 旨在保持核心简单但可扩展。</p></blockquote><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/bcd0caeda4c500b9a5748e6aa4ae643a.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/format:webp/0*vYBrYZfKwvnp5uMe.png"/></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">来源:Flask 的<a class="ae la" href="https://flask.palletsprojects.com/en/1.1.x/_images/flask-logo.png" rel="noopener ugc nofollow" target="_blank">文件</a></p></figure><h1 id="1127" class="mo mp iq bd mq mr ms mt mu mv mw mx my kf mz kg na ki nb kj nc kl nd km ne nf bi translated">装置</h1><p id="1b00" class="pw-post-body-paragraph lb lc iq ld b le ng ka lg lh nh kd lj lk ni lm ln lo nj lq lr ls nk lu lv lw ij bi translated">使用 pip 安装烧瓶</p><pre class="kp kq kr ks gt nl nm nn bn no np bi"><span id="baf5" class="nq mp iq nm b be nr ns l nt nu">pip install Flask</span></pre></div><div class="ab cl nv nw hu nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ij ik il im in"><h1 id="14a0" class="mo mp iq bd mq mr oc mt mu mv od mx my kf oe kg na ki of kj nc kl og km ne nf bi translated">最小烧瓶应用程序</h1><pre class="kp kq kr ks gt nl nm nn bn no np bi"><span id="94b8" class="nq mp iq nm b be nr ns l nt nu">from flask import Flask<br/><br/>app = Flask(__name__)<br/><br/>@app.route('/hello/', methods=['GET', 'POST'])<br/>def welcome():<br/>    return "Hello World!"<br/><br/>if __name__ == '__main__':<br/>    app.run(host='0.0.0.0', port=105)</span></pre><p id="1ab1" class="pw-post-body-paragraph lb lc iq ld b le lf ka lg lh li kd lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated">将该文件保存为<code class="fe oh oi oj nm b">app.py</code> <em class="mj">(或任何其他你想要的文件名)</em>，并进入终端并键入<code class="fe oh oi oj nm b">python app.py</code>(即<code class="fe oh oi oj nm b">python &lt;filename&gt;.py</code>)</p><p id="3ebe" class="pw-post-body-paragraph lb lc iq ld b le lf ka lg lh li kd lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated">您应该会看到类似这样的内容:</p><pre class="kp kq kr ks gt nl nm nn bn no np bi"><span id="708e" class="nq mp iq nm b be nr ns l nt nu">* Running on http://0.0.0.0:105/ (Press CTRL+C to quit)</span></pre><p id="1385" class="pw-post-body-paragraph lb lc iq ld b le lf ka lg lh li kd lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated">启动任何网络浏览器，然后前往<code class="fe oh oi oj nm b">http://localhost:105/hello/</code>查看应用程序的运行情况。</p><p id="f6b5" class="pw-post-body-paragraph lb lc iq ld b le lf ka lg lh li kd lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated">现在，让我们逐行理解代码的工作原理:</p><p id="beeb" class="pw-post-body-paragraph lb lc iq ld b le lf ka lg lh li kd lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated"><code class="fe oh oi oj nm b">from flask import Flask</code> →导入烧瓶类</p><p id="c051" class="pw-post-body-paragraph lb lc iq ld b le lf ka lg lh li kd lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated"><code class="fe oh oi oj nm b">app = Flask(__name__)</code> →创建类的一个实例</p><p id="c869" class="pw-post-body-paragraph lb lc iq ld b le lf ka lg lh li kd lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated"><code class="fe oh oi oj nm b">@app.route('/hello/', methods=['GET', 'POST'])</code> →我们使用<code class="fe oh oi oj nm b">route()</code>装饰器来告诉 Flask 哪个 URL 应该触发这个函数。<br/> <code class="fe oh oi oj nm b">methods</code>指定允许哪些 HTTP 方法。默认为<code class="fe oh oi oj nm b">['GET']</code></p><p id="54b8" class="pw-post-body-paragraph lb lc iq ld b le lf ka lg lh li kd lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated"><code class="fe oh oi oj nm b">if __name__ == '__main__'</code> → <code class="fe oh oi oj nm b">__name__</code>是 Python 中的一个特殊变量，取脚本名的值。这一行确保我们的 Flask 应用程序仅在主文件中执行时运行，而不是在导入到其他文件中时运行</p><p id="5df0" class="pw-post-body-paragraph lb lc iq ld b le lf ka lg lh li kd lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated"><code class="fe oh oi oj nm b">app.run(host='0.0.0.0', port=105)</code> →运行烧瓶应用程序</p><p id="d354" class="pw-post-body-paragraph lb lc iq ld b le lf ka lg lh li kd lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated">指定我们希望 flask 应用程序运行的服务器。<code class="fe oh oi oj nm b">host</code>的默认值为<code class="fe oh oi oj nm b">localhost</code>或<code class="fe oh oi oj nm b">127.0.0.1</code></p><p id="5698" class="pw-post-body-paragraph lb lc iq ld b le lf ka lg lh li kd lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated"><code class="fe oh oi oj nm b">0.0.0.0</code>的意思是<em class="mj">“本地机器上的所有 IPv4 地址”。这确保了从所有地址都可以到达服务器。<br/>默认<code class="fe oh oi oj nm b">port</code>值为<code class="fe oh oi oj nm b">5000</code>，您可以设置参数<code class="fe oh oi oj nm b">port</code>以使用您选择的端口号。</em></p></div><div class="ab cl nv nw hu nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ij ik il im in"><h1 id="980d" class="mo mp iq bd mq mr oc mt mu mv od mx my kf oe kg na ki of kj nc kl og km ne nf bi translated">可变规则</h1><p id="1c8e" class="pw-post-body-paragraph lb lc iq ld b le ng ka lg lh nh kd lj lk ni lm ln lo nj lq lr ls nk lu lv lw ij bi translated">您可以使用<code class="fe oh oi oj nm b">&lt;variable_name&gt;</code>向 URL 添加可变部分。该函数接收变量作为关键字参数。</p><pre class="kp kq kr ks gt nl nm nn bn no np bi"><span id="fb1c" class="nq mp iq nm b be nr ns l nt nu">from flask import Flask<br/>app = Flask(__name__)<br/><br/>@app.route('/&lt;int:number&gt;/')<br/>def incrementer(number):<br/>    return "Incremented number is " + str(number+1)<br/><br/>@app.route('/&lt;string:name&gt;/')<br/>def hello(name):<br/>    return "Hello " + name<br/><br/>app.run()</span></pre><p id="dce2" class="pw-post-body-paragraph lb lc iq ld b le lf ka lg lh li kd lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated">运行上面的代码来启动 Flask 应用程序。<br/>打开浏览器并转到<code class="fe oh oi oj nm b">http://localhost:5000/Jimit</code>，您将看到输出为<code class="fe oh oi oj nm b">Hello Jimit</code>，当您转到<code class="fe oh oi oj nm b">http://localhost:5000/10</code>时，输出将为<code class="fe oh oi oj nm b">Incremented number is 11</code>。</p></div><div class="ab cl nv nw hu nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ij ik il im in"><h1 id="6a82" class="mo mp iq bd mq mr oc mt mu mv od mx my kf oe kg na ki of kj nc kl og km ne nf bi translated">返回 JSON 可序列化输出</h1><p id="a79b" class="pw-post-body-paragraph lb lc iq ld b le ng ka lg lh nh kd lj lk ni lm ln lo nj lq lr ls nk lu lv lw ij bi translated">Flask 应用程序中函数的返回值应该是 JSON 可序列化的。您可以使用<code class="fe oh oi oj nm b">jsonify</code>使您的输出 JSON 可序列化。该函数包装<code class="fe oh oi oj nm b">json.dumps()</code>以将 JSON 输出转换成带有<em class="mj">application/JSON</em>mime-type 的响应对象。</p><h2 id="eca9" class="ok mp iq bd mq ol om dn mu on oo dp my lk op oq na lo or os nc ls ot ou ne iw bi translated">示例 1:</h2><p id="1f09" class="pw-post-body-paragraph lb lc iq ld b le ng ka lg lh nh kd lj lk ni lm ln lo nj lq lr ls nk lu lv lw ij bi translated">这个例子展示了如何对字典对象使用<code class="fe oh oi oj nm b">jsonify</code>:</p><pre class="kp kq kr ks gt nl nm nn bn no np bi"><span id="df23" class="nq mp iq nm b be nr ns l nt nu">from flask import jsonify<br/><br/>@app.route('/person/')<br/>def hello():<br/>    return jsonify({'name':'Jimit',<br/>                    'address':'India'})</span></pre><p id="c13f" class="pw-post-body-paragraph lb lc iq ld b le lf ka lg lh li kd lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated">这将发送如下的 JSON 响应:</p><pre class="kp kq kr ks gt nl nm nn bn no np bi"><span id="f4df" class="nq mp iq nm b be nr ns l nt nu">{<br/>  "address": "India", <br/>  "name": "Jimit"<br/>}</span></pre><h2 id="ce27" class="ok mp iq bd mq ol om dn mu on oo dp my lk op oq na lo or os nc ls ot ou ne iw bi translated">示例 2:</h2><p id="3571" class="pw-post-body-paragraph lb lc iq ld b le ng ka lg lh nh kd lj lk ni lm ln lo nj lq lr ls nk lu lv lw ij bi translated">还可以使用<code class="fe oh oi oj nm b">jsonify</code>自动将列表和元组序列化为 JSON 响应。</p><pre class="kp kq kr ks gt nl nm nn bn no np bi"><span id="a8cc" class="nq mp iq nm b be nr ns l nt nu">from flask import jsonify<br/><br/>@app.route('/numbers/')<br/>def print_list():<br/>    return jsonify(list(range(5)))</span></pre><p id="e41f" class="pw-post-body-paragraph lb lc iq ld b le lf ka lg lh li kd lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated">这将产生输出:</p><pre class="kp kq kr ks gt nl nm nn bn no np bi"><span id="9e10" class="nq mp iq nm b be nr ns l nt nu">[<br/>  0, <br/>  1, <br/>  2, <br/>  3, <br/>  4<br/>]</span></pre></div><div class="ab cl nv nw hu nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ij ik il im in"><h1 id="964f" class="mo mp iq bd mq mr oc mt mu mv od mx my kf oe kg na ki of kj nc kl og km ne nf bi translated">重定向行为</h1><pre class="kp kq kr ks gt nl nm nn bn no np bi"><span id="8b4f" class="nq mp iq nm b be nr ns l nt nu">@app.route('/home/')<br/>def home():<br/>    return "Home page"<br/><br/>@app.route('/contact')<br/>def contact():<br/>    return "Contact page"</span></pre><p id="0d2d" class="pw-post-body-paragraph lb lc iq ld b le lf ka lg lh li kd lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated">在上面的例子中，<code class="fe oh oi oj nm b">home</code>端点的 URL 有一个尾随斜杠，而<code class="fe oh oi oj nm b">contact</code>端点的 URL 缺少尾随斜杠。</p><p id="5f5c" class="pw-post-body-paragraph lb lc iq ld b le lf ka lg lh li kd lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated">这会导致两种不同的行为:</p><ol class=""><li id="19cd" class="ov ow iq ld b le lf lh li lk ox lo oy ls oz lw pa pb pc pd bi translated">对于<code class="fe oh oi oj nm b">home</code>端点，如果您访问不带结尾斜杠的 URL，那么 Flask 会将您重定向到带结尾斜杠的 URL。</li><li id="b206" class="ov ow iq ld b le pe lh pf lk pg lo ph ls pi lw pa pb pc pd bi translated">对于<code class="fe oh oi oj nm b">contact</code>端点，如果您访问带有结尾斜杠的 URL，那么它将导致状态 404 Not Found。</li></ol></div><div class="ab cl nv nw hu nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ij ik il im in"><h1 id="64e7" class="mo mp iq bd mq mr oc mt mu mv od mx my kf oe kg na ki of kj nc kl og km ne nf bi translated">返回状态代码</h1><p id="7c81" class="pw-post-body-paragraph lb lc iq ld b le ng ka lg lh nh kd lj lk ni lm ln lo nj lq lr ls nk lu lv lw ij bi translated">通过按如下方式指定状态代码，可以将状态代码与响应一起返回:</p><pre class="kp kq kr ks gt nl nm nn bn no np bi"><span id="88b1" class="nq mp iq nm b be nr ns l nt nu">@app.route('/teapot/')<br/>def teapot():<br/>    return "Would you like some tea?", 418</span></pre><p id="410e" class="pw-post-body-paragraph lb lc iq ld b le lf ka lg lh li kd lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated">对这个 URL 的响应将是带有状态码<code class="fe oh oi oj nm b">418</code>的<code class="fe oh oi oj nm b">Would you like some tea?</code>，而不是通常的<code class="fe oh oi oj nm b">200</code>。</p></div><div class="ab cl nv nw hu nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ij ik il im in"><h1 id="a1cd" class="mo mp iq bd mq mr oc mt mu mv od mx my kf oe kg na ki of kj nc kl og km ne nf bi translated">请求前</h1><p id="1abf" class="pw-post-body-paragraph lb lc iq ld b le ng ka lg lh nh kd lj lk ni lm ln lo nj lq lr ls nk lu lv lw ij bi translated">通过使用<code class="fe oh oi oj nm b">app.before_request</code> decorator，您可以指定一个应该在请求被处理之前一直执行的函数。</p><pre class="kp kq kr ks gt nl nm nn bn no np bi"><span id="f698" class="nq mp iq nm b be nr ns l nt nu">@app.before_request<br/>def before():<br/>    print("This is executed BEFORE each request.")<br/>    <br/>@app.route('/hello/')<br/>def hello():<br/>    return "Hello World!"</span></pre><p id="2e2c" class="pw-post-body-paragraph lb lc iq ld b le lf ka lg lh li kd lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated">对于这个例子，首先在服务器上打印语句<code class="fe oh oi oj nm b">This is executed BEFORE each request.</code>，然后执行<code class="fe oh oi oj nm b">hello</code>端点的功能。当您希望记录请求以进行监控时，这尤其有用。</p></div><div class="ab cl nv nw hu nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ij ik il im in"><h1 id="9c2f" class="mo mp iq bd mq mr oc mt mu mv od mx my kf oe kg na ki of kj nc kl og km ne nf bi translated">访问请求数据</h1><p id="a6c0" class="pw-post-body-paragraph lb lc iq ld b le ng ka lg lh nh kd lj lk ni lm ln lo nj lq lr ls nk lu lv lw ij bi translated">要访问请求数据，请使用以下命令</p><pre class="kp kq kr ks gt nl nm nn bn no np bi"><span id="e502" class="nq mp iq nm b be nr ns l nt nu">from flask import request</span></pre><p id="fb3d" class="pw-post-body-paragraph lb lc iq ld b le lf ka lg lh li kd lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated">您可以使用以下属性来提取随请求一起发送的数据:</p><p id="ae54" class="pw-post-body-paragraph lb lc iq ld b le lf ka lg lh li kd lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated"><code class="fe oh oi oj nm b"><a class="ae la" href="https://flask.palletsprojects.com/en/1.1.x/api/#flask.Request.data" rel="noopener ugc nofollow" target="_blank">request.data</a></code> →以字符串形式访问输入的请求数据</p><p id="743a" class="pw-post-body-paragraph lb lc iq ld b le lf ka lg lh li kd lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated"><code class="fe oh oi oj nm b"><a class="ae la" href="https://flask.palletsprojects.com/en/1.1.x/api/#flask.Request.args" rel="noopener ugc nofollow" target="_blank">request.args</a></code> →访问解析后的 URL 参数。返回<code class="fe oh oi oj nm b">ImmutableMultiDict</code></p><p id="aefa" class="pw-post-body-paragraph lb lc iq ld b le lf ka lg lh li kd lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated"><code class="fe oh oi oj nm b"><a class="ae la" href="https://flask.palletsprojects.com/en/1.1.x/api/#flask.Request.form" rel="noopener ugc nofollow" target="_blank">request.form</a></code> →访问表单参数。返回<code class="fe oh oi oj nm b">ImmutableMultiDict</code></p><p id="8aff" class="pw-post-body-paragraph lb lc iq ld b le lf ka lg lh li kd lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated"><code class="fe oh oi oj nm b"><a class="ae la" href="https://flask.palletsprojects.com/en/1.1.x/api/#flask.Request.values" rel="noopener ugc nofollow" target="_blank">request.values</a></code> →返回组合了<code class="fe oh oi oj nm b">args</code>和<code class="fe oh oi oj nm b">form</code>的<code class="fe oh oi oj nm b">CombinedMultiDict</code></p><p id="eec5" class="pw-post-body-paragraph lb lc iq ld b le lf ka lg lh li kd lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated"><code class="fe oh oi oj nm b"><a class="ae la" href="https://flask.palletsprojects.com/en/1.1.x/api/#flask.Request.json" rel="noopener ugc nofollow" target="_blank">request.json</a></code> →如果<em class="mj"> mimetype </em>为<code class="fe oh oi oj nm b">application/json</code>则返回解析后的 JSON 数据</p><p id="6157" class="pw-post-body-paragraph lb lc iq ld b le lf ka lg lh li kd lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated"><code class="fe oh oi oj nm b"><a class="ae la" href="https://flask.palletsprojects.com/en/1.1.x/api/#flask.Request.files" rel="noopener ugc nofollow" target="_blank">request.files</a></code> →返回包含所有上传文件的<code class="fe oh oi oj nm b">MultiDict</code>对象。每个键是文件名，值是<code class="fe oh oi oj nm b">FileStorage</code>对象。</p><p id="9f0f" class="pw-post-body-paragraph lb lc iq ld b le lf ka lg lh li kd lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated"><code class="fe oh oi oj nm b"><a class="ae la" href="https://flask.palletsprojects.com/en/1.1.x/api/#flask.Request.authorization" rel="noopener ugc nofollow" target="_blank">request.authorization</a></code> →返回一个<code class="fe oh oi oj nm b"><a class="ae la" href="https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.Authorization" rel="noopener ugc nofollow" target="_blank">Authorization</a></code>类的对象。它代表客户端发送的一个<em class="mj">授权</em>头。</p></div><div class="ab cl nv nw hu nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ij ik il im in"><h1 id="ead0" class="mo mp iq bd mq mr oc mt mu mv od mx my kf oe kg na ki of kj nc kl og km ne nf bi translated">app.run()参数</h1><p id="7192" class="pw-post-body-paragraph lb lc iq ld b le ng ka lg lh nh kd lj lk ni lm ln lo nj lq lr ls nk lu lv lw ij bi translated"><code class="fe oh oi oj nm b">app.run()</code>在服务器上运行应用程序。除了<code class="fe oh oi oj nm b">host</code>和<code class="fe oh oi oj nm b">port</code> <br/>之外，还有各种参数可以与<code class="fe oh oi oj nm b"><a class="ae la" href="https://flask.palletsprojects.com/en/1.1.x/api/?highlight=threaded#flask.Flask.run" rel="noopener ugc nofollow" target="_blank">app.run()</a></code>一起使用，其中包括:</p><p id="8f76" class="pw-post-body-paragraph lb lc iq ld b le lf ka lg lh li kd lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated"><code class="fe oh oi oj nm b">debug</code> →如果<code class="fe oh oi oj nm b">debug</code>参数设置为<code class="fe oh oi oj nm b">True</code>，那么服务器将在代码更改时自动重新加载，并在出现未处理的异常时显示交互式调试器。默认为<code class="fe oh oi oj nm b">False</code></p><p id="fb11" class="pw-post-body-paragraph lb lc iq ld b le lf ka lg lh li kd lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated"><code class="fe oh oi oj nm b">use_reloader</code> →当<code class="fe oh oi oj nm b">use_reloader</code>设置为<code class="fe oh oi oj nm b">True</code>时，当代码改变时，服务器将自动重启。默认为<code class="fe oh oi oj nm b">False</code></p><p id="5f1d" class="pw-post-body-paragraph lb lc iq ld b le lf ka lg lh li kd lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated"><code class="fe oh oi oj nm b">threaded</code> →当<code class="fe oh oi oj nm b">threaded</code>设置为<code class="fe oh oi oj nm b">True</code>时，进程将在单独的线程中处理每个请求。默认为<code class="fe oh oi oj nm b">False</code></p><p id="aff9" class="pw-post-body-paragraph lb lc iq ld b le lf ka lg lh li kd lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated"><code class="fe oh oi oj nm b">ssl_context</code> →连接的 SSL 上下文。如果服务器应该自动创建上下文，则需要<code class="fe oh oi oj nm b"><a class="ae la" href="https://docs.python.org/3/library/ssl.html#ssl.SSLContext" rel="noopener ugc nofollow" target="_blank">ssl.SSLContext</a></code>、格式为<code class="fe oh oi oj nm b">(cert_file, pkey_file)</code>的元组或字符串<code class="fe oh oi oj nm b">'adhoc'</code>。默认值为<code class="fe oh oi oj nm b">None</code>，即 SSL 被禁用。当我们想在 HTTPS 而不是 HTTP 上托管 Flask 应用程序时，使用这个。</p></div><div class="ab cl nv nw hu nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ij ik il im in"><h1 id="4a42" class="mo mp iq bd mq mr oc mt mu mv od mx my kf oe kg na ki of kj nc kl og km ne nf bi translated">蓝图</h1><p id="d7e8" class="pw-post-body-paragraph lb lc iq ld b le ng ka lg lh nh kd lj lk ni lm ln lo nj lq lr ls nk lu lv lw ij bi translated">蓝图允许我们将不同的端点分成子域。</p><p id="4af2" class="pw-post-body-paragraph lb lc iq ld b le lf ka lg lh li kd lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated"><code class="fe oh oi oj nm b">home.py</code></p><pre class="kp kq kr ks gt nl nm nn bn no np bi"><span id="22e6" class="nq mp iq nm b be nr ns l nt nu">from flask import Blueprint<br/>home_bp = Blueprint('home', __name__)<br/><br/>@home_bp.route('/hello/')<br/>def hello():<br/>    return "Hello from Home Page"</span></pre><p id="a313" class="pw-post-body-paragraph lb lc iq ld b le lf ka lg lh li kd lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated"><code class="fe oh oi oj nm b">contact.py</code></p><pre class="kp kq kr ks gt nl nm nn bn no np bi"><span id="f0af" class="nq mp iq nm b be nr ns l nt nu">from flask import Blueprint<br/>contact_bp = Blueprint('contact', __name__)<br/><br/>@contact_bp.route('/hello/')<br/>def hello():<br/>    return "Hello from Contact Page"</span></pre><p id="c9b9" class="pw-post-body-paragraph lb lc iq ld b le lf ka lg lh li kd lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated"><code class="fe oh oi oj nm b">app.py</code></p><pre class="kp kq kr ks gt nl nm nn bn no np bi"><span id="40a3" class="nq mp iq nm b be nr ns l nt nu">from flask import Flask<br/><br/>from home import home_bp<br/>from contact import contact_bp<br/><br/>app = Flask(__name__)<br/><br/>app.register_blueprint(home_bp, url_prefix='/home')<br/>app.register_blueprint(contact_bp, url_prefix='/contact')<br/><br/>app.run()</span></pre><p id="cc1f" class="pw-post-body-paragraph lb lc iq ld b le lf ka lg lh li kd lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated">注意，在两个蓝图中，<code class="fe oh oi oj nm b">/hello/</code>路线都在调用<code class="fe oh oi oj nm b">hello</code>函数。</p><p id="ea31" class="pw-post-body-paragraph lb lc iq ld b le lf ka lg lh li kd lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated">当你去<code class="fe oh oi oj nm b">http://localhost:5000/home/hello</code>时，输出将是<code class="fe oh oi oj nm b">Hello from Home Page</code> <br/>而当你访问<code class="fe oh oi oj nm b">http://localhost:5000/contact/hello</code>时，输出将是<code class="fe oh oi oj nm b">Hello from Contact Page</code></p><h1 id="d785" class="mo mp iq bd mq mr ms mt mu mv mw mx my kf mz kg na ki nb kj nc kl nd km ne nf bi translated">记录</h1><p id="f760" class="pw-post-body-paragraph lb lc iq ld b le ng ka lg lh nh kd lj lk ni lm ln lo nj lq lr ls nk lu lv lw ij bi translated">您可以使用以下方法在 Flask 应用程序中记录语句</p><pre class="kp kq kr ks gt nl nm nn bn no np bi"><span id="a0bf" class="nq mp iq nm b be nr ns l nt nu">app.logger.debug('This is a DEBUG message')<br/>app.logger.info('This is an INFO message')<br/>app.logger.warning('This is a WARNING message')<br/>app.logger.error('This is an ERROR message')</span></pre></div><div class="ab cl nv nw hu nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ij ik il im in"><h2 id="932c" class="ok mp iq bd mq ol om dn mu on oo dp my lk op oq na lo or os nc ls ot ou ne iw bi translated">参考</h2><ul class=""><li id="f147" class="ov ow iq ld b le ng lh nh lk pj lo pk ls pl lw pm pb pc pd bi translated"><a class="ae la" href="https://flask.palletsprojects.com/en/1.1.x/foreword/" rel="noopener ugc nofollow" target="_blank">https://flask.palletsprojects.com/en/1.1.x/foreword/</a></li></ul><h2 id="ce04" class="ok mp iq bd mq ol om dn mu on oo dp my lk op oq na lo or os nc ls ot ou ne iw bi translated">资源</h2><p id="953e" class="pw-post-body-paragraph lb lc iq ld b le ng ka lg lh nh kd lj lk ni lm ln lo nj lq lr ls nk lu lv lw ij bi translated">这篇文章的所有代码片段都可以在我的<a class="ae la" href="https://jimit105.github.io/medium-articles/Creating%20RESTful%20APIs%20using%20Flask%20and%20Python.html" rel="noopener ugc nofollow" target="_blank"> GitHub 页面</a>上找到。</p><h2 id="09b0" class="ok mp iq bd mq ol om dn mu on oo dp my lk op oq na lo or os nc ls ot ou ne iw bi translated">推荐阅读</h2><p id="bde7" class="pw-post-body-paragraph lb lc iq ld b le ng ka lg lh nh kd lj lk ni lm ln lo nj lq lr ls nk lu lv lw ij bi translated"><a class="ae la" href="https://medium.com/p/7461b3a9a2c8" rel="noopener">用 Flask、Flask-RESTPlus / Flask-RESTX 和 Swagger UI 构建 Python API</a></p><h2 id="8037" class="ok mp iq bd mq ol om dn mu on oo dp my lk op oq na lo or os nc ls ot ou ne iw bi translated">让我们连接</h2><p id="a86e" class="pw-post-body-paragraph lb lc iq ld b le ng ka lg lh nh kd lj lk ni lm ln lo nj lq lr ls nk lu lv lw ij bi translated">领英:<a class="ae la" href="https://www.linkedin.com/in/jimit105/" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/jimit105/</a><br/>GitHub:<a class="ae la" href="https://github.com/jimit105" rel="noopener ugc nofollow" target="_blank">https://github.com/jimit105</a><br/>推特:<a class="ae la" href="https://twitter.com/jimit105" rel="noopener ugc nofollow" target="_blank">https://twitter.com/jimit105</a></p></div></div>    
</body>
</html>