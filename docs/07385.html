<html>
<head>
<title>PowerBI RS: Setting Data Refresh in Trigger Mode</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PowerBI RS:在触发模式下设置数据刷新</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/game-changer-in-pbirs-setting-data-refresh-in-trigger-mode-62e594700b60?source=collection_archive---------23-----------------------#2020-06-04">https://towardsdatascience.com/game-changer-in-pbirs-setting-data-refresh-in-trigger-mode-62e594700b60?source=collection_archive---------23-----------------------#2020-06-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="c334" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用Power BI报告服务器数据库可以做许多在Power BI服务中不能做的事情，其中之一就是在报告数据集上设置触发数据刷新。</p><h1 id="4ab5" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">什么是触发模式下的数据刷新？</h1><p id="0bce" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">顾名思义，它将触发您的PBI报表的数据集来刷新事件。例如，当报表引用的数据源发生更改(添加、更改或删除)时，触发条件将被激活，以允许PBI报表立即刷新数据，并使PBI报表数据保持最新。典型的应用过程如下:</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/5d1ecb9ea8bfd53de00ea1357bb9a957.png" data-original-src="https://miro.medium.com/v2/resize:fit:1226/0*6ghKPEckGZpZ0RFE"/></div><p class="lz ma gj gh gi mb mc bd b be z dk translated">作者图片</p></figure><h1 id="69b1" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">为什么使用触发模式来刷新您的报告数据？</h1><p id="74dc" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">在PBIRS中，PBI报表有两种主要的数据刷新类型:计划刷新和DirectQuery。DirectQuery使用户在每次使用报表时都能持续获得最新的数据，但缺点是当报表查询逻辑复杂时，可能会严重影响报表的性能。此外，计算引擎不支持某些DAX函数(如时间智能函数)。在计划刷新模式下，理论上，您的报告性能不会受到刷新行为的影响，您可以使用任何支持PowerBI的DAX函数，这很好，但是，您不能保证用户在使用报告时会获得最新的数据。</p><p id="8195" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以，这就成了一个很尴尬的事实。假设你需要开发一个报表，这个报表需要使用DAX时间智能函数(而不是SQL)，你必须保证用户在使用它的时候能及时看到最新的数据。那么，如何为数据集选择刷新模式呢？也许你会设置你的报表每一分钟刷新一次，但是如果你的报表数据比较多，不仅会增加数据刷新失败的概率还会给服务器造成一定的负担。因此，触发模式下的数据刷新成为了最佳解决方案。它结合了DirectQuery和计划刷新的优点。只有当数据发生变化时，才会执行数据刷新。这不仅可以确保用户在使用报表时可以看到最新的数据，还可以在不影响报表性能的情况下减轻服务器的负担。这就是为什么您应该在触发器模式下刷新报告数据。</p><h1 id="ade2" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">如何实现？</h1><p id="a4da" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">首先，作为示例，我在数据库中创建一个表。如下图，我创建了一个新表，插入了三行数据——中国古代战国时期(公元前475-221)的三大名将:白起、廉颇、王建，简单的像这样:</p><pre class="ls lt lu lv gt md me mf mg aw mh bi"><span id="a804" class="mi kp it me b gy mj mk l ml mm">CREATE TABLE [TriggerRefreshTest]<br/>(<br/>[No_] int,<br/>[Name] nvarchar(10),<br/>[Country] nvarchar(20)<br/>)</span><span id="84c5" class="mi kp it me b gy mn mk l ml mm">Insert Into [TriggerRefreshTest]<br/>values(</span><span id="4995" class="mi kp it me b gy mn mk l ml mm">1, 'BaiQi', 'The Kingdom of Qin'</span><span id="f6f9" class="mi kp it me b gy mn mk l ml mm">),(</span><span id="51b5" class="mi kp it me b gy mn mk l ml mm">2, 'LianPo', 'The Kingdom of Zhao'</span><span id="9be5" class="mi kp it me b gy mn mk l ml mm">),(</span><span id="d07d" class="mi kp it me b gy mn mk l ml mm">3, 'WangJian', 'The Kingdom of Qin'</span><span id="ae23" class="mi kp it me b gy mn mk l ml mm">)</span></pre><p id="5d8a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将数据导入Power BI Desktop并按如下方式发布:</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/c99c716075fce076e93faabaa9ba984e.png" data-original-src="https://miro.medium.com/v2/resize:fit:476/0*lXH8PskSMb0sMOGu"/></div><p class="lz ma gj gh gi mb mc bd b be z dk translated">作者图片</p></figure><p id="a2ac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们现在要达到的效果是，当我在数据库中插入一行新的数据——(李牧，赵国)，然后立即触发一个数据刷新事件，使报表数据保持最新。在SSMS，创建一个新的触发事件，如下所示:</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/f69b33c1165f47f2b581c81c0eba4037.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/0*_2wULxom5SUWu2ag"/></div><p class="lz ma gj gh gi mb mc bd b be z dk translated">作者图片</p></figure><p id="a6a2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后我们需要用SQL写一个触发脚本。对于没有学过SQL的读者来说还是可以的。可以直接使用下面的代码。我已经简化并优化了脚本。您只需要用您的报告信息替换下面的代码(我已经做了注释):</p><pre class="ls lt lu lv gt md me mf mg aw mh bi"><span id="ea99" class="mi kp it me b gy mj mk l ml mm">SET ANSI_NULLS ON</span><span id="e4a3" class="mi kp it me b gy mn mk l ml mm">GO</span><span id="69ce" class="mi kp it me b gy mn mk l ml mm">SET QUOTED_IDENTIFIER ON</span><span id="6401" class="mi kp it me b gy mn mk l ml mm">GO</span><span id="31e0" class="mi kp it me b gy mn mk l ml mm">IF OBJECT_ID<br/>(<br/>    N'trigger_data_refresh'<br/>) is not null</span><span id="9319" class="mi kp it me b gy mn mk l ml mm">DROP TRIGGER trigger_data_refresh;</span><span id="fe37" class="mi kp it me b gy mn mk l ml mm">GO</span><span id="9b34" class="mi kp it me b gy mn mk l ml mm">CREATE TRIGGER trigger_data_refresh <br/>ON [TriggerRefreshTest]  --Replace with your table name here</span><span id="d01e" class="mi kp it me b gy mn mk l ml mm">AFTER INSERT<br/>AS <br/>SET NOCOUNT ON;</span><span id="cef1" class="mi kp it me b gy mn mk l ml mm">DECLARE @REPORT_NAME NVARCHAR<br/>(<br/>    50<br/>),<br/>@REPORT_ID VARCHAR<br/>(<br/>    100<br/>),<br/>@SUBSCRIPTION_ID VARCHAR<br/>(<br/>    100<br/>)<br/>SET @REPORT_NAME = 'WarringStates' --Replace with your PBI report name.<br/>SET @REPORT_ID = <br/>(<br/>    SELECT TOP 1 [ItemID]<br/>    FROM [ReportServer].[dbo].[Catalog]<br/>    WHERE [Name] = @REPORT_NAME<br/>)<br/>SET @SUBSCRIPTION_ID = <br/>(<br/>    SELECT TOP 1 SubscriptionID<br/>    FROM [ReportServer].[dbo].[ReportSchedule]<br/>    WHERE [ReportID] = @REPORT_ID<br/>)</span><span id="f29d" class="mi kp it me b gy mn mk l ml mm">BEGIN<br/>WAITFOR DELAY '0:0:3'<br/>exec [ReportServer].dbo.AddEvent <br/>@EventType='DataModelRefresh',<br/>@EventData=@SUBSCRIPTION_ID<br/>END</span><span id="f562" class="mi kp it me b gy mn mk l ml mm">GO</span></pre><p id="c505" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，运行代码，这样我们的触发器刷新就设置好了。让我们在表中插入一个新行—[triggerefreshtest]:</p><pre class="ls lt lu lv gt md me mf mg aw mh bi"><span id="e1cd" class="mi kp it me b gy mj mk l ml mm">Insert Into [TriggerRefreshTest]<br/>values (</span><span id="0e00" class="mi kp it me b gy mn mk l ml mm">4, 'LiMu', 'The Kingdom of Zhao'</span><span id="931e" class="mi kp it me b gy mn mk l ml mm">)</span></pre><p id="2365" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我们的触发机制已经检测到数据更改，因此数据刷新事件已被激活。返回Power BI RS的报告页面，点击“刷新”刷新缓存，可以看到，刚刚插入的数据立即显示在报告中！</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/330754e96900a7365592d1b0bff026bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/0*Cte-LUu8TKS3QjsT"/></div><p class="lz ma gj gh gi mb mc bd b be z dk translated">作者图片</p></figure><h1 id="d67e" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">考虑</h1><p id="03f6" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">如果数据源表由多个用户维护，那么他们可能会同时修改数据，这可能会导致问题(比如表锁定)。我认为解决方案之一是强制最小刷新间隔。这可以通过修改存储过程来实现。</p><p id="d6fc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="mr">结束~ </em></p><p id="4948" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="mr">(本文中文首发于2019年12月</em><a class="ae ms" href="https://d-bi.gitee.io/pbi-trigger-refresh/" rel="noopener ugc nofollow" target="_blank"><em class="mr">D-BI</em></a><em class="mr">)</em></p></div></div>    
</body>
</html>