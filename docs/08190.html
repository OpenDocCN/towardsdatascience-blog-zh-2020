<html>
<head>
<title>How to Profile Your Code in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Python中分析您的代码</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-profile-your-code-in-python-e70c834fad89?source=collection_archive---------2-----------------------#2020-06-16">https://towardsdatascience.com/how-to-profile-your-code-in-python-e70c834fad89?source=collection_archive---------2-----------------------#2020-06-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="217b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用cProfile查找瓶颈并优化性能</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4988a7c1b57cf832aa29bdf51be8813f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mc2fHK6i7P55an71k4g2bg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来自<a class="ae kv" href="https://www.pexels.com/photo/speed-bump-speed-limit-traffic-sign-vintage-1502365/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>的<a class="ae kv" href="https://www.pexels.com/@anthony-maggio-657507?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Anthony Maggio </a>摄影</p></figure><p id="2485" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你曾经写过一行代码(或者甚至几万行)，你一定想知道“为什么我的代码需要这么长时间才能运行？”回答这个问题并不总是简单的，但如果你以正确的方式寻找答案，它会变得更容易。</p><p id="33d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也许你相信你手头问题的知识，利用你的专业知识先检查某些片段。也许你对几个不同的模块/类/函数计时，看看大部分执行时间花在哪里。更好的是，您可以分析您的代码，以获得更多关于不同函数和子函数所花费的相对时间的信息。不管你的过程是什么，这个博客可能会教你一些更快找到答案的方法。</p><p id="65bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我将首先向您展示一个基本的分析方法。我将为它添加越来越多的特性和味道，以一个好的、可靠的剖析装饰器结束。对于那些赶时间的人(或者想回头参考这些资料的人)，可以去这个<a class="ae kv" href="https://github.com/ekhoda/profile_decorator" rel="noopener ugc nofollow" target="_blank"> GitHub仓库</a>，在那里你可以找到概要文件装饰器和一个例子。</p><h1 id="b7f3" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">计时！</h1><p id="250c" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">要分析你的代码，你需要知道如何计时。为此，您可以使用如下简单的方法:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="ca9c" class="mu lt iq mq b gy mv mw l mx my"><strong class="mq ir">from </strong>time <strong class="mq ir">import </strong>time</span><span id="f670" class="mu lt iq mq b gy mz mw l mx my">start = time()<br/><em class="na"># your script here<br/></em>end = time()<br/>print(<strong class="mq ir">f'It took {</strong>end - start<strong class="mq ir">} seconds!'</strong>)</span></pre><p id="a2a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了方便地为几个函数/代码片段计时(或者如果您只是喜欢使用更简洁、更pythonic化的方法)，您可以将上面的内容转换成一个<em class="na">计时器装饰器</em>(这里用示例<a class="ae kv" rel="noopener" target="_blank" href="/bite-sized-python-recipes-52cde45f1489">讨论</a>)。</p><p id="8e58" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在任何函数上使用定时器都可以单独显示该部分的运行时间。为了使这种方法有助于找到瓶颈，我们需要更多的信息。为了有效地分析代码，下列两个条件中至少有一个应该为真:</p><ol class=""><li id="9c09" class="nb nc iq ky b kz la lc ld lf nd lj ne ln nf lr ng nh ni nj bi translated"><strong class="ky ir">我们应该知道程序的总运行时间，以便更好地了解我们期望的功能/部分的相对运行时间。</strong>例如，如果一段代码需要5分钟来执行，那是总运行时间的10%、40%还是90%？</li><li id="5e25" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">我们应该对手头的问题或程序其他部分的运行时间有足够的了解，从而有把握地将一段给定的代码标记为瓶颈。即使一个功能需要10分钟才能运行(假设10分钟相对来说很长)，如果我们确信没有其他部分需要更长的时间，我们就应该担心它的低效率。正如唐纳德·克努特的名言:</li></ol><blockquote class="np"><p id="2a5b" class="nq nr iq bd ns nt nu nv nw nx ny lr dk translated">过早优化是万恶之源。</p></blockquote><p id="cb4e" class="pw-post-body-paragraph kw kx iq ky b kz nz jr lb lc oa ju le lf ob lh li lj oc ll lm ln od lp lq lr ij bi translated">像<code class="fe oe of og mq b"><a class="ae kv" href="https://docs.python.org/3.8/library/profile.html" rel="noopener ugc nofollow" target="_blank">cProfile</a></code>这样的分析器包通过满足这两个条件来帮助我们找到代码中的瓶颈。</p><h1 id="ae7d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">如何使用cProfile</h1><h2 id="0ff5" class="mu lt iq bd lu oh oi dn ly oj ok dp mc lf ol om me lj on oo mg ln op oq mi or bi translated">基本用法</h2><p id="cb94" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">用<code class="fe oe of og mq b">cProfile</code>进行概要分析的最基本方式是使用<code class="fe oe of og mq b">run()</code>函数。您需要做的就是将您想要分析的内容作为字符串语句传递给<code class="fe oe of og mq b">run()</code>。这是报告的一个示例(为简洁起见，进行了删节):</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="091b" class="mu lt iq mq b gy mv mw l mx my">&gt;&gt;&gt; <strong class="mq ir">import </strong>cProfile<br/>&gt;&gt;&gt; <strong class="mq ir">import </strong>pandas <strong class="mq ir">as </strong>pd</span><span id="9c42" class="mu lt iq mq b gy mz mw l mx my">&gt;&gt;&gt; cProfile.run(<strong class="mq ir">"pd.Series(list('ABCDEFG'))"</strong>)</span><span id="7b9f" class="mu lt iq mq b gy mz mw l mx my">258 function calls (256 primitive calls) in 0.001 seconds</span><span id="331c" class="mu lt iq mq b gy mz mw l mx my">Ordered by: standard name</span><span id="b708" class="mu lt iq mq b gy mz mw l mx my">ncalls  tottime  percall  cumtime  percall filename:lineno(function)<br/>     4    0.000    0.000    0.000    0.000 &lt;frozen importlib._bootstrap&gt;:997(_handle_fromlist)<br/>     1    0.000    0.000    0.000    0.000 &lt;string&gt;:1(&lt;module&gt;)<br/>     1    0.000    0.000    0.000    0.000 _dtype.py:319(_name_get)<br/>  ....<br/>  11/9    0.000    0.000    0.000    0.000 {built-in method builtins.len}<br/>     1    0.000    0.000    0.000    0.000 {built-in method numpy.array}<br/>     1    0.000    0.000    0.000    0.000 {built-in method numpy.empty}<br/>  ....</span></pre><p id="aa85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一行表示监控了258个调用，其中256个是原始调用(原始调用不是通过递归引起的)。下一行<code class="fe oe of og mq b">Ordered by: standard name</code>表示报告是基于标准名称排序的，标准名称是<code class="fe oe of og mq b">filename:lineno(function)</code>列中的文本。其后的一行是列标题:</p><p id="5fb9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe oe of og mq b">ncalls</code>:呼叫次数。当有两个数字时(如上面的11/9)，该函数循环出现。第一个值是调用的总数，第二个值是原始或非递归调用的数量。</p><p id="2e55" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe oe of og mq b">tottime</code>:给定函数花费的总时间(不包括调用子函数的时间)。</p><p id="c6bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe oe of og mq b">percall</code>:是<code class="fe oe of og mq b">tottime</code>除以<code class="fe oe of og mq b">ncalls</code>的商。</p><p id="d8b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe oe of og mq b">cumtime</code>:该功能及所有子功能的累计时间。这个数字对于递归函数来说是精确的<em class="na">甚至</em>。</p><p id="6529" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe oe of og mq b">percall</code>:是<code class="fe oe of og mq b">cumtime</code>的商除以原语调用。</p><p id="daff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe oe of og mq b">filename:lineno(function)</code>:提供各功能各自的数据。</p><p id="a36b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe oe of og mq b">run()</code>函数可以再接受两个参数:一个<code class="fe oe of og mq b">filename</code>将结果写入文件而不是stdout，另一个<code class="fe oe of og mq b">sort</code>参数指定输出应该如何排序。您可以查看<a class="ae kv" href="https://docs.python.org/3.8/library/profile.html#pstats.Stats.sort_stats" rel="noopener ugc nofollow" target="_blank">文档</a>以了解更多关于有效排序值的信息。常见的有<code class="fe oe of og mq b">'cumulative'</code>(累计时间)<code class="fe oe of og mq b">'time'</code>(总时间)<code class="fe oe of og mq b">'calls'</code>(通话次数)。</p><p id="aeef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您传递一个文件名并保存结果，您可能会注意到输出不是人类可读的。在这种情况下，您需要使用<code class="fe oe of og mq b">pstats.Stats</code>类来格式化结果，我们将在接下来讨论。</p></div><div class="ab cl os ot hu ou" role="separator"><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox"/></div><div class="ij ik il im in"><h2 id="90a1" class="mu lt iq bd lu oh oi dn ly oj ok dp mc lf ol om me lj on oo mg ln op oq mi or bi translated">使用<code class="fe oe of og mq b">Profile</code>和<code class="fe oe of og mq b">pstats.Stats</code>进行更多控制</h2><p id="6d06" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">虽然在大多数情况下使用<code class="fe oe of og mq b">cProfile.run()</code>就足够了，但是如果您需要对分析进行更多的控制，您应该使用<code class="fe oe of og mq b">cProfile</code>的<code class="fe oe of og mq b">Profile</code>类。下面的片段摘自<code class="fe oe of og mq b">Profile</code>级<a class="ae kv" href="https://docs.python.org/3.8/library/profile.html#profile.Profile" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="fce2" class="mu lt iq mq b gy mv mw l mx my"><strong class="mq ir">import </strong>cProfile, pstats, io<br/><strong class="mq ir">from </strong>pstats <strong class="mq ir">import </strong>SortKey<br/><br/>pr = cProfile.Profile()<br/>pr.enable()<br/><em class="na"># ... do something ...<br/></em>pr.disable()<br/>s = io.StringIO()<br/>sortby = SortKey.CUMULATIVE<br/>ps = pstats.Stats(pr, stream=s).sort_stats(sortby)<br/>ps.print_stats()<br/>print(s.getvalue())</span></pre><p id="76db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们一行一行地过一遍:</p><p id="eff6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们创建一个<code class="fe oe of og mq b">Profile</code>类(<code class="fe oe of og mq b">pr</code>)的实例，并通过调用<code class="fe oe of og mq b">enable</code>收集概要分析数据。当我们想要停止收集分析数据时，我们调用<code class="fe oe of og mq b">disable</code>。接下来是对收集的统计数据进行格式化。然后，我们可以使用<code class="fe oe of og mq b"><a class="ae kv" href="https://docs.python.org/3.8/library/profile.html#pstats.Stats" rel="noopener ugc nofollow" target="_blank">pstats.Stats</a></code>类构造函数来创建statistics对象的实例(<code class="fe oe of og mq b">ps</code>)。</p><p id="ee09" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe oe of og mq b">Stats</code>类可以从profile对象(<code class="fe oe of og mq b">pr</code>)创建一个statistics对象，并将输出打印到传递给它的流中。<code class="fe oe of og mq b">Stats</code>类还有一个<code class="fe oe of og mq b">sort_stats</code>方法，根据提供的标准对结果进行排序。在这种情况下，标准是<code class="fe oe of og mq b">SortKey.CUMULATIVE</code>,它代表在一个函数中花费的累计时间。如<code class="fe oe of og mq b"><a class="ae kv" href="https://docs.python.org/3.8/library/profile.html#pstats.Stats.sort_stats" rel="noopener ugc nofollow" target="_blank">sort_stats</a></code>文档所述，排序标准可以是<code class="fe oe of og mq b">SortKey</code>枚举(在Python 3.7中添加)或字符串的形式(即使用<code class="fe oe of og mq b">'cumulative'</code>代替<code class="fe oe of og mq b">SortKey.CUMULATIVE</code>也是有效的)。最后，创建结果并打印到标准输出。</p><p id="a91f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是构建装饰器的好样板(要了解更多关于装饰器的知识，我推荐这本伟大而全面的<a class="ae kv" href="https://realpython.com/primer-on-python-decorators/" rel="noopener ugc nofollow" target="_blank">初级读本</a>):</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="5f90" class="mu lt iq mq b gy mv mw l mx my"><strong class="mq ir">import </strong>cProfile<br/><strong class="mq ir">import </strong>io<br/><strong class="mq ir">import </strong>pstats</span><span id="7eb5" class="mu lt iq mq b gy mz mw l mx my"><strong class="mq ir">def </strong>profile(func):<br/>    <strong class="mq ir">def </strong>wrapper(*args, **kwargs):<br/>        pr = cProfile.Profile()<br/>        pr.enable()<br/>        retval = func(*args, **kwargs)<br/>        pr.disable()<br/>        s = io.StringIO()<br/>        sortby = SortKey.CUMULATIVE  # <strong class="mq ir">'cumulative'<br/>        </strong>ps = pstats.Stats(pr, stream=s).sort_stats(sortby)<br/>        ps.print_stats()<br/>        print(s.getvalue())<br/>        <strong class="mq ir">return </strong>retval<br/><br/>    <strong class="mq ir">return </strong>wrapper</span><span id="a64f" class="mu lt iq mq b gy mz mw l mx my"><em class="na"># Profile foo<br/></em>@profile<br/><strong class="mq ir">def </strong>foo():<br/>    print(<strong class="mq ir">'Profile me!'</strong>)</span></pre><p id="7309" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然这是一个好的开始，但是上面的装饰器中还有几个部分可以做得更好。特别是，更全面的职能可以:</p><ol class=""><li id="1903" class="nb nc iq ky b kz la lc ld lf nd lj ne ln nf lr ng nh ni nj bi translated">允许用户指定排序键(单个键或一组排序键)</li><li id="6b8f" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">仅显示最大时间消费者，而不是所有线路</li><li id="2dfd" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">通过删除文件名中的所有前导路径信息来整理报告，减小打印输出的大小并使报告更易于阅读</li><li id="d87a" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">将输出保存到文件，而不是打印到标准输出</li></ol><p id="01e6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以上所有情况都可以使用<code class="fe oe of og mq b">pstats.Stats</code>中的方法进行处理。让我们按顺序复习一下:</p><ol class=""><li id="da8b" class="nb nc iq ky b kz la lc ld lf nd lj ne ln nf lr ng nh ni nj bi translated">将所需的排序键传递给<code class="fe oe of og mq b">sort_stats()</code>方法(尽管我们仍然需要检查它是单个值还是一个元组)</li><li id="5b92" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">将最大所需打印行数传递给<code class="fe oe of og mq b">print_stats()</code></li><li id="8989" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">使用<code class="fe oe of og mq b">strip_dirs()</code></li><li id="6446" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">默认情况下，输出被打印到<code class="fe oe of og mq b"><a class="ae kv" href="https://docs.python.org/3/library/sys.html#sys.stdout" rel="noopener ugc nofollow" target="_blank">sys.stdout</a></code>,因为<code class="fe oe of og mq b">pstats.Stats()</code>使用它作为默认的流参数，但是要将结果写入文件，我们可以将文件作为流传递</li></ol><p id="6091" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将上述更改应用到<code class="fe oe of og mq b">profile</code>装饰器将产生以下函数(在docstring中提供了参数的更多解释):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oz pa l"/></div></figure><h1 id="7983" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">总结示例</h1><p id="ad62" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">为了了解<code class="fe oe of og mq b">profile</code>装饰器如何帮助我们检测瓶颈，让我们创建一个具有多个函数的例子。假设您有一份过去一年销售的产品列表，并且您想通过计算售出的数量来了解每种产品的受欢迎程度。(我们想要的可以通过使用<code class="fe oe of og mq b"><a class="ae kv" href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="noopener ugc nofollow" target="_blank">collections.Counter</a></code>很容易地完成，或者如果你是一个<code class="fe oe of og mq b">pandas</code>用户，通过<code class="fe oe of og mq b"><a class="ae kv" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.value_counts.html" rel="noopener ugc nofollow" target="_blank">pandas.Series.value_counts</a></code>，但是为了这个练习，让我们忘记那些。)</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="3344" class="mu lt iq mq b gy mv mw l mx my"><strong class="mq ir">import </strong>random<br/>random.seed(20)</span><span id="e75e" class="mu lt iq mq b gy mz mw l mx my"><strong class="mq ir">def </strong>create_products(num):<br/>    <em class="na">"""Create a list of random products with 3-letter alphanumeric name."""<br/>    </em><strong class="mq ir">return </strong>[<strong class="mq ir">''</strong>.join(random.choices(<strong class="mq ir">'ABCDEFG123'</strong>, k=3)) <strong class="mq ir">for </strong>_ <strong class="mq ir">in </strong>range(num)]<br/><br/><em class="na"># version1<br/></em>@profile(sort_by=<strong class="mq ir">'cumulative'</strong>, lines_to_print=10, strip_dirs=<strong class="mq ir">True</strong>)<br/><strong class="mq ir">def </strong>product_counter_v1(products):<br/>    <em class="na">"""Get count of products in descending order."""<br/>    </em>counter_dict = create_counter(products)<br/>    sorted_p = sort_counter(counter_dict)<br/>    <strong class="mq ir">return </strong>sorted_p<br/><br/><strong class="mq ir">def </strong>create_counter(products):<br/>    counter_dict = {}<br/>    <strong class="mq ir">for </strong>p <strong class="mq ir">in </strong>products:<br/>        <strong class="mq ir">if </strong>p <strong class="mq ir">not in </strong>counter_dict:<br/>            counter_dict[p] = 0<br/>        counter_dict[p] += 1<br/>    <strong class="mq ir">return </strong>counter_dict<br/><br/><strong class="mq ir">def </strong>sort_counter(counter_dict):<br/>    <strong class="mq ir">return </strong>{k: v <strong class="mq ir">for </strong>k, v <strong class="mq ir">in </strong>sorted(counter_dict.items(),<br/>                                    key=<strong class="mq ir">lambda </strong>x: x[1],<br/>                                    reverse=<strong class="mq ir">True</strong>)}<br/><br/><em class="na"># ===========<br/># Analysis starts here<br/># ===========<br/></em>num = 1_000_000  <em class="na"># assume we have sold 1,000,000 products<br/></em>products = create_products(num)<br/><em class="na"># Let's add profile decorator to product_counter_v1 function<br/></em>counter_dict = product_counter_v1(products)</span></pre><p id="28e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">结果将保存在您当前目录下的<code class="fe oe of og mq b">product_counter_v1.prof</code>中，它应该是这样的:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="ced8" class="mu lt iq mq b gy mv mw l mx my">1007 function calls in 0.228 seconds<br/><br/>Ordered by: cumulative time<br/><br/>ncalls  tottime  percall  cumtime  percall filename:lineno(function)<br/>     1    0.000    0.000    0.228    0.228 scratch_6.py:69(product_counter_v1)<br/>     1    0.215    0.215    0.215    0.215 scratch_6.py:86(create_counter)<br/>     1    0.000    0.000    0.013    0.013 scratch_6.py:105(sort_counter)<br/>     1    0.013    0.013    0.013    0.013 {built-in method builtins.sorted}<br/>     1    0.000    0.000    0.000    0.000 scratch_6.py:106(&lt;dictcomp&gt;)<br/>  1000    0.000    0.000    0.000    0.000 scratch_6.py:107(&lt;lambda&gt;)<br/>     1    0.000    0.000    0.000    0.000 {method 'items' of 'dict' objects}<br/>     1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}</span></pre><p id="0b7d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">检查这个文件，我们可以看到绝大部分的执行时间(0.228秒中的0.215秒)都花在了<code class="fe oe of og mq b">create_counter</code>函数上。所以，让我们制作一个新的<code class="fe oe of og mq b">create_counter</code>函数，并检查它的效果。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="8e0e" class="mu lt iq mq b gy mv mw l mx my"><em class="na"># version2<br/></em>@profile(sort_by=<strong class="mq ir">'cumulative'</strong>, lines_to_print=10, strip_dirs=<strong class="mq ir">True</strong>)<br/><strong class="mq ir">def </strong>product_counter_v2(products):<br/>    <em class="na">"""Get count of products in descending order."""<br/>    </em>counter_dict = create_counter_v2(products)<br/>    sorted_p = sort_counter(counter_dict)<br/>    <strong class="mq ir">return </strong>sorted_p<br/><br/><strong class="mq ir">def </strong>create_counter_v2(products):<br/>    counter_dict = {}<br/>    <strong class="mq ir">for </strong>p <strong class="mq ir">in </strong>products:<br/>        <strong class="mq ir">try</strong>:<br/>            counter_dict[p] += 1<br/>        <strong class="mq ir">except </strong>KeyError:<br/>            counter_dict[p] = 1<br/>    <strong class="mq ir">return </strong>counter_dict</span></pre><p id="6355" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">剖析结果<code class="fe oe of og mq b">product_counter_v2</code>如下所示:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="aad4" class="mu lt iq mq b gy mv mw l mx my">1007 function calls in 0.169 seconds<br/><br/>Ordered by: cumulative time<br/><br/>ncalls  tottime  percall  cumtime  percall filename:lineno(function)<br/>     1    0.000    0.000    0.169    0.169 scratch_6.py:78(product_counter_v2)<br/>     1    0.158    0.158    0.158    0.158 scratch_6.py:95(create_counter_v2)<br/>     1    0.000    0.000    0.010    0.010 scratch_6.py:105(sort_counter)<br/>     1    0.010    0.010    0.010    0.010 {built-in method builtins.sorted}<br/>     1    0.000    0.000    0.000    0.000 scratch_6.py:106(&lt;dictcomp&gt;)<br/>  1000    0.000    0.000    0.000    0.000 scratch_6.py:107(&lt;lambda&gt;)<br/>     1    0.000    0.000    0.000    0.000 {method 'items' of 'dict' objects}<br/>     1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}</span></pre><p id="0b24" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">运行时间从0.228秒减少到0.169秒，减少了约26%。如果这仍然不令人满意，您可以尝试使用<code class="fe oe of og mq b"><a class="ae kv" href="https://docs.python.org/3/library/collections.html#collections.defaultdict" rel="noopener ugc nofollow" target="_blank">collections.defaultdict</a></code>来创建<code class="fe oe of og mq b">counter_dict</code>。对于最后一个实现，我们将使用<code class="fe oe of og mq b">collections.Counter</code>:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="1977" class="mu lt iq mq b gy mv mw l mx my"><strong class="mq ir">import </strong>collections<br/><br/><em class="na"># version3<br/></em>@profile(sort_by=<strong class="mq ir">'cumulative'</strong>, lines_to_print=10, strip_dirs=<strong class="mq ir">True</strong>)<br/><strong class="mq ir">def </strong>product_counter_v3(products):<br/>    <em class="na">"""Get count of products in descending order."""<br/>    </em><strong class="mq ir">return </strong>collections.Counter(products)</span></pre><p id="9c36" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">性能分析<code class="fe oe of og mq b">product_counter_v3</code>显示它比<code class="fe oe of og mq b">product_counter_v1</code>提高了62%。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="e6ee" class="mu lt iq mq b gy mv mw l mx my">11 function calls in 0.086 seconds<br/><br/>Ordered by: cumulative time<br/><br/>ncalls  tottime  percall  cumtime  percall filename:lineno(function)<br/>     1    0.000    0.000    0.086    0.086 scratch_6.py:118(product_counter_v3)<br/>     1    0.000    0.000    0.086    0.086 __init__.py:517(__init__)<br/>     1    0.000    0.000    0.086    0.086 __init__.py:586(update)<br/>     1    0.086    0.086    0.086    0.086 {built-in method _collections._count_elements}<br/>     1    0.000    0.000    0.000    0.000 {built-in method builtins.isinstance}<br/>     1    0.000    0.000    0.000    0.000 abc.py:180(__instancecheck__)<br/>     2    0.000    0.000    0.000    0.000 _weakrefset.py:70(__contains__)<br/>     2    0.000    0.000    0.000    0.000 {built-in method builtins.len}<br/>     1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}</span></pre><p id="fe85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">试验一下<code class="fe oe of og mq b">profile</code>装饰器的不同参数，看看输出会如何变化。你可以在这个<a class="ae kv" href="https://github.com/ekhoda/profile_decorator" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中找到完整的例子。</p><p id="252c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">快乐剖析！</p></div><div class="ab cl os ot hu ou" role="separator"><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox"/></div><div class="ij ik il im in"><p id="845a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望这篇博客对你有用。我可以在<a class="ae kv" href="https://twitter.com/EhsanKhoda" rel="noopener ugc nofollow" target="_blank"><em class="na">Twitter</em></a><em class="na">和</em><a class="ae kv" href="https://www.linkedin.com/in/ehsankhodabandeh" rel="noopener ugc nofollow" target="_blank"><em class="na">LinkedIn</em></a><em class="na">上联系，我欢迎任何反馈。</em></p></div></div>    
</body>
</html>