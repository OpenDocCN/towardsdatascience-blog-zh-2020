<html>
<head>
<title>Should you Buy or Lease your Next Car? End-to-End Project</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你应该买还是租下一辆车？端到端项目</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/should-you-buy-or-lease-your-next-car-end-to-end-data-science-project-a26617f11fcb?source=collection_archive---------43-----------------------#2020-06-11">https://towardsdatascience.com/should-you-buy-or-lease-your-next-car-end-to-end-data-science-project-a26617f11fcb?source=collection_archive---------43-----------------------#2020-06-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="86f3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">探索这个项目，从收集数据到创建强回归的集合，再到回答你是否应该购买或租赁下一辆车</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c86b270159ed47d705d61130235eb8f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rQMJVAy-LRPVYYR3i-1ucg.png"/></div></div></figure><h1 id="bedb" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">概观</h1><p id="0aa3" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在本帖中，我们将从头到尾浏览一个完整的数据科学项目，并给出问题的结论——你应该购买还是租赁下一辆车？</p><p id="0985" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">该项目将包括以下部分(请随意跳到您最感兴趣的部分):</p><ul class=""><li id="51cd" class="mn mo it lo b lp mi ls mj lv mp lz mq md mr mh ms mt mu mv bi translated">把问题框起来，看大局</li><li id="9e7b" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">获取数据</li><li id="8238" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">探索数据</li><li id="d2d2" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">准备数据</li><li id="a1e2" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">选择和训练模型</li><li id="d41a" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">微调系统</li><li id="cf27" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">分析最佳模型的误差</li><li id="97ac" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">结论</li></ul><p id="d6a7" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">要在 Github 上查看该项目，请点击以下链接<a class="ae nb" href="https://github.com/lukenew2/automobile-depreciation/tree/master/leases" rel="noopener ugc nofollow" target="_blank">此处</a>！</p><h1 id="439b" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">把问题框起来，看大局</h1><p id="c613" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">这个项目的目标是通过比较汽车租赁的总费用和汽车的折旧成本来确定汽车租赁是否划算。如果租赁费用更高，我们可以得出结论，购买新车并转卖会更符合 T2 的成本效益。然而，如果租赁比我们认为的便宜，你应该租赁而不是购买。</p><p id="0b9e" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">通过使用机器学习，我们预测汽车的价格，并使用它来计算折旧成本，并与租赁成本进行比较。</p><p id="e8d6" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我们使用的指标是均方根误差(RMSE ),因为它给出了系统在预测中通常会产生多大误差的概念，误差越大，权重越高。</p><p id="cbf5" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">所以现在我们需要数据。我们没有收集数百辆不同汽车的数据，而是只收集了一辆最好的出租汽车——讴歌 TLX 的数据。这有助于我们简化问题，如果我们得出结论，你应该购买而不是租赁这辆车，我们可以得出同样的结论较低的汽车。</p><h1 id="d229" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">获取数据</h1><p id="48dc" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在这个项目中，我们使用 BeautifulSoup 的图书馆收集数据。我们在网上搜索 Truecar.com 的讴歌 TLX 汽车列表。笔记本完整的代码用于网页抓取可以在<a class="ae nb" href="https://github.com/lukenew2/car-leases/blob/master/collect_data_webscraping.ipynb" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="a501" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">该项目的其余部分的代码可以在这里查看<a class="ae nb" href="https://github.com/lukenew2/car-leases/blob/master/buy_or_lease.ipynb" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="9011" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">让我们加载通过网络搜集收集的数据，并对其进行初步研究。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="c1ed" class="ni kv it ne b gy nj nk l nl nm">CARS_PATH = os.path.join(PROJECT_ROOT_DIR, "datasets")<br/><br/><strong class="ne iu">def</strong> load_car_data(cars_path=CARS_PATH):<br/>    csv_path = os.path.join(cars_path, "cars.csv")<br/>    <strong class="ne iu">return</strong> pd.read_csv(csv_path)</span><span id="737f" class="ni kv it ne b gy nn nk l nl nm">cars = load_car_data()</span></pre><p id="b36e" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">让我们看看我们的数据集有多完整。通过查看每一列的 null 值的百分比，我们可以很好地了解我们正在处理的缺失值的数量。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="cb2e" class="ni kv it ne b gy nj nk l nl nm">cars.isnull().sum() / len(cars)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/73deb56aa110b604f28ef1fdd291681f.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/format:webp/1*CaEm38WcT8KKtziXiYeBMQ.png"/></div><p class="np nq gj gh gi nr ns bd b be z dk translated">每列的百分比 Null</p></figure><p id="bfb4" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我们看到在我们的 6 列中有缺失值。具体在我们的目标变量<strong class="lo iu">价格</strong>和属性<strong class="lo iu">驱动、发动机、内饰、外观颜色、</strong>和<strong class="lo iu">内饰颜色。由于价格是我们的目标变量，我们将不得不放弃这些实例。由于 Drive、Engine 和 Trim 的缺失值百分比非常低，因此也可以删除与这些实例相关的实例。由于外部和内部颜色超过 10%为空，可能对价格没有太大的预测能力，我们将继续从数据集中删除这些列。</strong></p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="9b03" class="ni kv it ne b gy nj nk l nl nm">cars = cars.drop(columns=["Exterior_color", "Interior_color"])<br/>cars = cars.dropna(axis=0)<br/>cars.reset_index(inplace=<strong class="ne iu">True</strong>)</span></pre><h2 id="9e30" class="ni kv it bd kw nt nu dn la nv nw dp le lv nx ny lg lz nz oa li md ob oc lk od bi translated">创建测试集</h2><p id="37db" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我们在这里使用<em class="nc">分层分割</em>来确保我们的测试集代表整个数据集中的各种比率。由于我们相信某些特征(如汽车年份)将是非常重要的价格预测因素，因此我们确保它们在训练集和测试集之间均匀分布。通过使用分层分割，我们避免了抽样偏差，即测试不能代表整个数据集。</p><p id="4690" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">下面的代码使用 pd.cut()函数创建一个包含 6 个类别的 year category 属性(标记为 0 到 5，对应于数据集中的每一年):</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="837f" class="ni kv it ne b gy nj nk l nl nm">cars["Year_cat"] = pd.cut(cars["Year"],                            bins=[2014.5, 2015.5, 2016.5, 2017.5, 2018.5, 2019.5, 2020.5],                          labels=[0, 1, 2, 3, 4, 5]</span></pre><p id="8b70" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">现在我们准备根据 year 属性进行分层抽样。为此，我们可以使用 Scikit-Learn 的 StratifiedShuffleSplit()类:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="b505" class="ni kv it ne b gy nj nk l nl nm"><strong class="ne iu">from</strong> sklearn.model_selection <strong class="ne iu">import</strong> StratifiedShuffleSplit<br/><br/>split = StratifiedShuffleSplit(n_splits=1, test_size=0.2)<br/><strong class="ne iu">for</strong> train_index, test_index <strong class="ne iu">in</strong> split.split(cars, cars["Year_cat"]):<br/>    train_set = cars.loc[train_index]<br/>    test_set = cars.loc[test_index]</span></pre><p id="ebef" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">现在，我们删除 Year_cat 属性，使数据恢复到原始状态:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="3cd4" class="ni kv it ne b gy nj nk l nl nm"><strong class="ne iu">for</strong> set_ <strong class="ne iu">in</strong> (test_set, train_set):<br/>    set_.drop("Year_cat", axis=1, inplace=<strong class="ne iu">True</strong>)</span></pre><h1 id="f450" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">探索数据</h1><p id="f2be" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">现在，让我们发现并可视化这些数据，感受一下它的样子并获得一些见解。我们创建了一个训练集的副本，这样我们就可以在不破坏原始训练集的情况下使用它:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="39ae" class="ni kv it ne b gy nj nk l nl nm">cars = train_set.copy()</span></pre><p id="9cb4" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">下面是一个表，其中包含列、数据类型和详细描述它们包含哪些信息的简短描述。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/e144a1f4b5f91ccd2c1a6a41d7656145.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*milgeOAW5fDtXsMyXKrhUw.png"/></div></div></figure><p id="543c" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我们将首先查看数字数据类型，并使用 corr()方法计算每对属性之间的标准相关系数:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="a35a" class="ni kv it ne b gy nj nk l nl nm">corr_matrix = cars.corr()</span></pre><p id="f890" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">现在让我们看看每个属性与价格的关联程度:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="44c0" class="ni kv it ne b gy nj nk l nl nm">corr_matrix["Price"].sort_values(ascending=<strong class="ne iu">False</strong>)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/8546db87b56130433781c183602c17cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*Xq5k0o8oyqWoG5BQG8SgZw.png"/></div></figure><p id="2749" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">检查属性之间相关性的另一种方法是使用 pandas scatter_matrix()函数，该函数将每个数值属性与其他数值属性相对照。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="cfe2" class="ni kv it ne b gy nj nk l nl nm"><strong class="ne iu">from</strong> pandas.plotting <strong class="ne iu">import</strong> scatter_matrix<br/><br/>attributes = ["Price", "Year", "Mileage", "Accidents"]<br/>scatter_matrix(cars[attributes], figsize=(12,8))<br/>save_fig("scatter_matrix_plot")</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/e2a1d96078df42be9e4931a5b47c9452.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MmyQI0kkI8AaxTNYp1Izhg.png"/></div></div></figure><p id="6d58" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">上图向我们展示了一些东西。事实上，年份和里程属性将是价格的强预测因素，并显示一些交互作用，我们可以通过创建一个新的功能，每年的里程来捕捉这些交互作用。此外，三起事故并不多见。将发生 2 次或 3 次事故的汽车归入一个 2 或更多的值可能是有益的。</p><p id="7c2e" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">要创建每年英里数属性，我们需要知道汽车的使用年限，而不是年份。我们通过从汽车年份中减去当前年份的绝对值来实现这一点。但是，我们无法将 2020 款讴歌 TLXs 除以 0，因此我们将 0 替换为 1(在这种情况下，属性 miles_per_year 将与 miles 相同)。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="4e89" class="ni kv it ne b gy nj nk l nl nm">cars["Years_old"] = abs(cars["Year"] - 2020)<br/>cars["Miles_per_year"] = cars["Mileage"] / <br/>                                     cars["Years_old"].replace(0, 1)                                     </span></pre><p id="eaa3" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">现在让我们看看我们的目标价格与新属性的相关性:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="9303" class="ni kv it ne b gy nj nk l nl nm">corr_matrix = cars.corr()<br/>corr_matrix["Price"].sort_values(ascending=<strong class="ne iu">False</strong>)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/48b44ae452f493dde4e73d70d29eb7ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*FOXeuyArWQRIejnegaengw.png"/></div></figure><p id="3bc7" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">太好了！我们发现它也与价格密切相关！</p><p id="993c" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我想看的最后一个有趣的专栏是 Trim。该列包含许多信息，包括汽车上的性能套件类型。提取包并把它作为一个属性使用可能是有益的。让我们观察不同的 trims 和中间价格之间的相关性。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="9b70" class="ni kv it ne b gy nj nk l nl nm">cars[["Price","Trim"]].groupby("Trim").median()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/d3ff6ba5c4e3c6067f386731babb9ed0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F76tkdViyrbHdtHBHs0NhA.png"/></div></div></figure><p id="a4af" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">现在让我们提取包，看看包之间是否有明显的相关性。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="2129" class="ni kv it ne b gy nj nk l nl nm"><strong class="ne iu">def</strong> extract_package(trims):<br/>    <br/>    packages = ["PMC Edition", "A-Spec", "Advance", "Technology"]<br/><br/>    pat = '|'.join(r"\b<strong class="ne iu">{}</strong>\b".format(x) <strong class="ne iu">for</strong> x <strong class="ne iu">in</strong> packages)<br/>    packages = pd.Series(trims).str.extract("(" + pat + ")")<br/>    packages.fillna("Standard", inplace=<strong class="ne iu">True</strong>)<br/>    <br/>    <strong class="ne iu">return</strong> packages</span><span id="8bba" class="ni kv it ne b gy nn nk l nl nm">cars["Package"] = extract_package(cars["Trim"].values)</span><span id="6fdb" class="ni kv it ne b gy nn nk l nl nm">cars[["Price", "Package"]].groupby("Package").median()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/7d7bf99a2178a9a14a28e64039df1903.png" data-original-src="https://miro.medium.com/v2/resize:fit:612/format:webp/1*EU4fcRBkr-xpj0sYDxcGmA.png"/></div></figure><p id="5d6f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">解压软件包似乎没有太大的帮助。不同包装之间的相关性很弱，不符合我们预期的任何趋势。</p><h2 id="ef9b" class="ni kv it bd kw nt nu dn la nv nw dp le lv nx ny lg lz nz oa li md ob oc lk od bi translated">摘要</h2><p id="3fca" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">现在我们对哪些特性是最有价值的有了一个很好的想法，并且探索了它们之间的关系。一些重要的发现是:</p><ul class=""><li id="d776" class="mn mo it lo b lp mi ls mj lv mp lz mq md mr mh ms mt mu mv bi translated">创建新列<code class="fe ok ol om ne b">miles_per_year</code>增加了额外的预测能力。</li><li id="7af3" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">发生 2 起以上事故的汽车在我们的数据集中非常稀少，最好与发生 2 起事故的汽车归为一组。我们通过这种方式保持了更强的相关性。</li><li id="c4ae" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">年份更适合用作序数特征。我们将减去该列的当前年份，以创建一个名为“years old”的列。</li><li id="d828" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">从 trim 中提取性能包可能有用，也可能没用。与价格没有明显的相关性，因此我们可以在数据准备阶段将它作为一个选项添加进来。</li></ul><h1 id="ffb7" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">准备数据</h1><p id="32d1" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">是时候为机器学习算法准备数据了。我们没有手动这样做，而是为此编写函数，这有几个原因:</p><ul class=""><li id="b3ea" class="mn mo it lo b lp mi ls mj lv mp lz mq md mr mh ms mt mu mv bi translated">这将允许我们在任何数据集上重现这些转换(例如，下次您获得新的数据集时)。</li><li id="b3a6" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">我们将逐步建立一个转换函数库，可以在未来的项目中重用。</li><li id="b2d0" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">这将使我们能够轻松地尝试各种转换，并查看哪种转换组合效果最好。</li></ul><p id="6d45" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我们需要一个数字属性和分类属性的准备管道。先说数值属性吧！</p><p id="f4f2" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">由于我们使用的是 Scikit-Learn，所以我们希望我们的转换器能够与 Scikit-Learn 功能(比如管道)无缝协作，但幸运的是，我们只需要创建一个类并实现三个方法:fit()(返回 self)、transform()和 fit_transform()。我们只需添加<em class="nc"> TransformerMixin </em>作为基类，就可以免费获得最后一个。</p><blockquote class="on oo op"><p id="019a" class="lm ln nc lo b lp mi ju lr ls mj jx lu oq mk lx ly or ml mb mc os mm mf mg mh im bi translated">我们还添加了<em class="it"> BaseEstimator </em>作为基类，为我们提供了两个额外的方法(get_params()和 set_params())，这对自动超参数调优很有用。</p></blockquote><p id="6330" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">例如，这里有一个 transformer 类，它添加了前面讨论过的数字属性，并在我们将训练集传递给它时添加了它的输出。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="162d" class="ni kv it ne b gy nj nk l nl nm"><strong class="ne iu">from</strong> sklearn.base <strong class="ne iu">import</strong> BaseEstimator, TransformerMixin<br/><br/><strong class="ne iu">class</strong> <strong class="ne iu">NumericalAttributesAdder</strong>(BaseEstimator, TransformerMixin):<br/>    <strong class="ne iu">def</strong> __init__(self, add_miles_per_year = <strong class="ne iu">True</strong>):<br/>        self.add_miles_per_year = add_miles_per_year<br/>    <strong class="ne iu">def</strong> fit(self, X, y=<strong class="ne iu">None</strong>):<br/>        <strong class="ne iu">return</strong> self<br/>    <strong class="ne iu">def</strong> transform(self, X):<br/>        years_old = abs(X["Year"] - 2020)<br/>        accidents_adjusted = X["Accidents"].replace(3, 2)<br/>        <strong class="ne iu">if</strong> self.add_miles_per_year:<br/>            miles_per_year = X["Mileage"] / years_old.replace(0, 1)<br/>            <strong class="ne iu">return</strong> pd.concat([X, years_old.rename("Years_old"),  <br/>                         accidents_adjusted.rename("Accidents_adj"),                        <br/>                         miles_per_year.rename("Miles_per_year")],   <br/>                         axis=1)</span><span id="b5f8" class="ni kv it ne b gy nn nk l nl nm"><strong class="ne iu">        else</strong>:<br/>            <strong class="ne iu">return</strong> pd.concat([X, years_old.rename("Years_old"),<br/>                        accidents_adjusted.rename("Accidents_adj")],         <br/>                        axis=1)<br/>        <br/>num_attr_adder = NumericalAttributesAdder(add_miles_per_year = <strong class="ne iu">True</strong>)<br/>num_attr_adder.transform(X_train)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/ce1aa4d1678432bded683aea6002a666.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rpq4wHYJABO8Hl5ohQ45cg.png"/></div></div></figure><p id="1184" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">现在，在我们添加新的属性之后，我们想要选择在我们的机器学习算法中使用哪些属性。我们使用与上面相同的方法来创建一个选择属性的自定义转换器。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="24d6" class="ni kv it ne b gy nj nk l nl nm"><strong class="ne iu">class</strong> <strong class="ne iu">DataFrameSelector</strong>(BaseEstimator, TransformerMixin):<br/>    <strong class="ne iu">def</strong> __init__(self, attribute_indices):<br/>        self.attribute_indices = attribute_indices<br/>    <strong class="ne iu">def</strong> fit(self, X, y=<strong class="ne iu">None</strong>):<br/>        <strong class="ne iu">return</strong> self<br/>    <strong class="ne iu">def</strong> transform(self, X):<br/>        <strong class="ne iu">return</strong> X[self.attribute_indices]</span></pre><p id="59fa" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">如您所见，有许多数据转换步骤需要按正确的顺序执行。幸运的是，Scikit-Learn 提供了 Pipeline 类来帮助处理转换序列。下面是数字属性的管道:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="6d3e" class="ni kv it ne b gy nj nk l nl nm"><strong class="ne iu">from</strong> sklearn.pipeline <strong class="ne iu">import</strong> Pipeline<br/><strong class="ne iu">from</strong> sklearn.preprocessing <strong class="ne iu">import</strong> StandardScaler</span><span id="0de0" class="ni kv it ne b gy nn nk l nl nm">attribs = ["Mileage", "Years_old", "Accidents_adj","Miles_per_year"]</span><span id="fa48" class="ni kv it ne b gy nn nk l nl nm">num_pipeline = Pipeline([<br/>        ('num_attribs_adder', NumericalAttributesAdder()),<br/>        ('select_numeric', DataFrameSelector(attribs)),<br/>        ('std_scaler', StandardScaler())<br/>    ])</span></pre><p id="2e3b" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我们使用上面的两个自定义转换器，然后使用 Scikit-Learn 的 StandardScaler()转换器来标准化所有数字属性。</p><p id="ab30" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">现在下一步是为我们的分类属性创建一个管道。由于这些属性是字符串，我们需要使用 OneHotEncoder 将它们转换成数值。但是首先我们创建一个定制的转换器，它将从我们前面讨论的 Trim 属性中提取汽车的包。我们初始化<em class="nc"> add_trim_features=True </em>,让我们选择是否添加新的包属性。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="d9b8" class="ni kv it ne b gy nj nk l nl nm"><strong class="ne iu">class</strong> <strong class="ne iu">CategoricalAttributesAdder</strong>(BaseEstimator, TransformerMixin):<br/>    <strong class="ne iu">def</strong> __init__(self, add_trim_features = <strong class="ne iu">True</strong>):<br/>        self.add_trim_features = add_trim_features  <br/>    <strong class="ne iu">def</strong> fit(self, X, y=<strong class="ne iu">None</strong>):                          <br/>        <strong class="ne iu">return</strong> self    <br/>    <strong class="ne iu">def</strong> transform(self, X):        <br/>        <strong class="ne iu">if</strong> self.add_trim_features:<br/>            package = extract_package(X["Trim"]) <br/>            <strong class="ne iu">return</strong> pd.concat([X, package.rename("Package")], axis=1)                                <br/>        <strong class="ne iu">else</strong>:            <br/>            <strong class="ne iu">return</strong> X         </span><span id="736f" class="ni kv it ne b gy nn nk l nl nm">cat_attr_adder = CategoricalAttributesAdder(add_trim_features =<strong class="ne iu">True</strong>)</span><span id="2c59" class="ni kv it ne b gy nn nk l nl nm">cat_attr_adder.transform(X_train)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/bd4c6a94e79e64a7826a11864d1db5f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qxMdBmB3BYUsAMaEvVN8fw.png"/></div></div></figure><p id="be7f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">现在，我们分类属性的完整管道已经准备好了。我们使用 CategoricalAttributesAdder、DataFrameSelector 和 OneHotEncoder 将我们的分类属性完全转换为适合机器学习的格式。管道如下所示:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="1b7c" class="ni kv it ne b gy nj nk l nl nm">attribs = ["Drive", "Engine", "Trim"]</span><span id="2fab" class="ni kv it ne b gy nn nk l nl nm">cat_pipeline = Pipeline([<br/>        ("cat_attribs_adder", CategoricalAttributesAdder()),<br/>        ("select_categoric", DataFrameSelector(attribs)),<br/>        ("one_hot", OneHotEncoder())<br/>    ])</span></pre><p id="d861" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">到目前为止，我们已经分别处理了分类列和数字列。如果有一个能够处理所有列的转换器，对每一列应用适当的转换，那将会更方便。幸运的是，Scikit-Learn 为此引入了<em class="nc"> ColumnTransformer </em>，好消息是它对熊猫数据帧非常有效。让我们使用它将所有转换应用到训练集:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="65d5" class="ni kv it ne b gy nj nk l nl nm"><strong class="ne iu">from</strong> sklearn.compose <strong class="ne iu">import</strong> ColumnTransformer</span><span id="6b0e" class="ni kv it ne b gy nn nk l nl nm">num_attribs = ["Year", "Mileage", "Accidents"]<br/>cat_attribs = ["Drive", "Engine", "Trim"]</span><span id="048c" class="ni kv it ne b gy nn nk l nl nm">full_pipeline = ColumnTransformer([<br/>        ("num", num_pipeline, num_attribs),<br/>        ("cat", cat_pipeline, cat_attribs)<br/>    ])<br/><br/>cars_prepared = full_pipeline.fit_transform(X_train)</span></pre><p id="672f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在这个管道中，我们指定数字列应该使用我们之前定义的<em class="nc"> num_pipeline </em>进行转换，而分类列应该使用我们之前定义的<em class="nc"> cat_pipeline </em>进行转换。最后，我们将这个<em class="nc"> ColumnTransformer </em>应用于训练集:它将每个转换器应用于适当的列，并沿着第二个轴连接输出(转换器必须返回相同数量的行)。</p><p id="458b" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">就是这样！我们有一个预处理管道，它接受完整的训练集，并对每一列应用适当的转换。</p><h1 id="24b0" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">选择和训练模型</h1><p id="c370" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">终于来了！我们构建了问题，获得了数据并对其进行了探索，对一个训练集和一个测试集进行了采样，我们编写了转换管道来自动清理和准备我们的数据以用于机器学习算法。我们现在准备选择和训练机器学习模型。</p><p id="640d" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我们的第一个基本模型是一个线性回归，我们将尝试改进它。使用 Scikit-Learn 的 cross_val_score()允许我们将训练集随机分成 10 个不同的折叠，然后训练和评估我们的模型 10 次，每次选择不同的折叠进行评估，并在其他 9 个折叠上进行训练。结果是一个包含 10 个评估分数的数组:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="b539" class="ni kv it ne b gy nj nk l nl nm"><strong class="ne iu">from</strong> sklearn.linear_model <strong class="ne iu">import</strong> LinearRegression <br/><strong class="ne iu">from</strong> sklearn.model_selection <strong class="ne iu">import</strong> cross_val_score </span><span id="a67c" class="ni kv it ne b gy nn nk l nl nm">lin_reg = LinearRegression()<br/>lin_reg_scores = np.sqrt(-cross_val_score(lin_reg, cars_prepared,   <br/>                  y_train, cv=10, scoring="neg_mean_squared_error"))</span></pre><p id="dc1b" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">让我们来看看结果:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="035d" class="ni kv it ne b gy nj nk l nl nm"><strong class="ne iu">def</strong> display_scores(scores):<br/>    print("Scores:", scores)    <br/>    print("Mean:", scores.mean())<br/>    print("Standard deviation:", scores.std()) </span><span id="f189" class="ni kv it ne b gy nn nk l nl nm">display_scores(lin_reg_scores)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/a70b8548f7d03f5bea3bc6f395c45e9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ELzFtkn0Zy849w2ZdEkFMA.png"/></div></div></figure><p id="a202" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">对我们的基本模型来说还不错！但是，我们不是像这样显示每个模型的分数，而是将每个模型的分数绘制在一个方框图中，显示平均值、四分位间距和最大/最小分数。请记住，我们的衡量标准是 RMSE，分数越低越好。以下是我们尝试的模型列表:</p><ul class=""><li id="b1a3" class="mn mo it lo b lp mi ls mj lv mp lz mq md mr mh ms mt mu mv bi translated">线性回归</li><li id="c3c9" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">多项式回归</li><li id="2657" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">岭正则化多项式回归</li><li id="6f39" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">随机森林回归量</li><li id="0212" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">支持向量机回归机</li><li id="4044" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">梯度推进回归器</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/ecd3048cc1a466eebaf06be8e138a8be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VOLptutEa0kcBPQ18u0F-Q.png"/></div></div></figure><p id="5fa0" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我们看到多项式回归比简单的线性回归稍好。此外，随机森林回归和梯度推进回归表现明显较好，而 SVM 回归表现明显较差。请记住，我们只是试图了解哪些机器学习算法执行得最好，因此所有这些算法都是用默认设置训练的。</p><h1 id="01e4" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">微调你的系统</h1><p id="0240" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">现在我们有了一份有前途的模特候选名单。我们现在需要对它们进行微调。由于我们使用默认超参数来训练我们的模型，我们将尝试看看哪个超参数最适合我们的最佳模型，随机森林回归器和梯度推进回归器。</p><p id="33fc" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我们没有手动这样做，而是让 Scikit-Learn 的<em class="nc"> GridSearchCV </em>来搜索我们。我们需要做的只是告诉它我们希望它试验哪些超参数，试验哪些值，它将使用交叉验证来评估超参数值的所有可能组合。</p><h2 id="f465" class="ni kv it bd kw nt nu dn la nv nw dp le lv nx ny lg lz nz oa li md ob oc lk od bi translated">随机森林回归量</h2><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="6a6c" class="ni kv it ne b gy nj nk l nl nm"><strong class="ne iu">from</strong> <strong class="ne iu">sklearn.model_selection</strong> <strong class="ne iu">import</strong> GridSearchCV<br/><br/>forest_param_grid = [{'bootstrap': [<strong class="ne iu">True</strong>],<br/>     'max_depth': [12, 14, <strong class="ne iu">None</strong>],<br/>     'max_features': ['auto', 'sqrt'],<br/>     'min_samples_leaf': [1, 2],<br/>     'min_samples_split': [ 2, 3],<br/>     'n_estimators': [100, 200, 300, 400]}<br/>    ]<br/><br/>forest_reg = RandomForestRegressor()<br/><br/>forest_grid_search = GridSearchCV(forest_reg, forest_param_grid, <br/>                                  cv=5,      <br/>                                  scoring="neg_mean_squared_error",<br/>                                  return_train_score=<strong class="ne iu">True</strong>,<br/>                                  verbose=<strong class="ne iu">True</strong>,<br/>                                  n_jobs=-1)<br/><br/>forest_grid_search.fit(cars_prepared, y_train)</span></pre><p id="b048" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我们可以直接得到最佳估计量:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="0503" class="ni kv it ne b gy nj nk l nl nm">forest_grid_search.best_estimator_</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/ff2a9e8a81c8493fa72c8cd036990984.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tjX_O3yxsyZemV3JWsuhDw.png"/></div></div></figure><h2 id="586c" class="ni kv it bd kw nt nu dn la nv nw dp le lv nx ny lg lz nz oa li md ob oc lk od bi translated">梯度推进回归器</h2><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="cb48" class="ni kv it ne b gy nj nk l nl nm">gb_param_grid = [{'loss': ['ls'],<br/>         'learning_rate': [0.05, 0.1, 0.15],<br/>         'n_estimators': [200, 220, 240, 260],<br/>         'subsample': [0.8, 0.9],<br/>         'min_samples_split': [2, 3],<br/>         'min_samples_leaf': [2, 3, 4],<br/>         'max_depth': [4, 5, 6, 7],<br/>         'max_features': ['sqrt'],<br/>        }]<br/><br/>gb_reg = GradientBoostingRegressor()<br/><br/>gb_grid_search = GridSearchCV(gb_reg, gb_param_grid, cv=5,<br/>                                  scoring="neg_mean_squared_error",<br/>                                  return_train_score=<strong class="ne iu">True</strong>,<br/>                                  verbose=<strong class="ne iu">True</strong>,<br/>                                  n_jobs=-1)<br/><br/>gb_grid_search.fit(cars_prepared, y_train)</span></pre><p id="b5fa" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">让我们看看最佳估计值:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="5319" class="ni kv it ne b gy nj nk l nl nm">gb_grid_search.best_estimator_</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/6b21ef44531765876dc72347305c14c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0eruJyFFiVpr9EuWCE6hTg.png"/></div></div></figure><h2 id="dc36" class="ni kv it bd kw nt nu dn la nv nw dp le lv nx ny lg lz nz oa li md ob oc lk od bi translated">集合:随机森林回归和梯度推进回归</h2><p id="8874" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">另一种微调系统的方法是尝试并组合性能最佳的模型。群体(或“整体”)通常会比最佳个体模型表现得更好。现在，我们已经调整了两个最佳模型的超参数，让我们尝试将它们结合起来，以进一步提高我们的最佳得分。</p><p id="ae94" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">使用 Scikit-Learn 的 VotingRegressor()类可以相对容易地做到这一点，该类允许我们对随机森林回归变量和梯度推进回归变量进行平均预测。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="7b89" class="ni kv it ne b gy nj nk l nl nm"><strong class="ne iu">from</strong> sklearn.ensemble <strong class="ne iu">import</strong> VotingRegressor<br/><br/>forest_reg =RandomForestRegressor(**forest_grid_search.best_params_)<br/>gb_reg = GradientBoostingRegressor(**gb_grid_search.best_params_)<br/><br/>forest_gb_reg = VotingRegressor([("forest_reg", forest_reg), <br/>                                 ("gb_reg", gb_reg)])</span><span id="490c" class="ni kv it ne b gy nn nk l nl nm">forest_gb_reg_scores = np.sqrt(-cross_val_score(forest_gb_reg, <br/>                               cars_prepared, y_train, cv=10,<br/>                               scoring="neg_mean_squared_error"))</span><span id="5ad2" class="ni kv it ne b gy nn nk l nl nm">display_scores(forest_gb_reg_scores)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/817c3960a7bdaf9cbfc13a2c51fb7c59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dl72XmHuaVNTSmVq0iN3BQ.png"/></div></div></figure><p id="8b56" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">看，成功了！我们的平均 RMSE 低于 1600！现在我们有了最好的模型，是时候分析它的错误了。但首先让我们做最后一个方框图，比较四个最好的模型。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/3e5d0a5cdc78e0668b8b83fc645c2836.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NBKDRAiwH1liPZlB0l74uA.png"/></div></div></figure><p id="a855" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">让我们保存最好的模型，以便我们可以很容易地回到他们当中的任何一个！</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="e2e0" class="ni kv it ne b gy nj nk l nl nm"><strong class="ne iu">import</strong> <strong class="ne iu">joblib</strong><br/><br/>MODELS_PATH = os.path.join(PROJECT_ROOT_DIR, "models/")<br/>os.makedirs(MODELS_PATH, exist_ok=<strong class="ne iu">True</strong>)</span><span id="d54f" class="ni kv it ne b gy nn nk l nl nm">models = [gb_grid_search.best_estimator_,<br/>          forest_grid_search.best_estimator_,<br/>          forest_gb_reg]<br/>names = ["gradient_boosting_reg", "forest_reg","ensemble_(RF_&amp;_GB)"]</span><span id="7ca8" class="ni kv it ne b gy nn nk l nl nm"><strong class="ne iu">for</strong> model, name <strong class="ne iu">in</strong> zip(models, names):<br/>    joblib.dump(model, MODELS_PATH + name)</span></pre><h1 id="eeb5" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">分析最佳模型的误差</h1><p id="caa0" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我们将使用 cross_val_predict 对我们的训练集中的每个实例进行干净的预测(“干净”意味着预测是由在训练期间从未看到数据的模型进行的)。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="2907" class="ni kv it ne b gy nj nk l nl nm"><strong class="ne iu">from </strong>sklearn.model_selection <strong class="ne iu">import</strong> cross_val_predict<br/><br/>preds = cross_val_predict(forest_gb_reg,cars_prepared,y_train,cv=10) </span></pre><p id="fa1e" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">让我们把我们的预测价格和实际价格对比一下。如果我们所有的点都在对角线上，这意味着我们的模型是完美的，误差为 0。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/8f2067ce3073058412ecaa5d7d463921.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a9kn4tCIwQynlGwWXzixjA.png"/></div></div></figure><p id="2f88" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这看起来很好，我们的误差正态分布，而不是一个区域漏低，另一个区域漏高。剩下的工作就是对测试集进行评估，并得到最终的性能检查。谢天谢地，使用我们之前创建的管道，测试集很容易准备！</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="94f9" class="ni kv it ne b gy nj nk l nl nm">X_test = test_set.drop("Price", axis=1)<br/>y_test = test_set["Price"].copy()<br/>X_test = X_test[cols]<br/>X_test_prepared = full_pipeline.fit_transform(X_test)</span><span id="e4fe" class="ni kv it ne b gy nn nk l nl nm"><strong class="ne iu">from</strong> sklearn.metrics <strong class="ne iu">import</strong> mean_squared_error<br/><br/>final_predictions = forest_gb_reg.predict(X_test_prepared)<br/>final_mse = mean_squared_error(y_test, final_predictions)<br/>final_rmse = np.sqrt(final_mse)<br/>final_rmse</span></pre><p id="97c1" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">最终 RMSE: 2207.82</p><p id="a477" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">看起来我们的训练装备可能有点过量了。回过头来尝试在测试集上表现得更好可能很有诱惑力，但是这样我们就冒着过度适应测试集的风险。我们会让它保持原样，因为它仍然在我们在训练集中得到的分数范围内。</p><h1 id="e798" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">结论</h1><p id="0ea8" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">现在回到最初的问题。你应该买还是租下一辆车？</p><p id="70ad" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">现在，我们已经有了最终的模型和测试集的性能分数，我们可以用它来预测讴歌 TLXs 的价格，其功能对应于各种租赁。我们用来对比的租约来自讴歌的网站。让我们看看多个不同的租赁条款，看看我们会发现什么！</p><p id="ad55" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我们预测的汽车具有以下特征和租赁:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/b7c2a3413e753d8203ccc107d5fe8a24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*89vsPF3cTnfop4gYYI7rNg.png"/></div></div></figure><p id="5414" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这里是三种不同调整的预计折旧成本和租赁比较。红线代表预计折旧成本，而蓝线代表租赁成本。阴影区域代表我们预测折旧的 95%置信区间。我们看到，在所有三种情况下，租赁都要贵得多。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/362d5c7739203c0843fb356ab0a5ab01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OZbxy_2fVe2TKWYdu3l-SA.png"/></div></div></figure><p id="64df" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">如果你选择购买新车，你可以节省高达 10，000 美元。即使是最好的汽车之一，租赁也要贵得多。</p><h1 id="ea54" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">未来的工作</h1><p id="6966" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">项目结束后，我脑海中突然冒出了一些我认为会很有趣的想法:</p><ul class=""><li id="1060" class="mn mo it lo b lp mi ls mj lv mp lz mq md mr mh ms mt mu mv bi translated">我们可以模拟不同的汽车，这些汽车也有很高的租赁费率，看看你能为一辆新车提供多少资金，让它仍然值得购买和转售。</li><li id="2803" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">从交叉验证来看，集成似乎是有益的，但在测试集上的表现仍然很差。探索原因可能会很有趣。我想知道是否所有其他模型在测试集上表现更差，或者我们的最终模型实际上不是最佳选择，尽管在交叉验证的所有折叠中表现最好。</li><li id="4e4a" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">进一步考虑这个问题，尝试建立多个汽车品牌和模型的模型，这些模型仍然可以准确预测汽车的价值。</li></ul><p id="3f01" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">一如既往地感谢你的阅读，我希望你喜欢它，并学到一些新的和有见地的东西！</p><div class="pc pd gp gr pe pf"><a href="https://github.com/lukenew2/car-leases" rel="noopener  ugc nofollow" target="_blank"><div class="pg ab fo"><div class="ph ab pi cl cj pj"><h2 class="bd iu gy z fp pk fr fs pl fu fw is bi translated">路金 2/汽车租赁</h2><div class="pm l"><h3 class="bd b gy z fp pk fr fs pl fu fw dk translated">在这个项目中，我的目标是通过比较汽车的折旧成本来确定汽车租赁是否划算</h3></div><div class="pn l"><p class="bd b dl z fp pk fr fs pl fu fw dk translated">github.com</p></div></div><div class="po l"><div class="pp l pq pr ps po pt ks pf"/></div></div></a></div></div></div>    
</body>
</html>