<html>
<head>
<title>Recursion in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的递归</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/recursion-in-python-b026d7dde906?source=collection_archive---------32-----------------------#2020-03-30">https://towardsdatascience.com/recursion-in-python-b026d7dde906?source=collection_archive---------32-----------------------#2020-03-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a6ff" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">理解Python中的递归</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c0efc75a09a523ac08918cfbbd12c255.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6KCB3rG4xxP7_iwZzZVxbA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://www.pexels.com/photo/apple-blank-business-computer-442574/" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="68ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在计算机科学中，递归是一种使用同一问题的较小解来寻找问题的解决方案的方法。递归算法在列表排序、二叉树遍历、路径查找等等方面都有应用。在本帖中，我们将讨论一个用于寻找自然数阶乘的经典递归过程。</p><p id="59c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们开始吧！</p><p id="ebdb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们将编写一个算法来寻找阶乘，所以有必要回顾一下阶乘的定义。自然数的阶乘，<em class="lv"> n </em>，是所有小于或等于<em class="lv"> n </em>的自然数的乘积:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lw"><img src="../Images/300b243fe441de373d4bcb0c2bc8c007.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qedX0b_1y6A74-Kb1SJjCw.png"/></div></div></figure><p id="16ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果<em class="lv"> n </em> =6:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/e8f29927f25f7f7b9bb0e6eb4c7b4342.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*x28NBOMV1o1wyfbLOOC6jg.png"/></div></figure><p id="91c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们递归地思考这个问题。如果我们有一个递归函数<em class="lv"> f </em>，我们想用<em class="lv"> f </em>来计算6！以下面的方式:</p><p id="3c79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">6!= <em class="lv"> f </em> (6)</p><p id="c273" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv"> f </em> (6) = 6* <em class="lv"> f </em> (5)</p><p id="ce86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv"> f </em> (5) = 5* <em class="lv"> f </em> (4)，所以<em class="lv">f</em>(6)= 6 * 5 *<em class="lv">f</em>(4)</p><p id="18a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv"> f </em> (4) = 4* <em class="lv"> f </em> (3)，所以<em class="lv">f</em>(6)= 6 * 5 * 4 *<em class="lv">f</em>(3)</p><p id="9673" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv"> f </em> (3) = 3* <em class="lv"> f </em> (2)，所以<em class="lv">f</em>(6)= 6 * 5 * 4 * 3 *<em class="lv">f</em>(2)</p><p id="6483" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv"> f </em> (2) = 2* <em class="lv"> f </em> (1)，所以<em class="lv">f</em>(6)= 6 * 5 * 4 * 3 * 2 *<em class="lv">f</em>(1)</p><p id="ee03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv"> f </em> (1) = 1，所以<em class="lv"> f </em> (6) = 6*5*4*3*2*1。</p><p id="56ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了在python中实现这一点，我们需要定义一个函数，我们将调用“recursive_factorial”，它接受输入<em class="lv"> n </em>，并返回<em class="lv">n</em>* recursive _ factorial(<em class="lv">n</em>-1)。此外，我们希望函数不断返回自身，直到输入等于1。此时，我们返回1，递归终止。为了实现这一点，我们执行以下操作:</p><pre class="kj kk kl km gt ly lz ma mb aw mc bi"><span id="821c" class="md me it lz b gy mf mg l mh mi">def recursive_factorial(n):<br/>    if n == 1:<br/>        return 1<br/>    else:<br/>        return n*recursive_factorial(n-1)</span></pre><p id="114d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，我们应该处理<em class="lv"> n </em> =0的情况，给定0！=1.让我们适当地改变if语句:</p><pre class="kj kk kl km gt ly lz ma mb aw mc bi"><span id="110c" class="md me it lz b gy mf mg l mh mi">def recursive_factorial(n):<br/>    if n &lt;= 1:<br/>        return 1<br/>    else:<br/>        return n*recursive_factorial(n-1)</span></pre><p id="f294" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一件值得注意的事情是，我们的函数不处理负数。这个方法只对自然数和零有效。</p><p id="57d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们来考虑一下这个函数对于4来说是做什么的！：</p><pre class="kj kk kl km gt ly lz ma mb aw mc bi"><span id="f3a8" class="md me it lz b gy mf mg l mh mi">We have to calculate recursive_factorial(4).</span><span id="5442" class="md me it lz b gy mj mg l mh mi">The function asks, is n = 1? No, n=4, so let's return 4*recursive_factorial(4 - 1), which is 4*recursive_factorial(3).</span><span id="11e3" class="md me it lz b gy mj mg l mh mi">Now we have to calculate recursive_factorial(3). </span><span id="9c50" class="md me it lz b gy mj mg l mh mi">Is n = 1? No, n=3, so let's return 4*3*recursive_factorial(3 - 1), which is 4*3*recursive_factorial(2).</span><span id="993e" class="md me it lz b gy mj mg l mh mi">Now we have to calculate recursive_factorial(2).</span><span id="a0fe" class="md me it lz b gy mj mg l mh mi">Is n = 1? No, n=2, so let's return 4*3*2recursive_factorial(2 - 1), which is 4*3*2recursive_factorial(1).</span><span id="bd79" class="md me it lz b gy mj mg l mh mi">Now we have to calculate recursive_factorial(1).</span><span id="610a" class="md me it lz b gy mj mg l mh mi">Is n = 1? yes, n=1, so let's return 4*3*2*1.</span></pre><p id="86dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中<em class="lv"> n </em> &gt; 1的情况称为递归情况，当<em class="lv"> n </em> &lt; = 1时，我们有基本情况。</p><p id="6298" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据这一逻辑，recursive _ factorial(4)= 4 * 3 * 2 * 1 = 24。让我们验证一下:</p><pre class="kj kk kl km gt ly lz ma mb aw mc bi"><span id="34ed" class="md me it lz b gy mf mg l mh mi">def recursive_factorial(n):<br/>    if n &lt;= 1:<br/>        return 1<br/>    else:<br/>        return n*recursive_factorial(n-1)<br/>print("4! =", recursive_factorial(4))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/41bd2b0d698843f066b4e3891bcf5888.png" data-original-src="https://miro.medium.com/v2/resize:fit:216/format:webp/1*9pYwsIFzYgnlcqPT5BUkTQ.png"/></div></figure><p id="6010" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们试试前面的例子，6！：</p><pre class="kj kk kl km gt ly lz ma mb aw mc bi"><span id="4f35" class="md me it lz b gy mf mg l mh mi">print("6! =", recursive_factorial(6))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/bbc96e3f172b64e9b51654dbb8079617.png" data-original-src="https://miro.medium.com/v2/resize:fit:256/format:webp/1*e6NT4SICNGhF7J9t2N0igA.png"/></div></figure><p id="f092" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将在这里停下来，但是您可以随意摆弄代码。如果你有兴趣学习更多关于递归的知识，python-course.edu是一个很好的资源。</p><p id="c5ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总之，在这篇文章中，我们讨论了如何编写一个递归算法来寻找一个自然数的阶乘。递归算法的其他经典应用包括<a class="ae ky" href="https://www.python-course.eu/towers_of_hanoi.php" rel="noopener ugc nofollow" target="_blank">汉诺塔问题</a>和<a class="ae ky" href="https://www.geeksforgeeks.org/count-ways-reach-nth-stair-using-step-1-2-3/" rel="noopener ugc nofollow" target="_blank">第N个楼梯问题</a>。我希望你觉得这篇文章有用/有趣。这篇文章的代码可以在<a class="ae ky" href="https://github.com/spierre91/medium_code/tree/master/data_structures_and_algorithms" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。感谢您的阅读！</p></div></div>    
</body>
</html>