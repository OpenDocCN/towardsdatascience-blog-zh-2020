# 关于自动编码器异常检测的更多信息:用 Keras 测量序列异常

> 原文：<https://towardsdatascience.com/more-on-anomaly-detection-with-neural-networks-and-autoencoders-measuring-sequence-abnormality-dabe361c8fe3?source=collection_archive---------23----------------------->

## 使用 Keras 框架设计一个简单的自动编码器，它可以学习字符串序列的模式并检测错误的模式。

![](img/9469250211b6ec2983c87841a42b3078.png)

由 [Raphael Schaller](https://unsplash.com/@raphaelphotoch?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄的照片

几个月前，我发布了一个[的故事](/a-keras-based-autoencoder-for-anomaly-detection-in-sequences-75337eaed0e5)，展示了如何使用自动编码器(一种主要用于降维和图像压缩的神经网络的特定类型或架构)来有效地检测一大组序列中的异常或错误的字符串序列。给定一个遵循特定模式或格式的序列列表(例如，“AB121E”、“AB323”、“DN176”)，我展示了我们如何设计一个网络来学习这些模式或格式，并能够检测序列格式不正确的情况。在这个故事中，我想展示一个更“高级”的用例，或者我们如何使用相同的方法来解决一个稍微复杂一些的问题。有时，我们想要回答的问题不是*某个序列*是否异常或异常，而是*某个给定序列与其他序列相比*如何异常或异常。例如，假设我们的数据流中每小时有一些异常序列是很正常的，但我们需要找到一种方法来评估某个小时与前一个小时相比有多正常或不正常。我们可以计算出我们每小时看到的异常的平均水平，但是我们如何处理这样的事情呢？

我不会深入研究自动编码器的理论以及它们是如何工作的(有相当多的好的和可访问的阅读材料——我在下面提到了一些),但简单地说，基本思想是自动编码器是一种网络形式，它*学习其输入数据的* *压缩表示，并试图重建它*。通过学习如何从压缩表示中重建序列，一个训练有素的自动编码器可以说是学习了控制其格式的“主导规则”(我应该承认，虽然这个类比对一些人有帮助，但不是每个人都觉得学习压缩表示的想法像学习格式规则一样有吸引力)。因此，我们可以使用这样的自动编码器来估计某个序列的格式或模式如何不同于或偏离其他序列。

遵循“代码优先”的方法，我将立即深入研究代码，并按 3 个主要步骤进行:

1.  *准备深度学习的序列* —标记化、填充和迁移(这取决于手头的问题，但我不认为这个简单的问题需要使用嵌入——无论是学习到的还是预先学习到的)。
2.  *创建并训练一个自动编码器*
3.  *预测得分*

# 1.序列准备

## 1.1 标记化

因此，我们有一个相当大的数据集，大约 25 万个序列(这里描述的方法的成功很大程度上取决于有一个大样本)。序列通常如下所示:

![](img/d9408c1468e2830cf732127ed1f48f12.png)

顺序

正如你所看到的，大多数序列由 4 个部分(或更多)组成，并且似乎遵循某种模式或格式，尽管我们不知道它。

我们需要做的第一项任务是*标记*序列，并为序列中的每个成分(或单词)创建数字表示——即，将['AB '，' C1 '，' D5']变成[1，7，6]。为了做到这一点，我使用了 Keras 的 Tokenizer 类，它负责标记化中的大多数低级步骤。

我定义了一个大小为 750 的词汇表——这意味着记号赋予器将只为数据集中最频繁出现的 750 个记号创建表示。

所有序列都存储在数据帧“序列”中，并通过序列[FEAT_FIELD]进行访问

在我们的数据集上安装了 tokenizer()之后，我们可以使用 tokenizer 的属性 *word_index* 来获取一个 dictionary 对象，该对象可用于检查分配给每个部分的数字表示。

我们通过在序列上调用标记化器的方法 *texts_to_sequences()* 来完成标记化阶段，以便获得一个数组，其中包含我们集合中所有序列的数字表示。

![](img/1022a51929763f7a5f15d60b7553e0ff.png)

我们现在有了一组符号化的序列([1，3，31，22])或一组原始集合的数值表示([DF，36，FR，GX567])。

## 1.2 填充

我们需要采取的下一步是关注我们分析所基于的序列的长度。在最好的情况下，所有序列的长度都是相同的，但有时情况并非如此。这个问题很重要，因为它关系到我们的模型将使用的特性。因为所有的序列都需要相同的长度(您将在后面看到原因)，所以短序列通常用零填充，以匹配长序列的长度。因此，如果我们决定我们的模型要学习的数字特征是 6，那么我们需要用零“填充”这个序列[1，3，31，22]，并将其转换为这个序列[1，3，31，22，0，0]。

例如，在我们的例子中，绝大多数序列有 4 个组成部分，但有些没有。

![](img/e1fcffa2eb7ad798fa345dfb431d6465.png)

我们序列的平均长度确实是 4，但我们看到有些“异常值”有更多。然而，因为大多数序列只有 4 个分量，并且因为不必要的填充可能会影响我们模型的性能，所以我们最好坚持 4 个分量，这样我们所要做的就是填充少于 4 个分量的序列。

![](img/ff47a70d83460b32b7296ecd66dbcd23.png)

我们使用这个一行程序来实现:

```
MAX_FEAT_LEN = 4

pad_seqs = pad_sequences(seqs, maxlen=MAX_FEAT_LEN, padding='post', truncating='post')
```

## 1.3 矢量化

我们最后也是最重要的一步是对每个序列进行矢量化。通过向量化我们的序列，我们像这样变换(或展平)序列:1，4，31，22

变成这样:

![](img/fdae426f777e032aef0d4b3e15451bb5.png)

您在这里看到的是一个大小为 750(这是我们的词汇量)的向量，它由 746 个 0 和 4 个 1 组成，而每个 1 的位置或索引是其数值的 representד。换句话说，序列 1，4，31，22 将在向量 **v** 中表示为:

```
**v**[1]  = 1
**v**[4]  = 1
**v**[31] = 1
**v**[22] = 1
```

使用这种方法可以很容易地实现这一点:

弗朗索瓦·乔莱(DLP)

现在我们的序列可以学习了！

# 2.创建并训练自动编码器

我不会在这里过多地讨论细节，因为我相信如果你对 DL 和 Keras 有所了解，代码是非常简单明了的。然而，简而言之，自动编码器通常是通过连接一个*编码*层和一个*解码*层来创建的，前者将输入压缩或挤压到一个较低维度的层中，从而创建一种“瓶颈”，后者学习从输入数据的压缩表示中重建输入。

![](img/fbb853eb23d60c168184920dd9f82b09.png)

摘自[https://www.jeremyjordan.me/autoencoders/](https://www.jeremyjordan.me/autoencoders/)

根据手头的问题，自动编码器显然可以以多种方式设计。我选择使用一个非常简单的例子(主要是由于数据的性质及其相对不复杂),这个例子可以使用 Keras 非常简单地实现，如下所示:

![](img/6b94f674b95949053a7fa2e4aece82b1.png)

这通常不是必需的，但是如果你想密切跟踪和观察你的模型的性能并保存它(像我一样)，那么这可能是有帮助的(否则你可以只调用 autoencoder compile()和 fit()方法。

假设模型表现足够好，我们现在可以加载它，并继续检查和评分我们的序列:

```
autoencoder = load_model('model_bin.h5')
```

# 3.预测和评分

现在我们到了有趣的部分。我们有一个自动编码器，它接收一个字符串序列作为输入(在它被标记化、填充和矢量化之后),并输出同一序列的重构。但是这个输出并不真正有趣——如果我们的自动编码器工作正常，它将简单地输出与我们给它的输入序列非常相似的东西。关于自动编码器的输出，*有趣的是输出和输入序列彼此之间有多么不同。假设我们的自动编码器训练有素，那么如果输入序列格式良好，或者如果它遵循自动编码器从训练数据中学习到的相同模式，那么输出序列将是相同或相似的。相应地，如果输入序列不遵循自动编码器已经学习的模式，则输出序列将与输入序列不太相似。*

因此，如果我们想要检查某个序列是否或在多大程度上遵循自动编码器从训练数据中学习到的模式，那么我们需要测量自动编码器的预测或其输出的序列所产生的差异(或误差)。但是我们怎么做呢？

让我提出一个可能的方法。在标记化、填充和矢量化之后，每个序列基本上都是一个零向量，在每个数字标记的索引位置都有“1”——因此在 6 个字符的词汇向量中,[1，3]将表示为[0，1，0，1，0，0]。如果我们的自动编码器将接收这个输入，并输出序列[0，1，0，0，1，0]，它代表序列[1，4]，那么我们有一个错误。我们想要实现的是找到一种方法来测量这或*测量两个序列不同的程度*。做到这一点的最有效的方法之一是简单地获得每个输出序列的均方误差，通过(1)减去输入和输出以计算误差；(2)平方结果(消除任何负值)；(3)将误差的平均值作为输出序列有多“错误”的度量。

这段代码将使这一点更加清楚。

![](img/f12d7496fb1a593246b02df1e3039142.png)

这里我们有 3 个输入序列和 3 个输出序列。第一个输出序列没有任何错误，而第二个输出序列有一个错误，第三个有两个错误。当我们看到减去它们的输出时，这一点就很清楚了:

```
Result of subtracting the vectors:
[[ 0  0  0  0  0]
 [-1  0  0  0  0]
 [ 0  0 -1 -1  0]]
```

当我们计算误差的平方并取每个序列的平均值时，我们就得到一个不完美的度量，或者说它偏离输入序列的程度。

```
 Errors:
[0\.  0.2 0.4]
```

因此，为了在我们的用例中实现这一点，我们需要做的就是通过对输入序列调用 predict 来从自动编码器获取输出序列，然后对错误数求平方并取平均值。

现在，每个序列都有一个特定的分数，代表它与输入序列的差异程度，我们可以用它来衡量这个序列遵循我们的自动编码器所学习的模式的程度。然而，这个分数本身并没有太大的帮助，也没有告诉我们任何事情(事实上，不管手头的词汇量有多大，考虑这个数字本身就是一个错误)。我们*可以*利用这一点的一种方法是测量我们数据集的误差平均值 *— np.quantile(mse，0.5)* ，然后将高于该阈值的每个序列视为比其他序列更不正常；而测量误差高于第 75 百分位的序列为*多*多异常，依此类推。这将允许我们根据序列与自动编码器学习的模式的偏离程度对序列进行评分。

![](img/442dbf3650989e2571a7d58edb86411f.png)

然而，反其道而行之会更准确、更有效——能够知道某个序列对应的百分位是多少，以便得到它的异常分数。这就是下面的方法所要做的:在准备好字符串之后，它使用 autoencoder 的 predict()方法，获得与输出序列相关联的误差项，并获得误差值的百分位数排名，这可以为我们提供它与学习模式的一致性的更准确的表示。

如下图所示，序列“9 ER 223 ABCDSED”的百分位等级为 73.8，这意味着考虑到自动编码器对其做出的预测错误数量，它是相对不正常的。这可能意味着它与自动编码器学习的其他序列遵循的模式有相当大的差异。

```
score, rank = get_sequence_anomaly_rank('9 ER 223 ABCDSED')print(f'Anomaly Score:{score}, Percentile Rank:{rank}')==> **Anomaly Score:[0.00346862], Percentile Rank:73.85446487442933**
```

现在测量某些序列以及序列组的异常程度是很简单的。为了评估某个组的异常程度，我们需要做的就是计算该组成员产生的误差的加权平均值。

我希望这有所帮助！

示例笔记本可以在[这里找到](https://github.com/a-agmon/anomaly_det/blob/81cba14740c83b9e517c86c1c54d2958105f8dc7/seq_autoencoder_pub.ipynb)

一些关于自动编码器的链接:

 [## 自动编码器介绍。

### 自动编码器是一种无监督的学习技术，其中我们利用神经网络来完成表示的任务…

www.jeremyjordan.me](https://www.jeremyjordan.me/autoencoders/) [](/applied-deep-learning-part-3-autoencoders-1c083af4d798) [## 应用深度学习-第 3 部分:自动编码器

### 概观

towardsdatascience.com](/applied-deep-learning-part-3-autoencoders-1c083af4d798) 

【https://blog.keras.io/building-autoencoders-in-keras.html 