<html>
<head>
<title>How GIN Indices Can Make Your Postgres Queries 15x Faster</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GIN 索引如何让 Postgres 查询速度提高 15 倍</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-gin-indices-can-make-your-postgres-queries-15x-faster-af7a195a3fc5?source=collection_archive---------8-----------------------#2020-03-27">https://towardsdatascience.com/how-gin-indices-can-make-your-postgres-queries-15x-faster-af7a195a3fc5?source=collection_archive---------8-----------------------#2020-03-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a602" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过查询示例，您可以在笔记本电脑上运行</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e4469dba64fec55bfd2088f7de2ca613.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UEAzlUSboRMuQBW486o0Xw.png"/></div></div></figure><p id="abbb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">添加索引将查询时间从几分钟缩短到了几毫秒，这是我职业生涯中从未有过的。作为数据科学家，我们花费大量时间来查询和分析数据，因此我们应该知道如何高效地完成这项工作。</p><p id="3f97" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Postgres 有 6 种索引类型。今天我们将讲述杜松子酒指数。</p><p id="2b82" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将为数据库植入越来越多的数据，并比较使用和不使用 GIN 索引的查询时间。如果您使用 SQL 编辑器(我使用的是 DBeaver)进行操作，您会受益更多。</p><h1 id="321c" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">什么是指数？</h1><p id="019b" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">一种数据结构，以较慢的插入速度和更多的磁盘空间为代价，提高了从数据库中检索数据的效率。</p><h1 id="7ce6" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">什么是杜松子酒指数？</h1><p id="5841" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">GIN 代表广义倒排索引。通常，倒排索引将单词映射到它在表中的位置。</p><p id="11e3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是我对倒排索引的一个抽象。</p><p id="31e3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们想在没有索引的情况下在表中查找包含单词<code class="fe mn mo mp mq b">lazy</code>的句子，我们需要迭代表中的每个句子来查找匹配。</p><p id="0915" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是通过增加一个索引，我们提前知道哪些句子包含了<code class="fe mn mo mp mq b">lazy</code>这个词，可以直接加载那些。这使得事情快了很多！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mr"><img src="../Images/2334981be89799c3ee20da46363e8f7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Of7_xwbaaW78cMkKNSBxrw.png"/></div></div></figure><p id="0b5f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种类型的索引适用于查询复合数据类型，这意味着它们存储不止一个值。例如 hStores、Arrays、Ranges 和 JSONs。</p><h1 id="4b33" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">杜松子酒指数快了多少？</h1><p id="01d7" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">让我们找出答案。</p><p id="020e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先创建一个表并用数据填充它。</p><pre class="kj kk kl km gt ms mq mt mu aw mv bi"><span id="c108" class="mw lr it mq b gy mx my l mz na"><strong class="mq iu"># create table</strong><br/>CREATE TABLE articles (<br/>  body text,<br/>  body_indexed text<br/>);</span><span id="3217" class="mw lr it mq b gy nb my l mz na"><strong class="mq iu"># add an index</strong><br/>CREATE INDEX articles_search_idx ON articles USING gin (body_indexed gin_trgm_ops);</span><span id="4315" class="mw lr it mq b gy nb my l mz na"><strong class="mq iu"># populate table with data</strong><br/>INSERT INTO articles<br/>SELECT<br/>  md5(random()::text),<br/>  md5(random()::text)<br/>from (<br/>  SELECT * FROM generate_series(1,100000) AS id<br/>) AS x;</span></pre><p id="2eff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">太棒了，我们现在有一个名为<code class="fe mn mo mp mq b">articles</code>的表，有 100k 条记录和 2 列随机字符串。</p><p id="a4a3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你对指数感兴趣。我们没有直接索引字符串，而是使用 Postgres 的<code class="fe mn mo mp mq b">gin_trgm_ops</code>从每个字符串创建<code class="fe mn mo mp mq b">trigrams</code>(想想<code class="fe mn mo mp mq b">sklearn</code>中的<code class="fe mn mo mp mq b">ngrams</code>),并对其进行索引。</p><p id="6b70" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我的 SQL 编辑器中，该表如下所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/87f33c0f4dfbf836857742185a5c9c0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NlP1rOylixqgEEtkWLVTPw.png"/></div></div></figure><p id="b6b8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我将在添加每 100k 条新记录后跟踪查询时间。</p><p id="74d6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我会运行这些查询。</p><pre class="kj kk kl km gt ms mq mt mu aw mv bi"><span id="a574" class="mw lr it mq b gy mx my l mz na"><strong class="mq iu">SELECT</strong> <strong class="mq iu">count</strong>(*) <strong class="mq iu">FROM</strong> articles <strong class="mq iu">where</strong> body <strong class="mq iu">ilike</strong> '%abc%';<br/><strong class="mq iu">SELECT</strong> <strong class="mq iu">count</strong>(*) <strong class="mq iu">FROM</strong> articles <strong class="mq iu">where</strong> body_indexed <strong class="mq iu">ilike</strong>'%abc%';</span></pre><p id="8a3d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="nd">相同或相似的查询运行多次会在运行时间上有所不同。这是由于机器上变化的系统负载和变化的查询计划。为了我们的目的，忽略波动，看看时差的一般趋势。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e4469dba64fec55bfd2088f7de2ca613.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UEAzlUSboRMuQBW486o0Xw.png"/></div></div></figure><p id="e08e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">哇！这对于仅有的 200 万张唱片来说是一个巨大的差异。想象一下，我们正在查询一个数十亿的数据库。</p><h1 id="2b11" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">结论</h1><p id="3598" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">大多数时候我们只需要添加一个 B 树索引。但有时像杜松子酒这样的另一个指数更合适。当您最终遇到 B 树无法解决的问题时，知道其他索引类型是有用的。</p><p id="18af" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你有没有遇到过任何很酷的索引用例，或者以有趣的方式应用它们？</p></div></div>    
</body>
</html>