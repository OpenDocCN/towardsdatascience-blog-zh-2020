<html>
<head>
<title>How Will Premier League End?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">英超将如何收场？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-will-the-premier-league-end-6f262e76e6c6?source=collection_archive---------62-----------------------#2020-05-20">https://towardsdatascience.com/how-will-the-premier-league-end-6f262e76e6c6?source=collection_archive---------62-----------------------#2020-05-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a1c7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用 XGBoost 预测并完成英超积分榜。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d0b6cd21b2479102a03d3fd1170c1534.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*P55d8h-3L2bWKWry"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Ajay Meganathan 在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="dac4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">英超联赛，连同几乎足球世界的其他部分，都暂停了。目前还不清楚联赛是否会继续。但如果继续下去，会如何收场？在这篇文章中，我将创建一个模型，预测英超联赛的结果，以完成联赛表。利物浦会赢得联赛冠军吗？曼联会晋级欧冠吗？还有哪些队伍会被拒绝？这些是将在本文结尾回答的一些问题。</p><h1 id="ac81" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">资料组</h1><p id="99da" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">为了创建一个有用的数据集，我们需要大量的匹配统计数据。对我们来说幸运的是，【http://www.football-data.co.uk/】是一个提供从 2005 年到今天每一场英超比赛统计数据的网站。在这里，我下载了每个季节的数据，并将其合并成一个数据集。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="6961" class="mu lt iq mq b gy mv mw l mx my">import pandas as pd</span><span id="8374" class="mu lt iq mq b gy mz mw l mx my"># Dataset </span><span id="f2a3" class="mu lt iq mq b gy mz mw l mx my">df = pd.<!-- -->read_csv<!-- -->('pl_data.csv')</span><span id="5166" class="mu lt iq mq b gy mz mw l mx my">df.info()<br/><br/>&lt;class 'pandas.core.frame.DataFrame'&gt;<br/>RangeIndex: <strong class="mq ir">5592</strong> entries, 0 to 5591<br/>Columns: <strong class="mq ir">144</strong> entries, Div to SBA<br/>dtypes: datetime64[ns](1), float64(131), int64(1), object(11)<br/>memory usage: 6.1+ MB</span></pre><p id="f237" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该数据集包含 5592 个观察值和 144 个变量。但是，我们不会在最终模型中使用任何变量。相反，这些变量将用于创建新的变量，如“主队的平均进球”。事实上，该模型将主要依赖于平均变量。由于目标是预测剩下的比赛，变量如‘Form<em class="na">’</em>将依赖于早期的预测。为了更清楚地说明这一点，假设我们有变量' Form <em class="na"> ' </em>(衡量主队或客场队在最近五场比赛中的得分)，我们希望预测本赛季的最后一场比赛。那么变量将只取决于早期预测的结果。这可能会扭曲预测，从而扭曲最终的排名。但是，在创建常规投注模型时，变量如“Form<em class="na">”</em>是至关重要的，应该添加。</p><p id="722b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完整的数据集最终有八个变量，分为主场或客场球队和赛季或总平均水平。这使得变量总数为 8*2*2 = <strong class="ky ir"> 32。</strong>这些是变量:</p><ul class=""><li id="6fa4" class="nb nc iq ky b kz la lc ld lf nd lj ne ln nf lr ng nh ni nj bi translated">平均进球数。</li><li id="904f" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">平均射门次数。</li><li id="8c7e" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">平均出手次数。</li><li id="02b5" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">平均角数。</li><li id="f108" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">平均犯规次数。</li><li id="ceb5" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">平均黄牌数。</li><li id="2124" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">红牌的平均数量。</li><li id="d198" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">半场平均进球数。</li></ul><p id="fd80" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，再增加几个变量也无妨。但是现在这样就可以了。下面是为主队和客场队创建总平均变量的代码(在计算“赛季平均”变量时使用类似的方法)。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="9478" class="mu lt iq mq b gy mv mw l mx my"># Create the columns # <br/>df['avg_g_hmt'] = df['gameId']<br/>df['avg_g_awt'] = df['gameId']<br/>df['avg_s_hmt'] = df['gameId']<br/>df['avg_s_awt'] = df['gameId']<br/>df['avg_sot_hmt'] = df['gameId']<br/>df['avg_sot_awt'] = df['gameId']<br/>df['avg_c_hmt'] = df['gameId']<br/>df['avg_c_awt'] = df['gameId']<br/>df['avg_f_hmt'] = df['gameId']<br/>df['avg_f_awt'] = df['gameId']<br/>df['avg_yc_hmt'] = df['gameId']<br/>df['avg_yc_awt'] = df['gameId']<br/>df['avg_rc_hmt'] = df['gameId']<br/>df['avg_rc_awt'] = df['gameId']<br/>df['avg_htg_hmt'] = df['gameId']<br/>df['avg_htg_awt'] = df['gameId']</span><span id="a51c" class="mu lt iq mq b gy mz mw l mx my">gameid_col = df.columns.get_loc('gameId')<br/>HomeTeam_col = df.columns.get_loc('HomeTeam')<br/>FTHG_col = df.columns.get_loc('FTHG')<br/>FTAG_col = df.columns.get_loc('FTAG')<br/>HS_col = df.columns.get_loc('HS')<br/>AS_col = df.columns.get_loc('AS')<br/>HST_col = df.columns.get_loc('HST')<br/>AST_col = df.columns.get_loc('AST')<br/>HF_col = df.columns.get_loc('HF')<br/>AF_col = df.columns.get_loc('AF')<br/>HC_col = df.columns.get_loc('HC')<br/>AC_col = df.columns.get_loc('AC')<br/>HY_col = df.columns.get_loc('HY')<br/>AY_col = df.columns.get_loc('AY')<br/>HR_col = df.columns.get_loc('HR')<br/>AR_col = df.columns.get_loc('AR')<br/>HTHG_col = df.columns.get_loc('HTHG')<br/>HTAG_col = df.columns.get_loc('HTAG')<br/>   <br/># Iterate over all teams # <br/>df = df.sort_values(by = ['Date'])<br/>mylist = list(set(df['HomeTeam']))<br/>count = 0<br/>for i in mylist:<br/>    count = count + 1 <br/>    print(count,": Creating variables for", i)<br/>    homegamesindex = df['HomeTeam'] == i<br/>    awaygamesindex = df['AwayTeam'] == i<br/>    df_1 = df[homegamesindex]<br/>    df_2 = df[awaygamesindex]<br/>    df_3 = pd.concat((df_1,df_2))<br/>    df_3 = df_3.sort_values(by = ['Date'])<br/>    for j in range(len(df_3)):<br/>        gameid = df_3.iloc[j,gameid_col]<br/>        if df_3.iloc[j,HomeTeam_col] == i:<br/>            H_or_A = "H"<br/>        else:<br/>            H_or_A = "A"<br/>        y = j - 1<br/>        # Create the count-variables # <br/>        avg_g = 0 <br/>        avg_s = 0<br/>        avg_sot = 0<br/>        avg_c = 0<br/>        avg_f = 0<br/>        avg_yc = 0<br/>        avg_rc = 0<br/>        avg_htg = 0<br/>        while y &gt; -1:<br/>        # Home or away in earlier games # <br/>            if df_3.iloc[y,HomeTeam_col] == i:<br/>                avg_g = avg_g + df_3.iloc[y,FTHG_col]<br/>                avg_s = avg_s + df_3.iloc[y,HS_col]<br/>                avg_sot = avg_sot + df_3.iloc[y,HST_col]<br/>                avg_c = avg_c + df_3.iloc[y,HC_col]<br/>                avg_f = avg_f + df_3.iloc[y,HF_col]<br/>                avg_yc = avg_yc + df_3.iloc[y,HY_col]<br/>                avg_rc = avg_rc + df_3.iloc[y,HR_col]<br/>                avg_htg = avg_htg + df_3.iloc[y,HTHG_col]<br/>            else:<br/>                avg_g = avg_g + df_3.iloc[y,FTAG_col]<br/>                avg_s = avg_s + df_3.iloc[y,AS_col]<br/>                avg_sot = avg_sot + df_3.iloc[y,AST_col]<br/>                avg_c = avg_c + df_3.iloc[y,AC_col]<br/>                avg_f = avg_f + df_3.iloc[y,AF_col]<br/>                avg_yc = avg_yc + df_3.iloc[y,AY_col]<br/>                avg_rc = avg_rc + df_3.iloc[y,AR_col]<br/>                avg_htg = avg_htg + df_3.iloc[y,HTAG_col]<br/>            <br/>            y = y - 1<br/>       # If the team plays home or away #<br/>       if H_or_A == "H": <br/>           df['avg_g_hmt'].loc[df['gameId'] == gameid] = avg_g/(j+1)<br/>           df['avg_s_hmt'].loc[df['gameId'] == gameid] = avg_s/(j+1)<br/>           df['avg_sot_hmt'].loc[df['gameId']==gameid]=avg_sot/(j+1)<br/>           df['avg_c_hmt'].loc[df['gameId'] == gameid] = avg_c/(j+1)<br/>           df['avg_f_hmt'].loc[df['gameId'] == gameid] = avg_f/(j+1)<br/>           df['avg_yc_hmt'].loc[df['gameId'] ==gameid]= avg_yc/(j+1)<br/>           df['avg_rc_hmt'].loc[df['gameId'] ==gameid]= avg_rc/(j+1)<br/>           df['avg_htg_hmt'].loc[df['gameId']==gameid]=avg_htg/(j+1)<br/>       else:<br/>           df['avg_g_awt'].loc[df['gameId'] == gameid] =avg_g/(j+1)<br/>           df['avg_s_awt'].loc[df['gameId'] == gameid] =avg_s/(j+1)<br/>           df['avg_sot_awt'].loc[df['gameId']==gameid]=avg_sot/(j+1)<br/>           df['avg_c_awt'].loc[df['gameId'] == gameid] =avg_c/(j+1)<br/>           df['avg_f_awt'].loc[df['gameId'] == gameid] =avg_f/(j+1)<br/>           df['avg_yc_awt'].loc[df['gameId'] ==gameid]=avg_yc/(j+1)<br/>           df['avg_rc_awt'].loc[df['gameId'] ==gameid]=avg_rc/(j+1)<br/>           df['avg_htg_awt'].loc[df['gameId']==gameid]=avg_htg/(j+1)</span></pre><p id="ba14" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">既然数据集已经完成，让我们来探索它吧！首先，它不应该包含任何 NA:s</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="02fe" class="mu lt iq mq b gy mv mw l mx my">all(data.isna() == False)</span><span id="ea9e" class="mu lt iq mq b gy mz mw l mx my">Out[36]: True</span></pre><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="5561" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完美！现在数据集被分为训练数据集和测试数据集。但是首先，第一轮比赛的所有比赛都被删除了，因为所有的平均变量都为零。此后，为“主场目标”和“客场目标”分别创建一个 XGBoost 模型。这将使我们能够预测即将到来的比赛的结果。在 XGBoost 中，可以绘制变量的重要性，下面是“家庭目标”模型的图。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="4fcd" class="mu lt iq mq b gy mv mw l mx my"><strong class="mq ir">from</strong> xgboost <strong class="mq ir">import</strong> plot_importance</span><span id="f871" class="mu lt iq mq b gy mz mw l mx my"><strong class="mq ir">plot_importance(</strong>home_mod<strong class="mq ir">)</strong></span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/db31a451038b14650d00bcbfae9b1615.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/1*FC1zZbJJ6xtxaSkQnAXK_Q.png"/></div></figure><p id="e8ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如预期的那样，有几个变量贡献很大，有几个贡献不太大。“客场球队的平均角球数”和“客场球队的平均黄牌数”似乎是最不重要的。而“主队的平均角球”和“主队的赛季平均进球”似乎是最重要的。这完全有意义，因为我们希望预测主队的进球。客队会有多少角球并不会显著改变得分的概率。然而，所有的变量仍将存在于最终的模型中，因为这不会有太大的计算量。</p><h2 id="5cea" class="mu lt iq bd lu ns nt dn ly nu nv dp mc lf nw nx me lj ny nz mg ln oa ob mi oc bi translated">利物浦会赢得联赛冠军吗？</h2><p id="668e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">由于利物浦已经领先 25 分，而且只剩下 9 场比赛，他们只需要再赢两场比赛就可以举起奖杯。这是模型如何预测利物浦即将到来的比赛。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi od"><img src="../Images/a1d937a9c04bd8cf61eb9f3ad3c80152.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*UAF7vU33MLUGKT7E-K_kEw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">预测:利物浦最后一场比赛</p></figure><p id="867f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">轻松点。利物浦在最近的 9 场比赛中以 7 胜 1 平 1 负的成绩轻松夺冠。利物浦不仅是赢家，他们是风格上的赢家。他们以 104 分打破了目前 98 分的积分纪录(曼城，2018/19)。这将是他们 30 年来的第一个 PL 冠军(89/90 赛季)！</p><p id="755f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么，其他队表现如何？预测完剩下的比赛，积分榜就这样结束了。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/fc695d094fbd40090489347e8ecd6c92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jgZXawOGcqiLYoIHEOOStw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">2019/2020 赛季英超联赛预测表</p></figure><p id="3e60" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">冠军联赛的门票将流向利物浦、曼城(但是他们被禁赛了，所以谁知道呢)、切尔西、曼联，也许还有莱斯特，因为曼城被禁赛了。“前六名”中的另外两支球队，阿森纳和托特纳姆，分别排在第六和第七位。不幸的是，预测下赛季参加锦标赛的球队是布莱顿、阿斯顿维拉和诺维奇。</p><p id="9a65" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种模式似乎有利于大型团队。例如，莱斯特现在在积分榜上排名第三，曼联排名第六，但该模型预测曼联最终会超过莱斯特。类似的事情也发生在布莱顿，它排在第 15 位，但预计会降级。我的假设是，该模型有利于大球队，因为大多数变量取决于球队在许多赛季前的表现。当然，大球队将从中受益。毕竟，他们被认为是大牌，因为他们在过去几个赛季表现出色。如果有人试图自己做这件事，这是一个可以改进的领域。</p><p id="e20d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你有它！利物浦赢了，切尔西下赛季打冠军联赛，诺维奇只拿到 21 分。也就是说，如果我的模型 100%正确。没有模特是这样的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/e562e32970ee8df355e59b6d38b12f73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cOExXeuERhU9Lqyl"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">乔治·特罗瓦托在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure></div></div>    
</body>
</html>