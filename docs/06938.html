<html>
<head>
<title>Confusion Matrix for Your Multi-Class Machine Learning Model</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">多类机器学习模型的混淆矩阵</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/confusion-matrix-for-your-multi-class-machine-learning-model-ff9aa3bf7826?source=collection_archive---------0-----------------------#2020-05-29">https://towardsdatascience.com/confusion-matrix-for-your-multi-class-machine-learning-model-ff9aa3bf7826?source=collection_archive---------0-----------------------#2020-05-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="48fe" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关于如何计算多类分类问题的精确度、召回率和 F1 分数的初学者指南。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2ed708608c1372b4d507197103dcf127.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1LQt3fUOBd24__D0iQeMzA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@homajob?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">斯科特·格雷厄姆</a>在<a class="ae ky" href="https://unsplash.com/@homajob?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="c0c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated"><span class="l lw lx ly bm lz ma mb mc md di"/>混淆矩阵是一种可视化预测模型性能的表格方式。混淆矩阵中的每个条目表示模型做出的正确或错误分类的预测数量。</p><p id="8fa2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">任何已经熟悉混淆矩阵的人都知道，大多数情况下，它是针对二元分类问题来解释的。这个解释不在其中。今天我们将看到混淆矩阵如何在多类机器学习模型上工作。然而，我们将从使用二元分类的一点背景开始，只是为了正确地看待事情。</p><h1 id="5c60" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">二元分类的混淆矩阵</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mw"><img src="../Images/1d3aee6f67f2b6a97da2fb6f0c122b23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fxiTNIgOyvAombPJx5KGeA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">二元分类的混淆矩阵</p></figure><p id="8048" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，二进制分类问题只有两个类要分类，最好是一个正类和一个负类。现在让我们看看混淆矩阵的度量。</p><p id="f18b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">真阳性(TP): </strong>指分类器正确预测阳性类为正的预测次数。</p><p id="7ad0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">真否定(TN): </strong>指分类器正确预测否定类为否定的预测次数。</p><p id="c974" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">假阳性(FP): </strong>指分类器错误地将阴性类预测为阳性的预测次数。</p><p id="651d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">假阴性(FN): </strong>指分类器错误地将阳性类预测为阴性的预测次数。</p><p id="54be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用混淆矩阵作为你的机器学习模型的评估标准总是比较好的。它为您的模型提供了一个非常简单而有效的性能测量方法。以下是困惑矩阵中一些你可以使用的最常见的绩效衡量标准。</p><p id="ec62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">准确性:</strong>它给出模型的总体准确性，即被分类器正确分类的样本占总样本的比例。计算精度，用下面的公式:<strong class="lb iu"><em class="mx">(TP+TN)/(TP+TN+FP+FN)</em></strong>。</p><p id="80bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">错误分类率:</strong>它告诉你有多少预测是错误的。它也被称为分类错误。可以用<strong class="lb iu"><em class="mx">(FP+FN)/(TP+TN+FP+FN)</em></strong>或者<strong class="lb iu"><em class="mx">(1-精度)</em> </strong>来计算。</p><p id="be00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> Precision: </strong>它告诉你一个正类的预测中有多少部分实际上是正的。要计算精度，用下面的公式:<strong class="lb iu"> <em class="mx"> TP/(TP+FP) </em> </strong>。</p><p id="c575" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">回忆:</strong>它告诉您所有阳性样本中有多少被分类器正确预测为阳性。它也被称为真阳性率(TPR)、灵敏度、检测概率。计算召回率，使用以下公式:<strong class="lb iu"><em class="mx">【TP/(TP+FN)</em></strong>。</p><p id="f2d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">特异性:</strong>它告诉您所有阴性样本中有多少部分被分类器正确预测为阴性。它也被称为真实负利率(TNR)。要计算特异性，用下面的公式:<strong class="lb iu"><em class="mx">【TN/(TN+FP)</em></strong>。</p><p id="64a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">F1-score: 它将精确度和召回率结合成一个单一的度量。从数学上来说，这是精确度和召回率的调和平均值。它可以计算如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi my"><img src="../Images/33a31d01865235d7cfc3a16f0b9493c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wUdjcIb9J9Bq6f2GvX1jSA.png"/></div></div></figure><p id="2936" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，在一个完美的世界里，我们想要一个精度为 1，召回率为 1 的模型。这意味着 F1 分数为 1，即 100%的准确率，这通常不是机器学习模型的情况。因此，我们应该尝试的是获得更高的查准率和更高的查全率。好了，现在我们知道了混淆矩阵的性能度量，让我们看看如何在多类机器学习模型中使用它。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="b727" class="me mf it bd mg mh ng mj mk ml nh mn mo jz ni ka mq kc nj kd ms kf nk kg mu mv bi translated">多类分类的混淆矩阵</h1><p id="edc6" class="pw-post-body-paragraph kz la it lb b lc nl ju le lf nm jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">为了简单起见，让我们考虑我们的多类分类问题是一个 3 类分类问题。比方说，我们有一个数据集，它有三个类标签，即<strong class="lb iu"> <em class="mx">苹果</em> </strong>、<strong class="lb iu"> <em class="mx">桔子</em> </strong>和<strong class="lb iu"> <em class="mx">芒果</em> </strong>。下面是这些类的一个可能的混淆矩阵。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/91b477a1d92bf091231e4538f80e30ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yH2SM0DIUQlEiveK42NnBg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">多类分类的混淆矩阵</p></figure><p id="2f49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与二进制分类不同，这里没有正类或负类。起初，找到 TP、TN、FP 和 FN 可能有点困难，因为没有正类或负类，但实际上很容易。这里我们要做的是找到每个类的 TP，TN，FP 和 FN。例如，如果我们取苹果类，那么让我们看看混淆矩阵中的度量值是多少。</p><ul class=""><li id="76e5" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated"><strong class="lb iu"> <em class="mx"> TP = 7 </em> </strong></li><li id="f54e" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><strong class="lb iu"><em class="mx">TN =(2+3+2+1)= 8</em></strong></li><li id="6149" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><strong class="lb iu"> <em class="mx"> FP = (8+9) = 17 </em> </strong></li><li id="e172" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><strong class="lb iu"> <em class="mx"> FN = (1+3) = 4 </em> </strong></li></ul><p id="1e3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于我们从混淆矩阵中获得了苹果类的所有必要度量，现在我们可以计算苹果类的性能度量。例如，苹果公司有</p><ul class=""><li id="fb7c" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated"><strong class="lb iu"> <em class="mx">精度= 7/(7+17) = 0.29 </em> </strong></li><li id="a44e" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><strong class="lb iu"> <em class="mx">回忆= 7/(7+4) = 0.64 </em> </strong></li><li id="ce8f" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><strong class="lb iu"><em class="mx">F1-得分= 0.40 </em> </strong></li></ul><p id="3a49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似地，我们可以计算其他类的度量。下表显示了每个类的每个测量值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/ce60a0b2e5aa37588f72aeefeee682f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X1ghULso7P3AdMalomM6yg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">每门课的精确度、召回率和 F1 分数</p></figure><p id="fabc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以通过这些措施做更多的事情。我们可以将每个类的 F1 分数结合起来，为整个模型提供一个单一的度量。有几种方法可以做到这一点，现在让我们来看看。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h2 id="14b4" class="og mf it bd mg oh oi dn mk oj ok dp mo li ol om mq lm on oo ms lq op oq mu or bi translated">微型 F1</h2><p id="29a1" class="pw-post-body-paragraph kz la it lb b lc nl ju le lf nm jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">这被称为微观平均 F1 分数。它是通过考虑模型的总 TP、总 FP 和总 FN 来计算的。它不单独考虑每个类，而是全局计算指标。所以在我们的例子中，</p><ul class=""><li id="ba16" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated"><strong class="lb iu"> <em class="mx">总 TP = (7+2+1) = 10 </em> </strong></li><li id="2820" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><strong class="lb iu"> <em class="mx">总 FP =(8+9)+(1+3)+(3+2)= 26</em></strong></li><li id="444b" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><strong class="lb iu"> <em class="mx">总 FN =(1+3)+(8+2)+(9+3)= 26</em></strong></li></ul><p id="f9cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，</p><ul class=""><li id="82f9" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated"><strong class="lb iu"> <em class="mx">精度= 10/(10+26) = 0.28 </em> </strong></li><li id="16b0" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><strong class="lb iu"> <em class="mx">回忆= 10/(10+26) = 0.28 </em> </strong></li></ul><p id="d009" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以使用 F1 分数的常规公式，并使用上述精度和召回率获得微观 F1 分数。</p><blockquote class="os ot ou"><p id="8986" class="kz la mx lb b lc ld ju le lf lg jx lh ov lj lk ll ow ln lo lp ox lr ls lt lu im bi translated"><strong class="lb iu">微 F1 = 0.28 </strong></p></blockquote><p id="e723" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您所看到的，当我们计算全局指标时，所有度量都变得相等。如果你计算准确度，你会发现，</p><blockquote class="oy"><p id="8ff2" class="oz pa it bd pb pc pd pe pf pg ph lu dk translated"><strong class="ak"> <em class="pi">精度=召回=微 F1 =准确度</em> </strong></p></blockquote><h2 id="afee" class="og mf it bd mg oh pj dn mk oj pk dp mo li pl om mq lm pm oo ms lq pn oq mu or bi translated">宏 F1</h2><p id="3bfe" class="pw-post-body-paragraph kz la it lb b lc nl ju le lf nm jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">这是 F1 的宏观平均分数。它分别计算每个类别的指标，然后取这些指标的未加权平均值。从图<strong class="lb iu"> <em class="mx">【精确度、召回率和 F1-每类得分】</em> </strong>中我们看到，</p><ul class=""><li id="8615" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated"><strong class="lb iu"> <em class="mx">类苹果 F1-得分= 0.40 </em> </strong></li><li id="741a" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><strong class="lb iu"> <em class="mx">级橙 F1-得分= 0.22 </em> </strong></li><li id="3833" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><strong class="lb iu"> <em class="mx">类芒果 F1-得分= 0.11 </em> </strong></li></ul><p id="6618" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，</p><blockquote class="os ot ou"><p id="f3e1" class="kz la mx lb b lc ld ju le lf lg jx lh ov lj lk ll ow ln lo lp ox lr ls lt lu im bi translated"><strong class="lb iu">宏 F1 = (0.40+0.22+0.11)/3 = 0.24 </strong></p></blockquote><h2 id="e118" class="og mf it bd mg oh oi dn mk oj ok dp mo li ol om mq lm on oo ms lq op oq mu or bi translated">加权 F1</h2><p id="7cb2" class="pw-post-body-paragraph kz la it lb b lc nl ju le lf nm jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">最后一个是加权平均 F1 分。与宏 F1 不同，它采用测量值的加权平均值。每个类别的权重是该类别的样本总数。因为我们有 11 个苹果，12 个橘子和 13 个芒果，</p><blockquote class="os ot ou"><p id="d829" class="kz la mx lb b lc ld ju le lf lg jx lh ov lj lk ll ow ln lo lp ox lr ls lt lu im bi translated"><strong class="lb iu">加权 F1 =((0.40 * 11)+(0.22 * 12)+(0.11 * 13))/(11+12+13)= 0.24</strong></p></blockquote></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><p id="9d37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，让我们看一个使用 Python 的 Scikit-learn 计算这些度量的脚本。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="po pp l"/></div></figure><p id="0c95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是脚本的输出。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pq"><img src="../Images/5be6aecfd04dc25e3299ff4f94eaa1c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/format:webp/1*eACrIJOuG05HYTAcLL910g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">信用:<a class="ae ky" href="https://colab.research.google.com/" rel="noopener ugc nofollow" target="_blank">谷歌 Colab </a></p></figure><p id="9c5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mx">注意:</em><a class="ae ky" href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.confusion_matrix.html" rel="noopener ugc nofollow" target="_blank"><em class="mx">Scikit-Learn</em></a><em class="mx">使用行作为“真实类”，使用列作为“预测类”这与我们对苹果、桔子和芒果例子的考虑相反，但在逻辑上是相似的。无论如何，您都可以考虑真实类和预测类。但是如果你使用 Scikit-Learn，那么你必须遵守他们的规则。</em></p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><p id="163a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望你找到了你想要的。感谢阅读。</p></div></div>    
</body>
</html>