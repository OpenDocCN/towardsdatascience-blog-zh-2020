<html>
<head>
<title>5 Ways to Control Attributes in Python. An Example Led Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中控制属性的 5 种方法。Led 指南示例</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/5-ways-to-control-attributes-in-python-an-example-led-guide-2f5c9b8b1fb0?source=collection_archive---------13-----------------------#2020-07-07">https://towardsdatascience.com/5-ways-to-control-attributes-in-python-an-example-led-guide-2f5c9b8b1fb0?source=collection_archive---------13-----------------------#2020-07-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="97a4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在点上发生了什么。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a0eae894e3a02647e4ebd4b271c0dd23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tu0khS5NE6m0GTOqNFJnWQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://unsplash.com/s/photos/learning" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>通过<a class="ae ky" href="https://unsplash.com/@joannakosinska" rel="noopener ugc nofollow" target="_blank"> @joannakosinska </a>提供</p></figure><h2 id="9047" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">介绍</h2><p id="5236" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">可以通过控制属性值及其访问来保护数据完整性。当创建一个类时，我们可能希望确保所有将来的对象都具有正确数据类型的属性，和/或合理/适当的值。我们可能还希望确保一旦设置了属性，就不能更改或删除它们的值。为此，必须创建只读和删除证明属性。</p><p id="ffd0" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">接受姓名、年龄和服务年限作为参数的 Employee 类可能希望确保姓名是一个字符串，年龄和服务年限是整数，然后在创建的对象中将它们设置为属性。这个类可能还希望确保像名称这样的属性不能被修改或删除。</p><p id="d890" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">属性验证可以帮助确保有效的数据输入，即使在类的用户可能输入不太理想的用户信息的情况下，例如，小写的姓名。这篇教程文章将探索 5 种不同的方法来确保属性验证，即通过 magic/dunder 方法和 decorators。当在类中定义的方法中使用属性本身时，属性完整性非常重要。这就是为什么在对象中设置属性之前，应该检查它的值。</p><h2 id="044a" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">示例 1: dunder __setattr_，__delattr__</h2><p id="9e29" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">Python 中的 magic 或 dunder __setattr_ 和 __delattr__ 方法代表了程序员控制属性的一种方式。为了说明，让我们初始化一个名为 Employees 的类。这个类将接受 3 个参数，并将它们设置为对象中的属性。</p><p id="165a" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">为了展示我们如何对属性施加控制，让我们建立我们希望为 Employees 对象实现的行为。</p><ol class=""><li id="8c82" class="mt mu it lx b ly mo mb mp li mv lm mw lq mx mn my mz na nb bi translated">_name 属性值应该是大写的，不管用户是否选择以大写格式输入 name 属性。</li><li id="a0ec" class="mt mu it lx b ly nc mb nd li ne lm nf lq ng mn my mz na nb bi translated">_name 属性应该只允许设置一次。一旦设置好，名称属性将变成只读的<em class="nh"/>。</li><li id="eed9" class="mt mu it lx b ly nc mb nd li ne lm nf lq ng mn my mz na nb bi translated">_age 和 _service_length 属性应该是整数。如果它们不是 TypeError，将引发异常。</li><li id="8a8e" class="mt mu it lx b ly nc mb nd li ne lm nf lq ng mn my mz na nb bi translated">不能删除 _name 属性<em class="nh"/></li></ol><h2 id="e870" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">dunder __setattr__</h2><p id="a17a" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">dunder setattr 方法将对象、键以及我们希望在对象中设置的值作为参数。我们首先检查具有属性' _name '的对象是否已经具有属性 name。如果是这样，我们将引发一个 AttributeError，因为我们不希望 name 属性被<em class="nh">重置</em>。在下面的 elif 语句中，如果对象没有 name 属性，我们将设置它，并使用 string title 方法将其大写。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在第一个 if 语句中，我们首先检查是否已经设置了属性' _name '。如果已经在 __init__ 方法中设置了它，用户将无法重新设置它，然后它将成为一个只读属性。</p></figure><p id="6cfd" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">setattr 方法的第一个 if 和 elif 块中的逻辑解决了上面的第 1 点和第 2 点。现在，让我们检查第 3 点的年龄和服务年限属性的数据类型。</p><p id="7649" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">对于' _age '和' _service_length '属性，我们使用内置的 Python isinstance 函数检查它们的类型是否为 int。如果它们是除 int 之外的任何类型，将引发 TypeError 异常。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="9cfd" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">最后，让我们解决第 4 点，并实现代码来防止名称属性的删除。为了便于讨论，让我们假设，名字一旦被设定，就不能被删除并永久存在。</p><p id="6ce7" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">因此，当我们试图从对象中删除 name 属性时，会引发一个 AttributeError 异常，通知用户不能删除该属性。在幕后，del 关键字调用 __delattr__ 方法。由于我们在类中定义了它，所以它会调用我们的自定义版本 __delattr__。但是，我们仍然允许删除任何其他属性的行为。</p><p id="4a34" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">注意，在所示的代码片段中，我们如下所示设置和删除属性，以避免递归错误。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="a572" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">下面通过 GitHub gist 显示了我们的 Employee 类的代码，可以通过这个<a class="ae ky" href="https://gist.github.com/StephenFordham/74f27d99e6b414fb7bbdebeb415d350a" rel="noopener ugc nofollow" target="_blank">链接</a>获得。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="94d2" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">为了测试我们已经实现的自定义行为，让我们创建一个 Employees 类的实例，并检查 name 属性是否可以设置、不能重置和不能删除。此外，我们可以检查年龄和服务年限属性的类型。</p><p id="18cd" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">重置 name 属性失败，并通知用户程序终止的原因。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/7e7df2c1b0e88609ac230b0752940839.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PnzEJHPUxquSXMHPt8--_Q.png"/></div></div></figure><p id="5873" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">当我们遍历属性字典并打印它们的类型时，我们可以看到年龄和服务年限是 int 类型。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/a23cd4f59e4fbbf65553de7f7d32ff18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*w_7KguVFj2gotR6C-LEXbw.png"/></div></figure><p id="98e0" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">最后，当我们试图删除属性名时，会引发一个 AttributeError 异常，用字符串消息通知用户不能删除该属性。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/dbf33456a7d04ac4b07b7d476e586252.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NMmbmLDSbOG3OgrEqTdj5A.png"/></div></div></figure><p id="4f4f" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我们现在已经成功地制定了我们想要的习俗行为。虽然这些例子是虚构的，但它们确实说明了我们如何使用 Python 中的 setattr 和 delattr 方法来控制属性。如果你想尝试所示的例子，完整的代码可以通过这个<a class="ae ky" href="https://gist.github.com/StephenFordham/0181e32f4c857f3cf533e48bd5fb5ade" rel="noopener ugc nofollow" target="_blank">链接</a>获得。</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h2 id="2058" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">控制对象属性的替代方法</h2><p id="060f" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">以下示例展示了在 Python 中控制属性的替代方法。附带说一句，我并不认为它们是控制属性的最佳方式，相反，替代方式意味着可以增加您在 Python 中使用的工具库。</p><p id="5111" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">下一节将介绍使用 decorators 管理属性的示例指南。</p><h2 id="c106" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">使用装饰者</h2><h2 id="73f8" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">示例 2:使用@staticmethod 装饰器</h2><p id="b183" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">为了保持连续性，在前面的示例中将初始化相同的雇员类。这里，staticmethod decorator 可以用来检查对象中的属性值。具体来说，我们希望 age 和 service_length 属性值都是 int 类型。</p><p id="e276" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">为此，我们可以在我们的类中定义一个 data_type_check 方法，并用 staticmethod decorator 来修饰它。当在 init 构造函数中设置属性时，我们调用对象上的 data_type_check 方法，并传入 age 或 service_length 作为参数。如果年龄和服务年限是 int 类型，它们将被返回并设置为我们的对象中的属性。如果它们不是 int 类型，将引发类型错误异常。</p><p id="e5eb" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">使用 staticmethod 装饰器的一个好处是它的可重用性。例如，如果我们在 init 方法中添加了一个 annual bonus 参数，我们可以简单地再次调用 staticmethod decorator 并将 bonus 作为参数传递。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h2 id="a088" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">示例 3:使用自定义装饰器</h2><p id="8574" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">另一种控制属性值的方法是通过一个<em class="nh">自定义</em>装饰器。为了与我们的主题保持一致，让我们创建同一个类，但是这次用一个名为 attr_check 的函数来修饰 init 构造函数方法。</p><p id="b594" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">当我们创建 Employee 类的实例时，init 方法将被自动调用。当 attr_check 函数修饰 init 方法时，将调用这个函数。attr_check 将 init 方法作为参数，并返回 inner。当我们用我们的对象 ref、age 和 service 调用 inner 时，我们可以对 age 和 service 执行类型检查。如果年龄和服务的类型是 int，我们将返回带有对象、名称、年龄和服务以及参数的原始 init 方法。</p><p id="98b6" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">这个实现是用 Python 控制属性值的好方法，因为我们可以选择什么进入 inner 的主体。在这种情况下，我们没有对姓名执行任何类型检查，也没有对年龄执行任何范围限制，但是我们可以通过扩展内部函数中定义的代码来简单地添加这些检查。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h2 id="1ab6" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">示例 4:使用@property/setter/deleter 装饰器</h2><p id="14c4" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">Python 中控制属性值的另一种方法是使用属性装饰器及其相应的 setter 和 deleter 方法。</p><p id="4b3b" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">让我们再次创建我们的雇员类。当用户试图通过 object.attribute 语法访问 name 属性时，将用@property 修饰的 name 方法将被调用，名称将以大写形式返回。</p><p id="7d04" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">这一次，如果用户想要更改 name 属性，让我们确保他们输入的任何字符串都是大写的。我们可以通过定义一个简单的 name 方法以及相应的 setter 和 deleter 方法来实现这一点。</p><p id="97ec" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我们定义了 name 方法，并用@name.setter 修饰它。当用户想要使用 object.attribute 语法设置一个新名称时，对象中设置的新名称现在将被大写。</p><p id="2186" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">注意，名称属性' _name '的基础名称不同于方法的名称，以避免递归错误。我们不能在 setter 方法的主体中包含 self.name = new_name.title()。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h2 id="47cb" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">示例 init 构造函数中的条件检查</h2><p id="68a5" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">结束这篇关于属性控制的文章，实现属性完整性的最简单的方法实际上可能是在类本身的 init 构造函数中包含条件检查。这里，我们允许员工的年龄大于或等于 18 岁，小于或等于 100 岁。如果满足条件，我们可以将 init 方法中作为参数提供的年龄设置为对象中的属性值。当创建的实例不满足此条件时，将引发 AttributeError 异常，并通过一条有用的字符串消息通知用户所需的条件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h2 id="de36" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">摘要</h2><p id="0167" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">感谢您的阅读，我希望您喜欢控制属性访问及其值的不同方式。虽然我主要关注的是数据类型检查和范围允许，但是任何可以想象到的条件都可以施加在属性值上。电子邮件地址在设置前可能会使用 regex 进行验证，以符合数据完整性。</p><p id="6f4f" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我在这里特意使用了一些基本的例子来帮助传达控制属性值和访问的多种方法是如何工作的。此外，描述符是 Python 中管理属性的另一种方式，我希望能写一篇关于如何使用它们的教程。如果你有任何问题，或者想要更多关于这个主题的文章，请通过 LinkedIn 告诉我。</p></div></div>    
</body>
</html>