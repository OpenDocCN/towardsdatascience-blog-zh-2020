<html>
<head>
<title>The Right Way to Build an API with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Python 构建 API 的正确方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-right-way-to-build-an-api-with-python-cd08ab285f8f?source=collection_archive---------0-----------------------#2020-09-11">https://towardsdatascience.com/the-right-way-to-build-an-api-with-python-cd08ab285f8f?source=collection_archive---------0-----------------------#2020-09-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1e13" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关于 Flask 中的 API 开发，您需要了解的所有内容</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7c040bad2488409dac767e853edd1bce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OH7EQ1SY8NdafTWG"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@steve_j?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">斯蒂夫·约翰森</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="8c7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated">我们如何建立一种从一个软件实例到另一个软件实例的通信方式？这听起来很简单，而且——说实话——确实如此。</p><p id="85a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们只需要一个 API。</p><p id="995f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">API(应用编程接口)是一个简单的接口，它定义了请求的类型(需求/问题等)。)能做的，怎么做的，怎么加工的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="me mf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Flask API 视频演练——涵盖了本文中的所有内容！</p></figure><p id="eb8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的例子中，我们将构建一个 API，它允许我们向不同的端点发送一系列 GET/POST/PUT/PATCH/DELETE 请求(稍后将详细介绍)，并返回或修改连接到我们的 API 的数据。</p><p id="2b6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用 Flask 框架来创建我们的 API 和 Postman 来测试它。简而言之，我们将涵盖:</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="2a02" class="ml mm it mh b gy mn mo l mp mq"><strong class="mh iu">&gt; Setup</strong><br/>  - Our Toy Data<br/>  - Initialize a Flask API<br/>  - Endpoints<br/>  - Running a Local Server<br/><strong class="mh iu">&gt; Writing Our API</strong><br/>  - GET<br/>  - POST<br/>  - 401 Unauthorized<br/>  - PUT<br/>  - DELETE<br/>  - Users Class (summary)<br/><strong class="mh iu">&gt; That's It!</strong></span></pre></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="b36c" class="my mm it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">设置</h1><p id="2484" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">我们的 API 将包含两个端点，<code class="fe nu nv nw mh b">users</code>和<code class="fe nu nv nw mh b">locations</code>。前者将允许访问我们的注册用户的详细资料，而后者将包括咖啡馆的位置列表。</p><p id="4286" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里假设的用例是一个数百万的咖啡馆书签应用程序，用户打开应用程序，将他们最喜欢的咖啡馆加入书签——像谷歌地图，但没有用。</p><h2 id="de52" class="ml mm it bd mz nx ny dn nd nz oa dp nh li ob oc nj lm od oe nl lq of og nn oh bi translated">我们的玩具数据</h2><p id="2c3b" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">为了简单起见，我们将这些数据存储在两个本地 CSV 文件中。实际上，您可能想看看 MongoDB 或 Google Firebase 之类的东西。</p><p id="e250" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的 CSV 文件如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/d236042a73046e2cd17481f34e22cc0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/format:webp/1*GD43z77-hcTdRf-bo6DI7w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://drive.google.com/file/d/12-nW-R6TEPbUzSVF8zsQtOm992TdZOqj/view?usp=sharing" rel="noopener ugc nofollow" target="_blank"> users.csv </a>中的用户数据。图片作者。</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/63a8b0ae10f25ea30b91e87369e375a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*_MBLDmI8ULvYDo49FkpuDA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://drive.google.com/file/d/1ERGeiKZLNuD9K-MHd7a0Colqj_DqiMww/view?usp=sharing" rel="noopener ugc nofollow" target="_blank"> locations.csv </a>中的位置映射。图片作者。</p></figure><p id="1bc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在这里下载<a class="ae ky" href="https://drive.google.com/file/d/12-nW-R6TEPbUzSVF8zsQtOm992TdZOqj/view?usp=sharing" rel="noopener ugc nofollow" target="_blank">users . CSV</a>，在这里下载<a class="ae ky" href="https://drive.google.com/file/d/1ERGeiKZLNuD9K-MHd7a0Colqj_DqiMww/view?usp=sharing" rel="noopener ugc nofollow" target="_blank">locations . CSV</a>。</p><h2 id="982d" class="ml mm it bd mz nx ny dn nd nz oa dp nh li ob oc nj lm od oe nl lq of og nn oh bi translated">初始化烧瓶 API</h2><p id="5fe7" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">现在，对于我们的 Python 脚本，我们需要导入模块并初始化我们的 API，如下所示:</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="e62e" class="ml mm it mh b gy mn mo l mp mq">from flask import Flask<br/>from flask_restful import Resource, Api, reqparse<br/>import pandas as pd<br/>import ast</span><span id="0a59" class="ml mm it mh b gy ok mo l mp mq">app = Flask(__name__)<br/>api = Api(app)</span></pre><h2 id="6e34" class="ml mm it bd mz nx ny dn nd nz oa dp nh li ob oc nj lm od oe nl lq of og nn oh bi translated">端点</h2><p id="d120" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">正如我们已经提到的，我们的 API 将有两个端点，<code class="fe nu nv nw mh b">users</code>和<code class="fe nu nv nw mh b">locations</code>。</p><p id="b467" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样做的结果是——如果我们的 API 位于<code class="fe nu nv nw mh b">www.api.com</code>,那么与<code class="fe nu nv nw mh b">Users</code>类的通信将在<code class="fe nu nv nw mh b">www.api.com<strong class="lb iu">/users</strong></code>提供，而<code class="fe nu nv nw mh b">Locations</code>将在<code class="fe nu nv nw mh b"><a class="ae ky" href="http://www.api.com/locations." rel="noopener ugc nofollow" target="_blank">www.api.com<strong class="lb iu">/locations</strong></a></code> <a class="ae ky" href="http://www.api.com/locations." rel="noopener ugc nofollow" target="_blank">提供。</a></p><p id="7a80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了创建一个端点，我们定义了一个 Python 类(可以使用任何名称)并用<code class="fe nu nv nw mh b">api.add_resource</code>将它连接到我们想要的端点，就像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol mf l"/></div></figure><ul class=""><li id="3abb" class="om on it lb b lc ld lf lg li oo lm op lq oq lu or os ot ou bi translated">Flask 需要知道这个类是我们 API 的一个端点，所以我们用类定义传入<code class="fe nu nv nw mh b">Resource</code>。</li><li id="e3fc" class="om on it lb b lc ov lf ow li ox lm oy lq oz lu or os ot ou bi translated">在类内部，我们包含了我们的 HTTP 方法(GET、POST、DELETE 等。).</li><li id="3b74" class="om on it lb b lc ov lf ow li ox lm oy lq oz lu or os ot ou bi translated">最后，我们使用<code class="fe nu nv nw mh b">api.add_resource</code>将我们的<code class="fe nu nv nw mh b">Users</code>类与<code class="fe nu nv nw mh b">/users</code>端点链接起来。</li></ul><p id="6ddc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们想要<strong class="lb iu">两个</strong>端点，所以我们复制逻辑:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol mf l"/></div></figure><h2 id="a727" class="ml mm it bd mz nx ny dn nd nz oa dp nh li ob oc nj lm od oe nl lq of og nn oh bi translated">运行本地服务器</h2><p id="3737" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">最后，当我们写出我们的 API 时，我们需要测试它！</p><p id="1b02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要做到这一点，我们需要托管我们的 API，我们可以通过在脚本末尾添加<code class="fe nu nv nw mh b">app.run</code>来本地完成，如下所示:</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="9b30" class="ml mm it mh b gy mn mo l mp mq">if __name__ == '__main__':<br/>    app.run()  # run our Flask app</span></pre><p id="6c37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，当我们运行我们的脚本时，我们应该看到类似这样的内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/47e7daca3f3b820cae8bce80da04e933.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xCq-U94HoNJbaTnkQ2UkoA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">本地主机服务器的初始化。图片作者。</p></figure><p id="1787" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们的服务器设置好了，我们就可以在使用 Postman 构建 API 时对其进行测试，如果您以前没有使用过它的话，因为它是 API 测试的事实标准。别担心——使用起来非常简单——从<a class="ae ky" href="https://www.postman.com/downloads/" rel="noopener ugc nofollow" target="_blank">这里</a>下载 Postman。</p><p id="492d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在继续之前，你可以在这里找到我们将要构建的<a class="ae ky" href="https://gist.github.com/jamescalam/0b309d275999f9df26fa063602753f73" rel="noopener ugc nofollow" target="_blank">的完整脚本。如果您不确定代码片段应该放在哪里，请查看那里！</a></p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="b794" class="my mm it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">编写 API 方法</h1><p id="9156" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">在每个类中，我们保留了 HTTP 方法 GET、POST 和 DELETE。</p><p id="ea6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了创建一个 GET 方法，我们使用<code class="fe nu nv nw mh b">def get(self)</code>。POST 和 DELETE 遵循相同的模式。</p><h2 id="26fd" class="ml mm it bd mz nx ny dn nd nz oa dp nh li ob oc nj lm od oe nl lq of og nn oh bi translated">得到</h2><p id="b38f" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">GET 方法是最简单的。我们返回所有存储在<code class="fe nu nv nw mh b">users.csv</code>中的数据，这些数据被包装在一个字典中，就像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol mf l"/></div></figure><p id="cc46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以运行脚本来初始化我们的 API，打开 Postman 并向我们的本地主机地址(通常是<code class="fe nu nv nw mh b"><a class="ae ky" href="http://127.0.0.1:5000)" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:5000</a></code>)发送 GET 请求——这是我们的 API <em class="pb">入口点</em>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/0405d522bf003bdff9639ef3621b0b40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pw9vclEEpWyLYQJ_q-EBiA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">如何向我们的 API 发送 GET 请求。图片作者。</p></figure><p id="c7d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要在 Postman 中向我们的 API 发送 GET 请求，我们:</p><ol class=""><li id="d3ef" class="om on it lb b lc ld lf lg li oo lm op lq oq lu pd os ot ou bi translated">从下拉列表中选择获取</li><li id="6faa" class="om on it lb b lc ov lf ow li ox lm oy lq oz lu pd os ot ou bi translated">键入我们的 API 实例+ <code class="fe nu nv nw mh b">/users</code>(端点<em class="pb"/>)的入口点</li><li id="053d" class="om on it lb b lc ov lf ow li ox lm oy lq oz lu pd os ot ou bi translated">点击<strong class="lb iu">发送</strong></li><li id="e584" class="om on it lb b lc ov lf ow li ox lm oy lq oz lu pd os ot ou bi translated">检查我们的 API 返回的状态代码(我们应该看到<code class="fe nu nv nw mh b">200 OK</code>)</li><li id="b300" class="om on it lb b lc ov lf ow li ox lm oy lq oz lu pd os ot ou bi translated">查看我们的 API 的响应，是 JSON <em class="pb">(像字典)</em>格式的<code class="fe nu nv nw mh b">users.csv</code></li></ol><h2 id="e629" class="ml mm it bd mz nx ny dn nd nz oa dp nh li ob oc nj lm od oe nl lq of og nn oh bi translated">邮政</h2><p id="2902" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">POST 方法允许我们向数据中添加记录。在这种情况下，我们将采用<code class="fe nu nv nw mh b">usedId</code>、<code class="fe nu nv nw mh b">name</code>和<code class="fe nu nv nw mh b">city</code>的参数。</p><p id="44f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些参数作为 URL 参数传递给我们的 API 端点，如下所示:</p><pre class="kj kk kl km gt mg mh mi mj aw mk bi"><span id="20ba" class="ml mm it mh b gy mn mo l mp mq"><a class="ae ky" href="http://127.0.0.1:5000/users?userId=abc123&amp;name=The" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:5000/users<strong class="mh iu">?userId=abc123&amp;name=The</strong></a><strong class="mh iu"> Rock&amp;city=Los Angeles</strong></span></pre><p id="2119" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以指定所需的参数，然后使用<code class="fe nu nv nw mh b">reqparse</code>解析提供的值，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol mf l"/></div></figure><p id="b28b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们分解一下解析器代码:</p><ul class=""><li id="85d8" class="om on it lb b lc ld lf lg li oo lm op lq oq lu or os ot ou bi translated">我们用<code class="fe nu nv nw mh b">.RequestParser()</code>初始化我们的解析器。</li><li id="e95e" class="om on it lb b lc ov lf ow li ox lm oy lq oz lu or os ot ou bi translated">用<code class="fe nu nv nw mh b">.add_argument([arg_name], required)</code>添加我们的参数——注意<code class="fe nu nv nw mh b">required=True</code>意味着参数在请求中是必需的。或者，我们可以用<code class="fe nu nv nw mh b">required=False</code>添加可选参数。</li><li id="6797" class="om on it lb b lc ov lf ow li ox lm oy lq oz lu or os ot ou bi translated">使用<code class="fe nu nv nw mh b">.parse_args()</code>将我们的参数及其值解析到一个 Python 字典中。</li></ul><p id="871e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以访问传递给每个参数的值，就像我们通常在字典中访问键值对一样。</p><p id="2459" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们将这些放在一起，为我们的 CSV 增加价值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol mf l"/></div></figure><p id="7a4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果它开始看起来有点混乱，我们所做的就是:</p><ul class=""><li id="6553" class="om on it lb b lc ld lf lg li oo lm op lq oq lu or os ot ou bi translated">从 URL 参数<code class="fe nu nv nw mh b">args</code>创建一行新数据<code class="fe nu nv nw mh b">new_data</code></li><li id="2d25" class="om on it lb b lc ov lf ow li ox lm oy lq oz lu or os ot ou bi translated">将其附加到预先存在的<code class="fe nu nv nw mh b">data</code></li><li id="6fb5" class="om on it lb b lc ov lf ow li ox lm oy lq oz lu or os ot ou bi translated">保存新合并的数据</li><li id="c9a4" class="om on it lb b lc ov lf ow li ox lm oy lq oz lu or os ot ou bi translated">并且，返回<code class="fe nu nv nw mh b">data</code>和一个<code class="fe nu nv nw mh b">200 OK</code>状态码。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/684bd73c515af54e1b6d00d447a7b9e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6TaG3fZ70HA4lgmfxtTOww.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们通过向我们的/用户端点发送包含<strong class="bd pf"> userId </strong>、<strong class="bd pf"> name </strong>和<strong class="bd pf"> city </strong>参数的<strong class="bd pf"> POST </strong>请求来创建一个新用户。图片作者。</p></figure><p id="f27d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以发送一个<strong class="lb iu"> POST </strong>请求来创建一个新用户，很简单！</p><h2 id="43c5" class="ml mm it bd mz nx ny dn nd nz oa dp nh li ob oc nj lm od oe nl lq of og nn oh bi translated">401 未经授权</h2><p id="a598" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">我们的代码处理<strong class="lb iu"> POST </strong>请求，允许我们向<code class="fe nu nv nw mh b">users.csv</code>写入新数据——但是如果那个用户已经存在了呢？</p><p id="2cf8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们需要添加一个检查。如果<code class="fe nu nv nw mh b">userId</code>已经存在，我们返回一个<code class="fe nu nv nw mh b">401 Unauthorized</code>代码给用户。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol mf l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/f12f970feff469413317ebdd6bd7e3ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BCJr5I7UvevD8VKlgsrMUQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">如果我们尝试用用户 id“ABC 123”再次发布，我们将返回以下 401 未授权状态代码和消息。图片作者。</p></figure><p id="fce6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到 Postman，我们可以通过尝试添加同一个用户两次来测试我们的 API 是否正常工作——这一次，Rock 收到了一个<code class="fe nu nv nw mh b">401 Unauthorized</code>响应。</p><h2 id="6cc6" class="ml mm it bd mz nx ny dn nd nz oa dp nh li ob oc nj lm od oe nl lq of og nn oh bi translated">放</h2><p id="0220" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">如果我们想给一个用户添加一个咖啡馆呢？我们不能使用<strong class="lb iu"> POST </strong>，因为这会返回一个<code class="fe nu nv nw mh b">401 Unauthorized</code>代码——相反，我们使用<strong class="lb iu"> PUT </strong>。</p><p id="3479" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与<strong class="lb iu"> POST </strong>类似，我们需要在提供的<code class="fe nu nv nw mh b">userId</code>不存在的情况下增加 if-else 逻辑。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol mf l"/></div></figure><p id="fb75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了对代码做了一些小的调整，我们的<strong class="lb iu"> PUT </strong>方法与<strong class="lb iu"> POST </strong>几乎相同。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ph"><img src="../Images/a7fc8caf4c5b2545dff2d9d033ecb37e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M8Q3MFr5CQCrGDuJ3V5zyg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这里我们使用<strong class="bd pf"> PUT </strong>方法将 ID 为 0007 的咖啡馆添加到 Rock 的书签位置。图片作者。</p></figure><p id="3f2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到 Postman，我们需要的输入参数已经改变。现在，我们只需要<code class="fe nu nv nw mh b">userId</code>和一个<code class="fe nu nv nw mh b">location</code>来添加到用户书签<code class="fe nu nv nw mh b">locations</code>中。</p><h2 id="c5f6" class="ml mm it bd mz nx ny dn nd nz oa dp nh li ob oc nj lm od oe nl lq of og nn oh bi translated">删除</h2><p id="8a54" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">我们也可以用<strong class="lb iu"> DELETE </strong>方法删除记录。</p><p id="fdf9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个方法非常简单，我们需要指定一个<code class="fe nu nv nw mh b">userId</code>来移除，并在不存在<code class="fe nu nv nw mh b">userId</code>的情况下添加一些 if-else 逻辑。</p><p id="f98a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，如果<code class="fe nu nv nw mh b">Jill</code>认为我们的应用程序毫无用处，想要离开，我们会发送一个包含她的<code class="fe nu nv nw mh b">userId</code>的<strong class="lb iu">删除</strong>请求。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pi"><img src="../Images/4916563479a2afd83d9343af1c2f103c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1M2jvRuYuLz0nWG7bcQJxQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">发送针对<strong class="bd pf">用户 id‘B2C’</strong>的<strong class="bd pf">删除</strong>请求，从我们的用户数据中删除 Jill 的记录。图片作者。</p></figure><p id="5a24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以在 Postman 中测试这一点，不出所料，我们返回的数据没有 Jill 的记录。如果我们尝试删除一个不存在的用户会怎么样？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pj"><img src="../Images/f621c49ef052cc16a82a6e295aad4a56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AYq_65E2QpPDzlYOk0pvDA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">如果我们<strong class="bd pf">删除</strong>一个不存在的<strong class="bd pf">用户标识</strong>，我们将收到一个<strong class="bd pf"> 404 未找到</strong>状态代码和一条解释用户标识不存在的消息。图片作者。</p></figure><p id="607c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们再次收到我们的<code class="fe nu nv nw mh b">404 Not Found</code>和一条简短的消息，说明没有找到<code class="fe nu nv nw mh b">userId</code>。</p><h2 id="b942" class="ml mm it bd mz nx ny dn nd nz oa dp nh li ob oc nj lm od oe nl lq of og nn oh bi translated">用户类别</h2><p id="1368" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">这是组成<code class="fe nu nv nw mh b">Users</code>类的所有部分，通过我们的<code class="fe nu nv nw mh b">/users</code>端点访问。你可以在这里找到<a class="ae ky" href="https://gist.github.com/jamescalam/0b309d275999f9df26fa063602753f73" rel="noopener ugc nofollow" target="_blank">的完整脚本</a>。</p><p id="acac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后还需要把<code class="fe nu nv nw mh b">Locations</code>类拼起来。这个类应该允许我们获取、发布、修补(更新)和删除位置。</p><p id="7a4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个位置都有一个唯一的 ID——当用户将一个位置加入书签时，这个唯一的 ID 会被添加到他们的带有<code class="fe nu nv nw mh b">PUT /users</code>的<code class="fe nu nv nw mh b">locations</code>列表中。</p><p id="a73d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个的代码和我们在<code class="fe nu nv nw mh b">Users</code>类中写的没有太大的不同，所以我们不会重复。然而，你可以在<code class="fe nu nv nw mh b">Users</code>级<a class="ae ky" href="https://gist.github.com/jamescalam/0b309d275999f9df26fa063602753f73" rel="noopener ugc nofollow" target="_blank">旁边找到它。</a></p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="875b" class="my mm it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">就是这样！</h1><p id="5219" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">就这么简单。用 Flask 和 Python 建立一个 API 非常简单。</p><p id="90ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在有了一个易于使用的标准化方法来在不同的接口之间进行通信。</p><p id="90ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经讨论了所有最常见的请求方法——GET、POST、PUT 和 DELETE——以及一些 HTTP 状态代码——200、401 和 404。</p><p id="1734" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们已经学会了如何在本地托管我们的 API，并使用 Postman 测试它——允许我们快速诊断问题，并确保我们的 API 按预期运行。</p><p id="e352" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总而言之，API 开发对于开发人员、数据科学家以及你能想象到的几乎任何其他技术倾向的角色来说都是一项至关重要的技能。</p><p id="24c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想要更多，我在<a class="ae ky" href="https://www.youtube.com/channel/UCv83tO5cePwHMt1952IVVHw" rel="noopener ugc nofollow" target="_blank"> YouTube 这里</a>发布编程教程。或者，如果您有任何问题或改进的想法，请在<a class="ae ky" href="https://twitter.com/jamescalam" rel="noopener ugc nofollow" target="_blank"> Twitter </a>或下面的评论中告诉我。</p><p id="550b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢这篇文章，感谢你的阅读！</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h2 id="8ad6" class="ml mm it bd mz nx ny dn nd nz oa dp nh li ob oc nj lm od oe nl lq of og nn oh bi translated"><a class="ae ky" href="https://bit.ly/nlp-transformers" rel="noopener ugc nofollow" target="_blank">🤖《变形金刚》课程 NLP 的 70%折扣</a></h2></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><p id="59fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想在 API 开发中采取下一步措施并与世界分享您的成果吗？点击此处了解谷歌云平台的 API 部署:</p><div class="pk pl gp gr pm pn"><a rel="noopener follow" target="_blank" href="/how-to-deploy-a-flask-api-8d54dd8d8b8a"><div class="po ab fo"><div class="pp ab pq cl cj pr"><h2 class="bd iu gy z fp ps fr fs pt fu fw is bi translated">如何部署 Flask API</h2><div class="pu l"><h3 class="bd b gy z fp ps fr fs pt fu fw dk translated">将您的 API 部署到 Google 云平台</h3></div><div class="pv l"><p class="bd b dl z fp ps fr fs pt fu fw dk translated">towardsdatascience.com</p></div></div><div class="pw l"><div class="px l py pz qa pw qb ks pn"/></div></div></a></div></div></div>    
</body>
</html>