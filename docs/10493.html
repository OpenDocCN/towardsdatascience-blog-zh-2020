<html>
<head>
<title>Automating the DCF Valuation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自动化 DCF 估价</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/automating-the-dcf-valuation-35abde04cdb9?source=collection_archive---------13-----------------------#2020-07-23">https://towardsdatascience.com/automating-the-dcf-valuation-35abde04cdb9?source=collection_archive---------13-----------------------#2020-07-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="aeeb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用蒙特卡罗模拟预测财务状况</h2></div><p id="ce23" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">DCF(贴现现金流)估值模型可能是金融专业人士拥有的最重要的金融工具。这种模型在理论和实践上都很棒，但是传统上在 excel 中执行，它有时在功能上相当繁琐。幸运的是，使用 Python，我们可以自动化这些评估步骤，然后更进一步，创建一个蒙特卡罗模拟函数，用于可视化潜在 DCF 结果的分布。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/3db3552147d3887d93cc6386339fd144.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jNXi_lXTAHYhpwLx"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">在<a class="ae lu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae lu" href="https://unsplash.com/@kmuza?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Carlos Muza </a>拍摄的照片</p></figure><pre class="lf lg lh li gt lv lw lx ly aw lz bi"><span id="285b" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">import</strong> numpy <strong class="lw iu">as</strong> np<br/><strong class="lw iu">import</strong> pandas <strong class="lw iu">as</strong> pd<br/><strong class="lw iu">import</strong> matplotlib.pyplot <strong class="lw iu">as</strong> plt<br/>%matplotlib inline</span></pre><p id="1083" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们首先需要的是对我们年销售额的预测。我们将创建一个未来六年的数据框架，从理论上讲，它将从以前的财务报表中结转初始销售数据。</p><pre class="lf lg lh li gt lv lw lx ly aw lz bi"><span id="b2b5" class="ma mb it lw b gy mc md l me mf">years = ['2020A', '2021B', '2022P', '2023P', '2024P', '2025P']<br/>sales = pd.Series(index=years)<br/>sales['2018A'] = 31.0  <br/>sales</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/baef7094bb9a88d9a8f27049defcdef9.png" data-original-src="https://miro.medium.com/v2/resize:fit:328/format:webp/1*AJJ7uHRF1tIk5BlWzAJRag.png"/></div></figure><p id="2906" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们现在已经构建了未来五年的销售增长(注:“A”=实际；“B”=预算；“P”=预计)。现在，我们将把预计的年度销售增长用于未来的预测。最终，我们可以用概率分布来代替这些估计，从而得到更真实的预测。</p><pre class="lf lg lh li gt lv lw lx ly aw lz bi"><span id="5cba" class="ma mb it lw b gy mc md l me mf">growth_rate = 0.1</span><span id="fd33" class="ma mb it lw b gy mh md l me mf"><strong class="lw iu">for</strong> year <strong class="lw iu">in</strong> range(1, 6):<br/>    sales[year] = sales[year - 1] * (1 + growth_rate)<br/>    <br/>sales</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/edb459448660e855b3046bfd57ebbb55.png" data-original-src="https://miro.medium.com/v2/resize:fit:464/format:webp/1*cLpFCRVu_MNukzozcPW0mg.png"/></div></figure><p id="fa17" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">类似地，我们现在需要为 DCF 模型中的所有关键变量分配值或公式。这些变量将保持标准的财务定义。(注意:纳税将需要一个额外的 lambda 函数，以确保如果税前利润为负，我们就不会有正的纳税)。</p><pre class="lf lg lh li gt lv lw lx ly aw lz bi"><span id="77ec" class="ma mb it lw b gy mc md l me mf">ebitda_margin = 0.14<br/>depr_percent = 0.032<br/>ebitda = sales * ebitda_margin<br/>depreciation = sales * depr_percent<br/>ebit = ebitda - depreciation<br/>nwc_percent = 0.24<br/>nwc = sales * nwc_percent<br/>change_in_nwc = nwc.shift(1) - nwc <br/>capex_percent = depr_percent<br/>capex = -(sales * capex_percent)<br/>tax_rate = 0.25<br/>tax_payment = -ebit * tax_rate<br/>tax_payment = tax_payment.apply(<strong class="lw iu">lambda</strong> x: min(x, 0))<br/>free_cash_flow = ebit + depreciation + tax_payment + capex + change_in_nwc</span><span id="d7e7" class="ma mb it lw b gy mh md l me mf"><br/>free_cash_flow</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/4dd166143b00ce7fb4b59c27f1f59388.png" data-original-src="https://miro.medium.com/v2/resize:fit:424/format:webp/1*VbugdW7ck0kUSe9u7uP3_w.png"/></div></figure><p id="02fa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们现在有了预计的自由现金流(百万)。现在我们有了 FCF，我们可以开始实际的 DCF 估值模型。我们将计算终值，并将所有现金流贴现回现在。</p><pre class="lf lg lh li gt lv lw lx ly aw lz bi"><span id="453b" class="ma mb it lw b gy mc md l me mf">cost_of_capital = 0.12<br/>terminal_growth = 0.02</span><span id="97f5" class="ma mb it lw b gy mh md l me mf">terminal_value = ((free_cash_flow[-1] * (1 + terminal_growth)) / <br/>                 (cost_of_capital - terminal_growth))</span><span id="d2f2" class="ma mb it lw b gy mh md l me mf">discount_factors = [(1 / (1 + cost_of_capital)) ** i <strong class="lw iu">for</strong> i <strong class="lw iu">in</strong> range (1,6)]</span><span id="f669" class="ma mb it lw b gy mh md l me mf">dcf_value = (sum(free_cash_flow[1:] * discount_factors) +<br/>            terminal_value * discount_factors[-1])</span></pre><p id="e0da" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了便于查看，让我们将这些变量打包成一个熊猫数据帧:</p><pre class="lf lg lh li gt lv lw lx ly aw lz bi"><span id="b8e6" class="ma mb it lw b gy mc md l me mf">output = pd.DataFrame([sales, ebit, free_cash_flow],<br/>                     index=['Sales', 'EBIT', 'Free Cash Flow']).round(1)</span><span id="9dba" class="ma mb it lw b gy mh md l me mf">output</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/89b4c5f2e9a0fe7a60b5d33966c81e59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*J7vyLa1GfseY5IJ_LZfvmA.png"/></div></figure><h1 id="3031" class="ml mb it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">创建蒙特卡洛模拟</h1><p id="d3ff" class="pw-post-body-paragraph ki kj it kk b kl nc ju kn ko nd jx kq kr ne kt ku kv nf kx ky kz ng lb lc ld im bi translated">因为我们对 DCF 模型变量使用了硬编码值，所以我们没有一个非常健壮的模型。幸运的是，我们可以通过引入蒙特卡罗模拟来改进这一点，该模拟将使用正态分布来随机生成和采样大量变量输入，然后将它们绘制成分布图。我们使用 numpy 来生成这些随机样本，然后迭代 10，000 次。</p><pre class="lf lg lh li gt lv lw lx ly aw lz bi"><span id="da7d" class="ma mb it lw b gy mc md l me mf">iterations = 10000</span><span id="e2c0" class="ma mb it lw b gy mh md l me mf"><strong class="lw iu">def</strong> <strong class="lw iu">run_mcs</strong>():<br/>    <br/>    <em class="nh"># Create probability distributions</em><br/>    sales_growth_dist = np.random.normal(loc=0.1, scale=0.01, size=iterations)<br/>    ebitda_margin_dist = np.random.normal(loc=0.14, scale=0.02, size=iterations)<br/>    nwc_percent_dist = np.random.normal(loc=0.24, scale=0.01, size=iterations)<br/>    <br/>    <em class="nh"># Calculate DCF value for each set of random inputs</em><br/>    output_distribution = []<br/>    <strong class="lw iu">for</strong> i <strong class="lw iu">in</strong> range(iterations):<br/>        <strong class="lw iu">for</strong> year <strong class="lw iu">in</strong> range(1, 6):<br/>            sales[year] = sales[year - 1] * (1 + sales_growth_dist[0])<br/>        ebitda = sales * ebitda_margin_dist[i]<br/>        depreciation = (sales * depr_percent)<br/>        ebit = ebitda - depreciation<br/>        nwc = sales * nwc_percent_dist[i]<br/>        change_in_nwc = nwc.shift(1) - nwc <br/>        capex = -(sales * capex_percent)<br/>        tax_payment = -ebit * tax_rate<br/>        tax_payment = tax_payment.apply(<strong class="lw iu">lambda</strong> x: min(x, 0))<br/>        free_cash_flow = ebit + depreciation + tax_payment + capex + change_in_nwc<br/>        <br/>        <em class="nh"># DCF valuation</em><br/>        terminal_value = (free_cash_flow[-1] * 1.02) / (cost_of_capital - 0.02)<br/>        free_cash_flow[-1] += terminal_value<br/>        discount_factors = [(1 / (1 + cost_of_capital)) ** i <strong class="lw iu">for</strong> i <strong class="lw iu">in</strong> range (1,6)]<br/>        dcf_value = sum(free_cash_flow[1:] * discount_factors )<br/>        output_distribution.append(dcf_value)<br/>    <br/>    <strong class="lw iu">return</strong> output_distribution</span></pre><p id="029c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们绘制这个模拟图时:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/701611c4233058d570f84b5628a310db.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/format:webp/1*UNeCw-0u2pJMygR7m2fj4A.png"/></div></figure><p id="13ff" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个输出图向我们显示，当迭代 10，000 个模型输入变量的潜在组合时，我们的贴现现金流值最常见的是在 2，300-2，500 万左右。</p><p id="03e3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是一个非常基本的介绍，介绍了 Python 在自动化金融操作方面的强大功能，但是蒙特卡洛模拟清楚地展示了这种强大的计算能力，它给了我们我们开始寻找的最终数字。请关注未来的帖子，这些帖子将进一步详细介绍如何使用 Python 实现日常财务任务的自动化。</p></div></div>    
</body>
</html>