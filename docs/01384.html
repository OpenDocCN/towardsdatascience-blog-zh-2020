<html>
<head>
<title>Machine-Learning In Julia is FINALLY Getting Better</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">朱莉娅的机器学习终于有所进步</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/machine-learning-in-julia-is-finally-getting-better-ab5cac68015b?source=collection_archive---------14-----------------------#2020-02-07">https://towardsdatascience.com/machine-learning-in-julia-is-finally-getting-better-ab5cac68015b?source=collection_archive---------14-----------------------#2020-02-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d57b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">最近的软件包开发使数据处理变得切实可行。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d6173185dfc02f58e525d65c16d67ad5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IUC4K5txS-QqRVZt8Q4uZQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(src = julia-lang.org)</p></figure><p id="4ddd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi lu translated">自从我第一次开始使用Julia，我和其他许多来自Python和R等具有强大生态系统的语言的叛逃者都有一个问题，那就是数据处理。在Julia中，数据处理似乎被忽视了，通常用单独的包来解决一个问题，而有些问题则被完全忽略了。有时已经有可用的函数，但是它们非常难以使用，要求您在通过任何预处理算法之前断言类型并转换数据。由于这个原因，不仅训练一个模型很困难，而且将一个模型放入一个管道并部署它也是完全不可能的。</p><p id="15a4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，随着Julia开发人员所取得的超前和令人兴奋的进步，预处理已经比我原先想象的可能发展得更远。因此，Julia已经成为机器学习的一个更可行的选择。随着对Genie及其相应文档的大量添加，部署API已经成为一种</p><blockquote class="md"><p id="a246" class="me mf it bd mg mh mi mj mk ml mm lt dk translated">蛋糕漫步。</p></blockquote><p id="e304" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">Genie为您管理所有的虚拟环境，现在文档已经发布，并由出色的开发人员Essenciary (Adrian Salceanu)不断改进，使Julia更适合作为日常web框架使用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/23bb6fdfe2d72c35491c970fde228974.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*DK4bEoBjtD0yai9jlD5tbg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(src = http://genieframework.com)</p></figure></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="3f4e" class="na nb it bd nc nd ne nf ng nh ni nj nk jz nl ka nm kc nn kd no kf np kg nq nr bi translated">PyCall</h1><p id="492f" class="pw-post-body-paragraph ky kz it la b lb ns ju ld le nt jx lg lh nu lj lk ll nv ln lo lp nw lr ls lt im bi translated">这可能令人惊讶，但Julia目前面临的最大挑战之一是PyCall.jl。这是因为就其现状而言，太多的包依赖于它，反过来又依赖于Python。虽然我完全理解，Python的生态系统要比Julia的生态系统大得多，但反过来，Julia失去了所有获得的速度，使用PyCall甚至比使用Python本身还慢，</p><blockquote class="md"><p id="41aa" class="me mf it bd mg mh mi mj mk ml mm lt dk translated">那为什么还要用朱莉娅呢？</p></blockquote><h1 id="cb46" class="na nb it bd nc nd nx nf ng nh ny nj nk jz nz ka nm kc oa kd no kf ob kg nq nr bi translated">训练-测试-拆分</h1><p id="4a60" class="pw-post-body-paragraph ky kz it la b lb ns ju ld le nt jx lg lh nu lj lk ll nv ln lo lp nw lr ls lt im bi translated">训练-测试-分割是一个基本的工具，对于机器学习的任何延伸都是完全需要的。为了验证一个算法，你必须首先有一个训练集和一个测试集，有些人甚至选择了一个验证集。参考这个线程，</p><div class="oc od gp gr oe of"><a href="https://discourse.julialang.org/t/simple-tool-for-train-test-split/473" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd iu gy z fp ok fr fs ol fu fw is bi translated">用于训练测试拆分简单工具</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">我暗暗希望这个问题至少在一周内不要出现，直到我找到时间写文档…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">discourse.julialang.org</p></div></div><div class="oo l"><div class="op l oq or os oo ot ks of"/></div></div></a></div><p id="10b7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">关于Julia的论述，我认为很明显，数据帧的测试序列分割在某种程度上被忽略了。MLDataUtils可能是大多数人用于训练-测试-分割的包，相信我的话:</p><blockquote class="md"><p id="f740" class="me mf it bd mg mh mi mj mk ml mm lt dk translated">它当然可以更好。</p></blockquote><p id="dc57" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">幸运的是，几个月来，已经有更好的从模块车床。</p><pre class="kj kk kl km gt ou ov ow ox aw oy bi"><span id="7f6a" class="oz nb it ov b gy pa pb l pc pd">using Lathe.preprocess: TrainTestSplit<br/>train, test = TrainTestSplit(df)</span></pre><p id="831b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们甚至可以调整我们的分割百分比，就像这样:</p><pre class="kj kk kl km gt ou ov ow ox aw oy bi"><span id="446b" class="oz nb it ov b gy pa pb l pc pd">train, test = TrainTestSplit(df,0.5)</span></pre><p id="a937" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这将为我们的测试和训练集把数据分成两半。</p><h1 id="bcfa" class="na nb it bd nc nd nx nf ng nh ny nj nk jz pe ka nm kc pf kd no kf pg kg nq nr bi translated">特征缩放</h1><p id="ae4e" class="pw-post-body-paragraph ky kz it la b lb ns ju ld le nt jx lg lh nu lj lk ll nv ln lo lp nw lr ls lt im bi lu translated">我认为在Julia模块中最常见的是SkLearn形式。我不认为我们应该从一个完全独立的语言中，在一个完全独立的范例中，接受或强制这种构造。一个很好的例子是Julia中的特征标量。大多数(如果不是全部)特征标量符合SkLearn的写作风格，该风格自2010年以来一直定义Python机器学习模块。但是SkLearn的标量如此表现的原因只有一个，那就是SkLearn的奇妙管道。</p><p id="2b3f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在Julia中，我们没有类，反过来我们也不能让方法成为一个对象的子对象。取而代之的是，我们有一些结构，它们可以采用一个方法来对该结构保存的数据执行一个操作。此外，Julia必须提供的唯一管道是语法管道——这很好，但肯定消除了与SkLearn一致的点，因为它们不使用相同的方法。为了正确理解这一点，以下是标准标量(Z分数规格化器)的公式:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/8490db3b627c43313518553cfe629f06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*Ap_7t_-luGSaAVgc7kl7qA.png"/></div></figure><p id="5d00" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有了这样一个简单的公式，fit只需要计算样本均值和标准差。以Julia的速度，这些计算当然可以在微秒内完成，就像在Python中一样。无论如何，这都不是一个困难的计算，只需一个简洁的for循环和另外两行代码就可以完成。幸运的是，车床用一种简单的方法再次罢工，采取任何数组:</p><pre class="kj kk kl km gt ou ov ow ox aw oy bi"><span id="2e75" class="oz nb it ov b gy pa pb l pc pd">using Lathe.preprocess: StandardScalar<br/>scaledX = StandardScalar(trainX)</span></pre><blockquote class="md"><p id="41d8" class="me mf it bd mg mh pi pj pk pl pm lt dk translated">很简单，对吧？</p></blockquote><p id="1e20" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">除了标准标量之外，Lathe还附带了大量其他标量，将来还计划实现一个单位长度标量。到目前为止，用？()方法将显示所有可用的标量:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/a77942266cb31405d1acc2fc65b5881d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1078/format:webp/1*LGkyZcVLa9Cq1vSEu7magw.png"/></div></figure><ul class=""><li id="f456" class="po pp it la b lb lc le lf lh pq ll pr lp ps lt pt pu pv pw bi translated">重新标度</li><li id="1dde" class="po pp it la b lb px le py lh pz ll qa lp qb lt pt pu pv pw bi translated">任意重新标度</li><li id="28e0" class="po pp it la b lb px le py lh pz ll qa lp qb lt pt pu pv pw bi translated">均值归一化</li></ul><h1 id="9bd4" class="na nb it bd nc nd nx nf ng nh ny nj nk jz pe ka nm kc pf kd no kf pg kg nq nr bi translated">分类编码器</h1><p id="d1fc" class="pw-post-body-paragraph ky kz it la b lb ns ju ld le nt jx lg lh nu lj lk ll nv ln lo lp nw lr ls lt im bi translated">分类编码器是Julia生态系统中另一个极度缺乏的领域。只有一个编码器可用，通常通过Flux使用，称为one hot编码器。为了让你了解复杂的Flux的one hot encoder有多无聊，你可以看看这里的源代码:</p><div class="oc od gp gr oe of"><a href="https://github.com/FluxML/Flux.jl/blob/master/src/onehot.jl" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd iu gy z fp ok fr fs ol fu fw is bi translated">FluxML/Flux.jl</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">放松点。Flux是不会让你tensor - FluxML/Flux.jl的ML库</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">github.com</p></div></div><div class="oo l"><div class="qc l oq or os oo ot ks of"/></div></div></a></div><p id="477e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该文件中的代码总共有130行，在我看来，这个大小根本没有必要。要使用车床的one hot编码器，我们只需调用方法“OneHotEncode”:</p><pre class="kj kk kl km gt ou ov ow ox aw oy bi"><span id="7c93" class="oz nb it ov b gy pa pb l pc pd">using Lathe.preprocess: OneHotEncode<br/>encoded_df = OneHotEncode(df,:columnname)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qd"><img src="../Images/ba2dd0ef38854e745eb89368e10f2a3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/1*igabL-Ygsuh5lwTIVHt9zA.png"/></div></figure><p id="1a15" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是计算它的代码，总共只有7行:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qe"><img src="../Images/4e96cacb8679e6c5e385e1d6b1df2a86.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*YfPdBzIG8gKaDS7MPsnWlA.png"/></div></figure></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="4787" class="na nb it bd nc nd ne nf ng nh ni nj nk jz nl ka nm kc nn kd no kf np kg nq nr bi translated">管道</h1><p id="d02d" class="pw-post-body-paragraph ky kz it la b lb ns ju ld le nt jx lg lh nu lj lk ll nv ln lo lp nw lr ls lt im bi lu translated">ipelines对于SkLearn和机器学习整体来说是一个非常重要的特性。Julia严重缺乏使用管道的真正好的库。Julia中的大多数管道不采用构造模型，也不允许任何简单的序列化读写。然而，对于车床，实际上存在使用与车床模型的其余部分相同的预测函数的管道，并且允许一组可迭代的步骤以及用于预测的模型。如果你想阅读一个完整的，虽然过时的车床管道教程，你可以在这里查看:</p><div class="oc od gp gr oe of"><a rel="noopener follow" target="_blank" href="/building-pipelines-with-lathe-0-0-7-unstable-in-julia-f7ba1850bde3"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd iu gy z fp ok fr fs ol fu fw is bi translated">在Julia中用车床0.0.7构建管道(不稳定)</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">数据科学的很大一部分是数据科学的一个子集，称为数据工程。数据工程(DE)包括…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">towardsdatascience.com</p></div></div><div class="oo l"><div class="qf l oq or os oo ot ks of"/></div></div></a></div><p id="2134" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，对于有价值的文档，您可以简单地使用？()方法在车床.模型.管道上</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qg"><img src="../Images/ef33740013488e2e415c8506db7d4d95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/1*V-cwHqg2sIpYi-ulT-93fg.png"/></div></figure><h1 id="bee0" class="na nb it bd nc nd nx nf ng nh ny nj nk jz pe ka nm kc pf kd no kf pg kg nq nr bi translated">结论</h1><p id="6257" class="pw-post-body-paragraph ky kz it la b lb ns ju ld le nt jx lg lh nu lj lk ll nv ln lo lp nw lr ls lt im bi translated">我相信很多Julia模块都有很多不尽人意的地方。一些不提供任何数据帧兼容性，而另一些通过使简单的算法变得过于复杂而制造了更多的问题。Julia语言非常灵活，这不仅在笔记本中对我们有利，在模块中也是如此。我认为，正是因为这个原因，Julia的生态系统让很多新人对这门语言望而却步，这让我很沮丧。事实是，就包而言，现在Python轻而易举地做得更好。我认为这很容易改变，展望未来，我对朱莉娅的生态系统，包括车床的未来感到非常兴奋！</p></div></div>    
</body>
</html>