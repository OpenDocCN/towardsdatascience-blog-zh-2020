<html>
<head>
<title>How to predict a variable sinusoid in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在 Python 中预测可变正弦曲线</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-predict-a-variable-sinusoid-in-python-4a21404dc061?source=collection_archive---------19-----------------------#2020-04-11">https://towardsdatascience.com/how-to-predict-a-variable-sinusoid-in-python-4a21404dc061?source=collection_archive---------19-----------------------#2020-04-11</a></blockquote><div><div class="fc ik il im in io"/><div class="ip iq ir is it"><h2 id="e6b1" class="iu iv iw bd b dl ix iy iz ja jb jc dk jd translated" aria-label="kicker paragraph">数据分析</h2><div class=""/><div class=""><h2 id="669d" class="pw-subtitle-paragraph kc jf iw bd b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dk translated">基于数学的预测 Python 中可变正弦曲线的方法。</h2></div><figure class="kv kw kx ky gu kz gi gj paragraph-image"><div class="gi gj ku"><img src="../Images/a2f2887a5a52b06faf4beb1334fee6d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*FqbYI6bPbWGDyAxFn2weJw.png"/></div></figure><p id="349b" class="pw-post-body-paragraph lc ld iw le b lf lg kg lh li lj kj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ip bi translated">本教程描述了如何用 Python 预测一个可变正弦曲线。首先，从 CSV 文件加载一些正弦数据。然后，通过正弦曲线对数据进行整形。之后，使用线性回归对最小和最大峰值进行建模。最后，建模的线用于计算下一个峰值。</p><p id="bda2" class="pw-post-body-paragraph lc ld iw le b lf lg kg lh li lj kj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ip bi translated">完整的代码可以从我的<a class="ae ly" href="https://github.com/alod83/data-science/tree/master/DataAnalysis/tourism" rel="noopener ugc nofollow" target="_blank"> Github 库</a>下载。</p><p id="7b28" class="pw-post-body-paragraph lc ld iw le b lf lg kg lh li lj kj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ip bi translated">分析的数据:旅游住宿机构的到达人数摘自<a class="ae ly" href="https://ec.europa.eu/eurostat/web/tourism/data/database" rel="noopener ugc nofollow" target="_blank">https://ec.europa.eu/eurostat/web/tourism/data/database</a></p><h1 id="49dd" class="lz ma iw bd mb mc md me mf mg mh mi mj kl mk km ml ko mm kp mn kr mo ks mp mq bi translated">数据导入和清理</h1><h2 id="3ccd" class="mr ma iw bd mb ms mt dn mf mu mv dp mj ll mw mx ml lp my mz mn lt na nb mp jc bi translated">从 CSV 加载数据并清除它们</h2><p id="86e4" class="pw-post-body-paragraph lc ld iw le b lf nc kg lh li nd kj lk ll ne ln lo lp nf lr ls lt ng lv lw lx ip bi translated">首先，我们读取 CSV 文件，我们只选择与意大利(<code class="fe nh ni nj nk b">df[df['geo'] == 'IT']</code>)相关的数据，以数字(<code class="fe nh ni nj nk b">df[df['unit'] == 'NR']</code>)的形式，并参考所有可用数据的总和(内部和外部到达)(<code class="fe nh ni nj nk b">df[df['c_resid'] == 'TOTAL']</code>)。</p><p id="50d2" class="pw-post-body-paragraph lc ld iw le b lf lg kg lh li lj kj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ip bi translated">然后我们通过函数<code class="fe nh ni nj nk b">drop()</code>删除无用的列。注意，我们通过参数<code class="fe nh ni nj nk b">inplace=True</code>将效果存储在原始变量<code class="fe nh ni nj nk b">df</code>中。</p><pre class="kv kw kx ky gu nl nk nm nn aw no bi"><span id="f397" class="mr ma iw nk b gz np nq l nr ns">import pandas as pd<br/>df = pd.read_csv(‘data/eurostat.csv’)<br/>df = df[df[‘geo’] == ‘IT’]<br/>df = df[df[‘unit’] == ‘NR’]<br/>df = df[df[‘c_resid’] == ‘TOTAL’]<br/>df.drop([‘c_resid’, ‘unit’, ‘nace_r2’, ‘2019M11’, ‘geo’],axis=1, inplace=True)<br/>df = df.reset_index()<br/>df.drop([‘index’],axis=1, inplace=True)</span></pre><p id="1a8d" class="pw-post-body-paragraph lc ld iw le b lf lg kg lh li lj kj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ip bi translated">现在我们可以纠正数据中的一些错误:一些行包含字符<code class="fe nh ni nj nk b">:</code>，这意味着没有可用的数据。其他行包含字母<code class="fe nh ni nj nk b">b</code>。我们改变了<code class="fe nh ni nj nk b">0</code>中的<code class="fe nh ni nj nk b">:</code>，并删除了字母<code class="fe nh ni nj nk b">b</code>。</p><pre class="kv kw kx ky gu nl nk nm nn aw no bi"><span id="6854" class="mr ma iw nk b gz np nq l nr ns">columns = df.columns[::-1]<br/>for column in columns:<br/> for row in range(1, len(df[column])):<br/> if “b” in df[column][row]:<br/> df[column] = df[column][row][:-2]<br/> if “:” in df[column][row]:<br/> df[column][row] = “0”</span></pre><p id="3dca" class="pw-post-body-paragraph lc ld iw le b lf lg kg lh li lj kj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ip bi translated">现在我们计算各列的总和，以获得每个月的总到达人数。我们将结果存储在变量<code class="fe nh ni nj nk b">y</code>中。</p><pre class="kv kw kx ky gu nl nk nm nn aw no bi"><span id="e332" class="mr ma iw nk b gz np nq l nr ns">y = []<br/>for column in columns:<br/> df[column] = df[column].astype(str).astype(int)<br/> y.append(df[column].sum())</span></pre><h1 id="056b" class="lz ma iw bd mb mc md me mf mg mh mi mj kl mk km ml ko mm kp mn kr mo ks mp mq bi translated">初步分析</h1><h2 id="1b9c" class="mr ma iw bd mb ms mt dn mf mu mv dp mj ll mw mx ml lp my mz mn lt na nb mp jc bi translated">绘制数据以了解数据趋势</h2><p id="d97b" class="pw-post-body-paragraph lc ld iw le b lf nc kg lh li nd kj lk ll ne ln lo lp nf lr ls lt ng lv lw lx ip bi translated">我们绘制<code class="fe nh ni nj nk b">y</code>来理解趋势线。我们构建辅助向量<code class="fe nh ni nj nk b">X</code>，它包含所有的月份。0 月指的是 1990 年 1 月。为了每 5 年在图中显示 x 标签，我们构建了两个辅助变量，<code class="fe nh ni nj nk b">x_ticks</code>和<code class="fe nh ni nj nk b">x_labels</code>。</p><pre class="kv kw kx ky gu nl nk nm nn aw no bi"><span id="a5a3" class="mr ma iw nk b gz np nq l nr ns">import matplotlib.pyplot as plt<br/>import matplotlib<br/>import numpy as np<br/>X = np.arange(0, len(columns))</span><span id="6dd3" class="mr ma iw nk b gz nt nq l nr ns">step = 5<br/>x_ticks = np.arange(0, len(columns)+step, step=12*step)<br/>x_labels = []<br/>x_labels.append(1990)<br/>for i in range(1, len(x_tick)+1):<br/> x_labels.append(x_labels[i-1]+step)<br/>plt.xticks(x_ticks, x_labels)<br/>plt.plot(X, y, color=”red”, linewidth=1)</span><span id="d29d" class="mr ma iw nk b gz nt nq l nr ns">plt.grid()<br/>plt.xlabel(‘Months’)<br/>plt.ylabel(‘Number of arrivals’)</span><span id="51bc" class="mr ma iw nk b gz nt nq l nr ns">plt.show()</span></pre><figure class="kv kw kx ky gu kz gi gj paragraph-image"><div class="gi gj ku"><img src="../Images/9684f6b5d1fc142bb082ded992773d53.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*VkbPyGBB5aGV2m-k1vy-JA.png"/></div></figure><p id="47cb" class="pw-post-body-paragraph lc ld iw le b lf lg kg lh li lj kj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ip bi translated">我们注意到，与前几年相比，在过去的 8 年中，最大峰值有所增加。因此，我们限制了过去 8 年的分析。这意味着我们应该跳过最初的 22 年。我们将<code class="fe nh ni nj nk b">X</code>和<code class="fe nh ni nj nk b">y</code>重置为仅适用于最近几年。</p><pre class="kv kw kx ky gu nl nk nm nn aw no bi"><span id="615d" class="mr ma iw nk b gz np nq l nr ns">skip = 22*12<br/>X = X[skip:]<br/>y = y[skip:]</span></pre><h1 id="51a3" class="lz ma iw bd mb mc md me mf mg mh mi mj kl mk km ml ko mm kp mn kr mo ks mp mq bi translated">数据近似值</h1><h2 id="4bb3" class="mr ma iw bd mb ms mt dn mf mu mv dp mj ll mw mx ml lp my mz mn lt na nb mp jc bi translated">用正弦曲线逼近数据</h2><p id="4cb4" class="pw-post-body-paragraph lc ld iw le b lf nc kg lh li nd kj lk ll ne ln lo lp nf lr ls lt ng lv lw lx ip bi translated">现在我们可以用正弦曲线来近似数据。正弦曲线的方程式为<code class="fe nh ni nj nk b">A*np.sin(omega*x+phase) + offset</code>，其中:</p><ul class=""><li id="fd11" class="nu nv iw le b lf lg li lj ll nw lp nx lt ny lx nz oa ob oc bi translated">| <code class="fe nh ni nj nk b">A</code> |表示振幅，即函数最大值和最小值之间距离的一半</li><li id="2b00" class="nu nv iw le b lf od li oe ll of lp og lt oh lx nz oa ob oc bi translated"><code class="fe nh ni nj nk b">omega</code>是 0 到 2pi 之间的循环数。周期 T 是 2pi/ω</li><li id="6ea5" class="nu nv iw le b lf od li oe ll of lp og lt oh lx nz oa ob oc bi translated"><code class="fe nh ni nj nk b">phase</code>是水平移动</li><li id="0a1d" class="nu nv iw le b lf od li oe ll of lp og lt oh lx nz oa ob oc bi translated"><code class="fe nh ni nj nk b">offset</code>是垂直位移，即最小峰值和振幅之和。下面是一些关于偏移的细节:<a class="ae ly" href="https://www.ck12.org/book/ck-12-precalculus-concepts/section/5.4/" rel="noopener ugc nofollow" target="_blank">https://www . ck12 . org/book/CK-12-precalculus-concepts/section/5.4/</a></li></ul><p id="811f" class="pw-post-body-paragraph lc ld iw le b lf lg kg lh li lj kj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ip bi translated">关于正弦曲线的更多细节，可以给看看:<a class="ae ly" href="https://mathbitsnotebook.com/Algebra2/TrigGraphs/TGsinusoidal.html" rel="noopener ugc nofollow" target="_blank">https://mathbitsnotebook . com/代数 2/trig graphs/TG sinusoid . html</a>。</p><pre class="kv kw kx ky gu nl nk nm nn aw no bi"><span id="555b" class="mr ma iw nk b gz np nq l nr ns">def sinusoid(x,A,offset,omega,phase):<br/> return A*np.sin(omega*x+phase) + offset</span></pre><p id="2cf3" class="pw-post-body-paragraph lc ld iw le b lf lg kg lh li lj kj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ip bi translated">我们还定义了正弦曲线的初始值。我们设置周期<code class="fe nh ni nj nk b">T = 12</code>，即一年中的月数。如果不知道周期，我们应该计算它。我们可以使用快速傅立叶变换。在这些链接中，你可以找到更多关于这方面的细节:<a class="ae ly" href="https://stackoverflow.com/questions/16716302/how-do-i-fit-a-sine-curve-to-my-data-with-pylab-and-numpy" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/16716302/how-do-I-fit-a-sine-curve-to-my-data-with-pylab-and-numpy</a>、<a class="ae ly" href="https://www.oreilly.com/library/view/elegant-scipy/9781491922927/ch04.html" rel="noopener ugc nofollow" target="_blank">https://www . oreilly . com/library/view/elegant-scipy/9781491922927/ch04 . html</a></p><pre class="kv kw kx ky gu nl nk nm nn aw no bi"><span id="4eb7" class="mr ma iw nk b gz np nq l nr ns">T = 12<br/>def get_p0(x, y):<br/> <br/> A0 = (max(y[0:T]) — min(y[0:T]))/2<br/> offset0 = y[0]<br/> phase0 = 0<br/> omega0 = 2.*np.pi/T<br/> return [A0, offset0,omega0, phase0]</span></pre><p id="280b" class="pw-post-body-paragraph lc ld iw le b lf lg kg lh li lj kj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ip bi translated">现在我们准备用正弦曲线来近似我们的数据。我们使用<code class="fe nh ni nj nk b">scipy</code>提供的<code class="fe nh ni nj nk b">curve_fit()</code>函数。我们绘制结果。关于<code class="fe nh ni nj nk b">curve_fit()</code>功能的更多细节，请看<a class="ae ly" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.curve_fit.html" rel="noopener ugc nofollow" target="_blank">https://docs . scipy . org/doc/scipy/reference/generated/scipy . optimize . curve _ fit . html</a>。</p><pre class="kv kw kx ky gu nl nk nm nn aw no bi"><span id="188b" class="mr ma iw nk b gz np nq l nr ns">from scipy.optimize import curve_fit<br/>import math<br/>param, covariance = curve_fit(sinusoid, X, y, p0=get_p0(X,y))</span><span id="048a" class="mr ma iw nk b gz nt nq l nr ns">step = 1<br/>x_ticks = np.arange(skip, skip+len(X)+step+12, step=12*step)<br/>x_labels = []<br/>x_labels.append(2012)<br/>for i in range(1, len(x_tick)+13):<br/> x_labels.append(x_labels[i-1]+step)<br/>plt.xticks(x_ticks, x_labels)<br/>plt.ylabel(‘Number of arrivals’)<br/>plt.plot(X, y, color=”red”, linewidth=1,linestyle=’dashed’)<br/>plt.plot(X, sinusoid(X, *param), color=”blue”, linewidth=1)<br/>plt.show()</span></pre><figure class="kv kw kx ky gu kz gi gj paragraph-image"><div class="gi gj ku"><img src="../Images/57f407c81e18c1c92e34ebb06ac91313.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*aQyPRDE0wHYDJgZ1sBUS5g.png"/></div></figure><p id="3105" class="pw-post-body-paragraph lc ld iw le b lf lg kg lh li lj kj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ip bi translated">我们用恒定值为<code class="fe nh ni nj nk b">A</code>的正弦曲线来近似我们的数据。在我们的例子中，振幅<code class="fe nh ni nj nk b">A</code>和<code class="fe nh ni nj nk b">offset</code>都是可变的。这个想法是计算我们数据中所有的最大峰值和最小峰值。然后我们可以使用它们的差来计算振幅的向量，并将它们传递给<code class="fe nh ni nj nk b">sinusoid()</code>函数。</p><p id="1b16" class="pw-post-body-paragraph lc ld iw le b lf lg kg lh li lj kj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ip bi translated">我们定义了函数<code class="fe nh ni nj nk b">get_peaks()</code>，它计算一个数组的峰值。我们每隔<code class="fe nh ni nj nk b">T</code>个元素对数组进行采样，并计算每个<code class="fe nh ni nj nk b">T</code>内的峰值。</p><pre class="kv kw kx ky gu nl nk nm nn aw no bi"><span id="a390" class="mr ma iw nk b gz np nq l nr ns">def get_peaks(y, metrics):<br/> n = int(math.ceil(len(y)/T))<br/> step = 0<br/> x_peaks = []<br/> y_peaks = []<br/> for i in range(0,n):<br/> peak_index = y.index(metrics(y[step:step+T]))<br/> x_peaks.append(peak_index + skip)<br/> y_peaks.append(y[peak_index])<br/> step = step+T<br/> return [x_peaks,y_peaks]</span></pre><p id="957a" class="pw-post-body-paragraph lc ld iw le b lf lg kg lh li lj kj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ip bi translated">我们计算最大和最小峰值。</p><pre class="kv kw kx ky gu nl nk nm nn aw no bi"><span id="3a24" class="mr ma iw nk b gz np nq l nr ns">min_peaks = get_peaks(y,min)<br/>max_peaks = get_peaks(y,max)</span></pre><p id="7b2c" class="pw-post-body-paragraph lc ld iw le b lf lg kg lh li lj kj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ip bi translated">现在我们可以计算振幅和偏移的数组。</p><pre class="kv kw kx ky gu nl nk nm nn aw no bi"><span id="396b" class="mr ma iw nk b gz np nq l nr ns">A = []<br/>offset = []<br/>for i in range(0, len(min_peaks[1])):<br/> c_a = (max_peaks[1][i] — min_peaks[1][i])/2<br/> c_offset = min_peaks[1][i] + c_a<br/> for j in range(0,T):<br/> A.append(c_a)<br/> offset.append(c_offset)<br/># last two months of 2019 are not available<br/>A = A[:-2]<br/>offset = offset[:-2]</span></pre><p id="1e87" class="pw-post-body-paragraph lc ld iw le b lf lg kg lh li lj kj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ip bi translated">由于<code class="fe nh ni nj nk b">A</code>和<code class="fe nh ni nj nk b">offset</code>是新特性，我们应该把它们作为变量添加进去。因此，我们定义了一个新变量<code class="fe nh ni nj nk b">features</code>，它定义了我们模型的新输入特性。然后我们定义函数<code class="fe nh ni nj nk b">variable_sinusoid()</code>，它将特性作为输入。</p><p id="8523" class="pw-post-body-paragraph lc ld iw le b lf lg kg lh li lj kj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ip bi translated">我们的模型返回的唯一参数是<code class="fe nh ni nj nk b">omega</code>和<code class="fe nh ni nj nk b">phase</code>，因此我们也用初始值<code class="fe nh ni nj nk b">omega</code>和<code class="fe nh ni nj nk b">phase</code>修改函数<code class="fe nh ni nj nk b">get_p0()</code>。新功能称为<code class="fe nh ni nj nk b">variable_get_p0()</code>。</p><pre class="kv kw kx ky gu nl nk nm nn aw no bi"><span id="50a2" class="mr ma iw nk b gz np nq l nr ns">features = [X, A, offset]<br/>def variable_sinusoid(features,omega,phase):<br/> x = features[0]<br/> A = features[1]<br/> offset = features[2]<br/> return A*np.sin(omega*x+phase) + offset</span><span id="45e7" class="mr ma iw nk b gz nt nq l nr ns">def variable_get_p0(x, y): <br/> phase0 = 0<br/> omega0 = 2.*np.pi/T<br/> return [omega0, phase0]</span></pre><p id="2ed8" class="pw-post-body-paragraph lc ld iw le b lf lg kg lh li lj kj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ip bi translated">我们拟合模型并绘制结果。</p><pre class="kv kw kx ky gu nl nk nm nn aw no bi"><span id="9d3d" class="mr ma iw nk b gz np nq l nr ns">param, covariance = curve_fit(variable_sinusoid, features, y, p0=variable_get_p0(X,y))<br/>plt.xticks(x_ticks, x_labels)<br/>plt.ylabel(‘Number of arrivals’)<br/>plt.plot(X, y, color=”red”, linewidth=1,linestyle=’dashed’)<br/>plt.plot(X, variable_sinusoid(features, *param), color=”blue”, linewidth=1)<br/>plt.show()</span></pre><figure class="kv kw kx ky gu kz gi gj paragraph-image"><div class="gi gj ku"><img src="../Images/9b68ee0722adce4249ff0a1dde45fc6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*xPe8-TQeIUHG61RcVoDVyg.png"/></div></figure><h1 id="0e58" class="lz ma iw bd mb mc md me mf mg mh mi mj kl mk km ml ko mm kp mn kr mo ks mp mq bi translated">预测未来趋势线</h1><h2 id="eb33" class="mr ma iw bd mb ms mt dn mf mu mv dp mj ll mw mx ml lp my mz mn lt na nb mp jc bi translated">预测可变正弦曲线的未来值</h2><p id="523f" class="pw-post-body-paragraph lc ld iw le b lf nc kg lh li nd kj lk ll ne ln lo lp nf lr ls lt ng lv lw lx ip bi translated">下一步包括预测下一个正弦曲线，即 2020 年的正弦曲线。为此，我们需要计算下一个最大和最小峰值。我们可以通过用两个线性回归分别逼近最大和最小峰值的向量来做到这一点。然后，我们可以计算出瞬时 2020 年 8 月)的最大峰值，作为瞬时(i-1) + pi (i-1 代表 2019 年 8 月)给出的最大线性回归的 y 值。同样，我们可以计算出 2020 年的最小峰值。</p><p id="3560" class="pw-post-body-paragraph lc ld iw le b lf lg kg lh li lj kj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ip bi translated">首先，我们对要传递给线性模型的峰值进行整形。然后，我们使用<code class="fe nh ni nj nk b">sklearn</code>类<code class="fe nh ni nj nk b">LinearRegression()</code>建立两个线性模型，每条预测线一个。之后，我们使用<code class="fe nh ni nj nk b">fit()</code>函数拟合每个模型。</p><pre class="kv kw kx ky gu nl nk nm nn aw no bi"><span id="1fc7" class="mr ma iw nk b gz np nq l nr ns">from sklearn import linear_model<br/># reshape x_peaks<br/>x_min_peaks = list(map(lambda el:[el], min_peaks[0])) <br/>x_max_peaks = list(map(lambda el:[el], max_peaks[0]))</span><span id="3160" class="mr ma iw nk b gz nt nq l nr ns"># min model<br/>model_min = linear_model.LinearRegression()<br/>model_min.fit(x_min_peaks,min_peaks[1])<br/># max model<br/>model_max = linear_model.LinearRegression()<br/>model_max.fit(x_max_peaks,max_peaks[1])</span></pre><p id="8d19" class="pw-post-body-paragraph lc ld iw le b lf lg kg lh li lj kj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ip bi translated">我们将下一个峰值添加到<code class="fe nh ni nj nk b">x_max_peaks</code>和<code class="fe nh ni nj nk b">x_min_peaks</code>，然后通过<code class="fe nh ni nj nk b">predict()</code>函数预测最大和最小峰值。</p><pre class="kv kw kx ky gu nl nk nm nn aw no bi"><span id="3b2d" class="mr ma iw nk b gz np nq l nr ns">x_min_peaks.append([x_min_peaks[len(x_min_peaks) -1][0] + T])<br/>x_max_peaks.append([x_max_peaks[len(x_max_peaks) -1][0] + T])<br/>y_pred_min = model_min.predict(x_min_peaks)<br/>y_pred_max = model_max.predict(x_max_peaks)</span></pre><p id="1c4d" class="pw-post-body-paragraph lc ld iw le b lf lg kg lh li lj kj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ip bi translated">我们绘制了两条预测线。</p><pre class="kv kw kx ky gu nl nk nm nn aw no bi"><span id="a7b9" class="mr ma iw nk b gz np nq l nr ns">plt.xticks(x_ticks, x_labels)<br/>plt.plot(X, y, color=”red”, linewidth=1,linestyle=’dashed’)<br/>plt.scatter(x_min_peaks, y_pred_min, color=”green”, linewidth=1,linestyle=’dashed’)<br/>plt.scatter(x_max_peaks, y_pred_max, color=”green”, linewidth=1,linestyle=’dashed’)<br/>plt.ylabel(‘Number of arrivals’)<br/>plt.grid()<br/>plt.show()</span></pre><figure class="kv kw kx ky gu kz gi gj paragraph-image"><div class="gi gj ku"><img src="../Images/f1a80b5ca1c391fbf4d77e4eb03a74ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*gBWriLlxjTneQ8Myg7hhnA.png"/></div></figure><p id="dd40" class="pw-post-body-paragraph lc ld iw le b lf lg kg lh li lj kj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ip bi translated">我们计算所有周期的正弦曲线，包括 2020 年。我们构建一个变量<code class="fe nh ni nj nk b">X_pred</code>，它包含<code class="fe nh ni nj nk b">X</code>和 2020 年的 12 个月。</p><pre class="kv kw kx ky gu nl nk nm nn aw no bi"><span id="7e95" class="mr ma iw nk b gz np nq l nr ns">X_pred = np.array(X)<br/>month = X_pred[len(X_pred)-1]<br/>for i in range(0,T):<br/> X_pred = np.append(X_pred,month)<br/> month = month + 1</span></pre><p id="ba22" class="pw-post-body-paragraph lc ld iw le b lf lg kg lh li lj kj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ip bi translated">现在，我们可以更新要传递给<code class="fe nh ni nj nk b">variable_sinusoid()</code>函数的变量<code class="fe nh ni nj nk b">features_pred</code>。首先，我们用新值更新振幅<code class="fe nh ni nj nk b">A</code>和<code class="fe nh ni nj nk b">offset</code>，然后我们更新<code class="fe nh ni nj nk b">features_pred</code>变量。</p><pre class="kv kw kx ky gu nl nk nm nn aw no bi"><span id="ef61" class="mr ma iw nk b gz np nq l nr ns">index = len(max_peaks[0])-1<br/>c_a = (max_peaks[1][index] — min_peaks[1][index])/2<br/>c_offset = min_peaks[1][index] + c_a<br/>for j in range(0,T):<br/> A.append(c_a)<br/> offset.append(c_offset)<br/>features_pred = [X_pred,A,offset]</span></pre><p id="8342" class="pw-post-body-paragraph lc ld iw le b lf lg kg lh li lj kj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ip bi translated">最后，我们绘制图表。</p><pre class="kv kw kx ky gu nl nk nm nn aw no bi"><span id="f24e" class="mr ma iw nk b gz np nq l nr ns">plt.xticks(x_ticks, x_labels)<br/>plt.plot(X, y, color=”red”, linewidth=1,linestyle=’dashed’)<br/>plt.plot(X_pred, variable_sinusoid(features_pred, *param), color=”blue”, linewidth=1)<br/>plt.grid()<br/>plt.ylabel(‘Number of arrivals’)<br/>plt.savefig(“data/sinusoid.png”)<br/>plt.show()</span></pre><figure class="kv kw kx ky gu kz gi gj paragraph-image"><div class="gi gj ku"><img src="../Images/a2f2887a5a52b06faf4beb1334fee6d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*FqbYI6bPbWGDyAxFn2weJw.png"/></div></figure><h1 id="5732" class="lz ma iw bd mb mc md me mf mg mh mi mj kl mk km ml ko mm kp mn kr mo ks mp mq bi translated">吸取的教训</h1><p id="94b9" class="pw-post-body-paragraph lc ld iw le b lf nc kg lh li nd kj lk ll ne ln lo lp nf lr ls lt ng lv lw lx ip bi translated">在本教程中，我介绍了一种通过可变正弦曲线来逼近正弦趋势数据的方法。然后我描述了预测下一个数据值的机制。</p><p id="aa12" class="pw-post-body-paragraph lc ld iw le b lf lg kg lh li lj kj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ip bi translated">所描述的方法可以推广到所有类型的曲线:</p><ul class=""><li id="26de" class="nu nv iw le b lf lg li lj ll nw lp nx lt ny lx nz oa ob oc bi translated">加载和清理数据</li><li id="3e65" class="nu nv iw le b lf od li oe ll of lp og lt oh lx nz oa ob oc bi translated">绘制数据以了解趋势线</li><li id="6d25" class="nu nv iw le b lf od li oe ll of lp og lt oh lx nz oa ob oc bi translated">通过<code class="fe nh ni nj nk b">curve_fit()</code>功能用曲线逼近趋势线</li><li id="fed9" class="nu nv iw le b lf od li oe ll of lp og lt oh lx nz oa ob oc bi translated">绘制近似结果，并与原始数据趋势线进行比较</li><li id="b8e7" class="nu nv iw le b lf od li oe ll of lp og lt oh lx nz oa ob oc bi translated">如果需要，改进近似趋势线</li><li id="ae04" class="nu nv iw le b lf od li oe ll of lp og lt oh lx nz oa ob oc bi translated">重复前两步，直到你得到一个好的近似值</li><li id="e266" class="nu nv iw le b lf od li oe ll of lp og lt oh lx nz oa ob oc bi translated">计算(线性、多项式、…)回归以预测未来值</li><li id="6246" class="nu nv iw le b lf od li oe ll of lp og lt oh lx nz oa ob oc bi translated">使用预测值更新近似趋势线。</li></ul><p id="8b4c" class="pw-post-body-paragraph lc ld iw le b lf lg kg lh li lj kj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ip bi translated">如果你读到这里，对我来说，今天已经很多了。谢谢！你可以在<a class="ae ly" href="https://alod83.medium.com/my-most-trending-articles-4fbfbe107fb" rel="noopener">这个链接</a>阅读我的趋势文章。</p><h1 id="9f9b" class="lz ma iw bd mb mc md me mf mg mh mi mj kl mk km ml ko mm kp mn kr mo ks mp mq bi translated">相关文章</h1><div class="oi oj gq gs ok ol"><a rel="noopener follow" target="_blank" href="/a-complete-data-analysis-workflow-in-python-pycaret-9a13c0fa51d4"><div class="om ab fp"><div class="on ab oo cl cj op"><h2 class="bd jg gz z fq oq fs ft or fv fx jf bi translated">Python PyCaret 中的完整数据分析工作流</h2><div class="os l"><h3 class="bd b gz z fq oq fs ft or fv fx dk translated">这是一个现成的教程，利用了我用过的最好的机器学习库。</h3></div><div class="ot l"><p class="bd b dl z fq oq fs ft or fv fx dk translated">towardsdatascience.com</p></div></div><div class="ou l"><div class="ov l ow ox oy ou oz la ol"/></div></div></a></div><div class="oi oj gq gs ok ol"><a rel="noopener follow" target="_blank" href="/a-complete-data-analysis-workflow-in-python-and-scikit-learn-9a77f7c283d3"><div class="om ab fp"><div class="on ab oo cl cj op"><h2 class="bd jg gz z fq oq fs ft or fv fx jf bi translated">Python 和 scikit 中的完整数据分析工作流程-学习</h2><div class="ot l"><p class="bd b dl z fq oq fs ft or fv fx dk translated">towardsdatascience.com</p></div></div><div class="ou l"><div class="pa l ow ox oy ou oz la ol"/></div></div></a></div><div class="oi oj gq gs ok ol"><a rel="noopener follow" target="_blank" href="/an-overview-of-visual-techniques-for-exploratory-data-analysis-in-python-d35703d43faf"><div class="om ab fp"><div class="on ab oo cl cj op"><h2 class="bd jg gz z fq oq fs ft or fv fx jf bi translated">Python 中探索性数据分析的可视化技术概述</h2><div class="os l"><h3 class="bd b gz z fq oq fs ft or fv fx dk translated">关于如何在 seaborn 和 matplotlib 中为 Visual EDA 绘制最常见图形的教程</h3></div><div class="ot l"><p class="bd b dl z fq oq fs ft or fv fx dk translated">towardsdatascience.com</p></div></div><div class="ou l"><div class="pb l ow ox oy ou oz la ol"/></div></div></a></div><h1 id="bcf8" class="lz ma iw bd mb mc md me mf mg mh mi mj kl mk km ml ko mm kp mn kr mo ks mp mq bi translated">在等待机器学习算法的输出时，你在做什么？</h1><p id="8629" class="pw-post-body-paragraph lc ld iw le b lf nc kg lh li nd kj lk ll ne ln lo lp nf lr ls lt ng lv lw lx ip bi translated">数据科学家的工作非常具有挑战性:你的知识必须涵盖从数据挖掘到数据分析，直到数据可视化。<strong class="le jg">你从不停止</strong>。</p><p id="1067" class="pw-post-body-paragraph lc ld iw le b lf lg kg lh li lj kj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ip bi translated">然而，当你启动一个繁重的计算时，比如一个大数据集上的机器学习算法，会发生什么呢？你停下来等待结果。你可能会盯着屏幕看几个小时，希望你的剧本能完成。</p><p id="8690" class="pw-post-body-paragraph lc ld iw le b lf lg kg lh li lj kj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ip bi translated">不管怎么说，这不是消磨时间的最佳方式。你应该做些别的事情。你不能坐下来等待结果。</p><p id="2a1f" class="pw-post-body-paragraph lc ld iw le b lf lg kg lh li lj kj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ip bi translated">在这里继续阅读<a class="ae ly" rel="noopener" target="_blank" href="/how-to-spend-your-time-when-you-are-waiting-for-a-data-analysis-output-e71b383f43cb"/>。</p><h1 id="7a66" class="lz ma iw bd mb mc md me mf mg mh mi mj kl mk km ml ko mm kp mn kr mo ks mp mq bi translated">保持联系！</h1><ul class=""><li id="857e" class="nu nv iw le b lf nc li nd ll pc lp pd lt pe lx nz oa ob oc bi translated">在<a class="ae ly" href="https://medium.com/@alod83?source=about_page-------------------------------------" rel="noopener">媒体</a>上跟随我</li><li id="915f" class="nu nv iw le b lf od li oe ll of lp og lt oh lx nz oa ob oc bi translated">注册我的<a class="ae ly" href="https://medium.com/subscribe?source=about_page-------------------------------------" rel="noopener">简讯</a></li><li id="f86e" class="nu nv iw le b lf od li oe ll of lp og lt oh lx nz oa ob oc bi translated">在<a class="ae ly" href="https://www.linkedin.com/in/angelicaloduca/?source=about_page-------------------------------------" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上连接</li><li id="bc48" class="nu nv iw le b lf od li oe ll of lp og lt oh lx nz oa ob oc bi translated">在推特上关注我</li><li id="5649" class="nu nv iw le b lf od li oe ll of lp og lt oh lx nz oa ob oc bi translated">跟着我上<a class="ae ly" href="https://www.facebook.com/alod83?source=about_page-------------------------------------" rel="noopener ugc nofollow" target="_blank">脸书</a></li><li id="b409" class="nu nv iw le b lf od li oe ll of lp og lt oh lx nz oa ob oc bi translated">在<a class="ae ly" href="https://github.com/alod83?source=about_page-------------------------------------" rel="noopener ugc nofollow" target="_blank"> Github </a>上关注我</li></ul></div></div>    
</body>
</html>