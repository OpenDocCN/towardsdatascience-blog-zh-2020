<html>
<head>
<title>Modeling Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">建模功能</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/modeling-functions-78704936477a?source=collection_archive---------13-----------------------#2020-01-28">https://towardsdatascience.com/modeling-functions-78704936477a?source=collection_archive---------13-----------------------#2020-01-28</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="f6d0" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">从线性回归到逻辑回归</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/e9213b20a77228018ffdf45ddc7db50b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6WW75o5n-LspRRrF"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Clem Onojeghuo 在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="1e05" class="lf lg iu lb b gz lh li l lj lk"><strong class="lb iv">Table of Contents</strong></span><span id="0ea8" class="lf lg iu lb b gz ll li l lj lk"><a class="ae kz" href="#3846" rel="noopener ugc nofollow"><strong class="lb iv">Introduction</strong></a></span><span id="6dfb" class="lf lg iu lb b gz ll li l lj lk">1. <a class="ae kz" href="#e296" rel="noopener ugc nofollow">Linear models</a><br/>2. <a class="ae kz" href="#005e" rel="noopener ugc nofollow">Quadratic models</a><br/>3. <a class="ae kz" href="#35bc" rel="noopener ugc nofollow">Cubic models</a><br/>4. <a class="ae kz" href="#7b2b" rel="noopener ugc nofollow">Exponential models</a><br/>5. <a class="ae kz" href="#ec20" rel="noopener ugc nofollow">Logarithmic models</a><br/>6. <a class="ae kz" href="#48d3" rel="noopener ugc nofollow">Sinusoidal models</a><br/>7. <a class="ae kz" href="#8108" rel="noopener ugc nofollow">Logistic models</a></span><span id="e481" class="lf lg iu lb b gz ll li l lj lk"><a class="ae kz" href="#9ef6" rel="noopener ugc nofollow"><strong class="lb iv">Conclusion</strong></a></span></pre></div><div class="ab cl lm ln hy lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="in io ip iq ir"><h1 id="3846" class="lt lg iu bd lu lv lw lx ly lz ma mb mc ka md kb me kd mf ke mg kg mh kh mi mj bi translated">介绍</h1><p id="8240" class="pw-post-body-paragraph mk ml iu mm b mn mo jv mp mq mr jy ms mt mu mv mw mx my mz na nb nc nd ne nf in bi translated">我们将使用 Jupyter Notebook 绘制一个散点图，并建立一个从线性到逻辑的回归线模型。</p><h1 id="e296" class="lt lg iu bd lu lv ng lx ly lz nh mb mc ka ni kb me kd nj ke mg kg nk kh mi mj bi translated">线性模型</h1><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj nl"><img src="../Images/6428ff5e302be04fa0c726f53537ac40.png" data-original-src="https://miro.medium.com/v2/resize:fit:380/format:webp/1*tXRCytR2xTR86BlnX6AdMA.png"/></div></figure><p id="e560" class="pw-post-body-paragraph mk ml iu mm b mn nm jv mp mq nn jy ms mt no mv mw mx np mz na nb nq nd ne nf in bi translated">第一个是线性模型。线性模型被表示为𝑦=𝑚𝑥+𝑐.我们将使用<a class="ae kz" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.array.html" rel="noopener ugc nofollow" target="_blank"> numpy.array </a>或<a class="ae kz" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.arange.html?highlight=arange#numpy.arange" rel="noopener ugc nofollow" target="_blank"> numpy.arange </a>来创建数据。如果你想了解更多关于线性关系的内容，请阅读<a class="ae kz" rel="noopener" target="_blank" href="/a-measure-of-linear-relationship-5dd4a995ee7e?source=friends_link&amp;sk=a68b5bc35334e5a501ead9900f0ea5db">线性关系的衡量标准</a>。我们导入 Python 库 numpy 和 matplotlib。我们创建了一个年份和一个二氧化碳阵列。</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="91c2" class="lf lg iu lb b gz lh li l lj lk">import numpy as np<br/>import matplotlib.pyplot as plt<br/>%matplotlib inline</span><span id="4ad2" class="lf lg iu lb b gz ll li l lj lk">year=np.array([1980,1982,1984,1986,1988,1990,1992,1994,1996,1998,2000])<br/>co2=np.array([338.7,341.1,344.4,347.2,351.5,354.2,356.4,358.9,362.6,366.6,369.4])</span></pre><p id="0ab2" class="pw-post-body-paragraph mk ml iu mm b mn nm jv mp mq nn jy ms mt no mv mw mx np mz na nb nq nd ne nf in bi translated">首先，我们使用 matplotlib 创建一个散点图。添加标题、标签、x 轴和 y 轴标签。你需要使用<code class="fe nr ns nt lb b">show()</code>方法。您可以在没有它的情况下进行打印，但这将删除不必要的输出。</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="32cc" class="lf lg iu lb b gz lh li l lj lk">plt.scatter(year,co2,label='CO2')<br/>plt.title("Year vs CO2")<br/>plt.xlabel('Year')<br/>plt.ylabel('CO2')<br/>plt.legend()<br/>plt.show()</span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nu"><img src="../Images/f271c71bddd9f9e208350a9e671a88c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4V_6wymEWVzQiaIaOH5yqA.png"/></div></div></figure><h2 id="e644" class="lf lg iu bd lu nv nw dn ly nx ny dp mc mt nz oa me mx ob oc mg nb od oe mi of bi translated">x 轴上的整数</h2><p id="3234" class="pw-post-body-paragraph mk ml iu mm b mn mo jv mp mq mr jy ms mt mu mv mw mx my mz na nb nc nd ne nf in bi translated">如上图所示，x 轴上有小数。在下面的代码中，我们使用前三行使它们成为整数。</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="dec1" class="lf lg iu lb b gz lh li l lj lk">from matplotlib.ticker import MaxNLocator</span><span id="feae" class="lf lg iu lb b gz ll li l lj lk">ax = plt.figure().gca()<br/>ax.xaxis.set_major_locator(MaxNLocator(integer=True))</span><span id="e9c9" class="lf lg iu lb b gz ll li l lj lk">plt.scatter(year,co2,label='CO2')<br/>plt.title("Year vs CO2")<br/>plt.xlabel('Year')<br/>plt.ylabel('CO2')<br/>plt.legend()<br/>plt.show()</span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj og"><img src="../Images/f9f0b44d0bcf13206d63424af9345316.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0219B9qTrbiMGULNbrJ2lg.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">x 轴上的整数</p></figure><h2 id="c7f7" class="lf lg iu bd lu nv nw dn ly nx ny dp mc mt nz oa me mx ob oc mg nb od oe mi of bi translated">用<code class="fe nr ns nt lb b">numpy.polyfit</code>和<code class="fe nr ns nt lb b">numpy.poly1d</code>寻找线性模型</h2><p id="32f5" class="pw-post-body-paragraph mk ml iu mm b mn mo jv mp mq mr jy ms mt mu mv mw mx my mz na nb nc nd ne nf in bi translated">最简单的方法就是用<code class="fe nr ns nt lb b">numpy.polyfit</code>。通过将 order 设置为 1，它将返回一个线性系数数组。在<code class="fe nr ns nt lb b">numpy.poly1d</code>中使用它会返回一个使用系数的等式。</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="4655" class="lf lg iu lb b gz lh li l lj lk">import numpy as np<br/>import matplotlib.pyplot as plt<br/>from matplotlib.ticker import MaxNLocator<br/>from sklearn.linear_model import LinearRegression<br/>%matplotlib inline</span><span id="b877" class="lf lg iu lb b gz ll li l lj lk">ax = plt.figure().gca()<br/>ax.xaxis.set_major_locator(MaxNLocator(integer=True))</span><span id="16cc" class="lf lg iu lb b gz ll li l lj lk">year=np.array([1980,1982,1984,1986,1988,1990,1992,1994,1996,1998,2000])<br/>co2=np.array([338.7,341.1,344.4,347.2,351.5,354.2,356.4,358.9,362.6,366.6,369.4])</span><span id="f65e" class="lf lg iu lb b gz ll li l lj lk">coef = np.polyfit(year, co2, 1)<br/>equ = np.poly1d(coef)</span><span id="37ce" class="lf lg iu lb b gz ll li l lj lk">x_plot = np.linspace(1975,2005,100)<br/>y_plot = equ(x_plot)<br/>plt.plot(x_plot, y_plot, color='r')</span><span id="fd53" class="lf lg iu lb b gz ll li l lj lk">plt.scatter(year,co2,label='CO2')<br/>plt.title("Year vs CO2")<br/>plt.xlabel('Year')<br/>plt.ylabel('CO2')<br/>plt.legend()<br/>plt.show()</span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oh"><img src="../Images/014dc2f1ee6ec0106821a1cdc565cf7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*alE83LwpllTJXf8X3RqN5g.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">散点图和线性回归线</p></figure><h2 id="56ac" class="lf lg iu bd lu nv nw dn ly nx ny dp mc mt nz oa me mx ob oc mg nb od oe mi of bi translated">使用 scikit-learn 查找线性模型</h2><p id="59b3" class="pw-post-body-paragraph mk ml iu mm b mn mo jv mp mq mr jy ms mt mu mv mw mx my mz na nb nc nd ne nf in bi translated">求回归斜率和截距的第二种方法是使用<code class="fe nr ns nt lb b"><a class="ae kz" href="https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LinearRegression.html" rel="noopener ugc nofollow" target="_blank">sklearn.linear_model.LinearRegression</a></code>。该类要求 x 值为一列。我们使用<code class="fe nr ns nt lb b">reshape(-1,1)</code>修改年份数据。原始年份数据具有 1x 11 形状。您需要将年份数据调整为 11 乘 1。</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="237c" class="lf lg iu lb b gz lh li l lj lk">year1=year.reshape((-1,1))<br/>print(np.shape(year))<br/>print(np.shape(year1))</span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj oi"><img src="../Images/88b00768d0d264348752256cdb9ca77e.png" data-original-src="https://miro.medium.com/v2/resize:fit:288/format:webp/1*1O3h8R2apYx2pJ2qUiU1-Q.png"/></div></figure><p id="18c4" class="pw-post-body-paragraph mk ml iu mm b mn nm jv mp mq nn jy ms mt no mv mw mx np mz na nb nq nd ne nf in bi translated">我们导入<code class="fe nr ns nt lb b"><a class="ae kz" href="https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LinearRegression.html" rel="noopener ugc nofollow" target="_blank">sklearn.linear_model.LinearRegression</a></code>，重塑年份数据，使用<code class="fe nr ns nt lb b">LinearRegression().fit()</code>拟合我们的数据。这将返回斜率<code class="fe nr ns nt lb b">coef_</code>和 y 轴截距<code class="fe nr ns nt lb b">intercept_</code>。<code class="fe nr ns nt lb b">coef_</code>返回一个数组，所以我们用<code class="fe nr ns nt lb b">reg.coef_[0]</code>取第一项。让我们打印出我们的回归线方程。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj oj"><img src="../Images/4c1dbbc31af1e93d25dcd7a310246727.png" data-original-src="https://miro.medium.com/v2/resize:fit:396/format:webp/1*QLUddHUtnUt1OA3D5vHgQQ.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">线性方程</p></figure><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="49df" class="lf lg iu lb b gz lh li l lj lk">from sklearn.linear_model import LinearRegression</span><span id="c77d" class="lf lg iu lb b gz ll li l lj lk">year1=year.reshape((-1,1))</span><span id="3e7c" class="lf lg iu lb b gz ll li l lj lk">reg = LinearRegression().fit(year1,co2)</span><span id="3f72" class="lf lg iu lb b gz ll li l lj lk">slope=reg.coef_[0]<br/>intercept=reg.intercept_</span><span id="7346" class="lf lg iu lb b gz ll li l lj lk">print(f'The equation of regression line is y={slope:.3f}x+{intercept:.3f}.')</span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ok"><img src="../Images/7b6c85cfd7b1e1a0308ac27356b04857.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CmXqqp-SUR4oJ2wlNbhNRQ.png"/></div></div></figure><h2 id="81a8" class="lf lg iu bd lu nv nw dn ly nx ny dp mc mt nz oa me mx ob oc mg nb od oe mi of bi translated">一起</h2><p id="3786" class="pw-post-body-paragraph mk ml iu mm b mn mo jv mp mq mr jy ms mt mu mv mw mx my mz na nb nc nd ne nf in bi translated">我们一起画一个散点图和我们的线性回归线。我们使用从 1975 年到 2005 年的新 x 域，取 100 个样本作为回归线，<code class="fe nr ns nt lb b">np.linspace(1975,2005,100)</code>。然后使用 x 域、斜率和 y 截距绘制回归线。</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="8a6e" class="lf lg iu lb b gz lh li l lj lk">import numpy as np<br/>import matplotlib.pyplot as plt<br/>from matplotlib.ticker import MaxNLocator<br/>from sklearn.linear_model import LinearRegression<br/>%matplotlib inline</span><span id="afda" class="lf lg iu lb b gz ll li l lj lk">ax = plt.figure().gca()<br/>ax.xaxis.set_major_locator(MaxNLocator(integer=True))</span><span id="e8d4" class="lf lg iu lb b gz ll li l lj lk">year=np.array([1980,1982,1984,1986,1988,1990,1992,1994,1996,1998,2000])<br/>co2=np.array([338.7,341.1,344.4,347.2,351.5,354.2,356.4,358.9,362.6,366.6,369.4])</span><span id="48e5" class="lf lg iu lb b gz ll li l lj lk">year1=year.reshape((-1,1))</span><span id="f1f7" class="lf lg iu lb b gz ll li l lj lk">reg = LinearRegression().fit(year1,co2) <br/>slope=reg.coef_[0]<br/>intercept=reg.intercept_</span><span id="a98c" class="lf lg iu lb b gz ll li l lj lk">plt.scatter(year,co2,label='CO2')<br/>X_plot = np.linspace(1975,2005,100)<br/>Y_plot = slope*X_plot+intercept<br/>plt.plot(X_plot, Y_plot, color='r')<br/>plt.title("Year vs CO2")<br/>plt.xlabel('Year')<br/>plt.ylabel('CO2')<br/>plt.legend()<br/>plt.show()</span><span id="b9ef" class="lf lg iu lb b gz ll li l lj lk">print(f'The equation of regression line is y={slope:.3f}x+{intercept:.3f}.')</span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ol"><img src="../Images/16100e40635a189c6f4ef94cdbe2f338.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2HUCBH2NFxqt8RD-7aExVg.png"/></div></div></figure><h2 id="dcce" class="lf lg iu bd lu nv nw dn ly nx ny dp mc mt nz oa me mx ob oc mg nb od oe mi of bi translated">用 scipy 寻找线性模型</h2><p id="3845" class="pw-post-body-paragraph mk ml iu mm b mn mo jv mp mq mr jy ms mt mu mv mw mx my mz na nb nc nd ne nf in bi translated">另一种寻找回归斜率和截距的方法是使用<code class="fe nr ns nt lb b"><a class="ae kz" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.linregress.html" rel="noopener ugc nofollow" target="_blank">scipy.stats.linregress</a></code>。这将返回<code class="fe nr ns nt lb b">slope, intercept, rvalue, pvalue, stderr</code>。</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="7848" class="lf lg iu lb b gz lh li l lj lk">from scipy.stats import linregress</span><span id="e24f" class="lf lg iu lb b gz ll li l lj lk">slope, intercept, r_value, p_value, std_err = linregress(year,co2)<br/>print(f'The equation of regression line is y={slope:.3f}x+{intercept:.3f}.')</span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj om"><img src="../Images/00406a2b787625b79abcdbb87d6d48d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4HBR0hNLzrHHPbd03ehqpQ.png"/></div></div></figure><h2 id="74dd" class="lf lg iu bd lu nv nw dn ly nx ny dp mc mt nz oa me mx ob oc mg nb od oe mi of bi translated">线性回归图</h2><p id="3cd9" class="pw-post-body-paragraph mk ml iu mm b mn mo jv mp mq mr jy ms mt mu mv mw mx my mz na nb nc nd ne nf in bi translated">为了画一条线，我们需要 x 个点。我们使用<code class="fe nr ns nt lb b">np.linspace</code>，它是<code class="fe nr ns nt lb b">numpy.linspace</code>，因为我们使用了<code class="fe nr ns nt lb b">import numpy as np</code>。我们的数据是从 1975 年到 2000 年。所以我们用 1960 代表<code class="fe nr ns nt lb b">start</code>，2005 代表<code class="fe nr ns nt lb b">stop</code>，100 代表样本数。</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="a76e" class="lf lg iu lb b gz lh li l lj lk">import numpy as np<br/>import matplotlib.pyplot as plt<br/>from scipy.stats import linregress<br/>%matplotlib inline</span><span id="b31f" class="lf lg iu lb b gz ll li l lj lk">year=np.array([1980,1982,1984,1986,1988,1990,1992,1994,1996,1998,2000])<br/>co2=np.array([338.7,341.1,344.4,347.2,351.5,354.2,356.4,358.9,362.6,366.6,369.4])</span><span id="44f1" class="lf lg iu lb b gz ll li l lj lk">X_plot = np.linspace(1975,2005,100)<br/>Y_plot = slope*X_plot+intercept<br/>plt.plot(X_plot, Y_plot, color='r')<br/>plt.show()</span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj on"><img src="../Images/43e68da2b005f58c9051d2044803c430.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kXIs8PKUTvKU5RfOyEHLmw.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">使用 scipy . Lin regression 的线性回归线</p></figure><p id="b56b" class="pw-post-body-paragraph mk ml iu mm b mn nm jv mp mq nn jy ms mt no mv mw mx np mz na nb nq nd ne nf in bi translated">现在我们把散点图、回归线和回归方程放在一起。</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="c01e" class="lf lg iu lb b gz lh li l lj lk">import numpy as np<br/>import matplotlib.pyplot as plt<br/>from matplotlib.ticker import MaxNLocator<br/>from scipy.stats import linregress</span><span id="57aa" class="lf lg iu lb b gz ll li l lj lk">%matplotlib inline</span><span id="8b98" class="lf lg iu lb b gz ll li l lj lk">ax = plt.figure().gca()<br/>ax.xaxis.set_major_locator(MaxNLocator(integer=True))<br/>slope, intercept, r_value, p_value, std_err = linregress(year,co2)<br/>X_plot = np.linspace(1975,2005,100)<br/>Y_plot = slope*X_plot+intercept<br/>plt.plot(X_plot, Y_plot, color='r')<br/>plt.scatter(year,co2,label='CO2')<br/>plt.title("Year vs CO2")<br/>plt.xlabel('Year')<br/>plt.ylabel('CO2')<br/>plt.legend()<br/>plt.show()</span><span id="a3a0" class="lf lg iu lb b gz ll li l lj lk">print(f'The equation of regression line is y={slope:.3f}x+{intercept:.3f}.')</span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oo"><img src="../Images/a00d200238593a00cef4b2741dc12d48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xYDls2OcYXqmLnA5809VPg.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">散点图和线性回归线</p></figure><h2 id="59ba" class="lf lg iu bd lu nv nw dn ly nx ny dp mc mt nz oa me mx ob oc mg nb od oe mi of bi translated">练习 1</h2><p id="3b20" class="pw-post-body-paragraph mk ml iu mm b mn mo jv mp mq mr jy ms mt mu mv mw mx my mz na nb nc nd ne nf in bi translated">使用以下数据绘制散点图和回归线。求一个线性回归方程。</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="9c3c" class="lf lg iu lb b gz lh li l lj lk">import numpy as np<br/>import matplotlib.pyplot as plt<br/>%matplotlib inline</span><span id="ade2" class="lf lg iu lb b gz ll li l lj lk">temp = np.array([55,60,65,70,75,80,85,90])<br/>rate = np.array([45,80,92,114,141,174,202,226])</span></pre><h2 id="bf54" class="lf lg iu bd lu nv nw dn ly nx ny dp mc mt nz oa me mx ob oc mg nb od oe mi of bi translated">回答</h2><p id="ee42" class="pw-post-body-paragraph mk ml iu mm b mn mo jv mp mq mr jy ms mt mu mv mw mx my mz na nb nc nd ne nf in bi translated">你画了散点图和回归图吗？回归线应该是<em class="op">𝑦</em>= 5.119<em class="op">𝑥</em>—236.88。</p></div><div class="ab cl lm ln hy lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="in io ip iq ir"><div class="kk kl km kn gu oq"><a rel="noopener follow" target="_blank" href="/the-subtlety-of-spearmans-rank-correlation-coefficient-29478653bbb9"><div class="or ab fp"><div class="os ab ot cl cj ou"><h2 class="bd iv gz z fq ov fs ft ow fv fx it bi translated">斯皮尔曼等级相关系数的微妙性</h2><div class="ox l"><h3 class="bd b gz z fq ov fs ft ow fv fx dk translated">单调关系的未知部分</h3></div><div class="oy l"><p class="bd b dl z fq ov fs ft ow fv fx dk translated">towardsdatascience.com</p></div></div><div class="oz l"><div class="pa l pb pc pd oz pe kt oq"/></div></div></a></div></div><div class="ab cl lm ln hy lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="in io ip iq ir"><h1 id="005e" class="lt lg iu bd lu lv lw lx ly lz ma mb mc ka md kb me kd mf ke mg kg mh kh mi mj bi translated">二次模型</h1><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj pf"><img src="../Images/27224fdab17bf0d4905e1511a684a45b.png" data-original-src="https://miro.medium.com/v2/resize:fit:604/format:webp/1*x-lA6hMydaABdtGvhILhfA.png"/></div></figure><p id="14cd" class="pw-post-body-paragraph mk ml iu mm b mn nm jv mp mq nn jy ms mt no mv mw mx np mz na nb nq nd ne nf in bi translated">我们使用 Numpy 的<code class="fe nr ns nt lb b">arange</code>来创建从 0 到 9 的 10 个整数。</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="6245" class="lf lg iu lb b gz lh li l lj lk">import numpy as np<br/>import matplotlib.pyplot as plt<br/>%matplotlib inline</span><span id="a152" class="lf lg iu lb b gz ll li l lj lk">time = np.arange(10)<br/>height = np.array([450,445,430,409,375,331,280,215,144,59])</span></pre><p id="c4fc" class="pw-post-body-paragraph mk ml iu mm b mn nm jv mp mq nn jy ms mt no mv mw mx np mz na nb nq nd ne nf in bi translated">我们来绘制上面的数据。</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="0456" class="lf lg iu lb b gz lh li l lj lk">import numpy as np<br/>import matplotlib.pyplot as plt<br/>%matplotlib inline</span><span id="c3de" class="lf lg iu lb b gz ll li l lj lk">plt.scatter(time,height,label='Height of a ball')<br/>plt.title("Time vs Height")<br/>plt.xlabel('Time')<br/>plt.ylabel('Height')<br/>plt.legend()<br/>plt.show()</span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj pg"><img src="../Images/bcb3ee0ca5b5000901475baab6399007.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dgyBE8JOi4DQmX-smtbuMw.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">二次回归图</p></figure><p id="cd08" class="pw-post-body-paragraph mk ml iu mm b mn nm jv mp mq nn jy ms mt no mv mw mx np mz na nb nq nd ne nf in bi translated"><code class="fe nr ns nt lb b">numpy.polyfit</code>拟合多项式。它需要 x，y 和拟合多项式的次数。二次为 2，三次为 3，以此类推。它返回一个数组，该数组的多项式系数为常数的高次幂。对于二次函数，它们是 a、b 和 c:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj ph"><img src="../Images/88bd4a5a94070c6f4c9c5ffe7d0a3ccf.png" data-original-src="https://miro.medium.com/v2/resize:fit:520/format:webp/1*rvIHSYifG1WwNb0svsP1Sg.png"/></div></figure><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="77d1" class="lf lg iu lb b gz lh li l lj lk">coef = np.polyfit(time, height, 2)<br/>coef</span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj pi"><img src="../Images/24ce59ffd7f3ab6259f1385853b19218.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x-sdT7DGfdkn_TmqZogJ8Q.png"/></div></div></figure><p id="cc5a" class="pw-post-body-paragraph mk ml iu mm b mn nm jv mp mq nn jy ms mt no mv mw mx np mz na nb nq nd ne nf in bi translated">让我们打印出二次回归线。</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="b041" class="lf lg iu lb b gz lh li l lj lk">print(f'The equation of regression line is y=')<br/>print(equ)</span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj pj"><img src="../Images/ef8ca77da3ded3f3a03493b69f4cffa4.png" data-original-src="https://miro.medium.com/v2/resize:fit:670/format:webp/1*UHL5EUTfzNt6UQmiO39Cyw.png"/></div></figure><p id="532a" class="pw-post-body-paragraph mk ml iu mm b mn nm jv mp mq nn jy ms mt no mv mw mx np mz na nb nq nd ne nf in bi translated">或者使用系数，回归线是:</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="8b58" class="lf lg iu lb b gz lh li l lj lk">print(f'The equation of regression line is y={coef[0]:.3f}x^2+{coef[1]:.3f}x+{coef[2]:.3f}.')</span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj pk"><img src="../Images/9f681d6c81e26ad3f80d5e0c69804f00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5tJoCKIjPGUSmLd09hk_Rg.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">二次回归方程</p></figure><p id="a8ca" class="pw-post-body-paragraph mk ml iu mm b mn nm jv mp mq nn jy ms mt no mv mw mx np mz na nb nq nd ne nf in bi translated">我们再次使用 NumPy 的<code class="fe nr ns nt lb b">poly1d</code>和<code class="fe nr ns nt lb b">polyfit</code>。<code class="fe nr ns nt lb b">np.poly1d(coefficients)</code>将使用我们的系数返回一个多项式方程。</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="1efa" class="lf lg iu lb b gz lh li l lj lk">equ = np.poly1d(coef)</span></pre><p id="fbcc" class="pw-post-body-paragraph mk ml iu mm b mn nm jv mp mq nn jy ms mt no mv mw mx np mz na nb nq nd ne nf in bi translated">我们可以找到任意 x 的值。例如，如果您想在 x=1 时找到 y 值:</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="8b83" class="lf lg iu lb b gz lh li l lj lk">equ(1)</span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj pl"><img src="../Images/7a3db5ffa22e31990ee0a17448ceba1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/format:webp/1*dedlD1Gd-TR09aozkgm2PA.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">x=1 时的 y 值</p></figure><p id="cd05" class="pw-post-body-paragraph mk ml iu mm b mn nm jv mp mq nn jy ms mt no mv mw mx np mz na nb nq nd ne nf in bi translated">我们用这个来画回归线。我们使用<code class="fe nr ns nt lb b">numpy.linspace</code>为 100 个样本定义从 0 到 10 的 x 值。并在<code class="fe nr ns nt lb b">equ</code>中使用它作为 y 值。</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="d772" class="lf lg iu lb b gz lh li l lj lk">import numpy as np<br/>import matplotlib.pyplot as plt<br/>%matplotlib inline</span><span id="51c2" class="lf lg iu lb b gz ll li l lj lk">x_plot = np.linspace(0,10,100)<br/>y_plot = equ(x_plot)<br/>plt.plot(x_plot, y_plot, color='r')<br/>plt.show()</span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj pm"><img src="../Images/2c5128c3819b78c7b5e41eb782ecda12.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/format:webp/1*ZTVfekMNagLFQxpzuxhHXg.png"/></div></figure><p id="5c53" class="pw-post-body-paragraph mk ml iu mm b mn nm jv mp mq nn jy ms mt no mv mw mx np mz na nb nq nd ne nf in bi translated">我们把它们放在一起。</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="d439" class="lf lg iu lb b gz lh li l lj lk">import numpy as np<br/>import matplotlib.pyplot as plt<br/>%matplotlib inline</span><span id="defa" class="lf lg iu lb b gz ll li l lj lk">time = np.arange(10)<br/>height = np.array([450,445,430,409,375,331,280,215,144,59])</span><span id="0166" class="lf lg iu lb b gz ll li l lj lk">coef = np.polyfit(time, height, 2)<br/>equ = np.poly1d(coef)</span><span id="99a6" class="lf lg iu lb b gz ll li l lj lk">x_plot = np.linspace(0,10,100)<br/>y_plot = equ(x_plot)<br/>plt.plot(x_plot, y_plot, color='r')</span><span id="9f24" class="lf lg iu lb b gz ll li l lj lk">plt.scatter(time,height,label='Height of a ball')<br/>plt.title("Time vs Height")<br/>plt.xlabel('Time')<br/>plt.ylabel('Height')<br/>plt.legend()<br/>plt.show()</span><span id="b850" class="lf lg iu lb b gz ll li l lj lk">print(f'The equation of regression line is y=')<br/>print(equ)</span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj pn"><img src="../Images/7858eece53c4fc1058d8fe397ad36879.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/format:webp/1*iCg_tIoi0OtJ_XJ5Slrvdw.png"/></div></figure><h2 id="8b8e" class="lf lg iu bd lu nv nw dn ly nx ny dp mc mt nz oa me mx ob oc mg nb od oe mi of bi translated">练习 2</h2><p id="83ff" class="pw-post-body-paragraph mk ml iu mm b mn mo jv mp mq mr jy ms mt mu mv mw mx my mz na nb nc nd ne nf in bi translated">通过使用以下数据，在图表中绘制散点图和回归线。求二次回归方程。</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="40f8" class="lf lg iu lb b gz lh li l lj lk">import numpy as np<br/>import matplotlib.pyplot as plt<br/>%matplotlib inline</span><span id="0d3d" class="lf lg iu lb b gz ll li l lj lk">angle = np.arange(20,80,10)<br/>distance = np.array([371,465,511,498,439,325])</span></pre><h2 id="0ebf" class="lf lg iu bd lu nv nw dn ly nx ny dp mc mt nz oa me mx ob oc mg nb od oe mi of bi translated">回答</h2><p id="737b" class="pw-post-body-paragraph mk ml iu mm b mn mo jv mp mq mr jy ms mt mu mv mw mx my mz na nb nc nd ne nf in bi translated">你能画一条散点线和回归线吗？二次方程应该是:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj po"><img src="../Images/a20587d27dc51e82edafe52120feaee0.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*aS_JW8VMd3dfsCTJhYXxzw.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">二次回归练习答案</p></figure></div><div class="ab cl lm ln hy lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="in io ip iq ir"><div class="kk kl km kn gu oq"><a rel="noopener follow" target="_blank" href="/gentle-introduction-to-chi-square-test-for-independence-7182a7414a95"><div class="or ab fp"><div class="os ab ot cl cj ou"><h2 class="bd iv gz z fq ov fs ft ow fv fx it bi translated">卡方独立性检验简介</h2><div class="ox l"><h3 class="bd b gz z fq ov fs ft ow fv fx dk translated">使用 Jupyter 笔记本的卡方初学者指南</h3></div><div class="oy l"><p class="bd b dl z fq ov fs ft ow fv fx dk translated">towardsdatascience.com</p></div></div><div class="oz l"><div class="pp l pb pc pd oz pe kt oq"/></div></div></a></div></div><div class="ab cl lm ln hy lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="in io ip iq ir"><h1 id="35bc" class="lt lg iu bd lu lv lw lx ly lz ma mb mc ka md kb me kd mf ke mg kg mh kh mi mj bi translated">立方模型</h1><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj pq"><img src="../Images/d6db4fa4ef6f7419951981b1fd39edc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:382/format:webp/1*dPVisMSEySdEGMgMkn2wvQ.png"/></div></figure><p id="9352" class="pw-post-body-paragraph mk ml iu mm b mn nm jv mp mq nn jy ms mt no mv mw mx np mz na nb nq nd ne nf in bi translated">可以用和上面二次函数一样的方法。我们要用<code class="fe nr ns nt lb b">plyfit</code>和<code class="fe nr ns nt lb b">poly1d</code>。首先，我们准备数据。让我们画一个散点图。</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="2941" class="lf lg iu lb b gz lh li l lj lk">import numpy as np<br/>import matplotlib.pyplot as plt<br/>%matplotlib inline</span><span id="bf50" class="lf lg iu lb b gz ll li l lj lk">engspeed = np.arange(9,23,2)<br/>avespeed = np.array([6.45,7.44,8.88,9.66,10.98,12.56,15.44])</span><span id="cd02" class="lf lg iu lb b gz ll li l lj lk">plt.scatter(engspeed,avespeed,label='Speed of different boat engine')</span><span id="ba1f" class="lf lg iu lb b gz ll li l lj lk">plt.title("Average speed of different boat engine")<br/>plt.xlabel('Engine speed')<br/>plt.ylabel('Boad speed')<br/>plt.ylim(0,20)<br/>plt.legend()<br/>plt.show()</span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj pr"><img src="../Images/30242f61306e54566fc3206ca555c25a.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/1*cL_eCqne1Qo8Ej07Vhx1eg.png"/></div></figure><p id="730d" class="pw-post-body-paragraph mk ml iu mm b mn nm jv mp mq nn jy ms mt no mv mw mx np mz na nb nq nd ne nf in bi translated">使用<code class="fe nr ns nt lb b">polyfit</code>返回系数。对于三次函数，a、b、c 和 d 在:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj ps"><img src="../Images/8e7b356dd00eb9c91b3eaa9cb6345cf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/format:webp/1*OTtF8gQG-yhYjTGCCPqpKg.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">立方函数</p></figure><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="04a7" class="lf lg iu lb b gz lh li l lj lk">coef = np.polyfit(engspeed, avespeed, 3)<br/>print(coef)</span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj pt"><img src="../Images/cae9b4ec1ce10c6b4bdc1cbf19a94f73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FFxycwKImsbbw6q1OXJ_eg.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">三次函数的系数</p></figure><p id="fbd5" class="pw-post-body-paragraph mk ml iu mm b mn nm jv mp mq nn jy ms mt no mv mw mx np mz na nb nq nd ne nf in bi translated">我们把所有的放在一起。</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="1bf8" class="lf lg iu lb b gz lh li l lj lk">import numpy as np<br/>import matplotlib.pyplot as plt<br/>%matplotlib inline</span><span id="e990" class="lf lg iu lb b gz ll li l lj lk">engspeed = np.arange(9,23,2)<br/>avespeed = np.array([6.45,7.44,8.88,9.66,10.98,12.56,15.44])</span><span id="c683" class="lf lg iu lb b gz ll li l lj lk">plt.scatter(engspeed,avespeed,label='Speed of different boat engine')</span><span id="c55f" class="lf lg iu lb b gz ll li l lj lk">coef = np.polyfit(engspeed, avespeed, 3)<br/>equ = np.poly1d(coef)</span><span id="426b" class="lf lg iu lb b gz ll li l lj lk">x_plot = np.linspace(8,25,100)<br/>y_plot = equ(x_plot)<br/>plt.plot(x_plot, y_plot, color='r')</span><span id="d91e" class="lf lg iu lb b gz ll li l lj lk">plt.title("Average speed of different boat engine")<br/>plt.xlabel('Engine speed')<br/>plt.ylabel('Boad speed')<br/>plt.ylim(0,20)<br/>plt.legend()<br/>plt.show()</span><span id="03dc" class="lf lg iu lb b gz ll li l lj lk">a, b, c, d = coef<br/>print(f'The equation of regression line is y={a:.3f}x^3+{b:.3f}x^2+{c:.3f}x+{d}.')</span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj pu"><img src="../Images/f53001dd03fd9df08c69d3c6879e7385.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/1*PKfC8dTxuhuZTcQHy9PBcA.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">散点图和三次回归线</p></figure><h2 id="b55f" class="lf lg iu bd lu nv nw dn ly nx ny dp mc mt nz oa me mx ob oc mg nb od oe mi of bi translated">练习 3</h2><p id="49ed" class="pw-post-body-paragraph mk ml iu mm b mn mo jv mp mq mr jy ms mt mu mv mw mx my mz na nb nc nd ne nf in bi translated">使用以下数据绘制散点图和三次回归线。打印三次方程。</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="3300" class="lf lg iu lb b gz lh li l lj lk">import numpy as np<br/>import matplotlib.pyplot as plt<br/>%matplotlib inline</span><span id="8d8e" class="lf lg iu lb b gz ll li l lj lk">x=np.arange(1,8)<br/>y=np.array([0,0.012,0.06,0.162,0.336,0.6,0.972])</span></pre><h2 id="9804" class="lf lg iu bd lu nv nw dn ly nx ny dp mc mt nz oa me mx ob oc mg nb od oe mi of bi translated">回答</h2><p id="54d3" class="pw-post-body-paragraph mk ml iu mm b mn mo jv mp mq mr jy ms mt mu mv mw mx my mz na nb nc nd ne nf in bi translated">你能画出散点图和回归线吗？回归线方程应为:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj pv"><img src="../Images/6cb2ed0c87219c6ac320d77cd2ffaba3.png" data-original-src="https://miro.medium.com/v2/resize:fit:912/format:webp/1*4kyJiF1MQE-bQ490v6TCqw.png"/></div></figure><p id="7c8f" class="pw-post-body-paragraph mk ml iu mm b mn nm jv mp mq nn jy ms mt no mv mw mx np mz na nb nq nd ne nf in bi translated">系数为[3.000000000 e-03，-1.16796094e-16，-9.000000000 e-03，6.00000000e-03]。这些意味着:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj pw"><img src="../Images/b33ca4e863df9427f8d3a01ebc4db931.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*iEzTuwOajt6CaP9EGlMEhg.png"/></div></figure><p id="42e6" class="pw-post-body-paragraph mk ml iu mm b mn nm jv mp mq nn jy ms mt no mv mw mx np mz na nb nq nd ne nf in bi translated">第二个实际上是 0。尝试以下方法，看看两者是否都是相同的 0.3。</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="a1b4" class="lf lg iu lb b gz lh li l lj lk">print(300e-03)<br/>print(300*10**(-3))</span></pre></div><div class="ab cl lm ln hy lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="in io ip iq ir"><h1 id="7b2b" class="lt lg iu bd lu lv lw lx ly lz ma mb mc ka md kb me kd mf ke mg kg mh kh mi mj bi translated">指数模型</h1><p id="2449" class="pw-post-body-paragraph mk ml iu mm b mn mo jv mp mq mr jy ms mt mu mv mw mx my mz na nb nc nd ne nf in bi translated">我们将探索三种指数模型。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj px"><img src="../Images/8b76f405bff36837cab1d3099eaa940c.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/format:webp/1*zdfNe6hayQaPBURwDvHo8w.png"/></div></figure><p id="7bd1" class="pw-post-body-paragraph mk ml iu mm b mn nm jv mp mq nn jy ms mt no mv mw mx np mz na nb nq nd ne nf in bi translated">让我们设置数据。画一个散点图。</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="3190" class="lf lg iu lb b gz lh li l lj lk">import numpy as np<br/>import matplotlib.pyplot as plt<br/>%matplotlib inline</span><span id="d031" class="lf lg iu lb b gz ll li l lj lk">day = np.arange(0,8)<br/>weight = np.array([251,209,157,129,103,81,66,49])</span><span id="9d1f" class="lf lg iu lb b gz ll li l lj lk">plt.scatter(day,weight,label='Weight change')<br/>plt.title("Day vs Weight")<br/>plt.xlabel('Day')<br/>plt.ylabel('Weight')<br/>plt.legend()<br/>plt.show()</span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj py"><img src="../Images/8c95f1e8fe7cb6eadcf7d0f3dc8d8953.png" data-original-src="https://miro.medium.com/v2/resize:fit:812/format:webp/1*KkIFZ-osxHz7pViTcrblWw.png"/></div></figure><p id="f026" class="pw-post-body-paragraph mk ml iu mm b mn nm jv mp mq nn jy ms mt no mv mw mx np mz na nb nq nd ne nf in bi translated">我们要用<code class="fe nr ns nt lb b"><a class="ae kz" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.curve_fit.html" rel="noopener ugc nofollow" target="_blank">scipy.optimize.curve_fit</a></code>。这需要一个函数，x 和 y 值，和初始值，<code class="fe nr ns nt lb b">p0</code>以数组的形式。找到合适的<code class="fe nr ns nt lb b">p0</code>需要一点反复试验。你必须测试不同的价值观。我们用<code class="fe nr ns nt lb b">p0=(1, 1e-6, 1)</code>。它返回参数的最优值和 popt 的估计协方差。</p><h1 id="39cf" class="lt lg iu bd lu lv ng lx ly lz nh mb mc ka ni kb me kd nj ke mg kg nk kh mi mj bi">𝑎⋅𝑒^−𝑏𝑥+𝑐</h1><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj pz"><img src="../Images/4ddecf23c14ff72da11e8b07e9f32e42.png" data-original-src="https://miro.medium.com/v2/resize:fit:568/format:webp/1*wjm8Y90cOLpPzAM2H0d2RQ.png"/></div></figure><p id="141b" class="pw-post-body-paragraph mk ml iu mm b mn nm jv mp mq nn jy ms mt no mv mw mx np mz na nb nq nd ne nf in bi translated">我们的第一个指数函数使用 a、b 和 c。我们将首先定义一个函数。这在<code class="fe nr ns nt lb b">curve_fit</code>方法中使用。对于平滑曲线，我们用 100 个样本使用<code class="fe nr ns nt lb b">numpy.linspace</code>从 0 到 7 设置 x 值。</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="47fe" class="lf lg iu lb b gz lh li l lj lk">import numpy as np<br/>import matplotlib.pyplot as plt<br/>from scipy.optimize import curve_fit<br/>%matplotlib inline</span><span id="5995" class="lf lg iu lb b gz ll li l lj lk">def func(x, a, b, c):<br/>    return a * np.exp(-b * x) + c</span><span id="432d" class="lf lg iu lb b gz ll li l lj lk">popt, pcov = curve_fit(func, day, weight, p0=[1, 1e-6, 1])</span><span id="e4d7" class="lf lg iu lb b gz ll li l lj lk">x_plot=np.linspace(0,7,100)<br/>plt.plot(x_plot, func(x_plot, *popt), 'r-')</span><span id="df59" class="lf lg iu lb b gz ll li l lj lk">plt.scatter(day,weight,label='Day vs Weight')<br/>plt.title("Day vs Weight a*e^-bx +c")<br/>plt.xlabel('Day')<br/>plt.ylabel('Weight')<br/>plt.legend()<br/>plt.show()</span><span id="21f7" class="lf lg iu lb b gz ll li l lj lk"># equation<br/>a=popt[0].round(2)<br/>b=popt[1].round(2)<br/>c=popt[2].round(2)</span><span id="d717" class="lf lg iu lb b gz ll li l lj lk">print(f'The equation of regression line is y={a}e^({b}x)+{c}')</span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj qa"><img src="../Images/5b32c1f7cfd0b1454c56cf454d48d290.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LIjxLIaxiesQ_s-Gp6tXAw.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">散点图和指数回归线</p></figure><h1 id="7a6b" class="lt lg iu bd lu lv ng lx ly lz nh mb mc ka ni kb me kd nj ke mg kg nk kh mi mj bi">𝑎⋅𝑒^−𝑏𝑥</h1><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj qb"><img src="../Images/d1dee3a920b12747b791073f598df9c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:432/format:webp/1*s3FKNI1Fye63v11Jtj0Ghg.png"/></div></figure><p id="d60e" class="pw-post-body-paragraph mk ml iu mm b mn nm jv mp mq nn jy ms mt no mv mw mx np mz na nb nq nd ne nf in bi translated">第二个函数使用 a 和 b。我们相应地定义函数。</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="5a35" class="lf lg iu lb b gz lh li l lj lk">import numpy as np<br/>import matplotlib.pyplot as plt<br/>from scipy.optimize import curve_fit<br/>%matplotlib inline</span><span id="cdbf" class="lf lg iu lb b gz ll li l lj lk">def func2(x, a, b):<br/>    return a * np.exp(-b * x)</span><span id="3388" class="lf lg iu lb b gz ll li l lj lk">popt, pcov = curve_fit(func2, day, weight, p0=[1, 1e-6])</span><span id="6f3a" class="lf lg iu lb b gz ll li l lj lk">x_plot=np.linspace(0,7,100)<br/>plt.plot(x_plot, func2(x_plot, *popt), 'r-')</span><span id="5b6b" class="lf lg iu lb b gz ll li l lj lk">plt.scatter(day,weight,label='Day vs Weight')<br/>plt.title("Day vs Weight a*e^-bx")<br/>plt.xlabel('Day')<br/>plt.ylabel('Weight')<br/>plt.legend()<br/>plt.show()</span><span id="8882" class="lf lg iu lb b gz ll li l lj lk"># equation<br/>a=popt[0].round(2)<br/>b=popt[1].round(2)</span><span id="f6d2" class="lf lg iu lb b gz ll li l lj lk">print(f'The equation of regression line is y={a}e^({b}x)')</span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj qc"><img src="../Images/d647968ca520765fdbd552446d89b7d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fiZCqo3eQgCjmEzLK64dEw.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">指数回归线的第二个例子</p></figure><h1 id="e28d" class="lt lg iu bd lu lv ng lx ly lz nh mb mc ka ni kb me kd nj ke mg kg nk kh mi mj bi">𝑎⋅𝑏^𝑥</h1><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj qd"><img src="../Images/6cd0fd6c98f7f86f8558da4b7b89dde4.png" data-original-src="https://miro.medium.com/v2/resize:fit:336/format:webp/1*RH_OvJLwyUvlX9NnK0ozVg.png"/></div></figure><p id="733a" class="pw-post-body-paragraph mk ml iu mm b mn nm jv mp mq nn jy ms mt no mv mw mx np mz na nb nq nd ne nf in bi translated">最后一个指数函数使用 a 和 b，我们相应地修改函数。</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="acab" class="lf lg iu lb b gz lh li l lj lk">import numpy as np<br/>import matplotlib.pyplot as plt<br/>from scipy.optimize import curve_fit<br/>%matplotlib inline</span><span id="508a" class="lf lg iu lb b gz ll li l lj lk">def func3(x, a, b):<br/>    return a * b ** x</span><span id="7b52" class="lf lg iu lb b gz ll li l lj lk">popt, pcov = curve_fit(func3, day, weight, p0=[1, 1e-6])<br/>x_plot=np.linspace(0,7,100)<br/>plt.plot(x_plot, func3(x_plot, *popt), 'r-')</span><span id="e9e4" class="lf lg iu lb b gz ll li l lj lk">plt.scatter(day,weight,label='Day vs Weight')<br/>plt.title("Day vs Weight a*b^x")<br/>plt.xlabel('Day')<br/>plt.ylabel('Weight')<br/>plt.legend()<br/>plt.show()</span><span id="89dc" class="lf lg iu lb b gz ll li l lj lk"># equation<br/>a=popt[0].round(4)<br/>b=popt[1].round(4)</span><span id="02cf" class="lf lg iu lb b gz ll li l lj lk">print(f'The equation of regression line is y={a}*{b}^x')</span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj qe"><img src="../Images/caf1c0dfac9cf6e0b6107fb40e9e5bb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ox2X314M4afYNBwNKTSYZA.png"/></div></div></figure><h2 id="cb41" class="lf lg iu bd lu nv nw dn ly nx ny dp mc mt nz oa me mx ob oc mg nb od oe mi of bi translated">与 TI Nspire 结果比较</h2><p id="7e4b" class="pw-post-body-paragraph mk ml iu mm b mn mo jv mp mq mr jy ms mt mu mv mw mx my mz na nb nc nd ne nf in bi translated">TI Nspire 的指数回归使用转换值 x 和𝑙𝑛的最小二乘拟合，将模型方程<em class="op"> 𝑦 </em> = <em class="op"> 𝑎𝑏^𝑥 </em>拟合到数据上<em class="op">(<em class="op">𝑦</em>)。它返回不同的值。</em></p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj qf"><img src="../Images/326ca5b8125de79e37efcb62745d2df9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tG1XPmH_bXLOrQLVNAQdsw.png"/></div></div></figure><h2 id="6f70" class="lf lg iu bd lu nv nw dn ly nx ny dp mc mt nz oa me mx ob oc mg nb od oe mi of bi translated">实践</h2><p id="6fa1" class="pw-post-body-paragraph mk ml iu mm b mn mo jv mp mq mr jy ms mt mu mv mw mx my mz na nb nc nd ne nf in bi translated">使用下列数据找出 ab^x.形式的指数函数，绘制散点图并绘制回归线。</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="5632" class="lf lg iu lb b gz lh li l lj lk">import numpy as np</span><span id="c12f" class="lf lg iu lb b gz ll li l lj lk">week = np.arange(1,21)<br/>views = np.array([102365, 38716,21617,24305,9321,14148,2103,8285,5098,3777,831,1007,834,34,378,204,6,42,54,31])</span></pre><h2 id="ccbd" class="lf lg iu bd lu nv nw dn ly nx ny dp mc mt nz oa me mx ob oc mg nb od oe mi of bi translated">回答</h2><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj qg"><img src="../Images/4645dcc8abc2ae4d1606e1396cfbe265.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c4l9bOLo2zFpL-s86elP8g.png"/></div></div></figure><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj qh"><img src="../Images/e5094baf2e878a4836f192fd5456230a.png" data-original-src="https://miro.medium.com/v2/resize:fit:476/format:webp/1*SpXWwAVxlNXmbR2kseEFfw.png"/></div></figure></div><div class="ab cl lm ln hy lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="in io ip iq ir"><h1 id="ec20" class="lt lg iu bd lu lv lw lx ly lz ma mb mc ka md kb me kd mf ke mg kg mh kh mi mj bi translated">对数模型</h1><h2 id="91a0" class="lf lg iu bd lu nv nw dn ly nx ny dp mc mt nz oa me mx ob oc mg nb od oe mi of bi translated">半对数模型</h2><p id="2d9e" class="pw-post-body-paragraph mk ml iu mm b mn mo jv mp mq mr jy ms mt mu mv mw mx my mz na nb nc nd ne nf in bi translated">通常，我们对指数函数使用半对数模型:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj qi"><img src="../Images/a2a90423b1db22d7770cb2c962c2186a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/format:webp/1*-Hbe3A7g-698oNGoRFGAPg.png"/></div></figure><p id="5b6d" class="pw-post-body-paragraph mk ml iu mm b mn nm jv mp mq nn jy ms mt no mv mw mx np mz na nb nq nd ne nf in bi translated">我们设置了模拟数据并绘制了散点图。</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="df5a" class="lf lg iu lb b gz lh li l lj lk">import numpy as np<br/>import matplotlib.pyplot as plt<br/>%matplotlib inline</span><span id="b5dd" class="lf lg iu lb b gz ll li l lj lk">time = np.arange(0,30,4)<br/>bacteria = np.array([20,150,453,920,1820,9765,15487,19450])</span><span id="b64c" class="lf lg iu lb b gz ll li l lj lk">plt.scatter(time,bacteria,label='Bacteria')<br/>plt.title("Time vs Bacteria")<br/>plt.xlabel('time')<br/>plt.ylabel('bacteria')<br/>plt.legend()<br/>plt.show()</span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj qj"><img src="../Images/6f9b657da734515a8fa2eac62b0113ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u6UWsPX_zQXz_HbWIa_1eA.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">时间对细菌图</p></figure><p id="ed64" class="pw-post-body-paragraph mk ml iu mm b mn nm jv mp mq nn jy ms mt no mv mw mx np mz na nb nq nd ne nf in bi translated">我们将使用<code class="fe nr ns nt lb b"><a class="ae kz" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.log.html" rel="noopener ugc nofollow" target="_blank">numpy.log</a></code>对细菌值进行自然记录。<code class="fe nr ns nt lb b">numpy.log</code>是自然对数。这应该显示一个线性趋势。我们需要用<code class="fe nr ns nt lb b">ln(bacteria)</code>修改标题和 y 标签。</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="579e" class="lf lg iu lb b gz lh li l lj lk">import numpy as np<br/>import matplotlib.pyplot as plt<br/>%matplotlib inline</span><span id="335f" class="lf lg iu lb b gz ll li l lj lk">time = np.arange(0,30,4)<br/>bacteria = np.array([20,150,453,920,1820,9765,15487,19450])</span><span id="bc59" class="lf lg iu lb b gz ll li l lj lk">plt.scatter(time,np.log(bacteria),label='Bacteria')<br/>plt.title("Time vs ln(Bacteria)")<br/>plt.xlabel('time')<br/>plt.ylabel('ln(bacteria)')<br/>plt.legend()<br/>plt.show()</span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj qk"><img src="../Images/12dd2b8f573048928f25f480143da924.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9iFiQquabSQKhry0p0KC1Q.png"/></div></div></figure><p id="fddc" class="pw-post-body-paragraph mk ml iu mm b mn nm jv mp mq nn jy ms mt no mv mw mx np mz na nb nq nd ne nf in bi translated">我们使用在二次和三次函数中使用的<code class="fe nr ns nt lb b">numpy.polyfit</code>。我们在<code class="fe nr ns nt lb b">numpy.polyfit()</code>中使用<code class="fe nr ns nt lb b">1</code>，这样它将返回一个线性回归。<code class="fe nr ns nt lb b">numpy.polyfit</code>返回等式的所有系数。</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="265f" class="lf lg iu lb b gz lh li l lj lk">import numpy as np<br/>import matplotlib.pyplot as plt<br/>%matplotlib inline</span><span id="6c2f" class="lf lg iu lb b gz ll li l lj lk">time = np.arange(0,30,4)<br/>bacteria = np.array([20,150,453,920,1820,9765,15487,19450])</span><span id="b8fa" class="lf lg iu lb b gz ll li l lj lk">p = np.polyfit(time, np.log(bacteria), 1)<br/>plt.plot(time, p[0] * time + p[1], 'g--', label='Semi-log graph')</span><span id="6dee" class="lf lg iu lb b gz ll li l lj lk">plt.scatter(time,np.log(bacteria),label='Bacteria')<br/>plt.title("Time vs Bacteria")<br/>plt.xlabel('time')<br/>plt.ylabel('bacteria')<br/>plt.legend()<br/>plt.show()</span><span id="fa58" class="lf lg iu lb b gz ll li l lj lk">print(f'The equation of regression line is y={p[0]:.3f} * x + {p[1]:.3f}')</span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ql"><img src="../Images/516dcab7d4dd5f5ce7c9c8cb880c9196.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vcptt_2ACRL_mCC075KapA.png"/></div></div></figure><h2 id="203b" class="lf lg iu bd lu nv nw dn ly nx ny dp mc mt nz oa me mx ob oc mg nb od oe mi of bi translated">双对数模型</h2><p id="9b29" class="pw-post-body-paragraph mk ml iu mm b mn mo jv mp mq mr jy ms mt mu mv mw mx my mz na nb nc nd ne nf in bi translated">双对数模型用于幂函数。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj qm"><img src="../Images/b40bc824a660e51d56475ff513295205.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/1*Rr99tu69Ko1n-5HV1UvJPQ.png"/></div></figure><p id="d186" class="pw-post-body-paragraph mk ml iu mm b mn nm jv mp mq nn jy ms mt no mv mw mx np mz na nb nq nd ne nf in bi translated">让我们设置数据并绘制散点图。</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="f027" class="lf lg iu lb b gz lh li l lj lk">import numpy as np<br/>import matplotlib.pyplot as plt<br/>%matplotlib inline</span><span id="cccc" class="lf lg iu lb b gz ll li l lj lk">x=np.array([2,30,70,100,150])<br/>y=np.array([4.24,16.4,25.1,30,36.7])</span><span id="0507" class="lf lg iu lb b gz ll li l lj lk">plt.scatter(x,y,label='Log-log')<br/>plt.title("Log-Log model")<br/>plt.xlabel('x')<br/>plt.ylabel('y')<br/>plt.legend()<br/>plt.show()</span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj og"><img src="../Images/c593ff8006e2c4d1201bf63f4fe7897f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pxd_sfZawv7eW2FEZvt8cA.png"/></div></div></figure><p id="1f06" class="pw-post-body-paragraph mk ml iu mm b mn nm jv mp mq nn jy ms mt no mv mw mx np mz na nb nq nd ne nf in bi translated">我们使用<code class="fe nr ns nt lb b"><a class="ae kz" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.log.html" rel="noopener ugc nofollow" target="_blank">numpy.log</a></code>获取 x 和 y 值的自然对数。我们需要将 x 和 y 标签修改为 ln(x)和 ln(y)。</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="177a" class="lf lg iu lb b gz lh li l lj lk">import numpy as np<br/>import matplotlib.pyplot as plt<br/>%matplotlib inline</span><span id="1e24" class="lf lg iu lb b gz ll li l lj lk">x=np.array([2,30,70,100,150])<br/>y=np.array([4.24,16.4,25.1,30,36.7])</span><span id="9366" class="lf lg iu lb b gz ll li l lj lk">p = np.polyfit(np.log(x), np.log(y), 1)<br/>plt.plot(np.log(x), p[0] * np.log(x) + p[1], 'r--', label='Regression line')</span><span id="dfe1" class="lf lg iu lb b gz ll li l lj lk">plt.scatter(np.log(x),np.log(y),label='log-log')<br/>plt.title("Log-log regression")<br/>plt.xlabel('ln(x)')<br/>plt.ylabel('ln(y)')<br/>plt.legend()<br/>plt.show()</span><span id="e78d" class="lf lg iu lb b gz ll li l lj lk">print(f'The equation of regression line is ln(y)={p[0]:.3f} * ln(x) + {p[1]:.3f}')</span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj qn"><img src="../Images/bfcebc98272842ce33feabeaf10fe4a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HylmZgZlGaLGKf5qqHzjdQ.png"/></div></div></figure></div><div class="ab cl lm ln hy lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="in io ip iq ir"><h1 id="48d3" class="lt lg iu bd lu lv lw lx ly lz ma mb mc ka md kb me kd mf ke mg kg mh kh mi mj bi translated">正弦模型</h1><p id="43ad" class="pw-post-body-paragraph mk ml iu mm b mn mo jv mp mq mr jy ms mt mu mv mw mx my mz na nb nc nd ne nf in bi translated">让我们试试正弦函数。我们设置数据并绘制散点图。既然要用<code class="fe nr ns nt lb b">scipy.optimize.curve_fit</code>，那我们也导入一下吧。我们在指数模型中使用了它。我们建立了数据并绘制了散点图。</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="4339" class="lf lg iu lb b gz lh li l lj lk">import numpy as np<br/>import matplotlib.pyplot as plt<br/>from scipy.optimize import curve_fit<br/>%matplotlib inline</span><span id="6f8f" class="lf lg iu lb b gz ll li l lj lk">year=np.arange(0,24,2)<br/>population=np.array([10.2,11.1,12,11.7,10.6,10,10.6,11.7,12,11.1,10.2,10.2])</span><span id="7419" class="lf lg iu lb b gz ll li l lj lk">plt.scatter(year,population,label='Population')<br/>plt.title("Year vs Population")<br/>plt.xlabel('Year')<br/>plt.ylabel('Population')<br/>plt.legend()<br/>plt.show()</span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj qo"><img src="../Images/da963e7af7dcedd9e4b7f4bb6c1ea219.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/format:webp/1*sLEBDMCfMUXGMEpY_2AnpQ.png"/></div></figure><p id="17d2" class="pw-post-body-paragraph mk ml iu mm b mn nm jv mp mq nn jy ms mt no mv mw mx np mz na nb nq nd ne nf in bi translated">我们定义一个叫做<code class="fe nr ns nt lb b">sinfunc</code>的函数。这需要参数<code class="fe nr ns nt lb b">x, a, b, c, d</code>。我们用<code class="fe nr ns nt lb b"><a class="ae kz" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.radians.html" rel="noopener ugc nofollow" target="_blank">numpy.radians</a></code>表示<code class="fe nr ns nt lb b">c</code>。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj qp"><img src="../Images/fe16f8a4ed3803b91384779d5fb703b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/format:webp/1*8K4IsR-dAl62dhLxQ4u_Sg.png"/></div></figure><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="fe47" class="lf lg iu lb b gz lh li l lj lk">import numpy as np<br/>import matplotlib.pyplot as plt<br/>from scipy.optimize import curve_fit<br/>%matplotlib inline</span><span id="c5e6" class="lf lg iu lb b gz ll li l lj lk">year=np.arange(0,24,2)<br/>population=np.array([10.2,11.1,12,11.7,10.6,10,10.6,11.7,12,11.1,10.2,10.2])</span><span id="65c2" class="lf lg iu lb b gz ll li l lj lk">def sinfunc(x, a, b, c, d):<br/>    return a * np.sin(b * (x - np.radians(c)))+d</span><span id="9c73" class="lf lg iu lb b gz ll li l lj lk">popt, pcov = curve_fit(sinfunc, year, population, p0=[1,0.4,1,5])<br/>x_data = np.linspace(0, 25, num=100)</span><span id="9918" class="lf lg iu lb b gz ll li l lj lk">plt.scatter(year,population,label='Population')<br/>plt.plot(x_data, sinfunc(x_data, *popt), 'r-',label='Fitted function')<br/>plt.title("Year vs Population")<br/>plt.xlabel('Year')<br/>plt.ylabel('Population')<br/>plt.legend()<br/>plt.show()</span><span id="6f39" class="lf lg iu lb b gz ll li l lj lk">a, b, c, d = popt</span><span id="c49f" class="lf lg iu lb b gz ll li l lj lk">print(f'The equation of regression line is y={a:.3f} * sin({b:.3f}(x-{np.radians(c):.3f}))+{d:.3f}')</span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj qq"><img src="../Images/47f75a59a1d989eca1510698f915bbda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IJ5CTKKjB3AijcOn5TzugQ.png"/></div></div></figure><h2 id="3ef1" class="lf lg iu bd lu nv nw dn ly nx ny dp mc mt nz oa me mx ob oc mg nb od oe mi of bi translated">实践</h2><p id="b7e8" class="pw-post-body-paragraph mk ml iu mm b mn mo jv mp mq mr jy ms mt mu mv mw mx my mz na nb nc nd ne nf in bi translated">使用<a class="ae kz" href="https://niwa.co.nz/education-and-training/schools/resources/climate/modelling" rel="noopener ugc nofollow" target="_blank">下面的表格</a>，画一个散点图并找到一个余弦回归函数。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj qr"><img src="../Images/be8fea0403d28858d2410abc32fb9421.png" data-original-src="https://miro.medium.com/v2/resize:fit:1194/format:webp/1*_8OQ-vYcqrH22khuqYHJoA.png"/></div></figure><h2 id="01d3" class="lf lg iu bd lu nv nw dn ly nx ny dp mc mt nz oa me mx ob oc mg nb od oe mi of bi translated">回答</h2><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj qs"><img src="../Images/5bd83791c791b2fe48992bbcded86228.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/1*G_4IWoKnyb0nMd4VDqEZMw.png"/></div></figure><p id="febb" class="pw-post-body-paragraph mk ml iu mm b mn nm jv mp mq nn jy ms mt no mv mw mx np mz na nb nq nd ne nf in bi translated">你可能有不同的系数。我用过</p></div><div class="ab cl lm ln hy lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="in io ip iq ir"><h1 id="8108" class="lt lg iu bd lu lv lw lx ly lz ma mb mc ka md kb me kd mf ke mg kg mh kh mi mj bi translated">逻辑模型</h1><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj qt"><img src="../Images/bfef875c251a7c7fd6fcfbf498bf36ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1130/format:webp/1*za66ufNp4_AYq1X0eNth-Q.png"/></div></figure><p id="b57a" class="pw-post-body-paragraph mk ml iu mm b mn nm jv mp mq nn jy ms mt no mv mw mx np mz na nb nq nd ne nf in bi translated">我们收集数据并绘制散点图。我们使用<code class="fe nr ns nt lb b">plt.xlim</code>和<code class="fe nr ns nt lb b">plt.ylim</code>设置域从-10 到 10，范围从 0 到 250。我们将使用<code class="fe nr ns nt lb b">scipy.optimize.curve_fit</code>进行逻辑回归。</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="62cb" class="lf lg iu lb b gz lh li l lj lk">import numpy as np<br/>import matplotlib.pyplot as plt<br/>from scipy.optimize import curve_fit<br/>%matplotlib inline</span><span id="a63a" class="lf lg iu lb b gz ll li l lj lk">x=np.arange(0,10)<br/>y=np.array([52,133,203,230,237,239.5,239.8,239.9,240,240])</span><span id="6a8c" class="lf lg iu lb b gz ll li l lj lk">plt.scatter(x, y, label='Regression line')<br/>plt.title("Logistic regression")<br/>plt.xlabel('x')<br/>plt.ylabel('y')<br/>plt.xlim(-10,10)<br/>plt.ylim(0,250)<br/>plt.legend()<br/>plt.show()</span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj qu"><img src="../Images/2470d607f4ddbd37187ef417edab2cae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ofFZhheRbhF4NXS1m0M6iw.png"/></div></div></figure><p id="f8ed" class="pw-post-body-paragraph mk ml iu mm b mn nm jv mp mq nn jy ms mt no mv mw mx np mz na nb nq nd ne nf in bi translated">我们使用<code class="fe nr ns nt lb b">logifunc</code>来定义我们的逻辑功能。我们用<code class="fe nr ns nt lb b">curve_fit</code>找到<code class="fe nr ns nt lb b">popt</code>中的函数参数。对于回归线，我们为函数设置一个新的域，<code class="fe nr ns nt lb b">x_data</code>从-10 到 10。我们使用<code class="fe nr ns nt lb b">plt.plot</code>绘制这条线。</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="a31b" class="lf lg iu lb b gz lh li l lj lk">import numpy as np<br/>import matplotlib.pyplot as plt<br/>from scipy.optimize import curve_fit<br/>%matplotlib inline</span><span id="fc99" class="lf lg iu lb b gz ll li l lj lk">x=np.arange(0,10.0)<br/>y=np.array([52,133,203,230,237,239.5,239.8,239.9,240,240])</span><span id="fc45" class="lf lg iu lb b gz ll li l lj lk">def logifunc(x,L,c,k):<br/>    return L/ (1 + c*np.exp(-k*x))</span><span id="327a" class="lf lg iu lb b gz ll li l lj lk">popt, pcov = curve_fit(logifunc, x, y, p0=[200,1,1])<br/>x_data = np.linspace(-10, 10, num=100)</span><span id="807a" class="lf lg iu lb b gz ll li l lj lk">plt.scatter(x,y,label='Logistic function')<br/>plt.plot(x_data, logifunc(x_data, *popt), 'r-',label='Fitted function')<br/>plt.title("Logistic")<br/>plt.xlabel('x')<br/>plt.ylabel('y')<br/>plt.xlim(-10,10)<br/>plt.ylim(0,250)<br/>plt.legend()<br/>plt.show()</span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj qv"><img src="../Images/07729277aabb9ef3898503ce1c4cffcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K34NyjqLsvY3DhuiTpfatQ.png"/></div></div></figure><h2 id="ea5b" class="lf lg iu bd lu nv nw dn ly nx ny dp mc mt nz oa me mx ob oc mg nb od oe mi of bi translated">当 y 数据点为负时</h2><p id="f1b6" class="pw-post-body-paragraph mk ml iu mm b mn mo jv mp mq mr jy ms mt mu mv mw mx my mz na nb nc nd ne nf in bi translated">有时，您的数据在 y 坐标中可能有负值。</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="2ccc" class="lf lg iu lb b gz lh li l lj lk">import pandas as pd</span><span id="0052" class="lf lg iu lb b gz ll li l lj lk">df = pd.read_csv('<a class="ae kz" href="http://bit.ly/2tUIZjK'" rel="noopener ugc nofollow" target="_blank">http://bit.ly/2tUIZjK'</a>)</span><span id="023e" class="lf lg iu lb b gz ll li l lj lk">df.head()</span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj qw"><img src="../Images/430253f087d91224a88ab61d6ec588de.png" data-original-src="https://miro.medium.com/v2/resize:fit:582/format:webp/1*wVodYcYtt8Q8ybIMJCYCSA.png"/></div></figure><p id="5e8f" class="pw-post-body-paragraph mk ml iu mm b mn nm jv mp mq nn jy ms mt no mv mw mx np mz na nb nq nd ne nf in bi translated">数据的最小值必须为零。理想情况下，乙状结肠中点也为零。但是上面的数据集两者都不满足。使用等式(1–2)，并添加<code class="fe nr ns nt lb b">offset</code>值适用于该数据集。</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="2619" class="lf lg iu lb b gz lh li l lj lk">x=df.T.iloc[0]<br/>y=df.T.iloc[1]</span><span id="b896" class="lf lg iu lb b gz ll li l lj lk">def logifunc(x,L,x0,k,off):<br/>    return L / (1 + np.exp(-k*(x-x0)))+off</span><span id="9add" class="lf lg iu lb b gz ll li l lj lk">plt.scatter(x,y,label='Logistic function')</span><span id="716d" class="lf lg iu lb b gz ll li l lj lk">popt, pcov = curve_fit(logifunc, x, y, p0=[50,185,0.1,-222])<br/>plt.scatter(x,y,label='Logistic function')</span><span id="20c9" class="lf lg iu lb b gz ll li l lj lk">x_data = np.linspace(170,205,num=100)<br/>plt.plot(x_data, logifunc(x_data, *popt), 'r-',label='Fitted function')<br/>plt.legend()</span><span id="61ea" class="lf lg iu lb b gz ll li l lj lk">plt.show()<br/>print(popt)</span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj qx"><img src="../Images/757bc8468bf6800f4fa7bf7d959d6427.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*JzBOR1WF6npWckBn-IkQAw.png"/></div></figure></div><div class="ab cl lm ln hy lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="in io ip iq ir"><h1 id="9ef6" class="lt lg iu bd lu lv lw lx ly lz ma mb mc ka md kb me kd mf ke mg kg mh kh mi mj bi translated">结论</h1><p id="2eac" class="pw-post-body-paragraph mk ml iu mm b mn mo jv mp mq mr jy ms mt mu mv mw mx my mz na nb nc nd ne nf in bi translated"><code class="fe nr ns nt lb b">scipy.optimize.curve_fit</code>对许多功能都有用。唯一的问题是在<code class="fe nr ns nt lb b">p0</code>中找到好的初始值。有时不同的<code class="fe nr ns nt lb b">p0</code>值会返回不同的<code class="fe nr ns nt lb b">popt</code>。可以试试<a class="ae kz" href="https://lmfit.github.io/lmfit-py/" rel="noopener ugc nofollow" target="_blank"> LMFIT </a>。</p></div><div class="ab cl lm ln hy lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="in io ip iq ir"><p id="04c3" class="pw-post-body-paragraph mk ml iu mm b mn nm jv mp mq nn jy ms mt no mv mw mx np mz na nb nq nd ne nf in bi translated"><strong class="mm iv">通过</strong> <a class="ae kz" href="https://blog.codewithshin.com/membership" rel="noopener ugc nofollow" target="_blank"> <strong class="mm iv">成为</strong> </a> <strong class="mm iv">的会员，可以完全访问媒体上的每一个故事。</strong></p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj qy"><img src="../Images/0be3ee559fee844cb75615290e4a8b29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*DjTM9iFtVc2wlcWcOms7VQ.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://blog.codewithshin.com/subscribe" rel="noopener ugc nofollow" target="_blank">https://blog.codewithshin.com/subscribe</a></p></figure></div><div class="ab cl lm ln hy lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="in io ip iq ir"><h1 id="4e0f" class="lt lg iu bd lu lv lw lx ly lz ma mb mc ka md kb me kd mf ke mg kg mh kh mi mj bi translated">参考</h1><ul class=""><li id="5d3e" class="qz ra iu mm b mn mo mq mr mt rb mx rc nb rd nf re rf rg rh bi translated"><a class="ae kz" href="https://realpython.com/linear-regression-in-python/" rel="noopener ugc nofollow" target="_blank">https://realpython.com/linear-regression-in-python/</a></li><li id="a09f" class="qz ra iu mm b mn ri mq rj mt rk mx rl nb rm nf re rf rg rh bi translated"><a class="ae kz" href="https://stackoverflow.com/questions/41925157/logisticregression-unknown-label-type-continuous-using-sklearn-in-python" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/41925157/logisticregression-unknown-label-type-continuous-using-sk learn-in-python</a></li></ul></div></div>    
</body>
</html>