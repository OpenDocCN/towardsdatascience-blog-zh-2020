<html>
<head>
<title>pre-commit hooks you must know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你必须知道的预提交钩子</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/pre-commit-hooks-you-must-know-ff247f5feb7e?source=collection_archive---------2-----------------------#2020-09-04">https://towardsdatascience.com/pre-commit-hooks-you-must-know-ff247f5feb7e?source=collection_archive---------2-----------------------#2020-09-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="51c5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在 5 分钟内提高您的生产力和代码质量</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/417adef1bf8508390dcb1f38c10c40b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E7GkL0hnZgu4h8IFEVP8fw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片作者:马丁·托马斯</p></figure><p id="4143" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">预提交钩子是版本控制系统 git 的一种机制。他们让你在提交之前执行代码。令人困惑的是，还有一个叫做<code class="fe lu lv lw lx b">pre-commit</code>的 Python 包，它允许你用一种更简单的接口创建和使用预提交钩子。Python 包有一个插件系统来自动创建 git 预提交钩子。它不仅适用于 Python 项目，也适用于任何项目。</p><p id="b1fb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">看完这篇文章，你就知道我最喜欢的专业软件开发插件了。我们开始吧！</p><h1 id="571c" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">提交前基础知识</h1><p id="cfd8" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">通过以下方式安装预提交</p><pre class="kj kk kl km gt mv lx mw mx aw my bi"><span id="4870" class="mz lz it lx b gy na nb l nc nd">pip install pre-commit</span></pre><p id="ad38" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在您的项目中创建一个<code class="fe lu lv lw lx b">.pre-commit-config.yaml</code>文件。这个文件包含每次提交前要运行的预提交钩子。看起来是这样的:</p><pre class="kj kk kl km gt mv lx mw mx aw my bi"><span id="ea39" class="mz lz it lx b gy na nb l nc nd">repos:<br/>-   repo: <a class="ae ne" href="https://github.com/pre-commit/pre-commit-hooks" rel="noopener ugc nofollow" target="_blank">https://github.com/pre-commit/pre-commit-hooks</a><br/>    rev: v3.2.0<br/>    hooks:<br/>    -   id: trailing-whitespace<br/>    -   id: mixed-line-ending</span><span id="1ff5" class="mz lz it lx b gy nf nb l nc nd">-   repo: <a class="ae ne" href="https://github.com/psf/black" rel="noopener ugc nofollow" target="_blank">https://github.com/psf/black</a><br/>    rev: 20.8b1<br/>    hooks:<br/>    -   id: black</span></pre><p id="c77e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">pre-commit</code>将在这两个带有指定 git 标签的存储库中查找名为<code class="fe lu lv lw lx b">.pre-commit-hooks.yaml</code>的文件。在这个文件中可以任意定义许多钩子。它们都需要一个<code class="fe lu lv lw lx b">id</code>，这样你就可以选择你想用的。上面的 git-commit 配置将使用 3 个钩子。</p><p id="70f0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，您需要运行<code class="fe lu lv lw lx b">pre-commit install</code>来告诉预提交总是为这个存储库运行。</p><p id="9edf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我使用它之前，我担心会失控。我想确切地知道我提交了哪些更改。如果它改变了什么，将中止提交。所以你还是可以看一下代码，检查一下改动是否合理。您也可以选择不运行预提交，方法是</p><pre class="kj kk kl km gt mv lx mw mx aw my bi"><span id="0b7d" class="mz lz it lx b gy na nb l nc nd">git commit --no-verify</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/e76fa0d086b7227482e8ed9688660428.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZCYzFdbHeOYuBvmIcVLnMA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由 CC-BY-3.0 下的<a class="ae ne" href="http://geek-and-poke.com/geekandpoke/2010/11/1/how-to-make-a-good-code-review.html" rel="noopener ugc nofollow" target="_blank"> geek-and-poke </a>提供</p></figure><h1 id="5a93" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">文件格式</h1><p id="a00f" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">以类似的方式格式化文件通过提高一致性来帮助可读性，并保持 git 提交的整洁。例如，您通常不想要尾随空格。您希望文本文件恰好以一个换行符结尾，这样一些 Linux 命令行工具就能正常工作。您希望 Linux ( <code class="fe lu lv lw lx b">\n</code>)、Mac ( <code class="fe lu lv lw lx b">\r</code> — <a class="ae ne" href="https://superuser.com/questions/439440/did-mac-os-lion-switch-to-using-line-feeds-lf-n-for-line-breaks-instead-of#:~:text=Nowadays%20Mac%20OS%20uses%20Unix%20style%20(LF)%20line%20breaks.&amp;text=Command%2Dline%20tools%20in%20Mac,Mac%2Dstyle%E2%80%9D%20line%20endings." rel="noopener ugc nofollow" target="_blank"> Mac 之间的换行符一致，将</a>改为<code class="fe lu lv lw lx b">\n</code>🎉)和 windows ( <code class="fe lu lv lw lx b">\r\n</code>)。我的配置是</p><pre class="kj kk kl km gt mv lx mw mx aw my bi"><span id="cd03" class="mz lz it lx b gy na nb l nc nd"># pre-commit run --all-files<br/>repos:<br/>-   repo: <a class="ae ne" href="https://github.com/pre-commit/pre-commit-hooks" rel="noopener ugc nofollow" target="_blank">https://github.com/pre-commit/pre-commit-hooks</a><br/>    rev: v3.2.0<br/>    hooks:<br/>    -   id: check-byte-order-marker  # Forbid UTF-8 byte-order markers<br/>    # Check for files with names that would conflict on a case-insensitive<br/>    # filesystem like MacOS HFS+ or Windows FAT.<br/>    -   id: check-case-conflict<br/>    -   id: check-json<br/>    -   id: check-yaml<br/>    -   id: end-of-file-fixer<br/>    -   id: trailing-whitespace<br/>    -   id: mixed-line-ending</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/41b70b477928d1f2e691bc68bd819112.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/1*SE_FC8cspNAz_pFojUEsTg.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由马丁·托马斯通过 imgflip.com<a class="ae ne" href="https://imgflip.com/i/4dqpwf" rel="noopener ugc nofollow" target="_blank">创建</a></p></figure><h1 id="7f66" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">代码风格</h1><p id="4878" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">我们可以用很多不同的方式编写代码。它们中的许多在运行时几乎没有区别，但在可读性方面有所不同。</p><h2 id="d206" class="mz lz it bd ma ni nj dn me nk nl dp mi lh nm nn mk ll no np mm lp nq nr mo ns bi translated">代码自动格式器</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/3d207b5c243a512b9e670c9a1ec2fce7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-WosNzXumx9wbyGbgpcIlA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">当你的代码看起来丑陋的时候，不要浪费时间学习风格指南和手工应用它。运行代码格式化程序。图片由兰道尔·门罗(<a class="ae ne" href="https://xkcd.com/1513/" rel="noopener ugc nofollow" target="_blank"> XKCD </a>)拍摄</p></figure><p id="8dc6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">自动代码格式化与文件格式化具有相同的优点。此外，它还能防止无意义的讨论。因此，它让你和你的团队专注于重要和复杂的部分。</p><p id="61b9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我喜欢 Pythons 自动格式化程序 black，在关于静态代码分析的文章中已经提到过:</p><pre class="kj kk kl km gt mv lx mw mx aw my bi"><span id="51d3" class="mz lz it lx b gy na nb l nc nd">-   repo: <a class="ae ne" href="https://github.com/psf/black" rel="noopener ugc nofollow" target="_blank">https://github.com/psf/black</a><br/>    rev: 20.8b1<br/>    hooks:<br/>    -   id: black<br/>-   repo: <a class="ae ne" href="https://github.com/asottile/blacken-docs" rel="noopener ugc nofollow" target="_blank">https://github.com/asottile/blacken-docs</a><br/>    rev: v1.8.0<br/>    hooks:<br/>    -   id: blacken-docs<br/>        additional_dependencies: [black==20.8b1]</span></pre><p id="45ec" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第一个是 black 本身，第二个是一个将黑色格式应用于 docstrings 中的代码字符串的项目。</p><p id="a8b1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，我希望我的导入被排序:</p><pre class="kj kk kl km gt mv lx mw mx aw my bi"><span id="0361" class="mz lz it lx b gy na nb l nc nd">-   repo: <a class="ae ne" href="https://github.com/asottile/seed-isort-config" rel="noopener ugc nofollow" target="_blank">https://github.com/asottile/seed-isort-config</a><br/>    rev: v2.2.0<br/>    hooks:<br/>    -   id: seed-isort-config<br/>-   repo: <a class="ae ne" href="https://github.com/pre-commit/mirrors-isort" rel="noopener ugc nofollow" target="_blank">https://github.com/pre-commit/mirrors-isort</a><br/>    rev: v5.4.2<br/>    hooks:<br/>    -   id: isort</span></pre><p id="48f1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">许多语言都有带预提交挂钩的自动套用格式器:</p><ul class=""><li id="ea42" class="nu nv it la b lb lc le lf lh nw ll nx lp ny lt nz oa ob oc bi translated"><a class="ae ne" href="https://prettier.io/docs/en/precommit.html#option-3-pre-commithttpsgithubcompre-commitpre-commit" rel="noopener ugc nofollow" target="_blank">更漂亮的</a> : HTML、CSS、JavaScript、GraphQL 等等。</li><li id="e75c" class="nu nv it la b lb od le oe lh of ll og lp oh lt nz oa ob oc bi translated"><a class="ae ne" href="https://github.com/andrewseidl/githook-clang-format" rel="noopener ugc nofollow" target="_blank"> Clang-format </a> : C，C++，Java，JavaScript，Objective-C，Protobuf，C#</li><li id="dd04" class="nu nv it la b lb od le oe lh of ll og lp oh lt nz oa ob oc bi translated"><a class="ae ne" href="https://github.com/doublify/pre-commit-rust" rel="noopener ugc nofollow" target="_blank">生锈:生锈</a></li></ul><h2 id="879a" class="mz lz it bd ma ni nj dn me nk nl dp mi lh nm nn mk ll no np mm lp nq nr mo ns bi translated">现代 Python</h2><p id="a5c2" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated"><a class="ae ne" href="https://github.com/asottile/pyupgrade" rel="noopener ugc nofollow" target="_blank"> pyupgrade </a>运行您的 Python 代码，并自动将旧式语法更改为新式语法。请看一些例子:</p><pre class="kj kk kl km gt mv lx mw mx aw my bi"><span id="b8cf" class="mz lz it lx b gy na nb l nc nd">dict([(a, b) for a, b in y])  # -&gt; {a: b for a, b in y}<br/>class C(object): pass         # -&gt; class C: pass<br/>from mock import patch        # -&gt; from unittest.mock import patch</span></pre><p id="9c7a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你想要吗？给你:</p><pre class="kj kk kl km gt mv lx mw mx aw my bi"><span id="8392" class="mz lz it lx b gy na nb l nc nd">-   repo: <a class="ae ne" href="https://github.com/asottile/pyupgrade" rel="noopener ugc nofollow" target="_blank">https://github.com/asottile/pyupgrade</a><br/>    rev: v2.7.2<br/>    hooks:<br/>    -   id: pyupgrade<br/>        args: [--py36-plus]</span></pre><h1 id="ee6e" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">测试您的代码</h1><p id="c8ce" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">我考虑过通过预提交自动运行单元测试。我决定不这样做，因为这可能需要一段时间。但是，有一些快速测试可以每次自动运行:</p><pre class="kj kk kl km gt mv lx mw mx aw my bi"><span id="303f" class="mz lz it lx b gy na nb l nc nd">-   repo: <a class="ae ne" href="https://github.com/pre-commit/pre-commit-hooks" rel="noopener ugc nofollow" target="_blank">https://github.com/pre-commit/pre-commit-hooks</a><br/>    rev: v3.2.0<br/>    hooks:<br/>    -   id: check-ast  # Is it valid Python?<br/>    # Check for debugger imports and py37+ breakpoint() calls<br/>    # in python source.<br/>    -   id: debug-statements</span><span id="50d1" class="mz lz it lx b gy nf nb l nc nd">-   repo: <a class="ae ne" href="https://github.com/pre-commit/mirrors-mypy" rel="noopener ugc nofollow" target="_blank">https://github.com/pre-commit/mirrors-mypy</a><br/>    rev: v0.782<br/>    hooks:<br/>    -   id: mypy<br/>        args: [--ignore-missing-imports]</span><span id="18e5" class="mz lz it lx b gy nf nb l nc nd">-   repo: <a class="ae ne" href="https://gitlab.com/pycqa/flake8" rel="noopener ugc nofollow" target="_blank">https://gitlab.com/pycqa/flake8</a><br/>    rev: '3.8.3'<br/>    hooks:<br/>    -   id: flake8</span></pre><h1 id="9072" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">安全性</h1><p id="a9e4" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">签入凭证是一个非常常见的错误。以下是防止这种情况的方法:</p><pre class="kj kk kl km gt mv lx mw mx aw my bi"><span id="14d9" class="mz lz it lx b gy na nb l nc nd">-   repo: <a class="ae ne" href="https://github.com/pre-commit/pre-commit-hooks" rel="noopener ugc nofollow" target="_blank">https://github.com/pre-commit/pre-commit-hooks</a><br/>    rev: v3.2.0<br/>    hooks:<br/>    -   id: detect-aws-credentials<br/>    -   id: detect-private-key</span></pre><h1 id="d2ac" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">杂项提交前挂钩</h1><p id="a593" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">有些挂钩不属于上述类别，但仍然有用。例如，这可以防止提交大文件:</p><pre class="kj kk kl km gt mv lx mw mx aw my bi"><span id="530f" class="mz lz it lx b gy na nb l nc nd">-   repo: <a class="ae ne" href="https://github.com/pre-commit/pre-commit-hooks" rel="noopener ugc nofollow" target="_blank">https://github.com/pre-commit/pre-commit-hooks</a><br/>    rev: v3.2.0<br/>    hooks:<br/>    -   id: check-added-large-files</span></pre><h1 id="8814" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">在团队中工作</h1><p id="0d23" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">预提交挂钩安装在本地，因此每个开发人员都可以自己决定是否需要预提交挂钩以及需要哪些挂钩。但是，我认为提供一个<code class="fe lu lv lw lx b">.pre-commit-config.yaml</code>有你推荐执行的插件是有帮助的。</p><h1 id="e140" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">所有的钩子！</h1><p id="2750" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">如果您正在寻找一个现成的完整的<code class="fe lu lv lw lx b">.pre-commit-config.yaml</code>,这里就是:</p><pre class="kj kk kl km gt mv lx mw mx aw my bi"><span id="87ac" class="mz lz it lx b gy na nb l nc nd"># Apply to all files without commiting:<br/>#   pre-commit run --all-files<br/># Update this file:<br/>#   pre-commit autoupdate<br/>repos:<br/>-   repo: <a class="ae ne" href="https://github.com/pre-commit/pre-commit-hooks" rel="noopener ugc nofollow" target="_blank">https://github.com/pre-commit/pre-commit-hooks</a><br/>    rev: v3.2.0<br/>    hooks:<br/>    -   id: check-ast<br/>    -   id: check-byte-order-marker<br/>    -   id: check-case-conflict<br/>    -   id: check-docstring-first<br/>    -   id: check-executables-have-shebangs<br/>    -   id: check-json<br/>    -   id: check-yaml<br/>    -   id: debug-statements<br/>    -   id: detect-aws-credentials<br/>    -   id: detect-private-key<br/>    -   id: end-of-file-fixer<br/>    -   id: trailing-whitespace<br/>    -   id: mixed-line-ending<br/>-   repo: <a class="ae ne" href="https://github.com/pre-commit/mirrors-mypy" rel="noopener ugc nofollow" target="_blank">https://github.com/pre-commit/mirrors-mypy</a><br/>    rev: v0.782<br/>    hooks:<br/>    -   id: mypy<br/>        args: [--ignore-missing-imports]<br/>-   repo: <a class="ae ne" href="https://github.com/asottile/seed-isort-config" rel="noopener ugc nofollow" target="_blank">https://github.com/asottile/seed-isort-config</a><br/>    rev: v2.2.0<br/>    hooks:<br/>    -   id: seed-isort-config<br/>-   repo: <a class="ae ne" href="https://github.com/pre-commit/mirrors-isort" rel="noopener ugc nofollow" target="_blank">https://github.com/pre-commit/mirrors-isort</a><br/>    rev: v5.4.2<br/>    hooks:<br/>    -   id: isort<br/>-   repo: <a class="ae ne" href="https://github.com/psf/black" rel="noopener ugc nofollow" target="_blank">https://github.com/psf/black</a><br/>    rev: 20.8b1<br/>    hooks:<br/>    -   id: black<br/>-   repo: <a class="ae ne" href="https://github.com/asottile/pyupgrade" rel="noopener ugc nofollow" target="_blank">https://github.com/asottile/pyupgrade</a><br/>    rev: v2.7.2<br/>    hooks:<br/>    -   id: pyupgrade<br/>        args: [--py36-plus]<br/>-   repo: <a class="ae ne" href="https://github.com/asottile/blacken-docs" rel="noopener ugc nofollow" target="_blank">https://github.com/asottile/blacken-docs</a><br/>    rev: v1.8.0<br/>    hooks:<br/>    -   id: blacken-docs<br/>        additional_dependencies: [black==20.8b1]</span></pre><h1 id="d697" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">摘要</h1><p id="c430" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">我喜欢预提交，因为它非常适合我的工作流程。我只是像往常一样提交，预提交会做我有时会忘记的所有检查。它加快了开发速度，因为 CI/CD 管道比在本地执行同样的步骤要慢得多。特别是对林挺来说，快速运行代码而不是提交，等待 CI/CD 管道，找到错误，在本地修复错误，推送，然后再次等待 CI/CD 管道，可以节省大量时间。</p><p id="3030" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果有你喜欢的其他预提交挂钩，请通过评论或电子邮件(info@martin-thoma.de)告诉我！</p></div></div>    
</body>
</html>