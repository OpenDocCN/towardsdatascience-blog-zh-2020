<html>
<head>
<title>Free Live Coronavirus Cases API With LiveData and MVVM</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">与LiveData和MVVM一起提供免费的冠状病毒案例API</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/free-live-coronavirus-cases-api-with-livedata-and-mvvm-39a78f8351fb?source=collection_archive---------31-----------------------#2020-04-13">https://towardsdatascience.com/free-live-coronavirus-cases-api-with-livedata-and-mvvm-39a78f8351fb?source=collection_archive---------31-----------------------#2020-04-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5452" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我们将通过LiveData &amp; MVVM实现实时冠状病毒病例应用编程接口</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/69a2463bdd99b07f1032f13d094216e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K5ajwSu4mgcDrR8mmR_adQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@fanhungry?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Dương Trần Quốc </a>在<a class="ae ky" href="https://unsplash.com/s/photos/camera-man?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><h2 id="a960" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">我们将建造什么？</h2><p id="107e" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">我们将构建一个Android应用程序，它将在RecyclerView中显示冠状病毒的真实病例。我们将遵循MVVM架构模式，用Kotlin实现LiveData。</p><p id="4b40" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我们最终的应用程序将是这样的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/21a00128e4d68aa8f648e7705cf45b7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1064/format:webp/1*AOyc-O-WUlJLHTOh22k2ig.png"/></div></figure><h2 id="04b9" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">我们会学到什么？</h2><ul class=""><li id="8893" class="mu mv it lx b ly lz mb mc li mw lm mx lq my mn mz na nb nc bi translated">MVVM建筑模式</li><li id="a1b2" class="mu mv it lx b ly nd mb ne li nf lm ng lq nh mn mz na nb nc bi translated">LiveData</li><li id="e594" class="mu mv it lx b ly nd mb ne li nf lm ng lq nh mn mz na nb nc bi translated">使用改进的API</li></ul><h2 id="b1fe" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">为什么是MVVM？</h2><p id="8879" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">MVVM是一种架构设计模式，它帮助我们实现以下目标。</p><ul class=""><li id="0cf6" class="mu mv it lx b ly mo mb mp li ni lm nj lq nk mn mz na nb nc bi translated">MVVM让代码更容易理解</li><li id="a5d1" class="mu mv it lx b ly nd mb ne li nf lm ng lq nh mn mz na nb nc bi translated">对于其他开发人员来说，代码变得更容易维护</li><li id="575b" class="mu mv it lx b ly nd mb ne li nf lm ng lq nh mn mz na nb nc bi translated">这也使得项目松散耦合，意味着减少了组件(如类、活动和片段)之间的依赖性。</li><li id="234d" class="mu mv it lx b ly nd mb ne li nf lm ng lq nh mn mz na nb nc bi translated">代码测试变得容易多了。</li></ul><h2 id="94ae" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">MVVM建筑模式</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/d8fa8ac1dc73888ddaaa30af274205e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w1lH5qriiLa2cQPtiz4gfA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">MVVM建筑</p></figure><p id="580d" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">上图解释了MVVM架构模式。在这个图中，在体系结构的顶部存在我们的视图，用户通过这些视图与数据进行交互。</p><p id="1251" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">为了显示数据，我们使用<strong class="lx iu"> ViewModel </strong>，因此我们的视图依赖于ViewModel来获取数据。使用<strong class="lx iu"> ViewModel </strong>的好处是，如果活动被破坏，它不会更新数据。这意味着它减少了应用崩溃的机会。</p><p id="e4f2" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">接下来，在<strong class="lx iu">视图模型</strong>下面存在<strong class="lx iu">存储库</strong>，它进一步依赖于各种数据源。存储库可以从任何来源获取数据，它可以是远程存储库或本地存储库，这完全取决于您的逻辑。</p><h2 id="44f5" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">LiveData</h2><p id="8c4f" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">当谈到可观察或观察者时，这意味着我们在谈论两种不同的东西，一种你可以认为是电视，另一种你可以认为是正在观看电视的人。所以电视是可观察的，因为它被观察，而观看它的人是一个观察者。如果我们把这个概念应用到我们的数据和视图上，数据被我们的视图观察，所以数据是可观察的，而视图是观察者。现在我希望你能理解这个概念。</p><p id="0cee" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">现在是时候来点技术了，不是吗？</p><p id="7126" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><code class="fe nm nn no np b"><a class="ae ky" href="https://developer.android.com/reference/androidx/lifecycle/LiveData" rel="noopener ugc nofollow" target="_blank">LiveData</a></code>是一个可观察的数据持有者类，这意味着扩展了<code class="fe nm nn no np b">LiveData</code>类的类负责通知处于活动状态的视图。一旦数据发生任何变化，我们的视图就会看到，即我们的视图会得到通知。</p><p id="ea7e" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">让我们考虑一个场景来更好地理解这个概念。</p><h2 id="b08b" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">例如:-</h2><p id="2539" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">让我们假设，你在任何应用程序的主屏幕上，它向你显示项目列表，但只要你单击任何项目，就会发生一些处理，这意味着后台服务正在获取数据，同时，你关闭应用程序。该应用程序对您不可见，但后台服务很快停止(因为您关闭了该应用程序)，并且它仍在尝试设置视图上的数据，现在由于数据未被提取，因此您的应用程序将因<code class="fe nm nn no np b">NullPointerException</code>而在后台崩溃。那就是没有使用<code class="fe nm nn no np b">LiveData</code>的问题。</p><p id="c5f1" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">现在，我们可以从这个例子中了解到，我们获取数据的过程并不知道我们的活动、片段和服务的生命周期，这就是我们的应用程序崩溃的原因。</p><p id="6b97" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">市场上唯一可用的解决方案是解决此类问题的<code class="fe nm nn no np b">LiveData</code>。那我们还在等什么？让我们直接进入编码部分。</p><h2 id="b4a0" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">项目结构</h2><p id="6b0d" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">在您的项目中创建以下包</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/b791921f7cc307854140c2f17f61f4f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/format:webp/1*bWhqLwz5pjJmpSs9oHvvEQ.png"/></div></figure><h2 id="747e" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">网络包:</h2><p id="a97f" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">这个包包含另外两个包，即data和repos，data包有两个类来接收从RemoteRepository类获取的数据。</p><h2 id="f788" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">用户界面包:</h2><p id="5a41" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">这个包还有另外两个包，它们是适配器和接口，适配器包有一个<code class="fe nm nn no np b">ModelListAdapter</code>类，这个类创建了一个<strong class="lx iu">冠状病毒</strong>的详细列表。</p><p id="d53e" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">接口包包含一个返回改造对象的接口。在这个接口中，我定义了<strong class="lx iu"> BASEURL </strong>和它的<strong class="lx iu">端点</strong>。</p><p id="57b6" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">接下来的两类ui包是<code class="fe nm nn no np b">MainActivity</code>和<code class="fe nm nn no np b">MyViewModel</code>。我们的<code class="fe nm nn no np b">MainActivity</code>类包含了<code class="fe nm nn no np b">RecyclerView</code>和<code class="fe nm nn no np b">ProgressBar</code>。MyViewModel类为我们的活动提供数据。</p><p id="a088" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">说够了，让我们现在开始编码…</p><p id="d369" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">这个项目我准备用<strong class="lx iu">免费的</strong>冠状病毒api。</p><p id="25d9" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><strong class="lx iu"> API网址:</strong>【https://api.covid19api.com/summary T21】</p><p id="01b8" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我将只使用国家数组。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/44e0f9eb6e50650b77ac53451c3f5b4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*04P8NXPUu96Pg9ZYNZohyg.png"/></div></div></figure><h2 id="a11a" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">主活动. kt</h2><p id="663e" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">我在这个应用程序中有一个单独的屏幕，这个屏幕使用RecyclerView描绘了冠状病毒详细信息的列表。</p><p id="9f59" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><code class="fe nm nn no np b">ViewModelProviders</code>是一个类，这个类的<code class="fe nm nn no np b">of()</code>方法返回活动范围的<strong class="lx iu"> MyViewModel类</strong>的对象。这是提供<strong class="lx iu">视图模型</strong>核心逻辑的主类。一旦我们创建了我们的<strong class="lx iu"> MyViewModel </strong>类的对象，现在我们可以开始使用<strong class="lx iu"> observer() </strong>方法观察数据。这个观察者接受两个参数，即当前活动的上下文和<strong class="lx iu">观察者</strong>匿名类。匿名类是没有任何名称的唯一类，这些类减少了类的数量。java文件，这些类用于一些特定的情况，当只有一次使用是必要的。在<strong class="lx iu"> Observer </strong>匿名类中，我们设置recyclerview适配器来显示我们的项目列表。所以这是我们在活动中需要的唯一代码。当<strong class="lx iu"> observer() </strong>发现数据中有任何更新时，它会通知适配器或任何视图。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="ea2b" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><strong class="lx iu"> MainActivity </strong>的布局文件仅包含recyclerview和一个progressBar，用于显示从远程存储库获取数据时的处理情况。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><h2 id="ad82" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">ModelListAdapter.kt</h2><p id="335f" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">这是在recyclerview中设置项目列表的适配器类。这个类是从<code class="fe nm nn no np b">MainActivity</code>中调用的。ModelListAdapter类使用<code class="fe nm nn no np b"><em class="nu">list_item</em></code> <em class="nu"> </em>布局文件，该文件有四个textviews来显示数据。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="fa22" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我们的适配器类的布局文件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><h2 id="98dc" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">MyViewModel.kt</h2><p id="679c" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">这是我们的ViewModel类，<strong class="lx iu"> MainActivity.kt </strong>类依赖于这个类。每当视图需要数据时，这个类就提供它。ViewModel类只负责管理数据。这个类永远不能访问视图。这个类的<code class="fe nm nn no np b">callAPI()</code>方法访问<code class="fe nm nn no np b">Repository</code>类的对象并调用它的<code class="fe nm nn no np b">callAPI()</code>方法。然后<code class="fe nm nn no np b">Repository</code>类返回<strong class="lx iu">可变数据</strong>对象的对象。这个对象进一步传递给our <code class="fe nm nn no np b">MainActivity</code>来设置数据。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><h2 id="849b" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">翻新设备服务</h2><p id="8c00" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">是一个有<code class="fe nm nn no np b">fetchData()</code>方法的接口，这个函数返回<code class="fe nm nn no np b">Country</code>类的对象。注意，fetchData()方法是用<strong class="lx iu"> @GET </strong>请求注释的，这意味着我们要发出的是一个<strong class="lx iu"> GET </strong>请求。Get request仅在仅从服务器获取数据时使用，这意味着在服务器上既不发送数据也不更新数据，除此之外，该接口还创建了reform类的singleton对象。<strong class="lx iu"> invoke() </strong>函数在<strong class="lx iu">伴随对象内部，</strong>这意味着无论何时我们需要调用这个<code class="fe nm nn no np b">invoke()</code>方法，我们都不必创建对象。<strong class="lx iu">伴随对象</strong>与Java的<strong class="lx iu">静态</strong>方法相同。在baseurl()方法中，我传递了我的web服务的url。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><h2 id="9ca8" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">Repository.kt</h2><p id="89d4" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">Repository类处理网络调用。当从<code class="fe nm nn no np b">MyModelView</code>类调用这个类的<strong class="lx iu"> callAPI() </strong>方法时，它很快开始执行它的异步方法<code class="fe nm nn no np b">enqueue()</code>。该方法有两个回调函数，<strong class="lx iu"> onFailure() </strong>和<strong class="lx iu"> onResponse() </strong>，如果调用成功，则调用<code class="fe nm nn no np b">onResponse()</code>，否则调用<code class="fe nm nn no np b">onFailure()</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="2948" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><strong class="lx iu">数据类别:</strong></p><p id="4020" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">Country是我的主类，它在构造函数中接受一个GlobalData类的列表。这个类由我们的API返回。</p><pre class="kj kk kl km gt nv np nw nx aw ny bi"><span id="f2e8" class="kz la it np b gy nz oa l ob oc"><strong class="np iu">class </strong>Country(<strong class="np iu">val Countries</strong>: List&lt;GlobalData&gt;) {<br/><br/>}</span></pre><p id="4ab2" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">这是我们从API得到的数据。</p><pre class="kj kk kl km gt nv np nw nx aw ny bi"><span id="13fd" class="kz la it np b gy nz oa l ob oc"><strong class="np iu">data class </strong>GlobalData(<br/>    <strong class="np iu">var Country</strong>: String,<br/>    <strong class="np iu">var NewConfirmed</strong>: Int,<br/>    <strong class="np iu">var TotalConfirmed</strong>: Int,<br/>    <strong class="np iu">var NewDeaths</strong>: Int,<br/>    <strong class="np iu">var TotalDeaths</strong>: Int,<br/>    <strong class="np iu">var NewRecovered</strong>: Int,<br/>    <strong class="np iu">var TotalRecovered</strong>: Int<br/>)</span></pre><h1 id="9f62" class="od la it bd lb oe of og le oh oi oj lh jz ok ka ll kc ol kd lp kf om kg lt on bi translated">使用LiveData的优势</h1><ul class=""><li id="f360" class="mu mv it lx b ly lz mb mc li mw lm mx lq my mn mz na nb nc bi translated">确保用户界面与数据状态相匹配</li><li id="4f29" class="mu mv it lx b ly nd mb ne li nf lm ng lq nh mn mz na nb nc bi translated"><strong class="lx iu">没有内存泄漏:</strong>观察器被绑定到<code class="fe nm nn no np b"><a class="ae ky" href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle" rel="noopener ugc nofollow" target="_blank">Lifecycle</a></code>对象，当它们相关的生命周期被破坏时，它们会自行清理。</li><li id="e36f" class="mu mv it lx b ly nd mb ne li nf lm ng lq nh mn mz na nb nc bi translated"><strong class="lx iu">没有因停止的活动而崩溃:</strong>如果观察者的生命周期处于非活动状态，例如在后台堆栈中的活动，那么它不会接收任何LiveData事件。</li><li id="2015" class="mu mv it lx b ly nd mb ne li nf lm ng lq nh mn mz na nb nc bi translated"><strong class="lx iu">不再手动处理生命周期:</strong> UI组件只是观察相关数据，并不停止或恢复观察。LiveData自动管理所有这一切，因为它在观察时知道相关的生命周期状态变化。</li><li id="8041" class="mu mv it lx b ly nd mb ne li nf lm ng lq nh mn mz na nb nc bi translated"><strong class="lx iu">总是最新数据:</strong>如果生命周期变为非活动状态，它会在再次变为活动状态时接收最新数据。例如，一个在后台的活动在返回前台后会立即收到最新的数据。</li><li id="7288" class="mu mv it lx b ly nd mb ne li nf lm ng lq nh mn mz na nb nc bi translated"><strong class="lx iu">适当的配置更改:</strong>如果由于配置更改(如设备轮换)而重新创建活动或片段，它会立即接收最新的可用数据。</li></ul><p id="0c86" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">如果你在代码的某个地方卡住了，不要担心，你可以从<a class="ae ky" href="https://github.com/himanshujbd/LiveData" rel="noopener ugc nofollow" target="_blank"> <strong class="lx iu">这里</strong> </a>下载我的Github项目。</p><p id="ad0c" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我希望你喜欢读这篇文章，你也可以访问我的<a class="ae ky" href="http://thehimanshuverma.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="lx iu">网站</strong> </a> <strong class="lx iu"> </strong>，在那里我会定期发布文章。</p><p id="1af3" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><a class="ae ky" href="https://mailchi.mp/b08da935e5d9/himanshuverma" rel="noopener ugc nofollow" target="_blank"> <strong class="lx iu">订阅</strong> </a>我的邮件列表，以便在您的收件箱中直接获得我的文章，并且不要忘记关注我自己在Medium上发表的文章<a class="ae ky" href="https://medium.com/the-code-monster" rel="noopener"><strong class="lx iu">The Code Monster</strong></a>来完善您的技术知识。</p><h1 id="a529" class="od la it bd lb oe of og le oh oi oj lh jz ok ka ll kc ol kd lp kf om kg lt on bi translated">结论</h1><p id="7c77" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">我们已经看到了如何将LiveData用于MVVM和改进API。为了详细说明LiveData的用例，我使用了Live Api，这样可以帮助您轻松理解LiveData的概念。</p></div></div>    
</body>
</html>