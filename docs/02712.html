<html>
<head>
<title>Intro to Window Functions in SQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SQL中的窗口函数介绍</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/intro-to-window-functions-in-sql-23ecdc7c1ceb?source=collection_archive---------12-----------------------#2020-03-16">https://towardsdatascience.com/intro-to-window-functions-in-sql-23ecdc7c1ceb?source=collection_archive---------12-----------------------#2020-03-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c5e5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何使用窗口函数跨一组行执行操作</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/02999dce13e74cb665b301582c1ea1ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*36YSG-arrR_BPXq-"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@mooo3721?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> R Mo </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="a81b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">窗口函数可以帮助您在选择行上运行操作，并从原始查询中返回值。</p><blockquote class="ls lt lu"><p id="a908" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">术语<a class="ae kv" href="https://drill.apache.org/docs/sql-window-functions-introduction/" rel="noopener ugc nofollow" target="_blank">窗口</a>描述函数操作的行集合。窗口函数使用窗口中行的值来计算返回值。</p></blockquote><p id="eda7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">窗口函数的一些常见用途包括计算累计和、移动平均、排名等。(<a class="ae kv" href="https://chartio.com/resources/tutorials/using-window-functions/" rel="noopener ugc nofollow" target="_blank">图表</a>)</p><p id="d249" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">窗口功能由<code class="fe lz ma mb mc b">OVER</code>子句启动，并使用三个概念进行配置:</p><ul class=""><li id="36f3" class="md me iq ky b kz la lc ld lf mf lj mg ln mh lr mi mj mk ml bi translated">窗口分区(<code class="fe lz ma mb mc b"><strong class="ky ir">P</strong>ARTITION BY</code> ) -将行分组为分区</li><li id="5edd" class="md me iq ky b kz mm lc mn lf mo lj mp ln mq lr mi mj mk ml bi translated">窗口排序(<code class="fe lz ma mb mc b">ORDER BY</code> ) -定义每个窗口中行的顺序或次序</li><li id="4275" class="md me iq ky b kz mm lc mn lf mo lj mp ln mq lr mi mj mk ml bi translated">窗口框架(<code class="fe lz ma mb mc b">ROWS</code> ) -使用指定行的偏移量定义窗口</li></ul><p id="6f43" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于本教程，我们将涵盖<code class="fe lz ma mb mc b"><strong class="ky ir">PARTITION</strong></code>和<code class="fe lz ma mb mc b"><strong class="ky ir">ORDER BY</strong></code>。我假设你有基本到中级的SQL经验。如果你没有，这里有一些很好的资源可以帮助你开始。</p><ul class=""><li id="185c" class="md me iq ky b kz la lc ld lf mf lj mg ln mh lr mi mj mk ml bi translated"><a class="ae kv" href="https://www.datacamp.com/courses/" rel="noopener ugc nofollow" target="_blank">数据营</a></li><li id="3755" class="md me iq ky b kz mm lc mn lf mo lj mp ln mq lr mi mj mk ml bi translated">周末速成班</li><li id="cb58" class="md me iq ky b kz mm lc mn lf mo lj mp ln mq lr mi mj mk ml bi translated"><a class="ae kv" href="https://www.udemy.com/course/sqldatabases/" rel="noopener ugc nofollow" target="_blank">学习MS SQL Server + PostgreSQL </a></li></ul></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><h1 id="bed6" class="my mz iq bd na nb nc nd ne nf ng nh ni jw nj jx nk jz nl ka nm kc nn kd no np bi translated">窗口函数与分组依据:</h1><ul class=""><li id="8459" class="md me iq ky b kz nq lc nr lf ns lj nt ln nu lr mi mj mk ml bi translated">窗口函数不会减少输出中的行数。</li><li id="329e" class="md me iq ky b kz mm lc mn lf mo lj mp ln mq lr mi mj mk ml bi translated">窗口函数可以从其他行中检索值，而GROUP BY函数则不能。</li><li id="b097" class="md me iq ky b kz mm lc mn lf mo lj mp ln mq lr mi mj mk ml bi translated">窗口函数可以计算累计和移动平均值，而GROUP BY函数则不能。</li></ul><h1 id="d518" class="my mz iq bd na nb nv nd ne nf nw nh ni jw nx jx nk jz ny ka nm kc nz kd no np bi translated">入门指南</h1><p id="934f" class="pw-post-body-paragraph kw kx iq ky b kz nq jr lb lc nr ju le lf oa lh li lj ob ll lm ln oc lp lq lr ij bi translated">我将与来自<a class="ae kv" href="https://www.datacamp.com/courses" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"/></a>数据营的名为<em class="lv"> summer_medal </em>的奥运奖牌榜一起工作。(如果你是一名拥有<strong class="ky ir"> <em class="lv"> edu </em> </strong>邮箱的学生，并且想要获得三个月的免费Datacamp访问— <a class="ae kv" href="https://education.github.com/pack" rel="noopener ugc nofollow" target="_blank"> GitHub学生开发者包</a>)。</p><p id="c3ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是该表的概述。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/c3138cc113a600f995fdb471f1ba709c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b8eZPM9xj6Bx0QPJ8LF9hw.png"/></div></div></figure><p id="2038" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该表代表了从1896年到2010年的奥运会，包含了每个国家、运动、项目、性别和学科的所有奖牌获得者。</p></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><h1 id="c8c2" class="my mz iq bd na nb nc nd ne nf ng nh ni jw nj jx nk jz nl ka nm kc nn kd no np bi translated">ROW_NUMBER()</h1><p id="c798" class="pw-post-body-paragraph kw kx iq ky b kz nq jr lb lc nr ju le lf oa lh li lj ob ll lm ln oc lp lq lr ij bi translated">如前所述，使用OVER()标识窗口函数。本教程中的第一个函数是ROW_NUMBER()。此函数为行中的每条记录分配一个编号。</p><pre class="kg kh ki kj gt oe mc of og aw oh bi"><span id="bb6a" class="oi mz iq mc b gy oj ok l ol om">SELECT<br/>  athlete,<br/>  event,<br/>  <strong class="mc ir">ROW_NUMBER() OVER()</strong> AS Row_Number<br/>FROM Summer_Medals<br/>ORDER BY Row_Number ASC;</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi on"><img src="../Images/b47769908a892cd1f566a7f919e585f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kSfz5gn6dluqEuHDiH89OQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">输出</p></figure><p id="3f37" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以看到，我们使用ROW_NUMBER()创建了一个行号，并将其分配给所选的变量。我们将窗口函数别名为Row_Number，并对其进行排序，这样我们就可以获得顶部的第一行编号。</p><h2 id="3321" class="oi mz iq bd na oo op dn ne oq or dp ni lf os ot nk lj ou ov nm ln ow ox no oy bi translated">行号为()，排序依据为()</h2><p id="f764" class="pw-post-body-paragraph kw kx iq ky b kz nq jr lb lc nr ju le lf oa lh li lj ob ll lm ln oc lp lq lr ij bi translated">我们可以结合<code class="fe lz ma mb mc b">ORDER BY</code>和<code class="fe lz ma mb mc b">ROW_NUMBER</code>来确定哪一列应该用于行号分配。让我们找到不同的运动，并根据字母顺序给它们分配行号。</p><pre class="kg kh ki kj gt oe mc of og aw oh bi"><span id="e2cb" class="oi mz iq mc b gy oj ok l ol om">SELECT<br/>  sport,<br/>  <strong class="mc ir">ROW_NUMBER()</strong> <strong class="mc ir">OVER</strong>(<strong class="mc ir">ORDER BY</strong> sport ASC) AS Row_N<br/>FROM (<br/>  SELECT DISTINCT sport<br/>  FROM Summer_Medals<br/>) AS sports<br/>ORDER BY sport ASC;</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oz"><img src="../Images/b59bb6868e32c15eb666a931efd0aaa0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CGsKK-pfbPtXkiG8ucbXGw.png"/></div></div></figure></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><h1 id="baa3" class="my mz iq bd na nb nc nd ne nf ng nh ni jw nj jx nk jz nl ka nm kc nn kd no np bi translated">划分依据</h1><p id="1456" class="pw-post-body-paragraph kw kx iq ky b kz nq jr lb lc nr ju le lf oa lh li lj ob ll lm ln oc lp lq lr ij bi translated">使用<code class="fe lz ma mb mc b"><a class="ae kv" href="https://www.geeksforgeeks.org/mysql-partition-by-clause/" rel="noopener ugc nofollow" target="_blank">PARTITION BY</a></code>,您可以根据一列中的唯一值拆分一个表。当我们必须使用一个组中的其他行对该组中的单个行执行计算时，这很有用。该子句仅适用于windows函数，如- <strong class="ky ir"> LAG() </strong>，<strong class="ky ir"> LEAD()，</strong>等。</p><h2 id="6bba" class="oi mz iq bd na oo op dn ne oq or dp ni lf os ot nk lj ou ov nm ln ow ox no oy bi translated">什么是LAG()？</h2><p id="44e8" class="pw-post-body-paragraph kw kx iq ky b kz nq jr lb lc nr ju le lf oa lh li lj ob ll lm ln oc lp lq lr ij bi translated">SQL <code class="fe lz ma mb mc b">LAG()</code>是一个窗口函数，输出当前行之前的一行。</p><p id="590a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个很好的例子，说明了它与我们的数据之间的关系。让我们找出从2004年开始按性别分列的网球运动员，谁赢得了网球单打金牌，谁在前一年获胜。</p><p id="889d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个问题有几个步骤。首先，我们想要创建一个CTE，它允许您定义一个临时命名的结果集，该结果集在一个语句的执行范围内临时可用——如果您被困在这里，请访问我的另一篇<a class="ae kv" rel="noopener" target="_blank" href="/using-ctes-to-improve-sql-queries-dfcb04b7edf0"> <strong class="ky ir">帖子</strong> </a>以了解更多信息。</p><p id="596c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我们希望在使用<code class="fe lz ma mb mc b">LAG()</code>之前，我们的结果中有今年的获胜者。</p><pre class="kg kh ki kj gt oe mc of og aw oh bi"><span id="ca27" class="oi mz iq mc b gy oj ok l ol om"><strong class="mc ir">-- CTE for isolating gold medal tennis winners<br/></strong>WITH Tennis_Gold AS (<br/>  SELECT<br/>    Athlete,<br/>    Gender,<br/>    Year,<br/>    Country<br/>  FROM<br/>    Summer_Medals<br/>  WHERE<br/>    Year  &gt;=  2004 AND<br/>    Sport = 'Tennis' AND<br/>    event = 'Singles' AND<br/>    Medal = 'Gold')</span><span id="8a72" class="oi mz iq mc b gy pa ok l ol om"><strong class="mc ir">-- Window Function to find the lag and partition by gender<br/></strong>SELECT<br/>    Athlete as Champion,<br/>    Gender,<br/>    Year,<br/>    <strong class="mc ir">LAG</strong>(Athlete) OVER (<strong class="mc ir">PARTITION BY</strong> gender<br/>                        ORDER BY Year ASC) AS Last_Champion<br/>FROM Tennis_Gold<br/>ORDER BY Gender ASC, Year ASC;</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pb"><img src="../Images/403163d4c7c2269172e39fb997d23fd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ygn_ApGqmrkYQgQZ5oH1Hg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">输出</p></figure><p id="75ab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以看到，男性和女性的结果都在一列中输出——这就是分区的作用。我们承认有3名男性和3名女性获奖者。男性和女性的第一个赢家是在2004年，如果我们看右边，我们看到一个空，因为在这之前没有赢家，因为我们从2004年开始。使用<code class="fe lz ma mb mc b">LAG</code>和<code class="fe lz ma mb mc b">PARTITION BY</code>有助于实现这一点。</p><p id="3d99" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们尝试使用铅()。</p><h2 id="054c" class="oi mz iq bd na oo op dn ne oq or dp ni lf os ot nk lj ou ov nm ln ow ox no oy bi translated">什么是铅()？</h2><p id="b679" class="pw-post-body-paragraph kw kx iq ky b kz nq jr lb lc nr ju le lf oa lh li lj ob ll lm ln oc lp lq lr ij bi translated">SQL <code class="fe lz ma mb mc b">LEAD()</code>是一个窗口函数，输出当前行之后的一行——本质上与LAG()相反。</p><p id="b44c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们使用网球例子中的相同问题，但是相反，找到未来的冠军，而不是过去的冠军。</p><pre class="kg kh ki kj gt oe mc of og aw oh bi"><span id="182a" class="oi mz iq mc b gy oj ok l ol om"><strong class="mc ir">-- CTE isolating tennis sport, gold medalists from the year 2004+</strong></span><span id="bce7" class="oi mz iq mc b gy pa ok l ol om">WITH Tennis_Gold AS (<br/>  SELECT<br/>    Athlete,<br/>    Gender,<br/>    Year,<br/>    Country<br/>  FROM<br/>    Summer_Medals<br/>  WHERE<br/>    Year  &gt;=  2004 AND<br/>    Sport = 'Tennis' AND<br/>    event = 'Singles' AND<br/>    Medal = 'Gold')</span><span id="c4b2" class="oi mz iq mc b gy pa ok l ol om"><strong class="mc ir">-- Window function, using LEAD to find the NEXT champion<br/></strong>SELECT<br/>    Athlete as Champion,<br/>    Gender,<br/>    Year,<br/>    <strong class="mc ir">LEAD</strong>(Athlete) OVER (PARTITION BY gender<br/>                        ORDER BY Year ASC) AS <strong class="mc ir">Future_Champion</strong><br/>FROM Tennis_Gold<br/>ORDER BY Gender ASC, Year ASC;</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pc"><img src="../Images/547b69d58875c00c2d034c131bccf0d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QBLdsVn43ydE_im-PUNPyQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">输出</p></figure><p id="b5fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们只需要把<code class="fe lz ma mb mc b">LAG</code>改成<code class="fe lz ma mb mc b">LEAD</code>，把别名改成未来冠军，就能达到相反的效果。</p></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><h1 id="0fe9" class="my mz iq bd na nb nc nd ne nf ng nh ni jw nj jx nk jz nl ka nm kc nn kd no np bi translated">排名()</h1><p id="de55" class="pw-post-body-paragraph kw kx iq ky b kz nq jr lb lc nr ju le lf oa lh li lj ob ll lm ln oc lp lq lr ij bi translated">SQL <code class="fe lz ma mb mc b">RANK</code>与<code class="fe lz ma mb mc b">ROW_NUMBER</code>类似，只是它会将相同的数字分配给具有相同值的行，跳过后面的数字。还有一个<code class="fe lz ma mb mc b">DENSE_RANK</code>，它给一个具有相等值的行分配一个数字，但不跳过一个数字。如果这一切看起来令人困惑，不要担心。下面是这种情况的并列对比。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pd"><img src="../Images/8983603f4ab5887972c1ea761d1a6e9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CYrlJQKM6BHRcfBtDN6rag.png"/></div></div></figure><h2 id="d0d1" class="oi mz iq bd na oo op dn ne oq or dp ni lf os ot nk lj ou ov nm ln ow ox no oy bi translated">请注意3种不同类型的柱。</h2><ul class=""><li id="4255" class="md me iq ky b kz nq lc nr lf ns lj nt ln nu lr mi mj mk ml bi translated">Row_number —这里没有什么新东西，我们只是为查询中的每一个行添加值。</li><li id="1330" class="md me iq ky b kz mm lc mn lf mo lj mp ln mq lr mi mj mk ml bi translated">Rank_number —这里，我们给出了基于值的排名，但是请注意，我们没有排名<strong class="ky ir"> 3 </strong>。相反，我们有两个2，我们跳到排名4。</li><li id="623d" class="md me iq ky b kz mm lc mn lf mo lj mp ln mq lr mi mj mk ml bi translated">Dense_rank —类似于rank_number，但我们没有跳过秩3，而是包括了它。</li></ul><p id="7cb4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是<code class="fe lz ma mb mc b">RANK</code>和<code class="fe lz ma mb mc b">DENSE_RANK</code>的主要区别。一个包括在联合排名数字之前的排名，一个不包括。</p><p id="c68f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是我用来得到上表的代码。</p><pre class="kg kh ki kj gt oe mc of og aw oh bi"><span id="fbbe" class="oi mz iq mc b gy oj ok l ol om">-- <strong class="mc ir"><em class="lv">CTE to get countries and number year particpated in selected countries.</em></strong></span><span id="48c0" class="oi mz iq mc b gy pa ok l ol om">WITH countries AS (<br/>  SELECT<br/>    Country,<br/>    COUNT(DISTINCT year) AS participated<br/>  FROM<br/>    Summer_Medals<br/>  WHERE<br/>    Country in ('GBR', 'DEN', 'FRA', 'ITA','AUT')<br/>  GROUP BY<br/>    Country)</span><span id="63e7" class="oi mz iq mc b gy pa ok l ol om">-- <strong class="mc ir"><em class="lv">Window functions to show different ranking choices.</em></strong><br/>SELECT<br/>    Country,<br/>    participated,<br/>    <strong class="mc ir">ROW_NUMBER()</strong><br/>        OVER(ORDER BY participated DESC) AS Row_Number,<br/>    <strong class="mc ir">RANK()</strong><br/>        OVER(ORDER BY participated DESC) AS Rank_Number,<br/>    <strong class="mc ir">DENSE_RANK()</strong><br/>        OVER(ORDER BY participated DESC) AS Dense_Rank<br/>FROM countries<br/>ORDER BY participated DESC;</span></pre></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><h1 id="db17" class="my mz iq bd na nb nc nd ne nf ng nh ni jw nj jx nk jz nl ka nm kc nn kd no np bi translated">最终结果</h1><p id="f48a" class="pw-post-body-paragraph kw kx iq ky b kz nq jr lb lc nr ju le lf oa lh li lj ob ll lm ln oc lp lq lr ij bi translated">对窗口函数的介绍到此结束。windows函数还有更多的功能，包括<code class="fe lz ma mb mc b">ROWS</code>、<code class="fe lz ma mb mc b">NTILE</code>，以及集合函数(<code class="fe lz ma mb mc b">SUM</code>、<code class="fe lz ma mb mc b">MAX</code>、<code class="fe lz ma mb mc b">MIN</code>等。).我将发布关于如何在SQL中更多地利用窗口函数的教程，所以请务必关注我的最新帖子。</p><p id="6b60" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<a class="ae kv" href="https://www.linkedin.com/in/jasonmchlee/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> Linkedin </strong> </a>或<a class="ae kv" href="https://github.com/jasonmchlee" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> Github </strong> </a>上与我联系</p></div></div>    
</body>
</html>