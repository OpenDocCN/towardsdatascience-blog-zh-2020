<html>
<head>
<title>Linear Interpolation In Python a Single Line of Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中的线性插值一行代码</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/linear-interpolation-in-python-a-single-line-of-code-25ab83b764f9?source=collection_archive---------11-----------------------#2020-06-29">https://towardsdatascience.com/linear-interpolation-in-python-a-single-line-of-code-25ab83b764f9?source=collection_archive---------11-----------------------#2020-06-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="c451" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">推导实用算法</h2><div class=""/><div class=""><h2 id="25a9" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">利用<code class="fe ko kp kq kr b">numpy</code>简化每个人工具箱中应该有的技术</h2></div><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div class="gh gi ks"><img src="../Images/31f980e95b9c6d90583a1b0ef4abf023.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*XdrmbrDQiUwLtBdFWRE4Ug.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">插值对数线性和反转(线性对数)值</p></figure><h1 id="c125" class="le lf iq bd lg lh li lj lk ll lm ln lo kf lp kg lq ki lr kj ls kl lt km lu lv bi translated">介绍</h1><p id="0856" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">线性插值从离散数据中创建一个连续函数。这是梯度下降算法的基础构建块，该算法用于几乎所有机器学习技术的训练。尽管深度学习非常复杂，但没有它就无法工作。这里我们先来看看构造线性插值算法的理论基础，然后实现一个实用的算法并将其应用到一个案例中。</p><h1 id="5eb6" class="le lf iq bd lg lh li lj lk ll lm ln lo kf lp kg lq ki lr kj ls kl lt km lu lv bi translated">衍生物</h1><p id="4c20" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">如果你想跳过推导，向下滚动到标题为<em class="ms">的章节，一句话</em>作为笑点。不然继续看！这不会花那么长时间…</p><p id="a033" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">在之前的文章中，我们通过使用一些线性代数讨论了线性回归的基础。特别是，我们用这个结果来确定回归系数:</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/2bce6dc178805331b52ebac86537c322.png" data-original-src="https://miro.medium.com/v2/resize:fit:290/format:webp/0*yVZadLxRNoYOo29u.png"/></div></figure><p id="2ab2" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">我们也有这个方程来预测这些系数:</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div class="gh gi na"><img src="../Images/b36eb8b390d07b082d0590f10bcf2248.png" data-original-src="https://miro.medium.com/v2/resize:fit:132/format:webp/1*ZF7cn57JtstAR1y3cHcUDw.png"/></div></figure><p id="f593" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">如果我们将第一个方程代入第二个方程，我们将得到预测值的直接估计值:</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/ada0b5cfda8e857fa4c7c58319fbf8e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:292/format:webp/1*vOLmlURs6HFtrllGq0B2VA.png"/></div></figure><p id="31bf" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">所有这些<strong class="ly ja"> <em class="ms"> X </em> </strong>项形成了一个叫做<a class="ae my" href="https://en.wikipedia.org/wiki/Projection_matrix" rel="noopener ugc nofollow" target="_blank">投影矩阵</a>的东西，也叫做帽子矩阵:</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/0a4a1497242485d0c4cfd719b9e6b026.png" data-original-src="https://miro.medium.com/v2/resize:fit:264/format:webp/1*rrcBTElXHd1qdOCH208S9w.png"/></div></figure><p id="fcce" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">投影矩阵<strong class="ly ja"> <em class="ms">将</em> </strong>(或<strong class="ly ja"> <em class="ms">投影</em> </strong>)的观测值<strong class="ly ja"><em class="ms"/></strong>转换为预测值<strong class="ly ja"><em class="ms"/></strong>。为此，它必须包含对任意值<strong class="ly ja"> <em class="ms"> Y </em> </strong>进行预测所需的所有信息。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/ec22ef9a8df747bd7b80be1726cce8da.png" data-original-src="https://miro.medium.com/v2/resize:fit:138/format:webp/1*KSedd3vBDAMVESz-wu7FLg.png"/></div></figure><p id="9538" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">如此看来，如果我们知道了<strong class="ly ja"><em class="ms"/></strong>，我们就知道了<strong class="ly ja"><em class="ms"/></strong>如何预测任何值！为了说明这一点，让我们创建一个玩具示例，看看帽子矩阵是什么样子的。我们将使用位于坐标(0，1)和(5，2)的两个数据点。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/92f4aad922d338cc0a68b07195667d70.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*Weu2Eae2iR2FHkvp7CGRGw.png"/></div></figure><h1 id="2beb" class="le lf iq bd lg lh li lj lk ll lm ln lo kf lp kg lq ki lr kj ls kl lt km lu lv bi translated">发展</h1><p id="210b" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">让我们用 Python 演示一下:</p><pre class="kt ku kv kw gt nf kr ng nh aw ni bi"><span id="891a" class="nj lf iq kr b gy nk nl l nm nn">import numpy as np<br/>np.set_printoptions(suppress=True)  # no scientific formatting</span><span id="83a5" class="nj lf iq kr b gy no nl l nm nn"># np.r_ and np.c_ are short-hands for concatenation of arrays<br/># np.r_ performs along the first-axis (rows)<br/># np.c_ performs along the second-axis (columns)</span><span id="e9d7" class="nj lf iq kr b gy no nl l nm nn"># our x-values<br/>x = np.c_[1., 1.,], [0., 5.]]</span><span id="b5db" class="nj lf iq kr b gy no nl l nm nn"># our y-values<br/>y = np.r_[1., 2.]</span><span id="e3b3" class="nj lf iq kr b gy no nl l nm nn">print(x)<br/>array([[1., 0.],<br/>       [1., 5.]])</span></pre><p id="ca79" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">到目前为止很简单。我们可以使用第一个等式求解回归系数:</p><pre class="kt ku kv kw gt nf kr ng nh aw ni bi"><span id="dcf1" class="nj lf iq kr b gy nk nl l nm nn"># @ is the numpy operator for matrix multiplication<br/>c = np.linalg.inv(x.T @ x) @ x.T @ Y</span><span id="6b42" class="nj lf iq kr b gy no nl l nm nn">print(c)<br/>array([1., 0.2])</span></pre><p id="9183" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">正如我们所料，斜率为 1/5，截距为 1。下一个是投影矩阵:</p><pre class="kt ku kv kw gt nf kr ng nh aw ni bi"><span id="67ca" class="nj lf iq kr b gy nk nl l nm nn"># @ is the numpy operator for matrix multiplication<br/>h = x @ np.linalg.inv(x.T @ x) @ x.T</span><span id="932d" class="nj lf iq kr b gy no nl l nm nn">print(h)<br/>array([[1., 0.],<br/>       [0., 1.]])</span></pre><p id="8104" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">回想一下，当我们将<strong class="ly ja"> <em class="ms"> H </em> </strong>乘以<strong class="ly ja"> <em class="ms"> Y </em> </strong>时，我们得到了预测值<strong class="ly ja"><em class="ms">【ŷ】</em></strong>。因为我们在对角线上有 1，在其他地方有 0，在这种情况下，<strong class="ly ja"> <em class="ms"> H </em> </strong>实际上是单位矩阵，所以我们简单地返回实际 y 值(1，2)的预测值(1，2)。当我们的点不像几乎所有线性回归问题那样形成一条直线时，情况就不一样了。然而，对于插值，我们总是可以做这样的假设，因为只有两个点限制了我们想要插值的点！</p><h1 id="8387" class="le lf iq bd lg lh li lj lk ll lm ln lo kf lp kg lq ki lr kj ls kl lt km lu lv bi translated">插入文字</h1><p id="7bef" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">实际插值呢？如果我们回忆一下第二个方程，我们可以为<strong class="ly ja"><em class="ms"/></strong>X 提供任何值以便创建一个预测值。让我们利用这个事实重写我们的投影矩阵，用<strong class="ly ja"> <em class="ms"> X₀ </em> </strong>代表我们的实际值，用<strong class="ly ja"> <em class="ms"> X₁ </em> </strong>代表我们要插值的值。我们将使用<strong class="ly ja"> <em class="ms"> W </em> </strong>将其表示为权重矩阵，原因我们稍后会看到:</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div class="gh gi np"><img src="../Images/cd1bcd992dfd94238efb08f66493c678.png" data-original-src="https://miro.medium.com/v2/resize:fit:316/format:webp/1*r9soRRtZzfup2Pyk3lR2zQ.png"/></div></figure><p id="04e9" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">如果我们在 0 和 5 的值<strong class="ly ja"><em class="ms"/></strong>之间尝试<strong class="ly ja"> <em class="ms"> X₁ </em> </strong>的各种值会发生什么？</p><pre class="kt ku kv kw gt nf kr ng nh aw ni bi"><span id="e54d" class="nj lf iq kr b gy nk nl l nm nn">for i in np.linspace(0, 5, 6):<br/>    w = np.c_[1., i] @ np.linalg.inv(x.T @ x) @ x.T<br/>    y_hat = w @ y<br/>    print(f'x1 = {i:.1f}, w = {w}, y_hat = {y_hat}')</span><span id="34c8" class="nj lf iq kr b gy no nl l nm nn">x1 = 0.0, w = [[1.0 0.0]], y_hat = [1.0]<br/>x1 = 1.0, w = [[0.8 0.2]], y_hat = [1.2]<br/>x1 = 2.0, w = [[0.6 0.4]], y_hat = [1.4]</span><span id="3fdc" class="nj lf iq kr b gy no nl l nm nn">x1 = 3.0, w = [[0.4 0.6]], y_hat = [1.6]<br/>x1 = 4.0, w = [[0.2 0.8]], y_hat = [1.8]</span><span id="a5f0" class="nj lf iq kr b gy no nl l nm nn">x1 = 5.0, w = [[0.0 1.0]], y_hat = [2.0]</span></pre><p id="5a93" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">有趣的事情发生了！在每种情况下，权重矩阵的和是 1。当我们将这个权重矩阵乘以<strong class="ly ja"> <em class="ms"> Y </em> </strong>值时，我们得到的是两个值的加权平均值。第一个权重与两个值<strong class="ly ja"><em class="ms"/></strong>之间插值的<strong class="ly ja"><em class="ms"/></strong>的距离成正比，第二个权重正好是第一个权重的补码。换句话说:</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/264f705de14ec210adea7a41ca7047a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:412/format:webp/1*7GFUOR2lh3A7kMDc3ShDFw.png"/></div></figure><h1 id="056d" class="le lf iq bd lg lh li lj lk ll lm ln lo kf lp kg lq ki lr kj ls kl lt km lu lv bi translated">一句话</h1><p id="398b" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">这给了我们一行的线性插值:</p><pre class="kt ku kv kw gt nf kr ng nh aw ni bi"><span id="b322" class="nj lf iq kr b gy nk nl l nm nn">new_y = np.c_[1., new_x] @ np.linalg.inv(x.T @ x) @ x.T @ y</span></pre><p id="13aa" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">当然，这有点噱头。我们必须准确地知道原始 x 值数组中的两个值，新的插值 x 值位于这两个值之间。我们需要一个函数来确定这两个值的索引。值得庆幸的是，<code class="fe ko kp kq kr b">numpy</code>恰恰包含了这样一个恰好的函数:<code class="fe ko kp kq kr b">np.searchsorted</code>。让我们用它把线性代数变成一个矢量化的函数。我们不是为每个插值计算权重矩阵，而是存储相关信息:权重本身，以及<strong class="ly ja"> <em class="ms"> X </em> </strong>值的索引(当我们计算插值时，它们也将由<strong class="ly ja"> <em class="ms"> Y </em> </strong>值的索引决定)。</p><pre class="kt ku kv kw gt nf kr ng nh aw ni bi"><span id="a0dc" class="nj lf iq kr b gy nk nl l nm nn">from typing import NamedTuple</span><span id="0efd" class="nj lf iq kr b gy no nl l nm nn">class Coefficient(NamedTuple):<br/>    lo: np.ndarray  # int  <br/>    hi: np.ndarray  # int<br/>    w: np.ndarray  # float</span><span id="d7fb" class="nj lf iq kr b gy no nl l nm nn">def interp_coef(<em class="ms">x0: </em>np.ndarray, <em class="ms">x</em>: np.ndarray) -&gt; Coefficient:<br/>    # find the indices into the original array<br/>    hi = np.minimum(len(x0) - 1, np.searchsorted(x0, x, 'right'))<br/>    lo = np.maximum(0, hi - 1)<br/>    <br/>    # calculate the distance within the range<br/>    d_left = x - x0[lo]<br/>    d_right = x0[hi] - x<br/>    d_total = d_left + d_right</span><span id="0bf8" class="nj lf iq kr b gy no nl l nm nn">    # weights are the proportional distance<br/>    w = d_right / d_total</span><span id="30f5" class="nj lf iq kr b gy no nl l nm nn">    # correction if we're outside the range of the array<br/>    w[np.isinf(w)] = 0.0</span><span id="3bb8" class="nj lf iq kr b gy no nl l nm nn">    # return the information contained by the projection matrices<br/>    <em class="ms">return</em> Coefficient(lo, hi, w)</span><span id="b9c8" class="nj lf iq kr b gy no nl l nm nn">def interp_with(<em class="ms">y0</em>: np.ndarray, <em class="ms">coef</em>: Coefficient) -&gt; np.ndarray:<br/>    <em class="ms">return</em> coef.w * y0[coef.lo] + (1 - coef.w) * y0[coef.hi]</span></pre><p id="9c60" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">这个算法的方便之处在于我们只需要计算一次我们的权重。有了权重，我们就可以对与 x 值向量对齐的任何 y 值向量进行插值。</p><h1 id="267b" class="le lf iq bd lg lh li lj lk ll lm ln lo kf lp kg lq ki lr kj ls kl lt km lu lv bi translated">示例应用程序</h1><p id="1850" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">在工程问题中，我们正在建模的物理过程通常是指数函数或幂律函数。当我们为这些过程收集数据时，我们可以以对数间隔的时间间隔进行。许多解释方法被构造成以均匀的测井间隔时间间隔工作。然而，一些数值方法更便于处理均匀的线性间距值。所以来回转换的能力很方便。线性插值是执行这种变换的一种工具。</p><p id="c1a4" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">事实上，我们并不局限于线性插值。我们可以首先线性化我们的值，然后进行插值。让我们来看一个径向系统中流量、<strong class="ly ja"> <em class="ms">、q </em> </strong>、压力、<strong class="ly ja"> <em class="ms"> p </em>、</strong>的例子。这些数据是用均匀对数间隔的样本合成的，当我们将它绘制在双对数图上时，我们会看到大多数数据的不同幂律行为。在后期，流速转变为指数下降，但这不会对我们的插值产生太大影响。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/9d11961a6949cd81cbb2f4c789b10292.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/1*JTYsbpPTrdXTf5oztX9MCQ.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">径流系统的压力和流量数据</p></figure><p id="23a4" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">让我们使用一组等距值进行插值。我们将假设幂律函数作为插值的基础，首先对我们的值应用对数变换。我们还将反转插值，以验证插值是否正确执行:</p><pre class="kt ku kv kw gt nf kr ng nh aw ni bi"><span id="9c93" class="nj lf iq kr b gy nk nl l nm nn"># construct out linear time series<br/>tDi = np.linspace(1e-3, 1e4, 100_001)</span><span id="658b" class="nj lf iq kr b gy no nl l nm nn"># interpolate from log to linear<br/>coef = interp_coef(np.log(time), np.log(time_interp))<br/>pi = np.exp(interp_with(np.log(pressure), coef))<br/>qi = np.exp(interp_with(np.log(rate), coef))</span><span id="8b53" class="nj lf iq kr b gy no nl l nm nn"># reverse from linear to log<br/>coef_i = interp_coef(np.log(time_interp), np.log(time))<br/>pr = np.exp(interp_with(np.log(pi), coef_i))<br/>qr = np.exp(interp_with(np.log(qi), coef_i))</span></pre><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div class="gh gi ks"><img src="../Images/31f980e95b9c6d90583a1b0ef4abf023.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*XdrmbrDQiUwLtBdFWRE4Ug.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">插值对数线性和反转(线性对数)值</p></figure><h1 id="1037" class="le lf iq bd lg lh li lj lk ll lm ln lo kf lp kg lq ki lr kj ls kl lt km lu lv bi translated">摘要</h1><p id="2449" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">线性方法是处理数据的重要工具。变量的变换，例如通过使用示例中所示的<code class="fe ko kp kq kr b">np.log</code>，允许我们在不期望数据是线性的情况下应用这些技术。</p><p id="b7bb" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">虽然我们推导并实现了自己的算法，但标准算法确实存在:<code class="fe ko kp kq kr b">scipy.interpolated.interp1d</code>。然而，为了在一些包中使用，比如当使用<code class="fe ko kp kq kr b">pymc3</code>时，可能需要为自己实现类似这样的东西。</p><p id="2a8d" class="pw-post-body-paragraph lw lx iq ly b lz mt ka mb mc mu kd me mf mv mh mi mj mw ml mm mn mx mp mq mr ij bi translated">还存在更一般的插值方法。其中之一是 B 样条，我们将在本系列的下一篇文章<em class="ms"> </em>中讨论它。b 样条也可以执行线性插值，以及二次，三次等。b 样条通过扩展我们在这里开发的概念来工作。也就是说，将权重<strong class="ly ja"> <em class="ms">向量</em> </strong>扩展为权重<strong class="ly ja"> <em class="ms">矩阵</em> </strong>。我们无需编写函数来查找每个插值的索引，只需用系数和新 x 值的矩阵乘法来计算插值的 y 值即可。</p></div></div>    
</body>
</html>