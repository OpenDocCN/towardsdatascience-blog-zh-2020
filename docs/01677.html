<html>
<head>
<title>The easiest way to download YouTube videos using Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Python 下载 YouTube 视频的最简单方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-easiest-way-to-download-youtube-videos-using-python-2640958318ab?source=collection_archive---------0-----------------------#2020-02-16">https://towardsdatascience.com/the-easiest-way-to-download-youtube-videos-using-python-2640958318ab?source=collection_archive---------0-----------------------#2020-02-16</a></blockquote><div><div class="fc ij ik il im in"/><div class="io ip iq ir is"><figure class="iu iv gp gr iw ix gh gi paragraph-image"><div role="button" tabindex="0" class="iy iz di ja bf jb"><div class="gh gi it"><img src="../Images/ee4216a2781dfc4fefe1db10c640b0b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CFBRJJaHQ7LBoJvuUTikig.jpeg"/></div></div><p class="je jf gj gh gi jg jh bd b be z dk translated">来源:<a class="ae ji" href="https://unsplash.com/photos/peLs78VbU50" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><div class=""/><div class=""><h2 id="5afd" class="pw-subtitle-paragraph ki jk jl bd b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dk translated">以及如何使用自定义类将帧提取为图像</h2></div><p id="bd65" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">在我的第一篇关于 Medium 的文章中，我展示了如何训练一个卷积神经网络来分类来自旧 GameBoy 游戏——Mario 和 Wario 的图像。一年多后，我想重温这个过程的一个方面——从 YouTube 视频下载视频(可能还有音频),并提取帧作为图像。我们可以将这样的图像用于各种机器学习项目。</p><h1 id="0082" class="lw lx jl bd ly lz ma mb mc md me mf mg kr mh ks mi ku mj kv mk kx ml ky mm mn bi translated">设置</h1><p id="f75f" class="pw-post-body-paragraph la lb jl lc b ld mo km lf lg mp kp li lj mq ll lm ln mr lp lq lr ms lt lu lv io bi translated">在我之前的文章中，我使用了一个名为<code class="fe mt mu mv mw b">pytube</code>的库来下载视频。然而，在 YouTube 引入一些变化后，它不再真正可用——任何下载视频的尝试都会导致<code class="fe mt mu mv mw b">KeyError: ‘url_encoded_fmt_stream_map’</code>。此外，图书馆不再得到积极维护。</p><p id="bc49" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">这就是为什么在这篇文章中我建议使用<code class="fe mt mu mv mw b">pytube3</code>，它是原始<code class="fe mt mu mv mw b">pytube</code>库的一个分支，并且已经修复了错误(它只适用于 Python 3)。原始库的所有功能都被保留，我们实际上仍然使用<code class="fe mt mu mv mw b">import pytube</code>来导入库(即使我们使用<code class="fe mt mu mv mw b">pip install pytube3</code>来安装它)。</p><p id="8709" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">下面我给出了本文所需的所有导入的列表:</p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="c12b" class="nf lx jl mw b gy ng nh l ni nj">from pytube import YouTube</span><span id="3311" class="nf lx jl mw b gy nk nh l ni nj"># misc<br/>import os<br/>import shutil<br/>import math<br/>import datetime</span><span id="4c6e" class="nf lx jl mw b gy nk nh l ni nj"># plots<br/>import matplotlib.pyplot as plt<br/>%matplotlib inline</span><span id="53f8" class="nf lx jl mw b gy nk nh l ni nj"># image operation<br/>import cv2</span></pre><h1 id="64fe" class="lw lx jl bd ly lz ma mb mc md me mf mg kr mh ks mi ku mj kv mk kx ml ky mm mn bi translated">下载视频</h1><p id="28ad" class="pw-post-body-paragraph la lb jl lc b ld mo km lf lg mp kp li lj mq ll lm ln mr lp lq lr ms lt lu lv io bi translated">在这一部分，我将介绍如何使用 Python 下载 YouTube 视频。我将使用 GameBoy 的一款经典视频游戏—<em class="nl">Mega Man:Wily 博士的复仇</em>。第一步是使用我们想要下载的视频的链接创建一个<code class="fe mt mu mv mw b">YouTube</code>类的实例。</p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="3a19" class="nf lx jl mw b gy ng nh l ni nj">video = YouTube('https://www.youtube.com/watch?v=NqC_1GuY3dw')</span></pre><p id="3d34" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">使用这个对象，我们可以下载视频/音频，并检查视频本身的一些属性。我们可以使用的一些有趣的方法有:</p><ul class=""><li id="4a07" class="nm nn jl lc b ld le lg lh lj no ln np lr nq lv nr ns nt nu bi translated"><code class="fe mt mu mv mw b">length</code> —以秒为单位的视频长度</li><li id="013e" class="nm nn jl lc b ld nv lg nw lj nx ln ny lr nz lv nr ns nt nu bi translated"><code class="fe mt mu mv mw b">rating</code> —视频的分级</li><li id="4bd4" class="nm nn jl lc b ld nv lg nw lj nx ln ny lr nz lv nr ns nt nu bi translated"><code class="fe mt mu mv mw b">views</code> —视图的数量</li></ul><p id="698d" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">下一步是使用<code class="fe mt mu mv mw b">streams</code>方法检查可用的流。我们可以用<code class="fe mt mu mv mw b">all</code>方法来链接它，以查看所有可用的流。</p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="776d" class="nf lx jl mw b gy ng nh l ni nj">video.streams.all()</span></pre><p id="0a77" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">运行该行代码将返回以下媒体格式列表:</p><figure class="mx my mz na gt ix"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="4f5f" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">关于媒体格式和流处理选项的更深入的描述，我在这里参考<code class="fe mt mu mv mw b">pytube</code>的可用文档<a class="ae ji" href="https://python-pytube.readthedocs.io/en/latest/index.html" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="1a12" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">让我们使用过滤方法将所有可用的流缩小到 mp4 文件:</p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="af81" class="nf lx jl mw b gy ng nh l ni nj">video.streams.filter(<em class="nl">file_extension</em> = "mp4").all()</span></pre><p id="ee38" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">运行该代码会导致以下选择:</p><figure class="mx my mz na gt ix"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="e484" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">在这种情况下，我们将使用第一个可用的选项，即 360p(分辨率)的选项。为了下载视频，我们首先通过使用<code class="fe mt mu mv mw b">itag</code>来指示我们想要下载的视频，然后使用<code class="fe mt mu mv mw b">download</code>方法来下载文件。下载视频的完整代码如下:</p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="df34" class="nf lx jl mw b gy ng nh l ni nj">video.streams.get_by_itag(18).download()</span></pre><p id="3154" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">在<code class="fe mt mu mv mw b">download</code>方法中，我们还可以指定视频的目的路径。默认值是当前目录。</p><h1 id="0f75" class="lw lx jl bd ly lz ma mb mc md me mf mg kr mh ks mi ku mj kv mk kx ml ky mm mn bi translated">从视频中提取帧</h1><p id="7bd7" class="pw-post-body-paragraph la lb jl lc b ld mo km lf lg mp kp li lj mq ll lm ln mr lp lq lr ms lt lu lv io bi translated">我创建了一个名为<code class="fe mt mu mv mw b">FrameExtractor</code>的特殊类——顾名思义——从视频中提取单个帧并保存为图像。该类定义如下:</p><figure class="mx my mz na gt ix"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="ea55" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">在实例化<code class="fe mt mu mv mw b">FrameExtractor</code>类的对象时，我们需要提供我们想要处理的视频的路径。在<code class="fe mt mu mv mw b">__init__</code>方法中，我们还提取了视频的一些特征，如总帧数和每秒帧数(FPS)。一般来说，该类提供了从视频中提取每第<em class="nl"> x </em>帧的功能，因为任何两个相邻帧之间的差异将是最小的。我们还提供了一些方便的方法。所有方法描述如下:</p><ul class=""><li id="269b" class="nm nn jl lc b ld le lg lh lj no ln np lr nq lv nr ns nt nu bi translated"><code class="fe mt mu mv mw b">get_video_duration</code> —打印视频的持续时间</li><li id="45e2" class="nm nn jl lc b ld nv lg nw lj nx ln ny lr nz lv nr ns nt nu bi translated"><code class="fe mt mu mv mw b">get_n_images</code> —打印每隔<em class="nl"> x </em>帧提取的图像数量(由<code class="fe mt mu mv mw b">every_x_frame</code>表示)</li><li id="b667" class="nm nn jl lc b ld nv lg nw lj nx ln ny lr nz lv nr ns nt nu bi translated"><code class="fe mt mu mv mw b">extract_frames</code> —这是该类的主要方法，用于提取图像。最起码要提供<code class="fe mt mu mv mw b">every_x_frame</code>的值和图像的名称(表示序列的数字会自动添加到名称的末尾)。默认情况下，图像将保存在当前目录中。我们还可以提供一个到所需目录的路径(<code class="fe mt mu mv mw b">dest_path</code>)，如果它不存在，就会为我们创建一个。我们还可以指定图像文件的格式，默认是 JPG。</li></ul><p id="f4af" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">现在是实际使用该类的时候了。我们从实例化<code class="fe mt mu mv mw b">FrameExtractor</code>类的对象开始:</p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="e02b" class="nf lx jl mw b gy ng nh l ni nj">fe = FrameExtractor('Game Boy Longplay [009] Mega Man Dr Wilys Revenge.mp4')</span></pre><p id="7466" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">接下来，我们调查视频的长度:</p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="387e" class="nf lx jl mw b gy ng nh l ni nj">fe.get_video_duration()<br/># Duration: 0:39:48.333333</span></pre><p id="42a4" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">举个例子，假设我们想每隔 1000 帧提取一次。为了计算使用此设置提取的图像数量，我们运行:</p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="a2f5" class="nf lx jl mw b gy ng nh l ni nj">fe.get_n_images(every_x_frame=1000)<br/># Extracting every 1000 (nd/rd/th) frame would result in 71 images.</span></pre><p id="a4bd" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">最后一步，我们提取图像:</p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="ff30" class="nf lx jl mw b gy ng nh l ni nj">fe.extract_frames(every_x_frame=1000, <br/>                  img_name='megaman', <br/>                  dest_path='megaman_images')</span><span id="ec8c" class="nf lx jl mw b gy nk nh l ni nj"># Created the following directory: megaman_images</span></pre><p id="378b" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">在使用<code class="fe mt mu mv mw b">extract_frames</code>方法之前，指定的目录并不存在，所以它是自动创建的，我们看到了一个打印的声明来确认这一点。</p><p id="7cac" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">最后，我们定义了一个查看下载图像的简短函数:</p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="db2c" class="nf lx jl mw b gy ng nh l ni nj">def show_image(path):<br/>    image = cv2.imread(path)<br/>    plt.imshow(image)<br/>    plt.show()</span><span id="0dfe" class="nf lx jl mw b gy nk nh l ni nj">show_image('megaman_images/megaman_61.jpg')</span></pre><p id="8217" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">运行该代码会导致显示下图:</p><figure class="mx my mz na gt ix gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/4880b9c773fee04a96650807a81b76af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*w2tAG4saKn-nUC3HLIilLQ.png"/></div><p class="je jf gj gh gi jg jh bd b be z dk translated">图片来自接近比赛结束的时候:)</p></figure><h1 id="3306" class="lw lx jl bd ly lz ma mb mc md me mf mg kr mh ks mi ku mj kv mk kx ml ky mm mn bi translated">结论</h1><p id="5002" class="pw-post-body-paragraph la lb jl lc b ld mo km lf lg mp kp li lj mq ll lm ln mr lp lq lr ms lt lu lv io bi translated">在本文中，我描述了如何使用<code class="fe mt mu mv mw b">pytube3</code>库从 YouTube 下载视频，并编写了一个自定义类，用于从下载的视频中提取帧作为图像。对该类的一个潜在修改是考虑到跳过视频的第一个<em class="nl"> n </em>秒，因为开头通常包含标题屏幕、公司徽标等。在视频的结尾也可以这样做。然而，就目前而言，我们也可以通过手动删除对我们没有用处的图像来解决这个问题。</p><p id="315e" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">你可以在我的<a class="ae ji" href="https://github.com/erykml/medium_articles/blob/master/Computer%20Vision/downloading_youtube_videos.ipynb" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到本文使用的代码。一如既往，我们欢迎任何建设性的反馈。你可以在推特上或者评论里联系我。</p><p id="ad12" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">喜欢这篇文章吗？成为一个媒介成员，通过无限制的阅读继续学习。如果你使用<a class="ae ji" href="https://eryk-lewinson.medium.com/membership" rel="noopener">这个链接</a>成为会员，你将支持我，不需要你额外付费。提前感谢，再见！</p></div><div class="ab cl od oe hz of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="io ip iq ir is"><p id="7ed6" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">我最近出版了一本关于使用 Python 解决金融领域实际任务的书。如果你有兴趣，我在<a class="ae ji" rel="noopener" target="_blank" href="/introducing-my-book-python-for-finance-cookbook-de219ca0d612">贴了一篇文章</a>介绍这本书的内容。你可以在亚马逊或者 Packt 的网站上买到这本书。</p></div></div>    
</body>
</html>