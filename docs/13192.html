<html>
<head>
<title>Model Validation in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中的模型验证</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/model-validation-in-python-95e2f041f78c?source=collection_archive---------29-----------------------#2020-09-10">https://towardsdatascience.com/model-validation-in-python-95e2f041f78c?source=collection_archive---------29-----------------------#2020-09-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7b76" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">应用训练/测试分割、折叠，并省略一个</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/50d43ae3c19ac264a7d7460773ab2b61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wSekzwdSAELpQW6qETGu9g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://www.pexels.com/photo/architecture-black-and-white-challenge-chance-277593/" rel="noopener ugc nofollow" target="_blank">像素</a>上的<a class="ae ky" href="https://www.pexels.com/@pixabay" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>拍摄</p></figure><p id="dad9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Scikit-learn 是一个开源的机器学习库，提供了构建、训练和测试模型的工具。模型选择模块具有许多对模型测试和验证有用的功能。在本帖中，我们将讨论 scikit-learn 中一些重要的模型选择功能。</p><p id="c62f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们开始吧！</p><p id="31e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出于我们的目的，我们将使用葡萄酒评论数据集，该数据集可以在<a class="ae ky" href="https://www.kaggle.com/zynicide/wine-reviews" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="0401" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们将数据读入熊猫数据框:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="a1f5" class="ma mb it lw b gy mc md l me mf">import pandas as pd<br/>df = pd.read_csv("winemag-data-130k-v2.csv")</span></pre><p id="9a40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们打印前五行数据:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="2123" class="ma mb it lw b gy mc md l me mf">print(df.head())</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mg"><img src="../Images/fe32a4c90f0319c432392f6cdf57e3ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*STX08p3mwei17fkR.png"/></div></div></figure><p id="27ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们考虑基于品种、酒厂、国家和评论点预测葡萄酒价格是否比 50 美元更贵的任务。我们可以构建一个随机的森林分类器来执行这项任务。首先，让我们将分类特征转换成可由随机森林处理的分类代码:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="6cf7" class="ma mb it lw b gy mc md l me mf">df['country_cat'.format(i)] = df['country'].astype('category').copy()<br/>df['country_cat'.format(i)] = df['country_cat'.format(i)].cat.codes</span><span id="e4d6" class="ma mb it lw b gy mh md l me mf">df['winery_cat'.format(i)] = df['winery'].astype('category').copy()<br/>df['winery_cat'.format(i)] = df['winery_cat'.format(i)].cat.codes</span><span id="fc5c" class="ma mb it lw b gy mh md l me mf">df['variety_cat'.format(i)] = df['variety'].astype('category').copy()<br/>df['variety_cat'.format(i)] = df['variety_cat'.format(i)].cat.codes</span></pre><p id="b30b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们也估算缺失值。我们在这里不做任何花哨的估算，但是看看用 Python  预测缺失值的<a class="ae ky" rel="noopener" target="_blank" href="/predicting-missing-values-with-python-41e581511117">，这是一种更可靠的估算方法。这里，让我们用 0 替换丢失的值:</a></p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="a312" class="ma mb it lw b gy mc md l me mf">df.fillna(0, inplace=True)</span></pre><p id="b18d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们根据价格值是否大于或等于$50，为它们分配二进制标签。超过 50 美元的葡萄酒有“1”的标签，否则为“0”:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="77f7" class="ma mb it lw b gy mc md l me mf">df['price_class']=np.where(df['price']&gt;=50,1,0)</span></pre><p id="90ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们定义我们的功能和目标:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="a611" class="ma mb it lw b gy mc md l me mf">X = np.array(df[['country_cat', 'winery_cat', 'variety_cat', 'points']])<br/>y = np.array(df['price_class'])</span></pre><h2 id="e8f2" class="ma mb it bd mj mk ml dn mm mn mo dp mp li mq mr ms lm mt mu mv lq mw mx my mz bi translated">训练/测试分割</h2><p id="0c77" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">我们将讨论的第一个函数是“train_test_split()”方法。这个函数将数组或矩阵分成随机训练和测试子集。让我们从 scikit-learn 导入这个函数:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="d934" class="ma mb it lw b gy mc md l me mf">from sklearn.model_selection import train_test_split</span></pre><p id="542e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了将我们的功能划分为培训和测试，我们执行以下操作:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="7035" class="ma mb it lw b gy mc md l me mf">X_train, X_test, y_train, y_test = train_test_split(X,y)</span></pre><p id="1b93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认测试大小为 0.25。您还可以更改训练/测试分割的大小。例如，要将测试大小更改为 0.3，我们需要执行以下操作:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="9a13" class="ma mb it lw b gy mc md l me mf">X_train, X_test, y_train, y_test = train_test_split(X,y, test_size = 0.3)</span></pre><p id="16e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们可以训练和测试我们的随机森林模型:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="e4f7" class="ma mb it lw b gy mc md l me mf">from sklearn.ensemble import RandomForestClassifier<br/>model = RandomForestClassifier()<br/>model.fit(X_train, y_train)<br/>y_pred = model.predict_proba(X_test)</span></pre><p id="036d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们评估接收器工作特性曲线(AUROC)下的面积:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="289d" class="ma mb it lw b gy mc md l me mf">from sklearn.metrics import roc_auc_score<br/>from sklearn.metrics import roc_curve, auc<br/>fpr, tpr, _ = roc_curve(y_test, y_pred)<br/>roc_auc = auc(fpr, tpr)</span></pre><p id="0bf4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并绘制 ROC:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="5eed" class="ma mb it lw b gy mc md l me mf">import matplotlib.pyplot as plt<br/>import seaborn as sns<br/>sns.set()<br/>plt.figure()<br/>lw = 2<br/>plt.plot(fpr, tpr, color='red',<br/>         lw=lw, label='ROC curve (area = %0.2f)' % roc_auc)<br/>plt.plot([0, 1], [0, 1], color='navy', lw=lw, linestyle='--')<br/>plt.xlim([0.0, 1.0])<br/>plt.ylim([0.0, 1.05])<br/>plt.xlabel('False Positive Rate')<br/>plt.ylabel('True Positive Rate')<br/>plt.title('Receiver operating characteristic for Wine Price Classification')<br/>plt.legend(loc="lower right")<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/8c0fcb1f8e8067a030da92df83151681.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cZiUty-qUE-YVzuYkGabzA.png"/></div></div></figure><p id="e08b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以看看精度/召回曲线和平均精度:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="c309" class="ma mb it lw b gy mc md l me mf">precision, recall, _ = precision_recall_curve(y_test,y_pred)<br/>average_precision = average_precision_score(y_test, y_pred)</span><span id="2d6c" class="ma mb it lw b gy mh md l me mf">sns.set()<br/>plt.figure()<br/>plt.step(recall, precision, where='post')</span><span id="4d29" class="ma mb it lw b gy mh md l me mf">plt.xlabel('Recall')<br/>plt.ylabel('Precision')<br/>plt.ylim([0.0, 1.05])<br/>plt.xlim([0.0, 1.0])<br/>plt.title(<br/>    'Average precision score Wine Price Classification, micro-averaged over all classes: AP={0:0.2f}'<br/>    .format(average_precision)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/7d2f456122af6f274484a51da2ca1d37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hAhggKTFRrGnlHV9PuOOlA.png"/></div></div></figure><h2 id="0a1e" class="ma mb it bd mj mk ml dn mm mn mo dp mp li mq mr ms lm mt mu mv lq mw mx my mz bi translated">k 倍交叉验证</h2><p id="f73d" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">接下来让我们讨论“KFold”方法。该函数提供训练和测试索引，将数据分成训练和测试集。它将数据随机或连续(默认)分成<em class="mi"> K </em>个折叠，每个折叠用于一次验证，而其余 k-1 个折叠构成训练集。我们将使用折叠数的默认值，即 5。让我们初始化一个“KFold”对象，获取数据分割，并初始化预测目标值和真实目标值的数组:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="d740" class="ma mb it lw b gy mc md l me mf">from sklearn.model_selection import KFold<br/>folds = KFold()<br/>folds.get_n_splits(df)<br/>y_true  = []<br/>y_pred = []</span></pre><p id="91c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想将折叠数从 5 改为 10，我们可以这样做:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="673c" class="ma mb it lw b gy mc md l me mf">folds = KFold(n_splits=10)</span></pre><p id="43a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们在 for 循环中训练和测试我们的模型，并追加结果:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="781a" class="ma mb it lw b gy mc md l me mf">for train_index, test_index in folds.split(df):<br/>    df_test = df.iloc[test_index]<br/>    df_train = df.iloc[train_index]     <br/>    X_train = np.array(df_train[['country_cat', 'winery_cat', 'variety_cat', 'points']])<br/>    y_train = np.array(df_train['price_class'])<br/>    X_test = np.array(df_test[['country_cat', 'winery_cat', 'variety_cat', 'points']])<br/>    y_test = np.array(df_test['price_class'])    <br/>    y_true.append(y_test)<br/>    model = RandomForestClassifier()<br/>    model.fit(X_train, y_train)    <br/>    y_pred.append(model.predict_proba(X_test)[:,1])<br/>y_pred = [item for sublist in y_pred for item in sublist]   <br/>y_true = [item for sublist in y_true for item in sublist]</span></pre><p id="b92a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来我们绘制 ROC 曲线:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="72a5" class="ma mb it lw b gy mc md l me mf">fpr, tpr, _ = roc_curve(y_true, y_pred)<br/>roc_auc = auc(fpr, tpr)</span><span id="0f63" class="ma mb it lw b gy mh md l me mf">sns.set()<br/>plt.figure()<br/>lw = 2<br/>plt.plot(fpr, tpr, color='red',<br/>         lw=lw, label='ROC curve (area = %0.2f)' % roc_auc)<br/>plt.plot([0, 1], [0, 1], color='navy', lw=lw, linestyle='--')<br/>plt.xlim([0.0, 1.0])<br/>plt.ylim([0.0, 1.05])<br/>plt.xlabel('False Positive Rate')<br/>plt.ylabel('True Positive Rate')<br/>plt.title('Receiver operating characteristic for Wine Price Classification (KFolds)')<br/>plt.legend(loc="lower right")<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/6fd18deefd20cae9af84023df6375df3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QxzMNS8crxFPX1-YpeDBOA.png"/></div></div></figure><p id="56bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">精确度/召回率曲线:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="6254" class="ma mb it lw b gy mc md l me mf">precision, recall, _ = precision_recall_curve(y_true,y_pred)<br/>average_precision = average_precision_score(y_true, y_pred)</span><span id="1764" class="ma mb it lw b gy mh md l me mf">sns.set()<br/>plt.figure()<br/>plt.step(recall, precision, where='post')</span><span id="8415" class="ma mb it lw b gy mh md l me mf">plt.xlabel('Recall')<br/>plt.ylabel('Precision')<br/>plt.ylim([0.0, 1.05])<br/>plt.xlim([0.0, 1.0])<br/>plt.title(<br/>    'Average precision score Wine Price Classification (KFolds), micro-averaged over all classes: AP={0:0.2f}'<br/>    .format(average_precision))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/6bba80f4d85e8740ee89ac9840d04d63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rQ3pbvOa0H8xlsaYAoiYdg.png"/></div></div></figure><h2 id="a418" class="ma mb it bd mj mk ml dn mm mn mo dp mp li mq mr ms lm mt mu mv lq mw mx my mz bi translated">遗漏一个交叉验证</h2><p id="1d28" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">最后，让我们讨论一下“LeaveOneOut”方法。该功能提供训练/测试指数，以分割用于训练和测试的数据。每个样本作为单独测试使用一次，而剩余的样本用于训练。这里，我们初始化“LeaveOneOut”对象，并像以前一样获取数据拆分:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="2831" class="ma mb it lw b gy mc md l me mf">from sklearn.model_selection import LeaveOneOut<br/>loo = LeaveOneOut()<br/>loo.get_n_splits(df)<br/>y_true  = []<br/>y_pred = []</span></pre><p id="b5f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们循环遍历索引并追加结果。为清楚起见，代码被截断:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="4b08" class="ma mb it lw b gy mc md l me mf">for train_index, test_index in loo.split(df):<br/>    df_test = df.iloc[test_index]<br/>    df_train = df.iloc[train_index]<br/>    ...</span></pre><p id="1698" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来我们绘制结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/587409e00702f7b58c1b79a3065114d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lbs5lEfcwGwb1GBc9y7ZIg.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/365ffda5fed70bafadd168460c7714c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1mf7si8Bx4xptTCTZfIg0A.png"/></div></div></figure><p id="a9c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我就讲到这里，但我鼓励您自己尝试一下这些函数。</p><h2 id="1f0d" class="ma mb it bd mj mk ml dn mm mn mo dp mp li mq mr ms lm mt mu mv lq mw mx my mz bi translated">结论</h2><p id="375b" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">总之，在这篇文章中，我们讨论了如何使用模型选择模块中的函数来验证模型。首先，我们讨论了随机选择数据进行训练和测试的训练/测试分割函数。然后，我们讨论了“K-Fold”函数，它将数据分成连续或随机的折叠，用于训练和测试。最后，我们讨论了“LeaveOneOut”函数，该函数使用一个单独的样本进行测试，剩余的数据用于数据中每个样本的训练。我希望你觉得这篇文章有用/有趣。这篇文章中的代码可以在<a class="ae ky" href="https://github.com/spierre91/medium_code/blob/master/machine_learning/model_selection_python.py" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。感谢您的阅读！</p></div></div>    
</body>
</html>