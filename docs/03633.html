<html>
<head>
<title>Serial dependence in binary sequences</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">二元序列中的序列相关性</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/serial-dependence-in-binary-sequences-409c5e8f54d0?source=collection_archive---------50-----------------------#2020-04-05">https://towardsdatascience.com/serial-dependence-in-binary-sequences-409c5e8f54d0?source=collection_archive---------50-----------------------#2020-04-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9923" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用Meixner正交多项式检验序列相关性</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/55ffd656b962437732f46bb0ca5dbbac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RNc1AlBzyRUYuYlXgXP4sA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">2018 Julian Wergieluk</p></figure><p id="425a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这篇博文中，我将研究随机二进制序列中的序列(即时间)依赖现象。</p><p id="bc2f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">随机二进制序列是由随机过程产生的0和1的序列。大多数随机数生成器生成的主要输出是二进制的。二进制序列通常对随机事件的发生进行编码:</p><ul class=""><li id="ba9b" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">金融市场的极端回报。</li><li id="56c7" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">机器、服务器等的故障</li><li id="4e1b" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">金融市场风险模型中的风险价值超额指标。</li></ul><p id="3922" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在许多这样的情况下，有必要确保被跟踪的事件彼此独立地发生。例如，生产系统中事件的发生不应该使系统更容易发生事件。为此，我们需要仔细研究一下所考虑的二进制序列的依赖结构。</p><h2 id="030a" class="mf mg iq bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">概述</h2><p id="12e8" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">在这篇博文中，我将开发并测试一种评分方法，用于量化随机二进制序列中的依赖强度。Meixner依赖分数易于实现，并且基于与几何分布相关联的正交多项式。</p><p id="ef05" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">读完这篇博文，你会知道:</p><ol class=""><li id="d462" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq nd lx ly lz bi translated">如何用统计术语来表述序列相关性度量的问题。</li><li id="410c" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq nd lx ly lz bi translated">如何从几何分布中导出迈克尔逊多项式？</li><li id="5139" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq nd lx ly lz bi translated">如何计算等待时间序列的Meixner依赖分数，以量化依赖强度。</li><li id="6c6b" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq nd lx ly lz bi translated">如何使用简单的Monte-Carlo实验测试依赖性评分方法，该实验涉及具有已知依赖性结构的马尔可夫链。</li></ol><h1 id="3078" class="ne mg iq bd mh nf ng nh mk ni nj nk mn jw nl jx mq jz nm ka mt kc nn kd mw no bi translated">问题的统计公式</h1><p id="a7ed" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">给定一个随机变量序列<em class="np"> X = (X[0]，X[1]，…，X[n]) </em>取集合<em class="np"> {0，1} </em>中的值和一个概率<em class="np"> p∈(0，1) </em>，我想考察<em class="np"> X </em>的元素之间的序列依赖关系。这个调查应该基于从<em class="np"> X </em>中抽取的一个样本<em class="np"> x </em>，即一个有限的0和1序列<em class="np"> (x[0]，x[1)，...，x[n]) </em>。这是一个非常困难和深刻的问题，在这篇博文中，我将重点收集证据来支持或拒绝以下两个基本假设:</p><ol class=""><li id="f54c" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq nd lx ly lz bi translated">随机变量<em class="np">X【I】</em>具有分布Ber( <em class="np"> p </em>)(成功概率为<em class="np"> p </em>的伯努利分布)。</li><li id="a427" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq nd lx ly lz bi translated">随机变量<em class="np">X【I】</em>是独立的。</li></ol><p id="814a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们假设<em class="np"> x </em>的元素是来自一个固定伯努利随机变量<em class="np"> X[0] </em>的独立样本，那么我们可以通过计算<em class="np"> x[0]，x[1]，…，x[n] </em>的平均值来估计概率<em class="np"> p </em>。这是因为<em class="np"> X[0] </em>的期望是<em class="np"> 𝔼 X[0] = p </em>。</p><p id="1723" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了给串行相关性检测问题设置一个合适的上下文，让我注意到随机二进制序列<em class="np"> x </em>通常与具有两个状态的系统的谨慎观察相关联。如果<em class="np"> x[0] = 1 </em>，我们说“一个事件”发生在时间<em class="np"> i </em>。</p><p id="9393" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们如何检查我们的事件是否彼此独立地发生，并收集事件时间之间没有序列相关性的证据？</p><p id="db0b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们经常倾向于在不存在序列相关性的情况下看到序列相关性。典型的例子是赌场里的赌徒所经历的“好运连连”。</p><p id="387d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了根据观察结果<em class="np"> x </em>严格研究序列<em class="np"> X </em>中的序列相关性问题，我们可以看看事件之间等待时间的分布。例如序列</p><pre class="kg kh ki kj gt nq nr ns nt aw nu bi"><span id="6f8d" class="mf mg iq nr b gy nv nw l nx ny">[0, 1, 1, 0, 0, 1, 0, 0]</span></pre><p id="95c1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">产生以下等待时间序列</p><pre class="kg kh ki kj gt nq nr ns nt aw nu bi"><span id="cac1" class="mf mg iq nr b gy nv nw l nx ny">[1, 3].</span></pre><p id="0007" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">请注意，等待时间计算会丢弃事件序列<em class="np"> x </em>中的初始零和尾随零。</p><p id="8548" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了基于<em class="np"> x </em>正式定义等待时间序列<em class="np">y =(y</em>【1】<em class="np">，…，y</em>【m】)，考虑索引<em class="np">I =(I</em>【1】<em class="np">，I</em>【2】<em class="np">，…) </em>的序列，使得对于每个<em class="np"> i∈ I </em>我们有<em class="np"> x我们出发了</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/6889136671234a540410eda877bb3315.png" data-original-src="https://miro.medium.com/v2/resize:fit:616/format:webp/1*toHkbHpmd9uQ4W0nORh3vA.png"/></div></figure><p id="5392" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于同分布的伯努利随机变量序列，等待时间序列由几何分布的同分布随机变量组成。让我们仔细看看它的属性。</p><h1 id="75ae" class="ne mg iq bd mh nf ng nh mk ni nj nk mn jw nl jx mq jz nm ka mt kc nn kd mw no bi translated">几何分布</h1><p id="9c46" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">参数为p 的几何分布的概率质量函数(PMF)由下式给出</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/cfdb821393eeff939be5e67c546bbc5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:846/format:webp/1*YY5vpvnNiLheZQKpIQL7bg.png"/></div></figure><p id="7a99" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">参数为<em class="np"> p=0.1 </em>的几何分布的PMF如下。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/8614d742d0a42107eca3e5ad420563cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*G8gxVo9oFRXBJ1oO.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">参数为<em class="oc"> p=0.1的几何分布的概率质量函数</em></p></figure><p id="a72e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">测试等待时间序列是否遵循几何分布的一种方法是查看由该分布生成的<em class="np">正交多项式</em>。</p><p id="d64d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一族正交多项式与<em class="np"> ℝ </em>上的每个概率分布<em class="np"> μ </em>密切相关。对于任何这样的分布，我们可以将(平方可积)实值函数<em class="np"> f </em>和<em class="np"> g </em>之间的标量积定义为</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi od"><img src="../Images/f3c276db7570c2e99f4d14c5e7c69d6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*Pr53GDAh0teBGi68i8UZKg.png"/></div></figure><p id="08a1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">其中<em class="np"> Y </em>是分布为<em class="np"> μ </em>的随机变量。对于几何分布，上述标量积采用以下形式</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/e54f6f28ff432a16600caf8c3f202d68.png" data-original-src="https://miro.medium.com/v2/resize:fit:634/format:webp/1*l-djfloUTTgzia5K-SMvqw.png"/></div></figure><p id="95ef" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们说函数<em class="np"> f </em>和<em class="np"> g </em>正交(相对于<em class="np"> μ </em>)当且仅当<em class="np"> ⟨f,g⟩ = 0。</em></p><p id="7b33" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，一个多项式序列<em class="np"> (q[i]) </em>与<em class="np"> i≥ 0 </em>称为正交，当且仅当，对于所有的<em class="np"> k ≠ i </em>，q[i]⟩ = 0 ，每个<em class="np">q[I】</em>都有度<em class="np"> i </em>。因此，对于<em class="np"> i &gt; 0 </em>，我们得到<em class="np"> 𝔼 q[i](Y) = 0 </em>。这是我将要用来检查给定的<em class="np"> Y </em>是否遵循几何分布的工具。</p><p id="c9ad" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对应于几何分布的正交多项式族<em class="np"> M = (M[i](y)) </em>是由负二项分布(几何分布的推广)导出的<em class="np"> Meixner族</em>的特例。Meixner家族的成员满足以下方便的递归关系:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi of"><img src="../Images/6d4db6cece7c44471ba515b84858c6bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*JH_74DFvdmU16OVlH-USqQ.png"/></div></figure><p id="3a15" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">用<em class="np"> M[1](y) = 1 </em>和<em class="np"> M[-1](y) = 0 </em>。该关系用于计算序列<em class="np"> M </em>。另外，请注意<em class="np"> M[k] </em>取决于参数<em class="np"> p </em>的值。</p><p id="9983" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在配套的python <a class="ae og" href="https://www.wergieluk.com/binary-sequences/meixner.py" rel="noopener ugc nofollow" target="_blank">源代码</a>中，函数<code class="fe oh oi oj nr b">meixner_poly_eval</code>用于在给定的点集上计算Meixner多项式到给定的次数。我用这个函数画出了这些多项式的55次曲线。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/80757c203bb9a1c336a8e0d76b479bdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fwNT0FXT3X3vkS22.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">p=0.1到55度的Meixner正交多项式的图</p></figure><p id="2629" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如上所述，对于每个多项式<em class="np">M【k】(y)</em>在<em class="np"> M </em>中的等式</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/0c639f8cdad746d8e11fb3e95d4841f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:264/format:webp/1*qfGul_YsZ61lih1ZjOrclA.png"/></div></figure><p id="a312" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当且仅当<em class="np"> Y∈ </em> Geom( <em class="np"> p </em>)和<em class="np"> k &gt; 0 </em>成立。</p><p id="9c5e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个关系可以用来检验给定的等待时间样本是否属于参数为<em class="np"> p </em>的几何分布。我们将估计期望值<em class="np"> 𝔼 M[k](Y) </em>并将估计值用作分数:接近零的值可以解释为参数为<em class="np"> p </em>的几何分布的证据。如果值远离零，这是一个信号，表明我们需要重新考虑我们的假设，并可能放弃关于原始事件序列的i.i.d .假设。注意，如果事件是独立的，也可能出现与零的显著偏差，但是真实概率<em class="np">p’</em>与假定的<em class="np"> p </em>显著不同。如前所述，这很容易测试。</p><h1 id="e87c" class="ne mg iq bd mh nf ng nh mk ni nj nk mn jw nl jx mq jz nm ka mt kc nn kd mw no bi translated">Meixner依赖分数</h1><p id="31e3" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">为了获得在上述意义上量化串行相关性程度的单个数字(分数)，我们将定义<em class="np"> Meixner相关性分数(MDS) </em>作为在等待时间<em class="np"> y=(y[1】的样本上评估的第一个<em class="np"> k </em> Meixner多项式的期望估计的平均值，..，y[m]) </em>:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/38bb55f139b02dd6af08f7a97a627f9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:532/format:webp/1*VumzlIlIgd6nLcqhbZzLeQ.png"/></div></figure><p id="542f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用正交多项式来测试二进制序列中依赖结构假设的思想源于矩推断方法，并在金融文献中被发展用于回溯测试风险值模型。在这篇博客文章中，我采用了Candelon等人提出的方法，请参见下面的参考资料部分。</p><h1 id="3b38" class="ne mg iq bd mh nf ng nh mk ni nj nk mn jw nl jx mq jz nm ka mt kc nn kd mw no bi translated">蒙特卡罗研究</h1><p id="ee0a" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">为了找出上面设计的过程是否有机会在实践中起作用，我将使用综合生成的数据来测试它。这种类型的测试程序通常称为蒙特卡罗(MC)研究。它不会用真实世界的数据替换测试，但可以帮助在受控环境中评估统计方法。</p><p id="fdb7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们要执行的实验包括以下步骤:</p><ol class=""><li id="a06e" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq nd lx ly lz bi translated">使用具有已知序列相关性结构的模型生成二进制序列。</li><li id="120b" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq nd lx ly lz bi translated">估计对<em class="np"> k=1，…，10 </em>的期望<em class="np"> 𝔼 M[k](X) </em>。</li><li id="e562" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq nd lx ly lz bi translated">在大量独立试验中重复第1步和第2步，并将汇总结果可视化。</li></ol><p id="1336" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们从一个简单的例子开始，用成功概率<em class="np"> p[0] </em>来模拟伯努利随机变量的i.i.d序列。这可以用作健全性检查，并测试我们的过程实现是否正确。</p><p id="96c7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于下面的实验，我们设置<em class="np"> p[0] = 0.05 </em>并模拟来自<em class="np"> X = (X[1])的5000个样本，..，X[1000]) </em>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi om"><img src="../Images/2c5f8e25ad331ed551e904c0f5cb33c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*wXa2k11L7mjYxOQc.png"/></div></figure><p id="800a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于一个具有简单形式的序列相关性的模型，我们选择概率<em class="np">0&lt;p[1]&lt;p[0]&lt;p[2]&lt;1</em>，并设置序列<em class="np">中随机变量的分布X = (X[0]，X[1]，X[2]，…) </em>如下。让<em class="np"> X[0] </em>为伯努利，成功概率<em class="np"> p[0] </em>。<em class="np"> X[i] </em>对于<em class="np"> i &gt; 0 </em>的分布以<em class="np"> X[i-1] </em>为条件:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi on"><img src="../Images/2fc7fa39e65e1a9835ceee3d4dbe1489.png" data-original-src="https://miro.medium.com/v2/resize:fit:494/format:webp/1*6Qi9U8a4bUaqXdGja7Q45g.png"/></div></figure><p id="2c3c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了将该模型与具有成功概率<br/>的I . I . Bernoulli模型<em class="np"> p[0] </em>进行比较，我们需要设置<em class="np"> p[1] </em>和<em class="np"> p[2] </em>，使得<em class="np"> X[i] </em>的无条件<br/>分布为Ber <em class="np"> (p[0]) </em>。</p><p id="56b5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">换句话说，对于给定的<em class="np">0&lt;P[1]&lt;P[0]&lt;1</em>，我们寻找的是<em class="np">P[2]∑(0，1) </em>，使得上述定义的随机二进制序列满足<em class="np"> P(X[i] = 1) = p[0] </em>。<br/>这个二元序列可以用状态空间{0，1}表示为简单的马尔可夫链，转移概率矩阵<em class="np"> P </em>由下式给出</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/c4217299a2aef928fc68c238fa07f67c.png" data-original-src="https://miro.medium.com/v2/resize:fit:286/format:webp/1*TX4LBk_W3oej6ucSOhKs-w.png"/></div></figure><p id="3ea3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">而初始分布<em class="np"> λ = (1-p[0]，p[0]) </em>。<em class="np"> X[i] </em>的边际分布由下式给出</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi op"><img src="../Images/eccd22c2c23b5ed7640c424ab30908af.png" data-original-src="https://miro.medium.com/v2/resize:fit:90/format:webp/1*_-uyMjKbldgssN0QZL0Emg.png"/></div></figure><p id="e8c9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个基本结果可以在任何一本关于马氏链的书中找到(参见下面的参考资料部分)。找到一个<em class="np"> p[2] </em>使得<em class="np"> P(X[i] = 1) </em>尽可能接近<em class="np"> p[0] </em>的任务，可以用现成的优化算法，例如<a class="ae og" href="https://docs.scipy.org/doc/scipy/reference/optimize.minimize-bfgs.html" rel="noopener ugc nofollow" target="_blank"> BFGS </a>很容易地解决。</p><p id="5534" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">例如，对于<em class="np"> p[1] = 0.02 </em>和<em class="np"> p[0] = 0.05 </em>，上述过程很快得出<em class="np"> p[2] = 0.62 </em>。</p><h2 id="7916" class="mf mg iq bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">蒙特卡罗研究结果</h2><p id="8389" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">让我们测试下面的值<em class="np"> p[1] </em>和<em class="np"> p[2] </em>的依赖评分算法。Meixner多项式的MC评估产生以下Meixner相关性分数:</p><pre class="kg kh ki kj gt nq nr ns nt aw nu bi"><span id="f9c0" class="mf mg iq nr b gy nv nw l nx ny">+------+------+-------+<br/>|  p1  |  p2  |  MDS  |<br/>+------+------+-------+<br/>| 0.5, |  0.5 | 0.083 |<br/>|  0.4 | 0.24 | 0.194 |<br/>|  0.3 | 0.43 | 0.382 |<br/>|  0.2 | 0.62 | 0.583 |<br/>+------+------+-------+</span></pre><p id="b1cf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">同样，对长度为1000的样本的5000次模拟产生了下面的期望估计直方图。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi om"><img src="../Images/fa554d4bdb202001473cba349f21f90d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*nhQX9qM69ejd1lxN.png"/></div></figure><p id="8aaa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">正如我们所见，直方图略微向左偏移。</p><p id="b214" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这篇博文中展示的所有结果和图表都是使用以下Python脚本生成的:<a class="ae og" href="https://www.wergieluk.com/binary-sequences/meixner.py" rel="noopener ugc nofollow" target="_blank"> meixner.py </a></p><h1 id="253f" class="ne mg iq bd mh nf ng nh mk ni nj nk mn jw nl jx mq jz nm ka mt kc nn kd mw no bi translated">结束语</h1><p id="2058" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">在这篇博文中，我们了解了二进制序列中的序列相关性的概念。我们基于Meixner正交多项式实现了一种串行依赖性检测方法，Meixner依赖性得分，并使用简单的马尔可夫链模型测试了它的性能。</p><p id="25d7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">依赖性测试的一个重要财务用例是分析由市场风险模型生成的风险价值超出事件序列。市场风险模型广泛用于银行业的监管资本要求计算，以及资产管理行业的投资组合构建和风险管理。</p><p id="feef" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae og" href="https://en.wikipedia.org/wiki/Value_at_risk" rel="noopener ugc nofollow" target="_blank">风险价值</a> (Var)是固定时间范围内金融资产价格损失分布的分位数。例如，持有黄金多头头寸的投资者可能对美元黄金价格在一天时间范围内的95% VaR感兴趣。对于校准良好的风险值模型，在一个投资期内观察到的5%营业日的极端损失将超过95%的风险值分数。VaR超过事件不仅必须以预期的频率发生，还必须相互独立。对市场风险模型进行适当校准，将超出事件的相关性降低到较低水平，通常比超出频率的简单校准要困难得多。但这在金融危机时期尤为重要，因为低估风险不可避免地会导致投机倒把，甚至可能导致更严重的损失。</p><p id="0342" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">非常感谢Sarah Khatry阅读了这篇博文的草稿，并提供了无数的改进意见和更正。</p><h1 id="4752" class="ne mg iq bd mh nf ng nh mk ni nj nk mn jw nl jx mq jz nm ka mt kc nn kd mw no bi translated">参考</h1><ul class=""><li id="0a8f" class="lr ls iq kx b ky my lb mz le oq li or lm os lq lw lx ly lz bi translated">Bertrand Candelon，Gilbert Colletaz，Christophe Hurlin，Sessi Tokpavi，<a class="ae og" href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.404.3188&amp;rep=rep1&amp;type=pdf" rel="noopener ugc nofollow" target="_blank">回测风险价值:基于GMM持续期的测试</a> (2011)，《金融计量经济学杂志》，第9卷，第2期，2011年春季</li><li id="424e" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">弗兰克·WJ·奥尔弗、丹尼尔·w·洛兹尔、罗纳德·f·博伊斯维特和查尔斯·w·克拉克编辑。，<a class="ae og" href="https://www.nist.gov/publications/nist-handbook-mathematical-functions" rel="noopener ugc nofollow" target="_blank">《NIST数学函数手册》精装本及光盘</a>，(2010)，剑桥大学出版社</li><li id="4e57" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">詹姆斯·诺里斯，<a class="ae og" href="https://doi.org/10.1017/CBO9780511810633" rel="noopener ugc nofollow" target="_blank">马尔可夫链</a> (1998)剑桥大学出版社</li><li id="84d9" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">Alexander J. McNeil、Rüdiger Frey和Paul Embrechts，<a class="ae og" href="https://press.princeton.edu/books/hardcover/9780691166278/quantitative-risk-management" rel="noopener ugc nofollow" target="_blank">量化风险管理</a> (2015)，普林斯顿大学出版社</li></ul></div></div>    
</body>
</html>