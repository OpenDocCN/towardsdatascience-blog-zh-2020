<html>
<head>
<title>NDArray — — a Java based N-Dim array toolkit</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NDArray — —一个基于 Java 的 N 维数组工具包</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/ndarray-a-java-based-n-dim-array-toolkit-60b4035b10b8?source=collection_archive---------15-----------------------#2020-08-12">https://towardsdatascience.com/ndarray-a-java-based-n-dim-array-toolkit-60b4035b10b8?source=collection_archive---------15-----------------------#2020-08-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4fc5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">DJL，一个引擎无关的深度学习库</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/3ec57ba024a26f5b0f99bd04301f3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*_-KWfrIAs4blUtrwTfPs3A.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated"><a class="ae kr" href="https://pixabay.com/illustrations/analytics-information-innovation-3088958/" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><h1 id="ade5" class="ks kt iq bd ku kv kw kx ky kz la lb lc jw ld jx le jz lf ka lg kc lh kd li lj bi translated">介绍</h1><p id="a151" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">在许多开发语言中，有一个使用 N 维数组的流行范例。它们允许您编写数字代码，否则只需几个简单的操作就可以完成许多层次的嵌套循环。由于并行化的能力，它的运行速度甚至比标准循环还要快。这现在是数据科学、图形和深度学习等许多领域的标准实践，但可以用于远远超出这一范围的应用。<br/> <br/>在 Python 中，NDArrays 的标准库叫做 NumPy。然而，在 Java 中没有等价的标准库。AWS 的<a class="ae kr" href="http://djl.ai" rel="noopener ugc nofollow" target="_blank">深度 Java 库(DJL) </a>为有兴趣使用 NDArrays 的 Java 开发者提供了一个产品。虽然它也包含深度学习，但核心是一个强大的<a class="ae kr" href="https://javadoc.io/doc/ai.djl/api/latest/ai/djl/ndarray/NDArray.html" rel="noopener ugc nofollow" target="_blank"> NDArray </a>系统，它可以单独使用，将这种范式引入 Java。借助对多个深度学习框架(PyTorch、TensorFlow、MXNet)的支持，DJL 可以允许 NDArray 操作大规模跨多个平台运行。不管你运行的是 CPU 还是 GPU，PC 还是 Android，都简单好用。<br/> <br/>在本教程中，我们将介绍如何利用 DJL 的<a class="ae kr" href="https://javadoc.io/doc/ai.djl/api/latest/ai/djl/ndarray/NDArray.html" rel="noopener ugc nofollow" target="_blank"> NDArray </a>用 Java 编写 NumPy 代码，并将 NDArray 应用到现实世界的应用程序中。</p><h1 id="1fc2" class="ks kt iq bd ku kv kw kx ky kz la lb lc jw ld jx le jz lf ka lg kc lh kd li lj bi translated">设置</h1><p id="35f3" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">您可以在 gradle 项目中使用以下配置。或者，您可以跳过设置，直接在我们的<a class="ae kr" href="https://aws-samples.github.io/djl-demo/web-demo/interactive-console/src/main/webapps/" rel="noopener ugc nofollow" target="_blank"> </a> <a class="ae kr" href="https://djl.ai/website/demo.html#jshell" rel="noopener ugc nofollow" target="_blank">交互式在线控制台</a>中尝试。</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="5718" class="ml kt iq mh b gy mm mn l mo mp">plugins {<br/>    id 'java'<br/>}<br/>repositories {                           <br/>    jcenter()<br/>}<br/>dependencies {<br/>    implementation "ai.djl:api:0.6.0"<br/>    // PyTorch<br/>    runtimeOnly "ai.djl.pytorch:pytorch-engine:0.6.0"<br/>    runtimeOnly "ai.djl.pytorch:pytorch-native-auto:1.5.0"<br/>}</span></pre><p id="13f0" class="pw-post-body-paragraph lk ll iq lm b ln mq jr lp lq mr ju ls lt ms lv lw lx mt lz ma mb mu md me mf ij bi translated">就这样，现在我们可以开始实现了。</p><h1 id="458d" class="ks kt iq bd ku kv kw kx ky kz la lb lc jw ld jx le jz lf ka lg kc lh kd li lj bi translated">基本操作</h1><p id="0aae" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">让我们首先创建一个 try 块来为我们的代码创建一个作用域(如果您使用的是交互式控制台，可以跳过这一步):</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="d384" class="ml kt iq mh b gy mm mn l mo mp">try(NDManager manager = NDManager.newBaseManager()) {<br/>}</span></pre><p id="ffa2" class="pw-post-body-paragraph lk ll iq lm b ln mq jr lp lq mr ju ls lt ms lv lw lx mt lz ma mb mu md me mf ij bi translated"><a class="ae kr" href="https://javadoc.io/doc/ai.djl/api/latest/ai/djl/ndarray/NDManager.html" rel="noopener ugc nofollow" target="_blank"> NDManager </a>帮助管理<a class="ae kr" href="https://javadoc.io/doc/ai.djl/api/latest/ai/djl/ndarray/NDArray.html" rel="noopener ugc nofollow" target="_blank">n arrays</a>的内存使用。它创造了它们，也有助于清除它们。使用完 NDManager 后，它还会清除在其作用域内创建的所有 NDArrays。NDManager 通过跟踪 NDArray 的使用情况，帮助整个系统高效地利用内存。<br/> <br/>为了比较，让我们看看 Python 的 NumPy 中的代码是什么样子。我们将从导入带有标准别名的 NumPy 库开始。</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="ea6f" class="ml kt iq mh b gy mm mn l mo mp">import NumPy as np</span></pre><p id="94fa" class="pw-post-body-paragraph lk ll iq lm b ln mq jr lp lq mr ju ls lt ms lv lw lx mt lz ma mb mu md me mf ij bi translated">在下面的部分中，我们将比较 NumPy 和 DJL 的 NDArray 的实现和结果。</p><h1 id="769e" class="ks kt iq bd ku kv kw kx ky kz la lb lc jw ld jx le jz lf ka lg kc lh kd li lj bi translated">n 阵列创建</h1><p id="1f35" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated"><code class="fe mv mw mx mh b">ones</code>是生成用 1 填充的 N 维数组的操作。<br/>数字</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="5413" class="ml kt iq mh b gy mm mn l mo mp">nd = np.ones((2, 3))<br/>```<br/>[[1. 1. 1.]<br/> [1. 1. 1.]]<br/>```</span></pre><p id="26f4" class="pw-post-body-paragraph lk ll iq lm b ln mq jr lp lq mr ju ls lt ms lv lw lx mt lz ma mb mu md me mf ij bi translated">恩达雷</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="2382" class="ml kt iq mh b gy mm mn l mo mp">NDArray nd = manager.ones(new Shape(2, 3));<br/>/*<br/>ND: (2, 3) cpu() float32<br/>[[1., 1., 1.],<br/> [1., 1., 1.],<br/>]<br/>*/</span></pre><p id="4248" class="pw-post-body-paragraph lk ll iq lm b ln mq jr lp lq mr ju ls lt ms lv lw lx mt lz ma mb mu md me mf ij bi translated">你也可以尝试随机生成。例如，我们将生成从 0 到 1 的随机均匀数据。<br/> <br/> NumPy</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="bff6" class="ml kt iq mh b gy mm mn l mo mp">nd = np.random.uniform(0, 1, (1, 1, 4))<br/># [[[0.7034806  0.85115891 0.63903668 0.39386125]]]</span></pre><p id="5e89" class="pw-post-body-paragraph lk ll iq lm b ln mq jr lp lq mr ju ls lt ms lv lw lx mt lz ma mb mu md me mf ij bi translated">恩达雷</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="9413" class="ml kt iq mh b gy mm mn l mo mp">NDArray nd = manager.randomUniform(0, 1, new Shape(1, 1, 4));<br/>/*<br/>ND: (1, 1, 4) cpu() float32<br/>[[[0.932 , 0.7686, 0.2031, 0.7468],<br/> ],<br/>]<br/>*/</span></pre><p id="821e" class="pw-post-body-paragraph lk ll iq lm b ln mq jr lp lq mr ju ls lt ms lv lw lx mt lz ma mb mu md me mf ij bi translated">这只是一些常用函数的快速演示。NDManager 现在提供了超过 20 种数组创建方法，涵盖了 NumPy 中大多数可用的方法。</p><h1 id="5999" class="ks kt iq bd ku kv kw kx ky kz la lb lc jw ld jx le jz lf ka lg kc lh kd li lj bi translated">数学运算</h1><p id="ce59" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">我们还可以使用 NDArrays 尝试一些数学运算。假设我们试图做一个<a class="ae kr" href="https://en.wikipedia.org/wiki/Transpose" rel="noopener ugc nofollow" target="_blank">转置</a>并给 NDArray 的每个元素加一个数。我们可以通过执行以下操作来实现这一点:<br/> <br/> NumPy</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="0bf0" class="ml kt iq mh b gy mm mn l mo mp">nd = np.arange(1, 10).reshape(3, 3)<br/>nd = nd.transpose()<br/>nd = nd + 10<br/>```<br/>[[11 14 17]<br/> [12 15 18]<br/> [13 16 19]]<br/>```</span></pre><p id="5995" class="pw-post-body-paragraph lk ll iq lm b ln mq jr lp lq mr ju ls lt ms lv lw lx mt lz ma mb mu md me mf ij bi translated">恩达雷</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="2cf6" class="ml kt iq mh b gy mm mn l mo mp">NDArray nd = manager.arange(1, 10).reshape(3, 3);<br/>nd = nd.transpose();<br/>nd = nd.add(10);<br/>/*<br/>ND: (3, 3) cpu() int32<br/>[[11, 14, 17],<br/> [12, 15, 18],<br/> [13, 16, 19],<br/>]<br/>*/</span></pre><p id="8376" class="pw-post-body-paragraph lk ll iq lm b ln mq jr lp lq mr ju ls lt ms lv lw lx mt lz ma mb mu md me mf ij bi translated">DJL 现在支持超过 60 种不同的 NumPy 数学方法，涵盖了大多数基本和高级数学函数。</p><h1 id="f16a" class="ks kt iq bd ku kv kw kx ky kz la lb lc jw ld jx le jz lf ka lg kc lh kd li lj bi translated">获取和设置</h1><p id="1a14" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">NDArray 最强大的特性之一是其灵活的数据索引，这是受 NumPy 中类似特性的启发。<br/> <br/>假设我们要过滤矩阵中所有小于 10 的值。<br/> <br/> NumPy</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="3f7d" class="ml kt iq mh b gy mm mn l mo mp">nd = np.arange(5, 14)<br/>nd = nd[nd &gt;= 10]<br/># [10 11 12 13]</span></pre><p id="46ea" class="pw-post-body-paragraph lk ll iq lm b ln mq jr lp lq mr ju ls lt ms lv lw lx mt lz ma mb mu md me mf ij bi translated">NDArray:</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="c21f" class="ml kt iq mh b gy mm mn l mo mp">NDArray nd = manager.arange(5, 14);<br/>nd = nd.get(nd.gte(10));<br/>/*<br/>ND: (4) cpu() int32<br/>[10, 11, 12, 13]<br/>*/</span></pre><p id="272b" class="pw-post-body-paragraph lk ll iq lm b ln mq jr lp lq mr ju ls lt ms lv lw lx mt lz ma mb mu md me mf ij bi translated">现在让我们尝试做一些更复杂的事情。假设我们有一个 3x3 的矩阵，我们想把第二列乘以 2。<br/> <br/> NumPy</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="b371" class="ml kt iq mh b gy mm mn l mo mp">nd = np.arange(1, 10).reshape(3, 3)<br/>nd[:, 1] *= 2<br/>```<br/>[[ 1  4  3]<br/> [ 4 10  6]<br/> [ 7 16  9]]<br/>```</span></pre><p id="6366" class="pw-post-body-paragraph lk ll iq lm b ln mq jr lp lq mr ju ls lt ms lv lw lx mt lz ma mb mu md me mf ij bi translated">恩达雷</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="5964" class="ml kt iq mh b gy mm mn l mo mp">NDArray nd = manager.arange(1, 10).reshape(3, 3);<br/>nd.set(new NDIndex(":, 1"), array -&gt; array.mul(2));<br/>/*<br/>ND: (3, 3) cpu() int32<br/>[[ 1,  4,  3],<br/> [ 4, 10,  6],<br/> [ 7, 16,  9],<br/>]<br/>*/</span></pre><p id="23ba" class="pw-post-body-paragraph lk ll iq lm b ln mq jr lp lq mr ju ls lt ms lv lw lx mt lz ma mb mu md me mf ij bi translated">在上面的例子中，我们在 Java 中引入了一个叫做<a class="ae kr" href="https://javadoc.io/doc/ai.djl/api/latest/ai/djl/ndarray/index/NDIndex.html" rel="noopener ugc nofollow" target="_blank"> NDIndex </a>的概念。它反映了 NumPy 支持的大多数 NDArray get/set 功能。通过简单地传递一个字符串表示，开发人员可以在 Java 中无缝地进行各种数组操作。</p><h1 id="bdb3" class="ks kt iq bd ku kv kw kx ky kz la lb lc jw ld jx le jz lf ka lg kc lh kd li lj bi translated">真实世界应用</h1><p id="030a" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">当我们需要操作一个巨大的数据集时，这些操作非常有用。让我们看一个具体的用例:令牌分类。在这种情况下，开发人员试图通过对其应用深度学习算法，对他们从用户那里收集的文本信息进行情感分析。在预处理和后处理中应用 n 阵列运算来编码和解码信息。</p><h1 id="503d" class="ks kt iq bd ku kv kw kx ky kz la lb lc jw ld jx le jz lf ka lg kc lh kd li lj bi translated">标记化</h1><p id="2bdc" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">在将数据输入到 NDArray 之前，我们将输入文本标记为数字。下面代码块中的<code class="fe mv mw mx mh b">tokenizer</code>是一个<code class="fe mv mw mx mh b">Map&lt;String, Integer&gt;</code>，它作为一个词汇表将文本转换成相应的向量。</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="d0e9" class="ml kt iq mh b gy mm mn l mo mp">String text = "The rabbit cross the street and kick the fox";<br/>String[] tokens = text.toLowerCase().split(" ");<br/>int[] vector = new int[tokens.length];<br/>/*<br/>String[9] { "the", "rabbit", "cross", "the", "street",<br/>"and", "kick", "the", "fox" }<br/>*/<br/>for (int i = 0; i &lt; tokens.length; i++) {<br/>    vector[i] = tokenizer.get(tokens[i]);<br/>}<br/>vector<br/>/*<br/>int[9] { 1, 6, 5, 1, 3, 2, 8, 1, 12 }<br/>*/</span></pre><h1 id="eda7" class="ks kt iq bd ku kv kw kx ky kz la lb lc jw ld jx le jz lf ka lg kc lh kd li lj bi translated">处理</h1><p id="e1b3" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">之后，我们创建一个<code class="fe mv mw mx mh b">NDArray</code>。为了进一步进行，我们需要创建一批令牌，并对它们应用一些转换。</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="ed0f" class="ml kt iq mh b gy mm mn l mo mp">NDArray array = manager.create(vector);<br/>array = array.reshape(new Shape(vector.length, 1)); // form a batch<br/>array = array.div(10.0);<br/>/*<br/>ND: (9, 1) cpu() float64<br/>[[0.1],<br/> [0.6],<br/> [0.5],<br/> [0.1],<br/> [0.3],<br/> [0.2],<br/> [0.8],<br/> [0.1],<br/> [1.2],<br/>]<br/>*/</span></pre><p id="f759" class="pw-post-body-paragraph lk ll iq lm b ln mq jr lp lq mr ju ls lt ms lv lw lx mt lz ma mb mu md me mf ij bi translated">然后，我们可以将这些数据发送给深度学习模型。用纯 Java 实现同样的事情需要更多的工作。如果我们试图实现上面的整形函数，我们需要在 Java 中创建一个 N 维数组，看起来像:<code class="fe mv mw mx mh b">List&lt;List&lt;List&lt;...List&lt;Float&gt;...&gt;&gt;&gt;</code>来覆盖所有不同的维度。然后，我们必须动态地插入一个新的包含元素的<code class="fe mv mw mx mh b">List&lt;Float&gt;</code>来构建结果数据结构。</p><h1 id="f779" class="ks kt iq bd ku kv kw kx ky kz la lb lc jw ld jx le jz lf ka lg kc lh kd li lj bi translated">为什么要用 NDArray？</h1><p id="4006" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">通过前面的演练，您应该有了在 Java 中使用 NDArray 的基本经验。总而言之，使用它有三个主要优势:</p><ul class=""><li id="db95" class="my mz iq lm b ln mq lq mr lt na lx nb mb nc mf nd ne nf ng bi translated">简单:通过简单的输入和相同的输出访问 60 多个 Java 操作符。</li><li id="fe8d" class="my mz iq lm b ln nh lq ni lt nj lx nk mb nl mf nd ne nf ng bi translated">快速:完全支持最常用的深度学习框架，包括 TensorFlow、PyTorch 和 MXNet。现在，你可以让你的计算在 CPU 上被 MKLDNN 加速，在 GPU 上被 CUDA 加速等等。</li><li id="b1df" class="my mz iq lm b ln nh lq ni lt nj lx nk mb nl mf nd ne nf ng bi translated">深度学习就绪:支持高维数组和稀疏 n 数组输入*。您可以在所有平台上应用这个工具包，包括 Apache Spark 和 Apache Beam，用于大规模数据处理。它是数据预处理和后处理的完美工具。</li></ul><p id="3c59" class="pw-post-body-paragraph lk ll iq lm b ln mq jr lp lq mr ju ls lt ms lv lw lx mt lz ma mb mu md me mf ij bi translated">*Sparse 目前仅涵盖 PyTorch 中的首席运营官和 MXNet 中的 CSR/Row_Sparse。</p><h1 id="e5e2" class="ks kt iq bd ku kv kw kx ky kz la lb lc jw ld jx le jz lf ka lg kc lh kd li lj bi translated">关于恩达里和 DJL</h1><p id="9871" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">在尝试了 NDArray 的创建和操作之后，你可能想知道 DJL 是如何实现 NDArray 来实现这些行为的。在本节中，我们将简要介绍 NDArray 的体系结构。</p><h1 id="30d9" class="ks kt iq bd ku kv kw kx ky kz la lb lc jw ld jx le jz lf ka lg kc lh kd li lj bi translated">NDArray 建筑</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/ec1d223ed021a1938eea01e088d81733.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/1*Cbxg59MeDE0F3Ud59dc4Ng.png"/></div></figure><p id="a40e" class="pw-post-body-paragraph lk ll iq lm b ln mq jr lp lq mr ju ls lt ms lv lw lx mt lz ma mb mu md me mf ij bi translated">如上所示，NDArray 有三个关键层。接口层包含 NDArray，它是一个 Java 接口，定义了 NDArray 应该是什么样子。我们仔细评估了它，并使所有函数的签名足够通用和易于使用。<br/> <br/>在 EngineProvider 层，有不同引擎对 NDArray 的实现。这一层充当解释层，将引擎特定的行为映射到 NumPy 行为。因此，所有引擎实现的行为方式都与 NumPy 相同。<br/> <br/>在 C++层，我们构建了 JNI 和 JNA 这两个公开 C++方法供 Java 调用。这将确保我们有足够的方法来构建整个 NDArray 堆栈。此外，由于所有引擎都是在 C/C++中实现的，因此它通过直接从 Java 调用 C++来确保最佳性能。</p><h1 id="f291" class="ks kt iq bd ku kv kw kx ky kz la lb lc jw ld jx le jz lf ka lg kc lh kd li lj bi translated">关于 DJL</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="no np di nq bf nr"><div class="gh gi nn"><img src="../Images/97c336dd5c4ef65780ffefd51e9aa4eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*al2fwHdh_kFRWY-7sN6iRQ.png"/></div></div></figure><p id="6427" class="pw-post-body-paragraph lk ll iq lm b ln mq jr lp lq mr ju ls lt ms lv lw lx mt lz ma mb mu md me mf ij bi translated"><a class="ae kr" href="https://djl.ai" rel="noopener ugc nofollow" target="_blank">深度 Java 库(DJL) </a>是一个用 Java 编写的深度学习框架，同时支持训练和推理。DJL 建立在现代深度学习框架(TenserFlow、PyTorch、MXNet 等)之上。您可以轻松地使用 DJL 来训练您的模型或部署您喜爱的模型从各种引擎，没有任何额外的转换。它包含一个强大的 ModelZoo 设计，允许您管理训练好的模型并在一行中加载它们。内置的 ModelZoo 目前支持来自 GluonCV、HuggingFace、TorchHub 和 Keras 的 70 多个预训练和随时可用的模型。NDArray 的加入使 DJL 成为 Java 中运行深度学习应用程序的最佳工具包。它可以自动识别您运行的平台，并判断是否利用 GPU 来运行您的应用程序。<br/> <br/>从最新发布的版本来看，DJL 0.6.0 正式支持 MXNet 1.7.0、PyTorch 1.5.0 和 TensorFlow 2.2.0。我们在 Android 上也有 PyTorch 的实验支持。<br/> <br/>关注我们的<a class="ae kr" href="https://github.com/awslabs/djl/tree/master/docs" rel="noopener ugc nofollow" target="_blank"> GitHub </a>、<a class="ae kr" href="https://github.com/aws-samples/djl-demo" rel="noopener ugc nofollow" target="_blank">演示库</a>、<a class="ae kr" href="https://join.slack.com/t/deepjavalibrary/shared_invite/zt-ar91gjkz-qbXhr1l~LFGEIEeGBibT7w" rel="noopener ugc nofollow" target="_blank"> Slack channel </a>和<a class="ae kr" href="https://twitter.com/deepjavalibrary" rel="noopener ugc nofollow" target="_blank"> twitter </a>获取更多文档和 DJL 的例子！</p></div></div>    
</body>
</html>