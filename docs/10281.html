<html>
<head>
<title>Advanced SQLAlchemy Features You Need To Start Using</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您需要开始使用的高级 SQLAlchemy 功能</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/advanced-sqlalchemy-features-you-need-to-start-using-e6fc1ddafbdb?source=collection_archive---------9-----------------------#2020-07-20">https://towardsdatascience.com/advanced-sqlalchemy-features-you-need-to-start-using-e6fc1ddafbdb?source=collection_archive---------9-----------------------#2020-07-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6a84" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过 SQLAlchemy 及其混合属性、嵌套查询、表元数据、方言等等，在 Python 中使用 SQL 变得很容易！</h2></div><p id="c244" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您是 Python 开发人员，并且使用 SQL 数据库，那么 SQLAlchemy 很可能是您熟悉的库。这是一个强大而灵活的工具包，用于在 Python 中使用 SQL，具有很多特性。像 ORM 和基本查询这样的一些特性是众所周知的，但是有相当多的特性你可能不知道，并且绝对应该加以利用。因此，让我们看看如何利用混合属性、嵌套查询、表元数据、方言等等！</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/45a7fe192b528a25d77fef0331756db1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jLE0ROnqoOVjb2mYudAIrQ.jpeg"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">西蒙·维亚尼在<a class="ae lu" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的原始照片</p></figure><h1 id="d8e3" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">列属性</h1><p id="8056" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">让我们从简单的开始。我认为您可能希望基于其他列创建映射属性是很常见的——本质上是创建计算列。最简单的例子是字符串串联:</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="1c9c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这很好，但是当我们使用 SQL 表达式来创建这样的属性时，它更有用:</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="d1df" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于上面的例子，我们增加了一些代码。我们创建了与<code class="fe mu mv mw mx b">User</code>有<em class="my">多对一</em>关系的<code class="fe mu mv mw mx b">CreditCard</code>类。这个用户——在第一个例子的列和属性之上——还有一个名为<code class="fe mu mv mw mx b">has_credit_card</code>的列属性，它是通过检查带有用户 ID 的信用卡是否存在来计算的。</p><p id="05c0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用该特性时，有一点需要注意，即在提交会话之前不会填充列属性，这在处理新创建的记录时可能是意外的:</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h1 id="3231" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">混合属性</h1><p id="2840" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">继续上一个技巧，让我也向您展示一下<em class="my">混合属性</em>。它们类似于列属性，因为它们产生<em class="my">计算属性</em>。然而，混合属性从实例级的 Python 表达式和类级的 SQL 表达式中产生值。有点困惑？好吧，让我们看一个例子:</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="a7c7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了展示<code class="fe mu mv mw mx b">hybrid_property</code>的能力，我们实现了<code class="fe mu mv mw mx b">User</code>和<code class="fe mu mv mw mx b">Order</code>之间的简单关系，其中每个用户都有一个包含<code class="fe mu mv mw mx b">.state</code>的订单列表——在这种情况下，要么是<em class="my">待定</em>要么是<em class="my">完成</em>。现在，如果我们想知道用户是否有任何<em class="my">未决的</em>订单，我们需要考虑两种情况——如果我们正在处理已经加载到 Python 对象中的行，那么我们可以只使用 Python 表达式并产生 Python 值(<code class="fe mu mv mw mx b">has_pending_orders(self)</code>)。另一方面，如果我们直接从数据库中查询这些信息，我们不能使用 Python 表达式，因为数据库引擎不能理解它。因此，对于这种情况(<code class="fe mu mv mw mx b">has_pending_orders(cls)</code>)，我们编写 SQL 表达式，可以针对数据库运行。</p><p id="98d6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">顺便提一下——如果 Python 和 SQL 评估的表达式相同，那么可以省略用<code class="fe mu mv mw mx b">.expression</code>修饰的第二个函数，SQLAlchemy 将在两种情况下使用第一个函数。</p><h1 id="5cd9" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">混合蛋白</h1><p id="4c12" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">我最喜欢的特性之一是混合类。Mixins 不仅仅是 SQLAlchemy 特有的东西，但是它们在与 ORM 模型结合时特别有用。您经常会遇到这样的情况，您有多个类(模型)需要相同的属性或相同的<code class="fe mu mv mw mx b">classmethod</code>。下面的<code class="fe mu mv mw mx b">User</code>模型就是这样一个例子:</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="c1e0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个例子中，我们有 2 个<em class="my"> Mixin </em>类，它们是<code class="fe mu mv mw mx b">User</code>模型继承的。首先- <code class="fe mu mv mw mx b">MixinAsDict</code>提供了方法<code class="fe mu mv mw mx b">as_dict(self)</code>，可以用来获得模型的<code class="fe mu mv mw mx b">dict</code>表示。另一个<code class="fe mu mv mw mx b">MixinGetByUsername</code>既提供了<code class="fe mu mv mw mx b">username</code>列，也提供了通过用户名查询用户的静态方法。</p><p id="ff4d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将这些函数定义为<em class="my"> Mixins </em>允许我们重用它们，并将它们添加到其他模型中，而无需到处复制粘贴相同的代码。</p><p id="c7d4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你不想自己写所有的<em class="my">mixin</em>，那么你可以看看<a class="ae lu" href="https://github.com/absent1706/sqlalchemy-mixins" rel="noopener ugc nofollow" target="_blank">https://github.com/absent1706/sqlalchemy-mixins</a>，它是一个常见 SQLAlchemy<em class="my">mixin</em>的集合。</p><h1 id="0dcc" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">使用元数据</h1><p id="90ec" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">有时，您可能需要访问表的列名，检查表上的约束，或者检查列是否可为空。所有这些都可以用<code class="fe mu mv mw mx b">MetaData()</code>类来完成:</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="30ec" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里重要的部分是代码片段底部的<code class="fe mu mv mw mx b">print</code>语句。它们中的每一个都演示了一些可以通过元数据对象访问的东西。这包括表名、列名、列类型、外键和主键以及其他约束。</p><h1 id="9976" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">配置表格</h1><p id="b1fa" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">一些数据库表可能需要更多的初始设置。例如，您可能希望包含一些检查约束、索引或指定不同的模式:</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="5c0f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所有这些都可以使用<code class="fe mu mv mw mx b">__table_args__</code> class 属性进行配置。这里，我们为 ID 列和外键约束设置了 2 个<em class="my">检查约束</em>，1 个索引。我们还打开了自动表扩展，这意味着如果我们在这个表创建之后向它添加列，那么它将被自动添加。最后，我们还指定这个表属于哪个模式。</p><h1 id="8f75" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">使用习惯方言</h1><p id="a64b" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">每个数据库引擎都有一些您可能想要利用的自定义功能。对我来说——作为一个 PostgreSQL 用户——我想使用 PostgreSQL 的一些自定义列类型。那么如何将它们与 SQLAlchemy 结合使用呢？</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="add9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码显示了一个具有 PostgreSQL <code class="fe mu mv mw mx b">UUID</code>、<code class="fe mu mv mw mx b">INT4RANGE</code>、<code class="fe mu mv mw mx b">NUMRANGE</code>、<code class="fe mu mv mw mx b">JSON</code>和<code class="fe mu mv mw mx b">ARRAY</code>列的<code class="fe mu mv mw mx b">Example</code>表。所有这些和<a class="ae lu" href="https://docs.sqlalchemy.org/en/13/dialects/postgresql.html" rel="noopener ugc nofollow" target="_blank">更多的</a>都可以从<code class="fe mu mv mw mx b">sqlalchemy.dialects.postgresql</code>导入。</p><p id="7391" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">创建包含这些类型值的行是不言自明的。但是在查询它们时，您需要使用方言和类型特定的比较器，如上面 PostgreSQL <code class="fe mu mv mw mx b">ARRAY</code>类型和<code class="fe mu mv mw mx b">.contains</code>比较器所示。</p><p id="dd4b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于像<code class="fe mu mv mw mx b">JSON</code>这样的其他类型，你也许可以将它们作为文本进行比较(使用<code class="fe mu mv mw mx b">.astext</code>)。</p><p id="6565" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了让您在创建这些查询时更轻松，我建议在创建引擎时设置<code class="fe mu mv mw mx b">echo=True</code>，这将使 SQLAchemy 将所有 SQL 查询打印到控制台中，以便您可以检查您的代码是否实际生成了正确的查询。</p><p id="3c23" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所有的方言、它们的类型和比较者都记录在<a class="ae lu" href="https://docs.sqlalchemy.org/en/13/dialects/" rel="noopener ugc nofollow" target="_blank">https://docs.sqlalchemy.org/en/13/dialects/</a>中。</p><h1 id="da52" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">使用 PostgreSQL 进行全文搜索</h1><p id="fac2" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">当谈到 PostgreSQL 特性时。用<code class="fe mu mv mw mx b">tsqeury</code>和<code class="fe mu mv mw mx b">tsvector</code>进行全文搜索呢？我们也可以用 SQLAchemy 做到这一点:</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="de1c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们再次为全文搜索创建了<em class="my"> Mixin </em>类，因为这是很多模型都可以使用的。这个<em class="my"> Mixin </em>有单一的静态方法，它采用搜索字符串和列在(<code class="fe mu mv mw mx b">field</code>)中进行搜索。为了进行实际的搜索，我们使用了<code class="fe mu mv mw mx b">func.to_tsvector</code>，我们将语言和对表列的引用传递给它。在这一点上，我们链接对<code class="fe mu mv mw mx b">.match</code>函数的调用，它实际上是对 PostgreSQL 中的<code class="fe mu mv mw mx b">to_tsquery</code>的调用，我们给它搜索字符串和搜索配置作为参数。</p><p id="7cc5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从生成的 SQL 中，我们可以看到 Python 代码确实生成了正确的 SQL 查询。</p><h1 id="54d2" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">跟踪行的上次更新</h1><p id="1b93" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">创建<code class="fe mu mv mw mx b">created_at</code>或<code class="fe mu mv mw mx b">updated_at</code>列是很常见的做法。这可以通过 SQLAlchemy 非常简单地完成:</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="d52f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于<code class="fe mu mv mw mx b">updated_at</code>,您只需要将<code class="fe mu mv mw mx b">onupdate</code>设置为<code class="fe mu mv mw mx b">func.now()</code>,这将使得每次更新行时，该列将被设置为当前时间戳。对于<code class="fe mu mv mw mx b">created_at</code>列，您可以省略<code class="fe mu mv mw mx b">onupdate</code>参数，而使用<code class="fe mu mv mw mx b">server_default</code>来设置创建行时调用的函数。</p><h1 id="f315" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">自引用表</h1><p id="42e5" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">在数据库中有递归/自引用关系并不罕见——无论是<em class="my">经理- &gt;员工</em>关系、树结构还是一些物化路径。这篇技巧展示了如何使用 SQLAlchemy 建立这种关系:</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="aac5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于本例，我们使用使用<code class="fe mu mv mw mx b">Node</code>记录创建的树形结构。每个节点都有一些<code class="fe mu mv mw mx b">data</code>，引用它的父节点和它的子节点列表。作为一种方便的方法，我们也包括了<code class="fe mu mv mw mx b">__str__</code>和<code class="fe mu mv mw mx b">__repr__</code>来帮助我们更好的可视化树。</p><p id="d88c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你对普通的<em class="my">一对多</em>关系没有意见，那么你可以用同样的方式处理任何非自指关系。然而，为了使其适用于<em class="my">双向</em>关系，您还需要包括如上所示的带有<code class="fe mu mv mw mx b">remote_side=[id]</code>的<code class="fe mu mv mw mx b">backref</code>。</p><h1 id="ecdc" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">用 Flask 绑定多个数据库</h1><p id="960f" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">最后一个是给所有<em class="my">烧瓶</em>用户的。如果您需要连接到多个数据库—例如，由于多个地理位置或多个数据源—那么您可以使用<code class="fe mu mv mw mx b">SQLALCHEMY_BINDS</code>来指定额外的数据库绑定:</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="3c7c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码片段中，我们通过设置<code class="fe mu mv mw mx b">SQLALCHEMY_DATABASE_URI</code>和<code class="fe mu mv mw mx b">SQLALCHEMY_BINDS</code>中的替代绑定来配置默认数据库。有了这个配置，我们就可以使用上述所有数据库。接下来，我们设置一个表的<code class="fe mu mv mw mx b">__bind_key__</code>来引用其中一个绑定，这样每当我们与这个特定的表交互时，SQLAlchemy 就会知道要连接到哪个数据库。</p><p id="080a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，如果您需要连接到具有相同表/模式的多个数据库，您可以使用多个引擎和会话——每个数据库一个，并根据需要在它们之间切换，如下所示:</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h1 id="74ff" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="5f5d" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">希望这里显示的这些提示和技巧中至少有一些对您有用，并且在您下次需要使用 SQLAlchemy 时会让您的生活稍微轻松一点。这篇文章绝对不是你可以用 SQLAlchemy 做的所有酷事情的详尽列表，你可以通过滚动<a class="ae lu" href="https://docs.sqlalchemy.org/en/13/core/index.html" rel="noopener ugc nofollow" target="_blank"> SQLAlchemy API 参考</a>找到一堆有用的东西。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><p id="01d3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="my">本文最初发布于</em><a class="ae lu" href="https://martinheinz.dev/blog/28?utm_source=tds&amp;utm_medium=referral&amp;utm_campaign=blog_post_28" rel="noopener ugc nofollow" target="_blank"><em class="my">martinheinz . dev</em></a></p><div class="ng nh gp gr ni nj"><a rel="noopener follow" target="_blank" href="/all-the-things-you-can-do-with-github-api-and-python-f01790fca131"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iu gy z fp no fr fs np fu fw is bi translated">你可以用 GitHub API 和 Python 做的所有事情</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">GitHub REST API 允许您管理问题、分支、回购、提交等等，所以让我们看看您如何使用…</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">towardsdatascience.com</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx lo nj"/></div></div></a></div><div class="ng nh gp gr ni nj"><a rel="noopener follow" target="_blank" href="/ultimate-guide-to-python-debugging-854dea731e1b"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iu gy z fp no fr fs np fu fw is bi translated">Python 调试终极指南</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">让我们探索使用 Python 日志记录、回溯、装饰器等等进行调试的艺术…</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">towardsdatascience.com</p></div></div><div class="ns l"><div class="ny l nu nv nw ns nx lo nj"/></div></div></a></div><div class="ng nh gp gr ni nj"><a rel="noopener follow" target="_blank" href="/automating-every-aspect-of-your-python-project-6517336af9da"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iu gy z fp no fr fs np fu fw is bi translated">自动化 Python 项目的各个方面</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">每个 Python 项目都可以从使用 Makefile、优化的 Docker 映像、配置良好的 CI/CD、代码…</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">towardsdatascience.com</p></div></div><div class="ns l"><div class="nz l nu nv nw ns nx lo nj"/></div></div></a></div></div></div>    
</body>
</html>