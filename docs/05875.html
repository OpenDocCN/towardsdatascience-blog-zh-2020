<html>
<head>
<title>Optimising Boids Algorithm With Unsupervised Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用无监督学习优化 Boids 算法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/optimising-boids-algorithm-with-unsupervised-learning-ba464891bdba?source=collection_archive---------37-----------------------#2020-05-14">https://towardsdatascience.com/optimising-boids-algorithm-with-unsupervised-learning-ba464891bdba?source=collection_archive---------37-----------------------#2020-05-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="412c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">利用 DBSCAN 聚类降低算法复杂度。</h2></div><p id="56b2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在群体智能中，许多个体在一个系统中相互作用。这些个体遵循一套简单的规则，通过他们的互动，可以出现更复杂的行为。</p><blockquote class="lb lc ld"><p id="be8a" class="kf kg le kh b ki kj jr kk kl km ju kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated"><em class="iq">“整体大于其部分之和”——</em><a class="ae li" href="https://sententiaeantiquae.com/2018/07/06/no-aristotle-didnt-write-a-whole-is-greater-than-the-sum-of-its-parts/" rel="noopener ugc nofollow" target="_blank"><em class="iq">大概不是亚里士多德</em>T5】</a></p></blockquote><p id="58ea" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">突现行为的一个著名例子是克雷格·雷诺兹的“Boids”程序。“机器人”最早诞生于 1986 年，模拟了栩栩如生的群体行为:</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi lj"><img src="../Images/f8d7aa844bff7018507aea0d5c08fc49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*jH94ehBHNaUs4V4Z.gif"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">我实现的 Boids 算法。</p></figure><p id="3486" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">整个鸟群的运动看起来很复杂。然而，如果我们考虑个人，我们可以看到复杂的行为来自三个简单的规则:</p><ul class=""><li id="4745" class="lv lw iq kh b ki kj kl km ko lx ks ly kw lz la ma mb mc md bi translated"><strong class="kh ir">分离:</strong>机器人移动以避免相互碰撞。</li><li id="d643" class="lv lw iq kh b ki me kl mf ko mg ks mh kw mi la ma mb mc md bi translated"><strong class="kh ir">对齐:</strong>机器人转向以匹配其周围机器人的平均方向。</li><li id="1fab" class="lv lw iq kh b ki me kl mf ko mg ks mh kw mi la ma mb mc md bi translated"><strong class="kh ir">内聚力:</strong>物体向其周围物体的中心移动。</li></ul><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mj"><img src="../Images/4007a9c7d905037e219ac424d0a9f72c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/0*GeU10W646CDVrNFv.jpg"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated"><a class="ae li" href="http://www.red3d.com/cwr/boids/" rel="noopener ugc nofollow" target="_blank"> <em class="mo">趋吉避凶。</em>T15】</a></p></figure><p id="7bfb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">遵循这些规则的单个 boid 在计算上是廉价的。然而，该算法的基本实现是非常低效的。一个 boid 需要考虑所有其他 boid 来计算其速度更新。因此，在没有额外编程的情况下，boids 算法相对于 boids 的数量具有复杂度 O(n)。随着我们向模拟中添加更多的 boids，我们的工作量会异常增加。</p><blockquote class="lb lc ld"><p id="e06a" class="kf kg le kh b ki kj jr kk kl km ju kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated"><em class="iq">快速提示:我们使用名为“减速”的指标来衡量绩效。实质上，减速是创建模拟所需的时间与该模拟的实时持续时间之间的比率。</em></p></blockquote><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi lj"><img src="../Images/0c40de200a1e0369dbc9c9cfbe4f4b07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*YPdeELwABj6YWaCL6YUjPw.png"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated"><em class="mo">指数级性能下降。</em></p></figure><p id="d002" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">提高 boids 性能的一种常见方法是使用空间数据结构。在 O(n)算法中，boid 考虑环境中的所有其他 boid。然而，它们的速度更新只受它们靠近的 boids 的影响。空间数据结构根据 boids 的位置来存储它们。这使得只比较存储在一起的 boids，节省了计算。</p><p id="873e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最著名的空间数据结构之一是切片。平铺通过在环境上放置一组瓷砖来标记 boids 的位置。Boids 只考虑它们的瓷砖和围绕它的瓷砖中的其他 boids。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi lj"><img src="../Images/9b4db2f41edd0eb8601931265321621d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*9LxNqZ90KNqfIO7l.gif"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">可视化平铺。</p></figure><p id="a44a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相对于 boids 的数量，平铺可以将 Boids 的效率提高到接近 O(n)。然而，平铺的一个经常被忽视的问题是它在大状态空间中的效率。随着我们所居住的“世界”的大小增加，瓷砖的数量也呈二次方增加。</p><p id="36d6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">计算 boid 的速度更新具有复杂度 O(n ),其中 n 是 boid 范围内的 boid 的数量。因此，我们预计在更宽敞(boid 密度更低)的环境中性能会有所提高。不幸的是，因为平铺在状态空间大小上具有指数复杂性，所以它的性能并没有提高多少。</p><p id="0838" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于这个问题，我提出的解决方案是使用一种相对于环境规模而言复杂度为 O(n)的算法。</p><p id="9d8a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae li" href="https://en.wikipedia.org/wiki/DBSCAN" rel="noopener ugc nofollow" target="_blank"> DBSCAN </a>是一种无监督学习聚类算法，根据点的密度产生聚类。将 DBSCAN 应用于 boids 会创建一组子群，这些子群相距太远，无法相互交互。这些子群中的 boid 和瓷砖中的一样，只需要考虑群中的其他 boid。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi lj"><img src="../Images/7e9bc5db01d4e4d2ffb4bb8d8d8cff22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*GUqf49WcfF_kOeVe.gif"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated"><em class="mo">实时 DBSCAN 聚类。</em></p></figure><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi lj"><img src="../Images/4b0ce4b9a96c01a2a9301bfb6525911d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*Ztw0vIWco-r6F1MWo3GKTg.png"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated"><em class="mo">相对于环境大小的表现。</em></p></figure><p id="ee38" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在大的状态空间中，DBSCAN 的性能明显优于平铺。平铺必须在整个环境中放置许多冗余的瓦片，在最极端的情况下会有数千个。DBSCAN 只需要考虑 boids 的位置作为点，这样就可以快速地对它们进行聚类。</p><p id="207d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">DBSCAN 不一定是普遍的改进。在高 boid 密度情况下，DBSCAN Boids 具有与 O(n)实现相当的性能。为了解决这个问题，我将 DBSCAN 与前面讨论的平铺算法结合起来。其结果是，相对于环境的大小而言，这种分块算法的效率要高得多。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi lj"><img src="../Images/dc5399777ce162c5bd7915bb4fd2f2b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*MZ3T8xlAGz735JWY.gif"/></div></figure><p id="000f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">红框显示了正在执行切片更新的环境区域。我们可以看到，环境中有一小部分需要在时间步长之间进行更新。这给出了相对于原始平铺方法的近乎普遍的改进，以及在高 boid 密度情况下相对于普通 DBSCAN 的提高的性能。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mp"><img src="../Images/c8d8f2406fbe8f379f22d1dd95cc2007.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JVVF3cnzB9_zqVyfcIxYGw.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated"><em class="mo">boid 划分算法的性能比较。</em></p></figure><p id="d4b9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽管我们已经看到了对基本 boids 实现的很好的改进，但我们只处理了改进算法的逻辑。通过优化代码和使用并行编程，可以进一步提高性能。</p><blockquote class="lb lc ld"><p id="ce7b" class="kf kg le kh b ki kj jr kk kl km ju kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated">编辑:使用 KD 树的初步结果显示在高 boid 密度环境中比 DBSCAN/Tiling 性能更好。</p></blockquote><p id="2349" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我为这篇文章编写的代码可以在这里找到。</p></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><p id="bb75" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="le">最初发布于</em><a class="ae li" href="https://adamprice.io/blog/boids.html" rel="noopener ugc nofollow" target="_blank"><em class="le">https://Adam price . io</em></a><em class="le">。</em></p></div></div>    
</body>
</html>