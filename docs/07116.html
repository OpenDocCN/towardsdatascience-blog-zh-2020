<html>
<head>
<title>Finding Lost Objects Using Bayesian Search in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 JavaScript 中使用贝叶斯搜索寻找丢失的对象</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/finding-lost-objects-using-bayesian-search-in-javascript-f502e3a1eb8c?source=collection_archive---------47-----------------------#2020-05-31">https://towardsdatascience.com/finding-lost-objects-using-bayesian-search-in-javascript-f502e3a1eb8c?source=collection_archive---------47-----------------------#2020-05-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="23a3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用贝叶斯搜索理论模拟对失踪飞机的搜索。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/da2e6c38e9156fe476d66c31a868aaff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kKanZlhj7r4si-eEw4fFFA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一架飞机在海上失踪的概率分布的例子。</p></figure><p id="349a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">寻找丢失的物品时，有多种搜索方法可供使用。<a class="ae lu" href="https://en.wikipedia.org/wiki/Bayesian_search_theory" rel="noopener ugc nofollow" target="_blank">贝叶斯搜索理论</a>就是其中之一。它已经被多次用于搜寻失踪的船只和飞机，如<a class="ae lu" href="https://en.wikipedia.org/wiki/USS_Scorpion_(SSN-589)" rel="noopener ugc nofollow" target="_blank">号航空母舰蝎子号</a>、<a class="ae lu" href="https://en.wikipedia.org/wiki/Air_France_Flight_447" rel="noopener ugc nofollow" target="_blank">号法航 447 航班</a>和<a class="ae lu" href="https://en.wikipedia.org/wiki/Malaysia_Airlines_Flight_370" rel="noopener ugc nofollow" target="_blank">号马航 370 航班</a>。</p><p id="891a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我会试着用<a class="ae lu" href="https://p5js.org/" rel="noopener ugc nofollow" target="_blank"> p5.js </a>用 JavaScript 模拟贝叶斯搜索理论。</p><h1 id="775b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">贝叶斯搜索理论</h1><p id="86dc" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">贝叶斯搜索理论涉及应用贝叶斯统计来搜索丢失的对象。它依赖于贝叶斯定理。在<a class="ae lu" href="https://en.wikipedia.org/wiki/Bayesian_optimization" rel="noopener ugc nofollow" target="_blank">贝叶斯优化</a>中使用的相同定理。</p><p id="39fb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">贝叶斯搜索理论的目标是在信息有限的情况下最大化检测概率。它有助于在不必等待新数据的情况下做出决策。</p><p id="1119" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">贝叶斯搜索通常如下进行:</p><ol class=""><li id="2d00" class="ms mt it la b lb lc le lf lh mu ll mv lp mw lt mx my mz na bi translated">设想所有可能的情况。</li><li id="2477" class="ms mt it la b lb nb le nc lh nd ll ne lp nf lt mx my mz na bi translated">计算每个场景的概率分布。</li><li id="d80e" class="ms mt it la b lb nb le nc lh nd ll ne lp nf lt mx my mz na bi translated">将它们与每个场景的概率结合起来，做出一个总体概率分布。</li><li id="4599" class="ms mt it la b lb nb le nc lh nd ll ne lp nf lt mx my mz na bi translated">构建一个从最高概率到最低概率的搜索路径。</li><li id="afad" class="ms mt it la b lb nb le nc lh nd ll ne lp nf lt mx my mz na bi translated">使用贝叶斯定理在搜索过程中更新概率。</li></ol><h1 id="4ad0" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">寻找失踪的飞机</h1><p id="0f6d" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">让我们假设我们正在大海中寻找一架失踪的飞机。飞行员宣布他们的发动机失灵了。通讯中断后不久。</p><h2 id="d41f" class="ng lw it bd lx nh ni dn mb nj nk dp mf lh nl nm mh ll nn no mj lp np nq ml nr bi translated">可能的情况</h2><p id="d88f" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">由于引擎失灵，一种可能的情况是它们失去了高度，溅入了海洋。在这个例子中，我们将假设这是唯一可能的情况。</p><h2 id="cf5b" class="ng lw it bd lx nh ni dn mb nj nk dp mf lh nl nm mh ll nn no mj lp np nq ml nr bi translated">计算概率分布</h2><p id="e507" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">假设我们知道飞行计划和飞机的<strong class="la iu">最后已知位置(LKP) </strong>。</p><p id="6d3c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">根据飞行员在溅落前可以保持的高度，我们可以估计一个搜索区域。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/daee92a30a5f61e8f0bbb2e22b416cb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MORUhK2yqjtes-qgJFH6nw.png"/></div></div></figure><p id="909d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将使用一个<a class="ae lu" href="https://en.wikipedia.org/wiki/Normal_distribution" rel="noopener ugc nofollow" target="_blank">正态分布</a>作为飞机距离飞行轨迹距离<strong class="la iu"> d </strong>的概率。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/bbff47c4563bcd7ac5b0ac67639f78c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:468/format:webp/1*JIkHuGE3saMh_DAOjqcoOA.png"/></div></figure><p id="4713" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">标准偏差<strong class="la iu"> σ </strong>将根据水深、水流等进行选择。</p><p id="0a22" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">分布可能看起来像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/675712396eb116aa0cd62d5cb4b8ee30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NABYnppNyWNB9XlmDEuSdQ.png"/></div></div></figure><p id="1de2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将再次使用正态分布计算飞机飞离最后已知位置的概率。结合这两个分布，我们得到:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f8b52bda7429bf7800cd5bc1d976f3fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_3TMBJ3cUPkjTnCiw8dcmA.png"/></div></div></figure><p id="444b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以加上其他因素，比如水流。在这个例子中，我将添加一些随机值和柏林噪声。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/016d2966aaf93c67b68f5292d27ad3f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WDdoSG8r-BSFStkbuYgHmQ.png"/></div></div></figure><p id="9da6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我创建了两个函数。<code class="fe nt nu nv nw b">generate_lost()</code>生成飞机的随机位置。<code class="fe nt nu nv nw b">generate_distribution()</code>生成一个更靠近飞机的随机点，并将其作为 LKP 来生成分布。</p><h2 id="21d4" class="ng lw it bd lx nh ni dn mb nj nk dp mf lh nl nm mh ll nn no mj lp np nq ml nr bi translated">搜索模式</h2><p id="fdd2" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">通常是从概率最高的地方开始搜索到概率最低的地方。现实生活中有很多搜索模式可以使用，比如:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/af24dea26a741493958ef416379d307a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wNI8K5M6HM0FULJ2CMETNw.jpeg"/></div></div></figure><p id="d415" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将使用不同的方法。我们将总是选择当前方块范围内概率最高的方块。如果有多个，我们将选择最近的一个。虽然对于现实生活中的应用程序来说不是很好，但它更容易实现。</p><p id="d35d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在正方形中搜索时，有三种情况。我们可以用概率来表示它们。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/7e564d1903d28ab7aed4bc4c2e5c3846.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*jsRJW52CvJOXN8cucHJcMA.png"/></div></figure><ul class=""><li id="14f3" class="ms mt it la b lb lc le lf lh mu ll mv lp mw lt nz my mz na bi translated"><strong class="la iu">真正:</strong> <em class="oa">概率</em> <strong class="la iu"> <em class="oa"> pf </em> </strong> <em class="oa">。</em> <strong class="la iu"> </strong>如果找到飞机。</li><li id="438f" class="ms mt it la b lb nb le nc lh nd ll ne lp nf lt nz my mz na bi translated"><strong class="la iu">真否定:</strong> <em class="oa">概率</em> <strong class="la iu"> <em class="oa"> 1-p. </em> </strong>如果没有找到飞机且正方形不包含飞机。</li><li id="4d07" class="ms mt it la b lb nb le nc lh nd ll ne lp nf lt nz my mz na bi translated"><strong class="la iu">假阴性:</strong> <em class="oa">概率</em><strong class="la iu"><em class="oa">p(1-f)</em></strong><em class="oa">。</em> <strong class="la iu"> </strong>如果你没有找到飞机但飞机确实在那里。这是因为搜索有可能找不到飞机。</li></ul><p id="8668" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你不可能得到误报，因为你不可能发现一架不在那里的飞机。(或者至少我们会这样假设)。</p><p id="7e66" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们在一个正方形中没有找到飞机，我们将使用正方形拥有飞机的概率来更新概率，假设搜索没有找到它。这就是我们要用到贝叶斯定理的地方。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/8258604add45f83672d659d8f519a129.png" data-original-src="https://miro.medium.com/v2/resize:fit:580/format:webp/1*OmJGpuR5zVi4M-ppJkQbPA.png"/></div></figure><p id="f0a5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">也可以写成</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/6f0cdf4242f466bd00979b8273755bba.png" data-original-src="https://miro.medium.com/v2/resize:fit:478/format:webp/1*x8JX_Pb9j275Sb0FrUfDLw.png"/></div></figure><p id="698f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">飞机在那里但搜索没有找到的概率是</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/cef9ef41f73b9e898fc58ef7c8412322.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/format:webp/1*0aKNFMXHlwotKc0BMS7zyw.png"/></div></figure><p id="806b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">利用上图我们可以看到，平面<strong class="la iu"> <em class="oa">存在而</em> </strong>未被发现的概率为<strong class="la iu"> p(1-f) </strong>。而飞机被<strong class="la iu">没发现</strong>的概率就是<strong class="la iu"> <em class="oa">有没有</em> </strong> <em class="oa"> </em> <strong class="la iu"> <em class="oa">没发现</em>p(1-f)</strong><strong class="la iu"><em class="oa">有没有 1-p </em> </strong> <em class="oa"> </em>也就是<strong class="la iu"> p(1-f)+1-p </strong>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/5dce26344e0236f3a05f150947166c71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*_uJ5t0FqU5oYgel5jvYN-w.png"/></div></figure><p id="7b8e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于其他方块，没有机会(<strong class="la iu"> f=0 </strong>)在那里找到飞机，因为我们还没有搜索那里。所以，可能性是</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/ea59ab7f0d78ecf0498de1d15adbfb83.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/format:webp/1*EeHTwgzRLlt2RpnDjR-r3A.png"/></div></figure><h1 id="b89c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">搜索！</h1><p id="e0a3" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">直觉上，随着搜索概率的下降，我们应该期待更多的迭代来找到对象。</p><div class="kj kk kl km gt ab cb"><figure class="og kn oh oi oj ok ol paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/b2405d92b629360d59fb8a7c85db4352.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*23MiIPSsWIR4j28j31MhnA.gif"/></div></figure><figure class="og kn oh oi oj ok ol paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/a8b712c83a004ff0a4a6a4ecee9dfec2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*qooS9XO3vDmQx6fqTS_bPg.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk om di on oo translated">70%(左)和 30%(右)的搜索发现概率。</p></figure></div><p id="6386" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">假设:</strong>较高的搜索概率平均需要较少的步骤来找到对象。</p><p id="77a7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当搜索概率较低时，如果什么也没找到，概率会缓慢下降。因此，执行了更多的搜索。</p><p id="8b5a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们针对不同的概率分布和搜索概率进行多次运行，以确认我们的假设。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/6b0168ef82d22a410e04db1a8837d82f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8QOjCPb9KGE54KAX1JvuLg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">16 个随机生成的概率分布。</p></figure><p id="0761" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是运行 1000 次后的结果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/49ca24748c83f4128ee49c923ac957c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vntaiPTUPaFnvRqVT17DUg.png"/></div></div></figure><p id="e82f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于高概率值(接近 1)，与低概率值相比，在发现飞机之前采取的步骤数量非常小且紧凑。</p><p id="89cd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以清楚地证实我们的假设。</p><p id="763e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以在这里找到<em class="oa"> JavaScript + p5.js </em>项目和源代码<a class="ae lu" href="https://editor.p5js.org/BilHim/sketches/3gsKfQCTx" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl or os hx ot" role="separator"><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow"/></div><div class="im in io ip iq"><p id="98ae" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以通过给每个方块一个搜索成本来进一步扩展这一点。那么问题就变成了:如何在最小化成本的同时最大化找到对象的几率。这是一个<a class="ae lu" href="https://en.wikipedia.org/wiki/Gittins_index" rel="noopener ugc nofollow" target="_blank">吉廷斯指数</a>的例子。</p><p id="a750" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">更进一步，我们可以将这种方法与基于神经网络的搜索进行比较。</p></div></div>    
</body>
</html>