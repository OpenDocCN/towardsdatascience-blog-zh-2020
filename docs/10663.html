<html>
<head>
<title>What Makes a Song Great? Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">是什么让一首歌伟大？第二部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/what-makes-a-song-great-part-2-e82a44be659c?source=collection_archive---------47-----------------------#2020-07-25">https://towardsdatascience.com/what-makes-a-song-great-part-2-e82a44be659c?source=collection_archive---------47-----------------------#2020-07-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="05c0" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/what-makes-a-song-great" rel="noopener" target="_blank">是什么让一首歌如此伟大</a></h2><div class=""/><div class=""><h2 id="541d" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">通过 Spotify 的 Python 分析滚石的<em class="ko"> 500 首最棒的歌曲</em></h2></div><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/8fd62593f25611af318bb423608480ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*H50KOVQdBgyZQ3uM"/></div></div><p class="lb lc gj gh gi ld le bd b be z dk translated">约翰·马特丘克在<a class="ae lf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="d503" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated"><strong class="li ja">【这是</strong> <a class="ae lf" href="https://towardsdatascience.com/tagged/what-makes-a-song-great" rel="noopener" target="_blank"> <strong class="li ja">系列三篇文章中的第二篇</strong></a><strong class="li ja"/></p><p id="e3f7" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">在<a class="ae lf" rel="noopener" target="_blank" href="/rollingstone-for-medium-f1f638b9568e">第 1 部分</a>中，我们研究了如何从网络上检索数据。在本文中，我们将更多地关注与 API 的交互和使用 Pandas。</p><h2 id="ecc4" class="mc md iq bd me mf mg dn mh mi mj dp mk lp ml mm mn lt mo mp mq lx mr ms mt iw bi translated">从 Spotify API 获取数据。</h2><p id="50b4" class="pw-post-body-paragraph lg lh iq li b lj mu ka ll lm mv kd lo lp mw lr ls lt mx lv lw lx my lz ma mb ij bi translated">以前我们使用网络抓取来获得一个包含滚石乐队有史以来 500 首最伟大歌曲的数据框架。如果我们想创建一个 Spotify 播放列表呢？或者，更好的是，从 Spotify 获得更多数据来补充我们的数据？我们可以通过查询并发布到 Spotify 的 API 来实现。最简单地说，应用程序编程接口(或“API”)只是服务器的一部分，当您的浏览器或应用程序从互联网发送和检索数据时，它会与服务器进行交互。当你在 Spotify 中将一首歌添加到播放列表中，或者查看一首歌的时长时，你正在与它的 API 进行交互。</p><p id="8510" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">这是了解更多信息的良好起点:</p><div class="na nb gp gr nc nd"><a href="https://medium.com/@perrysetgo/what-exactly-is-an-api-69f36968a41f" rel="noopener follow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd ja gy z fp ni fr fs nj fu fw iz bi translated">API 到底是什么？</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">你有没有听说过“API”这个词，并想知道这到底是什么？你是否有一个模糊的想法，但是…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">medium.com</p></div></div><div class="nm l"><div class="nn l no np nq nm nr kz nd"/></div></div></a></div><h2 id="6bd8" class="mc md iq bd me mf mg dn mh mi mj dp mk lp ml mm mn lt mo mp mq lx mr ms mt iw bi translated">步骤 1:设置</h2><p id="ff40" class="pw-post-body-paragraph lg lh iq li b lj mu ka ll lm mv kd lo lp mw lr ls lt mx lv lw lx my lz ma mb ij bi translated">前往 Spotify 的 API <a class="ae lf" href="https://developer.spotify.com/dashboard/applications" rel="noopener ugc nofollow" target="_blank">仪表盘</a>，用你的标准账户登录，点击“创建应用”。从那里你应该复制<em class="mz">客户端 id </em>和<em class="mz">客户端秘密</em>。这些将是您登录 API 所需的凭证。将它们粘贴到一个<code class="fe ns nt nu nv b">.txt</code>文件中是个好主意(我的文件叫做<code class="fe ns nt nu nv b">Spotify.txt</code>——见下文)。<br/>现在我们可以连接到 API，如下所示(T2 行是避免忘记关闭文件的简洁方法):</p><pre class="kq kr ks kt gt nw nv nx ny aw nz bi"><span id="41e9" class="mc md iq nv b gy oa ob l oc od">file = 'Spotify.txt'# replace this with the path and file name you use<br/>with open(file,'r') as f: <br/>    f = f.read().splitlines()<br/>    cid = f[0].split(':')[1]<br/>    secret = f[1].split(':')[1]</span><span id="508e" class="mc md iq nv b gy oe ob l oc od">client_credentials_manager = SpotifyClientCredentials(client_id=cid, client_secret=secret)<br/>sp = spotipy.Spotify(client_credentials_manager=client_credentials_manager)</span></pre><p id="f5e6" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">Python 有一个很棒的库叫做<code class="fe ns nt nu nv b">spotipy</code>(就是上面代码中的<code class="fe ns nt nu nv b">sp</code>)，这使得这比平常容易得多。<a class="ae lf" href="https://spotipy.readthedocs.io/en/2.13.0/" rel="noopener ugc nofollow" target="_blank">在这里</a>你可以阅读文档。或者像我一样，你可以通过阅读 Medium 上的一篇文章来了解一下——我推荐这篇:<a class="ae lf" href="https://medium.com/@samlupton/spotipy-get-features-from-your-favourite-songs-in-python-6d71f0172df0." rel="noopener">https://Medium . com/@ samlupton/spot ipy-get-features-from-your-favorite-songs-in-python-6d 71 f 0172 df 0。</a></p><h2 id="ed28" class="mc md iq bd me mf mg dn mh mi mj dp mk lp ml mm mn lt mo mp mq lx mr ms mt iw bi translated">步骤 2:检索数据</h2><p id="7f1e" class="pw-post-body-paragraph lg lh iq li b lj mu ka ll lm mv kd lo lp mw lr ls lt mx lv lw lx my lz ma mb ij bi translated">现在让我们开始有趣的部分。为了从 Spotify 下载数据，我们首先检索 500 首歌曲中每一首的<code class="fe ns nt nu nv b">track id</code>。让我们以<em class="mz">我的女孩</em>为例，由<em class="mz">诱惑</em>创作。</p><p id="7b4b" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">我们将从数据帧中提取艺术家和歌曲名称，并将结果传递给<code class="fe ns nt nu nv b">spotipy</code>的<code class="fe ns nt nu nv b">.search()</code>方法。</p><pre class="kq kr ks kt gt nw nv nx ny aw nz bi"><span id="55ae" class="mc md iq nv b gy oa ob l oc od">artist = df.Artist[412]<br/>track = df['Song title'][412]<br/>artist, track</span><span id="6c44" class="mc md iq nv b gy oe ob l oc od">('The Temptations', 'My Girl')</span><span id="f4c1" class="mc md iq nv b gy oe ob l oc od">track_id = sp.search(q='artist:' + artist + ' track:' + track, type='track')<br/>track_id</span><span id="6707" class="mc md iq nv b gy oe ob l oc od">{'tracks': {'href': 'https://api.spotify.com/v1/search?query=artist%3AThe+Temptations+track%3AMy+Girl&amp;type=track&amp;offset=0&amp;limit=10',<br/>  'items': [{'album': {'album_type': 'album',<br/>     'artists': [{'external_urls': {'spotify': 'https://open.spotify.com/artist/3RwQ26hR2tJtA8F9p2n7jG'},<br/>       'href': 'https://api.spotify.com/v1/artists/3RwQ26hR2tJtA8F9p2n7jG',<br/>       'id': '3RwQ26hR2tJtA8F9p2n7jG',<br/>       'name': 'The Temptations',<br/>       'type': 'artist',<br/>       'uri': 'spotify:artist:3RwQ26hR2tJtA8F9p2n7jG'}],<br/>     'available_markets': ['AD',<br/>      'AE',<br/>      'AL',<br/>      'AR',<br/>      'AT',<br/>      'AU',<br/>      'BA',<br/>   <br/>   [...]<br/>   <br/>  'previous': None,<br/>  'total': 143}}</span></pre><p id="aa25" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">虽然这看起来很可怕，但它是一个<a class="ae lf" href="https://www.w3schools.com/whatis/whatis_json.asp" rel="noopener ugc nofollow" target="_blank"> JSON 对象</a>，它的行为非常像一个 Python 字典。稍微检查一下就会发现，例如，如果一个列表本身是第一个键-值对(例如<code class="fe ns nt nu nv b">{tracks : ...}</code>)中键<code class="fe ns nt nu nv b">items</code>的值，那么实际的<code class="fe ns nt nu nv b">id</code>是作为第一个项目中键 <code class="fe ns nt nu nv b">id</code>的值嵌套的。同样，稍微挖掘一下，我们就能找到这首歌的<code class="fe ns nt nu nv b">popularity</code>属性。</p><pre class="kq kr ks kt gt nw nv nx ny aw nz bi"><span id="db21" class="mc md iq nv b gy oa ob l oc od">id_ = track_id['tracks']['items'][0]['id']</span><span id="1045" class="mc md iq nv b gy oe ob l oc od">popularity = track_id['tracks']['items'][0]['popularity']</span></pre><p id="19e6" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">现在我们可以把所有东西放进一个函数里。因为一些搜索可能没有结果，我们将使用<code class="fe ns nt nu nv b">try... except...</code>块<a class="ae lf" href="https://www.programiz.com/python-programming/exception-handling" rel="noopener ugc nofollow" target="_blank">处理异常</a>。注意第 4 行中使用了<code class="fe ns nt nu nv b">.zip()</code>函数，以避免更复杂的迭代。然后，我们检索数据并将其添加到我们的数据帧中。</p><pre class="kq kr ks kt gt nw nv nx ny aw nz bi"><span id="c43d" class="mc md iq nv b gy oa ob l oc od">def get_spotify_data(dataframe):<br/>    """<br/>    Takes a dataframe as input.<br/>    Returns a list of track ids and a list of popularity scores from the Spotify API. <br/>    """<br/>    from numpy import nan # we import np.nan to handle empty queries <br/>    track_ids = []<br/>    popularities = []<br/>    for [artist, song] in list(zip(dataframe['Artist'], dataframe['Song title'])):<br/>        try:<br/>            song_data = sp.search(q='artist:' + artist + ' track:' + song, type='track')<br/>            track_id = song_data['tracks']['items'][0]['id']<br/>            popularity = song_data['tracks']['items'][0]['popularity']<br/>            track_ids.append(track_id)<br/>            popularities.append(popularity)<br/>        except:<br/>            track_ids.append(nan)<br/>            popularities.append(nan)<br/>    return track_ids, popularities</span><span id="d203" class="mc md iq nv b gy oe ob l oc od">track_ids, popularities = get_spotify_data(df)</span><span id="b3c2" class="mc md iq nv b gy oe ob l oc od">df['Spotify id'] = track_ids<br/>df['Popularity'] = popularities</span><span id="6677" class="mc md iq nv b gy oe ob l oc od">df.head()</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="ab gu cl of"><img src="../Images/644ce52d5fa907455bfcb215f9a9eb7c.png" data-original-src="https://miro.medium.com/v2/format:webp/1*zdGdBh3bb0M8gcw5mKLFCw.png"/></div></figure><p id="9656" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">很好。让我们使用 pandas 的<code class="fe ns nt nu nv b">.isnull()</code>来检查我们的函数是否返回了任何丢失的值:</p><pre class="kq kr ks kt gt nw nv nx ny aw nz bi"><span id="488d" class="mc md iq nv b gy oa ob l oc od">df.isnull().sum()</span><span id="ab7f" class="mc md iq nv b gy oe ob l oc od">Artist         0<br/>Song title     0<br/>Writers        0<br/>Producer       0<br/>Year           0<br/>Spotify id    13<br/>Popularity    13<br/>dtype: int64</span></pre><p id="be92" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">我们的查询没有返回 13 个项目。为了简洁起见，我将把它们从数据帧中删除。我可能会在稍后阶段添加一个解决方法。</p><pre class="kq kr ks kt gt nw nv nx ny aw nz bi"><span id="a6d5" class="mc md iq nv b gy oa ob l oc od">df.dropna(inplace=True)</span></pre><h2 id="4dd0" class="mc md iq bd me mf mg dn mh mi mj dp mk lp ml mm mn lt mo mp mq lx mr ms mt iw bi translated">步骤 3:获取数据帧中的音频特征</h2><p id="3f06" class="pw-post-body-paragraph lg lh iq li b lj mu ka ll lm mv kd lo lp mw lr ls lt mx lv lw lx my lz ma mb ij bi translated">Spotify 还跟踪音频功能，如可跳舞性、拍号、速度。我们可以通过将一个轨迹的 id 传递给它的<code class="fe ns nt nu nv b">audio_features</code>方法来访问那些带有<code class="fe ns nt nu nv b">spotipy</code>的。我将向你展示两种做这件事的方法。首先，我使用 Python 的<a class="ae lf" href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="noopener ugc nofollow" target="_blank">列表理解</a>，这是一个稍微高级一点的特性，允许你以非常简洁的方式迭代地创建列表。但是如果感觉更舒服的话，你可以使用标准的<code class="fe ns nt nu nv b">for</code>环。<br/>点击<a class="ae lf" href="https://developer.spotify.com/documentation/web-api/reference/tracks/get-audio-features/" rel="noopener ugc nofollow" target="_blank">这里</a>了解 Spotify 音频功能的更多信息。</p><pre class="kq kr ks kt gt nw nv nx ny aw nz bi"><span id="b1d4" class="mc md iq nv b gy oa ob l oc od"># using list comprehension<br/>features = [sp.audio_features(id_) for id_ in df['Spotify id']]<br/>features[0]</span><span id="c1b3" class="mc md iq nv b gy oe ob l oc od">#using a 'for' loop<br/>features_2 = []<br/>for id_ in df['Spotify id']:<br/>    feature = sp.audio_features(id_)<br/>    features_2.append(feature)</span><span id="5bfc" class="mc md iq nv b gy oe ob l oc od"><em class="mz"># Look at an example</em></span><span id="e685" class="mc md iq nv b gy oe ob l oc od">features_2[0]</span><span id="5339" class="mc md iq nv b gy oe ob l oc od">[{'danceability': 0.365,<br/>  'energy': 0.668,<br/>  'key': 7,<br/>  'loudness': -12.002,<br/>  'mode': 1,<br/>  'speechiness': 0.817,<br/>  'acousticness': 0.836,<br/>  'instrumentalness': 2.58e-05,<br/>  'liveness': 0.911,<br/>  'valence': 0.216,<br/>  'tempo': 53.071,<br/>  'type': 'audio_features',<br/>  'id': '2eOFGf5MOA5QHGLY9ZlOfl',<br/>  'uri': 'spotify:track:2eOFGf5MOA5QHGLY9ZlOfl',  'track_href': 'https://api.spotify.com/v1/tracks/2eOFGf5MOA5QHGLY9ZlOfl',<br/>  'analysis_url': 'https://api.spotify.com/v1/audio-analysis/2eOFGf5MOA5QHGLY9ZlOfl',<br/>  'duration_ms': 217720,<br/>  'time_signature': 4}]</span></pre><p id="e82d" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">我们有一个列表列表，每个列表对应一首歌，包含一个字典。下面是我们如何将每个功能添加到数据框中的相应列:</p><ol class=""><li id="640b" class="og oh iq li b lj lk lm ln lp oi lt oj lx ok mb ol om on oo bi translated">创建特征列表</li><li id="ed48" class="og oh iq li b lj op lm oq lp or lt os lx ot mb ol om on oo bi translated">遍历列表创建一个字典。键将对应于列名，值将是包含实际音频特性的列表</li><li id="d7ce" class="og oh iq li b lj op lm oq lp or lt os lx ot mb ol om on oo bi translated">接下来，遍历特性列表，用字典的 items()方法检索音频特性的标签和值对。追加到我们创建的字典中。</li><li id="cf23" class="og oh iq li b lj op lm oq lp or lt os lx ot mb ol om on oo bi translated">用 for 循环将字典中的每一项作为新列添加</li></ol><pre class="kq kr ks kt gt nw nv nx ny aw nz bi"><span id="6e8c" class="mc md iq nv b gy oa ob l oc od">#STEP 1<br/>k = list(features[0][0].keys())</span><span id="a358" class="mc md iq nv b gy oe ob l oc od"># STEP 2<br/>dict_list = {} <br/>for key in k:<br/>    dict_list[key] = []</span><span id="88af" class="mc md iq nv b gy oe ob l oc od"># STEP 3<br/>for i in features:<br/>    item = i[0].items()<br/>    for pair in item:<br/>        key, value = pair<br/>        dict_list[key].append(value)</span><span id="ef25" class="mc md iq nv b gy oe ob l oc od"># STEP 4<br/>for key in dict_list.keys():<br/>    df[key] = dict_list[key]</span></pre><p id="c0d6" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">因为我们不需要一些列，所以我会去掉它们，看看我们的数据框架。</p><pre class="kq kr ks kt gt nw nv nx ny aw nz bi"><span id="8cc5" class="mc md iq nv b gy oa ob l oc od">columns_to_drop = ['tempo', 'type', 'id', 'uri', 'track_href', 'analysis_url']<br/>df.drop(columns_to_drop, axis=1, inplace=True)</span><span id="2d5a" class="mc md iq nv b gy oe ob l oc od">df.head()</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi ou"><img src="../Images/dec49465dbe1675ae082b15898c54e39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1qyCfybkqiTBlbjacdiy0Q.png"/></div></div><p class="lb lc gj gh gi ld le bd b be z dk translated">完整的数据帧</p></figure><p id="ff57" class="pw-post-body-paragraph lg lh iq li b lj lk ka ll lm ln kd lo lp lq lr ls lt lu lv lw lx ly lz ma mb ij bi translated">我们都准备好了。在下一篇文章中，我们将最终开始探索和可视化我们的数据集。我希望你喜欢并学到了一些有用的工具。</p></div></div>    
</body>
</html>