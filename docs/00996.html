<html>
<head>
<title>Preparing for Graduate School Interviews with Network Analysis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用网络分析准备研究生院面试</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/preparing-for-graduate-school-interviews-with-network-analysis-84df6354659b?source=collection_archive---------39-----------------------#2020-01-28">https://towardsdatascience.com/preparing-for-graduate-school-interviews-with-network-analysis-84df6354659b?source=collection_archive---------39-----------------------#2020-01-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="78f0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">利用数据科学发现跨机构教师之间的联系。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/574bf4ae8d6176f0170cfb1f6892e2b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bx_dVJ_cHbJQwimiloeqYg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图一。不同机构的教职员工的图表(彩色),由他们的出版历史联系起来。</p></figure><p id="8613" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="lr">本文是正在进行的关于在研究生院面试过程中利用数据科学的系列文章的第一部分。查看下一期</em> <a class="ae ls" rel="noopener" target="_blank" href="/topic-modelling-for-graduate-school-interviews-e6331721c6e0"> <em class="lr">专题造型</em> </a> <em class="lr">，敬请期待更多。</em></p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><p id="5722" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">美国的研究生院面试季正在火热进行中，这意味着你会遇到很多在某个特定领域可能相互认识的重要人物。当你准备的时候，你会开始意识到世界是多么的小，全国和全世界的教师是如何通过合作和相互尊重来建立他们的职业生涯的。为了帮助理解这些关系，我花了几周时间思考如何最好地收集、处理和呈现这些数据，以便在采访中有效地使用。我刚从我的第一轮面试中回来，并与我的同事分享了我的一些结果，他们的兴趣促使我写了这篇简短的走查，所以任何有兴趣为自己做同样事情的人都可以。</p><p id="f514" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将主要使用Python，包括以下模块:</p><ul class=""><li id="7372" class="ma mb iq kx b ky kz lb lc le mc li md lm me lq mf mg mh mi bi translated">学术，通过谷歌学术收集数据。</li><li id="0d9c" class="ma mb iq kx b ky mj lb mk le ml li mm lm mn lq mf mg mh mi bi translated">熊猫和Numpy，进行基础数据角力和操作。</li><li id="05f6" class="ma mb iq kx b ky mj lb mk le ml li mm lm mn lq mf mg mh mi bi translated">Networkx和Matplotlib，用于绘图和数据表示。</li><li id="7da3" class="ma mb iq kx b ky mj lb mk le ml li mm lm mn lq mf mg mh mi bi translated">Python-docx，用于自动化文档构造。</li></ul><p id="37c1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">其中一些可能包含在Python的典型安装中，也可能不包含在其中，因此我建议您参考它们各自的网站/文档以获得专门的帮助。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><p id="c809" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">第0部分:数据收集准备</strong></p><p id="83f4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">根据我的理解和知识，并没有一个确切的谷歌学术API可以被接口来直接获取数据，因此实现了<strong class="kx ir">学术</strong>。这带来了一些优点和缺点，其中一些有时会由于高容量使用而被阻塞。出于这个原因，我们想在安装后对它的脚本做一些小的修改。请在Python下的lib/site-packages/文件夹中，或者在您决定维护该模块的任何地方找到scholastic . py文件。这里我们将添加一个简单的随机用户代理生成器:这里是<a class="ae ls" rel="noopener" target="_blank" href="/5-strategies-to-write-unblock-able-web-scrapers-in-python-5e40c147bdaf">这里是</a>。在scholastic . py中，您可以找到web-scrapers标题的定义，如下所示:</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="a4bb" class="mt mu iq mp b gy mv mw l mx my">_HEADERS = {<br/> ‘accept-language’: ‘en-US,en’,<br/> ‘User-Agent’: ‘Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36’,<br/> ‘accept’: ‘text/html,application/xhtml+xml,application/xml’<br/> }</span></pre><p id="7510" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这对于简单的运行来说已经足够好了，然而，根据你感兴趣的教师数量，这可能是不够的。因此，在脚本的开始，我们将从前面的超链接文章中添加随机用户代理生成器，我们的scholarly.py脚本的开始应该是这样的:</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="70f0" class="mt mu iq mp b gy mv mw l mx my">def get_random_ua():<br/>    random_ua = ''<br/>    ua_file = 'C:/Users/Masters-PC/Documents/ua_file.txt'<br/>    try:<br/>        with open(ua_file) as f:<br/>            lines = f.readlines()<br/>        if len(lines) &gt; 0:<br/>            prng = np.random.RandomState()<br/>            index = prng.permutation(len(lines) - 1)<br/>            idx = np.asarray(index, dtype=np.integer)[0]<br/>            random_proxy = lines[int(idx)]<br/>    except Exception as ex:<br/>        print('Exception in random_ua')<br/>        print(str(ex))<br/>    finally:<br/>        return random_ua</span><span id="31b4" class="mt mu iq mp b gy mz mw l mx my">_GOOGLEID = hashlib.md5(str(random.random()).encode('utf-8')).hexdigest()[:16]<br/>_COOKIES = {'GSP': 'ID={0}:CF=4'.format(_GOOGLEID)}<br/>_HEADERS = {<br/>    'accept-language': 'en-US,en',<br/>    'User-Agent': get_random_ua(),<br/>    'accept': 'text/html,application/xhtml+xml,application/xml'<br/>    }</span></pre><p id="1daa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这应该让我们为我们的应用程序做好了准备，尽管您可以随意浏览带超链接的文章的其余部分，并实现他们的其余建议。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><p id="6dd4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">第一部分:数据收集</strong></p><p id="cbd8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">取决于你离面试日期有多近，你可能会也可能不会有你将会见的教员名单。这是我们将使用谷歌学术获得他们数据的广度的地方。首先，导入相应的模块并定义这个作者列表。</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="b9a7" class="mt mu iq mp b gy mv mw l mx my">authorlist = """Wilhelm Ostwald<br/>Linus Pauling<br/>Max Perutz<br/>Frederick Sanger<br/>Michael Smith<br/>Harold Urey<br/>Milton Friedman<br/>Friedrich Hayek"""</span></pre><p id="45b8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我只包括了7个随机的诺贝尔奖获得者，但是这个想法是你应该能够同时包括你感兴趣的所有教师。我的名单上有超过40人，分布在10多个机构，我还包括了我以前的导师，以防那里有任何以前未被发现的联系。有了这个，我们就可以利用学术并把输出写到一个. csv文件中，我们可以继续检查错误。</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="d58e" class="mt mu iq mp b gy mv mw l mx my">import scholarly<br/>import csv<br/>authors = authorlist.split('\n')<br/>table = [['Name','ID','Affiliation','Domain','First Year Cited','Citations','Citations (5 Years)','cites_per_year','coauthors','hindex','hindex5y','i10index','i10index5y','interests','publications']]</span><span id="20e0" class="mt mu iq mp b gy mz mw l mx my">for i in range(len(authors)):<br/>    print(i)<br/>    query = authors[i]<br/>    try:<br/>        search_query = scholarly.search_author(query)<br/>        author = next(search_query).fill()<br/>        data = [author.name, <br/>                author.id, <br/>                author.affiliation, <br/>                author.email, <br/>                'first cited year',<br/>                author.citedby, <br/>                author.citedby5y, <br/>                author.cites_per_year, <br/>                ['coauthors'], <br/>                author.hindex,<br/>                author.hindex5y,<br/>                author.i10index,<br/>                author.i10index5y,<br/>                author.interests,<br/>                ['publications']]<br/>        coauthors = []<br/>        for j in author.coauthors:<br/>            coauthors += [[j.name,j.affiliation]]<br/>        data[8] = coauthors<br/>        publications = []<br/>        for j in author.publications:<br/>            publications += [j.bib['title']]<br/>        data[-1] = publications<br/>    except:<br/>        print(query + ' is not available')<br/>        data = ['']*15<br/>        data[0] = query<br/>    table += [data]</span><span id="4f73" class="mt mu iq mp b gy mz mw l mx my">with open('FoIScholardata.csv', 'w', newline='', encoding='utf-16') as myfile:<br/>     wr = csv.writer(myfile, quoting=csv.QUOTE_ALL)<br/>     for i in table:<br/>         wr.writerow(i)</span></pre><p id="4cbc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">运行后，您现在应该在当前工作目录中有一个FoIScholardata.csv文件，可以在Microsoft Excel、Google Sheets或任何其他电子表格编辑器中打开该文件来检查数据。</p><p id="5a5e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">第1a条。证明、清理和扩充数据。</strong></p><p id="93b8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你应该做的第一件事是仔细检查你是否获得了正确的教授数据，因为那些有相同或相似名字的人可能会混淆。如果是这种情况，您可能希望在搜索查询中包括他们的机构名称/缩写以消除歧义，例如:</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="ff8a" class="mt mu iq mp b gy mv mw l mx my">authorlist = "...<br/>Linus Pauling CalTech<br/>..."</span></pre><p id="587d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你可能注意到的下一个问题是一些教授的数据不可用。如果这不是你的情况，你可以继续第1b部分。最可能的原因是他们没有创建自己的谷歌学术个人资料。为了解决这个问题，我们可以用其他网站来增加我们的数据，包括他们的机构网页或其他网站，如ResearchGate。如果您感兴趣，可以随意创建新的数据列。一旦你这样做了，如果你还需要获得他们的出版物列表，你可以使用学术以及下面的代码片段。将“用户”列表替换为谷歌学术网站上作者出版物中的缩写名称列表。</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="62c2" class="mt mu iq mp b gy mv mw l mx my">import scholarly<br/>import pandas as pd<br/>import time<br/>import random<br/>table = pd.read_csv("FoIScholardata.csv", encoding='utf-16') <br/>users = ['W Ostwald', 'MF Perutz']<br/>names = list(table.Name)<br/>surnames = []<br/>for i in names:<br/>    surnames += [i.split(' ')[-1]]<br/>for user in users:<br/>    print(user)<br/>    try:<br/>        srch=scholarly.search_pubs_query(user)<br/>    except:<br/>        print('Holding for an hour.')<br/>        time.sleep(3600)<br/>    pubs = []<br/>    noerror = True<br/>    while noerror:<br/>        time.sleep(0.5+random.random())<br/>        try:<br/>            pub = next(srch)<br/>            if user in pub.bib['author']:<br/>                pubs += [pub.bib['title']]<br/>                print(len(pubs))<br/>        except:<br/>            noerror = False<br/>    <br/>    titles = []<br/>    for i in pubs:<br/>        titles += [i.bib['title']]</span><span id="2716" class="mt mu iq mp b gy mz mw l mx my">    n = surnames.index(user.split(' ')[-1])<br/>    table.publications[n] = titles<br/>    export_csv = table.to_csv (r'fillins.csv', index = None, header=True) #Don't forget to add '.csv' at the end of the path<br/>    print('Holding for about a minute')<br/>    time.sleep(45+random.random()*30)</span></pre><p id="e874" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">根据您的兴趣修改导出的文件名，并将您的结果添加回原始FOIScholardata.csv文件。睡眠时间包括在内是为了方便逃避被封锁，但你可以随时删除/修改它们。</p><p id="efeb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">第1b节:确定作者之间的合作关系。</strong></p><p id="340a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">谷歌学术确实包括了一个共同作者的列表，这得到了概要持有者的认可，但这似乎是一个相对较新的特性。因此，它可能是在用户更新了他们的简档，或者他们的合作者创建了他们的简档等之后引入的。，可能不包括所有实际的合著者。因此，我们将基于共享同名出版物来手动添加这些协作。</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="d216" class="mt mu iq mp b gy mv mw l mx my">import pandas as pd <br/>import numpy as np<br/>table = pd.read_csv("FoIScholardata.csv")<br/>matrix = [[0]*len(table)]*len(table)<br/>matrix = np.array(matrix)<br/>newcol = []<br/>for i in range(len(table)):<br/>    print(i)<br/>    author = table.Name[i]<br/>    pubs = []<br/>    collaborators = []<br/>    if type(table.coauthors[i])==str:<br/>        pubs = eval(table.publications[i])<br/>    for j in range(len(table)):<br/>        if i == j:<br/>            continue<br/>        if type(table.coauthors[j])==str:<br/>            coms = list(set(eval(table.publications[j])) &amp; set(pubs))<br/>            matrix[i][j] = len(coms)<br/>            if matrix[i][j]&gt;0:<br/>                collaborators += [table.Name[j]]<br/>    newcol += [collaborators]<br/>table['collaborators'] = newcol<br/>export_csv = table.to_csv (r'FoIScholardata.csv', index = None, header=True) #Don't forget to add '.csv' at the end of the path</span></pre></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><p id="f2b1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">第2部分:生成主要合作者图表。</p><p id="9e80" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，我们的主要活动，虽然我们肯定有很多事情要做，我希望你留下来。有了适当组织的数据，我们将不会利用Networkx来构建和显示我们的图表。</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="8316" class="mt mu iq mp b gy mv mw l mx my">import math<br/>import pandas as pd<br/>import numpy as np<br/>import networkx as nx<br/>from matplotlib import cm<br/>import matplotlib.pyplot as plt<br/>table = pd.read_csv("FoIScholardata.csv")<br/>G=nx.Graph()<br/>for i in range(len(table)):<br/>    G.add_node(table.Name[i])<br/>for i in range(len(table)):<br/>    for j in eval(table.collaborators[i]):<br/>        G.add_edge(table.Name[i],j)<br/>domains = np.unique(table.Domain);<br/>#see <a class="ae ls" href="https://matplotlib.org/tutorials/colors/colormaps.html" rel="noopener ugc nofollow" target="_blank">https://matplotlib.org/tutorials/colors/colormaps.html</a><br/>viridis = cm.get_cmap('hsv', len(domains))<br/>from matplotlib.pyplot import figure<br/>figure(num=None, figsize=(16, 12), dpi=100, facecolor='w', edgecolor='k')<br/>pos = nx.spring_layout(G, k = 0.25)  # positions for all nodes<br/>labels = { i : table.Name[i] for i in range(0, len(table.Name) ) }<br/>options = {"alpha": 0.8}<br/>for i in range(len(G.nodes())):<br/>    nx.draw_networkx_nodes(G, pos, nodelist=[table.Name[i]],node_size=table.hindex[i]*19,node_color=viridis(list(domains).index(table.Domain[i])), **options)<br/>for i in pos:<br/>    angle = 0<br/>    plt.text(pos[i][0],pos[i][1],s=i,fontsize=12,rotation=angle, rotation_mode='anchor')<br/>plt.axis('off')<br/>plt.savefig("CollaboratorSpringGraphColor.png") # save as png<br/>plt.close()</span></pre><p id="a63d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">幸运的话，您的结果应该看起来有点像这样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi na"><img src="../Images/d08b1fd37ccb559f5133d826dddfc556.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0ecz1CnQgSYwfecR7G8rdg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd nb">图二。</strong>共同发表科学家的Spring (Force-directed)图。<em class="nc">注:这些科学家之间的联系事实上是不正确的。</em></p></figure><p id="c2b2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果您遇到颜色格式的问题，您可能需要手动修改数据中的“域”变量。在这种格式中，您可以很容易地识别该图中可能出现的子网和其他模式。其他格式也是可用的，即我们名义上的图像，圆形图。为此，我们应该分三部分稍微修改我们的代码:</p><ol class=""><li id="d045" class="ma mb iq kx b ky kz lb lc le mc li md lm me lq nd mg mh mi bi translated">修改位置声明:</li></ol><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="bda0" class="mt mu iq mp b gy mv mw l mx my">pos = nx.circular_layout(G)</span></pre><p id="009b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">2.旋转名称标签，使它们不重叠:</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="b20c" class="mt mu iq mp b gy mv mw l mx my">for j in range(len(pos)):<br/>    i = list(pos.keys())[j]<br/>    angle = 0<br/>    if ((math.atan2(pos[i][1],pos[i][0])*180/math.pi) &gt; (70)) &amp; ((math.atan2(pos[i][1],pos[i][0])*180/math.pi) &lt; (110)):<br/>        angle = 45<br/>    elif ((math.atan2(pos[i][1],pos[i][0])*180/math.pi) &gt; (-110)) &amp; ((math.atan2(pos[i][1],pos[i][0])*180/math.pi) &lt; (-70)):<br/>        angle = -45</span></pre><p id="de37" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">3.更改输出文件名:</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="0f7d" class="mt mu iq mp b gy mv mw l mx my">plt.savefig("CollaboratorCircleGraphColor.png")</span></pre><p id="5c85" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">生成的图像应该如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi na"><img src="../Images/dc87a46f4162553b1d4f58db09cc9058.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WROv_Oucfvk8UmXGg9xHDg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd nb">图三。</strong>标注的圆形图展示了所选院系之间的相互联系。<em class="nc">注:这些科学家之间的联系事实上并不正确。</em></p></figure></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><p id="c867" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">第3节:得出每位研究人员的额外个性化数据。</strong></p><p id="1ff7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，这个图表对于一幅大图来说是很好的。然而，当你接近被邀请的日期时，为了考虑到每一位教授，你可能会想把它大大地分解一下。首先，我们将建立在谷歌学者的“兴趣”概念上。正如我们已经习惯的那样，该特征可以由轮廓支架来完成，也可以不由轮廓支架来完成。然而，我们可以通过再次查看出版物标题来构建一个替代品。我们要做的是提取所有出版物的词频，并查看哪些出现在顶部。如果没有安装，您可能还需要安装get_stop_words模块。</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="1a14" class="mt mu iq mp b gy mv mw l mx my">import pandas as pd<br/>import matplotlib.pyplot as plt <br/>from stop_words import get_stop_words</span><span id="630a" class="mt mu iq mp b gy mz mw l mx my">excs = get_stop_words('en')<br/>table = pd.read_csv("FoIScholarData.csv") <br/>def valuef(x):<br/>        return worddict[x]<br/>newcol = []<br/>for i in range(len(table)):<br/>    pubs = eval(table.publications[i])<br/>    worddict = {}<br/>    for j in pubs:<br/>        words = j.lower().split(' ')<br/>        for k in words:<br/>            if k in worddict.keys():<br/>                worddict[k] += 1<br/>            else:<br/>                worddict[k] = 1<br/>    values = []<br/>    topics = []<br/>    for j in worddict:<br/>        if worddict[j] &gt; 5:<br/>            if not (j in excs):<br/>                values += [worddict[j]]<br/>                topics += [j]<br/>    width = 0.3<br/>    topics.sort(key=valuef)<br/>    values.sort()<br/>    newcol += [topics]            <br/>    plt.bar(topics[-15:], values[-15:], width, color='b')<br/>    plt.xticks(rotation = -45)<br/>    plt.gcf().subplots_adjust(bottom=0.22)<br/>    plt.title('Title Word Frequency for ' + str(table.Name[i]))<br/>    plt.savefig(str(table.Name[i]) + "_WF.png") # save as png<br/>    plt.close() # display</span><span id="610f" class="mt mu iq mp b gy mz mw l mx my">table['topics'] = newcol<br/>export_csv = table.to_csv (r'C:\Users\Masters-PC\Desktop\ProfNetworks\FoIScholardata.csv', index = None, header=True) #Don't forget to add '.csv' at the end of the path</span></pre><p id="ae72" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">除了在我们的数据电子表格中为我们提供一个新列之外，这还将为每位教授生成一个可视化效果，如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/0d1eb6d38420116927ac3386beb4fbe3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*7QJq5EwfnMLuNSX3Tt1Rgw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd nb">图3。宾夕法尼亚州立大学Charles Geier博士的出版物标题词频直方图。</strong></p></figure><p id="fd0a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这张图表立即提供了信息，因为我们可以确定研究人员对抑制控制和一般认知发展的兴趣。也许，更深入的分析，包括主题建模，以获得研究人员之间更深层次的联系是可能的，尽管这超出了本文的范围。</p><p id="74c6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="lr">更新:我决定贯彻这个承诺，并且有效地执行了一个</em> <a class="ae ls" rel="noopener" target="_blank" href="/topic-modelling-for-graduate-school-interviews-e6331721c6e0"> <em class="lr">主题建模方法</em> </a> <em class="lr">来连接这些部分。请随意查看！</em></p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><p id="1f2c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">第4部分:对每位研究人员的图表进行近距离观察。</strong></p><p id="3038" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们创建的大图表可能不适合每个研究人员的个性化报告。因此，我们可能只对提取子网络感兴趣，类似于力定向图中的可视化。为此，我们将考察他们的一阶合作者(直接)，和二阶合作者(合作者的合作者)。</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="ded7" class="mt mu iq mp b gy mv mw l mx my">import math<br/>import pandas as pd<br/>import numpy as np<br/>import networkx as nx<br/>from matplotlib import cm<br/>import matplotlib.pyplot as plt<br/>table = pd.read_csv("FoIScholardata.csv")</span><span id="37be" class="mt mu iq mp b gy mz mw l mx my">def f(n, c2, c1):<br/>    m = (c2-c1)/4<br/>    b = c2 - m*5<br/>    return m*n+b</span><span id="e309" class="mt mu iq mp b gy mz mw l mx my">for qt in range(len(table.Name)):<br/>            G=nx.Graph()    <br/>            # adding just one node:<br/>            G.add_node(table.Name[qt])<br/>            for j in eval(table.collaborators[qt]):<br/>                G.add_node(j)<br/>                G.add_edge(table.Name[qt],j)<br/>                if len(eval(table.collaborators[list(table.Name).index(j)]))&gt;0:<br/>                    for k in eval(table.collaborators[list(table.Name).index(j)]):<br/>                        G.add_node(k)<br/>                        G.add_edge(j,k)<br/>            N = len(eval(table.collaborators[qt]))<br/>            domains = np.unique(table.Domain);<br/>            #see <a class="ae ls" href="https://matplotlib.org/tutorials/colors/colormaps.html" rel="noopener ugc nofollow" target="_blank">https://matplotlib.org/tutorials/colors/colormaps.html</a><br/>            viridis = cm.get_cmap('hsv', len(domains))<br/>            from matplotlib.pyplot import figure<br/>            figure(num=None, figsize=(16, f(N, 12, 4)), dpi=100, facecolor='w', edgecolor='k')<br/>            #pos = nx.spring_layout(G, 1/(len(G.nodes)))  # positions for all nodes<br/>            #pos = nx.circular_layout(G)  # positions for all nodes<br/>            pos = nx.kamada_kawai_layout(G)  # positions for all nodes<br/>            <br/>            labels = { i : list(G.nodes())[i] for i in range(0, len(G.nodes())) }    <br/>            #nx.draw(G)<br/>            #options = {'node_size': 500, "alpha": 0.8}<br/>            options = {"alpha": 0.8}<br/>            for i in range(len(G.nodes())):<br/>                nx.draw_networkx_nodes(G, pos, nodelist=[list(G.nodes())[i]],node_size=table.hindex[list(table.Name).index(list(G.nodes())[i])]*19,node_color=viridis(list(domains).index(table.Domain[list(table.Name).index(list(G.nodes())[i])])), **options)<br/>            nx.draw_networkx_edges(G, pos, width=1.0, alpha=0.5)<br/>            for i in pos:<br/>                surname = i.split(' ')[-1]<br/>                plt.text(pos[i][0],pos[i][1],s=i,fontsize=f(N, 36, 48))<br/>            plt.axis('off')<br/>            xlims1 = plt.xlim()<br/>            plt.xlim(xlims1[0],f(N, 2, 2.5))<br/>            #plt.ylim(-3, 3)<br/>            plt.savefig(table.Name[qt]+ "CollaboratorSpringGraphColor.png") # save as png<br/>            plt.close() # display</span></pre><p id="4161" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我想这个自定义的f函数值得讨论一下。并非所有的研究人员都有相同数量的合作者，因此，我对每个条目的f函数进行了线性校准，我认为应该根据创建的图像进行适当的缩放，这样当我们进入下一部分，即生成我们的报告时，它将是美观的。这些数字可能有点武断，所以请随意调整它们以满足您的要求。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><p id="1148" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">第5部分:执行每位研究者的个性化报告。</strong></p><p id="9560" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所有这些数据都已可视化并准备就绪，我们现在可以开始最终完成我们的总结报告。为此，我们将使用Python-docx。</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="1173" class="mt mu iq mp b gy mv mw l mx my">from docx import Document<br/>from docx.shared import Inches<br/>from docx.enum.table import WD_ALIGN_VERTICAL<br/>import pandas as pd<br/>import numpy as np<br/>import networkx as nx<br/>from matplotlib import cm<br/>import matplotlib.pyplot as plt <br/>def f(n, c2, c1):<br/>    m = (c2-c1)/4<br/>    b = c2 - m*5<br/>    return m*n+b</span><span id="7379" class="mt mu iq mp b gy mz mw l mx my">table = pd.read_csv("FoIScholardata.csv", encoding='utf-16')</span><span id="6153" class="mt mu iq mp b gy mz mw l mx my">for qt in range(len(table.Name)):<br/>    print(qt)<br/>    document = Document()<br/>    try:<br/>        if type(table.Affiliation[qt])==float:<br/>            continue<br/>        document.add_heading(table.Name[qt], 0)<br/>        <br/>        p = document.add_paragraph('')<br/>        p.add_run(table.Affiliation[qt]).italic = True<br/>        p.add_run('\n'+'Interests '+str(table.interests[qt])[1:-1])<br/>        document.add_picture(table.Name[qt]+"_WF.png", width=Inches(5))<br/>        if len(eval(table.collaborators[qt]))&gt;0:<br/>            document.add_heading('Collaborators', level=1)<br/>            coltable = document.add_table(rows=1, cols=2)<br/>            coltable.cell(0, 0).vertical_alignment = WD_ALIGN_VERTICAL.CENTER            <br/>            for j in eval(table.collaborators[qt]):<br/>                pol = coltable.rows[0].cells[0].add_paragraph(<br/>                j, style='List Bullet')<br/>                   <br/>            co = coltable.rows[0].cells[1].add_paragraph()<br/>            bo = co.add_run()<br/>            bo.add_picture(table.Name[qt]+"CollaboratorSpringGraphColor.png", width=Inches(f(N, 4.9, 4)))<br/>            cols = []<br/>            ncols = []<br/>            bestcol = []<br/>            for j in eval(table.collaborators[qt]):<br/>                k = list(table.Name).index(j)<br/>                collabs = list(set(eval(table.publications[qt])) &amp; set(eval(table.publications[k])))<br/>                cols += [table.Name[k]]<br/>                ncols += [len(collabs)]<br/>                bestcol += [collabs[0]]<br/>            <br/>            <br/>            ntable = document.add_table(rows=1, cols=3)<br/>            hdr_cells = ntable.rows[0].cells<br/>            hdr_cells[0].text = 'Collaborator'<br/>            hdr_cells[1].text = 'Title'<br/>            hdr_cells[2].text = 'N'<br/>            for k in range(len(cols)):<br/>                row_cells = ntable.add_row().cells<br/>                row_cells[0].text = cols[k]<br/>                row_cells[0].width = Inches(1)<br/>                row_cells[1].text = bestcol[k]<br/>                row_cells[1].width = Inches(5)<br/>                row_cells[2].text = str(ncols[k])<br/>                row_cells[2].width = Inches(0.5)<br/>               <br/>        margin = Inches(0.5)<br/>        sections = document.sections<br/>        for section in sections:<br/>            section.top_margin = margin<br/>            section.bottom_margin = margin<br/>            section.left_margin = margin<br/>            section.right_margin = margin<br/>        <br/>        document.add_page_break()<br/>        <br/>        document.save('ScholarSheets/'+table.Name[qt]+'.docx')<br/>    except:<br/>        print(str(qt) + 'not')</span></pre><p id="ad1f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这将为我们留下一个最终的Word文档，看起来有点像这样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/8ee89ec1ceebeb7a60136e70a8edb89c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Eca8Pxy9CY_qfiFUFHI6EA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd nb">图4。</strong>Charles Geier博士的示例输出文档。</p></figure><p id="19fd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有了这份文件，我们现在有了关于我们教授的数据的简明摘要，并可以开始编辑笔记和执行更有针对性的文献搜索，以选择作为面试过程中您的审查的一部分。我们可以通过阅读教授之间的共享论文，制定潜在的问题，并记下笔记来一举两得。如果你能走到这一步，谢谢你的支持，我希望你这个赛季表现最好！如果您想更深入地了解，请不要忘记查看第2部分的<a class="ae ls" rel="noopener" target="_blank" href="/topic-modelling-for-graduate-school-interviews-e6331721c6e0">主题建模</a>。</p></div></div>    
</body>
</html>