<html>
<head>
<title>Finding the Needle in a Haystack on a Quantum Computer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在量子计算机上大海捞针</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/finding-the-needle-in-a-haystack-on-a-quantum-computer-d658bce3e3cc?source=collection_archive---------43-----------------------#2020-07-10">https://towardsdatascience.com/finding-the-needle-in-a-haystack-on-a-quantum-computer-d658bce3e3cc?source=collection_archive---------43-----------------------#2020-07-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e5c1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Grover 的量子搜索算法在 O(√N)时间内从无序元素列表中找到目标元素。</h2></div><p id="e236" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">给你一个数字列表和一个目标数字，要求你在列表中找到目标数字出现的索引。如果列表已排序，您可以使用搜索算法，如二分搜索法。但是如果列表没有被排序，你真的没什么可以做的；您只需遍历整个列表，直到找到元素。就算法复杂性而言，这需要 O(N)时间。然而，使用量子计算机，你可以在 O(√N)时间内解决这个问题。本文解释了这是如何通过 Grover 的搜索算法实现的。</p><p id="38b2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="le">如果你是量子计算的新手，你应该先读读这本简短的入门书:</em> </strong> <a class="ae lf" rel="noopener" target="_blank" href="/quantum-parallelism-where-quantum-computers-get-their-mojo-from-66c93bd09855?source=friends_link&amp;sk=e5c03e138045cee2476d7804e2df3bd3"> <strong class="kk iu"> <em class="le">量子并行性——量子计算机从</em> </strong> </a> <strong class="kk iu"> <em class="le">那里得到它们的魔咒。</em> </strong></p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/37291721bf590a63ac4147c4ecba73b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Ky32xN7iAew0x5yS.jpg"/></div></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">大海捞针(图片来自<a class="ae lf" href="https://pixabay.com/photos/needle-hay-needle-in-a-haystack-1419606/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="a9ed" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们从框架问题开始。我们被给予:</p><ul class=""><li id="84de" class="lw lx it kk b kl km ko kp kr ly kv lz kz ma ld mb mc md me bi translated">一组 N 个元素<code class="fe mf mg mh mi b">X = {x_1, …, x_i, … ,x_N}</code>，使得每个<code class="fe mf mg mh mi b">x_i</code>是由 0 和 1 组成的 m 位串。</li><li id="9ed6" class="lw lx it kk b kl mj ko mk kr ml kv mm kz mn ld mb mc md me bi translated">目标元素<code class="fe mf mg mh mi b">x*</code>也是由 0 和 1 组成的 m 位字符串</li><li id="993a" class="lw lx it kk b kl mj ko mk kr ml kv mm kz mn ld mb mc md me bi translated">函数<em class="le"> f </em>将 m 位字符串作为输入，如果该字符串为<code class="fe mf mg mh mi b">x*</code>则返回 1，否则返回 0。这个函数可以写成:</li></ul><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/c35414889d8e9e4901b040dcf70b4e57.png" data-original-src="https://miro.medium.com/v2/resize:fit:634/format:webp/1*84s3h1BfAFt8bzPR-q6W1g.png"/></div></figure><p id="36c1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Grover 的搜索分三步进行，如下所述。</p><p id="5118" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">步骤 1:设置状态</strong></p><p id="1ed6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个量子态建立在基态的相等叠加上。作为一个例子，考虑 N=8。我们使用 3 个量子位设置状态如下:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/d53c8abcf7470f56ea86c953e8e8ff5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1338/format:webp/1*Rh5Q61oirVpR71ZyXmWOvQ.png"/></div></figure><p id="ca12" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">第二步:相位反转</strong></p><p id="d48a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在第二步中，如果<code class="fe mf mg mh mi b">f(x)=1</code>我们翻转每个元素<code class="fe mf mg mh mi b">x</code>的振幅，如果<code class="fe mf mg mh mi b">f(x)=0</code>保持不变。这是使用实现以下单式门 O 的电路来执行的:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/97342393054cf762ed6e4c96b2ee46e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:550/format:webp/1*9pI3bGPV-ZatlzQK5EzqLQ.png"/></div></figure><p id="b974" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设我们的目标元素<code class="fe mf mg mh mi b">x*</code>出现在第四个位置。应用 O 门将为我们提供:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi mr"><img src="../Images/43ebcb70a8a18d6d1337924653b7489a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1270/format:webp/1*TByntqyk3P5GyeOb5j4IJA.png"/></div></div></figure><p id="bbbf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">第三步:围绕平均值反转</strong></p><p id="a0cb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第三步称为围绕平均值的<em class="le">反转</em>涉及围绕它们的集合平均值翻转所有元素。这是使用 Grover 扩散算子实现的，该算子由下式给出:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/200c84c79e42c221b3845c270d2eb5ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:638/format:webp/1*daHY9Rts2jjd7bApFdgumg.png"/></div></figure><p id="7cc3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将这个算符应用于我们的量子态，我们得到:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/e61f22ff90b211f2e581eeb054b90ca4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1290/format:webp/1*OvJQchZPqSAW9YxNgtCIfw.png"/></div></figure><p id="6641" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这完成了一个回合。如果我们在这一点上测量系统，我们将得到目标元素作为概率(5/(4*√2))等于 78%的结果。</p><p id="0960" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二步和第三步重复√N 次，最大化这个概率。在第二次迭代之后，我们得到下面的状态，它将以 95%的概率找到目标元素。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/30f112fbd6520c335316a2d079bd17fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/format:webp/1*-bpSyLhEQY8nLSq46ZPBNw.png"/></div></figure><p id="4af0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">像许多量子算法一样，格罗弗的搜索是概率性的。它以很高的概率给你正确的结果。为了使这个概率足够大以至于实际上有用，您可能需要多次运行它。</p><p id="1c85" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样的算法也可以用来查找 k 个匹配条目，而不是单个目标元素。已经提出了许多变体。其中之一是 Durr 和 Hoyer 最小化算法，该算法从列表中找到最小元素的索引——这在量子机器学习中找到了有趣的应用。详见:<a class="ae lf" href="https://arxiv.org/abs/2006.12025" rel="noopener ugc nofollow" target="_blank">监督学习的量子计算方法</a>。</p></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><p id="1f25" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">如果你喜欢这篇文章，可以在</em> <a class="ae lf" href="https://medium.com/@diningphilosopher" rel="noopener"> <em class="le">中型</em> </a> <em class="le">上查看我的其他作品，在</em><a class="ae lf" href="https://www.linkedin.com/in/kulkarniviraj/" rel="noopener ugc nofollow" target="_blank"><em class="le">LinkedIn</em></a><em class="le">或</em><a class="ae lf" href="https://twitter.com/VirajZero" rel="noopener ugc nofollow" target="_blank"><em class="le">Twitter</em></a><em class="le">，查看我的</em> <a class="ae lf" href="https://virajkulkarni.org/" rel="noopener ugc nofollow" target="_blank"> <em class="le">个人网页</em> </a> <em class="le">，或发邮件给我</em><a class="ae lf" href="mailto:%20viraj@berkeley.edu" rel="noopener ugc nofollow" target="_blank"><em class="le">viraj@berkeley.edu</em></a></p></div></div>    
</body>
</html>