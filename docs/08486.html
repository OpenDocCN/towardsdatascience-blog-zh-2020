<html>
<head>
<title>How I preprocessed text data with Regular Expressions for my Text classification task using CNN</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何使用CNN为我的文本分类任务使用正则表达式预处理文本数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-i-preprocessed-text-data-using-regular-expressions-for-my-text-classification-task-cnn-cb206e7274ed?source=collection_archive---------17-----------------------#2020-06-20">https://towardsdatascience.com/how-i-preprocessed-text-data-using-regular-expressions-for-my-text-classification-task-cnn-cb206e7274ed?source=collection_archive---------17-----------------------#2020-06-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><h1 id="e040" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">使用正则表达式进行预处理的步骤</h1><ol class=""><li id="6052" class="ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">从文件名中提取标签和文件编号</li><li id="9420" class="ko kp it kq b kr lg kt lh kv li kx lj kz lk lb lc ld le lf bi translated">提取电子邮件</li><li id="ef3b" class="ko kp it kq b kr lg kt lh kv li kx lj kz lk lb lc ld le lf bi translated">提取主题</li><li id="e213" class="ko kp it kq b kr lg kt lh kv li kx lj kz lk lb lc ld le lf bi translated">去收缩</li><li id="b286" class="ko kp it kq b kr lg kt lh kv li kx lj kz lk lb lc ld le lf bi translated">正在从以下位置删除写入:</li><li id="b515" class="ko kp it kq b kr lg kt lh kv li kx lj kz lk lb lc ld le lf bi translated">删除括号&lt;&gt;、()中的数据</li><li id="d719" class="ko kp it kq b kr lg kt lh kv li kx lj kz lk lb lc ld le lf bi translated">删除换行符、制表符</li><li id="f660" class="ko kp it kq b kr lg kt lh kv li kx lj kz lk lb lc ld le lf bi translated">用<strong class="kq iu">分块</strong>预处理人名和城市名</li><li id="4201" class="ko kp it kq b kr lg kt lh kv li kx lj kz lk lb lc ld le lf bi translated">移除数字</li><li id="735f" class="ko kp it kq b kr lg kt lh kv li kx lj kz lk lb lc ld le lf bi translated">使用<strong class="kq iu">匹配将“_word_”、“_word”、“word_”替换为word会捕获</strong></li><li id="47b6" class="ko kp it kq b kr lg kt lh kv li kx lj kz lk lb lc ld le lf bi translated">多方面的</li></ol><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi ll"><img src="../Images/8f57e83c97d4d4efb432160d45965cb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wf89DaXXNLF5xCr-rhwOzQ.png"/></div></div></figure><h1 id="78bd" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">介绍</h1><p id="b67b" class="pw-post-body-paragraph lx ly it kq b kr ks lz ma kt ku mb mc kv md me mf kx mg mh mi kz mj mk ml lb im bi mm translated">自然语言处理是人工智能中处理语言数据的一个分支。它基本上是一个研究人和机器之间互动的分支。机器翻译、文本到语音、文本分类——这些是自然语言处理的一些应用。</p><blockquote class="mv"><p id="1e39" class="mw mx it bd my mz na nb nc nd ne lb dk translated">在本文中，我将使用1D卷积神经网络对文本数据进行分类，广泛使用正则表达式进行字符串预处理和过滤。</p></blockquote><blockquote class="nf ng nh"><p id="34d2" class="lx ly ni kq b kr nj lz ma kt nk mb mc nl nm me mf nn no mh mi np nq mk ml lb im bi translated"><strong class="kq iu">本文的重点是如何使用正则表达式进行文本数据预处理</strong></p></blockquote><h1 id="4e53" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">问题陈述</h1><p id="c78d" class="pw-post-body-paragraph lx ly it kq b kr ks lz ma kt ku mb mc kv md me mf kx mg mh mi kz mj mk ml lb im bi translated">数据是<strong class="kq iu">新闻组20 </strong>数据集。我们的数据中总共有20种类型的文档。文档的名称包含标签和标签中的编号。格式为<strong class="kq iu">' class label _ DocumentNumberInThatLabel '。</strong>数据可以从<a class="ae nr" href="https://drive.google.com/file/d/1rxD15nyeIPIAZ-J2VYPrDRZI66-TBWvM/view" rel="noopener ugc nofollow" target="_blank">这里</a>下载。</p><p id="4c00" class="pw-post-body-paragraph lx ly it kq b kr ns lz ma kt nt mb mc kv nu me mf kx nv mh mi kz nw mk ml lb im bi translated">我们的任务是对文本数据进行预处理，并将其分类到正确的标签中。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi nx"><img src="../Images/5dd993bc11bed65a66859c973f254d65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3PBD8-nGd_VYZTf8hrdYVw.png"/></div></div><p class="ny nz gj gh gi oa ob bd b be z dk translated">类别标签的计数图</p></figure><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi oc"><img src="../Images/6e1f39a09666c17fdba6e5d200cc694e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j3kh0ToZpAenpxWXkUkoZw.png"/></div></div><p class="ny nz gj gh gi oa ob bd b be z dk translated">示例数据(我们将在整篇文章中跟踪这些数据)</p></figure><h1 id="cfa3" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">使用正则表达式预处理</h1><p id="6a65" class="pw-post-body-paragraph lx ly it kq b kr ks lz ma kt ku mb mc kv md me mf kx mg mh mi kz mj mk ml lb im bi translated">我们已经创建了一个函数，它将原始数据作为输入，并将经过预处理的过滤数据作为输出。</p><h2 id="f6fa" class="od jr it bd js oe of dn jw og oh dp ka kv oi oj ke kx ok ol ki kz om on km oo bi translated">I .从文件名中提取标签和文件编号</h2><p id="de0b" class="pw-post-body-paragraph lx ly it kq b kr ks lz ma kt ku mb mc kv md me mf kx mg mh mi kz mj mk ml lb im bi translated">我们将使用适用于字符串的拆分方法。</p><pre class="lm ln lo lp gt op oq or os aw ot bi"><span id="ecca" class="od jr it oq b gy ou ov l ow ox">1   for filename in os.listdir(path):<br/>2       i,j = filename.split('_')<br/>3       j = int(j.split('.')[0])<br/>4       label.append(i) <br/>5       doc_num.append(j)</span></pre><p id="2b1b" class="pw-post-body-paragraph lx ly it kq b kr ns lz ma kt nt mb mc kv nu me mf kx nv mh mi kz nw mk ml lb im bi translated">对于路径中的所有文件名，我们获取文件名并将其拆分为“_”。<strong class="kq iu">该功能。split()使用paranthesis中的元素来拆分字符串。</strong>同样，我们再次使用它来过滤<strong class="kq iu">。文件名中的txt </strong>。</p><pre class="lm ln lo lp gt op oq or os aw ot bi"><span id="cfd9" class="od jr it oq b gy ou ov l ow ox"><strong class="oq iu">Ex.- we get i = talk.religion.misc and j = 82778</strong></span></pre><h2 id="5e3d" class="od jr it bd js oe of dn jw og oh dp ka kv oi oj ke kx ok ol ki kz om on km oo bi translated"><strong class="ak">二。提取电子邮件</strong></h2><p id="3f93" class="pw-post-body-paragraph lx ly it kq b kr ks lz ma kt ku mb mc kv md me mf kx mg mh mi kz mj mk ml lb im bi translated">我们的任务是找到一个文档中的所有电子邮件，提取“@”后的文本，并用“.”分割，去掉所有小于3的字，去掉”。com”。将所有内容组合成一个字符串。最后，我们将电子邮件从我们的文本中删除。</p><pre class="lm ln lo lp gt op oq or os aw ot bi"><span id="112e" class="od jr it oq b gy ou ov l ow ox">Ex.-<br/><strong class="oq iu">[bskendig@netcom.com , joslin@pogo.isp.pitt.edu] → </strong></span><span id="ec92" class="od jr it oq b gy oy ov l ow ox"><strong class="oq iu">[netcom, pogo.isp.pitt.edu] → [netcom, pogo, isp, pitt, edu] →</strong></span><span id="7bd1" class="od jr it oq b gy oy ov l ow ox"><strong class="oq iu">“netcom pogo isp pitt edu”</strong></span></pre><p id="bae7" class="pw-post-body-paragraph lx ly it kq b kr ns lz ma kt nt mb mc kv nu me mf kx nv mh mi kz nw mk ml lb im bi translated">以下代码执行任务</p><pre class="lm ln lo lp gt op oq or os aw ot bi"><span id="0f00" class="od jr it oq b gy ou ov l ow ox">em = [] # for each doc<br/>st = ""  # for each doc</span><span id="8c0f" class="od jr it oq b gy oy ov l ow ox">#extracting email<br/>for i in re.findall(r'[\w\-\.]+@[\w\.-]+\b', f):  #extracting email <br/>    temp=[]<br/>    temp = i.split('@')[1]      #taking text after @<br/>    temp = temp.split('.')     #a list containing words split by "."</span><span id="f553" class="od jr it oq b gy oy ov l ow ox">    if 'com' in temp:<br/>        temp.remove('com')<br/> <br/>   for i in temp:            #removing words less than 3<br/>        if len(i)&gt;2:<br/>            em.append(i)</span><span id="4ae7" class="od jr it oq b gy oy ov l ow ox">for i in em:            #joining all the words in a string<br/>    st+=i<br/>    st+=' '</span><span id="8963" class="od jr it oq b gy oy ov l ow ox">re.sub(r'[\w\-\.]+@[\w\.-]+\b',' ')    #removing the email</span></pre><p id="e3e4" class="pw-post-body-paragraph lx ly it kq b kr ns lz ma kt nt mb mc kv nu me mf kx nv mh mi kz nw mk ml lb im bi translated"><strong class="kq iu">正则表达式解释</strong></p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi oz"><img src="../Images/65bd4b7d5c6043fcb20e01aed1e7d11f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kN45MYnJ9fApflJpHN-QOg.png"/></div></div></figure><p id="1b33" class="pw-post-body-paragraph lx ly it kq b kr ns lz ma kt nt mb mc kv nu me mf kx nv mh mi kz nw mk ml lb im bi translated"><strong class="kq iu"> \w → </strong>匹配任何字母数字字符</p><p id="f383" class="pw-post-body-paragraph lx ly it kq b kr ns lz ma kt nt mb mc kv nu me mf kx nv mh mi kz nw mk ml lb im bi translated"><strong class="kq iu"> \-\。→ </strong>匹配“-”和。”(“\ "用于转义特殊字符)</p><p id="e559" class="pw-post-body-paragraph lx ly it kq b kr ns lz ma kt nt mb mc kv nu me mf kx nv mh mi kz nw mk ml lb im bi translated"><strong class="kq iu"> []+ → </strong>匹配括号内的一个或多个字符</p><p id="2f3e" class="pw-post-body-paragraph lx ly it kq b kr ns lz ma kt nt mb mc kv nu me mf kx nv mh mi kz nw mk ml lb im bi translated"><strong class="kq iu">……………………………………………………。@ → </strong>匹配[\w\-\后的“@”。]</p><h2 id="4a89" class="od jr it bd js oe of dn jw og oh dp ka kv oi oj ke kx ok ol ki kz om on km oo bi translated">三提取主体</h2><p id="4ab9" class="pw-post-body-paragraph lx ly it kq b kr ks lz ma kt ku mb mc kv md me mf kx mg mh mi kz mj mk ml lb im bi translated">在这项任务中，我们将只保留来自主题部分的有用信息。<strong class="kq iu">主题:</strong>将被删除，所有非字母数字字符将被删除。以下代码执行任务-</p><pre class="lm ln lo lp gt op oq or os aw ot bi"><span id="3dcd" class="od jr it oq b gy ou ov l ow ox">#extracting subject<br/>temp1 = re.findall(r'^Subject.*$',f, re.MULTILINE)</span><span id="4b86" class="od jr it oq b gy oy ov l ow ox">sub = temp1[0]<br/>sub = sub[7:]   #Truncate Subject</span><span id="8328" class="od jr it oq b gy oy ov l ow ox">for i in string.punctuation:   #remove all the non-alphanumeric<br/>    sub = sub.replace(i," ")</span><span id="c3fd" class="od jr it oq b gy oy ov l ow ox">    sub = re.sub(r"re","",sub, flags=re.IGNORECASE) #removing Re</span><span id="a1ab" class="od jr it oq b gy oy ov l ow ox">    sub = sub.lower()  #lower-casing</span><span id="d8d5" class="od jr it oq b gy oy ov l ow ox">re.sub(r'Subject.*$'," ", flags=re.MULTILINE)  #removing subject</span></pre><p id="dd6e" class="pw-post-body-paragraph lx ly it kq b kr ns lz ma kt nt mb mc kv nu me mf kx nv mh mi kz nw mk ml lb im bi translated"><strong class="kq iu">正则表达式解释</strong></p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi pa"><img src="../Images/9d59b59ee14828163b048d8b5fdf67a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YCpj-ljVAvrIb8y4rOscqw.png"/></div></div></figure><p id="4b0b" class="pw-post-body-paragraph lx ly it kq b kr ns lz ma kt nt mb mc kv nu me mf kx nv mh mi kz nw mk ml lb im bi translated"><strong class="kq iu"> ^ → </strong>占了字符串的开头。</p><p id="a1de" class="pw-post-body-paragraph lx ly it kq b kr ns lz ma kt nt mb mc kv nu me mf kx nv mh mi kz nw mk ml lb im bi translated"><strong class="kq iu"> Subject → </strong>匹配字符串的开头是单词Subject。</p><p id="0557" class="pw-post-body-paragraph lx ly it kq b kr ns lz ma kt nt mb mc kv nu me mf kx nv mh mi kz nw mk ml lb im bi translated"><strong class="kq iu">。* </strong> →匹配主题后的0个或多个单词。</p><p id="787a" class="pw-post-body-paragraph lx ly it kq b kr ns lz ma kt nt mb mc kv nu me mf kx nv mh mi kz nw mk ml lb im bi translated"><strong class="kq iu"> $ </strong> →检测字符串的结尾。</p><p id="15d1" class="pw-post-body-paragraph lx ly it kq b kr ns lz ma kt nt mb mc kv nu me mf kx nv mh mi kz nw mk ml lb im bi translated"><strong class="kq iu">注意:</strong>“<strong class="kq iu">^</strong>”对于确保Regex只检测标题的“主题”很重要。它不应该在我们文本的任何其他部分检测到单词“subject”。</p><h2 id="3764" class="od jr it bd js oe of dn jw og oh dp ka kv oi oj ke kx ok ol ki kz om on km oo bi translated">四。去收缩</h2><p id="3afe" class="pw-post-body-paragraph lx ly it kq b kr ks lz ma kt ku mb mc kv md me mf kx mg mh mi kz mj mk ml lb im bi translated">用我会代替我会，用不能代替T21等等..</p><pre class="lm ln lo lp gt op oq or os aw ot bi"><span id="5517" class="od jr it oq b gy ou ov l ow ox"># specific<br/>f = re.sub(r"won't", "will not", f)<br/>f = re.sub(r"can\'t", "can not", f)</span><span id="ab9b" class="od jr it oq b gy oy ov l ow ox"># general<br/>f = re.sub(r"n\'t", " not", f)<br/>f = re.sub(r"\'re", " are", f)<br/>f = re.sub(r"\'s", " is", f)<br/>f = re.sub(r"\'d", " would", f)<br/>f = re.sub(r"\'ll", " will", f)<br/>f = re.sub(r"\'t", " not", f)<br/>f = re.sub(r"\'ve", " have", f)<br/>f = re.sub(r"\'m", " am", f)</span></pre><h2 id="1687" class="od jr it bd js oe of dn jw og oh dp ka kv oi oj ke kx ok ol ki kz om on km oo bi translated">动词 （verb的缩写）正在从以下位置删除写入:</h2><p id="3862" class="pw-post-body-paragraph lx ly it kq b kr ks lz ma kt ku mb mc kv md me mf kx mg mh mi kz mj mk ml lb im bi translated">删除写在“写给:”和“发件人:”下的地址等内容。</p><pre class="lm ln lo lp gt op oq or os aw ot bi"><span id="8d90" class="od jr it oq b gy ou ov l ow ox">f = re.sub(r"Write to:.*$","",f, flags=re.MULTILINE)           </span><span id="baaa" class="od jr it oq b gy oy ov l ow ox">f = re.sub(r"From:.*$","",f, flags=re.MULTILINE)               </span><span id="dfdf" class="od jr it oq b gy oy ov l ow ox">f = re.sub(r"or:","",f,flags=re.MULTILINE)</span></pre><p id="623f" class="pw-post-body-paragraph lx ly it kq b kr ns lz ma kt nt mb mc kv nu me mf kx nv mh mi kz nw mk ml lb im bi translated"><strong class="kq iu">注意- "$" </strong>匹配字符串的结尾只是为了安全</p><h2 id="b2d6" class="od jr it bd js oe of dn jw og oh dp ka kv oi oj ke kx ok ol ki kz om on km oo bi translated"><strong class="ak">六。删除括号内的数据&lt; &gt;，()</strong></h2><p id="b270" class="pw-post-body-paragraph lx ly it kq b kr ks lz ma kt ku mb mc kv md me mf kx mg mh mi kz mj mk ml lb im bi translated">删除括号内的所有数据。</p><p id="0f3d" class="pw-post-body-paragraph lx ly it kq b kr ns lz ma kt nt mb mc kv nu me mf kx nv mh mi kz nw mk ml lb im bi translated">我的名字是拉梅什(钦图)→我的名字是拉梅什</p><pre class="lm ln lo lp gt op oq or os aw ot bi"><span id="bb4c" class="od jr it oq b gy ou ov l ow ox">f = re.sub(r"&lt;.*&gt;","",f, flags=re.MULTILINE) </span><span id="53cb" class="od jr it oq b gy oy ov l ow ox">f = re.sub(r"\(.*\)","",f,flags=re.MULTILINE)                 </span></pre><h2 id="cf55" class="od jr it bd js oe of dn jw og oh dp ka kv oi oj ke kx ok ol ki kz om on km oo bi translated"><span class="l mn mo mp bm mq mr ms mt mu di">V</span>T28】II。移除换行符、制表符</h2><pre class="lm ln lo lp gt op oq or os aw ot bi"><span id="25cb" class="od jr it oq b gy ou ov l ow ox">#delete /,-,/n,</span><span id="c87b" class="od jr it oq b gy oy ov l ow ox">f = re.sub(r"[\n\t\-\\\/]"," ",f, flags=re.MULTILINE)</span></pre><h2 id="0e62" class="od jr it bd js oe of dn jw og oh dp ka kv oi oj ke kx ok ol ki kz om on km oo bi translated">八。组块</h2><p id="e7a2" class="pw-post-body-paragraph lx ly it kq b kr ks lz ma kt ku mb mc kv md me mf kx mg mh mi kz mj mk ml lb im bi translated">组块是基于词性标注从句子中提取有价值的短语的过程。它给句子增加了更多的结构，帮助机器更准确地理解句子的意思。你可以阅读尼基塔·巴查尼<a class="pb pc ep" href="https://medium.com/u/e44ae4099762?source=post_page-----cb206e7274ed--------------------------------" rel="noopener" target="_blank">的这篇</a><a class="ae nr" rel="noopener" target="_blank" href="/chunking-in-nlp-decoded-b4a71b2b4e24">文章</a>，她详细解释了分块。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi pd"><img src="../Images/aaf5460e841d82f4e8301fce54cb9a5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aLn-2hkpbJBS5WCCORKoJA.png"/></div></div><p class="ny nz gj gh gi oa ob bd b be z dk translated">组块的例子</p></figure><p id="7e15" class="pw-post-body-paragraph lx ly it kq b kr ns lz ma kt nt mb mc kv nu me mf kx nv mh mi kz nw mk ml lb im bi translated">我们的任务是在组块的帮助下删除城市名并给城市名添加下划线。Ex- Ramesh将被删除，新德里→新德里</p><pre class="lm ln lo lp gt op oq or os aw ot bi"><span id="793c" class="od jr it oq b gy ou ov l ow ox">chunks=[]<br/>chunks=(list(ne_chunk(pos_tag(word_tokenize(f)))))</span><span id="b29b" class="od jr it oq b gy oy ov l ow ox">for i in chunks:<br/>    if type(i)==Tree:<br/>        if i.label() == "GPE":<br/>            j = i.leaves()<br/>                if len(j)&gt;1:   #if new_delhi or bigger name<br/>                    gpe = "_".join([term for term,pos in j])</span><span id="6000" class="od jr it oq b gy oy ov l ow ox">                    f = re.sub(rf'{j[1][0]}',gpe,f, flags=re.MULTILINE)              #replacing delhi with new_delhi<br/></span><span id="a4bf" class="od jr it oq b gy oy ov l ow ox">                    f = re.sub(rf'\b{j[0][0]}\b',"",f, flags=re.MULTILINE)       #deleting new, \b is important</span><span id="d229" class="od jr it oq b gy oy ov l ow ox">        if i.label()=="PERSON":           # deleting Ramesh         <br/>            for term,pog in i.leaves():<br/>                f = re.sub(re.escape(term),"",f, flags=re.MULTILINE)</span></pre><p id="c513" class="pw-post-body-paragraph lx ly it kq b kr ns lz ma kt nt mb mc kv nu me mf kx nv mh mi kz nw mk ml lb im bi translated">正如我们上面看到的，组块有三个部分- <strong class="kq iu">标签，术语，词性。如果类型是树，标签是GPE，那么它是一个地方。如果这个地方有不止一个单词，我们用“_”将它们连接起来。</strong></p><pre class="lm ln lo lp gt op oq or os aw ot bi"><span id="1aaa" class="od jr it oq b gy ou ov l ow ox">f = re.sub(rf'{j[1][0]}',gpe,f, flags=re.MULTILINE)<br/>f = re.sub(rf'\b{j[0][0]}\b',"",f, flags=re.MULTILINE)</span></pre><p id="eacc" class="pw-post-body-paragraph lx ly it kq b kr ns lz ma kt nt mb mc kv nu me mf kx nv mh mi kz nw mk ml lb im bi translated">我们一起使用了格式字符串和正则表达式。“j”包含叶，因此j[1][0]包含第二项，即<strong class="kq iu">德里</strong>，j[0][0]包含第一项，即<strong class="kq iu">新。所以，我们把德里换成了新德里，删掉了new。\b是检测单词的结尾。</strong></p><pre class="lm ln lo lp gt op oq or os aw ot bi"><span id="9063" class="od jr it oq b gy ou ov l ow ox">f = re.sub(re.escape(term),"",f, flags=re.MULTILINE)</span></pre><p id="a613" class="pw-post-body-paragraph lx ly it kq b kr ns lz ma kt nt mb mc kv nu me mf kx nv mh mi kz nw mk ml lb im bi translated">为了删除Person，我们使用了<strong class="kq iu"> re.escape </strong>,因为这个术语可以包含一个字符，这个字符对于regex来说是一个特殊的字符，但是我们想把它仅仅当作一个字符串。</p><h2 id="5d7d" class="od jr it bd js oe of dn jw og oh dp ka kv oi oj ke kx ok ol ki kz om on km oo bi translated">九。移除数字</h2><pre class="lm ln lo lp gt op oq or os aw ot bi"><span id="3b6d" class="od jr it oq b gy ou ov l ow ox">f = re.sub(r'\d',"",f, flags=re.MULTILINE)                               </span></pre><h2 id="9a77" class="od jr it bd js oe of dn jw og oh dp ka kv oi oj ke kx ok ol ki kz om on km oo bi translated">X.将“_word_”、“_word”、“word_”替换为word</h2><pre class="lm ln lo lp gt op oq or os aw ot bi"><span id="933c" class="od jr it oq b gy ou ov l ow ox">f = re.sub(r"\b_([a-zA-z]+)_\b",r"\1",f) #replace _word_ to word<br/>   <br/>f = re.sub(r"\b_([a-zA-z]+)\b",r"\1",f) #replace_word to word</span><span id="f3c5" class="od jr it oq b gy oy ov l ow ox">f = re.sub(r"\b([a-zA-z]+)_\b",r"\1",f) #replace word_ to word</span></pre><p id="e19a" class="pw-post-body-paragraph lx ly it kq b kr ns lz ma kt nt mb mc kv nu me mf kx nv mh mi kz nw mk ml lb im bi translated">这里，我们使用一种叫做<strong class="kq iu">的匹配捕获。</strong></p><p id="680b" class="pw-post-body-paragraph lx ly it kq b kr ns lz ma kt nt mb mc kv nu me mf kx nv mh mi kz nw mk ml lb im bi translated">在我们使用“<strong class="kq iu"> \b_([a-zA-z]+)_\b”获得字符串之后，</strong>匹配捕获使我们能够只使用匹配字符串的特定部分。这里我们在下划线之间有一组并列句。因此这里有一组。我们使用<strong class="kq iu"> r '\1' </strong>来提取特定的组。简单的例子来解释这个概念。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi pe"><img src="../Images/47d4156152543b114cec980d550c2786.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iQcidgG2Nm9HhfkrZAdMkw.png"/></div></div><p class="ny nz gj gh gi oa ob bd b be z dk translated">有两个参数，所以有两个匹配捕获</p></figure><h2 id="0f2a" class="od jr it bd js oe of dn jw og oh dp ka kv oi oj ke kx ok ol ki kz om on km oo bi translated">XI杂项</h2><p id="7a4b" class="pw-post-body-paragraph lx ly it kq b kr ks lz ma kt ku mb mc kv md me mf kx mg mh mi kz mj mk ml lb im bi translated">{m，n} →这用于匹配m和n之间的字符数。m可以是零，n可以是无穷大。</p><pre class="lm ln lo lp gt op oq or os aw ot bi"><span id="2385" class="od jr it oq b gy ou ov l ow ox">f = re.sub(r"\b[a-zA-Z]{1}_([a-zA-Z]+)",r"\1",f) #d_berlin to berlin</span><span id="c91a" class="od jr it oq b gy oy ov l ow ox">f = re.sub(r"\b[a-zA-Z]{2}_([a-zA-Z]+)",r"\1",f) #mr_cat to cat</span><span id="aa5a" class="od jr it oq b gy oy ov l ow ox">f = f.lower()      #lower case</span><span id="14b5" class="od jr it oq b gy oy ov l ow ox">f = re.sub(r'\b\w{1,2}\b'," ",f) #remove words &lt;2</span><span id="335a" class="od jr it oq b gy oy ov l ow ox">f = re.sub(r"\b\w{15,}\b"," ",f) #remove words &gt;15</span><span id="a180" class="od jr it oq b gy oy ov l ow ox">f = re.sub(r"[^a-zA-Z_]"," ",f)  #keep only alphabets and _<br/>                                        <br/>f = re.sub(r" {2,}", " ", f, flags=re.MULTILINE) # REMOVE THE EXTRA SPACES</span></pre><h1 id="5ed2" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">最终数据准备</h1><p id="fb4c" class="pw-post-body-paragraph lx ly it kq b kr ks lz ma kt ku mb mc kv md me mf kx mg mh mi kz mj mk ml lb im bi translated">如前所述，整个预处理被放在一个返回五个值的函数中。将我们的数据传递给这个函数-</p><pre class="lm ln lo lp gt op oq or os aw ot bi"><span id="10c8" class="od jr it oq b gy ou ov l ow ox">doc_num, label, email, subject, text = preprocessing(prefix)</span></pre><p id="003e" class="pw-post-body-paragraph lx ly it kq b kr ns lz ma kt nt mb mc kv nu me mf kx nv mh mi kz nw mk ml lb im bi translated">创建包含预处理的电子邮件、主题和文本的数据帧。类别标签已被整数取代。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi pf"><img src="../Images/8b0bc082e846d54e0bc0b70acad09478.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NzgeH7ISsRkKNt4fEFL3IA.png"/></div></div><p class="ny nz gj gh gi oa ob bd b be z dk translated">预处理文本是这三者的串联</p></figure><h1 id="0df5" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">…向量化…</h1><p id="6be4" class="pw-post-body-paragraph lx ly it kq b kr ks lz ma kt ku mb mc kv md me mf kx mg mh mi kz mj mk ml lb im bi translated">在将数据分成训练和测试(0.25)之后，我们将数据矢量化成算法可以理解的正确形式。我们已经使用了来自keras 的<strong class="kq iu"> tokenizer函数，它将用于嵌入向量。</strong></p><blockquote class="nf ng nh"><p id="c0b6" class="lx ly ni kq b kr ns lz ma kt nt mb mc nl nu me mf nn nv mh mi np nw mk ml lb im bi translated"><strong class="kq iu"> <em class="it">最后对文本进行编码并填充，创建统一的数据集。</em>T13】</strong></p></blockquote><h1 id="4d35" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">模型</h1><p id="f732" class="pw-post-body-paragraph lx ly it kq b kr ks lz ma kt ku mb mc kv md me mf kx mg mh mi kz mj mk ml lb im bi translated">我们训练该数据集的模型由三个'<strong class="kq iu">一维卷积'</strong>层组成，这些层连接在一起，并通过下面给出的其他各层。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/46119ceb598abcf839ac163972eedb5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1134/format:webp/1*jwQvGjxK7ZXwUS98gX1_yw.png"/></div><p class="ny nz gj gh gi oa ob bd b be z dk translated">最后一块是我们的最终输出(softmax，categorical _ crossentropy)</p></figure><h1 id="7346" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">结论</h1><p id="4cda" class="pw-post-body-paragraph lx ly it kq b kr ks lz ma kt ku mb mc kv md me mf kx mg mh mi kz mj mk ml lb im bi translated">在训练模型之后，我们得到大约75%  <strong class="kq iu">的准确率</strong>，这可以通过在模型中做一些调整来容易地进一步提高。本文的主要焦点是预处理部分，这是比较棘手的部分。</p></div></div>    
</body>
</html>