<html>
<head>
<title>Probably the best introduction about JOIN, CROSS APPLY, UNION, CROSS JOINS and more in SQL Server</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可能是关于SQL Server中的连接、交叉应用、联合、交叉连接等的最佳介绍</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/probably-the-best-introduction-about-join-cross-apply-union-cross-joins-and-more-in-sql-server-f2ee8f8af957?source=collection_archive---------16-----------------------#2020-05-22">https://towardsdatascience.com/probably-the-best-introduction-about-join-cross-apply-union-cross-joins-and-more-in-sql-server-f2ee8f8af957?source=collection_archive---------16-----------------------#2020-05-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="6b5b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个故事中，我们将从零开始理解在SQL Server中组合两个或多个表的大部分方法。我们将使用SQL Server 2019，但几乎下面描述的每个查询都可以在旧版本的SQL Server上执行，甚至可以在Oracle或MySQL等其他SQL数据库上执行，只需做很小的调整。</p><p id="9949" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">在开始之前，一定要知道本文中的结构、数据和所有查询都可以在这个页面上找到</strong><a class="ae kl" href="https://dbfiddle.uk/?rdbms=sqlserver_2019&amp;fiddle=bb54aaea7e0a2527a7e5b14b6dc922e6" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">&lt;&gt;</strong></a><strong class="jp ir">。你会发现它非常有用，因为它们都是可编辑和可执行的，所以你可以随意尝试你想到的任何东西。</strong></p><h1 id="19c2" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">设置环境</h1><p id="7bae" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">我们将在所有查询中使用下面的表格和示例数据。想象一下，你正在查看像Bird、Lime、Dott这样的电动滑板车租赁服务的数据仓库(一个非常非常简化的版本)。</p><p id="6b5e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们有以下表格:</p><ul class=""><li id="135d" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk lu lv lw lx bi translated"><strong class="jp ir">表【dbo】。【Trip】</strong>:包含所有行程的事务表。它在每次旅行中都有一行，换句话说，每次用户解锁踏板车、使用它通勤并再次锁定它时都会生成一行。</li></ul><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi ly"><img src="../Images/912749c7494abcbf40a706de2078a323.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C5g6fKe9Y1mi03tIP3Y46g.png"/></div></div></figure><ul class=""><li id="0ccb" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk lu lv lw lx bi translated"><strong class="jp ir">表【dbo】。【用户】</strong>:用户的维度表。</li></ul><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/829e5b1471630f5047083a7390583b38.png" data-original-src="https://miro.medium.com/v2/resize:fit:286/format:webp/1*GK_AqUBZV-jSBbiYLzyFmQ.png"/></div></figure><ul class=""><li id="eea7" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk lu lv lw lx bi translated"><strong class="jp ir">表【dbo】。【踏板车】</strong>:踏板车尺寸表。</li></ul><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/50a4301d048a67102cb513c7017c1f67.png" data-original-src="https://miro.medium.com/v2/resize:fit:658/format:webp/1*TvY8lWeDEuVYC0JIchIz8g.png"/></div></figure><ul class=""><li id="3811" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk lu lv lw lx bi translated"><strong class="jp ir">表【dbo】。[RepairedScooter] </strong>:这是一个表格，包含至少一次通过维修区的滑板车列表。</li></ul><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/142825a8a165ed4248091410a78571b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:938/format:webp/1*pC5SzgE3zw_sbe5UQrwlgw.png"/></div></figure><p id="8ff7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以查看从db &lt;&gt; fiddle创建和填充数据的代码，但也可以查看预览。</p><h1 id="080c" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">查找不同列的组合</h1><p id="651b" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">我们可以在不同的情况下使用交叉连接(或笛卡尔连接),但是，它最常用的范围可能是当您想要从一个或多个表中选择两个或多个字段的所有组合时。</p><p id="dcd0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下面的示例中，您可以使用交叉连接对指示器和用户的每种组合进行选择。例如，如果您希望制作第一个表来分析用户是否不止一次租用同一辆小型摩托车，这可能会很有用。</p><blockquote class="mn mo mp"><p id="fcd7" class="jn jo mq jp b jq jr js jt ju jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj kk ij bi translated"><strong class="jp ir"> —查询A001 </strong> <br/>从【用户】A、【代步车】B <br/>中选择DISTINCT A【ID】、A【用户名】、B【ID】、B【品牌】、B【型号】<br/>排序按A【ID】、B【ID】</p></blockquote><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi ml"><img src="../Images/6c8db11e606694a4ddc81279cc356170.png" data-original-src="https://miro.medium.com/v2/resize:fit:658/format:webp/1*rnZxPmi9THehhnYalMwjrQ.png"/></div></div></figure><h1 id="ba0b" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">使用不同表的列</h1><p id="1c2d" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">当您想要将另一个表(表B)中的一列或多列添加到表(表A)中时，可以使用联接。如果您想使用基于SQL的数据库，这可能是需要掌握的最重要的构造。</p><h2 id="e6a8" class="mu kn iq bd ko mv mw dn ks mx my dp kw jy mz na la kc nb nc le kg nd ne li nf bi translated">语法介绍</h2><p id="71df" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">在理解不同类型的连接之前，让我们快速浏览一下在表之间进行连接时使用的语法。</p><p id="4846" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下查询是表[Trip](别名为“A”)和表[Scooter](别名为“B”)的基本连接。连接的类型是内部连接，我们将在文章的这一部分的后面理解它的含义。ON子句后列出了连接条件。这里，列之间有一个简单的等式，但它们可以不止一个(在这种情况下，您应该使用AND、OR，而不是运算符),或者可以是更复杂的等式，如between或like。在连接条件中，您还可以找到应用于列的函数(例如LEFT ),但这是一个介绍，因此我们不会找到这些情况。</p><blockquote class="mn mo mp"><p id="7772" class="jn jo mq jp b jq jr js jt ju jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj kk ij bi translated"><strong class="jp ir"> —查询B001 </strong> <br/>选择A.[ID]，A.[DateTimeStart]，A.[TripDuration]，B.[Brand]，B.[Model] <br/>从[Trip] A <br/>内联[Scooter] B <br/>上A.[ID_Scooter]=B.[ID]</p></blockquote><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/6b1f2978bb3af009b3a0e8a60665d477.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*n5kN7NeMRNtl60h3JO0oXA.png"/></div></figure><p id="1941" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在查询中使用了一些别名，但是，我们也可以重复表的完整名称，得到相同的结果。</p><blockquote class="mn mo mp"><p id="cb8f" class="jn jo mq jp b jq jr js jt ju jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj kk ij bi translated"><strong class="jp ir"> —查询B003 </strong> <br/>选择【行程】。[ID]，[Trip]。[日期时间开始]，[行程]。[旅行持续时间]，[踏板车]。[品牌]，[滑板车]。【车型】<br/>从【行程】<br/>内加入【踏板车】<br/>上【行程】。[ID_Scooter]=[Scooter]。[ID]</p></blockquote><p id="cb5f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果列名只存在于其中一个表中，则指定表名或别名不是强制性的(但建议这样做)。此外，这个查询给出的结果与其他两个相同。</p><blockquote class="mn mo mp"><p id="8f08" class="jn jo mq jp b jq jr js jt ju jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj kk ij bi translated"><strong class="jp ir"> —查询B002 </strong> <br/>选择A.[ID]，[DateTimeStart]，[TripDuration]，[Brand]，[Model] <br/>从[Trip] A <br/>内联接[Scooter] B <br/>上[ID_Scooter]=B.[ID]</p></blockquote><p id="aa73" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，您可以通过连接三个或更多的表来扩展所有这些规则，这方面没有限制。</p><blockquote class="mn mo mp"><p id="beaa" class="jn jo mq jp b jq jr js jt ju jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj kk ij bi translated"><strong class="jp ir"> —查询B004 </strong> <br/>选择A.[ID]，A.[DateTimeStart]，A.[TripDuration]，B.[Brand]，B.[Model]，C.* <br/>从[Trip] A <br/>内联接[Scooter]B<br/>ON A .[ID _ Scooter]= B .[ID]<br/>内联接[User]C<br/>ON A .[ID _ User]= C .[ID]</p></blockquote><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/88b3d58cca7e72cdee315c9e5c529911.png" data-original-src="https://miro.medium.com/v2/resize:fit:1386/format:webp/1*867o7DMa9Us-dfr1W9cXYg.png"/></div></figure><p id="3a16" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mq">最后，您可能会发现一些具有不同语法的连接子句(例如，如果您正在使用SAP Business Objects suite)，类似于交叉连接。这也是一种有效的语法，称为ANSI-92，但在本文中，我们不使用它，所以可以在互联网上找到许多关于它的文章。</em></p><h2 id="5b40" class="mu kn iq bd ko mv mw dn ks mx my dp kw jy mz na la kc nb nc le kg nd ne li nf bi translated">完全外部连接</h2><p id="2ca6" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">完全外部连接的结果将包括表A中的至少一行和表B中的至少一行，即使不满足连接条件，在这种情况下，一行空值将来自不匹配的行。</p><p id="6611" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">参见下面的例子来阐明这个概念。</p><blockquote class="mn mo mp"><p id="395b" class="jn jo mq jp b jq jr js jt ju jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj kk ij bi translated"><strong class="jp ir"> —查询C001</strong><br/>SELECT *<br/>FROM[Trip]A<br/>FULL OUTER JOIN[User]B【T33]ON A .[ID _ User]= B .[ID]</p></blockquote><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi ni"><img src="../Images/1c2df2a0b8bd611053d6db7bd29089f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*abmFxEpYbaxaB-ZrPkVUKA.png"/></div></div></figure><h2 id="9e5a" class="mu kn iq bd ko mv mw dn ks mx my dp kw jy mz na la kc nb nc le kg nd ne li nf bi translated">左外部连接</h2><p id="ba4a" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">左外部联接类似于完全外部联接，但不对称。这意味着结果中至少有一行来自左边的表(下例中的表A)，但是右边的表(下例中的表B)中不满足连接规则的行不会显示出来。</p><blockquote class="mn mo mp"><p id="57b3" class="jn jo mq jp b jq jr js jt ju jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj kk ij bi translated"><strong class="jp ir"> —查询D001 </strong> <br/> SELECT * <br/>从【行程】A <br/>左加入【用户】B <br/> ON A.[ID_User]=B.[ID]</p></blockquote><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi nj"><img src="../Images/0b1e6aa9f47f6a04939748b30f3f4d85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3pPv04lPUGcsoK-SX77QaA.png"/></div></div></figure><p id="ff61" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，我们可以使用LEFT OUTER JOIN构造来查找左边表(表A)中根据连接规则在右边表(表B)中没有对应行的行。这是一个非常有用的应用程序，您只需在查询下添加一个WHERE子句，如下例所示。</p><blockquote class="mn mo mp"><p id="7805" class="jn jo mq jp b jq jr js jt ju jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj kk ij bi translated"><strong class="jp ir"> —查询D002</strong><br/>SELECT A . *<br/>FROM[Trip]A<br/>LEFT JOIN[User]B<br/>ON A .[ID _ User]= B.[ID]<br/>其中B .[ID]为空</p></blockquote><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi nk"><img src="../Images/b87e8215e9be4ca0ad731a0443cb72cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dRSvBbIJWoP5ri6FC2p__Q.png"/></div></div></figure><h2 id="62e8" class="mu kn iq bd ko mv mw dn ks mx my dp kw jy mz na la kc nb nc le kg nd ne li nf bi translated">右外部联接</h2><p id="ba68" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">正如您可能期望的那样，我们对左外连接的所有考虑可以对称地用于右外连接。</p><p id="9527" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在理解了上一节中的左外连接之后，可以随意看一下下面的两个例子来确认或否定您对右外连接的期望。</p><blockquote class="mn mo mp"><p id="d02d" class="jn jo mq jp b jq jr js jt ju jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj kk ij bi translated"><strong class="jp ir"> —查询E001</strong><br/>SELECT *<br/>FROM[Trip]A<br/>RIGHT JOIN[User]B<br/>ON A .[ID _ User]= B .[ID]</p></blockquote><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi nj"><img src="../Images/26d54174232a8c8fbc775d76ea0142c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZUup8XO-wj5uU9pZ3j86Vg.png"/></div></div></figure><blockquote class="mn mo mp"><p id="ac51" class="jn jo mq jp b jq jr js jt ju jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj kk ij bi translated"><strong class="jp ir"> —查询E002</strong><br/>SELECT B . *<br/>FROM[Trip]A<br/>RIGHT JOIN[User]B<br/>ON A .[ID _ User]= B .[ID]<br/>其中A.[ID]为空</p></blockquote><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi nl"><img src="../Images/681e3398078ec545f70cdc459301287e.png" data-original-src="https://miro.medium.com/v2/resize:fit:294/format:webp/1*UslAWIkHiLeAxZWtFh4gYA.png"/></div></div></figure><h2 id="7500" class="mu kn iq bd ko mv mw dn ks mx my dp kw jy mz na la kc nb nc le kg nd ne li nf bi translated">内部连接</h2><p id="80c2" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">从概念上讲，内部连接是左外部连接和右外部连接的组合，因此该连接的结果将只包含符合连接规则的行。</p><p id="b494" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> —查询F001</strong><br/>SELECT *<br/>FROM[Trip]A<br/>INNER JOIN[User]B<br/>ON A .[ID _ User]= B .[ID]</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi nm"><img src="../Images/1c25cdcaf2dda3439c4c0cef1ef49b70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ofbc08SaWnUx6HvWjTbAPQ.png"/></div></div></figure><h2 id="d5a8" class="mu kn iq bd ko mv mw dn ks mx my dp kw jy mz na la kc nb nc le kg nd ne li nf bi translated">反连接</h2><p id="128e" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">相反，反连接将只显示左侧的表行(表A)和右侧的表行(表B ),它们不符合连接规则。</p><p id="c5a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> —查询G001</strong><br/>SELECT *<br/>FROM[Trip]A<br/>FULL OUTER JOIN[User]B<br/>ON A .[ID _ User]= B.[ID]<br/>其中A.[ID]为空或B .[ID]为空</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi nn"><img src="../Images/b63881ae59e13a05d2a6c11a488e4785.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7a_eD-5J07F1mnwi_8nIZQ.png"/></div></div></figure><h2 id="3029" class="mu kn iq bd ko mv mw dn ks mx my dp kw jy mz na la kc nb nc le kg nd ne li nf bi translated">交叉应用</h2><p id="f731" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">交叉应用类似于内部连接，但是当您想要指定一些关于连接中的数量或顺序的更复杂的规则时，可以使用它。交叉应用最常见的实际应用可能是当您希望在两个(或更多)表之间建立连接，但您希望表A的每一行都是math，并且只有表B的一行是math。在下面的示例中，更详细地说，每个用户(表A)将与其最长的行程(表B)匹配。请注意，没有进行任何旅行的用户不会包括在结果中，因为我们已经说过交叉应用在某种程度上类似于内部连接。</p><p id="2b78" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> —查询H001 </strong> <br/> SELECT A.*，B.[TripDuration]，B .[ID]<br/>FROM[User]A<br/>CROSS APPLY(<br/>SELECT TOP 1 *<br/>FROM[Trip]C<br/>其中C .[ID _ User]= A .[ID]<br/>ORDER BY C .[Trip duration]desc<br/>)B</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi no"><img src="../Images/a336697b06593a844218a1e4dbf5bfa0.png" data-original-src="https://miro.medium.com/v2/resize:fit:734/format:webp/1*MvinQRU26LB6JbEGy3rgdw.png"/></div></div></figure><h2 id="8ece" class="mu kn iq bd ko mv mw dn ks mx my dp kw jy mz na la kc nb nc le kg nd ne li nf bi translated">外部应用</h2><p id="d00a" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">外部应用与我们刚刚讨论的交叉应用非常接近。主要区别在于，外部APPLY还会在结果中包括表A中不符合WHERE子句中定义的匹配规则的行。</p><p id="55d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面的例子类似于我们在交叉应用部分中的例子，但是，正如您可以很容易地看到的，没有任何旅行的用户也包括在结果中。</p><p id="8959" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> —查询I001 </strong> <br/> SELECT A.*，B.[TripDuration]，B .[ID]<br/>FROM[User]A<br/>OUTER APPLY(<br/>SELECT TOP 1 *<br/>FROM[Trip]C<br/>其中C .[ID _ User]= A .[ID]<br/>ORDER BY C .[Trip duration]desc<br/>)B</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi np"><img src="../Images/50eb6a650534108653f6ab5cf4847194.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*Uctu4_6UPPunY9_aHFI9Og.png"/></div></figure><h2 id="fd60" class="mu kn iq bd ko mv mw dn ks mx my dp kw jy mz na la kc nb nc le kg nd ne li nf bi translated">在连接中使用WHERE条件</h2><p id="7924" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">在继续之前，理解使用连接时WHERE子句的用法是很重要的。</p><p id="1148" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将考虑四个例子，有四个完全不同的结果，我希望这些例子有助于理解如何正确地编写连接和WHERE规则。</p><p id="cadd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在查询L001中，您可以看到一个关于连接的重要事实，因为数据库将首先根据连接规则在表之间建立连接，然后才使用WHERE子句进行过滤。因此结果将只包括b .[用户名]='Brenda '的行。</p><blockquote class="mn mo mp"><p id="b29c" class="jn jo mq jp b jq jr js jt ju jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj kk ij bi translated"><strong class="jp ir"> —查询L001</strong><br/>SELECT *<br/>FROM[Trip]A<br/>LEFT JOIN[User]B<br/>ON A .[ID _ User]= B .[ID]<br/>其中B.[Username]='Brenda '</p></blockquote><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi nn"><img src="../Images/a10ec840e5223fd2a46a5ece8752aaa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mmkqGdtpt-vpMEHEbrnxMQ.png"/></div></div></figure><p id="d555" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于连接的另一个重要事实是，您可以在连接规则中指定一些过滤规则。如果考虑在WHERE子句之前应用连接规则，那么这是一个好主意，这样可以限制数据库在筛选之前必须提取的行数。</p><p id="be9a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">硬币的另一面是，您必须知道并始终注意，在左出连接中，只有应用于右表(表B)的过滤规则才会被考虑。</p><blockquote class="mn mo mp"><p id="adbf" class="jn jo mq jp b jq jr js jt ju jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj kk ij bi translated"><strong class="jp ir"> —查询L002</strong><br/>SELECT *<br/>FROM[Trip]A<br/>LEFT JOIN[User]B<br/>ON A .[ID _ User]= B .[ID]AND B .[Username]= ' Brenda '</p></blockquote><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi nm"><img src="../Images/c00dafb1a7758bef24fbd376e6773fe6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZHqDvj4YYCX7866rGP-pNA.png"/></div></div></figure><blockquote class="mn mo mp"><p id="ad7f" class="jn jo mq jp b jq jr js jt ju jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj kk ij bi translated"><strong class="jp ir"> —查询L003</strong><br/>SELECT *<br/>FROM[Trip]A<br/>LEFT JOIN[User]B<br/>ON A .[ID _ User]= B .[ID]<br/>其中A.[ID_Scooter]='SR001 '</p></blockquote><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi nn"><img src="../Images/5b8e3fc5977a6d1412e10d24cf1768d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i44WUjN96MX_cfNoS0k4Pw.png"/></div></div></figure><p id="ae66" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我们在查询L002的示例中已经说过的，在左出连接中，只考虑应用于右表(表B)的过滤规则。在本例中，您可以看到过滤规则A.[ID_Scooter]='SR001 '被忽略，所有指示器都被提取到结果中。请花一些时间来理解查询L003和L004的结果之间的差异。</p><blockquote class="mn mo mp"><p id="1102" class="jn jo mq jp b jq jr js jt ju jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj kk ij bi translated"><strong class="jp ir"> —查询L004</strong><br/>SELECT *<br/>FROM[Trip]A<br/>LEFT JOIN[User]B<br/>ON A .[ID _ User]= B .[ID]AND A .[ID _ Scooter]= ' Sr 001 '</p></blockquote><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi nq"><img src="../Images/8680e429fdc64ff09824747af92b932f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c5k5NWYP28znoVPty86daw.png"/></div></div></figure><h1 id="81f3" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">使用不同表格的行</h1><p id="fc41" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">在组合了不同表中的列之后，您可能会问是否有可能组合不同表中的行。答案是肯定的，但是你必须掌握不同的结构。</p><h2 id="600e" class="mu kn iq bd ko mv mw dn ks mx my dp kw jy mz na la kc nb nc le kg nd ne li nf bi translated">联合和联合所有</h2><p id="5543" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">关于组合不同表中的行的第一个重要假设是列名和类型必须相同。例如，如果您尝试将表Scooter和RepairedScooter与UNION ALL组合在一起，您将会得到一个错误，因为它们有不同的列。</p><p id="1c55" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> —查询M001 </strong> <br/>从【代步车】<br/>中选择* <br/>从【维修代步车】中选择* <br/></p><p id="42d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Msg 205 Level 16 State 1 Line 2所有使用UNION、INTERSECT或EXCEPT运算符组合的查询在其目标列表中必须有相同数量的表达式。</p><p id="8416" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">无需修改表的结构，只需选择两个表中都存在的列，就可以轻松地合并这两个表。</p><p id="d991" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> —查询M002 </strong> <br/>从【代步车】<br/>中选择【ID】、【品牌】、【型号】、【制造年份】<br/>从【维修代步车】中选择【ID】、【品牌】、【型号】、【制造年份】<br/></p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/240918ff42c1ce035fbdff1a45b8cd12.png" data-original-src="https://miro.medium.com/v2/resize:fit:664/format:webp/1*M5tKLEKVXbr4wpMZLFy41A.png"/></div></figure><p id="93b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">UNION和UNION ALL的区别在于，前者只在结果中包含不同的值，因此，它比后者稍慢。</p><p id="d5bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> —查询M003 </strong> <br/>从【代步车】<br/>中选择【ID】、【品牌】、【型号】、【制造年份】<br/>从【维修代步车】中选择【ID】、【品牌】、【型号】、【制造年份】<br/></p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/1a4eb7eceee1056188e1a7dbeca9bd7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:664/format:webp/1*BJUu1b6OqoZ7ZL3mOyWejA.png"/></div></figure><h2 id="677e" class="mu kn iq bd ko mv mw dn ks mx my dp kw jy mz na la kc nb nc le kg nd ne li nf bi translated">除...之外</h2><p id="eac2" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">如果我们希望提取第一个表中的行而不是第二个表中的行，我们可以使用EXCEPT。</p><p id="7f57" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> —查询N001 </strong> <br/>从【代步车】<br/>中选择【ID】、【品牌】、【型号】、【制造年份】<br/>除了<br/>从【维修代步车】中选择【ID】、【品牌】、【型号】、【制造年份】<br/></p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/8bbfa491dfbc2be2d1354c6d0838f71e.png" data-original-src="https://miro.medium.com/v2/resize:fit:658/format:webp/1*Kw4ddvz0rAwuV4XbsAGUdQ.png"/></div></figure><h2 id="5ffe" class="mu kn iq bd ko mv mw dn ks mx my dp kw jy mz na la kc nb nc le kg nd ne li nf bi translated">横断</h2><p id="1c4e" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">如果我们想提取第一个表和第二个表中的行，我们可以使用INTERSECT。</p><p id="8ce3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> —查询O001 </strong> <br/>从【代步车】<br/>中选择【ID】、【品牌】、【型号】、【制造年份】<br/>从【维修代步车】中选择【ID】、【品牌】、【型号】、【制造年份】<br/></p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/f3214e499bba09a58d20a13e3bef6860.png" data-original-src="https://miro.medium.com/v2/resize:fit:586/format:webp/1*Ete9TqtF41ORzz25a5SsMA.png"/></div></figure><h1 id="84da" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">使用流程图进行简单回顾</h1><p id="a752" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">我们看到了很多构造，我希望这个故事能帮助你更好地理解它们之间的区别。在下图中，您可以找到一个流程图，您可能会发现在SQL Server中组合不同来源的数据的第一步很有帮助。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi nt"><img src="../Images/743c3276bdc9e0c0f66f4ebbcf9524a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o-u_62y6ZWIijwvqqd-Bmg.png"/></div></div></figure><div class="nu nv gp gr nw nx"><a href="https://dbfiddle.uk/?rdbms=sqlserver_2019&amp;fiddle=bb54aaea7e0a2527a7e5b14b6dc922e6" rel="noopener  ugc nofollow" target="_blank"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd ir gy z fp oc fr fs od fu fw ip bi translated">SQL Server 2019 |数据库小提琴</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">免费的在线SQL环境用于实验和分享。</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">dbfiddle.uk</p></div></div></div></a></div></div></div>    
</body>
</html>