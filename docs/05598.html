<html>
<head>
<title>How to be Dangerous with Docker as a Data Scientist</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">作为一名数据科学家，如何应对Docker的危险</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-be-dangerous-with-docker-as-a-data-scientist-b9cf7153a206?source=collection_archive---------40-----------------------#2020-05-10">https://towardsdatascience.com/how-to-be-dangerous-with-docker-as-a-data-scientist-b9cf7153a206?source=collection_archive---------40-----------------------#2020-05-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="164d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">您需要了解的术语、语法和CLI命令将您的项目提升到一个新的水平</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/219769bf878073db8121b785b3f1d86b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JUOITpaBdlrMP9D__-K5Fw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:<a class="ae kv" href="https://www.docker.com/sites/default/files/d8/2019-07/horizontal-logo-monochromatic-white.png" rel="noopener ugc nofollow" target="_blank">https://www . docker . com/sites/default/files/D8/2019-07/horizontal-logo-monochronous-white . png</a></p></figure><p id="c400" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Docker将允许您打包并在任何地方部署您的数据科学解决方案(通常迁移到云中)。它可能是数据科学工具bet中的一个重要工具，可以将数据科学工作从理论和研究转变为实践，并为您的业务增值。</p><h1 id="6a3e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">Docker是什么？</h1><p id="02b2" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">点击<a class="ae kv" href="https://en.wikipedia.org/wiki/Docker_(software)" rel="noopener ugc nofollow" target="_blank">这里</a>查看来自维基百科的无聊的正式定义。然后继续我下面的描述。</p><blockquote class="mp mq mr"><p id="0df8" class="kw kx ms ky b kz la jr lb lc ld ju le mt lg lh li mu lk ll lm mv lo lp lq lr ij bi translated">Docker可以让你捆绑你的代码在一个完全可复制的环境中运行所需的一切，这个环境很容易带到其他机器上<em class="iq">(比如在云中运行)</em>。Docker <em class="iq">(以及像Kubernetes这样的容器管理系统)</em>将这些包相互隔离。这带来了额外的可靠性和安全性，因为如果我的代码被黑客攻击或崩溃，它不会影响你的代码。</p></blockquote><p id="7a98" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么Docker像虚拟机吗？</p><p id="862c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">是的，有点</strong>。在互联网上了解docker很多的人会告诉你<em class="ms">它实际上不像一个虚拟机</em>因为一些令人困惑的计算机术语。然而，这是一个有用的类比。您可以在同一台电脑上运行多个不同的、完全隔离的应用程序。有了虚拟机，每个新应用程序都有了完整的操作系统；而docker只带你需要的东西。这是它轻量级、可伸缩、甚至更安全的原因。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mw"><img src="../Images/e626715f1591714714175abbfab02dd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4ifkM1KdpZds04G3lPTfRA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Docker和虚拟机之间的架构差异</p></figure><h1 id="a882" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">开始时你需要知道的</h1><ul class=""><li id="5c1d" class="mx my iq ky b kz mk lc ml lf mz lj na ln nb lr nc nd ne nf bi translated">术语</li><li id="bed0" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">流行的Dockerfile文件步骤</li><li id="cb04" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">常见CLI命令</li></ul><h1 id="3c6a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">术语</h1><p id="18c6" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><strong class="ky ir"> Dockerfile </strong> <br/>这只是一个文本文件，包含了构建docker映像的具体说明。使用该文件的一些常见操作包括:指定基本映像、复制所需文件、定义环境变量、安装第三方包，以及编写从该映像启动容器时将运行的默认命令。</p><p id="7c55" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">图像</strong> <br/>从Dockerfiles 创建一个图像<em class="ms">，并用于<em class="ms">创建Docker容器</em>。图像一般存储在Dockerhub ( <a class="ae kv" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> public </a>)、Elastic Container Registry(<a class="ae kv" href="https://aws.amazon.com/ecr/" rel="noopener ugc nofollow" target="_blank">AWS</a>)和Artifactory ( <a class="ae kv" href="https://cglcloud.jfrog.io/cglcloud/webapp/#/home" rel="noopener ugc nofollow" target="_blank"> other </a>)这样的存储库中。</em></p><p id="2dd2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">容器这是实际完成工作的地方。创建新容器将运行您的代码。一些docker容器被构建为运行一段时间&amp;之后关闭(如培训作业或数据处理作业)；其他的已经启动并永远保持运行(像web服务、API端点、web应用仪表板)。</p><blockquote class="mp mq mr"><p id="ce4f" class="kw kx ms ky b kz la jr lb lc ld ju le mt lg lh li mu lk ll lm mv lo lp lq lr ij bi translated">如果你熟悉面向对象编程，那么“图像”就像一个类定义，而“容器”则是那个类的一个实例。一旦你有了一个类定义，你可以创建任意多的类实例。</p></blockquote><p id="20e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注册表</strong> <br/>想到一个GitHub的储存库，但是对于Docker图片。您可以在本地使用docker文件来创建图像。一旦你完成了这些图像的开发，你可以把它们推到一个注册中心，在那里它们将启动容器，或者其他人可以把它作为他们项目的基础图像。</p><p id="d746" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是每当从映像启动容器时运行的CLI命令。它通常由docker文件末尾的<code class="fe nl nm nn no b">ENTRYPOINT</code>或<code class="fe nl nm nn no b">CMD</code>步骤指定，或者从基本映像继承。您希望该命令启动完成任务所需的任何脚本或代码。(<a class="ae kv" href="https://goinbigdata.com/docker-run-vs-cmd-vs-entrypoint/" rel="noopener ugc nofollow" target="_blank">阅读更多</a>)</p><p id="fadb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">标签</strong> <br/>这是一种给图片版本命名的方式。这有助于跟踪一段时间内图像的版本历史(类似于git标签如何提交)；或者只是用一个简单的名称来引用该图像。(<a class="ae kv" href="https://www.freecodecamp.org/news/an-introduction-to-docker-tags-9b5395636c2a/" rel="noopener ugc nofollow" target="_blank">阅读更多</a>)</p><p id="a00b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">基础映像</strong> <br/>这是docker映像的起点，通常在docker文件的<code class="fe nl nm nn no b">FROM</code>语句中定义。几乎所有的东西都有一个基础图像。任何映像都可以是另一个映像的基础映像，只要它可以从注册表中访问。最基本的基础映像只是一个操作系统。</p><p id="2716" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ms">一些可能有用的基础图像</em>:</p><ul class=""><li id="e669" class="mx my iq ky b kz la lc ld lf np lj nq ln nr lr nc nd ne nf bi translated"><a class="ae kv" href="https://hub.docker.com/r/rocker/shiny-verse/dockerfile" rel="noopener ugc nofollow" target="_blank"> R闪亮带潮</a></li><li id="b89b" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated"><a class="ae kv" href="https://hub.docker.com/r/continuumio/miniconda/" rel="noopener ugc nofollow" target="_blank">带Conda的蟒蛇皮</a></li><li id="75d1" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated"><a class="ae kv" href="https://hub.docker.com/_/alpine" rel="noopener ugc nofollow" target="_blank">阿尔卑斯山</a></li><li id="a5df" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated"><a class="ae kv" href="https://hub.docker.com/r/lambci/lambda/" rel="noopener ugc nofollow" target="_blank"> AWS Lambda </a></li><li id="9495" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated"><a class="ae kv" href="https://hub.docker.com/_/debian" rel="noopener ugc nofollow" target="_blank"> Debian Linux </a></li></ul><h1 id="94bb" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">流行的Dockerfile文件步骤</h1><p id="c859" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><code class="fe nl nm nn no b">FROM</code> <br/>这个命令在每个Dockerfile文件中都有。它定义了您将要构建的基础映像。您必须能够访问包含基本映像的注册表。</p><p id="e88b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将把文件从你的本地机器(或者你正在构建映像的地方)复制到docker映像(以及随后的容器)。这些文件应该相对于当前工作目录，您将从该目录构建docker映像。</p><p id="641a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nl nm nn no b">ENV</code> <br/>这个为你的docker容器设置OS环境变量<em class="ms"> *注意:用这个代替</em> <code class="fe nl nm nn no b"><em class="ms">RUN export</em></code>。(<a class="ae kv" href="https://stackoverflow.com/questions/33379393/docker-env-vs-run-export" rel="noopener ugc nofollow" target="_blank">下面是为什么</a>)</p><p id="98cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nl nm nn no b">RUN</code> <br/>这将运行OS CLI命令。通常，这样做是为了编辑基本文件系统或安装第三方软件包。</p><p id="d1bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nl nm nn no b">WORKDIR</code> <br/>设置执行入口点或CMD的起始目录。</p><p id="85b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nl nm nn no b">ARG</code> <br/>允许您通过<code class="fe nl nm nn no b">docker build</code>命令将参数传递到docker文件中。</p><p id="0764" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nl nm nn no b">EXPOSE</code> <br/>这公开了一个端口，世界可以通过运行容器的机器访问这个端口。如果您有一个web应用程序、仪表板或API端点，那么您需要公开一个端口。很多时候这已经由你的基本形象来完成了。</p><p id="6c87" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nl nm nn no b">ENTRYPOINT</code>或<code class="fe nl nm nn no b">CMD</code> <br/>新容器启动时将运行的CLI命令。这应该调用您希望docker容器做的所有其他事情。</p><p id="f41d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">ENTRYPOINT和CMD的区别在于CMD可以被覆盖，而ENTRYPOINT不能被覆盖。(<a class="ae kv" href="https://goinbigdata.com/docker-run-vs-cmd-vs-entrypoint/" rel="noopener ugc nofollow" target="_blank">阅读更多</a>)</p><p id="1a5d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">无论如何ENTRYPOINT都会运行。CMD既可以单独运行，也可以用于向ENTRYPOINT添加额外的参数。CMD将指定一些缺省值，在容器启动时运行，但是该参数或命令可以通过<code class="fe nl nm nn no b">docker run</code>覆盖。</p><h1 id="c203" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">常见CLI命令</h1><h2 id="27c9" class="ns lt iq bd lu nt nu dn ly nv nw dp mc lf nx ny me lj nz oa mg ln ob oc mi od bi translated">Docker构建命令</h2><p id="3cd5" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">最简单的版本就是在当前目录下构建docker file:<br/><code class="fe nl nm nn no b">docker build .</code></p><p id="e582" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来你可能想做的是添加一个标签(注册表&amp;版本名):<br/> <code class="fe nl nm nn no b">docker build -t localRegistryName:TagName .</code></p><p id="8d7f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，您可能想用<code class="fe nl nm nn no b">ARG</code>将一些参数传递到docker文件中:</p><pre class="kg kh ki kj gt oe no of og aw oh bi"><span id="e902" class="ns lt iq no b gy oi oj l ok ol">docker build \<br/>    -t localRegistryName:TagName \<br/>    --build-arg DEPLOY_ENV=dev \<br/>    .</span></pre><p id="df2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">复杂应用程序的另一个选择是，您可能将docker文件隐藏在一个文件夹中，或者想要从父目录中复制一些文件。您可以指定<code class="fe nl nm nn no b">-f</code>作为docker文件的路径。</p><pre class="kg kh ki kj gt oe no of og aw oh bi"><span id="9b22" class="ns lt iq no b gy oi oj l ok ol">docker build \<br/>    -t localRegistryName:TagName \<br/>    --build-arg DEPLOY_ENV=dev \<br/>    -f path/to/the/Dockerfile \<br/>    .</span></pre><h2 id="7ccc" class="ns lt iq bd lu nt nu dn ly nv nw dp mc lf nx ny me lj nz oa mg ln ob oc mi od bi translated">Docker运行命令</h2><p id="c0a9" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">从映像运行容器的最简单方法:<br/> <code class="fe nl nm nn no b">docker run localRegistryName:TagName</code></p><p id="2a0c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">端口映射<br/></strong></p><p id="6c92" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ms">注意:第一个PORTNUM是您想要映射到的本地机器上的端口，第二个PORTNUM是您想要查看的来自docker容器的公开端口。端口号可以不同，但这只会使事情变得混乱。</em></p><p id="629e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用Bash <br/>调试另一件你可能想做的事情是用CLI探索你的容器。您可以这样做来检查诸如:<em class="ms">我的代码文件被正确复制了吗？环境变量定义正确吗？</em> <br/> <code class="fe nl nm nn no b">docker run -it localRegistryName:TagName /bin/bash</code></p><p id="7fef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意:要实现这一点，有几件事必须是真的。1)您的映像需要安装bash。所以这不能在windows容器上工作。2)你需要用CMD代替ENTRYPOINT。 <code class="fe nl nm nn no b"><em class="ms">/bin/bash</em></code> <em class="ms">用于在docker容器启动时覆盖CMD。入口点仍然会运行并阻止您运行bash的尝试。</em></p><h2 id="a860" class="ns lt iq bd lu nt nu dn ly nv nw dp mc lf nx ny me lj nz oa mg ln ob oc mi od bi translated">多方面的</h2><p id="df40" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">您可以使用<br/> <code class="fe nl nm nn no b">docker image ls</code> <br/> <code class="fe nl nm nn no b">docker container ls</code>轻松列出您当前的所有图像或正在运行的容器</p><p id="c11a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可能忘记标记图像，或者您只想添加另一个标记。您可以通过引用其他标签或其图像ID将标签添加到图像中。<em class="ms">(可以通过列出所有图像找到图像ID)</em></p><p id="5304" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nl nm nn no b">docker tag OldRegistry:OldTag NewRegistry:NewTag</code>或<br/>或<code class="fe nl nm nn no b">docker tag b25r13lkj89 NewRegistry:NewTag</code></p><p id="6a8c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以通过<br/> <code class="fe nl nm nn no b">docker stop ContainerName</code>或<code class="fe nl nm nn no b">docker kill ContainerName</code>停止当前正在运行的集装箱</p><p id="23a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">清理你的系统</strong> <br/>有不同的方法可以删除旧图像来清理你的工作空间。</p><p id="d338" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nl nm nn no b">docker rmi RegistryName:TagName</code>将删除1幅图像<br/> <code class="fe nl nm nn no b">docker system prune</code>将删除所有未标记的图像&amp;不与运行中的容器关联<br/> <code class="fe nl nm nn no b">docker system prune -a</code>将删除所有内容</p><h1 id="942f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="fb5a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">对于许多数据科学家来说，Docker有一条陡峭的学习曲线，但是一旦你越过了这条曲线，你就会极大地提高你的工作生产能力。</p><p id="ff5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读！<br/> <em class="ms">如果有任何我需要补充或修改的地方，请在评论中告诉我，欢迎反馈！</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi om"><img src="../Images/acfdd90c6b455792fe0d80c69a91c3c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*qWWZeEbuKMzouD1llLNj8w.png"/></div></figure></div></div>    
</body>
</html>