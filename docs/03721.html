<html>
<head>
<title>How To Generate Parquet Files in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Java中生成拼花文件</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-generate-parquet-files-in-java-64cc5824a3ce?source=collection_archive---------19-----------------------#2020-04-07">https://towardsdatascience.com/how-to-generate-parquet-files-in-java-64cc5824a3ce?source=collection_archive---------19-----------------------#2020-04-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/8efc6effa419c6bde0444cfdb71f4da7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zM0DWMdafsXXjL_DauY5KA.jpeg"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">马丁·范·登·霍维尔在<a class="ae kf" href="https://unsplash.com/s/photos/files?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="3c02" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Parquet是Apache为Hadoop基础设施开发的一种开源文件格式。嗯，它最初是Hadoop的一种文件格式，但后来变得非常流行，甚至AWS等云服务提供商也开始支持这种文件格式。这只能意味着拼花地板应该做一些正确的事情。在这篇文章中，我们将看到什么是Parquet文件格式，然后我们将看到一个简单的Java例子来创建或编写Parquet文件。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="06a6" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">拼花文件格式介绍</h1><p id="ca88" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">在传统方法中，我们将数据存储为行。但是Parquet采用了一种不同的方法，它在存储数据之前将数据展平成列。这允许更好的数据存储压缩，也允许更好的查询性能。此外，由于这种存储方法，该格式可以处理具有大量列的数据集。</p><p id="b0a7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于所有这些特性，大多数大数据项目都使用Parquet文件格式。拼花文件还减少了所需的存储空间。在大多数情况下，我们对某些列使用查询。这种文件格式的优点是一列的数据都是相邻的，所以查询运行得更快。</p><p id="b239" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于文件格式的优化和流行，甚至亚马逊也提供内置功能，在保存到<a class="ae kf" href="https://blog.contactsunny.com/?s=s3" rel="noopener ugc nofollow" target="_blank"> S3 </a>(其中<a class="ae kf" href="https://blog.contactsunny.com/data-science/how-to-build-a-simple-data-lake-using-amazon-kinesis-data-firehose-and-amazon-s3" rel="noopener ugc nofollow" target="_blank">充当数据湖</a>)之前，将传入的数据流转换为拼花文件。我在亚马逊的“雅典娜”和一些Apache服务中广泛使用了这个。关于Parquet文件系统的更多信息，可以参考官方文档。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="1ce7" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">依赖关系</h1><p id="b0fb" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">在我们开始写代码之前，我们需要注意依赖关系。因为这是一个<a class="ae kf" href="https://blog.contactsunny.com/?s=spring+boot" rel="noopener ugc nofollow" target="_blank"> Spring Boot </a> Maven项目，我们将在<em class="mo"> pom.xml </em>文件中列出我们所有的依赖项:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="3b45" class="my lm it mu b gy mz na l nb nc">&lt;dependencies&gt;<br/>    &lt;dependency&gt;<br/>        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>        &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;<br/>    &lt;/dependency&gt;<br/>    &lt;dependency&gt;<br/>        &lt;groupId&gt;org.apache.parquet&lt;/groupId&gt;<br/>        &lt;artifactId&gt;parquet-hadoop&lt;/artifactId&gt;<br/>        &lt;version&gt;1.8.1&lt;/version&gt;<br/>    &lt;/dependency&gt;<br/>    &lt;dependency&gt;<br/>        &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt;<br/>        &lt;artifactId&gt;hadoop-core&lt;/artifactId&gt;<br/>        &lt;version&gt;1.2.1&lt;/version&gt;<br/>    &lt;/dependency&gt;<br/>&lt;/dependencies&gt;</span></pre><p id="c03a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如您所见，我们正在添加Spring Boot启动包和几个其他Apache依赖项。对于这个例子，这就是我们所需要的。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="39b2" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">属性</h1><p id="a44e" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">和往常一样，我们有一个<em class="mo"> application.properties </em>文件，我们在其中指定所有属性。对于这个例子，我们只需要两个属性:一个指定模式文件的路径，另一个指定输出目录的路径。稍后我们将了解更多关于该模式的内容。因此，属性文件如下所示:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="0fb0" class="my lm it mu b gy mz na l nb nc">schema.filePath=<br/>output.directoryPath=</span></pre><p id="b40e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为这是一个Spring Boot应用程序，我们将使用<em class="mo"> @Value </em>注释来读取代码中的这些值:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="9ef0" class="my lm it mu b gy mz na l nb nc">@Value("${schema.filePath}")<br/>private String schemaFilePath;<br/><br/>@Value("${output.directoryPath}")<br/>private String outputDirectoryPath;</span></pre></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="3516" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">拼花文件的模式</h1><p id="caaf" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">我们需要指定将要写入Parquet文件的数据的模式。这是因为当创建一个Parquet二进制文件时，每一列的数据类型也会保留。基于我们在模式文件中提供的模式，代码会在将数据写入Parquet文件之前相应地格式化数据。</p><p id="b53d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个例子中，我尽量保持简单，正如您从下面的模式文件中看到的:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="3126" class="my lm it mu b gy mz na l nb nc">message m { <br/>    required INT64 id; <br/>    required binary username; <br/>    required boolean active; <br/>}</span></pre><p id="4077" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我解释一下这是什么。第一个参数的类型是INT64，这是一个整数，它被称为<em class="mo"> id </em>。第二个字段是二进制类型，它只是字符串。我们称之为<em class="mo">用户名</em>字段。第三个是名为<em class="mo">活动</em>的布尔字段。这是一个非常简单的例子。但是不幸的是，如果你的数据有一百列，你必须在这里声明所有的列。</p><p id="655e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">字段声明前的<em class="mo">必需的</em>关键字用于验证，以确保为该字段指定了值。这是可选的，对于非必填字段，您可以删除它。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="a61d" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">拼花作家</h1><p id="ed75" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">声明时间，我没有写这两个类，我在这一节讨论。几个月前，当我研究这个的时候，我在StackOverFlow上发现了这两个类。我不知道这是谁写的，但我一直在到处使用这两个类。但是是的，我已经重新命名了这些类来适应这个项目。</p><p id="da04" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先是<em class="mo"> CustomParquetWriter </em>类。这扩展了Apache提供的<em class="mo"> ParquetWriter </em>类。该类的代码如下:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="4015" class="my lm it mu b gy mz na l nb nc">public class CustomParquetWriter extends ParquetWriter&lt;List&lt;String&gt;&gt; {<br/><br/>    public CustomParquetWriter(<br/>            Path file,<br/>            MessageType schema,<br/>            boolean enableDictionary,<br/>            CompressionCodecName codecName<br/>    ) throws IOException {<br/>        super(file, new CustomWriteSupport(schema), codecName, DEFAULT_BLOCK_SIZE, DEFAULT_PAGE_SIZE, enableDictionary, false);<br/>    }<br/>}</span></pre><p id="1542" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里没什么好说的。下一个是<em class="mo"> CustomWriteSupport </em>，您可以在上面的代码片段中看到它是super()构造函数的第二个参数。这是很多事情发生的地方。您可以检查完整类的<a class="ae kf" href="https://github.com/contactsunny/Parquet_File_Writer_POC" rel="noopener ugc nofollow" target="_blank"> repo </a>，看看它做了什么。</p><p id="897f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">基本上，该类检查模式以确定每个字段的数据类型。之后，使用<em class="mo"> RecordConsumer </em>类的一个实例，数据被写入文件。我不会过多谈论这两个类，因为a)它们不是我写的，b)代码简单到任何人都能理解。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="0ffc" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">为拼花文件准备数据</h1><p id="244a" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">让我们准备一些数据来写入Parquet文件。字符串列表表示拼花文件的一个数据集。列表中的每一项都是模式文件中更正字段的值。例如，假设我们有一个如下所示的列表:</p><p id="5b8b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">查看scheme文件，我们可以看出数组中的第一个值是ID，第二个值是名称，第三个值是活动字段的布尔标志。</p><p id="a57c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，在我们的代码中，我们将有一个字符串列表来表示多行。是的，你没看错，这是一个字符串列表:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="8387" class="my lm it mu b gy mz na l nb nc">List&lt;List&lt;String&gt;&gt; columns = getDataForFile();</span></pre><p id="775e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看看这个函数，看看我们是如何生成数据的:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="05af" class="my lm it mu b gy mz na l nb nc">private List&lt;List&lt;String&gt;&gt; getDataForFile() {<br/>    List&lt;List&lt;String&gt;&gt; data = new ArrayList&lt;&gt;();<br/><br/>    List&lt;String&gt; parquetFileItem1 = new ArrayList&lt;&gt;();<br/>    parquetFileItem1.add("1");<br/>    parquetFileItem1.add("Name1");<br/>    parquetFileItem1.add("true");<br/><br/>    List&lt;String&gt; parquetFileItem2 = new ArrayList&lt;&gt;();<br/>    parquetFileItem2.add("2");<br/>    parquetFileItem2.add("Name2");<br/>    parquetFileItem2.add("false");<br/><br/>    data.add(parquetFileItem1);<br/>    data.add(parquetFileItem2);<br/><br/>    return data;<br/>}</span></pre><p id="a39c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这很简单，对吧？那我们继续吧。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="736e" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">获取模式文件</h1><p id="4e70" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">正如我们已经讨论过的，我们有一个模式文件。我们需要将该模式放入代码中，特别是作为<em class="mo"> MessageType </em>类的实例。让我们看看如何做到这一点:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="8691" class="my lm it mu b gy mz na l nb nc">MessageType schema = getSchemaForParquetFile();<br/><br/>...<br/><br/>private MessageType getSchemaForParquetFile() throws IOException {<br/>    File resource = new File(schemaFilePath);<br/>    String rawSchema = new String(Files.readAllBytes(resource.toPath()));<br/>    return MessageTypeParser.parseMessageType(rawSchema);<br/>}</span></pre><p id="df8e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如您所见，我们只是将文件作为字符串读取，然后使用Apache库提供的<em class="mo"> MessageTypeParser </em>类中的<em class="mo"> parseMessageType() </em>方法解析该字符串。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="3761" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">让拼花作家</h1><p id="eff1" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">这几乎是整个过程的最后一步。我们只需要获得我们之前讨论过的CustomParquetWriter类的一个实例。这里，我们还提供了writer将写入的输出文件的路径。这方面的代码也很简单:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="cde4" class="my lm it mu b gy mz na l nb nc">CustomParquetWriter writer = getParquetWriter(schema);<br/><br/>...<br/><br/>private CustomParquetWriter getParquetWriter(MessageType schema) throws IOException {<br/>    String outputFilePath = outputDirectoryPath+ "/" + System.currentTimeMillis() + ".parquet";<br/>    File outputParquetFile = new File(outputFilePath);<br/>    Path path = new Path(outputParquetFile.toURI().toString());<br/>    return new CustomParquetWriter(<br/>            path, schema, false, CompressionCodecName.SNAPPY<br/>    );<br/>}</span></pre></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="d1eb" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">将数据写入拼花文件</h1><p id="f01b" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">这是最后一步，我们只需将数据写入文件。我们将循环我们创建的list列表，并使用我们在上一步中创建的writer将每个列表写入文件:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="73ff" class="my lm it mu b gy mz na l nb nc">for (List&lt;String&gt; column : columns) {<br/>    writer.write(column);<br/>}<br/>logger.info("Finished writing Parquet file.");<br/><br/>writer.close();</span></pre><p id="926a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">差不多就是这样。您可以转到输出目录并检查创建的文件。例如，这是我运行这个项目后得到的结果:</p><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nd"><img src="../Images/4018cb959a431bf552d47075012a689c.png" data-original-src="https://miro.medium.com/v2/resize:fit:618/format:webp/1*eKpGCT4Rp9_iMUvzwBTfTw.png"/></div></div></figure><p id="a0cc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你想直接从工作示例开始，你可以在我的<a class="ae kf" href="https://github.com/contactsunny/Parquet_File_Writer_POC" rel="noopener ugc nofollow" target="_blank"> Github repo </a>中找到Spring Boot项目。如果你有任何疑问，欢迎在评论中问我。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><blockquote class="ne nf ng"><p id="d25f" class="kg kh mo ki b kj kk kl km kn ko kp kq nh ks kt ku ni kw kx ky nj la lb lc ld im bi translated">最初发表于2020年4月7日https://blog.contactsunny.com。</p></blockquote></div></div>    
</body>
</html>