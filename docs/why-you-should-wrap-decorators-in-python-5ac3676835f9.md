# 为什么应该用 Python 包装 Decorators

> 原文：<https://towardsdatascience.com/why-you-should-wrap-decorators-in-python-5ac3676835f9?source=collection_archive---------11----------------------->

## 提高您的 Python 技能

## 利用 functools.wraps

![](img/2052581815e170274f3a0ef4c241c21e.png)

照片由[本杰明·沃罗斯](https://unsplash.com/@vorosbenisop?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄

## 介绍

装饰器是 Python 中的一个重要特性。本质上，装饰器是修改被装饰函数的行为而不改变其固有功能的函数。在 Python 中，使用 decorator 的最常见语法是将 decorator 函数放在要修饰的函数之上。装饰函数名以@符号作为前缀，表示它是一个装饰函数。下面来看看它最基本的用法。

装饰者的基本用法

在上面的代码中，我们定义了一个名为`invocation_log`的装饰函数，它将记录特定函数调用前后的消息。要使用这个装饰器，我们只需简单地将它放在要装饰的函数之上，在本例中为`say_hello`。不要忘记装饰函数名前面的@符号。让我们调用修饰函数，看看会发生什么。

修饰函数的调用

这三行输出正是我们从装修中可以期待的。具体来说，decorator 只记录了两条消息——在调用被修饰的函数之前和之后。值得注意的是，如前所述，修饰函数做它最初定义的事情，而装饰函数做它自己的工作而不影响修饰函数的功能。

## 问题

在调试过程中，我们有时需要检查特定的对象，以便更好地理解实现细节。让我们考虑下面对上面定义的修饰函数的检查。

修饰函数的字符串表示

如你所见，它并没有真正告诉我们它是什么。相反，它告诉我们这个函数是装饰函数的内部函数。这并不奇怪，因为使用@ symbol 作为 decorator 函数的前缀来修饰函数相当于下面几行代码。换句话说，装饰函数实际上是在装饰函数中定义的返回的内部函数。

修饰函数的显式创建

如果其他人使用我们的代码，一些人可能需要获取关于函数调用的更多细节。为此设计了一个方便的内置函数——`help()`函数。但是对修饰的功能有帮助吗？不完全是，因为它显示了内部函数的信息。

修饰函数的帮助

或者，有些人更喜欢查看函数的文档字符串。然而，它并不像你想象的那样工作。

修饰函数的文档字符串

此外，有时我们希望使用序列化程序保存代码，比如标准库中的 *pickle* 模块。但是，我们不能将修饰函数序列化为它现在的形式，因为模块不能序列化在修饰函数范围内的本地对象。

装饰功能的酸洗问题

## 解决方案

实际上解决方案一点也不困难——我们可以利用标准库中 *functools* 模块中的*包装*函数。有趣的是，*包装了*函数本身就是一个装饰器，我们将使用这个函数通过配置要装饰的函数来装饰内部函数。听起来不简单吗？用下面的例子就很好理解了。

包装装潢师

如上图所示，我们只是使用了装饰器*包装*函数，通过包装`say_hello`函数来装饰内部函数。这只是一行代码。让我们看看这个看似微不足道的变化之后，事情是如何变化的。

包装装饰器的调用

如上所示，当我们不使用包装器时，装饰器的功能保持不变。更重要的问题是被修饰的函数是否有不同的“表现形式”。让我们通过运行下面的代码来检查一下。

支票装饰包装

正如您从输出中看到的，一切都按预期运行。例如，文档字符串显示了那些在`say_hello`函数中定义的内容。我们现在能够序列化该函数以供进一步处理。

## 结论

在本文中，我们回顾了为什么以及如何在 *functools* 模块中使用 *wraps* decorator 来解决我们使用 decorator 时出现的几个突出问题。通过几行额外的代码，修饰函数就像其他常规函数一样具有期望的行为。