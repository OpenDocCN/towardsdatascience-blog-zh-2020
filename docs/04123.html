<html>
<head>
<title>Credit Card Fraud Detection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">信用卡欺诈检测</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/credit-card-fraud-detection-1b3b3b44109b?source=collection_archive---------27-----------------------#2020-04-15">https://towardsdatascience.com/credit-card-fraud-detection-1b3b3b44109b?source=collection_archive---------27-----------------------#2020-04-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ce0d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用多元高斯分布的欺诈检测</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/245c72b23538cfea34af55fb330c46fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*z22ZKCRZXx3nWNwr.jpg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片由<a class="ae kv" href="https://pixabay.com/users/mohamed_hassan-5229782/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3696073" rel="noopener ugc nofollow" target="_blank">穆罕默德·哈桑</a>拍摄，来自<a class="ae kv" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3696073" rel="noopener ugc nofollow" target="_blank">皮克斯拜</a></p></figure><h1 id="d2d2" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">动机</h1><p id="a474" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">如今，大多数交易都在网上进行，这意味着信用卡和其他在线支付系统也参与其中。这种方法对公司和消费者都很方便。消费者节省了时间，因为他们不必去商店购物，公司通过不欠实体店和避免昂贵的租金来节省资金。数字时代似乎带来了一些非常有用的功能，这些功能改变了公司和消费者之间的互动方式，但只有一个成本…公司需要雇用熟练的软件工程师和渗透测试人员，以确保所有交易都是合法的、非欺诈性的。这些人在设计公司的服务器时，让客户无法控制关键的交易部分，如支付金额。通过精心设计，大多数(如果不是全部)问题都可以消除，但即使是用来创建服务器的框架也不是完美的。例如，如果你遵循 django 框架发布说明，你会发现在不同的版本中有许多错误修正，因此一个公司不应该仅仅依赖于它的工程技术。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="942d" class="kw kx iq bd ky kz mr lb lc ld ms lf lg jw mt jx li jz mu ka lk kc mv kd lm ln bi translated">Python 中的信用卡欺诈检测</h1><p id="63cd" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在本文中，我将介绍一种方法来检测是否有人绕过安全墙进行非法交易。你可以在我的<a class="ae kv" href="https://github.com/christk1/anomaly-detection" rel="noopener ugc nofollow" target="_blank"> github repo </a>中找到代码和数据集，但是我强烈建议你按照本文的说明来构建它。</p><p id="6d3b" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">数据集由信用卡交易组成，其特征是 PCA 分析的产物，因此除了“金额”、“时间”和“类别”之外，我们不知道它们代表什么。“金额”是每笔交易的价格，“时间”是&lt;<seconds elapsed="" between="" each="" transaction="" and="" the="" first="">&gt;“类别”在其值等于<strong class="lq ir"> 1 </strong>时表示一笔<strong class="lq ir">欺诈交易</strong>，在其值等于<strong class="lq ir"> 0 </strong>时表示一笔<strong class="lq ir">有效交易</strong>。最初，我们将安装所需的包，以便从我的 GitHub repo 中找到“requirements.txt”文件，创建一个虚拟环境安装它们:</seconds></p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="5eda" class="ng kx iq nc b gy nh ni l nj nk">pip install -r requirements.txt</span></pre><p id="2f88" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">最初创建一个“main.py”文件并导入以下内容:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="7cbd" class="ng kx iq nc b gy nh ni l nj nk">import numpy as np<br/>import pandas as pd<br/>import sklearn<br/>from scipy.stats import norm<br/>from scipy.stats import multivariate_normal<br/>from sklearn.preprocessing import MinMaxScaler<br/>import matplotlib.pyplot as plt<br/>import seaborn as sns</span></pre><p id="745c" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">现在，我们将读取数据集并检查是否有任何缺失值:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="87ef" class="ng kx iq nc b gy nh ni l nj nk">df = pd.read_csv('creditcardfraud/creditcard.csv')</span><span id="97cf" class="ng kx iq nc b gy nl ni l nj nk"># missing values<br/>print("missing values:", df.isnull().values.any())</span></pre><p id="e0a3" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">没有丢失的值，所以我们可以继续进行可视化，以更好地理解我们的数据。让我们画出数据集的平衡程度:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="1b13" class="ng kx iq nc b gy nh ni l nj nk"># plot normal and fraud<br/>count_classes = pd.value_counts(df['Class'], sort=True)<br/>count_classes.plot(kind='bar', rot=0)<br/>plt.title("Distributed Transactions")<br/>plt.xticks(range(2), ['Normal', 'Fraud'])<br/>plt.xlabel("Class")<br/>plt.ylabel("Frequency")<br/>plt.show()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/e4bc94e367b4f09ea6dd9e9fcb5a1c01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BN0-fVDm9B9-QsG4HOZrxA.png"/></div></div></figure><p id="ef87" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">我们发现我们的数据非常不平衡。因此，我们不能直接使用任何监督学习算法，因为它会基于“正常”的例子过度拟合。此时，我们仍处于数据调查分析阶段，因此让我们绘制热图:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="0536" class="ng kx iq nc b gy nh ni l nj nk"># heatmap<br/>sns.heatmap(df.corr(), vmin=-1)<br/>plt.show()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/ca5e464fa34547dcde791f80c1c7c8f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*40t7EvctPaq8Y1OnClkbyA.png"/></div></div></figure><p id="d019" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">我们似乎没有高度相关的特征，尽管“V2”和“金额”之间存在轻微的负相关(标签<em class="no">未显示在上面的热图中，但它接近“类别”特征</em>)特征。“Amount”功能与其他功能也略有关联，这意味着它可以部分地由他们计算，所以我们可以尝试放弃它(从我的测试来看，这给了最终分数一个很好的改善)。“时间”和其他特性之间也有一点关联，但是在这篇文章之后，我们会看到一个更重要的理由来放弃它。</p><p id="b0e6" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">到目前为止，我们做了一些不错的数据分析，但我们没有做最重要的部分，即了解“我们的数据来自哪里”。因此，下一张图将是数据分布图:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="5600" class="ng kx iq nc b gy nh ni l nj nk">fig, axs = plt.subplots(6, 5, squeeze=False)<br/>for i, ax in enumerate(axs.flatten()):<br/>    ax.set_facecolor('xkcd:charcoal')<br/>    ax.set_title(df.columns[i])<br/>    sns.distplot(df.iloc[:, i], ax=ax, fit=norm,<br/>                 color="#DC143C", fit_kws={"color": "#4e8ef5"})<br/>    ax.set_xlabel('')<br/>fig.tight_layout(h_pad=-1.5, w_pad=-1.5)<br/>plt.show()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/6e7ab8b24c4129f27263c10f6865e36d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rvWULHJuiIr1eFnz3JO5mA.png"/></div></div></figure><p id="6f0b" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">我鼓励您在本地机器上执行上述代码片段，以便更好地查看结果。蓝线表示实际的高斯分布，而红线表示数据的概率密度函数。我们看到几乎每个特征都来自<strong class="lq ir">正态(或高斯)分布</strong>，除了来自“时间”分布。因此，这将是我们使用多元高斯分布进行<strong class="lq ir">欺诈检测的动机。这种方法只适用于高斯分布的特征，因此如果你的数据不像高斯分布，你可以用我在这篇文章中描述的方法将其转换。例如，你可以在“第 26 版”、“第 4 版”、“V1”上尝试这种技巧，看看你是否能在我们的最终得分上有所提高。“时间”特征来自于<strong class="lq ir">双峰分布</strong>，其不能被转换为类高斯分布，因此我们将丢弃它。放弃“时间”特性的另一个原因是，它似乎不像其他图表中显示的特性那样包含极值<strong class="lq ir">。</strong></strong></p><p id="18a1" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">此外，我们将使用的算法对距离度量很敏感，因此如果我们将特征缩放到固定范围，我们将获得更好的结果。添加下面的代码片段，该代码片段将删除上面提到的功能，并缩放其他功能，使它们的值介于 0 和 1 之间:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="ce7a" class="ng kx iq nc b gy nh ni l nj nk">classes = df['Class']<br/>df.drop(['Time', 'Class', 'Amount'], axis=1, inplace=True)<br/>cols = df.columns.difference(['Class'])<br/>MMscaller = MinMaxScaler()<br/>df = MMscaller.fit_transform(df)<br/>df = pd.DataFrame(data=df, columns=cols)<br/>df = pd.concat([df, classes], axis=1)</span></pre><p id="51c9" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated"><strong class="lq ir">注意</strong>minmax scaler 不会改变分布的形状，因此异常值仍会在正确的位置。</p><p id="9155" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">至此，我们完成了数据分析和预处理，并准备深入研究算法的实现细节。该算法的步骤如下:</p><ol class=""><li id="343f" class="nq nr iq lq b lr mw lu mx lx ns mb nt mf nu mj nv nw nx ny bi translated">查找可能包含异常示例的要素(完成)</li><li id="fcab" class="nq nr iq lq b lr nz lu oa lx ob mb oc mf od mj nv nw nx ny bi translated">计算训练集中每个特征的平均值，训练集中通常包含<strong class="lq ir">正常</strong>交易的<strong class="lq ir"> 60% </strong></li><li id="457b" class="nq nr iq lq b lr nz lu oa lx ob mb oc mf od mj nv nw nx ny bi translated">计算训练集的协方差矩阵</li><li id="4e0c" class="nq nr iq lq b lr nz lu oa lx ob mb oc mf od mj nv nw nx ny bi translated">计算训练集上的多元正态 pdf(概率密度函数)(下面给出的<em class="no"/>)</li><li id="6075" class="nq nr iq lq b lr nz lu oa lx ob mb oc mf od mj nv nw nx ny bi translated">计算验证集上的多元正态 pdf(包含<strong class="lq ir">欺诈</strong>交易的<strong class="lq ir"> 50% </strong>，通常包含<strong class="lq ir">正常</strong>交易的<strong class="lq ir"> 20% </strong></li><li id="7dc4" class="nq nr iq lq b lr nz lu oa lx ob mb oc mf od mj nv nw nx ny bi translated">在测试集上计算多元正态 pdf(包含<strong class="lq ir">欺诈</strong>交易的<strong class="lq ir"> 50% </strong>，通常包含<strong class="lq ir">正常</strong>交易的<strong class="lq ir"> 20% </strong></li><li id="482d" class="nq nr iq lq b lr nz lu oa lx ob mb oc mf od mj nv nw nx ny bi translated">基于来自<strong class="lq ir">验证</strong>集合的<strong class="lq ir"> pdf </strong>找到一个阈值，该阈值表明比<strong class="lq ir">阈值</strong>小<strong class="lq ir">的<strong class="lq ir"> pdf 值</strong>是<strong class="lq ir">异常值</strong></strong></li><li id="0d0e" class="nq nr iq lq b lr nz lu oa lx ob mb oc mf od mj nv nw nx ny bi translated">计算测试集上的<strong class="lq ir">异常值</strong>，这些异常值是比先前阈值小<strong class="lq ir">的<strong class="lq ir"> pdf 值</strong>的<strong class="lq ir">和</strong></strong></li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/391c6700d4ea09ea091fcca94909e89f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q4vVChugE3BRoWl8QpY3sA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><em class="of">多元正态 pdf </em></p></figure><p id="0cda" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">其中<strong class="lq ir"> μ </strong>为均值，<strong class="lq ir"> det </strong>为行列式，<strong class="lq ir">σ</strong>为协方差矩阵，<strong class="lq ir"> κ </strong>为<strong class="lq ir"> x </strong>取值所在空间的维数。</p><blockquote class="og oh oi"><p id="a168" class="lo lp no lq b lr mw jr lt lu mx ju lw oj my lz ma ok mz md me ol na mh mi mj ij bi translated"><em class="iq">通常，该 pdf 返回交易正常的&lt; &lt;置信度&gt; &gt;。如果该数字低于阈值，则该交易是异常值。</em></p></blockquote><p id="141f" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">是的，我知道上面的 pdf 伤了你的眼睛(就像我的一样)，但它已经在 scipy 包中实现了…</p><p id="541a" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">继续我们的代码，创建一个名为“functions.py”的文件，我们将在其中添加有用的函数来实现算法的某些阶段，并放置以下函数，该函数将我们的数据集分为训练集、验证集和测试集:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="f5d9" class="ng kx iq nc b gy nh ni l nj nk">import pandas as pd<br/>import numpy as np</span><span id="f72a" class="ng kx iq nc b gy nl ni l nj nk">def train_validation_splits(df):<br/>    # Fraud Transactions<br/>    fraud = df[df['Class'] == 1]<br/>    # Normal Transactions<br/>    normal = df[df['Class'] == 0]<br/>    print('normal:', normal.shape[0])<br/>    print('fraud:', fraud.shape[0])</span><span id="18e7" class="ng kx iq nc b gy nl ni l nj nk">    normal_test_start = int(normal.shape[0] * .2)<br/>    fraud_test_start = int(fraud.shape[0] * .5)<br/>    normal_train_start = normal_test_start * 2</span><span id="71be" class="ng kx iq nc b gy nl ni l nj nk">    val_normal = normal[:normal_test_start]<br/>    val_fraud = fraud[:fraud_test_start]<br/>    validation_set = pd.concat([val_normal, val_fraud], axis=0)</span><span id="c218" class="ng kx iq nc b gy nl ni l nj nk">    test_normal = normal[normal_test_start:normal_train_start]<br/>    test_fraud = fraud[fraud_test_start:fraud.shape[0]]<br/>    test_set = pd.concat([test_normal, test_fraud], axis=0)</span><span id="6990" class="ng kx iq nc b gy nl ni l nj nk">    Xval = validation_set.iloc[:, :-1]<br/>    Yval = validation_set.iloc[:, -1]</span><span id="b6a7" class="ng kx iq nc b gy nl ni l nj nk">    Xtest = test_set.iloc[:, :-1]<br/>    Ytest = test_set.iloc[:, -1]</span><span id="d06c" class="ng kx iq nc b gy nl ni l nj nk">    train_set = normal[normal_train_start:normal.shape[0]]<br/>    Xtrain = train_set.iloc[:, :-1]</span><span id="5ec3" class="ng kx iq nc b gy nl ni l nj nk">    return Xtrain.to_numpy(), Xtest.to_numpy(), Xval.to_numpy(), Ytest.to_numpy(), Yval.to_numpy()</span></pre><p id="3397" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">现在添加下面的函数来计算平均值和协方差矩阵:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="d533" class="ng kx iq nc b gy nh ni l nj nk">def estimate_gaussian_params(X):<br/>    """<br/>    Calculates the mean and the covariance for each feature.</span><span id="3233" class="ng kx iq nc b gy nl ni l nj nk">    Arguments:<br/>    X: dataset<br/>    """<br/>    mu = np.mean(X, axis=0)<br/>    sigma = np.cov(X.T)</span><span id="6803" class="ng kx iq nc b gy nl ni l nj nk">    return mu, sigma</span></pre><p id="5213" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">回到我们的“main.py ”,导入并调用上述函数以及我们每组的多元正态 pdf:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="2a15" class="ng kx iq nc b gy nh ni l nj nk">(Xtrain, Xtest, Xval, Ytest, Yval) = train_validation_splits(df)</span><span id="68ca" class="ng kx iq nc b gy nl ni l nj nk">(mu, sigma) = estimate_gaussian_params(Xtrain)</span><span id="66d8" class="ng kx iq nc b gy nl ni l nj nk"># calculate gaussian pdf<br/>p = multivariate_normal.pdf(Xtrain, mu, sigma)<br/>pval = multivariate_normal.pdf(Xval, mu, sigma)<br/>ptest = multivariate_normal.pdf(Xtest, mu, sigma)</span></pre><p id="77e3" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">现在是时候参考阈值(或“ε”)了。一般来说，一个好的做法是用 pdf 的最小值初始化阈值，并以一小步递增，直到达到最大 pdf，同时将每个阈值保存在一个向量中。对于我们的问题，我发现来自 pdf 的值可以有效地用于创建阈值向量。创建向量后，我们创建一个“for”循环，并对其进行迭代。在每次迭代中，我们将当前阈值与产生我们预测的 pdf 值进行比较。然后，我们根据我们的<strong class="lq ir">预测</strong>和<strong class="lq ir">地面实况</strong>值计算<strong class="lq ir"> F1 分数</strong>，如果我们发现 F1 分数大于之前的分数，我们将覆盖一个“最佳阈值”变量。在“for”循环结束时，我们得到了产生最佳 F1 分数的ε值。</p><p id="03f5" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated"><strong class="lq ir">注意</strong>我们不能用准确性作为我们的衡量标准！如果我们确定所有的交易都是“正常”的，我们可能有 99%的准确率和一个无用的算法。</p><p id="f113" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">要实现上述功能，请将以下函数添加到“functions.py”中:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="e7d1" class="ng kx iq nc b gy nh ni l nj nk">def metrics(y, predictions):<br/>    fp = np.sum(np.all([predictions == 1, y == 0], axis=0))<br/>    tp = np.sum(np.all([predictions == 1, y == 1], axis=0))<br/>    fn = np.sum(np.all([predictions == 0, y == 1], axis=0))</span><span id="9201" class="ng kx iq nc b gy nl ni l nj nk">    precision = (tp / (tp + fp)) if (tp + fp) &gt; 0 else 0<br/>    recall = (tp / (tp + fn)) if (tp + fn) &gt; 0 else 0<br/>    F1 = (2 * precision * recall) / (precision +<br/>                                     recall) if (precision + recall) &gt; 0 else 0<br/>    return precision, recall, F1</span><span id="d7d8" class="ng kx iq nc b gy nl ni l nj nk">def selectThreshold(yval, pval):<br/>    e_values = pval<br/>    bestF1 = 0<br/>    bestEpsilon = 0</span><span id="27b7" class="ng kx iq nc b gy nl ni l nj nk">    for epsilon in e_values:<br/>        predictions = pval &lt; epsilon</span><span id="8c2e" class="ng kx iq nc b gy nl ni l nj nk">        (precision, recall, F1) = metrics(yval, predictions)</span><span id="7396" class="ng kx iq nc b gy nl ni l nj nk">        if F1 &gt; bestF1:<br/>            bestF1 = F1<br/>            bestEpsilon = epsilon</span><span id="8ee9" class="ng kx iq nc b gy nl ni l nj nk">    return bestEpsilon, bestF1</span></pre><p id="8fd2" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">最后，在我们的“main.py”文件中导入函数，并调用它们来返回我们的阈值和验证集的 F1 分数，并在我们的测试集上评估我们的模型:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="5307" class="ng kx iq nc b gy nh ni l nj nk">(epsilon, F1) = selectThreshold(Yval, pval)</span><span id="4f22" class="ng kx iq nc b gy nl ni l nj nk">print("Best epsilon found:", epsilon)<br/>print("Best F1 on cross validation set:", F1)</span><span id="b377" class="ng kx iq nc b gy nl ni l nj nk">(test_precision, test_recall, test_F1) = metrics(Ytest, ptest &lt; epsilon)<br/>print("Outliers found:", np.sum(ptest &lt; epsilon))<br/>print("Test set Precision:", test_precision)<br/>print("Test set Recall:", test_recall)<br/>print("Test set F1 score:", test_F1)</span></pre><p id="5260" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">结果是:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="0bc9" class="ng kx iq nc b gy nh ni l nj nk">Best epsilon found: 5e-324 <br/>Best F1 on cross validation set: 0.7852998065764023<br/> <br/>Outliers found: 210 <br/>Test set Precision: 0.9095238095238095 <br/>Test set Recall: 0.7764227642276422 <br/>Test set F1 score: 0.837719298245614</span></pre><p id="7dbb" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">哪个挺好的！</p><blockquote class="og oh oi"><p id="c153" class="lo lp no lq b lr mw jr lt lu mx ju lw oj my lz ma ok mz md me ol na mh mi mj ij bi translated"><em class="iq">本教程已经结束，希望这些信息对您有用。请不吝赐教，并询问您不明白的事情，我会尽快回复您！</em></p></blockquote></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><p id="6a6b" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated"><em class="no">最初发表于</em><a class="ae kv" href="https://devnal.com/articles/7/fraud-detection-in-python/" rel="noopener ugc nofollow" target="_blank">Python 中的欺诈检测(devnal.com)</a><em class="no">。</em></p></div></div>    
</body>
</html>