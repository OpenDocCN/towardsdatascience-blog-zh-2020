<html>
<head>
<title>Data pre-processing: A step-by-step guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据预处理:分步指南</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/data-pre-processing-a-step-by-step-guide-541b083912b5?source=collection_archive---------11-----------------------#2020-03-09">https://towardsdatascience.com/data-pre-processing-a-step-by-step-guide-541b083912b5?source=collection_archive---------11-----------------------#2020-03-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="b7a0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们知道，对数据进行充分的分析和特征工程会产生良好的可视化效果，但是人们在开始时经常会遇到问题。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ko"><img src="../Images/c2c2aef119079973ab01875278721016.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*MLCbvYinIzt3SjZwa3YKww.jpeg"/></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">来源:<a class="ae la" href="https://www.flickr.com/photos/31956880@N00/13120127" rel="noopener ugc nofollow" target="_blank"/>BY<a class="ae la" href="https://www.flickr.com/photos/31956880@N00" rel="noopener ugc nofollow" target="_blank">route 79</a>根据<a class="ae la" href="https://creativecommons.org/licenses/by-nc-sa/2.0/?ref=ccsearch&amp;atype=rich" rel="noopener ugc nofollow" target="_blank"> CC BY-NC-SA 2.0 </a>获得许可</p></figure><p id="553a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这篇文章中，让我们来看看数据预处理的不同步骤。</p><h1 id="88d2" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">1.用什么编码平台？</h1><p id="9c0d" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">虽然 Jupyter Notebook 是一个很好的起点，但 Google Colab 始终是协作工作的最佳选择。在这篇文章中，我将使用 Google Colab 展示数据预处理步骤。</p><h1 id="97c2" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak"> 2。如何为进一步的分析准备原始数据？</strong></h1><p id="e763" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">在针对任何问题优化数据时，遵循正确的步骤以达到正确的目的是很重要的。</p><pre class="kp kq kr ks gt me mf mg mh aw mi bi"><span id="2741" class="mj lc it mf b gy mk ml l mm mn">## Import required libraries<br/>import numpy as np<br/>import pandas as pd</span><span id="8284" class="mj lc it mf b gy mo ml l mm mn">## Upload dataset<br/>from google.colab import files<br/>uploaded = files.upload()</span></pre><h2 id="e852" class="mj lc it bd ld mp mq dn lh mr ms dp ll kb mt mu lp kf mv mw lt kj mx my lx mz bi translated">2.1 选择要上传的文件</h2><pre class="kp kq kr ks gt me mf mg mh aw mi bi"><span id="a1a2" class="mj lc it mf b gy mk ml l mm mn">## Read a .csv file to pandas dataframe<br/>df = pd.read_csv(uploaded['data.csv'])</span><span id="760c" class="mj lc it mf b gy mo ml l mm mn">## Read a .json file to pandas dataframe<br/>df = pd.read_json(uploaded['data.json'])</span><span id="e034" class="mj lc it mf b gy mo ml l mm mn">## Read an excel file to pandas dataframe<br/>df = pd.read_excel(uploaded['data.xlsx'])</span></pre><p id="4871" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">答。csv 文件可以基于<code class="fe na nb nc mf b">;</code>或任何其他分隔符(包括空格)进行分隔。</p><h2 id="e92a" class="mj lc it bd ld mp mq dn lh mr ms dp ll kb mt mu lp kf mv mw lt kj mx my lx mz bi translated">2.1.1 示例:以空格或制表符作为分隔符的 CSV 文件</h2><pre class="kp kq kr ks gt me mf mg mh aw mi bi"><span id="ec45" class="mj lc it mf b gy mk ml l mm mn"><em class="nd">## </em>Read a .csv file to a dataframe with delimiter as space or tab:<br/>df =  pd.read_csv('data.csv',  sep='\s+', engine='python')</span><span id="cd94" class="mj lc it mf b gy mo ml l mm mn">Output :<br/>   Name  Age  City<br/>0  Jack   34  Sydney<br/>1  Jill   31  Melbourne</span></pre><h2 id="e4ca" class="mj lc it bd ld mp mq dn lh mr ms dp ll kb mt mu lp kf mv mw lt kj mx my lx mz bi translated">2.1.2 示例:具有多个分隔符的 CSV 文件</h2><pre class="kp kq kr ks gt me mf mg mh aw mi bi"><span id="af04" class="mj lc it mf b gy mk ml l mm mn"><em class="nd">## </em>Read a .csv file to a dataframe with multiple delimiters :<br/>df =  pd.read_csv('data.csv',  sep='[:,|_]', engine='python')</span><span id="ccad" class="mj lc it mf b gy mo ml l mm mn">Input :<br/>Name,Age|City<br/>Jack,34_Sydney<br/>Jill:31,Melbourne<br/>Adam,16:New York</span><span id="8dc1" class="mj lc it mf b gy mo ml l mm mn">Output :<br/>   Name  Age   City<br/>0  Jack   34   Sydney<br/>1  Jill   31   Melbourne<br/>2  Adam   16   New York</span></pre><h1 id="119a" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak"> 3。描述数据有哪些不同的方式？</strong></h1><h2 id="8303" class="mj lc it bd ld mp mq dn lh mr ms dp ll kb mt mu lp kf mv mw lt kj mx my lx mz bi translated">3.1 数据的维度</h2><pre class="kp kq kr ks gt me mf mg mh aw mi bi"><span id="ec3b" class="mj lc it mf b gy mk ml l mm mn">df.shape <br/># df is the dataframe object name whose dimension we want to obtain</span></pre><h2 id="8c11" class="mj lc it bd ld mp mq dn lh mr ms dp ll kb mt mu lp kf mv mw lt kj mx my lx mz bi translated">3.2 从数据集中删除重复项</h2><pre class="kp kq kr ks gt me mf mg mh aw mi bi"><span id="7154" class="mj lc it mf b gy mk ml l mm mn">df.drop_duplicates(inplace=True)</span></pre><p id="75de" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe na nb nc mf b">inplace=True</code>确保 dataframe 对象被修改，但不创建其副本。如果你需要返回数据帧的副本，使用<code class="fe na nb nc mf b">inplace=False</code>代替。</p><h2 id="72ce" class="mj lc it bd ld mp mq dn lh mr ms dp ll kb mt mu lp kf mv mw lt kj mx my lx mz bi translated">3.3 每个数字列的描述</h2><pre class="kp kq kr ks gt me mf mg mh aw mi bi"><span id="515c" class="mj lc it mf b gy mk ml l mm mn">df.describe()</span></pre><p id="31f8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe na nb nc mf b">describe()</code>通过最小值和最大值以及平均值、中值、标准偏差&amp;等几个值，帮助获得数据集的基本信息。</p><h2 id="8699" class="mj lc it bd ld mp mq dn lh mr ms dp ll kb mt mu lp kf mv mw lt kj mx my lx mz bi translated">3.4 获取数据集的第一行或最后几行</h2><pre class="kp kq kr ks gt me mf mg mh aw mi bi"><span id="c253" class="mj lc it mf b gy mk ml l mm mn">df.head(5) # returns first '5' rows of the dataframe<br/>df.tail(5) # returns last '5' rows of the dataframe</span></pre><h2 id="557b" class="mj lc it bd ld mp mq dn lh mr ms dp ll kb mt mu lp kf mv mw lt kj mx my lx mz bi translated">3.4 列名</h2><p id="3a59" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">如果数据集包含大量的要素(列)，它有助于获取整个要素列表。使用<code class="fe na nb nc mf b">df.columns</code>以描述性格式返回数据帧中所有列的名称。</p><pre class="kp kq kr ks gt me mf mg mh aw mi bi"><span id="e6f4" class="mj lc it mf b gy mk ml l mm mn">df.columns</span><span id="c15f" class="mj lc it mf b gy mo ml l mm mn">Output:<br/>Index(['MSSubClass', 'LotFrontage', 'LotArea', 'OverallQual', 'OverallCond', 'YearBuilt', 'YearRemodAdd', 'MasVnrArea', 'BsmtFinSF2', 'SalePrice'], dtype='object')</span></pre><h2 id="8272" class="mj lc it bd ld mp mq dn lh mr ms dp ll kb mt mu lp kf mv mw lt kj mx my lx mz bi translated">3.5 检查列的数据类型和每列中的条目数:</h2><pre class="kp kq kr ks gt me mf mg mh aw mi bi"><span id="1abc" class="mj lc it mf b gy mk ml l mm mn">df.info()</span></pre><h2 id="f2a6" class="mj lc it bd ld mp mq dn lh mr ms dp ll kb mt mu lp kf mv mw lt kj mx my lx mz bi translated">3.6 删除数字列中的特殊字符</h2><p id="3ef3" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">现在，在几个实例中，包含数字数据的列可以具有“对象”数据类型。由于缺少数据点，一些特殊字符如<code class="fe na nb nc mf b"><strong class="js iu">?</strong></code>或<code class="fe na nb nc mf b">space</code>可能出现在连续变量中。在这种情况下，我们将检查唯一条目，以删除它们并更改数据类型:</p><pre class="kp kq kr ks gt me mf mg mh aw mi bi"><span id="740a" class="mj lc it mf b gy mk ml l mm mn">for col in ['names of each column containing object datatype with numeric data points']:<br/>  uni_val_col = df[col].unique()<br/>  print ('The unique values in ' , col , 'are ', uni_val_col)</span><span id="40fd" class="mj lc it mf b gy mo ml l mm mn">## Convert string datatype to float wherever required and change special characters to NaN<br/>for col in ['names of each column containing object datatype with numeric data points']:<br/>  df[col] = pd.to_numeric(df[col], errors='coerce')</span></pre><p id="3f48" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将某些列的特殊字符转换为<code class="fe na nb nc mf b">NaN</code>(非数字)值，并转换为<code class="fe na nb nc mf b">numeric</code>类型。</p><h2 id="8b99" class="mj lc it bd ld mp mq dn lh mr ms dp ll kb mt mu lp kf mv mw lt kj mx my lx mz bi translated">3.7 创建独立的连续和分类数据框架</h2><pre class="kp kq kr ks gt me mf mg mh aw mi bi"><span id="3f10" class="mj lc it mf b gy mk ml l mm mn">## Create a dataframe with continuous columns <br/>df_cont = df.select_dtypes(include = ['int64','float64'])</span><span id="7131" class="mj lc it mf b gy mo ml l mm mn">## Create a dataframe with categorical columns <br/>df_cat = df.select_dtypes(include =['object'])</span></pre><h2 id="65bc" class="mj lc it bd ld mp mq dn lh mr ms dp ll kb mt mu lp kf mv mw lt kj mx my lx mz bi translated">3.8 从分类列中删除特殊字符</h2><p id="479c" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">我们应该在分类列中检查类似的特殊字符(如 3.6 节所述)，并用适当的值替换它们。</p><pre class="kp kq kr ks gt me mf mg mh aw mi bi"><span id="9e7a" class="mj lc it mf b gy mk ml l mm mn">df.replace(to_replace=["?", ";"], value=np.nan)</span></pre><h1 id="21a5" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak"> 4。缺失值处理</strong></h1><p id="2f00" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">没有输入缺失值的最佳方法。它总是取决于问题的类型。在这里，我们只关注执行分析时要遵循的程序。</p><h2 id="f91a" class="mj lc it bd ld mp mq dn lh mr ms dp ll kb mt mu lp kf mv mw lt kj mx my lx mz bi translated">4.1 查找缺失值百分比</h2><p id="8964" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">在这里，我们可以看到如何获得我们在 3.7 节中创建的连续数据帧中缺失值的百分比</p><pre class="kp kq kr ks gt me mf mg mh aw mi bi"><span id="7c75" class="mj lc it mf b gy mk ml l mm mn"># Percentage of missing values in each dataframe along with visualization</span><span id="a93a" class="mj lc it mf b gy mo ml l mm mn">total = df_cont.isnull().sum().sort_values(ascending=False)<br/>percent = df_cont.isnull().sum()/df_cont.isnull().count()).sort_values(ascending=False)<br/>missing_data = pd.concat([total, percent], axis=1, keys=['Total', 'Percent'])<br/>f, ax = plt.subplots(figsize=(15, 6))<br/>plt.xticks(rotation='90')<br/>sns.barplot(x=missing_data.index, y=missing_data['Percent'])<br/>plt.xlabel('df_cont', fontsize=15)<br/>plt.ylabel('Percent of missing values', fontsize=15)<br/>plt.title('Percent missing data by feature', fontsize=15)<br/>missing_data</span></pre><p id="e587" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">输出:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi ne"><img src="../Images/9f78af38dbb00d9d0964b71519bd958b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uVn4vbYyxZ-4vkma5PpStg.png"/></div></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi nj"><img src="../Images/2764f9d775894d8040de4fc16adcd1b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BquVce0UNNrz0nDtjrDjzQ.png"/></div></div></figure><p id="779d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以将同样的方法应用于分类数据框架<code class="fe na nb nc mf b"><strong class="js iu">df_cat</strong></code></p><h2 id="de64" class="mj lc it bd ld mp mq dn lh mr ms dp ll kb mt mu lp kf mv mw lt kj mx my lx mz bi translated">4.2 缺失值的插补</h2><h2 id="addc" class="mj lc it bd ld mp mq dn lh mr ms dp ll kb mt mu lp kf mv mw lt kj mx my lx mz bi translated">数字数据框架</h2><p id="915e" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">任何列的缺失值都可以通过均值、中值或众数进行估算。如果列中的数据点没有太大的偏差，对于连续数据点，中值比平均值更适合用于替换空值。</p><pre class="kp kq kr ks gt me mf mg mh aw mi bi"><span id="7dc9" class="mj lc it mf b gy mk ml l mm mn">df_cont.'columnname'.fillna(features.Unemployment.median(), inplace=True)</span></pre><p id="b1c6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">与其他方法相比，我更喜欢用 KNN 插补来处理缺失值，因为它能提供更好的结果。</p><pre class="kp kq kr ks gt me mf mg mh aw mi bi"><span id="0318" class="mj lc it mf b gy mk ml l mm mn">from sklearn.impute import KNNImputer<br/>imputer = KNNImputer(n_neighbors=10) <br/>df_data = imputer.fit_transform(df_cont)</span><span id="c269" class="mj lc it mf b gy mo ml l mm mn">## Creating a new dataframe of the imputed data<br/>df_num = pd.DataFrame(df_data, columns = df_cont.columns )</span></pre><h2 id="8eea" class="mj lc it bd ld mp mq dn lh mr ms dp ll kb mt mu lp kf mv mw lt kj mx my lx mz bi translated">4.2.2 分类数据框架</h2><p id="c9c7" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">在分类数据点的情况下，我们可以用模式来代替它</p><pre class="kp kq kr ks gt me mf mg mh aw mi bi"><span id="2f55" class="mj lc it mf b gy mk ml l mm mn">## Replacing NaN with mode for a column<br/>df_cat.replace({'NaN':'four'} , inplace =True)</span></pre><h1 id="8887" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak"> 5。数据分发</strong></h1><h2 id="e2de" class="mj lc it bd ld mp mq dn lh mr ms dp ll kb mt mu lp kf mv mw lt kj mx my lx mz bi translated">5.1 数字数据帧的图形表示</h2><pre class="kp kq kr ks gt me mf mg mh aw mi bi"><span id="2535" class="mj lc it mf b gy mk ml l mm mn">## Plot distplot for continuous data columns <br/>for col in df_num.columns:<br/>  plt.figure()<br/>  sns.distplot(df_num[col])</span></pre><h2 id="bab6" class="mj lc it bd ld mp mq dn lh mr ms dp ll kb mt mu lp kf mv mw lt kj mx my lx mz bi translated">5.2 分类数据框架的图示</h2><pre class="kp kq kr ks gt me mf mg mh aw mi bi"><span id="5426" class="mj lc it mf b gy mk ml l mm mn">## Plotting bar plots for categorical data columns<br/>for col in df_cat.columns:<br/>    plt.figure()<br/>    sns.countplot(x=col, data=df_cat)<br/>    plt.xticks(rotation=90)</span></pre><h1 id="ef34" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak"> 6。异常值的处理</strong></h1><h2 id="7348" class="mj lc it bd ld mp mq dn lh mr ms dp ll kb mt mu lp kf mv mw lt kj mx my lx mz bi translated">6.1 异常值百分比和其他描述性统计措施</h2><p id="8763" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">异常值是可能影响也可能不影响模型的任何特征的极值。要获得每个数值或分类属性中异常值的百分比，我们可以使用-</p><pre class="kp kq kr ks gt me mf mg mh aw mi bi"><span id="7ded" class="mj lc it mf b gy mk ml l mm mn"># Use the appropriate dataframe in place of "dataframe_name" in the code below, i.e. in this case <strong class="mf iu">df_num</strong> and <strong class="mf iu">df_cat</strong></span><span id="4793" class="mj lc it mf b gy mo ml l mm mn">df_outliers = pd.DataFrame(index=dataframe_name.columns, columns=['outliers', 'outliers%']) </span><span id="6887" class="mj lc it mf b gy mo ml l mm mn">for col in dataframe_name.columns:</span><span id="9045" class="mj lc it mf b gy mo ml l mm mn">if any(x in str(dataframe_name[col].dtype) for x in ['int', 'float']):</span><span id="887d" class="mj lc it mf b gy mo ml l mm mn">df_outliers.loc[col, 'count'] = len(dataframe_name)<br/>df_outliers.loc[col, 'q1'] = dataframe_name[col].quantile(0.25)<br/>df_outliers.loc[col, 'q3'] = dataframe_name[col].quantile(0.75)<br/>df_outliers.loc[col, 'iqr'] = df_outliers.loc[col, 'q3'] - df_outliers.loc[col, 'q1']<br/>df_outliers.loc[col, 'lower'] = df_outliers.loc[col, 'q1'] - (3 * df_outliers.loc[col, 'iqr'])<br/>df_outliers.loc[col, 'upper'] = df_outliers.loc[col, 'q3'] + (3 * df_outliers.loc[col, 'iqr'])<br/>df_outliers.loc[col, 'min'] = df[col].min()<br/>df_outliers.loc[col, 'max'] = df[col].max()<br/>df_outliers.loc[col, 'outliers'] = ((dataframe_name[col] &lt; df_outliers.loc[col, 'lower']) | (df[col] &gt; df_outliers.loc[col,'upper'])).sum()<br/>df_outliers.loc[col, 'outliers%'] = np.round(df_outliers.loc[col,<br/>'outliers'] / len(dataframe_name) *100)</span><span id="3aa3" class="mj lc it mf b gy mo ml l mm mn">df_outliers</span></pre><p id="d9c7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们也可以对每个特征使用箱线图来获得相同的图形表示。</p><h2 id="2706" class="mj lc it bd ld mp mq dn lh mr ms dp ll kb mt mu lp kf mv mw lt kj mx my lx mz bi translated">6.2 异常值的处理</h2><p id="846a" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">有不同的方法来处理异常值，z-score 是最简单的一种。</p><pre class="kp kq kr ks gt me mf mg mh aw mi bi"><span id="3a60" class="mj lc it mf b gy mk ml l mm mn">from scipy import stats</span><span id="9fdd" class="mj lc it mf b gy mo ml l mm mn">z_scores = stats.zscore(dataframe_name)<br/>abs_z_scores = np.abs(z_scores)<br/>entries = (abs_z_scores &lt; 3).all(axis=1)<br/>dataframe_name = dataframe_name[entries]</span></pre></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><p id="985d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这就完成了我们最初的数据预处理！我们现在可以从可视化和特征工程开始，使我们的数据集模型就绪。</p></div></div>    
</body>
</html>