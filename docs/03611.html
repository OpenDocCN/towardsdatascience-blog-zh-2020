<html>
<head>
<title>Spinning up Jupyter Notebooks as ECS Service in AWS With Terraform</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Terraform在AWS中将Jupyter笔记本电脑升级为ECS服务</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/spinning-up-jupyter-notebooks-as-ecs-service-in-aws-with-terraform-805ac111d74b?source=collection_archive---------28-----------------------#2020-04-05">https://towardsdatascience.com/spinning-up-jupyter-notebooks-as-ecs-service-in-aws-with-terraform-805ac111d74b?source=collection_archive---------28-----------------------#2020-04-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/96bb88001d1c2ee07a3afca644dbd1f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BhZwRzgTnJzYphVLPAVPYQ.png"/></div></div></figure><p id="9094" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们团队中的数据科学家需要经常运行耗时的Python脚本。根据任务的重复，我们决定是否将它Dockerize并在AWS上运行它。例如，如果一个脚本需要运行多次，我们会努力重写/重构代码，并将其封装到一个容器中，然后将其部署到ECR，并将其调度为Fargate任务。如果这是一次性的，那么在本地运行脚本有时会更容易，但也有一些额外的缺点。</p><p id="18e5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本地运行(繁重的)脚本会消耗内存和CPU，结果是在脚本运行时，您无法真正做其他对笔记本电脑要求很高的事情。我们长期使用的一个解决方案是启动EC2实例并在这些实例上运行脚本。在我看来，这不像是一个可维护的解决方案，但它是可行的，我们没有任何其他解决方案。</p><h1 id="d02f" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">Jupyter笔记本</h1><p id="f185" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">团队大量使用Jupyter笔记本(本地)。有Docker容器可用，像<a class="ae lz" href="https://hub.docker.com/r/jupyter/scipy-notebook" rel="noopener ugc nofollow" target="_blank"> jupyter/scipy-notebook </a>，预装了很多依赖项，比如pandas和scikit-learn。我们想出的一个主意是，基于该图像在AWS上轻松地旋转Docker容器，然后团队成员可以使用它。</p><p id="c4b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，我们希望能够在没有太多麻烦的情况下在云中运行Jupyter笔记本，如果可能的话，甚至为每个人创建一个单独的实例，这样依赖关系、资源和文件就不会共享或混淆。笔记本应该或不应该与其他AWS资源交互。</p><p id="59d8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我偶然发现了<a class="ae lz" href="https://github.com/jupyterhub/jupyterhub" rel="noopener ugc nofollow" target="_blank"> jupyterhub </a> Git仓库的wiki，在那里我找到了一个关于<a class="ae lz" href="https://github.com/jupyterhub/jupyterhub/wiki/Spawners" rel="noopener ugc nofollow" target="_blank">产卵者</a>的页面。有一个<a class="ae lz" href="https://github.com/uktrade/fargatespawner" rel="noopener ugc nofollow" target="_blank"> FargateSpawner </a>，但是说实话，我错过了让它正常工作的文档。</p><p id="859d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">【2020年6月9日更新:你可能也会对我最近发布的一篇关于旋转Polynote笔记本的新文章感兴趣，这篇文章解决了我在Jupyter上遇到的一些问题。</p><div class="ma mb gp gr mc md"><a rel="noopener follow" target="_blank" href="/host-polynote-notebooks-with-basic-authentication-on-aws-fargate-with-terraform-65d4ff3ba730"><div class="me ab fo"><div class="mf ab mg cl cj mh"><h2 class="bd ir gy z fp mi fr fs mj fu fw ip bi translated">在AWS Fargate上使用Terraform进行基本身份验证的主机Polynote笔记本</h2><div class="mk l"><h3 class="bd b gy z fp mi fr fs mj fu fw dk translated">本文将帮助您使用Terraform在ECS上轻松部署安全的Polynote环境。</h3></div><div class="ml l"><p class="bd b dl z fp mi fr fs mj fu fw dk translated">towardsdatascience.com</p></div></div><div class="mm l"><div class="mn l mo mp mq mm mr jw md"/></div></div></a></div><h1 id="68be" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">将（行星）地球化（以适合人类居住）</h1><blockquote class="ms"><p id="95c7" class="mt mu iq bd mv mw mx my mz na nb kv dk translated">Terraform是一个安全有效地构建、更改和版本控制基础设施的工具。Terraform可以管理现有的和受欢迎的服务提供商以及定制的内部解决方案。</p><p id="09c7" class="mt mu iq bd mv mw mx my mz na nb kv dk translated">— <a class="ae lz" href="https://terraform.io" rel="noopener ugc nofollow" target="_blank">地形</a></p></blockquote><p id="5399" class="pw-post-body-paragraph jy jz iq ka b kb nc kd ke kf nd kh ki kj ne kl km kn nf kp kq kr ng kt ku kv ij bi translated">在过去的几个月里，我们对地形做了很多实验。我们心中有一个理想的情况，我们所有的资源和基础设施都通过Terraform以代码的形式建立和维护，但这还有很长的路要走。虽然它给了我们面对的问题一个新的视角。在对Terraform文件进行了一两个小时的工作后，我得到了一个可行的解决方案，目前正在我们的团队中进行测试！</p><h1 id="03ac" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">旋转笔记本的地形脚本</h1><p id="65b1" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我已经建立了一个Git存储库来共享我创建的脚本。你可以在这里找到Git库<a class="ae lz" href="https://github.com/sschrijver/spawn-jupyter-notebook-fargate" rel="noopener ugc nofollow" target="_blank">，我会一路解释。在本文中，我不会在一个代码片段中提供整个Terraform脚本，为此，我想参考Git存储库。我将把脚本分成几块，并提供每个片段的信息。</a></p><h2 id="aab7" class="nh kx iq bd ky ni nj dn lc nk nl dp lg kj nm nn lk kn no np lo kr nq nr ls ns bi translated">先决条件</h2><p id="3d50" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">这需要一些先决条件(参考<a class="ae lz" href="https://github.com/sschrijver/spawn-jupyter-notebook-fargate/blob/master/main.tf" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> main.tf </strong> </a> <strong class="ka ir"> </strong>脚本中的数据块)。我们已经在AWS中设置了以下服务:</p><ul class=""><li id="6139" class="nt nu iq ka b kb kc kf kg kj nv kn nw kr nx kv ny nz oa ob bi translated">ECS集群</li><li id="4798" class="nt nu iq ka b kb oc kf od kj oe kn of kr og kv ny nz oa ob bi translated">应用程序负载平衡器</li><li id="cd44" class="nt nu iq ka b kb oc kf od kj oe kn of kr og kv ny nz oa ob bi translated">Route53内的托管区域和域</li></ul><p id="b7bf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您没有这些东西，您可以选择通过Terraform来设置它们(我肯定会建议您在其他地方进行设置，在您定义和维护您的基础架构的地方)。但是当然，您也可以在AWS控制台中手动设置这些，就像我们之前所做的那样。</p><p id="5965" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我尽可能地使用了变量。这是因为我们有多个AWS环境，我们希望能够在这些不同的环境中轻松运行笔记本电脑。我们还希望能够调整内存和CPU，而不必更改terraform脚本。我的<strong class="ka ir"> vars.tfvars </strong>和<strong class="ka ir"> vars.tf </strong>看起来如下:</p><p id="bc28" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> vars.tfvars </strong>(替换所有大写字母并重新访问其他变量值)<strong class="ka ir"> : </strong></p><pre class="oh oi oj ok gt ol om on oo aw op bi"><span id="92e4" class="nh kx iq om b gy oq or l os ot">vpc_id = "VPC_ID_HERE"<br/>region = "REGION_HERE"<br/>profile_name ="PROFILE_NAME_HERE"<br/>ecs_cluster_name = "ECS_CLUSTER_NAME_HERE"<br/>loadbalancer_arn = "LOAD_BALANCER_ARN_HERE"<br/>hosted_zone_id = "ROUTE_53_HOSTED_ZONE_HERE"<br/>fargate_subnets = [<br/>  "SUBNET_1_HERE",<br/>  "SUBNET_2_HERE",<br/>  "SUBNET_3_HERE"]<br/>jupyter_docker_tag = "latest" #Update July 2021: change this to "dc9744740e12"<br/>cpu = 1024<br/>memory = 2048<br/>domain = "ROUTE_53_DOMAIN_NAME_HERE"</span></pre><p id="7f96" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> vars.tf </strong></p><pre class="oh oi oj ok gt ol om on oo aw op bi"><span id="23f5" class="nh kx iq om b gy oq or l os ot">variable "vpc_id" {}<br/>variable "region" {}<br/>variable "profile_name" {}<br/>variable "ecs_cluster_name" {}<br/>variable "loadbalancer_arn" {}<br/>variable "hosted_zone_id" {}<br/>variable "fargate_subnets" {<br/>  type = list(string)<br/>}<br/>variable "token" {}<br/>variable "jupyter_docker_tag" {}<br/>variable "memory" {}<br/>variable "cpu" {}<br/>variable "domain" {}</span></pre><h1 id="45dc" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">使用这个脚本</h1><p id="b562" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">首先，如果你还没有安装Terraform。安装完成后，可以在保存了<strong class="ka ir"> main.tf </strong>、<strong class="ka ir"> vars.tfvars </strong>和<strong class="ka ir"> vars.tf </strong>的文件夹中运行以下命令(运行<code class="fe ou ov ow om b">terraform init</code>后):</p><pre class="oh oi oj ok gt ol om on oo aw op bi"><span id="bdd1" class="nh kx iq om b gy oq or l os ot">terraform apply -var-file=vars.tfvars</span></pre><p id="effe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它会要求您提供一个令牌，您可以使用它来访问笔记本，并要求您批准在您的AWS云环境中进行更改。几秒钟后，它会输出一个您可以用来访问环境的url。Docker映像真正运行并可访问可能需要几分钟时间，所以如果没有立即得到预期的响应，也不用担心。最初几分钟，您可能会收到HTTP 503响应。</p><h2 id="24e0" class="nh kx iq bd ky ni nj dn lc nk nl dp lg kj nm nn lk kn no np lo kr nq nr ls ns bi translated">撕下笔记本</h2><p id="f2b1" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">当您使用完Jupyter环境后，只需运行下面的命令。提供您在设置环境时使用的相同令牌，不要键入“yes”来批准该命令。所有创建的资源都将被删除。如果您希望以后再次运行Jupyter笔记本，可以选择先将其保存在本地计算机上。</p><pre class="oh oi oj ok gt ol om on oo aw op bi"><span id="f597" class="nh kx iq om b gy oq or l os ot">terraform destroy -var-file=vars.tfvars</span></pre><p id="fb77" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，我将进一步解释存储库中的内容，并将为每个代码片段提供额外的信息，说明脚本实际上是做什么的。</p><h1 id="cfce" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated"><strong class="ak">这个脚本是做什么的？</strong></h1><p id="63ea" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">假设你已经有了一些Terraform的经验或者愿意自己去查阅，我想告诉你这个脚本在做什么。有了数据块，我们就可以检索关于已经存在的AWS资源的信息。正如您在第一个数据块中看到的，我想检索已经存在的ECS群集的信息。</p><pre class="oh oi oj ok gt ol om on oo aw op bi"><span id="b345" class="nh kx iq om b gy oq or l os ot">data "aws_ecs_cluster" "ecs_cluster" {<br/>  cluster_name = var.ecs_cluster_name<br/>}</span></pre><p id="f846" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我正在创建一个随机的字符串，稍后将被几个资源使用。这个随机字符串是这个脚本中的关键元素，它允许多个用户同时启动笔记本电脑。</p><pre class="oh oi oj ok gt ol om on oo aw op bi"><span id="2085" class="nh kx iq om b gy oq or l os ot">resource "random_string" "random_string" {<br/>  length = 8<br/>  special = false<br/>}</span></pre><p id="2e98" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要创建一个任务执行角色，该角色具有附加的策略，例如允许我们写入CloudWatch。AWS已经提供了该策略(参见下面的<code class="fe ou ov ow om b">data “aws_iam_policy" “amazon_ecs...."</code>块，但是我们仍然需要一个附加了该策略的角色。</p><pre class="oh oi oj ok gt ol om on oo aw op bi"><span id="8b80" class="nh kx iq om b gy oq or l os ot">resource "aws_iam_role" "ecs_task_execution_role" {<br/>  name = "ecsTaskExecutionRole-jupyter-${random_string.random_string.result}"<br/>  assume_role_policy = &lt;&lt;ASSUME_ROLE_POLICY<br/>{<br/>"Version": "2012-10-17",<br/>"Statement": [<br/>    {<br/>      "Sid": "",<br/>      "Effect": "Allow",<br/>      "Principal": {<br/>        "Service": "ecs-tasks.amazonaws.com"<br/>      },<br/>      "Action": "sts:AssumeRole"<br/>    }<br/>  ]<br/>}<br/>ASSUME_ROLE_POLICY<br/>}</span><span id="005f" class="nh kx iq om b gy ox or l os ot">data "aws_iam_policy" "amazon_ecs_task_execution_role_policy" {<br/>  arn = "arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy"<br/>}</span><span id="8514" class="nh kx iq om b gy ox or l os ot">resource "aws_iam_role_policy_attachment" "policy_role_attachment" {<br/>  role = aws_iam_role.ecs_task_execution_role.name<br/>  policy_arn = data.aws_iam_policy.amazon_ecs_task_execution_role_policy.arn<br/>}</span></pre><p id="6311" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">出于日志记录的目的，我创建了一个CloudWatch组，当然，你可以随意设置。</p><pre class="oh oi oj ok gt ol om on oo aw op bi"><span id="af2a" class="nh kx iq om b gy oq or l os ot">resource "aws_cloudwatch_log_group" "jupyter_ecs_log_group" {<br/>  name = "/aws/ecs/jupyter-${random_string.random_string.result}"<br/>}</span></pre><p id="56ab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">ECS上的每个Fargate或EC2服务/任务都需要一个任务定义，定义使用什么Docker容器，需要多少CPU和内存等等。你可以把它想象成一个蓝图。正如您在下面看到的，我将jupyter/data science-notebook指定为图像。我还更改了入口点，因此可以设置自定义令牌，否则它将生成一个随机令牌，不太容易从系统中检索到。</p><pre class="oh oi oj ok gt ol om on oo aw op bi"><span id="63e8" class="nh kx iq om b gy oq or l os ot">resource "aws_ecs_task_definition" "jupyter_task_definition" {<br/>  family = "jupyter-${random_string.random_string.result}"<br/>  requires_compatibilities = [<br/>    "FARGATE"]<br/>  network_mode = "awsvpc"<br/>  cpu = var.cpu<br/>  memory = var.memory<br/>  execution_role_arn = data.aws_iam_role.ecs_task_execution_role.arn<br/><br/>  container_definitions = &lt;&lt;TASK_DEFINITION<br/>  [<br/>    {<br/>        "entryPoint": ["start-notebook.sh","--NotebookApp.token='${var.token}'"],<br/>        "essential": true,<br/>        "image": "registry.hub.docker.com/jupyter/datascience-notebook:${var.jupyter_docker_tag}",<br/>        "name": "jupyter-${random_string.random_string.result}",<br/>        "portMappings": [<br/>            {<br/>                "containerPort": 8888,<br/>                "hostPort": 8888<br/>            }<br/>        ],<br/>        "logConfiguration": {<br/>                "logDriver": "awslogs",<br/>                "options": {<br/>                  "awslogs-region": "${var.region}",<br/>                  "awslogs-group": "${aws_cloudwatch_log_group.jupyter_ecs_log_group.name}",<br/>                  "awslogs-stream-prefix": "${random_string.random_string.result}"<br/>            }<br/>        }<br/>    }<br/>  ]<br/>  TASK_DEFINITION<br/>}</span></pre><p id="dbf9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如我提到的，我们已经有了一个带有HTTPS监听器的负载平衡器，所以我们希望从它那里检索信息，以便以后使用(连同我们的VPC的信息)。当然，您也可以使用端口80，但我的建议是使用端口443。</p><pre class="oh oi oj ok gt ol om on oo aw op bi"><span id="53ef" class="nh kx iq om b gy oq or l os ot">data "aws_vpc" "vpc" {<br/>  id = var.vpc_id<br/>}<br/><br/>data "aws_lb" "lb" {<br/>  arn = var.loadbalancer_arn<br/>}<br/><br/>data "aws_lb_listener" "lb_listener" {<br/>  load_balancer_arn = var.loadbalancer_arn<br/>  port = 443<br/>}</span></pre><p id="6105" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此设置还需要一个目标组，负载平衡器侦听器规则将指向该目标组。该目标组稍后将在<code class="fe ou ov ow om b">aws_ecs_service</code>资源块中使用。</p><pre class="oh oi oj ok gt ol om on oo aw op bi"><span id="a764" class="nh kx iq om b gy oq or l os ot">resource "aws_lb_target_group" "jupyter_target_group" {<br/>  name = "jupyter-${random_string.random_string.result}"<br/>  port = 80<br/>  protocol = "HTTP"<br/>  vpc_id = data.aws_vpc.vpc.id<br/>  target_type = "ip"<br/>  health_check {<br/>    matcher = "200,302"<br/>  }<br/>}</span></pre><p id="dca9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还需要将容器中的端口8888暴露给负载平衡器。我将端口8888暴露给连接到负载平衡器的安全组。</p><pre class="oh oi oj ok gt ol om on oo aw op bi"><span id="66bb" class="nh kx iq om b gy oq or l os ot">resource "aws_security_group" "jupyter_security_group" {<br/>  name = "jupyter_${random_string.random_string.result}"<br/>  vpc_id = data.aws_vpc.vpc.id<br/><br/>  ingress {<br/>    description = "Incoming 8888"<br/>    from_port = 8888<br/>    to_port = 8888<br/>    protocol = "tcp"<br/>    security_groups = data.aws_lb.lb.security_groups<br/>  }<br/><br/>  egress {<br/>    from_port = 0<br/>    to_port = 0<br/>    protocol = "-1"<br/>    cidr_blocks = [<br/>      "0.0.0.0/0"]<br/>  }<br/><br/>  tags = {<br/>    Name = "jupyter_${random_string.random_string.result}"<br/>  }<br/>}</span></pre><p id="2921" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有了所有这些资源，我们终于可以定义我们的ECS服务了。</p><pre class="oh oi oj ok gt ol om on oo aw op bi"><span id="e01f" class="nh kx iq om b gy oq or l os ot">resource "aws_ecs_service" "jupyter_service" {<br/>  name = "jupyter-${random_string.random_string.result}"<br/>  cluster = data.aws_ecs_cluster.ecs_cluster.id<br/>  task_definition = aws_ecs_task_definition.jupyter_task_definition.id<br/>  desired_count = 1<br/>  launch_type = "FARGATE"<br/><br/>  network_configuration {<br/>    subnets = var.fargate_subnets<br/>    security_groups = [<br/>      aws_security_group.jupyter_security_group.id]<br/>  }<br/><br/>  load_balancer {<br/>    target_group_arn = aws_lb_target_group.jupyter_target_group.arn<br/>    container_name = "jupyter-${random_string.random_string.result}"<br/>    container_port = 8888<br/>  }<br/>  depends_on = [<br/>    aws_lb_target_group.jupyter_target_group]<br/>}</span></pre><p id="d011" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，在负载平衡器中添加转发规则。假设我们有以下域:<code class="fe ou ov ow om b">company.com</code>，随机字符串为<code class="fe ou ov ow om b">123</code>。如果主机头是<code class="fe ou ov ow om b">jupyter-123.company.com</code>，它将转发到Jupyter目标组。【2021年7月更新: <code class="fe ou ov ow om b">field = "host-header"</code>仅适用于版本2.41.0之前的AWS提供程序，使用<code class="fe ou ov ow om b"><a class="ae lz" href="https://registry.terraform.io/providers/hashicorp/aws/latest/docs" rel="noopener ugc nofollow" target="_blank">required_providers</a></code>锁定AWS提供程序或更新条件块，使其适用于<a class="ae lz" href="https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/lb_listener_rule" rel="noopener ugc nofollow" target="_blank">最新版本</a>。</p><pre class="oh oi oj ok gt ol om on oo aw op bi"><span id="841a" class="nh kx iq om b gy oq or l os ot">resource "aws_lb_listener_rule" "jupyter_lb_listener_rule" {<br/>  listener_arn = data.aws_lb_listener.lb_listener.arn<br/>  priority = null<br/><br/>  action {<br/>    type = "forward"<br/>    target_group_arn = aws_lb_target_group.jupyter_target_group.arn<br/>  }<br/><br/>  condition {<br/>    field = "host-header"<br/>    values = [<br/>      "jupyter-${random_string.random_string.result}.${var.domain}"]<br/>  }<br/>  depends_on = [<br/>    aws_lb_target_group.jupyter_target_group]<br/>}</span></pre><p id="0e0e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后在Route53中添加指向负载平衡器的CNAME。继续前面的例子，CNAME将是<code class="fe ou ov ow om b">jupyter-123.company.com</code>，它将指向我们的负载平衡器url。</p><pre class="oh oi oj ok gt ol om on oo aw op bi"><span id="ffd0" class="nh kx iq om b gy oq or l os ot">resource "aws_route53_record" "jupyter_cname" {<br/>  zone_id = var.hosted_zone_id<br/>  name = "jupyter-${random_string.random_string.result}.${var.domain}"<br/>  type = "CNAME"<br/>  records = [<br/>    data.aws_lb.lb.dns_name]<br/>  ttl = 300<br/>}</span></pre><p id="9e60" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在一切就绪，我们当然想知道如何访问笔记本，因为一些字符串是随机生成的，我们在开始时已经设置了一个令牌。我们可以通过一个输出变量来实现。</p><pre class="oh oi oj ok gt ol om on oo aw op bi"><span id="0765" class="nh kx iq om b gy oq or l os ot">output "url" {<br/>  value = "${aws_route53_record.jupyter_cname.name}?token=${var.token}"<br/>}</span></pre><h1 id="ee38" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">后续步骤</h1><p id="d1ba" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">目前，Jupyter笔记本无法访问其他AWS资源。因此，您必须在任务定义中提供一个任务角色。此外，当您想要访问VPC中的数据库时，您必须在数据库的安全组中添加入站/入站规则，该规则允许来自附加到ECS服务的安全组的传入流量。<br/>状态现在被设置为本地，因此使用此脚本旋转笔记本的人也要负责销毁它们。</p><h1 id="21a3" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">问题和反馈</h1><p id="5039" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">如果您对本文有任何问题或反馈，请随时联系我或留下您的评论。</p><h1 id="6c97" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">2021年7月更新</h1><p id="d302" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">由于Jupyter docker图像的版本在发布时并没有固定到本文中的特定版本，所以我在<strong class="ka ir"> vars.tfvars </strong>中添加了一个注释。评论中的图片标签是在写这篇文章时docker图片的最新版本。当你想使用docker镜像的最新版本时:GitHub用户<a class="ae lz" href="https://github.com/mvtango" rel="noopener ugc nofollow" target="_blank"> mvtango </a>在我的存储库中创建了一个<a class="ae lz" href="https://github.com/sschrijver/spawn-jupyter-notebook-fargate/pull/1" rel="noopener ugc nofollow" target="_blank"> pull请求</a>。据我了解，最新的图片默认使用的是Jupyter Lab。</p></div></div>    
</body>
</html>