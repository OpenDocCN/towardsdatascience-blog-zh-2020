<html>
<head>
<title>Working with datetime in Pandas DataFrame</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 Pandas 数据框架中使用日期时间</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/working-with-datetime-in-pandas-dataframe-663f7af6c587?source=collection_archive---------0-----------------------#2020-08-28">https://towardsdatascience.com/working-with-datetime-in-pandas-dataframe-663f7af6c587?source=collection_archive---------0-----------------------#2020-08-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e791" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">帮助你开始数据分析的一些熊猫技巧</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/728b7411cfe0c6f22b3789d95b2989c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k3ucbwWRlCQzg4T6DkACZw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@goumbik?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">卢卡斯·布拉塞克</a>在<a class="ae ky" href="https://unsplash.com/s/photos/pandas-time?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="fb26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Datetime 是数据科学项目中常见的数据类型。通常，您会使用它并遇到问题。我发现 Pandas 是一个了不起的库，它包含了处理日期和时间的广泛功能和特性。</p><p id="8d62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将讨论以下常见的日期时间问题，应该可以帮助您开始数据分析。</p><ol class=""><li id="17af" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">将字符串转换为日期时间</li><li id="b1f1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">从多个列组合一个日期时间</li><li id="4427" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">获取年、月和日</li><li id="8c9a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">获取一年中的星期、星期几和闰年</li><li id="9e4c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">从出生日期得到年龄</li><li id="0469" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">通过将日期列设置为索引来提高性能</li><li id="630b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">选择特定年份的数据并执行聚合</li><li id="4555" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">选择具有特定月份和特定日期的数据</li><li id="8f30" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">选择两个日期之间的数据</li><li id="5eda" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">处理缺失值</li></ol><p id="bada" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">源代码请查看我的<a class="ae ky" href="https://github.com/BindiChen/machine-learning/blob/master/data-analysis/008-pandas-datetime/pandas-datetime.ipynb" rel="noopener ugc nofollow" target="_blank"> Github repo </a>。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="a40f" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">1.将字符串转换为日期时间</h1><p id="b576" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">Pandas 有一个名为<code class="fe nn no np nq b">to_datetime()</code>的内置函数，可以用来将字符串转换为日期时间。让我们看一些例子</p><h2 id="e6fb" class="nr mr it bd ms ns nt dn mw nu nv dp na li nw nx nc lm ny nz ne lq oa ob ng oc bi translated">使用默认参数</h2><p id="20e2" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">Pandas <code class="fe nn no np nq b">to_datetime()</code>能够将任何有效的日期字符串解析为 datetime，而不需要任何额外的参数。例如:</p><pre class="kj kk kl km gt od nq oe of aw og bi"><span id="5df2" class="nr mr it nq b gy oh oi l oj ok">df = pd.DataFrame({<strong class="nq iu">'date': ['3/10/2000', '3/11/2000', '3/12/2000']</strong>,<br/>                   'value': [2, 3, 4]})</span><span id="6191" class="nr mr it nq b gy ol oi l oj ok">df['date'] = <strong class="nq iu">pd.to_datetime(df['date'])<br/></strong>df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi om"><img src="../Images/52d2cd66706a0711b58c2791cc786188.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/format:webp/1*ES5afNZqwM_UQvsdIYKEOg.png"/></div></figure><h2 id="971c" class="nr mr it bd ms ns nt dn mw nu nv dp na li nw nx nc lm ny nz ne lq oa ob ng oc bi translated">首日格式</h2><p id="0f80" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">默认情况下，<code class="fe nn no np nq b">to_datetime()</code>会先解析月(<strong class="lb iu"> MM/DD </strong>、<strong class="lb iu"> MM DD、</strong>或<strong class="lb iu"> MM-DD </strong>)格式的字符串，这种安排在美国是比较独特的。</p><p id="93ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在世界上的大多数地方，日期是先写的(<strong class="lb iu"> DD/MM </strong>、<strong class="lb iu"> DD MM </strong>或<strong class="lb iu"> DD-MM </strong>)。如果你想让熊猫先考虑日子而不是月份，你可以将参数<code class="fe nn no np nq b">dayfirst</code>设置为<code class="fe nn no np nq b">True</code>。</p><pre class="kj kk kl km gt od nq oe of aw og bi"><span id="a8da" class="nr mr it nq b gy oh oi l oj ok">df = pd.DataFrame({<strong class="nq iu">'date': ['3/10/2000', '3/11/2000', '3/12/2000']</strong>,<br/>                   'value': [2, 3, 4]})</span><span id="8cd5" class="nr mr it nq b gy ol oi l oj ok">df['date'] = pd.to_datetime(df['date'], <strong class="nq iu">dayfirst=True</strong>)<br/>df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi om"><img src="../Images/e4178b5542287e099ff690fb0f3a892d.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/format:webp/1*U-xB8Ms2YTxdE3W1aGAPRw.png"/></div></figure><p id="ac49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，您可以向参数<code class="fe nn no np nq b">format</code>传递一个自定义格式。</p><h2 id="a3bc" class="nr mr it bd ms ns nt dn mw nu nv dp na li nw nx nc lm ny nz ne lq oa ob ng oc bi translated">自定义格式</h2><p id="b285" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">默认情况下，使用来自<code class="fe nn no np nq b">dateutil.parser.parse</code>的 Pandas 内置解析器解析字符串。有时，您的字符串可能是自定义格式，例如，<strong class="lb iu"> YYYY-DD-MM HH:MM:SS </strong>。熊猫<code class="fe nn no np nq b">to_datetime()</code>有一个名为<code class="fe nn no np nq b">format</code>的参数，它允许你传递一个自定义格式:</p><pre class="kj kk kl km gt od nq oe of aw og bi"><span id="c6c3" class="nr mr it nq b gy oh oi l oj ok">df = pd.DataFrame({<strong class="nq iu">'date': ['2016-6-10 20:30:0', <br/>                            '2016-7-1 19:45:30', <br/>                            '2013-10-12 4:5:1']</strong>,<br/>                   'value': [2, 3, 4]})</span><span id="d247" class="nr mr it nq b gy ol oi l oj ok">df['date'] = pd.to_datetime(df['date'], <strong class="nq iu">format="%Y-%d-%m %H:%M:%S"</strong>)<br/>df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/ae4195accf2048d264850f27dd0b5787.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/format:webp/1*IAC9zzWt5wq2WK3eBX3msQ.png"/></div></figure><h2 id="6797" class="nr mr it bd ms ns nt dn mw nu nv dp na li nw nx nc lm ny nz ne lq oa ob ng oc bi translated">用<code class="fe nn no np nq b">infer_datetime_format</code>加速解析</h2><p id="b0e6" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">如果不是 ISO8601 格式而是常规格式，传递<code class="fe nn no np nq b">infer_datetime_format=True</code>通常可以加快解析速度。根据[1]，在某些情况下，这可以将解析速度提高 5-10 倍。</p><pre class="kj kk kl km gt od nq oe of aw og bi"><span id="c16e" class="nr mr it nq b gy oh oi l oj ok"># Make up 3000 rows<br/>df = pd.DataFrame({'date': ['3/11/2000', '3/12/2000', '3/13/2000'] * 1000 })</span><span id="074c" class="nr mr it nq b gy ol oi l oj ok">%timeit pd.to_datetime(df['date'], <strong class="nq iu">infer_datetime_format=True</strong>)<br/>100 loops, best of 3: <strong class="nq iu">10.4 ms</strong> per loop</span><span id="4512" class="nr mr it nq b gy ol oi l oj ok">%timeit pd.to_datetime(df['date'], <strong class="nq iu">infer_datetime_format=False</strong>)<br/>1 loop, best of 3: <strong class="nq iu">471 ms</strong> per loop</span></pre><h2 id="d54b" class="nr mr it bd ms ns nt dn mw nu nv dp na li nw nx nc lm ny nz ne lq oa ob ng oc bi translated">处理解析错误</h2><p id="65d3" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">如果日期字符串不符合时间戳格式，您将得到一个<strong class="lb iu">类型错误</strong>。</p><pre class="kj kk kl km gt od nq oe of aw og bi"><span id="0746" class="nr mr it nq b gy oh oi l oj ok">df = pd.DataFrame({'date': ['3/10/2000', <strong class="nq iu">'a/11/2000'</strong>, '3/12/2000'],<br/>                   'value': [2, 3, 4]})<br/>df['date'] = pd.to_datetime(df['date'])</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/fa5f08ca50bb1a690fce08d6bd4b710d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iylG22bPTsihssfIg8xApg.png"/></div></div></figure><p id="07bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b">to_datetime()</code>有一个名为<code class="fe nn no np nq b">errors</code>的参数，允许您忽略错误或将无效值强制给<code class="fe nn no np nq b">NaT</code>。</p><pre class="kj kk kl km gt od nq oe of aw og bi"><span id="cef1" class="nr mr it nq b gy oh oi l oj ok">df['date'] = pd.to_datetime(df['date'], <strong class="nq iu">errors='ignore'</strong>)<br/>df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/f4a40a85821a90c6ebc391f57bc3f383.png" data-original-src="https://miro.medium.com/v2/resize:fit:596/format:webp/1*_dcQRlqPJ8pGWbGW9rZy1g.png"/></div></figure><pre class="kj kk kl km gt od nq oe of aw og bi"><span id="a91c" class="nr mr it nq b gy oh oi l oj ok">df['date'] = pd.to_datetime(df['date'], <strong class="nq iu">errors='coerce'</strong>)<br/>df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi om"><img src="../Images/fa8e6641122241dd439958ba27a66636.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/format:webp/1*v0tsgzOni5umcxur2pekew.png"/></div></figure><p id="e526" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，如果您想在从 CSV 文件中读取数据时解析日期列，请查看下面的文章</p><div class="oq or gp gr os ot"><a rel="noopener follow" target="_blank" href="/4-tricks-you-should-know-to-parse-date-columns-with-pandas-read-csv-27355bb2ad0e"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd iu gy z fp oy fr fs oz fu fw is bi translated">您应该知道的用 Pandas read_csv()解析日期列的 4 个技巧</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">一些最有用的熊猫把戏</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">towardsdatascience.com</p></div></div><div class="pc l"><div class="pd l pe pf pg pc ph ks ot"/></div></div></a></div><h1 id="3c4e" class="mq mr it bd ms mt pi mv mw mx pj mz na jz pk ka nc kc pl kd ne kf pm kg ng nh bi translated">2.从多个列组合一个日期时间</h1><p id="61b5" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated"><code class="fe nn no np nq b">to_datetime()</code>也可以用于从多个列组合一个日期时间。键(列标签)可以是常见的缩写，如<strong class="lb iu"> ['年'，'月'，'日'，'分钟'，'秒'，' ms '，' us '，' ns']) </strong>或相同的复数。</p><pre class="kj kk kl km gt od nq oe of aw og bi"><span id="0948" class="nr mr it nq b gy oh oi l oj ok">df = pd.DataFrame(<strong class="nq iu">{'year': [2015, 2016],<br/>                   'month': [2, 3],<br/>                   'day': [4, 5]}</strong>)</span><span id="ebb8" class="nr mr it nq b gy ol oi l oj ok">df['date'] = pd.to_datetime(df)<br/>df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/3369af0f4fe93ff803d176a811205a7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/1*houtxJGZYJEG2SZjF9LEng.png"/></div></figure><h1 id="8691" class="mq mr it bd ms mt pi mv mw mx pj mz na jz pk ka nc kc pl kd ne kf pm kg ng nh bi translated">3.获取年、月和日</h1><p id="99a8" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated"><code class="fe nn no np nq b">dt.year</code>、<code class="fe nn no np nq b">dt.month</code>和<code class="fe nn no np nq b">dt.day</code>是从熊猫日期时间对象中获取年、月和日的内置属性。</p><p id="1318" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们创建一个伪 DateFrame 并将<strong class="lb iu"> DoB </strong>解析为 datetime。</p><pre class="kj kk kl km gt od nq oe of aw og bi"><span id="db6f" class="nr mr it nq b gy oh oi l oj ok">df = pd.DataFrame({'name': ['Tom', 'Andy', 'Lucas'],<br/>                 'DoB': ['08-05-1997', '04-28-1996', '12-16-1995']})<br/>df['DoB'] = <strong class="nq iu">pd.to_datetime(df['DoB'])</strong></span></pre><p id="9fbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">得到年、月、日</p><pre class="kj kk kl km gt od nq oe of aw og bi"><span id="0745" class="nr mr it nq b gy oh oi l oj ok">df['year']= <strong class="nq iu">df['DoB'].dt.year</strong><br/>df['month']= <strong class="nq iu">df['DoB'].dt.month</strong><br/>df['day']= <strong class="nq iu">df['DoB'].dt.day</strong><br/>df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi po"><img src="../Images/e4485c5226b8628d3a31d8a3394366e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/1*amyy1KgAVfiIftyN-oZCTg.png"/></div></figure><h1 id="3074" class="mq mr it bd ms mt pi mv mw mx pj mz na jz pk ka nc kc pl kd ne kf pm kg ng nh bi translated">4.获取一年中的星期、星期几和闰年</h1><p id="d5ab" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">类似地，<code class="fe nn no np nq b">dt.week</code>、<code class="fe nn no np nq b">dt.dayofweek</code>和<code class="fe nn no np nq b">dt.is_leap_year</code>是获取一年中的星期、星期几和闰年的内置属性。</p><pre class="kj kk kl km gt od nq oe of aw og bi"><span id="efd7" class="nr mr it nq b gy oh oi l oj ok">df['week_of_year'] = <strong class="nq iu">df['DoB'].dt.week</strong><br/>df['day_of_week'] = <strong class="nq iu">df['DoB'].dt.dayofweek</strong><br/>df['is_leap_year'] = <strong class="nq iu">df['DoB'].dt.is_leap_year</strong><br/>df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pp"><img src="../Images/8571df6644602639480069de1dc0f732.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mEEPiKmkOT3FNr34515r2A.png"/></div></div></figure><p id="3c13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，Pandas <code class="fe nn no np nq b"><strong class="lb iu"> dt.dayofweek</strong></code>属性返回一周中的某一天，并且假设该周从星期一开始，用 0 表示，到星期天结束，用 6 表示。要用全名替换号码，我们可以创建一个映射并将其传递给<code class="fe nn no np nq b">map()</code>:</p><pre class="kj kk kl km gt od nq oe of aw og bi"><span id="fd62" class="nr mr it nq b gy oh oi l oj ok"><strong class="nq iu">dw_mapping={<br/>    0: 'Monday', <br/>    1: 'Tuesday', <br/>    2: 'Wednesday', <br/>    3: 'Thursday', <br/>    4: 'Friday',<br/>    5: 'Saturday', <br/>    6: 'Sunday'<br/>} </strong><br/>df['day_of_week_name']=df['DoB'].dt.weekday<strong class="nq iu">.map(dw_mapping)</strong><br/>df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pq"><img src="../Images/34f852a68b4ec1d51382d96139b73253.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zma8uR03--m0bWL7gpjM8A.png"/></div></div></figure><h1 id="aae9" class="mq mr it bd ms mt pi mv mw mx pj mz na jz pk ka nc kc pl kd ne kf pm kg ng nh bi translated">5.从出生日期得到年龄</h1><p id="c209" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">获得年龄的最简单方法是减去年份:</p><pre class="kj kk kl km gt od nq oe of aw og bi"><span id="68af" class="nr mr it nq b gy oh oi l oj ok"><strong class="nq iu">today = pd.to_datetime('today')</strong><br/>df['age'] = <strong class="nq iu">today.year - df['DoB'].dt.year</strong></span><span id="3e3b" class="nr mr it nq b gy ol oi l oj ok">df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pr"><img src="../Images/9fe3d3b56575d24e11465d20510ed2c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ns-WVKQ66JWalKT86qlOcg.png"/></div></div></figure><p id="ce64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，这是不准确的，因为人们今年可能还没有过生日。更准确的解决方案是考虑生日</p><pre class="kj kk kl km gt od nq oe of aw og bi"><span id="9091" class="nr mr it nq b gy oh oi l oj ok"># Year difference<br/>today = pd.to_datetime('today')<br/>diff_y = today.year - df['DoB'].dt.year<br/># Haven't had birthday<br/>b_md = df['DoB'].apply(lambda x: (x.month,x.day) )<br/><strong class="nq iu">no_birthday = b_md &gt; (today.month,today.day)</strong></span><span id="740d" class="nr mr it nq b gy ol oi l oj ok">df['age'] = <strong class="nq iu">diff_y - no_birthday</strong><br/>df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ps"><img src="../Images/d47ea73ebe319557742fa1063eb72ce0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3iR2_jhgqlIqSyTW6q40yg.png"/></div></div></figure><h1 id="5b13" class="mq mr it bd ms mt pi mv mw mx pj mz na jz pk ka nc kc pl kd ne kf pm kg ng nh bi translated">6.通过将日期列设置为索引来提高性能</h1><p id="4dd8" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">按日期选择数据的常见解决方案是使用布尔马克斯。例如</p><pre class="kj kk kl km gt od nq oe of aw og bi"><span id="d149" class="nr mr it nq b gy oh oi l oj ok">condition = <!-- -->(df['date'] &gt; start_date) &amp; (df['date'] &lt;= end_date)<br/>df.loc[condition]</span></pre><p id="a8c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该解决方案通常要求<code class="fe nn no np nq b">start_date</code>、<code class="fe nn no np nq b">end_date</code>和<strong class="lb iu">日期</strong>列为日期时间格式。事实上，当您在大型数据集中按日期进行大量选择时，这种解决方案会很慢。</p><p id="baea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您要按日期进行大量选择，首先将日期列设置为索引会更快，这样您就可以利用 Pandas 内置的优化。然后，您可以使用<code class="fe nn no np nq b">df.loc[start_date:end_date]</code>按日期选择数据。让我们看一个示例数据集 city_sales.csv，它有 1，795，144 行数据</p><pre class="kj kk kl km gt od nq oe of aw og bi"><span id="8520" class="nr mr it nq b gy oh oi l oj ok">df = pd.read_csv('data/city_sales.csv',parse_dates=['date'])<br/>df.info()</span><span id="23aa" class="nr mr it nq b gy ol oi l oj ok">RangeIndex: <strong class="nq iu">1795144</strong> entries, 0 to 1795143<br/>Data columns (total 3 columns):<br/> #   Column  Dtype         <br/>---  ------  -----         <br/> 0   date    datetime64[ns]<br/> 1   num     int64         <br/> 2   city    object        <br/>dtypes: datetime64[ns](1), int64(1), object(1)<br/>memory usage: 41.1+ MB</span></pre><p id="c8c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将日期列设置为索引</p><pre class="kj kk kl km gt od nq oe of aw og bi"><span id="1f4e" class="nr mr it nq b gy oh oi l oj ok"><strong class="nq iu">df = df.set_index(['date'])</strong><br/>df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pt"><img src="../Images/61997b46478d0d3b6d0472ed871648dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*k5byTosFphsSHZkvVkDd_A.png"/></div></figure><h1 id="f4d0" class="mq mr it bd ms mt pi mv mw mx pj mz na jz pk ka nc kc pl kd ne kf pm kg ng nh bi translated">7.选择特定年份的数据并执行聚合</h1><p id="2667" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">假设我们想要选择 2018 年的所有数据</p><pre class="kj kk kl km gt od nq oe of aw og bi"><span id="1b0a" class="nr mr it nq b gy oh oi l oj ok">df.loc['2018']</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pu"><img src="../Images/f2bec4aee597858c8c159cf0dda43b33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*yBY5wzERcpgF2_UY-w7zIQ.png"/></div></figure><p id="d1f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并对选择执行聚合，例如:</p><p id="e406" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">获取 2018 年总人数</p><pre class="kj kk kl km gt od nq oe of aw og bi"><span id="941e" class="nr mr it nq b gy oh oi l oj ok">df.loc<strong class="nq iu">['2018','num'].sum()</strong></span><span id="31b8" class="nr mr it nq b gy ol oi l oj ok"><strong class="nq iu">1231190</strong></span></pre><p id="23c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">获取 2018 年每个城市的总人数</p><pre class="kj kk kl km gt od nq oe of aw og bi"><span id="3886" class="nr mr it nq b gy oh oi l oj ok">df['2018']<strong class="nq iu">.groupby('city').sum()</strong></span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pv"><img src="../Images/6b81357e142cc1ca2a42bf12d1584631.png" data-original-src="https://miro.medium.com/v2/resize:fit:604/format:webp/1*MeSInvHJu6Nts0WaJtuYgw.png"/></div></figure><h1 id="40e1" class="mq mr it bd ms mt pi mv mw mx pj mz na jz pk ka nc kc pl kd ne kf pm kg ng nh bi translated">8.选择具有特定月份和特定日期的数据</h1><p id="c644" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">选择特定月份的数据，例如 2018 年 5 月</p><pre class="kj kk kl km gt od nq oe of aw og bi"><span id="580f" class="nr mr it nq b gy oh oi l oj ok">df.loc[<strong class="nq iu">'2018-5'</strong>]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pw"><img src="../Images/d1c02bcc9e7f2a7ca58aab8abc0dcea6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*sWA9DvYwXdoyVHnPhUVpTw.png"/></div></figure><p id="b91b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似地，选择一个月中特定日期的数据，例如 2018 年 5 月 1 日</p><pre class="kj kk kl km gt od nq oe of aw og bi"><span id="a7bc" class="nr mr it nq b gy oh oi l oj ok">df.loc[<strong class="nq iu">'2018-5-1'</strong>]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pw"><img src="../Images/d1c02bcc9e7f2a7ca58aab8abc0dcea6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*sWA9DvYwXdoyVHnPhUVpTw.png"/></div></figure><h1 id="bc09" class="mq mr it bd ms mt pi mv mw mx pj mz na jz pk ka nc kc pl kd ne kf pm kg ng nh bi translated">9 选择两个日期之间的数据</h1><p id="4ba4" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">要选择两个日期之间的数据，可以使用<code class="fe nn no np nq b">df.loc[start_date:end_date]</code>例如:</p><p id="020f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">选择 2016 年到 2018 年之间的数据</p><pre class="kj kk kl km gt od nq oe of aw og bi"><span id="f5d5" class="nr mr it nq b gy oh oi l oj ok">df.loc[<strong class="nq iu">'2016' : '2018'</strong>]</span></pre><p id="3046" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">选择 2018 年 5 月 2 日 10 点到 11 点之间的数据</p><pre class="kj kk kl km gt od nq oe of aw og bi"><span id="6cfc" class="nr mr it nq b gy oh oi l oj ok">df.loc[<strong class="nq iu">'2018-5-2 10' : '2018-5-2 11'</strong> ]</span></pre><p id="c832" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">选择 2018 年 5 月 2 日 10:30 至 10:45 之间的数据</p><pre class="kj kk kl km gt od nq oe of aw og bi"><span id="934c" class="nr mr it nq b gy oh oi l oj ok">df.loc[<strong class="nq iu">'2018-5-2 10:30' : '2018-5-2 10:45'</strong> ]</span></pre><p id="e1f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而要选择时间之间的数据，我们要用<code class="fe nn no np nq b">between_time()</code>，比如 10:30 和 10:45</p><pre class="kj kk kl km gt od nq oe of aw og bi"><span id="1276" class="nr mr it nq b gy oh oi l oj ok">df.<strong class="nq iu">between_time('10:30','10:45')</strong></span></pre><h1 id="9a90" class="mq mr it bd ms mt pi mv mw mx pj mz na jz pk ka nc kc pl kd ne kf pm kg ng nh bi translated">10 处理缺失值</h1><p id="fdb2" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我们经常需要计算窗口统计，例如<strong class="lb iu">滚动平均值</strong>或<strong class="lb iu">滚动总和。</strong></p><p id="4cd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们计算 3 个窗口期间的滚动总和，然后看看前 5 行。</p><pre class="kj kk kl km gt od nq oe of aw og bi"><span id="65d2" class="nr mr it nq b gy oh oi l oj ok">df['rolling_sum'] = <strong class="nq iu">df.rolling(3).sum()</strong><br/>df.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi px"><img src="../Images/53c01439dabfae206f542cf910280b26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*I8wgxcoYWU5kCsJ7vV4ftA.png"/></div></figure><p id="1f47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到，只有当有 3 个周期可以回顾时，它才开始有有效值。处理这个问题的一个解决方案是通过<strong class="lb iu">回填数据</strong>。</p><pre class="kj kk kl km gt od nq oe of aw og bi"><span id="10cb" class="nr mr it nq b gy oh oi l oj ok">df['rolling_sum_backfilled'] = <strong class="nq iu">df['rolling_sum'].fillna(method='backfill')</strong><br/>df.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi py"><img src="../Images/550e18fe8d0a9352eb4f12c37c5a6a8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CJSHG-MKgjKqFGmDbVnrhg.png"/></div></div></figure><p id="c294" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有关回填的更多细节，请查看以下文章</p><div class="oq or gp gr os ot"><a rel="noopener follow" target="_blank" href="/working-with-missing-values-in-pandas-5da45d16e74"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd iu gy z fp oy fr fs oz fu fw is bi translated">处理熊猫中缺失的值</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">关于 Pandas 中缺失值以及如何使用内置方法处理它们的教程</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">towardsdatascience.com</p></div></div><div class="pc l"><div class="pz l pe pf pg pc ph ks ot"/></div></div></a></div><h1 id="bb9d" class="mq mr it bd ms mt pi mv mw mx pj mz na jz pk ka nc kc pl kd ne kf pm kg ng nh bi translated">好了</h1><p id="36ff" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">感谢阅读。</p><p id="1533" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请在我的 Github 笔记本上查看源代码。</p><p id="cd0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你对机器学习的实用方面感兴趣，请继续关注。</p><p id="9eae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是为您挑选的一些文章:</p><ul class=""><li id="7f92" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu qa mb mc md bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/working-with-missing-values-in-pandas-5da45d16e74">处理熊猫中缺失的值</a></li><li id="acad" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu qa mb mc md bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/4-tricks-you-should-know-to-parse-date-columns-with-pandas-read-csv-27355bb2ad0e">用熊猫 read_csv()解析日期列的 4 个技巧</a></li><li id="cefd" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu qa mb mc md bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/all-the-pandas-read-csv-you-should-know-to-speed-up-your-data-analysis-1e16fe1039f3">熊猫 read_csv()加快数据分析速度你应该知道的小技巧</a></li><li id="379c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu qa mb mc md bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/6-pandas-tricks-you-should-know-to-speed-up-your-data-analysis-d3dec7c29e5">加快数据分析速度你应该知道的 6 个熊猫技巧</a></li><li id="ea12" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu qa mb mc md bi translated">数据科学项目开始时应该包括的 7 个设置。</li></ul><h1 id="3ae8" class="mq mr it bd ms mt pi mv mw mx pj mz na jz pk ka nc kc pl kd ne kf pm kg ng nh bi translated">参考</h1><ul class=""><li id="01a0" class="lv lw it lb b lc ni lf nj li qb lm qc lq qd lu qa mb mc md bi translated">[1] <a class="ae ky" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.to_datetime.html" rel="noopener ugc nofollow" target="_blank">熊猫来 _ 日期时间官方文件</a></li></ul></div></div>    
</body>
</html>