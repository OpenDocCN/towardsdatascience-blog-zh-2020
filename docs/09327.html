<html>
<head>
<title>Detecting Face Features with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Python 检测人脸特征</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/detecting-face-features-with-python-30385aee4a8e?source=collection_archive---------3-----------------------#2020-07-04">https://towardsdatascience.com/detecting-face-features-with-python-30385aee4a8e?source=collection_archive---------3-----------------------#2020-07-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="1e41" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">计算机视觉</h2><div class=""/><div class=""><h2 id="3563" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">使用 OpenCV 和 DLib 识别人脸并提取最多 6 个面部特征</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/3981bf7ffbed7531a54bd8825f38ccbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HmCGgmMlJLEYJYCNRcQ2Tg.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者的形象</p></figure><p id="d3a8" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">今天我们将学习如何使用图像来检测人脸并提取面部特征，如眼睛、鼻子、嘴巴等。我们可以做许多令人难以置信的事情，将这些信息作为预处理步骤，如捕捉人脸以标记照片中的人(手动或通过机器学习)，创建效果以“增强”我们的图像(类似于 Snapchat 等应用程序中的那些)，对人脸进行情感分析等等。</p><p id="ae13" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">过去，我们已经介绍过如何使用 OpenCV 来检测图像中的形状，但今天我们将通过引入 DLib 和从图像中提取人脸特征来将它提升到一个新的水平。</p><div class="md me gp gr mf mg"><a rel="noopener follow" target="_blank" href="/essential-opencv-functions-to-get-you-started-into-computer-vision-743df932e60"><div class="mh ab fo"><div class="mi ab mj cl cj mk"><h2 class="bd jd gy z fp ml fr fs mm fu fw jc bi translated">帮助您开始学习计算机视觉的基本 OpenCV 函数</h2><div class="mn l"><h3 class="bd b gy z fp ml fr fs mm fu fw dk translated">了解常见的 OpenCV 函数及其应用，帮助您开始学习计算机视觉。</h3></div><div class="mo l"><p class="bd b dl z fp ml fr fs mm fu fw dk translated">towardsdatascience.com</p></div></div><div class="mp l"><div class="mq l mr ms mt mp mu lb mg"/></div></div></a></div><p id="06dd" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><a class="ae mv" href="http://dlib.net/" rel="noopener ugc nofollow" target="_blank"> Dlib </a>是一个先进的机器学习库，旨在解决复杂的现实世界问题。这个库是使用 C++编程语言创建的，它可以与 C/C++、Python 和 Java 一起工作。</p><p id="ca69" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">值得注意的是，本教程可能需要对 OpenCV 库有一些了解，比如如何处理图像、打开相机、图像处理和一些小技巧。</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="4be7" class="nd ne it bd nf ng nh ni nj nk nl nm nn ki no kj np kl nq km nr ko ns kp nt nu bi translated">它是如何工作的？</h1><p id="9861" class="pw-post-body-paragraph lh li it lj b lk nv kd lm ln nw kg lp lq nx ls lt lu ny lw lx ly nz ma mb mc im bi translated">我们的脸有几个可以被识别的特征，像我们的眼睛、嘴巴、鼻子等等。当我们使用 DLib 算法来检测这些特征时，我们实际上获得了围绕每个特征的点的地图。</p><p id="1bb2" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这张由 67 个点(称为地标点)组成的地图可以识别以下特征:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/f61ea146790248056592ab5837f0cbf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/format:webp/0*L5z5AX73DUEl5klI.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">点地图</p></figure><ul class=""><li id="854d" class="ob oc it lj b lk ll ln lo lq od lu oe ly of mc og oh oi oj bi translated">颌点= 0–16</li><li id="6bfc" class="ob oc it lj b lk ok ln ol lq om lu on ly oo mc og oh oi oj bi translated">右眉点数= 17–21</li><li id="3ccf" class="ob oc it lj b lk ok ln ol lq om lu on ly oo mc og oh oi oj bi translated">左眉点数= 22–26</li><li id="836e" class="ob oc it lj b lk ok ln ol lq om lu on ly oo mc og oh oi oj bi translated">鼻点= 27–35°</li><li id="e244" class="ob oc it lj b lk ok ln ol lq om lu on ly oo mc og oh oi oj bi translated">右眼点数= 36–41</li><li id="35fe" class="ob oc it lj b lk ok ln ol lq om lu on ly oo mc og oh oi oj bi translated">左眼点数= 42–47</li><li id="812f" class="ob oc it lj b lk ok ln ol lq om lu on ly oo mc og oh oi oj bi translated">嘴部点数= 48–60</li><li id="4dde" class="ob oc it lj b lk ok ln ol lq om lu on ly oo mc og oh oi oj bi translated">嘴唇点数= 61–67</li></ul><p id="8d65" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在我们已经知道了一些我们计划如何提取特性，让我们开始编码吧。</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="1478" class="nd ne it bd nf ng nh ni nj nk nl nm nn ki no kj np kl nq km nr ko ns kp nt nu bi translated">安装要求</h1><p id="04d2" class="pw-post-body-paragraph lh li it lj b lk nv kd lm ln nw kg lp lq nx ls lt lu ny lw lx ly nz ma mb mc im bi translated">像往常一样，本文将提供带有代码的示例，我将一步一步地指导您实现一个完整的人脸特征识别示例。但是在我们开始之前，您需要启动一个新的 Python 项目并安装 3 个不同的库:</p><ul class=""><li id="9b48" class="ob oc it lj b lk ll ln lo lq od lu oe ly of mc og oh oi oj bi translated">opencv-python</li><li id="8d2c" class="ob oc it lj b lk ok ln ol lq om lu on ly oo mc og oh oi oj bi translated">dlib</li></ul><p id="7e6f" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果你像我一样使用<code class="fe op oq or os b">pipenv</code>，你可以用下面的命令安装它们:</p><pre class="ks kt ku kv gt ot os ou ov aw ow bi"><span id="9d7a" class="ox ne it os b gy oy oz l pa pb">pipenv install opencv-python, dlib</span></pre><p id="6077" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果你在 Mac 和某些版本的 Linux 上工作，你可能会在安装 dlib 时遇到一些问题，如果你在安装过程中遇到编译错误，请确保检查你正在使用的 CMake 库版本。在 Mac 中，要确保您有 CMake 可用并且版本正确，您可以运行:</p><pre class="ks kt ku kv gt ot os ou ov aw ow bi"><span id="751c" class="ox ne it os b gy oy oz l pa pb">brew install cmake</span></pre><p id="a900" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">对于其他操作系统，请在线查看具体支持。</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="d4d7" class="nd ne it bd nf ng nh ni nj nk nl nm nn ki no kj np kl nq km nr ko ns kp nt nu bi translated">步骤 1:加载并显示图像</h1><p id="e708" class="pw-post-body-paragraph lh li it lj b lk nv kd lm ln nw kg lp lq nx ls lt lu ny lw lx ly nz ma mb mc im bi translated">我们将从小处着手，构建代码，直到我们有一个完整的工作示例。</p><p id="0058" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">通常我喜欢使用绘图来渲染图像，但是因为我们在帖子的后面准备了一些很酷的东西，我们将做一些不同的事情，我们将创建一个窗口来显示我们的工作结果。</p><p id="795c" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">让我们直接进入代码</p><pre class="ks kt ku kv gt ot os ou ov aw ow bi"><span id="0a1d" class="ox ne it os b gy oy oz l pa pb">import cv2</span><span id="d326" class="ox ne it os b gy pc oz l pa pb"># read the image<br/>img = cv2.imread("face.jpg")</span><span id="ec0b" class="ox ne it os b gy pc oz l pa pb"># show the image<br/>cv2.imshow(winname="Face", mat=img)</span><span id="cb70" class="ox ne it os b gy pc oz l pa pb"># Wait for a key press to exit<br/>cv2.waitKey(delay=0)</span><span id="c060" class="ox ne it os b gy pc oz l pa pb"># Close all windows<br/>cv2.destroyAllWindows()</span></pre><p id="a5a6" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">很简单，对吧？我们只是用<code class="fe op oq or os b">imread</code>加载图像，然后告诉 OpenCV 在<code class="fe op oq or os b">winname</code>中显示图像，这将打开窗口并给它一个标题。</p><p id="b313" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">之后，我们需要暂停执行，因为当脚本停止时窗口会被破坏，所以我们使用<code class="fe op oq or os b">cv2.waitKey</code>按住窗口直到按下一个键，之后，我们破坏窗口并退出脚本。</p><p id="5096" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果您使用代码并将名为<code class="fe op oq or os b">face.jpg</code>的图像添加到代码目录中，您应该会得到如下所示的内容:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pd"><img src="../Images/81182429636af1b805952edbc2f9fccf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nw617u4p2mEH08NI1Rukrg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">原象</p></figure></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="fe7c" class="nd ne it bd nf ng nh ni nj nk nl nm nn ki no kj np kl nq km nr ko ns kp nt nu bi translated">第二步:面部识别</h1><p id="e7a1" class="pw-post-body-paragraph lh li it lj b lk nv kd lm ln nw kg lp lq nx ls lt lu ny lw lx ly nz ma mb mc im bi translated">到目前为止，我们还没有对图像做任何事情，除了将它显示在一个窗口中，相当无聊，但是现在我们将开始编码好的东西，我们将从识别图像中哪里有人脸开始。</p><p id="7733" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">为此，我们将使用名为<code class="fe op oq or os b">get_frontal_face_detector()</code>的 Dlib 函数，相当直观。不过有一个警告，这个函数只适用于灰度图像，所以我们必须先用 OpenCV 来实现。</p><p id="6aa5" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><code class="fe op oq or os b">get_frontal_face_detector()</code>将返回一个<code class="fe op oq or os b">detector</code>，这是一个我们可以用来检索人脸信息的函数。每个面都是一个对象，包含可以找到图像的点。</p><p id="6850" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">但是让我们更好地在代码上看到它:</p><pre class="ks kt ku kv gt ot os ou ov aw ow bi"><span id="ff9e" class="ox ne it os b gy oy oz l pa pb">import cv2<br/>import dlib</span><span id="786b" class="ox ne it os b gy pc oz l pa pb"># Load the detector<br/>detector = dlib.get_frontal_face_detector()</span><span id="638b" class="ox ne it os b gy pc oz l pa pb"># read the image<br/>img = cv2.imread("face.jpg")</span><span id="2792" class="ox ne it os b gy pc oz l pa pb"># Convert image into grayscale<br/>gray = cv2.cvtColor(src=img, code=cv2.COLOR_BGR2GRAY)</span><span id="5435" class="ox ne it os b gy pc oz l pa pb"># Use detector to find landmarks<br/>faces = detector(gray)</span><span id="90df" class="ox ne it os b gy pc oz l pa pb">for face in faces:<br/>    x1 = face.left() # left point<br/>    y1 = face.top() # top point<br/>    x2 = face.right() # right point<br/>    y2 = face.bottom() # bottom point<br/>    # Draw a rectangle<br/>    cv2.rectangle(img=img, pt1=(x1, y1), pt2=(x2, y2), color=(0, 255, 0), thickness=4)</span><span id="3e3d" class="ox ne it os b gy pc oz l pa pb"># show the image<br/>cv2.imshow(winname="Face", mat=img)</span><span id="79fe" class="ox ne it os b gy pc oz l pa pb"># Wait for a key press to exit<br/>cv2.waitKey(delay=0)</span><span id="7999" class="ox ne it os b gy pc oz l pa pb"># Close all windows<br/>cv2.destroyAllWindows()</span></pre><p id="7242" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">上面的代码将从图像中检索所有的面，并在每个面上呈现一个矩形，生成如下所示的图像:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/e1fd9003d92c10ce6a8fcf77fc7d85a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hm0kh74F8jTBrT1QN6kaLQ.jpeg"/></div></div></figure><p id="2a64" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">到目前为止，我们在寻找人脸方面做得很好，但我们仍然需要一些工作来提取所有的特征(标志)。接下来让我们继续。</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="c0c6" class="nd ne it bd nf ng nh ni nj nk nl nm nn ki no kj np kl nq km nr ko ns kp nt nu bi translated">第三步:识别面部特征</h1><p id="a672" class="pw-post-body-paragraph lh li it lj b lk nv kd lm ln nw kg lp lq nx ls lt lu ny lw lx ly nz ma mb mc im bi translated">你喜欢魔术吗？到目前为止，DLib 的工作方式非常神奇，只用几行代码我们就可以完成很多工作，现在我们有了一个全新的问题，它会继续这么简单吗？</p><p id="344d" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">简短的回答是肯定的！原来 DLib 提供了一个名为<code class="fe op oq or os b">shape_predictor()</code>的函数，它将为我们完成所有的魔法，但有一个警告，它需要一个预先训练好的模型才能工作。</p><p id="f8ed" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">有几个型号可以与<code class="fe op oq or os b">shape_predictor</code>一起工作，我正在使用的型号可以在这里下载<a class="ae mv" href="https://github.com/italojs/facial-landmarks-recognition/blob/master/shape_predictor_68_face_landmarks.dat" rel="noopener ugc nofollow" target="_blank">，但也可以尝试其他型号。</a></p><p id="5b84" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">让我们看看新代码现在是什么样子</p><pre class="ks kt ku kv gt ot os ou ov aw ow bi"><span id="bb94" class="ox ne it os b gy oy oz l pa pb">import cv2<br/>import dlib</span><span id="3961" class="ox ne it os b gy pc oz l pa pb"># Load the detector<br/>detector = dlib.get_frontal_face_detector()</span><span id="475f" class="ox ne it os b gy pc oz l pa pb"># Load the predictor<br/>predictor = dlib.shape_predictor("shape_predictor_68_face_landmarks.dat")</span><span id="b795" class="ox ne it os b gy pc oz l pa pb"># read the image<br/>img = cv2.imread("face.jpg")</span><span id="50b9" class="ox ne it os b gy pc oz l pa pb"># Convert image into grayscale<br/>gray = cv2.cvtColor(src=img, code=cv2.COLOR_BGR2GRAY)</span><span id="eeee" class="ox ne it os b gy pc oz l pa pb"># Use detector to find landmarks<br/>faces = detector(gray)</span><span id="5d12" class="ox ne it os b gy pc oz l pa pb">for face in faces:<br/>    x1 = face.left() # left point<br/>    y1 = face.top() # top point<br/>    x2 = face.right() # right point<br/>    y2 = face.bottom() # bottom point</span><span id="6db4" class="ox ne it os b gy pc oz l pa pb">    # Look for the landmarks<br/>    landmarks = predictor(image=gray, box=face)<br/>    x = landmarks.part(27).x<br/>    y = landmarks.part(27).y</span><span id="4d6e" class="ox ne it os b gy pc oz l pa pb">    # Draw a circle<br/>    cv2.circle(img=img, center=(x, y), radius=5, color=(0, 255, 0), thickness=-1)</span><span id="3c26" class="ox ne it os b gy pc oz l pa pb"># show the image<br/>cv2.imshow(winname="Face", mat=img)</span><span id="e1c4" class="ox ne it os b gy pc oz l pa pb"># Wait for a key press to exit<br/>cv2.waitKey(delay=0)</span><span id="dfab" class="ox ne it os b gy pc oz l pa pb"># Close all windows<br/>cv2.destroyAllWindows()</span></pre><p id="0d48" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">像以前一样，我们总是建立在相同的代码上，现在对每张脸使用我们的预测函数来找到界标。现在我仍然在做一些奇怪的事情，比如 27 号在那里做什么？</p><pre class="ks kt ku kv gt ot os ou ov aw ow bi"><span id="5949" class="ox ne it os b gy oy oz l pa pb">landmarks = predictor(image=gray, box=face)<br/>x = landmarks.part(27).x<br/>y = landmarks.part(27).y</span></pre><p id="af38" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们的预测函数将返回一个对象，该对象包含所有 68 个点，根据我们之前看到的图表，这些点符合一张脸，如果您注意它，点 27 正好在两眼之间，因此如果计算正确，您应该会在脸的两眼之间看到一个绿点，如下所示:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/d25f3003dc9dbc4d02ce0c6490fe4363.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GM6vUsVOsbRAN9XkoDStAA.jpeg"/></div></div></figure><p id="0e1c" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们越来越接近了，现在让我们渲染所有的点，而不仅仅是一个点:</p><pre class="ks kt ku kv gt ot os ou ov aw ow bi"><span id="10eb" class="ox ne it os b gy oy oz l pa pb">import cv2<br/>import numpy as np<br/>import dlib</span><span id="d7c5" class="ox ne it os b gy pc oz l pa pb"># Load the detector<br/>detector = dlib.get_frontal_face_detector()</span><span id="9894" class="ox ne it os b gy pc oz l pa pb"># Load the predictor<br/>predictor = dlib.shape_predictor("shape_predictor_68_face_landmarks.dat")</span><span id="626a" class="ox ne it os b gy pc oz l pa pb"># read the image<br/>img = cv2.imread("face.jpg")</span><span id="564f" class="ox ne it os b gy pc oz l pa pb"># Convert image into grayscale<br/>gray = cv2.cvtColor(src=img, code=cv2.COLOR_BGR2GRAY)</span><span id="5847" class="ox ne it os b gy pc oz l pa pb"># Use detector to find landmarks<br/>faces = detector(gray)<br/>for face in faces:<br/>    x1 = face.left() # left point<br/>    y1 = face.top() # top point<br/>    x2 = face.right() # right point<br/>    y2 = face.bottom() # bottom point</span><span id="e64d" class="ox ne it os b gy pc oz l pa pb">    # Create landmark object<br/>    landmarks = predictor(image=gray, box=face)</span><span id="b7f0" class="ox ne it os b gy pc oz l pa pb">    # Loop through all the points<br/>    for n in range(0, 68):<br/>        x = landmarks.part(n).x<br/>        y = landmarks.part(n).y</span><span id="f6e6" class="ox ne it os b gy pc oz l pa pb">        # Draw a circle<br/>        cv2.circle(img=img, center=(x, y), radius=3, color=(0, 255, 0), thickness=-1)</span><span id="3c49" class="ox ne it os b gy pc oz l pa pb"># show the image<br/>cv2.imshow(winname="Face", mat=img)</span><span id="89dc" class="ox ne it os b gy pc oz l pa pb"># Delay between every fram<br/>cv2.waitKey(delay=0)</span><span id="49a8" class="ox ne it os b gy pc oz l pa pb"># Close all windows<br/>cv2.destroyAllWindows()</span></pre><p id="66a8" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">Tada！魔力:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/92ef910a0f5fe39f79eaa89c4e9e0fe0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W6l_yH5YxocPtycQdMV3Iw.jpeg"/></div></div></figure><p id="2fcc" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">但是如果你对所有的点都不感兴趣呢？嗯……你实际上可以调整你的<code class="fe op oq or os b">range</code>间隔来获得上面词汇表中指定的任何特性，就像我在这里做的那样:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/46c7b191580d700bd710f19ca07b8c16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wrROUt9yTpbjAF3OtFSkyw.jpeg"/></div></div></figure><p id="2e1a" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">太棒了，但我们能做些更酷的吗？</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="620e" class="nd ne it bd nf ng nh ni nj nk nl nm nn ki no kj np kl nq km nr ko ns kp nt nu bi translated">步骤 4:实时检测</h1><p id="6d78" class="pw-post-body-paragraph lh li it lj b lk nv kd lm ln nw kg lp lq nx ls lt lu ny lw lx ly nz ma mb mc im bi translated">是的，你没看错！是的，这可能就是你所想的！下一步是连接我们的网络摄像头，从您的视频流中进行实时地标识别。</p><p id="5034" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">你可以通过相机或使用视频文件遍历视频帧，在你的脸上进行实时面部标志检测。参考下面的代码，如果你想使用自己的摄像头，但对于视频文件，请确保将数字 0 改为视频路径。</p><p id="f27d" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果您想结束窗口，请按键盘上的 ESC 键:</p><pre class="ks kt ku kv gt ot os ou ov aw ow bi"><span id="f055" class="ox ne it os b gy oy oz l pa pb">import cv2<br/>import dlib<br/><br/># Load the detector<br/>detector = dlib.get_frontal_face_detector()<br/><br/># Load the predictor<br/>predictor = dlib.shape_predictor("shape_predictor_68_face_landmarks.dat")<br/><br/># read the image<br/>cap = cv2.VideoCapture(0)<br/><br/>while True:<br/>    _, frame = cap.read()<br/>    # Convert image into grayscale<br/>    gray = cv2.cvtColor(src=frame, code=cv2.COLOR_BGR2GRAY)<br/><br/>    # Use detector to find landmarks<br/>    faces = detector(gray)<br/><br/>    for face in faces:<br/>        x1 = face.left()  # left point<br/>        y1 = face.top()  # top point<br/>        x2 = face.right()  # right point<br/>        y2 = face.bottom()  # bottom point<br/><br/>        # Create landmark object<br/>        landmarks = predictor(image=gray, box=face)<br/><br/>        # Loop through all the points<br/>        for n in range(0, 68):<br/>            x = landmarks.part(n).x<br/>            y = landmarks.part(n).y<br/><br/>            # Draw a circle<br/>            cv2.circle(img=frame, center=(x, y), radius=3, color=(0, 255, 0), thickness=-1)<br/><br/>    # show the image<br/>    cv2.imshow(winname="Face", mat=frame)<br/><br/>    # Exit when escape is pressed<br/>    if cv2.waitKey(delay=1) == 27:<br/>        break<br/><br/># When everything done, release the video capture and video write objects<br/>cap.release()<br/><br/># Close all windows<br/>cv2.destroyAllWindows()</span></pre><p id="60e0" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">最后的结果在这里:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/72bc61afd9307dc5a0b5e6c78604e273.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*Fcs2e9BjuaGFBSnn2uqGPg.gif"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">根据原始视频创建的 GIF，我必须剪切帧以使 GIF 具有合适的大小。</p></figure><p id="ebfa" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">即使在光线较弱的情况下，结果也相当准确，尽管上面的图像有一些误差，但光线较好的情况下效果很好。</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="78c1" class="nd ne it bd nf ng nh ni nj nk nl nm nn ki no kj np kl nq km nr ko ns kp nt nu bi translated">结论</h1><p id="1a89" class="pw-post-body-paragraph lh li it lj b lk nv kd lm ln nw kg lp lq nx ls lt lu ny lw lx ly nz ma mb mc im bi translated">OpenCV 和 DLib 是强大的库，简化了 ML 和计算机视觉的工作。今天我们只触及最基本的内容，还有很多东西要向他们学习。</p><p id="02e3" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">非常感谢你的阅读！</p></div></div>    
</body>
</html>