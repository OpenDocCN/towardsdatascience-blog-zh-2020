<html>
<head>
<title>Understanding Neural Networks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解神经网络</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/understanding-neural-networks-c5557cfef5b3?source=collection_archive---------53-----------------------#2020-05-17">https://towardsdatascience.com/understanding-neural-networks-c5557cfef5b3?source=collection_archive---------53-----------------------#2020-05-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8b32" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">对神经网络架构的深入理解</h2></div><p id="0cdc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我之前的文章中，我简要讨论了深度学习以及如何开始使用它。如果你还没有看过那篇文章，请在这里<a class="ae le" href="https://medium.com/@ayushparhi7/deep-learning-the-state-of-the-art-88153e69a602" rel="noopener">阅读</a>，对深度学习和机器学习有一个直观的认识。</p><p id="a93f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你已经看过了，那就开始吧！</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/f6c2b89afe7e36a83c368ae7b716dde4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UKalXwOhtAF-KTTc"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">由<a class="ae le" href="https://unsplash.com/@diskander?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">大卫·伊斯坎德尔</a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="7081" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">感知器</h1><p id="5f90" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">感知器？！你们中的一些人可能已经知道了。无论如何，感知器是神经网络的结构构建模块。就这么简单。通过形成层来组合许多感知机最终成为深度神经网络。感知器架构可能看起来像这样:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi ms"><img src="../Images/25db60b859153dbfd49d89c1bab1f908.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZEYyePoCAKOThGE7.jpg"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">感知器模型。来源:<a class="ae le" href="https://www.allaboutcircuits.com/uploads/articles/how-to-perform-classification-using-a-neural-network-a-simple-perceptron-example_rk_aac_image1.jpg" rel="noopener ugc nofollow" target="_blank">关于电路的一切</a></p></figure><p id="e0ef" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里，总共有两层:输入层和输出层。但是，在机器学习的世界中，开发人员不认为输入是一个层，因此他们会说，“这是一个单层感知器模型”。所以，当有人说，“我已经建立了一个5层的神经网络”，不要把输入算作一层。那么，这个感知机模型是做什么的呢？如上图所示，我们有2个输入和一个带有sigma和积分符号的单个节点，然后是输出。该节点计算两个数学表达式以给出输出。首先，它取输入加上一个偏差的加权和，然后该和通过一个<strong class="kk iu">非线性</strong>激活函数。稍后，激活函数产生预测输出。这整个过程在神经网络中称为前向传播。</p><p id="040d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请看这张图片:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi mt"><img src="../Images/005b697089974e22e02214b3e2f09370.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wz1sHBY43WBmNjTYZmPRjg.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">感知器计算。</p></figure><p id="d60d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正向传播的灵感来自逻辑回归。如果你知道逻辑回归算法，这可能看起来很熟悉，但如果你不知道逻辑回归，这是没有必要的。权重(W)和偏差(b)是由神经网络“训练”的参数，所谓“训练”是指它们被设置为精确值，使得损失最小。</p><p id="d2f7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">输出(上图中的“y”)是神经网络做出的预测。实际值和预测值之间的差异称为神经网络的损耗。但事情没那么简单。我们取预测值和实际值之间的差，而不是直接差。让我们明白我想说什么。</p><h1 id="ae96" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">损失和成本函数</h1><p id="d10e" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">在继续之前，您应该知道的一件事是，预测值计算神经网络的损失，而神经网络是通过计算“Z”来计算的，Z取决于“W”和“b”。最终，我们可以说损失取决于“W”和“b”。因此,“W”和“b”应设置为损耗最小的值。明确地说，<strong class="kk iu">神经网络总是最小化损失，而不是最大化精度</strong>。</p><p id="16d3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当解决一个深度学习问题时，数据集是巨大的。例如，假设我们要构建一个图像分类器，对猫和狗的图像进行分类(你可以将其视为“Hello World！”计算机视觉的:)。所以为了训练神经网络，我们需要尽可能多的猫和狗的图像。在机器学习中，一只狗或一只猫的形象被认为是一个<strong class="kk iu">“训练例子”</strong>。为了训练一个好的神经网络，我们需要大量的训练样本。损失函数是针对单个训练示例计算的损失。所以，实际上我们为神经网络的训练优化的是<strong class="kk iu">成本函数</strong>。成本函数可以定义为针对每个训练示例单独计算的所有损失的平均值。</p><p id="ffdf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们假设有“m”个训练例子。那么成本函数就是:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/1c822e57bc244411536029d883342053.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*gomspkQGkzXurs_YmhAGkQ.png"/></div></figure><p id="b015" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们把一个神经网络的损耗取为:<br/>损耗(比方说，L) =预测值(比方说，yhat) —实际值(比方说，y)</p><p id="7d78" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于神经网络的损失取决于“W”和“b ”,所以让我们仅针对“W”来绘制上述损失函数(为了简单起见，如果我们将“W”和“b”都考虑在内，我们必须绘制3d图，这将很难理解概念。此外，偏差“b”用于将激活函数向左或向右移动，就像公式中的截距线)<br/>图可能看起来像这样:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi mv"><img src="../Images/89c88c474755ab4f0374825f63375126.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZLXth_-qaiVBm-_JMc7Ekg.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">这将是一条直线</p></figure><p id="9f5e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个损失函数的问题是，它是一条直线，不可能使用优化算法(如梯度下降)来优化损失函数(在下一节中告诉你)。现在，要明白损失函数应该是一条具有全局最小值的曲线。</p><p id="c0d1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">后来研究人员又想出了另一个损失函数:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/49ad7c0b4a13f507673c35d9305b9e96.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/format:webp/1*9S7J89exdGmHXC1eYUAsXw.png"/></div></figure><p id="5c19" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这称为“<strong class="kk iu">均方误差损失</strong>”，用于回归类问题。此外，对于一个训练示例，这似乎是一个公平的等式。它是一条抛物线。但是对于“m”个训练示例，即，对于成本函数，将是具有许多局部最小值的波状曲线。我们想要一个碗状曲线或凸状曲线来优化成本。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi mx"><img src="../Images/815a6490b6ae593b9ea911b0420cc91f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QU-6Ft50iDA9cfSTXaapLA.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">有许多局部极小值的波状曲线</p></figure><p id="dc4f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以，后来我们得到了一个公认的损失函数方程:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi my"><img src="../Images/63210c998f26cea85e17431db5e253e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/1*Gb5-6Df6OC4-4m6Nj76Bhw.png"/></div></figure><p id="6b34" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个方程被称为“<strong class="kk iu">交叉熵损失</strong>，它被广泛用于深度学习中的分类问题。</p><p id="21fa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上述等式的成本函数如下所示:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi mz"><img src="../Images/77f4d176c26847bb312bf5d1123dbb85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6cieCB4fW9r212OuAOR-xw.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">凸形曲线。</p></figure><p id="3104" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们知道了如何计算神经网络的成本，让我们了解如何优化成本函数以获得更好的性能。</p><h1 id="d6f2" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">反向传播:训练神经网络</h1><p id="0823" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">反向传播是神经网络构建中最重要的任务。这是对神经网络进行实际训练的过程。这是一项计算量很大的任务。事实上，它是神经网络中整个计算过程的三分之二。在前向传播中，我们看到了如何计算神经网络的成本。在反向传播中，我们使用这个成本来设置“W”和“b”的值，使得它可以最小化神经网络的成本。<br/>一开始，我们将权重(W)和偏差(b)初始化为一些随机的小数字。随着模型的训练，权重和偏差会随着新值而更新。这种更新是在一种叫做<strong class="kk iu">梯度下降的优化算法的帮助下完成的。</strong></p><p id="df0e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在数学中，梯度意味着斜率或导数。下降意味着减少。所以通俗地说，梯度下降就是斜率递减。熟悉微积分有助于理解梯度下降。还记得我说过我们需要一个凸形代价函数来进行优化吗？原因是在下降过程中，我们不会陷入局部极小值。如果成本函数是波浪形的，它有机会停留在它的一个局部极小值，我们将永远不会有成本的全局最优值。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi na"><img src="../Images/6ef143ab29410558743e6bb4ec44e20e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*koeCCNT-eB4N7mjO.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">梯度下降算法的图形表示。</p></figure><p id="1919" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">梯度下降算法的上述表示可以帮助你理解它。</p><p id="d923" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在梯度下降算法中，我们分别计算计算成本相对于权重和偏差的导数。</p><p id="8dd7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们考虑一个简单的感知器模型，它有两个输入:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nb"><img src="../Images/a9ebdaac450ee279ad0f021b793a7eb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J3lT7QyR5PvypNkH7LI-Rg.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">计算权重的梯度。</p></figure><p id="1ce3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么权重被更新为:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/1da04d7ed688d2190116c97d3b8e84fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:614/format:webp/1*trYh_YZQ_sgE46W6g_4hlQ.png"/></div></figure><p id="b132" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上式中的α称为神经网络的<strong class="kk iu">学习速率</strong>。这是一个<strong class="kk iu">超参数</strong>，稍后我会告诉你更多的超参数。现在，把它当作一个常数。</p><p id="1775" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">权重和偏差将被更新，直到成本函数达到其全局最优值。这样我们得到的预测输出误差会更小。</p><p id="7da2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一次正向传播和一次反向传播一起被计为训练的1次迭代或<strong class="kk iu">时期</strong>。深度学习实践者必须在训练模型之前设置历元的数量(另一个超参数)。</p><h1 id="1f20" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">深度神经网络</h1><p id="33c5" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">到目前为止，我们一直在研究感知器模型，处理感知器模型非常容易。但是当我们深入网络时，事情就变得很糟糕了。</p><p id="4b8a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现实世界中的问题有大量的输入特征，每个输入特征都有自己的权重和偏差，根据问题，模型中有许多隐藏层，每个隐藏层都有许多计算Z和a的节点。训练过程与我之前描述的相同，但它会重复神经网络中存在的节点数。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/2fc85014b010d983426c65bf1f48983e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GcdQT-b6k6uPFss-.gif"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">深度神经网络的训练。来源:<a class="ae le" href="https://gfycat.com/activecourteousamericanindianhorse-mathematics-3b1b" rel="noopener ugc nofollow" target="_blank"> Gfycat </a></p></figure><p id="9348" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的GIF中，你可以猜到一个神经网络的复杂性和实现它的高计算要求。</p><p id="1c80" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们总结一下到目前为止我们学到的一切:<br/> 1。正向传播期间:<br/> -初始化权重和偏差。<br/> -计算每个节点的Z和A。<br/> -计算整个模型的成本。<br/> 2。反向传播期间:<br/> -使用梯度下降优化成本。<br/> -分别计算关于权重和偏差的成本梯度。<br/> -更新参数(W &amp; b) <br/> 3。重复步骤1和2，直到成本函数达到其全局最优值。</p><p id="5c33" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我希望我在整篇文章中表达清楚了，并且你很好地理解了这些概念。如果没有，欢迎在评论中提问。还有，在评论里给你宝贵的建议，我好改进我的文章。</p><p id="3fa3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">也可以建议你想学习深度学习领域的什么课题。</p><p id="907a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢大家抽出宝贵的时间阅读本文。</p></div></div>    
</body>
</html>