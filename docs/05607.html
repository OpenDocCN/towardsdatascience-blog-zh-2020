<html>
<head>
<title>How To Make Your Python Code Run Faster — 2nd Installment</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何让您的Python代码运行得更快—第2部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/did-you-know-how-to-make-your-python-code-run-faster-2nd-installment-f105516cbd8a?source=collection_archive---------49-----------------------#2020-05-10">https://towardsdatascience.com/did-you-know-how-to-make-your-python-code-run-faster-2nd-installment-f105516cbd8a?source=collection_archive---------49-----------------------#2020-05-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4266" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">高效的编程实践</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6d1721eaec85cff231dd98109dcac441.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hb6G2CqLvIYhWcrB"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Marc-Olivier Jodoin 在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="d760" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在前两个教程中，我们谈到了测量python代码执行时间的<a class="ae kv" rel="noopener" target="_blank" href="/did-you-know-you-can-measure-the-execution-time-of-python-codes-14c3b422d438"><em class="ls"/></a><em class="ls"/>和优化硬件利用率以提高代码执行速度的<a class="ae kv" rel="noopener" target="_blank" href="/did-you-know-how-to-make-your-python-code-run-faster-1st-installment-f317359159a1"><em class="ls"/></a>。在本教程中，我们将再次致力于提高我们的代码运行时间，但是，通过使用一些编程最佳实践，如:</p><ul class=""><li id="67a5" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated">记忆化</li><li id="cf74" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">…向量化…</li></ul><h1 id="6508" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">记忆化</h1><h2 id="5816" class="mz mi iq bd mj na nb dn mn nc nd dp mr lf ne nf mt lj ng nh mv ln ni nj mx nk bi translated"><strong class="ak"> a .)学校</strong> <strong class="ak">天</strong></h2><p id="4b1d" class="pw-post-body-paragraph kw kx iq ky b kz nl jr lb lc nm ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">我相信每个读这篇文章的人都会记得他们的小学时代。我们的数学老师总是记住从2到20的乘法表。想过为什么吗？很简单，这些表格构成了数学计算的基础，将它们储存在你的记忆中可以帮助你更快地计算。</p><h2 id="3e80" class="mz mi iq bd mj na nb dn mn nc nd dp mr lf ne nf mt lj ng nh mv ln ni nj mx nk bi translated"><strong class="ak"> b .)回到未来</strong></h2><p id="6ab4" class="pw-post-body-paragraph kw kx iq ky b kz nl jr lb lc nm ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">记忆难懂的概念的旧概念通过名称<strong class="ky ir">记忆化</strong>被构建到现代世界编程概念中。</p><blockquote class="nq nr ns"><p id="efbf" class="kw kx ls ky b kz la jr lb lc ld ju le nt lg lh li nu lk ll lm nv lo lp lq lr ij bi translated">引用维基百科，<strong class="ky ir">记忆化</strong>被定义为<strong class="ky ir">优化技术</strong>，主要用于通过<strong class="ky ir">存储昂贵的函数调用</strong>的结果和<strong class="ky ir">在相同的输入再次出现时返回缓存的结果</strong>来加速计算机程序。</p></blockquote><h2 id="33a4" class="mz mi iq bd mj na nb dn mn nc nd dp mr lf ne nf mt lj ng nh mv ln ni nj mx nk bi translated"><strong class="ak"> c .)用Python实现</strong></h2><p id="06dd" class="pw-post-body-paragraph kw kx iq ky b kz nl jr lb lc nm ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">为了用Python演示这个概念，让我们首先定义一个<strong class="ky ir">昂贵的函数</strong>。为了仿真一个昂贵的函数，这在计算上很耗时，我们将从时间包中调用<strong class="ky ir">睡眠函数，并人为增加函数<strong class="ky ir">的运行时间。</strong></strong></p><p id="2c78" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是创建该函数的Python代码。这个函数使用一个数值参数作为输入，休眠5秒钟，然后返回数值的平方作为输出。</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="1790" class="mz mi iq nx b gy ob oc l od oe"><strong class="nx ir">USUAL APPROACH TO DEFINE A FUNCTION</strong></span><span id="881a" class="mz mi iq nx b gy of oc l od oe"><strong class="nx ir">#### Import time package</strong><br/>import time</span><span id="d980" class="mz mi iq nx b gy of oc l od oe"><strong class="nx ir">#### Defining expensive function - The Usual Way</strong><br/>def expensive_function(n):<br/>    time.sleep(5)<br/>    return n**2</span></pre><h2 id="8e95" class="mz mi iq bd mj na nb dn mn nc nd dp mr lf ne nf mt lj ng nh mv ln ni nj mx nk bi translated"><strong class="ak"> d .)用常用方法运行时间</strong></h2><p id="6aef" class="pw-post-body-paragraph kw kx iq ky b kz nl jr lb lc nm ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">使用上面使用的方法，每次我们调用函数时，<strong class="ky ir">函数将首先休眠5秒钟</strong>，然后返回实际结果。让我们通过连续调用<strong class="ky ir"> 3次</strong>来对这个函数进行时间分析。</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="c095" class="mz mi iq nx b gy ob oc l od oe"><strong class="nx ir">### Calling the expensive function 3 times and timing </strong><br/>%%timeit -n1 -r1<br/>expensive_function(9)<br/>expensive_function(9)<br/>expensive_function(9)</span><span id="7644" class="mz mi iq nx b gy of oc l od oe"><strong class="nx ir">### Time profile output<br/></strong>15 s ± 0 ns per loop (mean ± std. dev. of 1 run, 1 loop each)</span></pre><p id="60f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设，我们调用了该函数3次，记录的总执行时间为<strong class="ky ir"> 15秒</strong>。</p><h2 id="25f4" class="mz mi iq bd mj na nb dn mn nc nd dp mr lf ne nf mt lj ng nh mv ln ni nj mx nk bi translated">e.)使用<strong class="ak">记忆</strong>减少运行时间</h2><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="748c" class="mz mi iq nx b gy ob oc l od oe"><strong class="nx ir">MEMOIZATION APPROACH TO DEFINE FUNCTIONS<br/>### Importing package<br/></strong>import time</span><span id="95e3" class="mz mi iq nx b gy of oc l od oe"><strong class="nx ir">### Re-defining the expensive function<br/></strong>def expensive_function(n):<br/>    <strong class="nx ir">argument_dict </strong>= {}<br/>    if n in argument_dict:<br/>        return argument_dict[n]<br/>    else:<br/>        argument_dict[n] = n**2<br/>        time.sleep(5)<br/>        return n**2</span><span id="58eb" class="mz mi iq nx b gy of oc l od oe"><strong class="nx ir">### Testing the run time<br/></strong>%%timeit -n1 -r1<br/>expensive_function(9)<br/>expensive_function(9)<br/>expensive_function(9)</span><span id="3176" class="mz mi iq nx b gy of oc l od oe"><strong class="nx ir">### Time Profile output</strong><br/>5.01 s ± 0 ns per loop (mean ± std. dev. of 1 run, 1 loop each)</span></pre><p id="4b4b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">解释</strong></p><ul class=""><li id="7a05" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated">由于<strong class="ky ir">记忆化</strong>提倡存储昂贵函数的结果，我们使用Python的字典来完成这项工作。注意字典"<strong class="ky ir"> argument_dict </strong>"的定义</li><li id="84de" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">函数定义略有变化。现在，在休眠5秒钟并返回结果之前，该函数检查与传递的参数相关联的结果是否已经存在于字典中</li><li id="4e2a" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">只有在内存(本例中为字典)中没有与传递的参数相关的结果时，才会调用sleep函数</li><li id="43d6" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">查看测试结果，可以注意到测试代码<strong class="ky ir">的执行时间(5.01秒)比过去的执行时间(15秒)减少了三分之一</strong></li></ul><h1 id="ea2a" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">…向量化…</h1><p id="3d8c" class="pw-post-body-paragraph kw kx iq ky b kz nl jr lb lc nm ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">每当我们想到在代码中实现迭代操作时，我们想到的第一个编程结构就是<strong class="ky ir">循环</strong>。当处理较小的数据集时，循环可以做得很好，但是随着数据集大小的增加，性能会下降。编程思维的一个小小的改变可以帮助我们克服这个挑战。</p><p id="d032" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑一个场景，我们需要对包含<strong class="ky ir">一百万行</strong>的<strong class="ky ir"> Pandas数据帧</strong>的一列执行一些操作。如果以传统方式处理，将会一个接一个地循环一百万条记录。</p><p id="8357" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">另一方面，</strong>建议对整个列只执行一次该操作(而不是逐个记录)。这样，你就避免了执行一百万次同样的操作。下面的例子展示了我们如何从一些常见的编程场景中消除循环:</p><h2 id="8522" class="mz mi iq bd mj na nb dn mn nc nd dp mr lf ne nf mt lj ng nh mv ln ni nj mx nk bi translated"><strong class="ak"> a)简单的数学运算</strong></h2><p id="2b9d" class="pw-post-body-paragraph kw kx iq ky b kz nl jr lb lc nm ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">让我们考虑一个简单的场景，其中我们有一个包含100k直角三角形的<strong class="ky ir">底边</strong>和<strong class="ky ir">垂直长度</strong>的熊猫数据帧，任务是计算它们的<strong class="ky ir">斜边</strong>。计算公式如下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/c39167b3002098512c6dfe12c8b5eb79.png" data-original-src="https://miro.medium.com/v2/resize:fit:360/format:webp/1*Z-gw0fe_7fCPHNATsfANQA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://miniwebtool.com/hypotenuse-calculator/" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="2dc3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们使用pandas <strong class="ky ir"> apply方法</strong>(一个函数在一个系列对象上的迭代应用)来捕获执行该操作时的运行时间:</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="b2d6" class="mz mi iq nx b gy ob oc l od oe"><strong class="nx ir">#### Importing libraries<br/></strong>import pandas as pd<br/>import random</span><span id="c8aa" class="mz mi iq nx b gy of oc l od oe"><strong class="nx ir">#### Creating Pandas with random values of base and perpendicular<br/></strong>base = [random.randint(1,100) for _ in range(100000)]<br/>perpend = [random.randint(1,100) for _ in range(100000)]<br/>triangle = pd.DataFrame(list(zip(base, perpend)),columns=["Base", "Perpendicular"])</span><span id="7dd4" class="mz mi iq nx b gy of oc l od oe"><strong class="nx ir">#### Calculating hypotenuse<br/></strong>%%timeit<br/>triangle["Hypotenuse"] = triangle.apply(lambda row: (row["Base"]**2 + row["Perpendicular"]**2) **(1/2), axis=1)</span><span id="5d17" class="mz mi iq nx b gy of oc l od oe"><strong class="nx ir">#### Performance<br/></strong>3.43 s ± 52.9 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</span></pre><p id="0fe5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用apply(熊猫循环最有效的形式之一)循环100k行花费了我们大约<strong class="ky ir"> 3.43秒</strong>。让我们看看<strong class="ky ir">矢量化如何帮助</strong>我们提高这段代码的性能。</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="3a0c" class="mz mi iq nx b gy ob oc l od oe"><strong class="nx ir">#### Importing libraries<br/></strong>import pandas as pd<br/>import random</span><span id="e99f" class="mz mi iq nx b gy of oc l od oe"><strong class="nx ir">#### Creating Pandas with random values of base and perpendicular<br/></strong>base = [random.randint(1,100) for _ in range(100000)]<br/>perpend = [random.randint(1,100) for _ in range(100000)]<br/>triangle = pd.DataFrame(list(zip(base, perpend)),columns=["Base", "Perpendicular"])</span><span id="bc70" class="mz mi iq nx b gy of oc l od oe"><strong class="nx ir">#### Calculating hypotenuse </strong><br/>%%timeit<br/>triangle["Hypotenuse"] = <strong class="nx ir">(triangle["Base"]**2 + triangle["Perpendicular"]**2) **(1/2)</strong></span><span id="0edf" class="mz mi iq nx b gy of oc l od oe"><strong class="nx ir">#### Performance<br/></strong>5.81 ms ± 274 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)</span></pre><p id="9dd7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">解释</strong></p><ul class=""><li id="06b9" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated">循环，在这个版本的代码中被删除了</li><li id="9594" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">合并了对完整pandas系列对象(基本和垂直)操作的单个代码语句<strong class="ky ir">(以粗体突出显示)</strong></li><li id="89ab" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">与之前的3.42秒相比，整个操作在<strong class="ky ir"> 5.81毫秒内完成。这种改善难道不是实质性的吗？</strong></li></ul><h2 id="b0cc" class="mz mi iq bd mj na nb dn mn nc nd dp mr lf ne nf mt lj ng nh mv ln ni nj mx nk bi translated"><strong class="ak"> b)涉及条件的操作</strong></h2><p id="e7d0" class="pw-post-body-paragraph kw kx iq ky b kz nl jr lb lc nm ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">矢量化可以派上用场的另一个常见场景是，当循环被有条件地执行时。为了证明这一点，我们创建了一些虚拟数据，其中包含2019年我们家每小时的电力消耗信息(365*24条记录)。鉴于<strong class="ky ir">费用在一天的不同时间</strong>是不同的，我们想计算<strong class="ky ir">每小时</strong>的电费。费用表如下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/8c8a08aa990a069c0eededc174404856.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*D_P-Dd6p01w7M_zBIyqoNQ.png"/></div></figure><p id="d860" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">编写简单循环时的性能评估:</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="edee" class="mz mi iq nx b gy ob oc l od oe"><strong class="nx ir">#### Importing libraries<br/></strong>import pandas as pd</span><span id="ab05" class="mz mi iq nx b gy of oc l od oe"><strong class="nx ir">#### Importing Dataframe<br/></strong>df = pd.read_csv("/home/isud/DidYouKnow/Tutorial 4/electricity.csv")</span><span id="fc0b" class="mz mi iq nx b gy of oc l od oe"><strong class="nx ir">#### Calculating Hourly Electricity Cost<br/></strong>%%timeit<br/>df["cost"] = df[["Hour","Usage"]].apply(lambda x: x["Usage"]*5 if x["Hour"]&lt;7 else (x["Usage"]*10 if x["Hour"] &lt;19 else x["Usage"]*15),axis = 1)</span><span id="17b4" class="mz mi iq nx b gy of oc l od oe"><strong class="nx ir">#### Performance<br/></strong>417 ms ± 19.8 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</span></pre><p id="b583" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用熊猫最有效的循环方法(应用方法)，我们可以在<strong class="ky ir"> 417毫秒</strong>内完成我们的目标。让我们评估使用<strong class="ky ir">矢量化</strong>执行相同操作时的性能:</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="4df3" class="mz mi iq nx b gy ob oc l od oe"><strong class="nx ir">#### Importing libraries<br/></strong>import pandas as pd</span><span id="4849" class="mz mi iq nx b gy of oc l od oe"><strong class="nx ir">#### Importing Dataframe<br/></strong>df = pd.read_csv("/home/isud/DidYouKnow/Tutorial 4/electricity.csv")</span><span id="93aa" class="mz mi iq nx b gy of oc l od oe"><strong class="nx ir">#### Calculating Hourly Electricity Cost<br/></strong>%%timeit<br/><strong class="nx ir">less_seven = df["Hour"].isin(range(1,7))<br/>less_nineteen = df["Hour"].isin(range(7,19))<br/>rest = df["Hour"].isin(range(19,24))<br/></strong>df.loc[less_seven, "Cost"] = df.loc[less_seven, "Usage"] * 5 <br/>df.loc[less_nineteen, "Cost"] = df.loc[less_nineteen, "Usage"] * 10 <br/>df.loc[rest, "Cost"] = df.loc[rest, "Usage"] * 15</span><span id="a2c1" class="mz mi iq nx b gy of oc l od oe"><strong class="nx ir">#### Performance<br/></strong>7.68 ms ± 47 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)</span></pre><p id="8d21" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">解释</strong></p><ul class=""><li id="9c96" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated">我们没有遍历每一行，而是为一天中不同的时间创建了逻辑向量，即<strong class="ky ir"> less_seven </strong>、<strong class="ky ir">less _ 19</strong>和<strong class="ky ir"> rest </strong></li><li id="6e3b" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">然后，这些逻辑向量用于成本构成的一次性(矢量化)计算。</li><li id="4bb9" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">使用上述方法，我们可以将代码运行时间从<strong class="ky ir">的417毫秒减少到</strong>的7.68毫秒。</li></ul><h1 id="5f8f" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">结束语</h1><p id="b529" class="pw-post-body-paragraph kw kx iq ky b kz nl jr lb lc nm ju le lf nn lh li lj no ll lm ln np lp lq lr ij bi translated">在过去的2个教程中，我们已经尝试用编写高效代码的方法来武装你。尝试这些方法，让我们知道它们是否有帮助。</p><p id="615a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">会在以后的教程中尝试并带来更多有趣的话题。在此之前:</p><p id="a515" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">快乐学习！！！！</p></div></div>    
</body>
</html>