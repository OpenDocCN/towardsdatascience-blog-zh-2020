<html>
<head>
<title>Supercharging Hyperparameter Tuning with Dask</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用 Dask 调整增压超参数</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/supercharging-hyperparameter-tuning-with-dask-ab2c28788bcf?source=collection_archive---------50-----------------------#2020-07-20">https://towardsdatascience.com/supercharging-hyperparameter-tuning-with-dask-ab2c28788bcf?source=collection_archive---------50-----------------------#2020-07-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="cdaf" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Dask 将 scikit-learn 参数搜索速度提高了 16 倍以上，Spark 提高了 4 倍以上</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c57abf2541c93d3c4ff09e9004fde2da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RgUBTvYFe1bbAY1Q"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@spencerdavis?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">斯潘塞·戴维斯</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kw"><img src="../Images/1455a4a2a8351217f3199ad62982b178.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3mZ9LjyqUU5YlHk-OMDq5A.png"/></div></div></figure><p id="101c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">声明:我是<a class="ae kv" href="https://www.saturncloud.io/" rel="noopener ugc nofollow" target="_blank">土星云</a>的高级数据科学家——我们用 Python 和 Dask 让企业数据科学变得快速而简单。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><p id="6f68" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">超参数调整是构建机器学习模型的一个关键部分，通常也是痛苦的部分。从你的模型中挤出每一点性能可能意味着数百万美元广告收入的差异，或者医疗保健模型中患者的生死。即使你的模型需要一分钟来训练，你也可能要等几个小时来完成网格搜索(想想 10x10 的网格，交叉验证，等等。).每次你等待一个搜索完成都会打破一个迭代周期，并且增加你的模型产生价值的时间。简而言之:</p><ul class=""><li id="190d" class="ma mb iq kz b la lb ld le lg mc lk md lo me ls mf mg mh mi bi translated">更快的运行时间意味着更多的迭代，以在截止日期之前提高准确性</li><li id="fa73" class="ma mb iq kz b la mj ld mk lg ml lk mm lo mn ls mf mg mh mi bi translated">更快的运行时间意味着更快的交付，因此您可以处理另一个项目</li><li id="76ea" class="ma mb iq kz b la mj ld mk lg ml lk mm lo mn ls mf mg mh mi bi translated">这两个要点都意味着将价值提升到您组织的底线</li></ul><p id="b5c7" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在这篇文章中，我们将看到如何通过在 Saturn Cloud  上用 Dask 代码 <a class="ae kv" href="https://saturncloud.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kz ir">替换 scikit-learn 管道中的几行代码，将超参数搜索的速度提高超过<strong class="kz ir">16 倍。这使得传统的通宵参数搜索变成了几秒钟的等待。我们还尝试用 Apache Spark 进行类似的网格搜索，这需要更多的代码修改，但仍然比 Dask 慢得多。</strong></strong></a></p><h1 id="f18b" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">一、Dask 是什么？</h1><p id="d88a" class="pw-post-body-paragraph kx ky iq kz b la ng jr lc ld nh ju lf lg ni li lj lk nj lm ln lo nk lq lr ls ij bi translated"><a class="ae kv" href="https://dask.org/" rel="noopener ugc nofollow" target="_blank"> Dask </a>是一个灵活、健壮的并行计算框架，内置于 Python 中，并为 Python 服务。它可以处理常见的数据结构，比如数组和数据帧，但是也可以用来并行处理那些不适合的复杂操作。事实上，并行数组和数据帧实际上是熟悉的<code class="fe nl nm nn no b">numpy</code>和<code class="fe nl nm nn no b">pandas</code>对象的集合，并且具有匹配的 API。通过这种方式，数据科学家不需要学习全新的框架，就可以在大数据上执行他们的代码。</p><h1 id="1dab" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">实验设置</h1><p id="6016" class="pw-post-body-paragraph kx ky iq kz b la ng jr lc ld nh ju lf lg ni li lj lk nj lm ln lo nk lq lr ls ij bi translated">我们将使用公开可用的<a class="ae kv" href="https://www1.nyc.gov/site/tlc/about/tlc-trip-record-data.page" rel="noopener ugc nofollow" target="_blank">纽约出租车数据集</a>并训练一个线性回归模型，该模型可以<a class="ae kv" href="https://www.kaggle.com/c/new-york-city-taxi-fare-prediction" rel="noopener ugc nofollow" target="_blank">使用与乘客接送相关的属性来预测出租车乘坐的费用金额</a>。</p><p id="159c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们将首先使用单节点 Python 包(<code class="fe nl nm nn no b">pandas</code>和<code class="fe nl nm nn no b">scikit-learn</code>)完成数据加载和网格搜索，然后强调使用 Dask 或 Spark 并行化网格搜索需要做哪些更改。所有三个工作负载使用相同的数据执行相同的网格搜索，我们在整篇文章中将它们称为<strong class="kz ir">单节点</strong>(对于单节点 Python)、<strong class="kz ir"> Dask </strong>(对于 Dask 集群)和<strong class="kz ir"> Spark </strong>(对于 Spark 集群)。</p><h1 id="4575" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">五金器具</h1><p id="56d9" class="pw-post-body-paragraph kx ky iq kz b la ng jr lc ld nh ju lf lg ni li lj lk nj lm ln lo nk lq lr ls ij bi translated">对于所有任务，我们都使用 AWS 的 r 5.2x 大型实例(8 个内核，64GB RAM)。对于 Python，我们只使用一个节点，对于 Spark 和 Dask，我们在具有不同数量工作节点的集群上运行工作负载，以跟踪运行时(3、10 和 20)。</p><p id="4222" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">Spark 集群使用亚马逊 EMR 管理，而 Dask 集群使用<a class="ae kv" href="https://www.saturncloud.io/" rel="noopener ugc nofollow" target="_blank">土星云</a>管理。</p><h1 id="7ab2" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">给我看看结果吧！</h1><p id="c6fe" class="pw-post-body-paragraph kx ky iq kz b la ng jr lc ld nh ju lf lg ni li lj lk nj lm ln lo nk lq lr ls ij bi translated">如果您想跳过代码并查看性能改进，请跳到<a class="ae kv" href="#abed" rel="noopener ugc nofollow">结果</a>部分。</p><h1 id="fa47" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">单节点工作流</h1><p id="843d" class="pw-post-body-paragraph kx ky iq kz b la ng jr lc ld nh ju lf lg ni li lj lk nj lm ln lo nk lq lr ls ij bi translated">首先，加载数据！我们随机抽取数据进行基准测试。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="5e49" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">然后，创建一些特征:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="e378" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们正在使用一个 scikit-learn <a class="ae kv" href="https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.ElasticNet.html" rel="noopener ugc nofollow" target="_blank">弹性网</a>模型，它可以基于<code class="fe nl nm nn no b">l1_ratio</code>参数执行 L1、L2 和弹性网正则化。我们还将尝试几个<code class="fe nl nm nn no b">alpha</code>的值，创建一个包含 404 个商品和三重交叉验证的网格，从而得到 1212 个适合搜索的模型。</p><p id="45c5" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">当我们训练一个线性模型时，我们需要一次性编码分类特征并缩放数字特征。注意定义<code class="fe nl nm nn no b">GridSearchCV</code>时的<code class="fe nl nm nn no b">n_jobs=-1</code>参数指示 scikit-learn 在机器中的所有内核上并行化模型训练(这还没有使用 Dask，因为单节点并行化是 scikit-learn 自带的)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="3b87" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">最后，我们可以运行网格搜索并检索最佳分数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="627d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果你在和我们一样大小的机器上运行这个，大约需要 3 个小时。</p><h1 id="9db4" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">顺便来看看</h1><p id="9964" class="pw-post-body-paragraph kx ky iq kz b la ng jr lc ld nh ju lf lg ni li lj lk nj lm ln lo nk lq lr ls ij bi translated">Dask 在单节点上运行良好，并且可以扩展到具有数千个节点的集群。要开始使用 Dask，我们需要<a class="ae kv" href="https://docs.dask.org/en/latest/setup.html" rel="noopener ugc nofollow" target="_blank">初始化一个客户端</a>，在这种情况下，我们将<a class="ae kv" href="https://www.saturncloud.io/docs/getting-started/spinning/dask/" rel="noopener ugc nofollow" target="_blank">使用 Saturn Cloud 的<code class="fe nl nm nn no b">SaturnCluster</code>设置我们的集群</a>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="eb60" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在读取数据时，我们需要做的唯一改变是使用<code class="fe nl nm nn no b">dask.dataframe</code>包，而不是<code class="fe nl nm nn no b">pandas</code>。<em class="nr">所有特征工程代码保持完全相同</em>，因为 Dask 数据帧实现了 pandas API。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="38f4" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">然后创建我们的管道和网格搜索:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="b19b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">注意 Dask 有几个不同的预处理和<code class="fe nl nm nn no b">GridSearchCV</code>类，用于加速预处理和避免网格搜索过程中不必要的重新计算。pipeline 和 estimator ( <code class="fe nl nm nn no b">ElasticNet</code>)类直接来自 scikit-learn。</p><p id="1fa4" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们可以像使用单节点 scikit-learn 一样使用网格搜索:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="1916" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">使用 20 个节点运行这个网格搜索的运行时间为<strong class="kz ir">11</strong>14】分钟！只需更改大约 10 行代码，性能就提高了 16 倍。让我夸张地再说一遍。</p><blockquote class="ns nt nu"><p id="114c" class="kx ky nr kz b la lb jr lc ld le ju lf nv lh li lj nw ll lm ln nx lp lq lr ls ij bi translated"><em class="iq">改 10 行代码 16 倍提升！</em></p></blockquote><h1 id="4eda" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">火花</h1><p id="a3d8" class="pw-post-body-paragraph kx ky iq kz b la ng jr lc ld nh ju lf lg ni li lj lk nj lm ln lo nk lq lr ls ij bi translated"><a class="ae kv" href="https://spark.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache Spark </a>是 Scala 内置的大数据处理引擎，带有一个 Python 接口，向下调用 Scala/JVM 代码。它是 Hadoop 处理生态系统中的一个主要部分，围绕 MapReduce 范式构建，具有数据帧接口以及机器学习。</p><p id="b089" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">为了使用 Spark 运行我们的工作负载，我们需要重构我们的 Python 代码，以使用 Spark 的 DataFrame 以及 Spark ML 管道、预处理和模型类。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="2cd1" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">特征工程看起来与熊猫略有不同:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="8ab1" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">然后，我们设置我们的预处理管道和网格搜索。Spark ML 希望所有的特性都在一个向量列中，所以我们使用<code class="fe nl nm nn no b">VectorAssembler</code>来收集所有处理过的列。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="fef0" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">然后，我们运行网格搜索，得到最佳结果:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="0f4c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在 20 个节点的集群上，这大约需要 47 分钟。</p><p id="2463" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">下面是一个并列的网格搜索代码，让您感受一下 Dask 在这个例子中有多简单:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/989a2177ac59e4611e1b3623c3ce72c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*nz_G8BZ8k31TuaAA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">代码量:Dask(左)和 Spark(右)</p></figure><h1 id="abed" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">结果</h1><p id="5fe4" class="pw-post-body-paragraph kx ky iq kz b la ng jr lc ld nh ju lf lg ni li lj lk nj lm ln lo nk lq lr ls ij bi translated">我们用 404 个配置和 3 倍交叉验证进行了超参数搜索，使用弹性网络模型从纽约出租车数据集预测出租车出行持续时间。我们从单节点 Python 实现开始，并使用 Dask 和 Spark 将其转移到集群。从下表中我们可以看到，Dask 搜索比单节点和 Spark 集群版本快得多，同时只需要最少的代码更改。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="ffd2" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们在不同规模的集群上运行了 Dask 和 Spark 工作负载，以了解更大的集群如何缩短参数搜索时间:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kw"><img src="../Images/1455a4a2a8351217f3199ad62982b178.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3mZ9LjyqUU5YlHk-OMDq5A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">与 Spark 和 Dask 集群相比的单节点 scikit-learn</p></figure><h1 id="21b8" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">为什么 Dask 这么快？</h1><p id="3c0d" class="pw-post-body-paragraph kx ky iq kz b la ng jr lc ld nh ju lf lg ni li lj lk nj lm ln lo nk lq lr ls ij bi translated">Dask 跨集群中的节点和核心并行化模型拟合，因此当向群集中添加更多机器时，您可以预期近似线性的加速。并行化工作会带来一些开销，这就是为什么我们通过添加 19 台机器获得了 16 倍的性能提升。</p><p id="7ebe" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在这个例子中，Spark 的速度要慢得多，因为 Spark 网格搜索实现并没有并行化网格，它只是并行化模型拟合。这变成了连续的网格搜索，每个 fit 中的部分在集群中并行化。有一个项目<a class="ae kv" href="https://github.com/joblib/joblib-spark" rel="noopener ugc nofollow" target="_blank"> joblibspark </a>正在积极开发中，该项目旨在 spark 集群上并行化 scikit-learn 管道。在撰写本文时，我们无法成功运行 joblibspark。</p><p id="62dc" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">所有代码都可以在<a class="ae kv" href="https://github.com/saturncloud/saturn-cloud-examples/tree/main/machine_learning/hyperparameter_tuning" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p><h1 id="5576" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">您需要更快的超参数搜索吗？</h1><p id="4645" class="pw-post-body-paragraph kx ky iq kz b la ng jr lc ld nh ju lf lg ni li lj lk nj lm ln lo nk lq lr ls ij bi translated">是啊！你可以用<a class="ae kv" href="https://www.saturncloud.io/" rel="noopener ugc nofollow" target="_blank">土星云</a>在几秒钟内启动 Dask 集群。Saturn 处理所有工具基础设施、安全性和部署方面的问题，让您立即开始使用 Dask。点击<a class="ae kv" href="https://manager.aws.saturnenterprise.io/register" rel="noopener ugc nofollow" target="_blank">在你的 AWS 账户中免费试用土星</a>！</p></div></div>    
</body>
</html>