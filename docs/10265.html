<html>
<head>
<title>Generalized Mixture Transition Distribution Model</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">广义混合转移分布模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/mixture-transition-distribution-model-e48b106e9560?source=collection_archive---------52-----------------------#2020-07-19">https://towardsdatascience.com/mixture-transition-distribution-model-e48b106e9560?source=collection_archive---------52-----------------------#2020-07-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="83ae" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">介绍 MTDg 模型和用于训练它们的 Python 包</h2></div></div><div class="ab cl kf kg hu kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="ij ik il im in"><p id="a776" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">本文旨在概述广义混合转移分布(MTDg)模型的概念，并介绍我开发的<code class="fe li lj lk ll b">mtd-learn</code> Python 包。你可以在这里找到对模型<a class="ae lm" href="https://github.com/PiotrekGa/mtd-learn/blob/master/post/2020-07-06-Mixture-Transition-Distribution.md" rel="noopener ugc nofollow" target="_blank">的更广泛的介绍(在这篇文章中没有完整介绍，因为 Medium 不支持数学符号)，在这里</a>找到包存储库<a class="ae lm" href="https://github.com/PiotrekGa/mtd-learn" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl kf kg hu kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="ij ik il im in"><h1 id="8cf1" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">广义混合转移分布模型</h1><p id="93f8" class="pw-post-body-paragraph km kn iq ko b kp mf jr kr ks mg ju ku kv mh kx ky kz mi lb lc ld mj lf lg lh ij bi translated">广义混合转移分布(MTDg)模型是由 Raftery 于 1985 年提出的[1]。它最初的目的是近似高阶马尔可夫链(MC)，但它也可以作为一个独立的模型。MTDg 模型的主要优点是，与马尔可夫链模型的指数增长相比，其独立参数的数量随阶数线性增长。</p><h2 id="58f1" class="mk lo iq bd lp ml mm dn lt mn mo dp lx kv mp mq lz kz mr ms mb ld mt mu md mv bi translated">定义</h2><p id="c180" class="pw-post-body-paragraph km kn iq ko b kp mf jr kr ks mg ju ku kv mh kx ky kz mi lb lc ld mj lf lg lh ij bi translated">MTDg 模型是一系列随机变量<em class="mw"> (Xn) </em>，使得:</p><figure class="my mz na nb gt nc gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/67f590e5929a51b11ff498579ab95a1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:726/0*yJIQfOeFU494n5Tk"/></div></figure><p id="90d2" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">其中<em class="mw"> it…i0 ∈ N </em>，<em class="mw">λ</em>是权重向量，<em class="mw"> Q(g) </em>是表示第 g 个<em class="mw"> </em>滞后和当前状态之间的关联的<em class="mw"> m ⨯ m </em>矩阵。</p><p id="678c" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">模型要产生概率，必须满足以下条件:</p><figure class="my mz na nb gt nc gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/8cebffb0dcf4e92439d14d6adebbb6e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:122/0*igNaYksSqdNrFQds"/></div></figure><figure class="my mz na nb gt nc gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/bdcf135bb3458563c7e35f82def8df87.png" data-original-src="https://miro.medium.com/v2/resize:fit:288/0*K9kCy38zH7RnNCdV"/></div></figure><p id="6509" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">MTDg 模型的对数似然函数由下式给出:</p><figure class="my mz na nb gt nc gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/7456ed97bbb6ca979a60eb21a1aff5e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:542/0*Bve1ZDnGFj2_EUFj"/></div></figure><p id="9863" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">其中<em class="mw"> n </em>表示数据集中的转换数量。</p><h2 id="4b48" class="mk lo iq bd lp ml mm dn lt mn mo dp lx kv mp mq lz kz mr ms mb ld mt mu md mv bi translated">MTDg 模型直觉</h2><p id="5f9b" class="pw-post-body-paragraph km kn iq ko b kp mf jr kr ks mg ju ku kv mh kx ky kz mi lb lc ld mj lf lg lh ij bi translated">您可以将 MTDg 模型视为后续滞后的转移概率的加权平均值。以下示例显示了如何根据订单 3 MTDg 模型计算转移 B-&gt;C-&gt;A-&gt;B 的概率:</p><figure class="my mz na nb gt nc gh gi paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gh gi ni"><img src="../Images/cdb2d9d176787e2456efb0ac2bee0350.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HnPZ7BaKXffDuB9t"/></div></div><p class="nn no gj gh gi np nq bd b be z dk translated"><em class="nr">作者图片</em></p></figure><h2 id="3f4c" class="mk lo iq bd lp ml mm dn lt mn mo dp lx kv mp mq lz kz mr ms mb ld mt mu md mv bi translated">独立参数的数量</h2><p id="b3e7" class="pw-post-body-paragraph km kn iq ko b kp mf jr kr ks mg ju ku kv mh kx ky kz mi lb lc ld mj lf lg lh ij bi translated">根据[1]，MTDg 模型的独立参数个数等于<em class="mw"> lm(m-1) + l — 1 </em>。在[2]中，Lebre 和 Bourguignon 证明了独立参数的真实个数等于<em class="mw"> (ml — m + 1)(l — 1) </em>。由于<code class="fe li lj lk ll b">mtd-learn</code>包使用了在【2】中提出的估算方法，参数的数量是用最新的公式计算的。</p><p id="716f" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">对于马尔可夫链，参数个数等于<em class="mw"> mˡ(m-1) </em>。您可以在下面找到参数数量的比较:</p><figure class="my mz na nb gt nc gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/710d4ba789c3e5f2c4ceb568b2ff592a.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/1*4axehjgBSG4g_h-zHkNSrQ.png"/></div><p class="nn no gj gh gi np nq bd b be z dk translated"><em class="nr">作者图片</em></p></figure></div><div class="ab cl kf kg hu kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="ij ik il im in"><h1 id="9c7f" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">用法示例</h1><p id="7aac" class="pw-post-body-paragraph km kn iq ko b kp mf jr kr ks mg ju ku kv mh kx ky kz mi lb lc ld mj lf lg lh ij bi translated">让我们分析 1999 年 1 月 5 日至 2020 年 4 月 10 日期间美元和欧元汇率的变化模式。你可以在这里找到数据集<a class="ae lm" href="https://github.com/PiotrekGa/mtd-learn/blob/master/examples/euro_usd.csv" rel="noopener ugc nofollow" target="_blank">。由于 MTDg 模型在离散状态下工作，因此变化分为四组:</a></p><ol class=""><li id="4225" class="nt nu iq ko b kp kq ks kt kv nv kz nw ld nx lh ny nz oa ob bi translated">0 _ BIG _ DROP 超过 0.5%的下降</li><li id="9f1e" class="nt nu iq ko b kp oc ks od kv oe kz of ld og lh ny nz oa ob bi translated">1 _ 下降—低于 0.5%的下降</li><li id="d91d" class="nt nu iq ko b kp oc ks od kv oe kz of ld og lh ny nz oa ob bi translated">2 _ 上升—不到 0.5%的上升</li><li id="b53e" class="nt nu iq ko b kp oc ks od kv oe kz of ld og lh ny nz oa ob bi translated">3 _ 大幅上涨—涨幅超过 0.5%</li></ol><p id="dc7d" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">先说进口:</p><pre class="my mz na nb gt oh ll oi oj aw ok bi"><span id="17a9" class="mk lo iq ll b gy ol om l on oo">import pandas as pd<br/>import numpy as np</span><span id="7aba" class="mk lo iq ll b gy op om l on oo">from mtdlearn.mtd import MTD<br/>from mtdlearn.preprocessing import PathEncoder, SequenceCutter</span></pre><p id="b274" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">然后是分组代码:</p><pre class="my mz na nb gt oh ll oi oj aw ok bi"><span id="3df5" class="mk lo iq ll b gy ol om l on oo">df = pd.read_csv('euro_usd.csv')<br/>df['Change'] = df.Closing_rate.diff()<br/>df['Change_enc'] = np.nan<br/>df.loc[df.Change &lt; 0.0, 'Change_enc'] = '1_DROP'<br/>df.loc[df.Change &lt; -0.005, 'Change_enc'] = '0_BIG_DROP'<br/>df.loc[df.Change &gt;= 0, 'Change_enc'] = '2_RISE'<br/>df.loc[df.Change &gt;= 0.005, 'Change_enc'] = '3_BIG_RISE'<br/>df.dropna(inplace=True)</span><span id="6e2f" class="mk lo iq ll b gy op om l on oo">df.Change_enc</span><span id="825e" class="mk lo iq ll b gy op om l on oo">1       0_BIG_DROP<br/>2       0_BIG_DROP<br/>3       3_BIG_RISE<br/>4       0_BIG_DROP<br/>5       0_BIG_DROP<br/>           ...    <br/>5516        1_DROP<br/>5517    3_BIG_RISE<br/>5518        1_DROP<br/>5519    3_BIG_RISE<br/>5520        2_RISE</span></pre><p id="5505" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">现在我们需要将<code class="fe li lj lk ll b">pd.Series</code>转换成一种更加<code class="fe li lj lk ll b">mtd-learn</code>友好的格式。你可以使用<code class="fe li lj lk ll b">SequenceCutter</code>类来做这件事。我们从<code class="fe li lj lk ll b">order=2</code>开始。</p><pre class="my mz na nb gt oh ll oi oj aw ok bi"><span id="6bfc" class="mk lo iq ll b gy ol om l on oo">order = 2</span><span id="90be" class="mk lo iq ll b gy op om l on oo">sc = SequenceCutter(order)<br/>x, y = sc.transform(df.Change_enc.values)</span><span id="4e8a" class="mk lo iq ll b gy op om l on oo">x<br/>array([['0_BIG_DROP&gt;0_BIG_DROP'],<br/>       ['0_BIG_DROP&gt;3_BIG_RISE'],<br/>       ['3_BIG_RISE&gt;0_BIG_DROP'],<br/>       ...,<br/>       ['1_DROP&gt;3_BIG_RISE'],<br/>       ['3_BIG_RISE&gt;1_DROP'],<br/>       ['1_DROP&gt;3_BIG_RISE']], dtype='&lt;U21')</span><span id="88e5" class="mk lo iq ll b gy op om l on oo">y<br/>array(['3_BIG_RISE', '0_BIG_DROP', '0_BIG_DROP', ..., '1_DROP',<br/>       '3_BIG_RISE', '2_RISE'], dtype=object)</span></pre><p id="3af6" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">我们可以看到每个状态(在向量<code class="fe li lj lk ll b">y</code>中)在<code class="fe li lj lk ll b">x</code>中都有一个两元素序列。例如，两个第一变化<code class="fe li lj lk ll b">0_BIG_DROP</code>和<code class="fe li lj lk ll b">0_BIG_DROP</code>之后是<code class="fe li lj lk ll b">3_BIG_RISE</code>状态。</p><p id="1ddc" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">这些值需要编码成整数。我们可以用<code class="fe li lj lk ll b">PathEncoder</code>类来实现:</p><pre class="my mz na nb gt oh ll oi oj aw ok bi"><span id="7017" class="mk lo iq ll b gy ol om l on oo">pe = PathEncoder(order)<br/>pe.fit(x, y)<br/>x_tr, y_tr = pe.transform(x, y)</span><span id="31fe" class="mk lo iq ll b gy op om l on oo">x_tr<br/>array([[0, 0],<br/>       [0, 3],<br/>       [3, 0],<br/>       ...,<br/>       [1, 3],<br/>       [3, 1],<br/>       [1, 3]])</span><span id="deb9" class="mk lo iq ll b gy op om l on oo">y_tr<br/>array([3, 0, 0, ..., 1, 3, 2])</span></pre><p id="1d0c" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">您可以访问编码字典:</p><pre class="my mz na nb gt oh ll oi oj aw ok bi"><span id="044d" class="mk lo iq ll b gy ol om l on oo">pe.label_dict<br/>{'0_BIG_DROP': 0, '1_DROP': 1, '2_RISE': 2, '3_BIG_RISE': 3, 'null': 4}</span></pre><p id="861f" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">注意，有一个<code class="fe li lj lk ll b">null</code>标签专用于缺失值。</p><p id="bf58" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">要适应模型，只需创建<code class="fe li lj lk ll b">MTD</code>类对象并适应它:</p><pre class="my mz na nb gt oh ll oi oj aw ok bi"><span id="34a7" class="mk lo iq ll b gy ol om l on oo">model = MTD(order=order)<br/>model.fit(x_tr, y_tr)<br/>log-likelihood value: -7547.882973125838</span></pre><p id="2914" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">您可以检查信息标准的值:</p><pre class="my mz na nb gt oh ll oi oj aw ok bi"><span id="a8ef" class="mk lo iq ll b gy ol om l on oo">print(f"AIC: {model.aic.round(1)}, BIC: {model.bic.round(1)}")<br/>AIC: 15137.8, BIC: 15276.7</span></pre><p id="945f" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">并做出预测:</p><pre class="my mz na nb gt oh ll oi oj aw ok bi"><span id="ecc0" class="mk lo iq ll b gy ol om l on oo">model.predict(np.array([[0, 0], <br/>                        [1, 3]]))<br/>array([2, 1])</span><span id="a8ee" class="mk lo iq ll b gy op om l on oo">model.predict_proba(np.array([[0, 0], <br/>                              [1, 3]])).round(3)<br/>array([[0.239, 0.239, 0.306, 0.215],<br/>       [0.217, 0.315, 0.275, 0.192]])</span></pre><p id="a729" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">让我们运行<code class="fe li lj lk ll b">order=3</code>的全部代码:</p><pre class="my mz na nb gt oh ll oi oj aw ok bi"><span id="bc1b" class="mk lo iq ll b gy ol om l on oo">order = 3<br/>​<br/>sc = SequenceCutter(order)<br/>x, y = sc.transform(df.Change_enc.values)</span><span id="f7d3" class="mk lo iq ll b gy op om l on oo">pe = PathEncoder(order)<br/>pe.fit(x, y)<br/>x_tr, y_tr = pe.transform(x, y)</span><span id="1a77" class="mk lo iq ll b gy op om l on oo">model = MTD(order=order, n_jobs=-1, number_of_initiations=100)<br/>model.fit(x_tr, y_tr)<br/>print(f"AIC: {model.aic.round(1)}, BIC: {model.bic.round(1)}")</span><span id="8af6" class="mk lo iq ll b gy op om l on oo">log-likelihood value: -7535.536495080953<br/>AIC: 15131.1, BIC: 15329.5</span></pre><p id="bea0" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">AIC 显示我们应该选择<code class="fe li lj lk ll b">order=3</code>，但是 BIC 却说<code class="fe li lj lk ll b">order=2</code>。正如西格尔定律所说:“一个有手表的人知道现在是什么时间。一个有两只表的人永远不确定。”，所以在检查其值之前选择您的标准:)</p><p id="8a62" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">我们可以将其与马尔可夫链的性能进行比较:</p><pre class="my mz na nb gt oh ll oi oj aw ok bi"><span id="3ab5" class="mk lo iq ll b gy ol om l on oo">order = 2<br/>model = MTD(order=order)<br/>model.fit(x_tr, y_tr)<br/>log-likelihood value: -7528.058152541998<br/>AIC: 15152.1, BIC: 15469.7</span><span id="59ca" class="mk lo iq ll b gy op om l on oo">order = 3<br/>model = MarkovChain(order=order)<br/>model.fit(x_tr, y_tr)</span><span id="fb9f" class="mk lo iq ll b gy op om l on oo">log-likelihood value: -7421.656650869228<br/>AIC: 15227.3, BIC: 16497.5</span></pre><p id="e455" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">无论我们在这里选择哪个标准，MTDg 模型似乎比马尔可夫链更能概括。</p></div><div class="ab cl kf kg hu kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="ij ik il im in"><h1 id="57cb" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">摘要</h1><p id="8da3" class="pw-post-body-paragraph km kn iq ko b kp mf jr kr ks mg ju ku kv mh kx ky kz mi lb lc ld mj lf lg lh ij bi translated">广义混合转移分布模型是有限状态马尔可夫链的一种简洁的替代方法。现在<code class="fe li lj lk ll b">mtd-learn</code>包提供了在 Python 中使用它们的简单方法。该软件包正处于早期开发阶段。欢迎任何贡献或功能请求。您可以在下面的参考书目部分找到关于模型的更多资源。</p><p id="0ff3" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">使用<a class="ae lm" href="https://www.codecogs.com/latex/eqneditor.php" rel="noopener ugc nofollow" target="_blank">latex.codecogs.com</a>生成乳胶配方</p></div><div class="ab cl kf kg hu kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="ij ik il im in"><h1 id="114b" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">文献学</h1><ol class=""><li id="ef8f" class="nt nu iq ko b kp mf ks mg kv oq kz or ld os lh ny nz oa ob bi translated">BERCHTOLD，RAFTERY，高阶马尔可夫链和非高斯时间序列的混合转移分布模型，2002 年。，统计科学第 17 卷，第 3328–356 页</li><li id="66db" class="nt nu iq ko b kp oc ks od kv oe kz of ld og lh ny nz oa ob bi translated">LEBRE，BOURGUIGNON，混合转移分布模型估计的 EM 算法，统计与基因组实验室，埃夫里大学，埃夫里，2009 年</li><li id="3495" class="nt nu iq ko b kp oc ks od kv oe kz of ld og lh ny nz oa ob bi translated">混合转移分布模型的估计。1999 年，华盛顿大学统计系第 352 号技术报告</li></ol></div></div>    
</body>
</html>