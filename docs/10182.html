<html>
<head>
<title>How to Convert Pandas Dataframe to Keras RNN and Back to Pandas for Multivariate Regression Problems</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对于多元回归问题，如何将 Pandas 数据框架转换为 Keras RNN，然后再转换回 Pandas</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-convert-pandas-dataframe-to-keras-rnn-and-back-to-pandas-for-multivariate-regression-dcc34c991df9?source=collection_archive---------10-----------------------#2020-07-18">https://towardsdatascience.com/how-to-convert-pandas-dataframe-to-keras-rnn-and-back-to-pandas-for-multivariate-regression-dcc34c991df9?source=collection_archive---------10-----------------------#2020-07-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ce9a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">这篇文章提供了一个简单的 Python 代码，它采用熊猫数据帧中的数据，并使用 Keras RNN LSTM 模型以相同的格式输出预测。</h2></div><p id="18b3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我遇到的问题相当普遍(我认为):以<code class="fe le lf lg lh b">pandas</code> <code class="fe le lf lg lh b">dataframe</code>格式获取数据，并使用带有<code class="fe le lf lg lh b">keras</code> RNN 的时间序列回归模型进行预测，其中我有不止一个独立的<code class="fe le lf lg lh b">X</code>(也称为特征或预测器)和一个依赖的<code class="fe le lf lg lh b">y</code>。更准确地说，问题不是构建模型，而是将数据从<code class="fe le lf lg lh b">pandas</code> <code class="fe le lf lg lh b">dataframe</code>格式转换成 RNN 模型(在<code class="fe le lf lg lh b">keras</code>中)需要的格式，并从<code class="fe le lf lg lh b">keras</code>模型中获得预测作为<code class="fe le lf lg lh b">pandas</code> <code class="fe le lf lg lh b">dataframe</code>。</p><p id="d3c4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感觉无论我在哪里寻找解决方案，我都能得到关于 RNN 如何工作的解释或者单变量回归问题的解决方案。因此，我会尽量保持这篇文章的简洁和集中。这里的编码假设您已经做了所有必要的预处理(例如，数据清理、特征工程等。)并以<code class="fe le lf lg lh b">pandas</code> <code class="fe le lf lg lh b">dataframe</code>格式准备好用于分析的时间序列。</p><p id="63c7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你<strong class="kk iu">不会</strong>在这里找到的:</p><p id="2ecd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">理论解释</p><p id="7bc9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">RNN 模型的精美插图</p><p id="caca" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">预处理技术</p><p id="c364" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">复杂或精密的模型</p><p id="7c27" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">网上有很多资源可以很好地解释这些问题，我强烈推荐查看一下<a class="ae li" href="https://stackoverflow.com/" rel="noopener ugc nofollow" target="_blank"> StackOverflow </a>的问题和杰森·布朗利<a class="ae li" href="https://machinelearningmastery.com/" rel="noopener ugc nofollow" target="_blank">的博客帖子。</a></p><p id="22d1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你<strong class="kk iu">会在这里</strong>找到什么:</p><p id="4af2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个简单的 Python 代码，采用一个<code class="fe le lf lg lh b">pandas</code> <code class="fe le lf lg lh b">dataframe</code>并使用一个<code class="fe le lf lg lh b">keras</code> RNN LSTM 模型以相同的格式输出预测，用于多元回归问题。</p><p id="c7fc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这篇文章将描述代码片段和解释，并在最后提供完整的无缝代码。</p><p id="f92f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们开始吧:</p><p id="4d3f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第一步，让我们导入所有需要的包并检查<code class="fe le lf lg lh b">keras</code>版本</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="c01a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如你所见，我的<code class="fe le lf lg lh b">keras</code>版本是<code class="fe le lf lg lh b">2.3.1</code>，所以如果你对我在这里发布的代码有一些问题，请检查你是否有相同或更高的版本。</p><p id="95d2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二步，读取数据</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="lo lp l"/></div></figure><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div class="gh gi lq"><img src="../Images/714aebc44cf2f3548fdff7c1b74ca9ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1044/format:webp/1*PEh9Nj6kQ9CFKnH0H6CcSQ.png"/></div></figure><p id="ee83" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如你所见，我有 32，128 行 4 列，有一个<code class="fe le lf lg lh b">y</code> <em class="lt"> </em>和三个<code class="fe le lf lg lh b">X</code>。这里的代码可以在任意数量的<code class="fe le lf lg lh b">X</code> <em class="lt"> </em>上运行，包括一个<em class="lt"> </em> <code class="fe le lf lg lh b">X</code> <em class="lt">。</em>注意，你需要定义你的<code class="fe le lf lg lh b">y</code>列，以使事情变得更简单和通用。</p><p id="22ad" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可选步骤-绘制数据</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="lo lp l"/></div></figure><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi lu"><img src="../Images/7fc52d1de0c868fc8f4bfac906a89eba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eSIAAp8lciGysVCyO33V3Q.png"/></div></div></figure><p id="cdcb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我知道，这里的分辨率不是很高，但是你可以想象我的数据是什么样子的。</p><p id="d9e9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第三步，拆分数据进行训练和测试</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="5048" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意第三行的注释。让我们再次策划，看看我们的分裂是否有意义。</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="lo lp l"/></div></figure><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi lz"><img src="../Images/7e494815c2f43ff19d66ab421fec22df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JSn_Eze91JrqXTajxR01cg.png"/></div></div></figure><p id="61bf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还是那句话，不要介意分辨率，这不重要。图看起来不错，过去(蓝色)是我们的训练数据，最近的日期是我们的测试数据(橙色)。</p><p id="26b7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第四步，只对训练数据分开<code class="fe le lf lg lh b">X</code>和<code class="fe le lf lg lh b">y</code>。我们将稍后处理测试数据。</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="c297" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，<code class="fe le lf lg lh b">X_train</code>看起来像这样:</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/6bbeb09b23da4e01c198ab9b3cea80af.png" data-original-src="https://miro.medium.com/v2/resize:fit:710/format:webp/1*Wl14htMn2QgwGd8WAZWOlA.png"/></div></figure><p id="b5a5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">而<code class="fe le lf lg lh b">y_train</code>看起来是这样的:</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/d764d1faa2d47e39410e6f7d45d8e25d.png" data-original-src="https://miro.medium.com/v2/resize:fit:430/format:webp/1*uGzZFnyGw206R0gCfJoXrA.png"/></div></figure><p id="2ca7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">步骤 5，为<code class="fe le lf lg lh b">keras</code>缩放并准备<code class="fe le lf lg lh b">X</code>和<code class="fe le lf lg lh b">y</code>数据</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="48c8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这部分需要一些解释。这里我们将数据从<code class="fe le lf lg lh b">pandas</code>数据帧转换成<code class="fe le lf lg lh b">keras</code>所需的<code class="fe le lf lg lh b">numpy</code>数组。在第 1–8 行中，我们首先使用<code class="fe le lf lg lh b">sklearn MinMaxScaler</code>模型缩放<code class="fe le lf lg lh b">X</code>和<code class="fe le lf lg lh b">y</code>，使它们的范围从 0 到 1。接下来的几行是对<code class="fe le lf lg lh b">y</code>的一些形状处理，以使其适用于<code class="fe le lf lg lh b">keras</code>。我们需要<code class="fe le lf lg lh b">y</code>的形状是<code class="fe le lf lg lh b">(n, )</code>，其中<code class="fe le lf lg lh b">n</code>是行数。第 12 行通过在第一个位置添加零将<code class="fe le lf lg lh b">y</code>数据向前“推”一步，第 13 行通过删除最后一个时间步(最后一行)保持<code class="fe le lf lg lh b">y</code>的形状。下面是第 12–13 行中发生的情况的一个简化示例:</p><pre class="lj lk ll lm gt mc lh md me aw mf bi"><span id="ab6f" class="mg mh it lh b gy mi mj l mk ml">#let's say y = [1,2,3,4]<br/># y = np.insert(y,0,0) --&gt; [0,1,2,3,4]<br/># y = np.delete(y,-1) --&gt; [0,1,2,3]</span></pre><p id="9789" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果这个解释不够清楚，我建议你参考 Jason Brownlee 的博客文章。查找标题为:<em class="lt">多元输入和相关系列示例的部分。</em></p><p id="e1f5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">总结一下<code class="fe le lf lg lh b">y</code>的形状操控，让我们快速看一下发生了什么。我们从作为数据帧的<code class="fe le lf lg lh b">y</code>数据开始:</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/b4fb199281d7e76ae99118b92bbae931.png" data-original-src="https://miro.medium.com/v2/resize:fit:436/format:webp/1*YakHr8WMoWgnPudVHn02Ng.png"/></div></figure><p id="2b71" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在它应该是这样的:</p><pre class="lj lk ll lm gt mc lh md me aw mf bi"><span id="e106" class="mg mh it lh b gy mi mj l mk ml">array([0.        , 0.12779697, 0.12401905, ..., 0.59237795, 0.6018512 , 0.61132446])</span></pre><p id="6857" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第六步，使用<code class="fe le lf lg lh b">keras</code>和<code class="fe le lf lg lh b">TimeseriesGenerator</code>组合<code class="fe le lf lg lh b">X</code>和<code class="fe le lf lg lh b">y</code></p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="c737" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">TimeseriesGenerator</code>将分离的<code class="fe le lf lg lh b">X</code>和<code class="fe le lf lg lh b">y</code>转换成样本结构，准备训练深度学习模型。我建议打印生成器对象的形状，以确保它能够工作。形状应该与第 8 行第 6 步中显示的完全一样。</p><p id="af89" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将我们的数据从<code class="fe le lf lg lh b">pandas</code> <code class="fe le lf lg lh b">dataframe</code>转换成可用于深度学习模型的东西的困难部分已经过去了。现在我们可以进入第 7 步，实例化模型:</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="c269" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，我在这里使用了一个非常简单的模型，只有一个隐藏层，没有脱落层。这是因为我想保持这篇文章的简洁，实际的模型架构不是这里的重点。但是可以随意尝试更多的层。</p><p id="8321" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第八步，拟合模型并绘制损失图</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="lo lp l"/></div></figure><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi mn"><img src="../Images/0d0bc494286dc18e1bbebc4374950631.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KYAe_b7xlj9gRJB52GmB0g.png"/></div></div></figure><p id="916b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样在这里，我使用了简单的设置，只有 5 个时期，只是为了说明整个过程。</p><p id="692c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在模型可以使用了，我们可以在测试集上进行预测。</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="28c1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第一行通过从测试集中删除<code class="fe le lf lg lh b">y</code> <em class="lt"> </em>来生成<code class="fe le lf lg lh b">X_test</code>数据，我们不希望<code class="fe le lf lg lh b">y</code> <em class="lt"> </em>数据包含在<code class="fe le lf lg lh b">X</code>中。然后我们根据之前安装在<code class="fe le lf lg lh b">X_train</code>上的<code class="fe le lf lg lh b">MinMaxScaler</code>模型来缩放<code class="fe le lf lg lh b">X_test</code>。第 3 行很重要，因为我们需要为测试数据创建一个<code class="fe le lf lg lh b">TimeseriesGenerator</code>。我很纠结这部分，因为在我看到的例子中，这里包含了<code class="fe le lf lg lh b">y_test</code>，但是我不希望模型有任何关于<code class="fe le lf lg lh b">y_test</code>数据的知识。我不希望有任何可能导致预测偏差的数据泄露。多亏了 Marco Cerliani 在<a class="ae li" href="https://stackoverflow.com/questions/62876780/how-to-shape-test-data-in-keras-lstm-prediction-for-multivariate-inputs-and-depe?noredirect=1#comment111192708_62876780" rel="noopener ugc nofollow" target="_blank"> StackOverflow </a>上给了我很大的帮助，我明白了<code class="fe le lf lg lh b">TimeseriesGenerator</code>中的第二个参数，也就是<code class="fe le lf lg lh b">y_test</code>只是一种预测方法，并且<code class="fe le lf lg lh b">y_test</code>的实际值并不重要(在这个特定的地方)，所以你可以插入一个虚拟的<code class="fe le lf lg lh b">y_test</code> →一个与实际<code class="fe le lf lg lh b">y_test</code>数据形状相同的零数组。<code class="fe le lf lg lh b">TimeseriesGenerator</code>的其余部分类似于训练数据，这里我也打印了形状以确保它没问题。</p><p id="62a7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第 10 行调用预测方法，第 11 行重新调整预测。记住，我们之前在 0 和 1 之间缩放了<code class="fe le lf lg lh b">y</code>数据，所以我们需要将它缩放回来。在第 12 行，我们从<code class="fe le lf lg lh b">y_true</code>和<code class="fe le lf lg lh b">y_pred</code>构造了一个<code class="fe le lf lg lh b">dataframe</code>。注意，我们只调用了<code class="fe le lf lg lh b">y_true</code> ( <code class="fe le lf lg lh b">test[y_col].values[n_input:]</code>)的子集，这是因为模型需要<code class="fe le lf lg lh b">n_input</code>时间步长(行或观察值)来开始预测，所以它从<code class="fe le lf lg lh b">X_test</code>中取出这些<code class="fe le lf lg lh b">n_input </code>(在本例中为 25 个时间步长)，然后才开始预测。例如，如果我们的测试集中有 50 个时间步长(或 50 行或 50 个观察值)，那么我们将只有 25 个预测，因为前 25 个是模型根据我们设置的体系结构使用的。</p><p id="7ce3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们有了一个很好的熊猫数据帧结构:</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/fa586363ac1ac5b669e88e66ac49b354.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/format:webp/1*yWYHSMefXKJg0p879Y6o-Q.png"/></div></figure><p id="3545" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用<code class="fe le lf lg lh b">results.plot();</code>来绘制它们:</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi mp"><img src="../Images/af14b5b70e5d6986424288e1ee7555ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fy4048arsFjoedxDtqZpiw.png"/></div></div></figure><p id="1149" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">就这样，我们以<code class="fe le lf lg lh b">pandas</code> <code class="fe le lf lg lh b">dataframe</code>格式的数据开始，以同样格式的预测结束。</p><p id="b532" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是一个块中的全部代码</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="6d3c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我希望这是有用的，将有助于您的机器学习任务。如果你有任何意见，请写在下面给我。</p></div></div>    
</body>
</html>