<html>
<head>
<title>Tafra: A Minimalist Dataframe</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">塔夫拉:一个极简的数据框架</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/tafra-a-minimalist-dataframe-61c7561ded2b?source=collection_archive---------56-----------------------#2020-06-17">https://towardsdatascience.com/tafra-a-minimalist-dataframe-61c7561ded2b?source=collection_archive---------56-----------------------#2020-06-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="32cb" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一个小的纯Python包，对类型的支持一流，对可用性和性能的依赖性最小。</h2></div><p id="a2c2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">大卫·s·富尔福德和德里克·w·特克。2020年6月17日</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi lc"><img src="../Images/3c78bbf64f6891a2a5e73cdd03bec150.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*cgtCh1duuEKfZgqZuzBE_w.jpeg"/></div><p class="lk ll gj gh gi lm ln bd b be z dk translated">图片来源:<a class="ae lo" href="https://pixabay.com/photos/laptop-book-information-online-819285/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><h2 id="6bf6" class="lp lq iq bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated">介绍</h2><p id="933b" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">很明显，数据科学需要数据。当我们处理数据时，我们必须首先从数据源加载数据，并存入内存。我们的数据可能有不同的<em class="lb">类型</em>:文本、整数、小数、日期、时间戳等等。<em class="lb">数据框架</em>是我们在执行数据科学时存储这种异构数据的实际机制。</p><p id="4ed1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mn mo mp mq b">tafra</code>作为一个思想实验开始了它的生命:我们怎样才能把阿达<strong class="kh ir"> <em class="lb">塔夫拉</em> </strong>我的想法(用像<code class="fe mn mo mp mq b">pandas</code>这样的库或者像<code class="fe mn mo mp mq b">R</code>这样的语言表达)减少到它有用的本质，同时切掉脚？</p><p id="c1fc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lo" href="https://usethe.computer/posts/12-typing-groupby.html" rel="noopener ugc nofollow" target="_blank">原始概念验证</a>在<code class="fe mn mo mp mq b">group_by()</code>处停止。从那以后，我们扩展了这个想法，构建了一个完整的库，产生了一个实用的T4，我们希望你会发现它是一个有用的轻量级替代品，可以替代T5的某些用途。</p><p id="a4df" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个<code class="fe mn mo mp mq b">tafra</code>或多或少是一组命名的<em class="lb">列</em>或<em class="lb">尺寸</em>。每一个都是长度一致的类型化<code class="fe mn mo mp mq b">numpy.ndarray</code>，用<em class="lb">行</em>表示每一列的值。该库提供了用于操作行和列的轻量级语法、对管理数据类型的支持、对行和子帧的迭代器、<code class="fe mn mo mp mq b">pandas</code>式的支持和从pandas数据帧的转换，以及SQL风格的<code class="fe mn mo mp mq b">GROUP BY</code>和<code class="fe mn mo mp mq b">JOIN</code>操作。</p><h2 id="8a72" class="lp lq iq bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated">一个简短的例子</h2><pre class="ld le lf lg gt mr mq ms mt aw mu bi"><span id="a147" class="lp lq iq mq b gy mv mw l mx my">from tafra import Tafra</span><span id="ad7f" class="lp lq iq mq b gy mz mw l mx my">t = Tafra({<br/>   'x': np.array([1, 2, 3, 4]),<br/>   'y': np.array(['one', 'two', 'one', 'two'], dtype='object'),<br/>})</span><span id="5593" class="lp lq iq mq b gy mz mw l mx my">t.pformat()<br/>&gt; Tafra(data = {<br/>&gt;  'x': array([1, 2, 3, 4]),<br/>&gt;  'y': array(['one', 'two', 'one', 'two'])},<br/>&gt; dtypes = {<br/>&gt;  'x': 'int', 'y': 'object'},<br/>&gt; rows = 4)</span></pre><p id="ec6a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们在一个Jupyter笔记本中，我们得到一个第一行带有<code class="fe mn mo mp mq b">dtypes</code>的HTML表格:</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi na"><img src="../Images/12e4b4abf6e199ff89cdca0969fe4d21.png" data-original-src="https://miro.medium.com/v2/resize:fit:234/format:webp/1*naPy3pLuL3JDWMavCcXbpg.png"/></div><p class="lk ll gj gh gi lm ln bd b be z dk translated">tafra的HTML表格渲染</p></figure><p id="e512" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">编写高性能代码(比如通过使用<code class="fe mn mo mp mq b"><a class="ae lo" href="https://numba.pydata.org/" rel="noopener ugc nofollow" target="_blank">numba</a></code>)需要严格执行您的数据类型。奇怪的是，Windows将<code class="fe mn mo mp mq b">int32</code>作为默认<code class="fe mn mo mp mq b">long</code>，而Linux和MacOS则是默认<code class="fe mn mo mp mq b">int64</code>。需要改吗？<code class="fe mn mo mp mq b">Tafra.update_dtypes()</code>可以接受<code class="fe mn mo mp mq b">numpy.dtype()</code>接受的任何输入。</p><pre class="ld le lf lg gt mr mq ms mt aw mu bi"><span id="00d7" class="lp lq iq mq b gy mv mw l mx my"># these are all equivalent<br/>t.update_dtypes({'x': 'int64', 'y': 'str'})<br/>t.update_dtypes({'x': np.int64, 'y': str})<br/>t.update_dtypes({'x': np.dtype('int64'), 'y': '&lt;U3'})</span></pre><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/0e1e100199f47f48c33d099d9334e5bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:216/format:webp/1*PXiYKm6QU6FMGgJ6eAhN7g.png"/></div><p class="lk ll gj gh gi lm ln bd b be z dk translated">铸造类型是灵活和直接的</p></figure><p id="54e7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除了从其他数据结构中读取数据(例如<a class="ae lo" href="https://tafra.readthedocs.io/en/latest/api.html#tafra.base.Tafra.read_csv" rel="noopener ugc nofollow" target="_blank"> CSV </a>、<a class="ae lo" href="https://tafra.readthedocs.io/en/latest/api.html#tafra.base.Tafra.read_sql" rel="noopener ugc nofollow" target="_blank"> SQL游标</a>，或者<a class="ae lo" href="https://tafra.readthedocs.io/en/latest/api.html#tafra.base.Tafra.from_records" rel="noopener ugc nofollow" target="_blank">行记录</a>，以及<a class="ae lo" href="https://tafra.readthedocs.io/en/latest/api.html#tafra.base.Tafra" rel="noopener ugc nofollow" target="_blank">许多其他数据结构</a>)，能够将<code class="fe mn mo mp mq b">tafra</code>转换为其他数据结构也很有用:</p><pre class="ld le lf lg gt mr mq ms mt aw mu bi"><span id="5af8" class="lp lq iq mq b gy mv mw l mx my">print('List:', '\n', t.to_list())<br/>&gt; List:<br/>&gt;  [array([1, 2, 3, 4], dtype=int64),<br/>&gt;  array(['one', 'two', 'one', 'two'], dtype='&lt;U3')]</span><span id="c43f" class="lp lq iq mq b gy mz mw l mx my">print('Records:', '\n', tuple(t.to_records()))<br/>&gt; Records:<br/>&gt;  ((1, 'one'), (2, 'two'), (3, 'one'), (4, 'two'))</span><span id="36e5" class="lp lq iq mq b gy mz mw l mx my">print('NamedTuple:', '\n', t.to_tuple())<br/>&gt; NamedTuple:<br/>&gt;  Tafra(x=array([1, 2, 3, 4], dtype=int64), y=array(['one', 'two', 'one', 'two'], dtype='&lt;U3'))</span><span id="c597" class="lp lq iq mq b gy mz mw l mx my">print('NamedTuple:', '\n', t.to_tuple(inner=True))<br/>&gt; NamedTuple:<br/>&gt;  Tafra(x=(1, 2, 3, 4), y=('one', 'two', 'one', 'two'))</span></pre><p id="04f8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要将聚合函数映射到列:</p><pre class="ld le lf lg gt mr mq ms mt aw mu bi"><span id="1f13" class="lp lq iq mq b gy mv mw l mx my">t.group_by(<br/>    ['y'], {'x': sum}<br/>)</span></pre><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/8c1438a8f2d80ada65047640fe83479f.png" data-original-src="https://miro.medium.com/v2/resize:fit:214/format:webp/1*V0Jc-R6fmshuHjq8K205wA.png"/></div><p class="lk ll gj gh gi lm ln bd b be z dk translated">group_by()运算</p></figure><p id="a10f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并将函数映射到行:</p><pre class="ld le lf lg gt mr mq ms mt aw mu bi"><span id="fb53" class="lp lq iq mq b gy mv mw l mx my">Tafra(t.row_map(lambda tf: (<br/>    tf['x'],<br/>    np.linspace(0, tf['x'].item(), 5)<br/>)))</span></pre><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/297a43c77da9dd39d275669f995d5de5.png" data-original-src="https://miro.medium.com/v2/resize:fit:448/format:webp/1*U1M7piEqps0QvaqqBEO8_Q.png"/></div><p class="lk ll gj gh gi lm ln bd b be z dk translated">row_map示例</p></figure><p id="4d15" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mn mo mp mq b">iterate_by</code>方法提供了很大的灵活性。<code class="fe mn mo mp mq b">Iterable</code>是唯一分组的<code class="fe mn mo mp mq b">Tuple</code>，匹配唯一分组的行的索引，以及这些行的<code class="fe mn mo mp mq b">Tafra</code>。例如:我们还没有构建pivot方法，但是执行您自己的方法非常简单:</p><pre class="ld le lf lg gt mr mq ms mt aw mu bi"><span id="daf6" class="lp lq iq mq b gy mv mw l mx my">pivot = []<br/>not_null = np.full(len(t), False)<br/>for y, idx, tf in t.iterate_by(['y']):<br/>    not_null |= idx<br/>    pivot.append([y, np.full(len(t), None)])<br/>    pivot[-1][1][idx] = t['x'][idx]</span><span id="f470" class="lp lq iq mq b gy mz mw l mx my">Tafra(pivot)[not_null]</span></pre><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/06b6640a85b294b6a4bb337b6c5c2777.png" data-original-src="https://miro.medium.com/v2/resize:fit:254/format:webp/1*yRWYn_qHoNvCNLmdhuFzyw.png"/></div><p class="lk ll gj gh gi lm ln bd b be z dk translated">有枢轴的塔夫绸</p></figure><p id="c495" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有一些适合熊猫的代码，或者只是一种你喜欢的做事方式？<code class="fe mn mo mp mq b">tafra</code>灵活:</p><pre class="ld le lf lg gt mr mq ms mt aw mu bi"><span id="ef21" class="lp lq iq mq b gy mv mw l mx my">df = pd.DataFrame(np.c_[<br/>    np.array([1, 2, 3, 4]),<br/>    np.array(['one', 'two', 'one', 'two'])<br/>], columns=['x', 'y'])</span><span id="3e8e" class="lp lq iq mq b gy mz mw l mx my">t = Tafra.from_dataframe(df)</span></pre><p id="409e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">回去也一样简单:</p><pre class="ld le lf lg gt mr mq ms mt aw mu bi"><span id="6613" class="lp lq iq mq b gy mv mw l mx my">df = pd.DataFrame(t.data)</span></pre><p id="cdeb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">或</em></p><pre class="ld le lf lg gt mr mq ms mt aw mu bi"><span id="438f" class="lp lq iq mq b gy mv mw l mx my">df = t.to_pandas()</span></pre><p id="0c61" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，大多数函数的默认设置是将数据视为不可变的。存在许多函数的就地版本，这样做是为了明确每个函数的返回类型。也就是说，一个函数最多返回一个类型或者一个<code class="fe mn mo mp mq b">None</code>，而不是调用代码必须检查的另外两个类型的一个<code class="fe mn mo mp mq b">Union</code>。</p><p id="b173" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不同返回类型的另一个例子在<code class="fe mn mo mp mq b">Tafra.read_sql</code>和<code class="fe mn mo mp mq b">Tafra_read_sql_chunks</code>中。前者将在调用时在一个<code class="fe mn mo mp mq b">Tafra</code>中返回所有记录，而后者将根据需要返回一个<code class="fe mn mo mp mq b">Iterator[Tafra]</code>来消费。</p><h2 id="d118" class="lp lq iq bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated">计时</h2><p id="8145" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">在这种情况下，轻量级也意味着高性能。除了添加到库中的任何附加特性，<code class="fe mn mo mp mq b">tafra</code>应该为组织数据结构进行数值处理提供必要的基础。最重要的方面之一是快速访问数据本身。通过最小化访问底层<code class="fe mn mo mp mq b">numpy.ndarray</code>，<code class="fe mn mo mp mq b">tafra</code>提供了数量级的性能提升。</p><pre class="ld le lf lg gt mr mq ms mt aw mu bi"><span id="7e4b" class="lp lq iq mq b gy mv mw l mx my"># Read Operations</span><span id="e2eb" class="lp lq iq mq b gy mz mw l mx my">%timemit x = t['x']<br/>&gt; 219 ns ± 71.6 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each)</span><span id="e472" class="lp lq iq mq b gy mz mw l mx my">%timemit x = df['x']<br/>&gt; 1.55 µs ± 105 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each)</span><span id="2822" class="lp lq iq mq b gy mz mw l mx my"># Assignment Operations</span><span id="b3a6" class="lp lq iq mq b gy mz mw l mx my">%timeit tf['x'] = x<br/>&gt; 7.39 µs ± 950 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)</span><span id="826f" class="lp lq iq mq b gy mz mw l mx my">%timeit df['x'] = x<br/>&gt; 47.8 µs ± 3.53 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each)</span></pre><p id="44bd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于那些需要更快性能的人来说，可以通过直接读写<code class="fe mn mo mp mq b">_data</code>属性来进行绕过数据验证检查的“不安全”操作。这些分别是熊猫的10倍和100倍。</p><pre class="ld le lf lg gt mr mq ms mt aw mu bi"><span id="0284" class="lp lq iq mq b gy mv mw l mx my">%timemit x = t._data['x']<br/>&gt; 55.3 ns ± 5.64 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each)</span><span id="e045" class="lp lq iq mq b gy mz mw l mx my">%timeit tf._data['x'] = x<br/>&gt; 65 ns ± 5.55 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each)</span></pre><h2 id="b053" class="lp lq iq bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated">聚合函数</h2><p id="9d40" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">dataframe式结构的主要用途之一是能够模拟SQL风格的<code class="fe mn mo mp mq b">GROUP BY</code>和<code class="fe mn mo mp mq b">JOIN</code>操作。<code class="fe mn mo mp mq b">tafra</code>在这些方面也很出色，即使是基本功能的性能也提高了<em class="lb">10倍</em>。此外，我们提供了将任何函数映射到任何列的能力。</p><pre class="ld le lf lg gt mr mq ms mt aw mu bi"><span id="b3b1" class="lp lq iq mq b gy mv mw l mx my"># Group By</span><span id="5a52" class="lp lq iq mq b gy mz mw l mx my">%timeit tf.group_by(['y', 'z'], {'x': sum})<br/>&gt; 138 µs ± 4.03 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each)</span><span id="ecc2" class="lp lq iq mq b gy mz mw l mx my">%timeit df.groupby(['y','z']).agg({'x': 'sum'}).reset_index()<br/>&gt; 2.5 ms ± 177 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)<br/></span><span id="46b2" class="lp lq iq mq b gy mz mw l mx my"># Transform, e.g. a GROUP BY followed by a LEFT JOIN back to the original table</span><span id="bec8" class="lp lq iq mq b gy mz mw l mx my">%timeit tf.transform(['y', 'z'], {'sum_x': (sum, 'x')})<br/>&gt; 161 µs ± 2.31 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each)</span><span id="d9ef" class="lp lq iq mq b gy mz mw l mx my">%%timeit<br/>tdf = df.copy()<br/>tdf['x'] = df.groupby(['y', 'z'])[['x']].transform(sum)<br/>&gt; 2.81 ms ± 143 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)</span></pre><h2 id="c6f5" class="lp lq iq bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated">摘要</h2><p id="d029" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">对于这些基本操作，<code class="fe mn mo mp mq b">tafra</code>至少快了一个数量级。而“不安全”赋值(直接赋值给<code class="fe mn mo mp mq b">_data</code>属性)是3个数量级如果你想自己提供<code class="fe mn mo mp mq b">dtypes</code>，或者在一组操作后调用<code class="fe mn mo mp mq b"><a class="ae lo" href="https://tafra.readthedocs.io/en/latest/api.html#tafra.base.Tafra._coalesce_dtypes" rel="noopener ugc nofollow" target="_blank">Tafra._coalesce_dtypes()</a></code>。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nf"><img src="../Images/cb8629f1c62a2a540206be48dcc44f22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dphl5nkkV-Evysx8-SKHVQ.png"/></div></div><p class="lk ll gj gh gi lm ln bd b be z dk translated">操作时间的比较</p></figure><h2 id="d316" class="lp lq iq bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated">你想知道更多吗？</h2><p id="8434" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">这只是对<code class="fe mn mo mp mq b">tafra</code>的介绍。我们相信它非常适合许多工作流，这些工作流需要一个以类型为中心的数据帧类型的结构，而不需要所有的花里胡哨…或者如果您只是想要一个替代方案，不会妨碍您将<code class="fe mn mo mp mq b">numpy.ndarray</code>传递到您想要它们去的地方。</p><p id="b3f7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这里查看文档<a class="ae lo" href="https://tafra.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">，并在这里</a>随意发布任何问题、错误或贡献<a class="ae lo" href="https://github.com/petbox-dev/tafra" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>