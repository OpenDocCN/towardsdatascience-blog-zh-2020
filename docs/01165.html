<html>
<head>
<title>Timing for Efficient Python Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高效 Python 代码的计时</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/timing-the-performance-to-choose-the-right-python-object-for-your-data-science-project-670db6f11b8e?source=collection_archive---------11-----------------------#2020-02-02">https://towardsdatascience.com/timing-the-performance-to-choose-the-right-python-object-for-your-data-science-project-670db6f11b8e?source=collection_archive---------11-----------------------#2020-02-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6186" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何比较列表、集合和其他方法的性能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8fe692fdc3f72c3f5d4f13e50232fc1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Z06kusmgS5pPESFA"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">乔恩·泰森在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="5954" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">动机</h1><p id="6c7e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">让我们看看这些常用的创建列表的方法:</p><p id="49c4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">串联:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="c6f1" class="mx la it mt b gy my mz l na nb">l = []<br/>   for i in range(10000):<br/>      l = l + [i]</span></pre><p id="987a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">追加:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="6d0f" class="mx la it mt b gy my mz l na nb">l = []<br/>   for i in range(10000):<br/>      l.append(i)</span></pre><p id="8ecb" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">理解:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="fd28" class="mx la it mt b gy my mz l na nb">l = [i for i in range(10000)]</span></pre><p id="0c33" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">列表范围:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="26d8" class="mx la it mt b gy my mz l na nb">l = list(range(10000))</span></pre><p id="4f67" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这些方法应该给你同样的数组。但是你有没有想过不同方法的效率？如果您正在处理一个小数据集，您可能不需要选择一种方法而不是另一种方法，但是当数据集变大时，选择一种有效的方法会对性能产生很大的影响。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/8ef11228349fa500b4ad42935fb97a83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*jgeIHTF8OD9HW4upqbKzkg.png"/></div></figure><p id="a1e1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">惊讶于<code class="fe nd ne nf mt b">concat</code>和其他方法在性能上的巨大差异？等到你看到比例:</p><p id="b99f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi">1019.0323133454616!</p><p id="003b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">您可能会意识到理解不同方法和 Python 对象之间的性能差异是多么重要。但是你能用什么方法来选择一个有效的方法呢？</p><h1 id="4c03" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">计时来追踪它</h1><p id="5063" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">你追踪的一个方法是用时间来追踪创建某个对象需要多长时间，比较时间差。<code class="fe nd ne nf mt b">timeit</code>方法允许你这么做。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="d15d" class="mx la it mt b gy my mz l na nb">import timeit</span><span id="8710" class="mx la it mt b gy ng mz l na nb">import numpy as np</span><span id="7fcc" class="mx la it mt b gy ng mz l na nb">from timeit import Timer</span></pre><p id="52f2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们看看如何跟踪方法的时间来创建我之前展示的列表。要使用<code class="fe nd ne nf mt b">Timer</code>,我们需要:</p><ul class=""><li id="9b03" class="nh ni it lt b lu mn lx mo ma nj me nk mi nl mm nm nn no np bi translated">将您想要计时的<em class="nq">函数</em>作为<em class="nq">字符串</em>和<em class="nq">位置</em>传递，以将该函数放入<code class="fe nd ne nf mt b">Timer</code></li><li id="1b87" class="nh ni it lt b lu nr lx ns ma nt me nu mi nv mm nm nn no np bi translated">设置<em class="nq">实验次数</em>以找到该功能的平均时间</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="eb12" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">结果:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="d880" class="mx la it mt b gy my mz l na nb">concat  25.208993583999998 milliseconds<br/>append  0.13781585199999924 milliseconds<br/>comprehension  0.08480268199999941 milliseconds<br/>list range  0.024738168999999033 milliseconds<br/><br/>Worse vs. best ratio 1019.0323133454616</span></pre><h1 id="8e12" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">比较其他 Python 方法</h1><p id="65b5" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">酷！现在我们知道如何比较不同方法之间的时间。让我们用它来跟踪我们在 Python 中经常使用的其他方法</p><h2 id="31a4" class="mx la it bd lb ny nz dn lf oa ob dp lj ma oc od ll me oe of ln mi og oh lp oi bi translated">Pop-front 与 Pop-end</h2><p id="8c8c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">您可能会猜测弹出数组前面的元素比弹出数组末尾的元素花费更多的时间(因为在弹出第一个元素后，您必须重新分配数组中其他元素的位置)。但是随着数组大小的增加，先弹出多长时间呢？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="6b36" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们使用范围从 10000 到 1000000 的数组进行测试，步长为 20000。让我们一起来观察我们的结果</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="698d" class="mx la it mt b gy my mz l na nb">import numpy as np</span><span id="e93c" class="mx la it mt b gy ng mz l na nb">matrixDat = np.array( result )</span><span id="c4f6" class="mx la it mt b gy ng mz l na nb">import matplotlib.pyplot as plt</span><span id="dce7" class="mx la it mt b gy ng mz l na nb">plt.plot(matrixDat[:,0], matrixDat[:,1], 'o', color='red',label='pop_zero');<br/>plt.plot(matrixDat[:,0], matrixDat[:,2], '+', color='blue',label='pop_end');</span><span id="af1c" class="mx la it mt b gy ng mz l na nb">leg = plt.legend(numpoints=1)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/80f90ca3cb95e3b089be2591eccdf093.png" data-original-src="https://miro.medium.com/v2/resize:fit:958/format:webp/1*lpuR5-W8ctO3UHdItFMuAQ.png"/></div></figure><p id="a1ff" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe nd ne nf mt b">.pop(0)</code>的持续时间随着阵列尺寸的增加而增加，而<code class="fe nd ne nf mt b">.pop()</code>的持续时间几乎保持不变。如果不追踪时间，我们不会注意到差异。</p><h2 id="7ca7" class="mx la it bd lb ny nz dn lf oa ob dp lj ma oc od ll me oe of ln mi og oh lp oi bi translated">列表与集合</h2><p id="2eac" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在我们找到 list 和 set 在性能上的区别之前，你愿意猜猜哪个性能更好吗？保持你的猜测，向下滚动找到答案。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="f285" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">使用前面的代码行来绘制结果。女士们先生们，让我来宣布结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/f872f270e5b55be6fd3753075d4e6618.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/format:webp/1*dUc_K01tDfdzfyGWrpr2Ug.png"/></div></figure><p id="cd8d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果你最初的猜测成立，你是对的。随着大小的增加，创建列表的持续时间增加，而集合的持续时间保持不变。</p><h1 id="acb7" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">结论</h1><p id="f9a0" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">了解 Python 方法之间的性能差异有助于您为自己的目标选择最有效的方法或对象。由于您将在数据科学项目中使用大型数据集，因此关注不同方法的性能以节省时间至关重要。</p><p id="2cb0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在<a class="ae ky" href="https://github.com/khuyentran1401/Data-science/blob/master/python/Time.ipynb" rel="noopener ugc nofollow" target="_blank"> this Github repo </a>中，您可以随意使用本文的代码。</p><p id="60d1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我喜欢写一些基本的数据科学概念，并尝试不同的算法和数据科学工具。你可以通过<a class="ae ky" href="https://www.linkedin.com/in/khuyen-tran-1401/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>和<a class="ae ky" href="https://twitter.com/KhuyenTran16" rel="noopener ugc nofollow" target="_blank"> Twitter </a>与我联系。</p><p id="5684" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果你想查看我写的所有文章的代码，请点击这里。在 Medium 上关注我，了解我的最新数据科学文章，例如:</p><div class="ol om gp gr on oo"><a rel="noopener follow" target="_blank" href="/maximize-your-productivity-with-python-6110004b45f7"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd iu gy z fp ot fr fs ou fu fw is bi translated">使用 Python 最大化您的生产力</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">你创建了一个待办事项清单来提高效率，但最终却把时间浪费在了不重要的任务上。如果你能创造…</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">towardsdatascience.com</p></div></div><div class="ox l"><div class="oy l oz pa pb ox pc ks oo"/></div></div></a></div><div class="ol om gp gr on oo"><a rel="noopener follow" target="_blank" href="/cython-a-speed-up-tool-for-your-python-function-9bab64364bfd"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd iu gy z fp ot fr fs ou fu fw is bi translated">cy thon——Python 函数的加速工具</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">当调整你的算法得到小的改进时，你可能想用 Cython 获得额外的速度，一个…</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">towardsdatascience.com</p></div></div><div class="ox l"><div class="pd l oz pa pb ox pc ks oo"/></div></div></a></div><div class="ol om gp gr on oo"><a rel="noopener follow" target="_blank" href="/choose-stocks-to-invest-with-python-584892e3ad22"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd iu gy z fp ot fr fs ou fu fw is bi translated">用 Python 选择要投资的股票</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">您计划在未来 3 年投资几只股票，每只股票的每一美元都有不同的预期回报…</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">towardsdatascience.com</p></div></div><div class="ox l"><div class="pe l oz pa pb ox pc ks oo"/></div></div></a></div><div class="ol om gp gr on oo"><a href="https://medium.com/@khuyentran1476/comprehensive-numpy-tutorials-for-beginners-8b88696bd3a2" rel="noopener follow" target="_blank"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd iu gy z fp ot fr fs ou fu fw is bi translated">为您的数据科学项目提供 Numpy 技巧</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">创建数组、矩阵、执行矩阵运算、解决线性代数问题和常见数据科学的技巧…</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">medium.com</p></div></div><div class="ox l"><div class="pf l oz pa pb ox pc ks oo"/></div></div></a></div></div></div>    
</body>
</html>