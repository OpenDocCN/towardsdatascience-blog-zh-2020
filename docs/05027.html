<html>
<head>
<title>Excel to Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Excel 到 Python</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/excel-to-python-79b01638f2d9?source=collection_archive---------5-----------------------#2020-05-01">https://towardsdatascience.com/excel-to-python-79b01638f2d9?source=collection_archive---------5-----------------------#2020-05-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f667" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为 Python 工具构建前端 Excel 工作簿</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b4676d70bebe66b4b2aa2c5c3581f273.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ToKTIvfq1ExRo4zA"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@m_b_m?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> M. B. M. </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="a01a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated"><span class="l lw lx ly bm lz ma mb mc md di"> D </span>在 Build 2016 大会上，微软宣布全球有 12 亿人在使用 Excel [1]。同年，地球人口估计为 74 亿[2]。</p><p id="2139" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那就是<strong class="lb iu">地球上所有人的 16.2%</strong>。</p><p id="830f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据 2019 年的一份报告[3]，Python 相比之下只有 820 万活跃开发者——占地球人口的 0.001%。</p><p id="53d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑到这些数字，鼓励 Excel 和 Python 之间更多的交互可能对我们有好处——为大量新用户打开 Python 构建的工具的闸门。</p><p id="4db5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">面向 Python 的 Excel 前端的机会是巨大的。在本文中，我们将看看如何做到这一点，并实现一个“典型的”财务 Excel 设置表。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="27a7" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">先有工具，后有 Excel</h1><p id="e4c8" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">在我能想到的几乎所有场景中，首先构建工具的 Python 部分会更方便。但是，我们必须保持工具“输入”格式的灵活性。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/9507a8ee4a63721aef7501de338f2646.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Mk2NqUY11sg9WAe8mv7Xdg.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">更改输入数据集格式不应破坏代码。</p></figure><p id="e0e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的意思是，如果我们使用 Pandas 读取一个或两个 CSV/Excel 表——对于第一个原型，我们可能依赖于一组给定的列名。</p><p id="b73c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，如果成千上万行代码，我们依赖于相同的硬编码值，当我们试图用 Excel 使这些输入列名动态化时，就会遇到问题。</p><p id="64cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，在初始原型阶段，<strong class="lb iu">如果还没有 Excel 表</strong>，使用代码的初始部分将列标签重命名为它们的内部(希望更具描述性)标签名称:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="dcce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">稍后，这将被我们的 Excel 表映射所取代。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="e081" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">Excel 前端</h1><p id="29e7" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">一旦 Python 工具被构建成一个更实际的原型，我们就该开始构建 Excel 前端了。首先，我们必须决定哪些变量可以从 Excel 工作表中进行调整。</p><p id="ba15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总是在假设输入数据的格式会改变的情况下构建这些类型的工具。</p><p id="9db2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据您的工作地点和您正在开发的工具，这要么非常重要，要么不重要。一些过程只是被很好地定义，数据格式不太可能改变。</p><p id="53d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，我总是谨慎行事，通过 Excel 前端包含更多而不是更少的灵活性。别太复杂了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/75ab6f7b553eaf3873b16f25cb9fff9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*35XmVp2ZzgeHUS96O_D8gg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用 Excel 将内部 Python 列标签映射到外部 CSV/Excel 列标签。</p></figure><p id="8493" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用内部命名系统并允许 Excel 用户指定列映射是保持灵活性的一个很好的例子。现在，Excel 用户可以调整这些映射，而不必依赖于硬编码的列名，甚至不用接触 Python。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="b448" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">映射</h1><p id="b383" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">集成的核心是<code class="fe nm nn no np b">mappings</code>字典。这将需要一个包含工具“设置”的 Excel 选项卡(我通常称之为映射)。</p><p id="dc60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了填充映射字典，我们需要读取 Excel mapping 选项卡的函数。为此，我们使用<strong class="lb iu"> openpyxl </strong>。</p><p id="0134" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以从 Excel 的给定单元格中读取一个值，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="bb63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用这个方法，我们现在可以开始填充我们的<code class="fe nm nn no np b">mappings</code>字典。我们将调整上面的代码，将本地路径添加到“tool _ setup”Excel 工作簿。</p><p id="5608" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还假设最初活动的工作表可能不是映射工作表，在添加、删除或移动选项卡的情况下，我们使用列表理解来查找“映射”选项卡索引:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="2295" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以添加一些映射:</p><pre class="kj kk kl km gt nq np nr ns aw nt bi"><span id="1ca1" class="nu mm it np b gy nv nw l nx ny">mappings = {}<br/>mappings['Amount'] = ws["E4"].value<br/>mappings['Term'] = ws["E5"].value</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/45d3972ce866b8ac1c39a7fe89357fae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qX4DLCFyoizQlPIG"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@nordwood?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">诺德伍德主题</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="8a54" class="ml mm it bd mn mo oa mq mr ms ob mu mv jz oc ka mx kc od kd mz kf oe kg nb nc bi translated">保持灵活性</h1><p id="984f" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">在从我们的 Excel mapping 选项卡中添加或删除行的情况下，这种方法将构建一个不正确的<code class="fe nm nn no np b">mapping</code>字典。为了避免这种情况，我们使用了<code class="fe nm nn no np b">search_col</code>功能。这将迭代地搜索一列中的每个单元格，直到找到包含我们想要的值的单元格(或者超出行<code class="fe nm nn no np b">limit</code>)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="5fd9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此时，search_col 返回包含我们想要查找的数据的列和行。</p><div class="kj kk kl km gt ab cb"><figure class="of kn og oh oi oj ok paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/7aaec070627661b64f5843d4140e8ede.png" data-original-src="https://miro.medium.com/v2/resize:fit:1030/format:webp/1*NGCNM8jZFvZK17kuOR4SSg.png"/></div></figure><figure class="of kn ol oh oi oj ok paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/25c9a4346baa3bc70e3af496321be4c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/format:webp/1*D0gCWQ4rJ1yDdZTgyEtv6A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk om di on oo translated">如果设置不正确，仅仅在一行中添加一个小的注释就可能破坏这个工具。左边<strong class="bd op"> B12 </strong>单元格包含<strong class="bd op"> Internal </strong>字样，表示我们列映射表的表头行，右边是<strong class="bd op"> B14 </strong>。</p></figure></div><p id="2eb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这允许我们通过在列 B 中搜索<strong class="lb iu">‘内部’</strong>来搜索列映射表，如下所示:</p><pre class="kj kk kl km gt nq np nr ns aw nt bi"><span id="b2e1" class="nu mm it np b gy nv nw l nx ny">search_col(ws, 'B', 'Internal')</span></pre><p id="282c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nm nn no np b">[Out]: ('B', 12)</code></p><p id="5d51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从这里，我们可以创建一个循环，将从列 C 到列 E 的映射添加到我们的<code class="fe nm nn no np b">mappings</code>字典中。一旦看到两个或更多的空白单元格，我们可以确信映射表已经结束，因此我们可以从循环中断开:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="1090" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦运行这段代码，我们将得到一个类似于下面这样的 Python 字典<code class="fe nm nn no np b">mappings </code>:</p><pre class="kj kk kl km gt nq np nr ns aw nt bi"><span id="d903" class="nu mm it np b gy nv nw l nx ny">{<br/>    'Loan ID': 'loan identifier',<br/>    'Product': 'product type',<br/>     ...<br/>    'Initial Fees': 'init fees'<br/>}</span></pre><p id="94df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们还想引入其他变量，例如 filepath，它在映射表截图中显示为<code class="fe nm nn no np b">data/loanbook.csv</code>。我们只需找到包含<em class="oq"> ' </em>文件路径'的行，并提取列 D 中的相应值:</p><pre class="kj kk kl km gt nq np nr ns aw nt bi"><span id="42b1" class="nu mm it np b gy nv nw l nx ny">row, _ = search_col(ws, 'C', 'Filepath')<br/>mappings['filepath'] = ws[f'D{row}].value</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8db7f919cbd1989ccc2a8e263c6b9af3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*d9GnAlhA9j3ZaICP"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@glenmcc?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">格伦·麦卡勒姆</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="be89" class="ml mm it bd mn mo oa mq mr ms ob mu mv jz oc ka mx kc od kd mz kf oe kg nb nc bi translated">综合</h1><p id="57bc" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">最后一步也是最简单的，将这些新的列名集成到我们的 Python 脚本中。</p><p id="f96f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们使用上面的映射表来读入数据，并将输入列标签转换为它们的内部标签。</p><pre class="kj kk kl km gt nq np nr ns aw nt bi"><span id="f72b" class="nu mm it np b gy nv nw l nx ny">data = pd.read_csv(mappings['Filepath'])</span></pre><p id="4525" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在将输入列标签转换为它们的内部标签之前，我们必须将键-值对交换为值-键对。</p><pre class="kj kk kl km gt nq np nr ns aw nt bi"><span id="429c" class="nu mm it np b gy nv nw l nx ny"># invert the dictionary<br/>inv_mappings = {mappings[key]: key for key in mappings}</span></pre><p id="8c5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管对于这个简单的例子来说，在构建<code class="fe nm nn no np b">mappings</code>字典时这样做似乎更方便。对于更复杂的工具，我总是发现保持我们在这里使用的内部:外部映射格式更好。尽管如此，这个细节还是由你来决定。</p><p id="5384" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，将输入标签转换为内部标签:</p><pre class="kj kk kl km gt nq np nr ns aw nt bi"><span id="9a34" class="nu mm it np b gy nv nw l nx ny">data.rename(inv_mappings, axis=1, inplace=True)</span></pre><p id="cb68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以在这里增加更多的灵活性。为了避免前导/尾随空格或小写/大写输入错误，我们重写了这部分代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="0961" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想加入的另一个可选部分。当我们在 Excel 表中显示内部列标签时，它们是大写的，并且包含正常间距。然而，作为个人偏好，我在内部维护了<a class="ae ky" href="https://en.wikipedia.org/wiki/Snake_case" rel="noopener ugc nofollow" target="_blank"> snake_case </a>格式，转换为:</p><pre class="kj kk kl km gt nq np nr ns aw nt bi"><span id="18c1" class="nu mm it np b gy nv nw l nx ny">"Loan ID" -&gt; "loan_id"<br/>"Initial Rate" -&gt; "initial_rate"</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/9d3710ffdb2b5ce344960d529b1acec2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7o69asOzuCd3T_H1"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@benchaccounting?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">钳工</a>对<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">去毛刺</a>拍照</p></figure><p id="d68d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我见过无数大量使用 Excel 的办公室，这些办公室可以节省数百个小时来检查复选框、键入值或等待 Excel 模型处理哪怕是最小的数据集。</p><p id="4c57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然自动化和机器学习的时代正在迅速自动化许多 Excel 繁重的领域，但 Excel 不会很快走向任何地方。</p><p id="ecda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目前，许多行业可以通过世界上发展最快的编程语言和世界上使用最多的软件之间的更紧密集成获得巨大的利益。</p><p id="4cb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="43c8" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">参考</h1><p id="e650" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">[1] J. Osborne，<a class="ae ky" href="https://www.techradar.com/uk/news/computing/pc/build-2016-1318027" rel="noopener ugc nofollow" target="_blank"> Build 2016:来自第 1 天和第 2 天的最大新闻</a> (2016)，techradar</p><p id="6235" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[2]世界银行，<a class="ae ky" href="https://data.worldbank.org/indicator/sp.pop.totl" rel="noopener ugc nofollow" target="_blank">总人口</a> (2019)，世界银行公开数据</p><p id="c700" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[3] M. Carraz，J. Stichbury，S. Schuermans，P. Crocker，K. Korakitis，C. Voskoglou，<a class="ae ky" href="https://slashdata-website-cms.s3.amazonaws.com/sample_reports/ZAamt00SbUZKwB9j.pdf" rel="noopener ugc nofollow" target="_blank">Developer Economis:the State of the Developer Nation</a>(2019)，SlashData</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="bcf3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">说到弥合不同技术之间的差距，我写过一篇关于用 Python 为 SQL 增压的文章。请点击这里查看:</p><div class="os ot gp gr ou ov"><a rel="noopener follow" target="_blank" href="/supercharging-ms-sql-server-with-python-e3335d11fa17"><div class="ow ab fo"><div class="ox ab oy cl cj oz"><h2 class="bd iu gy z fp pa fr fs pb fu fw is bi translated">用 Python 为 MS SQL Server 增压</h2><div class="pc l"><h3 class="bd b gy z fp pa fr fs pb fu fw dk translated">如何使用 Python 来自动化 SQL 的一切</h3></div><div class="pd l"><p class="bd b dl z fp pa fr fs pb fu fw dk translated">towardsdatascience.com</p></div></div><div class="pe l"><div class="pf l pg ph pi pe pj ks ov"/></div></div></a></div></div></div>    
</body>
</html>