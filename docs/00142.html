<html>
<head>
<title>plt.xxx(), or ax.xxx(), That Is The Question In Matplotlib</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">plt.xxx()还是 ax.xxx()，那是 Matplotlib 里的问题</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/plt-xxx-or-ax-xxx-that-is-the-question-in-matplotlib-8580acf42f44?source=collection_archive---------5-----------------------#2020-01-05">https://towardsdatascience.com/plt-xxx-or-ax-xxx-that-is-the-question-in-matplotlib-8580acf42f44?source=collection_archive---------5-----------------------#2020-01-05</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><figure class="it iu gq gs iv iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj is"><img src="../Images/2bc7e5ebf5fbdd8ad4947b266a532326.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IYEH91-VQv_J6C61QnhKog.png"/></div></div></figure><div class=""/><div class=""><h2 id="2b5f" class="pw-subtitle-paragraph kc je jf bd b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dk translated">学习 matplotlib 的初学者建议</h2></div><p id="eb4f" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp in bi translated">作为一个最近从使用 R 转换到 Python 的新手，通过标准 Python 可视化库<code class="fe lq lr ls lt b">matplotlib</code>进行数据可视化是学习过程中不可避免的一部分。最开始的时候，在看了几个容易找到的<code class="fe lq lr ls lt b">matplotlib</code>教程后，有一种“恩，没我想的那么难”的印象。在<code class="fe lq lr ls lt b">import matplotlib.pyplot as plt</code>之后，我基本上可以通过调用<code class="fe lq lr ls lt b">plt.xxx(…)</code>(如<code class="fe lq lr ls lt b">plt.plot(…)</code>、<code class="fe lq lr ls lt b">plt.scatter(…)</code>、<code class="fe lq lr ls lt b">plt.bar(…)</code>、<code class="fe lq lr ls lt b">plt.xlabel(…)</code>、<code class="fe lq lr ls lt b">plt.ylabel(…)</code>、<code class="fe lq lr ls lt b">plt.legend(…)</code>等)来剧情一切。).当涉及到一些具体的调整时，Stackoverflow 是可以找到答案的地方。很多时候，我只需要复制粘贴解决方案，甚至不需要阅读问题描述，人们称之为<strong class="kw jg"> Stackoverflow 综合症</strong>。然而，随着剧情变得复杂，我发现在<code class="fe lq lr ls lt b">matplotlib</code>中总是有许多不同的方法来解决一个特定的问题。例如，您可能会发现，<code class="fe lq lr ls lt b">plt.title(…)</code>、<code class="fe lq lr ls lt b">ax.set_title(…)</code>和<code class="fe lq lr ls lt b">ax.title.set_text(…)</code>这些功能都可以为一个情节设置一个标题。每次遇到这种情况，我都不知所措。<code class="fe lq lr ls lt b">plt.xxx()</code>不是一刀切的方法吗？<code class="fe lq lr ls lt b">ax.xxx()</code>从哪里来？</p><blockquote class="lv lw lx"><p id="5eb6" class="ku kv ly kw b kx ky kg kz la lb kj lc lz le lf lg ma li lj lk mb lm ln lo lp in bi translated">plt.xxx()，还是 ax.xxx()，就是这个问题。</p></blockquote><p id="6fa0" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp in bi translated">因此，我意识到复制粘贴的方法永远不会让我精通<code class="fe lq lr ls lt b">matplotlib</code>。我需要知道<code class="fe lq lr ls lt b">matplotlib</code>的架构和剧情。如果你是一个<code class="fe lq lr ls lt b">matplotlib</code>的初学者，并且和我一样经历过类似的情况，这是给你的帖子。在这篇文章中，我将分享我的笔记:</p><ol class=""><li id="aba5" class="mc md jf kw b kx ky la lb ld me lh mf ll mg lp mh mi mj mk bi translated"><code class="fe lq lr ls lt b">matplotlib</code>中<code class="fe lq lr ls lt b">plt.xxx()</code>与<code class="fe lq lr ls lt b">ax.xxx()</code>的区别，</li><li id="6a99" class="mc md jf kw b kx ml la mm ld mn lh mo ll mp lp mh mi mj mk bi translated">在<code class="fe lq lr ls lt b">matplotlib</code>中，<code class="fe lq lr ls lt b">figure</code>不仅是一个图形，<code class="fe lq lr ls lt b">axes</code>也不是轴的复数，</li><li id="07f3" class="mc md jf kw b kx ml la mm ld mn lh mo ll mp lp mh mi mj mk bi translated">分别用这两种方法画一个例图。</li></ol><p id="f6c9" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp in bi translated">我希望这篇文章能解答你长期以来的困惑，并节省你学习的时间。</p></div><div class="ab cl mq mr hy ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="in io ip iq ir"><h2 id="f796" class="mx my jf bd mz na nb dn nc nd ne dp nf ld ng nh ni lh nj nk nl ll nm nn no np bi translated"><code class="fe lq lr ls lt b">plt.xxx() </code>和<code class="fe lq lr ls lt b">ax.xxx()</code>的区别</h2><p id="9f70" class="pw-post-body-paragraph ku kv jf kw b kx nq kg kz la nr kj lc ld ns lf lg lh nt lj lk ll nu ln lo lp in bi translated">如图 1 所示，<code class="fe lq lr ls lt b">matplotlib</code>架构中有三个主要层。从上到下分别是<strong class="kw jg">脚本层</strong> ( <code class="fe lq lr ls lt b">matplotlib.pyplot</code>模块)、<strong class="kw jg">美工层</strong> ( <code class="fe lq lr ls lt b">matplotlib.artist</code>模块)、和<strong class="kw jg">后端层</strong> ( <code class="fe lq lr ls lt b">matplotlib.backend_bases</code>模块)。</p><figure class="nw nx ny nz gu iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj nv"><img src="../Images/18495d24e4569c544cd121d15a0658fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-AodXsh3AIymW83WLPwYqw.png"/></div></div><p class="oa ob gk gi gj oc od bd b be z dk translated">图 1，Matplotlib 架构</p></figure><p id="d744" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp in bi translated">让我们从底层开始，<strong class="kw jg">后端层</strong>通过与你机器中的工具箱如<a class="ae lu" href="https://www.wxpython.org/" rel="noopener ugc nofollow" target="_blank"> wxPython </a>或绘图语言如 PostScript 通信来处理所有繁重的工作。这是最复杂的一层。在这一层中，<code class="fe lq lr ls lt b">FigureCanvas</code>是绘制图形的区域，<code class="fe lq lr ls lt b">Renderer</code>是知道如何在<code class="fe lq lr ls lt b">FigureCanvas</code>上绘制的对象。像你我这样的普通用户几乎不需要处理这一层。</p><p id="cc8a" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp in bi translated">然后是中间层，<strong class="kw jg">艺术家层</strong>，这里是<code class="fe lq lr ls lt b">ax.xxx()</code>的来源。顾名思义，使用该层，您可以控制和微调尽可能多的元素(例如，脊线、刻度方向、刻度标签大小、刻度标签字体、刻度颜色等。)就像艺术家在画布上作画一样。与<strong class="kw jg">脚本层</strong>(见下文)相比，这一层允许你做更多的定制，对于高级剧情来说更方便。特别是当处理多个图形/轴时，你不会混淆哪个是当前活动的，因为每个子图都被分配给一个<code class="fe lq lr ls lt b">ax</code>。这就是为什么<code class="fe lq lr ls lt b">ax.xxx()</code>有时被称为<strong class="kw jg">基于对象的绘图</strong>。在编写 web 应用程序、UI 应用程序或者与其他开发人员共享的脚本时，我们肯定会更多地使用这一层。</p><p id="65b6" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp in bi translated">顶层，<strong class="kw jg">脚本层，</strong><code class="fe lq lr ls lt b">plt.xxx()</code>驻留于此，旨在使<code class="fe lq lr ls lt b">matplotlib</code>像 MATLAB 脚本一样工作。换句话说，这一层被认为是所有三层中最轻的脚本接口，它包括一组命令风格的函数，用于快速轻松地生成图形和绘图。这也是为什么很多<code class="fe lq lr ls lt b">matplotlib</code>教程更喜欢从这一层介绍。这是最容易开始和使用的部分，你基本上是在<code class="fe lq lr ls lt b">figure</code>的顶部添加对象(如线条、文本、矩形)。脚本层绘图有时也称为<strong class="kw jg">程序绘图</strong>。</p><figure class="nw nx ny nz gu iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj oe"><img src="../Images/1f94948894f5babaa02109f87ab0312b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JVFKjtwLXGOXkfJNh8IGHQ.png"/></div></div><p class="oa ob gk gi gj oc od bd b be z dk translated">图 2，脚本层绘制</p></figure><h2 id="a424" class="mx my jf bd mz na nb dn nc nd ne dp nf ld ng nh ni lh nj nk nl ll nm nn no np bi translated">Matplotlib 中的“图形”和“轴”</h2><p id="1834" class="pw-post-body-paragraph ku kv jf kw b kx nq kg kz la nr kj lc ld ns lf lg lh nt lj lk ll nu ln lo lp in bi translated">在<code class="fe lq lr ls lt b">matplotlib</code>中，<code class="fe lq lr ls lt b">figure</code>和<code class="fe lq lr ls lt b">axes</code>是一个图形的层(请注意，我并没有引用这个“图形”作为脚本)。这里让我们用 matplotlib 网站<a class="ae lu" href="https://matplotlib.org/1.5.1/faq/usage_faq.html#parts-of-a-figure" rel="noopener ugc nofollow" target="_blank">的一张图来解释这些概念。</a></p><figure class="nw nx ny nz gu iw gi gj paragraph-image"><div class="gi gj of"><img src="../Images/bbebf63735c80acae552beedc790df58.png" data-original-src="https://miro.medium.com/v2/resize:fit:770/format:webp/1*vIx8q9gj1WBY38Nhin_LKw.png"/></div><p class="oa ob gk gi gj oc od bd b be z dk translated">图 3，Matplotlib 中的部分图形</p></figure><p id="b167" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp in bi translated">从图 3 中我们可以看到，整个<code class="fe lq lr ls lt b">figure</code>(标记为外部红色方框)是一个图形的基础。其上一层是<code class="fe lq lr ls lt b">axes</code>(标记为内部蓝色方框)。一个<code class="fe lq lr ls lt b">figure</code>至少可以有一个<code class="fe lq lr ls lt b">axes</code>。从这里我们知道，<code class="fe lq lr ls lt b">axes</code>指的是图形的一部分，而不是一个以上轴的复数。例如，如果在<code class="fe lq lr ls lt b">figure</code>上有一个图，那么这个图就是<code class="fe lq lr ls lt b">axes</code>。如果你在一个<code class="fe lq lr ls lt b">figure</code>上有多个支线剧情，那么每个支线剧情就是一个<code class="fe lq lr ls lt b">axes</code>。为了能够制作一个情节，我们通常在开始时调用<code class="fe lq lr ls lt b">fig = plt.figure()</code>。我们通过调用<code class="fe lq lr ls lt b">ax1 = fig.add_subplot(2, 1, 1)</code>在<code class="fe lq lr ls lt b">figure</code>中创建一个<code class="fe lq lr ls lt b">axes</code>对象。这创建了 2 行 1 列的第一个支线剧情<code class="fe lq lr ls lt b">figure</code>。因此，所有的<code class="fe lq lr ls lt b">ax1.xxx(…)</code>都是专用于<code class="fe lq lr ls lt b">ax1</code>的功能。例如，要访问子情节<code class="fe lq lr ls lt b">ax1</code>中的 x 轴和 y 轴，我们调用<code class="fe lq lr ls lt b">ax1.xaxis(…)</code>和<code class="fe lq lr ls lt b">ax1.yaxis(…)</code>。同样，我们可以通过调用<code class="fe lq lr ls lt b">ax2 = fig.add_subplot(2, 1, 2)</code>来添加另一个子情节，并通过调用<code class="fe lq lr ls lt b">ax2.xxx(…)</code>来操纵它的元素。这样，在不弄乱代码的情况下，我们清楚地知道我们正在处理哪个子情节(当然，还有许多其他方法来调用两个<code class="fe lq lr ls lt b">axes</code>，例如，<code class="fe lq lr ls lt b">fig, ax = plt.subplots(2)</code>，那么每个轴都可以通过调用<code class="fe lq lr ls lt b">ax[0]</code>和<code class="fe lq lr ls lt b">ax[1]</code>来访问)。</p><h2 id="8f72" class="mx my jf bd mz na nb dn nc nd ne dp nf ld ng nh ni lh nj nk nl ll nm nn no np bi translated">使用两种方法的示例图</h2><p id="ce33" class="pw-post-body-paragraph ku kv jf kw b kx nq kg kz la nr kj lc ld ns lf lg lh nt lj lk ll nu ln lo lp in bi translated">好了，在明确了<code class="fe lq lr ls lt b">plt.xxx()</code>和<code class="fe lq lr ls lt b">ax.xxx()</code>的概念后，让我们用一个改编自<a class="ae lu" href="https://matplotlib.org/examples/pylab_examples/axes_demo.html" rel="noopener ugc nofollow" target="_blank"> matplotlib 文档</a>的简单例子来演示它们在绘制带有支线剧情的人物时的区别。</p><figure class="nw nx ny nz gu iw"><div class="bz fq l di"><div class="og oh l"/></div><p class="oa ob gk gi gj oc od bd b be z dk translated">脚本层绘图</p></figure><figure class="nw nx ny nz gu iw"><div class="bz fq l di"><div class="og oh l"/></div><p class="oa ob gk gi gj oc od bd b be z dk translated">艺术家图层绘图</p></figure><p id="8430" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp in bi translated">如果一切顺利，你会得到如下图。</p><figure class="nw nx ny nz gu iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj oi"><img src="../Images/fb9307d9025bc370aaae328bae2a8c68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tPLnKSjrCZMu0-XyNZfLRg.png"/></div></div><p class="oa ob gk gi gj oc od bd b be z dk translated">图 4，一个示例图</p></figure><p id="faaa" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp in bi translated">从这两个脚本中可以看出(<strong class="kw jg">脚本层出图</strong> <em class="ly"> vs. </em> <strong class="kw jg">美工层出图</strong>)，虽然美工层出图的代码比脚本层出图的代码更冗长，但是更容易读懂。这是一个非常重要的实践，可以让您生成高质量的代码并增加代码的可读性。当情节变得复杂时，艺术家分层绘图的力量就会越来越明显。</p><p id="0e3a" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp in bi translated">综上所述，我们可以使用<code class="fe lq lr ls lt b">plt.xxx()</code>来快速获得用于探索性数据分析的图表，然而，当您的代码是一个严肃项目的一部分并且需要与其他人共享时，<code class="fe lq lr ls lt b">ax.xxx()</code>是一种常用的风格。另外，作为一名<code class="fe lq lr ls lt b">matplotlib</code>的学习者，我强烈建议从<strong class="kw jg">艺术家图层绘制</strong>开始，从中你会对<code class="fe lq lr ls lt b">matplotlib</code>绘制有一个更全面的了解，对你在数据可视化方面的长远发展肯定更有好处。</p><p id="0719" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp in bi translated">以下是我发现非常有用的材料(<em class="ly">持续更新列表</em>)</p><ul class=""><li id="716b" class="mc md jf kw b kx ky la lb ld me lh mf ll mg lp oj mi mj mk bi translated"><a class="ae lu" href="https://github.com/matplotlib/AnatomyOfMatplotlib" rel="noopener ugc nofollow" target="_blank">Matplotlib 剖析——为 SciPy 会议开发的教程</a></li><li id="4b94" class="mc md jf kw b kx ml la mm ld mn lh mo ll mp lp oj mi mj mk bi translated"><a class="ae lu" href="https://pyviz.org/index.html" rel="noopener ugc nofollow" target="_blank">用于数据可视化的 Python 工具</a></li><li id="d800" class="mc md jf kw b kx ml la mm ld mn lh mo ll mp lp oj mi mj mk bi translated"><a class="ae lu" href="https://know.anaconda.com/eBook-PyVizeBookLP_ReportRegistration.html?utm_source=pyviz.org&amp;utm_campaign=pyviz&amp;utm_content=ebook" rel="noopener ugc nofollow" target="_blank">如何浏览 PyViz 景观</a></li><li id="d13f" class="mc md jf kw b kx ml la mm ld mn lh mo ll mp lp oj mi mj mk bi translated">Matplotlib 画廊</li><li id="e139" class="mc md jf kw b kx ml la mm ld mn lh mo ll mp lp oj mi mj mk bi translated"><a class="ae lu" href="https://matplotlib.org/api/api_overview.html" rel="noopener ugc nofollow" target="_blank"> Matplotlib API 概述</a></li></ul></div><div class="ab cl mq mr hy ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="in io ip iq ir"><p id="b14b" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp in bi translated">和往常一样，我欢迎反馈、建设性的批评以及倾听您的数据科学项目。你可以在 Linkedin 上找到我，现在也可以在我的网站上找到我。</p></div></div>    
</body>
</html>