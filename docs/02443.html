<html>
<head>
<title>Backtesting with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python进行回溯测试</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/backtesting-with-python-109cab7ee737?source=collection_archive---------27-----------------------#2020-03-08">https://towardsdatascience.com/backtesting-with-python-109cab7ee737?source=collection_archive---------27-----------------------#2020-03-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ca16" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">回溯测试移动平均线</h2></div><p id="748a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本帖中，我们将使用Python对简单的移动平均(MA)策略进行回溯测试。在我最近的一篇文章中，我展示了如何使用Python计算和绘制移动平均策略。现在，我们将学习通过回溯测试我们的算法来模拟移动平均线策略在过去几个月的表现。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi lc"><img src="../Images/7a7b9327802010eaa81bab1b4d21a7f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*FSxyeAUnEWhjX8Z1"/></div><p class="lk ll gj gh gi lm ln bd b be z dk translated">照片由<a class="ae lb" href="https://www.pexels.com/@negativespace?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">负空间</a>从<a class="ae lb" href="https://www.pexels.com/photo/party-glass-architecture-windows-34092/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">像素</a></p></figure><h1 id="bd06" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">重述移动平均线策略</h1><p id="5491" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">让我们首先快速回顾一下我们在上一篇文章中构建的内容。我们的模型很简单，我们构建了一个脚本来计算和绘制短期移动平均线(20天)和长期移动平均线(250天)。</p><p id="5b3a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我推荐你看一下这篇文章，了解更多关于移动平均线和如何构建Python脚本的细节。在这篇文章中，我将只发布获取所选股票的移动平均线和股价的代码:</p><pre class="ld le lf lg gt ml mm mn mo aw mp bi"><span id="909d" class="mq lp iq mm b gy mr ms l mt mu">import requests<br/>import pandas as pd<br/>import matplotlib.pyplot as plt<br/><br/><br/>def stockpriceanalysis(stock):<br/>    stockprices = requests.get(f"https://financialmodelingprep.com/api/v3/historical-price-full/{stock}?serietype=line")<br/>    stockprices = stockprices.json()<br/><br/>#Parse the API response and select only last 1200 days of prices<br/>    stockprices = stockprices['historical'][-1200:]<br/><br/>#Convert from dict to pandas datafram<br/><br/>    stockprices = pd.DataFrame.from_dict(stockprices)<br/>    stockprices = stockprices.set_index('date')<br/>    #20 days to represent the 22 trading days in a month<br/>    stockprices['20d'] = stockprices['close'].rolling(20).mean()<br/>    stockprices['250d'] = stockprices['close'].rolling(250).mean()<br/>  <br/>stockpriceanalysis('aapl')</span></pre><h1 id="ca8b" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">回溯测试策略</h1><p id="4e87" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">为了执行回溯测试，我们将:</p><ul class=""><li id="7cec" class="mv mw iq kh b ki kj kl km ko mx ks my kw mz la na nb nc nd bi translated">当<strong class="kh ir">短期移动平均线穿越长期移动平均线</strong>上方时，做多100只股票(即买入100只股票)。这就是所谓的<a class="ae lb" href="https://www.investopedia.com/terms/g/goldencross.asp" rel="noopener ugc nofollow" target="_blank">黄金交叉。</a></li><li id="0c98" class="mv mw iq kh b ki ne kl nf ko ng ks nh kw ni la na nb nc nd bi translated">几天后卖出股票。例如，我们会保留库存20天，然后出售。</li><li id="7f06" class="mv mw iq kh b ki ne kl nf ko ng ks nh kw ni la na nb nc nd bi translated">计算利润</li></ul><p id="5fad" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个非常简单的策略。我们将有所选股票的每日收盘价。该策略也可以用于分钟或小时数据，但我将保持简单，并基于每日数据执行回溯测试。</p><p id="5912" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为我不期望有很多进入点，也就是当我们购买股票时，为了简单起见，我将忽略交易成本。</p><p id="0811" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还记得我们之前的帖子吗，如果我们通过将股票名称作为参数传递给analyse来运行脚本，我们将获得一个名为<strong class="kh ir"> <em class="nj"> stockprices </em> </strong>的Pandas数据帧，其中包含最近1200天的收盘价和移动平均线。</p><pre class="ld le lf lg gt ml mm mn mo aw mp bi"><span id="4b14" class="mq lp iq mm b gy mr ms l mt mu">stockpriceanalysis('aapl')<br/><br/>#Outcome stored in a DataFrame call stockprices<br/>	        close	20d	         250d<br/>date			<br/>2020-02-07	320.03	316.7825	224.76192<br/>2020-02-10	321.55	317.3435	225.36456<br/>2020-02-11	319.61	317.4760	225.96228<br/>2020-02-12	327.20	318.2020	226.58788</span></pre><h1 id="aad5" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">Python中的回溯测试策略</h1><p id="379e" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">为了建立我们的回溯测试策略，我们将首先创建一个包含我们每个多头头寸利润的列表。</p><p id="6f2e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先(1)，我们创建一个新列，它将包含数据帧中所有数据点的<em class="nj"> True </em>，在该数据帧中，20天移动平均线与250天移动平均线相交。</p><p id="c8e7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，我们只对交叉发生的第一天或第二天感兴趣(即20日均线越过250日均线)。因此，我们定位交叉发生的第一个或第二个日期(行)( 2)。</p><p id="35ce" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如在这篇<a class="ae lb" href="https://economictimes.indiatimes.com/markets/stocks/news/moving-average-trading-rules/articleshow/71749811.cms?from=mdr" rel="noopener ugc nofollow" target="_blank">文章</a>中所述，我们将使用两天规则(<a class="ae lb" href="https://economictimes.indiatimes.com/markets/stocks/news/moving-average-trading-rules/articleshow/71749811.cms?utm_source=contentofinterest&amp;utm_medium=text&amp;utm_campaign=cppst" rel="noopener ugc nofollow" target="_blank">，即只有在被多一天的收盘</a>确认后，我们才开始交易，并且只有当连续两天20日均线高于250日均线时，我们才会保留该日期作为进场点。</p><p id="5a87" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种方法将帮助我们避免日常交易噪音波动。当这种情况发生时，我们将在列<em class="nj"> firstbuy </em>中设置入口点，其中值等于True:</p><pre class="ld le lf lg gt ml mm mn mo aw mp bi"><span id="7103" class="mq lp iq mm b gy mr ms l mt mu">#Start longposiiton list<br/><br/>longpositions = []<br/># (1)<br/>stockprices['buy'] =(stockprices['20d'] &gt; stockprices['250d'])<br/># (2)<br/>stockprices['firstbuy'] =   ((stockprices['buy'] == True) &amp; (stockprices['buy'].shift(2) == False)&amp; (stockprices['buy'].shift(1) == True))<br/><br/># (3) identify the buying points <br/>buyingpoints = np.where(stockprices['firstbuy'] == True)<br/>print(buyingpoints)<br/><br/>#Outcome<br/>(array([ 307,  970, 1026]),)</span></pre><p id="5dc6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">规则<em class="nj">(股票价格【买入】。shift(2) == False) </em>，帮助我们找出交叉发生后的第一个日期。</p><p id="919a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们有了变量<em class="nj">买入点</em> (3)，我们应该用我们的长期策略进入市场的日期。</p><p id="277b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">数组<em class="nj"> buyingpoints </em>中的每个元素代表我们需要做多的行。因此，我们可以通过它们循环得到接近的价格，并购买100只股票(4)。</p><p id="3ff7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们保留这些股票20天(5)，并以+20天收盘价卖出这100只股票。</p><pre class="ld le lf lg gt ml mm mn mo aw mp bi"><span id="8ab5" class="mq lp iq mm b gy mr ms l mt mu">#(4)<br/>for item in buyingpoints[0]:<br/>    #close price of the stock when 20MA crosses 250 MA <br/>    close_price = stockprices.iloc[item].close<br/><br/>    #Enter long position by buying 100 stocks<br/>    long = close_price*100<br/><br/>    # (5) sell the stock 20 days days later:<br/>    sellday = item + 20<br/>    close_price = stockprices.iloc[sellday].close<br/><br/>    #Sell 20 days later:<br/>    sell = close_price*100<br/>   <br/>    # (6) Calculate profit<br/>    profit = sell - long<br/><br/>    longpositionsprofit.append(profit)</span></pre><p id="b5b7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们计算利润，并将策略的结果添加到<em class="nj"> longpositionprofit </em>数组(6)中。</p><h1 id="c746" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">我们战略的结果</h1><p id="b36c" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">要了解我们的策略执行得如何，我们可以打印出多头头寸利润列表并计算总额:</p><pre class="ld le lf lg gt ml mm mn mo aw mp bi"><span id="18dd" class="mq lp iq mm b gy mr ms l mt mu">print(longpositionsprofit)<br/>#outcome<br/>(array([ 307,  970, 1026]),)<br/><br/>print(sum(longpositionsprofit))<br/>#outcome<br/>2100.0</span></pre><p id="481a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">太好了，我们对苹果的回溯测试策略显示，在1200多天里，我们进入了一个多头头寸，并在20天后总共卖出了三次。</p><p id="9749" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一次，我们获得了307美元的利润，第二次，970美元，最后一个多头头寸，我们获得了1026美元的利润。总共是2100美元。</p><p id="fdb9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一点也不差。但是如果我们在1200天前买了这只股票并一直持有到今天会怎么样呢？通过在我们的<em class="nj">股票价格</em>数据框架中获得最后一个可用价格和第一个可用价格，我们可以很容易地计算出买入和持有的利润。</p><pre class="ld le lf lg gt ml mm mn mo aw mp bi"><span id="6495" class="mq lp iq mm b gy mr ms l mt mu">firstdayprice = stockprices.iloc[0].close<br/>lastdayprice = stockprices.iloc[-1].close<br/><br/>profit = 100*(lastdayprice - firstdayprice)<br/>profit<br/><br/>#Outcome<br/>15906.999999999996</span></pre><p id="c986" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有趣的是，只要持有股票1，200天，我们的利润就是15，906美元加上年度股息。比我们采用移动平均线策略要高得多。</p><h1 id="2d86" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">包扎</h1><p id="8659" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">我们使用了一个简单的策略，当20日均线穿过250日均线时买入股票。然后，我们把股票保留了20天，然后才卖出。</p><p id="67d3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可能还遵循了其他策略。例如，我们可以在移动平均线交叉时买入股票，并持有到最后。或者，如果250天移动平均线低于20天移动平均线，我们可以卖掉股票。</p><p id="ed57" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我会让你知道如何试验和测试这些其他的策略。很高兴在我的Twitter账户上收到您的反馈。</p><p id="0462" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">查看下面的Python脚本，对任何公司的移动平均线策略进行回溯测试。只要把苹果的<strong class="kh ir"> <em class="nj">换成其他公司的</em> </strong>就行了</p><pre class="ld le lf lg gt ml mm mn mo aw mp bi"><span id="db04" class="mq lp iq mm b gy mr ms l mt mu">#Moving Averages and backtesting <br/>import requests<br/>import pandas as pd<br/>import matplotlib.pyplot as plt<br/>import numpy as np<br/><br/><br/>def stockpriceanalysis(stock):<br/>    stockprices = requests.get(f"https://financialmodelingprep.com/api/v3/historical-price-full/{stock}?serietype=line")<br/>    stockprices = stockprices.json()<br/><br/>#Parse the API response and select only last 1200 days of prices<br/>    stockprices = stockprices['historical'][-1200:]<br/><br/>#Convert from dict to pandas datafram<br/><br/>    stockprices = pd.DataFrame.from_dict(stockprices)<br/>    stockprices = stockprices.set_index('date')<br/>    #20 days to represent the 22 trading days in a month<br/>    stockprices['20d'] = stockprices['close'].rolling(20).mean()<br/>    stockprices['250d'] = stockprices['close'].rolling(250).mean()<br/>    <br/>    ###STARTING BACKTESTING STRATEGY<br/>    #Start longposiiton list<br/>    longpositionsprofit = []<br/><br/>    shortpositions = []<br/><br/>    stockprices['buy'] =(stockprices['20d'] &gt; stockprices['250d'])<br/><br/>    #We find the first True since it is first day when the line has crossed. Also, ensure that we have at least two days where sticoprices<br/>    stockprices['firstbuy'] =   ((stockprices['buy'] == True) &amp; (stockprices['buy'].shift(2) == False)&amp; (stockprices['buy'].shift(1) == True))<br/><br/><br/>    buyingpoints = np.where(stockprices['firstbuy'] == True)<br/><br/>    for item in buyingpoints[0]:<br/>        #close price of the stock when MA crosses<br/>        close_price = stockprices.iloc[item].close<br/>        #Enter long position<br/>        long = close_price*100<br/>        sellday = item + 20<br/>        close_price = stockprices.iloc[sellday].close<br/>        #Sell 20 days later:<br/>        sell = close_price*100<br/><br/>        #Calculate profti<br/>        profit = sell - long<br/><br/>        longpositionsprofit.append(profit)<br/>        <br/>    #Result of Moving Average Strategy of going long<br/>    print(longpositionsprofit )<br/>    print(str(sum(longpositionsprofit)) + ' is the profit of Moving Averag Strategy')<br/><br/>    #Result of just holding the stock over 1200 days<br/>    firstdayprice = stockprices.iloc[0].close<br/>    lastdayprice = stockprices.iloc[-1].close<br/><br/>    profit = 100*(lastdayprice - firstdayprice)<br/>    print(str(profit) + ' is the profit of holding over the selected period of 1200 days')<br/><br/><br/>#Change apple for the ticker of any company you want to backtest<br/>stockpriceanalysis('AAPL')</span></pre></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><p id="e610" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nj">原载于2020年3月8日https://codingandfun.com</em><em class="nj"/><a class="ae lb" href="https://codingandfun.com/backtesting-with-python/" rel="noopener ugc nofollow" target="_blank"><em class="nj">。</em></a></p></div></div>    
</body>
</html>