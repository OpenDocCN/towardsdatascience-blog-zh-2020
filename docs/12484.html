<html>
<head>
<title>PyCaret 2.1 is here — What’s new?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PyCaret 2.1 已经发布了，有什么新内容吗？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/pycaret-2-1-is-here-whats-new-4aae6a7f636a?source=collection_archive---------8-----------------------#2020-08-28">https://towardsdatascience.com/pycaret-2-1-is-here-whats-new-4aae6a7f636a?source=collection_archive---------8-----------------------#2020-08-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/3c68ba7ee153a65dbc070dc6e51ace86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OYS6O-iLkoE88fBbd3IKcw.jpeg"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">PyCaret 2.1 现在可以使用 pip 下载。<a class="ae jd" href="https://www.pycaret.org" rel="noopener ugc nofollow" target="_blank">https://www.pycaret.org</a></p></figure><div class=""/><p id="6bf6" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们很高兴宣布 py caret 2.1—2020 年 8 月的更新。</p><p id="bed2" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">PyCaret 是一个用 Python 编写的开源、<strong class="kf jh">低代码</strong>机器学习库，可以自动化机器学习工作流。它是一个端到端的机器学习和模型管理工具，可以加快机器学习实验周期，让您的工作效率提高 10 倍。</p><p id="d9c1" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与其他开源机器学习库相比，PyCaret 是一个替代的低代码库，可以用来替换数百行代码。这使得实验快速有效。</p><p id="2b10" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你以前没有听说过或使用过 PyCaret，请查看我们的<a class="ae jd" rel="noopener" target="_blank" href="/announcing-pycaret-2-0-39c11014540e">之前的公告</a>快速入门。</p><h1 id="a492" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">正在安装 PyCaret</h1><p id="eafc" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">安装 PyCaret 非常容易，只需要几分钟。我们强烈建议使用虚拟环境来避免与其他库的潜在冲突。参见下面的示例代码，创建一个<strong class="kf jh"> <em class="me"> conda 环境</em> </strong>并在该 conda 环境中安装 pycaret:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="2558" class="mo lc jg mk b gy mp mq l mr ms"><strong class="mk jh"># create a conda environment </strong><br/>conda create --name yourenvname python=3.6  </span><span id="f6f5" class="mo lc jg mk b gy mt mq l mr ms"><strong class="mk jh"># activate environment </strong><br/>conda activate yourenvname  </span><span id="3c2b" class="mo lc jg mk b gy mt mq l mr ms"><strong class="mk jh"># install pycaret </strong><br/>pip install pycaret<strong class="mk jh"> </strong></span><span id="f10e" class="mo lc jg mk b gy mt mq l mr ms"><strong class="mk jh"># create notebook kernel linked with the conda environment <br/></strong>python -m<strong class="mk jh"> </strong>ipykernel install --user --name yourenvname --display-name "display-name"</span></pre><p id="2506" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您已经安装了 PyCaret，您可以使用 pip 更新它:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="f3da" class="mo lc jg mk b gy mp mq l mr ms">pip install --upgrade pycaret</span></pre><h1 id="d6d1" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak"> PyCaret 2.1 功能概述</strong></h1><figure class="mf mg mh mi gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mu"><img src="../Images/42cb027a6784a8d3205cf6ca84dfb9a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cf_p85-ytqAWXneJ"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">由<a class="ae jd" href="https://unsplash.com/@pawel_czerwinski?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">paweczerwiński</a>在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="3450" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">👉GPU 上的超参数调整</h1><p id="9da5" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在 PyCaret 2.0 中，我们宣布了针对某些算法(XGBoost、LightGBM 和 Catboost)的支持 GPU 的培训。2.1 中的新功能是现在你还可以在 GPU 上调整这些模型的超参数。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="5267" class="mo lc jg mk b gy mp mq l mr ms"><strong class="mk jh"># train xgboost using gpu</strong><br/>xgboost = create_model('xgboost', tree_method = 'gpu_hist')</span><span id="b803" class="mo lc jg mk b gy mt mq l mr ms"><strong class="mk jh"># tune xgboost <br/></strong>tuned_xgboost<strong class="mk jh"> = </strong>tune_model(xgboost)</span></pre><p id="9088" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<strong class="kf jh"> tune_model </strong>函数中不需要额外的参数，因为它自动从使用<strong class="kf jh"> create_model </strong>函数创建的 xgboost 实例中继承 tree_method。如果你对小比较感兴趣，这里是:</p><blockquote class="mv mw mx"><p id="7fb8" class="kd ke me kf b kg kh ki kj kk kl km kn my kp kq kr mz kt ku kv na kx ky kz la ij bi translated"><strong class="kf jh"> 100，000 行，88 个特征，8 个类的多类问题</strong></p></blockquote><figure class="mf mg mh mi gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nb"><img src="../Images/c7cc550598a3e212763a92ea7d178674.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1lAya7O3sEad9-epPH1sUw.jpeg"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">GPU 上的 XGBoost 培训(使用 Google Colab)</p></figure><h1 id="eb87" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">👉模型部署</h1><p id="a383" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">自从 2020 年 4 月 PyCaret 的第一次发布以来，您可以简单地使用笔记本上的<strong class="kf jh"> </strong>中的<strong class="kf jh"> deploy_model </strong>在 AWS 上部署训练好的模型。在最近的版本中，我们增加了一些功能来支持在 GCP 和微软 Azure 上的部署。</p><h2 id="9627" class="mo lc jg bd ld nc nd dn lh ne nf dp ll ko ng nh lp ks ni nj lt kw nk nl lx nm bi translated"><strong class="ak">微软 Azure </strong></h2><p id="480a" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">若要在 Microsoft Azure 上部署模型，必须设置连接字符串的环境变量。可以从 Azure 中您的存储帐户的“访问密钥”中获取连接字符串。</p><figure class="mf mg mh mi gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nn"><img src="../Images/f41dd16b324137b12e105441e3dec242.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XPH0ZtRmQkRxVHiqEMLaIw.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">https:/portal . azure . com-从存储帐户获取连接字符串</p></figure><p id="f3e8" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦复制了连接字符串，就可以将其设置为环境变量。请参见下面的示例:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="8368" class="mo lc jg mk b gy mp mq l mr ms"><strong class="mk jh">import os<br/></strong>os.environ['AZURE_STORAGE_CONNECTION_STRING'] = 'your-conn-string'</span><span id="42a7" class="mo lc jg mk b gy mt mq l mr ms"><strong class="mk jh">from pycaret.classification import deploy_model</strong><br/>deploy_model(model = model, model_name = 'model-name', platform = 'azure', authentication = {'container' : 'container-name'})</span></pre><p id="5b3e" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">嘣！就是这样。只需使用一行代码<strong class="kf jh">，</strong>你的整个机器学习管道现在就装在微软 Azure 的容器里了。您可以使用<strong class="kf jh"> load_model </strong>函数来访问它。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="6b80" class="mo lc jg mk b gy mp mq l mr ms"><strong class="mk jh">import os<br/></strong>os.environ['AZURE_STORAGE_CONNECTION_STRING'] = 'your-conn-string'</span><span id="b5e3" class="mo lc jg mk b gy mt mq l mr ms"><strong class="mk jh">from pycaret.classification import load_model<br/></strong>loaded_model = load_model(model_name = 'model-name', platform = 'azure', authentication = {'container' : 'container-name'})</span><span id="d8d1" class="mo lc jg mk b gy mt mq l mr ms"><strong class="mk jh">from pycaret.classification import predict_model<br/></strong>predictions = predict_model(loaded_model, data = new-dataframe)</span></pre><h2 id="cdca" class="mo lc jg bd ld nc nd dn lh ne nf dp ll ko ng nh lp ks ni nj lt kw nk nl lx nm bi translated">谷歌云平台</h2><p id="bd47" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">要在 Google Cloud Platform (GCP)上部署模型，您必须首先使用命令行或 GCP 控制台创建一个项目。创建项目后，您必须创建一个服务帐户，并以 JSON 文件的形式下载服务帐户密钥，然后用它来设置环境变量。</p><figure class="mf mg mh mi gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi no"><img src="../Images/80c8afb7b72f587769c4034b3d89bdb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nN6uslyOixxmYpFcVel8Bw.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">创建新的服务帐户，并从 GCP 控制台下载 JSON</p></figure><p id="6a3f" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要了解更多关于创建服务账户的信息，请阅读<a class="ae jd" href="https://cloud.google.com/docs/authentication/production" rel="noopener ugc nofollow" target="_blank">官方文档</a>。一旦创建了服务帐户并从 GCP 控制台下载了 JSON 文件，就可以开始部署了。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="5a91" class="mo lc jg mk b gy mp mq l mr ms"><strong class="mk jh">import os<br/></strong>os.environ['GOOGLE_APPLICATION_CREDENTIALS'] = 'c:/path-to-json-file.json'</span><span id="4c32" class="mo lc jg mk b gy mt mq l mr ms"><strong class="mk jh">from pycaret.classification import deploy_model<br/></strong>deploy_model(model = model, model_name = 'model-name', platform = 'gcp', authentication = {'project' : 'project-name', 'bucket' : 'bucket-name'})</span></pre><p id="91f5" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">模型已上传。现在，您可以使用<strong class="kf jh"> load_model </strong>函数从 GCP 存储桶访问模型。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="bb95" class="mo lc jg mk b gy mp mq l mr ms"><strong class="mk jh">import os<br/></strong>os.environ['GOOGLE_APPLICATION_CREDENTIALS'] = 'c:/path-to-json-file.json'</span><span id="ce3d" class="mo lc jg mk b gy mt mq l mr ms"><strong class="mk jh">from pycaret.classification import load_model<br/></strong>loaded_model = load_model(model_name = 'model-name', platform = 'gcp', authentication = {'project' : 'project-name', 'bucket' : 'bucket-name'})</span><span id="cfb1" class="mo lc jg mk b gy mt mq l mr ms"><strong class="mk jh">from pycaret.classification import predict_model<br/></strong>predictions = predict_model(loaded_model, data = new-dataframe)</span></pre><h1 id="c82a" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">👉MLFlow 部署</h1><p id="08a9" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">除了使用 PyCaret 的本地部署功能，您现在还可以使用所有 MLFlow 部署功能。要使用这些，您必须使用<strong class="kf jh">设置</strong>功能中的<strong class="kf jh"> log_experiment </strong>参数记录您的实验。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="c73e" class="mo lc jg mk b gy mp mq l mr ms"><strong class="mk jh"># init setup</strong><br/>exp1 = setup(data, target = 'target-name', log_experiment = True, experiment_name = 'exp-name')</span><span id="cfad" class="mo lc jg mk b gy mt mq l mr ms"><strong class="mk jh"># create xgboost model<br/></strong>xgboost = create_model('xgboost')</span><span id="e284" class="mo lc jg mk b gy mt mq l mr ms">..<br/>..<br/>..</span><span id="50fa" class="mo lc jg mk b gy mt mq l mr ms"># rest of your script</span><span id="997e" class="mo lc jg mk b gy mt mq l mr ms"><strong class="mk jh"># start mlflow server on localhost:5000</strong><br/>!mlflow ui</span></pre><p id="14eb" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在在你喜欢的浏览器上打开<a class="ae jd" href="https://localhost:5000" rel="noopener ugc nofollow" target="_blank"> https://localhost:5000 </a>。</p><figure class="mf mg mh mi gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi np"><img src="../Images/c6f5dfacbf6cc8779e3891e9d6302da5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y0nMOMuDeMS1sdFepDngKw.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated"><a class="ae jd" href="https://localhost:5000" rel="noopener ugc nofollow" target="_blank"> https://localhost:5000 </a>上的 MLFlow UI</p></figure><p id="59df" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">点击<strong class="kf jh">【运行名称】</strong>左侧的<strong class="kf jh">【开始时间】</strong>，可以看到运行的详细信息。你在里面看到的是一个训练模型的所有超参数和评分指标，如果你向下滚动一点，所有的工件也会显示出来(见下文)。</p><figure class="mf mg mh mi gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nq"><img src="../Images/d091796efeca521dc153fdba0095490d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NS7ifCnHHKRpLHCWeYhNZg.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">MLFLow 伪影</p></figure><p id="cb16" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">经过训练的模型以及其他元数据文件存储在“/model”目录下。MLFlow 遵循包装机器学习模型的标准格式，这些模型可用于各种下游工具中——例如，通过 REST API 或 Apache Spark 上的批处理推理进行实时服务。如果您愿意，您可以使用 MLFlow 命令行在本地为该模型提供服务。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="53f5" class="mo lc jg mk b gy mp mq l mr ms">mlflow models serve -m local-path-to-model</span></pre><p id="2d9b" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，您可以使用 CURL 将请求发送给 model 以获得预测。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="e4c1" class="mo lc jg mk b gy mp mq l mr ms">curl <a class="ae jd" href="http://127.0.0.1:5000/invocations" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:5000/invocations</a> -H 'Content-Type: application/json' -d '{<br/>    "columns": ["age", "sex", "bmi", "children", "smoker", "region"],<br/>    "data": [[19, "female", 27.9, 0, "yes", "southwest"]]<br/>}'</span></pre><p id="28cb" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="me">(注意:Windows 操作系统尚不支持 MLFlow 的这一功能)。</em></p><p id="fa19" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">MLFlow 还提供与 AWS Sagemaker 和 Azure 机器学习服务的集成。您可以使用 SageMaker 兼容环境在 Docker 容器中本地训练模型，或者在 SageMaker 上远程训练模型。要远程部署到 SageMaker，您需要设置您的环境和 AWS 用户帐户。</p><p id="cd5c" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">使用 MLflow CLI 的示例工作流</strong></p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="bd63" class="mo lc jg mk b gy mp mq l mr ms">mlflow sagemaker build-and-push-container <br/>mlflow sagemaker run-local -m &lt;path-to-model&gt;<br/>mlflow sagemaker deploy &lt;parameters&gt;</span></pre><p id="c789" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要了解有关 MLFlow 所有部署功能的更多信息，<a class="ae jd" href="https://www.mlflow.org/docs/latest/models.html#" rel="noopener ugc nofollow" target="_blank">请单击此处</a>。</p><h1 id="8e90" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">👉MLFlow 模型注册表</h1><p id="7fc4" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">MLflow 模型注册组件是一个集中式模型存储、一组 API 和 UI，用于协作管理 MLflow 模型的整个生命周期。它提供了模型沿袭(MLflow 实验和运行产生了模型)、模型版本化、阶段转换(例如从阶段转换到生产)和注释。</p><p id="e6d3" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果运行您自己的 MLflow 服务器，您必须使用数据库支持的后端存储来访问模型注册表。<a class="ae jd" href="https://www.mlflow.org/docs/latest/tracking.html#backend-stores" rel="noopener ugc nofollow" target="_blank">点击此处</a>了解更多信息。然而，如果你使用的是<a class="ae jd" href="https://databricks.com/" rel="noopener ugc nofollow" target="_blank"> Databricks </a>或者任何托管的 Databricks 服务，比如<a class="ae jd" href="https://azure.microsoft.com/en-ca/services/databricks/" rel="noopener ugc nofollow" target="_blank"> Azure Databricks </a>，你不需要担心设置什么。它配有你所需要的所有铃铛和哨子。</p><figure class="mf mg mh mi gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nr"><img src="../Images/27ab54e7016ad97922df9824515fc127.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*XlT58YrFuszGb-1PIXvKZw.gif"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated"><a class="ae jd" href="https://databricks.com/blog/2020/06/25/announcing-mlflow-model-serving-on-databricks.html" rel="noopener ugc nofollow" target="_blank">https://data bricks . com/blog/2020/06/25/announcing-ml flow-model-serving-on-data bricks . html</a></p></figure><h1 id="4df2" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">👉高分辨率绘图</h1><p id="4eea" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">这并不是突破性的，但对于使用 PyCaret 进行研究和发表文章的人来说，确实是一个非常有用的补充。<strong class="kf jh"> plot_model </strong>现在有一个名为“scale”的附加参数，通过它您可以控制分辨率并为您的出版物生成高质量的绘图。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="1ec5" class="mo lc jg mk b gy mp mq l mr ms"><strong class="mk jh"># create linear regression model</strong><br/>lr = create_model('lr')</span><span id="1f4c" class="mo lc jg mk b gy mt mq l mr ms"><strong class="mk jh"># plot in high-quality resolution<br/></strong>plot_model(lr, scale = 5) # default is 1</span></pre><figure class="mf mg mh mi gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ns"><img src="../Images/dd58173a94e3f8b6e0d517927ea000ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O413K8IUvgYTgD3aTtcYjw.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">PyCaret 的高分辨率残差图</p></figure><h1 id="196a" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">👉用户定义的损失函数</h1><p id="1703" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">这是自第一版发布以来最受欢迎的特性之一。允许使用自定义/用户定义的函数调整模型的超参数为数据科学家提供了巨大的灵活性。现在可以通过使用<strong class="kf jh"> tune_model </strong>函数中的<strong class="kf jh"> custom_scorer </strong>参数来使用用户自定义损失函数。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="f9e2" class="mo lc jg mk b gy mp mq l mr ms"><strong class="mk jh"># define the loss function</strong><br/>def my_function(y_true, y_pred):<br/>...<br/>...</span><span id="fd8b" class="mo lc jg mk b gy mt mq l mr ms"><strong class="mk jh"># create scorer using sklearn</strong><br/>from sklearn.metrics import make_scorer<strong class="mk jh"><br/></strong>my_own_scorer = make_scorer(my_function, needs_proba=True)</span><span id="4641" class="mo lc jg mk b gy mt mq l mr ms"><strong class="mk jh"># train catboost model<br/></strong>catboost = create_model('catboost')</span><span id="d5df" class="mo lc jg mk b gy mt mq l mr ms"><strong class="mk jh"># tune catboost using custom scorer<br/></strong>tuned_catboost = tune_model(catboost, custom_scorer = my_own_scorer)</span></pre><h1 id="8d75" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">👉特征选择</h1><p id="c062" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">特征选择是机器学习中的一个基本步骤。您丢弃了一堆特征，并且希望只选择相关的特征，而丢弃其他的特征。目的是通过去除会引入不必要噪声的无用特征来简化问题。</p><p id="221e" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在 PyCaret 2.1 中，我们介绍了用 Python 实现 Boruta 算法(最初用 R 实现)。Boruta 是一种非常智能的算法，可以追溯到 2010 年，旨在自动对数据集执行特征选择。要使用它，你只需在<strong class="kf jh">设置</strong>函数中传递<strong class="kf jh">特征选择方法</strong>。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="2792" class="mo lc jg mk b gy mp mq l mr ms">exp1 = setup(data, target = 'target-var', feature_selection = True, feature_selection_method = 'boruta')</span></pre><p id="07dd" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要阅读更多关于 Boruta 算法的内容，请点击这里。</p><h1 id="8456" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">👉其他变化</h1><ul class=""><li id="4f17" class="nt nu jg kf b kg lz kk ma ko nv ks nw kw nx la ny nz oa ob bi translated"><code class="fe oc od oe mk b">compare_models</code>功能中的<code class="fe oc od oe mk b">blacklist</code>和<code class="fe oc od oe mk b">whitelist</code>参数现更名为<code class="fe oc od oe mk b">exclude</code>和<code class="fe oc od oe mk b">include</code>，功能不变。</li><li id="f6c0" class="nt nu jg kf b kg of kk og ko oh ks oi kw oj la ny nz oa ob bi translated">为了在<code class="fe oc od oe mk b">compare_models</code>功能中设置训练时间的上限，增加了新参数<code class="fe oc od oe mk b">budget_time</code>。</li><li id="aec8" class="nt nu jg kf b kg of kk og ko oh ks oi kw oj la ny nz oa ob bi translated">PyCaret 现在与 Pandas 分类数据类型兼容。在内部，它们被转换成对象，并以与处理<code class="fe oc od oe mk b">object</code>或<code class="fe oc od oe mk b">bool</code>相同的方式进行处理。</li><li id="c86a" class="nt nu jg kf b kg of kk og ko oh ks oi kw oj la ny nz oa ob bi translated">在<code class="fe oc od oe mk b">setup</code>功能的<code class="fe oc od oe mk b">numeric_imputation</code>中添加了数字插补新方法<code class="fe oc od oe mk b">zero</code>。当方法设置为<code class="fe oc od oe mk b">zero</code>时，缺失值被常量 0 替换。</li><li id="4dda" class="nt nu jg kf b kg of kk og ko oh ks oi kw oj la ny nz oa ob bi translated">为了使输出更易于阅读，由<code class="fe oc od oe mk b">predict_model</code>函数返回的<code class="fe oc od oe mk b">Label</code>列现在返回原始值，而不是编码值。</li></ul><p id="d6b7" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要了解 PyCaret 2.1 中所有更新的更多信息，请参见<a class="ae jd" href="https://github.com/pycaret/pycaret/releases/tag/2.1" rel="noopener ugc nofollow" target="_blank">发布说明</a>。</p><p id="1320" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用 Python 中的轻量级工作流自动化库，您可以实现的目标是无限的。如果你觉得这有用，请不要忘记给我们 GitHub repo 上的⭐️。</p><p id="0c6b" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">想了解更多关于 PyCaret 的信息，请关注我们的 LinkedIn 和 Youtube。</p><h1 id="95ae" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">重要链接</h1><p id="9680" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><a class="ae jd" href="https://www.pycaret.org/guide" rel="noopener ugc nofollow" target="_blank">用户指南</a> <br/> <a class="ae jd" href="https://pycaret.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">文档</a> <br/> <a class="ae jd" href="https://github.com/pycaret/pycaret/tree/master/tutorials" rel="noopener ugc nofollow" target="_blank">官方教程<br/> </a> <a class="ae jd" href="https://github.com/pycaret/pycaret/tree/master/examples" rel="noopener ugc nofollow" target="_blank">示例笔记本</a> <br/> <a class="ae jd" href="https://github.com/pycaret/pycaret/tree/master/resources" rel="noopener ugc nofollow" target="_blank">其他资源</a></p><h1 id="d31c" class="lb lc jg bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">想了解某个特定模块？</h1><p id="c45e" class="pw-post-body-paragraph kd ke jg kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">单击下面的链接查看文档和工作示例。</p><p id="6f7c" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae jd" href="https://www.pycaret.org/classification" rel="noopener ugc nofollow" target="_blank">分类</a> <br/> <a class="ae jd" href="https://www.pycaret.org/regression" rel="noopener ugc nofollow" target="_blank">回归<br/> </a> <a class="ae jd" href="https://www.pycaret.org/clustering" rel="noopener ugc nofollow" target="_blank">聚类</a> <br/> <a class="ae jd" href="https://www.pycaret.org/anomaly-detection" rel="noopener ugc nofollow" target="_blank">异常检测<br/> </a> <a class="ae jd" href="https://www.pycaret.org/nlp" rel="noopener ugc nofollow" target="_blank">自然语言处理</a><br/>T29】关联规则挖掘</p></div></div>    
</body>
</html>