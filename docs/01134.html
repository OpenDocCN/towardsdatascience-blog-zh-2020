<html>
<head>
<title>Servitization and Queueing Theory: Deriving M/M/1 Model</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">服务化和排队论:导出M/M/1模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/servitization-and-queueing-theory-deriving-m-m-1-model-589175b23054?source=collection_archive---------19-----------------------#2020-02-01">https://towardsdatascience.com/servitization-and-queueing-theory-deriving-m-m-1-model-589175b23054?source=collection_archive---------19-----------------------#2020-02-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/12b8b86e69c15d8f6e94e36e7be392d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UZ7pulnyBJu8di8qe-WgsA.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">注意到两者的共同点了吗？两个都是队列！图片来源:<a class="ae kf" href="https://www.flickr.com/photos/psit/5605605412" rel="noopener ugc nofollow" target="_blank">https://www.flickr.com/photos/psit/5605605412</a>和<a class="ae kf" href="https://www.geograph.org.uk/photo/5831116" rel="noopener ugc nofollow" target="_blank">https://www.geograph.org.uk/photo/5831116</a></p></figure><p id="c623" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">服务化是制造企业从销售纯产品转向提供解决方案(服务)的一种现象。<a class="ae kf" href="http://andyneely.blogspot.com/2013/11/what-is-servitization.html" rel="noopener ugc nofollow" target="_blank"> Neely (2013) </a>简要介绍了各行各业的公司如何采用这种商业模式。</p><p id="df7d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有趣的是，服务化也导致制造企业和服务企业之间的界限变得不那么清晰。事实上，我们可以看到，制造业和服务业的某些方面可以抽象成类似的数学概念。比如，把一条流水线比作一群排队买食物的人。请注意，两者基本上都是队列，并且通常具有相似的特征(吞吐量或卖家服务客户的速度、队列长度或有多少人在等待，等等)。</p><p id="6edd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我最近了解到数学中有一个分支专门研究这个问题，叫做<a class="ae kf" href="https://en.wikipedia.org/wiki/Queueing_theory" rel="noopener ugc nofollow" target="_blank">排队论</a>。根据理论，任何队列都可以用这6个参数建模:<a class="ae kf" href="http://www.mathcs.emory.edu/~cheung/Courses/558/Syllabus/00/queueing/queueing.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu"> A | B | c | D | E | F </strong> </a>。a是到达过程，B是服务者过程，c是服务者数量，D是队列容量，E是群体大小，F是排队规则。在这篇博文中，我们将关注最简单的队列类型<strong class="ki iu"> M|M|1|∞|∞|FIFO </strong>或者通常缩写为<strong class="ki iu"> M|M|1 </strong>。</p><h1 id="569e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><strong class="ak"> M|M|1 </strong>型号</h1><p id="9a8c" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">想象一个无限容量的队列(<strong class="ki iu"> ∞ </strong>)，也就是说，等待的长度没有限制。假设人口规模也是无限的(∞)，即潜在客户的数量是无限的。顾客是在先进先出(<strong class="ki iu"> FIFO </strong>)的基础上得到服务的。让我们假设我们正在运行一条只有一个服务器的生产线(<strong class="ki iu"> 1 </strong>)，例如，想象一辆有一条队列的基本食品卡车。然后，我们可以用速率为λ ( <strong class="ki iu"> M </strong>)的泊松过程对客户到达率进行建模。我们还假设我们的服务时间是指数分布的，因此也可以用速率为μ ( <strong class="ki iu"> M </strong>)的泊松过程建模。</p><p id="7d2b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们把这个过程表示为马尔可夫链。状态(节点)表示队列中有多少物品，而转移率表示接收/服务客户的概率。例如，S2表示在该州的队列中有2个项目。因为只有一台服务器，所以只能一个接一个地顺序处理项目。λ的到达率意味着平均在1个时间单位内，将有λ个项目到达队列。μ的服务率意味着平均来说，在1个时间单位内，μ个项目将被服务并因此从队列中移除。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mh"><img src="../Images/8484f12257b901e7799c6c4465f9795c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IZI1QLCWKiwQgMsUPFCZCw.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">M/M/1排队马尔可夫链</p></figure><p id="7413" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设到达和服务同步发生，即我们在h的同一时间窗内从一个状态移动到另一个状态，马尔可夫转移概率可以这样写。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mm"><img src="../Images/00ff4508381c0c0a13d7335c3aec879f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WajfL0SIEftIw5s26lFY-A.png"/></div></div></figure><p id="dbba" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的目标是只根据λ和μ(不考虑初始状态是什么)，计算长期处于任何状态Sn的概率。</p><p id="9f2a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要做到这一点，我们必须首先对n = 0的P(Sn)进行边缘化。我们可以用两种方式边缘化P(Sn ),要么是相对于先前的状态，要么是相对于随后的状态。请注意，S0有1个前一状态(s 1)和1个后一状态(S1)。只有从长远来看，这才是正确的。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mn"><img src="../Images/6f92667042ecedb5e01f23ba31fa9c40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oqJO-XaE7AGtDbtYE8YZXA.png"/></div></div></figure><p id="6883" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">经过替换和重新排列，我们得到了P(S1)和P(S0)之间的关系。对于其他n &gt; 0，我们现在对P(Sn)执行相同的边缘化。在这种情况下，Sn具有2个先前状态(Sn-1，Sn+1)和2个后续状态(Sn-1，Sn+1)。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mo"><img src="../Images/e948edbee2b5bb77eb7d81db1516b596.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X9R-2gkjQ3xG1ANeCAj_aA.png"/></div></div></figure><p id="43ee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们现在有了一个关于P(Sn+1)，P(Sn)和P(Sn-1)的等式。我们可以计算出n=2时的这个值。用我们以前得到的结果代替P(S1)得到下面的等式。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mp"><img src="../Images/cf82380bc0af6af4c491a23caea188f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*qcWFdVFqSVjhasVTK1RW6Q.png"/></div></div></figure><p id="714d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们可以对更高的n值做同样的替换和重排，得到如下迭代方程(需要更严格的证明；我们将在本帖中跳过这一点)。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/102074b90cdb2c0b681e1fdaefb731ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:506/format:webp/1*gSwnDV7nAPBVCbAdtJriug.png"/></div></figure><p id="3e8b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们快到了！唯一的问题是我们还有一个未知项P(S0)。好消息是，我们也可以基于λ和μ来表征P(S0)。为此，我们将利用概率的和性质，即所有状态的概率之和等于1。因为我们有无限多的可能状态，求和项趋于无穷大。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/30fd8e489c305af9cbf1fed07ac14e02.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*75P54pMprluggaZ4uCceNQ.png"/></div></figure><p id="59dd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该等式表明，只有当到达率小于服务率时，和的收敛才成立。直观地说，这意味着只有当我们能够以比客户到达速度更快的速度服务客户时，我们才会有一个正常工作的队列。否则，队列将无限增长。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ms"><img src="../Images/bb911947df38b55d6ae6df67d0a85c5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*IjOK97iJNHOSkEPsxBt_Og.png"/></div></div></figure><p id="a282" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们现在可以根据λ和μ来刻画P(S0)的特征。将该值代入P(Sn)的迭代方程，得到以下结果。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/c9e959db6ed0dfe069968d21d0091890.png" data-original-src="https://miro.medium.com/v2/resize:fit:712/format:webp/1*ku6cV76h3kyDIRcbenN5fA.png"/></div></figure><p id="26f8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们已经实现了最初的目标，即仅根据到达率和服务率来衡量处于任何状态的概率。</p><h1 id="d514" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">那又怎样？</h1><p id="5515" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">有了这个模型，我们可以回到我们最初的问题，并试图回答它们。举个例子，</p><blockquote class="mu mv mw"><p id="92b8" class="kg kh mx ki b kj kk kl km kn ko kp kq my ks kt ku mz kw kx ky na la lb lc ld im bi translated">假设我们每周三开一辆快餐车。在过去的几个月里，我们已经大致了解了顾客来的频率以及我们能以多快的速度为他们服务。使用我们新学到的排队论知识，我们现在可以估计我们的队列平均有多长。然后，我们可以将这个数字与我们操作的场地大小进行比较，看看是否有足够的空间让人们排队。我们还可以决定我们应该在加快服务时间以减少排队长度方面进行多少投资。</p></blockquote><p id="69f8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个用例在数学上等同于计算队列n中的预期项目数。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/5f953ac145e91d48aef7f1279f506df4.png" data-original-src="https://miro.medium.com/v2/resize:fit:712/format:webp/1*kVVyXFyy_i_yNCld-6jXwg.png"/></div></figure><p id="8917" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不幸的是，等式中有一个无穷和项。为了找出这相当于什么(再次假设λ &lt; μ), we’ll make use of the derivation of a geometric series sum.</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/a428eda913bfe6eb1dcc09f84ecf1864.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/format:webp/1*OZTb9fh43uFEkiwe-R-g4g.png"/></div></figure><p id="a2b8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">We can now substitute this to the original equation, resulting in an expected value that is characterised based on λ and μ alone.</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/b2895bb073079ad70902df397a2ce9d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:752/format:webp/1*J0ZLrN_F1JbWRjEMU7dyOQ.png"/></div></figure><p id="bf84" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Let’s return to our food truck example. Suppose 4 customers arrive per hour to our food truck and we have enough capacity to serve 6 of them per hour. Using the above equation, we can calculate the expected number of people in our queue across time.</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/e7b15c8d26b6ddf1febbad6d3a0f3c2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*jPdvX9Pq25HXGF9YdtXUvw.png"/></div></figure><p id="6fa2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">On average, we expect 2 people to queue in our waiting line. We can calculate also calculate <a class="ae kf" href="https://uk.mathworks.com/help/simevents/examples/m-m-1-queuing-system.html" rel="noopener ugc nofollow" target="_blank">更多的KPI</a>如服务器利用率、平均等待时间、平均排队时间都基于λ和μ)。</p><h1 id="5933" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><strong class="ak">结论</strong></h1><p id="0c7b" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们已经看到了排队论是如何帮助我们描述排队等候的特点的。制造业和服务业都可以使用这种数学抽象。在实践中，我们可能希望用更现实的参数来建模我们的队列，例如，我们可以有多个服务器，而不是一个服务器；或者我们可以假设容量有限而不是无限。然后，该模型可以提供关于如何改进排队系统的管理见解。</p><p id="c656" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">主要的限制是对到达和服务过程有很强的假设。在这种情况下，我们假设泊松过程，但更好的方法是更加数据驱动，看看哪个分布更适合。请记住，使用参数分布(无论是泊松分布还是其他分布)需要完全理解每个模型假设的潜在前提。</p></div></div>    
</body>
</html>