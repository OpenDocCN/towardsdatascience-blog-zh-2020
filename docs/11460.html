<html>
<head>
<title>The concept of Masks in Python 2021</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 2021 中的遮罩概念</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-concept-of-masks-in-python-50fd65e64707?source=collection_archive---------2-----------------------#2020-08-09">https://towardsdatascience.com/the-concept-of-masks-in-python-50fd65e64707?source=collection_archive---------2-----------------------#2020-08-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/36f2e668591bff4b0f241c11229d9d54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eOY7DZX8u4bMRK1m"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://unsplash.com/@pillepriske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">皮勒-张力尹·普里斯克</a>在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><div class=""/><div class=""><h2 id="0bc8" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">NumPy 的一个有趣特性是过滤不需要的数据</h2></div><blockquote class="ky kz la"><p id="70fd" class="lb lc ld le b lf lg kk lh li lj kn lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">所有的男人都是雕塑家，不断凿掉他们生活中不想要的部分，试图创造出他们心目中的杰作……艾迪·墨菲</p></blockquote><p id="6a27" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">如果您想知道如何在您的数据科学项目或 Python 编程中过滤或处理不需要的、缺失的或无效的数据，那么您必须学习有用的概念<strong class="le jk">屏蔽</strong>。在这篇文章中，我将首先引导你通过一个一维数组的例子，然后是二维数组(矩阵)，然后提供一个数据科学问题中屏蔽的<strong class="le jk">应用。</strong></p><h1 id="923e" class="mb mc jj bd md me mf mg mh mi mj mk ml kp mm kq mn ks mo kt mp kv mq kw mr ms bi translated">一维数组</h1><p id="8bd0" class="pw-post-body-paragraph lb lc jj le b lf mt kk lh li mu kn lk ly mv ln lo lz mw lr ls ma mx lv lw lx im bi translated">假设我们有以下 NumPy 数组:</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="4bfa" class="nh mc jj nd b gy ni nj l nk nl">import numpy as np</span><span id="3b32" class="nh mc jj nd b gy nm nj l nk nl">arr = np.array([1, 2, 3, 4, 5, 6, 7, 8])</span></pre><p id="821d" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">现在，我们想计算小于 4 和大于 6 的元素之和。一个<strong class="le jk">繁琐的方法</strong>是使用 for 循环，检查一个数字是否满足这些条件，然后将它添加到一个变量中。这将类似于:</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="b474" class="nh mc jj nd b gy ni nj l nk nl">total = 0    # Variable to store the sum</span><span id="6ff2" class="nh mc jj nd b gy nm nj l nk nl">for num in arr:<br/>    if (num&lt;4) or (num&gt;6):<br/>        total += num</span><span id="b591" class="nh mc jj nd b gy nm nj l nk nl">print(total)<br/>&gt;&gt;&gt; 21</span></pre><p id="cb68" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">您可以使用<strong class="le jk">列表理解</strong>将这段代码简化为一行代码，</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="9da3" class="nh mc jj nd b gy ni nj l nk nl">total = sum([num for num in arr if (num&lt;4) or (num&gt;6)])<br/>&gt;&gt;&gt; 21</span></pre><p id="732c" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">使用<strong class="le jk">屏蔽</strong>的概念可以实现相同的任务。它基本上使用一个布尔值列表<strong class="le jk">(真/假)</strong>，当应用于原始数组时，返回感兴趣的元素。这里，<strong class="le jk">真</strong>是指满足条件的元素(在我们的例子中小于 4 且大于 6)，假<strong class="le jk">是指不满足条件的元素。</strong></p><p id="0204" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">让我们首先手动创建这个遮罩。</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="41ff" class="nh mc jj nd b gy ni nj l nk nl">mask = [True, True, True, False, False, False, True, True]</span></pre><p id="9d0f" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">接下来，我们使用索引将这个掩码(布尔列表)传递给我们的数组。这将只返回满足条件的元素 <strong class="le jk">。然后你可以对这个子数组求和。下面的片段解释了它。您会注意到，您没有得到 4、5 和 6，因为相应的值为<strong class="le jk">假</strong>。</strong></p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="4605" class="nh mc jj nd b gy ni nj l nk nl">arr[mask]<br/>&gt;&gt;&gt; array([1, 2, 3, 7, 8])</span><span id="8aa8" class="nh mc jj nd b gy nm nj l nk nl">arr[mask].sum()<br/>&gt;&gt;&gt; 21</span></pre></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h1 id="e497" class="mb mc jj bd md me nu mg mh mi nv mk ml kp nw kq mn ks nx kt mp kv ny kw mr ms bi translated">Numpy 的 MaskedArray 模块</h1><p id="be78" class="pw-post-body-paragraph lb lc jj le b lf mt kk lh li mu kn lk ly mv ln lo lz mw lr ls ma mx lv lw lx im bi translated">Numpy 提供了一个名为<code class="fe nz oa ob nd b">ma</code>的<strong class="le jk">内置 MaskedArray 模块</strong>。该模块的<code class="fe nz oa ob nd b">masked_array()</code>功能允许您直接创建一个“屏蔽数组”，其中不满足条件的元素将被渲染/标记为<strong class="le jk">“无效”</strong>。这是通过使用<code class="fe nz oa ob nd b">mask</code>参数实现的，该参数包含真/假或值 0/1。</p><p id="e353" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated"><strong class="le jk">注意</strong>:现在，当<code class="fe nz oa ob nd b">mask=False</code>或<code class="fe nz oa ob nd b">mask=0</code>时，字面意思是<strong class="le jk">不要</strong>将该值标记为无效。简单地说，<strong class="le jk">在计算过程中包含</strong>它。同样，<code class="fe nz oa ob nd b">mask=True</code>或<code class="fe nz oa ob nd b">mask=1</code>表示将该值标注为<strong class="le jk"> </strong>无效。相比之下，之前你看到当我们使用索引时，假值被<strong class="le jk">排除在外。</strong></p><p id="d5f9" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">因此，你现在必须在使用 <code class="fe nz oa ob nd b"><strong class="le jk">ma</strong></code> <strong class="le jk">模块</strong>的同时<strong class="le jk">交换真假值。所以，新的面具变成了</strong></p><p id="a6b7" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated"><code class="fe nz oa ob nd b">mask = [False, False, False, True, True, True, False, False]</code></p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="bc60" class="nh mc jj nd b gy ni nj l nk nl">import numpy.ma as ma</span><span id="9e38" class="nh mc jj nd b gy nm nj l nk nl">"""First create a normal Numpy array"""<br/>arr = np.array([1, 2, 3, 4, 5, 6, 7, 8])</span><span id="77cc" class="nh mc jj nd b gy nm nj l nk nl">ma_arr = ma.masked_array(arr, mask=[False, False, False, True, <br/>                                    True, True, False, False])<br/>&gt;&gt;&gt; masked_array(data=[1, 2, 3, --, --, --, 7, 8],<br/>             mask=[False, False, False,  True,  True,  True, False, <br/>                   False], fill_value=999999)<br/>ma_arr.sum()<br/>&gt;&gt;&gt; 21</span></pre><p id="4d94" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">屏蔽(无效)值现在由<code class="fe nz oa ob nd b">--</code>表示。得到的<strong class="le jk"> masked_array </strong>的形状/大小与原始数组<strong class="le jk">相同</strong>。以前，当我们使用<code class="fe nz oa ob nd b">arr[mask]</code>时，得到的数组与原始数组长度不同，因为无效元素不在输出中。这个特性允许对长度相等但掩码不同的数组进行简单的算术运算。</p><p id="802f" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">像以前一样，您也可以使用列表理解来创建遮罩。然而，因为您想要交换<strong class="le jk">真值</strong>和<strong class="le jk">假值</strong>，所以您可以使用波浪号运算符<code class="fe nz oa ob nd b">~</code>来反转布尔值。</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="7f64" class="nh mc jj nd b gy ni nj l nk nl">"""Using Tilde operator to reverse the Boolean"""<br/>ma_arr = ma.masked_array(arr, mask=[~((a&lt;4) or (a&gt;6)) for a in arr])</span><span id="413a" class="nh mc jj nd b gy nm nj l nk nl">ma_arr.sum()<br/>&gt;&gt;&gt; 21</span></pre><p id="2e61" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">也可以使用由 0 和 1 组成的掩码。</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="998b" class="nh mc jj nd b gy ni nj l nk nl">ma_arr = ma.masked_array(arr, mask=[0, 0, 0, 1, 1, 1, 0, 0])</span></pre><p id="0bab" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">根据屏蔽条件的类型，NumPy 提供了几个其他的内置屏蔽，可以避免您手动指定布尔屏蔽的任务。很少有这样的情况:</p><ul class=""><li id="8b7a" class="oc od jj le b lf lg li lj ly oe lz of ma og lx oh oi oj ok bi translated">小于(或小于等于)一个数字</li><li id="11df" class="oc od jj le b lf ol li om ly on lz oo ma op lx oh oi oj ok bi translated">大于(或大于等于)一个数字</li><li id="d8e9" class="oc od jj le b lf ol li om ly on lz oo ma op lx oh oi oj ok bi translated">在给定的范围内</li><li id="ec9d" class="oc od jj le b lf ol li om ly on lz oo ma op lx oh oi oj ok bi translated">在给定范围之外</li></ul><h2 id="5eb1" class="nh mc jj bd md oq or dn mh os ot dp ml ly ou ov mn lz ow ox mp ma oy oz mr pa bi translated"><strong class="ak">小于(或小于等于)一个数</strong></h2><p id="2e3b" class="pw-post-body-paragraph lb lc jj le b lf mt kk lh li mu kn lk ly mv ln lo lz mw lr ls ma mx lv lw lx im bi translated">功能<code class="fe nz oa ob nd b">masked_less()</code>将屏蔽/过滤数值<strong class="le jk">小于</strong>的数值。</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="9c10" class="nh mc jj nd b gy ni nj l nk nl">arr = np.array([1, 2, 3, 4, 5, 6, 7, 8])</span><span id="f8a0" class="nh mc jj nd b gy nm nj l nk nl">ma_arr = ma.masked_less(arr, 4)<br/>&gt;&gt;&gt; masked_array(data=[--, --, --, 4, 5, 6, 7, 8],<br/>                 mask=[True, True, True, False, False, False, <br/>                       False, False], fill_value=999999)</span><span id="840f" class="nh mc jj nd b gy nm nj l nk nl">ma_arr.sum()<br/>&gt;&gt;&gt; 30</span></pre><p id="1874" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">要将小于或等于的值<strong class="le jk">过滤为一个数字，使用<code class="fe nz oa ob nd b">masked_less_equal()</code>。</strong></p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h2 id="5b49" class="nh mc jj bd md oq or dn mh os ot dp ml ly ou ov mn lz ow ox mp ma oy oz mr pa bi translated"><strong class="ak">大于(或大于等于)一个数字</strong></h2><p id="85d0" class="pw-post-body-paragraph lb lc jj le b lf mt kk lh li mu kn lk ly mv ln lo lz mw lr ls ma mx lv lw lx im bi translated">我们使用函数<code class="fe nz oa ob nd b">masked_greater()</code>来过滤大于 4 的值<strong class="le jk">。</strong></p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="4ba8" class="nh mc jj nd b gy ni nj l nk nl">arr = np.array([1, 2, 3, 4, 5, 6, 7, 8])</span><span id="ee1a" class="nh mc jj nd b gy nm nj l nk nl">ma_arr = ma.masked_greater(arr, 4)</span><span id="49b5" class="nh mc jj nd b gy nm nj l nk nl">&gt;&gt;&gt; masked_array(data=[1, 2, 3, 4, --, --, --, --],<br/>                 mask=[False, False, False, False, True, True, <br/>                       True, True], fill_value=999999)</span><span id="2f4c" class="nh mc jj nd b gy nm nj l nk nl">ma_arr.sum()<br/>&gt;&gt;&gt; 10</span></pre><p id="5d7a" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">同样，<code class="fe nz oa ob nd b">masked_greater_equal()</code>将大于或等于的值<strong class="le jk">过滤为 4。</strong></p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h2 id="4d41" class="nh mc jj bd md oq or dn mh os ot dp ml ly ou ov mn lz ow ox mp ma oy oz mr pa bi translated">在给定的范围内</h2><p id="9084" class="pw-post-body-paragraph lb lc jj le b lf mt kk lh li mu kn lk ly mv ln lo lz mw lr ls ma mx lv lw lx im bi translated">函数<code class="fe nz oa ob nd b">masked_inside()</code>将屏蔽/过滤位于两个给定数值之间的值(包括两个给定数值)。以下过滤值介于 4 和 6 之间。</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="4907" class="nh mc jj nd b gy ni nj l nk nl">arr = np.array([1, 2, 3, 4, 5, 6, 7, 8])</span><span id="e81d" class="nh mc jj nd b gy nm nj l nk nl">ma_arr = ma.masked_inside(arr, 4, 6)<br/>&gt;&gt;&gt; masked_array(data=[1, 2, 3, --, --, --, 7, 8],<br/>                 mask=[False, False, False, True, True, True, <br/>                       False, False], fill_value=999999)</span><span id="704a" class="nh mc jj nd b gy nm nj l nk nl">ma_arr.sum()<br/>&gt;&gt;&gt; 21</span></pre></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h2 id="9b4f" class="nh mc jj bd md oq or dn mh os ot dp ml ly ou ov mn lz ow ox mp ma oy oz mr pa bi translated">在给定范围之外</h2><p id="8da3" class="pw-post-body-paragraph lb lc jj le b lf mt kk lh li mu kn lk ly mv ln lo lz mw lr ls ma mx lv lw lx im bi translated">函数<code class="fe nz oa ob nd b">masked_inside()</code>将屏蔽/过滤位于两个给定数值之间的值(包括两个给定数值)。以下过滤值在 4-6 之外。</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="72b5" class="nh mc jj nd b gy ni nj l nk nl">arr = np.array([1, 2, 3, 4, 5, 6, 7, 8])</span><span id="fe7d" class="nh mc jj nd b gy nm nj l nk nl">ma_arr = ma.masked_outside(arr, 4, 6)<br/>&gt;&gt;&gt; masked_array(data=[--, --, --, 4, 5, 6, --, --],<br/>                 mask=[True, True, True, False, False, False, <br/>                       True, True], fill_value=999999)</span><span id="8cb3" class="nh mc jj nd b gy nm nj l nk nl">ma_arr.sum()<br/>&gt;&gt;&gt; 15</span></pre></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h2 id="9055" class="nh mc jj bd md oq or dn mh os ot dp ml ly ou ov mn lz ow ox mp ma oy oz mr pa bi translated">算术运算期间忽略<code class="fe nz oa ob nd b">NaN</code>和/或<code class="fe nz oa ob nd b">infinite</code>值</h2><p id="3000" class="pw-post-body-paragraph lb lc jj le b lf mt kk lh li mu kn lk ly mv ln lo lz mw lr ls ma mx lv lw lx im bi translated"><strong class="le jk"> <em class="ld">这是一个很酷的功能！</em> </strong>现实的数据集往往有很多缺失值(nan)或者一些奇怪的无穷大值。这样的值在计算中会产生问题，因此要么被忽略，要么被估算。</p><p id="9c0d" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">例如，这个一维 NumPy 数组的和或平均值将是<code class="fe nz oa ob nd b">nan</code>。</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="30d2" class="nh mc jj nd b gy ni nj l nk nl">arr = np.array([1, 2, 3, np.nan, 5, 6, np.inf, 8])<br/>arr.sum()<br/>&gt;&gt;&gt; nan</span></pre><p id="71c4" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">您可以使用<code class="fe nz oa ob nd b">masked_invalid()</code>很容易地排除 NaN 和 infinite 值，这将从计算中排除这些值。这些无效值现在将被表示为<code class="fe nz oa ob nd b">--</code>。在处理数据科学问题中大型数据集中的缺失数据时，这个特性<strong class="le jk">非常有用</strong>。</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="0379" class="nh mc jj nd b gy ni nj l nk nl">ma_arr = ma.masked_invalid(arr)<br/>&gt;&gt;&gt; masked_array(data=[1.0, 2.0, 3.0, --, 5.0, 6.0, --, 8.0],<br/>                 mask=[False, False, False, True, False, False,<br/>                       True, False], fill_value=1e+20)</span><span id="53c3" class="nh mc jj nd b gy nm nj l nk nl">ma_arr.mean()<br/>&gt;&gt;&gt; 4.166666666666667</span></pre><p id="9dc1" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">假设您想用剩余有效值的平均值估算或填充这些<strong class="le jk"> NaNs </strong>或<strong class="le jk"> inf </strong>值。你可以使用<code class="fe nz oa ob nd b">filled()</code>很容易地做到这一点，</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="bab6" class="nh mc jj nd b gy ni nj l nk nl">ma_arr.filled(ma_arr.mean())<br/>&gt;&gt;&gt; [1., 2., 3., 4.16666667, 5., 6., 4.16666667, 8.]</span></pre></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h1 id="98b8" class="mb mc jj bd md me nu mg mh mi nv mk ml kp nw kq mn ks nx kt mp kv ny kw mr ms bi translated">屏蔽二维阵列(矩阵)</h1><p id="d8f0" class="pw-post-body-paragraph lb lc jj le b lf mt kk lh li mu kn lk ly mv ln lo lz mw lr ls ma mx lv lw lx im bi translated">通常，您的大数据是大型二维矩阵的形式。让我们看看如何对矩阵使用掩码。考虑下面的 3×3 矩阵。</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="1daa" class="nh mc jj nd b gy ni nj l nk nl">arr = np.array([[1, 2, 3],<br/>                [4, 5, 6],<br/>                [7, 8, 9]])</span></pre><p id="02f2" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">假设我们想计算列方向的总和，排除大于 4 的数字。<strong class="le jk">现在，我们必须使用</strong> <strong class="le jk">一个二维遮罩</strong>。如前所述，你也可以在下面使用真/假的二维遮罩。</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="09cf" class="nh mc jj nd b gy ni nj l nk nl">ma_arr = ma.masked_array(arr, mask=[[0, 0, 0],<br/>                                    [0, 1, 1],<br/>                                    [1, 1, 1]])</span><span id="58b0" class="nh mc jj nd b gy nm nj l nk nl">&gt;&gt;&gt; masked_array(data=[[1, 2, 3],<br/>                       [4, --, --],<br/>                       [--, --, --]],<br/>                 mask=[[False, False, False],<br/>                       [False, True, True],<br/>                       [True, True, True]], fill_value=999999)</span><span id="5168" class="nh mc jj nd b gy nm nj l nk nl">"""Column-wise sum is computed using the argument <!-- -->axis=0"""<br/>ma_arr.sum(axis=0)</span><span id="56c5" class="nh mc jj nd b gy nm nj l nk nl">&gt;&gt;&gt; masked_array(data=[5, 2, 3], mask=[False, False, False],<br/>                 fill_value=999999)</span></pre><p id="d0cd" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">在上面的代码中，我们使用 0 和 1 手动创建了一个二维遮罩<strong class="le jk">。通过使用与前面一维情况相同的<strong class="le jk">功能</strong>，您可以使您的生活更加轻松。这里可以用<code class="fe nz oa ob nd b">masked_greater()</code>排除大于 4 的值。</strong></p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="3c54" class="nh mc jj nd b gy ni nj l nk nl">ma_arr = ma.masked_greater(arr, 4)</span><span id="f549" class="nh mc jj nd b gy nm nj l nk nl">ma_arr.sum(axis=0)<br/>&gt;&gt;&gt; masked_array(data=[5, 2, 3], mask=[False, False, False],<br/>                 fill_value=999999)</span></pre><p id="feb0" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated"><strong class="le jk">注意:</strong>你可以使用所有的函数，前面显示的函数适用于一维，也适用于二维数组。</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h1 id="0a9a" class="mb mc jj bd md me nu mg mh mi nv mk ml kp nw kq mn ks nx kt mp kv ny kw mr ms bi translated">数据科学问题中屏蔽的使用</h1><p id="de79" class="pw-post-body-paragraph lb lc jj le b lf mt kk lh li mu kn lk ly mv ln lo lz mw lr ls ma mx lv lw lx im bi translated">任何数据科学项目的常规任务都是探索性数据分析(EDA)。这方面的一个关键步骤是可视化输入要素之间的统计关系(相关性)。例如，皮尔逊相关系数提供了两个变量之间线性相关性的度量。</p><p id="f076" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">让我们考虑一下<strong class="le jk">波士顿住房数据集</strong>并计算相关矩阵，得出范围在-1 和 1 之间的系数。</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="ac6e" class="nh mc jj nd b gy ni nj l nk nl">import pandas as pd<br/>import seaborn as sns<br/>import matplotlib.pyplot as plt<br/>from sklearn.datasets import load_boston</span><span id="687f" class="nh mc jj nd b gy nm nj l nk nl">boston = load_boston()<br/>df = pd.DataFrame(boston.data, columns=boston.feature_names)</span></pre><p id="505f" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">现在让我们使用 Seaborn 库绘制相关矩阵。</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="d0b1" class="nh mc jj nd b gy ni nj l nk nl">correlation = df.corr()</span><span id="e52e" class="nh mc jj nd b gy nm nj l nk nl">ax = sns.heatmap(data=correlation, cmap='coolwarm', <br/>                 linewidths=2, cbar=True)</span></pre><figure class="my mz na nb gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pb"><img src="../Images/81ae9cac56bdfb7e0418059b8a50088a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kPvNF83RE3y9Pyt9Qp4PSg.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">波士顿住房数据集的输入要素的相关矩阵。</p></figure><p id="5f75" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">现在，假设您想要突出显示或轻松区分<strong class="le jk">绝对相关性超过 70%的值，即 0.7 </strong>。上面介绍的掩蔽概念在这里发挥了作用。您可以使用前面解释过的<code class="fe nz oa ob nd b">masked_outside()</code>函数来屏蔽您需要的值，并在 Seaborn 图中使用特殊颜色突出显示它们。</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="9527" class="nh mc jj nd b gy ni nj l nk nl">correlation = df.corr()</span><span id="53e8" class="nh mc jj nd b gy nm nj l nk nl">"""Create a mask for abs(corr) &gt; 0.7"""<br/>corr_masked = ma.masked_outside(np.array(correlation), -0.7, 0.7)</span><span id="65b6" class="nh mc jj nd b gy nm nj l nk nl">"""Set gold color for the masked/bad values"""<br/>cmap = plt.get_cmap('coolwarm') <br/>cmap.set_bad('gold')</span><span id="fbba" class="nh mc jj nd b gy nm nj l nk nl">ax = sns.heatmap(data=correlation, cmap=cmap, <br/>                 mask=corr_masked.mask, <br/>                 linewidths=2, cbar=True)</span></pre><figure class="my mz na nb gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pc"><img src="../Images/5a1bcf3d8c7861880a7dad16911e806f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MpAGZT2L0tSen97B0ZogyA.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">波士顿住房数据集的相关矩阵，其中掩膜值以金色高亮显示。</p></figure></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><p id="84a9" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">这就是我这篇文章的结尾。如果您想用即将发布的 Python 3.10 版本和 Matplotlib 3 中的最新特性来更新自己，请阅读我的以下文章。</p><div class="is it gp gr iu pd"><a rel="noopener follow" target="_blank" href="/python-in-2021-timeline-and-upcoming-features-c8369abbcc52"><div class="pe ab fo"><div class="pf ab pg cl cj ph"><h2 class="bd jk gy z fp pi fr fs pj fu fw ji bi translated">2021 年的 Python 时间表和即将推出的功能</h2><div class="pk l"><h3 class="bd b gy z fp pi fr fs pj fu fw dk translated">Python 3.10 的一些新特性的预览</h3></div><div class="pl l"><p class="bd b dl z fp pi fr fs pj fu fw dk translated">towardsdatascience.com</p></div></div><div class="pm l"><div class="pn l po pp pq pm pr ja pd"/></div></div></a></div><div class="is it gp gr iu pd"><a rel="noopener follow" target="_blank" href="/whats-new-in-matplotlib-3-1b3b03f18ddc"><div class="pe ab fo"><div class="pf ab pg cl cj ph"><h2 class="bd jk gy z fp pi fr fs pj fu fw ji bi translated">Matplotlib 3 的新特性</h2><div class="pk l"><h3 class="bd b gy z fp pi fr fs pj fu fw dk translated">第 3 代中最重要的更新概述</h3></div><div class="pl l"><p class="bd b dl z fp pi fr fs pj fu fw dk translated">towardsdatascience.com</p></div></div><div class="pm l"><div class="ps l po pp pq pm pr ja pd"/></div></div></a></div></div></div>    
</body>
</html>