<html>
<head>
<title>Customize Classification Model Output Layer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自定义分类模型输出层</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/customize-classification-model-output-layer-46355a905b86?source=collection_archive---------24-----------------------#2020-03-11">https://towardsdatascience.com/customize-classification-model-output-layer-46355a905b86?source=collection_archive---------24-----------------------#2020-03-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7872" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用Keras在自定义层中保存分类标签和最高机密</h2></div><p id="6fc4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">图像分类是深度学习应用的手册示例。制作分类模型的标准方法包括预处理步骤，在该步骤中，人类可读的类标签(例如:“汽车”、“人”、“猫”)被改变成机器可用的数字(例如:0，1，2)。最常见的方法是将可能的类列表与它们的索引进行映射。当然，这也需要一个后处理步骤，将结果转换成预期的形式。一种常见的方法是存储具有最高分数的类的标签和分数(对此广泛使用的术语是<em class="lb">置信度</em>)。</p><p id="4c83" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个故事中，我将展示一个在模型末尾使用自定义图层在模型中存储标签的示例。我的模型的首选输出是前<em class="lb"> k </em>标签及其置信度得分的列表。格式化的输出在产品是模型的生产中是有用的，并且标签必须存储在模型中。或者，当标签列表随着模型的每次迭代而改变时。</p><p id="44ad" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lc ld le lf b">Input: image(W,H,C)<br/>Outputs: labels(k) string, confidences(k) float</code></p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/baf80bab71e7fd4f4ec6893995091bbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*reZuS24UkvCBVyePshMs3Q.jpeg"/></div></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">照片由<a class="ae lw" href="https://unsplash.com/@rangel?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">大卫·兰格尔</a>在<a class="ae lw" href="https://unsplash.com/s/photos/programming?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="fa59" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">训练分类模型</h1><p id="e6b4" class="pw-post-body-paragraph kf kg iq kh b ki mp jr kk kl mq ju kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">对于这个故事，我将使用一个简单的分类模型。<a class="ae lw" href="https://colab.research.google.com/github/tensorflow/docs/blob/master/site/en/tutorials/keras/classification.ipynb" rel="noopener ugc nofollow" target="_blank">这个Colab笔记本</a>展示了一个在时尚MNIST数据集上训练的分类器的例子(在60000张图片上训练，在10000张图片上测试)。该模型预期28x28x1灰度图像，并返回10类的<em class="lb"> softmax </em>概率。类别标签列表包括:</p><p id="2742" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lc ld le lf b">class_names = ['T-shirt/top', 'Trouser', 'Pullover', 'Dress', 'Coat', 'Sandal', 'Shirt', 'Sneaker', 'Bag', 'Ankle boot']</code></p><p id="4d05" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">处理模型输出的一种简单方法是简单的映射:找到得分最高的索引并使用该索引的标签。</p><p id="d483" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lc ld le lf b">class_names[np.argmax(predictions[0])]</code>获取图像的标签0。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi mu"><img src="../Images/0e72e7f6ce9696427d8d7c2a869322f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*39rgaUWXw82LyBtD_t8sGQ.png"/></div></div><p class="ls lt gj gh gi lu lv bd b be z dk translated"><a class="ae lw" href="https://github.com/zalandoresearch/fashion-mnist" rel="noopener ugc nofollow" target="_blank">时尚MNIST范例</a>(作者Zalando，麻省理工学院许可)。</p></figure><h1 id="20db" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">构建自定义图层</h1><p id="7043" class="pw-post-body-paragraph kf kg iq kh b ki mp jr kk kl mq ju kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">要了解如何在Keras中制作自定义图层，建议阅读Keras 和<a class="ae lw" href="https://www.tensorflow.org/tutorials/keras/save_and_load" rel="noopener ugc nofollow" target="_blank"> TensorFlow </a>中的原始文档<a class="ae lw" href="https://keras.io/layers/writing-your-own-keras-layers/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="3bdb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我想实现一个自定义层来存储<code class="fe lc ld le lf b">labels </code>和一个<code class="fe lc ld le lf b">topn</code>值，这样该层的输出可以是前<em class="lb"> n个</em>置信度标签及其分数。为此，我们必须覆盖图层的<code class="fe lc ld le lf b">__init__</code>、<code class="fe lc ld le lf b">call</code>、<code class="fe lc ld le lf b">compute_output_shape </code>和<code class="fe lc ld le lf b">get_config </code>功能。</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="mv mw l"/></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">带有标签和Top_k选择的自定义图层</p></figure><h2 id="d7cd" class="mx ly iq bd lz my mz dn md na nb dp mh ko nc nd mj ks ne nf ml kw ng nh mn ni bi translated">初始化</h2><p id="e022" class="pw-post-body-paragraph kf kg iq kh b ki mp jr kk kl mq ju kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">在init函数中，我们将构造函数参数存储为类的字段。不要忘记调用父类的构造函数！<code class="fe lc ld le lf b">super(LabelLimitLayer, self).__init__(**kwargs)</code></p><h2 id="fdef" class="mx ly iq bd lz my mz dn md na nb dp mh ko nc nd mj ks ne nf ml kw ng nh mn ni bi translated">打电话</h2><p id="d405" class="pw-post-body-paragraph kf kg iq kh b ki mp jr kk kl mq ju kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">call函数期望前一层的输出作为输入，并计算<code class="fe lc ld le lf b">top_k </code>类及其标签。为此，我使用了张量流函数。</p><p id="c199" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了从标签列表中创建一个<code class="fe lc ld le lf b">(?,len(labels)) </code>形状的张量，我们首先使用列表(我们自定义类的参数)创建一个张量，然后使用前一层输出的形状扩展它(我们从中提取<code class="fe lc ld le lf b">batch_size </code>)。这些步骤是:</p><p id="39b3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lc ld le lf b">tf_labels = tf.constant([self.labels], dtype=”string”)</code>弦型张量<br/> <code class="fe lc ld le lf b">tf_labels = tf.tile(tf_labels,[batch_size,1])</code>展开得到(？1)处理批次的动态形状。</p><p id="6579" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了选择最高的k个分数，我使用了相应的TensorFlow函数。我们存储这些指数，这样我们就可以映射这些指数的标签以及置信度值。<br/> <code class="fe lc ld le lf b">top_k = tf.nn.top_k(x, k=self.topn, sorted=True, name=”top_k”).indices</code></p><p id="af49" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了使用一个张量的索引来获取另一个张量的值，我使用了tf.gather函数。<br/> <code class="fe lc ld le lf b">top_conf = tf.gather(x, top_k, batch_dims=1)<br/>top_labels = tf.gather(tf_labels, top_k, batch_dims=1)</code></p><p id="a5a2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，该层返回最后两个张量。<br/> <code class="fe lc ld le lf b">return [top_conf, top_labels]</code></p><h2 id="78c9" class="mx ly iq bd lz my mz dn md na nb dp mh ko nc nd mj ks ne nf ml kw ng nh mn ni bi translated">计算输出形状</h2><p id="9604" class="pw-post-body-paragraph kf kg iq kh b ki mp jr kk kl mq ju kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">由于有两个输出张量，Keras层不能自动计算输出形状。好在可以这样计算:<br/> <code class="fe lc ld le lf b">top_shape = (batch_size, self.topn)<br/>return [top_shape, top_shape]</code></p><h2 id="1e7a" class="mx ly iq bd lz my mz dn md na nb dp mh ko nc nd mj ks ne nf ml kw ng nh mn ni bi translated">获取配置</h2><p id="577a" class="pw-post-body-paragraph kf kg iq kh b ki mp jr kk kl mq ju kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">为了序列化定制层(当保存模型时)，必须用类参数的值更新配置。不要忘记将超类的配置添加到字典中！</p><h1 id="0014" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">将输出图层添加到模型</h1><p id="a925" class="pw-post-body-paragraph kf kg iq kh b ki mp jr kk kl mq ju kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">在这个例子中，我在基本分类模型的末尾添加了一个自定义层，带有标签(<code class="fe lc ld le lf b">class_names</code>)和top_k值(<code class="fe lc ld le lf b">2</code>)。</p><p id="39bb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lc ld le lf b">label_layer = LabelLimitLayer(class_names, 2)(base_model.output)<br/>label_model = Model(base_model.input, label_layer)</code></p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/c83f881ccd62b2d7ca7a5a2b2e54dcba.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*MypzHURkX2KBW8x5alpHug.png"/></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">时尚MNIST数据集中的预测标签</p></figure><h1 id="5049" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">保存和加载模型</h1><p id="3aa0" class="pw-post-body-paragraph kf kg iq kh b ki mp jr kk kl mq ju kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">最后，为了保存一个模型，我们可以使用Keras模型的save函数。要加载带有自定义层的模型，必须在<code class="fe lc ld le lf b">custom_objects </code>参数中定义该自定义层。</p><p id="6f7c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lc ld le lf b">label_model.save(‘test.h5’)<br/>restored_model = keras.models.load_model(“test.h5”, custom_objects={“LabelLimitLayer”:LabelLimitLayer})</code></p><h1 id="1663" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">摘要</h1><p id="2e45" class="pw-post-body-paragraph kf kg iq kh b ki mp jr kk kl mq ju kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">这个片段展示了如何使用Keras自定义层来创建字符串标签作为模型的输出。这个故事还使用top_k只保留相关的类。相应的代码可在<a class="ae lw" href="https://colab.research.google.com/drive/1--n60Ss4TY-jnJ2s0IoW-1Y9FRGxG1_i" rel="noopener ugc nofollow" target="_blank">这款Colab笔记本</a>上找到。</p></div></div>    
</body>
</html>