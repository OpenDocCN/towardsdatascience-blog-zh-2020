<html>
<head>
<title>Learn to Create a Doodle Draw Game on Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习在 Android 上创建一个涂鸦游戏</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/learn-to-create-a-doodle-draw-game-on-android-f713e64408a7?source=collection_archive---------43-----------------------#2020-09-15">https://towardsdatascience.com/learn-to-create-a-doodle-draw-game-on-android-f713e64408a7?source=collection_archive---------43-----------------------#2020-09-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9a59" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用 PyTorch 和深度 Java 库</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/28ef0a3d8ed605170d4239b5271a4f4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DYl7DdJr76WW4uim.jpg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">QuickDraw 数据集(来源<a class="ae kv" href="https://github.com/googlecreativelab/quickdraw-dataset/blob/master/preview.jpg" rel="noopener ugc nofollow" target="_blank"/><a class="ae kv" href="https://github.com/googlecreativelab/quickdraw-dataset/blob/master/preview.jpg" rel="noopener ugc nofollow" target="_blank">https://github . com/Google creative lab/quick draw-Dataset/blob/master/preview . jpg</a>)</p></figure><h1 id="b11b" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">介绍</h1><p id="194c" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">涂鸦绘画游戏的目标是以最快的速度创作出一幅特定物品的图画，比如一所房子或一只猫。虽然绘画部分很简单，但在深度学习出现之前，计算机不可能准确猜测你画了什么。与照片不同，绘画也有艺术家特有的创作风格，这使得它们特别难以理解。你可以在这里看到任何涂鸦绘画游戏<a class="ae kv" href="https://djl.ai/website/demo.html#doodle" rel="noopener ugc nofollow" target="_blank">的例子。<br/> <br/>随着多年来计算能力的稳步增长，现在已经可以在手机操作系统(如 Android)上运行边缘/物联网设备上的机器学习(ML)任务。然而，Android 运行在 Java 上，而大多数深度学习框架，如 TensorFlow 和 PyTorch，都是为 Python 设计的。为了解决这个挑战，我们需要一种在 Java 中构建深度学习模型的方法。Deep Java Library (DJL)是一个新的开源深度学习框架，由 AWS 构建，可以轻松地用 Java 进行深度学习。</a></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/edc3953a195a7cb177bc231cfff97fbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/0*ieXLtC43ZrCBBdAb.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Android 上的涂鸦应用程序(图片由作者提供)</p></figure><p id="93cf" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">在本教程中，我们将介绍在 Android 上部署 PyTorch 涂鸦识别模型的主要步骤。因为代码库相对较大，所以我们将涵盖您需要理解的最重要的部分，以便模型能够正确工作。你可以访问我们的<a class="ae kv" href="https://github.com/aws-samples/djl-demo/tree/master/android" rel="noopener ugc nofollow" target="_blank">示例项目</a>开始制作。</p><h1 id="ce3a" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">设置</h1><p id="aa4e" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">这个项目需要 Android API 26+来使用大多数 DJL 功能。您可以查看我们的<a class="ae kv" href="https://github.com/aws-samples/djl-demo/tree/master/android" rel="noopener ugc nofollow" target="_blank">示例项目设置</a>以节省一些时间。下面的代码块列出了此项目所需的依赖项:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="451d" class="mv kx iq mr b gy mw mx l my mz">dependencies {<br/>    implementation 'androidx.appcompat:appcompat:1.2.0'<br/>    implementation 'ai.djl:api:0.7.0'<br/>    implementation 'ai.djl.android:core:0.7.0'<br/>    runtimeOnly 'ai.djl.pytorch:pytorch-engine:0.7.0'<br/>    runtimeOnly 'ai.djl.android:pytorch-native:0.7.0'<br/>}</span></pre><p id="e5f8" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">您将使用 DJL 提供的 API 和 PyTorch 包。</p><h1 id="2d54" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">步骤 1:定义布局</h1><p id="5c35" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">受<a class="ae kv" href="https://medium.com/@ssaurel/learn-to-create-a-paint-application-for-android-5b16968063f8" rel="noopener">学习为 Android 创建画图应用</a>的启发，我们可以在 Android 上创建一个视图类来显示结果。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi na"><img src="../Images/ce3e87609c5e86a8d00cd8a8f69fb99b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*ClQh-fuFtAzYk98-06uOcw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">DoodleDraw 布局(图片由作者提供)</p></figure><p id="ee9d" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">正如您在这些图像中看到的，您在主页中创建了两个视图对象。<code class="fe nb nc nd mr b">PaintView</code>对象是允许用户涂鸦的对象。<code class="fe nb nc nd mr b">ImageView</code>在右下角会显示实际图像馈给模型进行推理。你还在左下角预留了一个按钮来清理画布。</p><h1 id="4bdd" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">步骤 2:处理绘制动作</h1><p id="3baf" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在 Android 设备上，您可以定制一个 Android 触摸事件处理程序来响应用户的触摸动作。在这种情况下，我们定义了三个动作处理程序来处理不同的触摸动作:</p><ul class=""><li id="f5e4" class="ne nf iq lq b lr ml lu mm lx ng mb nh mf ni mj nj nk nl nm bi translated">触摸开始:当检测到触摸动作时触发</li><li id="c411" class="ne nf iq lq b lr nn lu no lx np mb nq mf nr mj nj nk nl nm bi translated">触摸移动:当用户在屏幕上移动手指时触发</li><li id="741a" class="ne nf iq lq b lr nn lu no lx np mb nq mf nr mj nj nk nl nm bi translated">touchUp:当用户完成触摸动作时触发</li></ul><p id="8b57" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">同时，您使用<code class="fe nb nc nd mr b">paths</code>来存储用户在画布上绘制的路径。让我们看看实际的代码。</p><h2 id="99c6" class="mv kx iq bd ky ns nt dn lc nu nv dp lg lx nw nx li mb ny nz lk mf oa ob lm oc bi translated">重写 OnTouchEvent 和 OnDraw</h2><p id="6af3" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">覆盖<code class="fe nb nc nd mr b">onTouchEvent</code>函数来处理动作:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="4c4a" class="mv kx iq mr b gy mw mx l my mz">@Override<br/>public boolean onTouchEvent(MotionEvent event) {<br/>    float x = event.getX();<br/>    float y = event.getY();</span><span id="7184" class="mv kx iq mr b gy od mx l my mz">    switch (event.getAction()) {<br/>        case MotionEvent.ACTION_DOWN :<br/>            touchStart(x, y);<br/>            invalidate();<br/>            break;<br/>        case MotionEvent.ACTION_MOVE :<br/>            touchMove(x, y);<br/>            invalidate();<br/>            break;<br/>        case MotionEvent.ACTION_UP :<br/>            touchUp();<br/>            runInference();<br/>            invalidate();<br/>            break;<br/>    }</span><span id="4956" class="mv kx iq mr b gy od mx l my mz">    return true;<br/>}</span></pre><p id="9658" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">如该代码块所示，您在<code class="fe nb nc nd mr b">MotionEvent.ACTION_UP</code>处理程序中添加了一个<code class="fe nb nc nd mr b">runInference</code>。该函数用于预测用户画线完成时的涂鸦。我们将在接下来的几个步骤中讨论这一点。<br/> <br/>你还需要覆盖 onDraw 函数来显示用户画完的涂鸦:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="ad01" class="mv kx iq mr b gy mw mx l my mz">@Override<br/>protected void onDraw(Canvas canvas) {<br/>    canvas.save();<br/>    this.canvas.drawColor(DEFAULT_BG_COLOR);</span><span id="c1a3" class="mv kx iq mr b gy od mx l my mz">    for (Path path : paths) {<br/>        paint.setColor(DEFAULT_PAINT_COLOR);<br/>        paint.setStrokeWidth(BRUSH_SIZE);<br/>        this.canvas.drawPath(path, paint);<br/>    }<br/>    canvas.drawBitmap(bitmap, 0, 0, bitmapPaint);<br/>    canvas.restore();<br/>}</span></pre><p id="6e60" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">实际图像存储在位图中并显示在屏幕上。</p><h2 id="5589" class="mv kx iq bd ky ns nt dn lc nu nv dp lg lx nw nx li mb ny nz lk mf oa ob lm oc bi translated">触摸开始</h2><p id="e3f9" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">当触摸开始时，下面的代码创建一个新的路径，并在屏幕上记录该路径的坐标。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="79f4" class="mv kx iq mr b gy mw mx l my mz">private void touchStart(float x, float y) {<br/>    path = new Path();<br/>    paths.add(path);<br/>    path.reset();<br/>    path.moveTo(x, y);<br/>    this.x = x;<br/>    this.y = y;<br/>}</span></pre><h2 id="b5c0" class="mv kx iq bd ky ns nt dn lc nu nv dp lg lx nw nx li mb ny nz lk mf oa ob lm oc bi translated">触摸移动</h2><p id="bb7a" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在移动过程中，你不断记录坐标并形成一个<a class="ae kv" href="https://developer.android.com/reference/android/graphics/Path#quadTo(float,%20float,%20float,%20float)" rel="noopener ugc nofollow" target="_blank">二次贝塞尔曲线</a>。您可以使用移动动作的绝对差值来校准绘制动作。只有当坐标差超过公差时，它才画一条线。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="e36e" class="mv kx iq mr b gy mw mx l my mz">private void touchMove(float x, float y) {<br/>    if (x &lt; 0 || x &gt; getWidth() || y &lt; 0 || y &gt; getHeight()) {<br/>        return;<br/>    }<br/>    float dx = Math.abs(x - this.x);<br/>    float dy = Math.abs(y - this.y);</span><span id="3596" class="mv kx iq mr b gy od mx l my mz">    if (dx &gt;= TOUCH_TOLERANCE || dy &gt;= TOUCH_TOLERANCE) {<br/>        path.quadTo(this.x, this.y, (x + this.x) / 2, (y + this.y) / 2);<br/>        this.x = x;<br/>        this.y = y;<br/>    }<br/>}</span></pre><h2 id="be11" class="mv kx iq bd ky ns nt dn lc nu nv dp lg lx nw nx li mb ny nz lk mf oa ob lm oc bi translated">修饰</h2><p id="5cc9" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">当触摸完成时，下面的代码块在路径上画一条线，并计算路径的矩形边界。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="5f4d" class="mv kx iq mr b gy mw mx l my mz">private void touchUp() {<br/>    path.lineTo(this.x, this.y);<br/>    maxBound.add(new Path(path));<br/>}</span></pre><h1 id="77e4" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">第三步:开始推理</h1><p id="7148" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">要在 Android 上运行推理，需要完成以下三项任务:</p><ul class=""><li id="ab3b" class="ne nf iq lq b lr ml lu mm lx ng mb nh mf ni mj nj nk nl nm bi translated">从 URL 加载模型</li><li id="02cd" class="ne nf iq lq b lr nn lu no lx np mb nq mf nr mj nj nk nl nm bi translated">定义预处理和后处理</li><li id="8e12" class="ne nf iq lq b lr nn lu no lx np mb nq mf nr mj nj nk nl nm bi translated">从绘画视图运行推理</li></ul><p id="ccb8" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">为了实现这些目标，您需要创建一个<code class="fe nb nc nd mr b">DoodleModel</code>类来覆盖它们。下一节将遍历这个类中的核心逻辑来完成这些任务。</p><h2 id="4404" class="mv kx iq bd ky ns nt dn lc nu nv dp lg lx nw nx li mb ny nz lk mf oa ob lm oc bi translated">加载模型</h2><p id="07ee" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">DJL 有一个内置的模型管理系统。用户可以在文件系统中指定存储模型的目录。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="eb32" class="mv kx iq mr b gy mw mx l my mz">File dir = getFilesDir();<br/>System.<em class="oe">setProperty</em>("DJL_CACHE_DIR", dir.getAbsolutePath());</span></pre><p id="bb64" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">通过定义<code class="fe nb nc nd mr b">DJL_CACHE_DIR</code>属性，模型被保存到目标位置。<br/> <br/>之后，定义一个<a class="ae kv" href="https://javadoc.io/doc/ai.djl/api/latest/ai/djl/repository/zoo/Criteria.html" rel="noopener ugc nofollow" target="_blank">标准</a>从 URL 下载模型。zip 文件包含:</p><ul class=""><li id="fa3c" class="ne nf iq lq b lr ml lu mm lx ng mb nh mf ni mj nj nk nl nm bi translated"><code class="fe nb nc nd mr b">doodle_mobilenet.pt</code>:py torch 型号</li><li id="2d00" class="ne nf iq lq b lr nn lu no lx np mb nq mf nr mj nj nk nl nm bi translated"><code class="fe nb nc nd mr b">synset.txt</code>:包含类名</li></ul><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="68d0" class="mv kx iq mr b gy mw mx l my mz">Criteria&lt;Image, Classifications&gt; criteria =<br/>            Criteria.builder()<br/>                    .setTypes(Image.class, Classifications.class)<br/>                    .optModelUrls("https://djl-ai.s3.amazonaws.com/resources/demo/pytorch/doodle_mobilenet.zip")<br/>                    .optTranslator(translator)<br/>                    .build();<br/>return ModelZoo.loadModel(criteria);</span></pre><p id="75c8" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">这个代码块还定义了<code class="fe nb nc nd mr b">translator</code>。您可以使用这个类对图像进行预处理和后处理。<br/>最后，在主活动中创建一个<a class="ae kv" href="https://javadoc.io/doc/ai.djl/api/latest/ai/djl/Model.html" rel="noopener ugc nofollow" target="_blank">模型</a>，并使用它生成一个<a class="ae kv" href="https://javadoc.io/doc/ai.djl/api/latest/ai/djl/inference/Predictor.html" rel="noopener ugc nofollow" target="_blank">预测器</a>，如下所示:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="4c05" class="mv kx iq mr b gy mw mx l my mz">@Override<br/>protected Boolean doInBackground(Void... params) {<br/>    try {<br/>        model = DoodleModel.loadModel();<br/>        predictor = model.newPredictor();<br/>        return true;<br/>    } catch (IOException | ModelException e) {<br/>        Log.e("DoodleDraw", null, e);<br/>    }<br/>    return false;<br/>}</span></pre><p id="7ca4" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">有关模型加载的更多信息，请参见<a class="ae kv" href="https://github.com/awslabs/djl/blob/master/docs/load_model.md" rel="noopener ugc nofollow" target="_blank">如何加载模型</a>。</p><h2 id="c5b3" class="mv kx iq bd ky ns nt dn lc nu nv dp lg lx nw nx li mb ny nz lk mf oa ob lm oc bi translated">使用翻译器定义预处理和后处理</h2><p id="fab1" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在 DJL，我们定义了一个<a class="ae kv" href="https://javadoc.io/doc/ai.djl/api/latest/ai/djl/translate/Translator.html" rel="noopener ugc nofollow" target="_blank">翻译器</a>接口，用于进行预处理和后处理。这里我们刚刚定义了一个<a class="ae kv" href="https://javadoc.io/doc/ai.djl/api/latest/ai/djl/modality/cv/translator/ImageClassificationTranslator.html" rel="noopener ugc nofollow" target="_blank">image classificationtranslator</a>实现了<code class="fe nb nc nd mr b">DoodleModel</code>中的翻译器:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="6e0a" class="mv kx iq mr b gy mw mx l my mz">ImageClassificationTranslator.builder()<br/>    .addTransform(new ToTensor())<br/>    .optFlag(Image.Flag.GRAYSCALE)<br/>    .optApplySoftmax(true).build());</span></pre><p id="34f4" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">在内部，转换器在创建过程中加载 synset.txt 文件来存储类名。我们的预期输入是<a class="ae kv" href="https://javadoc.io/doc/ai.djl/api/latest/ai/djl/modality/cv/Image.html" rel="noopener ugc nofollow" target="_blank">图像</a>，我们的输出是<a class="ae kv" href="https://javadoc.io/doc/ai.djl/api/latest/ai/djl/modality/Classifications.html" rel="noopener ugc nofollow" target="_blank">分类</a>。对于后处理，我们对输出应用 softmax 操作，并存储在分类类中。要了解更多关于 translator 如何工作并创建您自己的定制翻译器，请参见<a class="ae kv" href="https://github.com/awslabs/djl/blob/master/jupyter/tutorial/image_classification_with_your_model.ipynb" rel="noopener ugc nofollow" target="_blank">使用您的模型</a> <a class="ae kv" href="https://render.githubusercontent.com/view/ipynb?commit=ca6afa7e568cd9621e128160007dcc5e9e0af488&amp;enc_url=68747470733a2f2f7261772e67697468756275736572636f6e74656e742e636f6d2f6177736c6162732f646a6c2f636136616661376535363863643936323165313238313630303037646363356539653061663438382f6a7570797465722f7475746f7269616c2f696d6167655f636c617373696669636174696f6e5f776974685f796f75725f6d6f64656c2e6970796e62&amp;nwo=awslabs%2Fdjl&amp;path=jupyter%2Ftutorial%2Fimage_classification_with_your_model.ipynb&amp;repository_id=218396611&amp;repository_type=Repository#Inference-with-your-model" rel="noopener ugc nofollow" target="_blank"> </a>进行推理。</p><h2 id="5008" class="mv kx iq bd ky ns nt dn lc nu nv dp lg lx nw nx li mb ny nz lk mf oa ob lm oc bi translated">从绘画视图运行推理</h2><p id="995a" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">最后，实现我们之前定义的<code class="fe nb nc nd mr b">runInference</code>函数。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="0f14" class="mv kx iq mr b gy mw mx l my mz">public void runInference() {<br/>    // make a copy<br/>    Bitmap bmp = Bitmap.createBitmap(bitmap);<br/>    // do scaling<br/>    bmp = Bitmap.createScaledBitmap(bmp, 64, 64, true);<br/>   // run inference<br/>    Classifications classifications = model.predict(bmp);<br/>   // display input image<br/>    Bitmap present = Bitmap.createScaledBitmap(bmp, imageView.getWidth(), imageView.getHeight(), true);<br/>    imageView.setImageBitmap(present);<br/>   // display output<br/>   if (messageToast != null) {<br/>        messageToast.cancel();<br/>    }<br/>    messageToast = Toast.makeText(getContext(), classifications.toString(), Toast.LENGTH_SHORT);<br/>    messageToast.show();<br/>}</span></pre><p id="592f" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">这将在屏幕上创建一个<a class="ae kv" href="https://developer.android.com/reference/android/widget/Toast" rel="noopener ugc nofollow" target="_blank"> Toast </a>弹出窗口，显示结果如下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi of"><img src="../Images/253a073c16ea38aa631229ee98046946.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*meWZl0YR_ZWrc0DpuuhDsQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">吐司(作者图片)</p></figure><p id="b4da" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">就是这样。您刚刚完成了第一个涂鸦应用程序的创建！</p><h2 id="c339" class="mv kx iq bd ky ns nt dn lc nu nv dp lg lx nw nx li mb ny nz lk mf oa ob lm oc bi translated">可选:优化输入</h2><p id="4e8c" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">为了获得最佳预测，您可能需要计算此图像的最大界限。该模型是在正方形图像上训练的，因此将输入图像设置为正方形将获得最佳结果。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/16548937feec3e2fd8f9cba786b7554e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x5VL1KMaPUHH2rtCDKKvyQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">裁剪图像(作者提供的图像)</p></figure><p id="6e9d" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">右边的图像比左边的图像有更好的预测结果，因为它不包含太多的空白。因为所有的路径都可以计算出一个矩形边界，所以我们可以找到所有 x 和 y 坐标的最小和最大值来找到最大的正方形。我们已经定义了一个<code class="fe nb nc nd mr b">Bound</code>类来做这件事。之后，按如下方式裁剪存储的位图:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="f64d" class="mv kx iq mr b gy mw mx l my mz">RectF bound = maxBound.getBound();<br/>int x = (int) bound.left;<br/>int y = (int) bound.top;<br/>int width = (int) Math.ceil(bound.width());<br/>int height = (int) Math.ceil(bound.height());<br/>// do crop<br/>Bitmap bmp = Bitmap.createBitmap(bitmap, x, y, width, height);</span></pre><p id="f5d4" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">就是这样！现在你应该可以在你的 Android 设备上创建一个涂鸦游戏了。同样，您也可以参考我们的<a class="ae kv" href="https://github.com/aws-samples/djl-demo/tree/master/android" rel="noopener ugc nofollow" target="_blank">示例项目</a>以获得完整的示例。</p><h1 id="e6d6" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">关于深度 Java 库</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/97c336dd5c4ef65780ffefd51e9aa4eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*al2fwHdh_kFRWY-7sN6iRQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">DJL 标志(图片由作者提供)</p></figure><p id="98c7" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated"><a class="ae kv" href="https://djl.ai" rel="noopener ugc nofollow" target="_blank">深度 Java 库(DJL) </a>是一个用 Java 编写的深度学习框架，同时支持训练和推理。DJL 建立在现代深度学习引擎(TenserFlow、PyTorch、MXNet 等)之上。您可以轻松地使用 DJL 来训练您的模型或部署您喜爱的模型从各种引擎，没有任何额外的转换。它包含一个强大的 ModelZoo 设计，允许您管理训练好的模型并在一行中加载它们。内置的 ModelZoo 目前支持来自 GluonCV、HuggingFace、TorchHub 和 Keras 的 70 多个预训练和随时可用的模型。<br/> <br/>关注我们的<a class="ae kv" href="https://github.com/awslabs/djl/tree/master/docs" rel="noopener ugc nofollow" target="_blank"> GitHub </a>、<a class="ae kv" href="https://github.com/aws-samples/djl-demo" rel="noopener ugc nofollow" target="_blank">演示库</a>、<a class="ae kv" href="https://join.slack.com/t/deepjavalibrary/shared_invite/zt-ar91gjkz-qbXhr1l~LFGEIEeGBibT7w" rel="noopener ugc nofollow" target="_blank"> Slack channel </a>和<a class="ae kv" href="https://twitter.com/deepjavalibrary" rel="noopener ugc nofollow" target="_blank"> twitter </a>获取更多关于 DJL 的文档和示例！</p></div></div>    
</body>
</html>