<html>
<head>
<title>Create new functionality with __getattribute__</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 __getattribute__ 创建新功能</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/create-new-functionality-with-getattribute-a6757ee27428?source=collection_archive---------44-----------------------#2020-06-18">https://towardsdatascience.com/create-new-functionality-with-getattribute-a6757ee27428?source=collection_archive---------44-----------------------#2020-06-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f16b" class="pw-subtitle-paragraph ju is it bd b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl dk translated">继承、包装器、类属性等等！</h2></div><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/67dd0c5e478d95b67e36882be8ff91c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hHisWs_p-GmRKP7UIVgYZw.jpeg"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">图片由<a class="ae lc" href="https://pixabay.com/users/josealbafotos-1624766/" rel="noopener ugc nofollow" target="_blank"> josealbafotos </a>提供</p></figure><p id="7999" class="pw-post-body-paragraph ld le it lf b lg lh jy li lj lk kb ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">作为一个班级的孩子，很难从父母手中夺回控制权。你可能认为一旦你父母给了你一些功能，你就不能改变它了，但事实并非如此！</p><p id="50f0" class="pw-post-body-paragraph ld le it lf b lg lh jy li lj lk kb ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们将考虑一个例子，我们想使用父方法给我们的功能，但是我们想在调用父方法之前或之后做一些事情。如果你从一个定义在不属于你的模块中的类继承，这将特别有用。</p><h2 id="17c7" class="lz ma it bd mb mc md dn me mf mg dp mh lm mi mj mk lq ml mm mn lu mo mp mq mr bi translated">背景</h2><p id="ee2a" class="pw-post-body-paragraph ld le it lf b lg ms jy li lj mt kb ll lm mu lo lp lq mv ls lt lu mw lw lx ly im bi translated">为了理解如何实现这一点，我们需要理解 Python 如何调用类方法。</p><p id="da96" class="pw-post-body-paragraph ld le it lf b lg lh jy li lj lk kb ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">考虑下面的类:</p><pre class="kn ko kp kq gt mx jt my mz aw na bi"><span id="380c" class="lz ma it jt b gy nb nc l nd ne">class Person:<br/>    def set_name(self,name):<br/>        self.name = name</span><span id="746a" class="lz ma it jt b gy nf nc l nd ne">class Worker(Person):<br/>    def set_occupation(self,job):<br/>        self.occupation = job</span><span id="824d" class="lz ma it jt b gy nf nc l nd ne">xander = Worker()</span></pre><p id="21c7" class="pw-post-body-paragraph ld le it lf b lg lh jy li lj lk kb ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">所以<code class="fe jq jr js jt b">xander</code>是<code class="fe jq jr js jt b">Worker</code>的一个实例。当我们运行<code class="fe jq jr js jt b">xander.set_name("Xander")</code>时，会发生两件事。</p><ol class=""><li id="74da" class="ng nh it lf b lg lh lj lk lm ni lq nj lu nk ly nl nm nn no bi translated">班级在<code class="fe jq jr js jt b">set_name</code>上呼叫<code class="fe jq jr js jt b">__getattribute__</code></li><li id="0b4b" class="ng nh it lf b lg np lj nq lm nr lq ns lu nt ly nl nm nn no bi translated">然后用参数<code class="fe jq jr js jt b">"Xander"</code>在<code class="fe jq jr js jt b">xander.set_name</code>上调用<code class="fe jq jr js jt b">__call__</code></li></ol><p id="9a18" class="pw-post-body-paragraph ld le it lf b lg lh jy li lj lk kb ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们想改变父类中一个函数的行为，但是我们没有访问它的权限(可能是因为它属于一个不同的模块)。</p><p id="ff71" class="pw-post-body-paragraph ld le it lf b lg lh jy li lj lk kb ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们对<code class="fe jq jr js jt b">__call__</code>没有任何控制权，因为该函数归父函数所有。然而，我们确实可以控制我们自己的<code class="fe jq jr js jt b">__getattribute__</code>,所以让我们改为修改它。</p><h2 id="e44a" class="lz ma it bd mb mc md dn me mf mg dp mh lm mi mj mk lq ml mm mn lu mo mp mq mr bi translated">功能包装</h2><p id="b7f7" class="pw-post-body-paragraph ld le it lf b lg ms jy li lj mt kb ll lm mu lo lp lq mv ls lt lu mw lw lx ly im bi translated">因此，要添加新功能，我们需要采用原始方法，在之前或之后添加新功能，并将其包装在新函数中。然后，我们中断<code class="fe jq jr js jt b">__getattribute__</code>的正常行为，注入新的包装器。</p><p id="04f9" class="pw-post-body-paragraph ld le it lf b lg lh jy li lj lk kb ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">让我们看一个基本的例子，我们想在函数运行之前和之后添加<code class="fe jq jr js jt b">print</code>语句。</p><pre class="kn ko kp kq gt mx jt my mz aw na bi"><span id="5184" class="lz ma it jt b gy nb nc l nd ne">def print_wrapper(func):<br/>    def new_func(*args,**kwargs):<br/>        print(f"Running: {func.__name__}")<br/>        out = func(*args,**kwargs)<br/>        print(f"Finished: {func.__name__}")<br/>        return out</span><span id="0d64" class="lz ma it jt b gy nf nc l nd ne">    return new_func</span></pre><p id="3668" class="pw-post-body-paragraph ld le it lf b lg lh jy li lj lk kb ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">为了获得更多令人兴奋的例子，也为了更全面地理解装饰者，我在这里写下了它们:</p><div class="nu nv gp gr nw nx"><a rel="noopener follow" target="_blank" href="/level-up-your-code-with-python-decorators-c1966d78607"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd iu gy z fp oc fr fs od fu fw is bi translated">用 Python decorators 提升你的代码</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">日志记录、类型检查、异常处理等等！</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">towardsdatascience.com</p></div></div><div class="og l"><div class="oh l oi oj ok og ol kw nx"/></div></div></a></div><p id="b348" class="pw-post-body-paragraph ld le it lf b lg lh jy li lj lk kb ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">现在我们需要编写新的<code class="fe jq jr js jt b">__getattribute__</code>函数:</p><pre class="kn ko kp kq gt mx jt my mz aw na bi"><span id="6894" class="lz ma it jt b gy nb nc l nd ne">def __getattribute__(self, attr):<br/>    attribute = super(Parent, self).__getattribute__(attr)<br/>    if callable(attribute):<br/>        return print_wrapper(attribute)<br/>    else:<br/>        return attribute</span></pre><p id="6c92" class="pw-post-body-paragraph ld le it lf b lg lh jy li lj lk kb ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">检查属性是否为<code class="fe jq jr js jt b">callable</code>就是检查被选择的属性是否可以用参数调用，因此应用包装器是有意义的。如果属性只是一个属性，而不是一个方法，那么行为将不会改变。</p><p id="af53" class="pw-post-body-paragraph ld le it lf b lg lh jy li lj lk kb ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">综上所述，我们上面的基本示例应该是这样的:</p><pre class="kn ko kp kq gt mx jt my mz aw na bi"><span id="fa45" class="lz ma it jt b gy nb nc l nd ne">class Person:<br/>    def set_name(self,name):<br/>        self._name = name</span><span id="ade0" class="lz ma it jt b gy nf nc l nd ne">def print_wrapper(func):<br/>    def new_func(*args,**kwargs):<br/>        print(f"Running: {func.__name__}")<br/>        out = func(*args,**kwargs)<br/>        print(f"Finished: {func.__name__}")<br/>        return out<br/>    return new_func</span><span id="a530" class="lz ma it jt b gy nf nc l nd ne">class Worker(Person):<br/>    <br/>    def __getattribute__(self, attr):<br/>        attribute = Person.__getattribute__(self,attr)<br/>        if callable(attribute):<br/>            return print_wrapper(attribute)<br/>        else:<br/>            return attribute<br/>    <br/>    def set_occupation(self,job):<br/>        self._job = job</span></pre><p id="77cf" class="pw-post-body-paragraph ld le it lf b lg lh jy li lj lk kb ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">当我们尝试使用它时，我们会得到:</p><pre class="kn ko kp kq gt mx jt my mz aw na bi"><span id="6ade" class="lz ma it jt b gy nb nc l nd ne">&gt;&gt;&gt; xander = Worker()<br/>&gt;&gt;&gt; xander.set_name("Xander")<br/>Running: set_name<br/>Finished: set_name<br/>&gt;&gt;&gt; xander.set_occupation("Butcher")<br/>Running: set_occupation<br/>Finished: set_occupation<br/>&gt;&gt;&gt; print(xander.__dict__)<br/>{'_name': 'Xander', '_job': 'Butcher'}</span></pre><h2 id="287a" class="lz ma it bd mb mc md dn me mf mg dp mh lm mi mj mk lq ml mm mn lu mo mp mq mr bi translated">警告的话</h2><p id="18f5" class="pw-post-body-paragraph ld le it lf b lg ms jy li lj mt kb ll lm mu lo lp lq mv ls lt lu mw lw lx ly im bi translated">使用这些类型的函数，弄乱<code class="fe jq jr js jt b">__getattribute__</code>应该小心，每个属性都会调用它，所以添加计算密集型功能会大大降低程序的速度。摆弄像<code class="fe jq jr js jt b">__getattribute__</code>这样的函数也很容易导致递归错误和内核崩溃，因为类会一次又一次地调用自己。</p><p id="3a19" class="pw-post-body-paragraph ld le it lf b lg lh jy li lj lk kb ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这种递归的一个例子是，如果你使用<code class="fe jq jr js jt b">__getattribute__</code>调用<code class="fe jq jr js jt b">__dict__</code>，因为<code class="fe jq jr js jt b">__dict__</code>本身调用<code class="fe jq jr js jt b">__getattribute__</code>，所以循环继续…</p><h2 id="58cf" class="lz ma it bd mb mc md dn me mf mg dp mh lm mi mj mk lq ml mm mn lu mo mp mq mr bi translated">我们学到了什么？</h2><p id="a0b3" class="pw-post-body-paragraph ld le it lf b lg ms jy li lj mt kb ll lm mu lo lp lq mv ls lt lu mw lw lx ly im bi translated">使用 Python 对象的双下划线方法可以让您节省大量时间和精力。实现同样目标的另一种方法是重新实现每个函数和装饰器。对于上面的例子来说，这可能不会太糟糕，但是想象一下，如果你的父类是像 Pandas 数据框或 NumPy 数组这样的东西，那么这将成为一项非常艰巨的任务。</p></div></div>    
</body>
</html>