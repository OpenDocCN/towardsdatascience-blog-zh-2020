<html>
<head>
<title>Matplotlib to Plotly Chart Conversion</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Matplotlib 到 Plotly 图表转换</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/matplotlib-to-plotly-chart-conversion-4bd260e73434?source=collection_archive---------17-----------------------#2020-05-11">https://towardsdatascience.com/matplotlib-to-plotly-chart-conversion-4bd260e73434?source=collection_archive---------17-----------------------#2020-05-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f6ea" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">将使用熊猫创建的 Matplotlib 图转换为 Plotly 图的实验</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f884d41c3768db9559bd260269a11f3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iNfLGng_H2eyhWaFcnaREg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">将 Matplotlib 图转换为 Plotly 图</p></figure><h1 id="7053" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">介绍</h1><p id="fc05" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">你有没有想过从数据帧中直接创建<a class="ae mm" href="https://plotly.com/python/" rel="noopener ugc nofollow" target="_blank"> Plotly </a>图表？</p><p id="6889" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">Pandas 目前使用 Matplotlib 作为默认的绘图后端。从 0.25 版本开始，<a class="ae mm" href="https://pandas.pydata.org/pandas-docs/stable/development/extending.html#plotting-backends" rel="noopener ugc nofollow" target="_blank">还支持其他后端</a>如<a class="ae mm" href="https://pypi.org/project/pandas-bokeh/" rel="noopener ugc nofollow" target="_blank">散景</a>。但是，目前不支持 Plotly。因此，我决定看看是否有可能将 Matplotlib 图表转换成它的 Plotly 等价物。</p><p id="ed6b" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">如果您想继续阅读本文，这里有完整的代码。</p><h1 id="fb81" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">窥视引擎盖下</h1><p id="5782" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">第一步是检查每个库如何在内部表示图。</p><p id="7b9d" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">两个库的内部工作是如此的抽象，以至于对于大多数常见的绘图目的，我们几乎不需要修补内部。将绘图提升到一个更高的抽象层次。您只需在数据帧上调用<code class="fe ms mt mu mv b">plot()</code>,可选地指定绘图种类，进行即时绘图——不需要创建空图形、设置轴标签、图例等等。例如，</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="af80" class="na kz it mv b gy nb nc l nd ne">data = df.groupby('year').sum()[["major_death", "major_capture"]]<br/>ax = data.plot.bar(rot=0)</span></pre><h2 id="a60a" class="na kz it bd la nf ng dn le nh ni dp li lz nj nk lk md nl nm lm mh nn no lo np bi translated">Matplotlib 轴属性</h2><p id="ca20" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我从检查由<code class="fe ms mt mu mv b">data.plot</code>返回的<code class="fe ms mt mu mv b">AxesSubplot</code>对象<code class="fe ms mt mu mv b">ax</code>开始。快速搜索后，我发现<code class="fe ms mt mu mv b">AxesSubplot</code>对象有一个<code class="fe ms mt mu mv b"><a class="ae mm" href="https://matplotlib.org/3.1.1/api/_as_gen/matplotlib.axes.Axes.properties.html#matplotlib.axes.Axes.properties" rel="noopener ugc nofollow" target="_blank">properties()</a></code>方法，将它们的属性作为一个字典返回。</p><p id="1cf3" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">以下是来自<a class="ae mm" href="https://www.kaggle.com/shaildeliwala/exploratory-analysis-and-predictions/#Major-death/capture-events-by-year" rel="noopener ugc nofollow" target="_blank">我的 Kaggle 笔记本</a>的条形图，其中包含关于《权力的游戏》战斗和死亡数据的 EDA。</p><p id="56f0" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">图表下方是由<code class="fe ms mt mu mv b">ax.properties()</code>返回的属性片段。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/fdfb60fc25714d9611848f0a6aa64258.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p7hHMBJCChjEfJN3ICDc4g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Matplotlib 剧情:《权力的游戏》中按年份划分的主要死亡/俘获事件</p></figure><p id="c8dc" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated"><code class="fe ms mt mu mv b">children</code>属性包含呈现为条形的<code class="fe ms mt mu mv b">Rectangle</code>对象。自然地，<code class="fe ms mt mu mv b">Rectangle</code>封装了大部分绘图信息(x 坐标、高度和宽度)。<code class="fe ms mt mu mv b">title</code>是图的标题，<code class="fe ms mt mu mv b">xlabel</code>和<code class="fe ms mt mu mv b">ylabel</code>分别是 x 轴和 y 轴标题。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="6da8" class="na kz it mv b gy nb nc l nd ne">{<br/>  'adjustable': 'box',<br/>  'axes_locator': None,<br/>  '<strong class="mv iu">children</strong>': [<br/>    &lt;matplotlib.patches.Rectangle at 0x1f7aa154608&gt;,<br/>    ...<br/>    &lt;matplotlib.legend.Legend at 0x1f7ab154ac8&gt;<br/>  ],<br/>  'data_ratio': 3.0,<br/>  'facecolor': (1.0, 1.0, 1.0, 1.0),<br/>  'figure': &lt;Figure size 1080x432 with 1 Axes&gt;,<br/>  ...,<br/>  'title': 'Major death/capture events by year',<br/>  'xlabel': 'Year',<br/>  'xticklabels': &lt;a list of 3 Text major ticklabel objects&gt;,<br/>  'ylabel': 'No. of Death/Capture Events',<br/>  'yticks': array([0., 1., 2., 3., 4., 5., 6., 7., 8., 9.]),<br/>}</span></pre><h2 id="80dc" class="na kz it bd la nf ng dn le nh ni dp li lz nj nk lk md nl nm lm mh nn no lo np bi translated">Plotly 图形属性</h2><p id="e475" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">下面是上面条形图的示意图。它的属性在它下面。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/ee9883f466cbe748b067b0a1093286de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KngDK1APKjTwE05FW_vYtw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">《权力的游戏》中按年份划分的主要死亡/俘获事件</p></figure><p id="22b7" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated"><code class="fe ms mt mu mv b">data</code>是包含上述绘图所需的几乎所有信息的属性。在<code class="fe ms mt mu mv b">layout</code>属性下，<code class="fe ms mt mu mv b">title</code>、<code class="fe ms mt mu mv b">xaxis.title</code>和<code class="fe ms mt mu mv b">yaxis.title</code>包含图标题和轴标题。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="cfbf" class="na kz it mv b gy nb nc l nd ne">{<br/>  "<strong class="mv iu">data</strong>": [<br/>    {<br/>      "marker": {<br/>        "color": [<br/>          "rgb(31.0,119.0,180.0,255.0)",<br/>          ...<br/>          "rgb(255.0,127.0,14.0,255.0)"<br/>        ]<br/>      },<br/>      "type": "bar",<br/>      "width": [0.25, ..., 0.25],<br/>      "x": [-0.25, 0.75, 1.75, 0, 1, 2],<br/>      "y": [4, 8, 1, 3, 6, 2]<br/>    }<br/>  ],<br/>  "layout": {<br/>    "barmode": "group",<br/>    "template": {<br/>      "data": {<br/>        "bar": [<br/>          {<br/>            "error_x": {"color": "#2a3f5f"},<br/>            "error_y": {"color": "#2a3f5f"},<br/>            "marker": {...}<br/>          }<br/>        ], ...<br/>        "table": [...]<br/>      }, ...<br/>    },<br/>    "title": {"text": "Major death/capture events by year"},<br/>    "xaxis": {"title": {"text": "Year"}, ... },<br/>    "yaxis": {<br/>      "range": [0, 9],<br/>      "title": {"text": "No. of Death/Capture Events"}<br/>    }<br/>  }<br/>}</span></pre><h2 id="eedc" class="na kz it bd la nf ng dn le nh ni dp li lz nj nk lk md nl nm lm mh nn no lo np bi translated">Matplotlib 图与 Plotly 图</h2><p id="3baa" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">请注意，虽然 Plotly 图形是 Matplotlib 图形的顶级对应物，但<a class="ae mm" href="https://plotly.com/python-api-reference/generated/plotly.graph_objects.Figure" rel="noopener ugc nofollow" target="_blank"> Plotly 图形</a> <em class="ns"> </em>与<a class="ae mm" href="https://matplotlib.org/3.2.1/api/_as_gen/matplotlib.figure.Figure.html#matplotlib.figure.Figure" rel="noopener ugc nofollow" target="_blank"> Matplotlib 图形</a>是不同的概念。</p><p id="21cf" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">然而，我们直接反映了<code class="fe ms mt mu mv b">AxesSubplot</code>的属性，即使它是包含在图形中的<a class="ae mm" href="https://matplotlib.org/3.1.1/tutorials/introductory/usage.html#parts-of-a-figure" rel="noopener ugc nofollow" target="_blank">。这是因为<code class="fe ms mt mu mv b">AxesSubplot</code>包含了我们所有感兴趣的对象。</a></p><p id="9fc7" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">然而，如果图中包含如下所示的支线剧情，我们必须反映每个支线剧情的属性。注意图<code class="fe ms mt mu mv b">fig</code>中包含的四个<code class="fe ms mt mu mv b">AxesSubplot</code>对象。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="0b0b" class="na kz it mv b gy nb nc l nd ne">fig, axes = plt.subplots(2, 2)<br/>print(fig.properties())</span><span id="d19a" class="na kz it mv b gy nt nc l nd ne"><strong class="mv iu"># Output</strong><br/>{<br/>    "agg_filter": null,<br/>    ...,<br/>    "axes": [<br/>        &lt;matplotlib.axes._subplots.AxesSubplot at 0x1f...&gt;,<br/>        &lt;matplotlib.axes._subplots.AxesSubplot at 0x1f...&gt;,<br/>        &lt;matplotlib.axes._subplots.AxesSubplot at 0x1f...&gt;,<br/>        &lt;matplotlib.axes._subplots.AxesSubplot at 0x1f...&gt;<br/>    ],<br/>    ...<br/>}</span></pre><h1 id="97e7" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">构建 Matplotlib 到 Plotly 的转换器</h1><p id="26a6" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">从这里开始，我们将把<code class="fe ms mt mu mv b">plotly.graph_objects</code>简称为<code class="fe ms mt mu mv b">go</code>。</p><h2 id="9835" class="na kz it bd la nf ng dn le nh ni dp li lz nj nk lk md nl nm lm mh nn no lo np bi translated">条形图转换器</h2><p id="bda7" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">根据上一节的理解，我编写了下面的函数，将一个给定的 Matplotlib 条形图转换成一个<code class="fe ms mt mu mv b">Plotly</code>条形图。它采用类型为<code class="fe ms mt mu mv b">AxesSubplot</code>的单个参数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">将 Matplotlib 条形图转换为 Plotly 条形图的函数</p></figure><p id="d80f" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">它执行以下步骤。</p><ol class=""><li id="5391" class="nw nx it ls b lt mn lw mo lz ny md nz mh oa ml ob oc od oe bi translated">从轴中提取所有矩形对象。</li><li id="360c" class="nw nx it ls b lt of lw og lz oh md oi mh oj ml ob oc od oe bi translated">构建矩形的 x 坐标、宽度、高度和颜色的列表。请注意，它将颜色转换为 Plotly 可以理解的格式。</li><li id="dae5" class="nw nx it ls b lt of lw og lz oh md oi mh oj ml ob oc od oe bi translated">构建刻度位置和标签的列表。</li><li id="afdc" class="nw nx it ls b lt of lw og lz oh md oi mh oj ml ob oc od oe bi translated">创建一个包含单个<code class="fe ms mt mu mv b">go.Bar</code>的<code class="fe ms mt mu mv b">go.Figure</code>对象。</li><li id="1569" class="nw nx it ls b lt of lw og lz oh md oi mh oj ml ob oc od oe bi translated">添加标题和记号。</li></ol><h2 id="9ec4" class="na kz it bd la nf ng dn le nh ni dp li lz nj nk lk md nl nm lm mh nn no lo np bi translated">散点图转换器</h2><p id="7a1d" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">以下函数获取包含散点图的 Matplotlib <code class="fe ms mt mu mv b">AxesSubplot</code>，并返回包含相应散点图的 Plotly <code class="fe ms mt mu mv b">go.Figure</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">将 Matplotlib 散点图转换为 Plotly 散点图的函数</p></figure><p id="5cdb" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">考虑下面的 Matpotlib 散点图。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/da6f521db3bb0360465a307f6b038ba2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k6m0wQHCIzb8G4f-hHfosQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Matplotlib 散点图</p></figure><p id="309d" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">如果你把它传递给上面的函数，你会得到下面的散点图。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/ff78a8566bfc3424a78efa7c5927a19c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jrOqxaTyFWX7K8epeB-kRw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Plotly 散点图</p></figure><h2 id="9d37" class="na kz it bd la nf ng dn le nh ni dp li lz nj nk lk md nl nm lm mh nn no lo np bi translated">限制</h2><p id="b2a5" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">虽然这种方法适用于小范围的绘图用例，但它很粗糙，不适合更大范围的用例。通过转换函数运行各种图并观察输出，很容易看出这一点。其他限制如下。</p><ol class=""><li id="71da" class="nw nx it ls b lt mn lw mo lz ny md nz mh oa ml ob oc od oe bi translated">图<a class="ae mm" href="https://matplotlib.org/3.2.1/api/_as_gen/matplotlib.pyplot.legend.html" rel="noopener ugc nofollow" target="_blank">图例</a>未映射。如果使用<code class="fe ms mt mu mv b">go</code>或<code class="fe ms mt mu mv b">plotly.express</code>在 Plotly 中创建一个分组条形图，分组信息将被保留。然而，与 Plotly 不同的是，条形分组信息并没有显式地存储在 Matplotlib 中。因此，要在 Plotly 中实现“真正的”分组条形图，我们必须以某种方式从 Matplotlib 图中推断分组信息。此外，我找不到一个直接的方法给一个复杂的图形添加图例，除了<a class="ae mm" href="https://plotly.com/python/creating-and-updating-figures/#adding-traces" rel="noopener ugc nofollow" target="_blank">添加带有名字的轨迹</a>和<code class="fe ms mt mu mv b">show_legend=True</code>。</li><li id="972c" class="nw nx it ls b lt of lw og lz oh md oi mh oj ml ob oc od oe bi translated">悬停标签显示最少的信息。如果使用<code class="fe ms mt mu mv b">plotly.express</code>创建图表，悬停标签会自动填充有用的信息，这是 Plotly 最酷的特性之一。无论如何，你仍然可以<a class="ae mm" href="https://plotly.com/python/hover-text-and-formatting" rel="noopener ugc nofollow" target="_blank">定制悬停标签</a>，以显示更多信息。</li><li id="9805" class="nw nx it ls b lt of lw og lz oh md oi mh oj ml ob oc od oe bi translated">内部属性可能会发生变化。如果在其中一个库中引入了向后不兼容的更改，转换代码可能会中断，并且需要更新。</li></ol><h1 id="b549" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">可供选择的事物</h1><p id="095f" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">Checkout <a class="ae mm" href="https://plotly.com/python/cufflinks/" rel="noopener ugc nofollow" target="_blank">袖扣</a>，一个第三方库，为 dataframes 添加了一个<code class="fe ms mt mu mv b">iplot()</code>方法。<code class="fe ms mt mu mv b">df.iplot()</code>之于 Plotly，正如<code class="fe ms mt mu mv b">df.plot()</code>之于 Matplotlib。</p><p id="a055" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">Bokeh 是一个很酷的交互式绘图库。你可以通过运行<code class="fe ms mt mu mv b">pd.set_option('plotting.backend', 'pandas_bokeh')</code>将它设置为你的熊猫<a class="ae mm" href="https://github.com/PatrikHlobil/Pandas-Bokeh" rel="noopener ugc nofollow" target="_blank">绘制后端</a>。</p><p id="28aa" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">同时，<a class="om on ep" href="https://medium.com/u/bfab5e323657?source=post_page-----4bd260e73434--------------------------------" rel="noopener" target="_blank">Nicolas Kruchten</a>(Plotly 产品副总裁)<a class="ae mm" href="https://github.com/plotly/plotly.py/issues/2005#issuecomment-615850935" rel="noopener ugc nofollow" target="_blank">最近评论</a>Plotly 可能会在下一个版本中作为绘图后端选项添加到 pandas！</p></div><div class="ab cl oo op hx oq" role="separator"><span class="or bw bk os ot ou"/><span class="or bw bk os ot ou"/><span class="or bw bk os ot"/></div><div class="im in io ip iq"><p id="ee99" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">我希望你觉得我的周末实验很有趣！此外，请查看我关于<a class="ae mm" rel="noopener" target="_blank" href="/streamlit-101-an-in-depth-introduction-fc8aad9492f2"> Streamlit </a>的教程。</p></div></div>    
</body>
</html>