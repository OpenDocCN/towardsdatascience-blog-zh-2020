<html>
<head>
<title>Facebook Prophet For Time Series Forecasting in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中时间序列预测的脸书预言家</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/facebook-prophet-for-time-series-forecasting-in-python-part1-d9739cc79b1d?source=collection_archive---------9-----------------------#2020-09-08">https://towardsdatascience.com/facebook-prophet-for-time-series-forecasting-in-python-part1-d9739cc79b1d?source=collection_archive---------9-----------------------#2020-09-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jq jr js jt gh gi paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="gh gi gj"><img src="../Images/86bee7b75ddac510fa280c4a1f582bb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iyWl0kveGRhTvPyXDDSlgA.png"/></div></div><p class="ka kb gj gh gi kc kd bd b be z dk translated">预言家预测</p></figure><p id="5323" class="pw-post-body-paragraph ke kf it kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb im bi translated">Prophet 是一个开源的时间序列预测算法，由脸书设计，易于使用，无需任何统计或时间序列预测方面的专家知识。Prophet 通过找到一条最佳平滑线来构建模型，该线可以表示为以下部分的总和<strong class="kg iu">:</strong></p><p id="80bb" class="pw-post-body-paragraph ke kf it kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb im bi translated"><strong class="kg iu"> y(t) = g(t) + s(t) + h(t) + ϵₜ </strong></p><ul class=""><li id="f43b" class="lc ld it kg b kh ki kl km kp le kt lf kx lg lb lh li lj lk bi translated">总体增长趋势。g(t)</li><li id="abf0" class="lc ld it kg b kh ll kl lm kp ln kt lo kx lp lb lh li lj lk bi translated">每年的季节性。s(t)</li><li id="e10c" class="lc ld it kg b kh ll kl lm kp ln kt lo kx lp lb lh li lj lk bi translated">每周季节性。s(t)</li><li id="4b84" class="lc ld it kg b kh ll kl lm kp ln kt lo kx lp lb lh li lj lk bi translated">假日效应 h(t)</li></ul><p id="c3cf" class="pw-post-body-paragraph ke kf it kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb im bi translated">在这篇博文中，我们将会看到下面列出的<code class="fe lq lr ls lt b"><strong class="kg iu">fbprophet</strong></code> <strong class="kg iu"> </strong>库中一些有用的函数，并附有一个例子。</p><ol class=""><li id="e100" class="lc ld it kg b kh ki kl km kp le kt lf kx lg lb lu li lj lk bi translated"><code class="fe lq lr ls lt b"><strong class="kg iu">Prophet.fit</strong></code></li><li id="3ccb" class="lc ld it kg b kh ll kl lm kp ln kt lo kx lp lb lu li lj lk bi translated"><code class="fe lq lr ls lt b"><strong class="kg iu">Prophet.predict</strong></code></li><li id="05d9" class="lc ld it kg b kh ll kl lm kp ln kt lo kx lp lb lu li lj lk bi translated"><code class="fe lq lr ls lt b"><strong class="kg iu">Prophet.plot</strong></code></li><li id="49f1" class="lc ld it kg b kh ll kl lm kp ln kt lo kx lp lb lu li lj lk bi translated"><code class="fe lq lr ls lt b"><strong class="kg iu">Prophet.plot_components</strong></code></li><li id="83da" class="lc ld it kg b kh ll kl lm kp ln kt lo kx lp lb lu li lj lk bi translated"><code class="fe lq lr ls lt b"><strong class="kg iu">Prophet.add_seasonality</strong></code></li><li id="246c" class="lc ld it kg b kh ll kl lm kp ln kt lo kx lp lb lu li lj lk bi translated"><code class="fe lq lr ls lt b"><strong class="kg iu">Prophet.add_regressors</strong></code></li><li id="0eea" class="lc ld it kg b kh ll kl lm kp ln kt lo kx lp lb lu li lj lk bi translated"><code class="fe lq lr ls lt b"><strong class="kg iu">Prophet.seasonalities</strong></code></li><li id="94be" class="lc ld it kg b kh ll kl lm kp ln kt lo kx lp lb lu li lj lk bi translated"><code class="fe lq lr ls lt b"><strong class="kg iu">Prophet.predictive_samples</strong></code></li></ol><p id="3679" class="pw-post-body-paragraph ke kf it kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb im bi translated">让我们从描述我们将在演示中使用的样本数据集开始。</p><h1 id="80a8" class="lv lw it bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">数据描述</h1><p id="0fef" class="pw-post-body-paragraph ke kf it kg b kh mt kj kk kl mu kn ko kp mv kr ks kt mw kv kw kx mx kz la lb im bi translated">我们将使用包含列(<code class="fe lq lr ls lt b"><strong class="kg iu">date</strong></code>、<code class="fe lq lr ls lt b"><strong class="kg iu">target</strong></code>、<code class="fe lq lr ls lt b"><strong class="kg iu">regr1</strong></code>、<code class="fe lq lr ls lt b"><strong class="kg iu">regr2</strong></code>)的合成每日时间序列数据(如下所示)，共 180 天，其中<code class="fe lq lr ls lt b"><strong class="kg iu">target</strong></code>是我们希望每天预测的值，<code class="fe lq lr ls lt b"><strong class="kg iu">regr1</strong></code>、<code class="fe lq lr ls lt b"><strong class="kg iu">regr2</strong></code>是影响目标值的外部因素。</p><p id="d227" class="pw-post-body-paragraph ke kf it kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb im bi translated">让我们通过绘制目标列和回归列来直观地查看数据。</p><pre class="my mz na nb gt nc lt nd ne aw nf bi"><span id="ed00" class="ng lw it lt b gy nh ni l nj nk"># Importing Libraries<br/>import pandas as pd<br/><br/># loading the time series data into a dataframe<br/>df = pd.read_csv('ts_with_2regressors.csv')<br/>df['date'] = pd.to_datetime(df['date'], format='%Y-%m-%d')<br/></span><span id="6d2b" class="ng lw it lt b gy nl ni l nj nk"># plotting the time series data<br/>df.plot(x='date', y='target', figsize=(20, 5), title='Time series Data')</span></pre><figure class="my mz na nb gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="gh gi nm"><img src="../Images/6ce2182cdb92573128a710c4917ab5d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dLsTb7MMTjMiX9iHrIK2DQ.png"/></div></div><p class="ka kb gj gh gi kc kd bd b be z dk translated">样本时间序列数据</p></figure><pre class="my mz na nb gt nc lt nd ne aw nf bi"><span id="2ca1" class="ng lw it lt b gy nh ni l nj nk"># plotting the regressors<br/>ax = df.plot(x='date', y='target', figsize=(20, 5), title='Regressors Effect')</span><span id="66b0" class="ng lw it lt b gy nl ni l nj nk">ticks, _ = plt.xticks()</span><span id="1603" class="ng lw it lt b gy nl ni l nj nk">y_min = df.target.min()<br/>y_max = df.target.max()</span><span id="e548" class="ng lw it lt b gy nl ni l nj nk">plt.vlines(x=list(df[df['regr1'] == 1]['date'].values), ymin=y_min, ymax=y_max, colors='purple', ls='--', lw=2, label='regr1')</span><span id="b087" class="ng lw it lt b gy nl ni l nj nk">plt.vlines(x=list(df[df['regr2'] == 1]['date'].values), ymin=y_min, ymax=y_max, colors='green', ls=':', lw=2, label='regr2')</span><span id="87f3" class="ng lw it lt b gy nl ni l nj nk">plt.legend(bbox_to_anchor=(1.04, 0.5), loc="center left")</span><span id="e5c8" class="ng lw it lt b gy nl ni l nj nk">plt.show()</span></pre><figure class="my mz na nb gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="gh gi nn"><img src="../Images/4908dcf689b74982a995286392b89171.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YJvnSNSpxthgx3NLofFNmQ.png"/></div></div><p class="ka kb gj gh gi kc kd bd b be z dk translated">回归因素效应</p></figure><p id="f63d" class="pw-post-body-paragraph ke kf it kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb im bi translated">我们可以看到，时间序列数据中的尖峰是由回归变量造成的(<code class="fe lq lr ls lt b"><strong class="kg iu">regr1</strong></code>、<code class="fe lq lr ls lt b"><strong class="kg iu">regr2</strong></code>)。在接下来的章节中，我们将看到如何获取这些回归变量并对其建模。</p><h1 id="d106" class="lv lw it bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated"><strong class="ak">先知安装:</strong></h1><p id="bc86" class="pw-post-body-paragraph ke kf it kg b kh mt kj kk kl mu kn ko kp mv kr ks kt mw kv kw kx mx kz la lb im bi translated">和所有 python 库一样，您可以使用 pip 安装<code class="fe lq lr ls lt b"><strong class="kg iu">fbprophet</strong></code>。先知的主要依赖是<code class="fe lq lr ls lt b"><strong class="kg iu">pystan</strong></code>。</p><pre class="my mz na nb gt nc lt nd ne aw nf bi"><span id="531f" class="ng lw it lt b gy nh ni l nj nk"># Install pystan with pip before using pip to install fbprophet</span><span id="6b89" class="ng lw it lt b gy nl ni l nj nk">pip install pystan<br/>pip install fbprophet</span></pre><p id="5b00" class="pw-post-body-paragraph ke kf it kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb im bi translated">现在让我们看看如何使用上述功能:</p><h1 id="3a1d" class="lv lw it bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">生成预测:</h1><ul class=""><li id="cac5" class="lc ld it kg b kh mt kl mu kp no kt np kx nq lb lh li lj lk bi translated">Prophet 遵循 sklearn 模型 API。我们创建了 Prophet 类的一个实例，然后调用它的 fit( <code class="fe lq lr ls lt b"><strong class="kg iu">Prophet.fit</strong></code>)和 predict( <code class="fe lq lr ls lt b"><strong class="kg iu">Prophet.predict</strong></code>)方法。</li><li id="b4e4" class="lc ld it kg b kh ll kl lm kp ln kt lo kx lp lb lh li lj lk bi translated">Prophet 的输入总是一个包含两列的数据帧:<code class="fe lq lr ls lt b"><strong class="kg iu"><em class="nr">ds</em></strong></code>和<code class="fe lq lr ls lt b"><strong class="kg iu"><em class="nr">y</em></strong></code>。<code class="fe lq lr ls lt b"><strong class="kg iu">ds</strong></code>(日期戳)列应该是熊猫所期望的格式，理想的是<code class="fe lq lr ls lt b"><strong class="kg iu">YYYY-MM-DD</strong></code>表示日期，或者<code class="fe lq lr ls lt b"><strong class="kg iu">YYYY-MM-DD HH:MM:SS</strong></code>表示时间戳。<code class="fe lq lr ls lt b"><strong class="kg iu">y</strong></code>列必须是数字，代表我们希望预测的测量值。</li><li id="f154" class="lc ld it kg b kh ll kl lm kp ln kt lo kx lp lb lh li lj lk bi translated"><em class="nr">为了演示，我们将使用前 150 天的</em> <code class="fe lq lr ls lt b"><strong class="kg iu"><em class="nr">target</em></strong></code> <em class="nr">值作为训练数据，并预测所有 180 天的目标。</em></li></ul><p id="d8e7" class="pw-post-body-paragraph ke kf it kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb im bi translated"><strong class="kg iu">注意</strong>:对于这一步，我们将只考虑<code class="fe lq lr ls lt b"><strong class="kg iu">date</strong></code>和<code class="fe lq lr ls lt b"><strong class="kg iu">target</strong></code>列</p><pre class="my mz na nb gt nc lt nd ne aw nf bi"><span id="1e9c" class="ng lw it lt b gy nh ni l nj nk"># Creating train and predict dataframe<br/>df = df.rename(columns={'date':'ds', 'target':'y'})<br/>df_train = df[['ds', 'y']].iloc[:150]<br/>df_predict = df[['ds']]</span><span id="a90f" class="ng lw it lt b gy nl ni l nj nk"><br/># Fitting a Prophet model<br/>model = Prophet()<br/>model.fit(df_train)<br/>forecast = model.predict(df_predict)</span><span id="8bb2" class="ng lw it lt b gy nl ni l nj nk">forecast.head()</span></pre><figure class="my mz na nb gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="gh gi ns"><img src="../Images/db99dd81858b0522ddfd7e17118fd7c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Lwu32V09NIFETpYrIYwrRw.gif"/></div></div><p class="ka kb gj gh gi kc kd bd b be z dk translated">预测标题 GIF</p></figure><pre class="my mz na nb gt nc lt nd ne aw nf bi"><span id="7944" class="ng lw it lt b gy nh ni l nj nk"># plotting the actual and forecast values<br/><br/>ax = (df.plot(x='ds',y='y',figsize=(20,5),title='Actual Vs Forecast'))<br/>forecast.plot(x='ds',y='yhat',figsize=(20,5),title='Actual vs Forecast', ax=ax)</span></pre><figure class="my mz na nb gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="gh gi nt"><img src="../Images/a339a1c60459bdef55581cadd204bfb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P9PSfQ0lYvfA7V1_0cAJug.png"/></div></div><p class="ka kb gj gh gi kc kd bd b be z dk translated">实际与预测</p></figure><p id="4c81" class="pw-post-body-paragraph ke kf it kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb im bi translated">从上面的输出我们可以看到，prophet 非常适合数据，但它仍然无法捕捉数据中的突然跳跃。这些跳跃基本上是由 prophet 在默认情况下无法检测到的外部变量引起的。我们将在接下来的章节中看到如何对 Prophet 建模以捕捉这些外部因素。</p><h1 id="92fa" class="lv lw it bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">绘制预测图:</h1><ul class=""><li id="7bee" class="lc ld it kg b kh mt kl mu kp no kt np kx nq lb lh li lj lk bi translated">我们可以通过调用<code class="fe lq lr ls lt b"><strong class="kg iu">Prophet.plot</strong></code> &amp; <code class="fe lq lr ls lt b"><strong class="kg iu">Prophet.plot_components</strong></code>方法并传入预测数据帧来绘制预测和组件，如下所示</li><li id="41c8" class="lc ld it kg b kh ll kl lm kp ln kt lo kx lp lb lh li lj lk bi translated">预测图是一个包含历史数据点散点图的单一图表，由黑点表示，预测/拟合曲线由蓝线表示。该图还包含对应于不确定性带的浅蓝色阴影区域。</li><li id="a171" class="lc ld it kg b kh ll kl lm kp ln kt lo kx lp lb lh li lj lk bi translated">分量图是一组对应于各种时间序列分量(<code class="fe lq lr ls lt b"><strong class="kg iu">trend</strong></code>、<code class="fe lq lr ls lt b"><strong class="kg iu">seasoanilities</strong></code>)和外部影响的图。</li></ul><pre class="my mz na nb gt nc lt nd ne aw nf bi"><span id="a3cd" class="ng lw it lt b gy nh ni l nj nk"># Plotting the generated forecast<br/>fig1 = model.plot(forecast, uncertainty=True)</span></pre><figure class="my mz na nb gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="gh gi nu"><img src="../Images/68c76fc0d8d1c3218d0624aacd3d0bc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S5gmHhIzLteIukoWXbhc3Q.png"/></div></div><p class="ka kb gj gh gi kc kd bd b be z dk translated">预测产量图</p></figure><pre class="my mz na nb gt nc lt nd ne aw nf bi"><span id="5d4c" class="ng lw it lt b gy nh ni l nj nk"># Plotting the forecast components.<br/>fig2 = model.plot_components(forecast)</span></pre><figure class="my mz na nb gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="gh gi nv"><img src="../Images/6c8835b6537c17aa1df221d03435397b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Op5Dwc1jEvoailAzRIdDw.png"/></div></div><p class="ka kb gj gh gi kc kd bd b be z dk translated">预测组件图</p></figure><p id="ad08" class="pw-post-body-paragraph ke kf it kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb im bi translated">如开始提到的<code class="fe lq lr ls lt b"><strong class="kg iu">Prophet</strong></code>根据训练数据估计了<code class="fe lq lr ls lt b"><strong class="kg iu">trend</strong></code>和<code class="fe lq lr ls lt b"><strong class="kg iu">weekly_seasonality</strong></code>。</p><p id="66f2" class="pw-post-body-paragraph ke kf it kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb im bi translated">现在让我们理解上面的两个图:</p><h1 id="f397" class="lv lw it bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated"><strong class="ak">预测产量图:</strong></h1><ul class=""><li id="2232" class="lc ld it kg b kh mt kl mu kp no kt np kx nq lb lh li lj lk bi translated"><strong class="kg iu"> X 轴</strong>代表历史和未来日期的日期值(<code class="fe lq lr ls lt b"><strong class="kg iu">ds</strong></code> <strong class="kg iu"> ) </strong>。</li><li id="640d" class="lc ld it kg b kh ll kl lm kp ln kt lo kx lp lb lh li lj lk bi translated"><strong class="kg iu"> Y 轴</strong>代表历史和未来日期的目标值(<code class="fe lq lr ls lt b"><strong class="kg iu">y</strong></code>、<code class="fe lq lr ls lt b"><strong class="kg iu">yhat</strong></code>)。</li><li id="2b29" class="lc ld it kg b kh ll kl lm kp ln kt lo kx lp lb lh li lj lk bi translated">图中的<code class="fe lq lr ls lt b"><strong class="kg iu">black dotted points</strong></code>代表历史训练数据点。</li><li id="0349" class="lc ld it kg b kh ll kl lm kp ln kt lo kx lp lb lh li lj lk bi translated"><code class="fe lq lr ls lt b"><strong class="kg iu">blue line</strong></code> <strong class="kg iu"> </strong>代表对历史和未来的预测。</li><li id="d921" class="lc ld it kg b kh ll kl lm kp ln kt lo kx lp lb lh li lj lk bi translated">此外还有代表不确定性范围的<code class="fe lq lr ls lt b"><strong class="kg iu">light blue region</strong></code> <strong class="kg iu"> </strong>(我们将在接下来的章节中看到更多相关内容。)</li></ul><h1 id="71ea" class="lv lw it bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">预测组件图:</h1><ul class=""><li id="db8f" class="lc ld it kg b kh mt kl mu kp no kt np kx nq lb lh li lj lk bi translated"><strong class="kg iu"> X 轴</strong>代表历史和未来日期的日期值(<code class="fe lq lr ls lt b"><strong class="kg iu">ds</strong></code> <strong class="kg iu"> ) </strong>。</li><li id="046a" class="lc ld it kg b kh ll kl lm kp ln kt lo kx lp lb lh li lj lk bi translated"><strong class="kg iu"> Y 轴</strong>代表相应预测成分的预测估计值(<code class="fe lq lr ls lt b"><strong class="kg iu">trend</strong></code>、<code class="fe lq lr ls lt b"><strong class="kg iu">seasonality</strong></code>)</li><li id="f122" class="lc ld it kg b kh ll kl lm kp ln kt lo kx lp lb lh li lj lk bi translated">Graph1: <code class="fe lq lr ls lt b"><strong class="kg iu">trend</strong></code> <strong class="kg iu"> </strong>所有日期的值(历史和未来)。</li><li id="5698" class="lc ld it kg b kh ll kl lm kp ln kt lo kx lp lb lh li lj lk bi translated">Graph2: <code class="fe lq lr ls lt b"><strong class="kg iu">weekly_seasonality</strong></code> <strong class="kg iu"> </strong>基于训练数据的一周中每一天的每周配置文件。</li></ul><p id="c9eb" class="pw-post-body-paragraph ke kf it kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb im bi translated">正如我们所见，使用 prophet 可以很容易地对您的时间序列数据建立合理的预测模型。</p><h1 id="b481" class="lv lw it bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">添加自定义季节</h1><ul class=""><li id="a072" class="lc ld it kg b kh mt kl mu kp no kt np kx nq lb lh li lj lk bi translated">在 Prophet 中，我们可以使用函数<code class="fe lq lr ls lt b"><strong class="kg iu">Prophet.add_seasonality</strong></code>对定制的季节性进行建模。</li><li id="8e0b" class="lc ld it kg b kh ll kl lm kp ln kt lo kx lp lb lh li lj lk bi translated">默认情况下，Prophet 会根据可用的训练数据自动模拟附加的<code class="fe lq lr ls lt b"><strong class="kg iu">daily</strong></code>、<code class="fe lq lr ls lt b"><strong class="kg iu">weekly</strong></code>、<code class="fe lq lr ls lt b"><strong class="kg iu">yearly</strong></code>季节性。</li><li id="ed35" class="lc ld it kg b kh ll kl lm kp ln kt lo kx lp lb lh li lj lk bi translated">我们可以使用函数<code class="fe lq lr ls lt b"><strong class="kg iu">Prophet.seasonalities</strong></code>得到推断的季节性的细节</li><li id="eebd" class="lc ld it kg b kh ll kl lm kp ln kt lo kx lp lb lh li lj lk bi translated">现在让我们用上面的方法来模拟一个<code class="fe lq lr ls lt b"><strong class="kg iu">monthly</strong></code>季节性。</li></ul><pre class="my mz na nb gt nc lt nd ne aw nf bi"><span id="b8f1" class="ng lw it lt b gy nh ni l nj nk"># Modelling a custom monthly seasonality<br/>model2 = Prophet()<br/>model2.add_seasonality(name='custom_monthly', period=30.5, fourier_order=10)</span><span id="ccb5" class="ng lw it lt b gy nl ni l nj nk">model2.fit(df_train)<br/>forecast2 = model2.predict(df_predict)</span><span id="cf12" class="ng lw it lt b gy nl ni l nj nk">print(model2.seasonalities)</span></pre><figure class="my mz na nb gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="gh gi nw"><img src="../Images/d9776f8bb77cad849576d44d67926b4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6DMzh2A3fwMctvohc0S0jg.png"/></div></div></figure><pre class="my mz na nb gt nc lt nd ne aw nf bi"><span id="3dd5" class="ng lw it lt b gy nh ni l nj nk">fig1 = model2.plot(forecast2, uncertainty=True)</span></pre><figure class="my mz na nb gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="gh gi nx"><img src="../Images/0c666f02b473aa0b37b1479d1c575f23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kJoiG04GwScgfaxGZ0uiOg.png"/></div></div></figure><pre class="my mz na nb gt nc lt nd ne aw nf bi"><span id="7c77" class="ng lw it lt b gy nh ni l nj nk">fig2 = model2.plot_components(forecast2, uncertainty=True)</span></pre><figure class="my mz na nb gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="gh gi ny"><img src="../Images/9d06c8ec1a9d7c8a58225e4d483685b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kGUdd410GYS0U2CV-P3qgQ.png"/></div></div></figure><p id="688d" class="pw-post-body-paragraph ke kf it kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb im bi translated">从上图中我们可以看到，Prophet 已经对 custom_monthly 季节性进行了建模，与默认预测相比，预测也有所修改。</p><h1 id="98e1" class="lv lw it bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">添加外部回归变量</h1><p id="4ae4" class="pw-post-body-paragraph ke kf it kg b kh mt kj kk kl mu kn ko kp mv kr ks kt mw kv kw kx mx kz la lb im bi translated">到目前为止，prophet 模型还不能对训练数据中的一些点进行建模。我们知道，由于外部回归因素(<code class="fe lq lr ls lt b"><strong class="kg iu">regr1</strong></code>、<code class="fe lq lr ls lt b"><strong class="kg iu">regr2</strong></code>)，这些值偏离了常规值。</p><p id="9fca" class="pw-post-body-paragraph ke kf it kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb im bi translated">现在让我们看看如何捕捉这些价值并对它们建模。</p><ul class=""><li id="fcf6" class="lc ld it kg b kh ki kl km kp le kt lf kx lg lb lh li lj lk bi translated">与季节性相似，prophet 也有一种方法，使用函数<code class="fe lq lr ls lt b"><strong class="kg iu">Prophet.add_regressors</strong></code>捕捉/模拟对目标值有影响的外部因素。</li><li id="a0cc" class="lc ld it kg b kh ll kl lm kp ln kt lo kx lp lb lh li lj lk bi translated">在我们使用的样本数据中，我们提到了影响目标值的两个外部回归量。</li><li id="a6d3" class="lc ld it kg b kh ll kl lm kp ln kt lo kx lp lb lh li lj lk bi translated">为了模拟和预测回归变量的影响，训练和预测数据框架都应该包含回归变量数据。</li><li id="7dcf" class="lc ld it kg b kh ll kl lm kp ln kt lo kx lp lb lh li lj lk bi translated">现在让我们来看看如何使用上述函数对这些回归变量进行建模。</li></ul><p id="d087" class="pw-post-body-paragraph ke kf it kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb im bi translated"><strong class="kg iu">注意</strong>:回归变量应该是数值，如果回归变量包含字符串数据，您必须执行一次热编码。</p><pre class="my mz na nb gt nc lt nd ne aw nf bi"><span id="3cca" class="ng lw it lt b gy nh ni l nj nk"># adding regressor data in historical and future dates</span><span id="b472" class="ng lw it lt b gy nl ni l nj nk">df_train3 = (df[['ds', 'y', 'regr1', 'regr2']]<br/>             .iloc[:150]<br/>             .copy())<br/>df_predict3 = df[['ds', 'regr1', 'regr2']].copy()</span><span id="692b" class="ng lw it lt b gy nl ni l nj nk"># modelling external regressors prior to model fitting</span><span id="67a3" class="ng lw it lt b gy nl ni l nj nk">model3 = Prophet()<br/>model3.add_regressor('regr1')<br/>model3.add_regressor('regr2')<br/><br/><br/># fit and predcit<br/>model3.fit(df_train3)<br/>forecast3 = model3.predict(df_predict3)</span><span id="a811" class="ng lw it lt b gy nl ni l nj nk"># Plot the forecast<br/>fig1 = model3.plot(forecast3, uncertainty=True)</span></pre><figure class="my mz na nb gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="gh gi gj"><img src="../Images/86bee7b75ddac510fa280c4a1f582bb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iyWl0kveGRhTvPyXDDSlgA.png"/></div></div><p class="ka kb gj gh gi kc kd bd b be z dk translated">具有外部回归变量的先知模型</p></figure><pre class="my mz na nb gt nc lt nd ne aw nf bi"><span id="4e84" class="ng lw it lt b gy nh ni l nj nk"># plot model components<br/>fig2 = model3.plot_components(forecast3, uncertainty=True)</span></pre><figure class="my mz na nb gt jt gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/6f50233a984612ef1a4c22fb8db07885.png" data-original-src="https://miro.medium.com/v2/resize:fit:1336/format:webp/1*9mdVyCuGrcqq6IxddPzScA.png"/></div><p class="ka kb gj gh gi kc kd bd b be z dk translated">具有外部回归的先知模型组件</p></figure><p id="81d2" class="pw-post-body-paragraph ke kf it kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb im bi translated">从上面的输出中，我们可以观察到该模型已经很好地捕捉到了两个外部影响，从输出图中，我们可以看到目标值相对于回归变量有大约 5%和 20%的提升。</p><h1 id="7589" class="lv lw it bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">先知后验样本</h1><ul class=""><li id="328c" class="lc ld it kg b kh mt kl mu kp no kt np kx nq lb lh li lj lk bi translated">默认情况下，prophet 每天生成 1000 个后验样本，以估计不确定性范围的上限和下限。在某一天，后验样本的平均值几乎等于预测值<code class="fe lq lr ls lt b"><strong class="kg iu">yhat</strong></code></li><li id="bc42" class="lc ld it kg b kh ll kl lm kp ln kt lo kx lp lb lh li lj lk bi translated">Prophet 可以使用函数<code class="fe lq lr ls lt b"><strong class="kg iu">Prophet.predictive_samples</strong></code>访问历史和未来某一天的后验样本</li><li id="8b8e" class="lc ld it kg b kh ll kl lm kp ln kt lo kx lp lb lh li lj lk bi translated">我们可以使用参数<code class="fe lq lr ls lt b"><strong class="kg iu">uncertainty_samples</strong></code>在 prophet 实例化时修改样本数量</li><li id="48e3" class="lc ld it kg b kh ll kl lm kp ln kt lo kx lp lb lh li lj lk bi translated">现在让我们用预测数据帧中 1 周的后验样本生成一个数据帧。</li></ul><pre class="my mz na nb gt nc lt nd ne aw nf bi"><span id="cd2d" class="ng lw it lt b gy nh ni l nj nk"># Select one week from prediction df<br/>df_1wk = df_predict3.iloc[:7]<br/>df_1wk</span></pre><figure class="my mz na nb gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="gh gi oa"><img src="../Images/db767c30a7db734812b38cec9805c5a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1e8TFNY_9JFKE6ySfsl-aA.png"/></div></div></figure><pre class="my mz na nb gt nc lt nd ne aw nf bi"><span id="4e69" class="ng lw it lt b gy nh ni l nj nk"># fetching the posterior samples.<br/>samples = model3.predictive_samples(df_1wk)</span><span id="ea35" class="ng lw it lt b gy nl ni l nj nk">df_samples = pd.DataFrame(data=samples['yhat'], index=df_1wk['ds']).reset_index()</span><span id="5ff3" class="ng lw it lt b gy nl ni l nj nk">df_samples</span></pre><figure class="my mz na nb gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="gh gi ob"><img src="../Images/0ae76c866650c487a6b3251f88e7fc08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cCYfDZ1xVGqREEe5rIcewQ.png"/></div></div></figure><p id="a420" class="pw-post-body-paragraph ke kf it kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb im bi translated">现在让我们计算一天后验样本的平均值，并将其与当天的预测值进行比较。</p><pre class="my mz na nb gt nc lt nd ne aw nf bi"><span id="5258" class="ng lw it lt b gy nh ni l nj nk"># Forecast <br/>forecast3[forecast3['ds'] == '2018-09-02'][['ds', 'yhat']]</span></pre><figure class="my mz na nb gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="gh gi oc"><img src="../Images/5351520acadbc75a1e06b7120cad9cb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D3sVRyEtLwDCyYLohqv6gQ.png"/></div></div></figure><pre class="my mz na nb gt nc lt nd ne aw nf bi"><span id="5384" class="ng lw it lt b gy nh ni l nj nk"># Mean of the posterior samples.<br/>df_samples[df_samples['ds'] == '2018-09-02'].set_index('ds').mean(axis=1)</span></pre><figure class="my mz na nb gt jt gh gi paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="gh gi od"><img src="../Images/ea78bc5d68209241e5a0fd43c7f854ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*su_3moW4NlPclzEUffyEXg.png"/></div></div></figure><p id="7980" class="pw-post-body-paragraph ke kf it kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb im bi translated">我们可以看到后验样本的平均值几乎等于某一天的预测值。</p><h1 id="d573" class="lv lw it bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">结论:</h1><p id="1955" class="pw-post-body-paragraph ke kf it kg b kh mt kj kk kl mu kn ko kp mv kr ks kt mw kv kw kx mx kz la lb im bi translated">我们的演示到此结束。希望你会发现这篇文章内容丰富。您可以在以下存储库中找到数据和 Jupyter 笔记本:</p><div class="oe of gp gr og oh"><a href="https://github.com/upraneelnihar/ML-Projects/tree/master/Time_series" rel="noopener  ugc nofollow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd iu gy z fp om fr fs on fu fw is bi translated">upraneelnihar/ML-项目</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">此文件夹包含与各种时间序列任务相关的 jupyter 笔记本:Time _ series _ analysis _ FB prophet . ipynb:This…</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">github.com</p></div></div><div class="oq l"><div class="or l os ot ou oq ov jy oh"/></div></div></a></div><p id="476f" class="pw-post-body-paragraph ke kf it kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb im bi translated">请尝试使用 prophet 为您的时间序列数据建模，并在评论部分分享您的想法。</p></div></div>    
</body>
</html>