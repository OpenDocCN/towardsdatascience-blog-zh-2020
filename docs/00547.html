<html>
<head>
<title>Building a sentence embedding index with fastText and BM25</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用fastText和BM25建立句子嵌入索引</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-a-sentence-embedding-index-with-fasttext-and-bm25-f07e7148d240?source=collection_archive---------7-----------------------#2020-01-16">https://towardsdatascience.com/building-a-sentence-embedding-index-with-fasttext-and-bm25-f07e7148d240?source=collection_archive---------7-----------------------#2020-01-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4f12" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">探索如何建立一个文本搜索系统</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d46473139714c74ec6975f4b99b163be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_-8Z4xsDMY1rE2PS"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">杰西卡·鲁斯切洛在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="e63c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">本文涵盖了句子嵌入和</em><a class="ae ky" href="https://github.com/neuml/codequestion" rel="noopener ugc nofollow" target="_blank"><em class="lv">code question</em></a><em class="lv">1.0。最新发布的codequestion使用了句子转换器。</em> <a class="ae ky" href="https://medium.com/neuml/find-answers-with-codequestion-2-0-50b2cfd8c8fe" rel="noopener"> <em class="lv">此处阅读更多</em> </a> <em class="lv">。</em></p><p id="8061" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lw translated">自然语言处理是机器学习领域中发展最快的领域之一。许多领域都在发生深度创新，让用户能够更快地找到更好的数据。曾经只有拥有大量IT预算和资源的人才能实现的技术和算法现在可以在笔记本电脑上运行。虽然NLP不是一个新问题，但是有一些经过时间考验的方法表现得非常好。最简单的方案很多时候可能是最好的方案。</p><p id="ac52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文将探索各种方法，并对构建文本搜索系统进行评估。</p><h2 id="6bf6" class="mf mg it bd mh mi mj dn mk ml mm dp mn li mo mp mq lm mr ms mt lq mu mv mw mx bi translated">全文搜索引擎</h2><p id="a94b" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">允许用户输入搜索查询并找到匹配结果的全文搜索引擎是一种可靠的解决方案，具有很好的性能历史。在这些系统中，每个文档都被标记化，通常去掉一列常用词，称为停用词。这些令牌存储在倒排索引中，每个令牌都根据令牌频率等指标进行加权。</p><p id="0a80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">搜索查询也使用相同的方法进行标记化，并且搜索引擎为查询标记找到最佳匹配记录。有一些高度分布式且非常快速的解决方案已经在生产中证明了自己多年，比如<a class="ae ky" href="https://www.elastic.co/" rel="noopener ugc nofollow" target="_blank"> Elasticsearch </a>。今天最常见的令牌加权算法是<a class="ae ky" href="https://en.wikipedia.org/wiki/Okapi_BM25" rel="noopener ugc nofollow" target="_blank"> BM25 </a>。它工作得非常好，仍然很难被击败。</p><h2 id="80bf" class="mf mg it bd mh mi mj dn mk ml mm dp mn li mo mp mq lm mr ms mt lq mu mv mw mx bi translated">嵌入</h2><p id="9b49" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">单词嵌入在过去的5-7年里发展迅速，首先从<a class="ae ky" href="https://en.wikipedia.org/wiki/Word2vec" rel="noopener ugc nofollow" target="_blank"> Word2vec </a>开始，接着是<a class="ae ky" href="https://en.wikipedia.org/wiki/GloVe_(machine_learning)" rel="noopener ugc nofollow" target="_blank"> GloVe </a>和<a class="ae ky" href="https://en.wikipedia.org/wiki/FastText" rel="noopener ugc nofollow" target="_blank"> fastText </a>。这些算法通常都构建300维向量。现在有了更高级的嵌入，它们的尺寸更大(768+维度)，能够理解句子中单词的上下文，其中<a class="ae ky" href="https://en.wikipedia.org/wiki/BERT_(language_model)" rel="noopener ugc nofollow" target="_blank"> BERT </a>嵌入处于领先地位。换句话说，超越简单的单词包方法。</p><p id="52e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">易于使用、健壮的库已经存在，使开发人员能够利用这些进步。<a class="ae ky" href="https://github.com/huggingface/transformers" rel="noopener ugc nofollow" target="_blank"> HuggingFace Transformers </a>是一个优秀的库，拥有一组快速增长的前沿功能。通用句子嵌入是另一个重要的发展领域。拥有一个单一的动态模型，可以将文本转换为下游学习任务的嵌入是至关重要的。<a class="ae ky" href="https://github.com/UKPLab/sentence-transformers" rel="noopener ugc nofollow" target="_blank">句子变形金刚</a>构建在变形金刚之上，是一个可以构建高质量句子嵌入的库的优秀例子。</p><h2 id="91c4" class="mf mg it bd mh mi mj dn mk ml mm dp mn li mo mp mq lm mr ms mt lq mu mv mw mx bi translated">性能考虑因素</h2><p id="dddd" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">随着构建完美嵌入的步伐越来越快，这对试图解决当前业务问题的实践者来说意味着什么。你总是使用最新和最大的进步吗？你总是需要吗？有更复杂的权衡。当处理数百万甚至数十亿个数据点时，处理时间与可接受的功能之间的关系总是一个需要讨论的话题。这些对话考虑了可用的资源、可用的时间以及满足给定问题的要求所必需的内容。</p><p id="0e0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">评估文本搜索解决方案时要问的一些问题。</p><ul class=""><li id="4a1f" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">我需要多快的查询响应和索引速度？需要多高的精确度？</li><li id="eb03" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">我可以访问哪些计算资源？我可以访问GPU吗？</li><li id="9df4" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">我有多少条记录和多少存储空间？假设向量使用32位(4字节)浮点，一个300维的向量每条记录需要300x4字节。对于4096维向量，它是4096x4，对于相同的数据，需要13倍多的空间。</li><li id="a918" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">一个全文搜索引擎能满足要求吗？</li></ul><h2 id="12ae" class="mf mg it bd mh mi mj dn mk ml mm dp mn li mo mp mq lm mr ms mt lq mu mv mw mx bi translated">我们在建造什么？</h2><p id="cec5" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><a class="ae ky" href="https://github.com/neuml/codequestion" rel="noopener ugc nofollow" target="_blank"> codequestion </a>是一个允许用户直接从终端询问编码问题的应用程序。许多开发人员在开发和运行web搜索时会打开一个web浏览器窗口，因为会出现问题。codequestion致力于加快这一过程，以便您可以专注于开发。它还允许无法直接访问互联网或互联网访问受限的用户运行代码问题查询。下面是一个实际应用的例子。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/47668b13563564b6a8c3334051cafd61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*FSnkgyBVG5O43waQRQyRaw.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">codequestion应用程序演示</p></figure><p id="1a9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">codequestion由一个<a class="ae ky" href="https://en.wikipedia.org/wiki/SQLite" rel="noopener ugc nofollow" target="_blank"> SQLite </a>数据库提供支持，该数据库存储了问答回复。提供了使用<a class="ae ky" href="https://archive.org/details/stackexchange" rel="noopener ugc nofollow" target="_blank">堆栈交换数据</a>的预训练模型。该数据库还可以加载自定义的问题列表。</p><h2 id="0f69" class="mf mg it bd mh mi mj dn mk ml mm dp mn li mo mp mq lm mr ms mt lq mu mv mw mx bi translated">精心设计解决方案</h2><p id="9b66" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">最好总是从最简单的解决方案开始，然后一步一步往上走。我们能不能对数据做一个全文索引，然后就到此为止？添加外部文本索引并不是我们所希望的，因为这个应用程序被设计为本地安装在开发人员的机器上。SQLite确实提供了一个名为FTS5的文本索引解决方案。这是很容易添加的，似乎工作得很好。但是一种测量结果的方法对于真正判断它的效果是必要的。</p><h2 id="c098" class="mf mg it bd mh mi mj dn mk ml mm dp mn li mo mp mq lm mr ms mt lq mu mv mw mx bi translated">评估结果</h2><p id="f339" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">构建了一个包含100个查询的数据集来判断一个索引的工作情况。对于每个查询，手动运行web搜索，并为该查询存储顶部堆栈交换结果。选择了流行的查询(即在python中解析日期),并注意不总是在查询和答案之间有直接的标记匹配。</p><p id="6ea6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Mean_reciprocal_rank" rel="noopener ugc nofollow" target="_blank">平均倒数排名(MRR) </a>用于测量人工注释的搜索查询的最高结果得分。标准FTS5索引对100个查询数据集的评分如下。</p><p id="1977" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv"> MRR = 45.9 </em></p><p id="8bb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为开始还不算太坏。是时候增加复杂性来决定权衡是否值得了。</p><h2 id="63d9" class="mf mg it bd mh mi mj dn mk ml mm dp mn li mo mp mq lm mr ms mt lq mu mv mw mx bi translated"><strong class="ak"> BM25 </strong></h2><p id="640f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">SQLite的FTS5默认令牌加权方案是使用<a class="ae ky" href="https://en.wikipedia.org/wiki/Tf%E2%80%93idf" rel="noopener ugc nofollow" target="_blank"> tf-idf </a>。它还支持BM25，得分为:</p><p id="8163" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv"> MRR = 49.5 </em></p><p id="acd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">绝对是个进步。但感觉还是有很大的提升空间。让我们试试句子嵌入。</p><h2 id="1699" class="mf mg it bd mh mi mj dn mk ml mm dp mn li mo mp mq lm mr ms mt lq mu mv mw mx bi translated"><strong class="ak">快速文本句子嵌入</strong></h2><p id="41eb" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">标准文本标记搜索正被同义词和不完全匹配所困扰。单词嵌入是找到不完全匹配的相似结果的好方法。</p><p id="5a4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所需功能的示例如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/67f7657dd4a75be2a797e821e0ffa4c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*PQW1XrwnffUUkrUaEMRTew.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">linux解码音频文件查询</p></figure><p id="81b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查询“linux解码音频文件”返回了类似“通过linux命令行播放mp3或wav文件”的问题。单词decode和audio没有出现在返回的结果中，但是decode类似于play，audio类似于mp3/wav。</p><p id="bd57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的示例查询被标记为["linux "，" decode "，" audio "，" file"]。可以使用fastText为每个标记检索单词嵌入。为了构建句子嵌入，嵌入可以被平均在一起以创建单个嵌入向量。</p><h2 id="b28b" class="mf mg it bd mh mi mj dn mk ml mm dp mn li mo mp mq lm mr ms mt lq mu mv mw mx bi translated">快速文本+ BM25</h2><p id="4cfa" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">平均效果出奇的好。但是如果我们可以两全其美，使用BM25来衡量每个标记对句子嵌入的贡献有多大呢？这就是codequestion采用的方法。BM25索引建立在数据集之上。使用<a class="ae ky" href="https://fasttext.cc/docs/en/english-vectors.html" rel="noopener ugc nofollow" target="_blank">预先训练的快速文本</a>向量加上BM25，得分为:</p><p id="8449" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv"> MRR = 66.1 </em></p><p id="1b5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">比直BM25 (66.1比49.5)有相当大的进步！</p><h2 id="ad74" class="mf mg it bd mh mi mj dn mk ml mm dp mn li mo mp mq lm mr ms mt lq mu mv mw mx bi translated">定制训练的快速文本嵌入</h2><p id="a1d0" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">这种级别的功能是性能和结果的可接受组合。但还有最后一件事可以尝试，这可能会进一步提高分数，即在问题数据库本身上定制训练的fastText嵌入模型。使用根据数据分数训练的fastText嵌入，如下所示:</p><p id="2412" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv"> MRR = 76.3 </em></p><p id="d813" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">又一次，相当大的进步。我们可以继续尝试BERT嵌入模型，该模型得分更高，但也需要更多计算/存储。fastText + BM25不考虑顺序，所以类似“python convert UTC to localtime”的查询可以匹配“python convert localtime to UTC”。BERT会更好地处理这个用例。但是对于这个项目，嵌入方法工作得很好。</p><h2 id="2260" class="mf mg it bd mh mi mj dn mk ml mm dp mn li mo mp mq lm mr ms mt lq mu mv mw mx bi translated">构建索引</h2><p id="0928" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">嵌入本身只是一堆数字。一旦完整的数据存储库被转换为句子嵌入，就需要有一种方法来为查询找到相似的结果。</p><p id="bb6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Cosine_similarity" rel="noopener ugc nofollow" target="_blank">余弦相似度</a>是比较两个向量相似程度的常用方法。最简单的方法是强力比较查询向量和每个结果，并返回最相似的结果。对于小型数据集，这种方法很有效。但是随着数据的增长，它无法扩展。</p><p id="8a88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Faiss 是一个向量相似性搜索库，可以在这方面提供帮助。它可以量化向量以减少存储量，并支持可扩展的近似最近邻搜索。Faiss支持高性能搜索，提供结果准确性和速度的良好结合。</p><h2 id="a221" class="mf mg it bd mh mi mj dn mk ml mm dp mn li mo mp mq lm mr ms mt lq mu mv mw mx bi translated">结论</h2><p id="2b82" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">本文介绍了一种评估如何构建搜索系统的方法，从而产生一个句子嵌入索引。这条路不会总是通向同一个终点，但是像这样的渐进方法应该有助于找到问题的最佳解决方案。</p></div></div>    
</body>
</html>