<html>
<head>
<title>Polymorphism in Python: Fundamentals For Data Scientists</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中的多态性:数据科学家的基础</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/polymorphism-in-python-fundamentals-for-data-scientists-9dc19071da55?source=collection_archive---------34-----------------------#2020-06-16">https://towardsdatascience.com/polymorphism-in-python-fundamentals-for-data-scientists-9dc19071da55?source=collection_archive---------34-----------------------#2020-06-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b1a3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用一个具体的例子来理解基础！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c4680a05bea0903704cfe21b4523b930.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2qXlSstOrYN5jPiy"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的<a class="ae ky" href="https://unsplash.com/@thisisengineering?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> ThisisEngineering RAEng </a></p></figure><p id="7bff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">多态是面向对象编程中的另一个重要概念。</p><p id="3eb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当这些类包含具有不同实现但名称相同的方法时，它们就是多态的。在这种情况下，我们可以使用这些多态类的对象，而不用考虑这些类之间的差异。它允许我们有一个界面来以许多不同的方式执行类似的任务。</p><p id="2f07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">多态性通过增加灵活性使代码易于更改、维护和扩展。</p><p id="0861" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章将向你介绍在 Python 中实现多态性的基础知识。</p><p id="509a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们编写一个 Python3 代码，其中包含简单的多态例子；</p><h1 id="cdd0" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">函数和对象的多态性</h1><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="64c1" class="ms lw it mo b gy mt mu l mv mw"><em class="mx">class</em> <strong class="mo iu">CSVColumnOne:<br/> </strong><em class="mx">def</em> <strong class="mo iu">col_count</strong>(<em class="mx">self</em>):<br/>  print(“Column One — count function is called.”)</span><span id="4fc8" class="ms lw it mo b gy my mu l mv mw"><em class="mx">def</em> <strong class="mo iu">col_mean</strong>(<em class="mx">self</em>):<br/>  print(“Column One — mean function is called.”)</span><span id="1a2a" class="ms lw it mo b gy my mu l mv mw"><em class="mx">def</em> <strong class="mo iu">col_std</strong>(<em class="mx">self</em>):<br/>  print(“Column One — std function is called.”)</span><span id="f5db" class="ms lw it mo b gy my mu l mv mw"><em class="mx">class</em> <strong class="mo iu">CSVColumnTwo:<br/> </strong><em class="mx">def</em> <strong class="mo iu">col_count</strong>(<em class="mx">self</em>):<br/>  print(“Column Two — count function is called.”)</span><span id="ca1d" class="ms lw it mo b gy my mu l mv mw"><em class="mx">def</em> <strong class="mo iu">col_mean</strong>(<em class="mx">self</em>):<br/>  print(“Column Two — mean function is called.”)</span><span id="84c8" class="ms lw it mo b gy my mu l mv mw"><em class="mx">def</em> <strong class="mo iu">col_std</strong>(<em class="mx">self</em>):<br/>  print(“Column Two — std function is called.”)</span></pre><p id="60fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面你可以看到我们有两个不同的类，<strong class="lb iu"> <em class="mx"> CSVColumnOne </em> </strong>和<strong class="lb iu"> <em class="mx"> CSVColumnTwo。</em> </strong>而<strong class="lb iu"> <em class="mx"> </em> </strong>它们之间没有任何联系，它们有三个同名的方法。虽然它们的名字相同，但每个类中的方法执行类似任务的方式不同。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="af4c" class="ms lw it mo b gy mt mu l mv mw"><em class="mx">def</em> <strong class="mo iu">func</strong>(<em class="mx">obj</em>):<br/> obj.col_count()<br/> obj.col_mean()<br/> obj.col_std()</span><span id="a6bd" class="ms lw it mo b gy my mu l mv mw"><strong class="mo iu">obj_col_one</strong> = CSVColumnOne()<br/><strong class="mo iu">obj_col_two</strong> = CSVColumnTwo()</span><span id="2bac" class="ms lw it mo b gy my mu l mv mw">func(<strong class="mo iu">obj_col_one</strong>)<br/>func(<strong class="mo iu">obj_col_two</strong>)</span><span id="fb32" class="ms lw it mo b gy my mu l mv mw"><strong class="mo iu">Output:</strong><br/>Column One - count function is called.<br/>Column One - mean function is called.<br/>Column One - std function is called.<br/>Column Two - count function is called.<br/>Column Two - mean function is called.<br/>Column Two - std function is called.</span></pre><p id="7760" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于 Python 中的多态性，我们可以通过将每个类的对象传递给函数来创建调用方法的函数，而不用考虑不同类的对象如何不同地执行任务。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/73cbf1e63555a7f6b4696ea4ad5d45ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*s2k9Gs9ZrrMJi5le"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@louangm?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Louan García </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="8203" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak"> Python 内置的多态函数</strong></h1><p id="bc84" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">Python 中有很多内置的多态函数。举个例子，就拿<strong class="lb iu"> <em class="mx"> len() </em> </strong>函数来说吧；</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="7674" class="ms lw it mo b gy mt mu l mv mw"><strong class="mo iu"># len() being used for a string</strong><br/>print(len("Data Science"))</span><span id="c6aa" class="ms lw it mo b gy my mu l mv mw"><strong class="mo iu"># len() being used for a list</strong><br/>print(len([1, 2, 3, 4]))</span><span id="8432" class="ms lw it mo b gy my mu l mv mw"><strong class="mo iu">Output:<br/></strong>12<br/>4</span></pre><p id="3068" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上面可以看出，我们可以对不同类型的对象使用<strong class="lb iu"> <em class="mx"> len() </em> </strong>函数，而无需考虑该函数将如何处理基于对象类型差异的任务。这使得代码直观易读。</p><h1 id="4ee1" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">具有类方法和继承的多态性</h1><p id="6669" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">继承允许我们从其他类中派生出函数和数据定义，以增加代码的可重用性。下面可以看到<strong class="lb iu"> <em class="mx"> CSVColumnSub </em> </strong>类是<strong class="lb iu"> <em class="mx"> CSVColumn </em> </strong>的子类。</p><p id="5967" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="mx"> CSVColumnSub </em> </strong>类通过重写<strong class="lb iu"> <em class="mx"> col_mean() </em> </strong>方法来继承基类的<strong class="lb iu"> <em class="mx"> col_count() </em> </strong>和<strong class="lb iu"> <em class="mx"> col_mean() </em> </strong>方法，以具有特定于子类的不同实现。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="a841" class="ms lw it mo b gy mt mu l mv mw"><em class="mx">class</em> <strong class="mo iu">CSVColumn</strong>:<br/> <em class="mx">def</em> <strong class="mo iu">col_count</strong>(<em class="mx">self</em>):<br/> print("Count function is called for all columns.")</span><span id="4d9a" class="ms lw it mo b gy my mu l mv mw"><em class="mx"> def</em> <strong class="mo iu">col_mean</strong>(<em class="mx">self</em>):<br/>  print("Mean function is called for all columns.")</span><span id="5fe8" class="ms lw it mo b gy my mu l mv mw"><em class="mx">class</em> <strong class="mo iu">CSVColumnSub</strong>(<em class="mx">CSVColumn</em>):<br/> <em class="mx">def</em> <strong class="mo iu">col_mean</strong>(<em class="mx">self</em>):<br/>  print("Mean function is called for only sub-columns.")</span></pre><p id="82db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于多态，我们可以调用基类和子类中同名的方法，而不用考虑每个类中方法的不同实现。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="ab4e" class="ms lw it mo b gy mt mu l mv mw"><strong class="mo iu">obj_col_all</strong> = CSVColumn()<br/><strong class="mo iu">obj_col_sub</strong> = CSVColumnSub()</span><span id="0dc7" class="ms lw it mo b gy my mu l mv mw"><strong class="mo iu">obj_col_all.col_count()<br/>obj_col_all.col_mean()</strong></span><span id="6747" class="ms lw it mo b gy my mu l mv mw"><strong class="mo iu">obj_col_sub.col_count()<br/>obj_col_sub.col_mean()</strong></span><span id="6e05" class="ms lw it mo b gy my mu l mv mw"><strong class="mo iu">Output:</strong><br/>Count function is called for all columns.<br/>Mean function is called for all columns.<br/>Count function is called for all columns.<br/>Mean function is called for only sub-columns.</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/2766ac9b87a820e7c484de7360a3cd40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Dmc2mklNdMP69K9u"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@emerald_?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">诺亚·博耶</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="1309" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">关键要点</h1><ul class=""><li id="aebc" class="ng nh it lb b lc na lf nb li ni lm nj lq nk lu nl nm nn no bi translated">多态性允许我们用一个接口以多种不同的方式执行相似的任务。</li><li id="8882" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">多态性通过增加灵活性使代码易于更改、维护和扩展。</li></ul><h1 id="1b5e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="7c94" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">在这篇文章中，我解释了 Python 中多态性的基础。</p><p id="74e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章中的代码可以在我的 GitHub 库中找到。</p><p id="43f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这篇文章对你有用。</p><p id="4f43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读！</p></div></div>    
</body>
</html>