<html>
<head>
<title>You Should Start Using Type Annotations in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您应该开始在 Python 中使用类型注释</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-type-annotations-and-why-you-should-use-them-6f647c6b4e9c?source=collection_archive---------5-----------------------#2020-08-17">https://towardsdatascience.com/python-type-annotations-and-why-you-should-use-them-6f647c6b4e9c?source=collection_archive---------5-----------------------#2020-08-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/d636968c02bf36df8fb5de629a2af895.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fuLO9QZDnOpSTmj-"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://unsplash.com/@raduflorin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">拉杜·弗罗林</a>在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><div class=""/><div class=""><h2 id="ad15" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">因为动态类型化，你花了多少时间调试？</h2></div><p id="dc5a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我刚开始学 Python 的时候，是 C 背景。我当时没有丰富的软件开发经验，动态打字提供的自由的滋味是如此甜蜜。利用多态和鸭类型的函数允许我用很少的资源做很多事情。</p><p id="9e16" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">后来，随着我的经验增长，我开始参与大型项目，我逐渐明白这种自由是福<em class="lu">而</em>是祸。随着贡献者的增加，代码越来越接近产品级，没有静态类型或类型检查会导致令人讨厌的意外。</p><p id="28d9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是 Python 生态系统中许多人的共同感受。然而，保持动态类型所允许的自由，但减轻其负面影响是困难的。</p><p id="2825" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输入<em class="lu">类型注释</em>。</p><p id="d321" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果 Python 中有一个特性可以最大限度地增加对代码的积极影响，同时只需要最少的努力，那就是<em class="lu">类型注释</em>。它允许开发人员与解释器(以及其他开发人员)有效地交流预期的参数类型和返回值，同时保持动态类型的优势。</p><h1 id="d7ce" class="lv lw jj bd lx ly lz ma mb mc md me mf kp mg kq mh ks mi kt mj kv mk kw ml mm bi translated">Python 中的动态类型</h1><p id="33ef" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">那么，什么是动态类型呢？为了看到这一点，让我们来玩一玩。</p><figure class="mt mu mv mw gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ms"><img src="../Images/6340ae53444be3227b2a2d11e476f8ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G9Mrsc_B4_DxBZQv7uzEzQ.png"/></div></div></figure><p id="9ace" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在幕后，Python 中类似上面<code class="fe mx my mz na b">a</code>的变量是<em class="lu">指针</em>，指向某一类型的对象。然而，指针并不局限于表示给定名称的固定类型的对象。这给了我们很大的自由。例如，函数可以接受任何类型作为参数，因为在后台会传递一个指针。</p><p id="b6a1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不幸的是，如果没有适当的照顾，这可能会很快出错。</p><h2 id="cee9" class="nb lw jj bd lx nc nd dn mb ne nf dp mf lh ng nh mh ll ni nj mj lp nk nl ml nm bi translated">动态类型是一把双刃剑</h2><p id="f007" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">想想下面的例子。</p><figure class="mt mu mv mw gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nn"><img src="../Images/180272664f56af379eab09b741089f57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ELXq9LMxexmvaixO2WdYIQ.png"/></div></div></figure><p id="667c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个简单的统计函数也适用于列表和 NumPy 数组！多牛逼啊！</p><p id="a98e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">嗯，不完全是。有很多方法可以烧伤你自己。例如，您可能会无意中传递一些东西，导致函数崩溃。如果我们用一个字符串调用函数，就会发生这种情况。</p><figure class="mt mu mv mw gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi no"><img src="../Images/dd1fa596f9adab32a493ddfdc0345ddb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L8GG7ZKCMYlU9h70657AsA.png"/></div></div></figure><p id="039e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">没有在字符串和整数之间定义除法运算符，因此错误。因为 Python 是一种解释型语言，所以这个问题不会出现，直到函数被错误的参数调用。这可能需要几周的运行时间。像 C 这样的语言可以在编译时间<em class="lu">捕捉这些错误，以免出错。</em></p><p id="25cd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">事情可能会变得更糟。例如，让我们用<em class="lu">字典</em>调用函数。</p><figure class="mt mu mv mw gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi np"><img src="../Images/6918e7e248eab492b5cf335316434160.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gHuJnrPZ7AvKSxfO5N2vTQ.png"/></div></div></figure><p id="b24b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">执行成功，但是<em class="lu">结果错误</em>。当一个字典被传递时，<code class="fe mx my mz na b">min</code>和<code class="fe mx my mz na b">max</code>函数计算<em class="lu">键</em>的最小值和最大值，而不是我们想要的值。这种错误可能会在很长一段时间内不被发现，同时，你会觉得一切都很好。</p><p id="cc5a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看我们能做些什么来避免这样的问题！</p><h1 id="4e7f" class="lv lw jj bd lx ly lz ma mb mc md me mf kp mg kq mh ks mi kt mj kv mk kw ml mm bi translated">输入函数注释和类型提示</h1><p id="0c3e" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">2006 年，<a class="ae jg" href="https://www.python.org/dev/peps/pep-3107/" rel="noopener ugc nofollow" target="_blank"> PEP 3107 </a>引入了<em class="lu">函数注释</em>，在<a class="ae jg" href="https://www.python.org/dev/peps/pep-0484" rel="noopener ugc nofollow" target="_blank"> PEP 484 </a>中扩展了<em class="lu">类型提示</em>。(PEP 是 Python Enhancement Proposal 的简称，是 Python 建议和讨论新语言特性的方式。)</p><p id="a890" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">函数注释就是<em class="lu">“一种向 Python 函数添加任意元数据注释的语法”</em>，如 PEP 3107 所述。实际情况如何？</p><figure class="mt mu mv mw gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nq"><img src="../Images/10671ea65de2be5071e6f1bafd3f1811.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zmQ48d0Gdi6tkRIFgVhPRg.png"/></div></div></figure><p id="e375" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">类型可以用<code class="fe mx my mz na b">argument: type = default_value</code>提示，返回值可以用<code class="fe mx my mz na b">def function(...) -&gt; type</code>提示。</p><p id="ef89" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些根本不会被强制执行，并且会被解释器忽略。然而，这并不意味着它们没有惊人的用处！来说服你，看看我们能有什么收获！</p><h2 id="6df5" class="nb lw jj bd lx nc nd dn mb ne nf dp mf lh ng nh mh ll ni nj mj lp nk nl ml nm bi translated">通过代码完成加快开发速度</h2><p id="fa17" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">你有没有尝试过在记事本这样的准系统文本编辑器中开发？你必须输入所有的东西，并且时刻记住什么是什么。如果 IDE 不知道您正在使用的对象，它也帮不了您。</p><p id="ff0f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">看看下面的例子。</p><figure class="mt mu mv mw gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nr"><img src="../Images/d0de03b501dc26527957b3370d25056a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TUKKPK07Y8jWPG3DHPEFIw.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">PyCharm 中的自动完成</p></figure><p id="b1cd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过函数注释，IDE 知道<code class="fe mx my mz na b">data</code>对象的类型，它是<code class="fe mx my mz na b">preprocess_data</code>函数的返回值。因此，您得到了自动完成，这节省了大量的时间。</p><p id="b326" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这也有助于使用函数。大多数情况下，定义是在一个完全不同的模块中，远离你调用它的地方。通过告诉 IDE 参数的类型，它将能够帮助您以正确的格式传递参数，而不必手动检查文档或实现。</p><h2 id="f0f5" class="nb lw jj bd lx nc nd dn mb ne nf dp mf lh ng nh mh ll ni nj mj lp nk nl ml nm bi translated">代码作为文档</h2><p id="6210" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">开发人员花在阅读代码上的时间比写代码多得多。我坚信伟大的代码是自文档化的。通过适当的结构和变量命名，很少需要注释。函数注释对此有很大贡献。只要浏览一下定义，就会发现很多关于如何使用它的信息。</p><h2 id="1cfd" class="nb lw jj bd lx nc nd dn mb ne nf dp mf lh ng nh mh ll ni nj mj lp nk nl ml nm bi translated">类型检查</h2><p id="ad20" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">注释可以从函数外部访问。</p><figure class="mt mu mv mw gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nq"><img src="../Images/5708e2181769365f920bd7d66e7612f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kKUA3lYuc9Kl1hGBYZCIuQ.png"/></div></div></figure><p id="31d9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这不仅对程序员有用，对程序本身也有用！在调用函数之前，如果需要，可以在运行时检查其参数的有效性。</p><p id="cacc" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">基于 PEP 484，类型检查被带到了下一个级别。它包括<code class="fe mx my mz na b">typing</code>模块，<em class="lu">“为类型注释提供标准语法，开放 Python 代码以更容易进行静态分析和重构，潜在的运行时类型检查，以及(也许，在某些上下文中)利用类型信息的代码生成”</em>，如 PEP 中所述。</p><p id="e7c7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">举一个更具体的例子，<code class="fe mx my mz na b">typing</code>模块包含<code class="fe mx my mz na b">List</code>，所以通过使用注释<code class="fe mx my mz na b">List[int]</code>，您可以知道该函数期望(或返回)一个整数列表。</p><h1 id="9c9a" class="lv lw jj bd lx ly lz ma mb mc md me mf kp mg kq mh ks mi kt mj kv mk kw ml mm bi translated">更进一步:用 pydantic 进行数据验证</h1><p id="4648" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">类型检查带来了很多机会。但是，一直手动做就没那么方便了。</p><p id="a9b5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你想要一个稳定的解决方案，你应该试试<a class="ae jg" href="https://pydantic-docs.helpmanual.io" rel="noopener ugc nofollow" target="_blank"> <em class="lu"> pydantic </em> </a>，一个数据验证库。使用它的<code class="fe mx my mz na b">BaseModel</code>类，您可以在运行时验证数据。</p><figure class="mt mu mv mw gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ns"><img src="../Images/c00e2e8bf7aa1a17ad47a0af821c3112.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*woP3KGIwvBYAUlEAZ0GfjQ.png"/></div></div></figure><p id="6c8f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您甚至可以超越这个例子，例如为<em class="lu"> pydantic </em>模型提供定制的<a class="ae jg" href="https://pydantic-docs.helpmanual.io/usage/validators/" rel="noopener ugc nofollow" target="_blank">验证器</a>。</p><p id="fe52" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="lu"> pydantic </em>是 FastAPI 的支柱之一，是 Python 中 web 开发框架的后起之秀。在那里，<em class="lu"> pydantic </em>可以轻松地为端点定义 JSON 模式。</p><p id="6d94" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您感兴趣，可以在下面找到这些框架的文档。(它们是很好的读物，所以我强烈推荐它们。)</p><div class="is it gp gr iu nt"><a href="https://pydantic-docs.helpmanual.io/" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd jk gy z fp ny fr fs nz fu fw ji bi translated">pydantic</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">版本文档:1.6.1 使用 python 类型注释的数据验证和设置管理。pydantic…</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">pydantic-docs.helpmanual.io</p></div></div></div></a></div><div class="is it gp gr iu nt"><a href="https://fastapi.tiangolo.com/" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd jk gy z fp ny fr fs nz fu fw ji bi translated">FastAPI</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">FastAPI 框架，高性能，简单易学，快速编码，准备生产文档…</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">fastapi.tiangolo.com</p></div></div><div class="oc l"><div class="od l oe of og oc oh ja nt"/></div></div></a></div><h1 id="ec2e" class="lv lw jj bd lx ly lz ma mb mc md me mf kp mg kq mh ks mi kt mj kv mk kw ml mm bi translated">结论</h1><p id="9730" class="pw-post-body-paragraph ky kz jj la b lb mn kk ld le mo kn lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">所以，我希望我已经说服你了。类型注释需要最小的努力，但是它们对你的代码有巨大的积极影响。它</p><ul class=""><li id="ac6d" class="oi oj jj la b lb lc le lf lh ok ll ol lp om lt on oo op oq bi translated">让您和您的团队更容易阅读代码，</li><li id="e92c" class="oi oj jj la b lb or le os lh ot ll ou lp ov lt on oo op oq bi translated">鼓励你心中有类型，</li><li id="6257" class="oi oj jj la b lb or le os lh ot ll ou lp ov lt on oo op oq bi translated">帮助识别与类型相关的问题，</li><li id="9e3a" class="oi oj jj la b lb or le os lh ot ll ou lp ov lt on oo op oq bi translated">启用正确的类型检查。</li></ul><p id="b185" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你还没有使用它，你应该现在就开始使用它！这是你只用少量工作就能做的最大的代码改进之一。</p></div><div class="ab cl ow ox hx oy" role="separator"><span class="oz bw bk pa pb pc"/><span class="oz bw bk pa pb pc"/><span class="oz bw bk pa pb"/></div><div class="im in io ip iq"><p id="8153" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae jg" href="https://www.tivadardanka.com/blog" rel="noopener ugc nofollow" target="_blank"> <strong class="la jk"> <em class="lu">如果你喜欢把机器学习概念拆开，理解是什么让它们运转，我们有很多共同点。看看我的博客，我经常在那里发表这样的技术文章！</em> </strong> </a></p></div></div>    
</body>
</html>