<html>
<head>
<title>Understand Inheritance in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解 Python 中的继承</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/understand-inheritance-in-python-74f8e3025f3c?source=collection_archive---------22-----------------------#2020-07-14">https://towardsdatascience.com/understand-inheritance-in-python-74f8e3025f3c?source=collection_archive---------22-----------------------#2020-07-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2c8e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一个简单但重要的设计模式</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c7aebf1848545ea7d8414e565b00e9cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*W4gaH-dncCpI9O-j"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@walkthecreator" rel="noopener ugc nofollow" target="_blank">迈克尔在<a class="ae ky" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上行走</a></p></figure><p id="ff36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated"><span class="l lw lx ly bm lz ma mb mc md di">I</span>T12】n 继承是任何面向对象编程语言的关键特性，包括 Python。当您在 Python 3 中编写代码时，您可能已经在不知不觉中使用了继承特性。与 Java 等其他面向对象语言不同，Python 支持单继承和多继承。</p><p id="f543" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将讨论 Python 中不同类型的继承，并解释这个概念是如何集成到 Python 3 中的，以及我们如何在日常编程中使用它。我们开始吧！</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="6ae9" class="ml mm it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">什么是继承？</h2><p id="f387" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">继承是基于现有的类创建一个类，新的类继承现有类的属性和方法。新的类通常称为“子类”，现有的类称为“父类”。这一概念与现实世界的运作方式相同，在现实世界中，孩子从父母那里继承了一些特征，但同时，他或她也可以拥有独特的特征。</p><p id="d9cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">任何面向对象编程语言中的继承都应该遵循<a class="ae ky" href="https://en.wikipedia.org/wiki/Liskov_substitution_principle" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> Liskov 替换原则</strong> </a>其中说:</p><blockquote class="nj"><p id="b2d4" class="nk nl it bd nm nn no np nq nr ns lu dk translated">如果 S 是 T 的子类型，那么 T 类型的对象可以用 S 类型的对象替换</p></blockquote><p id="aaaf" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">这意味着子类将从父类继承属性、方法和实现。允许修改和添加新功能，但不能从父功能中删除功能。</p><p id="095b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我有一个父类<code class="fe nz oa ob oc b">Student</code>和子类<code class="fe nz oa ob oc b">HighSchoolStudent</code>和<code class="fe nz oa ob oc b">PrimarySchoolStudent</code>。两个子类都继承了来自<code class="fe nz oa ob oc b">Student</code>的所有属性，但是它们中的每一个对于<code class="fe nz oa ob oc b">grade</code>都有不同的值。例如，如果你想创建一个不需要<code class="fe nz oa ob oc b">school</code>属性的对象，那么你可能不应该在这里继承。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/d2661e226b870a364329bf971d836b2d" rel="noopener ugc nofollow" target="_blank">什么是继承. py </a></p></figure></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="d831" class="ml mm it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">每个类的祖先:Object</h2><p id="19e5" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">如果你在 Python 中创建了一个新类，那么它已经从某个地方继承了。我们从一个虚拟类<code class="fe nz oa ob oc b">BaseClass</code>开始，使用<code class="fe nz oa ob oc b">__bases__</code>方法检查它的父类。我们得到了<code class="fe nz oa ob oc b">&lt;class 'object'&gt;</code>，它有一些带有双前导和尾随下划线的<a class="ae ky" rel="noopener" target="_blank" href="/5-different-meanings-of-underscore-in-python-3fafa6cd0379">方法，所以从<code class="fe nz oa ob oc b">object</code>继承的类也实现了这些方法。它们在 Python 中被称为</a><a class="ae ky" href="https://www.geeksforgeeks.org/dunder-magic-methods-python/#:~:text=OpenCV%20and%20OCR-,Dunder%20or%20magic%20methods%20in%20Python,commonly%20used%20for%20operator%20overloading." rel="noopener ugc nofollow" target="_blank">魔法方法</a>。</p><p id="db7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">类</strong> <code class="fe nz oa ob oc b"><strong class="lb iu">object</strong></code> <strong class="lb iu">是 Python 中每个类的祖先。</strong>如果做<code class="fe nz oa ob oc b">object.__bases__</code>，会得到一个空值。</p><p id="5a12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="of">在 Python 2.x 中，仍然像</em> <code class="fe nz oa ob oc b"><em class="of">class BaseClass(object)</em></code> <em class="of">一样强制显式继承</em> <code class="fe nz oa ob oc b"><em class="of">object</em></code> <em class="of">，但是从 Python 3.x 开始，已经没有必要了。</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/2c771f7eb1c80d24a5017c4acc7d31b5" rel="noopener ugc nofollow" target="_blank">继承-dummy.py </a></p></figure><p id="b9f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于 Python 中定制的异常，它们应该从类<code class="fe nz oa ob oc b">BaseException</code>或其子类<code class="fe nz oa ob oc b">Exception</code>扩展而来，尽管<code class="fe nz oa ob oc b">BaseException</code>的父类也是<code class="fe nz oa ob oc b">object</code>。<strong class="lb iu">不能提升不是从</strong> <code class="fe nz oa ob oc b"><strong class="lb iu">BaseException</strong></code> <strong class="lb iu">类继承的类。</strong></p><pre class="kj kk kl km gt og oc oh oi aw oj bi"><span id="7cc2" class="ml mm it oc b gy ok ol l om on">raise BaseClass<br/># TypeError: exceptions must derive from BaseException</span></pre></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="f1a5" class="ml mm it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">单一遗传</h2><p id="0b9e" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">单一继承是指类只从一个类继承。根据在子类中做什么，子类可能有不同的结构。这里我们使用 UML 来显示类之间的关系。在每个例子中，我将首先说明用例，然后画出 UML 图。最后，我将展示代码。请在检查答案之前考虑解决方案。</p><p id="7e2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">例 1 </strong>:我有一个父类<code class="fe nz oa ob oc b">Job</code>，它有一个属性<code class="fe nz oa ob oc b">person_name</code>和一个方法<code class="fe nz oa ob oc b">task</code>。我想创建一个继承自<code class="fe nz oa ob oc b">Job</code>的子类<code class="fe nz oa ob oc b">Teacher</code>，并用<em class="of">“教学生”</em>覆盖<code class="fe nz oa ob oc b">task</code>。</p><p id="8da0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">UML 图看起来像这样。这是一个非常简单的例子，我们唯一需要做的就是覆盖方法<code class="fe nz oa ob oc b">task()</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/db704495936ac530006ea37621354fc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:266/format:webp/1*93UJht6PUY81uYq56xComA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">UML 图</p></figure><p id="096e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们检查一下代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/0a951ed38977bda13f21aecd8c734b41#file-inheritance-overwrite-method-py" rel="noopener ugc nofollow" target="_blank">继承-覆盖-方法. py </a></p></figure><p id="bbc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">例 2: </strong>我们仍然使用<code class="fe nz oa ob oc b">Job</code>作为父类，但是这次除了重写<code class="fe nz oa ob oc b">task()</code>之外，我还想创建一个带有额外属性<code class="fe nz oa ob oc b">school_name</code>的子类<code class="fe nz oa ob oc b">Teacher</code>。</p><p id="58c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在 UML 图中，我们会在类<code class="fe nz oa ob oc b">Teacher</code>中找到一个新的属性。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/6008085a0d1687df97d84ee9df19a97c.png" data-original-src="https://miro.medium.com/v2/resize:fit:266/format:webp/1*3IPCV5AZlv9vt85Ym-2ZTw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">UML 图—新属性</p></figure><p id="18f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nz oa ob oc b">school</code>是一个新属性，所以这意味着我们需要覆盖<code class="fe nz oa ob oc b">__init__</code>方法来添加属性。在这个例子中，我们将使用一个内置函数<code class="fe nz oa ob oc b"><a class="ae ky" href="https://docs.python.org/3.8/library/functions.html#super" rel="noopener ugc nofollow" target="_blank">super()</a></code>。</p><p id="6362" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之，<code class="fe nz oa ob oc b">super()</code>返回一个将方法调用委托给父类的对象。它允许您重用父类的属性和行为。在下面的代码中，<code class="fe nz oa ob oc b">super().__init__</code>将执行<code class="fe nz oa ob oc b">Job.__init__</code>中的所有内容，以避免重复代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/9fe2c0b48b9ea5236bc7981422fbc4ff" rel="noopener ugc nofollow" target="_blank">继承-新建-属性. py </a></p></figure><p id="b16e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nz oa ob oc b">super()</code>可以在其他方法中使用，所以也可以在子类中调用<code class="fe nz oa ob oc b">super().task()</code>。</p><p id="283f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">例 3: </strong>除了例 2，我想防止类<code class="fe nz oa ob oc b">Job</code>被实例化，因为没有名为<code class="fe nz oa ob oc b">Job</code>的作业。</p><p id="d70e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">UML 图将与示例 2 相同。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/6008085a0d1687df97d84ee9df19a97c.png" data-original-src="https://miro.medium.com/v2/resize:fit:266/format:webp/1*3IPCV5AZlv9vt85Ym-2ZTw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">UML 图—新属性</p></figure><p id="758b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了实现这一点，我们将讨论 Python 中抽象类的概念。<strong class="lb iu">抽象类是打算被继承但从不实例化的类。</strong> Python 提供了<code class="fe nz oa ob oc b">abc</code>模块定义抽象基类，提供了<code class="fe nz oa ob oc b">@abstractmethod</code> decorator 定义抽象方法。</p><p id="064d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以新的<code class="fe nz oa ob oc b">Job</code>类是从<code class="fe nz oa ob oc b">ABC</code>类扩展而来的，方法<code class="fe nz oa ob oc b">task()</code>有装饰器<code class="fe nz oa ob oc b">@abstractmethod</code>。通过这样做，它告诉程序员这个类不允许被实例化。如果您试图创建一个对象，它将引发一个异常。此外，将任何有意义的逻辑放入抽象方法是没有意义的，尽管你仍然可以这样做。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">继承-抽象. py</p></figure><pre class="kj kk kl km gt og oc oh oi aw oj bi"><span id="ad8e" class="ml mm it oc b gy ok ol l om on">job = Job("xiaoxu")<br/># TypeError: Can't instantiate abstract class Job with abstract methods task</span></pre><p id="0792" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">子类<code class="fe nz oa ob oc b">Teacher</code>将与前面的例子相同。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="923b" class="ml mm it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">多重遗传</h2><p id="4b06" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">多重继承是指类从多个父类继承。在某种程度上，这可以减少冗余，但也会增加代码的复杂性。你应该清楚自己在做什么。</p><p id="a940" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">例子</strong>:我有一个父类<code class="fe nz oa ob oc b">Dad</code>和另一个父类<code class="fe nz oa ob oc b">Mum</code>。子类<code class="fe nz oa ob oc b">Kid</code>扩展了两个父类。父类如下所示。有些属性具有相同的值(例如城市)，但有些属性不具有相同的值(例如眼睛颜色)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/9f680533f9033b94db354021db85ffbf" rel="noopener ugc nofollow" target="_blank">继承-multi.py </a></p></figure><p id="3074" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧，那么问题来了。一个<code class="fe nz oa ob oc b">kid</code>对象的默认<code class="fe nz oa ob oc b">eye_color</code>是什么？当涉及到多重继承时，子类将首先在它自己的类中搜索属性，如果没有，那么在它的父类中以深度优先、从左到右的顺序搜索。这在 Python 中叫做 <a class="ae ky" href="https://bytes.vokal.io/20151207-python-super-mro/#:~:text=The%20MRO%20(Method%20Resolution%20Order,point%20to%20the%20parent%20class)" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">方法解析顺序</strong> </a> <strong class="lb iu"> (MRO)。MRO 定义了 Python 如何搜索继承的方法。</strong></p><p id="23b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，我们可以通过执行<code class="fe nz oa ob oc b">Kid.__mro__</code>来检查这个订单。由于<code class="fe nz oa ob oc b">Kid</code>类第一次访问<code class="fe nz oa ob oc b">Dad</code>，那么它默认会有蓝眼睛。此外，<code class="fe nz oa ob oc b">kid</code>将会兼具游泳和舞蹈“技能”。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/9a2680c38528f2c577766e06f5233c4d" rel="noopener ugc nofollow" target="_blank">继承-多结果. py </a></p></figure><p id="d5cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你只想从类<code class="fe nz oa ob oc b">Mum</code>继承属性，那么你可以在<code class="fe nz oa ob oc b">Kid</code>的<code class="fe nz oa ob oc b">__init__</code>中明确提到。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/4955d74d282b289302d3c67c77dcf16c" rel="noopener ugc nofollow" target="_blank">继承-多-2.py </a></p></figure></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="6ec6" class="ml mm it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">结论</h2><p id="9f2d" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">继承是任何面向对象编程语言中极其常见的设计模式。它有助于程序员重用代码，节省大量的时间和精力。这种模式在 Python 中得到了很好的实现，既有单一继承的可能性，也有多重继承的可能性。</p><p id="65be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢这篇文章！如果你有任何想法，请在下面留下你的评论。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="4826" class="ml mm it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">参考</h2><div class="op oq gp gr or os"><a href="https://realpython.com/python-super/" rel="noopener  ugc nofollow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd iu gy z fp ox fr fs oy fu fw is bi translated">用 Python super() -真正的 Python 来增强你的类</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">免费奖励:关于 Python 精通的 5 个想法，这是一个面向 Python 开发者的免费课程，向你展示了路线图和…</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">realpython.com</p></div></div><div class="pb l"><div class="pc l pd pe pf pb pg ks os"/></div></div></a></div></div></div>    
</body>
</html>