<html>
<head>
<title>Dynamic replay of time-series data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">时间序列数据的动态重放</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/dynamic-replay-of-time-series-data-819e27212b4b?source=collection_archive---------45-----------------------#2020-04-06">https://towardsdatascience.com/dynamic-replay-of-time-series-data-819e27212b4b?source=collection_archive---------45-----------------------#2020-04-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2041" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在 Python 中利用 matplotlib 和双端队列</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/47af53a6b5d778b3b398581b66e76a02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*KTAEFZUcMUMsKlZEbfJYPA.gif"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">脑电 Fp2 和 C3 通道的动态图。</p></figure><p id="70d6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">完整地静态绘制大型时间序列数据可能会导致非常紧凑的绘图，这些绘图几乎不会产生关于它们在较短时间尺度上可能包含的任何有趣影响的信息。为了识别这些影响，以可调节的速率回放数据可能是有用的。以下用 Python 3 编写的代码正是通过利用<code class="fe lq lr ls lt b">matplotlib</code>的交互模式以及双端队列(或称<code class="fe lq lr ls lt b">deques</code>)来实现这一点，双端队列是类似列表的容器，支持快速追加和在任一端弹出。</p><p id="f52d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在下面的演示中，我将使用从大约 8 分钟的静息状态会话中获得的脑电图(EEG)数据。然而，我想强调的是，该代码适用于任何类型的时间序列数据，无论是来自电生理学、股票市场、产品销售还是气象学。</p><p id="ea90" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们首先导入所需的包，加载数据，并打开<code class="fe lq lr ls lt b">matplotlib</code>的交互模式。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="383a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，我们将定义图中可见的时间量(即 x 轴的长度)，并初始化数据的队列，<code class="fe lq lr ls lt b">dy1</code>和<code class="fe lq lr ls lt b">dy2</code>，以及它们对应的 x 轴<code class="fe lq lr ls lt b">dx</code>。<code class="fe lq lr ls lt b">interval</code>变量表示包含所有数据点索引的数组(在本例中，从 0 到 224，930)，用于扩展 x 轴并设置其限制。因为 EEG 采集的采样频率是 500 Hz，所以我们需要将这个数组除以 500 来获得以秒为单位的时间。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="0cd2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，我们需要定义图形和它的轴。我选择了一个 2 乘 1 的子图，上面的代表通道 Fp2，下面的代表通道 C3。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="3f06" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，我们将图的 x 轴和 y 轴更新打包到一个 while 循环中，该循环只有在回放完所有数据后才会结束。变量<code class="fe lq lr ls lt b">start</code>控制时间序列移动的速度，因为它决定了 deques 的增量，因此也决定了图的更新。此外，y 轴的限值根据其相应数据的平均值<code class="fe lq lr ls lt b">mdy1</code>和<code class="fe lq lr ls lt b">mdy2</code>动态移动。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="948b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">输出是一个以自定义速度重放整个时间序列数据的动态图，如本文顶部的 GIF 所示。</p></div></div>    
</body>
</html>