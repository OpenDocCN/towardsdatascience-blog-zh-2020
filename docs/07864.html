<html>
<head>
<title>Up and running with Milvus</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">与Milvus一起运行</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/up-and-running-with-milvus-2466161e8b1f?source=collection_archive---------25-----------------------#2020-06-11">https://towardsdatascience.com/up-and-running-with-milvus-2466161e8b1f?source=collection_archive---------25-----------------------#2020-06-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0cb0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">向量相似性搜索引擎。构建推荐并搜索图像/视频、音频或非结构化文本。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b99bbb4299237e3071618d2212402d3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lfZAUff_IGoUco-n"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">马库斯·温克勒在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kw"><img src="../Images/eb320d1b215748eaf276638a5414a713.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uN0CIKZYydOpTNYK5vhOPw.png"/></div></div></figure><h1 id="408c" class="kx ky iq bd kz la lb lc ld le lf lg lh jw li jx lj jz lk ka ll kc lm kd ln lo bi translated">什么是Milvus？</h1><p id="cfa4" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">一个矢量相似性搜索引擎，看起来已经可以生产了。据<a class="ae kv" href="https://milvus.io/" rel="noopener ugc nofollow" target="_blank">网站</a>:</p><ul class=""><li id="92cf" class="ml mm iq lr b ls mn lv mo ly mp mc mq mg mr mk ms mt mu mv bi translated">它提供了多种相似性度量和索引类型。</li><li id="5d8d" class="ml mm iq lr b ls mw lv mx ly my mc mz mg na mk ms mt mu mv bi translated">水平缩放。</li><li id="4a07" class="ml mm iq lr b ls mw lv mx ly my mc mz mg na mk ms mt mu mv bi translated">读写几乎是实时进行的，这意味着我们可以在引擎在线时插入记录。</li><li id="327c" class="ml mm iq lr b ls mw lv mx ly my mc mz mg na mk ms mt mu mv bi translated">公开一个REST接口。</li></ul><p id="f359" class="pw-post-body-paragraph lp lq iq lr b ls mn jr lu lv mo ju lx ly nb ma mb mc nc me mf mg nd mi mj mk ij bi translated">听起来很酷！</p><p id="0de9" class="pw-post-body-paragraph lp lq iq lr b ls mn jr lu lv mo ju lx ly nb ma mb mc nc me mf mg nd mi mj mk ij bi translated">对于那些还不知道的人来说，像这样的技术有很多用例。在机器学习的帮助下，我们可以搜索图像、视频和音频。</p><p id="4e86" class="pw-post-body-paragraph lp lq iq lr b ls mn jr lu lv mo ju lx ly nb ma mb mc nc me mf mg nd mi mj mk ij bi translated">假设我们训练了一个对图像进行分类的CNN。如果我们在最终输出之前查看任何层的输出，我们可能会发现描述输入的N维特征向量。随着我们在网络中移动，这些特征变得更加具体。开始时，我们可以识别纹理、形状等。接近尾声时，我们辨认出像猫耳朵和狗尾巴这样的物体。我们可以获取这些层的输出，通过某种方法将其展平，并在搜索引擎中对其进行索引！瞧啊。所选择的层将对什么被认为是“相似的”产生影响。这将因使用情形而异。这个例子是基于内容的图像检索(CBIR)的一个应用。</p><h1 id="d207" class="kx ky iq bd kz la lb lc ld le lf lg lh jw li jx lj jz lk ka ll kc lm kd ln lo bi translated">我们在建造什么？</h1><p id="4107" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">一个非常简单的在Dockerized环境中使用Milvus的CBIR实现。这是完整的回购协议和我们将使用的技术列表。如果你想下载回购，只是乱搞，它已经准备好了。</p><div class="ne nf gp gr ng nh"><a href="https://github.com/dshvimer/milvus-up-and-running" rel="noopener  ugc nofollow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd ir gy z fp nm fr fs nn fu fw ip bi translated">dshvimer/milv us-启动并运行</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">在GitHub上创建一个帐户，为dshvimer/milvus的启动和运行开发做出贡献。</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">github.com</p></div></div><div class="nq l"><div class="nr l ns nt nu nq nv kp nh"/></div></div></a></div><ul class=""><li id="6152" class="ml mm iq lr b ls mn lv mo ly mp mc mq mg mr mk ms mt mu mv bi translated">python——因为</li><li id="3cf4" class="ml mm iq lr b ls mw lv mx ly my mc mz mg na mk ms mt mu mv bi translated">Docker —这样每个人都有一个标准的环境</li><li id="d7f8" class="ml mm iq lr b ls mw lv mx ly my mc mz mg na mk ms mt mu mv bi translated">py torch——因为我总是跳Keras，想学点新东西。</li><li id="b17c" class="ml mm iq lr b ls mw lv mx ly my mc mz mg na mk ms mt mu mv bi translated">Jupyter笔记本—与Milvus互动的简单方式</li></ul><h1 id="90ff" class="kx ky iq bd kz la lb lc ld le lf lg lh jw li jx lj jz lk ka ll kc lm kd ln lo bi translated">设置项目</h1><p id="7a75" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">在一个新的目录中，让我们创建更多的空目录。</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="823f" class="ob ky iq nx b gy oc od l oe of">-project<br/>  -notebook<br/>  -milvus<br/>    -conf</span></pre><p id="12aa" class="pw-post-body-paragraph lp lq iq lr b ls mn jr lu lv mo ju lx ly nb ma mb mc nc me mf mg nd mi mj mk ij bi translated">在顶层目录中，创建一个名为<code class="fe og oh oi nx b">docker-compose.yml</code>的文件，内容如下:</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="78ef" class="ob ky iq nx b gy oc od l oe of">version: '2.0'<br/>services:<br/>    notebook:<br/>        build:<br/>            context: ./notebook<br/>        ports:<br/>            - '8888:8888'<br/>        volumes:<br/>            - ./notebook:/home/jovyan<br/>        links:<br/>            - milvus<br/>    milvus:<br/>        image: milvusdb/milvus:0.9.1-cpu-d052920-e04ed5<br/>        ports:<br/>            - '19530:19530'<br/>            - '19121:19121'<br/>        volumes:<br/>            - ./milvus/db:/var/lib/milvus/db<br/>            - ./milvus/conf:/var/lib/milvus/conf<br/>            - ./milvus/logs:/var/lib/milvus/logs<br/>            - ./milvus/wal:/var/lib/milvus/wal</span></pre><p id="838c" class="pw-post-body-paragraph lp lq iq lr b ls mn jr lu lv mo ju lx ly nb ma mb mc nc me mf mg nd mi mj mk ij bi translated">我们定义了两个docker容器，一个用于Milvus，另一个用于jupyter笔记本。Milvus容器通过<code class="fe og oh oi nx b">links</code>属性对笔记本可见。我们声明的卷是为了让Milvus文件系统与我们的操作系统共享一些文件夹。这让我们可以轻松地配置和监控Milvus。因为我们给了笔记本容器一个上下文来构建，所以我们需要在<code class="fe og oh oi nx b">notebook</code>目录中创建一个名为<code class="fe og oh oi nx b">Dockerfile</code>的文件，其内容如下:</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="e87e" class="ob ky iq nx b gy oc od l oe of">FROM jupyter/scipy-notebook</span><span id="0b8e" class="ob ky iq nx b gy oj od l oe of">RUN pip install pymilvus==0.2.12</span><span id="6d37" class="ob ky iq nx b gy oj od l oe of">RUN conda install --quiet --yes pytorch torchvision -c pytorch</span></pre><p id="1232" class="pw-post-body-paragraph lp lq iq lr b ls mn jr lu lv mo ju lx ly nb ma mb mc nc me mf mg nd mi mj mk ij bi translated">这不是声明依赖关系的最佳方式，但可以在以后进行优化。我们还应该下载一些图片来玩。随意下载我用的<a class="ae kv" href="https://github.com/dshvimer/milvus-up-and-running/tree/master/notebook/images" rel="noopener ugc nofollow" target="_blank">这里的</a>:把它们放入<code class="fe og oh oi nx b">notebook/images</code>。</p><p id="e08a" class="pw-post-body-paragraph lp lq iq lr b ls mn jr lu lv mo ju lx ly nb ma mb mc nc me mf mg nd mi mj mk ij bi translated">最后一步，下载启动器Milvus <a class="ae kv" href="https://raw.githubusercontent.com/milvus-io/milvus/v0.9.1/core/conf/demo/server_config.yaml" rel="noopener ugc nofollow" target="_blank">配置文件</a>并放入<code class="fe og oh oi nx b">milvus/conf/</code>中。现在只要Docker安装并运行，我们运行<code class="fe og oh oi nx b">docker-compose up</code>，我们就活了！</p><p id="9052" class="pw-post-body-paragraph lp lq iq lr b ls mn jr lu lv mo ju lx ly nb ma mb mc nc me mf mg nd mi mj mk ij bi translated">如果您在控制台输出中看到以下行:</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="dd84" class="ob ky iq nx b gy oc od l oe of">milvus_1    | Milvus server exit...</span><span id="00dd" class="ob ky iq nx b gy oj od l oe of">milvus_1    | Config check fail: Invalid cpu cache capacity: 1. Possible reason: sum of cache_config.cpu_cache_capacity and cache_config.insert_buffer_size exceeds system memory.</span><span id="1390" class="ob ky iq nx b gy oj od l oe of">milvus_1    | ERROR: Milvus server fail to load config file</span></pre><p id="9200" class="pw-post-body-paragraph lp lq iq lr b ls mn jr lu lv mo ju lx ly nb ma mb mc nc me mf mg nd mi mj mk ij bi translated">这意味着Docker没有足够的内存来运行Milvus。如果我们打开配置文件并搜索“cpu_cache_capacity ”,我们会看到一些有用的文档。"T11'插入缓冲区大小'和' cpu缓存容量'之和必须小于系统内存大小。"</p><p id="f694" class="pw-post-body-paragraph lp lq iq lr b ls mn jr lu lv mo ju lx ly nb ma mb mc nc me mf mg nd mi mj mk ij bi translated">将两个值都设置为1，然后打开Docker的设置，确保将其配置为任何大于2GB的值(必须大于)。确保应用设置并重启Docker。然后再试试<code class="fe og oh oi nx b">docker-compose up</code>。如果有其他问题，请在评论中告诉我。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/8307a551751fde9dedee21074960ee80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_F3r3eRO3fCLajCkClPnZw.png"/></div></div></figure><h1 id="045a" class="kx ky iq bd kz la lb lc ld le lf lg lh jw li jx lj jz lk ka ll kc lm kd ln lo bi translated">PyTorch特征向量</h1><p id="36cf" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">有趣的东西，开始了。一旦一切都运行了，我们应该有一个URL来访问我们的jupyter实例。让我们创建一个新的笔记本并开始编码。一次一个细胞。</p><p id="da95" class="pw-post-body-paragraph lp lq iq lr b ls mn jr lu lv mo ju lx ly nb ma mb mc nc me mf mg nd mi mj mk ij bi translated">首先是进口:</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="bc86" class="ob ky iq nx b gy oc od l oe of">import torch<br/>import torch.nn as nn<br/>import torchvision.models as models<br/>import torchvision.transforms as transforms<br/>from torch.autograd import Variable<br/>from PIL import Image<br/>import matplotlib.pyplot as plt<br/>import numpy as np<br/>%matplotlib inline</span></pre><p id="f986" class="pw-post-body-paragraph lp lq iq lr b ls mn jr lu lv mo ju lx ly nb ma mb mc nc me mf mg nd mi mj mk ij bi translated">现在让我们定义一个助手类来提取特征向量:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="008c" class="pw-post-body-paragraph lp lq iq lr b ls mn jr lu lv mo ju lx ly nb ma mb mc nc me mf mg nd mi mj mk ij bi translated">我为什么选ResNet18？因为它有一个输出长度为512的平面向量的层。学习新事物时，方便和容易是合理的。这个类有很大的扩展空间。我们可以一次从多个层提取特征，并一次输入多个图像。就目前而言，这已经足够好了。</p><p id="066e" class="pw-post-body-paragraph lp lq iq lr b ls mn jr lu lv mo ju lx ly nb ma mb mc nc me mf mg nd mi mj mk ij bi translated">现在，我们可以加载我们的图像，并开始查看相似性:</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="6108" class="ob ky iq nx b gy oc od l oe of">feat_vec = FeatureVector()<br/>dog1 = Image.open('./images/dog1.jpg')<br/>dog2 = Image.open('./images/dog2.jpg')<br/>dog3 = Image.open('./images/dog3.jpg')<br/>cat1 = Image.open('./images/cat1.jpg')<br/>cat2 = Image.open('./images/cat2.jpg')<br/>person1 = Image.open('./images/person1.jpg')<br/>person2 = Image.open('./images/person2.jpg')</span><span id="d2ee" class="ob ky iq nx b gy oj od l oe of">def compare(a, b):<br/>    plt.figure()<br/>    plt.subplot(1, 2, 1)<br/>    plt.imshow(a)<br/>    plt.subplot(1, 2, 2)<br/>    plt.imshow(b)<br/>    a_v = feat_vec.get_vector(a)<br/>    b_v = feat_vec.get_vector(b)<br/>    print('Similarity: {}'.format(feat_vec.similarity(a_v, b_v)))</span><span id="9947" class="ob ky iq nx b gy oj od l oe of">compare(dog1, dog2)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/ae4e5bc771111717a5150ceaa80f2656.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2nuZFUwWsHMTWyAGWblQng.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/9d97d6275144dd3d9666961f1b666fd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jR4rS99n_grhFy0XlE1wkg.png"/></div></div></figure><p id="2725" class="pw-post-body-paragraph lp lq iq lr b ls mn jr lu lv mo ju lx ly nb ma mb mc nc me mf mg nd mi mj mk ij bi translated">在第一个例子中，小狗和成年金毛猎犬图像的相似性得分约为0.79。当我们比较一只小狗金毛寻回犬和一只哈巴狗时，我们得到的相似性分数约为0.58。</p><h1 id="ec11" class="kx ky iq bd kz la lb lc ld le lf lg lh jw li jx lj jz lk ka ll kc lm kd ln lo bi translated">使用Milvus:连接、插入、查询</h1><p id="2dce" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">让我们做我们来这里要做的事。我们从连接Milvus开始，创建一个集合</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="468e" class="ob ky iq nx b gy oc od l oe of">from milvus import Milvus, IndexType, MetricType, Status</span><span id="cf10" class="ob ky iq nx b gy oj od l oe of"># Milvus server IP address and port.<br/># Because the link to milvus in docker-compose <br/># was named `milvus`, thats what the hostname will be<br/>_HOST = 'milvus'<br/>_PORT = '19530'  # default value</span><span id="e472" class="ob ky iq nx b gy oj od l oe of"># Vector parameters<br/>_DIM = 512  # dimension of vector</span><span id="ca60" class="ob ky iq nx b gy oj od l oe of">_INDEX_FILE_SIZE = 32  # max file size of stored index</span><span id="9b24" class="ob ky iq nx b gy oj od l oe of">milvus = Milvus(_HOST, _PORT, pool_size=10)</span><span id="8716" class="ob ky iq nx b gy oj od l oe of"># Create collection demo_collection if it dosen't exist.<br/>collection_name = 'resnet18_simple'</span><span id="8066" class="ob ky iq nx b gy oj od l oe of">status, ok = milvus.has_collection(collection_name)<br/>if not ok:<br/>    param = {<br/>        'collection_name': collection_name,<br/>        'dimension': _DIM,<br/>        'index_file_size': _INDEX_FILE_SIZE,  # optional<br/>        'metric_type': MetricType.L2  # optional<br/>    }</span><span id="7a87" class="ob ky iq nx b gy oj od l oe of">print(milvus.create_collection(param))</span><span id="35df" class="ob ky iq nx b gy oj od l oe of"># Milvus expo<br/>_, collection = milvus.get_collection_info(collection_name)<br/>print(collection)</span></pre><p id="cc01" class="pw-post-body-paragraph lp lq iq lr b ls mn jr lu lv mo ju lx ly nb ma mb mc nc me mf mg nd mi mj mk ij bi translated">现在我们可以插入图像的特征向量。我们需要将向量转换成python列表:</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="f320" class="ob ky iq nx b gy oc od l oe of">images = [<br/>    dog1,<br/>    dog2,<br/>    dog3,<br/>    cat1,<br/>    cat2,<br/>    person1,<br/>    person2<br/>]</span><span id="1240" class="ob ky iq nx b gy oj od l oe of"># 10000 vectors with 128 dimension<br/># element per dimension is float32 type<br/># vectors should be a 2-D array<br/>vectors = [feat_vec.get_vector(i).tolist() for i in images]</span><span id="34fe" class="ob ky iq nx b gy oj od l oe of"># Insert vectors into demo_collection, return status and vectors id list<br/>status, ids = milvus.insert(collection_name=collection_name, records=vectors)<br/>if not status.OK():<br/>    print("Insert failed: {}".format(status))<br/>else: print(ids)</span></pre><p id="1b33" class="pw-post-body-paragraph lp lq iq lr b ls mn jr lu lv mo ju lx ly nb ma mb mc nc me mf mg nd mi mj mk ij bi translated">如果成功了，我们应该会看到Milvus用来识别图像的ID列表。它们的顺序与我们的图像列表相同，因此让我们创建一个快速查找表，以便在给定一些ID的情况下轻松访问图像:</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="70f6" class="ob ky iq nx b gy oc od l oe of">lookup = {}<br/>for ID, img in zip(ids, images):<br/>    lookup[ID] = img</span><span id="ee43" class="ob ky iq nx b gy oj od l oe of">for k in lookup:<br/>    print(k, lookup[k])</span></pre><p id="0725" class="pw-post-body-paragraph lp lq iq lr b ls mn jr lu lv mo ju lx ly nb ma mb mc nc me mf mg nd mi mj mk ij bi translated">我们可以将新项目刷新到磁盘上，并为收藏获取一些信息:</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="ceb5" class="ob ky iq nx b gy oc od l oe of"># Flush collection  inserted data to disk.<br/>milvus.flush([collection_name])</span><span id="4951" class="ob ky iq nx b gy oj od l oe of"># Get demo_collection row count<br/>status, result = milvus.count_entities(collection_name)<br/>print(result)<br/># present collection statistics info<br/>_, info = milvus.get_collection_stats(collection_name)<br/>print(info)</span></pre><p id="087c" class="pw-post-body-paragraph lp lq iq lr b ls mn jr lu lv mo ju lx ly nb ma mb mc nc me mf mg nd mi mj mk ij bi translated">让我们搜索！</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="0cfb" class="ob ky iq nx b gy oc od l oe of"># execute vector similarity search<br/>search_param = {<br/>    "nprobe": 16<br/>}</span><span id="fdf4" class="ob ky iq nx b gy oj od l oe of">print("Searching ... ")</span><span id="535f" class="ob ky iq nx b gy oj od l oe of">param = {<br/>    'collection_name': collection_name,<br/>    'query_records': [vectors[0]],<br/>    'top_k': 10,<br/>    'params': search_param,<br/>}</span><span id="1c6a" class="ob ky iq nx b gy oj od l oe of">status, results = milvus.search(**param)<br/>if status.OK():<br/>    print(results)<br/>else:<br/>    print("Search failed. ", status)</span></pre><p id="cd49" class="pw-post-body-paragraph lp lq iq lr b ls mn jr lu lv mo ju lx ly nb ma mb mc nc me mf mg nd mi mj mk ij bi translated">如果我们看到结果列表，这意味着一切都很好。我们可以用下面的代码片段将它们可视化</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="d0f9" class="ob ky iq nx b gy oc od l oe of">for neighbors in results:<br/>    for n in neighbors:<br/>        plt.figure()<br/>        plt.subplot(1, 2, 1)<br/>        plt.imshow(images[0])<br/>        plt.subplot(1, 2, 2)<br/>        plt.imshow(lookup[n.id])<br/>        print('Distance: {}'.format(n.distance))</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/773b079378f98248a9504c4b5b85f7d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fRkb3zcjzUIPrmvm06UJAQ.png"/></div></div></figure><p id="4d7b" class="pw-post-body-paragraph lp lq iq lr b ls mn jr lu lv mo ju lx ly nb ma mb mc nc me mf mg nd mi mj mk ij bi translated">要删除收藏:</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="cc59" class="ob ky iq nx b gy oc od l oe of">milvus.drop_collection(collection_name)</span></pre><h1 id="8aee" class="kx ky iq bd kz la lb lc ld le lf lg lh jw li jx lj jz lk ka ll kc lm kd ln lo bi translated">结论</h1><p id="d217" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">启动并运行起来非常容易。这里大部分与Milvus相关的代码来自网站上的入门示例。我们的一个向量大小约为1KB，因此我们可以将一百万个特征向量放入1GB的内存中。我们在这里没有使用索引，这会增加成本，但这仍然是一种非常有效的图像索引方式。网站文档很棒，但是我认为通读配置文件是理解这个东西能做什么的好方法。在这篇文章中，我们把它保持得非常简单，但是对于那些想更进一步的人来说，这里有一些想法:</p><ul class=""><li id="e593" class="ml mm iq lr b ls mn lv mo ly mp mc mq mg mr mk ms mt mu mv bi translated">预处理特征向量。(即标准化)</li><li id="3a86" class="ml mm iq lr b ls mw lv mx ly my mc mz mg na mk ms mt mu mv bi translated">尝试不同的层，如果它们不平坦，尝试最大池化或平均池化，然后平坦化</li><li id="52e9" class="ml mm iq lr b ls mw lv mx ly my mc mz mg na mk ms mt mu mv bi translated">应用降维技术:tNSE、PCA、LDA</li><li id="52ba" class="ml mm iq lr b ls mw lv mx ly my mc mz mg na mk ms mt mu mv bi translated">使用自动编码器进行预处理</li></ul><p id="6196" class="pw-post-body-paragraph lp lq iq lr b ls mn jr lu lv mo ju lx ly nb ma mb mc nc me mf mg nd mi mj mk ij bi translated">这是我的第一篇文章。所以如果你喜欢，请告诉我。如果有什么不工作或格式被关闭，也让我知道！在外面保持优雅。</p></div></div>    
</body>
</html>