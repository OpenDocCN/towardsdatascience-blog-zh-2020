<html>
<head>
<title>Nature-Inspired Optimization Algorithms: Particle Swarm Optimization Using Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自然启发的优化算法:使用 Python 的粒子群优化</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/nature-inspired-optimization-algorithms-particle-swarm-optimization-2cd207d0d37e?source=collection_archive---------12-----------------------#2020-01-17">https://towardsdatascience.com/nature-inspired-optimization-algorithms-particle-swarm-optimization-2cd207d0d37e?source=collection_archive---------12-----------------------#2020-01-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/8c039c48816e7aa65bfbb199a0ca04ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*aHC46tTrxzQT6sN6SUcgjw.gif"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">鸣椋鸟</p></figure><div class=""/><div class=""><h2 id="7340" class="pw-subtitle-paragraph kf jh ji bd b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dk translated">利用百万年自然选择过程解决数值优化问题</h2></div><h1 id="d8bc" class="kx ky ji bd kz la lb lc ld le lf lg lh ko li kp lj kr lk ks ll ku lm kv ln lo bi translated">目录</h1><ul class=""><li id="6a82" class="lp lq ji lr b ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated"><strong class="lr jj">简介</strong></li><li id="178b" class="lp lq ji lr b ls mh lu mi lw mj ly mk ma ml mc md me mf mg bi translated"><strong class="lr jj">什么是涌现复杂性？</strong></li><li id="a8e1" class="lp lq ji lr b ls mh lu mi lw mj ly mk ma ml mc md me mf mg bi translated"><strong class="lr jj">建模鸟群智能</strong></li><li id="50e1" class="lp lq ji lr b ls mh lu mi lw mj ly mk ma ml mc md me mf mg bi translated"><strong class="lr jj">使用 Python 实现理论</strong></li><li id="ad3d" class="lp lq ji lr b ls mh lu mi lw mj ly mk ma ml mc md me mf mg bi translated"><strong class="lr jj">结论</strong></li><li id="6a02" class="lp lq ji lr b ls mh lu mi lw mj ly mk ma ml mc md me mf mg bi translated"><strong class="lr jj">资源和参考资料</strong></li></ul><h1 id="c21a" class="kx ky ji bd kz la lb lc ld le lf lg lh ko li kp lj kr lk ks ll ku lm kv ln lo bi translated">介绍</h1><p id="37e9" class="pw-post-body-paragraph mm mn ji lr b ls lt kj mo lu lv km mp lw mq mr ms ly mt mu mv ma mw mx my mc im bi translated">粒子群优化(PSO)是一种基于随机优化的强大算法，其灵感来自于大群鸟中的规则。在本文中，将支持该方法的可行性，然后将推导出这些原则的精确模型。最后，将描述数值优化问题的这些原理的数学模型的实现，然后使用 Python 来实现，以找到 Rastrigin 函数的全局最小值[1]。如果你用 C++编程，你可以参考参考资料一节[2]中的链接来查看项目源代码。</p><h1 id="59a9" class="kx ky ji bd kz la lb lc ld le lf lg lh ko li kp lj kr lk ks ll ku lm kv ln lo bi translated">什么是涌现复杂性？</h1><p id="27b2" class="pw-post-body-paragraph mm mn ji lr b ls lt kj mo lu lv km mp lw mq mr ms ly mt mu mv ma mw mx my mc im bi translated">涌现复杂性[3]是一种现象，它描述了大群体的各个组成部分如何以相同但更简单的规则一起工作来创建多样而复杂的系统。有一些自然的复杂行为可以作为涌现的例子。例如，蚂蚁本能地互相交流，以建立一个活的桥梁，在寻找食物源的时候最小化交流距离[4]。鸟类相互跟随，形成更大的群体，这增加了它们发现捕食者和食物来源的可能性。与不一定有用的通常的复杂性概念不同，自然复杂性是百万年自然选择过程的结果，其中能量使用是增加存活机会的最重要因素。因此，如果同一个问题有两种解决方案，由于自然选择，更简单和需要更少能量的方法将会存在。这就是为什么《自然》杂志提出的解决方案既简单又能有效地尽可能减少动物的能量消耗。因此，科学家们单独观察一群椋鸟中的每只鸟，发现它们中的每一只都采取简单的行动来形成复杂的结构。</p><ol class=""><li id="7c5a" class="lp lq ji lr b ls mz lu na lw nb ly nc ma nd mc ne me mf mg bi translated">每只鸟都有自己的位置和速度</li><li id="5b52" class="lp lq ji lr b ls mh lu mi lw mj ly mk ma ml mc ne me mf mg bi translated">每只鸟都有自己的视野范围，可以跟随周围的鸟。这只鸟完全不知道这个跨度之外的活动。</li><li id="77b9" class="lp lq ji lr b ls mh lu mi lw mj ly mk ma ml mc ne me mf mg bi translated">如果任何一只鸟发现了食物，鸟群中所有的鸟都会朝那个方向飞去。</li></ol><h1 id="f2b6" class="kx ky ji bd kz la lb lc ld le lf lg lh ko li kp lj kr lk ks ll ku lm kv ln lo bi translated"><strong class="ak">鸟群智能建模</strong></h1><p id="b72c" class="pw-post-body-paragraph mm mn ji lr b ls lt kj mo lu lv km mp lw mq mr ms ly mt mu mv ma mw mx my mc im bi translated">在自然界中，在一个数值问题中，任何 boid(类鸟物体)的可观测邻域都被限制在某个范围内。因此，它可以收敛到某个局部最小值或鞍点，其中梯度(在我们的情况下是速度)将为 0。然而，拥有一个以上的 boid 允许群体中的所有鸟意识到误差函数的更大表面，并且如果它们中的任何一个已经看到了误差方面的更好位置，则不会陷入局部最小值。为此，我们将对上述原则进行数学建模，以使群体找到误差函数的全局最小值</p><ol class=""><li id="99a0" class="lp lq ji lr b ls mz lu na lw nb ly nc ma nd mc ne me mf mg bi translated">每个 boid 都有自己的位置和速度。我们可以把速度看作误差函数的偏导数的向量。</li></ol><figure class="ng nh ni nj gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nf"><img src="../Images/ca50de647c787ab5e1e5953d05f75cce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p8IYgn8FMhEg8nLw4r1v-Q@2x.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">f(x)= x +y 函数的曲面图</p></figure><p id="5264" class="pw-post-body-paragraph mm mn ji lr b ls mz kj mo lu na km mp lw nk mr ms ly nl mu mv ma nm mx my mc im bi translated">2.每个 boid 保持跟踪它曾经经历过的最佳位置，这在某种预定义的程度上有助于 boid 的当前速度。</p><p id="acd9" class="pw-post-body-paragraph mm mn ji lr b ls mz kj mo lu na km mp lw nk mr ms ly nl mu mv ma nm mx my mc im bi translated">3.这是整个鸟群所见过的最佳位置。因此，它将以预定的速率影响所有物体的速度。</p><p id="23a7" class="pw-post-body-paragraph mm mn ji lr b ls mz kj mo lu na km mp lw nk mr ms ly nl mu mv ma nm mx my mc im bi translated">通过使用上述规则，我们可以很容易地推导出驱动每个 boid 的数学方程。</p><figure class="ng nh ni nj gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nn"><img src="../Images/74753fc608453d59fc1edd7961211519.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CYwixdI1FMpsEwcOZrHBQQ@2x.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">计算 Delta V 的向量表示</p></figure><figure class="ng nh ni nj gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi no"><img src="../Images/c0cb9a7c38ef703d6809c86e3d1ff16f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QopK57QWQl0atyHAl548hA.png"/></div></div></figure><p id="7030" class="pw-post-body-paragraph mm mn ji lr b ls mz kj mo lu na km mp lw nk mr ms ly nl mu mv ma nm mx my mc im bi translated">在上面的等式中:</p><ul class=""><li id="13f3" class="lp lq ji lr b ls mz lu na lw nb ly nc ma nd mc md me mf mg bi translated">w——惯性决定了 boid 的当前速度对δV 的影响程度</li><li id="1472" class="lp lq ji lr b ls mh lu mi lw mj ly mk ma ml mc md me mf mg bi translated">c₂c₁——定义了 boid 和 swarm 的最佳记录位置将如何分别影响δv</li></ul><p id="cdb7" class="pw-post-body-paragraph mm mn ji lr b ls mz kj mo lu na km mp lw nk mr ms ly nl mu mv ma nm mx my mc im bi translated">w、c₁、c₂、学习率——是在优化过程中应该微调的超参数。</p><h1 id="8199" class="kx ky ji bd kz la lb lc ld le lf lg lh ko li kp lj kr lk ks ll ku lm kv ln lo bi translated"><strong class="ak">使用 Python 实现理论</strong></h1><p id="2d67" class="pw-post-body-paragraph mm mn ji lr b ls lt kj mo lu lv km mp lw mq mr ms ly mt mu mv ma mw mx my mc im bi translated">对群体智能背后的数学理论进行了讨论和建模，它可以使用任何现代编程语言来实现。然而，由于它的广泛使用，实现将使用 Python 来实现。不过，在本文的参考资料部分，也可以找到 C++项目代码。为了测试该算法，Rastrigin 函数将被用作误差函数，这是优化问题中最具挑战性的函数之一。在平面上有大量的余弦振荡会引入无数的局部最小值，在这些局部最小值中，物体会被卡住。</p><figure class="ng nh ni nj gt iv gh gi paragraph-image"><div class="gh gi np"><img src="../Images/e56b54a03ea43e32fea0df59029c9790.png" data-original-src="https://miro.medium.com/v2/resize:fit:906/format:webp/1*egc5BvvR63j-bsMz-HcxsA.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">拉斯特里金函数</p></figure><figure class="ng nh ni nj gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nq"><img src="../Images/7d79c56dce364458d97eb9d249ca296c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YG3Q22p3jf4lozGdF-Jikg.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae nr" href="https://www.wikiwand.com/en/Rastrigin_function" rel="noopener ugc nofollow" target="_blank">Rastrigin 函数的 3D 曲面:</a>【1】</p></figure><figure class="ng nh ni nj gt iv"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="2493" class="pw-post-body-paragraph mm mn ji lr b ls mz kj mo lu na km mp lw nk mr ms ly nl mu mv ma nm mx my mc im bi translated">如上所述，每个 boid 都有一个位置、速度、误差、最佳位置和已知误差。我们还应该编写一个 setter 函数，在需要时修改参数。</p><figure class="ng nh ni nj gt iv"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="b5ac" class="pw-post-body-paragraph mm mn ji lr b ls mz kj mo lu na km mp lw nk mr ms ly nl mu mv ma nm mx my mc im bi translated">PSO 类将由误差函数表面上的移动粒子列表组成。为了初始化函数，需要函数的维数、boids 的数量以及历元的数量。</p><figure class="ng nh ni nj gt iv"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="755c" class="pw-post-body-paragraph mm mn ji lr b ls mz kj mo lu na km mp lw nk mr ms ly nl mu mv ma nm mx my mc im bi translated">最后，我们编写代码来找到最佳优化误差函数的位置。首先，在每个时期，每个粒子被一个接一个地挑选并且优化它的位置。一旦粒子的位置被更新，“if”语句将检查它是否是蜂群的最佳位置。</p><figure class="ng nh ni nj gt iv"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="12ab" class="pw-post-body-paragraph mm mn ji lr b ls mz kj mo lu na km mp lw nk mr ms ly nl mu mv ma nm mx my mc im bi translated">现在，是时候运行 PSO 并观察算法的性能了。</p><figure class="ng nh ni nj gt iv"><div class="bz fp l di"><div class="ns nt l"/></div></figure><figure class="ng nh ni nj gt iv"><div class="bz fp l di"><div class="ns nt l"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">粒子群输出</p></figure><p id="27ac" class="pw-post-body-paragraph mm mn ji lr b ls mz kj mo lu na km mp lw nk mr ms ly nl mu mv ma nm mx my mc im bi translated">从下面的等值线图可以很容易地看出，swarm 只需要几个历元就可以收敛到 Rastrigin 函数的全局最小值。要获得创建轮廓可视化的代码以及流程的误差历元图，可以参考参考资料和参考资料一节中给出的链接。</p><figure class="ng nh ni nj gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/2aa19da1fac9234ddbcaf237865daf06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*fV1HNUyYqXotq-whw_gHSw.gif"/></div></div></figure><h1 id="f753" class="kx ky ji bd kz la lb lc ld le lf lg lh ko li kp lj kr lk ks ll ku lm kv ln lo bi translated"><strong class="ak">结论</strong></h1><p id="f28a" class="pw-post-body-paragraph mm mn ji lr b ls lt kj mo lu lv km mp lw mq mr ms ly mt mu mv ma mw mx my mc im bi translated">总而言之，粒子群优化模拟了鸟(或鱼)群体的集体行为。它受益于自然形成的解决自身优化问题以最小化能量使用的方式。大自然的设计及其原理在计算机科学问题上的实际应用是了不起的。虽然有无数的资源可以帮助你获得更多关于涌现和 PSO 的见解，但我将列出一些有区别的资源，你可以用它们来更深入地挖掘群体智能的主题。</p><h1 id="1e8b" class="kx ky ji bd kz la lb lc ld le lf lg lh ko li kp lj kr lk ks ll ku lm kv ln lo bi translated">资源和参考资料</h1><p id="0538" class="pw-post-body-paragraph mm mn ji lr b ls lt kj mo lu lv km mp lw mq mr ms ly mt mu mv ma mw mx my mc im bi translated">[1] <a class="ae nr" href="https://www.wikiwand.com/en/Rastrigin_function" rel="noopener ugc nofollow" target="_blank">维基百科，拉斯特里金函数</a></p><p id="2178" class="pw-post-body-paragraph mm mn ji lr b ls mz kj mo lu na km mp lw nk mr ms ly nl mu mv ma nm mx my mc im bi translated">[2] <a class="ae nr" href="https://bitbucket.org/tarlanahad/myneatcodes/src/master/PSO/" rel="noopener ugc nofollow" target="_blank"> T. Ahadli，粒子群优化 C++/Python 项目代码</a></p><p id="8fbc" class="pw-post-body-paragraph mm mn ji lr b ls mz kj mo lu na km mp lw nk mr ms ly nl mu mv ma nm mx my mc im bi translated">[3] <a class="ae nr" href="https://theconversation.com/emergence-the-remarkable-simplicity-of-complexity-30973" rel="noopener ugc nofollow" target="_blank">对话，复杂中的非凡简单</a></p><p id="05e6" class="pw-post-body-paragraph mm mn ji lr b ls mz kj mo lu na km mp lw nk mr ms ly nl mu mv ma nm mx my mc im bi translated">[4] <a class="ae nr" href="https://www.youtube.com/watch?v=4BdjxYUdJS8" rel="noopener ugc nofollow" target="_blank">《国家地理》，蚂蚁如何只用身体在半空中搭建桥梁</a></p><p id="c80d" class="pw-post-body-paragraph mm mn ji lr b ls mz kj mo lu na km mp lw nk mr ms ly nl mu mv ma nm mx my mc im bi translated">[5] <a class="ae nr" href="http://youtube.com/watch?v=bVDX_UwthZI" rel="noopener ugc nofollow" target="_blank">詹姆斯·麦卡弗里，利用 Python 实现群体智能优化</a></p></div></div>    
</body>
</html>