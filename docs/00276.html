<html>
<head>
<title>Where Machine Learning meets Cryptography</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">机器学习遇到密码学</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/where-machine-learning-meets-cryptography-b4a23ef54c9e?source=collection_archive---------5-----------------------#2020-01-09">https://towardsdatascience.com/where-machine-learning-meets-cryptography-b4a23ef54c9e?source=collection_archive---------5-----------------------#2020-01-09</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="e15b" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">通过机器学习解决带噪声的密码相关学习奇偶校验问题</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/ebfca13da2908b81b8c39133ddbcb5fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1Q2b0mp1hAFRAfBgPXg-oA.png"/></div></div></figure><p id="0705" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">当你读到这里的时候，很可能你已经知道一些关于机器学习的事情。你知道机器学习算法通常会接受一堆<em class="lr">样本，</em>每个样本包含固定数量的<em class="lr">特征，</em>并最终输出一个<em class="lr">预测</em>。</p><p id="a9ee" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">你可能听说过(但没有深入研究)的是<em class="lr">密码学</em>领域。这是一个神秘的话题，涉及到安全、密码和隐藏的东西。也许你甚至听说过<em class="lr"> AES </em>或<em class="lr"> RSA </em>，它们是<em class="lr">加密</em>数据<em class="lr">的算法。</em></p><p id="95a9" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">但是不要担心，即使您以前从未接触过密码学，您也能够理解，因为我将从入门的角度来解释一切。</p></div><div class="ab cl ls lt hy lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="in io ip iq ir"><p id="fb29" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">在这篇文章中，我想把这两个领域结合起来。我将向您介绍一个易于理解但难以解决的用于构建密码算法的问题——所谓的<strong class="kx iv">带噪声的学习奇偶校验</strong>问题，简称<strong class="kx iv"> LPN </strong>。LPN 中的“L”应该已经给你的机器学习敲响了警钟，因为这个问题可以被视为一个常规的机器学习问题！</p><p id="91ae" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">但首先，让我们看看 LPN 问题在加密设置中自然出现在哪里，以及如何定义它。之后，我们将使用机器学习来解决 LPN 问题。</p><h1 id="369b" class="lz ma iu bd mb mc md me mf mg mh mi mj ka mk kb ml kd mm ke mn kg mo kh mp mq bi translated">动机</h1><p id="e076" class="pw-post-body-paragraph kv kw iu kx b ky mr jv la lb ms jy ld le mt lg lh li mu lk ll lm mv lo lp lq in bi translated">假设您拥有一家酒店，并且您想要管理对客人房间的访问，即每个客人应该只能进入他们自己的房间。有道理，对吧？</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj mw"><img src="../Images/66b1b19a59be36cba631bb33814ca17e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SoUEy9zk-c09CQ1W"/></div></div><p class="mx my gk gi gj mz na bd b be z dk translated">你的酒店。照片由<a class="ae nb" href="https://unsplash.com/@abovedaworld?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">英治 K </a>在<a class="ae nb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><p id="db82" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">现在，传统上你可以使用普通的物理钥匙。缺点是，人们有时会丢失钥匙，这意味着您的业务会有很大的成本，因为您必须更换受影响的门上的锁。</p><p id="87b1" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">因此，您决定部署智能卡，特别是带有 RFID(射频识别)<strong class="kx iv"> </strong>芯片的卡，以及相应的锁。由于你必须提供许多门，并且你想省钱，你选择<strong class="kx iv">非常弱的 RFID 芯片</strong>，即计算能力递减的芯片，甚至可能没有自己的电源。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nc"><img src="../Images/09b6ecb667bbc73a8a6ad4d508855d1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nZUcQN8mrHJAMa6Y_IyC-Q.jpeg"/></div></div><p class="mx my gk gi gj mz na bd b be z dk translated">苏珊·普兰克在<a class="ae nb" href="https://pixabay.com/de/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=4312260" rel="noopener ugc nofollow" target="_blank">皮克斯贝</a>拍摄的照片。</p></figure><p id="bc90" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">你的系统应该是这样工作的:每把锁和每张卡都存储了一个<strong class="kx iv">密钥</strong>，一个二进制向量，比如<em class="lr"> s= </em> (1，0，1，0)，<em class="lr">实际上要长得多</em>。如果你把你的卡放在一把锁旁边，这把锁就像一个阅读器一样扫描卡的密钥。在这种情况下，芯片被称为<strong class="kx iv">标签</strong>。</p><blockquote class="nd"><p id="5a84" class="ne nf iu bd ng nh ni nj nk nl nm lq dk translated">线索:如果卡和门的秘密钥匙匹配，门就会打开。</p></blockquote><p id="da23" class="pw-post-body-paragraph kv kw iu kx b ky nn jv la lb no jy ld le np lg lh li nq lk ll lm nr lo lp lq in bi translated">完美！但是怎么做呢？嗯，一个简单的方法是把你的卡放在锁旁边，锁告诉卡上的芯片把它的密钥发送给锁。然后，锁检查两个密钥是否相等，如果相等，则开门。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj ns"><img src="../Images/ea98b0afbe7200779c87367f3c6a9dfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/1*CSjtPGmfHH-MQ-W3AoTszA.png"/></div></figure><p id="813f" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">这是有意义的，因为如果您没有正确的卡，即您芯片上的密钥与门锁中的密钥不同，门将无法打开。</p><h2 id="2f74" class="nt ma iu bd mb nu nv dn mf nw nx dp mj le ny nz ml li oa ob mn lm oc od mp oe bi translated">问题是</h2><p id="5f6d" class="pw-post-body-paragraph kv kw iu kx b ky mr jv la lb ms jy ld le mt lg lh li mu lk ll lm mv lo lp lq in bi translated">当客人想要进入他们的房间时，这种解决方案的麻烦就开始了:一个坏人，通常在密码学中被称为<em class="lr">攻击者</em>，可能坐在走廊上，显然只是无辜地在他们的笔记本上打字。攻击者实际做的是<a class="ae nb" href="https://en.wikipedia.org/wiki/Sniffing_attack" rel="noopener ugc nofollow" target="_blank"> <em class="lr">嗅探</em></a><em class="lr">RFID 流量，</em>即读取锁和客人芯片之间的通信。如果芯片直接发送密钥，攻击者将看到它，存储它，伪造一个包含这个密钥的卡，然后将能够进入房间。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj of"><img src="../Images/bb9075a3b2a0f82d6b045ac737f581a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GevR3azbt8CufTuA"/></div></div><p class="mx my gk gi gj mz na bd b be z dk translated">一个典型的黑客在工作，这一次没有滑雪面具。纳赫尔·阿卜杜勒·哈迪在<a class="ae nb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="b096" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">所以，这是个坏主意。只有在世界上没有坏人的情况下(极不可能)才有效。相反，我们必须武装自己，为我们的客人提高安全性。想法是这样的:</p><blockquote class="nd"><p id="ec85" class="ne nf iu bd ng nh ni nj nk nl nm lq dk translated">芯片必须以某种方式向锁证明它拥有正确的密钥，而不泄露它。</p></blockquote><p id="fd80" class="pw-post-body-paragraph kv kw iu kx b ky nn jv la lb no jy ld le np lg lh li nq lk ll lm nr lo lp lq in bi translated">我听到你尖叫:<strong class="kx iv"> <em class="lr">这就是加密的作用！</em> </strong>你说的没错。攻击者只能在嗅探工具中看到垃圾，而无法重建密钥。但可悲的是，RFID 芯片对于加密任何东西来说都太弱了，因为你想省钱，记得吗？<em class="lr">可悲的是，现实世界中的大公司也是如此。这种芯片几乎没有计算能力，存储空间也只能勉强容纳密钥。因此，我们需要另一种更轻量级的解决方案。</em></p><p id="63c6" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">一种方法是使用类似于<strong class="kx iv"> Hopper </strong>和<strong class="kx iv"> Blum </strong>的<strong class="kx iv"> HB 协议</strong>的加密协议。这个协议使得攻击者很难提取密钥。</p></div><div class="ab cl ls lt hy lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="in io ip iq ir"><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj og"><img src="../Images/b41b852fc88b27ffd7f60e094ccfc14e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IgFqYPoKaKHOUbZM"/></div></div><p class="mx my gk gi gj mz na bd b be z dk translated">照片由<a class="ae nb" href="https://unsplash.com/@gohrhyyan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Goh Rhy Yan </a>在<a class="ae nb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="0fc1" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><strong class="kx iv"> <em class="lr">我要介绍的 vanilla HB 协议还有其他漏洞，不应该在实际中使用。我用它只是因为它容易解释。为了现实世界的安全，应该使用该协议或其他安全协议的更安全的扩展。</em>T19】</strong></p><h2 id="ce45" class="nt ma iu bd mb nu nv dn mf nw nx dp mj le ny nz ml li oa ob mn lm oc od mp oe bi translated">血红蛋白协议</h2><p id="f686" class="pw-post-body-paragraph kv kw iu kx b ky mr jv la lb ms jy ld le mt lg lh li mu lk ll lm mv lo lp lq in bi translated">所以，你有一个<strong class="kx iv">阅读器<em class="lr">R</em>T23】(锁)和一个<strong class="kx iv">标签<em class="lr">T</em>T27】(你的芯片)。<em class="lr"> T </em>现在想要向<em class="lr"> R </em>证明它拥有相同的密钥<strong class="kx iv">而不泄露它。</strong>这是通过<em class="lr"> R </em>反复询问<em class="lr"> T </em>只有具有正确密钥的标签才能回答的问题来实现的。到目前为止，我们已经看到单个问题“你的秘密密钥是什么？”是不安全的，因为这已经暴露了太多的信息。相反，在 HB 协议中<em class="lr"> T </em>被要求一次只透露一小部分秘密，直到<em class="lr"> R </em>能够确定<em class="lr"> T </em>拥有正确的秘密密钥。</strong></strong></p></div><div class="ab cl ls lt hy lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="in io ip iq ir"><p id="99c3" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">假设<em class="lr"> R </em>和<em class="lr"> T </em>的密钥实际上都是同一个<em class="lr"> s </em> =(1，0，1，0)。现在<em class="lr"> R </em>向<em class="lr"> T </em>发送一个随机二进制向量<em class="lr"> a </em>(例如<em class="lr"> a </em> = (1，0，1，1))，并期望<em class="lr"> T </em>用标量积<em class="lr"> b </em> = <em class="lr"> &lt; a，s &gt;，</em>对其进行响应，即</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oh"><img src="../Images/a3b2040401d086b57647ade3e80549e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P357qGHJJB3t2tBjxfgaww.png"/></div></div></figure><p id="9fe2" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">在这个例子中。我们称这个<em class="lr">为</em>为<em class="lr">挑战</em>。记住，我们在这里处理的是位算术，所以“+”实际上是一个 XOR。乘法和实数乘法是一样的。或者对数学家来说:我们在域 GF(2)或𝔽₂中计算，这个域有两个元素。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj oi"><img src="../Images/42990a1fddd6dbe0a64d399859f05582.png" data-original-src="https://miro.medium.com/v2/resize:fit:572/format:webp/1*eSpUgGFX-hejqsJggJmhHg.png"/></div><p class="mx my gk gi gj mz na bd b be z dk translated">异或就像整数的普通加法，只是 1+1=0。</p></figure><p id="a9d2" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><em class="lr"> R </em>可以自己计算标量积(它知道<em class="lr"> a </em>和<em class="lr"> s </em>)并检查<em class="lr"> T </em>的答案。如果<em class="lr"> T </em>的答案是相同的，那么<em class="lr"> R </em>可以更加确信<em class="lr"> T </em>确实拥有相同的密钥。为了增加信心，这个游戏要重复几次。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj oj"><img src="../Images/c9a78da04b7710ef6ccaabe995511b35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*hE_lhqPmOBFVb2XGJOl5AQ.png"/></div></figure><p id="d5d6" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">例如，如果<em class="lr"> T </em>没有正确的密钥，那么在足够多的回合之后，它很可能不会成功，因为单个响应的正确概率只有 0.5。因此，例如，在 10 轮之后，成功认证的机会仅为 1/1024，<strong class="kx iv">小于 0，1% </strong>。</p><p id="4a32" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">这听起来好多了吧？T 现在并没有一口气透露它的秘密，相反，它通过回答挑战给了<em class="lr"> R </em>一些信息。<strong class="kx iv">但可悲的是，这也是完全没有安全感的。</strong>攻击者仍然可以写下<em class="lr"> R </em>和<em class="lr"> T </em>之间的完整通信，然后轻松求解线性方程组来恢复<em class="lr"> s </em>。这是通过以下方式完成的:假设攻击者已经为挑战/响应对写下了以下内容:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj ok"><img src="../Images/f7dd3ab1e9e282c52dd99a535c5176f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/format:webp/1*O-Ztd8Yatm186yQmjPoNlA.png"/></div></figure><p id="de25" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">攻击者也知道</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ol"><img src="../Images/0d2d31e08787f9b7650c4d1e8b17d725.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HzCMrOn-pCIOOcINlzXu1g.png"/></div></div></figure><p id="edec" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">其中<em class="lr"> A </em>是包含<em class="lr"> aᵢ </em>行和<em class="lr">b</em>bᵢ行的矩阵。在我们的例子中:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj om"><img src="../Images/18938128951dafe481fd8c8c39208b4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*qeAgSRQ9yRg22G3ZiYRKmw.png"/></div><p class="mx my gk gi gj mz na bd b be z dk translated">攻击者必须解决的线性方程组。</p></figure><p id="c5f3" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">因此，解决这个系统为<em class="lr">的</em>产生的秘密。如果<em class="lr"> s </em>大得多，即 1024 位长，这也可以通过<a class="ae nb" href="https://en.wikipedia.org/wiki/Gaussian_elimination" rel="noopener ugc nofollow" target="_blank">高斯消除</a>容易地完成。顺便说一下解决方法是<em class="lr"> s </em> = (1，0，1，0)。😎</p><h1 id="12a4" class="lz ma iu bd mb mc md me mf mg mh mi mj ka mk kb ml kd mm ke mn kg mo kh mp mq bi translated">噪声问题下的学习奇偶校验</h1><p id="db86" class="pw-post-body-paragraph kv kw iu kx b ky mr jv la lb ms jy ld le mt lg lh li mu lk ll lm mv lo lp lq in bi translated">有一个非常小但是非常重要的调整来防止我们的攻击者:<em class="lr"> T </em>只是在它的响应中添加了一些随机的<a class="ae nb" href="https://en.wikipedia.org/wiki/Bernoulli_distribution" rel="noopener ugc nofollow" target="_blank">伯努利</a>噪声。它不是将<em class="lr"> &lt; a，s</em>发送回<em class="lr"> R，</em>而是掷一枚概率为<em class="lr"> p </em>为 1，否则为 0 的硬币<em class="lr"> e，并将<em class="lr">T88】a，s &gt; +e </em>发送回阅读器<em class="lr">。</em>换句话说，标签以概率 1- <em class="lr"> p </em>将<em class="lr"> &lt; a，s &gt; </em>发送回<em class="lr"> R </em>，并以概率<em class="lr"> p </em>将响应位从 0 翻转到 1 或从 1 翻转到 0 <em class="lr">。</em>我们假设<em class="lr">p&lt;T29】0.5。</em></em></p><p id="119d" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">这并不能<strong class="kx iv">而不是</strong>阻止攻击者嗅探<em class="lr"> R </em>和<em class="lr"> T </em>之间的通信，并做笔记<em class="lr">，</em>当然，但他们现在必须解决以下问题:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj on"><img src="../Images/89d31bb254e5394a4411808ab867cd61.png" data-original-src="https://miro.medium.com/v2/resize:fit:246/format:webp/1*1Zsg0Zf0WBIIcLU4-134Gw.png"/></div></figure><p id="d295" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><strong class="kx iv">这个符号表示方程组的每个方程只有概率 1- <em class="lr"> p </em>才是正确的。更正式地说，你可以把它写成<em class="lr"> As+e=b，</em>其中<em class="lr"> e </em>是噪声向量，每个分量(独立地)以概率<em class="lr"> p </em>为 1，以概率 1-<em class="lr">p</em></strong>为 0</p><blockquote class="nd"><p id="71b2" class="ne nf iu bd ng nh ni nj nk nl nm lq dk translated">因此，攻击者必须在 GF(2)上解一个嘈杂的方程组。对于一个恒定的错误率 p，这个问题——带噪声的学习奇偶校验(LPN)问题——被认为对于足够长的密钥长度是不可行的。如果攻击者可以获得任意多个方程，这也是正确的。</p></blockquote><p id="e768" class="pw-post-body-paragraph kv kw iu kx b ky nn jv la lb no jy ld le np lg lh li nq lk ll lm nr lo lp lq in bi translated">即使添加了这些错误，<em class="lr"> R </em>也可以完成确定<em class="lr"> T </em>是否知道<em class="lr"> s </em>的工作。如果<em class="lr"> T </em>具有正确的<em class="lr"> s，</em>大约 1- <em class="lr"> p </em>响应的一小部分将是正确的<em class="lr">。</em>这意味着如果<em class="lr"> p </em> = 0.25，HB 协议运行 1000 次迭代，<em class="lr"> T </em>应该给<strong class="kx iv">大约 750 个正确响应</strong>。</p><p id="5ee1" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">如果<em class="lr"> T </em>没有正确的<em class="lr"> s </em>，它将给出大约 0.5 个正确答案的分数，即<strong class="kx iv">1000 个</strong>回合中的 500 个回合协议运行。这允许<em class="lr"> R </em>决定<em class="lr"> T </em>是否有正确的秘密，并且这个协议对我们的用例仍然有意义。</p><h2 id="9dbe" class="nt ma iu bd mb nu nv dn mf nw nx dp mj le ny nz ml li oa ob mn lm oc od mp oe bi translated">通过机器学习求解 LPN</h2><p id="a556" class="pw-post-body-paragraph kv kw iu kx b ky mr jv la lb ms jy ld le mt lg lh li mu lk ll lm mv lo lp lq in bi translated">现在让我们开始有趣的部分。我们已经确定，解决 LPN 问题意味着，给定一个随机二进制矩阵<em class="lr"> A </em>和一个二进制向量<em class="lr"> b=As+e </em>，恢复<em class="lr"> s. </em></p><p id="e410" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><strong class="kx iv">重要观察:</strong>我们可以把矩阵<em class="lr"> A </em>的每一行<em class="lr"> aᵢ </em>现在作为一个样本，把向量<em class="lr"> b </em>中对应的值<em class="lr"> bᵢ= &lt; aᵢ，s &gt; +eᵢ </em>作为标签。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oo"><img src="../Images/09e3bc60003eb2a79d0d008bfa47759f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JUy-S7FWiRM8eZ0YblSWQA.png"/></div></div><p class="mx my gk gi gj mz na bd b be z dk translated">使用秘密长度为 4 和六个捕获的通信的例子，我们可以看到矩阵 A 的每一行包括四个特征，并且 b 中的条目是相应的标签。我们的数据集大小为 6。</p></figure><p id="30a2" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">正如在机器学习中使用的正常数据集所发现的，标签<em class="lr"> bᵢ </em>实际上类似于特征向量<em class="lr"> aᵢ </em>和固定秘密向量<em class="lr"> s(一些基本事实)</em>的标量积，但是添加了误差项。但是，当我们抛出一个机器学习算法来预测标签时，我们如何才能获得秘密呢？</p><p id="c4c6" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">好吧，如果我们能很好地学习问题<em class="lr">，</em>，我们就能为标签生成好的预测(标积；地面真相)为每个特征向量<em class="lr"> aᵢ </em>我们喜欢。如果我们放入向量<em class="lr"> a </em> =(1，0，0，0)，那么我们会得到一个很好的猜测</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj op"><img src="../Images/612414bd02b82d8b2e423eac2da359b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*96E3CBoKyfCkfffi_PCxlg.png"/></div></div></figure><p id="fd76" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><strong class="kx iv">第一位的<em class="lr">s</em>T30】！对向量(0，1，0，0)，(0，0，1，0)和<br/> (0，0，0，1)做同样的操作，我们就有了密钥的所有位。</strong></p><p id="fa8f" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">因此，我们可以使用机器学习来解决 LPN 问题。</p><h2 id="bf00" class="nt ma iu bd mb nu nv dn mf nw nx dp mj le ny nz ml li oa ob mn lm oc od mp oe bi translated">评论</h2><p id="8a0e" class="pw-post-body-paragraph kv kw iu kx b ky mr jv la lb ms jy ld le mt lg lh li mu lk ll lm mv lo lp lq in bi translated">LPN 问题是一个非常通用的问题，您也可以使用它来构建<em class="lr">加密、基于身份的加密、用户认证、不经意传输、消息认证码</em>，以及可能更多的构造。此外，与因式分解问题不同，LPN 问题无法使用量子计算机轻松解决。与它的轻量级配对，它是构建后量子安全算法的一个很好的候选者。所以，不用担心，如果 RSA，这种基于大数分解的算法，在量子计算机面前消亡了。；)</p><p id="124f" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">关于 LPN 问题的更多信息和更好的数学定义，请参考我的论文[2]。</p><h1 id="6e65" class="lz ma iu bd mb mc md me mf mg mh mi mj ka mk kb ml kd mm ke mn kg mo kh mp mq bi translated">实验</h1><p id="1061" class="pw-post-body-paragraph kv kw iu kx b ky mr jv la lb ms jy ld le mt lg lh li mu lk ll lm mv lo lp lq in bi translated">让我们首先定义一个<em class="lr"> LPN oracle，</em>即<em class="lr"> </em>一个我们可以在实例化时用一个密钥和一个错误级别<em class="lr"> p </em>来填充的类，这给了我们想要的那么多样本。</p><p id="a7f1" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">这可以使用以下代码轻松完成:</p><pre class="kk kl km kn gu oq or os bn ot ou bi"><span id="fe19" class="ov ma iu or b be ow ox l oy oz">import numpy as np<br/><br/>class LPNOracle:<br/>    def __init__(self, secret, error_rate):<br/>        self.secret = secret<br/>        self.dimension = len(secret)<br/>        self.error_rate = error_rate<br/><br/>    def sample(self, n_amount):<br/>        # Create random matrix.<br/>        A = np.random.randint(0, 2, size=(n_amount, self.dimension))<br/>        # Add Bernoulli errors.<br/>        e = np.random.binomial(1, self.error_rate, n_amount)<br/>        # Compute the labels.<br/>        b = np.mod(A @ self.secret + e, 2)<br/>        return A, b</span></pre><p id="3703" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">我们现在可以用长度为 16 的随机秘密和 p = 0.125 来实例化这个 oracle。</p><pre class="kk kl km kn gu oq or os bn ot ou bi"><span id="5e85" class="ov ma iu or b be ow ox l oy oz">p = 0.125<br/>dim = 16<br/>s = np.random.randint(0, 2, dim)<br/>lpn = LPNOracle(s, p)</span></pre><p id="d4e0" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">我们现在可以从<code class="fe pa pb pc or b">lpn</code>开始取样:</p><pre class="kk kl km kn gu oq or os bn ot ou bi"><span id="3977" class="ov ma iu or b be ow ox l oy oz">lpn.sample(3)<br/><br/># My output:<br/># (array([[1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1],<br/>#        [1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0],<br/>#        [1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0]]),<br/># array([1, 1, 1], dtype=int32))</span></pre><p id="9d33" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">这里我们采样了 3 个数据点。现在，让我们试着用决策树找到<em class="lr">的</em>。当然，您也可以尝试逻辑回归、伯努利朴素贝叶斯和您选择的任何其他分类器。</p><pre class="kk kl km kn gu oq or os bn ot ou bi"><span id="f506" class="ov ma iu or b be ow ox l oy oz">from sklearn.tree import DecisionTreeClassifier<br/><br/>dt = DecisionTreeClassifier()<br/><br/># Get 100000 samples.<br/>A, b = lpn.sample(100000)<br/><br/># Fit the tree.<br/>dt.fit(A, b)<br/><br/># Predict all canonical unit vectors (1, 0, 0, ..., 0), (0, 1, 0 ,0, ..., 0), ..., (0, 0, ..., 0, 1).<br/>s_candidate = dt.predict(np.eye(dim))<br/><br/># Check if the candidate solution is correct.<br/>if np.mod(A @ s_candidate + b, 2).sum() &lt; 14000:<br/>    print(s_candidate, s)<br/>else:<br/>    print('Wrong candidate. Try again!')</span></pre><p id="fabf" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">学习算法可能无法捕捉基本事实并学习另一个函数。在这种情况下，向量的所谓<em class="lr">汉明权重</em>相当高(对于我们长度为 100000 的向量来说大约为 50000)<em class="lr">。</em>这对应于标签<em class="lr"> T </em>具有错误密钥并且可以正确回答大约一半挑战的情况。如果<em class="lr"> s </em> _candidate = <em class="lr"> s，</em>汉明重量将在 0.125 * 100000 = 12500 左右。</p><p id="d946" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">在这个例子中，阈值为 14000 是在识别正确的秘密和不输出错误的候选解之间的一个很好的折衷。你可以在[2，23 页]中找到如何得到这个界限。</p><h1 id="5910" class="lz ma iu bd mb mc md me mf mg mh mi mj ka mk kb ml kd mm ke mn kg mo kh mp mq bi translated">结论</h1><p id="988f" class="pw-post-body-paragraph kv kw iu kx b ky mr jv la lb ms jy ld le mt lg lh li mu lk ll lm mv lo lp lq in bi translated">我们已经定义了 LPN 问题，并了解了当试图破解加密 HB 协议时它是如何出现的。然后我们用一个简单的决策树解决了一个小问题。</p><p id="d3f0" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><strong class="kx iv">但旅程才刚刚开始:</strong>我们可以用其他/更好的算法(深度学习，有人吗？)或巧妙的花招来</p><ul class=""><li id="d03c" class="pd pe iu kx b ky kz lb lc le pf li pg lm ph lq pi pj pk pl bi translated">获得更高的成功率，</li><li id="6c13" class="pd pe iu kx b ky pm lb pn le po li pp lm pq lq pi pj pk pl bi translated">使用更少的样本和</li><li id="f583" class="pd pe iu kx b ky pm lb pn le po li pp lm pq lq pi pj pk pl bi translated">能够解决更高维度的问题。</li></ul></div><div class="ab cl ls lt hy lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="in io ip iq ir"><p id="aa8b" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">关于求解 LPN 的非机器学习算法的列表和解释，请查看我的论文[2]。还有，如果你想出名，比如试着求解一个秘密长度为 512，p=0.125 的实例。这个 LPN 实例目前未被破坏，用于一些现实世界的密码系统。祝你好运！；)</p><h1 id="08ea" class="lz ma iu bd mb mc md me mf mg mh mi mj ka mk kb ml kd mm ke mn kg mo kh mp mq bi translated">参考</h1><p id="c7df" class="pw-post-body-paragraph kv kw iu kx b ky mr jv la lb ms jy ld le mt lg lh li mu lk ll lm mv lo lp lq in bi translated">[1] N. Hopper 和 M. Blum，<a class="ae nb" href="https://link.springer.com/chapter/10.1007/3-540-45682-1_4" rel="noopener ugc nofollow" target="_blank">安全人类识别协议</a> (2001)，密码学与信息安全理论与应用国际会议，Springer</p><p id="ca26" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">[2] R. Kübler，<a class="ae nb" href="https://hss-opus.ub.ruhr-uni-bochum.de/opus4/frontdoor/deliver/index/docId/5940/file/diss.pdf" rel="noopener ugc nofollow" target="_blank">学习奇偶与噪声问题的时间记忆权衡</a> (2018)，学位论文(波鸿鲁尔大学)</p></div><div class="ab cl ls lt hy lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="in io ip iq ir"><p id="66cb" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">我希望你今天学到了新的、有趣的、有用的东西。感谢阅读！</p><p id="fcaf" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><strong class="kx iv">作为最后一点，如果你</strong></p><ol class=""><li id="6fd3" class="pd pe iu kx b ky kz lb lc le pf li pg lm ph lq pr pj pk pl bi translated"><strong class="kx iv">想支持我多写点机器学习和</strong></li><li id="1943" class="pd pe iu kx b ky pm lb pn le po li pp lm pq lq pr pj pk pl bi translated"><strong class="kx iv">无论如何，计划获得一个中等订阅，</strong></li></ol><p id="139f" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><strong class="kx iv">为什么不做</strong> <a class="ae nb" href="https://dr-robert-kuebler.medium.com/membership" rel="noopener"> <strong class="kx iv">通过这个环节</strong> </a> <strong class="kx iv">？这将对我帮助很大！😊</strong></p><p id="4a9d" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><em class="lr">说白了，给你的价格不变，但是大约一半的订阅费直接归我。</em></p><p id="5381" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">非常感谢，如果你考虑支持我的话！</p><blockquote class="nd"><p id="9ca4" class="ne nf iu bd ng nh ni nj nk nl nm lq dk translated"><em class="ps">有问题就在</em> <a class="ae nb" href="https://www.linkedin.com/in/dr-robert-k%C3%BCbler-983859150/" rel="noopener ugc nofollow" target="_blank"> <em class="ps"> LinkedIn </em> </a> <em class="ps">上写我！</em></p></blockquote></div></div>    
</body>
</html>