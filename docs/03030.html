<html>
<head>
<title>Why Logarithms Are So Important In Machine Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么对数在机器学习中如此重要</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/why-logarithms-are-so-important-in-machine-learning-6d2ff7930c8e?source=collection_archive---------10-----------------------#2020-03-23">https://towardsdatascience.com/why-logarithms-are-so-important-in-machine-learning-6d2ff7930c8e?source=collection_archive---------10-----------------------#2020-03-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/f829fa0d425a0d89fffd76e60a23ac9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*G6-r9fDV37B2Dv8q"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">蒂姆·福斯特在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="4b57" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你住在一栋大楼的第10层，你是走楼梯还是乘电梯？</p><p id="2980" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这两种情况的目标是一样的:在漫长的一天工作后，你想回到你的公寓。</p><p id="a7ec" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当然，如果你是一个忙碌的人，没有时间去健身房，想把楼梯作为有氧运动的简化版，走楼梯会更好。但是，除此之外，你更有可能乘电梯。</p><p id="ef23" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们再举一个例子。</p><p id="0fe3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设你正试图去你的工作场所。不堵车的时候，开车10分钟，走路50分钟。</p><p id="7cec" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可以选择开车或走路。你仍然会到达同一个目的地，但你想节省时间。你每个工作日都去工作，而不是一生中只去一次。因此，你可能需要定期就此做出决定。</p><p id="9a62" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你希望能够更快地去上班，这样你就可以有更多的时间和家人朋友在一起。你想开始那个副业。阅读你在当地书店买的书。观看你一直想要的讲座。</p><p id="81e8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你不想花那么多时间去同一个目的地，而是想坐汽车或公共汽车去那里。这样，你就有更多的时间去做其他的事情。</p><h1 id="36bb" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用对数的好处的例子</h1><p id="85d2" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><strong class="ki iu">使用对数也是一样:</strong>你需要找到使损失函数最小化的参数，这是你在机器学习中试图解决的主要问题之一。</p><p id="062a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设您的函数如下所示:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/6eadde21c1a5ee596f3e23106f550308.png" data-original-src="https://miro.medium.com/v2/resize:fit:620/format:webp/1*cj-GKEe7L91QMfdDp3H_Dg.png"/></div></figure><p id="98f5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们找到它的一阶导数，我们最终会得到下面的表达式:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mm"><img src="../Images/06357cdb92765cf32a476ba7f2338911.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xrO11A5cElBNchaZW9u9LA.png"/></div></div></figure><p id="845c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有时，我们甚至需要找到二阶导数，因为我们需要知道函数是否是凸的。当一个函数是凸的，我们知道它只有一个极小值，所以每个局部极小值实际上都是全局极小值。</p><p id="e3e0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们的表达式中，我们将有以下内容:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mn"><img src="../Images/765c987ed8dac91b2aabeead9caa63ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jl-vaCT7tEOyphDkte5meg.png"/></div></div></figure><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mo"><img src="../Images/1beff0f3493fc96871d723606ecc2bfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Da4JxwYaUSBrrY8rJqpKQ.png"/></div></div></figure><p id="69d6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如你所见，它变得相当杂乱，对吗？</p><p id="b6e4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">而且，很繁琐。</p><p id="1082" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同一函数的对数的一阶导数要简单得多:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/20387472d157db1b4ed35647ef9d43fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/format:webp/1*xWOZ22yhkDzl8k2VDnJ2Vg.png"/></div></figure><p id="bd73" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">二阶导数也更简单:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mq"><img src="../Images/4dbcc32fe4b7035d4015d2d31ea59172.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yv2GhXd54LwUkTyzdlhFLw.png"/></div></div></figure><p id="af3b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当你实际使用对数时，你不会得到相同的函数。</p><p id="b3a9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你不需要在走路和开车时走同一条路线。你有与行人分开的车道。但你实际上并不在乎。</p><p id="f161" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这并不是说你对所有的兼职商店都很关心。你已经在家里吃了一点小吃，想直接去你的工作场所，这意味着他们无论如何都不重要。</p><p id="a9a3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你想最小化某些参数的损失函数。你需要最小化损失函数的参数。这正是一个函数和该函数的对数的共同之处:使损失函数最小化的相同参数。</p><p id="682c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你对这个函数和它的对数求导，就可以得到损失函数的最小值。</p><h1 id="3556" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">数学证明</h1><p id="c62a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">让我们证明最小化一个函数的参数等于最小化那个函数的对数的参数。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/073810418ce3fd647d6ed0b8622b6719.png" data-original-src="https://miro.medium.com/v2/resize:fit:718/format:webp/1*Mo186UQFsudLDX8fDLSPIQ.png"/></div></figure><p id="5d0a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们假设一个点<strong class="ki iu"> <em class="ms"> w* </em> </strong>是g(w) = log f(w)的局部极小值，这意味着在<strong class="ki iu"> <em class="ms"> w* </em> </strong>的一个近邻中的任何参数<strong class="ki iu"> <em class="ms"> w </em> </strong>我们都有g(w*)≤ g(w)。现在，既然<strong class="ki iu"> <em class="ms"> e </em> </strong>也通常表示为<strong class="ki iu"> <em class="ms"> exp </em> </strong>保留了单调性，我们就有:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mt"><img src="../Images/273f474bb9f66740143d1d230a2984db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TrKQ86_fkTZ5JUJ66TtGVg.png"/></div></div></figure><p id="902a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">换句话说，<strong class="ki iu"> <em class="ms"> w* </em> </strong>也是函数f的最小值，这是我们想要证明的。</p><p id="9624" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着当我们将对数应用于任何函数时，我们保留最小值或最大值(即，使函数最小化或最大化的参数，但不是函数的实际值)。</p><p id="dd9d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还需要证明取对数并不能消除函数的极小值，但我们在这里跳过了这一点。</p><p id="6b34" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们在上面的例子中看到的，这导致了更简单的计算和更好的稳定性。</p><p id="227e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你对此理解有困难，那么我们用一些情节来说明这一点。</p><p id="3622" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们以下面的函数为例:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/9c209c1a1a7f5cecc4ff13674b18b3e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:410/format:webp/1*HW_87PINOgFZf0xyOjbRSg.png"/></div></figure><p id="7d84" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其图表的一部分如下所示:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mv"><img src="../Images/1dab595adf87e2394494fc3b7908545a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a6VsN2bSXPZEORmFQR5jHg.png"/></div></div></figure><p id="f891" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它的对数是:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/08e294fd8abe83047225243d50620c49.png" data-original-src="https://miro.medium.com/v2/resize:fit:910/format:webp/1*gxVdhEseyp0xyvjsnBqPAQ.png"/></div></figure><p id="931e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其图表的一部分如下所示:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mx"><img src="../Images/ed59a076369d497804929d4851c60493.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i4WF8ixSmFaTTZXTDjNBKw.png"/></div></div></figure><p id="a8bd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如你所看到的，在这两种情况下，当x = 0.3时，我们得到了函数的最大值。</p><p id="00cf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">是的，我们没有得到相同的函数，但我们仍然有相同的临界点，帮助我们最小化损失函数。</p><p id="0dab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">仅这一点在训练机器学习模型时就非常有帮助。</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><p id="ef0c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> <em class="ms">跟我上</em> </strong> <a class="ae kf" href="https://www.twitter.com/fatosmorina/" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu"> <em class="ms">推特</em> </strong> </a></p></div></div>    
</body>
</html>