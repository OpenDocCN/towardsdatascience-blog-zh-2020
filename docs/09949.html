<html>
<head>
<title>Thought you loved Python? Wait until you meet Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以为你爱 Python？等到你遇到铁锈</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/thought-you-loved-python-wait-until-you-meet-rust-64a06d976ce?source=collection_archive---------1-----------------------#2020-07-14">https://towardsdatascience.com/thought-you-loved-python-wait-until-you-meet-rust-64a06d976ce?source=collection_archive---------1-----------------------#2020-07-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="2a69" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">意见</h2><div class=""/><div class=""><h2 id="7acb" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">小众现象如何连续第五年成为 StackOverflow 最受欢迎的语言</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/cc05c5da419ab48ebc0346254e0a1218.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xtamjXiztza275fNP3YqKw.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">有时候旧东西比你想象的更令人向往。妮可·盖里在<a class="ae lh" href="https://unsplash.com/s/photos/rusty?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="bea5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi me translated"><span class="l mf mo bm di mp"> <img alt="“T" class="lb mq mr ms mt mu fc n ih dh bf" src="../Images/342a2c9be12278887a431eff4c084f0d.png" width="93" height="79" loading="lazy" data-original-src="https://miro.medium.com/v2/resize:fit:186/1*ETmY8LRVPyvQ7IZ11Q_Q6g.jpeg"/> <span class="l mf mg mh bm mi mj mk ml mm di mn">“过去的技术拯救未来。”这是《铁锈》的创作者格雷顿·霍尔(Graydon Hoare)对他想要实现的目标的描述。</span></span></p><p id="1659" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是 Rust 的关键标志之一:使用学术界熟知但在当代编程语言中很少实现的技术。古老、可靠、有时被遗忘的技术。但最重要的是，它工作得非常好。</p><p id="baeb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这些技术主要用于一件事:安全。</p><p id="e569" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">听起来很无聊？如果你问社区，它不是。根据今年的 StackOverflow 开发者调查，多达 86.1%的 Rust 开发者喜欢这种语言，这使它成为自 2016 年以来最受欢迎的语言。</p><p id="04d8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你会认为软件开发人员是这个星球上最具创新精神的人。然而，Rust 与<em class="mv">“快速移动并打破东西”</em>咒语正好相反。然而，Rust 开发人员几乎肯定会学到他们以前从未听说过的概念。</p><p id="f915" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">从一些开发人员对代数数据类型的系统编程的新奇感到 Rust 自己的内存安全方法:每个开发人员都可以找到新的、非常有用的东西来学习。还有更多理由让<a class="ae lh" href="https://stackoverflow.blog/2020/01/20/what-is-rust-and-why-is-it-so-popular/" rel="noopener ugc nofollow" target="_blank">爱上</a>铁锈。</p><div class="mw mx gp gr my mz"><a rel="noopener follow" target="_blank" href="/you-want-to-learn-rust-but-you-dont-know-where-to-start-fc826402d5ba"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd jd gy z fp ne fr fs nf fu fw jc bi translated">你想学 Rust 但是不知道从哪里开始</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">Rust 初学者的完整资源</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">towardsdatascience.com</p></div></div><div class="ni l"><div class="nj l nk nl nm ni nn lb mz"/></div></div></a></div><h1 id="2391" class="no np it bd nq nr ns nt nu nv nw nx ny ki nz kj oa kl ob km oc ko od kp oe of bi translated">更高的内存安全性，无需垃圾收集</h1><p id="6de3" class="pw-post-body-paragraph li lj it lk b ll og kd ln lo oh kg lq lr oi lt lu lv oj lx ly lz ok mb mc md im bi translated">每种编程语言都面临着一个挑战，那就是如何安全有效地管理计算机内存。例如，Python 有一个垃圾收集器，在程序运行时不断寻找不再使用的内存并清理它。</p><p id="cd33" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在其他语言中，如 C 和 C++，程序员必须显式地分配和释放内存。因为所有与内存相关的问题都在程序运行前被清除了，所以这种方法对优化性能更好。</p><p id="5d45" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">另一方面，内存是开发人员需要一直考虑的另一件事。这就是为什么用 C 写一个程序要比用 Python 长得多的原因之一，即使它在一天结束时做同样的事情。</p><p id="a001" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Rust 走的是另一条路:内存是在编译时通过所有权系统分配的。这是一个干净利落的方法，可以确保不用的数据被清理掉，而不用强迫程序员一直考虑分配和释放内存。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ol"><img src="../Images/ecb88ed45b92a930234e7697fdc91aa5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y8KR2J468dIK4ZMrA6Fc4w.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">Rust 使用旧技术进行有效的内存管理。安迪·福肯纳在<a class="ae lh" href="https://unsplash.com/s/photos/rusty?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="1fec" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">基本上，所有权是三个<a class="ae lh" href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html" rel="noopener ugc nofollow" target="_blank">规则</a>的集合:</p><ol class=""><li id="7388" class="om on it lk b ll lm lo lp lr oo lv op lz oq md or os ot ou bi translated">Rust 中的每个值都有一个名为 owner 的变量。</li><li id="ea2e" class="om on it lk b ll ov lo ow lr ox lv oy lz oz md or os ot ou bi translated">一次只能有一个所有者。</li><li id="e533" class="om on it lk b ll ov lo ow lr ox lv oy lz oz md or os ot ou bi translated">当所有者超出范围时，该值将被丢弃，从而释放内存。</li></ol><p id="7aa7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一个简单的例子是在 Rust 中指定一个向量:</p><pre class="ks kt ku kv gt pa pb pc pd aw pe bi"><span id="631a" class="pf np it pb b gy pg ph l pi pj">fn main() {     <br/>    let a = vec![1, 2, 3];     <br/>    let b = a;                 <br/>    println!("a: {:?}", b); <br/>}</span></pre><p id="dff6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在第二行中，创建了拥有者为<code class="fe pk pl pm pb b">a</code>的向量<code class="fe pk pl pm pb b">[1, 2, 3]</code>。此后，<code class="fe pk pl pm pb b">b</code>成为了载体的主人。因为在 print 语句中调用了正确的所有者，所以该程序在执行时会编译并返回预期的结果:</p><pre class="ks kt ku kv gt pa pb pc pd aw pe bi"><span id="d15b" class="pf np it pb b gy pg ph l pi pj">a: [1, 2, 3]</span></pre><p id="e417" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">另一方面，您可以尝试用它以前的所有者<code class="fe pk pl pm pb b">a</code>来调用 vector，就像这样:</p><pre class="ks kt ku kv gt pa pb pc pd aw pe bi"><span id="b23e" class="pf np it pb b gy pg ph l pi pj">fn main() {<br/>    let a = vec![1, 2, 3];<br/>    let b = a;<br/>    println!("a: {:?}", b, a);<br/>}</span></pre><p id="6d67" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这种情况下，编译器抛出一个错误，因为第三行中已经删除了<code class="fe pk pl pm pb b">a</code>。这个主题还有很多更深入的内容，但这是基本的想法。</p><p id="ae6c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">相比之下，Python 会在第二种情况下运行。它的垃圾收集器只有在最后一次被调用后才会丢弃<code class="fe pk pl pm pb b">a</code>，这对开发人员来说很好，但从内存空间的角度来看就不那么好了。</p><p id="27b8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在 C 语言中，事情会稍微复杂一点:你必须为<code class="fe pk pl pm pb b">a</code>分配内存空间，然后将它指向 vector，然后为<code class="fe pk pl pm pb b">b</code>分配更多的内存空间，将<code class="fe pk pl pm pb b">b</code>指向<code class="fe pk pl pm pb b">a</code>，最后当你完成时，释放由<code class="fe pk pl pm pb b">a</code>和<code class="fe pk pl pm pb b">b</code>占用的空间。</p><p id="3048" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">从这个意义上说，Rust 对内存的处理方式是开发速度和性能之间的折衷。虽然它不像 Python 那么容易编写，但是一旦你理解了所有权的概念，它也不会像 C 语言那样笨拙。</p><p id="faf3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">另一方面，效率是相当惊人的:例如，开发团队<a class="ae lh" href="https://www.tilde.io" rel="noopener ugc nofollow" target="_blank"> Tilde </a>在 Rust 中重写了一些 JavaHTTP 片段后，设法减少了 90%的内存使用量<a class="ae lh" href="https://www.rust-lang.org/static/pdfs/Rust-Tilde-Whitepaper.pdf" rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pn"><img src="../Images/de944fead90eb8bf1000b8de15c003e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JwWYu0EfdkcNhyT3cZoo_Q.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">谁说铁锈不能吸引人？安娜斯塔西娅·塔拉索娃在<a class="ae lh" href="https://unsplash.com/s/photos/rusty?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="6d06" class="no np it bd nq nr ns nt nu nv nw nx ny ki nz kj oa kl ob km oc ko od kp oe of bi translated">静态打字不难看</h1><p id="83eb" class="pw-post-body-paragraph li lj it lk b ll og kd ln lo oh kg lq lr oi lt lu lv oj lx ly lz ok mb mc md im bi translated">这几乎是动态类型化和静态类型化之间的宗教战争。虽然用动态类型的语言来开发软件要容易得多，但是代码很快就会变得不可维护。这就是为什么 Python 代码与 C 语言相比很难维护的原因之一。</p><p id="fbba" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">另一方面，必须声明每个变量的类型 C-style 会变得相当烦人。如果你曾经试图在 C 语言中使用一个返回<code class="fe pk pl pm pb b">float</code>类型的函数中使用一个<code class="fe pk pl pm pb b">double</code>，你就会明白我的意思。</p><p id="05f5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Rust 走的是中间路线:它是一个静态类型系统，但它只需要程序员指定顶级类型，如函数参数和常数。在函数体内，允许 Python 风格的类型推断。</p><p id="fc54" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Rust 的一个特别<a class="ae lh" href="https://learning-rust.github.io/docs/e3.option_and_result.html" rel="noopener ugc nofollow" target="_blank">有用的特性</a>是它也有一个<code class="fe pk pl pm pb b">None</code>类型。这允许您在编译时处理异常，从而保证程序在最终用户处平稳运行。考虑这个例子，我们可以得到一个人的全名，而不管他是否有中间名:</p><pre class="ks kt ku kv gt pa pb pc pd aw pe bi"><span id="a4bd" class="pf np it pb b gy pg ph l pi pj">fn get_full_name(fname: &amp;str, mname: Option&lt;&amp;str&gt;, lname: &amp;str) -&gt; String { <br/>    match mname {<br/>        Some(n) =&gt; format!("{} {} {}", fname, n, lname),<br/>        None =&gt; format!("{} {}", fname, lname),<br/>    } <br/>}</span><span id="119e" class="pf np it pb b gy po ph l pi pj">fn main() {<br/>    println!("{}", get_full_name("Ronald", None, "McDonald"));<br/>    println!("{}", get_full_name("Dwight", Some("P."), "Eisenhower"));<br/>}</span></pre><p id="aebb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">虽然其他语言中也存在各种版本的<code class="fe pk pl pm pb b">None</code>变通办法，但它以一种简洁的方式展示了 Rust 的雄心:不使事情变得太难编写，同时尽可能保持代码的持久性和可维护性。</p><h1 id="6b11" class="no np it bd nq nr ns nt nu nv nw nx ny ki nz kj oa kl ob km oc ko od kp oe of bi translated">一种巧妙的系统编程方法</h1><p id="83f1" class="pw-post-body-paragraph li lj it lk b ll og kd ln lo oh kg lq lr oi lt lu lv oj lx ly lz ok mb mc md im bi translated">虽然 Python 是一种通用编程语言，但 Rust 和 C 一样，绝对适合系统编程。虽然 Rust 不是为最终用户开发应用程序的理想语言，但它非常适合构建为其他软件提供服务的软件。</p><p id="e6ab" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，效率是核心问题。零成本抽象就是最好的证明，它在解释代码的同时将内存使用保持在最低水平。正如 C++的发明者比雅尼·斯特劳斯特鲁普，<a class="ae lh" href="https://www.stroustrup.com/ETAPS-corrected-draft.pdf" rel="noopener ugc nofollow" target="_blank"/>:<em class="mv">“你不用的东西，不用付钱。更进一步:你所使用的，你不可能比手工编码更好了。”</em></p><p id="34e3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">例如，考虑在 Python 中将 1000 以内的所有整数相加:</p><pre class="ks kt ku kv gt pa pb pc pd aw pe bi"><span id="1aec" class="pf np it pb b gy pg ph l pi pj">sum(range(1000))</span></pre><p id="b17c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">每次代码运行时，它都会进行 1000 次迭代和添加——您可以想象这会降低代码的速度。相比之下，在 Rust 中考虑同样的事情:</p><pre class="ks kt ku kv gt pa pb pc pd aw pe bi"><span id="633b" class="pf np it pb b gy pg ph l pi pj">(0..1000).sum()</span></pre><p id="0bd8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这编译成常数<code class="fe pk pl pm pb b">499500</code>。实际上，内存使用已经减少了 1，000 倍。</p><p id="37fb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">虽然这些抽象也存在于 C 语言中，但是 Rust 大量使用了它们——事实上，一个目标是尽可能多地向语言中添加零成本的抽象。从这个意义上说，Rust 有点像 next-level C。</p><p id="3f7c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">c 已经存在了 40 多年，Rust 的目标也是如此。Rust 非常强调向后兼容性，以至于今天你仍然可以在 Rust 1.0 中运行代码。同样，如果你今天编写 Rust 代码，二十年后你仍然可以运行它。锈也不会生锈！</p><div class="mw mx gp gr my mz"><a rel="noopener follow" target="_blank" href="/rust-powered-command-line-utilities-to-increase-your-productivity-eea03a4cf83a"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd jd gy z fp ne fr fs nf fu fw jc bi translated">Rust-Powered 命令行实用程序可提高您的工作效率</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">您腰带下的现代快速工具</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">towardsdatascience.com</p></div></div><div class="ni l"><div class="pp l nk nl nm ni nn lb mz"/></div></div></a></div><h1 id="f95f" class="no np it bd nq nr ns nt nu nv nw nx ny ki nz kj oa kl ob km oc ko od kp oe of bi translated">一个小而不可思议的社区</h1><p id="ab68" class="pw-post-body-paragraph li lj it lk b ll og kd ln lo oh kg lq lr oi lt lu lv oj lx ly lz ok mb mc md im bi translated">Dropbox 强调安全性和可持续性，所有漂亮的细节都说明了这一点，难怪 Dropbox 用 Rust 重写了许多核心结构。Rust 的第一个大赞助商 Mozilla 在里面写了 Firefox 的重要部分。微软认为 C 和 C++ <a class="ae lh" href="https://thenewstack.io/microsoft-rust-is-the-industrys-best-chance-at-safe-systems-programming/#" rel="noopener ugc nofollow" target="_blank">对于关键任务软件不再安全</a>，并在 Rust 上投入了越来越多的资金。</p><p id="3643" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">不仅仅是大公司，对 Rust 的热爱也转化到了个人程序员身上。尽管到目前为止，StackOverflow 的调查对象中只有 5%的人使用 Rust，但是这些开发者对这种语言非常感兴趣。</p><p id="d5f9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是有原因的。不仅语言规范和编译器都考虑得很周全。有<code class="fe pk pl pm pb b"><a class="ae lh" href="https://rustup.rs" rel="noopener ugc nofollow" target="_blank">rustup</a></code>来安装和管理工具链。Cargo 是一个命令行工具，每个 Rust 安装都附带它，可以帮助管理依赖关系、运行测试和生成文档。</p><p id="c849" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">有<a class="ae lh" href="https://crates.io" rel="noopener ugc nofollow" target="_blank"> crates.io </a>供用户分享和发现图书馆，还有<a class="ae lh" href="https://docs.rs" rel="noopener ugc nofollow" target="_blank"> docs.rs </a>供用户记录。有来自<a class="ae lh" href="https://github.com/rust-lang/rust-clippy" rel="noopener ugc nofollow" target="_blank"> Clippy </a>的编译器 lints 和来自<a class="ae lh" href="https://github.com/rust-lang/rustfmt" rel="noopener ugc nofollow" target="_blank"> rustfmt </a>的自动格式化。</p><p id="13ed" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">除此之外，还有官方和非官方的聊天，子编辑，用户论坛，StackOverflow 问题，以及世界各地的会议。对于一个把友好放在一切之上的社区，还有什么可要求的呢？</p><h1 id="c4a4" class="no np it bd nq nr ns nt nu nv nw nx ny ki nz kj oa kl ob km oc ko od kp oe of bi translated">缺点是:在你会走之前需要先跑</h1><p id="fa49" class="pw-post-body-paragraph li lj it lk b ll og kd ln lo oh kg lq lr oi lt lu lv oj lx ly lz ok mb mc md im bi translated">Rust 令人沮丧的一点是高昂的启动成本。虽然在大多数语言中，你需要一到两天的时间来提高效率，但在 Rust 中，这更像是一两周的时间。</p><p id="c6ad" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是由于许多其他语言没有使用的新概念，以及编译时通常会有许多错误的事实。你需要在第一天就处理所有的异常，而不能像在 Python 中那样，只是写一段临时代码，然后运行并添加异常。</p><p id="0817" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">此外，由于 Rust 仍然很新，并不是所有你想要的库都已经存在了。除了官方文档和关于 StackOverflow 的各种问题，也没有那么多教程。</p><p id="b499" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">好消息是，一旦你学会了这些概念并编译好了你的程序，它就会像魔法一样运行。另外，考虑到向后兼容性，它应该还能工作 20 年。</p><p id="6596" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">考虑到你的代码的可持续性，以及 Rust 得到许多大公司支持的事实，尽管有缺点，一两周的前期学习可能是值得的。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pq"><img src="../Images/5745f1dd8d900abb0725ecfb225e92f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YEiqOS3avHvmFJwE7z75Dw.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">这种铁锈不会使你的船沉没。马特·拉默斯在<a class="ae lh" href="https://unsplash.com/s/photos/rusty?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="bccc" class="no np it bd nq nr ns nt nu nv nw nx ny ki nz kj oa kl ob km oc ko od kp oe of bi translated">底线:无所畏惧地黑客</h1><p id="2b1b" class="pw-post-body-paragraph li lj it lk b ll og kd ln lo oh kg lq lr oi lt lu lv oj lx ly lz ok mb mc md im bi translated">生锈是<a class="ae lh" href="https://steveklabnik.com/writing/rust-is-more-than-safety" rel="noopener ugc nofollow" target="_blank">多于安全</a>。但很难否认，它的许多核心概念旨在消除内存泄漏和其他安全问题。在这个软件决定一切的时代，安全是必须的。</p><p id="be2d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">每种即将到来的语言可能都有一席之地:<a class="ae lh" rel="noopener" target="_blank" href="/one-in-two-pythonistas-should-learn-golang-now-ba8dacaf06e8"> Go </a>正在越来越多地占据 Python 和 Java 的空间，<a class="ae lh" rel="noopener" target="_blank" href="/bye-bye-python-hello-julia-9230bff0df62"> Julia </a>正在数据科学领域追赶 Python，Rust 正在 Python 和 C++领域成长。让 Rust 与众不同的是它不可思议的社区，它的创新特性，以及它被设计成可以在未来几十年内工作的事实。</p><p id="638b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">还有很多工作要做，而 Rust 只能完成其中的一小部分。今天的新语言很有可能会存在一段时间，尽管其他语言也会在未来几年出现。但是如果我必须把我的牌放在一种语言上，Rust 将是一个安全的赌注。</p><p id="96c2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="mv">编辑:正如</em><a class="pr ps ep" href="https://medium.com/u/6a6a5a2d9af0?source=post_page-----64a06d976ce--------------------------------" rel="noopener" target="_blank"><em class="mv">Ketut Artayasa</em></a><em class="mv">和推特用户</em><a class="ae lh" href="https://twitter.com/dondishdev" rel="noopener ugc nofollow" target="_blank"><em class="mv">don dish</em></a><em class="mv">曾</em> <em class="mv">指出，比雅尼·斯特劳斯特鲁普是 C++的发明者，而不是 C，这在这个故事的最初版本中是错误的。此外，当 C++的意思是 C#已经被提及。这一点也已得到纠正。</em></p></div></div>    
</body>
</html>