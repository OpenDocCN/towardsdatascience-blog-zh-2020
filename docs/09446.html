<html>
<head>
<title>How to build and deploy a Machine Learning web application in a day</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在一天内构建和部署一个机器学习 web 应用程序</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-build-and-deploy-a-machine-learning-web-application-in-a-day-f194fdbd4a5f?source=collection_archive---------21-----------------------#2020-07-06">https://towardsdatascience.com/how-to-build-and-deploy-a-machine-learning-web-application-in-a-day-f194fdbd4a5f?source=collection_archive---------21-----------------------#2020-07-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="edd8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">构建 durian 分类器的一步一步的端到端指南(包括代码)</h2></div><p id="d17c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我决定构建一个 web 应用程序来对榴莲进行分类，因为嘿，为什么不呢？点击查看<a class="ae le" href="https://durian-classifier.herokuapp.com/" rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi lf"><img src="../Images/30974bcea27e479ceafa9d8ba5b1dbb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*t_k0CWZHkcYzjq0qXfhRpw.gif"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">网络应用<a class="ae le" href="https://durian-classifier.herokuapp.com/" rel="noopener ugc nofollow" target="_blank">演示</a> (GIF 由作者创建)</p></figure><p id="dcc6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于我所有的国际读者来说，如果你不知道榴莲是什么，它是一种水果(在新加坡我们称它为<em class="lr">水果之王</em>),它有着奶油般的质地，刺鼻的气味(<em class="lr">见下图</em>)和尖尖的外表。这种说的刺鼻的气味，让人要么讨厌，要么绝对喜欢(我属于后一类，<em class="lr">明显是</em>)。如果你觉得它闻起来不错，那么它的味道可能会更好。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ls"><img src="../Images/22ea9e840182709b797f76238aa64a85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vYpU01wOvRStELbl"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">榴莲长什么样(照片由<a class="ae le" href="https://unsplash.com/@jimteo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Jim Teo </a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄)</p></figure><h2 id="4384" class="lx ly it bd lz ma mb dn mc md me dp mf kr mg mh mi kv mj mk ml kz mm mn mo mp bi translated">问题陈述</h2><p id="e4b3" class="pw-post-body-paragraph ki kj it kk b kl mq ju kn ko mr jx kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">是的，这个项目的动力源于我对榴莲的热爱。你一定想知道，我们到底在分类什么？</p><p id="ad3b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你看，榴莲有很多种，它们的味道、质地和颜色都不一样。对于这个项目，我们将对四种不同类型的榴莲进行分类，即:</p><ul class=""><li id="1187" class="mv mw it kk b kl km ko kp kr mx kv my kz mz ld na nb nc nd bi translated">猫山王</li><li id="80c1" class="mv mw it kk b kl ne ko nf kr ng kv nh kz ni ld na nb nc nd bi translated">金凤(金凤凰)</li><li id="e31e" class="mv mw it kk b kl ne ko nf kr ng kv nh kz ni ld na nb nc nd bi translated">D24</li><li id="d6f2" class="mv mw it kk b kl ne ko nf kr ng kv nh kz ni ld na nb nc nd bi translated">红对虾</li></ul><p id="2d3a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些榴莲的差异可以总结在下表中:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi nj"><img src="../Images/c3e74ee9f455146faa2ad8749bd4d786.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VFJslPRzx7UOJ1XJbkG8YQ.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">来源:<a class="ae le" href="https://www.you.co/sg/blog/types-of-durians-how-to-pick-the-best-durian/" rel="noopener ugc nofollow" target="_blank">https://www . you . co/SG/blog/types-of-durians-how-to-pick-the-best-durian/</a></p></figure><p id="661c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那里有更多种类的榴莲(在这个<a class="ae le" href="https://www.shape.com.sg/food/the-ultimate-guide-to-identifying-your-favourite-durian-types-in-singapore/#:~:text=To%20distinguish%20them%2C%20look%20out,base%20of%20the%20durian%20fruit." rel="noopener ugc nofollow" target="_blank">链接</a>中找到更多)但是我认为这些榴莲的细微差别可能已经证明我们的模型很难学习。</p><h2 id="8e5b" class="lx ly it bd lz ma mb dn mc md me dp mf kr mg mh mi kv mj mk ml kz mm mn mo mp bi translated">数据收集</h2><p id="5d2a" class="pw-post-body-paragraph ki kj it kk b kl mq ju kn ko mr jx kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">每个项目都从数据收集开始。由于我们将部署的模型将用于个人和教育目的，我们将从<em class="lr"> Google Images 获取图像。如果您将图像用于其他目的，请检查版权。</em></p><p id="d3da" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将使用这个<a class="ae le" href="https://github.com/ultralytics/google-images-download" rel="noopener ugc nofollow" target="_blank"> API </a>来获取我们的图像。只需按照回购上的说明安装软件包。在说明的步骤 3 中，我们将针对我们的特定用例运行该命令(替换到<em class="lr"> chromedriver </em>的路径):</p><pre class="lg lh li lj gt nk nl nm nn aw no bi"><span id="ed16" class="lx ly it nl b gy np nq l nr ns">python3 bing_scraper.py --url 'https://www.bing.com/images/search?q=mao+shan+wang' --limit 100 --download --chromedriver &lt;path_to_chromedriver&gt;</span></pre><p id="35b2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这里，我们将下载的图片数量限制为 100 张，因为没有多少特定的“<em class="lr">茅山王</em>”图片。我们重复上述步骤三次以上，用其他品种的榴莲代替搜索。请注意，由于我们正在 API 中修改搜索 URL，查询中的<em class="lr">空格</em>将被替换为“+”(即<code class="fe nt nu nv nl b">mao+shan+wang</code>、<code class="fe nt nu nv nl b">red+prawn+durian</code>等)。</p><p id="6ad9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当然，您可以对任何想要分类的图像执行此步骤。</p><h2 id="8522" class="lx ly it bd lz ma mb dn mc md me dp mf kr mg mh mi kv mj mk ml kz mm mn mo mp bi translated">数据清理</h2><p id="9579" class="pw-post-body-paragraph ki kj it kk b kl mq ju kn ko mr jx kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">在我们的使用案例中，由于公开可用的榴莲图像不多，许多下载的图像可能与正确的榴莲品种不对应(例如，在搜索“猫山王”时，您可能会找到一种普通的“未标记”榴莲)。因此，我需要手动检查所有下载的图像，以确保颜色和背景是正确的。毕竟，拥有高质量(即标签正确)的数据胜过数量，对吗？</p><p id="bf3c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这一步确实需要一些领域知识，可能会稍微费时。(<em class="lr">但当然，数据清理是机器学习管道中的一个基本步骤，反映了数据科学家和人工智能工程师的现实。</em>)</p><p id="d024" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">清理完数据后，我们剩下的是<strong class="kk iu"> 55 </strong> D24、39 金凤、<strong class="kk iu"> 59 </strong>毛山王和<strong class="kk iu"> 68 </strong>红对虾的图像。</p><h2 id="1ce3" class="lx ly it bd lz ma mb dn mc md me dp mf kr mg mh mi kv mj mk ml kz mm mn mo mp bi translated">训练我们的榴莲分类器</h2><p id="d56d" class="pw-post-body-paragraph ki kj it kk b kl mq ju kn ko mr jx kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">我选择了使用 TensorFlow 框架，我相信大多数从业者都已经习惯了(当然，可以随意使用<em class="lr"> Pytorch </em>)。由于我们只有很少的图像，我们无疑必须使用预训练的模型，并在我们的数据集上对其进行微调。</p><p id="2482" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，确保你有下面的文件夹结构，这是稍后<code class="fe nt nu nv nl b">flow_from_directory</code>所需要的。</p><pre class="lg lh li lj gt nk nl nm nn aw no bi"><span id="37cd" class="lx ly it nl b gy np nq l nr ns">train<br/>|-- d24<br/>|-- golden-phoenix<br/>|-- mao-shan-wang<br/>|-- red-prawn<br/>valid<br/>|-- d24<br/>|-- golden-phoenix<br/>|-- mao-shan-wang<br/>|-- red-prawn</span></pre><p id="1d6f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们开始构建我们的分类器！</p><pre class="lg lh li lj gt nk nl nm nn aw no bi"><span id="d008" class="lx ly it nl b gy np nq l nr ns"># Import relevant libraries we will be using<br/>import numpy as np</span><span id="2747" class="lx ly it nl b gy nw nq l nr ns">from tensorflow.keras.initializers import glorot_uniform<br/>from tensorflow.keras.regularizers import l2<br/>from tensorflow.keras.preprocessing.image import ImageDataGenerator<br/>from tensorflow.keras.applications import Xception<br/>from tensorflow.keras.layers import (<br/>    Flatten,<br/>    Dense,<br/>    AveragePooling2D,<br/>    Dropout<br/>)<br/>from tensorflow.keras.optimizers import SGD<br/>from tensorflow.keras.preprocessing import image<br/>from tensorflow.keras import Model<br/>from tensorflow.keras.preprocessing.image import img_to_array<br/>from tensorflow.keras.callbacks import (<br/>    EarlyStopping,<br/>    ModelCheckpoint,<br/>    LearningRateScheduler<br/>)</span></pre><p id="7384" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如上所述，我们将使用的基本模型是<strong class="kk iu">异常</strong>。让我们实例化这一点，并添加一些密集层。我们将使用较小的批量 8，因为我们有许多图像。我们还需要警惕过度适应我们的小数据集。</p><pre class="lg lh li lj gt nk nl nm nn aw no bi"><span id="52f3" class="lx ly it nl b gy np nq l nr ns">SHAPE = 224<br/>BATCH_SIZE = 8</span><span id="8b31" class="lx ly it nl b gy nw nq l nr ns">model = Xception(<br/>    input_shape=(SHAPE, SHAPE, 3),<br/>    include_top=False,<br/>    weights='imagenet'<br/>)</span><span id="9196" class="lx ly it nl b gy nw nq l nr ns">x = model.output<br/>x = AveragePooling2D(pool_size=(2, 2))(x)<br/>x = Dense(32, activation='relu')(x)<br/>x = Dropout(0.1)(x)<br/>x = Flatten()(x)<br/>x = Dense(4, activation='softmax',<br/>          kernel_regularizer=l2(.0005))(x)</span><span id="c061" class="lx ly it nl b gy nw nq l nr ns">model = Model(inputs=model.inputs, outputs=x)</span><span id="f0e7" class="lx ly it nl b gy nw nq l nr ns">opt = SGD(lr=0.0001, momentum=.9)<br/>model.compile(loss='categorical_crossentropy',<br/>              optimizer=opt,<br/>              metrics=['accuracy'])</span></pre><p id="1758" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">之后，让我们使用 TensorFlow 的<code class="fe nt nu nv nl b">ImageDataGenerator</code>和<code class="fe nt nu nv nl b">flow_from_directory</code>创建我们的图像生成器对象。由于我们没有足够的训练图像，图像增强比以往任何时候都更加重要。</p><pre class="lg lh li lj gt nk nl nm nn aw no bi"><span id="a608" class="lx ly it nl b gy np nq l nr ns">train_datagen = ImageDataGenerator(<br/>    rescale=1./255,<br/>    rotation_range=15,<br/>    width_shift_range=0.1,<br/>    height_shift_range=0.1,<br/>    horizontal_flip=True<br/>)</span><span id="f906" class="lx ly it nl b gy nw nq l nr ns">valid_datagen = ImageDataGenerator(<br/>    rescale=1./255,<br/>    rotation_range=0,<br/>    width_shift_range=0.0,<br/>    height_shift_range=0.0,<br/>    horizontal_flip=False<br/>)</span><span id="5aa1" class="lx ly it nl b gy nw nq l nr ns">train_generator = train_datagen.flow_from_directory(<br/>    'train/',<br/>    target_size=(SHAPE, SHAPE),<br/>    shuffle=True,<br/>    batch_size=BATCH_SIZE,<br/>    class_mode='categorical',<br/>)</span><span id="0955" class="lx ly it nl b gy nw nq l nr ns">valid_generator = valid_datagen.flow_from_directory(<br/>    'valid/',<br/>    target_size=(SHAPE, SHAPE),<br/>    shuffle=True,<br/>    batch_size=BATCH_SIZE,<br/>    class_mode='categorical',<br/>)</span><span id="6ca4" class="lx ly it nl b gy nw nq l nr ns">&gt;&gt;&gt; Found 178 images belonging to 4 classes.<br/>&gt;&gt;&gt; Found 42 images belonging to 4 classes.</span></pre><p id="5284" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们的模型之前，让我们定义一些回调函数。</p><pre class="lg lh li lj gt nk nl nm nn aw no bi"><span id="a1f6" class="lx ly it nl b gy np nq l nr ns">earlystop = EarlyStopping(monitor='val_loss',<br/>                          patience=4,<br/>                          verbose=1)</span><span id="f4fe" class="lx ly it nl b gy nw nq l nr ns">checkpoint = ModelCheckpoint(<br/>    "model-weights/xception_checkpoint.h5",<br/>    monitor="val_loss",<br/>    mode="min",<br/>    save_best_only=True,<br/>    verbose=1<br/>)</span></pre><p id="99e7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，让我们开始训练我们的模型！</p><pre class="lg lh li lj gt nk nl nm nn aw no bi"><span id="80dd" class="lx ly it nl b gy np nq l nr ns">history = model.fit_generator(<br/>    train_generator,<br/>    epochs=30,<br/>    callbacks=[earlystop, checkpoint],<br/>    validation_data=valid_generator<br/>)</span><span id="8a35" class="lx ly it nl b gy nw nq l nr ns"># Save our model for inference<br/>model.save("model-weights/xception.h5")</span></pre><p id="763f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不幸的是，由于我们拥有的图像数量有限，我们的模型在验证集上没有达到很好的准确性。然而，由于模型微调不是本文的主要焦点，我们不会过多地讨论这个问题。</p><h2 id="fa1d" class="lx ly it bd lz ma mb dn mc md me dp mf kr mg mh mi kv mj mk ml kz mm mn mo mp bi translated">选择我们的 Web 框架</h2><p id="fa04" class="pw-post-body-paragraph ki kj it kk b kl mq ju kn ko mr jx kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">对于这个项目，我选择了使用<a class="ae le" href="https://www.streamlit.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kk iu"><em class="lr">streamlit</em></strong></a>因为它可以实现机器学习应用程序的超级快速可视化，而且方便，它也是用 Python 编写的。在我们构建好之后，我们剩下要做的就是部署它。</p><p id="04c5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，导入我们需要的库，并指定模型权重的路径。此外，由于我们使用了<code class="fe nt nu nv nl b">flow_from_directory</code>，TensorFlow 按字母顺序分配类号。照此，D24 将是 0 类，以此类推。</p><pre class="lg lh li lj gt nk nl nm nn aw no bi"><span id="3570" class="lx ly it nl b gy np nq l nr ns">import numpy as np</span><span id="87c7" class="lx ly it nl b gy nw nq l nr ns">from PIL import Image<br/>from tensorflow.keras.models import load_model<br/>from tensorflow.keras.preprocessing.image import img_to_array<br/>from tensorflow.keras.preprocessing import image<br/>import streamlit as st</span><span id="be57" class="lx ly it nl b gy nw nq l nr ns">PATH = "model-weights/"<br/>WEIGHTS = "xception.h5"<br/>CLASS_DICT = {<br/>    0: 'D24',<br/>    1: 'JIN FENG',<br/>    2: 'MAO SHAN WANG',<br/>    3: 'RED PRAWN'<br/>}</span></pre><p id="994f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们创建一个函数，将上传的图像转换成模型可以使用的格式。我们特别使用来自<code class="fe nt nu nv nl b">PIL</code>的<code class="fe nt nu nv nl b">Image</code>类，因为上传的图像是<code class="fe nt nu nv nl b">BytesIO</code>格式的。</p><pre class="lg lh li lj gt nk nl nm nn aw no bi"><span id="ec73" class="lx ly it nl b gy np nq l nr ns">def load_img(input_image, shape):<br/>    img = Image.open(input_image).convert('RGB')<br/>    img = img.resize((shape, shape))<br/>    img = image.img_to_array(img)<br/>    return np.reshape(img, [1, shape, shape, 3])/255</span></pre><p id="6812" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="lr"> Streamlit </em>的工作方式是，给定用户指定的参数的每一个变化，脚本从上到下重新运行(因此其交互式 UI)。因此，它以<code class="fe nt nu nv nl b">st.cache</code>的形式提供了一个<code class="fe nt nu nv nl b">cache</code>装饰器来缓存加载的对象。缓存通常用于数据加载步骤或任何需要长时间计算/处理的步骤。请记住，我们使用<code class="fe nt nu nv nl b">allow_output_mutation=True</code>参数，因为默认情况下这是<code class="fe nt nu nv nl b">False</code>，如果输出对象以任何方式发生变化，应用程序将被重新加载。</p><p id="53f5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们的例子中，模型对象在每次预测时都会发生变异。因此，我们将这个<code class="fe nt nu nv nl b">allow_output_mutation</code>参数设置为<code class="fe nt nu nv nl b">True</code>。我们想要缓存我们的模型的原因是因为我们不想在每次用户选择不同的图像时加载它(即模型加载只进行一次)。</p><pre class="lg lh li lj gt nk nl nm nn aw no bi"><span id="7533" class="lx ly it nl b gy np nq l nr ns"><a class="ae le" href="http://twitter.com/st" rel="noopener ugc nofollow" target="_blank">@st</a>.cache(allow_output_mutation=True)<br/>def load_own_model(weights):<br/>    return load_model(weights)</span></pre><p id="e12b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们只需要一些代码添加到 UI 中:</p><pre class="lg lh li lj gt nk nl nm nn aw no bi"><span id="3e68" class="lx ly it nl b gy np nq l nr ns">if __name__ == "__main__":<br/>    result = st.empty()<br/>    uploaded_img = st.file_uploader(label='upload your image:')<br/>    if uploaded_img:<br/>        st.image(uploaded_img, caption="your sexy durian pic",<br/>                 width=350)<br/>        result.info("please wait for your results")<br/>        model = load_own_model(PATH + WEIGHTS)<br/>        pred_img = load_img(uploaded_img, 224)<br/>        pred = CLASS_DICT[np.argmax(model.predict(pred_img))]</span><span id="2484" class="lx ly it nl b gy nw nq l nr ns">        result.success("The breed of durian is " + pred)</span></pre><p id="83dc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就对了。我们的 web 应用程序是用 Python 创建的，代码不多。您可以通过在命令行中输入以下命令来确保它(假设它将被称为<code class="fe nt nu nv nl b">app.py</code>)能够在本地运行:</p><pre class="lg lh li lj gt nk nl nm nn aw no bi"><span id="4092" class="lx ly it nl b gy np nq l nr ns">streamlit run app.py</span></pre><h2 id="2d07" class="lx ly it bd lz ma mb dn mc md me dp mf kr mg mh mi kv mj mk ml kz mm mn mo mp bi translated">将我们的模型部署到 Heroku</h2><p id="4db3" class="pw-post-body-paragraph ki kj it kk b kl mq ju kn ko mr jx kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">就我个人而言，部署不是我最喜欢的部分，但是，嘿，如果它不在网络上，那它是什么呢？所以让我们开始吧。</p><p id="d8bd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有许多方法可以为 web 应用程序提供服务，也有许多云服务提供商来托管它。在这种情况下，我选择与<a class="ae le" href="http://www.heroku.com" rel="noopener ugc nofollow" target="_blank"> <em class="lr"> Heroku </em> </a>合作主要是因为我以前没有尝试过。</p><p id="19df" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">什么是 Heroku？<em class="lr"><br/></em></strong><em class="lr">Heroku</em>是一个云平台即服务(PaaS)，支持多种编程语言，允许开发人员完全在云端构建、运行和操作应用。这篇<a class="ae le" href="https://devcenter.heroku.com/articles/how-heroku-works" rel="noopener ugc nofollow" target="_blank">文章</a>解释的很清楚。</p><p id="052b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了部署一个应用程序，我们总是需要某种版本控制来确保我们的应用程序运行在本地机器之外的另一个服务器上。为此，许多人使用 Docker 容器，指定所需的可运行的应用程序和包。</p><p id="a5d0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用 Heroku 进行部署类似于同时使用 Docker 容器和 web 托管服务。但是，它使用 Git 作为部署应用程序的主要手段。我们不需要将所有需要的文件打包到 Docker 容器中，而是必须创建一个 git 存储库来进行版本控制，然后我们可以使用熟悉的<code class="fe nt nu nv nl b">git push</code>，但是要使用<code class="fe nt nu nv nl b">heroku</code>遥控器。</p><p id="53a6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Heroku 然后使用相同的容器技术，但是以一个<strong class="kk iu"> dyno </strong>的形式。每个应用程序都放在一个 dyno(或容器)中，每个应用程序消耗“dyno-hours”(更多信息<a class="ae le" href="https://www.heroku.com/dynos#:~:text=Dynos%3A%20the%20heart%20of%20the,simplify%20development%20and%20enhance%20productivity.&amp;text=The%20containers%20used%20at%20Heroku,on%20a%20user%2Dspecified%20command." rel="noopener ugc nofollow" target="_blank">请点击</a>)。每个 Heroku 帐户都有一些可用的免费小时数，消耗的小时数取决于应用程序的活动/流量。首先，如果你没有预见到应用程序的大流量，你应该对免费层非常满意。</p><p id="0b0f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样值得注意的是，当 Heroku 收到应用程序源代码时，它会启动应用程序的构建(如在<code class="fe nt nu nv nl b">requirements.txt</code>中检索依赖项，创建必要的资产等)，然后组装成<strong class="kk iu"> slug。</strong></p><blockquote class="nx ny nz"><p id="7633" class="ki kj lr kk b kl km ju kn ko kp jx kq oa ks kt ku ob kw kx ky oc la lb lc ld im bi translated"><strong class="kk iu">术语</strong>:slug 是您的源代码、获取的依赖项、语言运行时和编译/生成的构建系统输出的捆绑包——准备执行。</p></blockquote><p id="a3f9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要在 Heroku 上部署，我们需要以下文件:</p><p id="acc0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">(1) <em class="lr"> setup.sh </em> —创建必要的目录并将一些信息(如端口号)写入一个<code class="fe nt nu nv nl b">.toml</code>文件</p><pre class="lg lh li lj gt nk nl nm nn aw no bi"><span id="c9d4" class="lx ly it nl b gy np nq l nr ns">mkdir -p ~/.streamlit/</span><span id="05a3" class="lx ly it nl b gy nw nq l nr ns">echo "\<br/>[server]\n\<br/>headless = true\n\<br/>port = $PORT\n\<br/>enableCORS = false\n\<br/>\n\<br/>" &gt; ~/.streamlit/config.toml</span></pre><p id="3dbf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">(2) <a class="ae le" href="https://devcenter.heroku.com/articles/procfile" rel="noopener ugc nofollow" target="_blank"> Procfile </a> —类似于 Dockerfile，包含我们想要执行的指令。我们将首先在<code class="fe nt nu nv nl b">setup.sh</code>中执行一些 bash 命令，然后执行<code class="fe nt nu nv nl b">streamlit run app.py</code>命令。</p><pre class="lg lh li lj gt nk nl nm nn aw no bi"><span id="cdf1" class="lx ly it nl b gy np nq l nr ns">web: sh setup.sh &amp;&amp; streamlit run app.py</span></pre><p id="511e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">(3) <em class="lr"> requirements.txt </em> —包含我们的应用程序所需的所有包依赖关系。请注意，这些是我正在使用的版本。您可以通过终端中的<code class="fe nt nu nv nl b">conda list</code>或者使用<code class="fe nt nu nv nl b">pip freeze &gt; requirements.txt</code>来获得您的环境当前使用的软件包的详细列表，从而找到您正在使用的软件包版本。</p><pre class="lg lh li lj gt nk nl nm nn aw no bi"><span id="9c01" class="lx ly it nl b gy np nq l nr ns">numpy==1.18.1<br/>spacy==2.2.4<br/>pandas==1.0.1<br/>Pillow==7.1.2<br/>streamlit==0.61.0<br/>tensorflow-cpu==2.2.0</span></pre><p id="0a07" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的文件夹目录应该如下所示:</p><pre class="lg lh li lj gt nk nl nm nn aw no bi"><span id="2e16" class="lx ly it nl b gy np nq l nr ns">app.py<br/>Procfile<br/>README.md<br/>requirements.txt<br/>setup.sh<br/>model-weights<br/>|-- xception.h5</span></pre><p id="bc89" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您以前没有创建过 Github 存储库，以下是一些简单的步骤:</p><ol class=""><li id="9923" class="mv mw it kk b kl km ko kp kr mx kv my kz mz ld od nb nc nd bi translated">创建新的存储库<repo_name/></li></ol><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi oe"><img src="../Images/d86db31896a0ed430dc86f26d9f2adfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qcVv-Vygzdx0PWnshrWEiQ.png"/></div></div></figure><p id="f4c7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">2.复制红色框中的 URL</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi of"><img src="../Images/7af44371411d8499af036f9793d7120f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i3kAVxSDLv7Je6HDVB_AMw.png"/></div></div></figure><p id="c147" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">3.从终端运行以下命令:</p><pre class="lg lh li lj gt nk nl nm nn aw no bi"><span id="025b" class="lx ly it nl b gy np nq l nr ns"># Clone the repository into our local machine<br/>git clone &lt;repo URL in step 2&gt;</span><span id="9bd9" class="lx ly it nl b gy nw nq l nr ns"># Enter the directory we just cloned<br/>cd &lt;repo_name&gt;</span></pre><p id="0f7c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">4.将之前创建的文件复制到该文件夹中，并在终端中运行以下命令:</p><pre class="lg lh li lj gt nk nl nm nn aw no bi"><span id="d9dc" class="lx ly it nl b gy np nq l nr ns"># Add all the files we just copied over to be committed<br/>git add .</span><span id="92e5" class="lx ly it nl b gy nw nq l nr ns"># Commit the files, along with a commit message<br/>git commit -m "deploy app"</span><span id="9b1c" class="lx ly it nl b gy nw nq l nr ns"># Push to master branch on our github repo<br/>git push origin master</span></pre><p id="4ec5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们快到了！这是最后的步骤。</p><p id="d110" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">(1)创建一个<em class="lr"> Heroku </em>账户并验证</p><p id="640a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">(2)在这里安装<em class="lr"> Heroku </em> CLI <a class="ae le" href="https://devcenter.heroku.com/articles/heroku-cli" rel="noopener ugc nofollow" target="_blank"/></p><p id="186e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">(3)通过终端登录您的<em class="lr"> Heroku </em>账户。将会打开一个浏览器窗口进行身份验证。</p><pre class="lg lh li lj gt nk nl nm nn aw no bi"><span id="4705" class="lx ly it nl b gy np nq l nr ns">heroku login</span></pre><p id="eb3c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">(4)创建一个<em class="lr"> Heroku </em> app</p><pre class="lg lh li lj gt nk nl nm nn aw no bi"><span id="8ccc" class="lx ly it nl b gy np nq l nr ns">heroku create &lt;project-name&gt;</span></pre><p id="e4a5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">完成此步骤后，您将能够在终端中看到指向您的项目的链接。</p><p id="c695" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">(5)将我们的 git 回购推送到 Heroku remote。从 github repo 的同一个目录中，运行以下命令:</p><pre class="lg lh li lj gt nk nl nm nn aw no bi"><span id="8cb6" class="lx ly it nl b gy np nq l nr ns">git push heroku master</span></pre><p id="1961" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们完了！构建完成后，您应该能够在上面的链接中看到您的应用程序已部署！</p></div><div class="ab cl og oh hx oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="im in io ip iq"><h1 id="3043" class="on ly it bd lz oo op oq mc or os ot mf jz ou ka mi kc ov kd ml kf ow kg mo ox bi translated">结束语</h1><p id="2d89" class="pw-post-body-paragraph ki kj it kk b kl mq ju kn ko mr jx kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">希望这对每个试图从头到尾创建自己的迷你 ML 项目的人有用！请随时留下任何意见:)</p><p id="42c4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="lr">支持我！</em> </strong> —如果你喜欢我的内容并且<em class="lr">没有</em>订阅 Medium，请考虑支持我并通过我在这里的推荐链接<a class="ae le" href="https://davidcjw.medium.com/membership" rel="noopener">订阅</a> ( <em class="lr">注意:你的一部分会员费将作为推荐费</em>分摊给我)。</p></div></div>    
</body>
</html>