<html>
<head>
<title>End-to-end Machine Learning with TFX on TensorFlow 2.x</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TFX在TensorFlow 2.x上的端到端机器学习</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/end-to-end-machine-learning-with-tfx-on-tensorflow-2-x-6eda2fb5fe37?source=collection_archive---------20-----------------------#2020-02-01">https://towardsdatascience.com/end-to-end-machine-learning-with-tfx-on-tensorflow-2-x-6eda2fb5fe37?source=collection_archive---------20-----------------------#2020-02-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="220f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">去年年底Tensorflow 2.0发布时，我非常兴奋。毕竟，它承诺了比1.x版本更令人愉快的开发人员体验(或者被称为来自地狱的Java的深度学习等价物)。对部署模型有强大支持的Keras层？算我一个！</p><p id="501f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，当我意识到对将TF 2.0模型投入生产的支持并不是我想象的那样时，我的兴奋是短暂的。当然，<a class="ae kl" href="https://github.com/tensorflow/tfx" rel="noopener ugc nofollow" target="_blank"> TensorFlow Extended </a>是一个选项，但考虑到文档尚未跟上，这不是一个特别令人愉快的选项。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/7b37eef6fd3f0c2f29b425bdcd692861.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yWfQ4r1s1d5EPBRrhICEYg.png"/></div></div></figure><p id="89e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尽管如此，我还是不耐烦了；还有，<a class="ae kl" href="https://www.tensorflow.org/guide/eager" rel="noopener ugc nofollow" target="_blank">急于执行</a>。接下来是一段充满泪水和欢呼的艰苦旅程，所有人都在寻找一个真正的奖励，那就是一个工作的机器学习管道。我向你们展示我在r̶a̶n̶t̶s̶的发现，希望你们不必重蹈我的覆辙。不管怎样，直到下一个版本。</p><h2 id="0a3f" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">这是(不是)什么</h2><p id="cffe" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">这篇文章绝不是关于构建生产就绪的TF 2.0管道的<em class="lw"/>方法的权威文章。它展示了部署ML模型的一个可能的工作流，该工作流考虑了内存约束和训练服务偏差(以及其他因素)。如果这些概念听起来很陌生，我推荐阅读谷歌的<a class="ae kl" href="https://developers.google.com/machine-learning/guides/rules-of-ml/" rel="noopener ugc nofollow" target="_blank">机器学习规则</a>。有神经网络和机器学习生命周期的经验肯定会有帮助。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/c2010344346e613b64cb531b378c96ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/0*MIuuJGz1DyeOEi3X.png"/></div><p class="ly lz gj gh gi ma mb bd b be z dk translated">Gojek 采用的机器学习生命周期<a class="ae kl" href="https://blog.gojekengineering.com/an-introduction-to-gojeks-machine-learning-platform-108968c85e64" rel="noopener ugc nofollow" target="_blank">示例</a></p></figure><p id="d409" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您将学习如何:</p><ul class=""><li id="390c" class="mc md iq jp b jq jr ju jv jy me kc mf kg mg kk mh mi mj mk bi translated">使用<a class="ae kl" href="https://www.tensorflow.org/tfx/transform/get_started" rel="noopener ugc nofollow" target="_blank"> TF变换</a>执行特征插补和缩放</li><li id="01ae" class="mc md iq jp b jq ml ju mm jy mn kc mo kg mp kk mh mi mj mk bi translated">使用<a class="ae kl" href="https://www.tensorflow.org/guide/keras/functional" rel="noopener ugc nofollow" target="_blank"> Keras functional API </a>和<a class="ae kl" href="https://www.tensorflow.org/tutorials/structured_data/feature_columns" rel="noopener ugc nofollow" target="_blank">特性列</a>构建模型</li><li id="abd5" class="mc md iq jp b jq ml ju mm jy mn kc mo kg mp kk mh mi mj mk bi translated">为服务于的<a class="ae kl" href="https://www.tensorflow.org/tfx/serving/serving_basic" rel="noopener ugc nofollow" target="_blank"> TF导出一个重用转换图的模型</a></li></ul><p id="aa0a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了简短起见，我将只展示代码片段。</p><h2 id="bd14" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">1.安装依赖项</h2><p id="81a2" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">您将需要以下Python包。因为我们将使用Apache Beam来运行我们的TF转换管道，所以让我们也安装它。</p><pre class="kn ko kp kq gt mq mr ms mt aw mu bi"><span id="b03d" class="ky kz iq mr b gy mv mw l mx my">pip install apache-beam==2.16.0 tensorflow==2.0.0 tensorflow-transform==0.15.0</span></pre><h2 id="636d" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">2.使用TF变换预处理数据</h2><p id="52ef" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">本指南假设读者熟悉TF转换，这涉及到在一个<code class="fe mz na nb mr b">preprocessing_fn</code>中编写由射束管道执行的转换。关于如何开始的更多信息可以在<a class="ae kl" href="https://www.tensorflow.org/tfx/transform/get_started" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="366e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们为一个数值变量<code class="fe mz na nb mr b">age</code>编写一个简单的转换，用平均值估算缺失值并应用特征缩放。</p><pre class="kn ko kp kq gt mq mr ms mt aw mu bi"><span id="8dbf" class="ky kz iq mr b gy mv mw l mx my">import tensorflow as tf<br/>import tensorflow_transform as tft</span><span id="c327" class="ky kz iq mr b gy nc mw l mx my">def preprocessing_fn(inputs):<br/>    outputs = inputs.copy()<br/>    <br/>    age = outputs["age"]<br/>    mean_age = tft_mean(age)<br/>    age = impute(age, -1, mean_age)<br/>    outputs["age"] = tft.scale_to_z_score(age)<br/>    <br/>    return outputs</span></pre><p id="2011" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">停下来。TF变换不支持使用<code class="fe mz na nb mr b">tft.mean()</code>分析器计算平均值吗？为什么我们需要自己编写<code class="fe mz na nb mr b">tft_mean</code>的实现？这是因为TF变换有一个<a class="ae kl" href="https://github.com/tensorflow/transform/issues/152#issuecomment-568000987" rel="noopener ugc nofollow" target="_blank">已知问题</a>，其中nan可能会为某些分析器产生意外结果。为了解决这个问题，我们只使用非空值来计算平均值。</p><pre class="kn ko kp kq gt mq mr ms mt aw mu bi"><span id="3749" class="ky kz iq mr b gy mv mw l mx my">def tft_mean(tensor):<br/>    finite_indices = tf.math.is_finite(tensor.values)<br/>    finite_values = tf.boolean_mask(tensor.values, finite_indices)<br/>    return tft.mean(finite_values)</span></pre><p id="0457" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们使用平均年龄来估算缺失值。有两种方法表示缺失值:第一，通过使用<a class="ae kl" href="https://www.tensorflow.org/api_docs/python/tf/sparse/SparseTensor" rel="noopener ugc nofollow" target="_blank">稀疏处理器</a>进行排除；第二，通过使用一些任意值(例如，<code class="fe mz na nb mr b">-1</code>代表数字变量，或者<code class="fe mz na nb mr b">NULL</code>代表分类变量)。让我们考虑这两种情况。</p><pre class="kn ko kp kq gt mq mr ms mt aw mu bi"><span id="3e41" class="ky kz iq mr b gy mv mw l mx my">def impute(tensor, missing, replacement):<br/>    sparse = tf.sparse.SparseTensor(<br/>        tensor.indices, tensor.values, [tf.shape(tensor)[0], 1]<br/>    )<br/>    dense = tf.sparse.to_dense(sp_input=sparse, default_value=replacement)<br/>    return tf.where(tf.equal(tensor, missing), replacement, dense)</span></pre><p id="9267" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，您可以运行您的TF转换管道，不要忘记导出转换图，以便我们可以在以后重用它！</p><pre class="kn ko kp kq gt mq mr ms mt aw mu bi"><span id="b153" class="ky kz iq mr b gy mv mw l mx my">import apache_beam as beam <br/>import tensorflow_transform.beam as tft_beam<br/>import tempfile</span><span id="c880" class="ky kz iq mr b gy nc mw l mx my">with beam.Pipeline() as pipeline:<br/>    with tft_beam.Context(temp_dir=tempfile.mkdtemp()):<br/>        # read raw data<br/>        raw_data = pipeline &gt;&gt; beam.io.ReadFromTFRecord(...)<br/>        <br/>        # apply transformation<br/>        transformed_data, transform_fn = (<br/>            (raw_data, raw_metadata) &gt;&gt; tft_beam.AnalyzeAndTransformDataset(preprocessing_fn)<br/>        )<br/>        <br/>        # export transform graph<br/>        _ = (<br/>            transform_fn &gt;&gt; tft_beam.WriteTransformFn("data/tft/")<br/>        )</span></pre><h2 id="cf03" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">3.使用Keras图层和要素列构建模型</h2><p id="719a" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">是时候进行一些功能工程了。TensorFlow特性列为常见操作(如一键编码)提供了一个简洁的API。让我们为一个数字变量<code class="fe mz na nb mr b">age</code>和一个分类变量<code class="fe mz na nb mr b">country</code>定义特性列。</p><pre class="kn ko kp kq gt mq mr ms mt aw mu bi"><span id="93b6" class="ky kz iq mr b gy mv mw l mx my">features = [<br/>    tf.feature_column.numeric_column("age"),<br/>    tf.feature_column.indicator_column(<br/>        tf.feature_column.categorical_column_with_vocabulary_list(<br/>            "country", ["America", "Japan", "China"],<br/>        )<br/>    ),<br/>]</span></pre><p id="8bd3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Keras functional API中使用特性列可能有点棘手。你需要使用一个<a class="ae kl" href="https://www.tensorflow.org/api_docs/python/tf/keras/Input" rel="noopener ugc nofollow" target="_blank">输入</a>层来实例化一个Keras张量。</p><pre class="kn ko kp kq gt mq mr ms mt aw mu bi"><span id="e56b" class="ky kz iq mr b gy mv mw l mx my">from tensorflow.keras.layers import Input</span><span id="0048" class="ky kz iq mr b gy nc mw l mx my">feature_inputs = {<br/>    "age": Input(name="age", shape=(), dtype=tf.float32),<br/>    "country": Input(name="country", shape=(), dtype=tf.string),<br/>}</span></pre><p id="7228" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在可以将它输入到Keras <a class="ae kl" href="https://www.tensorflow.org/api_docs/python/tf/keras/layers/DenseFeatures" rel="noopener ugc nofollow" target="_blank"> DenseFeatures </a>层，并继续定义我们的神经网络架构。</p><pre class="kn ko kp kq gt mq mr ms mt aw mu bi"><span id="808e" class="ky kz iq mr b gy mv mw l mx my">from tensorflow.keras.layers import Dense, DenseFeatures<br/>from tensorflow.keras import Model</span><span id="b0e1" class="ky kz iq mr b gy nc mw l mx my">output_1 = DenseFeatures(features)(feature_inputs)<br/>output_2 = Dense(16, activation="relu")(output_1)<br/>preds = Dense(10, activation="softmax")(output_2)<br/>model = Model(inputs=feature_inputs, outputs=preds)</span><span id="56b4" class="ky kz iq mr b gy nc mw l mx my">model = model.compile(...)<br/>model.fit(...)</span></pre><h2 id="b1c4" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">4.导出模型和调用转换图</h2><p id="3504" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">恭喜你走到这一步！在训练我们的模型之后，我们将把我们的模型导出为一个<a class="ae kl" href="https://www.tensorflow.org/guide/saved_model" rel="noopener ugc nofollow" target="_blank">保存的模型</a>来部署它。为了防止训练和服务之间的偏差，我们需要加载导出的转换图，以便对服务输入运行相同的转换。</p><pre class="kn ko kp kq gt mq mr ms mt aw mu bi"><span id="8c42" class="ky kz iq mr b gy mv mw l mx my">tft_dir = "data/tft/"  # location of exported transform_fn</span><span id="baef" class="ky kz iq mr b gy nc mw l mx my">tft_output = tft.TFTransformOutput(tft_dir)<br/>tft_output.transform_raw_features(raw_serving_inputs)</span></pre><p id="879e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Tensorflow 1.x中，当导出您的模型时，您将在<code class="fe mz na nb mr b">serving_input_receiver_fn</code> <a class="ae kl" href="https://www.tensorflow.org/api_docs/python/tf/estimator/Estimator#export_saved_model" rel="noopener ugc nofollow" target="_blank">中包含上述逻辑。然而，随着我们远离TF 2.x中的估计器API，这个功能已经被弃用了。相反，我们需要通过覆盖<code class="fe mz na nb mr b">save()</code>方法来修改Keras模型的服务签名。</a></p><pre class="kn ko kp kq gt mq mr ms mt aw mu bi"><span id="e3c1" class="ky kz iq mr b gy mv mw l mx my">class ExportModel(tf.keras.Model):<br/>    def __init__(self, model, tft_dir):<br/>        super().__init__(self)<br/>        self.model = model<br/>        self.tft_output = tft.TFTransformOutput(tft_dir)<br/>        <br/>    @tf.function(input_signature=[SERVING_FEATURE_SPEC])<br/>    def serving_fn(self, inputs):<br/>        transformed = self.tft_output.transform_raw_features(inputs)<br/>        return {"preds": self.model(transformed)}</span><span id="c5d7" class="ky kz iq mr b gy nc mw l mx my">    def save(self, output_dir):<br/>        signatures = {"serving_default": self.serving_fn} <br/>        tf.saved_model.save(self, output_dir, signatures)</span><span id="25f4" class="ky kz iq mr b gy nc mw l mx my">ExportModel(model, "data/tft/").save("data/model/1/")</span></pre><p id="fa26" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们可以使用TF服务来服务我们的模型。</p><p id="12c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">希望这有所帮助。再见。</p></div></div>    
</body>
</html>