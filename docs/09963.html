<html>
<head>
<title>What’s new in Matplotlib 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Matplotlib 3 的新特性</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/whats-new-in-matplotlib-3-1b3b03f18ddc?source=collection_archive---------15-----------------------#2020-07-14">https://towardsdatascience.com/whats-new-in-matplotlib-3-1b3b03f18ddc?source=collection_archive---------15-----------------------#2020-07-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/4af812de768fa6856644257278c0d8f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*x8sDUu4gqxk2kez4"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://unsplash.com/@karaeads?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">卡拉·伊德斯</a>在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><div class=""/><div class=""><h2 id="0abb" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">第 3 代中最重要的更新概述</h2></div><blockquote class="ky kz la"><p id="033e" class="lb lc ld le b lf lg kk lh li lj kn lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">如果说可视化在数据中无处不在，无论大小，那么 Matplotlib 在 python 中同样无处不在。</p></blockquote><p id="a2db" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated"><a class="ae jg" href="https://matplotlib.org/" rel="noopener ugc nofollow" target="_blank"> Matplotlib </a>是 python 中使用最广泛的绘图库。<strong class="le jk">句号。</strong>自 2003 年首次发布以来，它已经经历了四代开发，最新版本是最近发布的 3 . 2 . 2(2020 年 6 月 17 日)。最新一代的 Matplotlib 3 只与 Python 3 兼容，是近两年前推出的。</p><figure class="mc md me mf gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mb"><img src="../Images/45ab7a3a0e6422335efd4b7d869121f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tjX9ZxKtImDcX-kyeA5c_g.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">Matplotlib 开发的历史时间表(未按比例绘制)</p></figure><p id="a838" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">为了保持这篇文章的简短，我将关注从 Matplotlib 3.0 开始的<strong class="le jk">最有趣的特性</strong>(在我看来)<strong class="le jk">，然后转移到 3.1 和 3.2 版本</strong>。如果你对学习 python 绘图的基础感兴趣，请阅读我最近在《走向数据科学》中的文章<a class="ae jg" rel="noopener" target="_blank" href="/a-laymans-guide-to-plot-with-python-and-matplotlib-8462054f2059">，如果你想了解最新的 Matplotlib 3.3 中的特性，请阅读我的第二篇文章</a><a class="ae jg" href="https://medium.com/@ankitgupta.tech/latest-cool-features-of-matplotlib-c7a1e2c060c1" rel="noopener">这里</a>。</p><blockquote class="ky kz la"><p id="0269" class="lb lc ld le b lf lg kk lh li lj kn lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">生存下来的不是最强壮的物种，也不是最聪明的物种，而是对变化最敏感的物种——查尔斯·达尔文</p></blockquote><h2 id="b8d0" class="mg mh jj bd mi mj mk dn ml mm mn dp mo ly mp mq mr lz ms mt mu ma mv mw mx my bi translated">所以准备好在 Matplotlib 3 上更新自己吧</h2><h1 id="e496" class="mz mh jj bd mi na nb nc ml nd ne nf mo kp ng kq mr ks nh kt mu kv ni kw mx nj bi translated">Matplotlib 3.0 中的新功能</h1><ol class=""><li id="2123" class="nk nl jj le b lf nm li nn ly no lz np ma nq lx nr ns nt nu bi translated"><strong class="le jk">轴的可缩放性<br/> </strong>如果您想按给定的数量级缩放轴的值，您可以指定<strong class="le jk">相同的值</strong>作为上限和下限。例如，下面的代码片段将 y 轴缩放 1000 倍。</li></ol><pre class="mc md me mf gt nv nw nx ny aw nz bi"><span id="7605" class="mg mh jj nw b gy oa ob l oc od">import numpy as np<br/>import matplotlib.pyplot as plt</span><span id="1d75" class="mg mh jj nw b gy oe ob l oc od">fig, ax = plt.subplots()</span><span id="e8a9" class="mg mh jj nw b gy oe ob l oc od">x = np.linspace(0, 2*np.pi, 1000)</span><span id="f18a" class="mg mh jj nw b gy oe ob l oc od">ax.plot(x, np.sin(x**2), 'orange', label=r'sin($x^2$)')<br/>ax.legend(title='Legend Title', fontsize=14, title_fontsize=18)</span><span id="745b" class="mg mh jj nw b gy oe ob l oc od">ax.ticklabel_format(style='sci', scilimits=(3, 3), axis='y')</span></pre><figure class="mc md me mf gt iv gh gi paragraph-image"><div class="gh gi of"><img src="../Images/6fa732d8d2c0048bf3c55fd7f8e9c5c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*3rvuqL_iUxTIip9bghKv4g.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">sin(x)函数的重新缩放 y 轴。注意左上角的乘法因子 1e3。</p></figure><p id="a264" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">2.<strong class="le jk">自由选择图例标题的字体大小</strong></p><p id="9551" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">您现在可以分别设置<strong class="le jk">图例标题</strong>和<strong class="le jk">图例标签</strong>的字体大小。这已经在代码片段和上图中显示出来了。如果你正在使用<code class="fe og oh oi nw b">rcParams</code>，你也可以使用<code class="fe og oh oi nw b">rcParams["legend.title_fontsize"]</code>和<code class="fe og oh oi nw b">rcParams["legend.fontsize"]</code>分别指定两者</p><pre class="mc md me mf gt nv nw nx ny aw nz bi"><span id="7e6e" class="mg mh jj nw b gy oa ob l oc od">plt.rcParams["legend.title_fontsize"]  = 18<br/>plt.rcParams["legend.fontsize"] = 14</span></pre><p id="230e" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">3.<strong class="le jk">饼图现在默认为圆形<em class="ld"/></strong></p><p id="7a34" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">与 Matplotlib 2 不同，饼状图现在默认总是圆形的<em class="ld"/>，你不需要手动设置纵横比<code class="fe og oh oi nw b">"equal"</code>。在早期版本中，您需要指定<code class="fe og oh oi nw b">ax.set_aspect("equal")</code>或<code class="fe og oh oi nw b">plt.axis("equal")</code>来制作圆形饼图。如果您不喜欢这个默认行为，您可以使用<code class="fe og oh oi nw b">ax.set_aspect("auto")</code>或<code class="fe og oh oi nw b">plt.axis("auto").</code>来覆盖它</p><p id="d7a5" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">4.<strong class="le jk">轴标题和<em class="ld">x</em>-轴</strong>之间不再重叠</p><p id="52ae" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">如果图的顶部有<em class="ld">x</em>-轴(或双<em class="ld">y</em>-轴)，图标题<strong class="le jk"> <em class="ld">将不再与顶部<em class="ld"> x </em>轴标签和刻度标签</em> </strong>重叠。以前，您必须手动重新定位图形标题。</p><p id="9862" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated"><strong class="le jk">捕捉<em class="ld"> : </em> </strong>默认<em class="ld">y</em>-标题值为 1.0。即使您手动指定默认位置为<code class="fe og oh oi nw b">ax.title.set_position(0.5, 1.0)</code>、<em class="ld">，这是多余的，因为它已经默认了</em>，底层算法仍然会重新定位标题并防止重叠。如果你不想重新定位，并且你是一个混乱和喜欢重叠的人，你可以使用一个不等于 1 的值<em class="ld"> y </em>来防止它，例如<code class="fe og oh oi nw b">ax.title.set_position(0.5, 1.005)</code></p><p id="c4eb" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">5.<strong class="le jk"> GridSpec 现在更方便了</strong></p><p id="52e7" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">以前，要添加子情节网格，您必须使用需要导入<code class="fe og oh oi nw b">gridspec</code>的<code class="fe og oh oi nw b">gridspec.GridSpec()</code>和<code class="fe og oh oi nw b">gridspec.GridSpecFromSubplotSpec()</code>方法。现在这两个都换成了<code class="fe og oh oi nw b">add_gridpec()</code>和<code class="fe og oh oi nw b">SubplotSpec.subgridspec()</code>。这移除了<em class="ld">显式需要</em>来导入<code class="fe og oh oi nw b">gridspec</code>，如下面的<a class="ae jg" href="https://matplotlib.org/3.0.0/users/whats_new.html#new-convenience-methods-for-gridspec" rel="noopener ugc nofollow" target="_blank">官方</a>示例所示</p><pre class="mc md me mf gt nv nw nx ny aw nz bi"><span id="ea99" class="mg mh jj nw b gy oa ob l oc od">fig = plt.figure()<br/>gs = fig.add_gridspec(3, 1)</span><span id="e007" class="mg mh jj nw b gy oe ob l oc od">ax1 = fig.add_subplot(gs[0])<br/>ax2 = fig.add_subplot(gs[1])<br/>sub_gs = gs[2].subgridspec(1, 4)</span><span id="3c70" class="mg mh jj nw b gy oe ob l oc od">for i in range(4):<br/>    fig.add_subplot(sub_gs[0, i])</span></pre><figure class="mc md me mf gt iv gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/e82fa0b3465895ab62312a7cd667fc7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*7Nrd6-uaHBLB8ZiRaGfuCw.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">Matplotlib 3 中“add_gridspec”和“subgridspec”的演示</p></figure></div><div class="ab cl ok ol hx om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="im in io ip iq"><h1 id="a116" class="mz mh jj bd mi na or nc ml nd os nf mo kp ot kq mr ks ou kt mu kv ov kw mx nj bi translated">Matplotlib 3.1 中的新功能</h1><ol class=""><li id="e6d6" class="nk nl jj le b lf nm li nn ly no lz np ma nq lx nr ns nt nu bi translated"><strong class="le jk">创建辅助<em class="ld"> x-y </em>轴</strong>的新方法</li></ol><p id="bdc5" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">假设您正在用欧元计算股票价格，但是您的老板要求您也在同一数字中显示相应的美元价格，那么<strong class="le jk"> <em class="ld">副轴</em> </strong>就是您所需要的。你现在可以简单地使用<code class="fe og oh oi nw b">ax.secondary_xaxis()</code>和<code class="fe og oh oi nw b">ax.secondary_yaxis()</code>。您必须定义两个转换函数，例如下面的<code class="fe og oh oi nw b">eur2dol()</code>和<code class="fe og oh oi nw b">dol2eur()</code>，它们将定义主轴和副轴之间的关系，如<a class="ae jg" href="https://matplotlib.org/3.1.0/gallery/subplots_axes_and_figures/secondary_axis.html" rel="noopener ugc nofollow" target="_blank">这个</a>官方示例所示。</p><pre class="mc md me mf gt nv nw nx ny aw nz bi"><span id="59f1" class="mg mh jj nw b gy oa ob l oc od"><strong class="nw jk">def </strong>eur2dol(x):<br/>    <strong class="nw jk">return</strong> x * 1.14  # Taking 1 Eur = 1.14 US Dollar as Rate<br/><br/><strong class="nw jk">def</strong> dol2eur(x):<br/>    <strong class="nw jk">return</strong> x / 1.14<br/><br/>secax = ax.secondary_xaxis('top', functions=(eur2dol, dol2eur))</span></pre><p id="8758" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">2.<strong class="le jk">整洁简洁的日期格式器</strong></p><p id="ac56" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">如果你正在处理日期，你会喜欢这个功能的！新的日期格式器，被称为<code class="fe og oh oi nw b">ConciseDateFormatter()</code>，属于<code class="fe og oh oi nw b">matplotlib.dates</code>，与默认的格式器相比，它可以简洁明了地显示刻度标签。</p><p id="fcfd" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">3.<strong class="le jk">轻松创建散点图的图例</strong></p><p id="9762" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">以前，在为标记绘制不同颜色和大小的散点图时，需要一种变通方法，要么用单个标签条目绘制多个散点图，要么使用代理美工手动添加它们。Matplotlib 3.1 通过引入返回唯一句柄和标签的<code class="fe og oh oi nw b">legend_elements()</code>简化了这一过程，这些句柄和标签可用于生成图例。此处提供了一个官方示例<a class="ae jg" href="https://matplotlib.org/3.1.0/gallery/lines_bars_and_markers/scatter_with_legend.html#automated-legend-creation" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="91b0" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">4.<strong class="le jk">反转轴的新方法</strong></p><p id="9a72" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">现在，您可以使用<code class="fe og oh oi nw b">set_inverted()</code>反转轴，使用<code class="fe og oh oi nw b">get_inverted()</code>检查轴之前是否被反转过。后者将返回 Matplotlib 2 中的<code class="fe og oh oi nw b">True</code>或<code class="fe og oh oi nw b">False.</code>，等效方法为<code class="fe og oh oi nw b">invert_xaxis()</code>和<code class="fe og oh oi nw b">invert_yaxis()</code>用于反转，<code class="fe og oh oi nw b">xaxis_inverted()</code>和<code class="fe og oh oi nw b">yaxis_inverted()</code>用于检查轴是否已反转。</p><pre class="mc md me mf gt nv nw nx ny aw nz bi"><span id="8775" class="mg mh jj nw b gy oa ob l oc od">fig, ax = plt.subplots()</span><span id="9df8" class="mg mh jj nw b gy oe ob l oc od">x = np.linspace(0, 0.5, 100)</span><span id="f2fd" class="mg mh jj nw b gy oe ob l oc od">ax.plot(x, np.sin(x**2), 'orange')<br/>ax.xaxis.set_inverted(True) # &lt;-- Takes Boolean as argument</span><span id="2464" class="mg mh jj nw b gy oe ob l oc od">ax.xaxis.get_inverted()<br/>&gt;&gt;&gt; True</span></pre><figure class="mc md me mf gt iv gh gi paragraph-image"><div class="gh gi of"><img src="../Images/94d23a9d583b0c1363ce70588af75eef.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*EBWvoz8lrsNW1I-qfjZYiw.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">x 轴倒置的图形</p></figure><p id="ffd6" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">5.<strong class="le jk">滑块控件终于俯身直起</strong></p><p id="ec4c" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">现在可以有一个垂直的小部件滑块。您需要传递一个可选参数<code class="fe og oh oi nw b">orientation</code>，它可以是<code class="fe og oh oi nw b">'horizontal'</code>或<code class="fe og oh oi nw b">'vertical'</code>。</p></div><div class="ab cl ok ol hx om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="im in io ip iq"><h1 id="a8f0" class="mz mh jj bd mi na or nc ml nd os nf mo kp ot kq mr ks ou kt mu kv ov kw mx nj bi translated">Matplotlib 3.2 中的新功能(最新版本是 3.2.2)</h1><ol class=""><li id="4f49" class="nk nl jj le b lf nm li nn ly no lz np ma nq lx nr ns nt nu bi translated"><strong class="le jk">控制轴的标题位置和颜色</strong></li></ol><p id="5fe2" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">在定制您的<code class="fe og oh oi nw b">rcParams</code>文件/设置时，您现在还可以传递图形标题的位置及其颜色。标题的位置可以是以下任意一个:<code class="fe og oh oi nw b">"left", "center", "right"</code>。标题的颜色可以是<code class="fe og oh oi nw b">"auto"</code>或任何指定的颜色，如<code class="fe og oh oi nw b">"red"</code>、<code class="fe og oh oi nw b">"mediumseagreen",</code>等。这里列出了<a class="ae jg" href="https://matplotlib.org/3.1.0/gallery/color/named_colors.html" rel="noopener ugc nofollow" target="_blank">和</a>。</p><pre class="mc md me mf gt nv nw nx ny aw nz bi"><span id="801a" class="mg mh jj nw b gy oa ob l oc od">plt.rcParams["axes.titlelocation"] = "left"<br/>plt.rcParams["axes.titlecolor"] = "red"</span></pre><p id="6aad" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">2.<strong class="le jk">3d 条的阴影</strong></p><p id="56a3" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">你现在可以用<code class="fe og oh oi nw b">bar3d().</code>从不同的角度投射光线来制作漂亮的 3d 条，这可以用<code class="fe og oh oi nw b"><a class="ae jg" href="https://matplotlib.org/3.2.0/api/_as_gen/matplotlib.colors.LightSource.html#matplotlib.colors.LightSource" rel="noopener ugc nofollow" target="_blank">lightsource</a></code>参数来配置，它有两个角度:方位角和高度。阴影参数需要是<code class="fe og oh oi nw b">True</code>来调用这个效果。</p><p id="c45c" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">3.<strong class="le jk">选择显示哪些误差线</strong></p><p id="8a2e" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">有时您可能希望在数据点上显示误差线。然而，如果您有大量的数据点，您不希望在每个点上添加误差线。到目前为止，您只能选择在每个<em class="ld"> n </em>数据点后放置误差线。现在，您还可以指定误差线的起点。下面的第一个代码将在<code class="fe og oh oi nw b">x[::5], y[::5]</code>点放置误差线，而第二个代码将在<code class="fe og oh oi nw b">x[2::5], y[2::5]</code>放置误差线，即从第二个点开始每隔第五个点放置误差线。<code class="fe og oh oi nw b">[::5]</code>是 NumPy 的切片符号，它返回每第 5 个元素。</p><pre class="mc md me mf gt nv nw nx ny aw nz bi"><span id="c6b3" class="mg mh jj nw b gy oa ob l oc od"># Before matplotlib 3.2 <br/>plt.errorbar(x, y, yerr, errorevery=5)</span><span id="0b5a" class="mg mh jj nw b gy oe ob l oc od"># matplotlib 3.2 onwards<br/>plt.errorbar(x, y, yerr, errorevery=(2, 5))</span></pre></div><div class="ab cl ok ol hx om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="im in io ip iq"><p id="1763" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">这就是我的帖子的结尾。恭喜你！现在，您已经更新了 Matplotlib 3 的一些最新特性。下一个候选版本是<a class="ae jg" href="https://matplotlib.org/3.3.0/index.html" rel="noopener ugc nofollow" target="_blank"> 3.3.0 </a>。当这种情况发生时，我会更新这个帖子。</p><p id="8051" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">您可以在以下超链接中找到 Matplotlib 3 中<strong class="le jk">新增功能的完整列表:<a class="ae jg" href="https://matplotlib.org/3.0.0/users/whats_new.html#shifting-errorbars" rel="noopener ugc nofollow" target="_blank"> 3.0 </a>、<a class="ae jg" href="https://matplotlib.org/3.1.0/users/whats_new.html#shifting-errorbars" rel="noopener ugc nofollow" target="_blank"> 3.1 </a>和<a class="ae jg" href="https://matplotlib.org/3.2.0/users/whats_new.html#shifting-errorbars" rel="noopener ugc nofollow" target="_blank"> 3.2 </a>。如果你对学习 python 绘图的基础感兴趣，请阅读我在《走向数据科学》中的文章。</strong></p><p id="c29c" class="pw-post-body-paragraph lb lc jj le b lf lg kk lh li lj kn lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated"><strong class="le jk"><em class="ld">Matplotlib-ing 快乐！</em>T13】</strong></p></div></div>    
</body>
</html>