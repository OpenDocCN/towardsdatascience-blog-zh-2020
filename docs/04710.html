<html>
<head>
<title>Intro to Dynamic Visualization with Python — Animations and Interactive Plots</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python动态可视化简介-动画和交互式绘图</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/intro-to-dynamic-visualization-with-python-animations-and-interactive-plots-f72a7fb69245?source=collection_archive---------3-----------------------#2020-04-26">https://towardsdatascience.com/intro-to-dynamic-visualization-with-python-animations-and-interactive-plots-f72a7fb69245?source=collection_archive---------3-----------------------#2020-04-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="62c4" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">Python科学绘图</h2><div class=""/><div class=""><h2 id="a9dd" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">用Python制作基本动画和交互式绘图</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/c5ef59e72a4559f1acbb87923aed206b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9EHJpc3KDVS5XNoiFUXMmQ.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@katya?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">卡蒂亚·奥斯丁</a>在<a class="ae lh" href="https://unsplash.com/s/photos/interactive?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="8509" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">有时，您可能希望创建一个像视频一样随时间变化的动态图形，或者根据交互式用户输入进行调整。这些可视化做了大量的工作，真实地展示了输出如何随着输入而变化。在本文中，我将把相同的数据呈现为静态图、动画和交互式图。为了与我以前文章的物理科学主题保持一致，我绘制的数据将来自固态物理学中最广泛使用的方程之一:费米-狄拉克分布，它描述了电子在固体中的占有率。等式如下所示，它将占据能量<em class="me"> E </em>的态的分数作为费米能量和温度的函数。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi mf"><img src="../Images/18d665fd46f5abd992856926cae4e4ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TVsZ_HP-Rs9NlL6c8OtwSA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">费米-狄拉克分布</p></figure><h1 id="95c2" class="mg mh it bd mi mj mk ml mm mn mo mp mq ki mr kj ms kl mt km mu ko mv kp mw mx bi translated"><strong class="ak">静态图</strong></h1><p id="c86e" class="pw-post-body-paragraph li lj it lk b ll my kd ln lo mz kg lq lr na lt lu lv nb lx ly lz nc mb mc md im bi translated">我们的第一个图将是一个静态图，其中将有不同温度下的<em class="me"> f(E) </em>曲线。首先，我们导入所需的包:</p><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="042d" class="ni mh it ne b gy nj nk l nl nm"># Import packages<br/>import matplotlib as mpl<br/>import matplotlib.pyplot as plt<br/>import numpy as np</span></pre><p id="6918" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">由于我们要多次计算费米-狄拉克分布，我们应该写一个函数来为我们做这个计算:</p><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="eae0" class="ni mh it ne b gy nj nk l nl nm"># Fermi-Dirac Distribution<br/>def fermi(E: float, E_f: float, T: float) -&gt; float:<br/>    k_b = 8.617 * (10**-5) # eV/K<br/>    return 1/(np.exp((E - E_f)/(k_b * T)) + 1)</span></pre><p id="83ba" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在我们可以开始绘制数据了！首先，我将编辑一些常规的绘图参数:</p><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="f9f6" class="ni mh it ne b gy nj nk l nl nm"># General plot parameters<br/>mpl.rcParams['font.family'] = 'Avenir'<br/>mpl.rcParams['font.size'] = 18</span><span id="c5e2" class="ni mh it ne b gy nn nk l nl nm">mpl.rcParams['axes.linewidth'] = 2<br/>mpl.rcParams['axes.spines.top'] = False<br/>mpl.rcParams['axes.spines.right'] = False</span><span id="f0b1" class="ni mh it ne b gy nn nk l nl nm">mpl.rcParams['xtick.major.size'] = 10<br/>mpl.rcParams['xtick.major.width'] = 2<br/>mpl.rcParams['ytick.major.size'] = 10<br/>mpl.rcParams['ytick.major.width'] = 2</span></pre><p id="ec03" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们创建我们的图形，并向其添加轴对象:</p><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="5884" class="ni mh it ne b gy nj nk l nl nm"># Create figure and add axes<br/>fig = plt.figure(figsize=(6, 4))<br/>ax = fig.add_subplot(111)</span></pre><p id="4f0c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了向我们的费米-狄拉克函数提供变化的温度数据，我们使用<code class="fe no np nq ne b">numpy.linspace</code>生成100 K到1000 K之间的一组值:</p><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="ff1d" class="ni mh it ne b gy nj nk l nl nm"># Temperature values<br/>T = np.linspace(100, 1000, 10)</span></pre><p id="9a63" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于这些温度值中的每一个，我们需要将不同的颜色映射到其结果曲线上。我们将从<code class="fe no np nq ne b">coolwarm</code>色图中生成颜色，因为我们实际上是在处理不断变化的温度。由于我们已经在上面生成了10个温度值，我们将从<code class="fe no np nq ne b">coolwarm</code>色图中提取10种颜色。</p><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="48c0" class="ni mh it ne b gy nj nk l nl nm"># Get colors from coolwarm colormap<br/>colors = plt.get_cmap('coolwarm', 10)</span></pre><p id="4d81" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">绘制数据的最简单方法是循环遍历所有温度值，并每次绘制相应的曲线。为了生成x轴值，我们再次使用<code class="fe no np nq ne b">numpy.linspace</code>来创建一个由0到1之间的100个等距值组成的数组。此外，我们在所有计算中使用0.5 eV的固定费米能量值。</p><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="cae4" class="ni mh it ne b gy nj nk l nl nm"># Plot F-D data<br/>for i in range(len(T)):<br/>    x = np.linspace(0, 1, 100)<br/>    y = fermi(x, 0.5, T[i])<br/>    ax.plot(x, y, color=colors(i), linewidth=2.5)</span></pre><p id="e609" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们的图需要的最后一个元素是一种区分不同颜色温度曲线的方法。为此，我们将创建一个图例，首先创建一个标签列表，然后将它们传递给<code class="fe no np nq ne b">axes.legend</code>方法。</p><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="2655" class="ni mh it ne b gy nj nk l nl nm"># Add legend</span><span id="2b88" class="ni mh it ne b gy nn nk l nl nm">labels = ['100 K', '200 K', '300 K', '400 K', '500 K', '600 K', <br/>          '700 K', '800 K', '900 K', '1000 K']</span><span id="32b0" class="ni mh it ne b gy nn nk l nl nm">ax.legend(labels, bbox_to_anchor=(1.05, -0.1), loc='lower left', <br/>          frameon=False, labelspacing=0.2)</span></pre><p id="4f67" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe no np nq ne b">labelspacing</code> —图例条目之间的垂直间距(默认为<code class="fe no np nq ne b">0.5</code>)</p><p id="d942" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最后，在添加轴标签后，我们将看到以下图形:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nr"><img src="../Images/2279ed2389a1f0266186e444862b9ac8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JDA2q_4bm-EM-l8ixzfKGQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">费米能级为0.5 eV时费米-狄拉克分布的温度依赖性</p></figure><h1 id="b739" class="mg mh it bd mi mj mk ml mm mn mo mp mq ki mr kj ms kl mt km mu ko mv kp mw mx bi translated"><strong class="ak">动画剧情</strong></h1><p id="9d15" class="pw-post-body-paragraph li lj it lk b ll my kd ln lo mz kg lq lr na lt lu lv nb lx ly lz nc mb mc md im bi translated">现在，假设我们想要呈现与上面相同的数据，但是作为一个视频，我们该怎么做呢？原来我们用<code class="fe no np nq ne b">matplotlib</code>就可以很轻松的做到这一点！我们必须导入以下内容才能使用该功能:</p><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="ecaf" class="ni mh it ne b gy nj nk l nl nm"># Import animation package<br/>from matplotlib.animation import FuncAnimation</span></pre><p id="5422" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果我们使用的是Jupyter笔记本，我们也应该改变<code class="fe no np nq ne b">matplotlib</code>用来渲染其数字的后端，以便允许交互式绘图。</p><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="678b" class="ni mh it ne b gy nj nk l nl nm"># Change matplotlib backend<br/>%matplotlib notebook</span></pre><p id="d280" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于我们的动画，我们需要做以下工作:</p><p id="2015" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">(1)将对绘制曲线的引用存储为变量</p><p id="7a20" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">(2)使用带有该变量的函数调用来不断更新绘图数据</p><p id="462f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们将首先绘制空数组，并将该图存储为一个名为<code class="fe no np nq ne b">f_d</code>的变量。此外，我们将添加一个显示当前绘图温度的文本注释，因此我们也将存储一个对此的变量引用。我们将文本注释的右上角与axes对象的右上角对齐。</p><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="09f3" class="ni mh it ne b gy nj nk l nl nm"># Create variable reference to plot<br/>f_d, = ax.plot([], [], linewidth=2.5)</span><span id="67a6" class="ni mh it ne b gy nn nk l nl nm"># Add text annotation and create variable reference<br/>temp = ax.text(1, 1, '', ha='right', va='top', fontsize=24)</span></pre><p id="304a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在来看看我们动画的核心——动画功能。该函数将接受索引<code class="fe no np nq ne b">i</code>的输入，并在每次调用时更新绘图。它还会用当前温度和(只是为了好玩！)根据<code class="fe no np nq ne b">coolwarm</code>色图中的相同颜色改变绘图和文本的颜色。</p><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="61f7" class="ni mh it ne b gy nj nk l nl nm"># Animation function<br/>def animate(i):<br/>    x = np.linspace(0, 1, 100)<br/>    y = fermi(x, 0.5, T[i])<br/>    f_d.set_data(x, y)<br/>    f_d.set_color(colors(i))<br/>    temp.set_text(str(int(T[i])) + ' K')<br/>    temp.set_color(colors(i))</span></pre><p id="dd18" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe no np nq ne b">set_data(x, y)</code> —为绘图设置新的<code class="fe no np nq ne b">x</code>和<code class="fe no np nq ne b">y</code>数据</p><p id="0139" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，为了让奇迹发生，我们使用下面一行代码:</p><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="25b3" class="ni mh it ne b gy nj nk l nl nm"># Create animation<br/>ani = FuncAnimation(fig=fig, func=animate, frames=range(len(T)), interval=500, repeat=True)</span></pre><p id="2de9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe no np nq ne b">fig</code> —传递给动画功能的图形</p><p id="f1b8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe no np nq ne b">func</code> —剧情的动画功能</p><p id="4e84" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe no np nq ne b">frames</code> —一个数组，从0开始，代表动画的帧。在这种情况下，我们传递一个长度等于我们正在制作动画的温度数的值(这也是传递给<code class="fe no np nq ne b">func</code>的索引<code class="fe no np nq ne b">i</code>)。</p><p id="3a02" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe no np nq ne b">interval</code> —帧之间的延迟，单位为毫秒</p><p id="2261" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe no np nq ne b">repeat</code> —是否在动画结束时重复播放</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/c4b979026fe77ef58646f47794e95c85.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/1*mJMm9bGXpcR4wgDWjwzybg.gif"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">费米能量值为0.5 eV时费米-狄拉克分布的温度依赖性的动画图</p></figure><p id="6db8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在那里！现在，如果您的轴标签或部分绘图被截断，您可以尝试添加以下代码行，以确保所有元素都在图形的视图中。</p><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="eedf" class="ni mh it ne b gy nj nk l nl nm"># Ensure the entire plot is visible<br/>fig.tight_layout()</span></pre><p id="84d0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，为了保存我们的动画，我们使用如下:</p><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="87d7" class="ni mh it ne b gy nj nk l nl nm"># Save and show animation<br/>ani.save('AnimatedPlot.gif', writer='imagemagick', fps=2)</span></pre><p id="ed1d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了生成<code class="fe no np nq ne b">.gif</code>文件，我使用了<a class="ae lh" href="https://imagemagick.org/index.php" rel="noopener ugc nofollow" target="_blank"> ImageMagick </a></p><p id="6f60" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe no np nq ne b">fps</code> —动画的每秒帧数(因为我们只有10帧，所以我使用fps值2来模拟之前500毫秒的间隔延迟)</p><h1 id="0752" class="mg mh it bd mi mj mk ml mm mn mo mp mq ki mr kj ms kl mt km mu ko mv kp mw mx bi translated"><strong class="ak">互动剧情</strong></h1><p id="173e" class="pw-post-body-paragraph li lj it lk b ll my kd ln lo mz kg lq lr na lt lu lv nb lx ly lz nc mb mc md im bi translated">最后，如果我们想让用户摆弄输入参数，观察它们在输出上的变化，我们可以制作一个交互式的图形。我们从导入所需的包开始。</p><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="150e" class="ni mh it ne b gy nj nk l nl nm"># Import slider package<br/>from matplotlib.widgets import Slider</span></pre><p id="49b6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们再次开始创建一个图形和轴对象来保存我们的绘图。然而，这一次，我们调整了绘图的大小，以便为将要添加的滑块腾出空间。</p><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="b232" class="ni mh it ne b gy nj nk l nl nm"># Create main axis<br/>ax = fig.add_subplot(111)<br/>fig.subplots_adjust(bottom=0.2, top=0.75)</span></pre><p id="97ed" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe no np nq ne b">figure.subplots_adjust()</code>接受<code class="fe no np nq ne b">top</code>、<code class="fe no np nq ne b">bottom</code>、<code class="fe no np nq ne b">left</code>和<code class="fe no np nq ne b">right</code>的输入，指示在何处绘制轴边界框的四个角。在这种情况下，我们确保顶部不超过0.75，这样我们就可以将滑块放在图的顶部。</p><p id="9f2c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">滑块开始就像任何其他轴对象。在这里，我们将两者都加在图上(一个用来改变费米能，一个用来改变温度)。此外，由于我们更改了全局绘图设置，删除了右侧和顶部脊线，因此我们将它们添加回滑块。</p><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="5cb4" class="ni mh it ne b gy nj nk l nl nm"># Create axes for sliders<br/>ax_Ef = fig.add_axes([0.3, 0.85, 0.4, 0.05])<br/>ax_Ef.spines['top'].set_visible(True)<br/>ax_Ef.spines['right'].set_visible(True)</span><span id="e05d" class="ni mh it ne b gy nn nk l nl nm">ax_T = fig.add_axes([0.3, 0.92, 0.4, 0.05])<br/>ax_T.spines['top'].set_visible(True)<br/>ax_T.spines['right'].set_visible(True)</span></pre><p id="d80b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，我们必须将这些轴对象转换成滑块:</p><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="b3c3" class="ni mh it ne b gy nj nk l nl nm"># Create sliders</span><span id="2f95" class="ni mh it ne b gy nn nk l nl nm">s_Ef = Slider(ax=ax_Ef, label='Fermi Energy ', valmin=0, valmax=1.0,<br/>              valfmt=' %1.1f eV', facecolor='#cc7000')</span><span id="381a" class="ni mh it ne b gy nn nk l nl nm">s_T = Slider(ax=ax_T, 'Temperature ', valmin=100, valmax=1000, <br/>             valinit=100, valfmt='%i K', facecolor='#cc7000')</span></pre><p id="181c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe no np nq ne b">ax</code> —要转换为滑块的轴对象</p><p id="9c1d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe no np nq ne b">label</code> —位于滑块左侧的滑块标签</p><p id="3515" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe no np nq ne b">valmin</code> —滑块的最小值</p><p id="d8d6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe no np nq ne b">valmax</code> —滑块的最大值</p><p id="d82e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe no np nq ne b">valfmt</code> —显示为滑块值的字符串，位于右侧。<code class="fe no np nq ne b">%1.1f</code>是一个带1个小数点的浮点数，<code class="fe no np nq ne b">%i</code>是一个整数</p><p id="1c0c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe no np nq ne b">facecolor</code> —填充滑块的颜色</p><p id="2d20" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在我们已经创建了滑块，让我们绘制“默认”数据集，它将显示图形首次加载的时间(费米能量为0.5 eV，温度为300 K):</p><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="9c37" class="ni mh it ne b gy nj nk l nl nm"># Plot default data<br/>x = np.linspace(-0, 1, 100)<br/>Ef_0 = 0.5<br/>T_0 = 100<br/>y = fermi(x, Ef_0, T_0)<br/>f_d, = ax.plot(x, y, linewidth=2.5)</span></pre><p id="b4a2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">就像在动画情节中一样，我们现在将定义<code class="fe no np nq ne b">update</code>函数，它将随着滑块的更新而改变数据。此<code class="fe no np nq ne b">update</code>函数获取滑块的当前值，更改绘图中的数据，并重新绘制图形。</p><pre class="ks kt ku kv gt nd ne nf ng aw nh bi"><span id="c8a1" class="ni mh it ne b gy nj nk l nl nm"># Update values<br/>def update(val):<br/>    Ef = s_Ef.val<br/>    T = s_T.val<br/>    f_d.set_data(x, fermi(x, Ef, T))<br/>    fig.canvas.draw_idle()</span><span id="2282" class="ni mh it ne b gy nn nk l nl nm">s_Ef.on_changed(update)<br/>s_T.on_changed(update)</span></pre><p id="0056" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当滑块值改变时，<code class="fe no np nq ne b">Slider.on_changed(func)</code>调用更新<code class="fe no np nq ne b">func</code>。最后，当我们展示我们的阴谋，我们得到这个很酷的互动图！</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/1368df88b911a97f6b86be56f1b2246b.png" data-original-src="https://miro.medium.com/v2/resize:fit:866/1*PxqmKvYvn2AUDxC_GetC9Q.gif"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">费米-狄拉克分布温度依赖性的交互图</p></figure><h1 id="e901" class="mg mh it bd mi mj mk ml mm mn mo mp mq ki mr kj ms kl mt km mu ko mv kp mw mx bi translated"><strong class="ak">结论</strong></h1><p id="a94d" class="pw-post-body-paragraph li lj it lk b ll my kd ln lo mz kg lq lr na lt lu lv nb lx ly lz nc mb mc md im bi translated">我希望这篇文章展示了如何通过动画和交互式滑块使数据可视化变得动态。感谢您的阅读——我感谢任何评论和反馈。本文中展示的所有例子都可以在这个<a class="ae lh" href="https://github.com/venkatesannaveen/python-science-tutorial" rel="noopener ugc nofollow" target="_blank"> Github资源库</a>中找到。你可以在Twitter上关注我，或者在LinkedIn上联系我，获取更多文章和更新。</p></div></div>    
</body>
</html>