<html>
<head>
<title>How to Compare Large Files</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何比较大文件</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-compare-large-files-f58982eccd3a?source=collection_archive---------4-----------------------#2020-03-25">https://towardsdatascience.com/how-to-compare-large-files-f58982eccd3a?source=collection_archive---------4-----------------------#2020-03-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8c26" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何使用Python比较大文件</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/e07bbd414adf5047df5893ee0a19c20f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1070/format:webp/1*_L89-1sH0J85SPZH6s5Cdw.png"/></div></figure><p id="5361" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在这篇博客中，我们将学习如何比较两个大文件，同时创建一个快速而有意义的差异摘要。我已经以这样一种方式组织了这个博客，你可以按照端到端解决方案中的一步一步的指导。</p><p id="b8f8" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">一般来说，比较两个数据集并不是很难。主要的困难来自于能够快速获得有意义的见解。虽然前面提到的困难可以通过预先存在的比较库(如dataComPy)快速解决，但当数据变得如此之大，以至于无法保存在内存中时，问题就会变得更加严重。</p><div class="lm ln gp gr lo lp"><a rel="noopener follow" target="_blank" href="/building-a-python-ui-for-comparing-data-13c10693d9e4"><div class="lq ab fo"><div class="lr ab ls cl cj lt"><h2 class="bd iu gy z fp lu fr fs lv fu fw is bi translated">构建用于比较数据的Python UI</h2><div class="lw l"><h3 class="bd b gy z fp lu fr fs lv fu fw dk translated">如何快速让您的非技术团队能够比较数据</h3></div><div class="lx l"><p class="bd b dl z fp lu fr fs lv fu fw dk translated">towardsdatascience.com</p></div></div><div class="ly l"><div class="lz l ma mb mc ly md ko lp"/></div></div></a></div><p id="f6ac" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">令我失望的是，我找不到一个现有的数据比较库来处理更大的数据集。我找到的所有这些都要求所有的数据都在内存中。</p><p id="a05a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">看到这是一个需要解决的问题，我开始寻找解决这个问题的最佳方法。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="b7fe" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">确定解决方案</h1><p id="b6d3" class="pw-post-body-paragraph kq kr it ks b kt nd ju kv kw ne jx ky kz nf lb lc ld ng lf lg lh nh lj lk ll im bi translated">为了帮助确定解决方案，我从清楚地定义问题开始。我希望能够比较大文件。问题是数据太大了，我无法在内存中保存所有的数据。我也希望解决方案是简单的。</p><blockquote class="ni"><p id="3ec9" class="nj nk it bd nl nm nn no np nq nr ll dk translated">说得好的问题是解决了一半的问题。</p><p id="31af" class="nj nk it bd nl nm nn no np nq nr ll dk translated">—查尔斯·凯特林</p></blockquote><p id="14d1" class="pw-post-body-paragraph kq kr it ks b kt ns ju kv kw nt jx ky kz nu lb lc ld nv lf lg lh nw lj lk ll im bi translated">我考虑过的解决这个问题的一个方法是将部分内容加载到内存中。这意味着比较内存中的数据；找出匹配的和不匹配的(内存外)，然后转移到更多的数据上。这些类型的操作是一个完整的后勤噩梦，需要复杂的逻辑来跟踪一切。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/b26ba388f999d708b970abb2cb0d7a0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1378/format:webp/1*tUr09iHX1FfUKyvtI2ZuVw.png"/></div></figure><p id="0e09" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我希望有一种更简单的做事方法。抱着看看；我想到了另一个主意。如果我使用一个SQL数据库来进行所有的比较会怎么样。</p><p id="6b41" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">毕竟，这不是数据库的主要目的吗？持有数据，快速进行以数据为中心的操作？</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="5474" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">构建比较脚本，利用SQL的强大功能</h1><p id="fb39" class="pw-post-body-paragraph kq kr it ks b kt nd ju kv kw ne jx ky kz nf lb lc ld ng lf lg lh nh lj lk ll im bi translated">我希望比较的结果易于理解，并提供有意义的见解。这意味着我更感兴趣的是一个快速总结，和一些例子比较突破。如果需要，我总是可以深入研究数据。</p><div class="lm ln gp gr lo lp"><a rel="noopener follow" target="_blank" href="/an-introduction-to-sql-4c9eb27995df"><div class="lq ab fo"><div class="lr ab ls cl cj lt"><h2 class="bd iu gy z fp lu fr fs lv fu fw is bi translated">SQL简介</h2><div class="lw l"><h3 class="bd b gy z fp lu fr fs lv fu fw dk translated">通过示例学习SQL的基础知识</h3></div><div class="lx l"><p class="bd b dl z fp lu fr fs lv fu fw dk translated">towardsdatascience.com</p></div></div><div class="ly l"><div class="ny l ma mb mc ly md ko lp"/></div></div></a></div><p id="fa6a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">那么，它是如何工作的呢？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oa ob di oc bf od"><div class="gh gi nz"><img src="../Images/57be83531c1a2b7251fbf638021c4663.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UtTjNBRtsY3GulcDEIl09A.png"/></div></div></figure><p id="e571" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在我们运行完整的比较之前，我们应该快速查看文件是否100%相似。为此，我们可以进行校验和检查。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="fe94" class="oe mm it bd mn of og dn mr oh oi dp mv kz oj ok mx ld ol om mz lh on oo nb op bi translated">校验和:用SHA1比较数据</h2><pre class="kj kk kl km gt oq or os ot aw ou bi"><span id="ccb2" class="oe mm it or b gy ov ow l ox oy">import hashlib</span><span id="2f13" class="oe mm it or b gy oz ow l ox oy">def sha1(fname):<br/>    sha1hash = hashlib.sha1()<br/>    with open(fname) as handle: #opening the file one line at a time for memory considerations<br/>        for line in handle:<br/>            sha1hash.update(line.encode('utf-8'))<br/>    return(sha1hash.hexdigest())<br/>    <br/>def comparefiles(files,datakey):<br/>    print('########################################')<br/>    print('Checking the files\' hash.')<br/>    if sha1(files[0]) == sha1(files[1]):<br/>        print('100% Match')<br/>    else:<br/>        print('Hash not matched. Proceeding to detailed checks.')</span><span id="b4a0" class="oe mm it or b gy oz ow l ox oy">comparefiles(files, datakey)</span></pre><p id="b890" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">仔细观察上面的脚本，我们实际上是一行一行地加载文件，并计算出它们的SHA1输出。然后在两个文件之间进行比较。</p><p id="31d6" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">要运行上面的脚本，我们只需传入:</p><pre class="kj kk kl km gt oq or os ot aw ou bi"><span id="df63" class="oe mm it or b gy ov ow l ox oy">comparefiles(['path2file1', 'path2file2'], '')</span></pre><p id="e832" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">假设文件之间存在差异，那么我们想知道差异是在记录的数量上还是在它们的值上。因此，我们可以研究做一些快速计数。</p><div class="lm ln gp gr lo lp"><a href="https://medium.com/financeexplained/3-quick-ways-to-compare-data-in-python-65201be10b6" rel="noopener follow" target="_blank"><div class="lq ab fo"><div class="lr ab ls cl cj lt"><h2 class="bd iu gy z fp lu fr fs lv fu fw is bi translated">在Python中比较数据的3种快速方法</h2><div class="lw l"><h3 class="bd b gy z fp lu fr fs lv fu fw dk translated">对于任何从事分析工作的人来说，收到比较数据的请求都太熟悉了。不管那是…</h3></div><div class="lx l"><p class="bd b dl z fp lu fr fs lv fu fw dk translated">medium.com</p></div></div><div class="ly l"><div class="pa l ma mb mc ly md ko lp"/></div></div></a></div></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="a76a" class="oe mm it bd mn of og dn mr oh oi dp mv kz oj ok mx ld ol om mz lh on oo nb op bi translated">将数据加载到SQL</h2><p id="ad83" class="pw-post-body-paragraph kq kr it ks b kt nd ju kv kw ne jx ky kz nf lb lc ld ng lf lg lh nh lj lk ll im bi translated">首先，我们需要在不超出可用内存的情况下将数据加载到SQL中，并创建索引来加快查询操作。</p><p id="c45c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">从下面的脚本中，您可以看到我们首先需要定义我们的输入:</p><ul class=""><li id="c547" class="pb pc it ks b kt ku kw kx kz pd ld pe lh pf ll pg ph pi pj bi translated">文件:我们要比较的两个文件的文件路径列表</li><li id="d20d" class="pb pc it ks b kt pk kw pl kz pm ld pn lh po ll pg ph pi pj bi translated">colsep:两个文件的分隔符列表</li><li id="56f9" class="pb pc it ks b kt pk kw pl kz pm ld pn lh po ll pg ph pi pj bi translated">数据键:我们数据集的键列表</li><li id="1be3" class="pb pc it ks b kt pk kw pl kz pm ld pn lh po ll pg ph pi pj bi translated">conn:我们将用于比较的连接；它可以在内存中，也可以在物理数据库中</li></ul><p id="2e8d" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">下面的脚本中需要注意的另一件事是，我们正在逐块加载文件以避免耗尽内存，并且我们用下划线替换了所有的列空格。</p><pre class="kj kk kl km gt oq or os ot aw ou bi"><span id="8e34" class="oe mm it or b gy ov ow l ox oy">import sqlite3, pandas as pd</span><span id="7c0d" class="oe mm it or b gy oz ow l ox oy">#################Set Up#############<br/>files = [r'C:\Temp\FL_insurance.csv', r'C:\temp\FL_insurance - Copy.csv']<br/>colsep = [',',',']<br/>datakey = ['policyID', 'statecode', 'county']</span><span id="1ac4" class="oe mm it or b gy oz ow l ox oy">conn = sqlite3.connect(':memory:')<br/>#conn = sqlite3.connect('meh.sqlite3')<br/>#####################################</span><span id="ca68" class="oe mm it or b gy oz ow l ox oy">cur = conn.cursor()<br/>static = ['Table1','Table2']</span><span id="103c" class="oe mm it or b gy oz ow l ox oy">def loadDataToSQL(files, static):<br/>    chunksize = 10000<br/>    i=0<br/>    createindexfortable = lambda a, b : f'CREATE INDEX  {a} Index ON {b} ({a})'<br/>    for file in files:<br/>        i = i+1<br/>        for chunk in pd.read_csv(file, chunksize=chunksize, delimiter=colsep[i-1]): #load the file in chunks in case its too big<br/>            chunk.columns = chunk.columns.str.replace(' ', '_') #replacing spaces with underscores for column names<br/>            chunk.to_sql(name= static[i-1], con=conn, if_exists='append')<br/>    for item in datakey: #create indexes so it runs faster<br/>        createindexfortable(item, 'Table1')<br/>        createindexfortable(item, 'Table2')</span></pre><p id="0e3d" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">假设数据现在已经全部加载到SQL DB中，接下来要做的事情就是执行计数。为了控制命令的执行和输出，我们可以创建一个可以调用的函数。</p><pre class="kj kk kl km gt oq or os ot aw ou bi"><span id="9962" class="oe mm it or b gy ov ow l ox oy">def returnSQLresults(statement, noprint = 0):<br/>    cur.execute(statement)<br/>    i=0<br/>    temp = []<br/>    for row in cur:<br/>        if noprint == 0 and len(row) &gt; 1:<br/>            if i == 0: #if there are multiple records, only print the header once<br/>                names = list(map(lambda x: x[0], cur.description)) #column names<br/>                print(names)<br/>            print(row)<br/>        else:<br/>            temp.append(row)<br/>        i=i+1<br/>    if noprint == 1 and i != 0:<br/>        return(temp)<br/>    elif i==0: return(None)</span></pre><p id="c0ba" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">分解上面的脚本:</p><ol class=""><li id="9033" class="pb pc it ks b kt ku kw kx kz pd ld pe lh pf ll pp ph pi pj bi translated">我们检查光标中是否有任何结果返回，以及是否已经定义了<em class="pq"> noprint </em></li><li id="9b0e" class="pb pc it ks b kt pk kw pl kz pm ld pn lh po ll pp ph pi pj bi translated"><em class="pq"> noprint </em>本质上导致函数<em class="pq">返回</em>数据而不是打印</li><li id="23ed" class="pb pc it ks b kt pk kw pl kz pm ld pn lh po ll pp ph pi pj bi translated">如果光标返回任何结果，我们在<em class="pq">打印</em>任何内容之前<em class="pq">打印</em>结果中的列名</li></ol><p id="0464" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">完成上述设置后，我们现在可以开始比较操作了。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="381b" class="oe mm it bd mn of og dn mr oh oi dp mv kz oj ok mx ld ol om mz lh on oo nb op bi translated">总计数</h2><p id="b597" class="pw-post-body-paragraph kq kr it ks b kt nd ju kv kw ne jx ky kz nf lb lc ld ng lf lg lh nh lj lk ll im bi translated">现在是时候利用我们到目前为止在程序中定义的所有函数，开始构建数据比较摘要了。然后，让我们通过定义一个可以调用的新函数来大致了解一下总计数。</p><pre class="kj kk kl km gt oq or os ot aw ou bi"><span id="a458" class="oe mm it or b gy ov ow l ox oy">def SQLComp(files, keys, compDegree):<br/>    print('########################################')<br/>    print('Checking Counts across the two data sets:')<br/>    print('Total Counts')    <br/>    statement_counts =   '''SELECT "Table1" AS "TABLE", COUNT(1)                                                                                               FROM Table1<br/>                            UNION<br/>                            SELECT "Table2" AS "TABLE", COUNT(1) FROM Table2'''<br/>    returnSQLresults(statement_counts)</span></pre></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oa ob di oc bf od"><div class="gh gi pr"><img src="../Images/c4c9f390d210acc324726eb3d7f66374.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*azJksTSlfnmP1gsO"/></div></div><p class="ps pt gj gh gi pu pv bd b be z dk translated">照片由<a class="ae pw" href="https://unsplash.com/@hishahadat?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">沙哈达特·拉赫曼</a>在<a class="ae pw" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h2 id="700f" class="oe mm it bd mn of og dn mr oh oi dp mv kz oj ok mx ld ol om mz lh on oo nb op bi translated">比较行(根据预定义的键)</h2><p id="80ac" class="pw-post-body-paragraph kq kr it ks b kt nd ju kv kw ne jx ky kz nf lb lc ld ng lf lg lh nh lj lk ll im bi translated">此时，我们知道这两个文件不是100%匹配，并且我们也知道每个文件的计数。我们现在需要看得更深一点，了解是否有任何条目与我们预定义的键不匹配。</p><p id="9f40" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">也就是说，我们需要做一个完整的外部连接，并突出显示不在一个文件或另一个文件中的记录(按照我们预定义的键)。从技术上讲，进行这种连接的SQL查询并不复杂；然而，由于我们希望从我们的输入中自动生成查询，所以我们需要有创造性。</p><p id="41d0" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">为此，我使用了一个循环和f字符串。让我们更详细地看看这一点。</p><pre class="kj kk kl km gt oq or os ot aw ou bi"><span id="22d1" class="oe mm it or b gy ov ow l ox oy">def SQLComp(files, keys, compDegree):<br/>    for key in keys:<br/>        if key == keys[0]:<br/>            joinstatement = f'x.{key} = y.{key}'<br/>            wherestatement = f' WHERE y.{key} IS NULL'<br/>            wherenotstatement = f' WHERE y.{key} IS NOT NULL'<br/>        else: <br/>            joinstatement += f' AND x.{key} = y.{key}'<br/>            wherestatement += f' AND y.{key} IS NULL'<br/>            wherenotstatement += f' AND y.{key} IS NOT NULL'</span><span id="471a" class="oe mm it or b gy oz ow l ox oy">print('########################################')<br/>    print('Checking Rows based on data Key.')<br/>    statement1 = f'''SELECT * FROM Table1 x<br/>                    LEFT JOIN Table2 y ON {joinstatement} {wherestatement}'''<br/>    statement2 = f'''SELECT * FROM Table2 x<br/>                    LEFT JOIN Table1 y ON  {joinstatement} {wherestatement}'''<br/>                   <br/>    if returnSQLresults(statement1) is None and returnSQLresults(statement2) is None:<br/>        print('No differences found.')<br/>    else:<br/>        print('Data in file 1, but not in file 2')<br/>        returnSQLresults(statement1)<br/>        <br/>        print('Data in file 2, but not in file 1')<br/>        returnSQLresults(statement2)</span></pre><p id="dbd6" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们通过左右连接来实现完全的外部连接，在每个点突出显示孤立条目。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="5dca" class="oe mm it bd mn of og dn mr oh oi dp mv kz oj ok mx ld ol om mz lh on oo nb op bi translated">比较标题(列)</h2><p id="b802" class="pw-post-body-paragraph kq kr it ks b kt nd ju kv kw ne jx ky kz nf lb lc ld ng lf lg lh nh lj lk ll im bi translated">接下来，是列检查。我们想知道这些文件的头是否有差异。</p><p id="311a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们可以通过PRAGMA命令在SQLite中检索头，所以这是相对简单的。</p><pre class="kj kk kl km gt oq or os ot aw ou bi"><span id="c67c" class="oe mm it or b gy ov ow l ox oy">def SQLComp(files, keys, compDegree):<br/>    print('########################################')<br/>    print('Checking Columns between the two files.')<br/>    statement3 = lambda a : 'PRAGMA TABLE_INFO(' + a + ')'<br/>    statement3Table1results = returnSQLresults(statement3('Table1'),1)<br/>    statement3Table2results = returnSQLresults(statement3('Table2'),1)<br/>    if (statement3Table1results == statement3Table2results):<br/>        print('No differences found.')<br/>    else:<br/>        print('Columns in one but not the other.')<br/>        print(set(statement3Table1results)-set(statement3Table2results))</span></pre><p id="4142" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这里唯一值得强调的是集合上减法运算的使用，它允许我快速比较列表。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oa ob di oc bf od"><div class="gh gi px"><img src="../Images/7a39dde005a8112448df1d9775de8060.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2WWu26aGSvKcGU2J"/></div></div><p class="ps pt gj gh gi pu pv bd b be z dk translated">阿诺·弗朗西斯卡在<a class="ae pw" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h2 id="3a75" class="oe mm it bd mn of og dn mr oh oi dp mv kz oj ok mx ld ol om mz lh on oo nb op bi translated">详细的值比较</h2><p id="6873" class="pw-post-body-paragraph kq kr it ks b kt nd ju kv kw ne jx ky kz nf lb lc ld ng lf lg lh nh lj lk ll im bi translated">完成上述检查后，我们现在要开始探索一些价值差异。为此，我们首先要确定两个文件之间的共同列，这将允许我们对它们进行比较。</p><pre class="kj kk kl km gt oq or os ot aw ou bi"><span id="47e3" class="oe mm it or b gy ov ow l ox oy">def list2csv(l1):<br/>    for i, item in enumerate(l1):<br/>        if i == 0:<br/>            csvlist = 'x.' + item<br/>        else:<br/>            csvlist += ', x.'+ item<br/>    return(csvlist)</span><span id="b928" class="oe mm it or b gy oz ow l ox oy">def SQLComp(files, keys, compDegree):<br/>    print('########################################')<br/>    print('Differences identified in the following columns.')<br/>    columnsInCommon1 = list(set(statement3Table1results).intersection(set(statement3Table2results)))<br/>    columnsInCommon = []<br/>    for cols in columnsInCommon1:<br/>        columnsInCommon.append(cols[1])<br/>    columnsInCommon.remove('index')<br/>    cols2select = list2csv(datakey)</span><span id="f743" class="oe mm it or b gy oz ow l ox oy">for item in columnsInCommon:<br/>        statement4 = f'''SELECT {cols2select}, x.{item}, y.{item} FROM Table1 x<br/>                      JOIN Table2 y ON {joinstatement} {wherenotstatement}<br/>                      AND x.{item} &lt;&gt; y.{item}'''<br/>        returnSQLresults(statement4)</span></pre></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="8e28" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">对其进行测试</h1><p id="f4cd" class="pw-post-body-paragraph kq kr it ks b kt nd ju kv kw ne jx ky kz nf lb lc ld ng lf lg lh nh lj lk ll im bi translated">为了帮助我测试上面的脚本并展示结果，我取了一个样本数据文件，克隆它并做了一些修改。您可以在这里看到不同之处:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="oa ob di oc bf od"><div class="gh gi py"><img src="../Images/d297790eb22fc6d44b3767ba054ca485.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D196QLujVgdTaeFwBJGKaw.png"/></div></div></figure><p id="4783" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">您可以看到，我更改了标题结构下的一个值，并删除了其中一列。</p><p id="f10d" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">运行脚本，返回以下内容:</p><pre class="kj kk kl km gt oq or os ot aw ou bi"><span id="8bb9" class="oe mm it or b gy ov ow l ox oy">########################################<br/>Checking the files' hash.<br/>Hash not matched. Proceeding to detailed checks.<br/>########################################<br/>Checking Counts across the two data sets:<br/>Total Counts<br/>['TABLE', 'COUNT(1)']<br/>('Table1', 36633)<br/>('Table2', 36633)<br/>########################################<br/>Checking Rows based on data Key.<br/>No differences found.<br/>########################################<br/>Checking Columns between the two files.<br/>Columns in one but not the other.<br/>{(18, 'point_granularity', 'INTEGER', 0, None, 0)}<br/>########################################<br/>Differences identified in the following columns.<br/>['policyID', 'statecode', 'county', 'construction', 'construction']<br/>(448094, 'FL', 'CLAY COUNTY', 'Masonry', 'wut')</span></pre></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="13a5" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">结论</h1><p id="a58c" class="pw-post-body-paragraph kq kr it ks b kt nd ju kv kw ne jx ky kz nf lb lc ld ng lf lg lh nh lj lk ll im bi translated">总之，上面的脚本允许您将无法保存在内存中的大型数据集进行比较，同时最终为您提供一个漂亮的摘要视图。</p><p id="6796" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">将来可以通过以下方式轻松扩展它:</p><ul class=""><li id="a99c" class="pb pc it ks b kt ku kw kx kz pd ld pe lh pf ll pg ph pi pj bi translated">详细的值比较可以扩展为每个数据键的列表，而不是返回多行结果</li><li id="3fdd" class="pb pc it ks b kt pk kw pl kz pm ld pn lh po ll pg ph pi pj bi translated">包括特定属性的忽略标志</li><li id="b78b" class="pb pc it ks b kt pk kw pl kz pm ld pn lh po ll pg ph pi pj bi translated">引入公差(绝对、相对)</li><li id="3cdf" class="pb pc it ks b kt pk kw pl kz pm ld pn lh po ll pg ph pi pj bi translated">包括一个用户界面</li></ul><p id="09af" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果我继续使用它，我会努力扩展它，但请随意扩展它或评论您的建议。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="1fe6" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">完整的剧本</h1><pre class="kj kk kl km gt oq or os ot aw ou bi"><span id="e984" class="oe mm it or b gy ov ow l ox oy">import hashlib, sqlite3, pandas as pd</span><span id="fae5" class="oe mm it or b gy oz ow l ox oy">conn = sqlite3.connect(':memory:')<br/>#conn = sqlite3.connect('meh.sqlite3')<br/>cur = conn.cursor()</span><span id="4f3d" class="oe mm it or b gy oz ow l ox oy">files = [r'C:\Temp\FL_insurance.csv', r'C:\temp\FL_insurance - Copy.csv']<br/>colsep = [',',',']<br/>datakey = ['policyID', 'statecode', 'county']<br/>static = ['Table1','Table2']</span><span id="7ba2" class="oe mm it or b gy oz ow l ox oy">def list2csv(l1):<br/>    for i, item in enumerate(l1):<br/>        if i == 0:<br/>            csvlist = 'x.' + item<br/>        else:<br/>            csvlist += ', x.'+ item<br/>    return(csvlist)</span><span id="0852" class="oe mm it or b gy oz ow l ox oy">def sha1(fname):<br/>    sha1hash = hashlib.sha1()<br/>    with open(fname) as handle: #opening the file one line at a time for memory considerations<br/>        for line in handle:<br/>            sha1hash.update(line.encode('utf-8'))<br/>    return(sha1hash.hexdigest())</span><span id="f9fd" class="oe mm it or b gy oz ow l ox oy">def loadDataToSQL(files, static):<br/>    chunksize = 10000<br/>    i=0<br/>    createindexfortable = lambda a, b : f'CREATE INDEX  {a} Index ON {b} ({a})'<br/>    for file in files:<br/>        i = i+1<br/>        for chunk in pd.read_csv(file, chunksize=chunksize, delimiter=colsep[i-1]): #load the file in chunks in case its too big<br/>            chunk.columns = chunk.columns.str.replace(' ', '_') #replacing spaces with underscores for column names<br/>            chunk.to_sql(name= static[i-1], con=conn, if_exists='append')<br/>    for item in datakey: #create indexes so it runs faster<br/>        createindexfortable(item, 'Table1')<br/>        createindexfortable(item, 'Table2')</span><span id="80a2" class="oe mm it or b gy oz ow l ox oy">def returnSQLresults(statement, noprint = 0):<br/>    cur.execute(statement)<br/>    i=0<br/>    temp = []<br/>    for row in cur:<br/>        if noprint == 0 and len(row) &gt; 1:<br/>            if i == 0: #if there are multiple records, only print the header once<br/>                names = list(map(lambda x: x[0], cur.description)) #column names<br/>                print(names)<br/>            print(row)<br/>        else:<br/>            temp.append(row)<br/>        i=i+1<br/>    if noprint == 1 and i != 0:<br/>        return(temp)<br/>    elif i==0: return(None)</span><span id="ae82" class="oe mm it or b gy oz ow l ox oy">def sha1(fname):<br/>    sha1hash = hashlib.sha1()<br/>    with open(fname) as handle: #opening the file one line at a time for memory considerations<br/>        for line in handle:<br/>            sha1hash.update(line.encode('utf-8'))<br/>    return(sha1hash.hexdigest())</span><span id="2ec9" class="oe mm it or b gy oz ow l ox oy">def SQLComp(files, keys, compDegree):<br/>    for key in keys:<br/>        if key == keys[0]:<br/>            joinstatement = f'x.{key} = y.{key}'<br/>            wherestatement = f' WHERE y.{key} IS NULL'<br/>            wherenotstatement = f' WHERE y.{key} IS NOT NULL'<br/>        else: <br/>            joinstatement += f' AND x.{key} = y.{key}'<br/>            wherestatement += f' AND y.{key} IS NULL'<br/>            wherenotstatement += f' AND y.{key} IS NOT NULL'<br/>    print('########################################')<br/>    print('Checking Counts across the two data sets:')<br/>    print('Total Counts')    <br/>    statement_counts =   '''SELECT "Table1" AS "TABLE", COUNT(1) FROM Table1<br/>                            UNION<br/>                            SELECT "Table2" AS "TABLE", COUNT(1) FROM Table2'''<br/>    returnSQLresults(statement_counts)<br/>    print('########################################')<br/>    print('Checking Rows based on data Key.')<br/>    statement1 = f'''SELECT * FROM Table1 x<br/>                    LEFT JOIN Table2 y ON {joinstatement} {wherestatement}'''<br/>    statement2 = f'''SELECT * FROM Table2 x<br/>                    LEFT JOIN Table1 y ON  {joinstatement} {wherestatement}'''<br/>    if returnSQLresults(statement1) is None and returnSQLresults(statement2) is None:<br/>        print('No differences found.')<br/>    else:<br/>        print('Data in file 1, but not in file 2')<br/>        returnSQLresults(statement1)<br/>        print('Data in file 2, but not in file 1')<br/>        returnSQLresults(statement2)<br/>    print('########################################')<br/>    print('Checking Columns between the two files.')<br/>    #statement3 = 'PRAGMA table_info(Table1);'<br/>    statement3 = lambda a : 'PRAGMA TABLE_INFO(' + a + ')'<br/>    statement3Table1results = returnSQLresults(statement3('Table1'),1)<br/>    statement3Table2results = returnSQLresults(statement3('Table2'),1)<br/>    if (statement3Table1results == statement3Table2results):<br/>        print('No differences found.')<br/>    else:<br/>        print('Columns in one but not the other.')<br/>        print(set(statement3Table1results)-set(statement3Table2results))<br/>    print('########################################')<br/>    print('Differences identified in the following columns.')<br/>    columnsInCommon1 = list(set(statement3Table1results).intersection(set(statement3Table2results)))<br/>    columnsInCommon = []<br/>    for cols in columnsInCommon1:<br/>        columnsInCommon.append(cols[1])<br/>    columnsInCommon.remove('index')<br/>    cols2select = list2csv(datakey)<br/>    for item in columnsInCommon:<br/>        statement4 = f'''SELECT {cols2select}, x.{item}, y.{item} FROM Table1 x<br/>                      JOIN Table2 y ON {joinstatement} {wherenotstatement}<br/>                      AND x.{item} &lt;&gt; y.{item}'''<br/>        returnSQLresults(statement4)<br/>        #print(statement4)</span><span id="3e07" class="oe mm it or b gy oz ow l ox oy">def comparefiles(files,datakey):<br/>    print('########################################')<br/>    print('Checking the files\' hash.')<br/>    if sha1(files[0]) == sha1(files[1]):<br/>        print('100% Match')<br/>    else:<br/>        print('Hash not matched. Proceeding to detailed checks.')<br/>        loadDataToSQL(files, static)<br/>        SQLComp(files, datakey, [])</span><span id="46a5" class="oe mm it or b gy oz ow l ox oy">comparefiles(files, datakey)</span></pre></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="330a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果你喜欢这个故事，你可能也会喜欢:</p><div class="lm ln gp gr lo lp"><a rel="noopener follow" target="_blank" href="/building-a-python-ui-for-comparing-data-13c10693d9e4"><div class="lq ab fo"><div class="lr ab ls cl cj lt"><h2 class="bd iu gy z fp lu fr fs lv fu fw is bi translated">构建用于比较数据的Python UI</h2><div class="lw l"><h3 class="bd b gy z fp lu fr fs lv fu fw dk translated">如何快速让您的非技术团队能够比较数据</h3></div><div class="lx l"><p class="bd b dl z fp lu fr fs lv fu fw dk translated">towardsdatascience.com</p></div></div><div class="ly l"><div class="lz l ma mb mc ly md ko lp"/></div></div></a></div><div class="lm ln gp gr lo lp"><a href="https://medium.com/financeexplained/3-quick-ways-to-compare-data-in-python-65201be10b6" rel="noopener follow" target="_blank"><div class="lq ab fo"><div class="lr ab ls cl cj lt"><h2 class="bd iu gy z fp lu fr fs lv fu fw is bi translated">在Python中比较数据的3种快速方法</h2><div class="lw l"><h3 class="bd b gy z fp lu fr fs lv fu fw dk translated">对于任何从事分析工作的人来说，收到比较数据的请求都太熟悉了。不管那是…</h3></div><div class="lx l"><p class="bd b dl z fp lu fr fs lv fu fw dk translated">medium.com</p></div></div><div class="ly l"><div class="pa l ma mb mc ly md ko lp"/></div></div></a></div></div></div>    
</body>
</html>