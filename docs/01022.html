<html>
<head>
<title>Color Pop effect using BodyPix and TensorFlow.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用BodyPix和TensorFlow.js的颜色流行效果</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/color-pop-effect-using-bodypix-and-tensorflow-js-a584ddc48a02?source=collection_archive---------18-----------------------#2020-01-29">https://towardsdatascience.com/color-pop-effect-using-bodypix-and-tensorflow-js-a584ddc48a02?source=collection_archive---------18-----------------------#2020-01-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/b7297f82d759a467c0f92ef7d0c59152.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pFUAI82593bpul9wfxvRVg.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">在<a class="ae kf" href="https://unsplash.com/photos/tBWmzPuQo3w" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上发现的女孩照片</p></figure><p id="8920" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi le translated"><span class="l lf lg lh bm li lj lk ll lm di"> O </span>谷歌照片应用程序中我最喜欢的小功能之一是它的<strong class="ki iu">彩色流行</strong>效果。颜色流行(也称为颜色飞溅)效果使主体(通常是人)从图像的其余部分中突出出来。主体保持彩色，但背景变成灰度。在大多数情况下，这给人一种愉快的感觉。</p><figure class="lo lp lq lr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ln"><img src="../Images/5a127ba451669c9d4e04d60624e70800.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Aka4tGMrafqHBsCQb_A3Dg.jpeg"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">彩色流行效果示例。原稿左侧，彩色弹出右侧</p></figure><p id="fff2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然这项功能非常好用，但Google相册只将这种效果应用于一些它认为容易检测到人类的图像。这限制了它的潜力，并且不允许用户手动选择图像来应用这种效果。这让我思考，有没有什么方法可以达到类似于<em class="ls">的效果</em>，但是用<em class="ls">我选择的图片</em>？</p><p id="9d0a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">大多数应用程序不提供自动化解决方案。它需要用户手动在他们的图像上绘制这种效果，这既耗时又容易出错。我们能做得更好吗？像Google相册这样的智能东西？是啊！😉</p><p id="a341" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">了解了如何手动实现这种效果，我发现以下两个主要步骤:</p><ul class=""><li id="ebea" class="lt lu it ki b kj kk kn ko kr lv kv lw kz lx ld ly lz ma mb bi translated">在图像中的人物周围创建一个遮罩(也称为分段)。</li><li id="491b" class="lt lu it ki b kj mc kn md kr me kv mf kz mg ld ly lz ma mb bi translated">使用遮罩保留人物的颜色，同时使背景灰度化。</li></ul><h1 id="78b9" class="mh mi it bd mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne bi translated">从图像中分割出人</h1><p id="082d" class="pw-post-body-paragraph kg kh it ki b kj nf kl km kn ng kp kq kr nh kt ku kv ni kx ky kz nj lb lc ld im bi translated">这是这个过程中最重要的一步。一个好的结果很大程度上取决于分割掩模创建得有多好。这一步需要一些机器学习，因为它已经被证明在这些情况下工作良好。</p><p id="ea6e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从零开始建立和训练一个机器学习模型会花费太多时间(<em class="ls">不了解ML的人说</em>😛)，所以我搜索了一下有没有预先训练好的模型可以用。快速搜索将我带到了<a class="ae kf" href="https://github.com/tensorflow/tfjs-models/tree/master/body-pix" rel="noopener ugc nofollow" target="_blank"> BodyPix </a>，这是一个<a class="ae kf" href="http://tensorflow.org/js/" rel="noopener ugc nofollow" target="_blank"> Tensorflow.js </a>模型，用于人物分割和姿势检测。</p><div class="nk nl gp gr nm nn"><a href="https://github.com/tensorflow/tfjs-models/tree/master/body-pix" rel="noopener  ugc nofollow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd iu gy z fp ns fr fs nt fu fw is bi translated">Tensorflow.js的BodyPix模型</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">这个包包含一个名为BodyPix的独立模型，以及一些演示，用于运行实时人和身体…</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">github.com</p></div></div><div class="nw l"><div class="nx l ny nz oa nw ob jz nn"/></div></div></a></div><figure class="lo lp lq lr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oc"><img src="../Images/ce13206bd2067d1540218549dbf1a260.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Jvrhdz0GlwCrsY5njOB_Tg.gif"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">创作者提供的BodyPix现场演示。在这里尝试一下<a class="ae kf" href="https://storage.googleapis.com/tfjs-models/demos/body-pix/index.html" rel="noopener ugc nofollow" target="_blank"/></p></figure><p id="b4d5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如你所看到的，它在检测图像中的一个人(包括多人)方面做得很好，并且在浏览器上运行相对较快。彩虹色的区域就是我们需要的<strong class="ki iu">分割图</strong>。🌈</p><p id="8efc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们用Tensorflow.js和BodyPix CDN脚本建立一个基本的HTML文件。</p><pre class="lo lp lq lr gt od oe of bn og oh bi"><span id="b733" class="oi mi it oe b be oj ok l ol om">&lt;html&gt;<br/>  &lt;head&gt;<br/>    &lt;title&gt;Color Pop using Tensorflow.js and BodyPix&lt;/title&gt;<br/>  &lt;/head&gt;<br/><br/>&lt;body&gt;<br/>  &lt;!-- Canvas for input and output --&gt;<br/>  &lt;canvas&gt;&lt;/canvas&gt;<br/>  <br/>  &lt;!-- Load TensorFlow.js --&gt;<br/>  &lt;script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.2"&gt;&lt;/script&gt;<br/>  &lt;!-- Load BodyPix --&gt;<br/>  &lt;script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/body-pix@2.0"&gt;&lt;/script&gt;<br/>  <br/>  &lt;!-- Color Pop code--&gt;<br/>  &lt;script src="colorpop.js"&gt;&lt;/script&gt;<br/>  <br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><h2 id="42f7" class="on mi it bd mj oo op dn mn oq or dp mr kr os ot mv kv ou ov mz kz ow ox nd oy bi translated">在画布中载入图像</h2><p id="654f" class="pw-post-body-paragraph kg kh it ki b kj nf kl km kn ng kp kq kr nh kt ku kv ni kx ky kz nj lb lc ld im bi translated">在分割之前，理解如何在JavaScript中<strong class="ki iu">操作图像</strong>的像素数据是很重要的。一个简单的方法是使用HTML Canvas。Canvas使得读取和操作图像的像素数据变得很容易。还兼容BodyPix，双赢！</p><pre class="lo lp lq lr gt od oe of bn og oh bi"><span id="2b61" class="oi mi it oe b be oj ok l ol om">function loadImage(src) {<br/>  const img = new Image();<br/>  const canvas = document.querySelector('canvas');<br/>  const ctx = canvas.getContext('2d');<br/><br/>  // Load the image on canvas<br/>  img.addEventListener('load', () =&gt; {<br/>    // Set canvas width, height same as image<br/>    canvas.width = img.width;<br/>    canvas.height = img.height;<br/>    ctx.drawImage(img, 0, 0);<br/><br/>    // TODO: Implement pop()<br/>    pop();<br/>  });<br/><br/>  img.src = src;<br/>}</span></pre><h2 id="a1d9" class="on mi it bd mj oo op dn mn oq or dp mr kr os ot mv kv ou ov mz kz ow ox nd oy bi translated">正在加载BodyPix模型</h2><p id="8da8" class="pw-post-body-paragraph kg kh it ki b kj nf kl km kn ng kp kq kr nh kt ku kv ni kx ky kz nj lb lc ld im bi translated">BodyPix的README很好地解释了如何使用该模型。加载模型的一个重要部分是您使用的<code class="fe oz pa pb oe b">architecture</code>。ResNet更准确，但速度较慢，而MobileNet不太准确，但速度较快。在构建和测试这个效果时，我将使用MobileNet。稍后我将切换到ResNet并比较结果。<br/>注意:最好加载一次模型，并多次重复使用它进行分段，因为每次加载模型时都必须下载架构。在下面的例子中，每次对图像应用颜色弹出效果时，都会加载模型(以保持主要功能清晰)。</p><pre class="lo lp lq lr gt od oe of bn og oh bi"><span id="7b13" class="oi mi it oe b be oj ok l ol om">async function pop() {<br/>  // Loading the model<br/>  const net = await bodyPix.load({<br/>    architecture: 'MobileNetV1',<br/>    outputStride: 16,<br/>    multiplier: 0.75,<br/>    quantBytes: 2<br/>  });<br/>}</span></pre><h2 id="8e98" class="on mi it bd mj oo op dn mn oq or dp mr kr os ot mv kv ou ov mz kz ow ox nd oy bi translated">执行分段👥</h2><p id="5a03" class="pw-post-body-paragraph kg kh it ki b kj nf kl km kn ng kp kq kr nh kt ku kv ni kx ky kz nj lb lc ld im bi translated">BodyPix具有多种功能来分割图像。一些适合于身体部分分割，而另一些适合于单人/多人分割。所有这些都在他们的<a class="ae kf" href="https://github.com/tensorflow/tfjs-models/tree/master/body-pix" rel="noopener ugc nofollow" target="_blank">自述文件</a>中有详细解释。<code class="fe oz pa pb oe b">segmentPerson()</code>将在这种情况下工作，因为它在一个单独的地图中为图像中的每个人创建一个分割地图。此外，它比其他方法相对更快。</p><p id="2855" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe oz pa pb oe b">segmentPerson()</code>接受一个画布元素作为输入图像，以及一些配置设置。<code class="fe oz pa pb oe b">internalResolution</code>设置指定分割前输入图像尺寸调整的因子。我将使用<code class="fe oz pa pb oe b">full</code>进行设置，因为我想要清晰的分割图。我强烈建议你阅读一下其他的设置，并尝试一下。</p><pre class="lo lp lq lr gt od oe of bn og oh bi"><span id="2dec" class="oi mi it oe b be oj ok l ol om">async function pop() {<br/>  // Loading the model<br/>  const net = await bodyPix.load({<br/>    architecture: 'MobileNetV1',<br/>    outputStride: 16,<br/>    multiplier: 0.75,<br/>    quantBytes: 2<br/>  });<br/>  <br/>  // Segmentation<br/>  const canvas = document.querySelector('canvas');<br/>  const { data:map } = await net.segmentPerson(canvas, {<br/>    internalResolution: 'full',<br/>  });<br/>}</span></pre><p id="b871" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">分割后的结果就是一个物体(如下图)。结果对象的主要部分是<code class="fe oz pa pb oe b">data</code>，它是一个将分割图表示为一个数字数组的<code class="fe oz pa pb oe b">Uint8Array</code>。我已经用ES6析构把<code class="fe oz pa pb oe b">data</code>拿出来当<code class="fe oz pa pb oe b">map</code>。这将用于应用颜色流行到图像！</p><pre class="lo lp lq lr gt od oe of bn og oh bi"><span id="ccc4" class="oi mi it oe b be oj ok l ol om">{<br/>  width: 640,<br/>  height: 480,<br/>  data: Uint8Array(307200) [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, …],<br/>  allPoses: [{"score": 0.4, "keypoints": […]}, …]<br/>}</span></pre><h1 id="ef40" class="mh mi it bd mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne bi translated">制作背景灰度</h1><p id="ced9" class="pw-post-body-paragraph kg kh it ki b kj nf kl km kn ng kp kq kr nh kt ku kv ni kx ky kz nj lb lc ld im bi translated">准备好分割数据后，下一部分涉及使用分割图实现颜色弹出，以使背景灰度化并保留图像中人物的颜色。为此，需要对图像进行像素级的操作，这也是canvas元素大放异彩的地方。<code class="fe oz pa pb oe b">getImageData()</code>函数返回<code class="fe oz pa pb oe b">ImageData</code>，其中包含RGBA格式的每个像素的颜色。在下面的代码中，我使用了析构来提取有用的<code class="fe oz pa pb oe b">data</code>作为<code class="fe oz pa pb oe b">imgData</code></p><pre class="lo lp lq lr gt od oe of bn og oh bi"><span id="36ec" class="oi mi it oe b be oj ok l ol om">async function pop() {<br/>  // ... previous code<br/>  <br/>  // Extracting image data<br/>  const ctx = canvas.getContext('2d');<br/>  const { data:imgData } = ctx.getImageData(0, 0, canvas.width, canvas.height);<br/>}</span></pre><h2 id="0a7d" class="on mi it bd mj oo op dn mn oq or dp mr kr os ot mv kv ou ov mz kz ow ox nd oy bi translated">应用效果</h2><p id="ea26" class="pw-post-body-paragraph kg kh it ki b kj nf kl km kn ng kp kq kr nh kt ku kv ni kx ky kz nj lb lc ld im bi translated">所有的材料都准备好了，这就是色彩流行魔法发生的地方！让我们从创建新的图像数据开始。<code class="fe oz pa pb oe b">createImageData()</code>创建一个新的图像数据，我们对实际图像数据的所有修改都将存储在这里。</p><p id="7ede" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们遍历地图中的像素，其中每个元素都是1或0。</p><ul class=""><li id="3d80" class="lt lu it ki b kj kk kn ko kr lv kv lw kz lx ld ly lz ma mb bi translated">1表示在该像素处检测到<strong class="ki iu">人</strong>。</li><li id="117a" class="lt lu it ki b kj mc kn md kr me kv mf kz mg ld ly lz ma mb bi translated">0表示<strong class="ki iu">在该像素处没有检测到人</strong>。</li></ul><p id="1563" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了提高代码的可读性，我使用析构将颜色数据提取到<code class="fe oz pa pb oe b">r</code> <code class="fe oz pa pb oe b">g</code> <code class="fe oz pa pb oe b">b</code> <code class="fe oz pa pb oe b">a</code>变量中。然后使用RGB值，使用<strong class="ki iu">亮度方法</strong>计算适当的灰色。有各种方法来计算灰度值。<a class="ae kf" href="http://www.tannerhelland.com/3643/grayscale-image-algorithm-vb6/" rel="noopener ugc nofollow" target="_blank">这篇文章</a>有一个很好的列表，列出了其中的一些转换公式。</p><p id="a722" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，基于分割图值(0或1 ),可以将灰度或实际的RGBA颜色分配给新的图像数据。请注意，RGB中对应的灰色是通过为所有三个通道分配相同的灰度值来计算的。</p><p id="874e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">处理完每个像素后，使用<code class="fe oz pa pb oe b">putImageData()</code>功能在画布上绘制新的图像数据。</p><pre class="lo lp lq lr gt od oe of bn og oh bi"><span id="0691" class="oi mi it oe b be oj ok l ol om">async function pop() {<br/>  // ... previous code<br/>  <br/>  // Creating new image data<br/>  const newImg = ctx.createImageData(canvas.width, canvas.height);<br/>  const newImgData = newImg.data;<br/>  <br/>  // Apply the effect<br/>  for(let i=0; i&lt;map.length; i++) {<br/>    // Extract data into r, g, b, a from imgData<br/>    const [r, g, b, a] = [<br/>      imgData[i*4],<br/>      imgData[i*4+1],<br/>      imgData[i*4+2],<br/>      imgData[i*4+3]<br/>    ];<br/><br/>    // Calculate the gray color<br/>    const gray = ((0.3 * r) + (0.59 * g) + (0.11 * b));<br/><br/>    // Set new RGB color to gray if map value is not 1<br/>    // for the current pixel in iteration<br/>    [<br/>      newImgData[i*4],<br/>      newImgData[i*4+1],<br/>      newImgData[i*4+2],<br/>      newImgData[i*4+3]<br/>    ] = !map[i] ? [gray, gray, gray, 255] : [r, g, b, a];<br/>  }<br/>  <br/>  // Draw the new image back to canvas<br/>  ctx.putImageData(newImg, 0, 0);<br/>}</span></pre><p id="73cb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可以看到具有彩色pop效果的最终图像应用于原始图像。耶！🎉</p><h1 id="0ad9" class="mh mi it bd mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne bi translated">探索其他架构和设置</h1><p id="34d4" class="pw-post-body-paragraph kg kh it ki b kj nf kl km kn ng kp kq kr nh kt ku kv ni kx ky kz nj lb lc ld im bi translated">我对ResNet和MobileNet架构进行了一些测试。在所有示例图像中，图像的一个维度(宽度或高度)的大小为1080px。请注意，分割的内部分辨率被设置为<code class="fe oz pa pb oe b">full</code>(分割期间图像不缩小)。</p><p id="9606" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于我的测试，我在加载BodyPix模型时使用了以下设置。</p><pre class="lo lp lq lr gt od oe of bn og oh bi"><span id="0049" class="oi mi it oe b be oj ok l ol om">// MobileNet architecture<br/>const net = await bodyPix.load({<br/>  architecture: 'MobileNetV1',<br/>  outputStride: 16,<br/>  quantBytes: 4,<br/>});<br/><br/><br/>// ResNet architecture<br/>const net = await bodyPix.load({<br/>  architecture: 'ResNet50',<br/>  outputStride: 16,<br/>  quantBytes: 2,<br/>});</span></pre><h2 id="87f1" class="on mi it bd mj oo op dn mn oq or dp mr kr os ot mv kv ou ov mz kz ow ox nd oy bi translated">测试1 —单人</h2><p id="b1bc" class="pw-post-body-paragraph kg kh it ki b kj nf kl km kn ng kp kq kr nh kt ku kv ni kx ky kz nj lb lc ld im bi translated">这里两个模特都发现了照片中的女孩。与MobileNet相比，ResNet更好地分割了该图像。</p><figure class="lo lp lq lr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pc"><img src="../Images/32a0e51e00559ec124009cfe01f2d7c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3o2a0u1gCdi9__x06xWs3w.jpeg"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">从左至右:原始样本、MobileNet、ResNet</p></figure><h2 id="14c2" class="on mi it bd mj oo op dn mn oq or dp mr kr os ot mv kv ou ov mz kz ow ox nd oy bi translated">测试2 —多人</h2><p id="c796" class="pw-post-body-paragraph kg kh it ki b kj nf kl km kn ng kp kq kr nh kt ku kv ni kx ky kz nj lb lc ld im bi translated">这是一个有点棘手的问题，因为它有许多人在图像周围摆着不同的姿势和道具。ResNet再次准确地分割了图像中的所有人。MobileNet也很接近，但错过了一些边缘。<br/>两者都错误地分割了坐垫的一部分。</p><figure class="lo lp lq lr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pc"><img src="../Images/bda9b6d27940956d37eceb56f7e1ba7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m8ZbONFA2yKla7kFEjeljg.jpeg"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">从左至右:原始样本、MobileNet、ResNet</p></figure><h2 id="51d4" class="on mi it bd mj oo op dn mn oq or dp mr kr os ot mv kv ou ov mz kz ow ox nd oy bi translated">测试3 —面朝后</h2><p id="555c" class="pw-post-body-paragraph kg kh it ki b kj nf kl km kn ng kp kq kr nh kt ku kv ni kx ky kz nj lb lc ld im bi translated">另一个棘手的问题是，照片中的女孩面朝后。老实说，我期待着对图像中女孩的不准确检测，但ResNet和MobileNet在这方面都没有问题。由于dupatta，两种架构中的分段都不准确。</p><figure class="lo lp lq lr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pc"><img src="../Images/1914f1d50410e370d16bb54ddc8de194.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GaRxp6BpcrSUys3BFnzrCQ.jpeg"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">从左至右:原始样本、MobileNet、ResNet</p></figure><h2 id="6666" class="on mi it bd mj oo op dn mn oq or dp mr kr os ot mv kv ou ov mz kz ow ox nd oy bi translated">测试的结论是📋</h2><p id="d791" class="pw-post-body-paragraph kg kh it ki b kj nf kl km kn ng kp kq kr nh kt ku kv ni kx ky kz nj lb lc ld im bi translated">从测试中可以明显看出，ResNet比MobileNet执行更好的分段，但代价是更高的时间。两者都很好地检测了同一幅图像中的多人，但有时由于服装的原因无法准确分割。由于BodyPix打算在浏览器(或Node.js) 中与<em class="ls"> Tensorflow.js一起运行，所以当使用正确的设置时，它的执行速度令人印象深刻。</em></p><p id="4aba" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是我如何能够创造受谷歌照片启发的彩色流行效果。总而言之，BodyPix是一个很棒的人物细分模型。我很想在我未来的一些项目中使用这个和Tensorflow.js。你可以在这里找到源代码和现场工作版本:<a class="ae kf" href="https://glitch.com/~color-pop-effect" rel="noopener ugc nofollow" target="_blank">https://glitch.com/~color-pop-effect</a></p></div><div class="ab cl pd pe hx pf" role="separator"><span class="pg bw bk ph pi pj"/><span class="pg bw bk ph pi pj"/><span class="pg bw bk ph pi"/></div><div class="im in io ip iq"><p id="b4b6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我已经为这个颜色的流行效果创建了一个Firebase云函数。它在Node上使用Tensorflow.js，这使得它比在用户的浏览器上运行要快得多。您可以检查<a class="ae kf" href="https://github.com/blenderskool/color-pop" rel="noopener ugc nofollow" target="_blank">颜色弹出</a>🌈在这里投影。我迫不及待地想看到你的❤️和对它的贡献！</p></div></div>    
</body>
</html>