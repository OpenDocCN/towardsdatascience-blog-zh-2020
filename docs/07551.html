<html>
<head>
<title>Represent Hierarchical Data in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python表示分层数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/represent-hierarchical-data-in-python-cd36ada5c71a?source=collection_archive---------20-----------------------#2020-06-07">https://towardsdatascience.com/represent-hierarchical-data-in-python-cd36ada5c71a?source=collection_archive---------20-----------------------#2020-06-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="15fb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用anytree库解析简单的JSON表示</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/eeb769f4eb4e50fe33384627da3c0962.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8poxrcWhqRqCrnmP"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Edvard Alexander lvaag在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="941c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在计算机科学中，处理层次分类数据是非常常见的。应用范围从<a class="ae ky" href="https://en.wikipedia.org/wiki/Taxonomy_(general)" rel="noopener ugc nofollow" target="_blank">维基百科</a>的类别到由聚类算法(如HDBSCAN)生成的数据的层次结构，等等。</p><p id="b143" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，让我们从我的工作领域中的一个例子开始:如何正确分类连接到网络的设备。从“设备”的一般概念出发，我们可以定义两大类设备，称为“网络”和“计算机”。第一类可以进一步细分为“路由器”、“交换机”和“防火墙”(当然，为了简单起见，我省略了其他几类)。数据可以这样表示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/c80f556ae9316ffe8460910bd17cebaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:850/format:webp/1*PsV9Y5RxPtAKEWjFsYUHeQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用于对联网设备进行分类的分类示例。</p></figure><p id="045f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种在层次结构中表示分类数据的方式——其自然适合的数据结构是一个<em class="lw">树</em>——在技术上被称为<a class="ae ky" href="https://www.britannica.com/science/taxonomy" rel="noopener ugc nofollow" target="_blank"> <em class="lw">分类法</em> </a>，这个术语最初在生物学中用于对物种进行分类。分类的每个元素都是一个<em class="lw">分类节点</em>。</p><p id="58b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果想用人类可读的格式(如JSON)来表示分类法，最常用的表示方法如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="5410" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种表示暴露了树的递归性质，但是随着分类的增长，由于大量的嵌套层次，它很快变得难以修改。在这篇文章中，我将展示JSON中的另一种表示，以及序列化它的Python代码。</p><h2 id="ceea" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">分层数据的简单JSON表示</h2><p id="4fb5" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">通过避免任何嵌套结构并将所有对象表示为按每个分类级别划分的平面列表，可以获得表示分类数据的另一种方法。这样，我们之前使用的分类示例如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="100f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和以前一样，每个节点可以包含任意数量的属性。上面的表示很容易在应用程序中解析和修改。然而，相对于前一个，它有一些缺点:</p><ul class=""><li id="e161" class="mx my it lb b lc ld lf lg li mz lm na lq nb lu nc nd ne nf bi translated">它没有显示底层树的递归性质，因此部分地失去了人类的可读性。</li><li id="104c" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">由于每个分类节点存储了<em class="lw">父</em>字段，因此它占用了更多内存。</li></ul><p id="3da9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在为分层数据选择正确的表示法时，请考虑这些缺点。现在让我们看看如何用Python解析上面的分类法表示。</p><h2 id="50ce" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">用Python解析分层数据</h2><p id="12bf" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">您肯定知道，说到可用库，没有哪种语言比Python更好。因此，有几个适合处理分类法的库就不足为奇了:</p><ul class=""><li id="f436" class="mx my it lb b lc ld lf lg li mz lm na lq nb lu nc nd ne nf bi translated">最受欢迎的是<code class="fe nl nm nn no b"><a class="ae ky" href="https://networkx.github.io/documentation/stable/" rel="noopener ugc nofollow" target="_blank">networkx</a></code>。尽管它是为更复杂的图结构而设计的，<code class="fe nl nm nn no b">networkx</code>很容易适应分类法，这只是图的一个特例。</li><li id="4f9f" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">另一个不太受欢迎的图书馆是<code class="fe nl nm nn no b"><a class="ae ky" href="https://anytree.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">anytree</a></code>。它实现了一个简单但功能丰富的树数据结构，并且经过了实战测试(它达到了版本2.8.0，对于Python库来说并不常见)。这是我为这篇文章选择的库。</li><li id="8324" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">其他库包括<code class="fe nl nm nn no b"><a class="ae ky" href="https://github.com/joowani/binarytree" rel="noopener ugc nofollow" target="_blank">binarytree</a></code> just for二叉树、<a class="ae ky" href="https://github.com/niemasd/TreeSwift" rel="noopener ugc nofollow" target="_blank"> TreeSwift </a>等等。</li></ul><p id="d458" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们构建一个TaxonomyParser类的最小版本，用于反序列化JSON表示，并使用惟一的节点标识符在分类法中进行搜索。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="7b80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个类唯一需要的属性是<code class="fe nl nm nn no b">root_key</code>——用于快速检索根节点——和包含所有树节点的字典<code class="fe nl nm nn no b">nodes</code>,这些树节点由它们唯一的<code class="fe nl nm nn no b">name</code>索引。由于JSON文件中的平面表示，反序列化分层数据的代码(<code class="fe nl nm nn no b">read_from_json</code>方法)非常简单。</p><p id="198f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果需要在分类法上实现更复杂的搜索条件，该怎么办？例如，假设每个节点包含一个带有正则表达式列表的<code class="fe nl nm nn no b">regex</code>属性。给定一个输入关键字，您希望查找正则表达式与该关键字匹配的所有节点。听起来很复杂？得益于<code class="fe nl nm nn no b">anytree</code>灵活的界面，这可以通过几行代码实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="e119" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，如果您想将图形导出到标准。<em class="lw">点</em>格式或作为PNG图像，<code class="fe nl nm nn no b">anytree</code>提供了所有你需要的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lx ly l"/></div></figure></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><p id="4083" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总之，有了<code class="fe nl nm nn no b">anytree</code>库，解析和操作本文中呈现的平面表示中存储的分层数据变得非常容易。完整的代码可以在我的<a class="ae ky" href="https://github.com/madagra/taxonomy-parser" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到。如果你喜欢这篇文章，并且有任何问题或意见，请不要犹豫，通过<a class="ae ky" href="https://www.linkedin.com/in/mariodagrada/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>联系我。</p></div></div>    
</body>
</html>