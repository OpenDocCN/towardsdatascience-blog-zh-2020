<html>
<head>
<title>Building an Automated Machine Learning Pipeline: Part Four</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建自动化机器学习管道:第四部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-an-automated-machine-learning-pipeline-part-four-787cdc50a12d?source=collection_archive---------29-----------------------#2020-06-09">https://towardsdatascience.com/building-an-automated-machine-learning-pipeline-part-four-787cdc50a12d?source=collection_archive---------29-----------------------#2020-06-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="5053" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" rel="noopener" target="_blank" href="https://towardsdatascience.com/machine-learning/home">机器学习</a></h2><div class=""/><div class=""><h2 id="6d29" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">利用 Docker 和 Luigi 实现管道自动化</h2></div><ul class=""><li id="d0e7" class="kr ks it kt b ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated"><a class="ae lj" rel="noopener" target="_blank" href="/building-an-automated-machine-learning-pipeline-part-one-5c70ae682f35?source=friends_link&amp;sk=8de05327eedb3d0dadcfa4b1a8e8cc75">第 1 部分:理解、清理、探索、处理数据</a></li><li id="5448" class="kr ks it kt b ku lk kw ll ky lm la ln lc lo le lf lg lh li bi translated"><a class="ae lj" rel="noopener" target="_blank" href="/building-an-automated-machine-learning-pipeline-part-two-1d3c86e6fe42?source=friends_link&amp;sk=a005d5ead7a844adb7819403ddc6dc0e">第 2 部分:设置指标和基线，选择和调整模型</a></li><li id="fa49" class="kr ks it kt b ku lk kw ll ky lm la ln lc lo le lf lg lh li bi translated"><a class="ae lj" rel="noopener" target="_blank" href="/building-an-automated-machine-learning-pipeline-a74acda76b98?source=friends_link&amp;sk=1790d8dd404126a45828c3905f47432c">第三部分:培训、评估和解释模型</a></li><li id="2032" class="kr ks it kt b ku lk kw ll ky lm la ln lc lo le lf lg lh li bi translated">第 4 部分:使用 Docker 和 Luigi 自动化您的管道(您现在正在阅读)</li></ul><blockquote class="lp lq lr"><p id="9591" class="ls lt lu kt b ku kv kd lv kw kx kg lw lx ly lz ma mb mc md me mf mg mh mi le im bi translated"><strong class="kt jd">免责声明:</strong>本文章系列不是关于 Docker 和 Luigi 的教程。这是“构建自动化机器学习管道”系列文章的最后一篇，该系列文章重点关注构建端到端的 ML 管道，并展示如何使用这两种工具的某些元素来自动化它。如果你阅读了上面链接中的前几篇文章，这篇文章会对你更有意义。</p></blockquote><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mj"><img src="../Images/f6d537cb8d250f759cdaf694e7a28c57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WHxWnEoQDZAdxgKxzBxO2A.jpeg"/></div></div><p class="mv mw gj gh gi mx my bd b be z dk translated">照片由<a class="ae lj" href="https://unsplash.com/@ekrull?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">埃里克·克鲁尔</a>在<a class="ae lj" href="https://unsplash.com/collections/10621375/medium-ejcuhcdfwrs?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="323e" class="pw-post-body-paragraph ls lt it kt b ku kv kd lv kw kx kg lw ky ly lz ma la mc md me lc mg mh mi le im bi translated">在这个系列文章中，我们将我们的课程设置为构建一个 9 步机器学习(ML)管道，并使用 Docker 和 Luigi 将其自动化。</p><ol class=""><li id="c904" class="kr ks it kt b ku kv kw kx ky kz la lb lc ld le mz lg lh li bi translated">理解、清理和格式化数据</li><li id="0817" class="kr ks it kt b ku lk kw ll ky lm la ln lc lo le mz lg lh li bi translated">探索性数据分析</li><li id="daeb" class="kr ks it kt b ku lk kw ll ky lm la ln lc lo le mz lg lh li bi translated">特征工程和预处理</li><li id="d190" class="kr ks it kt b ku lk kw ll ky lm la ln lc lo le mz lg lh li bi translated">设置评估指标并建立基线</li><li id="122b" class="kr ks it kt b ku lk kw ll ky lm la ln lc lo le mz lg lh li bi translated">基于评估度量选择 ML 模型</li><li id="93f3" class="kr ks it kt b ku lk kw ll ky lm la ln lc lo le mz lg lh li bi translated">对所选模型执行超参数调整</li><li id="3f89" class="kr ks it kt b ku lk kw ll ky lm la ln lc lo le mz lg lh li bi translated">训练和评估模型</li><li id="ae9d" class="kr ks it kt b ku lk kw ll ky lm la ln lc lo le mz lg lh li bi translated">解释模型预测</li><li id="4a34" class="kr ks it kt b ku lk kw ll ky lm la ln lc lo le mz lg lh li bi translated">得出结论并记录工作</li></ol><p id="f6d2" class="pw-post-body-paragraph ls lt it kt b ku kv kd lv kw kx kg lw ky ly lz ma la mc md me lc mg mh mi le im bi translated">由于这个管道，我们构建了我们的 ML 解决方案，并将其命名为<strong class="kt jd"> <em class="lu">葡萄酒评级预测器</em> </strong>，因为我们试图使用样本数据集<a class="ae lj" href="https://github.com/cereniyim/Wine-Rating-Predictor-ML-Model/blob/master/data_root/raw/wine_dataset.csv" rel="noopener ugc nofollow" target="_blank">来推断用<em class="lu">点</em>表示的葡萄酒质量。在第一篇文章</a>的<a class="ae lj" rel="noopener" target="_blank" href="/building-an-automated-machine-learning-pipeline-part-one-5c70ae682f35?source=friends_link&amp;sk=8de05327eedb3d0dadcfa4b1a8e8cc75">中，我们将葡萄酒评级预测器的要求定义为:</a></p><blockquote class="lp lq lr"><p id="52de" class="ls lt lu kt b ku kv kd lv kw kx kg lw lx ly lz ma mb mc md me mf mg mh mi le im bi translated"><strong class="kt jd"> -可以理解</strong>因为我们的观众可能对统计学和 ML 了解有限。</p><p id="df94" class="ls lt lu kt b ku kv kd lv kw kx kg lw lx ly lz ma mb mc md me mf mg mh mi le im bi translated"><strong class="kt jd"> -高性能</strong>因为完整的生产数据集可能有数百万行。</p><p id="8514" class="ls lt lu kt b ku kv kd lv kw kx kg lw lx ly lz ma mb mc md me mf mg mh mi le im bi translated"><strong class="kt jd"> -自动化</strong>，可以在任何生产系统上运行，不需要专门的配置和设置。</p></blockquote><p id="59a4" class="pw-post-body-paragraph ls lt it kt b ku kv kd lv kw kx kg lw ky ly lz ma la mc md me lc mg mh mi le im bi translated">到目前为止，我们已经满足了<strong class="kt jd">的可理解性</strong>并解决了<strong class="kt jd">的性能</strong>——在某种程度上:</p><ul class=""><li id="3cab" class="kr ks it kt b ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">我们选择了一个<strong class="kt jd">可理解的</strong>模型，随机森林回归器，作为葡萄酒评级预测器的底层 ML 算法。此外，我们已经在第二篇文章和第三篇文章中解释了随机森林回归器的工作原理及其超参数<a class="ae lj" rel="noopener" target="_blank" href="/building-an-automated-machine-learning-pipeline-part-two-1d3c86e6fe42?source=friends_link&amp;sk=a005d5ead7a844adb7819403ddc6dc0e">。</a></li><li id="8b5d" class="kr ks it kt b ku lk kw ll ky lm la ln lc lo le lf lg lh li bi translated">我们通过对随机森林回归器执行超参数调优，构建了一个<strong class="kt jd">性能</strong>模型。尽管如此，我们仍然有它的空间。</li></ul><p id="0d6c" class="pw-post-body-paragraph ls lt it kt b ku kv kd lv kw kx kg lw ky ly lz ma la mc md me lc mg mh mi le im bi translated">今天，我们将戴上软件工程师的帽子，解决最后一个需求— <strong class="kt jd">自动化。我们将从 ML 管道中采取以下步骤，在 Docker 容器上运行这些步骤，并将它们与 Luigi 任务连接起来。(不要担心，我们将在整篇文章中详细阐述它们🙂)</strong></p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi na"><img src="../Images/41b042e461eae7b411c12519e5fda477.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X-EVmlK2C7d51BBMVOkm-w.png"/></div></div><p class="mv mw gj gh gi mx my bd b be z dk translated">ML 管道的自动化流程</p></figure><p id="680b" class="pw-post-body-paragraph ls lt it kt b ku kv kd lv kw kx kg lw ky ly lz ma la mc md me lc mg mh mi le im bi translated">如果你已经注意到，我们有两个额外的步骤，因为一个典型的现实世界的 ML 管道开始于从一个源获取数据。此外，我们包括了训练-测试数据集分割，其余的是 ML 管道的已知步骤。</p><p id="599a" class="pw-post-body-paragraph ls lt it kt b ku kv kd lv kw kx kg lw ky ly lz ma la mc md me lc mg mh mi le im bi translated">为了运行上面的流程，我们将首先查看 Docker 和 Luigi，并理解它们在本系列文章的上下文中的用法。因此，我们将从解释这些工具及其必要元素开始。</p><p id="ddef" class="pw-post-body-paragraph ls lt it kt b ku kv kd lv kw kx kg lw ky ly lz ma la mc md me lc mg mh mi le im bi translated">然后，我们将使用这些工具来连接这些点。最终，我们将把这些碎片放在一起，运行流程，这将完成我们的自动化任务！</p><ol class=""><li id="9287" class="kr ks it kt b ku kv kw kx ky kz la lb lc ld le mz lg lh li bi translated">什么是 Docker，它是如何用于葡萄酒等级预测的？</li><li id="a100" class="kr ks it kt b ku lk kw ll ky lm la ln lc lo le mz lg lh li bi translated">什么是 Luigi，为什么选择它作为编排工具？</li><li id="f074" class="kr ks it kt b ku lk kw ll ky lm la ln lc lo le mz lg lh li bi translated">把 Docker 和 Luigi 的碎片放在一起</li><li id="ef8b" class="kr ks it kt b ku lk kw ll ky lm la ln lc lo le mz lg lh li bi translated">运行和自动化管道！</li></ol><p id="5296" class="pw-post-body-paragraph ls lt it kt b ku kv kd lv kw kx kg lw ky ly lz ma la mc md me lc mg mh mi le im bi translated">您可以在这里找到 GitHub 资源库:</p><div class="nb nc gp gr nd ne"><a href="https://github.com/cereniyim/Wine-Rating-Predictor-ML-Model" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd jd gy z fp nj fr fs nk fu fw jc bi translated">cereniyim/葡萄酒评级预测模型</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">在这个项目中，我为一个在线葡萄酒卖家构建了一个葡萄酒评级预测器。这款葡萄酒预测器旨在显示良好的…</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">github.com</p></div></div><div class="nn l"><div class="no l np nq nr nn ns mt ne"/></div></div></a></div><p id="e64a" class="pw-post-body-paragraph ls lt it kt b ku kv kd lv kw kx kg lw ky ly lz ma la mc md me lc mg mh mi le im bi translated">在我们开始之前，还有一个免责声明:</p><blockquote class="lp lq lr"><p id="593c" class="ls lt lu kt b ku kv kd lv kw kx kg lw lx ly lz ma mb mc md me mf mg mh mi le im bi translated"><strong class="kt jd">免责声明:</strong>库的结构和<strong class="kt jd"> </strong> <code class="fe nt nu nv nw b">download_data.py</code>、<code class="fe nt nu nv nw b">util.py</code>、<code class="fe nt nu nv nw b">docker-clean.sh</code>、<code class="fe nt nu nv nw b">docker-compose.yml</code>文件提供给我作为代码挑战的基础。剩下的代码是我写的。</p></blockquote></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><h1 id="5d13" class="oe of it bd og oh oi oj ok ol om on oo ki op kj oq kl or km os ko ot kp ou ov bi translated">1.什么是 Docker，它是如何用于葡萄酒等级预测的？</h1><h2 id="04e2" class="ow of it bd og ox oy dn ok oz pa dp oo ky pb pc oq la pd pe os lc pf pg ou iz bi translated">Docker 是什么？</h2><p id="e0c1" class="pw-post-body-paragraph ls lt it kt b ku ph kd lv kw pi kg lw ky pj lz ma la pk md me lc pl mh mi le im bi translated"><a class="ae lj" href="https://en.wikipedia.org/wiki/Docker_(software)" rel="noopener ugc nofollow" target="_blank">维基百科</a>对 Docker 的官方定义如下:</p><blockquote class="pm"><p id="15e7" class="pn po it bd pp pq pr ps pt pu pv le dk translated">Docker 是一套平台即服务产品，它使用操作系统级虚拟化来交付名为<strong class="ak">容器</strong>的软件包中的软件。</p></blockquote><p id="0a67" class="pw-post-body-paragraph ls lt it kt b ku pw kd lv kw px kg lw ky py lz ma la pz md me lc qa mh mi le im bi translated">我将它定义为为你的应用程序/软件/数据科学/ML 项目创建虚拟环境，这样它可以在任何有 Docker 的系统上无缝运行。</p><h2 id="c088" class="ow of it bd og ox oy dn ok oz pa dp oo ky pb pc oq la pd pe os lc pf pg ou iz bi translated"><strong class="ak">我们如何用 Docker 创建虚拟环境？</strong></h2><p id="3ab7" class="pw-post-body-paragraph ls lt it kt b ku ph kd lv kw pi kg lw ky pj lz ma la pk md me lc pl mh mi le im bi translated">经由<strong class="kt jd">容器</strong>。它们是运行您的应用程序的独立虚拟环境，对于我们的情况，是 ML 解决方案。</p><h2 id="0146" class="ow of it bd og ox oy dn ok oz pa dp oo ky pb pc oq la pd pe os lc pf pg ou iz bi translated">我们如何创建 Docker 容器？</h2><p id="a8a8" class="pw-post-body-paragraph ls lt it kt b ku ph kd lv kw pi kg lw ky pj lz ma la pk md me lc pl mh mi le im bi translated">来自<strong class="kt jd">图像</strong>。它们是用于创建容器的模板。它们包含关于底层操作系统、环境和库的信息，以及版本。</p><h2 id="345b" class="ow of it bd og ox oy dn ok oz pa dp oo ky pb pc oq la pd pe os lc pf pg ou iz bi translated">我们如何创建 Docker 图像？</h2><p id="82ec" class="pw-post-body-paragraph ls lt it kt b ku ph kd lv kw pi kg lw ky pj lz ma la pk md me lc pl mh mi le im bi translated">通过阅读来自<strong class="kt jd">档案的指令。</strong>它是一组用户可以在命令行上调用来创建图像的指令和命令。你可以用<code class="fe nt nu nv nw b">docker build Dockerfile -t &lt;image_name&gt;</code>命令在你的系统中创建一个本地镜像。</p><h2 id="9fe8" class="ow of it bd og ox oy dn ok oz pa dp oo ky pb pc oq la pd pe os lc pf pg ou iz bi translated">图像和容器是如何连接的？</h2><p id="0f08" class="pw-post-body-paragraph ls lt it kt b ku ph kd lv kw pi kg lw ky pj lz ma la pk md me lc pl mh mi le im bi translated"><strong class="kt jd">容器</strong>是<strong class="kt jd">图像</strong>的运行实例。运行映像时，您会创建一个容器，它是一个隔离的环境。</p><h2 id="aeed" class="ow of it bd og ox oy dn ok oz pa dp oo ky pb pc oq la pd pe os lc pf pg ou iz bi translated">我们是如何使用 Docker 构建葡萄酒评级预测器的？</h2><p id="74ac" class="pw-post-body-paragraph ls lt it kt b ku ph kd lv kw pi kg lw ky pj lz ma la pk md me lc pl mh mi le im bi translated">我们使用 Docker 构建虚拟环境并管理库的依赖关系，这样我们就可以无缝地运行流程。下面的<strong class="kt jd"> <em class="lu">自动化流程</em> </strong>被设计成每个盒子在一个单独的 Docker 容器上运行。</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi qb"><img src="../Images/ea84977b3ecb9830027bc946cc419ddd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZlHk1OXN0FbgLVS_mkFK8A.png"/></div></div><p class="mv mw gj gh gi mx my bd b be z dk translated">自动化流程</p></figure><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div class="gh gi qc"><img src="../Images/1fb02bcdb224b7f515a5857a6cc392d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:518/format:webp/1*lzKdcXxKa9afsGrSeH4d4A.png"/></div><p class="mv mw gj gh gi mx my bd b be z dk translated">葡萄酒等级预测库的结构</p></figure><p id="0725" class="pw-post-body-paragraph ls lt it kt b ku kv kd lv kw kx kg lw ky ly lz ma la mc md me lc mg mh mi le im bi translated">我相信你已经注意到了存储库中一些我们还没有提到的目录和文件。您可以将<code class="fe nt nu nv nw b">download_data</code>、<code class="fe nt nu nv nw b">make_dataset</code>、<code class="fe nt nu nv nw b">clean_data</code>、<code class="fe nt nu nv nw b">extract_features</code>、<code class="fe nt nu nv nw b">transform_data</code>、<code class="fe nt nu nv nw b">impute_data</code>、<code class="fe nt nu nv nw b">train_model</code>和<code class="fe nt nu nv nw b">evaluate_model</code>目录视为自动化流程中盒子的边界，该流程包含 docker 文件和 Python 文件形式的源代码。</p><p id="b2ab" class="pw-post-body-paragraph ls lt it kt b ku kv kd lv kw kx kg lw ky ly lz ma la mc md me lc mg mh mi le im bi translated">在看如何创建 Dockerfile 之前，我们先来了解一下<code class="fe nt nu nv nw b">base_docker</code>在这里的用法。</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi qd"><img src="../Images/53849d7d1685348a4ffa491abb4c0ac9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Whjy6xKUEhCTc2c8_XdEZw.png"/></div></div><p class="mv mw gj gh gi mx my bd b be z dk translated">在自动化流程中使用基本 Docker</p></figure><p id="7660" class="pw-post-body-paragraph ls lt it kt b ku kv kd lv kw kx kg lw ky ly lz ma la mc md me lc mg mh mi le im bi translated">自动化流程的每一步都在一个单独的容器上运行。然而，它们是用 Python 编写的模块，它们之间唯一的区别是使用的库。因此，<code class="fe nt nu nv nw b">base_docker</code>用于指定公共环境变量并安装所需的 Python 版本和库。它也有助于葡萄酒评级预测器的性能，只需安装一次所需的软件包，而不是每次都安装在单独的容器上。</p><h2 id="38f9" class="ow of it bd og ox oy dn ok oz pa dp oo ky pb pc oq la pd pe os lc pf pg ou iz bi translated">如何写 Dockerfile 文件</h2><p id="e7b9" class="pw-post-body-paragraph ls lt it kt b ku ph kd lv kw pi kg lw ky pj lz ma la pk md me lc pl mh mi le im bi translated">当创建 docker 文件时，就像在您的机器上创建本地环境一样开始执行这些步骤。考虑到您的目标是使用 Python 部署 ML 解决方案，您可以在<a class="ae lj" href="https://hub.docker.com/search?q=python&amp;type=image" rel="noopener ugc nofollow" target="_blank"> Docker Hub </a>中的现有 Python 映像之上构建您的映像。这里很重要的一点是<a class="ae lj" href="https://pythonspeed.com/articles/base-image-python-docker-images/" rel="noopener ugc nofollow" target="_blank">选择一个适合你情况的现有 Python 图像</a>，因为有几个版本和大小可供选择。</p><pre class="mk ml mm mn gt qe nw qf qg aw qh bi"><span id="ad24" class="ow of it nw b gy qi qj l qk ql">FROM python:3.7-slim<br/>ENV LC_ALL=C.UTF-8<br/>ENV LANG=C.UTF-8<br/>ENV PYTHONPATH=/opt/orchestrator:$PYTHONPATH<br/><br/>COPY requirements.txt /opt/base_docker/<br/><br/>RUN pip install -r /opt/base_docker/requirements.txt<br/><br/>WORKDIR /opt/base_docker/</span></pre><p id="e149" class="pw-post-body-paragraph ls lt it kt b ku kv kd lv kw kx kg lw ky ly lz ma la mc md me lc mg mh mi le im bi translated">选择了<code class="fe nt nu nv nw b">slim</code>变量，并指定了 Python 版本<code class="fe nt nu nv nw b">3.7</code>，与我的本地系统中的 Python 版本相同。</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div class="gh gi qm"><img src="../Images/a7957b27926ddd29ad09b737c6fa3e0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:494/format:webp/1*14g_Rfl9QDA0pHNb479dWA.png"/></div><p class="mv mw gj gh gi mx my bd b be z dk translated">requirements.txt 截图</p></figure><p id="9c92" class="pw-post-body-paragraph ls lt it kt b ku kv kd lv kw kx kg lw ky ly lz ma la mc md me lc mg mh mi le im bi translated"><code class="fe nt nu nv nw b">ENV</code>命令用于更新容器安装的底层操作系统的<code class="fe nt nu nv nw b">PATH</code>环境变量(对于我们的例子是<code class="fe nt nu nv nw b">Python 3.7-slim</code>)。</p><p id="1c16" class="pw-post-body-paragraph ls lt it kt b ku kv kd lv kw kx kg lw ky ly lz ma la mc md me lc mg mh mi le im bi translated">带有<code class="fe nt nu nv nw b">requirements.txt</code>中提到的版本的库被复制并与<code class="fe nt nu nv nw b">pip_install</code>一起安装。除了前面提到的 Python 库之外，还安装了<code class="fe nt nu nv nw b">click</code>——稍后将详细介绍它的用法。</p><p id="fcc2" class="pw-post-body-paragraph ls lt it kt b ku kv kd lv kw kx kg lw ky ly lz ma la mc md me lc mg mh mi le im bi translated">作为最后一条指令，Docker 容器的工作目录用<code class="fe nt nu nv nw b">WORKDIR</code> <strong class="kt jd"> </strong>命令定义。</p><p id="6560" class="pw-post-body-paragraph ls lt it kt b ku kv kd lv kw kx kg lw ky ly lz ma la mc md me lc mg mh mi le im bi translated">现在，我们的<code class="fe nt nu nv nw b">base_docker</code>已经准备好了，从自动化流程中探索任何<strong class="kt jd">docker 文件</strong>就足够了，因为所有其他<strong class="kt jd">docker 文件</strong>都是用相同的逻辑编写的。这里有一个来自<code class="fe nt nu nv nw b">clean_data</code>的例子:</p><pre class="mk ml mm mn gt qe nw qf qg aw qh bi"><span id="fc61" class="ow of it nw b gy qi qj l qk ql">FROM code-challenge/base-docker</span><span id="199a" class="ow of it nw b gy qn qj l qk ql">COPY . /opt/clean_data/<br/><br/>WORKDIR /opt/clean_data/</span></pre><p id="23ef" class="pw-post-body-paragraph ls lt it kt b ku kv kd lv kw kx kg lw ky ly lz ma la mc md me lc mg mh mi le im bi translated">现在我们的基地形象变成了<code class="fe nt nu nv nw b">base_docker</code>。复制<code class="fe nt nu nv nw b">clean_data</code>目录中的每个文件，并创建 Docker 容器的工作目录。</p><p id="8ea1" class="pw-post-body-paragraph ls lt it kt b ku kv kd lv kw kx kg lw ky ly lz ma la mc md me lc mg mh mi le im bi translated">是时候看看 Spotify 心爱的 Luigi 了！</p><h1 id="b6af" class="oe of it bd og oh qo oj ok ol qp on oo ki qq kj oq kl qr km os ko qs kp ou ov bi translated">2.什么是 Luigi，为什么选择它作为编排工具？</h1><h2 id="29e4" class="ow of it bd og ox oy dn ok oz pa dp oo ky pb pc oq la pd pe os lc pf pg ou iz bi translated">什么是路易吉？</h2><p id="c26d" class="pw-post-body-paragraph ls lt it kt b ku ph kd lv kw pi kg lw ky pj lz ma la pk md me lc pl mh mi le im bi translated"><a class="ae lj" href="https://luigi.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank">来自文件</a>的官方定义如下:</p><blockquote class="pm"><p id="5510" class="pn po it bd pp pq pr ps pt pu pv le dk translated">Luigi 是一个 Python 包，可以帮助您构建批处理作业的复杂管道。它处理依赖关系解析、工作流管理、可视化、处理故障、命令行集成等等。</p></blockquote><p id="2c03" class="pw-post-body-paragraph ls lt it kt b ku pw kd lv kw px kg lw ky py lz ma la pz md me lc qa mh mi le im bi translated">它基本上是一个编排工具，将许多任务缝合在一个有向无环图(DAG)结构中:</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi qt"><img src="../Images/4ea64fe3b78a4cb02516da80bdd1859a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HUmxmPt13dIis6FpV4I9UA.png"/></div></div><p class="mv mw gj gh gi mx my bd b be z dk translated">有向无环图示例。图片来源:<a class="ae lj" href="https://en.wikipedia.org/wiki/Directed_acyclic_graph" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></figure><h2 id="cfd6" class="ow of it bd og ox oy dn ok oz pa dp oo ky pb pc oq la pd pe os lc pf pg ou iz bi translated">为什么选择它作为编排工具？</h2><p id="d637" class="pw-post-body-paragraph ls lt it kt b ku ph kd lv kw pi kg lw ky pj lz ma la pk md me lc pl mh mi le im bi translated">当你构建一个 ML 解决方案，随着规模的增长，这很容易变得复杂和混乱。Luigi 是一个健壮的工作流管理工具，可以防止混乱和复杂。</p><h2 id="2ba3" class="ow of it bd og ox oy dn ok oz pa dp oo ky pb pc oq la pd pe os lc pf pg ou iz bi translated">Luigi 如何作为一个编排工具工作？</h2><p id="84e8" class="pw-post-body-paragraph ls lt it kt b ku ph kd lv kw pi kg lw ky pj lz ma la pk md me lc pl mh mi le im bi translated">Luigi 有两个基本构件:<strong class="kt jd">任务</strong>和<strong class="kt jd">目标</strong></p><h2 id="9d21" class="ow of it bd og ox oy dn ok oz pa dp oo ky pb pc oq la pd pe os lc pf pg ou iz bi translated">什么是 Luigi 任务？</h2><p id="2e74" class="pw-post-body-paragraph ls lt it kt b ku ph kd lv kw pi kg lw ky pj lz ma la pk md me lc pl mh mi le im bi translated">工作流的步骤是<strong class="kt jd">任务</strong>，通常是一个单独的工作单元，在这里完成计算。Luigi 工作流建立在任务之上。</p><h2 id="37dd" class="ow of it bd og ox oy dn ok oz pa dp oo ky pb pc oq la pd pe os lc pf pg ou iz bi translated">Luigi 任务是如何连接的？</h2><p id="48b9" class="pw-post-body-paragraph ls lt it kt b ku ph kd lv kw pi kg lw ky pj lz ma la pk md me lc pl mh mi le im bi translated">每个任务都与一个<strong class="kt jd">目标</strong>相关联。目标可以是文件、工作流中的检查点或任务生成的任何类型的<strong class="kt jd">输出</strong>。</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi qu"><img src="../Images/d41ef29492676204ff47aa9c83229a89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OUDR5RXdYLw-DkPEij5PFw.png"/></div></div><p class="mv mw gj gh gi mx my bd b be z dk translated">自动化流程中的每一步都是一项任务</p></figure><p id="275a" class="pw-post-body-paragraph ls lt it kt b ku kv kd lv kw kx kg lw ky ly lz ma la mc md me lc mg mh mi le im bi translated">我们正在转储<code class="fe nt nu nv nw b">data_root</code>中每个任务生成的输出:</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div class="gh gi qv"><img src="../Images/b52a79c2d1352123cd12deef322da78e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/1*rgrsyLclaLcT-Ofxkl-tLw.png"/></div></figure><p id="444b" class="pw-post-body-paragraph ls lt it kt b ku kv kd lv kw kx kg lw ky ly lz ma la mc md me lc mg mh mi le im bi translated">在流程中，除了初始任务<code class="fe nt nu nv nw b">download_data</code>之外，每个任务都依赖于前一个任务的输出。每个文件都作为一个<code class="fe nt nu nv nw b">Parameter</code>传递，这样它就可以被工作流中的后续步骤使用。</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi qw"><img src="../Images/8fb4730ac1181c7ba8092fe8e6b69b7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CEkllcpG7DquH2bcUg0RjQ.png"/></div></div><p class="mv mw gj gh gi mx my bd b be z dk translated">每个任务产生的输出</p></figure><p id="4a4a" class="pw-post-body-paragraph ls lt it kt b ku kv kd lv kw kx kg lw ky ly lz ma la mc md me lc mg mh mi le im bi translated">在设计工作流时，Luigi 推荐原子结构:每个任务应该有一个单独的文件作为输出，就像在<code class="fe nt nu nv nw b">download_data</code>和<code class="fe nt nu nv nw b">train_model</code>任务中一样。</p><p id="a47a" class="pw-post-body-paragraph ls lt it kt b ku kv kd lv kw kx kg lw ky ly lz ma la mc md me lc mg mh mi le im bi translated">对于其余的任务，我们用<code class="fe nt nu nv nw b">SUCCESS</code>旗模拟原子性。当我们在训练和测试数据集上执行计算时，在将输出文件转储到目录中之后，我们创建一个<code class="fe nt nu nv nw b">SUCCESS</code>标志作为任务的输出。这样，下一个任务只检查是否存在一个<code class="fe nt nu nv nw b">SUCCESS</code>标志。</p><h2 id="7cbf" class="ow of it bd og ox oy dn ok oz pa dp oo ky pb pc oq la pd pe os lc pf pg ou iz bi translated">我们如何定义任务依赖关系？</h2><p id="23c9" class="pw-post-body-paragraph ls lt it kt b ku ph kd lv kw pi kg lw ky pj lz ma la pk md me lc pl mh mi le im bi translated">任务依赖是用<code class="fe nt nu nv nw b">requires()</code>方法定义的。以下是 Luigi 文档中的任务概要:</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi qx"><img src="../Images/5204170ef6951b4e985717e98f840b18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aa_MewYezE4w_A850Osxrw.png"/></div></div><p class="mv mw gj gh gi mx my bd b be z dk translated">Luigi 任务的概要。图片来源:<a class="ae lj" href="https://luigi.readthedocs.io/en/stable/tasks.html" rel="noopener ugc nofollow" target="_blank"> luigi.readthedocs.io </a></p></figure><p id="5ec9" class="pw-post-body-paragraph ls lt it kt b ku kv kd lv kw kx kg lw ky ly lz ma la mc md me lc mg mh mi le im bi translated">对于我们的例子，任务依赖是显而易见的，因为我们定义了一个线性的自动化流程。</p><h2 id="bb9a" class="ow of it bd og ox oy dn ok oz pa dp oo ky pb pc oq la pd pe os lc pf pg ou iz bi translated">我们如何运行 Luigi 工作流？</h2><p id="6659" class="pw-post-body-paragraph ls lt it kt b ku ph kd lv kw pi kg lw ky pj lz ma la pk md me lc pl mh mi le im bi translated">不幸的是，Luigi 没有触发机制。如果要运行 Luigi 工作流，可以使用命令行指定模块名称和项目目录中的最后一项任务:</p><pre class="mk ml mm mn gt qe nw qf qg aw qh bi"><span id="6439" class="ow of it nw b gy qi qj l qk ql">luigi --module &lt;modul_name&gt; &lt;task_name&gt; </span></pre><p id="fa2c" class="pw-post-body-paragraph ls lt it kt b ku kv kd lv kw kx kg lw ky ly lz ma la mc md me lc mg mh mi le im bi translated">当工作流被触发时，Luigi 检查上一步的输出是否存在。如果没有，那么它向后检查前一步骤的输出是否存在。对于我们的例子，这将是<code class="fe nt nu nv nw b">train_model</code>、<code class="fe nt nu nv nw b">impute_data</code>、<code class="fe nt nu nv nw b">transform_data</code>、<code class="fe nt nu nv nw b">extract_features</code>、<code class="fe nt nu nv nw b">clean_data</code>、<code class="fe nt nu nv nw b">make_dataset</code>和<code class="fe nt nu nv nw b">download_data</code>。</p><p id="4943" class="pw-post-body-paragraph ls lt it kt b ku kv kd lv kw kx kg lw ky ly lz ma la mc md me lc mg mh mi le im bi translated">如果来自流程中任何一步的任务输出存在，Luigi 将从它离开的地方继续流程。这是一个非常有用和重要的特性，可以防止 ML 管道在包含部分数据时崩溃。</p><p id="c4af" class="pw-post-body-paragraph ls lt it kt b ku kv kd lv kw kx kg lw ky ly lz ma la mc md me lc mg mh mi le im bi translated">现在我们知道了 Luigi 和 Docker 的基本元素，我们可以继续完成这幅画了！</p><h1 id="4bbf" class="oe of it bd og oh qo oj ok ol qp on oo ki qq kj oq kl qr km os ko qs kp ou ov bi translated">3.把 Docker 和 Luigi 的碎片放在一起</h1><p id="b10c" class="pw-post-body-paragraph ls lt it kt b ku ph kd lv kw pi kg lw ky pj lz ma la pk md me lc pl mh mi le im bi translated">我们将把 Docker 和 Luigi 的片段放在<code class="fe nt nu nv nw b">docker-compose.yml</code>和<code class="fe nt nu nv nw b">orchestrator</code>目录中。</p><p id="f4e1" class="pw-post-body-paragraph ls lt it kt b ku kv kd lv kw kx kg lw ky ly lz ma la mc md me lc mg mh mi le im bi translated">由<a class="ae lj" href="https://www.datarevenue.com/en-our-team#the-team" rel="noopener ugc nofollow" target="_blank">数据收入的令人敬畏的工程师</a>提供的效用函数已经使我能够连接 Docker 和 Luigi 的片断。<code class="fe nt nu nv nw b">util.py</code>中可用的函数和类在连接 Docker 和 Luigi 的葡萄酒评级预测器中发挥了重要作用。例如，<code class="fe nt nu nv nw b">DockerTask </code> —我们作为参数在任务之间传递的对象— <a class="ae lj" href="https://luigi.readthedocs.io/en/stable/parameters.html" rel="noopener ugc nofollow" target="_blank">通常在 Luigi </a>中不能作为参数使用。</p><p id="d459" class="pw-post-body-paragraph ls lt it kt b ku kv kd lv kw kx kg lw ky ly lz ma la mc md me lc mg mh mi le im bi translated">首先，让我们看看<code class="fe nt nu nv nw b">orchestrator</code>目录中的<code class="fe nt nu nv nw b">task.py</code>，在那里我使用实用程序构建了自动化流程。那么，让我们来理解一下<code class="fe nt nu nv nw b">docker-compose.yml</code>的目的。</p><h2 id="892b" class="ow of it bd og ox oy dn ok oz pa dp oo ky pb pc oq la pd pe os lc pf pg ou iz bi translated">在 Task.py 中定义任务</h2><figure class="mk ml mm mn gt mo"><div class="bz fp l di"><div class="qy qz l"/></div></figure><ul class=""><li id="77aa" class="kr ks it kt b ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated"><strong class="kt jd"> Luigi 参数:</strong>每个任务都以一个 Luigi <code class="fe nt nu nv nw b">Parameter</code>对象开始，我们在其中指定任务的输入/输出文件和目录。例如，我们使用测试集评估 ML 模型的最后一个任务<code class="fe nt nu nv nw b">EvaluateModel</code>将<code class="fe nt nu nv nw b">test_features</code>、<code class="fe nt nu nv nw b">test_target</code>和经过训练的模型文件(<code class="fe nt nu nv nw b">model.sav</code>)作为输入 Luigi <code class="fe nt nu nv nw b">Parameter</code>。由于这个任务创建了多个文件作为输出(<code class="fe nt nu nv nw b">PredictionsVSActuals.png</code>和<code class="fe nt nu nv nw b">FeatureImportances.png</code>)，我们还定义了一个<code class="fe nt nu nv nw b">SUCCESS</code>标志来模拟原子性。</li><li id="efbc" class="kr ks it kt b ku lk kw ll ky lm la ln lc lo le lf lg lh li bi translated"><strong class="kt jd"> Image: </strong>我们定义使用哪个 Docker 图像来创建容器。</li><li id="2ebf" class="kr ks it kt b ku lk kw ll ky lm la ln lc lo le lf lg lh li bi translated"><strong class="kt jd">依赖任务:</strong>如果有依赖任务，在这里用<code class="fe nt nu nv nw b">requires()</code>方法定义。<code class="fe nt nu nv nw b">EvaluateModel</code>的从属任务是<code class="fe nt nu nv nw b">TrainModel</code>。</li><li id="b4a4" class="kr ks it kt b ku lk kw ll ky lm la ln lc lo le lf lg lh li bi translated"><strong class="kt jd">命令:</strong>容器要执行的命令。此处命令用相关参数调用<code class="fe nt nu nv nw b">evaluate_model.py</code>中可用的源代码。</li><li id="4b78" class="kr ks it kt b ku lk kw ll ky lm la ln lc lo le lf lg lh li bi translated"><strong class="kt jd">输出:</strong><code class="fe nt nu nv nw b">output()</code>方法返回一个或多个目标对象(输出文件或<code class="fe nt nu nv nw b">SUCCESS</code>标志)</li></ul><p id="5c8c" class="pw-post-body-paragraph ls lt it kt b ku kv kd lv kw kx kg lw ky ly lz ma la mc md me lc mg mh mi le im bi translated">回想一下，流程中每一步的源代码都以 Python 文件的形式存在于各自的目录中。我们来看看<code class="fe nt nu nv nw b">train_model</code>的源代码:</p><figure class="mk ml mm mn gt mo"><div class="bz fp l di"><div class="qy qz l"/></div></figure><p id="722a" class="pw-post-body-paragraph ls lt it kt b ku kv kd lv kw kx kg lw ky ly lz ma la mc md me lc mg mh mi le im bi translated">在定义了助手函数<code class="fe nt nu nv nw b">convert_features_to_array</code>和<code class="fe nt nu nv nw b">convert_target_to_array</code>之后，我们定义了必要的点击命令。</p><p id="c31d" class="pw-post-body-paragraph ls lt it kt b ku kv kd lv kw kx kg lw ky ly lz ma la mc md me lc mg mh mi le im bi translated"><a class="ae lj" href="https://click.palletsprojects.com/en/7.x/" rel="noopener ugc nofollow" target="_blank">点击</a>，如官方文件中所定义:</p><blockquote class="pm"><p id="82ef" class="pn po it bd pp pq pr ps pt pu pv le dk translated">这是一个 Python 包，用于以可组合的方式用尽可能少的代码创建漂亮的命令行界面。</p></blockquote><figure class="rb rc rd re rf mo gh gi paragraph-image"><div class="gh gi ra"><img src="../Images/411aa64733ac5cd67664c933e8d6989d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/format:webp/1*QlGYXY1JI8IuYQWet4yi3g.png"/></div><p class="mv mw gj gh gi mx my bd b be z dk translated">如何使用点击命令。图片来源:<a class="ae lj" href="https://click.palletsprojects.com/en/7.x/" rel="noopener ugc nofollow" target="_blank">click.palletsprojects.com</a></p></figure><p id="7afc" class="pw-post-body-paragraph ls lt it kt b ku kv kd lv kw kx kg lw ky ly lz ma la mc md me lc mg mh mi le im bi translated">我们使用 Click 从命令行向 python 脚本传递参数。最后，我们使用我们在训练数据集上的<strong class="kt jd"> <em class="lu">对所选模型步骤</em> </strong>执行超参数调整中决定的微调参数来训练模型。最后，我们将训练好的模型保存在<code class="fe nt nu nv nw b">model.sav</code>文件中作为输出。</p><h2 id="5144" class="ow of it bd og ox oy dn ok oz pa dp oo ky pb pc oq la pd pe os lc pf pg ou iz bi translated">Docker 编写器的使用</h2><p id="2f61" class="pw-post-body-paragraph ls lt it kt b ku ph kd lv kw pi kg lw ky pj lz ma la pk md me lc pl mh mi le im bi translated"><a class="ae lj" href="https://docs.docker.com/compose/" rel="noopener ugc nofollow" target="_blank">根据 Docker 文档</a>编写 Docker 的官方定义如下:</p><blockquote class="pm"><p id="8b65" class="pn po it bd pp pq pr ps pt pu pv le dk translated">Compose 是一个定义和运行多容器 Docker 应用程序的工具。使用 Compose，<a class="ae lj" rel="noopener" target="_blank" href="/5-reasons-to-use-yaml-files-in-your-machine-learning-projects-d4c7b9650f27">您可以使用一个 YAML 文件</a>来配置您的应用程序的服务。然后，只需一个命令，您就可以从您的配置中创建并启动所有服务。</p></blockquote><p id="fcf4" class="pw-post-body-paragraph ls lt it kt b ku pw kd lv kw px kg lw ky py lz ma la pz md me lc qa mh mi le im bi translated">这个定义适合我们的情况，因为我们在包括<code class="fe nt nu nv nw b">base_docker</code>在内的 9 个容器上运行自动化流程。你可以在这里阅读更多关于<code class="fe nt nu nv nw b">docker-compose</code>T20 的用法和命令。</p><p id="a61c" class="pw-post-body-paragraph ls lt it kt b ku kv kd lv kw kx kg lw ky ly lz ma la mc md me lc mg mh mi le im bi translated">这里对我们来说重要的部分运行 Luigi 任务的命令写在这里，所以当我们通过<code class="fe nt nu nv nw b">docker-compose</code>运行容器时，它将通过<code class="fe nt nu nv nw b">luigi — module task EvaluateModel-scheduler-host luigiid</code>命令触发自动化流程。</p><figure class="mk ml mm mn gt mo"><div class="bz fp l di"><div class="qy qz l"/></div></figure><h1 id="8609" class="oe of it bd og oh qo oj ok ol qp on oo ki qq kj oq kl qr km os ko qs kp ou ov bi translated">4.运行和自动化管道！</h1><p id="5ead" class="pw-post-body-paragraph ls lt it kt b ku ph kd lv kw pi kg lw ky pj lz ma la pk md me lc pl mh mi le im bi translated">这是关键时刻！我们将运行自动化流程，并自动化 9 步 ML 管道。这是最后一步，再坚持一分钟😉</p><h2 id="566f" class="ow of it bd og ox oy dn ok oz pa dp oo ky pb pc oq la pd pe os lc pf pg ou iz bi translated"><strong class="ak"> 1。打开您的终端并导航到项目目录</strong></h2><p id="9765" class="pw-post-body-paragraph ls lt it kt b ku ph kd lv kw pi kg lw ky pj lz ma la pk md me lc pl mh mi le im bi translated">对我来说这是:</p><pre class="mk ml mm mn gt qe nw qf qg aw qh bi"><span id="edb4" class="ow of it nw b gy qi qj l qk ql">cd GitHub/Wine-Rating-Predictor-ML-Model</span></pre><h2 id="fc4f" class="ow of it bd og ox oy dn ok oz pa dp oo ky pb pc oq la pd pe os lc pf pg ou iz bi translated">2.构建 Docker 容器</h2><p id="322f" class="pw-post-body-paragraph ls lt it kt b ku ph kd lv kw pi kg lw ky pj lz ma la pk md me lc pl mh mi le im bi translated">我们将使用一个 shell 脚本来构建 Docker 容器<code class="fe nt nu nv nw b">build-task-images.sh</code>，而不是一个接一个地构建多个 Docker 容器</p><figure class="mk ml mm mn gt mo"><div class="bz fp l di"><div class="qy qz l"/></div></figure><pre class="mk ml mm mn gt qe nw qf qg aw qh bi"><span id="5da3" class="ow of it nw b gy qi qj l qk ql">./build-task-images.sh 0.1</span></pre><p id="9f67" class="pw-post-body-paragraph ls lt it kt b ku kv kd lv kw kx kg lw ky ly lz ma la mc md me lc mg mh mi le im bi translated">下面的消息显示容器构建成功。因此，我们可以触发自动化流程了。</p><pre class="mk ml mm mn gt qe nw qf qg aw qh bi"><span id="ffb1" class="ow of it nw b gy qi qj l qk ql"><strong class="nw jd">Successfully tagged code-challenge/evaluate-model:0.1</strong></span></pre><h2 id="7ac9" class="ow of it bd og ox oy dn ok oz pa dp oo ky pb pc oq la pd pe os lc pf pg ou iz bi translated">4.从 Docker 编写触发自动化流程:</h2><p id="29fc" class="pw-post-body-paragraph ls lt it kt b ku ph kd lv kw pi kg lw ky pj lz ma la pk md me lc pl mh mi le im bi translated">我们将通过以下方式触发工作流</p><pre class="mk ml mm mn gt qe nw qf qg aw qh bi"><span id="13ea" class="ow of it nw b gy qi qj l qk ql">docker-compose up orchestrator</span></pre><p id="554c" class="pw-post-body-paragraph ls lt it kt b ku kv kd lv kw kx kg lw ky ly lz ma la mc md me lc mg mh mi le im bi translated">在写这个命令时，Luigi 检查每个任务是否完成，并输出以下信息:</p><pre class="mk ml mm mn gt qe nw qf qg aw qh bi"><span id="ea91" class="ow of it nw b gy qi qj l qk ql"><strong class="nw jd">Checking if EvaluateModel(<br/>    no_remove_finished=False,<br/>    in_test_features_csv=/usr/share/data/interim/test_features.csv,<br/>    in_test_target_csv=/usr/share/data/interim/test_target.csv,<br/>    in_trained_model=/usr/share/data/output/model.sav,<br/>    out_dir=/usr/share/data/output/, <br/>    flag=.SUCCESS_EvaluateModel)</strong> <strong class="nw jd">is complete</strong></span><span id="bc8f" class="ow of it nw b gy qn qj l qk ql"><strong class="nw jd">Checking if TrainModel(<br/>   no_remove_finished=False,<br/>   in_train_features_csv=/usr/share/data/interim/train_features.csv,<br/>   in_train_target_csv=/usr/share/data/interim/train_target.csv,<br/>   out_dir=/usr/share/data/output/)</strong> <strong class="nw jd">is complete</strong></span><span id="9e3d" class="ow of it nw b gy qn qj l qk ql"><strong class="nw jd">Checking if ImputeData(<br/>    no_remove_finished=False,<br/>    in_train_csv=/usr/share/data/interim/train_transformed.csv,<br/>    in_test_csv=/usr/share/data/interim/test_transformed.csv,<br/>    out_dir=/usr/share/data/interim/, <br/>    flag=.SUCCESS_ImputeData)</strong> <strong class="nw jd">is complete</strong></span><span id="e597" class="ow of it nw b gy qn qj l qk ql"><strong class="nw jd">Checking if TransformData( <br/>  no_remove_finished=False,<br/>  in_train_csv=/usr/share/data/interim/train_features_extracted.csv,<br/>  in_test_csv=/usr/share/data/interim/test_features_extracted.csv,<br/>  out_dir=/usr/share/data/interim/, <br/>  flag=.SUCCESS_TransformData)</strong> <strong class="nw jd">is complete</strong></span><span id="22a2" class="ow of it nw b gy qn qj l qk ql"><strong class="nw jd">Checking if ExtractFeatures(<br/>    no_remove_finished=False,<br/>    in_train_csv=/usr/share/data/interim/train_cleaned.csv,<br/>    in_test_csv=/usr/share/data/interim/test_cleaned.csv,<br/>    out_dir=/usr/share/data/interim/, <br/>    flag=.SUCCESS_ExtractFeatures)</strong> <strong class="nw jd">is complete</strong></span><span id="eb5e" class="ow of it nw b gy qn qj l qk ql"><strong class="nw jd">Checking if CleanData(<br/>    no_remove_finished=False,<br/>    in_train_csv=/usr/share/data/interim/train.csv,<br/>    in_test_csv=/usr/share/data/interim/test.csv,<br/>    out_dir=/usr/share/data/interim/, <br/>    flag=.SUCCESS_CleanData)</strong> <strong class="nw jd">is complete</strong></span><span id="a326" class="ow of it nw b gy qn qj l qk ql"><strong class="nw jd">Checking if MakeDatasets(<br/>    no_remove_finished=False,<br/>    in_csv=/usr/share/data/raw/wine_dataset.csv,<br/>    out_dir=/usr/share/data/interim/, <br/>    flag=.SUCCESS_MakeDatasets)</strong> <strong class="nw jd">is complete</strong></span><span id="4034" class="ow of it nw b gy qn qj l qk ql"><strong class="nw jd">Checking if DownloadData(<br/>    no_remove_finished=False, <br/>    fname=wine_dataset, <br/>    out_dir=/usr/share/data/raw/,<br/>    url=</strong><a class="ae lj" href="https://github.com/datarevenue-berlin/code-challenge-2019/releases/download/0.1.0/dataset_sampled.csv" rel="noopener ugc nofollow" target="_blank"><strong class="nw jd">https://github.com/datarevenue-berlin/code-challenge-2019/releases/download/0.1.0/dataset_sampled.csv</strong></a><strong class="nw jd">)</strong> <strong class="nw jd">is complete</strong></span></pre><p id="4e44" class="pw-post-body-paragraph ls lt it kt b ku kv kd lv kw kx kg lw ky ly lz ma la mc md me lc mg mh mi le im bi translated">然后一个接一个地运行任务。对我们来说另一个重要的信息是:</p><pre class="mk ml mm mn gt qe nw qf qg aw qh bi"><span id="2b70" class="ow of it nw b gy qi qj l qk ql"><strong class="nw jd">INFO:evaluate-model:Mean square error of the model is: 4.95</strong></span></pre><p id="7c8a" class="pw-post-body-paragraph ls lt it kt b ku kv kd lv kw kx kg lw ky ly lz ma la mc md me lc mg mh mi le im bi translated">成功运行后，您会看到一个🙂：</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi rg"><img src="../Images/322a31e41403b74346653b0f9639d7f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kXY_3oen8Zo5Tz4oOcaFdw.png"/></div></div></figure><p id="2c08" class="pw-post-body-paragraph ls lt it kt b ku kv kd lv kw kx kg lw ky ly lz ma la mc md me lc mg mh mi le im bi translated"><strong class="kt jd">奖励点:让我们看看 Luigi 是如何从</strong> <br/>的流程中恢复的。假设您准备了训练数据集并运行了自动化流程，然后您将从训练模型开始构建接下来的步骤。Luigi 不会重复成功运行之前的步骤，在这种情况下只会运行<code class="fe nt nu nv nw b">TrainModel</code>和<code class="fe nt nu nv nw b">EvaluateModel</code>任务。</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi rg"><img src="../Images/c7c6f252145371fc4b2862409c960f6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lN0sTaafGid7ArzUSi2rMw.png"/></div></div></figure><h1 id="abfa" class="oe of it bd og oh qo oj ok ol qp on oo ki qq kj oq kl qr km os ko qs kp ou ov bi translated">结论</h1><p id="c634" class="pw-post-body-paragraph ls lt it kt b ku ph kd lv kw pi kg lw ky pj lz ma la pk md me lc pl mh mi le im bi translated">我会说哇！</p><p id="7a35" class="pw-post-body-paragraph ls lt it kt b ku kv kd lv kw kx kg lw ky ly lz ma la mc md me lc mg mh mi le im bi translated">这是一个跨越 4 篇文章和一个月⛵️的旅程</p><p id="567b" class="pw-post-body-paragraph ls lt it kt b ku kv kd lv kw kx kg lw ky ly lz ma la mc md me lc mg mh mi le im bi translated">我们从头开始，通过第一、第二和第三篇文章分析了 9 步 ML 管道的每一步。</p><div class="nb nc gp gr nd ne"><a rel="noopener follow" target="_blank" href="/building-an-automated-machine-learning-pipeline-part-one-5c70ae682f35"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd jd gy z fp nj fr fs nk fu fw jc bi translated">构建自动化机器学习管道:第一部分</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">数据清理、探索性数据分析和特征工程步骤</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">towardsdatascience.com</p></div></div><div class="nn l"><div class="rh l np nq nr nn ns mt ne"/></div></div></a></div><div class="nb nc gp gr nd ne"><a rel="noopener follow" target="_blank" href="/building-an-automated-machine-learning-pipeline-part-two-1d3c86e6fe42"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd jd gy z fp nj fr fs nk fu fw jc bi translated">构建自动化机器学习管道:第二部分</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">设置评估指标&amp;建立基线、选择算法和执行超参数调整…</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">towardsdatascience.com</p></div></div><div class="nn l"><div class="ri l np nq nr nn ns mt ne"/></div></div></a></div><div class="nb nc gp gr nd ne"><a rel="noopener follow" target="_blank" href="/building-an-automated-machine-learning-pipeline-a74acda76b98"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd jd gy z fp nj fr fs nk fu fw jc bi translated">构建自动化机器学习管道</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">训练和评估模型，解释模型结果和最终结论</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">towardsdatascience.com</p></div></div><div class="nn l"><div class="rj l np nq nr nn ns mt ne"/></div></div></a></div><p id="2950" class="pw-post-body-paragraph ls lt it kt b ku kv kd lv kw kx kg lw ky ly lz ma la mc md me lc mg mh mi le im bi translated">在这最后一篇文章中，我们介绍了 Docker 和 Luigi 的相关元素，并解释了它们对于葡萄酒评级预测器的重要性和用途。我们完成了我们的综合管道的最后一个缺失部分，并对 ML 解决方案进行了试运行——就像它在生产系统上运行一样。</p><h2 id="b970" class="ow of it bd og ox oy dn ok oz pa dp oo ky pb pc oq la pd pe os lc pf pg ou iz bi translated">特别感谢</h2><p id="e21a" class="pw-post-body-paragraph ls lt it kt b ku ph kd lv kw pi kg lw ky pj lz ma la pk md me lc pl mh mi le im bi translated">我想是时候感谢我的另一半了。在我的数据科学探险中，他是我最宝贵的导师、编辑和学习伙伴！</p><p id="8112" class="pw-post-body-paragraph ls lt it kt b ku kv kd lv kw kx kg lw ky ly lz ma la mc md me lc mg mh mi le im bi translated">他帮助我克服了转行的起起落落。此外，我要感谢他对我完成这个系列文章的支持，以及他为我提供的勇气。谢谢你，亲爱的❤️</p></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><p id="5cf2" class="pw-post-body-paragraph ls lt it kt b ku kv kd lv kw kx kg lw ky ly lz ma la mc md me lc mg mh mi le im bi translated">感谢阅读🙂请随意使用这个管道、代码和<a class="ae lj" href="https://github.com/cereniyim/Wine-Rating-Predictor-ML-Model" rel="noopener ugc nofollow" target="_blank">库</a>用于你自己的项目。</p><p id="aa9f" class="pw-post-body-paragraph ls lt it kt b ku kv kd lv kw kx kg lw ky ly lz ma la mc md me lc mg mh mi le im bi translated">对于评论或建设性的反馈，您可以通过回复、<a class="ae lj" href="https://twitter.com/cereniyim" rel="noopener ugc nofollow" target="_blank"> Twitter </a>或<a class="ae lj" href="https://www.linkedin.com/in/ceren-iyim" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>联系我！</p><p id="5c29" class="pw-post-body-paragraph ls lt it kt b ku kv kd lv kw kx kg lw ky ly lz ma la mc md me lc mg mh mi le im bi translated">在我们走之前，我还想分享一些我用来准备这个项目的有用资源。下一篇文章再见👋</p><h2 id="95f4" class="ow of it bd og ox oy dn ok oz pa dp oo ky pb pc oq la pd pe os lc pf pg ou iz bi translated"><strong class="ak">了解 Docker 和 Luigi 更多信息的建议资源:</strong></h2><ul class=""><li id="d58f" class="kr ks it kt b ku ph kw pi ky rm la rn lc ro le lf lg lh li bi translated"><a class="ae lj" href="https://www.datarevenue.com/en-blog/how-to-scale-your-machine-learning-pipeline" rel="noopener ugc nofollow" target="_blank">通过<a class="ae lj" href="https://www.datarevenue.com/" rel="noopener ugc nofollow" target="_blank">数据收入</a>来扩展你的机器学习管道</a></li><li id="b877" class="kr ks it kt b ku lk kw ll ky lm la ln lc lo le lf lg lh li bi translated"><a class="ae lj" href="https://www.youtube.com/watch?v=zJ6WbK9zFpI&amp;t=659s" rel="noopener ugc nofollow" target="_blank">面向初学者的 Docker:由<a class="ae lj" href="https://www.youtube.com/channel/UCSWj8mqQCcrcBlXPi4ThRDQ" rel="noopener ugc nofollow" target="_blank">kode cloud</a>提供的完整课程</a></li><li id="d3e5" class="kr ks it kt b ku lk kw ll ky lm la ln lc lo le lf lg lh li bi translated"><a class="ae lj" rel="noopener" target="_blank" href="/build-a-docker-container-with-your-machine-learning-model-3cf906f5e07e">用你的机器学习模型</a>构建一个 Docker 容器<a class="rk rl ep" href="https://medium.com/u/e2511f99cdfc?source=post_page-----787cdc50a12d--------------------------------" rel="noopener" target="_blank"> Tina Bu </a></li><li id="3c03" class="kr ks it kt b ku lk kw ll ky lm la ln lc lo le lf lg lh li bi translated"><a class="ae lj" href="https://luigi.readthedocs.io/en/stable/index.html" rel="noopener ugc nofollow" target="_blank">路易吉文档</a></li><li id="ac3b" class="kr ks it kt b ku lk kw ll ky lm la ln lc lo le lf lg lh li bi translated"><a class="ae lj" href="https://docs.docker.com/get-started/" rel="noopener ugc nofollow" target="_blank"> Docker 文档</a></li><li id="a8fe" class="kr ks it kt b ku lk kw ll ky lm la ln lc lo le lf lg lh li bi translated"><a class="ae lj" href="https://intoli.com/blog/luigi-jupyter-notebooks/" rel="noopener ugc nofollow" target="_blank">用 Luigi 和 Jupyter 的笔记本构建数据科学管道</a>作者<a class="ae lj" href="https://mattiaciollaro.github.io/" rel="noopener ugc nofollow" target="_blank"> Mattia Ciollaro </a></li></ul></div></div>    
</body>
</html>