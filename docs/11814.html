<html>
<head>
<title>How to Build a Regression Model in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用 Python 构建回归模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-build-a-regression-model-in-python-9a10685c7f09?source=collection_archive---------3-----------------------#2020-08-16">https://towardsdatascience.com/how-to-build-a-regression-model-in-python-9a10685c7f09?source=collection_archive---------3-----------------------#2020-08-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/ba131f733aec6c76266630444631b716.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GuTe9FhXJSW7OFBqEXYDHw@2x.jpeg"/></div></div></figure><h2 id="d2e2" class="jc jd je bd b dl jf jg jh ji jj jk dk jl translated" aria-label="kicker paragraph">数据科学</h2><div class=""/><div class=""><h2 id="d1cf" class="pw-subtitle-paragraph kk jn je bd b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dk translated">详细直观的分步演练</h2></div></div><div class="ab cl lc ld hx le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="im in io ip iq"><p id="465e" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi mf translated"><span class="l mg mh mi bm mj mk ml mm mn di">如果</span>你是一名有抱负的数据科学家或资深数据科学家，这篇文章就适合你！在本文中，我们将使用 Python 构建一个简单的回归模型。为了增加一点趣味，我们将不会使用广受欢迎且无处不在的<em class="mo">波士顿房屋</em>数据集，而是使用一个简单的生物信息学数据集。特别是，我们将使用<strong class="ll jo"> <em class="mo">德莱尼溶解度</em> </strong>数据集，它代表了计算药物发现中一个重要的物理化学性质。</p><p id="7379" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">有抱负的数据科学家会发现逐步教程特别容易获得，而经验丰富的数据科学家可能希望找到一个新的具有挑战性的数据集，以尝试他们最先进的机器学习算法或工作流。</p></div><div class="ab cl lc ld hx le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="im in io ip iq"><h1 id="b751" class="mp mq je bd mr ms mt mu mv mw mx my mz kt na ku nb kw nc kx nd kz ne la nf ng bi translated">1.我们今天在建造什么？</h1><p id="f9a6" class="pw-post-body-paragraph lj lk je ll b lm nh ko lo lp ni kr lr ls nj lu lv lw nk ly lz ma nl mc md me im bi translated">一个回归模型！我们将使用 Python 来完成这项工作。在此过程中，我们将使用一个生物信息学数据集(从技术上讲，它是化学信息学数据集)来建立模型。</p><p id="e40f" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">特别是，我们要预测小分子水溶性的对数值。水溶性值是分子溶于水的能力的相对量度。它是有效药物的重要理化性质。</p><p id="c873" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">有什么比卡通插图更好的方式来了解我们今天正在建造的概念呢？</p><figure class="nm nn no np gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/9644740cdaec82996bc91829a927a9ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ydtFKo4yssZJ6QXDiY1oaw@2x.jpeg"/></div></div><p class="nq nr gj gh gi ns nt bd b be z dk translated"><strong class="bd nu">化学信息学数据集的机器学习模型构建的示意性工作流程的卡通图示，其中目标响应变量被预测为输入分子特征的函数。</strong>从技术上讲，这一过程被称为<em class="nv">定量构效关系</em> (QSAR)。(由 Chanin Nantasenamat 绘制</p></figure></div><div class="ab cl lc ld hx le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="im in io ip iq"><h1 id="2df2" class="mp mq je bd mr ms mt mu mv mw mx my mz kt na ku nb kw nc kx nd kz ne la nf ng bi translated">2.德莱尼溶解度数据集</h1><h2 id="b31c" class="nw mq je bd mr nx ny dn mv nz oa dp mz ls ob oc nb lw od oe nd ma of og nf jk bi translated">2.1.数据理解</h2><p id="f0d7" class="pw-post-body-paragraph lj lk je ll b lm nh ko lo lp ni kr lr ls nj lu lv lw nk ly lz ma nl mc md me im bi translated">顾名思义，<strong class="ll jo"> <em class="mo">德莱尼溶解度</em> </strong>数据集由一组 1144 个分子的<strong class="ll jo"> <em class="mo">水溶性</em> </strong>值及其相应的化学结构组成。对于这些，在生物学领域之外，有一些术语我们将花一些时间来澄清。</p><p id="a442" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><strong class="ll jo"> <em class="mo">分子</em> </strong>或有时被称为小分子或化合物是由原子组成的化学实体。让我们打个比方，让我们把原子想象成乐高积木，1 个原子就是 1 个乐高积木。当我们用几块乐高积木来建造某样东西时，不管是房子、汽车还是某个抽象的实体；这样构建的实体可与分子相媲美。由此，我们可以将原子形成一个分子的具体排列和连接方式称为<strong class="ll jo"> <em class="mo">化学结构</em> </strong>。</p><figure class="nm nn no np gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oh"><img src="../Images/046c8d0660faa59ffa318bab6f85ee45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j2yXft-XVviXNxXqTfSmow@2x.jpeg"/></div></div><p class="nq nr gj gh gi ns nt bd b be z dk translated"><strong class="bd nu">把分子的构造比喻成乐高积木。</strong>这个黄色的房子来自乐高 10703 创意建造者盒子。(由 Chanin Nantasenamat 绘制)</p></figure><p id="6173" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">那么你正在构建的每个实体有什么不同呢？它们的不同之处在于区块的空间连通性(即各个区块是如何连接的)。在化学术语中，每个分子的化学结构不同。因此，如果你改变了积木的连接性，那么你就有效地改变了你正在建造的实体。对于分子，如果原子类型(例如碳、氧、氮、硫、磷、氟、氯等。)或原子团(例如羟基、甲氧基、羧基、醚基等。)被改变，那么分子也将被改变，从而成为新的化学实体(即产生新的分子)。</p><figure class="nm nn no np gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/eec4a41faebbaf7c4e112a9ccb4f1516.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QslCNe6yCH4vYJM8TYgElQ@2x.jpeg"/></div></div><p class="nq nr gj gh gi ns nt bd b be z dk translated"><strong class="bd nu">一个分子模型的卡通插图。</strong>红色、蓝色、深灰色和白色代表氧、氮、碳和氢原子，而连接这些原子的浅灰色是键。每个原子都可以媲美一块乐高积木。上面显示的构建分子可与构建的乐高实体(如本文上面显示的黄色房子)相媲美。(由 Chanin Nantasenamat 绘制)</p></figure><p id="3aea" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">要成为一种有效的药物，分子将需要被人体吸收和分布，这种特性直接由<strong class="ll jo"> <em class="mo">水溶性</em> </strong>决定。溶解性是研究人员在设计和开发治疗药物时考虑的一个重要特性。因此，由于溶解性差而不能到达所需目的地的有效药物将是差的候选药物。</p></div><div class="ab cl lc ld hx le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="im in io ip iq"><h2 id="9788" class="nw mq je bd mr nx ny dn mv nz oa dp mz ls ob oc nb lw od oe nd ma of og nf jk bi translated">2.2.正在检索数据集</h2><p id="4e50" class="pw-post-body-paragraph lj lk je ll b lm nh ko lo lp ni kr lr ls nj lu lv lw nk ly lz ma nl mc md me im bi translated">Delaney 在名为<a class="ae oi" href="https://pubs.acs.org/doi/10.1021/ci034243x" rel="noopener ugc nofollow" target="_blank"> ESOL:从分子结构直接估算水溶性</a>的研究论文中进行的水溶性数据集可作为<a class="ae oi" href="https://pubs.acs.org/doi/10.1021/ci034243x" rel="noopener ugc nofollow" target="_blank">补充文件</a>获得。为了您的方便，我们还下载了整个<a class="ae oi" href="https://github.com/dataprofessor/data/blob/master/delaney.csv" rel="noopener ugc nofollow" target="_blank"> <strong class="ll jo">德莱尼溶解度数据集</strong> </a>，并在<a class="ae oi" href="https://github.com/dataprofessor" rel="noopener ugc nofollow" target="_blank">数据 GitHub 教授</a>上提供。</p><figure class="nm nn no np gt iv"><div class="bz fp l di"><div class="oj ok l"/></div><p class="nq nr gj gh gi ns nt bd b be z dk translated"><strong class="ak">Delaney 溶解度数据集原始版本的预览。</strong><a class="ae oi" href="https://github.com/dataprofessor/data/blob/master/delaney.csv" rel="noopener ugc nofollow" target="_blank">完整版</a>可在<a class="ae oi" href="https://github.com/dataprofessor" rel="noopener ugc nofollow" target="_blank">数据教授 GitHub </a>上获得。</p></figure><p id="a8ba" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><strong class="ll jo">代码练习</strong></p><p id="801d" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我们开始吧，好吗？</p><p id="7f75" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">启动 Google Colab 或您的 Jupyter 笔记本，运行以下代码单元。</p><figure class="nm nn no np gt iv"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="6fba" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><strong class="ll jo">代码解释</strong></p><p id="7355" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">现在让我们来看看每个代码单元的含义。</p><p id="f059" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">第<strong class="ll jo">个编码单元</strong>，</p><ul class=""><li id="ead3" class="ol om je ll b lm ln lp lq ls on lw oo ma op me oq or os ot bi translated">正如代码字面上所说，我们将把<code class="fe ou ov ow ox b">pandas</code>库作为<code class="fe ou ov ow ox b">pd</code>导入。</li></ul><p id="efeb" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><strong class="ll jo">第二代码单元</strong>:</p><ul class=""><li id="be05" class="ol om je ll b lm ln lp lq ls on lw oo ma op me oq or os ot bi translated">将德莱尼溶解度数据集所在的 URL 分配给<code class="fe ou ov ow ox b">delaney_url</code>变量。</li><li id="d889" class="ol om je ll b lm oy lp oz ls pa lw pb ma pc me oq or os ot bi translated">通过<code class="fe ou ov ow ox b">pd.read_csv()</code>函数读入德莱尼溶解度数据集，并将结果数据帧分配给<code class="fe ou ov ow ox b">delaney_df</code>变量。</li><li id="ca30" class="ol om je ll b lm oy lp oz ls pa lw pb ma pc me oq or os ot bi translated">调用<code class="fe ou ov ow ox b">delaney_df</code>变量返回输出值，该输出值实际上打印出包含以下 4 列的数据帧:</li></ul><ol class=""><li id="7fe0" class="ol om je ll b lm ln lp lq ls on lw oo ma op me pd or os ot bi translated"><strong class="ll jo">化合物 ID </strong> —化合物的名称。</li><li id="d9d2" class="ol om je ll b lm oy lp oz ls pa lw pb ma pc me pd or os ot bi translated"><strong class="ll jo">实测对数(溶解度:mol/L)</strong>—Delaney 在原始研究文章中报告的实验水溶性值。</li><li id="20ea" class="ol om je ll b lm oy lp oz ls pa lw pb ma pc me pd or os ot bi translated"><strong class="ll jo"> ESOL 预测对数(溶解度:mol/L)</strong>—Delaney 在原始研究文章中报告的预测水溶性值。</li><li id="1c51" class="ol om je ll b lm oy lp oz ls pa lw pb ma pc me pd or os ot bi translated"><strong class="ll jo"> SMILES </strong> —化学结构信息的一维编码</li></ol></div><div class="ab cl lc ld hx le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="im in io ip iq"><h2 id="0f8f" class="nw mq je bd mr nx ny dn mv nz oa dp mz ls ob oc nb lw od oe nd ma of og nf jk bi translated">2.3.计算分子描述符</h2><p id="95e5" class="pw-post-body-paragraph lj lk je ll b lm nh ko lo lp ni kr lr ls nj lu lv lw nk ly lz ma nl mc md me im bi translated">需要注意的一点是，作者最初提供的上述数据集还不能开箱即用。特别是，我们将不得不使用<strong class="ll jo"> <em class="mo"> SMILES 符号</em> </strong>通过<em class="mo"> rdkit </em> Python 库来计算<strong class="ll jo"> <em class="mo">分子描述符</em> </strong>，这在以前的媒体文章(<a class="ae oi" rel="noopener" target="_blank" href="/how-to-use-machine-learning-for-drug-discovery-1ccb5fdf81ad"> <em class="mo">如何使用机器学习进行药物发现</em> </a>)中以逐步的方式进行了演示。</p><p id="b5f8" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">需要注意的是，<strong class="ll jo"> <em class="mo">微笑符号</em> </strong>是对分子化学结构信息的一维描绘。<strong class="ll jo"> <em class="mo">分子描述符</em> </strong>是对分子独特的物理化学性质的定量或定性描述。</p><p id="9b2d" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">让我们将分子描述符视为一种以数字形式唯一表示分子的方法，机器学习算法可以理解这种方法，以学习、预测和提供关于<strong class="ll jo"> <em class="mo">结构-活性关系</em> </strong>的有用知识。如前所述，原子的特定排列和连接产生不同的化学结构，从而决定了它们将产生的最终活性。这种概念被称为结构-活性关系。</p><p id="53b8" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">包含计算的分子描述符及其相应响应变量(对数)的数据集的处理版本如下所示。这个处理过的数据集现在准备好用于机器学习模型构建，其中前 4 个变量可以用作<strong class="ll jo"> X </strong>变量，而对数变量可以用作<strong class="ll jo"> Y </strong>变量。</p><figure class="nm nn no np gt iv"><div class="bz fp l di"><div class="oj ok l"/></div><p class="nq nr gj gh gi ns nt bd b be z dk translated"><strong class="ak">德莱尼溶解度数据集处理版本的预览。</strong>实际上，原始版本中的 SMILES 符号被用作计算 4 个分子描述符的输入，这在之前的<a class="ae oi" rel="noopener" target="_blank" href="/how-to-use-machine-learning-for-drug-discovery-1ccb5fdf81ad">媒体文章</a>和<a class="ae oi" href="https://www.youtube.com/watch?v=VXFFHHoE1wk" rel="noopener ugc nofollow" target="_blank"> YouTube 视频</a>中有详细描述。<a class="ae oi" href="https://github.com/dataprofessor/data/blob/master/delaney.csv" rel="noopener ugc nofollow" target="_blank">完整版</a>可在<a class="ae oi" href="https://github.com/dataprofessor" rel="noopener ugc nofollow" target="_blank">数据教授 GitHub </a>上获得。</p></figure><p id="627e" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">4 个分子描述符和响应变量的快速描述如下:</p><ol class=""><li id="f77b" class="ol om je ll b lm ln lp lq ls on lw oo ma op me pd or os ot bi translated"><strong class="ll jo"> cLogP </strong> —辛醇-水分配系数</li><li id="32c1" class="ol om je ll b lm oy lp oz ls pa lw pb ma pc me pd or os ot bi translated"><strong class="ll jo"> MW </strong> —分子量</li><li id="1af8" class="ol om je ll b lm oy lp oz ls pa lw pb ma pc me pd or os ot bi translated"><strong class="ll jo">RB</strong>—可旋转债券数量</li><li id="c267" class="ol om je ll b lm oy lp oz ls pa lw pb ma pc me pd or os ot bi translated"><strong class="ll jo"> AP </strong> <em class="mo"> — </em>芳香比例=芳香原子数/重原子总数</li><li id="9375" class="ol om je ll b lm oy lp oz ls pa lw pb ma pc me pd or os ot bi translated"><strong class="ll jo">日志</strong> —水溶性的日志</li></ol><p id="c6a1" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><strong class="ll jo">代码练习</strong> <br/>让我们继续读入包含计算出的分子描述符的 CSV 文件。</p><figure class="nm nn no np gt iv"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="bd97" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><strong class="ll jo">代码解释</strong></p><p id="682f" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">现在让我们来看一下代码单元的含义。</p><ul class=""><li id="3eb4" class="ol om je ll b lm ln lp lq ls on lw oo ma op me oq or os ot bi translated">将 Delaney 溶解度数据集(带有计算的描述符)所在的 URL 分配给<code class="fe ou ov ow ox b">delaney_url</code>变量。</li><li id="5a67" class="ol om je ll b lm oy lp oz ls pa lw pb ma pc me oq or os ot bi translated">通过<code class="fe ou ov ow ox b">pd.read_csv()</code>函数读入德莱尼溶解度数据集(带有计算出的描述符),并将结果数据帧赋给<code class="fe ou ov ow ox b">delaney_descriptors_df</code>变量。</li><li id="20f2" class="ol om je ll b lm oy lp oz ls pa lw pb ma pc me oq or os ot bi translated">调用<code class="fe ou ov ow ox b">delaney_descriptors_df</code>变量返回输出值，该输出值实际上打印出包含以下 5 列的数据帧:</li></ul><ol class=""><li id="f093" class="ol om je ll b lm ln lp lq ls on lw oo ma op me pd or os ot bi translated">莫洛格普</li><li id="5dda" class="ol om je ll b lm oy lp oz ls pa lw pb ma pc me pd or os ot bi translated">MolWt</li><li id="1929" class="ol om je ll b lm oy lp oz ls pa lw pb ma pc me pd or os ot bi translated">NumRotatableBonds</li><li id="862d" class="ol om je ll b lm oy lp oz ls pa lw pb ma pc me pd or os ot bi translated">芳香比例</li><li id="47a1" class="ol om je ll b lm oy lp oz ls pa lw pb ma pc me pd or os ot bi translated">日志</li></ol><p id="701f" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">前 4 列是使用<code class="fe ou ov ow ox b">rdkit</code> Python 库计算的分子描述符。第五列是响应变量<em class="mo">日志</em>。</p></div><div class="ab cl lc ld hx le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="im in io ip iq"><h1 id="854e" class="mp mq je bd mr ms mt mu mv mw mx my mz kt na ku nb kw nc kx nd kz ne la nf ng bi translated">3.数据准备</h1><h2 id="ba42" class="nw mq je bd mr nx ny dn mv nz oa dp mz ls ob oc nb lw od oe nd ma of og nf jk bi translated">3.1.将数据分离为 X 和 Y 变量</h2><p id="bf0e" class="pw-post-body-paragraph lj lk je ll b lm nh ko lo lp ni kr lr ls nj lu lv lw nk ly lz ma nl mc md me im bi translated">在使用<code class="fe ou ov ow ox b">scikit-learn</code>库构建机器学习模型时，我们需要将数据集分成输入特征(<strong class="ll jo"> X </strong>变量)和目标响应变量(<strong class="ll jo"> Y </strong>变量)。</p><p id="a4b5" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><strong class="ll jo">代码练习</strong></p><p id="fa74" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">遵循并实现以下 2 个代码单元，将包含在<code class="fe ou ov ow ox b">delaney_descriptors_df</code>数据帧中的数据集分成<strong class="ll jo"> X </strong>和<strong class="ll jo"> Y </strong>子集。</p><figure class="nm nn no np gt iv"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="72e9" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><strong class="ll jo">代码解释</strong></p><p id="e6d7" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">让我们来看看这两个代码单元。</p><p id="84cf" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><strong class="ll jo"> <em class="mo">第一个编码单元格:</em> </strong></p><ul class=""><li id="9bb2" class="ol om je ll b lm ln lp lq ls on lw oo ma op me oq or os ot bi translated">这里我们使用 drop()函数专门“删除”logS 变量(这是<strong class="ll jo"> Y </strong>变量，我们将在下一个代码单元格中处理它)。因此，我们将有 4 个剩余变量分配给<strong class="ll jo"> X </strong>数据帧。特别是，我们将<code class="fe ou ov ow ox b">drop()</code>函数应用于<code class="fe ou ov ow ox b">delaney_descriptors_df</code>数据帧，如在<code class="fe ou ov ow ox b">delaney_descriptors_df.drop(‘logS’, axis=1)</code>中，其中第一个输入参数是我们想要删除的特定列，而<code class="fe ou ov ow ox b">axis=1</code>的第二个输入参数指定第一个输入参数是一列。</li></ul><p id="0c67" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><strong class="ll jo">第二编码单元:</strong></p><ul class=""><li id="7c6c" class="ol om je ll b lm ln lp lq ls on lw oo ma op me oq or os ot bi translated">这里，我们通过<code class="fe ou ov ow ox b">delaney_descriptors_df.logS</code>从<code class="fe ou ov ow ox b">delaney_descriptors_df</code>数据帧中选择一列(‘logS’列),并将其分配给<strong class="ll jo"> Y </strong>变量。</li></ul></div><div class="ab cl lc ld hx le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="im in io ip iq"><h2 id="27d1" class="nw mq je bd mr nx ny dn mv nz oa dp mz ls ob oc nb lw od oe nd ma of og nf jk bi translated">3.2.数据分割</h2><p id="3276" class="pw-post-body-paragraph lj lk je ll b lm nh ko lo lp ni kr lr ls nj lu lv lw nk ly lz ma nl mc md me im bi translated">在评估模型性能时，标准做法是将数据集拆分为 2 个(或更多分区)分区，这里我们将使用 80/20 的拆分比率，其中 80%的子集将用作训练集，20%的子集将用作测试集。由于 scikit-learn 要求将数据进一步分离到它们的<strong class="ll jo"> X </strong>和<strong class="ll jo"> Y </strong>组件，因此<code class="fe ou ov ow ox b">train_test_split()</code>函数可以轻松执行上述任务。</p><p id="83c8" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><strong class="ll jo">代码练习</strong></p><p id="51d1" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">让我们实现以下两个代码单元。</p><figure class="nm nn no np gt iv"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="9dad" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><strong class="ll jo">代码解释</strong></p><p id="fb5a" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">让我们看看代码在做什么。</p><p id="fd70" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><strong class="ll jo"> <em class="mo">第一个编码单元格:</em> </strong></p><ul class=""><li id="64e1" class="ol om je ll b lm ln lp lq ls on lw oo ma op me oq or os ot bi translated">这里我们将从 scikit-learn 库中导入<code class="fe ou ov ow ox b">train_test_split</code>。</li></ul><p id="e2f8" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><strong class="ll jo"> <em class="mo">第二个编码单元格:</em> </strong></p><ul class=""><li id="10e3" class="ol om je ll b lm ln lp lq ls on lw oo ma op me oq or os ot bi translated">我们首先定义<code class="fe ou ov ow ox b">train_test_split()</code>函数将生成的 4 个变量的名称，这包括<code class="fe ou ov ow ox b">X_train</code>、<code class="fe ou ov ow ox b">X_test</code>、<code class="fe ou ov ow ox b">Y_train</code>和<code class="fe ou ov ow ox b">Y_test</code>。前 2 个对应于训练和测试集的 X 数据帧，而后 2 个对应于训练和测试集的 Y 变量。</li></ul></div><div class="ab cl lc ld hx le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="im in io ip iq"><h1 id="e154" class="mp mq je bd mr ms mt mu mv mw mx my mz kt na ku nb kw nc kx nd kz ne la nf ng bi translated">4.线性回归模型</h1><p id="633d" class="pw-post-body-paragraph lj lk je ll b lm nh ko lo lp ni kr lr ls nj lu lv lw nk ly lz ma nl mc md me im bi translated">现在，有趣的部分来了，让我们建立一个回归模型。</p><h2 id="3c5b" class="nw mq je bd mr nx ny dn mv nz oa dp mz ls ob oc nb lw od oe nd ma of og nf jk bi translated">4.1.训练线性回归模型</h2><p id="b6e6" class="pw-post-body-paragraph lj lk je ll b lm nh ko lo lp ni kr lr ls nj lu lv lw nk ly lz ma nl mc md me im bi translated"><strong class="ll jo">代码练习</strong></p><p id="71f3" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">这里，我们将使用 scikit-learn 中的<code class="fe ou ov ow ox b">LinearRegression()</code>函数，使用普通的最小二乘线性回归建立一个模型。</p><figure class="nm nn no np gt iv"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="622a" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><strong class="ll jo">代码解释</strong></p><p id="d601" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">让我们看看代码在做什么</p><p id="f22a" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><strong class="ll jo">第一个编码单元:</strong></p><ul class=""><li id="3e0b" class="ol om je ll b lm ln lp lq ls on lw oo ma op me oq or os ot bi translated">这里我们从 scikit-learn 库中导入了 linear_model</li></ul><p id="db8d" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><strong class="ll jo">第二编码单元:</strong></p><ul class=""><li id="f8ce" class="ol om je ll b lm ln lp lq ls on lw oo ma op me oq or os ot bi translated">我们将<code class="fe ou ov ow ox b">linear_model.LinearRegression()</code>函数赋给<code class="fe ou ov ow ox b">model</code>变量。</li><li id="3857" class="ol om je ll b lm oy lp oz ls pa lw pb ma pc me oq or os ot bi translated">使用命令<code class="fe ou ov ow ox b">model.fit(X_train, Y_train)</code>构建模型，由此 model.fit()函数将把<code class="fe ou ov ow ox b">X_train</code>和<code class="fe ou ov ow ox b">Y_train</code>作为输入参数来构建或训练模型。特别是，<code class="fe ou ov ow ox b">X_train</code>包含输入特征，而<code class="fe ou ov ow ox b">Y_train</code>包含响应变量(日志)。</li></ul><h2 id="6366" class="nw mq je bd mr nx ny dn mv nz oa dp mz ls ob oc nb lw od oe nd ma of og nf jk bi translated">4.2.应用经过训练的模型来预测来自训练和测试集的日志</h2><p id="6329" class="pw-post-body-paragraph lj lk je ll b lm nh ko lo lp ni kr lr ls nj lu lv lw nk ly lz ma nl mc md me im bi translated">如上所述，<code class="fe ou ov ow ox b">model.fit()</code>训练模型，训练后的模型保存在<code class="fe ou ov ow ox b">model</code>变量中。</p><p id="a05b" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><strong class="ll jo">代码练习</strong></p><p id="9a0a" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我们现在将应用经过训练的模型对训练集进行预测(<code class="fe ou ov ow ox b">X_train</code>)。</p><figure class="nm nn no np gt iv"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="7a69" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我们现在将应用训练好的模型对测试集进行预测(<code class="fe ou ov ow ox b">X_test</code>)。</p><figure class="nm nn no np gt iv"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="f0c8" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><strong class="ll jo">代码解释</strong></p><p id="bff5" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">让我们开始解释。</p><p id="f7f0" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">以下解释将仅涵盖训练集(<code class="fe ou ov ow ox b">X_train</code>)，因为通过执行以下简单调整，完全相同的概念可以同样地应用于测试集(<code class="fe ou ov ow ox b">X_test</code>):</p><ul class=""><li id="7501" class="ol om je ll b lm ln lp lq ls on lw oo ma op me oq or os ot bi translated">将<code class="fe ou ov ow ox b">X_train</code>替换为<code class="fe ou ov ow ox b">X_test</code></li><li id="37bb" class="ol om je ll b lm oy lp oz ls pa lw pb ma pc me oq or os ot bi translated">将<code class="fe ou ov ow ox b">Y_train</code>替换为<code class="fe ou ov ow ox b">Y_test</code></li><li id="c9e6" class="ol om je ll b lm oy lp oz ls pa lw pb ma pc me oq or os ot bi translated">将<code class="fe ou ov ow ox b">Y_pred_train</code>替换为<code class="fe ou ov ow ox b">Y_pred_test</code></li></ul><p id="e882" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">其他一切都完全一样。</p><p id="92f0" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><strong class="ll jo"> <em class="mo">第一个编码单元格:</em> </strong></p><ul class=""><li id="b390" class="ol om je ll b lm ln lp lq ls on lw oo ma op me oq or os ot bi translated">通过调用<code class="fe ou ov ow ox b">model.predict()</code>并使用<code class="fe ou ov ow ox b">X_train</code>作为输入参数来执行对日志值的预测，这样我们就可以运行命令<code class="fe ou ov ow ox b">model.predict(X_train)</code>。产生的预测值将被赋给<code class="fe ou ov ow ox b">Y_pred_train</code>变量。</li></ul><p id="a0e8" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><strong class="ll jo"> <em class="mo">第二个编码单元:</em> </strong></p><p id="0cda" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">模型性能指标现已打印。</p><ul class=""><li id="e284" class="ol om je ll b lm ln lp lq ls on lw oo ma op me oq or os ot bi translated">回归系数值从<code class="fe ou ov ow ox b">model.coef_</code>获得，</li><li id="63ea" class="ol om je ll b lm oy lp oz ls pa lw pb ma pc me oq or os ot bi translated">y 轴截距值从<code class="fe ou ov ow ox b">model.intercept_</code>获得，</li><li id="6fe4" class="ol om je ll b lm oy lp oz ls pa lw pb ma pc me oq or os ot bi translated">使用<code class="fe ou ov ow ox b">mean_squared_error()</code>函数计算均方误差(MSE ),使用<code class="fe ou ov ow ox b">Y_train</code>和<code class="fe ou ov ow ox b">Y_pred_train</code>作为输入参数，因此我们运行<code class="fe ou ov ow ox b">mean_squared_error(Y_train, Y_pred_train)</code></li><li id="1214" class="ol om je ll b lm oy lp oz ls pa lw pb ma pc me oq or os ot bi translated">使用<code class="fe ou ov ow ox b">Y_train</code>和<code class="fe ou ov ow ox b">Y_pred_train</code>作为输入参数，使用<code class="fe ou ov ow ox b">r2_score()</code>函数计算决定系数(也称为 R ),因此我们运行<code class="fe ou ov ow ox b">r2_score(Y_train, Y_pred_train)</code></li></ul></div><div class="ab cl lc ld hx le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="im in io ip iq"><h2 id="c204" class="nw mq je bd mr nx ny dn mv nz oa dp mz ls ob oc nb lw od oe nd ma of og nf jk bi translated">4.3.打印出回归方程</h2><p id="47a7" class="pw-post-body-paragraph lj lk je ll b lm nh ko lo lp ni kr lr ls nj lu lv lw nk ly lz ma nl mc md me im bi translated">线性回归模型的方程实际上是模型本身，您可以插入输入特征值，方程将返回目标响应值(对数)。</p><p id="9bae" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><strong class="ll jo">代码练习</strong></p><p id="6399" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">现在让我们打印出回归模型方程。</p><figure class="nm nn no np gt iv"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="b598" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><strong class="ll jo">代码解释</strong></p><p id="4779" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><strong class="ll jo"> <em class="mo">第一个编码单元格:</em> </strong></p><ul class=""><li id="0754" class="ol om je ll b lm ln lp lq ls on lw oo ma op me oq or os ot bi translated">回归模型方程的所有组成部分都是从<code class="fe ou ov ow ox b">model</code>变量中导出的。在<code class="fe ou ov ow ox b">model.intercept_</code>、<code class="fe ou ov ow ox b">model.coef_[0]</code>、<code class="fe ou ov ow ox b">model.coef_[1]</code>、<code class="fe ou ov ow ox b">model.coef_[2]</code>和<code class="fe ou ov ow ox b">model.coef_[3]</code>中提供了 y 截距和 LogP、MW、RB 和 AP 的回归系数。</li></ul><p id="819e" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><strong class="ll jo"> <em class="mo">第二码单元格:</em> </strong></p><ul class=""><li id="826d" class="ol om je ll b lm ln lp lq ls on lw oo ma op me oq or os ot bi translated">在这里，我们通过<code class="fe ou ov ow ox b">print()</code>功能将组件放在一起并打印出方程式。</li></ul></div><div class="ab cl lc ld hx le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="im in io ip iq"><h1 id="d21b" class="mp mq je bd mr ms mt mu mv mw mx my mz kt na ku nb kw nc kx nd kz ne la nf ng bi translated">5.实验测井与预测测井的散点图</h1><p id="ddaa" class="pw-post-body-paragraph lj lk je ll b lm nh ko lo lp ni kr lr ls nj lu lv lw nk ly lz ma nl mc md me im bi translated">现在，我们将通过散点图来直观显示实验与预测测井曲线的相对分布。这样的情节可以让我们很快看到模型的性能。</p><p id="6227" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><strong class="ll jo">代码练习</strong></p><p id="7f09" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在接下来的例子中，我将向你展示如何不同地布置 2 个子图，即:(1)垂直图和(2)水平图。</p><figure class="nm nn no np gt iv"><div class="bz fp l di"><div class="oj ok l"/></div></figure><figure class="nm nn no np gt iv"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="6193" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><strong class="ll jo">代码解释</strong></p><p id="6403" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">现在让我们看看实现垂直和水平图的底层代码。在这里，我提供了两个选项供您选择，让您选择是在垂直布局还是水平布局中使用这个多点图的布局。</p><p id="fdf0" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><strong class="ll jo"> <em class="mo">导入库</em> </strong></p><p id="da3e" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">两者都从导入必要的库开始，即<code class="fe ou ov ow ox b">matplotlib</code>和<code class="fe ou ov ow ox b">numpy</code>。特别是，大部分代码将使用<code class="fe ou ov ow ox b">matplotlib</code>来创建绘图，而<code class="fe ou ov ow ox b">numpy</code>库在这里用于添加趋势线。</p><p id="8e04" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><strong class="ll jo"> <em class="mo">定义图尺寸</em> </strong></p><p id="54f6" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">接下来，我们通过<code class="fe ou ov ow ox b">plt.figure(figsize=(5,11))</code>为垂直绘图指定图形尺寸(图形的宽度和高度)，通过<code class="fe ou ov ow ox b">plt.figure(figsize=(11,5))</code>为水平绘图指定图形尺寸。特别是，(5，11)告诉 matplotlib，垂直图的图形应该是 5 英寸宽和 11 英寸高，而水平图则使用相反的图形。</p><p id="5875" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><strong class="ll jo"> <em class="mo">定义子图</em> </strong>的占位符</p><p id="4d8a" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我们将告诉 matplotlib，我们希望有 2 行和 1 列，因此它的布局将是垂直绘图。这是由<code class="fe ou ov ow ox b">plt.subplot(2, 1, 1)</code>指定的，其中<code class="fe ou ov ow ox b">2, 1, 1</code>的输入参数指的是 2 行 1 列以及我们在它下面创建的特定子图。换句话说，让我们把使用<code class="fe ou ov ow ox b">plt.subplot()</code>功能看作是通过为图形包含的各种子图创建占位符来构建图形的一种方式。垂直图的第二个子图由<code class="fe ou ov ow ox b">plt.subplot()</code>功能的第三个输入参数中的值 2 指定，如<code class="fe ou ov ow ox b">plt.subplot(2, 1, 2)</code>所示。</p><p id="70e9" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">通过应用相同的概念，通过容纳 2 个子图的<code class="fe ou ov ow ox b">plt.subplot(1, 2, 1)</code>和<code class="fe ou ov ow ox b">plt.subplot(1, 2, 2)</code>创建水平图的结构为 1 行 2 列。</p><p id="e324" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><strong class="ll jo"> <em class="mo">创建散点图</em> </strong></p><p id="779a" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">既然图的一般结构已经就绪，现在让我们添加数据可视化。分别使用<code class="fe ou ov ow ox b">plt.scatter(x=Y_train, y=Y_pred_train, c=”#7CAE00", alpha=0.3)</code>中的<code class="fe ou ov ow ox b">plt.scatter()</code>函数添加数据散点，其中<code class="fe ou ov ow ox b">x</code>指的是用于<em class="mo"> x </em>轴的数据列，<code class="fe ou ov ow ox b">y</code>指的是用于<em class="mo"> y </em>轴的数据列，<code class="fe ou ov ow ox b">c</code>指的是用于散点数据的颜色，<code class="fe ou ov ow ox b">alpha</code>指的是 alpha 透明度级别(散点数据的透明度，数值越低，透明度越高)。</p><p id="b9d2" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><strong class="ll jo"> <em class="mo">添加趋势线</em> </strong></p><p id="1571" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">接下来，我们使用来自<code class="fe ou ov ow ox b">numpy</code>的<code class="fe ou ov ow ox b">np.polyfit()</code>和<code class="fe ou ov ow ox b">np.poly1d()</code>函数以及来自<code class="fe ou ov ow ox b">matplotlib</code>的<code class="fe ou ov ow ox b">plt.plot ()</code>函数来创建趋势线。</p><pre class="nm nn no np gt pe ox pf pg aw ph bi"><span id="a905" class="nw mq je ox b gy pi pj l pk pl"><em class="mo"># Add trendline</em><br/><em class="mo"># https://stackoverflow.com/questions/26447191/how-to-add-trendline-in-python-matplotlib-dot-scatter-graphs</em><br/>z = np.polyfit(Y_train, Y_pred_train, 1)<br/>p = np.poly1d(z)<br/>plt.plot(Y_test,p(Y_test),"#F8766D")</span></pre><p id="f3b6" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><strong class="ll jo"> <em class="mo">添加 x 和 y 轴标签</em> </strong></p><p id="2d20" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">为了给<em class="mo"> x </em>和<em class="mo"> y </em>轴添加标签，我们使用了<code class="fe ou ov ow ox b">plt.xlabel()</code>和<code class="fe ou ov ow ox b">plt.ylabel()</code>功能。需要注意的是，对于垂直图，我们省略了顶部子图的 x 轴标签(<em class="mo">为什么？因为对于底部子图</em>，x 轴标签是多余的。</p><p id="d9d0" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><strong class="ll jo"> <em class="mo">保存图</em> </strong></p><p id="2b9c" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">最后，我们将把构建好的图形保存到文件中，我们可以使用来自<code class="fe ou ov ow ox b">matplotlib</code>的<code class="fe ou ov ow ox b">plt.savefig()</code>函数，并指定文件名作为输入参数。最后，以<code class="fe ou ov ow ox b">plt.show()</code>结束。</p><pre class="nm nn no np gt pe ox pf pg aw ph bi"><span id="66f6" class="nw mq je ox b gy pi pj l pk pl">plt.savefig('plot_vertical_logS.png')<br/>plt.savefig('plot_vertical_logS.pdf')<br/>plt.show()</span></pre><p id="972a" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><strong class="ll jo">视觉解释</strong></p><p id="614e" class="pw-post-body-paragraph lj lk je ll b lm ln ko lo lp lq kr lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">上一节提供了基于文本的解释，在这一节中，我们将对这个视觉解释做同样的解释，它利用颜色高亮来区分情节的不同组成部分。</p><figure class="nm nn no np gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/b23a06d752a7b00248f46fce23d6f49f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TVV9kgSL4WHJV_NaXyQN0g@2x.jpeg"/></div></div><p class="nq nr gj gh gi ns nt bd b be z dk translated"><strong class="bd nu">创建散点图的可视化说明。</strong>这里我们用颜色高亮显示特定的代码行和它们对应的绘图组件。(由 Chanin Nantasenamat 绘制)</p></figure><h1 id="19b0" class="mp mq je bd mr ms pm mu mv mw pn my mz kt po ku nb kw pp kx nd kz pq la nf ng bi translated">需要您的反馈</h1><p id="45cd" class="pw-post-body-paragraph lj lk je ll b lm nh ko lo lp ni kr lr ls nj lu lv lw nk ly lz ma nl mc md me im bi translated">作为一名教育工作者，我喜欢听我如何改进我的内容。请在评论中告诉我:</p><ol class=""><li id="4ef1" class="ol om je ll b lm ln lp lq ls on lw oo ma op me pd or os ot bi translated">可视化插图有助于理解代码是如何工作的，</li><li id="8165" class="ol om je ll b lm oy lp oz ls pa lw pb ma pc me pd or os ot bi translated">视觉插图是多余的和不必要的，或者是否</li><li id="6794" class="ol om je ll b lm oy lp oz ls pa lw pb ma pc me pd or os ot bi translated">可视化插图补充了基于文本的解释，有助于理解代码是如何工作的。</li></ol></div><div class="ab cl lc ld hx le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="im in io ip iq"><h2 id="89c7" class="nw mq je bd mr nx ny dn mv nz oa dp mz ls ob oc nb lw od oe nd ma of og nf jk bi translated">订阅我的邮件列表，获取我在数据科学方面的最佳更新(偶尔还有免费赠品)!</h2></div><div class="ab cl lc ld hx le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="im in io ip iq"><h1 id="f0d0" class="mp mq je bd mr ms mt mu mv mw mx my mz kt na ku nb kw nc kx nd kz ne la nf ng bi translated">关于我</h1><p id="7c13" class="pw-post-body-paragraph lj lk je ll b lm nh ko lo lp ni kr lr ls nj lu lv lw nk ly lz ma nl mc md me im bi translated">我是泰国一所研究型大学的生物信息学副教授和数据挖掘和生物医学信息学负责人。在我下班后的时间里，我是一名 YouTuber(又名<a class="ae oi" href="http://bit.ly/dataprofessor/" rel="noopener ugc nofollow" target="_blank">数据教授</a>)制作关于数据科学的在线视频。在我制作的所有教程视频中，我也在 GitHub 上分享 Jupyter 笔记本(<a class="ae oi" href="https://github.com/dataprofessor/" rel="noopener ugc nofollow" target="_blank">数据教授 GitHub page </a>)。</p><div class="is it gp gr iu pr"><a href="https://www.youtube.com/dataprofessor?sub_confirmation=1" rel="noopener  ugc nofollow" target="_blank"><div class="ps ab fo"><div class="pt ab pu cl cj pv"><h2 class="bd jo gy z fp pw fr fs px fu fw jn bi translated">数据教授</h2><div class="py l"><h3 class="bd b gy z fp pw fr fs px fu fw dk translated">数据科学、机器学习、生物信息学、研究和教学是我的激情所在。数据教授 YouTube…</h3></div><div class="pz l"><p class="bd b dl z fp pw fr fs px fu fw dk translated">www.youtube.com</p></div></div><div class="qa l"><div class="qb l qc qd qe qa qf ja pr"/></div></div></a></div><h2 id="1328" class="nw mq je bd mr nx ny dn mv nz oa dp mz ls ob oc nb lw od oe nd ma of og nf jk bi translated">在社交网络上与我联系</h2><p id="2675" class="pw-post-body-paragraph lj lk je ll b lm nh ko lo lp ni kr lr ls nj lu lv lw nk ly lz ma nl mc md me im bi translated">✅YouTube:<a class="ae oi" href="http://youtube.com/dataprofessor/" rel="noopener ugc nofollow" target="_blank">http://youtube.com/dataprofessor/</a><br/>♇网站:<a class="ae oi" href="https://www.youtube.com/redirect?redir_token=w4MajL6v6Oi_kOAZNbMprRRJrvJ8MTU5MjI5NjQzN0AxNTkyMjEwMDM3&amp;q=http%3A%2F%2Fdataprofessor.org%2F&amp;event=video_description&amp;v=ZZ4B0QUHuNc" rel="noopener ugc nofollow" target="_blank">http://dataprofessor.org/</a>(在建)<br/>♇LinkedIn:<a class="ae oi" href="https://www.linkedin.com/company/dataprofessor/" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/company/dataprofessor/</a><br/>♇Twitter:<a class="ae oi" href="https://twitter.com/thedataprof" rel="noopener ugc nofollow" target="_blank">https://twitter.com/thedataprof</a><br/>♇Facebook:<a class="ae oi" href="https://www.youtube.com/redirect?redir_token=w4MajL6v6Oi_kOAZNbMprRRJrvJ8MTU5MjI5NjQzN0AxNTkyMjEwMDM3&amp;q=http%3A%2F%2Ffacebook.com%2Fdataprofessor%2F&amp;event=video_description&amp;v=ZZ4B0QUHuNc" rel="noopener ugc nofollow" target="_blank">http://facebook.com/dataprofessor/</a><br/>♇github:<a class="ae oi" href="https://github.com/dataprofessor/" rel="noopener ugc nofollow" target="_blank">https://github.com/dataprofessor/</a><br/>♇insta gram:【t2t</p></div></div>    
</body>
</html>