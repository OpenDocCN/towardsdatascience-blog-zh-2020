<html>
<head>
<title>Predicting Churn with PySpark ML</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 PySpark ML 预测客户流失</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/predicting-churn-with-pyspark-ml-d65012e9ab7c?source=collection_archive---------31-----------------------#2020-08-17">https://towardsdatascience.com/predicting-churn-with-pyspark-ml-d65012e9ab7c?source=collection_archive---------31-----------------------#2020-08-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9949" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用 Sparkify 订阅数据解决分类问题</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/03c06274d2edec491e21e4ecc702f551.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UiQ39DTGU_4gdQClxsEq1w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@franki?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">弗兰基·查马基</a>在<a class="ae ky" href="https://unsplash.com/s/photos/machine-learning?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="964f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">留住客户对繁荣的企业至关重要。当我们正在享受<strong class="lb iu">一键订阅</strong>的数字服务时，一些公司正在拔头发，因为有人只是点击<strong class="lb iu">一下就退出了。如果我们能够确定哪些用户面临流失风险，那么企业就可以采取行动，并有可能留住他们。</strong></p><p id="3c73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了实现这一点，我们需要不仅准确，而且足够强大的机器学习解决方案来快速处理大量数据。<strong class="lb iu"> Apache Spark </strong>是一个适合这种需求的大数据平台。部署在 Spark 上的数据科学管道可以利用像<strong class="lb iu"> HDFS </strong>这样的分布式系统来增加模型的可扩展性。<strong class="lb iu"> Spark ML </strong>支持逻辑回归、随机森林和其他线性扩展模型等算法。</p><h1 id="737d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">激发客户流失预测</strong></h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mn"><img src="../Images/7c97ec96b58d4e4926952f53c9c31e94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lFryB6rgWBg67SZkZxVG7A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">资料来源:Udacity</p></figure><p id="b0b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Sparkify 是 Udacity 宇宙中的一项音乐流媒体服务。就像 Spotify 一样，用户可以选择带广告的免费订阅层或不带广告的付费订阅层。</p><p id="31b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个项目中，我们将根据 Sparkify 用户数据预测有流失风险的用户。我们将首先分析较小子集(128MB)上的数据，然后将管道部署到 AWS EMR 等云服务，以使用完整数据集(12GB)调优选定的模型。</p><h1 id="38d4" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">探索性数据分析</strong></h1><p id="61bd" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">这个小数据集包含 286500 条记录和 18 个字段:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="3466" class="my lw it mu b gy mz na l nb nc">df.printSchema()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/e5684fd801c04bd55fd2df0e162c2b28.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*YbxxOdG0UwmphYD6FvvAhQ.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">df 模式</p></figure><p id="550e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于我们只对现有的 Sparkify 用户感兴趣，我们将排除与用户 Id 无关的访客流量或活动，这样我们就有了 225 个不同的用户。</p><h2 id="730d" class="my lw it bd lx ne nf dn mb ng nh dp mf li ni nj mh lm nk nl mj lq nm nn ml no bi translated"><strong class="ak">流失定义</strong></h2><p id="eed9" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在这项研究中，我们将用户流失定义为用户<strong class="lb iu">取消订阅</strong>并离开 Sparkify。当用户提交取消时，记录将有<code class="fe np nq nr mu b">auth == 'Cancelled'</code>和<code class="fe np nq nr mu b">page == 'Cancellation Confirmation'</code>。取消立即生效。</p><p id="4b9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个小数据集中，有 52 个用户产生了争议。流失概率<strong class="lb iu"> 23.11% </strong>。</p><h2 id="e2e8" class="my lw it bd lx ne nf dn mb ng nh dp mf li ni nj mh lm nk nl mj lq nm nn ml no bi translated"><strong class="ak">用户活动</strong></h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/037ad03c6ee0fd288f741aa21e139095.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*gFEzyLjPrhxo8GxnVmOMaw.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用户 _ 活动</p></figure><p id="65db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了播放歌曲，用户还可以对歌曲进行评级，更改设置和添加朋友。Sparkify 上互动越多的用户对平台的粘性越大吗？用户会因为订阅了太多他们不喜欢的歌曲而离开吗？</p><p id="eec5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了回答这些问题，我们在特性中添加了<code class="fe np nq nr mu b">interactions, thumbs_down</code>。</p><h2 id="fd5d" class="my lw it bd lx ne nf dn mb ng nh dp mf li ni nj mh lm nk nl mj lq nm nn ml no bi translated"><strong class="ak">活动日期</strong></h2><p id="8b2f" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">数据集中的日期范围是从<code class="fe np nq nr mu b">2018-09-30</code>到<code class="fe np nq nr mu b">2018-12-02</code>。我们可以看到，付费层和免费层在开始时具有相似的用户会话数量和不同的用户，然后<strong class="lb iu">随着时间的推移，付费层的两个指标都增加了</strong>，而免费用户的指标则减少了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/80a6cb55f523648edb5b98ba6bbe968b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0VcCpjfVAvxkIQeWae1d8Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一段时间内的用户活动</p></figure><h2 id="e0f5" class="my lw it bd lx ne nf dn mb ng nh dp mf li ni nj mh lm nk nl mj lq nm nn ml no bi translated"><strong class="ak">用户年龄(自注册后)</strong></h2><p id="a252" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">用户在 Sparkify 上停留多长时间后就会流失？从用户流失时的年龄直方图中，我们可以看到大多数流失发生在注册后的 100 天内。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/f88019fc8039b5e6989223d4be93e5be.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/format:webp/1*hQGhSr97C90pv9xhut1Vug.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">流失时的用户年龄</p></figure><h1 id="69cb" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">特征选择</h1><p id="3197" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">探索数据集后，选择了 11 个要素进行进一步分析:</p><p id="1111" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">用户信息:</strong>性别，用户 _ 年龄，付费 _ 用户，降级</p><p id="f9a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">活动测量:</strong>艺术家、歌曲、长度、互动、拇指向下、总时段、时段间隙</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/864a972c09c833e59f284425be7c0df9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*_9UIkTxhqSHo3zwXZMskCQ.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">壮举直方图</p></figure><h2 id="fe14" class="my lw it bd lx ne nf dn mb ng nh dp mf li ni nj mh lm nk nl mj lq nm nn ml no bi translated"><strong class="ak">相关性矩阵</strong></h2><ul class=""><li id="7db2" class="nw nx it lb b lc mo lf mp li ny lm nz lq oa lu ob oc od oe bi translated">除了<code class="fe np nq nr mu b">user_age</code>之外<code class="fe np nq nr mu b">cancelled</code>没有明显的强预测因子</li><li id="5681" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated"><code class="fe np nq nr mu b">songs, interactions, thumbs_down, length, artists</code>根据直方图非常相似。尽管它们都显示出彼此之间的高度相关性，但这可能是由小数据集(225 个用户)造成的。如果我们有更多的数据，我们可能会看到更多的用户行为差异。因此，我们将只排除<code class="fe np nq nr mu b">songs</code>和<code class="fe np nq nr mu b">artists </code>，因为它们总是与<code class="fe np nq nr mu b">length</code>相似。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/ae137ac82b479f45c97b14da2473e284.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*EB7JecxqYSFpcA5sZcNnJw.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">特征相关性(皮尔逊)</p></figure><h1 id="587c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">造型</strong></h1><p id="59e3" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">要使用 PySpark 中的功能，需要将这些功能组合成矢量，然后使用 StandardScaler 进行归一化:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="f608" class="my lw it mu b gy mz na l nb nc">assembler = VectorAssembler(inputCols=['female','user_age','paid_user',\<br/>                                       'downgraded','total_session','interactions',\<br/>                                      'thumbs_down','length','session_gap'],\<br/>                            outputCol='NumFeatures',handleInvalid = 'skip')</span><span id="8d05" class="my lw it mu b gy ol na l nb nc">standardscaler = StandardScaler(inputCol="NumFeatures", outputCol="features", withMean=True, withStd=True)</span></pre><p id="fac0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，数据被分成测试集和验证集:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="f526" class="my lw it mu b gy mz na l nb nc">test, validation = data.randomSplit([0.8, 0.2], seed=42)</span></pre><h2 id="ca15" class="my lw it bd lx ne nf dn mb ng nh dp mf li ni nj mh lm nk nl mj lq nm nn ml no bi translated"><strong class="ak">型号选择</strong></h2><p id="4b27" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">因为我们预测用户是否有流失的风险(1/0)，所以预测是一个<strong class="lb iu">分类问题</strong>。4 种分类算法用于初始训练:</p><ul class=""><li id="b6de" class="nw nx it lb b lc ld lf lg li om lm on lq oo lu ob oc od oe bi translated">逻辑回归</li><li id="bf65" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated">随机森林</li><li id="0266" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated">线性支持向量分类器</li><li id="17fe" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated">梯度增强树分类器</li></ul><h2 id="af38" class="my lw it bd lx ne nf dn mb ng nh dp mf li ni nj mh lm nk nl mj lq nm nn ml no bi translated"><strong class="ak">模型拟合</strong></h2><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="fe50" class="my lw it mu b gy mz na l nb nc">def fit_model(model, paramGrid = None):<br/>    # Model fitting with selected model and paramgric(optional)<br/>    # Input: model, paramgrid<br/>    # Output: fitted model, prediction on validation set<br/>    pipeline = Pipeline(stages=[standardscaler, model])<br/>    <br/>    if paramGrid != None:<br/>        crossval = CrossValidator(estimator=pipeline,<br/>                          estimatorParamMaps=paramGrid,<br/>                          evaluator=MulticlassClassificationEvaluator(),<br/>                          numFolds=3)<br/>        fitmodel = crossval.fit(test)<br/>    else:<br/>        fitmodel = pipeline.fit(test)<br/>    <br/>    results = fitmodel.transform(validation)<br/>    <br/>    return fitmodel, results</span></pre><p id="760a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了找到最佳的模型和参数，我们使用<strong class="lb iu"> CrossValidator </strong>来评估模型性能并验证模型的健壮性。使用<code class="fe np nq nr mu b">numFolds = 3</code>，CrossValidator 生成 3 组训练/测试对，每组使用 2/3 的数据进行训练，1/3 的数据进行测试。为了评估特定的模型/参数选择，CrossValidator 计算适合 3 个训练/测试对的 3 个模型的平均评估指标。</p><h2 id="cb5e" class="my lw it bd lx ne nf dn mb ng nh dp mf li ni nj mh lm nk nl mj lq nm nn ml no bi translated">模型评估</h2><p id="819c" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">为了对模型进行评估，我们通过验证数据上的模型预测的<strong class="lb iu"> f1_score、</strong>准确度、精确度和召回率对算法进行了比较。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/2d40c03c86e795e950b85f738b0c8b68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/format:webp/1*yG6Z50YnYYM6V5NoENbcTg.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">验证数据的模型性能</p></figure><p id="53d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> f1-score: </strong>精度和召回率的调和平均值。</p><p id="a5f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">准确度</strong>:(真阳性+真阴性)/所有预测</p><p id="91ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">精度</strong>:真阳性/(真阳性+假阳性)</p><p id="d87d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">回忆:</strong>真阳性/(真阳性+假阴性)</p><p id="de90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们在一个小的数据集上工作，所以我们需要一个具有精确度和召回率的平衡模型。我们将使用<strong class="lb iu"> f1 分数</strong>来选择最佳型号。</p><p id="ffdc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">逻辑回归</strong>表现最好，F 值= 0.83 。它预测验证集中的<strong class="lb iu"> 44% </strong>的流失和<strong class="lb iu"> 100% </strong>的流失预测是正确的。根据系数，对客户流失影响最大的前 5 个特征是:</p><ul class=""><li id="8f84" class="nw nx it lb b lc ld lf lg li om lm on lq oo lu ob oc od oe bi translated">会话间隔、总会话、拇指向下、用户年龄、长度</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/4730702728908e678b42a65dcc1c62c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*B42PS1Ktcnx9ua_uCAKUSg.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">逻辑回归系数</p></figure><p id="6cae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">随机森林</strong>也表现不错<strong class="lb iu"> F 值= 0.73 </strong>。由于 RF 在大型数据集中具有更强的预测能力，因此也值得用完整数据调整随机森林模型。根据随机森林功能的重要性，前 5 位功能是:</p><ul class=""><li id="f3f5" class="nw nx it lb b lc ld lf lg li om lm on lq oo lu ob oc od oe bi translated">用户年龄、会话间隔、总会话、拇指向下、交互</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/825dc6e1d644e186a40dced37b1ae90c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1074/format:webp/1*SbbjW3Lh1WJdJvHGvQSiLA.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">随机森林要素重要性</p></figure><p id="2b0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">LSVC 在这个数据集上表现不佳。<strong class="lb iu">召回</strong> <strong class="lb iu">为 0 </strong>，这意味着它无法识别任何流失。</p><p id="ae07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">梯度提升树</strong>的 F 值略高于 LSVC，但也存在召回率低的问题。</p><h1 id="7dfc" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">通过处理不平衡数据改进模型</strong></h1><p id="5c56" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在我们的数据集中，客户流失的结果是不平衡的(23%)，这损害了模型的实际预测能力(参见 LSVC，盲目地将一切赋值为 0 仍将得到 0.6 的 f1 分)。</p><p id="0652" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于逻辑回归，有多种方法来处理不平衡数据。在这项研究中，我们将尝试两种解决方案:</p><ul class=""><li id="a0db" class="nw nx it lb b lc ld lf lg li om lm on lq oo lu ob oc od oe bi translated">设置类别权重</li><li id="8458" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated">设置不同的阈值</li></ul><h2 id="2981" class="my lw it bd lx ne nf dn mb ng nh dp mf li ni nj mh lm nk nl mj lq nm nn ml no bi translated"><strong class="ak">py spark 中的类权重</strong></h2><p id="715d" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我们想给正面的东西分配更高的权重(<code class="fe np nq nr mu b">cancelled == 1</code>)。生成类权重:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="b1a0" class="my lw it mu b gy mz na l nb nc">balancingRatio = data.filter(col(‘label’) == 1).count() / data.count()</span><span id="b375" class="my lw it mu b gy ol na l nb nc">calculateWeights = udf(lambda x: 1 * balancingRatio if x == 0 else (1 * (1.0 — balancingRatio)), DoubleType())</span><span id="bb41" class="my lw it mu b gy ol na l nb nc">weightedDataset = data.withColumn(“classWeightCol”, calculateWeights(‘label’))</span></pre><p id="5a3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用 classWeightCol 重新拟合逻辑回归模型:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="04d8" class="my lw it mu b gy mz na l nb nc">lrweightedmodel, lrweightedresults = fit_model(lr.setWeightCol(‘classWeightCol’))</span><span id="203d" class="my lw it mu b gy ol na l nb nc">print(“LogisticRegression with weight: f1 score,accuracy,precision,recall”, val_evaluation(lrweightedresults))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/4f7ab34e6a8867ad597fbcf03fb60cf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nI22CkCPuTOXt8Cc343BYw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">具有类别权重结果的逻辑回归</p></figure><p id="e108" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哇！使用类权重重新平衡数据集在小数据集中非常有效，这将 f1 分数增加到<strong class="lb iu"> 0.85 </strong>，召回到<strong class="lb iu"> 0.67 </strong>。</p><h2 id="84e7" class="my lw it bd lx ne nf dn mb ng nh dp mf li ni nj mh lm nk nl mj lq nm nn ml no bi translated">最佳阈值</h2><p id="02b2" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">另一种平衡数据的方法是设置不同的阈值来进行正面预测。</p><p id="af16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在当前逻辑回归模型中通过 f-score 找到最佳阈值:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="ee6b" class="my lw it mu b gy mz na l nb nc">fMeasure = trainingSummary.fMeasureByThreshold<br/>maxFMeasure = fMeasure.groupBy().max('F-Measure').select('max(F-Measure)').head()<br/>bestThreshold = fMeasure.where(fMeasure['F-Measure'] == maxFMeasure['max(F-Measure)']) \<br/>    .select('threshold').head()['threshold']</span></pre><p id="5b1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当前模型的最佳阈值为<strong class="lb iu"> 0.27 </strong>。这似乎有点过于严格，可能会导致大型数据集中的低精度。为了测试不同阈值的有效性，我们可以使用 paramGrid 来拟合阈值在[0.3，0.4，0.5]的模型。</p><h1 id="8d51" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><ul class=""><li id="d701" class="nw nx it lb b lc mo lf mp li ny lm nz lq oa lu ob oc od oe bi translated">对于 Sparkify 订阅，样本数据集中的整体流失率为<strong class="lb iu"> 23% </strong>。大多数搅动发生在注册后的 100 天内。</li><li id="d4c7" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated">除了用户年龄，<strong class="lb iu">他们使用 Sparkify 服务<code class="fe np nq nr mu b">(session_gap, total_session</code>的频率</strong>，以及<strong class="lb iu">他们在使用平台<code class="fe np nq nr mu b">thumbs_down, interactions</code>时的活跃程度</strong>也对他们是否会流失有很大影响。</li><li id="af27" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated"><strong class="lb iu">带类别权重的 Logistic 回归模型</strong>对 f1-score = 0.85 的小数据集的预测能力最强。它能够以 75%的精度预测验证集中的 67%的搅动(75%的预测用户实际搅动)。</li></ul><h2 id="7992" class="my lw it bd lx ne nf dn mb ng nh dp mf li ni nj mh lm nk nl mj lq nm nn ml no bi translated">我们学到了什么</h2><ul class=""><li id="7e9b" class="nw nx it lb b lc mo lf mp li ny lm nz lq oa lu ob oc od oe bi translated">正确地清理和处理数据不仅可以提高模型性能，还可以提高管道的操作效率和可伸缩性。对于 Sparkify mini 数据，我们将 268k 个事件级记录聚合为 225 个用户级记录，其大小是原始数据的 0.1%。</li><li id="1ee0" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated">理解您的数据是数据科学项目成功的关键。从 18 个原始字段中，我们只选择了与用户行为相关的指标，并创建了 11 个特性。然后，我们进一步根据相关性将数据精简为 9 个具有独特特征的特征，以训练模型。</li></ul><h2 id="8178" class="my lw it bd lx ne nf dn mb ng nh dp mf li ni nj mh lm nk nl mj lq nm nn ml no bi translated">挑战</h2><ul class=""><li id="c51e" class="nw nx it lb b lc mo lf mp li ny lm nz lq oa lu ob oc od oe bi translated"><strong class="lb iu">季节性</strong>:我们使用的数据只包含两个月的数据，这意味着分析可能会因季节性而有偏差。</li><li id="dc2e" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated"><strong class="lb iu">小数据集</strong>:在没有进行所有探索性分析的情况下，管道在我的本地机器上运行需要 2 个多小时。如果我们在两个月内收集了 12 GB 的用户数据，这意味着我们只在 0.6 天的数据量上训练我们的模型。假设业务随着时间的推移而增长，在本地运行管道是不可伸缩的。</li></ul><h1 id="ecfb" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">下一步是什么？</h1><h2 id="bcec" class="my lw it bd lx ne nf dn mb ng nh dp mf li ni nj mh lm nk nl mj lq nm nn ml no bi translated">超参数调谐</h2><ul class=""><li id="89e2" class="nw nx it lb b lc mo lf mp li ny lm nz lq oa lu ob oc od oe bi translated">从这个小数据集，我们知道<strong class="lb iu">逻辑回归</strong>和<strong class="lb iu">随机森林</strong>模型对于预测我们数据的变动是很好的。我们可以通过使用网格搜索调整超参数来进一步改进模型。</li><li id="6175" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated">目前的模型提供了良好的 f1 分数和准确性，但相对而言<strong class="lb iu">召回率</strong>较低，这意味着我们没有捕捉到所有有风险的用户。</li><li id="23d4" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated">我们想要如何评估模型取决于我们想要回答什么样的业务问题:例如，如果我们想要研究<strong class="lb iu">什么类型的用户更有可能流失</strong>，那么我们将需要好的<strong class="lb iu"> f1-score </strong>。如果我们想<strong class="lb iu">找到所有有风险的用户</strong>并试图让他们留下来，那么<strong class="lb iu">召回率</strong>就变得更加重要。</li></ul><h2 id="c1be" class="my lw it bd lx ne nf dn mb ng nh dp mf li ni nj mh lm nk nl mj lq nm nn ml no bi translated">使用完整数据集将管道部署到 AWS EMR</h2><p id="8355" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">AWS EMR(Elastic MapReduce)为 Spark 提供了一个高性能环境。下一步，我们将部署我们的管道 AWS EMR。然后，我们将能够使用完整的数据训练模型，并使用超参数调整来改进模型。</p><p id="1781" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ot">你最喜欢的客户流失预测解决方案是什么？你有什么建议可以让这个项目做得更好？请在下面留下你的想法吧！</em></p><p id="3be5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ot">所有脚本和结果都包含在</em> <a class="ae ky" href="https://github.com/estella-zzz/sparkify_churn_prediction" rel="noopener ugc nofollow" target="_blank"> <em class="ot">项目 git repo </em> </a> <em class="ot">中。</em></p><h1 id="aaf1" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">参考</h1><ul class=""><li id="c2d8" class="nw nx it lb b lc mo lf mp li ny lm nz lq oa lu ob oc od oe bi translated"><a class="ae ky" href="https://github.com/estella-zzz/sparkify_churn_prediction" rel="noopener ugc nofollow" target="_blank">项目 git 回购</a></li><li id="d1ad" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated"><a class="ae ky" href="https://spark.apache.org/docs/latest/api/python/pyspark.ml.html?highlight=stringindexer#pyspark.ml.classification.LogisticRegression" rel="noopener ugc nofollow" target="_blank"> PySpark ML 文档</a></li><li id="6ea0" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated"><a class="ae ky" href="https://stackoverflow.com/questions/33372838/dealing-with-unbalanced-datasets-in-spark-mllib" rel="noopener ugc nofollow" target="_blank">用 PySpark ML 分类重量</a></li><li id="32d5" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated"><a class="ae ky" href="https://aws.amazon.com/emr/features/spark/" rel="noopener ugc nofollow" target="_blank">亚马逊 EMR 上的 Apache Spark</a></li></ul></div></div>    
</body>
</html>