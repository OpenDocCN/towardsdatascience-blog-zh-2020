<html>
<head>
<title>Exchange Rate Prediction: Time Series Forecasting with ARIMA</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">汇率预测:用ARIMA进行时间序列预测</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/exchange-rate-prediction-time-series-forecasting-with-arima-27260faafcdc?source=collection_archive---------22-----------------------#2020-05-31">https://towardsdatascience.com/exchange-rate-prediction-time-series-forecasting-with-arima-27260faafcdc?source=collection_archive---------22-----------------------#2020-05-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0ca2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">利用之前的回归工作，这最后一部分旨在使用ARIMA预测未来汇率，这是一种“从过去预测未来”的机器学习算法。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d77284ae549317459463fb87c83d6483.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QKcLHePKOSLThuMkzE0keg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:https://unsplash.com/photos/6EnTPvPPL6I</p></figure><p id="0ff8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我的数据科学端到端项目的<strong class="ky ir">最后部分</strong>来了。如果您遵循或阅读了前两部分，您可能已经知道本文中会出现什么。但是如果你还没有，不要犹豫去看看它们:<a class="ae kv" href="https://medium.com/analytics-vidhya/exchange-rate-prediction-part-1-276b6cd5338" rel="noopener"> <strong class="ky ir">第一部分</strong> </a>和<a class="ae kv" rel="noopener" target="_blank" href="/exchange-rate-prediction-machine-learning-with-5-regression-models-d7a3192531d"> <strong class="ky ir">第二部分</strong> </a>。</p><p id="886a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是这个项目整体结构的总结:</p><ul class=""><li id="ab46" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><strong class="ky ir">第1部分</strong>:解释性数据分析(EDA) &amp;数据可视化(奖励:假设检验)</li><li id="5bcb" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir">第二部分</strong>:4个回归模型的机器学习</li><li id="bfd7" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">第三部分:机器学习(续。)与ARIMA </li></ul><p id="73e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一部分通过数据清理和可视化为分析奠定基础，第二部分采用回归模型拟合所有数据点，最后一部分将利用它们来<strong class="ky ir">预测未来</strong>(在这种情况下，是2020年的澳元/美元汇率)。为了做到这一点，应考虑先决条件和流程:</p><ol class=""><li id="800e" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr mg ly lz ma bi translated">静态测试(ADF和KPSS)</li><li id="2a4f" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr mg ly lz ma bi translated">自相关(ACF)和部分自相关(PACF)</li><li id="31ae" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr mg ly lz ma bi translated">ARIMA天气预报</li></ol><p id="add3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们开始吧！</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><p id="6294" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在开始之前，您可能想知道为什么在使用ARIMA之前我们需要遵循上面提到的结构。如果是，让我们简单了解一下ARIMA是什么，需要什么优先！</p><h1 id="4d0f" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">0.简而言之ARIMA</h1><p id="4c3f" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">ARIMA代表什么？</p><p id="b682" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在预测时间序列时，我们可以选择:</p><ul class=""><li id="5eee" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><strong class="ky ir">单变量</strong>:如果我们相信时间序列的先前值能够预测其未来值</li><li id="a905" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir">多变量</strong>:如果我们使用预测器而不是序列本身来预测未来值</li></ul><p id="faad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，ARIMA代表<em class="nl">‘自回归综合移动平均’</em>，这种算法源于这样一种信念，即时间序列的<strong class="ky ir"> <em class="nl">过去值可以单独用于预测未来值</em> </strong>。</p><p id="7c07" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要使用ARIMA，我们需要确定它的参数值:p，d，q</p><ul class=""><li id="159b" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">p:AR项的阶数(AR:自回归)</li><li id="ebf0" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">d:差异的数量</li><li id="75c7" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">问:移动平均线的顺序</li></ul><p id="87ab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这几乎是你熟悉下面将要发生的事情所需要的全部信息。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="ef52" class="mo mp iq bd mq mr nm mt mu mv nn mx my jw no jx na jz np ka nc kc nq kd ne nf bi translated">1.静态测试</h1><p id="be1f" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">什么是静态测试，我们为什么需要它？</p><p id="d416" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">ARIMA要求数据集是“<strong class="ky ir">稳定的</strong>，这样模型才能产生准确的预测。简而言之，从技术上讲，平稳序列不会随时间而变化。特别是，<strong class="ky ir">均值、方差、协方差等参数随时间</strong>保持不变。</p><p id="14d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了更直观地展示它，我们来看看下面的图表，看看平稳数据和非平稳数据之间的区别:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/bd9428571d3e76aad78467e8cfb583b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*ID13ocl51akBidzW.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:<a class="ae kv" href="https://en.wikipedia.org/wiki/Stationary_process" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Stationary_process</a></p></figure><p id="c3f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，这并不意味着数据集在任何特定时间点都是“冻结”的。它确实发生了变化，但随着时间的推移，其均值和方差保持不变(图1)。<strong class="ky ir">与</strong>相反，如果看到这种不寻常的峰值或谷值(没有清晰的模式)，这意味着数据集及其统计属性会随着时间而变化(图2)。众所周知，这是由于趋势或季节性对数据集的影响。</p><p id="e52c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想探究这两者在数学上的区别，可以看看这篇关于数据科学的文章:</p><div class="ns nt gp gr nu nv"><a rel="noopener follow" target="_blank" href="/stationarity-in-time-series-analysis-90c94f27322"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd ir gy z fp oa fr fs ob fu fw ip bi translated">时间序列分析的平稳性</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">平稳性的概念和类型综述</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">towardsdatascience.com</p></div></div><div class="oe l"><div class="of l og oh oi oe oj kp nv"/></div></div></a></div><p id="8008" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">静态数据很重要，因为模型更容易学习模式，我们也更容易分析和预测模式，这已经成为大多数时间序列分析中的一个常见假设。</p><p id="f8d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">话虽如此，我们如何知道数据集是否是静态的呢？首先，我们可以依靠<strong class="ky ir">统计测试</strong>来检查平稳性，如果不是，我们需要将数据从非平稳转换为平稳。</p><p id="dfd8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> ADF </strong>(增广的迪基-富勒)和<strong class="ky ir"> KPSS </strong>(科维亚特科夫斯基-菲利普斯-施密特-申)是两种常见的平稳性统计测试。这两个测试的目的在技术上是相同的，只是后面使用的技术不同。ADF使用差分来转换数据集，<strong class="ky ir"> KPSS移除趋势</strong>使数据稳定。因此，建议使用这两种测试来确保预期的结果。</p><p id="740d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，需要注意的一点是，H0(零假设)和H1(替代假设)的两个检验是彼此相反的:</p><ul class=""><li id="ad19" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">ADF:  H0声称数据集是<strong class="ky ir">而不是</strong>静止的，而H1说它是静止的。</li><li id="8888" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir"> KPSS </strong> : H0声称数据集是静止的，而H1却说它是<strong class="ky ir">而不是</strong>。</li></ul><pre class="kg kh ki kj gt ok ol om on aw oo bi"><span id="93da" class="op mp iq ol b gy oq or l os ot">from statsmodels.tsa.stattools import adfuller</span><span id="9b95" class="op mp iq ol b gy ou or l os ot">adf_test = adfuller(y_pred)<br/>print('stat=%.3f, p=%.3f' % adf_test[0:2])<br/>if adf_test[1] &gt; 0.05:<br/> print('Probably not Stationary')<br/>else:<br/> print('Probably Stationary')</span></pre><p id="8e4d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">ADF测试结果:<strong class="ky ir"> stat=-0.434，p = 0.904—‘可能不稳定’</strong></p><pre class="kg kh ki kj gt ok ol om on aw oo bi"><span id="99ac" class="op mp iq ol b gy oq or l os ot">from statsmodels.tsa.stattools import kpss</span><span id="9d9d" class="op mp iq ol b gy ou or l os ot">kpss_test = kpss(y_pred, nlags='auto')</span><span id="bbdb" class="op mp iq ol b gy ou or l os ot">print('stat=%.3f, p=%.3f' % kpss_test[0:2])<br/>if kpss_test[1] &gt; 0.05:<br/>    print('Probably Stationary')<br/>else:<br/>    print('Probably not Stationary')</span></pre><p id="7cdb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">KPSS检验结果:<strong class="ky ir"> stat=0.692，p = 0.014——“可能不平稳”</strong></p><p id="df23" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">原来数据集根本不是静止的！让我们直观地看一下:</p><pre class="kg kh ki kj gt ok ol om on aw oo bi"><span id="12eb" class="op mp iq ol b gy oq or l os ot">from statsmodels.tsa.seasonal import seasonal_decompose</span><span id="6fda" class="op mp iq ol b gy ou or l os ot">y_pred_list = y_pred.tolist()<br/>result = seasonal_decompose(y_pred_list, model='additive', period=1)</span><span id="211f" class="op mp iq ol b gy ou or l os ot">result.plot()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ov"><img src="../Images/97c4cf216cf2c810aeea7dba3e6f86b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1aqkGnOSxrvFGFsFtU5kfw.png"/></div></div></figure><p id="dbe9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> Seasonal_decompose </strong>告诉我们数据集在趋势、季节性和残差方面的表现。如您所见，观察值和趋势值之间的模式非常相似，这意味着趋势已经作为非平稳数据的原因介入其中。</p><p id="d80f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们再一次让它静止！！</p><pre class="kg kh ki kj gt ok ol om on aw oo bi"><span id="db02" class="op mp iq ol b gy oq or l os ot">date = list(range(1,37))<br/>date_fx = pd.DataFrame(zip(date, y_pred_list), columns=['Date', 'FX'])</span><span id="d069" class="op mp iq ol b gy ou or l os ot">date_fx_log = np.log(date_fx)</span><span id="809b" class="op mp iq ol b gy ou or l os ot">date_fx_log_diff = date_fx_log - date_fx_log.shift(1)<br/>date_fx_log_diff.dropna(inplace=True)</span><span id="27c6" class="op mp iq ol b gy ou or l os ot">y_stationary = date_fx_log_diff.iloc[:,1]</span></pre><p id="82f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，为了简单起见，我将实际日期替换为从1到36的数字范围(在我们的数据中代表36个月)。然后，为了稳定数据集，我用<strong class="ky ir"> np.log </strong>对原始数据进行了变换(这可以通过不同的方法完成:幂变换、平方根或对数变换)。最后，我用<strong class="ky ir">差分</strong>让数据与<strong class="ky ir">平稳。shift(1)，</strong>将数据集中的每个点减去其前面的点。</p><p id="efdc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好了，我们已经将非平稳的预测汇率(y_pred_list，如前一部分)转换为平稳的预测汇率(y_stationary)！</p><p id="7174" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们再次与ADF和KPSS确认一下！</p><pre class="kg kh ki kj gt ok ol om on aw oo bi"><span id="dcb1" class="op mp iq ol b gy oq or l os ot">#a. ADF Test<br/>adf_test_2 = adfuller(y_stationary)<br/>print('stat=%.3f, p=%.3f' % adf_test_2[0:2])<br/>if adf_test_2[1] &gt; 0.05:<br/> print('Probably not Stationary')<br/>else:<br/> print('Probably Stationary')</span><span id="03d8" class="op mp iq ol b gy ou or l os ot">#b. KPSS Test<br/>kpss_test_2 = kpss(y_stationary, nlags='auto')</span><span id="81b6" class="op mp iq ol b gy ou or l os ot">print('stat=%.3f, p=%.3f' % kpss_test_2[0:2])<br/>if kpss_test_2[1] &gt; 0.05:<br/>    print('Probably Stationary')<br/>else:<br/>    print('Probably not Stationary')</span></pre><p id="876e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">结果是:</p><ul class=""><li id="0595" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><strong class="ky ir"> ADF: </strong> stat=-5.316，p=0.000，可能是平稳的</li><li id="df3e" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir"> KPSS </strong> : stat=0.192，p=0.100，可能是静止的</li></ul><p id="2b00" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">耶！</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="bb40" class="mo mp iq bd mq mr nm mt mu mv nn mx my jw no jx na jz np ka nc kc nq kd ne nf bi translated">2.自相关(ACF)和部分自相关(PACF)</h1><p id="9f82" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated"><em class="nl">什么是ACF和PACF，它们与ARIMA有什么关系？</em></p><p id="3686" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在使数据集稳定后，我们继续该过程的第二步:为ARIMA模型确定<strong class="ky ir"> p，d，q </strong>。这可以通过观察ACF和PACF图来实现！</p><p id="45c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据<a class="ae kv" href="https://machinelearningmastery.com/gentle-introduction-autocorrelation-partial-autocorrelation/" rel="noopener ugc nofollow" target="_blank">机器学习掌握度</a>，</p><blockquote class="ow ox oy"><p id="21e2" class="kw kx nl ky b kz la jr lb lc ld ju le oz lg lh li pa lk ll lm pb lo lp lq lr ij bi translated">这些图以图形方式总结了一个时间序列中的观察值与之前时间步长中的观察值之间的关系强度。</p></blockquote><p id="6c43" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这与我们之前完成的步骤之一完全一致:<strong class="ky ir">区别于。</strong>转变①！如果您还记得的话，我们已经采用了shift作为将当前值减去前一个值的方法，以使数据保持稳定。事实上，ACF和PACF能做的不仅仅是差异化！</p><p id="4e3d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们把它们画出来:</p><pre class="kg kh ki kj gt ok ol om on aw oo bi"><span id="ee46" class="op mp iq ol b gy oq or l os ot">from statsmodels.graphics.tsaplots import plot_acf, plot_pacf</span><span id="f84c" class="op mp iq ol b gy ou or l os ot">date_fx_log_diff = date_fx_log_diff.values.reshape(-1)</span><span id="01a9" class="op mp iq ol b gy ou or l os ot">plot_acf(date_fx_log_diff, lags=50)<br/>plot_pacf(date_fx_log_diff, lags=50)</span><span id="7a33" class="op mp iq ol b gy ou or l os ot">plt.show()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pc"><img src="../Images/bbb3a7921323e3f523ac1e78a498617b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fL9qy2M_Jdwzd7zoB657Ng.png"/></div></div></figure><p id="ae31" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">基于ACF和PACF的形状和图案，我们可以确定ARIMA模型的p (AR项)和q (MA项)。如果你想深入研究，可以看看这些文章<a class="ae kv" href="https://support.minitab.com/en-us/minitab/18/help-and-how-to/modeling-statistics/time-series/how-to/autocorrelation/interpret-the-results/autocorrelation-function-acf/" rel="noopener ugc nofollow" target="_blank">这里</a>和<a class="ae kv" href="https://support.minitab.com/en-us/minitab/18/help-and-how-to/modeling-statistics/time-series/how-to/partial-autocorrelation/interpret-the-results/partial-autocorrelation-function-pacf/" rel="noopener ugc nofollow" target="_blank">这里</a>。本质上，图表中显著滞后的数量“传递了信息”，在这种情况下是p &amp; q的值。</p><p id="10e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如您在ACF图中看到的，在滞后1中看到一个大尖峰，随后是2或3个滞后，所有滞后都被认为是显著的，因为它们位于“极限阈值”或“显著性线”(蓝色区域)之上。同样地，在PACF的图中，在第一个时间出现一个大的峰值，然后在第三个时间出现另一个峰值。那么这一切意味着什么呢？</p><p id="1e0f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对我来说，这一发现是测试哪种(p，d，q)组合对我们的ARIMA模型产生最佳结果的关键，其中p可以在ACF中找到，而q在PACF。那么具体是什么<strong class="ky ir"> <em class="nl">结果</em> </strong>呢？是AIC。</p><blockquote class="ow ox oy"><p id="bd07" class="kw kx nl ky b kz la jr lb lc ld ju le oz lg lh li pa lk ll lm pb lo lp lq lr ij bi translated">赤池信息标准(AIC)是一种广泛使用的统计模型的措施。它基本上将模型的1)拟合优度和2)简单性/简约性量化为单个统计数据。—阿巴斯·凯什瓦尼，<a class="ae kv" href="https://coolstatsblog.com/2013/08/14/using-aic-to-test-arima-models-2/" rel="noopener ugc nofollow" target="_blank">酷派博客</a></p></blockquote><p id="5fb5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一般来说，AIC越低越好。让我们转到第3部分，看看哪种组合的AIC最低！</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="eabb" class="mo mp iq bd mq mr nm mt mu mv nn mx my jw no jx na jz np ka nc kc nq kd ne nf bi translated">3.ARIMA预测</h1><p id="1b82" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated"><em class="nl">让我们将p、d、q的值代入我们的ARIMA模型！</em></p><p id="8d2d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我前面解释的，ACF和PACF图中的显著滞后的数量可以转化为相应的p &amp; q。让我们看看ARIMA在下列值下的情况:</p><ul class=""><li id="4591" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">p = 3，因为ACF中有3个显著滞后</li><li id="75ac" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">根据中的计算，d = 1。移位(1)</li><li id="001f" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">q =2为PACF的2个显著滞后</li></ul><pre class="kg kh ki kj gt ok ol om on aw oo bi"><span id="7ae6" class="op mp iq ol b gy oq or l os ot">from statsmodels.tsa.arima_model import ARIMA</span><span id="74ef" class="op mp iq ol b gy ou or l os ot">y = date_fx_log.iloc[:, 1]</span><span id="73fe" class="op mp iq ol b gy ou or l os ot">model_arima = ARIMA(y, (3,1,2))<br/>model_arima_fit = model_arima.fit()<br/>print(model_arima_fit.summary())</span></pre><p id="9b06" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们从Statsmodels库中导入ARIMA，并从转换后的数据集中提取y。然后，我们用(p，d，q)的上述值拟合ARIMA模型，称为<strong class="ky ir">。概要()</strong>:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/afaab34e324468a40b6183bd8d19a781.png" data-original-src="https://miro.medium.com/v2/resize:fit:1334/format:webp/1*zueKl95wxV2IYXiBj-aEmQ.png"/></div></figure><p id="850f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管看起来很复杂，但我们只需关注表中的两个指标:AIC和P值(P&gt;|z|)。</p><ul class=""><li id="69f3" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">AIC = -183.227，我们将对p，d，q的另一个组合进行测试，看它是否是最低值。</li><li id="5d23" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">p = 3时，模型为不同行中的每个AR返回3个不同的p值。虽然前两个的p值<strong class="ky ir">为&lt; 0.05 </strong>(这是理想的推荐值)，但AR。L3的高于0.05。这意味着在ACF图中实际上可能有2个明显的滞后。</li></ul><p id="296b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">基于这个发现，让我们测试(p，d，q) = (2，1，2)的另一个组合:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pe"><img src="../Images/d5d233271c5bfc379aaea8062d06d2da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4zFIIw7Vaw_xjyxk-tlglw.png"/></div></div></figure><p id="709c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，AIC (-183.096)与第一个模型的AIC (-183.227)相比没有改善。此外，AR的p值。、马。L1(第一个q)大于0.05，这表明我们可能只需要p=1和q=1。让我们用(p，d，q) = (1，1，1)来测试一下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pf"><img src="../Images/fa2312de6f728d7361a037776f651f1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uPOf6AW8r5O3e67gzAaanw.png"/></div></div></figure><p id="12c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">答对了。AIC已经改进了很多，因为它是三次试验(最低AIC和所有p值&lt;0.05).</p><p id="8d68" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Okay, this process has been a bit too manual and time-consuming. How about we use <strong class="ky ir">与for循环</strong>的迭代，看看哪个组合(p，d，q)产生最低AIC)后的最佳值。</p><pre class="kg kh ki kj gt ok ol om on aw oo bi"><span id="eb97" class="op mp iq ol b gy oq or l os ot">import itertools</span><span id="2504" class="op mp iq ol b gy ou or l os ot">p = range(1, 4)<br/>d = range(1, 2)<br/>q = range(1, 3)</span><span id="2c80" class="op mp iq ol b gy ou or l os ot">pdq = list(itertools.product(p, d, q))</span><span id="b237" class="op mp iq ol b gy ou or l os ot">aics = []<br/>params = []</span><span id="c980" class="op mp iq ol b gy ou or l os ot">for param in pdq:<br/>    model = ARIMA(y, order=param)<br/>    model_fit = model.fit()<br/>    aic = model_fit.aic<br/>    aics.append(aic)<br/>    params.append(param)</span><span id="0505" class="op mp iq ol b gy ou or l os ot">combo = list(zip(aics, params))<br/>combo.sort()</span><span id="8c3d" class="op mp iq ol b gy ou or l os ot">combo_array = np.array(combo)<br/>print(combo_array)</span></pre><p id="29d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如上所述，我根据ACF和PACF图创建了p、d和q的不同范围:</p><ul class=""><li id="04db" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">p = range(1，4):因为在ACF中看到3个滞后</li><li id="4626" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">d = range(1，2):因为我们至少需要1次差分来使数据稳定</li><li id="425c" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">q = range(1，3):因为在PACF看到两个滞后</li></ul><p id="aa38" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我使用<strong class="ky ir"> itertools.product() </strong>从给定的值生成不同的组合。最后，我为循环应用了一个<strong class="ky ir">，并用生成的每个组合来拟合ARIMA模型。</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/54c65c5546087508ac0f42c79ee40efb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*jJsI96CWWG220kE4sCD7Tg.png"/></div></figure><p id="8bba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以你看，从(1，1，1)的(p，d，q)来看，最低的AIC是-185.892，与上面的最新试验相同！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pf"><img src="../Images/fa2312de6f728d7361a037776f651f1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uPOf6AW8r5O3e67gzAaanw.png"/></div></div></figure><p id="6e94" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，也是最后一步，预测:</p><pre class="kg kh ki kj gt ok ol om on aw oo bi"><span id="9800" class="op mp iq ol b gy oq or l os ot">pred = model_arima_fit.forecast(12, alpha=0.05)[0]<br/>print(pred)</span><span id="a624" class="op mp iq ol b gy ou or l os ot">model_arima_fit.plot_predict(1,42)</span></pre><p id="4f8d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简单说一下，<strong class="ky ir">。forecast() </strong>包括<strong class="ky ir">我们需要预测的值的数量</strong>(在本例中，数据集周期之后的2020年的12个月)和<strong class="ky ir"> alpha=0.05 </strong>作为95%置信区间。plot_predict(1，42)作为整个预测数据集的(start，end )(在本例中，1表示第一个月2017年1月，2表示最后一个月2020年12月)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ph"><img src="../Images/bdc6fc1a23895cbd133d34d7b4adb6c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fycP6prWcEVR5Dg621yEwQ.png"/></div></div></figure><p id="3bdb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于我们y值(橙色)和预测(蓝色)的匹配度，看起来还不错！事实上，如果你回想一下多项式回归的图表，预测(蓝色)与我们发现的曲线完全吻合！</p><p id="1fd9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">塔达！我们已经预测了2020年的汇率，这个项目快结束了。如果打印预测值，您可能会觉得奇怪:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/3bafab26ed40cfe4f0c9693d963128ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*IbYJct1SDG8zf-lfnC7zwQ.png"/></div></figure><p id="0767" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是因为预测值来源于数据集，该数据集在运行该模型之前已经过<strong class="ky ir">的对数变换</strong>！借助于<strong class="ky ir">指数函数</strong>简单地恢复数值，这是对数的倒数。</p><pre class="kg kh ki kj gt ok ol om on aw oo bi"><span id="2306" class="op mp iq ol b gy oq or l os ot">pred = np.exp(pred)<br/>forecast = pred.tolist()</span><span id="06a1" class="op mp iq ol b gy ou or l os ot">fx_2020 = np.array(list(zip(month_year_future, forecast)))<br/>print(fx_2020)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/15059a6e00f80268fd2d7b7676441fa8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*W4CkjOhMh2o20Y8ngSNTdg.png"/></div></figure><p id="03f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完美！我们整体来形象化一下，2017年到2020年！</p><pre class="kg kh ki kj gt ok ol om on aw oo bi"><span id="b444" class="op mp iq ol b gy oq or l os ot">x_merge = ['2019-12', '2020-01']<br/>y_merge = [y_pred[-1], forecast[0]]</span><span id="daf2" class="op mp iq ol b gy ou or l os ot">plt.figure(figsize=(14,6))<br/>plt.scatter(month_year, y_fx, alpha=0.4)<br/>plt.plot(month_year, y_fx_predict, color='b')<br/>plt.plot(month_year, y_fx_predict_2, color='r')<br/>plt.plot(month_year, y_fx_predict_3, color='g')<br/>plt.plot(month_year, y_pred, color='black')<br/>plt.plot(x_merge, y_merge, color='y')<br/>plt.plot(month_year_future, forecast, color='y')<br/>plt.legend(['1var', '2var', '3var', '3var with Poly', 'Forecast'])<br/>plt.title("Linear Regression: AUD/USD Exchange Rate (3 var: Interest Rate, GDP &amp; UER)")<br/>plt.xlabel("Month-Year")<br/>plt.ylabel("Exchange Rate")<br/>plt.xticks(fontsize=5)<br/>plt.show()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pk"><img src="../Images/8e29a7e4747663effaa99ba27874de5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iR0cTWHUv3TjWJyg2q08xw.png"/></div></div></figure><p id="a3ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">瞧啊。！！</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><p id="646a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个项目到此结束——汇率预测！尽管有很多信息要吸收，我还是希望你能发现整个系列(<a class="ae kv" href="https://medium.com/analytics-vidhya/exchange-rate-prediction-part-1-276b6cd5338" rel="noopener"> <strong class="ky ir">第一部分</strong> </a>、<a class="ae kv" rel="noopener" target="_blank" href="/exchange-rate-prediction-machine-learning-with-5-regression-models-d7a3192531d"> <strong class="ky ir">第二部分</strong> </a>，以及这里的最后一部分)是有帮助的和信息丰富的！</p><p id="a02d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在不久的将来，一定要关注我的<strong class="ky ir">即将到来的数据科学和机器学习项目</strong>！与此同时，如果您觉得这有帮助，请给我一个掌声，并在这里随意查看我的Github以获得完整的资源库:</p><p id="1231" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">github:<a class="ae kv" href="https://github.com/andrewnguyen07" rel="noopener ugc nofollow" target="_blank">https://github.com/andrewnguyen07</a>T12】LinkedIn:<a class="ae kv" href="http://www.linkedin.com/in/andrewnguyen07" rel="noopener ugc nofollow" target="_blank">www.linkedin.com/in/andrewnguyen07</a></p><p id="7b58" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">谢谢！</p></div></div>    
</body>
</html>