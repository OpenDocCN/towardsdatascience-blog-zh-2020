<html>
<head>
<title>Images and masks splitting into multiple pieces in Python with Google Colab</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Google Colab 在 Python 中将图像和蒙版分割成多个部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/images-and-masks-splitting-into-multiple-pieces-in-python-with-google-colab-2f6b2ddcb322?source=collection_archive---------10-----------------------#2020-08-06">https://towardsdatascience.com/images-and-masks-splitting-into-multiple-pieces-in-python-with-google-colab-2f6b2ddcb322?source=collection_archive---------10-----------------------#2020-08-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2cd4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">图像和蒙版分割成更小部分的实际例子</h2></div><p id="c241" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">数据标注者使用特殊的标注工具来标注对象。例如，<a class="ae le" href="https://github.com/opencv/cvat" rel="noopener ugc nofollow" target="_blank">计算机视觉标注工具(CVAT) </a>在计算机视觉领域广为人知。自然，贴标机使用高分辨率图像会更方便。当您需要标记大量对象时尤其如此。</p><p id="6b87" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我参与的一个屋顶分割任务中，需要突出屋顶的三角形段、四边形段、其他段和边缘。下图显示了此类标记的一个示例(白色表示边，红色表示三角形，绿色表示四边形，蓝色表示其他多边形):</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/e62c501a028f64190a2b89dbc5baa380.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kam5rcIQhFLoOsXwQVe9GA.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">图像由 Oleksii Sheremet 使用<a class="ae le" href="https://matplotlib.org/" rel="noopener ugc nofollow" target="_blank"> matplotlib </a>模块创建</p></figure><p id="3427" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">原始图像是从谷歌地球获得的，像素为 2048x1208。数据标签员用 CVAT 以同样的分辨率对掩膜进行了标注。为了训练模型，图像和蒙版应该采用较低的分辨率(从 128x128 到 512x512 像素)。众所周知，图像分割是一种最常用于将大图像分割成较小部分的技术。因此，合理的解决方案是将图像及其对应的蒙版分割成具有相同分辨率的部分。</p><p id="2288" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所有用于拆分的代码都是在 Google Colab 中实现的。让我们仔细看看。导入库:</p><pre class="lg lh li lj gt lv lw lx ly aw lz bi"><span id="1cfa" class="ma mb it lw b gy mc md l me mf">import os<br/>import sys<br/>import shutil<br/>import glob<br/>import matplotlib.pyplot as plt<br/>import matplotlib.image as mpimg<br/>from PIL import Image</span></pre><p id="71a2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将 Google Drive(包含图片和蒙版)安装到 Google Colab:</p><pre class="lg lh li lj gt lv lw lx ly aw lz bi"><span id="18c7" class="ma mb it lw b gy mc md l me mf">from google.colab import drive<br/>drive.mount('/content/gdrive')<br/>%cd "gdrive/My Drive/File Folder"</span></pre><p id="372f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个用于创建新目录和递归删除现有目录内容的有用函数:</p><pre class="lg lh li lj gt lv lw lx ly aw lz bi"><span id="a75f" class="ma mb it lw b gy mc md l me mf">def dir_create(path):<br/>    if (os.path.exists(path)) and (os.listdir(path) != []):<br/>        shutil.rmtree(path)<br/>        os.makedirs(path)<br/>    if not os.path.exists(path):<br/>        os.makedirs(path)</span></pre><p id="3ed0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">覆盖原始图像的裁剪功能被调整到原始图像限制，并包含原始像素:</p><pre class="lg lh li lj gt lv lw lx ly aw lz bi"><span id="a33c" class="ma mb it lw b gy mc md l me mf">def crop(input_file, height, width):<br/>    img = Image.open(input_file)<br/>    img_width, img_height = img.size<br/>    for i in range(img_height//height):<br/>        for j in range(img_width//width):<br/>            box = (j*width, i*height, (j+1)*width, (i+1)*height)<br/>            yield img.crop(box)</span></pre><p id="e6ed" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将图像和蒙版分割成较小部分的功能(裁剪窗口的高度和宽度以及起始数字作为输入参数):</p><pre class="lg lh li lj gt lv lw lx ly aw lz bi"><span id="0e21" class="ma mb it lw b gy mc md l me mf">def split(inp_img_dir, inp_msk_dir, out_dir, height, width, <br/>          start_num):<br/>    image_dir = os.path.join(out_dir, 'images')<br/>    mask_dir = os.path.join(out_dir, 'masks')<br/>    dir_create(out_dir)<br/>    dir_create(image_dir)<br/>    dir_create(mask_dir)<br/>    img_list = [f for f in<br/>                os.listdir(inp_img_dir)<br/>                if os.path.isfile(os.path.join(inp_img_dir, f))]<br/>    file_num = 0<br/>    for infile in img_list:<br/>        infile_path = os.path.join(inp_img_dir, infile)<br/>        for k, piece in enumerate(crop(infile_path,<br/>                                       height, width), start_num):<br/>            img = Image.new('RGB', (height, width), 255)<br/>            img.paste(piece)<br/>            img_path = os.path.join(image_dir, <br/>                                    infile.split('.')[0]+ '_'<br/>                                    + str(k).zfill(5) + '.png')<br/>            img.save(img_path)<br/>        infile_path = os.path.join(inp_msk_dir,<br/>                                   infile.split('.')[0] + '.png')<br/>        for k, piece in enumerate(crop(infile_path,<br/>                                       height, width), start_num):<br/>            msk = Image.new('RGB', (height, width), 255)<br/>            msk.paste(piece)<br/>            msk_path = os.path.join(mask_dir,<br/>                                    infile.split('.')[0] + '_'<br/>                                    + str(k).zfill(5) + '.png')<br/>            msk.save(msk_path)<br/>        file_num += 1<br/>        sys.stdout.write("\rFile %s was processed." % file_num)<br/>        sys.stdout.flush()</span></pre><p id="c6dc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们设置必要的变量:</p><pre class="lg lh li lj gt lv lw lx ly aw lz bi"><span id="70aa" class="ma mb it lw b gy mc md l me mf">inp_img_dir = ‘./input_dir/images’<br/>inp_msk_dir = ‘./input_dir/masks’<br/>out_dir = ‘./output_dir’<br/>height = 512<br/>width = 512<br/>start_num = 1</span></pre><p id="83d7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们用原始图像和蒙版组成一个文件列表，并对它们进行拆分:</p><pre class="lg lh li lj gt lv lw lx ly aw lz bi"><span id="3dd8" class="ma mb it lw b gy mc md l me mf">input_images_list = glob.glob(inp_img_dir + ‘/*.jpg’)<br/>input_masks_list = glob.glob(inp_msk_dir + ‘/*.png’)<br/>split(inp_img_dir, inp_msk_dir, out_dir, height, width, start_num)</span></pre><p id="1881" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，使用以下代码显示了两个原始图像和遮罩:</p><pre class="lg lh li lj gt lv lw lx ly aw lz bi"><span id="52cf" class="ma mb it lw b gy mc md l me mf">for i, (image_path, mask_path) in enumerate(zip(input_images_list,<br/>                                                input_masks_list)):<br/>    fig, [ax1, ax2] = plt.subplots(1, 2, figsize=(18, 9))<br/>    image = mpimg.imread(image_path)<br/>    mask = mpimg.imread(mask_path)<br/>    ax1.set_title(‘Image ‘ + str(i+1))<br/>    ax1.imshow(image)<br/>    ax2.imshow(mask)<br/>    ax2.set_title(‘Mask ‘ + str(i+1))</span></pre><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi mg"><img src="../Images/e7d16a3d426b3fa288755496b20f52aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tg4Y2CWvl9jmb1xfE2nyEA.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">图像由 Oleksii Sheremet 使用<a class="ae le" href="https://matplotlib.org/" rel="noopener ugc nofollow" target="_blank"> matplotlib </a>模块创建</p></figure><p id="9007" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用以下功能，您可以显示分割图像的所有部分(分为 8 个部分):</p><pre class="lg lh li lj gt lv lw lx ly aw lz bi"><span id="a25c" class="ma mb it lw b gy mc md l me mf">def image_part_plotter(images_list, offset):<br/>    fig = plt.figure(figsize=(12, 6))<br/>    columns = 4<br/>    rows = 2<br/>    # ax enables access to manipulate each of subplots<br/>    ax = []<br/>    for i in range(columns*rows):<br/>        # create subplot and append to ax<br/>        img = mpimg.imread(images_list[i+offset])<br/>        ax.append(fig.add_subplot(rows, columns, i+1))<br/>        ax[-1].set_title(“image part number “ + str(i+1))<br/>        plt.imshow(img)<br/>    plt.show() # Render the plot</span></pre><p id="4f67" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看看我们得到了什么作为图像和面具分裂的结果。对于第一幅图像:</p><pre class="lg lh li lj gt lv lw lx ly aw lz bi"><span id="0eec" class="ma mb it lw b gy mc md l me mf">image_part_plotter(output_images_list, 0)<br/>image_part_plotter(output_masks_list, 0)</span></pre><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi mh"><img src="../Images/4c415af5273f2f0041b6443d1b3d7979.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VXFhi-Wte1VJoI4l40eIcg.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">图像由 Oleksii Sheremet 使用<a class="ae le" href="https://matplotlib.org/" rel="noopener ugc nofollow" target="_blank"> matplotlib </a>模块创建</p></figure><pre class="lg lh li lj gt lv lw lx ly aw lz bi"><span id="24f5" class="ma mb it lw b gy mc md l me mf">image_part_plotter(output_images_list, 8)<br/>image_part_plotter(output_masks_list, 8)</span></pre><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi mi"><img src="../Images/4a61eab39a019de6f858b91a796b6514.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uqc5Vz1sRE_D1UuWaInndA.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">图像由 Oleksii Sheremet 使用<a class="ae le" href="https://matplotlib.org/" rel="noopener ugc nofollow" target="_blank"> matplotlib </a>模块创建</p></figure><p id="c4f6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">结论</strong></p><p id="a818" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用所提出的方法分割的图像和掩模以相同的文件名保存在不同的目录中，即，如果文件<em class="mj">’。/output _ dir/images/1 _ 00001 . png '</em>在有图像的文件夹中，然后是文件<em class="mj">。/output _ dir/masks/1 _ 00001 . png '</em>会在带有掩码的目录中对应它。分割图像和遮罩后，您可以对其每个部分应用增强(例如，更改亮度、对比度、旋转或翻转)。为此，只需添加增强功能。</p><p id="741a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">参考文献</strong></p><p id="9beb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae le" href="https://pillow.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank">枕头(PIL 叉)</a></p><p id="63de" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae le" href="https://github.com/opencv/cvat" rel="noopener ugc nofollow" target="_blank">计算机视觉标注工具(CVAT) </a></p><p id="2284" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae le" href="https://colab.research.google.com/notebooks/io.ipynb" rel="noopener ugc nofollow" target="_blank">本笔记本提供从外部来源加载和保存数据的方法</a></p></div></div>    
</body>
</html>