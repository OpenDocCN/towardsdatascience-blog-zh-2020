<html>
<head>
<title>Deep Learning in Healthcare — X-Ray Imaging (Part 3-Analyzing images using Python)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">医疗保健中的深度学习— X射线成像(第3部分—使用Python分析图像)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/deep-learning-in-healthcare-x-ray-imaging-part-3-analyzing-images-using-python-915a98fbf14c?source=collection_archive---------26-----------------------#2020-06-08">https://towardsdatascience.com/deep-learning-in-healthcare-x-ray-imaging-part-3-analyzing-images-using-python-915a98fbf14c?source=collection_archive---------26-----------------------#2020-06-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a06c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">这是深度学习在X射线成像上的应用的第3部分。这里的重点是使用Python查看和分析X射线图像。</h2></div><p id="9308" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">既然我们已经了解了未经培训的专业人员解读X射线图像有多么困难，那么让我们来看看一些查看和分析图像及其直方图的技术，以及一种使用Python编程将图像和标签相加的技术。</p><h2 id="cd0a" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">图像数据集:</h2><p id="7525" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">图像数据集(胸部x光片)从Kaggle获得。数据集可通过以下链接获得—<a class="ae mc" href="https://www.kaggle.com/paultimothymooney/chest-xray-pneumonia/data" rel="noopener ugc nofollow" target="_blank">https://www . ka ggle . com/paultimothymooney/chest-x ray-pneumonia/data</a></p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi md"><img src="../Images/eaee9dd250affad6af52669bb3d5b47b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_dQB2rjcr8olDMhOP-n-gw.jpeg"/></div></div><p class="mp mq gj gh gi mr ms bd b be z dk translated">图一。不同肺炎情况下的胸部x光检查(资料来源- Kaggle公共数据集，详情见参考文献1)</p></figure><blockquote class="mt mu mv"><p id="8d9a" class="ki kj mw kk b kl km ju kn ko kp jx kq mx ks kt ku my kw kx ky mz la lb lc ld im bi translated">关于数据集—直接引用自Kaggle challenge —数据集分为3个文件夹(train、test、val ),并包含每个图像类别(肺炎/正常)的子文件夹。有5，863个x光图像(JPEG)和2个类别(肺炎/正常)。胸部X线图像(前-后)选自广州市妇女儿童医疗中心1-5岁的儿童患者的回顾性队列。所有的胸部x光成像都是作为患者常规临床护理的一部分进行的。对于胸部x射线图像的分析，最初通过去除所有低质量或不可读的扫描对所有胸部射线照片进行质量控制筛选。图像的诊断然后由两名专家医生进行评级，然后被批准用于训练人工智能系统。为了解决任何评分错误，评估集也由第三方专家检查。</p></blockquote><p id="99fb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如内容中明确指出的那样，挑战中共有5863幅图像可用，这些图像被分为肺炎和正常两类，并进一步分为训练/测试和验证集。为了使挑战更加困难，我们将数据分为三类，正常、细菌性肺炎和病毒性肺炎。在这一部分中，我们将只关注图像——用python加载它们，从医学成像的角度分析图像的各个重要方面，并将图像和标签一起加载。让我们直入主题吧。</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h2 id="c8d7" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">导入必要的库</h2><pre class="me mf mg mh gt nh ni nj nk aw nl bi"><span id="f705" class="le lf it ni b gy nm nn l no np"><em class="mw">#importing all the necessary libraries</em><br/><br/><strong class="ni iu">import</strong> <strong class="ni iu">numpy</strong> <strong class="ni iu">as</strong> <strong class="ni iu">np</strong>                     <br/><strong class="ni iu">import</strong> <strong class="ni iu">matplotlib.pyplot</strong> <strong class="ni iu">as</strong> <strong class="ni iu">plt</strong><br/><strong class="ni iu">import</strong> <strong class="ni iu">os</strong><br/><strong class="ni iu">import</strong> <strong class="ni iu">cv2</strong> <strong class="ni iu">as</strong> <strong class="ni iu">cv</strong><br/><strong class="ni iu">import</strong> <strong class="ni iu">random</strong></span></pre><p id="0ffe" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Numpy — Numpy是Python中最常用的库之一。它用于对多维数组和矩阵进行运算，并执行高级数学函数来对这些数组进行运算。</p><p id="d72c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">matplotlib——用于在python中创建静态和动态可视化的库。</p><p id="022a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">OS——python内置的一个模块。它提供了与操作系统交互的功能。</p><p id="bbf0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">cv2 — OpenCV(开源计算机视觉库)—一个非常重要的库，主要用于计算机视觉。其他类似的库有SimpleITK和Pillow (Python图像库)。</p><p id="eabc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">random —生成伪随机数的模块。</p><h2 id="fb33" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">研究数据集中的单个图像:</h2><pre class="me mf mg mh gt nh ni nj nk aw nl bi"><span id="b3d7" class="le lf it ni b gy nm nn l no np"><em class="mw">#load a single image from the bacteria folder</em><br/><br/><strong class="ni iu">def</strong> load_image(path):<br/>    <strong class="ni iu">for</strong> img <strong class="ni iu">in</strong> os.listdir(bacteria_path):<br/>        print('Image name =',img)<br/>        image = cv.imread(os.path.join(bacteria_path, img))<br/>        <strong class="ni iu">break</strong><br/>        <br/>    <strong class="ni iu">return</strong> image</span></pre><p id="b771" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如前所述，数据集中的图像被分成三类。1-正常，2-细菌(细菌性肺炎)，3-病毒(病毒性肺炎)。</p><p id="c312" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码片段创建了一个函数load_image，它将用于从训练集的细菌文件夹中加载一个图像。os.listdir用于列出该目录中的所有文件。在这种情况下，它可以用来访问细菌文件夹中的所有图像。接下来，它将打印图像的名称。最后，使用OpenCV库读取图像。</p><p id="0bfd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Break-在这里是必要的，这样只访问第一个图像，否则函数将遍历细菌文件夹中的所有图像。</p><pre class="me mf mg mh gt nh ni nj nk aw nl bi"><span id="7eb1" class="le lf it ni b gy nm nn l no np"><em class="mw"># Investigate a single image</em><br/><br/>bacteria_path = 'H:/All Files/Kaggle/chest_xray/train/2_BACTERIA/'<br/><br/>image = load_image(bacteria_path)<br/>plt.imshow(image, cmap='gray')<br/>plt.colorbar()<br/>plt.title('Raw Chest X Ray Image')<br/>print(f"The dimensions are <strong class="ni iu">{image.shape[0]}</strong> pixels height and <strong class="ni iu">{image.shape[1]}</strong> pixels width")<br/>print(f"The maximum pixel value is {image.max():.4f}")<br/>print(f"The minimum pixel value is {image.min():.4f}")<br/>print(f"The mean value of the pixels is {image.mean():.4f}")<br/>print(f"The standard deviation is {image.std():.4f}")</span></pre><p id="b770" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">输出-</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi nq"><img src="../Images/5e633db105ff68e2036c7114845add7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jcWbSVO4egYA5JXoIBkspw.jpeg"/></div></div></figure><p id="ae79" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个代码片段中，首先定义了图像的路径。然后，通过调用函数load_image，将文件夹中的第一幅图像加载到变量“image”中。然后使用matplotlib.imshow查看图像。之后，打印图像尺寸、灰度栏中的最大像素值和最小像素值。还计算图像像素的平均值和标准偏差。</p><p id="1816" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们绘制图像所有像素的直方图。<strong class="kk iu">直方图</strong>是用不同高度的条来显示数据的图形。</p><pre class="me mf mg mh gt nh ni nj nk aw nl bi"><span id="2d22" class="le lf it ni b gy nm nn l no np"># plot a histogram</span><span id="eff6" class="le lf it ni b gy nr nn l no np">plt.hist(image.ravel(),256,[0,256]) <br/>plt.show()</span></pre><p id="e26d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">输出-</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi ns"><img src="../Images/3d1c14d10b91a57aa4c38ccf99ffec4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t_dp6OedFqZltw6ce4zpyQ.jpeg"/></div></div></figure><p id="aae5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Matplotlib.hist用于绘制直方图。由于图像大部分是暗的，我们在灰度条的零位置上看到一个巨大的像素簇。</p><p id="df82" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些是可以使用OpenCV和matplotlib在图像上执行的一些基本功能。我们将在后面的部分看到OpenCV的更多用途。</p><h2 id="355b" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">一起加载图像和标签并调整图像大小</h2><pre class="me mf mg mh gt nh ni nj nk aw nl bi"><span id="2c8d" class="le lf it ni b gy nm nn l no np"><em class="mw"># loading the path of the train images</em><br/><br/>path = 'H:/All Files/Kaggle/chest_xray/train/'<br/>train = os.listdir(path)</span></pre><p id="d412" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">定义了训练集的路径，路径下的目录保存在‘train’中。在这种情况下，有三个文件夹，1_Normal、2_Bacteria和3_Virus。</p><pre class="me mf mg mh gt nh ni nj nk aw nl bi"><span id="f6c0" class="le lf it ni b gy nm nn l no np">folders=[]<br/>folders = [f <strong class="ni iu">for</strong> f <strong class="ni iu">in</strong> sorted(os.listdir(path))]<br/>print(folders)</span></pre><p id="8d35" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">输出-</p><p id="1d6b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">[' 1 _正常'，' 2 _细菌'，' 3 _病毒']</p><p id="76b3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们创建一个空列表——文件夹。然后，使用os.listdir遍历路径，将文件夹名排序并存储在列表中——“folders”。</p><pre class="me mf mg mh gt nh ni nj nk aw nl bi"><span id="0b3d" class="le lf it ni b gy nm nn l no np">labels = folders<br/>print (f'The labels are <strong class="ni iu">{labels}</strong>')<br/><br/><em class="mw"># setting the size of images that we want</em><br/><br/>image_size = 256<br/>print(f'All images to be resized into <strong class="ni iu">{image_size}</strong>*<strong class="ni iu">{image_size}</strong> pixels')</span></pre><p id="a309" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">输出-</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi nt"><img src="../Images/21463ba90b794918c7e12c42de3960a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4v9AzZmwc2jVaPbAlHnrNQ.jpeg"/></div></div></figure><p id="a8fb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">文件夹名称被设置为图像的标签，并且图像尺寸被选择为256*256。也就是说，所有图像的大小都将调整为256*256。如果我们浏览数据集，我们会看到所有的图像都有不同的维度，为了将图像输入到卷积神经网络(CNN)中，有必要将图像调整到相同的维度。</p><pre class="me mf mg mh gt nh ni nj nk aw nl bi"><span id="5901" class="le lf it ni b gy nm nn l no np"><em class="mw"># defining a function to load images and labels together</em><br/><em class="mw"># this function will also resize the images</em><br/><br/><strong class="ni iu">def</strong> load_train(path):<br/>    <br/>    images = []<br/>    <br/>    <strong class="ni iu">for</strong> label <strong class="ni iu">in</strong> labels:<br/>        direc = os.path.join(path, label)<br/>        class_num = labels.index(label)<br/>        <br/>        <strong class="ni iu">for</strong> image <strong class="ni iu">in</strong> os.listdir(direc):<br/>            image_read = cv.imread(os.path.join(direc,image),cv.IMREAD_GRAYSCALE)<br/>            image_resized = cv.resize(image_read,(image_size,image_size))<br/>            images.append([image_resized,class_num])<br/>            <br/>    <strong class="ni iu">return</strong> np.array(images)</span></pre><p id="6047" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里我们定义了一个函数，根据标签名称加载所有图像，将它们的大小调整为256*256像素，并返回图像数组。</p><p id="9d90" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">创建一个空列表来保存所有图像。然后运行“for”循环，从所有三个文件夹中提取所有图像。os.path.join用于合并目录中的路径。简历。im read _ gray将所有图像转换为灰度格式。cv.resize用于将图像大小调整为256*256像素。。“append”用于将所有图像追加到一个列表中，该列表最终被转换为一个数组并使用return语句返回。</p><pre class="me mf mg mh gt nh ni nj nk aw nl bi"><span id="8407" class="le lf it ni b gy nm nn l no np"><em class="mw">#load all the training images to train_images</em><br/><br/>train_images = load_train(path)<br/><br/>print(f'Shape of the training images = <strong class="ni iu">{train_images.shape}</strong>')</span></pre><p id="4c29" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">训练图像的输出形状= (5208，2)</p><p id="ff53" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后调用函数“load_train ”,所有训练图像都作为数组保存在train_images中。训练图像的形状为(5208，2)</p><pre class="me mf mg mh gt nh ni nj nk aw nl bi"><span id="92b9" class="le lf it ni b gy nm nn l no np"><em class="mw">#loading the images and labels seperately in X and y, to be used later for training</em></span><span id="84f0" class="le lf it ni b gy nr nn l no np">X = []<br/>y = []<br/><br/><strong class="ni iu">for</strong> feature, label <strong class="ni iu">in</strong> train_images:<br/>    X.append(feature)<br/>    y.append(label)<br/>    <br/>print (f'Length of X = {len(X)}')<br/>print (f'Length of y = {len(y)}')</span></pre><p id="67d1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">输出-</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi nu"><img src="../Images/7ec8bcb5ac590c89661b7a7affc56e67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sO4iFt4VjEU0O2_uWGlMyg.jpeg"/></div></div></figure><p id="33b0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了训练神经网络，需要分离图像和标签，并且通过在train_images上循环，并且通过提取图像和它们相应的标签来完成。</p><pre class="me mf mg mh gt nh ni nj nk aw nl bi"><span id="5785" class="le lf it ni b gy nm nn l no np"><em class="mw"># checking the number of images of each class</em><br/><br/>a = 0<br/>b = 0<br/>c = 0<br/><br/><strong class="ni iu">for</strong> label <strong class="ni iu">in</strong> y:<br/>    <strong class="ni iu">if</strong> label == 0:<br/>        a += 1<br/>    <strong class="ni iu">if</strong> label == 1:<br/>        b += 1<br/>    <strong class="ni iu">if</strong> label == 2:<br/>        c += 1<br/>        <br/>print (f'Number of Normal images = <strong class="ni iu">{a}</strong>')<br/>print (f'Number of Bacteria images = <strong class="ni iu">{b}</strong>')<br/>print (f'Number of Virus images = <strong class="ni iu">{c}</strong>')<br/><br/><em class="mw"># plotting the data</em><br/><br/>x_pos = [i <strong class="ni iu">for</strong> i, _ <strong class="ni iu">in</strong> enumerate(labels)]<br/>numbers = [a,b,c]<br/>plt.bar(x_pos,numbers,color = 'green')<br/>plt.xlabel("Labels")<br/>plt.ylabel("No. of images")<br/>plt.title("Images for each label")<br/><br/>plt.xticks(x_pos, labels)<br/><br/>plt.show()</span></pre><p id="b8d9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">输出-</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi nv"><img src="../Images/2a7318a7848ec14c1dac7bcdc4df1c3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qxvbfBMvg2kny5gn2V1Jhw.jpeg"/></div></div></figure><p id="4de5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了检查每个类中的图像数量，运行了一个for循环。然后使用用于创建条形图的matplotlib.bar绘制结果。</p><p id="59a1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从数据中可以清楚地看出，属于每个标签的图像数量有很大的差异。如果用这些数量的图像训练网络，它可能会偏向具有最多标签的类。这就是所谓的阶级不平衡问题。因此，每个类有相似数量的图像是必要的，我们将在下一部分讨论这一点。</p><pre class="me mf mg mh gt nh ni nj nk aw nl bi"><span id="9644" class="le lf it ni b gy nm nn l no np"><em class="mw"># Displays images </em><br/><em class="mw"># Extract 9 random images</em><br/>print('Display Random Images')<br/><br/><em class="mw"># Adjust the size of your images</em><br/>plt.figure(figsize=(20,10))<br/><br/><strong class="ni iu">for</strong> i <strong class="ni iu">in</strong> range(9):<br/>    num = random.randint(0,len(X)-1)<br/>    plt.subplot(3, 3, i + 1)<br/>    <br/>    plt.imshow(X[num],cmap='gray')<br/>    plt.axis('off')<br/>    <br/><em class="mw"># Adjust subplot parameters to give specified padding</em><br/>plt.tight_layout()</span></pre><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi nw"><img src="../Images/830b3810e514aa4cccdee5fafe1e2c18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rqyxe2wALu7riB1_w0OOXg.jpeg"/></div></div></figure><p id="0f76" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们使用随机模块从训练集中生成九幅随机图像，然后使用matplotlib绘制这些图像。</p><p id="0928" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是这部分的结尾。正如我们所见，对于医学成像分析来说，正确理解数据集是非常重要的，在本例中是X射线图像。在下一部分中，我们将使用matplotlib和OpenCV处理类不平衡问题和更多操作。</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><p id="0e91" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">参考资料:</p><ol class=""><li id="5572" class="nx ny it kk b kl km ko kp kr nz kv oa kz ob ld oc od oe of bi translated">从丹尼尔-克马尼获得的数据集；张、康；Goldbaum，Michael (2018)，“用于分类的标记光学相干断层扫描(OCT)和胸部X射线图像”，Mendeley Data，v2 http://dx . doi . org/10.17632/rscb jbr 9 SJ。</li><li id="1f42" class="nx ny it kk b kl og ko oh kr oi kv oj kz ok ld oc od oe of bi translated">通过基于图像的深度学习识别医学诊断和可治疗的疾病- (2018)，作者:Daniel S. Kermany，Michael Goldbaum，Cai，Carolina C.S. Valentim，Huiying Liang，Sally L. Baxter，Alex McKeown，Ge Yang，Xiaokang Wu，Yan，Justin Dong，Made K. Prasadha，Jacqueline Pei，Magdalene Y.L. Ting，，Christina Li，Sierra Hewett等，出版物:Cell Publisher。</li></ol></div></div>    
</body>
</html>