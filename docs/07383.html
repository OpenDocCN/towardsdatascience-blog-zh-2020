<html>
<head>
<title>Advance DAX Tutorial: Basket Analysis 2.0</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高级DAX教程:篮子分析2.0</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/explore-the-potential-of-products-through-customers-purchase-behaviour-in-power-bi-basket-a1f77e8a2bf6?source=collection_archive---------21-----------------------#2020-06-04">https://towardsdatascience.com/explore-the-potential-of-products-through-customers-purchase-behaviour-in-power-bi-basket-a1f77e8a2bf6?source=collection_archive---------21-----------------------#2020-06-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="87f3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过Power BI中的客户购买行为发掘产品的潜力</h2></div><p id="8ea4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">本文旨在使用DAX分析Power BI中的客户购买行为，并洞察产品潜力。</em></p><p id="16f9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae lf" href="https://www.sqlbi.com/author/marco-russo/" rel="noopener ugc nofollow" target="_blank"> <em class="le">马尔科·鲁索</em> </a> <em class="le">和</em> <a class="ae lf" href="https://www.sqlbi.com/author/alberto-ferrari/" rel="noopener ugc nofollow" target="_blank"> <em class="le">阿尔贝托·法拉利</em> </a> <em class="le">几年前曾发表过一篇名为《</em> <a class="ae lf" href="https://www.daxpatterns.com/basket-analysis/" rel="noopener ugc nofollow" target="_blank"> <em class="le">购物篮分析</em> </a> <em class="le">》的博客，这篇有趣的文章详细描述了如何使用DAX来计算任何产品组合下的订单数和客户数等非常有用的指标。这篇文章可以看作是“购物篮分析”的扩展，它考虑了客户购买不同产品的时间顺序。</em></p><h1 id="6089" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">与“篮子分析”相比</h1><p id="18f0" class="pw-post-body-paragraph ki kj it kk b kl ly ju kn ko lz jx kq kr ma kt ku kv mb kx ky kz mc lb lc ld im bi translated">假设A和B代表两种不同的产品，那么“篮子分析”计算的是P(AB)，而本文计算的是P(A|B)和P(B|A)，因为你可以比较下图所示的两个数字:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi md"><img src="../Images/4850ee1de2846128c11739221a05d263.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*kBPCQh7EV-tT9s0F"/></div><p class="ml mm gj gh gi mn mo bd b be z dk translated">作者图片</p></figure><p id="77b4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上图是“购物篮分析”中“两种产品都有客户”的衡量标准，显示有72个客户同时有“瓶瓶罐罐”和“自行车架”的购买记录。但是，下图中显示的数据考虑了客户购买产品的时间顺序。你可以发现，先买自行车架，后买瓶子和笼子的顾客有8个，先买瓶子和笼子，后买自行车架的顾客有14个。(注:我们暂时忽略同时买A和B的情况)</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi md"><img src="../Images/625a1d60af42abb76f02a7757e938935.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*Ecp8ebRioHlqeFfc"/></div><p class="ml mm gj gh gi mn mo bd b be z dk translated">作者图片</p></figure><h1 id="1bd0" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">为什么这个分析有意义？</h1><p id="588e" class="pw-post-body-paragraph ki kj it kk b kl ly ju kn ko lz jx kq kr ma kt ku kv mb kx ky kz mc lb lc ld im bi translated">客户的订单记录反映了一些非常有用的事实，为产品之间的关联提供了方向。换句话说，“购物篮分析”在分析超市数据时非常有用，因为顾客往往在购物时选择多种产品，然后去收银台一起下单。在这种情况下，所有产品都被视为同时订单。但实际上，你无法追溯顾客在超市购物过程中选择不同商品的记录。但是如果是在其他场景，比如客户在电商平台或者官网上下单，如果你作为店长，你可能想知道A和B是最畅销的型号，哪一个能带来更多的回头客，哪一个更容易流失客户。所以我们需要知道每个产品的回购百分比。比如所有先购买产品A的客户，未来有多少人会再回来购买产品，进一步分析，在这些人中，购买的仍然是产品A还是其他产品？各占多大比例，这是一个值得研究的问题。</p><h1 id="d3a6" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">计算过程。</h1><p id="f252" class="pw-post-body-paragraph ki kj it kk b kl ly ju kn ko lz jx kq kr ma kt ku kv mb kx ky kz mc lb lc ld im bi translated">按照计算过程，我们将最终实现下图所示的计算结果(注:我使用的数据集与“篮子分析”相同):</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mp"><img src="../Images/1207e8221d144fc4643a23f97825b909.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*806eF7MP-bT3FRx-"/></div></div><p class="ml mm gj gh gi mn mo bd b be z dk translated">作者图片</p></figure><p id="1d88" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如前所述，它显示了哪些客户首先购买了产品A并有后续购买记录，其中有多少客户购买了产品B或产品C等。</p><p id="0c88" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，为了达到这个计算结果，这里有五个步骤:</p><p id="c67f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">1.首先，对销售表的所有订单进行分类，在客户的所有订单中，订单日期最早的一个或多个订单被分类为第一个订单，其余为“非第一个”:</p><pre class="me mf mg mh gt mu mv mw mx aw my bi"><span id="b683" class="mz lh it mv b gy na nb l nc nd">IsFirstOrder = <br/>VAR<br/>E_Date = 'Sales'[OrderDateKey]<br/>VAR<br/>CUST = 'Sales'[CustomerKey]<br/>RETURN<br/>IF(<br/>    SUMX(<br/>        FILTER('Sales',<br/>        CUST = 'Sales'[CustomerKey]&amp;&amp;<br/>        E_Date &gt; 'Sales'[OrderDateKey]),<br/>        COUNTROWS('Sales'))&gt;0,FALSE,TRUE)</span></pre><p id="06f5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">2.过滤销售中所有产品A的订单数据，然后进一步过滤哪些订单被标记为客户的第一个订单，我们在这个过滤后的表中提取客户列表，并在其中添加一个名为“ROWS”的虚拟列，如下面的代码所示—虚拟表“VT1”。</p><p id="5a24" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">3.使用Sales作为主表，并使用NATURALLEFTOUTERJOIN()与虚拟表“VT1”相关联，然后使用filter()排除那些[ROWS]值不等于1的行，以便剩余的数据(VT2)是“VT1”返回的所有客户的所有订单。最后，对除“一阶”以外的所有订单进一步筛选数据，结果命名为“CustDistinctValue”:</p><pre class="me mf mg mh gt mu mv mw mx aw my bi"><span id="7704" class="mz lh it mv b gy na nb l nc nd">CustDistinctValue = <br/>VAR<br/>FIRSTORDERPROD = <br/>IF(HASONEVALUE('Product'[Subcategory]),<br/>    VALUES('Product'[Subcategory]),0)<br/>VAR<br/>VT1 = <br/>SUMMARIZE(<br/>    FILTER(Sales,<br/>        AND(related('Product'[Subcategory]) = FIRSTORDERPROD,<br/>            'Sales'[IsFirstOrder]=TRUE)),<br/>        'Sales'[CustomerKey],<br/>        "ROWS",<br/>        DISTINCTCOUNT(Sales[CustomerKey]))<br/>VAR<br/>VT2 = <br/>FILTER(<br/>    NATURALLEFTOUTERJOIN(ALL(Sales),VT1),<br/>    [ROWS] = 1)<br/>RETURN<br/>CALCULATE(<br/>    DISTINCTCOUNT('Sales'[CustomerKey]),<br/>    FILTER(VT2,'Sales'[IsFirstOrder] = FALSE)<br/>)</span></pre><p id="544c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">4.之后，我们需要确保这些数据可以被产品过滤(在这种情况下，我们只使用子类别)。这里和Macro的计算方法基本相同，使用产品表的副本(过滤产品)和主表建立非活动关系，然后创建一个度量，使其上下文忽略产品表的所有字段，接受来自其副本(过滤产品)的上下文。</p><pre class="me mf mg mh gt mu mv mw mx aw my bi"><span id="5e8e" class="mz lh it mv b gy na nb l nc nd">CustPurchaseOthersSubcategoryAfter = <br/>VAR CustPurchaseOthersSubcategoryAfter = <br/>CALCULATE (<br/>    'Sales'[CustDistinctValue],<br/>    CALCULATETABLE (<br/>        SUMMARIZE ( Sales, Sales[CustomerKey] ),<br/>        'Sales'[IsFirstOrder] = FALSE,<br/>        ALLSELECTED ('Product'),<br/>        USERELATIONSHIP ( Sales[ProductCode],<br/>             'Filter Product'[Filter ProductCode] )<br/>    )<br/>)<br/>RETURN<br/>IF(NOT([SameSubCategorySelection]),<br/>    CustPurchaseOthersSubcategoryAfter)</span></pre><p id="6dad" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注:“SameSubCategorySelection”用于排除选择相同子类别的数据。这个公式也使用宏的方法来完成:</p><pre class="me mf mg mh gt mu mv mw mx aw my bi"><span id="241b" class="mz lh it mv b gy na nb l nc nd">SameSubCategorySelection = <br/>IF (<br/>    HASONEVALUE ( 'Product'[Subcategory] )<br/>        &amp;&amp; HASONEVALUE ( 'Filter Product'[Filter Subcategory] ),<br/>    IF (<br/>        VALUES ( 'Product'[Subcategory])<br/>            = VALUES ( 'Filter Product'[Filter Subcategory] ),<br/>        TRUE<br/>    )<br/>)</span></pre><p id="e596" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">5.现在，我们已经计算出购买产品A的客户中有多少人首先购买了其他产品，现在我们需要计算这些客户占首先购买产品A然后有购买记录的客户总数的比例。下面是计算这个比例的分母的代码。</p><pre class="me mf mg mh gt mu mv mw mx aw my bi"><span id="e308" class="mz lh it mv b gy na nb l nc nd">AsFirstOrderCust = <br/>VAR<br/>FIRSTORDERPROD = <br/>IF(<br/>    HASONEVALUE('Product'[Subcategory]),<br/>    VALUES('Product'[Subcategory]),0)<br/>VAR<br/>VT1 = <br/>SUMMARIZE(<br/>    FILTER(Sales,<br/>        AND(<br/>            RELATED('Product'[Subcategory]) = FIRSTORDERPROD,<br/>                'Sales'[IsFirstOrder]=TRUE)),<br/>            'Sales'[CustomerKey]<br/>)<br/>return<br/>CALCULATE(<br/>    DISTINCTCOUNT('Sales'[CustomerKey]),<br/>    VT1)</span><span id="9e13" class="mz lh it mv b gy ne nb l nc nd">-------------------------------------------------------------------------------<br/>IsLastOrder = <br/>VAR<br/>E_Date = 'Sales'[OrderDateKey]<br/>VAR<br/>CUST = 'Sales'[CustomerKey]<br/>RETURN<br/>IF(<br/>    SUMX(<br/>        FILTER('Sales',<br/>        CUST = 'Sales'[CustomerKey]&amp;&amp;<br/>        E_Date &lt; 'Sales'[OrderDateKey]),<br/>        COUNTROWS('Sales'))&gt;0,"F","T")</span><span id="99e4" class="mz lh it mv b gy ne nb l nc nd">-------------------------------------------------------------------------------<br/>AsFirstOrderCustRepurchase = <br/>CALCULATE(<br/>    'Sales'[AsFirstOrderCust],<br/>    'Sales'[IsLastOrder] = "F")</span></pre><p id="4d71" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们得到最终的结果:custpruchaseotherssubcategoryaafter %，这个度量的名字很长，因为它的逻辑很复杂，就像上面的计算过程一样。</p><pre class="me mf mg mh gt mu mv mw mx aw my bi"><span id="2003" class="mz lh it mv b gy na nb l nc nd">CustPurchaseOthersSubCategoryAfter <em class="le">% = </em><br/>DIVIDE ( 'Sales'[CustPurchaseOthersSubcategoryAfter],<br/>    'Sales'[AsFirstOrderCustRepurchase])</span></pre><h1 id="043a" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">最后的结果。</h1><p id="8013" class="pw-post-body-paragraph ki kj it kk b kl ly ju kn ko lz jx kq kr ma kt ku kv mb kx ky kz mc lb lc ld im bi translated">最后，我们将成功地得到如下的最终结果，并选择使用一个名为“CHORD”的自定义视觉效果来可视化它。</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mp"><img src="../Images/edc57d2c3e0be12fc20f6338b868c6d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wyEDlM43GxaQeSsM"/></div></div><p class="ml mm gj gh gi mn mo bd b be z dk translated">作者图片</p></figure><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi nf"><img src="../Images/5de5cb69ee3e1f8e79dd8c8749d445c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*G8mYi-KykEx9EgKO"/></div></div><p class="ml mm gj gh gi mn mo bd b be z dk translated">作者图片</p></figure><p id="0084" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如你所看到的，首先购买公路车的顾客中，1853人后来购买了山地车，而有趣的是，只有200名顾客在购买山地车后购买了公路车。</p><p id="503d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">非常感谢</em> <a class="ae lf" href="https://blog.gbrueckl.at/about/" rel="noopener ugc nofollow" target="_blank"> <em class="le">格哈德</em> </a> <em class="le">之前的指点，这次我在文章中附上了PBIX文件，有兴趣的可以在这里</em><a class="ae lf" href="https://1drv.ms/u/s!AjpQa2fseaxaoDLeh4yBlBSaa-qx" rel="noopener ugc nofollow" target="_blank"><em class="le"/></a><em class="le">下载。</em></p><p id="4170" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">结束~ </em></p></div></div>    
</body>
</html>