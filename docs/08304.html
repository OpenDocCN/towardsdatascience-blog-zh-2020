<html>
<head>
<title>Part 5: Fast Approximate Matrix Profiles with STUMPY</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第5部分:用STUMPY快速近似矩阵轮廓</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/part-5-fast-approximate-matrix-profiles-with-scrump-c6d9c984c560?source=collection_archive---------52-----------------------#2020-06-17">https://towardsdatascience.com/part-5-fast-approximate-matrix-profiles-with-scrump-c6d9c984c560?source=collection_archive---------52-----------------------#2020-06-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="adcc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在很短的时间内计算出大致精确的矩阵轮廓</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4e8fef089bc69c3d15bd2ea38fbd4c12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EHFYS_NbMOwVgzOSRB-qqA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由<a class="ae ky" href="https://unsplash.com/@loic?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Djim Loic </a>提供)</p></figure><h1 id="3178" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">整体大于部分之和</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/b9dc45622efb5d6ddbb94d3e2f91b304.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/1*NWV2vLKBciK49BAVfzvN4Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="dd09" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated"><a class="ae ky" href="https://github.com/TDAmeritrade/stumpy" rel="noopener ugc nofollow" target="_blank"> STUMPY是一个强大且可扩展的Python库，用于现代时间序列分析</a>，在其核心，有效地计算出一种叫做<em class="mo">矩阵轮廓</em>的东西。这个多部分系列的目标是解释什么是matrix profile，以及如何开始利用<a class="ae ky" href="https://stumpy.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> STUMPY </a>完成所有现代时间序列数据挖掘任务！</p><p id="71be" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated"><em class="mo">注:这些教程最初出现在</em> <a class="ae ky" href="https://stumpy.readthedocs.io/en/latest/tutorials.html" rel="noopener ugc nofollow" target="_blank"> <em class="mo"> STUMPY文档</em> </a> <em class="mo">中。</em></p><p id="e588" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">第一部分:<a class="ae ky" rel="noopener" target="_blank" href="/the-matrix-profile-e4a679269692">矩阵轮廓</a> <br/>第二部分:<a class="ae ky" rel="noopener" target="_blank" href="/stumpy-basics-21844a2d2d92"> STUMPY基础知识</a> <br/>第三部分:<a class="ae ky" rel="noopener" target="_blank" href="/part-3-time-series-chains-da281450abbf">时间序列链</a> <br/>第四部分:<a class="ae ky" rel="noopener" target="_blank" href="/part-4-semantic-segmentation-b42c3792833d">语义分割</a> <br/>第五部分:<a class="ae ky" rel="noopener" target="_blank" href="/part-5-fast-approximate-matrix-profiles-with-scrump-c6d9c984c560">快速近似矩阵轮廓与STUMPY </a> <br/>第六部分:<a class="ae ky" rel="noopener" target="_blank" href="/matrix-profiles-for-streaming-time-series-data-f877ff6f9eef">用于流式时间序列数据的矩阵轮廓</a> <br/>第七部分:<a class="ae ky" rel="noopener" target="_blank" href="/part-7-fast-pattern-searching-with-stumpy-2baf610a8de1">快速模式搜索与STUMPY </a> <br/>第八部分:【T21 10: <a class="ae ky" rel="noopener" target="_blank" href="/part-10-discovering-multidimensional-time-series-motifs-45da53b594bb">发现多维时间序列模体</a> <br/>第十一部分:<a class="ae ky" rel="noopener" target="_blank" href="/part-11-user-guided-motif-search-d3d317caf9ea">用户引导的模体搜索</a> <br/>第十二部分:<a class="ae ky" rel="noopener" target="_blank" href="/part-12-matrix-profiles-for-machine-learning-2dfd98d7ff3f">机器学习的矩阵轮廓</a></p><h1 id="1716" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">利用有限的时间和资源计算矩阵轮廓</h1><p id="9df5" class="pw-post-body-paragraph ls lt it lu b lv mp ju lx ly mq jx ma mb mr md me mf ms mh mi mj mt ml mm mn im bi translated">在<a class="ae ky" href="https://medium.com/@seanmylaw/the-matrix-profile-e4a679269692" rel="noopener">第1部分:矩阵分布图</a>中，我们定义了矩阵分布图的含义，讨论了计算大型时间序列的矩阵分布图的复杂性，并且在<a class="ae ky" href="https://medium.com/@seanmylaw/stumpy-basics-21844a2d2d92" rel="noopener">第2部分:STUMPY基础知识</a>中，我们检查了它为我们提供的一些好处。然而，随着时间序列长度的增加，计算矩阵轮廓的成本可能会挑战你的耐心，甚至你的钱包。</p><p id="2a9c" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">在本文的<a class="ae ky" href="https://www.cs.ucr.edu/~eamonn/SCRIMP_ICDM_camera_ready_updated.pdf" rel="noopener ugc nofollow" target="_blank">中，介绍了一种称为“SCRIMP++的新方法，它以增量方式计算矩阵轮廓。当只需要一个近似矩阵轮廓时，该算法使用矩阵轮廓计算的某些属性来大大减少总计算时间，在本教程中，我们将演示这种方法如何满足您的应用。</a></p><p id="7618" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated"><a class="ae ky" href="https://github.com/TDAmeritrade/stumpy" rel="noopener ugc nofollow" target="_blank"> STUMPY </a>在<code class="fe mu mv mw mx b">stumpy.scrump()</code>函数中为自连接和AB连接实现了这种方法，当需要更高分辨率的输出时，它允许矩阵轮廓被容易地细化。</p><h1 id="07ae" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">入门指南</h1><p id="bc41" class="pw-post-body-paragraph ls lt it lu b lv mp ju lx ly mq jx ma mb mr md me mf ms mh mi mj mt ml mm mn im bi translated">首先，让我们导入一些将用于数据加载、分析和绘图的包。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="7b43" class="nc la it mx b gy nd ne l nf ng">%matplotlib inline<br/><br/>import pandas as pd<br/>import stumpy<br/>import numpy as np<br/>import matplotlib.pyplot as plt<br/>from matplotlib.patches import Rectangle<br/><br/>plt.rcParams["figure.figsize"] = [20, 6]  # width, height<br/>plt.rcParams['xtick.direction'] = 'out'</span></pre><h1 id="f530" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">加载Steamgen数据集</h1><p id="801e" class="pw-post-body-paragraph ls lt it lu b lv mp ju lx ly mq jx ma mb mr md me mf ms mh mi mj mt ml mm mn im bi translated">该数据是使用模糊模型生成的，该模型用于模拟位于伊利诺伊州香槟市的Abbott电厂的蒸汽发生器。我们感兴趣的数据特性是输出蒸汽流量遥测，单位为kg/s，数据每三秒“采样”一次，共有9600个数据点。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="baaa" class="nc la it mx b gy nd ne l nf ng">steam_df = pd.read_csv("https://zenodo.org/record/4273921/files/STUMPY_Basics_steamgen.csv?download=1")<br/>steam_df.head()</span><span id="9184" class="nc la it mx b gy nh ne l nf ng">drum pressure  excess oxygen  water level  steam flow<br/>    320.08239       2.506774     0.032701    9.302970<br/>   1321.71099       2.545908     0.284799    9.662621<br/>   2320.91331       2.360562     0.203652   10.990955 <br/>   3325.00252       0.027054     0.326187   12.430107<br/>   4326.65276       0.285649     0.753776   13.681666</span></pre><h1 id="0108" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">可视化Steamgen数据集</h1><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="e918" class="nc la it mx b gy nd ne l nf ng">plt.suptitle('Steamgen Dataset', fontsize='25')<br/>plt.xlabel('Time', fontsize ='20')<br/>plt.ylabel('Steam Flow', fontsize='20')<br/>plt.plot(steam_df['steam flow'].values)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/bfad902faf6158b32b99a5c8e4ae163b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*yhECk83if85YuH8J.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><h1 id="fcbc" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">计算真实矩阵轮廓</h1><p id="cb7d" class="pw-post-body-paragraph ls lt it lu b lv mp ju lx ly mq jx ma mb mr md me mf ms mh mi mj mt ml mm mn im bi translated">现在，作为比较的基准，我们将使用<code class="fe mu mv mw mx b">stumpy.stump()</code>函数和<code class="fe mu mv mw mx b">m=640</code>的窗口大小来计算完整的矩阵轮廓。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="60fd" class="nc la it mx b gy nd ne l nf ng">m = 640<br/>mp = stumpy.stump(steam_df['steam flow'], m)<br/>true_P = mp[:, 0]</span><span id="4c69" class="nc la it mx b gy nh ne l nf ng">fig, axs = plt.subplots(2, sharex=True, gridspec_kw={'hspace': 0})<br/>plt.suptitle('Motif (Pattern) Discovery', fontsize='25')</span><span id="0964" class="nc la it mx b gy nh ne l nf ng">axs[0].plot(steam_df['steam flow'].values)<br/>axs[0].set_ylabel('Steam Flow', fontsize='20')<br/>rect = Rectangle((643, 0), m, 40, facecolor='lightgrey')<br/>axs[0].add_patch(rect)<br/>rect = Rectangle((8724, 0), m, 40, facecolor='lightgrey')<br/>axs[0].add_patch(rect)<br/>axs[1].set_xlabel('Time', fontsize ='20')<br/>axs[1].set_ylabel('Matrix Profile', fontsize='20')<br/>axs[1].axvline(x=643, linestyle="dashed")<br/>axs[1].axvline(x=8724, linestyle="dashed")<br/>axs[1].plot(true_P)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/3cad8b47ad15acaa737da943c70fc9a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fTqFjoPh2sqoCIip.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="64ab" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">矩阵分布图的全局最小值(虚线)是顶部基序的索引(即，彼此最相似的两个子序列)。当使用矩阵图时，在许多应用中，这是两个最重要的子序列，我们将看到如何使用<code class="fe mu mv mw mx b">stumpy.scrump()</code>快速得出一个近似的矩阵图，在很短的时间内挑出这些子序列。</p><p id="d333" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">此外，我们将使用下面的帮助器功能直观地比较真实的矩阵轮廓(<code class="fe mu mv mw mx b">true_P</code> -用<code class="fe mu mv mw mx b">stumpy.stump()</code>计算)和近似的矩阵轮廓(<code class="fe mu mv mw mx b">approx_P</code> -用<code class="fe mu mv mw mx b">stumpy.scrump()</code>计算)。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="fb82" class="nc la it mx b gy nd ne l nf ng">def compare_approximation(true_P, approx_P):<br/>    fig, ax = plt.subplots(gridspec_kw={'hspace': 0})</span><span id="0c69" class="nc la it mx b gy nh ne l nf ng">    ax.set_xlabel('Time', fontsize ='20')<br/>    ax.axvline(x=643, linestyle="dashed")<br/>    ax.axvline(x=8724, linestyle="dashed")<br/>    ax.set_ylim((5, 28))<br/>    ax.plot(approx_P, color='C1', label="Approximate Matrix Profile")<br/>    ax.plot(true_P, label="True Matrix Profile")<br/>    ax.legend()</span></pre><h1 id="4d28" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">使用SCRUMP计算近似矩阵轮廓</h1><p id="26e4" class="pw-post-body-paragraph ls lt it lu b lv mp ju lx ly mq jx ma mb mr md me mf ms mh mi mj mt ml mm mn im bi translated">为了计算完整的矩阵分布，必须计算整个距离矩阵(即所有子序列对之间的成对距离)。然而，<code class="fe mu mv mw mx b">stumpy.scrump()</code>以对角线方式计算这个距离矩阵，但是只使用所有对角线的子集(因此，只使用所有距离的子集)。您想要计算的对角线上的成对距离由<code class="fe mu mv mw mx b">percentage</code>参数控制。计算的距离越多，近似值就越好，但这也意味着更高的计算成本。选择值<code class="fe mu mv mw mx b">1.0</code>，或所有距离的100%，产生完全精确的矩阵轮廓(相当于<code class="fe mu mv mw mx b">stumpy.stump()</code>的输出)。重要的是要注意，即使正在计算较少的成对距离，也没有近似成对距离。也就是说，你总是保证在<code class="fe mu mv mw mx b">percentage &lt;= 1.0</code>时<code class="fe mu mv mw mx b">approx_P &gt;= true_P</code>，在<code class="fe mu mv mw mx b">percentage=1.0</code>、<code class="fe mu mv mw mx b">approx_P == true_P</code>(即它是精确的)。</p><p id="7544" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">现在，让我们调用<code class="fe mu mv mw mx b">stumpy.scrump()</code>，通过仅计算所有距离的1%来近似整个矩阵轮廓(即<code class="fe mu mv mw mx b">percentage=0.01</code>):</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="9525" class="nc la it mx b gy nd ne l nf ng">approx = stumpy.scrump(steam_df['steam flow'], m, percentage=0.01, pre_scrump=False)</span></pre><p id="43dc" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">有几件事需要注意。首先，我们传入了一个<code class="fe mu mv mw mx b">pre_scrump</code>参数，这是<code class="fe mu mv mw mx b">stumpy.scrump()</code>的一个预处理步骤，当设置为<code class="fe mu mv mw mx b">True</code>时，可以极大地提高近似值。现在，出于演示目的，我们关闭预处理步骤，并在下一节中再次讨论它。其次，<code class="fe mu mv mw mx b">stumpy.scrump()</code>初始化并返回一个<code class="fe mu mv mw mx b">scrump</code>对象，而不是直接返回矩阵配置文件，我们将在下面看到这为什么有用。</p><p id="a831" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">为了检索第一次近似(即，从所有距离的1%计算的矩阵轮廓)，我们简单地调用<code class="fe mu mv mw mx b">.update()</code>方法:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="869a" class="nc la it mx b gy nd ne l nf ng">approx.update()</span></pre><p id="9bf3" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">我们可以分别通过<code class="fe mu mv mw mx b">.P_</code>和<code class="fe mu mv mw mx b">.I_</code>属性访问更新的矩阵配置文件和矩阵配置文件索引:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="4b26" class="nc la it mx b gy nd ne l nf ng">approx_P = approx.P_</span></pre><p id="6566" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">请记住，近似矩阵轮廓是通过随机计算对角线子集的距离来计算的。所以，每次你通过调用<code class="fe mu mv mw mx b">stumpy.scrump()</code>初始化一个新的<code class="fe mu mv mw mx b">scrump</code>对象，这将随机打乱距离计算的顺序，这不可避免地导致不同的近似矩阵轮廓(除了当<code class="fe mu mv mw mx b">percentage=1.0</code>)。根据您的使用情况，为了确保可重复的结果，您可以考虑在调用<code class="fe mu mv mw mx b">stumpy.scrump()</code>之前设置随机种子:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="7ab9" class="nc la it mx b gy nd ne l nf ng">seed = np.random.randint(100000)<br/>np.random.seed(seed)<br/>approx = stumpy.scrump(steam_df['steam flow'], m, percentage=0.01, pre_scrump=<strong class="mx iu">False</strong>)</span></pre><p id="4447" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">接下来，让我们在<code class="fe mu mv mw mx b">true_P</code>上绘制<code class="fe mu mv mw mx b">approx_P</code>，看看它们比较起来有多好:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="b257" class="nc la it mx b gy nd ne l nf ng">compare_approximation(true_P, approx_P)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/72030d3a4fe30fa28c9d3985bff78705.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*T9UtyPB1ROGb2g-B.png"/></div></div></figure><p id="0731" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">我们可以看到，这种近似(橙色)远非完美，但两者之间有一些相似之处。然而，近似值中的最低点(橙色)并不对应于真正的最小值(蓝色)。</p><h1 id="95e0" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">细化矩阵轮廓</h1><p id="a202" class="pw-post-body-paragraph ls lt it lu b lv mp ju lx ly mq jx ma mb mr md me mf ms mh mi mj mt ml mm mn im bi translated">然而，我们可以通过再调用<code class="fe mu mv mw mx b">.update()</code>九次(即<code class="fe mu mv mw mx b">10 * 0.01 = 0.10</code>)来逐步细化近似，因此我们新的近似矩阵轮廓将使用全距离矩阵中所有成对距离的大约10%来计算。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="e032" class="nc la it mx b gy nd ne l nf ng">for _ in range(9):<br/>    approx.update()</span><span id="4ef3" class="nc la it mx b gy nh ne l nf ng">approx_P = approx.P_</span><span id="8f57" class="nc la it mx b gy nh ne l nf ng">compare_approximation(true_P, approx_P)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/4429ace904a54d64e1bc879e171b47de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DOsYw0t6jZGMviLT.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="246d" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">现在，这个结果更有说服力了，它只需要计算所有成对距离的10%!我们可以看到这两个轮廓非常相似，特别是像全局最小值这样的重要特征几乎处于相同的位置，如果不是相同的话。对于大多数应用来说，这就足够了，因为几个点的偏移通常并不重要，并且必须计算的距离数量减少了十分之一！事实上，我们可以做得更好！</p><h1 id="122c" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">预处理的力量</h1><p id="ded6" class="pw-post-body-paragraph ls lt it lu b lv mp ju lx ly mq jx ma mb mr md me mf ms mh mi mj mt ml mm mn im bi translated">到目前为止，我们只运行了<code class="fe mu mv mw mx b">stumpy.scrump()</code>而没有强大的<em class="mo">pre crimp</em>预处理步骤。<em class="mo"> PRESCRIMP </em>是对复杂度为<code class="fe mu mv mw mx b">O(n log(n) / s)</code>的时间序列数据进行预处理的算法，其中<code class="fe mu mv mw mx b">n</code>是数据点的个数，<code class="fe mu mv mw mx b">s</code>称为采样率。<code class="fe mu mv mw mx b">stumpy.stump()</code>和<code class="fe mu mv mw mx b">stumpy.scrump()</code>(没有<em class="mo">预裁剪</em>)都是<code class="fe mu mv mw mx b">O(n^2)</code>复杂度，所以一般来说，预处理是‘廉价’的。<em class="mo"> PRESCRIMP </em>已经计算了一些成对距离的距离，并且采样率控制了要计算的数量。通常，一个好的值是<code class="fe mu mv mw mx b">s=m/4</code>，与典型的禁区大小相同，如果将<code class="fe mu mv mw mx b">None</code>传递给<code class="fe mu mv mw mx b">scrimp.scrump()</code>函数调用，就会使用这个值。</p><p id="875c" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">下面我们将再次用所有对角线的1%来近似矩阵轮廓，但是这一次，我们将通过设置<code class="fe mu mv mw mx b">pre_scrimp=True</code>来启用预处理。显然，这将需要更长的计算时间，因为还需要执行一些计算:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="3b6a" class="nc la it mx b gy nd ne l nf ng">approx = stumpy.scrump(steam_df['steam flow'], m, percentage=0.01, pre_scrump=True, s=None)<br/>approx.update()<br/>approx_P = approx.P_</span><span id="de0a" class="nc la it mx b gy nh ne l nf ng">compare_approximation(true_P, approx_P)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/1abf16ad6bb5a1ef89becb78754e9275.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Zpzupo4tI-ynsB3j.png"/></div></div></figure><p id="ff31" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">然而，人们可以看到，在这个例子中，预处理之后的<strong class="lu iu">仅计算1%的成对距离</strong>(即，仅调用<code class="fe mu mv mw mx b">.update()</code>一次)，近似矩阵轮廓和真实矩阵轮廓在视觉上几乎无法区分。随着时间序列长度的增加，使用预处理的好处会进一步增加。当然，根据您需要分析的时间序列数据的大小以及您可以使用的计算资源，计算更高百分比的距离以确保近似值收敛可能是值得的。</p><h1 id="aee1" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">摘要</h1><p id="98db" class="pw-post-body-paragraph ls lt it lu b lv mp ju lx ly mq jx ma mb mr md me mf ms mh mi mj mt ml mm mn im bi translated">就是这样！您已经学习了如何使用<code class="fe mu mv mw mx b">stumpy.scrump()</code>来近似矩阵轮廓，希望能够在您的应用中使用近似矩阵轮廓。</p><h1 id="d20e" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">资源</h1><p id="b0e0" class="pw-post-body-paragraph ls lt it lu b lv mp ju lx ly mq jx ma mb mr md me mf ms mh mi mj mt ml mm mn im bi translated"><a class="ae ky" href="https://www.cs.ucr.edu/~eamonn/SCRIMP_ICDM_camera_ready_updated.pdf" rel="noopener ugc nofollow" target="_blank">Matrix Profile Xi</a><br/><a class="ae ky" href="https://stumpy.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">STUMPY Matrix Profile文档</a><br/><a class="ae ky" href="https://github.com/TDAmeritrade/stumpy" rel="noopener ugc nofollow" target="_blank">STUMPY Matrix Profile Github代码库</a></p><h2 id="615f" class="nc la it bd lb nl nm dn lf nn no dp lj mb np nq ll mf nr ns ln mj nt nu lp nv bi translated">← <a class="ae ky" rel="noopener" target="_blank" href="/part-4-semantic-segmentation-b42c3792833d">第4部分:语义分割</a> | <a class="ae ky" rel="noopener" target="_blank" href="/matrix-profiles-for-streaming-time-series-data-f877ff6f9eef">第6部分:流式时间序列数据的矩阵轮廓</a> →</h2></div></div>    
</body>
</html>