<html>
<head>
<title>7 Modern Python Mistakes To Fix NOW!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现在修复7个现代Python错误！</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/7-modern-python-mistakes-to-fix-now-6ff6f1dedbf3?source=collection_archive---------14-----------------------#2020-05-04">https://towardsdatascience.com/7-modern-python-mistakes-to-fix-now-6ff6f1dedbf3?source=collection_archive---------14-----------------------#2020-05-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="dd27" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Python中常见的7个不该犯的错误。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/274b2f2344a201fc04a1a75067dbb4b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4QvomM2tSz43vlLNgsPbyQ.png"/></div></div></figure><blockquote class="ku"><p id="04af" class="kv kw it bd kx ky kz la lb lc ld le dk translated"><a class="ae lf" href="https://github.com/emmettgb/Emmetts-DS-NoteBooks/tree/master/Python3" rel="noopener ugc nofollow" target="_blank">笔记本</a></p></blockquote><h1 id="a0a1" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">介绍</h1><p id="ecac" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms le im bi translated">Python是一种相对容易掌握的语言，但是由于很多事情都是假设的，所以很容易出错。此外，这些错误可能会在很长一段时间内被忽视。提前给我的另外四头<em class="mt">菜鸟巨蟒失误</em>。</p><div class="mu mv gp gr mw mx"><a rel="noopener follow" target="_blank" href="/avoid-these-rookie-python-mistakes-9cc17cccd051"><div class="my ab fo"><div class="mz ab na cl cj nb"><h2 class="bd iu gy z fp nc fr fs nd fu fw is bi translated">避免这些Python新手的错误</h2><div class="ne l"><h3 class="bd b gy z fp nc fr fs nd fu fw dk translated">他们可能会工作，但他们可以工作得更好。</h3></div><div class="nf l"><p class="bd b dl z fp nc fr fs nd fu fw dk translated">towardsdatascience.com</p></div></div><div class="ng l"><div class="nh l ni nj nk ng nl ks mx"/></div></div></a></div><p id="3c04" class="pw-post-body-paragraph ly lz it ma b mb nm ju md me nn jx mg mh no mj mk ml np mn mo mp nq mr ms le im bi translated">今天我将分享更多在Python 3.8中容易犯的错误。</p><h1 id="48d0" class="lg lh it bd li lj lk ll lm ln lo lp lq jz nr ka ls kc ns kd lu kf nt kg lw lx bi">№1: +=</h1><p id="51a1" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms le im bi translated">在很多情况下，我肯定会犯的一个错误是使用了+=操作数。假设加法必须用两个独立的操作数来完成似乎太容易了，一个用于加法，另一个用于断言。幸运的是，Python(以及许多其他编程语言)支持可以同时执行数学和断言运算的操作数。</p><blockquote class="ku"><p id="e23d" class="kv kw it bd kx ky nu nv nw nx ny le dk translated">而不是:</p></blockquote><pre class="nz oa ob oc od oe of og oh aw oi bi"><span id="1af9" class="oj lh it of b gy ok ol l om on">x = x + 5</span></pre><blockquote class="ku"><p id="2ed0" class="kv kw it bd kx ky kz la lb lc ld le dk translated">做:</p></blockquote><pre class="nz oa ob oc od oe of og oh aw oi bi"><span id="4f92" class="oj lh it of b gy ok ol l om on">x += 5</span></pre><h1 id="8b14" class="lg lh it bd li lj lk ll lm ln lo lp lq jz nr ka ls kc ns kd lu kf nt kg lw lx bi translated">№2:位置变元表示</h1><p id="b41a" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms le im bi translated">在大多数现代脚本语言中，有两种主要类型的参数可以用作函数的参数:</p><blockquote class="ku"><p id="e96e" class="kv kw it bd kx ky nu nv nw nx ny le dk translated">位置和</p><p id="1e43" class="kv kw it bd kx ky nu nv nw nx ny le dk translated">关键词。</p></blockquote><p id="d33d" class="pw-post-body-paragraph ly lz it ma b mb oo ju md me op jx mg mh oq mj mk ml or mn mo mp os mr ms le im bi translated">在Python 3.8发布之前，没有办法表示位置参数，使得位置参数缺省基本上不可能。然而，由于Python 3.8中的更新，我们可以使用\将所有以前的参数表示为位置参数。您应该使用它们，因为位置参数是高性能Python代码的基础。如果在Python中有什么东西是你的代码需要补偿的，特别是在机器学习的时候，那可能就是性能。</p><p id="f898" class="pw-post-body-paragraph ly lz it ma b mb nm ju md me nn jx mg mh no mj mk ml np mn mo mp nq mr ms le im bi translated">关键字参数在函数定义时计算一次。这对递归算法的性能尤其有害。如果你喜欢写成本函数，使用位置参数是绝对必要的。这并不是说根本不应该使用它们，但是尽可能使用位置参数绝对是一个更好的主意。</p><blockquote class="ku"><p id="955b" class="kv kw it bd kx ky nu nv nw nx ny le dk translated">而不是:</p></blockquote><pre class="nz oa ob oc od oe of og oh aw oi bi"><span id="1d94" class="oj lh it of b gy ok ol l om on">def numbers(custom, five=5,ten=10,fifteen=15):<br/>    total = five + ten + fifteen + custom<br/>    return(total)</span></pre><blockquote class="ku"><p id="3b0c" class="kv kw it bd kx ky kz la lb lc ld le dk translated">做:</p></blockquote><pre class="nz oa ob oc od oe of og oh aw oi bi"><span id="acf5" class="oj lh it of b gy ok ol l om on">def numbers(custom,\,five=5,ten=10,fifteen=15):<br/>    total = five + ten + fifteen + custom<br/>    return(total)</span></pre><p id="5878" class="pw-post-body-paragraph ly lz it ma b mb nm ju md me nn jx mg mh no mj mk ml np mn mo mp nq mr ms le im bi translated">同样重要的是要记住，这个特性是相当新的，所以为了提高性能而使用仅位置参数的概念将仅限于Python 3.8+版本</p><h1 id="706b" class="lg lh it bd li lj lk ll lm ln lo lp lq jz nr ka ls kc ns kd lu kf nt kg lw lx bi translated">№3:初始化时返回</h1><p id="7b9b" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms le im bi translated">虽然这种方法并不常见，而且可能是一个相当大的新手动作，但我见过有人尝试在初始化函数中执行returns。在Python面向对象的世界中，每次实例化一个类时都会调用__init__函数。init函数对于设置变量、移动数据和构造类型非常有价值。然而，随着强大的能力而来的是巨大的责任，Python的__init__函数应该用于类初始化，而不是监视、循环、定向，只是类初始化。并且拜托(我有经历过有人这么做！)</p><blockquote class="ku"><p id="96d9" class="kv kw it bd kx ky nu nv nw nx ny le dk translated">初始化时不要返回！</p></blockquote><p id="1a8e" class="pw-post-body-paragraph ly lz it ma b mb oo ju md me op jx mg mh oq mj mk ml or mn mo mp os mr ms le im bi translated">(没有任何意义！)</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/80dd5850e46ea0b31e81b3a1559e7549.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GuOTlu0KiX6FDxxfIC5KIw.png"/></div></div></figure><h1 id="8af2" class="lg lh it bd li lj lk ll lm ln lo lp lq jz nr ka ls kc ns kd lu kf nt kg lw lx bi translated">№4:循环依赖</h1><p id="7219" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms le im bi translated">当用完成相似目标的不同部分编写一个大的Python包时，通常你的包会互相依赖。这可能会产生很大的问题，并导致所谓的“循环依赖”发生这种情况时，当模块中的不同位置试图相互访问时，就会遇到问题。</p><h1 id="f14c" class="lg lh it bd li lj lk ll lm ln lo lp lq jz nr ka ls kc ns kd lu kf nt kg lw lx bi translated">№5:空格还是缩进？</h1><p id="9106" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms le im bi translated">众所周知，Python使用缩进而不是分隔符来将代码包含在其他代码中。对许多人来说，这使得代码更容易阅读和编写，尽管我个人主观上很鄙视它。然而，在其他语言中，我通常倾向于用缩进(tab键)来缩进代码。)然而，根据PEP8，你应该使用四个空格来缩进。老实说，这是我和很多人一起做项目时唯一遵循的原则。对我来说，只要保持一致，我不认为空格或缩进有什么关系——但正式来说，你应该使用空格。也就是说，在为一项工作或需要许多其他用户观察的大型团队项目编写代码时，遵循PEP8的标准可能是一个好主意。</p><h1 id="8a0a" class="lg lh it bd li lj lk ll lm ln lo lp lq jz nr ka ls kc ns kd lu kf nt kg lw lx bi translated">№6:块迭代</h1><p id="dbc2" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms le im bi translated">当执行迭代for循环时，当您编写完整长度的for循环时，在代码中表达您的想法会容易得多。然而，一般来说，如果您需要执行的操作只需要一行，那么最好是循环一行。这不仅会使您的代码更加漂亮和简洁，而且还会带来相关的性能提升。</p><blockquote class="ku"><p id="5f8b" class="kv kw it bd kx ky nu nv nw nx ny le dk translated">而不是:</p></blockquote><pre class="nz oa ob oc od oe of og oh aw oi bi"><span id="7f73" class="oj lh it of b gy ok ol l om on">for i in x:<br/>    i += 5</span></pre><blockquote class="ku"><p id="79f1" class="kv kw it bd kx ky kz la lb lc ld le dk translated">做:</p></blockquote><pre class="nz oa ob oc od oe of og oh aw oi bi"><span id="8114" class="oj lh it of b gy ok ol l om on">[i + 5 for i in x]</span></pre><h1 id="0d9f" class="lg lh it bd li lj lk ll lm ln lo lp lq jz nr ka ls kc ns kd lu kf nt kg lw lx bi translated">№7:内部字符串</h1><p id="6a22" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms le im bi translated">对于要考虑的最后一个错误，我想谈谈互联网字符串。在某些情况下，Python会尝试重用不可变的对象，字符串实习就是这种情况的一个例子。所有长度为1的字符串都被保留。除ASCII字符、数字和下划线之外的任何字符串都不会被保留。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/54daf9e0272d4293fd75b9d93559f48a.png" data-original-src="https://miro.medium.com/v2/resize:fit:504/format:webp/1*UD_4evm-2iBKl-8XpLJqbg.png"/></div></figure><p id="5436" class="pw-post-body-paragraph ly lz it ma b mb nm ju md me nn jx mg mh no mj mk ml np mn mo mp nq mr ms le im bi translated">这里我试图创建两个不同的对象，a和b，但是这不是Python所做的。Python实际上把b变成了指向a的指针，而不是产生一个新的字符串。但是如果我们添加一个ASCII字符:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/f894b1119390d1d9092f3bd66ac09b6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:604/format:webp/1*dHI-IAwyeAvH1epbAYKmyA.png"/></div></figure><p id="5a35" class="pw-post-body-paragraph ly lz it ma b mb nm ju md me nn jx mg mh no mj mk ml np mn mo mp nq mr ms le im bi translated">所以在使用不可变字符串的时候要记住这一点，因为它确实给我带来了很多麻烦。</p></div></div>    
</body>
</html>