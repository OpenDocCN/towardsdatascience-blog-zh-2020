<html>
<head>
<title>Quantum Machine Learning 101</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">量子机器学习101</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/quantum-machine-learning-101-1058f24c3487?source=collection_archive---------43-----------------------#2020-06-24">https://towardsdatascience.com/quantum-machine-learning-101-1058f24c3487?source=collection_archive---------43-----------------------#2020-06-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7d0b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如果你认为ML很有趣，那么<strong class="ak"> <em class="ki"> Q </em> </strong> ML来了！</h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/73a9d56edc53d29a0f39b6c9aae8829f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yVqiWFcP14t4Hb6B"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马库斯·斯皮斯克</a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="5f6a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在量子机器学习(QML)领域已经做了很多工作，这个博客只是给你一个简短的10分钟介绍QML的世界。因此，这本书对你来说应该只是一个有趣的读物，而我计划写一个关于QML的更系统更深入的系列教程。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="afac" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">经典计算机是通用的，因为它们可以实现任何逻辑运算，而量子计算机是通用的，因为一组量子位上的任何量子态都可以转换成任何其他量子态。量子(电路)计算可行性的许多良好的早期希望来自<a class="ae kz" href="https://en.wikipedia.org/wiki/Solovay%E2%80%93Kitaev_theorem" rel="noopener ugc nofollow" target="_blank">索洛维-基塔耶夫定理</a>，在非常广泛的条件下(神经元/门&amp;普适函数/状态近似的有限性)可以等同于深度学习的<a class="ae kz" href="https://en.wikipedia.org/wiki/Universal_approximation_theorem" rel="noopener ugc nofollow" target="_blank">普适近似定理</a>。</p><h1 id="b41b" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">伊辛模型和哈密顿量</h1><p id="248e" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated">简单来说，伊辛模型是一种表示体系内相变和相互作用的数学模型<a class="ae kz" href="https://en.wikipedia.org/wiki/Ising_model" rel="noopener ugc nofollow" target="_blank">【1】</a><a class="ae kz" href="http://stanford.edu/~jeffjar/statmech2/intro4.html" rel="noopener ugc nofollow" target="_blank">【2】</a>。这种系统在任一点的能量由该点的各自的<a class="ae kz" href="https://en.wikipedia.org/wiki/Hamiltonian_(quantum_mechanics)" rel="noopener ugc nofollow" target="_blank">哈密顿量</a>(方程式)给出。</p><p id="71c7" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">比如说在图1中。下面，我们有一个4X4(点阵)矩阵系统。每个单元处于两种可能状态之一(比如+1，-1)。假设每个单元只有四个相邻(上、左、右、下)单元，如果存在的话。</p><p id="a9ca" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">所以6的相邻单元格是3，5，7和10。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi na"><img src="../Images/bc93687923ef51028247165935b2b096.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yAWSVZQ9sNLmFQ9kk__7uQ.png"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated"><strong class="bd nb">图1 </strong>。随机系统(同一系统的两种不同表示)</p></figure><p id="e694" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">现在每个细胞都拥有一些能量，这是由于它与邻居的相互作用，还有一些是由于它自己的状态。每个系统都想达到(过渡到)最低能量状态。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nc"><img src="../Images/19276699cb936a56a7a871806a1ec7de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nT5mdNfPFNW-p6-zdb-7hQ.png"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">Eq1 。哈密顿函数</p></figure><p id="7e29" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">所以Eq1。以上是这种系统在任一点的能量方程</p><ul class=""><li id="6934" class="nd ne it lc b ld le lg lh lj nf ln ng lr nh lv ni nj nk nl bi translated"><strong class="lc iu"> M </strong>:表示上述任一点的系统/矩阵</li><li id="7b70" class="nd ne it lc b ld nm lg nn lj no ln np lr nq lv ni nj nk nl bi translated"><strong class="lc iu"> &lt; i，j &gt; </strong>:所有对代表相邻单元格I，j</li><li id="5f0d" class="nd ne it lc b ld nm lg nn lj no ln np lr nq lv ni nj nk nl bi translated"><strong class="lc iu"> J i，j </strong>:表示相邻细胞间的相互作用能量系数</li><li id="fc38" class="nd ne it lc b ld nm lg nn lj no ln np lr nq lv ni nj nk nl bi translated"><strong class="lc iu"> Mi </strong>:表示每个单元格的值{+1，-1}</li><li id="798b" class="nd ne it lc b ld nm lg nn lj no ln np lr nq lv ni nj nk nl bi translated"><strong class="lc iu">嗨:</strong>代表每个的能量系数</li><li id="6e5f" class="nd ne it lc b ld nm lg nn lj no ln np lr nq lv ni nj nk nl bi translated"><strong class="lc iu"> μ </strong>:表示每个电池的总(外)能量系数</li></ul><p id="7da0" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">现在，虽然上面的等式甚至对于简单的物理磁体(它最初是为其提出的)来说不够准确，但是它很好地模拟了由于每个粒子的状态、它与其他粒子的相互作用以及每个粒子上的任何外部因素而产生的系统能量。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/423078d9622425e3b6918b3aa14e9189.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/1*nOCcni7IE9hgZyTvN25DPQ.gif"/></div></figure><div class="kk kl km kn gt ab cb"><figure class="ns ko nt nu nv nw nx paragraph-image"><img src="../Images/611ead2f59eddec3228c8d4cfff11f18.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*bIjGt9jXJ0b1khN4friVHA.png"/></figure><figure class="ns ko nt nu nv nw nx paragraph-image"><img src="../Images/df578f932fb89d896c6202dda9d7a5bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/1*SLtwVMFb7M6vJZ6mNLeg-g.gif"/></figure><figure class="ns ko nt nu nv nw nx paragraph-image"><img src="../Images/888ed91ec0f11b1008be29384c8d072f.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*E8sPVUq1KloF33y4qUcT2A.png"/><p class="kv kw gj gh gi kx ky bd b be z dk ny di nz oa translated"><strong class="bd nb">图2 </strong>开始状态(左)过渡状态(中)结束状态(右)</p></figure></div><p id="d594" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">图二。上面显示了这样一个系统(200X200)从初始状态(左)到最终状态(右)的转变。</p><h1 id="a242" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">量子ML的方法</h1><p id="1eb8" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated">虽然总结量子最大似然的所有可能的方法对我来说是不可能的，主要是因为我对我读过的一些算法的理解有限，但是因为一般来说任何量子优化/最小化算法都可以有一个等价的QML用例。</p><p id="5436" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在下面提供的3种方法中，我们将只关注第一种模型，在本博客后面的讨论中，其他两种方法放在这里只是为了给出QML算法的更大的图像</p><h2 id="1676" class="ob me it bd mf oc od dn mj oe of dp mn lj og oh mp ln oi oj mr lr ok ol mt om bi translated">量子电路/门模型</h2><ul class=""><li id="8d7c" class="nd ne it lc b ld mv lg mw lj on ln oo lr op lv ni nj nk nl bi translated">将经典问题映射到量子算法。</li><li id="2e95" class="nd ne it lc b ld nm lg nn lj no ln np lr nq lv ni nj nk nl bi translated">相应的量子算法然后被转换成量子电路</li><li id="96d0" class="nd ne it lc b ld nm lg nn lj no ln np lr nq lv ni nj nk nl bi translated">量子电路然后在量子处理器上运行</li></ul><h2 id="17d1" class="ob me it bd mf oc od dn mj oe of dp mn lj og oh mp ln oi oj mr lr ok ol mt om bi translated">绝热量子计算[暂时忽略]</h2><ul class=""><li id="9943" class="nd ne it lc b ld mv lg mw lj on ln oo lr op lv ni nj nk nl bi translated"><strong class="lc iu"> H1 </strong>代表一个系统的能量纯粹由于单个细胞&amp;而不是相互作用(即Jij = 0)。<br/>(注意:这里的基态/最小能态是所有比特的叠加)<em class="oq">如果你不知道什么是量子比特的叠加，现在忽略这一点</em></li><li id="dec2" class="nd ne it lc b ld nm lg nn lj no ln np lr nq lv ni nj nk nl bi translated"><strong class="lc iu"> H2 </strong>代表我们系统的一般能量状态，如上面等式1给出的</li><li id="09eb" class="nd ne it lc b ld nm lg nn lj no ln np lr nq lv ni nj nk nl bi translated">现在随着时间的推移(每一步)，我们想要从H1的基态转移到H2的基态</li><li id="6b36" class="nd ne it lc b ld nm lg nn lj no ln np lr nq lv ni nj nk nl bi translated">在任何时候，系统的状态将是H1对H2的凸组合，t ∈ [0，1] <br/> H (t) = (1-t) * H1 + t * H2</li><li id="977f" class="nd ne it lc b ld nm lg nn lj no ln np lr nq lv ni nj nk nl bi translated">注意，这个问题不容易解决，也很难解决，因为我们不知道在所有状态之间移动的正确转换速度(类似于在梯度下降中选择学习速率)</li></ul><h2 id="0200" class="ob me it bd mf oc od dn mj oe of dp mn lj og oh mp ln oi oj mr lr ok ol mt om bi translated">量子退火<strong class="ak">【简化绝热量子计算】</strong></h2><ul class=""><li id="61d1" class="nd ne it lc b ld mv lg mw lj on ln oo lr op lv ni nj nk nl bi translated">这是绝热量子计算的更可行/实用的版本，其中我们不是找到我们的目标系统的基态，而是开始在每次跃迁中找到许多不同的低能态(基于不同的跃迁速度)。我们希望能量最低的状态是目标系统的基态</li></ul><p id="bea2" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果您想了解更多相关信息，请查看以下链接:</p><ul class=""><li id="d9df" class="nd ne it lc b ld le lg lh lj nf ln ng lr nh lv ni nj nk nl bi translated"><a class="ae kz" href="https://arxiv.org/abs/cond-mat/0205280" rel="noopener ugc nofollow" target="_blank">量子退火</a><a class="ae kz" href="https://ai.googleblog.com/2015/12/when-can-quantum-annealing-win.html" rel="noopener ugc nofollow" target="_blank">更</a></li><li id="13c4" class="nd ne it lc b ld nm lg nn lj no ln np lr nq lv ni nj nk nl bi translated"><a class="ae kz" href="https://arxiv.org/abs/1511.03316" rel="noopener ugc nofollow" target="_blank">量子绝热计算</a></li><li id="bfb8" class="nd ne it lc b ld nm lg nn lj no ln np lr nq lv ni nj nk nl bi translated"><a class="ae kz" href="https://arxiv.org/abs/1812.01041" rel="noopener ugc nofollow" target="_blank">量子近似优化算法</a></li></ul><blockquote class="or os ot"><p id="d840" class="la lb oq lc b ld le ju lf lg lh jx li ou lk ll lm ov lo lp lq ow ls lt lu lv im bi translated"><strong class="lc iu">基本上，以上所有方法不知何故都会变成，我们得到一个等价的量子电路&amp;通过一个量子处理单元(QPU)结合我们的标准CPU来解决它。</strong></p></blockquote><p id="d5e5" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在这篇博客中，我们将假设我们被神奇地给予了一个量子电路来解决我们的问题&amp;我们想在一个有编程接口的QPU上解决它。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="f0f0" class="md me it bd mf mg ox mi mj mk oy mm mn jz oz ka mp kc pa kd mr kf pb kg mt mu bi translated">让我们编码</h1><p id="71b0" class="pw-post-body-paragraph la lb it lc b ld mv ju lf lg mw jx li lj mx ll lm ln my lp lq lr mz lt lu lv im bi translated">现在，我们将尝试构建一个简单的回归暨分类问题，在下面的笔记本中提供，但在这里我们将一点一点地打破它。</p><div class="pc pd gp gr pe pf"><a href="https://github.com/AbhishekAshokDubey/quantum-computing-101/blob/master/qml-101/tfq_ml_101.ipynb" rel="noopener  ugc nofollow" target="_blank"><div class="pg ab fo"><div class="ph ab pi cl cj pj"><h2 class="bd iu gy z fp pk fr fs pl fu fw is bi translated">AbhishekAshokDubey/量子计算-101</h2><div class="pm l"><h3 class="bd b gy z fp pk fr fs pl fu fw dk translated">permalink dissolve GitHub是超过5000万开发人员的家园，他们一起工作来托管和审查代码，管理…</h3></div><div class="pn l"><p class="bd b dl z fp pk fr fs pl fu fw dk translated">github.com</p></div></div><div class="po l"><div class="pp l pq pr ps po pt kt pf"/></div></div></a></div><p id="e951" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">同样，我们已经假设了问题的电路，主要由最后的MNIST问题电路驱动，如<a class="ae kz" href="https://arxiv.org/abs/1802.06002" rel="noopener ugc nofollow" target="_blank">法尔希等人</a> &amp;所建议的，也被<a class="ae kz" href="https://www.tensorflow.org/quantum/tutorials/mnist" rel="noopener ugc nofollow" target="_blank">谷歌TFQ MNIST的例子</a>所使用。</p><p id="c7af" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在开始之前，我们需要在tensorflow (TF)上安装tensorflow-quantum (TFQ)和Cirq。</p><ul class=""><li id="4bef" class="nd ne it lc b ld le lg lh lj nf ln ng lr nh lv ni nj nk nl bi translated"><strong class="lc iu"> tensorflow-quantum </strong>:作为任何底层QPU的编程语言(接口)。(很像GPU的CUDA)</li><li id="e185" class="nd ne it lc b ld nm lg nn lj no ln np lr nq lv ni nj nk nl bi translated"><strong class="lc iu"> Cirq </strong>:作为定义量子电路的编程语言</li></ul><pre class="kk kl km kn gt pu pv pw px aw py bi"><span id="2f15" class="ob me it pv b gy pz qa l qb qc">tensorflow &amp; pip install -q <strong class="pv iu">tensorflow</strong>==2.1.0<br/>pip install -q <strong class="pv iu">tensorflow-quantum</strong><br/>pip install -q <strong class="pv iu">cirq</strong></span></pre><p id="be4b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">让我们导入所有我们需要的包</p><pre class="kk kl km kn gt pu pv pw px aw py bi"><span id="d414" class="ob me it pv b gy pz qa l qb qc"><strong class="pv iu">import</strong> <strong class="pv iu">numpy</strong> <strong class="pv iu">as</strong> <strong class="pv iu">np</strong><br/><strong class="pv iu">import</strong> <strong class="pv iu">sympy</strong><br/><br/><em class="oq"># For Quantum ML</em><br/><strong class="pv iu">import</strong> <strong class="pv iu">cirq</strong><br/><strong class="pv iu">import</strong> <strong class="pv iu">tensorflow</strong> <strong class="pv iu">as</strong> <strong class="pv iu">tf</strong><br/><strong class="pv iu">import</strong> <strong class="pv iu">tensorflow_quantum</strong> <strong class="pv iu">as</strong> <strong class="pv iu">tfq</strong><br/><br/><em class="oq"># For Visualization</em><br/>%matplotlib inline<br/><strong class="pv iu">import</strong> <strong class="pv iu">matplotlib.pyplot</strong> <strong class="pv iu">as</strong> <strong class="pv iu">plt</strong><br/><strong class="pv iu">from</strong> <strong class="pv iu">cirq.contrib.svg</strong> <strong class="pv iu">import</strong> SVGCircuit</span></pre><p id="23c6" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">让我们为我们的问题制作一个虚拟玩具数据</p><pre class="kk kl km kn gt pu pv pw px aw py bi"><span id="7392" class="ob me it pv b gy pz qa l qb qc"><strong class="pv iu">def</strong> get_data(l):<br/>    data = np.random.randint(0,1,(l,2))<br/>    label = np.ones(l)<br/>    data[0::2,0]=1<br/>    data[1::2,1]=1<br/>    label[0::2] = -1<br/>    p = np.random.permutation(l)<br/>    <strong class="pv iu">return</strong> data[p], label[p]<br/><br/>x_train, y_train = get_data(5000)<br/>x_test, y_test = get_data(200)</span><span id="b91d" class="ob me it pv b gy qd qa l qb qc">print(pd.DataFrame(np.concatenate((x_train, np.reshape(y_train, (-1,1))), axis=1) , columns=["x1", "x2", "y"]))</span></pre><p id="ebd7" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">生成的数据如下所示，上面打印语句的输出。基本上x1 =1 → y = -1，x2 =1 → y = +1。不要问我为什么，但这看起来像是解决简单问题的方法:)</p><pre class="kk kl km kn gt pu pv pw px aw py bi"><span id="fb60" class="ob me it pv b gy pz qa l qb qc">      x1   x2    y<br/>0     1.0  0.0 -1.0<br/>1     1.0  0.0 -1.0<br/>2     1.0  0.0 -1.0<br/>3     <em class="oq">0.0  1.0  1.0</em><br/>4     1.0  0.0 -1.0<br/>...   ...  ...  ...<br/>4995  1.0  0.0 -1.0<br/>4996  <em class="oq">0.0  1.0  1.0</em><br/>4997  1.0  0.0 -1.0<br/>4998  1.0  0.0 -1.0<br/>4999  1.0  0.0 -1.0</span></pre><p id="5fda" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">关于量子数据的一个有趣的事实是，它不能被存储&amp;它只能作为量子电路本身产生/提供。<a class="ae kz" href="https://hackernoon.com/quantum-facts-funny-and-weird-at-the-same-time-1g3g3wjr" rel="noopener ugc nofollow" target="_blank">多检查几个</a></p><p id="b1c8" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">因此，我们上面生成每个数据点都应该被转换成等效的量子电路。所以基本上对于<strong class="lc iu"> 0 </strong>位我们什么都不做，但是我们通过一个<strong class="lc iu"> 1 </strong>位虽然不是门。下面是一个简单的函数来做同样的事情，将0/1上的数据转换成等效电路</p><pre class="kk kl km kn gt pu pv pw px aw py bi"><span id="9449" class="ob me it pv b gy pz qa l qb qc"><strong class="pv iu">def</strong> convert_to_circuit(x):<br/>    qubits = cirq.GridQubit.rect(1, 2)<br/>    circuit = cirq.Circuit()<br/>    <strong class="pv iu">for</strong> i, val <strong class="pv iu">in</strong> enumerate(x):<br/>        <strong class="pv iu">if</strong> val:<br/>            circuit.append(cirq.X(qubits[i]))<br/>    <strong class="pv iu">return</strong> circuit</span></pre><p id="3ccb" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">所以，让我们得到经典数据集中每个数据点的等效量子数据(电路)。</p><pre class="kk kl km kn gt pu pv pw px aw py bi"><span id="266c" class="ob me it pv b gy pz qa l qb qc">x_train_circ = [convert_to_circuit(x) <strong class="pv iu">for</strong> x <strong class="pv iu">in</strong> x_train]<br/>x_test_circ = [convert_to_circuit(x) <strong class="pv iu">for</strong> x <strong class="pv iu">in</strong> x_test]</span></pre><p id="9df2" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">为了将上面用CIRQ生成的电路/数据点传递到TFQ，我们需要将每个电路/数据点转换成TFQ张量。</p><pre class="kk kl km kn gt pu pv pw px aw py bi"><span id="4314" class="ob me it pv b gy pz qa l qb qc">x_train_tfcirc = tfq.convert_to_tensor(x_train_circ)<br/>x_test_tfcirc = tfq.convert_to_tensor(x_test_circ)</span></pre><p id="a569" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">现在我们已经准备好了我们的量子数据，我们现在需要的是解决我们问题的量子电路&amp;一个解决它的方法:)</p><p id="5f0e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如上所述，让我们假设一个电路，即使它对于手头的问题不是最好的，但是我们相信如果一个类似的电路可以解决简化的MNIST二进制(3对6)数字分类，它应该很容易解决我们的问题</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi qe"><img src="../Images/332dd9fa96b0887087c60925d2723f07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*x0oLqHsskXPuIKCsW_JefQ.png"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated"><strong class="bd nb">图三</strong>问题电路模型</p></figure><p id="ff0a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这里(-1，-1)行/量子位是我们的最终输出类预测，而(0，0)和(1，0)量子位是我们的输入数据。</p><p id="4bbf" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">那么，让我们在CIRQ中构建上述电路。</p><pre class="kk kl km kn gt pu pv pw px aw py bi"><span id="0f26" class="ob me it pv b gy pz qa l qb qc">input_qubits = cirq.GridQubit.rect(2, 1)  <em class="oq"># 2x1 grid.</em><br/>readout = cirq.GridQubit(-1, -1)   <em class="oq"># a qubit at [-1,-1]</em><br/>model_circuit = cirq.Circuit()<br/><br/>model_circuit.append(cirq.X(readout))<br/>model_circuit.append(cirq.H(readout))<br/><br/>alpha1 = sympy.Symbol('a1')<br/>model_circuit.append(cirq.XX(input_qubits[0], readout)**alpha1)<br/><br/>alpha2 = sympy.Symbol('a2')<br/>model_circuit.append(cirq.XX(input_qubits[1], readout)**alpha2)<br/><br/>beta1 = sympy.Symbol('b1')<br/>model_circuit.append(cirq.ZZ(input_qubits[0], readout)**beta1)<br/><br/>beta2 = sympy.Symbol('b2')<br/>model_circuit.append(cirq.ZZ(input_qubits[1], readout)**beta2)<br/><br/>model_circuit.append(cirq.H(readout))<br/>model_readout = cirq.Z(readout)</span><span id="3c8c" class="ob me it pv b gy qd qa l qb qc">SVGCircuit(model_circuit)</span></pre><p id="0bf5" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><code class="fe qf qg qh pv b">SVGCircuit(model_circuit)</code>代码/命令应该能够在嵌入式控制台上绘制电路图像。</p><blockquote class="or os ot"><p id="0e3f" class="la lb oq lc b ld le ju lf lg lh jx li ou lk ll lm ov lo lp lq ow ls lt lu lv im bi translated"><strong class="lc iu">从这里开始，事情会变得和经典的机器学习一样有意义</strong></p></blockquote><p id="fc12" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">现在更像Keras序列神经网络模型，我们将建立一个模型来解决我们的问题电路。</p><pre class="kk kl km kn gt pu pv pw px aw py bi"><span id="55d6" class="ob me it pv b gy pz qa l qb qc"><em class="oq"># Build the model.</em><br/>model = tf.keras.Sequential([<br/>    <em class="oq"># The input is the data-circuit, encoded as a tf.string</em><br/>    tf.keras.layers.Input(shape=(), dtype=tf.string),<br/>    <em class="oq"># PQC layer returns the expected val of the readout gate @[-1,1]</em><br/>    tfq.layers.PQC(model_circuit, model_readout),<br/>])</span></pre><p id="334b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">最后，我们需要定义损失函数、优化器和指标来跟踪。</p><pre class="kk kl km kn gt pu pv pw px aw py bi"><span id="9c3a" class="ob me it pv b gy pz qa l qb qc">model.compile(<br/>    loss=tf.keras.losses.MeanSquaredError(),<br/>    optimizer=tf.keras.optimizers.Adam(),<br/>    metrics=[accuracy])</span></pre><p id="c217" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">下面是我们目前构建的模型包含的内容(来自模型摘要)</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi qi"><img src="../Images/b2b5d696938d7f440a461a553c574224.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*8RW5v8d9u-15_pZPMnuVWg.png"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated"><strong class="bd nb">图4 </strong>。模型摘要</p></figure><p id="99b8" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">让我们用量子数据来训练我们的量子电路模型。</p><pre class="kk kl km kn gt pu pv pw px aw py bi"><span id="fae4" class="ob me it pv b gy pz qa l qb qc">model_history = model.fit(<br/>      x_train_tfcirc, y_train,<br/>      batch_size=200,<br/>      epochs=5,<br/>      verbose=1,<br/>      validation_data=(x_test_tfcirc, y_test))<br/><br/>results = model.evaluate(x_test_tfcirc, y_test)</span></pre><p id="c68f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">以下是您的训练和验证数据丢失(&amp;准确性)将如何随着每个历元而变化。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi qj"><img src="../Images/952a503e22069c2ce20365a20d68220d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/1*PAvCbUs9Giy57KDzNG_smw.png"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated"><strong class="bd nb">图5 </strong>。量子训练历史</p></figure><p id="26bd" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">希望一切顺利，试着从测试数据中预测值。</p><pre class="kk kl km kn gt pu pv pw px aw py bi"><span id="b385" class="ob me it pv b gy pz qa l qb qc">print(list(zip(model.predict(x_test_tfcirc).ravel()[:10], y_test[:10])))<br/></span><span id="f0a7" class="ob me it pv b gy qd qa l qb qc">[(-0.7765335, -1.0),<br/>(0.77620333, 1.0),<br/>(0.77620333, 1.0),<br/>(0.77620333, 1.0),<br/>(-0.7765335, -1.0),<br/>(0.77620333, 1.0),<br/>(-0.7765335, -1.0),<br/>(0.77620333, 1.0),<br/>(0.77620333, 1.0),<br/>(0.77620333, 1.0)]</span></pre><p id="1cfa" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">基于以上，你会认为我们已经解决了一个经典的分类问题，即回归问题，所以请继续改进它<br/> <a class="ae kz" href="https://github.com/AbhishekAshokDubey/quantum-computing-101/blob/master/qml-101/tfq_classifier_101.ipynb" rel="noopener ugc nofollow" target="_blank">提示:铰链丢失？</a></p><p id="83ad" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">最后，一旦你理解了这一点，对你来说，编写你自己的简单的MNIST两类分类器就容易多了，而不需要参考谷歌的教程:)</p><p id="0e6a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果您想知道量子处理单元如何与当前的处理单元结合使用，以及我们上面使用的所有东西在更大的画面中适合什么位置(？).<br/>谷歌TFQ团队的以下架构将为你提供一些快速的提示。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi qk"><img src="../Images/af5309e8806a183a441430e41c2ae86c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/0*9RXU3kQ5t_ci12Ve.png"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">张量流量子栈:<a class="ae kz" href="https://youtu.be/-o9AhIz1uvo?t=1247" rel="noopener ugc nofollow" target="_blank">https://youtu.be/-o9AhIz1uvo?t=1247</a></p></figure><p id="db59" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">现在是时候从一个更小的玩具例子转移到一个更好的玩具例子了，试试下面。</p><div class="pc pd gp gr pe pf"><a href="https://arxiv.org/abs/1802.06002" rel="noopener  ugc nofollow" target="_blank"><div class="pg ab fo"><div class="ph ab pi cl cj pj"><h2 class="bd iu gy z fp pk fr fs pl fu fw is bi translated">用量子神经网络在近期处理器上进行分类</h2><div class="pm l"><h3 class="bd b gy z fp pk fr fs pl fu fw dk translated">我们介绍了一个量子神经网络，QNN，它可以代表标记数据，经典或量子，并训练…</h3></div><div class="pn l"><p class="bd b dl z fp pk fr fs pl fu fw dk translated">arxiv.org</p></div></div></div></a></div><div class="pc pd gp gr pe pf"><a href="https://www.tensorflow.org/quantum/tutorials/mnist" rel="noopener  ugc nofollow" target="_blank"><div class="pg ab fo"><div class="ph ab pi cl cj pj"><h2 class="bd iu gy z fp pk fr fs pl fu fw is bi translated">MNIST分类|张量流量子</h2><div class="pm l"><h3 class="bd b gy z fp pk fr fs pl fu fw dk translated">更高分辨率的输入和更强大的模型使CNN很容易解决这个问题。而一个经典的模型…</h3></div><div class="pn l"><p class="bd b dl z fp pk fr fs pl fu fw dk translated">www.tensorflow.org</p></div></div><div class="po l"><div class="ql l pq pr ps po pt kt pf"/></div></div></a></div><h1 id="7bb0" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">干杯&amp;快乐学习！！！</h1><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="qm qn l"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated"><a class="ae kz" href="https://giphy.com/" rel="noopener ugc nofollow" target="_blank">giphy.com</a>:<a class="ae kz" href="https://gph.is/g/ap0YjGy" rel="noopener ugc nofollow" target="_blank">https://gph.is/g/ap0YjGy</a></p></figure><p id="4c58" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">参考资料:</p><ol class=""><li id="53a4" class="nd ne it lc b ld le lg lh lj nf ln ng lr nh lv qo nj nk nl bi translated">【https://www.youtube.com/watch?v=16ZfkPRVf2w T4】</li><li id="8065" class="nd ne it lc b ld nm lg nn lj no ln np lr nq lv qo nj nk nl bi translated"><a class="ae kz" href="https://github.com/AbhishekAshokDubey/quantum-computing-101/tree/master/qml-101" rel="noopener ugc nofollow" target="_blank">https://github . com/AbhishekAshokDubey/quantum-computing-101/tree/master/qml-101</a></li><li id="4a95" class="nd ne it lc b ld nm lg nn lj no ln np lr nq lv qo nj nk nl bi translated"><a class="ae kz" href="https://www.tensorflow.org/quantum/tutorials/mnist" rel="noopener ugc nofollow" target="_blank">https://www.tensorflow.org/quantum/tutorials/mnist</a></li><li id="9110" class="nd ne it lc b ld nm lg nn lj no ln np lr nq lv qo nj nk nl bi translated"><a class="ae kz" href="https://www.youtube.com/watch?v=-o9AhIz1uvo" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=-o9AhIz1uvo</a></li><li id="e822" class="nd ne it lc b ld nm lg nn lj no ln np lr nq lv qo nj nk nl bi translated"><a class="ae kz" href="https://medium.com/@adubey40/quantum-computing-101-1ed742540ba2" rel="noopener">https://medium . com/@ adubey 40/quantum-computing-101-1ed 742540 ba 2</a></li></ol></div></div>    
</body>
</html>