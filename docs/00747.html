<html>
<head>
<title>Traffic Sign Recognition with TensorFlow 2.x</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用TensorFlow 2.x识别交通标志</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/traffic-sign-recognition-with-tensorflow-2-x-7ab4e8611a83?source=collection_archive---------23-----------------------#2020-01-21">https://towardsdatascience.com/traffic-sign-recognition-with-tensorflow-2-x-7ab4e8611a83?source=collection_archive---------23-----------------------#2020-01-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e5df" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">从原始图像处理到模型评估的端到端示例</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/249d16aad583cbe0c339460b435eacd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ncftMvgEvKRELSsQzDbwtA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">左:TensorFlow logo。图片来源:tensorflow.com右:原始和灰度交通标志来自下面的数据</p></figure><h1 id="47e4" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">介绍</h1><p id="7caa" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">TensorFlow是一个软件库，以其在神经网络中的灵活性和易用性而闻名。您可以在网上找到许多从图像分类到对象检测的示例，但其中许多都基于TensorFlow 1.x。从TensorFlow 1.0到2.0有一个很大的变化，Keras集成更紧密，重点是更高级别的API。很多方法已经折旧了(也可以用<code class="fe mj mk ml mm b">tf.compat.v1</code>)。模型构建变得容易多了，每个模型中的默认参数已经可以很好地用于一般用途。尽管有这么多好处，但如果您需要更改参数，它仍然提供了灵活性。</p><p id="d649" class="pw-post-body-paragraph ln lo iq lp b lq mn jr ls lt mo ju lv lw mp ly lz ma mq mc md me mr mg mh mi ij bi translated">在这篇文章中，我将使用TensorFlow 2.0(更具体地说，TensorFlow中的Keras)对交通标志进行分类。网络上很多地方都有数据集，但我将使用Kaggle 上的这个<a class="ae ms" href="https://www.kaggle.com/meowmeowmeowmeowmeow/gtsrb-german-traffic-sign" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="e644" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">数据概述</h1><p id="36e7" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">数据包包括<code class="fe mj mk ml mm b">Train</code>、<code class="fe mj mk ml mm b">Test</code>和一个<code class="fe mj mk ml mm b">test.csv</code>的文件夹。有一个<code class="fe mj mk ml mm b">meta.csv</code>和一个<code class="fe mj mk ml mm b">Meta</code>文件夹来显示每个交通标志的标准图像。还有一个<code class="fe mj mk ml mm b">signname.csv</code>用于将标签映射到它的描述。<code class="fe mj mk ml mm b">Train</code>文件夹包含43个子文件夹，子文件夹的名称是其中图像的标签。例如，文件夹<code class="fe mj mk ml mm b">0</code>中的所有图像都有一个类别标签<code class="fe mj mk ml mm b">0</code>等等……这些图像的大小从20x20到70x70不等，并且都有3个通道:RGB。</p><p id="98e4" class="pw-post-body-paragraph ln lo iq lp b lq mn jr ls lt mo ju lv lw mp ly lz ma mq mc md me mr mg mh mi ij bi translated">所以我要做的第一件事是将所有图像的大小调整为32x32x3，并将它们读入numpy数组作为训练特征。同时，我创建了另一个numpy数组，其中包含每个图像的标签，这些标签来自加载图像的文件夹名称。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="7ce8" class="pw-post-body-paragraph ln lo iq lp b lq mn jr ls lt mo ju lv lw mp ly lz ma mq mc md me mr mg mh mi ij bi translated">我需要做同样的测试图像。然而，用于测试图像的标签与该图像的路径一起存储为<code class="fe mj mk ml mm b">test.csv</code>中的<code class="fe mj mk ml mm b">ClassId </code>。所以我使用pandas来读取<code class="fe mj mk ml mm b">csv </code>文件，从path加载图像并分配相应的<code class="fe mj mk ml mm b">ClassId</code>。</p><p id="2bbd" class="pw-post-body-paragraph ln lo iq lp b lq mn jr ls lt mo ju lv lw mp ly lz ma mq mc md me mr mg mh mi ij bi translated">从训练集中，我随机抽取了20%作为模型训练过程中使用的验证集。训练和验证的模型精度将为我们提供关于欠拟合或过拟合的信息。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="a464" class="pw-post-body-paragraph ln lo iq lp b lq mn jr ls lt mo ju lv lw mp ly lz ma mq mc md me mr mg mh mi ij bi translated">接下来，我将图像转换成灰度，并对每个像素进行归一化处理。归一化使模型收敛更快。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="036f" class="pw-post-body-paragraph ln lo iq lp b lq mn jr ls lt mo ju lv lw mp ly lz ma mq mc md me mr mg mh mi ij bi translated">这是RGB和灰度图像之间的比较。灰度图像仍然保留其特征，并且可以被识别，但是尺寸小得多。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/a18179a25875943f97e67352d2f5e2d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/format:webp/1*A3Rv3vF1j15dBEuT23of0w.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">原始图像和灰度图像的比较</p></figure><h1 id="d827" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">模型构建</h1><p id="f624" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我将使用Yann LeCun等人在1998年发表的著名LeNet，输入形状为32x32x1。第一个卷积层的深度为6，过滤器大小为(5，5)，跨距为(1，1)。使用了有效的填充(即没有填充)。因此，该层的宽度(或高度)为32–5+1 = 28，即形状为28x28x6。该层的激活是relu。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="7bab" class="pw-post-body-paragraph ln lo iq lp b lq mn jr ls lt mo ju lv lw mp ly lz ma mq mc md me mr mg mh mi ij bi translated">第一个卷积层之后是最大轮询层。它通过仅选择相邻像素的最大值像素来有效地缩减数据。LeNet使用(2，2)内核大小。默认步幅与内核相同，这意味着从其中选择最大值的像素组之间没有重叠。现在输出的形状变成了14x14x6。</p><p id="2edb" class="pw-post-body-paragraph ln lo iq lp b lq mn jr ls lt mo ju lv lw mp ly lz ma mq mc md me mr mg mh mi ij bi translated">下一个LeNet有第二个卷积层，深度为16，过滤器大小为(5，5)和relu激活函数，后面是最大池层。输出的宽度(或高度)现在是(14–5+1)/2 = 5，即形状是5x5x16。</p><p id="36bb" class="pw-post-body-paragraph ln lo iq lp b lq mn jr ls lt mo ju lv lw mp ly lz ma mq mc md me mr mg mh mi ij bi translated">然后，数据在完全连接的层之前被展平。输出的形状是5x5x16 = 400。随后是2个完全连接的层，尺寸为120和84，relu作为两者的激活功能。增加一个脱落层以减少过度拟合。最后是大小为43(类的数量)的全连接层。Softmax用于返回每个类别的概率。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="40b1" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">模型训练和评估</h1><p id="a750" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">Keras的培训非常简单。我们只需要指定优化器、损失函数和验证度量。在10个时期内，训练和验证的准确度都在0.97以上。对于脱层，没有明显的过度拟合。另一方面，增加训练只会产生最小的改善，所以我只在10个周期后就停止了。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="b7a9" class="pw-post-body-paragraph ln lo iq lp b lq mn jr ls lt mo ju lv lw mp ly lz ma mq mc md me mr mg mh mi ij bi translated">我们还可以绘制每个时期训练和验证的模型性能。事实上，该模型似乎相当一般化，并且没有过度拟合训练数据。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mw"><img src="../Images/85be331d548d02f30da003c3203f1b39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4puyR3580lt4IhAuK6no_Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">每个历元的训练和验证的准确性和损失</p></figure><p id="5c85" class="pw-post-body-paragraph ln lo iq lp b lq mn jr ls lt mo ju lv lw mp ly lz ma mq mc md me mr mg mh mi ij bi translated">最后，利用该模型对测试集的标签进行预测。精度在0.925左右。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="3e4d" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">结论</h1><p id="2405" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">之前我写过一篇关于从零开始构建神经网络的文章，这需要核心的线性代数。通过使用TensorFlow这样的库，任务变得容易多了，模型也更强大了。</p></div><div class="ab cl mx my hu mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ij ik il im in"><p id="481b" class="pw-post-body-paragraph ln lo iq lp b lq mn jr ls lt mo ju lv lw mp ly lz ma mq mc md me mr mg mh mi ij bi translated"><em class="ne">可以从</em> <a class="ae ms" href="https://github.com/JunWorks/Traffic-Sign-Classifier" rel="noopener ugc nofollow" target="_blank"> <em class="ne">这里</em> </a> <em class="ne">获取完整代码。</em></p></div></div>    
</body>
</html>