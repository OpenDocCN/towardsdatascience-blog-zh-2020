<html>
<head>
<title>Write Better Python Code With These 10 Tricks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用这 10 个技巧写出更好的 Python 代码</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/write-better-python-code-with-these-10-tricks-30b7018e247a?source=collection_archive---------3-----------------------#2020-08-02">https://towardsdatascience.com/write-better-python-code-with-these-10-tricks-30b7018e247a?source=collection_archive---------3-----------------------#2020-08-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="90ae" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">提高您的 Python 技能</h2><div class=""/><div class=""><h2 id="d861" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">学习如何用 Pythonic 的方式编码</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/23febd9826a56966f909cdafd1fce3af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sGdDV8Zz2U7-5n3l"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/@cgower?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克里斯托弗·高尔</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="9fd0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">编码很有趣，用 Python 编码更有趣，因为有许多不同的方法来完成相同的功能。然而，大多数时候，都有首选的实现，有些人称之为 Pythonic。这些 Pythonic 实现的一个共同特点是代码简洁明了。</p><p id="9a7d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">用 Python 或任何编码语言编程都不是火箭科学，它主要是关于制作技能。如果您有意尝试 Pythonic 编码，这些技术将很快成为您的工具包的一部分，并且您会发现在您的项目中使用它们会越来越自然。因此，让我们来探索一些简单的技巧，希望对你有所帮助。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="cef7" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated">1.负索引</h2><p id="7122" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">人们喜欢使用序列，因为我们知道元素的顺序，并且我们可以按顺序操作这些元素。在 Python 中，字符串、元组和列表是最常见的序列数据类型。我们可以使用索引来访问单个项目。像其他主流编程语言一样，Python 支持基于 0 的索引，其中我们使用一对方括号中的 0 来访问第一个元素。此外，我们还可以使用 slice 对象来检索序列中的特定元素，如下面的代码示例所示。</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="32d9" class="ml mm it nj b gy nn no l np nq">&gt;&gt;&gt; # Positive Indexing<br/>... numbers = [1, 2, 3, 4, 5, 6, 7, 8]<br/>... print("First Number:", numbers[0])<br/>... print("First Four Numbers:", numbers[:4])<br/>... print("Odd Numbers:", numbers[::2])<br/>... <br/>First Number: 1<br/>First Four Numbers: [1, 2, 3, 4]<br/>Odd Numbers: [1, 3, 5, 7]</span></pre><p id="f2ac" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，Python 更进了一步，支持负索引。具体来说，我们可以使用-1 来引用序列中的最后一个元素，并对项目进行反向计数。例如，倒数第二个元素的索引为-2，依此类推。重要的是，负索引也可以与切片对象中的正索引一起工作。</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="46c2" class="ml mm it nj b gy nn no l np nq">&gt;&gt;&gt; # Negative Indexing<br/>... data_shape = (100, 50, 4)<br/>... names = ["John", "Aaron", "Mike", "Danny"]<br/>... hello = "Hello World!"<br/>... <br/>... print(data_shape[-1])<br/>... print(names[-3:-1])<br/>... print(hello[1:-1:2])<br/>... <br/>4<br/>['Aaron', 'Mike']<br/>el ol</span></pre></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="0d0c" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated">2.检查容器的空度</h2><p id="410b" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">容器是指那些可以存储其他数据的容器数据类型。一些常用的内置容器是元组、列表、字典和集合。当我们处理这些容器时，我们经常需要在执行附加操作之前检查它们是否包含任何元素。事实上，我们可以检查这些容器的长度，它对应于存储项目的数量。当长度为零时，容器为空。下面给你看一个简单的例子。</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="4459" class="ml mm it nj b gy nn no l np nq">if len(some_list) &gt; 0:<br/>    # do something here when the list is not empty<br/>else:<br/>    # do something else when the list is empty</span></pre><p id="9cd0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，这并不是最有效的方法。相反，我们可以简单地检查容器本身，它将在包含元素时计算<code class="fe nr ns nt nj b">True</code>。虽然下面的代码向您展示了主要的容器数据类型，但是这种用法也适用于字符串(即任何非空字符串都是<code class="fe nr ns nt nj b">True</code>)。</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="5fdc" class="ml mm it nj b gy nn no l np nq">&gt;&gt;&gt; def check_container_empty(container):<br/>...     if container:<br/>...         print(f"{container} has elements.")<br/>...     else:<br/>...         print(f"{container} doesn't have elements.")<br/>... <br/>... check_container_empty([1, 2, 3])<br/>... check_container_empty(set())<br/>... check_container_empty({"zero": 0, "one": 1})<br/>... check_container_empty(tuple())<br/>... <br/>[1, 2, 3] has elements.<br/>set() doesn't have elements.<br/>{'zero': 0, 'one': 1} has elements.<br/>() doesn't have elements.</span></pre></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="e17c" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated">3.用 Split()创建字符串列表</h2><p id="8930" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">我们经常使用字符串作为特定对象的标识符。例如，我们可以使用字符串作为字典中的关键字。在数据科学项目中，字符串通常是数据的列名。当我们选择多个列时，我们不可避免地需要创建一个字符串列表。事实上，我们可以在列表中使用文字创建字符串。然而，我们必须用引号将每个字符串括起来，这对于我们这些“懒人”来说有点乏味。因此，我更喜欢利用字符串的<code class="fe nr ns nt nj b">split()</code>方法创建一个字符串列表，如下面的代码片段所示。</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="b672" class="ml mm it nj b gy nn no l np nq">&gt;&gt;&gt; # List of strings<br/>... # The typical way<br/>... columns = ['name', 'age', 'gender', 'address', 'account_type']<br/>... print("* Literals:", columns)<br/>... <br/>... # Do this instead<br/>... columns = 'name age gender address account_type'.split()<br/>... print("* Split with spaces:", columns)<br/>... <br/>... # If the strings contain spaces, you can use commas instead<br/>... columns = 'name, age, gender, address, account type'.split(', ')<br/>... print("* Split with commas:", columns)<br/>... <br/>* Literals: ['name', 'age', 'gender', 'address', 'account_type']<br/>* Split with spaces: ['name', 'age', 'gender', 'address', 'account_type']<br/>* Split with commas: ['name', 'age', 'gender', 'address', 'account type']</span></pre><p id="85da" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如上所示，<code class="fe nr ns nt nj b">split()</code>方法默认使用空格作为分隔符，并从字符串创建一个字符串列表。值得注意的是，当您创建一个包含一些包含空格的元素的字符串列表时，您可以选择使用不同类型的分隔符(例如，逗号)。</p><p id="2ba6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这种用法受到一些内置功能的启发。例如，当你创建一个命名的元组类时，我们可以这样做:<code class="fe nr ns nt nj b">Student = namedtuple(“Student”, [“name”, “gender”, “age”])</code>。字符串列表指定了元组的“属性”然而，通过这样定义该类，它本身也得到支持:<code class="fe nr ns nt nj b">Student = namedtuple(“Student”, “name gender age”)</code>。再举一个例子，创建一个<em class="nu">枚举</em>类支持相同的替代解决方案。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="b91a" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated">4.三元表达式</h2><p id="54b3" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">在许多用例中，我们需要根据条件定义具有特定值的变量，我们可以简单地使用<em class="nu"> if…else </em>语句来检查条件。然而，它需要几行代码。如果我们只处理一个变量的赋值，我们可能想要使用三元表达式，它只需要一行代码就可以检查条件并完成赋值。此外，它的形式更短，这使得代码更加简洁。考虑下面的例子。</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="d672" class="ml mm it nj b gy nn no l np nq"># The typical way<br/>if score &gt; 90:<br/>    reward = "1000 dollars"<br/>else:<br/>    reward = "500 dollars"</span><span id="1d6d" class="ml mm it nj b gy nv no l np nq"># Do this instead<br/>reward = "1000 dollars" if score &gt; 90 else "500 dollars"</span></pre><p id="b04e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">有时候，我们可以从一个已定义的函数中获取一些数据，我们可以利用这一点，写一个三元表达式的速记运算，如下所示。</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="cf8a" class="ml mm it nj b gy nn no l np nq"># Another possible scenario<br/># You got a reward amount from somewhere else, but don't know if None/0 or not<br/>reward = reward_known or "500 dollars"<br/># The above line of code is equivalent to below<br/>reward = reward_known if reward_known else "500 dollars"</span></pre></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="1e2f" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated">5.文件对象的 With 语句</h2><p id="96e4" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">我们经常需要从文件中读取数据，并向文件中写入数据。最常见的方法是简单地使用内置的<code class="fe nr ns nt nj b">open()</code>函数打开一个文件，它创建了一个我们可以操作的文件对象。您以前遇到过以下问题吗？</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="401a" class="ml mm it nj b gy nn no l np nq">&gt;&gt;&gt; # Create a text file that has the text: Hello World!<br/>... <br/>... # Open the file and append some new data<br/>... text_file0 = open("hello_world.txt", "a")<br/>... text_file0.write("Hello Python!")<br/>... <br/>... # Open the file again for something else<br/>... text_file1 = open("hello_world.txt")<br/>... print(text_file1.read())<br/>... <br/>Hello World!</span></pre><p id="a595" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在前面的代码片段中，我们从一个文本文件开始，该文件包含文本“Hello World！”然后，我们将一些新数据添加到文件中。然而，过了一会儿，我们又想在文件上工作了；当我们读取文本文件时，它仍然有旧的数据。换句话说，附加的文本不包括在文本文件中。为什么会这样？</p><p id="78a9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是因为我们没有首先关闭文件对象。如果不关闭文件，将无法保存更改。事实上，我们可以在 file 对象上显式调用<code class="fe nr ns nt nj b">close()</code>方法。但是，我们可以使用“with”语句来实现这一点，它会自动为我们关闭 file 对象，如下所示。当我们完成对文件的操作时，我们可以通过访问 file 对象的<code class="fe nr ns nt nj b">closed</code>属性来验证文件是否被关闭。</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="18f7" class="ml mm it nj b gy nn no l np nq">&gt;&gt;&gt; with open("hello_world.txt", "a") as file:<br/>...     file.write("Hello Python!")<br/>... <br/>... with open("hello_world.txt") as file:<br/>...     print(file.read())<br/>... <br/>... print("Is file close?", file.closed)<br/>... <br/>Hello World!Hello Python!Hello Python!<br/>Is file close? True</span></pre><p id="1748" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">更一般地说，<em class="nu"> with </em>语句是在 Python 中使用上下文管理器的语法。前面的例子涉及文件操作，因为文件是共享资源，我们负责释放这些资源。上下文管理器可以帮助我们完成工作。如前所示，文件操作结束后，通过使用带有语句的<em class="nu">自动关闭文件。你可以在我的<a class="ae lh" href="https://medium.com/better-programming/context-managers-in-python-go-beyond-with-open-as-file-85a27e392114" rel="noopener">上一篇文章</a>中了解更多关于上下文管理的内容。</em></p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="a9b2" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated">6.评估多个条件</h2><p id="8f36" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">我们经常需要评估多种情况。有几种可能的情况。对于数值，我们可以对同一个变量进行多次比较。在这种情况下，我们可以将这些比较链接起来。</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="bf48" class="ml mm it nj b gy nn no l np nq"># Multiple Comparisons<br/># The typical way<br/>if a &lt; 4 and a &gt; 1:<br/>    # do something here</span><span id="a6a5" class="ml mm it nj b gy nv no l np nq"># Do this instead<br/>if 1 &lt; a &lt; 4:<br/>    # do somerthing here</span></pre><p id="0a02" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在其他一些场景中，我们可以进行多重等式比较，并且我们可以利用下面的技术，使用关键字中的<em class="nu">进行成员测试。</em></p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="72ac" class="ml mm it nj b gy nn no l np nq"># The typical way<br/>if b == "Mon" or b == "Wed" or b == "Fri" or b == "Sun":<br/>    # do something here</span><span id="462c" class="ml mm it nj b gy nv no l np nq"># Do this instead, you can also specify a tuple ("Mon", "Wed", "Fri", "Sun")<br/>if b in "Mon Wed Fri Sun".split():<br/>    # do something here</span></pre><p id="10de" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">另一种技术是使用内置的<code class="fe nr ns nt nj b">all()</code>和<code class="fe nr ns nt nj b">any()</code>函数来评估多个条件。具体来说，当 iterable 中的元素都是<code class="fe nr ns nt nj b">True</code>时，<code class="fe nr ns nt nj b">all()</code>函数的计算结果将是<code class="fe nr ns nt nj b">True</code>，因此该函数适合代替一系列的 and 逻辑比较。另一方面，当 iterable 中的任何元素为<code class="fe nr ns nt nj b">True</code>时，<code class="fe nr ns nt nj b">any()</code>函数将计算为<code class="fe nr ns nt nj b">True</code>，因此适合替换一系列 OR 逻辑运算。相关的例子如下。</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="5e58" class="ml mm it nj b gy nn no l np nq"># The typical ways<br/>if a &lt; 10 and b &gt; 5 and c == 4:<br/>    # do something</span><span id="473f" class="ml mm it nj b gy nv no l np nq">if a &lt; 10 or b &gt; 5 or c == 4:<br/>    # do something</span><span id="90b0" class="ml mm it nj b gy nv no l np nq"># Do these instead<br/>if all([a &lt; 10, b &gt; 5, c == 4]):<br/>    # do something</span><span id="90d7" class="ml mm it nj b gy nv no l np nq">if any([a &lt; 10, b &gt; 5, c == 4]):<br/>    # do something</span></pre></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="9098" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated">7.在函数声明中使用默认值</h2><p id="f574" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">在几乎所有的 Python 项目中，大部分代码都涉及到创建和调用函数。换句话说，我们不断地处理函数声明和重构。在许多情况下，我们需要多次调用一个函数。根据不同的参数集，该函数的运行方式会略有不同。然而，有时一组参数可能比其他参数更常用，在这种情况下，我们应该考虑在声明函数时设置默认值。考虑下面这个微不足道的例子。</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="742b" class="ml mm it nj b gy nn no l np nq"># The original form:<br/>def generate_plot(data, image_name):<br/>    """This function creates a scatter plot for the data"""<br/>    # create the plot based on the data<br/>    ...<br/>    if image_name:<br/>        # save the image<br/>        ...</span><span id="b5b7" class="ml mm it nj b gy nv no l np nq"># In many cases, we don't need to save the image<br/>generate_plot(data, None)</span><span id="3689" class="ml mm it nj b gy nv no l np nq"># The one with a default value<br/>def generate_plot(data, image_name=None):<br/>    pass</span><span id="e0d8" class="ml mm it nj b gy nv no l np nq"># Now, we can omit the second parameter<br/>generate_plot(data)</span></pre><p id="8f2c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">需要注意的一点是，如果在设置默认值时处理可变数据类型(例如，列表、集合)，请确保使用<code class="fe nr ns nt nj b">None</code>而不是构造函数(例如，arg_name=[])。因为 Python 在定义函数对象的地方创建函数对象，所以提供空列表会被函数对象“卡住”。换句话说，函数对象不会在你调用它的时候被创建。相反，您将在内存中处理同一个函数对象，包括它最初创建的默认可变对象，这可能会导致意想不到的行为(更多讨论见<a class="ae lh" href="https://medium.com/better-programming/top-5-mistakes-you-make-when-declaring-functions-in-python-b7a0747711a4" rel="noopener">。</a></p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="ab9f" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated">8.使用计数器进行元素计数</h2><p id="38a8" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">当我们在一个列表、元组或字符串中有多个项目时(例如，多个字符)，我们经常想要计算每个项目有多少个。要做到这一点，可以为该功能编写一些乏味的代码。</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="171f" class="ml mm it nj b gy nn no l np nq">&gt;&gt;&gt; words = ['an', 'boy', 'girl', 'an', 'boy', 'dog', 'cat', 'Dog', 'CAT', 'an','GIRL', 'AN', 'dog', 'cat', 'cat', 'bag', 'BAG', 'BOY', 'boy', 'an']<br/>... unique_words = {x.lower() for x in set(words)}<br/>... for word in unique_words:<br/>...     print(f"* Count of {word}: {words.count(word)}")<br/>... <br/>* Count of cat: 3<br/>* Count of bag: 1<br/>* Count of boy: 3<br/>* Count of dog: 2<br/>* Count of an: 5<br/>* Count of girl: 1</span></pre><p id="dab8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如上所示，我们首先必须创建一个只包含唯一单词的集合。然后我们迭代单词集，并使用<code class="fe nr ns nt nj b">count()</code>方法找出每个单词的出现次数。然而，有一个更好的方法——使用<code class="fe nr ns nt nj b">Counter</code>类，它是为完成这个计数任务而设计的。</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="4751" class="ml mm it nj b gy nn no l np nq">&gt;&gt;&gt; from collections import Counter<br/>... <br/>... word_counter = Counter(x.lower() for x in words)<br/>... print("Word Counts:", word_counter)<br/>... <br/>Word Counts: Counter({'an': 5, 'boy': 4, 'cat': 4, 'dog': 3, 'girl': 2, 'bag': 2})</span></pre><p id="6518" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe nr ns nt nj b">collections</code>模块中提供了<em class="nu">计数器</em>类。为了使用该类，我们简单地创建了一个生成器:<code class="fe nr ns nt nj b">x.lower() for x in words</code>，并且每一项都会被计数。如你所见，<em class="nu">计数器</em>对象是一个类似 dict 的映射对象，每个键对应于单词列表的唯一项，而值是这些项的计数。很简洁，对吧？</p><p id="7d7c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">此外，如果您对找出单词列表中最频繁出现的条目感兴趣，我们可以利用<em class="nu"> Counter </em>对象的<code class="fe nr ns nt nj b">most_common()</code>方法。下面的代码向您展示了这种用法。你只需要指定一个整数(N)，它会从列表中找出最频繁出现的 N 个条目。顺便提一下，<code class="fe nr ns nt nj b">Counter</code>对象也可以处理其他序列数据，比如字符串和元组。</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="1572" class="ml mm it nj b gy nn no l np nq">&gt;&gt;&gt; # Find out the most common item<br/>... print("Most Frequent:", word_counter.most_common(1))<br/>Most Frequent: [('an', 5)]<br/>&gt;&gt;&gt; # Find out the most common 2 items<br/>... print("Most Frequent:", word_counter.most_common(2))<br/>Most Frequent: [('an', 5), ('boy', 4)]</span></pre></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="ab57" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated">9.不同订单要求的排序</h2><p id="b37c" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">在许多项目中，对列表中的项进行排序是一项普遍的任务。最基本的排序是基于数字或者字母顺序，我们可以使用内置的<code class="fe nr ns nt nj b">sorted()</code>函数。默认情况下，<code class="fe nr ns nt nj b">sorted()</code>函数将按升序对列表(实际上，它可以是任何可迭代的)进行排序。如果我们将<code class="fe nr ns nt nj b">reverse</code>参数指定为<code class="fe nr ns nt nj b">True</code>，我们可以得到降序排列的条目。下面显示了一些简单的用法。</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="6dc8" class="ml mm it nj b gy nn no l np nq">&gt;&gt;&gt; # A list of numbers and strings<br/>... numbers = [1, 3, 7, 2, 5, 4]<br/>... words = ['yay', 'bill', 'zen', 'del']<br/>... # Sort them<br/>... print(sorted(numbers))<br/>... print(sorted(words))<br/>... <br/>[1, 2, 3, 4, 5, 7]<br/>['bill', 'del', 'yay', 'zen']<br/>&gt;&gt;&gt; # Sort them in descending order<br/>... print(sorted(numbers, reverse=True))<br/>... print(sorted(words, reverse=True))<br/>... <br/>[7, 5, 4, 3, 2, 1]<br/>['zen', 'yay', 'del', 'bill']</span></pre><p id="709f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">除了这些基本用法，我们还可以指定<code class="fe nr ns nt nj b">key</code>参数，以便对复杂的项目进行排序，比如元组列表。考虑以下这种情况的例子。</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="f769" class="ml mm it nj b gy nn no l np nq">&gt;&gt;&gt; # Create a list of tuples<br/>... grades = [('John', 95), ('Aaron', 99), ('Zack', 97), ('Don', 92), ('Jennifer', 100), ('Abby', 94), ('Zoe', 99), ('Dee', 93)]<br/>&gt;&gt;&gt; # Sort by the grades, descending<br/>... sorted(grades, key=lambda x: x[1], reverse=True)<br/>[('Jennifer', 100), ('Aaron', 99), ('Zoe', 99), ('Zack', 97), ('John', 95), ('Abby', 94), ('Dee', 93), ('Don', 92)]<br/>&gt;&gt;&gt; # Sort by the name's initial letter, ascending<br/>... sorted(grades, key=lambda x: x[0][0])<br/>[('Aaron', 99), ('Abby', 94), ('Don', 92), ('Dee', 93), ('John', 95), ('Jennifer', 100), ('Zack', 97), ('Zoe', 99)]</span></pre><p id="4ade" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">上面的代码通过利用 lambda 函数向您展示了两个高级排序示例，该函数被传递给<code class="fe nr ns nt nj b">key</code>参数。第一个是使用降序对项目进行排序，而第二个是使用默认的升序。如果我们想把这两个要求结合起来呢？如果你考虑使用<code class="fe nr ns nt nj b">reverse</code>参数，你可能找错了对象，因为如果你试图按多个标准排序，相反的参数将适用于所有标准。那有什么诀窍呢？请参见下面的代码片段。</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="ec28" class="ml mm it nj b gy nn no l np nq">&gt;&gt;&gt; # Requirement: sort by name initial ascending, and by grades, descending<br/>... # Both won't work<br/>... sorted(grades, key=lambda x: (x[0][0], x[1]), reverse=True)<br/>[('Zoe', 99), ('Zack', 97), ('Jennifer', 100), ('John', 95), ('Dee', 93), ('Don', 92), ('Aaron', 99), ('Abby', 94)]<br/>&gt;&gt;&gt; sorted(grades, key=lambda x: (x[0][0], x[1]), reverse=False)<br/>[('Abby', 94), ('Aaron', 99), ('Don', 92), ('Dee', 93), ('John', 95), ('Jennifer', 100), ('Zack', 97), ('Zoe', 99)]<br/>&gt;&gt;&gt; # This will do the trick<br/>... sorted(grades, key=lambda x: (x[0][0], -x[1]))<br/>[('Aaron', 99), ('Abby', 94), ('Dee', 93), ('Don', 92), ('Jennifer', 100), ('John', 95), ('Zoe', 99), ('Zack', 97)]</span></pre><p id="939d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如您所见，通过将<code class="fe nr ns nt nj b">reverse</code>参数设置为<code class="fe nr ns nt nj b">True</code>或<code class="fe nr ns nt nj b">False</code>，两者都不起作用。相反，诀窍是否定等级，因此当您按默认升序排序时，分数将因为这些值的否定而反向排序。但是，对于这种方法有一个警告，因为求反只能处理数值，而不能处理字符串。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="eff0" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated">10.不要忘记 defaultdict</h2><p id="7a8e" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">字典是一种有效的数据类型，它允许我们以键值对的形式存储数据。要求所有的键都是可散列的，这样在幕后，存储这些数据可能涉及到使用散列表。这种实现允许数据检索和插入的 O(1)效率。然而，应该注意的是，除了内置的<em class="nu"> dict </em>类型之外，我们还可以使用其他的字典。其中，我想讨论一下<em class="nu"> defaultdict </em>类型。与内置的<em class="nu"> dict </em>类型不同，<em class="nu"> defaultdict </em>允许我们设置一个默认的工厂函数，当键不存在时创建一个元素。您可能对以下错误并不陌生。</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="1c77" class="ml mm it nj b gy nn no l np nq">&gt;&gt;&gt; student = {'name': "John", 'age': 18}<br/>... student['gender']<br/>... <br/>Traceback (most recent call last):<br/>  File "&lt;input&gt;", line 2, in &lt;module&gt;<br/>KeyError: 'gender'</span></pre><p id="be26" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">假设我们在处理单词，我们想将相同的字符组成一个列表，这些列表与作为键的字符相关联。这里有一个使用内置<em class="nu">字典</em>类型的简单实现。值得注意的是，检查 dict 对象是否有<code class="fe nr ns nt nj b">letter</code>键至关重要，因为如果键不存在，调用<code class="fe nr ns nt nj b">append()</code>方法会引发<code class="fe nr ns nt nj b">KeyError</code>异常。</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="a750" class="ml mm it nj b gy nn no l np nq">&gt;&gt;&gt; letters = ["a", "a", "c", "d", "d", "c", "a", "b"]<br/>... final_dict = {}<br/>... for letter in letters:<br/>...     if letter not in final_dict:<br/>...         final_dict[letter] = []<br/>...     final_dict[letter].append(letter)<br/>... <br/>... print("Final Dict:", final_dict)<br/>... <br/>Final Dict: {'a': ['a', 'a', 'a'], 'c': ['c', 'c'], 'd': ['d', 'd'], 'b': ['b']}</span></pre><p id="b1bc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们看看如何使用<em class="nu"> defaultdict </em>来编写更简洁的代码。虽然这个例子很简单，但它只是给了你一些关于<em class="nu"> defaultdict </em>类的想法，这样我们就不用处理字典对象中不存在的键了。</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="5e43" class="ml mm it nj b gy nn no l np nq">&gt;&gt;&gt; from collections import defaultdict<br/>... <br/>... final_defaultdict = defaultdict(list)<br/>... for letter in letters:<br/>...     final_defaultdict[letter].append(letter)<br/>... <br/>... print("Final Default Dict:", final_defaultdict)<br/>... <br/>Final Default Dict: defaultdict(&lt;class 'list'&gt;, {'a': ['a', 'a', 'a'], 'c': ['c', 'c'], 'd': ['d', 'd'], 'b': ['b']})</span></pre></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="9d69" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated">结论</h2><p id="6fe0" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">在阅读本文之前，您可能已经知道了其中的一些技巧，但是我希望您仍然能够很好地掌握这些技巧。在您的项目中实践这些习惯用法将使您的 Python 代码更具可读性和性能。</p><p id="af3c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这件作品到此为止。感谢阅读。</p></div></div>    
</body>
</html>