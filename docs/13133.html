<html>
<head>
<title>Deploy a Dockerized Streamlit App to GCP with Compute Engine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用计算引擎将 Dockerized Streamlit 应用程序部署到 GCP</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/deploy-a-dockerized-streamlit-app-to-gcp-with-compute-engine-9b82fd2cdd28?source=collection_archive---------23-----------------------#2020-09-09">https://towardsdatascience.com/deploy-a-dockerized-streamlit-app-to-gcp-with-compute-engine-9b82fd2cdd28?source=collection_archive---------23-----------------------#2020-09-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b0eb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用 Docker 和 Google 云平台将简单的 streamlit 应用程序部署到云的指南(GCP)</h2></div><p id="c26b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作者:<a class="ae le" href="https://www.linkedin.com/in/edkrueger/" rel="noopener ugc nofollow" target="_blank">爱德华·克鲁格</a>和<a class="ae le" href="https://www.linkedin.com/in/douglas-franklin-1a3a2aa3/" rel="noopener ugc nofollow" target="_blank">道格拉斯·富兰克林</a>。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/c33d32c683fcc2761a037e9d78e1a746.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1Af1Ysp1wn_U5SOkd4XGZg.jpeg"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">照片由 Boudewijn 在 Unsplash 上直播</p></figure><p id="9c50" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用 Streamlit 框架构建原型很简单，至少可以在您自己的计算机上运行。与更广泛的受众分享更加复杂。</p><p id="b2e2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Streamlit 使我们能够以最少的努力和零成本创建干净的应用程序。我们在这里使用的应用程序非常简单，因为本文将重点关注部署。我们将按照本文中列出的步骤，将 Streamlit 应用程序部署到 Google 云平台计算实例中。</p><p id="1e56" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里有一个链接，链接到包含我们项目代码的<a class="ae le" href="https://github.com/edkrueger/streamlit-template" rel="noopener ugc nofollow" target="_blank"> GitHub 库</a>。注意，我们使用 Pipenv 来管理我们的依赖关系。</p><div class="lv lw gp gr lx ly"><a href="https://github.com/edkrueger/streamlit-template" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">edkrueger/streamlit-模板</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">切换到后端目录。运行 pipenv install — dev 来安装 env。运行 pipenv shell。运行预提交安装到…</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">github.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm lp ly"/></div></div></a></div><h1 id="bf81" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">什么是 Streamlit？</h1><p id="8d28" class="pw-post-body-paragraph ki kj it kk b kl nf ju kn ko ng jx kq kr nh kt ku kv ni kx ky kz nj lb lc ld im bi translated">Streamlit 是一个免费的开源应用框架<strong class="kk iu"> </strong>，为数据科学家和机器学习工程师快速创建伟大的 Python 应用提供了一种<strong class="kk iu"> </strong>简单的方法。Streamlit 固执己见的本性使构建前端变得容易。最后，Streamlit 可以让数据应用的实验和生产以及机器学习分析更容易进行和迭代。</p><p id="724d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">查看他们在 GitHub 上的工作。</p><div class="lv lw gp gr lx ly"><a href="https://github.com/streamlit/streamlit" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">简化/简化</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">streamlit-用 Python 构建数据应用程序的最快方法-streamlit/streamlit</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">github.com</p></div></div><div class="mh l"><div class="nk l mj mk ml mh mm lp ly"/></div></div></a></div><h1 id="ccb6" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">Docker 和我们的 docker 文件</h1><p id="296f" class="pw-post-body-paragraph ki kj it kk b kl nf ju kn ko ng jx kq kr nh kt ku kv ni kx ky kz nj lb lc ld im bi translated">Docker 是将应用程序投入生产的最佳方式。Docker 使用 docker 文件来构建容器。构建的容器存储在 Google Container Registry 中，可以在这里进行部署。Docker 容器可以在本地构建，并将在任何运行 Docker <strong class="kk iu">的系统上运行。</strong></p><p id="8edf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是我们在这个项目中使用的 docker 文件:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="nl nm l"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">Dockerfile 文件</p></figure><p id="ab71" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Dockerfile 的第一行以<code class="fe nn no np nq b">FROM.</code>开始，这是我们导入操作系统或编程语言的地方。</p><p id="4edd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来的两行涉及设置环境并在服务器上执行它。<code class="fe nn no np nq b">COPY</code>行使本地文件<code class="fe nn no np nq b">requirements.txt</code>在 docker 容器中可用。<code class="fe nn no np nq b">RUN</code>命令可以跟随着您想要执行的任何 bash 代码。我们使用<code class="fe nn no np nq b">RUN</code>来安装我们的依赖项。然后<code class="fe nn no np nq b">ENV,</code>将我们的环境变量<code class="fe nn no np nq b">ENV </code>设置为<code class="fe nn no np nq b">APP_HOME / app</code>。这模仿了我们的项目目录的结构，让 Docker 知道我们的应用程序在哪里。</p><p id="a138" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些行是 Python 云平台结构的一部分，你可以在谷歌的云<a class="ae le" href="https://cloud.google.com/run/docs/quickstarts/build-and-deploy#python" rel="noopener ugc nofollow" target="_blank"> <em class="nr">文档</em> </a>中读到更多关于它们的内容。</p><p id="73e7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nn no np nq b">WORKDIR</code>行将我们的工作目录设置为<code class="fe nn no np nq b">$APP_HOME</code>。然后，<code class="fe nn no np nq b">COPY </code>行将剩余的本地文件放在 docker 容器中。</p><p id="6930" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">docker 文件中的最后一行在<code class="fe nn no np nq b">$PORT.</code>运行我们的应用程序</p><h1 id="50c1" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">用 Docker 构建和运行</h1><p id="e3ca" class="pw-post-body-paragraph ki kj it kk b kl nf ju kn ko ng jx kq kr nh kt ku kv ni kx ky kz nj lb lc ld im bi translated">这里我们将解释如何用 Docker 构建我们的容器。请注意，我们的 Dockerfile 位于<code class="fe nn no np nq b">backend</code>目录中。</p><ul class=""><li id="998c" class="ns nt it kk b kl km ko kp kr nu kv nv kz nw ld nx ny nz oa bi translated">进入<code class="fe nn no np nq b">backend</code>目录。</li><li id="13f6" class="ns nt it kk b kl ob ko oc kr od kv oe kz of ld nx ny nz oa bi translated">使用<code class="fe nn no np nq b">docker build . -t streamlit-app</code>构建</li></ul><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi og"><img src="../Images/6fecee1b246187470c8b19017788aadd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cdBMQS9fxZlxWXw9hUztpw.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">成功构建</p></figure><p id="8390" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nn no np nq b">docker build</code>命令将 docker 文件的每一行视为一个“步骤”,并提供一个终端输出，指示每个步骤何时运行，如上所示。</p><p id="4beb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">既然我们的容器是在我们的虚拟机上构建的，我们就可以运行我们的 Streamlit 应用程序了。</p><ul class=""><li id="3057" class="ns nt it kk b kl km ko kp kr nu kv nv kz nw ld nx ny nz oa bi translated">使用<code class="fe nn no np nq b">docker run -p 80:8080 -e PORT=8080 streamlit-app</code>运行</li></ul><p id="450c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意:这将在容器内部的端口 8080 和容器外部的端口 80 上运行应用程序。为了在容器外部引用它，URL 是<code class="fe nn no np nq b"><a class="ae le" href="http://localhost/" rel="noopener ugc nofollow" target="_blank">http://localhost/</a></code></p><p id="0811" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可能会收到如下所示的错误。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi oh"><img src="../Images/4197ace5bccf8888a0f16fac0a3c4fc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cFzi4LjxEBYqf0TWXwgMrQ.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">虚拟机告诉我们端口 80 已经被使用</p></figure><p id="f470" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果是这种情况，将内部端口<code class="fe nn no np nq b">80</code>更改为另一个数字，例如<code class="fe nn no np nq b">85</code>，并运行<code class="fe nn no np nq b">docker run -p 85:8080 -e PORT=8080 streamlit-app</code>。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi oi"><img src="../Images/ebc15f522829af6766719a575cb166b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OEJpc-_JV3s27NNxUpjE1w.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">应用程序正在运行</p></figure><h1 id="cb71" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">部署到 GCP 计算引擎</h1><p id="43b6" class="pw-post-body-paragraph ki kj it kk b kl nf ju kn ko ng jx kq kr nh kt ku kv ni kx ky kz nj lb lc ld im bi translated">如果您在本地开发，您将需要安装云软件开发工具包 CLI 工具。</p><div class="lv lw gp gr lx ly"><a href="https://cloud.google.com/sdk/?utm_source=google&amp;utm_medium=cpc&amp;utm_campaign=na-US-all-en-dr-bkws-all-all-trial-e-dr-1009135&amp;utm_content=text-ad-lpsitelinkCCexp2-any-DEV_c-CRE_79747435927-ADGP_Hybrid+%7C+AW+SEM+%7C+BKWS+%7C+US+%7C+en+%7C+EXA+~+Google+Cloud+SDK-KWID_43700007037826431-kwd-76317487932&amp;utm_term=KW_google%20cloud%20sdk-ST_google+cloud+sdk&amp;gclid=Cj0KCQjw-uH6BRDQARIsAI3I-Uc-oIyaUf1X-nC0P0hd1VOZzMtHMXnZM-qZwD3L6y5lrLdlYtqKaEAaAg-mEALw_wcB" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">云 SDK 命令行工具|云 SDK:命令行界面</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">发送反馈 Google Cloud Next '20: OnAir |从 7 月 14 日起每周二按需探索精选内容…</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">cloud.google.com</p></div></div><div class="mh l"><div class="oj l mj mk ml mh mm lp ly"/></div></div></a></div><p id="a7f2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你在云机器上开发，很可能已经配置了这些工具。打开终端，输入以下命令。</p><ul class=""><li id="8598" class="ns nt it kk b kl km ko kp kr nu kv nv kz nw ld nx ny nz oa bi translated">运行<code class="fe nn no np nq b">gcloud init</code>选择您的账户和项目</li></ul><p id="fc71" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将多次提示您响应终端中的提示，以选择项目和虚拟机(VM)。</p><ul class=""><li id="21dc" class="ns nt it kk b kl km ko kp kr nu kv nv kz nw ld nx ny nz oa bi translated">运行<code class="fe nn no np nq b">export PROJECT=$(gcloud config get-value project)</code>获取并保存您的项目 id。</li><li id="70c8" class="ns nt it kk b kl ob ko oc kr od kv oe kz of ld nx ny nz oa bi translated">跑<code class="fe nn no np nq b">export GCR_TAG=gcr.io/$PROJECT/my-app</code>去拿 GCR 的标签。</li></ul><p id="0f2a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这允许我们将<code class="fe nn no np nq b">GCR_TAG</code>作为环境变量引用，以便以后重用。</p><ul class=""><li id="45be" class="ns nt it kk b kl km ko kp kr nu kv nv kz nw ld nx ny nz oa bi translated">运行<code class="fe nn no np nq b">gcloud builds submit --tag $GCR_TAG</code>将构建提交给 GCP 云构建。</li></ul><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi ok"><img src="../Images/41d582401a3eff8b8c5dd84dc37ff97f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h-HOoj-CsIy73EGbDbwf4w.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">建立成功</p></figure><p id="eeb5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将在云构建中的另一台机器上构建我们的容器。一旦这个构建完成，我们的容器就可以在 Google 容器注册中心(GCR) <strong class="kk iu"> </strong>中使用我们指定的标签了。</p><ul class=""><li id="fa6c" class="ns nt it kk b kl km ko kp kr nu kv nv kz nw ld nx ny nz oa bi translated">运行<code class="fe nn no np nq b">echo $GCR_TAG</code>查看 GCR 标签。</li></ul><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi ol"><img src="../Images/6b7b3e10885c33c657b789190d9d566f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bRp0QxCAlJCPLPWNtWPbsA.png"/></div></div></figure><p id="8096" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，为了将我们的 dockerized 应用程序部署到虚拟机，我们遵循以下步骤。</p><ul class=""><li id="3fc3" class="ns nt it kk b kl km ko kp kr nu kv nv kz nw ld nx ny nz oa bi translated">转到 GCP 用户界面中的“计算引擎”并选择“创建实例”</li></ul><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi om"><img src="../Images/d79e8f20375b691d415cf7da104f1844.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qfVznwlHn8Z8oNcJ03fKPA.png"/></div></div></figure><ul class=""><li id="b60e" class="ns nt it kk b kl km ko kp kr nu kv nv kz nw ld nx ny nz oa bi translated">在选项中，选中复选框“将容器映像部署到此虚拟机实例”</li><li id="cf04" class="ns nt it kk b kl ob ko oc kr od kv oe kz of ld nx ny nz oa bi translated">在“容器图像”字段中粘贴 GCR 标签。</li></ul><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi on"><img src="../Images/81e8aaf1d08f081ab1f8e0dc0d435bd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/format:webp/1*v3Nqjxg6FO_KLS1jMt8GCw.png"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">在 GCP 上创建实例</p></figure><p id="ac12" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">若要公开部署，请选择“允许 HTTP 流量”</p><ul class=""><li id="5139" class="ns nt it kk b kl km ko kp kr nu kv nv kz nw ld nx ny nz oa bi translated">点击“创建”</li><li id="59d8" class="ns nt it kk b kl ob ko oc kr od kv oe kz of ld nx ny nz oa bi translated">运行<code class="fe nn no np nq b">export GCR_TAG=&lt;GCR TAG&gt;</code>。</li></ul><p id="171c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">确保用您的标签替换<code class="fe nn no np nq b">GCR_TAG</code>。</p><ul class=""><li id="2005" class="ns nt it kk b kl km ko kp kr nu kv nv kz nw ld nx ny nz oa bi translated">运行<code class="fe nn no np nq b">docker run -p 80:8080 -e PORT=8080 $GCR_TAG</code>。</li></ul><p id="9128" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您不应该在新虚拟机上遇到任何端口错误。如果确实如此，请务必终止该进程，这样就可以将<code class="fe nn no np nq b">80</code>保持为默认端口。否则，您的本地主机地址将是您指定的内部端口。</p><p id="de37" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果成功，您将看到两个 URL 填充了您的终端。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi oo"><img src="../Images/e8127c21db2685349aaab1db48308805.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mJN_RxzgnnXG69_bvTBOiA.png"/></div></div></figure><p id="be80" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，使用 GUI 并单击“连接”下的下拉菜单，然后选择“在浏览器窗口中打开”</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi op"><img src="../Images/c4ea5b47e5b6e974904b6292e3a83dc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:716/format:webp/1*61Y7kiZk3tjL41yCJJYF_Q.png"/></div></div></figure><p id="fea7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将打开一个新的终端如下所示。我们再次需要我们的<code class="fe nn no np nq b">GCR_TAG</code>，并且可以用命令<code class="fe nn no np nq b">docker image ls</code>检索它。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi oq"><img src="../Images/3af1813fe9754bee3b76d4d48bbefce2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HyJB0UTKTl7M7-fxJEdpIw.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">我们的 docker 图像</p></figure><p id="1b7d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦我们有了<code class="fe nn no np nq b">GCR_TAG</code>，我们使用<code class="fe nn no np nq b">export</code>保存它，然后用行<code class="fe nn no np nq b">docker run -p 80:8080 -e PORT=8080 $GCR_TAG</code>重新运行我们的应用程序。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi or"><img src="../Images/80e4a3e0b33fc4b8c0a3f9c6eeac2a42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*TGW-GpRveUr9iqcrbw7WLg.png"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">使用 Docker 运行我们的应用程序</p></figure><p id="439f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，我们无法在终端显示的 URL 中找到我们的应用程序。要查看我们的应用程序的运行情况，我们将使用 GUI 并找到那里显示的 URL。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi os"><img src="../Images/5e439f1063ad9a5edf2e8bec3ab42642.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WywiJJKUj4l85umwfHvJUQ.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">运行应用程序的外部 URL</p></figure><p id="ae1e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你访问网址，你会看到你的应用程序！请注意，这是公开的。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/d85685d2c9dc2820cc82762a203ecd0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:492/format:webp/1*klgcOng0FwZI-XQiv7mWXQ.png"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">复杂性</p></figure><p id="6eed" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，这是“不安全”的，意味着没有 HTTPS 握手发生。如果网站不安全，用户在页面上输入的任何信息(如姓名、地址、信用卡详细信息)都不会受到保护，很容易被窃取。然而，在安全的网站上，代码是加密的，因此任何敏感信息都很难被发现。</p><p id="5fe4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当您使用完实例时，一定要关闭它们，因为它们只向您收取运行时间的费用。</p><h2 id="03da" class="ou mo it bd mp ov ow dn mt ox oy dp mx kr oz pa mz kv pb pc nb kz pd pe nd pf bi translated">结论</h2><p id="025f" class="pw-post-body-paragraph ki kj it kk b kl nf ju kn ko ng jx kq kr nh kt ku kv ni kx ky kz nj lb lc ld im bi translated">现在我们知道了如何将一个 streamlit 应用程序 Dockerize 并将其部署到 GCP。Streamlit 非常适合快速 POC 模型和内部仪表盘，现在我们有办法在云中测试我们的 Streamlit 应用程序！</p><p id="7211" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您的阅读！你能部署一个 Streamlit 应用程序吗？</p></div></div>    
</body>
</html>