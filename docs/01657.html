<html>
<head>
<title>What is the difference between a having clause and a where clause in SQL?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SQL中的having子句和where子句有什么区别？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/what-is-the-difference-between-a-having-clause-and-a-where-clause-in-sql-ed74e0a8ad6d?source=collection_archive---------2-----------------------#2020-02-15">https://towardsdatascience.com/what-is-the-difference-between-a-having-clause-and-a-where-clause-in-sql-ed74e0a8ad6d?source=collection_archive---------2-----------------------#2020-02-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="803c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一个常见的面试问题解释</h2></div><p id="c9ee" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在SQL <strong class="kk iu">中，其中</strong>子句和<strong class="kk iu"> having </strong>子句用于过滤数据。<strong class="kk iu">这里的</strong>子句相当简单，但是<strong class="kk iu">有</strong>子句就有点复杂了。<strong class="kk iu"> Where </strong>子句按表中的形式过滤数据。相比之下，具有子句的<strong class="kk iu">在<strong class="kk iu">分组</strong>和<strong class="kk iu">聚合</strong>之后过滤数据。另一种说法是，<strong class="kk iu"> where </strong>作用于单个记录，而<strong class="kk iu">have</strong>作用于<strong class="kk iu">分组</strong>记录。</strong></p><p id="21df" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个故事中，我将描述<strong class="kk iu"> where </strong>子句和<strong class="kk iu"> having </strong>子句。然后，我将使用《吸血鬼猎人巴菲》中的角色，通过一个使用了where子句的示例和一个having子句的示例。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/f4c05b05836a776a9ffd3270c1d0c4a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/0*1ppjJOKB6UpiaS50.png"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated"><a class="ae lu" href="https://imgs.xkcd.com/comics/query_2x.png" rel="noopener ugc nofollow" target="_blank">https://imgs.xkcd.com/comics/query_2x.png</a></p></figure><h1 id="4117" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">场景</h1><h2 id="a06c" class="mn lw it bd lx mo mp dn mb mq mr dp mf kr ms mt mh kv mu mv mj kz mw mx ml my bi translated">*剧透警报*</h2><p id="b8e6" class="pw-post-body-paragraph ki kj it kk b kl mz ju kn ko na jx kq kr nb kt ku kv nc kx ky kz nd lb lc ld im bi translated">这个场景提到了《吸血鬼猎人巴菲》中的故事情节，所以如果你还没有看过，也不想知道会发生什么…停止在这里阅读。然而，鉴于它开始于1997年，结束于2003年，我认为我们可能是相当安全的😜</p><p id="61e5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">巴菲和她的朋友住在地狱口的阳光谷。巴菲是吸血鬼猎人，但其他角色也有助于猎杀吸血鬼和恶魔。</p><p id="0309" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设我们有一个包含在地狱之口收集的数据的表。这张表叫做<strong class="kk iu">吸血鬼_被杀</strong>，显示了生活在阳光谷的所有角色杀死的吸血鬼数量。它也给每个人一个他们所属的类别标签，包括杀戮者，吸血鬼，平民和守望者。</p><p id="59c1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在整个系列中，巴菲死了两次。第一季有一次主人淹死了她。她复活了，之后继续杀吸血鬼。她第二次死是在第五季的最后一集，她从一座塔上跳下，进入一个传送门，代替她的姐姐道恩死去。在第六季开始时，她的朋友们用巫术把她从死亡中带了回来，她也回去猎杀吸血鬼。</p><p id="0329" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于她死了两次，巴菲实际上在<strong class="kk iu">吸血鬼_被杀</strong>表中有三个条目。</p><p id="3ac8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些数字不是真实的。我编造了这些故事来猜测每个角色一生中会杀死多少吸血鬼。没错，我现在正在狂看《魔法奇兵》的整个7季，但我不会坐在那里统计所有死去的吸血鬼。</p><p id="4984" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你想知道每个角色在屏幕上被杀死的实际次数，你可以在这里找到。我没有在我的例子中使用这些数字，因为这些数字偏向于那些有更多屏幕时间的主要角色。</p><h1 id="527b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">问题是</h1><p id="ecb9" class="pw-post-body-paragraph ki kj it kk b kl mz ju kn ko na jx kq kr nb kt ku kv nc kx ky kz nd lb lc ld im bi translated">费思和巴菲在吵架。他们一直有竞争，但这场争论是关于谁杀了最多的吸血鬼。费思认为只有她杀了1000多个吸血鬼，而巴菲还没有达到这个数字。巴菲不同意，并认为她已经杀死了1000多个吸血鬼。</p><p id="41a8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了解决他们的争吵，贾尔斯使用了<strong class="kk iu">吸血鬼_被杀</strong>的记录。</p><pre class="lf lg lh li gt ne nf ng nh aw ni bi"><span id="95f2" class="mn lw it nf b gy nj nk l nl nm">CREATE TABLE vampires_slain (<br/>    name varchar(255),<br/>    hellmouth_category varchar(255),<br/>    slay_count int<br/>);<br/>INSERT INTO vampires_slain (name, hellmouth_category, slay_count)<br/>VALUES<br/>    ('Buffy', 'slayer', 104),<br/>    ('Willow', 'civilian', 65),<br/>    ('Xander', 'civilian', 89),<br/>    ('Buffy', 'slayer', 886),<br/>    ('Angel', 'vampire', 1397),<br/>    ('Giles', 'watcher', 673),<br/>    ('Kendra', 'slayer', 1260),<br/>    ('Spike', 'vampire', 1108),<br/>    ('Faith', 'slayer', 1421),<br/>    ('Buffy', 'slayer', 957)<br/>;</span></pre><blockquote class="nn"><p id="2ce7" class="no np it bd nq nr ns nt nu nv nw ld dk translated">吸血鬼_被杀</p></blockquote><figure class="ny nz oa ob oc lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi nx"><img src="../Images/a4f0f3bb05bd6b1531e43af2f46ed404.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rlXFxn9ZAPwlMFhi11g-zg.png"/></div></div></figure><h2 id="83d0" class="mn lw it bd lx mo mp dn mb mq mr dp mf kr ms mt mh kv mu mv mj kz mw mx ml my bi translated">环境</h2><p id="8083" class="pw-post-body-paragraph ki kj it kk b kl mz ju kn ko na jx kq kr nb kt ku kv nc kx ky kz nd lb lc ld im bi translated">为了运行这个例子中的代码，我在<a class="ae lu" href="http://sqlfiddle.com/" rel="noopener ugc nofollow" target="_blank"> SQL Fiddle </a>中使用了MySQL 5.6。如果您想尝试运行代码，请随意使用它。</p><h1 id="9135" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">解决方案</h1><p id="8380" class="pw-post-body-paragraph ki kj it kk b kl mz ju kn ko na jx kq kr nb kt ku kv nc kx ky kz nd lb lc ld im bi translated">为了解决巴菲和菲斯之间的争论，贾尔斯想要过滤掉<strong class="kk iu">吸血鬼_被杀的表格。</strong>他想只显示那些<strong class="kk iu"> slay_count </strong>大于1000的个体。他试图使用一个<strong class="kk iu"> where </strong>子句来实现。</p><h2 id="e40e" class="mn lw it bd lx mo mp dn mb mq mr dp mf kr ms mt mh kv mu mv mj kz mw mx ml my bi translated">Where子句</h2><p id="6334" class="pw-post-body-paragraph ki kj it kk b kl mz ju kn ko na jx kq kr nb kt ku kv nc kx ky kz nd lb lc ld im bi translated"><strong class="kk iu">其中</strong>在SQL中是一个简单的过滤器。如果满足查询的<strong class="kk iu"> where </strong>条件，则在结果中返回该行数据。就这么简单。</p><p id="e870" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在查询中，<strong class="kk iu"> where </strong>子句最常用在<strong class="kk iu"> from </strong>之后。您可以在<strong class="kk iu"> where </strong>子句中使用许多不同的运算符，包括<strong class="kk iu"> =、&gt;、&lt;、&gt; =、&lt; =、！=，之间，像</strong>中的和<strong class="kk iu">。注意，在MySQL中要么<strong class="kk iu">！= </strong>或<strong class="kk iu"> &lt; &gt; </strong>可以用来表示‘不等于’。</strong></p><pre class="lf lg lh li gt ne nf ng nh aw ni bi"><span id="7c96" class="mn lw it nf b gy nj nk l nl nm">select *<br/>from<br/>vampires_slain<br/>where<br/>slay_count &gt; 1000<br/>order by <br/>slay_count desc;</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi nx"><img src="../Images/02283e8d21a238b75a41b7797285e48f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OzWE6kGuzCmnXBwRtsjVkA.png"/></div></div></figure><p id="d866" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">费思很惊讶，她不是唯一一个杀死了1000多个吸血鬼的人。安吉尔、肯德拉和斯派克也在slay_count 大于1000的名单<strong class="kk iu">中。</strong></p><p id="2604" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">巴菲惊讶地发现她不在名单上。就连年纪轻轻就被杀的肯德拉也有1000以上的<strong class="kk iu"> slay_count </strong>。</p><p id="f3a1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当巴菲买下肯德拉时，贾尔斯意识到当巴菲死了，肯德拉被召唤成为一名杀手时，巴菲的记录可能会一分为二。然后他想起她为了救Dawn第二次死了，并得出结论，Buffy在表中有3个条目。</p><p id="5432" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了合并这三个记录，Giles决定使用一个具有子句的<strong class="kk iu">。这样他就能看到巴菲三个条目的<strong class="kk iu">和</strong>是否大于1000，以及她杀死的吸血鬼数量是否大于费思。</strong></p><h2 id="2135" class="mn lw it bd lx mo mp dn mb mq mr dp mf kr ms mt mh kv mu mv mj kz mw mx ml my bi translated">Having子句</h2><p id="4470" class="pw-post-body-paragraph ki kj it kk b kl mz ju kn ko na jx kq kr nb kt ku kv nc kx ky kz nd lb lc ld im bi translated"><strong class="kk iu"> where </strong>关键字不能与聚合函数一起使用。这就是有了的<strong class="kk iu">的用武之地。<strong class="kk iu"> Having </strong>只能通过</strong>子句与<strong class="kk iu">组结合使用。SQL中一些最常见的聚合函数有<strong class="kk iu"> min </strong>，<strong class="kk iu"> max </strong>，<strong class="kk iu"> ave </strong>，<strong class="kk iu"> count </strong>和<strong class="kk iu"> sum </strong>。</strong></p><p id="f972" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当在查询中使用具有的<strong class="kk iu">时，只返回满足具有</strong>条件的<strong class="kk iu">的<strong class="kk iu">组</strong>。</strong></p><p id="d4a5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">贾尔斯用一个<strong class="kk iu"> having </strong>子句解决了巴菲两次进入<strong class="kk iu">吸血鬼_被杀</strong>表的问题。他按名称对条目进行分组，这样Buffy的两个条目将合并为一个。她名下的两个条目将使用<strong class="kk iu"> having </strong>子句中的<strong class="kk iu"> sum </strong>聚合函数进行<strong class="kk iu">求和</strong>。</p><p id="eb9e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，他可以再次使用<strong class="kk iu"> &gt; </strong>符号来过滤数据集，以仅包含总和<strong class="kk iu"> slay_count </strong>大于1000的分组条目。</p><pre class="lf lg lh li gt ne nf ng nh aw ni bi"><span id="9227" class="mn lw it nf b gy nj nk l nl nm">select name, hellmouth_category, sum(slay_count)<br/>from<br/>vampires_slain<br/>group by <br/>name<br/>having<br/>sum(slay_count)&gt;1000<br/>order by sum(slay_count) desc;</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi od"><img src="../Images/72828893f883712d9c9ae60fd72fcba5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QYYxl5zSjw8jPim5rzMn2A.png"/></div></div></figure><p id="afc4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，一旦Giles使用了<strong class="kk iu"> having </strong>子句，就会对每个个体的<strong class="kk iu"> slay_counts </strong>进行求和，然后过滤生成一个表，该表只包含<strong class="kk iu"> sum(slay_count) </strong>大于1000的个体。结果表像以前一样包含了费思、安吉尔、肯德拉和斯派克，但它也包含了具有1947年<strong class="kk iu"> sum(slay_count) </strong>的巴菲。</p><p id="1421" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，贾尔斯解决了争论。巴菲和费思的总死亡数都超过了1000。信仰是错误的。巴菲不仅杀死了1000多只吸血鬼，而且她在1947年杀死的吸血鬼总数比费思的1421只还多。</p><h1 id="361f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">我如何使用where和having子句</h1><p id="8e37" class="pw-post-body-paragraph ki kj it kk b kl mz ju kn ko na jx kq kr nb kt ku kv nc kx ky kz nd lb lc ld im bi translated">我不得不承认，在我的日常数据库查询中，我倾向于不太使用having子句。相反，我通常会创建中间表，其中的项目被<strong class="kk iu">分组</strong>。然后，如果需要的话，我会使用一个<strong class="kk iu"> where </strong>子句来过滤中间表。我想我经常<strong class="kk iu">分组</strong>字段或者<strong class="kk iu">过滤</strong>它们，但很少同时两者。</p><p id="796d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我之所以会创建中间表而不是使用带有子句的<strong class="kk iu">来创建中间表，主要是因为我所处理的数据都在非常大的表中。当使用具有</strong>子句的<strong class="kk iu">时，会在内存中创建一个临时表。这意味着，对于大型数据集，使用具有</strong>子句的<strong class="kk iu">的查询会花费很长时间。</strong></p><p id="d2f8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，<strong class="kk iu"> having </strong>从句在科技面试中经常被用作问题。这是因为它们是需要正确使用的比较棘手的SQL子句之一。因此，即使你很少在实践中使用它们，了解它们的工作原理并对它们感到舒适也是值得的。</p><p id="3e63" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我希望这个例子有助于澄清SQL中的<strong class="kk iu"> where </strong>和<strong class="kk iu"> having </strong>之间的区别。</p><p id="50a5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">除了数据，我的另一个爱好是绘画。你可以在www.katemarielewis.com<a class="ae lu" href="http://www.katemarielewis.com" rel="noopener ugc nofollow" target="_blank">找到我的野生动物艺术</a></p><h1 id="df2d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">我写过的关于SQL的其他文章:</h1><div class="oe of gp gr og oh"><a rel="noopener follow" target="_blank" href="/what-is-the-difference-between-an-inner-and-an-outer-join-in-sql-5b5ec8277377"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd iu gy z fp om fr fs on fu fw is bi translated">SQL中的内部连接和外部连接有什么区别？</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">SQL中的内部连接、完全外部连接、左外部连接和右外部连接使用来自以下领域的示例进行解释…</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">towardsdatascience.com</p></div></div><div class="oq l"><div class="or l os ot ou oq ov lo oh"/></div></div></a></div><h1 id="0a0d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">我写的关于数据科学的文章:</h1><div class="oe of gp gr og oh"><a rel="noopener follow" target="_blank" href="/how-i-went-from-zero-coding-skills-to-data-scientist-in-6-months-c2207b65f2f3"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd iu gy z fp om fr fs on fu fw is bi translated">我如何在6个月内从零编码技能成为数据科学家</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">我用来自学数据科学的4个工具没有花一美元</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">towardsdatascience.com</p></div></div><div class="oq l"><div class="ow l os ot ou oq ov lo oh"/></div></div></a></div></div></div>    
</body>
</html>