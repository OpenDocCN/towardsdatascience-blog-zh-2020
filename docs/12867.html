<html>
<head>
<title>Beginner’s guide to building Convolutional Neural Networks using TensorFlow’s Keras API in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 TensorFlow 的 Keras API 在 Python 中构建卷积神经网络的初学者指南</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/beginners-guide-to-building-convolutional-neural-networks-using-tensorflow-s-keras-api-in-python-6e8035e28238?source=collection_archive---------12-----------------------#2020-09-04">https://towardsdatascience.com/beginners-guide-to-building-convolutional-neural-networks-using-tensorflow-s-keras-api-in-python-6e8035e28238?source=collection_archive---------12-----------------------#2020-09-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="41a5" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">初学者的深度学习</h2><div class=""/><div class=""><h2 id="fbad" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">解释具有 MaxPool2D、Conv2D 和 Dense 图层的端到端二值图像分类模型。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/1501a24b408d3bd1ed5e2a71fd1c4626.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*KVU0lI14wJhXFPPO.jpg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">来自<a class="ae lh" href="https://pixabay.com/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=3537401" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae lh" href="https://pixabay.com/users/thedigitalartist-202249/" rel="noopener ugc nofollow" target="_blank">皮特·林弗斯</a>的图片</p></figure><p id="c3d3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">欢迎来到神经网络系列的第 2 部分！在第 1 部分的<a class="ae lh" rel="noopener" target="_blank" href="/beginners-guide-to-building-artificial-neural-networks-using-keras-in-python-bdc4989dab00">中，我们使用 Keras API 研究了一个人工神经网络(ann)。我们讨论了顺序网络架构、激活函数、隐藏层、神经元等。最后用一个端到端的例子来预测贷款申请是被批准还是被拒绝。</a></p><p id="9a03" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在本教程中，我们将学习如何使用 Keras API 创建卷积神经网络(CNN)。为了让它更直观，我将解释这个网络的每一层是做什么的，并提供一些提示和技巧来简化你的深度学习之旅。我们在本教程中的目的是建立一个基本的 CNN，它可以对胸部 x 光图像进行分类，并确定它是正常的还是患有肺炎。鉴于新冠肺炎疫情，我认为这将成为一个有趣的项目，即使是你的数据科学采访！</p><p id="1bdb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们开始吧！</p><h1 id="7961" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">什么时候应该使用卷积神经网络而不是人工神经网络？</h1><blockquote class="mw mx my"><p id="7a01" class="li lj mz lk b ll lm kd ln lo lp kg lq na ls lt lu nb lw lx ly nc ma mb mc md im bi translated">当数据可以以空间方式表示时，比如说以 MxN 像素表示的图像，CNN 工作得最好。如果你的数据在把你的任何一个专栏互相洗牌后仍然有用，那么你就不能使用 CNN。</p></blockquote><p id="6475" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">例如，如果您回忆一下第 1 部分中的贷款申请数据集，它有两列(或特性)，即<code class="fe nd ne nf ng b">age</code>和<code class="fe nd ne nf ng b">area</code>，如果我交换这两列(在将它提供给我的网络之前)，对我的数据集没有任何影响。因此，人工神经网络是这种数据集的首选。相反，如果我交换我的图像中的列(本质上是像素阵列)，我肯定会弄乱我的实际图像。因此，使用人工神经网络是一大禁忌，你必须使用 CNN。</p><h1 id="7da0" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">让我们直接进入编码...</h1><p id="0a6e" class="pw-post-body-paragraph li lj it lk b ll nh kd ln lo ni kg lq lr nj lt lu lv nk lx ly lz nl mb mc md im bi translated">我们首先在机器上安装 Keras。正如我在第 1 部分中讨论的，Keras 集成在 TensorFlow 中，所以您所要做的就是在您的终端(Mac OS)中使用<code class="fe nd ne nf ng b">pip install tensorflow</code>来访问 Jupyter 笔记本中的 Keras。要检查 Tensorflow 的版本，请使用<code class="fe nd ne nf ng b">tf.__version__</code>。</p><h1 id="d695" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">导入库</h1><pre class="ks kt ku kv gt nm ng nn no aw np bi"><span id="6805" class="nq mf it ng b gy nr ns l nt nu">import tensorflow as tf<br/>from tensorflow import keras<br/>from tensorflow.keras.models import Sequential<br/>from tensorflow.keras.layers import Activation, Dense, Flatten, BatchNormalization, Conv2D, MaxPool2D<br/>from tensorflow.keras.optimizers import Adam<br/>from tensorflow.keras.metrics import categorical_crossentropy<br/>from sklearn.metrics import confusion_matrix<br/>from tensorflow.keras.preprocessing.image import ImageDataGenerator</span><span id="7bc3" class="nq mf it ng b gy nv ns l nt nu">import numpy as np<br/>import itertools<br/>import os<br/>import random</span><span id="5adb" class="nq mf it ng b gy nv ns l nt nu">import matplotlib.pyplot as plt<br/>%matplotlib inline</span></pre><h1 id="14a0" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">资料组</h1><p id="1d0d" class="pw-post-body-paragraph li lj it lk b ll nh kd ln lo ni kg lq lr nj lt lu lv nk lx ly lz nl mb mc md im bi translated">我们将使用<a class="ae lh" href="https://www.kaggle.com/paultimothymooney/chest-xray-pneumonia" rel="noopener ugc nofollow" target="_blank">胸部 x 光图像</a> Kaggle 数据集。下载并解压缩后，您将看到<strong class="lk jd">胸部 x 光文件夹</strong>，其中包含整齐地组织到训练、有效和测试子文件夹中的图像。每个子文件夹包含两个子文件夹，一个用于<code class="fe nd ne nf ng b">normal</code>胸部 x 射线，另一个用于指示<code class="fe nd ne nf ng b">pneumonia</code>的 x 射线。</p><p id="b3da" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="mz">注意:确保</em> <strong class="lk jd"> <em class="mz"> chest_xray 文件夹</em> </strong> <em class="mz">和你的 Python Jupyter 笔记本在同一个目录下。</em></p><p id="4657" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">设置训练、验证和测试文件夹的路径:</p><pre class="ks kt ku kv gt nm ng nn no aw np bi"><span id="52cb" class="nq mf it ng b gy nr ns l nt nu">train_path = "chest_xray/train"<br/>test_path = "chest_xray/test"<br/>valid_path = "chest_xray/val"</span></pre><blockquote class="mw mx my"><p id="00d9" class="li lj mz lk b ll lm kd ln lo lp kg lq na ls lt lu nb lw lx ly nc ma mb mc md im bi translated">注意:如果您收集了自己的数据集&amp;它没有整齐地组织到 train、valid 和 test 文件夹中，不必担心！只需确保(a)您已将所有图像(正常和肺炎)保存在一个名为“胸部 x 射线”的公共文件夹中，并且(b)图像名称包含两个词中的一个——正常或肺炎。在此基础上，使用下面的代码片段将图像组织成训练集、有效集和测试集。</p></blockquote><pre class="ks kt ku kv gt nm ng nn no aw np bi"><span id="cbd1" class="nq mf it ng b gy nr ns l nt nu"># Organize data into train, valid, test directories<br/>os.chdir('data/chest_xrays')<br/>if os.path.isdir('train/normal') is False:<br/>    os.makedirs('train/normal')<br/>    os.makedirs('train/pneumonia')<br/>    os.makedirs('valid/normal')<br/>    os.makedirs('valid/pneumonia')<br/>    os.makedirs('test/normal')<br/>    os.makedirs('test/pneumonia')<br/><br/>    for i in random.sample(glob.glob('pneumonia*'), 500):<br/>        shutil.move(i, 'train/pneumonia')      <br/>    for i in random.sample(glob.glob('normal*'), 500):<br/>        shutil.move(i, 'train/normal')<br/>    for i in random.sample(glob.glob('pneumonia*'), 100):<br/>        shutil.move(i, 'valid/pneumonia')        <br/>    for i in random.sample(glob.glob('normal*'), 100):<br/>        shutil.move(i, 'valid/normal')<br/>    for i in random.sample(glob.glob('pneumonia*'), 50):<br/>        shutil.move(i, 'test/pneumonia')      <br/>    for i in random.sample(glob.glob('normal*'), 50):<br/>        shutil.move(i, 'test/normal')<br/><br/>os.chdir('../../')</span></pre><h1 id="dec1" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">预处理图像数据</h1><p id="9c6b" class="pw-post-body-paragraph li lj it lk b ll nh kd ln lo ni kg lq lr nj lt lu lv nk lx ly lz nl mb mc md im bi translated">我们需要将数据转换成模型期望的格式。所以我们必须把我们的图像转换成 T2 的格式。简而言之，我们将使用<code class="fe nd ne nf ng b">ImageGenerator</code>类中的<code class="fe nd ne nf ng b">flow_from_directory()</code>函数从 train、test 和 valid 目录创建<em class="mz">批处理</em>。使用<code class="fe nd ne nf ng b">fit</code>函数将这些批数据传递给顺序模型。(以前，在第 1 部分构建 ann 时，我们将 NumPy 数组传递给 fit 函数，但现在我们需要将批处理传递给 fit 函数)。</p><p id="f529" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">作为预处理的一部分(在创建批处理之前)，我们将应用<code class="fe nd ne nf ng b">preprocessing_function = tf.keras.applications.vgg16.preprocess_input</code>。这将按照图像传递到 vgg16 模型(2014 年赢得 ImageNet 竞赛的 CNN 模型)时处理图像的相同方式来处理我们的图像。</p><pre class="ks kt ku kv gt nm ng nn no aw np bi"><span id="e340" class="nq mf it ng b gy nr ns l nt nu"><em class="mz"># Creating train, test and valid batches from the respective directories</em></span><span id="a25c" class="nq mf it ng b gy nv ns l nt nu">train_batches = ImageDataGenerator(preprocessing_function=tf.keras.applications.vgg16.preprocess_input).flow_from_directory(directory=train_path, target_size=(224,224), classes=['pneumonia', 'normal'], batch_size=10)</span><span id="4adf" class="nq mf it ng b gy nv ns l nt nu">valid_batches = ImageDataGenerator(preprocessing_function=tf.keras.applications.vgg16.preprocess_input).flow_from_directory(directory=valid_path, target_size=(224,224), classes=['pneumonia', 'normal'], batch_size=10)</span><span id="d2c8" class="nq mf it ng b gy nv ns l nt nu">test_batches = ImageDataGenerator(preprocessing_function=tf.keras.applications.vgg16.preprocess_input).flow_from_directory(directory=test_path, target_size=(224,224), classes=['pneumonia', 'normal'], batch_size=10, shuffle=False)</span></pre><p id="46e3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe nd ne nf ng b">target_size</code>指定我们希望图像调整到的高度和宽度。这很重要，因为我们的数据集中可能有不同大小的图像。</p><p id="bec9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe nd ne nf ng b">batch_size</code>被设置为 10，并且 10 的选择是任意的。32 中使用的另一个常见批量值，但理想情况下，最佳值应该通过超参数调整找到(我们将在下一个教程中学习如何做到这一点)。</p><blockquote class="mw mx my"><p id="d646" class="li lj mz lk b ll lm kd ln lo lp kg lq na ls lt lu nb lw lx ly nc ma mb mc md im bi translated">批量大小指定了在更新神经网络的权重之前 <strong class="lk jd">一次应该将多少训练样本传递给神经网络。</strong></p></blockquote><p id="98a7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们还为测试集只指定了<code class="fe nd ne nf ng b">shuffle = False</code><strong class="lk jd"/>，因为稍后当我们测试我们的模型时，我们想要访问未混淆的标签来绘制我们的混淆矩阵。默认情况下，shuffle 设置为 True。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/0c0adb769afc7540f0a214948c52219b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*w7QLDoF2Tl7HuKA4HmIjng.png"/></div></figure><p id="2dc9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="mz">注意:如果你在运行上面的代码时看到</em> <code class="fe nd ne nf ng b"><em class="mz">Found 0 images beloning to 2 classes</em></code> <em class="mz">，很可能你指向了错误的目录！解决这个问题，它应该工作正常！</em></p><h1 id="cb01" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">可视化图像数据:</h1><p id="ad67" class="pw-post-body-paragraph li lj it lk b ll nh kd ln lo ni kg lq lr nj lt lu lv nk lx ly lz nl mb mc md im bi translated">使用 TensorFlow 的<a class="ae lh" href="https://www.tensorflow.org/tutorials/images/classification#visualize_the_data" rel="noopener ugc nofollow" target="_blank">文档</a>中的绘图助手功能。</p><pre class="ks kt ku kv gt nm ng nn no aw np bi"><span id="9e64" class="nq mf it ng b gy nr ns l nt nu"><em class="mz"># plot images in the form of a 1 by 10 grid and resize img to 20x20</em><br/>def plotImages(images_arr):<br/>    fig, axes = plt.subplots(1, 10, figsize=(20,20))<br/>    axes = axes.flatten()<br/>    for img, ax in zip( images_arr, axes):<br/>        ax.imshow(img.astype(np.uint8))<br/>        ax.axis('off')<br/>    plt.tight_layout()<br/>    plt.show()</span></pre><p id="d6ee" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Newt，我们将使用 Python 函数<code class="fe nd ne nf ng b">next()</code>从训练集中抓取一批图像和相应的标签。由于我们设置了<code class="fe nd ne nf ng b">batch_size = 10</code>，我们将看到在<code class="fe nd ne nf ng b">imgs</code>中有 10 个图像，在<code class="fe nd ne nf ng b">labels</code>中有 10 个相应的标签。</p><pre class="ks kt ku kv gt nm ng nn no aw np bi"><span id="ef96" class="nq mf it ng b gy nr ns l nt nu">imgs, labels = next(train_batches)</span><span id="b314" class="nq mf it ng b gy nv ns l nt nu">plotImages(imgs)<br/>print(labels)</span></pre><p id="5570" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="mz">注意:</em> <code class="fe nd ne nf ng b"><em class="mz">imshow</em></code> <em class="mz">期望输入在</em> <code class="fe nd ne nf ng b"><em class="mz">[0, 1]</em></code> <em class="mz">或</em> <code class="fe nd ne nf ng b"><em class="mz">[0, 255]</em></code> <em class="mz">的范围内，所以如果输入数组没有这个范围，它将削波输入。因此，我们在显示时显式地将图像转换为</em> <code class="fe nd ne nf ng b"><em class="mz">np.int8</em></code> <em class="mz">格式。</em></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nx"><img src="../Images/399bb46d55afea8b740a31a08c680671.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8PNc7LUC2oWinTw50Rk5Qw.png"/></div></div></figure><p id="dccf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="mz">注意:图像可能看起来与你的目录中的有一点不同(可能有点失真)，但那是因为我们对它执行了一些 vgg16 预处理步骤。</em></p><p id="095c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">标签是指示图像是肺炎还是正常的一次性编码向量。A <code class="fe nd ne nf ng b">[1 0]</code>代表肺炎，而<code class="fe nd ne nf ng b">[0 1]</code>代表正常 x 光。</p><h1 id="47ef" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">生成模型架构</h1><p id="fe21" class="pw-post-body-paragraph li lj it lk b ll nh kd ln lo ni kg lq lr nj lt lu lv nk lx ly lz nl mb mc md im bi translated">回想一下，当我们在第 1 部分中构建一个用于预测贷款申请结果的人工神经网络时，我们介绍了一个<strong class="lk jd">序列模型</strong>。简而言之，顺序 API <strong class="lk jd"> </strong>允许你逐层创建模型。</p><pre class="ks kt ku kv gt nm ng nn no aw np bi"><span id="14d5" class="nq mf it ng b gy nr ns l nt nu">model = Sequential([<br/>    Conv2D(filters=32, kernel_size=(3, 3), activation='relu', padding = 'same', input_shape=(224,224,3)),<br/>    MaxPool2D(pool_size=(2, 2), strides=2),<br/>    Conv2D(filters=64, kernel_size=(3, 3), activation='relu', padding = 'same'),<br/>    MaxPool2D(pool_size=(2, 2), strides=2),<br/>    Flatten(),<br/>    Dense(units=2, activation='softmax')<br/>])</span></pre><p id="1154" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">第一个隐藏层</strong>是标准卷积层<code class="fe nd ne nf ng b">Conv2D</code>，有 32 个滤波器，每个滤波器的核大小为 3x3。请记住，每个过滤器都专用于识别图像的某些方面，比如过滤器 1 检测胸腔的垂直边界，过滤器 2 检测胸腔的对角线边界，等等...随着时间的推移，随着我们深入网络的卷积层，过滤器编码的模式将变得复杂。</p><p id="edd1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="mz">注:32 的选择是任意的！</em></p><blockquote class="mw mx my"><p id="e764" class="li lj mz lk b ll lm kd ln lo lp kg lq na ls lt lu nb lw lx ly nc ma mb mc md im bi translated">一个<strong class="lk jd">内核</strong>是一个由数字组成的小网格，你将它传递给你的整个图像，即你输入图像中的所有像素，并根据这些数字进行转换。</p></blockquote><p id="90d6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">通过在内核中使用不同的数字，您可以执行不同类型的图像预处理(在图像识别期间)，如对比度、模糊、锐化或边缘检测。一般来说，内核比映像小，3x3 是相当常见的选择！</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ny"><img src="../Images/5b4c967dce5a7c12be45f7242630c238.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*opZllXHxr_539y6K.gif"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">Gif 展示了一个 3x3 内核如何通过整个图像。来源:<a class="ae lh" href="https://www.machinelearninguru.com//computer_vision/basics/convolution/convolution_layer.html" rel="noopener ugc nofollow" target="_blank">https://www . machine learning uru . com//computer _ vision/basics/convolution/convolution _ layer . html</a></p></figure><p id="3006" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当内核到达图像的边缘时，它必须决定在输入图像中没有像素的地方做什么。现在，我们继续用<em class="mz">零填充</em>边缘，使用<code class="fe nd ne nf ng b">padding = 'same'</code>实现。零填充意味着在图像外部提供一个零缓冲(如上面的 gif 图像所示)。这有助于确保卷积操作后输入图像的<a class="ae lh" href="https://deeplizard.com/learn/video/qSTv_m-KFk0" rel="noopener ugc nofollow" target="_blank">维度不会减少。</a></p><p id="fcd1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="mz">注意:根据内核大小和图像大小，你可能需要做两到三层厚的垫子。</em></p><p id="1ce1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">从第 1 部分，您已经知道我们如何根据自己的数据集得出<code class="fe nd ne nf ng b">input_shape</code>参数。基本上，它可以被认为是一个<em class="mz">单个</em>图像的形状，该图像被馈送到网络，在我们的例子中是 224x224x3(高度=宽度= 224，3 是颜色通道，更准确地说是 RGB 分量)。您可以通过使用给出元组<code class="fe nd ne nf ng b">(224,224,3)</code>作为答案的<code class="fe nd ne nf ng b">imgs[0].shape</code>检查<code class="fe nd ne nf ng b">imgs</code>中随机元素(比如第一个元素)的形状来验证这是否正确。</p><p id="6442" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最后，对于第一个隐藏层，我们有<code class="fe nd ne nf ng b">relu</code>激活函数(在第一部分讨论过)。总的来说，激活函数确保传递的值在可调的预期范围内。<a class="ae lh" href="https://machinelearningmastery.com/rectified-linear-activation-function-for-deep-learning-neural-networks/" rel="noopener ugc nofollow" target="_blank">整流线性单元</a>(或 relu)函数返回直接作为输入提供的值，或者如果输入为 0.0 或更小，则返回值 0.0。</p><p id="f65e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">第二个隐藏层</strong>是最大池层<code class="fe nd ne nf ng b">MaxPool2D</code>，主要用于降低数据的维度。其方法是从过滤后的图像(来自卷积/RELU 层)中选择一个窗口大小(<code class="fe nd ne nf ng b">pool_size = 2x2</code>)，然后用该窗口中的最高值替换其中的 4 个像素。接下来，向右(或向下或向上)移动两步<code class="fe nd ne nf ng b">stride</code>，用最高值替换这 4 个像素。等等，直到整个图像被覆盖。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nz"><img src="../Images/b67334402a7bfe4e58377dd68dffc16b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sTW-VwOrlv8j8r7N.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">MaxPooling 的例子。<a class="ae lh" href="https://www.google.com/url?sa=i&amp;url=https%3A%2F%2Fcomputersciencewiki.org%2Findex.php%2FMax-pooling_%2F_Pooling&amp;psig=AOvVaw2fEdtSyGyTeKglezNZfqnb&amp;ust=1599290533375000&amp;source=images&amp;cd=vfe&amp;ved=0CAMQjB1qFwoTCLifsdP7zusCFQAAAAAdAAAAABAD" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="22e5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">第三</strong>和<strong class="lk jd">第四隐藏层</strong>又分别是<code class="fe nd ne nf ng b">Conv2D</code>和<code class="fe nd ne nf ng b">MaxPool2D</code>。</p><p id="81e3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="mz">注意:第二个</em> <code class="fe nd ne nf ng b"><em class="mz">Conv2D</em></code> <em class="mz">图层有</em> <code class="fe nd ne nf ng b"><em class="mz">filters = 64</em></code> <em class="mz">，是第一个</em> <code class="fe nd ne nf ng b"><em class="mz">Conv2D</em></code> <em class="mz">图层滤镜数量的两倍(其中有 32 个滤镜)。当我们进入网络的较后的层时，这种功能的增加是一种常见的做法。</em></p><p id="6180" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最后，我们<code class="fe nd ne nf ng b">flatten</code>卷积层的输出，并通过<code class="fe nd ne nf ng b">units = 2</code>(对应于输出类<code class="fe nd ne nf ng b">pneumonia</code>和<code class="fe nd ne nf ng b">normal</code>)和<code class="fe nd ne nf ng b">softmax</code>激活将其传递给<code class="fe nd ne nf ng b">Dense</code>层。softmax 函数返回两个类的输出概率。(关于 softmax 激活的详细描述，请在此处阅读<a class="ae lh" rel="noopener" target="_blank" href="/beginners-guide-to-building-artificial-neural-networks-using-keras-in-python-bdc4989dab00"/>)。</p><p id="d309" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">模型摘要如下所示:</p><pre class="ks kt ku kv gt nm ng nn no aw np bi"><span id="ac3d" class="nq mf it ng b gy nr ns l nt nu">model.summary()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/12075c6671f19df5a0ee603d9f3d81ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/1*VAkbP85dMYKicikJMqp_rA.png"/></div></figure><h1 id="1c87" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">为培训准备模型</h1><pre class="ks kt ku kv gt nm ng nn no aw np bi"><span id="c44a" class="nq mf it ng b gy nr ns l nt nu">model.compile(optimizer=Adam(learning_rate=0.0001), loss='categorical_crossentropy', metrics=['accuracy'])</span></pre><p id="7b85" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在我们开始用实际数据训练我们的模型之前，我们必须用某些参数<code class="fe nd ne nf ng b">compile</code>模型。这里，我们将使用 Adam <code class="fe nd ne nf ng b">optimizer</code>。<code class="fe nd ne nf ng b">loss</code>参数指定在每次迭代中应该监控分类交叉熵损失。<code class="fe nd ne nf ng b">metrics</code>参数表示我们希望根据精确度来判断我们的模型。</p><h1 id="6fda" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">训练和验证模型</h1><p id="3c1c" class="pw-post-body-paragraph li lj it lk b ll nh kd ln lo ni kg lq lr nj lt lu lv nk lx ly lz nl mb mc md im bi translated"><em class="mz">注意:当下面的代码运行时，你可以很容易地去喝杯咖啡什么的。在 CPU 上，每个时期花费我大约 5 分钟，所以运行 10 个时期大约需要 50 分钟。</em></p><pre class="ks kt ku kv gt nm ng nn no aw np bi"><span id="5ceb" class="nq mf it ng b gy nr ns l nt nu"><em class="mz"># recall that we set batch_size = 10 during preprocessing<br/></em>batch_size = 10 <br/><br/>model.fit(<br/>    x = train_batches, <br/>    steps_per_epoch=train_batches.samples // batch_size, <br/>    epochs=10, <br/>    validation_data=valid_batches, <br/>    validation_steps=valid_batches.samples // batch_size,<br/>    verbose=2)</span></pre><p id="bd3a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你仔细观察，我们没有明确地为训练集声明标签(就像我们在第一部分中使用<code class="fe nd ne nf ng b">y</code>参数为 ann 所做的那样)，原因是它们已经包含在<code class="fe nd ne nf ng b">train_batches</code>迭代器中。</p><p id="1a47" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe nd ne nf ng b">steps_per_epoch</code>是根据你的训练数据计算出来的。例如，如果我们的训练集中的样本数是 1000，批量大小是 20，那么通过除以 1000/20 = 50 来计算<code class="fe nd ne nf ng b">steps_per_epoch</code>。</p><p id="763f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">更正式地说，</p><blockquote class="mw mx my"><p id="8008" class="li lj mz lk b ll lm kd ln lo lp kg lq na ls lt lu nb lw lx ly nc ma mb mc md im bi translated">steps_per_epoch <strong class="lk jd">它通常应等于<strong class="lk jd"> ceil(样本数/批量大小)</strong>。</strong></p></blockquote><p id="fcb7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">此外，既然我们正在通过<code class="fe nd ne nf ng b">validation_data = valid_batches</code>，我们也需要通过<code class="fe nd ne nf ng b">validation_steps</code>。它与<code class="fe nd ne nf ng b">steps_per_epoch</code>参数完全一样，但主要是关于验证数据(而不是训练数据)。</p><p id="14f2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是模型训练的输出，根据输出消息将<code class="fe nd ne nf ng b">verbose</code>设置为最高级别:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ob"><img src="../Images/ddd934fbacee20a1becaaf2cdb7e4cc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QGDu2L9TdpDkG9ujDoZLLQ.png"/></div></div></figure><p id="92a0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如您所见，由于训练集准确率为 100%,训练集损失几乎可以忽略不计，但验证集的准确率仅为 75%,因此肯定存在一些过度拟合。但是，嘿，即使有这样一个基本的模型架构和只有六个隐藏层，这一点也不差，首先！</p><p id="39b1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你想达到更高的精度(~92%)，使用更深的模型架构，就像这里描述的<a class="ae lh" href="https://www.kaggle.com/artemkostrikin/pneumonia-model-cnn-92" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="7f7c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">减少过度拟合的另一个很棒的方法是使用退出和批量正则化，我们将在下一个教程中讨论。</p><h1 id="91a1" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated"><strong class="ak">对测试集进行推理</strong></h1><pre class="ks kt ku kv gt nm ng nn no aw np bi"><span id="0682" class="nq mf it ng b gy nr ns l nt nu"><em class="mz"># making predictions<br/></em>predictions = model.predict(x = test_batches, verbose=0)</span></pre><p id="e66f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">直接使用<a class="ae lh" href="https://scikit-learn.org/stable/auto_examples/model_selection/plot_confusion_matrix.html#sphx-glr-auto-examples-model-selection-plot-confusion-matrix-py" rel="noopener ugc nofollow" target="_blank"> Scikit 学习文档</a>中的绘图功能:</p><pre class="ks kt ku kv gt nm ng nn no aw np bi"><span id="533d" class="nq mf it ng b gy nr ns l nt nu">def plot_confusion_matrix(cm, classes,<br/>                          normalize=False,<br/>                          title='Confusion matrix',<br/>                          cmap=plt.cm.Blues):<br/>    """<br/>    This function prints and plots the confusion matrix.<br/>    Normalization can be applied by setting `normalize=True`.<br/>    """<br/>    plt.imshow(cm, interpolation='nearest', cmap=cmap)<br/>    plt.title(title)<br/>    plt.colorbar()<br/>    tick_marks = np.arange(len(classes))<br/>    plt.xticks(tick_marks, classes, rotation=45)<br/>    plt.yticks(tick_marks, classes)</span><span id="00af" class="nq mf it ng b gy nv ns l nt nu">if normalize:<br/>        cm = cm.astype('float') / cm.sum(axis=1)[:, np.newaxis]<br/>        print("Normalized confusion matrix")<br/>    else:<br/>        print('Confusion matrix, without normalization')</span><span id="4771" class="nq mf it ng b gy nv ns l nt nu">print(cm)</span><span id="d65b" class="nq mf it ng b gy nv ns l nt nu">thresh = cm.max() / 2.<br/>    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):<br/>        plt.text(j, i, cm[i, j],<br/>            horizontalalignment="center",<br/>            color="white" if cm[i, j] &gt; thresh else "black")</span><span id="a177" class="nq mf it ng b gy nv ns l nt nu">plt.tight_layout()<br/>    plt.ylabel('True label')<br/>    plt.xlabel('Predicted label')</span></pre><h2 id="6154" class="nq mf it bd mg oc od dn mk oe of dp mo lr og oh mq lv oi oj ms lz ok ol mu iz bi translated">使用混淆矩阵可视化预测结果</h2><pre class="ks kt ku kv gt nm ng nn no aw np bi"><span id="843a" class="nq mf it ng b gy nr ns l nt nu"><em class="mz"># confusion matrix</em><br/>cm = confusion_matrix(y_true=test_batches.classes, y_pred=np.argmax(predictions, axis=-1))</span><span id="7823" class="nq mf it ng b gy nv ns l nt nu">plot_confusion_matrix(cm, classes = ['Pneumonia', 'Normal'])</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi om"><img src="../Images/c16d7cc2bbfff9cb37070682dc574f77.png" data-original-src="https://miro.medium.com/v2/resize:fit:910/format:webp/1*vwYi_JnBw_oYng7UDvrSTg.png"/></div></figure></div><div class="ab cl on oo hx op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="im in io ip iq"><p id="513c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这就是我们的第一个用于 Python 二进制图像分类的 CNN 模型。请参考第 1 部分，了解如何保存优化器的模型架构、权重和状态。在下一个教程中，我们将学习如何提高 CNN 和 ann 对测试数据的准确性。</p><p id="b67e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在那之前:)</p><div class="ou ov gp gr ow ox"><a rel="noopener follow" target="_blank" href="/beginners-guide-to-building-artificial-neural-networks-using-keras-in-python-bdc4989dab00"><div class="oy ab fo"><div class="oz ab pa cl cj pb"><h2 class="bd jd gy z fp pc fr fs pd fu fw jc bi translated">使用 Python 中的 Keras 构建人工神经网络的初学者指南</h2><div class="pe l"><h3 class="bd b gy z fp pc fr fs pd fu fw dk translated">创建网络架构、训练、验证和保存模型并使用它进行推理的提示和技巧。</h3></div><div class="pf l"><p class="bd b dl z fp pc fr fs pd fu fw dk translated">towardsdatascience.com</p></div></div><div class="pg l"><div class="ph l pi pj pk pg pl lb ox"/></div></div></a></div><div class="ou ov gp gr ow ox"><a rel="noopener follow" target="_blank" href="/step-by-step-guide-to-explaining-your-ml-project-during-a-data-science-interview-81dfaaa408bf"><div class="oy ab fo"><div class="oz ab pa cl cj pb"><h2 class="bd jd gy z fp pc fr fs pd fu fw jc bi translated">在数据科学面试中解释你的 ML 项目的逐步指南。</h2><div class="pe l"><h3 class="bd b gy z fp pc fr fs pd fu fw dk translated">在结尾有一个额外的样本脚本，让你谨慎地展示你的技术技能！</h3></div><div class="pf l"><p class="bd b dl z fp pc fr fs pd fu fw dk translated">towardsdatascience.com</p></div></div><div class="pg l"><div class="pm l pi pj pk pg pl lb ox"/></div></div></a></div><div class="ou ov gp gr ow ox"><a rel="noopener follow" target="_blank" href="/time-series-analysis-using-pandas-in-python-f726d87a97d8"><div class="oy ab fo"><div class="oz ab pa cl cj pb"><h2 class="bd jd gy z fp pc fr fs pd fu fw jc bi translated">使用 Python 中的 Pandas 进行时间序列分析</h2><div class="pe l"><h3 class="bd b gy z fp pc fr fs pd fu fw dk translated">对季节性、趋势、自相关等关键词的额外介绍。</h3></div><div class="pf l"><p class="bd b dl z fp pc fr fs pd fu fw dk translated">towardsdatascience.com</p></div></div><div class="pg l"><div class="pn l pi pj pk pg pl lb ox"/></div></div></a></div></div></div>    
</body>
</html>