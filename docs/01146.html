<html>
<head>
<title>Introducing Leya: The Meta-Statistical Lisp-like language</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Leya简介:元统计Lisp类语言</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/introducing-leya-the-meta-statistical-lisp-like-language-ef9012affbdb?source=collection_archive---------31-----------------------#2020-02-01">https://towardsdatascience.com/introducing-leya-the-meta-statistical-lisp-like-language-ef9012affbdb?source=collection_archive---------31-----------------------#2020-02-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f7ef" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我正在创造我梦想中的语言。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9e579b495a461076c18f27c4202d45c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TSFU3nSMLyXd8lVDyE0d_Q.png"/></div></div></figure><p id="d538" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi lq translated">在过去的几周里，我一直在享受GNU Common Lisp的强大功能。在Common Lisp中，所有代码都包含一个列表，它是list中的一个数据类型。本质上，Lisp程序只是列表中的一系列参数。首先，这使得Lisp成为元编程极其可行的语言。Lisp的宏进一步增强了这种效果。Lisp的宏使得从语言内部调用子进程和使用代码作为数据类型变得非常容易。这当然是非常有效的，不仅可以使你的代码干净、简洁、易读，而且可以自动化。</p><p id="f6b0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我正在构建的语言Leya是一个将这种方法论发挥到极致的计划。Lisp很棒，但我确实不喜欢Common Lisp的某些地方:</p><ul class=""><li id="d523" class="lz ma it kw b kx ky la lb ld mb lh mc ll md lp me mf mg mh bi translated">包裹绝对是一种痛苦。我想有一个简单的结构类似这样的导入功能:</li></ul><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="5558" class="mn mo it mj b gy mp mq l mr ms">(import :package)</span></pre><p id="94d7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在Lisp中，添加包绝对是一场噩梦。当然，这不一定是Lisp的错，因为这种语言是在1958年创造的，但这肯定是一个缺点。包作为一个简单的文件存储在任何外部环境的本地，并且必须直接从源代码加载。如果不考虑安装在系统范围内的lib-dependency(例如-lib-SDL 2)不能在Lisp中使用，这可能并不奇怪。有替代方案，比如beta版Quick Lisp包，但是这些肯定不能替代一个有效的包管理器。</p><ul class=""><li id="669f" class="lz ma it kw b kx ky la lb ld mb lh mc ll md lp me mf mg mh bi translated">Lisp实际上可以快得多，只要在后端做一些性能上的调整。</li></ul><p id="1b2d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Lisp具有强大的统计能力和惊人的速度！对于数据科学来说，这两者可能是致命的组合。事实是Lisp实际上可以比现在快得多。要理解这是为什么，我们需要理解一个叫做控制流的概念。每种语言都有一个控制流，控制流既可以“跳转”，也可以根据具体情况忽略。跳转是这里的关键词，因为无论何时进行跳转，程序的控制流都会随之改变。</p><p id="6eaa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">默认情况下，控制流是垂直的，每个部分从1开始向上计数。这里有一个例子，写在NASM编译的汇编里:</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="5dfa" class="mn mo it mj b gy mp mq l mr ms">_start:</span><span id="ea20" class="mn mo it mj b gy mt mq l mr ms">; Allocate our memory</span><span id="7bbb" class="mn mo it mj b gy mt mq l mr ms">; Get the current brk address<br/>        mov rax, 12 ; brk<br/>        mov rdi, 0<br/>        syscall</span><span id="e11b" class="mn mo it mj b gy mt mq l mr ms">; rax =&gt; alloc_ptr &amp;&amp; heap_start<br/>        mov [alloc_ptr], rax<br/>        mov [heap_start], rax</span><span id="383e" class="mn mo it mj b gy mt mq l mr ms">; (Allocate memory)<br/>        mov rdi, rax<br/>        ; 64 == 9 million;<br/>        add rdi, 1000000</span><span id="8454" class="mn mo it mj b gy mt mq l mr ms">; Syscall<br/>        mov rax, 12<br/>        syscall</span><span id="7f3d" class="mn mo it mj b gy mt mq l mr ms">; Read the source code into memory<br/>;   VVVVVVVVVVVV Recreate this with call reading_loop attached<br/>;            for read evaluate print<br/>    reading_loop:</span><span id="7f4c" class="mn mo it mj b gy mt mq l mr ms">; Read from stdin<br/>        mov rax, 0<br/>        mov rdi, 0 ; stdin<br/>        mov rsi, [alloc_ptr]<br/>        mov rdx, 100000<br/>        syscall</span><span id="90dd" class="mn mo it mj b gy mt mq l mr ms">add [alloc_ptr], rax</span><span id="ae92" class="mn mo it mj b gy mt mq l mr ms">cmp rax, 0<br/>        jne reading_loop<br/>    ;   call reading_loop<br/>    ; After the loop:</span><span id="e91b" class="mn mo it mj b gy mt mq l mr ms">; Save the end of the program<br/>        mov rax, [alloc_ptr]<br/>        mov [program_end], rax</span><span id="6608" class="mn mo it mj b gy mt mq l mr ms">; Add a null terminator<br/>        mov byte [rax], 0<br/>        inc rax</span><span id="20bc" class="mn mo it mj b gy mt mq l mr ms">; Align pointer<br/>    align_loop:<br/>        mov rdi, rax<br/>        and rdi, 0</span></pre><blockquote class="mu"><p id="ee37" class="mv mw it bd mx my mz na nb nc nd lp dk translated">好吧，这看起来像很多代码。</p></blockquote><p id="b9c7" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">但是为了理解控制流，我们只需要看几个例子。每当调用“_start:”时，控制流被设置为降序，一个包含数字0的字节被放入内存。在“_start:”完成后，由于没有跳转或调用，控制流将继续下降，当它完成与内核的syscall通信时，它将进入位置1:“reading _ loop:。”</p><p id="2017" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在读取循环的最后，我们会看到三个命令:add、cmp、jne。首先，add是做什么的？Add将把我们在。bss部分或。数据段添加到注册表rax，它是64位高位注册表中的第一个位置。下一个命令cmp是compare的缩写。这将比较两个值，并根据标志的结果更改标志。在这个特殊的例子中，我使用存储在字节0的注册表标志，CF标志。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/761be5e243ebccee37da5ebcdb17e57a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*UduEgnjf59sdmutVRX_A3w.jpeg"/></div><p class="nk nl gj gh gi nm nn bd b be z dk translated">(img src:<a class="ae no" href="https://www.slideshare.net/safayethossain3/assembly-flag-resister" rel="noopener ugc nofollow" target="_blank">https://www . slide share . net/safayethossain 3/assembly-flag-resister</a>)</p></figure><p id="aa61" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后但同样重要的是jne，这是一个条件跳转。如果满足这个标志，那么jne命令将通过将控制流保持在位置1:“reading _ loop:.”来将控制流变成一个圆形</p><p id="c250" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">控制流实际上驱动了我们在日常语言中使用的大多数东西，以及我们使用的每个高级工具，例如循环、条件等。实际上通常会使用非常特殊的控制流。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/c4d987837315a6cf2dd1d87edc6157a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t0DjByYbNEf-iG51zWj_wQ.jpeg"/></div></div><p class="nk nl gj gh gi nm nn bd b be z dk translated">(img src:【https://dzone.com/articles/how-draw-control-flow-graph】T2</p></figure><p id="d5c9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当然，控制流不仅对我们想要做的事情非常重要，对性能也非常重要。你可能听说过for循环，一般来说，非常能够坦克性能。这是因为for循环使用至少四个位置的组合，并将根据添加的数据字节进行条件跳转(将字符长度存储在内存中，并将cmp值保存在内存中，循环数。)这意味着每次不满足最终迭代条件时，控制流将减少2。假设我们在位置3，每次for循环没有完成，我们就跳到位置1，重复这个过程。</p><p id="e0fd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">很明显，有很多方法可以通过调整控制流来提高性能。这个方法其实是朱莉娅想出来的，所以我不能居功；每当汇编编译器调用自身时，控制流就会不断地循环。这意味着在语言内部运行比汇编语言更有性能。这是因为汇编的进程在执行前由处理器读取。这类似于大多数语言的编译方式。</p><p id="866e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，当语言中最常用的核心函数是用语言本身编写的时候，就可以在运行时进行调用，而不需要另一次汇编。所以我们的目标是在一个单独的线程上运行一个已经分配、加载并标记了内存的代码。</p></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><h1 id="e862" class="nx mo it bd ny nz oa ob oc od oe of og jz oh ka oi kc oj kd ok kf ol kg om on bi translated">结论</h1><p id="3589" class="pw-post-body-paragraph ku kv it kw b kx oo ju kz la op jx lc ld oq lf lg lh or lj lk ll os ln lo lp im bi translated">作为一种类似Lisp的语言，Leya编程语言拥有Lisp的所有优点。轻松编译，用汇编器只汇编3000行左右的代码，一切都是列表，还有用宏进行元编程的轻松和流畅。</p><p id="0572" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">创建一种与另一种语言做同样事情的语言是有点愚蠢的，尽管我会第一个说构建编译器使我在汇编和编程方面做得更好。实际上，有一本有趣的书叫做《用C语言构建你自己的Lisp 》,如果你想学习C语言，我建议你去看看。构建Lisp不仅能让你更好地学习C语言，或者帮助你学习C语言，而且我认为它还能让你更接近许多理解起来非常重要的计算机科学基础。</p><p id="f186" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">“Leya”这个名字的本意是解释它自己，而这种语言的构建意图完全不同:</p><blockquote class="mu"><p id="8280" class="mv mw it bd mx my ot ou ov ow ox lp dk translated">机器学习的快速元编程。</p></blockquote><p id="a61c" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">“Leya”这个名字来源于术语Lemma，它是一个论证或证明中的数学分离，也是中间的。这是我的原话，但这是谷歌的定义:</p><blockquote class="mu"><p id="6472" class="mv mw it bd mx my ot ou ov ow ox lp dk translated">"论证或证明中的附属或中间定理."</p></blockquote><p id="20ea" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">这非常类似于编程中的宏指令。Y来自于我们都知道并且喜爱的Y，我们算法的目标。</p><p id="deba" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为Lisp是轻量级的，易于编译，所以Lisp是一种非常快速的编程语言。Lisp通常被认为不能像C那样使用，但是它的语法非常高级，很容易习惯。Lisp最难的一点是，为了使用它，你必须直接从传统的角度来思考所有的事情。从回报开始，一直到价值。通常我只在一个值被循环使用的特殊情况下设置一个变量，以避免多次计算。</p><p id="87bc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢您阅读到最后，如果您想了解Leya，请访问Github:</p><div class="oy oz gp gr pa pb"><a href="https://github.com/emmettgb/Leya" rel="noopener  ugc nofollow" target="_blank"><div class="pc ab fo"><div class="pd ab pe cl cj pf"><h2 class="bd iu gy z fp pg fr fs ph fu fw is bi translated">emmettgb/Leya</h2><div class="pi l"><h3 class="bd b gy z fp pg fr fs ph fu fw dk translated">Leya -火烈鸟的官方编程语言。通过在…上创建帐户，为emmettgb/Leya的发展做出贡献</h3></div><div class="pj l"><p class="bd b dl z fp pg fr fs ph fu fw dk translated">github.com</p></div></div><div class="pk l"><div class="pl l pm pn po pk pp ks pb"/></div></div></a></div><p id="2754" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">每天都有越来越多的问题涌现出来，慢慢地，但肯定地，问题正在得到解决。截至目前，我有大约六个项目，我一直在工作，所以开发一直很慢(请放心提交！)但是希望到最后，这种语言是我所有数据科学需求的理想选择。</p></div></div>    
</body>
</html>