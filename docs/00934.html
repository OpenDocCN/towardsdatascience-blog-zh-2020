<html>
<head>
<title>Easy Fixes For SQL Queries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SQL查询的简单修复</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/easy-fixes-for-sql-queries-ff9d8867a617?source=collection_archive---------18-----------------------#2020-01-27">https://towardsdatascience.com/easy-fixes-for-sql-queries-ff9d8867a617?source=collection_archive---------18-----------------------#2020-01-27</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><figure class="it iu gq gs iv iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj is"><img src="../Images/45a6722933091f23598be85f845356e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Llxx4OsDETVK_qcj-kSaXQ.jpeg"/></div></div><p class="jd je gk gi gj jf jg bd b be z dk translated">由<a class="ae jh" href="https://unsplash.com/@thoughtcatalog?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">思想目录</a>在<a class="ae jh" href="https://unsplash.com/s/photos/improvement?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。不是101篇文章，但是这里有一些提示和想法将会改变你写SQL的方式。他们可能不会改变你的想法。为了改变你的思维方式，你应该多读书，与真实的人交谈，并确定你需要改变你的思维方式。我可以一直唠叨下去。如果你能读一读这篇关于SQL的该死的文章，那不是很好吗！我已经花了将近十年的时间学习SQL，并且仍然很强大。</p></figure><h2 id="236f" class="ji jj jk bd b dl jl jm jn jo jp jq dk jr translated" aria-label="kicker paragraph">更好的SQL</h2><div class=""/><div class=""><h2 id="dc3c" class="pw-subtitle-paragraph kq jt jk bd b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dk translated">查询任何传统关系数据库的经验法则</h2></div><p id="2596" class="pw-post-body-paragraph li lj jk lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">SQL对于任何角色来说都是一个强大的工具。数据驱动着公司的所有决策。数据只使用一种语言，那就是SQL。写SQL(或者说，如果你是个书呆子的话)很简单。大多数人都能做到。只有一些人做得很好。这个会超级短超级有用。</p><p id="b8cc" class="pw-post-body-paragraph li lj jk lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">不管您使用的是什么关系数据库管理系统或RDBMS (MySQL、PostgreSQL、SQL Server、Oracle ),一些经验法则都适用于所有这些。以下是在你的数据库上做<code class="fe me mf mg mh b">SELECT</code>的规则</p><h1 id="9cbb" class="mi mj jk bd mk ml mm mn mo mp mq mr ms kz mt la mu lc mv ld mw lf mx lg my mz bi translated">1.总是使用<a class="ae jh" href="https://use-the-index-luke.com/sql/where-clause" rel="noopener ugc nofollow" target="_blank"> WHERE </a>子句(总是使用索引)</h1><p id="33dc" class="pw-post-body-paragraph li lj jk lk b ll na ku ln lo nb kx lq lr nc lt lu lv nd lx ly lz ne mb mc md in bi translated">换句话说，只获取您绝对需要的数据——这可以通过使用古老的<code class="fe me mf mg mh b">WHERE</code>子句来完成。只有在极少数情况下，您会发现不使用索引可以获得更好的性能。不要担心罕见的情况。索引强制数据做二分搜索法(尽管不同数据库的二分搜索法实现不同)。本质上，你将能够在对数时间而不是线性时间内<code class="fe me mf mg mh b">SELECT</code>你的数据。</p><blockquote class="nf"><p id="2eee" class="ng nh jk bd ni nj nk nl nm nn no md dk translated">只获取你绝对需要的数据</p></blockquote><p id="5bec" class="pw-post-body-paragraph li lj jk lk b ll np ku ln lo nq kx lq lr nr lt lu lv ns lx ly lz nt mb mc md in bi translated">例如，对一个有10亿条记录的表进行查询<strong class="lk ju"> <em class="nu">而不使用</em> </strong>索引，可能需要多达10亿次才能得到您想要的记录。然而，使用 索引对您正在搜索的列进行查询<strong class="lk ju"> <em class="nu">将花费更少的次数，并且将更快地获得结果，因为10亿的对数以2为底大约是30(准确地说，是29.897352854)。这是对搜索过程的过度简化。</em></strong></p><p id="e9da" class="pw-post-body-paragraph li lj jk lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated"><em class="nu">感谢纠正日志上以2为基数的值不正确</em> <a class="nv nw ep" href="https://medium.com/u/2236cf1a63ba?source=post_page-----ff9d8867a617--------------------------------" rel="noopener" target="_blank"> <em class="nu">普拉莫诺·温纳塔</em> </a> <em class="nu">。</em></p><h1 id="66df" class="mi mj jk bd mk ml mm mn mo mp mq mr ms kz mt la mu lc mv ld mw lf mx lg my mz bi translated">2.确保使用了<a class="ae jh" href="https://dataschool.com/sql-optimization/how-indexing-works/" rel="noopener ugc nofollow" target="_blank">索引</a></h1><p id="d11e" class="pw-post-body-paragraph li lj jk lk b ll na ku ln lo nb kx lq lr nc lt lu lv nd lx ly lz ne mb mc md in bi translated">当查询引擎无法使用索引时，可能会出现问题。这将导致查询速度缓慢。速度的快慢取决于查询所扫描的数据量。当查询引擎无法理解或映射带有表数据定义的搜索值的字符集(在<code class="fe me mf mg mh b">WHERE</code>子句或<code class="fe me mf mg mh b">JOIN</code>中)时，通常会出现问题。在这种情况下，显式类型转换通常会有所帮助。</p><blockquote class="nf"><p id="412b" class="ng nh jk bd ni nj nk nl nm nn no md dk translated">不使用索引时，使用显式强制转换</p></blockquote><p id="4e99" class="pw-post-body-paragraph li lj jk lk b ll np ku ln lo nq kx lq lr nr lt lu lv ns lx ly lz nt mb mc md in bi translated">来自MySQL文档</p><blockquote class="nx ny nz"><p id="f51e" class="li lj nu lk b ll lm ku ln lo lp kx lq oa ls lt lu ob lw lx ly oc ma mb mc md in bi translated"><em class="jk">对于字符串列与数字的比较，MySQL不能使用列上的索引来快速查找值。避免这类问题的一个方法是使用</em> <code class="fe me mf mg mh b"><a class="ae jh" href="https://dev.mysql.com/doc/refman/5.5/en/cast-functions.html#function_cast" rel="noopener ugc nofollow" target="_blank"><em class="jk">CAST()</em></a></code> <em class="jk">。</em></p></blockquote><p id="7a72" class="pw-post-body-paragraph li lj jk lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">所有的数据库都非常相似。问题的严重性取决于任何数据库中查询引擎的实现。</p><h1 id="fcd9" class="mi mj jk bd mk ml mm mn mo mp mq mr ms kz mt la mu lc mv ld mw lf mx lg my mz bi translated">3.明智地使用<a class="ae jh" href="https://dataschool.com/how-to-teach-people-sql/how-sql-subqueries-work/" rel="noopener ugc nofollow" target="_blank">子查询</a></h1><p id="004a" class="pw-post-body-paragraph li lj jk lk b ll na ku ln lo nb kx lq lr nc lt lu lv nd lx ly lz ne mb mc md in bi translated">在许多数据库中，使用子查询会强制将数据复制到磁盘，并且对您的<a class="ae jh" href="https://www.percona.com/blog/2007/08/16/how-much-overhead-is-caused-by-on-disk-temporary-tables/" rel="noopener ugc nofollow" target="_blank">查询数据的计算将发生在磁盘</a>上(数据将被一次又一次地读取和写入磁盘)，而不是内存中。如果发生这种情况，如果数据很大，它会成为一个严重的开销。当这种情况发生时,<a class="ae jh" href="http://norvig.com/21-days.html#answers" rel="noopener ugc nofollow" target="_blank">延迟会成为性能杀手。查看由格蕾丝·赫柏上将制作的关于一纳秒意味着什么的惊人视频。延迟通常以纳秒为单位。</a></p><blockquote class="nf"><p id="45fe" class="ng nh jk bd ni nj nk nl nm nn no md dk translated">当心子查询和磁盘的使用</p></blockquote><p id="b2f8" class="pw-post-body-paragraph li lj jk lk b ll np ku ln lo nq kx lq lr nr lt lu lv ns lx ly lz nt mb mc md in bi translated">事实上，明智地使用任何在磁盘上创建(强制创建)临时表的方法—</p><ul class=""><li id="2642" class="od oe jk lk b ll lm lo lp lr of lv og lz oh md oi oj ok ol bi translated"><code class="fe me mf mg mh b">GROUP BY</code>和<code class="fe me mf mg mh b">ORDER BY</code> —是的，这也会导致数据子集被写入磁盘。在所有数据库中，您可以预定义一块内存(RAM)用于写入查询数据。如果您的数据集很大，并且您的查询数据的子集超过了这个限制，那么它肯定会被写入磁盘并从那里进行管理。</li><li id="fe14" class="od oe jk lk b ll om lo on lr oo lv op lz oq md oi oj ok ol bi translated"><code class="fe me mf mg mh b">JOINS</code> —是的，即使是<code class="fe me mf mg mh b">JOINS</code>也可以将数据写入磁盘，以便进一步检索。一个<code class="fe me mf mg mh b">JOIN</code>本质上是一个<code class="fe me mf mg mh b">SEARCH</code>和<code class="fe me mf mg mh b">MAP</code>操作。</li></ul><h1 id="1d64" class="mi mj jk bd mk ml mm mn mo mp mq mr ms kz mt la mu lc mv ld mw lf mx lg my mz bi translated">4.避免<a class="ae jh" href="https://use-the-index-luke.com/sql/sorting-grouping" rel="noopener ugc nofollow" target="_blank">排序/分类</a>数据</h1><p id="34c3" class="pw-post-body-paragraph li lj jk lk b ll na ku ln lo nb kx lq lr nc lt lu lv nd lx ly lz ne mb mc md in bi translated">排序操作成本极高。每个数据库都有自己的排序算法实现。他们可能使用了传统的排序算法，也可能想出了自己的排序算法。在任何情况下，由于这是一个非常耗费资源的操作，而且还涉及到将数据推入磁盘和从磁盘中取出数据，因此应该谨慎地使用排序。</p><h1 id="66d0" class="mi mj jk bd mk ml mm mn mo mp mq mr ms kz mt la mu lc mv ld mw lf mx lg my mz bi translated">5.不要使用<code class="fe me mf mg mh b"><a class="ae jh" href="https://mode.com/sql-tutorial/sql-like/" rel="noopener ugc nofollow" target="_blank">LIKE</a></code>查询</h1><p id="18b6" class="pw-post-body-paragraph li lj jk lk b ll na ku ln lo nb kx lq lr nc lt lu lv nd lx ly lz ne mb mc md in bi translated">当您长时间查询数据时，传统的关系数据库会导致争用问题。这正是你做<code class="fe me mf mg mh b">LIKE</code>查询时发生的事情。它们会影响整个数据库和其他正在运行的查询的性能。除了使用<code class="fe me mf mg mh b">LIKE</code>，还有其他选择</p><ul class=""><li id="8b60" class="od oe jk lk b ll lm lo lp lr of lv og lz oh md oi oj ok ol bi translated">关系数据库的全文功能。现在几乎所有的数据库都支持全文搜索。</li><li id="ea35" class="od oe jk lk b ll om lo on lr oo lv op lz oq md oi oj ok ol bi translated">如果全文搜索不是一个选项，你可以使用像Elasticsearch，Solr或Algolia这样的全文搜索引擎。它们是为文本分析而设计的。虽然，对于这些新系统，你没有一个像传统数据库那样强大的SQL接口。</li></ul><blockquote class="nf"><p id="c327" class="ng nh jk bd ni nj or os ot ou ov md dk translated">使用关系数据库的全文功能，或者使用类似Elasticsearch的工具进行文本搜索</p></blockquote><h1 id="1924" class="mi mj jk bd mk ml mm mn mo mp mq mr ms kz ow la mu lc ox ld mw lf oy lg my mz bi translated">如果你想成为SQL超人</h1><ul class=""><li id="6ff7" class="od oe jk lk b ll na lo nb lr oz lv pa lz pb md oi oj ok ol bi translated">了解关系数据库的内部结构——数据库如何使用内存和磁盘</li><li id="8d14" class="od oe jk lk b ll om lo on lr oo lv op lz oq md oi oj ok ol bi translated">了解查询的执行顺序——首先评估查询的哪个子句。是<code class="fe me mf mg mh b">JOIN</code>先发生还是<code class="fe me mf mg mh b">WHERE</code>从句先发生还是<code class="fe me mf mg mh b">GROUP BY</code>先发生</li><li id="5314" class="od oe jk lk b ll om lo on lr oo lv op lz oq md oi oj ok ol bi translated">了解查询引擎如何准确解析、估计、优化、重写和执行查询的底层实现细节。</li><li id="26c4" class="od oe jk lk b ll om lo on lr oo lv op lz oq md oi oj ok ol bi translated">了解基于云的关系数据库实现，如Amazon Aurora、Amazon RDS和Azure SQL数据库等等。</li></ul><p id="5f82" class="pw-post-body-paragraph li lj jk lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated"><a class="ae jh" href="https://linktr.ee/kovid" rel="noopener ugc nofollow" target="_blank">这并不是一份详尽的清单</a>。还有更多关于<code class="fe me mf mg mh b">DISTINCT</code>和<code class="fe me mf mg mh b">OR</code>以及<code class="fe me mf mg mh b">EXISTS</code>和<code class="fe me mf mg mh b">IN</code>子句的用法，但我选择的这些似乎是最有问题的，也是最容易修复的。这些只是编写和重写查询时应该记住的一些通用规则。</p></div></div>    
</body>
</html>