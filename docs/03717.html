<html>
<head>
<title>Community detection of the countries of the world with Neo4j Graph Data Science</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Neo4j 图形数据科学对世界各国的社区检测</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/community-detection-of-the-countries-of-the-world-with-neo4j-graph-data-science-4d3a022f8399?source=collection_archive---------15-----------------------#2020-04-07">https://towardsdatascience.com/community-detection-of-the-countries-of-the-world-with-neo4j-graph-data-science-4d3a022f8399?source=collection_archive---------15-----------------------#2020-04-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1163" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用 Neo4j 图形数据科学库进行网络分析，包括要素缩减技术、相似性网络推理和社区检测</h2></div><p id="f8c8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我等待发面的时候，我想，消磨时间的最好方式是使用<a class="ae lb" href="https://github.com/neo4j/graph-data-science" rel="noopener ugc nofollow" target="_blank"> Neo4j 图形数据科学库</a>进行网络分析。嗯，也许还可以试着画一幅丙烯画，但我不会让你厌烦的。如果这是你第一次听说 GDS 图书馆，我可以推荐一些我以前的博客文章，试图解释基本知识:</p><ul class=""><li id="d8ea" class="lc ld iq kh b ki kj kl km ko le ks lf kw lg la lh li lj lk bi translated">GDS <a class="ae lb" rel="noopener" target="_blank" href="/exploring-the-graph-catalog-feature-of-neo4j-graph-data-science-plugin-on-a-lord-of-the-rings-d2de0d0a023">原生投影</a></li><li id="ed64" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated">GDS <a class="ae lb" rel="noopener" target="_blank" href="/how-to-use-cypher-projection-in-neo4j-graph-data-science-library-on-a-lord-of-the-rings-social-b3459138c4f1">赛佛投影</a></li><li id="4c34" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated">GDS <a class="ae lb" rel="noopener" target="_blank" href="/analyzing-multigraphs-in-neo4j-graph-data-science-library-35c9b6d20099">多图投影</a></li></ul><p id="e01f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你准备好了，是时候戴上我们的图形数据科学的帽子，进入正题了。</p><h2 id="626b" class="lq lr iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">要求:</h2><ul class=""><li id="d08e" class="lc ld iq kh b ki mj kl mk ko ml ks mm kw mn la lh li lj lk bi translated"><a class="ae lb" href="https://neo4j.com/" rel="noopener ugc nofollow" target="_blank"> Neo4j </a></li><li id="5fc0" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated"><a class="ae lb" href="https://github.com/neo4j-contrib/neo4j-apoc-procedures" rel="noopener ugc nofollow" target="_blank"> Neo4j APOC 插件</a></li><li id="f39c" class="lc ld iq kh b ki ll kl lm ko ln ks lo kw lp la lh li lj lk bi translated"><a class="ae lb" href="https://github.com/neo4j/graph-data-science" rel="noopener ugc nofollow" target="_blank"> Neo4j 图形数据科学插件</a></li></ul><h2 id="f547" class="lq lr iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">图表模式</h2><p id="b671" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">我们将使用由<a class="ae lb" href="https://www.kaggle.com/fernandol" rel="noopener ugc nofollow" target="_blank"> Fernando Lasso </a>在 Kaggle 上提供的<a class="ae lb" href="https://www.kaggle.com/fernandol/countries-of-the-world/data" rel="noopener ugc nofollow" target="_blank">世界各国</a>数据集。看一下致谢，数据来源于中情局的世界概况。不幸的是，贡献者没有提供数据汇编的年份。我的猜测是 2013 年，但我可能是错的。该数据集包含各种指标，如面积大小、人口、婴儿死亡率以及世界上约 227 个国家的数据。</p><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi mr"><img src="../Images/4ea6411511e3f3a1814dd2a956d4fab1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RgjvVtvoAxfrUd1ejbvc0A.png"/></div></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">图表模式</p></figure><p id="46dc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">图表模式由标记为<em class="nh">国家</em>的节点组成，这些节点将它们的特征存储为属性。一个<em class="nh">国家</em>也是一个<em class="nh">地区</em>的一部分。</p><h2 id="5778" class="lq lr iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">图形导入</h2><p id="acb4" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">首先，我们需要下载数据集，并将其复制到<code class="fe ni nj nk nl b">$Neo4j/import</code>文件夹中。出于某种原因，CSV 文件中的数字使用逗号作为浮点，而不是点(<em class="nh"> 0，1 </em>而不是<em class="nh"> 0.1 </em>)。我们需要对数据进行预处理，以便能够将数字转换为 Neo4j 中的浮点数。在 APOC 过程<code class="fe ni nj nk nl b">apoc.cypher.run</code>的帮助下，我们可以在一个 cypher 查询中预处理和存储数据。<code class="fe ni nj nk nl b">apoc.cypher.run</code>允许我们在主 cypher 查询中运行独立的子查询，非常适合各种用例。</p><pre class="ms mt mu mv gt nm nl nn no aw np bi"><span id="9e82" class="lq lr iq nl b gy nq nr l ns nt">LOAD CSV WITH HEADERS FROM "file:///countries%20of%20the%20world.csv" as row<br/>// cleanup the data and replace comma floating point with a dot<br/>CALL apoc.cypher.run(<br/>    "UNWIND keys($row) as key <br/>     WITH row,<br/>          key,<br/>          toFloat(replace(row[key],',','.')) as clean_value<br/>          // exclude string properties<br/>          WHERE NOT key in ['Country','Region'] <br/>          RETURN collect([key,clean_value]) as keys", <br/>     {row:row}) YIELD value<br/>MERGE (c:Country{name:trim(row.Country)})<br/>SET c+= apoc.map.fromPairs(value.keys)<br/>MERGE (r:Region{name:trim(row.Region)})<br/>MERGE (c)-[:PART_OF]-&gt;(r)</span></pre><h2 id="5018" class="lq lr iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">识别缺失值</h2><p id="f4cc" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">另一个有用的 APOC 程序是<code class="fe ni nj nk nl b">apoc.meta.nodeTypeProperties</code>。有了它，我们可以检查图的节点属性模式。我们将使用它来确定国家的每个要素有多少个缺失值。</p><pre class="ms mt mu mv gt nm nl nn no aw np bi"><span id="ac10" class="lq lr iq nl b gy nq nr l ns nt">// Only look at properties of nodes labeled "Country"<br/>CALL apoc.meta.nodeTypeProperties({labels:['Country']})<br/>YIELD propertyName, propertyObservations, totalObservations<br/>RETURN propertyName,<br/>       (totalObservations - propertyObservations) as missing_value,<br/>       (totalObservations - propertyObservations) / toFloat(totalObservations) as pct_missing_value<br/>ORDER BY pct_missing_value DESC LIMIT 10</span></pre><p id="858e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果</p><figure class="ms mt mu mv gt mw"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="98b0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看起来我们没有太多缺失的值。然而，为了简单起见，我们将在进一步的分析中忽略缺失值超过四个的特性。</p><h2 id="5d65" class="lq lr iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">高相关滤波器</h2><p id="dd69" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">高相关滤波是一种简单的数据降维技术。具有高相关性的特征可能携带相似的信息，并且更加线性相关。使用具有相关信息的多个特征会降低各种模型的性能，可以通过删除两个相关特征中的一个来避免。</p><pre class="ms mt mu mv gt nm nl nn no aw np bi"><span id="f280" class="lq lr iq nl b gy nq nr l ns nt">// Only look at properties of nodes labeled "Country"<br/>CALL apoc.meta.nodeTypeProperties({labels:['Country']})<br/>YIELD propertyName, propertyObservations, totalObservations<br/>WITH propertyName,<br/>       (totalObservations - propertyObservations) as missing_value</span><span id="1db1" class="lq lr iq nl b gy nw nr l ns nt">// filter our features with more than 5 missing values<br/>WHERE missing_value &lt; 5 AND propertyName &lt;&gt; 'name'<br/>WITH collect(propertyName) as features<br/>MATCH (c:Country)<br/>UNWIND features as feature<br/>UNWIND features as compare_feature<br/>WITH feature,<br/>     compare_feature,<br/>     collect(coalesce(c[feature],0)) as vector_1,<br/>     collect(coalesce(c[compare_feature],0)) as vector_2<br/>// avoid comparing with a feature with itself<br/>WHERE feature &lt; compare_feature<br/>RETURN feature,<br/>       compare_feature,<br/>       gds.alpha.similarity.pearson(vector_1, vector_2) AS correlation<br/>ORDER BY correlation DESC LIMIT 10</span></pre><p id="fe7b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果:</p><figure class="ms mt mu mv gt mw"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="ace3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有趣的是出生率和婴儿死亡率密切相关。死亡率也与婴儿死亡率密切相关，因此我们将降低出生率和死亡率，但保持婴儿死亡率。手机数量和净移民似乎与国内生产总值相关。我们也将放弃这两项，保持 GDP 不变。我们还将减少人口，保留面积和人口密度，这两者携带类似的信息。</p><h2 id="be83" class="lq lr iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">特征统计</h2><p id="e577" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">至此，我们只剩下八个特征。我们将用<code class="fe ni nj nk nl b">apoc.agg.statistics</code>函数来检验它们的分布。它计算数值统计，例如一组值的最小值、最大值和百分位数。</p><pre class="ms mt mu mv gt nm nl nn no aw np bi"><span id="b5b6" class="lq lr iq nl b gy nq nr l ns nt">// define excluded features<br/>WITH ['name', <br/>      'Deathrate', <br/>      'Birthrate',<br/>      'Phones (per 1000)',<br/>      'Net migration', <br/>      'Population'] as excluded_features<br/>CALL apoc.meta.nodeTypeProperties({labels:['Country']})<br/>YIELD propertyName, propertyObservations, totalObservations<br/>WITH propertyName,<br/>       (totalObservations - propertyObservations) as missing_value<br/>WHERE missing_value &lt; 5 AND <br/>      NOT propertyName in excluded_features<br/>// Reduce to a single row<br/>WITH collect(propertyName) as potential_features<br/>MATCH (c:Country)<br/>UNWIND potential_features as potential_feature<br/>WITH potential_feature, <br/>     apoc.agg.statistics(c[potential_feature],<br/>                        [0.5,0.75,0.9,0.95,0.99]) as stats<br/>RETURN potential_feature, <br/>       apoc.math.round(stats.min,2) as min, <br/>       apoc.math.round(stats.max,2) as max, <br/>       apoc.math.round(stats.mean,2) as mean, <br/>       apoc.math.round(stats.stdev,2) as stdev,<br/>       apoc.math.round(stats.`0.5`,2) as p50,<br/>       apoc.math.round(stats.`0.75`,2) as p75,<br/>       apoc.math.round(stats.`0.95`,2) as p95,<br/>       apoc.math.round(stats.`0.99`,2) as p99</span></pre><p id="4cea" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果</p><figure class="ms mt mu mv gt mw"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="0123" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">密克罗尼西亚联邦的海岸与面积之比为 870，令人印象深刻。另一方面，世界上共有 44 个国家的海岸线为零。另一个有趣的事实是，格陵兰有 56361 名居民和 2166086 平方英里的人口密度约为每平方英里 0。这可能是一个进行社交距离的好地方。</p><p id="2a42" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以观察到，大多数特征似乎是描述性的，除了其他的(%)，大多数在 80 到 100 之间。由于低方差，我们将在进一步的分析中忽略它。</p><h2 id="0fa1" class="lq lr iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">填充缺少的值</h2><p id="6bb5" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">我们只剩下七个特征，我们将用它们来推断国家之间的相似性网络。在此之前，我们需要做的一件事是填充缺失的值。我们将使用一种简单的方法，用国家所在地区的平均值来填充要素的缺失值。</p><pre class="ms mt mu mv gt nm nl nn no aw np bi"><span id="d5d2" class="lq lr iq nl b gy nq nr l ns nt">UNWIND ["Arable (%)",<br/>        "Crops (%)",<br/>        "Infant mortality (per 1000 births)",<br/>        "GDP ($ per capita)"] as feature<br/>MATCH (c:Country)<br/>WHERE c[feature] IS null<br/>MATCH (c)-[:PART_OF]-&gt;(r:Region)&lt;-[:PART_OF]-(other:Country)<br/>WHERE other[feature] IS NOT null<br/>WITH c,feature,avg(other[feature]) as avg_value<br/>CALL apoc.create.setProperty(c, feature, avg_value) <br/>YIELD node<br/>RETURN distinct 'missing values populated'</span></pre><h2 id="aa34" class="lq lr iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">最小最大归一化</h2><p id="36ef" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">最后但同样重要的是，我们必须将我们的特征标准化，以防止任何单一特征由于较大的规模而支配其他特征。我们将使用标准化的简单的<a class="ae lb" href="https://en.wikipedia.org/wiki/Feature_scaling#Rescaling_(min-max_normalization)" rel="noopener ugc nofollow" target="_blank">最小最大方法</a>在 0 和 1 之间重新调整特征。</p><pre class="ms mt mu mv gt nm nl nn no aw np bi"><span id="3cec" class="lq lr iq nl b gy nq nr l ns nt">UNWIND ["Arable (%)",<br/>        "Crops (%)",<br/>        "Infant mortality (per 1000 births)",<br/>        "GDP ($ per capita)",<br/>        "Coastline (coast/area ratio)",<br/>        "Pop. Density (per sq. mi.)",<br/>        "Area (sq. mi.)"] as feature<br/>MATCH (c:Country)<br/>// Calculate the min and the max value for each feature<br/>WITH max(c[feature]) as max,<br/>     min(c[feature]) as min,<br/>     feature<br/>MATCH (c1:Country)<br/>WITH c1,<br/>    // define property name to store back results <br/>    "n_" + feature AS newKey,<br/>    // normalize values<br/>    (toFloat(c1[feature]) - min) / (max - min) as normalized_value</span><span id="570f" class="lq lr iq nl b gy nw nr l ns nt">// store results to properties<br/>CALL apoc.create.setProperty(c1, newKey, normalized_value) <br/>YIELD node<br/>RETURN distinct 'normalization done'</span></pre><h2 id="073a" class="lq lr iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">余弦相似的相似网络</h2><p id="8de4" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">我们已经完成了数据预处理，可以专注于数据分析部分。分析的第一步是借助于<a class="ae lb" href="https://neo4j.com/docs/graph-data-science/1.0/alpha-algorithms/cosine/" rel="noopener ugc nofollow" target="_blank">余弦相似性算法</a>推断相似性网络。我们基于所选特征为每个国家构建一个向量，并比较每对国家之间的余弦相似性。如果相似性高于预定义的阈值，我们以相似节点对之间的关系的形式存储回结果。定义一个最佳阈值是艺术和科学的结合，通过实践你会做得更好。理想情况下，您想要推断一个稀疏图，因为社区检测算法在<a class="ae lb" href="https://en.wikipedia.org/wiki/Complete_graph" rel="noopener ugc nofollow" target="_blank">完整</a>或<a class="ae lb" href="https://en.wikipedia.org/wiki/Dense_graph" rel="noopener ugc nofollow" target="_blank">密集</a>图上表现不佳。在这个例子中，我们将使用 0.8 的<code class="fe ni nj nk nl b">similarityCutoff</code>值(范围在-1 和 1 之间)。除了相似性阈值，我们还将使用<code class="fe ni nj nk nl b">topK</code>参数来仅存储前 10 个相似的邻居。我们这样做是为了确保图形更稀疏。</p><pre class="ms mt mu mv gt nm nl nn no aw np bi"><span id="922f" class="lq lr iq nl b gy nq nr l ns nt">MATCH (c:Country)</span><span id="3788" class="lq lr iq nl b gy nw nr l ns nt">// build the vector from features<br/>WITH id(c) as id, [c["n_Arable (%)"],<br/>                   c["n_Crops (%)"],<br/>                   c["n_Infant mortality (per 1000 births)"],<br/>                   c["n_GDP ($ per capita)"],<br/>                   c["n_Coastline (coast/area ratio)"],<br/>                   c["n_Pop. Density (per sq. mi.)"],<br/>                   c["n_Area (sq. mi.)"]] as weights<br/>WITH {item:id, weights: weights} as countryData<br/>WITH collect(countryData) as data<br/>CALL gds.alpha.similarity.cosine.write({<br/>    nodeProjection: '*',<br/>    relationshipProjection: '*',<br/>    similarityCutoff:0.8,<br/>    topK:10,<br/>    data: data})<br/>YIELD nodes, similarityPairs<br/>RETURN nodes, similarityPairs</span></pre><h2 id="d2fd" class="lq lr iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">图形数据科学图书馆</h2><p id="db4f" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">借助 Neo4j 的<a class="ae lb" href="https://github.com/neo4j/graph-data-science" rel="noopener ugc nofollow" target="_blank">图形数据科学库</a>，我们可以直接在 Neo4j 中运行 30 多种不同的图形算法。算法被公开为密码程序，类似于我们上面看到的 APOC 程序。</p><p id="1311" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">GDS 使用存储图形的投影，这完全是在内存中实现更快的执行时间。我们可以利用<code class="fe ni nj nk nl b">gdn.graph.create</code>过程来投影存储图的视图。关于 GDS 图形投影的更多细节，请查看我在<a class="ae lb" rel="noopener" target="_blank" href="/exploring-the-graph-catalog-feature-of-neo4j-graph-data-science-plugin-on-a-lord-of-the-rings-d2de0d0a023">之前的博文</a>。在本例中，我们将投影标签为 Country 且关系类型为 SIMILAR 的节点。</p><pre class="ms mt mu mv gt nm nl nn no aw np bi"><span id="3465" class="lq lr iq nl b gy nq nr l ns nt">CALL gds.graph.create('similarity_network','Country','SIMILAR');</span></pre><h2 id="ffdd" class="lq lr iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">弱连通分量</h2><p id="d198" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">通常，我们用<a class="ae lb" href="https://neo4j.com/docs/graph-data-science/1.0/algorithms/wcc/" rel="noopener ugc nofollow" target="_blank">弱连接成分</a>算法开始图形分析。这是一种社区检测算法，用于在我们的图中找到断开的网络或孤岛。因为我们只对断开组件的计数感兴趣，所以我们可以运行算法的<code class="fe ni nj nk nl b">stats</code>变体。</p><pre class="ms mt mu mv gt nm nl nn no aw np bi"><span id="4332" class="lq lr iq nl b gy nq nr l ns nt">CALL gds.wcc.stats('similarity_network')<br/>YIELD componentCount, componentDistribution<br/>RETURN componentCount, <br/>       componentDistribution.min as min,<br/>       componentDistribution.max as max,<br/>       componentDistribution.mean as mean,<br/>       componentDistribution.p50 as p50,<br/>       componentDistribution.p75 as p75,<br/>       componentDistribution.p90 as p90</span></pre><p id="f05c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果</p><figure class="ms mt mu mv gt mw"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="d79e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该算法在我们的图中只找到了一个组件。这是一个有利的结果，因为断开的岛会扭曲各种其他图算法的结果。</p><h2 id="63ec" class="lq lr iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">卢万算法</h2><p id="1093" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">另一种社区检测算法是<a class="ae lb" href="https://neo4j.com/docs/graph-data-science/1.0/algorithms/louvain/" rel="noopener ugc nofollow" target="_blank"> Louvain 算法</a>。用基本术语来说，密集连接的节点更有可能形成社区。它依靠模块化优化来提取社区。模块化优化分两步进行。第一步包括局部优化模块化。在第二步中，它将属于同一社区的节点聚合到单个节点中，并从这些聚合的节点构建新的网络。这两个步骤反复重复，直到获得最大的模块化。这些迭代的一个微妙的副作用是，我们可以在每次迭代结束时查看社区结构，因此 Louvain 算法被视为分层社区检测算法。要包含分层社区结果，我们必须将<code class="fe ni nj nk nl b">includeIntermediateCommunities</code>参数值设置为 true。</p><pre class="ms mt mu mv gt nm nl nn no aw np bi"><span id="b798" class="lq lr iq nl b gy nq nr l ns nt">CALL gds.louvain.write('similarity_network',  <br/>    {maxIterations:20,<br/>     includeIntermediateCommunities:true,<br/>     writeProperty:'louvain'})<br/>YIELD ranLevels, communityCount,modularity,modularities</span></pre><p id="e0b4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果</p><figure class="ms mt mu mv gt mw"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="ba66" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过<code class="fe ni nj nk nl b">ranLevels</code>值观察到，Louvain 算法在我们的网络中发现了两个层次的社区。在最后一层，它发现了八个组。我们现在可以检查最后一级的提取社区，并比较它们的特征平均值。</p><pre class="ms mt mu mv gt nm nl nn no aw np bi"><span id="485c" class="lq lr iq nl b gy nq nr l ns nt">MATCH (c:Country)<br/>RETURN c.louvain[-1] as community,<br/>       count(*) as community_size,<br/>       avg(c['Arable (%)']) as pct_arable,<br/>       avg(c['Crops (%)']) as pct_crops, <br/>       avg(c['Infant mortality (per 1000 births)']) as infant_mortality,<br/>       avg(c['GDP ($ per capita)']) as gdp,<br/>       avg(c['Coastline (coast/area ratio)']) as coastline,<br/>       avg(c['Pop. Density (per sq. mi.)']) as population_density,<br/>       avg(c['Area (sq. mi.)']) as area_size,<br/>       collect(c['name'])[..3] as example_members<br/>ORDER BY gdp DESC</span></pre><p id="2e4a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果</p><figure class="ms mt mu mv gt mw"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="cccd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Louvain 算法在相似性网络中找到了八个不同的社区。最大的组织有 51 个成员国，平均 GDP 最高，接近 22，000 美元。它们在婴儿死亡率和海岸线比例上位居第二，但在人口密度上遥遥领先。有两个社区的平均 GDP 在 2 万美元左右，然后我们可以观察到第三名的 GDP 急剧下降到 7000 美元。随着 GDP 的下降，我们还可以发现婴儿死亡率的上升几乎是线性的。另一个有趣的发现是，大多数更贫困的社区几乎没有海岸线。</p><h2 id="0bb6" class="lq lr iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">使用 PageRank 查找社区代表</h2><p id="620c" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">我们可以使用 PageRank 算法来评估最终级别社区的顶级代表。如果我们假设每个<em class="nh">相似的</em>关系都是国家间相似度的投票，<a class="ae lb" href="https://neo4j.com/docs/graph-data-science/1.0/algorithms/page-rank/" rel="noopener ugc nofollow" target="_blank"> PageRank </a>算法会给社区内最相似的国家分配最高分。我们将对每个社区分别执行 PageRank 算法，并且只考虑给定社区中的节点和关系。这可以通过<a class="ae lb" href="https://neo4j.com/docs/graph-data-science/1.0/management-ops/cypher-projection/" rel="noopener ugc nofollow" target="_blank">密码投影</a>轻松实现，无需任何额外的变换。</p><pre class="ms mt mu mv gt nm nl nn no aw np bi"><span id="cd58" class="lq lr iq nl b gy nq nr l ns nt">WITH 'MATCH (c:Country) WHERE c.louvain[-1] = $community <br/>      RETURN id(c) as id' as nodeQuery,<br/>     'MATCH (s:Country)-[:SIMILAR]-&gt;(t:Country) <br/>      RETURN id(s) as source, id(t) as target' as relQuery<br/>MATCH (c:Country)<br/>WITH distinct c.louvain[-1] as community, nodeQuery, relQuery<br/>CALL gds.pageRank.stream({nodeQuery:nodeQuery,<br/>                          relationshipQuery:relQuery, <br/>                          parameters:{community:community},<br/>                          validateRelationships:False})<br/>YIELD nodeId, score<br/>WITH community, nodeId,score<br/>ORDER BY score DESC<br/>RETURN community, <br/>       collect(gds.util.asNode(nodeId).name)[..5] as top_5_representatives</span></pre><p id="d8a7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果</p><figure class="ms mt mu mv gt mw"><div class="bz fp l di"><div class="nu nv l"/></div></figure><h2 id="9122" class="lq lr iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">使用 Gephi 实现网络可视化</h2><p id="ccc9" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">优秀的可视化胜过千言万语。Gephi 是一个创建网络可视化的伟大工具。正如我们现在可能预期的那样，APOC 提供了一个方便的程序<code class="fe ni nj nk nl b">apoc.gephi.add</code>,可以将网络数据从 Neo4j 无缝地传输到 Gephi。在<a class="ae lb" href="https://neo4j.com/docs/labs/apoc/current/export/gephi/" rel="noopener ugc nofollow" target="_blank">文档</a>或我的<a class="ae lb" href="https://tbgraph.wordpress.com/2017/04/01/neo4j-to-gephi/" rel="noopener ugc nofollow" target="_blank">前一篇博文</a>中找到更多信息。</p><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nx"><img src="../Images/9893e9da26e1f27874b5adada9d18439.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H-ZKR68IIHl-2ayzSQ22Sw.png"/></div></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">节点颜色表示社区，节点大小表示 GDP，文本大小表示社区 PageRank 值</p></figure><p id="d1bf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们之前观察到的，我们的网络中有八个不同的社区。平均 GDP 最高的社区在右上角，平均 GDP 最高到最低的国家按顺时针方向排列。我发现一个有趣的三角形正好位于俄罗斯、中国和巴西形成的图像中间。此外，如果你仔细观察，你会发现巴拿马是红色社区的一部分，但位于中间。这是因为它与大多数社区中的一两个国家有类似的关系，但与红色社区中的三个国家有关系，因此属于红色社区。</p><h2 id="02a7" class="lq lr iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">基于 Louvain 算法的层次社区</h2><p id="f8f9" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">我们之前提到过，Louvain 算法可用于查找带有<code class="fe ni nj nk nl b">includeIntermediateCommunities</code>参数的分层社区，在我们的示例中，它找到了两个级别的社区。我们现在将考察第一层次的国家集团。一条经验法则是，较低级别的社区将更细粒度、更小。</p><pre class="ms mt mu mv gt nm nl nn no aw np bi"><span id="d25c" class="lq lr iq nl b gy nq nr l ns nt">MATCH (c:Country)<br/>RETURN c.louvain[0] as community,<br/>       count(*) as community_size,<br/>       avg(c['Arable (%)']) as pct_arable,<br/>       avg(c['Crops (%)']) as pct_crops, <br/>       avg(c['Infant mortality (per 1000 births)']) as infant_mortality,<br/>       avg(c['GDP ($ per capita)']) as gdp,<br/>       avg(c['Coastline (coast/area ratio)']) as coastline,<br/>       avg(c['Pop. Density (per sq. mi.)']) as population_density,<br/>       avg(c['Area (sq. mi.)']) as area_size,<br/>       collect(c['name'])[..3] as example_members<br/>ORDER BY gdp DESC</span></pre><p id="9a55" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果</p><figure class="ms mt mu mv gt mw"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="790d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不出所料，第一层的社区数量几乎是第二层(也是最后一层)的两倍。一个激动人心的社区由平均 GDP 排在第二位。它只包含五个国家，这些国家很小，平均面积只有 364 平方英里。另一方面，他们有很高的人口密度，大约每平方英里 10000 人。例如澳门、摩纳哥和香港。</p><h2 id="45e9" class="lq lr iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">Neo4j Bloom 的图形探索</h2><p id="0a41" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">另一个非常好的网络可视化工具是<a class="ae lb" href="https://neo4j.com/bloom/" rel="noopener ugc nofollow" target="_blank"> Neo4j Bloom </a>。它提供了定制图形透视图和搜索查询的能力，没有任何 cypher 查询语言技能的人可以使用它来探索和搜索图形中的见解。如果你有兴趣了解更多，可以查看<a class="ae lb" href="https://twitter.com/lyonwj" rel="noopener ugc nofollow" target="_blank">威廉·里昂</a>写的<a class="ae lb" href="https://medium.com/neo4j/hands-on-with-the-neo4j-graph-data-science-sandbox-7b780be5a44f" rel="noopener">这篇博文</a>。</p><p id="5c57" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将看看最后一组 GDP 最高的国家。它是一个由 51 个国家组成的共同体，在第一层级上有四个不同的共同体。</p><figure class="ms mt mu mv gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi ny"><img src="../Images/410c528b7a299273ae76938c10edb054.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ItbzAkHzQWfFRaFr7BnaVg.png"/></div></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">节点颜色表示一级社区，节点大小表示 GDP</p></figure><p id="c96d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">之前，我们提到了一个令人兴奋的社区，由五个人口密度极高的小国组成。在这个图像中，它们被涂成红色。蓝色社区的平均 GDP 比黄色社区高 25%左右，婴儿死亡率几乎是黄色社区的一半。另一方面，黄色社区平均比蓝色社区有更多的海岸线。</p><h1 id="5eec" class="nz lr iq bd ls oa ob oc lv od oe of ly jw og jx mb jz oh ka me kc oi kd mh oj bi translated">结论</h1><p id="f4f8" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">Neo4j 生态系统非常适合执行和可视化网络分析。<a class="ae lb" href="https://github.com/neo4j/graph-data-science" rel="noopener ugc nofollow" target="_blank">图形数据科学库</a>是生态系统的一个实用补充，允许我们运行各种图形算法并执行图形分析，而没有太多麻烦。你可以在你的电脑上试用，也可以创建一个<a class="ae lb" href="https://neo4j.com/sandbox/" rel="noopener ugc nofollow" target="_blank"> Neo4j 沙盒</a>账户，几分钟内就可以开始使用。</p><p id="a876" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">和往常一样，代码可以在<a class="ae lb" href="https://github.com/tomasonjo/blogs/blob/master/Countries_of_the_world/Countries%20of%20the%20world%20analysis.ipynb" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。</p></div></div>    
</body>
</html>