<html>
<head>
<title>tf.data: Creating data input pipelines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">tf.data:创建数据输入管道</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/tf-data-creating-data-input-pipelines-2913461078e2?source=collection_archive---------29-----------------------#2020-04-08">https://towardsdatascience.com/tf-data-creating-data-input-pipelines-2913461078e2?source=collection_archive---------29-----------------------#2020-04-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="005c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你不能把你的数字数据载入内存吗？您的模型是否必须在每个时期后等待数据加载？<br/>你的 Keras DataGenerator 慢吗？</p><p id="3dfc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">tensor flow<a class="ae ko" href="https://www.tensorflow.org/api_docs/python/tf/data" rel="noopener ugc nofollow" target="_blank"><strong class="js iu"><em class="kp">TF . data</em></strong></a>API 允许构建复杂的输入管道。它可以轻松处理大量数据，可以读取不同格式的数据，同时允许复杂的数据转换。</p><h1 id="2fb0" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">我们为什么需要 tf.data？</h1><p id="0b25" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">一个训练步骤包括以下步骤:<br/> 1。文件读取<br/> 2。获取或解析数据<br/> 3。数据转换<br/> 4。使用数据来训练模型。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi lt"><img src="../Images/517e5dad734c9eb64dae56f9cd44a6ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wm8r4SSP2FjKXDu3H4swUA.png"/></div></div><p class="mf mg gj gh gi mh mi bd b be z dk translated">来源:<a class="ae ko" href="https://www.tensorflow.org/guide/data_performance" rel="noopener ugc nofollow" target="_blank">张量流</a> (CC0)</p></figure><p id="6aea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你有大量的数据，而你无法将它加载到内存中，你可能想要使用<a class="ae ko" href="https://www.tensorflow.org/guide/data#consuming_python_generators" rel="noopener ugc nofollow" target="_blank">生成器</a>。但是生成器的可移植性和可伸缩性有限。<br/>在每个时期之后，您将等待模型将数据转换成可消费的格式，在此期间，您的模型处于闲置状态，不进行任何训练。这导致 CPU 和 GPU 利用率低。<br/>处理这个问题的一个解决方案是<a class="ae ko" href="https://www.tensorflow.org/guide/data_performance#prefetching" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">预先预取</strong> </a>您的数据，这样您就不必等待数据被加载。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi mj"><img src="../Images/609c6cc1a447d5c598cf8ff054be07fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7ijyt5E5XvQs23I0dD2GhA.png"/></div></div><p class="mf mg gj gh gi mh mi bd b be z dk translated">来源:<a class="ae ko" href="https://www.tensorflow.org/guide/data_performance" rel="noopener ugc nofollow" target="_blank">张量流</a> (CC0)</p></figure><p id="b2b7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">tf.data 是一个数据输入管道构建 API，您可以使用它来轻松构建您的数据管道。无论您是想从本地文件中读取数据，还是远程存储数据。</p><h1 id="a86f" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">加载分类数据</h1><p id="762a" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">为了训练图像分类模型，我们创建了一个 CNN 模型，并将我们的数据提供给该模型。我想训练一个猫和狗的分类器，我的数据存储在下面的文件夹结构中。</p><pre class="lu lv lw lx gt mk ml mm mn aw mo bi"><span id="8f33" class="mp kr it ml b gy mq mr l ms mt"><em class="kp">data<br/>└── train<br/>    ├── cat -&gt; contains images of cats<br/>    └── dog -&gt; contains images of dogs</em></span></pre><p id="6f4b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="kp">我们首先找到所有图像的路径——</em></p><pre class="lu lv lw lx gt mk ml mm mn aw mo bi"><span id="d772" class="mp kr it ml b gy mq mr l ms mt">from glob import glob<br/>import tensorflow as tf</span><span id="8975" class="mp kr it ml b gy mu mr l ms mt">image_path_list = glob('data/train/*/*.jpg')<br/>data = tf.data.Dataset.list_files(image_path_list)</span></pre><p id="4be8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">TF . data . Dataset . list _ files</strong>将 glob 方法返回的列表转换为 Dataset 对象。现在，我们将加载图像和它们的类。</p><pre class="lu lv lw lx gt mk ml mm mn aw mo bi"><span id="e43b" class="mp kr it ml b gy mq mr l ms mt">def load_images(path):<br/>    <br/>    image = tf.io.read_file(path)<br/>    image = tf.io.decode_image(image)<br/>    label = tf.strings.split(path, os.path.sep)[-2]</span><span id="0920" class="mp kr it ml b gy mu mr l ms mt">    return image, label</span><span id="24d8" class="mp kr it ml b gy mu mr l ms mt">data = data.map(load_images)</span></pre><p id="4acf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">于是，<strong class="js iu"> <em class="kp">数据</em> </strong>对象现在有了图像和标签。但这不是它，我们将不得不调整图像的大小，预处理和应用转换。</p><pre class="lu lv lw lx gt mk ml mm mn aw mo bi"><span id="9810" class="mp kr it ml b gy mq mr l ms mt">def preprocess(image, label):<br/>    image = tf.image.resize(image, (IMG_HEIGHT, IMG_WIDTH))<br/>    image = tf.image.random_flip_left_right(image)<br/>    image = tf.image.random_flip_up_down(image)</span><span id="57ff" class="mp kr it ml b gy mu mr l ms mt">    image /= 255.<br/>    image -= 0.5</span><span id="6616" class="mp kr it ml b gy mu mr l ms mt">    return image, label</span><span id="11d2" class="mp kr it ml b gy mu mr l ms mt">data = data.map(preprocess)</span></pre><p id="7cfe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我基于<em class="kp"> tf.data </em>创建了一个名为<a class="ae ko" href="https://github.com/aniketmaurya/chitra" rel="noopener ugc nofollow" target="_blank"><strong class="js iu"><em class="kp">Chitra</em></strong></a><strong class="js iu"><em class="kp"/></strong>的小库，可以用来跳过所有这些步骤。</p><pre class="lu lv lw lx gt mk ml mm mn aw mo bi"><span id="7cb6" class="mp kr it ml b gy mq mr l ms mt">from chitra import dataloader as dl<br/>path = './data/train'</span><span id="47c9" class="mp kr it ml b gy mu mr l ms mt">train_dl = dl.Clf()<br/>data = train_dl.from_folder(path, target_shape=(224, 244), shuffle = True)</span><span id="428d" class="mp kr it ml b gy mu mr l ms mt"># to visualize the data<br/>train_dl.show_batch(6, figsize=(6,6))</span></pre><p id="0ebc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">您只需指定数据的路径，它就会以目标大小加载。</strong></p></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/12de8f07e813261faa9f0fc43dd9fa63.png" data-original-src="https://miro.medium.com/v2/resize:fit:664/format:webp/1*RSmpjnP9xKHV8Y22IRn9pA.png"/></div></figure><blockquote class="nd"><p id="f690" class="ne nf it bd ng nh ni nj nk nl nm kn dk translated"><em class="nn">你可以在</em><a class="ae ko" href="https://github.com/aniketmaurya/chitra" rel="noopener ugc nofollow" target="_blank"><em class="nn">https://github.com/aniketmaurya/chitra</em></a>找到我的代码</p></blockquote></div></div>    
</body>
</html>