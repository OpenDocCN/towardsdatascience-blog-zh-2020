<html>
<head>
<title>Custom Iteration Patterns with Python Generators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python生成器定制迭代模式</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/custom-iteration-patterns-with-python-generators-12b98e552b38?source=collection_archive---------32-----------------------#2020-05-08">https://towardsdatascience.com/custom-iteration-patterns-with-python-generators-12b98e552b38?source=collection_archive---------32-----------------------#2020-05-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fe7c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">创建定制迭代模式</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5e0cc26fe3d702aac8740094327f74f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sIlSOdhIq3yL39YujCNklw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://www.pexels.com/photo/abstract-art-background-blue-430207/" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="bc5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python有几个内置的迭代模式，比如由“range()”和“reversed()”方法提供的那些模式。“range()”方法接受“start”和“stop”参数，并返回一个我们可以迭代的不可变序列。“reverse()”方法接受一个输入序列并返回反向迭代器。假设我们想要实现一个定制的迭代模式，其行为与这些内置函数不同。在这篇文章中，我们将讨论如何在python中实现定制迭代模式。</p><p id="c199" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们开始吧！</p><p id="ed3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们创建一个迭代模式，它产生一个不断增加的浮动范围。该函数将接受“开始”、“停止”和“增量”参数:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="6d51" class="ma mb it lw b gy mc md l me mf">def increment_pattern(start, stop, increment):</span></pre><p id="5c64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将初始化将要增加的变量，<em class="mg"> x </em>:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="2101" class="ma mb it lw b gy mc md l me mf">def increment_pattern(start, stop, increment):<br/>    x = start</span></pre><p id="e6d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们写一个控制流条件，这样，只要一个<em class="mg"> x </em>小于或等于“停止”输入值，随后的任何过程都将继续:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="aa49" class="ma mb it lw b gy mc md l me mf">def increment_pattern(start, stop, increment):<br/>    x = start<br/>    while x &lt; stop:</span></pre><p id="6493" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于我们想编写一个定制的迭代模式，类似于' range()'，我们想返回一个生成器。我们使用“yield”关键字来实现这一点:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="5a9a" class="ma mb it lw b gy mc md l me mf">def increment_pattern(start, stop, increment):<br/>    x = start<br/>    while x &lt; stop:<br/>        yield x</span></pre><p id="b63b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们增加值，<em class="mg"> x </em>:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="37a7" class="ma mb it lw b gy mc md l me mf">def increment_pattern(start, stop, increment):<br/>    x = start<br/>    while x &lt;= stop:<br/>        yield x<br/>        x += increment</span></pre><p id="5093" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以在“for-loop”中调用我们的生成器，并迭代值。让我们传入‘开始’= 0，‘停止’= 3，让我们递增0.5:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="f2ec" class="ma mb it lw b gy mc md l me mf">for value in increment_pattern(0, 3, 0.5):<br/>    print(value)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/5c3e6fa3ef97a89d46e5f1ed6c255b46.png" data-original-src="https://miro.medium.com/v2/resize:fit:128/format:webp/1*Uy5A_RFVWTMlWFhUnYRkFQ.png"/></div></figure><p id="65fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以定义一个递减模式。让我们定义一个新的函数并改变while循环条件，使x大于或等于‘stop’值。让我们也反复减去减量值:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="1537" class="ma mb it lw b gy mc md l me mf">def decrement_pattern(start, stop, decrement):<br/>    x = start<br/>    while x &gt;= stop:<br/>        yield x<br/>        x -= decrement</span></pre><p id="9448" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在“for-loop”内的函数调用中，让我们交换start和stop的值，并递减0.5:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="6f5d" class="ma mb it lw b gy mc md l me mf">for value in decrement_pattern(3, 0, 0.5):<br/>    print(value)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/db9a57974edc50d95ddfc705163f09ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:114/format:webp/1*xhHma7D9HjW3FejcDOASUA.png"/></div></figure><p id="a51c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们来看一个更实际的例子。让我们使用一个定制的迭代模式来生成一个对应于指数增长函数的值列表。具体来说，让我们考虑复利的例子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/9133fbfa2833c2adfa2c615f3f4f837a.png" data-original-src="https://miro.medium.com/v2/resize:fit:542/format:webp/1*UWY15N6eTLJObjQ7wjmZYA@2x.png"/></div></figure><p id="200b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">等式中的各项如下:</p><ol class=""><li id="d067" class="mk ml it lb b lc ld lf lg li mm lm mn lq mo lu mp mq mr ms bi translated"><strong class="lb iu"> A </strong>表示经过一段时间后的金额</li><li id="4cd2" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated"><strong class="lb iu"> P </strong>代表原则，也就是你开始的钱数</li><li id="9252" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated"><strong class="lb iu"> r </strong>代表利率</li><li id="5804" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated"><strong class="lb iu"> n </strong>是复利的倍数</li><li id="04d4" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated">代表以年为单位的时间量</li></ol><p id="d48b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设你出生时在一个储蓄账户里有1000美元，你想计算你每年会有多少钱，直到你年满18岁，每月复利8%。让我们定义我们的复利函数。这里，我们将原则初始化为开始时的1000美元。我们还将年份<em class="mg"> t </em>初始化为“开始”值。我们还写下了这样一个条件:当年份<em class="mg"> t，</em>小于‘停止’时，我们将递增:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="6a14" class="ma mb it lw b gy mc md l me mf">def compound_interest_monthly(start, stop, increment):<br/>    t= start<br/>    principle = 1000<br/>    while t &lt; stop:</span></pre><p id="4b5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们定义等式中的利息部分:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="c85d" class="ma mb it lw b gy mc md l me mf">def compound_interest_monthly(start, stop, increment):<br/>    ...<br/>        interest = (1+ 0.08/12)**(12*t)</span></pre><p id="0a2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们返回生成器并增加我们的年份:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="bb37" class="ma mb it lw b gy mc md l me mf">def compound_interest_monthly(start, stop, increment):<br/>    ...<br/>        interest = (1+ 0.08/12)**(12*t)<br/>        yield principle*interest<br/>        t+= increment</span></pre><p id="af95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总功能如下:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="0595" class="ma mb it lw b gy mc md l me mf">def compound_interest_monthly(start, stop, increment):<br/>    t= start<br/>    principle = 1000<br/>    while t&lt; stop:<br/>        interest = (1+ 0.08/12)**(12*t)<br/>        yield principle*interest<br/>        t+= increment</span></pre><p id="f276" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们称我们的生成器为“for-loop ”,其中“start ”= 0年,“stop ”= 19年，每年递增:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="2106" class="ma mb it lw b gy mc md l me mf">for value in compound_interest_monthly(0, 19, 1):<br/>    print(value)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi my"><img src="../Images/1d73bf0ff086005aa1940190d1a7679e.png" data-original-src="https://miro.medium.com/v2/resize:fit:534/format:webp/1*uIsydGmGNlm-R325hbo0Fw.png"/></div></figure><p id="f505" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看复利，从相同的原则开始，在相同的时间段内，以4%的利率按季度复利计算:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="2a16" class="ma mb it lw b gy mc md l me mf">def compound_interest_quarterly(start, stop, increment):<br/>    t= start<br/>    principle = 1000<br/>    while t&lt; stop:<br/>        interest = (1+ 0.04/4)**(4*t)<br/>        yield principle*interest<br/>        t+= increment</span></pre><p id="7402" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们迭代我们的生成器:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="f5a0" class="ma mb it lw b gy mc md l me mf">for value in compound_interest_quarterly(0, 19, 1):<br/>    print(value)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/534cee59b513f9540926c82c9bdd9d46.png" data-original-src="https://miro.medium.com/v2/resize:fit:540/format:webp/1*lEXHshLliQk5yCx6VxOUUA.png"/></div></figure><p id="bc9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我就讲到这里，但是您可以自己随意摆弄代码。</p><h1 id="b5ba" class="na mb it bd nb nc nd ne nf ng nh ni nj jz nk ka nl kc nm kd nn kf no kg np nq bi translated">结论</h1><p id="f7ae" class="pw-post-body-paragraph kz la it lb b lc nr ju le lf ns jx lh li nt lk ll lm nu lo lp lq nv ls lt lu im bi translated">总之，在这篇文章中，我们讨论了如何用python中的生成器定义定制迭代模式。我们创建了定制的递增和递减迭代模式，允许我们生成一系列的浮点。然后我们开发了一个更实用的定制迭代模式来计算复利。我希望你觉得这篇文章有趣/有用。这篇文章中的代码可以在<a class="ae ky" href="https://github.com/spierre91/medium_code/blob/master/basic_python/custom_iterators.py" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。感谢您的阅读！</p></div></div>    
</body>
</html>