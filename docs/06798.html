<html>
<head>
<title>Build predictive Business Intelligence with Google Colab, Google Data Studio and Google Sheets</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Google Colab、Google Data Studio和Google Sheets构建预测性商业智能</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/build-predictive-business-intelligence-with-google-colab-google-data-studio-and-google-sheets-9a5c1559124f?source=collection_archive---------28-----------------------#2020-05-27">https://towardsdatascience.com/build-predictive-business-intelligence-with-google-colab-google-data-studio-and-google-sheets-9a5c1559124f?source=collection_archive---------28-----------------------#2020-05-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="62ac" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">基于免费Google服务的预测性BI解决方案的实验结果</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4b0e43d15ad7a1389dbcc414a4c57f46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BoHiHHUmb5YhKMrYUlb9DA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片作者:Rostyslav Neskorozhenyi</p></figure><p id="c55b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们许多人习惯于认为商业智能是大公司使用的东西，是用昂贵且通常难以学习的工具创建的(尽管也有令人愉快的例外，如<a class="ae lu" href="https://www.metabase.com/" rel="noopener ugc nofollow" target="_blank">元数据库</a>和<a class="ae lu" href="https://superset.incubator.apache.org/" rel="noopener ugc nofollow" target="_blank">超集</a>)。在我的文章中，我想展示几乎每个人都可以使用商业智能的力量，甚至可以通过普遍可用和免费的在线工具为其添加一些预测分析，如<a class="ae lu" href="https://colab.research.google.com/" rel="noopener ugc nofollow" target="_blank">谷歌Colab </a>和<a class="ae lu" href="https://datastudio.google.com/" rel="noopener ugc nofollow" target="_blank">谷歌数据工作室</a>。不需要部署数据库。所有用于分析和可视化的数据，我们将存储在谷歌表。</p><p id="1a3b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将在Google Colab中实现一个机器学习模型，根据产品的销售历史，我们将能够预测未来几个月的销售情况，并在Google Data Studio中可视化我们的预测。</p><p id="caf4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将使用包含产品列表信息和每种产品12个月的销售历史的数据集。</p><p id="7e89" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该模型将分析每个月的销售历史和产品功能的变化，因此任何变化都会动态地影响模型预测。这将使我们能够迅速评估某些决定的后果，并采取最佳发展战略。</p><h1 id="6596" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">加载数据</h1><p id="1b25" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">我们认为，我们在Google Colab中的所有操作。首先，我们将使用<strong class="la iu"> kaggle </strong>模块下载所需的数据集。你可以通过这个<a class="ae lu" href="https://github.com/Kaggle/kaggle-api" rel="noopener ugc nofollow" target="_blank">链接</a>阅读更多关于模块和如何获得Kaggle API令牌的细节。</p><blockquote class="ms mt mu"><p id="f91c" class="ky kz mv la b lb lc ju ld le lf jx lg mw li lj lk mx lm ln lo my lq lr ls lt im bi translated"><strong class="la iu">数据集描述:</strong><a class="ae lu" href="https://www.kaggle.com/c/online-sales/data" rel="noopener ugc nofollow" target="_blank"><strong class="la iu">https://www.kaggle.com/c/online-sales/data</strong></a><strong class="la iu">。</strong></p></blockquote><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="fc40" class="ne lw it na b gy nf ng l nh ni">!pip install kaggle</span></pre><p id="3b95" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于我们正在使用Google Colab，我们将连接到Google Drive来复制Kaggle凭据。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="f965" class="ne lw it na b gy nf ng l nh ni">from google.colab import drive<br/>drive.mount(‘/content/drive/’)</span></pre><p id="9009" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">用保存的凭证设置一个工作目录(在我们的例子中，该目录称为“Colab笔记本”)。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="90db" class="ne lw it na b gy nf ng l nh ni">import os<br/>os.chdir(“/content/drive/My Drive/Colab Notebooks”)</span></pre><p id="03b5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">复制Kaggle API的凭据。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="c052" class="ne lw it na b gy nf ng l nh ni">import os<br/>os.chdir(“/content/drive/My Drive/Colab Notebooks”)</span></pre><p id="eb5a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下载数据集。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="48e9" class="ne lw it na b gy nf ng l nh ni">!kaggle competitions download -c online-sales</span></pre><p id="e79e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">将数据集加载到内存中，并用零替换空值。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="28dc" class="ne lw it na b gy nf ng l nh ni">import pandas as pd<br/>import numpy as np<br/>from matplotlib import pyplot as plt</span><span id="5438" class="ne lw it na b gy nj ng l nh ni">df = pd.read_csv(“TrainingDataset.csv”)<br/>df = df.replace(np.nan, 0, regex=True)</span></pre><p id="6fee" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们可以预览数据集了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/fa05e3e421342f6ad0bd7ba70b6553d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0WheoqoQs9vnhAM57MY5jw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片作者:Rostyslav Neskorozhenyi</p></figure><p id="b59c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将把数据集分成训练部分(我们将在其上训练我们的模型)和测试部分(我们将在其上测试我们的模型的正确性)。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="068f" class="ne lw it na b gy nf ng l nh ni">from sklearn.model_selection import train_test_split</span><span id="9e9a" class="ne lw it na b gy nj ng l nh ni">df_train, df_test = train_test_split(df, test_size=0.2)<br/>print(df_train.shape)<br/>print(df_test.shape)</span></pre><h1 id="867f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">探索性数据分析</h1><p id="4050" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">让我们将数据可视化。我们将展示10个随机产品的价格变化动态。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="94c1" class="ne lw it na b gy nf ng l nh ni">import random</span><span id="334c" class="ne lw it na b gy nj ng l nh ni">indexes = random.sample(range(len(df)), 10)<br/>df_plot = pd.DataFrame()</span><span id="cf02" class="ne lw it na b gy nj ng l nh ni">for i in indexes:<br/>  df_plot[“product_”+str(i)] = df.iloc[i, 0:12]</span><span id="515e" class="ne lw it na b gy nj ng l nh ni">df_plot.plot();</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/93ba46f36485f3129046d93b2adfc6bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:886/format:webp/1*aB5dIav_aTXLlkI4S5omOw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片作者:Rostyslav Neskorozhenyi</p></figure><p id="226b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如我们所看到的，在大多数情况下，全年的销售额都在下降。</p><h1 id="8648" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">准备数据</h1><p id="81a6" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">我们需要以一种特殊的方式准备数据，以便加载到我们的模型中。我们将建立一个模型，根据以前的值预测未来一个月的结果。对于每个月，模型将分析产品功能和有关上个月结果的信息。</p><p id="b5cc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，我们将分开产品功能和每月结果的信息。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="e6e8" class="ne lw it na b gy nf ng l nh ni">y_train_real = df_train.iloc[:, 0:12].values<br/>print(y_train_real.shape)</span><span id="05b3" class="ne lw it na b gy nj ng l nh ni">y_test_real = df_test.iloc[:, 0:12].values<br/>print(y_test_real.shape)</span><span id="2ac8" class="ne lw it na b gy nj ng l nh ni">x_train_real = df_train.iloc[:, 12:].values<br/>x_test_real = df_test.iloc[:, 12:].values<br/>print(x_train_real.shape)<br/>print(x_test_real.shape)</span></pre><p id="c984" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在一个范围内缩放值以获得更好的预测。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="a9e6" class="ne lw it na b gy nf ng l nh ni">from sklearn.preprocessing import MinMaxScaler</span><span id="d5ae" class="ne lw it na b gy nj ng l nh ni">#scale datasets<br/>x_scaler = MinMaxScaler()<br/>x_scaler = x_scaler.fit(x_train_real)<br/>x_train = x_scaler.transform(x_train_real)<br/>x_test = x_scaler.transform(x_test_real)</span><span id="9d32" class="ne lw it na b gy nj ng l nh ni">y_scaler = MinMaxScaler()<br/>y_scaler = y_scaler.fit(y_train_real)<br/>y_train = y_scaler.transform(y_train_real)<br/>y_test = y_scaler.transform(y_test_real)</span></pre><p id="362e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在让我们转到这个过程中最重要的一步:将价格历史转换成多维时间序列。对于每个产品，我们将创建1-12个时间步的时间序列，其中包含有关产品功能和以前时间步结果的信息。我们不知道第一个时间步长的先前结果，所以我们只取零。</p><p id="d242" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这里，我们为训练和测试数据创建列表，每个列表将包含12个三维numpy数组。每个数组的第二维将代表时间步长，并逐渐增加1。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="169f" class="ne lw it na b gy nf ng l nh ni">x_train_series = []<br/>x_test_series = []</span><span id="71e8" class="ne lw it na b gy nj ng l nh ni">for k in range(len(y_train[0])):<br/>  x_train_series.append(np.zeros((x_train.shape[0], k+1, x_train.shape[1]+1)))</span><span id="d4e2" class="ne lw it na b gy nj ng l nh ni">for k in range(len(y_test[0])):<br/>  x_test_series.append(np.zeros((x_test.shape[0], k+1, x_test.shape[1]+1)))</span></pre><p id="38e2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">向每个时间步长添加有关产品功能和先前时间步长结果的信息。现在，我们对每个时间步长使用相同的产品功能，但是该模型允许跟踪每个时间步长上的功能变化，以做出更准确的预测。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="5922" class="ne lw it na b gy nf ng l nh ni">for k in range(len(y_train[0])):<br/>  for i in range(len(x_train)):<br/>    for j in range(k + 1):<br/>      shifted_index = j - 1<br/>      if shifted_index &lt; 0:<br/>        x_train_series[k][i, j] = np.append(x_train[i], 0)<br/>      else:<br/>        x_train_series[k][i, j] = np.append(x_train[i], y_train[i, shifted_index])</span></pre><p id="94d5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">测试数据的相同时间步长转换。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="edaf" class="ne lw it na b gy nf ng l nh ni">for k in range(len(y_test[0])):<br/>  for i in range(len(x_test)):<br/>    for j in range(k + 1):<br/>      shifted_index = j - 1<br/>      if shifted_index &lt; 0:<br/>        x_test_series[k][i, j] = np.append(x_test[i], 0)<br/>      else:<br/>        x_test_series[k][i, j] = np.append(x_test[i], y_test[i, shifted_index])</span></pre><p id="3852" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">制作12个列表，列出每个时间、每个产品的结果信息。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="d871" class="ne lw it na b gy nf ng l nh ni">y_train_series = []<br/>y_test_series = []</span><span id="1160" class="ne lw it na b gy nj ng l nh ni">for k in range(len(y_train[0])):<br/>  y_train_series.append(np.zeros((len(y_train), 1)))<br/>  y_test_series.append(np.zeros((len(y_test), 1)))<br/> <br/>  <br/>for k in range(len(y_train[0])):<br/>  y_train_series[k] = y_train[:, k].reshape(-1, 1)<br/>  y_test_series[k] = y_test[:, k].reshape(-1, 1)</span></pre><h1 id="6263" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">构建LSTM神经网络</h1><p id="46c5" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">我们将使用长短期记忆(LSTM)网络的递归神经网络(RNN)。你可以在这里阅读更多关于这些类型的神经网络:</p><p id="6119" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae lu" href="http://colah.github.io/posts/2015-08-Understanding-LSTMs/" rel="noopener ugc nofollow" target="_blank">http://colah.github.io/posts/2015-08-Understanding-LSTMs/</a></p><p id="837b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们使用Keras框架进行深度学习。我们的模型仅由一个具有256个单元的LSTM层、一个具有128个单元的密集层和具有一个神经元的密集连接输出层组成。我们还添加了一个脱层，以避免过度拟合。模型保持简单和快速，仍然能够做出有用的预测。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="daf1" class="ne lw it na b gy nf ng l nh ni">from keras.models import Sequential<br/>from keras.layers import Dense<br/>from keras.layers import LSTM<br/>from keras.layers import Dropout</span><span id="366a" class="ne lw it na b gy nj ng l nh ni">model = Sequential()<br/>model.add(LSTM(256, input_shape=(None, x_train.shape[1]+1)))<br/>model.add(Dropout(0.5))<br/>model.add(Dense(128, activation = "relu"))<br/>model.add(Dense(1))<br/>model.summary()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/0c824abe89c11e2294c08947018132b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1310/format:webp/1*xUoLOYiHJ1GF4K6K5GRq0Q.png"/></div></figure><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="6c5d" class="ne lw it na b gy nf ng l nh ni">model.compile(loss='mse', optimizer='rmsprop')</span></pre><p id="2d76" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">训练我们的模型:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="2656" class="ne lw it na b gy nf ng l nh ni">for i in range(len(x_train_series)):<br/>  print(i)<br/>  model.fit(x_train_series[i], y_train_series[i], epochs=10, validation_split=0.2)</span></pre><p id="9bca" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">评估模型，预测几个月后的结果。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="2820" class="ne lw it na b gy nf ng l nh ni">for i in range(len(x_test_series)):<br/>  accr = model.evaluate(x_test_series[i], y_test_series[i])<br/>  print("Predicting outcome after {} months. MSE:".format(i), accr)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/c36f62ec9747576affb1bd366ea835d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/format:webp/1*HaKQzSIYlgqB3w2ipHRr5A.png"/></div></figure><h1 id="3491" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结果预测函数</h1><p id="8de4" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">我们将使用我们的模型创建一个递归函数，该函数将在几个月内获取有关产品特性和结果历史的信息。因此，这个函数可以预测未来几个月的结果。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="8f99" class="ne lw it na b gy nf ng l nh ni">def predictor(features, history, future):<br/>  '''<br/>  features: list of product features<br/>  history: list with outcome per month<br/>  future: int, number of months to predict outcome<br/>  '''<br/>  if future == 0:<br/>    return history  <br/>  <br/>  p_serie = np.zeros((1, len(history), len(features)+1))  <br/>  <br/>  for j in range(len(history)):<br/>    shifted_index = j - 1<br/>    if shifted_index &lt; 0:<br/>      p_serie[0, j] = np.append(features, 0)<br/>    else:<br/>      p_serie[0, j] = np.append(features, history[shifted_index])<br/>      <br/>  prediction = model.predict(p_serie)    <br/>  <br/>  history.append(prediction[0][0])<br/>  future -= 1  <br/>  <br/>  return predictor(features, history, future)</span></pre><p id="3e34" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将在随机产品<em class="mv"> n </em>上测试我们的功能。我们将创建两个列表。首先是前<em class="mv"> m </em>个月的成果历史，其次是产品特性</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="ce64" class="ne lw it na b gy nf ng l nh ni">import random</span><span id="8adf" class="ne lw it na b gy nj ng l nh ni">n = random.choice(range(len(x_test)-1))<br/>m = 6<br/>future = 6</span><span id="dfc8" class="ne lw it na b gy nj ng l nh ni">features = x_test[n].tolist()<br/>history = y_test[n, 0:m].tolist()</span></pre><p id="6453" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">绘制预测结果与实际数据的对比图</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="18fc" class="ne lw it na b gy nf ng l nh ni">prediction = predictor(features, history, future)</span><span id="c981" class="ne lw it na b gy nj ng l nh ni">plt.plot(y_scaler.inverse_transform([prediction])[0])<br/>plt.plot(y_scaler.inverse_transform([y_test[n, :m+future]])[0])<br/>plt.title('Predicted and real outcome')<br/>plt.legend(['predicted', 'real'], loc='upper left')<br/>axes = plt.gca()</span><span id="3e72" class="ne lw it na b gy nj ng l nh ni">plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/a4bbccbcdbf8c9e91d2f91413cf16037.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*EBzn4KrjDr66Kf66WrnhSw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片作者:Rostyslav Neskorozhenyi</p></figure><p id="2284" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如我们所看到的，它相当准确地显示了销售变化的总体趋势。对于一个相对简单的模型来说，这是一个不错的结果。</p><h1 id="9271" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">在Google Data Studio中显示预测</h1><p id="4d87" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">现在，当我们有了我们的预测数据，我们可以在谷歌的商业智能解决方案<a class="ae lu" href="https://datastudio.google.com/" rel="noopener ugc nofollow" target="_blank">谷歌数据工作室</a>中显示它。这个工具的一个优点是可以免费用来制作自定义报表和仪表盘。</p><p id="e8a6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Google Data Studio可以连接多个数据源进行报告。Google Sheets作为数据源很适合我们的目的。我们将把我们的预测保存为Google Sheet，Google Data Studio将在dashbord上显示其中的数据。因此，我们可以很容易地整合谷歌实验室和数据工作室。</p><p id="1851" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我不会详细解释谷歌数据工作室的功能。你可以在https://developers.google.com/datastudio/<a class="ae lu" href="https://developers.google.com/datastudio/" rel="noopener ugc nofollow" target="_blank">的官方文件中了解到</a></p><p id="be5b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将随机抽取三个产品，保存每个产品的预测和结果历史。为了将我们的数据保存到谷歌电子表格中，我们将使用<strong class="la iu"> gspread </strong>库。</p><p id="e897" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将需要一个客户端密钥写在谷歌电子表格。这里介绍如何得到钥匙<a class="ae lu" href="https://gspread.readthedocs.io/en/latest/oauth2.html" rel="noopener ugc nofollow" target="_blank">https://gspread.readthedocs.io/en/latest/oauth2.html</a>。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="94e5" class="ne lw it na b gy nf ng l nh ni">!pip install — upgrade oauth2client gspread</span></pre><p id="30fa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">连接到Google Sheets。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="e299" class="ne lw it na b gy nf ng l nh ni">import gspread<br/>from oauth2client.service_account import ServiceAccountCredentials</span><span id="5cc0" class="ne lw it na b gy nj ng l nh ni">scope = ['<a class="ae lu" href="https://spreadsheets.google.com/feeds'" rel="noopener ugc nofollow" target="_blank">https://spreadsheets.google.com/feeds'</a>,<br/>         '<a class="ae lu" href="https://www.googleapis.com/auth/drive'" rel="noopener ugc nofollow" target="_blank">https://www.googleapis.com/auth/drive'</a>]</span><span id="393e" class="ne lw it na b gy nj ng l nh ni">credentials = ServiceAccountCredentials.from_json_keyfile_name('spreadkey.json', scope)</span><span id="54b2" class="ne lw it na b gy nj ng l nh ni">gc = gspread.authorize(credentials)</span></pre><p id="0047" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">列出三种随机产品的真实和预测结果历史。出于测试目的，我们使用来自测试数据集的数据，但在实际情况下，您可以在Google Sheets中插入产品功能的任何变化，从Google Sheets加载数据并做出预测。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="bf68" class="ne lw it na b gy nf ng l nh ni">real_data = []<br/>predicted_data = []</span><span id="85e3" class="ne lw it na b gy nj ng l nh ni">for i in range(3):<br/>  n = random.choice(range(len(x_test)-1))<br/>  m = 6<br/>  future = 6<br/>  features = x_test[n].tolist()<br/>  history = y_test[n, 0:m].tolist()</span><span id="7e3c" class="ne lw it na b gy nj ng l nh ni">  prediction = predictor(features, history, future)</span><span id="b1a1" class="ne lw it na b gy nj ng l nh ni">  predicted_data.append(y_scaler.inverse_transform([prediction])[0])<br/>  real_data.append(y_scaler.inverse_transform([y_test[n, :m+future]])[0])</span></pre><p id="630f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">打开谷歌工作表保存真实和预测的数据。我们有两个工作表:“真实”代表真实数据，“预测”代表预测数据。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="8ca6" class="ne lw it na b gy nf ng l nh ni">ws = gc.open('TrainingDataset2')</span><span id="4acd" class="ne lw it na b gy nj ng l nh ni">ws_predicted = ws.worksheet("predicted")<br/>ws_real = ws.worksheet("real")</span></pre><p id="c408" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">把我们真实的和预测的数据写到Google Sheets。我们将从第二行开始写，保留第一行作为列名(Product1、Product2、Product3)。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="cae4" class="ne lw it na b gy nf ng l nh ni">for j in range(len(real_data)):<br/>  for i in range(len(real_data[0])):<br/>    ws_predicted.update_cell(i+2, j+1, float(predicted_data[j][i]))<br/>    ws_real.update_cell(i+2, j+1, float(real_data[j][i]))<br/>    <br/>    <br/>for i in range(len(real_data[0])):    <br/>    # add index column<br/>    ws_predicted.update_cell(i+2, len(real_data)+1, i)<br/>    ws_real.update_cell(i+2, len(real_data)+1, i)</span></pre><p id="39bb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在Google Sheets查看我们的数据</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="bd75" class="ne lw it na b gy nf ng l nh ni">ws_real.get_all_records()[6:11]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/7879dbfda2662ed0943ca6235e807ae5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*pvo-0IxalGYGNIkHueovFQ.png"/></div></figure><p id="8005" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于我们已经有了充满真实和预测结果的Google Sheets，现在我们可以将Google Sheets作为Google Data Studio中的数据源进行连接。</p><p id="2e38" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在Google Data Studio中，创建新的仪表板并为其创建数据源。你会在资源列表中找到谷歌工作表。将您的Google工作表添加为数据源。</p><p id="b54f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">基于“预测的”和“真实的”工作表中的数据，我们可以做出显示结果变化的图表。</p><p id="b320" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就是这样！现在你有人工智能驱动的仪表板，显示对未来结果的预测！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4b0e43d15ad7a1389dbcc414a4c57f46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BoHiHHUmb5YhKMrYUlb9DA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片作者:Rostyslav Neskorozhenyi</p></figure><h1 id="d4e5" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="a3b9" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">这篇文章的主要思想是，甚至带有一些人工智能特征的商业智能比我们想象的更容易获得。您可以创建高级分析，将建议的图表嵌入到您的分析报告中，并对当前情况和不久的将来有所了解。所有的变化，你想检查可以迅速插入谷歌表，预测的后果将在谷歌Colab计算，并显示在谷歌数据工作室。</p><p id="f8a4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以通过这个<a class="ae lu" href="https://colab.research.google.com/drive/1O3_LJOL40ZvIWtnYE36HSBWzKgIZCC9W?usp=sharing" rel="noopener ugc nofollow" target="_blank">链接</a>找到所有描述代码的Google Colab笔记本。</p></div></div>    
</body>
</html>