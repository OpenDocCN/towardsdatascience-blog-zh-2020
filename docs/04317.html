<html>
<head>
<title>How to Merge “Not Matching” Time Series with Pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何合并与熊猫“不匹配”的时间序列</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-merge-not-matching-time-series-with-pandas-7993fcbce063?source=collection_archive---------8-----------------------#2020-04-19">https://towardsdatascience.com/how-to-merge-not-matching-time-series-with-pandas-7993fcbce063?source=collection_archive---------8-----------------------#2020-04-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d691" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何使用 merge_asof 函数</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5d2ad1c14ce025b8e2c245affa552ae4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hmgSvo__1rQt0vilW81W-w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@loic?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Djim Loic </a>在<a class="ae ky" href="https://unsplash.com/s/photos/clock?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="8ac6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">时间序列数据有许多定义，所有这些定义都以不同的方式表示相同的含义。一个直截了当的定义是，时间序列数据包括附加到连续时间戳的数据点。</p><p id="9524" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Pandas 由 Wes Mckinney 创建，旨在提供一个高效灵活的工具来处理时间至关重要的财务数据。因此，Pandas 是处理时间序列数据的一个非常好的选择。</p><p id="d68d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">金融数据通常包括在非常短的时间内(例如在秒级)进行的测量。因此，当我们合并两个由时间序列数据组成的数据帧时，我们可能会遇到测量值相差一两秒的情况。对于这种情况，熊猫提供了一种由<strong class="lb iu"> merge_asof </strong>完成的“智能”合并方式。</p><p id="c910" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们正在合并数据帧 A 和 B。如果左侧数据帧(A)中的一行在右侧数据帧(B)中没有匹配的行，<strong class="lb iu"> merge_asof </strong>允许获取其值接近左侧数据帧(A)中值的一行。</p><blockquote class="lv lw lx"><p id="e86d" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">左和右是根据函数中参数的顺序定义的。pd.merge_asof (A，B，…)表示 A 是左边的那个。</p></blockquote><p id="85fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">“亲近”是有一些限制的。根据“on”参数指定的列进行比较，右数据帧(B)中的值必须小于左数据帧(A)中的值。简单解释一下，merge_asof 的意思是:</p><blockquote class="lv lw lx"><p id="dda5" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated"><strong class="lb iu">没有匹配的，取前面的。</strong></p></blockquote><p id="04ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们看一些例子时，它会更有意义。</p><p id="0ed1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">样本 A 和 B 数据帧如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/45217eafe3f519b431a7c8c919d4fa1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:830/format:webp/1*rDF3FGMrEBB2WR6EQzhS_A.png"/></div></figure><p id="b627" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们想按“名称”列合并“时间”上的这些数据帧，但一些时间值不匹配。例如，在第二行中，A 中的时间比 b 中的时间晚一秒，假设我们可以容忍 2 秒的延迟。</p><p id="b87a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，可以使用<strong class="lb iu"> merge_asof </strong>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi md"><img src="../Images/6f33992bb3605ffcc2a940dd1732f077.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*gFa-O0QQriGrmX1Bv4AJ_A.png"/></div></figure><ul class=""><li id="7fa2" class="me mf it lb b lc ld lf lg li mg lm mh lq mi lu mj mk ml mm bi translated">第一行:时间匹配，因此根据行索引取值。</li><li id="f7e6" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated">第二行:左侧数据帧(A)上的时间为 00:00:03，但右侧数据帧(B)此时没有值。因此，merge_asof 会查看前面的步骤，如果在指定的时间间隔(2 秒)内有一个值，它会将最后一个值放入合并的数据帧中。在时间 00:00:00 只有一个先前值，它落后 3 秒，因此不在指定的时间内。因此，values_b 列这次用 NaN 填充。</li><li id="57b3" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated">第三行:左侧数据帧(A)上的时间是 00:00:06。右数据帧(B)在这一秒没有值，但它在 00:00:04 有一个值，该值在指定的内部时间内，因此 merge_asof 获取该值并放入合并的数据帧中。</li><li id="175a" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated">第四行:这一行很重要，所以请密切注意。左侧数据帧(A)上的时间是 00:00:09。右侧数据帧(B)此时没有值，但在指定时间间隔内的 00:00:08 时有值。但是，“名称”列也必须匹配，因为我们是按“名称”列合并的。由于名称不同，merge_asof 不接受该值，因此 values_b 列用 NaN 填充该行。</li><li id="7eed" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated">第 5 行:两个数据帧都有时间值 00:00:12，并命名为 FFF。</li></ul><p id="9b3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们不指定时间间隔，merge_asof 将查找前一个时间间隔，而不考虑时差。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/4d43eb9e15e5cc655966a2facbf29852.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/format:webp/1*NF5Ceonvnbb9htD6Jzw0dw.png"/></div></figure><p id="32ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当时间间隔为 2 秒时，values_b 为 NaN。如果没有指定的时间间隔，则用之前的值 5 填充。</p><p id="c844" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Merge_asof 还提供了一个排除精确匹配的选项。如果 allow_exact_matches 设置为 False，merge_asof 仅在右侧数据帧中查找以前的值，匹配行中的值不会放入合并的数据帧中:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/d12efb303f38f8e3d46501f080aa37e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1126/format:webp/1*LG18yEZZTxWlqObueZIk0w.png"/></div></figure><p id="3059" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">测量时间的方法是无限的，因为我们可以精确到纳秒。根据不同的任务，我们可以选择最佳的测量频率。Merge_asof 允许我们在匹配时间序列或者有序数据时有一定的余地。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><p id="9720" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。如果您有任何反馈，请告诉我。</p></div></div>    
</body>
</html>