<html>
<head>
<title>Managing JupyterLab-based data science projects using Conda (+pip)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Conda (+pip)管理基于 JupyterLab 的数据科学项目</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/managing-jupyterlab-based-data-science-projects-using-conda-pip-cd2ee8521705?source=collection_archive---------43-----------------------#2020-09-07">https://towardsdatascience.com/managing-jupyterlab-based-data-science-projects-using-conda-pip-cd2ee8521705?source=collection_archive---------43-----------------------#2020-09-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8ab0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为眼光敏锐的数据科学家收集的“最佳实践”</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5ce089d16affadf2b557db347b783dc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N5Pd0tHOmDtBDLHtX39fTg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用 Conda (+pip)和一点 Bash，自动安装 JupyterLab 很容易。(图片:NASA/JPL/比约恩·杰森/塞恩·多兰/<a class="ae ky" href="https://www.flickr.com/photos/136797589@N04/35532950750/" rel="noopener ugc nofollow" target="_blank">Flickr</a>(<a class="ae ky" href="https://creativecommons.org/licenses/by-nc-nd/2.0/" rel="noopener ugc nofollow" target="_blank">CC BY-NC-ND 2.0</a>))</p></figure><p id="f908" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文讨论了使用 Conda (+pip)管理基于<a class="ae ky" href="https://jupyter.org/" rel="noopener ugc nofollow" target="_blank"> JupyterLab </a>的数据科学项目的两种方法:一种是“全系统”方法，其中 Conda (+pip)用于管理所有项目共享的单个 JupyterLab 安装，另一种是“基于项目”方法，其中 Conda (+pip)用于管理每个项目的单独 JupyterLab 安装。在描述了这两种方法之后，我将浏览一些例子并讨论相关的权衡。</p><h1 id="a0ec" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">“系统级”JupyterLab 安装</h1><p id="b415" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">Conda (+pip)采用“全系统”方法管理 JupyterLab，用于管理所有或您的数据科学项目共享的 JupyterLab 安装。“全系统”方法有几个好处。</p><ul class=""><li id="5629" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">一组通用的 JupyterLab 扩展简化了用户界面(UI)和用户体验(UX)。</li><li id="a86c" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">允许更快地启动新项目，因为不需要安装(和构建！)JupyterLab 每一个项目。</li><li id="01b0" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">通过用户主目录中的<code class="fe ng nh ni nj b">~/.jupyter</code>目录中的文件对 JupyterLab 进行简单的低级配置。</li></ul><h2 id="4ed6" class="nk lw it bd lx nl nm dn mb nn no dp mf li np nq mh lm nr ns mj lq nt nu ml nv bi translated">“系统范围”安装的典型 Conda environment.yml</h2><p id="9549" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">下面是一个“系统级”JupyterLab 安装的存根<code class="fe ng nh ni nj b">environment.yml</code>文件。</p><pre class="kj kk kl km gt nw nj nx ny aw nz bi"><span id="15e1" class="nk lw it nj b gy oa ob l oc od">name: jupyterlab-base-env</span><span id="1f6b" class="nk lw it nj b gy oe ob l oc od">channels:<br/> — conda-forge<br/> — defaults<br/> <br/>dependencies:<br/> — jupyterlab<br/> — jupyterlab-git # provides git support<br/> — nodejs # required for building (some) extensions<br/> — pip<br/> — pip:<br/> — -r file:requirements.txt # extensions available via pip go here<br/> — python</span></pre><p id="fbfb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有几件事值得注意。首先，您应该将通过 Conda(通常来自<code class="fe ng nh ni nj b"><a class="ae ky" href="https://conda-forge.org/" rel="noopener ugc nofollow" target="_blank">conda-forge</a></code>频道)获得的任何 JupyterLab 扩展作为依赖项包含在这个文件中。通过 Pip 获得的 JupyterLab 扩展应该单独包含在一个<code class="fe ng nh ni nj b">requirements.txt</code>文件中(下面讨论)。第二，我明确地将<code class="fe ng nh ni nj b">nodejs</code>作为一个依赖项。<a class="ae ky" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>是重新构建 JupyterLab 所必需的(这可能是必需的，取决于您的扩展集合)。最后，我安装 Pip 并使用<code class="fe ng nh ni nj b">pip</code>来安装包含在一个单独的<code class="fe ng nh ni nj b">requirements.txt</code>文件中的所有包和扩展。</p><h2 id="d6a7" class="nk lw it bd lx nl nm dn mb nn no dp mf li np nq mh lm nr ns mj lq nt nu ml nv bi translated">“系统范围”安装的典型 pip 要求. txt</h2><p id="01e0" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">关于<code class="fe ng nh ni nj b">requirements.txt</code>文件没有什么特别的。您只需列出您想通过<code class="fe ng nh ni nj b">pip</code>安装的包和扩展。在这里，我包括了 Jupyter 语言服务器协议扩展，它带来了完整的 IDE 功能，比如代码导航、悬停建议、linters、自动完成和 JupyterLab 的重命名。</p><pre class="kj kk kl km gt nw nj nx ny aw nz bi"><span id="312f" class="nk lw it nj b gy oa ob l oc od">jupyter-lsp<br/>python-language-server[all]</span></pre><h2 id="728f" class="nk lw it bd lx nl nm dn mb nn no dp mf li np nq mh lm nr ns mj lq nt nu ml nv bi translated">使用 Bash 脚本自动化<code class="fe ng nh ni nj b">jupyterlab-base-env</code>构建</h2><p id="06b2" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">因为 Conda (+pip)环境的环境构建过程有点复杂(因为它涉及到通过 Conda 安装包，通过 pip 安装包，然后可能安装扩展并重新构建 JupyterLab 本身),所以使用 Bash 脚本自动构建环境是一个好主意。</p><pre class="kj kk kl km gt nw nj nx ny aw nz bi"><span id="faf5" class="nk lw it nj b gy oa ob l oc od">#!/bin/bash --login<br/>set -e</span><span id="781f" class="nk lw it nj b gy oe ob l oc od">conda env create \<br/> —-name jupyterlab-base-env \<br/> —-file environment.yml \<br/> —-force<br/>conda activate jupyterlab-base-env<br/>source postBuild # put jupyter labextension install commands here</span></pre><p id="4563" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意<code class="fe ng nh ni nj b">--login</code>标志的使用。这确保了脚本将在一个登录 shell 中运行，该 shell 将正确地获取必要的 Bash 概要文件，这些文件是<code class="fe ng nh ni nj b">conda activate</code>命令按预期工作所必需的。还要注意对一个<code class="fe ng nh ni nj b">postBuild</code>文件的引用。这是一个 Bash 脚本，包含启用这些扩展和重建 JupyterLab 所需的任何必要的<code class="fe ng nh ni nj b">jupyter labextension install</code>命令。我已经在<a class="ae ky" href="https://github.com/davidrpugh/jupytercon-2020-talk/tree/jupyterlab-base-env" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上包含了上面提到的所有配置文件的工作示例。</p><h2 id="d692" class="nk lw it bd lx nl nm dn mb nn no dp mf li np nq mh lm nr ns mj lq nt nu ml nv bi translated">保持身体的倾斜</h2><p id="af29" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">您的<code class="fe ng nh ni nj b">jupyterlab-base-env</code>环境应该<em class="of">仅</em>包含 JupyterLab 和任何必需的扩展(+依赖项)。不要将用于数据科学项目的包安装到您的<code class="fe ng nh ni nj b">jupyterlab-base-env</code>中。相反，您应该为每个项目创建单独的 Conda (+pip)环境，然后为每个特定于项目的 Conda (+pip)环境创建定制的 Jupyter 内核。</p><h2 id="fe6a" class="nk lw it bd lx nl nm dn mb nn no dp mf li np nq mh lm nr ns mj lq nt nu ml nv bi translated">为 Conda 环境创建 Jupyter 内核</h2><p id="baad" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">为您项目的每个 Conda (+pip)环境创建一个定制的 Jupyter 内核，这将允许您在一个通用的 JupyterLab 安装中从这些环境启动 Jupyter 笔记本和 IPython 控制台。您甚至可以使用<code class="fe ng nh ni nj b"><a class="ae ky" href="https://github.com/fcollonval/jupyter_conda" rel="noopener ugc nofollow" target="_blank">jupyter-conda</a></code>扩展为您机器上的所有 Conda (+pip)环境自动化内核创建过程！</p><p id="51f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，与其为每个 Conda (+pip)环境创建定制内核，我更喜欢为我真正关心的特定 Conda (+pip)环境手动创建定制 Jupyter 内核。</p><p id="2974" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">如何手动创建自定义 Jupyter 内核</strong></p><p id="20a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在为 Conda (+pip)环境创建定制内核之前，您需要确保在 Conda 环境中安装了<code class="fe ng nh ni nj b"><a class="ae ky" href="https://pypi.org/project/ipykernel/" rel="noopener ugc nofollow" target="_blank">ipykernel</a></code>包，因为您将需要使用该包来创建<a class="ae ky" href="https://jupyter-client.readthedocs.io/en/latest/kernels.html#kernelspecs" rel="noopener ugc nofollow" target="_blank">内核规范</a>文件。</p><pre class="kj kk kl km gt nw nj nx ny aw nz bi"><span id="11e4" class="nk lw it nj b gy oa ob l oc od">conda activate $PROJECT_DIR/env # don’t forget to activate!<br/>python -m ipykernel install \ # requires ipykernel!<br/> --user \<br/> —-name name-for-internal-use-only \<br/> —-display-name “Name you will see in the JupyerLab launcher”</span></pre><h1 id="57dc" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">基于项目的 JupyterLab 安装</h1><p id="1ac2" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">通过“基于项目”的方法来管理 JupyterLab，Conda (+pip)用于管理每个项目的独立 JupyterLab 安装。“基于项目”的方法有几个优点。</p><ul class=""><li id="4f78" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">更灵活的用户界面/UX，因为 JupyterLab 版本和扩展可以为每个项目定制。</li><li id="620b" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">JupyterLab 前沿特性的更简单实验。</li><li id="636c" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">自动生成数据科学项目报告<a class="ae ky" href="https://mybinder.org/" rel="noopener ugc nofollow" target="_blank">“活页夹就绪”</a>。</li></ul><h2 id="5a8f" class="nk lw it bd lx nl nm dn mb nn no dp mf li np nq mh lm nr ns mj lq nt nu ml nv bi translated">“基于项目”安装的典型 Conda environment.yml</h2><p id="1dcc" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这个<code class="fe ng nh ni nj b">environment.yml</code>文件的结构类似于“全系统”方法的结构。不同之处在于，使用“基于项目”的方法，您应该将您的项目所需的所有包和扩展通过 Conda 添加到这个文件中；皮普和<code class="fe ng nh ni nj b">requirements.txt</code>文件也是如此。</p><pre class="kj kk kl km gt nw nj nx ny aw nz bi"><span id="75a8" class="nk lw it nj b gy oa ob l oc od">name: null</span><span id="5d82" class="nk lw it nj b gy oe ob l oc od">channels:<br/> — conda-forge<br/> — defaults<br/> <br/>dependencies:<br/> — jupyterlab<br/> — jupyterlab-git # extensions available via conda go here<br/> - nodejs<br/> — pip<br/> — pip:<br/> — -r file:requirements.txt # packages available via pip go here<br/> — python</span></pre><h2 id="f058" class="nk lw it bd lx nl nm dn mb nn no dp mf li np nq mh lm nr ns mj lq nt nu ml nv bi translated">使用 Bash 脚本自动构建项目环境</h2><p id="9db8" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">同样，您应该尽可能自动化 Conda (+pip)环境构建。这个脚本与“系统范围”方法中使用的脚本之间的唯一区别是，我将 Conda (+pip)环境安装在我的项目目录的一个名为<code class="fe ng nh ni nj b">env</code>的子目录中。这是一个<a class="ae ky" rel="noopener" target="_blank" href="/managing-project-specific-environments-with-conda-406365a539ab"> Conda (+pip)“最佳实践”</a>。</p><pre class="kj kk kl km gt nw nj nx ny aw nz bi"><span id="5231" class="nk lw it nj b gy oa ob l oc od">#!/bin/bash —-login<br/>set -e</span><span id="137f" class="nk lw it nj b gy oe ob l oc od">export ENV_PREFIX=$PROJECT_DIR/env<br/>conda env create \<br/> —-prefix $ENV_PREFIX <br/> —-file environment.yml \<br/> —-force<br/>conda activate $ENV_PREFIX<br/>source postBuild # put jupyter labextension install commands here</span></pre><h2 id="ae45" class="nk lw it bd lx nl nm dn mb nn no dp mf li np nq mh lm nr ns mj lq nt nu ml nv bi translated">“基于项目”的 JupyterLab 安装示例</h2><p id="0a0f" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">正如我所承诺的，这里有几个“基于项目”方法的例子，可以作为你下一个数据科学项目的灵感。</p><ul class=""><li id="378d" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated"><a class="ae ky" href="https://github.com/davidrpugh/jupytercon-2020-talk/tree/scikit-learn-env" rel="noopener ugc nofollow" target="_blank">JupyterLab+Scikit Learn+Dask</a>:基于 CPU 的数据科学项目环境，将 JupyterLab 与<a class="ae ky" href="https://scikit-learn.org/stable/index.html" rel="noopener ugc nofollow" target="_blank"> Scikit-learn </a>和<a class="ae ky" href="https://dask.org/" rel="noopener ugc nofollow" target="_blank"> Dask </a>(还有朋友！).包括一些常见的 JupyterLab 扩展。</li><li id="c76d" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><a class="ae ky" href="https://github.com/davidrpugh/jupytercon-2020-talk/tree/pytorch-env" rel="noopener ugc nofollow" target="_blank"> JupyterLab + PyTorch </a>:使用 JupyterLab 和<a class="ae ky" href="https://pytorch.org/" rel="noopener ugc nofollow" target="_blank"> PyTorch </a>进行 GPU 加速深度学习的标准环境。包括 GPU 和深度学习特定的 JupyterLab 扩展，如<a class="ae ky" href="https://github.com/rapidsai/jupyterlab-nvdashboard" rel="noopener ugc nofollow" target="_blank"> jupyterlab-nvdashboard </a>和<a class="ae ky" href="https://github.com/chaoleili/jupyterlab_tensorboard" rel="noopener ugc nofollow" target="_blank"> jupyterlab-tensorboard </a>。</li><li id="81cc" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><a class="ae ky" href="https://github.com/davidrpugh/jupytercon-2020-talk/tree/nvidia-rapids-env" rel="noopener ugc nofollow" target="_blank">JupyterLab+NVIDIA RAPIDS+BlazingSQL+Dask</a>:更复杂的 GPU 加速机器学习环境有 JupyterLab、<a class="ae ky" href="https://rapids.ai/" rel="noopener ugc nofollow" target="_blank"> NVIDIA RAPIDS </a>、<a class="ae ky" href="https://www.blazingsql.com/" rel="noopener ugc nofollow" target="_blank"> BlazingSQL </a>、<a class="ae ky" href="https://dask.org/" rel="noopener ugc nofollow" target="_blank"> Dask </a>(还有<em class="of">很多</em>的朋友！).包括一些常见的 JupyterLab 扩展以及一些特定于 GPU 的扩展，如<a class="ae ky" href="https://github.com/rapidsai/jupyterlab-nvdashboard" rel="noopener ugc nofollow" target="_blank"> jupyterlab-nvdashboard </a>。</li></ul><h1 id="04ca" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">%conda 和%pip 魔术命令</h1><p id="9c20" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">任何关于 JupyterLab、Conda 和 pip 的讨论，如果不提及内置的 IPython 魔术命令，将软件包通过 Conda ( <code class="fe ng nh ni nj b"><a class="ae ky" href="https://ipython.readthedocs.io/en/stable/interactive/magics.html#magic-conda" rel="noopener ugc nofollow" target="_blank">%conda</a></code>)或 Pip ( <code class="fe ng nh ni nj b"><a class="ae ky" href="https://ipython.readthedocs.io/en/stable/interactive/magics.html#magic-pip" rel="noopener ugc nofollow" target="_blank">%pip</a></code>)安装到<em class="of">活动</em>环境/内核中，都是不完整的。</p><ul class=""><li id="e878" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">这两个命令都可以在 Jupyter 笔记本或 IPython 控制台中使用。</li><li id="34df" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><code class="fe ng nh ni nj b">%conda</code>和<code class="fe ng nh ni nj b">%pip</code>对新项目的原型设计都非常有用。</li><li id="3e98" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">对于“生产”，更喜欢向<code class="fe ng nh ni nj b">environment.yml</code>或<code class="fe ng nh ni nj b">requirements.txt</code>文件添加新的包(并重建环境)。</li></ul><h1 id="71b0" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">摘要</h1><p id="8fc4" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">希望到此为止，您将理解用 Conda (+pip)管理 JupyterLab 安装的“系统范围”和“基于项目”方法之间的区别。您还看到了这两种方法的几个示例，包括一些可用于下一个数据科学项目的起始代码。</p><p id="094a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总的来说，我推荐“基于项目”的方法，因为它具有更大的灵活性和最小的额外开销。如果您只在部分项目中使用 GPU，那么您可能更喜欢“基于项目”的方法，因为有一些很好的用于 GPU 加速数据科学项目的 JupyterLab 扩展(您不想为纯 CPU 项目安装这些扩展)。然而，如果您的所有项目要么只有 CPU，要么几乎总是使用 GPU，并且总是使用一组通用的 JupyterLab 扩展，那么您可能更喜欢“系统范围”的方法。</p></div></div>    
</body>
</html>