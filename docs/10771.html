<html>
<head>
<title>Build a NLP Pipeline with SciKit-Learn: Ham or Spam?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 SciKit-Learn 构建 NLP 管道:火腿还是垃圾邮件？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/build-a-nlp-pipeline-with-scikit-learn-ham-or-spam-b2cd0b3bc0c1?source=collection_archive---------61-----------------------#2020-07-27">https://towardsdatascience.com/build-a-nlp-pipeline-with-scikit-learn-ham-or-spam-b2cd0b3bc0c1?source=collection_archive---------61-----------------------#2020-07-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1476" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用 Scikit-Learn 的自然语言处理库制作简单的垃圾邮件检测器模型的初学者指南。</h2></div><p id="334a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作者:<a class="ae le" href="https://www.linkedin.com/in/edkrueger/" rel="noopener ugc nofollow" target="_blank">爱德华·克鲁格</a>和<a class="ae le" href="https://www.linkedin.com/in/douglas-franklin-1a3a2aa3/" rel="noopener ugc nofollow" target="_blank">道格拉斯·富兰克林</a>。</p><p id="39a2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们的<a class="ae le" href="https://github.com/edkrueger/spam-detector" rel="noopener ugc nofollow" target="_blank"> GitHub 库</a>中查看代码！</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/fcba8c3934093d22d8b5d3f4093e14f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Utn4e5P4YryUcaCwltYxzg.jpeg"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">安娜·阿尔尚蒂在 Unsplash 上的照片</p></figure><h2 id="eb8f" class="lv lw it bd lx ly lz dn ma mb mc dp md kr me mf mg kv mh mi mj kz mk ml mm mn bi translated">问题是</h2><p id="5527" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">像许多 NLP 问题一样，决定哪些电子邮件属于垃圾邮件，哪些是你可能想要阅读的是一个分类问题。</p><p id="cbf2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以问，电子邮件属于哪一类，是垃圾邮件还是非垃圾邮件？因此，我们有两个类来分类我们所有的电子邮件。从哪里开始？</p><p id="af49" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了解决这个问题，我们将使用监督机器学习。这意味着我们有一个已经被标记为垃圾邮件的电子邮件集合。被认为是非垃圾邮件的电子邮件。大致上，我们的模型将通过查看电子邮件的内容并将该内容与任一标签相关联来学习对这些电子邮件进行分类。</p><p id="a742" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">经过训练后，我们的模型可以接收一封未标记的电子邮件，并对其进行分类。</p><h2 id="6930" class="lv lw it bd lx ly lz dn ma mb mc dp md kr me mf mg kv mh mi mj kz mk ml mm mn bi translated">数据</h2><p id="bf11" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">在我们开始之前，让我们看一下我们的数据。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/e19c05180c52d79eba43c6b89cf0029c.png" data-original-src="https://miro.medium.com/v2/resize:fit:798/format:webp/1*Zij9pCmI2lO1DrhwA4lmpA.png"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">用于监督学习的标记电子邮件数据</p></figure><p id="a1c7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们从包含垃圾邮件和非垃圾邮件的语料库或文本集合开始。数据包括标签列(v1)和文本列(v2)。这是我们的模型将读取的数据，用于将消息与类相关联。</p><p id="5bb2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">听起来很简单，但是计算机不能像我们一样阅读和学习！然而，机器是优秀的计算器。所以让我们把我们的文本转换成一种我们的机器可以进行数学运算的结构，向量。</p><p id="e326" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在完成一些基本的文本清理以处理大小写和非字母字符之后，我们可以开始了。我们将讨论的矢量化的第一步称为标记化。</p><h2 id="1a40" class="lv lw it bd lx ly lz dn ma mb mc dp md kr me mf mg kv mh mi mj kz mk ml mm mn bi translated">标记化</h2><p id="0ba5" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">给定一个字符序列和一个定义的长度，标记化就是将文档分割成指定长度的片段，称为<em class="mu">标记</em>。</p><p id="d718" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">令牌不一定是术语或单词。一个<em class="mu">标记</em>是一些特定文档中的一个字符序列的实例，这些字符被分组为一个有用的语义单元用于处理。换句话说，标记是我们希望模型学习的有意义的语言。</p><p id="1482" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">示例:</strong>句子的标记化，将标记长度限制为<strong class="kk iu">五个</strong>字符。</p><pre class="lg lh li lj gt mv mw mx my aw mz bi"><span id="a489" class="lv lw it mw b gy na nb l nc nd"><strong class="mw iu">IN:</strong> “moon river wider than a mile i am crossing you in style”</span><span id="337d" class="lv lw it mw b gy ne nb l nc nd"><strong class="mw iu">OUT:</strong> [moon, river, wider, than, a, mile, i, am, cross, you, in, style]</span></pre><p id="9314" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过标记化，我们已经从包含超过五个字符长的单词和空格的<strong class="kk iu">字符串</strong>变成包含五个字符或更少字符且没有空格的单词或标记的<strong class="kk iu">数组</strong>。</p><p id="6448" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">好了，我们现在有了一个字符串数组，我们如何把这些数组转换成向量呢？</p><h2 id="d776" class="lv lw it bd lx ly lz dn ma mb mc dp md kr me mf mg kv mh mi mj kz mk ml mm mn bi translated">矢量化:将单词映射为数值</h2><p id="8463" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">Scikit-learn 的 CountVectorizer 提供了一种简单的方法来标记一组文本文档并构建已知单词的词汇表。</p><p id="99a7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们看到的任何文档都可以被编码为一个固定长度的向量，其长度为已知单词的词汇表的长度。向量中每个位置的值可以用文档中每个单词的计数或频率来填充。</p><p id="16c9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">用 CountVectorizer 将句子转换成向量</p><p id="231d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对我们来说，这给了每封邮件一个整数向量。向量将是语料库中不同单词数量的长度。给定一个冗长的语料库，这些向量在计算过程中会变得相当长且麻烦。</p><p id="49e9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就引出了我们的下一个想法，如何在不损失太多意义的情况下缩小语料库？</p><p id="3737" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦我们用 CountVectorizer 将语料库转换成一个整数数组，我们就进入停用词。</p><h2 id="a7e0" class="lv lw it bd lx ly lz dn ma mb mc dp md kr me mf mg kv mh mi mj kz mk ml mm mn bi translated">停用词:模型中包含什么词汇？</h2><p id="4775" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">在帮助确定文档是否是垃圾邮件方面似乎没有什么价值的常见单词被完全从词汇表中排除。这些词被称为<em class="mu">停止词</em>。决定停止列表的一般策略是根据<em class="mu">收集频率</em>(每个术语在文档集合中出现的总次数)对术语进行排序，然后将最常见的术语作为<em class="mu">停止列表，这些术语有时根据它们相对于被分析文档的领域的含义进行手动过滤。</em>然后在索引过程中丢弃该非索引列表的成员。</p><p id="93a3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可以手动或自动将停用词添加到停用列表中。在 Scikit-learn 的计数矢量器中，有一个针对特定语料库的停用词的选项。您可以传递一个非索引词数组，或者使用最小和最大文档频率参数自动完成这个过程。</p><p id="489e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个简化的矩阵将训练得更快，甚至可以提高你的模型的准确性。</p><p id="4e88" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">缩小语料库对于减少模型的内存使用非常有用。这样会节省计算成本！</p><h2 id="86cb" class="lv lw it bd lx ly lz dn ma mb mc dp md kr me mf mg kv mh mi mj kz mk ml mm mn bi translated">计数矢量器</h2><p id="d08b" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">CountVectorizer 标记、矢量化并创建我们的非索引列表！所以我们要做的就是在模型管道中调用它。这个函数返回一个稀疏矩阵，我们将使用它来训练我们的 ML 模型。</p><h2 id="aac7" class="lv lw it bd lx ly lz dn ma mb mc dp md kr me mf mg kv mh mi mj kz mk ml mm mn bi translated">构建模型管道</h2><p id="2de0" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">机器学习<strong class="kk iu">管道</strong>用于帮助机器学习工作流程自动化。这些管道的运行方式是，在一个模型中对一系列数据进行转换和关联，只需一个代码步骤就可以对这些数据进行测试和评估。</p><p id="cf02" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，看看我们的朴素贝叶斯管道。</p><pre class="lg lh li lj gt mv mw mx my aw mz bi"><span id="573e" class="lv lw it mw b gy na nb l nc nd">nb = make_pipeline(<br/>    CountVectorizer(binary=<strong class="mw iu">True</strong>),<br/>    MultinomialNB()<br/>)</span></pre><p id="07bf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们只需调用<code class="fe nf ng nh mw b">make_pipline</code>，添加 CountVectorizer 和我们的模型，然后调用<code class="fe nf ng nh mw b">nb.fit</code>使用管道训练一个模型！</p><p id="3a76" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">机器学习算法通常涉及一系列任务，包括预处理、特征提取、模型拟合和验证阶段。管道帮助我们将这些任务整合在一起。</p><h2 id="a59e" class="lv lw it bd lx ly lz dn ma mb mc dp md kr me mf mg kv mh mi mj kz mk ml mm mn bi translated">模型度量:精确度和召回率</h2><p id="4060" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">我们如何判断哪种模型最有效地解决了这个问题？首先，让我们看看我们的一些模型分数，精度和召回率。</p><p id="9f2f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> Precision </strong>试图回答以下问题:</p><p id="8c45" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mu">实际上有多少比例的肯定认同是正确的？</em></p><p id="276d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Precision 测量被标记为垃圾邮件的<strong class="kk iu">邮件被正确分类的百分比。</strong></p><p id="43b8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">回想一下</strong>试图回答以下问题:</p><p id="6f47" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mu">正确识别实际阳性的比例是多少？</em></p><p id="4527" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">召回衡量被正确分类的实际垃圾邮件的百分比。</p><p id="6bbe" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要全面评估一个模型的有效性，你必须同时检查<strong class="kk iu">和</strong>精度和召回率。不幸的是，精确度和召回率经常处于紧张状态。也就是说，提高精度通常会降低召回率，反之亦然。</p><p id="45ba" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以你需要知道，对于你的问题，精确和召回哪个更重要？</p><p id="4756" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们来看看我们的两个模型。这里我们有朴素贝叶斯模型的分数。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/af691497fee1ad9c18075f90af0f25de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*LiVcTFBtzrxI9jMYrwfXvg.png"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">朴素贝叶斯</p></figure><p id="dcca" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是逻辑回归模型的分数。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/8c1fd978d04c192edcb0cc003001afde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1114/format:webp/1*PAXe3_KM8PZKYlycO8HWWw.png"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">逻辑回归</p></figure><p id="cda1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，除了垃圾邮件精确度这一项之外，NB 模型在所有方面都优于 LR 模型。我们不能说一个模型总是比另一个好，但我们可以更多地选择正确的那个。</p><h2 id="d5e2" class="lv lw it bd lx ly lz dn ma mb mc dp md kr me mf mg kv mh mi mj kz mk ml mm mn bi translated">保存您的模型</h2><p id="1a12" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">一旦你决定了一个模型，把它保存为一个. joblib，就像下面我们对朴素贝叶斯模型所做的那样。</p><pre class="lg lh li lj gt mv mw mx my aw mz bi"><span id="9ac6" class="lv lw it mw b gy na nb l nc nd">dump(nb, "clf.joblib")</span></pre><p id="ad67" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在您已经有了一个保存为 joblib 的垃圾邮件检测模型！</p><h2 id="adf8" class="lv lw it bd lx ly lz dn ma mb mc dp md kr me mf mg kv mh mi mj kz mk ml mm mn bi translated">结论</h2><p id="ea60" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">在这里，我们已经涵盖了基本的 NPL 概念，记号化，向量化和停用词。然后，我们在模型管道中使用这些概念和 CountVectorizer 来比较模型之间的度量。在决定了朴素贝叶斯分类器之后，我们将它保存为一个 joblib，供以后在我们的应用程序中使用。</p><p id="cd66" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">查看我们的<a class="ae le" href="https://github.com/edkrueger/spam-detector" rel="noopener ugc nofollow" target="_blank"> GitHub Repositor </a> y 中的代码，获取一个模板开始使用！</p><p id="0972" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要为您的模型提供应用程序并进行部署，请查看下面的进一步阅读资料！</p><p id="ca9c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本文讨论构建一个应用程序来服务我们的模型，以及如何将它部署到云中。我们涵盖了应用程序的构建和 docker 化，在 Google Container Registry 上存储 docker 映像，以及将应用程序部署到 Cloud run。</p><div class="nk nl gp gr nm nn"><a rel="noopener follow" target="_blank" href="/deploy-a-scikit-learn-nlp-model-with-docker-gcp-cloud-run-and-flask-ba958733997a"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd iu gy z fp ns fr fs nt fu fw is bi translated">使用 Docker、GCP 云运行和 Flask 部署 Scikit-Learn NLP 模型</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">构建一个服务于自然语言处理模型的应用程序，将其容器化并部署的简要指南。</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">towardsdatascience.com</p></div></div><div class="nw l"><div class="nx l ny nz oa nw ob lp nn"/></div></div></a></div></div></div>    
</body>
</html>