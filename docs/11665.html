<html>
<head>
<title>Data Structures &amp; Algorithms in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中的数据结构和算法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/data-structures-algorithms-in-python-68c8dbb19c90?source=collection_archive---------2-----------------------#2020-08-13">https://towardsdatascience.com/data-structures-algorithms-in-python-68c8dbb19c90?source=collection_archive---------2-----------------------#2020-08-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="52b0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">开始掌握数据结构和算法概述</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/13270ee656f11e557d074265d3e1b51e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mwbojLoUaYO3lXg95IfTQg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=62966" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae ky" href="https://pixabay.com/users/WikiImages-1897/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=62966" rel="noopener ugc nofollow" target="_blank">维基图片</a></p></figure><blockquote class="kz"><p id="1cca" class="la lb it bd lc ld le lf lg lh li lj dk translated">为了<!-- -->发展一个完整的头脑:研究艺术的科学；研究科学艺术。学会如何去看。意识到每件事都与其他事相关联。</p><p id="35ba" class="la lb it bd lc ld lk ll lm ln lo lj dk translated">列奥纳多·达· 芬奇</p></blockquote></div><div class="ab cl lp lq hx lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="im in io ip iq"><h2 id="bf3e" class="lw lx it bd ly lz ma dn mb mc md dp me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">介绍</h2><p id="f145" class="pw-post-body-paragraph ms mt it mu b mv mw ju mx my mz jx na mf nb nc nd mj ne nf ng mn nh ni nj lj im bi translated">这篇文章的目的是给你一个 Python 中数据结构和算法的全景。对于数据科学家来说，这个主题非常重要，可以帮助他或她以更有效的方式设计和解决机器学习模型。</p><p id="9922" class="pw-post-body-paragraph ms mt it mu b mv nk ju mx my nl jx na mf nm nc nd mj nn nf ng mn no ni nj lj im bi translated">我们将看到内置数据结构、用户定义数据结构的实际例子，最后但同样重要的是，我将向您介绍一些算法，如遍历算法、排序算法和搜索算法。</p><p id="89d9" class="pw-post-body-paragraph ms mt it mu b mv nk ju mx my nl jx na mf nm nc nd mj nn nf ng mn no ni nj lj im bi translated">所以，让我们开始吧！</p></div><div class="ab cl lp lq hx lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="im in io ip iq"><h2 id="86ed" class="lw lx it bd ly lz ma dn mb mc md dp me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">第一部分:内置数据结构</h2><p id="d8e4" class="pw-post-body-paragraph ms mt it mu b mv mw ju mx my mz jx na mf nb nc nd mj ne nf ng mn nh ni nj lj im bi translated">顾名思义，数据结构允许我们组织、存储和管理数据，以便有效地访问和修改。</p><p id="66dc" class="pw-post-body-paragraph ms mt it mu b mv nk ju mx my nl jx na mf nm nc nd mj nn nf ng mn no ni nj lj im bi translated">在这一部分，我们将看看内置的数据结构。Python 中有四种类型的内置数据结构:列表、元组、集合和字典。</p><p id="3c27" class="pw-post-body-paragraph ms mt it mu b mv nk ju mx my nl jx na mf nm nc nd mj nn nf ng mn no ni nj lj im bi translated"><strong class="mu iu"> <em class="np">列表</em> </strong></p><p id="69c2" class="pw-post-body-paragraph ms mt it mu b mv nk ju mx my nl jx na mf nm nc nd mj nn nf ng mn no ni nj lj im bi translated">列表是用方括号定义的，包含用逗号分隔的数据。该列表是可变的和有序的。它可以包含不同数据类型的混合。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="29c3" class="pw-post-body-paragraph ms mt it mu b mv nk ju mx my nl jx na mf nm nc nd mj nn nf ng mn no ni nj lj im bi translated">出局:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="ef7c" class="lw lx it nt b gy nx ny l nz oa">january</span><span id="9de1" class="lw lx it nt b gy ob ny l nz oa">['january', 'february', 'march', 'april', 'may', 'june', 'july']</span><span id="c047" class="lw lx it nt b gy ob ny l nz oa">['birthday', 'february', 'march', 'april', 'may', 'june', 'july', 'august', 'september', 'october', 'november', 'december']</span></pre><p id="80d7" class="pw-post-body-paragraph ms mt it mu b mv nk ju mx my nl jx na mf nm nc nd mj nn nf ng mn no ni nj lj im bi translated">下面是列表中一些有用的函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="c081" class="pw-post-body-paragraph ms mt it mu b mv nk ju mx my nl jx na mf nm nc nd mj nn nf ng mn no ni nj lj im bi translated">出局:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="8969" class="lw lx it nt b gy nx ny l nz oa">What<br/>is<br/>your<br/>favourite<br/>painting<br/>?</span><span id="4215" class="lw lx it nt b gy ob ny l nz oa">Who-is-your-favourite-artist-?</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="980a" class="pw-post-body-paragraph ms mt it mu b mv nk ju mx my nl jx na mf nm nc nd mj nn nf ng mn no ni nj lj im bi translated">出局:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="9557" class="lw lx it nt b gy nx ny l nz oa">['Chagall', 'Kandinskij', 'Dalí', 'da Vinci', 'Picasso', 'Warhol', 'Basquiat']</span></pre><p id="42c0" class="pw-post-body-paragraph ms mt it mu b mv nk ju mx my nl jx na mf nm nc nd mj nn nf ng mn no ni nj lj im bi translated"><strong class="mu iu"> <em class="np">元组</em> </strong></p><p id="d148" class="pw-post-body-paragraph ms mt it mu b mv nk ju mx my nl jx na mf nm nc nd mj nn nf ng mn no ni nj lj im bi translated">元组是另一种容器。它是不可变有序元素序列的数据类型。不可变的，因为你不能从元组中添加和删除元素，或者就地排序。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="0a13" class="pw-post-body-paragraph ms mt it mu b mv nk ju mx my nl jx na mf nm nc nd mj nn nf ng mn no ni nj lj im bi translated">出局:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="a49d" class="lw lx it nt b gy nx ny l nz oa">The dimensions are 7 x 3 x 1</span></pre><p id="96a2" class="pw-post-body-paragraph ms mt it mu b mv nk ju mx my nl jx na mf nm nc nd mj nn nf ng mn no ni nj lj im bi translated"><strong class="mu iu"> <em class="np">设置</em> </strong></p><p id="7204" class="pw-post-body-paragraph ms mt it mu b mv nk ju mx my nl jx na mf nm nc nd mj nn nf ng mn no ni nj lj im bi translated">集合是唯一元素的可变且无序的集合。它可以让我们快速地从列表中删除重复项。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="b2bc" class="pw-post-body-paragraph ms mt it mu b mv nk ju mx my nl jx na mf nm nc nd mj nn nf ng mn no ni nj lj im bi translated">出局:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="52fb" class="lw lx it nt b gy nx ny l nz oa">{1, 2, 3, 5, 6}<br/>False<br/>Basquiat</span></pre><p id="3bc3" class="pw-post-body-paragraph ms mt it mu b mv nk ju mx my nl jx na mf nm nc nd mj nn nf ng mn no ni nj lj im bi translated"><strong class="mu iu"> <em class="np">字典</em> </strong></p><p id="7c56" class="pw-post-body-paragraph ms mt it mu b mv nk ju mx my nl jx na mf nm nc nd mj nn nf ng mn no ni nj lj im bi translated">字典是一种可变的无序的数据结构。它允许存储一对项(即键和值)。</p><p id="a2ae" class="pw-post-body-paragraph ms mt it mu b mv nk ju mx my nl jx na mf nm nc nd mj nn nf ng mn no ni nj lj im bi translated">如下例所示，在字典中，可以将容器包含到其他容器中以创建复合数据结构。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="f16a" class="pw-post-body-paragraph ms mt it mu b mv nk ju mx my nl jx na mf nm nc nd mj nn nf ng mn no ni nj lj im bi translated">出局:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="d030" class="lw lx it nt b gy nx ny l nz oa">In a Sentimental Mood<br/>Lacrimosa</span></pre></div><div class="ab cl lp lq hx lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="im in io ip iq"><h2 id="5252" class="lw lx it bd ly lz ma dn mb mc md dp me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">第二部分:用户定义的数据结构</h2><p id="8b3d" class="pw-post-body-paragraph ms mt it mu b mv mw ju mx my mz jx na mf nb nc nd mj ne nf ng mn nh ni nj lj im bi translated">现在我将向您介绍三种用户定义的数据结构:ques、stack 和 tree。我假设您对类和函数有基本的了解。</p><p id="be57" class="pw-post-body-paragraph ms mt it mu b mv nk ju mx my nl jx na mf nm nc nd mj nn nf ng mn no ni nj lj im bi translated"><strong class="mu iu"> <em class="np">堆栈使用数组</em> </strong></p><p id="1524" class="pw-post-body-paragraph ms mt it mu b mv nk ju mx my nl jx na mf nm nc nd mj nn nf ng mn no ni nj lj im bi translated">堆栈是一种线性数据结构，其中元素按顺序排列。它遵循 L.I.F.O 的机制，意思是后进先出。因此，最后插入的元素将作为第一个元素被删除。这些操作是:</p><ul class=""><li id="3366" class="oc od it mu b mv nk my nl mf oe mj of mn og lj oh oi oj ok bi translated">Push →将元素插入堆栈</li><li id="e5e2" class="oc od it mu b mv ol my om mf on mj oo mn op lj oh oi oj ok bi translated">Pop →从堆栈中删除元素</li></ul><p id="87e6" class="pw-post-body-paragraph ms mt it mu b mv nk ju mx my nl jx na mf nm nc nd mj nn nf ng mn no ni nj lj im bi translated">要检查的条件:</p><ul class=""><li id="4f96" class="oc od it mu b mv nk my nl mf oe mj of mn og lj oh oi oj ok bi translated">溢出情况→当我们试图将一个元素放入已经具有最大元素数的堆栈时，就会出现这种情况。</li><li id="ff55" class="oc od it mu b mv ol my om mf on mj oo mn op lj oh oi oj ok bi translated">下溢情况→当我们试图从空堆栈中删除一个元素时，就会出现这种情况。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="3b25" class="pw-post-body-paragraph ms mt it mu b mv nk ju mx my nl jx na mf nm nc nd mj nn nf ng mn no ni nj lj im bi translated">出局:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="ed9a" class="lw lx it nt b gy nx ny l nz oa">5<br/>True<br/>[10, 23, 25, 27, 11]<br/>overflow<br/>11<br/>27<br/>25<br/>23<br/>10<br/>underflow</span></pre><p id="f280" class="pw-post-body-paragraph ms mt it mu b mv nk ju mx my nl jx na mf nm nc nd mj nn nf ng mn no ni nj lj im bi translated"><strong class="mu iu"> <em class="np">队列使用数组</em> </strong></p><p id="c6b5" class="pw-post-body-paragraph ms mt it mu b mv nk ju mx my nl jx na mf nm nc nd mj nn nf ng mn no ni nj lj im bi translated">队列是一种线性数据结构，其中的元素按顺序排列。它遵循先进先出的 F.I.F.O 机制。想想当你和你的朋友去电影院时，你可以想象第一个给你票的人也是第一个站出来的人。队列的机制是相同的。</p><p id="bb2c" class="pw-post-body-paragraph ms mt it mu b mv nk ju mx my nl jx na mf nm nc nd mj nn nf ng mn no ni nj lj im bi translated">描述队列特征的方面。</p><p id="f380" class="pw-post-body-paragraph ms mt it mu b mv nk ju mx my nl jx na mf nm nc nd mj nn nf ng mn no ni nj lj im bi translated">两端:</p><ul class=""><li id="dfd6" class="oc od it mu b mv nk my nl mf oe mj of mn og lj oh oi oj ok bi translated">正面→指向起始元素</li><li id="913d" class="oc od it mu b mv ol my om mf on mj oo mn op lj oh oi oj ok bi translated">后→指向最后一个元素</li></ul><p id="bf2b" class="pw-post-body-paragraph ms mt it mu b mv nk ju mx my nl jx na mf nm nc nd mj nn nf ng mn no ni nj lj im bi translated">有两种操作:</p><ul class=""><li id="925d" class="oc od it mu b mv nk my nl mf oe mj of mn og lj oh oi oj ok bi translated">入队→将元素插入队列。它将在后方完成。</li><li id="fb8e" class="oc od it mu b mv ol my om mf on mj oo mn op lj oh oi oj ok bi translated">出列→从队列中删除元素。这将在前线完成。</li></ul><p id="1d04" class="pw-post-body-paragraph ms mt it mu b mv nk ju mx my nl jx na mf nm nc nd mj nn nf ng mn no ni nj lj im bi translated">有两个条件:</p><ul class=""><li id="7f5c" class="oc od it mu b mv nk my nl mf oe mj of mn og lj oh oi oj ok bi translated">溢出→插入到已满的队列中</li><li id="4e34" class="oc od it mu b mv ol my om mf on mj oo mn op lj oh oi oj ok bi translated">下溢→从空队列中删除</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="26fb" class="pw-post-body-paragraph ms mt it mu b mv nk ju mx my nl jx na mf nm nc nd mj nn nf ng mn no ni nj lj im bi translated">出局:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="0283" class="lw lx it nt b gy nx ny l nz oa">[2, 3, 4, 5]<br/>[3, 4, 5]</span></pre><p id="1cd0" class="pw-post-body-paragraph ms mt it mu b mv nk ju mx my nl jx na mf nm nc nd mj nn nf ng mn no ni nj lj im bi translated"><strong class="mu iu">树<em class="np">(一般树)</em>树</strong></p><p id="7e97" class="pw-post-body-paragraph ms mt it mu b mv nk ju mx my nl jx na mf nm nc nd mj nn nf ng mn no ni nj lj im bi translated">树用于定义层次结构。它从根节点开始，再往下，最后的节点称为子节点。</p><p id="b3ec" class="pw-post-body-paragraph ms mt it mu b mv nk ju mx my nl jx na mf nm nc nd mj nn nf ng mn no ni nj lj im bi translated">在本文中，我主要关注二叉树。二叉树是一种树形数据结构，其中每个节点最多有两个孩子，称为左孩子和右孩子。下面你可以看到一个用 python 编写的二叉树的表示和例子，其中我构建了一个名为<strong class="mu iu"> Node </strong>的类和表示不同节点(A、B、C、D 和 E)的对象。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/ee6e829956e811b6d857a32b536930c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/1*-OMyiuIn8hS_NbF0bDUZ5Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="5c56" class="pw-post-body-paragraph ms mt it mu b mv nk ju mx my nl jx na mf nm nc nd mj nn nf ng mn no ni nj lj im bi translated">无论如何，还有其他用户定义的数据结构，如<strong class="mu iu">链表</strong>和<strong class="mu iu">图。</strong></p></div><div class="ab cl lp lq hx lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="im in io ip iq"><h2 id="b6be" class="lw lx it bd ly lz ma dn mb mc md dp me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">第三部分:算法</h2><p id="76ca" class="pw-post-body-paragraph ms mt it mu b mv mw ju mx my mz jx na mf nb nc nd mj ne nf ng mn nh ni nj lj im bi translated">算法的概念自古就有。事实上，古埃及人使用算法来解决他们的问题。然后他们把这种方法传授给希腊人。</p><p id="61de" class="pw-post-body-paragraph ms mt it mu b mv nk ju mx my nl jx na mf nm nc nd mj nn nf ng mn no ni nj lj im bi translated">algorithm 一词源自 9 世纪波斯数学家 muḥammad·伊本·穆斯哈勒·赫瓦·里兹姆，他的名字拉丁化为 Algorithmi。Al-Khwārizm 也是一名天文学家、地理学家和巴格达智慧之家的学者。</p><p id="32b4" class="pw-post-body-paragraph ms mt it mu b mv nk ju mx my nl jx na mf nm nc nd mj nn nf ng mn no ni nj lj im bi translated">正如你已经知道的，算法是以有限的顺序来解决问题的指令。</p><p id="1365" class="pw-post-body-paragraph ms mt it mu b mv nk ju mx my nl jx na mf nm nc nd mj nn nf ng mn no ni nj lj im bi translated">当我们编写一个算法时，我们必须知道确切的问题是什么，确定我们需要从哪里开始和停止，并制定中间步骤。</p><p id="1a0d" class="pw-post-body-paragraph ms mt it mu b mv nk ju mx my nl jx na mf nm nc nd mj nn nf ng mn no ni nj lj im bi translated">有三种解决算法的主要方法:</p><ul class=""><li id="d89f" class="oc od it mu b mv nk my nl mf oe mj of mn og lj oh oi oj ok bi translated">Divide et Impera(也称为分而治之)→它将问题分成子部分，并分别解决每个子部分</li><li id="ef7d" class="oc od it mu b mv ol my om mf on mj oo mn op lj oh oi oj ok bi translated">动态规划→它将问题分成子部分，记住子部分的结果，并将其应用于类似的问题</li><li id="4a3f" class="oc od it mu b mv ol my om mf on mj oo mn op lj oh oi oj ok bi translated">贪婪算法→解决问题时采取最简单的步骤，而不用担心未来步骤的复杂性</li></ul><p id="e556" class="pw-post-body-paragraph ms mt it mu b mv nk ju mx my nl jx na mf nm nc nd mj nn nf ng mn no ni nj lj im bi translated"><strong class="mu iu">树遍历算法</strong></p><p id="c81b" class="pw-post-body-paragraph ms mt it mu b mv nk ju mx my nl jx na mf nm nc nd mj nn nf ng mn no ni nj lj im bi translated">python 中的树是非线性数据结构。它们以根和节点为特征。我用之前为二叉树构造的类。</p><p id="5f62" class="pw-post-body-paragraph ms mt it mu b mv nk ju mx my nl jx na mf nm nc nd mj nn nf ng mn no ni nj lj im bi translated">树遍历指的是恰好访问树中的每个节点一次，以便更新或检查它们。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/ee6e829956e811b6d857a32b536930c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/1*-OMyiuIn8hS_NbF0bDUZ5Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="184b" class="pw-post-body-paragraph ms mt it mu b mv nk ju mx my nl jx na mf nm nc nd mj nn nf ng mn no ni nj lj im bi translated">有三种类型的树遍历:</p><ul class=""><li id="5da7" class="oc od it mu b mv nk my nl mf oe mj of mn og lj oh oi oj ok bi translated">有序遍历→指的是先访问左边的节点，然后是根，再是右边的节点。</li></ul><p id="60a6" class="pw-post-body-paragraph ms mt it mu b mv nk ju mx my nl jx na mf nm nc nd mj nn nf ng mn no ni nj lj im bi translated">这里 D 是最左边的节点，其中最近的根是 B .根 B 的右边是 e .现在左边的子树完成了，所以我向根节点 A 移动，然后到节点 c。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="3731" class="pw-post-body-paragraph ms mt it mu b mv nk ju mx my nl jx na mf nm nc nd mj nn nf ng mn no ni nj lj im bi translated">出局:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="6e13" class="lw lx it nt b gy nx ny l nz oa">D<br/>B<br/>E<br/>A<br/>C</span></pre><ul class=""><li id="dda5" class="oc od it mu b mv nk my nl mf oe mj of mn og lj oh oi oj ok bi translated">前序遍历→指的是先访问根节点，然后是左节点，再是右节点。</li></ul><p id="8bbe" class="pw-post-body-paragraph ms mt it mu b mv nk ju mx my nl jx na mf nm nc nd mj nn nf ng mn no ni nj lj im bi translated">在这种情况下，我移动到根节点 A，然后移动到左边的子节点 B 和子节点 d。之后，我可以转到节点 E，然后是节点 c。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="7243" class="pw-post-body-paragraph ms mt it mu b mv nk ju mx my nl jx na mf nm nc nd mj nn nf ng mn no ni nj lj im bi translated">出局:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="0817" class="lw lx it nt b gy nx ny l nz oa">A<br/>B<br/>D<br/>E<br/>C</span></pre><ul class=""><li id="cc8b" class="oc od it mu b mv nk my nl mf oe mj of mn og lj oh oi oj ok bi translated">后序遍历→指的是先访问左边的节点，然后是右边的节点，最后是根节点</li></ul><p id="55b1" class="pw-post-body-paragraph ms mt it mu b mv nk ju mx my nl jx na mf nm nc nd mj nn nf ng mn no ni nj lj im bi translated">我到最左边的节点 D，然后到右边的节点 e，然后，我可以从左边的节点 B 到右边的节点 c，最后，我向根节点 a 移动。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="886a" class="pw-post-body-paragraph ms mt it mu b mv nk ju mx my nl jx na mf nm nc nd mj nn nf ng mn no ni nj lj im bi translated">出局:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="acd5" class="lw lx it nt b gy nx ny l nz oa">D<br/>E<br/>B<br/>C<br/>A</span></pre><p id="c2a5" class="pw-post-body-paragraph ms mt it mu b mv nk ju mx my nl jx na mf nm nc nd mj nn nf ng mn no ni nj lj im bi translated"><strong class="mu iu">排序算法</strong></p><p id="82cc" class="pw-post-body-paragraph ms mt it mu b mv nk ju mx my nl jx na mf nm nc nd mj nn nf ng mn no ni nj lj im bi translated">排序算法用于按照给定的顺序对数据进行排序。可分为归并排序和冒泡排序。</p><ul class=""><li id="5e0e" class="oc od it mu b mv nk my nl mf oe mj of mn og lj oh oi oj ok bi translated">归并排序→遵循<strong class="mu iu">分治规则</strong>。给定的列表首先被划分成更小的列表，并比较相邻的列表，然后按照所需的顺序对它们进行重新排序。因此，从作为输入的无序元素总结，我们需要有作为输出的有序元素。下面是描述每个步骤的代码。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="58c1" class="pw-post-body-paragraph ms mt it mu b mv nk ju mx my nl jx na mf nm nc nd mj nn nf ng mn no ni nj lj im bi translated">出局:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="1d77" class="lw lx it nt b gy nx ny l nz oa">input - unordered elements: 15 1 19 93<br/>output - ordered elements: <br/>[1, 15, 19, 93]</span></pre><ul class=""><li id="0ce8" class="oc od it mu b mv nk my nl mf oe mj of mn og lj oh oi oj ok bi translated">冒泡排序→它首先比较相邻的元素，如果它们没有按照指定的顺序排序，则进行排序。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="7789" class="pw-post-body-paragraph ms mt it mu b mv nk ju mx my nl jx na mf nm nc nd mj nn nf ng mn no ni nj lj im bi translated">出局:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="ef0a" class="lw lx it nt b gy nx ny l nz oa">[1, 3, 9, 15]</span></pre><ul class=""><li id="3136" class="oc od it mu b mv nk my nl mf oe mj of mn og lj oh oi oj ok bi translated">插入排序→它在给定的列表中选择一个条目，并把它放在应该放的地方。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="5168" class="pw-post-body-paragraph ms mt it mu b mv nk ju mx my nl jx na mf nm nc nd mj nn nf ng mn no ni nj lj im bi translated">出局:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="49e4" class="lw lx it nt b gy nx ny l nz oa">[1, 3, 9, 15]</span></pre><p id="488f" class="pw-post-body-paragraph ms mt it mu b mv nk ju mx my nl jx na mf nm nc nd mj nn nf ng mn no ni nj lj im bi translated">还有其他排序算法像<strong class="mu iu">选择排序</strong>和<strong class="mu iu">外壳排序</strong>。</p><p id="5662" class="pw-post-body-paragraph ms mt it mu b mv nk ju mx my nl jx na mf nm nc nd mj nn nf ng mn no ni nj lj im bi translated"><strong class="mu iu">搜索算法</strong></p><p id="3901" class="pw-post-body-paragraph ms mt it mu b mv nk ju mx my nl jx na mf nm nc nd mj nn nf ng mn no ni nj lj im bi translated">搜索算法用于寻找给定数据集中存在的一些元素。有许多类型的搜索算法，如线性搜索，二分搜索法，指数搜索，插值搜索，等等。在这一节，我们将看到线性搜索和二分搜索法。</p><ul class=""><li id="b34e" class="oc od it mu b mv nk my nl mf oe mj of mn og lj oh oi oj ok bi translated">线性搜索→在一维数组中，我们必须搜索特定的关键元素。输入是我们想要找到的一组元素和关键元素。因此，我们必须将关键元素与组中的每个元素进行比较。在下面的代码中，我尝试在列表中查找元素 27。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="87a6" class="pw-post-body-paragraph ms mt it mu b mv nk ju mx my nl jx na mf nm nc nd mj nn nf ng mn no ni nj lj im bi translated">出局:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="e8df" class="lw lx it nt b gy nx ny l nz oa">'not fund'</span></pre><ul class=""><li id="fd8a" class="oc od it mu b mv nk my nl mf oe mj of mn og lj oh oi oj ok bi translated">二分搜索法→在这个算法中，我们假设列表是升序排列的。因此，如果搜索关键字的值小于列表中间的元素，我们将区间缩小到下半部分。否则，我们缩小到上半部分。我们继续检查，直到找到值或者列表为空。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="a658" class="pw-post-body-paragraph ms mt it mu b mv nk ju mx my nl jx na mf nm nc nd mj nn nf ng mn no ni nj lj im bi translated">出局:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="38b4" class="lw lx it nt b gy nx ny l nz oa">False<br/>True</span></pre></div><div class="ab cl lp lq hx lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="im in io ip iq"><h2 id="03dd" class="lw lx it bd ly lz ma dn mb mc md dp me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">结论</h2><p id="081e" class="pw-post-body-paragraph ms mt it mu b mv mw ju mx my mz jx na mf nb nc nd mj ne nf ng mn nh ni nj lj im bi translated">现在你对数据结构和算法有了一个大概的了解。所以，你可以开始深入理解算法。</p><p id="9fa1" class="pw-post-body-paragraph ms mt it mu b mv nk ju mx my nl jx na mf nm nc nd mj nn nf ng mn no ni nj lj im bi translated">我为这篇文章选择的维特鲁威人的美丽形象不是随便的。这幅画是基于理想人体与几何学的关系。事实上，对于这种表现，达芬奇受到了维特鲁威斯的启发，他将人的身体描述为确定建筑中正确比例的理想身体。</p><p id="ab2f" class="pw-post-body-paragraph ms mt it mu b mv nk ju mx my nl jx na mf nm nc nd mj nn nf ng mn no ni nj lj im bi translated">关于算法，维特鲁威人隐藏了一个秘密算法，这个算法被艺术家们使用了几个世纪，以证明他们的作品受到了神圣比例的启发。</p><p id="20b2" class="pw-post-body-paragraph ms mt it mu b mv nk ju mx my nl jx na mf nm nc nd mj nn nf ng mn no ni nj lj im bi translated">有时候我喜欢想，也许达芬奇，通过他的精彩作品，想要定义最重要的算法，也就是生命的算法。</p></div><div class="ab cl lp lq hx lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="im in io ip iq"><p id="2391" class="pw-post-body-paragraph ms mt it mu b mv nk ju mx my nl jx na mf nm nc nd mj nn nf ng mn no ni nj lj im bi translated">感谢你阅读这篇文章。您还可以通过其他方式与我保持联系并关注我的工作:</p><ul class=""><li id="a8ac" class="oc od it mu b mv nk my nl mf oe mj of mn og lj oh oi oj ok bi translated"><a class="ae ky" href="https://upscri.be/wxv1zi" rel="noopener ugc nofollow" target="_blank">订阅</a>我的时事通讯。</li><li id="501d" class="oc od it mu b mv ol my om mf on mj oo mn op lj oh oi oj ok bi translated">也可以通过我的电报群<a class="ae ky" href="https://t.me/DataScienceForBeginners" rel="noopener ugc nofollow" target="_blank"> <em class="np">初学数据科学</em> </a>联系。</li></ul></div></div>    
</body>
</html>