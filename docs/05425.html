<html>
<head>
<title>Data-Driven T-SQL Business Rules</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据驱动的T-SQL业务规则</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/data-driven-t-sql-business-rules-9ac1e6ad3b4a?source=collection_archive---------27-----------------------#2020-05-07">https://towardsdatascience.com/data-driven-t-sql-business-rules-9ac1e6ad3b4a?source=collection_archive---------27-----------------------#2020-05-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="395e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">创建具有动态和可互换业务规则的数据验证器，或者为什么(T-) SQL比我们愿意承认的更强大</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/dcb4522362dec387d45c27ae23f1b666.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3ncr-LNUinALRCV7Sh2vaA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://www.pngjoy.com/preview/f9m4w4v8d8x8f0_web-development-images-full-stack-development-hd-png/" rel="noopener ugc nofollow" target="_blank">图片由PNGJoy提供</a></p></figure><p id="db99" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">硬编码。我敢肯定，在这一点上，你已经听说了使用它将如何把你带到编码器的地狱。专家似乎建议尽可能避免它。那么，为什么我们的大多数查询都是硬编码的呢？如果我们能够以一种集中的、可互换的方式指定查询的谓词，会怎么样？让我们看看(T-)SQL到底有多动态。</p><p id="72d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，请注意，这可能不是一个好主意，但无论如何让我们玩得开心点。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="ce1e" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">什么？</h1><p id="6207" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">为了说明数据驱动约束引入的可能性，我们将创建一个数据验证器，它强制执行一组约束(不要与SQL自身的约束混淆)、业务规则或简单的阈值，这些都是在表上定义的。此外，同样的模型可以扩展到定义您的<em class="mw"> where </em>谓词，或者您的查询的任何部分。如果任何人发现这个帖子相关——怀疑——我会用这个扩展名创建另一个帖子。</p><p id="afbc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的最终目标是获得一个存储过程，它允许用户根据一组给定的动态规则来验证给定的条目。例如，验证值50是否符合规则集ID 2，并检索相关的输出代码:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="5870" class="nc ma iq my b gy nd ne l nf ng">exec ValidateThreshold 2, ‘50’, @returned_code OUTPUT;</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="3b50" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">为什么？</h1><p id="c99c" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">首先，你到底为什么要这么做？谁会将业务规则硬编码到数据库的查询中呢？事实证明我们大多数人。从数据模型的接近到职责的分离，有很多理由说明为什么需要这样做。</p><p id="18b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑一个拍卖网站的例子。如今，你有一条规则，规定你只接受不低于0.05的出价。如果明天你想把所说的价值改成产品估价的0.01%到10%之间的任何值呢？是否要更改包含新约束的每个过程、视图、触发器或查询？好吧，希望在这篇文章之后，你不用再这样做了。</p><p id="fc63" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实际上，我们引入了一个简单的模型，在实践中，拥有一个规则集表是有意义的，它创建了要应用的规则组。</p><p id="8224" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">需要做一个介绍性的说明，我绝不是SQL专家——我相信你已经注意到了——相反，我只是一个极其懒惰的人，喜欢想方设法避免手工劳动。希望它也能帮助你的懒惰性格。请务必阅读结尾部分，它可能是整篇文章中最重要的部分。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="a927" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">怎么会？</h1><p id="7704" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">第一步是实际构建您的规则或阈值。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="c8b3" class="nc ma iq my b gy nd ne l nf ng">Create table Threshold<br/>(<br/> ThresholdID int identity not null,<br/> ThresholdSetID int not null,<br/> VarName varchar(20) not null,<br/> Operator varchar(2) not null,<br/> TargetValue varchar(50) not null,<br/> [Description] varchar(100) not null,<br/> ThresholdOrder int not null,<br/> Deprecated bit not null default 0,</span><span id="3d38" class="nc ma iq my b gy nh ne l nf ng">primary key (ThresholdID)<br/>);</span></pre><p id="7c22" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并用一组虚拟内容填充它:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="5aae" class="nc ma iq my b gy nd ne l nf ng">insert into Threshold values (1, '@input', '&gt;=', '25', 'dbo.InsertAuctionBid(...)', 1, 0);</span><span id="8cbd" class="nc ma iq my b gy nh ne l nf ng">insert into Threshold values (1, '@input', '&lt;', '(select max(value) from dbo.AuctionDates)', 'dbo.InsertAuctionBid(...)', 2, 0);</span></pre><p id="ac07" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意rows<em class="mw">@如何输入</em>参数，该参数表示要验证的值。第一个规则将确保我们的参数大于或等于25的<strong class="ky ir">，而第二个规则确保传递的参数小于AuctionDates表中的最大日期</strong>的<strong class="ky ir">。</strong></p><p id="d7dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">进入验证程序！</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="75b1" class="nc ma iq my b gy nd ne l nf ng">create procedure dbo.ValidateThreshold<br/>(<br/> @thresholdID int,<br/> @input nvarchar(50),<br/> @return_code int OUTPUT<br/>)<br/>as<br/> if @thresholdID is null <br/> begin<br/>  set @return_code = 2;<br/>  return;<br/> end</span><span id="a94d" class="nc ma iq my b gy nh ne l nf ng">if @input is null  <br/> begin<br/>  set @return_code = 2;<br/>  return;<br/> end</span><span id="89ee" class="nc ma iq my b gy nh ne l nf ng">declare @statement nvarchar(max), @where_clause nvarchar(max);</span><span id="0a34" class="nc ma iq my b gy nh ne l nf ng">set @where_clause = stuff((<br/>  select '  and '+ VarName +' '+ Operator  +' ' + TargetValue +char(10)<br/>  from <br/>   Threshold<br/>  where<br/>   ThresholdID in (@thresholdID)<br/>  order by <br/>   thresholdOrder<br/>  for xml path (''), type).value('.','nvarchar(max)')<br/>  ,1,6,'');</span><span id="3276" class="nc ma iq my b gy nh ne l nf ng">set @statement = 'if exists(select 1 '+char(10)+'where '+ @where_clause + char(10) + ') select 0; else select 1;';</span><span id="bf6b" class="nc ma iq my b gy nh ne l nf ng">set @statement = replace(@statement, '@input', @input)</span><span id="2735" class="nc ma iq my b gy nh ne l nf ng">exec sp_executesql<br/>  @query = @statement<br/>  ,@params = N'@return_code INT OUTPUT'<br/>  ,@return_code = @return_code OUTPUT;</span></pre><p id="1cbc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于我们这些SQL新手来说，有很多东西需要理解，所以让我们把它分成几个部分。</p><p id="2c7c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的过程应该有三个参数:2个输入和1个输出。要应用的规则；要验证的参数，格式为文本。最后是操作的输出代码，0表示成功，任何不同都表示特定的错误代码。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="bb1f" class="nc ma iq my b gy nd ne l nf ng">create procedure dbo.ValidateThreshold<br/>(<br/>  @thresholdGroup int,<br/>  @input nvarchar(50),<br/>  @return_code int OUTPUT<br/>)</span></pre><p id="64ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，验证我们的输入并返回一个适当的错误代码</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="6f3f" class="nc ma iq my b gy nd ne l nf ng">as<br/> if @thresholdID is null <br/> begin<br/>  set @return_code = 2;<br/>  return;<br/> end</span><span id="840f" class="nc ma iq my b gy nh ne l nf ng">if @input is null  <br/> begin<br/>  set @return_code = 2;<br/>  return;<br/> end</span></pre><p id="09c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">到目前为止一切顺利。果汁来了</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="ae30" class="nc ma iq my b gy nd ne l nf ng">declare @statement nvarchar(max), @where_clause nvarchar(max);</span><span id="b342" class="nc ma iq my b gy nh ne l nf ng">-- Generate the underlying where clause by concatenatinc the Variable to test, the boolean operator and the test predicate<br/> -- using XML PATH to repeat the whole process, gluing subsequent predicates with an ' and'.<br/> -- Lastly, use stuff to collapse it all together, removing the first 6 characters (corresponding to ' and') starting on the first position.<br/> -- Note: If more than a @thresholdID is provided, the predicates will be passed according to Threshold.ThresholdOrder</span><span id="cd25" class="nc ma iq my b gy nh ne l nf ng"> set @where_clause = stuff((<br/>  select '  and '+ VarName +' '+ Operator  +' ' + TargetValue +char(10)<br/>  from <br/>   Threshold<br/>  where<br/>   ThresholdID in (@thresholdID)<br/>  order by <br/>   thresholdOrder<br/>  for xml path (''), type).value('.','nvarchar(max)')<br/>  ,1,6,'');</span><span id="ca68" class="nc ma iq my b gy nh ne l nf ng">set @statement = 'if exists(select 1 '+char(10)+'where '+@where_clause + char(10) + ') select 0; else select 1;';</span><span id="114d" class="nc ma iq my b gy nh ne l nf ng">-- Feed the input variable<br/> set @statement = replace(@statement, '@input', @input)</span><span id="9ddf" class="nc ma iq my b gy nh ne l nf ng">exec sp_executesql<br/>  @query = @statement<br/>  ,@params = N'@input nvarchar(50), @return_code INT OUTPUT'<br/>  ,@input = @value<br/>  ,@return_code = @return_code OUTPUT;</span></pre><h2 id="6c36" class="nc ma iq bd mb ni nj dn mf nk nl dp mj lf nm nn ml lj no np mn ln nq nr mp ns bi translated">那么这是如何工作的呢？</h2><p id="f3d9" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated"><a class="ae kv" href="https://docs.microsoft.com/en-us/sql/relational-databases/xml/for-xml-sql-server?view=sql-server-ver15" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> FOR XML PATH </strong> </a>顾名思义，允许您将查询结果转换成XML文件。但是，通过将一个空字符串传递给RAW参数，我们为返回的数据创建了一个串联的字符串。考虑以下用户表:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="43d2" class="nc ma iq my b gy nd ne l nf ng">╔═══════════╗<br/>║   Name    ║<br/>╠═══════════╣<br/>║ John      ║<br/>║ Mary      ║<br/>║ William   ║<br/>║ Anthony   ║<br/>╚═══════════╩</span></pre><p id="58c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">应用于前一个表:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="5147" class="nc ma iq my b gy nd ne l nf ng">select ','+ name <br/>        from Users<br/>        FOR XML PATH('')</span><span id="ac37" class="nc ma iq my b gy nh ne l nf ng">Output: ‘,John, Mary, William, Anthony’</span></pre><p id="7c40" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意尾部的逗号，它虽然允许我们创建逗号分隔的字符串，但会完全破坏SQL语句。在我们的例子中，我们输入了一个<em class="mw">和</em>关键字，而不是逗号，这样我们就可以将多个子句粘在一起。</p><p id="0e79" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们首先调用<a class="ae kv" href="https://docs.microsoft.com/en-us/sql/t-sql/xml/value-method-xml-data-type?view=sql-server-ver15" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> value() </strong> </a>函数将XML对象转换成字符串。然后，我们使用<a class="ae kv" href="https://docs.microsoft.com/en-us/sql/t-sql/functions/stuff-transact-sql?view=sql-server-ver15" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> STUFF() </strong> </a>函数检索逗号，或者在我们的例子中，检索6个字符，以从生成的字符串中删除‘and’部分。</p><p id="7417" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下一步是将生成的<em class="mw"> where </em>子句传递给一个布尔语句，使用<em class="mw"> Exists </em>来测试返回的存在。如果返回为1，则<em class="mw">@输入</em>有效，但是如果返回为空，则<em class="mw">@输入</em>验证<em class="mw">失败。</em></p><p id="27aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过用传递的<em class="mw"> @input </em>替换@input字段并通过<a class="ae kv" href="https://docs.microsoft.com/en-us/sql/relational-databases/system-stored-procedures/sp-executesql-transact-sql?view=sql-server-ver15" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">动态SQL </strong> </a>执行查询，该过程结束。</p><p id="6de8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是请注意，动态SQL有很多缺点，从性能到安全性。我绝不是建议您的DBA应该实现这个模型，它仅仅是(T-)SQL灵活性的一个展示，人们并不期望它存在。</p><p id="d2a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望这个资源对你有所帮助，或者至少是有趣的。</p></div></div>    
</body>
</html>