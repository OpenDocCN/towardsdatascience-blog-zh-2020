<html>
<head>
<title>Using Survival Regression to Gain Insights about Users and Optimize Blacklist Retention Policies</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用生存回归获得关于用户的洞察并优化黑名单保留策略</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/using-survival-regression-to-optimize-blacklist-retention-policies-and-gain-insights-about-users-4f61c2be3634?source=collection_archive---------54-----------------------#2020-05-03">https://towardsdatascience.com/using-survival-regression-to-optimize-blacklist-retention-policies-and-gain-insights-about-users-4f61c2be3634?source=collection_archive---------54-----------------------#2020-05-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2365" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用生命线Python库和生存分析来估计用户的“寿命”</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c9aa103974d7a3ef677eb37b3ff2df52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4h1w1SZNUnCWATQt"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">克里斯·利维拉尼在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="f81d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">公共网站和SAAS应用程序的安全管理员面临的最大挑战之一是检测非人类或恶意用户的非法活动。幸运的是，当有足够的使用数据可用时，通常不难发现某个用户的“行为”有些奇怪或不寻常。然而，要决定T4如何对这样的发现做出反应，通常也是一个不小的挑战。</p><p id="eada" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在大多数情况下，最好的方法是简单地将可疑用户列入黑名单或阻止(通过阻止其IP地址、会话、设备、帐户等)。然而，用户有时不能被列入黑名单，直到得到进一步通知，安全管理员必须回答的下一个问题是“我们应该将可疑用户列入黑名单多长时间？”，“我们如何确保选择正确的阻塞持续时间？”，以及“我们如何测试自己？”当攻击者滥用合法用户的设备或IP地址时尤其如此。通常，这种关于黑名单的维护和保留策略的问题是使用相当多的直觉和假设来回答的——当使用直觉和假设的人足够有经验时，这是非常好的。</p><p id="1992" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将提出一个更可靠的方法来解决这个问题，它需要更少的直觉和更多的数据。我的方法是基于一种被称为<em class="lv">生存分析</em>或“<em class="lv">事件发生时间”</em>分析的方法论或统计工具。虽然我将集中讨论生存分析如何帮助我们处理一个非常具体的问题，但我相信这种方法，更重要的是，这里介绍的工具在各种环境和类似问题中是有价值的。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="2d10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">生存分析主要被研究人员和科学家用来估计在给定的<em class="lv">时间</em>发生某个<em class="lv">【死亡】事件</em>的<em class="lv">几率</em>。传统上，它用于比较或确定给定特定情况下不同人群的存活率，或回答一些问题，如“给予某种治疗，患者多活3年的可能性有多大”或“有多少人在被诊断患有X后有可能活10年”。</p><p id="e796" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，生存分析也被用来估计其他类似死亡事件的可能性。生存分析用于估计用户在离开网站前可能会在网站上花费多长时间，引擎在发现某个故障后会继续运行多长时间，或者政府在不同类型的政治制度下“存活”多长时间。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi md"><img src="../Images/cd39f63f7e89ea8fa5ba401e79d60ffb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*hgoit5UEGuIA4SwCQdBL9g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">该图表摘自我将在这里使用的生命线Python库的文档(<a class="ae ky" href="https://lifelines.readthedocs.io/" rel="noopener ugc nofollow" target="_blank">https://lifelines.readthedocs.io/</a>)</p></figure><p id="9c0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，上图中的分析描述了一条<em class="lv">生存曲线</em>，显示与平均执政时间不超过10年的民主政权相比，非民主政权更有可能“存活”20年以上。</p><p id="1a79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">生存分析是一个巨大的话题，但我更愿意在下面引用一些好的介绍资源，然后继续展示它如何帮助我们解决这里提到的问题。然而，在我们继续之前，对于生存分析，或者更准确地说，对于它通常基于的表单数据，只有一个概念需要解释。</p><p id="e55e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">驱使科学家使用生存分析的一个主要问题是他们的数据被T4审查。假设我们试图在某一种树长得太大并倒塌之前估计它的寿命。同样，假设我们有一个数据集，其中包含我们在全国范围内监控的1000棵树。现在，假设我们的数据集中只有50%的树倒塌了，剩下的500棵树仍然挺立着。我们应该如何解释这些树？在我们知道它们的寿命结束之前，我们能报告它们的寿命吗？我们是否应该将这些树从我们的数据集中排除，因为我们对它们的预期寿命一无所知？换句话说，我们的数据是<em class="lv">右删截的——</em>我们知道它从哪里开始(在图表的右侧)，但我们不一定知道它至少在哪里结束。我不打算在这里讨论这个理论(你可以使用下面引用的一个很好的来源)，但是生存估计量的一个主要目的就是解释这种数据。否则，生存分析会是一个更简单的任务。</p><p id="19fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，任何生存分析估计器都需要至少2个变量或特征:<strong class="lb iu"> (1) </strong> <em class="lv">持续时间</em>(例如，树在倒塌之前站立了多长时间)；以及<strong class="lb iu"> (2) </strong> <em class="lv">事件</em>(是否已经发生“死亡”事件——树是否已经倒塌)。这一点很快就会清楚。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="dc66" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">黑名单、保留策略和用户生活</h1><p id="61df" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">因此，假设我们有一个web应用程序，它经常成为僵尸程序或自动化攻击的目标。幸运的是，我们知道如何识别由非人类和恶意用户生成的请求，并且我们可以轻松阻止生成这些请求的设备或地址。然而，我们也知道这些设备或地址也被真实用户使用，因此我们希望尽可能短时间地阻止它们。我们的安全顾问建议将我们黑名单的保留策略设置为14天，此后设备将不再被阻止，因为她的经验表明这是一种非常常见的模式。我们能测试这个吗？</p><p id="22e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我相信我们可以，生存分析是这项工作的一个非常好的工具。假设我们有了所需的数据，我们可以使用生存分析来估计这些设备或地址在停止生成非人类恶意请求之前将被邪恶用户接管多长时间。如果我们的安全专家是正确的，那么14天后，当我们检测到设备或地址产生非人类或恶意请求时，我们应该可以安全地重新激活我们已列入黑名单的设备或地址。</p><p id="5c5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们拥有的数据由大约25天前首次观察到的非人类行为的设备或地址的汇总统计数据组成。这里有两个我们特别感兴趣的特性:<em class="lv"> days_with_bad_req，</em>记录设备或地址生成被我们识别为非人类的请求的天数，以及一个名为<em class="lv"> event的变量，</em>告诉我们设备或地址是否已经停止生成非人类的请求，或者“攻击”是否仍在继续。当一个地址或设备发出<em class="lv">任何</em>请求已经超过10天时，我们将该地址或设备视为已经“死亡”或停止生成非人类请求。因此，如果有人接管了我的IP地址，并在6天内生成“坏”请求，然后消失了14天，我的地址将有<em class="lv">个days_with_bad_req </em> = 6和<em class="lv">个event </em> = 1。如果他昨天接管了我的IP，并仍然使用它来攻击网站，那么它将有<em class="lv">个days_with_bad_req </em> = 2和<em class="lv">个event </em> = 0。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/eb599af0e0ab5598041e507619b4feb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KAIQNZaVZHm04p8UC8C5Mw.png"/></div></div></figure><p id="a189" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有两个更有趣的特性，我们稍后会用到:<em class="lv"> req_day </em>记录该设备或地址每天生成的请求数，这些请求应该会给我们一些关于其活动强度<em class="lv">的测量值。<em class="lv"> bad_req_days_rate </em>是告诉我们该设备或地址产生非人类流量的时间百分比(天数)的功能(即，它是否专门用于生成恶意请求)。</em></p><p id="c2ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">初步数据显示，恶意用户实际操作的时间比14天短得多，但请记住，这里报告的一些数字可能是仍在进行的攻击。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/3deaf3ea5ea50dce383bc0becf3a0f4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1vRkGCkggi7GxyTZrTbhhQ.png"/></div></div></figure><p id="92e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将首先使用KaplanMeierFitter来确认这一声明。KM可能是最流行的单变量生存分析估计器，Lifeline库版本非常容易使用，并且具有非常有用的绘图功能，可以立即给我们一些见解。请注意它只需要两个变量:变量<em class="lv">持续时间</em>——对我们来说是设备或地址创建非人类请求的天数，以及变量<em class="lv">事件</em>——在我们的情况下，它等于设备或地址的攻击是否正在进行，或者是否被认为已经完成(即，自其上次活动以来已经超过10天)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="5847" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">KM fitter绘制的图表显示，超过一半的恶意用户会在2天的活动后停止攻击，大约90%的攻击者会在第5天结束时消失。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/063a0fc899655ce189e1851d73665594.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IApXivXdZSt0ojHXEmz4-A.png"/></div></div></figure><p id="3d9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">生命线库实际上有一个非常有用的函数，名为<em class="lv">【百分位()】</em>，它可以很容易地帮助我们进一步解释生存曲线，并确定所需的边界。<em class="lv"> percentile() </em>函数可以只取一个参数，这是所需的百分位数，因此，例如，<em class="lv"> percentile(0.1) </em>将给出90%的人口将“死亡”的时间点—回想一下，我们使用生存分析来估计“死亡时间”事件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/e734996e79ef738c275f954847f3c1c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*R8aV9T-TaSsDutQRbVYywQ.png"/></div></figure><p id="dbba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用一些有用的百分位数来更好地了解我们的生存曲线。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="0f66" class="nm mf it ni b gy nn no l np nq">50% of the population will not make bad req after 1.0 days<br/>75% of the population will not make bad req after 2.0 days<br/>99% of the population will not make bad req after 9.0 days<br/>no one will make bad req after 14.0 days</span></pre><p id="d22b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嗯，这肯定证实了我们的安全专家的直觉，因为任何人都不可能到达的时间点是14天。然而，如果尽快从黑名单中删除地址或设备对我们来说真的很重要，那么我们的分析表明，我们也可以将保留时间设置为仅仅10天，以避免大约99%的恶意非人类请求。</p><p id="99f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以使用<em class="lv"> predict() </em>方法来确认这一点，该方法将我们想要估计存活几率的天数作为参数。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="a288" class="nm mf it ni b gy nn no l np nq">print(f’Probability that device/address takeover continues after 3 days is: {kmf_breq.predict(3)}’)</span><span id="0fcf" class="nm mf it ni b gy nr no l np nq"><strong class="ni iu">Probability that device/address takeover continues after 3 days is: 0.14585572331045113</strong></span><span id="388f" class="nm mf it ni b gy nr no l np nq">print(f'Probability that device/address takeover continues after 10 days is: {kmf_breq.predict(10)}')</span><span id="5143" class="nm mf it ni b gy nr no l np nq"><strong class="ni iu">Probability that device/address takeover continues after 10 days is: 0.0033031481126646763</strong></span></pre><h1 id="326d" class="me mf it bd mg mh ns mj mk ml nt mn mo jz nu ka mq kc nv kd ms kf nw kg mu mv bi translated">生存回归越来越复杂</h1><p id="4f8c" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">在大多数情况下，使用Kaplan-Meier估计量就足以获得所需的洞察力，但有时我们可能需要(或想要)做出更准确的估计。例如，假设我们有充分的理由相信，更具侵略性的非人类行动者也可能更快消失。如前所述，我们有另一个名为<em class="lv"> bad_req_days_rate </em>的功能，它告诉我们设备或地址被用于生成恶意非人类活动的天数百分比。我们想检验这一特征(以及其他特征)的变化如何改变我们的生存功能。</p><p id="c4fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Lifelines库提供了另一个非常有用的估计器，名为CoxPHFitter，这也是一个非常流行的估计器，用于survival <em class="lv">回归。</em>与KMF等单变量估计不同，生存回归估计允许我们在分析中添加更多的协变量，并根据持续时间对它们进行回归。因此，让我们将特性<em class="lv"> bad_req_days_rate </em>与特性<em class="lv"> req_day </em>一起添加到我们的模型中，该特性通过计算每天生成多少请求(任何请求)来记录用户、地址或设备运行的一般速度。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/4feac51c2cf08fde8158fd847f78f3f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nkz7U5lpcddOUmf9loUvRg.png"/></div></div></figure><p id="c86c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个总结告诉我们许多需要用教科书来解释的事情，但请注意几个要点:尽管这两个特征的<em class="lv"> p值</em>在统计上是显著的(它小于0.05)，但我们的模型的一致性得分并不令人印象深刻，这意味着我们的模型(我们选择的协变量)不会很好地预测我们想要估计的最终寿命。这通常意味着我们需要重新思考我们的模型甚至数据的结构。然而，为了便于解释，我现在将忽略这一点。</p><p id="3ba3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要注意的第二件重要的事情是在<strong class="lb iu"> exp(coef) </strong>列下的两个特性的值，这是我们用来解释模型的主要值。变量<em class="lv"> req_day </em>的exp(coef) = 0.89，这意味着<em class="lv"> req_day </em>增加一个单位将<em class="lv">降低死亡</em>的“危险”，从而增加设备或地址随时间存活的机会约11%。另一方面，我们的第二个参数，<em class="lv"> bad_req_days_rate </em>的<em class="lv"> </em>为正(或&gt; 1.0) exp(coef) — 1.04。这意味着<em class="lv"> bad_req_days_rate </em>每增加一个单位(例如，设备在%51而非50%的活动天数内发出错误请求)将<em class="lv">增加死亡风险</em>，从而将用户继续发出错误请求的几率降低4%。</p><p id="916a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">换句话说，正如我们假设的那样，更具攻击性的攻击持续的时间更短。实际上，我们可以使用CoxPHFitter通过plot_covariate_groups()方法来可视化这一点。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="5457" class="nm mf it ni b gy nn no l np nq">cp.plot_covariate_groups('bad_req_days_rate', [75, 100])</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/8384e5a2c6f6230d7c605d6ca7657146.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/format:webp/1*2Xq0MLK4uUPG5S0GB63tTQ.png"/></div></figure><p id="0eed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这向我们展示了bad_req_days_rate为75%和100%的用户的生存函数。正如预期的那样，发起更集中攻击的用户“存活”更少或更早死亡。</p><p id="58cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以通过使用<em class="lv"> predict_survival_function()来看到这一点。</em>下面的代码通过创建两个用户来说明这一点，这两个用户的<em class="lv"> bad_req_days_rate只有一个不同，即</em>一个是80%，另一个是95%。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="9f26" class="nm mf it ni b gy nn no l np nq"><strong class="ni iu">#Create the first user with <em class="lv">bad_req_days_rate = 80</em></strong><br/>user_a_df = pd.DataFrame(np.array([0,2,1,80]).reshape(1,-1),columns=cols)</span><span id="5232" class="nm mf it ni b gy nr no l np nq"><strong class="ni iu">#Create the second user with <em class="lv">bad_req_days_rate = 95<br/></em></strong>user_b_df = pd.DataFrame(np.array([0,2,1,95]).reshape(1,-1),columns=cols)</span><span id="0439" class="nm mf it ni b gy nr no l np nq"><strong class="ni iu">#predict the survival function for each user and plot it</strong></span><span id="ec10" class="nm mf it ni b gy nr no l np nq">surv = cp.predict_survival_function(user_a_df)<br/>plt.plot(surv)</span><span id="253a" class="nm mf it ni b gy nr no l np nq">surv = cp.predict_survival_function(user_b_df)<br/>plt.plot(surv)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/c350ed056d349868545cf46248e4cf30.png" data-original-src="https://miro.medium.com/v2/resize:fit:810/format:webp/1*w4pJE4dpazAPzA3pRftP0A.png"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="d720" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结论:这是对生存分析的一个简短而深刻的介绍，我希望它能成为一个强大的工具，使我们能够对用户活动数据的重要方面获得有趣的见解。虽然这只是一个(有趣的)用例，但我试图使它足够简单，以便在其他环境中使用。</p><p id="6e85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">祝你好运！</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="d01d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的笔记本在这里可以找到</p><p id="2fb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[1]<a class="ae ky" href="https://lifelines.readthedocs.io/" rel="noopener ugc nofollow" target="_blank">生命线图书馆</a></p><p id="3742" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[2] <a class="ae ky" href="https://nbviewer.jupyter.org/github/sebp/scikit-survival/blob/master/examples/00-introduction.ipynb" rel="noopener ugc nofollow" target="_blank"> SciKit-Survival </a>是一个与我使用的不同的生存分析python库，但是一个极好的资源。</p><p id="8b03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">【2】几个比较好的来源<a class="ae ky" href="https://www.karger.com/Article/Fulltext/324758" rel="noopener ugc nofollow" target="_blank">这里</a>，这里<a class="ae ky" href="https://www.statsdirect.com/help/survival_analysis/cox_regression.htm" rel="noopener ugc nofollow" target="_blank">这里</a>。还有几个短的这里<a class="ae ky" href="http://www.bandolier.org.uk/painres/download/whatis/COX_MODEL.pdf" rel="noopener ugc nofollow" target="_blank">这里</a>和<a class="ae ky" rel="noopener" target="_blank" href="/survival-analysis-part-a-70213df21c2e">这里</a>。</p></div></div>    
</body>
</html>