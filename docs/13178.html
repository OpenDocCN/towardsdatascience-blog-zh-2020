<html>
<head>
<title>Introducing Python’s Functools Module</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">介绍 Python 的 Functools 模块</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/introducing-pythons-functools-module-2c4cba4774e?source=collection_archive---------15-----------------------#2020-09-10">https://towardsdatascience.com/introducing-pythons-functools-module-2c4cba4774e?source=collection_archive---------15-----------------------#2020-09-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f6d1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">处理高阶函数和可调用对象</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/227ecadc9295d4c0609e73d9b6c78dbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HEPOtoBTrAoVQTKr"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">阿里安·达尔维什在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="1ee0" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="e228" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">functools 模块是 Python 标准库的一部分，它提供了一些有用的特性，使得使用高阶函数(返回一个函数或接受另一个函数作为参数的函数)变得更加容易。有了这些特性，您可以重用或扩展函数或可调用对象的效用，而无需重写它们。这使得编写可重用和可维护的代码变得非常简单。</p><p id="edb0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">根据当前的稳定版本，即 Python 3.8 系列，functools 模块包含 11 个函数，其中一些可能不可用，或者在早期或后期版本中工作方式不同。它们包括:</p><ol class=""><li id="a7b3" class="ms mt it lt b lu mn lx mo ma mu me mv mi mw mm mx my mz na bi translated"><em class="nb">减少()</em></li><li id="a74a" class="ms mt it lt b lu nc lx nd ma ne me nf mi ng mm mx my mz na bi translated"><em class="nb"> lru_cache() </em></li><li id="3c39" class="ms mt it lt b lu nc lx nd ma ne me nf mi ng mm mx my mz na bi translated"><em class="nb">偏()</em></li><li id="68c2" class="ms mt it lt b lu nc lx nd ma ne me nf mi ng mm mx my mz na bi translated"><em class="nb"> partialmethod() </em></li><li id="c1b4" class="ms mt it lt b lu nc lx nd ma ne me nf mi ng mm mx my mz na bi translated"><em class="nb"> singledispatch() </em></li><li id="b652" class="ms mt it lt b lu nc lx nd ma ne me nf mi ng mm mx my mz na bi translated"><em class="nb"> singledispatchmethod() </em></li><li id="edf7" class="ms mt it lt b lu nc lx nd ma ne me nf mi ng mm mx my mz na bi translated"><em class="nb"> cached_property() </em></li><li id="7edb" class="ms mt it lt b lu nc lx nd ma ne me nf mi ng mm mx my mz na bi translated"><em class="nb"> total_ordering() </em></li><li id="91f1" class="ms mt it lt b lu nc lx nd ma ne me nf mi ng mm mx my mz na bi translated"><em class="nb">更新 _ 包装()</em></li><li id="3395" class="ms mt it lt b lu nc lx nd ma ne me nf mi ng mm mx my mz na bi translated"><em class="nb">wrapps()</em></li><li id="7f52" class="ms mt it lt b lu nc lx nd ma ne me nf mi ng mm mx my mz na bi translated"><em class="nb"> cmp_to_key() </em></li></ol><p id="d865" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们将简要讨论每一个，然后借助例子，说明它们的用法和功能。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h2 id="cb82" class="no la it bd lb np nq dn lf nr ns dp lj ma nt nu ll me nv nw ln mi nx ny lp nz bi translated">1.减少()</h2><p id="5182" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">首先我们有一个经典。<strong class="lt iu"> reduce(function，sequence) </strong>函数接收两个参数，一个函数和一个 iterable。它从左到右对 iterable 的所有元素累积应用 argument 函数，然后返回一个值。</p><p id="436d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">简单地说，它首先将参数函数应用于 iterable 的前两个元素，第一次调用返回的值成为函数的第一个参数，iterable 的第三个元素成为第二个参数。重复这个过程，直到可迭代次数用完。</p><p id="6ad0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">例如，reduce()可用于轻松计算列表的总和或乘积。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="f25c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在第一个例子中<em class="nb"> reduce(lambda a，b: a + b，[1，2，3，4]) </em>计算((1+2)+3)+4)并返回列表的总和 10。</p><h2 id="fee0" class="no la it bd lb np nq dn lf nr ns dp lj ma nt nu ll me nv nw ln mi nx ny lp nz bi translated">2.lru_cache()</h2><p id="74fb" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">lru_cache()是一个 decorator，它用一个<a class="ae ky" href="https://www.python-course.eu/python3_memoization.php" rel="noopener ugc nofollow" target="_blank"> memoizing </a> callable 来包装一个函数，该函数用于保存一个函数调用的结果，如果用相同的参数再次调用该函数，则返回存储的值。当使用相同的参数定期调用昂贵的或 I/O 受限的函数时，它可以节省时间。</p><p id="45d6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">本质上，它使用两种数据结构，一个字典将函数的参数映射到结果，一个链表跟踪函数的调用历史。</p><p id="ff87" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在全 LRU 缓存中，代表最近最少使用的缓存，指的是在达到最大条目大小时丢弃最近最少使用的元素的缓存。如果<strong class="lt iu"> maxsize </strong>设置为 None，则禁用 LRU 功能；如果<strong class="lt iu"> typed </strong>为 True，则分别缓存不同数据类型的参数，例如，<em class="nb"> f(3) </em>和<em class="nb"> f(3.0) </em>将被明确缓存。</p><p id="fc0a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">lru_cache()实用程序的一个例子可以在优化生成数字阶乘的代码中看到</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="72d3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在没有<em class="nb"> @lru_cache </em>的情况下，阶乘函数需要大约 1.46 s 来运行，而另一方面，使用<em class="nb"> @lru_cache，</em>该函数只需要 158 ns。这相当于性能提高了近 100，000 倍——太神奇了！对吗？</p><p id="1d75" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">通常，仅当您想要重用之前计算的值时，才应使用 LRU 缓存。因此，缓存需要在每次调用时创建不同可变对象的函数是没有意义的。此外，由于使用字典来缓存结果，函数的位置和关键字参数必须是可哈希的。</p><h2 id="a321" class="no la it bd lb np nq dn lf nr ns dp lj ma nt nu ll me nv nw ln mi nx ny lp nz bi translated">3.部分()</h2><p id="d2eb" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">部分函数是具有一些预先分配的输入参数的派生函数。例如，如果一个函数有两个参数，比如"<strong class="lt iu"> a" </strong>和"<strong class="lt iu"> b" </strong>"，那么可以从它创建一个分部函数，将"<strong class="lt iu"> a" </strong>作为预填充的参数，然后可以使用"<strong class="lt iu"> b" </strong>作为唯一的参数来调用它。Functool 的 partial()用于创建分部函数/对象，这是一个有用的特性，因为它允许:</p><ol class=""><li id="2169" class="ms mt it lt b lu mn lx mo ma mu me mv mi mw mm mx my mz na bi translated">复制已经传入了一些参数的现有函数。</li><li id="361a" class="ms mt it lt b lu nc lx nd ma ne me nf mi ng mm mx my mz na bi translated">以记录良好的方式创建现有功能的新版本。</li></ol><p id="905a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们考虑一个简单的例子来说明这一点</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="676c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们首先基于<em class="nb"> math.perm() </em>函数创建一个分部对象。在这种情况下，我们将 9 设置为第一个参数。因此，新创建的<em class="nb"> permutation_of_nine </em>函数的行为就像我们调用<em class="nb"> math.perm() </em>并将 9 设置为默认参数一样。在我们的例子中，<em class="nb"> permutation_of_nine(2) </em>与<em class="nb"> math.perm(9，2)做同样的事情。</em></p><p id="cb8b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">需要注意的是，<strong class="lt iu"> <em class="nb"> __name__ </em> </strong>和<strong class="lt iu"> <em class="nb"> __doc__ </em> </strong>属性是由程序员指定的，因为它们不是自动创建的</p><p id="891e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">partial 函数还带有一些重要的属性，这些属性在跟踪 partial 函数/对象时非常有用。其中包括:</p><ul class=""><li id="798a" class="ms mt it lt b lu mn lx mo ma mu me mv mi mw mm oc my mz na bi translated"><strong class="lt iu"><em class="nb">partial . args</em></strong>—返回预先分配给分部函数的位置参数。</li><li id="bb16" class="ms mt it lt b lu nc lx nd ma ne me nf mi ng mm oc my mz na bi translated"><strong class="lt iu"><em class="nb">partial . keywords</em></strong>—返回预先分配给分部函数的关键字参数。</li><li id="5ba6" class="ms mt it lt b lu nc lx nd ma ne me nf mi ng mm oc my mz na bi translated"><strong class="lt iu"> <em class="nb"> partial.func </em> </strong> —返回父函数的名称及其地址。</li></ul><p id="984b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们看另一个说明这些特征的例子</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="7bbe" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">偏旁非常有用。例如，在函数调用的管道序列中，一个函数的返回值是传递给下一个函数的参数。</p><h2 id="bb8b" class="no la it bd lb np nq dn lf nr ns dp lj ma nt nu ll me nv nw ln mi nx ny lp nz bi translated">4.partialmethod()</h2><p id="f0f7" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><em class="nb"> partialmethod() </em>返回一个新的<em class="nb"> partialmethod </em>描述符，其行为类似于<em class="nb"> partial </em>，只是它被设计为用作方法定义，而不是可直接调用的。你可以把它看作是方法的<em class="nb"> partial() </em>。</p><p id="289e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">也许一个例子最适合说明这一点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="f6c3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们首先创建一个动物类，它有一个属性<em class="nb">物种</em>和一个实例方法<em class="nb"> _set_species() </em>来设置动物的物种。接下来，我们创建两个 partialmethod 描述符<em class="nb"> set_dog() </em>和<em class="nb"> set_rabbit() </em>，分别用“狗”或“兔子”调用<em class="nb"> _set_species() </em>。这允许我们创建动物类的一个新实例，调用<em class="nb"> set_dog() </em>将动物的种类改为 dog，最后打印新的属性。</p><h2 id="7477" class="no la it bd lb np nq dn lf nr ns dp lj ma nt nu ll me nv nw ln mi nx ny lp nz bi translated">5.singledispatch()</h2><p id="758f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在我们讨论这个函数之前，我们首先要弄清楚两个重要的概念，这很重要:</p><ul class=""><li id="ecea" class="ms mt it lt b lu mn lx mo ma mu me mv mi mw mm oc my mz na bi translated">第一个是通用函数，它是由对不同类型实现相同操作的多个函数组成的函数。呼叫期间使用的实现由<a class="ae ky" href="http://ezyfleet.com/dispatch-algorithm-overview-2/" rel="noopener ugc nofollow" target="_blank">调度算法</a>决定。</li><li id="afd0" class="ms mt it lt b lu nc lx nd ma ne me nf mi ng mm oc my mz na bi translated">第二种是单一分派，这是一种通用函数分派的形式，根据单一参数的类型选择实现。</li></ul><p id="8bc1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">考虑到这一点，functool 的<em class="nb"> singledispatch </em>是一个装饰器，它将一个简单函数转换成一个通用函数，其行为取决于其第一个参数的类型。用简单的语言来说，它用于函数重载</p><p id="adfb" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们来看一个实际例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="0ba6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们首先定义一个函数<em class="nb"> divide() </em>，它接受两个参数<strong class="lt iu"> a </strong>和<strong class="lt iu"> b </strong>，并返回<strong class="lt iu"> a/b </strong>的值。然而，分割字符串会导致一个<a class="ae ky" href="https://docs.python.org/3/tutorial/errors.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lt iu">类型错误</strong> </a>，为了处理这个问题，我们定义了 _ functions，它指定了<em class="nb"> divide() </em>的行为，如果它是由字符串提供的话。注意，重载的实现是使用通用函数的<em class="nb"> register() </em>属性注册的</p><h2 id="42a2" class="no la it bd lb np nq dn lf nr ns dp lj ma nt nu ll me nv nw ln mi nx ny lp nz bi translated">6.singledispatchmethod()</h2><p id="939e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">它是一个装饰器，做的事情和<em class="nb"> @singledispatch </em>完全一样，但是它是为方法而不是函数指定的。</p><p id="2271" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">考虑下面的例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="4479" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">Product 类的 prod 方法被重载以返回一个列表或集合的元素的乘积，但是如果提供了不同的类型，默认情况下，它会引发一个<a class="ae ky" href="https://docs.python.org/3/tutorial/errors.html" rel="noopener ugc nofollow" target="_blank"><strong class="lt iu">notimplementererror</strong></a>。</p><h2 id="76d7" class="no la it bd lb np nq dn lf nr ns dp lj ma nt nu ll me nv nw ln mi nx ny lp nz bi translated">7.cached _ property()</h2><p id="40da" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">顾名思义，<em class="nb"> cached_property() </em>是一个装饰器，它将一个类方法转换成一个属性，该属性的值只计算一次，然后作为实例生命周期中的一个普通属性进行缓存。它类似于<a class="ae ky" href="https://www.freecodecamp.org/news/python-property-decorator/" rel="noopener ugc nofollow" target="_blank"> <em class="nb"> @property </em> </a>，除了它的缓存功能。这对于实例的计算开销很大的属性很有用，否则这些属性实际上是永久的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="ee3b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在上面的例子中，我们有一个<em class="nb">数据集</em>类，它保存了一个观察值列表，并实现了计算方差和标准差的方法。问题是，每次调用这些方法时，都必须重新计算方差和标准差，这可能证明是非常昂贵的，尤其是对于大型数据集。<em class="nb"> @cached_property </em>通过只计算和存储一次值来缓解这个问题，如果该方法被同一个实例再次调用，则返回该值。</p><h2 id="04b9" class="no la it bd lb np nq dn lf nr ns dp lj ma nt nu ll me nv nw ln mi nx ny lp nz bi translated">8.total_ordering()</h2><p id="81bf" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">给定一个定义了一个或多个<a class="ae ky" href="https://www.python.org/dev/peps/pep-0207/" rel="noopener ugc nofollow" target="_blank">富比较排序方法</a>即 _ <em class="nb"> _lt__()、__le__()、_ _ gt _ _()</em>或<em class="nb"> __eq__() </em>(对应<em class="nb"> &lt;、&lt; =、&gt;、&gt; = </em>、<em class="nb">=</em>)。您可以定义一些比较方法，<em class="nb"> @total_ordering </em>会根据给定的定义自动提供其余的方法。重要的是，该类应该提供一个<em class="nb"> __eq__() </em>方法。</p><p id="a3db" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">例如，如果您想创建一个比较不同数字的类。您可能需要实现所有丰富的比较方法。然而，这可能是相当繁琐和多余的，要解决这个问题，你只能实现 _ <em class="nb"> _eq__ </em>和<em class="nb"> __gt__ </em>方法，并使用<em class="nb"> @total_ordering </em>来自动填充其余的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="258b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">不过有一个限制，使用<em class="nb"> @total_ordering </em>会增加<a class="ae ky" href="https://en.wikipedia.org/wiki/Overhead_(computing)#:~:text=In%20computer%20science%2C%20overhead%20is,to%20perform%20a%20specific%20task.&amp;text=Examples%20of%20computing%20overhead%20may,data%20transfer%2C%20and%20data%20structures." rel="noopener ugc nofollow" target="_blank">的开销</a>导致执行速度变慢。此外，派生比较方法的<a class="ae ky" href="https://en.wikipedia.org/wiki/Stack_trace" rel="noopener ugc nofollow" target="_blank">堆栈跟踪</a>更加复杂。因此，如果您需要高效的代码，明智的做法是自己显式地实现比较方法</p><h2 id="d8e6" class="no la it bd lb np nq dn lf nr ns dp lj ma nt nu ll me nv nw ln mi nx ny lp nz bi translated">9.更新包装器()</h2><p id="fc6f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">它更新包装函数的元数据，使之看起来像被包装的函数。例如，对于分部函数，<strong class="lt iu"><em class="nb">update _ wrapper(partial，parent) </em> </strong>将更新分部函数的文档(<strong class="lt iu"> <em class="nb"> __doc__ </em> </strong>)和名称(<strong class="lt iu"> <em class="nb"> __name__ </em> </strong>)以匹配父函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><h2 id="20a8" class="no la it bd lb np nq dn lf nr ns dp lj ma nt nu ll me nv nw ln mi nx ny lp nz bi translated">10.换行()</h2><p id="9e11" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这是一个方便调用<em class="nb"> update_wrapper() </em>到修饰函数的函数。相当于运行<strong class="lt iu"><em class="nb">partial(update _ wrapper，wrapped=wrapped，assigned=assigned，updated=updated) </em> </strong>。</p><p id="ddf2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">举个例子，</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><h2 id="4da1" class="no la it bd lb np nq dn lf nr ns dp lj ma nt nu ll me nv nw ln mi nx ny lp nz bi translated">11.cmp_to_key()</h2><p id="7d26" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">它将旧式的比较函数转换为关键函数。比较函数是任何可调用的函数，它接受两个参数，对它们进行比较，返回负数表示小于，返回零表示等于，返回正数表示大于。键函数是一个可调用函数，它接受一个参数并返回另一个值以用作排序键，一个例子是<strong class="lt iu"><em class="nb">operator . item getter()</em></strong>键函数。<strong class="lt iu"><em class="nb">sorted()</em></strong><strong class="lt iu"><em class="nb">min()</em></strong><strong class="lt iu"><em class="nb">max()</em></strong><strong class="lt iu"><em class="nb">ITER tools . group by()</em></strong>等工具中都用到关键函数。</p><p id="2e07" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">cmp_to_key() 主要用作 Python 2 编写的支持比较函数的程序的转换工具。</p><p id="016e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们举一个例子，说明如何使用比较函数根据首字母对字符串列表进行排序，以说明<em class="nb"> cmp_to_key() </em>的用法</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="2c5c" class="kz la it bd lb lc od le lf lg oe li lj jz of ka ll kc og kd ln kf oh kg lp lq bi translated">结论</h1><p id="3df5" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在本文中，我们已经学习了 functools 模块，希望您现在已经了解了如何使用它来实现高阶函数，并编写高度健壮、可读和可重用的代码。</p><p id="17ef" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">祝你好运，编码愉快，愿 bug 在你的力量面前颤抖。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/ae6fdda31bfde274700a6ef1b3849d09.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*a-PFvelhpSE5N87aiJZxcw.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://meme-arsenal.com/create/meme/2637984" rel="noopener ugc nofollow" target="_blank"> meme-arsenal </a>制作的图像</p></figure></div></div>    
</body>
</html>