<html>
<head>
<title>Clustering: chess openings classifier (Part II)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">聚类:国际象棋开局分类器(第二部分)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/clustering-chess-openings-classifier-part-ii-7a4f0ce9dcc9?source=collection_archive---------53-----------------------#2020-06-03">https://towardsdatascience.com/clustering-chess-openings-classifier-part-ii-7a4f0ce9dcc9?source=collection_archive---------53-----------------------#2020-06-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="099c" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">聚类方法</h2><div class=""/><div class=""><h2 id="b57e" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">第二部分:国际象棋开局分类</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/a7d22b1b5f18a387acf5f21b617741fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*x0g4I7d1lm-AsEzh"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae lh" href="https://unsplash.com/@yobiworks?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> A. Yobi Blumberg </a>拍摄的照片</p></figure><p id="51bf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在本文的前一部分，我已经编写了一个API，允许我从lichess.org下载大量的顶级国际象棋比赛。我已经收集了7000多个匹配项，今天我将使用聚类技术对它们进行分析。我的目标是:列出这些比赛中最受欢迎的空缺。</p><p id="7a3e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><a class="ae lh" href="https://github.com/arditoibryan/Projects/blob/master/20200526_Chess_Openings_Classifier/Chess_Clustering.ipynb" rel="noopener ugc nofollow" target="_blank">我的仓库里有完整的代码。</a></p><h1 id="d8bf" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">导入数据集</h1><p id="9be6" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">像往常一样，第一步是使用<a class="ae lh" rel="noopener" target="_blank" href="/clustering-chess-openings-classifier-part-i-6299fbc9c291?source=your_stories_page---------------------------">导入下载的匹配数据集，这是我上一篇文章(第一部分)</a>中的说明。</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="2495" class="ng mf it nc b gy nh ni l nj nk">import pandas as pd<br/>#importing dataset<br/>X = pd.read_csv('/content/drive/My Drive/Colab Notebooks/Projects/20200526_Chess Openings/chess1.csv')</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/c4916e3044885fdb2b99f5efebb7c572.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/format:webp/1*PEiqdN9sVgD1J7iVvF1t2w.png"/></div></figure><p id="35d3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">不幸的是，数据根本没有结构化。我需要预处理所有的数据来创建一个数据集，为每一列保存一个单独的棋步。</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="5056" class="ng mf it nc b gy nh ni l nj nk">n_moves = X.shape[0]</span><span id="0625" class="ng mf it nc b gy nm ni l nj nk">#break every game in individual moves<br/>moves = [[] for x in range(n_moves-1)]<br/>for _ in range(n_moves-1):<br/>  game = X['0'][_].split(".")<br/>  game.remove('1')<br/>  #print(game)<br/>  for move in game:<br/>    try:<br/>      player_move = move.split(" ")<br/>      #print(player_move)<br/>      moves[_].append(player_move[1]) #add white move<br/>      moves[_].append(player_move[2]) #add black move<br/>    except:<br/>      #if error occurs<br/>      print(_, move)</span></pre><p id="6f00" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">使用这个算法，我获取了第0列的所有内容，并分解了每个字符串(因此每个匹配)。比如我分解了“1。d4 Nf6 2。Nf3 g6 3。Bf4 Bg7 4。e3 O-O 5。H3……”，分成单个动作。它将创建一个名为moves的数据集，将每个单独的移动作为一个字符串放在不同的列中。</p><h2 id="4f01" class="ng mf it bd mg nn no dn mk np nq dp mo lr nr ns mq lv nt nu ms lz nv nw mu iz bi translated">输出</h2><p id="e9e2" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">该函数还将返回将遇到错误的行，并避免将它们添加到数据集中。</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="dde7" class="ng mf it nc b gy nh ni l nj nk">3302  <br/>3303  <br/>3304  <br/>3305  <br/>3306   <br/>3307   <br/>3308   <br/>3309  <br/>3310  <br/>5280  <br/>5284  <br/>5285  </span></pre><p id="07bb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">* * *对于一个微小的错误，数字会在代码中重复一次，但对我们的结果没有任何影响</p><p id="e329" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，让我们看看最终的结果:</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="1620" class="ng mf it nc b gy nh ni l nj nk">moves = pd.DataFrame(moves)<br/>moves</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nx"><img src="../Images/98ef86742ac669a66873365122b1d01e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2M4q3FgeBSjCTG2-khRkBA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">我们的结构化数据集</p></figure><h1 id="dbd4" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">空缺</h1><p id="a306" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">如果我将聚类算法应用于moves，即结构化数据集，我将不只是对空缺进行分类，而是对整个匹配进行分类。我需要设置一个限制，集群将在数据中找到模式。</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="410f" class="ng mf it nc b gy nh ni l nj nk">#only conserve opening columns<br/>list1 = [x for x in range(0, 10)]<br/>list1</span><span id="bc75" class="ng mf it nc b gy nm ni l nj nk">moves.columns<br/>tot = moves[list1]<br/>tot</span></pre><p id="953c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我选择选择最多10步棋(相当于5回合)。这些数据足以为我提供一组常用的组合，但也不会有太多的数据模糊组合的频率。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/dbb4c4ef0d956ed089c128ef99cb4409.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/format:webp/1*b_e8UNmURSOkF2fqO4975g.png"/></div></figure><h1 id="502f" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">按名称分组</h1><p id="d32e" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">通过这个简单的groupby算法，我可以通过组合对所有7674个匹配进行排序。</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="8a32" class="ng mf it nc b gy nh ni l nj nk">final = tot.groupby([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], group_keys=True, squeeze=True, sort=True).count()<br/>final = pd.DataFrame(final)<br/>final</span></pre><p id="b71d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这将是我们的输出。如果您查看前4行，您会看到它们都包含变体:Nc3、d5、Nf3。现在的问题是我们按字母顺序排列它们。当我们的数据集超过7000行时，我们不知道这些开口有多受欢迎。这些只是没有明显重量的随意搭配。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/dbde2f0629431554e8fb8e5808398be6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*smgxEOVDTP3l17uVOIaexg.png"/></div></figure><h1 id="bc5b" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">按频率分组</h1><p id="7fd6" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">我要用的是另一种形式的groupby。在7000个匹配中，我可以通过统计它们的频率立即看出哪些是最受欢迎的空缺。</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="ee1f" class="ng mf it nc b gy nh ni l nj nk">final = tot.groupby([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], group_keys=True, squeeze=True, sort=True).size().sort_values(ascending=False)<br/>final = pd.DataFrame(final)<br/>final</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/e18683d81639105e802918f42a5d2a51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/format:webp/1*WsvW0QM1rfL118WFWJO19g.png"/></div></figure><p id="5300" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我要做的是将这个数据集转换成熊猫数据帧(我找到的唯一方法是将其导出为。csv，然后再次导入)。</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="de8c" class="ng mf it nc b gy nh ni l nj nk">#in order to reset it, we need to export it<br/>final.to_csv('chess.csv')</span><span id="3aae" class="ng mf it nc b gy nm ni l nj nk">#import of already reset dataset<br/>final_ = pd.read_csv('/content/chess.csv')<br/>final_.columns = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 'frequency']<br/>final_ = final_[0:20]<br/>final_</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/0f51a48d0f3d0a9fc01f89b16309969b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*orC8o9tpGOjEAiXNOEFahA.png"/></div></figure><p id="0a00" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最后，我可以按字母顺序对空缺进行分组，以使用第一种分组算法来识别聚类:</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="6ba8" class="ng mf it nc b gy nh ni l nj nk">final_ = final_.groupby([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], group_keys=True, squeeze=True, sort=True).count()<br/>final_[0:20]</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oc"><img src="../Images/9a063a0893703df471c983fb44c8e170.png" data-original-src="https://miro.medium.com/v2/resize:fit:1064/format:webp/1*BhmADZ47bHnVp6LzSDANmA.png"/></div></div></figure><p id="eef4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如您所见，这些是按频率选择的前20个空缺职位，然后按类别分组。虽然每个聚类的频率都为1，但它只是随着数据集格式的变化而重置，因此我们可以忽略它。</p></div></div>    
</body>
</html>