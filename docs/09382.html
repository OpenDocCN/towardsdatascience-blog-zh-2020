<html>
<head>
<title>Pandas DataFrame Group by Consecutive Certain Values</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">熊猫数据帧按连续的特定值分组</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/pandas-dataframe-group-by-consecutive-certain-values-a6ed8e5d8cc?source=collection_archive---------7-----------------------#2020-07-05">https://towardsdatascience.com/pandas-dataframe-group-by-consecutive-certain-values-a6ed8e5d8cc?source=collection_archive---------7-----------------------#2020-07-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/d1eaf32ecb88450d6173b480f88f8a96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GyIaQ1FL3MkNk8JBhcBbZw.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://pixabay.com/users/geralt-9301/" rel="noopener ugc nofollow" target="_blank"> geralt </a>在<a class="ae jg" href="https://pixabay.com/illustrations/pay-digit-number-fill-count-mass-1036469/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上拍摄</p></figure><h2 id="bd1e" class="jh ji jj bd b dl jk jl jm jn jo jp dk jq translated" aria-label="kicker paragraph">Python 编程技巧</h2><div class=""/><div class=""><h2 id="39ad" class="pw-subtitle-paragraph kp js jj bd b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dk translated">按任意行中出现的连续特定值对数据帧进行分组</h2></div><p id="c0f3" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们通常希望通过连续的值来分割熊猫数据帧。然而，在任何情况下处理连续值几乎总是不容易的，比如 SQL，Pandas 也是如此。</p><p id="dd37" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">标准 SQL 提供了一堆窗口函数来促进这种操作，但是在 Pandas 中没有太多的窗口函数。幸运的是，Python 中有许多变通方法，有时甚至比经典的窗口函数更简单。</p><p id="55ba" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在本文中，我将演示如何按照任意时间出现的某些值对熊猫数据帧进行分组。</p><h1 id="ff26" class="md me jj bd mf mg mh mi mj mk ml mm mn ky mo kz mp lb mq lc mr le ms lf mt mu bi translated">问题定义</h1><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/d34e8e12c55e2fbc9f589b1e3e0505b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7OgOFAeCsANDAeH6g4Fjaw.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">由<a class="ae jg" href="https://pixabay.com/users/geralt-9301/" rel="noopener ugc nofollow" target="_blank"> geralt </a>在<a class="ae jg" href="https://pixabay.com/illustrations/problem-solution-help-support-3303396/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上拍摄的照片</p></figure><p id="0b38" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果您对这个标题有些困惑，下面的示例数据会让您明白。让我们首先创建示例数据帧。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="d73b" class="ne me jj na b gy nf ng l nh ni">df = pd.DataFrame({<br/>  'item':['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M'], <br/>  'value':[12, 3, 5, 0, 0, 0, 23, 4, 2, 0, 0, 12, 0]<br/>})</span></pre><figure class="mv mw mx my gt iv gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/568b4e1044624265eb1dfe550d2cb73e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1330/format:webp/1*frHPnaFOnq7j0KypRlGJng.png"/></div></figure><p id="17de" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在本例中，我们希望为任意数量的连续值 0 分割数据帧。红色方块表示预计将从该原始数据帧中分离出三个数据段。</p><h1 id="7801" class="md me jj bd mf mg mh mi mj mk ml mm mn ky mo kz mp lb mq lc mr le ms lf mt mu bi translated">直觉</h1><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/c063035a6c124e61fde5579845ec50b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KFm3T49wnF_aekKh0UhMCg.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片由<a class="ae jg" href="https://pixabay.com/users/geralt-9301/" rel="noopener ugc nofollow" target="_blank"> geralt </a>在<a class="ae jg" href="https://pixabay.com/illustrations/board-font-chalk-enlightenment-953154/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>拍摄</p></figure><p id="46a8" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们在这里尝试做的事情通常有两个:</p><ol class=""><li id="8aae" class="nk nl jj lj b lk ll ln lo lq nm lu nn ly no mc np nq nr ns bi translated">用具有<code class="fe nt nu nv na b">value == 0</code>的行过滤数据帧。</li><li id="5976" class="nk nl jj lj b lk nw ln nx lq ny lu nz ly oa mc np nq nr ns bi translated">如果这些行不连续，请将它们分开。换句话说，至少有一行有<code class="fe nt nu nv na b">value != 0</code>。</li></ol><p id="4eef" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">第一步很容易，但第二步显然不容易。在对解决方案进行编码之前，让我们先看看直观的步骤。</p><ol class=""><li id="cfcc" class="nk nl jj lj b lk ll ln lo lq nm lu nn ly no mc np nq nr ns bi translated">用所有布尔值创建一个“遮罩”系列。<code class="fe nt nu nv na b">True</code>若为<code class="fe nt nu nv na b">value == 0</code>，否则为<code class="fe nt nu nv na b">False</code>。</li><li id="781a" class="nk nl jj lj b lk nw ln nx lq ny lu nz ly oa mc np nq nr ns bi translated">使用掩码系列过滤数据帧。所以，我们有了所有带<code class="fe nt nu nv na b">value == 0</code>的行。</li><li id="0f8a" class="nk nl jj lj b lk nw ln nx lq ny lu nz ly oa mc np nq nr ns bi translated">反转遮罩系列，因此<code class="fe nt nu nv na b">True</code>变为<code class="fe nt nu nv na b">False</code>，反之亦然。</li><li id="d607" class="nk nl jj lj b lk nw ln nx lq ny lu nz ly oa mc np nq nr ns bi translated">对反转的掩码系列执行累积求和。</li><li id="0e29" class="nk nl jj lj b lk nw ln nx lq ny lu nz ly oa mc np nq nr ns bi translated">累积和数列可以用来分组，达到我们想要的。</li></ol><p id="31cd" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">重要的是要澄清，如果我们在 Python 中累加布尔值，<code class="fe nt nu nv na b">True</code>将被视为<code class="fe nt nu nv na b">1</code>，而<code class="fe nt nu nv na b">False</code>将被视为<code class="fe nt nu nv na b">0</code>。</p><p id="27f3" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我知道，可能还是会让人困惑。让我们来看看下面的数据框架，它只是为了这种直觉而创建的，并不作为解决方案的一部分。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="9278" class="ne me jj na b gy nf ng l nh ni"># This is not part of the solution, just for demo purposes<br/>df_tmp = df<br/>df_tmp['mask'] = mask<br/>df_tmp['inversed_mask'] = ~mask<br/>df_tmp['inversed_mask_cumsum'] = (~mask).cumsum()</span></pre><figure class="mv mw mx my gt iv gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/26313c73f7df4bb1b0f9541048978370.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/1*1-CNfCusFLUlMKENL-70Iw.png"/></div></figure><p id="0029" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">绿色矩形显示了我们期望获得的预期行组。</p><p id="1940" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">那么，为什么我们需要在这里对反转的掩码列执行<code class="fe nt nu nv na b">cumsum()</code>？</p><ol class=""><li id="eb36" class="nk nl jj lj b lk ll ln lo lq nm lu nn ly no mc np nq nr ns bi translated">对于任何非零值，反转的掩码将具有<code class="fe nt nu nv na b">True (1)</code>，对于任何零，反转的掩码将具有<code class="fe nt nu nv na b">False (0)</code>。</li><li id="b134" class="nk nl jj lj b lk nw ln nx lq ny lu nz ly oa mc np nq nr ns bi translated">当我们对这个反转的掩码列应用<code class="fe nt nu nv na b">cumsum()</code>时，连续<code class="fe nt nu nv na b">0</code>的结果将保持不变，而如果不是<code class="fe nt nu nv na b">0</code>，累积和将使值增加。</li></ol><h1 id="3b73" class="md me jj bd mf mg mh mi mj mk ml mm mn ky mo kz mp lb mq lc mr le ms lf mt mu bi translated">解决办法</h1><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/af375f68f9c83dfd13ed9f04ec338ede.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xp6uPLbTCgSLrwt9GlBarw.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae jg" href="https://pixabay.com/users/qimono-1962238/" rel="noopener ugc nofollow" target="_blank">奇莫诺</a>在<a class="ae jg" href="https://pixabay.com/illustrations/key-keyhole-lock-security-unlock-2114046/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上的照片</p></figure><p id="dc31" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">直觉过后，你可能会觉得这并不容易。然而，当你看到解决方案时，你可能会嘲笑它是多么容易。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="d2aa" class="ne me jj na b gy nf ng l nh ni">df[df['value'] == 0].groupby((df['value'] != 0).cumsum())</span></pre><p id="b855" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">对，就是这样。</p><p id="f5b4" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们可以验证这些组是否正确。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="37c6" class="ne me jj na b gy nf ng l nh ni">for k, v in df[df['value'] == 0].groupby((df['value'] != 0).cumsum()):<br/>    print(f'[group {k}]')<br/>    print(v)<br/>    print('\n')</span></pre><figure class="mv mw mx my gt iv gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/9cef61e54405b3c636ee08cc734c0472.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*kPDRbZp9M2lXMD79quxVkw.png"/></div></figure><p id="aeb4" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这正是我们所期待的:)</p><h1 id="b76d" class="md me jj bd mf mg mh mi mj mk ml mm mn ky mo kz mp lb mq lc mr le ms lf mt mu bi translated">摘要</h1><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/fc28ae17033f4c7e479b76007abd1738.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kQyW2ZJTnyc92mhTlpZm3g.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://pixabay.com/users/janjf93-3084263/" rel="noopener ugc nofollow" target="_blank"> janjf93 </a>在<a class="ae jg" href="https://pixabay.com/vectors/desk-notes-notebook-album-write-2906792/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上拍摄</p></figure><p id="e918" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">事实上，我不会说熊猫提供了许多有用的窗口功能。但是，Python 中的 Pandas 是典型的不像 SQL 的“编程语言”。因此，它提供了更多的可能性，有时甚至能以更简单的方式解决问题。</p><div class="is it gp gr iu od"><a href="https://medium.com/@qiuyujx/membership" rel="noopener follow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd jt gy z fp oi fr fs oj fu fw js bi translated">通过我的推荐链接加入 Medium 克里斯托弗·陶</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">medium.com</p></div></div><div class="om l"><div class="on l oo op oq om or ja od"/></div></div></a></div><p id="7f5c" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果你觉得我的文章有帮助，请考虑加入 Medium 会员来支持我和成千上万的其他作者！(点击上面的链接)</p></div></div>    
</body>
</html>