<html>
<head>
<title>How to Design For Panic Resilience in Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何设计Rust中的恐慌恢复能力</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-design-for-panic-resilience-in-rust-55d5fd2478b9?source=collection_archive---------26-----------------------#2020-06-01">https://towardsdatascience.com/how-to-design-for-panic-resilience-in-rust-55d5fd2478b9?source=collection_archive---------26-----------------------#2020-06-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="6993" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">错误处理</h2><div class=""/><div class=""><h2 id="95bc" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">不要慌！学会构建对错误有弹性的高质量软件。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/e417a0f17821fc716967744442b10ab6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mEH29GM1gkgZjhyNNw0GQA.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">照片:<a class="ae lh" href="https://unsplash.com/@dallimonti" rel="noopener ugc nofollow" target="_blank">安德烈斯·达利蒙提</a> /Unsplash</p></figure></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi lp"><img src="../Images/89c101f81063fc0d32cff2be0fc3dd6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eISdxsTuw-EbMRgtTVeiSA.png"/></div></div></figure><p id="0e58" class="pw-post-body-paragraph lq lr it ls b lt lu kd lv lw lx kg ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">试着想象使用一些软件和WHAM，一堆文本，以及大脑无法忽略的视觉垃圾。或者更好的是，当你的用户同时按下两个按钮，飞机关闭时，他们正在驾驶一架商业客机。我们需要的是明确的反馈，并防止暂停执行。在这个故事中，我们讨论Rust应用程序中的恐慌恢复方法，以使高质量的软件用户可以依赖。</p><blockquote class="mm"><p id="d2f7" class="mn mo it bd mp mq mr ms mt mu mv ml dk translated">如果你认为你的软件是一辆时速60英里的汽车，恐慌就像撞上了一堵砖墙。</p></blockquote><p id="ef84" class="pw-post-body-paragraph lq lr it ls b lt mw kd lv lw mx kg ly lz my mb mc md mz mf mg mh na mj mk ml im bi translated">1990年，一次软件更新导致美国电话电报公司全国114个电子交换系统全部瘫痪。当一座塔发生故障时，它会向邻近的塔发送一条信息，告知它正在停止交通。其他塔收到的信息导致它们进入类似的故障状态，通过整个美国电话电报公司长途网络使信息永久存在。</p><p id="8dbf" class="pw-post-body-paragraph lq lr it ls b lt lu kd lv lw lx kg ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">糟糕的逻辑是大多数有害软件错误的原因。C #中的错误可能更谨慎，因为被忽略的错误不会产生警告。Rust本可以防止过去发生的一些讨厌的软件错误，但前提是软件开发人员利用了Rust语言提供的重要错误处理逻辑。</p><p id="8b75" class="pw-post-body-paragraph lq lr it ls b lt lu kd lv lw lx kg ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">在C语言中，数值是表达“发生了错误”的惯用方法。函数调用返回一个表示错误代码的整数。如果代码为零，则没有错误发生。否则，可以将代码与值进行比较，以确定发生了什么故障。</p><p id="df59" class="pw-post-body-paragraph lq lr it ls b lt lu kd lv lw lx kg ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">C中错误处理方法的问题是，忽略函数调用的返回值既不是错误，也不是警告。失败可能会被忽视和处理。</p><blockquote class="mm"><p id="2f36" class="mn mo it bd mp mq mr ms mt mu mv ml dk translated">错误处理的首要目标是防止崩溃。</p></blockquote><p id="4488" class="pw-post-body-paragraph lq lr it ls b lt mw kd lv lw mx kg ly lz my mb mc md mz mf mg mh na mj mk ml im bi translated">一些在C之后设计的新语言使用异常进行错误处理，这是对错误代码的高级抽象。调用一个可能失败并导致异常的函数需要一个<code class="fe nb nc nd ne b">try</code>和<code class="fe nb nc nd ne b">catch </code>块来执行可能导致异常的代码，并处理异常发出的错误信号。异常仍然不总是被显式处理，因此一些懒惰的程序员处理异常的方式与<code class="fe nb nc nd ne b">.unwrap()</code>在Rust中处理错误的方式相同——打印错误并失败。</p><p id="494e" class="pw-post-body-paragraph lq lr it ls b lt lu kd lv lw lx kg ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">在Rust中，错误显而易见。根据习语的说法，铁锈中的错误有<code class="fe nb nc nd ne b">Result</code>和<code class="fe nb nc nd ne b">Option</code>三种类型。因为错误是显而易见的，程序员厌倦了处理它们，最终更喜欢<code class="fe nb nc nd ne b">.unwrap()</code>每一个错误，这在恐慌恢复的名义下毫无用处。Unwrap鼓励“最好的希望”,盲目地钻研可能存在的任何数据，如果在任何情况下都失败了，那就是严重的崩溃——恐慌。</p><p id="c00d" class="pw-post-body-paragraph lq lr it ls b lt lu kd lv lw lx kg ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">错误处理的首要目标是防止崩溃。</p><p id="354e" class="pw-post-body-paragraph lq lr it ls b lt lu kd lv lw lx kg ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">让我们看看Rust中处理错误的三个关键部分:</p><ol class=""><li id="7f1a" class="nf ng it ls b lt lu lw lx lz nh md ni mh nj ml nk nl nm nn bi translated">什么时候恐慌，</li><li id="df0e" class="nf ng it ls b lt no lw np lz nq md nr mh ns ml nk nl nm nn bi translated">处理错误，</li><li id="6fd3" class="nf ng it ls b lt no lw np lz nq md nr mh ns ml nk nl nm nn bi translated">和附加部分:库中的错误处理。</li></ol><h1 id="a48e" class="nt nu it bd nv nw nx ny nz oa ob oc od ki oe kj of kl og km oh ko oi kp oj ok bi translated">何时恐慌</h1><p id="351a" class="pw-post-body-paragraph lq lr it ls b lt ol kd lv lw om kg ly lz on mb mc md oo mf mg mh op mj mk ml im bi translated">带着错误代码退出总比惊慌失措好。在最好的情况下，你写的任何软件都不会死机。死机是一种可控制的崩溃，为了构建可靠的软件，必须避免死机。</p><p id="e936" class="pw-post-body-paragraph lq lr it ls b lt lu kd lv lw lx kg ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">崩溃从来都不是“恰当”的行为，但这总比让你的系统造成物理损坏要好。如果在任何时候，人们认为该软件可能会导致一些致命的、昂贵的或破坏性的事情发生，那么最好是将其关闭。</p><p id="8eb7" class="pw-post-body-paragraph lq lr it ls b lt lu kd lv lw lx kg ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">如果你认为你的软件是一辆时速60英里的汽车，恐慌就像撞上了一堵砖墙。</p><p id="41f0" class="pw-post-body-paragraph lq lr it ls b lt lu kd lv lw lx kg ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">死机会解开调用堆栈，跳出每个函数调用并从程序执行中返回，在此过程中破坏对象。这不被认为是安全或干净的关闭。避免恐慌。</p><p id="d969" class="pw-post-body-paragraph lq lr it ls b lt lu kd lv lw lx kg ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">结束程序执行的最好方法是让它运行到最后一个大括号。以某种方式，为那种行为编程。它允许所有物体安全地自我毁灭。参见<a class="ae lh" href="https://doc.rust-lang.org/std/ops/trait.Drop.html" rel="noopener ugc nofollow" target="_blank">掉落特性</a>。</p><h1 id="aa1b" class="nt nu it bd nv nw nx ny nz oa ob oc od ki oe kj of kl og km oh ko oi kp oj ok bi translated">处理错误</h1><blockquote class="mm"><p id="c9bd" class="mn mo it bd mp mq mr ms mt mu mv ml dk translated">恐慌是最后的手段，而不是一个很好的内置工具，可以很容易地通过一个消息退出！</p></blockquote><p id="133c" class="pw-post-body-paragraph lq lr it ls b lt mw kd lv lw mx kg ly lz my mb mc md mz mf mg mh na mj mk ml im bi translated"><code class="fe nb nc nd ne b"><em class="oq">Result</em></code>、<code class="fe nb nc nd ne b"><em class="oq">Option</em></code>、<code class="fe nb nc nd ne b">std::io::<em class="oq">Result</em></code>等其他一些类型可以代表一次手术的成功。在惯用的Rust中，如果某个东西可能失败，它会返回一个<code class="fe nb nc nd ne b"><em class="oq">Result</em></code> <em class="oq"> </em>，该值编码了两个可能的值:要么是成功值(<code class="fe nb nc nd ne b"><strong class="ls jd">Ok</strong></code>)，要么是错误值(<code class="fe nb nc nd ne b">Err</code>)。<code class="fe nb nc nd ne b"><em class="oq">Result</em>&lt;<strong class="ls jd">T</strong>, <strong class="ls jd">E</strong>&gt;</code>其中<code class="fe nb nc nd ne b">T</code>是<em class="oq">成功</em>值类型，<code class="fe nb nc nd ne b">E</code>是<em class="oq">错误</em>值类型。</p><p id="f1cc" class="pw-post-body-paragraph lq lr it ls b lt lu kd lv lw lx kg ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我们将我们的<code class="fe nb nc nd ne b"><em class="oq">Result</em></code>与成功和错误值相匹配。如果这是一个成功，那么我们只是把我们的价值和进展，在我们的软件。但是，如果该值产生错误，我们必须基于以下问题制定有效的备份计划:</p><ol class=""><li id="1d5b" class="nf ng it ls b lt lu lw lx lz nh md ni mh nj ml nk nl nm nn bi translated">我们能再试一次吗？</li><li id="7056" class="nf ng it ls b lt no lw np lz nq md nr mh ns ml nk nl nm nn bi translated">数据是绝对强制进行的，还是可以生成、调整或假设的？</li></ol><p id="e174" class="pw-post-body-paragraph lq lr it ls b lt lu kd lv lw lx kg ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">如果需要数据<em class="oq">来继续，那么我们需要向调用者报告错误。除了main以外，我们绝对不能对任何功能感到恐慌。否则，你会得到自认为是上帝的东西的函数。适当的错误处理会尽其所能，当有疑问时，让调用者来处理问题。</em></p><p id="49bf" class="pw-post-body-paragraph lq lr it ls b lt lu kd lv lw lx kg ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">下面的例子适用于第一个问题:<em class="oq">我们可以再试一次吗？</em></p><pre class="ks kt ku kv gt or ne os ot aw ou bi"><span id="8181" class="ov nu it ne b gy ow ox l oy oz"><strong class="ne jd">fn </strong>open_config() -&gt; <em class="oq">Result</em>&lt;std::fs::File, std::io::Error&gt; {<br/>    <strong class="ne jd">use </strong>std::fs::File;<br/>    <strong class="ne jd">match </strong>File::<strong class="ne jd">open</strong>("config.toml") {<br/>        <strong class="ne jd">Ok</strong>(f) =&gt; <strong class="ne jd">Ok</strong>(f),<br/>        // If not found, search in second location:<br/>        <strong class="ne jd">Err</strong>(e) =&gt; <strong class="ne jd">match </strong>File::<strong class="ne jd">open</strong>("data/config.toml") {<br/>            <strong class="ne jd">Ok</strong>(f) =&gt; <strong class="ne jd">Ok</strong>(f),<br/>            // Otherwise, bubble first error up to caller<br/>            _ =&gt; <strong class="ne jd">Err</strong>(e),<br/>        }<br/>    }<br/>}</span><span id="694f" class="ov nu it ne b gy pa ox l oy oz"><strong class="ne jd">fn </strong>main() {<br/>    <strong class="ne jd">let mut</strong> result = <strong class="ne jd">open_config</strong>();<br/>    <strong class="ne jd">if </strong>result.<strong class="ne jd">is_err</strong>() { // If failed the first time<br/>        // Try again in about 5 seconds ...<br/>        std::thread::<strong class="ne jd">sleep</strong>(std::time::Duration::<strong class="ne jd">from_secs</strong>(5));<br/>        // Reattempt<br/>        result = <strong class="ne jd">open_config</strong>();<br/>    }</span><span id="bf20" class="ov nu it ne b gy pa ox l oy oz">    <strong class="ne jd">match </strong>result {<br/>        // Proceed as usual ...<br/>        <strong class="ne jd">Ok</strong>(cfg) =&gt; <em class="oq">println!</em>(<strong class="ne jd">"Opened the config file"</strong>),<br/>        // Print the cause to stderr, and DONT PANIC<br/>        <strong class="ne jd">Err</strong>(e) =&gt; <em class="oq">{<br/>            eprintln!</em>(<strong class="ne jd">"File could not be opened: {:?}"</strong>, e.<strong class="ne jd">kind</strong>());<br/>            std::process::<strong class="ne jd">exit</strong>(1); // Exit with code 1 (fail)<br/>    }<br/>}</span></pre><p id="4e99" class="pw-post-body-paragraph lq lr it ls b lt lu kd lv lw lx kg ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">这段代码试图在“config.toml”中找到一个配置文件。如果失败，它会尝试在特定的子文件夹中查找相同的配置文件。只有当第二次尝试失败时，它才会将错误冒泡到调用者。调用者是main，它愿意在暂停5秒钟后第一次重试失败。请注意，即使main也不会死机，因为虽然这是一个致命的错误，但是可以恢复正常的退出进程。带着错误代码退出总比惊慌失措好。</p><p id="43e0" class="pw-post-body-paragraph lq lr it ls b lt lu kd lv lw lx kg ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">但是和恐慌一样，<code class="fe nb nc nd ne b">std::process:exit</code>可以防止物品的毁坏，所以只能在没有需要掉落的物品时使用。因此，恐慌是最后的手段，而不是一个漂亮的内置功能，可以很容易地通过一个消息退出！</p><p id="3794" class="pw-post-body-paragraph lq lr it ls b lt lu kd lv lw lx kg ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">最后一个例子适用于第二个问题:<em class="oq">数据是否绝对必须继续？</em></p><pre class="ks kt ku kv gt or ne os ot aw ou bi"><span id="c62b" class="ov nu it ne b gy ow ox l oy oz">/// Get the username from the config if it is present.<br/><strong class="ne jd">fn </strong>read_username_from_config() -&gt; <em class="oq">Option</em>&lt;<em class="oq">String</em>&gt; {<br/>    // Implementation hidden<br/>}</span><span id="4d62" class="ov nu it ne b gy pa ox l oy oz">/// Get the username if present. Otherwise returns the<br/>/// default username "unnamed".<br/><strong class="ne jd">fn </strong>get_username() -&gt; <em class="oq">String </em>{<br/>    <strong class="ne jd">read_username_from_config</strong>()<br/>        .<strong class="ne jd">unwrap_or</strong>(<em class="oq">String</em>::<strong class="ne jd">from</strong>(<strong class="ne jd">"unnamed"</strong>))<br/>}</span><span id="9f7a" class="ov nu it ne b gy pa ox l oy oz"><strong class="ne jd">fn </strong>main() {<br/>    <strong class="ne jd">let </strong>username = <strong class="ne jd">get_username</strong>();<br/>    <em class="oq">println!</em>(<strong class="ne jd">"Username is: {}"</strong>, username);<br/>}</span></pre><p id="56a3" class="pw-post-body-paragraph lq lr it ls b lt lu kd lv lw lx kg ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">在上面的例子中，main只请求一个用户名。<code class="fe nb nc nd ne b">get_username</code>返回<code class="fe nb nc nd ne b">String</code>，这意味着它没有失败的能力。它试图使用<code class="fe nb nc nd ne b">read_username_from_config</code>从配置文件中读取一个用户名，但是如果无法检索到，它将使用默认字符串“未命名”。</p><p id="b059" class="pw-post-body-paragraph lq lr it ls b lt lu kd lv lw lx kg ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">权衡你可能得不到的数据的价值是很重要的。考虑是否有可能返回到输入循环，或者带着警告继续。关注你的软件的可用性，以及它如何克服缺乏数据的问题。⁴</p><h1 id="b30a" class="nt nu it bd nv nw nx ny nz oa ob oc od ki oe kj of kl og km oh ko oi kp oj ok bi translated">库中的错误处理</h1><blockquote class="mm"><p id="fe9e" class="mn mo it bd mp mq mr ms mt mu mv ml dk translated">将错误值表示为代码时，可以使用枚举。</p></blockquote><pre class="pb pc pd pe pf or ne os ot aw ou bi"><span id="2f39" class="ov nu it ne b gy ow ox l oy oz">#[derive(Debug, PartialEq)] // Use derives<br/><strong class="ne jd">enum </strong><em class="oq">SafeDivideError </em>{ // Define a custom error type<br/>  <strong class="ne jd">DivideByZero</strong>,<br/>}</span><span id="6704" class="ov nu it ne b gy pa ox l oy oz"><strong class="ne jd">fn </strong>safe_divide(dividend: <strong class="ne jd">i32</strong>, divisor: <strong class="ne jd">i32</strong>) -&gt; <em class="oq">Result</em>&lt;<strong class="ne jd">i32</strong>, <em class="oq">SafeDivideError</em>&gt; {<br/>  <strong class="ne jd">if </strong>divisor == 0 { // If the dividend is zero …<br/>    <strong class="ne jd">Err</strong>(<em class="oq">SafeDivideError</em>::<strong class="ne jd"><em class="oq">Divi</em>deByZero</strong>) // Return the error value<br/>  } <strong class="ne jd">else </strong>{ // Otherwise …<br/>    <strong class="ne jd">Ok</strong>(dividend / divisor) // Return the success value<br/>  }<br/>}</span><span id="a9d9" class="ov nu it ne b gy pa ox l oy oz"><em class="oq">assert_eq!</em>(safe_divide(4, 2), <strong class="ne jd">Ok</strong>(4/2));<br/><em class="oq">assert_eq!</em>(safe_divide(4, 0), <strong class="ne jd">Err</strong>(<em class="oq">SafeDivideError</em>::<strong class="ne jd">DivideByZero</strong>));</span></pre><p id="4ecd" class="pw-post-body-paragraph lq lr it ls b lt lu kd lv lw lx kg ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">在上面的例子中，我们使用自定义枚举作为错误返回类型。这很容易看出我们产生错误的原因，但是在这种情况下，被零除是我们需要报告错误的唯一原因。因此，更好的型号可能是<code class="fe nb nc nd ne b"><em class="oq">Option</em>&lt;<strong class="ls jd">i32</strong>&gt;</code>。</p><p id="aca5" class="pw-post-body-paragraph lq lr it ls b lt lu kd lv lw lx kg ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">创建自定义错误类型很有价值。当您使用空枚举作为错误类型时，数据足迹可能很小。这很重要，因为不管使用<code class="fe nb nc nd ne b"><em class="oq">Result</em>&lt;<strong class="ls jd">i32</strong>, <em class="oq">String</em>&gt;</code>的成功或错误值，例如，它消耗的内存和它的最大成员一样多。在这种情况下，是一个字符串，比堆栈上的一个<code class="fe nb nc nd ne b"><strong class="ls jd">i32 </strong></code>大16个字节。相反，<code class="fe nb nc nd ne b">SafeDivideError</code>枚举消耗“零”字节的内存。</p><pre class="ks kt ku kv gt or ne os ot aw ou bi"><span id="6688" class="ov nu it ne b gy ow ox l oy oz"><em class="oq">println!</em>(<strong class="ne jd">"String:          {}B"</strong>, std::mem::size_of::&lt;<em class="oq">String</em>&gt;());<br/><em class="oq">println!</em>(<strong class="ne jd">"SafeDivideError: {}B"</strong>, std::mem::size_of::&lt;<em class="oq">SafeDivideError</em>&gt;());</span><span id="4945" class="ov nu it ne b gy pa ox l oy oz">// String:          24B<br/>// SafeDivideError: 0B</span></pre><p id="9293" class="pw-post-body-paragraph lq lr it ls b lt lu kd lv lw lx kg ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">当使用两个或更多值时，它就变成了一个<code class="fe nb nc nd ne b">u8</code>的大小，在获得另一个字节之前，可以表示多达256个不同的错误值。将错误值表示为代码时，可以使用枚举。</p><p id="cff0" class="pw-post-body-paragraph lq lr it ls b lt lu kd lv lw lx kg ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">利用文档注释来解释函数为什么会返回错误，尤其是不同的错误值意味着什么，这一点很重要。如果一个函数返回<code class="fe nb nc nd ne b"><em class="oq">Result</em>&lt;<strong class="ls jd">i32</strong>, <em class="oq">String</em>&gt;</code>，那么使用你的库的人肯定会想知道函数失败会返回什么不同的字符串。</p><p id="93b2" class="pw-post-body-paragraph lq lr it ls b lt lu kd lv lw lx kg ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">旧的规则仍然适用于创建库:永远不要惊慌，只允许函数的调用者在您不能处理错误时处理错误——必要时冒泡错误。设计一个好的错误恢复库需要强调健壮的错误类型和它们的文档。从<code class="fe nb nc nd ne b"><a class="ae lh" href="https://doc.rust-lang.org/std/io/struct.Error.html" rel="noopener ugc nofollow" target="_blank">std::io::Error</a></code>中汲取一些天才。</p><p id="94dc" class="pw-post-body-paragraph lq lr it ls b lt lu kd lv lw lx kg ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">Rust使任何人都能够构建高度健壮、可靠和高效的软件。所以不要慌！使用正确的方法编写可靠的Rust软件。</p><h2 id="49e7" class="ov nu it bd nv pg ph dn nz pi pj dp od lz pk pl of md pm pn oh mh po pp oj iz bi translated">脚注</h2><ol class=""><li id="6283" class="nf ng it ls b lt ol lw om lz pq md pr mh ps ml nk nl nm nn bi translated">来源:<a class="ae lh" href="http://www.phworld.org/history/attcrash.htm" rel="noopener ugc nofollow" target="_blank">http://www.phworld.org/history/attcrash.htm</a></li><li id="65a6" class="nf ng it ls b lt no lw np lz nq md nr mh ns ml nk nl nm nn bi translated">这里有一个很好的列表:https://en.wikipedia.org/wiki/List_of_software_bugs</li><li id="5552" class="nf ng it ls b lt no lw np lz nq md nr mh ns ml nk nl nm nn bi translated">错误冒泡是指代码向上游传递错误，因为它肯定不会处理它。又名错误传播。</li><li id="b2be" class="nf ng it ls b lt no lw np lz nq md nr mh ns ml nk nl nm nn bi translated">但是不要执行<a class="ae lh" href="https://en.wikibooks.org/wiki/JavaScript/Automatic_semicolon_insertion" rel="noopener ugc nofollow" target="_blank">静默数据操作。</a></li></ol></div></div>    
</body>
</html>