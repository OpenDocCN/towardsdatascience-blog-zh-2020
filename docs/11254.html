<html>
<head>
<title>Solving Combinatorial Problems with PySpark</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 PySpark 解决组合问题</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/solving-combinatorial-problems-with-pyspark-fad433b1fca0?source=collection_archive---------47-----------------------#2020-08-04">https://towardsdatascience.com/solving-combinatorial-problems-with-pyspark-fad433b1fca0?source=collection_archive---------47-----------------------#2020-08-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/a4ac4dffca1b16d97dad592e017ed228.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*v9JEOMjpZyOXP2fx"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">乔·奇恰雷利在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><div class=""/><div class=""><h2 id="f6f2" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">用二进制表示划分组合问题</h2></div><p id="5e0e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们考虑问题陈述。给定<em class="lu"> n </em>个实数<em class="lu"> x1 </em>，<em class="lu"> x2 </em>，<em class="lu"> xn </em>，选择任意一组不同的数，使得函数<em class="lu"> f </em>对这些选择的数给出最大值。函数<em class="lu"> f </em>可以接受任意数量的输入，因此可以选择任意数量的数字。</p><p id="3c80" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">期望输出:一组数字 S = { <em class="lu"> xi </em>，<em class="lu"> xj </em>，…，<em class="lu"> xm </em> }或<em class="lu"> f(xi，xj，…，xm)的最大值。</em></p><p id="ab35" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">解决这个问题的一个强力策略是对数字进行置换，首先从 n 个数字中选择 1，然后是 2，3，依此类推。如果我们不知道函数<em class="lu"> f </em>，那么我们就不知道输入参数的顺序是否重要。因此我们需要排列和组合。如果顺序不重要，那么我们可以使用组合。</p><h1 id="c4f4" class="lv lw jj bd lx ly lz ma mb mc md me mf kp mg kq mh ks mi kt mj kv mk kw ml mm bi translated">组合的总和</h1><blockquote class="mn mo mp"><p id="8bc9" class="ky kz lu la b lb lc kk ld le lf kn lg mq li lj lk mr lm ln lo ms lq lr ls lt im bi translated">所有<em class="jj"> k </em>的<em class="jj"> k </em>组合数是一组<em class="jj"> n </em>元素的子集数。有几种方法可以看出这个数字是 2^n.</p><p id="fade" class="ky kz lu la b lb lc kk ld le lf kn lg mq li lj lk mr lm ln lo ms lq lr ls lt im bi translated">来源:<a class="ae jg" href="https://en.wikipedia.org/wiki/Combination" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Combination</a></p></blockquote><p id="04eb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">很容易看出是否有 n 个数字可能的方法来选择不同的 k 个数字，因为所有的 k 都非常接近 2^n.的二进制表示。n 位二进制向量可以表示从 0 到 2^n-1.的数字如果这个向量的每个索引代表 n 个数字中的一个，如果那个索引的比特是开的，我们可以选择那个数字。这样，我们可以从 0 到 2^n-1 遍历数字，将它们表示为一个 n 位的二进制向量，然后根据哪些位是开的来选择数字。</p><figure class="mt mu mv mw gt iv"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="1d3f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">方法<em class="lu"> get_data </em>将 num 转换为二进制表示，并根据返回的数据中哪些位在该索引上。</p><pre class="mt mu mv mw gt mz na nb nc aw nd bi"><span id="8b62" class="ne lw jj na b gy nf ng l nh ni">Output:<br/>000 []<br/>001 [1]<br/>010 [4]<br/>011 [4, 1]<br/>100 [3]<br/>101 [3, 1]<br/>110 [3, 4]<br/>111 [3, 4, 1]</span></pre><p id="9dbf" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从上面的输出可以看出，二进制字符串 010 将在索引 1 处获得值 4，而 011 将在索引 1 和 2 处获得[4，1]。一旦我们有了这些值，我们就可以很容易地计算函数<em class="lu"> f </em>的值，并最终得到最大值。</p><h1 id="412d" class="lv lw jj bd lx ly lz ma mb mc md me mf kp mg kq mh ks mi kt mj kv mk kw ml mm bi translated">负载的平均分配</h1><p id="cd6d" class="pw-post-body-paragraph ky kz jj la b lb nj kk ld le nk kn lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">现在，为了对来自数据集的各种组合的函数<em class="lu"> f </em>的计算进行并行化，我们希望将所有组合 2^n 的数量以相等的比例划分。</p><figure class="mt mu mv mw gt iv"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="4f31" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以上方法将数量<em class="lu">计数</em>分成相等数量的桶(除法)。<em class="lu"> num_per_division </em>是除法运算中的数，而<em class="lu"> spill </em>是余数，它被加到初始除法运算中，直到它变为零。上述方法用于将 2^n 划分为多个桶，然后在每个桶上并行进行函数<em class="lu"> f </em>的计算。</p><h1 id="8381" class="lv lw jj bd lx ly lz ma mb mc md me mf kp mg kq mh ks mi kt mj kv mk kw ml mm bi translated">计算所有组合的 f</h1><figure class="mt mu mv mw gt iv"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="e9b5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="lu"> process_combination </em>方法处理一组由等分计算出的数字。它对所有这些数字执行函数<em class="lu"> f </em>并返回最大值。</p><p id="44d5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="lu"> solve_combination </em>把所有东西放在一起。首先，它计算组合的数量，然后将它们分成相等的桶。然后使用<em class="lu"> process_combination </em>方法将这些桶并行化以计算所有桶的函数<em class="lu"> f </em>。</p><h1 id="8629" class="lv lw jj bd lx ly lz ma mb mc md me mf kp mg kq mh ks mi kt mj kv mk kw ml mm bi translated">功能<em class="no"> f </em>的一些例子</h1><p id="7cbc" class="pw-post-body-paragraph ky kz jj la b lb nj kk ld le nk kn lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">在各种情况下，函数<em class="lu"> f </em>的知识可以极大地减少搜索空间。</p><h2 id="0afc" class="ne lw jj bd lx np nq dn mb nr ns dp mf lh nt nu mh ll nv nw mj lp nx ny ml nz bi translated">平均</h2><p id="6959" class="pw-post-body-paragraph ky kz jj la b lb nj kk ld le nk kn lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">假设函数<em class="lu"> f </em>计算所有输入参数(数字)的平均值。</p><figure class="mt mu mv mw gt iv"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="acdf" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果从所有输入数据中选择最大的数字，其平均值将是最大的。因此，在这种情况下，我们可以选择最高的数字，而不是使用 spark。</p><h2 id="afdd" class="ne lw jj bd lx np nq dn mb nr ns dp mf lh nt nu mh ll nv nw mj lp nx ny ml nz bi translated">总和</h2><p id="9118" class="pw-post-body-paragraph ky kz jj la b lb nj kk ld le nk kn lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">类似于均值 if 函数<em class="lu"> f </em>计算所有输入参数(数字)的和。</p><figure class="mt mu mv mw gt iv"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="e909" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以对输入数据中的所有数字求和，因为这是最高的。</p><h2 id="7b63" class="ne lw jj bd lx np nq dn mb nr ns dp mf lh nt nu mh ll nv nw mj lp nx ny ml nz bi translated">正弦</h2><p id="38d7" class="pw-post-body-paragraph ky kz jj la b lb nj kk ld le nk kn lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">如果函数 f 计算所有输入参数之和的正弦，那么我们宁愿使用 spark 解。可能有一个更复杂的函数<em class="lu"> f </em>,在这个函数中，spark 解决方案非常有用。</p><h1 id="4530" class="lv lw jj bd lx ly lz ma mb mc md me mf kp mg kq mh ks mi kt mj kv mk kw ml mm bi translated">单元测试</h1><figure class="mt mu mv mw gt iv"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="245c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面我讨论了如何在没有 spark 解决方案的情况下轻松计算平均值和总和。我使用相同的范例来做单元测试。在均值的情况下，我将 spark 的输出与输入数据的最大值进行比较。对于总和，我将火花输出与所有输入数据的总和进行比较。</p><h1 id="552a" class="lv lw jj bd lx ly lz ma mb mc md me mf kp mg kq mh ks mi kt mj kv mk kw ml mm bi translated">结论</h1><p id="d42a" class="pw-post-body-paragraph ky kz jj la b lb nj kk ld le nk kn lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">在这篇文章中，我提出了一个简单的框架，说明如何使用一个简单的函数<em class="lu"> f，</em>来解决组合问题，尽管解决方案并不局限于此，而是可以应用于无数的问题。希望你喜欢它！</p></div></div>    
</body>
</html>