<html>
<head>
<title>Common Time Series Data Analysis Methods and Forecasting Models in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中常用的时间序列数据分析方法和预测模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/common-time-series-data-analysis-methods-and-forecasting-models-in-python-f0565b68a3d8?source=collection_archive---------14-----------------------#2020-06-22">https://towardsdatascience.com/common-time-series-data-analysis-methods-and-forecasting-models-in-python-f0565b68a3d8?source=collection_archive---------14-----------------------#2020-06-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b555" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用ARIMA和LSTM模型分析用于预测的时间序列数据</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f6fe9e203e1c6fe620778f8289ab8cf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IaFH3-ZYHe89DhDs-eHbNA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片</p></figure><p id="0388" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae lu" href="https://en.wikipedia.org/wiki/Time_series" rel="noopener ugc nofollow" target="_blank">时间序列</a>是以相等的时间间隔按时间顺序获取的数据样本序列。时间序列包括来自金融、医学、科学研究(如全球变暖、语音分析、地震)等不同领域的多种真实实验数据。[1][2].时间序列预测在各个领域都有很多实际应用，例如商业预测(如销售、股票)、天气、死亡等[1]。</p><p id="f0e6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">给定用于预测的监督机器学习的传统(时间顺序独立)数据集，在可以执行特征工程之前需要数据探索和预处理，并且在可以选择机器学习模型并将其应用于工程特征以进行预测之前需要完成特征工程。</p><p id="c981" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">与传统数据集类似，给定一个时间序列数据集，在可以分析时间序列数据之前，需要进行数据探索和预处理，并且在可以选择时间序列预测模型并将其应用于所分析的数据集以进行预测之前，需要进行时间序列数据分析。</p><p id="0b30" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我使用Kaggle [2]的全球变暖数据集来演示Python中一些常见的时间序列数据预处理/分析方法和时间序列预测模型。演示包括以下内容:</p><ul class=""><li id="7cae" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">时间序列数据预处理</li><li id="3ff8" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">时间序列数据分析</li><li id="0f9b" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">时间数列预测法</li></ul><h1 id="fec0" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">1.时间序列数据预处理</h1><p id="2708" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">如前所述，对于时间序列数据，在进行数据分析之前，需要进行数据预处理。</p><h2 id="b0eb" class="ng mk it bd ml nh ni dn mp nj nk dp mt lh nl nm mv ll nn no mx lp np nq mz nr bi translated">1.1加载数据</h2><p id="1db0" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">数据预处理的第一步是从csv文件加载数据。</p><p id="e0db" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">时间顺序在时间序列数据分析和预测中起着至关重要的作用。特别是，时间序列中的每个数据样本必须与唯一的时间点相关联。这可以在Pandas DataFrame/Series中通过使用<em class="ns"> DatetimeIndex </em>类型的值作为其索引值来实现。</p><p id="ce21" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦Kaggle [2]中的地球表面温度数据集被下载到本地机器上，数据集csv文件可被加载到Pandas数据帧中，如下所示:</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="79c4" class="ng mk it nu b gy ny nz l oa ob">df_raw = pd.read_csv('./data/GlobalTemperatures.csv', parse_dates=['dt'], index_col='dt')<br/>df_raw.head()</span></pre><p id="c0d6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">选项<em class="ns"> parse_dates </em>是告诉Pandas将<em class="ns"> dt </em>列中的字符串值解析为Python <em class="ns"> datatime </em>值，而选项<em class="ns"> index_col </em>是告诉Pandas将<em class="ns"> dt </em>列的解析值转换为<em class="ns"> DatatimeIndex </em>类型，然后将它们用作索引。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/09cfab8e704a2845841b27fbbe70223e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cge_3vK0m6MvMR13YS-PIQ.png"/></div></div></figure><p id="67da" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了简单起见，我提取了<em class="ns"> LandAverageTemperature </em>列作为Pandas系列，以便在本文中进行演示:</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="a42d" class="ng mk it nu b gy ny nz l oa ob">df = df_raw['LandAverageTemperature']</span></pre><h2 id="f9da" class="ng mk it bd ml nh ni dn mp nj nk dp mt lh nl nm mv ll nn no mx lp np nq mz nr bi translated">1.2处理缺失数据</h2><p id="f134" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">与传统数据集类似，时间序列数据中经常出现缺失数据，在对数据进行进一步预处理和分析之前，必须对其进行处理。</p><p id="5370" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下代码可以检查缺少多少数据条目:</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="9e2d" class="ng mk it nu b gy ny nz l oa ob">df.isnull().value_counts()</span></pre><p id="e05d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">地球表面温度时间序列中有12项缺失数据。在不破坏过去的时间相关性的情况下，这些丢失的值不能简单地被移除或设置为零。有多种方法可以恰当地处理时间序列中的缺失数据[3]:</p><ul class=""><li id="bad7" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">向前填充</li><li id="470d" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">反向填充</li><li id="436b" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">线性内插法</li><li id="ad53" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">二次插值法</li><li id="eacb" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">最近邻居的平均值</li><li id="f7e6" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">季节对比平均值</li></ul><p id="40e3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我使用向前填充来填充本文中缺少的数据条目:</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="b5e6" class="ng mk it nu b gy ny nz l oa ob">df = df.ffill()</span></pre><h1 id="fa5d" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">2.时间序列数据分析</h1><p id="5b63" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">一旦数据预处理完成，下一步就是分析数据。</p><h2 id="234d" class="ng mk it bd ml nh ni dn mp nj nk dp mt lh nl nm mv ll nn no mx lp np nq mz nr bi translated">2.1可视化数据</h2><p id="4148" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">作为一种常见的实践[1][3][4]，时间序列数据分析的第一步是将数据可视化。</p><p id="8d95" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下代码使用Pandas DataFrame/Series内置绘图方法绘制地球表面温度时间序列:</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="cbcb" class="ng mk it nu b gy ny nz l oa ob">ax = df.plot(figsize=(16,5), title='Earth Surface Temperature')<br/>ax.set_xlabel("Date")<br/>ax.set_ylabel("Temperature")</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/90101e93f31904ff881dcc4eec0bb062.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kc6ZlFv1aXbjum7BqnjrjA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd oe">图1: </strong>地球表面温度。</p></figure><p id="aded" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上图显示，地球表面的平均温度大约在[5，12]的范围内，总体趋势是缓慢上升。由于不同时间序列成分(如基准水平、趋势、季节性)和其他成分(如误差和随机噪声)的混合，图中没有显示其他明显的模式[1][3]。时间序列可以分解成单个的部分，以便进一步分析。</p><h2 id="8883" class="ng mk it bd ml nh ni dn mp nj nk dp mt lh nl nm mv ll nn no mx lp np nq mz nr bi translated">2.2将数据分解成组件</h2><p id="89b8" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">为了将一个时间序列分解成组件以供进一步分析，可以将该时间序列建模为基准水平、趋势、季节性和误差(包括随机噪声)的<em class="ns">加法</em>或<em class="ns">乘法</em>[3]:</p><ul class=""><li id="4333" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated"><strong class="la iu">加法时间序列</strong> : <br/> <em class="ns">数值</em> = <em class="ns">基数</em> <strong class="la iu"> + </strong> <em class="ns">趋势</em> <strong class="la iu"> + </strong> <em class="ns">季节性</em> <strong class="la iu"> + </strong> <em class="ns">误差</em></li><li id="2d82" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><strong class="la iu">乘法时间序列</strong> : <br/> <em class="ns">数值</em> = <em class="ns">基数水平</em> <strong class="la iu"> x </strong> <em class="ns">趋势</em> <strong class="la iu"> x </strong> <em class="ns">季节性</em> <strong class="la iu"> x </strong> <em class="ns">误差</em></li></ul><p id="c0cd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本文将地表温度时间序列建模为<em class="ns">相加</em>时间序列；</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="41c4" class="ng mk it nu b gy ny nz l oa ob">additive = seasonal_decompose(df, model='additive', extrapolate_trend='freq')</span></pre><p id="baac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">选项<code class="fe of og oh nu b">extrapolate_trend='freq'</code>是处理时间序列开始时趋势和残差中的任何缺失值[3]。</p><p id="7d13" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">理论上，通过将选项<em class="ns">模型=‘加法’</em>替换为<em class="ns">模型=‘乘法’，可以很容易地将相同的数据集建模为<em class="ns">乘法</em>时间序列。</em>然而，乘法模型不能应用于该特定数据集，因为数据集包含零值和/或负值，这在<em class="ns">乘法季节性分解</em>中是不允许的。</p><p id="17dc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">加法分解的结果分量可以被提取以形成如下的熊猫数据帧:</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="f1a8" class="ng mk it nu b gy ny nz l oa ob">additive_df = pd.concat([additive.seasonal, additive.trend, additive.resid, additive.observed], axis=1)<br/>additive_df.columns = ['seasonal', 'trend', 'resid', 'actual_values']<br/>additive_df.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/c94c515489ae1a81c3d8c4ce571e7646.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*n35WgxoAPzv_u1Mc9A_eHg.png"/></div></figure><p id="35d5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面的代码是可视化的相加分解成分:趋势、季节和残差(即，基础水平+误差)。</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="91b7" class="ng mk it nu b gy ny nz l oa ob">plt.rcParams.update({'figure.figsize': (10,10)})<br/>additive.plot().suptitle('Additive Decompose')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/112abd80ad719728a5fa32ee95534fc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LomT68JT-nK5xYPOCdIOMg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd oe">图2: </strong>时间序列分解。</p></figure><p id="1afc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于地表温度时间序列数据，我们最感兴趣的是其长期趋势，可提取如下:</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="d315" class="ng mk it nu b gy ny nz l oa ob">trend = additive.trend</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/7b69f58a7b987453dc37ab6fef294ac2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2MsdXZYoFmNJIhioEl6ITw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd oe">图3: </strong>地表温度趋势。</p></figure><h1 id="9f7e" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">3.时间数列预测法</h1><p id="cd6d" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">一旦数据预处理和分析完成，时间序列预测就可以开始了。</p><p id="8701" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本节介绍了将两种常见的时间序列预测模型应用于地球表面温度趋势数据的结果:</p><ul class=""><li id="a2d3" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated"><a class="ae lu" href="https://en.wikipedia.org/wiki/Autoregressive_integrated_moving_average" rel="noopener ugc nofollow" target="_blank"> ARIMA </a>(自回归综合移动平均)</li><li id="37e5" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><a class="ae lu" href="https://en.wikipedia.org/wiki/Long_short-term_memory" rel="noopener ugc nofollow" target="_blank"> LSTM </a>(长短期记忆)</li></ul><h2 id="07d3" class="ng mk it bd ml nh ni dn mp nj nk dp mt lh nl nm mv ll nn no mx lp np nq mz nr bi translated">3.1 ARIMA模式</h2><p id="0d1b" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">ARIMA模型[1][4]由三个参数决定:</p><ul class=""><li id="07a2" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated"><strong class="la iu"> p </strong>:自回归顺序</li><li id="201f" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><strong class="la iu"> d </strong>:使时间序列平稳的差分顺序</li><li id="4c15" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><strong class="la iu">问</strong>:均线下单</li></ul><p id="6771" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">ARIMA模型由三部分组成[4]:自回归(AR)、移动平均(MA)和一个常数:</p><p id="0cec" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">ARIMA =常数+ AR + MA</p><p id="cea7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在哪里</p><p id="540e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">AR =过去时间点的<strong class="la iu"> <em class="ns"> p </em> </strong>连续值的线性组合(即滞后)</p><p id="59b4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">MA =线性组合<strong class="la iu"> <em class="ns"> q </em> </strong>过去时间点的连续预测误差(即滞后预测误差)</p><p id="3037" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">AR和MA都只能应用于平稳的时间序列，这是通过ARIMA差分实现的。</p><p id="f332" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> 3.1.1确定差分d的阶数</strong></p><p id="a489" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一个时间序列是(弱)<em class="ns">平稳的</em>如果它的<em class="ns">均值</em>是常数(与时间无关)并且它的<a class="ae lu" href="https://en.wikipedia.org/wiki/Autocovariance" rel="noopener ugc nofollow" target="_blank"> <em class="ns">自协方差</em> </a>在时间序列的两个不同时间点<em class="ns"> s </em>和<em class="ns"> t </em>之间的函数只取决于时间间隔|s - t|(即滞后)，而不是特定的时间点[1]。</p><p id="6c17" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">时间序列预测仅对平稳时间序列有效，因为只有平稳时间序列的行为是可预测的。</p><p id="8894" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以使用ADF检验(<a class="ae lu" href="https://en.wikipedia.org/wiki/Augmented_Dickey%E2%80%93Fuller_test" rel="noopener ugc nofollow" target="_blank">扩展的Dickey Fuller检验</a> ) [4]来检验一个时间序列是否是平稳的。例如，下面的代码将检查地球表面温度时间序列的平稳性:</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="7d09" class="ng mk it nu b gy ny nz l oa ob">from statsmodels.tsa.stattools import adfuller</span><span id="0425" class="ng mk it nu b gy ol nz l oa ob">result = adfuller(trend.values)<br/>print('ADF Statistic: %f' % result[0])<br/>print('p-value: %f' % result[1])</span></pre><p id="c86d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">测试的p值为0.012992。</p><p id="d04e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">ADF检验的默认零假设是时间序列是非平稳的。由于上述ADF测试的p值小于0.05的显著性水平，我们拒绝零假设，并得出时间序列是平稳的结论(在这种情况下只有<a class="ae lu" href="https://en.wikipedia.org/wiki/Stationary_process" rel="noopener ugc nofollow" target="_blank">趋势平稳</a>)。</p><p id="a72f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一般来说，要使时间序列平稳，需要做以下工作:</p><ul class=""><li id="4dd2" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">移除会随时间改变均值和/或协方差的不规则行为</li><li id="e989" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">去除可能随时间改变均值和/或协方差的常规行为，如趋势和季节性</li></ul><p id="c44e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">差分是一种常用的数据转换方法，用于消除非平稳行为(尤其是趋势)。</p><p id="bfea" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下代码用于对地表温度时间序列进行一阶和二阶差分:</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="f587" class="ng mk it nu b gy ny nz l oa ob">from statsmodels.graphics.tsaplots import plot_acf, plot_pacf</span><span id="a7be" class="ng mk it nu b gy ol nz l oa ob"># Original Series<br/>fig, axes = plt.subplots(3, 2, sharex=True)<br/>axes[0, 0].plot(trend.values); axes[0, 0].set_title('Original Series')<br/>plot_acf(trend.values, ax=axes[0, 1]).suptitle('Original Series', fontsize=0)</span><span id="38d3" class="ng mk it nu b gy ol nz l oa ob"># 1st Differencing<br/>diff1 = trend.diff().dropna()<br/>axes[1, 0].plot(diff1.values)<br/>axes[1, 0].set_title('1st Order Differencing')<br/>plot_acf(diff1.values, ax=axes[1, 1]).suptitle('1st Order Differencing', fontsize=0)</span><span id="1054" class="ng mk it nu b gy ol nz l oa ob"># 2nd Differencing<br/>diff2 = trend.diff().diff().dropna()<br/>axes[2, 0].plot(diff2.values)<br/>axes[2, 0].set_title('2nd Order Differencing')<br/>plot_acf(diff2.values, ax=axes[2, 1]).suptitle('2nd Order Differencing', fontsize=0)</span></pre><p id="ec33" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下图显示一阶差分足以消除趋势。二阶差分没有任何改进。因此，在本文中，差分顺序<em class="ns"> d </em>被设置为1。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/df2e1333b7a0d6e096cc09f46ba9f19e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TsUMohcI9-nRN1YAkUKXNg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd oe">图4: </strong>一阶和二阶差分。</p></figure><p id="7fa2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> 3.1.2确定自回归阶数p </strong></p><p id="b6d5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过分析时间序列数据[1][4]的一阶差分的PACF ( <a class="ae lu" href="https://en.wikipedia.org/wiki/Partial_autocorrelation_function" rel="noopener ugc nofollow" target="_blank">偏自相关函数</a>)的结果，可以确定自回归阶数<em class="ns"> p </em>:</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="92bc" class="ng mk it nu b gy ny nz l oa ob">plt.rcParams.update({'figure.figsize':(9,3), 'figure.dpi':120})</span><span id="5e13" class="ng mk it nu b gy ol nz l oa ob">size = 100</span><span id="a71b" class="ng mk it nu b gy ol nz l oa ob">fig, axes = plt.subplots(1, 2, sharex=True)<br/>axes[0].plot(diff1.values[:size])<br/>axes[0].set_title('1st Order Differencing')<br/>axes[1].set(ylim=(0,5))<br/>plot_pacf(diff1.values[:size], lags=50, ax=axes[1]).suptitle('1st Order Differencing', fontsize=0)</span></pre><p id="7e8f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以观察到PACF滞后1远远高于显著性线(灰色区域)。因此，自回归顺序<em class="ns"> p </em>在本文中被设置为1。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/6f3701bf6273358c4f8e5354682a98fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DT2nLcdTCCUfJtCA_R4c4w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd oe">图5: </strong>一阶差分PACF。</p></figure><p id="b92f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> 3.1.3确定移动平均顺序q </strong></p><p id="f5c8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">移动平均阶数<em class="ns"> q </em>可以通过分析时间序列数据的一阶差分的自相关函数(ACF)的结果来确定[1][4]:</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="aa7c" class="ng mk it nu b gy ny nz l oa ob">plt.rcParams.update({'figure.figsize':(9,3), 'figure.dpi':120})</span><span id="7f09" class="ng mk it nu b gy ol nz l oa ob">size = 100</span><span id="89e0" class="ng mk it nu b gy ol nz l oa ob">fig, axes = plt.subplots(1, 2, sharex=True)<br/>axes[0].plot(diff1.values[:size])<br/>axes[0].set_title('1st Order Differencing')<br/>axes[1].set(ylim=(0,1.2))<br/>plot_acf(diff1.values[:size], lags=50, ax=axes[1]).suptitle('1st Order Differencing', fontsize=0)</span></pre><p id="cc3f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以观察到ACF滞后1远远高于显著性线(灰色区域)。因此，在本文中，移动平均顺序<em class="ns"> q </em>也被设置为1。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/ae0a794e666711fa25dabba38f295863.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hHMjTuKqo9qFBnEJoreopA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd oe">图6: </strong>一阶差分的ACF。</p></figure><p id="1662" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> 3.1.4培训ARIMA模型</strong></p><p id="66dc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下代码首先将地表温度趋势时间序列分为训练和测试子序列，然后使用训练数据训练一个ARIMA模型，其确定值为<em class="ns"> p </em> =1，<em class="ns"> d </em> =1，<em class="ns"> q </em> = 1。</p><p id="bb00" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">传统的数据集通常被随机分为训练和测试子集。但是，这对时间序列无效，因为它打破了顺序时间依赖性。为了避免这个问题，温度趋势时间序列数据通过保持其原始顺序来划分。</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="a2b9" class="ng mk it nu b gy ny nz l oa ob">from statsmodels.tsa.arima_model import ARIMA</span><span id="2fa5" class="ng mk it nu b gy ol nz l oa ob">train = trend[:3000]<br/>test  = trend[3000:]</span><span id="a686" class="ng mk it nu b gy ol nz l oa ob"># order = (p=1, d=1, q=1)<br/>model = ARIMA(train, order=(1, 1, 1))  <br/>model = model.fit(disp=0)  <br/>print(model.summary())</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/7b40933817c059f37c0d5b994f0abb31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hexo6FlzTa8Y1R01WR3fVw.png"/></div></div></figure><p id="eb57" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从上面的模型训练结果可以看出，p&gt;|z|列中AR1和MA1的P值是高度显著的(&lt;&lt; 0.05). This indicates that the choices of p =1 and q =1 are appropriate.</p><p id="fb6a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">The code below is to plot the residuals.</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="3739" class="ng mk it nu b gy ny nz l oa ob"># Plot residual errors<br/>residuals = pd.DataFrame(model.resid)<br/>fig, ax = plt.subplots(1,2)<br/>residuals.plot(title="Residuals", ax=ax[0])<br/>residuals.plot(kind='kde', title='Density', ax=ax[1])</span></pre><p id="a756" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">The plot of the residuals shows no patterns (i.e., with constant mean and variance) except for the first 20% of the time series. This indicates that the trained ARIMA model behaves appropriately.</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/d0c8dd4dedcf19a9e1da2f6c3ec51812.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gxaMEHnwXqPry9F-8SWCVg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd oe">图7: </strong>残差分布。</p></figure><p id="b49b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> 3.1.5使用训练好的ARIMA模型进行预测</strong></p><p id="de22" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面的代码使用经过训练的ARIMA模型来预测192个(可以是任何正整数)温度值，然后将它们与测试时间序列进行比较:</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="88db" class="ng mk it nu b gy ny nz l oa ob"># Forecast: 192 forecasting values with 95% confidence<br/>fc, se, conf = model.forecast(192, alpha=0.05)</span><span id="f8d2" class="ng mk it nu b gy ol nz l oa ob"># Make as pandas series<br/>fc_series = pd.Series(fc, index=test.index)<br/>lower_series = pd.Series(conf[:, 0], index=test.index)<br/>upper_series = pd.Series(conf[:, 1], index=test.index)</span><span id="97e4" class="ng mk it nu b gy ol nz l oa ob"># Plot<br/>plt.figure(figsize=(12,5), dpi=100)<br/>plt.plot(train, label='training')<br/>plt.plot(test, label='actual')<br/>plt.plot(fc_series, label='forecast')<br/>plt.fill_between(lower_series.index, lower_series, upper_series, <br/>                 color='k', alpha=.15)<br/>plt.title('Forecast vs Actuals')<br/>plt.legend(loc='upper left', fontsize=8)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/fa6da93c5dc16ad8988ae06c73beb944.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ItwFHVceMMONDqcYVBPhgw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd oe">图8: </strong>利用ARIMA进行气温预报。</p></figure><p id="bc16" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上述预测结果表明，经过训练的ARIMA模型预测的温度往往低于实际温度。</p><h2 id="822a" class="ng mk it bd ml nh ni dn mp nj nk dp mt lh nl nm mv ll nn no mx lp np nq mz nr bi translated">3.2 LSTM模式</h2><p id="aedf" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">本节介绍将著名的LSTM模型应用于地球表面温度趋势时间序列的结果。</p><p id="5d06" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> 3.2.1准备数据集</strong></p><p id="9374" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">与[6]类似，下面的代码从温度时间序列中生成特征向量对(过去时间点的温度值序列)和标签对(当前时间点的目标温度),用于LSTM模型训练和评估。</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="7826" class="ng mk it nu b gy ny nz l oa ob">from numpy import array<br/>from keras.models import Sequential<br/>from keras.layers import LSTM<br/>from keras.layers import Dense</span><span id="5881" class="ng mk it nu b gy ol nz l oa ob">def split_sequence(sequence, n_steps):<br/>    X, y = list(), list()<br/>    for i in range(len(sequence)):<br/>        # find the end of this pattern<br/>        end_ix = i + n_steps<br/>        # check if we are beyond the sequence<br/>        if end_ix &gt; len(sequence)-1:<br/>            break<br/>        # gather input and output parts of the pattern<br/>        seq_x, seq_y = sequence[i:end_ix], sequence[end_ix]<br/>        X.append(seq_x)<br/>        y.append(seq_y)<br/>    return array(X), array(y)</span><span id="b930" class="ng mk it nu b gy ol nz l oa ob"># define input sequence<br/>raw_seq = trend.tolist()<br/># choose a number of time steps<br/>n_steps = 12<br/># split into samples<br/>X, y = split_sequence(raw_seq, n_steps)</span></pre><p id="32f4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了简单起见，在本文中，我使用过去12个月的温度来预测下个月的温度。以下是生成的数据集的两个示例:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/e2a987c17e7d8d138954d29ea291acdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wqRY4XJ1dk2yf-LgR6FGaA.png"/></div></div></figure><p id="6653" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">生成的数据集分为两部分:前3000个数据集用于模型训练，其余数据集用于模型测试:</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="735f" class="ng mk it nu b gy ny nz l oa ob">X_train = X[:3000]<br/>y_train = y[:3000]<br/>X_test  = X[3000:]<br/>y_test  = y[3000:]</span></pre><p id="b5ca" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> 3.2.2选择LSTM型号</strong></p><p id="182e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下LSTM模型[6]将一系列温度值作为输入，并生成一个目标温度作为输出。由于温度预测是一个回归问题，LSTM模型的输出可以取任何值，因此没有相关的激活函数。</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="a118" class="ng mk it nu b gy ny nz l oa ob">n_features = 1</span><span id="d33a" class="ng mk it nu b gy ol nz l oa ob">X_train = X_train.reshape((X_train.shape[0], X_train.shape[1], n_features))</span><span id="151b" class="ng mk it nu b gy ol nz l oa ob"># define model<br/>model = Sequential()<br/>model.add(LSTM(50, activation='relu', input_shape=(n_steps, n_features)))<br/>model.add(Dense(1))<br/>model.compile(optimizer='adam', loss='mse')<br/># fit model<br/>model.fit(X_train, y_train, epochs=200, verbose=1)</span></pre><p id="3430" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> 3.2.3培训LSTM模型</strong></p><p id="4acd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是模型训练的结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/73240f12a1e6ce4b6f323565c88740a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J3OXpCS09qlEcCGXhmTe3g.png"/></div></div></figure><p id="a187" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> 3.2.4使用训练好的LSTM模型进行预测</strong></p><p id="2249" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦模型训练完成，经过训练的LSTM模型就可以应用于测试时间序列来预测温度:</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="6558" class="ng mk it nu b gy ny nz l oa ob">X_test = X_test.reshape((X_test.shape[0], X_test.shape[1], n_features))<br/>y_pred = model.predict(X_test, verbose=0)</span></pre><p id="b4c1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面的代码将预测温度与测试时间序列中的实际温度进行了对比:</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="e0e0" class="ng mk it nu b gy ny nz l oa ob">def plot_forecosting(df1, df2, line_stype1='b-', line_stype2='r--', title="", xlabel='Date', ylabel='Temperature', dpi=100):<br/>    plt.figure(figsize=(16,5), dpi=dpi)<br/>    plt.plot(df1.index, df1, line_stype1, label='actual') <br/>    plt.plot(df2.index, df2, line_stype2, label='forecast')<br/>    plt.gca().set(title=title, xlabel=xlabel, ylabel=ylabel)<br/>    plt.title('Forecast vs Actuals')<br/>    plt.legend(loc='upper left', fontsize=8)<br/>    plt.show()</span><span id="61ca" class="ng mk it nu b gy ol nz l oa ob">y_pred_1 = y_pred.reshape((y_pred.shape[0]))<br/>y_pred_series = pd.Series(y_pred_1)<br/>y_test_1 = y_test.reshape((y_test.shape[0]))<br/>y_test_series = pd.Series(y_test_1)</span><span id="a9c4" class="ng mk it nu b gy ol nz l oa ob">plot_forecosting(y_test_series, y_pred_series, title='Land Average Temperature')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/91ef8860f030426381f6172711e8dd35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UWUafq-XPpZH2uBRkCZTmQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd oe">图9: </strong>利用LSTM进行气温预报。</p></figure><p id="eaea" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">预测温度与整个温度趋势时间序列的关系如下:</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="1e2b" class="ng mk it nu b gy ny nz l oa ob">X_all = X.reshape((X.shape[0], X.shape[1], n_features))<br/>y_pred_all = model.predict(X_all, verbose=0)<br/>y_pred_all_1 = y_pred_all.reshape((y_pred_all.shape[0]))<br/>y_pred_all_series = pd.Series(y_pred_all_1)<br/>y_all = y.reshape((y.shape[0]))<br/>y_all_series = pd.Series(y_all)<br/>plot_forecosting(y_all_series, y_pred_all_series, title='Land Average Temperature')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/840ed908cfb0989291f08deaa548832c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b0YNVnXDsdDiC91DAL4ksg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd oe">图10: </strong>利用LSTM进行全时间序列的温度预报。</p></figure><p id="7a0d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上述预报结果表明，预报温度与实际温度非常接近。</p><h1 id="fbf4" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">4.摘要</h1><p id="9584" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">在本文中，我使用了Kaggle [2]的全球变暖数据集来演示一些常见的时间序列数据预处理/分析实践，以及Python中两个广泛采用的时间序列预测模型ARIMA和LSTM。</p><p id="65e5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从第3节可以看出，ARIMA模型的性能严重依赖于数据预处理和分析，以使时间序列平稳，而LSTM可以用最少的数据预处理和分析来处理时间序列(例如，在LSTM模型中不需要通过差分来消除趋势)。</p><p id="96ad" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本文中使用的所有源代码都可以在Github [7]中找到。</p><h1 id="d75d" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">参考</h1><ol class=""><li id="d9b9" class="lv lw it la b lb nb le nc lh ow ll ox lp oy lt oz mb mc md bi translated">R.Shumway和D. Stoffer，时间序列分析及其应用，Springer，第4版，2017年</li><li id="e8b0" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt oz mb mc md bi translated"><a class="ae lu" href="https://www.kaggle.com/berkeleyearth/climate-change-earth-surface-temperature-data?select=GlobalTemperatures.csv" rel="noopener ugc nofollow" target="_blank">气候变化:地表温度数据</a></li><li id="dce0" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt oz mb mc md bi translated">南Prabhakaran，<strong class="la iu"><em class="ns"/></strong><a class="ae lu" href="https://www.machinelearningplus.com/time-series/time-series-analysis-python/" rel="noopener ugc nofollow" target="_blank">Python中的时间序列分析—带示例的综合指南</a></li><li id="70a2" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt oz mb mc md bi translated">南普拉巴卡兰，<a class="ae lu" href="https://www.machinelearningplus.com/time-series/arima-model-time-series-forecasting-python/" rel="noopener ugc nofollow" target="_blank"> ARIMA模型Python中时间序列预测的完整指南</a></li><li id="36fc" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt oz mb mc md bi translated">J.Brownlee，<strong class="la iu"> </strong> <a class="ae lu" href="https://machinelearningmastery.com/remove-trends-seasonality-difference-transform-python/" rel="noopener ugc nofollow" target="_blank">如何用Python中的差分变换去除趋势和季节性</a></li><li id="0c55" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt oz mb mc md bi translated">J.Brownlee，<a class="ae lu" href="https://machinelearningmastery.com/how-to-develop-lstm-models-for-time-series-forecasting/" rel="noopener ugc nofollow" target="_blank">如何开发用于时间序列预测的LSTM模型</a></li><li id="49ad" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt oz mb mc md bi translated">Y.张<a class="ae lu" href="https://github.com/yzzhang/machine-learning/tree/master/time_series" rel="noopener ugc nofollow" target="_blank"> Github </a>中的Jupyter笔记本</li></ol></div></div>    
</body>
</html>