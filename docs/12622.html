<html>
<head>
<title>Joining DataFrames matching by substring with Python Pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Python Pandas 连接按子串匹配的数据帧</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/joining-dataframes-by-substring-match-with-python-pandas-8fcde5b03933?source=collection_archive---------18-----------------------#2020-08-31">https://towardsdatascience.com/joining-dataframes-by-substring-match-with-python-pandas-8fcde5b03933?source=collection_archive---------18-----------------------#2020-08-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5412" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何使用笛卡尔积连接两个数据帧，其中一个具有全文值，另一个具有子串。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/540030bc4e17268520bfdf095fd7f274.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dCRaJyITmXCkIS1wZc-GKw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源 https://getrefe.tumblr.com/<a class="ae ky" href="https://getrefe.tumblr.com/" rel="noopener ugc nofollow" target="_blank">的 REFE</a></p></figure><h1 id="1b10" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">源代码</h1><p id="26e3" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">下一个为<em class="mn"> Jupyter 笔记本</em>制作的 Python 熊猫代码在<a class="ae ky" href="https://github.com/cristiansaavedra/Python-Pandas-Tooltip/tree/master/02%20Join%20two%20Dataframes%20by%20approximate%20column%20string%20matching" rel="noopener ugc nofollow" target="_blank"> GitHub </a>中可用，它回答了这个问题:“哪些任务不匹配？”</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="534c" class="kz la it bd lb lc mx le lf lg my li lj jz mz ka ll kc na kd ln kf nb kg lp lq bi translated">数据</h1><p id="46b2" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">代码的第一部分创建两个数据帧:<strong class="lt iu"> df1 </strong>和<strong class="lt iu"> df2。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/5e91e9e71798c99f2b98f6e25c582b1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mcrXDpygtyygxc5Gih7EgA.png"/></div></div></figure><p id="b699" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated"><strong class="lt iu"> df1 </strong>数据帧在<strong class="lt iu"> task_name </strong>列中有任务的完整名称。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/59b399d94b87c0c95425c810425816f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J71oWPdDXpuPyBEHBNNG0A.png"/></div></div></figure><p id="2ea3" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">并且<strong class="lt iu"> df2 </strong> DataFrame 在<strong class="lt iu"> partial_task_name </strong>列中有一个子串。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/c13ead4055b76daedcfbea5f358d09b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DcUWk6XEBo6RObGwhbjoDw.png"/></div></div></figure><p id="e8a4" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">看，<strong class="lt iu"> partial_task_name </strong>中的值<strong class="lt iu"> BC </strong>是 A <strong class="lt iu"> BC </strong>和<strong class="lt iu"> BC </strong> D 的子串，这种情况下预期的结果一定会产生很多行，但是怎么才能得到很多行呢？答案是使用笛卡尔积或交叉连接。</p><h1 id="318d" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">连接</h1><p id="e85b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">要在 Pandas 中做笛卡尔乘积，请执行以下步骤:</p><ol class=""><li id="b179" class="nk nl it lt b lu nd lx ne ma nm me nn mi no mm np nq nr ns bi translated">在每个数据帧中添加一个具有相同值的虚拟列</li><li id="5876" class="nk nl it lt b lu nt lx nu ma nv me nw mi nx mm np nq nr ns bi translated">通过新列进行联接</li><li id="8254" class="nk nl it lt b lu nt lx nu ma nv me nw mi nx mm np nq nr ns bi translated">删除每个数据帧中的新列</li></ol><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="3900" class="od la it nz b gy oe of l og oh">df1['<strong class="nz iu">join</strong>'] = 1<br/>df2['<strong class="nz iu">join</strong>'] = 1<br/><br/>dfFull = df1.merge(df2, on='<strong class="nz iu">join</strong>').drop('<strong class="nz iu">join</strong>', axis=1)<br/>df2.drop('<strong class="nz iu">join</strong>', axis=1, inplace=True)</span></pre><h1 id="d139" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">这场比赛</h1><p id="c16b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果<strong class="lt iu"> partial_task_name </strong>列在<strong class="lt iu"> task_name </strong>列中，下一步是在返回的结果数据帧中添加一个新列。我们将使用一个 lambda 和“find”函数，其中结果≥ 0</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="2550" class="od la it nz b gy oe of l og oh">dfFull['match'] = dfFull.apply(lambda x: x.task_name.find(x.partial_task_name), axis=1).ge(0)</span></pre><p id="189b" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">该产品为<strong class="lt iu"> dfFull </strong>数据帧</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/f8e70bfb51748a6dc9a3b938e3b04df3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NPoKaQULo6JPm99KaRjV0A.png"/></div></div></figure><p id="4a16" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">我们按<strong class="lt iu">任务名</strong>、<strong class="lt iu">管道名</strong>做一个分组，得到匹配的最大值<strong class="lt iu">、</strong>进行过滤。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/1fc44e2b150fb78e34a6c9806f538d33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jZRn2MwrEd2VNIx6MD5kbg.png"/></div></div></figure><h1 id="2481" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">好答案</h1><p id="7f48" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了知道哪些任务不存在于<strong class="lt iu"> df2 </strong>数据帧中，我们通过<strong class="lt iu">匹配</strong>列进行了一个负过滤:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/b8839145f2ed31083357f93d570fdb46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SMWBpixaeZyX1QQfUdHpPg.png"/></div></div></figure><h1 id="49b1" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">不好的答案</h1><p id="e696" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果我们不使用笛卡尔积，而是尝试在<strong class="lt iu"> df2 </strong>数据帧中添加第一个匹配，然后用<strong class="lt iu"> df1 </strong>数据帧进行左连接</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/7e09449ba078787fed948dc6b5eb9d0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jiiy9YjjSEOJkdL8epVTnQ.png"/></div></div></figure><p id="4ee0" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">我们正在犯一个常见的错误，那就是它给了我们错误的答案。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/b0eefa84075a685b217b3944ff98b54c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5ytDxliqNCCmP9idyDwfzg.png"/></div></div></figure><p id="a45a" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">因为我们在用第一个搭配的时候，<strong class="lt iu"> ABC </strong>搭配的是<strong class="lt iu"> BC </strong>而不是<strong class="lt iu"> BCD。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/2e200c36e81310c5e9b7370228d6db81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z0rNSZjXZ5WguOG7GPURJg.png"/></div></div></figure></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><p id="6be1" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">有一种更通用的技术叫做<a class="ae ky" href="https://en.m.wikipedia.org/wiki/Approximate_string_matching" rel="noopener ugc nofollow" target="_blank">近似字符串匹配</a>或者通俗地说叫做模糊查找，它也试图解决相似或部分不连续的子字符串。如果是你的情况，你可以试试<strong class="lt iu"> fuzzywuzzy。</strong></p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><p id="2bd8" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">感谢<strong class="lt iu"> Charles Romestant </strong>给了我写这篇文章的灵感</p><p id="76d1" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated"><a class="ae ky" href="https://medium.com/@cristiansaavedra" rel="noopener">快乐码！</a></p></div></div>    
</body>
</html>