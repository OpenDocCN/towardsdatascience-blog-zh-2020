<html>
<head>
<title>How to Quickly Create and Unpack Lists with Pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何快速创建和打开熊猫列表</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-quickly-create-and-unpack-lists-with-pandas-d0e78e487c75?source=collection_archive---------15-----------------------#2020-07-19">https://towardsdatascience.com/how-to-quickly-create-and-unpack-lists-with-pandas-d0e78e487c75?source=collection_archive---------15-----------------------#2020-07-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="0241" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">大蟒</h2><div class=""/><div class=""><h2 id="594e" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">使用 df.explode()解决使用熊猫数据框架时的常见问题</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/d459e51efeced7f7e92db2308f564680.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JAdqHfWdRSeVyheET8ub-Q.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">当你需要打开清单时，很快你就会像这个人一样微笑</p></figure><p id="229a" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">预处理和“数据争论”占用了大量时间，但这并不总是数据分析项目中最有趣的部分。</p><p id="aa39" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">当涉及到重新格式化初始数据时，必须解包一个列表。幸运的是，Pandas 提供了许多常见问题的矢量化解决方案，所以我们不必为在数据帧中解包列表而感到太大压力。</p><p id="3cb0" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在这篇文章中，我们将关注两件事:</p><ul class=""><li id="537f" class="md me it lj b lk ll ln lo lq mf lu mg ly mh mc mi mj mk ml bi translated">如何使用<code class="fe mm mn mo mp b">df.explode()</code>取消数据帧中带有列表值的列嵌套；</li><li id="1ea7" class="md me it lj b lk mq ln mr lq ms lu mt ly mu mc mi mj mk ml bi translated">如何使用<code class="fe mm mn mo mp b">Series.str.split()</code>从一个字符串创建一个列表。</li></ul><p id="a101" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们将使用<a class="ae mv" href="https://www.kaggle.com/gregorut/videogamesales" rel="noopener ugc nofollow" target="_blank">这个</a>视频游戏销售数据的修改版本，所以如果你想跟进的话，可以下载 csv 文件。这一次，我在最底部加入了代码来获取每个示例的初始表。我建议先浏览一遍这段代码，然后复制代码以获得输入，然后再尝试示例。</p><h1 id="5511" class="mw mx it bd my mz na nb nc nd ne nf ng ki nh kj ni kl nj km nk ko nl kp nm nn bi translated">如何在熊猫数据框架中取消嵌套(分解)一列</h1><p id="3b5c" class="pw-post-body-paragraph lh li it lj b lk no kd lm ln np kg lp lq nq ls lt lu nr lw lx ly ns ma mb mc im bi translated">我们的初始表格如下所示:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nt"><img src="../Images/579a60f035e80275f80f12045b055779.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wlI121hkLfdvkuZW7Ef10w.png"/></div></div></figure><p id="4d43" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">目标是分隔“流派”列中的所有值，以便每行只有一个值。就数据库规范化而言，这将是实现“第一范式”的一个步骤，在第一范式中，每一列只包含原子(不可分的)值。</p><p id="5d5b" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">为此，我们需要做的就是使用<code class="fe mm mn mo mp b">df.explode()</code>功能。我们只需要传递一个参数，它是包含列表 like 值的列的名称。</p><p id="28f4" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们的代码是这样的。</p><pre class="ks kt ku kv gt nu mp nv nw aw nx bi"><span id="f5df" class="ny mx it mp b gy nz oa l ob oc">df2 = df2.explode('Genre').drop_duplicates()</span></pre><p id="8899" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">结果数据帧的子集如下所示:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi od"><img src="../Images/6fe75cff2be66c1bc697342f8f091f13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*J839TKIJMkoue_2m1egg5w.png"/></div></figure><p id="df29" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在我们有了一个包含每个出版商所有不同类型的表格。我们还通过在数据帧上传递<code class="fe mm mn mo mp b">.drop_duplicates()</code>来确保只有唯一的值。</p><p id="e28e" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">您会注意到原始数据帧中的索引值是为每一行保留的，这表明<code class="fe mm mn mo mp b">df.explode()</code>函数所做的只是在 iterable 中分离元素，同时保持所有其他行的值不变。如果我们想要新的索引值，我们也可以轻松地通过<code class="fe mm mn mo mp b">.reset_index()</code>。</p><h1 id="f083" class="mw mx it bd my mz na nb nc nd ne nf ng ki nh kj ni kl nj km nk ko nl kp nm nn bi translated">如何在 Pandas 数据框架中创建(和解包)一个具有列表式值的列</h1><p id="dc72" class="pw-post-body-paragraph lh li it lj b lk no kd lm ln np kg lp lq nq ls lt lu nr lw lx ly ns ma mb mc im bi translated">在最后一个问题中，我们使用了一个包含一列列表的数据帧。然而，您经常会处理不完全符合预定义的 Pandas 函数的数据。例如，假设我们有一个类似于上一个问题的表格，如下所示:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oe"><img src="../Images/00aaea74e0137785264ca9531b9557ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pI39qnvg0mQ1Ma4AtU4bZg.png"/></div></div></figure><p id="eccf" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">你能看出区别吗？</p><p id="9064" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">“流派”列中仍有一堆值，但它们不再在 Python 列表中。<code class="fe mm mn mo mp b">df.explode()</code>函数不起作用，因为根据它的文档:</p><blockquote class="of"><p id="3ce7" class="og oh it bd oi oj ok ol om on oo mc dk translated">这个例程(df.explode)将分解类似列表的内容，包括列表、元组、序列和 np.ndarray。</p></blockquote><p id="7a84" class="pw-post-body-paragraph lh li it lj b lk op kd lm ln oq kg lp lq or ls lt lu os lw lx ly ot ma mb mc im bi translated">我们目前对每个列值都有多个条目，但是它们不是“类似列表”的格式。我们只有一堆很长的字符串。</p><p id="9ec1" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">为了将子字符串组合成一个列表，我们将使用一行简单的代码将字符串转换成一个列表:</p><pre class="ks kt ku kv gt nu mp nv nw aw nx bi"><span id="efc5" class="ny mx it mp b gy nz oa l ob oc">df3['Genre'] = df3['Genre'].str.split(',')</span></pre><p id="d802" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这里，我们在“流派”列上使用了<code class="fe mm mn mo mp b">Series.str.split()</code>方法来创建一个列表。顾名思义，这个方法在您指定的分隔符上分割字符串，在我们的例子中是逗号。如果你不向<code class="fe mm mn mo mp b">split()</code>传递任何东西，这个方法将试图在空白上分割一个字符串，但是我们的字符串没有空白。</p><p id="ab36" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">生成的表格如下所示:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ou"><img src="../Images/0db3939c58f86abdab5b32a401cdd070.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nr-pv7PR2T13jGgq8p9C1A.png"/></div></div></figure><p id="14f4" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在，我们有了一个与前一个几乎相同的表，只是这次所有不同的值都在一个列表中。</p><p id="efd7" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们现在要做的就是运行与第一个问题中相同的代码行:</p><pre class="ks kt ku kv gt nu mp nv nw aw nx bi"><span id="afd4" class="ny mx it mp b gy nz oa l ob oc">df3 = df3.explode('Genre')</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/5627f5f4dc10a658aae51ae864bab43c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*H4c-sRUqNO69Pdya8rtNNA.png"/></div></figure></div><div class="ab cl ow ox hx oy" role="separator"><span class="oz bw bk pa pb pc"/><span class="oz bw bk pa pb pc"/><span class="oz bw bk pa pb"/></div><div class="im in io ip iq"><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/50cccccf7dff7358520c62514b709081.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ax2e34RLpPXbQoR0RQOf0A.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">姐姐创作的漫画</p></figure><p id="7d32" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我希望你发现这个快速浏览<code class="fe mm mn mo mp b">df.melt</code>对你的熊猫工作有用！如果你需要在你的数据框架中创建或者解压列表，你可以分别使用<code class="fe mm mn mo mp b">Series.str.split()</code>和<code class="fe mm mn mo mp b">df.explode()</code>方法。</p><p id="25d5" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">正如所承诺的，下面是设置这两个示例的代码:</p><pre class="ks kt ku kv gt nu mp nv nw aw nx bi"><span id="d386" class="ny mx it mp b gy nz oa l ob oc">import pandas as pd</span><span id="72d2" class="ny mx it mp b gy pd oa l ob oc">df = pd.read_csv('vgsales.csv').dropna()<br/>df['Year'] = df['Year'].astype(int)</span><span id="1cc3" class="ny mx it mp b gy pd oa l ob oc"># problem 1<br/>df2 = df.groupby('Publisher')['Genre'].apply(','.join).reset_index()<br/>df2 = df2.loc[(df2['Publisher']=='Nintendo') | (df2['Publisher']=='Ubisoft') | (df2['Publisher']=='Activision')]<br/>df2['Genre'] = df2['Genre'].str.strip().str.split(',')</span><span id="08a8" class="ny mx it mp b gy pd oa l ob oc"># problem 2<br/>df3 = df.groupby('Publisher')['Genre'].apply(','.join).reset_index()<br/>df3 = df3.loc[(df3['Publisher']=='Infogrames') | (df3['Publisher']=='Wanadoo')]</span></pre><p id="f1ab" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">你可以看到我使用了<code class="fe mm mn mo mp b">.loc[]</code>函数为我的数据帧设置了一些条件，所以如果你还不熟悉使用它，你可以看看这个:</p><div class="pe pf gp gr pg ph"><a rel="noopener follow" target="_blank" href="/you-dont-always-have-to-loop-through-rows-in-pandas-22a970b347ac"><div class="pi ab fo"><div class="pj ab pk cl cj pl"><h2 class="bd jd gy z fp pm fr fs pn fu fw jc bi translated">你不需要总是在熊猫的行列中循环！</h2><div class="po l"><h3 class="bd b gy z fp pm fr fs pn fu fw dk translated">用向量化解决方案看一下“for 循环”的替代方案。</h3></div><div class="pp l"><p class="bd b dl z fp pm fr fs pn fu fw dk translated">towardsdatascience.com</p></div></div><div class="pq l"><div class="pr l ps pt pu pq pv lb ph"/></div></div></a></div><p id="58ce" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我在这里也使用了<code class="fe mm mn mo mp b">.apply()</code>，这是一种沿着数据帧的轴执行函数的简单方法。对于逐行编辑数据帧的另一种方法(我建议只在遇到问题<em class="pw">没有</em>的矢量化熊猫解决方案时才使用)，请查看以下内容:</p><div class="pe pf gp gr pg ph"><a rel="noopener follow" target="_blank" href="/a-really-simple-way-to-edit-row-by-row-in-a-pandas-dataframe-75d339cbd313"><div class="pi ab fo"><div class="pj ab pk cl cj pl"><h2 class="bd jd gy z fp pm fr fs pn fu fw jc bi translated">一个非常简单的方法来编辑熊猫数据帧中的一行一行</h2><div class="po l"><h3 class="bd b gy z fp pm fr fs pn fu fw dk translated">使用 pd.loc 根据条件更改数据的子集。</h3></div><div class="pp l"><p class="bd b dl z fp pm fr fs pn fu fw dk translated">towardsdatascience.com</p></div></div><div class="pq l"><div class="px l ps pt pu pq pv lb ph"/></div></div></a></div><p id="7da4" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">祝你和熊猫的冒险之旅好运！</p></div></div>    
</body>
</html>