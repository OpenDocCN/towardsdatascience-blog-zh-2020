<html>
<head>
<title>Outstanding results predicting Apple Stock with Continual ML using Global News (with Python)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用全球新闻(使用Python)通过连续ML预测苹果股票的出色结果</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/making-a-continual-ml-pipeline-to-predict-apple-stock-with-global-news-python-90e5d6610b21?source=collection_archive---------5-----------------------#2020-02-13">https://towardsdatascience.com/making-a-continual-ml-pipeline-to-predict-apple-stock-with-global-news-python-90e5d6610b21?source=collection_archive---------5-----------------------#2020-02-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bfbe" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">简单是关键。</h2></div><h1 id="1d23" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">目标</h1><p id="0acd" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在本教程中，我们将制作一个机器学习管道，它输入商业新闻，并随着时间的推移为<a class="ae lw" href="https://www.openblender.io/#/dataset/explore/5d4c39d09516290b01c8307b/or/32" rel="noopener ugc nofollow" target="_blank">苹果</a>股价<strong class="lc iu">再培训</strong>生成<strong class="lc iu">预测</strong>。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi lx"><img src="../Images/e800e5f7c665c854744e82b870ce7e9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HOscj6Xo-zzRkTj5.jpg"/></div></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">图片来自apple.com</p></figure><p id="7e52" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">我们还将衡量<strong class="lc iu">它在现实生活中有多有利可图。</strong></p><h1 id="58cb" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">我们要做什么</h1><ul class=""><li id="f185" class="ms mt it lc b ld le lg lh lj mu ln mv lr mw lv mx my mz na bi translated">步骤1:设置技术<strong class="lc iu">先决条件</strong></li><li id="948b" class="ms mt it lc b ld nb lg nc lj nd ln ne lr nf lv mx my mz na bi translated">第二步:<strong class="lc iu">获取2017年以来每日苹果库存的数据</strong></li><li id="1404" class="ms mt it lc b ld nb lg nc lj nd ln ne lr nf lv mx my mz na bi translated">步骤3:定义并理解ML的<strong class="lc iu">目标</strong></li><li id="57a0" class="ms mt it lc b ld nb lg nc lj nd ln ne lr nf lv mx my mz na bi translated">第四步:<strong class="lc iu">将</strong>商业新闻融入我们的数据</li><li id="548b" class="ms mt it lc b ld nb lg nc lj nd ln ne lr nf lv mx my mz na bi translated">第五步:<strong class="lc iu">准备</strong>我方数据<strong class="lc iu"> </strong>并应用ML</li><li id="ae06" class="ms mt it lc b ld nb lg nc lj nd ln ne lr nf lv mx my mz na bi translated">第六步:测量和分析<strong class="lc iu">结果</strong></li><li id="4b56" class="ms mt it lc b ld nb lg nc lj nd ln ne lr nf lv mx my mz na bi translated">第七步:打破数据和<strong class="lc iu">训练/测试</strong>穿越时间</li></ul><h1 id="7c71" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">第一步。先决条件</h1><ul class=""><li id="823a" class="ms mt it lc b ld le lg lh lj mu ln mv lr mw lv mx my mz na bi translated">安装Python 2.6+或3.1+版本</li><li id="856f" class="ms mt it lc b ld nb lg nc lj nd ln ne lr nf lv mx my mz na bi translated">安装熊猫、sklearn和openblender(带pip)</li></ul><pre class="ly lz ma mb gt ng nh ni nj aw nk bi"><span id="c4a9" class="nl kj it nh b gy nm nn l no np">$ pip install pandas OpenBlender scikit-learn</span></pre><h1 id="310e" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">第二步。获取数据</h1><p id="679f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们将使用这个每日<a class="ae lw" href="https://www.openblender.io/#/dataset/explore/5d4c39d09516290b01c8307b/or/32" rel="noopener ugc nofollow" target="_blank">苹果股票数据集</a></p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi nq"><img src="../Images/64345360a3ba537701da061655aaa72a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_loqTLWSrE6QEZTeyAFzWw.png"/></div></div></figure><p id="e9af" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">它有每天的最高价、最低价、开盘价和收盘价，以及当天的百分比变化。</p><p id="888a" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">所以让我们<strong class="lc iu">通过OpenBlender API <strong class="lc iu">拉数据</strong>。</strong>打开一个python脚本，运行以下代码:</p><pre class="ly lz ma mb gt ng nh ni nj aw nk bi"><span id="70bd" class="nl kj it nh b gy nm nn l no np"># Import the libraries</span><span id="a2c6" class="nl kj it nh b gy nr nn l no np">import OpenBlender<br/>import pandas as pd<br/>import numpy as np<br/>import json</span><span id="928b" class="nl kj it nh b gy nr nn l no np">token = '<strong class="nh iu">YOUR_TOKEN_HERE</strong>'</span><span id="8340" class="nl kj it nh b gy nr nn l no np"># Specify the action<br/>action = 'API_getObservationsFromDataset'</span><span id="ee82" class="nl kj it nh b gy nr nn l no np">interval = 60 * 60 * 24 # One day</span><span id="5034" class="nl kj it nh b gy nr nn l no np">parameters = { <br/> 'token' : token,<br/>    'id_dataset':'5d4c39d09516290b01c8307b',<br/>    'date_filter':{"start_date":"2017-01-01T06:00:00.000Z",<br/>                   "end_date":"2020-02-09T06:00:00.000Z"},<br/>    'aggregate_in_time_interval' : {<br/>              'time_interval_size' : interval, <br/>              'output' : 'avg', <br/>              'empty_intervals' : 'impute'<br/>      }<br/>}<br/>        <br/># Pull the data into a Pandas Dataframe</span><span id="6b2b" class="nl kj it nh b gy nr nn l no np">df = pd.read_json(json.dumps(OpenBlender.call(action, parameters)['sample']), convert_dates=False, convert_axes=False)<br/>df.reset_index(drop=True, inplace=True)<br/>df['date'] = [OpenBlender.unixToDate(ts, timezone = 'GMT') for ts in df.timestamp]<br/>df = df.drop('timestamp', axis = 1)</span></pre><p id="3267" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated"><strong class="lc iu">注意:</strong>要获得您<em class="ns">需要的令牌</em>必须在<a class="ae lw" href="https://www.openblender.io/#/welcome/or/32" rel="noopener ugc nofollow" target="_blank"> openblender.io </a>(免费)上创建一个帐户，您可以在您个人资料图标的“帐户”选项卡中找到它。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/4104cb694cc0f42c57d02af78c2012cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1346/format:webp/1*1TmcoUWFpR1wjiMSrGiF5A.png"/></div></figure><p id="491b" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">现在让我们来看看数据:</p><pre class="ly lz ma mb gt ng nh ni nj aw nk bi"><span id="ff1c" class="nl kj it nh b gy nm nn l no np">df.head()</span></pre><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi nu"><img src="../Images/fdde4484306b5774bc4432bcbf725450.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TKdgwwqa7I1ZsEhxsKAneg.png"/></div></div></figure><p id="beee" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">检查！</p><h1 id="ae46" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">第三步。定义和理解目标</h1><p id="d189" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">让我们画出<strong class="lc iu">价格</strong>和<strong class="lc iu">变化</strong>:</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/0cd89dbae041d8bc63a1ff831c350910.png" data-original-src="https://miro.medium.com/v2/resize:fit:1326/format:webp/1*OFJ0UTAJpapOSce9kIRTeA.png"/></div></figure><p id="5a00" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">现在，我们想要的是检测第二天价格是否会在<em class="ns">上涨或<strong class="lc iu">下跌</strong>，这样我们就可以买入或做空。</em></p><p id="df0e" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">“<strong class="lc iu">变化</strong>”是开盘价和收盘价之间发生的百分比上升或下降，因此它对我们有效。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi nw"><img src="../Images/c6b769250997557ad7f46454d1a67cd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cGNQzW8euFuI-LZI"/></div></div></figure><p id="3fda" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">让我们将我们的目标变量定义为大于0.5%的增长(这样就不值得购买):</p><p id="f0de" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated"><strong class="lc iu">阳性POC: </strong>其中“变化”增加超过0.5%</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi nx"><img src="../Images/b1e986fe7581e225e0f2ed239b64306b.png" data-original-src="https://miro.medium.com/v2/resize:fit:676/format:webp/1*23NAvNMeYMFSUlHVpvXZuA.png"/></div></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">“变化”的分布</p></figure><p id="876d" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">这意味着绿线右侧的所有观察结果都将是我们的“成功”情景。</p><h1 id="5306" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">第四步。向量化和混合商业新闻</h1><p id="e31f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这是<strong class="lc iu">非常</strong> <strong class="lc iu">简单的</strong>执行，但是让我们试着理解后台发生的事情。</p><p id="84b1" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">我们想要的:</p><ol class=""><li id="3def" class="ms mt it lc b ld mn lg mo lj ny ln nz lr oa lv ob my mz na bi translated">我们需要<strong class="lc iu">收集有用的新闻数据</strong>，这些数据与我们的目标相关</li><li id="0451" class="ms mt it lc b ld nb lg nc lj nd ln ne lr nf lv ob my mz na bi translated">我们希望将它融入我们的数据中，使<strong class="lc iu">消息与第二天的价格</strong>“变化”保持一致(这样模型就可以学习预测第二天的价格，我们就可以实际使用它)</li><li id="0e93" class="ms mt it lc b ld nb lg nc lj nd ln ne lr nf lv ob my mz na bi translated">我们想把它转换成<strong class="lc iu">数字特征</strong>，这样它就可以遍历一个ML模型。</li></ol><p id="514c" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">因此，让我们寻找时间重叠的商业新闻数据集:</p><pre class="ly lz ma mb gt ng nh ni nj aw nk bi"><span id="eb00" class="nl kj it nh b gy nm nn l no np"># First we need to add the UNIX timestamp which is the number <br/># of seconds since 1970 on UTC, it is a very convenient <br/># format because it is the same in every time zone in the world!</span><span id="dff1" class="nl kj it nh b gy nr nn l no np">df['timestamp'] = OpenBlender.dateToUnix(df['date'], <br/>                                           date_format = '%d-%m-%Y %H:%M:%S', <br/>                                           timezone = 'GMT')<br/></span><span id="4e57" class="nl kj it nh b gy nr nn l no np"><br/># Now, let's search on OpenBlender</span><span id="e8dc" class="nl kj it nh b gy nr nn l no np">search_keyword = '<strong class="nh iu">business</strong>'</span><span id="6265" class="nl kj it nh b gy nr nn l no np">df = df.sort_values('timestamp').reset_index(drop = True)</span><span id="fddc" class="nl kj it nh b gy nr nn l no np">print('From : ' + OpenBlender.unixToDate(min(df.timestamp)))<br/>print('Until: ' + OpenBlender.unixToDate(max(df.timestamp)))</span><span id="1480" class="nl kj it nh b gy nr nn l no np"># We need to pass our timestamp column and <br/># search keywords as parameters.</span><span id="266b" class="nl kj it nh b gy nr nn l no np">OpenBlender.searchTimeBlends(token,<br/>                             df.timestamp,<br/>                             search_keyword)</span></pre><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi oc"><img src="../Images/739ce0631764f8819f794f00552d6232.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BSBsuzs4h81Q-LMQcLV90Q.png"/></div></div></figure><p id="00c7" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">我们可以看到时间重叠(交叉)数据集及其一些属性，甚至可以看到界面的url。</p><p id="a8f3" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">因此，让我们挑选这个<a class="ae lw" href="https://www.openblender.io/#/dataset/explore/5e2ef74e9516294390e810a9/or/32" rel="noopener ugc nofollow" target="_blank">华尔街日报新闻</a>数据集:</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi od"><img src="../Images/119c9077afec9748c9f808640916c198.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NcPxI25lxagiESveUeTA_Q.png"/></div></div></figure><p id="644e" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">这是<a class="ae lw" href="https://www.openblender.io/#/dataset/explore/5e32fd289516291e346c1726/or/32" rel="noopener ugc nofollow" target="_blank">今日美国</a>推特新闻。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi oe"><img src="../Images/3e119bf6e4a883972cc0506f16f556e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GXzP1sm8H7kl-7-3SFLnsQ.png"/></div></div></figure><ul class=""><li id="32c8" class="ms mt it lc b ld mn lg mo lj ny ln nz lr oa lv mx my mz na bi translated"><em class="ns">注意:</em>我选择这些是因为它们有意义，但是你可以搜索数百个其他的。</li></ul><p id="edc9" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">我们可以<strong class="lc iu">通过搜索按时间聚合的新闻术语，将新的列混合到我们的数据集</strong>中。例如，我们可以用“华尔街”数据集中的新闻数量创建一个“苹果”特征，该特征与我们自制的ngrams相匹配:</p><pre class="ly lz ma mb gt ng nh ni nj aw nk bi"><span id="b80a" class="nl kj it nh b gy nm nn l no np"><strong class="nh iu">positive_filter</strong> = {'name' : 'apple', <br/>                   'match_ngrams': ['apple', 'iphone', 'ipad', <br/>                                    'tim cook', 'mac store']}</span><span id="58cc" class="nl kj it nh b gy nr nn l no np"># We need to pass the 'id_dataset', the name of the<br/># column (which is 'text') and an optional filter.</span><span id="2d9d" class="nl kj it nh b gy nr nn l no np">blend_source = {<br/>                'id_dataset':'<strong class="nh iu">5e2ef74e9516294390e810a9</strong>',<br/>                'feature' : '<strong class="nh iu">text</strong>',<br/>                'filter_text' : <strong class="nh iu">positive_filter</strong><br/>            }</span><span id="4bec" class="nl kj it nh b gy nr nn l no np">df_blend = OpenBlender.timeBlend( token = token,<br/>                                  anchor_ts = df.timestamp,<br/>                                  blend_source = blend_source,<br/>                                  blend_type = 'agg_in_intervals',<br/>                                  interval_size = 60 * 60 * 24,<br/>                                  direction = 'time_prior',<br/>                                  interval_output = 'list')</span><span id="21c2" class="nl kj it nh b gy nr nn l no np">df_anchor = pd.concat([df, df_blend.loc[:, df_blend.columns != 'timestamp']], axis = 1)<br/>df_anchor</span></pre><p id="efe4" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">timeBlend函数的参数:</p><ul class=""><li id="7fec" class="ms mt it lc b ld mn lg mo lj ny ln nz lr oa lv mx my mz na bi translated"><strong class="lc iu"> anchor_ts </strong>:我们只需要发送我们的时间戳列，这样它就可以作为锚来混合外部数据。</li><li id="c788" class="ms mt it lc b ld nb lg nc lj nd ln ne lr nf lv mx my mz na bi translated"><strong class="lc iu"> blend_source </strong>:我们想要的特性的信息。</li><li id="6e52" class="ms mt it lc b ld nb lg nc lj nd ln ne lr nf lv mx my mz na bi translated"><strong class="lc iu">blend _ type</strong>:‘agg _ in _ intervals’因为我们想要对我们的每个观察值进行24小时间隔聚合。</li><li id="5f42" class="ms mt it lc b ld nb lg nc lj nd ln ne lr nf lv mx my mz na bi translated"><strong class="lc iu"> inverval_size </strong>:间隔的大小，以秒为单位(本例中为24小时)。</li><li id="b3ce" class="ms mt it lc b ld nb lg nc lj nd ln ne lr nf lv mx my mz na bi translated"><strong class="lc iu">方向</strong>:‘time _ prior’因为我们希望间隔收集之前24小时的观察值，而不是向前。</li></ul><p id="ae5d" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">输出是两个新的列，我们的“苹果”功能的“计数”和一个实际新闻的列表，以防有人想遍历每一个。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi of"><img src="../Images/1dd62118bd760a77bdaf22f94fe6c4ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wMrmQ9a4fMARjq6bX3pbyQ.png"/></div></div></figure><p id="4201" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">现在让我们<strong class="lc iu">创建一个文本矢量器</strong>，它是OpenBlender上的一个模型，你可以从中提取数千个计算化的ngrams作为特征:</p><pre class="ly lz ma mb gt ng nh ni nj aw nk bi"><span id="f444" class="nl kj it nh b gy nm nn l no np">action = 'API_createTextVectorizerPlus'</span><span id="03bb" class="nl kj it nh b gy nr nn l no np">parameters = {<br/>    'token' : token,<br/>    'name' : 'Wall Street and USA Today Vectorizer',<br/>    'sources':[<br/>              {'id_dataset':"<strong class="nh iu">5e2ef74e9516294390e810a9</strong>", <br/>               'features' : ["<strong class="nh iu">text</strong>"]},<br/>              {'id_dataset' : "<strong class="nh iu">5e32fd289516291e346c1726</strong>", <br/>               'features' : ["<strong class="nh iu">text</strong>"]}<br/>    ],<br/>    'ngram_range' : {'min' : 1, 'max' : 2},<br/>    'language' : 'en',<br/>    'remove_stop_words' : 'on',<br/>    'min_count_limit' : 2<br/>}</span><span id="525b" class="nl kj it nh b gy nr nn l no np">response = OpenBlender.call(action, parameters)<br/>response</span></pre><p id="735d" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">根据上述内容，我们指定了以下内容:</p><ul class=""><li id="a6a9" class="ms mt it lc b ld mn lg mo lj ny ln nz lr oa lv mx my mz na bi translated"><strong class="lc iu">名称:</strong>我们将其命名为“华尔街和今日美国矢量器”</li><li id="236d" class="ms mt it lc b ld nb lg nc lj nd ln ne lr nf lv mx my mz na bi translated"><strong class="lc iu">源</strong>:要作为源包含的数据集的id和源列(在本例中，两者都只有一个名为“text”)</li><li id="6bab" class="ms mt it lc b ld nb lg nc lj nd ln ne lr nf lv mx my mz na bi translated"><strong class="lc iu"> ngram_range </strong>:将被标记的单词集的最小和最大长度</li><li id="4134" class="ms mt it lc b ld nb lg nc lj nd ln ne lr nf lv mx my mz na bi translated">语言:英语</li><li id="c6f6" class="ms mt it lc b ld nb lg nc lj nd ln ne lr nf lv mx my mz na bi translated"><strong class="lc iu"> remove_stop_words </strong>:这样就从源头上消除了停用词</li><li id="c255" class="ms mt it lc b ld nb lg nc lj nd ln ne lr nf lv mx my mz na bi translated"><strong class="lc iu"> min_count_limit </strong>:被认为是令牌的最小重复次数(出现一次很少有帮助)</li></ul><p id="cda4" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">现在，如果我们转到OpenBlender的仪表板，我们可以看到矢量器:</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi og"><img src="../Images/5b28f77007bd9098aca47e44ed3c7e5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lq0NpCJapHEnjb8ZC5Kxsw.png"/></div></div></figure><p id="3464" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">它生成了4999个n-gram，这些n-gram是最大2个单词的令牌的<strong class="lc iu">二进制特征</strong>，如果提到了<strong class="lc iu"> n-gram则为“1”</strong>否则为“0”。</p><p id="315f" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">现在<strong class="lc iu">我们希望矢量化的数据</strong>在24小时内被压缩，并与第二天的苹果股票价格保持一致。</p><p id="4d83" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">您需要添加您的<strong class="lc iu">矢量器的id </strong>(它是在您创建它时打印的，或者您可以在OpenBlender中获得它。</p><pre class="ly lz ma mb gt ng nh ni nj aw nk bi"><span id="2f21" class="nl kj it nh b gy nm nn l no np">blend_source = { <br/>                'id_textVectorizer':'<strong class="nh iu">5f74fb7895162967ca2160fe</strong>'<br/>               }</span><span id="75de" class="nl kj it nh b gy nr nn l no np">df_blend = OpenBlender.timeBlend( token = token,<br/>                                  anchor_ts = df_anchor.timestamp,<br/>                                  blend_source = blend_source,<br/>                                  blend_type = 'agg_in_intervals',<br/>                                  interval_size = 60 * 60 * 24,<br/>                                  direction = 'time_prior_strict') .add_prefix('VEC.')</span><span id="37fa" class="nl kj it nh b gy nr nn l no np">df_anchor = pd.concat([df_anchor, df_blend.loc[:, df_blend.columns != 'timestamp']], axis = 1)<br/>df_anchor.head()</span></pre><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi oh"><img src="../Images/7edc2186855b96d21519391f7abd6daf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hh__LDudUh9OdDLuRsaDUQ.png"/></div></div></figure><p id="569a" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">现在我们有了<strong class="lc iu"> 1068 </strong>个观察值和<strong class="lc iu"> 4887 </strong>个特征。我们的原始数据集加上过去24小时的矢量化和聚合新闻。</p><h1 id="8a8e" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">第五步。准备数据并应用ML</h1><p id="8465" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">没有更多的争论或清理要做，我们只需要<strong class="lc iu">创建我们的目标特性</strong>正POC和负POC(我们将使用‘正POC’来实现前面定义的目的)。</p><pre class="ly lz ma mb gt ng nh ni nj aw nk bi"><span id="67b1" class="nl kj it nh b gy nm nn l no np"># Where ‘change’ <strong class="nh iu">decreased</strong> more than 0.5%<br/>df_anchor['negative_poc'] = [1 if log_diff &lt; -0.005 else 0 for log_diff in df_anchor['change']]<br/></span><span id="027b" class="nl kj it nh b gy nr nn l no np"># Where ‘change’ <strong class="nh iu">increased</strong> more than 0.5%<br/>df_anchor['positive_poc'] = [1 if log_diff &gt; 0.005 else 0 for log_diff in df_anchor['change']]</span><span id="3bb9" class="nl kj it nh b gy nr nn l no np"># We need to shift our target one day so that we predict <br/># for what will happen 'tomorrow' with news and data from 'today'</span><span id="87dd" class="nl kj it nh b gy nr nn l no np">df_anchor['target'] = df_anchor['positive_poc'].shift(-1)<br/>df_anchor[['change', 'positive_poc', 'target']]</span></pre><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/d233227e77ab4913b2008a91371eec1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/1*QJ2zQyAt6fXWpZeLhQQ83Q.png"/></div></figure><p id="9f71" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">现在我们有了'<strong class="lc iu">目标</strong>'特性，它简单地将<strong class="lc iu">的“变化”值与“<strong class="lc iu">前一天的数据</strong>对齐</strong>，这正是我们所需要的。最近的观察(最后一次)是NaN，因为那是我们想要为“明天”预测的。</p><p id="5438" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">现在，让我们尝试一些ML来学习和预测<strong class="lc iu">目标</strong>。</p><pre class="ly lz ma mb gt ng nh ni nj aw nk bi"><span id="e050" class="nl kj it nh b gy nm nn l no np"># Import libraries<br/>from sklearn.ensemble import RandomForestRegressor<br/>from sklearn.metrics import roc_auc_score<br/>from sklearn.metrics import accuracy_score<br/>from sklearn import metrics<br/>df_anchor = df_anchor[:-1] # Remove the last one with NaN</span><span id="5a9a" class="nl kj it nh b gy nr nn l no np"># Define target<br/>target = 'target'<br/>df_positive = df_anchor[1:].select_dtypes(['number'])</span><span id="89a7" class="nl kj it nh b gy nr nn l no np"># Create train/test sets<br/>X = df_positive.loc[:, df_positive.columns != target].values<br/>y = df_positive.loc[:,[target]].values<br/>div = int(round(len(X) * 0.71))</span><span id="8c05" class="nl kj it nh b gy nr nn l no np">X_train = X[:div]<br/>y_train = y[:div]<br/>X_test = X[div:]<br/>y_test = y[div:]</span><span id="0ade" class="nl kj it nh b gy nr nn l no np">print('Train:')<br/>print(X_train.shape)<br/>print(y_train.shape)<br/>print('Test:')<br/>print(X_test.shape)<br/>print(y_test.shape)</span></pre><p id="cfe1" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">产出:</p><pre class="ly lz ma mb gt ng nh ni nj aw nk bi"><span id="d3e0" class="nl kj it nh b gy nm nn l no np">Train:<br/>(758, 4995)<br/>(758, 1)<br/>Test:<br/>(310, 4885)<br/>(310, 1)</span></pre><p id="5e48" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">现在让我们训练模型并预测:</p><pre class="ly lz ma mb gt ng nh ni nj aw nk bi"><span id="8f46" class="nl kj it nh b gy nm nn l no np">rf = RandomForestRegressor(n_estimators = 1000, random_state = 1)<br/>rf.fit(X_train, y_train)<br/>y_pred = rf.predict(X_test)</span></pre><h1 id="af1a" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">第六步。分析结果</h1><p id="5cb8" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">现在公布结果。</p><pre class="ly lz ma mb gt ng nh ni nj aw nk bi"><span id="c820" class="nl kj it nh b gy nm nn l no np">print("AUC score:")<br/>print(roc_auc_score(y_test, y_pred))<br/>print('---')</span><span id="fb4e" class="nl kj it nh b gy nr nn l no np"># Let's binarize and look at the confusion matrix<br/>preds = [1 if val &gt; 0.5 else 0 for val in y_pred]<br/>print('Confusion Matrix:')<br/>print(metrics.confusion_matrix(y_test, preds))<br/>print('---')</span><span id="919c" class="nl kj it nh b gy nr nn l no np"># Lets look at the accuracy score<br/>print('Accuracy:')<br/>print(accuracy_score(y_test, preds))<br/>print('---')</span></pre><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/4f11aac4bcc966f2c64bbfae7b790f0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:350/format:webp/1*RP8Ro-mSzh0irccjSUtYlA.png"/></div></figure><p id="3590" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">如果我自己这么说的话，这是相当惊人的。</p><p id="0bf2" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">我们来分析一下结果。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/6109a6dd8b2c6eb6831ad35856c1b481.png" data-original-src="https://miro.medium.com/v2/resize:fit:568/format:webp/1*OSfO_HDS24o_xBQzrt3D1g.png"/></div></figure><p id="eed9" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">这意味着，从这个模型预测第二天价格变化将增加0.5%或更多的所有时间来看，<strong class="lc iu">它有72%的时间是正确的</strong>。我不知道任何现实生活中的模型甚至可以与此相比。</p><p id="9322" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">如果我们在一天结束时运行模型，我们可以在第二天早上买入/做空，期待当天结束时的结果。</p><p id="27ba" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated"><em class="ns">*旁注:如果你们中的任何人把这个投入到自动交易(或手工交易)的生产中，至少送我一份礼物。</em></p><h1 id="5c45" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">第七步。打破时间的数据</h1><p id="bf6a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">现在，我们需要一种方法，在这种方法中，数据经过训练和测试，以观察结果是否一致。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/df65f206139a4977bb203bfd2b241473.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*GMr26yVH2-3_GVEmWbEhLw.png"/></div></figure><p id="c747" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">让我们运行我们刚刚做的，但是在这个循环中中断数据。</p><pre class="ly lz ma mb gt ng nh ni nj aw nk bi"><span id="5d5f" class="nl kj it nh b gy nm nn l no np">results = []</span><span id="5d62" class="nl kj it nh b gy nr nn l no np">for i in range(0, 90, 5): <br/> time_chunk = i/100<br/> print(“time_chunk:” + str(time_chunk) + “ starts”)<br/> df_ml = df_positive[:int(round(df_positive.shape[0] * (time_chunk + 0.4)))]<br/> X = df_ml.loc[:, df_ml.columns != target].values<br/> y = df_ml.loc[:,[target]].values<br/> div = int(round(len(X) * 0.29))<br/> X_test = X[:div]<br/> y_test = y[:div]<br/> X_train = X[div:]<br/> y_train = y[div:]<br/> rf = RandomForestRegressor(n_estimators = 1000, random_state = 1)<br/> rf.fit(X_train, y_train)<br/> y_pred = rf.predict(X_test)<br/> preds = [1 if val &gt; 0.5 else 0 for val in y_pred]<br/> try:<br/> roc = roc_auc_score(y_test, y_pred)<br/> except:<br/> roc = 0<br/> conf_mat = metrics.confusion_matrix(y_test, preds)<br/> accuracy = accuracy_score(y_test, preds)<br/> results.append({<br/> ‘roc’ : roc,<br/> ‘accuracy’ : accuracy,<br/> ‘conf_mat’ : conf_mat,<br/> ‘time_chunk’ : time_chunk<br/> })</span></pre><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div class="gh gi om"><img src="../Images/7eae1c8520fee58e830b4534c83a6917.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/format:webp/1*2DMsU79mPfEGOG1-wyzPjg.png"/></div></figure><p id="621d" class="pw-post-body-paragraph la lb it lc b ld mn ju lf lg mo jx li lj mp ll lm ln mq lp lq lr mr lt lu lv im bi translated">我们可以看到<strong class="lc iu">指标增加</strong>并稳定低谷时间！</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div class="gh gi on"><img src="../Images/ff230646f6a865562879e1be5c9cb995.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*IuEkfClWPtzg2aNNtaLYVQ.png"/></div></figure></div></div>    
</body>
</html>