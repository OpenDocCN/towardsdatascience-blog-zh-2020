<html>
<head>
<title>Building Analysis Pipelines with Kaggle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Kaggle构建分析管道</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-analysis-pipelines-with-kaggle-c745671d273e?source=collection_archive---------42-----------------------#2020-06-21">https://towardsdatascience.com/building-analysis-pipelines-with-kaggle-c745671d273e?source=collection_archive---------42-----------------------#2020-06-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0695" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">不仅仅是竞争</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fccccf29a0b0aa2e2088b05d7f0c5125.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HvLDPnJbIumFcIwU"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">卢克·切瑟在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="520b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://www.kaggle.com/" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>是最受欢迎的数据科学和机器学习入门网站之一。数据科学界的大多数人都使用过或者至少听说过它。Kaggle是一个众所周知的举办机器学习竞赛的网站，虽然这是该平台的一大部分，但它可以做得更多。</p><p id="28cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今年有了<a class="ae ky" href="https://www.kaggle.com/allen-institute-for-ai/CORD-19-research-challenge" rel="noopener ugc nofollow" target="_blank">新冠肺炎开放研究数据集(CORD-19) </a>，我有机会更加一致地使用这个平台。老实说，Jupyter笔记本和基于GUI的开发并不是我的首选方法(Vim对我来说已经足够好了)。但是在过去的几个月里，我对这个平台的能力印象深刻。本文概述了Kaggle笔记本、Kaggle API，并演示了一种构建自动化分析管道的方法。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ecc7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">笔记本电脑</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/c11170100e0a86d18ed565d067f64d74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XZdJPfVU2RPpE1egSYrGVQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://www.kaggle.com/notebooks" rel="noopener ugc nofollow" target="_blank"> Kaggle笔记本</a></p></figure><p id="5fa8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://www.kaggle.com/notebooks" rel="noopener ugc nofollow" target="_blank"> Kaggle Notebooks </a>是一个云托管的Jupyter笔记本环境。笔记本可以用Python或r构建。笔记本在Docker容器中执行，我们可以把它们看作一个逻辑包。笔记本可以包含数据分析项目的所有逻辑，也可以链接在一起构建模块化组件。笔记本可以公开共享，也可以保密。</p><p id="b814" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">笔记本电脑可以访问多个CPU内核和大量内存。另外还可以增加<a class="ae ky" href="https://en.wikipedia.org/wiki/Graphics_processing_unit" rel="noopener ugc nofollow" target="_blank">GPU</a>和<a class="ae ky" href="https://en.wikipedia.org/wiki/Tensor_processing_unit" rel="noopener ugc nofollow" target="_blank">TPU</a>，可以加速深度学习模型的训练。对于一项免费服务来说，可用的资源是非常可观的。在一家大型云提供商上安装一台类似的主机是一笔相当大的成本。</p><p id="46ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">笔记本使用几种不同的方法读取数据。主要途径是通过数据集。任何拥有帐户的人都可以上传数据并创建自己的数据集。Kaggle上已经有大量公开的数据集。与笔记本电脑一样，数据集可以公开共享，也可以保密。笔记本可以有一个或多个数据集作为输入。此外，其他笔记本的输出可以用作输入，从而允许构建笔记本链。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4aa3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">创建新笔记本</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mv"><img src="../Images/d0e73ebbf0c6e3a6b5749c60fc345542.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ph9h7rZhDG3yDNVW_kz1VA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Kaggle笔记本副本</p></figure><p id="89c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以使用上图中显示的“新建笔记本”按钮创建空白笔记本。一旦创建了一个笔记本，就会有一个编辑器可以用来构建逻辑。本例将复制一个现有的笔记本，重点介绍运行笔记本的方法。</p><p id="eb2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用<a class="ae ky" href="https://www.kaggle.com/davidmezzetti/cord-19-report-builder/" rel="noopener ugc nofollow" target="_blank"> CORD-19报表生成器笔记本</a>。点击参考链接后，我们可以通过“复制和编辑”按钮复制笔记本。这将创建一个笔记本作为<em class="mw"> &lt;你的Kaggle用户名&gt;</em>/cord-19-report-builder。请注意，以下所有链接将显示<em class="mw">大卫·梅泽蒂</em>作为用户名，请替换为您的Kaggle用户名。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4486" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">执行笔记本</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mx"><img src="../Images/63db753dc499ccd28da1706b02be4657.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tOKOfazOlI46WphW8lERDA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Kaggle笔记本编辑</p></figure><p id="7321" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">复制笔记本会把我们带到编辑笔记本的界面。在该屏幕上，我们还可以添加/删除输入、修改设置以及保存/运行笔记本。</p><p id="af12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的示例显示了从另一个笔记本导入实用程序脚本。这是一个强大的功能，允许在笔记本之间共享功能，避免复制/粘贴样板代码。该示例有两个输入数据集和一个笔记本作为输入。</p><p id="dc18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">点击“保存版本”按钮将执行笔记本中的逻辑并保存一个新版本。有多种选择:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi my"><img src="../Images/5e3519e2437a3dde25d963a73b8b2c64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*hVTpSFZrAXwczSF6ICLwBg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Kaggle笔记本保存</p></figure><p id="ee9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果在编辑时笔记本已经完全运行，“快速保存”工作良好。否则，应使用“保存并运行全部”。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ac87" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">Kaggle API</h1><p id="4f01" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">如果我们有几个笔记本，我们希望在添加额外的逻辑时偶尔更新，那么已经描述的内容通常就足够了。</p><p id="d461" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于更复杂的情况或频繁使用的情况，Kaggle有一个<a class="ae ky" href="https://github.com/Kaggle/kaggle-api" rel="noopener ugc nofollow" target="_blank">全功能Python API </a>可用。Kaggle API可以通过PyPi获得:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="bfe1" class="nj md it nf b gy nk nl l nm nn">pip install kaggle</span></pre><p id="3b3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/Kaggle/kaggle-api#api-credentials" rel="noopener ugc nofollow" target="_blank"> API有关于如何设置授权和创建访问密钥以启用使用的文档</a>。一旦设置了API，下面显示了一个通过API运行笔记本的简单示例:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="4a85" class="nj md it nf b gy nk nl l nm nn">kaggle kernels pull <em class="mw">davidmezzetti</em>/cord-19-report-builder -p cord-19-report-builder -m</span><span id="1da0" class="nj md it nf b gy no nl l nm nn">kaggle kernels push -p cord-19-report-builder</span></pre><p id="f339" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这运行两个命令。第一个是提取cord-19-report-builder笔记本，将它和它的元数据存储在一个名为cord-19-report-builder的目录中。第二个运行笔记本。</p><p id="9d15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦运行了上面的命令，我们就可以到Kaggle来监控作业的进度。下图显示了版本屏幕，从中我们可以看到笔记本电脑的新版本正在运行。点击版本文本(在右上角突出显示)即可调出该屏幕。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/93839a082709eae6e06a8e9bf87d21a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jd5XZ47kUAfWsTKiLPnJFw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Kaggle笔记本新版本</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e773" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">自动化管道</h1><p id="7e0f" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">Kaggle API功能强大，允许在主web界面之外运行笔记本(以及许多其他功能)。可以围绕它构建脚本，以支持更复杂的功能以及与外部流程的交互。</p><p id="6b24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了CORD-19数据集，支持这项工作的笔记本电脑数量增加到了10多台，每次有新数据进来时都需要刷新。最重要的是，数据集移动到了每天更新的程度，笔记本电脑相互依赖(即一个需要在另一个运行之前运行)。</p><p id="0625" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这个用例，完全自动化显然是必要的。为了实现自动化管道，NeuML创建了<a class="ae ky" href="https://github.com/neuml/kernelpipes" rel="noopener ugc nofollow" target="_blank"> kernelpipes项目</a>。</p><p id="e8a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">内核管道可以通过pip安装:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="90c9" class="nj md it nf b gy nk nl l nm nn">pip install git+https://github.com/neuml/kernelpipes</span></pre><p id="4fbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">kernelpipes使用Kaggle API顺序或并行执行一系列笔记本。可以添加检查，以便仅在更新了源时才允许运行管道。此外，管道有一个内置的cron调度特性来支持连续执行。下面是<a class="ae ky" href="https://en.wikipedia.org/wiki/YAML" rel="noopener ugc nofollow" target="_blank"> YAML </a>的一个简单管道例子。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="fb2d" class="nj md it nf b gy nk nl l nm nn"># Pipeline name                       <br/>name: pipeline</span><span id="164e" class="nj md it nf b gy no nl l nm nn"># Pipeline execution steps<br/>steps:<br/>  - kernel: <em class="mw">davidmezzetti</em>/cord-19-report-builder                       <br/>  - status: 2.5m</span></pre><p id="9442" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设上述内容保存在名为pipeline.yml的文件中，它可以如下运行:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/d574fc1295dbc491017497c8c03ab970.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*3G9lEAc70xXVHkO77LBWCA.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">pipeline.yml执行</p></figure><p id="3582" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个简单的管道每2.5分钟执行一次记事本并检查完成状态。一旦内核完成，进程将退出。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5efe" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">基本管道配置</h1><h2 id="b643" class="nj md it bd me nr ns dn mi nt nu dp mm li nv nw mo lm nx ny mq lq nz oa ms ob bi translated">名字</h2><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="cc8c" class="nj md it nf b gy nk nl l nm nn">name: &lt;pipeline name&gt;</span></pre><p id="62ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">必填字段，命名管道</p><h2 id="9f19" class="nj md it bd me nr ns dn mi nt nu dp mm li nv nw mo lm nx ny mq lq nz oa ms ob bi translated">日程安排</h2><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="4323" class="nj md it nf b gy nk nl l nm nn">schedule: cron string</span></pre><p id="be0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">允许通过调度程序运行作业的可选字段。根据偏好，可以使用System cron来代替它。与系统cron相比，内部调度程序的一个优点是，在前一个作业正在运行时，不会产生新的作业。例如，如果某个作业计划每小时运行一次，而一次运行需要1.5小时，它将跳过第二次运行，并在第三个小时重新开始。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b5b6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">步伐</h1><h2 id="13c9" class="nj md it bd me nr ns dn mi nt nu dp mm li nv nw mo lm nx ny mq lq nz oa ms ob bi translated">支票</h2><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="258c" class="nj md it nf b gy nk nl l nm nn">check: /kaggle/dataset/path</span></pre><p id="bed4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">允许根据数据集更新状态有条件地运行管道。检索数据集元数据，并将最新版本与上次运行的版本进行比较，仅当数据集已更新时才允许处理继续进行。如果数据集没有本地元数据，将继续运行。</p><h2 id="8a3f" class="nj md it bd me nr ns dn mi nt nu dp mm li nv nw mo lm nx ny mq lq nz oa ms ob bi translated">核心</h2><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="3c98" class="nj md it nf b gy nk nl l nm nn">kernel: /kaggle/kernel/path</span></pre><p id="0f58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">返回在/kaggle/kernel/path指定的内核</p><h2 id="5265" class="nj md it bd me nr ns dn mi nt nu dp mm li nv nw mo lm nx ny mq lq nz oa ms ob bi translated">状态</h2><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="44c0" class="nj md it nf b gy nk nl l nm nn">status: &lt;seconds|s|m|h&gt;</span></pre><p id="c7ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在指定的持续时间内检查前面内核步骤的状态。</p><p id="b20c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">持续时间示例:10代表10秒，30代表30秒，1代表1分钟，1代表1小时。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f5f8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">更复杂的例子</h1><p id="8206" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">为了给出一个复杂用例的概念，下面是一个用于处理CORD-19数据集的完整管道。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="ee31" class="nj md it nf b gy nk nl l nm nn"># Pipeline name<br/>name: CORD-19 Pipeline</span><span id="82b5" class="nj md it nf b gy no nl l nm nn"># Schedule job to run @ 12am, 10am, 3pm local time<br/>schedule: "0 0,10,15 * * *"</span><span id="fd6f" class="nj md it nf b gy no nl l nm nn"># Pipeline execution steps<br/>steps:<br/>  - check: allen-institute-for-ai/CORD-19-research-challenge<br/>  - kernel: davidmezzetti/cord-19-article-entry-dates<br/>  - status: 1m<br/>  - kernel: davidmezzetti/cord-19-analysis-with-sentence-embeddings<br/>  - status: 15m<br/>  - kernel: davidmezzetti/cord-19-population<br/>  - kernel: davidmezzetti/cord-19-relevant-factors<br/>  - kernel: davidmezzetti/cord-19-patient-descriptions<br/>  - kernel: davidmezzetti/cord-19-models-and-open-questions<br/>  - kernel: davidmezzetti/cord-19-materials<br/>  - kernel: davidmezzetti/cord-19-diagnostics<br/>  - kernel: davidmezzetti/cord-19-therapeutics<br/>  - kernel: davidmezzetti/cord-19-risk-factors<br/>  - status: 2.5m<br/>  - kernel: davidmezzetti/cord-19-task-csv-exports<br/>  - kernel: davidmezzetti/cord-19-study-metadata-export<br/>  - kernel: davidmezzetti/cord-19-most-influential-papers<br/>  - kernel: davidmezzetti/cord-19-report-builder<br/>  - kernel: davidmezzetti/cord-19-forecasting-articles<br/>  - kernel: davidmezzetti/cord-19-mice-trials<br/>  - kernel: davidmezzetti/cord-19-bcg-vaccine<br/>  - kernel: davidmezzetti/cord-19-digital-contact-tracing-privacy<br/>  - status: 2.5m</span></pre><p id="e361" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的例子一天运行3次。在执行之前，它将数据集的版本与前一次运行的版本进行比较，如果没有变化，则该过程退出。否则，笔记本会一直启动到状态步骤。此时，kernelpipes将等待所有笔记本完成后再继续。</p><p id="14f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的配置中，cord-19-article-entry-dates开始，kernelpipes将每分钟检查一次，直到完成，然后启动cord-19-analysis笔记本，每15分钟检查一次完成情况。一旦完成，下一个系列的笔记本会并行启动，kernelpipes会等待所有操作完成，以此类推。</p><p id="f311" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每次CORD-19数据集更新时，该管道都会刷新，无需任何用户操作。它有效地使一系列“活”笔记本随着新的新冠肺炎文章的增加而不断更新。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1490" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="91bc" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">Kaggle平台在许多不同的领域带来了很多东西，本文只是触及了表面(<a class="ae ky" href="https://www.kaggle.com/learn/overview" rel="noopener ugc nofollow" target="_blank">微型课程</a>看起来也很棒)。总的来说，我对这套功能印象非常深刻，并且能够设计一个复杂的全自动数据分析管道。将来用Kaggle构建时，请记住这些特性！</p></div></div>    
</body>
</html>