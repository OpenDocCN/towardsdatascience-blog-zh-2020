<html>
<head>
<title>Exploratory Data Analysis on Mobile App Behavior Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">移动应用行为数据的探索性数据分析</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/exploratory-data-analysis-on-mobile-app-behavior-data-2777fc937973?source=collection_archive---------60-----------------------#2020-06-22">https://towardsdatascience.com/exploratory-data-analysis-on-mobile-app-behavior-data-2777fc937973?source=collection_archive---------60-----------------------#2020-06-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ff51" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用可视化和相关性分析，深入了解具有大量原始数据的 EDA，以提高您的动手技能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/25593f85f5b503d14f39f9e0d593cda5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*QW8qsPD8cj9AGt6x-LLrig.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">来自 Unsplash 的 Img 通过<a class="ae ku" href="https://unsplash.com/photos/jrh5lAq-mIs" rel="noopener ugc nofollow" target="_blank">链接</a></p></figure><p id="d3f0" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在之前的<a class="ae ku" rel="noopener" target="_blank" href="/eda-how-to-on-app-behavior-data-77fde7384a70">文章</a>中，我们介绍了如何在小型 app 行为数据集上执行 EDA。希望你在那里学到了很多。<strong class="kx iu">这篇文章旨在用更复杂的数据集提高你的 EDA 技能，并介绍新的技巧。</strong>它被分成 6 部分。</p><p id="8d06" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">1.数据审查</p><p id="fe68" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">2.数据清理</p><p id="bb56" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">3.数值变量分布</p><p id="ac03" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">4.二元变量分布</p><p id="a3ff" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">5.相关分析</p><p id="548a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">6.摘要</p><p id="e190" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">现在，让我们开始旅程🏃‍♂️🏃‍♀️.</p><ol class=""><li id="e5f3" class="lr ls it kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated"><strong class="kx iu">数据审核</strong></li></ol><p id="e009" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">快速查看下面视频中显示的数据，您会发现有 31 列 27，000 行。有了这么多特性，最好为每一列的解释创建一个视图，如图 1 所示，以增强我们的理解。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">视频 1 原始数据的简要视图</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mc"><img src="../Images/d4e6150244ddc1a45dad4e4ac98d5886.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NkvEDmPcAf1kdADSBkGkYQ.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图 1 表格视图中的变量说明</p></figure><p id="7940" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">2.<strong class="kx iu">数据清理</strong></p><p id="ad44" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">原始数据通常包含缺失值。所以我们需要知道每一列中是否有<em class="mh"> NaN </em>。具体来说，</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="43b4" class="mn mo it mj b gy mp mq l mr ms">dataset.columns[dataset.isna().any()].tolist()</span></pre><p id="8032" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们得到了列<em class="mh"> ['年龄'，'信用分数'，'奖励收入']。</em>但是这些列中有多少条记录是<em class="mh"> NaN </em>？所以，</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="34ed" class="mn mo it mj b gy mp mq l mr ms">dataset.isna().sum()</span></pre><p id="540e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如图 2 所示，在'<em class="mh"> credit_score' </em>栏中有 8000 多名<em class="mh"> NaN </em>，在'<em class="mh"> rewards_earned' </em>栏中有 3227 名<em class="mh"> NaN </em>。<strong class="kx iu">我们将删除这两列，并删除年龄为<em class="mh">男</em>的 4 条记录。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/e9f9bcc26674640831c16c434bebedad.png" data-original-src="https://miro.medium.com/v2/resize:fit:426/format:webp/1*jI_c7Tq-YiLgjd5D8v_r3g.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图 2 <em class="mu">列中的 NaN </em>记录</p></figure><p id="6dab" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">具体来说，</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="82fc" class="mn mo it mj b gy mp mq l mr ms">dataset = dataset[pd.notnull(dataset.age)]<br/>dataset = dataset.drop(columns = [‘credit_score’, ‘rewards_earned’])</span></pre><p id="fccd" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">3.<strong class="kx iu">数值变量分布</strong></p><p id="78d0" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">为了更好地理解数据分布，可视化是最好的方法。让我们尝试一个<strong class="kx iu">直方图</strong>。具体来说，</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="c003" class="mn mo it mj b gy mp mq l mr ms">dataset2 = dataset.drop(columns = [‘user’, ‘churn’])<br/>for i in range(1, dataset2.shape[1] + 1):<br/>    plt.subplot(6, 5, i)<br/>    f = plt.gca()<br/>    vals = np.size(dataset2.iloc[:, i — 1].unique()<br/>    plt.hist(dataset2.iloc[:, i — 1], bins=vals, color=’#3F5D7D’)</span></pre><p id="0bb2" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如图 3 所示，许多变量是正偏的。一些二元变量均匀分布，而另一些则高度集中在一边。<strong class="kx iu">对于高度集中的变量，审查因变量是否不平衡非常重要。例如，对于列'<em class="mh"> waiting_4_loan </em>'，小于 10%为 1。如果大多数等待贷款的人退订了该产品，该模型很可能会在这个功能上适得其反。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/522246d9d5f085aae410bbd8d6cd849a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*WBQTK2OuVlfYU_tDzNX8_A.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图 3 数值变量直方图</p></figure><p id="e11d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">4.<strong class="kx iu">二元变量分布</strong></p><p id="4ea8" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如上所述，让我们使用一个<strong class="kx iu">饼状图</strong>来关注二元变量的分布。具体来说，</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="0872" class="mn mo it mj b gy mp mq l mr ms">dataset2 = dataset[[‘housing’, ‘is_referred’, ‘app_downloaded’, ‘web_user’, ‘app_web_user’, ‘ios_user’, ‘android_user’, ‘registered_phones’, ‘payment_type’, ‘waiting_4_loan’, ‘cancelled_loan’, ‘received_loan’, ‘rejected_loan’, ‘left_for_two_month_plus’, ‘left_for_one_month’, ‘is_referred’]]</span><span id="d93a" class="mn mo it mj b gy mv mq l mr ms">for i in range(1, dataset2.shape[1] + 1):<br/>    f = plt.gca()<br/>    values = dataset2.iloc[:, i — 1].value_counts(normalize = True).values<br/>    index = dataset2.iloc[:, i — 1].value_counts(normalize = True).index<br/>    plt.pie(values, labels = index, autopct=’%1.1f%%’)</span></pre><p id="4c3f" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如图 4 所示，有 5 列需要进一步探索，因为它们的分布高度集中:<em class="mh"> 'waiting_4_loan '、' cancelled _ loan '、' received_loan '、' rejected_loan '、' left_for_one_month' </em>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/512dfd1827d5568e2a560255619aeab0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*oCJe2lZ4p566uafle38zfQ.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图 4 二元变量饼图</p></figure><p id="73de" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">对于这 5 列，让我们回顾一下少数类别中的因变量分布。具体来说，</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/bdbb08773352e6ebaf27ae32d5bd0332.png" data-original-src="https://miro.medium.com/v2/resize:fit:716/format:webp/1*ufzKxA6iAZ49ji2u0zzxfg.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图 5 集中变量的因变量分布</p></figure><p id="e756" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">图 5 告诉我们，在少数民族类别中，因变量并不严重失衡。太好了。没什么好担心的。</p><p id="8d8f" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">总之，可视化的全部目的就是了解每个变量的分布是如何均匀的，以及每个二元变量中因变量的分布是如何均匀的。因此，我们可以识别需要过采样或下采样的变量。</strong></p><p id="93b8" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">5.<strong class="kx iu">相关性分析</strong></p><p id="7dde" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">5.1 自变量和因变量之间</p><p id="dfb7" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这一步是为了了解哪些特征或变量可能对因变量有很大影响。这里我们只分析<strong class="kx iu">数值变量</strong>。</p><p id="cc55" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">具体来说，</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="f617" class="mn mo it mj b gy mp mq l mr ms">dataset.drop(columns = [‘user’, ‘churn’, ‘housing’, ‘payment_type’, ‘registered_phones’,‘zodiac_sign’]).corrwith(dataset.churn).plot.bar(figsize=(20,10), title = ‘Correlation with Response variable’,fontsize = 15, rot = 45,grid = True)</span></pre><p id="1df2" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">图 6 显示了一些有趣的发现。例如，对于变量'<em class="mh"> cc_taken' </em>，客户获得的信用越多，他们流失的可能性就越大。这可能表明顾客对信用卡不满意。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/706f41a92f41c7f0be67f9fd2a010fc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*zluF9xk_egMOdbB6cnPoqg.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图 6 自变量和因变量之间的相关性</p></figure><p id="87fd" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">5.2 自变量之间</p><p id="0520" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">理想情况下，我们只使用“独立”变量作为输入。相关矩阵表明变量是否相互独立。具体来说，</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="1f66" class="mn mo it mj b gy mp mq l mr ms">corr = dataset.drop(columns = [‘user’, ‘churn’]).corr()</span></pre><p id="3267" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如图 7 所示，'<em class="mh"> android_user </em>'和'<em class="mh"> ios_user </em>'之间有很强的负相关关系。另一列是“<em class="mh"> app_web_user </em>”，表示同时使用 app 和 web 的用户。当'<em class="mh"> app_downloaded </em>'为 1 且'<em class="mh"> web_user </em>'为 1 时，只能为 1。所以'<em class="mh"> app_web_user </em>'不是一个需要去掉的自变量。具体来说，</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="9c2a" class="mn mo it mj b gy mp mq l mr ms">dataset = dataset.drop(columns = [‘app_web_user’])<br/>dataset.to_csv(‘new_churn_data.csv’, index = False)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/509d494357bbd6fff26a3bf1eb18a2c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/1*Nin0sMypGlAWLuW0afavow.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图 7 独立变量间的相关矩阵</p></figure><p id="581d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">6.<strong class="kx iu">总结</strong></p><p id="63b9" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在许多情况下，您将面临比我们在这里处理的更多的脏数据。因此，您需要首先清理数据，检查数据分布，并了解是否出现了不平衡。此外，使用相关性分析来消除对要素的任何依赖性。幸运的是，不管你有多少数据，思维过程或多或少都是一样的。</p><p id="3da9" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">太好了！这就是旅程的全部！如果需要源代码，可以随时访问我的</strong> <a class="ae ku" href="https://github.com/luke4u/Customer_Behaviour_Prediction/tree/main/churn_prediction" rel="noopener ugc nofollow" target="_blank"> <strong class="kx iu"> Github </strong> </a> <strong class="kx iu">页面</strong>🤞🤞<strong class="kx iu">。下一篇文章将介绍数据处理、模型构建和优化</strong>。</p></div></div>    
</body>
</html>