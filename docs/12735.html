<html>
<head>
<title>How to Evaluate your Stock Trading Model</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何评价自己的炒股模式</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-evaluate-your-stock-trading-model-e7e5e51d4320?source=collection_archive---------48-----------------------#2020-09-01">https://towardsdatascience.com/how-to-evaluate-your-stock-trading-model-e7e5e51d4320?source=collection_archive---------48-----------------------#2020-09-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="135c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">提示:不要使用传统的损失函数</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/367da768a913697e0ef6a6c6bcb8aa5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0l7-vV_6zXMjAZzpRLM2xw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com/s/photos/stock-trading?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae ky" href="https://unsplash.com/@austindistel?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Austin Distel </a>拍摄的照片</p></figure><p id="fe83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="lv">来自《走向数据科学》编辑的提示:</em> </strong> <em class="lv">虽然我们允许独立作者根据我们的</em> <a class="ae ky" rel="noopener" target="_blank" href="/questions-96667b06af5"> <em class="lv">规则和指导方针</em> </a> <em class="lv">发表文章，但我们并不认可每个作者的贡献。你不应该在没有寻求专业建议的情况下依赖一个作者的作品。详见我们的</em> <a class="ae ky" rel="noopener" target="_blank" href="/readers-terms-b5d780a700a4"> <em class="lv">读者术语</em> </a> <em class="lv">。</em></p><p id="3188" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我偶尔观察到“使用 LSTMs 预测股价”时，准确性和盈利性的衡量标准是亏损，通常是均方误差函数。对于以预测值的准确性为最终目标的数据集来说，这一切都很好。</p><p id="534e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在股票交易的情况下，盈利是最终目标。那么如何才能量化这个价值呢？</p><h1 id="3d27" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">概念:</h1><p id="a580" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">评估模型的最佳值应该与项目的最终目标——盈利能力直接相关。所以我们知道脚本应该能够评估估计的盈利能力。</p><p id="4977" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，为了进行盈利能力评估，程序必须对以前从未见过的数据进行处理。这意味着我们必须对数据进行测试，以检查一个人能赚多少钱。</p><p id="d5c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了利润估算程序的两个最重要的特征，让我们开始创建这个程序。</p><h1 id="9430" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">代码:</h1><p id="c31e" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我为不同类型的交易准备了三种不同的脚本:</p><ul class=""><li id="d996" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated">固定时间交易</li><li id="2393" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">正常股票交易</li><li id="7220" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">二元期权交易</li></ul><h2 id="3c36" class="nh lx it bd ly ni nj dn mc nk nl dp mg li nm nn mi lm no np mk lq nq nr mm ns bi translated">固定时间交易:</h2><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="224f" class="nh lx it nu b gy ny nz l oa ob">def trading_simulator(trade_time,trade_value,close_price,sma_one,sma_two):<br/>    intersections,insights = intersection(sma_1,sma_2)<br/>    profit = 0<br/>    logs = []<br/>    for i in range(len(insights)):<br/>        index = intersections[i]<br/>        if insights[i] == buy:<br/>            if index+trade_time &lt; len(fx_data):<br/>                if fx_data[index][-1] &lt; fx_data[index+trade_time][-1]:<br/>                    profit += trade_value * 0.8<br/>                    logs.append(trade_value*0.8)<br/>                elif fx_data[index][-1] &gt; fx_data[index+trade_time][-1]:<br/>                    profit -= trade_value<br/>                    logs.append(-trade_value)<br/>        elif insights[i] == sell:<br/>            if index+trade_time &lt;= len(fx_data):<br/>                if fx_data[index][-1] &gt; fx_data[index+trade_time][-1]:<br/>                    profit += trade_value * 0.8<br/>                    logs.append(trade_value*0.8)<br/>                elif fx_data[index][-1] &lt; fx_data[index+trade_time][-1]:<br/>                    profit -= trade_value<br/>                    logs.append(-trade_value)<br/>        profit = profit<br/>    return profit,logs</span></pre><p id="bbb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个交易程序使用两个 SMA 值的交集来测试如果基于对两个定义的 SMA 值的交集的理解以及准确性(所有交易中盈利的交易数量)进行交易，将会赚多少钱。</p><p id="77ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个程序基于固定时间交易的利润估计:一种交易策略，其中你预测在下一个时间框架内，如果价格将增加或减少。您可以修改程序，或者只是从这里复制整个脚本来测试利润估计:</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="d14c" class="nh lx it nu b gy ny nz l oa ob">import requests<br/>import numpy as np<br/>from matplotlib import pyplot as plt<br/>import datetime<br/>API_KEY = 'YOURAPIKEYHERE'<br/>from_symbol = 'EUR'<br/>to_symbol = 'USD'</span><span id="2da8" class="nh lx it nu b gy oc nz l oa ob">def sell():<br/>    pyautogui.click(1350,320)<br/>    <br/>def buy():<br/>    pyautogui.click(1350,250)<br/>    <br/>def SMA(prices,value):<br/>    means = []    count = 0<br/>    while value+count &lt;= len(prices):<br/>        pre_val = prices[count:value+count]<br/>        count +=1<br/>        means.append(np.mean(pre_val))<br/>    return means</span><span id="7294" class="nh lx it nu b gy oc nz l oa ob">def intersection(lst_1,lst_2):<br/>    intersections = []<br/>    insights = []<br/>    if len(lst_1) &gt; len(lst_2):<br/>        settle = len(lst_2)<br/>    else:<br/>        settle = len(lst_1)<br/>    for i in range(settle-1):<br/>        if (lst_1[i+1] &lt; lst_2[i+1]) != (lst_1[i] &lt; lst_2[i]):<br/>            if ((lst_1[i+1] &lt; lst_2[i+1]),(lst_1[i] &lt; lst_2[i])) == (True,False):<br/>                insights.append(buy)<br/>            else:<br/>                insights.append(sell)<br/>            intersections.append(i)<br/>    return intersections,insights</span><span id="8504" class="nh lx it nu b gy oc nz l oa ob">def trading_simulator(trade_time,trade_value,close_price,sma_one,sma_two):<br/>    intersections,insights = intersection(sma_1,sma_2)<br/>    profit = 0<br/>    logs = []<br/>    for i in range(len(insights)):<br/>        index = intersections[i]<br/>        if insights[i] == buy:<br/>            if index+trade_time &lt; len(fx_data):<br/>                if fx_data[index][-1] &lt; fx_data[index+trade_time][-1]:<br/>                    profit += trade_value * 0.8<br/>                    logs.append(trade_value*0.8)<br/>                elif fx_data[index][-1] &gt; fx_data[index+trade_time][-1]:<br/>                    profit -= trade_value<br/>                    logs.append(-trade_value)<br/>        elif insights[i] == sell:<br/>            if index+trade_time &lt;= len(fx_data):<br/>                if fx_data[index][-1] &gt; fx_data[index+trade_time][-1]:<br/>                    profit += trade_value * 0.8<br/>                    logs.append(trade_value*0.8)<br/>                elif fx_data[index][-1] &lt; fx_data[index+trade_time][-1]:<br/>                    profit -= trade_value<br/>                    logs.append(-trade_value)<br/>        profit = profit<br/>    return profit,logs</span><span id="b187" class="nh lx it nu b gy oc nz l oa ob">close_price = []<br/>r = requests.get(<br/>        '<a class="ae ky" href="https://www.alphavantage.co/query?function=FX_INTRADAY&amp;from_symbol='" rel="noopener ugc nofollow" target="_blank">https://www.alphavantage.co/query?function=FX_INTRADAY&amp;from_symbol='</a> +<br/>        from_symbol + '&amp;to_symbol=' + to_symbol +<br/>        '&amp;interval=1min&amp;outputsize=full&amp;apikey=' + API_KEY)<br/>jsondata = json.loads(r.content)<br/>pre_data = list(jsondata['Time Series FX (1min)'].values())<br/>fx_data = []<br/>for data in pre_data: <br/>    fx_data.append(list(data.values()))<br/>fx_data.reverse()<br/>for term in fx_data:<br/>    close_price.append(float(term[-1]))</span><span id="f197" class="nh lx it nu b gy oc nz l oa ob">sma_1 = SMA(close_price,2)<br/>sma_2 = SMA(close_price,1)<br/>profit,logs = trading_simulator(1,10,close_price,sma_1,sma_2)<br/>profit</span></pre><p id="20af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了让程序工作，你必须用你自己的 API 密匙替换 API 密匙参数。</p><h2 id="56d9" class="nh lx it bd ly ni nj dn mc nk nl dp mg li nm nn mi lm no np mk lq nq nr mm ns bi translated">正常交易:</h2><p id="524a" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">正常的交易是买入或卖出一定数量的股票，所赚的利润是股票价格的差额。</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="052e" class="nh lx it nu b gy ny nz l oa ob">def estimate_profits(standard_qty,model,data,close,open_,high,low):<br/>    close_prices = close<br/>    open_prices = open_<br/>    low_prices = low<br/>    high_prices = high<br/>    pred_close = list()<br/>    pred_open = list()<br/>    orders = list()<br/>    profits = list()<br/>    <br/>    for i in range(len(data)):<br/>        pred = model.predict(data[i])[0]<br/>        open_price,close_price = pred<br/>        if open_price &gt; close_price:<br/>            side = -1<br/>        elif open_price &lt; close_price:<br/>            side = 1<br/>        qty = standard_qty<br/>        orders.append([side,qty])<br/>        pred_close.append(close_price)<br/>        pred_open.append(open_price)<br/>        <br/>    for i in range(len(data)):<br/>        sign = 0<br/>        mult = 0<br/>        side,qty = orders[i][0],orders[i][1]<br/>        dif = close_prices[i] - open_prices[i]<br/>        if dif &gt; 0:<br/>            sign = 1<br/>        else:<br/>            sign = -1<br/>        if sign == side:<br/>            mult = 1<br/>        else:<br/>            mult = -1<br/>        profit = dif*mult*qty<br/>        profits.append(profit)<br/>    return profits</span></pre><p id="36cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该程序计算资产在制造时和下一次制造时之间的差异。它将这一差额乘以股票数量来计算利润。你可以调整时间步长，测试更长时间的交易策略。</p><h2 id="2290" class="nh lx it bd ly ni nj dn mc nk nl dp mg li nm nn mi lm no np mk lq nq nr mm ns bi translated">二元期权交易:</h2><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="33ed" class="nh lx it nu b gy ny nz l oa ob">def trading_simulator(open_prices):<br/>    profit = 0<br/>    insights = []<br/>    logs = []<br/>    for i in range(len(pred)):<br/>        if float(open_prices[i]) &gt; pred[i][0]:<br/>            insights.append('sell')<br/>        elif float(open_prices[i]) &lt; pred[i][0]:<br/>            insights.append('buy')<br/>    for i in range(len(insights)):<br/>        if insights[i] == 'sell':<br/>            if float(open_prices[i]) &gt; y[i]:<br/>                profit += 8<br/>                logs.append(8)  <br/>            else:<br/>                profit -= 10<br/>                logs.append(-10)<br/>                <br/>        if insights[i] == 'buy':<br/>            if float(open_prices[i]) &lt; y[i]:<br/>                profit += 8<br/>                logs.append(8)  <br/>            else:<br/>                profit -= 10<br/>                logs.append(-10)<br/>            <br/>    return profit,logs</span></pre><p id="6cde" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该函数计算利润，考虑交易金额的固定 80%利润。它计算当前值和下一个时间步长值之间的差值。</p><h1 id="526d" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">结论:</h1><p id="cbb6" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我真的希望人们可以使用程序的盈利能力来评估他们的模型，以便真正了解交易算法是否有效。</p><h1 id="be4a" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">我的链接:</h1><p id="a665" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">如果你想看更多我的内容，点击这个<a class="ae ky" href="https://linktr.ee/victorsi" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">链接</strong> </a>。</p></div></div>    
</body>
</html>