<html>
<head>
<title>Extracting headers and paragraphs from pdf using PyMuPDF</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用PyMuPDF从pdf中提取标题和段落</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/extracting-headers-and-paragraphs-from-pdf-using-pymupdf-676e8421c467?source=collection_archive---------4-----------------------#2020-04-09">https://towardsdatascience.com/extracting-headers-and-paragraphs-from-pdf-using-pymupdf-676e8421c467?source=collection_archive---------4-----------------------#2020-04-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div class="gh gi ir"><img src="../Images/4fc52091d8a0e316ce0202bc6362885c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*ijbZMFI45PPS_hLPVXK0uQ.gif"/></div><p class="iy iz gj gh gi ja jb bd b be z dk translated">由<a class="ae jc" href="https://enjoyanimation.com/work" rel="noopener ugc nofollow" target="_blank">制作的动画享受动画</a></p></figure><div class=""/><div class=""><h2 id="33ea" class="pw-subtitle-paragraph kc je jf bd b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dk translated">一种从pdf文档中解析标题和段落的简单方法</h2></div><p id="fd6f" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是完全不同的东西:解析pdf文档并提取标题和段落！有各种各样的软件包可以从pdf文档中提取文本并将其转换成HTML，但是我发现这些软件包对于手头的任务来说要么过于复杂，要么过于复杂。根据我的经验，一般的pdf解析器对所有文档进行一般化处理，但是对于结构相似的文档的特定用例，我们可以用自己的代码来提高性能！</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h2 id="ea8e" class="ly lz jf bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated">方法学</h2><p id="509a" class="pw-post-body-paragraph ku kv jf kw b kx mr kg kz la ms kj lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">由于pdf文件由非结构化的文本组成，我们需要在不同的文档中找到一些关于标题和段落如何分隔的相似之处。使用一个关于保险公司的荷兰保单条款的大型pdf文件(每个50-150页)的小样本，我发现<em class="lq">有些</em>一致的是标题和段落通常由文本的<strong class="kw jg">字体大小</strong>和<strong class="kw jg">字体粗细</strong>分隔，并且<strong class="kw jg">最常用的字体</strong>可以被认为是段落。现在，这是我们创造方法论的一个很好的起点。</p><ol class=""><li id="d622" class="mw mx jf kw b kx ky la lb ld my lh mz ll na lp nb nc nd ne bi translated">使用PyMuPDF将段落标识为文档中使用最多的字体的文本，将标题标识为比段落样式更大的字体，将下标标识为比段落样式更小的字体。</li><li id="10e5" class="mw mx jf kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">为标题、段落和下标创建一个带有HTML样式元素标签的字典，比如<code class="fe nk nl nm nn b">&lt;h1&gt;</code>、<code class="fe nk nl nm nn b">&lt;p&gt;</code>和<code class="fe nk nl nm nn b">&lt;s0&gt;</code>。</li><li id="ba5b" class="mw mx jf kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">用这些元素<code class="fe nk nl nm nn b">&lt;tags&gt;</code>注释文本片段。</li></ol></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h2 id="bc34" class="ly lz jf bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated">识别段落、标题和下标</h2><p id="4b73" class="pw-post-body-paragraph ku kv jf kw b kx mr kg kz la ms kj lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">我们使用PyMuPDF包来读取PDF文件。该软件包逐页打开pdf文档，将其所有内容保存在一个<code class="fe nk nl nm nn b">block</code>中，并识别文本<code class="fe nk nl nm nn b">size</code>、<code class="fe nk nl nm nn b">font</code>、<code class="fe nk nl nm nn b">colour</code>和<code class="fe nk nl nm nn b">flags</code>。我发现一些pdf文档只通过<code class="fe nk nl nm nn b">font</code>和<code class="fe nk nl nm nn b">size</code>来区分标题和段落，但是其他的使用所有四个属性。为了说明这一点，我们将添加一个<code class="fe nk nl nm nn b">granularity</code>标志，这样我们就可以决定在区分文档中不同的文本部分时包含哪些属性。</p><p id="51b3" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这个阶段，我们将创建一个包含所有不同样式和属性的<code class="fe nk nl nm nn b">dictionary</code>和一个包含所有这些样式的<code class="fe nk nl nm nn b">[(font_size, count), ..]</code>列表。</p><figure class="no np nq nr gt iv"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="277d" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们迭代文档的<code class="fe nk nl nm nn b">pages</code>和<code class="fe nk nl nm nn b">blocks</code>，由<code class="fe nk nl nm nn b">PyMuPDF</code>包(导入为<code class="fe nk nl nm nn b">fitz</code>)解析，并根据我们的<code class="fe nk nl nm nn b">granularity</code>标志识别所有的样式和属性。</p><p id="ea2e" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的一个文档的输出如下所示:</p><pre class="no np nq nr gt nu nn nv nw aw nx bi"><span id="39b3" class="ly lz jf nn b gy ny nz l oa ob">font_counts, styles = fonts(doc, granularity=False)</span><span id="50bd" class="ly lz jf nn b gy oc nz l oa ob">[('9.5', 1079), ('10.0', 190), ('8.5', 28), ('10.5', 24), ...]</span><span id="c8ec" class="ly lz jf nn b gy oc nz l oa ob">{'12.0': {'size': 12.0, 'font': 'ArialMT'}, '9.0': {'size': 9.0, 'font': 'XKZKVH+VAGRoundedStd-Light'}, ...}</span></pre><p id="4bc7" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以看到最常用的字体大小是<code class="fe nk nl nm nn b">9.5</code>，有<code class="fe nk nl nm nn b">1079</code>个这样大小的文本。很可能这个字体大小代表了我们文档中的段落。</p><h2 id="eb31" class="ly lz jf bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated">元素标签字典</h2><p id="a860" class="pw-post-body-paragraph ku kv jf kw b kx mr kg kz la ms kj lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">接下来，我们将为每种字体大小创建一个包含元素标签的字典。<strong class="kw jg">注意</strong>，这里我们只考虑字体大小，但是如果你在<code class="fe nk nl nm nn b">fonts()</code>函数中使用<code class="fe nk nl nm nn b">granularity=True</code>标志，通过几行额外的代码，你可以找到一种方法来合并其他属性！</p><figure class="no np nq nr gt iv"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="00d9" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nk nl nm nn b">line 12-13</code>首先，我们确定段落的大小，以区分标签的类型<code class="fe nk nl nm nn b">&lt;header&gt;</code>、<code class="fe nk nl nm nn b">&lt;paragraph&gt;</code>或<code class="fe nk nl nm nn b">&lt;subscript&gt;</code>。<code class="fe nk nl nm nn b">line 16-19</code>我们将大小从高到低排序，以便我们可以向每个元素标签添加正确的整数。注意，我们使用<code class="fe nk nl nm nn b">1</code>作为<strong class="kw jg">最大的</strong>标签，这个数字随着标题和下标的字体大小的减小而减小！我们这样做是因为它与HTLM标签的排序方式相同。<code class="fe nk nl nm nn b">line 22-32</code>用标签填充字典，如下所示。</p><pre class="no np nq nr gt nu nn nv nw aw nx bi"><span id="04c5" class="ly lz jf nn b gy ny nz l oa ob">{60.0: '&lt;h1&gt;', 59.69924545288086: '&lt;h2&gt;', 36.0: '&lt;h3&gt;', 30.0: '&lt;h4&gt;', 24.0: '&lt;h5&gt;', 20.0: '&lt;h6&gt;', 16.0: '&lt;h7&gt;', 14.0: '&lt;h8&gt;', 13.0: '&lt;h9&gt;', 10.5: '&lt;h10&gt;', 10.0: '&lt;h11&gt;', 9.5: '&lt;p&gt;', 9.452380180358887: '&lt;s1&gt;', 9.404520988464355: '&lt;s2&gt;', 8.5: '&lt;s3&gt;', 8.0: '&lt;s4&gt;', 7.5: '&lt;s5&gt;', 7.0: '&lt;s6&gt;'}</span></pre><h2 id="9ce0" class="ly lz jf bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated">提取标题和段落</h2><figure class="no np nq nr gt iv"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="5ae7" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们再次迭代文档的页面和块。对于第一个块，我们用<code class="fe nk nl nm nn b">element tag</code>和来自span <code class="fe nk nl nm nn b">s['text']</code>的实际文本初始化<code class="fe nk nl nm nn b">block_string</code>。对于接下来的每个区间，我们检查字体<code class="fe nk nl nm nn b">size</code>是否与前一个区间的字体<code class="fe nk nl nm nn b">size</code>匹配，或者是否有新的文本大小。相应地，如果字符串大小相同，我们就将它们连接起来。<code class="fe nk nl nm nn b">blocks</code>是由<code class="fe nk nl nm nn b">PyMuPDF</code>包分隔和识别的文本部分，但我发现它们有时包含句子的一部分。因此，为什么我用一个<code class="fe nk nl nm nn b">'|'</code>将它们连接起来，以表明一个新的块已经开始。在后处理步骤中，我们可以决定如何处理这些由管道分隔的部分(连接它们或分离它们)。</p><p id="2cad" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们返回一个包含管道的字符串列表，然后能够识别哪些文本部分是标题、段落或下标，如下所示。</p><pre class="no np nq nr gt nu nn nv nw aw nx bi"><span id="c21e" class="ly lz jf nn b gy ny nz l oa ob">['&lt;h4&gt;Als onderdeel van het | ZekerheidsPakket Particulieren |', '', '&lt;h1&gt;Informatie  over  uw|', '&lt;h2&gt;Inboedelverzekering|', '&lt;h1&gt;Basis|', '', '&lt;h6&gt;Inhoud|', '', '&lt;p&gt;pagina| Leeswijzer, Uw verzekering in het kort | 3 | Polisvoorwaarden Inboedelverzekering Basis | 7 |', '', '&lt;s3&gt;3|', '', '&lt;h7&gt;Uw verzekering in het kort|',</span></pre><p id="dbc1" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如您所看到的，我们仍然需要执行几个后处理步骤来清理数据，并可能以不同的方式对其进行排序，但这至少是一个起点。我希望你在这里学到了一些东西，并快乐编码！完整的脚本和示例pdf文档可以在<a class="ae jc" href="https://github.com/LouisdeBruijn/Medium/tree/master/PDF%20retrieval" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p></div></div>    
</body>
</html>