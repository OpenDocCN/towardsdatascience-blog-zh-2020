# NumPy 速成班

> 原文：<https://towardsdatascience.com/numpy-crash-course-6e2906feb175?source=collection_archive---------52----------------------->

## 关于 NumPy 你需要知道的一切

你好，

今天我们就来看看 [**NumPy Python 库**](https://numpy.org) 。NumPy 用于数值处理。请记住，需要一些基本的 Python 知识。我建议您跟随 jupyter 笔记本，这样您可以看到代码的输出，也可以使用不同的输入进行实验。

![](img/85da91a2f02fbc5bbca43b56bb83b52c.png)

照片由 [Kolleen Gladden](https://unsplash.com/@rockthechaos?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 在 [Unsplash](https://unsplash.com/s/photos/numbers?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 拍摄

在本文中，您将学习如何:

*   创建 numpy 数组。
*   生成随机数，以及如何设置种子。
*   使用数组执行操作。
*   如何重塑一个数组？

如何从 N 维数组中:

*   获取单个元素。
*   获取行/列。
*   切片。
*   做蒙版。

在这个过程中，我们将看到一些**技巧**和**窍门**，你可以用它们来使编码更加高效和简单。

我希望你会喜欢它🙂

首先进行 *pip 安装 numpy* ，然后将其导入您的笔记本电脑:

```
import numpy as np
```

**快速注意:**在每个代码块中，您都可以看到代码和输出。如果你想下载 Jupiter-notebook，你也可以查看我的 GitHub 库[这里](https://github.com/AlexiaArtemis/tensorflow/blob/master/Numpy.ipynb)。

## 创建 numpy 数组

可以使用列表或内置函数来创建数组。让我们看看它们各自是如何工作的。

## A.使用列表创建 numpy 数组

我们可以用一个列表创建一个数组。

我们首先创建一个列表，

```
my_list = [0,1,2,3]
my_list [0, 1, 2, 3]
```

然后将其转换为 numpy 数组。

```
my_array = np.array(my_list)
my_array array([0, 1, 2, 3])
```

## B.使用内置函数创建 numpy 数组

Numpy 有许多内置函数，提供了一种快速有效的方法来创建数组。

## 窍门:

要查看所有可用的函数，请键入阵列的名称，然后按 tab 键。

```
my_array.  # press tab
```

## 1.Arange 内置函数。

假设您想要创建一个大小为 5 的数组，数组中的数字从 0 到 4。我们可以这样做:

```
np.array([0,1,2,3,4]) array([0, 1, 2, 3, 4])
```

但是假设我们需要创建一个大小为 100 的数组，其中包含从 0 到 99 的所有数字。如果使用以前的方法，可能会非常痛苦。这就是阿朗奇拯救世界的地方。

这里我们只需要指定起点和终点(注意，终点不会包含在数组中)。

```
np.arange(0, 100) array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
       17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33,
       34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50,
       51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67,
       68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84,
       85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99])
```

我们还可以指定步长。假设我们想要这个数组的每一个元素，我们可以简单地通过在 arange 函数中增加步长来实现:

```
np.arange(0, 100, 2) array([ 0,  2,  4,  6,  8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32,
       34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66,
       68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98])
```

## 2.Linspace 内置函数，用于创建线性间隔的数组

Linspace 将一个起点、一个终点和它们之间均匀分布的点数作为输入，这些点数也表示数组的长度。

让我们看一个例子:

```
# From 1 to 10, 5 elements, evenly spaced between them.
np.linspace(1, 10, 5) array([ 1\.  ,  3.25,  5.5 ,  7.75, 10\.  ])
```

这里起点是 1，终点是 10。Linspace 创建一个数组，在开始和结束点之间有 5 个均匀分布的数字。

## 3.随机内置函数创建随机数组

如果我们不关心我们的数组会有什么数字呢？嗯，我们简单地把随机数放在那里，对吗？random.randint 函数就是这样做的。

它将一个起点、一个终点(不包含在数组中)和一个形状的大小(不用担心，我们稍后会研究它)作为输入。

```
np.random.randint(0, 4, (2,2)) array([[2, 0],
       [0, 2]])
```

好吧，但现在我想和你产生相同的随机数！怎么才能做到呢？

简单，我们用一颗种子！如果您在一个单元格中键入:

> *np.random.seed(12)*

*我们将得到相同的随机数！*

```
*np.random.seed(12)
same_arr = np.random.randint(0, 10, 20)
same_arr array([6, 1, 2, 3, 3, 0, 6, 1, 4, 5, 9, 2, 6, 0, 5, 8, 2, 9, 3, 4])*
```

## *4.正态(高斯)分布的样本*

*如果我们需要一个大小为 100 的样本，均值为 0，标准差为 1，该怎么办？嗯，我们再次使用。随机但这里不是。我们用 randint。正常！*

```
*np.random.seed(101)
norm_arr = np.random.normal(0, 1, 100)
norm_arr array([ 2.70684984e+00,  6.28132709e-01,  9.07969446e-01,  5.03825754e-01,
        6.51117948e-01, -3.19318045e-01, -8.48076983e-01,  6.05965349e-01,
       -2.01816824e+00,  7.40122057e-01,  5.28813494e-01, -5.89000533e-01,
        1.88695309e-01, -7.58872056e-01, -9.33237216e-01,  9.55056509e-01,
        1.90794322e-01,  1.97875732e+00,  2.60596728e+00,  6.83508886e-01,
        3.02665449e-01,  1.69372293e+00, -1.70608593e+00, -1.15911942e+00,
       -1.34840721e-01,  3.90527843e-01,  1.66904636e-01,  1.84501859e-01,
        8.07705914e-01,  7.29596753e-02,  6.38787013e-01,  3.29646299e-01,
       -4.97104023e-01, -7.54069701e-01, -9.43406403e-01,  4.84751647e-01,
       -1.16773316e-01,  1.90175480e+00,  2.38126959e-01,  1.99665229e+00,
       -9.93263500e-01,  1.96799505e-01, -1.13664459e+00,  3.66479606e-04,
        1.02598415e+00, -1.56597904e-01, -3.15791439e-02,  6.49825833e-01,
        2.15484644e+00, -6.10258856e-01, -7.55325340e-01, -3.46418504e-01,
        1.47026771e-01, -4.79448039e-01,  5.58769406e-01,  1.02481028e+00,
       -9.25874259e-01,  1.86286414e+00, -1.13381716e+00,  6.10477908e-01,
        3.86030312e-01,  2.08401853e+00, -3.76518675e-01,  2.30336344e-01,
        6.81209293e-01,  1.03512507e+00, -3.11604815e-02,  1.93993231e+00,
       -1.00518692e+00, -7.41789705e-01,  1.87124522e-01, -7.32845148e-01,
       -1.38292010e+00,  1.48249550e+00,  9.61458156e-01, -2.14121229e+00,
        9.92573453e-01,  1.19224064e+00, -1.04677954e+00,  1.29276458e+00,
       -1.46751402e+00, -4.94095358e-01, -1.62534735e-01,  4.85808737e-01,
        3.92488811e-01,  2.21490685e-01, -8.55196041e-01,  1.54199041e+00,
        6.66319321e-01, -5.38234626e-01, -5.68581361e-01,  1.40733825e+00,
        6.41805511e-01, -9.05099902e-01, -3.91156627e-01,  1.02829316e+00,
       -1.97260510e+00, -8.66885035e-01,  7.20787599e-01, -1.22308204e+00])*
```

## *诡计！*

*类型**？你会得到如何使用这个功能的信息。如果您不想记住每个函数需要什么输入以及函数返回什么，这很有帮助。***

```
*?np.random.normal*
```

*让我们检查一下 norm_arr 数组的均值是否接近 0，标准差是否接近 1。*

```
*norm_arr.mean()0.166369880423112 norm_arr.std()1.0338189430873386*
```

*如果增加样本量，这些数字将分别越来越接近 0 和 1。*

*让我们从 norm_arr 数组中找出最小和最大的数字，以及它们分别在哪个索引处！*

```
*norm_arr.min() # minimun value-2.1412122910809264 norm_arr.max() # maximun value2.706849839399938 norm_arr.argmin() # index of the minimun value75 norm_arr.argmax() # index of the maximun value0*
```

*最后一步是把所有东西整理好。我们来排序一下 *norm_arr* 数组！*

```
*np.sort(norm_arr) array([-2.14121229e+00, -2.01816824e+00, -1.97260510e+00, -1.70608593e+00,
       -1.46751402e+00, -1.38292010e+00, -1.22308204e+00, -1.15911942e+00,
       -1.13664459e+00, -1.13381716e+00, -1.04677954e+00, -1.00518692e+00,
       -9.93263500e-01, -9.43406403e-01, -9.33237216e-01, -9.25874259e-01,
       -9.05099902e-01, -8.66885035e-01, -8.55196041e-01, -8.48076983e-01,
       -7.58872056e-01, -7.55325340e-01, -7.54069701e-01, -7.41789705e-01,
       -7.32845148e-01, -6.10258856e-01, -5.89000533e-01, -5.68581361e-01,
       -5.38234626e-01, -4.97104023e-01, -4.94095358e-01, -4.79448039e-01,
       -3.91156627e-01, -3.76518675e-01, -3.46418504e-01, -3.19318045e-01,
       -1.62534735e-01, -1.56597904e-01, -1.34840721e-01, -1.16773316e-01,
       -3.15791439e-02, -3.11604815e-02,  3.66479606e-04,  7.29596753e-02,
        1.47026771e-01,  1.66904636e-01,  1.84501859e-01,  1.87124522e-01,
        1.88695309e-01,  1.90794322e-01,  1.96799505e-01,  2.21490685e-01,
        2.30336344e-01,  2.38126959e-01,  3.02665449e-01,  3.29646299e-01,
        3.86030312e-01,  3.90527843e-01,  3.92488811e-01,  4.84751647e-01,
        4.85808737e-01,  5.03825754e-01,  5.28813494e-01,  5.58769406e-01,
        6.05965349e-01,  6.10477908e-01,  6.28132709e-01,  6.38787013e-01,
        6.41805511e-01,  6.49825833e-01,  6.51117948e-01,  6.66319321e-01,
        6.81209293e-01,  6.83508886e-01,  7.20787599e-01,  7.40122057e-01,
        8.07705914e-01,  9.07969446e-01,  9.55056509e-01,  9.61458156e-01,
        9.92573453e-01,  1.02481028e+00,  1.02598415e+00,  1.02829316e+00,
        1.03512507e+00,  1.19224064e+00,  1.29276458e+00,  1.40733825e+00,
        1.48249550e+00,  1.54199041e+00,  1.69372293e+00,  1.86286414e+00,
        1.90175480e+00,  1.93993231e+00,  1.97875732e+00,  1.99665229e+00,
        2.08401853e+00,  2.15484644e+00,  2.60596728e+00,  2.70684984e+00])*
```

*现在我们有了一个从最小值开始一直到最大值的数组。*

## *提示:*

1.  *若要检查数组的维数，请使用数组的名称，然后。ndim*
2.  *若要检查数组的形状，请使用数组的名称，然后。形状*

*但是数组的维度和形状是什么呢？*

*让我们看一个例子。*

*想象一下，你有一个如下所示的嵌套列表:*

*[ [1,2], [3,4], [5,6], [7,8] ]*

*这里，你有一个列表，在这个列表里面，你有另外 4 个列表，每个列表有 2 个元素。太好了。现在想象一下有一个更大的列表，包含前一个列表的 3 倍！我们把所有这些列表转换成 numpy 数组。*

```
*small_array  = np.array([1,2])
small_arrayarray([1, 2]) medium_array = np.array([[1,2],[3,4],[5,6],[7,8]])
medium_arrayarray([[1, 2],
       [3, 4],
       [5, 6],
       [7, 8]]) big_array = np.array([ [[1,2],[3,4],[5,6],[7,8]] , [[1,2],[3,4],[5,6],[7,8]], [[1,2],[3,4],[5,6],[7,8]] ])
big_arrayarray([[[1, 2],
        [3, 4],
        [5, 6],
        [7, 8]],

       [[1, 2],
        [3, 4],
        [5, 6],
        [7, 8]],

       [[1, 2],
        [3, 4],
        [5, 6],
        [7, 8]]])*
```

*我们知道要从数组中获取维数。ndim，所以我们来试试吧！*

```
*small_array.ndim1 medium_array.ndim2 big_array.ndim3*
```

*要查看数组形状，请使用。形状*

```
*small_array.shape(2,) medium_array.shape(4, 2) big_array.shape(3, 4, 2)*
```

*我们在这里看到的是，维度与列表的嵌套程度有关！*

*数组的形状是用来创建数组的列表的长度。在 big_array 中，我们有 3 个列表，每个列表中嵌套了 4 个列表，这 4 个列表的长度都是 2。所以形状是:(3，4，2)。*

## *5.零数组*

*要创建一个每个索引都为零的数组，我们需要指定:*

1.  *数组的长度。*
2.  *形状(作为元组)。如果未指定形状，则默认值为(数组的长度)。*

*输出是一个浮点数为 0 的数组。*

```
*# (3,) shape numpy array with 3 zeros
array1 = np.zeros(3)
array1array([0., 0., 0.]) # (2,3) shape numpy array with 6 zeros
array2 = np.zeros((2,3))
array2array([[0., 0., 0.],
       [0., 0., 0.]])*
```

## *6.一的数组*

*就像。零点函数，同样的事情也适用于这里。要创建一个每个索引都有一个的数组，我们需要指定:*

1.  *数组的长度。*
2.  *形状(作为元组)。如果未指定形状，则默认值为(数组的长度)。*

*输出是一个浮点数为 1 的数组。*

```
*# (3,) shape array with 3 ones
np.ones(3)array([1., 1., 1.]) # (2,3) shape array with 6 ones
np.ones((2,3))array([[1., 1., 1.],
       [1., 1., 1.]])*
```

## *7.完全内置功能*

*0 和 1 可能不是我们唯一想用的数字。如果我们想创建一个数组，它的每个索引都是数字 4 呢？我们可以充分利用内置功能。*

*首先，我们指定数组的形状，然后在每个索引处指定我们想要的数字。*

```
*all_4 = np.full((2, 3), 4)
all_4 array([[4, 4, 4],
       [4, 4, 4]])*
```

## *至此，您知道了创建 numpy 数组的两种方法。*

*第一种方法是使用列表，第二种方法是使用内置函数。现在是时候了解我们可以利用这些阵列做些什么了！首先，我们将看看如何执行操作，然后如何重塑数组，最后如何访问数组中的特定元素。*

## *操作*

*假设我们有两个形状和长度相同的数组，分别叫做 *a* 和 *b* 。*

*我们可以:*

*   *取相应指数之和。*
*   *在每个索引处添加元素值。*

*同样的事情也适用于减法、乘法和除法。*

```
*# Array with 3 random numbers. a = np.random.randint(0, 10, 3)aarray([1, 9, 9])b = np.random.randint(0, 10, 3) 
barray([2, 0, 2]) a + b # addition of two arraysarray([ 3,  9, 11]) a + 1 # adding 1 to each element of aarray([ 2, 10, 10])*
```

## *使再成形*

*假设我们有一个长度为 9 的数组。*

```
*first_arr = np.arange(0,9)
print(first_arr)
first_arr.shape [0 1 2 3 4 5 6 7 8]

(9,)*
```

*这里的目标是创建一个新的数组，包含相同的数据，但具有新的形状！让我们选择(3，3)形状。我们可以使用 shape 内置函数。*

```
*sec_arr = first_arr.reshape(3,3)
print(sec_arr)
sec_arr.shape [[0 1 2]
 [3 4 5]
 [6 7 8]]

(3, 3)*
```

*所以现在我们已经把第一个数组分成了 3 部分，创建了一个(3，3)形状的数组！你能猜出第二个数组的维数吗？你看到数组中嵌套了多少东西？让我们检查一下:*

```
*sec_arr.ndim 2*
```

*这就像我们之前看到的 medium_array。*

## *访问数组中的特定元素*

*我们创造了不同尺寸和形状的阵列。但是我们如何访问我们想要的元素呢？*

*首先，想象一个二维数组，有 5 个嵌套数组，每个数组有 5 个元素。你可以把这个数组想象成一个矩阵。*

```
*mat = np.arange(0, 25).reshape(5, 5)
mat array([[ 0,  1,  2,  3,  4],
       [ 5,  6,  7,  8,  9],
       [10, 11, 12, 13, 14],
       [15, 16, 17, 18, 19],
       [20, 21, 22, 23, 24]])*
```

## *获取矩阵的第一个数组。*

*我们有一个嵌套的数组，所以当我们键入 mat[0]时，这代表第一个维度和第一个数组(因为 0)。*

**注意 python 中的索引从 0 开始！**

```
*mat[0] array([0, 1, 2, 3, 4])*
```

## *获取矩阵的最后一个数组。*

*你可以用-1 来代替计算你的数组有多长。*

```
*mat[-1] array([20, 21, 22, 23, 24])*
```

## *获取单个元素*

*现在假设我们想从这个矩阵中得到值 0。有了 mat[0]我们就有了来自第一维的第一个数组。现在用 mat[0，0]表示第二维度和矩阵中的元素 0。*

```
*mat[0,0] 0*
```

## *去第三排*

*当我们想要访问所有的元素时，我们可以使用符号:。所以我们在这里说，从第一个维度我想要一切，从第二个维度我只想要第三个元素。*

```
*mat[:,2] array([ 2,  7, 12, 17, 22])*
```

## *获取第二列*

*否则:从第一个维度，第二个数组，从第二个维度，一切。将这两列结合起来，我们就剩下第二列了。*

```
*mat[1,:] array([5, 6, 7, 8, 9])*
```

## *限幅*

*这里我们想得到一片或一片矩阵。假设我们想要一个 3x3 的矩阵，其左上角的值来自原始矩阵。我们可以这样做:*

```
*mat[0:3, 0:3] array([[ 0,  1,  2],
       [ 5,  6,  7],
       [10, 11, 12]])*
```

## *掩饰*

*如果我们想要指定一些限制，屏蔽是有用的。假设我们只想从矩阵中得到小于 5 的值。*

```
*mat < 5 # matrix with boolean valuesarray([[ True,  True,  True,  True,  True],
       [False, False, False, False, False],
       [False, False, False, False, False],
       [False, False, False, False, False],
       [False, False, False, False, False]])*
```

## *获取实际值*

*要获得实际值而不是布尔值数组，我们可以这样做:*

```
*my_filer = mat < 5
mat[my_filer] array([0, 1, 2, 3, 4])*
```

*或者只是*

```
*mat[mat<5] array([0, 1, 2, 3, 4])*
```

# *万岁！*

*这样，你实际上完成了 numpy 速成班！为你做到了而自豪吧！我希望这对你有用，你可以使用不同的输入来玩它，我期待着在熊猫速成班见到你。*

*感谢阅读，保持安全，并快乐。*

# *关于我:*

*我对机器学习和人工智能充满热情。我是 Clarify 的一名数据科学家，我们正在那里建造 [**Clarify**](https://www.clarify.us/) ！Clarify 是团队探索时间序列数据和共享知识的工具。*