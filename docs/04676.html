<html>
<head>
<title>Probabilistic Deep Learning for Breast Cancer Detection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于乳腺癌检测的概率深度学习</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/probabilistic-neural-networks-for-breast-cancer-detection-2f1a6951e459?source=collection_archive---------27-----------------------#2020-04-25">https://towardsdatascience.com/probabilistic-neural-networks-for-breast-cancer-detection-2f1a6951e459?source=collection_archive---------27-----------------------#2020-04-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/4c4e9085bf33f4483565604f56a3c6b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EWlL5K6qAftBsdnk-CKbzg.jpeg"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">来源:<a class="ae kf" href="https://unsplash.com/photos/XrLSV-CKmuQ" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="e13a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我将演示使用变分推理来量化深度神经网络权重的不确定性，并为乳腺癌分类数据集做出更明智的预测。</p><p id="0dcf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我将在 PyMC3 中构建一个概率神经网络，它使用 ADVI 来优化我们模型的参数。我们将更多地考虑神经网络权重的后验分布，以及我们可以从中获得的见解。</p><h1 id="c4ea" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">目标</h1><p id="9dfd" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">这里的目标是建立一种算法，可以分析关于乳腺癌细胞的信息和指标，以预测细胞中的癌症是“良性”还是“恶性”</p><p id="041c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">乳腺癌的分类是一个二元分类问题，其中我们将细胞分类为良性或恶性。良性肿瘤是一种不会扩散到身体其他部位的非侵袭性肿瘤。恶性肿瘤是一种侵袭性和癌性肿瘤，可以通过血液扩散到身体的其他部位。如果被确定为“恶性”，乳腺癌需要更有效的治疗。</p><h1 id="4e8a" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">犯假阴性的代价</h1><p id="6bcf" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在这个分类问题中，有两种错误——假阴性和假阳性。假阳性(良性癌症被归类为恶性癌症)将导致我们最终给患者服用更强的药物。虽然这会带来额外的成本和风险，但不会危及生命。<strong class="ki iu">任何假阴性(恶性癌症被错误地归类为良性)都可能是致命的，我们应该不惜一切代价避免它。</strong></p><p id="03a4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们来量化一下这个损失。假阴性会危及生命。因此，假阴性的代价等于一个人生命的价值。虽然对生命的代价存在重大争议，但人类生命的代价大约是 1000 万美元。(注:我不完全同意给生命贴上价格标签，但你应该读一下<a class="ae kf" href="https://www.wsj.com/articles/why-the-government-puts-a-dollar-value-on-life-1458911310" rel="noopener ugc nofollow" target="_blank">的这篇文章。)</a>与此同时，导致更多医疗费用的假阳性的成本约为 8 万美元。这两个错误的比例是 125。因此，提交一个假阴性与提交 125 个假阳性是一样的。</p><p id="cd03" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用整体准确性作为衡量标准来微调算法是没有意义的，因为它掩盖了假阴性和假阳性的分布。因此，我们需要一种算法来将假阴性的数量减少到绝对最小值。因此，我们希望根据假阴性的数量来优化我们的模型。</p><p id="e448" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个算法中有很多地方，我们可以改变参数来影响结果。在这种情况下，我们将微调算法中的一切，以减少假阴性的数量。</p><h1 id="8831" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">数据</h1><p id="179b" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我从加州大学欧文分校的机器学习库中获得了这些数据。在数据集中，科学家将肿瘤细胞的图像转换成九个基本指标:</p><ol class=""><li id="1443" class="mh mi it ki b kj kk kn ko kr mj kv mk kz ml ld mm mn mo mp bi translated">半径，</li><li id="78bf" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">纹理(灰度值的标准偏差)，</li><li id="0ef6" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">周界，</li><li id="ebd2" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">面积，</li><li id="673c" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">平滑度，</li><li id="7dcc" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">紧凑性，</li><li id="7c5a" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">凹度，</li><li id="b031" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">凹点</li><li id="913d" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">对称。</li></ol><p id="7ff9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，图像被简化以供我们使用。因此，我们需要更少的预处理来使我们的数据为分析做好准备。</p><h1 id="78ad" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">数据清理</h1><p id="ede7" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">原始数据文件是未经处理的字符串数据，其中每个值都必须进行分离和处理。一些列有空值。我们清理数据，并在 NumPy 数组中将它转换成可供分析的格式。(注意:大多数 ML/AI 算法接受 NumPy 数组作为输入，因为 NumPy 数组作为矩阵工作。因此，对数据执行线性代数(如点积/投影/乘法)变得容易多了。)</p><p id="a040" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是获取原始数据的代码。数据文件并将其合并到干净的 NumPy 数组中。请注意，我故意编写了比平时更长的代码，因为我想演示实际的处理和转换。通过 pandas/NumPy 内置函数，同样的过程更加简单，尽管它们可能不会更快。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="6645" class="ne lf it na b gy nf ng l nh ni"><em class="nj">""" This section extracts and cleans all the data in the .data file  """</em></span><span id="6d9d" class="ne lf it na b gy nk ng l nh ni"><strong class="na iu">def</strong> extraction(pathname):<br/>    initial = open(pathname)<br/>    image_data = []</span><span id="f2dc" class="ne lf it na b gy nk ng l nh ni"><strong class="na iu">for</strong> line <strong class="na iu">in</strong> initial:<br/>        image_data.append(line.strip()) <br/>     <em class="nj">#Extracting data line by line</em><br/>        <br/>    final_data = []<br/>    target = []<br/>    <br/><em class="nj"># Each line is a record that contains the attributes, delimited by a comma</em><br/>    <br/>    <strong class="na iu">for</strong> string <strong class="na iu">in</strong> image_data: <br/>        string2 = list(string)<br/>        bad_data = <strong class="na iu">False</strong><br/>        indexes = [-1]<br/>        <strong class="na iu">for</strong> (index,element) <strong class="na iu">in</strong> enumerate(string2):<br/>            <strong class="na iu">if</strong> element == ',':<br/>                indexes.append(index)</span><span id="2e73" class="ne lf it na b gy nk ng l nh ni"><em class="nj"># Finding the indexes where the string needs to be be cut</em><br/>                <br/>        indexes.append(len(string))<br/>        data = [] <br/>    <br/>        <strong class="na iu">for</strong> i <strong class="na iu">in</strong> range(1,len(indexes)):<br/>            <em class="nj"># For each split by a comma, we extract the element</em><br/>            element = string[indexes[i-1]+1:indexes[i]]<br/>        <br/>            <strong class="na iu">try</strong>:<br/>            <em class="nj"># If the data is float, we extract it</em><br/>                element = float(element)<br/>                data.append(element)<br/>        <br/>            <strong class="na iu">except</strong>:<br/>            <em class="nj"># Otherwise it's bad data.</em><br/>            <em class="nj"># This includes inputs like missing data, 'NA' or 'nan'</em><br/>                bad_data = <strong class="na iu">True</strong><br/>        <br/>        <strong class="na iu">if</strong> <strong class="na iu">not</strong> bad_data:<br/>            final_data.append(data[1:len(data)-1])<br/>            target.append(data[-1])</span><span id="9f32" class="ne lf it na b gy nk ng l nh ni"><em class="nj"># Appending the data and the class to the data list and target list</em><br/>    <strong class="na iu">return</strong> np.array(final_data), np.array(target).reshape(len(target))</span></pre><p id="0954" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将继续把这段代码放在一个<a class="ae kf" href="https://docs.python.org/3/tutorial/classes.html" rel="noopener ugc nofollow" target="_blank"> Python 类中。</a>python 类帮助我们将所有相关的函数和数据保存在一个对象中。</p><p id="432d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里的输出是两个 NumPy 数组。一个是维数(或形状)为(683，9)的特征数组。因此，它有 683 条记录，每行有九个属性或维度。第二个是 shape (683，1)数组，这是我们的目标。在目标类别中，1 表示恶性，0 表示良性癌症。让我们来处理我们的实际数据:</p><h1 id="6d9c" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">特征工程和数据整合</h1><p id="318a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在这一点上，有人可能认为我们应该投入到模型中，并尝试对其进行调整。但是这种方法的问题很简单:</p><blockquote class="nl nm nn"><p id="794a" class="kg kh nj ki b kj kk kl km kn ko kp kq no ks kt ku np kw kx ky nq la lb lc ld im bi translated">输出结果中的偏差是数据和算法的函数。如果数据的结构、规模和清理不当，算法只能起到减少偏差的作用，但无法弥补数据缺乏一致性的问题。</p></blockquote><p id="7f97" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以让我们开始吧。首先，我们检查要素之间的多重共线性。我们将使用关联热图来检查:</p><figure class="mv mw mx my gt ju gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/8acb5452ac8dd091ee46e3e979982307.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*MyYCYg1-gcM_e1fNcFEi4Q.png"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">使用上述代码生成的关联热图。来源:自己的作品。</p></figure><p id="f3d6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在此热图中，重点关注任意两个变量之间过度相关的非对角线元素。我把极端相关度定义为 80%，但也要看问题的语境。在这里，纹理和参数似乎是极其相关的(91%)。但是我不会移除这个变量，因为这两个变量实际上都很重要。这两个参数在肿瘤细胞的生物学中是必不可少的，因此即使我们没有看到非常统计上的好处，因为 90%的变异是相同的，另外 10%可能有一种模式，这将提高我们算法的能力。</p><p id="90b1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">值得在没有任何参数的情况下重复分析(就像 A/B 测试实验一样)，但是移除变量需要理论证明。我删除了凹度，因为它提高了我的模型的性能。</p><p id="8637" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下一步是正常化。数据的比例不正确，一些参数的比例与其他参数的比例不同，这可能会使算法偏向一个要素。因此，我们使用标准缩放器来重新缩放所有特征，这将所有特征转换为均值为 0、标准差为 1 的新分布。</p><p id="aa8c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">注:</strong>欢迎大家进一步进行数据整理和理解。这里没有限制！我还测试了一个<a class="ae kf" rel="noopener" target="_blank" href="/a-one-stop-shop-for-principal-component-analysis-5582fb7e0a9c"> PCA </a>和一个<a class="ae kf" rel="noopener" target="_blank" href="/linear-discriminant-analysis-in-python-76b8b17817c2"> LDA </a>，试图减少我的数据集中的维数。有趣的是，它没有影响维度，这证明了一个事实，即每个特征都有其变化，不能组合成另一个。主成分分析确实重新排列了维度，这使我们在准确性和假阴性数量方面有了微小的提高。我们将在最后考虑这个问题，但是欢迎您在这里执行自己的 A/B 测试。你也可以在这里下载处理后的数据<a class="ae kf" href="https://docs.google.com/spreadsheets/d/15uN0eEARf9vP087teWtDueEiD3C9tUWgodVm6dLSfno/edit?usp=sharing" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="f1db" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">神经网络</h1><p id="91e1" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果你不知道什么是神经网络，你可以在这里了解更多。我们试图在多个层中构建“决策节点”,接受数据并进行转换。这些转换有助于对数据做出决策。多个层次做出越来越多的决定，共同导致最终的答案。这就像建立一个规则图，让算法用给定数据后有意义的法律来填补空白。每个节点都有一个激活函数，它采用输入的加权和并提供一个输出，该输出成为神经网络下一层的输入。本文的重点是构建网络并使用它来获得结果的过程。你可以在这里了解更多关于建立神经网络的想法<a class="ae kf" rel="noopener" target="_blank" href="/step-by-step-guide-to-building-your-own-neural-network-from-scratch-df64b1c5ab6e">。</a></p><h1 id="5679" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">概率神经网络</h1><p id="62d2" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在上面链接的文章中，<a class="ae kf" href="https://towardsdatascience.com/@marcopeixeiro?source=post_page-----df64b1c5ab6e----------------------" rel="noopener" target="_blank"> Marco Peixeiro </a>谈到了位于神经网络每一层的节点所使用的函数形式。这些“激活函数”在技术上是固定的，并且每个节点的输入权重在网络中被优化。但是简单的神经网络是确定性算法。它给了我们一个重量的估计，你可以用它来做预测。但是没有关于这些估计的不确定性或最终预测的不确定性的信息。这些估计以预测概率或我们估计的置信区间的形式出现。因此，探索贝叶斯推理和神经网络的结合来帮助我们识别这些算法中的不确定性是有价值的。</p><p id="03dd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">具体来说，我们希望提取以下信息:</p><ol class=""><li id="4454" class="mh mi it ki b kj kk kn ko kr mj kv mk kz ml ld mm mn mo mp bi translated"><strong class="ki iu">我们预测的不确定性:</strong>这是以“恶性”对“良性”的概率的形式出现的，而不仅仅是二分法。</li><li id="9532" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated"><strong class="ki iu">权重中的不确定性:</strong>对于神经网络的每一层，我们希望了解这些权重中的不确定性，并使用它来评估我们的神经网络的质量。</li><li id="4f0b" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated"><strong class="ki iu">赋予权重先验的能力:</strong>还记得贝叶斯推理吗？我们将初始化参数的先验，并获得基于先验和给定先验的数据的似然性的后验样本/估计。这些估计将为我们提供不确定性估计。<strong class="ki iu">因此，将 a 置于神经网络中节点权重之前的能力将增加我们分析的价值。</strong></li><li id="4e9c" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated"><strong class="ki iu">分层建模:</strong>神经网络的一个重要方面是理解和汇集基于子群的参数的能力。例如，我们可以估计癌症样本的种族的不同权重(这可能非常重要，因为已经有大量研究证明<a class="ae kf" href="https://www.cdc.gov/cancer/dcpc/research/articles/breast_cancer_rates_women.htm" rel="noopener ugc nofollow" target="_blank">种族影响乳腺癌</a>的死亡率)。</li><li id="16f1" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated"><strong class="ki iu">建模的灵活性</strong>:贝叶斯推理带来了建模的灵活性和主观性。虽然这种灵活性可能会威胁到模型的可靠性，但如果您是专家，并且了解我们数据的不同输入之间的交互的本质细节，这将是有益的。</li></ol><h1 id="0a38" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">自动微分变分推理</h1><p id="02de" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果你对 MCMC 或者变分推理(VI)不太了解，你应该看看<a class="ae kf" rel="noopener" target="_blank" href="/bayesian-inference-problem-mcmc-and-variational-inference-25a8aa9bce29">这篇文章。</a>总而言之，VI 对给定的参数进行分布，然后优化这些分布。例如，网络某一层的权重具有正态分布的先验，我们使用 VI 来找到该分布的最佳平均值和标准偏差。</p><p id="7e32" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">VI 使用 KL-Divergence，这是一个成本函数，帮助我们了解我们的目标概率分布和当前分布之间的距离。但是 VI 不是全自动的，需要微调。因此，我们将使用一个称为自动微分变分推理(ADVI)的 VI 版本，它优化了一个不同的参数(类似于 KL-Divergence，但更容易优化)。该算法使用各种库来区分 ELBO(我们这里的度量)并找到最大值来更新参数。它使用坐标下降(沿坐标轴优化)来实现参数更新方程。我知道这是很多信息，但是我推荐你阅读<a class="ae kf" href="https://luiarthur.github.io/statorial/varinf/introvi/" rel="noopener ugc nofollow" target="_blank">这篇文章</a>来熟悉它。</p><h1 id="b7ae" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">用 PyMC3 中的 ADVI 构建神经网络</h1><p id="7c1a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">对于这个实现，我们不会从头开始构建 ADVI 算法。相反，我们将使用 PyMC3 的内置特性来开发我们的模型，并指定我们想要实现的参数、先验和网络层。</p><p id="6bf7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于这个特定的实现，我将构建一个具有三层的神经网络。最后一层是感知器，也是最后的决策层。我将为它使用一个 sigmoid 函数，这样它就像一个逻辑回归。内部的两个隐藏层将使用“双曲正切”函数。您可以在这里使用 PyMC3 文档中您喜欢的任何函数。我用‘tanh’是因为它的灵活性。在 3.14 弧度的旋转中，Tanh '可以从-无穷大到+无穷大，因此，它可以很容易地模拟不同种类的渐变。</p><p id="30ad" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于每一层，我们必须对每个网络的权重进行先验分布。这些权重处理输入并帮助函数做出决策。我使用标准正态分布(均值为 0，标准差为 1)来构建权重矩阵。请注意，这是一个不知情的先验。如果您有相关的知识来支持您的选择，您可以使用不同的发行版。</p><p id="a3e0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">对于我的网络架构:</strong>每一层接受输入并产生输出。输出的维度比前一个维度少一个。因此，层 1 与 9 维的整个数据集一致，并产生 8 维的隐藏和处理输出，该输出被馈送到第二层。第二层输出七个维度，然后由感知器(基础层)作为逻辑回归进行处理。使用伯努利可能性将最终输出建模为二进制结果。看看下面的代码，跟着注释走:(注意，这个实现的基本结构是受托马斯·威茨基的帖子<a class="ae kf" href="https://docs.pymc.io/notebooks/bayesian_neural_network_advi.html" rel="noopener ugc nofollow" target="_blank">这里</a>的启发。我已经采取了骨架结构，并实现了一个新的，有组织的和知情的神经网络)</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="10be" class="ne lf it na b gy nf ng l nh ni">import numpy as np<br/>floatX = theano.config.floatX<br/>import pymc3 as pm<br/>import theano.tensor as T</span><span id="6da0" class="ne lf it na b gy nk ng l nh ni">def build_network(X_train, Y_train):<br/>    <br/>    <strong class="na iu"># We're initialising the weights here <br/>      (the parameters we need to optimise)</strong></span><span id="fd88" class="ne lf it na b gy nk ng l nh ni"><strong class="na iu"># Note that the shape of the distribution <br/>      should match the dimension of the layer.<br/>    # So, first distribution should go from X.shape[1] = 9 to 8</strong></span><span id="cf8b" class="ne lf it na b gy nk ng l nh ni">initial_weights_1 = np.random.randn(X.shape[1],8).astype(floatX)<br/>    initial_weights_2 = np.random.randn(8, 7).astype(floatX)<br/>    initial_weights_p = np.random.randn(7).astype(floatX)</span><span id="4b3a" class="ne lf it na b gy nk ng l nh ni"><strong class="na iu"># Initialising a model</strong><br/>    with pm.Model() as neural_network:</span><span id="c414" class="ne lf it na b gy nk ng l nh ni"><strong class="na iu"># Denoting input data<br/>        </strong>features = pm.Data('ann_input', X_train) <br/>        output = pm.Data('ann_output', Y_train) <strong class="na iu"># Denoting targets</strong><br/>        <br/>       <strong class="na iu"> # We're now taking the set of parameters and <br/>          assigning a prior distribution to them.<br/>        # The pm.Normal assigns a Normal distribution <br/>           with mean 0 and standard deviation 1</strong><br/>        <br/>        prior_1 = pm.Normal('w_in_1', 0 ,  <strong class="na iu">#mean</strong><br/>                  sigma=1, <strong class="na iu"># standard deviation</strong><br/>                  shape=(X.shape[1], 8), <strong class="na iu">#shape of set of parameters</strong><br/>                  testval=initial_weights_1) <strong class="na iu">#initialised parameters</strong><br/>        <br/>        prior_2 = pm.Normal('w_1_2', 0, sigma=1, shape=(8, 7),<br/>                            testval=initial_weights_2)</span><span id="e4a3" class="ne lf it na b gy nk ng l nh ni">prior_perceptron = pm.Normal('w_3_out', 0, sigma=1, <br/>                            shape=(7,), testval=initial_weights_p)<br/>        <br/>        <strong class="na iu"># Now, we'll assign the functional form of each layer<br/>        # tanh for the first three and sigmoid for the perceptron</strong></span><span id="edaf" class="ne lf it na b gy nk ng l nh ni">layer_1 = pm.math.tanh(pm.math.dot(features, prior_1))<br/>        layer_2 = pm.math.tanh(pm.math.dot(layer_1, prior_2))<br/>        perceptron = pm.math.sigmoid( pm.math.dot(layer_2, <br/>                                      prior_perceptron))<br/>        <br/>        <strong class="na iu"># A bernoulli distribution as the likelihood <br/>          helps model the 0,1 target data as pass/fails</strong></span><span id="beaf" class="ne lf it na b gy nk ng l nh ni">likelihood = pm.Bernoulli('out', output, observed=output,<br/>                                  total_size=Y_train.shape[0])</span><span id="3889" class="ne lf it na b gy nk ng l nh ni">return neural_network</span></pre><p id="6755" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们现在构建网络，并在其上放置一个随机种子，以消除任何起始偏差。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="1794" class="ne lf it na b gy nf ng l nh ni"><strong class="na iu">from</strong> sklearn.model_selection <strong class="na iu">import</strong> train_test_split<br/>X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=        .5)</span><span id="0001" class="ne lf it na b gy nk ng l nh ni">neural_network = build_network(X_train, Y_train)</span><span id="dbda" class="ne lf it na b gy nk ng l nh ni">from pymc3.theanof import set_tt_rng, MRG_RandomStreams<br/>set_tt_rng(MRG_RandomStreams(101))</span></pre><h1 id="8561" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">网络权重的含义</h1><figure class="mv mw mx my gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ns"><img src="../Images/888f8cf1daa9c950cd3e7c23bde1a266.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*POipB6RLNx6niV_s75on7A.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">神经网络中每个连接的权重示例。<strong class="bd nt">来源</strong> : <a class="ae kf" href="https://hackernoon.com/everything-you-need-to-know-about-neural-networks-8988c3ee4491" rel="noopener ugc nofollow" target="_blank">黑客月</a></p></figure><p id="34ad" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">简单地说，每个节点都有一个处理数据的激活函数(就像我们使用的 tanh 函数一样)。该数据然后被加权，然后提交给下一层中的每个节点。这些权重决定了一个节点对下一层中每个节点的影响。通过提取每个权重的不确定性，我们可以了解总体预测不确定性的根源，并将其追溯到数据特征。因此，这些不确定性在用户和神经网络之间提供了急需的透明度，神经网络的隐藏层(节点前后的垂直堆叠变换)更难解释。</p><h1 id="de35" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">优化时间！</h1><p id="f942" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们将使用内置的 ADVI 算法来优化神经网络的权重分布。PyMC3 使它的实现变得非常简单:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="bf04" class="ne lf it na b gy nf ng l nh ni">with neural_network:</span><span id="35f3" class="ne lf it na b gy nk ng l nh ni">inference_method = pm.ADVI()<br/>    approx = pm.fit(n=30000, method= inference_method)</span><span id="3669" class="ne lf it na b gy nk ng l nh ni"><strong class="na iu"># n is the number of iterations for ADVI</strong><br/><strong class="na iu"># method is where we denote the ADVI() from PyMC3</strong></span><span id="b355" class="ne lf it na b gy nk ng l nh ni">plt.figure(figsize=(12,6))<br/>plt.plot(-inference.hist, label='new ADVI', alpha=.3)<br/>plt.plot(approx.hist, label='old ADVI', alpha=.3)<br/>plt.legend()<br/>plt.ylabel('ELBO')<br/>plt.xlabel('iteration');</span></pre><p id="e1a6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尽管 PyMC3 屏蔽了 ADVI 代码，但还是有必要查看一下后端代码来理解这个过程。您将在 PyMC3 Github 存储库的这个 python 文件中找到 ADVI 代码。复习第 323 行的 ADVI 类。ADVI 职能部门的以下文件至关重要:</p><figure class="mv mw mx my gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nu"><img src="../Images/accf12e3f3e9b892ed3961079a2c1085.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BoWPpvon3PNZL2jJi5tZOA.png"/></div></div></figure><p id="4832" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">ADVI 代码进一步依赖于从<a class="ae kf" href="https://github.com/pymc-devs/pymc3/blob/master/pymc3/variational/approximations.py" rel="noopener ugc nofollow" target="_blank">推理. py </a>文件导入的平均场推理函数。它执行简单的平均场推断。同时，它分析输入参数并相应地采取行动。在这种情况下，MeanField()的* *参数还包括一个 ELBO 自动优化的注释。默认为 KL-Divergence。</p><figure class="mv mw mx my gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nv"><img src="../Images/60f1b51d76fff2da6276d5503c94e214.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VxXUx3QOFY6q8cqhKIQDAw.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">ELBO 随迭代次数的变化。<strong class="bd nt">来源:</strong>自己的作品</p></figure><p id="24ae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">ELBO 的优化在 19 秒内完成。但是关于这个模型有一些事情会导致 ELBO 收敛的问题，包括我们在 500 次迭代后观察到的收敛中的噪声。首先，它是一种神经网络，不总是能很好地处理小数据集。训练数据集只有大约 342 个数据点。因此，网络发现在只有 342 个数据点的情况下训练自己并解释所有的复杂性是一项挑战。因此，ELBO 的优化并不简单。</p><p id="d3b5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其次，神经网络很难建立。要知道创建正确网络所需的隐藏层数并不容易。因此，模型规范中也存在不确定性。让我们试着解决这些问题:</p><h1 id="19d7" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">微调 ELBO 的优化</h1><p id="072a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">有多种方法可以确保模型的 ELBO 优化不会发散。这些指标定义了每个神经元处理的不确定性和方差的数量。值得注意的是，模型的收敛取决于数据变化的精确建模。很有可能，您对神经网络的第一次尝试将导致对数据变化的过度建模或建模不足。网络的结构及其参数必须相应地调整。我们可以对该模型的两个主要特性进行微调，以获得更好的结果:</p><h2 id="d2ea" class="ne lf it bd lg nw nx dn lk ny nz dp lo kr oa ob ls kv oc od lw kz oe of ma og bi translated">微调神经网络</h2><p id="3334" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以控制两个主要指标:隐藏层的数量和每个网络中神经元(节点)的数量。</p><ol class=""><li id="0644" class="mh mi it ki b kj kk kn ko kr mj kv mk kz ml ld mm mn mo mp bi translated"><em class="nj">隐藏层数</em>:在较小的数据集(比如我的)中，较高的层数会导致数据中方差的损失，从而影响模型的准确性。在我的实验中，我发现两个隐藏层最适合这个数据集。该指标随着数据集的大小和结构而变化。</li><li id="5894" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated"><em class="nj">神经元数量:</em>每个隐藏层有几个在初始权值部分指定的神经元。您可以选择这些数字来减少、增加或保持层的数量不变。目标是以尽可能好的方式解包数据。因此，这一步取决于每个特征所代表的数据的变化。对于我的数据集，不同特征之间存在高度相关性，每层神经元数量的减少会导致整体准确性的增加。</li></ol><h2 id="d548" class="ne lf it bd lg nw nx dn lk ny nz dp lo kr oa ob ls kv oc od lw kz oe of ma og bi translated">使用微型批次进行可扩展优化</h2><p id="7776" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">为了使推断更快，我们将在 PyMC3 中使用迷你批处理。迷你批次减少了训练数据集的大小。在初始设置中，参数更新将要求参数查看整个训练数据集。他们创建一个小批量的训练数据集(大小为“b”)，每次更新的训练都在小批量上进行。每次迭代后，批次都会更新。</p><p id="f4f7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">经过大量的迭代，微型批次在优化 ELBO 方面变得非常高效，因为更新方程可以查看几乎每一个数据点，但不是同时查看所有数据点，这使得该过程更具可扩展性。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="2c2d" class="ne lf it na b gy nf ng l nh ni">X_new = pm.MiniBatch(X_train, b=50)<br/>Y_new = pm.MiniBatch(Y_train, b=50)</span><span id="a1b8" class="ne lf it na b gy nk ng l nh ni">neural_network = build_network(X_train, Y_train)</span><span id="01cf" class="ne lf it na b gy nk ng l nh ni">with neural_network:<br/>    inference = pm.ADVI()<br/>    approx = pm.fit(n=30000, method=inference, callbacks=<br/>                                [CheckParametersConvergence()])</span></pre><p id="34d8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要使用迷你批次检查结果的收敛性，我们使用相同的绘图算法:</p><figure class="mv mw mx my gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nv"><img src="../Images/9475d6f977acb786705aaa9f82c1fb40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q65sCrF9gYHk81d_DELoBA.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">使用小批量优化的 ELBO 变量。来源:自己的工作</p></figure><p id="db8d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用迷你批处理，我们在 12 秒内达到收敛，但优化似乎不太顺利(初始收敛后发散更多)。我使用了来自大小为 340 的训练数据集的批量大小 50。因此，大小是一个限制，训练批次的减少导致了权重收敛的不稳定性。在结果部分，我们将比较假阴性的实际数量，以确定这种方法在乳腺癌检测中的有效性。</p><h1 id="0f80" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结果的概率</h1><p id="1764" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">为了预测结果，我们首先生成后验样本，这些样本可用于构建预测测试结果的函数。注意，给定模型权重的估计，这些样本对应于结果的后验概率。这些样本不是参数的后验样本，因为我们没有进行 MCMC 采样。</p><p id="c959" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">PyMC3 没有给我们提供预测类。对于每一行，它为我们提供了结果为“1”的概率。我们必须定义一个决策边界。完成这项任务的代码如下:(这段代码的灵感来自 Thomas Wiecki 的博客，虽然我已经简化了代码，减少了一些技术术语)。</p><p id="838a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于计算优化，我不会使用内置的 sample_posterior_predictive 函数，因为它很慢，并且不允许我们初始化预测的先验，这是我们可以手动完成的事情，以实现测试预测的加速。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="f928" class="ne lf it na b gy nf ng l nh ni"><strong class="na iu"># Setting initial values</strong></span><span id="73f7" class="ne lf it na b gy nk ng l nh ni">x = T.matrix('X')<strong class="na iu"> # create symbolic input</strong><br/>n = T.iscalar('n') <strong class="na iu"># number of samples</strong><br/>x.tag.test_value = np.empty_like(X_train[:10]) <br/>n.tag.test_value = 100 <strong class="na iu">#initialising test values</strong></span><span id="eefd" class="ne lf it na b gy nk ng l nh ni"><strong class="na iu"># We now have to generate samples from our nodes <br/># that'll help us make the test predictions</strong></span><span id="491b" class="ne lf it na b gy nk ng l nh ni">_sample_proba =approx.sample_node(neural_network.out.distribution.p,<br/>                                   size=n,<br/>                                   more_replacements=         <br/>                                   {neural_network['ann_input']: x})</span><span id="5770" class="ne lf it na b gy nk ng l nh ni"><strong class="na iu"># Converting the samples into a workable function</strong><br/>sample_proba = theano.function([x, n], _sample_proba)</span><span id="f98e" class="ne lf it na b gy nk ng l nh ni"><strong class="na iu"># The function for prediction of posterior probabilities:</strong></span><span id="10b3" class="ne lf it na b gy nk ng l nh ni"><strong class="na iu"># Predicts the outcomes (True/False) given a decision boundary</strong><br/>def predict(decision_boundary):<br/>    pred = sample_proba(X_test, 500).mean(0) &gt; decision_boundary<br/>    return pred</span><span id="9284" class="ne lf it na b gy nk ng l nh ni"><strong class="na iu"># Compares the outcome to the Y_test values and checks for false-negatives/ false-positives</strong></span><span id="e32f" class="ne lf it na b gy nk ng l nh ni">def false_results(pred):<br/>    false_neg = 0<br/>    false_pos = 0<br/>    <br/>    for i in range(len(pred)):<br/>        if pred[i] == 0 and list(Y_test)[i] == 1:<br/>            false_neg+=1<br/>        elif pred[i] == 1 and list(Y_test)[i] == 0:<br/>            false_pos+=1</span><span id="fdb2" class="ne lf it na b gy nk ng l nh ni">return false_neg, false_pos</span></pre><p id="96c8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在收集了测试预测之后，我们处理它们以收集总错误数、总假阴性和总假阳性。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="ed11" class="ne lf it na b gy nf ng l nh ni">boundaries = np.linspace(0,1,101)<br/>false_negative_num = []<br/>false_positive_num = []<br/>total_errors = []</span><span id="920c" class="ne lf it na b gy nk ng l nh ni">for i in boundaries:<br/>    pred = predict(i)<br/>    n, p = false_negatives(pred)<br/>    false_negative_num.append(n*100/len(pred))<br/>    total_errors.append((n+p)*100/len(pred))<br/>    false_positive_num.append(p*100/len(pred))</span><span id="9b91" class="ne lf it na b gy nk ng l nh ni">plt.figure(figsize=(20,10))<br/>plt.plot(boundaries, false_negative_num, label='False Negative Rate(%)', color='red')<br/>plt.plot(boundaries, false_positive_num, label='False Positive Rate(%)')<br/>plt.plot(boundaries, total_errors, label='Total Error Rate(%)', color='orange')<br/>plt.xlabel('Decision Boundary', fontsize=20)<br/>plt.ylabel('Percentage Cases', fontsize=20)<br/>plt.legend(fontsize=20)<br/>plt.show()</span></pre><h1 id="3665" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">优化决策边界</h1><figure class="mv mw mx my gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oh"><img src="../Images/8eedebec27a3fdbe4d0d0d61feb4a32d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aA4MPXqelM8M-ETFv_mRLw.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">误差百分比随决策边界的变化。<strong class="bd nt">来源:</strong>自己的作品</p></figure><p id="5a90" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里的决策边界是结果被分类为恶性和非良性的结果的概率。</p><p id="db35" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于非常低的决策边界，假阳性的数量非常高(这很直观，因为我们将一切都归类为恶性)。随着决策边界的上升，我们在 0.3 的决策边界处看到最初的几个假阴性。随着我们进一步深入，上升是缓慢的，直到 0.6 的决策边界，在那里我们看到大约 2%的假阴性率，在那之后急剧上升(如预期的)。因此，理想的决策边界位于 0.3 和 0.6 之间，尽管它可能因训练数据集的不同片段而改变。从这个网络中，对于 0.4 的判定边界，我们实现了大约 97.3%的准确度。</p><p id="f9a7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们只考虑假阴性的数量，很容易说我们应该将决策边界设为 0，但这将不再有用，因此我们将告诉每个人他们患有恶性癌症，这将使算法无用。因此，我们需要小心我们整体预测的质量以及关注的指标。</p><h1 id="28e2" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">解释模型的权重</h1><p id="73ac" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">生成重量分布图的一种简单方法是构建参数的轨迹图。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="2bbd" class="ne lf it na b gy nf ng l nh ni">trace = approx.sample(draws=5000)<br/>pm.traceplot(trace)</span></pre><figure class="mv mw mx my gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oi"><img src="../Images/db078dd05164b9024dbf91fd16cd453a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9YZsdzhbhblfUKj5MaaiYA.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">参数样本的轨迹图。来源:自己的工作</p></figure><p id="ed62" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，这不是一个非常清晰的可视化，但是我们可以从中获得一些见解:(在下一节中，我们将更深入地研究权重，并通过每个节点对它们进行剖析)</p><p id="66de" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">大多数权重被建模为高斯分布，这与我们之前的假设和初始分布非常吻合。</strong></p><p id="dc0a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后一组权重(w_2_out)是一组较小的分布，因为这是映射到感知器节点(做出最终决策的 sigmoid 曲线)的七个权重(来自最终层的七个神经元)。权重有一个平衡分布，这意味着对最终概率有正面和负面影响的分量数量相等。这些是经过两个隐藏层后的转换组件，所以很难谈论它们的“实际”意义，但可以认为它们是一个中间结果。</p><p id="25af" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些分布中的大多数在 w_2_out 中似乎与 0 有统计上的显著差异，除了在中间的几个。这意味着有一些特定组件的变换在统计上没有显著的权重，因此，它们对我们最终结果的影响并不显著。(作为一项带回家的任务，读者应尽量减少最后一层的神经元数量，以观察变化。)</p><p id="b006" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">w _ 1 _ 2 分析:</strong>这些权重代表了从第一层到第二层的成果映射。第一层有八个神经元，第二层有七个神经元。因此，这里的神经元总数是 8*7 = 56。(权重聚类的原因)。这些权重中的大部分似乎在<strong class="ki iu">统计上不显著</strong>(基于分布与 0 的重叠)，这表明第二层对于模型来说不像我们想象的那样信息丰富。</p><p id="03d6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一个重要的注意事项是，这里的权重分布更广。这意味着这些权重存在很大的不确定性。(这是在确定性神经网络中永远无法分辨的事情)</p><p id="2c8a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">w _ in _ 1 分析:</strong>这些权重表示数据到第一层八个节点上的映射。数据中有九个维度，第一层有八个神经元。因此，这里的神经元总数是 9*8 = 72。(权重聚类的原因)。在这种情况下，还存在权重统计不显著的问题。</p><p id="bffd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是这个分析需要更多的深度。让我们按每个节点分解权重并绘制它们。我们将使用以下代码获得每个重量的平均值和标准偏差:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="2e70" class="ne lf it na b gy nf ng l nh ni">means = approx.bij.rmap(approx.mean.eval())<br/>sds = approx.bij.rmap(approx.std.eval())</span></pre><h1 id="eea8" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">解释每个节点的权重</h1><p id="f5dc" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">对于第一个映射(w_in_1):</p><figure class="mv mw mx my gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oj"><img src="../Images/f29a6e9074b2ba5b06761a4fa4e50d84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yRlybinUNSboPGnpzY4Nwg.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">从数据到第一层映射的模型权重的分割分布。<strong class="bd nt">来源:</strong>自己的作品</p></figure><p id="a5a7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以从上图中获得以下见解:</p><ol class=""><li id="0a1a" class="mh mi it ki b kj kk kn ko kr mj kv mk kz ml ld mm mn mo mp bi translated">特征 2、3、4 和 5 具有大量统计上不显著的权重(平均值接近于 0)，因此，它们不会持续地影响模型中的方差。(这意味着它们的影响在某些情况下是积极的，在其他情况下是消极的)</li><li id="e583" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">特征 1、6、7 和 8 的权重具有更大的可变性和更小的不重要权重。因此，它们以更大的一致性(更可能停留在正面或负面)对模型的方差做出贡献。</li><li id="ed65" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">虽然大多数分布都一样宽(平均标准偏差为 1)，但特征 6 和 7 的分布似乎更宽。相反，特征 4 和 5 具有最平坦的曲线，具有较小的标准偏差。</li></ol><p id="05ce" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于第二个映射(w_1_2):</p><figure class="mv mw mx my gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oj"><img src="../Images/c76a9be74a1da4b95fe65667e5b57f67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yWGo3PthVSzBxURMnISiCw.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">从第一层到第二层映射的模型权重的分割分布。<strong class="bd nt">来源:</strong>自己的作品</p></figure><p id="be26" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以从上图中获得以下见解:</p><ol class=""><li id="fb00" class="mh mi it ki b kj kk kn ko kr mj kv mk kz ml ld mm mn mo mp bi translated">节点 2-6 具有大量统计上不显著的权重(平均值接近于 0)，因此，它们不会持续地影响模型中的方差。</li><li id="e3f6" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">其余节点的权重具有更大的可变性和更小的无关紧要的权重。因此，它们以更大的一致性(更可能停留在正面或负面)对模型的方差做出贡献。</li><li id="ef3d" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">特征 7 和 8 似乎是变化的最佳贡献者，而节点 4 似乎是最不相关的贡献者，大多数平均权重为 0。</li></ol><h1 id="23fb" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">根据此信息采取行动:</h1><p id="f106" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">通过理解第一层对数据建模的影响较小，而第二层的影响较大，我们可以得出两个结果:</p><ol class=""><li id="9d48" class="mh mi it ki b kj kk kn ko kr mj kv mk kz ml ld mm mn mo mp bi translated">减少一层网络以观察对权重一致性的影响是值得的。这可能有助于将差异合并到较少数量的更重要的节点中。</li><li id="7a34" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">减少节点的数量也是值得的，看看它是否有助于将差异合并到更少的节点中。</li></ol><h1 id="8fe6" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">最终要点:</h1><ol class=""><li id="a064" class="mh mi it ki b kj mc kn md kr ok kv ol kz om ld mm mn mo mp bi translated">使用该模型，我们能够在测试数据集上实现大约 97%的准确率。我们还能够了解这种准确性随不同决策边界的变化，并确定最适合我们目标的决策边界范围。</li><li id="807e" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">我们能够仔细检查神经网络中的每一个权重，以及每个节点权重的不确定性。这些信息有助于优化网络并增加模型的可靠性。</li></ol><h1 id="ec25" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">未来的改进:</h1><ol class=""><li id="fb88" class="mh mi it ki b kj mc kn md kr ok kv ol kz om ld mm mn mo mp bi translated">值得收集更大的数据集来提高我们模型的质量。如果首先没有足够的数据来分析，神经网络只能增加这么多的价值。</li><li id="93db" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">我们可以用多种激活函数和大小来增强神经网络，作为 A/B 测试，以找到最佳匹配。</li></ol><p id="fa12" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你想探索这个模型，我已经在这里的笔记本<a class="ae kf" href="https://github.com/sohitmiglani/MCMC-and-Variational-Inference/blob/master/Bayesian%20Deep%20Learning.ipynb" rel="noopener ugc nofollow" target="_blank">中将整个工作流程构建成一个易于使用的 Python 类。</a></p><p id="5dd2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您有任何问题或想要联系，我的 LinkedIn 个人资料是<a class="ae kf" href="https://www.linkedin.com/in/sohitmiglani/" rel="noopener ugc nofollow" target="_blank">这里。</a>在推特上联系我<a class="ae kf" href="https://twitter.com/sohitmiglani" rel="noopener ugc nofollow" target="_blank">这里。</a></p></div></div>    
</body>
</html>