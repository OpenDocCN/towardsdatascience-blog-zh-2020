<html>
<head>
<title>Let’s Deploy a Machine Learning Model</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们部署一个机器学习模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/lets-deploy-a-machine-learning-model-be6057f2d304?source=collection_archive---------18-----------------------#2020-06-26">https://towardsdatascience.com/lets-deploy-a-machine-learning-model-be6057f2d304?source=collection_archive---------18-----------------------#2020-06-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8db2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何在生产中使用机器学习模型</h2></div><p id="99d2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">数据科学太酷了，不能留在笔记本里。我们需要某种方法使模型对 web 应用程序有用，但是我们如何做到这一点呢？今天我们将训练一个简单的机器学习模型，并用<em class="le"> Flask </em>进行部署，然后用 Python 的<em class="le">请求</em>库进行预测。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/f5072c98e719909d71c2642bab134873.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DxjiXyNG8c6WhdYx"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">在<a class="ae lv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae lv" href="https://unsplash.com/@pawel_czerwinski?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">paweczerwiński</a>拍摄的照片</p></figure><p id="ff96" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你更喜欢视频，或者只是想巩固你的知识，请随意观看我们关于这个主题的视频。<a class="ae lv" href="https://github.com/betterdatascience/YouTube/tree/master/0002_MLDeploy" rel="noopener ugc nofollow" target="_blank">源代码</a>包含在内:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="57e1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">我为什么要关心部署？</em>好问题。让我用另一个问题来回答它:如果你不打算使用它，你的模型的目的是什么？或者至少让别人用？想不出任何理由？很好，我也是。</p><p id="b90c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">什么是烧瓶？</em> Flask 是一个开发 web 应用的微框架。我们不会为此使用它，但是我们将使用<em class="le"> Flask-RESTful </em>来公开我们模型的某些功能。</p><p id="b5d9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">好吧，但是什么是请求呢？这只是另一个与 REST APIs 通信的简单库。</p><p id="6b0f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">呃，什么是 REST API？REST 或表述性状态转移——无论哪个对您来说更自然——是一组用于创建 web 服务的样式和约束。一旦 Restful API 上线，我们就可以用特定的参数向特定的端点发出请求——这就是你现在应该知道的。这样做将执行一些后端逻辑——在我们的例子中是进行预测。</em></p><p id="c124" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是目录结构(可以随意调整):</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/6e741e69034b5deda2ba6014500b350e.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/format:webp/1*4uDPsTfws72XqIh4A822Ew.png"/></div></figure><p id="2eec" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">根目录叫做<em class="le"> mldeploy </em>，里面我们多了两个文件夹:<em class="le"> modeler </em>和<em class="le"> models </em>。第一个包含<em class="le"> modeler.py </em>文件(Python 创建了另外两个)，后者将包含一个保存的模型，一旦我们完成训练。</p><p id="2163" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，<em class="le"> app.py </em>将所有的东西绑在一起，并使用<em class="le"> Flask </em>和<em class="le"> Flask-RESTful </em>来暴露预测部分。</p><p id="8a04" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们做一个愚蠢的简单分类器。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="4618" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">制作分类器</h1><p id="9667" class="pw-post-body-paragraph ki kj it kk b kl my ju kn ko mz jx kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated">我们将使用著名的<a class="ae lv" href="https://raw.githubusercontent.com/uiuc-cse/data-fa14/gh-pages/data/iris.csv" rel="noopener ugc nofollow" target="_blank">虹膜数据集</a> <strong class="kk iu"> </strong>，因为对于这个例子，我们不能不关心任务的机器学习部分。我们只对模型如何部署感兴趣，而不是如何构建。</p><p id="f8cf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是进口货:</p><pre class="lg lh li lj gt nd ne nf ng aw nh bi"><span id="9852" class="ni mh it ne b gy nj nk l nl nm">import os<br/>import joblib<br/>import pandas as pd<br/>from sklearn.tree import DecisionTreeClassifier</span></pre><p id="181f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Joblib 可能是这里唯一的未知数。简而言之，我们可以用它来保存和加载机器学习模型。</p><p id="5f25" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们编写了一个用于模型加载、训练、保存和预测的类。这里不涉及数据准备，所以一切都归结为几行代码:</p><pre class="lg lh li lj gt nd ne nf ng aw nh bi"><span id="a20b" class="ni mh it ne b gy nj nk l nl nm">class Modeler:<br/>    def __init__(self):<br/>        self.df = pd.read_csv(‘https://raw.githubusercontent.com/uiuc-cse/data-fa14/gh-pages/data/iris.csv')<br/>        try: self.model = joblib.load(‘models/iris.model’)<br/>        except: self.model = None</span><span id="030c" class="ni mh it ne b gy nn nk l nl nm">    def fit(self):<br/>        X = self.df.drop(‘species’, axis=1)<br/>        y = self.df[‘species’]<br/>        self.model = DecisionTreeClassifier().fit(X, y)<br/>        joblib.dump(self.model, ‘models/iris.model’)</span><span id="761d" class="ni mh it ne b gy nn nk l nl nm">    def predict(self, measurement):<br/>        if not os.path.isfile(‘models/iris.model’):<br/>            raise Exception(‘Model not trained yet. Call .fit() before making predictions.’)<br/>        if len(measurement) != 4:<br/>            raise Exception(f’Expected sepal_length, sepal_width, petal_length, petal_width, got {measurement}’)</span><span id="67cb" class="ni mh it ne b gy nn nk l nl nm">        prediction = self.model.predict([measurement])<br/>        return prediction[0]</span></pre><p id="04c8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以上就是<em class="le"> modeler.py </em>的全部内容。我们将在下一节开发 API 本身。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="f7ca" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">REST API</h1><p id="b3e0" class="pw-post-body-paragraph ki kj it kk b kl my ju kn ko mz jx kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated">我们现在可以开始部署部分了。让我们打开<em class="le"> app.py </em>，执行几个导入操作:</p><pre class="lg lh li lj gt nd ne nf ng aw nh bi"><span id="5540" class="ni mh it ne b gy nj nk l nl nm">import os<br/>import joblib<br/>from flask import Flask, jsonify, request<br/>from flask_restful import Api, Resource<br/>from modeler.modeler import Modeler</span></pre><p id="4fec" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还将在这里使用<em class="le"> Joblib </em>，但是这次是为了加载训练好的模型。在底部，我们正在导入之前编写的<em class="le"> Modeler </em>类。现在让我们做一些<em class="le">烧瓶</em>内务处理:</p><pre class="lg lh li lj gt nd ne nf ng aw nh bi"><span id="50e9" class="ni mh it ne b gy nj nk l nl nm">app = Flask(__name__)<br/>api = Api(app)</span></pre><p id="c410" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le"> Flask-RESTful </em>的构造方式是每个端点都应该在自己的类中。在内部，我们声明了与最终用户发出的请求类型相对应的函数——最流行的是 GET 和 POST。</p><p id="eee2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本例中使用了 POST，一旦发出请求，我们将获取用户提供的数据。需要 4 个值:<em class="le">萼片长度、萼片宽度、花瓣长度</em>和<em class="le">花瓣宽度</em>，对应于我们数据集的特征。</p><p id="a35e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后创建一个<em class="le"> Modeler </em>类的实例，用提到的输入数据调用<em class="le"> predict() </em>函数。最后，返回预测的 JSON 表示。</p><p id="04df" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">听起来很简单吧？</em>因为是。代码如下:</p><pre class="lg lh li lj gt nd ne nf ng aw nh bi"><span id="b673" class="ni mh it ne b gy nj nk l nl nm">class Predict(Resource):<br/>    @staticmethod<br/>    def post():<br/>        data = request.get_json()<br/>        sepal_length = data[‘sepal_length’]<br/>        sepal_width = data[‘sepal_width’]<br/>        petal_length = data[‘petal_length’]<br/>        petal_width = data[‘petal_width’]</span><span id="3dd5" class="ni mh it ne b gy nn nk l nl nm">        m = Modeler()<br/>        if not os.path.isfile(‘models/iris.model’):<br/>            m.fit()</span><span id="ac18" class="ni mh it ne b gy nn nk l nl nm">        prediction = m.predict([sepal_length, sepal_width, petal_length, petal_width])</span><span id="e98f" class="ni mh it ne b gy nn nk l nl nm">        return jsonify({<br/>            ‘Input’: {<br/>                ‘SepalLength’: sepal_width,<br/>                ‘SepalWidth’: sepal_width,<br/>                ‘PetalLength’: petal_length,<br/>                ‘PetalWidth’: petal_width<br/>            },<br/>            ‘Class’: prediction<br/>        })</span></pre><p id="29ef" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们需要做更多的<em class="le"> Flask </em>内务处理，这实际上是将<em class="le"> Predict </em>类连接到一个端点——应该由<em class="le"> /predict </em>来完成:</p><pre class="lg lh li lj gt nd ne nf ng aw nh bi"><span id="37c1" class="ni mh it ne b gy nj nk l nl nm">api.add_resource(Predict, ‘/predict’)</span></pre><p id="6fed" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">代码方面的最后一件事是使<em class="le"> app.py </em>可执行:</p><pre class="lg lh li lj gt nd ne nf ng aw nh bi"><span id="4a0c" class="ni mh it ne b gy nj nk l nl nm">if __name__ == ‘__main__’:<br/>    app.run(debug=True)</span></pre><p id="a494" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们可以测试是否一切都像宣传的那样工作。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="1778" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">做预测</h1><p id="615d" class="pw-post-body-paragraph ki kj it kk b kl my ju kn ko mz jx kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated">先运行<em class="le"> app.py </em>吧。在“终端”中打开根文件夹，然后键入:</p><pre class="lg lh li lj gt nd ne nf ng aw nh bi"><span id="804c" class="ni mh it ne b gy nj nk l nl nm">python3 app.py</span></pre><p id="1a4d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者，如果您使用的是 Windows，则不带“3 ”:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi no"><img src="../Images/6328461a6960d6b014df75e553378080.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rY13XTfl3zvVzLzIRfX-7g.png"/></div></div></figure><p id="b6c8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">API 现在运行在<a class="ae lv" href="http://127.0.0.1:5000/." rel="noopener ugc nofollow" target="_blank"> http://127.0.0.1:5000/上。为了测试它是否正常工作，我们将使用笔记本——它们比代码编辑器更具交互性。</a></p><p id="f301" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们需要<em class="le">请求</em>库:</p><pre class="lg lh li lj gt nd ne nf ng aw nh bi"><span id="6766" class="ni mh it ne b gy nj nk l nl nm">import requests</span></pre><p id="8fb2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从这里我们可以向<em class="le"> /predict </em>端点发出 POST 请求，请求值为<em class="le">萼片长度</em>、<em class="le">萼片宽度、花瓣长度、</em>和<em class="le">花瓣宽度</em>。这很容易做到:</p><pre class="lg lh li lj gt nd ne nf ng aw nh bi"><span id="b5ac" class="ni mh it ne b gy nj nk l nl nm">res = requests.post(<br/>    url=’<a class="ae lv" href="http://localhost:5000/predict'" rel="noopener ugc nofollow" target="_blank">http://localhost:5000/predict'</a>,<br/>    json={<br/>        ‘sepal_length’: 5.0,<br/>        ‘sepal_width’: 3.2,<br/>        ‘petal_length’: 1.5,<br/>        ‘petal_width’: 0.3<br/>    }<br/>)</span></pre><p id="0101" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">酷毙了。我们可以检查<em class="le"> res </em>变量中的内容:</p><pre class="lg lh li lj gt nd ne nf ng aw nh bi"><span id="9ba5" class="ni mh it ne b gy nj nk l nl nm">res</span><span id="1a2b" class="ni mh it ne b gy nn nk l nl nm"><strong class="ne iu">&gt;&gt;&gt; &lt;Response [200]&gt;</strong></span></pre><p id="5fc1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">状态代码 200 表示一切正常，我们准备好提取预测了。对<em class="le"> res.json() </em>的调用完成了这个任务:</p><pre class="lg lh li lj gt nd ne nf ng aw nh bi"><span id="ebf2" class="ni mh it ne b gy nj nk l nl nm">res.json()</span><span id="2915" class="ni mh it ne b gy nn nk l nl nm"><strong class="ne iu">&gt;&gt;&gt; {‘Class’: ‘setosa’,<br/>     ‘Input’: {‘PetalLength’: 1.5,<br/>      ‘PetalWidth’: 0.3,<br/>      ‘SepalLength’: 3.2,<br/>      ‘SepalWidth’: 3.2}}</strong></span></pre><p id="df44" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">就是这样！你必须承认——这比你想象的要容易。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="7005" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">最后的话</h1><p id="cc2d" class="pw-post-body-paragraph ki kj it kk b kl my ju kn ko mz jx kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated">现在你知道如何采用任何机器学习模型并部署它。当然，我们在本地主机上做了所有的事情，但是在您的生产环境中，唯一会改变的主要部分是 URL。</p><p id="3e56" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以它不会是<a class="ae lv" href="http://127.0.0.1/predict," rel="noopener ugc nofollow" target="_blank">http://127 . 0 . 0 . 1:5000/predict，</a>而是类似于<a class="ae lv" href="http://your_url:port/predict." rel="noopener ugc nofollow" target="_blank">http://your _ URL:port/predict。</a></p><p id="6b2b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个模型现在已经可以在某种应用程序中使用了，希望通过一个漂亮的 GUI。比留在笔记本里好多了。</p><p id="f88d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢阅读。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><p id="0f63" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">喜欢这篇文章吗？成为</em> <a class="ae lv" href="https://medium.com/@radecicdario/membership" rel="noopener"> <em class="le">中等会员</em> </a> <em class="le">继续无限制学习。如果你使用下面的链接，我会收到你的一部分会员费，不需要你额外付费。</em></p><div class="np nq gp gr nr ns"><a href="https://medium.com/@radecicdario/membership" rel="noopener follow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd iu gy z fp nx fr fs ny fu fw is bi translated">通过我的推荐链接加入 Medium-Dario rade ci</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">medium.com</p></div></div><div class="ob l"><div class="oc l od oe of ob og lp ns"/></div></div></a></div></div></div>    
</body>
</html>