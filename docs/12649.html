<html>
<head>
<title>Custom Coloring Dendrogram Ends in R</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自定义着色树状图以 R 结尾</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/custom-coloring-dendrogram-ends-in-r-f1fa45e5077a?source=collection_archive---------45-----------------------#2020-08-31">https://towardsdatascience.com/custom-coloring-dendrogram-ends-in-r-f1fa45e5077a?source=collection_archive---------45-----------------------#2020-08-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/0c2cd5777acd738aca83ae68d7b3a28e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*IeY7vUllZxniY0J99DkV_A.png"/></div><p class="ju jv gj gh gi jw jx bd b be z dk translated">作者图片</p></figure><p id="1407" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">作为一名研究微生物群落数据的研究生，我从事的大多数项目都涉及某种聚类分析。对于其中的一个，我想用元数据中的一个变量来给一个树状图的两端着色，以可视化该变量是否作为另一个图形的一部分跟随聚类。R 中有一些优秀的包，比如<a class="ae kw" href="https://cran.r-project.org/web/packages/ggdendro/index.html" rel="noopener ugc nofollow" target="_blank"> ggdendro </a>，它允许您在树状图下绘制彩色条来表示组是如何聚类的，或者通过聚类本身来给终端段着色。</p><p id="175e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">也就是说，我仍然没有找到一种简单的方法来基于用户定义的元数据改变树状图本身的终端颜色，我个人认为在某些情况下这可能更美观。本教程描述了我是如何做到的，并提供了可复制的<a class="ae kw" href="https://github.com/mselensky/mselensky.github.io/blob/master/post/dendro-color/dendro_color_tutorial.R" rel="noopener ugc nofollow" target="_blank">代码</a>，如果你希望做同样的事情！</p><h1 id="ac46" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">树状图基础</h1><p id="6a35" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">在我开始之前，树状图到底是什么？</p><p id="6413" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">树状图是<a class="ae kw" href="https://www.statisticshowto.com/hierarchical-clustering/#:~:text=A%20dendrogram%20is%20a%20type,any%20type%20of%20grouped%20data" rel="noopener ugc nofollow" target="_blank">层次聚类</a>的图形表示。聚类可以以不同的方式构建(即自顶向下或自底向上)，最常见的是在 R 中通过在距离矩阵上应用<code class="fe ma mb mc md b">hclust()</code>。树状图是通过将节点连接到分支或其他节点来构建的，从而产生一个树状图形，该图形基于多个变量来显示各个事物如何相互关联。</p><p id="ee23" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设我们想要从众所周知的<a class="ae kw" href="https://www.rdocumentation.org/packages/datasets/versions/3.6.2/topics/iris" rel="noopener ugc nofollow" target="_blank"> R-core 数据集</a>中比较单个虹膜如何聚类。该数据帧包含四个数字向量(<code class="fe ma mb mc md b">Sepal.Length</code>、<code class="fe ma mb mc md b">Sepal.Width</code>、<code class="fe ma mb mc md b">Petal.Length</code>和<code class="fe ma mb mc md b">Petal.Width</code>)以及一个字符向量(<code class="fe ma mb mc md b">Species</code>)。我们可以很容易地构建并绘制一个包含所有这些以 R 为基数的数字数据的树状图，但是如果我们想根据鸢尾的种类对末端片段进行着色，以可视化物种是否遵循由<code class="fe ma mb mc md b">hclust()</code>确定的聚类呢？</p><h1 id="2501" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">步骤 1:安装软件包</h1><p id="8ea6" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">对于本教程，您需要加载三个 R 包:<code class="fe ma mb mc md b">tidyverse</code>用于数据操作和可视化，<code class="fe ma mb mc md b">ggdendro</code>用于将树状图分段数据提取到数据帧中，<code class="fe ma mb mc md b">RColorBrewer</code>用于为树状图末端制作自动定制调色板。如果你想让你的树状图具有交互性，一定要加载<code class="fe ma mb mc md b">plotly</code>。</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="471e" class="mm ky iq md b gy mn mo l mp mq">pacman::p_load(tidyverse, ggdendro, RColorBrewer, plotly)</span></pre><h1 id="4963" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">步骤 2:加载数据</h1><p id="1392" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">现在我们要将<code class="fe ma mb mc md b">iris</code>数据帧加载到我们的环境中。作为生物信息学家，我们通常有映射到每个观察结果的样本名称，所以我们希望从一开始就创建自己的名称(<code class="fe ma mb mc md b">sample_name</code>)。</p><p id="c998" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有了微生物群落数据，我的工作流程本质上涉及两个对象:一个巨大的 ASV 矩阵(扩增子序列变体；该术语用于描述基于<code class="fe ma mb mc md b">sample_name</code>的 DNA 序列相似性)丰度的分类，以及与每个样本相关的元数据。为了模拟这一点，我们将把<code class="fe ma mb mc md b">iris</code>分成<code class="fe ma mb mc md b">numeric_data</code>和<code class="fe ma mb mc md b">metadata</code>，根据 T8，我们将计算距离并构建一个树状图，为了我们的目的，T9 将简单地包含每个<code class="fe ma mb mc md b">sample_name</code>的鸢尾种类。对于这个工作流，每个观察都有一个<code class="fe ma mb mc md b">sample_name</code>标识符是很重要的；它将是最后融合一切的基础。</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="c9ac" class="mm ky iq md b gy mn mo l mp mq"># label rows with unique sample_name<br/>dat &lt;- iris %&gt;%<br/> mutate(sample_name = paste(“iris”, seq(1:nrow(iris)), sep = “_”)) # create unique sample ID</span><span id="ff93" class="mm ky iq md b gy mr mo l mp mq"># save non-numeric metadata in separate dataframe<br/>metadata &lt;- dat %&gt;%<br/> select(sample_name, Species)</span><span id="08d0" class="mm ky iq md b gy mr mo l mp mq"># extract numeric vectors for distance matrix<br/>numeric_data &lt;- dat %&gt;%<br/> select(Sepal.Length, Sepal.Width, Petal.Length, Petal.Width, sample_name)</span><span id="6cb1" class="mm ky iq md b gy mr mo l mp mq"># check data <br/>head(numeric_data)</span></pre><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi ms"><img src="../Images/69b44a7b32527c095bb68e0adc6adeac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*siuePqk2ED2fnMDOKwRtww.png"/></div></div><p class="ju jv gj gh gi jw jx bd b be z dk translated">作者图片</p></figure><h1 id="75b3" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">步骤 3:标准化数据并创建树状图</h1><p id="cfb4" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">在我们制作树状图之前，我们将使用<code class="fe ma mb mc md b">dist()</code>基于<code class="fe ma mb mc md b">numeric_data</code>计算一个距离矩阵。在进行此计算之前，最好对数据进行标准化处理；因此，我将在 0 到 1 的范围内对向量中的所有值进行归一化。</p><p id="617f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这样做之后，我们可以创建一个距离矩阵(<code class="fe ma mb mc md b">dist_matrix</code>)并从我们的标准化数据中生成一个<code class="fe ma mb mc md b">dendrogram</code>。</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="8af1" class="mm ky iq md b gy mn mo l mp mq"># normalize data to values from 0 to 1 <br/>numeric_data_norm &lt;- numeric_data %&gt;%<br/> select(sample_name, everything()) %&gt;%<br/> pivot_longer(cols = 2:ncol(.), values_to = “value”, names_to = “type”) %&gt;%<br/> group_by(type) %&gt;%<br/> mutate(value_norm = (value-min(value))/(max(value)-min(value))) %&gt;% # normalize data to values 0–1<br/> select(sample_name, value_norm) %&gt;%<br/> pivot_wider(names_from = “type”, values_from = “value_norm”) %&gt;%<br/> column_to_rownames(“sample_name”)</span><span id="4ba9" class="mm ky iq md b gy mr mo l mp mq"># create dendrogram from distance matrix of normalized data<br/>dist_matrix &lt;- dist(numeric_data_norm, method = “euclidean”)<br/>dendrogram &lt;- as.dendrogram(hclust(dist_matrix, method = “complete”))</span></pre><h1 id="7776" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">步骤 4:使用 ggdendro 提取树状图片段数据</h1><p id="2032" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">现在让我们快速地看一下使用基数 R 时我们的树状图是什么样子的:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="c3cc" class="mm ky iq md b gy mn mo l mp mq">plot(dendrogram)</span></pre><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi mx"><img src="../Images/47a11fc1522e4bfafa88ac88c880f391.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3XN9_Vbj13q49v1mpTDZkw.png"/></div></div><p class="ju jv gj gh gi jw jx bd b be z dk translated">作者图片</p></figure><p id="6cc5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好吧，它不是很漂亮，但是请原谅我。这是一个有用的视图，展示了我们将如何使用<code class="fe ma mb mc md b">ggdendro::dendro_data()</code>从树状图对象中提取坐标数据，以生成一个更好的图形。每个树状图都是通过在 x 和 y 网格上的点之间添加单独的线段来绘制的。</p><p id="cfb5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们应用<code class="fe ma mb mc md b">dendro_data()</code>并查看提取的分段数据时，我们看到每个树状图有四个向量:<code class="fe ma mb mc md b">x</code>、<code class="fe ma mb mc md b">y</code>、<code class="fe ma mb mc md b">xend</code>和<code class="fe ma mb mc md b">yend</code>。您在基数 R 图中看到的每条水平线或垂直线最终都是由以下数据帧中的一行构成的:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="90a8" class="mm ky iq md b gy mn mo l mp mq"># extract dendrogram segment data<br/>dendrogram_data &lt;- dendro_data(dendrogram)<br/>dendrogram_segments &lt;- dendrogram_data$segments # contains all dendrogram segment data</span><span id="49a2" class="mm ky iq md b gy mr mo l mp mq">head(dendrogram_segments)</span></pre><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi my"><img src="../Images/b42e6e5464ecefac80877b15eb2f8bd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bao_B9baqvQgkLZZeu6v2Q.png"/></div></div><p class="ju jv gj gh gi jw jx bd b be z dk translated">作者图片</p></figure><p id="1549" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将把这些坐标数据分成两个数据帧:<code class="fe ma mb mc md b">dendrogram_segments</code>，包含所有线段，和<code class="fe ma mb mc md b">dendrogram_ends</code>，仅包含图形的终端分支。如上图所示，当 y 方向的值为 0(即<code class="fe ma mb mc md b">yend == 0</code>)时，仅包括图底部的单个线段:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="0fb8" class="mm ky iq md b gy mn mo l mp mq"># get terminal dendrogram segments<br/>dendrogram_ends &lt;- dendrogram_segments %&gt;%<br/> filter(yend == 0) %&gt;% # filter for terminal dendrogram ends<br/> left_join(dendrogram_data$labels, by = “x”) %&gt;% # .$labels contains the row names from dist_matrix (i.e., sample_name)<br/> rename(sample_name = label) %&gt;%<br/> left_join(metadata, by = “sample_name”) </span><span id="3ce0" class="mm ky iq md b gy mr mo l mp mq"># dataframe now contains only terminal dendrogram segments and merged metadata associated with each iris</span></pre><p id="746c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">查看<code class="fe ma mb mc md b">dendrogram_ends</code>，我们现在有一个数据帧，其中包含与<code class="fe ma mb mc md b">sample_name</code>和<code class="fe ma mb mc md b">Species</code>向量匹配的树状图坐标数据。我们现在准备在<code class="fe ma mb mc md b">ggplot2</code>开始绘图！</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="054f" class="mm ky iq md b gy mn mo l mp mq">head(dendrogram_ends)</span></pre><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi mz"><img src="../Images/98cc80b106605bc94134209e72b7b64b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RWBTY-ApOGbqJ3Ke--VvHw.png"/></div></div><p class="ju jv gj gh gi jw jx bd b be z dk translated">作者图片</p></figure><h1 id="7f18" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">步骤 5:使用 RColorBrewer(可选)基于元数据变量为树状图末端生成自定义调色板</h1><p id="fa2c" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">如果您想要基于感兴趣的元数据向量包含多少唯一变量来动态创建颜色列表，您可以运行以下代码。在这个例子中，我们的<code class="fe ma mb mc md b">metadata</code>只包含三种鸢尾，所以这可以相当快地手动完成。但是，如果数据集中的唯一元数据变量的数量超过这个数目，就像微生物群落数据中常见的那样，那么您可能希望自动执行这个过程。</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="b023" class="mm ky iq md b gy mn mo l mp mq"># Generate custom color palette for dendrogram ends based on metadata variable</span><span id="5223" class="mm ky iq md b gy mr mo l mp mq">unique_vars &lt;- levels(factor(dendrogram_ends$Species)) %&gt;% <br/> as.data.frame() %&gt;% rownames_to_column(“row_id”) </span><span id="583c" class="mm ky iq md b gy mr mo l mp mq"># count number of unique variables<br/>color_count &lt;- length(unique(unique_vars$.))</span><span id="b04d" class="mm ky iq md b gy mr mo l mp mq"># get RColorBrewer palette<br/>get_palette &lt;- colorRampPalette(brewer.pal(n = 8, name = “Set1”))</span><span id="ee53" class="mm ky iq md b gy mr mo l mp mq"># produce RColorBrewer palette based on number of unique variables in metadata:<br/>palette &lt;- get_palette(color_count) %&gt;% <br/> as.data.frame() %&gt;%<br/> rename(“color” = “.”) %&gt;%<br/> rownames_to_column(var = “row_id”)<br/>color_list &lt;- left_join(unique_vars, palette, by = “row_id”) %&gt;%<br/> select(-row_id)<br/>species_color &lt;- as.character(color_list$color)<br/>names(species_color) &lt;- color_list$.</span></pre><p id="9dd2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您不想在本教程中使用上述代码，您可以手动创建一个命名的字符向量作为替代:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="2ff4" class="mm ky iq md b gy mn mo l mp mq"># Alternatively, create a custom named vector for iris species color:</span><span id="9181" class="mm ky iq md b gy mr mo l mp mq">species_color &lt;- c(“setosa” = “#E41A1C”, “versicolor” = “#CB6651”, “virginica” = “#F781BF”)</span></pre><h1 id="8041" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">第 6 步:绘制自定义颜色的树状图！</h1><p id="72de" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">现在是时候绘制我们的树状图了！您将需要为<code class="fe ma mb mc md b">geom_segment</code>定义两个几何图形:一个绘制从步骤 4 中提取的所有未着色的分段数据，另一个仅绘制树状图的末端分支，这是我们将在上一步骤中用<code class="fe ma mb mc md b">species_color</code>着色的部分。如果你用<code class="fe ma mb mc md b">plotly</code>(见下文)包装这个图，我建议增加一个额外的<code class="fe ma mb mc md b">text</code>美学来控制哪些信息将显示在你的输出上。</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="69bd" class="mm ky iq md b gy mn mo l mp mq">p &lt;- ggplot() +<br/> geom_segment(data = dendrogram_segments, <br/> aes(x=x, y=y, xend=xend, yend=yend)) +<br/> geom_segment(data = dendrogram_ends,<br/> aes(x=x, y=y.x, xend=xend, yend=yend, color = Species, text = paste(‘sample name: ‘, sample_name,<br/> ‘&lt;br&gt;’,<br/> ‘species: ‘, Species))) + # test aes is for plotly<br/> scale_color_manual(values = species_color) +<br/> scale_y_reverse() +<br/> coord_flip() + theme_bw() + theme(legend.position = “none”) + ylab(“Distance”) + # flipped x and y coordinates for aesthetic reasons<br/> ggtitle(“Iris dendrogram”)<br/> <br/>p</span></pre><figure class="me mf mg mh gt jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/0c2cd5777acd738aca83ae68d7b3a28e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*IeY7vUllZxniY0J99DkV_A.png"/></div><p class="ju jv gj gh gi jw jx bd b be z dk translated">作者图片</p></figure><p id="0ead" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你想变得更有趣，你可以用<a class="ae kw" href="https://plotly.com/r/" rel="noopener ugc nofollow" target="_blank"> plotly </a>包装你的 ggplot，使你的树状图具有交互性！确保指定<code class="fe ma mb mc md b">tooltip = “text”</code>来控制显示哪些信息。</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="c272" class="mm ky iq md b gy mn mo l mp mq">ggplotly(p, tooltip = “text”)</span></pre><p id="43c5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在你已经知道了——树图的末端由元数据中的一个变量动态着色！正如我们所看到的，iris 的种类似乎遵循由<code class="fe ma mb mc md b">hclust()</code>确定的层次聚类，这可以通知您在探索性分析管道中完成的进一步测试。</p></div></div>    
</body>
</html>