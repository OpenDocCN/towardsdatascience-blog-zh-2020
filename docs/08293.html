<html>
<head>
<title>Part 6: Matrix Profiles for Streaming Time Series Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第 6 部分:流式时间序列数据的矩阵轮廓</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/matrix-profiles-for-streaming-time-series-data-f877ff6f9eef?source=collection_archive---------41-----------------------#2020-06-17">https://towardsdatascience.com/matrix-profiles-for-streaming-time-series-data-f877ff6f9eef?source=collection_archive---------41-----------------------#2020-06-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="87db" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用 STUMPY 使用在线数据逐步更新您的矩阵档案</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/21477c881b0ce47506d56c9e1111eed8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V3mAHO-JLpBHb8UCjZT1Sg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">(图片由<a class="ae kv" href="https://unsplash.com/@jfobranco?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">若昂·布兰科</a>提供)</p></figure><h1 id="1119" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">整体大于部分之和</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi lo"><img src="../Images/187c6f161c2bd22a0bb7eaaba6e15a55.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/0*0OFZM4y8UyA0l9wA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">(图片由作者提供)</p></figure><p id="a9b4" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated"><a class="ae kv" href="https://github.com/TDAmeritrade/stumpy" rel="noopener ugc nofollow" target="_blank"> STUMPY 是一个强大且可扩展的 Python 库，用于现代时间序列分析</a>，在其核心，有效地计算出一种叫做<em class="ml">矩阵轮廓</em>的东西。这个多部分系列的目标是解释什么是 matrix profile，以及如何开始利用<a class="ae kv" href="https://stumpy.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> STUMPY </a>完成所有现代时间序列数据挖掘任务！</p><p id="1316" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated"><em class="ml">注:这些教程最初出现在</em> <a class="ae kv" href="https://stumpy.readthedocs.io/en/latest/tutorials.html" rel="noopener ugc nofollow" target="_blank"> <em class="ml"> STUMPY 文档</em> </a> <em class="ml">中。</em></p><p id="50ce" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">第一部分:<a class="ae kv" rel="noopener" target="_blank" href="/the-matrix-profile-e4a679269692">矩阵轮廓图</a> <br/>第二部分:<a class="ae kv" rel="noopener" target="_blank" href="/stumpy-basics-21844a2d2d92"> STUMPY 基础知识</a> <br/>第三部分:<a class="ae kv" rel="noopener" target="_blank" href="/part-3-time-series-chains-da281450abbf">时间序列链</a> <br/>第四部分:<a class="ae kv" rel="noopener" target="_blank" href="/part-4-semantic-segmentation-b42c3792833d">语义分割</a> <br/>第五部分:<a class="ae kv" rel="noopener" target="_blank" href="/part-5-fast-approximate-matrix-profiles-with-scrump-c6d9c984c560">快速近似矩阵轮廓图与 STUMPY </a> <br/>第六部分:<a class="ae kv" rel="noopener" target="_blank" href="/matrix-profiles-for-streaming-time-series-data-f877ff6f9eef">用于流式时间序列数据的矩阵轮廓图</a> <br/>第七部分:<a class="ae kv" rel="noopener" target="_blank" href="/part-7-fast-pattern-searching-with-stumpy-2baf610a8de1">快速模式搜索与 STUMPY </a> <br/>第八部分:【T2 10: <a class="ae kv" rel="noopener" target="_blank" href="/part-10-discovering-multidimensional-time-series-motifs-45da53b594bb">发现多维时间序列模体</a> <br/>第十一部分:<a class="ae kv" rel="noopener" target="_blank" href="/part-11-user-guided-motif-search-d3d317caf9ea">用户引导的模体搜索</a> <br/>第十二部分:<a class="ae kv" rel="noopener" target="_blank" href="/part-12-matrix-profiles-for-machine-learning-2dfd98d7ff3f">机器学习的矩阵轮廓</a></p><h1 id="7f21" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">用于流时间序列数据的增量矩阵轮廓</h1><p id="4902" class="pw-post-body-paragraph lp lq iq lr b ls mm jr lu lv mn ju lx ly mo ma mb mc mp me mf mg mq mi mj mk ij bi translated">现在，您已经对如何计算矩阵配置文件有了基本的了解，在这个简短的教程中，我们将演示当您有流(在线)数据时，如何使用<code class="fe mr ms mt mu b">stumpy.stumpi()</code>(“STUMP Incremental”)函数增量更新您的矩阵配置文件。您可以通过阅读<a class="ae kv" href="https://www.cs.ucr.edu/~eamonn/PID4481997_extend_Matrix%20Profile_I.pdf" rel="noopener ugc nofollow" target="_blank">矩阵档案 I </a>文件的 G 部分以及本文件的第 4.6 部分和表 5 <a class="ae kv" href="https://www.cs.ucr.edu/~eamonn/ten_quadrillion.pdf" rel="noopener ugc nofollow" target="_blank">来了解有关该方法的更多详细信息。</a></p><h1 id="8dfb" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">入门指南</h1><p id="ea3f" class="pw-post-body-paragraph lp lq iq lr b ls mm jr lu lv mn ju lx ly mo ma mb mc mp me mf mg mq mi mj mk ij bi translated">让我们导入创建和分析随机生成的时间序列数据集所需的包。</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="54e7" class="mz kx iq mu b gy na nb l nc nd">import numpy as np<br/>import stumpy<br/>import numpy.testing as npt<br/>import time</span></pre><h1 id="f401" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">生成一些随机时间序列数据</h1><p id="bd82" class="pw-post-body-paragraph lp lq iq lr b ls mm jr lu lv mn ju lx ly mo ma mb mc mp me mf mg mq mi mj mk ij bi translated">想象一下，我们有一个<a class="ae kv" href="https://en.wikipedia.org/wiki/Internet_of_things" rel="noopener ugc nofollow" target="_blank">物联网</a>传感器，它在过去 14 天里每小时收集一次数据。这意味着到目前为止我们已经积累了<code class="fe mr ms mt mu b">14 * 24 = 336</code>个数据点，我们的数据集可能如下所示:</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="0364" class="mz kx iq mu b gy na nb l nc nd">T = np.random.rand(336)</span></pre><p id="bfc6" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">或许，我们从经验中知道，在 12 小时(滑动)的时间窗口内，可以检测到一个有趣的主题或异常:</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="717f" class="mz kx iq mu b gy na nb l nc nd">m = 12</span></pre><h1 id="a769" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">典型批量分析</h1><p id="f3d1" class="pw-post-body-paragraph lp lq iq lr b ls mm jr lu lv mn ju lx ly mo ma mb mc mp me mf mg mq mi mj mk ij bi translated">使用<code class="fe mr ms mt mu b">stumpy.stump()</code>通过批处理直接计算矩阵分布图:</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="768f" class="mz kx iq mu b gy na nb l nc nd">mp = stumpy.stump(T, m)</span></pre><p id="3f4d" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">但是随着<code class="fe mr ms mt mu b">T</code>的长度随着时间的推移而增长，计算矩阵轮廓将花费越来越多的时间，因为<code class="fe mr ms mt mu b">stumpy.stump()</code>将实际上重新计算时间序列内所有子序列之间的所有成对距离。这个超级耗时！相反，对于流数据，我们希望找到一种方法来获取新的传入(单个)数据点，并将它所在的子序列与时间序列的其余部分进行比较(即，计算距离轮廓)并更新现有的矩阵轮廓。幸运的是，这可以通过<code class="fe mr ms mt mu b">stumpy.stumpi()</code>或“残肢增量”轻松实现。</p><h1 id="33d4" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">用 STUMPI 进行流式(在线)分析</h1><p id="e218" class="pw-post-body-paragraph lp lq iq lr b ls mm jr lu lv mn ju lx ly mo ma mb mc mp me mf mg mq mi mj mk ij bi translated">当我们等待下一个数据点<code class="fe mr ms mt mu b">t</code>到来时，我们可以用现有的数据初始化我们的流对象:</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="8b5e" class="mz kx iq mu b gy na nb l nc nd">stream = stumpy.stumpi(T, m)</span></pre><p id="b075" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">并且当新的数据点<code class="fe mr ms mt mu b">t</code>到达时:</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="fe03" class="mz kx iq mu b gy na nb l nc nd">t = np.random.rand()</span></pre><p id="f6f7" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">我们可以将<code class="fe mr ms mt mu b">t</code>添加到<code class="fe mr ms mt mu b">stream</code>中，并在后台轻松更新矩阵配置文件、<code class="fe mr ms mt mu b">P</code>和矩阵配置文件索引、<code class="fe mr ms mt mu b">I</code>:</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="9c40" class="mz kx iq mu b gy na nb l nc nd">stream.update(t)</span></pre><p id="9d89" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">在后台，<code class="fe mr ms mt mu b">t</code>已被附加到现有的时间序列中，它自动将新的子序列与所有现有的子序列进行比较，并更新历史值。它还确定现有子序列中的哪一个是新子序列的最近邻居，并将该信息附加到矩阵简档。随着额外数据的流入，这可以继续进行，比如说，再进行 1000 次迭代(或无限期地):</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="61f1" class="mz kx iq mu b gy na nb l nc nd">for i in range(1000):<br/>    t = np.random.rand()<br/>    stream.update(t)</span></pre><p id="e15f" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">重要的是要重申，增量<code class="fe mr ms mt mu b">stumpy.stumpi()</code>与批量<code class="fe mr ms mt mu b">stumpy.stump()</code>不同，它不会浪费任何时间来重新计算任何过去的成对距离。<code class="fe mr ms mt mu b">stumpy.stumpi()</code>只花时间计算新的距离，然后在必要时更新适当的数组，因此，它真的很快！</p><h1 id="5912" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">验证矩阵配置文件</h1><p id="1200" class="pw-post-body-paragraph lp lq iq lr b ls mm jr lu lv mn ju lx ly mo ma mb mc mp me mf mg mq mi mj mk ij bi translated">现在，这种用流(在线)数据“快速更新”的说法可能感觉奇怪或不可思议，因此，首先，让我们验证增量<code class="fe mr ms mt mu b">stumpy.stumpi()</code>的输出与执行批处理<code class="fe mr ms mt mu b">stumpy.stump()</code>的输出相同。让我们从具有<code class="fe mr ms mt mu b">64</code>数据点的完整时间序列开始，并计算完整的矩阵轮廓:</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="d7c1" class="mz kx iq mu b gy na nb l nc nd">T_full = np.random.rand(64)<br/>m = 8</span><span id="654d" class="mz kx iq mu b gy ne nb l nc nd">mp = stumpy.stump(T_full, m)<br/>P_full = mp[:, 0]<br/>I_full = mp[:, 1]</span></pre><p id="3cf2" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">接下来，对于<code class="fe mr ms mt mu b">stumpy.stumpi()</code>，我们将只从全长时间序列中的第一个<code class="fe mr ms mt mu b">10</code>元素开始，然后一次一个地增加额外的数据点:</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="0b94" class="mz kx iq mu b gy na nb l nc nd"># Start with half of the full length time series and initialize inputs<br/>T_stream = T_full[:10].copy()<br/>stream = stumpy.stumpi(T_stream, m)</span><span id="3cce" class="mz kx iq mu b gy ne nb l nc nd"># Incrementally add one new data point at a time and update the matrix profile<br/>for i in range(len(T_stream), len(T_full)):<br/>    t = T_full[i]<br/>    stream.update(t)</span></pre><p id="2721" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">现在我们已经完成了，让我们检查并验证一下:</p><ol class=""><li id="3e5d" class="nf ng iq lr b ls lt lv lw ly nh mc ni mg nj mk nk nl nm nn bi translated"><code class="fe mr ms mt mu b">stream.T == T_full</code></li><li id="53cf" class="nf ng iq lr b ls no lv np ly nq mc nr mg ns mk nk nl nm nn bi translated"><code class="fe mr ms mt mu b">stream.P == P_full</code></li><li id="6c28" class="nf ng iq lr b ls no lv np ly nq mc nr mg ns mk nk nl nm nn bi translated"><code class="fe mr ms mt mu b">stream.I == I_full</code></li></ol><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="a87b" class="mz kx iq mu b gy na nb l nc nd">npt.assert_almost_equal(stream.T_, T_full)<br/>npt.assert_almost_equal(stream.P_, P_full)<br/>npt.assert_almost_equal(stream.I_, I_full)</span></pre><p id="b979" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">没有错误，它们都匹配！因此，这意味着<code class="fe mr ms mt mu b">stump.stumpi()</code>确实产生了我们所期望的正确矩阵分析结果。</p><h1 id="95c4" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">验证性能</h1><p id="27cc" class="pw-post-body-paragraph lp lq iq lr b ls mm jr lu lv mn ju lx ly mo ma mb mc mp me mf mg mq mi mj mk ij bi translated">我们基本上声称，当每个新数据点到达时，用<code class="fe mr ms mt mu b">stumpy.stumpi()</code>增量更新我们的矩阵轮廓比用<code class="fe mr ms mt mu b">stumpy.stump</code>执行完整的成对距离计算要快得多(在总计算时间上)。让我们实际比较一下时间，取一个完整的时间序列，长度为 1，000 个数据点，我们用时间序列的前 20%(即前 200 个点)初始化这两种方法，并在每次迭代时附加一个新的数据点，然后重新计算矩阵轮廓:</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="a019" class="mz kx iq mu b gy na nb l nc nd">T_full = np.random.rand(1000)<br/>T_stream = T_full[:200].copy()<br/>m = 10</span><span id="d1c1" class="mz kx iq mu b gy ne nb l nc nd"># `stumpy.stump` timing<br/>start = time.time()<br/>mp = stumpy.stump(T_stream, m)<br/>for i in range(200, len(T_full)):<br/>    T_stream = np.append(T_stream, T_full[i])<br/>    mp = stumpy.stump(T_stream, m)<br/>stump_time = time.time() - start</span><span id="901c" class="mz kx iq mu b gy ne nb l nc nd"># `stumpy.stumpi` timing<br/>start = time.time()<br/>stream = stumpy.stumpi(T_stream, m)<br/>for i in range(200, len(T_full)):<br/>    t = T_full[i]<br/>    stream.update(t)<br/>stumpi_time = time.time() - start</span><span id="ed45" class="mz kx iq mu b gy ne nb l nc nd">print(f"stumpy.stump: {np.round(stump_time,1)}s")<br/>print(f"stumpy.stumpi:, {np.round(stumpi_time, 1)}s")</span><span id="75cd" class="mz kx iq mu b gy ne nb l nc nd">stumpy.stump: 429.9s<br/>stumpy.stumpi:, 3.4s</span></pre><p id="03f3" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">撇开拥有更多 CPU 将加速这两种方法的事实不谈，我们清楚地看到，对于处理流数据，增量<code class="fe mr ms mt mu b">stumpy.stumpi()</code>比批量<code class="fe mr ms mt mu b">stumpy.stump()</code>快几个数量级。事实上，对于当前的硬件，平均来说，<code class="fe mr ms mt mu b">stumpy.stump()</code>分析每个新矩阵配置文件大约需要半秒钟。因此，如果每半秒钟就有一个新的数据点到达，那么您将无法跟上。相比之下，<code class="fe mr ms mt mu b">stumpy.stumpi()</code>应该能够使用相当适中的硬件轻松处理每秒 300 多个新数据点。此外，计算复杂度为<code class="fe mr ms mt mu b">O(n^2)</code>的批处理<code class="fe mr ms mt mu b">stumpy.stump()</code>将会变得更慢，因为越来越多的数据点被附加到现有的时间序列，而<code class="fe mr ms mt mu b">stumpy.stumpi()</code>，本质上是<code class="fe mr ms mt mu b">O(1)</code>，将继续保持高性能。</p><h1 id="238b" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">直观的例子</h1><p id="2f18" class="pw-post-body-paragraph lp lq iq lr b ls mm jr lu lv mn ju lx ly mo ma mb mc mp me mf mg mq mi mj mk ij bi translated">现在，我们已经了解了如何使用流数据计算和更新我们的矩阵轮廓，让我们用一个真实的示例数据集来探索这个问题，其中有一个已知的模式，并看看<code class="fe mr ms mt mu b">stumpy.stumpi()</code>是否能够正确识别何时遇到全局基序(模式)。</p><h1 id="b8f8" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">检索和加载数据</h1><p id="0b29" class="pw-post-body-paragraph lp lq iq lr b ls mm jr lu lv mn ju lx ly mo ma mb mc mp me mf mg mq mi mj mk ij bi translated">首先让我们导入一些额外的 Python 包，然后检索我们的标准“Steamgen 数据集”:</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="5b50" class="mz kx iq mu b gy na nb l nc nd">%matplotlib inline<br/><br/>import pandas as pd<br/>import stumpy<br/>import numpy as np<br/>import matplotlib.pyplot as plt<br/>from matplotlib.patches import Rectangle<br/>from matplotlib import animation<br/>from IPython.display import HTML<br/>import os<br/><br/>plt.rcParams["figure.figsize"] = [20, 6]  # width, height<br/>plt.rcParams['xtick.direction'] = 'out'<br/><br/>steam_df = pd.read_csv("https://zenodo.org/record/4273921/files/STUMPY_Basics_steamgen.csv?download=1")<br/>steam_df.head()</span><span id="87f8" class="mz kx iq mu b gy ne nb l nc nd">drum pressure  excess oxygen  water level  steam flow<br/>    320.08239       2.506774     0.032701    9.302970<br/>   1321.71099       2.545908     0.284799    9.662621<br/>   2320.91331       2.360562     0.203652   10.990955 <br/>   3325.00252       0.027054     0.326187   12.430107<br/>   4326.65276       0.285649     0.753776   13.681666</span></pre><p id="2ec8" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">该数据是使用模糊模型生成的，该模型用于模拟位于伊利诺伊州香槟市的 Abbott 电厂的蒸汽发生器。我们感兴趣的数据特性是输出蒸汽流量遥测，单位为 kg/s，数据每三秒“采样”一次，共有 9600 个数据点。</p><p id="ab19" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">下面突出显示了我们正在寻找的主题(模式),但是仍然很难确定橙色和绿色的子序列是否匹配，也就是说，直到我们放大它们并将子序列重叠在彼此之上。</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="0381" class="mz kx iq mu b gy na nb l nc nd">m = 640<br/>fig, axs = plt.subplots(2)<br/>plt.suptitle('Steamgen Dataset', fontsize='30')<br/>axs[0].set_ylabel("Steam Flow", fontsize='20')<br/>axs[0].plot(steam_df['steam flow'], alpha=0.5, linewidth=1)<br/>axs[0].plot(steam_df['steam flow'].iloc[643:643+m])<br/>axs[0].plot(steam_df['steam flow'].iloc[8724:8724+m])<br/>rect = Rectangle((643, 0), m, 40, facecolor='lightgrey')<br/>axs[0].add_patch(rect)<br/>rect = Rectangle((8724, 0), m, 40, facecolor='lightgrey')<br/>axs[0].add_patch(rect)<br/>axs[1].set_xlabel("Time", fontsize='20')<br/>axs[1].set_ylabel("Steam Flow", fontsize='20')<br/>axs[1].plot(steam_df['steam flow'].values[643:643+m], color='C1')<br/>axs[1].plot(steam_df['steam flow'].values[8724:8724+m], color='C2')</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/cf75c81f6e922b85106966ca2ce39bac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qe1BWuLugZLW1iwi.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">(图片由作者提供)</p></figure><p id="e0dc" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">现在，我们可以清楚地看到，母题非常相似！</p><h1 id="b589" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">使用 STUMPI</h1><p id="8dba" class="pw-post-body-paragraph lp lq iq lr b ls mm jr lu lv mn ju lx ly mo ma mb mc mp me mf mg mq mi mj mk ij bi translated">现在，让我们看看当我们用前 2000 个数据点初始化<code class="fe mr ms mt mu b">stumpy.stumpi()</code>时，矩阵轮廓会发生什么变化:</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="29dd" class="mz kx iq mu b gy na nb l nc nd">T_full = steam_df['steam flow'].values<br/>T_stream = T_full[:2000]<br/>stream = stumpy.stumpi(T_stream, m)</span></pre><p id="cc00" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">然后递增地添加新的数据点并更新我们的结果:</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="d09e" class="mz kx iq mu b gy na nb l nc nd">windows = [(stream.P_, T_stream)]<br/>P_max = -1<br/>for i in range(2000, len(T_full)):<br/>    t = T_full[i]<br/>    stream.update(t)</span><span id="93a2" class="mz kx iq mu b gy ne nb l nc nd">    if i % 50 == 0:<br/>        windows.append((stream.P_, T_full[:i+1]))<br/>        if stream.P_.max() &gt; P_max:<br/>            P_max = stream.P_.max()</span></pre><p id="2084" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">当我们绘制增长时间序列(上图)、<code class="fe mr ms mt mu b">T_stream</code>以及矩阵分布图(下图)、<code class="fe mr ms mt mu b">P</code>时，我们可以看到矩阵分布图是如何随着新数据的添加而演变的:</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="6e66" class="mz kx iq mu b gy na nb l nc nd">fig, axs = plt.subplots(2, sharex=True, gridspec_kw={'hspace': 0})</span><span id="3688" class="mz kx iq mu b gy ne nb l nc nd">rect = Rectangle((643, 0), m, 40, facecolor='lightgrey')<br/>axs[0].add_patch(rect)<br/>rect = Rectangle((8724, 0), m, 40, facecolor='lightgrey')<br/>axs[0].add_patch(rect)<br/>axs[0].set_xlim((0, T_full.shape[0]))<br/>axs[0].set_ylim((-0.1, T_full.max()+5))<br/>axs[1].set_xlim((0, T_full.shape[0]))<br/>axs[1].set_ylim((-0.1, P_max+5))<br/>axs[0].axvline(x=643, linestyle="dashed")<br/>axs[0].axvline(x=8724, linestyle="dashed")<br/>axs[1].axvline(x=643, linestyle="dashed")<br/>axs[1].axvline(x=8724, linestyle="dashed")<br/>axs[0].set_ylabel("Steam Flow", fontsize='20')<br/>axs[1].set_ylabel("Matrix Profile", fontsize='20')<br/>axs[1].set_xlabel("Time", fontsize='20')<br/></span><span id="51c5" class="mz kx iq mu b gy ne nb l nc nd">lines = []<br/>for ax in axs:<br/>    line, = ax.plot([], [], lw=2)<br/>    lines.append(line)<br/>line, = axs[1].plot([], [], lw=2)<br/>lines.append(line)</span><span id="096d" class="mz kx iq mu b gy ne nb l nc nd">def init():<br/>    for line in lines:<br/>        line.set_data([], [])<br/>    return lines</span><span id="1782" class="mz kx iq mu b gy ne nb l nc nd">def animate(window):<br/>    P, T = window<br/>    for line, data in zip(lines, [T, P]):<br/>        line.set_data(np.arange(data.shape[0]), data)</span><span id="373e" class="mz kx iq mu b gy ne nb l nc nd">    return lines</span><span id="dcf1" class="mz kx iq mu b gy ne nb l nc nd">anim = animation.FuncAnimation(fig, animate, init_func=init,<br/>                               frames=windows, interval=100,<br/>                               blit=True, repeat=False)</span><span id="20db" class="mz kx iq mu b gy ne nb l nc nd">anim_out = anim.to_jshtml()<br/>plt.close()  # Prevents duplicate image from displaying<br/>if os.path.exists("None0000000.png"):<br/>    os.remove("None0000000.png")  # Delete rogue temp file</span><span id="772a" class="mz kx iq mu b gy ne nb l nc nd">HTML(anim_out)<br/># anim.save('/tmp/stumpi.mp4')</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/cdbb1ac3cdaaa35c5e3b22322bf1d728.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ga7Hkd0a8p6c7wAnOGRKEw.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">(图片由作者提供)</p></figure><p id="98b2" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">这里，垂直虚线标记了预期的全局基序对的位置，灰色方框强调了相应的基序子序列。播放动画时，您可能会注意到矩阵轮廓不断变化，因为过去的子序列可能会找到新的最近邻。但是，请注意，矩阵轮廓的任何变化只能向下移动(向零移动)。在该动画的大部分时间里，左侧高亮显示的子序列(灰色框)具有相对较高的矩阵轮廓值。然而，随着时间序列延伸超过右侧的灰色框，前述矩阵轮廓值显著下降，并且一旦其最近的邻居完全到达流中就迅速稳定。这真的很酷！事实上，最初的<a class="ae kv" href="https://www.cs.ucr.edu/~eamonn/PID4481997_extend_Matrix%20Profile_I.pdf" rel="noopener ugc nofollow" target="_blank"> Matrix Profile I </a>论文的作者指出，在这个数据集上，在耗尽时间或内存之前，可以用<code class="fe mr ms mt mu b">stumpy.stumpi()</code>继续监控 Matrix Profile 几十年！</p><h1 id="38b8" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">奖金部分—从不更新历史记录</h1><p id="3208" class="pw-post-body-paragraph lp lq iq lr b ls mm jr lu lv mn ju lx ly mo ma mb mc mp me mf mg mq mi mj mk ij bi translated">上面，我们已经用典型的定义矩阵配置文件。也就是说，对于任何给定的子序列，<code class="fe mr ms mt mu b">T[i : i + m]</code>，找出到它最近的邻居，<code class="fe mr ms mt mu b">T[j : j + m]</code>的距离，不管<code class="fe mr ms mt mu b">j</code>是在<code class="fe mr ms mt mu b">i</code>(即<code class="fe mr ms mt mu b">j &lt; i</code>)的左边还是在<code class="fe mr ms mt mu b">i</code>(即<code class="fe mr ms mt mu b">j &gt; i</code>)的右边。这意味着随着新数据的到来，如果一个“新的”最近邻点出现，甚至过去的历史数据点的矩阵轮廓也会更新。本质上，这是“事后诸葛亮”。因此，可能会有这样的情况，当您第一次看到一个独特的子序列时，您可能会将其识别为异常，因为它的矩阵分布值相对较高。然而，随着越来越多的新数据到达，这种最初的异常子序列可能不再是唯一的。考虑只观察正弦波的第一个周期，所有这些子序列将是唯一的。但随着正弦波的下一个周期开始流入，我们意识到第一个周期中的数据点不再异常，因此我们相应地更新了它们的矩阵轮廓值。</p><p id="deb1" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">现在，这可能有益，也可能无益，取决于你选择如何定义“异常”。事实上，您可以选择不更新过去的矩阵轮廓，并且您可能希望限制对最近邻居<code class="fe mr ms mt mu b">j</code>的搜索，使其始终位于<code class="fe mr ms mt mu b">i</code>的左侧(即<code class="fe mr ms mt mu b">j &lt; i</code>)。幸运的是，在<code class="fe mr ms mt mu b">stumpy.stumpi()</code>中，这已经为您完成，您可以分别通过流对象的<code class="fe mr ms mt mu b">.left_P</code>和<code class="fe mr ms mt mu b">.left_I</code>属性访问左矩阵配置文件和左矩阵配置文件索引:</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="95bf" class="mz kx iq mu b gy na nb l nc nd">T_full = np.random.rand(64)<br/>m = 8</span><span id="8eed" class="mz kx iq mu b gy ne nb l nc nd">T_stream = T_full[:10].copy()<br/>stream = stumpy.stumpi(T_stream, m)</span><span id="3b24" class="mz kx iq mu b gy ne nb l nc nd">for i in range(len(T_stream), len(T_full)):<br/>    t = T_full[i]<br/>    stream.update(t)</span><span id="a739" class="mz kx iq mu b gy ne nb l nc nd">print(f"Full Matrix Profile: {np.round(stream.P_, 2)}")<br/>print(f"Left Matrix Profile: {np.round(stream.left_P_, 2)}")<br/>print(f"Full Matrix Profile Indices: {stream.I_}")<br/>print(f"Left Matrix Profile Indices: {stream.left_I_}")<br/></span><span id="fb5e" class="mz kx iq mu b gy ne nb l nc nd">Full Matrix Profile: [2.59 2.56 2.4  2.07 1.99 2.22 2.18 1.57 2.29 1.8  1.94 1.93 1.97 2.12<br/> 2.06 2.35 2.54 2.15 1.95 1.78 2.18 1.99 2.43 2.05 1.77 2.07 2.04 2.49<br/> 2.18 2.23 1.57 1.68 1.59 1.93 1.68 1.59 2.12 2.12 1.77 1.78 2.08 2.06<br/> 1.99 2.42 2.1  2.07 1.99 2.22 2.1  1.8  2.29 2.16 2.13 1.95 1.93 1.93<br/> 1.97]<br/>Left Matrix Profile: [ inf  inf  inf 4.42 3.78 2.98 2.74 3.12 2.98 3.8  2.93 2.75 2.45 2.56<br/> 2.4  2.35 2.54 2.34 2.77 2.56 2.48 2.58 2.74 2.48 2.29 2.39 2.16 2.51<br/> 2.18 2.23 1.57 2.05 1.91 2.07 1.68 1.59 2.19 2.12 1.77 1.78 2.08 2.06<br/> 1.99 2.52 2.4  2.07 1.99 2.22 2.1  1.8  2.29 2.16 2.13 1.95 1.93 1.93<br/> 1.97]<br/>Full Matrix Profile Indices: [52 19 39 45 46 47 48 30 26 49 54 55 56 40 41 42  6 56 53 39 28 42 30 31<br/> 38 33 55 38 20  6  7 34 35 54 31 32 54 34 24 19  3 14 21 47 48  3  4  5<br/> 44  9 10 36 37 18 33 11 12]<br/>Left Matrix Profile Indices: [-1 -1 -1  0  1  2  3  4  2  4  0  1  7  3  9  5  6 12 13  1  9  6  7 10<br/> 11 12 13  4 20  6  7 23 24 25 31 32 25 34 24 19  3 14 21 30  3  3  4  5<br/> 44  9 10 36 37 18 33 11 12]</span></pre><p id="14ef" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">当然，需要指出的是，左侧矩阵轮廓索引中的<code class="fe mr ms mt mu b">-1</code>值并不对应于时间序列中的最后一个子序列。相反，这意味着该位置的子序列在其左侧没有有效的最近邻。因此，相应的左矩阵轮廓值将被设置为<code class="fe mr ms mt mu b">np.inf</code>。</p><h1 id="9d38" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">摘要</h1><p id="c73d" class="pw-post-body-paragraph lp lq iq lr b ls mm jr lu lv mn ju lx ly mo ma mb mc mp me mf mg mq mi mj mk ij bi translated">就是这样！您刚刚学习了如何针对流式(在线)数据逐步更新矩阵配置文件。</p><h1 id="d55f" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">资源</h1><p id="0672" class="pw-post-body-paragraph lp lq iq lr b ls mm jr lu lv mn ju lx ly mo ma mb mc mp me mf mg mq mi mj mk ij bi translated"><a class="ae kv" href="https://www.cs.ucr.edu/~eamonn/PID4481997_extend_Matrix%20Profile_I.pdf" rel="noopener ugc nofollow" target="_blank"> Matrix Profile I </a> <br/> <a class="ae kv" href="https://www.cs.ucr.edu/~eamonn/MP_journal.pdf" rel="noopener ugc nofollow" target="_blank">时序连接、基序、不一致和 Shapelets:利用 Matrix Profile 的统一视图</a>(见第 4.6 节和表 5) <br/> <a class="ae kv" href="https://stumpy.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> STUMPY Matrix Profile 文档</a><br/><a class="ae kv" href="https://github.com/TDAmeritrade/stumpy" rel="noopener ugc nofollow" target="_blank">STUMPY Matrix Profile Github 代码库</a></p><h2 id="8b4e" class="mz kx iq bd ky nv nw dn lc nx ny dp lg ly nz oa li mc ob oc lk mg od oe lm of bi translated">← <a class="ae kv" rel="noopener" target="_blank" href="/part-5-fast-approximate-matrix-profiles-with-scrump-c6d9c984c560">第 5 部分:使用 STUMPY 的快速近似矩阵轮廓</a> | <a class="ae kv" rel="noopener" target="_blank" href="/part-7-fast-pattern-searching-with-stumpy-2baf610a8de1">第 7 部分:使用 STUMPY 的快速模式搜索</a> →</h2></div></div>    
</body>
</html>