<html>
<head>
<title>Fetch Failed Exception in Apache Spark: Decrypting the most common causes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Apache Spark 中的获取失败异常:解密最常见的原因</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/fetch-failed-exception-in-apache-spark-decrypting-the-most-common-causes-b8dff21075c?source=collection_archive---------9-----------------------#2020-08-21">https://towardsdatascience.com/fetch-failed-exception-in-apache-spark-decrypting-the-most-common-causes-b8dff21075c?source=collection_archive---------9-----------------------#2020-08-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div class="gh gi ir"><img src="../Images/a76c8cf18106532a35f21fa6c9406f34.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*i62Cr8llMnAtKLEfMKfkzw.png"/></div></figure><h2 id="f032" class="iy iz ja bd b dl jb jc jd je jf jg dk jh translated" aria-label="kicker paragraph">SPARK 执行指南</h2><div class=""/><div class=""><h2 id="3522" class="pw-subtitle-paragraph kg jj ja bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">大多数 Spark 开发人员花费了大量的时间来排除在混洗操作中观察到的 Fetch Failed 异常。这个故事将为您提供获取失败异常的最常见原因，并揭示最近对该异常进行的调查结果。</h2></div><p id="117b" class="pw-post-body-paragraph ky kz ja la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Shuffle 操作是几乎所有 Spark 作业的主干，这些作业的目标是数据聚合、连接或数据重组。在混洗操作期间，数据通过两步过程在群集的各个节点之间混洗:</p><p id="bdd6" class="pw-post-body-paragraph ky kz ja la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">a)混洗写入:混洗映射任务将待混洗的数据写入磁盘文件，数据根据混洗减少任务排列在文件中。对应于由混洗映射任务写入混洗减少任务的一堆混洗数据被称为混洗块。此外，每个混洗映射任务通知驱动程序关于写入的混洗数据。</p><p id="ded4" class="pw-post-body-paragraph ky kz ja la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">b)混洗读取:混洗减少任务向驱动程序查询其混洗块的位置。然后，这些任务与托管其洗牌块的执行器建立连接，并开始获取所需的洗牌块。一旦获取了一个块，它就可用于 reduce 任务中的进一步计算。</p><blockquote class="lu lv lw"><p id="89fb" class="ky kz lx la b lb lc kk ld le lf kn lg ly li lj lk lz lm ln lo ma lq lr ls lt im bi translated">想了解更多洗牌过程，可以参考我之前的故事标题:<a class="ae mb" href="https://medium.com/swlh/revealing-apache-spark-shuffling-magic-b2c304306142" rel="noopener">揭秘 Apache Spark 洗牌魔术</a>。</p></blockquote><p id="7a70" class="pw-post-body-paragraph ky kz ja la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">shuffle 的两步过程虽然听起来很简单，但是操作起来很复杂，因为它涉及数据排序、磁盘写/读和网络传输。因此，对于混洗操作的可靠性总是有一个问号，并且这种不可靠性的证据是在混洗操作期间经常遇到的“提取失败异常”。大多数 Spark 开发人员花费大量时间来排除这种常见的异常。首先，他们试图找出异常的根本原因，然后相应地对其进行正确的修复。</p><blockquote class="lu lv lw"><p id="03b5" class="ky kz lx la b lb lc kk ld le lf kn lg ly li lj lk lz lm ln lo ma lq lr ls lt im bi translated">在 shuffle reduce 任务中报告的获取失败异常指示从宿主执行器读取一个或多个 shuffle 块失败。调试 FetchFailed 异常非常具有挑战性，因为它可能由于多种原因而发生。找到并了解正确的原因是非常重要的，因为这将有助于您采取正确的措施来克服异常。</p></blockquote><p id="267b" class="pw-post-body-paragraph ky kz ja la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最近一段时间对数百个 Spark 作业进行故障排除后，我意识到 Fetch Failed 异常主要是由于以下原因造成的:</p><ul class=""><li id="bfa4" class="mc md ja la b lb lc le lf lh me ll mf lp mg lt mh mi mj mk bi translated">执行器上的堆内存不足</li><li id="5e3b" class="mc md ja la b lb ml le mm lh mn ll mo lp mp lt mh mi mj mk bi translated">执行器上的低内存开销</li><li id="e24d" class="mc md ja la b lb ml le mm lh mn ll mo lp mp lt mh mi mj mk bi translated">大于 2 GB 的随机播放块</li><li id="ff3e" class="mc md ja la b lb ml le mm lh mn ll mo lp mp lt mh mi mj mk bi translated">网络超时。</li></ul><p id="60e4" class="pw-post-body-paragraph ky kz ja la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了了解这些原因出现的频率，我最近还对 Spark、<a class="ae mb" href="https://www.linkedin.com/groups/7403611/" rel="noopener ugc nofollow" target="_blank"> Apache Spark </a>上最受关注的 LinkedIn 群组进行了<a class="ae mb" href="https://www.linkedin.com/feed/update/urn:li:activity:6699000104633860096" rel="noopener ugc nofollow" target="_blank">民意调查</a>。令我惊讶的是，相当多的人参与了投票并提交了他们的意见，这进一步证实了人们在 Spark 工作中经常遇到这种例外的事实。以下是投票结果:</p><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/786a23aa0bf30828edf5c1ebaeb64b3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1038/format:webp/1*S8vB4csDB8tJ_j8_7f_j2A.png"/></div><p class="mv mw gj gh gi mx my bd b be z dk translated">LinkedIn Apache Spark 组中对 Fetch Failed Exception 进行的投票结果</p></figure><blockquote class="lu lv lw"><p id="98cc" class="ky kz lx la b lb lc kk ld le lf kn lg ly li lj lk lz lm ln lo ma lq lr ls lt im bi translated">根据投票结果，“执行程序堆内存不足”和“洗牌块大于 2 GB”是投票最多的原因。接下来是“网络超时”和“执行器的低内存开销”。</p></blockquote><p id="2200" class="pw-post-body-paragraph ky kz ja la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们详细了解一下这些原因:</p><p id="97fc" class="pw-post-body-paragraph ky kz ja la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">“执行程序上的堆内存不足”:</strong>这个原因表明，由于托管相应洗牌块的执行程序因 Java“内存不足”错误而崩溃，导致获取失败异常。当执行器上的堆空间不足或者执行器的垃圾收集器在垃圾收集上浪费了比实际有用的工作更多的时间时，就会出现“内存不足错误”。</p><p id="6cfa" class="pw-post-body-paragraph ky kz ja la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了关联这个原因，您需要检查 Fetch Failed 异常中提到的主机执行器详细信息(主机名/IP 地址/端口)。一旦您获得了执行器的详细信息，您会注意到针对托管执行器的以下任务失败:</p><ul class=""><li id="0586" class="mc md ja la b lb lc le lf lh me ll mf lp mg lt mh mi mj mk bi translated">由于退出代码 143，导致“ExecutorLostFailure”</li><li id="f98e" class="mc md ja la b lb ml le mm lh mn ll mo lp mp lt mh mi mj mk bi translated">由于执行器心跳超时，导致“ExecutorLostFailure”。</li></ul><p id="1e91" class="pw-post-body-paragraph ky kz ja la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些针对托管执行器的任务失败表明托管洗牌块的执行器由于 Java“内存不足”错误而被杀死。此外，还可以明确确认 executor 容器日志中的错误。由于托管执行器被终止，托管的 shuffle 块无法获取，因此可能会导致一个或多个 shuffle reduce 任务中的获取失败异常。</p><blockquote class="lu lv lw"><p id="ac01" class="ky kz lx la b lb lc kk ld le lf kn lg ly li lj lk lz lm ln lo ma lq lr ls lt im bi translated">根据民意调查结果，这一原因获得了最高的投票率。我在工作中也见证了更大比例的这种原因。</p></blockquote><p id="24d4" class="pw-post-body-paragraph ky kz ja la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">“执行程序上的低内存开销”:</strong>该原因表明，由于托管相应洗牌块的执行程序因“低内存开销”而崩溃，因此出现了提取失败异常。当一个执行器的物理内存占用超过指定的物理内存限制时，就会出现“内存开销低”的错误。当执行器堆内存被大量利用，并且对堆外内存也有很好的需求时，就会出现这种情况。</p><p id="2bd0" class="pw-post-body-paragraph ky kz ja la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了关联这个原因，您需要检查 Fetch Failed 异常中提到的主机执行器细节(主机名/IP 地址/端口)。一旦获得了执行者的详细信息，您可能会注意到针对托管执行者的以下任务失败:</p><ul class=""><li id="29ba" class="mc md ja la b lb lc le lf lh me ll mf lp mg lt mh mi mj mk bi translated">ExecutorLostFailure，使用了# GB 物理内存中的# GB。考虑提高火花。纱线。执行者。开销</li></ul><p id="f1fb" class="pw-post-body-paragraph ky kz ja la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">针对托管执行器的上述任务失败表明，托管洗牌块的执行器由于过度使用指定的物理内存限制而被杀死。同样，由于托管执行器被终止，托管的混排块不能被获取，因此可能导致一个或多个混排减少任务中的获取失败异常。</p><blockquote class="lu lv lw"><p id="b409" class="ky kz lx la b lb lc kk ld le lf kn lg ly li lj lk lz lm ln lo ma lq lr ls lt im bi translated">根据民意调查结果，这一原因的投票率最低。但是，我也目睹了更大比例的这种原因。事实上，这个比例类似于“执行程序内存不足”的原因。</p></blockquote><p id="e8bb" class="pw-post-body-paragraph ky kz ja la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">“大于 2 GB 的随机播放块”:</strong>获取失败异常，提及“帧太大”、“帧大小超过”或“大小超过整数”。作为错误原因的“MaxValue”指示相应的混洗减少任务试图获取大于 2 GB 的混洗块。这主要来源于整数的限制。数据结构抽象(ByteBuffer)上的 MaxValue(2GB)用于在内存中存储 shuffle 块。</p><p id="c456" class="pw-post-body-paragraph ky kz ja la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，从 Spark 版开始，这个特殊的原因在很大程度上得到了解决。</p><blockquote class="lu lv lw"><p id="f1de" class="ky kz lx la b lb lc kk ld le lf kn lg ly li lj lk lz lm ln lo ma lq lr ls lt im bi translated">根据民意调查结果，这一原因获得了第二高的投票率。但是，在我的工作中，我很少看到 Fetch 因此而失败。</p></blockquote><p id="db89" class="pw-post-body-paragraph ky kz ja la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">“网络超时”:</strong>通常以可配置的时间间隔(<code class="fe mz na nb nc b">spark.shuffle.io.retryWait</code>)重试可配置的次数(<code class="fe mz na nb nc b">spark.shuffle.io.maxRetries</code>)来获取混洗块。当从其宿主执行器获取 shuffle 块时耗尽了所有的退休时，在 shuffle reduce 任务中会引发一个获取失败异常。这些获取失败的异常通常被归类为“网络超时”类别。</p><p id="2ca1" class="pw-post-body-paragraph ky kz ja la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种提取失败异常很难关联。此外，这些异常可能由于网络问题而出现，或者当托管相应洗牌块的执行器变得不堪重负时出现。</p><blockquote class="lu lv lw"><p id="6e30" class="ky kz lx la b lb lc kk ld le lf kn lg ly li lj lk lz lm ln lo ma lq lr ls lt im bi translated">根据民意调查结果，这一原因获得了第三高的投票率。我也经常目睹这一事业。</p></blockquote><p id="1d5a" class="pw-post-body-paragraph ky kz ja la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望，读完这个故事后，您现在一定对 Fetch Failed 异常的各种原因有了一个公平的想法。我计划在一个不同的故事中介绍针对每个原因的可能的修复方法。如果您正在紧急寻找针对 Fetch Failed 异常的修复方法，您可以丢弃一条消息。</p><p id="2390" class="pw-post-body-paragraph ky kz ja la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，我要感谢所有参与投票并提交意见的人。</p><p id="e82e" class="pw-post-body-paragraph ky kz ja la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果对这个故事有任何反馈或疑问，请写在评论区。我希望，你会发现它有用。 <a class="ae mb" href="https://medium.com/@ajaygupta.hbti" rel="noopener"> <em class="lx">这里是我贴的 Apache Spark 上其他综合故事的链接。</em> </a></p></div></div>    
</body>
</html>