<html>
<head>
<title>You Don’t Always Have to Loop Through Rows in Pandas!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你不需要总是在熊猫的行列中循环！</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/you-dont-always-have-to-loop-through-rows-in-pandas-22a970b347ac?source=collection_archive---------8-----------------------#2020-06-09">https://towardsdatascience.com/you-dont-always-have-to-loop-through-rows-in-pandas-22a970b347ac?source=collection_archive---------8-----------------------#2020-06-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="c8c4" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">计算机编程语言</h2><div class=""/><div class=""><h2 id="e490" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">用向量化解决方案看一下“for循环”的替代方案。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/74c0a13e809d51fb8b87325f0bf6c7f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9FVEOlBm0_f7ymi3DlbQKw.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">由@ <a class="ae lh" href="https://www.instagram.com/siscadraws/" rel="noopener ugc nofollow" target="_blank"> siscadraws </a>创建(Instagram句柄)</p></figure><p id="de58" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我用熊猫已经有一段时间了，但我并不总是正确地使用它。我执行计算或编辑数据的直观方法倾向于从这个问题开始:</p><blockquote class="me"><p id="1519" class="mf mg it bd mh mi mj mk ml mm mn md dk translated">我如何循环遍历(迭代)我的数据帧来做<em class="mo"> INSERT_ANY_TASK_HERE </em>？</p></blockquote><p id="c998" class="pw-post-body-paragraph li lj it lk b ll mp kd ln lo mq kg lq lr mr lt lu lv ms lx ly lz mt mb mc md im bi translated">迭代数据帧中的行可能有效。事实上，我写了一整篇关于<a class="ae lh" rel="noopener" target="_blank" href="/a-really-simple-way-to-edit-row-by-row-in-a-pandas-dataframe-75d339cbd313">如何逐行编辑你在熊猫</a>中的数据。</p><p id="867a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我这样做的原因是因为我有一个多层计算，对于我来说，我无法解决如何不循环。我有多个条件，其中一个条件涉及获取一个列值，该列值具有数据帧中另一个列的名称，该列将用于计算。</p><p id="6117" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">迭代数据帧是我能想到的解决这个问题的唯一方法。但是这不应该是你在和熊猫一起工作时总是采用的方法。</p><p id="696d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">事实上，Pandas甚至有一个红色的警告<a class="ae lh" href="https://pandas.pydata.org/pandas-docs/stable/getting_started/basics.html#iteration" rel="noopener ugc nofollow" target="_blank">告诉你不应该迭代数据帧。</a></p><blockquote class="me"><p id="185b" class="mf mg it bd mh mi mj mk ml mm mn md dk translated">遍历pandas对象一般都是<strong class="ak">慢</strong>。在许多情况下，不需要手动迭代这些行，并且可以通过<em class="mo">矢量化</em>解决方案来避免:许多操作可以使用内置方法或NumPy函数、(布尔)索引来执行。</p></blockquote><p id="7f34" class="pw-post-body-paragraph li lj it lk b ll mp kd ln lo mq kg lq lr mr lt lu lv ms lx ly lz mt mb mc md im bi translated">大多数时候，您可以使用一个<strong class="lk jd">矢量化解决方案</strong>来执行您的熊猫操作。<strong class="lk jd">矢量化</strong>不是使用“for循环”类型的操作，即一次遍历一组数据中的一个值，而是实现一个解决方案，一次遍历一组值。在Pandas中，这意味着不是逐行计算，而是在整个数据帧上执行操作。</p><p id="d241" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">这里的重点不仅仅是代码在非循环解决方案下运行的速度，而是创建可读的代码，最大程度地利用Pandas。</strong></p><p id="a492" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，让我们通过几个例子来帮助重新构建最初的思考过程，从“我如何循环通过一个数据帧？”真正的问题是“我如何用熊猫的工具进行计算？”。</p></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><p id="97a5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们将要使用的数据来自于<a class="ae lh" href="https://www.kaggle.com/jessemostipak/animal-crossing/data" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>的一个动物穿越用户回顾数据集。我们将导入数据并创建两个数据帧，一个称为“旧”，另一个称为“新”。然后，为了开始了解for循环的替代解决方案的基础，我们将使用for循环和矢量化解决方案执行一些操作，并比较代码。(要理解下面for循环代码背后的逻辑，请查看<a class="ae lh" rel="noopener" target="_blank" href="/a-really-simple-way-to-edit-row-by-row-in-a-pandas-dataframe-75d339cbd313?source=friends_link&amp;sk=29a2f011cc7fa485a019d1f9511cf78a">我之前的一篇文章</a>，因为它已经对这个主题有了深入的解释。)</p><pre class="ks kt ku kv gt nc nd ne nf aw ng bi"><span id="3e65" class="nh ni it nd b gy nj nk l nl nm">import pandas as pd</span><span id="ced9" class="nh ni it nd b gy nn nk l nl nm">old = pd.read_csv('user_reviews.csv')<br/>new = pd.read_csv('user_reviews.csv')</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi no"><img src="../Images/14f8cca69e942b9b9af788bf42d599c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wC7uqI4XaPlA0Ydo3-goQw.png"/></div></div></figure><h1 id="4a54" class="np ni it bd nq nr ns nt nu nv nw nx ny ki nz kj oa kl ob km oc ko od kp oe of bi translated">熊猫矢量化解决方案介绍</h1><h2 id="0300" class="nh ni it bd nq og oh dn nu oi oj dp ny lr ok ol oa lv om on oc lz oo op oe iz bi translated">实现“如果-那么-否则”</h2><p id="4110" class="pw-post-body-paragraph li lj it lk b ll oq kd ln lo or kg lq lr os lt lu lv ot lx ly lz ou mb mc md im bi translated">让我们创建一个名为“qualitative _ rating”的新列。这样，我们可以创建一些宽泛的类别，将每个用户评论标记为“差”、“好”和“好”。“坏”评论是指“等级”低于5的评论。一篇好的评论将会是任何“等级”大于5的评论。任何“等级”等于5的评论都将是“好的”。</p><p id="4a9a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">要使用for循环实现这一点，代码如下所示:</p><pre class="ks kt ku kv gt nc nd ne nf aw ng bi"><span id="2e9e" class="nh ni it nd b gy nj nk l nl nm"># if then elif else (old)</span><span id="36f3" class="nh ni it nd b gy nn nk l nl nm"># create new column <br/>old['qualitative_rating'] = ''</span><span id="8836" class="nh ni it nd b gy nn nk l nl nm"># assign 'qualitative_rating' based on 'grade' with loop<br/>for index in old.index:<br/>    if old.loc[index, 'grade'] &lt; 5:<br/>        old.loc[index, 'qualitative_rating'] = 'bad'<br/>    elif old.loc[index, 'grade'] == 5:<br/>        old.loc[index, 'qualitative_rating'] = 'ok'<br/>    elif old.loc[index, 'grade'] &gt; 5:<br/>        old.loc[index, 'qualitative_rating'] = 'good'</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ov"><img src="../Images/0e34c661354428cb1d29eb5411b4d9de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M6x17J9fwB8M8gPYGvowvg.png"/></div></div></figure><p id="db6b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">代码很容易阅读，但是花了7行2.26秒完成了3000行。</p><p id="9971" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">相反，更好的解决方案应该是这样的:</p><pre class="ks kt ku kv gt nc nd ne nf aw ng bi"><span id="04ba" class="nh ni it nd b gy nj nk l nl nm"># if then elif else (new)</span><span id="cde8" class="nh ni it nd b gy nn nk l nl nm"># create new column<br/>new['qualitative_rating'] = ''</span><span id="cd4e" class="nh ni it nd b gy nn nk l nl nm"># assign 'qualitative_rating' based on 'grade' with .loc<br/>new.loc[new.grade &lt; 5, 'qualitative_rating'] = 'bad'<br/>new.loc[new.grade == 5, 'qualitative_rating'] = 'ok'<br/>new.loc[new.grade &gt; 5, 'qualitative_rating'] = 'good'</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ow"><img src="../Images/b46a55bc8f74b0e60e7b08e9cfdaa2a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ElRIIOxuNG3L3BWY2uoEMQ.png"/></div></div></figure><p id="379e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这一次，添加定性评级的代码仅由3行代码组成，仅用了68毫秒。“我也用过了。loc”data frame函数，但这一次，我“恰当地”使用了它。我的意思是，我没有使用循环的“如果-否则”解决方案，而是直接从“如果-否则”中分配“坏”、“好”和“好”的定性评级。loc”选择。</p><h2 id="2e4b" class="nh ni it bd nq og oh dn nu oi oj dp ny lr ok ol oa lv om on oc lz oo op oe iz bi translated"><strong class="ak">计算列值的长度</strong></h2><p id="2419" class="pw-post-body-paragraph li lj it lk b ll oq kd ln lo or kg lq lr os lt lu lv ot lx ly lz ou mb mc md im bi translated">我们的下一个新列“len_text”将显示每个评论的字符数，因此我们可以比较数据集中不同评论的长度。</p><p id="70ac" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">要使用for循环实现这一点，代码如下所示:</p><pre class="ks kt ku kv gt nc nd ne nf aw ng bi"><span id="3ccc" class="nh ni it nd b gy nj nk l nl nm"># create column based on other column (old)</span><span id="59f2" class="nh ni it nd b gy nn nk l nl nm"># create new column<br/>old['len_text'] = ''</span><span id="b5b6" class="nh ni it nd b gy nn nk l nl nm"># calculate length of column value with loop<br/>for index in old.index:<br/>    old.loc[index, 'len_text'] = len(old.loc[index, 'text'])</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ow"><img src="../Images/12bd84ecb4e71f163976216a0009dd5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ioeImGBOQz-55V3uhEOF1g.png"/></div></div></figure><p id="d90b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">同样，2行2.23秒对于这个计算来说并不算长。但是，我们可以使用只需要一行的解决方案，而不是遍历每一行来查找长度:</p><pre class="ks kt ku kv gt nc nd ne nf aw ng bi"><span id="05bc" class="nh ni it nd b gy nj nk l nl nm"># create column based on other column (new)</span><span id="14a6" class="nh ni it nd b gy nn nk l nl nm"># create new column<br/>new['len_text'] = ''</span><span id="203a" class="nh ni it nd b gy nn nk l nl nm"># calculate length of column value by converting to str<br/>new['len_text'] = new['text'].str.len()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ox"><img src="../Images/8db31b65301004ec0f19e4a41fb70105.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lP3OCmc23IHJ3ndhkmjNXg.png"/></div></div></figure><p id="33d1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里，我们获取一个现有列的值，将它们转换成字符串，然后使用“.len()"来获取每个字符串中的字符数。这个解决方案只花了40毫秒运行。</p><h2 id="46e5" class="nh ni it bd nq og oh dn nu oi oj dp ny lr ok ol oa lv om on oc lz oo op oe iz bi translated"><strong class="ak">基于多个条件和现有列值创建新列</strong></h2><p id="ab59" class="pw-post-body-paragraph li lj it lk b ll oq kd ln lo or kg lq lr os lt lu lv ot lx ly lz ou mb mc md im bi translated">现在让我们创建一个名为“super_category”的新列。在这里，我们将确定人们是否有资格成为“超级审阅者”，或者在这种情况下，他们的审阅长度是否大于1000个字符。如果评论“等级”大于或等于9，我们还会将超级评论者标记为“超级粉丝”，如果评论“等级”小于或等于1，则标记为“超级讨厌者”。其他人都将被归类为“正常”。</p><p id="4856" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">用for循环实现这一点将如下所示:</p><pre class="ks kt ku kv gt nc nd ne nf aw ng bi"><span id="47eb" class="nh ni it nd b gy nj nk l nl nm"># new column based on multiple conditions (old)</span><span id="1198" class="nh ni it nd b gy nn nk l nl nm"># create new column<br/>old['super_category'] = ''</span><span id="e136" class="nh ni it nd b gy nn nk l nl nm"># set multiple conditions and assign reviewer category with loop<br/>for index in old.index:<br/>    if old.loc[index, 'grade'] &gt;= 9 and old.loc[index, 'len_text'] &gt;= 1000:<br/>        old.loc[index, 'super_category'] = 'super fan'<br/>    elif old.loc[index, 'grade'] &lt;= 1 and old.loc[index, 'len_text'] &gt;= 1000:<br/>        old.loc[index, 'super_category'] = 'super hater'<br/>    else:<br/>        old.loc[index, 'super_category'] = 'normal'</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ox"><img src="../Images/4b6fd96e6ac11dfa194f999e424df0b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c9MODy2jEmi8Y7S8SFbIow.png"/></div></div></figure><p id="b1cb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是可行的，但是让我们把它分成两半:</p><pre class="ks kt ku kv gt nc nd ne nf aw ng bi"><span id="b8ea" class="nh ni it nd b gy nj nk l nl nm"># new column based on multiple conditions (new)</span><span id="0960" class="nh ni it nd b gy nn nk l nl nm"># create new column<br/>new['super_category'] = 'normal'</span><span id="e933" class="nh ni it nd b gy nn nk l nl nm"># set multiple conditions and assign reviewer category with .loc<br/>new.loc[(new['grade'] == 10) &amp; (new['len_text'] &gt;= 1000), 'super_category'] = 'super fan'<br/>new.loc[(new['grade'] &lt;= 1) &amp; (new['len_text'] &gt;= 1000), 'super_category'] = 'super hater'</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ox"><img src="../Images/9109ed690c912fe9ccc74f72f0d7d09c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fPKjsIn7gMUXWjsYt1FOgg.png"/></div></div></figure><p id="1146" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里，我们在我们的内部使用了“&amp;”操作符。loc "函数来同时实现这两个条件。矢量化解决方案在63毫秒内完成，这再次明显快于循环方法，后者需要2.23秒。</p></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><p id="1fa1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这些是一些基本的操作，用来扩展现有的数据和一些我们自己定制的分析。是的，我们可以用循环做任何事情，你甚至可以看到相同的结构应用于许多不同的操作。但是Pandas自带了很多内置方法，专门用于我们经常需要执行的操作。</p><p id="4d03" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">经历这些帮助我重新训练我的大脑，不要总是将for循环作为寻找更好的方法来完成各种操作的解决方案。</p><p id="ff89" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我希望它能帮助你做同样的事情！</p></div></div>    
</body>
</html>