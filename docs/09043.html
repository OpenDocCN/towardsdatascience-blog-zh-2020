<html>
<head>
<title>The 3 Ways To Compute Feature Importance in the Random Forest</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">计算随机森林中特征重要性的三种方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-3-ways-to-compute-feature-importance-in-the-random-forest-96c86b49e6d4?source=collection_archive---------20-----------------------#2020-06-29">https://towardsdatascience.com/the-3-ways-to-compute-feature-importance-in-the-random-forest-96c86b49e6d4?source=collection_archive---------20-----------------------#2020-06-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="e6a6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">特征重要性描述了哪些特征是相关的。它可以帮助更好地理解所解决的问题，有时还可以通过利用特征选择来改进模型。在这篇文章中，我将展示 3 种方法(带代码)来计算来自<code class="fe ko kp kq kr b">scikit-learn</code>包(Python 中)的随机森林算法的特征重要性。</p><h1 id="ae7f" class="ks kt it bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">内置随机森林重要性</h1><p id="96f5" class="pw-post-body-paragraph jq jr it js b jt lq jv jw jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn im bi translated">随机森林算法具有内置的要素重要性，可以通过两种方式计算:</p><ul class=""><li id="eadd" class="lv lw it js b jt ju jx jy kb lx kf ly kj lz kn ma mb mc md bi translated"><strong class="js iu">基尼系数</strong>(或平均减少杂质)，由随机森林结构计算得出。让我们看看随机森林是如何构建的。这是一组决策树。每个决策树都是一组内部节点和叶子。在内部节点中，所选择的特征用于决定如何将数据集分成两个独立的集合，其中具有相似的响应。内部节点的特征是根据某种标准选择的，对于分类任务，该标准可以是基尼不纯或信息增益，对于回归，该标准是方差减少。我们可以测量每个特征如何减少分裂的杂质(具有最高减少的特征被选择用于内部节点)。对于每个特征，我们可以收集它平均如何减少杂质。森林中所有树的平均值是要素重要性的度量。该方法可在<code class="fe ko kp kq kr b"><a class="ae me" href="https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestClassifier.html#sklearn.ensemble.RandomForestClassifier.feature_importances_" rel="noopener ugc nofollow" target="_blank">scikit-learn</a></code> <a class="ae me" href="https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestClassifier.html#sklearn.ensemble.RandomForestClassifier.feature_importances_" rel="noopener ugc nofollow" target="_blank">中实现</a>的随机森林(对于分类器和回归器都适用)。值得一提的是，在这种方法中，我们应该查看计算出的重要性的相对值。这种方法最大的优点是计算速度快——所有需要的值都是在随机森林训练中计算出来的。该方法的缺点是倾向于选择(选择为重要的)高基数的数字特征和分类特征。此外，在相关特征的情况下，它可以选择其中一个特征，而忽略第二个特征的重要性(这可能导致错误的结论)。</li><li id="7649" class="lv lw it js b jt mf jx mg kb mh kf mi kj mj kn ma mb mc md bi translated"><strong class="js iu">平均降低准确度</strong> —是一种基于准确度平均降低来计算置换出袋(OOB)样本特征重要性的方法。这个方法没有在<code class="fe ko kp kq kr b">scikit-learn</code>包中实现。与这种方法非常相似的是本文下面描述的基于排列的重要性。</li></ul><p id="bd77" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我将展示如何使用<code class="fe ko kp kq kr b">scikit-learn</code>包和波士顿数据集计算随机森林的特征重要性(房价回归任务)。</p><pre class="mk ml mm mn gt mo kr mp mq aw mr bi"><span id="21d3" class="ms kt it kr b gy mt mu l mv mw"><em class="mx"># Let's load the packages</em><br/><strong class="kr iu">import</strong> <strong class="kr iu">numpy</strong> <strong class="kr iu">as</strong> np<br/><strong class="kr iu">import</strong> <strong class="kr iu">pandas</strong> <strong class="kr iu">as</strong> pd<br/><strong class="kr iu">from</strong> <strong class="kr iu">sklearn.datasets</strong> <strong class="kr iu">import</strong> load_boston<br/><strong class="kr iu">from</strong> <strong class="kr iu">sklearn.model_selection</strong> <strong class="kr iu">import</strong> train_test_split<br/><strong class="kr iu">from</strong> <strong class="kr iu">sklearn.ensemble</strong> <strong class="kr iu">import</strong> RandomForestRegressor<br/><strong class="kr iu">from</strong> <strong class="kr iu">sklearn.inspection</strong> <strong class="kr iu">import</strong> permutation_importance<br/><strong class="kr iu">import</strong> <strong class="kr iu">shap</strong><br/><strong class="kr iu">from</strong> <strong class="kr iu">matplotlib</strong> <strong class="kr iu">import</strong> pyplot <strong class="kr iu">as</strong> plt<br/><br/>plt.rcParams.update({'figure.figsize': (12.0, 8.0)})<br/>plt.rcParams.update({'font.size': 14})</span></pre><p id="8670" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">加载数据集并拆分用于训练和测试。</p><pre class="mk ml mm mn gt mo kr mp mq aw mr bi"><span id="eec6" class="ms kt it kr b gy mt mu l mv mw">boston = load_boston()<br/>X = pd.DataFrame(boston.data, columns=boston.feature_names)<br/>y = boston.target<br/>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25, random_state=12)</span></pre><p id="f013" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">用 100 棵决策树装配<a class="ae me" href="https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestRegressor.html#sklearn.ensemble.RandomForestRegressor" rel="noopener ugc nofollow" target="_blank">随机森林回归器</a>;</p><pre class="mk ml mm mn gt mo kr mp mq aw mr bi"><span id="b79f" class="ms kt it kr b gy mt mu l mv mw">rf = RandomForestRegressor(n_estimators=100)<br/>rf.fit(X_train, y_train)</span></pre><p id="240d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要从随机森林模型中获得特征重要性，请使用<code class="fe ko kp kq kr b">feature_importances_</code>参数:</p><pre class="mk ml mm mn gt mo kr mp mq aw mr bi"><span id="cb66" class="ms kt it kr b gy mt mu l mv mw">rf.feature_importances_</span><span id="3a25" class="ms kt it kr b gy my mu l mv mw">array([0.04054781, 0.00149293, 0.00576977, 0.00071805, 0.02944643,<br/>       0.25261155, 0.01969354, 0.05781783, 0.0050257 , 0.01615872,<br/>       0.01066154, 0.01185997, 0.54819617])</span></pre><p id="4772" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们画出重要性(图表比数值更容易理解)。</p><pre class="mk ml mm mn gt mo kr mp mq aw mr bi"><span id="436b" class="ms kt it kr b gy mt mu l mv mw">plt.barh(boston.feature_names, rf.feature_importances_)</span></pre><figure class="mk ml mm mn gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi mz"><img src="../Images/bcaecc931be634625eda8783ce13299c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*N3t3ZWjuxwhf6r4v.png"/></div></div></figure><p id="d806" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了有一个更好的图表，让我们对特征进行排序，并再次绘图:</p><pre class="mk ml mm mn gt mo kr mp mq aw mr bi"><span id="b645" class="ms kt it kr b gy mt mu l mv mw">sorted_idx = rf.feature_importances_.argsort()<br/>plt.barh(boston.feature_names[sorted_idx], rf.feature_importances_[sorted_idx])<br/>plt.xlabel("Random Forest Feature Importance")</span></pre><figure class="mk ml mm mn gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi mz"><img src="../Images/edd1f46993b9ce358c8ee829a3987a5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Vt03EpzvA5R45dTN.png"/></div></div></figure><h1 id="ee13" class="ks kt it bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">基于排列的重要性</h1><p id="7214" class="pw-post-body-paragraph jq jr it js b jt lq jv jw jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn im bi translated">基于排列的重要性可用于克服用平均杂质减少计算的默认特征重要性的缺点。它在<code class="fe ko kp kq kr b">scikit-learn</code>中作为<code class="fe ko kp kq kr b"><a class="ae me" href="https://scikit-learn.org/stable/modules/generated/sklearn.inspection.permutation_importance.html#sklearn.inspection.permutation_importance" rel="noopener ugc nofollow" target="_blank">permutation_importance</a></code>方法实现。作为参数，它需要经过训练的模型(可以是与<code class="fe ko kp kq kr b">scikit-learn</code> API 兼容的任何模型)和验证(测试数据)。这种方法将随机改变每个特征，并计算模型性能的变化。对性能影响最大的特性是最重要的特性。</p><p id="1b20" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">置换重要性可以很容易地计算出来:</p><pre class="mk ml mm mn gt mo kr mp mq aw mr bi"><span id="aa6d" class="ms kt it kr b gy mt mu l mv mw">perm_importance = permutation_importance(rf, X_test, y_test)</span></pre><p id="a156" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">绘制重要性图:</p><pre class="mk ml mm mn gt mo kr mp mq aw mr bi"><span id="a29c" class="ms kt it kr b gy mt mu l mv mw">sorted_idx = perm_importance.importances_mean.argsort()<br/>plt.barh(boston.feature_names[sorted_idx], perm_importance.importances_mean[sorted_idx])<br/>plt.xlabel("Permutation Importance")</span></pre><figure class="mk ml mm mn gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi mz"><img src="../Images/edb2afa44ca7fcdbf25419e9b1a670ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hEmu5JH6rV8DNe5b.png"/></div></div></figure><p id="5d2c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">基于置换的重要性在计算上是昂贵的。基于排列的方法对于高度相关的特征可能有问题，它可以将它们报告为不重要。</p><h1 id="3c5e" class="ks kt it bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">根据 SHAP 值计算重要性</h1><p id="5ae8" class="pw-post-body-paragraph jq jr it js b jt lq jv jw jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn im bi translated">可以使用<a class="ae me" href="https://github.com/slundberg/shap" rel="noopener ugc nofollow" target="_blank"> SHAP </a>解释(它是模型不可知的)来计算随机森林的特征重要性。它使用博弈论中的 Shapley 值来估计每个特征对预测的贡献。它可以很容易地安装(<code class="fe ko kp kq kr b">pip install shap</code>)和使用<code class="fe ko kp kq kr b">scikit-learn</code>随机森林:</p><pre class="mk ml mm mn gt mo kr mp mq aw mr bi"><span id="0e95" class="ms kt it kr b gy mt mu l mv mw">explainer = shap.TreeExplainer(rf)<br/>shap_values = explainer.shap_values(X_test)</span></pre><p id="c0c2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要将特征重要性绘制成水平条形图，我们需要使用<code class="fe ko kp kq kr b">summary_plot</code>方法:</p><pre class="mk ml mm mn gt mo kr mp mq aw mr bi"><span id="e37e" class="ms kt it kr b gy mt mu l mv mw">shap.summary_plot(shap_values, X_test, plot_type="bar")</span></pre><figure class="mk ml mm mn gt na gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/6d0ef15db08572fe0bf819538419e6e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1044/format:webp/0*mmIiTLFwEx1NNYOa.png"/></div></figure><p id="afb5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">特征重要性可以用更多细节来绘制，显示特征值:</p><pre class="mk ml mm mn gt mo kr mp mq aw mr bi"><span id="c1f3" class="ms kt it kr b gy mt mu l mv mw">shap.summary_plot(shap_values, X_test)</span></pre><figure class="mk ml mm mn gt na gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/4afa743a11b8d86d5a1dae1a6aa7c9fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/format:webp/0*TD_WnP_zwnKaTkgx.png"/></div></figure><p id="c5f7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用 SHAP 计算特征重要性的计算开销可能很大。然而，它可以提供更多的信息，如决策图或依赖图。</p><h1 id="fac7" class="ks kt it bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">摘要</h1><p id="62a6" class="pw-post-body-paragraph jq jr it js b jt lq jv jw jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn im bi translated">给出了计算<code class="fe ko kp kq kr b">scikit-learn</code>随机森林的特征重要性的 3 种方法:</p><ul class=""><li id="c6bc" class="lv lw it js b jt ju jx jy kb lx kf ly kj lz kn ma mb mc md bi translated">内置功能重要性</li><li id="d9d9" class="lv lw it js b jt mf jx mg kb mh kf mi kj mj kn ma mb mc md bi translated">基于排列的重要性</li><li id="9312" class="lv lw it js b jt mf jx mg kb mh kf mi kj mj kn ma mb mc md bi translated">用 SHAP 值计算</li></ul><p id="ea9c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我看来，检查所有方法并比较结果总是好的。我在 MLJAR 的 AutoML 开源包<code class="fe ko kp kq kr b"><a class="ae me" href="https://github.com/mljar/mljar-supervised" rel="noopener ugc nofollow" target="_blank">mljar-supervised</a></code>中使用了基于排列和 SHAP 的方法。我使用它们是因为它们是模型不可知的，并且可以很好地与非来自<code class="fe ko kp kq kr b">scikit-learn</code>的算法一起工作:Xgboost，神经网络(keras+tensorflow)，LigthGBM，CatBoost。</p><h1 id="905f" class="ks kt it bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">重要注意事项</h1><ul class=""><li id="6eb5" class="lv lw it js b jt lq jx lr kb nj kf nk kj nl kn ma mb mc md bi translated">模型越精确，计算出的重要性就越可信。</li><li id="ef8e" class="lv lw it js b jt mf jx mg kb mh kf mi kj mj kn ma mb mc md bi translated">计算的重要性描述了特征对于机器学习模型有多重要。这是数据中要素重要性的近似值</li></ul></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><p id="3ac6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由 mljar 监管的是一个开源的自动机器学习(AutoML) Python 包，可以处理表格数据。它旨在为数据科学家节省时间。它抽象了预处理数据、构建机器学习模型和执行超参数调整以找到最佳模型的通用方法。这不是一个黑匣子，因为你可以确切地看到 ML 管道是如何构建的(每个 ML 模型都有一个详细的降价报告)。</p><figure class="mk ml mm mn gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nt"><img src="../Images/330bdbab62d431e84a80f8e945a1f401.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Ud2IpWTJgd84KLJdsYzmqA.gif"/></div></div><p class="nu nv gj gh gi nw nx bd b be z dk translated">使用 mljar 监督的 AutoML 包生成的示例报告。</p></figure></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><p id="0f79" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="mx">原载于 2020 年 6 月 29 日</em><a class="ae me" href="https://mljar.com/blog/feature-importance-in-random-forest/" rel="noopener ugc nofollow" target="_blank"><em class="mx"/></a><em class="mx">。</em></p></div></div>    
</body>
</html>