<html>
<head>
<title>The Most Elegant Python Object-Oriented Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">最优雅的 Python 面向对象编程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-most-elegant-python-object-oriented-programming-b38d75f4ae7b?source=collection_archive---------6-----------------------#2020-07-12">https://towardsdatascience.com/the-most-elegant-python-object-oriented-programming-b38d75f4ae7b?source=collection_archive---------6-----------------------#2020-07-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/f5ea34dab8fb6ea76be992257d96268f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dOCFOF3zyodV1XaLC4JOwQ.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae jg" href="https://pixabay.com/users/TheDigitalArtist-202249/" rel="noopener ugc nofollow" target="_blank">数码师</a>在<a class="ae jg" href="https://pixabay.com/illustrations/banner-jigsaw-pattern-design-5190182/" rel="noopener ugc nofollow" target="_blank">像素点</a>拍摄的照片</p></figure><div class=""/><div class=""><h2 id="f719" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">具有全面验证功能的字典和对象之间的无缝转换</h2></div><p id="31d1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">众所周知，Python 的优势在于它的灵活性。例如，Python 是面向对象编程中最简单的编程语言之一。然而，它有时也会受到批评，因为它“过于灵活”。</p><p id="b2b0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我将介绍我认为使用 Python 进行面向对象编程的最优雅的方式。</p><p id="6cbf" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">方法的关键是一个名为<code class="fe lu lv lw lx b">marshmallow</code>的库。</p><p id="7c56" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以通过<code class="fe lu lv lw lx b">pip install marshmallow</code>轻松安装这个库。</p><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ly"><img src="../Images/101912b1bcb4d3c44c23d28e6fd399d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SHQhLlM7Sk5h7e3grMvsXQ.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">由<a class="ae jg" href="https://pixabay.com/users/Zorro4-796252/" rel="noopener ugc nofollow" target="_blank"> Zorro4 </a>在<a class="ae jg" href="https://pixabay.com/illustrations/hibiscus-marshmallow-blue-flower-2081312/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上拍摄的照片</p></figure><h1 id="232d" class="md me jj bd mf mg mh mi mj mk ml mm mn kp mo kq mp ks mq kt mr kv ms kw mt mu bi translated">类别的定义</h1><p id="3bc3" class="pw-post-body-paragraph ky kz jj la b lb mv kk ld le mw kn lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">让我们从声明一个用户类开始，出于演示目的，保持简单。</p><pre class="lz ma mb mc gt na lx nb nc aw nd bi"><span id="a8bd" class="ne me jj lx b gy nf ng l nh ni">class User(object):<br/>    def __init__(self, name, age):<br/>        self.name = name<br/>        self.age = age</span><span id="842a" class="ne me jj lx b gy nj ng l nh ni">def __repr__(self):<br/>        return f'I am {self.name} and my age is {self.age}'</span></pre><p id="4843" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">好的。我们的<code class="fe lu lv lw lx b">User</code>职业只有两个属性:<code class="fe lu lv lw lx b">name</code>和<code class="fe lu lv lw lx b">age</code>。请注意，我还实现了<code class="fe lu lv lw lx b">__repr__</code>方法，这样我们可以很容易地输出实例来验证它。</p><p id="c1eb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，我们需要从库<code class="fe lu lv lw lx b">marshmallow</code>中导入一些模块和方法。</p><pre class="lz ma mb mc gt na lx nb nc aw nd bi"><span id="8c40" class="ne me jj lx b gy nf ng l nh ni">from marshmallow import Schema, fields, post_load<br/>from pprint import pprint</span></pre><p id="e0a8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里我导入了<code class="fe lu lv lw lx b">pprint</code>，因为我们要打印许多字典和列表。只是想让它更好看。</p><p id="a381" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们应该如何使用<code class="fe lu lv lw lx b">marshmallow</code>？简单地为我们的<code class="fe lu lv lw lx b">User</code>类定义一个“模式”。</p><pre class="lz ma mb mc gt na lx nb nc aw nd bi"><span id="3672" class="ne me jj lx b gy nf ng l nh ni">class UserSchema(Schema):<br/>    name = fields.String()<br/>    age = fields.Integer()</span><span id="c244" class="ne me jj lx b gy nj ng l nh ni">@post_load<br/>    def make(self, data, **kwargs):<br/>        return User(**data)</span></pre><p id="f692" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这很简单。对于每个属性，我们需要声明它是<code class="fe lu lv lw lx b">fields</code>，然后后跟类型。</p><p id="0645" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注释<code class="fe lu lv lw lx b">@post_load</code>是可选的，如果我们希望将模式作为任何类的实例来加载，就需要这个注释。因此，在我们的例子中我们需要它，因为我们想要生成<code class="fe lu lv lw lx b">User</code>实例。<code class="fe lu lv lw lx b">make</code>方法将简单地使用所有的参数来实例化实例。</p><h1 id="2c23" class="md me jj bd mf mg mh mi mj mk ml mm mn kp mo kq mp ks mq kt mr kv ms kw mt mu bi translated">JSON 到实例</h1><p id="c6ed" class="pw-post-body-paragraph ky kz jj la b lb mv kk ld le mw kn lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">如果我们有一个字典(JSON 对象)并且想要一个实例，下面是代码。</p><pre class="lz ma mb mc gt na lx nb nc aw nd bi"><span id="9f6e" class="ne me jj lx b gy nf ng l nh ni">data = {<br/>    'name': 'Chris',<br/>    'age': 32<br/>}</span><span id="fcaf" class="ne me jj lx b gy nj ng l nh ni">schema = UserSchema()<br/>user = schema.load(data)</span></pre><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/93a8c3ea84a2e70e54e8731306ce4eae.png" data-original-src="https://miro.medium.com/v2/resize:fit:672/format:webp/1*zOARY-lmHnOa4QlCH_4ZJg.png"/></div></figure><p id="d7b8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">多简单啊！只需调用模式的<code class="fe lu lv lw lx b">load()</code>方法，我们就将 JSON 对象反序列化为类实例。</p><h1 id="c05b" class="md me jj bd mf mg mh mi mj mk ml mm mn kp mo kq mp ks mq kt mr kv ms kw mt mu bi translated">多个实例的 JSON 数组</h1><p id="d087" class="pw-post-body-paragraph ky kz jj la b lb mv kk ld le mw kn lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">如果我们有一个包含多个要去序列化的对象的 JSON 数组呢？我们不需要写 for-loop，简单指定<code class="fe lu lv lw lx b">many=True</code>如下。</p><pre class="lz ma mb mc gt na lx nb nc aw nd bi"><span id="54c4" class="ne me jj lx b gy nf ng l nh ni">data = [{<br/>    'name': 'Alice',<br/>    'age': 20<br/>}, {<br/>    'name': 'Bob',<br/>    'age': 25<br/>}, {<br/>    'name': 'Chris',<br/>    'age': 32<br/>}]</span><span id="feb6" class="ne me jj lx b gy nj ng l nh ni">schema = UserSchema()<br/>users = schema.load(data, many=True)</span></pre><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/2fea1cfabc6c0e8f7621c6bdee5f1cd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/format:webp/1*BmEkSY99ZbKyZEyCbvPe3w.png"/></div></figure><h1 id="2e54" class="md me jj bd mf mg mh mi mj mk ml mm mn kp mo kq mp ks mq kt mr kv ms kw mt mu bi translated">将实例序列化为 JSON 对象(字典)</h1><p id="8c04" class="pw-post-body-paragraph ky kz jj la b lb mv kk ld le mw kn lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">好的。我们知道可以使用<code class="fe lu lv lw lx b">load()</code>方法将字典转换成实例。反过来怎么样？我们可以使用如下的<code class="fe lu lv lw lx b">dump()</code>方法。</p><pre class="lz ma mb mc gt na lx nb nc aw nd bi"><span id="0cea" class="ne me jj lx b gy nf ng l nh ni">dict = schema.dump(users, many=True)</span></pre><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/091be8557ea443642d98c0b386c51ea2.png" data-original-src="https://miro.medium.com/v2/resize:fit:788/format:webp/1*Nqri-bWM-QPt1UTpTCCj6A.png"/></div></figure><p id="0d8d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个例子中，我简单地使用了<code class="fe lu lv lw lx b">users</code>，它是从前面的例子中生成的用户实例列表。可以看到，一行代码就把用户实例列表转换成了 JSON 数组！</p><h1 id="df56" class="md me jj bd mf mg mh mi mj mk ml mm mn kp mo kq mp ks mq kt mr kv ms kw mt mu bi translated">现场验证</h1><p id="68d7" class="pw-post-body-paragraph ky kz jj la b lb mv kk ld le mw kn lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">你认为<code class="fe lu lv lw lx b">marshmallow</code>只能序列化/反序列化实例吗？如果是这样，我大概不会把这个作为故事分享在这里。这个库最强大的特性是验证。</p><p id="f52c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里先说一个简单的例子。首先，我们需要从库中导入一个异常<code class="fe lu lv lw lx b">ValidationError</code>。</p><pre class="lz ma mb mc gt na lx nb nc aw nd bi"><span id="63fd" class="ne me jj lx b gy nf ng l nh ni">from marshmallow import ValidationError</span></pre><p id="9b7c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">还记得我们用字段<code class="fe lu lv lw lx b">age</code>声明了上面的<code class="fe lu lv lw lx b">UserSchema</code>为<code class="fe lu lv lw lx b">Integer</code>吗？如果我们传入一个无效的值呢？</p><pre class="lz ma mb mc gt na lx nb nc aw nd bi"><span id="fc91" class="ne me jj lx b gy nf ng l nh ni">data = [{<br/>    'name': 'Alice',<br/>    'age': 20<br/>}, {<br/>    'name': 'Bob',<br/>    'age': 25<br/>}, {<br/>    'name': 'Chris',<br/>    'age': 'thirty two'<br/>}]</span></pre><p id="be80" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，在上面的 JSON 数组中，第三个对象“Chris”的年龄格式无效，不能转换为整数。现在让我们使用<code class="fe lu lv lw lx b">load()</code>方法去序列化数组。</p><pre class="lz ma mb mc gt na lx nb nc aw nd bi"><span id="c1d7" class="ne me jj lx b gy nf ng l nh ni">try:<br/>    schema = UserSchema()<br/>    users = schema.load(data, many=True)<br/>except ValidationError as e:<br/>    print(f'Error Msg: {e.messages}')<br/>    print(f'Valid Data: {e.valid_data}')</span></pre><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nn"><img src="../Images/62bfbd727de362fc33f52d3987dbef06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fqfdBbKh5gxqjbrAQUnAig.png"/></div></div></figure><p id="b38f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">异常被捕获，它告诉我们“不是一个有效的整数”。想象一下，我们正在开发一个 web 应用程序，甚至没有必要为编写错误消息而烦恼！</p><p id="5895" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，在本例中，只有第三个对象存在验证问题。错误消息实际上告诉我们它发生在索引<code class="fe lu lv lw lx b">2</code>处。此外，仍然可以输出有效的对象。</p><h1 id="eea7" class="md me jj bd mf mg mh mi mj mk ml mm mn kp mo kq mp ks mq kt mr kv ms kw mt mu bi translated">高级验证</h1><p id="7bed" class="pw-post-body-paragraph ky kz jj la b lb mv kk ld le mw kn lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">当然，仅仅针对数据类型进行验证是不够的。该库支持更多的验证方法。</p><p id="0e19" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们给<code class="fe lu lv lw lx b">User</code>类再添加一个属性<code class="fe lu lv lw lx b">gender</code>。</p><pre class="lz ma mb mc gt na lx nb nc aw nd bi"><span id="5bfd" class="ne me jj lx b gy nf ng l nh ni">class User(object):<br/>    def __init__(self, name, age, gender):<br/>        self.name = name<br/>        self.age = age<br/>        self.gender = gender</span><span id="d3da" class="ne me jj lx b gy nj ng l nh ni">def __repr__(self):<br/>        return f'I am {self.name}, my age is {self.age} and my gender is {self.gender}'</span></pre><p id="090c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，让我们定义带有验证的模式。我们还需要从库中导入<code class="fe lu lv lw lx b">validate</code>特征。</p><pre class="lz ma mb mc gt na lx nb nc aw nd bi"><span id="15a6" class="ne me jj lx b gy nf ng l nh ni">from marshmallow import validate</span><span id="2046" class="ne me jj lx b gy nj ng l nh ni">class UserSchema(Schema):<br/>    name = fields.String(validate=validate.Length(min=1))<br/>    age = fields.Integer(validate=validate.Range(min=18, max=None))<br/>    gender = fields.String(validate=validate.OneOf(['F', 'M', 'Other']))</span></pre><p id="011d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里，我们向所有这三个字段添加了验证。</p><ul class=""><li id="c38a" class="no np jj la b lb lc le lf lh nq ll nr lp ns lt nt nu nv nw bi translated">对于字段<code class="fe lu lv lw lx b">name</code>，长度必须至少为 1。换句话说，不能是空的。</li><li id="14b3" class="no np jj la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated">对于字段<code class="fe lu lv lw lx b">age</code>，它必须大于或等于 18。</li><li id="35cc" class="no np jj la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated">对于字段<code class="fe lu lv lw lx b">gender</code>，它必须是三个值之一。</li></ul><p id="0ac3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们定义一个包含所有无效值的 JSON 对象，如下所示。</p><pre class="lz ma mb mc gt na lx nb nc aw nd bi"><span id="bdfb" class="ne me jj lx b gy nf ng l nh ni">data = {<br/>    'name': '',<br/>    'age': 16,<br/>    'gender': 'X'<br/>}</span></pre><p id="f418" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，让我们试着加载它。</p><pre class="lz ma mb mc gt na lx nb nc aw nd bi"><span id="c01a" class="ne me jj lx b gy nf ng l nh ni">try:<br/>    UserSchema().load(data)<br/>except ValidationError as e:<br/>    pprint(e.messages)</span></pre><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/ee3f4b7c978552b5116d7cee4e0a34a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*cTeSAdZb4GJjGAUA55Yf_A.png"/></div></figure><p id="5ae6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">捕捉异常并不奇怪，但是当我第一次尝试时，我真的很惊讶错误消息是现成的。这为我们编写验证错误消息节省了大量时间。</p><h1 id="9535" class="md me jj bd mf mg mh mi mj mk ml mm mn kp mo kq mp ks mq kt mr kv ms kw mt mu bi translated">定制验证功能</h1><p id="5aa6" class="pw-post-body-paragraph ky kz jj la b lb mv kk ld le mw kn lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">您可能会问，使用上例中的内置验证方法(如范围、长度和“其中之一”)仍然有一定的局限性。如果我们想要定制验证方法呢？当然可以。</p><pre class="lz ma mb mc gt na lx nb nc aw nd bi"><span id="9e4a" class="ne me jj lx b gy nf ng l nh ni">def validate_age(age):<br/>    if age &lt; 18:<br/>        raise ValidationError('You must be an adult to buy our products!')</span><span id="c841" class="ne me jj lx b gy nj ng l nh ni">class UserSchema(Schema):<br/>    name = fields.String(validate=validate.Length(min=1))<br/>    age = fields.Integer(validate=validate_age)<br/>    gender = fields.String(validate=validate.OneOf(['F', 'M', 'Other']))</span></pre><p id="5f41" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这里，我们用定制的逻辑和消息定义了我们的验证方法<code class="fe lu lv lw lx b">validate_age</code>。让我们定义一个 JSON 对象来测试它。在以下对象中，年龄小于 18 岁。</p><pre class="lz ma mb mc gt na lx nb nc aw nd bi"><span id="430e" class="ne me jj lx b gy nf ng l nh ni">data = {<br/>    'name': 'Chris',<br/>    'age': 17,<br/>    'gender': 'M'<br/>}</span><span id="529f" class="ne me jj lx b gy nj ng l nh ni">try:<br/>    user = UserSchema().load(data)<br/>except ValidationError as e:<br/>    pprint(e.messages)</span></pre><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi od"><img src="../Images/87650dccf43d4c67c07ecacb4ba97901.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o8o5U0OAmGqRCgDz_MkurA.png"/></div></div></figure><p id="2e18" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，它使用你定制的逻辑和错误信息。</p><p id="c0c9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">还有另外一种实现方式，我觉得更优雅。</p><pre class="lz ma mb mc gt na lx nb nc aw nd bi"><span id="dc8a" class="ne me jj lx b gy nf ng l nh ni">class UserSchema(Schema):<br/>    name = fields.String()<br/>    age = fields.Integer()<br/>    gender = fields.String()</span><span id="46c4" class="ne me jj lx b gy nj ng l nh ni">@validates('age')<br/>    def validate_age(self, age):<br/>        if age &lt; 18:<br/>            raise ValidationError('You must be an adult to buy our products!')</span></pre><p id="9ba2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，在这个例子中，我们使用注释来定义类内部的验证方法。</p><h1 id="2412" class="md me jj bd mf mg mh mi mj mk ml mm mn kp mo kq mp ks mq kt mr kv ms kw mt mu bi translated">必填字段</h1><p id="7992" class="pw-post-body-paragraph ky kz jj la b lb mv kk ld le mw kn lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">您还可以定义一些必填字段。</p><pre class="lz ma mb mc gt na lx nb nc aw nd bi"><span id="b7f6" class="ne me jj lx b gy nf ng l nh ni">class UserSchema(Schema):<br/>    name = fields.String(required=True, error_messages={'required': 'Please enter your name.'})<br/>    age = fields.Integer(required=True, error_messages={'required': 'Age is required.'})<br/>    email = fields.Email()</span></pre><p id="669f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个例子中，我们定义<code class="fe lu lv lw lx b">name</code>和<code class="fe lu lv lw lx b">age</code>为必填字段。现在，让我们使用一个没有电子邮件的对象来测试它。</p><pre class="lz ma mb mc gt na lx nb nc aw nd bi"><span id="93a4" class="ne me jj lx b gy nf ng l nh ni">data_no_email = {<br/>    'name': 'Chris',<br/>    'age': 32<br/>}</span><span id="96ca" class="ne me jj lx b gy nj ng l nh ni">try: <br/>    user = UserSchema().load(data_no_email)<br/>except ValidationError as e:<br/>    pprint(e.messages)</span></pre><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oe"><img src="../Images/289b53f06186e651ea937a755d6354dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SplqyVKtSfEXx_kcYfPoWA.png"/></div></div></figure><p id="e980" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">好的。完全没问题。如果我们有一个没有名字和年龄的物体呢？</p><pre class="lz ma mb mc gt na lx nb nc aw nd bi"><span id="1900" class="ne me jj lx b gy nf ng l nh ni">data_no_name_age = {<br/>    'email': '<a class="ae jg" href="mailto:abc@email.com" rel="noopener ugc nofollow" target="_blank">abc@email.com</a>'<br/>}</span><span id="0384" class="ne me jj lx b gy nj ng l nh ni">try: <br/>    user = UserSchema().load(data_no_name_age)<br/>except ValidationError as e:<br/>    print(f'Error Msg: {e.messages}')<br/>    print(f'Valid Data: {e.valid_data}')</span></pre><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi of"><img src="../Images/46e9f0d6e29530a79b06e6076b56a19a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_RB_AC0tKMoZ4z1fsakv5Q.png"/></div></div></figure><p id="6e0d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它会报错并提供我们为必填字段定义的错误消息。</p><h1 id="a805" class="md me jj bd mf mg mh mi mj mk ml mm mn kp mo kq mp ks mq kt mr kv ms kw mt mu bi translated">默认值</h1><p id="887b" class="pw-post-body-paragraph ky kz jj la b lb mv kk ld le mw kn lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">有时，我们可能希望用默认值定义一些字段。因此，用户可能不需要输入它，默认值将被利用。</p><pre class="lz ma mb mc gt na lx nb nc aw nd bi"><span id="4652" class="ne me jj lx b gy nf ng l nh ni">class UserSchema(Schema):<br/>    name = fields.String(missing='Unknown', default='Unknown')</span><span id="ee52" class="ne me jj lx b gy nj ng l nh ni">print(UserSchema().load({}))  # Take the "missing" value<br/>print(UserSchema().dump({})) # Take the "default" value</span></pre><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div class="gh gi og"><img src="../Images/5d73605f13b50e6fa28ac471ab7e2c5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/1*mQ6SY3I4ijRfhzFd9iPwbQ.png"/></div></figure><p id="9f2d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在<code class="fe lu lv lw lx b">marshmallow</code>中，有两种方式定义“默认”值:</p><ul class=""><li id="5911" class="no np jj la b lb lc le lf lh nq ll nr lp ns lt nt nu nv nw bi translated"><code class="fe lu lv lw lx b">missing</code>关键字定义了使用<code class="fe lu lv lw lx b">load()</code>反序列化实例时将使用的默认值</li><li id="8377" class="no np jj la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated"><code class="fe lu lv lw lx b">default</code>关键字定义使用<code class="fe lu lv lw lx b">dump()</code>序列化实例时将使用的默认值</li></ul><p id="b37f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的例子中，我们使用了两个关键字，并用一个空对象试验了<code class="fe lu lv lw lx b">load()</code>和<code class="fe lu lv lw lx b">dump()</code>两种方法。可以看出，两者都添加了带有默认值的<code class="fe lu lv lw lx b">name</code>字段。</p><h1 id="f671" class="md me jj bd mf mg mh mi mj mk ml mm mn kp mo kq mp ks mq kt mr kv ms kw mt mu bi translated">属性别名</h1><p id="1eb2" class="pw-post-body-paragraph ky kz jj la b lb mv kk ld le mw kn lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">继续，还没完:)</p><p id="50cd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有时候，在键/属性名方面，我们的类和实际的 JSON 数据之间可能会有一些差异。</p><p id="ef15" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，在我们的类中，我们定义了<code class="fe lu lv lw lx b">name</code>属性。然而，在 JSON 对象中，我们有<code class="fe lu lv lw lx b">username</code>,它表示相同的字段，但是命名不同。在这种情况下，我们不必重新实现我们的类，也不必转换 JSON 对象中的键。</p><pre class="lz ma mb mc gt na lx nb nc aw nd bi"><span id="07f5" class="ne me jj lx b gy nf ng l nh ni">class User(object):<br/>    def __init__(self, name, age):<br/>        self.name = name<br/>        self.age = age</span><span id="4d70" class="ne me jj lx b gy nj ng l nh ni">def __repr__(self):<br/>        return f'I am {self.name} and my age is {self.age}'</span><span id="6944" class="ne me jj lx b gy nj ng l nh ni">class UserSchema(Schema):<br/>    username = fields.String(attribute='name')<br/>    age = fields.Integer()</span><span id="1279" class="ne me jj lx b gy nj ng l nh ni">@post_load<br/>    def make(self, data, **kwargs):<br/>        return User(**data)</span></pre><p id="7b21" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，我们在<code class="fe lu lv lw lx b">User</code>类中有<code class="fe lu lv lw lx b">name</code>，而在<code class="fe lu lv lw lx b">UserSchema</code>中我们有<code class="fe lu lv lw lx b">username</code>，但是对于字段<code class="fe lu lv lw lx b">username</code>，我们定义它的<code class="fe lu lv lw lx b">attribute</code>应该叫做<code class="fe lu lv lw lx b">name.</code></p><p id="f775" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们尝试转储一个用户实例。</p><pre class="lz ma mb mc gt na lx nb nc aw nd bi"><span id="3e3f" class="ne me jj lx b gy nf ng l nh ni">user = User('Chris', 32)<br/>UserSchema().dump(user)</span></pre><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/2eb4ef71ed4bcd6f88349c5fceb159f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*Z8G0u___3JoLayDz3nsexQ.png"/></div></figure><p id="c730" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它正确地序列化了字段名为<code class="fe lu lv lw lx b">username</code>的实例。</p><p id="d067" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">反之亦然:</p><pre class="lz ma mb mc gt na lx nb nc aw nd bi"><span id="a6f9" class="ne me jj lx b gy nf ng l nh ni">data = {<br/>    'username': 'Chris',<br/>    'age': 32<br/>}<br/>UserSchema().load(data)</span></pre><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/650469cdeea9726022953eeb026d1013.png" data-original-src="https://miro.medium.com/v2/resize:fit:648/format:webp/1*Eh_d29itxcJCPHDpRAFmRw.png"/></div></figure><p id="d85e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">即使我们传递了带有键<code class="fe lu lv lw lx b">username</code>的 JSON 对象，它仍然可以毫无问题地将其反序列化到<code class="fe lu lv lw lx b">User</code>实例。</p><h1 id="af9b" class="md me jj bd mf mg mh mi mj mk ml mm mn kp mo kq mp ks mq kt mr kv ms kw mt mu bi translated">嵌套属性</h1><p id="92f1" class="pw-post-body-paragraph ky kz jj la b lb mv kk ld le mw kn lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">最后但同样重要的是，<code class="fe lu lv lw lx b">marshmallow</code>支持嵌套属性，没有任何问题。</p><pre class="lz ma mb mc gt na lx nb nc aw nd bi"><span id="9981" class="ne me jj lx b gy nf ng l nh ni">class Address(object):<br/>    def __init__(self, street, suburb, postcode):<br/>        self.street = street<br/>        self.suburb = suburb<br/>        self.postcode = postcode</span><span id="594f" class="ne me jj lx b gy nj ng l nh ni">def __repr__(self):<br/>        return f'{self.street}, {self.suburb} {self.postcode}'</span><span id="7f6c" class="ne me jj lx b gy nj ng l nh ni">class User(object):<br/>    def __init__(self, name, address):<br/>        self.name = name<br/>        self.address = address<br/>    <br/>    def __repr__(self):<br/>        return f'My name is {self.name} and I live at {self.address}'</span></pre><p id="06af" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们定义了两个类<code class="fe lu lv lw lx b">Address</code>和<code class="fe lu lv lw lx b">User</code>。类别<code class="fe lu lv lw lx b">User</code>有一个属性<code class="fe lu lv lw lx b">address</code>，其类型为<code class="fe lu lv lw lx b">Address</code>。让我们通过实例化一个用户对象来测试这些类。</p><pre class="lz ma mb mc gt na lx nb nc aw nd bi"><span id="778a" class="ne me jj lx b gy nf ng l nh ni">address = Address('1, This St', 'That Suburb', '1234')<br/>user = User('Chris', address)<br/>print(user)</span></pre><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/12432328e2beb8f3898d41f8699b0297.png" data-original-src="https://miro.medium.com/v2/resize:fit:1126/format:webp/1*_GQnzN8qP7q1wDs0TOEF5Q.png"/></div></figure><p id="a6cb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们将如下定义模式。</p><pre class="lz ma mb mc gt na lx nb nc aw nd bi"><span id="c0ac" class="ne me jj lx b gy nf ng l nh ni">class AddressSchema(Schema):<br/>    street = fields.String()<br/>    suburb = fields.String()<br/>    postcode = fields.String()</span><span id="5f49" class="ne me jj lx b gy nj ng l nh ni">@post_load<br/>    def make(self, data, **kwargs):<br/>        return Address(**data)</span><span id="3567" class="ne me jj lx b gy nj ng l nh ni">class UserSchema(Schema):<br/>    name = fields.String()<br/>    address = fields.Nested(AddressSchema())</span><span id="aebb" class="ne me jj lx b gy nj ng l nh ni">@post_load<br/>    def make(self, data, **kwargs):<br/>        return User(**data)</span></pre><p id="92f9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里的技巧是使用<code class="fe lu lv lw lx b">fields.Nested()</code>来定义一个使用另一个模式的字段。上面我们已经有了一个用户实例。让我们把它转储到一个 JSON 对象中。</p><pre class="lz ma mb mc gt na lx nb nc aw nd bi"><span id="00b5" class="ne me jj lx b gy nf ng l nh ni">pprint(UserSchema().dump(user))</span></pre><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/090f595967bdeec4002b0a9111f7bf33.png" data-original-src="https://miro.medium.com/v2/resize:fit:826/format:webp/1*ohBJJ_MzE4XOCo3PoS9fpA.png"/></div></figure><p id="d720" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如图所示，用户实例已经被序列化为一个嵌套的 JSON 对象！</p><p id="7e3b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当然，反过来也可以。</p><pre class="lz ma mb mc gt na lx nb nc aw nd bi"><span id="d527" class="ne me jj lx b gy nf ng l nh ni">data = {<br/>    'name': 'Chris',<br/>    'address': {<br/>        'postcode': '1234',<br/>        'street': '1, This St',<br/>        'suburb': 'That Suburb'<br/>    }<br/>}<br/>pprint(UserSchema().load(data))</span></pre><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/a3f69145f6bd8a6302d5c1294c844d4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*-WX4zvrnx2rSQPXyDC-Ccw.png"/></div></figure><h1 id="b820" class="md me jj bd mf mg mh mi mj mk ml mm mn kp mo kq mp ks mq kt mr kv ms kw mt mu bi translated">摘要</h1><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/ebcac622cb767a93da7062e6280a1be5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W1OCVh58AqxDjemw-ds1NA.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片由<a class="ae jg" href="https://pixabay.com/users/geralt-9301/" rel="noopener ugc nofollow" target="_blank"> geralt </a>在<a class="ae jg" href="https://pixabay.com/illustrations/business-planning-concepts-hand-5338474/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>拍摄</p></figure><p id="f314" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我介绍了如何使用库<code class="fe lu lv lw lx b">marshmallow</code>在实践中极大地简化 Python 中的面向对象编程。我认为在 Python 中使用 OO &lt; - &gt; JSON 是最优雅的方式。</p><p id="5415" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所有的代码都在我的谷歌实验室里:</p><div class="is it gp gr iu om"><a href="https://colab.research.google.com/drive/1mZVBiVgk3OTyJqFFTw6NYRThtjyZne9X?usp=sharing" rel="noopener  ugc nofollow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd jk gy z fp or fr fs os fu fw ji bi translated">棉花糖 _ 面向对象 _Python.ipynb</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">实验记录手册</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">colab.research.google.com</p></div></div><div class="ov l"><div class="ow l ox oy oz ov pa ja om"/></div></div></a></div><div class="is it gp gr iu om"><a href="https://medium.com/@qiuyujx/membership" rel="noopener follow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd jk gy z fp or fr fs os fu fw ji bi translated">通过我的推荐链接加入 Medium 克里斯托弗·陶</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">medium.com</p></div></div><div class="ov l"><div class="pb l ox oy oz ov pa ja om"/></div></div></a></div><p id="7d6b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你觉得我的文章有帮助，请考虑加入 Medium 会员来支持我和数以千计的其他作者！(点击上面的链接)</p></div></div>    
</body>
</html>