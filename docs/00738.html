<html>
<head>
<title>Pandas Makes Python Better</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">熊猫让Python变得更好</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/pandas-makes-python-better-ec6cc1e30233?source=collection_archive---------14-----------------------#2020-01-21">https://towardsdatascience.com/pandas-makes-python-better-ec6cc1e30233?source=collection_archive---------14-----------------------#2020-01-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d200" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">熊猫携带Python进行数据处理</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f149ba7ae5804dd97b0e36612756f0a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b3P4rdrVHMIHbhQXnwRVew.jpeg"/></div></div></figure><p id="30bf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi lq translated">我想谈论很久的一件事是熊猫给Python带来的力量。Pandas是Python中数据科学的一个基本包，因为它功能多样，非常擅长处理数据。我非常喜欢熊猫的一个部分是它奇妙的IPython和Numpy集成。这就是说，熊猫是直接与Numpy交织在一起的，就像花生酱与果冻交织在一起一样。难怪这两种组合在一个完整的包装中一起出售。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/c678204f6afc24e88250943ab747b47e.png" data-original-src="https://miro.medium.com/v2/resize:fit:976/format:webp/1*XpNMapwzntGlln2k_MMqnA.jpeg"/></div></figure><p id="14fa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="ma">抛开Smucker的Goober </em>笑话不谈，Pandas巧妙地让Python成为一种更可行的数据科学语言，仅仅是因为它内置于其中。这并不是说Python没有大量模拟这种确切效果的精彩包，因为Python有无数用于机器学习和数据处理的包。Pandas使得相对困难的事情，或者在其他语言中比较痛苦的事情，在Python中变得非常简单。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="b21a" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">IPython</h1><p id="0bb0" class="pw-post-body-paragraph ku kv it kw b kx na ju kz la nb jx lc ld nc lf lg lh nd lj lk ll ne ln lo lp im bi translated">支持熊猫的最大因素是——嗯，熊猫本身。该包从一开始就设计为包含IPython笔记本和Numpy等数据科学的主要产品。所有这些拼凑在一起的方式很有意义，但我不会告诉你这些，我将向你展示使用另一种语言的包是什么样子的，这是我最喜欢的:</p><blockquote class="nf"><p id="d8be" class="ng nh it bd ni nj nk nl nm nn no lp dk translated">朱莉娅</p></blockquote><p id="ae17" class="pw-post-body-paragraph ku kv it kw b kx np ju kz la nq jx lc ld nr lf lg lh ns lj lk ll nt ln lo lp im bi translated">有趣的是，我们用来创建数据框的包是DataFrames.jl。当然，我们现在将使用逗号分隔值文件(CSV文件)。所以第一步是读入我们的数据…但是我们怎么做呢？在变更日志中，有一个叫做read_table的方法的简短提及，但是在大多数情况下，这似乎肯定是不赞成的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/f8d469ab64d281e0cd4b064db2445bd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4ZBvTzoYO5WQVxuxJNJByA.png"/></div></div></figure><p id="1f08" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是诀窍，为了用DataFrames.jl读入我们的DataFrames，我们实际上必须得到另一个名为CSV.jl的包，添加这个包后，我们可以用read()方法打开我们的CSV文件:</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="bdc8" class="oa mj it nw b gy ob oc l od oe">using CSV<br/>df = CSV.read("Fizzbuzz")</span></pre><p id="857b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">太棒了，现在我们已经读取了我们的数据，但是我们在顶部得到了一个有趣的消息…</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/3bf179780050e79cb90987d14aa1ba70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_ucuqguD6eSM4iYPkfa0JQ.png"/></div></div></figure><blockquote class="nf"><p id="7fe1" class="ng nh it bd ni nj og oh oi oj ok lp dk translated">“省略打印12列”</p></blockquote><p id="22e7" class="pw-post-body-paragraph ku kv it kw b kx np ju kz la nq jx lc ld nr lf lg lh ns lj lk ll nt ln lo lp im bi translated">很好，但是为什么呢？出于某种奇怪的原因，他们选择在Iframe之外呈现数据帧，根据特定的列长度省略列。那么我们如何显示所有的列呢？显示所有的列非常容易，只需向show方法添加一个bool类型的参数，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/90976172b0e09e40c281ee1177f9cdeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gzVIBmyWvT-OdzQGnLdJjg.png"/></div></div></figure><p id="23c0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">等等，那是什么？没错，它会转到一个基于文本的数据框，并打印出列</p><blockquote class="nf"><p id="d265" class="ng nh it bd ni nj nk nl nm nn no lp dk translated">在彼此之上。</p></blockquote><p id="7a31" class="pw-post-body-paragraph ku kv it kw b kx np ju kz la nq jx lc ld nr lf lg lh ns lj lk ll nt ln lo lp im bi translated">好消息是，老showall！()方法，这意味着当我们显示所有列时，不必显示所有行。这很可能是我不久前开始使用字典的原因…</p><p id="8b49" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">好吧，现在我们知道这对朱莉娅来说有多难，但是熊猫呢？嗯，你不会认为它会这么简单，但是你需要的唯一的包是Pandas，你需要的唯一的方法是read_csv，最后，但同样重要的是，你可以使用函数df.head()打印出你选择的头部长度，使用df.tail()打印出你选择的尾部长度。更不用说，看起来是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/6e58d50598f2ad8cc7f18c39b4f74a5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ut0zf6Jz33FfoUGtTox6IQ.png"/></div></div></figure><p id="247d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">相信我，R的数据框架也没有panda好，而且大多数使用R和Julia的人倾向于PyCall Pandas，而不是使用他们各自语言的数据框架包。</p><h1 id="25ab" class="mi mj it bd mk ml on mn mo mp oo mr ms jz op ka mu kc oq kd mw kf or kg my mz bi translated">Numpy</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/d3fbd3046270bec0a06df8ad9b62fba2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*77kb1s09XosupOF4vGPzzg.png"/></div></div></figure><p id="38e6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi lq translated">umpy是Python数据科学包三剑客的另一部分。Numpy集成允许在数据框内使用Numpy的所有线性代数。此外，Numpy的某些部分使数据处理变得更加容易。看看我一眨眼就销毁了一千多个空值！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/64addcc8b156c816b228c1512bf59de1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*2Jeh_uyJ5dWTnuwoHHFalQ.png"/></div></figure><p id="b056" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">重要的是要记住，鉴于Python是一种编程语言，普通Python和线性代数实际上并不像你想象的那样相处融洽。我认为这仅仅是因为Python比“线性代数”更高级，当然也不希望它成为许多公司现在深陷其中的统计语言。当然，我的df.dropna()例子很简单，但是可以肯定的是，在某种程度上，与Numpy的紧密集成将使您的生活变得更加轻松！</p><h1 id="2eea" class="mi mj it bd mk ml on mn mo mp oo mr ms jz op ka mu kc oq kd mw kf or kg my mz bi translated">熊猫本身</h1><p id="ddf5" class="pw-post-body-paragraph ku kv it kw b kx na ju kz la nb jx lc ld nc lf lg lh nd lj lk ll ne ln lo lp im bi translated">除了Pandas出色的集成和围绕其他Python包的方法论之外，Pandas还有许多好处，这些好处是他们所做的所有出色的开源工作所提供的。每一个扭曲，每一个旋转，索引，连接，融合，旋转，甚至交叉制表都可以在熊猫的一行中完成。这些任务在其他包裹中确实可以提供一个完整小时的工作，但是用熊猫——它很容易而且即时。</p><p id="b361" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过replace()函数这样的简单工具，使用Pandas变得更加容易，replace()函数可用于替换nan，或者只是奇怪的数据。熊猫让很多工作变成了一点点工作，这就是它如此受欢迎和令人印象深刻的原因。但是熊猫还有更多巨大的好处。</p><h2 id="d89a" class="oa mj it bd mk ou ov dn mo ow ox dp ms ld oy oz mu lh pa pb mw ll pc pd my pe bi translated">字符串存取器</h2><p id="5d4d" class="pw-post-body-paragraph ku kv it kw b kx na ju kz la nb jx lc ld nc lf lg lh nd lj lk ll ne ln lo lp im bi translated">是的，传说是真的:</p><blockquote class="nf"><p id="2341" class="ng nh it bd ni nj nk nl nm nn no lp dk translated">数据框被美化成字典。</p></blockquote><p id="6e4f" class="pw-post-body-paragraph ku kv it kw b kx np ju kz la nq jx lc ld nr lf lg lh ns lj lk ll nt ln lo lp im bi translated">但是并不是所有的字典都是一样的。首先，在我所知道的语言中，熊猫的条件掩蔽是迄今为止最好的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pf"><img src="../Images/2e815042f75ce86c289fdf0728900669.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i_ObfswjpWrj-C3lkvRlMw.png"/></div></div></figure><p id="e14d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在一个简单的步骤中，数据被完全过滤并准备就绪，所有这些都包含在Pandas中，而不需要实际运行任何额外的方法——因为毕竟，它只是一个字典。</p><p id="53c0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Julia也有字典，他们的DataFrames.jl包当然是完全相同的系统，但在我看来，在这种情况下，当它试图与熊猫站在一起时，它就彻底失败了。首先，为了使用布尔型遮罩，我们使用了过滤器！()方法。没问题，它有点不太优雅，但不管怎样，它工作得非常好。但是总的来说，在朱莉娅的字典中，有一个非常重要的问题很少被提及，这让我很惊讶。</p><p id="a635" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Julia的字典命名方案使用符号而不是字符串。这是一个很大的问题，因为我们所有键盘的底部都有一个邪恶的东西，</p><blockquote class="nf"><p id="82bf" class="ng nh it bd ni nj nk nl nm nn no lp dk translated">空格键。</p></blockquote><figure class="ph pi pj pk pl kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/b8e25710bbcb6983fe77d7f203dc95db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hAatn4p6clclGxM2nqxnFQ.png"/></div></div></figure><p id="0464" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如您所见，典型的字符串命名方案在Julia中不起作用。相反，Julia使用的符号是通过在变量名前加一个冒号创建的。所以让我们用一个符号来代替:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pm"><img src="../Images/68c37ceb06fb9e370e713b89e9f2fb2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LlGD9R4r0bIh_9CVT8dp4w.png"/></div></div></figure><p id="861d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">好的，这是可行的，但是我们如何用一个空格来做这件事呢？这是个大问题，如果名称中有空格，就没有办法访问这个列，根本没有办法。当然，大多数数据框的列名中没有空格，因为使用_比空格更合适，但是如果有呢？在Julia中唯一有意义的解决方案是打开CSV文件并更改其中的列名，这是一个大问题。</p><h1 id="020f" class="mi mj it bd mk ml on mn mo mp oo mr ms jz op ka mu kc oq kd mw kf or kg my mz bi translated">结论</h1><blockquote class="nf"><p id="534d" class="ng nh it bd ni nj nk nl nm nn no lp dk translated">我喜欢熊猫。</p></blockquote><p id="e4bb" class="pw-post-body-paragraph ku kv it kw b kx np ju kz la nq jx lc ld nr lf lg lh ns lj lk ll nt ln lo lp im bi translated">Pandas是一个非常棒的包，它让数据科学在很大程度上变得非常容易。我当然希望DataFrames.jl可以模仿Pandas为Python数据科学社区所创造的东西。熊猫真正伟大的地方在于它周围的整个技术体系如何与它无缝衔接。</p><blockquote class="nf"><p id="0881" class="ng nh it bd ni nj nk nl nm nn no lp dk translated">Python世界当然是一个美丽的世界。</p></blockquote></div></div>    
</body>
</html>