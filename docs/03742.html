<html>
<head>
<title>Memoization in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中的记忆化</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/memoization-in-python-57c0a738179a?source=collection_archive---------1-----------------------#2020-04-08">https://towardsdatascience.com/memoization-in-python-57c0a738179a?source=collection_archive---------1-----------------------#2020-04-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1b5a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">记忆入门</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c97345ee5f894d352f9da811b7dd2374.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FVoZ2l7PdWq8oy1ABCIhpA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://www.pexels.com/photo/camera-photography-vintage-travel-46794/" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="98f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记忆化(Memoization)是唐纳德·米基(Donald Michie)在 1968 年引入的一个术语，它来自拉丁语单词备忘录(要记住)。记忆是计算机科学中使用的一种方法，通过存储(记住)过去的计算来加速计算。如果使用相同的参数进行重复的函数调用，我们可以存储以前的值，而不是重复不必要的计算。在这篇文章中，我们将使用记忆化来寻找斐波那契数列中的项。</p><p id="d6cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们开始吧！</p><p id="5507" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们定义一个递归函数，我们可以用它来显示斐波纳契数列中的第一个<em class="lv"> n </em>项。如果你对递归不熟悉，可以看看这篇文章:<a class="ae ky" rel="noopener" target="_blank" href="/recursion-in-python-b026d7dde906"><em class="lv">Python 中的递归</em> </a> <em class="lv">。</em></p><p id="273b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提醒一下，斐波纳契数列是这样定义的，每个数字都是前两个数字的和。例如，斐波纳契数列的前 6 项是 1，1，2，3，5，8。我们可以将递归函数定义如下:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="f234" class="mb mc it lx b gy md me l mf mg">def fibonacci(input_value):<br/>    if input_value == 1:<br/>        return 1<br/>    elif input_value == 2:<br/>        return 1<br/>    elif input_value &gt; 2:<br/>        return fibonacci(input_value -1) + fibonacci(input_value -2)</span></pre><p id="0636" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们指定了基本情况，即如果输入值等于 1 或 2，则返回 1。如果输入值大于 2，则返回对前两个斐波那契值求和的递归函数调用。</p><p id="2950" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们打印前 10 个术语:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="c837" class="mb mc it lx b gy md me l mf mg">for i in range(1, 11):<br/>     print("fib({}) = ".format(i), fibonacci(i))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/cd2276699e8d2d2785eeb711281320e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:432/format:webp/1*LBhatMQDWtw9GAKBValTJw.png"/></div></figure><p id="7da8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这似乎运行良好。现在，让我们尝试显示前 200 个术语:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="9852" class="mb mc it lx b gy md me l mf mg">for i in range(1, 201):<br/>     print("fib({}) = ".format(i), fibonacci(i))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/f3effc7d3d98285115239ea0da231cca.png" data-original-src="https://miro.medium.com/v2/resize:fit:568/format:webp/1*LCgCkenrcK36Tvamd5KEfA.png"/></div></figure><p id="5a12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将会发现，在 fib(20)之后，后续计算将会比之前的计算花费更长的时间。这是因为每次后续计算我们都在做重复的工作。</p><p id="d339" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑递归函数如何计算每一项:</p><p id="5473" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">纤维(1) = 1</p><p id="bf02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">纤维(2) = 1</p><p id="5df0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">纤维(3) =纤维(1) +纤维(2) = 2</p><p id="62f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">纤维(4) =纤维(3) +纤维(2) = 3</p><p id="6f1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">纤维(5) =纤维(4) +纤维(3) = 5</p><p id="0ab7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，对于 fib(5 ),我们重复 fib(4)和 fib(3)的计算。如果我们有办法在计算时记住/存储这些值，我们就会避免重复计算。这就形成了记忆法的动机。</p><p id="1e37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们浏览一下实现记忆化方法的步骤。为了继续，让我们初始化一个字典:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="ba67" class="mb mc it lx b gy md me l mf mg">fibonacci_cache = {}</span></pre><p id="bde8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将定义记忆函数。首先，我们检查作为字典键的输入是否存在于字典中。如果键存在，我们返回对应于输入/键的值:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="bff2" class="mb mc it lx b gy md me l mf mg">def fibonacci_memo(input_value):<br/>        if input_value in fibonacci_cache:<br/>            return fibonacci_cache[input_value]</span></pre><p id="be74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们定义基本案例，它们对应于前两个值。如果输入值是 1 或 2，那么我们将该值设置为 1:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="6a55" class="mb mc it lx b gy md me l mf mg">def fibonacci_memo(input_value):<br/>    ...</span><span id="8af0" class="mb mc it lx b gy mj me l mf mg">    if input_value == 1:<br/>        value = 1<br/>    elif input_value == 2:<br/>        value = 1</span></pre><p id="28f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们考虑递归情况。如果输入大于 2，我们将该值设置为等于前两项之和:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="f92f" class="mb mc it lx b gy md me l mf mg">def fibonacci_memo(input_value):<br/>    ...<br/>    elif input_value &gt; 2:           <br/>        value =  fibonacci_memo(input_value -1) + fibonacci_memo(input_value -2)</span></pre><p id="ca8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们将该值存储在字典中并返回该值:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="dcf0" class="mb mc it lx b gy md me l mf mg">def fibonacci_memo(input_value):<br/>    ...<br/>    fibonacci_cache[input_value] = value<br/>    return value</span></pre><p id="6d48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完整的功能是:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="5eb5" class="mb mc it lx b gy md me l mf mg">def fibonacci_memo(input_value):<br/>    if input_value in fibonacci_cache:<br/>        return fibonacci_cache[input_value]<br/>    if input_value == 1:<br/>            value = 1<br/>    elif input_value == 2:<br/>            value = 1<br/>    elif input_value &gt; 2:           <br/>            value =  fibonacci_memo(input_value -1) + fibonacci_memo(input_value -2)<br/>    fibonacci_cache[input_value] = value<br/>    return value</span></pre><p id="a29e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们尝试用新函数显示前 200 个术语:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="1ffb" class="mb mc it lx b gy md me l mf mg">for i in range(1, 201):<br/>     print("fib({}) = ".format(i), fibonacci_memo(i))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mk"><img src="../Images/b8ab66b3335ce6e43817bedd9a0257b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UcIyB8pxaTLEcQvpROAW6A.png"/></div></div></figure><p id="977a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在运行我们的脚本时，我们看到我们相当快地到达了序列中的第 200 项。</p><p id="6f15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一种更简单的方法可以用更少的代码实现记忆化。让我们考虑一下我们最初的递归函数:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="1f90" class="mb mc it lx b gy md me l mf mg">def fibonacci(input_value):<br/>    if input_value == 1:<br/>        return 1<br/>    elif input_value == 2:<br/>        return 1<br/>    elif input_value &gt; 2:<br/>        return fibonacci(input_value -1) + fibonacci(input_value -2)</span></pre><p id="6cf3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以从“functools”模块导入一个名为“lru_cache”的装饰器，它允许我们缓存我们的值。该名称代表“最近最少使用的缓存”。使用这个装饰器，我们可以获得与‘Fibonacci _ memo’方法相同的性能:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="51dd" class="mb mc it lx b gy md me l mf mg">from functools import lru_cache</span><span id="b6d6" class="mb mc it lx b gy mj me l mf mg"><a class="ae ky" href="http://twitter.com/lru_cache" rel="noopener ugc nofollow" target="_blank">@lru_cache</a>(maxsize = 1000)<br/>def fibonacci(input_value):<br/>    if input_value == 1:<br/>        return 1<br/>    elif input_value == 2:<br/>        return 1<br/>    elif input_value &gt; 2:<br/>        return fibonacci(input_value -1) + fibonacci(input_value -2)</span><span id="28f4" class="mb mc it lx b gy mj me l mf mg">for i in range(1, 201):<br/>     print("fib({}) = ".format(i), fibonacci(i))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mk"><img src="../Images/b8ab66b3335ce6e43817bedd9a0257b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UcIyB8pxaTLEcQvpROAW6A.png"/></div></div></figure><p id="237d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到我们实现了相似的性能。我就讲到这里，但是我鼓励你自己去研究代码。</p><h1 id="00ea" class="ml mc it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">结论</h1><p id="429d" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">总之，在这篇文章中，我们讨论了 python 中的记忆方法。首先，我们展示了在计算斐波纳契数列中的许多项之后，递归函数的简单实现是如何变得非常慢的。然后，我们定义了一个新方法，在这个方法中，我们将过去计算的值存储在一个字典中。这导致了计算的显著加速。然后我们讨论了“lru_cache”装饰器，它允许我们用更少的代码实现与“fibonacci_memo”方法相似的性能。如果你有兴趣了解更多关于记忆化的知识，我鼓励你去看看<a class="ae ky" href="https://www.youtube.com/watch?v=Qk0zUZW-U_M&amp;t=302s" rel="noopener ugc nofollow" target="_blank">苏格拉底的 YouTube 教程</a>。我希望你觉得这篇文章有用/有趣。这篇文章中的代码可以在<a class="ae ky" href="https://github.com/spierre91/medium_code/blob/master/data_structures_and_algorithms/memo_fibonacci.py" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。感谢您的阅读！</p></div></div>    
</body>
</html>