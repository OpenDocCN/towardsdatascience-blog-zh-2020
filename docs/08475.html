<html>
<head>
<title>Solving Mazes With Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python解迷宫</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/solving-mazes-with-python-f7a412f2493f?source=collection_archive---------6-----------------------#2020-06-20">https://towardsdatascience.com/solving-mazes-with-python-f7a412f2493f?source=collection_archive---------6-----------------------#2020-06-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ee8d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Dijkstra的算法和OpenCV</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/441daf3b456cb50e19f2609bfc331054.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HGreqVCYeYtzEMfF"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@mitchel3uo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">米切尔罗</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="f265" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">迷宫对人类来说往往是简单的谜题，但它们提出了一个很大的编程问题，我们可以使用最短路径技术来解决，如Dijkstra算法。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1d05" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">关于Dijkstra算法的复习</h1><p id="3157" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Dijkstra算法是比较流行的基本图论算法之一。它用于在<a class="ae ky" href="https://en.wikipedia.org/wiki/Directed_graph" rel="noopener ugc nofollow" target="_blank">有向图</a>上寻找节点间的最短路径。我们从一个源节点和节点之间的已知边长开始。</p><p id="ac15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们首先给所有节点分配一个到源的距离值。节点<em class="mz"> s </em>接收0值，因为它是源；其余的接收值为∞开始。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/37b445177bfec5d71944c01c40b404bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k7m08sftFpnLzziiZ0Iy9w.png"/></div></div></figure><p id="004d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们感兴趣的节点是最小值的未处理节点(显示为灰色)，即<em class="mz"> s </em>。首先，我们“放松”感兴趣节点的每个相邻顶点，将它们的值更新为其当前值或感兴趣节点的值加上连接边长度的最小值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/f81a47c3e8a6ca28455ca5adb1053388.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*btifUJC-z-jC2JL1ZffBsg.png"/></div></div></figure><p id="46f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">节点<em class="mz"> s </em>现已完成(黑色),其邻居<em class="mz"> a </em>和<em class="mz"> b </em>已采用新值。感兴趣的新节点是<em class="mz"> b </em>，因此我们重复“放松”<em class="mz"> b </em>的相邻节点并最终确定<em class="mz"> b </em>的最短路径值的过程。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/4c78835909fcad29fb68b73cf43c0340.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gHxrGeUPA_cVJ7FgxMiI8Q.png"/></div></div></figure><p id="3577" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">遍历每个节点后，我们最终会得到一个图，显示从源到每个节点的最短路径长度。</p><div class="kj kk kl km gt ab cb"><figure class="nc kn nd ne nf ng nh paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/a20c81a875f15b1c9a42ea4d4583fa12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*ftxrqCemBe2E7XX8-p9T_A.png"/></div></figure><figure class="nc kn ni ne nf ng nh paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/664aa72bcc4c0e9e0a9f80b254c6b17a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*Ftt1KwqlXU5BuQQftryTUw.png"/></div></figure></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/e72ce18c8c3dd8834996559a5eaec08e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s4yNrJU0qidwNtxzcZgNXw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">运行Dijkstra算法后的最终图表。每个节点中的数字代表与源节点的最短可能距离</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="18c2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">概念化迷宫图像</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/7b88d7bfa1eb8fc5e0ecf3db0692cc7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9YDXBRJ7jyT71mnZzJ3X8g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://freesvg.org/the-maze" rel="noopener ugc nofollow" target="_blank">freesvg.org</a></p></figure><p id="5f7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以把图像想象成一个像素矩阵。每个像素(为简单起见)的RGB值为0，0，0(黑色)或255，255，255(白色)。我们的目标是创建一条最短的路径，它从白色开始，并且不跨越黑色边界。为了表示这一目标，我们可以将每个像素视为一个节点，并在相邻像素之间绘制边缘，边缘长度基于RGB值的差异。我们将使用<a class="ae ky" href="https://en.wikipedia.org/wiki/Color_difference#Euclidean" rel="noopener ugc nofollow" target="_blank">欧几里德平方距离</a>公式，并添加0.1以确保没有零距离路径长度(Dijkstra算法的要求):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/73826d88f06bce1a01ef0c37d07a9c19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*ZVEbby2yKdIfv7qOOSxqVw.jpeg"/></div></figure><p id="740f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个公式使得穿过迷宫边界的距离非常大。正如我们所见，从源到目的地的最短路径显然是绕过障碍，而不是穿过障碍。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/93396b88a7c23bc5a78be7753bcd02f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/1*Xccrpgo6hokbvtO3qcUYRw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用我们的欧几里德平方颜色距离公式显示的路径长度</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c9dd" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">履行</h1><p id="e107" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们可以使用OpenCV，一个流行的用于Python的<a class="ae ky" href="https://neptune.ai/blog/image-processing-python" rel="noopener ugc nofollow" target="_blank">图像处理</a>库，来提取像素值并显示我们的迷宫图像。让我们通过在迷宫中添加点来确定起点和终点的坐标</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="0183" class="nr md it nn b gy ns nt l nu nv">import cv2<br/>import matplotlib.pyplot as plt<br/>import numpy as np</span><span id="809a" class="nr md it nn b gy nw nt l nu nv">img = cv2.imread('maze.png') # read an image from a file using<br/>cv2.circle(img,(5,220), 3, (255,0,0), -1) # add a circle at (5, 220)<br/>cv2.circle(img, (25,5), 3, (0,0,255), -1) # add a circle at (5,5)<br/>plt.figure(figsize=(7,7))<br/>plt.imshow(img) # show the image<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/b8a7800596cff4c8da875495f656b676.png" data-original-src="https://miro.medium.com/v2/resize:fit:570/format:webp/1*I85ZjwWhjr6IExUcESFlQQ.png"/></div></figure><p id="b10d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们创建一个顶点类来帮助我们跟踪坐标。我们还希望跟踪父节点，这样一旦找到距离值，我们就可以重建整个路径。</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="87bc" class="nr md it nn b gy ns nt l nu nv">class Vertex:<br/>    def __init__(self,x_coord,y_coord):<br/>        self.x=x_coord<br/>        self.y=y_coord<br/>        self.d=float('inf') #current distance from source node<br/>        self.parent_x=None<br/>        self.parent_y=None<br/>        self.processed=False<br/>        self.index_in_queue=None</span></pre><p id="795f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要创建一个顶点矩阵，代表图像中像素的2D布局。这将是我们Dijkstra算法图的基础。我们还维护了一个最小堆优先级队列来跟踪<em class="mz">未处理的</em>节点。</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="9391" class="nr md it nn b gy ns nt l nu nv">def find_shortest_path(img,src,dst):<br/>    pq=[] #min-heap priority queue</span><span id="464e" class="nr md it nn b gy nw nt l nu nv">    imagerows,imagecols=img.shape[0],img.shape[1]<br/>    matrix = np.full((imagerows, imagecols), None) <br/>    #access matrix elements by matrix[row][col]</span><span id="8c52" class="nr md it nn b gy nw nt l nu nv">    #fill matrix with vertices<br/>    for r in range(imagerows):<br/>        for c in range(imagecols):<br/>            matrix[r][c]=Vertex(c,r)<br/>            matrix[r][c].index_in_queue=len(pq)<br/>            pq.append(matrix[r][c])</span><span id="c947" class="nr md it nn b gy nw nt l nu nv">    #set source distance value to 0<br/>    matrix[source_y][source_x].d=0</span><span id="7e34" class="nr md it nn b gy nw nt l nu nv">    #maintain min-heap invariant (minimum d Vertex at list index 0)<br/>    pq = bubble_up(pq, matrix[source_y][source_x].index_in_queue)</span></pre><p id="a34b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要几个辅助函数来帮助寻找顶点之间的边和边长:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="f244" class="nr md it nn b gy ns nt l nu nv">#Implement euclidean squared distance formula<br/>def get_distance(img,u,v):<br/>    return 0.1 + (float(img[v][0])-float(img[u][0]))**2+(float(img[v][1])-float(img[u][1]))**2+(float(img[v][2])-float(img[u][2]))**2</span><span id="f6ae" class="nr md it nn b gy nw nt l nu nv">#Return neighbor directly above, below, right, and left<br/>def get_neighbors(mat,r,c):<br/>    shape=mat.shape<br/>    neighbors=[]<br/>    #ensure neighbors are within image boundaries<br/>    if r &gt; 0 and not mat[r-1][c].processed:<br/>         neighbors.append(mat[r-1][c])<br/>    if r &lt; shape[0] - 1 and not mat[r+1][c].processed:<br/>            neighbors.append(mat[r+1][c])<br/>    if c &gt; 0 and not mat[r][c-1].processed:<br/>        neighbors.append(mat[r][c-1])<br/>    if c &lt; shape[1] - 1 and not mat[r][c+1].processed:<br/>            neighbors.append(mat[r][c+1])<br/>    return neighbors</span></pre><p id="c5ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以实现Dijkstra算法，并将距离(<em class="mz"> d </em>)值分配给迷宫图像中的所有像素顶点:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="4a98" class="nr md it nn b gy ns nt l nu nv">while len(pq) &gt; 0:<br/>    u=pq[0] #smallest-value unprocessed node</span><span id="0123" class="nr md it nn b gy nw nt l nu nv">    #remove node of interest from the queue<br/>    pq[0]=pq[-1] <br/>    pq[0].index_in_queue=0<br/>    pq.pop()<br/>    pq=bubble_down(pq,0) #min-heap function, see source code <br/>    <br/>    u.processed=True</span><span id="777a" class="nr md it nn b gy nw nt l nu nv">    neighbors = get_neighbors(matrix,u.y,u.x)<br/>    for v in neighbors:<br/>        dist=get_distance(img,(u.y,u.x),(v.y,v.x))<br/>        if u.d + dist &lt; v.d:<br/>            v.d = u.d+dist<br/>            v.parent_x=u.x #keep track of the shortest path<br/>            v.parent_y=u.y<br/>            idx=v.index_in_queue<br/>            pq=bubble_down(pq,idx) <br/>            pq=bubble_up(pq,idx)</span></pre><p id="1316" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以调用最短路径函数，并在迷宫上画出解决方案:</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="41c8" class="nr md it nn b gy ns nt l nu nv">img = cv2.imread('maze.png') # read an image from a file using opencv (cv2) library<br/>p = find_shortest_path(img, (25,5), (5,220))<br/>drawPath(img,p)<br/>plt.figure(figsize=(7,7))<br/>plt.imshow(img) # show the image on the screen <br/>plt.show()</span></pre><div class="kj kk kl km gt ab cb"><figure class="nc kn ny ne nf ng nh paragraph-image"><img src="../Images/7169b39394fddf7f2c9461c6e89acb93.png" data-original-src="https://miro.medium.com/v2/resize:fit:450/format:webp/1*Y-_xHCSrlZ_-KjZ-AtdGCQ.png"/></figure><figure class="nc kn ny ne nf ng nh paragraph-image"><img src="../Images/3e890e4aa43ef473cf7349cf50f2a75d.png" data-original-src="https://miro.medium.com/v2/resize:fit:450/format:webp/1*9Xwz2E-MTZxd_v-PKW_qzw.png"/></figure></div><p id="b616" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们试试网络上的其他迷宫。</p><div class="kj kk kl km gt ab cb"><figure class="nc kn ny ne nf ng nh paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/bdecb92e38c40246e17782d2ce61a96c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*2is6SJe8uI7YnPP9O1_pMQ.jpeg"/></div></figure><figure class="nc kn ny ne nf ng nh paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/e60676cf1ea7bbcfcab66ba45e461ddf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*G30lmiIsoQHGfz1EXQApuA.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk nz di oa ob translated">来源:Pinterest<a class="ae ky" href="https://www.pinterest.com/pin/425168021068848034/" rel="noopener ugc nofollow" target="_blank">上的莎伦·莱曼</a></p></figure></div><div class="ab cb"><figure class="nc kn ny ne nf ng nh paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/3762b1f05a545060064d3aa8b64c23c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*BCBzSfjnY2XiWgJzPPvZ4g.png"/></div></figure><figure class="nc kn ny ne nf ng nh paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/bca0f40de724525957cda090ad1c2017.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*5pjUIu0oCRp3iEGsl-aL5A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk nz di oa ob translated">来源:<a class="ae ky" href="https://freesvg.org/the-maze" rel="noopener ugc nofollow" target="_blank">freesvg.org</a></p></figure></div><p id="8b48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完整的源代码可以在GitHub <a class="ae ky" href="https://github.com/maxwellreynolds/Maze" rel="noopener ugc nofollow" target="_blank">上找到，这里是</a>和第2部分，下面是为迷宫解算器创建用户界面:</p><div class="oc od gp gr oe of"><a href="https://medium.com/@maxwellreynolds/building-a-simple-ui-for-python-fd0e5f2a2d8b" rel="noopener follow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd iu gy z fp ok fr fs ol fu fw is bi translated">为Python构建一个简单的UI</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">Streamlit:一个基于浏览器的Python UI，不需要HTML/CSS/JS</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">medium.com</p></div></div><div class="oo l"><div class="op l oq or os oo ot ks of"/></div></div></a></div></div></div>    
</body>
</html>