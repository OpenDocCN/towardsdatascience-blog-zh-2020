# 每天 10 分钟学习 Python 10

> 原文：<https://towardsdatascience.com/learning-python-10-minutes-a-day-17-10fd0642a202?source=collection_archive---------70----------------------->

![](img/861a215f083567059b0616591c415d2f.png)

[杰瑞米·拉帕克](https://unsplash.com/@jeremy_justin?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)在 [Unsplash](/?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上的原始照片。

## [每天 10 分钟 Python 速成班](https://towardsdatascience.com/tagged/10minutespython)

## 列表理解和地图:一个惊人的捷径

这是一个[系列](https://python-10-minutes-a-day.rocks)10 分钟的简短 Python 文章，帮助您提高 Python 知识。我试着每天发一篇文章(没有承诺)，从最基础的开始，到更复杂的习惯用法。如果您对 Python 的特定主题有任何问题或要求，请随时通过 LinkedIn 联系我。

Python 的关键元素之一是它的可读性。这种语言迫使你使用缩进来应用结构，这在我看来非常赏心悦目。Python 的关键思想也可以在[*Python 的禅*](https://en.wikipedia.org/wiki/Zen_of_Python) 中找到。它是解释器中众多复活节彩蛋中的一个(只需键入' *import this* ')。其中一个非常酷的习惯用法是理解。理解，或者更经常被称为*列表理解*，因为它们最经常与列表一起使用，是创建列表的一种有点抽象的方式。它们将某种处理步骤与一个循环结合在一起，以填充一个新的列表。为了更清楚地说明这一点，让我们把传统的舞步和积木上的酷小子做个比较:

在传统的循环中，首先需要定义一个空列表。接下来是一个 for 循环，遍历所有计算，并将所有计算结果追加到新的列表中。这三行可以使用 list comprehension 合并成一行，但不会牺牲可读性。在列表理解中，即在由括号标识的列表定义中，有一个 for 循环。这个 for 循环定义了一个用于迭代的变量，我们可以自由选择。我们常常很懒，选择短字母，如 *x* 、 *y* 和 *z* 。尽管如此，使用描述性名称是更好的做法。for 循环的行为与常规 for 循环相同，并在整个 iterable 上迭代。我们可以压缩多个 iterables 或者使用 enumerate，但是我们也需要解包所有额外的变量(或者将它们作为一个元组使用)。需要记住的一件事是，列表理解会创建一个新的列表，即使我们复制了每一个条目并且有相同的列表。理解几乎可以在任何地方工作，并且可以在函数中使用。他们也可以使用字典和集合，但是当然，每个数据类型的定义必须是正确的。

一般来说，理解的语法是:*iterable*中项目的表达式。由于理解的结果又是可重复的，我们也可以将多个理解嵌套成一个。虽然这很好，但是要记住可读性可能会下降。因此，将你的超级一行改为两行并不是一个坏习惯。

与内联 for 循环一样，我们也可以使用内联 if 语句。我认为对于一般的用法，内联 if 语句会增加代码的混乱，降低可读性。然而，我们可以在理解中使用 if 语句，对于这种用例，它们有时非常简洁。

列表理解是缩短代码的一个很好的方法，而且通常不会牺牲可读性。与内联的 if 语句一起，这是一种创建过滤项目列表的简单方法。另一个非常类似的方法是 *map()* 函数。这个函数在列表的每一项上映射一个函数，并返回一个包含所有返回值的新列表。使用 for 循环或理解也可以达到同样的效果，但是 map 函数的可读性更好一些，因此，我认为了解以下内容是很有用的:

函数的第一个参数是对函数的引用，第二个参数是 iterable。然而，它返回的结果不是一个列表，而是一个 map-object。map-object 是一种生成器，所以它只在被请求时计算值。这在大多数情况下效率更高，消耗的内存更少。为了查看完整的列表，我们将 map-object 转换成一个列表。正如我们在这里所做的，处理容易*映射*的数据也更容易并行化(在计算机的多个内核上并行运行)。Python 有多处理包，为 CPU 密集型任务提供了多处理映射功能。

# 今天的练习:

理解是过滤列表结构数据或组合相似任务的一个好方法。我经常做的事情是，例如在列表理解中读取 CSV 文件，产生 CSV 熊猫数据帧列表。使用 Pandas 中的 *concat* 功能，我可以在一行中合并所有导入的文件，得到一个包含所有数据的组合数据框。另一个很好的用法是有选择地将值放入列表中。这就是我们今天要练习的，用它来近似圆周率。

**作业:** 今天我们要用[莱布尼茨公式](https://en.wikipedia.org/wiki/Leibniz_formula_for_%CF%80)来近似π的值。莱布尼茨公式是一个交替的级数(它改变每个值的符号),当对无穷多个值的级数求和时，你得到圆周率。问题是，我们没有无限的内存，因此，我们截断了这个值，并近似圆周率。莱布尼茨公式指出圆周率 4 等于下面给出的交替级数:

```
π / 4 = 1/1 - 1/3 + 1/5 - 1/7 + 1/9 - 1/11 + .....
```

为了解决这个问题，我们可以将它分成几个步骤:
a)为所有奇数
创建一个列表理解 b)使用另一个列表理解使每个第二个值为负
c)使用另一个列表理解，将每个值转换为 1 除以 x
d)将整个列表求和并乘以 4 以获得π的近似值 e)增加数字的数量( *n* )以获得更好的近似值。

**提示:**
1。使用 range 获得一个数值 n 以内的数字列表(range(n))。
2。用 2 的模数检查是否是偶数/奇数
3。要获得每一秒的数字，请将 enumerate 与模数一起使用。

```
import math
actual_pi = math.pin = 100  # amount of numbers
```

我已经在我的 Github 上发布了[解决方案](https://gist.github.com/dennisbakhuis/a4fe1d3feac0e46bcb76b6c223ccfabd)。

如有任何问题，欢迎通过 [LinkedIn](https://www.linkedin.com/in/dennisbakhuis/) 联系我。