<html>
<head>
<title>Building a Youtube music recommender</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建Youtube音乐推荐器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-a-youtube-music-recommender-bbd1b3431da4?source=collection_archive---------31-----------------------#2020-03-29">https://towardsdatascience.com/building-a-youtube-music-recommender-bbd1b3431da4?source=collection_archive---------31-----------------------#2020-03-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4dbc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从无到有:向你推荐youtube音乐视频</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c42322ce14153a5990c004644e76092f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oph1PynSCUMwLNVMgAhWzA.jpeg"/></div></div></figure><h1 id="172b" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">概观</h1><p id="860d" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在这篇文章中，我将对一个简单的向自己推荐Youtube音乐视频的解决方案的一些细节进行评论。你可以通过<a class="ae mi" href="https://thawing-shore-99052.herokuapp.com/" rel="noopener ugc nofollow" target="_blank"> Youtube音乐推荐</a>查看Heroku上部署的解决方案。我知道，这不美。也许有一天我会发展我的前端技能。</p><p id="0bfc" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">然后，这里的主要思想是从零开始到部署。这个过程主要包括以下所有步骤:</p><ol class=""><li id="3d96" class="mo mp it lo b lp mj ls mk lv mq lz mr md ms mh mt mu mv mw bi translated">删除Youtube页面上的视频数据；</li><li id="ffce" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">从每个页面中提取视频信息；</li><li id="6b49" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">将来自每个视频的数据预处理成单个数据集；</li><li id="ed5b" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">手动标记一些样本，主动学习其余的样本；</li><li id="36cf" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">从数据集中提取要素；</li><li id="4241" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">训练一个随机森林和一个LightGBM模型并集成它们；</li><li id="46f7" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">通过Heroku建立一个简单的应用程序来服务模型。</li></ol><p id="2d78" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">此外，如果你想查看<a class="ae mi" href="https://github.com/lmeazzini/youtube-recommender" rel="noopener ugc nofollow" target="_blank">代码</a>，我会引用每个步骤中使用的脚本。</p><div class="nc nd gp gr ne nf"><a href="https://github.com/lmeazzini/youtube-recommender" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd iu gy z fp nk fr fs nl fu fw is bi translated">lmeazzini/YouTube-推荐者</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">这是一个简单的youtube视频推荐器。解决方案可以在Heroku上看到，网址是…</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">github.com</p></div></div><div class="no l"><div class="np l nq nr ns no nt ks nf"/></div></div></a></div><blockquote class="nu nv nw"><p id="ed24" class="lm ln nx lo b lp mj ju lr ls mk jx lu ny ml lx ly nz mm mb mc oa mn mf mg mh im bi translated"><strong class="lo iu">我们开始吧！</strong></p></blockquote><h1 id="bcc2" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">删除Youtube页面上的视频数据</h1><p id="98ef" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">首先，我们需要数据！为了获得一些数据，我通过在youtube搜索上查询来废弃Youtube页面。因为我正在寻找推荐给自己的音乐，所以我使用了六个查询:</p><blockquote class="nu nv nw"><p id="de96" class="lm ln nx lo b lp mj ju lr ls mk jx lu ny ml lx ly nz mm mb mc oa mn mf mg mh im bi translated">民谣摇滚、古典吉他、原声摇滚、管弦乐摇滚、大提琴歌曲和巴西摇滚</p></blockquote><p id="80cf" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">然后，我保存了每个查询的前100页。这在“search_data_collection.py”脚本中完成。</p><h1 id="c3b0" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">从每个页面中提取视频信息</h1><p id="6309" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">现在我们有了来自Youtube搜索页面的数据，我们需要从这些页面上的视频中提取信息。为此，我用<a class="ae mi" href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/" rel="noopener ugc nofollow" target="_blank"> BeautifulSoup </a>制作了一个解析器。</p><p id="51ef" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">这个解析器只保存600页中每个视频的链接、标题和查询。此外，由于有可能的视频被复制，我放弃了重复。这在“search_data_parsing.py”脚本中完成。</p><h1 id="4b51" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">将来自每个视频的数据预处理成单个数据集</h1><p id="0bf3" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">从解析的数据中，我们能够对每个视频进行网络剪辑。这里有很多信息，我们能得到的大部分特征都来自这一步。因为这是一个简单的解决方案，而且我没有花太多时间来设计特性，所以我只使用了几种可能性。</p><p id="50cb" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">总共有2277个视频，那么这个脚本需要相当长的鳄龙时间来运行，大约2小时。脚本名为“video_data_processing.py”</p><h1 id="a42f" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">可能通过主动学习手动标记一些样本</h1><p id="dbc3" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">这项工作中最单调乏味的部分。我必须得到标签。因此，我在sheets上打开了上一步生成的raw_data文件，添加了一个“y”列，并用0或1手动填充了1000行。</p><p id="89eb" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">使用标记的数据，可以训练随机森林模型和下一步提取的特征，并使用该模型来识别哪些样本最难分类(~0.5输出)，然后我手动标记了200个通过主动学习识别的样本。</p><p id="675f" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">主动学习有助于降低标记成本。然而，我期望花费的标注时间比我想象的要少，所以我结束了手动标注。</p><h1 id="205c" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">从视频数据中提取特征</h1><p id="49b4" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">现在，我们数据集的每一行都是一个视频及其数据，如标题、浏览量、作者、描述、视频高度、视频宽度和其他信息。从这些字段中，我做了特征工程，提取出一些可以对后面有帮助的特征。</p><p id="c29b" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">这样，我提取了浏览量、日均浏览量、视频分辨率，用标题串做了一袋字(BoW)。当然，还有更多的特征可以提取，尤其是从视频描述和视频标签中。但是，我把更深层次的特征工程留给了以后的作品。</p><h1 id="496c" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">训练一个随机的森林和一个LightGBM模型，并使它们变得安全</h1><p id="8efa" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">利用提取的特征和标签，我们可以在训练和验证中分割数据集。我选择不做测试集，把最终的验证留给生产数据。</p><p id="b37c" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">首先，我训练了一个LightGBM模型，用贝叶斯优化优化了它的参数以及一些数据预处理参数(比如BoW的n_gram范围)。然后，用基于贝叶斯搜索的相同预处理参数训练随机森林模型。更多细节，可以查看实现。我寻找这两个模型的集合，给每个模型一个权重。</p><p id="ed53" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">为了衡量模型的表现，我选择不使用精度、召回率和F1值。由于问题涉及到一个建议，最终的输出应该是最相关的建议的排序(输出更接近1)。然后我用了average_precision_score，roc_auc，log_loss来更好的评估模型。</p><p id="edfd" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">此外，我做了一个学习曲线分析(LCA ),以检查所使用的数据是否足以进行一致的预测。ROC曲线和LCA可以在下图中看到。特征提取和建模在“final_model.py”上进行</p><div class="kj kk kl km gt ab cb"><figure class="ob kn oc od oe of og paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/f39a53f362bd262a3f5fe4cc1e0d977b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*PycPAy--SmCtudklakiZLQ.png"/></div></figure><figure class="ob kn oc od oe of og paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/10fd8f4fb4e0346efdb2854b3b167360.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*wiqWjxlZ2qvvMmUvF9fltg.png"/></div></figure></div><h1 id="d397" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">通过Heroku构建一个简单的应用程序来服务模型</h1><p id="6a17" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">现在我们有了模型，我们可以创建一个应用程序来预测生产数据。由于我们的数据来自youtube搜索，如果我们使用用于生成数据集的相同查询，我们可能会获得用于训练/验证模型的相同或几乎相同的视频。然后，我修改了大多数查询，以便在应用程序中获得不同的视频。</p><p id="8884" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">这个过程包括一个用Flask构建的应用程序(app.py)。这个脚本负责调用函数来丢弃新数据，处理新数据，并使用保存的模型来预测输出，最后生成。html文件来显示最终输出。废弃的数据被预处理并存储在SQLite数据库中，然后被查询以进行预测，这样以后我可以向数据库中插入新数据，并轻松地重新运行应用程序。</p><p id="cd98" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">为了部署它，我使用了Docker和Gunicorn。部署文件夹中有一个包含该配置的docker文件。您可以轻松地在本地运行docker，甚至通过Heroku部署它，我已经按照Heroku文档上的<a class="ae mi" href="https://devcenter.heroku.com/articles/container-registry-and-runtime" rel="noopener ugc nofollow" target="_blank">指南</a>完成了。</p><p id="a0fc" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">您可以在下面看到部署的应用程序截图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/35c7e0791097a714f2f80b8800f376a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wUobw-f7QfAIjGenJPDZ4Q.png"/></div></div></figure><p id="7ce9" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">然而，如果你现在打开它，音乐列表可能会与截图相同或非常相似。这可能是由于音乐不会随着时间的推移而发生很大变化，模型只是在我需要时进行重新分类；没有重新训练计划。</p><h1 id="1a26" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">最后</h1><p id="a0c9" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">看看生产中的模型预测，有明显的偏差。很多推荐的视频标题上都有“官方音乐视频”这一串。大概这是一个没有太大意义的重功能。可以进行许多改进来提高模型性能并更好地理解预测。</p><p id="db22" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">希望这篇文章能给人以启发，并能帮助到任何阅读它的人。同样，这篇文章并没有描述每一步，但是，代码可以在<a class="ae mi" href="https://github.com/lmeazzini/youtube-recommender" rel="noopener ugc nofollow" target="_blank"> GitHub </a>获得。</p><div class="nc nd gp gr ne nf"><a href="https://github.com/lmeazzini/youtube-recommender" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd iu gy z fp nk fr fs nl fu fw is bi translated">lmeazzini/YouTube-推荐者</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">这是一个简单的youtube音乐/视频推荐器。您可以在Heroku上检查已部署的解决方案…</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">github.com</p></div></div><div class="no l"><div class="oi l nq nr ns no nt ks nf"/></div></div></a></div></div></div>    
</body>
</html>