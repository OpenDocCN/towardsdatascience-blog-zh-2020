<html>
<head>
<title>Asymmetric Encrypting of sensitive data in memory (Python)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">内存中敏感数据的非对称加密(Python)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/asymmetric-encrypting-of-sensitive-data-in-memory-python-e20fdebc521c?source=collection_archive---------22-----------------------#2020-03-16">https://towardsdatascience.com/asymmetric-encrypting-of-sensitive-data-in-memory-python-e20fdebc521c?source=collection_archive---------22-----------------------#2020-03-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="6ff8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有时需要在读取和写入周期之间加密数据，例如，我们有一个设备可以获取敏感数据并记录下来进行处理。但是，由于数据存储在写入数据的同一设备上，我们不希望使用用于加密数据的同一密钥来解密数据。这就是我们使用非对称加密的原因。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/7948ffe48a9b69b7fff6cb2061cea7a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KGUi-IAjd4QMpxYh"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">照片由<a class="ae le" href="https://unsplash.com/@rxspawn?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">弗洛里安·奥利佛</a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h2 id="6e67" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">不对称加密</h2><p id="6141" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">不对称加密对数据使用两个密钥(一个私钥和一个公钥)。这里，公钥用于每个单独的(易受攻击的)设备，仅用于加密数据。一旦加密，这些<em class="md">就不能被</em>用来解密。然而，私钥是一个只提供给所有者的密钥，用于读取加密数据。也可以用私钥加密数据，这样就只能用公钥来读取数据，但这是一种不好的做法，会导致比它所解决的问题更多的问题。</p><h2 id="ad0b" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">密码学 python 包</h2><p id="e45e" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">我们将要使用的 python 包叫做<code class="fe me mf mg mh b">cryptography</code>，可以使用<code class="fe me mf mg mh b">pip install cryptography</code>来安装。</p><h2 id="d07b" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">密钥生成</h2><p id="16dc" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">我们从导入所需的包开始:</p><pre class="kp kq kr ks gt mi mh mj mk aw ml bi"><span id="c445" class="lf lg it mh b gy mm mn l mo mp"><strong class="mh iu">import</strong> cryptography<br/><strong class="mh iu">from</strong> cryptography.hazmat.backends <strong class="mh iu">import</strong> default_backend<br/><strong class="mh iu">from</strong> cryptography.hazmat.primitives.asymmetric <strong class="mh iu">import</strong> rsa<br/><strong class="mh iu">from</strong> cryptography.hazmat.primitives <strong class="mh iu">import</strong> serialization</span></pre><p id="e2f1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们生成公钥和私钥。这些有两个参数—公共指数和密钥大小。公共指数是一个正质数(通常是<code class="fe me mf mg mh b">65537</code>)，密钥大小是模数的长度，以比特为单位(对于 2015 年的密钥，建议这些是<code class="fe me mf mg mh b">&gt;2048</code>比特)</p><pre class="kp kq kr ks gt mi mh mj mk aw ml bi"><span id="cbf5" class="lf lg it mh b gy mm mn l mo mp">private_key = rsa.generate_private_key(<br/>    public_exponent=65537,<br/>    key_size=2048,<br/>    backend=default_backend()<br/>)<br/>public_key = private_key.public_key()</span></pre><h2 id="d977" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">保存生成的密钥</h2><p id="e406" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">要保存生成的密钥，我们必须首先对它们进行序列化，然后将它们写入文件:</p><pre class="kp kq kr ks gt mi mh mj mk aw ml bi"><span id="7346" class="lf lg it mh b gy mm mn l mo mp"># private key<br/>serial_private = private_key.private_bytes(<br/>    encoding=serialization.Encoding.PEM,<br/>    format=serialization.PrivateFormat.PKCS8,<br/>    encryption_algorithm=serialization.NoEncryption()<br/>)<br/>with open('private_noshare.pem', 'wb') as f: f.write(serial_private)<br/>    </span><span id="12aa" class="lf lg it mh b gy mq mn l mo mp"># public key<br/>serial_pub = public_key.public_bytes(<br/>    encoding=serialization.Encoding.PEM,<br/>    format=serialization.PublicFormat.SubjectPublicKeyInfo<br/>)<br/>with open('public_shared.pem', 'wb') as f: f.write(serial_pub)</span></pre><h2 id="869e" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">读取加密密钥</h2><pre class="kp kq kr ks gt mi mh mj mk aw ml bi"><span id="369e" class="lf lg it mh b gy mm mn l mo mp"># make sure the following are imported<br/># from cryptography.hazmat.backends import default_backend<br/># from cryptography.hazmat.primitives import serialization</span><span id="8e27" class="lf lg it mh b gy mq mn l mo mp">#########      Private device only    ##########<br/>def read_private (filename = "private_noshare.pem):<br/>    with open(filename, "rb") as key_file:<br/>        private_key = serialization.load_pem_private_key(<br/>            key_file.read(),<br/>            password=None,<br/>            backend=default_backend()<br/>        )<br/>    return private_key<br/>                  <br/>######### Public (shared) device only ##########<br/>def read_public (filename = "public_shared.pem"):<br/>    with open("public_shared.pem", "rb") as key_file:<br/>        public_key = serialization.load_pem_public_key(<br/>            key_file.read(),<br/>            backend=default_backend()<br/>        )<br/>    return public_key</span></pre><h2 id="0a3c" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">加密</h2><p id="1bb7" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">为了存储一些敏感信息(例如一个人的体重),我们可以使用以下方法对其进行加密:</p><pre class="kp kq kr ks gt mi mh mj mk aw ml bi"><span id="9bb7" class="lf lg it mh b gy mm mn l mo mp"># make sure the following are imported<br/># from cryptography.hazmat.primitives import hashes<br/># from cryptography.hazmat.primitives.asymmetric import padding</span><span id="b79b" class="lf lg it mh b gy mq mn l mo mp">######### Public (shared) device only #########</span><span id="00f9" class="lf lg it mh b gy mq mn l mo mp">data = [b'My secret weight', b'My secret id']<br/>public_key = read_public()</span><span id="d8ae" class="lf lg it mh b gy mq mn l mo mp">open('test.txt', "wb").close() # clear file<br/>for encode in data:<br/>    encrypted = public_key.encrypt(<br/>        encode,<br/>        padding.OAEP(<br/>            mgf=padding.MGF1(algorithm=hashes.SHA256()),<br/>            algorithm=hashes.SHA256(),<br/>            label=None<br/>        )<br/>    )<br/>    <br/>    with open('test.txt', "ab") as f: f.write(encrypted)</span></pre><h2 id="615d" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">[通信]解密</h2><p id="39a0" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">由于每个数据段都编码在相同数量的字节中，因此可以分块读取文件。这允许我们读取和解码每个数据块，重新创建原始数据集。</p><pre class="kp kq kr ks gt mi mh mj mk aw ml bi"><span id="508f" class="lf lg it mh b gy mm mn l mo mp"># make sure the following are imported<br/># from cryptography.hazmat.primitives import hashes<br/># from cryptography.hazmat.primitives.asymmetric import padding</span><span id="3c71" class="lf lg it mh b gy mq mn l mo mp">#########      Private device only    ##########</span><span id="1695" class="lf lg it mh b gy mq mn l mo mp">read_data = []<br/>private_key = read_private()</span><span id="625b" class="lf lg it mh b gy mq mn l mo mp">with open('test.txt', "rb") as f:<br/>    for encrypted in f:<br/>        read_data.append(<br/>            private_key.decrypt(<br/>                encrypted,<br/>            padding.OAEP(<br/>                mgf=padding.MGF1(algorithm=hashes.SHA256()),<br/>                algorithm=hashes.SHA256(),<br/>                label=None<br/>            )))</span><span id="8a9a" class="lf lg it mh b gy mq mn l mo mp"># &gt;&gt;&gt; read_data = [b'My secret weight', b'My secret id']</span></pre><h2 id="5c58" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">结论</h2><p id="a407" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">所以你有它，一个简单的方法来加密数据(在内存中)，面向公众的设备，这样你就需要一个单独的密钥来解码它了。</p></div></div>    
</body>
</html>