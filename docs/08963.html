<html>
<head>
<title>Object Detection on Python Using Template Matching</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于模板匹配的 Python 对象检测</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/object-detection-on-python-using-template-matching-ab4243a0ca62?source=collection_archive---------7-----------------------#2020-06-28">https://towardsdatascience.com/object-detection-on-python-using-template-matching-ab4243a0ca62?source=collection_archive---------7-----------------------#2020-06-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6216" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何在没有机器学习或任何框架的情况下在 Python 上进行对象检测</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/228655a5b00011bbcfdc14567ee69916.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7JQRTtWA7MW1INXVTbDydA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">雅各布·欧文斯在<a class="ae ky" href="/s/photos/object-detection?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="2187" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每当我们听到“<em class="lv">对象检测</em>”时，我们脑海中就会浮现出机器学习以及不同的框架。但我们实际上可以在不使用机器学习或任何其他框架的情况下进行对象检测。在本文中，我将向您展示如何只用 Python 来实现这一点。</p><p id="2e4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将从定义一个模板图像(对象)开始，系统将在源图像中找到与我们选择的模板匹配的所有其他对象。让我解释一下我给你们看一个例子的意思。下面有两张图片，左边是飞机的源图像，右边是飞机作为物体的模板照片。</p><div class="kj kk kl km gt ab cb"><figure class="lw kn lx ly lz ma mb paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/01b7f1356681c7349693029f230edcb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*3IB1tRu2_Iq6Be1HpbpLNw.jpeg"/></div></figure><figure class="lw kn mc ly lz ma mb paragraph-image"><img src="../Images/a3647c12c5569fcbfb56f29a92ec5f49.png" data-original-src="https://miro.medium.com/v2/resize:fit:184/format:webp/1*nIC077iQLYxBeTgFPPCm2Q.jpeg"/><p class="ku kv gj gh gi kw kx bd b be z dk md di me mf translated">左—源图像，右—模板图像</p></figure></div><p id="f20c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我要做的是写一个 python 代码来显示这个模板图像实际上适合我的源图像的所有区域。</p><p id="9722" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们从检测一个对象开始，其次，我们可以调整代码来检测多个对象。</p><h2 id="3013" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">检测一个对象—最精确的对象</h2><p id="721b" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">为此，我们需要一个源图像和一个模板图像。模板图像在源图像上滑动(像 2D 卷积一样)，程序将试图找到最准确的匹配。</p><p id="cfe4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开始编码吧。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="7e02" class="mg mh it nf b gy nj nk l nl nm">import cv2<br/>import numpy as np<br/>from matplotlib import pyplot as plt</span><span id="fa02" class="mg mh it nf b gy nn nk l nl nm">img_rgb = cv2.imread('SourceIMG.jpeg')<br/>img_gray = cv2.cvtColor(img_rgb, cv2.COLOR_BGR2GRAY)<br/>template = cv2.imread('TemplateIMG.jpeg', 0)</span></pre><p id="6967" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的部分代码中，我们使用 OpenCV 来读取我们的<code class="fe no np nq nf b">SourceIMG.jpeg</code>和<code class="fe no np nq nf b">TemplateIMG.jpeg</code>。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="312a" class="mg mh it nf b gy nj nk l nl nm">height, width = template.shape[::]</span></pre><p id="7b2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当模板图像滑过源图像时，它会寻找整个区域。(<strong class="lb iu">左上角为参考帧</strong>)。在模板图像与源图像匹配后，我们要注意左上角的位置，然后在实际匹配的区域周围画一个方框。为了做到这一点，我们需要找到这个模板图像的高度和宽度。所以我们可以画矩形。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="cad2" class="mg mh it nf b gy nj nk l nl nm">res = cv2.matchTemplate(img_gray, template, cv2.TM_SQDIFF)</span></pre><p id="9ae4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">模板匹配是 OpenCV 的一部分，它获取我们的灰度源图像和带有我们需要使用的统计指标的模板图像。在这种情况下，我使用的是<strong class="lb iu">最小方差</strong> ( <code class="fe no np nq nf b">TM_SQDIFF</code>)，因为我们在寻找模板图像和源图像之间的最小差异。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="d179" class="mg mh it nf b gy nj nk l nl nm">plt.imshow(res, cmap='gray')</span></pre><p id="8e45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你画出我们到目前为止所做的，我们会看到一个概率图。正如你从下图中看到的，这些小点就是模板实际匹配的地方。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/919fcc954cd9e14aafae901d5c213796.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*4-ALdeHcd5M-7Vi1ZkqJ8A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">概率图</p></figure><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="142b" class="mg mh it nf b gy nj nk l nl nm">min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res)</span></pre><p id="741d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用上面的代码，我们可以找到概率图中微小点的位置。使用<code class="fe no np nq nf b">minMaxLoc(res)</code>我们可以提取最小值、最大值、最小位置和最大位置。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="2adb" class="mg mh it nf b gy nj nk l nl nm">top_left = min_loc <br/>bottom_right = (top_left[0] + width, top_left[1] + height)<br/>cv2.rectangle(img_rgb, top_left, bottom_right, (255, 0, 0), 2)</span></pre><p id="5232" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了在模板图像匹配的源图像上绘制一个蓝色矩形，我们需要得到最小位置，<code class="fe no np nq nf b">min_loc</code>(匹配实际开始的位置)作为我们的左上角。同样的，我们可以通过<code class="fe no np nq nf b">top_left[0] + width</code>和<code class="fe no np nq nf b">top_left[1] + height</code>得到我们的底部。有了这些尺寸，我们可以使用<code class="fe no np nq nf b">cv2.rectangle</code>绘制蓝色矩形。<br/>这就是我们需要设置的所有内容，让我们继续想象一下。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="44f8" class="mg mh it nf b gy nj nk l nl nm">cv2.imshow("Matched image", img_rgb)<br/>cv2.waitKey()<br/>cv2.destroyAllWindows()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/0a0f83a2073742f0e61c152f2b3724c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JM_irGBRl7oZlFzAMPIcXQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">匹配图像—一个对象</p></figure><p id="c06c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完整代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><h2 id="e286" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">在给定阈值下检测多个对象</h2><p id="e263" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">我们已经通过选择源图像和模板图像之间的最小差异检测了一个对象。通过定义一个阈值，我们可以检测所有与模板图像相似的对象。</p><p id="b811" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我将使用相同的源图像和模板图像来检测一个概率阈值高于 0.5 的对象(您可以通过参考<code class="fe no np nq nf b">res</code>数组来决定阈值)。我们只需要修改几行代码来检测多个对象。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="a2f4" class="mg mh it nf b gy nj nk l nl nm">res = cv2.matchTemplate(img_gray, template, cv2.TM_CCOEFF_NORMED)</span></pre><p id="352c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我使用<code class="fe no np nq nf b">TM_CCOEFF_NORMED</code>是因为我们需要得到最大值，而不是最小值。这意味着我们需要寻找多个物体而不是一个。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="2da2" class="mg mh it nf b gy nj nk l nl nm">threshold = 0.5 #For TM_CCOEFF_NORMED, larger values means good fit</span><span id="f01b" class="mg mh it nf b gy nn nk l nl nm">loc = np.where( res &gt;= threshold)</span></pre><p id="4dd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们试图找到所有大于阈值的位置值。<code class="fe no np nq nf b">loc</code>将接收 2 个输出数组，组合这些数组我们可以得到 x，y 坐标。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="9097" class="mg mh it nf b gy nj nk l nl nm">for pt in zip(*loc[::-1]):<br/>   cv2.rectangle(img_rgb, pt, (pt[0] + width, pt[1] + height), (255, 0, 0), 1)</span></pre><p id="fc43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我现在要做的是，我们有多个位置，而不是一个。因此，对于所有这些位置，我们需要绘制蓝色矩形。这就是我们需要设置的所有内容，让我们继续想象一下。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/8f46ad54a055cf531aa824c5ab962b0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nUa0SOxfW1L57XtG-oSVXA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">匹配图像—多个对象</p></figure><p id="5f3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完整代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><p id="e3ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看起来很简单，对吗？但如果我们使用机器学习或框架，我们可以更准确地做到这一点。</p><p id="49ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读，我希望这篇文章是有帮助的。</p><h2 id="96a3" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">资源</h2><div class="od oe gp gr of og"><a href="https://www.youtube.com/channel/UC34rW-HtPJulxr5wp2Xa04w" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">Sreeni 为显微镜专家开发的 Python</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">本频道将带您了解学习 Python 编码的整个过程；从基础到高级…</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">www.youtube.com</p></div></div><div class="op l"><div class="oq l or os ot op ou ks og"/></div></div></a></div></div></div>    
</body>
</html>