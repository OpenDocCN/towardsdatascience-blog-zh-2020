<html>
<head>
<title>Tricks I used to succeed on a famous Kaggle Competition</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我在一次著名的纸牌游戏比赛中成功使用的技巧</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/tricks-i-used-to-succeed-on-a-famous-kaggle-competition-adaa16c09f22?source=collection_archive---------15-----------------------#2020-01-24">https://towardsdatascience.com/tricks-i-used-to-succeed-on-a-famous-kaggle-competition-adaa16c09f22?source=collection_archive---------15-----------------------#2020-01-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="62ee" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用创造性特征工程和高级回归技术预测房价|前3 %</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/56852d10cf8a50964ca6782d6bba675f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*l4UW1n4SOrM3Vh_I"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">汤姆·朗布尔在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="4194" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为一名新的数据科学家，在我攻读数据分析硕士学位期间，我积极参加了许多Kaggle比赛，以便将我在学习期间学到的所有知识投入到工作中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/3733cde4eec3b81a11ebac2dabaf7680.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*iQgVa3wk0JZa9UC0WE40Pg.png"/></div></figure><p id="1662" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我就说说我的第一场比赛，<strong class="lb iu"> </strong> <a class="ae ky" href="https://www.kaggle.com/c/house-prices-advanced-regression-techniques" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">房价:高级回归技巧</strong> </a>。<strong class="lb iu"> </strong>对于数据科学初学者或通过了机器学习课程并希望扩展其技能组合的学生来说，这是一场完美的比赛。本次竞赛的目标是预测样本房屋的销售价格。根据预测值的对数和观察到的销售价格的对数之间的<a class="ae ky" href="https://en.wikipedia.org/wiki/Root-mean-square_deviation" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">均方根误差(RMSE) </strong> </a>对所有提交进行评估。</p><p id="9745" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有几个因素会影响房子的整体价格，其中一些因素更为有形，如房子的质量或房子的整体大小(面积),其他因素更为内在，如经济表现。建立一个准确的模型来预测实际价值是一项艰巨的任务，因为有内部和外部因素会影响每栋房子的价格。</p><p id="1d0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里我将为你描述我是如何从第2800名左右进入前150名的。你可以在我的GitHub个人资料上找到详细的笔记本:<a class="ae ky" href="https://github.com/chouhbik/Kaggle-House-Prices" rel="noopener ugc nofollow" target="_blank">https://github.com/chouhbik/Kaggle-House-Prices</a></p><p id="f655" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一开始，我从构建不同的模型开始，并让它们根据我从Kaggle下载的原始数据进行训练。随机森林表现良好，得分为0.13825，足以让我在排行榜上垫底。</p><p id="9bb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后才知道<strong class="lb iu"> EDA(探索性数据分析)</strong><strong class="lb iu">特征工程</strong>的前期步骤是如此重要。接下来，我将向您展示我是如何改进的…</p><h1 id="3960" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated"><strong class="ak">第一步:</strong>因变量的对数变换</h1><p id="2ddf" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">有两个原因需要预测销售记录，而不是销售额:首先，本次竞赛中使用的评估指标取决于销售记录，其次，许多货币实体的分布接近对数正态分布，即重尾分布。通常，预测不具有重尾性的事物会更好，并且大多数机器学习模型在正态分布的数据上表现良好。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="376c" class="my lx it mu b gy mz na l nb nc">(np.log(df_train["SalePrice"])).hist(bins = 40)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/2667c8f14d971b17e8400bdc507f5bc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/format:webp/1*rWDEHvPh0_AzRr-2HF0EXQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">直方图:销售记录</p></figure><h1 id="5c35" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated"><strong class="ak">步骤2:重新编码预测值/缺失值/异常值</strong></h1><p id="0ed0" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">一些顺序的预测值(即它们的值有自然顺序)最初被存储为因子。我以一种明智的方式对它们进行了重新编码(这种预测器的例子有<em class="ne">ext equal</em>和<em class="ne"> BsmtCond </em>)。显然，我必须填写缺失的值:</p><ul class=""><li id="166a" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">数字预测中的缺失:当有意义时，我用零填充(例如，如果地下室没有浴室，BsmtFullBath应该等于零)，</li><li id="8cf8" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">分类预测中的缺失:我用中位数或其他典型值(均值或众数)填充。最后，</li><li id="fa6f" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">此外，去除预测值中的一些异常值也是值得的，如<em class="ne">总体质量</em>和<em class="ne"> GrLivArea </em>。</li></ul><h1 id="e191" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated"><strong class="ak">第三步:处理非线性</strong></h1><p id="af3c" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">由于我计划使用一些线性方法(拉索，山脊，SVM)，我<em class="ne">用它们的对数替换了</em>所有的重尾预测值，并为一些预测值<em class="ne">添加了</em>它们的平方(即我们有预测值X，我们添加了预测值X)。用对数代替重尾预测值的动机是:</p><ul class=""><li id="f9e3" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">线性方法可能用非常小的权重来拟合这种预测值，并且值中包含的大部分信息可能会丢失</li><li id="ead6" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">当这样的预测值取非常高的值时，预测值也可能非常高或误导。添加方块是由散点图“预测值与销售记录”中的非线性引起的</li></ul><h1 id="2d6d" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated"><strong class="ak">步骤4:添加新的预测值</strong></h1><p id="52e4" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我决定增加一些指标变量，如果相应的预测因子取某个值，它们就等于某个值。</p><p id="edc2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="495f" class="my lx it mu b gy mz na l nb nc"><em class="ne"># feture engineering a new feature "TotalSF"</em><br/>all_data['TotalSF'] = all_data['TotalBsmtSF'] + all_data['1stFlrSF'] + all_data['2ndFlrSF']</span><span id="51f2" class="my lx it mu b gy nt na l nb nc">all_data['YrBltAndRemod']=all_data['YearBuilt']+all_data['YearRemodAdd']<br/><br/>all_data['Total_sqr_footage'] = (all_data['BsmtFinSF1'] + all_data['BsmtFinSF2'] +all_data['1stFlrSF'] + all_data['2ndFlrSF'])<br/><br/>all_data['Total_Bathrooms'] = (all_data['FullBath'] + (0.5 * all_data['HalfBath']) + all_data['BsmtFullBath'] + (0.5 * all_data['BsmtHalfBath']))<br/><br/>all_data['Total_porch_sf'] = (all_data['OpenPorchSF'] +                         all_data['3SsnPorch'] + all_data['EnclosedPorch'] + all_data['ScreenPorch'] +all_data['WoodDeckSF'])</span><span id="bd64" class="my lx it mu b gy nt na l nb nc">all_data['haspool'] = all_data['PoolArea'].apply(lambda x: 1 if x &gt; 0 else 0)<br/>all_data['has2ndfloor'] = all_data['2ndFlrSF'].apply(lambda x: 1 if x &gt; 0 else 0)<br/>all_data['hasgarage'] = all_data['GarageArea'].apply(lambda x: 1 if x &gt; 0 else 0)<br/>all_data['hasbsmt'] = all_data['TotalBsmtSF'].apply(lambda x: 1 if x &gt; 0 else 0)<br/>all_data['hasfireplace'] = all_data['Fireplaces'].apply(lambda x: 1 if x &gt; 0 else 0)</span></pre><h1 id="0dd8" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated"><strong class="ak">步骤5:堆叠模型</strong></h1><p id="5176" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">下一步，我使用了10层<strong class="lb iu"><em class="ne"/></strong>交叉验证和堆叠:对于每次“运行”的交叉验证，我试图在10层<strong class="lb iu">(套索、脊、弹性网、GBM和XGBoost) </strong>中的9层上拟合5个模型，对遗漏的层进行预测，并使用这五组预测作为另一个<strong class="lb iu">套索</strong>模型的输入，以预测遗漏层的销售记录(这种<strong class="lb iu">套索</strong>模型被称为我们总共有<strong class="lb iu"> <em class="ne"> 6*10=60款</em> </strong> (10套6款)。我使用所有这些模型进行最终预测:我采用测试数据集，使用5个子模型进行预测，然后使用这些模型的输出作为各自元模型的输入，以获得给定模型集的预测集。我重复这个过程10次，得到10组预测，然后使用算术平均值<strong class="lb iu"><em class="ne"/></strong>对它们进行平均，得到用于提交的数据。</p><h1 id="922b" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated"><strong class="ak">第六步:调整参数</strong></h1><p id="b755" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">对于堆叠，我使用了6个不同的模型，每个模型都需要调整(对于<strong class="lb iu"> <em class="ne">交叉验证</em> </strong>的每次“运行”,我用始终相同的参数拟合6个模型。我花了很多时间和提交来微调参数(最好的改进是通过为<strong class="lb iu">GradientBoostingRegressor</strong>调整<strong class="lb iu"><em class="ne">min _ samples _ leaf</em></strong>和<strong class="lb iu"><em class="ne">min _ samples _ split</em></strong>)。最终，我得到了0.1167左右的smt，并且确信我无法通过调优来提高它。</p><h1 id="2cbf" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated"><strong class="ak">第7步:更多缺失值</strong></h1><p id="1749" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">接下来，我尝试了不同的填充缺失值的策略(模式/方法/中间值等)。).在某种程度上，最有效的东西是出乎意料的:它基于R中的mice包，在这里描述为<a class="ae ky" href="https://www.kaggle.com/couyang/hybrid-svm-benchmark-approach-0-11180-lb-top-2" rel="noopener ugc nofollow" target="_blank"/>。我使用<a class="ae ky" href="https://cran.r-project.org/web/packages/mice/mice.pdf" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> <em class="ne">鼠标</em> </strong> </a>包来填充数值变量NA使用<strong class="lb iu">随机森林</strong>。</p><p id="3876" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> Mice </strong> package在填充NAs时非常方便。结果不是最好的，但比用每个变量的中间值来填补缺口要好。更重要的是，它很好用。</p><p id="c2fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<strong class="lb iu"> R/Mice/SVM </strong>和<strong class="lb iu"> python/stacking </strong>并取这些预测的几何平均值，我得到了0.1131，这已经很好了。令人意想不到的是，这种简单的、非业务驱动的填补异常值的方法起了作用。注意，<strong class="lb iu">老鼠</strong>可能会在数值预测器中填入不等于零的东西，而它们应该是零。我认为这种方法帮助了我，因为它与我在python中得到的完全不同。</p><h1 id="ea41" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated"><strong class="ak">第八步:野蛮武力</strong></h1><p id="698b" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我对0.1131已经很满意了，但是我最不想尝试的就是这个。回归通常不适用于边缘情况，不适用于预测值的大小。我接受了培训，运行了R/mice/svm、python/stacking，使用几何平均值对结果进行了平均，得到了销售记录的最终预测，并将它们与真实值的记录进行了对比:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/ab6ad1d05e01bfe4ec479711ff46db12.png" data-original-src="https://miro.medium.com/v2/resize:fit:506/format:webp/1*s8HXM2GaO9OVOw5czLl45A.jpeg"/></div></figure><p id="2a66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从图中可以明显看出，对于小的最终预测，我们高估了销售记录，对于大的预测值，我们低估了。</p><p id="e3a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我尝试了一个相当残酷的方法:我取预测销售额(不是对数，而是实际销售额)，取3个百分点，手动增加/减少预测。</p><p id="1af7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我用不同的百分位值重复了8次，直到最后得到0.10985。值得注意的是，这种强力方法提高了对少量观察值的预测，但似乎足以提高排行榜上的分数。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="2fe3" class="my lx it mu b gy mz na l nb nc">q1 = final_sub['SalePrice'].quantile(0.0025)<br/>q2 = final_sub['SalePrice'].quantile(0.0045)<br/>q3 = final_sub['SalePrice'].quantile(0.99)<br/><br/>final_sub['SalePrice'] = final_sub['SalePrice'].apply(lambda x: x if x &gt; q1 else x*0.79)<br/>final_sub['SalePrice'] = final_sub['SalePrice'].apply(lambda x: x if x &gt; q2 else x*0.89)<br/>final_sub['SalePrice'] = final_sub['SalePrice'].apply(lambda x: x if x &lt; q3 else x*1.0)</span></pre><h1 id="9e76" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated"><strong class="ak">总结:</strong></h1><p id="0209" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">最后，我还尝试了一些其他的方法，但是没有用:</p><ul class=""><li id="a228" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">主成分分析</li><li id="fcf4" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">添加越来越多的预测器</li><li id="a65f" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">将其他模型添加到堆叠中</li><li id="3775" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">在张量流和标度上使用keras，具有密集的神经网络。</li></ul><p id="b5e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想说的是，产品化版本的评估指标大约为0.12，因为可以构建简单的模型来提供相同的结果。有帮助的有趣的事情:添加一些预测器的方块，在原始数据上使用<strong class="lb iu">鼠标&amp; SVM </strong>和<strong class="lb iu"> R </strong>并使用边缘预测(非常低或非常高的预测)。</p><p id="0651" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望你喜欢这个项目的分析和预测模型，这些预测模型曾经接近准确的预测。</p></div></div>    
</body>
</html>