<html>
<head>
<title>10 Numpy functions you should know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你应该知道的10个数字函数</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/10-numpy-functions-you-should-know-1dc4863764c5?source=collection_archive---------2-----------------------#2020-01-02">https://towardsdatascience.com/10-numpy-functions-you-should-know-1dc4863764c5?source=collection_archive---------2-----------------------#2020-01-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="72e4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">数据科学和人工智能的例子</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f49a9f2cd7b2c59f6394ebc6855d6703.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BdxOimywjwXWjyLpP0mLRQ.png"/></div></div></figure><p id="a462" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae lq" href="https://numpy.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu"> Numpy </strong> </a>是一个用于科学计算的python包，提供了高性能的多维数组对象。这个库广泛用于数值分析、矩阵计算和数学运算。在本文中，我们展示了10个有用的numpy函数以及数据科学和人工智能应用。我们开始吧！🍀</p><h1 id="7bd8" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">1.numpy.linspace</h1><p id="e146" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated"><a class="ae lq" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.linspace.html" rel="noopener ugc nofollow" target="_blank"><strong class="kw iu">numpy . Lin space</strong></a><strong class="kw iu">(<em class="mo">start</em>，<em class="mo"> stop </em>，<em class="mo"> num=50 </em>，<em class="mo"> endpoint=True </em>，<em class="mo"> retstep=False </em>，<em class="mo"> dtype=None </em>，<em class="mo"> axis=0 </em> ) </strong>函数返回由函数的前两个参数定义的指定间隔内均匀分布的数字生成的样本数量由第三个参数<strong class="kw iu"> <em class="mo"> num </em> </strong>指定。如果省略，将生成50个样本。在使用这个函数时要记住的一件重要事情是，停止元素是在返回的数组中提供的(默认情况下<strong class="kw iu"> <em class="mo">【端点=真】</em> </strong>，不像在内置的python函数<a class="ae lq" href="https://www.geeksforgeeks.org/python-range-function/" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu"> <em class="mo">范围</em> </strong> </a>中那样。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><h1 id="ee88" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">例子</h1><p id="88ae" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated"><strong class="kw iu"> Linspace函数</strong>可用于为x轴生成均匀间隔的样本。例如，如果我们想要绘制一个数学函数，我们可以通过使用<strong class="kw iu"> numpy.linspace </strong>函数轻松地为x轴生成样本。在强化学习中，我们可以使用该函数进行离散化，提供连续空间(状态或动作)的最高和最低值，生成一致的离散空间。</p><p id="3336" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下图显示了4个数学函数:(1)正弦，(2)余弦，(3)指数，以及(4)对数函数。为了生成x轴数据，我们使用linspace函数，生成从0到100的111个数据点，包括0和100。你可能会注意到，为了生成数学函数，我们再次使用了<strong class="kw iu"> Numpy </strong>。我们可以参考<a class="ae lq" href="https://docs.scipy.org/doc/numpy-1.13.0/reference/routines.math.html" rel="noopener ugc nofollow" target="_blank">文档</a>来观察<strong class="kw iu"> Numpy </strong>提供的大量数学函数:)</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/019645dbf3d42e0bc2540e9e69e606d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1338/format:webp/1*f8oiLfPNUJkaU2LWt949DQ.png"/></div></figure><h1 id="ba06" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated"><strong class="ak"> 2。numpy . digital</strong></h1><p id="c4bd" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">也许你从来没有听说过这个函数，但是在强化学习中使用连续空间确实很有用。<a class="ae lq" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.digitize.html" rel="noopener ugc nofollow" target="_blank"><strong class="kw iu">numpy . digitize</strong></a><strong class="kw iu">(<em class="mo">x</em>，<em class="mo">bin</em>，<em class="mo"> right=False </em> ) </strong>函数有两个参数:(1)一个输入数组<strong class="kw iu"><em class="mo">x</em></strong>；以及(2)一个数组<em class="mo"/><strong class="kw iu"><em class="mo">bin</em>，</strong>返回每个值所在bin的索引迷惑？让我们看一个例子👌</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><h2 id="da73" class="ms ls it bd lt mt mu dn lx mv mw dp mb ld mx my md lh mz na mf ll nb nc mh nd bi translated">例子</h2><p id="3b47" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">在上面的代码中，我们总共有5个bin:</p><ul class=""><li id="0c63" class="ne nf it kw b kx ky la lb ld ng lh nh ll ni lp nj nk nl nm bi translated">x &lt; 0 → Index 0</li><li id="9924" class="ne nf it kw b kx nn la no ld np lh nq ll nr lp nj nk nl nm bi translated">0≤ x &lt; 1 → Index 1</li><li id="658c" class="ne nf it kw b kx nn la no ld np lh nq ll nr lp nj nk nl nm bi translated">1≤ x &lt; 2 → Index 2</li><li id="d826" class="ne nf it kw b kx nn la no ld np lh nq ll nr lp nj nk nl nm bi translated">2≤ x &lt; 3 → Index 3</li><li id="f68a" class="ne nf it kw b kx nn la no ld np lh nq ll nr lp nj nk nl nm bi translated">3≤ x → Index 4</li></ul><p id="9394" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Therefore, if we provide as an input 0.5, the function returns 1, since that is the index of the bin to which 0.5 belongs.</p><p id="17d6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">In <strong class="kw iu">强化学习</strong>，我们可以用等间距网格离散化状态空间。<strong class="kw iu">离散化</strong>允许我们将为离散空间设计的算法，如<strong class="kw iu"> Sarsa </strong>、<strong class="kw iu"> Sarsamax </strong>或<strong class="kw iu">预期Sarsa </strong>应用于连续空间。</p><p id="da94" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">想象我们有下面的<strong class="kw iu">连续空间</strong>。<strong class="kw iu">代理</strong>可以在任意位置(x，y)，其中0≤x≤5，0≤y≤5。我们可以通过提供一个<strong class="kw iu">元组</strong>来离散化代理的位置，表示代理所在的网格。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/f2b2bfaff604f8e41debffc7b4ae0bab.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*CWdV6Rh8wNBw891V1c0gjQ.png"/></div></div></figure><p id="0f43" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以通过使用<strong class="kw iu"> numpy.digitize </strong>函数轻松实现这种离散化，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="313d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将考虑任何小于1的值属于库索引0，任何大于或等于4的值属于库索引4。瞧！我们已经把一个连续的空间变成了一个离散的空间。</p><h1 id="8d43" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated"><strong class="ak"> 3。numpy.repeat </strong></h1><p id="e4bb" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated"><strong class="kw iu"/><a class="ae lq" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.repeat.html" rel="noopener ugc nofollow" target="_blank"><strong class="kw iu">numpy . repeat</strong></a><strong class="kw iu">(<em class="mo">a</em>，<em class="mo"> repeats </em>，<em class="mo"> axis=None </em> ) </strong>函数<strong class="kw iu"> </strong> repeats数组的元素。重复次数由第二个参数<strong class="kw iu">指定<em class="mo">重复</em>。</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><h2 id="fb33" class="ms ls it bd lt mt mu dn lx mv mw dp mb ld mx my md lh mz na mf ll nb nc mh nd bi translated">例子</h2><p id="2f83" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">假设我们有两个不同的数据框，包含2017年和2018年的销售额，但我们只想要一个数据框，包括所有信息。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/706d81ab650580deb09036ac1b680338.png" data-original-src="https://miro.medium.com/v2/resize:fit:486/format:webp/1*CfIvQ2w5QycGwiFEdCTY6g.png"/></div><p class="nu nv gj gh gi nw nx bd b be z dk translated">2017年销售额</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/5f2175568d163f9d404d09fb1f0d2cf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:492/format:webp/1*fYsuEETXycIGJF8u4orCpA.png"/></div><p class="nu nv gj gh gi nw nx bd b be z dk translated">2018年销售额</p></figure><p id="11c4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在合并两个数据框之前，我们需要添加一列，指定产品销售的年份。我们可以通过使用<strong class="kw iu"> numpy.repeat </strong>函数来添加这些信息。随后，我们使用<strong class="kw iu"> pandas.concat </strong>函数连接两个数据帧。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/d2cd219076268ef77102a643342be5e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/format:webp/1*JkLstFwCOVxnXXaWMwYXgg.png"/></div><p class="nu nv gj gh gi nw nx bd b be z dk translated">销售</p></figure><h1 id="7f91" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">4.numpy.random</h1><h2 id="9c97" class="ms ls it bd lt mt mu dn lx mv mw dp mb ld mx my md lh mz na mf ll nb nc mh nd bi translated">4.1.numpy.random.randint</h2><p id="33b1" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated"><a class="ae lq" href="https://docs.scipy.org/doc/numpy-1.15.0/reference/generated/numpy.random.randint.html#numpy.random.randint" rel="noopener ugc nofollow" target="_blank"><strong class="kw iu">numpy . random . randint</strong></a><strong class="kw iu">(<em class="mo">low</em>，<em class="mo"> high=None </em>，<em class="mo"> size=None </em>，<em class="mo"> dtype='l' </em> ) </strong>函数返回区间[low，high]中的随机整数。如果<strong class="kw iu"> <em class="mo">高</em> </strong>参数<strong class="kw iu"> <em class="mo"> </em> </strong>缺失(无)，则从区间[0，低]中选取随机数。默认情况下，返回一个随机数(int)。为了生成一个随机整数数组，数组的形状在参数<strong class="kw iu"> <em class="mo"> size </em> </strong>中提供。</p><h2 id="f425" class="ms ls it bd lt mt mu dn lx mv mw dp mb ld mx my md lh mz na mf ll nb nc mh nd bi translated">例子</h2><p id="8ab3" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">该函数可用于模拟随机事件，如抛硬币或掷骰子，如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><h2 id="ba51" class="ms ls it bd lt mt mu dn lx mv mw dp mb ld mx my md lh mz na mf ll nb nc mh nd bi translated"><strong class="ak"> 4.2。numpy.random.choice </strong></h2><p id="92e6" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated"><a class="ae lq" href="https://docs.scipy.org/doc/numpy-1.15.0/reference/generated/numpy.random.choice.html" rel="noopener ugc nofollow" target="_blank"><strong class="kw iu">numpy . random . choice</strong></a><strong class="kw iu">(<em class="mo">a</em>，<em class="mo"> size=None </em>，<em class="mo"> replace=True </em>，<em class="mo"> p=None </em> ) </strong>从给定数组中返回一个随机样本。默认情况下，返回单个值。要返回更多的元素，可以在参数<strong class="kw iu"> <em class="mo"> size </em> </strong>中指定输出形状，就像我们之前使用numpy.random.randint函数一样。</p><h2 id="19a4" class="ms ls it bd lt mt mu dn lx mv mw dp mb ld mx my md lh mz na mf ll nb nc mh nd bi translated">例子</h2><p id="558f" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">上面显示的随机事件也可以通过使用numpy.random.choice来模拟。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="b9a8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">默认情况下，元素被选中的概率相等。为了给每个元素分配不同的概率，可以提供概率数组<strong class="kw iu"><em class="mo"/></strong>。使用这个参数<strong class="kw iu"> <em class="mo"> p </em> </strong>，我们可以模拟一个有偏的硬币翻转如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><h2 id="3a24" class="ms ls it bd lt mt mu dn lx mv mw dp mb ld mx my md lh mz na mf ll nb nc mh nd bi translated">4.3.数字随机二项式</h2><p id="1c30" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">我们可以使用numpy来模拟各种各样的统计分布，如正态分布、贝塔分布、二项式分布、均匀分布、伽玛分布或泊松分布。</p><p id="cd81" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae lq" href="https://docs.scipy.org/doc/numpy-1.15.0/reference/generated/numpy.random.binomial.html#numpy.random.binomial" rel="noopener ugc nofollow" target="_blank"><strong class="kw iu">numpy . random . binomial</strong></a><strong class="kw iu">(<em class="mo">n</em>，<em class="mo"> p </em>，<em class="mo"> size=None </em> ) </strong>从二项分布中抽取样本。当有两个相互排斥的结果时，使用二项分布，提供<strong class="kw iu"> <em class="mo"> n </em> </strong>次试验的成功次数以及单次试验的成功概率<strong class="kw iu"><em class="mo"/></strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="d559" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我建议阅读文档并发现numpy.random库提供的广泛功能。</p><h1 id="6f6e" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">5.numpy.polyfit</h1><p id="5dad" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated"><strong class="kw iu"> numpy.polyfit( <em class="mo"> x </em>，<em class="mo"> y </em>，<em class="mo"> deg </em>，<em class="mo"> rcond=None </em>，<em class="mo"> full=False </em>，<em class="mo"> w=None </em>，<em class="mo"> cov=False </em> ) </strong>函数<strong class="kw iu"> </strong>输出一个<strong class="kw iu"> <em class="mo"> deg </em> </strong>的多项式，即【T50</p><p id="c946" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个函数在线性回归问题中非常有用。<strong class="kw iu">线性回归</strong>模拟<strong class="kw iu">因变量</strong>和<strong class="kw iu">自变量之间的关系，</strong>获得最符合数据的直线。</p><blockquote class="oa"><p id="adc1" class="ob oc it bd od oe of og oh oi oj lp dk translated"><strong class="ak"> y =a+bx </strong></p></blockquote><p id="f32a" class="pw-post-body-paragraph ku kv it kw b kx ok ju kz la ol jx lc ld om lf lg lh on lj lk ll oo ln lo lp im bi translated">其中<strong class="kw iu"> x </strong>为<strong class="kw iu">自变量</strong>，<strong class="kw iu"> y </strong>为<strong class="kw iu">因变量</strong>，<strong class="kw iu"> b </strong>为<strong class="kw iu">斜率</strong>，<strong class="kw iu"> a </strong>为<strong class="kw iu">截距。</strong>要获得系数a和b，我们可以使用<strong class="kw iu"> numpy.polyfit </strong>函数，如下所示。</p><h2 id="245e" class="ms ls it bd lt mt mu dn lx mv mw dp mb ld mx my md lh mz na mf ll nb nc mh nd bi translated">例子</h2><p id="bf9b" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">假设我们有一个包含5000名男性身高和体重的数据框。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/8c4b20e19c2a8c41cd192bb0cb203e9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:528/format:webp/1*WPGFGospScYI6BKNpPTgjA.png"/></div></figure><p id="237c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如我们所观察到的，两个变量呈现线性关系。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/52b59b07a818a106b746b4f655c146b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*1BAhOgxyjNfXfsSHWzC95w.png"/></div></figure><p id="09a0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们通过以下方式用<strong class="kw iu"> numpy.polyfit </strong>函数获得最佳拟合线性方程:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="ed6f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该函数返回线性模型的斜率(<strong class="kw iu"> 5.96 </strong>)和截距(<strong class="kw iu"> -224.50 </strong>)。现在，我们可以利用得到的模型(<strong class="kw iu"> y=5.96x-224.50 </strong>)来预测一个人的体重(看不见的数据)。这个预测可以通过使用<strong class="kw iu"> numpy.polyval </strong>函数来获得。</p><h1 id="fff1" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">6.numpy.polyval</h1><p id="dd18" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated"><a class="ae lq" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.polyval.html" rel="noopener ugc nofollow" target="_blank"><strong class="kw iu">numpy . polyval</strong></a><strong class="kw iu">(<em class="mo">p</em>，<em class="mo"> x) </em> </strong>函数计算特定值的多项式。之前我们已经通过使用<strong class="kw iu"> numpy.polyfit </strong>函数得到了一个预测一个人<strong class="kw iu">(体重= 5.96 *身高-224.50) </strong>体重的线性模型。现在，我们使用这个模型通过<strong class="kw iu"> numpy.polyval </strong>函数进行预测。假设我们想预测一个70英寸高的男人的体重。作为参数，我们提供从最高次到常数项(<strong class="kw iu"> p=[5.96，-224.49] </strong>)的多项式系数(用polyfit获得)，以及一个用来计算<strong class="kw iu"><em class="mo">p</em></strong>(<strong class="kw iu">x = 70</strong>)的数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="cc3a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下图显示了回归线和预测重量。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/85c66344c3cea87b7228f8d97dde8482.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*eIsxy-ZF1fJ11UHeLV2Eow.png"/></div></figure><h1 id="4869" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">7.numpy .楠</h1><p id="f9a6" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">Numpy库包括几个<a class="ae lq" href="https://numpy.org/devdocs/reference/constants.html#numpy.nan" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu">常量</strong> </a>如非数字(Nan)、无穷大(inf)或pi。在计算中，not number是一种可以解释为未定义值的数字数据类型。在Pandas中，我们可以使用not数字来表示缺失值或空值。不幸的是，脏数据集包含具有其他名称的空值(例如Unknown、—、n/a ),因此很难检测和丢弃它们。</p><h2 id="96a9" class="ms ls it bd lt mt mu dn lx mv mw dp mb ld mx my md lh mz na mf ll nb nc mh nd bi translated">例子</h2><p id="e49e" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">假设我们有以下数据集，其中包含马德里市的房屋信息(出于解释目的，此数据集有所缩减)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi os"><img src="../Images/aed35cb85b2b2c7a2fd2597dc3543d3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/format:webp/1*5m3osPnry4NYb5tYH3LBZw.png"/></div><p class="nu nv gj gh gi nw nx bd b be z dk translated">具有非标准缺失值的数据框</p></figure><p id="3866" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过使用<a class="ae lq" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.info.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu">熊猫，我们可以很容易地分析缺失值。data frame . info</strong>T39】方法。此方法打印有关数据框的信息，包括列类型、非空值的数量和内存使用情况。</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/4c1fb50b33b04a9504831fa01edcbf2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/1*kY-Wfma2zdkP-xYIABM5Hw.png"/></div><p class="nu nv gj gh gi nw nx bd b be z dk translated">info方法的输出</p></figure><p id="273c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如我们所观察到的，info函数没有检测到意外的空值(Unknown和-)。我们必须将这些值转换成熊猫可以检测到的空值。我们可以通过使用<strong class="kw iu"> numpy.nan </strong>常量来实现这一点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/ab2f7ad6d25705c8919dd3f2b94f8a82.png" data-original-src="https://miro.medium.com/v2/resize:fit:478/format:webp/1*4ca4ty0p4ku9I1fg_gEyYw.png"/></div></figure><p id="64f9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在分析数据之前，我们必须处理缺失值。为此，有不同的方法:(1)手动分配缺失值(如果我们知道数据)，(2)用平均值/中值替换缺失值，或(3)删除有缺失数据的行，以及其他方法。</p><p id="dbbf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在用标准空值替换(Unknown和-)之后，在num _ bedrooms和num _ balconies列中检测到两个缺失值。现在，通过使用<strong class="kw iu">熊猫可以很容易地删除那些丢失的值。DataFrame.dropna </strong>函数(方法3)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/afb03385f316468c72ecdf69881faa68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1086/format:webp/1*MsiVK3sFkbaPbarDG_m_cQ.png"/></div><p class="nu nv gj gh gi nw nx bd b be z dk translated">删除空值之前的数据帧</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/87018b5a2317f5a30d13276f4a22d6dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1074/format:webp/1*gJuF_TpHRBdXa0WGu9xVUg.png"/></div><p class="nu nv gj gh gi nw nx bd b be z dk translated">删除空值后的数据帧</p></figure><h1 id="40a6" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">8.numpy.argmax</h1><p id="e1d4" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated"><a class="ae lq" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.argmax.html" rel="noopener ugc nofollow" target="_blank"><strong class="kw iu">numpy . arg max</strong></a><strong class="kw iu">(<em class="mo">a</em>，<em class="mo"> axis=None </em>，<em class="mo"> out=None </em> ) </strong>函数返回一个轴上最大值的索引。</p><p id="b836" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在2d数组中，我们可以很容易地获得最大值的索引，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="0087" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以获得沿指定轴的最大值的索引，为<strong class="kw iu"> <em class="mo">轴</em> </strong>属性提供0或1。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><h2 id="1986" class="ms ls it bd lt mt mu dn lx mv mw dp mb ld mx my md lh mz na mf ll nb nc mh nd bi translated">例子</h2><p id="c1e2" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">在强化学习任务中，<strong class="kw iu"> numpy.argmax </strong>非常有用。<strong class="kw iu"> Q表</strong>是一个动作值函数估计，包含每个状态-动作对的<strong class="kw iu"><em class="mo"/></strong>，假设代理处于状态s，并采取动作a，遵循策略<strong class="kw iu"> π </strong>直到剧集结束。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/85cf311475fd46e9675c8f876ee1caea.png" data-original-src="https://miro.medium.com/v2/resize:fit:342/format:webp/1*sbT2OGOd0oUvj_K05aWMHw.png"/></div></div><p class="nu nv gj gh gi nw nx bd b be z dk translated">q表</p></figure><p id="39a6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以通过选择为每个状态<strong class="kw iu"><em class="mo"/></strong>提供最大<strong class="kw iu"> <em class="mo">期望回报</em> </strong>的动作<strong class="kw iu"> <em class="mo"> a </em> </strong>来容易地获得策略</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/a7390fa31d5747674b48c36aa5f021a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:336/format:webp/1*Lrjkq8-6arATHPQvBLuozw.png"/></div><p class="nu nv gj gh gi nw nx bd b be z dk translated">Q表中的策略</p></figure><p id="f0cb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的例子中，<strong class="kw iu"> numpy.argmax </strong>函数返回策略:状态0 →动作0，状态1 →动作2，状态2 →动作1。</p><h1 id="bf98" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">9.numpy .挤压</h1><p id="c06b" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated"><a class="ae lq" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.squeeze.html" rel="noopener ugc nofollow" target="_blank"><strong class="kw iu">numpy . squeeze</strong></a><strong class="kw iu">(<em class="mo">a</em>，<em class="mo"> axis=None </em> ) </strong>从数组的形状中删除一维条目。参数<strong class="kw iu"> <em class="mo">轴</em> </strong>指定了我们要挤出的轴。如果所选轴的形状大于1，则出现<strong class="kw iu"> <em class="mo">值错误</em> </strong>。如何使用numpy.squeeze函数的示例如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="10be" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如我们所观察到的，只有轴0和轴2可以被删除，因为它们的长度都是1。轴1有3个元素；因此，会引发ValueError。</p><h2 id="e2b5" class="ms ls it bd lt mt mu dn lx mv mw dp mb ld mx my md lh mz na mf ll nb nc mh nd bi translated">例子</h2><p id="c230" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated"><strong class="kw iu"> Pytorch </strong>是基于torch库的开源机器学习库。该库提供了多个数据集，如MNIST、Fashion-MINST或CIFAR，我们可以用它们来训练神经网络。首先，我们用<strong class="kw iu"> torchvision.datasets </strong>函数下载数据集(例如MNIST)。然后，我们通过使用<strong class="kw iu">torch . utils . data . data loader</strong>创建一个iterable。这个iterable被传递给<strong class="kw iu"> iter() </strong>方法，生成一个迭代器。最后，我们通过使用<strong class="kw iu"> next() </strong>方法获得迭代器的每个元素。这些元素是形状为[N，C，H，W]的张量，其中N表示批量大小，C表示通道数量，H表示输入平面的高度(以像素为单位), W表示宽度(以像素为单位)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="5397" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了可视化前一批元素，我们必须删除第一个轴，因为<a class="ae lq" href="https://matplotlib.org/3.1.1/api/_as_gen/matplotlib.pyplot.imshow.html" rel="noopener ugc nofollow" target="_blank"><strong class="kw iu">matplotlib . py plot . im show</strong></a>函数接受shape (H，W)的图像作为输入。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/6823d98be4003d9d17cc8e9420b6af14.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/format:webp/1*xhDVoq0oiQwbFLX4b5Fz4w.png"/></div><p class="nu nv gj gh gi nw nx bd b be z dk translated">批次的第一个图像</p></figure><h1 id="3fdb" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">10.数字直方图</h1><p id="37f2" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated"><a class="ae lq" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.histogram.html" rel="noopener ugc nofollow" target="_blank"><strong class="kw iu">numpy . histogram</strong></a><strong class="kw iu">(</strong><em class="mo">a</em><strong class="kw iu">，</strong><em class="mo">bin = 10</em><strong class="kw iu">，</strong> <em class="mo"> range=None </em> <strong class="kw iu">，</strong> <em class="mo"> normed=None </em> <strong class="kw iu">，</strong> <em class="mo"> weights=None </em> <strong class="kw iu">，</strong> <em class="mo">密度=None </em>该函数返回2个值:(1)频率计数，以及(2)箱边缘。</p><h2 id="1480" class="ms ls it bd lt mt mu dn lx mv mw dp mb ld mx my md lh mz na mf ll nb nc mh nd bi translated">例子</h2><p id="1261" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">以下数据框包含5000名男性的身高。我们创建一个直方图，将<strong class="kw iu"> <em class="mo"> kind='hist' </em> </strong>传递给<strong class="kw iu"> <em class="mo"> plot </em> </strong>方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/34bf9b457008e511bdb69240a857be85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/format:webp/1*Ep6LSDDeEpEVI-0LK7VArg.png"/></div></figure><p id="e477" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">默认情况下，直方图方法将数据集分成10个箱。请注意，x轴标签与箱子尺寸不匹配。这可以通过传入一个包含箱子尺寸列表的<strong class="kw iu"> <em class="mo"> xticks </em> </strong>参数来解决，方式如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mp mq l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/c2a61ecaf0baac09fb44535879b34341.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*4K9eKTwhEkxfiYmPiZ4ixg.png"/></div></figure><p id="9cc4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢阅读！！🍀 🍀 💪并且使用Numpy！</p></div></div>    
</body>
</html>