<html>
<head>
<title>8 Common Data Structures every Programmer must know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">每个程序员都必须知道的8种常见数据结构</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/8-common-data-structures-every-programmer-must-know-171acf6a1a42?source=collection_archive---------0-----------------------#2020-02-28">https://towardsdatascience.com/8-common-data-structures-every-programmer-must-know-171acf6a1a42?source=collection_archive---------0-----------------------#2020-02-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="949f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">8种常用数据结构的快速介绍</h2></div><p id="ae89" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">数据结构</strong>是一种在计算机中组织和存储数据的专门方法，通过这种方法，我们可以更有效地对存储的数据执行操作。数据结构在计算机科学和软件工程领域有着广泛而多样的使用范围。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/fc98197f8a35d39c3d0eb878ac87008b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KpDOKMFAgDWaGTQHL0r70g.png"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">作者图片</p></figure><p id="6d1f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">几乎每一个已经开发的程序或软件系统都在使用数据结构。此外，数据结构属于计算机科学和软件工程的基础。当涉及到软件工程面试问题时，这是一个关键话题。因此，作为开发人员，我们必须对数据结构有很好的了解。</p><p id="33bb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章中，我将简要解释每个程序员都必须知道的8种常用数据结构。</p><h1 id="31ab" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">1.数组</h1><p id="6be1" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">一个<strong class="kk iu">数组</strong>是一个固定大小的结构，它可以保存相同数据类型的项目。它可以是整数数组、浮点数数组、字符串数组甚至数组数组(比如<em class="mr">二维数组</em>)。数组是有索引的，这意味着随机访问是可能的。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi ms"><img src="../Images/959b62e85a4ac12e87a3e2d9450d4f3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pYIKtQYbX8vgCWrwe1YOyg.png"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">图一。数组基本术语的可视化(图片由作者提供)</p></figure><h2 id="6504" class="mt lv it bd lw mu mv dn ma mw mx dp me kr my mz mg kv na nb mi kz nc nd mk ne bi translated">数组运算</h2><ul class=""><li id="3cfd" class="nf ng it kk b kl mm ko mn kr nh kv ni kz nj ld nk nl nm nn bi translated"><strong class="kk iu">遍历</strong>:遍历元素并打印出来。</li><li id="7053" class="nf ng it kk b kl no ko np kr nq kv nr kz ns ld nk nl nm nn bi translated"><strong class="kk iu">搜索</strong>:搜索数组中的一个元素。您可以通过元素的值或索引来搜索元素</li><li id="1c32" class="nf ng it kk b kl no ko np kr nq kv nr kz ns ld nk nl nm nn bi translated"><strong class="kk iu">更新</strong>:更新给定索引处现有元素的值</li></ul><p id="132c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">向数组中插入</strong>元素和从数组中删除<strong class="kk iu">元素不能马上完成，因为数组的大小是固定的。如果你想在一个数组中插入一个元素，首先你需要创建一个新的数组，增加它的大小(当前大小+ 1)，复制现有的元素并添加新的元素。这同样适用于删除一个新的减小了大小的数组。</strong></p><h2 id="edcd" class="mt lv it bd lw mu mv dn ma mw mx dp me kr my mz mg kv na nb mi kz nc nd mk ne bi translated"><strong class="ak">数组的应用</strong></h2><ul class=""><li id="d734" class="nf ng it kk b kl mm ko mn kr nh kv ni kz nj ld nk nl nm nn bi translated">用作构建块来构建其他数据结构，如数组列表、堆、哈希表、向量和矩阵。</li><li id="7b6e" class="nf ng it kk b kl no ko np kr nq kv nr kz ns ld nk nl nm nn bi translated">用于不同的排序算法，如插入排序、快速排序、冒泡排序和合并排序。</li></ul><h1 id="d965" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">2.链接列表</h1><p id="6b65" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated"><strong class="kk iu">链表</strong>是一个顺序结构，由一系列相互链接的线性顺序的项目组成。因此，你必须按顺序访问数据，随机访问是不可能的。链表提供了一种简单灵活的动态集合表示。</p><p id="33b2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们考虑以下关于链表的术语。参考图2可以有一个清晰的思路。</p><ul class=""><li id="c9ab" class="nf ng it kk b kl km ko kp kr nt kv nu kz nv ld nk nl nm nn bi translated">链表中的元素被称为<strong class="kk iu">节点</strong>。</li><li id="8952" class="nf ng it kk b kl no ko np kr nq kv nr kz ns ld nk nl nm nn bi translated">每个节点包含一个<strong class="kk iu">键</strong>和一个指向其后继节点的指针，称为<strong class="kk iu">下一个</strong>。</li><li id="7cee" class="nf ng it kk b kl no ko np kr nq kv nr kz ns ld nk nl nm nn bi translated">名为<strong class="kk iu"> head </strong>的属性指向链表的第一个元素。</li><li id="15a2" class="nf ng it kk b kl no ko np kr nq kv nr kz ns ld nk nl nm nn bi translated">链表的最后一个元素被称为<strong class="kk iu">尾</strong>。</li></ul><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi nw"><img src="../Images/18fd10a9e9d7f9c1ae6287d8dae9e767.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4fuF6lHXOSmoVNcOV8aaJA.png"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">图二。链表基本术语的可视化(图片由作者提供)</p></figure><p id="a317" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是可用的各种类型的链表。</p><ul class=""><li id="70f4" class="nf ng it kk b kl km ko kp kr nt kv nu kz nv ld nk nl nm nn bi translated"><strong class="kk iu">单链表</strong> —只能向前遍历项目。</li><li id="f68f" class="nf ng it kk b kl no ko np kr nq kv nr kz ns ld nk nl nm nn bi translated"><strong class="kk iu">双向链表</strong> —可以向前和向后遍历条目。节点由一个称为<strong class="kk iu"> prev </strong>的额外指针组成，指向前一个节点。</li><li id="f893" class="nf ng it kk b kl no ko np kr nq kv nr kz ns ld nk nl nm nn bi translated"><strong class="kk iu">循环链表</strong> —头的prev指针指向尾，尾的next指针指向头的链表。</li></ul><h2 id="d683" class="mt lv it bd lw mu mv dn ma mw mx dp me kr my mz mg kv na nb mi kz nc nd mk ne bi translated">链表操作</h2><ul class=""><li id="9e6b" class="nf ng it kk b kl mm ko mn kr nh kv ni kz nj ld nk nl nm nn bi translated"><strong class="kk iu"> Search </strong>:通过简单的线性搜索，在给定的链表中找到关键字为<strong class="kk iu"> k </strong>的第一个元素，并返回指向该元素的指针</li><li id="f6c1" class="nf ng it kk b kl no ko np kr nq kv nr kz ns ld nk nl nm nn bi translated"><strong class="kk iu">插入</strong>:向链表中插入一个键。插入可以通过三种不同的方式完成；在列表的开头插入，在列表的结尾插入，在列表的中间插入。</li><li id="9c3b" class="nf ng it kk b kl no ko np kr nq kv nr kz ns ld nk nl nm nn bi translated"><strong class="kk iu">删除</strong>:从给定的链表中删除一个元素<strong class="kk iu"> x </strong>。您不能一步删除一个节点。删除可以通过三种不同的方式完成；从列表的开头删除，从列表的结尾删除，从列表的中间删除。</li></ul><h2 id="1da5" class="mt lv it bd lw mu mv dn ma mw mx dp me kr my mz mg kv na nb mi kz nc nd mk ne bi translated"><strong class="ak">链表的应用</strong></h2><ul class=""><li id="7009" class="nf ng it kk b kl mm ko mn kr nh kv ni kz nj ld nk nl nm nn bi translated">用于编译器设计中的<em class="mr">符号表管理</em>。</li><li id="e9fb" class="nf ng it kk b kl no ko np kr nq kv nr kz ns ld nk nl nm nn bi translated">用于使用Alt + Tab在程序之间切换(使用循环链表实现)。</li></ul><h1 id="ca20" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">3.大量</h1><p id="1844" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated"><strong class="kk iu">堆栈</strong>是一种<strong class="kk iu"> LIFO </strong>(后进先出——放在最后的元素可以首先被访问)结构，这在许多编程语言中都很常见。这种结构被命名为“堆栈”,因为它类似于现实世界中的堆栈——一堆盘子。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi nx"><img src="../Images/e28afcd00fe8927db0af9b2b0f97b109.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e4XWkyzxdOreblbPlbOCyw.jpeg"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">图片由<a class="ae ny" href="https://pixabay.com/users/congerdesign-509903/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=629987" rel="noopener ugc nofollow" target="_blank">设计</a>来自<a class="ae ny" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=629987" rel="noopener ugc nofollow" target="_blank">像素库</a></p></figure><h2 id="4b54" class="mt lv it bd lw mu mv dn ma mw mx dp me kr my mz mg kv na nb mi kz nc nd mk ne bi translated">堆栈操作</h2><p id="8a78" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">下面给出了可以在堆栈上执行的两个基本操作。请参考图3来更好地理解堆栈操作。</p><ul class=""><li id="1d3e" class="nf ng it kk b kl km ko kp kr nt kv nu kz nv ld nk nl nm nn bi translated"><strong class="kk iu">按下</strong>:将一个元素插入到栈顶。</li><li id="de19" class="nf ng it kk b kl no ko np kr nq kv nr kz ns ld nk nl nm nn bi translated"><strong class="kk iu"> Pop </strong>:删除最上面的元素并返回。</li></ul><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi nz"><img src="../Images/dbb5651f037b5a167f7553deac496568.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QMifqahZm4DGQ91GkOhu4g.png"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">图三。堆栈基本操作的可视化(图片由作者提供)</p></figure><p id="ae83" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，还为堆栈提供了以下附加功能，以便检查其状态。</p><ul class=""><li id="0f06" class="nf ng it kk b kl km ko kp kr nt kv nu kz nv ld nk nl nm nn bi translated"><strong class="kk iu"> Peek </strong>:返回栈顶元素，不删除。</li><li id="85bf" class="nf ng it kk b kl no ko np kr nq kv nr kz ns ld nk nl nm nn bi translated"><strong class="kk iu"> isEmpty </strong>:检查堆栈是否为空。</li><li id="ea86" class="nf ng it kk b kl no ko np kr nq kv nr kz ns ld nk nl nm nn bi translated"><strong class="kk iu">是否已满</strong>:检查堆栈是否已满。</li></ul><h2 id="f7fc" class="mt lv it bd lw mu mv dn ma mw mx dp me kr my mz mg kv na nb mi kz nc nd mk ne bi translated">堆栈的应用</h2><ul class=""><li id="cace" class="nf ng it kk b kl mm ko mn kr nh kv ni kz nj ld nk nl nm nn bi translated">用于表达式评估(例如:<em class="mr">调车场算法</em>用于解析和评估数学表达式)。</li><li id="6dc1" class="nf ng it kk b kl no ko np kr nq kv nr kz ns ld nk nl nm nn bi translated">用于在递归编程中实现函数调用。</li></ul><h1 id="0e94" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">4.行列</h1><p id="1f22" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">一个<strong class="kk iu">队列</strong>是一个<strong class="kk iu"> FIFO </strong>(先进先出——放在最前面的元素可以最先被访问)结构，这在许多编程语言中都很常见。这种结构被命名为“队列”,因为它类似于现实世界中的队列——人们在队列中等待。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi nx"><img src="../Images/4e137a7fa979a68f88bfb184e9e8d1a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GbtPRh9OWh1jtCtCa9czIg.jpeg"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">图片来自<a class="ae ny" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=50119" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae ny" href="https://pixabay.com/users/sheadquarters-5187/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=50119" rel="noopener ugc nofollow" target="_blank"> Sabine Felidae </a></p></figure><h2 id="9bcd" class="mt lv it bd lw mu mv dn ma mw mx dp me kr my mz mg kv na nb mi kz nc nd mk ne bi translated">队列操作</h2><p id="6667" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">下面给出了可以在队列上执行的两个基本操作。请参考图4来更好地理解队列操作。</p><ul class=""><li id="3221" class="nf ng it kk b kl km ko kp kr nt kv nu kz nv ld nk nl nm nn bi translated"><strong class="kk iu">入队</strong>:在队列末尾插入一个元素。</li><li id="641e" class="nf ng it kk b kl no ko np kr nq kv nr kz ns ld nk nl nm nn bi translated"><strong class="kk iu">出列</strong>:删除队列开头的元素。</li></ul><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi oa"><img src="../Images/a10b8e8aa3f2efcc630efd175163f7e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K4-7c0lyUcSGRPmv3_9uqw.png"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">图4。队列基本操作的可视化(图片由作者提供)</p></figure><h2 id="07fd" class="mt lv it bd lw mu mv dn ma mw mx dp me kr my mz mg kv na nb mi kz nc nd mk ne bi translated">队列的应用</h2><ul class=""><li id="86d9" class="nf ng it kk b kl mm ko mn kr nh kv ni kz nj ld nk nl nm nn bi translated">用于管理多线程中的线程。</li><li id="e242" class="nf ng it kk b kl no ko np kr nq kv nr kz ns ld nk nl nm nn bi translated">用于实现排队系统(例如:优先级队列)。</li></ul><h1 id="4690" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">5.哈希表</h1><p id="72f2" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">哈希表是一种存储值的数据结构，这些值具有与每个值相关联的键。此外，如果我们知道与值相关联的键，它可以有效地支持查找。因此，无论数据大小如何，它在插入和搜索方面都非常有效。</p><p id="fe7d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">直接寻址</strong>在表中存储时，使用值和键之间的一对一映射。然而，当有大量的键值对时，这种方法就有一个问题。考虑到典型计算机的可用内存，该表将会非常大，包含如此多的记录，并且可能不切实际，甚至不可能被存储。为了避免这个问题，我们使用了<strong class="kk iu">散列表</strong>。</p><h2 id="9052" class="mt lv it bd lw mu mv dn ma mw mx dp me kr my mz mg kv na nb mi kz nc nd mk ne bi translated">散列函数</h2><p id="42a2" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">名为<strong class="kk iu">散列函数</strong> ( <strong class="kk iu"> h </strong>)的特殊函数用于克服直接寻址中的上述问题。</p><p id="cbf4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在直接访问中，具有键<strong class="kk iu"> k </strong>的值被存储在槽<strong class="kk iu"> k </strong>中。使用散列函数，我们计算每个值所在的表(槽)的索引。使用散列函数为给定键计算的值被称为<strong class="kk iu">散列值</strong>，它指示该值映射到的表的索引。</p><blockquote class="ob"><p id="870c" class="oc od it bd oe of og oh oi oj ok ld dk translated"><strong class="ak"> h(k) = k % m </strong></p></blockquote><ul class=""><li id="7782" class="nf ng it kk b kl ol ko om kr on kv oo kz op ld nk nl nm nn bi translated"><strong class="kk iu"> h: </strong>哈希函数</li><li id="1389" class="nf ng it kk b kl no ko np kr nq kv nr kz ns ld nk nl nm nn bi translated"><strong class="kk iu"> k: </strong>应确定其哈希值的键</li><li id="e504" class="nf ng it kk b kl no ko np kr nq kv nr kz ns ld nk nl nm nn bi translated"><strong class="kk iu"> m: </strong>哈希表的大小(可用的槽数)。对于<strong class="kk iu"> m </strong>来说，不接近2的精确幂的质数是个不错的选择。</li></ul><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi oq"><img src="../Images/8c9c959c1408b29ad1d5f75d120df65e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xOmBfzMxLLldy1ll4w7esg.png"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">图五。哈希函数的表示(图片由作者提供)</p></figure><p id="16d3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">考虑哈希函数<strong class="kk iu"> h(k) = k % 20 </strong>，其中哈希表的大小为20。给定一组键，我们希望计算每个键的哈希值，以确定它在哈希表中的索引位置。假设我们有以下键，散列和散列表索引。</p><ul class=""><li id="8092" class="nf ng it kk b kl km ko kp kr nt kv nu kz nv ld nk nl nm nn bi">1 → 1%20 → 1</li><li id="100b" class="nf ng it kk b kl no ko np kr nq kv nr kz ns ld nk nl nm nn bi">5 → 5%20 → 5</li><li id="00d4" class="nf ng it kk b kl no ko np kr nq kv nr kz ns ld nk nl nm nn bi">23 → 23%20 → 3</li><li id="e735" class="nf ng it kk b kl no ko np kr nq kv nr kz ns ld nk nl nm nn bi">63 → 63%20 → 3</li></ul><p id="c884" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从上面给出的最后两个例子中，我们可以看到，当哈希函数为多个键生成相同的索引时，会出现<strong class="kk iu">冲突</strong>。我们可以通过选择合适的散列函数h来解决冲突，并使用诸如<strong class="kk iu">链接</strong>和<strong class="kk iu">开放寻址</strong>之类的技术。</p><h2 id="0328" class="mt lv it bd lw mu mv dn ma mw mx dp me kr my mz mg kv na nb mi kz nc nd mk ne bi translated">哈希表的应用</h2><ul class=""><li id="78f5" class="nf ng it kk b kl mm ko mn kr nh kv ni kz nj ld nk nl nm nn bi translated">用于实现数据库索引。</li><li id="069e" class="nf ng it kk b kl no ko np kr nq kv nr kz ns ld nk nl nm nn bi translated">用于实现关联数组。</li><li id="4442" class="nf ng it kk b kl no ko np kr nq kv nr kz ns ld nk nl nm nn bi translated">用于实现“设置”数据结构。</li></ul><h1 id="1c0f" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">6.树</h1><p id="eef3" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated"><strong class="kk iu">树</strong>是一种分层结构，其中数据按层次组织并链接在一起。这种结构不同于链表，而在链表中，项目是以线性顺序链接的。</p><p id="5d83" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在过去的几十年中，为了适应特定的应用和满足特定的限制，已经开发了各种类型的树。一些例子是二叉查找树树、B树、treap树、红黑树、八字树、AVL树和n叉树。</p><h2 id="ba6b" class="mt lv it bd lw mu mv dn ma mw mx dp me kr my mz mg kv na nb mi kz nc nd mk ne bi translated">二分搜索法树</h2><p id="730a" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated"><strong class="kk iu">二叉查找树(BST) </strong>顾名思义，是一种二叉树，其中数据以层次结构组织。这种数据结构按排序顺序存储值。</p><p id="c139" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">二叉查找树中的每个节点都包含以下属性。</p><ol class=""><li id="4fdb" class="nf ng it kk b kl km ko kp kr nt kv nu kz nv ld or nl nm nn bi translated"><strong class="kk iu"> key </strong>:存储在节点中的值。</li><li id="e6cb" class="nf ng it kk b kl no ko np kr nq kv nr kz ns ld or nl nm nn bi translated"><strong class="kk iu">左</strong>:指向左子的指针。</li><li id="dc1c" class="nf ng it kk b kl no ko np kr nq kv nr kz ns ld or nl nm nn bi translated"><strong class="kk iu">右</strong>:指向右孩子的指针。</li><li id="9cf7" class="nf ng it kk b kl no ko np kr nq kv nr kz ns ld or nl nm nn bi translated"><strong class="kk iu"> p </strong>:指向父节点的指针。</li></ol><p id="6810" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">二叉查找树表现出一种独特的属性，区别于其他树木。这个属性被称为<strong class="kk iu">二进制搜索树属性</strong>。</p><p id="c83f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">设<strong class="kk iu"> x </strong>是二叉查找树中的一个节点。</p><ul class=""><li id="a10e" class="nf ng it kk b kl km ko kp kr nt kv nu kz nv ld nk nl nm nn bi translated">如果<strong class="kk iu"> y </strong>是x的<strong class="kk iu">左</strong>子树中的一个节点，那么<strong class="kk iu"> y.key ≤ x.key </strong></li><li id="6ff4" class="nf ng it kk b kl no ko np kr nq kv nr kz ns ld nk nl nm nn bi translated">如果<strong class="kk iu"> y </strong>是x的<strong class="kk iu">右</strong>子树中的一个节点，那么<strong class="kk iu"> y.key ≥ x.key </strong></li></ul><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi os"><img src="../Images/ae4f61eb818cdd757568f66fe358275e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TMn800emvMuqwY3AZpfwCg.png"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">图六。树木基本术语的可视化(图片由作者提供)</p></figure><h2 id="3ea1" class="mt lv it bd lw mu mv dn ma mw mx dp me kr my mz mg kv na nb mi kz nc nd mk ne bi translated">树木的应用</h2><ul class=""><li id="0b38" class="nf ng it kk b kl mm ko mn kr nh kv ni kz nj ld nk nl nm nn bi translated"><strong class="kk iu">二叉树</strong>:用于实现表达式解析器和表达式求解器。</li><li id="ccb4" class="nf ng it kk b kl no ko np kr nq kv nr kz ns ld nk nl nm nn bi translated"><strong class="kk iu">二叉查找树</strong>:用于许多数据不断进出的搜索应用。</li><li id="6428" class="nf ng it kk b kl no ko np kr nq kv nr kz ns ld nk nl nm nn bi translated"><strong class="kk iu">堆</strong>:JVM(Java虚拟机)用来存储Java对象。</li><li id="1d8a" class="nf ng it kk b kl no ko np kr nq kv nr kz ns ld nk nl nm nn bi translated"><strong class="kk iu"> Treaps </strong>:用于无线网络。</li></ul><p id="44af" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">查看我下面关于8个有用的树数据结构和自平衡二分搜索法树的文章。</p><div class="ot ou gp gr ov ow"><a rel="noopener follow" target="_blank" href="/8-useful-tree-data-structures-worth-knowing-8532c7231e8c"><div class="ox ab fo"><div class="oy ab oz cl cj pa"><h2 class="bd iu gy z fp pb fr fs pc fu fw is bi translated">值得了解的8种有用的树数据结构</h2><div class="pd l"><h3 class="bd b gy z fp pb fr fs pc fu fw dk translated">8种不同树形数据结构的概述</h3></div><div class="pe l"><p class="bd b dl z fp pb fr fs pc fu fw dk translated">towardsdatascience.com</p></div></div><div class="pf l"><div class="pg l ph pi pj pf pk lo ow"/></div></div></a></div><div class="ot ou gp gr ov ow"><a rel="noopener follow" target="_blank" href="/self-balancing-binary-search-trees-101-fc4f51199e1d"><div class="ox ab fo"><div class="oy ab oz cl cj pa"><h2 class="bd iu gy z fp pb fr fs pc fu fw is bi translated">自平衡二分搜索法树101</h2><div class="pd l"><h3 class="bd b gy z fp pb fr fs pc fu fw dk translated">自平衡二分搜索法树简介</h3></div><div class="pe l"><p class="bd b dl z fp pb fr fs pc fu fw dk translated">towardsdatascience.com</p></div></div><div class="pf l"><div class="pl l ph pi pj pf pk lo ow"/></div></div></a></div><h1 id="9e26" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">7.很</h1><p id="abc3" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">一个<strong class="kk iu">堆</strong>是二叉树的一个特例，其中父节点与它们的子节点的值进行比较，并相应地排列。</p><p id="fa22" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看看如何表示堆。堆可以用树和数组来表示。图7和图8展示了我们如何使用二叉树和数组来表示二进制堆。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi pm"><img src="../Images/87f217bafe622b852d25d0434f006512.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BEq4aj8K7u4LbIaIEtHNmQ.png"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">图7。堆的二叉树表示(图片由作者提供)</p></figure><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi pn"><img src="../Images/c84f004ee753572aad6d04aa80b6b55b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N7R4banKc1NG5KqdXmJnkA.png"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">图8。堆的数组表示(图片由作者提供)</p></figure><p id="f411" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">堆可以有两种类型。</p><ol class=""><li id="37ea" class="nf ng it kk b kl km ko kp kr nt kv nu kz nv ld or nl nm nn bi translated"><strong class="kk iu">最小堆</strong> —父项的键小于或等于其子项的键。这被称为<strong class="kk iu">最小堆属性</strong>。根将包含堆的最小值。</li><li id="90e8" class="nf ng it kk b kl no ko np kr nq kv nr kz ns ld or nl nm nn bi translated"><strong class="kk iu">最大堆</strong> —父项的键大于或等于其子项的键。这称为<strong class="kk iu">最大堆属性</strong>。根将包含堆的最大值。</li></ol><h2 id="6986" class="mt lv it bd lw mu mv dn ma mw mx dp me kr my mz mg kv na nb mi kz nc nd mk ne bi translated">堆的应用</h2><ul class=""><li id="d5f7" class="nf ng it kk b kl mm ko mn kr nh kv ni kz nj ld nk nl nm nn bi translated">用于<strong class="kk iu">堆排序算法</strong>。</li><li id="0972" class="nf ng it kk b kl no ko np kr nq kv nr kz ns ld nk nl nm nn bi translated">用于实现优先级队列，因为优先级值可以根据堆属性进行排序，其中堆可以使用数组来实现。</li><li id="0ce5" class="nf ng it kk b kl no ko np kr nq kv nr kz ns ld nk nl nm nn bi translated">队列函数可以在<strong class="kk iu"> O(log n) </strong>时间内使用堆来实现。</li><li id="1748" class="nf ng it kk b kl no ko np kr nq kv nr kz ns ld nk nl nm nn bi translated">用于查找给定数组中kᵗʰ最小(或最大)值。</li></ul><p id="5162" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">查看我下面关于使用python heapq模块实现堆的文章。</p><div class="ot ou gp gr ov ow"><a rel="noopener follow" target="_blank" href="/introduction-to-python-heapq-module-53534feda625"><div class="ox ab fo"><div class="oy ab oz cl cj pa"><h2 class="bd iu gy z fp pb fr fs pc fu fw is bi translated">Python Heapq模块简介</h2><div class="pd l"><h3 class="bd b gy z fp pb fr fs pc fu fw dk translated">关于如何使用Python的heapq模块的简单介绍</h3></div><div class="pe l"><p class="bd b dl z fp pb fr fs pc fu fw dk translated">towardsdatascience.com</p></div></div><div class="pf l"><div class="po l ph pi pj pf pk lo ow"/></div></div></a></div><h1 id="e0c7" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">8.图表</h1><p id="cf3a" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">一个<strong class="kk iu">图</strong>由一组有限的<strong class="kk iu">顶点</strong>或节点以及一组连接这些顶点的<strong class="kk iu">边</strong>组成。</p><p id="6636" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">图的<strong class="kk iu">阶</strong>是图中顶点的个数。图的<strong class="kk iu">大小</strong>是图中边的数量。</p><p id="5b45" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果两个节点通过同一条边相互连接，则称它们为<strong class="kk iu">相邻</strong>。</p><h2 id="3763" class="mt lv it bd lw mu mv dn ma mw mx dp me kr my mz mg kv na nb mi kz nc nd mk ne bi translated">有向图</h2><p id="d782" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">如果一个图<strong class="kk iu"> G </strong>的所有边都有一个指示什么是起始顶点，什么是结束顶点的方向，则称该图为<strong class="kk iu">有向图</strong>。</p><p id="ff43" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们说<strong class="kk iu"> (u，v) </strong>是从或<strong class="kk iu">离开</strong>顶点<strong class="kk iu"> u </strong>的<strong class="kk iu">事件，是从</strong>或<strong class="kk iu">进入</strong>顶点<strong class="kk iu"> v </strong>的<strong class="kk iu">事件。</strong></p><p id="7ef2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">自循环</strong>:从顶点到自身的边。</p><h2 id="9fe9" class="mt lv it bd lw mu mv dn ma mw mx dp me kr my mz mg kv na nb mi kz nc nd mk ne bi translated">无向图</h2><p id="0696" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">如果一个图<strong class="kk iu"> G </strong>的所有边都没有方向，则称其为无向图<strong class="kk iu">。它可以在两个顶点之间双向移动。</strong></p><p id="151e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果一个顶点不与图中的任何其他节点相连，则称其为<strong class="kk iu">孤立的</strong>。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi pp"><img src="../Images/680090f51bf27b75caed8a93dd81141f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bgRmFfnYXHYXSv1pbNea0A.png"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">图九。图形术语的可视化(图片由作者提供)</p></figure><p id="31b2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可以从我的文章<a class="ae ny" href="https://medium.com/@vijinimallawaarachchi/10-graph-algorithms-visually-explained-e57faa1336f3" rel="noopener"> 10图算法直观解释</a>中读到更多关于图算法的内容。</p><div class="ot ou gp gr ov ow"><a href="https://medium.com/@vijinimallawaarachchi/10-graph-algorithms-visually-explained-e57faa1336f3" rel="noopener follow" target="_blank"><div class="ox ab fo"><div class="oy ab oz cl cj pa"><h2 class="bd iu gy z fp pb fr fs pc fu fw is bi translated">直观解释的10种图形算法</h2><div class="pd l"><h3 class="bd b gy z fp pb fr fs pc fu fw dk translated">10种基本图形算法的快速介绍，包括示例和可视化</h3></div><div class="pe l"><p class="bd b dl z fp pb fr fs pc fu fw dk translated">medium.com</p></div></div><div class="pf l"><div class="pq l ph pi pj pf pk lo ow"/></div></div></a></div><h2 id="888d" class="mt lv it bd lw mu mv dn ma mw mx dp me kr my mz mg kv na nb mi kz nc nd mk ne bi translated">图表的应用</h2><ul class=""><li id="b0ea" class="nf ng it kk b kl mm ko mn kr nh kv ni kz nj ld nk nl nm nn bi translated">用于表示社交媒体网络。每个用户都是一个顶点，当用户连接时，他们就创建了一条边。</li><li id="3aa9" class="nf ng it kk b kl no ko np kr nq kv nr kz ns ld nk nl nm nn bi translated">用于表示搜索引擎的网页和链接。互联网上的网页通过超链接相互链接。每个页面是一个顶点，两个页面之间的超链接是一条边。用于谷歌的页面排名。</li><li id="e7b5" class="nf ng it kk b kl no ko np kr nq kv nr kz ns ld nk nl nm nn bi translated">用于在GPS中表示位置和路线。位置是顶点，连接位置的路线是边。用于计算两个位置之间的最短路线。</li></ul><h1 id="1355" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">最后的想法</h1><p id="767d" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">数据结构操作的时间复杂性的备忘单可以在这个<a class="ae ny" href="https://www.bigocheatsheet.com/" rel="noopener ugc nofollow" target="_blank">链接</a>中找到。此外，请查看我下面的文章，在这篇文章中，我使用C++从头开始实现了一些常见的数据结构。</p><div class="ot ou gp gr ov ow"><a rel="noopener follow" target="_blank" href="/data-structures-in-c-part-1-b64613b0138d"><div class="ox ab fo"><div class="oy ab oz cl cj pa"><h2 class="bd iu gy z fp pb fr fs pc fu fw is bi translated">C++中的数据结构—第1部分</h2><div class="pd l"><h3 class="bd b gy z fp pb fr fs pc fu fw dk translated">在C++中实现通用数据结构</h3></div><div class="pe l"><p class="bd b dl z fp pb fr fs pc fu fw dk translated">towardsdatascience.com</p></div></div><div class="pf l"><div class="pr l ph pi pj pf pk lo ow"/></div></div></a></div><p id="1256" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我要感谢A Alkaff Ahamed先生为改进本文提供了宝贵的反馈和建议。</p><p id="2e7d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我希望作为对数据结构的简单介绍，这篇文章对您有所帮助。我很想听听你的想法。😇</p><p id="1a18" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">非常感谢你的阅读。😊</p><p id="b60f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">干杯！😃</p><h1 id="ff97" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">参考</h1><p id="7e68" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">[1]《算法导论》，第三版，作者:托马斯·h·科尔曼、查尔斯·e·莱瑟森、罗纳德·L·李维斯特和克利福德·斯坦。</p><p id="6826" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">[2]维基百科的数据结构列表(<a class="ae ny" href="https://en.wikipedia.org/wiki/List_of_data_structures" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/List_of_data_structures</a>)</p></div></div>    
</body>
</html>