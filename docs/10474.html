<html>
<head>
<title>Learning Python 10 minutes a day #18</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">每天 10 分钟学习 Python 10</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/learning-python-10-minutes-a-day-18-4718eb73758c?source=collection_archive---------51-----------------------#2020-07-22">https://towardsdatascience.com/learning-python-10-minutes-a-day-18-4718eb73758c?source=collection_archive---------51-----------------------#2020-07-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/861a215f083567059b0616591c415d2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kjLLayjOlfsSupnd.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae jg" href="https://unsplash.com/@jeremy_justin?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">杰瑞米·拉帕克</a>在<a class="ae jg" href="/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的原始照片。</p></figure><h2 id="83a4" class="jh ji jj bd b dl jk jl jm jn jo jp dk jq translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/10minutespython" rel="noopener" target="_blank">每天 10 分钟 Python 速成班</a></h2><div class=""/><div class=""><h2 id="b1be" class="pw-subtitle-paragraph kp js jj bd b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dk translated">关于生成器以及如何创建它们的更多信息</h2></div><p id="8b06" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这是一个<a class="ae jg" href="https://python-10-minutes-a-day.rocks" rel="noopener ugc nofollow" target="_blank">系列</a>10 分钟的简短 Python 文章，帮助您提高 Python 知识。我试着每天发一篇文章(没有承诺)，从最基础的开始，到更复杂的习惯用法。如果您对 Python 的特定主题有任何问题或要求，请随时通过 LinkedIn 联系我。</p><p id="23a2" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们已经遇到了生成器，它是一个 iterable，可以在需要的时候缓慢地计算值。这在速度上有好处，但最大的好处是减少了内存。常规列表需要一次性分配，一百万个值的列表可能会占用大量内存。当我们一次处理一个(或几个)值时，使用生成器要聪明得多。我们已经看到了<em class="md"> range() </em>函数，然而这并不是一个正式的生成器(但还是有点类似)。关于生成器，有一点是它只能在 iterable 上迭代一次。范围()可以重复完整迭代。当然，这只是一个细微的差别，但是要牢记在心。在上节课中，我们讨论了理解，但我们没有提到一种特殊类型:生成理解(或生成表达)。这种类型的理解看起来与列表理解相同，但是使用圆括号而不是方括号，并且顾名思义，返回一个生成器。</p><figure class="me mf mg mh gt iv"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="460c" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">发电机没有长度，因此不能使用<em class="md"> length() </em>功能。在这个例子中，我们知道长度，因为我们已经定义了它(<em class="md"> range(10) </em>)。然而，如果我们使用生成器来一行一行地遍历一个大文件，根据定义，生成器没有长度。实际上，要获得长度，即要读取的行数，您需要读取整个文件并计算' \n '个字符。这已经花费了一个完整的迭代周期。</p><p id="73d0" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">从生成器获取下一个值的另一种方法是使用<em class="md"> next() </em>函数。你必须记住，如果生成器是空的，即完整的迭代已经完成，<em class="md"> next() </em>函数将引发一个<em class="md"> StopIteration </em>异常。这可能会让您想知道 for 循环是如何工作的，因为您无法检查是否还有剩余的项。原来 for-loop 抓到了<em class="md"> StopIteration </em>异常:<em class="md"> </em> <a class="ae jg" rel="noopener" target="_blank" href="/learning-python-10-minutes-a-day-12-44806ea44852"> <em class="md">先请求原谅再请求许可</em> </a>。</p><p id="3a00" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们了解到，生成器对于减少 Python 程序的内存占用非常有用，甚至可以读取 100GB 的文件。为了完成这些专门的任务，您需要定义自己的生成器函数。生成器函数看起来像一个常规函数，它计算当前值。然后返回这个值，但是我们不使用<em class="md"> return </em>关键字，而是使用<em class="md"> yield </em>。通常，当使用<em class="md"> return </em>时，函数的状态是垃圾收集。这意味着函数中的所有变量都被删除了。使用<em class="md">产量</em>，功能的状态被保持，保持所有变量完整。当 for-loop 或 next()调用请求下一个值时，生成器函数将继续生成下一个值。让我们创建一个简单的生成器:</p><figure class="me mf mg mh gt iv"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="52d5" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">从生成器函数本身来看，已经很清楚为什么生成器在一次完整的迭代后是空的了。到达<em class="md"> max_number </em>后，该功能结束，不能产生新的值。为了再次迭代生成器，我们需要再次重新启动生成器。</p><p id="aacb" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">函数本身可以是任何东西。我们已经提到的例子是一个大于内存的文件的逐行迭代，但是还有许多其他的用法。生成器可以组合一个或多个数据库调用，可以从互联网下载信息，并且可以被定义为可以无限期运行。</p><p id="2512" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">生成器是 Python 中的一个高级特性，在某些情况下非常有用。正如我已经提到的，当内存是一个问题时，生成器是一个可能的解决方案。值是动态计算的。如果你只需要几个值(比如 100 个值中的前 10 个)，你可以省略不需要的计算，这样可以提高速度。你可以用发电机做更高级的事情，例如堆叠发电机。组合生成器可以模仿管道，这是一种高效的技术，例如在 Unix 世界中。</p><h1 id="6eef" class="mk ml jj bd mm mn mo mp mq mr ms mt mu ky mv kz mw lb mx lc my le mz lf na nb bi translated">今天的练习:</h1><p id="d7c3" class="pw-post-body-paragraph lh li jj lj b lk nc kt lm ln nd kw lp lq ne ls lt lu nf lw lx ly ng ma mb mc im bi translated">当讨论更高级的话题时，作业也会变得更有趣。因为我喜欢数字，今天我们要产生<a class="ae jg" href="https://en.wikipedia.org/wiki/Fibonacci_number" rel="noopener ugc nofollow" target="_blank">斐波纳契数</a>。斐波那契数列(或斐波那契数列)非常神奇，因为它们在自然界中经常出现。该序列定义了当前的斐波那契数列是前两个数列的和:</p><pre class="me mf mg mh gt nh ni nj nk aw nl bi"><span id="e52d" class="nm ml jj ni b gy nn no l np nq">F = [0, 1, 1, 2, 3, 5, 8, 13, ....... ]</span></pre><p id="9b7c" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jt">赋值:<br/> </strong>创建一个<em class="md">无限</em>生成器来生成斐波那契数。使用 while 循环(和 break)测试您的函数。由于生成器是无限的，您可以继续第二个循环。</p><p id="2199" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jt">提示</strong> : <br/> a)无限循环可以用永远为真的 while 循环来创建。<br/> b)生成器函数需要跟踪最后两个值并得出总和。</p><p id="ec87" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我已经在我的 Github 上发布了<a class="ae jg" href="https://gist.github.com/dennisbakhuis/ad7ceab8238e1eac2df6e98d06c859d2" rel="noopener ugc nofollow" target="_blank">解决方案</a>。</p><p id="6f2e" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如有任何问题，欢迎通过<a class="ae jg" href="https://www.linkedin.com/in/dennisbakhuis/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>联系我。</p></div></div>    
</body>
</html>