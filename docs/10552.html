<html>
<head>
<title>Five Advanced Python Features</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">五个高级 Python 特性</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/five-advanced-python-features-169c96682350?source=collection_archive---------8-----------------------#2020-07-24">https://towardsdatascience.com/five-advanced-python-features-169c96682350?source=collection_archive---------8-----------------------#2020-07-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2299" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">花括号作用域、自动形象化和其他编写更好代码的方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c908ffb715da83391a28b49d7946a7e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vX_OeVbO9Xn0WDjA"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Josh Kahen 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="7c53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated">ython 总能找到一些让我们惊喜的东西——这种语言中包含了太多精彩的特性。幸运的是，这意味着我们永远不会学不完东西。</p><p id="8ac7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着时间的推移，我已经养成了一个习惯，那就是记下我在 Python 中偶然发现的每个新特性。大多数情况下，它们令人兴奋，但使用案例非常有限。</p><p id="7ca0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，其他时候，我偶然发现了一个真正非常广泛适用的特性——通常，它会改变我的编码方式。我用一个列表来记录这些特性，这篇文章涵盖了列表中我最喜欢的五个特性。</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="dec0" class="mj mk it mf b gy ml mm l mn mo"><strong class="mf iu">Get Method for Dictionaries</strong> - no more KeyErrors<br/><strong class="mf iu">Tree Datatypes</strong> - or autovivification<br/><strong class="mf iu">Advanced List Indexing</strong> - [::3]?<br/><strong class="mf iu">Decorator Functions</strong> - those @ things<br/><strong class="mf iu">Denote Scopes with Braces</strong> - not whitespace <em class="mp">(my favorite feature)</em></span></pre></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="e44a" class="mx mk it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">字典的 Get 方法</h1><p id="62fe" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">dictionary <code class="fe nt nu nv mf b">get</code>方法执行与更常见的<code class="fe nt nu nv mf b">dict[key]</code>语法相同的操作，但有一个显著的不同——如果<code class="fe nt nu nv mf b">key</code>在我们的字典中不存在，我们不会抛出错误:</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="9907" class="mj mk it mf b gy ml mm l mn mo">dictionary = {<br/>    'one': 1,<br/>    'two': 2<br/>}<br/>dictionary['three']</span></pre><p id="4b70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nt nu nv mf b"><strong class="lb iu">[Out]:</strong> KeyError: 'three'</code></p><p id="0300" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用<strong class="lb iu">得到</strong> —</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="e3d2" class="mj mk it mf b gy ml mm l mn mo">dictionary.get('three')</span></pre><p id="c343" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nt nu nv mf b"><strong class="lb iu">[Out]:</strong> None</code></p><p id="4843" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nt nu nv mf b">get</code>方法返回<strong class="lb iu"> None </strong>，而不是返回一个<strong class="lb iu"> KeyError </strong>。</p><p id="e21e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以更进一步，用<code class="fe nt nu nv mf b">get</code>方法的第二个参数指定如果<code class="fe nt nu nv mf b">key</code>不存在要返回的值:</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="d7cb" class="mj mk it mf b gy ml mm l mn mo">dictionary.get('three', False)</span></pre><p id="2d1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nt nu nv mf b"><strong class="lb iu">[Out]:</strong> False</code></p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="43bd" class="mj mk it mf b gy ml mm l mn mo">dictionary.get('three', "doesn't exist")</span></pre><p id="ec32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nt nu nv mf b"><strong class="lb iu">[Out]: </strong>'doesn't exist'</code></p><p id="c97b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mp">最后，如果你知道你的字典的内容——不要用</em> <code class="fe nt nu nv mf b"><em class="mp">get</em></code> <em class="mp">它更慢！(感谢</em><a class="nw nx ep" href="https://medium.com/u/b4afc3baa612?source=post_page-----169c96682350--------------------------------" rel="noopener" target="_blank"><em class="mp">Petru</em></a><em class="mp">)</em></p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="7be1" class="mx mk it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">树数据类型</h1><p id="34fa" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">树数据类型如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/4494d0077405d843a85c85cfbe43d329.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d0Qq8OpeaG05a2_QisOREQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">句子中单词的树形表示及其各自的词性(PoS)标签。来源:作者。</p></figure><p id="3ae8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它表示一个分层的树结构，在最顶层有一个根值，向下分支到子节点。每个子节点有一个父节点，每个父节点可以有一个或多个子节点。</p><p id="a626" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们在 Python 中的表示将非常类似于嵌套字典，我们将像这样构建:</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="d81d" class="mj mk it mf b gy ml mm l mn mo">tree = {<br/>    'carnivora': {<br/>        'canis': {<br/>            'c.lupus': 'c.l.familiaris'<br/>        },<br/>        'felis': 'f.catus'<br/>    }<br/>}</span></pre><p id="ee3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们需要为每个子节点定义一个新的字典，一次一个步骤。</p><p id="1863" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它缓慢、混乱并且容易出错——想象一下一个简单的五层树，其中每个父节点只有两个子节点。</p><p id="382f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，我们可以用下面的代码构建我们的树数据类型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="8a4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以立即构建整个分支，而不是像我们所做的那样定义每个子字典:</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="3045" class="mj mk it mf b gy ml mm l mn mo">tree = Tree()<br/>tree['carnivora']['canis']['c.lupus'] = 'c.l.familiaris'<br/>tree['carnivora']['felis'] = 'f.catus'<br/>print(tree)</span><span id="1175" class="mj mk it mf b gy ob mm l mn mo"><strong class="mf iu">[Out]:</strong> {<br/>           'carnivora': {<br/>               'canis': {<br/>                   'c.lupus': 'c.l.familiaris'<br/>               },<br/>               'felis': 'f.catus'<br/>           }<br/>       }</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/38d39154678676e0462f2c257b8ef267.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VvN6RxqP3Tl3wGi7SG8kGw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd od">人类最好的朋友</strong>的科学分类树以及其他那些人们喜欢的东西。<a class="ae ky" href="https://unsplash.com/@jamie452?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Jamie Street </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照(左)，Kari Shea 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照(右)。</p></figure><p id="cd85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个方法有一个名字，<a class="ae ky" href="https://en.wikipedia.org/wiki/Autovivification" rel="noopener ugc nofollow" target="_blank">auto vivification</a>——每当一个未定义的值被<a class="ae ky" href="https://www.computerhope.com/jargon/d/dereference-operator.htm" rel="noopener ugc nofollow" target="_blank">解引用</a>时，自动创建新的数组和散列。</p><p id="fe38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个单行实现(不包括导入)可以在<a class="ae ky" href="https://gist.github.com/hrldcpr/2012250" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="cd05" class="mx mk it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">高级列表索引</h1><h2 id="8891" class="mj mk it bd my oe of dn nc og oh dp ng li oi oj ni lm ok ol nk lq om on nm oo bi translated">步伐</h2><p id="84d9" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">有几种未知的列表切片方法，尽管很有用。第一个是使用<strong class="lb iu">步骤</strong>:</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="f5a7" class="mj mk it mf b gy ml mm l mn mo">x = [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]<br/>x[::2]</span></pre><p id="1980" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nt nu nv mf b"><strong class="lb iu">[Out]:</strong> [0, 4, 8, 12, 16]</code></p><p id="fe5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在这里使用的语法是<code class="fe nt nu nv mf b">list[start:end:<strong class="lb iu">step</strong>]</code>——因为我们将<code class="fe nt nu nv mf b">start</code>和<code class="fe nt nu nv mf b">end</code>留空，我们从列表的最开始迭代到最末尾，其中<code class="fe nt nu nv mf b">step</code>为<code class="fe nt nu nv mf b">2</code>。</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="a2ac" class="mj mk it mf b gy ml mm l mn mo">x[3:8:2]</span></pre><p id="701e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nt nu nv mf b"><strong class="lb iu">[Out]:</strong> [6, 10, 14]</code></p><h2 id="041d" class="mj mk it bd my oe of dn nc og oh dp ng li oi oj ni lm ok ol nk lq om on nm oo bi translated">命名切片</h2><p id="aa3e" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">下面这个高级列表切片方法叫做<strong class="lb iu">命名切片</strong>。这里，我们将一个切片赋给一个变量，如下所示:</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="39a0" class="mj mk it mf b gy ml mm l mn mo">named_slice = slice(5, None)  # this is equivalent to [5:]</span></pre><p id="bb90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以将这个命名切片应用于任何列表。</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="fec9" class="mj mk it mf b gy ml mm l mn mo">x[named_slice]</span></pre><p id="a6bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nt nu nv mf b"><strong class="lb iu">[Out]:</strong> [10, 12, 14, 16, 18]</code></p><p id="9a9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在这里使用的语法使用相同的<em class="mp">开始、结束、步骤</em>模式— <code class="fe nt nu nv mf b">slice(start, end, step)</code>。我们可以这样重写<code class="fe nt nu nv mf b">x[3:8:2]</code>:</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="bc39" class="mj mk it mf b gy ml mm l mn mo">new_slice = slice(3, 8, 2)<br/>x[new_slice]</span></pre><p id="7dcc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nt nu nv mf b"><strong class="lb iu">[Out]:</strong> [6, 10, 14, 18]</code></p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="07ab" class="mx mk it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">装饰函数</h1><p id="9b04" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">装饰函数是我相信我们很多人都见过的奇怪的<code class="fe nt nu nv mf b">@func_name</code>事物之一——特别是 Flask 库大量使用了它们。</p><p id="ccd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们非常容易理解，而且非常有用。装饰者只是允许我们修改一个函数的行为，而不用显式地修改我们的函数。</p><p id="bc4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以定义一个<code class="fe nt nu nv mf b">pointless</code>函数，它将遍历一个范围，最终返回打印的乘以 2 的最终值:</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="9380" class="mj mk it mf b gy ml mm l mn mo">def pointless():<br/>    for i in range(20000000):<br/>        x = i*2<br/>    print(x)</span></pre><p id="6267" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nt nu nv mf b"><strong class="lb iu">[Out]:</strong> 39999998</code></p><p id="e925" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个函数什么都不会做，只会花很长时间来运行——但这正是我们想要的。我们将使用装饰函数来计时这个函数的运行时间。</p><p id="9fe2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">装饰器的定义就像任何普通函数一样:</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="3d56" class="mj mk it mf b gy ml mm l mn mo">def timer(func):<br/>    def wrapper():<br/>        start = datetime.datetime.now()<br/>        func()<br/>        runtime = datetime.datetime.now() - start<br/>        print(runtime)<br/>    return wrapper</span></pre><p id="9042" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，在定义我们的<code class="fe nt nu nv mf b">pointless</code>函数来继承<code class="fe nt nu nv mf b">timer</code>行为时，我们可以使用这个奇怪的@语法。</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="c734" class="mj mk it mf b gy ml mm l mn mo"><strong class="mf iu"><em class="mp">@timer</em></strong><br/>def pointless():<br/>    for i in range(20000000):<br/>        x = i*2<br/>    print(x)</span><span id="6a81" class="mj mk it mf b gy ob mm l mn mo">pointless()</span><span id="f244" class="mj mk it mf b gy ob mm l mn mo"><strong class="mf iu">[Out]:</strong> <!-- -->39999998<br/>       <strong class="mf iu">0:00:01.220755</strong>  <em class="mp">&lt;-- this is returned from our decorator</em></span></pre><p id="12ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以使用多个装饰器。让我们定义另一个名为<code class="fe nt nu nv mf b">repeat</code>的函数，它将对任何给定的函数迭代两次。</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="e5af" class="mj mk it mf b gy ml mm l mn mo">def repeat(func):<br/>    def wrapper():<br/>        for i in range(2):<br/>            func()<br/>            print(i)<br/>    return wrapper</span></pre><p id="ab57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们现在将<code class="fe nt nu nv mf b">@timer</code>和<code class="fe nt nu nv mf b">@repeat</code>装饰器都应用到我们的<code class="fe nt nu nv mf b">pointless</code>函数中，我们将得到:</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="5dd0" class="mj mk it mf b gy ml mm l mn mo"><strong class="mf iu"><em class="mp">@timer<br/>@repeat<br/></em></strong>def pointless():<br/>    for i in range(20000000):<br/>        x = i*2<br/>    print(x)</span><span id="2e07" class="mj mk it mf b gy ob mm l mn mo">pointless()</span><span id="74fc" class="mj mk it mf b gy ob mm l mn mo"><strong class="mf iu">[Out]:</strong> <!-- -->39999998<br/>       <strong class="mf iu">0</strong>               <em class="mp">&lt;-- printed in @repeat</em><br/>       39999998<br/>       <strong class="mf iu">1</strong>               <em class="mp">&lt;-- @repeat again</em><br/>       <strong class="mf iu">0:00:01.220755</strong>  <em class="mp">&lt;-- printed from @timer</em></span></pre><p id="2538" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们将<code class="fe nt nu nv mf b">pointless</code>包装到了<code class="fe nt nu nv mf b">@repeat</code>中，并将结果函数包装到了<code class="fe nt nu nv mf b">@timer</code>中——就像一些古怪的科学怪人的 Python 函数一样。</p><p id="d402" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在这里使用的装饰器是简单的玩具例子。对于装饰者，我们可以做更多的事情——我建议看看这些文章/资源:</p><ul class=""><li id="fd20" class="op oq it lb b lc ld lf lg li or lm os lq ot lu ou ov ow ox bi translated"><a class="ae ky" href="https://realpython.com/primer-on-python-decorators/" rel="noopener ugc nofollow" target="_blank">Python 装饰者入门</a> <em class="mp">(一篇关于装饰者的免费综合文章)</em></li><li id="a756" class="op oq it lb b lc oy lf oz li pa lm pb lq pc lu ou ov ow ox bi translated"><a class="ae ky" href="https://amzn.to/2OMODLF" rel="noopener ugc nofollow" target="_blank">流畅的 Python，卢西亚诺·拉马尔霍</a> <em class="mp">(大量的 Python——不仅仅是装饰者)</em></li></ul></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="22f4" class="mx mk it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">用大括号表示范围</h1><p id="336b" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">很容易我最喜欢的 Python 中的<em class="mp">高级</em>特性，而不是依靠空格来表示作用域<em class="mp">(无聊)</em>——我们可以使用花括号！</p><p id="f8ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们从<code class="fe nt nu nv mf b">__future__</code>库中导入功能:</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="8156" class="mj mk it mf b gy ml mm l mn mo">from __future__ import braces</span></pre><p id="5956" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们出发了！</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><p id="4be8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是 Python 中五个不常见但非常方便的特性。我想留给你们几个值得尊敬的例子来验证一下:</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="4051" class="mj mk it mf b gy ml mm l mn mo">&gt;&gt;&gt; import this<br/>&gt;&gt;&gt; import antigravity<br/>&gt;&gt;&gt; hash(float('inf'))</span></pre><p id="6d27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我把一个小的 GitHub repo 放在一起，里面有上述所有特性的例子，还有更多。查看它的代码片段——当然，也可以随意添加您自己的代码片段！</p><p id="84a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你有任何建议或问题，请随时通过<a class="ae ky" href="https://twitter.com/jamescalam" rel="noopener ugc nofollow" target="_blank">推特</a>或在下面的评论中联系我们。或者，如果你想要更多这样的内容，我也会在<a class="ae ky" href="https://www.youtube.com/c/jamesbriggs" rel="noopener ugc nofollow" target="_blank"> YouTube </a>上发布。</p><p id="e580" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>