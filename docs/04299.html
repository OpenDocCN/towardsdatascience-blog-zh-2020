<html>
<head>
<title>Comparing Graql to SQL — Part 1/2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">比较Graql和SQL —第1/2部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/comparing-graql-to-sql-part-1-2-ead496130a0c?source=collection_archive---------39-----------------------#2020-04-18">https://towardsdatascience.com/comparing-graql-to-sql-part-1-2-ead496130a0c?source=collection_archive---------39-----------------------#2020-04-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2755" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">探索共同的概念和差异</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2de935bfbe7c4ff221795f23adcf221d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EZnicJ3jlkWr5VQVuVH2IA.png"/></div></div></figure><p id="f037" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">自20世纪70年代以来，SQL一直是处理数据库的事实语言。作为一种声明式语言，编写查询和构建强大的应用程序非常简单。然而，关系数据库在处理互连的复杂数据时会遇到困难。在SQL中处理这类数据时，尤其是在数据的建模和查询方面会出现挑战。</p><p id="e00b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Graql是在<a class="ae lq" href="https://github.com/graknlabs/grakn" rel="noopener ugc nofollow" target="_blank"> Grakn </a>中使用的查询语言。就像SQL是关系数据库中的标准查询语言一样，Graql是Grakn的查询语言。SQL和Graql都是声明式查询语言，抽象出了低级操作。两者都是:</p><ul class=""><li id="078f" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated">尝试可读性和可理解性的语言</li><li id="dbec" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">试图在更高层次上提问的语言</li><li id="2c86" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">系统计算出如何进行底层操作的语言</li></ul><p id="837e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">实际上，这意味着那些原本无法接触到这些语言的人群可以接触到这些语言。在本文中，当我们查看特定的通用概念时，我们将重点比较和探索这两种语言之间的差异。</p><h1 id="0da7" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">SQL和关系模型的起源</h1><p id="e805" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">1970年，一位牛津毕业的数学家名叫<a class="ae lq" href="https://en.wikipedia.org/wiki/Edgar_F._Codd" rel="noopener ugc nofollow" target="_blank"> Edgar Codd </a>，也就是所谓的“ted ”,发表了一篇<a class="ae lq" href="https://dl.acm.org/doi/10.1145/362384.362685" rel="noopener ugc nofollow" target="_blank">论文</a>,在论文中，他引入了两种语言——一种关系代数和一种关系微积分来表达极其复杂的查询。当它们问世时，被认为是一种奇怪的数学符号。为了将这些想法构建到数据库管理系统中，Ted创建了一个名为<a class="ae lq" href="https://en.wikipedia.org/wiki/IBM_System_R" rel="noopener ugc nofollow" target="_blank"> System R </a>的研究小组，该小组基于圣何塞的IBM研究机构。</p><p id="4056" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那时，数据库主要基于<a class="ae lq" href="https://databasemanagement.fandom.com/wiki/Navigational_Database" rel="noopener ugc nofollow" target="_blank">导航</a>、<a class="ae lq" href="https://www.techopedia.com/definition/20971/network-database" rel="noopener ugc nofollow" target="_blank">网络</a>和<a class="ae lq" href="https://www.techopedia.com/definition/19782/hierarchical-database" rel="noopener ugc nofollow" target="_blank">层级</a>模型，在我们能够编写描述我们的查询的导航计划之前，我们需要知道物理数据层。然而，Ted看到了其中固有的复杂性，并希望使编写数据库查询变得更容易。</p><p id="cbef" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，由于Ted的想法是基于数学符号和数学象征的，它们很难理解，大多数人也不太容易理解，所以两位System R成员通过创建一种简单的查询语言来解决这个问题based。由于这种新语言完全基于英语单词，这成为一个突破，使人们更容易理解Ted的简单思想。</p><p id="abc4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">到20世纪70年代末，关系数据库越来越受欢迎，世界开始接受SQL和关系模型比它的前辈优越。此后的故事众所周知——随着世界进入数字革命，关系数据库已经成为构建软件的标准。</p><h1 id="fbe8" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">SQL和Graql的本质</h1><p id="bd57" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">在理解Graql时，看看创建SQL的基本思想是很有用的，因为它们在概念上是密切相关的。Graql和SQL的本质可以总结如下:</p><ol class=""><li id="8c21" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp nc lx ly lz bi translated"><strong class="kw iu">一种可以直观阅读和理解的语言。当一种语言看起来简单、可维护并且与自然文本有一定程度的相似性时，我们说它满足这些标准。</strong></li><li id="d709" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp nc lx ly lz bi translated"><strong class="kw iu">一种能够提出更高层次问题的语言。</strong>这里我们指的是一种允许用户在新的和更高的语义层次上描述操作的语言。</li><li id="714d" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp nc lx ly lz bi translated">一种语言，在这种语言中，系统计算出如何进行低级操作。当用户描述更高层次的操作时，系统会处理这些操作，而无需用户去想它们。</li></ol><p id="a308" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从这个意义上说，SQL和Graql都是抽象低级操作的语言。实际上，这意味着那些原本无法接触到这些语言的人群可以接触到这些语言。这意味着它们能够创造价值，而那些已经可以使用它们的人现在可以更快地做事。Python也有类似的情况，例如，它是一种高级编程语言，使数百万程序员能够构建软件，而不必担心被抽象掉的低级操作。</p><h1 id="9f9e" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">建模和定义模式</h1><p id="0155" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">首先，让我们看看SQL和Graql之间的数据建模有何不同。我们使用<a class="ae lq" href="https://en.wikipedia.org/wiki/Entity%E2%80%93relationship_model" rel="noopener ugc nofollow" target="_blank">实体关系图</a> (ER图)，因为它是最常用的建模工具。基本模型由实体类型和它们之间可能存在的关系组成。下面是一个ER图示例。我们称之为概念模型。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/fdaf1dcbae0f83d16390fe34bd543c92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1RGaf24wegdlpmjf.png"/></div></div></figure><p id="fbb0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="ne"> ER图示例。正方形是实体，菱形是关系，圆形是属性。</em></p><h1 id="2f99" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">SQL建模</h1><p id="d3b8" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">如果我们在关系数据库中实现这个模型，我们首先要经历一个规范化过程。我们从<a class="ae lq" href="https://en.wikipedia.org/wiki/First_normal_form" rel="noopener ugc nofollow" target="_blank">第一范式</a> (1NF)开始，通过寻找诸如函数依赖和传递依赖之类的东西，我们最终得到我们想要的<a class="ae lq" href="https://en.wikipedia.org/wiki/Third_normal_form" rel="noopener ugc nofollow" target="_blank">第三范式</a> (3NF)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/9d3d47c2c9d234c6f847015e20681834.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e2_1tfFTWG0i4P6m4cr2tQ.png"/></div></div><p class="ng nh gj gh gi ni nj bd b be z dk translated"><em class="nk">从1NF归一化到3NF。</em></p></figure><p id="bc11" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这个规范化过程之后，我们在3NF中得到我们的逻辑模型，并在关系数据库中实现它。我们已经从概念模型(ER图)发展到逻辑模型(3NF)，甚至不需要深入到数据库的物理层。这正是关系模型带给我们的突破——抽象出物理层次。我们称之为数据的物理独立性。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/15bc0ca7e75a8d1b917b1776ece7316c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZLmDgq-B4TMHVaxL4xm5GA.png"/></div></div><p class="ng nh gj gh gi ni nj bd b be z dk translated"><em class="nk"> SQL给了我们数据的物理独立性。</em></p></figure><h1 id="1510" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">Graql建模</h1><p id="5c67" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">现在让我们来看看它与Graql有何不同。<em class="ne">我们可以将任何ER图直接映射到我们如何在Graql </em>中实现它，这意味着我们不需要经过规范化过程。下面我们可以看到早期er图的特定部分是如何建模的。我们避免了进行任何标准化的需要，因为Graql使我们能够创建一个带有实体、关系、属性和角色的ER图的直接映射，以便我们稍后在代码中实现它。这与SQL不同，在SQL中，我们需要在模型上强加一个表格结构作为逻辑层(如上所述)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/10702cc861ac9c230c650b4c62d7114f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xHGC7HO_EKIACCEeLgWuiQ.png"/></div></div><p class="ng nh gj gh gi ni nj bd b be z dk translated"><em class="nk"> ER图(左)到Graql模型(右)。</em></p></figure><p id="45ad" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这意味着我们完全跳过了SQL中所需的规范化过程，我们继续在概念模型上工作。换句话说，Graql抽象出了逻辑和物理模型。从这个意义上说，SQL给了我们数据的物理独立性，而Graql给了我们数据的逻辑独立性。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/7cc1c50e7a46f597e9ebf5900856f775.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nssT1V92ePr4CZa_EVEN-g.png"/></div></div><p class="ng nh gj gh gi ni nj bd b be z dk translated">通过在概念层面建模，Graql为我们提供了逻辑模型的抽象。</p></figure><h1 id="494e" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">在SQL和Graql中定义模式</h1><p id="f07e" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">现在我们来看一些真实的数据。任何学习过SQL的人可能都熟悉Northwind数据集。它包含虚构的专业食品进出口公司Northwind Traders的销售数据。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/42c1f78218937e54e9aa6d809eee94f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Qer7tksJI6z4ZyMD.png"/></div></div><p class="ng nh gj gh gi ni nj bd b be z dk translated">北风模式。</p></figure><p id="3a42" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们如何在Graql和SQL中定义上面显示的<code class="fe np nq nr ns b">products</code>表？下面我们看到Graql语法定义了<code class="fe np nq nr ns b">product</code>实体，以及相应的<code class="fe np nq nr ns b">relation</code>。这也显示了创建新表的<code class="fe np nq nr ns b">SQL</code>语句和相应的属性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ng nh gj gh gi ni nj bd b be z dk translated">Graql</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ng nh gj gh gi ni nj bd b be z dk translated">结构化查询语言</p></figure><p id="0aa1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">几个要点:</p><ul class=""><li id="182d" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated">这里我们可以看到SQL表有三个属性，每个属性都有自己的数据类型，我们也可以在Graql中定义。其中一个属性是<code class="fe np nq nr ns b">primary key</code>，我们在Graql中使用<code class="fe np nq nr ns b">key</code>关键字定义了它。</li><li id="b7e1" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">在SQL语句中，还有一个<code class="fe np nq nr ns b">foreign key</code>，根据我们的模型，我们将其建模为Graql中的相关<code class="fe np nq nr ns b">relation</code>。我们通过使用角色<code class="fe np nq nr ns b">product-assignment</code>将<code class="fe np nq nr ns b">product</code>实体连接到<code class="fe np nq nr ns b">assignment</code>关系来做到这一点。</li><li id="8cdd" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">在Graql中，没有<code class="fe np nq nr ns b">null</code>值的概念。如果一个概念没有属性，它就真的没有属性。这是因为在图上下文中，空属性被简单地从图中省略了。</li><li id="fe59" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">最后，重要的一点是，在Graql模型中，属性是<a class="ae lq" href="https://en.wikipedia.org/wiki/First-class_citizen" rel="noopener ugc nofollow" target="_blank">一等公民</a>，不像在SQL中。</li></ul><p id="1835" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">总结一下:</p><ul class=""><li id="2311" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated">将ER图建模为SQL包含一个从1NF到3NF的规范化过程</li><li id="0f27" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">ER图自然地映射到Graql，不需要执行任何类型的规范化</li></ul><p id="6022" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="ne">在第2部分中(</em> <a class="ae lq" href="https://blog.grakn.ai/comparing-graql-to-sql-part-2-2-745f79e9528d" rel="noopener ugc nofollow" target="_blank"> <em class="ne">链接此处</em> </a> <em class="ne">)，我们看看如何读/写数据，以及我们应该如何在Graql中利用超图和自动推理进行更高级别的建模。</em></p></div></div>    
</body>
</html>