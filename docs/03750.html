<html>
<head>
<title>Build A Keyword Extraction API with Spacy, Flask, and FuzzyWuzzy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Spacy、Flask 和 FuzzyWuzzy 构建一个关键词提取 API</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/build-a-keyword-extraction-api-with-spacy-flask-and-fuzzywuzzy-4909d7ffc105?source=collection_archive---------9-----------------------#2020-04-08">https://towardsdatascience.com/build-a-keyword-extraction-api-with-spacy-flask-and-fuzzywuzzy-4909d7ffc105?source=collection_archive---------9-----------------------#2020-04-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="22f4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何在 python 中构建一个轻量级的关键字提取和模糊词匹配服务？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/65d12feba9a7d1297c27a2b4e7309544.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8euZTPfBnpJdEeEM"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@worksite?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">工地有限公司</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="814f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，在处理长文本序列时，您会希望将这些序列分解开来，并提取单个关键字来执行搜索或查询数据库。</p><p id="6f07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果输入文本是自然语言，您很可能不希望使用每个单词来查询数据库，相反，您可能希望从输入中选择一组唯一的关键字，并使用这些单词或单词短语来执行有效的搜索。</p><p id="7335" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这项任务被称为关键词提取，多亏了像<a class="ae ky" href="https://spacy.io/" rel="noopener ugc nofollow" target="_blank"> Spacy </a>这样的生产级 NLP 工具，只需几行 Python 代码就可以完成。在本文中，我们将涵盖:</p><ul class=""><li id="d315" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">如何使用 Spacy 构建一个简单而健壮的关键词提取工具</li><li id="a11c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">如何使用<a class="ae ky" href="https://github.com/seatgeek/fuzzywuzzy" rel="noopener ugc nofollow" target="_blank"> fuzzyWuzzy </a>处理拼写错误并找到给定关键字(令牌)的模糊匹配</li><li id="64dd" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">如何用<a class="ae ky" href="https://flask.palletsprojects.com/en/1.1.x/" rel="noopener ugc nofollow" target="_blank"> Flask </a>将这两个函数包装成 REST API 端点</li></ul><p id="0abc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个轻量级 API 旨在成为许多用例的通用关键字服务。当然，您也可以使用相同的通用结构将 Spacy 众多 NLP 函数中的任何一个构建到这个 API 中。</p><p id="0c1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们开始之前，确保运行:<code class="fe mj mk ml mm b">pip install flask flask-cors spacy fuzzywuzzy</code>来安装所有需要的包。</p><h1 id="95a6" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">基于空间的关键词提取</h1><p id="3929" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">对于关键字提取功能，我们将使用 Spacy 的两个核心思想——核心语言模型和文档对象。</p><p id="362c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Spacy <a class="ae ky" href="https://spacy.io/models" rel="noopener ugc nofollow" target="_blank">核心语言模型</a>有:</p><blockquote class="nk"><p id="a4bc" class="nl nm it bd nn no np nq nr ns nt lu dk translated">通用预训练模型，用于预测命名实体、词性标签和句法依赖性。可以开箱即用，并针对更具体的数据进行微调。</p></blockquote><p id="fc58" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">空间<a class="ae ky" href="https://spacy.io/api/doc" rel="noopener ugc nofollow" target="_blank">文档</a>对象为:</p><blockquote class="nk"><p id="ff58" class="nl nm it bd nn no np nq nr ns nt lu dk translated">用于访问语言注释的容器……(和)是一个标记结构数组</p></blockquote><p id="c79d" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">因此，随着通过模型创建的文档对象的创建，我们可以访问大量非常有用(且强大)的 NLP 派生属性和功能，包括词类标签和名词块，它们将是关键字提取器功能的核心。</p><h2 id="b214" class="nz mo it bd mp oa ob dn mt oc od dp mx li oe of mz lm og oh nb lq oi oj nd ok bi translated">下载语言模型</h2><p id="b2bb" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">使用 Spacy，我们必须首先下载我们想要使用的语言模型。到今天为止，Spacy 目前的<code class="fe mj mk ml mm b">version 2.2.4</code>已经有了 10 种不同语言的语言模型，都有不同的大小。我将使用英文核心模型的小版本。我选择了小模型，因为对于 Heroku 部署来说，大模型的内存大小有问题。根据您部署该模型的位置/方式，您可能能够使用大型模型。要使用 Spacy 的 CLI 下载语言模型，请在终端中运行以下命令:</p><blockquote class="ol om on"><p id="d586" class="kz la oo lb b lc ld ju le lf lg jx lh op lj lk ll oq ln lo lp or lr ls lt lu im bi translated"><code class="fe mj mk ml mm b">python -m spacy download en_core_web_sm</code></p></blockquote><p id="b192" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们构建 flask API 时，我们将使用 python 内置的<em class="oo">子进程</em>包，在服务启动后在应用程序本身中运行这个命令。但是现在，我们可以在命令行中这样做。</p><p id="9b15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在下载好模型后，你可以加载它并创建<code class="fe mj mk ml mm b">nlp</code>对象:</p><pre class="kj kk kl km gt os mm ot ou aw ov bi"><span id="a883" class="nz mo it mm b gy ow ox l oy oz">import spacy</span><span id="c280" class="nz mo it mm b gy pa ox l oy oz">nlp = spacy.load("en_core_web_sm”)</span></pre><p id="8075" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的语言模型<code class="fe mj mk ml mm b">nlp</code>将作为参数传递给下面的<code class="fe mj mk ml mm b">extract_keywords()</code>函数，以生成<code class="fe mj mk ml mm b">doc</code>对象。</p><p id="c0fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关键字提取函数有 3 个参数:</p><ul class=""><li id="9c28" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">语言模型<code class="fe mj mk ml mm b">nlp</code></li><li id="d4ff" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">sequence</code>我们要从中提取关键字的字符串。</li><li id="5131" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">以及可选的字符串列表<code class="fe mj mk ml mm b">special_tags</code>。此参数允许用户指定一个特殊的单词/短语列表，如果它们存在于序列中，则默认情况下会添加到输出中。</li></ul><p id="9ee3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的代码片段显示了该函数是如何工作的:</p><ol class=""><li id="24fe" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu pb mb mc md bi translated">通过语言模型传递字符串序列来创建<code class="fe mj mk ml mm b">doc</code>对象。</li><li id="51af" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu pb mb mc md bi translated">如果特殊记号出现在序列中，则将它们添加到最终结果中。</li><li id="38da" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu pb mb mc md bi translated">迭代文档的<a class="ae ky" href="https://spacy.io/usage/linguistic-features#noun-chunks" rel="noopener ugc nofollow" target="_blank">名词组块</a>，如果所有组块的标记都在期望的<code class="fe mj mk ml mm b">pos_tag</code>列表中，则向结果添加一个名词组块。</li><li id="a10e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu pb mb mc md bi translated">最后，我们迭代所有的单个标记，并添加那些在期望的<code class="fe mj mk ml mm b">pos_tag</code>集合中的标记，而不是语言模型的默认停用词列表的一部分。<em class="oo">如有需要，可将自定义停用词追加到该列表中。</em></li></ol><p id="2abe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，该函数返回结果变量中结束的所有唯一单词<strong class="lb iu">的列表。</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pc pd l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用 Spacy 的关键字提取代码</p></figure><h1 id="49fc" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">带有 FuzzyWuzzy 的模糊字符串匹配</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pe pd l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源<a class="ae ky" href="https://www.reddit.com/r/reddit.com/comments/k5vqa/are_you_sure/" rel="noopener ugc nofollow" target="_blank"> u/lawlesskenny </a></p></figure><p id="b2d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当人类打字时，错别字和错误是不可避免的。在关键字搜索/匹配的环境中，这是一个问题，但是使用模糊匹配算法可以很好地解决这个问题。</p><p id="f131" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python 包 FuzzyWuzzy 实现了一个非常有效的模糊匹配算法:<a class="ae ky" href="https://en.wikipedia.org/wiki/Levenshtein_distance" rel="noopener ugc nofollow" target="_blank"> Levenshtein 距离</a>。</p><p id="4edb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Levenshtein Distance 是一个公式，用于计算将源单词<em class="oo"> S </em>转换为目标单词<em class="oo"> T. </em>的成本。该算法会惩罚需要进行许多更改才能转换为目标单词的源单词，并支持需要较小转换的单词。关于 FuzzyWuzzy 如何实现这种检查的详细而直观的解释，请参见 Luciano Strika 的文章。</p><div class="ph pi gp gr pj pk"><a rel="noopener follow" target="_blank" href="/fuzzywuzzy-how-to-measure-string-distance-on-python-4e8852d7c18f"><div class="pl ab fo"><div class="pm ab pn cl cj po"><h2 class="bd iu gy z fp pp fr fs pq fu fw is bi translated">FuzzyWuzzy:如何在 Python 上测量字符串距离</h2><div class="pr l"><h3 class="bd b gy z fp pp fr fs pq fu fw dk translated">FuzzyWuzzy 是一个 Python 库，用于测量两个字符串之间的相似性。以下是您开始使用它的方法…</h3></div><div class="ps l"><p class="bd b dl z fp pp fr fs pq fu fw dk translated">towardsdatascience.com</p></div></div><div class="pt l"><div class="pu l pv pw px pt py ks pk"/></div></div></a></div><h2 id="1df2" class="nz mo it bd mp oa ob dn mt oc od dp mx li oe of mz lm og oh nb lq oi oj nd ok bi translated">使用 FuzzyWuzzy</h2><p id="7a93" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">模糊匹配实现起来非常快。从包中导入<code class="fe mj mk ml mm b">ratio</code>会导入默认的 Levenshtein 距离评分机制，而<code class="fe mj mk ml mm b">process.extractBests()</code>允许我们计算一系列目标的 Levenshtein 距离，并返回高于定义的截止点的结果。为了获得最佳匹配结果，您可能需要对<code class="fe mj mk ml mm b">score_cutoff</code>参数进行微调。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pc pd l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">模糊匹配实现</p></figure><h1 id="197e" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">烧瓶应用</h1><p id="6987" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">差不多了，现在剩下要做的就是把所有东西都打包到两个非常简单的烧瓶端点中。对于下面的要点，请确保导入模糊匹配器和关键字提取服务，或者在 app.py 本身中声明它们。</p><p id="8df2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你是 Flask 的新手，我建议看看他们的<a class="ae ky" href="https://flask.palletsprojects.com/en/1.1.x/quickstart/#a-minimal-application" rel="noopener ugc nofollow" target="_blank">文档</a>快速入门指南。它们提供了如何启动和运行的简单、最小的示例。</p><p id="46c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该应用程序有两个端点:</p><ul class=""><li id="8506" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">api/keywords</code></li><li id="cb65" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe mj mk ml mm b">api/fuzzy-matches</code></li></ul><p id="a52f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两个端点都接收 POST 请求，因此参数通过请求体传递给每个端点。</p><p id="f1c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能还注意到，我们使用前面提到的子流程模块在应用程序内部以编程方式调用 Spacy CLI。如果您需要将它部署到云服务，并且忘记通过 CLI 手动下载模型，这将非常有用。</p><p id="adf4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在两个端点之外加载语言模型，因为我们希望这个对象在我们的服务运行时无限期地持久，而不必在每次发出请求时都加载它。这使得添加使用 Spacy 功能的新端点变得容易，因为它们可以共享相同的语言模型，该语言模型可以作为参数提供。</p><p id="9fe1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">应该就是这样了，在项目目录的命令行中运行下面实现的代码<code class="fe mj mk ml mm b">flask run</code>，这应该会在您的本地主机上启动 API。</p><p id="ee44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在 Postman 中测试端点，以确保它们的行为符合预期。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pc pd l"/></div></figure><div class="kj kk kl km gt ab cb"><figure class="pz kn qa qb qc qd qe paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/90393a384898bd1cabdfdddd888c61ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/1*SC0rEjrwpsMQIW-QaS8VBg.gif"/></div></figure><figure class="pz kn qf qb qc qd qe paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/93abfb6dde60b527b8354c0dbae212e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/1*SuZ6IDe2-KXhjZsGcSP_Bg.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk qg di qh qi translated">两个端点的邮递员请求</p></figure></div><p id="9fec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想将 API 部署到云服务，如 Heroku，请查看:</p><div class="ph pi gp gr pj pk"><a href="https://medium.com/the-andela-way/deploying-a-python-flask-app-to-heroku-41250bda27d0" rel="noopener follow" target="_blank"><div class="pl ab fo"><div class="pm ab pn cl cj po"><h2 class="bd iu gy z fp pp fr fs pq fu fw is bi translated">在 Heroku 上部署 Python Flask 应用程序</h2><div class="pr l"><h3 class="bd b gy z fp pp fr fs pq fu fw dk translated">在我之前的文章中，我描述了我是如何使用 Flask 开发 API 的。我简单讲了一下我是如何主持…</h3></div><div class="ps l"><p class="bd b dl z fp pp fr fs pq fu fw dk translated">medium.com</p></div></div><div class="pt l"><div class="qj l pv pw px pt py ks pk"/></div></div></a></div><p id="27f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的文章是几年前的了，原理还是一样的，你也可以直接在 heroku 的网站上设置一个应用程序，然后通过 CLI 推送。</p><h1 id="e50d" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">结论</h1><p id="8450" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">这应该有望帮助您启动并运行这个简单的 API。我发现在很多情况下，我需要这样一个简单的服务来处理文本输入或执行某种 NLP 任务。这个设置<em class="oo">希望</em>有所帮助的是，它应该很容易允许添加额外的空间 NLP 服务作为端点，而无需任何重大更改。</p><p id="3650" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你有任何问题或者在我提供的任何代码中发现了一个<strong class="lb iu">错误</strong>,请告诉我，感谢阅读！</p></div><div class="ab cl qk ql hx qm" role="separator"><span class="qn bw bk qo qp qq"/><span class="qn bw bk qo qp qq"/><span class="qn bw bk qo qp"/></div><div class="im in io ip iq"><p id="66ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[1]空间文档。模特。<a class="ae ky" href="https://spacy.io/models" rel="noopener ugc nofollow" target="_blank">https://spacy.io/models</a></p><p id="470a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[2]空间文档。文档对象。<a class="ae ky" href="https://spacy.io/api/doc" rel="noopener ugc nofollow" target="_blank">https://spacy.io/api/doc</a></p></div></div>    
</body>
</html>