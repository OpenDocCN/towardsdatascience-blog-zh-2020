<html>
<head>
<title>The Python Standard Library — modules you should know as a data scientist</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python标准库——作为数据科学家应该知道的模块</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-python-standard-library-modules-you-should-know-as-a-data-scientist-47e1117ca6c8?source=collection_archive---------15-----------------------#2020-05-27">https://towardsdatascience.com/the-python-standard-library-modules-you-should-know-as-a-data-scientist-47e1117ca6c8?source=collection_archive---------15-----------------------#2020-05-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1b9c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">带有用法示例</h2></div><p id="7342" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Python标准库包含大量处理日常编程的模块，并且包含在Python的标准版本中，这意味着不需要额外安装。它为与操作系统交互、读写CSV文件、生成随机数以及处理日期和时间等任务提供了模块。本文描述了Python标准库的8个模块，我相信你在用Python编程时会遇到这些模块。我们开始吧！🙌</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/88c3de638cec133df9337b6cfec3029b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*43ckfURAU9NYm7Da"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">克里斯里德在<a class="ae lu" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="f80b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">1.Zipfile</h1><p id="d34c" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated"><strong class="kk iu"> zipfile </strong>库提供了轻松处理zip文件的工具。它允许你直接在<strong class="kk iu"> Python </strong>中创建、读取和写入zip文件，而不需要使用外部程序。</p><h2 id="c5f7" class="ms lw it bd lx mt mu dn mb mv mw dp mf kr mx my mh kv mz na mj kz nb nc ml nd bi translated">阅读压缩文件</h2><p id="e45a" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">要在<strong class="kk iu"> Python </strong>中打开一个zip文件，我们使用<a class="ae lu" href="https://docs.python.org/3/library/zipfile.html#zipfile-objects" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> zipfile。ZipFile类</strong> </a>，提供<strong class="kk iu">文件路径</strong>和打开模式作为输入。由于我们想以<strong class="kk iu">阅读模式</strong>打开文件，所以我们提供了<strong class="kk iu"> mode='r' </strong>。</p><p id="cb1b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> ZipFile </strong>构造函数返回一个<strong class="kk iu"> ZipFile </strong>对象，我们将它赋给变量<strong class="kk iu"> myzip </strong>。然后，我们使用<strong class="kk iu">。extractall(path=None，members=None，pwd=None) </strong>方法将所有成员从zip文件提取到当前工作目录。为了提取zip文件的部分成员，而不是全部，我们可以将他们的名字提供给参数<strong class="kk iu">成员</strong>。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="bd44" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">运行上面的代码后，我们可以打开当前目录来检查文件是否被正确提取。或者，我们可以使用<strong class="kk iu"> os.listdir() </strong>函数(在<strong class="kk iu"> os模块</strong>中定义)来获取工作目录中包含的条目列表。</p><p id="a499" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们使用<strong class="kk iu">关闭<strong class="kk iu"> zip文件</strong>。</strong>方法关闭()。当我们不再需要文件时，记住关闭所有文件以避免用完文件句柄是很重要的。</p><p id="2705" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于在Python中工作时很容易忘记关闭文件，所以我们可以使用带有语句的<strong class="kk iu">，该语句在嵌套代码块执行后自动关闭<strong class="kk iu"> zip文件</strong>。</strong></p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="04ae" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们想获得zip文件中包含的成员列表而不提取它们，我们可以使用<strong class="kk iu">。namelist() </strong>方法如下。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h2 id="1675" class="ms lw it bd lx mt mu dn mb mv mw dp mf kr mx my mh kv mz na mj kz nb nc ml nd bi translated">写一个zip文件</h2><p id="aa1a" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">我们使用<strong class="kk iu"> zipfile在<strong class="kk iu"> Python </strong>中创建和打开一个新的<strong class="kk iu"> zip文件</strong>。ZipFile </strong>类处于写模式<strong class="kk iu"> mode='w' </strong>。创建zip文件后，我们调用<strong class="kk iu">。write()方法</strong>添加一个文件如下。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="f38a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码在当前工作目录下创建一个新的<strong class="kk iu"> zip文件</strong> (new_file.zip)，包含两个。txt文件(file_1.txt和file_2.txt)。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="eb01" class="lv lw it bd lx ly nn ma mb mc no me mf jz np ka mh kc nq kd mj kf nr kg ml mm bi translated">2.随意</h1><p id="1125" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated"><strong class="kk iu">随机数</strong>在人工智能和数据科学中扮演着重要的角色。我们使用随机数在每个时期之前打乱训练数据，在神经网络中设置初始权重，分离训练和测试数据，或者进行A/B测试。</p><p id="a5bc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Python标准库提供了大量用于生成随机数的函数。让我们看看其中的一些！</p><h2 id="24f5" class="ms lw it bd lx mt mu dn mb mv mw dp mf kr mx my mh kv mz na mj kz nb nc ml nd bi translated">随机. randint</h2><p id="1530" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated"><strong class="kk iu"> random.randint(a，b) </strong>函数返回一个在<strong class="kk iu"> a </strong>和<strong class="kk iu"> b </strong>之间的<strong class="kk iu">随机整数</strong>(两者都包含在内)。</p><p id="ec07" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> Numpy </strong>还提供了生成随机整数的函数(<strong class="kk iu"> numpy.random.randint </strong>)。但与<strong class="kk iu"> random.randint </strong>不同的是，不包含上界。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h2 id="7936" class="ms lw it bd lx mt mu dn mb mv mw dp mf kr mx my mh kv mz na mj kz nb nc ml nd bi translated"><strong class="ak">随机选择</strong></h2><p id="675f" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated"><strong class="kk iu"> random.choices(population，weights=None，*，cum_weights=None，k=1) </strong>函数返回从<strong class="kk iu">人口</strong>中随机选择的<strong class="kk iu"> k </strong>个元素的列表，替换为<strong class="kk iu">。</strong>我们可以使用<strong class="kk iu">权重</strong>参数来衡量每个值被选中的可能性。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h2 id="5e9e" class="ms lw it bd lx mt mu dn mb mv mw dp mf kr mx my mh kv mz na mj kz nb nc ml nd bi translated"><strong class="ak"> random.shuffle </strong></h2><p id="4283" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated"><strong class="kk iu"> random.shuffle(x[，random]) </strong>函数将序列<strong class="kk iu"> x </strong>就地打乱，返回<strong class="kk iu"> None </strong>。因此，函数的输入必须是可变对象。如果我们提供一个不可变的序列作为输入(例如一个字符串)，就会出现一个异常(<strong class="kk iu"> TypeError </strong>)。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="0ca1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了混洗不可变的对象，我们可以使用<strong class="kk iu"> random.sample(population，k) </strong>函数。该函数返回从<strong class="kk iu">群体</strong>中随机选择的<strong class="kk iu"> k </strong>个元素的列表，没有替换。通过设置函数<strong class="kk iu"> k=len(population) </strong>的第二个参数，我们获得了一个所有元素都被随机打乱的新列表。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="7d4e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如上图所示，我们可以使用内置函数<strong class="kk iu"> tuple() </strong>将<strong class="kk iu">混洗列表</strong>转换为<strong class="kk iu">元组</strong>。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="a8f4" class="lv lw it bd lx ly nn ma mb mc no me mf jz np ka mh kc nq kd mj kf nr kg ml mm bi translated">3.操作系统（Operating System）</h1><p id="1ebc" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated"><strong class="kk iu"> os </strong>模块提供与<strong class="kk iu">操作系统</strong>交互的功能。它包含许多用于处理<strong class="kk iu">目录</strong>、<strong class="kk iu">路径</strong>和<strong class="kk iu">文件</strong>的工具。在本文中，我们将只讨论由<strong class="kk iu"> os </strong>提供的一些功能。</p><h2 id="4752" class="ms lw it bd lx mt mu dn mb mv mw dp mf kr mx my mh kv mz na mj kz nb nc ml nd bi translated"><strong class="ak">获取当前工作目录</strong></h2><p id="49a8" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">函数的作用是:返回当前工作目录的路径。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="c68a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如上所示，该函数没有参数，返回一个字符串数据类型。</p><h2 id="96d0" class="ms lw it bd lx mt mu dn mb mv mw dp mf kr mx my mh kv mz na mj kz nb nc ml nd bi translated">更改当前工作目录</h2><p id="ae5c" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated"><strong class="kk iu"> os.chdir() </strong>函数将当前工作目录修改为给定路径，返回<strong class="kk iu"> None </strong>。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="f49e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">更改目录后，我们可以使用<strong class="kk iu"> os.getcwd() </strong>函数来验证修改。</p><h2 id="0ea1" class="ms lw it bd lx mt mu dn mb mv mw dp mf kr mx my mh kv mz na mj kz nb nc ml nd bi translated">文件和目录列表</h2><p id="c658" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated"><strong class="kk iu"> os.listdir(path) </strong>函数返回指定<strong class="kk iu">路径</strong>中所有文件和目录的列表。如果<strong class="kk iu">路径</strong>被省略，<strong class="kk iu"> os.list() </strong>函数返回<strong class="kk iu">当前工作目录</strong>中的条目列表。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="0b45" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以结合使用<strong class="kk iu"> os.listdir() </strong>函数和其他函数来过滤返回的列表。如下图，我们用的是字符串方法<strong class="kk iu">。endswith() </strong>获取当前工作目录中的文本文件列表。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h2 id="e349" class="ms lw it bd lx mt mu dn mb mv mw dp mf kr mx my mh kv mz na mj kz nb nc ml nd bi translated">将文件重命名为o目录</h2><p id="5d25" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">Python允许您使用<strong class="kk iu"> os.rename(src，dst) </strong>函数以编程方式重命名文件或目录。该函数将文件或目录<strong class="kk iu"> src </strong>重命名为<strong class="kk iu"> dst </strong>并返回<strong class="kk iu"> None </strong>。如果你试图重命名一个不存在的文件或目录<strong class="kk iu">，Python </strong>会抛出<strong class="kk iu"> OSError </strong>异常。</p><p id="a1a4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面的块代码将文件<strong class="kk iu"> file_1.txt </strong>重命名为<strong class="kk iu"> file_new_name.txt </strong>。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="893f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如上所示，我们使用<strong class="kk iu"> os.listdir() </strong>函数来检查修改是否正确执行。</p><h2 id="f483" class="ms lw it bd lx mt mu dn mb mv mw dp mf kr mx my mh kv mz na mj kz nb nc ml nd bi translated">创建一个新目录</h2><p id="407d" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">函数<strong class="kk iu"> os.mkdir(path[，mode]) </strong>允许您创建一个名为<strong class="kk iu"> path </strong>的目录，其模式为数字<strong class="kk iu"/>。<strong class="kk iu">模式</strong>使用八进制数表示<strong class="kk iu">文件的权限</strong>(谁可以读、写或执行目录)。如果省略参数mode，则使用默认值0o777，使所有三个用户组都能够读取、写入和执行目录。</p><p id="a5f8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在下面的代码块中，我们在当前工作目录中创建了一个名为<strong class="kk iu"> new_dir </strong>的新目录。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="d666" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">函数<strong class="kk iu"> os.mkdir() </strong>在现有目录中创建一个目录。如果您试图在一个不存在的地方创建一个目录，就会引发异常。或者，您可以使用函数<strong class="kk iu"> os.mkdirs() </strong>(带s)来创建中间文件夹，如果它们不存在的话。</p><h2 id="f2cd" class="ms lw it bd lx mt mu dn mb mv mw dp mf kr mx my mh kv mz na mj kz nb nc ml nd bi translated"><strong class="ak">启动一个文件</strong></h2><p id="71f2" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated"><strong class="kk iu"> os.startfile(path[，operation]) </strong>用相关应用程序启动一个文件。默认的<strong class="kk iu">操作</strong>是<strong class="kk iu">‘打开’</strong>，就像你双击一个文件，在你的电脑上打开它。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="cecf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面的代码将打开。txt文件(<strong class="kk iu"> file_2 </strong>)及其相关程序(在我的例子中是Windows编辑器)。</p><p id="8798" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些只是<strong class="kk iu">操作系统模块</strong>中可用的几个功能。阅读文档以了解更多信息！</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="7be6" class="lv lw it bd lx ly nn ma mb mc no me mf jz np ka mh kc nq kd mj kf nr kg ml mm bi translated">4.时间</h1><h2 id="75dc" class="ms lw it bd lx mt mu dn mb mv mw dp mf kr mx my mh kv mz na mj kz nb nc ml nd bi translated">测量执行时间</h2><p id="a0a8" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">我们可以使用<strong class="kk iu"> time.time() </strong>函数来测量一段代码的执行时间。该函数返回自纪元以来经过的秒数。epoch是时间开始的点(<strong class="kk iu"> time.time() </strong>将返回0)，它依赖于平台，在Windows系统上是1970年1月1日00:00:00 (UTC)。</p><p id="401e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们计算执行时间(挂钟时间)，用下面的方式减去代码块前后的时间。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="8003" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们想计算<strong class="kk iu"> CPU时间</strong>而不是<strong class="kk iu">运行时间</strong>，我们使用<strong class="kk iu"> time.clock() </strong>函数。经过的时间通常比CPU时间长，因为CPU也可以在代码块运行时执行其他指令。</p><h2 id="1091" class="ms lw it bd lx mt mu dn mb mv mw dp mf kr mx my mh kv mz na mj kz nb nc ml nd bi translated">暂停执行</h2><p id="ac7e" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated"><strong class="kk iu"> time.sleep(secs) </strong>暂停程序执行给定的秒数<strong class="kk iu"> secs </strong>。在用<strong class="kk iu"> Python </strong>抓取网页时，这个函数就派上用场了。</p><p id="65a4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">大多数时候，我们希望尽可能快地执行代码。但是在<strong class="kk iu">网页抓取</strong>中，建议在请求之间暂停程序的执行，以免服务器不堪重负。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="b91f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如上所示，在两次请求之间，执行会暂停2秒钟。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="2a56" class="lv lw it bd lx ly nn ma mb mc no me mf jz np ka mh kc nq kd mj kf nr kg ml mm bi translated">5.日期时间</h1><p id="9cfd" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated"><strong class="kk iu"> datetime </strong>库提供了许多在<strong class="kk iu"> Python </strong>中处理日期和时间的工具。使用<strong class="kk iu">日期时间</strong>模块，我们可以很容易地获得当前时间，减去两个日期，或者将日期转换成定制格式的字符串。</p><p id="cf26" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">导入库之后，我们用<strong class="kk iu"> datetime.datetime() </strong>函数创建一个<strong class="kk iu"> datetime </strong>对象。该函数需要三个参数:(1)年，(2)月，和(3)日，是小时、分钟、秒、微秒和时区可选参数。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="b187" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如上所示，该函数返回一个<strong class="kk iu">日期时间</strong>对象。该对象具有以下属性:年、月、日、小时、分钟、秒、微秒和tzinfo。我们可以使用点符号来访问它们，或者使用<strong class="kk iu"> getattr() </strong>函数。</p><p id="537b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们详细说明如何获取当前日期，减去两个日期，将一个<strong class="kk iu"> datetime </strong>对象转换成一个<strong class="kk iu"> string </strong>，反之亦然。</p><h2 id="dc46" class="ms lw it bd lx mt mu dn mb mv mw dp mf kr mx my mh kv mz na mj kz nb nc ml nd bi translated">当前本地日期和时间</h2><p id="1950" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">我们可以使用<strong class="kk iu">datetime . datetime . now(tz = None)</strong>函数轻松获得当前的本地日期和时间。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="d59c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如您所看到的，该函数返回一个具有以下格式的<strong class="kk iu">日期时间</strong>对象:<strong class="kk iu"> YYYY-MM-DD HH:MM:SS:MS </strong>。</p><h2 id="935a" class="ms lw it bd lx mt mu dn mb mv mw dp mf kr mx my mh kv mz na mj kz nb nc ml nd bi translated">减去两个日期</h2><p id="0f0b" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">我们可以用Python减去两个<strong class="kk iu"> datetime </strong>对象，结果得到一个<strong class="kk iu"> timedelta </strong>对象。该对象表示两个日期之间的时间跨度。</p><p id="6c68" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如下图，我们通过减去乔治·奥威尔的死亡日期和出生日期来计算他活了多久。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h2 id="9541" class="ms lw it bd lx mt mu dn mb mv mw dp mf kr mx my mh kv mz na mj kz nb nc ml nd bi translated">将日期时间对象转换为字符串</h2><p id="5133" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated"><strong class="kk iu">。strftime(format) </strong>方法将<strong class="kk iu"> datetime </strong>对象转换为<strong class="kk iu">字符串，</strong>接受<strong class="kk iu"> </strong>单个字符串参数(<strong class="kk iu"> format </strong>)作为输入<strong class="kk iu">。</strong>该参数指定了我们要返回的<strong class="kk iu">日期时间</strong>对象的哪一部分，以及以何种格式返回。</p><p id="8255" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下表包含Python中可用的一些指令。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/fb44147ce5b9854e1227ce03b3d73a8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:938/format:webp/1*i8s58bWP91y-LU4HU1518A.png"/></div></figure><p id="97f9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们使用上面列出的指令创建不同格式的字符串来表示乔治·奥威尔的生日。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h2 id="82f2" class="ms lw it bd lx mt mu dn mb mv mw dp mf kr mx my mh kv mz na mj kz nb nc ml nd bi translated">将字符串转换为日期时间对象</h2><p id="5acd" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated"><strong class="kk iu">datetime . strptime(date _ string，format) </strong>函数从字符串创建一个datetime对象，与<strong class="kk iu">相反。strftime() </strong>方法。为了正确工作，作为输入传递的<strong class="kk iu">日期字符串</strong>需要匹配指定的<strong class="kk iu">格式</strong>。否则，会引发一个异常(<strong class="kk iu">值错误</strong>)。</p><p id="02c8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在下面的例子中，我们从代表乔治·奥威尔的出生日期的字符串中获得一个datetime对象。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ne nf l"/></div></figure></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="a8ed" class="lv lw it bd lx ly nn ma mb mc no me mf jz np ka mh kc nq kd mj kf nr kg ml mm bi translated">6.战斗支援车</h1><p id="50c4" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated"><strong class="kk iu">逗号分隔值</strong> (CSV)文件是用于传输信息的常用格式。信息的结构是一个<strong class="kk iu">表</strong>，其中每个<strong class="kk iu">行</strong>包含一个<strong class="kk iu">记录</strong>，每个<strong class="kk iu">列</strong>包含一个<strong class="kk iu">字段</strong>，即由<strong class="kk iu">逗号</strong>分隔的<strong class="kk iu">字段</strong>。尽管逗号是最常见的<strong class="kk iu">分隔符</strong>，但我们也可以使用其他分隔符，如空格或制表符。</p><p id="e5af" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下图显示了一个包含学生信息的<strong class="kk iu"> CSV文件</strong>。如下所示，文件的第一行包含字段名称(列标题)。</p><p id="60dc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于<strong class="kk iu"> CSV文件</strong>是<strong class="kk iu">纯文本文件</strong>，我们可以像<strong class="kk iu">微软记事本</strong>一样使用<strong class="kk iu">文本编辑器</strong>创建并打开它。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/19d5a7efc243384b052b63e5e1ef46c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:612/format:webp/1*XLHyQN2hJkxL8PiVP5kibw.png"/></div></figure><p id="1fe6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> Python标准库</strong>提供了一个内置模块，包含读取、处理和写入<strong class="kk iu"> CSV文件</strong>的类。尽管该模块对于简单的操作很有帮助，但建议使用<strong class="kk iu"> Pandas </strong>进行更复杂的数值分析。</p><h2 id="283b" class="ms lw it bd lx mt mu dn mb mv mw dp mf kr mx my mh kv mz na mj kz nb nc ml nd bi translated">读取CSV文件—阅读器功能</h2><p id="862d" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">导入库后，我们用内置函数<strong class="kk iu">打开</strong>打开CSV文件。接下来，我们将file对象传递给<strong class="kk iu"> csv.reader() </strong>函数，将函数的输出存储在一个名为<strong class="kk iu"> reader </strong>的变量中。然后，我们可以通过使用循环的<strong class="kk iu">迭代<strong class="kk iu">阅读器对象</strong>来访问文件的每一行。</strong></p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="bf0c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如上所示，<strong class="kk iu"> reader对象</strong>返回的每一行都是一个字符串列表。</p><p id="0e19" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者，我们可以在每次想要访问下一行时使用<strong class="kk iu"> next() </strong>函数。这个函数通过调用它的<strong class="kk iu"> __next__() </strong>方法从迭代器<strong class="kk iu">阅读器</strong>返回下一个元素。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="979a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">默认情况下，分隔符是逗号。然而，如果使用另一个分隔符，我们必须用<strong class="kk iu">分隔符</strong>参数指定它，如下所示。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/a4f98379f1884ae6f8d2811588d9cc4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:570/format:webp/1*NmXZ_wDGAk3g1O6Fa4xJOg.png"/></div></figure><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h2 id="a639" class="ms lw it bd lx mt mu dn mb mv mw dp mf kr mx my mh kv mz na mj kz nb nc ml nd bi translated">读取CSV文件— DictReader函数</h2><p id="b89b" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated"><strong class="kk iu"> csv。DictReader() </strong>函数将<strong class="kk iu"> CSV文件</strong>的行作为<strong class="kk iu">字典</strong>对象(具体地说是作为<strong class="kk iu">有序字典</strong>)而不是作为<strong class="kk iu">列表</strong>对象返回。<strong class="kk iu">字典</strong>的<strong class="kk iu">键</strong>在<strong class="kk iu">字段名</strong>参数中指定。如果省略fieldnames，则第一行中包含的值将用作键。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="0dc8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">有序字典</strong>由记住其内容添加顺序的字典组成。在Python 3.6+中，字典也是<strong class="kk iu">插入排序的，</strong>意味着它们记住了插入条目的顺序。</p><h2 id="ae30" class="ms lw it bd lx mt mu dn mb mv mw dp mf kr mx my mh kv mz na mj kz nb nc ml nd bi translated"><strong class="ak">编写一个csv文件—编写器功能</strong></h2><p id="2cb9" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">要将数据写入CSV文件，首先，我们使用内置函数<strong class="kk iu"> open </strong>在<strong class="kk iu">写入模式</strong>下打开CSV文件。然后，我们将由<strong class="kk iu">打开函数</strong>返回的<strong class="kk iu">打开文件对象</strong>作为输入提供给<strong class="kk iu"> csv.writer()函数，</strong>获得一个writer对象。</p><p id="9890" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">writer对象支持两种将数据写入CSV文件的方法。</p><ul class=""><li id="f45f" class="nv nw it kk b kl km ko kp kr nx kv ny kz nz ld oa ob oc od bi translated"><strong class="kk iu">CSV writer . writerow(row)→</strong>该方法将一行数据写入CSV文件。</li><li id="c2f6" class="nv nw it kk b kl oe ko of kr og kv oh kz oi ld oa ob oc od bi translated"><strong class="kk iu">CSV writer . writerows(rows)→</strong>该方法将所有给定的行(行对象的一个iterable)写入CSV文件。</li></ul><p id="b262" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们使用<strong class="kk iu"> writerows </strong>方法编写一个包含艺术作品信息的CSV文件。正如您所观察到的，这个方法接受一个嵌套列表作为输入。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="e058" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">运行上面的代码后，在当前工作目录下创建一个CSV文件(<strong class="kk iu"> works_of_art.csv </strong>)。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/6906df0e44d92abd0dcd272e27241a16.png" data-original-src="https://miro.medium.com/v2/resize:fit:546/format:webp/1*jU_VUIUHweQSnHj-BDLxMQ.png"/></div></figure><h2 id="7943" class="ms lw it bd lx mt mu dn mb mv mw dp mf kr mx my mh kv mz na mj kz nb nc ml nd bi translated">写一个csv文件— Dictwriter函数</h2><p id="e5c1" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated"><strong class="kk iu"> csv。DictWriter() </strong>函数返回一个支持上述方法(writerow和writerows)的对象，用于将数据写入CSV文件。该函数需要输入<strong class="kk iu">标题信息</strong>(参数<strong class="kk iu">字段名</strong>)以及打开的文件对象。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="6ebf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这种情况下，<strong class="kk iu"> writerows </strong>方法将字典列表而不是嵌套列表作为输入。</p><p id="c861" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">运行上面的代码后，在当前工作目录下创建一个CSV文件(<strong class="kk iu"> works_of_art_2.csv </strong>)。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/b05b8210876fc9054907884ddac34bd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:584/format:webp/1*md-_Ni-9ZKAwT8NZ_vsYMQ.png"/></div></figure></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="3475" class="lv lw it bd lx ly nn ma mb mc no me mf jz np ka mh kc nq kd mj kf nr kg ml mm bi translated">7.一团</h1><p id="15e2" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated"><strong class="kk iu"> glob </strong>模块允许您通过使用<strong class="kk iu">通配符</strong>符号来查找匹配给定模式的文件和路径列表。一个<strong class="kk iu">通配符</strong>是一个特殊字符，我们可以用它来选择多个相似的名字。</p><p id="4624" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下表显示了您可以在<strong class="kk iu"> glob </strong>中使用的最常见通配符。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/5e4b9f33652e00094d39a0f10a493a8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:912/format:webp/1*OObY2cX1FzhkuJkzTYY0mw.png"/></div></figure><p id="17de" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们使用这个符号和<strong class="kk iu"> glob.glob() </strong>函数从当前工作目录中获取匹配文件和路径的列表(如下所示)。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi om"><img src="../Images/eaf82b35863e594f9395c0249225e033.png" data-original-src="https://miro.medium.com/v2/resize:fit:494/format:webp/1*uxul_uFOxHTtI4KSXNg_MA.png"/></div></figure><ul class=""><li id="4492" class="nv nw it kk b kl km ko kp kr nx kv ny kz nz ld oa ob oc od bi translated">所有<strong class="kk iu"> CSV文件列表</strong>。</li></ul><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ne nf l"/></div></figure><ul class=""><li id="083e" class="nv nw it kk b kl km ko kp kr nx kv ny kz nz ld oa ob oc od bi translated">以单词<strong class="kk iu">学生</strong>开头的文件和目录。</li></ul><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ne nf l"/></div></figure><ul class=""><li id="ae03" class="nv nw it kk b kl km ko kp kr nx kv ny kz nz ld oa ob oc od bi translated">Txt文件:<strong class="kk iu"> file_2.txt </strong>，<strong class="kk iu"> file_3.txt </strong>，以及<strong class="kk iu"> file_4.txt </strong>。</li></ul><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="abe9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如您所观察到的，<strong class="kk iu"> glob </strong>函数比<strong class="kk iu"> listdir </strong>函数(在<strong class="kk iu"> os </strong>模块中定义)更灵活地列出目录中的文件。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="a568" class="lv lw it bd lx ly nn ma mb mc no me mf jz np ka mh kc nq kd mj kf nr kg ml mm bi translated">8.Difflib</h1><p id="2f2d" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated"><strong class="kk iu"> difflib </strong>模块包含各种用于比较序列的函数和类，对于计算文本和字符串之间的差异尤其有用。</p><p id="330c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">diff lib . get _ close _ matches(word，probabilities，n=3，cutoff=0.6) </strong>函数可以方便地检测拼写错误和打字错误，将一个<strong class="kk iu">单词</strong>与一组<strong class="kk iu">可能性</strong>进行匹配。该函数采用两个可选参数<strong class="kk iu"> n </strong>和<strong class="kk iu">截止值</strong>。<strong class="kk iu"> N </strong>是返回的匹配数，默认为3。<strong class="kk iu">截止值</strong>的范围从0到1，<strong class="kk iu">表示</strong>从<strong class="kk iu">可能性列表</strong>中返回一个<strong class="kk iu">元素</strong>的最小相似度，意味着<strong class="kk iu">元素</strong>与<strong class="kk iu">单词</strong>足够相似。</p><p id="8e31" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们使用这个函数获取用户介绍的一个国家的人口。首先，我们使用库<strong class="kk iu"> Request </strong>和<strong class="kk iu"> Pandas </strong>从下面的网页获取数据。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ne nf l"/></div></figure><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi on"><img src="../Images/ae2fd67c301f47c9567e0300476a0d17.png" data-original-src="https://miro.medium.com/v2/resize:fit:372/format:webp/1*g1ag-R-oo3rDFQzVGIEl0A.png"/></div></figure><p id="7aa2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们要求用户介绍一个国家，以访问其人口。如下图所示，如果你打错了，程序会建议一个相似的国家名称。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ne nf l"/></div></figure><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi oo"><img src="../Images/a337b2f0d770526fb3d80a05f2d8c4e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*77Kv4Y-Oq6-1q3zOfMNwKw.gif"/></div></div></figure><p id="6f5f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个模块提供了更多的功能来识别文本之间的异同。如前所述，请参考文档，了解如何使用该模块的更多详细信息！:)</p><h1 id="e9e8" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">有趣的网站</h1><p id="345a" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">除了官方的<strong class="kk iu"> Python </strong>文档，你还可以在多个网页上找到关于如何使用<strong class="kk iu"> Python标准库</strong>中可用模块的详细解释。</p><p id="5ddc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们解释了有限数量的模块，因为Python标准库包含超过200个模块！这意味着我们将在以后的文章中再次讨论Python标准库。💪</p><p id="9949" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">阿曼达💜</p></div></div>    
</body>
</html>