# 如何在 operator 中使用 SQL 获得更多洞察？

> 原文：<https://towardsdatascience.com/how-to-get-more-insights-using-sql-in-operator-9bbe73f9b4ba?source=collection_archive---------45----------------------->

## *使用 IN 运算符跨表合并数据*

![](img/dcce0236aeb9ccbc2b637e9e12e3b583.png)

[克里丝蒂娜·瓦格纳](https://unsplash.com/@a_wandering_yogi?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍照

我们都知道 SQL IN 是一个有用的操作符，它允许您在 WHERE 子句中选择多个条件。然而，IN 操作符甚至比您想象的更有用。在中，您可以跨表合并数据。

# 一个使用 Google BigQuery 公共数据集的例子

为了举例说明，我将快速浏览一遍教程。我使用 Google BigQuery 的公共数据集，名为 **austin_bikeshare** 。因此，你可以很容易地按照我的代码来练习。

这个数据集中有两个表。 **bikeshare_stations** 表格包含有关站点名称、状态和位置的信息。 **bikeshare_trips** 表包括关于行程的开始时间、结束时间、开始站、结束站、持续时间和订户类型的信息。

作为一名数据分析师，我可能想通过出行次数了解每个起点站的性能。然而，我只对仍然活跃的站感兴趣。因此，我可以把我的问题框定如下:

> 每个活动始发站进行了多少次旅行？

您可以从 **bikeshare_trips** 表中轻松找到始发站和相关的行程。但是，每个站点的状态位于 **bikeshare_stations** 表中。解决方案可能是使用 JOIN:

还有一个使用 IN 的解决方案，在这个方案中，您不必使用 JOIN。首先，通过从 **bikeshare_trips** 表中计算行程 id，选择所有起点站的名称和行程数。然后，在 WHERE 子句中，编写一个子查询，从 **bikeshare_stations** 表中选择所有活动的站点，并使用 in 运算符。结果，所选择的站被限制在活动站的子集内，而不是所有站。代码如下:

# 另一个 Leetcode 问题的例子

我用 607 号问题(销售人员)来进一步说明。问题是选择表**销售人员**中的所有姓名，他们没有销售给“RED”公司。

表:`salesperson`

```
+----------+------+--------+-----------------+-----------+
| sales_id | name | salary | commission_rate | hire_date |
+----------+------+--------+-----------------+-----------+
|   1      | John | 100000 |     6           | 4/1/2006  |
|   2      | Amy  | 120000 |     5           | 5/1/2010  |
|   3      | Mark | 65000  |     12          | 12/25/2008|
|   4      | Pam  | 25000  |     25          | 1/1/2005  |
|   5      | Alex | 50000  |     10          | 2/3/2007  |
+----------+------+--------+-----------------+-----------+
```

表:`company`

```
+---------+--------+------------+
| com_id  |  name  |    city    |
+---------+--------+------------+
|   1     |  RED   |   Boston   |
|   2     | ORANGE |   New York |
|   3     | YELLOW |   Boston   |
|   4     | GREEN  |   Austin   |
+---------+--------+------------+
```

表:`orders`

```
+----------+------------+---------+----------+--------+
| order_id | order_date | com_id  | sales_id | amount |
+----------+------------+---------+----------+--------+
| 1        |   1/1/2014 |    3    |    4     | 100000 |
| 2        |   2/1/2014 |    4    |    5     | 5000   |
| 3        |   3/1/2014 |    1    |    1     | 50000  |
| 4        |   4/1/2014 |    1    |    4     | 25000  |
+----------+----------+---------+----------+--------+
```

由于该问题仅询问销售人员的姓名，因此从**销售人员**表中选择**姓名**是有意义的。然而，那些没有销售给“红色”公司的呢？

在这个场景中，IN 操作符发挥了作用。我们不用 IN，而只用 NOT IN。首先，我们通过连接 **orders** 表和 **company** 表，选择销售 id，并使用公司名称为“RED”的条件，来选择与公司“RED”有销售关系的雇员子集。然后，我们只需选择不属于该子集的销售 id。以下是需要遵循的代码:

通过这两个例子，我希望您能更好地理解如何使用 IN 操作符在不使用 JOIN 的情况下跨表合并数据。