<html>
<head>
<title>How to properly ship and deploy your machine learning model</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何正确地发布和部署您的机器学习模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-properly-ship-and-deploy-your-machine-learning-model-8a8664b763c4?source=collection_archive---------4-----------------------#2020-01-29">https://towardsdatascience.com/how-to-properly-ship-and-deploy-your-machine-learning-model-8a8664b763c4?source=collection_archive---------4-----------------------#2020-01-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9145" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">FastAPI、Docker和GitHub操作实用指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/792a0dd18cf98e3180af6798c6c9970d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NyExPzjOGaVpRBEcBkpkjQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">汤姆·菲斯克在<a class="ae ky" href="https://www.pexels.com" rel="noopener ugc nofollow" target="_blank">像素</a>上拍摄的照片</p></figure><p id="97d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为一名数据科学家，训练你的机器学习模型只是为客户提供解决方案的一部分。除了生成和清理数据、选择和调整算法之外，您还需要交付和部署您的结果，以便它可以在生产中使用。这本身就是一个很大的领域，有着不断发展的工具和标准。在这篇文章中，我的目标是提供一个实用的指南，告诉你如何使用当前可用的最先进的工具和最佳实践来完成这项工作。我们将构建一个系统，它可以作为您部署任务的起点，而不考虑实际的机器学习问题本身！我的目标是介绍最佳实践和展示高级特性，而不是一个仅仅触及所用工具表面的最小化应用程序，这样你就不必学习艰难的方法。从你自己的错误中学习固然很好，但是提前思考并且不犯那些错误要好得多。</p><p id="7141" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了创建我们的部署就绪应用程序，我们将使用两个工具作为我们的主要构建块:<a class="ae ky" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker </a>和<a class="ae ky" href="https://fastapi.tiangolo.com/" rel="noopener ugc nofollow" target="_blank"> FastAPI </a>。Docker可能不需要介绍，它是一个容器化工具，允许您在任何环境中轻松打包和运行您的应用程序。它与FastAPI配合得特别好，FastAPI在过去的几个月里获得了令人难以置信的流行。它使得围绕您的模型构建web框架和根据您客户的需求进行定制变得容易。</p><div class="lv lw gp gr lx ly"><a rel="noopener follow" target="_blank" href="/you-should-start-using-fastapi-now-7efb280fec02"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">您应该现在就开始使用FastAPI</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">如果您还没有尝试过FastAPI，现在是时候了</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">towardsdatascience.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm ks ly"/></div></div></a></div><p id="175e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的玩具问题将是一个简单的回归，我们将根据犯罪率、财产税率等13个特征来预测房地产价格。为此，我们将使用<a class="ae ky" href="https://scikit-learn.org/stable/datasets/index.html#boston-dataset" rel="noopener ugc nofollow" target="_blank">波士顿房价数据集</a>作为我们的训练数据。关于模型选择，我们将使用来自牛逼的<a class="ae ky" href="https://scikit-learn.org/stable/index.html" rel="noopener ugc nofollow" target="_blank"> scikit-learn </a>包的<a class="ae ky" href="https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestRegressor.html" rel="noopener ugc nofollow" target="_blank">随机森林回归器</a>。当然，您并不局限于scikit-learn，您可以使用TensorFlow、PyTorch或任何您喜欢的工具。为了简单起见，我选择了这个，因为它几乎不需要额外的工作，比如大量的数据预处理，而且它的依赖性相对较轻，易于安装。</p><p id="68cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将展示如何</p><ul class=""><li id="db2d" class="mn mo it lb b lc ld lf lg li mp lm mq lq mr lu ms mt mu mv bi translated">打包您的模型并构建一个API来与之通信，</li><li id="69a6" class="mn mo it lb b lc mw lf mx li my lm mz lq na lu ms mt mu mv bi translated">设计一个方便简单的用户界面，</li><li id="73a8" class="mn mo it lb b lc mw lf mx li my lm mz lq na lu ms mt mu mv bi translated">用<code class="fe nb nc nd ne b">virtualenv</code>设置合适的开发环境，</li><li id="fb9d" class="mn mo it lb b lc mw lf mx li my lm mz lq na lu ms mt mu mv bi translated">使用FastAPI，</li><li id="a066" class="mn mo it lb b lc mw lf mx li my lm mz lq na lu ms mt mu mv bi translated">通过包装你的机器学习模型为将来的代码变化做准备，</li><li id="9ba7" class="mn mo it lb b lc mw lf mx li my lm mz lq na lu ms mt mu mv bi translated">使用依赖注入使测试更容易，</li><li id="39c1" class="mn mo it lb b lc mw lf mx li my lm mz lq na lu ms mt mu mv bi translated">验证用户输入，</li><li id="4153" class="mn mo it lb b lc mw lf mx li my lm mz lq na lu ms mt mu mv bi translated">用模拟测试API，</li><li id="f9a8" class="mn mo it lb b lc mw lf mx li my lm mz lq na lu ms mt mu mv bi translated">用Docker和Docker compose打包，</li><li id="e921" class="mn mo it lb b lc mw lf mx li my lm mz lq na lu ms mt mu mv bi translated">最后是如何使用GitHub动作来自动化测试。</li></ul><p id="470c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要遵循这个指南，你根本不需要有使用Docker或FastAPI的经验！熟悉scikit-learn和NumPy将是有益的，但我们不会非常集中地关注这些部分。我们将要构建的应用程序可以在<a class="ae ky" href="https://github.com/cosmic-cortex/fastAPI-ML-quickstart" rel="noopener ugc nofollow" target="_blank">https://github.com/cosmic-cortex/fastAPI-ML-quickstart</a>找到，随时可以使用。在我们直接进入开发之前，让我们评估需求并设计应用程序的架构！</p><h1 id="4889" class="nf ng it bd nh ni nj nk nl nm nn no np jz nq ka nr kc ns kd nt kf nu kg nv nw bi translated">如何设计一个小型的机器学习app</h1><p id="aaf1" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">部署期间的一个主要考虑因素是客户的需求。在我们的例子中，我们假设他们不需要理解算法是如何工作的，也不想重新训练算法。他们只想发送数据，然后马上得到答案。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/a950c7319562c7af7be7c41a578d04cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sutI0FqeIaoWuI_xdLTSJA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">与机器学习模型通信</p></figure><p id="a273" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用技术术语来说，我们将构建一个应用程序，它以HTTP请求的形式接收数据，并以HTTP响应的形式发回预测。除了接口简单之外，作为微服务很容易集成到更大的应用中，这是一个巨大的优势。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/89a07d4e4a3a8897bb834660d2d8cc80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IPci3RFJjf0nWPsTqxy_mQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自高层的应用程序</p></figure><p id="3143" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的应用程序将通过API进行通信，该API将被打包在Docker容器中。在这个简单的例子中，在应用程序本身中，我们需要做三件事:处理输入、进行预测、处理输出并将其返回给用户。使用FastAPI，输入将是一个JSON，如下所示:</p><pre class="kj kk kl km gt oe ne of og aw oh bi"><span id="d4da" class="oi ng it ne b gy oj ok l ol om">{<strong class="ne iu"><br/>  </strong>"data":[[0.00632,18,2.31,0,0.538,6.575,65.2,4.09,1,296,15.3,396.9,4.98]]<strong class="ne iu"><br/></strong>}</span></pre><p id="35c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将由FastAPI在内部转换成适当的Python对象。(稍后将详细介绍这一点，因为这是FastAPI中最简洁的特性之一。)我们需要为scikit-learn模型处理它，这意味着将它转换成一个NumPy数组。它可以用来计算我们的预测，我们将再次把它转换成FastAPI使用的格式。最后，用户将收到一个类似输入的JSON:</p><pre class="kj kk kl km gt oe ne of og aw oh bi"><span id="2151" class="oi ng it ne b gy oj ok l ol om">{<strong class="ne iu"><br/>  </strong>"data": [25.813999999999993]<strong class="ne iu"><br/></strong>}</span></pre><p id="7442" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">马上投入开发吧！我们的首要工作是建立适当的开发环境。</p><h1 id="daa9" class="nf ng it bd nh ni nj nk nl nm nn no np jz nq ka nr kc ns kd nt kf nu kg nv nw bi translated">设置开发环境</h1><p id="0cb3" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">如果您曾广泛使用Python，那么您可能使用过虚拟环境。如果没有，要点如下。Python虚拟环境是Python的独立安装，您可以在其中安装项目所需的特定包。当您有许多项目具有可能冲突的依赖关系时(比如一个项目要求NumPy ≥ 1.13，而另一个项目要求NumPy ≤ 1.10)，您最好使用虚拟环境来避免完全混乱。要创建虚拟环境，请使用</p><pre class="kj kk kl km gt oe ne of og aw oh bi"><span id="6cbc" class="oi ng it ne b gy oj ok l ol om">virtualenv /path/to/venv --python=/path/to/python3</span></pre><p id="c07a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里可以找到全局Python3解释器的路径</p><pre class="kj kk kl km gt oe ne of og aw oh bi"><span id="7511" class="oi ng it ne b gy oj ok l ol om">which python3</span></pre><p id="d143" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你在Linux下。(如果不显式提供解释器，就会回退到别名为<code class="fe nb nc nd ne b">python</code>的Python解释器，有些情况下可以是Python 2.7。不要使用Python 2.7:)虚拟环境可以用</p><pre class="kj kk kl km gt oe ne of og aw oh bi"><span id="b97d" class="oi ng it ne b gy oj ok l ol om">source /path/to/venv/bin/activate</span></pre><p id="553c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这之后，如果你用<em class="on"> pip </em>安装包，它将只在虚拟环境活动时可见。在您克隆了包含我们将要构建的应用程序的库之后，您可以使用</p><pre class="kj kk kl km gt oe ne of og aw oh bi"><span id="0021" class="oi ng it ne b gy oj ok l ol om">pip install -r requirements.txt</span></pre><p id="bc02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在根文件夹中时执行命令。尽管您不需要将您的依赖项收集到一个单独的需求文件中，但是强烈建议您这样做。这使得维护你的应用程序更加容易，而且当你把应用程序打包成Docker镜像时，你可以使用同一个文件。</p><h1 id="b546" class="nf ng it bd nh ni nj nk nl nm nn no np jz nq ka nr kc ns kd nt kf nu kg nv nw bi translated">构建应用程序的框架</h1><p id="13e8" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">粗略地说，每个FastAPI应用程序都由一个主文件组成，该主文件负责启动应用程序/定义端点和端点使用的附加模块。(可以在主文件之外的其他地方定义端点，但是在最简单的情况下，这种结构是更可取的。)</p><pre class="kj kk kl km gt oe ne of og aw oh bi"><span id="e67e" class="oi ng it ne b gy oj ok l ol om">.<br/>├── api<br/>│   ├── __init__.py<br/>│   ├── main.py<br/>│   └── ml<br/>│       ├── __init__.py<br/>│       ├── model.joblib<br/>│       └── model.py<br/>└── requirements.txt</span></pre><p id="1ecf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当FastAPI应用程序的结构清晰后，我们先构建<code class="fe nb nc nd ne b">main.py</code>的框架，然后实现<code class="fe nb nc nd ne b">ml</code>模块！</p><p id="2873" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们基本上需要导入两个类:为我们的API提供所有功能的<code class="fe nb nc nd ne b">FastAPI</code>类和来自awesome Pydantic库的<code class="fe nb nc nd ne b">BaseModel</code>,它充当HTTP请求和响应的模型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="e83d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在实例化一个<code class="fe nb nc nd ne b">FastAPI</code>对象后，我们可以通过使用它的适当方法来修饰描述端点逻辑的函数，从而向它注册端点。例如，这里我们有</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="dfc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着我们的应用程序期望一个对<code class="fe nb nc nd ne b">/predict</code>端点的<code class="fe nb nc nd ne b">POST</code>请求，该请求包含一个由<code class="fe nb nc nd ne b">PredictRequest</code>对象描述的JSON有效负载，并将返回一个由<code class="fe nb nc nd ne b">PredictResponse</code>描述的JSON有效负载的响应。这些都是由函数前的<code class="fe nb nc nd ne b">@app.post</code>装饰器指定的，它将这个函数注册到名为<code class="fe nb nc nd ne b">app</code>的<code class="fe nb nc nd ne b">FastAPI</code>实例，并将请求路由到这个函数的<code class="fe nb nc nd ne b">/predict</code> URL。<code class="fe nb nc nd ne b">predict</code>的<code class="fe nb nc nd ne b">input</code>参数的类型注释描述了请求数据的适当格式。</p><p id="6295" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，<code class="fe nb nc nd ne b">PredictRequest</code>对象有一个名为<code class="fe nb nc nd ne b">data</code>的属性，它必须是一个floats列表的列表。(由于数据通常是成批传递的，所以外部列表中的每个列表都是一个数据点。)Pydantic非常重视类型检查:如果类型不匹配，它会无情地抛出一个异常。这种用Pydantic进行的类型检查是FastAPI的一个极其强大的特性，使我们的生活变得更加容易。如果请求的格式不正确，您会立即收到一个422不可处理的实体状态代码作为响应。而你要为此做几乎为零的工作！如果您已经使用请求和响应模型指定了模式，FastAPI和Pydantic会为您执行验证。</p><p id="32eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以立即使用此应用程序</p><pre class="kj kk kl km gt oe ne of og aw oh bi"><span id="862a" class="oi ng it ne b gy oj ok l ol om">uvicorn api.main:app</span></pre><p id="cb7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并且通过检查由FastAPI生成的自动文档来试用端点，默认情况下可以在<a class="ae ky" href="http://localhost:8000/docs" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/docs</a>找到该文档。或者，您可以使用<code class="fe nb nc nd ne b">curl</code>来发布请求，例如</p><pre class="kj kk kl km gt oe ne of og aw oh bi"><span id="fff2" class="oi ng it ne b gy oj ok l ol om">curl -X POST “<a class="ae ky" href="http://localhost:8000/predict" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/predict</a>" -H “accept: application/json” -H “Content-Type: application/json” -d “{\”data\”:[[0]]}”</span></pre><p id="bfa0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">会管用的。目前，这个简单的框架将总是返回一个伪响应</p><pre class="kj kk kl km gt oe ne of og aw oh bi"><span id="4bb4" class="oi ng it ne b gy oj ok l ol om">{<strong class="ne iu"><br/>  </strong>"data":<strong class="ne iu"> </strong>[0]<strong class="ne iu"><br/></strong>}</span></pre><p id="0ab6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，一旦我们的模型到位，这种情况很快就会改变。既然框架已经建立并运行，我们就可以开始实现机器学习模型了！</p><h1 id="96a5" class="nf ng it bd nh ni nj nk nl nm nn no np jz nq ka nr kc ns kd nt kf nu kg nv nw bi translated">创建机器学习算法</h1><p id="522c" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">正如我提到的，我们将使用<a class="ae ky" href="https://scikit-learn.org/stable/datasets/index.html#boston-dataset" rel="noopener ugc nofollow" target="_blank"> Boston数据集</a>训练一个简单的<a class="ae ky" href="https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestRegressor.html" rel="noopener ugc nofollow" target="_blank">随机森林回归器</a>，两者都可以在scikit-learn中找到。尽管直接使用scikit-learn对象很有吸引力，但我更喜欢为我们的模型构建一个抽象接口，它将由API端点使用，而不是由scikit-learn对象本身使用。其背后的原因是该接口在整个代码库中是可重用的，如果您希望替换您的底层模型(比如使用PyTorch模型而不是scikit-learn的随机森林回归器)，您只需要更改该类的实现，而不是更改实际使用该模型的所有函数和端点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="c991" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要四个基本方法:一个用于训练模型，一个用于计算预测，两个用于保存和加载模型。当界面清晰时，我们就可以开始具体的实现了，这非常简单。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="82e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了模型接口本身，我们还将在<code class="fe nb nc nd ne b">api.ml.model</code>模块中定义模型对象。这个特定的实例将在整个应用程序中使用。这被称为单例，是最重要的OOP模式之一。虽然在这里使用是安全的，但是在大型应用程序中必须小心使用单例变量，因为它们基本上是全局变量。通过调用<code class="fe nb nc nd ne b">get_model()</code>函数，可以在应用程序的其余部分访问这个模型对象。这有两个原因。首先，这个函数在代码中到处都是可重用的，因此如果以后我们决定添加额外的逻辑来获取模型(如检查等)，在一个地方修改代码就足够了。第二，稍后将会解释，如果我们在端点中使用<a class="ae ky" href="https://fastapi.tiangolo.com/tutorial/dependencies/" rel="noopener ugc nofollow" target="_blank">依赖注入</a>，那么为应用程序编写单元测试会更好。(如果你现在不明白这一点也不要担心，后面会解释的。)</p><p id="3692" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了准备我们的应用程序，在执行这个脚本时，一个模型被训练并保存到磁盘上。这将在以后用于预测。</p><h1 id="78bf" class="nf ng it bd nh ni nj nk nl nm nn no np jz nq ka nr kc ns kd nt kf nu kg nv nw bi translated">构建API端点I:处理JSON输入</h1><p id="c2cd" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">在应用程序框架和机器学习算法到位后，我们就可以实施端点背后的逻辑了。让我们切换回<code class="fe nb nc nd ne b">main.py</code>模块！预测是一个相对简单的过程，只需要几行代码就可以实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="818c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在函数体中，有三件事情正在进行:</p><ol class=""><li id="ab77" class="mn mo it lb b lc ld lf lg li mp lm mq lq mr lu oq mt mu mv bi translated">输入(是<code class="fe nb nc nd ne b">PredictRequest</code>的一个实例)被转换成一个NumPy数组。</li><li id="b94d" class="mn mo it lb b lc mw lf mx li my lm mz lq na lu oq mt mu mv bi translated">计算预测，产生一个NumPy数组。</li><li id="2055" class="mn mo it lb b lc mw lf mx li my lm mz lq na lu oq mt mu mv bi translated">结果被转换成一个<code class="fe nb nc nd ne b">PredictResponse</code>对象并返回。</li></ol><p id="6fb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">FastAPI将返回值转换为正确的响应。有一个重要的变化可能已经引起了您的注意:我们向我们的<code class="fe nb nc nd ne b">predict</code>函数传递了一个额外的参数:</p><pre class="kj kk kl km gt oe ne of og aw oh bi"><span id="b923" class="oi ng it ne b gy oj ok l ol om">model: Model = Depends(get_model)</span></pre><p id="7689" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中<code class="fe nb nc nd ne b">get_model</code>函数是返回模型的函数，在<code class="fe nb nc nd ne b">api.ml.model</code>模块中定义。这种技术被称为依赖注入。虽然<code class="fe nb nc nd ne b">model</code>是函数的一个参数，但是每次调用<code class="fe nb nc nd ne b">predict</code>函数，都会执行<code class="fe nb nc nd ne b">get_model</code>并传递返回值。为什么这很有用，这一点可能并不明显，但是这对于编写正确的单元测试非常重要。想想看:我们的端点依赖于一个scikit-learn对象，它背后有数千行代码。例如，它可以在软件包的新版本中进行磨合。(就像最近发生在pip上的一样:<a class="ae ky" href="https://github.com/pypa/pip/issues/7217" rel="noopener ugc nofollow" target="_blank">https://github.com/pypa/pip/issues/7217</a>，影响了相当一部分用户。)一般来说，不管它们有多重要，外部依赖都会带来潜在的错误。当我们想要对我们的应用程序进行单元测试时，我们不希望结果依赖于一些可能超出我们控制的对象的正确性。因此，这些通常在单元测试中被嘲笑。mock是一个伪对象，实现了与原始对象相同的接口，具有100%可预测的行为。有了依赖注入，通过覆盖依赖，这些模拟可以很容易地注入到代码中。如果您没有马上明白这一点，请不要担心，在测试部分会有更详细的解释。</p><h1 id="3ce3" class="nf ng it bd nh ni nj nk nl nm nn no np jz nq ka nr kc ns kd nt kf nu kg nv nw bi translated">永远不要相信用户的输入</h1><p id="628d" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">既然端点本身已经实现，让我们考虑一些可能的用例。如果你尝试</p><pre class="kj kk kl km gt oe ne of og aw oh bi"><span id="8017" class="oi ng it ne b gy oj ok l ol om">curl -X POST “<a class="ae ky" href="http://localhost:8000/predict" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/predict</a>" -H “accept: application/json” -H “Content-Type: application/json” -d “{\”data\”:[[0]]}”</span></pre><p id="3280" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用当前的实现，您将得到一个内部服务器错误，应用程序将崩溃。这是因为由于模型是使用13个特征训练的，所以它需要13个特征来进行预测。虽然uvicorn很聪明，会在这种情况下重启你的应用程序，但是内部服务器错误听起来很糟糕，你肯定不想在生产中遇到这种情况。为了解决这个问题，我们将在Pydantic请求模型中添加额外的验证。默认情况下，它们只检查JSON有效负载是否有一个“data”键，其值是一个floats列表的列表。在我们的<a class="ae ky" href="https://pydantic-docs.helpmanual.io/usage/validators/" rel="noopener ugc nofollow" target="_blank">定制验证器</a>(除了默认验证之外还运行)中，我们检查数据的维度是否正确，也就是说，每个子列表都准确地包含了<code class="fe nb nc nd ne b">n_features</code>元素。(也就是13。)</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="84c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当传递了错误的数据并且验证失败时，应用程序不会崩溃，而是返回422不可处理的实体错误代码。虽然这对最终用户来说不一定是更好的结果，但对你和你的devops团队来说肯定是更愉快的。一般来说，当您构建处理数据的应用程序时，您不应该相信用户输入。事情可能会意外出错，也可能会受到恶意攻击，比如SQL注入，这是黑客工具包中一个流行而危险的工具。</p><p id="22e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最终的模块会是这样的:<a class="ae ky" href="https://github.com/cosmic-cortex/fastAPI-ML-quickstart/blob/master/api/main.py" rel="noopener ugc nofollow" target="_blank">https://github . com/cosmic-cortex/fastAPI-ML-quick start/blob/master/API/main . py</a></p><p id="af56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一节将添加<code class="fe nb nc nd ne b">predict_csv</code>端点。</p><h1 id="efff" class="nf ng it bd nh ni nj nk nl nm nn no np jz nq ka nr kc ns kd nt kf nu kg nv nw bi translated">构建API端点II:处理。csv文件</h1><p id="4a3f" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">如果您想接收另一种格式的数据，如csv文件，您可以这样做。你应该使用<code class="fe nb nc nd ne b"><a class="ae ky" href="https://fastapi.tiangolo.com/tutorial/request-files/" rel="noopener ugc nofollow" target="_blank">File</a></code> <a class="ae ky" href="https://fastapi.tiangolo.com/tutorial/request-files/" rel="noopener ugc nofollow" target="_blank">和</a> <code class="fe nb nc nd ne b"><a class="ae ky" href="https://fastapi.tiangolo.com/tutorial/request-files/" rel="noopener ugc nofollow" target="_blank">UploadFile</a></code>来代替使用Pydantic模型作为输入。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="8abe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，这一次，Pydantic没有为我们执行验证，因此我们必须手动执行。有两件事需要验证。</p><ol class=""><li id="27ea" class="mn mo it lb b lc ld lf lg li mp lm mq lq mr lu oq mt mu mv bi translated">该文件包含表格形式的数据。</li><li id="8ebc" class="mn mo it lb b lc mw lf mx li my lm mz lq na lu oq mt mu mv bi translated">该数据正好包含13个特征。</li></ol><p id="8ffa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在函数体内手动完成这两项工作。当出现问题时，我们会抛出一个异常，由FastAPI在一个适当的HTTP响应中返回。</p><h1 id="533f" class="nf ng it bd nh ni nj nk nl nm nn no np jz nq ka nr kc ns kd nt kf nu kg nv nw bi translated">测试API</h1><p id="6193" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">现在我们已经准备好了一切，是时候测试我们的应用程序了！使用未经测试的代码就像打地鼠游戏:你修复了一个bug，另一个bug马上就会出现。就个人而言，我是测试的大力支持者，我认为你也应该是一个。尽管测试需要最初的时间投入，但它将在开发的后期得到指数回报。</p><p id="897f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了测试API，我们将使用<code class="fe nb nc nd ne b">pytest</code>，这是Python中单元测试的标准工具。我们将把测试模块放在<code class="fe nb nc nd ne b">api</code>旁边，因此文件结构将如下所示:</p><pre class="kj kk kl km gt oe ne of og aw oh bi"><span id="ebe4" class="oi ng it ne b gy oj ok l ol om">.<br/>├── api<br/>│   ├── __init__.py<br/>│   ├── main.py<br/>│   ├── ml<br/>│   │   ├── __init__.py<br/>│   │   ├── model.joblib<br/>│   │   └── model.py<br/>│   └── tests<br/>│       ├── api<br/>│       │   ├── __init__.py<br/>│       │   └── test_api.py<br/>│       ├── conftest.py<br/>│       ├── __init__.py<br/>│       └── mocks.py<br/>└── requirements.txt</span></pre><p id="af46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们要构建的第一件事是一个模拟的<code class="fe nb nc nd ne b">Model</code>对象，这样我们的端点测试就不依赖于scikit-learn。正如我所提到的，这是不可取的，因为我们希望将代码中的错误和外部代码中的错误分离开来。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="ee6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个类相对简单，完全模仿我们的<code class="fe nb nc nd ne b">api.ml.model.Model</code>类的接口，但是基本上它不执行任何有意义的计算，并且返回随机数据。(尽管随机数据将在形状上匹配预期的输出。)</p><p id="ab62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将根据<code class="fe nb nc nd ne b">pytest</code>需求添加位于<code class="fe nb nc nd ne b">conftest.py</code>模块中的测试配置。在我们的情况下，我们应该做两件事。</p><ol class=""><li id="d4d5" class="mn mo it lb b lc ld lf lg li mp lm mq lq mr lu oq mt mu mv bi translated">覆盖端点中使用的依赖注入，以使用一个<code class="fe nb nc nd ne b">MockModel</code>对象来代替真实模型。</li><li id="1200" class="mn mo it lb b lc mw lf mx li my lm mz lq na lu oq mt mu mv bi translated">定义测试中使用的fixtures，它们本身就是依赖注入。(我们很快会看到一个例子。)</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="a32c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们从我们的<code class="fe nb nc nd ne b">main</code>模块导入实际的<code class="fe nb nc nd ne b">app</code>对象。要覆盖对<code class="fe nb nc nd ne b">get_model()</code>的依赖，我们只需提供一个新函数，并用新函数在<code class="fe nb nc nd ne b">app.dependency_overrides</code>字典中设置适当的键。这段代码不会在部署期间执行，因此我们的依赖关系不会被意外覆盖，它是特定于测试的。接下来，我们准备一个Starlette <code class="fe nb nc nd ne b">TestClient</code>，它<a class="ae ky" href="https://www.starlette.io/testclient/" rel="noopener ugc nofollow" target="_blank">“允许你对你的ASGI应用程序做出请求”</a>，一个非常方便的测试工具。这个定义意味着使用<code class="fe nb nc nd ne b">TestClient</code>实例，我们可以向端点发送请求并接收响应，这正是我们想要测试的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="bedd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们用有效数据测试用户输入。为了看到它在多批量(从1到9)下工作良好，我们添加了数据点的数量作为<code class="fe nb nc nd ne b">n_instances</code>参数。在测试函数中遍历所有可能的大小被认为是不好的做法，因为如果它对某个特定的大小失败了，您会想知道它失败的确切位置。因此，我们可以使用<code class="fe nb nc nd ne b">@pytest.mark.parametrize</code>装饰器，它为参数的每个值自动生成一个新的测试函数。在测试函数中，我们简单地生成一些假数据，并使用<code class="fe nb nc nd ne b">TestClient</code>将其发送到应用程序。我们要检查两件事:1)响应代码是200，这是HTTP-okay的说法2)响应包含的预测与输入数据集的大小一样多。</p><p id="ab48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，测试端点的正确输入数据是不够的。如果是这样，更重要的是确保我们的应用程序在出现不正确的数据时表现正常。这在下面介绍。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="7b5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了完整起见，我已经为<code class="fe nb nc nd ne b">predict_csv</code>端点添加了测试，这些测试与之前的测试相似，所以我不再详述。</p><p id="acf0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦测试准备好了，您就可以通过在bash中从项目的根目录执行<code class="fe nb nc nd ne b">pytest</code>来运行它们。输出将如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/020978b5d614974b2651bd71722902d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8eSgQlFPaSeowrOQkNPzHQ.png"/></div></div></figure><p id="f59b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">毕竟测试模块应该是这样的:<a class="ae ky" href="https://github.com/cosmic-cortex/fastAPI-ML-quickstart/tree/master/api/tests" rel="noopener ugc nofollow" target="_blank">https://github . com/cosmic-cortex/fastAPI-ML-quick start/tree/master/API/tests</a>。</p><h1 id="7ad6" class="nf ng it bd nh ni nj nk nl nm nn no np jz nq ka nr kc ns kd nt kf nu kg nv nw bi translated">打包您的应用程序</h1><p id="1f79" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">当应用程序经过适当的测试并在您的本地机器上正确运行时，就该将它打包成可移植的格式了。如果没有这一点，在另一台机器上设置它将是一个缓慢而痛苦的过程。为此，我们将使用Docker。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/3ef2af6ff85dd4cd19a5c142af73eb1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yfe1eQBGZC6nOi-_fbn0xA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Docker架构。来源:<a class="ae ky" href="https://docs.docker.com/engine/docker-overview/" rel="noopener ugc nofollow" target="_blank">https://docs.docker.com/engine/docker-overview/</a></p></figure><p id="41da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Docker将应用打包成<em class="on">镜像</em>，镜像是自包含的应用，甚至是操作系统。它们由Docker容器运行，Docker容器是隔离的执行环境。它们在原理上非常类似于虚拟机。尽管它们不像虚拟机那样提供严格的隔离，但当您第一次使用Docker时，这是一个很好的模型。</p><p id="930b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Docker映像由<code class="fe nb nc nd ne b">Dockerfile</code>定义，它基本上是Docker如何构建映像的一组指令。映像通常不是独立的，它们是从其他基础映像构建的。这些图像在https://hub.docker.com有它们自己的存储库，你可以在那里推送你的图像和拉取其他图像。打个比方，这些图像就像git存储库。使用基本映像就像分叉一个存储库，并将一些提交推到您自己的分叉上。</p><p id="240b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用包含19.10版本Ubuntu的<code class="fe nb nc nd ne b">ubuntu:19.10</code>映像来打包我们的应用程序。(这是Ubuntu docker官方图片。)选择基础映像会显著影响后面的大部分工作流程。对于Python应用程序，基于Alpine Linux的映像也是一个很好的选择，Python甚至有一些基于Alpine的官方映像。然而，将NumPy和某些机器学习库安装到基于Alpine的映像可能会很困难，所以我们将坚持使用Ubuntu。</p><p id="cf1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们的Dockerfile，包含在项目的根文件夹中。我们将一行一行地走一遍。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="20e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一行描述了基本图像，如前所述是<code class="fe nb nc nd ne b">ubuntu:19.10</code>。在构建时，这个映像从中央存储库中取出。完成后，Docker将把<code class="fe nb nc nd ne b">./api</code>文件夹复制到图像中。(每个映像都有自己的文件系统。)然后我们准备安装Python3以及FastAPI等所需的包。在图像内执行<code class="fe nb nc nd ne b">RUN</code>后的命令。在这之后，我们正确地设置<code class="fe nb nc nd ne b">PYTHONPATH</code>变量和工作目录。</p><p id="c680" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了服务于我们的应用程序，我们将向主机映像公开容器的端口8000。出于安全原因，默认情况下不会这样做，您必须手动这样做。最后，我们告诉Docker在容器运行时要做什么:我们要启动<code class="fe nb nc nd ne b">uvicorn</code>并为应用程序提供服务。<code class="fe nb nc nd ne b">ENTRYPOINT</code>指定每次执行容器时将运行的命令，而<code class="fe nb nc nd ne b">CMD</code>指定其参数。</p><p id="dbb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">图像本身可以用</p><pre class="kj kk kl km gt oe ne of og aw oh bi"><span id="2047" class="oi ng it ne b gy oj ok l ol om">docker build --file Dockerfile --tag fastapi-ml-quickstart .</span></pre><p id="038d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">命令。构建可能需要一段时间，但完成后，您可以使用</p><pre class="kj kk kl km gt oe ne of og aw oh bi"><span id="f199" class="oi ng it ne b gy oj ok l ol om">docker run -p 8000:8000 fastapi-ml-quickstart</span></pre><p id="37c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在run命令中，您需要指定Docker将容器的TCP端口8000映射到主机中的同一个端口。如果您在浏览器中打开<a class="ae ky" href="http://localhost:8000" rel="noopener ugc nofollow" target="_blank"> http://localhost:8000 </a>，您可以看到应用程序正在运行，并且您可以正确地连接到它。</p><h2 id="7166" class="oi ng it bd nh ot ou dn nl ov ow dp np li ox oy nr lm oz pa nt lq pb pc nv pd bi translated">组合容器</h2><p id="eaa3" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">在这个简单的例子中，我们的应用程序不依赖于其他服务，比如Redis或PostgreSQL。在这种情况下，<code class="fe nb nc nd ne b">docker-compose</code>可以用来组合容器。与<code class="fe nb nc nd ne b">Dockerfile</code>类似，docker-compose需要一个名为<code class="fe nb nc nd ne b">docker-compose.yaml</code>的YAML配置文件来描述要启动哪些服务。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="87fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这之后，只需执行</p><pre class="kj kk kl km gt oe ne of og aw oh bi"><span id="9986" class="oi ng it ne b gy oj ok l ol om">docker-compose up</span></pre><p id="b6b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从项目根目录。Docker compose将在图像不可用时自动构建图像。我发现即使你只有一个容器，每次用这个手动调用<code class="fe nb nc nd ne b">docker build</code>和<code class="fe nb nc nd ne b">docker run</code>也要简单得多。</p><h1 id="e996" class="nf ng it bd nh ni nj nk nl nm nn no np jz nq ka nr kc ns kd nt kf nu kg nv nw bi translated">与GitHub动作的持续集成</h1><p id="c38c" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">维护良好的代码的支柱之一是持续集成。即使我们有测试，实际上也没有强迫程序员在提交变更之前使用它们。我们可以通过在某些触发条件下自动执行测试来解决这个问题，比如对特定分支的push和pull请求。这样，向共享代码库的主线推送更改可以比通常更快地完成。与旧的学校开发工作流程相比，当合并每周进行一次，并需要团队的大部分人员来监督时，通过适当的持续集成设置，代码交付可以由一个人完成，甚至每天几次。</p><p id="6a4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个项目中，我们将使用GitHub Actions，它允许您根据预定义的触发器自动执行操作。它要求您在GitHub托管的存储库的<code class="fe nb nc nd ne b">.github/workflows</code>子目录中定义您的动作脚本。以下是该项目的<a class="ae ky" href="https://github.com/cosmic-cortex/fastAPI-ML-quickstart/blob/master/.github/workflows/ci.yaml" rel="noopener ugc nofollow" target="_blank"> YAML配置文件</a>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="fdca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，配置文件有两个主要部分:第二部分定义将要发生什么，第一部分定义何时发生。在这个例子中，我们希望脚本在对<code class="fe nb nc nd ne b">master</code>分支的每个push和pull请求上执行。</p><p id="72b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">动作本身是根据<em class="on">工作</em>定义的，并给出了每个步骤。这个名为<code class="fe nb nc nd ne b">build</code>的特定作业在Ubuntu实例中运行，如<code class="fe nb nc nd ne b">runs-on</code>参数所示。首先它<a class="ae ky" href="https://github.com/actions/checkout" rel="noopener ugc nofollow" target="_blank">检查存储库</a>，然后它使用<code class="fe nb nc nd ne b">docker-compose.test.yaml</code>文件启动Docker compose，这是专门为测试目的而制作的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="3789" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与我们之前使用的相比，这个Docker compose只有一行不同:它覆盖了<code class="fe nb nc nd ne b">fastapi-ml-quickstart</code>容器的入口点，启动了<code class="fe nb nc nd ne b">pytest</code>而不是<code class="fe nb nc nd ne b">uvicorn</code>。完成后，容器退出，Docker编写被中止，从<code class="fe nb nc nd ne b">fastapi-ml-quickstart</code>容器返回退出代码。这些事情都不是<code class="fe nb nc nd ne b">docker-compose</code>的默认行为，所以你要特别指示它这么做:</p><pre class="kj kk kl km gt oe ne of og aw oh bi"><span id="3c1b" class="oi ng it ne b gy oj ok l ol om">docker-compose -f docker-compose.test.yaml up --abort-on-container-exit --exit-code-from fastapi-ml-quickstart</span></pre><p id="9ef4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就个人而言，我是GitHub Actions的忠实粉丝。它是非常通用的，你甚至可以用它将更新推送到产品中，在PyPI中发布，以及许多其他任务。它明显的缺点是只对GitHub用户开放。然而，也有替代者，例如Jenkins、CircleCI、Travis CI、GitLab CI等等。</p><h1 id="ca78" class="nf ng it bd nh ni nj nk nl nm nn no np jz nq ka nr kc ns kd nt kf nu kg nv nw bi translated">包扎</h1><p id="ff2e" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li nz lk ll lm oa lo lp lq ob ls lt lu im bi translated">在本指南中，我的目标是为机器学习应用程序构建一个小应用程序，并遵循最佳实践和使用现代工具对其进行适当的打包。但是，总有进步的空间！如果你有任何想法，欢迎在<a class="ae ky" href="https://github.com/cosmic-cortex/fastAPI-ML-quickstart" rel="noopener ugc nofollow" target="_blank">https://github.com/cosmic-cortex/fastAPI-ML-quickstart</a>提出来！我希望你觉得这个指南有用。现在去开始构建令人敬畏的人工智能应用程序:)</p></div><div class="ab cl pe pf hx pg" role="separator"><span class="ph bw bk pi pj pk"/><span class="ph bw bk pi pj pk"/><span class="ph bw bk pi pj"/></div><div class="im in io ip iq"><p id="bf01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://www.tivadardanka.com/blog" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> <em class="on">如果你喜欢把机器学习概念拆开，理解是什么让它们运转，我们有很多共同点。看看我的博客，我经常在那里发表这样的技术文章！</em> </strong> </a></p></div></div>    
</body>
</html>