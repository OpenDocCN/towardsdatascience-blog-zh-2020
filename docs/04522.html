<html>
<head>
<title>Python Generators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 生成器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-generators-393455aa48a3?source=collection_archive---------27-----------------------#2020-04-22">https://towardsdatascience.com/python-generators-393455aa48a3?source=collection_archive---------27-----------------------#2020-04-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="bdf3" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用 yield 关键字开发 python 生成器函数的教程</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/bd23c2a4cd8a9991be0fe158d0617a1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KbVmRHw8hsdgqs6VvXLwaQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来自<a class="ae kv" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4550711" rel="noopener ugc nofollow" target="_blank">皮克斯拜</a></p></figure><p id="d64e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简单地说，Python 生成器促进了维护持久状态的功能。这使得增量计算和迭代成为可能。此外，生成器可以用来代替数组以节省内存。这是因为生成器不存储值，而是存储带有函数状态的计算逻辑，类似于一个准备启动的未赋值函数实例。</p><h1 id="3dd3" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">生成器表达式</h1><p id="bf8d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">生成器表达式可以用来代替数组创建操作。与数组不同，生成器将在运行时生成数字。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="169c" class="mu lt iq mq b gy mv mw l mx my">&gt;&gt;&gt; import sys<br/>&gt;&gt;&gt; a = [x for x in range(1000000)]<br/>&gt;&gt;&gt; b = (x for x in range(1000000))<br/>&gt;&gt;&gt; sys.getsizeof(a)<br/>8697472<br/>&gt;&gt;&gt; sys.getsizeof(b)<br/>128<br/>&gt;&gt;&gt; a<br/>[0, 1, ... 999999]<br/>&gt;&gt;&gt; b<br/>&lt;generator object &lt;genexpr&gt; at 0x1020de6d0&gt;</span></pre><p id="87c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以看到，在上面的场景中，通过用生成器代替数组，我们节省了大量内存。</p><h1 id="9125" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">用收益代替回报的函数</h1><p id="635a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">让我们考虑一个简单的例子，你想产生任意数量的素数。下面是检查一个数是否是质数的函数，以及将产生无穷多个质数的生成器。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="c6a1" class="mu lt iq mq b gy mv mw l mx my">def isPrime(n):<br/>    if n &lt; 2 or n % 1 &gt; 0:<br/>        return False<br/>    elif n == 2 or n == 3:<br/>        return True<br/>    for x in range(2, int(n**0.5) + 1):<br/>        if n % x == 0:<br/>            return False<br/>    return True</span><span id="ac02" class="mu lt iq mq b gy mz mw l mx my">def getPrimes():<br/>    value = 0<br/>    while True:<br/>        if isPrime(value):<br/>            yield value<br/>        value += 1</span></pre><p id="94d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如你在第二个函数中看到的，我们在一个 while 循环中迭代并产生质数。让我们看看如何使用上面的生成器。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="b44e" class="mu lt iq mq b gy mv mw l mx my">primes = getPrimes()</span><span id="df89" class="mu lt iq mq b gy mz mw l mx my">&gt;&gt;&gt; next(primes)<br/>2<br/>&gt;&gt;&gt; next(primes)<br/>3<br/>&gt;&gt;&gt; next(primes)<br/>5</span></pre><p id="5f7d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们调用函数并获取生成器实例。虽然这可以模拟一个无限数组，但是还没有找到任何元素。如果你调用<code class="fe na nb nc mq b">list(primes)</code>，你的程序可能会因为内存错误而崩溃。然而，对于质数，它不会到达那里，因为质数空间对于在有限时间内达到内存限制的计算是稀疏的。但是，对于发电机，你不会事先知道长度。如果您调用<code class="fe na nb nc mq b">len(primes)</code>,您将得到下面的错误，原因与数字只在运行时生成的原因完全相同。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="7dcb" class="mu lt iq mq b gy mv mw l mx my">----------------------------------------------------------------<br/>TypeError                      Traceback (most recent call last)<br/>&lt;ipython-input-33-a6773446b45c&gt; in &lt;module&gt;<br/>----&gt; 1 len(primes)<br/><br/>TypeError: object of type 'generator' has no len()</span></pre><h1 id="faeb" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">迭代次数有限的生成器</h1><p id="0fc7" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">虽然我们的质数例子有一个无限的迭代空间，但在大多数日常场景中，我们面对的是有限的计算。因此，让我们来看一个例子，我们可以用它来读取一个包含文本数据和下一行句子的语义分数的文件。</p><h2 id="8831" class="mu lt iq bd lu nd ne dn ly nf ng dp mc lf nh ni me lj nj nk mg ln nl nm mi nn bi translated">为什么我们需要使用收益率？</h2><p id="1452" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">假设文件是 1TB，词的语料库是 500000。它不适合存储。一个简单的解决方案是一次读取两行，计算每行的单词字典，并在下一行返回语义得分。该文件如下所示。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="be7c" class="mu lt iq mq b gy mv mw l mx my">The product is well packed<br/>5<br/>Edges of the packaging was damaged and print was faded.<br/>3<br/>Avoid this product. Never going to buy anything from ShopX.<br/>1<br/>Shipping took a very long time<br/>2</span></pre><p id="ab13" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">很明显，我们不需要马上打开文件。此外，这些线条必须矢量化，并可能保存到另一个可以直接解析的文件中，以训练机器学习模型。因此，给我们一个干净代码的选项是使用一个生成器，它可以一次读取两行，并以元组的形式给我们数据和语义得分。</p><h2 id="8810" class="mu lt iq bd lu nd ne dn ly nf ng dp mc lf nh ni me lj nj nk mg ln nl nm mi nn bi translated">实现文件解析生成器</h2><p id="5a51" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">假设我们在一个名为<code class="fe na nb nc mq b">test.txt</code>的文件中有上述文本文档。我们将使用下面的生成器函数来读取文件。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="3ec2" class="mu lt iq mq b gy mv mw l mx my">def readData(path):<br/>    with open(path) as f:<br/>        sentiment = ""<br/>        line = ""<br/>        for n, d in enumerate(f):<br/>            if n % 2 == 0:<br/>                line = d.strip()<br/>            else:<br/>                sentiment = int(d.strip())<br/>                yield line, sentiment</span></pre><p id="a5fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以在一个<code class="fe na nb nc mq b">for</code>循环中使用上述函数，如下所示。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="66aa" class="mu lt iq mq b gy mv mw l mx my">&gt;&gt;&gt; data = readData("test.txt")<br/>&gt;&gt;&gt; for l, s in data: print(l, s)<br/>The product is well packed 5<br/>Edges of the packaging was damaged and print was faded. 3<br/>Avoid this product. Never going to buy anything from ShopX. 1<br/>Shipping took a very long time 2</span></pre><h2 id="6704" class="mu lt iq bd lu nd ne dn ly nf ng dp mc lf nh ni me lj nj nk mg ln nl nm mi nn bi translated">发电机如何退出？</h2><p id="48e0" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在一个普通的 for 循环中，当生成器不再生成时，迭代停止。然而，这可以通过我们在生成器实例上手动调用<code class="fe na nb nc mq b">next()</code>来观察到。超出迭代限制调用<code class="fe na nb nc mq b">next()</code>将引发以下异常。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="366e" class="mu lt iq mq b gy mv mw l mx my">----------------------------------------------------------------<br/>StopIteration                  Traceback (most recent call last)<br/>&lt;ipython-input-41-cddec6aa1599&gt; in &lt;module&gt;<br/>---&gt; 28 print(next(data))</span><span id="afc6" class="mu lt iq mq b gy mz mw l mx my">StopIteration:</span></pre><h1 id="9bef" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">使用发送、抛出和关闭</h1><h2 id="2ed6" class="mu lt iq bd lu nd ne dn ly nf ng dp mc lf nh ni me lj nj nk mg ln nl nm mi nn bi translated">发送功能</h2><p id="7bec" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">让我们回忆一下质数的例子。假设我们想将我们的生成函数的值重置为 100，如果它们是质数，就开始产生大于 100 的值。我们可以在生成器实例上使用<code class="fe na nb nc mq b">send()</code>方法将一个值推入生成器，如下所示。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="7b3d" class="mu lt iq mq b gy mv mw l mx my">&gt;&gt;&gt; primes = getPrimes()<br/>&gt;&gt;&gt; next(primes)<br/>2<br/>&gt;&gt;&gt; primes.send(10)<br/>11<br/>&gt;&gt;&gt; primes.send(100)<br/>101</span></pre><p id="34f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，在调用<code class="fe na nb nc mq b">send()</code>之前，我们必须至少调用<code class="fe na nb nc mq b">next()</code>一次。让我们看看我们必须如何修改我们的函数来适应这个目的。因为该函数应该知道如何分配接收到的值。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="e487" class="mu lt iq mq b gy mv mw l mx my">def getPrimes():<br/>    value = 0<br/>    while True:<br/>        if isPrime(value):<br/>            i = yield value<br/>            if i is not None:<br/>                value = i<br/>        value += 1</span></pre><p id="2d36" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将产生的值存储在变量<code class="fe na nb nc mq b">i</code>中。如果那不是<code class="fe na nb nc mq b">None</code>类型，我们把它赋给<code class="fe na nb nc mq b">value</code>变量。<code class="fe na nb nc mq b">None</code>检查至关重要，因为第一个<code class="fe na nb nc mq b">next()</code>在<code class="fe na nb nc mq b">value</code>变量中没有要产出的值。</p><h2 id="3760" class="mu lt iq bd lu nd ne dn ly nf ng dp mc lf nh ni me lj nj nk mg ln nl nm mi nn bi translated">投掷功能</h2><p id="1262" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">假设您想要在大于 10 的值处结束迭代，以避免溢出或超时(假设)。<code class="fe na nb nc mq b">throw()</code>功能可用于提示发电机暂停引发异常。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="74a5" class="mu lt iq mq b gy mv mw l mx my">primes = getPrimes()</span><span id="9aa9" class="mu lt iq mq b gy mz mw l mx my">for x in primes:<br/>    if x &gt; 10:<br/>        primes.throw(ValueError, "Too large")<br/>    print(x)</span></pre><p id="6cac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种技术对于验证输入很有用。逻辑取决于发生器的用户。这将产生以下输出。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="eb1f" class="mu lt iq mq b gy mv mw l mx my">2<br/>3<br/>5<br/>7</span><span id="27ef" class="mu lt iq mq b gy mz mw l mx my">----------------------------------------------------------------<br/>ValueError                     Traceback (most recent call last)<br/>&lt;ipython-input-113-37adca265503&gt; in &lt;module&gt;<br/><strong class="mq ir">     12</strong> for x in primes:<br/><strong class="mq ir">     13</strong>     if x &gt; 10:<br/>---&gt; 14         primes.throw(ValueError, "Too large")<br/><strong class="mq ir">     15</strong>     print(x)<br/><br/>&lt;ipython-input-113-37adca265503&gt; in getPrimes()<br/><strong class="mq ir">      3</strong>     while True:<br/><strong class="mq ir">      4</strong>         if isPrime(value):<br/>----&gt; 5             i = yield value<br/><strong class="mq ir">      6</strong>             if i is not None:<br/><strong class="mq ir">      7</strong>                 value = i<br/><br/>ValueError: Too large</span></pre><h2 id="3151" class="mu lt iq bd lu nd ne dn ly nf ng dp mc lf nh ni me lj nj nk mg ln nl nm mi nn bi translated">关闭功能</h2><p id="5759" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">处理闭包时没有异常通常是优雅的。在这种情况下，<code class="fe na nb nc mq b">close()</code>函数可以用来有效地关闭迭代器。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="cf7f" class="mu lt iq mq b gy mv mw l mx my">primes = getPrimes()</span><span id="0beb" class="mu lt iq mq b gy mz mw l mx my">for x in primes:<br/>    if x &gt; 10:<br/>        primes.close()<br/>    print(x)</span></pre><p id="7b6f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将为我们提供以下输出。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="d9c1" class="mu lt iq mq b gy mv mw l mx my">2<br/>3<br/>5<br/>7<br/>11</span></pre><p id="2e1f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，我们的值是 11，这是最后一个大于 11 的计算值。这模拟了 C/C++中<strong class="ky ir"> do while </strong>循环的行为。</p><p id="77e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我相信这篇文章将有助于你将来开发更好的软件和研究程序。感谢阅读。</p><p id="7444" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">干杯😃</p></div></div>    
</body>
</html>