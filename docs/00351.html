<html>
<head>
<title>How to Create Your First Machine Learning Model</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何创建你的第一个机器学习模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-create-your-first-machine-learning-model-4c8f745e4b8c?source=collection_archive---------4-----------------------#2020-01-11">https://towardsdatascience.com/how-to-create-your-first-machine-learning-model-4c8f745e4b8c?source=collection_archive---------4-----------------------#2020-01-11</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><figure class="it iu gq gs iv iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj is"><img src="../Images/4a91085cec2fd8b8b0ce8c65d7ca74a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PMAXfe5teqtbHyURgpGo5Q.jpeg"/></div></div><p class="jd je gk gi gj jf jg bd b be z dk translated">凯尔西·奈特在<a class="ae jh" href="https://unsplash.com/s/photos/wine?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><div class=""/><div class=""><h2 id="9f67" class="pw-subtitle-paragraph kh jj jk bd b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dk translated">用Python创建简单机器学习模型的指南</h2></div><p id="f834" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">许多机器学习教程专注于机器学习工作流的特定元素，如数据清理、模型训练或算法优化。然而，如果你是机器学习的新手，没有完整简单的解释或演练，很难完全掌握基本的端到端工作流。</p><p id="5dbb" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在下面的帖子中，我将提供一个非常简单的教程，用python开发一个有监督的机器学习模型。在这篇文章中，我将假设你只有非常基本的python编程知识，并且已经安装了一些常用的数据科学库。如果你首先需要一个关于数据科学的python介绍，<a class="ae jh" href="https://www.codecademy.com/learn/learn-python" rel="noopener ugc nofollow" target="_blank"> Codeacademy </a>是一个不错的起点。我还将提供教程中包含的所有库的文档链接。</p></div><div class="ab cl lv lw hy lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="in io ip iq ir"><h2 id="3cbe" class="mc md jk bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">什么是机器学习？</h2><p id="0cd7" class="pw-post-body-paragraph kz la jk lb b lc mv kl le lf mw ko lh li mx lk ll lm my lo lp lq mz ls lt lu in bi translated">机器学习是计算机能够学习一些输入(数据特征)和一些已知输出(数据标签)之间的映射而无需显式编程的能力。目标是，给定未知输出的新输入，机器可以正确预测标签。</p><blockquote class="na"><p id="2345" class="nb nc jk bd nd ne nf ng nh ni nj lu dk translated">"机器学习本质上是一种事物标签."，<a class="ae jh" href="https://hackernoon.com/@kozyrkov" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">卡西科兹尔科夫</strong> </a></p></blockquote><p id="6441" class="pw-post-body-paragraph kz la jk lb b lc nk kl le lf nl ko lh li nm lk ll lm nn lo lp lq no ls lt lu in bi translated">这种输入到输出的映射由数学函数执行，主要来自线性代数和微积分领域，其执行速度和规模在没有大量计算能力的情况下是无法实现的。有许多不同的算法可以完成这项任务，从简单的基于回归的方法到更复杂的深度学习技术。</p><p id="2672" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">幸运的是，python编程语言有一个非常活跃的开源开发者社区，他们构建了许多库，这些库抽象出了直接编写这些算法的需求。其中一个核心的机器学习库是<a class="ae jh" href="https://scikit-learn.org/stable/index.html" rel="noopener ugc nofollow" target="_blank"> scikit-learn </a>，对于初学者来说非常容易访问。在本教程中，我将关注这个库。</p><h2 id="1d70" class="mc md jk bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">数据</h2><p id="9194" class="pw-post-body-paragraph kz la jk lb b lc mv kl le lf mw ko lh li mx lk ll lm my lo lp lq mz ls lt lu in bi translated">为了简单起见，我将使用机器学习来解决一个分类问题。我将使用scikit-learn API中的一个玩具数据集，该数据集包含三种类型的葡萄酒(标签或目标)的许多葡萄酒属性(特征)，如酒精度和颜色。</p><p id="b3c2" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">要加载数据并将其转换为<a class="ae jh" href="https://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank"> pandas </a>数据框，请使用如下所示的代码。</p><pre class="np nq nr ns gu nt nu nv nw aw nx bi"><span id="1d62" class="mc md jk nu b gz ny nz l oa ob">from sklearn.datasets import load_wine<br/>import pandas as pd</span><span id="8ac8" class="mc md jk nu b gz oc nz l oa ob">wine = load_wine()<br/>data = pd.DataFrame(data=wine['data'], columns = wine['feature_names'])<br/>data['target'] = wine['target']<br/>data.head()</span></pre><figure class="np nq nr ns gu iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj od"><img src="../Images/d8cb8414913b7404334c968569f2e57e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YM0rfAIOGORpx8QMq76S5w.png"/></div></div></figure><p id="def0" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">因为机器学习算法是基于数学的，所以用于机器学习的数据本质上必须是数字。这个数据集完全是数字的，但是，如果我们有分类特征，我们将需要执行一些预处理来首先将它们转换成数字。我选择了这个数据集，这样我就可以展示开发模型的最简单的工作流，而不用引入更多关于数据预处理的高级概念。</p><h2 id="327c" class="mc md jk bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">测试列车分离</h2><p id="ea43" class="pw-post-body-paragraph kz la jk lb b lc mv kl le lf mw ko lh li mx lk ll lm my lo lp lq mz ls lt lu in bi translated">在开发机器学习模型时，重要的是能够评估它能够将输入映射到输出并做出准确预测的能力。但是，如果您使用模型已经看到的数据(例如，在训练期间)来评估性能，那么您将无法检测诸如过度拟合之类的问题。</p><p id="9306" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">过度拟合是指模型在训练数据中学习了过多的细节或噪音，而这些不一定存在于看不见的数据中。在这种情况下，模型在训练数据上表现良好，但在看不见的数据上表现不佳。这通常被称为模型不能很好地概括。</p><p id="b7ff" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">机器学习中的一个标准是，首先把你的训练数据分成一组用于训练，一组用于测试。对于要进行的精确大小划分没有规则，但是为训练保留更大的样本是明智的——典型的划分是80%训练数据和20%测试数据。</p><p id="72f3" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">重要的是，数据也是随机分割的，这样您就可以很好地表示两组数据中存在的模式。Scikit-learn有一个工具可以在一行代码中完成这个过程，这个工具叫做<a class="ae jh" href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.train_test_split.html" rel="noopener ugc nofollow" target="_blank"> test_train_split </a>。下面的代码将特性和目标数据传递给函数，并指定20%的测试大小。</p><pre class="np nq nr ns gu nt nu nv nw aw nx bi"><span id="a121" class="mc md jk nu b gz ny nz l oa ob">from sklearn.model_selection import train_test_split</span><span id="756f" class="mc md jk nu b gz oc nz l oa ob">X_train, X_test, y_train, y_test = train_test_split(data.drop('target', axis=1), data['target'], test_size=0.20, random_state=0)</span></pre><h2 id="be64" class="mc md jk bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">基线模型</h2><p id="6d7c" class="pw-post-body-paragraph kz la jk lb b lc mv kl le lf mw ko lh li mx lk ll lm my lo lp lq mz ls lt lu in bi translated">接下来训练一个虚拟分类器以获得基线分数来为模型开发的进一步迭代设定基准是一个好主意。Scikit-learn有一个<a class="ae jh" href="https://scikit-learn.org/stable/modules/generated/sklearn.dummy.DummyClassifier.html" rel="noopener ugc nofollow" target="_blank">功能</a>，允许你训练一个模型，并根据简单的规则进行预测，比如随机预测。这有助于评估您的模型开发在您迭代后续步骤时是否有所改进。</p><p id="7cd4" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在下面的代码中，我训练了一个虚拟分类器，它总是预测最频繁出现的类。然而，虚拟分类器对此有许多不同的方法。准确度分数是0.44。完美的准确度分数应该是1.0。现在进入下一阶段，我们将知道我们是否在这个基线上有所改进。</p><pre class="np nq nr ns gu nt nu nv nw aw nx bi"><span id="349d" class="mc md jk nu b gz ny nz l oa ob">from sklearn.dummy import DummyClassifier<br/>from sklearn.metrics import accuracy_score</span><span id="0006" class="mc md jk nu b gz oc nz l oa ob">baseline = DummyClassifier(strategy='most_frequent', random_state=0).fit(X_train, y_train)<br/>y_pred = baseline.predict(X_test)<br/>print(round(accuracy_score(y_test, y_pred),4))</span></pre><h2 id="7716" class="mc md jk bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">型号选择</h2><p id="6354" class="pw-post-body-paragraph kz la jk lb b lc mv kl le lf mw ko lh li mx lk ll lm my lo lp lq mz ls lt lu in bi translated">现在我们有了一个训练好的基线模型，我们需要评估是否有另一种算法可以更好地处理我们的数据。Scikit-learn有这个有用的<a class="ae jh" href="https://scikit-learn.org/stable/tutorial/machine_learning_map/index.html" rel="noopener ugc nofollow" target="_blank">备忘单</a>，它将让你了解解决分类问题的不同算法。</p><p id="a7c9" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">下面的代码循环遍历一系列分类算法，并打印出结果分数。输出显示在代码下方。</p><pre class="np nq nr ns gu nt nu nv nw aw nx bi"><span id="c01f" class="mc md jk nu b gz ny nz l oa ob">from sklearn.metrics import accuracy_score, log_loss<br/>from sklearn.neighbors import KNeighborsClassifier<br/>from sklearn.svm import SVC, LinearSVC, NuSVC<br/>from sklearn.tree import DecisionTreeClassifier<br/>from sklearn.ensemble import RandomForestClassifier, AdaBoostClassifier, GradientBoostingClassifier<br/>from sklearn.discriminant_analysis import LinearDiscriminantAnalysis<br/>from sklearn.discriminant_analysis import QuadraticDiscriminantAnalysis</span><span id="3b96" class="mc md jk nu b gz oc nz l oa ob">classifiers = [<br/>    KNeighborsClassifier(3),<br/>    SVC(kernel="rbf", C=0.025, probability=True),<br/>    NuSVC(probability=True),<br/>    DecisionTreeClassifier(),<br/>    RandomForestClassifier(),<br/>    AdaBoostClassifier(),<br/>    GradientBoostingClassifier()<br/>    ]</span><span id="7279" class="mc md jk nu b gz oc nz l oa ob">for classifier in classifiers:<br/>    model = classifier.fit(X_train, y_train)<br/>    print(classifier)<br/>    print("model score: %.3f" % model.score(X_test, y_test))</span></pre><figure class="np nq nr ns gu iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj oe"><img src="../Images/d029bed86c8120e97fd5b58d855d53aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pujGm-IZfEL3Ma86HWRClw.png"/></div></div></figure><p id="9a7a" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我们可以看到，RandomForestClassifier对于该模型表现最佳，因此我们将选择该算法来训练我们的最终模型。</p><h2 id="0ebe" class="mc md jk bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">超参数优化</h2><p id="2b63" class="pw-post-body-paragraph kz la jk lb b lc mv kl le lf mw ko lh li mx lk ll lm my lo lp lq mz ls lt lu in bi translated">每个机器学习算法都有大量的参数用于控制学习过程。这些参数可以更改，并且根据数据集可以提高模型的性能。为算法和数据集寻找最佳参数集的过程被称为<a class="ae jh" href="https://en.wikipedia.org/wiki/Hyperparameter_optimization" rel="noopener ugc nofollow" target="_blank">超参数优化</a>。</p><p id="514f" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">从上一节运行的代码中我们知道，随机森林分类器在我们使用的数据集上表现最好。如果你看一下这个模型的<a class="ae jh" href="https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestClassifier.html" rel="noopener ugc nofollow" target="_blank">文档</a>，你会发现这个算法有很多参数可以调整。</p><p id="2ebd" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">超参数优化的一种常用方法是网格搜索。Scikit-learn提供了一个名为<a class="ae jh" href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.GridSearchCV.html" rel="noopener ugc nofollow" target="_blank"> GridSearchCV </a>的函数来执行这个任务。我们需要向这个函数传递一个python字典形式的网格，其中包含参数名和相应的参数列表。这就变成了函数将要搜索的参数空间。</p><p id="9136" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">然后，该函数将为给定分类器的每个参数组合建立一个模型。一旦完成，您将能够以最佳模型和最佳参数组合的形式获得结果。</p><p id="6632" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">为了简单起见，在下面的例子中，我选择只调整四个参数。它们如下:</p><p id="093b" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb jl"> n_estimators: </strong>模型中树的数量。</p><p id="3108" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb jl"> max_depth: </strong>树的最大深度。</p><p id="8b5e" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb jl"> min_samples_split: </strong>节点被拆分前，节点中数据点的最小个数。</p><p id="f633" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb jl"> min_samples_leaf: </strong>每片叶子中数据点的最小数量。</p><p id="5a66" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">下面的代码执行超参数调整，并打印最佳模型得分和参数组合。</p><pre class="np nq nr ns gu nt nu nv nw aw nx bi"><span id="4402" class="mc md jk nu b gz ny nz l oa ob">from sklearn.model_selection import GridSearchCV</span><span id="52ea" class="mc md jk nu b gz oc nz l oa ob">n_estimators = [100, 300, 500, 800, 1200]<br/>max_depth = [5, 8, 15, 25, 30]<br/>min_samples_split = [2, 5, 10, 15, 100]<br/>min_samples_leaf = [1, 2, 5, 10]</span><span id="ec33" class="mc md jk nu b gz oc nz l oa ob">param_grid = dict(n_estimators = n_estimators, max_depth = max_depth,  <br/>              min_samples_split = min_samples_split, <br/>             min_samples_leaf = min_samples_leaf)</span><span id="ebcf" class="mc md jk nu b gz oc nz l oa ob">rf = RandomForestClassifier()</span><span id="17e1" class="mc md jk nu b gz oc nz l oa ob">grid_search = GridSearchCV(estimator=rf, param_grid=param_grid)<br/>best_model = grid_search.fit(X_train, y_train)</span><span id="a1b4" class="mc md jk nu b gz oc nz l oa ob">print(round(best_model.score(X_test, y_test),2))<br/>print(best_model.best_params_)</span></pre><figure class="np nq nr ns gu iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj of"><img src="../Images/4e4431c810a29adde8897215fb3c08e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FmE2cm6zFd3j3xioK222eg.png"/></div></div></figure><h2 id="8825" class="mc md jk bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">最终评估</h2><p id="5cf2" class="pw-post-body-paragraph kz la jk lb b lc mv kl le lf mw ko lh li mx lk ll lm my lo lp lq mz ls lt lu in bi translated">最后，我们使用最佳模型来预测测试集上的标签，并打印分类报告来详细评估其性能。我们可以看到，与基线模型相比，整体性能有了很大的提高。</p><pre class="np nq nr ns gu nt nu nv nw aw nx bi"><span id="d1eb" class="mc md jk nu b gz ny nz l oa ob">from sklearn.metrics import classification_report</span><span id="747a" class="mc md jk nu b gz oc nz l oa ob">y_pred_best = best_model.predict(X_test)<br/>print(classification_report(y_test, y_pred_best))</span></pre><figure class="np nq nr ns gu iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj og"><img src="../Images/45873073b377239640cdcdfb9870b339.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GM_tTSXkw77BAuXCdZzEFg.png"/></div></div></figure></div><div class="ab cl lv lw hy lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="in io ip iq ir"><p id="f9ba" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在本文中，我展示了开发机器学习模型所需的最简单的工作流程。开发一个模型通常需要更多的步骤，尤其是当您使用真实世界的数据集时。其中包括数据清理、特征工程和交叉验证等许多可能的步骤。一旦你掌握了这篇文章中的基本步骤，你就可以继续学习机器学习中涉及的其他元素。</p><p id="e2a9" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><em class="oh">在本文中，我只讨论了分类，但对于其他类型的机器学习的简要概述，请参见— </em> <a class="ae jh" rel="noopener" target="_blank" href="/beginners-guide-to-the-three-types-of-machine-learning-3141730ef45d"> <em class="oh">三种机器学习类型的初学者指南</em> </a> <em class="oh">。</em></p><p id="dbea" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><em class="oh">如果你对学习数据科学感兴趣，可以在这里看到我的学习数据科学的完全免费资源列表— </em> <a class="ae jh" rel="noopener" target="_blank" href="/how-to-learn-data-science-for-free-eda10f04d083"> <em class="oh">如何免费学习数据科学</em> </a> <em class="oh">。</em></p><p id="b777" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">感谢阅读！</p></div></div>    
</body>
</html>