<html>
<head>
<title>Creating And Fitting A Regression Model In Julia</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 Julia 中创建和拟合回归模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/creating-and-fitting-a-regression-model-in-julia-4b5c947eabdc?source=collection_archive---------29-----------------------#2020-02-06">https://towardsdatascience.com/creating-and-fitting-a-regression-model-in-julia-4b5c947eabdc?source=collection_archive---------29-----------------------#2020-02-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b7d3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在 Julia 中根据风速和湿度创建和拟合车床模型。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/dfa21f65184a76cf76e011ccb4a3e93a.png" data-original-src="https://miro.medium.com/v2/resize:fit:450/format:webp/1*_disWwdKNS0K4O9bR3NfbA.png"/></div></figure><p id="dea9" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi lm translated">0.0.9 刚刚被合并到主分支中，随之而来的是一系列令人兴奋的新特性。Julia 的机器学习现在比以往任何时候都容易。Julia 中的机器学习目前面临的唯一问题是缺乏 Python 大小的生态系统，以及缺乏文档。幸运的是，对于车床用户来说，有许多功能和工具可供我们使用，甚至更好:</p><blockquote class="lv"><p id="e327" class="lw lx it bd ly lz ma mb mc md me ll dk translated">车床有很好的文档！</p></blockquote><p id="4c7b" class="pw-post-body-paragraph kq kr it ks b kt mf ju kv kw mg jx ky kz mh lb lc ld mi lf lg lh mj lj lk ll im bi translated">我在网上找到了另一个 CSV 数据集。要将这个 CSV 加载到 Julia 中，我们将需要三个依赖项中的第一个，CSV.jl。所以记住这一点，第一步是跳转到 Pkg REPL，首先输入朱莉娅 step，然后按]。从这个 REPL 中，我们可以添加三个依赖项:</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="a54f" class="mp mq it ml b gy mr ms l mt mu">julia&gt; ]<br/>pkg&gt; add "Lathe"#Unstable<br/>pkg&gt; add "DataFrames"<br/>pkg&gt; add "CSV"</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/b134c107bfa9abcd43dfc086b26638b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/1*VgAEFK7zh29pfkcBDVpCaA.png"/></div></figure><p id="95c1" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">现在我们的系统上已经有了 CSV.jl，我们可以使用将它引入到 Julia 中，并使用 CSV.read()方法读入我们的数据:</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="3e48" class="mp mq it ml b gy mr ms l mt mu">using CSV<br/>df = CSV.read("weatherHistory.csv")</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/9fc2dac4daa258fcf2d16f4c2618f94c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*I6oEgj_X8OmOoNnChiiSfw.png"/></div></figure><p id="704b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">对于连续和分类特征，这个数据集有许多选项，这将首先允许我展示车床预处理的最新方法，</p><blockquote class="lv"><p id="4a5e" class="lw lx it bd ly lz ma mb mc md me ll dk translated">一个热编码</p></blockquote><p id="4aa0" class="pw-post-body-paragraph kq kr it ks b kt mf ju kv kw mg jx ky kz mh lb lc ld mi lf lg lh mj lj lk ll im bi translated">我决定做的第一件事是将数据分成两个数据帧，一个将用于我们的模型，另一个将用于展示一个热编码器。我这样做是通过首先做</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="2bde" class="mp mq it ml b gy mr ms l mt mu">show(df, allcols = true)</span></pre><p id="dc58" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">其次，我构建了两个具有相应特性的新数据帧类型:</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="7343" class="mp mq it ml b gy mr ms l mt mu">using DataFrames<br/>hotdf = DataFrame(:Humidity =&gt; df[:Humidity], :Type =&gt; df[Symbol("Precip Type")])<br/>df = DataFrame(:Humidity =&gt; df[:Humidity],:WindSpeed =&gt; df[Symbol("Wind Speed (km/h)")])</span></pre><p id="d76f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">仅仅为了这个例子，我将假装我不知道如何使用车床，以便炫耀车床中的代码内文档。首先，我们当然需要使用以下命令加载车床:</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="db73" class="mp mq it ml b gy mr ms l mt mu">using Lathe</span></pre><p id="fbdd" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">然后我们可以用茱莉亚的？()包本身的方法:</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="5cdc" class="mp mq it ml b gy mr ms l mt mu">?(Lathe)<br/>|====== Lathe - Easily ML =====</span><span id="bb53" class="mp mq it ml b gy mx ms l mt mu">|= = = = = v. 0.0.9 = = = = = |</span><span id="b556" class="mp mq it ml b gy mx ms l mt mu">|==============================</span><span id="0397" class="mp mq it ml b gy mx ms l mt mu">|<strong class="ml iu">__</strong>Lathe.stats</span><span id="fa5c" class="mp mq it ml b gy mx ms l mt mu">|<strong class="ml iu">__</strong>Lathe.validate</span><span id="e3c4" class="mp mq it ml b gy mx ms l mt mu">|<strong class="ml iu">__</strong>Lathe.preprocess</span><span id="f151" class="mp mq it ml b gy mx ms l mt mu">|<strong class="ml iu">__</strong>Lathe.models</span><span id="1c51" class="mp mq it ml b gy mx ms l mt mu">|<strong class="ml iu">__</strong></span><span id="a679" class="mp mq it ml b gy mx ms l mt mu">Use ?(Lathe.package) for information!</span><span id="8747" class="mp mq it ml b gy mx ms l mt mu">[uuid]</span><span id="bad4" class="mp mq it ml b gy mx ms l mt mu">38d8eb38-e7b1-11e9-0012-376b6c802672</span><span id="83e1" class="mp mq it ml b gy mx ms l mt mu">[deps]</span><span id="4ce7" class="mp mq it ml b gy mx ms l mt mu">DataFrames.jl</span><span id="827f" class="mp mq it ml b gy mx ms l mt mu">Random.jl</span></pre><p id="0bbe" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">由此，我们看到了一个模块树，其中显示了三个模块:</p><ul class=""><li id="b418" class="my mz it ks b kt ku kw kx kz na ld nb lh nc ll nd ne nf ng bi translated">车床.统计</li><li id="fe6a" class="my mz it ks b kt nh kw ni kz nj ld nk lh nl ll nd ne nf ng bi translated">车床.验证</li><li id="62cf" class="my mz it ks b kt nh kw ni kz nj ld nk lh nl ll nd ne nf ng bi translated">车床.预处理</li><li id="d4dc" class="my mz it ks b kt nh kw ni kz nj ld nk lh nl ll nd ne nf ng bi translated">车床.型号</li></ul><p id="9c12" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">对于 one hot encoder，我们当然要研究 Lathe.preprocess。(Lathe.package)了解更多信息，所以让我们试试吧！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/a77942266cb31405d1acc2fc65b5881d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1078/format:webp/1*LGkyZcVLa9Cq1vSEu7magw.png"/></div></figure><p id="d07c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">现在我们可以在模块树中看到 OneHotEncode()函数，让我们对它做同样的操作:</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="ec32" class="mp mq it ml b gy mr ms l mt mu">?(Lathe.preprocess.OneHotEncode)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="no np di nq bf nr"><div class="gh gi nn"><img src="../Images/2680b79cddf838046bfd3da78913f5c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xjSJXXGnOr2fYmQw-RHGJA.png"/></div></div></figure><p id="2a60" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">由此我们得到一个简短的描述，参数，甚至用法。看起来这个函数需要一个数据帧，以及一个表示我们想要编码的列的符号。这当然与你的预期有关:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/ba2dd0ef38854e745eb89368e10f2a3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/1*igabL-Ygsuh5lwTIVHt9zA.png"/></div></figure><p id="08a1" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">抛开手边的方法，让我们回到我们的原始数据框架，用我们的两个特征，湿度和风速。因为数据集在这个特定的列上没有缺失值，并且我不打算缩放任何特性，所以我决定要做的第一件事是继续并训练 TestSplit:</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="d3db" class="mp mq it ml b gy mr ms l mt mu">using Lathe.preprocess: TrainTestSplit<br/>train, test = TrainTestSplit(df)</span></pre><p id="ce61" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这将返回两个新的数据帧，train 将占数据的 75%，而 test 将占剩余的 25%。我们可以通过在 df 后面添加一个浮动百分比来对此进行调整:</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="6429" class="mp mq it ml b gy mr ms l mt mu">train, test = TrainTestSplit(df, .5)</span></pre><blockquote class="lv"><p id="c1db" class="lw lx it bd ly lz nt nu nv nw nx ll dk translated">这将平均分割数据。</p></blockquote><p id="45a6" class="pw-post-body-paragraph kq kr it ks b kt mf ju kv kw mg jx ky kz mh lb lc ld mi lf lg lh mj lj lk ll im bi translated">就我个人而言，我喜欢将我所有的数据分配给变量，这些变量在考虑做模型之前就可以很容易地改变。在 Julia 中，你可以这样做:</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="e02d" class="mp mq it ml b gy mr ms l mt mu">x = :Humidity<br/>y = :WindSpeed<br/>trainX = train[x]<br/>trainy = train[y]<br/>testX = test[x]<br/>testy = test[y]</span></pre><p id="af7a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">接下来，我们只需要导入我们的模型，我们的预测函数，然后我们就可以构建和拟合了！</p><pre class="kj kk kl km gt mk ml mm mn aw mo bi"><span id="5fef" class="mp mq it ml b gy mr ms l mt mu">using Lathe.models: predict, LinearRegression<br/>model = LinearRegression(trainX, trainy)<br/>yhat = predict(model, testX)</span></pre><blockquote class="lv"><p id="087c" class="lw lx it bd ly lz nt nu nv nw nx ll dk translated">这是结果:</p></blockquote><figure class="nz oa ob oc od kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/512903b19c7ff2815719c57855928ae5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/format:webp/1*KmrWg20JW_ekhaNsVCu24w.png"/></div></figure><p id="124b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">真的是太简单了！你怎么会对此感到不安呢？我很期待车床在未来的发展方向，以及这个模块会对 Julia 产生怎样的影响。到目前为止，Lathe 可能是您可以使用的最简单的 ML 包，我认为大部分学习曲线源于使用 DataFrames.jl，而不是 Lathe。总的来说，我对车床的下一个版本，0.1.0 以及更高版本感到非常兴奋！</p></div></div>    
</body>
</html>