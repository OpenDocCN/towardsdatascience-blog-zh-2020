<html>
<head>
<title>Handy TensorFlow.js API for Client-Side ML Development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于客户端ML开发的便捷TensorFlow.js API</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/handy-tensorflow-js-api-for-client-side-ml-development-5256ed88e6f1?source=collection_archive---------24-----------------------#2020-02-19">https://towardsdatascience.com/handy-tensorflow-js-api-for-client-side-ml-development-5256ed88e6f1?source=collection_archive---------24-----------------------#2020-02-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c29d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">TensorFlow.js提供了一组丰富的API方法来处理训练数据，在客户端执行训练和推理。这篇文章通过一个简单实用的例子解释了如何使用这个API。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/918368dc289a36fd25699ba4be969e53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Un4K-ZGBuG8NkPXMPupUnA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:Pixabay</p></figure><p id="439f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们研究一下TensorFlow.js API，用于训练数据处理、训练执行和推理。TensorFlow.js非常棒，因为它将机器学习带到了Web开发人员的手中，这提供了互利。机器学习领域得到了更多的开发者和支持者，而Web开发在机器学习的支持下变得更加强大。</p><p id="1277" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我过去有一个关于TensorFlow.js的帖子— <a class="ae lu" rel="noopener" target="_blank" href="/comprehensive-tensorflow-js-example-96367625fab7">综合TensorFlow.js举例</a>。本文旨在展示如何使用TensorFlow.js构建实际用例。今天，我将重点介绍TensorFlow.js API，并展示如何使用开箱即用的API获取数据、训练模型和运行预测。</p><p id="5b32" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我想让示例应用程序尽可能简单，不使用任何特定的JavaScript框架/工具包。这将允许您下载示例代码并快速运行它。示例应用程序(<a class="ae lu" href="https://github.com/abaranovskis-redsamurai/automation-repo/tree/master/tfjs-simple" rel="noopener ugc nofollow" target="_blank"> GitHub </a> repo)作为HTML页面运行，要在本地测试它，您需要使用HTTP服务器。我会推荐使用NPM的<a class="ae lu" href="https://www.npmjs.com/package/http-server" rel="noopener ugc nofollow" target="_blank"> HTTP-Server </a>。转到包含HTML文件的文件夹，运行<em class="lv"> http-server </em>命令。在浏览器中导航到端口8080并单击HTML文件，这将加载示例应用程序。</p><p id="668d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">示例应用程序基于<a class="ae lu" href="https://www.kaggle.com/uciml/pima-indians-diabetes-database" rel="noopener ugc nofollow" target="_blank">皮马印第安人糖尿病</a>数据集(可在Kaggle上获得)。数据被分成训练集和测试集。</p><p id="8879" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第一步是加载数据。通常，数据来自CSV，有一个帮助器TensorFlow.js函数从CSV文件中读取数据— <a class="ae lu" href="https://js.tensorflow.org/api/latest/#data.csv" rel="noopener ugc nofollow" target="_blank"> tf.data.csv </a>:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="ae93" class="mb mc it lx b gy md me l mf mg">const trainingUrl = 'diabetes-train.csv';<br/>const trainingData = tf.data.csv(trainingUrl, {<br/>      columnConfigs: {<br/>          Outcome: {<br/>              isLabel: true<br/>          }<br/>      }<br/>});</span></pre><p id="143c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以指定属性名，哪个将被用作训练目标。</p><p id="ef5c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，我们转换数据集，为训练做好准备(这里我们可以对分类数据进行一次性编码)。将数据转换为数组形式:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="efb0" class="mb mc it lx b gy md me l mf mg">const convertedTrainingData =<br/>   trainingData.map(({ xs, ys }) =&gt; {<br/>       return { xs: Object.values(xs), ys: Object.values(ys) };<br/>   }).batch(30);</span></pre><p id="477e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这就是模型的构建方式。有三层，分别有12、8和1个神经元。最后一层包含1个神经元，并通过sigmoid激活设置为返回0/1。模型被编译以支持二进制分类任务:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="748b" class="mb mc it lx b gy md me l mf mg">const numOfFeatures = (await trainingData.columnNames()).length - 1;</span><span id="f10d" class="mb mc it lx b gy mh me l mf mg">const model = tf.sequential();<br/>model.add(tf.layers.dense({<br/>    inputShape: [numOfFeatures],<br/>    units: 12,<br/>    activation: 'relu'<br/>}));<br/>model.add(tf.layers.dense({<br/>    units: 8,<br/>    activation: 'relu'<br/>));<br/>model.add(tf.layers.dense({<br/>    units: 1,<br/>    activation: 'sigmoid'<br/>}));</span><span id="7b63" class="mb mc it lx b gy mh me l mf mg">model.compile({ optimizer: tf.train.adam(0.001), loss: 'binaryCrossentropy', metrics: 'accuracy' });</span></pre><p id="03f9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我使用的是<a class="ae lu" href="https://js.tensorflow.org/api/latest/#tf.Sequential.fitDataset" rel="noopener ugc nofollow" target="_blank"> fitDataset </a>函数，它直接根据之前准备的数据进行训练。这非常方便，省去了繁琐的数据操作过程:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="7809" class="mb mc it lx b gy md me l mf mg">const metrics = ['loss', 'val_loss', 'acc', 'val_acc'];<br/>const container = { name: 'Model Training', styles: { width: '1200px' } };<br/>const fitCallbacks = tfvis.show.fitCallbacks(container, metrics, {callbacks: ['onEpochEnd'], width: 1200});</span><span id="07dc" class="mb mc it lx b gy mh me l mf mg">await model.fitDataset(convertedTrainingData,<br/>     {<br/>         epochs: 100,<br/>         validationData: convertedTestingData,<br/>         callbacks: fitCallbacks<br/>     });</span></pre><p id="e72f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我正在使用<a class="ae lu" href="https://js.tensorflow.org/api_vis/1.4.0/" rel="noopener ugc nofollow" target="_blank"> tfjs-vis </a>回调来可视化培训过程:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mi"><img src="../Images/0e6da698de359f682ad48a6fb8de9220.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wfL9Uw1JAbgM_c2-44xoPA.png"/></div></div></figure><p id="4e8d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，我们执行预测函数来计算标签(训练目标)。TensorFlow.js预测函数期望<em class="lv"> tf.tensor2d </em>变量。[1，8]表示1维，8个输入，用于描述我们传递给预测函数的数据的形状:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="997b" class="mb mc it lx b gy md me l mf mg">const testVal = tf.tensor2d([2, 108, 64, 0, 0, 30.8, 0.158, 21], [1, 8]);<br/>const prediction = model.predict(testVal);<br/>outcome = prediction.dataSync()[0];<br/>prediction.dispose();</span></pre><p id="d67d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">样本代码可以在我的GitHub repo上找到。</p></div></div>    
</body>
</html>