<html>
<head>
<title>Ensemble models for Classification</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于分类的集成模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/ensemble-models-for-classification-d443ebed7efe?source=collection_archive---------30-----------------------#2020-08-17">https://towardsdatascience.com/ensemble-models-for-classification-d443ebed7efe?source=collection_archive---------30-----------------------#2020-08-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4b6a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">堆叠表现不佳的模型以创建更强的模型。他们从彼此的错误中吸取教训</h2></div><p id="a2b0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您已经清理了数据并移除了所有相关要素。您还可视化了数据集，并且知道类标签是可分离的。你也调整了你的超参数。太好了，但是为什么你的模型表现不好呢？</p><h2 id="6d59" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">什么是模型堆叠？</h2><p id="d6ef" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">你试过叠模型吗？传统上，我们用单一的算法来模拟我们的数据。这可能是逻辑回归、高斯朴素贝叶斯或 XGBoost。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi lz"><img src="../Images/79c376e63329466082de6eea165cfdce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hb6Rge6mvFUsZ1EXAdhOAw.png"/></div></div><p class="ml mm gj gh gi mn mo bd b be z dk translated">作者图片:传统 ML 模型</p></figure><p id="9f68" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">系综叠加模型的作用如下:</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi mp"><img src="../Images/5c58e7404bc613fe23a952247d065466.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iCFqUkCpYN-X8DUPafVvSw.png"/></div></div><p class="ml mm gj gh gi mn mo bd b be z dk translated">作者图片:堆叠 ML 模型</p></figure><h2 id="09ed" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">元学习者</h2><p id="be06" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">用于<strong class="kh ir">组合基本估计器</strong>的算法被称为元学习器。我们可以确定我们希望该算法如何响应来自其他模型(本例中为分类器)的不同预测。它可以是:</p><ol class=""><li id="a62f" class="mq mr iq kh b ki kj kl km ko ms ks mt kw mu la mv mw mx my bi translated">估计量的预测</li><li id="9e1d" class="mq mr iq kh b ki mz kl na ko nb ks nc kw nd la mv mw mx my bi translated">预测以及原始训练数据</li></ol><p id="423e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是这仅仅是最后一类<strong class="kh ir">预测吗？</strong>不，您可以选择推动决策的指标:</p><ol class=""><li id="7d65" class="mq mr iq kh b ki kj kl km ko ms ks mt kw mu la mv mw mx my bi translated">可能是<code class="fe ne nf ng nh b">'predict_proba'</code>或<code class="fe ne nf ng nh b">'predict'</code>或者两者都是</li><li id="7768" class="mq mr iq kh b ki mz kl na ko nb ks nc kw nd la mv mw mx my bi translated">也可以使用<a class="ae ni" href="https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.StackingClassifier.html#sklearn.ensemble.StackingClassifier.decision_function" rel="noopener ugc nofollow" target="_blank"> sklearn </a>中的其他<code class="fe ne nf ng nh b">'decision_function'</code></li></ol><p id="bc26" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最终的元学习者可以是任何估计者(默认情况下，sklearn 有逻辑回归)</p><p id="4427" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们采用<strong class="kh ir">基线高斯朴素贝叶斯估计器</strong>，并将所有未来结果与其预测准确度进行比较:</p><pre class="ma mb mc md gt nj nh nk nl aw nm bi"><span id="52d4" class="lb lc iq nh b gy nn no l np nq">rf = OneVsRestClassifier(estimator = GaussianNB())</span><span id="447a" class="lb lc iq nh b gy nr no l np nq">cv = RepeatedStratifiedKFold(n_splits=10, n_repeats=3, random_state=20)</span><span id="9438" class="lb lc iq nh b gy nr no l np nq">n_scores = cross_val_score(rf, X, y, scoring='f1_weighted', cv=cv, error_score='raise')</span><span id="64f8" class="lb lc iq nh b gy nr no l np nq">print(n_scores)<br/>print('Baseline scores \n mean f1 weighted: %.3f with a %.3f standard deviation in scores ' % (np.mean(n_scores), np.std(n_scores)))</span></pre><figure class="ma mb mc md gt me gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/d6c72a7a288b80f1d4018421deda79f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*7rjwJP2Xk-5BrF6JLVDjcA.png"/></div><p class="ml mm gj gh gi mn mo bd b be z dk translated">作者图片:基本模型分数</p></figure><figure class="ma mb mc md gt me"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ml mm gj gh gi mn mo bd b be z dk translated">创建多层调优估值器，并将它们堆叠在一起</p></figure><figure class="ma mb mc md gt me gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/92cd5a9413ba2739bd27cb78c33a1bdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:418/format:webp/1*owbEcVA0c7QqmQNRg3A4TA.png"/></div><p class="ml mm gj gh gi mn mo bd b be z dk translated">图片作者:堆叠模型胜过其他模型！</p></figure><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi nw"><img src="../Images/cee3d23af382efba53aa424f3f5ad9ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s-zdVuDMa_TbvqvivjHbCw.png"/></div></div><p class="ml mm gj gh gi mn mo bd b be z dk translated">作者图片:堆叠模型优于所有分类器</p></figure><p id="60ff" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最终，我们想要一个 F1 值高于 81.1%的分类器，我们最终用堆叠模型得到了 96.7%的 F1 值。</p><p id="a21b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在医疗保健设置中，我将接受相对于 SVC 模型的 0.1%的改进，并且不会牺牲堆叠模型的复杂性！</p><p id="fee5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以在这里找到完整的代码:<a class="ae ni" href="https://github.com/gaurikatyagi/Machine-Learning/blob/master/Classification/Ensemble%20Model-%20Stacked%20Classification.ipynb" rel="noopener ugc nofollow" target="_blank">https://github . com/gaurikatyagi/Machine-Learning/blob/master/class ification/Ensemble % 20 model-% 20 stacked % 20 class ification . ipynb</a></p><p id="5500" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在就去堆栈…</p></div></div>    
</body>
</html>