<html>
<head>
<title>Function Wrappers in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中的函数包装器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/function-wrappers-in-python-5146f3ad0601?source=collection_archive---------8-----------------------#2020-05-05">https://towardsdatascience.com/function-wrappers-in-python-5146f3ad0601?source=collection_archive---------8-----------------------#2020-05-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="46fa" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">将包装器放在函数周围</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a85d32657e61bfae7a1fc803feeb82b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fEfsVE1GdeAetGi5BLltdw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://www.pexels.com/search/wrap/" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="2561" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">软件编程的一个重要原则是 DRY 原则。DRY 是“不要重复自己”的缩写。DRY 的目标是避免软件编程中不必要的重复。DRY 的应用包括通过函数、类、装饰器、类装饰器和元类实现抽象。在这篇文章中，我们将使用一个函数装饰器来包装和添加额外的处理到现有的用于模型构建的函数中。</p><p id="3c16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们开始吧！</p><p id="917b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于我们的例子，我们将定义一个装饰函数来报告输入函数的执行时间。作为一名数据科学家，我经常需要考虑 fit 的执行时间，并预测生产中的调用。让我们考虑这个用例。</p><p id="eef9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用来自<em class="lv">医疗费用个人数据集</em>的合成医疗数据，可以在<a class="ae ky" href="https://www.kaggle.com/mirichoi0218/insurance" rel="noopener ugc nofollow" target="_blank">这里</a>找到。我们将定义读取数据、拟合数据和进行预测的函数。然后我们将定义一个装饰函数，它将报告每个函数调用的执行时间。</p><p id="15f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们将数据读入熊猫数据框:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="9c47" class="mb mc it lx b gy md me l mf mg">import pandas as pd <br/>df = pd.read_csv("insurance.csv")</span></pre><p id="1b08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们打印前五行数据:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="8756" class="mb mc it lx b gy md me l mf mg">print(df.head())</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mh"><img src="../Images/5366cb4abde8347ed30958b3d3911e04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qpFPeW7FwFz7N3R08sItuA.png"/></div></div></figure><p id="c8b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们来构思一下我们的预测问题。让我们使用“年龄”、“bmi”和“儿童”列作为输入特征，使用“费用”作为目标。让我们也拆分我们的数据用于训练和测试。首先，让我们导入一些必要的包:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="b107" class="mb mc it lx b gy md me l mf mg">import numpy as np <br/>from sklearn.model_selection import train_test_split</span></pre><p id="2796" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们定义我们的输入和输出。让我们将数据分成训练集和测试集:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="3ddd" class="mb mc it lx b gy md me l mf mg">X = np.array(df[['children', 'bmi', 'age' ]])<br/>y = np.array(df['charges'])<br/>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state = 42)</span></pre><p id="8657" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们选择一个测试大小，对应于 20%数据的随机样本。现在，让我们将所有这些放入一个函数中:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="0ccd" class="mb mc it lx b gy md me l mf mg">def read_and_split(self, test_size):<br/>    df = pd.read_csv("insurance.csv")<br/>    print(df.head())<br/>    X = np.array(df[['children', 'bmi', 'age' ]])<br/>    y = np.array(df['charges'])<br/>    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state = 42)<br/>    return X_train, X_test, y_train, y_test</span></pre><p id="f755" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们定义一个函数“fit_model”，我们将使用它来使我们的模型符合我们的训练数据。让我们导入“线性回归”模块:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="ab41" class="mb mc it lx b gy md me l mf mg">from sklearn.linear_models import LinearRegression</span></pre><p id="3e7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的“fit_model”函数中，让我们定义一个“LinearRegression”对象，并根据训练数据拟合我们的模型:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="0485" class="mb mc it lx b gy md me l mf mg">def fit_model():<br/>    model = LinearRegression()<br/>    model = model.fit(X_train, y_train)<br/>    return model</span></pre><p id="2173" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，让我们定义一个对测试集进行预测的函数:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="e49d" class="mb mc it lx b gy md me l mf mg">def predict(input_value):<br/>    result = model.predict(X_test)<br/>    return result</span></pre><p id="dc66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经定义了函数，让我们定义将报告执行时间的装饰函数。我们的装饰函数将是一个计时器函数，称为“timethis ”,它将接受一个函数作为输入:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="ada6" class="mb mc it lx b gy md me l mf mg">def timethis(func):<br/>    ...</span></pre><p id="9c73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将在“timethis”函数中定义一个“wrapper”函数:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="b140" class="mb mc it lx b gy md me l mf mg">def timethis(func):<br/>    <br/>    def wrapper(*args, **kwargs):<br/>        ...</span></pre><p id="3050" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的“包装器”函数中，我们将定义“开始”和“结束”变量，我们将使用它们来记录运行的开始和结束。在定义“开始”和“结束”变量之间，我们将调用输入函数，并将其存储在一个名为“结果”的变量中:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="e871" class="mb mc it lx b gy md me l mf mg">def timethis(func):<br/>    <br/>    def wrapper(*args, **kwargs):<br/>        start = time.time()<br/>        result = func(*args, **kwargs)<br/>        end = time.time()</span></pre><p id="16f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要做的最后一件事是将“@ wraps”装饰符放在“wrapper”函数之前的行中:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="14fb" class="mb mc it lx b gy md me l mf mg">def timethis(func):<br/>    <a class="ae ky" href="http://twitter.com/wraps" rel="noopener ugc nofollow" target="_blank">@wraps</a>(func)<br/>    def wrapper(*args, **kwargs):<br/>        start = time.time()<br/>        result = func(*args, **kwargs)<br/>        end = time.time()<br/>        return result</span></pre><p id="794b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">“@ wraps”装饰器获取传递给“@timethis”的函数，并复制函数名、文档字符串、参数列表等…</p><p id="24b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们将打印函数的名称和运行时间(' end' — 'start ')。我们还返回输入函数，它存储在“结果”变量中:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="9505" class="mb mc it lx b gy md me l mf mg">def timethis(func):<br/>    <a class="ae ky" href="http://twitter.com/wraps" rel="noopener ugc nofollow" target="_blank">@wraps</a>(func)<br/>    def wrapper(*args, **kwargs):<br/>        start = time.time()<br/>        result = func(*args, **kwargs)<br/>        end = time.time()<br/>        print(func.__name__, end-start)<br/>        return result</span></pre><p id="f171" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，“timethis”函数返回“包装器”:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="1e01" class="mb mc it lx b gy md me l mf mg">def timethis(func):<br/>    <a class="ae ky" href="http://twitter.com/wraps" rel="noopener ugc nofollow" target="_blank">@wraps</a>(func)<br/>    def wrapper(*args, **kwargs):<br/>        start = time.time()<br/>        result = func(*args, **kwargs)<br/>        end = time.time()<br/>        print(func.__name__, end-start)<br/>        return result<br/>    return wrapper</span></pre><p id="ce30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以在任何函数上使用“@timethis”装饰器。让我们将“@timethis”应用于我们的“read_split”方法。我们只需在我们想要包装的函数前面的行中放上“@timethis ”:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="6ef1" class="mb mc it lx b gy md me l mf mg">@timethis<br/>def read_and_split(self, test_size):<br/>    df = pd.read_csv("insurance.csv")<br/>    X = np.array(df[['children', 'bmi', 'age' ]])<br/>    y = np.array(df['charges'])<br/>    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state = 42)<br/>    return X_train, X_test, y_train, y_test</span></pre><p id="e56e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果我们调用我们的“read_split”方法，我们的装饰器“@timethis”应该打印执行时间:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="f342" class="mb mc it lx b gy md me l mf mg">X_train, X_test, y_train, y_test = read_and_split(0.2)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/bc081b63f35d4ea1c19b0637e9396c61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*tAAa4AjFcW64D4YQxFthmQ.png"/></div></figure><p id="4bdc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们对我们的 fit 方法做同样的事情:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="3d9e" class="mb mc it lx b gy md me l mf mg"><a class="ae ky" href="http://twitter.com/timethis" rel="noopener ugc nofollow" target="_blank">@timethis</a><br/>def fit_model():<br/>    model = LinearRegression()<br/>    model = model.fit(X_train, y_train)<br/>    return model</span><span id="a50a" class="mb mc it lx b gy mj me l mf mg">model = fit_model()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/660850e4185374087d1da0bd9d32797e.png" data-original-src="https://miro.medium.com/v2/resize:fit:846/format:webp/1*jo6oLIjVC0V9fcdyLxoj-w.png"/></div></figure><p id="ef8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于我们预测方法:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="d9f0" class="mb mc it lx b gy md me l mf mg"><a class="ae ky" href="http://twitter.com/timethis" rel="noopener ugc nofollow" target="_blank">@timethis</a><br/>def predict():<br/>    result = model.predict(X_test)<br/>    return result</span><span id="809e" class="mb mc it lx b gy mj me l mf mg">prediction =  predict()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ml"><img src="../Images/202d4de9840acafb341027fb34b9d66a.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*ZmLDDd-m5G02vngybR9UFA.png"/></div></div></figure><p id="0135" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将在这里停下来，但是您可以自己随意摆弄代码和数据。我鼓励您分析一些其他回归模型的执行时间，您可以使用这些数据构建这些模型，如随机森林或支持向量回归。</p><h2 id="03dc" class="mb mc it bd mm mn mo dn mp mq mr dp ms li mt mu mv lm mw mx my lq mz na nb nc bi translated">结论</h2><p id="844e" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">总之，在这篇文章中，我们讨论了 python 中的函数包装器。首先，我们定义了三个函数来构建线性回归模型。我们定义了一些函数，用于读取和拆分我们的数据以进行训练，使我们的模型适合训练数据，并对我们的测试集进行预测。然后我们定义了一个函数包装器，允许我们报告每个函数调用的执行时间。我希望你觉得这篇文章有用/有趣。这篇文章中的代码可以在<a class="ae ky" href="https://github.com/spierre91/medium_code/blob/master/metaprogramming/function_wrapping.py" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。感谢您的阅读！</p></div></div>    
</body>
</html>