<html>
<head>
<title>Simple Guide to Regular Expressions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">正则表达式简单指南</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/simplest-guide-for-regular-expressions-nlp-made-easy-bbb33cd694be?source=collection_archive---------41-----------------------#2020-05-20">https://towardsdatascience.com/simplest-guide-for-regular-expressions-nlp-made-easy-bbb33cd694be?source=collection_archive---------41-----------------------#2020-05-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d2e1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">NLP变得简单</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3bb29e2693b2a441791bf64a7b8c92b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BWdJQGj2xJ6PuRlnx4bNsg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@franki?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">弗兰基·查马基</a>在<a class="ae kv" href="https://unsplash.com/s/photos/data?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="6523" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你不知道正则表达式，它会被认为是很难和高级的东西，但是如果你知道，恭喜你，你知道很难和高级的东西。在这篇文章中，我们将揭示正则表达式的基础，在文章的最后，我附上了一个指向我的笔记本的链接，在那里你可以看到除了我们将在这里讨论的功能之外的三倍多的功能。</p><p id="8000" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以让我们从定义正则表达式开始:</p><blockquote class="ls"><p id="396c" class="lt lu iq bd lv lw lx ly lz ma mb lr dk translated">正则表达式是定义搜索模式的字符序列。</p></blockquote><h2 id="97fa" class="mc md iq bd me mf mg dn mh mi mj dp mk lf ml mm mn lj mo mp mq ln mr ms mt mu bi translated">它们被用在哪里？</h2><p id="c1fc" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">正则表达式有广泛的用途:</p><ul class=""><li id="b9d1" class="na nb iq ky b kz la lc ld lf nc lj nd ln ne lr nf ng nh ni bi translated">文本预处理</li><li id="df4f" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated">根据某种模式提取文本，查找并替换某些符合模式匹配的单词，例如，查找所有以“a”开头的单词，并用单词cat替换它们</li><li id="c995" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated">密码模式匹配</li><li id="e516" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated">数据有效性</li></ul><p id="3312" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正则表达式在您的日常编码任务中起着至关重要的作用，此外，当涉及到数据清理、数据挖掘和其他过于庞大而无法硬编码的操作时，它还是一个超级强大的工具。我们创建一个正则表达式模式，在整个文本中滑动，匹配部分的位置或值返回给我们。</p><p id="7647" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正则表达式模式匹配有两个部分:</p><p id="326c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">1.正确的模式:它是关于找出我们真正想要匹配的东西</p><p id="423c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.右<strong class="ky ir"> re </strong>功能:与职位有关。不管我们是想匹配一开始的模式还是任何地方的模式。万一我们想要分裂和替换，我们也必须改变我们的re函数。</p><h2 id="51aa" class="mc md iq bd me mf no dn mh mi np dp mk lf nq mm mn lj nr mp mq ln ns ms mt mu bi translated"><strong class="ak">问题:给你两个文本，你必须找出它们是否以单词corona开头。</strong></h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="ea59" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以现在我们必须弄清楚两件事:使用什么模式，使用什么函数。</p><ol class=""><li id="435d" class="na nb iq ky b kz la lc ld lf nc lj nd ln ne lr nv ng nh ni bi translated">我们必须匹配单词corona，所以corona是我们的模式字符串。</li><li id="4d3e" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nv ng nh ni bi translated">对于函数，我们将选择<code class="fe nw nx ny nz b">re.match</code>,因为我们需要找到字符串<strong class="ky ir">是否以图案电晕开始</strong>。</li><li id="46f9" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nv ng nh ni bi translated"><code class="fe nw nx ny nz b">re.match</code>接受3个输入- &gt;模式匹配、需要搜索的文本和标志。我们稍后会谈到旗帜。</li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="1540" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">输出</strong>:</p><pre class="kg kh ki kj gt oa nz ob oc aw od bi"><span id="4e08" class="mc md iq nz b gy oe of l og oh">&lt;re.Match object; span=(0, 6), match='corona'&gt;<br/>None</span></pre><p id="c42f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果模式与字符串匹配，则返回一个匹配对象，否则不返回任何对象。</p><p id="20ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在匹配的情况下，如在<code class="fe nw nx ny nz b">result_text1</code>中，返回具有三个属性的匹配对象:</p><ul class=""><li id="649d" class="na nb iq ky b kz la lc ld lf nc lj nd ln ne lr nf ng nh ni bi translated"><code class="fe nw nx ny nz b">.span()</code>:返回包含匹配开始和结束位置的元组。</li><li id="82d8" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated"><code class="fe nw nx ny nz b">.string</code>:返回传递给函数的字符串</li><li id="f50a" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated"><code class="fe nw nx ny nz b">.group()</code>:返回匹配的字符串部分</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="281a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">输出</strong>:</p><pre class="kg kh ki kj gt oa nz ob oc aw od bi"><span id="f5bb" class="mc md iq nz b gy oe of l og oh">Span of result_text1:  (0, 6)<br/>String passed to result_text1:  corona epidemic has taken world by storm.<br/>Groups in result_text1:  corona</span></pre><h1 id="17c9" class="oi md iq bd me oj ok ol mh om on oo mk jw op jx mn jz oq ka mq kc or kd mt os bi translated">与<code class="fe nw nx ny nz b">re.match</code>的问题:</h1><ul class=""><li id="be5e" class="na nb iq ky b kz mv lc mw lf ot lj ou ln ov lr nf ng nh ni bi translated">这是一个非常好的函数，只在开始的时候匹配字符串。</li><li id="4f5f" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated">如果我们想要匹配字符串中的任何地方，我们使用<code class="fe nw nx ny nz b">re.search</code>。它的工作原理和<code class="fe nw nx ny nz b">re.match</code>一样，但是允许我们匹配字符串中的任何位置。返回一个<strong class="ky ir">匹配对象</strong>，如果没有找到匹配，则返回<strong class="ky ir">无</strong>。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="73b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">输出</strong>:</p><pre class="kg kh ki kj gt oa nz ob oc aw od bi"><span id="8935" class="mc md iq nz b gy oe of l og oh">&lt;re.Match object; span=(0, 6), match='corona'&gt;<br/>None<br/>&lt;re.Match object; span=(29, 35), match='corona'&gt;</span></pre><h1 id="8795" class="oi md iq bd me oj ok ol mh om on oo mk jw op jx mn jz oq ka mq kc or kd mt os bi translated"><code class="fe nw nx ny nz b">re.match</code>和<code class="fe nw nx ny nz b">re.search</code>的限制</h1><p id="e9dc" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated"><code class="fe nw nx ny nz b">re.match</code>只能在开始时匹配，而<code class="fe nw nx ny nz b">re.search</code>可以在任何地方匹配，但只返回第一个匹配。原因是<code class="fe nw nx ny nz b">re.search</code>是为了查找字符串中是否存在模式而设计的。如果我们想要返回所有的匹配，我们使用<code class="fe nw nx ny nz b">re.findall</code>。事实上，<code class="fe nw nx ny nz b">re.findall</code>默认用于模式匹配，因为通过各种标识符和条件，它可以表现为<code class="fe nw nx ny nz b">re.match</code> &amp; <code class="fe nw nx ny nz b">re.search</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><pre class="kg kh ki kj gt oa nz ob oc aw od bi"><span id="66e1" class="mc md iq nz b gy oe of l og oh">&lt;re.Match object; span=(0, 6), match='corona'&gt;<br/>['corona', 'corona']</span></pre><h2 id="c064" class="mc md iq bd me mf no dn mh mi np dp mk lf nq mm mn lj nr mp mq ln ns ms mt mu bi translated">如果我们想替换模式匹配我们选择的字符串的地方，该怎么办？</h2><p id="01dd" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">假设我们想用新冠肺炎病毒取代所有出现的冠状病毒。为此，我们使用<code class="fe nw nx ny nz b">re.sub</code> <code class="fe nw nx ny nz b">re.sub(pattern,replacement,text,count)</code>:模式是我们试图匹配的内容，替换是用来替换模式的内容，文本是我们搜索模式的内容。设定<strong class="ky ir">计数</strong>以替代有限的发生次数。默认情况下，它会替换所有引用。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="2295" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">输出</strong>:</p><pre class="kg kh ki kj gt oa nz ob oc aw od bi"><span id="9147" class="mc md iq nz b gy oe of l og oh">coronavirus is causing international shutdowns. Neil Ferguson's report stated that coronavirus matches SARS.<br/>COVID-19 is causing international shutdowns. Neil Ferguson's report stated that COVID-19 matches SARS.</span><span id="e5c4" class="mc md iq nz b gy ow of l og oh">ONLY ONE OCCURENCE IS SUBSTITUTED IF WE MENTION COUNT = 1</span><span id="1aa7" class="mc md iq nz b gy ow of l og oh">coronavirus is causing international shutdowns. Neil Ferguson's report stated that coronavirus matches SARS.<br/>COVID-19 is causing international shutdowns. Neil Ferguson's report stated that coronavirus matches SARS.</span></pre><h1 id="aca7" class="oi md iq bd me oj ok ol mh om on oo mk jw op jx mn jz oq ka mq kc or kd mt os bi translated">在模式匹配的地方拆分文本</h1><p id="9a56" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated"><code class="fe nw nx ny nz b">re.split(pattern,string,maxsplit,flags) </code>模式和字符串是常用参数。maxsplit表示我们最大希望进行多少次分割，默认情况下表示全部。我们稍后会谈到旗帜</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="d9d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">输出</strong>:</p><pre class="kg kh ki kj gt oa nz ob oc aw od bi"><span id="00a3" class="mc md iq nz b gy oe of l og oh">['COVID-19 is ', 'virus, as of 24 March ', 'virus has causes more than 400,000 cases.']</span></pre><blockquote class="ox oy oz"><p id="0d02" class="kw kx pa ky b kz la jr lb lc ld ju le pb lg lh li pc lk ll lm pd lo lp lq lr ij bi translated">字符串在匹配模式的地方被分割。由于上述字符串有两个电晕事件，它只是分裂它在两个地方，因此导致三个部分。将返回拆分列表。</p></blockquote><p id="7f2f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正则表达式也是优秀的武器文本清理、文本挖掘和在一行程序中做复杂的事情。</p><p id="f68d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其余功能请查看我的Github笔记本。正则表达式的其他高级特性将在此讨论:</p><div class="pe pf gp gr pg ph"><a href="https://github.com/iamchiragsharma/Regular-Expressions-NLP-Text" rel="noopener  ugc nofollow" target="_blank"><div class="pi ab fo"><div class="pj ab pk cl cj pl"><h2 class="bd ir gy z fp pm fr fs pn fu fw ip bi translated">iamchiragshama/正则表达式-NLP-Text</h2><div class="po l"><h3 class="bd b gy z fp pm fr fs pn fu fw dk translated">自然语言处理和机器学习的正则表达式。贡献给iamchiragshama/正则表达式-NLP-Text…</h3></div><div class="pp l"><p class="bd b dl z fp pm fr fs pn fu fw dk translated">github.com</p></div></div><div class="pq l"><div class="pr l ps pt pu pq pv kp ph"/></div></div></a></div><p id="16e6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在twitter上关注我，了解关于自然语言处理、深度学习和文本分析的更多更新:</p><div class="pe pf gp gr pg ph"><a href="https://twitter.com/csblacknet" rel="noopener  ugc nofollow" target="_blank"><div class="pi ab fo"><div class="pj ab pk cl cj pl"><h2 class="bd ir gy z fp pm fr fs pn fu fw ip bi translated">奇拉格·夏尔马</h2><div class="po l"><h3 class="bd b gy z fp pm fr fs pn fu fw dk translated">Chirag Sharma的最新推文(@csblacknet)。联合创始人BlackNet |我创造可持续和实用的人工智能。印度</h3></div><div class="pp l"><p class="bd b dl z fp pm fr fs pn fu fw dk translated">twitter.com</p></div></div><div class="pq l"><div class="pw l ps pt pu pq pv kp ph"/></div></div></a></div></div></div>    
</body>
</html>