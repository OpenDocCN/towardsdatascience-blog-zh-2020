<html>
<head>
<title>Experience the power of the Genetic Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">体验遗传算法的威力</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/experience-the-power-of-the-genetic-algorithm-4030adf0383f?source=collection_archive---------34-----------------------#2020-05-31">https://towardsdatascience.com/experience-the-power-of-the-genetic-algorithm-4030adf0383f?source=collection_archive---------34-----------------------#2020-05-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="136e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">基于遗传算法的顶点覆盖</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d91b9457351ed84f9a6d9032de84791d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HQpg3Kx3g-Q6QB6o.jpg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://cdn.pixabay.com/photo/2018/03/02/10/21/head-3192830_1280.jpg" rel="noopener ugc nofollow" target="_blank"> PixaBay </a>上的图片</p></figure><p id="2e75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Genetic_algorithm" rel="noopener ugc nofollow" target="_blank">遗传算法</a>是一种基于<a class="ae ky" href="https://en.wikipedia.org/wiki/Genetics" rel="noopener ugc nofollow" target="_blank">遗传学</a>和<a class="ae ky" href="https://en.wikipedia.org/wiki/Natural_selection" rel="noopener ugc nofollow" target="_blank">自然选择</a>概念的进化计算技术。它主要用于在<a class="ae ky" href="https://en.wikipedia.org/wiki/Deterministic_algorithm" rel="noopener ugc nofollow" target="_blank">确定性</a>多项式解决方案不可行的情况下，为许多优化和更棘手的问题找到一个接近最优的解决方案。</p><p id="dc62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">遗传算法也可以用于搜索空间，以找到正确的特征和模型参数来预测目标变量。遗传算法的另一个重要优点是除了标准优化问题之外，当目标函数是不可微的、不连续的、随机的或非线性的时，它们也是有用的。</p><p id="0be4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将以关于<a class="ae ky" href="https://en.wikipedia.org/wiki/Genetic_algorithm" rel="noopener ugc nofollow" target="_blank">遗传算法</a>和<a class="ae ky" href="https://en.wikipedia.org/wiki/Vertex_cover" rel="noopener ugc nofollow" target="_blank">顶点覆盖</a>问题的简介开始这篇博文。然后我将展示我们如何使用遗传算法来获得顶点覆盖问题的近似最优解，这远优于<a class="ae ky" href="https://en.wikipedia.org/wiki/Approximation_algorithm" rel="noopener ugc nofollow" target="_blank">近似算法</a>。通过这个博客，我也想让读者体验遗传算法的力量。该解决方案的完整源代码可以在<a class="ae ky" href="https://github.com/samread81/Vertex-Cover-Genetic-Algorithm" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h1 id="19bd" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">遗传算法</h1><p id="742a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">遗传算法有 5 个阶段:</p><ol class=""><li id="e63c" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated"><strong class="lb iu">初始化</strong>:初始解(第一代)随机初始化</li><li id="a5d2" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><strong class="lb iu">健康评分</strong>:这里的主要思想是，可能很难找到最佳解决方案，但是一旦我们有了一些解决方案，很容易给它附加一个良好或健康评分。</li><li id="280c" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><strong class="lb iu">选择</strong>:种群中最适合的成员(解)存活下来，并继续进入下一代。</li><li id="3da6" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><strong class="lb iu">交叉</strong>:群体中最适合的成员(解)成对组合，产生新的成员(可能的解)。</li><li id="be43" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><strong class="lb iu">突变</strong>:新成员(可能的新方案)少量改变自己，变得更好。</li></ol><p id="5f0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦初始种群生成，选择、交叉和变异的循环将持续许多代，直到算法收敛或达到最大迭代。这些概念在这个博客里解释得很清楚。</p><div class="ng nh gp gr ni nj"><a rel="noopener follow" target="_blank" href="/introduction-to-genetic-algorithms-including-example-code-e396e98d8bf3"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iu gy z fp no fr fs np fu fw is bi translated">遗传算法简介—包括示例代码</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">遗传算法是一种受查尔斯·达尔文的自然进化理论启发的搜索启发式算法。这个…</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">towardsdatascience.com</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx ks nj"/></div></div></a></div><h1 id="6a92" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">顶点覆盖问题</h1><p id="90c5" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Vertex_cover" rel="noopener ugc nofollow" target="_blank">顶点覆盖</a>是<a class="ae ky" href="https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)" rel="noopener ugc nofollow" target="_blank">图</a>中顶点的子集，使得对于图的每个边(u，v ),或者‘u’或者‘v’在顶点覆盖中。这是一个典型的<a class="ae ky" href="https://en.wikipedia.org/wiki/NP-hardness" rel="noopener ugc nofollow" target="_blank"> NP-hard </a>优化问题，有一个近似算法，但没有确定的多项式解。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/c04f2c76f1f3007fe312207008f4d359.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2jzxINPyCxuKO72KFu5RLA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源<a class="ae ky" href="https://en.wikipedia.org/wiki/File:Vertex-cover.svg" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></figure><p id="3677" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">图-1 的顶点覆盖为 3，与 3-red 节点一样，所有的边都被覆盖，因此对于图的每条边(u，v ),或者“u”或者“v”都在顶点覆盖中。类似地，图-2 的顶点覆盖为 4。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/8eff33f04200364db5a1e711c6cfc196.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uCZtLu0un-Kwnv0ksu65dw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源<a class="ae ky" href="https://en.wikipedia.org/wiki/File:Minimum-vertex-cover.svg" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></figure><p id="0592" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">图-3 的顶点覆盖为 2，图-4 的顶点覆盖为 3。</p><p id="1c81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">顶点覆盖是一个典型的 NP-Hard 问题，没有确定的多项式时间解。我们有一个可用的近似算法，它在多项式时间内运行并给出一个次优解。近似算法的细节可以在下面的链接中找到。</p><div class="ng nh gp gr ni nj"><a href="https://www.geeksforgeeks.org/vertex-cover-problem-set-1-introduction-approximate-algorithm-2/" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iu gy z fp no fr fs np fu fw is bi translated">顶点覆盖问题|集合 1(简介和近似算法)- GeeksforGeeks</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">无向图的顶点覆盖是其顶点的子集，使得对于图的每条边(u，v ),或者…</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">www.geeksforgeeks.org</p></div></div><div class="ns l"><div class="oa l nu nv nw ns nx ks nj"/></div></div></a></div><p id="5572" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有证据表明，近似解永远不会超过最优解 2 倍。详情可以在这里找到。</p><div class="ng nh gp gr ni nj"><a href="http://www.personal.kent.edu/~rmuhamma/Algorithms/MyAlgorithms/AproxAlgor/vertexCover.htm" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iu gy z fp no fr fs np fu fw is bi translated">顶点覆盖</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">定义:无向图 G=( V，E)的顶点覆盖是 V 的子集，使得如果边(u，V)是…</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">www.personal.kent.edu</p></div></div><div class="ns l"><div class="ob l nu nv nw ns nx ks nj"/></div></div></a></div><h1 id="9aa7" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">生成图形数据</h1><p id="a407" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我生成了一个 250 节点的图表。用于生成该图的主要思想是在[0，1]范围内绘制随机数，并且仅当概率小于阈值时，才在节点“u”和“v”之间创建边。</p><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="017d" class="oh lw it od b gy oi oj l ok ol">#Graph Library<br/>import networkx as nx</span><span id="5808" class="oh lw it od b gy om oj l ok ol">edge_probability = .0085<br/>adjacency_matrix = np.zeros((nodes,nodes),dtype = np.int)<br/>edges = []<br/>edges_cnt = 0<br/>for i in range(nodes):<br/>    for j in range(i):<br/>        prob = random.random()<br/>        if prob &lt; edge_probability:<br/>            adjacency_matrix[i,j] = 1<br/>            edges.append((i,j))<br/>            edges_cnt += 1</span><span id="4f6b" class="oh lw it od b gy om oj l ok ol">G=nx.Graph()<br/>G.add_nodes_from(list(range(0,nodes)))<br/>G.add_edges_from(edges)<br/>nx.draw(G,node_color='r', node_size=18, alpha=0.8)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/010f4c23a9d297a025241247d7c9766f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Niw-9XQXRS_DakksE2yjoA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">生成了具有 250 个节点的图“G”</p></figure><p id="3d87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个图有 256 条边。</p><h1 id="5891" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">求图“G”顶点覆盖的近似算法</h1><p id="4f29" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">顶点覆盖的近似算法是一种<a class="ae ky" href="https://en.wikipedia.org/wiki/Greedy_algorithm" rel="noopener ugc nofollow" target="_blank">贪婪算法</a>，它可能不会给出最优解。近似算法的工作可以解释为:</p><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="ce92" class="oh lw it od b gy oi oj l ok ol">1) Initialize the solution-set as  {}<br/>2) Loop through all the E (Edges).<br/>3) For an arbitrary edge (u, v) from set of E (Edges).<br/>   a) Add 'u' and 'v'  to solution-set if none of the vertices 'u' or 'v' present in the set already<br/>   b) If any of the vertex 'u' or 'v' present already in the solution-set, skip the edge and move to the next one.<br/>3) Return solution-set.</span></pre><p id="a0c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该解决方案的更多细节可以在这个博客中找到。</p><div class="ng nh gp gr ni nj"><a href="https://www.geeksforgeeks.org/vertex-cover-problem-set-1-introduction-approximate-algorithm-2/" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iu gy z fp no fr fs np fu fw is bi translated">顶点覆盖问题|集合 1(简介和近似算法)- GeeksforGeeks</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">无向图的顶点覆盖是其顶点的子集，使得对于图的每条边(u，v ),或者…</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">www.geeksforgeeks.org</p></div></div><div class="ns l"><div class="oa l nu nv nw ns nx ks nj"/></div></div></a></div><p id="d7e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在具有 250 个节点和 256 条边的图“G”上运行近似算法，我们得到 178 个节点的顶点覆盖。</p><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="604e" class="oh lw it od b gy oi oj l ok ol">#Vertex Cover Greedy Algorithm<br/>visited = np.zeros(nodes)<br/>cnt = 0<br/>for e in edges:<br/>    (u,v) = e<br/>#     print(u,v)<br/>    if ((visited[u]==0) &amp; (visited[v]==0)):<br/>        visited[u] = 1<br/>        visited[v] = 1<br/>        cnt+=2<br/>print("Vertex cover consists of {} nodes".format(cnt))</span></pre><p id="71a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:顶点覆盖由 178 个节点组成。</p><h1 id="5e71" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">用遗传算法寻找图 G 的顶点覆盖</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/f0695c9497ebf5ffbb504bcc4310dd3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9s_36FSgdW8PJyvY"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://unsplash.com/@kennyluoping" rel="noopener ugc nofollow" target="_blank">肯尼罗</a>在<a class="ae ky" href="https://images.unsplash.com/photo-1515419577046-3a169cab1854?ixlib=rb-1.2.1&amp;auto=format&amp;fit=crop&amp;w=2250&amp;q=80" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h2 id="a952" class="oh lw it bd lx op oq dn mb or os dp mf li ot ou mh lm ov ow mj lq ox oy ml oz bi translated">解决方法</h2><p id="4c95" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">使用遗传算法可能有相当多的解决顶点覆盖的方法。</p><p id="aee0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一种方法是将适应度分数定义为覆盖边和所用顶点数量的函数。当一个解覆盖了所有的边时，罚分是 0，当一些边丢失时，罚分被包括。此外，实现这一目标所需的节点数量也会带来成本。这将需要仔细定义健身核心。</p><p id="667f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不想惹上麻烦，因为适应值是覆盖边和顶点数的函数。我希望它是其中一个的功能。因此，我固定了顶点的数量，并将适应度分数定义为仅覆盖边的函数。这是如何做到的:</p><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="7450" class="oh lw it od b gy oi oj l ok ol">1. Is it possible to cover all the edges with exactly 'k' number of vertices. Genetic Algorithm tries to find such solution, if possible.</span><span id="18c2" class="oh lw it od b gy om oj l ok ol">2. Binary Search for the minimum value for 'k'.</span></pre><h2 id="c73b" class="oh lw it bd lx op oq dn mb or os dp mf li ot ou mh lm ov ow mj lq ox oy ml oz bi translated">初始化</h2><p id="a079" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们需要发现，如果使用一些“k”个顶点，是否有可能覆盖所有的边。因此，我们用一些“k”个顶点随机初始化种群，作为顶点覆盖的一部分。</p><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="879c" class="oh lw it od b gy oi oj l ok ol">n = 250<br/>#----------Hyperparameters can be tuned--------------------<br/>pop_total = 1500   # max population allowed in the environment<br/>pop_init = 1000    # Initial Population<br/>max_iterate = 500  # Max Iterations or Generations allowed<br/>#----------------------------------------------------------</span><span id="25b8" class="oh lw it od b gy om oj l ok ol">def chromosomes_gen(n,k,pop_init):<br/>    lst = []<br/>    for i in range(pop_init):<br/>        chromosome = np.zeros(n,dtype= int)<br/>        samples = random.sample(range(0,n), k = k)<br/>        for j in range(k):<br/>            chromosome[samples[j]] = 1<br/>        lst.append(chromosome)<br/>    return lst</span></pre><h2 id="b837" class="oh lw it bd lx op oq dn mb or os dp mf li ot ou mh lm ov ow mj lq ox oy ml oz bi translated">健身得分</h2><p id="f030" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在这里，我通过使用精确的“k”个顶点的给定解决方案来检查，有多少条边丢失了。我为它增加一个惩罚/障碍计数。</p><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="5aba" class="oh lw it od b gy oi oj l ok ol">def cost(soln,n,edges):<br/>    obstacles = 0<br/>    for e in edges:<br/>        (u,v) = e<br/>        if ((soln[u]==0) &amp; (soln[v]==0)):<br/>            obstacles += 1<br/>    return obstacles</span></pre><h2 id="aa0b" class="oh lw it bd lx op oq dn mb or os dp mf li ot ou mh lm ov ow mj lq ox oy ml oz bi translated">选择</h2><p id="c460" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">有各种可能的选择方法。在这个问题中，我只是简单地将得分最高的解决方案传递给下一代，并杀死其余的。变量‘pop _ total’定义了允许传递给下一代的最大群体。</p><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="7d2d" class="oh lw it od b gy oi oj l ok ol">def selection(lst,pop_total,n,edges):<br/>    score = []<br/>    output_lst = []<br/>    len_lst = len(lst)<br/>    for i in range(len_lst):<br/>        score.append(cost(lst[i],n,edges))<br/>    sorted_index = np.argsort(score)<br/>    cnt = 0<br/>    for i in range(len_lst):<br/>        output_lst.append(lst[sorted_index[i]])<br/>        if((i+1) == pop_total):<br/>            break<br/>    lst = output_lst <br/>    # Return truncated-population and best score of this Generation<br/>    return lst,score[sorted_index[0]]</span></pre><h2 id="3bb8" class="oh lw it bd lx op oq dn mb or os dp mf li ot ou mh lm ov ow mj lq ox oy ml oz bi translated">交叉</h2><p id="bb66" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在交叉中，我们将两种解决方案结合起来，希望得到更好的解决方案。在这个问题中，我采用两个解决方案，找到第一个解决方案中不存在于第二个解决方案中的顶点，类似地，采用第二个解决方案中不存在于第一个解决方案中的顶点，并交换其中的 50%。</p><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="a645" class="oh lw it od b gy oi oj l ok ol">#Crossover<br/>cross_over_prob = 0.50<br/>for i in range(len_lst):<br/>      <br/>      # First solution<br/>      tmp = lst[i].copy()<br/>      # Second solution<br/>      mate_with = lst[int(random.uniform(0,len_lst))]<br/>      <br/>      tmp_unique = []<br/>      mate_with_unique = []<br/>      <br/>      # Store all vertices of Solution-1 and Solution-2<br/>      for j in range(n):<br/>          if(tmp[j]==1):<br/>              tmp_unique.append(j)<br/>          if(mate_with[j]==1):<br/>              mate_with_unique.append(j)</span><span id="a99e" class="oh lw it od b gy om oj l ok ol">#Filter vertices from Solution-1 which is in Solution-2 and shuffle<br/>      tmp_unique = np.setdiff1d(tmp,mate_with)<br/>      random.shuffle(tmp_unique)</span><span id="2f16" class="oh lw it od b gy om oj l ok ol">#Filter vertices from Solution-2 which is in Solution-1 and shuffle<br/>      mate_with_unique = np.setdiff1d(mate_with,tmp)<br/>      random.shuffle(mate_with_unique)</span><span id="2d4c" class="oh lw it od b gy om oj l ok ol">#Swap 50% unique vertices from Solution2 into Solution1 ~ New Soln<br/>      swap = math.ceil(cross_over_prob * min(len(tmp_unique),len(mate_with_unique)))<br/>      for j in range(swap):<br/>          tmp[mate_with_unique[j]] = 1<br/>          tmp[tmp_unique[j]] = 0<br/>      new_solution = tmp</span></pre><h2 id="4266" class="oh lw it bd lx op oq dn mb or os dp mf li ot ou mh lm ov ow mj lq ox oy ml oz bi translated">变化</h2><p id="ef17" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在这一步中，来自交叉状态的新解会稍微改变自己，或者变异，希望变得更好。在这个问题中，我执行了两种类型的突变，改变了 5%的解。我掷硬币，如果正面朝上，我进行变异 1，否则进行变异 2，两者都不同地改变 5%的解。</p><p id="6d7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在变异-1 中，我从解中随机取出 5%的顶点，并用之前不在解中的其他随机 5%的顶点替换它。</p><p id="dd67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在变异-2 中，我从解决方案中随机抽取 5%的顶点，并用其他 5%的顶点替换，这些顶点可以覆盖当前解决方案未能覆盖的一些边。</p><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="23a3" class="oh lw it od b gy oi oj l ok ol"># Mutation <br/>mutat_prob = 0.05<br/>zeroes = []<br/>ones = []<br/>for j in range(n):<br/>    if soln[j]==1:<br/>        ones.append(j)<br/>    else:<br/>        zeroes.append(j)</span><span id="9e08" class="oh lw it od b gy om oj l ok ol">random.shuffle(ones)<br/>random.shuffle(zeroes)</span><span id="da3f" class="oh lw it od b gy om oj l ok ol">coin_toss = random.random()<br/>if(coin_toss &lt;= 0.5):<br/>    # Mutation-1<br/>    swaps = min(len(ones),len(zeroes))<br/>    for j in range(swaps):<br/>        coin_toss2 = random.random()<br/>        if(coin_toss2 &lt; mutat_prob):<br/>            soln[ones[j]] = 0<br/>            soln[zeroes[j]] = 1<br/>            #Swapping logic<br/>            dummy = ones[j]<br/>            ones[j] = zeroes[j]<br/>            zeroes[j] = dummy<br/>else:    <br/>    # Mutation-2<br/>    mutate_lst = []<br/>    for e in edges:<br/>        (u,v) = e<br/>        if((soln[u] == 0) &amp; (soln[v] == 0)):<br/>            coin_toss2 = random.random()<br/>            if(coin_toss2 &lt; mutat_prob):<br/>                coin_toss3 = random.random()<br/>                if(coin_toss3 &lt;= 0.5):<br/>                    if(u not in mutate_lst):<br/>                        mutate_lst.append(u)<br/>                else:<br/>                    if(v not in mutate_lst):<br/>                        mutate_lst.append(v)</span><span id="e755" class="oh lw it od b gy om oj l ok ol">    random.shuffle(mutate_lst)<br/>    sz = min(len(ones),len(mutate_lst))<br/>    <br/>    for j in range(sz):<br/>        soln[ones[j]] = 0<br/>        soln[mutate_lst[j]] = 1<br/>        #Swapping logic<br/>        dummy = ones[j]<br/>        ones[j] = mutate_lst[j]<br/>        mutate_lst[j] = dummy<br/>    <br/>soln_lst.append(soln)</span></pre><blockquote class="pa pb pc"><p id="72d8" class="kz la pd lb b lc ld ju le lf lg jx lh pe lj lk ll pf ln lo lp pg lr ls lt lu im bi translated">遗传算法的性能主要取决于交叉和变异函数的构造。这些功能需要仔细设计和调整/修改，以获得最佳性能。</p></blockquote><h2 id="6744" class="oh lw it bd lx op oq dn mb or os dp mf li ot ou mh lm ov ow mj lq ox oy ml oz bi translated">二分搜索法找到最小的 k</h2><p id="4090" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我执行了一个<a class="ae ky" href="https://en.wikipedia.org/wiki/Binary_search_algorithm" rel="noopener ugc nofollow" target="_blank">二分搜索法</a>来寻找‘k’的最小值，这样‘k’个顶点的顶点覆盖覆盖了所有的图边。</p><pre class="kj kk kl km gt oc od oe of aw og bi"><span id="1f0a" class="oh lw it od b gy oi oj l ok ol"># Environment to perform Initialisation-Selection-Crossover-Mutation<br/>def environ(n,k,mut_prob,pop_init,pop_totl,max_iterate,edges)<br/>    soln = chromosomes_gen(n,k,pop_init)<br/>    for it in range(max_iterate):<br/>        soln = cross_over_mutate(soln,n,k,mut_prob,pop_total,edges)<br/>        soln,cost_value = selection(soln,pop_total,n,edges)<br/>        if cost_value==0:<br/>            break<br/>    return cost_value,result</span><span id="34c3" class="oh lw it od b gy om oj l ok ol"># Binary Search function<br/>def mfind(n,mut_prob,pop_init,pop_total,max_iterate,edges,start,end)<br/>    result_dict = {}<br/>    l = start<br/>    h = end<br/>    ans = 0<br/>    while(l&lt;=h):<br/>        m = int((l+h)/2.0)<br/>        cv,res = environ(n,m,mut_prob,pop_init,pop_total,max_iterate,edges)<br/>        if(cv==0):<br/>            result_dict[m] = res<br/>            h = m-1<br/>        else:<br/>            l = m + 1<br/>    return result_dict</span><span id="df8e" class="oh lw it od b gy om oj l ok ol"># Main-function Call<br/>res = mfind(n,mutat_prob,pop_init,pop_total,max_iterate,edges,1,n)</span></pre><h1 id="44ec" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结果</h1><p id="e946" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">使用遗传算法，具有 250 个节点和 256 条边的图“G”的顶点覆盖是 104 个节点，这比近似算法的 178 个节点的解决方案小得多且更好。解决方案的完整源代码可以在<a class="ae ky" href="https://github.com/samread81/Vertex-Cover-Genetic-Algorithm" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h1 id="eb3d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="c234" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在这篇博文中，我们理解了遗传算法的概念及其用例和属性。然后我们用遗传算法来解决顶点覆盖问题，得到了一个比近似算法更好的解。</p><blockquote class="ph"><p id="5ff8" class="pi pj it bd pk pl pm pn po pp pq lu dk translated">如果你有任何疑问，请联系我。我很有兴趣知道你是否有一些有趣的问题陈述或想法，遗传算法可以用于它。</p></blockquote><p id="2905" class="pw-post-body-paragraph kz la it lb b lc pr ju le lf ps jx lh li pt lk ll lm pu lo lp lq pv ls lt lu im bi translated"><strong class="lb iu"> <em class="pd">我的 Youtube 频道更多内容:</em> </strong></p><div class="ng nh gp gr ni nj"><a href="https://www.youtube.com/channel/UCg0PxC9ThQrbD9nM_FU1vWA" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iu gy z fp no fr fs np fu fw is bi translated">阿布舍克·蒙戈利</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">嗨，伙计们，欢迎来到频道。该频道旨在涵盖各种主题，从机器学习，数据科学…</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">www.youtube.com</p></div></div><div class="ns l"><div class="pw l nu nv nw ns nx ks nj"/></div></div></a></div><blockquote class="pa pb pc"><p id="33b0" class="kz la pd lb b lc ld ju le lf lg jx lh pe lj lk ll pf ln lo lp pg lr ls lt lu im bi translated"><strong class="lb iu"> <em class="it">关于作者-: </em> </strong></p><p id="3250" class="kz la pd lb b lc ld ju le lf lg jx lh pe lj lk ll pf ln lo lp pg lr ls lt lu im bi translated">Abhishek Mungoli 是一位经验丰富的数据科学家，拥有 ML 领域的经验和计算机科学背景，跨越多个领域并具有解决问题的思维方式。擅长各种机器学习和零售业特有的优化问题。热衷于大规模实现机器学习模型，并通过博客、讲座、聚会和论文等方式分享知识。</p><p id="1db9" class="kz la pd lb b lc ld ju le lf lg jx lh pe lj lk ll pf ln lo lp pg lr ls lt lu im bi translated">我的动机总是把最困难的事情简化成最简单的版本。我喜欢解决问题、数据科学、产品开发和扩展解决方案。我喜欢在闲暇时间探索新的地方和健身。关注我的<a class="ae ky" href="https://medium.com/@mungoliabhishek81" rel="noopener"> <strong class="lb iu">中</strong> </a>、<strong class="lb iu"/><a class="ae ky" href="https://www.linkedin.com/in/abhishek-mungoli-39048355/" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">Linkedin</strong></a><strong class="lb iu"/>或<strong class="lb iu"/><a class="ae ky" href="https://www.instagram.com/simplyspartanx/" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">insta gram</strong></a><strong class="lb iu"/>并查看我的<a class="ae ky" href="https://medium.com/@mungoliabhishek81" rel="noopener">往期帖子</a>。我欢迎反馈和建设性的批评。我的一些博客-</p></blockquote><ul class=""><li id="fcf3" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu px my mz na bi translated">每个数据科学家都应该避免的 5 个错误</li><li id="3ad8" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu px my mz na bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/decomposing-a-time-series-in-a-simple-and-intuitive-way-19d3213c420b?source=---------7------------------">以简单&amp;直观的方式分解时间序列</a></li><li id="7534" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu px my mz na bi translated"><a class="ae ky" href="https://medium.com/walmartlabs/how-gpu-computing-literally-saved-me-at-work-fc1dc70f48b6" rel="noopener">GPU 计算如何在工作中真正拯救了我？</a></li><li id="d033" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu px my mz na bi translated">信息论&amp; KL 分歧<a class="ae ky" rel="noopener" target="_blank" href="/part-i-a-new-tool-to-your-toolkit-kl-divergence-5b887b5b420e">第一部分</a>和<a class="ae ky" rel="noopener" target="_blank" href="/part-2-a-new-tool-to-your-toolkit-kl-divergence-736c134baa3d">第二部分</a></li><li id="d82a" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu px my mz na bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/process-wikipedia-using-apache-spark-to-create-spicy-hot-datasets-1a59720e6e25">使用 Apache Spark 处理维基百科，创建热点数据集</a></li><li id="2b85" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu px my mz na bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/a-semi-supervised-embedding-based-fuzzy-clustering-b2023c0fde7c">一种基于半监督嵌入的模糊聚类</a></li><li id="e131" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu px my mz na bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/compare-which-machine-learning-model-performs-better-4912b2ed597d">比较哪种机器学习模型表现更好</a></li><li id="127e" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu px my mz na bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/analyzing-fitbit-data-to-demystify-bodily-pattern-changes-amid-pandemic-lockdown-5b0188fec0f0">分析 Fitbit 数据，揭开疫情封锁期间身体模式变化的神秘面纱</a></li><li id="3d73" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu px my mz na bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/myths-and-reality-around-correlation-9b359456d8e1">神话与现实围绕关联</a></li><li id="3db6" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu px my mz na bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/a-guide-to-becoming-business-oriented-data-scientist-51da5c829ffa">成为面向商业的数据科学家指南</a></li></ul></div></div>    
</body>
</html>