<html>
<head>
<title>Are you dropping too many correlated features?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你是否丢弃了太多相关的特性？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/are-you-dropping-too-many-correlated-features-d1c96654abe6?source=collection_archive---------7-----------------------#2020-09-14">https://towardsdatascience.com/are-you-dropping-too-many-correlated-features-d1c96654abe6?source=collection_archive---------7-----------------------#2020-09-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="88dc" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">对当前方法的分析和建议的解决方案</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/9a4966c4842b19d4003f249750a61735.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EJw_Da7iRkwGh21N"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">卡拉·里维拉在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="068f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">更新</strong>:本文描述的更新后的 Python 关联函数可以在 PYPI 上的<a class="ae kv" href="https://pypi.org/project/exploretransform/" rel="noopener ugc nofollow" target="_blank"> exploretransform </a>包中找到。</p><h1 id="b922" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">总结</strong></h1><p id="d451" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">一些常用的相关滤波方法倾向于丢弃比所需更多的特征。随着数据集变得越来越大，并且随着更多的成对相关性超过特定阈值，这个问题变得更加严重。如果我们丢弃了不必要的变量，那么可用的信息就会减少，从而可能导致模型性能不佳。在本文中，我将展示当前方法的缺点，并提出一个可能的解决方案。</p><h1 id="2583" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">示例</strong></h1><p id="d51c" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">让我们来看一个例子，当前的方法是如何删除本应保留在数据集中的要素的。我们将使用波士顿住房修订数据集，并用 R 和 Python 展示示例。</p><p id="2140" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> R: </strong>下面的代码使用 caret 包中的 findCorrelation()函数来确定应该删除哪些列。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="9621" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该功能确定[ 'indus '，' nox '。lstat '，' age '，' dis' ]应根据 0.6 的相关临界值删除。</p><p id="d420" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> Python </strong> : Python 没有 findCorrelation()这样的内置函数，所以我写了一个叫 corrX_orig()的函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="4f5b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们得到与 R: drop 列[ 'indus '，' nox '相同的结果。lstat '，'年龄'，' dis' ]</p><h1 id="14e3" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">不幸的是，两者都不正确。年龄一栏不应该被删除。我们来探究一下原因。</h1><p id="830b" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><strong class="ky ir">这些功能是如何工作的？<br/> </strong>首先创建一个相关矩阵。这些数字代表所有数值变量组合的成对相关性。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mr"><img src="../Images/7948ab86f5204eb4169d7df44a605f92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Un3RmCzh5dJGEMuon-cGww.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">波士顿住房的相关矩阵</p></figure><p id="7688" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，计算每个变量的平均相关性。这可以通过取每行或每列的平均值来实现，因为它们是相等的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/e80dcf0446c198adaf2675f294f32bbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/format:webp/1*YNEV6_3pCuGd0n-Ru_TMVw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">列和行的平均相关性</p></figure><p id="d0f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">之后，矩阵的下三角和对角线被屏蔽。我们不需要下面的三角形，因为相同的信息存在于对角线的两边(见上面的矩阵)。我们不需要对角线，因为它代表变量和它们自身之间的相关性(它总是 1)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mt"><img src="../Images/b962139c20493a9240b709437af7725d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z0ciepPUCPV2KyK-ZgUxLA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">下三角形和对角线被遮罩的矩阵</p></figure><p id="d941" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是伪代码来演示该函数的其余部分是如何工作的。我将 0.6 硬编码为本例的相关截止值:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="4444" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">现在到了你期待已久的部分</strong>。<strong class="ky ir">为什么功能不会老化？</strong></p><p id="d2a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的表格显示了我从原始函数中捕获的变量。还记得函数告诉我们去掉[ 'indus '，' nox '吗。lstat '，' age '，' dis' ]。所以我们手动从表中删除[ 'indus '，' nox '，' lstat '，' dis' ]。正如您在表中看到的，没有其他变量可以与年龄进行比较来做出放弃决定。因此年龄不应该下降。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mu"><img src="../Images/ec16d65cc0f15dce1ecc8ba4e64ab169.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3unrxiYyao-wC6uRw_lWgQ.png"/></div></div></figure><p id="58d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">但是为什么会这样呢？</strong></p><p id="04e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于 R 和 python 函数的顺序性质，它们无法整体考虑所有变量的状态。删除变量的决定按顺序发生，并且是最终决定。</p><p id="dc5e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如何证明年龄属于数据集中？</p><p id="1c4f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以从下拉列表中删除 age，得到[ indus，nox，dis，lstat]，然后从原始数据集中删除这四列。当我们重新运行这个变量子集时，如果它应该被删除，我们将期望“age”作为输出。如果我们没有输出，这意味着“年龄”应该留在集合中。</p><p id="1d7a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">如下图所示，这两个函数都没有输出。年龄应该留下来。</strong></p><p id="8965" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> R </strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="cd9f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> Python </strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="6a5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">简要回顾</strong></p><p id="3d4a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个例子中，我们已经证明了常用的相关过滤函数夸大了删除列的数量。我的断言是，这是由于相关矩阵中的每个单元如何被评估和丢弃的顺序性质。</p><h1 id="93f1" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">那么解决办法是什么呢？</strong></h1><ol class=""><li id="bafd" class="mv mw iq ky b kz mk lc ml lf mx lj my ln mz lr na nb nc nd bi translated">根据原始逻辑记录变量状态</li><li id="d9fe" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr na nb nc nd bi translated">使用日志计算最后要删除的变量</li><li id="3cff" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr na nb nc nd bi translated"><strong class="ky ir">原始</strong>:原始解决方案顺序地、立即地、最终地删除列。</li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><ol class=""><li id="44ea" class="mv mw iq ky b kz la lc ld lf nj lj nk ln nl lr na nb nc nd bi translated"><strong class="ky ir">修改后的</strong>:捕捉变量状态而不落入数据帧 res</li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="0758" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 2。修订后的</strong>:使用 res 计算要删除的变量</p><p id="2219" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是 res 的输出，包含变量状态和变量定义</p><p id="f0cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> v1，v2 </strong>:被分析的行和列<br/>v1，v2【T27。mean] :每个 v1 和 v2 的平均相关性<br/><strong class="ky ir">corr</strong>:v1 和 v2 的成对相关性<br/> <strong class="ky ir"> drop </strong>:初始 drop 决定下降(v1.mean，v2.mean)中的较高值</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/d2c89450807553a05c17cbdd94f5346a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dxRgCLyfs-Ol1x6ZhJHDyw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">捕获的可变状态</p></figure><p id="2a26" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">修改了跌落计算中的(2)个步骤</strong></p><p id="a4e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我鼓励读者使用上面的捕获变量状态(res)图来手动完成下面的步骤。我还嵌入了 calcDrop()函数中每一步的代码。整个函数在这一节的末尾。</p><p id="6df3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">第一步:</strong> all_vars_corr <strong class="ky ir"> = </strong>所有超过相关临界值 0.6 的变量。因为我们的逻辑将捕获满足这个条件的变量，所以这将是上面 res 表中 v1 + v2 列中的唯一变量集。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="c9fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">结果</strong> : ['tax '，' indus '，' lstat '，' rm '，' zn '，' age '，' nox '，' dis']</p><p id="fd65" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">第二步:</strong> poss_drop <strong class="ky ir"> = </strong>来自 drop 列的唯一变量。这些最终可能会也可能不会被放弃。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="27a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">结果</strong> : ['indus '，' lstat '，' age '，' nox '，' dis']</p><p id="d6f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">步骤 3: </strong>保持<strong class="ky ir"> = </strong>来自 v1 和 v2 的变量不在 poss_drop 中。本质上，任何不可能被删除的变量都将被保留</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="5c6e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">结果</strong> : ['zn '，' tax '，' rm']</p><p id="65b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">步骤 4: </strong> drop =来自 v1 和 v2 的变量出现在与 keep 相同的行中。如果我们知道要保留哪些变量，那么任何与这些变量配对的变量都将被丢弃。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="b52a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">结果</strong> : ['lstat '，' nox '，' dis '，' indus']</p><p id="5149" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">第五步</strong> : poss_drop =从 poss_drop 中移除 drop 变量。我们正在删除我们知道会从可能性列表中删除的变量。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="596b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">结果</strong> : ['年龄']这是可能性中剩下的最后一个变量。</p><p id="5350" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">步骤 6 </strong>:将数据帧子集化，仅包含 v1 和 v2 中的 poss_drop 变量。我们想知道是否有任何理由降低年龄。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/1e5524bdedfe536215c1f2f1599880cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/1*aGj1uLE6Ea7kaJ6Phzi66w.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">步骤 6 的结果</p></figure><p id="7192" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> Step7 </strong>:删除 drop 变量在 v1 或 v2 中的行，存储 drop 列中的唯一变量。将结果存储在 more_drop 中。在这里，我们删除了包含要删除的变量的行。在这个较小的例子中，我们将得到一个空集，因为所有的行都包含我们知道要删除的变量。这是正确的结果:年龄不在这个集合中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="56f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">结果</strong>:设定()</p><p id="fe58" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">第 8 步</strong>:添加更多 _drop 变量到 drop 并返回 drop</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="65ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">结果</strong> : ['lstat '，' nox '，' dis '，' indus']:手动完成 res 表<strong class="ky ir">上的<strong class="ky ir"> </strong>步骤后，more_drop 不包含年龄，这正是我们所期望的</strong></p><p id="9164" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">下面是完整的 calcDrop()函数:</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="c5bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">简要回顾</strong></p><p id="fbf2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本例中，我们展示了一对基于相关性过滤变量的修正函数。这些函数的工作方式如下:</p><ol class=""><li id="be98" class="mv mw iq ky b kz la lc ld lf nj lj nk ln nl lr na nb nc nd bi translated"><strong class="ky ir"> corrX_new </strong>:记录基于原始逻辑的变量状态</li><li id="fade" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr na nb nc nd bi translated"><strong class="ky ir"> calcDrop </strong>:计算要删除的变量</li></ol><h1 id="64dc" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">最终示例</strong></h1><p id="a50f" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">让我们使用来自 R 的 caret 包的(mdrr)数据集，它包含许多相关的特性。我们将在本节中使用新旧函数，因为我们已经介绍了一般的测试例程，所以不会太冗长。</p><p id="ad60" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> R(原始)</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="cb2f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">findCorrelation()删除了 203 列</p><p id="c148" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> Python(原创)</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="be2e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">corrX_orig()删除 203 列</p><p id="adab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> Python(修订版)</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="c0e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有 9 列被识别为不应该从数据集中删除。我们用 R 和 Python 来确认一下。</p><p id="fbe2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> R </strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="450a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当 python 所标识的列被添加回 R 中的主集中时，没有删除任何列。</p><p id="868c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> Python </strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="9b52" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Python 中的结果是相同的。最初不应该删除列['DDI '，' ZM1V '，' X2v '，' piPC05 '，' VAR '，' SPAN '，' QYYe '，' GMTIV '，' X5sol']。</p><h1 id="06e0" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">结论</strong></h1><p id="cee7" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在本文中，我们已经展示了常用的相关滤波方法是如何不必要地丢弃特征的。我们已经展示了当数据变大时，问题会如何加剧。尽管我们没有给出证据，但可以合理地假设，不必要的特征移除会对模型性能产生负面影响</p><p id="870a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还提供了有效的解决方案，包括代码、解释和示例。在以后的文章中，我们将扩展这个解决方案，将目标相关性添加到过滤决策中。</p><p id="32f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请随时在 LinkedIn 上联系我。</p></div></div>    
</body>
</html>