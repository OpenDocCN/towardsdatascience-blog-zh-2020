<html>
<head>
<title>You never get bored playing with Computer Vision</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">玩电脑视觉永远不会无聊</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/you-never-get-bored-playing-with-computer-vision-cb93cbd3274a?source=collection_archive---------42-----------------------#2020-05-13">https://towardsdatascience.com/you-never-get-bored-playing-with-computer-vision-cb93cbd3274a?source=collection_archive---------42-----------------------#2020-05-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6e1c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><em class="kf">…以及如何让Dino独立运行而不考虑平台</em></h2></div><p id="aeb6" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">在本文中，您将学习如何使用Python和MSS以合适的帧速率录制屏幕。如何用OpenCV进行模板匹配和边缘检测？如果你愿意，你可以让你的机器玩游戏。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lc"><img src="../Images/40241a8b30f3f88431b74baaab30364f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-bGv2uUHOUI6UKPLHv5JgQ.jpeg"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">来源:作者</p></figure><h1 id="1a11" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">介绍</h1><p id="664f" class="pw-post-body-paragraph kg kh iq ki b kj mk jr kl km ml ju ko kp mm kr ks kt mn kv kw kx mo kz la lb ij bi translated">我喜欢自动化，有一次我读了由<a class="ae mp" href="https://medium.com/@markusrenepae" rel="noopener">马库斯·雷内·Pae</a>写的关于另一个python库<a class="ae mp" href="https://pyautogui.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> PyAutoGUI </a>的<a class="ae mp" href="https://medium.com/datadriveninvestor/automating-your-job-with-python-f1952b6b640d" rel="noopener">评论</a>。这个库允许你通过操作系统输入来操作，比如发出鼠标或键盘事件。Markus提出的挑战之一是自动化Google Dino游戏。我很好奇PyAutoGUI是否允许我实时捕捉监视器，找到恐龙，并在需要时进行跳跃？我决定尝试一下，不要拘泥于浏览器实现，所以Dino应该运行，不管它是浏览器还是独立的应用程序。在本文的后面，您将发现PyAutoGUI在哪些任务中工作得很好，在哪些任务中最好使用其他技术。</p><h2 id="0963" class="mq lt iq bd lu mr ms dn ly mt mu dp mc kp mv mw me kt mx my mg kx mz na mi nb bi translated">我最后用了哪些库来让Dino单独运行</h2><ul class=""><li id="e0c4" class="nc nd iq ki b kj mk km ml kp ne kt nf kx ng lb nh ni nj nk bi translated"><a class="ae mp" href="https://pyautogui.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> PyAutoGUI </a></li><li id="e1a7" class="nc nd iq ki b kj nl km nm kp nn kt no kx np lb nh ni nj nk bi translated"><a class="ae mp" href="https://opencv.org" rel="noopener ugc nofollow" target="_blank"> OpenCV </a></li><li id="7395" class="nc nd iq ki b kj nl km nm kp nn kt no kx np lb nh ni nj nk bi translated"><a class="ae mp" href="https://python-mss.readthedocs.io" rel="noopener ugc nofollow" target="_blank"> Python MSS </a>(多个截图)</li><li id="e316" class="nc nd iq ki b kj nl km nm kp nn kt no kx np lb nh ni nj nk bi translated">当然还有<a class="ae mp" href="https://numpy.org" rel="noopener ugc nofollow" target="_blank"> NumPy </a>、<a class="ae mp" href="https://matplotlib.org" rel="noopener ugc nofollow" target="_blank"> Matplotlib </a>和<a class="ae mp" href="https://jupyter.org" rel="noopener ugc nofollow" target="_blank"> Jupyter </a></li></ul><h2 id="48e9" class="mq lt iq bd lu mr ms dn ly mt mu dp mc kp mv mw me kt mx my mg kx mz na mi nb bi translated">简而言之什么是CV(计算机视觉)和OpenCV</h2><p id="a3e7" class="pw-post-body-paragraph kg kh iq ki b kj mk jr kl km ml ju ko kp mm kr ks kt mn kv kw kx mo kz la lb ij bi translated">如今，计算机视觉是一个非常热门的话题。它被用在许多地方，在这些地方，图像或视频应该被处理以备将来使用。例如Face ID:在了解这是你之前，首先它试图检测一张脸，然后处理图片并要求ML(机器学习)模型来分类这是不是你。<em class="nq">可能是其他人正在尝试解锁您的手机。</em>目前最流行的CV库之一是<a class="ae mp" href="https://opencv.org" rel="noopener ugc nofollow" target="_blank"> OpenCV </a>。根据官方网站:<em class="nq">该库拥有超过2500种优化算法，其中包括一套全面的经典和最先进的计算机视觉和机器学习算法</em>。OpenCV是用C++写的，可以在所有平台上使用，使用C++、Python等写的API。如果你有一个遵循<a class="ae mp" href="https://opencv.org/platforms/cuda/" rel="noopener ugc nofollow" target="_blank"> CUDA </a>或<a class="ae mp" href="https://opencv.org/opencl/" rel="noopener ugc nofollow" target="_blank"> OpenCL </a>标准的GPU，它会加速你的GPU上的计算。</p><h2 id="21c8" class="mq lt iq bd lu mr ms dn ly mt mu dp mc kp mv mw me kt mx my mg kx mz na mi nb bi translated">我用PyAutoGUI实现游戏自动化的尝试</h2><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi nr"><img src="../Images/880c57b38c2eecf6a06d62cd988497aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GOGYspUKS6-rNp2sEnp6xg.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">没有互联网连接的Chrome浏览器截图</p></figure><p id="efcd" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">首先，我实现了一个游戏循环，并试图只使用PyAutoGUI来捕捉屏幕，匹配一个模板(在我的情况下，它是一个恐龙),从技术上来说，这是可行的，但是……PyAutoGUI中的截图并不是为了实时捕捉。所以我得到了两帧之间大约一秒的延迟。因为Dino运行速度超过每秒400像素，所以太多了。当我的程序按下“跳转”键时，游戏就结束了。我决定指定每次捕获哪个区域来减少延迟，得到的延迟大约是0.4秒。更好，但仍然不够。我明白我需要一些别的东西来执行物体检测，所有的计算都应该以至少30帧/秒的速度进行。这意味着我需要在0.03秒内完成我的计算和所有的副作用。</p><h2 id="5792" class="mq lt iq bd lu mr ms dn ly mt mu dp mc kp mv mw me kt mx my mg kx mz na mi nb bi translated">MSS跳入游戏</h2><p id="be57" class="pw-post-body-paragraph kg kh iq ki b kj mk jr kl km ml ju ko kp mm kr ks kt mn kv kw kx mo kz la lb ij bi translated">一、什么是MSS？<br/>根据docs MSS是<em class="nq">一个使用ctypes的纯python中的超快速跨平台多截图模块。</em>该API易于使用，已经集成了Numpy和OpenCV。我为什么选择MSS？基本上，如果你想捕捉整个屏幕，MSS会做得很快，比其他库快得多。如果你需要把你的屏幕投射到某个地方，我会选择这个库。</p><p id="f0be" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">在尝试了不同的可以提供截图功能的库之后，我了解到它们中的大多数都使用了相同的方法。每次抓取屏幕时，都会重新建立与屏幕资源的“连接”。到目前为止，我没有深入研究这一部分，我只能说我们在重建上花了太多时间。同时，MSS针对任何操作系统进行了优化。当你抓取一个屏幕时，它使用XGetImage方法从已经创建的“连接”到你的屏幕资源<em class="nq">。</em>这意味着，你可以用<code class="fe ns nt nu nv b">with</code>语句初始化MSS实例，让你的游戏在那里循环，你会得到更好的性能。</p><pre class="ld le lf lg gt nw nv nx ny aw nz bi"><span id="2e45" class="mq lt iq nv b gy oa ob l oc od">with mss.mss() as sct:<br/>  while True:<br/>    screen = sct.grab(monitor)<br/>    process_image(screen)<br/>    if trigger_to_leave:<br/>      break</span></pre><p id="7041" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">是的，就这么简单。这样你抓取一个屏幕的速度可以提高几百倍。在这里，我实现了以100帧/秒的速度获取截图，我甚至添加了一个睡眠来减少多余的计算。接下来，我们需要处理图像，分析所有块，并在需要时“跳转”。<br/>我把这个分成两部分:</p><ol class=""><li id="06c1" class="nc nd iq ki b kj kk km kn kp oe kt of kx og lb oh ni nj nk bi translated">在屏幕上找到一只恐龙，并探测一个有“障碍物”的区域</li><li id="3b6a" class="nc nd iq ki b kj nl km nm kp nn kt no kx np lb oh ni nj nk bi translated">使用上一步得到的区域，循环抓取，计算到障碍物的距离，并计算速度。</li></ol><p id="c5e0" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">让我们回顾一下这些步骤。</p><h2 id="a202" class="mq lt iq bd lu mr ms dn ly mt mu dp mc kp mv mw me kt mx my mg kx mz na mi nb bi translated">在屏幕上找到一只恐龙，并探测一个有“障碍物”的区域</h2><p id="02fb" class="pw-post-body-paragraph kg kh iq ki b kj mk jr kl km ml ju ko kp mm kr ks kt mn kv kw kx mo kz la lb ij bi translated">这一部分在我的GitHub上的一个Jupyter笔记本中进行了可视化的呈现:<a class="ae mp" href="https://github.com/dperyel/run-dino-run/blob/master/search.ipynb" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/dper Yel/run-dino-run/blob/master/search . ipynb</a></p><p id="cc6f" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">此时我广泛使用OpenCV进行图像处理、模板匹配、边缘检测。首先，我消除了图像中的颜色通道，并且通过用<code class="fe ns nt nu nv b">cv2.cvtColot(img, cv2.COLOR_BRG2GRAY)</code>变换图像只使用了一个通道。然后我需要消除白天和黑夜的区别。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi oi"><img src="../Images/2a385b2069cc25a67d7af9487d31c8ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9P-bTMuwHdY3X2NwdSLkTA.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">白天从左边，夜晚从右边</p></figure><p id="7eae" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">对此我们能做些什么？事实上，有许多方法可以接近，我决定使用一个<a class="ae mp" href="https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_canny/py_canny.html" rel="noopener ugc nofollow" target="_blank"> Canny算法</a>来检测边缘，并使用最大和最小阈值的极值。它让我在白天和晚上都能得到几乎相同的画面。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi oj"><img src="../Images/7b16c8a875f50c61ee887147ece6f862.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*luRcap8WJ5GeQj3qmQcOqA.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">白天从左边，夜晚从右边</p></figure><p id="2699" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">当然，如果一幅图像有很多噪声，我需要先模糊它，但在这种特殊情况下，只需找到边缘就足够了。而且我擅长用<a class="ae mp" href="https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_template_matching/py_template_matching.html" rel="noopener ugc nofollow" target="_blank">模板匹配</a>来找迪诺。唯一的事情是模板不会在比赛中缩放。我们的恐龙模板应该取自游戏将要运行的屏幕。或者您可以扩展此功能，并使用模板缩放来执行模板匹配。</p><p id="7223" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">通过使用<code class="fe ns nt nu nv b">cv2.matchTemplate</code>我得到了匹配的位置。最初你会得到一堆位置，因为当OpenCV在源图像上滑动模板时，它会比较这个区域，然后你会得到一个匹配的值。匹配值表示像素匹配的精确程度。在我的例子中，我只寻找1个恐龙，这意味着我可以取最高值，并使用映射到该值的位置。</p><pre class="ld le lf lg gt nw nv nx ny aw nz bi"><span id="3965" class="mq lt iq nv b gy oa ob l oc od">match_res = cv2.matchTemplate(canny_night, dino_bordered_template, cv2.TM_CCOEFF_NORMED)<br/>_, max_val, _, max_loc = cv2.minMaxLoc(match_res)</span></pre><p id="3558" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">我的max_val平均为0.81，这意味着我的模板在图像上的匹配率为81%。好到可以继续。</p><p id="9218" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">知道了恐龙的位置，我们就可以突出显示障碍物出现的区域。我选择没有其他噪音只有障碍物可见的部分。需要对仙人掌和鸟类等障碍物进行分组。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi ok"><img src="../Images/4e068ce9deb932d1440a86288d695d00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WKR95st5wgXsdnTfxxFq2Q.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">蓝色矩形代表我需要在每一帧上查看的区域</p></figure><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi ol"><img src="../Images/5c0cdec4ef1fcd65fc2108cc47b1905a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0m7DJJJ4qKTzKxC5vM3Xqg.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">需要关注的区域。用边缘检测对图像进行后处理。</p></figure><p id="5443" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">要进行分组并不太难，因为本质上，我有一个矩阵(图像)，其中每个单元有两个值<code class="fe ns nt nu nv b">0</code>或<code class="fe ns nt nu nv b">255</code>，有点不规范的二进制矩阵。我需要从左边找到至少有一个像素值为<code class="fe ns nt nu nv b">255</code>的组的位置。为此，我通过X轴在画布上迭代，步长定义了“障碍物”之间的最小距离。每个组代表一个元组，该元组具有距组左侧的位置和宽度。当我找到所有组时，我从左边修剪结果以知道“障碍”的确切边缘。这是简化光流的未来部分所需要的。还值得一提的是，因为步长值是常数，这种方法的复杂性是线性的<code class="fe ns nt nu nv b">O(n+k)</code>，其中<code class="fe ns nt nu nv b">n</code>是画布的宽度，<code class="fe ns nt nu nv b">k</code>是“障碍”的数量。这还不算太糟糕，因为我需要对每一帧进行计算，并且关心这里的性能。下面你可以看到分组是如何工作的。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi om"><img src="../Images/e9336d80732de45929b54ebaef844c0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*rpOJJSvma8MuFZETNkTILg.gif"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">“障碍”如何分组的可视化表示。来源:作者</p></figure><p id="99d6" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">现在我有一切可以切换到下一步。</p><h2 id="a36a" class="mq lt iq bd lu mr ms dn ly mt mu dp mc kp mv mw me kt mx my mg kx mz na mi nb bi translated">通过速度计算使恐龙奔跑和跳跃</h2><p id="d23b" class="pw-post-body-paragraph kg kh iq ki b kj mk jr kl km ml ju ko kp mm kr ks kt mn kv kw kx mo kz la lb ij bi translated">找到恐龙并开始游戏循环的运行脚本位于下一个文件:<a class="ae mp" href="https://github.com/dperyel/run-dino-run/blob/master/run.py" rel="noopener ugc nofollow" target="_blank">https://github.com/dperyel/run-dino-run/blob/master/run.py</a></p><p id="f593" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">好的，我要说最复杂的部分已经在第一部分完成了。现在我们至少知道了到第一个“障碍”的距离，如果“危险”物体太近，可以使用<code class="fe ns nt nu nv b">pyautogui.press('space')</code>。问题是游戏改变了速度。迪诺越跑越快。我的第一个想法是使用光流和<a class="ae mp" href="https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_video/py_lucas_kanade/py_lucas_kanade.html#lucas-kanade-optical-flow-in-opencv" rel="noopener ugc nofollow" target="_blank"> Lucas-Kanade算法</a>来比较前一帧和当前帧。当我得到像素偏差时，我可以计算速度。它会工作，唯一的事情是我已经有我需要的一切。我的“障碍”组代表了我需要注意的特征，我可以存储前一帧的状态以找到我需要的偏差。<strong class="ki ir"> <em class="nq">当我避免使用复杂的算法时，我总是感到轻松，并通过做几个“加和减”</em> </strong> (-:</p><p id="fa56" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">通过知道一个速度，找到一个依赖关系是一个数学(或时间)问题，这个依赖关系是你需要从一个“障碍”的距离来触发一个“跳跃”。这是一个结果。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="on oo l"/></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">结果，迪诺没日没夜地跑，如果有仙人掌或鸟靠近，它就会跳起来。来源:作者</p></figure><h2 id="ea69" class="mq lt iq bd lu mr ms dn ly mt mu dp mc kp mv mw me kt mx my mg kx mz na mi nb bi translated">结论</h2><p id="60fd" class="pw-post-body-paragraph kg kh iq ki b kj mk jr kl km ml ju ko kp mm kr ks kt mn kv kw kx mo kz la lb ij bi translated">计算机视觉是许多自动化过程的重要组成部分。正如你在这个小例子中看到的，你甚至可以通过让一台机器找到敏感部分来对一个游戏进行完整的端到端测试。</p><p id="235f" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">尝试不同的库来比较性能是一个好主意。在我的例子中，当PyAutoGUI仍然用于其他副作用时，MSS在屏幕捕捉方面是绝对的赢家。</p><p id="9a52" class="pw-post-body-paragraph kg kh iq ki b kj kk jr kl km kn ju ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated"><strong class="ki ir">附言:</strong>所有源码都放在我的GitHub上<a class="ae mp" href="https://github.com/dperyel/run-dino-run" rel="noopener ugc nofollow" target="_blank">https://github.com/dperyel/run-dino-run</a><br/>回购使用git LFS存储所有二进制文件。为了让脚本工作，你需要从你的显示器上截取一个<code class="fe ns nt nu nv b">assets/dino_crop.png</code>的截图，或者做一个模板缩放(-；<br/>代码可能包含bug，因为它主要是像概念验证一样完成的。<br/>欢迎在下面评论或提问。</p></div></div>    
</body>
</html>