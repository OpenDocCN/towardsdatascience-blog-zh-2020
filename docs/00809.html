<html>
<head>
<title>Time-Series Prediction Beyond Test Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">超越测试数据的时间序列预测</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/time-series-prediction-beyond-test-data-3f4625019fd9?source=collection_archive---------3-----------------------#2020-01-23">https://towardsdatascience.com/time-series-prediction-beyond-test-data-3f4625019fd9?source=collection_archive---------3-----------------------#2020-01-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="89f0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">许多(如果不是全部的话)与时间序列预测相关的例子仅用于测试数据，缺乏如何预测真实未来日期的例子。这个简单的例子展示了如何在测试数据集之外进行预测。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0e13af9f24c9b3d1091a9d3649150c34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WC3LutLauArIfyFPXAE7Sg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:Pixabay</p></figure><p id="cf88" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我当时的任务是构建一个大规模时间序列预测解决方案。我最终在单一解决方案中使用了多种方法的组合——预言家、ARIMA和LSTM神经网络(运行在Keras/TensorFlow之上)。使用Prophet ( <a class="ae lu" rel="noopener" target="_blank" href="/serving-prophet-model-with-flask-predicting-future-1896986da05f">用Flask提供Prophet模型—预测未来</a>)和ARIMA可以直接计算未来日期的预测，两者都提供了返回给定未来范围的预测的函数。如果你是新手，LSTM的情况就不一样了——这将需要大量的时间来研究如何预测真实的未来日期(大多数例子只展示了如何根据测试数据集进行预测)。</p><p id="afeb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我发现了一个很好的例子，它帮助我解决了我的任务——<a class="ae lu" href="https://medium.com/swlh/a-quick-example-of-time-series-forecasting-using-long-short-term-memory-lstm-networks-ddc10dc1467d" rel="noopener">一个使用长短期记忆(LSTM)网络</a>进行时间序列预测的快速例子。在这篇文章中，我将展示如何预测洗发水销售月度数据，主要基于上面例子中的代码。</p><p id="a9d9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">可以从Kaggle下载一个包含洗发水月销售数据的<a class="ae lu" href="https://www.kaggle.com/guangningyu/sales-of-shampoo" rel="noopener ugc nofollow" target="_blank">数据集</a>。</p><p id="ed8b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">LSTM模型是用TensorFlow 2.0和Keras建立的。</p><p id="c04b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，我们需要获取和解析时间序列数据:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="532c" class="ma mb it lw b gy mc md l me mf">def parser(x):<br/>    return pd.datetime.strptime('190'+x, '%Y-%m')</span><span id="0a93" class="ma mb it lw b gy mg md l me mf">df = pd.read_csv('shampoo.csv', parse_dates=[0], index_col=0, date_parser=parser)<br/>df.tail()</span></pre><p id="8bc2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于LSTM模型训练，必须对数据进行缩放，这是通过来自<em class="mh"> sklearn </em>库的MinMaxScaler完成的:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="f0c8" class="ma mb it lw b gy mc md l me mf">train = df</span><span id="bc14" class="ma mb it lw b gy mg md l me mf">scaler = MinMaxScaler()<br/>scaler.fit(train)<br/>train = scaler.transform(train)</span></pre><p id="2fa2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">时间序列预测是一项序列预测任务。日期对于ML算法来说并不重要，它试图识别过去和未来数据之间的依赖模式。有许多方法可以将原始序列数据转换成适合LSTM神经网络训练的数据。我更喜欢使用Keras TimeseriesGenerator(在这里阅读更多信息— <a class="ae lu" href="https://machinelearningmastery.com/how-to-use-the-timeseriesgenerator-for-time-series-forecasting-in-keras/" rel="noopener ugc nofollow" target="_blank">如何在Keras </a>中使用TimeseriesGenerator进行时间序列预测)。我们将预测12个月的洗发水销售额，因为这将使用过去12个月的时间窗口来确定预测:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="698c" class="ma mb it lw b gy mc md l me mf">n_input = 12<br/>n_features = 1<br/>generator = TimeseriesGenerator(train, train, length=n_input, batch_size=6)</span></pre><p id="76db" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">LSTM模特培训。对于输入和目标，我们将使用整个时间序列数据集，模型将在整个数据集上进行训练。这将允许为训练集中可用的最后日期之后的日期生成预测:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="4c5b" class="ma mb it lw b gy mc md l me mf">model = Sequential()<br/>model.add(LSTM(200, activation='relu', input_shape=(n_input, n_features)))<br/>model.add(Dropout(0.15))<br/>model.add(Dense(1))</span><span id="e660" class="ma mb it lw b gy mg md l me mf">optimizer = keras.optimizers.Adam(learning_rate=0.001)<br/>model.compile(optimizer=optimizer, loss='mse')</span><span id="3719" class="ma mb it lw b gy mg md l me mf">history = model.fit_generator(generator,epochs=100,verbose=1)</span></pre><p id="cad5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦模型训练完毕，我们就可以生成未来日期的预测。这里的想法是——使用最近的12个步骤，为未来的一个步骤生成一个预测。向数组中添加新的预测，从同一数组中删除第一个条目，并用12步的更新数组预测下一步。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="543f" class="ma mb it lw b gy mc md l me mf">pred_list = []</span><span id="8514" class="ma mb it lw b gy mg md l me mf">batch = train[-n_input:].reshape((1, n_input, n_features))</span><span id="4796" class="ma mb it lw b gy mg md l me mf">for i in range(n_input):   <br/>    pred_list.append(model.predict(batch)[0]) <br/>    batch = np.append(batch[:,1:,:],[[pred_list[i]]],axis=1)</span></pre><p id="c35a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">创建包含未来月份的数据框，我们将为这些月份分配计算的预测数据:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="35c4" class="ma mb it lw b gy mc md l me mf">add_dates = [df.index[-1] + DateOffset(months=x) for x in range(0,13) ]<br/>future_dates = pd.DataFrame(index=add_dates[1:],columns=df.columns)</span></pre><p id="0b2e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">创建包含日期和预测数据的数据框。最后，与训练数据框架合并，以绘制显示训练数据和真实未来预测的图表:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="dfb4" class="ma mb it lw b gy mc md l me mf">df_predict = pd.DataFrame(scaler.inverse_transform(pred_list),<br/>                          index=future_dates[-n_input:].index, columns=['Prediction'])</span><span id="a187" class="ma mb it lw b gy mg md l me mf">df_proj = pd.concat([df,df_predict], axis=1)</span></pre><p id="669c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">结果显示为Plotly:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="62a6" class="ma mb it lw b gy mc md l me mf">plot_data = [<br/>    go.Scatter(<br/>        x=df_proj.index,<br/>        y=df_proj['Sales'],<br/>        name='actual'<br/>    ),<br/>    go.Scatter(<br/>        x=df_proj.index,<br/>        y=df_proj['Prediction'],<br/>        name='prediction'<br/>    )<br/>]</span><span id="c222" class="ma mb it lw b gy mg md l me mf">plot_layout = go.Layout(<br/>        title='Shampoo sales prediction'<br/>    )<br/>fig = go.Figure(data=plot_data, layout=plot_layout)<br/>pyoff.iplot(fig)</span></pre><p id="ff97" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">预测的真实未来销售额，以黄色显示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mi"><img src="../Images/2ccd60f408c852cf1817f98e940795b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uahqYXFf5IafdkcwMyPpvQ.png"/></div></div></figure><p id="e289" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">源代码可以在<a class="ae lu" href="https://github.com/abaranovskis-redsamurai/automation-repo/tree/master/forecast-lstm" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。</p></div></div>    
</body>
</html>