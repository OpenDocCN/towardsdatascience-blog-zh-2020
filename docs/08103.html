<html>
<head>
<title>YOLO v3 Object Detection with Keras</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Keras 进行 YOLO v3 目标检测</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/yolo-v3-object-detection-with-keras-461d2cfccef6?source=collection_archive---------12-----------------------#2020-06-15">https://towardsdatascience.com/yolo-v3-object-detection-with-keras-461d2cfccef6?source=collection_archive---------12-----------------------#2020-06-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/26ed354d151943cf69b361759267d14d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vISVnk-prof925j3f1ZDDQ.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片由作者说明</p></figure><div class=""/><div class=""><h2 id="afca" class="pw-subtitle-paragraph kf jh ji bd b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dk translated">用 Keras 实现简单解释 YOLO v3</h2></div><figure class="kx ky kz la gt iv"><div class="bz fp l di"><div class="lb lc l"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">视频由 YOLO 作者，<br/>约瑟夫·雷德蒙</p></figure><p id="70fd" class="pw-post-body-paragraph ld le ji lf b lg lh kj li lj lk km ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf jj">关于 YOLO v3 算法</strong></p><p id="85e0" class="pw-post-body-paragraph ld le ji lf b lg lh kj li lj lk km ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">“你只看一次”(YOLO)是一种对象检测算法，以其高准确性而闻名，同时由于其速度检测，它也能够实时运行。与之前的算法不同，第三个版本通过简单地改变模型的大小，在不需要重新训练的情况下，促进了速度和准确性之间的有效折衷。</p><p id="2ed9" class="pw-post-body-paragraph ld le ji lf b lg lh kj li lj lk km ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在我们开始用 YOLO v3 实现对象检测之前，我们需要下载<a class="ae lz" href="https://pjreddie.com/media/files/yolov3.weights" rel="noopener ugc nofollow" target="_blank">预训练模型权重</a>。下载这个可能需要一段时间，所以你可以在等待的时候准备你的咖啡。YOLO v3 是用 c 语言的开源神经网络 DarkNet framework 编写的，这让我一开始就感到很害怕。</p><p id="94dd" class="pw-post-body-paragraph ld le ji lf b lg lh kj li lj lk km ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">但值得庆幸的是，这段代码受到了 experiencor 的 keras-yolo3 projec 的强烈启发，它使用 keras 执行 YOLO v3 模型。在整个实现过程中，我将在 Google Colab 上运行它。此外，我们将使用这些可爱的狗图像进行对象检测。</p><figure class="kx ky kz la gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ma"><img src="../Images/535666dabf45cee2706c67e277f6a40d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*x0NBikuerYc6Eoh2"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae lz" href="https://unsplash.com/@alvannee?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Alvan Nee </a>在<a class="ae lz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="2411" class="pw-post-body-paragraph ld le ji lf b lg lh kj li lj lk km ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">所以让我们把手弄脏吧！！</p><p id="d133" class="pw-post-body-paragraph ld le ji lf b lg lh kj li lj lk km ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf jj">第一步:</strong></p><p id="2564" class="pw-post-body-paragraph ld le ji lf b lg lh kj li lj lk km ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">跳到第一步，下面是必要的库和依赖项。</p><figure class="kx ky kz la gt iv"><div class="bz fp l di"><div class="mb lc l"/></div></figure><p id="71d9" class="pw-post-body-paragraph ld le ji lf b lg lh kj li lj lk km ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf jj">第二步:</strong></p><p id="6aa9" class="pw-post-body-paragraph ld le ji lf b lg lh kj li lj lk km ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">接下来，<code class="fe mc md me mf b"><strong class="lf jj">WeightReader</strong></code> <strong class="lf jj"> </strong>类用于解析“yolov3。权重”文件并将模型权重加载到内存中。</p><figure class="kx ky kz la gt iv"><div class="bz fp l di"><div class="mb lc l"/></div></figure><p id="9adb" class="pw-post-body-paragraph ld le ji lf b lg lh kj li lj lk km ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf jj">第三步:</strong></p><p id="db73" class="pw-post-body-paragraph ld le ji lf b lg lh kj li lj lk km ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">YOLO v3 使用了新的网络来执行特征提取，不可否认，与 YOLO v2 相比，它的规模更大。这个网络被称为 Darknet-53，因为整个网络由 53 个具有快捷连接的卷积层组成<a class="ae lz" href="https://pjreddie.com/media/files/papers/YOLOv3.pdf" rel="noopener ugc nofollow" target="_blank"> (Redmon &amp;法尔哈迪，2018) </a>。</p><figure class="kx ky kz la gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mg"><img src="../Images/762598ca5d6b29840f2069e01234a36d.png" data-original-src="https://miro.medium.com/v2/resize:fit:582/format:webp/1*O-KQMRsZMjNbjEIpcl8nGQ.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">YOLO v3 网络有 53 个卷积层<a class="ae lz" href="https://pjreddie.com/media/files/papers/YOLOv3.pdf" rel="noopener ugc nofollow" target="_blank">(雷德蒙&amp;法尔哈迪，2018) </a></p></figure><p id="2ad2" class="pw-post-body-paragraph ld le ji lf b lg lh kj li lj lk km ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">因此，下面的代码由几个组件组成，它们是:</p><ul class=""><li id="ec70" class="mh mi ji lf b lg lh lj lk lm mj lq mk lu ml ly mm mn mo mp bi translated"><code class="fe mc md me mf b"><strong class="lf jj">_conv_block</strong></code>用于构建卷积层的函数</li><li id="2177" class="mh mi ji lf b lg mq lj mr lm ms lq mt lu mu ly mm mn mo mp bi translated"><code class="fe mc md me mf b"><strong class="lf jj">make_yolov3_model</strong></code>用于创建卷积层并将其堆叠在一起作为一个整体的功能。</li></ul><figure class="kx ky kz la gt iv"><div class="bz fp l di"><div class="mb lc l"/></div></figure><p id="ab8b" class="pw-post-body-paragraph ld le ji lf b lg lh kj li lj lk km ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf jj">第四步:</strong></p><p id="aed0" class="pw-post-body-paragraph ld le ji lf b lg lh kj li lj lk km ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">接下来，下面的代码解释如下:</p><ul class=""><li id="4da9" class="mh mi ji lf b lg lh lj lk lm mj lq mk lu ml ly mm mn mo mp bi translated">定义 YOLO v3 模型</li><li id="0db3" class="mh mi ji lf b lg mq lj mr lm ms lq mt lu mu ly mm mn mo mp bi translated">加载您之前下载的预训练重量</li><li id="605d" class="mh mi ji lf b lg mq lj mr lm ms lq mt lu mu ly mm mn mo mp bi translated">使用 Keras <code class="fe mc md me mf b">save</code>函数并指定文件名保存模型</li></ul><figure class="kx ky kz la gt iv"><div class="bz fp l di"><div class="mb lc l"/></div></figure><p id="33c1" class="pw-post-body-paragraph ld le ji lf b lg lh kj li lj lk km ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf jj">第四步:</strong></p><p id="661f" class="pw-post-body-paragraph ld le ji lf b lg lh kj li lj lk km ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">该步骤包括将预测输出解码成边界框</p><p id="98ae" class="pw-post-body-paragraph ld le ji lf b lg lh kj li lj lk km ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">YOLO v3 预测的输出是难以解释的数组列表的形式。因为 YOLO v3 是多尺度检测，所以它被解码成(13，13，225)、(26，26，225)和(52，52，225)形状的三个不同尺度</p><figure class="kx ky kz la gt iv gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/a9933de3f57424f4b89fe77144fe89b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1336/format:webp/1*rrX6sLSfQnMgvlbMEzncsA.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">解码前的 YOLOv3 预测输出片段</p></figure><figure class="kx ky kz la gt iv gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/d76fb67094e9e15abd767b08e8be0a4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*nMPCG4yGCI90qyo_ytWonw.png"/></div></figure><ul class=""><li id="31c9" class="mh mi ji lf b lg lh lj lk lm mj lq mk lu ml ly mm mn mo mp bi translated"><code class="fe mc md me mf b"><strong class="lf jj">decode_netout</strong></code>函数用于将预测输出解码成方框</li></ul><figure class="kx ky kz la gt iv"><div class="bz fp l di"><div class="mb lc l"/></div></figure><p id="36df" class="pw-post-body-paragraph ld le ji lf b lg lh kj li lj lk km ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">简而言之，这就是<code class="fe mc md me mf b"><strong class="lf jj">decode_netout</strong></code>函数的工作方式，如下图所示:</p><figure class="kx ky kz la gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/26ed354d151943cf69b361759267d14d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vISVnk-prof925j3f1ZDDQ.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片由作者说明</p></figure><p id="2dbc" class="pw-post-body-paragraph ld le ji lf b lg lh kj li lj lk km ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf jj">第五步:</strong></p><p id="a8fe" class="pw-post-body-paragraph ld le ji lf b lg lh kj li lj lk km ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">缩放和拉伸解码后的框以适合原始图像形状</p><figure class="kx ky kz la gt iv"><div class="bz fp l di"><div class="mb lc l"/></div></figure><p id="5dfb" class="pw-post-body-paragraph ld le ji lf b lg lh kj li lj lk km ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf jj">第六步:</strong>网络输出解码后，不会直接对物体显示平滑预测。解码后的盒子产生了几个重叠的盒子。从下图可以看出，模型已经检测到图像中有三只狗。然而，它仅仅是一个物体上重叠的盒子，在这个例子中是可爱的柯基。</p><figure class="kx ky kz la gt iv gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/51981609ac7583d32b96a5569234c304.png" data-original-src="https://miro.medium.com/v2/resize:fit:658/format:webp/1*T516c2Yn_vRU9Qeo65hEKA.png"/></div></figure><p id="85fc" class="pw-post-body-paragraph ld le ji lf b lg lh kj li lj lk km ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">因此，发生非最大抑制(NMS)来滤除以便获得正确的框</p><ul class=""><li id="7517" class="mh mi ji lf b lg lh lj lk lm mj lq mk lu ml ly mm mn mo mp bi translated"><code class="fe mc md me mf b"><strong class="lf jj">bbox_iou</strong></code>函数用于通过获取两个盒子的<code class="fe mc md me mf b"><strong class="lf jj">_interval_overlap</strong></code>来计算 IOU(交集/并集)</li></ul><figure class="kx ky kz la gt iv gh gi paragraph-image"><div class="gh gi my"><img src="../Images/17832a6b86d4462fbcfa4d8cb11c403b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1110/format:webp/1*HMEljtnTcNBikA-5uZ1bnQ.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自 DeepLearning.ai 课程</p></figure><ul class=""><li id="9dc9" class="mh mi ji lf b lg lh lj lk lm mj lq mk lu ml ly mm mn mo mp bi translated"><code class="fe mc md me mf b"><strong class="lf jj">do_nms</strong></code> <strong class="lf jj"> </strong>功能用于执行 NMS</li></ul><p id="6479" class="pw-post-body-paragraph ld le ji lf b lg lh kj li lj lk km ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">一般来说，NMS 是这样表演的:</p><ol class=""><li id="972e" class="mh mi ji lf b lg lh lj lk lm mj lq mk lu ml ly mz mn mo mp bi translated">选择得分最高的方框。</li><li id="a667" class="mh mi ji lf b lg mq lj mr lm ms lq mt lu mu ly mz mn mo mp bi translated">计算此框与其他框的区间重叠，省略重叠明显的框(iou &gt;= <code class="fe mc md me mf b">iou_threshold</code>)。</li><li id="c33a" class="mh mi ji lf b lg mq lj mr lm ms lq mt lu mu ly mz mn mo mp bi translated">重复步骤 1 并重复，直到没有比当前选择的盒子分数更低的盒子。</li></ol><p id="daca" class="pw-post-body-paragraph ld le ji lf b lg lh kj li lj lk km ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这将忽略与所选框有大量重叠的所有框。只剩下“正确”框。</p><figure class="kx ky kz la gt iv gh gi paragraph-image"><div class="gh gi na"><img src="../Images/47cebb03361cd039a6fdd6c226544a5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/1*XGtnjDotXe4B-xwDChCx8Q.png"/></div></figure><ul class=""><li id="801a" class="mh mi ji lf b lg lh lj lk lm mj lq mk lu ml ly mm mn mo mp bi translated"><code class="fe mc md me mf b"><strong class="lf jj">get_boxes</strong></code>函数用于获取通过 NMS 滤波器选择的盒子</li><li id="dbba" class="mh mi ji lf b lg mq lj mr lm ms lq mt lu mu ly mm mn mo mp bi translated"><code class="fe mc md me mf b"><strong class="lf jj">draw_boxes</strong></code>函数用于使用<code class="fe mc md me mf b">matplotlib.patches.Rectangle</code>类给输入图像绘制一个矩形框</li></ul><figure class="kx ky kz la gt iv"><div class="bz fp l di"><div class="mb lc l"/></div></figure><p id="9d82" class="pw-post-body-paragraph ld le ji lf b lg lh kj li lj lk km ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf jj">第七步:</strong></p><p id="b501" class="pw-post-body-paragraph ld le ji lf b lg lh kj li lj lk km ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们即将结束 YOLO v3 的实施。在这一步，我们必须声明几个配置，它们是:</p><ul class=""><li id="e54e" class="mh mi ji lf b lg lh lj lk lm mj lq mk lu ml ly mm mn mo mp bi translated"><code class="fe mc md me mf b"><strong class="lf jj">anchors</strong></code> <strong class="lf jj"> : </strong>根据对 COCO 数据集中对象大小的分析精心选择。</li><li id="b123" class="mh mi ji lf b lg mq lj mr lm ms lq mt lu mu ly mm mn mo mp bi translated"><code class="fe mc md me mf b"><strong class="lf jj">class_threshold</strong></code>:检测对象的概率阈值</li><li id="edc4" class="mh mi ji lf b lg mq lj mr lm ms lq mt lu mu ly mm mn mo mp bi translated"><code class="fe mc md me mf b"><strong class="lf jj">labels</strong></code>:COCO 数据集中的类标签</li></ul><figure class="kx ky kz la gt iv"><div class="bz fp l di"><div class="mb lc l"/></div></figure><p id="5a13" class="pw-post-body-paragraph ld le ji lf b lg lh kj li lj lk km ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf jj">第七步:</strong></p><p id="caad" class="pw-post-body-paragraph ld le ji lf b lg lh kj li lj lk km ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">最后，YOLO 模型准备进行预测，下面的代码允许用户输入图像来检测对象。</p><figure class="kx ky kz la gt iv"><div class="bz fp l di"><div class="mb lc l"/></div></figure><p id="bdae" class="pw-post-body-paragraph ld le ji lf b lg lh kj li lj lk km ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">输出:</p><figure class="kx ky kz la gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nb"><img src="../Images/7a44bbaf84d0a48e988e93c365f3e578.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PUpAlr_fOyQdmoFYHZghxg.png"/></div></div></figure><h2 id="5255" class="nc nd ji bd ne nf ng dn nh ni nj dp nk lm nl nm nn lq no np nq lu nr ns nt nu bi translated">结论</h2><p id="26f0" class="pw-post-body-paragraph ld le ji lf b lg nv kj li lj nw km ll lm nx lo lp lq ny ls lt lu nz lw lx ly im bi translated">总之，YOLOv3 是一个强大的对象检测模型，以快速检测和准确预测而闻名。在本文结束时，我真的希望这篇文章能让你更好地理解 YOLO 算法的工作原理，并在 Keras 中实现它。完整的代码可以在<a class="ae lz" href="https://github.com/christienatashiaarchie/YOLOv3-Object-Detection/tree/master" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p><p id="7eed" class="pw-post-body-paragraph ld le ji lf b lg lh kj li lj lk km ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">此外，在我的整个旅程中，我想对<a class="ae lz" href="https://github.com/experiencor" rel="noopener ugc nofollow" target="_blank"> Huynh Ngoc Anh </a>和<a class="ae lz" href="https://machinelearningmastery.com/about/" rel="noopener ugc nofollow" target="_blank"> Jason Brownlee </a>大声疾呼，深入了解 YOLOv3 的工作原理并将其应用到 Keras 中。另外，你可以在这里找到 YOLOv3 论文<a class="ae lz" href="https://pjreddie.com/media/files/papers/YOLOv3.pdf" rel="noopener ugc nofollow" target="_blank"/>。</p><h2 id="4591" class="nc nd ji bd ne nf ng dn nh ni nj dp nk lm nl nm nn lq no np nq lu nr ns nt nu bi translated">参考</h2><div class="is it gp gr iu oa"><a rel="noopener follow" target="_blank" href="/dive-really-deep-into-yolo-v3-a-beginners-guide-9e3d2666280e"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd jj gy z fp of fr fs og fu fw jh bi translated">深入了解 YOLO v3:初学者指南</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">针对初学者的 TensorFlow 2 中 YOLO v3 的详细回顾和实践。</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">towardsdatascience.com</p></div></div><div class="oj l"><div class="ok l ol om on oj oo ja oa"/></div></div></a></div><div class="is it gp gr iu oa"><a href="https://github.com/experiencor/keras-yolo3" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd jj gy z fp of fr fs og fu fw jh bi translated">experiencor/Keras-yolo3</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">要安装依赖项，请运行 pip install -r requirements.txt，为了让 GPU 工作，请确保您已经安装了…</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">github.com</p></div></div><div class="oj l"><div class="op l ol om on oj oo ja oa"/></div></div></a></div><div class="is it gp gr iu oa"><a href="https://machinelearningmastery.com/how-to-perform-object-detection-with-yolov3-in-keras/" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd jj gy z fp of fr fs og fu fw jh bi translated">如何在 Keras 中使用 YOLOv3 执行对象检测-机器学习掌握</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">目标检测是计算机视觉中的一项任务，涉及识别一个或多个目标的存在、位置和类型</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">machinelearningmastery.com</p></div></div><div class="oj l"><div class="oq l ol om on oj oo ja oa"/></div></div></a></div></div></div>    
</body>
</html>