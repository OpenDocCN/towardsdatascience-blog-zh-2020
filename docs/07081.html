<html>
<head>
<title>How I Taught Myself Linked Lists</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我是如何自学链表的</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-i-taught-myself-linked-lists-72c4837ea721?source=collection_archive---------12-----------------------#2020-05-31">https://towardsdatascience.com/how-i-taught-myself-linked-lists-72c4837ea721?source=collection_archive---------12-----------------------#2020-05-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="193f" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">数据结构和算法，但更简单</h2><div class=""/><div class=""><h2 id="94b5" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">一部分一部分地分解链表的定义。</h2></div><h1 id="54d0" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">什么是链表？</h1><p id="cdcd" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">链表是最简单和最常见的数据结构之一。如果您曾经试图学习更多关于基本数据结构的知识，很可能您已经遇到过链表，并且读过类似下面的定义:</p><blockquote class="mf mg mh"><p id="3c2e" class="lj lk mi ll b lm mj kd lo lp mk kg lr ml mm lu lv mn mo ly lz mp mq mc md me im bi translated">链表是一种数据结构，其中对象以线性顺序排列。然而，与数组不同，在数组中，线性顺序由数组索引决定，而链表中的顺序由每个对象中的指针决定。</p></blockquote><p id="e248" class="pw-post-body-paragraph lj lk it ll b lm mj kd lo lp mk kg lr ls mm lu lv lw mo ly lz ma mq mc md me im bi translated">根据学习数据结构时的个人经验，以上内容对于初学者来说可能毫无意义。因此，这篇文章旨在向你展示链表在概念上是简单的，以一种直观和外行的方式分解它的定义，就像你是一个完全的初学者一样。</p><p id="b3ce" class="pw-post-body-paragraph lj lk it ll b lm mj kd lo lp mk kg lr ls mm lu lv lw mo ly lz ma mq mc md me im bi translated">我们将离开“那又怎样？”我相信，当我们对链表有了更好的理解后，我们将能够问更有意义的“那又怎样”。请注意，我们将在整篇文章中引用上述定义。</p><p id="ab46" class="pw-post-body-paragraph lj lk it ll b lm mj kd lo lp mk kg lr ls mm lu lv lw mo ly lz ma mq mc md me im bi translated">所以让我们开始吧。</p><h1 id="8a8e" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">什么是数据结构？</h1><blockquote class="mf mg mh"><p id="4dfc" class="lj lk mi ll b lm mj kd lo lp mk kg lr ml mm lu lv mn mo ly lz mp mq mc md me im bi translated">链表是一种数据结构…</p></blockquote><p id="a53e" class="pw-post-body-paragraph lj lk it ll b lm mj kd lo lp mk kg lr ls mm lu lv lw mo ly lz ma mq mc md me im bi translated">因为链表是一种数据结构，所以简单地理解什么是数据结构是有好处的。</p><p id="9d9f" class="pw-post-body-paragraph lj lk it ll b lm mj kd lo lp mk kg lr ls mm lu lv lw mo ly lz ma mq mc md me im bi translated">简单地说，数据结构就是数据存储和组织的方式。</p><p id="5e2a" class="pw-post-body-paragraph lj lk it ll b lm mj kd lo lp mk kg lr ls mm lu lv lw mo ly lz ma mq mc md me im bi translated">然后，根据数据的存储和组织方式，可以对数据应用不同的操作。</p><p id="0bc5" class="pw-post-body-paragraph lj lk it ll b lm mj kd lo lp mk kg lr ls mm lu lv lw mo ly lz ma mq mc md me im bi translated">数据结构之间的区别可能在于数据是如何存储和组织的，可以对数据做什么，或者两者都有。计算机科学中的大量问题都需要某种数据，我们需要根据问题类型从数据中有效地检索信息，这是我们今天创建不同数据结构的动机。</p><p id="e96c" class="pw-post-body-paragraph lj lk it ll b lm mj kd lo lp mk kg lr ls mm lu lv lw mo ly lz ma mq mc md me im bi translated">例如，一个链表在<em class="mi">指针</em>的帮助下以线性顺序存储和组织数据(这就是“数据的组织方式”)，这些指针允许我们轻松地插入和删除元素，而无需重新组织整个数据结构(这就是“能做的”)。这使得一个链表成为一个<em class="mi">线性数据结构</em>(与非线性相对)。</p><h1 id="7356" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated"><strong class="ak">什么是线性顺序？</strong></h1><blockquote class="mf mg mh"><p id="8546" class="lj lk mi ll b lm mj kd lo lp mk kg lr ml mm lu lv mn mo ly lz mp mq mc md me im bi translated">…其中对象以线性顺序排列。</p></blockquote><p id="c13a" class="pw-post-body-paragraph lj lk it ll b lm mj kd lo lp mk kg lr ls mm lu lv lw mo ly lz ma mq mc md me im bi translated">以线性顺序存储元素意味着以连续的顺序组织它们，使得:</p><ul class=""><li id="628a" class="mr ms it ll b lm mj lp mk ls mt lw mu ma mv me mw mx my mz bi translated">只有一个第一个元素，并且只有一个下一个元素</li><li id="8a03" class="mr ms it ll b lm na lp nb ls nc lw nd ma ne me mw mx my mz bi translated">只有最后一个元素，并且只有前一个元素</li><li id="00fe" class="mr ms it ll b lm na lp nb ls nc lw nd ma ne me mw mx my mz bi translated">所有其他元素都有上一个和下一个元素</li></ul><p id="98a6" class="pw-post-body-paragraph lj lk it ll b lm mj kd lo lp mk kg lr ls mm lu lv lw mo ly lz ma mq mc md me im bi translated">例如，除了链表，<em class="mi">数组</em>也是线性数据结构，以线性顺序存储数据。</p><figure class="ng nh ni nj gt nk gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi nf"><img src="../Images/75d224d7e07fc7b5e547550569a2a08e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gE2C1sPZnJewrydSSNKNvw.png"/></div></div><p class="nr ns gj gh gi nt nu bd b be z dk translated">作者绘制的图像。</p></figure><p id="8b2f" class="pw-post-body-paragraph lj lk it ll b lm mj kd lo lp mk kg lr ls mm lu lv lw mo ly lz ma mq mc md me im bi translated">同样，线性还是非线性数据结构更好取决于您的用例。像往常一样，这两种类型各有利弊。</p><h1 id="3a9b" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">好吧，但是数组有什么问题？</h1><blockquote class="mf mg mh"><p id="5867" class="lj lk mi ll b lm mj kd lo lp mk kg lr ml mm lu lv mn mo ly lz mp mq mc md me im bi translated">…但是，与数组不同的是…</p></blockquote><p id="1b1c" class="pw-post-body-paragraph lj lk it ll b lm mj kd lo lp mk kg lr ls mm lu lv lw mo ly lz ma mq mc md me im bi translated">到目前为止，你应该已经注意到链表最常被比作数组。数组的错误(或正确)取决于您的用例。和其他数据结构一样，数组也有自己的优点和缺点。</p><p id="432b" class="pw-post-body-paragraph lj lk it ll b lm mj kd lo lp mk kg lr ls mm lu lv lw mo ly lz ma mq mc md me im bi translated">虽然数组提供非常快速的索引访问和元素赋值，但是它们有固定的、不可变的长度。这意味着它们不能增长或收缩，也不可能追加或插入项目。因此，在创建数组时，我们必须知道我们想要存储多少元素，这可能会导致某些问题，具体取决于手头的问题。</p><p id="3d78" class="pw-post-body-paragraph lj lk it ll b lm mj kd lo lp mk kg lr ls mm lu lv lw mo ly lz ma mq mc md me im bi translated">动态数组(例如 Python 的<strong class="ll jd">列表</strong>)具有可变长度，这是通过保留额外的内存空间来实现的。然而，在动态数组的开头插入一个元素比在末尾插入要昂贵得多。这可能会成为一个巨大的障碍，这也取决于你试图解决的问题。</p><p id="0c31" class="pw-post-body-paragraph lj lk it ll b lm mj kd lo lp mk kg lr ls mm lu lv lw mo ly lz ma mq mc md me im bi translated">使用 Python 的 list 对象，我们可以运行以下代码来说明这一点:</p><pre class="ng nh ni nj gt nv nw nx ny aw nz bi"><span id="57cd" class="oa ks it nw b gy ob oc l od oe">n = 500000<br/>example_list1 = []<br/>example_list2 = []</span><span id="5302" class="oa ks it nw b gy of oc l od oe"># Slow insertion of at the front of Python lists<br/>for i in range(0, n):<br/>    example_list1.insert(0, i)</span><span id="ad2a" class="oa ks it nw b gy of oc l od oe"># Fast insertion of at the end of Python lists<br/>for i in range(0, n):<br/>    example_list2.insert(i, i)</span></pre><p id="c1e0" class="pw-post-body-paragraph lj lk it ll b lm mj kd lo lp mk kg lr ls mm lu lv lw mo ly lz ma mq mc md me im bi translated">记录并打印完全插入 500，000 个元素所需的时间，我们得到:</p><pre class="ng nh ni nj gt nv nw nx ny aw nz bi"><span id="21a5" class="oa ks it nw b gy ob oc l od oe">Insertion at start took: 110.1042 seconds<br/>Insertion at end took: 0.1853 seconds</span></pre><p id="3bb4" class="pw-post-body-paragraph lj lk it ll b lm mj kd lo lp mk kg lr ls mm lu lv lw mo ly lz ma mq mc md me im bi translated">对于动态数组，为了在第一个位置(或第一个索引)插入一个元素，您需要将所有其他元素“向右”移动，以便为这个新元素腾出空间。很自然，你可以想象如果你有一个包含大量元素的数组，这将是非常低效的。此外，在移动元素之前，您可能需要为数组分配更多的内存空间。</p><figure class="ng nh ni nj gt nk gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi og"><img src="../Images/8b7b56c603ffd13ad83928a4f3f6739b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1NvExos0tl9socTNsOW2yQ.png"/></div></div><p class="nr ns gj gh gi nt nu bd b be z dk translated">作者绘制的图像。</p></figure><p id="1cca" class="pw-post-body-paragraph lj lk it ll b lm mj kd lo lp mk kg lr ls mm lu lv lw mo ly lz ma mq mc md me im bi translated">这就是链表可以做得更好的地方。</p><h1 id="e0fe" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">好的，那么链表和数组有什么不同呢？</h1><blockquote class="mf mg mh"><p id="6a14" class="lj lk mi ll b lm mj kd lo lp mk kg lr ml mm lu lv mn mo ly lz mp mq mc md me im bi translated">…链表中的顺序由每个对象中的指针决定。</p></blockquote><p id="1f16" class="pw-post-body-paragraph lj lk it ll b lm mj kd lo lp mk kg lr ls mm lu lv lw mo ly lz ma mq mc md me im bi translated">指针指针指针。</p><p id="d3a8" class="pw-post-body-paragraph lj lk it ll b lm mj kd lo lp mk kg lr ls mm lu lv lw mo ly lz ma mq mc md me im bi translated">尽管链表和数组都是线性数据结构，但链表使用指针保持其元素的线性顺序(与数组中的索引相比)。与使用数组相比，使用指针可以更有效地在任意位置插入或删除节点。</p><p id="32dd" class="pw-post-body-paragraph lj lk it ll b lm mj kd lo lp mk kg lr ls mm lu lv lw mo ly lz ma mq mc md me im bi translated">在其最基本的形式中(即只包含必需的属性)，链表由以下部分组成:</p><ol class=""><li id="a50b" class="mr ms it ll b lm mj lp mk ls mt lw mu ma mv me oh mx my mz bi translated">被称为<strong class="ll jd">节点</strong>的对象，其属性为:(a) <strong class="ll jd">项</strong>，它被分配了它存储的数据<em class="mi">(必需)</em>，(b) <strong class="ll jd">下一个指针</strong>，它指向线性顺序中的下一个节点<em class="mi">(必需)</em>和(c) <strong class="ll jd">上一个指针</strong>，它指向线性顺序中的上一个节点<em class="mi">(非必需)</em>。</li><li id="662e" class="mr ms it ll b lm na lp nb ls nc lw nd ma ne me oh mx my mz bi translated">指向列表头部的指针(必需)</li><li id="9550" class="mr ms it ll b lm na lp nb ls nc lw nd ma ne me oh mx my mz bi translated">指向列表尾部的指针(不是必需的)</li></ol><p id="9880" class="pw-post-body-paragraph lj lk it ll b lm mj kd lo lp mk kg lr ls mm lu lv lw mo ly lz ma mq mc md me im bi translated">为了了解链表如何允许我们有效地在头部和尾部插入对象，我们将实现一个有 3 个节点的链表，以线性顺序保存整数 14、5 和 22 作为数据。每个节点都有一个指向下一个节点的指针，而链表既有一个指向列表头部的指针，又有一个指向列表尾部的指针。</p><figure class="ng nh ni nj gt nk gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi oi"><img src="../Images/bf0e9b9ab7505663864fda36a4014147.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Failms_Mv7tZn65KSV-68A.png"/></div></div><p class="nr ns gj gh gi nt nu bd b be z dk translated">作者绘制的图像。</p></figure><p id="dded" class="pw-post-body-paragraph lj lk it ll b lm mj kd lo lp mk kg lr ls mm lu lv lw mo ly lz ma mq mc md me im bi translated">由于链表中节点的位置存储在前一个节点的指针中，所以链表中的节点不必在内存中连续组织。事实上，它可以存储在内存中的任何地方。因此，它看起来更像这样:</p><figure class="ng nh ni nj gt nk gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi oj"><img src="../Images/096dc73b2acb0f88fa827ad19e51c885.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PlUAq9Ya20QviwfUOzCzrg.png"/></div></div><p class="nr ns gj gh gi nt nu bd b be z dk translated">作者绘制的图像。</p></figure><h2 id="74ec" class="oa ks it bd kt ok ol dn kx om on dp lb ls oo op ld lw oq or lf ma os ot lh iz bi translated">在尾部插入</h2><p id="9c78" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">为了在链表的尾部插入一个整数为 50 的节点，我们执行以下操作:</p><ol class=""><li id="7874" class="mr ms it ll b lm mj lp mk ls mt lw mu ma mv me oh mx my mz bi translated">创建一个新节点，其<strong class="ll jd">项</strong> = 50</li><li id="e48f" class="mr ms it ll b lm na lp nb ls nc lw nd ma ne me oh mx my mz bi translated">让它的<strong class="ll jd">下一个指针</strong>指向<em class="mi">无</em></li><li id="8aa1" class="mr ms it ll b lm na lp nb ls nc lw nd ma ne me oh mx my mz bi translated">让当前尾节点指向这个新节点，而不是<em class="mi"> None </em></li><li id="c20b" class="mr ms it ll b lm na lp nb ls nc lw nd ma ne me oh mx my mz bi translated">重置链表的<strong class="ll jd">尾指针</strong>指向这个新创建的节点</li></ol><figure class="ng nh ni nj gt nk gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi ou"><img src="../Images/2a2560826d493fe24a458f4140a32845.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LDo-pmiNCCVyYJ58OYnR8A.png"/></div></div><p class="nr ns gj gh gi nt nu bd b be z dk translated">作者绘制的图像。</p></figure><h2 id="ad9f" class="oa ks it bd kt ok ol dn kx om on dp lb ls oo op ld lw oq or lf ma os ot lh iz bi translated">在头部插入</h2><p id="5a08" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">类似地，为了在链表的头部添加一个条目，我们执行以下操作:</p><ol class=""><li id="6799" class="mr ms it ll b lm mj lp mk ls mt lw mu ma mv me oh mx my mz bi translated">创建新节点</li><li id="e95c" class="mr ms it ll b lm na lp nb ls nc lw nd ma ne me oh mx my mz bi translated">让它的<strong class="ll jd">下一个指针</strong>指向链表的当前头</li><li id="bf3e" class="mr ms it ll b lm na lp nb ls nc lw nd ma ne me oh mx my mz bi translated">重置链表的<strong class="ll jd">头指针</strong>指向这个新创建的节点</li></ol><p id="27f6" class="pw-post-body-paragraph lj lk it ll b lm mj kd lo lp mk kg lr ls mm lu lv lw mo ly lz ma mq mc md me im bi translated">这本质上是一个最简单形式的链表。</p><h1 id="b9c8" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">那又怎样？</h1><p id="2b1b" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">答应了，那又怎样？</p><p id="57f2" class="pw-post-body-paragraph lj lk it ll b lm mj kd lo lp mk kg lr ls mm lu lv lw mo ly lz ma mq mc md me im bi translated">我们可以看到，与(动态)数组相比，链表的主要优点是它允许快速插入(和移除)条目。与数组不同，不需要重新构建整个数据结构，也不需要为重新构建而重新分配内存。这源于使用指针来保持数据的线性顺序，这消除了数据项以连续方式存储在存储器中的需要。换句话说，链表允许使用固定数量的操作(如上面步骤中所列)来插入和移除项目，而不管列表的长度。</p><p id="acea" class="pw-post-body-paragraph lj lk it ll b lm mj kd lo lp mk kg lr ls mm lu lv lw mo ly lz ma mq mc md me im bi translated">使用节点的这些基本概念，它如何存储数据并指向它的邻居，我们可以根据我们的需要建立其他(更复杂)类型的链表，例如<em class="mi">双向链表</em>和<em class="mi">循环链表</em>。</p><p id="8143" class="pw-post-body-paragraph lj lk it ll b lm mj kd lo lp mk kg lr ls mm lu lv lw mo ly lz ma mq mc md me im bi translated">更令人兴奋的是，理解链表及其节点可以引导我们探索和理解其他数据结构甚至算法。链表是实现其他<a class="ae ov" href="https://en.wikipedia.org/wiki/Abstract_data_type" rel="noopener ugc nofollow" target="_blank">抽象数据类型</a>的多种方式之一，例如<a class="ae ov" href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type)" rel="noopener ugc nofollow" target="_blank">栈</a>、<a class="ae ov" href="https://en.wikipedia.org/wiki/Queue_(abstract_data_type)" rel="noopener ugc nofollow" target="_blank">队列</a>、<a class="ae ov" href="https://en.wikipedia.org/wiki/Hash_table" rel="noopener ugc nofollow" target="_blank">散列表</a>和<a class="ae ov" href="https://en.wikipedia.org/wiki/Graph_(abstract_data_type)" rel="noopener ugc nofollow" target="_blank">图形</a>，我们将在以后的某一天再深入讨论。</p><p id="2425" class="pw-post-body-paragraph lj lk it ll b lm mj kd lo lp mk kg lr ls mm lu lv lw mo ly lz ma mq mc md me im bi translated"><em class="mi">这是上面的单链表在传统教科书中的样子，当然没有颜色:</em></p><figure class="ng nh ni nj gt nk gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi ow"><img src="../Images/94b42b8076b417342606d0f40b0206a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nqgCmK8-sffQ0ZnzzXej7Q.png"/></div></div><p class="nr ns gj gh gi nt nu bd b be z dk translated">作者绘制的图像。</p></figure></div></div>    
</body>
</html>