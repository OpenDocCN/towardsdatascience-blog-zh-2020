<html>
<head>
<title>Part 4: Semantic Segmentation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第4部分:语义分割</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/part-4-semantic-segmentation-b42c3792833d?source=collection_archive---------21-----------------------#2020-06-16">https://towardsdatascience.com/part-4-semantic-segmentation-b42c3792833d?source=collection_archive---------21-----------------------#2020-06-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="aaf1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用STUMPY寻找时间序列状态变化</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9855976ea884395c07d81fbe77f9390b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BvH7UOSved1IhJao9wxmKw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由<a class="ae ky" href="https://unsplash.com/@ronan18?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">罗南古田</a>提供)</p></figure><h1 id="ac74" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">整体大于部分之和</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/b9dc45622efb5d6ddbb94d3e2f91b304.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/1*NWV2vLKBciK49BAVfzvN4Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="0443" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated"><a class="ae ky" href="https://github.com/TDAmeritrade/stumpy" rel="noopener ugc nofollow" target="_blank"> STUMPY是一个强大且可扩展的Python库，用于现代时间序列分析</a>，在其核心，有效地计算出一种叫做<em class="mo">矩阵轮廓</em>的东西。这个多部分系列的目标是解释什么是matrix profile，以及如何开始利用<a class="ae ky" href="https://stumpy.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> STUMPY </a>完成所有现代时间序列数据挖掘任务！</p><p id="49ad" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated"><em class="mo">注:这些教程最初出现在</em> <a class="ae ky" href="https://stumpy.readthedocs.io/en/latest/tutorials.html" rel="noopener ugc nofollow" target="_blank"> <em class="mo"> STUMPY文档</em> </a> <em class="mo">中。</em></p><p id="1519" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">第1部分:<a class="ae ky" rel="noopener" target="_blank" href="/the-matrix-profile-e4a679269692">矩阵轮廓图</a> <br/>第2部分:<a class="ae ky" rel="noopener" target="_blank" href="/stumpy-basics-21844a2d2d92"> STUMPY基础知识</a> <br/>第3部分:<a class="ae ky" rel="noopener" target="_blank" href="/part-3-time-series-chains-da281450abbf">时间序列链</a> <br/>第4部分:<a class="ae ky" rel="noopener" target="_blank" href="/part-4-semantic-segmentation-b42c3792833d">语义分割</a> <br/>第5部分:<a class="ae ky" rel="noopener" target="_blank" href="/part-5-fast-approximate-matrix-profiles-with-scrump-c6d9c984c560">用STUMPY快速近似矩阵轮廓图</a> <br/>第6部分:<a class="ae ky" rel="noopener" target="_blank" href="/matrix-profiles-for-streaming-time-series-data-f877ff6f9eef">用于流式时间序列数据的矩阵轮廓图</a> <br/>第7部分:<a class="ae ky" rel="noopener" target="_blank" href="/part-7-fast-pattern-searching-with-stumpy-2baf610a8de1">用STUMPY快速模式搜索</a> 10: <a class="ae ky" rel="noopener" target="_blank" href="/part-10-discovering-multidimensional-time-series-motifs-45da53b594bb">发现多维时间序列模体</a> <br/>第11部分:<a class="ae ky" rel="noopener" target="_blank" href="/part-11-user-guided-motif-search-d3d317caf9ea">用户引导的模体搜索</a> <br/>第12部分:<a class="ae ky" rel="noopener" target="_blank" href="/part-12-matrix-profiles-for-machine-learning-2dfd98d7ff3f">机器学习的矩阵轮廓</a></p><h1 id="7d9e" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">用FLUSS和FLOSS识别时间序列数据中的变化点</h1><p id="6054" class="pw-post-body-paragraph ls lt it lu b lv mp ju lx ly mq jx ma mb mr md me mf ms mh mi mj mt ml mm mn im bi translated">本例利用了从<a class="ae ky" href="https://www.cs.ucr.edu/~eamonn/Segmentation_ICDM.pdf" rel="noopener ugc nofollow" target="_blank">矩阵图VIII </a>研究论文中获得的主要信息。对于适当的上下文，我们强烈建议您先阅读本文，但要知道我们的实现是紧密遵循本文的。</p><p id="391c" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">根据上述出版物，“一个人可以对[越来越多的时间序列数据被捕获]执行的最基本的分析之一是将其分割成同质区域。”换句话说，如果您能够将长时间序列数据分割或分割成<code class="fe mu mv mw mx b">k</code>个区域(其中<code class="fe mu mv mw mx b">k</code>较小),并且最终目标是只向人类(或机器)注释者呈现<code class="fe mu mv mw mx b">k</code>个简短的代表性模式，以便为整个数据集生成标签，这不是很好吗？这些分割的区域也被称为“政权”。此外，作为一种探索性工具，人们可能会在数据中发现以前未发现的新的可操作的见解。快速低成本单值语义分割(FLUSS)是一种算法，它产生一种称为“弧形曲线”的东西，用有关政权变化可能性的信息来注释原始时间序列。快速低成本在线语义分割(FLOSS)是FLUSS的一种变体，根据原始论文，它是域不可知的，提供具有可操作实时干预潜力的流功能，并适用于真实世界数据(即，不假设数据的每个区域都属于定义明确的语义段)。</p><p id="4e77" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">为了演示API和基本原理，我们将观察躺在医疗倾斜台上的健康志愿者的动脉血压(ABP)数据，并观察我们是否能够检测到倾斜台何时从水平位置倾斜到垂直位置。这与原始论文中的数据相同(见上文)。</p><h1 id="5689" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">入门指南</h1><p id="f080" class="pw-post-body-paragraph ls lt it lu b lv mp ju lx ly mq jx ma mb mr md me mf ms mh mi mj mt ml mm mn im bi translated">让我们导入加载、分析和绘制数据所需的包。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="dfe9" class="nc la it mx b gy nd ne l nf ng">%matplotlib inline<br/><br/>import pandas as pd<br/>import numpy as np<br/>import stumpy<br/>import matplotlib.pyplot as plt<br/>from matplotlib.patches import Rectangle, FancyArrowPatch<br/>from matplotlib import animation<br/>from IPython.display import HTML<br/><br/>plt.rcParams["figure.figsize"] = [20, 6]  # width, height<br/>plt.rcParams['xtick.direction'] = 'out'</span></pre><h1 id="9a0e" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">检索数据</h1><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="1028" class="nc la it mx b gy nd ne l nf ng">df = pd.read_csv("https://zenodo.org/record/4276400/files/Semantic_Segmentation_TiltABP.csv?download=1")<br/>df.head()</span><span id="8c13" class="nc la it mx b gy nh ne l nf ng">time      abp<br/>   0  06832.0<br/>   1  16928.0<br/>   2  26968.0<br/>   3  36992.0<br/>   4  46980.0</span></pre><h1 id="976b" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">可视化原始数据</h1><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="5ae4" class="nc la it mx b gy nd ne l nf ng">plt.plot(df['time'], df['abp'])<br/>rect = Rectangle((24000,2400),2000,6000,facecolor='lightgrey')<br/>plt.gca().add_patch(rect)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/22705552d6b492e46beb79067dc5ed8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_hm2zzhGEj7A_6p4.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="3425" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">我们可以清楚地看到，在<code class="fe mu mv mw mx b">time=25000</code>附近有一个变化，对应于桌子被直立倾斜的时间。</p><h1 id="60db" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">弗卢斯</h1><p id="c9ed" class="pw-post-body-paragraph ls lt it lu b lv mp ju lx ly mq jx ma mb mr md me mf ms mh mi mj mt ml mm mn im bi translated">不使用完整的数据集，让我们直接放大并分析<code class="fe mu mv mw mx b">x=25000</code>前后的2500个数据点(参见论文中的图5)。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="ec99" class="nc la it mx b gy nd ne l nf ng">start = 25000 - 2500<br/>stop = 25000 + 2500<br/>abp = df.iloc[start:stop, 1]<br/>plt.plot(range(abp.shape[0]), abp)<br/>plt.ylim(2800, 8500)<br/>plt.axvline(x=2373, linestyle="dashed")</span><span id="ee02" class="nc la it mx b gy nh ne l nf ng">style="Simple, tail_width=0.5, head_width=6, head_length=8"<br/>kw = dict(arrowstyle=style, color="k")</span><span id="c862" class="nc la it mx b gy nh ne l nf ng"># regime 1<br/>rect = Rectangle((55,2500), 225, 6000, facecolor='lightgrey')<br/>plt.gca().add_patch(rect)<br/>rect = Rectangle((470,2500), 225, 6000, facecolor='lightgrey')<br/>plt.gca().add_patch(rect)<br/>rect = Rectangle((880,2500), 225, 6000, facecolor='lightgrey')<br/>plt.gca().add_patch(rect)<br/>rect = Rectangle((1700,2500), 225, 6000, facecolor='lightgrey')<br/>plt.gca().add_patch(rect)<br/>arrow = FancyArrowPatch((75, 7000), (490, 7000), connectionstyle="arc3, rad=-.5", **kw)<br/>plt.gca().add_patch(arrow)<br/>arrow = FancyArrowPatch((495, 7000), (905, 7000), connectionstyle="arc3, rad=-.5", **kw)<br/>plt.gca().add_patch(arrow)<br/>arrow = FancyArrowPatch((905, 7000), (495, 7000), connectionstyle="arc3, rad=.5", **kw)<br/>plt.gca().add_patch(arrow)<br/>arrow = FancyArrowPatch((1735, 7100), (490, 7100), connectionstyle="arc3, rad=.5", **kw)<br/>plt.gca().add_patch(arrow)</span><span id="450f" class="nc la it mx b gy nh ne l nf ng"># regime 2<br/>rect = Rectangle((2510,2500), 225, 6000, facecolor='moccasin')<br/>plt.gca().add_patch(rect)<br/>rect = Rectangle((2910,2500), 225, 6000, facecolor='moccasin')<br/>plt.gca().add_patch(rect)<br/>rect = Rectangle((3310,2500), 225, 6000, facecolor='moccasin')<br/>plt.gca().add_patch(rect)<br/>arrow = FancyArrowPatch((2540, 7000), (3340, 7000), connectionstyle="arc3, rad=-.5", **kw)<br/>plt.gca().add_patch(arrow)<br/>arrow = FancyArrowPatch((2960, 7000), (2540, 7000), connectionstyle="arc3, rad=.5", **kw)<br/>plt.gca().add_patch(arrow)<br/>arrow = FancyArrowPatch((3340, 7100), (3540, 7100), connectionstyle="arc3, rad=-.5", **kw)<br/>plt.gca().add_patch(arrow)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/9379af7d1ccbd9b6ee2dddac1ac30c63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6ZY3RAJOHfIC3kAy.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="5bfa" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">粗略地说，在上面的截断图中，我们看到两个区域之间的分割发生在<code class="fe mu mv mw mx b">time=2373</code>(垂直虚线)附近，在那里第一个区域(灰色)的模式没有跨越到第二个区域(橙色)(参见原始论文中的图2)。因此“弧形曲线”是通过沿时间序列滑动并简单地计算其他模式“越过”该特定时间点的次数(即“弧形”)来计算的。从本质上讲，可以通过查看矩阵轮廓指数来提取这些信息(矩阵轮廓指数会告诉您最近的邻居在时间序列上的位置)。因此，我们预计在重复图案彼此靠近的地方电弧数高，在没有交叉电弧的地方电弧数低。</p><p id="3fe7" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">在我们计算“弧形曲线”之前，我们需要首先计算标准矩阵轮廓，我们可以看到窗口大小大约为210个数据点(由于主题/领域专家的知识)。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="02ab" class="nc la it mx b gy nd ne l nf ng">m = 210<br/>mp = stumpy.stump(abp, m=m)</span></pre><p id="d6fb" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">现在，为了计算“弧线”并确定状态变化的位置，我们可以直接调用<code class="fe mu mv mw mx b">stumpy.fluss()</code>函数。但是，请注意<code class="fe mu mv mw mx b">stumpy.fluss()</code>需要以下输入:</p><ol class=""><li id="b9f6" class="nj nk it lu b lv lw ly lz mb nl mf nm mj nn mn no np nq nr bi translated">矩阵轮廓索引<code class="fe mu mv mw mx b">mp[:, 1]</code>(不是矩阵轮廓距离)</li><li id="427b" class="nj nk it lu b lv ns ly nt mb nu mf nv mj nw mn no np nq nr bi translated">一个合适的子序列长度，<code class="fe mu mv mw mx b">L</code>(为了方便起见，我们只选择它等于窗口大小，<code class="fe mu mv mw mx b">m=210</code>)</li><li id="a105" class="nj nk it lu b lv ns ly nt mb nu mf nv mj nw mn no np nq nr bi translated">要搜索的区域数量<code class="fe mu mv mw mx b">n_regimes</code>(本例中为2个区域)</li><li id="4480" class="nj nk it lu b lv ns ly nt mb nu mf nv mj nw mn no np nq nr bi translated">一个排除因子，<code class="fe mu mv mw mx b">excl_factor</code>，使弧线的起点和终点无效(根据论文，1-5之间的任何值都是合理的)</li></ol><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="f1bf" class="nc la it mx b gy nd ne l nf ng">L = 210<br/>cac, regime_locations = stumpy.fluss(mp[:, 1], L=L, n_regimes=2, excl_factor=1)</span></pre><p id="95ce" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">请注意，<code class="fe mu mv mw mx b">stumpy.fluss()</code>实际上返回了一种叫做“校正弧线”(CAC)的东西，它使这样一个事实正常化，即通常在时间序列的开始和结束附近的时间点上跨越的弧线较少，而在时间序列的中间附近跨越的可能性较大。另外，<code class="fe mu mv mw mx b">stumpy.fluss()</code>返回虚线的区域或位置。让我们绘制原始时间序列(顶部)以及校正后的弧线(橙色)和单一状态(垂直虚线)。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="c521" class="nc la it mx b gy nd ne l nf ng">fig, axs = plt.subplots(2, sharex=True, gridspec_kw={'hspace': 0})<br/>axs[0].plot(range(abp.shape[0]), abp)<br/>axs[0].axvline(x=regime_locations[0], linestyle="dashed")<br/>axs[1].plot(range(cac.shape[0]), cac, color='C1')<br/>axs[1].axvline(x=regime_locations[0], linestyle="dashed")</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/d624c1a42c4bfebab3cf828ea0c590c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*IH7Ajqs8j_c8QeQ5.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="f769" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">在这里，我们看到<code class="fe mu mv mw mx b">stumpy.fluss()</code>不仅成功地识别出存在政权更迭，而且能够清晰明确地区分两种政权。</p><h1 id="1c8c" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">丝棉</h1><p id="9a4d" class="pw-post-body-paragraph ls lt it lu b lv mp ju lx ly mq jx ma mb mr md me mf ms mh mi mj mt ml mm mn im bi translated">与FLUSS不同，FLOSS关注的是流数据，因此它计算的是修正圆弧曲线(CAC)的修改版本，它是严格单向的(CAC_1D ),而不是双向的。也就是说，我们不期望从两个方向交叉的可能性相等，而是期望更多的交叉指向未来(更少的指向过去)。所以，我们可以手动计算<code class="fe mu mv mw mx b">CAC_1D</code></p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="2571" class="nc la it mx b gy nd ne l nf ng"># This is for demo purposes only. Use stumpy.floss() below!<br/>cac_1d = stumpy._cac(mp[:, 3], L, bidirectional=False, excl_factor=1)</span></pre><p id="32b4" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">并且将<code class="fe mu mv mw mx b">CAC_1D</code>(蓝色)与双向<code class="fe mu mv mw mx b">CAC</code>(橙色)进行比较，我们看到全局最小值大约在相同的位置(参见原始论文中的图10)。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="e04f" class="nc la it mx b gy nd ne l nf ng">fig, axs = plt.subplots(2, sharex=True, gridspec_kw={'hspace': 0})<br/>axs[0].plot(np.arange(abp.shape[0]), abp)<br/>axs[0].axvline(x=regime_locations[0], linestyle="dashed")<br/>axs[1].plot(range(cac.shape[0]), cac, color='C1')<br/>axs[1].axvline(x=regime_locations[0], linestyle="dashed")<br/>axs[1].plot(range(cac_1d.shape[0]), cac_1d)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/38d970db1dcdbcad309ffffa53af6d9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*17tEY3ZY5GjTTIRN.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><h1 id="a75d" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">使用FLOSS传输数据</h1><p id="6e47" class="pw-post-body-paragraph ls lt it lu b lv mp ju lx ly mq jx ma mb mr md me mf ms mh mi mj mt ml mm mn im bi translated">然而，我们可以直接调用实例化一个流对象的<code class="fe mu mv mw mx b">stumpy.floss()</code>函数，而不是像上面那样手工计算<code class="fe mu mv mw mx b">CAC_1D</code>。为了演示<code class="fe mu mv mw mx b">stumpy.floss()</code>的用法，让我们取一些<code class="fe mu mv mw mx b">old_data</code>并像上面那样计算它的矩阵轮廓指数:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="5e7d" class="nc la it mx b gy nd ne l nf ng">old_data = df.iloc[20000:20000+5000, 1].values  # This is well before the regime change has occurred</span><span id="f272" class="nc la it mx b gy nh ne l nf ng">mp = stumpy.stump(old_data, m=m)</span></pre><p id="244a" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">现在，我们可以像前面一样计算双向修正弧线，但我们希望看到弧线在添加新数据点后会如何变化。因此，让我们定义一些要流入的新数据:</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="d7cd" class="nc la it mx b gy nd ne l nf ng">new_data = df.iloc[25000:25000+5000, 1].values</span></pre><p id="5e94" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">最后，我们调用<code class="fe mu mv mw mx b">stumpy.floss()</code>函数来初始化一个流对象并传入:</p><ol class=""><li id="5818" class="nj nk it lu b lv lw ly lz mb nl mf nm mj nn mn no np nq nr bi translated">从<code class="fe mu mv mw mx b">old_data</code>生成的矩阵轮廓(仅使用矩阵轮廓索引)</li><li id="b174" class="nj nk it lu b lv ns ly nt mb nu mf nv mj nw mn no np nq nr bi translated">“旧数据”用于生成1中的矩阵轮廓。</li><li id="b972" class="nj nk it lu b lv ns ly nt mb nu mf nv mj nw mn no np nq nr bi translated">矩阵轮廓窗口大小，<code class="fe mu mv mw mx b">m=210</code></li><li id="9709" class="nj nk it lu b lv ns ly nt mb nu mf nv mj nw mn no np nq nr bi translated">子序列长度，<code class="fe mu mv mw mx b">L=210</code></li><li id="c33c" class="nj nk it lu b lv ns ly nt mb nu mf nv mj nw mn no np nq nr bi translated">排除因素</li></ol><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="7b47" class="nc la it mx b gy nd ne l nf ng">stream = stumpy.floss(mp, old_data, m=m, L=L, excl_factor=1)</span></pre><p id="9816" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">您现在可以通过<code class="fe mu mv mw mx b">stream.update(t)</code>功能用新的数据点<code class="fe mu mv mw mx b">t</code>更新<code class="fe mu mv mw mx b">stream</code>，这将滑动您的窗口一个数据点，它将自动更新:</p><ol class=""><li id="50c8" class="nj nk it lu b lv lw ly lz mb nl mf nm mj nn mn no np nq nr bi translated"><code class="fe mu mv mw mx b">CAC_1D</code>(通过<code class="fe mu mv mw mx b">.cac_1d_</code>属性访问)</li><li id="923b" class="nj nk it lu b lv ns ly nt mb nu mf nv mj nw mn no np nq nr bi translated">矩阵轮廓(通过<code class="fe mu mv mw mx b">.P_</code>属性访问)</li><li id="ff36" class="nj nk it lu b lv ns ly nt mb nu mf nv mj nw mn no np nq nr bi translated">矩阵轮廓指数(通过<code class="fe mu mv mw mx b">.I_</code>属性访问)</li><li id="751a" class="nj nk it lu b lv ns ly nt mb nu mf nv mj nw mn no np nq nr bi translated">用于产生<code class="fe mu mv mw mx b">CAC_1D</code>的数据滑动窗口(通过<code class="fe mu mv mw mx b">.T_</code>属性访问——这应该与“旧数据”的长度相同)</li></ol><p id="8572" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">让我们用<code class="fe mu mv mw mx b">new_data</code>不断更新我们的<code class="fe mu mv mw mx b">stream</code>，一次更新一个值，并将它们存储在一个列表中(一会儿你就知道为什么了):</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="1472" class="nc la it mx b gy nd ne l nf ng">windows = []<br/>for i, t in enumerate(new_data):<br/>    stream.update(t)</span><span id="42a9" class="nc la it mx b gy nh ne l nf ng">    if i % 100 == 0:<br/>        windows.append((stream.T_, stream.cac_1d_))</span></pre><p id="c191" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">下面，您可以看到一个动画，它是用新数据更新流的结果。作为参考，我们还绘制了<code class="fe mu mv mw mx b">CAC_1D</code>(橙色)，这是我们从上面为静态数据手动生成的。您将看到，在动画进行到一半时，状态发生了变化，更新后的<code class="fe mu mv mw mx b">CAC_1D</code>(蓝色)将与橙色曲线完美对齐。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="f0c3" class="nc la it mx b gy nd ne l nf ng">fig, axs = plt.subplots(2, sharex=True, gridspec_kw={'hspace': 0})</span><span id="6908" class="nc la it mx b gy nh ne l nf ng">axs[0].set_xlim((0, mp.shape[0]))<br/>axs[0].set_ylim((-0.1, max(np.max(old_data), np.max(new_data))))<br/>axs[1].set_xlim((0, mp.shape[0]))<br/>axs[1].set_ylim((-0.1, 1.1))</span><span id="efc6" class="nc la it mx b gy nh ne l nf ng">lines = []<br/>for ax in axs:<br/>    line, = ax.plot([], [], lw=2)<br/>    lines.append(line)<br/>line, = axs[1].plot([], [], lw=2)<br/>lines.append(line)</span><span id="1c8f" class="nc la it mx b gy nh ne l nf ng">def init():<br/>    for line in lines:<br/>        line.set_data([], [])<br/>    return lines</span><span id="a7a3" class="nc la it mx b gy nh ne l nf ng">def animate(window):<br/>    data_out, cac_out = window<br/>    for line, data in zip(lines, [data_out, cac_out, cac_1d]):<br/>        line.set_data(np.arange(data.shape[0]), data)<br/>    return lines</span><span id="6caf" class="nc la it mx b gy nh ne l nf ng">anim = animation.FuncAnimation(fig, animate, init_func=init,<br/>                               frames=windows, interval=100,<br/>                               blit=True)</span><span id="1e52" class="nc la it mx b gy nh ne l nf ng">anim_out = anim.to_jshtml()<br/>plt.close()  # Prevents duplicate image from displaying<br/>if os.path.exists("None0000000.png"):<br/>    os.remove("None0000000.png")  # Delete rogue temp file</span><span id="53be" class="nc la it mx b gy nh ne l nf ng">HTML(anim_out)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/49329727d2559c4f3b16c9bd8d200995.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*2EuHfmMWqcYMdoqLf5lz_Q.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><h1 id="2f5e" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">摘要</h1><p id="7a17" class="pw-post-body-paragraph ls lt it lu b lv mp ju lx ly mq jx ma mb mr md me mf ms mh mi mj mt ml mm mn im bi translated">就是这样！您刚刚学习了如何使用矩阵剖面指数和利用<code class="fe mu mv mw mx b">stumpy.fluss()</code>和<code class="fe mu mv mw mx b">stumpy.floss()</code>以编程方式识别时间序列数据中的变化段/状态的基础知识。</p><h1 id="5b4a" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">资源</h1><p id="de65" class="pw-post-body-paragraph ls lt it lu b lv mp ju lx ly mq jx ma mb mr md me mf ms mh mi mj mt ml mm mn im bi translated"><a class="ae ky" href="https://www.cs.ucr.edu/~eamonn/Segmentation_ICDM.pdf" rel="noopener ugc nofollow" target="_blank">Matrix Profile VIII</a><br/><a class="ae ky" href="https://stumpy.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">STUMPY Matrix Profile文档</a><br/><a class="ae ky" href="https://github.com/TDAmeritrade/stumpy" rel="noopener ugc nofollow" target="_blank">STUMPY Matrix Profile Github代码库</a></p><h2 id="dc37" class="nc la it bd lb ny nz dn lf oa ob dp lj mb oc od ll mf oe of ln mj og oh lp oi bi translated">← <a class="ae ky" rel="noopener" target="_blank" href="/part-3-time-series-chains-da281450abbf">第3部分:时间序列链</a> | <a class="ae ky" rel="noopener" target="_blank" href="/part-5-fast-approximate-matrix-profiles-with-scrump-c6d9c984c560">第5部分:带STUMPY的快速近似矩阵轮廓</a> →</h2></div></div>    
</body>
</html>