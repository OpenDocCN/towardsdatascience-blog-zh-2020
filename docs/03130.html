<html>
<head>
<title>Visualising Assembly Graphs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可视化装配图</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/visualising-assembly-graphs-fb631f46bbd1?source=collection_archive---------19-----------------------#2020-03-25">https://towardsdatascience.com/visualising-assembly-graphs-fb631f46bbd1?source=collection_archive---------19-----------------------#2020-03-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4178" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用于宏基因组宁滨分析的可视化装配图</h2></div><p id="7968" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我研究元基因组组装图已经有一段时间了，我遇到了许多有趣的事情。在这篇文章中，我将与您分享我对宏基因组组装图和从这些图中获得的宁滨重叠群的一些观察。假设你对基因组组装有了基本的了解(如果没有你可以看我之前的文章<a class="ae le" rel="noopener" target="_blank" href="/genome-assembly-the-holy-grail-of-genome-analysis-fae8fc9ef09c">基因组组装——基因组分析的圣杯</a>)，让我们开始吧。</p><h1 id="a21b" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">什么是装配图？</h1><p id="16bf" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">装配图用于表示一个基因组(或元基因组)的最终装配。简而言之，汇编器根据读数和它们的重叠信息构建这个汇编图。最后，组装器解析组装图中的路径，并输出非分支路径作为重叠群。</p><p id="8ff2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面给出了从名为<a class="ae le" href="https://rrwick.github.io/Bandage/" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">绷带</strong> </a>的工具中获得的装配图的可视化部分。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mc"><img src="../Images/2ab69e14d5af0d91f29a6302a00185b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gAOeI3xyqWAMDJDWTNTzAQ.png"/></div></div><p class="mo mp gj gh gi mq mr bd b be z dk translated">图一。使用绷带显示<a class="ae le" href="https://github.com/Vini2/GraphBin/tree/master/test_data/ES_metaSPAdes" rel="noopener ugc nofollow" target="_blank"> <strong class="bd ms"> ES+metaSPAdes </strong> </a>数据集。</p></figure><h1 id="7370" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">装配图是如何表示的？</h1><p id="e9ca" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">用于表示装配图的最常见的文件格式是<a class="ae le" href="http://gfa-spec.github.io/GFA-spec/GFA1.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> GFA(图形片段装配)</strong> </a>格式。GFA 文件由一组序列和制表符分隔的重叠序列对组成。你可以从 http://gfa-spec.github.io/GFA-spec/GFA1.html 了解更多关于这种格式的信息。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mc"><img src="../Images/e4923c3ac260db1fba64ecf8340c44ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IGE_NsBQRktiJv5PSd9IhA.png"/></div></div><p class="mo mp gj gh gi mq mr bd b be z dk translated">图二。GFA 样本文件的一部分</p></figure><p id="7555" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如图 2 所示，序列从“<strong class="kk iu"> S </strong>开始表示，序列之间的重叠(或连接)从“<strong class="kk iu"> L </strong>开始表示。加号(+)和减号(-)表示重叠中考虑的是原始序列还是其反向互补序列。链环中用字母“<strong class="kk iu"> M </strong>表示的数值是指搭接长度。在这个样本文件中，重叠长度是 55 个碱基对。</p><h1 id="7aae" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">如何可视化装配图？</h1><p id="09bd" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">由于我们正在讨论的组装图已经是一个“<strong class="kk iu">图</strong>，我们可以将序列建模为顶点，将重叠/链接建模为边。</p><ul class=""><li id="3acd" class="mt mu it kk b kl km ko kp kr mv kv mw kz mx ld my mz na nb bi translated">顶点→序列</li><li id="2ba2" class="mt mu it kk b kl nc ko nd kr ne kv nf kz ng ld my mz na nb bi translated">边缘→序列之间的重叠</li></ul><p id="1ef5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们使用<strong class="kk iu"> python-igraph </strong>可视化一个样本装配图。你可以从我的<a class="ae le" rel="noopener" target="_blank" href="/visualising-graph-data-with-python-igraph-b3cc81a495cf">上一篇文章</a>中读到更多关于使用 python-igraph 可视化图形数据的内容。为了便于解释，我不考虑链接信息中的加号和减号。简单地说，我将想象一个无向图。</p><h1 id="a9a6" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">可视化样本图</h1><p id="744b" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">我们将考虑由来自两种细菌物种的读数组成的数据集；<em class="nh">粪肠球菌</em>和<em class="nh">金黄色葡萄球菌</em>。我们将它称为<strong class="kk iu"> ES </strong>数据集。我已经使用<a class="ae le" href="https://genome.cshlp.org/content/27/5/824" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> metaSPAdes </strong> </a>组装器组装了这个数据集，以获得重叠群。这个重叠群数据集被称为<strong class="kk iu"> ES+metaSPAdes </strong>，可以从链接<a class="ae le" href="https://github.com/Vini2/GraphBin/tree/master/test_data/ES_metaSPAdes" rel="noopener ugc nofollow" target="_blank">找到这里的</a>为<a class="ae le" href="https://github.com/Vini2/GraphBin/blob/master/test_data/ES_metaSPAdes/contigs.fasta" rel="noopener ugc nofollow" target="_blank"><strong class="kk iu"><em class="nh">contigs . fasta</em></strong></a>。装配图文件可以找到<a class="ae le" href="https://github.com/Vini2/GraphBin/blob/master/test_data/ES_metaSPAdes/assembly_graph_with_scaffolds.gfa" rel="noopener ugc nofollow" target="_blank"><strong class="kk iu"><em class="nh">assembly _ graph _ with _ scaffolds . GFA</em></strong></a>。</p><p id="e5a1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="nh">注:</em> </strong> metaSPAdes 将每个重叠群表示为一组片段，组装图文件包含这些片段的详细信息以及这些片段之间的链接。因此，当获得重叠群之间的链接时，您必须扫描<a class="ae le" href="https://github.com/Vini2/GraphBin/blob/master/test_data/ES_metaSPAdes/contigs.paths" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> <em class="nh">重叠群.路径</em> </strong> </a>文件和<a class="ae le" href="https://github.com/Vini2/GraphBin/blob/master/test_data/ES_metaSPAdes/assembly_graph_with_scaffolds.gfa" rel="noopener ugc nofollow" target="_blank"><strong class="kk iu"><em class="nh">assembly _ graph _ with _ scaffolds . GFA</em></strong></a><strong class="kk iu"><em class="nh">文件</em> </strong>中每个重叠群的前缀和后缀，以确定重叠重叠群的前缀或后缀。</p><p id="4170" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">ES+metaSPAdes 数据集的可视化如下所示。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi ni"><img src="../Images/09599ae726ca17a158d6f0612db3b217.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ES1QKWgXBlhrn2LL6ehq0w.png"/></div></div><p class="mo mp gj gh gi mq mr bd b be z dk translated">图三。装配图的可视化</p></figure><h1 id="9f7c" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">比对参考基因组</h1><p id="68f0" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">我们可以将重叠群与参考基因组进行比对，以确定每个重叠群属于哪个基因组。为此，我们可以使用<a class="ae le" href="https://github.com/lh3/bwa" rel="noopener ugc nofollow" target="_blank"> BWA-MEM </a>。下面给出了一个运行 BWA-MEM 的示例命令。</p><pre class="md me mf mg gt nj nk nl nm aw nn bi"><span id="689f" class="no lg it nk b gy np nq l nr ns">bwa mem &lt;<strong class="nk iu">path to reference genome</strong>&gt; &lt;<strong class="nk iu">path to contig file</strong>&gt; &gt; &lt;<strong class="nk iu">output path</strong>&gt;alignment.sam</span></pre><p id="e3db" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于每个重叠群，导致最长比对长度的参考基因组可以被认为是重叠群的来源。</p><p id="9daf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在确定重叠群的基本事实后，我们可以标记顶点(重叠群)并将这些数据可视化，如图 4 所示。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi ni"><img src="../Images/36379eb7385797a38b425ce39b5bc642.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5VhKQ18cVZlY0_Hdf7P1PA.png"/></div></div><p class="mo mp gj gh gi mq mr bd b be z dk translated">图 4。重叠群基础真相物种的可视化。红色重叠群属于粪肠球菌，绿色重叠群属于金黄色葡萄球菌。不考虑白色节点。</p></figure><h1 id="0aa2" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">从这些集会中我们能得出什么结论？</h1><p id="507c" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">如图 5 所示，我们可以看到，两个物种的重叠群倾向于在组装图中形成两个独立的区域。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi ni"><img src="../Images/e5aa3ef560328d64abdaaffe2e360fb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A5BrvJTdA7FhrNdEOdrKtg.png"/></div></div><p class="mo mp gj gh gi mq mr bd b be z dk translated">图五。这两个物种的分离可以在装配图中看到。</p></figure><p id="7d22" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，除了边界情况之外，属于相同物种的重叠群很可能彼此之间有重叠。我们可以在宁滨分析中利用这些数据。</p><h1 id="3002" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">密码</h1><p id="bad8" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">下面是一些用来生成我在本文中展示的图像的代码片段。</p><h2 id="4f89" class="no lg it bd lh nt nu dn ll nv nw dp lp kr nx ny lr kv nz oa lt kz ob oc lv od bi translated">构建装配图</h2><pre class="md me mf mg gt nj nk nl nm aw nn bi"><span id="44c4" class="no lg it nk b gy np nq l nr ns">import re<br/>from igraph import *<br/>from collections import defaultdict</span><span id="aba1" class="no lg it nk b gy oe nq l nr ns">paths = {}<br/>segment_contigs = {}<br/>node_count = 0</span><span id="e479" class="no lg it nk b gy oe nq l nr ns"># Get contig paths from contigs.paths<br/>with open(&lt;<strong class="nk iu">path to metaSPAdes contigs.paths file</strong>&gt;) as file:<br/>    name = file.readline()<br/>    path = file.readline()<br/>    <br/>    while name != "" and path != "":<br/>            <br/>        while ";" in path:<br/>            path = path[:-2]+","+file.readline()<br/>        <br/>        start = 'NODE_'<br/>        end = '_length_'<br/>        contig_num = str(int(re.search('%s(.*)%s' % (start, end), name).group(1))-1)<br/>        <br/>        segments = path.rstrip().split(",")<br/>        <br/>        if contig_num not in paths:<br/>            node_count += 1<br/>            paths[contig_num] = [segments[0], segments[-1]]<br/>        <br/>        for segment in segments:<br/>            if segment not in segment_contigs:<br/>                segment_contigs[segment] = set([contig_num])<br/>            else:<br/>                segment_contigs[segment].add(contig_num)<br/>        <br/>        name = file.readline()<br/>        path = file.readline()<br/></span><span id="2c8d" class="no lg it nk b gy oe nq l nr ns">links = []<br/>links_map = defaultdict(set)</span><span id="d028" class="no lg it nk b gy oe nq l nr ns"># Get contig paths from contigs.paths<br/>with open(&lt;<strong class="nk iu">path to metaSPAdes GFA file</strong>&gt;) as file:<br/>    line = file.readline()<br/>    <br/>    while line != "":<br/>        <br/>        # Identify lines with link information<br/>        if "L" in line:<br/>            strings = line.split("\t")<br/>            f1, f2 = strings[1]+strings[2], strings[3]+strings[4]<br/>            links_map[f1].add(f2)<br/>            links_map[f2].add(f1)<br/>            links.append(strings[1]+strings[2]+" "+strings[3]+strings[4])<br/>        line = file.readline()<br/></span><span id="2394" class="no lg it nk b gy oe nq l nr ns"># Create graph<br/>g = Graph()</span><span id="a0be" class="no lg it nk b gy oe nq l nr ns"># Add vertices<br/>g.add_vertices(node_count)</span><span id="e02a" class="no lg it nk b gy oe nq l nr ns">for i in range(len(g.vs)):<br/>    g.vs[i]["id"]= i<br/>    g.vs[i]["label"]= str(i+1)</span><span id="75d0" class="no lg it nk b gy oe nq l nr ns">for i in range(len(paths)):<br/>    segments = paths[str(i)]<br/>    <br/>    start = segments[0]<br/>    start_rev = ""<br/>    if start.endswith("+"):<br/>        start_rev = start[:-1]+"-"<br/>    else:<br/>        start_rev = start[:-1]+"+"<br/>        <br/>    end = segments[1]<br/>    end_rev = ""<br/>    if end.endswith("+"):<br/>        end_rev = end[:-1]+"-"<br/>    else:<br/>        end_rev = end[:-1]+"+"<br/>    <br/>    new_links = []<br/>    <br/>    if start in links_map:<br/>        new_links.extend(list(links_map[start]))<br/>    if start_rev in links_map:<br/>        new_links.extend(list(links_map[start_rev]))<br/>    if end in links_map:<br/>        new_links.extend(list(links_map[end]))<br/>    if end_rev in links_map:<br/>        new_links.extend(list(links_map[end_rev]))<br/>    <br/>    for new_link in new_links:<br/>        if new_link in segment_contigs:<br/>            for contig in segment_contigs[new_link]:<br/>                if i!=int(contig):<br/>                    g.add_edge(i,int(contig))<br/>            <br/>g.simplify(multiple=True, loops=False, combine_edges=None)</span></pre><h2 id="5952" class="no lg it bd lh nt nu dn ll nv nw dp lp kr nx ny lr kv nz oa lt kz ob oc lv od bi translated"><strong class="ak">使用 python-igraph 可视化初始装配图</strong></h2><pre class="md me mf mg gt nj nk nl nm aw nn bi"><span id="6bc6" class="no lg it nk b gy np nq l nr ns">out_fig_name = "assembly_graph.png"</span><span id="0bac" class="no lg it nk b gy oe nq l nr ns">visual_style = {}</span><span id="0aa6" class="no lg it nk b gy oe nq l nr ns"># Set bbox and margin<br/>visual_style["bbox"] = (1500,1500)<br/>visual_style["margin"] = 30</span><span id="cff8" class="no lg it nk b gy oe nq l nr ns"># Set vertex colours<br/>visual_style["vertex_color"] = 'white'</span><span id="278a" class="no lg it nk b gy oe nq l nr ns"># Set vertex size<br/>visual_style["vertex_size"] = 35</span><span id="6c73" class="no lg it nk b gy oe nq l nr ns"># Set vertex lable size<br/>visual_style["vertex_label_size"] = 15</span><span id="93ba" class="no lg it nk b gy oe nq l nr ns"># Don't curve the edges<br/>visual_style["edge_curved"] = False</span><span id="2837" class="no lg it nk b gy oe nq l nr ns"># Set the layout<br/>my_layout = g.layout_fruchterman_reingold()<br/>visual_style["layout"] = my_layout</span><span id="b06c" class="no lg it nk b gy oe nq l nr ns"># Plot the graph<br/>plot(g, out_fig_name, **visual_style)</span></pre><h2 id="68ab" class="no lg it bd lh nt nu dn ll nv nw dp lp kr nx ny lr kv nz oa lt kz ob oc lv od bi translated">用 python-igraph 可视化彩色装配图</h2><pre class="md me mf mg gt nj nk nl nm aw nn bi"><span id="5ebe" class="no lg it nk b gy np nq l nr ns">node_colours = []</span><span id="4258" class="no lg it nk b gy oe nq l nr ns">for i in range(node_count):<br/>    if i in efaecalis_list:<br/>        node_colours.append("red")<br/>    elif i in saureus_list:<br/>        node_colours.append("green")<br/>    else:<br/>        node_colours.append("white")</span><span id="3733" class="no lg it nk b gy oe nq l nr ns">out_fig_name = "coloured_assembly_graph.png"</span><span id="cedc" class="no lg it nk b gy oe nq l nr ns">g.vs["color"] = node_colours</span><span id="f7dd" class="no lg it nk b gy oe nq l nr ns">visual_style = {}</span><span id="b9d2" class="no lg it nk b gy oe nq l nr ns"># Set bbox and margin<br/>visual_style["bbox"] = (1500,1500)<br/>visual_style["margin"] = 30</span><span id="53ce" class="no lg it nk b gy oe nq l nr ns"># Set vertex size<br/>visual_style["vertex_size"] = 35</span><span id="1cf1" class="no lg it nk b gy oe nq l nr ns"># Set vertex lable size<br/>visual_style["vertex_label_size"] = 15</span><span id="3928" class="no lg it nk b gy oe nq l nr ns"># Don't curve the edges<br/>visual_style["edge_curved"] = False</span><span id="7950" class="no lg it nk b gy oe nq l nr ns"># Set the layout<br/>visual_style["layout"] = my_layout</span><span id="b66e" class="no lg it nk b gy oe nq l nr ns"># Plot the graph<br/>plot(g, out_fig_name, **visual_style)</span></pre><h1 id="15ee" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">最后的想法</h1><p id="fd02" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">我和我的实验室开发了一个名为<strong class="kk iu"> GraphBin </strong>的工具，通过利用组装图和重叠群之间的连接性信息来细化合并的重叠群。你可以从<a class="ae le" href="https://github.com/Vini2/GraphBin" rel="noopener ugc nofollow" target="_blank">这里</a>找到 GitHub 回购。</p><div class="of og gp gr oh oi"><a href="https://github.com/Vini2/GraphBin" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">Vini2/GraphBin</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">GraphBin 是一个宏基因组重叠群宁滨工具，它利用了来自组装…</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">github.com</p></div></div><div class="or l"><div class="os l ot ou ov or ow mm oi"/></div></div></a></div><p id="5fbd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">GraphBin 发表在 OUP 生物信息学杂志上。你可以从 DOI:<a class="ae le" href="http://dx.doi.org/10.1093/bioinformatics/btaa180" rel="noopener ugc nofollow" target="_blank">10.1093/bio informatics/btaa 180</a>中查看关于该工具的更多信息。</p><div class="of og gp gr oh oi"><a href="http://dx.doi.org/10.1093/bioinformatics/btaa180" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">GraphBin:使用集合图的宏基因组重叠群的精细宁滨</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">抽象动机。宏基因组学领域提供了对结构、多样性和生态学的有价值的见解。</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">dx.doi.org</p></div></div><div class="or l"><div class="ox l ot ou ov or ow mm oi"/></div></div></a></div><p id="f44d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你也可以从下面列出的我以前的文章中读到更多关于基因组组装和宏基因组学的内容。</p><div class="of og gp gr oh oi"><a rel="noopener follow" target="_blank" href="/genome-assembly-the-holy-grail-of-genome-analysis-fae8fc9ef09c"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">基因组组装——基因组分析的圣杯</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">组装 2019 新型冠状病毒基因组</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">towardsdatascience.com</p></div></div><div class="or l"><div class="oy l ot ou ov or ow mm oi"/></div></div></a></div><div class="of og gp gr oh oi"><a rel="noopener follow" target="_blank" href="/metagenomics-who-is-there-and-what-are-they-doing-9f204342eed9"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">宏基因组学——谁在那里，他们在做什么？</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">深入了解微生物群落的数据</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">towardsdatascience.com</p></div></div><div class="or l"><div class="oz l ot ou ov or ow mm oi"/></div></div></a></div><p id="3a68" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">希望你对我的发现感兴趣。我很想听听你的想法。</p><p id="910e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您的阅读。</p><p id="cc1f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">干杯！</p></div></div>    
</body>
</html>