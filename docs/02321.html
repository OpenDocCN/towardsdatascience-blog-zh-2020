<html>
<head>
<title>Understanding Python Bytecode</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解Python字节码</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/understanding-python-bytecode-e7edaae8734d?source=collection_archive---------2-----------------------#2020-03-05">https://towardsdatascience.com/understanding-python-bytecode-e7edaae8734d?source=collection_archive---------2-----------------------#2020-03-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d97e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何反汇编Python字节码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fd083030d6444c7435a04bfc5d17bac7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rzFHGM9zMYTuoZwLiJLczQ.jpeg"/></div></div></figure><p id="9494" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">编程语言的源代码可以使用解释器或编译器来执行。在编译语言中，编译器会将源代码直接翻译成二进制机器代码。该机器代码特定于目标机器，因为每台机器可以具有不同操作系统和硬件。编译后，目标机器会直接运行机器码。</p><p id="2f42" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在解释语言中，源代码不是由目标机器直接运行的。还有一个程序叫做解释器，它直接读取并执行源代码。特定于目标机器的解释器将源代码的每个语句翻译成机器代码并运行它。</p><p id="14a9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Python通常被称为解释语言，然而，它结合了编译和解释。当我们执行一个源代码(扩展名为<code class="fe lq lr ls lt b">.py</code>的文件)时，Python首先将其编译成字节码。字节码是独立于平台的低级源代码表示，但是，它不是二进制机器码，不能由目标机器直接运行。事实上，它是一个虚拟机的指令集，这个虚拟机被称为Python虚拟机(PVM)。</p><p id="2ae4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">编译后，字节码被发送到PVM执行。PVM是运行字节码的解释器，是Python系统的一部分。字节码是独立于平台的，但是PVM是特定于目标机器的。Python编程语言的默认实现是用C编程语言编写的CPython。CPython将Python源代码编译成字节码，然后这个字节码由CPython虚拟机执行。</p><p id="ee5a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">生成字节码文件</strong></p><p id="9906" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在Python中，字节码存储在一个<code class="fe lq lr ls lt b">.pyc</code>文件中。在Python 3中，字节码文件存储在一个名为<code class="fe lq lr ls lt b">__pycache__</code>的文件夹中。当您尝试导入您创建的另一个文件时，会自动创建此文件夹:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="a9e3" class="ly lz it lt b gy ma mb l mc md">import file_name</span></pre><p id="982f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是，如果我们不在源代码中导入另一个文件，它就不会被创建。在这种情况下，我们仍然可以手动创建它。要从命令行编译单个文件<code class="fe lq lr ls lt b">file_1.py</code>到<code class="fe lq lr ls lt b">file_n.py </code>，我们可以写:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="7a59" class="ly lz it lt b gy ma mb l mc md">python -m compileall file_1.py ... file_n.py</span></pre><p id="f75a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所有生成的<code class="fe lq lr ls lt b">pyc</code>文件都将存储在<code class="fe lq lr ls lt b">__pycache__ </code>文件夹中。如果在<code class="fe lq lr ls lt b">compileall,</code>之后没有提供文件名，它将编译当前文件夹中的所有python源代码文件。</p><p id="090f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还可以使用<code class="fe lq lr ls lt b">compile()</code>函数来编译包含Python源代码的字符串。该函数的语法是:</p><p id="771f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">compile(<em class="me">source</em>, <em class="me">filename</em>, <em class="me">mode</em>, <em class="me">flag</em>, <em class="me">dont_inherit</em>, <em class="me">optimize</em>)</code></p><p id="7ed2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们只关注前三个必需的参数(其他的是可选的)。<code class="fe lq lr ls lt b">source</code>是要编译的源代码，可以是字符串、字节对象或AST对象。<code class="fe lq lr ls lt b">filename</code>是源代码所来自的文件的名称。如果源代码不是来自一个文件，你可以写你喜欢的任何东西或者留下一个空字符串。<code class="fe lq lr ls lt b">mode</code>可以是:</p><p id="b2ee" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">'exec'</code>:接受任何形式的Python源代码(任意数量的语句或块)。它将它们编译成字节码，最终返回<code class="fe lq lr ls lt b">None</code></p><p id="d65d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">'eval'</code>:接受单个表达式，并将其编译成字节码，最终返回该表达式的值</p><p id="f83d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">'single'</code>:只接受一条语句(或用<code class="fe lq lr ls lt b">;</code>分隔的多条语句)。如果最后一条语句是一个表达式，那么产生的字节码会将该表达式的值的<em class="me"> </em> <code class="fe lq lr ls lt b">repr()</code> <em class="me"> </em>打印到标准输出中。</p><p id="aec6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，为了编译一些Python语句，我们可以编写:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="acb7" class="ly lz it lt b gy ma mb l mc md">s='''<br/>a=5<br/>a+=1<br/>print(a)<br/>'''<br/>compile(s, "", "exec")</span></pre><p id="7e3c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">或者换句话说:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="db43" class="ly lz it lt b gy ma mb l mc md">compile("a=5 \na+=1 \nprint(a)", "", "exec")</span></pre><p id="8b03" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要评估一个表达式，我们可以写:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="63c3" class="ly lz it lt b gy ma mb l mc md">compile("a+7", "", "eval")</span></pre><p id="5631" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您没有表达式，此模式会给出一个错误:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="614a" class="ly lz it lt b gy ma mb l mc md"># This does not work:<br/>compile("a=a+1", "", "eval")</span></pre><p id="c3e9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里<code class="fe lq lr ls lt b">a=a+1</code>不是一个表达式，不返回任何东西，所以我们不能使用<code class="fe lq lr ls lt b">eval</code>模式。但是，我们可以使用<code class="fe lq lr ls lt b">single</code>模式来编译它:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="3b45" class="ly lz it lt b gy ma mb l mc md">compile("a=a+1", "", "single")</span></pre><p id="fdba" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是<code class="fe lq lr ls lt b">compile</code>返回的是什么？当您运行<code class="fe lq lr ls lt b">compile</code>函数时，Python返回:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="3797" class="ly lz it lt b gy ma mb l mc md">&lt;code object &lt;module&gt; at 0x000001A1DED95540, file "", line 1&gt;</span></pre><p id="468b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以<code class="fe lq lr ls lt b">compile</code>函数返回的是一个<em class="me">代码对象</em>(在<code class="fe lq lr ls lt b">at</code>之后的地址在你的机器上可以不同)。</p><p id="4750" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">代码对象</strong></p><p id="87a7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">compile()</code>函数返回一个Python代码对象。Python中的一切都是对象。例如，我们定义了一个整数变量，它的值存储在一个<code class="fe lq lr ls lt b">int</code>对象中，您可以使用<code class="fe lq lr ls lt b">type()</code>函数轻松检查它的类型:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="a640" class="ly lz it lt b gy ma mb l mc md">a = 5<br/>type(a)  # Output is: int</span></pre><p id="9f95" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以类似的方式，编译函数生成的字节码存储在<code class="fe lq lr ls lt b">code</code>对象中。</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="2768" class="ly lz it lt b gy ma mb l mc md">c = compile("a=a+1", "", "single")<br/>type(c)  # Output is: code</span></pre><p id="a10f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">code对象不仅包含字节码，还包含CPython运行字节码所需的一些其他信息(稍后将讨论)。代码对象可以通过传递给<code class="fe lq lr ls lt b">exec()</code>或<code class="fe lq lr ls lt b">eval()</code>函数来执行或评估。所以我们可以写:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="53f5" class="ly lz it lt b gy ma mb l mc md">exec(compile("print(5)", "", "single"))  # Output is: 5</span></pre><p id="33af" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当你在Python中定义一个函数时，它会为它创建一个代码对象，你可以使用<code class="fe lq lr ls lt b">__code__</code>属性来访问它。例如，我们可以写:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="4c4b" class="ly lz it lt b gy ma mb l mc md">def f(n):<br/>    return n<br/>f.__code__  </span></pre><p id="f551" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">输出将是:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="6aad" class="ly lz it lt b gy ma mb l mc md">&lt;code object f at 0x000001A1E093E660, file "&lt;ipython-input-61-88c7683062d9&gt;", line 1&gt;</span></pre><p id="2651" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">像任何其他对象一样，code对象也有一些属性，要获得存储在code对象中的字节码，可以使用它的<code class="fe lq lr ls lt b">co_code</code>属性:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="01e2" class="ly lz it lt b gy ma mb l mc md">c = compile("print(5)", "", "single")<br/>c.co_code</span></pre><p id="5422" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">输出是:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="62b9" class="ly lz it lt b gy ma mb l mc md">b'e\x00d\x00\x83\x01F\x00d\x01S\x00'</span></pre><p id="4574" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">结果是一个前缀为<code class="fe lq lr ls lt b">b'.</code>的<em class="me">字节文字</em>，它是一个不可变的字节序列，类型为<code class="fe lq lr ls lt b">bytes</code>。每个字节可以有一个0到255的十进制值。所以一个字节文字是一个不可变的0到255之间的整数序列。每个字节可由字符代码与字节值相同的ASCII字符显示，也可由前导<code class="fe lq lr ls lt b">\x</code>后跟两个字符显示。前导<code class="fe lq lr ls lt b">\x</code>转义意味着接下来的两个字符被解释为字符代码的十六进制数字。例如:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="a0ee" class="ly lz it lt b gy ma mb l mc md">print(c.co_code[0])<br/>chr(c.co_code[0])</span></pre><p id="5e87" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">给出:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="2730" class="ly lz it lt b gy ma mb l mc md">101<br/>'e'</span></pre><p id="786f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为第一个元素具有十进制值101，并且可以用字符<code class="fe lq lr ls lt b">e</code>来显示，该字符的ASCII字符代码是101。或者:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="0e02" class="ly lz it lt b gy ma mb l mc md">print(c.co_code[4])<br/>chr(c.co_code[4])</span></pre><p id="5707" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">给出:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="80cb" class="ly lz it lt b gy ma mb l mc md">131<br/>'\x83'</span></pre><p id="24ad" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为第4个元素的十进制值为131。131的十六进制值是83。所以这个字节可以用一个字符码为<code class="fe lq lr ls lt b">\x83</code>的字符来表示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mf"><img src="../Images/301178691c24eb4038d33312180f7124.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XSMRlTXxKxm8BpRteSHBMg.jpeg"/></div></div></figure><p id="023d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些字节序列可以被CPython解释，但是它们对人类不友好。所以我们需要理解这些字节是如何映射到CPython将要执行的实际指令的。在下一节中，我们将把字节码分解成一些对人友好的指令，看看CPython如何执行字节码。</p><p id="5326" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">字节码细节</strong></p><p id="6e40" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="me">在深入细节之前，重要的是要注意字节码的实现细节通常会随着Python版本的不同而变化。因此，您在本文中看到的内容可能并不适用于Python的所有版本。事实上，它包括了3.6版本中发生的变化，一些细节可能对旧版本无效。本文中的代码已经用Python 3.7进行了测试。</em></p><p id="bde5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">字节码可以被认为是Python解释器的一系列指令或低级程序。在3.6版本之后，Python对每条指令使用2个字节。一个字节用于该指令的代码，称为<em class="me">操作码</em>，一个字节保留用于其<em class="me"> </em>参数<em class="me"> </em>，称为<em class="me"> oparg。每个操作码都有一个友好的名字，叫做<em class="me"> opname </em>。字节码指令的一般格式如下:</em></p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="1887" class="ly lz it lt b gy ma mb l mc md">opcode oparg <br/>opcode oparg <br/>  .       <br/>  .<br/>  .</span></pre><p id="e619" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的字节码中已经有了操作码，我们只需要将它们映射到它们对应的opname。有一个名为<code class="fe lq lr ls lt b">dis</code>的模块可以帮助解决这个问题。在这个模块中，有一个名为<code class="fe lq lr ls lt b">opname</code>的列表，它存储了所有的opnames。此列表的第<em class="me"> i </em>个元素给出了操作码等于<em class="me"> i </em>的指令的opname。</p><p id="eaa4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有些指令不需要参数，所以它们会忽略操作码后面的字节。值低于某个数字的操作码会忽略它们的参数。该值存储在<code class="fe lq lr ls lt b">dis.HAVE_ARGUMENT</code>中，目前等于90。于是操作码&gt; = <code class="fe lq lr ls lt b">dis.HAVE_ARGUMENT</code>有了争论，操作码&lt; <code class="fe lq lr ls lt b">dis.HAVE_ARGUMENT</code>忽略。</p><p id="b5fa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，假设我们有一个短字节码<code class="fe lq lr ls lt b">b'd\x00Z\x00d\x01S\x00' </code>，我们想反汇编它。这个字节码代表一个四字节的序列。我们可以很容易地显示它们的十进制值:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="4ee4" class="ly lz it lt b gy ma mb l mc md">bytecode = b'd\x00Z\x00d\x01S\x00'<br/>for byte in bytecode:<br/>    print(byte, end=' ')</span></pre><p id="7ef6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">输出将是:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="a351" class="ly lz it lt b gy ma mb l mc md">100 0 90 0 100 1 83 0</span></pre><p id="b25a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">字节码的前两个字节是<code class="fe lq lr ls lt b">100 0</code>。第一个字节是操作码。要得到它的opname我们可以写(<code class="fe lq lr ls lt b">dis</code>应该先导入):</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="fb54" class="ly lz it lt b gy ma mb l mc md">dis.opname[100]</span></pre><p id="0428" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">而结果是<code class="fe lq lr ls lt b">LOAD_CONST</code>。由于操作码大于<code class="fe lq lr ls lt b">dis.HAVE_ARGUMENT</code>，它有一个oparg，即第二个字节<code class="fe lq lr ls lt b">0</code>。所以<code class="fe lq lr ls lt b">100 0</code>翻译过来就是:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="2c91" class="ly lz it lt b gy ma mb l mc md">LOAD_CONST 0</span></pre><p id="62fc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">字节码中的最后两个字节是<code class="fe lq lr ls lt b">83 0</code>。我们再次写<code class="fe lq lr ls lt b">dis.opname[83]</code>，结果是<code class="fe lq lr ls lt b">RETURN_VALUE</code>。83小于90 ( <code class="fe lq lr ls lt b">dis.HAVE_ARGUMENT</code>)，所以该操作码忽略oparg，并且<code class="fe lq lr ls lt b">83 0</code>被分解为:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="386a" class="ly lz it lt b gy ma mb l mc md">RETURN_VALUE</span></pre><p id="debd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，某些指令的参数可能太大，无法放入默认的一个字节中。有一个特殊的操作码<code class="fe lq lr ls lt b">144</code>来处理这些指令。它的opname是<code class="fe lq lr ls lt b">EXTENDED_ARG</code>，也存放在<code class="fe lq lr ls lt b">dis.EXTENDED_ARG</code>。这个操作码是任何参数大于一个字节的操作码的前缀。例如，假设我们有操作码131(它的opname是<code class="fe lq lr ls lt b">CALL_FUNCTION</code>)，它的oparg需要是260。所以应该是:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="553b" class="ly lz it lt b gy ma mb l mc md">CALL_FUNCTION 260</span></pre><p id="e317" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是，一个字节可以存储的最大数量是255，260不适合一个字节。所以这个操作码的前缀是<code class="fe lq lr ls lt b">EXTENDED_ARG</code>:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="2653" class="ly lz it lt b gy ma mb l mc md">EXTENDED_ARG 1<br/>CALL_FUNCTION 4</span></pre><p id="5e5f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当解释器执行<code class="fe lq lr ls lt b">EXTENDED_ARG</code>时，它的oparg(为1)左移8位，并存储在一个临时变量中。姑且称之为<code class="fe lq lr ls lt b">extended_arg</code>(不要和opname <code class="fe lq lr ls lt b">EXTENDED_ARG</code>混淆):</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="48fc" class="ly lz it lt b gy ma mb l mc md">extened_arg = 1 &lt;&lt; 8  # same as 1 * 256</span></pre><p id="7978" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">于是二进制值<code class="fe lq lr ls lt b">0b1</code>(二进制值1)被转换为<code class="fe lq lr ls lt b">0b100000000</code>。这就像在十进制系统中1乘以256，<code class="fe lq lr ls lt b">extened_arg</code>将等于256。现在我们在<code class="fe lq lr ls lt b">extened_arg</code>中有两个字节。当解释器执行到下一条指令时，使用按位<code class="fe lq lr ls lt b">or</code>将这个双字节值添加到它的oparg(这里是4)中。</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="7605" class="ly lz it lt b gy ma mb l mc md">extened_arg = extened_arg | 4<br/># Same as extened_arg += 4</span></pre><p id="fb40" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就像把oparg的值加到<code class="fe lq lr ls lt b">extened_arg</code>上。所以现在我们有:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="7f61" class="ly lz it lt b gy ma mb l mc md">extened_arg = 256 + 4 = 260</span></pre><p id="905f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该值将作为<code class="fe lq lr ls lt b">CALL_FUNCTION</code>的实际oparg。所以，事实上，</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="0fe0" class="ly lz it lt b gy ma mb l mc md">EXTENDED_ARG 1<br/>CALL_FUNCTION 4</span></pre><p id="e299" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">被解释为:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="3a5f" class="ly lz it lt b gy ma mb l mc md">EXTENDED_ARG 1<br/>CALL_FUNCTION 260  </span></pre><p id="cfc3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于每个操作码，最多允许三个前缀<code class="fe lq lr ls lt b">EXTENDED_ARG</code>，形成一个从两字节到四字节的参数。</p><p id="0829" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，我们可以专注于oparg本身。这是什么意思？实际上，每个oparg的含义取决于它的操作码。如前所述，代码对象存储除字节码之外的一些信息。可以使用代码对象的不同属性来访问这些信息，我们需要其中的一些属性来解释每个oparg的含义。这些属性是:<code class="fe lq lr ls lt b">co_consts</code>、<code class="fe lq lr ls lt b">co_names</code>、<code class="fe lq lr ls lt b">co_varnames</code>、<code class="fe lq lr ls lt b">co_cellvars</code>和<code class="fe lq lr ls lt b">co_freevars</code>。</p><p id="2113" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">代码对象属性</strong></p><p id="3d95" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我将用一个例子来解释这些属性的含义。假设您有这个源代码的代码对象:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="008f" class="ly lz it lt b gy ma mb l mc md"># Listing 1<br/>s = '''<br/>a = 5<br/>b = 'text'<br/>def f(x):<br/>    return x<br/>f(5)<br/>'''<br/>c=compile(s, "", "exec")</span></pre><p id="8b29" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，我们可以检查每个属性中存储了什么:</p><p id="b275" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">1- <code class="fe lq lr ls lt b">co_consts</code>:包含字节码使用的文字的元组。这里<code class="fe lq lr ls lt b">c.co_consts</code>返回:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="d652" class="ly lz it lt b gy ma mb l mc md">(5, 'text', &lt;code object f at 0x00000218C297EF60, file "", line 4&gt;, 'f', None)</span></pre><p id="cd95" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以字面量<code class="fe lq lr ls lt b">5</code>和<code class="fe lq lr ls lt b">'text'</code>以及函数名<code class="fe lq lr ls lt b">'f'</code>都存储在这个元组中。此外，函数<code class="fe lq lr ls lt b">f</code>的主体存储在一个单独的代码对象中，并被视为一个同样存储在该元组中的文字。记住<code class="fe lq lr ls lt b">compile()</code>中的<code class="fe lq lr ls lt b">exec</code>模式生成一个最终返回<code class="fe lq lr ls lt b">None</code>的字节码。这个<code class="fe lq lr ls lt b">None</code>值也被存储为一个文字。事实上，如果你像这样在<code class="fe lq lr ls lt b">eval</code>模式下编译一个表达式:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="8dac" class="ly lz it lt b gy ma mb l mc md">s = "3 * a"<br/>c1 = compile(s, "", "eval")<br/>c1.co_consts   # Output is <!-- -->(3,)</span></pre><p id="0d70" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">None</code>将不再包含在<code class="fe lq lr ls lt b">co_consts</code>元组中。原因是这个表达式返回它的最终值而不是<code class="fe lq lr ls lt b">None</code>。</p><p id="1e09" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你试图获取一个函数的目标代码的<code class="fe lq lr ls lt b">co_const</code>,比如:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="0dcf" class="ly lz it lt b gy ma mb l mc md">def f(x):<br/>    a = x * 2<br/>    return a<br/>f.__code__.co_consts</span></pre><p id="72fd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">结果会是<code class="fe lq lr ls lt b">(None, 2)</code>。事实上，函数的默认返回值是<code class="fe lq lr ls lt b">None</code>，并且总是作为文字添加。正如我后面解释的，为了提高效率，Python不会检查你是否总是要到达一个<code class="fe lq lr ls lt b">return</code>语句，所以<code class="fe lq lr ls lt b">None</code>总是被添加为默认返回值。</p><p id="301f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">2- <code class="fe lq lr ls lt b">co_names</code>:包含字节码使用的名称的元组，可以是全局变量、函数和类，也可以是从对象加载的属性。例如，对于清单1中的目标代码，<code class="fe lq lr ls lt b">c.co_names</code>给出了:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="5c02" class="ly lz it lt b gy ma mb l mc md">('a', 'b', 'f')</span></pre><p id="be75" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">3- <code class="fe lq lr ls lt b">co_varnames</code>:包含字节码使用的本地名称的元组(首先是参数，然后是本地变量)。如果我们对清单1的对象代码进行尝试，它会给出一个空元组。原因是局部名称是在函数内部定义的，清单1中的函数是作为一个单独的代码对象存储的，所以它的局部变量不会包含在这个元组中。为了访问一个函数的局部变量，我们应该为那个函数的代码对象使用这个属性。所以我们先写这段源代码:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="1076" class="ly lz it lt b gy ma mb l mc md">def f(x):<br/>    z = 3<br/>    t = 5<br/>    def g(y):<br/>        return t*x + y<br/>    return g<br/>a = 5<br/>b = 1<br/>h = f(a)</span></pre><p id="f49f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在<code class="fe lq lr ls lt b">f.__code__</code>给出<code class="fe lq lr ls lt b">f</code>的代码对象，<code class="fe lq lr ls lt b">f.__code__.co_varnames</code>给出:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="dbcb" class="ly lz it lt b gy ma mb l mc md">('x', 'z', 'g')</span></pre><p id="c0c5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为什么不包括<code class="fe lq lr ls lt b">t</code>？原因是<code class="fe lq lr ls lt b">t</code>不是<code class="fe lq lr ls lt b">f</code>的局部变量。它是一个非局部变量，因为它是由<code class="fe lq lr ls lt b">f</code>中的闭包<code class="fe lq lr ls lt b">g</code>访问的。实际上，<code class="fe lq lr ls lt b">x</code>也是一个非局部变量，但既然是函数的自变量，那么它总是包含在这个元组中。要了解更多关于闭包和非局部变量的知识，你可以参考这篇文章。</p><p id="f189" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">4- <code class="fe lq lr ls lt b">co_cellvars</code>:包含非局部变量名称的元组。这些是由内部函数访问的函数的局部变量。所以<code class="fe lq lr ls lt b">f.__code__.co_cellvars</code>给出:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="e1a7" class="ly lz it lt b gy ma mb l mc md">('t', 'x')</span></pre><p id="8fec" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">5- <code class="fe lq lr ls lt b">co_freevars</code> : <strong class="kw iu"> </strong>包含自由变量名称的元组。自由变量是外部函数的局部变量，由内部函数访问。所以这个属性应该和闭包<code class="fe lq lr ls lt b">h</code>的代码对象一起使用。现在<code class="fe lq lr ls lt b">h.__code__.co_freevars</code>给出了相同的结果:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="830c" class="ly lz it lt b gy ma mb l mc md">('t', 'x')</span></pre><p id="4170" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们已经熟悉了这些属性，我们可以回到opargs。每个oparg的含义取决于它的操作码。我们有不同类别的操作码，每个类别的oparg都有不同的含义。在<code class="fe lq lr ls lt b">dis</code>模块中，有一些列表给出了每个类别的操作码:</p><p id="ae68" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">1- <code class="fe lq lr ls lt b">dis.hasconst</code>:此列表等于【100】。所以只有操作码100(它的opname是LOAD_CONST)属于<code class="fe lq lr ls lt b">hasconst</code>的范畴。这个操作码的oparg给出了<code class="fe lq lr ls lt b">co_consts</code>元组中一个元素的索引。例如，在清单1的字节码中，如果我们有:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="90ed" class="ly lz it lt b gy ma mb l mc md">LOAD_CONST  1</span></pre><p id="cdfe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那么oparg就是索引为1的<code class="fe lq lr ls lt b">co_consts</code>的元素。所以我们要把<code class="fe lq lr ls lt b">1</code>换成<code class="fe lq lr ls lt b">co_consts[1]</code>等于<code class="fe lq lr ls lt b">'text'</code>。因此该指令将被解释为:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="fb0b" class="ly lz it lt b gy ma mb l mc md">LOAD_CONST  <!-- -->'text'</span></pre><p id="bdec" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">类似地，在<code class="fe lq lr ls lt b">dis</code>模块中有一些其他的列表定义操作码的其他类别:</p><p id="f8d6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">2- <code class="fe lq lr ls lt b">dis.hasname</code>:这个列表中操作码的oparg是<code class="fe lq lr ls lt b">co_names</code>中一个元素的索引</p><p id="71dd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">3- <code class="fe lq lr ls lt b">dis.haslocal</code>:该列表中操作码的oparg是<code class="fe lq lr ls lt b">co_varnames</code>中一个元素的索引</p><p id="9ea2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">4- <code class="fe lq lr ls lt b">dis.hasfree</code>:该列表中操作码的oparg是<code class="fe lq lr ls lt b">co_cellvars + co_freevars</code>中一个元素的索引</p><p id="3a7d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">5- <code class="fe lq lr ls lt b">dis.hascompare</code>:这个列表中操作码的oparg是元组<code class="fe lq lr ls lt b">dis.cmp_op</code>的一个元素的索引。这个元组包含比较和成员操作符，如<code class="fe lq lr ls lt b">&lt;</code>或<code class="fe lq lr ls lt b">==</code></p><p id="fee7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">6- <code class="fe lq lr ls lt b">dis.hasjrel</code>:这个列表中操作码的oparg应该替换为<code class="fe lq lr ls lt b">offset + 2 + oparg</code>，其中<code class="fe lq lr ls lt b">offset</code>是字节码序列中代表操作码的字节的索引。</p><p id="8fe3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">code对象还有一个更重要的属性应该在这里讨论。它被称为<code class="fe lq lr ls lt b">co_lnotab</code>，存储字节码的行号信息。这是一个存储在字节文字中的有符号字节数组，用于将字节码偏移量映射到源代码行号。我举个例子解释一下。假设您的源代码只有三行，并且已经被编译成24字节的字节码:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="bd50" class="ly lz it lt b gy ma mb l mc md">1        0 LOAD_CONST             0 <br/>         2 STORE_NAME             0 <br/><br/>2        4 LOAD_NAME              0 <br/>         6 LOAD_CONST             1 <br/>         8 INPLACE_ADD             <br/>        10 STORE_NAME             0 <br/><br/>3       12 LOAD_NAME              1 <br/>        14 LOAD_NAME              0 <br/>        16 CALL_FUNCTION          1 <br/>        18 POP_TOP                 <br/>        20 LOAD_CONST             2 <br/>        22 RETURN_VALUE</span></pre><p id="c32c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们有了从字节码偏移量到行号的映射，如下表所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mh"><img src="../Images/fa2f00af3a39d78fb32f682aeb7e7268.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CQrpODH_ne3T6MRJf_bniQ.jpeg"/></div></div></figure><p id="b362" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">字节码偏移量总是从0开始。code对象有一个名为<code class="fe lq lr ls lt b">co_firstlineno</code>的属性，它给出了偏移量0的行号。对于这个例子来说<code class="fe lq lr ls lt b">co_firstlineno</code>等于1。Python只存储从一行到下一行的增量(不包括第一行)，而不是存储偏移量和行号。所以前面的表格变成了:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mi"><img src="../Images/9c3d2302a2faf550e01737c73782b2d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0mHACc3WhO64RbsmHdBM9w.jpeg"/></div></div></figure><p id="1441" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这两个增量列按如下顺序压缩在一起:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="b2b6" class="ly lz it lt b gy ma mb l mc md">4 1 8 1 </span></pre><p id="56ff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">每个数字存储在一个字节中，整个序列作为一个字节文字存储在代码对象的<code class="fe lq lr ls lt b">co_lnotab</code>中。因此，如果您检查<code class="fe lq lr ls lt b">co_lnotab</code>的值，您会得到:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="8a9d" class="ly lz it lt b gy ma mb l mc md">b'\x04\x01\x08\x01'</span></pre><p id="862d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它是前一个序列的字节数。因此，通过拥有属性<code class="fe lq lr ls lt b">co_lnotab</code>和<code class="fe lq lr ls lt b">co_firstlineno</code>，您可以检索从字节码偏移到源代码行号的映射。<code class="fe lq lr ls lt b">co_lnotab</code>是一个有符号的字节序列。所以其中的每个有符号字节可以取-128到127之间的值(这些值仍然存储在取0到255的字节中。但是介于128和255之间的值被认为是负数)。负增量意味着行号在减少(这个特性用在优化器中)。但是如果行增量大于127会怎么样呢？在这种情况下，行增量将被分成127和一些额外的字节，这些额外的字节将以零偏移增量存储(如果它小于-128，它将被分成-128和一些额外的字节，偏移增量为零)。例如，假设字节码偏移量与行号的关系如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/0c8481f69686f78b99b611394933ec10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VwExuAQk55XV_YQ-XgRG4w.jpeg"/></div></div></figure><p id="3734" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那么偏移增量与行号增量之比应为:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mk"><img src="../Images/7a601c4af810cafb1862935b376f9878.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nNVTLqiyf-zqcnD2bVDSNQ.jpeg"/></div></div></figure><p id="20b1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">139等于127 + 12。所以前一行应该写成:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mk"><img src="../Images/1176705e3aaafc76409cf11d06ed07ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h5B7SZ6FCxCMCIbAlrItdg.jpeg"/></div></div></figure><p id="3ec8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">并且应该存储为<code class="fe lq lr ls lt b">8 127 0 12</code>。所以<code class="fe lq lr ls lt b">co_lnotab</code>的值会是:<code class="fe lq lr ls lt b">b'\x08\x7f\x00\x0c'</code>。</p><p id="4bb8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">反汇编字节码</strong></p><p id="26e9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们已经熟悉了字节码结构，我们可以编写一个简单的反汇编程序。我们首先编写一个生成器函数来解包每个指令，并生成偏移量、操作码和oparg:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="0a26" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个函数从字节码中读取下一对字节。第一个字节是操作码。通过将该操作码与<code class="fe lq lr ls lt b">dis.HAVE_ARGUMENT</code>进行比较，该函数决定是将第二个字节作为oparg还是忽略它。使用按位or ( <code class="fe lq lr ls lt b">|</code>)将<code class="fe lq lr ls lt b">extended_arg</code>的值添加到oparg。最初，它为零，对oparg没有影响。如果操作码等于<code class="fe lq lr ls lt b">dis.EXTENDED_ARG</code>，它的oparg将左移8位，并存储在一个名为<code class="fe lq lr ls lt b">extended_arg</code>的临时变量中。</p><p id="77f0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在下一次迭代中，这个临时变量将被添加到下一个oparg中，并向其中添加一个字节。如果下一个操作码再次是<code class="fe lq lr ls lt b">dis.EXTENDED_ARG</code>，则该过程继续，并且每次将一个字节加到<code class="fe lq lr ls lt b">extended_arg</code>。最后，当它到达一个不同的操作码时，<code class="fe lq lr ls lt b">extended_arg</code>将被加到它的oparg并被设置回零。</p><p id="83a0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">find_linestarts</code>函数返回一个字典，其中包含每个字节码偏移量的源代码行号。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="fe85" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它首先将<code class="fe lq lr ls lt b">co_lnotab</code>字节文字分成两个序列。一个是偏移增量，另一个是行号增量。偏移<code class="fe lq lr ls lt b">0</code>的行号在<code class="fe lq lr ls lt b">co_firstlineno</code>中。将这两个数字相加得到字节码偏移量及其对应的行号。如果行号增量等于或大于128 (0x80)，它将被视为减量。</p><p id="e618" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">get_argvalue</code>函数返回每个oparg的友好含义。它首先检查操作码属于哪个类别，然后判断oparg指的是什么。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="6bb4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">findlabels</code>函数找到字节码中所有作为跳转目标的偏移量，并返回这些偏移量的列表。跳转目标将在下一节讨论。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="3812" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们可以使用所有这些函数来反汇编字节码。<code class="fe lq lr ls lt b">dissassemble</code>函数获取一个代码对象并将其反汇编:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="c47a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它将首先解包代码对象的字节码中每对字节的偏移量、操作码和oparg。然后，它找到相应的源代码行号，并检查偏移量是否是跳转目标。最后，它查找opname和oparg的含义，并打印所有信息。如前所述，每个函数定义都存储在一个单独的代码对象中。所以在最后，函数递归地调用自己来反汇编字节码中的所有函数定义。下面是一个使用这个函数的例子。最初，我们有这样的源代码:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="373e" class="ly lz it lt b gy ma mb l mc md">a=0<br/>while a&lt;10:<br/>    print(a)<br/>    a += 1</span></pre><p id="6342" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们首先将它存储在一个字符串中，并编译它以获得目标代码。然后我们使用<code class="fe lq lr ls lt b">disassemble</code>函数反汇编它的字节码:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="f3d0" class="ly lz it lt b gy ma mb l mc md">s='''a=0<br/>while a&lt;10:<br/>    print(a)<br/>    a += 1<br/>'''<br/>c=compile(s, "", "exec")<br/>disassemble(c)</span></pre><p id="b784" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">输出是:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="fba8" class="ly lz it lt b gy ma mb l mc md">1         0 LOAD_CONST               0 (0)<br/>          2 STORE_NAME               0 (a)<br/><br/>2         4 SETUP_LOOP              28 (to 34)<br/>    &gt;&gt;    6 LOAD_NAME                0 (a)<br/>          8 LOAD_CONST               1 (10)<br/>         10 COMPARE_OP               0 (&lt;)<br/>         12 POP_JUMP_IF_FALSE       32 <br/><br/>3        14 LOAD_NAME                1 (print)<br/>         16 LOAD_NAME                0 (a)<br/>         18 CALL_FUNCTION            1 <br/>         20 POP_TOP                    <br/><br/>4        22 LOAD_NAME                0 (a)<br/>         24 LOAD_CONST               2 (1)<br/>         26 INPLACE_ADD                <br/>         28 STORE_NAME               0 (a)<br/>         30 JUMP_ABSOLUTE            6 <br/>    &gt;&gt;   32 POP_BLOCK                  <br/>    &gt;&gt;   34 LOAD_CONST               3 (None)<br/>         36 RETURN_VALUE</span></pre><p id="5eec" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以4行源代码被转换成38字节的字节码或19行字节码。在下一节中，我将解释这些指令的含义以及CPython将如何解释它们。</p><p id="4296" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">模块<code class="fe lq lr ls lt b">dis</code>有一个名为<code class="fe lq lr ls lt b">dis()</code>的函数，同样可以反汇编代码对象。实际上，本文中的<code class="fe lq lr ls lt b">disassmble</code>函数是<code class="fe lq lr ls lt b">dis.dis</code>函数的简化版。因此，我们可以写<code class="fe lq lr ls lt b">dis.dis(c)</code>来得到类似的输出，而不是写<code class="fe lq lr ls lt b">disassemble(c)</code>。</p><p id="744d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">反汇编一个pyc文件</strong></p><p id="3d93" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如前所述，编译源代码时，字节码存储在一个<code class="fe lq lr ls lt b">pyc</code>文件中。这个字节码可以用类似的方式反汇编。但是，需要提到的是，<code class="fe lq lr ls lt b">pyc</code>文件包含一些元数据和<a class="ae mg" href="https://docs.python.org/2/library/marshal.html" rel="noopener ugc nofollow" target="_blank"> <em class="me">编组</em> </a>格式的代码对象。封送格式用于Python的内部对象序列化。元数据的大小取决于Python版本，对于版本3.7，它是16个字节。所以当你读取<code class="fe lq lr ls lt b">pyc</code>文件时，首先你应该读取元数据，然后使用<code class="fe lq lr ls lt b">marshal</code>模块加载代码对象。例如，要反汇编<code class="fe lq lr ls lt b">__pycache__</code>文件夹中名为<code class="fe lq lr ls lt b">u1.cpython-37.pyc</code>的<code class="fe lq lr ls lt b">pyc</code>文件，我们可以写:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ml mm l"/></div></figure><h1 id="7524" class="mn lz it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">字节码操作</h1><p id="db40" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">到目前为止，我们已经学习了如何反汇编字节码指令。我们现在可以关注这些指令的含义以及它们是如何被CPython执行的。Python的默认实现CPython使用基于<em class="me">栈的</em>虚拟机。所以首先我们应该熟悉堆栈。</p><p id="7447" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">堆栈和堆</strong></p><p id="4fb1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">栈是一种具有后进先出顺序的数据结构。它有两个主要操作:</p><ul class=""><li id="4bb5" class="nj nk it kw b kx ky la lb ld nl lh nm ll nn lp no np nq nr bi translated">push:将元素添加到堆栈中</li><li id="6188" class="nj nk it kw b kx ns la nt ld nu lh nv ll nw lp no np nq nr bi translated">pop:删除最近添加的元素</li></ul><p id="c838" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，添加或推入堆栈的最后一个元素是要移除或弹出的第一个元素。使用堆栈存储数据的好处是内存是为你管理的。读取和写入堆栈非常快，但是，堆栈的大小是有限的。</p><p id="53cc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Python中的数据表示为存储在私有堆上的对象。与堆栈相比，访问堆上的数据要慢一些，但是，堆的大小只受虚拟内存大小的限制。heap的元素彼此之间没有依赖关系，可以随时随机访问。Python中的一切都是对象，对象总是存储在堆中。它只是存储在堆栈中的对象的引用(或指针)。</p><p id="21fe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">CPython使用<em class="me">调用栈</em>来运行Python程序。在Python中调用一个函数时，一个新的<em class="me">框架</em> <strong class="kw iu"> </strong>被推送到调用栈上，每次函数调用返回时，其框架被弹出。程序运行的模块有一个最底层的框架，称为全局框架或模块框架。</p><p id="1d72" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">每一帧都有一个<em class="me">评估栈</em>，在那里执行Python函数。函数参数及其局部变量被压入这个计算堆栈。CPython使用评估堆栈来存储任何操作所需的参数以及这些操作的结果。在开始该操作之前，所有必需的参数都被推送到评估堆栈上。然后操作开始并弹出它的参数。当操作完成时，它将结果推回计算堆栈。</p><p id="efbc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所有对象都存储在堆中，框架中的评估堆栈处理对它们的引用。因此，对这些对象的引用可以被临时推到计算堆栈上，以供后面的操作使用。Python的大部分字节码指令都是在当前框架中操作求值栈。在本文中，每当我们谈到堆栈时，它指的是当前框架中的评估堆栈或全局框架中的评估堆栈，如果我们不在任何函数的范围内。</p><p id="d121" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我从一个简单的例子开始，反汇编以下源代码的字节码:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="f2ff" class="ly lz it lt b gy ma mb l mc md">a=1<br/>b=2<br/>c=a+b</span></pre><p id="4788" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为此，我们可以写:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="598d" class="ly lz it lt b gy ma mb l mc md">s='''a=1<br/>b=2<br/>c=a+b<br/>'''<br/>c=compile(s, "", "exec")<br/>disassemble(c)</span></pre><p id="2e24" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们得到了:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="9268" class="ly lz it lt b gy ma mb l mc md">1         0 LOAD_CONST               0 (1)<br/>          2 STORE_NAME               0 (a)<br/><br/>2         4 LOAD_CONST               1 (2)<br/>          6 STORE_NAME               1 (b)<br/><br/>3         8 LOAD_NAME                0 (a)<br/>         10 LOAD_NAME                1 (b)<br/>         12 BINARY_ADD                 <br/>         14 STORE_NAME               2 (c)<br/>         16 LOAD_CONST               2 (None)<br/>         18 RETURN_VALUE</span></pre><p id="8d53" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，我们可以检查代码对象的其他一些属性:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="cf26" class="ly lz it lt b gy ma mb l mc md">c.co_consts<br/># output is:  (1, 2, None)<br/>c.co_names<br/># output is:  ('a', 'b', 'c')</span></pre><p id="f909" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里代码在模块中运行，所以我们在全局框架中。第一个指令是<code class="fe lq lr ls lt b">LOAD_CONST 0</code>。指令</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="6b28" class="ly lz it lt b gy ma mb l mc md"><strong class="lt iu">LOAD_CONST </strong><em class="me">consti</em></span></pre><p id="5d56" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将<code class="fe lq lr ls lt b">co_consts[consti]</code>的值推送到堆栈上。所以我们将<code class="fe lq lr ls lt b">co_consts[0] </code>(等于<code class="fe lq lr ls lt b">1</code>)压入堆栈。</p><p id="6e0b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">值得注意的是，stack使用对对象的引用。因此，每当我们说一个指令将一个对象或对象的值压入堆栈时，就意味着压入了对该对象的引用(或指针)。当一个对象或它的值被弹出堆栈时，也会发生同样的事情。再次弹出它的引用。解释器知道如何使用这些引用来检索或存储对象的数据。</p><p id="6caa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">指令</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="2831" class="ly lz it lt b gy ma mb l mc md"><strong class="lt iu">STORE_NAME </strong><em class="me">namei</em></span></pre><p id="ce5a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">弹出堆栈的顶部，并将其存储到一个对象中，该对象的引用存储在代码对象的<code class="fe lq lr ls lt b">co_names[namei]</code>中。所以<code class="fe lq lr ls lt b">STORE_NAME 0</code>在栈顶弹出元素(也就是<code class="fe lq lr ls lt b">1</code>)并存储在一个对象中。对这个对象的引用是<code class="fe lq lr ls lt b">co_names[0]</code>也就是<code class="fe lq lr ls lt b">a</code>。这两条指令是源代码中<code class="fe lq lr ls lt b">a=1</code>的字节码等价物。<code class="fe lq lr ls lt b">b=2</code>被类似地转换，现在解释器已经创建了对象<code class="fe lq lr ls lt b">a</code>和<code class="fe lq lr ls lt b">b</code>。源代码的最后一行是<code class="fe lq lr ls lt b">c=a+b</code>。指令</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="b6a5" class="ly lz it lt b gy ma mb l mc md"><strong class="lt iu">BINARY_ADD</strong></span></pre><p id="324b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">弹出堆栈顶部的两个元素(<code class="fe lq lr ls lt b">1</code>和<code class="fe lq lr ls lt b">2</code>)，将它们相加，并将结果(<code class="fe lq lr ls lt b">3</code>)推送到堆栈上。所以现在<code class="fe lq lr ls lt b">3</code>在栈顶。之后<code class="fe lq lr ls lt b">STORE_NAME 2</code>将栈顶弹出到本地对象(引用的)<code class="fe lq lr ls lt b">c</code>。现在记住<code class="fe lq lr ls lt b">exec </code>模式下的<code class="fe lq lr ls lt b">compile</code>将源代码编译成最终返回<code class="fe lq lr ls lt b">None</code>的字节码。指令<code class="fe lq lr ls lt b">LOAD_CONST 2</code>将<code class="fe lq lr ls lt b">co_consts[2]=None</code>推到堆栈上，指令</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="5bfd" class="ly lz it lt b gy ma mb l mc md"><strong class="lt iu">RETURN_VALUE</strong></span></pre><p id="19e3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将堆栈的顶部返回给函数的调用方。当然，这里我们是在模块范围内，没有调用函数，所以<code class="fe lq lr ls lt b">None</code>是最终结果，它保留在全局堆栈的顶部。图1显示了偏移量为0到14的所有字节码操作(同样应该注意的是，对象的引用被推送到堆栈上，而不是对象或它们的值。该图没有明确示出)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/e064ddc30e2c06d2bd206abb1a82b8d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ad3u9avB6W-Q2X_6JgIaLg.jpeg"/></div></div></figure><p id="3f07" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">函数、全局和局部变量</strong></p><p id="5700" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在让我们看看如果我们也有一个函数会发生什么。我们将分解源代码的字节码，它有一个功能:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="a14e" class="ly lz it lt b gy ma mb l mc md">#Listing 2<br/>s='''a = 1<br/>b = 2<br/>def f(x):<br/>    global b<br/>    b = 3<br/>    y = x + 1<br/>    return y <br/>f(4)<br/>print(a)<br/>'''<br/>c=compile(s, "", "exec")<br/>disassemble(c)</span></pre><p id="5fdc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">输出是:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="79f4" class="ly lz it lt b gy ma mb l mc md">1         0 LOAD_CONST               0 (1)<br/>          2 STORE_NAME               0 (a)<br/><br/>2         4 LOAD_CONST               1 (2)<br/>          6 STORE_GLOBAL             1 (b)<br/><br/>3         8 LOAD_CONST               2 (&lt;code object f at 0x00000218C2E758A0, file "", line 3&gt;)<br/>         10 LOAD_CONST               3 ('f')<br/>         12 MAKE_FUNCTION            0 <br/>         14 STORE_NAME               2 (f)<br/><br/>8        16 LOAD_NAME                2 (f)<br/>         18 LOAD_CONST               4 (4)<br/>         20 CALL_FUNCTION            1 <br/>         22 POP_TOP                    <br/><br/>9        24 LOAD_NAME                3 (print)<br/>         26 LOAD_NAME                0 (a)<br/>         28 CALL_FUNCTION            1 <br/>         30 POP_TOP                    <br/>         32 LOAD_CONST               5 (None)<br/>         34 RETURN_VALUE               <br/><br/>Disassembly of&lt;code object f at 0x00000218C2E758A0, file "", line 3&gt;:<br/><br/>5         0 LOAD_CONST               1 (3)<br/>          2 STORE_GLOBAL             0 (b)<br/><br/>6         4 LOAD_FAST                0 (x)<br/>          6 LOAD_CONST               2 (1)<br/>          8 BINARY_ADD                 <br/>         10 STORE_FAST               1 (y)<br/><br/>7        12 LOAD_FAST                1 (y)<br/>         14 RETURN_VALUE</span></pre><p id="2a8b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，我们可以检查代码对象的其他一些属性:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="7758" class="ly lz it lt b gy ma mb l mc md">c.co_consts<br/># output is:  (1, 2, &lt;code object f at 0x00000218C2E758A0, file "", line 3&gt;, 'f', 4, None)</span><span id="e80f" class="ly lz it lt b gy ny mb l mc md">c.co_names<br/># Output is: ('a', 'b', 'f', 'print')</span></pre><p id="a322" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在第一行(偏移量0和2 ),首先使用<code class="fe lq lr ls lt b">LOAD_CONST 0</code>将常量<code class="fe lq lr ls lt b">1</code>推入全局帧的评估堆栈。然后<code class="fe lq lr ls lt b">STORE_NAME 0</code>弹出并存储在一个对象中。</p><p id="c327" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在第二行中，使用<code class="fe lq lr ls lt b">LOAD_CONST 1</code>将常量<code class="fe lq lr ls lt b">2</code>推入堆栈。但是，使用不同的opname将其分配给引用。指令</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="82d5" class="ly lz it lt b gy ma mb l mc md"><strong class="lt iu">STORE_GLOBAL </strong><em class="me">namei</em></span></pre><p id="5ce4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">弹出栈顶并将其存储到一个对象中，该对象的引用存储在<code class="fe lq lr ls lt b">co_names[namei]</code>中。所以<code class="fe lq lr ls lt b">2</code>存储在<code class="fe lq lr ls lt b">b</code>引用的对象中。这被认为是一个全局变量。但是为什么这个指令没有用于<code class="fe lq lr ls lt b">a</code>？原因是<code class="fe lq lr ls lt b">a</code>是函数<code class="fe lq lr ls lt b">f</code>内部的全局变量。如果变量是在模块范围内定义的，并且没有函数访问它，那么它将通过<code class="fe lq lr ls lt b">STORE_NAME</code>和<code class="fe lq lr ls lt b">LOAD_NAME</code>被存储和加载。在模块范围内，全局变量和局部变量没有区别。</p><p id="87fc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">第三行定义了函数<code class="fe lq lr ls lt b">f</code>。函数体在一个名为<code class="fe lq lr ls lt b">&lt;code object f at 0x00000218C2E758A0, file "", line 3&gt;</code>的单独代码对象中编译，并被推送到堆栈上。然后，一个函数名为<code class="fe lq lr ls lt b">'f'</code>的字符串对象被推送到堆栈上(事实上，对它们的引用被推送到堆栈上)。指令</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="1f09" class="ly lz it lt b gy ma mb l mc md"><strong class="lt iu">MAKE_FUNCTION </strong><em class="me">argc</em></span></pre><p id="9b14" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">用于创建函数。它需要一些应该被推到堆栈上的参数。函数名应该在栈顶，函数的代码对象应该在栈底。在这个例子中，它的oparg是零，但是它可以有其他值。例如，如果函数定义有一个关键字参数，如:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="12eb" class="ly lz it lt b gy ma mb l mc md">def f(x=5):<br/>    global b<br/>    b = 3<br/>    y = x + 1<br/>    return y</span></pre><p id="0180" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那么第2行的反汇编字节码应该是:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="d7fd" class="ly lz it lt b gy ma mb l mc md">2         4 LOAD_CONST               5 ((5,))<br/>          6 LOAD_CONST               1 (&lt;code object f at 0x00000218C2E75AE0, file "", line 2&gt;)<br/>          8 LOAD_CONST               2 ('f')<br/>         10 MAKE_FUNCTION            1</span></pre><p id="f9ca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">MAKE_FUNCTION</code>的oparg<code class="fe lq lr ls lt b">1</code>表示该函数有一些关键字参数，一个包含默认值的tuple应该在该函数的code对象(这里是<code class="fe lq lr ls lt b">(5,)</code>)之前被推送到堆栈上。创建函数后，<code class="fe lq lr ls lt b">MAKE_FUNCTION</code>将新的函数对象推送到堆栈上。然后在偏移量14处，<code class="fe lq lr ls lt b">STORE_NAME 2</code>弹出函数对象，并存储为<code class="fe lq lr ls lt b">f</code>引用的函数对象。</p><p id="d8a2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在让我们看看从第5行开始的<code class="fe lq lr ls lt b">f(x)</code>的代码对象内部。语句<code class="fe lq lr ls lt b">global a</code>不会转换成字节码中的独立指令。它只是指导编译器将<code class="fe lq lr ls lt b">a</code>视为一个全局变量。所以<code class="fe lq lr ls lt b">STORE_GLOBAL 0</code>将被用来改变它的值。指令</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="1a32" class="ly lz it lt b gy ma mb l mc md"><strong class="lt iu">LOAD_GLOBAL </strong><em class="me">namei</em></span></pre><p id="dbea" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将对由<code class="fe lq lr ls lt b">co_names[namei]</code>引用的对象的引用推送到堆栈上。然后使用<code class="fe lq lr ls lt b">STORE_GLOBAL 0</code>将其存储在<code class="fe lq lr ls lt b">b</code>中。指令</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="928e" class="ly lz it lt b gy ma mb l mc md"><strong class="lt iu">LOAD_FAST </strong><em class="me">var_num</em></span></pre><p id="8de1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将引用为<code class="fe lq lr ls lt b">co_varnames[var_num]</code>的对象的引用推送到堆栈上。在函数<code class="fe lq lr ls lt b">f</code>的代码对象中，属性<code class="fe lq lr ls lt b">co_varnames</code>包含:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="eba7" class="ly lz it lt b gy ma mb l mc md">('x', 'y')</span></pre><p id="8420" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此<code class="fe lq lr ls lt b">LOAD_FAST 0</code>将<code class="fe lq lr ls lt b">x</code>推到堆栈上。然后<code class="fe lq lr ls lt b">1</code>被推到堆栈上。<code class="fe lq lr ls lt b">BINARY_ADD</code>弹出<code class="fe lq lr ls lt b">x</code>和<code class="fe lq lr ls lt b">1</code>，将它们相加，并将结果推送到堆栈上。指令</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="6de2" class="ly lz it lt b gy ma mb l mc md"><strong class="lt iu">STORE_FAST </strong><em class="me">var_num</em></span></pre><p id="84bb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">弹出堆栈的顶部，并将其存储到一个对象中，该对象的引用存储在<code class="fe lq lr ls lt b">co_varnames[var_num]</code>中。所以<code class="fe lq lr ls lt b">STORE_FAST 1</code>弹出结果并存储在一个引用为<code class="fe lq lr ls lt b">y</code>的对象中。<code class="fe lq lr ls lt b">LOAD_FAST</code>和<code class="fe lq lr ls lt b">STORE_FAST</code>用于函数的局部变量。因此它们不在模块范围内使用。另一方面，<code class="fe lq lr ls lt b">LOAD_GLOBAL</code>和<code class="fe lq lr ls lt b">STORE_GLOBAL</code>用于函数内部访问的全局变量。最后，<code class="fe lq lr ls lt b">LOAD_FAST 1</code>将把<code class="fe lq lr ls lt b">y</code>的值推到栈顶，而<code class="fe lq lr ls lt b">RETURN_VALUE</code>将把它返回给模块函数的调用者。</p><p id="9eda" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是这个函数怎么调用呢？如果你看第8行的字节码，首先，<code class="fe lq lr ls lt b">LOAD_NAME</code> <code class="fe lq lr ls lt b">2</code>将引用为<code class="fe lq lr ls lt b">f</code>的函数对象推送到堆栈上。<code class="fe lq lr ls lt b">LOAD_CONST 4</code>将其参数(<code class="fe lq lr ls lt b">4</code>)推送到堆栈上。指令</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="a244" class="ly lz it lt b gy ma mb l mc md"> <strong class="lt iu">CALL_FUNCTION </strong><em class="me">argc</em></span></pre><p id="8c72" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">用位置参数调用可调用对象。它的oparg，<em class="me"> argc </em>表示位置参数的数量。堆栈的顶部包含位置参数，最右边的参数位于顶部。参数下面是要调用的函数可调用对象。</p><p id="1e21" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">CALL_FUNCTION</code>首先从堆栈中弹出所有的参数和可调用对象。然后，它将在调用堆栈上分配一个新的框架，为函数调用填充局部变量，并在该框架内执行函数的字节码。一旦完成，框架将弹出调用堆栈，在前面的框架中，函数的返回值将被推到计算堆栈的顶部。如果没有前一个框架，它将被推到全局框架的评估堆栈的顶部。</p><p id="c3f7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们的例子中，我们只有一个位置参数，所以指令将是<code class="fe lq lr ls lt b">CALL_FUNCTION 1</code>。在那之后，指令</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="02b7" class="ly lz it lt b gy ma mb l mc md"><strong class="lt iu">POP_TOP</strong></span></pre><p id="dfb5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将项目弹出到堆栈顶部。这是因为我们不再需要函数的返回值。图2显示了偏移量为16到22的所有字节码操作。<code class="fe lq lr ls lt b">f(x)</code>中的字节码指令用红色显示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/cbf6429e38d90ce49e8bc2e3b7feaec9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*saaYgv-uLbSUh3IP9Q_zQw.jpeg"/></div></div><p class="oa ob gj gh gi oc od bd b be z dk translated">图2</p></figure><p id="f88e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">内置函数</strong></p><p id="e446" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在清单2的反汇编字节码的第9行，我们想要<code class="fe lq lr ls lt b">print(a)</code>。<code class="fe lq lr ls lt b">print</code>也是函数，不过是内置的Python函数。函数名是对其可调用对象的引用。因此，首先将它推送到堆栈上，然后再推它的参数。最后，它将被称为使用<code class="fe lq lr ls lt b">CALL_FUNCTION</code>。<code class="fe lq lr ls lt b">print</code>会返回<code class="fe lq lr ls lt b">None</code>，之后返回值会弹出堆栈。</p><p id="d8c1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Python使用其内置函数来创建数据结构。例如，下面一行:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="bae5" class="ly lz it lt b gy ma mb l mc md">a = [1,2,3]</span></pre><p id="5d94" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将被转换为:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="f800" class="ly lz it lt b gy ma mb l mc md">1         0 LOAD_CONST               0 (1)<br/>          2 LOAD_CONST               1 (2)<br/>          4 LOAD_CONST               2 (3)<br/>          6 BUILD_LIST               3 <br/>          8 STORE_NAME               0 (a)</span></pre><p id="c6b1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最初，列表中的每个元素都被推送到堆栈上。然后是指令</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="8eee" class="ly lz it lt b gy ma mb l mc md"><strong class="lt iu">BUILD_LIST </strong><em class="me">count</em></span></pre><p id="d13e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用堆栈中的<em class="me">计数</em>项创建列表，并将结果列表对象推送到堆栈上。最后，栈上的对象将被弹出并存储在堆上，而<code class="fe lq lr ls lt b">a</code>将成为它的引用。</p><p id="8845" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> EXTENDED_ARG </strong></p><p id="4fe7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如前所述，一些指令的参数太大，无法放入默认的一个字节，它们将被加上前缀指令<code class="fe lq lr ls lt b">EXTENDED_ARG</code>。这里有一个例子。假设我们想要打印260个<code class="fe lq lr ls lt b">*</code>字符。我们可以简单地写<code class="fe lq lr ls lt b">print('*' * 260)</code>。然而，我将写一些不寻常的东西来代替:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="2cba" class="ly lz it lt b gy ma mb l mc md">s= 'print(' + '"*",' * 260 + ')'<br/>c = compile(s, "", "exec")<br/>disassemble(c)</span></pre><p id="56ad" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里的<code class="fe lq lr ls lt b">s</code>包含一个<code class="fe lq lr ls lt b">print</code>函数，它有260个参数，每个参数都是一个<code class="fe lq lr ls lt b">*</code>字符。现在看看反汇编后的字节码:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="231e" class="ly lz it lt b gy ma mb l mc md">1         0 LOAD_NAME                0 (print)<br/>          2 LOAD_CONST               0 ('*')<br/>          4 LOAD_CONST               0 ('*')<br/>                .                    .<br/>                .                    .<br/>                .                    .</span><span id="8c5b" class="ly lz it lt b gy ny mb l mc md">        518 LOAD_CONST               0 ('*')<br/>        520 LOAD_CONST               0 ('*')<br/>        522 EXTENDED_ARG             1 <br/>        524 CALL_FUNCTION          260 <br/>        526 POP_TOP                    <br/>        528 LOAD_CONST               1 (None)<br/>        530 RETURN_VALUE</span></pre><p id="8bc9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里<code class="fe lq lr ls lt b">print</code>首先被推到堆栈上。然后推送它的260个参数。然后<code class="fe lq lr ls lt b">CALL_FUNCTION</code>应该调用函数。但是它需要(目标函数的)参数个数作为它的oparg。这里这个数字是260，比一个字节所能容纳的最大数字还要大。记住oparg只有一个字节。所以<code class="fe lq lr ls lt b">CALL_FUNCTION</code>是以<code class="fe lq lr ls lt b">EXTENDED_ARG</code>为前缀的。实际的字节码是:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="3565" class="ly lz it lt b gy ma mb l mc md">        522 EXTENDED_ARG             1 <br/>        524 CALL_FUNCTION            4</span></pre><p id="db13" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如前所述，EXTENDED_ARG的oparg将左移8位或简单地乘以256，并添加到下一个操作码的oparg中。所以<code class="fe lq lr ls lt b">CALL_FUNCTION</code>的oparg将被解释为<code class="fe lq lr ls lt b">256+4 = 260</code>(请注意，<code class="fe lq lr ls lt b">disassemble</code>函数显示的是这个被解释的oparg，而不是字节码中实际的oparg)。</p><p id="b90d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">条件语句和跳转</strong></p><p id="c9d7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">考虑下面的源代码，它有一个<code class="fe lq lr ls lt b">if-else</code>语句:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="8e22" class="ly lz it lt b gy ma mb l mc md">s='''a = 1<br/>if a&gt;=0:<br/>    b=a<br/>else:<br/>    b=-a<br/>'''<br/>c=compile(s, "", "exec")<br/>disassemble(c)</span></pre><p id="8a97" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">反汇编的字节码是:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="4f4b" class="ly lz it lt b gy ma mb l mc md">1         0 LOAD_CONST               0 (1)<br/>          2 STORE_NAME               0 (a)<br/><br/>2         4 LOAD_NAME                0 (a)<br/>          6 LOAD_CONST               1 (0)<br/>          8 COMPARE_OP               5 (&gt;=)<br/>         10 POP_JUMP_IF_FALSE       18 <br/><br/>3        12 LOAD_NAME                0 (a)<br/>         14 STORE_NAME               1 (b)<br/>         16 JUMP_FORWARD             6 (to 24)<br/><br/>5   &gt;&gt;   18 LOAD_NAME                0 (a)<br/>         20 UNARY_NEGATIVE             <br/>         22 STORE_NAME               1 (b)<br/>    &gt;&gt;   24 LOAD_CONST               2 (None)<br/>         26 RETURN_VALUE</span></pre><p id="cdeb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们这里有一些新的指示。在第2行中，<code class="fe lq lr ls lt b">a</code>引用的对象被推送到堆栈上，然后文字<code class="fe lq lr ls lt b">0</code>被推。指令</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="f5b7" class="ly lz it lt b gy ma mb l mc md"><strong class="lt iu">COMPARE_OP </strong><em class="me">oparg</em></span></pre><p id="1adf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">执行布尔运算。操作名称见<code class="fe lq lr ls lt b">cmp_op[oparg]</code>。<code class="fe lq lr ls lt b">cmp_op</code>的值存储在一个名为<code class="fe lq lr ls lt b">dis.cmp_op</code>的列表中。该指令首先弹出堆栈的顶部两个元素。我们把第一个叫做<code class="fe lq lr ls lt b">TOS1</code>，第二个叫做<code class="fe lq lr ls lt b">TOS2</code>。然后对它们执行由<em class="me"> oparg </em>选择的布尔运算<code class="fe lq lr ls lt b">(TOS2 cmp_op[oparg] TOS1)</code>，结果被推到堆栈的顶部。在本例中为<code class="fe lq lr ls lt b">TOS1=0</code>和<code class="fe lq lr ls lt b">TOS2=value of a</code>。另外，<em class="me"> oparg </em>为<code class="fe lq lr ls lt b">5</code>和<code class="fe lq lr ls lt b">cmp_op[5]='≥'</code>。因此<code class="fe lq lr ls lt b">cmp_op</code>将测试<code class="fe lq lr ls lt b">a≥0</code>并将结果(真或假)存储在堆栈顶部。</p><p id="5e3a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">指令</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="294f" class="ly lz it lt b gy ma mb l mc md"><strong class="lt iu">POP_JUMP_IF_FALSE </strong><em class="me">target </em></span></pre><p id="35f9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">执行条件跳转。首先，它弹出栈顶。如果栈顶的元素为false，它将字节码计数器设置为<em class="me">目标</em>。字节码计数器显示正在执行的当前字节码偏移量。所以它跳转到等于target的字节码偏移量，字节码从那里继续执行。字节码中的offset 18是一个跳转目标，所以在反汇编的字节码中在它前面有一个<code class="fe lq lr ls lt b">&gt;&gt;</code>。指令</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="d42f" class="ly lz it lt b gy ma mb l mc md"><strong class="lt iu">JUMP_FORWARD </strong><em class="me">delta</em></span></pre><p id="f2ef" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将字节码计数器增加<em class="me">增量</em>。在前面的字节码中，这条指令的偏移量是16，我们知道每条指令占用2个字节。所以当这条指令结束时，字节码计数器是<code class="fe lq lr ls lt b">16+2=18</code>。这里是<code class="fe lq lr ls lt b">delta=6</code>和<code class="fe lq lr ls lt b">18+6=24</code>，所以跳到偏移<code class="fe lq lr ls lt b">24</code>。偏移24是一个跳转目标，它也有一个<code class="fe lq lr ls lt b">&gt;&gt;</code>符号。</p><p id="8575" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们可以看到<code class="fe lq lr ls lt b">if-else</code>语句是如何被转换成字节码的。<code class="fe lq lr ls lt b">cmp_op</code>检查<code class="fe lq lr ls lt b">a≥0</code>是否。如果结果为假，<code class="fe lq lr ls lt b">POP_JUMP_IF_FALSE</code> <strong class="kw iu"> </strong>跳转<strong class="kw iu"> </strong>到偏移18，这是<code class="fe lq lr ls lt b">else</code>块的开始。如果为真，将执行<code class="fe lq lr ls lt b">if</code>块，然后<code class="fe lq lr ls lt b">JUMP_FORWARD</code>跳转到偏移量24，不执行<code class="fe lq lr ls lt b">else</code>块。</p><p id="8e16" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在让我们看一个更复杂的布尔表达式。考虑以下源代码:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="35b5" class="ly lz it lt b gy ma mb l mc md">s='''a = 1<br/>c = 3<br/>if a&gt;=0 and c==3:<br/>    b=a<br/>else:<br/>    b=-a<br/>'''<br/>c=compile(s, "", "exec")<br/>disassemble(c)</span></pre><p id="268d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里我们有一个逻辑<code class="fe lq lr ls lt b">and</code>。反汇编的字节码是:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="1d57" class="ly lz it lt b gy ma mb l mc md">1         0 LOAD_CONST               0 (1)<br/>          2 STORE_NAME               0 (a)<br/><br/>2         4 LOAD_CONST               1 (3)<br/>          6 STORE_NAME               1 (c)<br/><br/>3         8 LOAD_NAME                0 (a)<br/>         10 LOAD_CONST               2 (0)<br/>         12 COMPARE_OP               5 (&gt;=)<br/>         14 POP_JUMP_IF_FALSE       30 <br/>         16 LOAD_NAME                1 (c)<br/>         18 LOAD_CONST               1 (3)<br/>         20 COMPARE_OP               2 (==)<br/>         22 POP_JUMP_IF_FALSE       30 <br/><br/>4        24 LOAD_NAME                0 (a)<br/>         26 STORE_NAME               2 (b)<br/>         28 JUMP_FORWARD             6 (to 36)<br/><br/>6   &gt;&gt;   30 LOAD_NAME                0 (a)<br/>         32 UNARY_NEGATIVE             <br/>         34 STORE_NAME               2 (b)<br/>    &gt;&gt;   36 LOAD_CONST               3 (None)<br/>         38 RETURN_VALUE</span></pre><p id="9cb4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在Python中<code class="fe lq lr ls lt b">and</code>是短路运算符。所以在对<code class="fe lq lr ls lt b">X and Y</code>求值的时候，只有<code class="fe lq lr ls lt b">X</code>为真，它才会对<code class="fe lq lr ls lt b">Y</code>求值。这在字节码中很容易看到。在第3行，首先对<code class="fe lq lr ls lt b">and</code>的左操作数求值。如果<code class="fe lq lr ls lt b">(a≥0)</code>为假，则不计算第二个操作数，并跳转到偏移量30执行<code class="fe lq lr ls lt b">else </code>块。但是，如果为真，第二个操作数<code class="fe lq lr ls lt b">(b==3)</code>也将被求值。</p><p id="adca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">循环和块堆栈</strong></p><p id="4ffa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如前所述，每个框架内都有一个评估堆栈。另外，在每一帧中，都有一个<em class="me">块堆栈</em>。CPython使用它来跟踪某些类型的控制结构，如循环、<code class="fe lq lr ls lt b">with</code>块和<code class="fe lq lr ls lt b">try/except</code>块。当CPython想要进入这些结构中的一个时，一个新的项目被推到块堆栈上，当CPython退出该结构时，该结构的项目被弹出块堆栈。使用块堆栈CPython知道哪个结构当前是活动的。所以当它到达一个<code class="fe lq lr ls lt b">break</code>或<code class="fe lq lr ls lt b">continue</code>语句时，它知道哪些结构应该受到影响。</p><p id="eaea" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看看循环是如何在字节码中实现的。考虑下面的代码及其反汇编的字节码:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="77b2" class="ly lz it lt b gy ma mb l mc md">s='''for i in range(3):<br/>    print(i)<br/>'''<br/>c=compile(s, "", "exec")<br/>disassemble(c)</span><span id="b197" class="ly lz it lt b gy ny mb l mc md">--------------------------------------------------------------------</span><span id="486e" class="ly lz it lt b gy ny mb l mc md">1         0 SETUP_LOOP              24 (to 26)<br/>          2 LOAD_NAME                0 (range)<br/>          4 LOAD_CONST               0 (3)<br/>          6 CALL_FUNCTION            1 <br/>          8 GET_ITER                   <br/>    &gt;&gt;   10 FOR_ITER                12 (to 24)<br/>         12 STORE_NAME               1 (i)<br/><br/>2        14 LOAD_NAME                2 (print)<br/>         16 LOAD_NAME                1 (i)<br/>         18 CALL_FUNCTION            1 <br/>         20 POP_TOP                    <br/>         22 JUMP_ABSOLUTE           10 <br/>    &gt;&gt;   24 POP_BLOCK                  <br/>    &gt;&gt;   26 LOAD_CONST               1 (None)<br/>         28 RETURN_VALUE</span></pre><p id="b172" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">指令</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="15dc" class="ly lz it lt b gy ma mb l mc md"><strong class="lt iu">SETUP_LOOP</strong> <em class="me">delta</em></span></pre><p id="674c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在循环开始前执行。此指令将一个新项目(也称为块)推送到块堆栈上。<em class="me">增量</em>加到字节码计数器，确定循环后下一条指令的偏移量。这里<code class="fe lq lr ls lt b">SET_LOOP</code>的偏移量是<code class="fe lq lr ls lt b">0</code>，所以字节码计数器是<code class="fe lq lr ls lt b">0+2=2</code>。另外，<em class="me"> delta </em>为<code class="fe lq lr ls lt b">24</code>，所以循环后下一条指令的偏移量为<code class="fe lq lr ls lt b">2+24=26</code>。这个偏移量存储在推送到块堆栈上的块中。此外，评估堆栈中的当前项目数存储在该块中。</p><p id="5fe2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">之后，应该执行功能<code class="fe lq lr ls lt b">range(3)</code>。它的oparg ( <code class="fe lq lr ls lt b">3</code>)被推到函数名之前。结果是一个<a class="ae mg" href="https://www.w3schools.com/python/python_iterators.asp" rel="noopener ugc nofollow" target="_blank"> <em class="me">可迭代</em> </a>。Iterables可以使用以下指令生成一个<a class="ae mg" href="https://docs.python.org/3/glossary.html#term-iterator" rel="noopener ugc nofollow" target="_blank"> <em class="me">迭代器</em> </a>:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="dfd7" class="ly lz it lt b gy ma mb l mc md"><strong class="lt iu">GET_ITER</strong></span></pre><p id="f3d5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它将iterable放在堆栈的顶部，并推送它的迭代器。说明:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="7655" class="ly lz it lt b gy ma mb l mc md"><strong class="lt iu">FOR_ITER </strong><em class="me">delta</em></span></pre><p id="e53b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">假设栈顶有一个迭代器。它调用它的<code class="fe lq lr ls lt b">__next__()</code>方法。如果它产生一个新值，这个值被推到栈顶(迭代器之上)。在循环内部，栈顶存储在其后的<code class="fe lq lr ls lt b">i</code>中，执行<code class="fe lq lr ls lt b">print</code>函数。然后弹出栈顶，即迭代器的当前值。在那之后，指令</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="e3ff" class="ly lz it lt b gy ma mb l mc md"><strong class="lt iu">JUMP_ABSOLUTE </strong><em class="me">target</em></span></pre><p id="c7f3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将字节码计数器设置为<em class="me">目标</em>并跳转到<em class="me">目标</em>偏移量。所以它跳到偏移量10，再次运行<code class="fe lq lr ls lt b">FOR_ITER</code>来获取迭代器的下一个值。如果迭代器指示没有其他元素可用，则弹出栈顶，并且字节码计数器增加<em class="me">增量</em>。这里是<code class="fe lq lr ls lt b"><em class="me">delta</em>=12</code>，所以循环结束后，跳转到偏移量24。在偏移量24处，指令</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="60af" class="ly lz it lt b gy ma mb l mc md"><strong class="lt iu">POP_BLOCK</strong></span></pre><p id="510d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从块堆栈顶部移除当前块。循环后下一条指令的偏移量存储在块中(这里是26)。所以解释器会跳到那个偏移量，并从那里继续执行。图3显示了偏移量为0、10、24和26的字节码操作(事实上，在图1和图2中，我们只显示了每一帧中的评估堆栈)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/2f6da813a6d2887cb06bf1eb5ab86f47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*glhOtrxf4VYhBucO5RwhOQ.jpeg"/></div></div><p class="oa ob gj gh gi oc od bd b be z dk translated">图3</p></figure><p id="448a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是如果我们在这个循环中添加一个<code class="fe lq lr ls lt b">break</code>语句会发生什么呢？考虑下面的源代码及其反汇编的字节码:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="6d14" class="ly lz it lt b gy ma mb l mc md">s='''for i in range(3):<br/>    break<br/>    print(i)<br/>'''<br/>c=compile(s, "", "exec")<br/>disassemble(c)</span><span id="7fee" class="ly lz it lt b gy ny mb l mc md">--------------------------------------------------------------------</span><span id="3613" class="ly lz it lt b gy ny mb l mc md">1         0 SETUP_LOOP              26 (to 28)<br/>          2 LOAD_NAME                0 (range)<br/>          4 LOAD_CONST               0 (3)<br/>          6 CALL_FUNCTION            1 <br/>          8 GET_ITER                   <br/>    &gt;&gt;   10 FOR_ITER                14 (to 26)<br/>         12 STORE_NAME               1 (i)<br/><br/>2        14 BREAK_LOOP                 <br/><br/>3        16 LOAD_NAME                2 (print)<br/>         18 LOAD_NAME                1 (i)<br/>         20 CALL_FUNCTION            1 <br/>         22 POP_TOP                    <br/>         24 JUMP_ABSOLUTE           10 <br/>    &gt;&gt;   26 POP_BLOCK                  <br/>    &gt;&gt;   28 LOAD_CONST               1 (None)<br/>         30 RETURN_VALUE</span></pre><p id="a445" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们只在前一个循环中添加了一个<code class="fe lq lr ls lt b">break</code>语句。该语句被转换为</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="47f8" class="ly lz it lt b gy ma mb l mc md"><strong class="lt iu">BREAK_LOOP</strong></span></pre><p id="af28" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该操作码移除评估堆栈上的那些额外项目，并从块堆栈的顶部弹出该块。您应该注意到，循环的其他指令仍在使用评估堆栈。因此，当循环中断时，属于它的项应该从计算堆栈中弹出。在这个例子中，迭代器对象仍然在栈顶。请记住，在开始循环之前，块堆栈中的块存储评估堆栈中存在的项数。</p><p id="bc3c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，通过知道这个数字，<code class="fe lq lr ls lt b">BREAK_LOOP</code> <strong class="kw iu"> </strong>从评估堆栈中弹出那些额外的项目。然后跳转到存储在块堆栈的当前块中的偏移量(这里是28)。这是循环后下一条指令的偏移量。因此循环中断，从那里继续执行。</p><p id="6acd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">创建代码对象</strong></p><p id="6873" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">code对象是一个类型为<code class="fe lq lr ls lt b">code</code>的对象，可以动态创建。模块<code class="fe lq lr ls lt b">types</code>可以帮助动态创建新类型，该模块中的类<code class="fe lq lr ls lt b">CodeType()</code>返回一个新的代码对象:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="35a3" class="ly lz it lt b gy ma mb l mc md">types.CodeType(co_argcount, co_kwonlyargcount,<br/>               co_nlocals, co_stacksize, co_flags,<br/>               co_code, co_consts, co_names,<br/>               co_varnames, co_filename, co_name,<br/>               co_firstlineno, co_lnotab, <!-- -->freevars=None, <br/>               cellvars=None<!-- -->)</span></pre><p id="d03f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">参数构成了代码对象的所有属性。你已经熟悉了其中的一些参数(比如<code class="fe lq lr ls lt b">co_varnames</code>和<code class="fe lq lr ls lt b">co_firstlineno</code>)。<code class="fe lq lr ls lt b">freevars</code>和<code class="fe lq lr ls lt b">cellvars</code>是可选的，因为它们在闭包中使用，并且不是所有的函数都使用它们(关于它们的更多信息，请参考本文)。其他属性以下面的函数为例进行说明:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="98c9" class="ly lz it lt b gy ma mb l mc md">def f(a, b, *args, c, **kwargs):<br/>    d=1<br/>    def g():<br/>        return 1<br/>    g()<br/>    return 1</span></pre><p id="1033" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">co_argcount</code>:如果代码对象是一个函数的对象，则是它所采用的参数个数(不包括仅关键字的参数，<code class="fe lq lr ls lt b">*</code>或<code class="fe lq lr ls lt b">**</code> args)。对于功能<code class="fe lq lr ls lt b">f</code>，它是<code class="fe lq lr ls lt b">2</code>。</p><p id="3622" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">co_kwonlyargcount</code>:如果代码对象是函数的代码对象，则为仅关键字参数的数量(不包括<code class="fe lq lr ls lt b">**</code> arg)。对于功能<code class="fe lq lr ls lt b">f</code>，它是<code class="fe lq lr ls lt b">1</code>。</p><p id="7c4c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">co_nlocals</code>:局部变量的个数加上代码对象中定义的函数名(自变量也被认为是局部变量)。事实上，<code class="fe lq lr ls lt b">co_varnames</code>中的元素数就是<code class="fe lq lr ls lt b">('a', 'b', 'c', 'args', 'kwargs', 'd', 'g')</code>。所以是<code class="fe lq lr ls lt b">f</code>的<code class="fe lq lr ls lt b">7</code>。</p><p id="a1a0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">co_stacksize</code>:显示此代码对象将推入计算堆栈的元素的最大数量。请记住，有些操作码需要将一些元素推送到计算堆栈上。这个属性显示了栈在字节码操作中可以增长到的最大大小。在这个例子中是<code class="fe lq lr ls lt b">2</code>。让我解释一下原因。如果你反汇编这个函数的字节码，你会得到:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="c347" class="ly lz it lt b gy ma mb l mc md">2         0 LOAD_CONST               1 (1)<br/>          2 STORE_FAST               5 (d)<br/><br/>3         4 LOAD_CONST               2 (&lt;code object g at 0x0000028A62AB1D20, file "&lt;ipython-input-614-cb7dfbcc0072&gt;", line 3&gt;)<br/>          6 LOAD_CONST               3 ('f.&lt;locals&gt;.g')<br/>          8 MAKE_FUNCTION            0 <br/>         10 STORE_FAST               6 (g)<br/><br/>5        12 LOAD_FAST                6 (g)<br/>         14 CALL_FUNCTION            0 <br/>         16 POP_TOP                    <br/><br/>6        18 LOAD_CONST               1 (1)<br/>         20 RETURN_VALUE</span></pre><p id="f305" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在第2行，使用<code class="fe lq lr ls lt b">LOAD_CONST</code>将一个元素推到堆栈上，并将使用<code class="fe lq lr ls lt b">STORE_FAST</code>弹出。第5行和第6行类似地将一个元素推到堆栈上，稍后再弹出它。但是在第3行中，两个元素被推到堆栈上来定义内部函数<code class="fe lq lr ls lt b">g</code>:它的代码对象和它的名字。这是这个代码对象将被推到计算堆栈上的元素的最大数量，它决定了堆栈的大小。</p><p id="26d4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">co_flags</code>:整数，用位表示函数是否接受可变数量的参数，函数是否是生成器等。在我们的例子中，它的值是<code class="fe lq lr ls lt b">79</code>。<code class="fe lq lr ls lt b">79</code>的二进制值为<code class="fe lq lr ls lt b">0b1001111</code>。它使用一个<a class="ae mg" href="https://en.wikipedia.org/wiki/Endianness#Little-endian" rel="noopener ugc nofollow" target="_blank">小端系统</a>，其中字节从左<em class="me">到右</em>按重要性递增的方式写入。所以第一位是右边的第一个。你可以参考这个<a class="ae mg" href="https://docs.python.org/3/library/inspect.html#inspect-module-co-flags" rel="noopener ugc nofollow" target="_blank">链接</a>来了解这些位的含义。例如，右数第三位代表<code class="fe lq lr ls lt b">CO_VARARGS</code>标志。当它是<code class="fe lq lr ls lt b">1</code>时，意味着代码对象有一个可变的位置参数(<code class="fe lq lr ls lt b">*args</code> -like)。</p><p id="3cdc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">co_filename</code>:字符串，指定函数所在的文件。在这种情况下，这是<code class="fe lq lr ls lt b">'&lt;ipython-input-59–960ced5b1120&gt;'</code>，因为我正在运行Jupyter笔记本中的脚本。</p><p id="1888" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">co_name</code>:定义该代码对象的名称。这里是函数的名字<code class="fe lq lr ls lt b">'f'</code>。</p><p id="f102" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">字节码注入</strong></p><p id="1bd8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们已经完全熟悉了代码对象，我们可以开始改变它的字节码了。需要注意的是，代码对象是不可变的。所以一旦创造了，我们就不能改变它。假设我们想要更改以下函数的字节码:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="b5be" class="ly lz it lt b gy ma mb l mc md">def f(x, y):<br/>    return x + y</span><span id="b073" class="ly lz it lt b gy ny mb l mc md">c = f.__code__</span></pre><p id="4d11" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里我们不能直接改变函数的代码对象的字节码。相反，我们需要创建一个新的代码对象，然后将它分配给这个函数。为此，我们需要更多的函数。<code class="fe lq lr ls lt b">disassemble</code>函数可以将字节码分解成一些对人类友好的指令。我们可以随心所欲地修改它们，但是我们需要将它们组装回字节码，以将其分配给新的代码对象。<code class="fe lq lr ls lt b">disassemble</code>的输出是一个格式化的字符串，易于阅读，但难以更改。所以我将添加一个新函数，它可以将字节码分解成一系列指令。它与<code class="fe lq lr ls lt b">disassemble</code>非常相似，但是，它的输出是一个列表。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="197e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以在之前的函数上尝试一下:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="d264" class="ly lz it lt b gy ma mb l mc md">disassembled_bytecode = disassemble_to_list(c)</span></pre><p id="58be" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在<code class="fe lq lr ls lt b">disassembled_bytecode</code>等于:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="4f26" class="ly lz it lt b gy ma mb l mc md">[['LOAD_FAST', 'x'],<br/> ['LOAD_FAST', 'y'],<br/> ['BINARY_ADD'],<br/> ['RETURN_VALUE']]</span></pre><p id="8451" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们现在可以很容易地更改该列表的说明。但是我们还需要将它组装回字节码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ml mm l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="8ca5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">函数<code class="fe lq lr ls lt b">get_oparg</code>类似于<code class="fe lq lr ls lt b">get_argvalue</code>的逆函数。它接受一个argvalue，这是oparg的友好含义，并返回相应的oparg。它需要code对象作为它的参数，因为code对象的属性如<code class="fe lq lr ls lt b">co_consts</code>是将argvalue转换成oparg所必需的。</p><p id="5361" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">函数<code class="fe lq lr ls lt b">assemble</code>获取一个代码对象和一个反汇编的字节码列表，并将其组装回字节码。它使用<code class="fe lq lr ls lt b">dis.opname</code>将opname转换成操作码。然后它调用<code class="fe lq lr ls lt b">get_oparg </code>将argvalue转换成oparg。最后，它返回字节码列表的字节文字。我们现在可以使用这些新函数来改变前面函数<code class="fe lq lr ls lt b">f</code>的字节码。首先，我们改变<code class="fe lq lr ls lt b">disassembled_bytecode</code>中的一条指令:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="e6b1" class="ly lz it lt b gy ma mb l mc md">disassembled_bytecode[2] = ['BINARY_MULTIPLY']</span></pre><p id="bb95" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">指令</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="17e7" class="ly lz it lt b gy ma mb l mc md"><strong class="lt iu">BINARY_MULTIPLY</strong></span></pre><p id="0cb8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">弹出堆栈顶部的两个元素，将它们相乘，并将结果推送到堆栈上。现在我们组装修改后的反汇编字节码:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="06e4" class="ly lz it lt b gy ma mb l mc md">new_co_code= assemble(disassembled_bytecode, c.co_consts,<br/>                      c.co_varnames, c.co_names,<br/>                      c.co_cellvars+c.co_freevars)</span></pre><p id="4afd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">之后，我们创建一个新的代码对象:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="0075" class="ly lz it lt b gy ma mb l mc md">import types<br/>nc = types.CodeType(c.co_argcount, c.co_kwonlyargcount,<br/>                    c.co_nlocals, c.co_stacksize, c.co_flags,<br/>                    new_co_code, c.co_consts, c.co_names, <br/>                    c.co_varnames, c.co_filename, c.co_name, <br/>                    c.co_firstlineno, c.co_lnotab, <br/>                    c.co_freevars, c.co_cellvars)<br/>f.__code__ = nc</span></pre><p id="35fd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们使用<code class="fe lq lr ls lt b">f</code>的所有属性来创建它，只替换新的字节码(<code class="fe lq lr ls lt b">new_co_code</code>)。然后我们将新的代码对象分配给<code class="fe lq lr ls lt b">f</code>。现在，如果我们再次运行<code class="fe lq lr ls lt b">f</code>，它不会将其参数加在一起。相反，它会将它们相乘:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="3ed7" class="ly lz it lt b gy ma mb l mc md">f(2,5)  # Output is 10 not 7</span></pre><p id="f21c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">注意</strong>:<code class="fe lq lr ls lt b">types.CodeType</code>函数有两个可选参数<code class="fe lq lr ls lt b">freevars</code>和<code class="fe lq lr ls lt b"> cellvars</code>，但是使用时要小心。如前所述，代码对象的<code class="fe lq lr ls lt b">co_cellvars</code>和<code class="fe lq lr ls lt b">co_freevars</code>属性仅在代码对象属于具有自由变量或非局部变量的函数时使用。所以函数应该是一个闭包，或者闭包应该已经在函数内部定义了。例如，考虑以下函数:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="61d8" class="ly lz it lt b gy ma mb l mc md">def func(x):<br/>    def g(y):<br/>        return x + y <br/>    return g</span></pre><p id="2761" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在如果检查它的代码对象:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="a907" class="ly lz it lt b gy ma mb l mc md">c = func.__code__<br/>c.co_cellvars  # Output is: ('x',)</span></pre><p id="04e5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">事实上，这个函数有一个非局部变量<code class="fe lq lr ls lt b">x</code>，因为这个变量是由其内部函数访问的。现在我们可以尝试使用相同的属性重新创建它的代码对象:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="ebf3" class="ly lz it lt b gy ma mb l mc md">nc = types.CodeType(c.co_argcount, c.co_kwonlyargcount,<br/>                    c.co_nlocals, c.co_stacksize, c.co_flags,<br/>                    new_co_code, c.co_consts, c.co_names, <br/>                    c.co_varnames, c.co_filename, c.co_name, <br/>                    c.co_firstlineno, c.co_lnotab, <br/>                    cellvars = c.co_cellvars,<br/>                    freevars = c.co_freevars)</span></pre><p id="ae74" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是如果我们检查新代码对象的相同属性</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="24e4" class="ly lz it lt b gy ma mb l mc md">nc.co_cellvars  Output is: ()</span></pre><p id="0526" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">结果是空的。所以<code class="fe lq lr ls lt b">types.CodeType</code>不能创建相同的代码对象。如果你试图将这个代码对象赋给一个函数并执行那个函数，你会得到一个错误(这个已经在Python 3.7.4上测试过了)。</p><p id="c13c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">代码优化</strong></p><p id="c954" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">理解字节码指令可以帮助我们优化源代码。考虑以下源代码:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="a2ef" class="ly lz it lt b gy ma mb l mc md">setup1='''import math<br/>mult = 2<br/>def f():<br/>    total = 0<br/>    i = 1<br/>    for i in range(1, 200):<br/>        total += mult * math.log(i)<br/>    return total<br/>'''</span><span id="a3fe" class="ly lz it lt b gy ny mb l mc md">setup2='''import math<br/>def f(): <br/>    log = math.log<br/>    mult = 2<br/>    total = 0<br/>    for i in range(1, 200):<br/>        total += mult * log(i)<br/>    return total<br/>'''</span></pre><p id="20e8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里我们定义一个函数<code class="fe lq lr ls lt b">f()</code>来计算一个简单的数学表达式。它有两种不同的定义。在<code class="fe lq lr ls lt b">setup1</code>中，我们在<code class="fe lq lr ls lt b">f()</code>中使用全局变量<code class="fe lq lr ls lt b">mult</code>，并直接使用<code class="fe lq lr ls lt b">math</code>模块中的<code class="fe lq lr ls lt b">log()</code>函数。在<code class="fe lq lr ls lt b">setup2</code>中，<code class="fe lq lr ls lt b">mult</code>是<code class="fe lq lr ls lt b">f()</code>的局部变量。另外，<code class="fe lq lr ls lt b">math.log</code>首先存储在本地变量<code class="fe lq lr ls lt b">log</code>中。现在我们可以比较这些函数的性能:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="841b" class="ly lz it lt b gy ma mb l mc md">t1 = timeit.timeit(stmt="f()", setup=setup1, number=100000)<br/>t2 = timeit.timeit(stmt="f()", setup=setup2, number=100000)<br/>print("t1=", t1)<br/>print("t2=", t2)<br/>--------------------------------------------------------------------<br/>t1= 3.8076129000110086<br/>t2= 3.2230119000014383</span></pre><p id="d296" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可能会得到不同的<code class="fe lq lr ls lt b">t1</code>和<code class="fe lq lr ls lt b">t2</code>的数字，但底线是<code class="fe lq lr ls lt b">setup2</code>比<code class="fe lq lr ls lt b">setup1</code>快。现在让我们比较一下它们的字节码，看看为什么它更快。我们只看<code class="fe lq lr ls lt b">setup1</code>和<code class="fe lq lr ls lt b">setup2</code>的反汇编代码中的第7行。这是这一行的字节码:<code class="fe lq lr ls lt b">total += mult * log(i)</code>。</p><p id="dc07" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe lq lr ls lt b">setup1</code>中，我们有:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="5cf8" class="ly lz it lt b gy ma mb l mc md">7        24 LOAD_FAST                0 (total)<br/>         26 LOAD_GLOBAL              1 (mult)<br/>         28 LOAD_GLOBAL              2 (math)<br/>         30 LOAD_METHOD              3 (log)<br/>         32 LOAD_FAST                1 (i)<br/>         34 CALL_METHOD              1 <br/>         36 BINARY_MULTIPLY            <br/>         38 INPLACE_ADD                <br/>         40 STORE_FAST               0 (total)<br/>         42 JUMP_ABSOLUTE           20 <br/>    &gt;&gt;   44 POP_BLOCK</span></pre><p id="8de6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是在<code class="fe lq lr ls lt b">setup2</code>中我们得到:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="28a6" class="ly lz it lt b gy ma mb l mc md">7        30 LOAD_FAST                2 (total)<br/>         32 LOAD_FAST                1 (mult)<br/>         34 LOAD_FAST                0 (log)<br/>         36 LOAD_FAST                3 (i)<br/>         38 CALL_FUNCTION            1 <br/>         40 BINARY_MULTIPLY            <br/>         42 INPLACE_ADD                <br/>         44 STORE_FAST               2 (total)<br/>         46 JUMP_ABSOLUTE           26 <br/>    &gt;&gt;   48 POP_BLOCK</span></pre><p id="94d5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如您在<code class="fe lq lr ls lt b">setup1</code>中所见，<code class="fe lq lr ls lt b">mult</code>和<code class="fe lq lr ls lt b">math</code>均使用<code class="fe lq lr ls lt b">LOAG_GLOBAL</code>加载，但在<code class="fe lq lr ls lt b">setup2</code>中，<code class="fe lq lr ls lt b">mult</code>和<code class="fe lq lr ls lt b">log</code>使用<code class="fe lq lr ls lt b">LOAD_FAST</code>加载。因此两个<code class="fe lq lr ls lt b">LOAD_GLOBAL</code>指令被替换为<code class="fe lq lr ls lt b">LOAD_FAST</code>。事实是<code class="fe lq lr ls lt b">LOAD_FAST</code>顾名思义比<code class="fe lq lr ls lt b">LOAD_GLOBAL</code>快得多。我们提到的全局和局部变量的名称都存储在<code class="fe lq lr ls lt b">co_names</code>和<code class="fe lq lr ls lt b">co_varnames</code>中。但是在执行编译后的代码时，CPython解释器是如何找到值的呢？</p><p id="3698" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">局部变量存储在每一帧的数组中(为了简单起见，前面的图中没有显示)。我们知道局部变量的名字存储在<code class="fe lq lr ls lt b">co_varnames</code>中。它们的值将以相同的顺序存储在该数组中。因此，当解释器看到类似于<code class="fe lq lr ls lt b">LOAD_FAST 1 (mult)</code>的指令时，它读取索引<code class="fe lq lr ls lt b">1</code>处的数组元素。</p><p id="51f6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">模块的全局和内置存储在一个字典中。我们知道他们的名字存储在<code class="fe lq lr ls lt b">co_names</code>中。因此，当解释器看到类似于<code class="fe lq lr ls lt b">LOAD_GLOBAL 1 (mult)</code>的指令时，它首先从<code class="fe lq lr ls lt b">co_names[1]</code>获得全局变量的名称。然后，它将在字典中查找这个名称以获得它的值。与简单的局部变量数组查找相比，这是一个非常慢的过程。因此，<code class="fe lq lr ls lt b">LOAD_FAST</code>比<code class="fe lq lr ls lt b">LOAD_GLOBAL</code>快，用<code class="fe lq lr ls lt b">LOAD_FAST</code>代替<code class="fe lq lr ls lt b">LOAD_GLOBAL</code>可以提高性能。这可以通过简单地将内置变量和全局变量存储到局部变量中或者直接改变字节码指令来实现。</p><p id="2d27" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">示例:在Python中定义常数</strong></p><p id="96c5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个例子说明了如何使用字节码注入来改变函数的行为。我们将编写一个装饰器，为Python添加一个<em class="me"> const </em>语句。在一些编程语言如C、C++和JavaScript中，有一个<em class="me"> const </em>关键字。如果使用这个关键字将一个变量声明为const，那么改变它的值是非法的，我们不能再在源代码中改变这个变量的值了。</p><p id="cb50" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Python没有const语句，我也没有说Python中真的有必要有这样的关键字。此外，定义常量也可以在不使用字节码注入的情况下完成。所以这只是一个展示如何将字节码注入付诸实施的例子。首先，让我展示一下如何使用它。const关键字是使用名为<code class="fe lq lr ls lt b">const</code>的函数装饰器提供的。一旦用<code class="fe lq lr ls lt b">const</code>修饰了一个函数，就可以用关键字<code class="fe lq lr ls lt b">const.</code>将函数内部的变量声明为常量(最后的<code class="fe lq lr ls lt b">.</code>是关键字的一部分)。这里有一个例子:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="4011" class="ly lz it lt b gy ma mb l mc md">@const<br/>def f(x):<br/>    const. A=5<br/>    return A*x<br/>f(2)  # Output is: 10</span></pre><p id="7fc6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">f</code>中的变量<code class="fe lq lr ls lt b">A</code>现在是一个常量。现在，如果您尝试在<code class="fe lq lr ls lt b">f</code>中重新分配这个变量，将会引发一个异常:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="fdd6" class="ly lz it lt b gy ma mb l mc md">@const<br/>def f(x):<br/>    const. A=5<br/>    A = A + 1<br/>    return A*x<br/>--------------------------------------------------------------------# This raises an exception :<br/><strong class="lt iu">ConstError</strong>: 'A' is a constant and cannot be reassigned!</span></pre><p id="e805" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当变量被声明为const时。，应该赋给它的初始值，它将是那个函数的局部变量。</p><p id="6fde" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在让我向你展示它是如何实现的。假设我这样定义一个函数(没有修饰):</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="f550" class="ly lz it lt b gy ma mb l mc md">def f(x):<br/>    const. A=5<br/>    A = A + 1<br/>    return A*x</span></pre><p id="001b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它将被适当地编译。但是如果您尝试执行这个函数，您会得到一个错误:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="1ecc" class="ly lz it lt b gy ma mb l mc md">f(2)<br/>--------------------------------------------------------------------</span><span id="704b" class="ly lz it lt b gy ny mb l mc md"><strong class="lt iu">NameError</strong>: name 'const' is not defined</span></pre><p id="5c9b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在让我们来看看这个函数反汇编后的字节码:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="eac8" class="ly lz it lt b gy ma mb l mc md">2         0 LOAD_CONST               1 (5)<br/>          2 LOAD_GLOBAL              0 (const)<br/>          4 STORE_ATTR               1 (A)<br/><br/>3         6 LOAD_FAST                1 (A)<br/>          8 LOAD_CONST               2 (1)<br/>         10 BINARY_ADD                 <br/>         12 STORE_FAST               1 (A)<br/><br/>4        14 LOAD_FAST                1 (A)<br/>         16 LOAD_FAST                0 (x)<br/>         18 BINARY_MULTIPLY            <br/>         20 RETURN_VALUE</span></pre><p id="cb93" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当Python试图编译函数时，它将<code class="fe lq lr ls lt b">const</code>作为一个全局变量，因为它没有在函数中定义。变量<code class="fe lq lr ls lt b">A</code>被认为是全局变量<code class="fe lq lr ls lt b">A</code>的一个属性。事实上，<code class="fe lq lr ls lt b">const. A=1</code>和<code class="fe lq lr ls lt b">const.A=1</code>是一样的，因为Python忽略了点运算符和属性名之间的空格。当然，我们在源代码中确实没有名为<code class="fe lq lr ls lt b">A</code>的全局变量。但是Python不会在编译时检查它。只有在执行过程中，才会发现名称<code class="fe lq lr ls lt b">const</code>没有被定义。所以我们的源代码在编译时会被接受。但是我们需要在执行这个函数的代码对象之前改变它的字节码。我们首先需要创建一个函数来更改字节码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="d49b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个函数接收由<code class="fe lq lr ls lt b">assemble_to_list</code>生成的字节码指令列表作为它的参数。它有两个名为<code class="fe lq lr ls lt b">constants</code>和<code class="fe lq lr ls lt b">indices</code>的列表，分别存储声明为const的变量的名称和它们第一次被赋值的偏移量。第一个循环搜索字节码指令列表，找到所有的<code class="fe lq lr ls lt b">['LOAD_GLOBAL', 'const']</code>指令。变量名应该在下一条指令中。在本例中，下一条指令是<code class="fe lq lr ls lt b">['STORE_ATTR', 'A']</code>，名称是<code class="fe lq lr ls lt b">A</code>。该指令的名称和偏移量存储在<code class="fe lq lr ls lt b">constants</code>和<code class="fe lq lr ls lt b">indices</code>中。现在我们需要去掉全局变量<code class="fe lq lr ls lt b">const</code>及其属性，并创建一个名为<code class="fe lq lr ls lt b">A</code>的局部变量。指令</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="1ce2" class="ly lz it lt b gy ma mb l mc md"><strong class="lt iu">NOP</strong></span></pre><p id="27b2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">是“什么都不做”的代码。当解释器到达<code class="fe lq lr ls lt b">NOP</code>时，它将忽略它。我们不能简单地从指令列表中删除操作码，因为删除一条指令会减少后面所有指令的偏移量。现在，如果字节码中有一些跳转，它们的目标偏移量也应该改变。所以简单地用<code class="fe lq lr ls lt b">NOP</code>替换不需要的指令要容易得多。现在我们用<code class="fe lq lr ls lt b">NOP</code>代替<code class="fe lq lr ls lt b">['LOAD_GLOBAL', 'const']</code>，然后用<code class="fe lq lr ls lt b">['STORE_FAST', 'A']</code>代替<code class="fe lq lr ls lt b">['STORE_ATTR', 'A']</code>。最终的字节码如下所示:</p><pre class="kj kk kl km gt lu lt lv lw aw lx bi"><span id="66c2" class="ly lz it lt b gy ma mb l mc md">2         0 LOAD_CONST               1 (5)<br/>          2 NOP<br/>          4 STORE_FAST               1 (A)<br/><br/>3         6 LOAD_FAST                1 (A)<br/>          8 LOAD_CONST               2 (1)<br/>         10 BINARY_ADD                 <br/>         12 STORE_FAST               1 (A)<br/><br/>4        14 LOAD_FAST                1 (A)<br/>         16 LOAD_FAST                0 (x)<br/>         18 BINARY_MULTIPLY            <br/>         20 RETURN_VALUE</span></pre><p id="9901" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在第2行相当于源代码中的<code class="fe lq lr ls lt b">a=2</code>，执行这个字节码不会导致任何运行时错误。该循环还检查同一个变量是否被声明为const两次。因此，如果声明为const的变量已经存在于<code class="fe lq lr ls lt b">constants</code>列表中，它将引发一个自定义异常。现在唯一剩下的事情是确保常量变量没有被重新分配。</p><p id="b439" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">第二个循环再次搜索字节码指令列表，寻找常量变量的重新赋值。任何像<code class="fe lq lr ls lt b">['STORE_GLOBAL', 'A']</code>或<code class="fe lq lr ls lt b">['STORE_FAST', 'A']</code>这样的指令都意味着重分配在源代码中，所以它会引发一个定制的异常来警告用户。需要常量初始赋值的偏移量，以确保初始赋值不被视为再赋值。</p><p id="3a5c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如前所述，字节码应该在执行代码之前更改。所以需要在调用函数<code class="fe lq lr ls lt b">f</code>之前调用函数<code class="fe lq lr ls lt b">add_const</code>。为此，我们将它放在一个装饰器中。装饰函数<code class="fe lq lr ls lt b">const</code>接收目标函数<code class="fe lq lr ls lt b">f</code>作为它的参数。它将首先使用<code class="fe lq lr ls lt b">add_const</code>更改<code class="fe lq lr ls lt b">f</code>的字节码，然后用修改后的字节码创建一个新的代码对象。该代码对象将被分配给<code class="fe lq lr ls lt b">f</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="a715" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当我们创建新的代码对象时，需要修改它的一些属性。在原始函数中,<code class="fe lq lr ls lt b">const</code>是一个全局变量,<code class="fe lq lr ls lt b">A</code>是一个属性，所以它们都被添加到了<code class="fe lq lr ls lt b">co_names</code>元组中，它们应该从新代码对象的<code class="fe lq lr ls lt b">co_names</code>中移除。另外，当一个像<code class="fe lq lr ls lt b">A</code>这样的属性变成局部变量时，它的名字要加到<code class="fe lq lr ls lt b">co_varnames</code>元组中。属性<code class="fe lq lr ls lt b">co_nlocals</code>给出了局部变量(加上定义的函数)的数量，也应该被更新。其他属性保持不变。装饰器最终返回带有新代码对象的目标函数，现在目标函数已经准备好执行了。</p></div><div class="ab cl of og hx oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="im in io ip iq"><p id="82a3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">理解Python的字节码可以让你熟悉Python编译器和虚拟机的底层实现。如果您知道源代码是如何转换成字节码的，那么您就可以在编写和优化代码方面做出更好的决策。字节码注入也是代码优化和元编程的有用工具。在本文中，我只涉及了少量的字节码指令。可以参考<code class="fe lq lr ls lt b"><a class="ae mg" href="https://docs.python.org/3/library/dis.html" rel="noopener ugc nofollow" target="_blank">dis</a></code> <a class="ae mg" href="https://docs.python.org/3/library/dis.html" rel="noopener ugc nofollow" target="_blank">模块的网页</a>查看Python的字节码指令完整列表。我希望你喜欢阅读这篇文章。本文的所有代码清单都可以作为Jupyter笔记本下载，网址:<a class="ae mg" href="https://github.com/reza-bagheri/Understanding-Python-Bytecode" rel="noopener ugc nofollow" target="_blank">https://github . com/Reza-bag heri/Understanding-Python-Bytecode</a></p></div></div>    
</body>
</html>