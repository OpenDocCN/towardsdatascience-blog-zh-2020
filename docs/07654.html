<html>
<head>
<title>Graph Theory | Rooting a Tree</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">图论|为树生根</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/graph-theory-rooting-a-tree-fb2287b09779?source=collection_archive---------51-----------------------#2020-06-08">https://towardsdatascience.com/graph-theory-rooting-a-tree-fb2287b09779?source=collection_archive---------51-----------------------#2020-06-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="f3f4" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/graph-theory-simplified" rel="noopener" target="_blank">图论简化版</a></h2><div class=""/><blockquote class="jz ka kb"><p id="538d" class="kc kd ke kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la im bi translated">今天，我们要看看如何给一棵树扎根。这是我正在进行的系列<a class="ae lb" href="https://medium.com/@kelvinjose/graph-theory-go-hero-1b5917da4fc1" rel="noopener"> <strong class="kf jd"> <em class="it">图论:围棋英雄</em> </strong> </a> <strong class="kf jd"> <em class="it">的第 8 个帖子。你一定要查看索引页面，深入研究图表和相关问题。我通常会在每个周末尝试这个系列的新帖子。我们来看看生根是怎么做的。</em></strong></p></blockquote><p id="4317" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la im bi translated">如果我们想处理有根的树，这是我们需要的最基本的转换之一。为一棵树生根的动机是，它通常可以帮助添加一个结构并简化问题。一棵有根的树可以把一棵无向树转换成一棵更容易操作的有向树。从概念上讲，给一棵树生根就像通过一个特定的节点捡起树，让所有的边都指向下。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/0de8a7e799791f94b5873fe4cf4b9b7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xAOsQtX605zQtJx9zt0Vrw.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">作者照片</p></figure><p id="b041" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la im bi translated">我们可以通过使用树的任何节点来确定树的根，但是，在选择节点时要小心，因为不是所有的节点都不能生成平衡的树。所以我们需要有所选择。</p><p id="c031" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la im bi translated">在某些情况下，拥有一条返回父节点的路由总是一个好主意，这样我们就可以往回走。我在下面用红线说明了到父节点的路由。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lv"><img src="../Images/fa5fb2c7a9ac2e8ff043a8afa5975a05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JpKvr0fQhKN3S3oHRNt1Cg.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">作者照片</p></figure><p id="8811" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la im bi translated">让我们来看看如何给一棵树扎根。</p><h2 id="c96a" class="lw lx it bd ly lz ma dn mb mc md dp me lc mf mg mh ld mi mj mk le ml mm mn iz bi translated">生根溶液</h2><p id="fdd6" class="pw-post-body-paragraph kc kd it kf b kg mo ki kj kk mp km kn lc mq kq kr ld mr ku kv le ms ky kz la im bi translated">用一个<a class="ae lb" rel="noopener" target="_blank" href="/graph-theory-depth-first-search-977c1ae386e1?source=your_stories_page---------------------------"> <strong class="kf jd"> <em class="ke">深度优先搜索</em> </strong> </a> ( <strong class="kf jd"> DFS </strong>)很容易地完成一棵树的寻根。我已经创建了一个动画版本的结果 DFS 如下。你肯定会理解的，肯定。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi mt"><img src="../Images/6f4b84686d3afbae8f3d7a3bf11bb530.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*NkC0ExW1bUSwkTuC5FEbEQ.gif"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">作者创建的 GIF</p></figure><p id="aa3f" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la im bi translated">简而言之，这就是扎根于一棵树。</p><h2 id="1ad3" class="lw lx it bd ly lz ma dn mb mc md dp me lc mf mg mh ld mi mj mk le ml mm mn iz bi translated">伪码</h2><pre class="lg lh li lj gt mu mv mw mx aw my bi"><span id="1eaa" class="lw lx it mv b gy mz na l nb nc">class Treenode:<br/>    <br/>    int id;<br/>    Treenode parent;<br/>    Treenode [] children;</span><span id="631e" class="lw lx it mv b gy nd na l nb nc">function rootTree(g, rootId = 0):<br/>    root = Treenode(rootId, null, [])<br/>    return buildTree(g, root, null)</span><span id="982d" class="lw lx it mv b gy nd na l nb nc">function buildTree(g, node, parent):<br/>    for child in g[node.id]:<br/>        if parent != null and childId == parent.id:<br/>            continue<br/>        child = Treenode(childId, node, [])<br/>        node.children.add(child)<br/>        buildTree(g, child, node)<br/>    return node</span></pre><p id="99b7" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la im bi translated">我们定义了一个名为<em class="ke"> Treenode 的类。</em>树中的每个节点都有一个唯一的 id，这就是我们存储在 id 占位符中的内容。正如我们前面所讨论的，保存父节点始终是一个最佳实践，因为这将有助于我们返回。此外，我们保存了一些对当前节点的子节点的引用。</p><p id="36a0" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la im bi translated">然后我们定义一个名为<em class="ke"> rootTree </em>的函数，它接受两个参数——一个图和节点的 id。图<em class="ke"> g </em>将被表示为具有无向边的邻接表。<em class="ke"> rootTree </em>方法的第一行创建了一个<em class="ke"> Treenode </em>对象，带有给定的<em class="ke"> rootId </em>、父引用和子对象列表。<em class="ke"> rootTree </em>函数调用另一个名为<em class="ke"> buildTree </em>的函数，带有参数 graph g、根节点和对父节点的引用。</p><p id="e9e0" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la im bi translated"><em class="ke"> buildTree </em>方法采用我们刚刚谈到的三个参数。当我们进入函数时，我们最终会进入一个遍历当前节点所有子节点的 for 循环。我们知道边是无向的，所以我们绝对需要管理添加指向同一个节点的有向边的情况。如果不满足上述条件，我们确定我们手里有一个确诊的孩子。然后我们为<em class="ke"> Treenode </em>类创建一个对象，并将该子节点添加到当前节点的子节点列表中。之后，它使用新创建的节点将<strong class="kf jd"> <em class="ke"> DFS </em> </strong>更多地放入树中。当我们访问节点的所有邻居时，我们返回当前节点。</p><p id="b2ba" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la im bi translated">所以，这就是我们如何扎根一棵树。我们将在接下来的帖子中讨论<strong class="kf jd"> <em class="ke">树中心</em> </strong>。让我们一起继续学习。</p><p id="7822" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn lc kp kq kr ld kt ku kv le kx ky kz la im bi translated"><strong class="kf jd">干杯，全体。</strong></p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi ne"><img src="../Images/12a42ea150b669878b350084c16af78d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lgzROdVHD1jDW91xwO8mVA.png"/></div></div></figure></div></div>    
</body>
</html>