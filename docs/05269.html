<html>
<head>
<title>Census Geography with NetworkX</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用NetworkX的普查地理</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/census-geography-with-networkx-fe2aa6c8ab16?source=collection_archive---------65-----------------------#2020-05-04">https://towardsdatascience.com/census-geography-with-networkx-fe2aa6c8ab16?source=collection_archive---------65-----------------------#2020-05-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="f1da" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">公共数据</h2><div class=""/><div class=""><h2 id="5f88" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">使用Python中的图表表示人口普查地图的教程</h2></div><h2 id="7de2" class="kr ks it bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll iz bi translated">概观</h2><p id="85d4" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu la lv lw lx le ly lz ma li mb mc md me im bi translated">本教程的目标是创建一个表示纽约州各县之间地理关系的图形数据结构。具体来说，我们希望确定两个县何时相邻。</p><p id="08a1" class="pw-post-body-paragraph lm ln it lo b lp mf kd lr ls mg kg lu la mh lw lx le mi lz ma li mj mc md me im bi translated">在我们开始写代码之前，让我们想一想我们想要如何构建这些关于节点和边的关系。</p><ul class=""><li id="a320" class="mk ml it lo b lp mf ls mg la mm le mn li mo me mp mq mr ms bi translated"><strong class="lo jd">节点— </strong>每个节点将代表纽约州的一个县。它们将通过它们的FIPS(联邦信息处理标准)编号来识别。此外，每个节点将存储该县的自然语言名称以及公共交通的使用率。</li><li id="711c" class="mk ml it lo b lp mt ls mu la mv le mw li mx me mp mq mr ms bi translated"><strong class="lo jd">边— </strong>如果两个节点在地图上地理上相邻，它们将共享一条边</li></ul><h2 id="47b4" class="kr ks it bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll iz bi translated">设置</h2><p id="6e30" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu la lv lw lx le ly lz ma li mb mc md me im bi translated">要完成本教程，您需要以下内容</p><ul class=""><li id="aa0d" class="mk ml it lo b lp mf ls mg la mm le mn li mo me mp mq mr ms bi translated">一个县<a class="ae my" href="https://data.nber.org/data/county-adjacency.html" rel="noopener ugc nofollow" target="_blank">邻接文件</a>。</li><li id="5b41" class="mk ml it lo b lp mt ls mu la mv le mw li mx me mp mq mr ms bi translated">类似下面截图的人口普查数据框架。如果您对如何下载或格式化有任何疑问，请参考此处的<a class="ae my" rel="noopener" target="_blank" href="/mapping-us-census-data-with-python-607df3de4b9c"/>。</li></ul><figure class="na nb nc nd gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi mz"><img src="../Images/25f4daf35a3916f3fd414c3df6cad7fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DrXjLoXSGg1r7btaPDlxLg.png"/></div></div><p class="nl nm gj gh gi nn no bd b be z dk translated">在本教程中，我们将使用纽约州所有县的数据框架</p></figure><h2 id="01ea" class="kr ks it bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll iz bi translated">节点</h2><p id="0b7f" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu la lv lw lx le ly lz ma li mb mc md me im bi translated">首先，我们需要导入一些包并实例化我们的graph对象。我们还假设我们的人口普查数据框架将被称为df。</p><pre class="na nb nc nd gt np nq nr ns aw nt bi"><span id="eb79" class="kr ks it nq b gy nu nv l nw nx">import pandas as pd<br/>import networkx as nx</span><span id="889a" class="kr ks it nq b gy ny nv l nw nx">df=df</span><span id="013e" class="kr ks it nq b gy ny nv l nw nx">G = nx.Graph()</span></pre><p id="571e" class="pw-post-body-paragraph lm ln it lo b lp mf kd lr ls mg kg lu la mh lw lx le mi lz ma li mj mc md me im bi translated">NetworkX可以在每个节点以字典的形式存储数据。因此，为了存储我们的县名和公交使用数据，我们需要创建一个适当形式的节点列表。这将是一个2元组的列表，其中第一个元素是节点的名称，第二个元素是数据的字典。因此，单个元素将如下所示:</p><pre class="na nb nc nd gt np nq nr ns aw nt bi"><span id="01e3" class="kr ks it nq b gy nu nv l nw nx">('36081', <br/>{'percent_public_transpo': 52.27, 'county_name': 'Queens County'})</span></pre><p id="cfa0" class="pw-post-body-paragraph lm ln it lo b lp mf kd lr ls mg kg lu la mh lw lx le mi lz ma li mj mc md me im bi translated">要创建这个列表，让我们创建一个函数，该函数接收一个县的数据帧，并遍历该数据帧以返回所需的列表</p><pre class="na nb nc nd gt np nq nr ns aw nt bi"><span id="5617" class="kr ks it nq b gy nu nv l nw nx">def process_counties(df):<br/>    final_list = []<br/>    for index, row in df.iterrows():<br/>        node = (str(index), <br/>          {'percent_public_transpo': row['percent_public_transpo'],<br/>           'county_name': row['county_name']})<br/>        final_list.append(node)<br/>    return final_list</span></pre><p id="3d55" class="pw-post-body-paragraph lm ln it lo b lp mf kd lr ls mg kg lu la mh lw lx le mi lz ma li mj mc md me im bi translated">现在将这些节点添加到我们的图表中。</p><pre class="na nb nc nd gt np nq nr ns aw nt bi"><span id="691a" class="kr ks it nq b gy nu nv l nw nx">county_FIPS = process_counties(df)<br/>G.add_nodes_from(county_FIPS)</span></pre><h2 id="2d38" class="kr ks it bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll iz bi translated">优势</h2><p id="5f6e" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu la lv lw lx le ly lz ma li mb mc md me im bi translated">要添加邻接边，我们需要读入在设置部分链接的CSV邻接文件</p><pre class="na nb nc nd gt np nq nr ns aw nt bi"><span id="8221" class="kr ks it nq b gy nu nv l nw nx">adj_df = pd.read_csv('county_adjacency2010.csv')</span></pre><figure class="na nb nc nd gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi nz"><img src="../Images/0fab7705370a0ea2f85b321fcdc5f41f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N4-icZ3_Nd4dVvY0DiUlUA.png"/></div></div><p class="nl nm gj gh gi nn no bd b be z dk translated">邻接文件将会像这样读入。</p></figure><p id="0826" class="pw-post-body-paragraph lm ln it lo b lp mf kd lr ls mg kg lu la mh lw lx le mi lz ma li mj mc md me im bi translated">这是全国每个县的名单。我们需要把范围缩小到纽约州的县，否则我们会把邻近州的县也包括进来。要做到这一点，从原始df中制作一个FIPS列表，然后根据它进行过滤。</p><pre class="na nb nc nd gt np nq nr ns aw nt bi"><span id="5096" class="kr ks it nq b gy nu nv l nw nx">county_FIPS_list = list(df.index)<br/>adj_df = adj_df[adj_df['fipscounty'].isin(county_FIPS_list)]<br/>adj_df = adj_df[adj_df['fipsneighbor'].isin(county_FIPS_list)]</span></pre><p id="08f1" class="pw-post-body-paragraph lm ln it lo b lp mf kd lr ls mg kg lu la mh lw lx le mi lz ma li mj mc md me im bi translated">然后删除除FIPS代码之外的所有列</p><pre class="na nb nc nd gt np nq nr ns aw nt bi"><span id="4d2a" class="kr ks it nq b gy nu nv l nw nx">adj_df = adj_df[['fipscounty', 'fipsneighbor']]</span></pre><p id="2394" class="pw-post-body-paragraph lm ln it lo b lp mf kd lr ls mg kg lu la mh lw lx le mi lz ma li mj mc md me im bi translated">我们将定义一个函数，将数据帧转换为元组列表，同时删除任何镜像或自连接的边。</p><pre class="na nb nc nd gt np nq nr ns aw nt bi"><span id="c4b2" class="kr ks it nq b gy nu nv l nw nx">def create_tuples(df):<br/>    all_tuples = list(df.itertuples(index=False, name=None))<br/>    final_tuples = []</span><span id="4246" class="kr ks it nq b gy ny nv l nw nx">    for tuple in all_tuples:<br/>        if (tuple[1],tuple[0]) not in final_tuples:<br/>            if tuple[1] != tuple[0]:<br/>                final_tuples.append((str(tuple[0]),str(tuple[1])))</span><span id="25f9" class="kr ks it nq b gy ny nv l nw nx">   return final_tuples</span></pre><p id="92a5" class="pw-post-body-paragraph lm ln it lo b lp mf kd lr ls mg kg lu la mh lw lx le mi lz ma li mj mc md me im bi translated">最后，将邻接数据帧传递给它，并将结果添加到我们的图中。</p><pre class="na nb nc nd gt np nq nr ns aw nt bi"><span id="0cd5" class="kr ks it nq b gy nu nv l nw nx">fips_tuples = create_tuples(adj_df)<br/>G.add_edges_from(fips_tuples)</span></pre><h2 id="ea47" class="kr ks it bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll iz bi translated">肉眼观察</h2><p id="6438" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu la lv lw lx le ly lz ma li mb mc md me im bi translated">为了检查结果，我们将定义一个快速函数来绘制图形。</p><pre class="na nb nc nd gt np nq nr ns aw nt bi"><span id="445d" class="kr ks it nq b gy nu nv l nw nx">import matplotlib.pyplot as plt</span><span id="098d" class="kr ks it nq b gy ny nv l nw nx">def draw_graph(G):<br/>    plt.close()<br/>    nx.draw(G, with_labels=True, font_weight='bold')<br/>    plt.show()<br/>    return</span></pre><p id="c32b" class="pw-post-body-paragraph lm ln it lo b lp mf kd lr ls mg kg lu la mh lw lx le mi lz ma li mj mc md me im bi translated">最后，我们将把最终的graph对象传递给它来查看结果。这将是一个国家的抽象，可能看起来一点也不像纽约。</p><pre class="na nb nc nd gt np nq nr ns aw nt bi"><span id="2709" class="kr ks it nq b gy nu nv l nw nx">draw_graph(G)</span></pre><div class="na nb nc nd gt ab cb"><figure class="oa ne ob oc od oe of paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><img src="../Images/9b1c91f77fe49911ed37fbfc683c3857.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*8vuZDN4-_nIewOAjKbkF5g.png"/></div></figure><figure class="oa ne og oc od oe of paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><img src="../Images/b0499b4db62592c86b9b3048f2b63f3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*6XvoGgtCjqDqxUJQo3I7dA.png"/></div><p class="nl nm gj gh gi nn no bd b be z dk oh di oi oj translated">NYS邻接图的两种可能表示</p></figure></div><p id="ee63" class="pw-post-body-paragraph lm ln it lo b lp mf kd lr ls mg kg lu la mh lw lx le mi lz ma li mj mc md me im bi translated">就是这样。感谢您的阅读！</p></div></div>    
</body>
</html>