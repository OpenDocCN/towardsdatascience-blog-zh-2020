<html>
<head>
<title>The keys to creating a collaborative-filtering music recommender system</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建协同过滤音乐推荐系统的关键</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-keys-building-collaborative-filtering-music-recommender-65ec3900d19f?source=collection_archive---------9-----------------------#2020-03-25">https://towardsdatascience.com/the-keys-building-collaborative-filtering-music-recommender-65ec3900d19f?source=collection_archive---------9-----------------------#2020-03-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/febd3d0114b0bde4bc2387eede0d544c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1hdcGjHxlPFSnpdgF3airg.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">西蒙·诺在<a class="ae jg" href="https://unsplash.com/s/photos/music?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><div class=""/><div class=""><h2 id="a9ed" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">接下来该放哪首歌？</h2></div></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><p id="5506" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi">“ …</p><p id="086b" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><em class="mb">哦，我是个幸运的人，</em></p><p id="b40f" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><em class="mb">用双手去数我爱的人</em></p><p id="bfb5" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><em class="mb"> […。】</em></p><p id="b2aa" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><em class="mb">跟我在一起，</em></p><p id="f6f7" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><em class="mb">我们深呼吸</em></p><p id="233c" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">…”—我开始喃喃自语我最喜欢的一首歌</p><p id="0ee8" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">我仍然记得在音乐会上唱过这首歌。</p><p id="1e99" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">尽管这不是我的第一场演唱会，但这是我用第一份工资全额支付的第一场演唱会。</p><p id="a052" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">大概是我在写关于基于内容的推荐系统的时候想到了这个问题。</p><p id="69ef" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">从广义上来说，<strong class="lh jk">推荐器</strong>(或推荐)<strong class="lh jk">系统</strong>(或引擎)是一个过滤系统，其目的是预测用户对一个项目的<em class="mb">评级</em>或<em class="mb">偏好</em>:在我们的例子中是一首歌。</p><p id="1e7e" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">在推荐系统中，最常用的是<em class="mb">基于内容的过滤器</em>和<em class="mb">协同过滤器。</em></p><blockquote class="mc md me"><p id="55b1" class="lf lg mb lh b li lj kk lk ll lm kn ln mf lp lq lr mg lt lu lv mh lx ly lz ma im bi translated">基于内容的方法基于两首歌曲内容或属性的相似性给出推荐，而协作方法使用不同歌曲的评级矩阵来预测可能的偏好。</p></blockquote><p id="3953" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi mi translated"><span class="l mj mk ml bm mm mn mo mp mq di">我们</span>有兴趣了解<strong class="lh jk"> <em class="mb">协同过滤器</em> </strong>是如何工作的。该算法的目的是学习一个可以预测用户是否会从某个项目中受益的函数——这意味着用户可能会听一首歌。</p><p id="24e0" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">为此，这种类型的过滤仅依赖于用户对一组歌曲的历史偏好。</p><p id="2324" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi mi translated"><span class="l mj mk ml bm mm mn mo mp mq di"> 1 </span>答案是我们在日常生活中使用的东西:<strong class="lh jk">评级</strong>。</p><p id="2cba" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">收集用户评分有两种方式。</p><p id="9d20" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">第一种是通过使用<strong class="lh jk">明确评级</strong>，这意味着我们明确要求用户给出一个评级。这代表了来自用户的最直接的反馈，以显示他们有多喜欢一首歌。</p><p id="b7f5" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">第二种采用<strong class="lh jk">隐性评级；</strong>例如，我们检查用户是否听了一首歌，听了多长时间或多少次，这可能表明他/她喜欢那首特定的歌。</p><p id="38b2" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">这些评级可以转化为二进制(用户听或不听一首歌)，离散(1到5颗星)，或某人听一首歌的次数，或连续数字(用户听一位艺术家的总时间)。</p><p id="4a09" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">收集评级后，我们可以生成互动矩阵。</p><p id="9993" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><strong class="lh jk">交互矩阵</strong>基于许多条目，包括用户-歌曲对以及代表用户对该歌曲的评级的值。</p><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/c30d674dfbfeb7cc45da6ead8484a3b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*p1juKwITBTVN2S9WUpbhsw.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">用户给特定的歌曲评级</p></figure><p id="888d" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">一般来说，这些相互作用矩阵是巨大的(百万行百万列)，非常稀疏并且充满了缺失值。<em class="mb">为什么？</em>因为大多数项目没有被特定用户看过或评价过。</p><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mw"><img src="../Images/1fda6dcda94d98046cf1a185441e6a15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3aR_utS2WnIum-XiJH1g0g.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">显示每个用户对特定歌曲的评价的矩阵。</p></figure><p id="1c1c" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">在我们的例子中，我们将使用<a class="ae jg" href="http://millionsongdataset.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="lh jk">百万首歌曲数据集</strong> </a>，这是一百万首当代流行音乐曲目的音频特征和元数据的免费集合。</p><p id="077f" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">有两个文件会让我们感兴趣。</p><p id="1e76" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">第一个文件给出了关于用户ID、歌曲ID和收听次数的信息。我们可以从<code class="fe mx my mz na b">static.turi.com/datasets/millionsong/10000.txt</code>开始读。</p><p id="48e9" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">第二个文件将包含歌曲ID、歌曲标题和艺术家姓名。我们可以从<code class="fe mx my mz na b">static.turi.com/datasets/millionsong/song_data.csv</code>开始读</p><figure class="ms mt mu mv gt iv"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="994f" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">合并这两个文件后，我们最终得到一个数据集，其中包含200万个观察值，9567首不同的歌曲和76353个不同的用户。</p><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nd"><img src="../Images/c6a44a3ba65077fb79492f0b96a2054e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bhqtb_VES9HlajkWLQdtjQ.png"/></div></div></figure><p id="5f59" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">我们将使用<code class="fe mx my mz na b">listen_count</code>，用户听一首歌的次数作为一个隐含的评级。</p><p id="d219" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">做一些探索性分析，我们可以发现用户平均听26首歌曲，平均听16首歌曲。</p><p id="6e7c" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">我们可以很快看到，并不是所有的用户都听所有的歌。所以<code class="fe mx my mz na b">song x users</code>矩阵中的很多值都将为零。因此，我们将处理极其稀疏的数据。</p><p id="1007" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">处理这样一个稀疏矩阵，我们会占用大量的内存和资源。为了让我们的生活更容易，让我们只选择那些已经听了至少16首歌曲的用户。</p><figure class="ms mt mu mv gt iv"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="fe40" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">我们现在需要使用<code class="fe mx my mz na b">scipy-<a class="ae jg" href="https://en.wikipedia.org/wiki/Sparse_matrix" rel="noopener ugc nofollow" target="_blank">sparse matrix</a></code>来避免溢出和内存浪费。为此，我们将使用<code class="fe mx my mz na b">scipy.sparse</code>中的<code class="fe mx my mz na b"><a class="ae jg" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.html" rel="noopener ugc nofollow" target="_blank">csr_matrix</a></code>函数。</p><p id="1123" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">首先，我们将根据来自作为索引的<em class="mb"> </em> <code class="fe mx my mz na b">song_id</code>和作为列的<code class="fe mx my mz na b">user_id</code>的唯一值来重塑数据，以形成作为结果的<code class="fe mx my mz na b">DataFrame</code> <em class="mb">的轴。</em></p><p id="864c" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">然后，我们将使用函数<a class="ae jg" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.pivot.html" rel="noopener ugc nofollow" target="_blank"> pivot </a>生成一个<a class="ae jg" href="https://en.wikipedia.org/wiki/Pivot_table" rel="noopener ugc nofollow" target="_blank">透视表</a>。然后，我们将把这个表转换成一个稀疏矩阵。</p><figure class="ms mt mu mv gt iv"><div class="bz fp l di"><div class="nb nc l"/></div></figure><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ne"><img src="../Images/8c8ebcf6e10a818c36e5211cde8bf877.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ny6nzTw8iv-1TzjkMdEXdA.png"/></div></div></figure><p id="00f4" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">正如我们可以观察到的，许多值等于零。这表明用户没有听过该歌曲。</p><p id="d0d7" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi mi translated"><span class="l mj mk ml bm mm mn mo mp mq di">2</span>T13】那么，协同过滤器是如何向特定用户推荐歌曲的呢？有两种主要方法可以做到这一点。</p><p id="b737" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">它找到具有相似兴趣和行为的用户，并考虑这些相似用户所听的内容，然后做出推荐。这种技术被称为<strong class="lh jk"> <em class="mb">基于用户的方法</em> </strong>(或用户项目)。</p><p id="347a" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">或者它可以考虑用户过去考虑过什么歌曲，并推荐用户可以欣赏的新的类似歌曲；一种技术叫做<strong class="lh jk"> <em class="mb">基于项目的方法</em> </strong>(或项目-项目)。</p><p id="2a38" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi mi translated"><span class="l mj mk ml bm mm mn mo mp mq di">3</span>T25】协同过滤器用什么算法推荐新歌？有几种机器学习算法可以用于协同过滤的情况。其中，我们可以提到最近邻、聚类和矩阵分解。</p><p id="95df" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">让我们来看看它们。</p><p id="6461" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi mi translated">K<strong class="lh jk">-最近邻(kNN) </strong>被认为是基于用户和基于项目的协同过滤方法的标准方法。</p><p id="5a31" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">在我们研究这个算法在推荐系统中的具体应用之前，我们将解释kNN是什么。</p><p id="3fb1" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">kNN算法是一种监督的非参数<a class="ae jg" href="https://en.wikipedia.org/wiki/Instance-based_learning" rel="noopener ugc nofollow" target="_blank">惰性学习</a>方法，用于分类和回归。</p><p id="4473" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><em class="mb">监督</em>因为它需要标记的数据点才能工作。</p><p id="f06c" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><em class="mb">非参数</em>因为它不对数据分布做任何假设。</p><p id="025c" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><a class="ae jg" href="https://en.wikipedia.org/wiki/Lazy_learning" rel="noopener ugc nofollow" target="_blank"><em class="mb"/></a>懒是因为没有使用训练数据点做泛化；它被延迟到测试阶段。</p><p id="1552" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">这种算法是基于特征相似性的——我们可以开始看看它可以用于推荐系统的什么东西。</p><p id="9da4" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">它基本上假设相似的东西彼此靠近。在这里<a class="ae jg" rel="noopener" target="_blank" href="/how-to-measure-distances-in-machine-learning-13a396aa34ce?source=friends_link&amp;sk=adb1f38fb6c7cb31b6f2f992ad7bddbf">距离</a>再次测量两点有多相似或“接近”。</p><p id="a7af" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">想象一下，我们必须将一个数据点分为两类。</p><p id="efcd" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">我们有两个属性来描述不同的点。如果我们在x-y图中表示点及其属性，它看起来会像这样:</p><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nf"><img src="../Images/539e5a19a8944758fe39fac4f1b7ce1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0Q2YJu4Hz5vkvsjM1_o-kQ.png"/></div></div></figure><p id="609e" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">现在，kNN算法如何知道这个新点属于黄色还是绿色类别？</p><p id="8015" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">首先，它会查看它的<strong class="lh jk"> <em class="mb"> k </em> </strong>最近邻居。然后，它将通过在这些k点中投票选出最受欢迎的类来确定该点应该具有哪个类。</p><p id="4208" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">让我们来看看实际情况。如果在我们的例子中k = 5，我们需要取5个最近的邻居如下:</p><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nf"><img src="../Images/2d4e752e63f7f732a4845a34b862d06e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6hS-MabAVotnTmFh56ovvg.png"/></div></div></figure><p id="0846" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">因此，我们有3个点属于绿色类，2个点属于黄色类。所以我们的新数据点被归类为绿色。</p><p id="7815" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">注意这里。k的选择非常重要，因为在我们的情况下，如果我们设置k=3，新的数据点将被分类为黄色。</p><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nf"><img src="../Images/6d7b2134f97d716654e22edf9ded5859.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B7Trf9IwKweO6umHK4Y0KA.png"/></div></div></figure><p id="de4c" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">当我们使用kNN对一首歌曲进行预测时，该算法将计算目标歌曲与数据集中每首其他歌曲之间的距离。</p><p id="1d9d" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">然后，它会根据它们的距离进行排序。最后，它将返回前k首最近邻歌曲作为歌曲推荐。</p><p id="c32a" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">让我们使用<code class="fe mx my mz na b">Python 3.7</code>建立一个推荐系统，它依赖于k个最近邻居来推荐歌曲。</p><p id="6214" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">为此，我们将创建一个名为<code class="fe mx my mz na b">Recommender</code>的类。我们不会在这里描述整个类，相反，我们将关注它内部的主要函数。</p><p id="898f" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">我们将使用<code class="fe mx my mz na b">scikit-learn</code>中的<code class="fe mx my mz na b">NearestNeighbors</code>方法。这种方法需要几个我们应该仔细选择的参数。</p><ol class=""><li id="bed0" class="ng nh jj lh b li lj ll lm lo ni ls nj lw nk ma nl nm nn no bi translated"><strong class="lh jk">度量</strong>:要使用的距离度量。我们将使用<code class="fe mx my mz na b">cosine</code></li><li id="ffac" class="ng nh jj lh b li np ll nq lo nr ls ns lw nt ma nl nm nn no bi translated"><strong class="lh jk">算法</strong>:用于计算最近邻的算法。我们将使用一个<code class="fe mx my mz na b">brute</code>强制算法。</li><li id="8eef" class="ng nh jj lh b li np ll nq lo nr ls ns lw nt ma nl nm nn no bi translated"><strong class="lh jk"> n_neighbors: </strong>用于查询的邻居数量。我们要用<code class="fe mx my mz na b">20</code>。记得我们之前提到过，这个参数非常重要。</li></ol><p id="d4ef" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">我们还需要使模型符合数据。为此，我们将使用之前获得的稀疏矩阵。</p><figure class="ms mt mu mv gt iv"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="26ad" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">现在，我们可以使用这个拟合的模型来推荐新歌。</p><p id="f098" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">我们如何做到这一点？我们只需要输入歌曲并从歌曲中获取<code class="fe mx my mz na b">kneighbors</code>。该模型的这个属性还告诉我们，我们的歌曲与推荐的歌曲有多接近，从而允许我们对它们进行排序。</p><p id="ce6a" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">因为系统将输出歌曲的id，而不是标题，所以我们将创建一个函数，将这些索引与歌曲标题进行映射。</p><figure class="ms mt mu mv gt iv"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="0d5a" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">如果我要做推荐，我们就不会有<code class="fe mx my mz na b">id</code>。我们只知道标题。而且有时候这个名字的写法不一样。</p><p id="004c" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">我们如何解决这个问题？克服这一点的方法是将新歌曲的字符串与数据集中所有歌曲的字符串进行近似匹配，并确定它们的相似程度。</p><p id="0380" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">如果我们找到一首相似的，我们就选这首歌。</p><p id="4bd1" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">我们将使用一种叫做<a class="ae jg" href="https://www.datacamp.com/community/tutorials/fuzzy-string-python" rel="noopener ugc nofollow" target="_blank">模糊匹配</a>的普通技术来完成这项工作。我们将使用库<code class="fe mx my mz na b"><a class="ae jg" href="https://pypi.org/project/fuzzywuzzy/" rel="noopener ugc nofollow" target="_blank">fuzzywuzzy</a></code>。</p><p id="58b8" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">这个方法使用<a class="ae jg" href="https://en.wikipedia.org/wiki/Levenshtein_distance" rel="noopener ugc nofollow" target="_blank"> Levenshtein Distance </a>，它测量将一个单词序列更改为另一个单词序列所需的最少编辑次数。这些编辑可以是插入、删除或替换。</p><figure class="ms mt mu mv gt iv"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="362b" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">我们现在已经有了我们的推荐系统。所以是时候用了。</p><p id="cb82" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">我们首先需要创建一个字典，根据歌曲的id对歌曲标题进行解码。这将被传递给推荐者。</p><p id="9d08" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">然后，我们将推荐歌曲<code class="fe mx my mz na b">I believe in miracles</code>。让我们看看我们有什么！</p><figure class="ms mt mu mv gt iv"><div class="bz fp l di"><div class="nb nc l"/></div></figure><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nu"><img src="../Images/bf140927fafd6cfed1b6b2e68daadb9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sE1Sy62b7SFHjmgGmuaPSw.png"/></div></div></figure><p id="dc29" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">这种方法有一些限制。它没有很好地处理稀疏性，并且当我们有更多的用户或歌曲时，它的计算效率不高。</p><p id="ca92" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">为了克服这些限制，我们可以使用其他方法，如矩阵分解。</p><p id="08f2" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi mi translated">矩阵分解是一种实现推荐系统的强大方法。其背后的思想是在一个低维的潜在空间中表现用户和物品。</p><p id="f1e7" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">因此，换句话说，矩阵分解方法将原始的稀疏用户项矩阵分解成具有潜在特征的较低维度的稀疏矩形矩阵。</p><p id="3e83" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">这不仅解决了稀疏性问题，而且使该方法可扩展。不管矩阵有多大，你总能找到更低维度的矩阵，它们是原始矩阵的真实代表。</p><p id="95d2" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">但是什么是潜在特征呢？为什么它对推荐系统有意义？</p><p id="6044" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">想象一下，一个用户给了下面几首歌很好的评价:<em class="mb">通往地狱的公路(AC DC) </em>，<em class="mb">野兽的数量</em>，<em class="mb">，【铁娘子】，</em>水上烟(深紫色)。</p><p id="f9d0" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">我们可以把它们看作三个独立的等级。然而，如果我们的目的是找到一种更简单的方式来表达他们的偏好，我们可以说他们喜欢硬摇滚T2。</p><p id="e6fb" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><code class="fe mx my mz na b">Hard Rock</code>是一个<strong class="lh jk">的潜在特征</strong>。它们是通过更高层次的属性来表达的，而不是具体的歌曲。</p><p id="cd2a" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">矩阵分解将告诉我们一个用户与一组特征有多少关联，以及一首歌有多少属于这组潜在特征。</p><p id="b7db" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">这提供了一个优于其他协作过滤的优势:尽管两个用户没有评价过任何相同的歌曲，但如果他们共享相同的潜在特征，我们仍然可以找到他们之间的相似性。</p><p id="04dd" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">在不同的矩阵分解技术中，我们发现了流行的<em class="mb">奇异值分解(SVD) </em>。</p><p id="2613" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">当我们深入研究数学基础时，这可能是一个抽象的概念。但是我们会尽量保持简单。</p><p id="b0d8" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">假设我们有一个矩阵A，包含n个用户x m首歌曲的数据。这个矩阵可以唯一地分解成3个矩阵；姑且称之为<strong class="lh jk"> U </strong>、<strong class="lh jk"> S </strong>和<strong class="lh jk"> V </strong>。</p><p id="8348" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">就我们的歌曲推荐者而言:</p><p id="03fe" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">- <strong class="lh jk"> U </strong>是一个<em class="mb"> n </em>用户x <em class="mb"> r </em>用户潜在特征矩阵</p><p id="4491" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><strong class="lh jk"> - V </strong>是一个<em class="mb"> m </em>歌曲x <em class="mb"> r </em>歌曲-潜在特征矩阵</p><p id="704b" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><strong class="lh jk"> - </strong> <strong class="lh jk"> S </strong>是一个包含原矩阵奇异值的<em class="mb"> r x r </em> <em class="mb">非负</em>对角矩阵。</p><p id="a3e1" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">奇异值表示特定特征在预测用户偏好中的重要性。</p><p id="05b1" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><em class="mb">对角矩阵</em>是主对角线外的元素全为零的矩阵。</p><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/1000ead49941fa47144292c3377ed210.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*6ksR8xRgy1Tkoo1EipANRg.jpeg"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">单值分解:任何n×m维的矩阵A都可以分解成三个矩阵U，S，v。</p></figure><p id="1dbc" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">这三个矩阵非常容易处理。此外，将它们相乘会给我们返回原始矩阵<strong class="lh jk"> A </strong>。</p><p id="f604" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">我们以前研究过这些数据。我们知道一个用户平均听26首歌。经过进一步的探索，我们发现一首歌平均有200个用户在听，最少48个，最多8277个。</p><p id="b8b5" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">所以我们已经知道它是一个非常稀疏的矩阵。为了让我们的生活更轻松，让我们进一步过滤数据。我们将只选择那些至少被200个用户听过的歌曲。</p><figure class="ms mt mu mv gt iv"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="e206" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">我们将应用<a class="ae jg" href="https://en.wikipedia.org/wiki/Data_binning" rel="noopener ugc nofollow" target="_blank">宁滨</a>技术，而不是像现在这样使用隐式评级。</p><p id="3265" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">我们将定义10个类别。落在从0到1的区间内的原始数据值将被代表等级1所取代；如果它们落入1到2的区间，它们将被2所取代；诸如此类。最后一个类别将被赋予范围从9到2213的原始值。</p><figure class="ms mt mu mv gt iv"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="52c0" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">现在让我们尝试采用矩阵分解的方法，使用Python 3.7和一个名为<code class="fe mx my mz na b">surprise</code>的有趣库来推荐歌曲。</p><p id="1d1c" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><strong class="lh jk"> <em class="mb">惊喜</em> </strong>是一个简单易用的Python库，专门为推荐系统设计。要安装惊喜，我们只需运行:<code class="fe mx my mz na b">pip install surprise</code>。</p><figure class="ms mt mu mv gt iv"><div class="bz fp l di"><div class="nb nc l"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">运行推荐系统所需的软件包。</p></figure><p id="ac9f" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">为了从我们的<code class="fe mx my mz na b">DataFrame</code>加载数据集，我们将使用<code class="fe mx my mz na b">load_from_df()</code>方法。</p><p id="7d1b" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">我们需要传递以下参数:</p><ul class=""><li id="8709" class="ng nh jj lh b li lj ll lm lo ni ls nj lw nk ma nw nm nn no bi translated"><strong class="lh jk"> df </strong> —包含歌曲评级的数据帧。它必须有三列，分别对应于用户id、歌曲id和收视率。</li><li id="8a9e" class="ng nh jj lh b li np ll nq lo nr ls ns lw nt ma nw nm nn no bi translated"><strong class="lh jk">阅读器</strong>(<code class="fe mx my mz na b"><a class="ae jg" href="https://surprise.readthedocs.io/en/stable/reader.html#surprise.reader.Reader" rel="noopener ugc nofollow" target="_blank"><strong class="lh jk">Reader</strong></a></code>)——一个阅读文件的阅读器。只需要指定<code class="fe mx my mz na b"><strong class="lh jk">rating_scale</strong></code>字段。</li></ul><figure class="ms mt mu mv gt iv"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="1b99" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">我们将为<a class="ae jg" href="https://surprise.readthedocs.io/en/stable/matrix_factorization.html#surprise.prediction_algorithms.matrix_factorization.SVD" rel="noopener ugc nofollow" target="_blank"> SVD </a>使用内置函数。值得注意的是，这种实现(<em class="mb">由西蒙·芬克在网飞奖期间推广</em>)将一个矩阵分解为另外两个矩阵，然后使用梯度下降来寻找特征和权重的最佳值。</p><p id="e724" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">严格来说，这不是上面解释的数学SVD。</p><p id="a821" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">相反，该算法将原始矩阵分解为两个低维矩阵的乘积。</p><p id="7ecf" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">第一矩阵具有包含与每个用户相关联的潜在特征的行。第二个具有包含与歌曲相关联的潜在特征的列。</p><p id="90ba" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">首先，我们需要为我们的模型找到最适合我们现有数据的参数。</p><p id="273a" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">在交叉验证过程中，<code class="fe mx my mz na b"><a class="ae jg" href="https://surprise.readthedocs.io/en/stable/model_selection.html#surprise.model_selection.search.GridSearchCV" rel="noopener ugc nofollow" target="_blank">GridSearchCV</a></code>类将根据所选的参数组合为<code class="fe mx my mz na b">SVD</code>算法计算准确性指标。这对于找到预测算法的最佳参数集非常有用。</p><p id="ebac" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><code class="fe mx my mz na b">cross_validate</code>将为我们在网格搜索中找到的最佳估计值运行交叉验证程序，并报告准确性测量和计算时间。</p><p id="950b" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">这种方法使用<code class="fe mx my mz na b">KFold</code>作为交叉验证技术。</p><figure class="ms mt mu mv gt iv"><div class="bz fp l di"><div class="nb nc l"/></div></figure><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nx"><img src="../Images/17d9e1d685fee464c0f39490fc708b5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oWpZprip0grcEC_4WnRuGg.png"/></div></div></figure><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ny"><img src="../Images/a7d3a1f67e4b0e3f6b9c027e57f3190d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jK_15HXnGV6WnFkIzIkpfA.png"/></div></div></figure><p id="71f3" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">找到模型的最佳参数后，我们可以创建我们的最终模型。</p><p id="54d4" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">我们可以使用方法<code class="fe mx my mz na b">fit()</code>在训练集中训练算法，然后使用方法<code class="fe mx my mz na b">test()</code>返回从测试集中获得的预测。</p><figure class="ms mt mu mv gt iv"><div class="bz fp l di"><div class="nb nc l"/></div></figure><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nz"><img src="../Images/15216f33c2eeb5dbfb6bb4fbee5d4a1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vYgoU6R3F2BRh1IVuaPo4g.png"/></div></div></figure><p id="0fd4" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">现在，我们可以得到用户对特定歌曲的评价:</p><figure class="ms mt mu mv gt iv"><div class="bz fp l di"><div class="nb nc l"/></div></figure><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oa"><img src="../Images/8b0d440666b8931ac29c8aff93d83a67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZFoEwc7riNU_3Y9mhkjJDw.png"/></div></div></figure><p id="9233" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">这个模型现在可以使用了！</p><p id="af6d" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">如果您想了解代码的更多细节，可以看看我在GitHub中的repo:</p><div class="is it gp gr iu ob"><a href="https://github.com/ugis22/music_recommender" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd jk gy z fp og fr fs oh fu fw ji bi translated">UGIS 22/音乐_推荐者</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">一个推荐系统(或引擎)是一个过滤系统，其目的是预测一个评级或…</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">github.com</p></div></div><div class="ok l"><div class="ol l om on oo ok op ja ob"/></div></div></a></div><p id="7476" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">如果您好奇并渴望阅读更多内容，请阅读以下资源:</p><p id="90c4" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">Thierry Bertin-Mahieux、Daniel P.W. Ellis、Brian Whitman和Paul Lamere。<br/>百万首歌曲集。《第12届国际音乐信息检索会议论文集<br/>》(ISMIR 2011)，2011年。</p><p id="1e34" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><a class="ae jg" rel="noopener" target="_blank" href="/k-nearest-neighbors-knn-algorithm-bd375d14eec7"> k近邻算法</a>。</p><p id="243b" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><a class="ae jg" href="https://heartbeat.fritz.ai/recommender-systems-with-python-part-ii-collaborative-filtering-k-nearest-neighbors-algorithm-c8dcd5fd89b2" rel="noopener ugc nofollow" target="_blank">基于Python的推荐系统——第二部分:协同过滤(K近邻算法)</a></p><p id="bc5e" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><a class="ae jg" rel="noopener" target="_blank" href="/fuzzy-matching-at-scale-84f2bfd0c536">尺度模糊匹配</a></p><p id="b949" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><a class="ae jg" rel="noopener" target="_blank" href="/building-a-music-recommendation-engine-with-probabilistic-matrix-factorization-in-pytorch-7d2934067d4a">在PyTorch中构建概率矩阵分解的音乐推荐引擎</a>。</p><p id="5cac" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><a class="ae jg" href="https://heartbeat.fritz.ai/recommender-systems-with-python-part-iii-collaborative-filtering-singular-value-decomposition-5b5dcb3f242b" rel="noopener ugc nofollow" target="_blank">基于Python的推荐系统——第三部分:协同过滤(奇异值分解)</a></p><p id="920e" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">人工智能-全合一。<a class="ae jg" href="https://www.youtube.com/watch?v=9AP-DgFBNP4" rel="noopener ugc nofollow" target="_blank">第16.3讲</a>和<a class="ae jg" href="https://www.youtube.com/watch?v=YW2b8La2ICo" rel="noopener ugc nofollow" target="_blank">第16.4讲</a>。</p></div></div>    
</body>
</html>