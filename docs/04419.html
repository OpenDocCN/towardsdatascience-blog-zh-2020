<html>
<head>
<title>Prototyping My Video Search Engine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我的视频搜索引擎原型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/prototyping-my-video-search-engine-d6fb03c9bcd1?source=collection_archive---------57-----------------------#2020-04-20">https://towardsdatascience.com/prototyping-my-video-search-engine-d6fb03c9bcd1?source=collection_archive---------57-----------------------#2020-04-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="8276" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<a class="ae ko" rel="noopener" target="_blank" href="/evaluating-the-accuracy-of-my-video-search-engine-1235f375bd5">的上一篇文章</a>中，我评估了我的物体探测器的准确性，它在一场视频录制的比赛中发现了一个乒乓球。平均精度为0.57，模型的例子在以前从未见过的镜头上推广得很好，我鼓起勇气组装了这个原型:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ku kv l"/></div></figure><p id="25c9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">概括地说，我分享了这个问题和关于走向数据科学的建议<a class="ae ko" rel="noopener" target="_blank" href="/the-video-search-engine-my-journey-into-computer-vision-9789824e76bb"/>:</p><blockquote class="kw kx ky"><p id="6dd1" class="jq jr kz js b jt ju jv jw jx jy jz ka la kc kd ke lb kg kh ki lc kk kl km kn im bi translated">制作视频很容易，但是谁有时间看完呢？我提出一个视频搜索引擎来寻找相关的时刻。。。。我的目标是建立一个原型，它将视频记录乒乓球比赛，当球在比赛时提取视频剪辑，并向用户显示相关剪辑。</p></blockquote><p id="aabd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这篇文章展示了我的视频搜索引擎的端到端原型。</p><h2 id="73eb" class="ld le it bd lf lg lh dn li lj lk dp ll kb lm ln lo kf lp lq lr kj ls lt lu lv bi translated">系统设计</h2><p id="ed13" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn im bi translated">我喜欢从最终结果开始，然后反向工作来规划整个系统。我的目标是提供一个简单的浏览器体验，播放完整长度的视频，并为用户提供观看精彩片段的选项。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi mb"><img src="../Images/9c67be8b23e06eb4bbfa1dd891fb5e8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aQ_DM2CI2XHy_DJsaeVPQA.png"/></div></div></figure><p id="f6ff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我制作了一个系统图，这样我就可以理解我将要编码的每个组件。总体而言，我的系统包括三大要素:</p><ol class=""><li id="b9bc" class="mi mj it js b jt ju jx jy kb mk kf ml kj mm kn mn mo mp mq bi translated">函数获取视频文件，解析它的帧，在每帧上调用我的机器学习算法，并存储每个剪辑的相关时间戳；</li><li id="6217" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated">一个剪辑时间戳的数据库，当用户点击“观看精彩片段卷”按钮时，可以从浏览器调用该数据库；和</li><li id="386f" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated">根据用户输入播放全长视频或精彩片段的web体验。</li></ol><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi mw"><img src="../Images/d5174775c203d6ff7ce3fd04dd19378f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XcJp6eePyMJfxhdLIs3wCg.png"/></div></div></figure><p id="f743" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下部分包括Python代码和对每个元素的解释。</p><h2 id="95d0" class="ld le it bd lf lg lh dn li lj lk dp ll kb lm ln lo kf lp lq lr kj ls lt lu lv bi translated">1.用我的物体检测算法处理视频</h2><p id="ec86" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn im bi translated">我首先导入相关的包并初始化变量:</p><pre class="kp kq kr ks gt mx my mz na aw nb bi"><span id="55a4" class="ld le it my b gy nc nd l ne nf">import boto3<br/>import cv2<br/>import datetime<br/>import json<br/>import pytz<br/>from pytz import timezone<br/>import os<br/><br/>dynamodb = boto3.resource('dynamodb', region_name=os.environ["AWS_DEFAULT_REGION"],                          aws_access_key_id=os.environ["AWS_ACCESS_KEY_ID"],<br/>aws_secret_access_key=os.environ["AWS_SECRET_ACCESS_KEY"])</span><span id="c3ff" class="ld le it my b gy ng nd l ne nf">ddb_table = dynamodb.Table("pp-video-clips")</span><span id="6f8b" class="ld le it my b gy ng nd l ne nf">runtime_client = boto3.client('sagemaker-runtime')<br/>endpoint_name = 'pp-ball-detector-endpoint'</span><span id="51a3" class="ld le it my b gy ng nd l ne nf">test_video_file = 'tt-video-1080p.mp4' # from local in example to save time &amp; money<br/>crop_x1 = 710<br/>crop_x2 = crop_x1 + 512<br/>crop_y1 = 183<br/>crop_y2 = crop_y1 + 512<br/>timestamps = [0.0]<br/>detection_threshold = 0.50<br/>lookback_frames = 30<br/>last_n_detections = [0] * lookback_frames<br/>nth_iteration = 0<br/>shouldSaveTimestamp = 0<br/>last_n_shouldSaveTimestamp = [0, 0]<br/>nth_iteration_shouldSaveTimestamp = 0<br/>ith_frame = 0<br/>clip_id = 0<br/>clip_start_time = None<br/>clip_end_time = None</span></pre><p id="7c82" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个例子中，我使用2018年美国国家乒乓球锦标赛视频作为<code class="fe nh ni nj my b">test_video_file</code>:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ku kv l"/></div></figure><p id="21a8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我用<a class="ae ko" href="https://pypi.org/project/opencv-python/" rel="noopener ugc nofollow" target="_blank"> CV2 </a>打开视频文件，并把它放在一个<code class="fe nh ni nj my b">cap</code>变量中。然后，我存储视频中的最后一帧，因为它将帮助我处理剪辑没有其他结束时间戳的边缘情况。(<em class="kz">详见下一节。</em>)</p><pre class="kp kq kr ks gt mx my mz na aw nb bi"><span id="0dc8" class="ld le it my b gy nc nd l ne nf">cap = cv2.VideoCapture(test_video_file)<br/>cap.set(cv2.CAP_PROP_POS_AVI_RATIO,1) # fast forward to video end<br/>last_frame = cap.get(cv2.CAP_PROP_POS_FRAMES) - 1 # get final frame<br/>cap.set(cv2.CAP_PROP_POS_AVI_RATIO,0) # rewind to beginning</span></pre><p id="1b29" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我在一个<code class="fe nh ni nj my b">while</code>循环中处理每个视频帧。虽然有许多摄像机角度，但大多数相关内容都出现在桌面周围。由于我的ResNet-50对象检测器需要一个224 x 224像素的输入图像，因此我简化了这个原型，在每一帧中裁剪一个固定的正方形来检测正在运动的球。</p><pre class="kp kq kr ks gt mx my mz na aw nb bi"><span id="1064" class="ld le it my b gy nc nd l ne nf">while (cap.isOpened()):<br/>    frame_exists, frame = cap.read()<br/>    if frame_exists == False:<br/>        break<br/>    if frame_exists:<br/>        timestamp = cap.get(cv2.CAP_PROP_POS_MSEC)<br/>        crop_frame = frame[crop_y1:crop_y2, crop_x1:crop_x2]</span></pre><p id="4356" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，大多数匹配都是从这个摄像机角度发生的:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi nk"><img src="../Images/e46906582aad62913e79a1bc677c953b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4m-GIaO0CH3ikJzCD0DbQQ.png"/></div></div></figure><p id="9b24" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我的代码使用带有<code class="fe nh ni nj my b">crop_frame = frame[crop_y1:crop_y2, crop_x1:crop_x2]</code>的绿色方块，并将其传递给我的Sagemaker模型端点:</p><pre class="kp kq kr ks gt mx my mz na aw nb bi"><span id="203d" class="ld le it my b gy nc nd l ne nf">height = crop_frame.shape[0]<br/>width = crop_frame.shape[1]<br/>success, encoded_frame = cv2.imencode('.png', crop_frame)<br/><br/>response = runtime_client.invoke_endpoint(EndpointName=endpoint_name, ContentType='image/png', Body=encoded_frame.tobytes())</span><span id="1adf" class="ld le it my b gy ng nd l ne nf">result = response['Body'].read().decode('ascii')</span><span id="75c3" class="ld le it my b gy ng nd l ne nf">detections = json.loads(result)</span></pre><p id="0100" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe nh ni nj my b">detections</code>结果包括按置信度降序排列的N次检测。我选择列表中的(第一个)最佳检测，因为我的领域特定的应用程序假设在任何给定时间只能有一个乒乓球在运动。我还获取最佳检测的置信度得分，并计算边界框的x，y坐标:</p><pre class="kp kq kr ks gt mx my mz na aw nb bi"><span id="d76a" class="ld le it my b gy nc nd l ne nf">best_detection = detections['prediction'][0]<br/>(klass, score, x0, y0, x1, y1) = best_detection<br/>xmin = int(x0 * width)<br/>ymin = int(y0 * height)<br/>xmax = int(x1 * width)<br/>ymax = int(y1 * height)</span></pre><p id="c7ff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我通过比较<code class="fe nh ni nj my b">best_detection</code>得分和<code class="fe nh ni nj my b">detection_threshold</code>来确定是否检测到球。我尝试了各种阈值，我发现0.5到0.7之间的值效果最好，前提是我们使用30帧的缓冲区(下面的将详细介绍<em class="kz">)。</em></p><pre class="kp kq kr ks gt mx my mz na aw nb bi"><span id="4de7" class="ld le it my b gy nc nd l ne nf">if score &gt; detection_threshold:<br/>    ball_detection = 1<br/>else:<br/>    ball_detection = 0</span></pre><p id="2216" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">到目前为止，一切顺利。我们现在有了视频中每一帧的检测输出！</p><h2 id="27bf" class="ld le it bd lf lg lh dn li lj lk dp ll kb lm ln lo kf lp lq lr kj ls lt lu lv bi translated">2.将剪辑存储在数据库中</h2><p id="441c" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn im bi translated">但是有一个问题。鉴于视频压缩模糊和球的高速度，在<code class="fe nh ni nj my b">frame-n</code>中，球检测器可能会错过球(得分刚好低于detection_threshold)，在<code class="fe nh ni nj my b">frame-n+1</code>中找到球，然后在<code class="fe nh ni nj my b">frame-n+2</code>中错过球。如果我们从这个信号中创建视频剪辑，它将导致短暂、不连贯的突出显示。这个信号处理问题被称为<a class="ae ko" href="https://my.eng.utah.edu/~cs5780/debouncing.pdf" rel="noopener ugc nofollow" target="_blank">去抖</a>。</p><p id="3495" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了解决这个问题，我创建了一个缓冲区来确定是在当前帧还是在上一个<code class="fe nh ni nj my b">n-frames</code>中检测到球。目标是获得变量<code class="fe nh ni nj my b">shouldSaveTimestamp</code>的输出模式:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi nl"><img src="../Images/bb4147ebdceefe97a2589b9136a712ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7eqLQjTvShJxSiKl5OkFwg.png"/></div></div></figure><p id="a80d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个帧缓冲器允许球检测器偶尔出错，否则有一个总的肯定信号表明有球在运动。</p><p id="a061" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用<code class="fe nh ni nj my b">shouldSaveTimestamp</code>变量，我们可以通过在<code class="fe nh ni nj my b">shouldSaveTimestamp</code>从0 → 1时保存<code class="fe nh ni nj my b">start_timestamp</code>和在<code class="fe nh ni nj my b">shouldSaveTimestamp</code>从1→ 0时保存<code class="fe nh ni nj my b">end_timestamp</code>来进一步识别剪辑。</p><pre class="kp kq kr ks gt mx my mz na aw nb bi"><span id="0870" class="ld le it my b gy nc nd l ne nf"># create n-Frames buffer; feed latest detection back one position<br/>for nth_frame in range(len(last_n_detections)):<br/>    if nth_frame &lt; len(last_n_detections) - 1: # if not the last element, then:<br/>        last_n_detections[nth_frame] = last_n_detections[nth_frame+1]<br/>    else:<br/>        last_n_detections[nth_frame] = ball_detection</span><span id="d203" class="ld le it my b gy ng nd l ne nf"># identify when the ball is in play using the buffer<br/>if (ball_detection &gt; 0 or sum(last_n_detections) &gt; 0 ):<br/>    shouldSaveTimestamp = 1<br/>else:<br/>    shouldSaveTimestamp = 0</span><span id="a960" class="ld le it my b gy ng nd l ne nf"># create a buffer to identify 0-&gt;1 and 1-&gt;0 clip conditions<br/>last_n_shouldSaveTimestamp[0] = last_n_shouldSaveTimestamp[1]<br/>last_n_shouldSaveTimestamp[1] = shouldSaveTimestamp</span><span id="3630" class="ld le it my b gy ng nd l ne nf"># if shouldSaveTimestamp goes from 0 to 1, save "start timestamp"<br/>if last_n_shouldSaveTimestamp[0] == 0 and last_n_shouldSaveTimestamp[1] == 1:<br/>    clip_start_time = timestamp<br/><br/># if shouldSaveTimestamp goes from 1 to 0, save "end timestamp"<br/>if last_n_shouldSaveTimestamp[0] == 1 and last_n_shouldSaveTimestamp[1] == 0:<br/>    clip_end_time = timestamp</span><span id="9f9e" class="ld le it my b gy ng nd l ne nf"># handle some edge cases:<br/>if ith_frame == last_frame and clip_start_time is not None:<br/>    # take the last timestamp as the end time<br/>    clip_end_time = timestamp<br/><br/>if ith_frame == last_frame and clip_start_time is None:<br/>    # take the whole video as a clip :(<br/>    clip_start_time = 0<br/>    clip_start_time = timestamp</span></pre><p id="4da9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们有有效的开始和结束时间戳，剩下的就是在数据库中保存一个剪辑。我选择DynamoDB是因为它具有无模式的设计，以及与前端框架(如React)的简单、有据可查的连接。</p><pre class="kp kq kr ks gt mx my mz na aw nb bi"><span id="28a2" class="ld le it my b gy nc nd l ne nf">if (clip_start_time is not None and clip_end_time is not None):<br/>    # Persist clip to DynamoDB<br/>    clip_start_time = round(clip_start_time/1000, 1)<br/>    clip_end_time = round(clip_end_time/1000, 1)<br/>    ddb_item = {<br/>        'video_filename': str(clip_id),<br/>        'start_end_times': '{},{}'.format(clip_start_time, clip_end_time)<br/>    }<br/>    ddb_table.put_item(Item=ddb_item)<br/>    # reset clip start/end times<br/>    clip_start_time = None<br/>    clip_end_time = None<br/>    clip_id += 1</span><span id="7694" class="ld le it my b gy ng nd l ne nf"># increment the frame counter before looping back to the top<br/>ith_frame += 1</span></pre><p id="3d30" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">就是这样！下面是代码处理一个示例视频时我的日志输出:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi nm"><img src="../Images/ac3637f1231b7937c25c453bd0d1e261.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KtR93DnZ21jLEvpMN0ttZQ.png"/></div></div></figure><p id="6a25" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，验证数据的甜蜜喜悦传到了DynamoDB:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/5d9dc873557f2bc62c679a863afcc3df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/format:webp/1*G7Nmeazc0kukc04bv29ntw.png"/></div></figure><p id="ee48" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我应该提到，出于诊断目的，我在主<code class="fe nh ni nj my b">while</code>循环中添加了以下代码:</p><pre class="kp kq kr ks gt mx my mz na aw nb bi"><span id="9765" class="ld le it my b gy nc nd l ne nf">draw_bb_on_frame(ith_frame, crop_frame, score, xmin, ymin, xmax, ymax)</span><span id="c362" class="ld le it my b gy ng nd l ne nf"># where this function is defined earlier:<br/>def draw_bb_on_frame(ith_frame, image, score, x0, y0, x1, y1):<br/>    cv2.rectangle(image, (x0,y0),(x1,y1), (0, 0, 255), 1)<br/>    cv2.putText(image, "Confidence: {:.4f}".format(score), (10, 30),<br/>                cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 255, 0), 2)<br/>    if not cv2.imwrite('cv2-test-' + str(ith_frame) + '.jpg', image):<br/>        raise Exception("Could not write image")</span></pre><p id="9b37" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该代码片段在每个视频帧上绘制分数和边界框。不需要或不建议在最终原型中包含这一步骤，因为(1)它通过为每一帧写入一个图像来限制运行速度，并且(2)产生21，000多个图像(1.35千兆字节！)同时处理一个12分钟的视频。但是当我调试系统和调整<code class="fe nh ni nj my b">detection_threshold</code>值时，这个函数对于诊断发生了什么非常有用。</p><h2 id="14e6" class="ld le it bd lf lg lh dn li lj lk dp ll kb lm ln lo kf lp lq lr kj ls lt lu lv bi translated">3.为Web浏览器构建精彩片段卷</h2><p id="6b3f" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn im bi translated">接下来，我将展示如何加载视频，并使用获取的时间戳从浏览器调用数据库，以便在用户单击“highlight reel”按钮时对剪辑进行排序和自动播放。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi mb"><img src="../Images/9a314c536cbd9bc9352ff7a459e80bbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9x5r6HIcfr7nazK7PEFZrQ.png"/></div></div></figure><p id="d220" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我从一个基本的React应用程序<code class="fe nh ni nj my b">npx create-react-app pp-web-ui &amp;&amp; cd pp-web-ui</code>开始。然后，我添加一个视频播放器。虽然有许多选项可用，但我还是推荐<a class="ae ko" href="https://www.npmjs.com/package/video.js/v/7.0.3" rel="noopener ugc nofollow" target="_blank"> Video.js </a>，因为:</p><ul class=""><li id="6c90" class="mi mj it js b jt ju jx jy kb mk kf ml kj mm kn no mo mp mq bi translated">它支持<a class="ae ko" href="https://www.w3.org/TR/media-frags/" rel="noopener ugc nofollow" target="_blank">媒体片段协议</a>使用开始/结束时间戳标记剪辑，并且</li><li id="6937" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn no mo mp mq bi translated">它支持一个<a class="ae ko" href="https://www.npmjs.com/package/videojs-playlist" rel="noopener ugc nofollow" target="_blank">播放列表插件</a>来排序和自动播放多个这样的剪辑。</li></ul><p id="e226" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我运行<code class="fe nh ni nj my b">npm install video.js &amp;&amp; npm install videojs-playlist</code>，在web应用程序中实例化一个视频播放器，并加载完整的视频剪辑。为此，我在React应用程序的<code class="fe nh ni nj my b">/components</code>目录中创建了一个新组件<code class="fe nh ni nj my b">VideoPlayer.js</code>。</p><pre class="kp kq kr ks gt mx my mz na aw nb bi"><span id="82b2" class="ld le it my b gy nc nd l ne nf">import React from 'react';<br/>import videojs from 'video.js'<br/>import 'video.js/dist/video-js.css';<br/>import './VideoContainer.css';</span><span id="f859" class="ld le it my b gy ng nd l ne nf">export default class VideoPlayer extends React.Component {<br/> <br/>  componentDidMount() {<br/>    // instantiate Video.js<br/>    this.player = videojs(this.videoNode, this.props.vidOptions, function onPlayerReady() {<br/>      console.log('onPlayerReady', this)<br/>    });<br/>  }</span><span id="c254" class="ld le it my b gy ng nd l ne nf">// destroy player on unmount<br/>  componentWillUnmount() {<br/>    if (this.player) {<br/>      this.player.dispose()<br/>    }<br/>  }</span><span id="2126" class="ld le it my b gy ng nd l ne nf">  render() {</span><span id="5428" class="ld le it my b gy ng nd l ne nf">let playerStyle = {      <br/>            margin: '10px auto',      <br/>          }</span><span id="d32c" class="ld le it my b gy ng nd l ne nf">return (<br/>      &lt;div&gt; <br/>        &lt;div data-vjs-player&gt;<br/>          &lt;video  ref={ node =&gt; this.videoNode = node } <br/>                  className="video-js"<br/>                  style={playerStyle}<br/>          &gt;        <br/>          &lt;/video&gt;<br/>        &lt;/div&gt;<br/>      &lt;/div&gt;<br/>    )<br/>  }<br/>}</span></pre><p id="7330" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，我将那个<code class="fe nh ni nj my b">VideoPlayer.js</code>组件放在一个单独的容器组件中，在那里我处理数据库逻辑:</p><pre class="kp kq kr ks gt mx my mz na aw nb bi"><span id="d5a6" class="ld le it my b gy nc nd l ne nf">import React, { Component } from 'react';<br/>import VideoPlayer from './VideoPlayer';<br/>import './VideoContainer.css';</span><span id="6b80" class="ld le it my b gy ng nd l ne nf">const videoJsOptions = {<br/>          autoplay: true,<br/>          controls: true,<br/>          height: 480, <br/>          sources: [{<br/>                        src: '<a class="ae ko" href="http://localhost:3000/tt-video-1080p.mp4'" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/tt-video-1080p.mp4'</a>,<br/>                        type: 'video/mp4'<br/>                    }]<br/>        }</span><span id="b79f" class="ld le it my b gy ng nd l ne nf">class VideoContainer extends Component {<br/>    constructor(props) {<br/>        super(props);<br/>    }</span><span id="5702" class="ld le it my b gy ng nd l ne nf">componentDidMount(){<br/>        <br/>    }            </span><span id="e99f" class="ld le it my b gy ng nd l ne nf">render() {<br/>         return (<br/>                &lt;div&gt;<br/>                    &lt;VideoPlayer className="center" vidOptions={videoJsOptions} /&gt;;<br/>                &lt;/div&gt;<br/>            &lt;/div&gt;<br/>        )<br/>    }<br/>}</span><span id="e18a" class="ld le it my b gy ng nd l ne nf">export default VideoContainer;</span></pre><p id="b789" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，我将<code class="fe nh ni nj my b">VideoContainer.js</code>组件添加到主App.js文件中，以在浏览器中显示视频:</p><pre class="kp kq kr ks gt mx my mz na aw nb bi"><span id="4325" class="ld le it my b gy nc nd l ne nf">import React from 'react';<br/>import logo from './logo.svg';<br/>import './App.css';<br/>import VideoContainer from './components/VideoContainer';<br/>import 'bootstrap/dist/css/bootstrap.min.css';</span><span id="a08e" class="ld le it my b gy ng nd l ne nf">function App() {<br/>  return (<br/>    &lt;div className="App"&gt;<br/>      &lt;VideoContainer /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span><span id="c4cf" class="ld le it my b gy ng nd l ne nf">export default App;</span></pre><p id="d99c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">简单——源视频现在可以在网络浏览器上播放了！另外，上面的三个组件代表了前端体验的整个框架。在下面的剩余部分中，我更新了<code class="fe nh ni nj my b">VideoPlayer.js</code>和<code class="fe nh ni nj my b">VideoContainer.js</code>来获取时间戳，对它们进行排序，并在用户单击“highlight reel”按钮时自动播放剪辑。</p><h2 id="14d7" class="ld le it bd lf lg lh dn li lj lk dp ll kb lm ln lo kf lp lq lr kj ls lt lu lv bi translated">从DynamoDB获取时间戳onClick</h2><p id="73bf" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn im bi translated">在本节中，我添加了<a class="ae ko" href="https://www.npmjs.com/package/aws-sdk" rel="noopener ugc nofollow" target="_blank"> AWS-SDK包</a>并调用DynamoDB的<code class="fe nh ni nj my b">.scan</code>函数来获取数据库中的所有时间戳。</p><p id="8cf2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，我执行<code class="fe nh ni nj my b">npm install aws-sdk</code>，导入包，并初始化<code class="fe nh ni nj my b">VideoConainer.js</code>中的变量:</p><pre class="kp kq kr ks gt mx my mz na aw nb bi"><span id="5e60" class="ld le it my b gy nc nd l ne nf">import * as AWS from 'aws-sdk';</span><span id="7cd9" class="ld le it my b gy ng nd l ne nf">AWS.config.update({<br/>  region: 'us-east-1',<br/>  endpoint: 'dynamodb.us-east-1.amazonaws.com',<br/>  accessKeyId: 'USE-YOUR-OWN',<br/>  secretAccessKey: 'USE-YOUR-OWN'<br/>});</span></pre><p id="2b8d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意:我在这个例子中硬编码了DynamoDB凭证，只是出于教学目的。<code class="fe nh ni nj my b">accessKeyId</code>和<code class="fe nh ni nj my b">secretAccessKey</code> <a class="ae ko" href="https://docs.aws.amazon.com/sdk-for-javascript/v2/developer-guide/setting-credentials.html" rel="noopener ugc nofollow" target="_blank">不应该硬编码</a>在应用程序或浏览器脚本中。</p><p id="73ea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我更新<code class="fe nh ni nj my b">componentDidMount</code>来初始化DynamoDB:</p><pre class="kp kq kr ks gt mx my mz na aw nb bi"><span id="f3dd" class="ld le it my b gy nc nd l ne nf">componentDidMount(){<br/>        this.dynamodb = new AWS.DynamoDB();<br/>        this.docClient = new AWS.DynamoDB.DocumentClient();<br/>        <br/>    }</span></pre><p id="80db" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，我添加了一个click handler函数，它从DynamoDB获取时间戳，按照剪辑ID的升序对剪辑进行排序(在我的代码中称为<code class="fe nh ni nj my b">video_filename</code>，并创建一个<code class="fe nh ni nj my b">videojs-playlist</code>插件所期望的<code class="fe nh ni nj my b">sources</code>数组:</p><pre class="kp kq kr ks gt mx my mz na aw nb bi"><span id="0ec1" class="ld le it my b gy nc nd l ne nf">onClickHandler(){<br/>        var params = {<br/>          TableName: 'pp-video-clips',<br/>         };</span><span id="c3eb" class="ld le it my b gy ng nd l ne nf">this.dynamodb.scan(params, (error, result) =&gt; {<br/>            if (error) {<br/>                console.log(error);<br/>            }</span><span id="2735" class="ld le it my b gy ng nd l ne nf">                const allVideosObjects = result.Items</span><span id="9b10" class="ld le it my b gy ng nd l ne nf">                const sortedVidObj = allVideosObjects.sort((a, b) =&gt; (a.video_filename.S &gt; b.video_filename.S) ? 1 : -1)</span><span id="cfcf" class="ld le it my b gy ng nd l ne nf">               const videosObjects = sortedVidObj.map(item =&gt; { return {<br/>                    sources: [{<br/>                         src: '<a class="ae ko" href="http://localhost:3000/tt-video-1080p.mp4#t='+item.start_end_times.S" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/tt-video-1080p.mp4#t='+item.start_end_times.S</a>,<br/>                        type: 'video/mp4'<br/>                    }]<br/>                }      <br/>            })<br/>            <br/>            this.setState(videosObjects);<br/>        })            <br/>    }</span></pre><p id="d5f1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您会注意到<code class="fe nh ni nj my b">src</code>键/值对包括这个特殊的标记<code class="fe nh ni nj my b">#t='item.start_end_times.S'</code>，它表示一个媒体片段。这告诉视频播放器只播放来自<code class="fe nh ni nj my b">time = {start_time},{end_time}</code>的一个片段，然后暂停。</p><p id="ae38" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，我更新了<code class="fe nh ni nj my b">VideoContainer.js</code>组件的<code class="fe nh ni nj my b">render()</code>块，以(1)获取状态变量(在那里我存储了<code class="fe nh ni nj my b">sources</code>的数组)，(2)根据视频播放器应该播放完整长度的剪辑还是高亮剪辑的数组，有条件地呈现视频播放器，以及(3)如果单击了“观看高亮卷”按钮，则调用onClickHandler函数:</p><pre class="kp kq kr ks gt mx my mz na aw nb bi"><span id="0067" class="ld le it my b gy nc nd l ne nf">render() {        <br/>        let videosObjects = this.state; <br/>        var videoSourcesArray = Object.values(videosObjects);</span><span id="9f48" class="ld le it my b gy ng nd l ne nf">let videoBlock;<br/>        if (videoSourcesArray &amp;&amp; videoSourcesArray.length) {<br/>          videoBlock = &lt;VideoPlayer className="center" vidOptions={videoJsOptions} vidSources = {videoSourcesArray} /&gt;;<br/>        } else {<br/>          videoBlock = &lt;VideoPlayer className="center" vidOptions={videoJsOptions}/&gt;;<br/>        }</span><span id="8545" class="ld le it my b gy ng nd l ne nf">return (<br/>            &lt;div&gt;<br/>                &lt;h2 className="center big"&gt;Rod's Video Search Engine&lt;/h2&gt;<br/>                &lt;div className="pad20"&gt;<br/>                    &lt;button className="btn_reel" onClick={() =&gt; { this.onClickHandler() }}&gt;<br/>                        Watch Highlight Reel<br/>                    &lt;/button&gt;<br/>                &lt;/div&gt;<br/>                &lt;div&gt;<br/>                    {videoBlock}<br/>                &lt;/div&gt;<br/>            &lt;/div&gt;<br/>        )<br/>    }</span></pre><h2 id="7ff8" class="ld le it bd lf lg lh dn li lj lk dp ll kb lm ln lo kf lp lq lr kj ls lt lu lv bi translated">使用Video.js播放列表自动播放剪辑</h2><p id="097c" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn im bi translated">在这一节中，我将演示如何使用Video.js播放列表来自动播放剪辑。</p><p id="9aa6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，我导入包并在<code class="fe nh ni nj my b">VideoPlayer.js</code>中注册插件:</p><pre class="kp kq kr ks gt mx my mz na aw nb bi"><span id="8221" class="ld le it my b gy nc nd l ne nf">import videojsPlaylistPlugin from 'videojs-playlist';<br/>videojs.registerPlugin('playlist', videojsPlaylistPlugin);</span></pre><p id="6b9a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后我修改<code class="fe nh ni nj my b">componentDidUpdate</code>来接收来自DynamoDB的视频源数组，并开始自动播放剪辑，每个剪辑之间间隔0秒:</p><pre class="kp kq kr ks gt mx my mz na aw nb bi"><span id="ef1f" class="ld le it my b gy nc nd l ne nf">componentDidUpdate() {<br/>     this.player.playlist(this.props.vidSources);<br/>     this.player.playlist.autoadvance(0);    <br/>  }</span></pre><p id="24f9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个挑战是媒体片段在每个剪辑的结尾“暂停”视频，而不是使用“结束”事件。因此，为了让播放列表前进到下一个视频剪辑，我必须创建一个<code class="fe nh ni nj my b">onPause</code>处理程序:</p><pre class="kp kq kr ks gt mx my mz na aw nb bi"><span id="af3a" class="ld le it my b gy nc nd l ne nf">onPause(){<br/>    if(this.props.vidSources &amp;&amp; this.props.vidSources.length &gt; 0) {<br/>      this.player.playlist.next();<br/>    }<br/>  }</span></pre><p id="c61b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这种方法的一个缺点/优点是点击视频算作一个<code class="fe nh ni nj my b">onPause</code>事件，它会自动快进到下一个剪辑。让我们把它记为一个<em class="kz">特性，而不是一个bug </em>😉</p><p id="7a05" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，我更新了<code class="fe nh ni nj my b">render()</code>块中的<code class="fe nh ni nj my b">return</code>语句来监听<code class="fe nh ni nj my b">onPause</code>事件，该事件调用<code class="fe nh ni nj my b">onPause</code>处理函数:</p><pre class="kp kq kr ks gt mx my mz na aw nb bi"><span id="b20e" class="ld le it my b gy nc nd l ne nf">return (<br/>      &lt;div&gt; <br/>        &lt;div data-vjs-player&gt;<br/>          &lt;video  ref={ node =&gt; this.videoNode = node } <br/>                  className="video-js"<br/>                  style={playerStyle}<br/>                  onPause={() =&gt; { this.onPause() }}<br/>          &gt;        <br/>          &lt;/video&gt;<br/>        &lt;/div&gt;<br/>      &lt;/div&gt;<br/>    )</span></pre><p id="539b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">转眼间。完整长度的视频在加载网络应用程序时播放，当用户点击“观看精彩片段卷”按钮时，<em class="kz">球在剪辑帧</em>视频剪辑自动播放。以下是完整视频(左)和高亮显示的视频片段(右)的对比:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ku kv l"/></div></figure><p id="c6f5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在未来的版本中，我应该改进一些东西:</p><ul class=""><li id="e69e" class="mi mj it js b jt ju jx jy kb mk kf ml kj mm kn no mo mp mq bi translated">这些剪辑并不完美，有时这个原型在不到2秒的时间内就能剪辑好一个剪辑。我应该考虑一个更长的帧缓冲区来防止这种情况。</li><li id="2baa" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn no mo mp mq bi translated">我用<code class="fe nh ni nj my b">clip_id</code>的<code class="fe nh ni nj my b">string</code>而不是<code class="fe nh ni nj my b">integer</code>创建了DynamoDB表，因此对剪辑的排序是不正确的(例如，剪辑99在剪辑10之前播放)</li></ul><h2 id="9b67" class="ld le it bd lf lg lh dn li lj lk dp ll kb lm ln lo kf lp lq lr kj ls lt lu lv bi translated">在真实场景中评估原型</h2><p id="5a59" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn im bi translated">虽然上面的精彩镜头感觉很神奇，但它的工作应该不会令人惊讶，因为我在来自同一视频源的2000帧上训练了我的算法。</p><p id="eb4c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">真正的问题是:</p><blockquote class="np"><p id="fbb2" class="nq nr it bd ns nt nu nv nw nx ny kn dk translated">这个系统与真实世界的录音相比表现如何？</p></blockquote><p id="96e2" class="pw-post-body-paragraph jq jr it js b jt nz jv jw jx oa jz ka kb ob kd ke kf oc kh ki kj od kl km kn im bi translated">幸运的是，我的朋友保留了记录的比赛，供他的教练训练他。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ku kv l"/></div></figure><p id="a6f6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">哦，哦…一个白色的球在白色的墙上…🤦‍♂️</p><p id="c508" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我没有被吓住，处理了视频。但该系统产生的剪辑非常短，可能是由于摄像机角度和白墙上的白球的置信度较低。该图绘制了相对于视频时间戳的置信度得分:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi oe"><img src="../Images/35d0a77cbc39d3382f78de86acf68cdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3_B0QoFCAV7E-fK6nXzvwg.png"/></div></div></figure><p id="ffc3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在0.30的<code class="fe nh ni nj my b">detection_threshold</code>处有很多好的(真阳性)检测，但是也有同样多的假阳性，如果不是更多的话。将阈值提高到0.40(橙色虚线)消除了大多数假阳性，尽管我留下了一些真阳性(参见时间戳27.9秒处的红色标记)。).我觉得这是一个可以接受的权衡，我重新处理了视频，耗时4.76小时。</p><p id="3739" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下是我的“集锦卷”(右)与完整视频(左)的对比:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ku kv l"/></div></figure><p id="ebae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我的模型删除了大约4分钟的无趣内容(当<em class="kz">球不在</em>时，36%的录制时间)。在给Sandeep看了“精彩片段”之后，他点了点头，笑了笑，并感叹道“太棒了！”</p><h2 id="61f7" class="ld le it bd lf lg lh dn li lj lk dp ll kb lm ln lo kf lp lq lr kj ls lt lu lv bi translated">未来方向</h2><p id="e1c1" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn im bi translated">有许多问题值得探讨。举个例子，</p><ul class=""><li id="b2f8" class="mi mj it js b jt ju jx jy kb mk kf ml kj mm kn no mo mp mq bi translated">如果玩家使用橙色乒乓球，模型会失败吗？</li><li id="c5f7" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn no mo mp mq bi translated">对于探测比赛中的球来说，一些摄像机角度更差吗？</li><li id="dd00" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn no mo mp mq bi translated">我可以升级前端体验，允许用户上传他们自己的视频并识别“感兴趣的领域”吗？</li><li id="827f" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn no mo mp mq bi translated">我可以通过使用PyTorch或Keras滚动我们自己的卷积神经网络来提高模型精度吗？</li><li id="d305" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn no mo mp mq bi translated">我可以加快视频处理时间吗？(剧本花了6个小时处理了12分钟的视频！)</li><li id="0022" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn no mo mp mq bi translated">我能多快多容易地将这个原型推广到其他运动，比如击剑或网球？</li><li id="feec" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn no mo mp mq bi translated">如果我们需要预测多个类别(例如，“比赛中的球”与“比赛中的球”或“发球中的球”)，性能会如何变化？</li></ul><p id="0018" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在未来的几个月里，我将继续探索这些问题。如果你对我的结对编程感兴趣，请在评论区留言，我们可以在周末找到时间！</p></div></div>    
</body>
</html>