<html>
<head>
<title>Python Power Tip: Enumerated Types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python Power Tip:枚举类型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-power-tip-enumerated-types-9a1e606250a4?source=collection_archive---------27-----------------------#2020-05-09">https://towardsdatascience.com/python-power-tip-enumerated-types-9a1e606250a4?source=collection_archive---------27-----------------------#2020-05-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="a108" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">PYTHON 编程</h2><div class=""/><div class=""><h2 id="0855" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">表示有限选项集的正确方式</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/e688a660868a8cb6e686d46a4f59f7c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HURqaibDatTP2LAM"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@louishansel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">路易斯·汉瑟@shotsoflouis </a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="a088" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">通常，程序员希望在他们的代码中表示一些东西，这些东西的值必须属于预先确定的有限的值集合。例子包括:</p><ul class=""><li id="e5de" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md mj mk ml mm bi translated">一周中的每一天:星期一，星期二，…，星期天。</li><li id="9067" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">图像文件格式的类型:JPEG，PNG，GIF，…</li><li id="8e38" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">纸牌游戏中的花色:梅花、方块、红心、黑桃。</li><li id="d13f" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">某<a class="ae lh" href="https://en.wikipedia.org/wiki/Finite-state_machine" rel="noopener ugc nofollow" target="_blank">有限状态机</a>的状态。</li></ul><h2 id="e03e" class="ms mt it bd mu mv mw dn mx my mz dp na lr nb nc nd lv ne nf ng lz nh ni nj iz bi translated">不令人满意的替代品</h2><p id="a4b3" class="pw-post-body-paragraph li lj it lk b ll nk kd ln lo nl kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">为了解决这样的情况，许多编程语言支持<a class="ae lh" href="https://en.wikipedia.org/wiki/Enumerated_type" rel="noopener ugc nofollow" target="_blank">枚举类型</a>。Python 直到 2014 年 3 月发布 3.4 版才支持枚举类型。在那之前，Python 程序员不得不求助于一些不太理想的策略。</p><p id="6363" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">常见的解决方法是用唯一的整数值定义一些全局变量，如下所示:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="d0f1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然后剩下的代码可以根据需要使用<code class="fe nr ns nt nu b">CLUB</code>、<code class="fe nr ns nt nu b">DIAMOND</code>、<code class="fe nr ns nt nu b">HEART</code>或<code class="fe nr ns nt nu b">SPADE</code>来表示一副牌。</p><p id="9fa7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这种方法存在一些问题:</p><ul class=""><li id="27f3" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md mj mk ml mm bi translated">这些全局变量是可变的。必须确保没有代码给它们赋予不同的值。</li><li id="dde6" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">没有类型检查。很容易将其他整数值与一套牌混淆，从而导致错误。</li></ul><h2 id="0077" class="ms mt it bd mu mv mw dn mx my mz dp na lr nb nc nd lv ne nf ng lz nh ni nj iz bi translated">Python 最后添加了枚举类型</h2><p id="d5b9" class="pw-post-body-paragraph li lj it lk b ll nk kd ln lo nl kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">Python 的这一缺陷导致了各种第三方包的产生。在 2005 年有一个<a class="ae lh" href="https://www.python.org/dev/peps/pep-0354/" rel="noopener ugc nofollow" target="_blank">被拒绝的提议</a>将枚举类型添加到 Python 标准库中。然后，在 2013 年 1 月，语言开发人员之间的一次电子邮件对话再次引发了对标准支持的考虑。结果是<a class="ae lh" href="https://www.python.org/dev/peps/pep-0435/" rel="noopener ugc nofollow" target="_blank"> PEP 435 </a>，一个向标准库添加新<code class="fe nr ns nt nu b">enum</code>模块的提议。Python 的创造者吉多·范·罗苏姆于 2013 年 5 月 10 日<a class="ae lh" href="https://mail.python.org/pipermail/python-dev/2013-May/126112.html" rel="noopener ugc nofollow" target="_blank">批准了</a> PEP 435。第二年<code class="fe nr ns nt nu b">enum</code>模块首次出现在 Python 3.4 中。</p><h2 id="1db9" class="ms mt it bd mu mv mw dn mx my mz dp na lr nb nc nd lv ne nf ng lz nh ni nj iz bi translated">定义典型的枚举类型</h2><p id="7eb0" class="pw-post-body-paragraph li lj it lk b ll nk kd ln lo nl kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">对于只需要一些可选值的简单情况，您可以遵循以下模式:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="0106" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这就创建了一个枚举类型<code class="fe nr ns nt nu b">Suit</code>，它定义了四种花色的符号，称为<em class="nv">成员</em>。可选的装饰器<code class="fe nr ns nt nu b">@unique</code>增加了一个健全性检查，确保所有成员都有惟一的值。如果您不小心添加了多个具有相同值的符号，那么在执行类声明时会出现一个<code class="fe nr ns nt nu b">ValueError</code>异常。例如，以下代码将失败:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="1b20" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">运行此代码会产生以下行为:</p><pre class="ks kt ku kv gt nw nu nx ny aw nz bi"><span id="76d7" class="ms mt it nu b gy oa ob l oc od">Traceback (most recent call last):<br/>  File "cards2.py", line 2, in &lt;module&gt;<br/>    class Suit(Enum):<br/>  File "/usr/lib/python3.5/enum.py", line 573, in unique<br/>    (enumeration, alias_details))<br/>ValueError: duplicate values found in &lt;enum 'Suit'&gt;: Diamond -&gt; Club</span></pre><p id="0a7b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">此时，您可以很快发现问题所在，即<code class="fe nr ns nt nu b">Diamond</code>和<code class="fe nr ns nt nu b">Club</code>都具有相同的值:1。</p><h2 id="320e" class="ms mt it bd mu mv mw dn mx my mz dp na lr nb nc nd lv ne nf ng lz nh ni nj iz bi translated">使用枚举类型</h2><p id="b103" class="pw-post-body-paragraph li lj it lk b ll nk kd ln lo nl kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">像<code class="fe nr ns nt nu b">Suit</code>这样的枚举类型的成员是常量。在修复了<code class="fe nr ns nt nu b">Suit</code>中的唯一性问题之后，这里有一些你可以用 Python 解释器尝试的例子。首先，如果您评估其中一个成员，您会看到它的表示:</p><pre class="ks kt ku kv gt nw nu nx ny aw nz bi"><span id="5be2" class="ms mt it nu b gy oa ob l oc od">&gt;&gt;&gt; <strong class="nu jd">s = Suit.Spade</strong><br/>&gt;&gt;&gt; <strong class="nu jd">s</strong><br/>&lt;Suit.Spade: 4&gt;</span></pre><p id="84f5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">每个枚举成员还有一个<code class="fe nr ns nt nu b">name</code>属性，该属性产生字符串形式的名称:</p><pre class="ks kt ku kv gt nw nu nx ny aw nz bi"><span id="3243" class="ms mt it nu b gy oa ob l oc od">&gt;&gt;&gt; <strong class="nu jd">s.name</strong><br/>'Spade'</span></pre><p id="9ac0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">每个成员还有一个<code class="fe nr ns nt nu b">value</code>属性，它返回您给它的任何值:</p><pre class="ks kt ku kv gt nw nu nx ny aw nz bi"><span id="e50b" class="ms mt it nu b gy oa ob l oc od">&gt;&gt;&gt; <strong class="nu jd">s.value</strong><br/>4</span></pre><p id="0a0e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe nr ns nt nu b">name</code>和<code class="fe nr ns nt nu b">value</code>属性是只读的。这解决了我们上面提到的可变性问题:</p><pre class="ks kt ku kv gt nw nu nx ny aw nz bi"><span id="d8f3" class="ms mt it nu b gy oa ob l oc od">&gt;&gt;&gt; <strong class="nu jd">s.value = 7</strong><br/>Traceback (most recent call last):<br/>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>  File "/usr/lib/python3.5/types.py", line 141, in __set__<br/>    raise AttributeError("can't set attribute")<br/>AttributeError: can't set attribute</span><span id="b896" class="ms mt it nu b gy oe ob l oc od">&gt;&gt;&gt; <strong class="nu jd">s.name = 'Joker'</strong><br/>Traceback (most recent call last):<br/>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>  File "/usr/lib/python3.5/types.py", line 141, in __set__<br/>    raise AttributeError("can't set attribute")<br/>AttributeError: can't set attribute</span><span id="c2eb" class="ms mt it nu b gy oe ob l oc od">&gt;&gt;&gt; <strong class="nu jd">Suit.Heart.value = 9</strong><br/>Traceback (most recent call last):<br/>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>  File "/usr/lib/python3.5/types.py", line 141, in __set__<br/>    raise AttributeError("can't set attribute")<br/>AttributeError: can't set attribute</span></pre><p id="cfe2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">枚举成员可以直接相互比较是否相等:</p><pre class="ks kt ku kv gt nw nu nx ny aw nz bi"><span id="3c7d" class="ms mt it nu b gy oa ob l oc od">&gt;&gt;&gt; <strong class="nu jd">s == Suit.Spade</strong><br/>True</span><span id="86ae" class="ms mt it nu b gy oe ob l oc od">&gt;&gt;&gt; <strong class="nu jd">s == Suit.Heart</strong><br/>False</span><span id="6661" class="ms mt it nu b gy oe ob l oc od">&gt;&gt;&gt; <strong class="nu jd">s != Suit.Heart</strong><br/>True</span></pre><p id="a845" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这允许您编写代码来处理替代情况，如下所示:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="78ba" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">枚举成员充当字典键:</p><pre class="ks kt ku kv gt nw nu nx ny aw nz bi"><span id="4b74" class="ms mt it nu b gy oa ob l oc od">&gt;&gt;&gt; <strong class="nu jd">color = { Suit.Heart: 'red', Suit.Diamond: 'red',</strong><br/>... <strong class="nu jd">Suit.Spade: 'black', Suit.Club: 'black' }</strong></span><span id="43fd" class="ms mt it nu b gy oe ob l oc od">&gt;&gt;&gt; <strong class="nu jd">color[Suit.Club]</strong><br/>'black'</span></pre><h2 id="ecf8" class="ms mt it bd mu mv mw dn mx my mz dp na lr nb nc nd lv ne nf ng lz nh ni nj iz bi translated">类型转换</h2><p id="55d2" class="pw-post-body-paragraph li lj it lk b ll nk kd ln lo nl kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">如果在字符串中有枚举成员的名称，可以使用带括号的类型名称来获取相应的枚举成员。</p><pre class="ks kt ku kv gt nw nu nx ny aw nz bi"><span id="e152" class="ms mt it nu b gy oa ob l oc od">&gt;&gt;&gt; <strong class="nu jd">text = 'Heart'</strong><br/>&gt;&gt;&gt; <strong class="nu jd">Suit[text]</strong><br/>&lt;Suit.Heart: 3&gt;</span></pre><p id="72b1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">类型名还充当一个函数，当给定一个初始值作为参数时，该函数返回相应的成员。</p><pre class="ks kt ku kv gt nw nu nx ny aw nz bi"><span id="baaa" class="ms mt it nu b gy oa ob l oc od">&gt;&gt;&gt; <strong class="nu jd">Suit(3)</strong><br/>&lt;Suit.Heart: 3&gt;</span></pre><h2 id="6ac5" class="ms mt it bd mu mv mw dn mx my mz dp na lr nb nc nd lv ne nf ng lz nh ni nj iz bi translated">枚举类型是可枚举的</h2><p id="c360" class="pw-post-body-paragraph li lj it lk b ll nk kd ln lo nl kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">仅仅从它们的名字来看，枚举类型应该提供枚举它们包含的成员的能力是有意义的。事实也的确如此。类型名充当其成员的枚举数:</p><pre class="ks kt ku kv gt nw nu nx ny aw nz bi"><span id="cd51" class="ms mt it nu b gy oa ob l oc od">&gt;&gt;&gt; <strong class="nu jd">for x in Suit:</strong><br/>...     <strong class="nu jd">print(x)</strong><br/>... <br/>Suit.Club<br/>Suit.Diamond<br/>Suit.Heart<br/>Suit.Spade</span><span id="473a" class="ms mt it nu b gy oe ob l oc od">&gt;&gt;&gt; <strong class="nu jd">list(Suit)</strong><br/>[&lt;Suit.Club: 1&gt;, &lt;Suit.Diamond: 2&gt;, &lt;Suit.Heart: 3&gt;, &lt;Suit.Spade: 4&gt;]</span></pre><h2 id="638b" class="ms mt it bd mu mv mw dn mx my mz dp na lr nb nc nd lv ne nf ng lz nh ni nj iz bi translated">温和类型检查</h2><p id="edd1" class="pw-post-body-paragraph li lj it lk b ll nk kd ln lo nl kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">我上面提到的一个问题是，可能会混淆不同种类的枚举值。让我们添加另一个枚举类型，看看当我们试图比较它们时会发生什么。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="7bb4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">尽管<code class="fe nr ns nt nu b">Suit.Club</code>和<code class="fe nr ns nt nu b">Animal.Dog</code>具有相同的关联值 1，但它们并不相等:</p><pre class="ks kt ku kv gt nw nu nx ny aw nz bi"><span id="15e2" class="ms mt it nu b gy oa ob l oc od">&gt;&gt;&gt; <strong class="nu jd">Suit.Club == Animal.Dog</strong><br/>False</span></pre><p id="35be" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是有道理的，因为<code class="fe nr ns nt nu b">Suit</code>和<code class="fe nr ns nt nu b">Animal</code>是不同的类型，一般来说不同的类型比较起来是不相等的:</p><pre class="ks kt ku kv gt nw nu nx ny aw nz bi"><span id="0ba6" class="ms mt it nu b gy oa ob l oc od">&gt;&gt;&gt; <strong class="nu jd">Suit.Club == 1</strong><br/>False</span><span id="2138" class="ms mt it nu b gy oe ob l oc od">&gt;&gt;&gt; <strong class="nu jd">Suit.Club == 'one'</strong><br/>False</span></pre><p id="0bbe" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这有助于您避免编写代码混淆动物与卡片套装！</p><h2 id="ebac" class="ms mt it bd mu mv mw dn mx my mz dp na lr nb nc nd lv ne nf ng lz nh ni nj iz bi translated">整数枚举</h2><p id="0c30" class="pw-post-body-paragraph li lj it lk b ll nk kd ln lo nl kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">上面演示的<code class="fe nr ns nt nu b">Enum</code>基类通常是创建枚举类型最有用的方法。但是，有时您希望枚举成员的行为类似于整数常量。在这种情况下，您可能不希望抽象类型成为表示特定整数常量的符号集合。也许您有一个外部 API，它将图像文件的格式报告为 1=PNG、2=JPEG 或 3=GIF。</p><p id="3943" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这种情况下，Python <code class="fe nr ns nt nu b">enum</code>模块提供了另一个叫做<code class="fe nr ns nt nu b">IntEnum</code>的基类。下面是如何定义一个不那么挑剔的枚举类型，其中成员的行为类似于整数常量:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="cd77" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在成员<code class="fe nr ns nt nu b">ImageFormat.JPEG</code>仍然拥有自己的枚举成员身份:</p><pre class="ks kt ku kv gt nw nu nx ny aw nz bi"><span id="2f14" class="ms mt it nu b gy oa ob l oc od">&gt;&gt;&gt; <strong class="nu jd">ImageFormat.JPEG</strong><br/>&lt;ImageFormat.JPEG: 2&gt;</span></pre><p id="7aee" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，当与整数 2 比较时，它匹配:</p><pre class="ks kt ku kv gt nw nu nx ny aw nz bi"><span id="2406" class="ms mt it nu b gy oa ob l oc od">&gt;&gt;&gt; <strong class="nu jd">ImageFormat.JPEG == 2</strong><br/>True</span></pre><p id="270f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你甚至可以用它做数学，不像一个<code class="fe nr ns nt nu b">Enum</code>的成员:</p><pre class="ks kt ku kv gt nw nu nx ny aw nz bi"><span id="e7c3" class="ms mt it nu b gy oa ob l oc od">&gt;&gt;&gt; <strong class="nu jd">ImageFormat.JPEG + 1</strong><br/>3</span><span id="9add" class="ms mt it nu b gy oe ob l oc od">&gt;&gt;&gt; <strong class="nu jd">Suit.Club + 1</strong><br/>Traceback (most recent call last):<br/>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>TypeError: unsupported operand type(s) for +: 'Suit' and 'int'</span></pre><p id="5396" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">其他有用的<code class="fe nr ns nt nu b">Enum</code>功能仍然有效，比如使用名称或值枚举和获取成员:</p><pre class="ks kt ku kv gt nw nu nx ny aw nz bi"><span id="a5b2" class="ms mt it nu b gy oa ob l oc od">&gt;&gt;&gt; <strong class="nu jd">list(ImageFormat)</strong><br/>[&lt;ImageFormat.PNG: 1&gt;, &lt;ImageFormat.JPEG: 2&gt;, &lt;ImageFormat.GIF: 3&gt;]</span><span id="3cff" class="ms mt it nu b gy oe ob l oc od">&gt;&gt;&gt; <strong class="nu jd">ImageFormat(3)</strong><br/>&lt;ImageFormat.GIF: 3&gt;</span><span id="7a77" class="ms mt it nu b gy oe ob l oc od">&gt;&gt;&gt; <strong class="nu jd">ImageFormat['PNG']</strong><br/>&lt;ImageFormat.PNG: 1&gt;</span></pre><h2 id="c664" class="ms mt it bd mu mv mw dn mx my mz dp na lr nb nc nd lv ne nf ng lz nh ni nj iz bi translated">还有很多要学的</h2><p id="61ce" class="pw-post-body-paragraph li lj it lk b ll nk kd ln lo nl kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">我们已经在这里介绍了 Python 枚举类型的基础知识，这足以让您入门。现在，您可以在代码中很好地使用枚举类型了。</p><p id="02dd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，还有很多细节和细微差别。我鼓励你阅读下面链接的官方建议和文档页面。这两页都是深入理解这一重要语言特性的好读物。</p><h2 id="f99d" class="ms mt it bd mu mv mw dn mx my mz dp na lr nb nc nd lv ne nf ng lz nh ni nj iz bi translated">参考</h2><ol class=""><li id="9e99" class="me mf it lk b ll nk lo nl lr of lv og lz oh md oi mk ml mm bi translated"><a class="ae lh" href="https://www.python.org/dev/peps/pep-0435/" rel="noopener ugc nofollow" target="_blank"> PEP 435:将 Enum 类型添加到 Python 标准库</a>:这是导致将<code class="fe nr ns nt nu b">enum</code>模块添加到 Python 3.4+标准库的提议。</li><li id="0891" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md oi mk ml mm bi translated"><a class="ae lh" href="https://docs.python.org/3/library/enum.html" rel="noopener ugc nofollow" target="_blank"> Python 官方文档为</a> <code class="fe nr ns nt nu b"><a class="ae lh" href="https://docs.python.org/3/library/enum.html" rel="noopener ugc nofollow" target="_blank">enum</a></code> <a class="ae lh" href="https://docs.python.org/3/library/enum.html" rel="noopener ugc nofollow" target="_blank">模块。</a></li></ol></div></div>    
</body>
</html>