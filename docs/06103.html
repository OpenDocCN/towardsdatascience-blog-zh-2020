<html>
<head>
<title>Explaining the SettingWithCopyWarning in pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解释熊猫中带有复制警告的设置</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/explaining-the-settingwithcopywarning-in-pandas-ebc19d799d25?source=collection_archive---------7-----------------------#2020-05-18">https://towardsdatascience.com/explaining-the-settingwithcopywarning-in-pandas-ebc19d799d25?source=collection_archive---------7-----------------------#2020-05-18</a></blockquote><div><div class="fc ij ik il im in"/><div class="io ip iq ir is"><figure class="iu iv gp gr iw ix gh gi paragraph-image"><div role="button" tabindex="0" class="iy iz di ja bf jb"><div class="gh gi it"><img src="../Images/d5145ee2494d7d374cfdfc32909dee05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uSA9SQXQSAeKVgG3mHTRxA.jpeg"/></div></div><p class="je jf gj gh gi jg jh bd b be z dk translated">照片由<a class="ae ji" href="https://unsplash.com/@neonbrand?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> NeONBRAND </a>在<a class="ae ji" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><div class=""/><div class=""><h2 id="e16d" class="pw-subtitle-paragraph km jk jl bd b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dk translated">如果你想知道是什么导致了<code class="fe ki kj kk kl b">SettingwithCopyWarning</code>，这就是你要找的地方！</h2></div><p id="8616" class="pw-post-body-paragraph le lf jl lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz io bi translated">不管你和<code class="fe ki kj kk kl b">pandas</code>共事多久，是一天还是一年，迟早你都有可能遇到臭名昭著的<code class="fe ki kj kk kl b">SettingWithCopyWarning</code>。在本文中，我将解释是什么导致了这个问题，以及如何正确地解决这个问题。</p><h1 id="cc9e" class="ma mb jl bd mc md me mf mg mh mi mj mk kv ml kw mm ky mn kz mo lb mp lc mq mr bi translated">警告不是错误</h1><p id="4dd7" class="pw-post-body-paragraph le lf jl lg b lh ms kq lj lk mt kt lm ln mu lp lq lr mv lt lu lv mw lx ly lz io bi translated">在我深入研究技术细节之前，我想强调一下<code class="fe ki kj kk kl b">SettingWithCopyWarning</code>是——顾名思义——一个警告，而不是一个错误。所以我们正在执行的代码很可能不会中断并产生最终结果。然而，最终的结果可能不是我们真正想要的。</p><p id="d1c5" class="pw-post-body-paragraph le lf jl lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz io bi translated">我想强调这种区别的原因是，当我们看到代码实际上成功返回结果时，我们可能会忽略警告。事实上，结果可能是正确的！最佳实践是格外小心，并真正理解基本原理。通过这种方式，我们通常可以节省大量时间来识别一个不明显的 bug，这是我们一开始就可以避免的。</p><h1 id="8cfd" class="ma mb jl bd mc md me mf mg mh mi mj mk kv ml kw mm ky mn kz mo lb mp lc mq mr bi translated">视图与副本</h1><p id="99c5" class="pw-post-body-paragraph le lf jl lg b lh ms kq lj lk mt kt lm ln mu lp lq lr mv lt lu lv mw lx ly lz io bi translated">与<code class="fe ki kj kk kl b">SettingWithCopyWarning</code>相关的关键概念是视图和副本。<code class="fe ki kj kk kl b">pandas</code>中的一些操作(和<code class="fe ki kj kk kl b">numpy</code>一样)将返回原始数据的视图，而其他的副本。</p><p id="2ba8" class="pw-post-body-paragraph le lf jl lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz io bi translated">简单地说，<strong class="lg jm">视图</strong>是链接到原始源的原始对象(<code class="fe ki kj kk kl b">DataFrame</code>或<code class="fe ki kj kk kl b">Series</code>)的子集，而<strong class="lg jm">副本</strong>是一个全新的对象。一般来说，当我们对副本进行的操作完成后，副本就会被丢弃。这种区别的结果是，当我们修改视图时，我们也修改了原始对象。副本不会发生这种情况，因为它们没有连接到原始对象。</p><p id="0ea7" class="pw-post-body-paragraph le lf jl lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz io bi translated">描述了区别之后，<code class="fe ki kj kk kl b">SettingWithCopyWarning</code>实际上是让我们知道我们写的代码可能做了一件事，而实际上我们想做的是另一件事。我将用一个真实的例子来说明这一点。想象一下有一个大的<code class="fe ki kj kk kl b">DataFrame</code>。对于某些分析，您过滤(切分)了<code class="fe ki kj kk kl b">DataFrame</code>，使其只包含完整数据的子集，例如，来自某个国家的用户。然后，您可能想要修改提取的<code class="fe ki kj kk kl b">DataFrame</code>中的一些值，假设一个特性的最大值为 100。这是您可能遇到臭名昭著的警告的典型情况——您只想修改提取的帧，而最终却修改了源数据。你可以很容易地想象这不是你想做的事情，并可能导致以后的潜在问题。</p><p id="b72d" class="pw-post-body-paragraph le lf jl lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz io bi translated"><strong class="lg jm">注意</strong>:要了解一个框架是否是副本的视图，可以使用一个<code class="fe ki kj kk kl b">pandas.DataFrame</code>的内部<code class="fe ki kj kk kl b">_is_view</code>和<code class="fe ki kj kk kl b">_is_copy</code>方法。第一个函数返回一个布尔值，而第二个函数要么是原来的<code class="fe ki kj kk kl b">DataFrame</code>的<code class="fe ki kj kk kl b">weakref</code>，要么是<code class="fe ki kj kk kl b">None</code>。</p><h1 id="c156" class="ma mb jl bd mc md me mf mg mh mi mj mk kv ml kw mm ky mn kz mo lb mp lc mq mr bi translated">警告的常见事件</h1><p id="1187" class="pw-post-body-paragraph le lf jl lg b lh ms kq lj lk mt kt lm ln mu lp lq lr mv lt lu lv mw lx ly lz io bi translated">在这一节中，我回顾了实践中发生<code class="fe ki kj kk kl b">SettingWithCopyWarning</code>时最常见的情况。我将使用一个小的定制<code class="fe ki kj kk kl b">DataFrame</code>来举例说明这些情况，因为这对于理解逻辑来说已经足够了。</p><p id="9517" class="pw-post-body-paragraph le lf jl lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz io bi translated">为了准备数据，我运行以下代码:</p><figure class="mx my mz na gt ix"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="eee5" class="pw-post-body-paragraph le lf jl lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz io bi translated">运行代码打印出小的<code class="fe ki kj kk kl b">DataFrame</code>:</p><figure class="mx my mz na gt ix gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/0ee4407f68b125f873011ee4f5d3e341.png" data-original-src="https://miro.medium.com/v2/resize:fit:452/format:webp/1*ATgM2Fr099ADjwfJAiiu5g.png"/></div></figure><p id="5707" class="pw-post-body-paragraph le lf jl lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz io bi translated">为了清楚地理解正在发生的事情，对于下面的每一种情况，我们将从头开始—运行<code class="fe ki kj kk kl b">get_data</code>函数的结果。</p><p id="b7a5" class="pw-post-body-paragraph le lf jl lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz io bi translated">作为将来的参考，本文是使用<code class="fe ki kj kk kl b">pandas</code>版本 1.0.3 编写的。</p><h2 id="fe95" class="ne mb jl bd mc nf ng dn mg nh ni dp mk ln nj nk mm lr nl nm mo lv nn no mq np bi translated">1.链式分配</h2><p id="fa45" class="pw-post-body-paragraph le lf jl lg b lh ms kq lj lk mt kt lm ln mu lp lq lr mv lt lu lv mw lx ly lz io bi translated">为了解释链式赋值的概念，我们将依次讨论构造块。赋值操作(也称为<strong class="lg jm">设置操作</strong>)简单地设置一个对象的值。我们可以通过创建一个列表来说明这一点:</p><pre class="mx my mz na gt nq kl nr ns aw nt bi"><span id="baa1" class="ne mb jl kl b gy nu nv l nw nx">x_list = [1, 2, 3, 4, 5]</span></pre><p id="2239" class="pw-post-body-paragraph le lf jl lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz io bi translated">尽管第一个例子是基于列表的，但是同样的原则也适用于数组、<code class="fe ki kj kk kl b">Series</code>和<code class="fe ki kj kk kl b">DataFrames</code>(我们马上就会看到)。第二种类型的操作称为<strong class="lg jm"> get 操作</strong>，用于访问和返回对象的值。<strong class="lg jm">索引</strong>是一种<em class="ny"> get </em>操作，我们可以通过运行返回的<code class="fe ki kj kk kl b">x_list[0:3]</code>来索引列表</p><pre class="mx my mz na gt nq kl nr ns aw nt bi"><span id="22b8" class="ne mb jl kl b gy nu nv l nw nx">[1, 2, 3]</span></pre><p id="999c" class="pw-post-body-paragraph le lf jl lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz io bi translated">最后一个构建块叫做<strong class="lg jm">链接</strong>，本质上是指链接多个索引操作，比如<code class="fe ki kj kk kl b">x_list[0:3][1]</code>，返回 2。</p><p id="a845" class="pw-post-body-paragraph le lf jl lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz io bi translated">已经描述了所有的单个部分，通过<strong class="lg jm">链接赋值</strong>我们指的是链接和赋值的组合。是时候提及我们的玩具<code class="fe ki kj kk kl b">DataFrame</code>了。首先，我们对<code class="fe ki kj kk kl b">DataFrame</code>进行切片，以显示<code class="fe ki kj kk kl b">B</code>特性值大于 12 的观察值。</p><pre class="mx my mz na gt nq kl nr ns aw nt bi"><span id="79cb" class="ne mb jl kl b gy nu nv l nw nx">X = get_data()<br/>X[X['B'] &gt; 12]</span></pre><figure class="mx my mz na gt ix gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/50042bfcf45f5660ffc532baa591427e.png" data-original-src="https://miro.medium.com/v2/resize:fit:436/format:webp/1*LVzKsBgwp0__q9xUbnABxQ.png"/></div></figure><p id="d6af" class="pw-post-body-paragraph le lf jl lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz io bi translated">只有 2 行符合该标准。让我们用 999 替换<code class="fe ki kj kk kl b">C</code>特性的值。</p><pre class="mx my mz na gt nq kl nr ns aw nt bi"><span id="ab1b" class="ne mb jl kl b gy nu nv l nw nx">X[X['B'] &gt; 12]['C'] = 999<br/>X[X['B'] &gt; 12]['C']</span></pre><p id="8937" class="pw-post-body-paragraph le lf jl lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz io bi translated">运行上面的行会导致臭名昭著的警告:</p><pre class="mx my mz na gt nq kl nr ns aw nt bi"><span id="632e" class="ne mb jl kl b gy nu nv l nw nx">SettingWithCopyWarning: <br/>A value is trying to be set on a copy of a slice from a DataFrame.<br/>Try using .loc[row_indexer,col_indexer] = value instead</span></pre><p id="109b" class="pw-post-body-paragraph le lf jl lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz io bi translated">在生成的输出中，我们看到这些值没有被替换！</p><figure class="mx my mz na gt ix gh gi paragraph-image"><div role="button" tabindex="0" class="iy iz di ja bf jb"><div class="gh gi oa"><img src="../Images/6b753b18e74f652508fc288d6328c53c.png" data-original-src="https://miro.medium.com/v2/resize:fit:732/format:webp/1*hgA1AQaraINoYdNRIq7VOw.png"/></div></div></figure><p id="e83f" class="pw-post-body-paragraph le lf jl lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz io bi translated">我们看到警告是因为我们链接了两个索引操作。这些连锁操作在后台独立执行。第一部分是<em class="ny"> get </em>操作，它返回一个包含所有<code class="fe ki kj kk kl b">B</code>值大于 12 的行的<code class="fe ki kj kk kl b">DataFrame</code>。第二部分是<em class="ny">设置</em>的操作，并且是对新建的<code class="fe ki kj kk kl b">DataFrame</code>进行由<em class="ny">获取</em>的操作。所以我们不是在修改原来的<code class="fe ki kj kk kl b">DataFrame</code>！</p><p id="0d69" class="pw-post-body-paragraph le lf jl lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz io bi translated">当我们在一行中使用两个方括号时，这是非常明显的，然而，通过使用<code class="fe ki kj kk kl b">loc</code>、<code class="fe ki kj kk kl b">iloc</code>或访问列的点方法也会发生同样的情况。例如，运行<code class="fe ki kj kk kl b">X.loc[X[‘B’] &gt; 12][‘C’] = 999</code>会给出同样不正确的结果。</p><p id="ba6f" class="pw-post-body-paragraph le lf jl lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz io bi translated">为了正确替换<code class="fe ki kj kk kl b">DataFrame</code>中的值，我们需要以如下方式使用<code class="fe ki kj kk kl b">loc</code>:</p><pre class="mx my mz na gt nq kl nr ns aw nt bi"><span id="ddef" class="ne mb jl kl b gy nu nv l nw nx">X.loc[X['B'] &gt; 12, 'C'] = 999<br/>X[X['B'] &gt; 12]['C']</span></pre><figure class="mx my mz na gt ix gh gi paragraph-image"><div role="button" tabindex="0" class="iy iz di ja bf jb"><div class="gh gi ob"><img src="../Images/3ebad92141c859ee5c8c459903d75cda.png" data-original-src="https://miro.medium.com/v2/resize:fit:716/format:webp/1*axNv5NHf40bw53FNKMsMFw.png"/></div></div></figure><p id="e23d" class="pw-post-body-paragraph le lf jl lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz io bi translated">我们可以看到原来的<code class="fe ki kj kk kl b">DataFrame</code>中的值被成功替换。</p><h2 id="2869" class="ne mb jl bd mc nf ng dn mg nh ni dp mk ln nj nk mm lr nl nm mo lv nn no mq np bi translated">2.隐藏链接</h2><p id="020e" class="pw-post-body-paragraph le lf jl lg b lh ms kq lj lk mt kt lm ln mu lp lq lr mv lt lu lv mw lx ly lz io bi translated">隐藏链接可能是一个很难调试的问题，因为问题到底出在哪里通常不是很明显。我们将复习一个例子。首先，让我们加载数据，并使用前面案例中的知识，创建一个<code class="fe ki kj kk kl b">DataFrame</code>，它是原始数据的子集。我们过滤掉所有具有大于 101 的<code class="fe ki kj kk kl b">C</code>特性值的行。</p><figure class="mx my mz na gt ix"><div class="bz fp l di"><div class="nb nc l"/></div></figure><figure class="mx my mz na gt ix gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/e22c34a86c85d6428641098d3e12755c.png" data-original-src="https://miro.medium.com/v2/resize:fit:444/format:webp/1*JSAUBQ-uGJnbsX3iHYPRzw.png"/></div></figure><p id="8dfa" class="pw-post-body-paragraph le lf jl lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz io bi translated">经常发生的是，我们探索并进一步处理新的<code class="fe ki kj kk kl b">DataFrame</code>。让我们想象运行几行代码来进一步检查<code class="fe ki kj kk kl b">temp</code>对象，比如<code class="fe ki kj kk kl b">pandas.DataFrame</code>的<code class="fe ki kj kk kl b">shape</code>、<code class="fe ki kj kk kl b">describe</code>、<code class="fe ki kj kk kl b">plot</code>方法。</p><p id="7804" class="pw-post-body-paragraph le lf jl lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz io bi translated">我们实际上没有在这里打印输出，因为这不是重要的部分。现在，再运行几行代码后，让我们用 999 替换第一行<code class="fe ki kj kk kl b">temp</code>中<code class="fe ki kj kk kl b">C</code>特性的值:</p><pre class="mx my mz na gt nq kl nr ns aw nt bi"><span id="d907" class="ne mb jl kl b gy nu nv l nw nx">temp.loc[2, 'C'] = 999</span></pre><p id="62b7" class="pw-post-body-paragraph le lf jl lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz io bi translated">在这样做的时候，我们遇到了我们的老朋友:</p><pre class="mx my mz na gt nq kl nr ns aw nt bi"><span id="c8d1" class="ne mb jl kl b gy nu nv l nw nx">SettingWithCopyWarning: <br/>A value is trying to be set on a copy of a slice from a DataFrame.<br/>Try using .loc[row_indexer,col_indexer] = value instead</span></pre><p id="80b2" class="pw-post-body-paragraph le lf jl lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz io bi translated">让我们检查原始的和提取的<code class="fe ki kj kk kl b">DataFrames</code>中<code class="fe ki kj kk kl b">C</code>的值:</p><pre class="mx my mz na gt nq kl nr ns aw nt bi"><span id="b519" class="ne mb jl kl b gy nu nv l nw nx">print(f"New DataFrame: {temp.loc[2, 'C']}")<br/>print(f"Original DataFrame: {X.loc[2, 'C']}")</span><span id="2bb3" class="ne mb jl kl b gy od nv l nw nx"># New DataFrame: 999<br/># Original DataFrame: 102</span></pre><p id="197b" class="pw-post-body-paragraph le lf jl lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz io bi translated">所以我们真的发生了？警告的原因在于，链式索引可能出现在两行中，而不仅仅出现在一行中。当我们创建新的<code class="fe ki kj kk kl b">DataFrame</code>时，我们使用了<em class="ny"> get </em>操作的输出。这可能是原件<code class="fe ki kj kk kl b">DataFrame</code>的副本，也可能不是。在我们检查之前无法知道。引用关于链式索引的<code class="fe ki kj kk kl b">pandas</code>文档:</p><blockquote class="oe of og"><p id="b989" class="le lf ny lg b lh li kq lj lk ll kt lm oh lo lp lq oi ls lt lu oj lw lx ly lz io bi translated">除了简单的情况之外，很难预测它[链式索引]将返回一个视图还是一个副本(这取决于数组的内存布局，对此 pandas 不能保证)，…</p></blockquote><p id="a676" class="pw-post-body-paragraph le lf jl lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz io bi translated">所以当我们索引<code class="fe ki kj kk kl b">temp</code>来分配新值时，我们实际上使用了链式索引。因此，我们可能在修改<code class="fe ki kj kk kl b">temp</code>的同时也修改了<code class="fe ki kj kk kl b">X</code>。</p><p id="6d75" class="pw-post-body-paragraph le lf jl lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz io bi translated">棘手的部分是，在实际的代码库中，负责隐藏链式分配的两行代码可能被几十行代码分开，这使得识别潜在问题相当困难。</p><p id="d545" class="pw-post-body-paragraph le lf jl lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz io bi translated">为了解决这个问题，我们可以通过使用<code class="fe ki kj kk kl b">copy</code>方法直接指示<code class="fe ki kj kk kl b">pandas</code>创建原始<code class="fe ki kj kk kl b">DataFrame</code>的副本。下面，我们使用这种方法来避免隐藏链接:</p><figure class="mx my mz na gt ix"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="458f" class="pw-post-body-paragraph le lf jl lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz io bi translated">我们看到运行代码生成了正确的输出。</p><h2 id="3cd1" class="ne mb jl bd mc nf ng dn mg nh ni dp mk ln nj nk mm lr nl nm mo lv nn no mq np bi translated">3.一个假阴性的例子</h2><p id="c96a" class="pw-post-body-paragraph le lf jl lg b lh ms kq lj lk mt kt lm ln mu lp lq lr mv lt lu lv mw lx ly lz io bi translated">最后，我们回顾一下[3]中提到的假阴性(<code class="fe ki kj kk kl b">pandas</code>没有通知我们<code class="fe ki kj kk kl b">SettingWithCopyWarning</code>，而它实际上应该通知我们)。当我们在对<code class="fe ki kj kk kl b">DataFrame</code>的多个列进行切片时使用链式索引时，就会发生这种情况。我们来看两个简单的案例。</p><pre class="mx my mz na gt nq kl nr ns aw nt bi"><span id="da02" class="ne mb jl kl b gy nu nv l nw nx">X = get_data()<br/>X.loc[X['A'] &gt; 2, ['A', 'B']]['A'] = 999<br/>X</span></pre><p id="1072" class="pw-post-body-paragraph le lf jl lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz io bi translated">和</p><pre class="mx my mz na gt nq kl nr ns aw nt bi"><span id="14d3" class="ne mb jl kl b gy nu nv l nw nx">X = get_data()<br/>X[['A', 'B', 'C']]['A'] = 999<br/>X</span></pre><p id="2fd5" class="pw-post-body-paragraph le lf jl lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz io bi translated">两者都产生了下面的结果，但没有真正显示出<code class="fe ki kj kk kl b">SettingWithCopyWarning</code>。</p><figure class="mx my mz na gt ix gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/d58c7ef89e8d7f7d9eb2909e6a2b593f.png" data-original-src="https://miro.medium.com/v2/resize:fit:448/format:webp/1*qhUkfQVSNl-bjAzInEUB2Q.png"/></div></figure><p id="81db" class="pw-post-body-paragraph le lf jl lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz io bi translated">从上面的图片中我们可以看到，这些值并没有按照我们想要的那样被修改。由于在索引操作中包含多个列，因此没有显示警告。我们可以很容易地验证在单个列的情况下不会发生这种情况——运行<code class="fe ki kj kk kl b">X[[‘C’]][‘C’] = 999</code> <br/>会产生警告并且不会修改<code class="fe ki kj kk kl b">X</code>。</p><h1 id="dc57" class="ma mb jl bd mc md me mf mg mh mi mj mk kv ml kw mm ky mn kz mo lb mp lc mq mr bi translated">关于警告来源的更深层次的背景</h1><p id="8d60" class="pw-post-body-paragraph le lf jl lg b lh ms kq lj lk mt kt lm ln mu lp lq lr mv lt lu lv mw lx ly lz io bi translated">我们可以说<code class="fe ki kj kk kl b">pandas</code>从<code class="fe ki kj kk kl b">numpy</code>继承了视图和副本的概念。在引擎盖下，<code class="fe ki kj kk kl b">pandas</code>使用<code class="fe ki kj kk kl b">numpy</code>进行高效的数据存储和操作。在<code class="fe ki kj kk kl b">numpy</code>中，视图和副本遵循一组特定的规则，并以可预测的方式返回(更多信息见【5】)。那么为什么<code class="fe ki kj kk kl b">pandas</code>不是这样呢？问题在于<code class="fe ki kj kk kl b">numpy</code>数组被限制为单一数据类型。正如我们所知，<code class="fe ki kj kk kl b">pandas</code>的情况并非如此。</p><p id="6693" class="pw-post-body-paragraph le lf jl lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz io bi translated">实际上，在多数据类型<code class="fe ki kj kk kl b">DataFrame</code>上的索引(<em class="ny"> get </em>操作)将总是返回一个帧的副本。对单一类型框架的相同操作几乎总是返回基于单一<code class="fe ki kj kk kl b">numpy</code>数组的视图，这是解决问题的最有效方式。然而，正如我们在文档的引用中已经看到的，返回视图依赖于对象的内存布局，不幸的是不能保证。</p><p id="c535" class="pw-post-body-paragraph le lf jl lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz io bi translated">综上所述，<code class="fe ki kj kk kl b">pandas</code>尽最大努力将其通用的索引方法(由于这种方法，它非常流行，并且基本上是用 Python 进行数据科学研究的先决条件)和使用底层<code class="fe ki kj kk kl b">numpy</code>数组的效率结合起来。这导致了一些小麻烦，然而，这种权衡绝对是值得的，并且通过正确理解<code class="fe ki kj kk kl b">pandas</code>在引擎盖下如何工作，这些问题可以被克服。</p><h1 id="df40" class="ma mb jl bd mc md me mf mg mh mi mj mk kv ml kw mm ky mn kz mo lb mp lc mq mr bi translated">结论</h1><p id="3fba" class="pw-post-body-paragraph le lf jl lg b lh ms kq lj lk mt kt lm ln mu lp lq lr mv lt lu lv mw lx ly lz io bi translated">在这篇文章中，我解释了 pandas 中副本和视图之间的区别，以及它们与臭名昭著的<code class="fe ki kj kk kl b">SettingWithCopyWarning</code>之间的关系。主要的想法缩小到知道什么是链式索引以及如何成功地避免它。一般规则是:</p><ul class=""><li id="a4f8" class="ol om jl lg b lh li lk ll ln on lr oo lv op lz oq or os ot bi translated">如果要改变原来的<code class="fe ki kj kk kl b">DataFrame</code>，使用单赋值。</li><li id="caad" class="ol om jl lg b lh ou lk ov ln ow lr ox lv oy lz oq or os ot bi translated">如果您想要制作一个<code class="fe ki kj kk kl b">DataFrame</code>的副本，请使用<code class="fe ki kj kk kl b">copy</code>方法显式地这样做。</li></ul><p id="c024" class="pw-post-body-paragraph le lf jl lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz io bi translated">遵循这两条规则可以节省您调试一些奇怪情况的大量时间，尤其是在冗长的代码库中。</p><p id="ea84" class="pw-post-body-paragraph le lf jl lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz io bi translated">同样值得一提的是，<code class="fe ki kj kk kl b">SettingWithCopyWarning</code>仅在我们使用<em class="ny"> set </em>操作(赋值)时发生。然而，最好也避免对<em class="ny"> get </em>操作进行链式索引。这是因为链式操作通常比较慢，如果您后来决定将<em class="ny"> set </em>操作添加到代码中，可能会导致问题。</p><p id="93dc" class="pw-post-body-paragraph le lf jl lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz io bi translated">您可以在我的<a class="ae ji" href="https://github.com/erykml/medium_articles/blob/master/Data%20Wrangling/SettingwithCopyWarning_explained.ipynb" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到本文使用的代码。一如既往，我们欢迎任何建设性的反馈。你可以在推特上或者评论里联系我。</p><h1 id="ebe5" class="ma mb jl bd mc md me mf mg mh mi mj mk kv ml kw mm ky mn kz mo lb mp lc mq mr bi translated">参考</h1><p id="5365" class="pw-post-body-paragraph le lf jl lg b lh ms kq lj lk mt kt lm ln mu lp lq lr mv lt lu lv mw lx ly lz io bi translated">[1]<a class="ae ji" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html" rel="noopener ugc nofollow" target="_blank">https://pandas . pydata . org/pandas-docs/stable/user _ guide/indexing . html</a></p><p id="0d56" class="pw-post-body-paragraph le lf jl lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz io bi translated">[2]<a class="ae ji" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy" rel="noopener ugc nofollow" target="_blank">https://pandas . pydata . org/pandas-docs/stable/user _ guide/indexing . html # return-a-view-vs-a-copy</a></p><p id="a375" class="pw-post-body-paragraph le lf jl lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz io bi translated"><a class="ae ji" href="https://github.com/pandas-dev/pandas/issues/9767" rel="noopener ugc nofollow" target="_blank">https://github.com/pandas-dev/pandas/issues/9767</a></p><p id="92d9" class="pw-post-body-paragraph le lf jl lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz io bi translated">[4]<a class="ae ji" href="https://www.practicaldatascience.org/html/views_and_copies_in_pandas.html" rel="noopener ugc nofollow" target="_blank">https://www . practical data science . org/html/views _ and _ copies _ in _ pandas . html</a></p><p id="f201" class="pw-post-body-paragraph le lf jl lg b lh li kq lj lk ll kt lm ln lo lp lq lr ls lt lu lv lw lx ly lz io bi translated">[5]<a class="ae ji" href="https://scipy-cookbook.readthedocs.io/items/ViewsVsCopies.html" rel="noopener ugc nofollow" target="_blank">https://scipy-cookbook . readthedocs . io/items/viewsvscopies . html</a></p></div></div>    
</body>
</html>