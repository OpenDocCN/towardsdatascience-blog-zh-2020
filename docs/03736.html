<html>
<head>
<title>Dealing with Growing Impatience? Push your Real-Time ML Services to Production on AWS!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">处理越来越不耐烦？在AWS上将您的实时ML服务推向生产！</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/dealing-with-growing-impatience-push-your-real-time-ml-services-to-production-on-aws-b5c948b05078?source=collection_archive---------34-----------------------#2020-04-07">https://towardsdatascience.com/dealing-with-growing-impatience-push-your-real-time-ml-services-to-production-on-aws-b5c948b05078?source=collection_archive---------34-----------------------#2020-04-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e4f2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为您的ML应用程序构建正确的云基础设施通常被低估。这里可以看到，由于广泛普及的云资源调配，这变得多么容易。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/16760ae08053ea20b220c22833804345.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CYektXnDkru344828Ft-Rg.png"/></div></div></figure><p id="f429" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi lq translated">最近，我看到研究小组、学生或同事想出一个取得巨大成就的模型的次数令人吃惊。(我不是在说通过CT扫描检测COVID的50张图像的95%准确性……)人工智能革命已经将它的一桶新应用带到了现实世界，但都面临着同样的问题:产品-市场-适合(这是一个太大的主题，无法在这里涵盖)和具体化。幸运的是，由于硬件价格的下降和云计算可靠性的提高，超大规模和大计算已经迅速普及。在本文中，我将花一些时间来讨论一组特定的ML应用程序的后者:实时服务。</p><p id="ba06" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">其中，最受欢迎的当然是实时异常或欺诈检测、即时定价、社交媒体平台、聊天机器人或花式流媒体。在牵强的一端，你们中的一些在协作平台上工作的人已经使用了一些，甚至没有注意到通过推荐或音频流去噪。决策正在快速发展，急躁是最新一代人的最大特点之一，这迫使当前设计的应用程序必须巧妙应对实时交互和解释的需求。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lz"><img src="../Images/749d7238324055bd6116ed8fe4e6b378.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*VdZdz_o7hcge9fO4.png"/></div></div><p class="ma mb gj gh gi mc md bd b be z dk translated"><a class="ae me" href="https://www.mdpi.com/2411-5134/4/1/8" rel="noopener ugc nofollow" target="_blank">机器学习应用:不同行业过去和现在的研究趋势</a></p></figure><p id="4e88" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Alriiiiiight，太多让人兴奋的理由了！我将尽我所能帮助您弄清楚构建这样的服务并使您的用户能够使用它们需要做些什么。</p><h1 id="a7a4" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">流式要求101</h1><p id="9b25" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi lq translated"><span class="l lr ls lt bm lu lv lw lx ly di">在</span>架构方面，流确实意味着你需要为两个利益相关者之间的持续信息流打开大门。该流将源自一个用户，并且必须保持活动，直到该用户或他的对应方关闭该流。在协议方面，这涉及到WebSockets的创建。从概念上讲，它们主要是一个允许信息同时从A传到B，从B传到A的系统。这就是我们所说的全双工连接。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/63e57fb4dbb867669ace330fc6714d3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1fwsuRnKNB95FM5t.png"/></div></div><p class="ma mb gj gh gi mc md bd b be z dk translated">演职员表:<a class="ae me" href="https://www.fullstackpython.com/websockets.html" rel="noopener ugc nofollow" target="_blank">fullstackpython.com/websockets.html</a></p></figure><p id="0b35" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">幸运的是，有多种方法可以将WebSockets服务包含到您的产品中。我给你一个沙盒模板，让你在我的<a class="ae me" href="https://github.com/Coricos/Challenger/tree/master/templates/beanstalk-streaming" rel="noopener ugc nofollow" target="_blank"> Github </a>上玩。在那个例子中，我使用<strong class="kw iu">砂箱</strong>作为基础，<strong class="kw iu">砂箱插座</strong>作为工人，<strong class="kw iu"> gunicorn </strong>作为主管。flask-sockets附带了一个非常方便的包装，可以快速制作原型并对产品进行足够的控制。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ma mb gj gh gi mc md bd b be z dk translated">烧瓶插座用法的沙盒示例</p></figure><p id="00c8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">出乎意料的是，我总是发现测试一个依赖于WebSockets的端点比实际实现它更难。在这些可能性中，有一种是由<a class="ae me" href="https://ngrok.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu"> Ngrok </strong> </a>提供的，这种服务允许你通过安全的隧道管理将你的本地机器转换成具有公共地址的适当端点。然而，Ngrok的免费版本有一些限制(一次1个服务，上限为每分钟40个连接)。在某些情况下，它非常方便，但在其他情况下就不那么方便了。我建议你随时尝试一下！:)</p><p id="ba15" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">同时，只需使用下面的代码片段运行启用了WebSocket workers的Flask服务器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ma mb gj gh gi mc md bd b be z dk translated">运行本地接受WebSockets的实例的代码段</p></figure><p id="3aee" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面的代码片段通过这些工人将文件传输到您的应用程序:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ma mb gj gh gi mc md bd b be z dk translated">流媒体应用的测试功能示例</p></figure><p id="f0f3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">前面的示例使您能够发送来自音频文件的流。很明显，您可以调整前面的代码片段来发送您的麦克风、视频帧、消息等输入……可能性是无限的！</p><h1 id="2616" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated"><strong class="ak">AWS上生产实例的技巧和提示</strong></h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/ca7ec98cb21bcf31c2b37238f8066093.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LeFf8bqCzF3ZUlG4p9JQAw.png"/></div></div></figure><p id="92a1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi lq translated">保留前面的步骤已经很不错了，因为它让你能够展示你从一开始就在起草的申请。最有趣的部分是把管道放到云上，让其他人也能使用。以下是要遵循的步骤，所有代码都可以在<a class="ae me" href="https://github.com/Coricos/Challenger/tree/master/templates/beanstalk-streaming" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到:</p><ul class=""><li id="3c74" class="ng nh it kw b kx ky la lb ld ni lh nj ll nk lp nl nm nn no bi translated"><em class="np">以正确的方式建立你的Docker形象:</em></li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ma mb gj gh gi mc md bd b be z dk translated">流式应用程序的Dockerfile</p></figure><p id="f877" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这可能是您可以在本地运行的最后一个测试。在这一点上，浏览<strong class="kw iu"> Docker </strong>是关于云基础设施的良好实践。容器化使您能够为自己保留一些<strong class="kw iu">云不可知论</strong>，同时控制您的版本。为了最大化这种不可知论，我的方法通常是使用AWS的<strong class="kw iu"> Elastic Beanstalk </strong>实例，它可以非常无缝地运行我的Docker映像，并支持足够的配置。</p><ul class=""><li id="30b0" class="ng nh it kw b kx ky la lb ld ni lh nj ll nk lp nl nm nn no bi translated"><em class="np">基础架构草案:</em></li></ul><p id="3cc1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">安全性是一个大问题，但我不会在本文中详细讨论虚拟私有云和静态加密。我将从一个简单的概念证明开始，您可以在自己的云上运行和扩展。共享的代码片段将使您能够构建一个安全的WebSocket连接，通过<strong class="kw iu">经典负载平衡器</strong>捕获流，并通过<strong class="kw iu"> SSL </strong>将该信息传输到您的应用程序。这里的这个应用程序仅仅是一个将接收到的数据存储在一个<strong class="kw iu">弹性文件存储器</strong>(仅仅是一个挂载的虚拟硬盘驱动器)上的应用程序，您可以在不同的实例之间共享它以供进一步处理。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/79279fecd49b717eeae1d2a692cdcd6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4RqVXwi_yqcIanockAI_Rg.png"/></div></div></figure><ul class=""><li id="f54d" class="ng nh it kw b kx ky la lb ld ni lh nj ll nk lp nl nm nn no bi translated"><em class="np">举个有用的例子:</em></li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/3730ac706a991586f0f5efcf146a3ae2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pBvSplfGuYb_QDW_8tdt1w.png"/></div></div></figure><h1 id="e5b2" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">最后一步:实例配置！</h1><p id="e89c" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi lq translated">这就是奇迹发生的地方。由于我必须浏览大量的论坛和文档，这当然是你会发现最有价值的地方！:)</p><ul class=""><li id="33fb" class="ng nh it kw b kx ky la lb ld ni lh nj ll nk lp nl nm nn no bi translated">使您的听众能够听到入站流:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ma mb gj gh gi mc md bd b be z dk translated">。ebextensions/listeners.config</p></figure><ul class=""><li id="8b57" class="ng nh it kw b kx ky la lb ld ni lh nj ll nk lp nl nm nn no bi translated">使您的实例能够在WebSockets端口上反向代理:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ma mb gj gh gi mc md bd b be z dk translated">。ebextensions/websockets.config</p></figure><p id="44dc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于配置的其余部分，一切都在<code class="fe ns nt nu nv b">.ebextensions</code>目录中可用。在其他任务中，这些文件将启用<strong class="kw iu"> HTTPS </strong>，在您的请求中启用<strong class="kw iu">头</strong>的使用，并且<strong class="kw iu">将您的弹性文件存储虚拟硬盘</strong>挂载到您的实例中。<code class="fe ns nt nu nv b">.Dockerrun.aws.json</code>文件将与安装EFS端点的实例进行通信。</p><h1 id="9a0b" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">有多有用？让我向你介绍卡拉斯特！</h1><p id="1f37" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi lq translated">阿拉斯特是一个设计用于紧急呼叫中心收集、分析和优先排序信息的平台。更好的信息可以帮助急救人员以更有效的方式应对紧急情况。通过从呼叫分析到可视化的一系列服务，CalAster允许急救人员更好地了解紧急情况并做好心理准备。此外，CalAster的优先排序工具可以有效地对来电进行分类。在自然灾害期间，当资源短缺，紧急呼叫中心不堪重负时，这一点尤其有用。以下是该架构过去的一瞥，让我们进入了2019年  <strong class="kw iu">代码的<a class="ae me" href="https://funginstitute.berkeley.edu/news/meng-alumni-address-disaster-response-through-project-aster/" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu">决赛。</strong></a></strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/f8b55973a65a3b4474de9cbdc08d60da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8rD7kN4QVqhHAZB27s-dSA.png"/></div></div></figure><h1 id="4271" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated"><strong class="ak">为了冒险者… </strong></h1><p id="be77" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">你们中的一些人可能已经在抱怨了，因为实时ML的真正界限通常是推理时间。当你在大型模型上工作时，即使是在GPU上，也很难让它运行得和你的入站流一样快。目前思考这个问题的方式仍在前进:策略中有模型<strong class="kw iu">量化</strong>和模型<strong class="kw iu">修剪</strong>。我将让您探索这两个Github库，它们仍在积极开发中！</p><blockquote class="nx ny nz"><p id="e589" class="ku kv np kw b kx ky ju kz la lb jx lc oa le lf lg ob li lj lk oc lm ln lo lp im bi translated"><a class="ae me" href="https://github.com/NVlabs/condensa" rel="noopener ugc nofollow" target="_blank"> Condensa </a>是Python中<em class="it">可编程模型压缩</em>的框架。它附带了一组内置的压缩运算符，可用于针对DNN体系结构、硬件平台和优化目标的特定组合构建复杂的压缩方案。为了恢复压缩过程中的任何精度损失，Condensa使用模型压缩的约束优化公式，并采用基于增强拉格朗日的算法作为优化器。</p><p id="2176" class="ku kv np kw b kx ky ju kz la lb jx lc oa le lf lg ob li lj lk oc lm ln lo lp im bi translated">激流是一个函数、脚本和工具的集合，它使得超低位宽的神经网络能够被容易地高速训练和部署。激流建立在Tensorflow之上，用于训练，TVM用于部署。激流模型使用一种称为<em class="it">融合胶</em>的新型算子来取代二进制神经网络内部的所有浮点运算。通过将融合的粘合层与其他优化(如<em class="it"> Bitpack Fusion </em>)相结合，Riptide能够生成比Raspberry Pi上的浮点对等物运行速度快4-12倍的模型。</p></blockquote><h1 id="6b36" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">拜托，要有创意！</h1><p id="a296" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld mz lf lg lh na lj lk ll nb ln lo lp im bi translated">有那么多的问题需要解决，而解决这些问题的人却那么少。如果你有了一个想法，要知道有大量的信息可供你建立你的想法，并把它从一个概念变成一个有影响力的实际产品！</p><p id="45c6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有兴趣保持联系吗？:D<a class="ae me" href="https://twitter.com/DindinMeryll" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae me" href="https://www.linkedin.com/in/dindin-meryll/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae me" href="https://github.com/Coricos" rel="noopener ugc nofollow" target="_blank">Github</a>|<a class="ae me" href="https://medium.com/@merylldin" rel="noopener">Medium</a></p></div></div>    
</body>
</html>