<html>
<head>
<title>5 Wrong Use Cases Of Python List Comprehensions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 列表理解的 5 个错误用例</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/5-wrong-use-cases-of-python-list-comprehensions-e8455fb75692?source=collection_archive---------38-----------------------#2020-07-06">https://towardsdatascience.com/5-wrong-use-cases-of-python-list-comprehensions-e8455fb75692?source=collection_archive---------38-----------------------#2020-07-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e84f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">知道什么时候不使用列表理解</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e36162156baf4863bd1b8db84da03b65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*f-b_Nb6c_a9csM1U"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@kris_ricepees?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">加里·本迪格</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="f6a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">列表理解无疑是 Python 最强大的特性。它们是 pythonic 式的，功能强大，并提供可读性。</p><p id="6b23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是这很容易为滥用它们打开方便之门。或者说是各种形式的虐待。这样做，你的代码只能是非 pythonic 化的，很难被对等体破译。</p><p id="5d02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下一节中，我们将看看使用 Python 列表理解的几种不正确的方法及其替换。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="dc6b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">当你只是改变状态，而不是列表</h1><p id="2c13" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">许多程序员在开始使用 Python 时，在并不真正需要的地方开始使用列表理解。</p><p id="e779" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，在下面的例子中，使用列表理解并不是最好的主意，因为我们没有对列表做任何事情。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="3195" class="ne md it na b gy nf ng l nh ni">vehicles = [ car, bike, truck ]<br/>[ v.setLights(true) for v in vehicles ]</span><span id="1489" class="ne md it na b gy nj ng l nh ni">names = [ "A", "B", "C" ]<br/>[ print(i) for n in names ]</span></pre><p id="8187" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，最好使用经典的 for 循环，因为它可以防止创建不必要的列表。列表理解并不意味着指定命令或设置元素的状态。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3ee7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">当你只是在转换价值观的时候</h1><p id="bebc" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">你可能想转换一个字符串的字符或者简单地添加一串数字。在这两种情况下，选择列表理解并不意味着它也是 pythonic 式的。</p><p id="f405" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们考虑下面的例子:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="c96a" class="ne md it na b gy nf ng l nh ni">total = 0<br/>listOne = [1,2,3]<br/>[total := total + x for x in listOne]</span></pre><p id="2457" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然 Python 3.8 的赋值操作符<code class="fe nk nl nm na b">:=</code>允许我们使用列表理解对列表元素求和，但是当 Python 提供了内置的<code class="fe nk nl nm na b">sum()</code>函数时，为什么要重新发明一个轮子呢？上面的列表理解可以通过一段非常短的代码来完成:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="a028" class="ne md it na b gy nf ng l nh ni">sum(listOne)</span></pre><p id="c6a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似地，当你只是将一个字符串拆分成字符(或者转换它们)时，使用列表理解是多余的，而且完全没有必要:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="4e53" class="ne md it na b gy nf ng l nh ni">str = "Fred"<br/>chars = [x for x in str]</span><span id="5fc7" class="ne md it na b gy nj ng l nh ni">#use this instead:<br/>chars = list(str)</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="aa61" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">当理解与庞大的逻辑嵌套在一起时</h1><p id="13f1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">列表理解无论有多好，当它们嵌套在一起时都会变成一种痛苦。当逻辑冗长时，可读性问题只会进一步恶化。</p><p id="ef79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python 列表的理解最好是留给简洁的逻辑，以符合 python 代码。这意味着，如果需要的话，可以放弃嵌套列表理解，而使用嵌套循环。</p><p id="4600" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的例子仅仅展示了嵌套循环是如何变得更容易理解，并且有时是长嵌套理解的很好的替代品。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="482f" class="ne md it na b gy nf ng l nh ni">list = [[1,2,3],[-1,-5,6]]</span><span id="955e" class="ne md it na b gy nj ng l nh ni">flatten = [item<br/>           for sublist in list<br/>           for item in sublist<br/>           if item &gt; 0]</span><span id="973d" class="ne md it na b gy nj ng l nh ni">#using loops<br/>flatten1 = []</span><span id="315c" class="ne md it na b gy nj ng l nh ni">for rows in list:<br/>    for sublist in rows:<br/>        if sublist &gt; 0:<br/>           flatten1.append(sublist)</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e0d5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">当你在内存中加载整个列表时，尽管你并不需要它</h1><p id="8bd4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">列表理解可以让你很容易地创建列表，但是它们会一直占用内存。这使得它们非常低效，尤其是在处理大型数据集时。</p><p id="ef6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑下面的例子，您很容易遇到内存不足的错误。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="655d" class="ne md it na b gy nf ng l nh ni">sum([i * i for i in range(1000)])</span></pre><p id="7b46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">建议使用生成器表达式，因为它一次生成一个值:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="c7c8" class="ne md it na b gy nf ng l nh ni">sum(i* i for i in range(1000))</span></pre><p id="a157" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将列表存储在内存中的另一个不好的例子是，当您只根据特定条件查找单个元素时。下面的列表理解单句效率很低。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="2e39" class="ne md it na b gy nf ng l nh ni">first = [x for x in list <br/>         if x.get("id")=="12"]</span></pre><p id="6fe7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不仅可以用生成器表达式来代替它，还可以设置<code class="fe nk nl nm na b">next</code>函数，以便在第一个元素匹配给定条件时返回:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="453c" class="ne md it na b gy nf ng l nh ni">first = next((x for x in list if x.get("id")=="12"), None)</span></pre><p id="cd90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe nk nl nm na b">itertools</code>函数和生成器表达式是一种有效的退出方式，而不是使用不支持<code class="fe nk nl nm na b">break</code>或<code class="fe nk nl nm na b">continue</code>的列表理解。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="705f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">当你过度使用列表理解时</h1><p id="3608" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">同样，您会惊讶地发现陷入列表理解并将其用于解压缩元组是多么容易。</p><p id="f43a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的例子只是恢复了另一个不正确的用例，我们将元组值拆分成嵌套列表:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="c76d" class="ne md it na b gy nf ng l nh ni">myList <strong class="na iu">=</strong> <!-- -->[('A', 1), ('B', 2), ('C', 3)]</span><span id="b6de" class="ne md it na b gy nj ng l nh ni">result =<!-- --> <!-- -->[[ i for<!-- --> <!-- -->i, j in<!-- --> <!-- -->myList ],<br/>       [ j for<!-- --> <!-- -->i, j in<!-- --> <!-- -->myList ]]</span></pre><p id="4daa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python 已经为我们提供了一个特定的内置工具，可以让我们解压缩元组。只需使用解包操作符<code class="fe nk nl nm na b">*</code>来析构元组，并将其传递给<code class="fe nk nl nm na b">zip</code>函数来创建单独的列表。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="5475" class="ne md it na b gy nf ng l nh ni">result <strong class="na iu">=</strong> <!-- -->list(zip(<strong class="na iu">*</strong>myList))</span><span id="9192" class="ne md it na b gy nj ng l nh ni"># [['A', 'B', 'C'], [1, 2, 3]]</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bf14" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="676d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Python 列表理解非常强大，但是它们很容易被过度使用，从而使代码变得非 python 化。</p><p id="ae42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望以上不正确的方法能帮助你更好地判断什么时候不使用列表理解。</p><p id="af39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一次到此为止。感谢阅读。</p></div></div>    
</body>
</html>