<html>
<head>
<title>Handle missing data with R: 10 daily used idioms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用R: 10日常习惯用法处理缺失数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/handle-missing-data-with-r-10-daily-used-idioms-13d849d01690?source=collection_archive---------47-----------------------#2020-05-04">https://towardsdatascience.com/handle-missing-data-with-r-10-daily-used-idioms-13d849d01690?source=collection_archive---------47-----------------------#2020-05-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="848a" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">r提示</h2><div class=""/><div class=""><h2 id="10f7" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">你应该把命令自动化</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/798296e59bac756d580fedd3696fec82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oFNXyh11eGwFZgnE"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@mattartz?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马特·阿特兹</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="5bab" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">数据清理是数据分析过程中最耗时的阶段之一。它的许多步骤包括熟悉数据集、搜索缺失值、插补或删除缺失值，以及可能对不同变量或其组合的相同代码行进行大量重复。因此，我们必须寻找并接受任何加快进程的可能性。</p><p id="cfc1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">不久前，我提交了一篇关于针对数据集中缺失值的简短Python习惯用法的文章。今天，我准备了类似的脚本汇编，但在R语言。此外，我们将再次使用Kaggle的<a class="ae lh" rel="noopener" target="_blank" href="/7-idioms-to-acquire-missing-values-every-data-scientist-should-know-2edf4224360c">葡萄酒评论数据集</a>。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="b985" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated">0.使用NAs打开数据集</h2><p id="b701" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">是的，R中的向量从1开始，但是在处理缺失值之前，我们应该有一个包含缺失值的数据集。有时，空记录会被替换字符串填充，如空格(<code class="fe ni nj nk nl b">“ “</code>)、<code class="fe ni nj nk nl b">“empty”</code>、<code class="fe ni nj nk nl b">“nan”</code>或一些垃圾。为了开始这项工作，我们应该用“真实的”<code class="fe ni nj nk nl b">NA</code>值来代替它们。幸运的是，我们可以在数据集开放阶段做到这一点:</p><pre class="ks kt ku kv gt nm nl nn no aw np bi"><span id="8181" class="ml mm it nl b gy nq nr l ns nt">wine_data &lt;- read.csv(‘winemag-data-130k-v2.csv’,<br/>                       <strong class="nl jd">na.string</strong> = c(‘’, ‘i’, ‘P’))</span></pre><p id="e477" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe ni nj nk nl b">na.string</code>接受替代值的向量。</p><h2 id="29ac" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated">1.有没有完全缺失的值？</h2><p id="1a27" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">开始时，我们需要检查缺失值的存在。我们有<code class="fe ni nj nk nl b">is.na()</code>用于这些目的。它接收数据并返回一个布尔向量。</p><ul class=""><li id="824b" class="nu nv it lk b ll lm lo lp lr nw lv nx lz ny md nz oa ob oc bi translated">检查是否缺少单个值:<br/> <code class="fe ni nj nk nl b">is.na(wine_data$region_1[2])</code></li><li id="f742" class="nu nv it lk b ll od lo oe lr of lv og lz oh md nz oa ob oc bi translated">获取某些列中缺少元素的行:<br/> <code class="fe ni nj nk nl b">wine_data[is.na(wine_data$country),]</code></li><li id="f209" class="nu nv it lk b ll od lo oe lr of lv og lz oh md nz oa ob oc bi translated">检查一列中是否有缺失值:<br/> <code class="fe ni nj nk nl b">all(!is.na(wine_data$points))</code></li><li id="8f16" class="nu nv it lk b ll od lo oe lr of lv og lz oh md nz oa ob oc bi translated">检查一列中是否有缺失值:<br/> <code class="fe ni nj nk nl b">any(is.na(wine_data$country))</code></li></ul><h2 id="8d0d" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated">2.检查缺失值存在的最短方法</h2><p id="a4c5" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">以前的脚本需要一些关于数据集的知识和对独立元素的访问。但是如果我们想看到全貌呢？答案是<code class="fe ni nj nk nl b">na.fail()</code>功能。如果整个数据中有任何缺失值，它将引发异常:</p><pre class="ks kt ku kv gt nm nl nn no aw np bi"><span id="7afc" class="ml mm it nl b gy nq nr l ns nt">na.fail(wine_data)</span></pre><h2 id="fa2d" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated">3.了解整体情况</h2><p id="3eb3" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">有一个特殊的函数，替代了一堆过滤器和索引。它主要用于数据框，可用于显示所有缺失值的行(在任何列中):<code class="fe ni nj nk nl b">complete.cases()</code>。它返回一个布尔向量，非常方便索引。</p><ul class=""><li id="1fe0" class="nu nv it lk b ll lm lo lp lr nw lv nx lz ny md nz oa ob oc bi translated">获取缺失数据的行数<br/> <code class="fe ni nj nk nl b">sum(!complete.cases(wine_data))</code></li><li id="9e50" class="nu nv it lk b ll od lo oe lr of lv og lz oh md nz oa ob oc bi translated">获取有缺失数据的行<br/> <code class="fe ni nj nk nl b">wine_data[!complete.cases(wine_data), ]</code></li></ul><h2 id="a1eb" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated">4.更实用的命令</h2><p id="053b" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">所有以前的脚本主要用于探索性任务:展示、获取等..但是如果我们需要得到缺失值的索引呢？在这种情况下，我们应该使用<code class="fe ni nj nk nl b">which()</code>功能:</p><pre class="ks kt ku kv gt nm nl nn no aw np bi"><span id="abba" class="ml mm it nl b gy nq nr l ns nt">which(is.na(wine_data$country))<br/>#returns indexes of rows with missing data</span></pre><h2 id="7924" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated">5.NA值的高级使用</h2><p id="c8d5" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">看来，<code class="fe ni nj nk nl b">NA</code>价值观存在的唯一目的就是被清除。不过，我们可能会在一些非常有趣的组合中使用它们。例如，我们有一个混合数据向量:</p><pre class="ks kt ku kv gt nm nl nn no aw np bi"><span id="6d71" class="ml mm it nl b gy nq nr l ns nt">test_vec &lt;- c( 'ten', '5', 'n', '25', '10')</span></pre><p id="b80d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们希望将“可转换”的字符串(如<code class="fe ni nj nk nl b">‘5’</code>或<code class="fe ni nj nk nl b">‘25’</code>)与其他字符串分开。我们可以和<code class="fe ni nj nk nl b">is.na()</code>功能一起做:</p><pre class="ks kt ku kv gt nm nl nn no aw np bi"><span id="6cd9" class="ml mm it nl b gy nq nr l ns nt">test_vec[!is.na(as.numeric(test_vec))]<br/># returns ( '5', '25', '10' )</span></pre><h2 id="ee65" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated">6.跳过NAs进行计算</h2><p id="134e" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated"><code class="fe ni nj nk nl b">NAs</code>存在有一些副作用——它把几乎任何操作的结果值都变成了<code class="fe ni nj nk nl b">NA</code>。但是有一个解决方案——很多R函数都有内置的<code class="fe ni nj nk nl b">na.rm</code>参数，允许跳过缺失值。</p><pre class="ks kt ku kv gt nm nl nn no aw np bi"><span id="bdc9" class="ml mm it nl b gy nq nr l ns nt">mean(wine_data$price)<br/># returns NA</span><span id="aebe" class="ml mm it nl b gy oi nr l ns nt">mean(wine_data$price, <strong class="nl jd">na.rm</strong> = T)<br/># returns the result</span></pre><h2 id="b159" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated">7.忽略数据集中所有缺失的值</h2><p id="85e3" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">你可以看一下以前的脚本，然后想，省略丢失的值是一件非常乏味的工作。嗯，是的，它是。但是如果需要一次删除所有的<code class="fe ni nj nk nl b">NA</code>并把它们当作一场噩梦忘记，R为我们提供了以下功能:</p><pre class="ks kt ku kv gt nm nl nn no aw np bi"><span id="4bc0" class="ml mm it nl b gy nq nr l ns nt">wine_data_totally_cleared_1 &lt;- na.omit(wine_data)</span><span id="e267" class="ml mm it nl b gy oi nr l ns nt">wine_data_totally_cleared_2 &lt;- wine_data[complete.cases(wine_data),]</span></pre><p id="e53e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如你所见，我们可以使用已知的特殊功能<code class="fe ni nj nk nl b">na.omit()</code><code class="fe ni nj nk nl b">complete.cases()</code>。结果是一样的:数据集中不再有缺失值。</p><h2 id="fec1" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated">8.省略数据集中一些缺失的值</h2><p id="cee9" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">当我们构建一些过滤器时，我们希望结果只有匹配的值。在处理数据框时，它变得尤其有价值。但是，如果您运行以下命令:</p><pre class="ks kt ku kv gt nm nl nn no aw np bi"><span id="c1c8" class="ml mm it nl b gy nq nr l ns nt">wine_data_condition_NA &lt;- wine_data[wine_data$price &gt; 20,]</span></pre><p id="02d3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您不仅会得到正确的子集，还会得到所有缺失的值。它是R数据帧索引、布尔数组和<code class="fe ni nj nk nl b">NA</code>性质的结果:缺少值将条件结果变成被视为非<code class="fe ni nj nk nl b">FALSE</code>的<code class="fe ni nj nk nl b">NA</code>。我们仍然有丢失值搜索的痛苦。</p><p id="2fa4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">解决方法是<code class="fe ni nj nk nl b">subset()</code>功能:</p><pre class="ks kt ku kv gt nm nl nn no aw np bi"><span id="2bd7" class="ml mm it nl b gy nq nr l ns nt">wine_data_condition &lt;- <strong class="nl jd">subset</strong>(wine_data, wine_data$price &gt; 20)</span></pre><p id="3995" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">它返回正确的子集，但没有NAs，NAs被过滤掉了。</p><h2 id="2107" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated">9.关于缺失值的更多信息</h2><p id="63a6" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">让我们回到查看数据集全貌时的步骤。我们希望看到缺失值的分布，也许是一些模式，或者变量之间的依赖关系。我们还有另一个具有所需功能的R包— <a class="ae lh" href="https://cran.r-project.org/web/packages/mice/mice.pdf" rel="noopener ugc nofollow" target="_blank">“鼠标”包</a>。它包含一些函数，这些函数遍历数据集，统计所有的遗漏，并构建数据集的图片。举个例子，我们来举个例子:<code class="fe ni nj nk nl b">wine_data[1:5, 4:8]</code>。它包含下一个数据:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oj"><img src="../Images/e0bcb7169e50f4a70702077c1e4d0786.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jhaLoBahQOp1u9oEZZBFXw.png"/></div></div></figure><p id="c7a4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">正如我们看到的，有一些丢失的值。让我们应用上述包中的md.pattern()函数:</p><pre class="ks kt ku kv gt nm nl nn no aw np bi"><span id="45de" class="ml mm it nl b gy nq nr l ns nt">require(mice)<br/>md.pattern(wine_data[1:5, 4:8], plot = F)</span></pre><p id="5350" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们得到了模式表:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/6e1c1b8d2406079b3b11eb9a28348a83.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/1*jeFHWBvK-ev24e4h3rfeXA.png"/></div></figure><p id="176b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最左边的索引显示行数。最右边的索引显示缺失特征的数量。中间的矩阵显示了模式:在计算的行中缺少哪个特征组合。所以第一行告诉我们，有2行没有缺失数据(0个缺失特征)。第三行显示，数据片段中有一行缺少一个特征，即缺少<code class="fe ni nj nk nl b">price</code>。</p><h2 id="4bdd" class="ml mm it bd mn mo mp dn mq mr ms dp mt lr mu mv mw lv mx my mz lz na nb nc iz bi translated">10.形象化</h2><p id="e345" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">现在我们准备好可视化缺失值的分布。我们为这项工作准备了另一个R包— <a class="ae lh" href="https://cran.r-project.org/web/packages/VIM/index.html" rel="noopener ugc nofollow" target="_blank"> VIM库</a>。在许多其他函数中，它绘制空记录的分布直方图，并根据上一步构建模式表的可视化表示:</p><pre class="ks kt ku kv gt nm nl nn no aw np bi"><span id="1b42" class="ml mm it nl b gy nq nr l ns nt">require(VIM)<br/>aggr_plot &lt;- aggr(wine_data, col=c(‘navyblue’,’red’),<br/> numbers=TRUE, labels=colnames(wine_data),<br/> ylab=c(“Histogram of missing data”,”Pattern”))</span></pre><p id="3400" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们有一幅美丽的图画:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ol"><img src="../Images/6e47a4ce156fbbcc7c12906139fc43bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wwYfBMSOzRgGZlByqeiQxQ.png"/></div></div></figure><p id="2b1e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">例如，现在我们可以看到，几乎60%的行没有<code class="fe ni nj nk nl b">region_2</code>值。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="2b1a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于我来说，你应该把这些代码片段自动化。你会收集到超速行驶的重要分析。此外，和往常一样，您可以在我的GitHub上找到带有工作示例的代码:</p><div class="om on gp gr oo op"><a href="https://github.com/Midvel/medium_jupyter_notes/blob/master/r_missing_values/missing-values.R" rel="noopener  ugc nofollow" target="_blank"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd jd gy z fp ou fr fs ov fu fw jc bi translated">中级/中等_jupyter_notes</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">为中型文章构建的代码和模型示例- Midvel/medium_jupyter_notes</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">github.com</p></div></div><div class="oy l"><div class="oz l pa pb pc oy pd lb op"/></div></div></a></div><p id="b81f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">请确保您已经看过我之前关于Python习惯用法的文章:</p><div class="om on gp gr oo op"><a rel="noopener follow" target="_blank" href="/7-idioms-to-acquire-missing-values-every-data-scientist-should-know-2edf4224360c"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd jd gy z fp ou fr fs ov fu fw jc bi translated">每个数据科学家都应该知道的获取缺失值的7个习惯用法</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">你应该把命令自动化</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">towardsdatascience.com</p></div></div><div class="oy l"><div class="pe l pa pb pc oy pd lb op"/></div></div></a></div></div></div>    
</body>
</html>