<html>
<head>
<title>Using Data Science to Understand Climate Change: Atmospheric CO2 Levels (Keeling Curve) — Model Fitting and Time Series Analysis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用数据科学了解气候变化:大气CO2水平(基林曲线)——模型拟合和时间序列分析</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/timeseries-data-science-curve-fitting-pandas-numpy-scipy-b0cd938ecb59?source=collection_archive---------30-----------------------#2020-06-10">https://towardsdatascience.com/timeseries-data-science-curve-fitting-pandas-numpy-scipy-b0cd938ecb59?source=collection_archive---------30-----------------------#2020-06-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="07b6" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">TL；博士:</h1><h2 id="c112" class="kl jo iq bd jp km kn dn jt ko kp dp jx kq kr ks kb kt ku kv kf kw kx ky kj kz bi translated">也称为“执行摘要”</h2><p id="adcd" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk kq ll lm ln kt lo lp lq kw lr ls lt lu ij bi translated">欢迎光临！本文是<strong class="lc ir">数据科学的一个完整项目。</strong>本文涵盖了<strong class="lc ir"> 1)数据准备2)建模、</strong>和<strong class="lc ir"> 3)模型评估</strong>的领域。这个项目着眼于一个<strong class="lc ir">时间驱动的季节性数据集</strong>，我们将与<strong class="lc ir">熊猫</strong>库合作。对于建模和拟合，我们使用<strong class="lc ir"> Numpy的polyfit </strong>和<strong class="lc ir"> Scipy的optimize </strong>库。我将带你经历提出和构建模型的思维过程，以及如何验证它们。</p><p id="e8c0" class="pw-post-body-paragraph la lb iq lc b ld lv lf lg lh lw lj lk kq lx lm ln kt ly lp lq kw lz ls lt lu ij bi translated">对于更高级的读者，我将在另一篇文章中讨论如何通过<strong class="lc ir"> PyStan </strong>(斯坦的<strong class="lc ir">Python实现)使用<strong class="lc ir">蒙特卡罗方法</strong>对同一数据集执行<strong class="lc ir">预测分析</strong>。</strong></p><p id="d071" class="pw-post-body-paragraph la lb iq lc b ld lv lf lg lh lw lj lk kq lx lm ln kt ly lp lq kw lz ls lt lu ij bi translated">你可以在这里找到完整的代码<a class="ae ma" href="https://gist.github.com/AntonioStark/902007a90db2c12c02e177917fdc496f" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="6396" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">背景</h1><h2 id="f9e4" class="kl jo iq bd jp km kn dn jt ko kp dp jx kq kr ks kb kt ku kv kf kw kx ky kj kz bi translated">斯克里普斯二氧化碳项目</h2><p id="3256" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk kq ll lm ln kt lo lp lq kw lr ls lt lu ij bi translated">该项目基于自1958年以来在夏威夷莫纳罗亚天文台收集的二氧化碳浓度数据。该数据集由<strong class="lc ir">斯克里普斯海洋研究所</strong>编制，因此被称为<a class="ae ma" href="https://scrippsco2.ucsd.edu/" rel="noopener ugc nofollow" target="_blank"> <strong class="lc ir">斯克里普斯二氧化碳数据集</strong> </a>。这是迄今为止最全面和最一致的科学测量之一，自20世纪70年代以来，美国国家海洋和大气管理局(NOAA)的GMD计划一直在努力扩大这一测量。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/cc6e8fcd94738a13ff3cf29fb4dac22d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/0*v9qZUAWwcs7R3APZ.png"/></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">从1980年到2010年的月平均大气CO2浓度(<a class="ae ma" href="https://scrippsco2.ucsd.edu/research/atmospheric_co2.html" rel="noopener ugc nofollow" target="_blank">来源</a>)</p></figure><h2 id="25fb" class="kl jo iq bd jp km kn dn jt ko kp dp jx kq kr ks kb kt ku kv kf kw kx ky kj kz bi translated">龙骨曲线</h2><p id="5d3a" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk kq ll lm ln kt lo lp lq kw lr ls lt lu ij bi translated">数据集的结果曲线被命名为<a class="ae ma" href="https://en.wikipedia.org/wiki/Keeling_Curve" rel="noopener ugc nofollow" target="_blank"> <strong class="lc ir">基林曲线</strong> </a>，以纪念启动监测程序的科学家<strong class="lc ir">查理斯·大卫·基林</strong>。基林曲线显示了二氧化碳浓度的平均增长(~ 2 ppmv/年)，并且是温室气体如何导致气候变化的最权威的证据之一。基林曲线有助于识别二氧化碳的季节变化、自然和人类活动之间的相互作用以及现代工业时代二氧化碳浓度的加速。</p><h1 id="9370" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">数据准备</h1><h2 id="733d" class="kl jo iq bd jp km kn dn jt ko kp dp jx kq kr ks kb kt ku kv kf kw kx ky kj kz bi translated">数据下载</h2><p id="bdea" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk kq ll lm ln kt lo lp lq kw lr ls lt lu ij bi translated">您可以直接从Scripps程序主页下载数据。csv格式:<a class="ae ma" href="https://scrippsco2.ucsd.edu/data/atmospheric_co2/primary_mlo_co2_record.html" rel="noopener ugc nofollow" target="_blank">https://Scripps CO2 . ucsd . edu/data/atmospheric _ CO2/primary _ mlo _ CO2 _ record . html</a>。在我们的调查中，我们将使用文件名为“weekly _ in-situ _ co2 _ mlo . CSV”的<strong class="lc ir">每周原位CO2数据集</strong>。请注意，<strong class="lc ir">默认的</strong>原位CO2数据是<strong class="lc ir">每月</strong>——因此请确保您下载的是正确的文件。</p><p id="867c" class="pw-post-body-paragraph la lb iq lc b ld lv lf lg lh lw lj lk kq lx lm ln kt ly lp lq kw lz ls lt lu ij bi translated"><strong class="lc ir">数据的前44行</strong>是关于文件的<strong class="lc ir">信息</strong>，应该在导入Python之前丢弃。<strong class="lc ir">第一列</strong>表示记录的<strong class="lc ir">日期</strong>，格式为“yyyy/mm/dd”。<strong class="lc ir">第二列</strong>表示<strong class="lc ir">大气CO2浓度</strong>，单位为百万分率(ppm)。</p><h2 id="4908" class="kl jo iq bd jp km kn dn jt ko kp dp jx kq kr ks kb kt ku kv kf kw kx ky kj kz bi translated">数据导入</h2><p id="137e" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk kq ll lm ln kt lo lp lq kw lr ls lt lu ij bi translated">我们将使用熊猫图书馆来存放我们的数据。对于那些不熟悉熊猫的人来说，这是一个让你用一堆有用的特性创建数据框架的库。如果你正在进入<strong class="lc ir">数据科学</strong>领域，你会经常用到它！</p><pre class="mc md me mf gt mn mo mp mq aw mr bi"><span id="624c" class="kl jo iq mo b gy ms mt l mu mv">df = pd.read_csv('weekly_in_situ_co2_mlo.csv',names=['date','CO2 ppm'])<br/>print('Dataframe has <strong class="mo ir">%d</strong> data points of <strong class="mo ir">%d</strong> features'<br/>      %(df.shape[0],df.shape[1]))</span><span id="5bcd" class="kl jo iq mo b gy mw mt l mu mv">df.head()</span></pre><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi mx"><img src="../Images/7c37540dd9d62556260d8d2d108e681a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LE6TtjeUGm9akxjXo9RzHQ.png"/></div></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">数据的输出(。csv文件)导入。</p></figure><h2 id="9577" class="kl jo iq bd jp km kn dn jt ko kp dp jx kq kr ks kb kt ku kv kf kw kx ky kj kz bi translated">将日期列转换为“日期时间”格式</h2><p id="b05a" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk kq ll lm ln kt lo lp lq kw lr ls lt lu ij bi translated">当前日期采用<strong class="lc ir">字符串</strong>格式。我们将其更改为<strong class="lc ir"> datetime </strong>对象，这样Python就可以识别出时间线上的数据点。熊猫对此有一个函数叫做“<strong class="lc ir">到_datetime </strong>”</p><pre class="mc md me mf gt mn mo mp mq aw mr bi"><span id="c053" class="kl jo iq mo b gy ms mt l mu mv">df['date'] = pd.to_datetime(df['date'],format='%Y/%m/<strong class="mo ir">%d</strong>')<br/>df.head()</span></pre><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/ab64cb4ad611c06c2386717cfd5f2f02.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/format:webp/1*3NVBSilCE9Z5gs85WHm8YA.png"/></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">将“日期”列更改为日期时间后的输出</p></figure><h2 id="a005" class="kl jo iq bd jp km kn dn jt ko kp dp jx kq kr ks kb kt ku kv kf kw kx ky kj kz bi translated">创建“天”列</h2><p id="6b62" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk kq ll lm ln kt lo lp lq kw lr ls lt lu ij bi translated">虽然date列用于将数据绘制成时间序列，但它对我们的建模步骤用处不大。为对应于第一天之后N天的<strong class="lc ir">的数据创建一个新参数会提供更多信息。至少，它使我们的<strong class="lc ir">模型参数易于解释</strong>。</strong></p><pre class="mc md me mf gt mn mo mp mq aw mr bi"><span id="39fe" class="kl jo iq mo b gy ms mt l mu mv"><em class="nd"># take the first row as the start date<br/></em>epoch = df['date'][0]</span><span id="d0da" class="kl jo iq mo b gy mw mt l mu mv"><em class="nd"># take integer values of the days from epoch<br/></em>df['days'] = (df['date']-epoch).dt.days</span><span id="df74" class="kl jo iq mo b gy mw mt l mu mv">df.head()</span></pre><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/c39e569a4409adba84e3c0850d493273.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*uV1DgPxcJrWZK0oZpiKlVQ.png"/></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">添加要在我们的模型中使用的“days”列的输出。请注意,“天数”列将用于查找模型的参数，而“日期”列将用于绘图。</p></figure><h2 id="75d7" class="kl jo iq bd jp km kn dn jt ko kp dp jx kq kr ks kb kt ku kv kf kw kx ky kj kz bi translated">数据观察</h2><p id="6be0" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk kq ll lm ln kt lo lp lq kw lr ls lt lu ij bi translated">数据科学的第一步是调查数据的一般形式(如果可能的话)。这将使我们能够确定用于建模的宏观趋势。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nf"><img src="../Images/8e57f636262d515b8ed0945cd02dfea3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j9llPxEzZHkr6PndVdT82w.png"/></div></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">未经编辑的原始数据</p></figure><p id="b5c8" class="pw-post-body-paragraph la lb iq lc b ld lv lf lg lh lw lj lk kq lx lm ln kt ly lp lq kw lz ls lt lu ij bi translated">在宏观的一瞥之后，对数据进行一些细微的观察也是值得的。对于这个数据集，我将始终查看数据集的第一年、前三年、最后三年和最后一年。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ng"><img src="../Images/33c7ac8eaa5390775ea8a72b438ba74b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sqcmvcF_JM7KrrhJG3A6_g.png"/></div></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">数据集两侧的1年和3年数据图。</p></figure><p id="36b2" class="pw-post-body-paragraph la lb iq lc b ld lv lf lg lh lw lj lk kq lx lm ln kt ly lp lq kw lz ls lt lu ij bi translated">从这两个观察中，我们看到有一个<strong class="lc ir">增加的基数趋势</strong>和一个<strong class="lc ir">波动的季节性趋势</strong>。这两种趋势是您将在时间驱动的数据集中看到的典型趋势，尤其是关于<strong class="lc ir">自然观测</strong>的数据集。</p><h1 id="2e7f" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">建模和评估</h1><h2 id="b238" class="kl jo iq bd jp km kn dn jt ko kp dp jx kq kr ks kb kt ku kv kf kw kx ky kj kz bi translated">建模</h2><p id="f10b" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk kq ll lm ln kt lo lp lq kw lr ls lt lu ij bi translated">对数据建模是一种尝试，旨在识别生成数据的不同力量。建模可以通过科学调查或从数据中推断来完成。</p><p id="7c87" class="pw-post-body-paragraph la lb iq lc b ld lv lf lg lh lw lj lk kq lx lm ln kt ly lp lq kw lz ls lt lu ij bi translated">如果你意识到一些创造数据的基本力量，通过科学调查建模是可能的。有限资源环境中的人口增长，例如病毒在有限人口中的传播，是一个已经在数学中广泛建模的问题。虽然这些数学模型无法解释数据中的所有变化，但它们可以提供塑造模型的关键方向，并且更适用于类似的场景(例如，具有不同初始点的类似环境)。</p><p id="5b75" class="pw-post-body-paragraph la lb iq lc b ld lv lf lg lh lw lj lk kq lx lm ln kt ly lp lq kw lz ls lt lu ij bi translated"><strong class="lc ir">推断建模</strong>是针对数据中的变化进行的，当你不知道这些变化是如何产生的时候。推理建模仅限于指数或正弦曲线的基本集合，因为复杂的多项式函数往往会过度拟合数据，并且具有有限的可推广性。</p><h2 id="de5e" class="kl jo iq bd jp km kn dn jt ko kp dp jx kq kr ks kb kt ku kv kf kw kx ky kj kz bi translated">估价</h2><p id="3e6c" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk kq ll lm ln kt lo lp lq kw lr ls lt lu ij bi translated">可以通过视觉和数字两种方式进行评估。<strong class="lc ir">目视评估</strong>可通过目视检查模型生成数据与实际数据来进行。当差异较大或数据中有<strong class="lc ir">未说明的趋势</strong>时，目视检查非常有用。重要的是从建模数据中创建<strong class="lc ir">相关图表</strong>，以查看<strong class="lc ir">剩余数据</strong>是否显示其他趋势。然后，可以通过添加额外的数学模型来解释这些数据。</p><p id="b9f4" class="pw-post-body-paragraph la lb iq lc b ld lv lf lg lh lw lj lk kq lx lm ln kt ly lp lq kw lz ls lt lu ij bi translated"><strong class="lc ir">数值评估</strong>通常采用<strong class="lc ir"> R平方值</strong>的形式。r平方值显示预测(或回归)解释的原始数据方差的百分比。接近1.00的R平方值更好(有可能过度拟合数据)，而接近0的值更差。(负的R平方值也是可能的，但是我们在这里不考虑这个概念。)R平方值本身并不能揭示无法解释的方差在哪里。噪声引起的方差是不可分辨的，而缺少建模引起的方差是可以改善的。</p><h1 id="0416" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">模型# I——线性基本趋势</h1><h2 id="6593" class="kl jo iq bd jp km kn dn jt ko kp dp jx kq kr ks kb kt ku kv kf kw kx ky kj kz bi translated">线性基本趋势建模</h2><p id="4419" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk kq ll lm ln kt lo lp lq kw lr ls lt lu ij bi translated">最明显的基本趋势是线性趋势。由于我们还没有考虑季节变化，所以整个模型是一个带有两个参数的<strong class="lc ir">多项式</strong>——零阶和一阶系数。</p><p id="00dc" class="pw-post-body-paragraph la lb iq lc b ld lv lf lg lh lw lj lk kq lx lm ln kt ly lp lq kw lz ls lt lu ij bi translated">Numpy (np)的Polyfit 库允许我们对数据进行多项式拟合。然后，我们可以使用输出系数值为我们拥有的每个数据点创建<strong class="lc ir">合成数据</strong>(即，为我们拥有的每个x点绘制相应的y点)。</p><pre class="mc md me mf gt mn mo mp mq aw mr bi"><span id="3229" class="kl jo iq mo b gy ms mt l mu mv">coeffs = np.polyfit(df['days'],df['CO2 ppm'],deg=1)<br/>print('Data has a linear trend<strong class="mo ir">\n\</strong><br/>1st deg coeff: <strong class="mo ir">%.3e</strong> (slope)<strong class="mo ir">\n\</strong><br/>0th deg coeff: <strong class="mo ir">%.3e</strong> (intercept)'<br/>     %(coeffs[0],coeffs[1]))<br/><br/>df['linear trend'] = df['days']*coeffs[0]+coeffs[1]<br/>df['relative ppm (lin)'] = df['CO2 ppm']-df['linear trend']</span></pre><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/aab02fe6e6c04600f0dd4a9b88249834.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*fIjEw5wSy7zlKZ922Rwvjw.png"/></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">线性基本趋势的拟合参数值。</p></figure><h2 id="f2fa" class="kl jo iq bd jp km kn dn jt ko kp dp jx kq kr ks kb kt ku kv kf kw kx ky kj kz bi translated">线性基本趋势评估</h2><p id="2b0d" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk kq ll lm ln kt lo lp lq kw lr ls lt lu ij bi translated">我们首先从模型的外观检查开始。<strong class="lc ir">将建模数据叠加到原始数据上</strong>显示，我们的线性模型确定了多年来的持续增长。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ni"><img src="../Images/ce8cfa2fd93f12b01af40fe4f7ff36e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3c1A25ZTkdLB_evvqPVCEQ.png"/></div></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">我们拟合的线性趋势叠加在原始数据之上</p></figure><p id="8a8a" class="pw-post-body-paragraph la lb iq lc b ld lv lf lg lh lw lj lk kq lx lm ln kt ly lp lq kw lz ls lt lu ij bi translated">现在，我们观察在解释了线性趋势的变化后，数据看起来是什么样的。这是通过简单地从原始数据中减去模型数据来实现的。在代码中，这存储在一个名为<strong class="lc ir">‘相对ppm(Lin)’的新列中。</strong></p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nj"><img src="../Images/eebb1e2fb2810f18ee9edc7c30e858ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vsHnSalKqg6Z672Te_I98g.png"/></div></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">线性趋势无法解释的其余变化。</p></figure><p id="6afa" class="pw-post-body-paragraph la lb iq lc b ld lv lf lg lh lw lj lk kq lx lm ln kt ly lp lq kw lz ls lt lu ij bi translated">从这个相对图中我们可以观察到两件事。<strong class="lc ir">首先，在剩余的数据中有明显的减少和增加(月牙形)。</strong>这表明数据的增长率平均先降低后升高，与线性趋势假设的恒定增长率相反。<strong class="lc ir">其次，数据有明显的季节性</strong>。这是显而易见的，因为我们还没有在我们的模型中实现季节性趋势，因此季节性仍然无法解释。请注意，当考虑到宏观水平的增长时，可以更好地观察到季节性趋势的<strong class="lc ir">幅度</strong>。</p><p id="a396" class="pw-post-body-paragraph la lb iq lc b ld lv lf lg lh lw lj lk kq lx lm ln kt ly lp lq kw lz ls lt lu ij bi translated">使用<strong class="lc ir">数值分析</strong>使用<strong class="lc ir"> r平方</strong>，我们发现数据中97.7%的变化可以用简单的线性趋势来解释。</p><h1 id="0793" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">模型#2 —二次基本趋势</h1><h2 id="2e27" class="kl jo iq bd jp km kn dn jt ko kp dp jx kq kr ks kb kt ku kv kf kw kx ky kj kz bi translated">二次基趋势建模</h2><p id="f71a" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk kq ll lm ln kt lo lp lq kw lr ls lt lu ij bi translated">虽然使用高次多项式通常会因其过度拟合和缺乏可推广性而受到反对，但<strong class="lc ir">二次多项式</strong>，也称为二次函数，被广泛认为是合理的基本趋势。</p><p id="8866" class="pw-post-body-paragraph la lb iq lc b ld lv lf lg lh lw lj lk kq lx lm ln kt ly lp lq kw lz ls lt lu ij bi translated">像线性基本趋势一样，我们使用Numpy的polyfit库来拟合我们的数据的三个参数。</p><pre class="mc md me mf gt mn mo mp mq aw mr bi"><span id="d873" class="kl jo iq mo b gy ms mt l mu mv">coeffs = np.polyfit(df['days'],df['CO2 ppm'],deg=2)<br/>print('Data has a quadratic trend<strong class="mo ir">\n\</strong><br/>2nd deg coeff: <strong class="mo ir">%.3e</strong> (quad term)<strong class="mo ir">\n\</strong><br/>1st deg coeff: <strong class="mo ir">%.3e</strong> (slope)<strong class="mo ir">\n\</strong><br/>0th deg coeff: <strong class="mo ir">%.3e</strong> (intercept)'<br/>     %(coeffs[0],coeffs[1],coeffs[2]))<br/><br/>df['quad trend'] = df['days']**2*coeffs[0]+df['days']*coeffs[1]+coeffs[2]<br/>df['relative ppm (quad)'] = df['CO2 ppm']-df['quad trend']</span></pre><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/24f3b28bd88c042d6a8a9934cdc3a857.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*2xz9PVhmHrnlqr5VA6C6iQ.png"/></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">二次基本趋势的拟合参数值。</p></figure><h2 id="d3e7" class="kl jo iq bd jp km kn dn jt ko kp dp jx kq kr ks kb kt ku kv kf kw kx ky kj kz bi translated">二次基本趋势评估</h2><p id="123d" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk kq ll lm ln kt lo lp lq kw lr ls lt lu ij bi translated">同样，我们试图通过将趋势叠加到我们的数据上来进行<strong class="lc ir">视觉评估</strong>。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nl"><img src="../Images/88ee03d143f849ff364a3f533b3dc026.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zz4qGbl2rbU0JvSfWOlN8g.png"/></div></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">拟合的二次趋势叠加在原始数据之上。</p></figure><p id="1c63" class="pw-post-body-paragraph la lb iq lc b ld lv lf lg lh lw lj lk kq lx lm ln kt ly lp lq kw lz ls lt lu ij bi translated">我们立即看到，二次基趋势是一个比线性趋势好得多的宏观趋势。我们再次将<strong class="lc ir">剩余变化</strong>绘制到基本趋势上，以识别任何未解释的变化。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ni"><img src="../Images/8d92e87570a60479afb9ee8bec104834.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_s9kVOpBSBNxdM1igCMt7w.png"/></div></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">二次趋势无法解释的其余变化。</p></figure><p id="992e" class="pw-post-body-paragraph la lb iq lc b ld lv lf lg lh lw lj lk kq lx lm ln kt ly lp lq kw lz ls lt lu ij bi translated">我们看到，以前的(线性)模型的新月形变化现在在新的(二次)模型下得到解释。似乎还有一些更高层次的变异，但现阶段很难直观观察到。</p><p id="0bfe" class="pw-post-body-paragraph la lb iq lc b ld lv lf lg lh lw lj lk kq lx lm ln kt ly lp lq kw lz ls lt lu ij bi translated">看一下<strong class="lc ir">的r平方值</strong>，我们现在看到99.4%的变化现在被模型解释了——比以前的模型增加了1.7个百分点。</p><h1 id="604b" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">模型# 3——二次基数和正弦季节趋势</h1><h2 id="106e" class="kl jo iq bd jp km kn dn jt ko kp dp jx kq kr ks kb kt ku kv kf kw kx ky kj kz bi translated">二次+正弦趋势建模</h2><p id="4a85" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk kq ll lm ln kt lo lp lq kw lr ls lt lu ij bi translated">既然我们对<strong class="lc ir">的基本趋势</strong>有些满意，我们可以开始处理<strong class="lc ir">的季节性趋势</strong>。对于这个模型，我们实现了一个<strong class="lc ir">正弦曲线</strong>作为我们的季节因素。</p><p id="5831" class="pw-post-body-paragraph la lb iq lc b ld lv lf lg lh lw lj lk kq lx lm ln kt ly lp lq kw lz ls lt lu ij bi translated">基本趋势的参数仍然是二阶多项式函数的<strong class="lc ir">三个系数。一条<strong class="lc ir">一般正弦曲线</strong>也有<strong class="lc ir">三个系数</strong> : <strong class="lc ir"> (1)振幅，(2)频率</strong>，和<strong class="lc ir"> (3)相位</strong>。</strong></p><p id="6cbf" class="pw-post-body-paragraph la lb iq lc b ld lv lf lg lh lw lj lk kq lx lm ln kt ly lp lq kw lz ls lt lu ij bi translated">这就是我们可以利用我们的科学调查的地方。我们可以预测每年的季节性变化<strong class="lc ir"/>。虽然这可能不准确，但我们仍然可以测试假设并观察性能。当我们能够<strong class="lc ir">减少拟合参数</strong>的数量时，它也为我们节省了大量的计算能力并增加了末端拟合的精度。因为我们的时间是以天为单位的，所以我们可以将频率参数取为1/365.25，因为每年有365.25天。(如果你不知道. 25的出处，查“闰年”)</p><p id="6512" class="pw-post-body-paragraph la lb iq lc b ld lv lf lg lh lw lj lk kq lx lm ln kt ly lp lq kw lz ls lt lu ij bi translated">由于我们的模型不再是一个<strong class="lc ir">多项式</strong>，我们不能使用<strong class="lc ir"> Numpy的Polyfit </strong>库。相反，我们使用<strong class="lc ir"> Scipy的优化</strong>模块来找到五个(之前是六个)参数的拟合值。</p><pre class="mc md me mf gt mn mo mp mq aw mr bi"><span id="39f9" class="kl jo iq mo b gy ms mt l mu mv"><strong class="mo ir">def</strong> test_func(t,c0,c1,c2,c3,c4):<br/>    <strong class="mo ir">return</strong> c0+c1*t+c2*t**2+c3*np.cos(2*math.pi*f_year*t+c4)<br/>coeffs, coeffs_covariance = optimize.curve_fit(test_func,df['days'],df['CO2 ppm'])<br/><br/>print('optimized coefficient values:')<br/><strong class="mo ir">for</strong> i <strong class="mo ir">in</strong> range(5):<br/>    print('c<strong class="mo ir">%d</strong>: <strong class="mo ir">%.3e</strong>'%(i,coeffs[i]))<br/>    <br/>df['quad+sin trend'] = coeffs[0] + coeffs[1]*df['days'] +\<br/>                        coeffs[2]*df['days']**2 +\<br/>                        coeffs[3]*np.cos(2*math.pi*f_year*df['days']+coeffs[4])<br/>df['relative ppm (quad+sin)'] = df['CO2 ppm']-df['quad+sin trend']</span></pre><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/7e900e2ffd71bda1adb15e4212489431.png" data-original-src="https://miro.medium.com/v2/resize:fit:1052/format:webp/1*XhqnHML44seBnjwe12afgw.png"/></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">拟合的参数值。请注意，与Numpy的polyfit库不同，scipy.optimize要求您显式声明一个函数来拟合数据。</p></figure><h2 id="455c" class="kl jo iq bd jp km kn dn jt ko kp dp jx kq kr ks kb kt ku kv kf kw kx ky kj kz bi translated">二次+正弦趋势评估</h2><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nn"><img src="../Images/9af96227f5047e992b8f57850e99ccc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EgpxjQVIiIwIFCGinI6jOA.png"/></div></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">我们的模型在整个数据期间以及第一年和最后五年的原始数据集上的叠加。</p></figure><p id="ab87" class="pw-post-body-paragraph la lb iq lc b ld lv lf lg lh lw lj lk kq lx lm ln kt ly lp lq kw lz ls lt lu ij bi translated"><strong class="lc ir">目视检查</strong>显示我们的组合模型与我们的数据非常吻合。<strong class="lc ir"> r平方值</strong>告诉我们，我们现在已经解释了来自五个参数的数据变化的<strong class="lc ir"> 99.9% </strong>(具体地说，99.8783%)。我们看到，正弦模型的增加使我们的模型的解释能力提高了0.5个百分点。</p><p id="5553" class="pw-post-body-paragraph la lb iq lc b ld lv lf lg lh lw lj lk kq lx lm ln kt ly lp lq kw lz ls lt lu ij bi translated">我们应该满足于这99.9%的解释吗？这就是我们需要警惕过度拟合的地方。任何数据集，只要加入足够多的参数，都可以100%“解释”。(从技术上来说，任何大小为N的数据集都可以通过使用具有N个参数的多项式进行100%匹配)仅使用<strong class="lc ir"> 5个参数</strong>，现在就对一个<strong class="lc ir">3000+数据点</strong>数据集进行过度拟合还为时过早。决定归结为剩余的方差是来自<strong class="lc ir">噪声</strong>，我们不应该<strong class="lc ir">过度拟合</strong>，还是来自<strong class="lc ir">模式</strong>，我们希望将其合并到模型中。这就是为什么我们总是需要查看<strong class="lc ir">剩余变化</strong>并观察是否存在我们可以建模的模式。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nf"><img src="../Images/1d9a9f026ffa4c3434ab2080976ef298.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lZLMCnN3Xx4-V8H5vU7v_g.png"/></div></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">二次+正弦模型预测后的剩余变化。</p></figure><p id="3835" class="pw-post-body-paragraph la lb iq lc b ld lv lf lg lh lw lj lk kq lx lm ln kt ly lp lq kw lz ls lt lu ij bi translated">观察<strong class="lc ir">整个时标</strong>的剩余变化，我们首先看到变化的<strong class="lc ir">幅度</strong>已经显著降低。在线性基础模型中，<strong class="lc ir">最大变化</strong>(数据最高点和最低点之间的差异)约为17 ppm，在二次基础模型中为11 ppm。现在，考虑到正弦季节性，最大变化仅为6 ppm。我们还看到两个30年长的新月形，但是它们的偏斜度很难识别。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi no"><img src="../Images/f701f914a2519f1b16b7512b8216e510.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hZqyftc7xBg_IdwUYi57Xw.png"/></div></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">第一年和最后一年绘制的剩余变化。</p></figure><p id="4466" class="pw-post-body-paragraph la lb iq lc b ld lv lf lg lh lw lj lk kq lx lm ln kt ly lp lq kw lz ls lt lu ij bi translated">在<strong class="lc ir">多年时间尺度</strong>上，我们看到仍然有一些<strong class="lc ir">周期变化</strong>大约<strong class="lc ir"> 6个月长度</strong>。放大到<strong class="lc ir">年尺度</strong>，我们看到低谷出现在每年的4月和10月左右，高峰出现在1月和7月。这些<strong class="lc ir">半年波动</strong>的<strong class="lc ir">振幅</strong>约为<strong class="lc ir"> 2.5 ppm </strong>，其中心在宏观尺度上移动。</p><h1 id="befb" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">奖金——研究正弦不对称</h1><p id="4c3d" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk kq ll lm ln kt lo lp lq kw lr ls lt lu ij bi translated">虽然我们的基本趋势是一年(365.25天)，但我们无法解释的变化的周期是6个月，即我们正弦周期的一半。这似乎表明我们的<strong class="lc ir">年度正弦季节性</strong>周期性地抵消我们的数据。</p><p id="7215" class="pw-post-body-paragraph la lb iq lc b ld lv lf lg lh lw lj lk kq lx lm ln kt ly lp lq kw lz ls lt lu ij bi translated">我们可以调查<strong class="lc ir">这种偏移是如何发生的，方法是将我们的所有数据<strong class="lc ir">逐月叠加</strong>，并查看它与我们模型中使用的正弦季节性相比如何。</strong></p><p id="4058" class="pw-post-body-paragraph la lb iq lc b ld lv lf lg lh lw lj lk kq lx lm ln kt ly lp lq kw lz ls lt lu ij bi translated">为了实现这一点，我们首先<strong class="lc ir">将年度差异</strong>移至我们的“日期”栏。这确保了我们所有的<strong class="lc ir">数据将绘制在x轴</strong>的同一线段上。在我的代码中，我通过将年份部分重置为1904来实现这一点。这与完全删除年份部分略有不同，默认情况下，这将使用1900年的“datetime”类纪元年份。这不适用于我们的情况，因为我们的一个数据点有闰日(2月29日)，1900年不是闰年(1904年是)。</p><p id="73e4" class="pw-post-body-paragraph la lb iq lc b ld lv lf lg lh lw lj lk kq lx lm ln kt ly lp lq kw lz ls lt lu ij bi translated">其次，我们需要根据我们在线性和二次基本趋势中看到的每年的<strong class="lc ir">平均值增长</strong>进行调整。这确保了我们所有的<strong class="lc ir">数据将被绘制在y轴</strong>的同一范围内。在我的代码中，我通过从每年的数据值中减去每年的平均数据值来实现这一点。这意味着我的绘图将以y=0线为中心。</p><pre class="mc md me mf gt mn mo mp mq aw mr bi"><span id="f4ba" class="kl jo iq mo b gy ms mt l mu mv"><em class="nd"># the list of years represented in the dataset</em><br/>dfYears = range(df.iloc[0]['date'].year,df.iloc[-1]['date'].year+1)<br/><strong class="mo ir">for</strong> year <strong class="mo ir">in</strong> dfYears:<br/>    dfYear = df[df['date'].dt.year == year]<br/>    <em class="nd">## there's 1992-02-29 in the dataset</em><br/>    <em class="nd">## and the "epoch" year in the datetime module (1900)</em><br/>    <em class="nd">## is NOT a leap year</em><br/>    monthDays = [datetime.strptime('1904-'+str(date.month)+'-'+str(date.day), '%Y-%m-<strong class="mo ir">%d</strong>')<br/>                 <strong class="mo ir">for</strong> date <strong class="mo ir">in</strong> dfYear['date']]<br/>    plt.plot(monthDays,dfYear['CO2 ppm']-np.mean(dfYear['CO2 ppm']),<br/>             color='b',alpha=0.1)</span></pre><p id="de7a" class="pw-post-body-paragraph la lb iq lc b ld lv lf lg lh lw lj lk kq lx lm ln kt ly lp lq kw lz ls lt lu ij bi translated">最后，我们在聚合图上绘制正弦曲线，以验证我们的假设。为了比较，我在黄色虚线中加入了一个非相移正弦图(从0开始到结束)。我用眼睛标记了一个相移，它的图形用橙色虚线表示。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi np"><img src="../Images/de5cb95266442833e5871ba0e0c66b34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-zDqXYo1OE-QP_lsMHSQkg.png"/></div></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">每年绘制的大气CO2汇总数据图，并以绝对高度归一化(蓝色，不透明度=0.1)</p></figure><p id="c8b5" class="pw-post-body-paragraph la lb iq lc b ld lv lf lg lh lw lj lk kq lx lm ln kt ly lp lq kw lz ls lt lu ij bi translated">在此，我们确定<strong class="lc ir">数据的季节性</strong>实际上是<strong class="lc ir">与<strong class="lc ir">正弦曲线</strong>略有出入</strong>。数据值从谷到峰的<strong class="lc ir">增加</strong>是<strong class="lc ir">非常缓慢的</strong>——总计耗时<strong class="lc ir"> 8个月</strong>。另一方面，数据值的<strong class="lc ir">下降</strong>，只需要<strong class="lc ir"> 4个月</strong>。这解释了当数据<strong class="lc ir">的增长速度比我们的模型</strong>慢并且<strong class="lc ir">的下降速度比我们的模型</strong>快时<strong class="lc ir"> 6个月</strong>与模型的差异。</p><p id="3483" class="pw-post-body-paragraph la lb iq lc b ld lv lf lg lh lw lj lk kq lx lm ln kt ly lp lq kw lz ls lt lu ij bi translated">如果你真的去查阅斯克里普斯项目网站上的文件和出版物<a class="ae ma" href="https://scrippsco2.ucsd.edu/publications/scientific_literature.html" rel="noopener ugc nofollow" target="_blank">，你会发现一个解释，解释了大气CO2的增减循环中的这种<strong class="lc ir">不对称性。<a class="ae ma" href="https://en.wikipedia.org/wiki/Keeling_Curve#Results_and_interpretation" rel="noopener ugc nofollow" target="_blank">简而言之</a>，大气CO2的<strong class="lc ir">减少</strong>来自夏季<strong class="lc ir">植被的生长</strong>，因为植物消耗CO2并排出O2。由于大部分地块集中在<strong class="lc ir">北半球</strong>，本次夏季从<strong class="lc ir">5月持续至</strong>9月，为期4个月。CO2水平变化在大气中的反映延迟约1个月，实际下降周期为<strong class="lc ir">6月(高峰)至10月(低谷)</strong>。</strong></a></p><h1 id="3ac0" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">下一步是什么？</h1><p id="ab48" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk kq ll lm ln kt lo lp lq kw lr ls lt lu ij bi translated">首先，祝贺你走到这一步！现在，您已经了解了为<strong class="lc ir">时间序列数据建立模型的基本思维过程。</strong>在数据科学方面，你也使用了三个Python包——熊猫(数据结构)、Numpy和Scipy。Numpy和Scipy都广泛用于<strong class="lc ir">数学计算</strong>，Scipy为<strong class="lc ir">线性代数</strong>函数提供了更全面的能力。如果你是一个刚进入数据科学领域的学生，你会看到这些软件包更多！</p><p id="4a88" class="pw-post-body-paragraph la lb iq lc b ld lv lf lg lh lw lj lk kq lx lm ln kt ly lp lq kw lz ls lt lu ij bi translated">具体来说，关于这个项目，你可以关闭这一章满意地解决了99.9%的变化在一个数据集重要的人类；或者尝试对该变化进行甚至更大的定址(诸如微调该正弦曲线以更好地拟合该增大-减小不对称性)；或者尝试数据外测试(即投影)，以查看模型在数据集中的时间序列中的表现。关于最后一点，我写了一篇单独的文章，使用<strong class="lc ir">蒙特卡罗方法</strong>来确定模型的投影边界，并通过<strong class="lc ir"> PyStan </strong>库实现。</p></div></div>    
</body>
</html>