<html>
<head>
<title>Broadcasting PySpark Accumulators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">广播 PySpark 累加器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/broadcasting-pyspark-accumulators-343104c18c44?source=collection_archive---------43-----------------------#2020-07-29">https://towardsdatascience.com/broadcasting-pyspark-accumulators-343104c18c44?source=collection_archive---------43-----------------------#2020-07-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4ad6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">以及如何管理它们</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/507c40e9ef6b831696d0ee623a7fac32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QeceFDo8n1_LDbU2"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@grakozy?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">格雷戈·拉科齐</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="7291" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将讨论一个有趣的模式，用一个方便的广播。在进入更多细节之前，让我们回顾一下什么是火花累加器。</p><blockquote class="lv lw lx"><p id="5d6f" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">一种可以累加的共享变量，即有一个可交换的和相关的“加”操作。Spark 集群上的工作任务可以使用+=操作符将值添加到累加器中，但是只有驱动程序才允许使用<code class="fe mc md me mf b"><a class="ae ky" href="https://spark.apache.org/docs/2.3.1/api/python/pyspark.html#pyspark.Accumulator.value" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">value</strong></a></code>来访问它的值。来自工人的更新自动传播到驱动程序。</p><p id="4ff6" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">来源:<a class="ae ky" href="https://spark.apache.org/docs/2.3.1/api/python/pyspark.html#pyspark.Accumulator" rel="noopener ugc nofollow" target="_blank">https://spark . Apache . org/docs/2 . 3 . 1/API/python/py spark . html # py spark。蓄能器</a></p></blockquote><h1 id="50e9" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">累加器的三大戒律</h1><ol class=""><li id="6576" class="my mz it lb b lc na lf nb li nc lm nd lq ne lu nf ng nh ni bi translated">累加器只能用于交换和结合的“加法”运算。对于任何其他操作，我们必须使用自定义实现。稍后会详细介绍。</li><li id="503f" class="my mz it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">可以在工作任务上“更新”累加器，但该任务不能访问其值。</li><li id="2b25" class="my mz it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">累加器可以在驱动程序上更新和访问。</li></ol><h1 id="cd81" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">几行代码抵得上千言万语</h1><p id="ca9e" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">让我们看一个简单的累加器例子</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="da69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的示例代码中，<em class="ly"> cnt </em>是在全局级别上定义的。<em class="ly"> add_items </em>方法将输入<em class="ly"> x </em>加到<em class="ly"> cnt </em>上。<em class="ly"> add_items </em>方法后来应用于<em class="ly"> global_accumulator </em>方法中 rdd 的每一项。这是累加器的典型用法，最后对<em class="ly"> global_accumulator </em>的调用将输出 6，这是 1、2 和 3 的总和。请注意，我们需要将<em class="ly"> cnt </em>定义为全局变量，否则各种方法都无法访问它，并且它将是未定义的。</p><h2 id="8078" class="nt mh it bd mi nu nv dn mm nw nx dp mq li ny nz ms lm oa ob mu lq oc od mw oe bi translated">那是什么问题…</h2><p id="2af2" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">现在，为了激发对广播累加器的需求，让我们将代码分成几个文件，这就是模块化代码库中的代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="3a0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ly">global _ accumulator _ module</em>从另一个模块<em class="ly"> accumulator_process </em>中调用<em class="ly"> process_data </em>方法(代码如下)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="0ffa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们执行<em class="ly">global _ accumulator _ module</em>，那么它会失败并出现以下错误。</p><pre class="kj kk kl km gt of mf og oh aw oi bi"><span id="9c0a" class="nt mh it mf b gy oj ok l ol om">NameError: name ‘cnt’ is not defined</span></pre><p id="8331" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">问题是 Python 中的全局变量对于一个模块来说是全局的。</p><blockquote class="lv lw lx"><p id="d01c" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">Python 中的全局变量是模块的全局变量，而不是所有模块的全局变量。(与 C 不同，C 中的全局变量在所有实现文件中都是相同的，除非您显式地将其设为静态。).如果从导入的模块中需要真正的全局变量，可以在导入模块的属性中设置这些变量。</p><p id="315a" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">来源:<a class="ae ky" href="https://www.tutorialspoint.com/Explain-the-visibility-of-global-variables-in-imported-modules-in-Python" rel="noopener ugc nofollow" target="_blank">https://www . tutorialspoint . com/Explain-the-visibility-of-global-variables-in-imported-modules-in-Python</a></p></blockquote><p id="13d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，如何让一个全局变量在模块间可用呢？Python 医生有一些想法。</p><blockquote class="lv lw lx"><p id="765c" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">在单个程序中跨模块共享信息的规范方法是创建一个特殊的模块(通常称为 config 或 cfg)。只需在应用程序的所有模块中导入配置模块；然后，该模块就可以作为全局名称使用了。因为每个模块只有一个实例，所以对模块对象的任何更改都会在任何地方得到反映。例如:</p><p id="c658" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated"><strong class="lb iu">配置文件:</strong></p><p id="94e2" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">x = 0<em class="it"># x 配置设置的默认值</em></p><p id="e962" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated"><strong class="lb iu"> mod.py: </strong></p><p id="1fc8" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">导入配置<br/> config.x = 1</p><p id="a6d8" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated"><strong class="lb iu"> main.py: </strong></p><p id="bb06" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">导入配置<br/>导入模式<br/>打印(config.x)</p><p id="cafe" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">注意，出于同样的原因，使用模块也是实现单例设计模式的基础。</p><p id="db4a" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">来源:<a class="ae ky" href="https://docs.python.org/3/faq/programming.html?highlight=global#how-do-i-share-global-variables-across-modules" rel="noopener ugc nofollow" target="_blank">https://docs.python.org/3/faq/programming.html?highlight = global # how-do-I-share-global-variables-cross-modules</a></p></blockquote><p id="3882" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这不适用于 PySpark，原因是每个 worker 节点上有不同的 module 实例。<strong class="lb iu">因此需要累加器，因为共享变量的典型方式在 Spark 中不起作用。</strong></p><h1 id="d334" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">广播累加器</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="5d42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，<em class="ly"> broadcast_accumulator </em>方法调用<em class="ly"> accumulator_process </em>模块中的<em class="ly">process _ data _ accumulator</em>方法，累加器<em class="ly"> acc </em>。</p><p id="473e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里实际发生的是，我们向 worker 节点发送一个对象引用<em class="ly"> acc </em>。这样我们就不必定义它为全局。</p><p id="21aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我将讨论累加器的两个定制:</p><ol class=""><li id="28a1" class="my mz it lb b lc ld lf lg li on lm oo lq op lu nf ng nh ni bi translated">将静态值与累加器一起广播</li><li id="f870" class="my mz it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">广播多个累加器</li></ol><h1 id="9402" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">过滤累加器</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="21cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在此示例中，FilterAccumulator 类保存项目列表。如果在<em class="ly">过程</em>方法中传递的项目不在项目列表中，则更新累加器<em class="ly"> acc </em>。如代码所示，<em class="ly"> init </em>和<em class="ly"> count </em>应该在驱动程序上执行，而<em class="ly">进程</em>应该在 worker 节点上执行。执行上述操作得到的值为 4，这是正确的结果。</p><h1 id="d595" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">多个累加器</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="5984" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本例中，我们有两个累加器<em class="ly"> sum </em>和<em class="ly"> num </em>，分别累加项目的值和项目的数量。同样，如代码所示，<em class="ly"> init </em>和<em class="ly">意味着</em>应该在驱动程序上执行，而<em class="ly">在 worker 节点上处理</em>。虽然平均值可以使用其他本机 spark 方法获得，但这是一个如何使用单个类管理多个累加器而不将其声明为全局的示例(这在模块化代码中不起作用)。</p><h1 id="16d2" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="ae4e" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">希望现在已经很清楚如何使用类和广播来管理累加器，而不是声明为全局的。我希望在将来发布如何创建非整型和浮点型的累加器，因为 Spark 允许自定义累加器。</p></div></div>    
</body>
</html>