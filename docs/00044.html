<html>
<head>
<title>Android MVP for beginners</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向初学者的 Android MVP</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/simplest-way-to-understand-mvp-in-android-b2d96583260b?source=collection_archive---------15-----------------------#2020-01-02">https://towardsdatascience.com/simplest-way-to-understand-mvp-in-android-b2d96583260b?source=collection_archive---------15-----------------------#2020-01-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="05e2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让我们来理解这种设计模式是如何以更少的努力提供更大的维护大型项目代码的便利性的</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e285e5090e13ad6fcec948e8ceb21f61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JPH8xnrOME4fk1scALFnTA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@simonrae?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">西蒙·瑞</a>在<a class="ae ky" href="https://unsplash.com/s/photos/separate?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="6d35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在 Android 中，由于 Android 活动与 UI 和数据访问机制紧密耦合，我们遇到了一个问题。但是应用程序代码必须易于扩展、维护、阅读和测试，等等。为了实现所有这些，我们将使用 MVP 架构模式，它将应用程序分为三层。三层是模型、视图和演示者。</p><h1 id="763d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">模型视图演示者(MVP)</h1><ul class=""><li id="d7af" class="mn mo it lb b lc mp lf mq li mr lm ms lq mt lu mu mv mw mx bi translated">模型:它处理我们应用程序的数据部分</li><li id="35f7" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated"><strong class="lb iu">视图</strong>:负责按照演示者的指示，用相关数据布置视图</li><li id="6888" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated"><strong class="lb iu">展示者</strong>:它是连接模型和视图的桥梁</li></ul><p id="0842" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意</strong> : Presenter 是模型和视图之间的中间人，这意味着视图和模型不能直接相互交流。</p><h1 id="64d6" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">使用 MVP 的好处</h1><ul class=""><li id="ebc3" class="mn mo it lb b lc mp lf mq li mr lm ms lq mt lu mu mv mw mx bi translated">将用户界面的代码与业务逻辑分开</li><li id="31a7" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated">阻止模型(数据)和用户界面之间的直接通信</li><li id="992a" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated">更改代码的一部分不会影响另一部分。</li><li id="d96c" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated">代码对于单元测试来说变得容易多了</li></ul><p id="bc92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在把所有的理论部分放在一边，开始研究编码部分</p><p id="a0db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将创建登录应用程序，以尽可能保持简单</p><p id="c0c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在 ActivityMain.java 的课上，我简单地拿了两个编辑文本和一个登录按钮。我在这个活动中实现了<code class="fe nd ne nf ng b">LoginView</code> <code class="fe nd ne nf ng b">interface</code>,并覆盖了所有的方法——这些方法将基于用户提供的凭证被调用。如果<code class="fe nd ne nf ng b">username</code>和<code class="fe nd ne nf ng b">password</code>不是用户输入的，那么<code class="fe nd ne nf ng b">“Username can’t be empty”</code>消息将显示给用户。我正在创建人工延迟来显示进度条。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">ActivityMain.java</p></figure><p id="dc03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我声明了不同目的的方法，比如用户名错误和密码错误等等。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">LoginView.java</p></figure><p id="f4bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是最重要的类，有助于模型和视图之间的交流。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">LoginPresenter.java</p></figure><p id="ab53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个类包含了应用程序的业务逻辑，并且这个类决定了哪个方法将被调用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">LoginInteractor.java</p></figure><p id="3c6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><p id="097c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当输入字段为空时:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/c404f50b3cc331853007707aef5226ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*hxjnvcRWgdLZkuw_AgafSw.png"/></div></figure><p id="27e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当用户名和密码都正确时:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/a4ab2e4ffdc56242b1a8c3730153ac51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*fOQP9ClIjdzN0T8_Z3fgOQ.png"/></div></figure><h1 id="1a56" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="8cb0" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">MVP 架构模式没有普遍公认的定义。每个人都根据自己的需要实现这个模式，但是我们的目标应该是将代码分成至少三层，就像我们上面讨论的那样。</p><p id="4ef5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢读这篇文章，你也可以访问我的<a class="ae ky" href="http://thehimanshuverma.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">网站</strong> </a> <strong class="lb iu"> </strong>，在那里我会定期发布文章。</p><p id="233d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://mailchi.mp/b08da935e5d9/himanshuverma" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">订阅</strong> </a>我的邮件列表，以便在您的收件箱中直接获得我的文章，并且不要忘记关注我自己在 Medium<a class="ae ky" href="https://medium.com/the-code-monster" rel="noopener"><strong class="lb iu">The Code Monster</strong></a>上发表的文章，以丰富您的技术知识。</p><h1 id="75f6" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">了解你的作者</h1><p id="847c" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">希曼舒·维尔马毕业于印度勒克瑙的 APJ 阿卜杜勒·卡拉姆大学博士。他是 Android &amp; IOS 开发人员、机器学习和数据科学学习者、金融顾问和博客作者。</p></div></div>    
</body>
</html>