<html>
<head>
<title>Building a Sudoku Solving Application with Computer Vision and Backtracking</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用计算机视觉和回溯构建一个数独求解应用程序</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-a-sudoku-solving-application-with-computer-vision-and-backtracking-19668d0a1e2?source=collection_archive---------20-----------------------#2020-05-03">https://towardsdatascience.com/building-a-sudoku-solving-application-with-computer-vision-and-backtracking-19668d0a1e2?source=collection_archive---------20-----------------------#2020-05-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9683" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用在合成数据上训练的自定义OCR从截图中解决数独，然后回溯。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e7ab3618519eafb89eaeb5cfbe52f5eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E62Q7hnSRpPaYb6WEiRYVw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@jasonlthompson?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">贾森·汤普森</a>在<a class="ae kv" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="b953" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">数独是一种基于逻辑的谜题，通常以9x9网格和1到9位数的3x3子网格的形式出现。这个难题的有效解决方案的条件是，在任何行、列或3×3子网格中，没有数字被使用两次。</p><p id="2714" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可能的9x9网格的数量是6.67×10^21，所以根据最初的拼图，找到一个解决方案有时是具有挑战性的。在这个项目中，我们将构建一个Streamlit应用程序，它可以在给定一个屏幕截图的情况下自动解决数独难题。</p><p id="0224" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将首先构建一个对象字符识别模型，它可以从数独网格图像中提取数字，然后使用回溯方法来解决这个问题。最终的应用程序将通过一个易于使用的Streamlit应用程序进行访问。</p><p id="04f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">数独python表示和求解器的第一个版本大部分都是从这个Repo:【https://github.com/RutledgePaulV/sudoku-generator<a class="ae kv" href="https://github.com/RutledgePaulV/sudoku-generator" rel="noopener ugc nofollow" target="_blank"/>中获取和修改的</p><h1 id="6bb0" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">目标字符识别</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/d4c31c00229ca727502f83c18ef37523.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*-oZUiyeOi3y-qYChxuxtGQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:<a class="ae kv" href="https://en.wikipedia.org/wiki/Sudoku" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Sudoku</a></p></figure><p id="495d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦我们有了拼图的图像，我们需要提取所有写在那里的数字，以及它们的位置。</p><p id="19f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为此，我们将训练一个数字检测器模型，然后训练一个数字识别器模型。第一个会告诉我们一个数字出现在图像的什么地方，第二个会告诉我们是哪个数字。我们还将获得这两项任务的数据集。</p><h2 id="33f3" class="ml lt iq bd lu mm mn dn ly mo mp dp mc lf mq mr me lj ms mt mg ln mu mv mi mw bi translated">探测器模型</h2><p id="ce01" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">我们将使用的检测器模型基于具有跳跃连接的全卷积神经网络，与我们在以前的项目中使用的非常相似，例如:</p><ul class=""><li id="aee9" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nh ni nj nk bi translated"><a class="ae kv" rel="noopener" target="_blank" href="/vessel-segmentation-with-python-and-keras-722f9fb71b21">使用Python和Keras进行血管分割</a></li><li id="71cd" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated"><a class="ae kv" rel="noopener" target="_blank" href="/fingerprint-denoising-and-inpainting-using-fully-convolutional-networks-e24714c3233">使用全卷积网络的指纹去噪和修复</a></li></ul><p id="fc72" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想了解更多关于图像分割的知识，你可以阅读这两篇文章。</p><p id="f1a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个模型的目标是输出一个二进制掩码，告诉我们，对于输入图像的每个像素，它是否是数字的一部分。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/a4df00f76651964cd18fee2906636286.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n0f4XJr4CQGZeC2k44-Yvw.png"/></div></div></figure><h2 id="88eb" class="ml lt iq bd lu mm mn dn ly mo mp dp mc lf mq mr me lj ms mt mg ln mu mv mi mw bi translated">识别器模型</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/49ef04a06082f10bc8ebf753fcd518c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:460/format:webp/1*CIYBsWqBNv9C9skKILFCLA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">从上面的网格中提取的字符</p></figure><p id="f814" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">识别器模型的作用是接受单个数字作为输入，并预测它是集合{1，2，3，4，5，6，7，8，9}中的哪一个。它主要是一个卷积网络，但输出是一个具有softmax激活的全连接层。</p><h2 id="bf58" class="ml lt iq bd lu mm mn dn ly mo mp dp mc lf mq mr me lj ms mt mg ln mu mv mi mw bi translated">数据集</h2><p id="63d0" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">为了训练上述两个网络，我们需要带注释的数据。我们可以生成一个合成的数据集，而不是手动注释一堆数独网格，因为它花费不多，并且希望它能起作用😉。</p><p id="1c33" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了有一个真实的数据集，我们使用多种类型的字体、大小、背景颜色、网格元素…</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/5e1fa46d20ce26a3f478ade6dfadafb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/format:webp/1*cXmWQWiVwx779lm9EKfYig.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">生成图像的示例</p></figure><p id="6c9a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我们从头开始生成这些例子，所以我们可以获得图像中每个数字的位置和类别的所有细节。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/93077a092155f599031c1b68e02fbb61.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*CfQT1X4cxMK1eqnJq8ZbbA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">最终OCR结果</p></figure><h1 id="4f16" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">追踪</h1><p id="280f" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">我们将使用回溯来解决数独。这种方法允许我们一步一步地构建树状的候选解，然后如果我们发现子树不能产生可行的解，就修剪这棵树。</p><p id="11b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在数独游戏中的做法如下:</p><ul class=""><li id="7e21" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nh ni nj nk bi translated">对于每个单元格，我们计算可以用来填充给定网格状态的单元格的可能值。我们可以通过消去法很容易地做到这一点。</li><li id="b6df" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">我们按照可能值的数量对单元格进行排序，从最低到最高。</li><li id="4621" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">我们遍历第一个未填充的单元格，给它分配一个可能的值，然后分配给下一个，依此类推…</li><li id="7d6d" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">如果我们最终得到了一个可行的解，我们就返回它，否则我们就回到上一个被赋值的单元格，把它的状态改成另一个可能的值。有点像深度优先树搜索。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/1bf25792a3b9604ae4de5d6cfc386bd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/1*SEoISyrZa_RexSPhmt2w_A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">数字定义了遍历的顺序。来源:<a class="ae kv" href="https://commons.wikimedia.org/wiki/File:Depth-first-tree.svg" rel="noopener ugc nofollow" target="_blank">https://commons . wikimedia . org/wiki/File:Depth-first-tree . SVG</a></p></figure><p id="b35c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果在探索了这棵树所有可能的叶子之后，我们找不到解决方案，那么这个数独就是无解的。</p><p id="0c90" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">回溯的好处是保证找到一个解或者证明一个不存在。问题是，虽然它在9x9数独网格中通常很快，但它在一般情况下的时间复杂度是惊人的。</p><p id="efcc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实现(有些操作，如排序，是在“Board”类中执行的):</p><pre class="kg kh ki kj gt nv nw nx ny aw nz bi"><span id="9b79" class="ml lt iq nw b gy oa ob l oc od">def backtracking_solve(board):<br/>    # Modified from <a class="ae kv" href="https://github.com/RutledgePaulV/sudoku-generator/blob/master/Sudoku/Solver.py" rel="noopener ugc nofollow" target="_blank">https://github.com/RutledgePaulV/sudoku-generator/blob/master/Sudoku/Solver.py</a><br/>    set_initially_available(board.cells)<br/>    to_be_filled = board.get_unused_cells()<br/>    index = 0<br/>    n_iter = 0<br/>    while -1 &lt; index &lt; len(to_be_filled):<br/>        current = to_be_filled[index]<br/>        flag = False<br/>        possible_values = board.get_possibles(current)<br/>        my_range = range(current.value + 1, 10)<br/>        for x in my_range:<br/>            if x in possible_values:<br/>                n_iter += 1<br/>                current.value = x<br/>                flag = True<br/>                break<br/>        if not flag:<br/>            current.value = 0<br/>            index -= 1<br/>        else:<br/>            index += 1<br/>    if len(to_be_filled) == 0:<br/>        return n_iter, False<br/>    else:<br/>        return n_iter, index == len(to_be_filled)</span></pre><h1 id="3aec" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">该应用程序</h1><p id="78a9" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">我们使用Streamlit构建应用程序。该应用程序需要允许我们上传图像，解决数独，并显示结果。</p><h2 id="2f64" class="ml lt iq bd lu mm mn dn ly mo mp dp mc lf mq mr me lj ms mt mg ln mu mv mi mw bi translated">文件上传:</h2><p id="9781" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">Streamlit提供了一种使用st.file_uploader创建文件上传小部件的简单方法。</p><pre class="kg kh ki kj gt nv nw nx ny aw nz bi"><span id="bcec" class="ml lt iq nw b gy oa ob l oc od">file = st.file_uploader("Upload Sudoku image", type=["jpg", "png"])</span></pre><h2 id="9707" class="ml lt iq bd lu mm mn dn ly mo mp dp mc lf mq mr me lj ms mt mg ln mu mv mi mw bi translated">OCR:</h2><p id="99b8" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">我们应用检测器和识别器模型来创建网格。</p><pre class="kg kh ki kj gt nv nw nx ny aw nz bi"><span id="26de" class="ml lt iq nw b gy oa ob l oc od">grid = img_to_grid(img, detector_model, recognizer_model, plot_path=None, print_result=False)</span></pre><h2 id="a045" class="ml lt iq bd lu mm mn dn ly mo mp dp mc lf mq mr me lj ms mt mg ln mu mv mi mw bi translated">求解:</h2><p id="40ab" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">我们使用回溯来解决数独。</p><pre class="kg kh ki kj gt nv nw nx ny aw nz bi"><span id="0427" class="ml lt iq nw b gy oa ob l oc od">n_iter, _ = backtracking_solve(to_solve_board)</span></pre><h2 id="7632" class="ml lt iq bd lu mm mn dn ly mo mp dp mc lf mq mr me lj ms mt mg ln mu mv mi mw bi translated">显示结果:</h2><p id="72d3" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">我们通过指定unsafe_allow_html=True在一个漂亮的Html/Css表中显示结果。</p><pre class="kg kh ki kj gt nv nw nx ny aw nz bi"><span id="f45b" class="ml lt iq nw b gy oa ob l oc od">html_board.markdown("&lt;center&gt;" + to_solve_board.html() + "&lt;/center&gt;", unsafe_allow_html=True)</span></pre><h2 id="db4e" class="ml lt iq bd lu mm mn dn ly mo mp dp mc lf mq mr me lj ms mt mg ln mu mv mi mw bi translated">最终结果:</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/85094fa6b454ee9b151cf47ac674d721.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v1bArKhF6rA0KvMxRfUg1g.png"/></div></div></figure><h1 id="dfca" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论:</h1><p id="8428" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">在这个小项目中，我们在Streamlit中构建了一个数独求解应用程序。我们在这个过程中训练了一个定制的OCR模型，并使用回溯来解决实际的数独网格。</p><p id="839e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">代号:<a class="ae kv" href="https://github.com/CVxTz/sudoku_solver/" rel="noopener ugc nofollow" target="_blank">https://github.com/CVxTz/sudoku_solver/</a></p></div></div>    
</body>
</html>