<html>
<head>
<title>Predicting Gold Prices Using Machine Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用机器学习预测黄金价格</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/machine-learning-to-predict-gold-price-returns-4bdb0506b132?source=collection_archive---------11-----------------------#2020-04-20">https://towardsdatascience.com/machine-learning-to-predict-gold-price-returns-4bdb0506b132?source=collection_archive---------11-----------------------#2020-04-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="77d6" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/gold-price-prediction" rel="noopener" target="_blank">黄金预测</a></h2><div class=""/><div class=""><h2 id="e7f7" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">用PyCaret预测黄金价格</h2></div><h1 id="c57c" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">介绍</h1><p id="4c39" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">十多年来，我一直是金融市场的学生，一直在研究不同的资产类别及其在不同经济条件下的行为。很难找到比黄金更具两极分化的资产类别。有喜欢它的人，也有讨厌它的人，更多的时候，他们永远停留在同一个阵营。由于黄金本身没有什么基本面(这又是一个两极分化的来源)，在这个多部分系列中，我将尝试使用几种机器学习技术来预测黄金价格回报。以下是我(目前)对该系列的设想:</p><p id="d608" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated"><strong class="ll jd"> <em class="mk">第一部分:确定方法，收集和准备数据</em> </strong></p><p id="20f8" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated"><strong class="ll jd"> <em class="mk">第二部分:使用PyCaret </em> </strong>的回归建模</p><p id="eb7e" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated"><strong class="ll jd"> <em class="mk">第三部分:使用PyCaret </em> </strong>分类建模</p><p id="96f8" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated"><strong class="ll jd"> <em class="mk">第四部分:时间序列建模使用Prophet(脸书)</em> </strong></p><p id="896c" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated"><strong class="ll jd"> <em class="mk">第五部分:评估方法整合</em> </strong></p><blockquote class="ml mm mn"><p id="92af" class="lj lk mk ll b lm mf kd lo lp mg kg lr mo mh lu lv mp mi ly lz mq mj mc md me im bi translated">“请注意，在一个竞争极其激烈的市场中，黄金是一种交易非常广泛的资产。长期从任何策略中持续赚钱是极其困难的，如果不是不可能的话。这篇文章只是分享我的经验，而不是投资或交易的处方或倡导。然而，对于像我这样的该领域的学生来说，这个想法可以通过个人努力扩展和发展成交易算法。”</p></blockquote><h1 id="53e5" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">背景</h1><p id="2cd4" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">几个世纪以来，黄金一直是人类最初的价值储存手段和交易媒介，直到几个世纪前纸币取代了黄金。然而，直到1971年布雷顿森林协定被废除，世界货币成为真正的′𝐹𝑖𝑎𝑡′货币之前，大多数可持续的纸币都是由黄金支持的。</p><p id="548c" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">然而，黄金不仅作为珠宝的首选金属，而且作为价值储存手段和多样化投资组合中通常可取的一部分，继续引起人们的兴趣，因为它往往是一种有效的通胀对冲和经济经历艰难时期的避风港。</p><h1 id="b763" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">方法</h1><p id="e406" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在这个系列中，我们将采用不同的方法来预测黄金价格的回报，使用<strong class="ll jd">机器学习</strong>正如引言部分所强调的</p><p id="f053" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">首先，我们将走回归路线来预测未来2周和3周的黄金回报。我们将通过使用不同工具的历史回报来实现这一点，我认为这将影响黄金的前景。根本原因是，我将黄金称为一种“反动”资产。它几乎没有自己的基本面，价格的变动通常是投资者如何看待其他资产类别(股票、大宗商品等)的衍生品。).</p><h1 id="1624" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">导入数据</h1><p id="38b4" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在本次和后续练习中，我们将需要过去10年中几种工具的收盘价。我们可以使用各种付费资源(路透社、彭博)和免费资源(IEX、Quandl、Yahoofinance、谷歌财经)来导入数据。由于这个项目需要不同类型的资产类别(股票、商品、债务和贵金属)，我发现<strong class="ll jd">'</strong><a class="ae mr" href="https://pypi.org/project/yahoofinancials/" rel="noopener ugc nofollow" target="_blank"><strong class="ll jd"><em class="mk">Yahoo financials</em></strong></a><strong class="ll jd">'</strong>软件包非常有用且简单明了。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="7061" class="nb ks it mx b gy nc nd l ne nf"><strong class="mx jd"><em class="mk">#Importing Libraries</em></strong><br/>import pandas as pd<br/>from datetime import datetime<br/>import matplotlib.pyplot as plt<br/>from yahoofinancials import YahooFinancials</span></pre><p id="1dd7" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">我准备了一份需要导入数据的仪器清单。<strong class="ll jd"><em class="mk">Yahoo financials</em></strong>包需要Yahoo股票代码。该列表包含股票代号及其说明。包含列表的excel文件可以在<a class="ae mr" href="https://github.com/Riazone/Gold-Return-Prediction/blob/master/Ticker%20List.xlsx" rel="noopener ugc nofollow" target="_blank">这里</a>找到，文件名为“Ticker List”。我们导入该文件，并将股票代码和名称提取为单独的列表。(<a class="ae mr" href="https://github.com/Riazone/Gold-Return-Prediction/blob/master/Regression/Gold%20Prediction%20Experiment%20%20Regression-%20PyCaret.ipynb" rel="noopener ugc nofollow" target="_blank"> <em class="mk">见笔记本</em> </a>)</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="e8d8" class="nb ks it mx b gy nc nd l ne nf">ticker_details = pd.read_excel(“Ticker List.xlsx”)<br/>ticker = ticker_details['Ticker'].to_list()<br/>names = ticker_details['Description'].to_list()<br/>ticker_details.head(20)</span></pre><figure class="ms mt mu mv gt nh gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/c920231ca90a3548577ea2fce8aef876.png" data-original-src="https://miro.medium.com/v2/resize:fit:504/format:webp/1*8j73ugtxNcnvJt4iwFvnLg.png"/></div></figure><p id="7f89" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">有了列表后，我们需要定义需要导入数据的日期范围。我选择的期限是2010年1月至2020年3月1日。我之所以没有提取之前的数据，是因为2008-09年的<strong class="ll jd">全球金融危机(GFC) </strong>极大地改变了经济和市场格局。那段时期之前的关系现在可能没那么重要了。</p><p id="9950" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">我们创建一个日期范围，并将其写入一个名为<strong class="ll jd"> <em class="mk"> values </em> </strong>的空数据帧，我们将从yahoofinancials中提取并粘贴数据。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="ba92" class="nb ks it mx b gy nc nd l ne nf"><strong class="mx jd"><em class="mk">#Creating Date Range and adding them to values table</em></strong><br/>end_date= “2020–03–01”<br/>start_date = “2010–01–01”<br/>date_range = pd.bdate_range(start=start_date,end=end_date)<br/>values = pd.DataFrame({ ‘Date’: date_range})<br/>values[‘Date’]= pd.to_datetime(values[‘Date’])</span></pre><p id="355d" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">一旦我们在dataframe中有了日期范围，我们就需要使用ticker符号从API中提取数据。<strong class="ll jd"> <em class="mk"> yahoofinancials </em> </strong>以JSON格式返回输出。下面的代码循环遍历股票代码列表，只提取所有历史日期的收盘价，并将它们添加到在日期上水平合并的dataframe中。鉴于这些资产类别可能有不同的地区和交易假期，每次数据提取的日期范围可能不相同。通过合并，我们最终会有几个<em class="mk"> NAs </em>，稍后我们将<em class="mk">填充</em>。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="e72c" class="nb ks it mx b gy nc nd l ne nf"><strong class="mx jd"><em class="mk">#Extracting Data from Yahoo Finance and Adding them to Values table using date as key<br/></em></strong>for i in ticker:<br/> raw_data = YahooFinancials(i)<br/> raw_data = raw_data.get_historical_price_data(start_date, end_date, “daily”)<br/> df = pd.DataFrame(raw_data[i][‘prices’])[[‘formatted_date’,’adjclose’]]<br/> df.columns = [‘Date1’,i]<br/> df[‘Date1’]= pd.to_datetime(df[‘Date1’])<br/> values = values.merge(df,how=’left’,left_on=’Date’,right_on=’Date1')<br/> values = values.drop(labels=’Date1',axis=1)</span><span id="3606" class="nb ks it mx b gy nk nd l ne nf"><strong class="mx jd"><em class="mk">#Renaming columns to represent instrument names rather than their ticker codes for ease of readability</em></strong><br/>names.insert(0,’Date’)<br/>values.columns = names<br/>print(values.shape)<br/>print(values.isna().sum())<br/></span><span id="8afd" class="nb ks it mx b gy nk nd l ne nf"><strong class="mx jd"><em class="mk">#Front filling the NaN values in the data set</em></strong><br/>values = values.fillna(method="ffill",axis=0)<br/>values = values.fillna(method="bfill",axis=0)<br/>values.isna().sum()</span><span id="7e25" class="nb ks it mx b gy nk nd l ne nf"><strong class="mx jd"><em class="mk"># Coercing numeric type to all columns except Date</em></strong><br/>cols=values.columns.drop('Date')<br/>values[cols] = values[cols].apply(pd.to_numeric,errors='coerce').round(decimals=1)<br/>values.tail()</span></pre><figure class="ms mt mu mv gt nh gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi nl"><img src="../Images/062f5bf33aa745965aa55dea1e5413f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n9DrEpRxVpV2rDzJBtsDhg.png"/></div></div><p class="nq nr gj gh gi ns nt bd b be z dk translated">值表的尾部</p></figure><h1 id="2ed9" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">准备数据</h1><p id="aef3" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在上述方法中，我们强调了我们将使用上市工具的滞后回报来预测黄金的未来回报。在这里，我们继续计算所有工具的短期历史回报和少数选定工具的长期历史回报。</p><p id="b98c" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">其背后的基本思想是，如果某项资产表现优异或表现不佳，投资组合重新平衡的可能性更大，这将影响未来其他资产类别的回报。如果股票市场(比如说S &amp; P500)在过去的6个月中表现出惊人的回报，资产经理可能会希望记录利润，并分配一些资金到贵金属上，为股票市场的调整做准备。下图显示了在不同的市场条件下，黄金和标普500之间的价格变动和相关性。</p><figure class="ms mt mu mv gt nh gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi nu"><img src="../Images/7abd1b20cfb2730cb210b4cfe090a7c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YIsV9sx5qw_GqWVjA4QF_Q.png"/></div></div></figure><figure class="ms mt mu mv gt nh gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi nv"><img src="../Images/1241094ec01d835c56eed66bcf7067da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x6xtsbW5IqY9m1O1ymhYBQ.jpeg"/></div></div><p class="nq nr gj gh gi ns nt bd b be z dk translated">资料来源:彭博、ICE基准管理机构、世界黄金协会。<a class="ae mr" href="https://www.gold.org/goldhub/research/relevance-of-gold-as-a-strategic-asset-2019" rel="noopener ugc nofollow" target="_blank">链接</a></p></figure><p id="fba7" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">从上面我们可以看到，当S&amp;P500出现极端的负向运动时，黄金表现出负相关性。最近股市的大幅下跌也凸显了类似的关系，当金价因预期下跌而上涨时，年初至今金价上涨了11%，而S&amp;P500年初至今下跌了11%。</p><p id="4f98" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">然而，我们将使用机器学习来评估假设。您可以直接从我的<a class="ae mr" href="https://github.com/Riazone/Gold-Return-Prediction/blob/master/Training%20Data_Values.csv" rel="noopener ugc nofollow" target="_blank"> git-hub repo </a>下载文件名为‘Training Data _ Values’的数值数据</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="f04e" class="nb ks it mx b gy nc nd l ne nf">imp = [‘Gold’,’Silver’, ‘Crude Oil’, ‘S&amp;P500’,’MSCI EM ETF’]</span><span id="7e61" class="nb ks it mx b gy nk nd l ne nf"><strong class="mx jd"><em class="mk"># Calculating Short term -Historical Returns</em></strong><br/>change_days = [1,3,5,14,21]</span><span id="2c09" class="nb ks it mx b gy nk nd l ne nf">data = pd.DataFrame(data=values[‘Date’])<br/>for i in change_days:<br/> print(data.shape)<br/> x= values[cols].pct_change(periods=i).add_suffix(“-T-”+str(i))<br/> data=pd.concat(objs=(data,x),axis=1)<br/> x=[]<br/>print(data.shape)</span><span id="5e23" class="nb ks it mx b gy nk nd l ne nf"><strong class="mx jd"><em class="mk"># Calculating Long term Historical Returns</em></strong><br/>change_days = [60,90,180,250]</span><span id="3954" class="nb ks it mx b gy nk nd l ne nf">for i in change_days:<br/> print(data.shape)<br/> x= values[imp].pct_change(periods=i).add_suffix(“-T-”+str(i))<br/> data=pd.concat(objs=(data,x),axis=1)<br/> x=[]<br/>print(data.shape)</span></pre><p id="deda" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">除了滞后回报，我们还可以看到不同窗口的当前金价离其移动平均线有多远。这是技术分析中非常常用的指标，移动平均线为资产价格提供支撑和阻力。我们使用简单移动平均线和指数移动平均线的组合。然后，我们将这些移动平均值添加到现有的特征空间。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="5dc5" class="nb ks it mx b gy nc nd l ne nf"><strong class="mx jd"><em class="mk">#Calculating Moving averages for Gold</em></strong><br/>moving_avg = pd.DataFrame(values[‘Date’],columns=[‘Date’])<br/>moving_avg[‘Date’]=pd.to_datetime(moving_avg[‘Date’],format=’%Y-%b-%d’)<br/><strong class="mx jd"><em class="mk">#Adding Simple Moving Average</em></strong><br/>moving_avg[‘Gold/15SMA’] = (values[‘Gold’]/(values[‘Gold’].rolling(window=15).mean()))-1<br/>moving_avg[‘Gold/30SMA’] = (values[‘Gold’]/(values[‘Gold’].rolling(window=30).mean()))-1<br/>moving_avg[‘Gold/60SMA’] = (values[‘Gold’]/(values[‘Gold’].rolling(window=60).mean()))-1<br/>moving_avg[‘Gold/90SMA’] = (values[‘Gold’]/(values[‘Gold’].rolling(window=90).mean()))-1<br/>moving_avg[‘Gold/180SMA’] = (values[‘Gold’]/(values[‘Gold’].rolling(window=180).mean()))-1</span><span id="0de2" class="nb ks it mx b gy nk nd l ne nf"><strong class="mx jd"><em class="mk">#Adding Exponential Moving Average<br/></em></strong>moving_avg[‘Gold/90EMA’] = (values[‘Gold’]/(values[‘Gold’].ewm(span=90,adjust=True,ignore_na=True).mean()))-1<br/>moving_avg[‘Gold/180EMA’] = (values[‘Gold’]/(values[‘Gold’].ewm(span=180,adjust=True,ignore_na=True).mean()))-1<br/>moving_avg = moving_avg.dropna(axis=0)<br/>print(moving_avg.shape)<br/>moving_avg.head(20)</span></pre><figure class="ms mt mu mv gt nh gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/a8a242b98b0ac7b771f1406f652a1e2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/format:webp/1*nPd7K-2XXRt_e9m3K4pP4g.png"/></div><p class="nq nr gj gh gi ns nt bd b be z dk translated">移动平均数据帧的输出</p></figure><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="ccbf" class="nb ks it mx b gy nc nd l ne nf"><strong class="mx jd"><em class="mk">#Merging Moving Average values to the feature space</em></strong><br/>data[‘Date’]=pd.to_datetime(data[‘Date’],format=’%Y-%b-%d’)<br/>data = pd.merge(left=data,right=moving_avg,how=’left’,on=’Date’)<br/>print(data.shape)<br/>data.isna().sum()</span></pre><p id="fdbb" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">这都是关于特性的。现在我们需要创建目标，也就是我们想要预测的。因为我们在预测回报，所以我们需要选择一个我们需要预测回报的时间范围。我选择了14天和22天的时间范围，因为其他更小的时间范围往往非常不稳定，缺乏预测能力。然而，你也可以尝试其他的地平线。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="4fcc" class="nb ks it mx b gy nc nd l ne nf"><strong class="mx jd"><em class="mk">#Calculating forward returns for Target</em></strong><br/>y = pd.DataFrame(data=values[‘Date’])<br/>y[‘Gold-T+14’]=values[“Gold”].pct_change(periods=-14)<br/>y[‘Gold-T+22’]=values[“Gold”].pct_change(periods=-22)<br/>print(y.shape)<br/>y.isna().sum()</span><span id="2496" class="nb ks it mx b gy nk nd l ne nf"><strong class="mx jd"><em class="mk"># Removing NAs</em></strong><br/><br/>data = data[data[‘Gold-T-250’].notna()]<br/>y = y[y[‘Gold-T+22’].notna()]</span><span id="1d30" class="nb ks it mx b gy nk nd l ne nf"><strong class="mx jd"><em class="mk">#Adding Target Variables</em></strong><br/>data = pd.merge(left=data,right=y,how=’inner’,on=’Date’,suffixes=(False,False))<br/>print(data.shape)</span></pre><p id="1b87" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">现在我们有了完整的数据集，可以开始建模了。在下一部分中，我们将使用极其创新和高效的PyCaret库来试验不同的算法。我还将展示如何创建一个管道来不断导入新数据，以使用训练好的模型生成预测。</p></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><h1 id="574f" class="kr ks it bd kt ku oe kw kx ky of la lb ki og kj ld kl oh km lf ko oi kp lh li bi translated">利用机器学习预测黄金价格</h1><h2 id="81de" class="nb ks it bd kt oj ok dn kx ol om dp lb ls on oo ld lw op oq lf ma or os lh iz bi translated">使用PyCaret的第二部分回归建模</h2><p id="239a" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在第一部分中，我们讨论了从开源免费API导入数据，并以一种适合我们预期的机器学习练习的方式准备它。您可以参考第一部分的代码，或者从<a class="ae mr" href="https://github.com/Riazone/Gold-Return-Prediction/blob/master/Training%20Data.csv" rel="noopener ugc nofollow" target="_blank"> github repo </a>导入文件名为“Training Data”的最终数据集。</p><p id="aa49" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">PyCaret是Python中的一个开源机器学习库，可以在任何笔记本环境中使用，并大大减少了编码工作，使过程变得非常高效。在下面的部分我们将看到<strong class="ll jd"><em class="mk"/></strong><a class="ae mr" href="https://pycaret.org/" rel="noopener ugc nofollow" target="_blank"><strong class="ll jd"><em class="mk">py caret</em></strong></a>如何为任何机器学习实验增压。首先，您需要使用以下命令安装PyCaret:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="f848" class="nb ks it mx b gy nc nd l ne nf">!pip install pycaret</span></pre><h2 id="6605" class="nb ks it bd kt oj ok dn kx ol om dp lb ls on oo ld lw op oq lf ma or os lh iz bi translated">22天模型</h2><p id="e4b1" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我们以22天为目标。这意味着，根据历史数据，我们将尝试预测未来三周的黄金回报。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="17c6" class="nb ks it mx b gy nc nd l ne nf"><strong class="mx jd"><em class="mk">#If you are importing downloaded dataset</em></strong><br/>data = pd.read_csv("Training Data.csv")</span><span id="1b8f" class="nb ks it mx b gy nk nd l ne nf">from pycaret.regression import *</span><span id="8eea" class="nb ks it mx b gy nk nd l ne nf"><strong class="mx jd"><em class="mk">#We have two target columns. We will remove the T+14 day Target<br/></em></strong>data_22= data.drop(['Gold-T+14'],axis=1)</span></pre><p id="3297" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated"><strong class="ll jd">设置</strong></p><p id="37de" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">要在PyCaret中开始任何建模练习，第一步是“设置”功能。这里的强制变量是数据集和数据集中的目标标签。所有基本和必要的数据转换，如丢弃id、一次性编码分类因子和缺失值插补，都在后台自动进行。PyCaret还提供了20多个预处理选项。对于这个例子，我们将在设置中使用基础知识，并在后面的实验中尝试不同的预处理技术。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="76a3" class="nb ks it mx b gy nc nd l ne nf">a=setup(data_22,target='Gold-T+22',<br/>        ignore_features=['Date'],session_id=11,<br/>        silent=True,profile=False);</span></pre><p id="788c" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">在上面的代码中，数据集作为“data_22”传递，目标指向标记为“Gold-T+22”的列。我特别提到要忽略“日期”列，以防止PyCaret在日期列上创建基于时间的功能，这在其他情况下可能非常有用，但我们现在不评估这一点。如果您想查看变量之间的分布和相关性，您可以保留参数“profile=True”，它显示一个panda profiler输出。我特意提供了‘session _ id = 11 ’,以便能够重新创建结果。</p><p id="a67b" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated"><strong class="ll jd">魔法命令....<em class="mk">compare _ models()</em>T3】</strong></p><p id="500e" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">下一步，我将使用PyCaret的一个我最喜欢的特性，它将数百行代码缩减为两个字——“compare _ models”。该函数使用所有算法(目前有25种)并使它们适合数据，运行10重交叉验证，并为每个模型提供6个评估指标。所有这些只用两个字。为了节省时间，函数中还可以使用另外两个参数:</p><p id="eebb" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated"><strong class="ll jd"> a. turbo=False </strong> —默认为真。当turbo=True时，比较模型不会评估一些更昂贵的算法，即核脊(kr)、自动相关性确定(ard)和多层感知器(mlp)</p><p id="57d7" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated"><strong class="ll jd"> b .黑名单</strong> —在这里，可以传递算法缩写的列表(参见docstring ),这是众所周知的耗时更长且性能改善很小的方法。下面，我已经把尼尔森回归器(tr)列入了黑名单</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="3e1a" class="nb ks it mx b gy nc nd l ne nf">compare_models(blacklist=['tr'],turbo=True)</span></pre><figure class="ms mt mu mv gt nh gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/d0162a42a31060ea5467a491e2deb486.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/format:webp/1*qyHVCx4o4J7DfvHByLWcvA.png"/></div><p class="nq nr gj gh gi ns nt bd b be z dk translated">比较模型的输出</p></figure><p id="d460" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">这里我们将使用R平方(R2)作为度量标准。我们看到ET、Catboost和KNN是前三名的模型。下一步，我们将调整三个模型的超参数。</p><p id="f18a" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated"><strong class="ll jd">调整模型超参数</strong></p><p id="ed05" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">PyCaret为每个算法都预定义了一个网格，并且<strong class="ll jd"> <em class="mk"> tune_model() </em> </strong>函数使用随机网格搜索来查找优化指标选择的参数集(此处为Rsquare ),并显示优化模型的交叉验证分数。它不接受经过训练的模型，并且需要作为字符串传递的估计量的缩写。我们将调整额外树(et)、K最近邻(knn)和CatBoost (catboost)回归器。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="5a4f" class="nb ks it mx b gy nc nd l ne nf">et_tuned = tune_model(‘et’)</span></pre><figure class="ms mt mu mv gt nh gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/20a519e288010c98fdede54b8cc6fa45.png" data-original-src="https://miro.medium.com/v2/resize:fit:698/format:webp/1*Uyr9_ZMPPj1ymb7qQLVEVw.png"/></div></figure><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="0e46" class="nb ks it mx b gy nc nd l ne nf">catb_tuned = tune_model(‘catboost’)</span></pre><figure class="ms mt mu mv gt nh gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/10b1b9287a528fe802ea76cd83c2e551.png" data-original-src="https://miro.medium.com/v2/resize:fit:692/format:webp/1*n_Ss1NREh9Bgjcmveb3jIw.png"/></div></figure><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="4883" class="nb ks it mx b gy nc nd l ne nf">knn_tuned = tune_model(‘knn’,n_iter=150)</span><span id="0ada" class="nb ks it mx b gy nk nd l ne nf"><em class="mk">#I have increased the iteration in knn because increasing iterations have shown to perform better for knn rather than other models in question without significantly increasing the training time.</em></span></pre><figure class="ms mt mu mv gt nh gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/550777fdfa0d9c00ebf91952543aef33.png" data-original-src="https://miro.medium.com/v2/resize:fit:712/format:webp/1*jNwXyUhJAiWNr2BTb63eEA.png"/></div></figure><p id="e42b" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">上面我们可以看到，knn的R2在调优后大幅提升至87.86%，远高于调优后没有提升的et和catboost。这可能是因为网格搜索过程中的随机化。在一些非常高的迭代次数下，它们可能会改进。</p><p id="1dda" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">我还会创建一个基本的额外树(et)模型，因为它的原始性能(调优前)非常接近调优后的knn。我们将使用PyCaret中的<strong class="ll jd"><em class="mk">create _ model()</em></strong>函数来创建模型。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="049d" class="nb ks it mx b gy nc nd l ne nf">et = create_model(‘et’)</span></pre><p id="3c31" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated"><strong class="ll jd">评估模型</strong></p><p id="8d44" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">对训练好的模型进行一些模型诊断是很重要的。我们将使用PyCaret中的<strong class="ll jd"> <em class="mk"> evaluate_model() </em> </strong>函数来查看绘图集和其他诊断信息。它接受经过训练的模型，以返回模型诊断图和模型定义的选择。我们将对我们的两个顶级模型进行模型诊断，即knn_tuned和et。</p><figure class="ms mt mu mv gt nh gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi ox"><img src="../Images/5e80629540849143383600b07560080e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vecSoo26snJEaae8bi8OzA.png"/></div></div><p class="nq nr gj gh gi ns nt bd b be z dk translated">库克距离图knn_tuned</p></figure><p id="7d54" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">上面，我们可以清楚地看到，在前500个观察值中，有许多异常值，它们不仅影响模型性能，还可能影响未来的模型泛化。因此，去除这些异常值可能是值得的。但在此之前，我们将通过et来了解特征重要性(knn不提供特征重要性)</p><figure class="ms mt mu mv gt nh gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi oy"><img src="../Images/70d15f5fbcd14dd4e70bea960f4a6d8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*98uU-bVryZsx-ew8k52bJg.png"/></div></div></figure><p id="841f" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">我们认为，白银和新兴市场ETF的回报率具有最高的特征重要性，突显出白银和黄金通常成对波动，而投资组合配置确实在新兴市场股票和黄金之间转移。</p><p id="25b6" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated"><strong class="ll jd">去除异常值</strong></p><p id="77b7" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">要移除异常值，我们需要回到设置阶段，使用PyCaret内置的异常值移除器，并再次创建模型以查看影响。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="64dc" class="nb ks it mx b gy nc nd l ne nf">b=setup(data_22,target=’Gold-T+22', ignore_features=[‘Date’], session_id=11,silent=True,profile=False,remove_outliers=True);</span></pre><p id="51c5" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">如果<strong class="ll jd"><em class="mk">' remove _ outliers '</em></strong>参数设置为true，PyCaret使用奇异值分解(SVD)技术删除通过PCA线性降维识别的离群值。默认杂质水平为5%。这意味着它将删除5%的观察值，它认为是离群值。</p><p id="96ab" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">移除异常值后，我们再次运行我们的顶级模型，看看是否有任何性能改进，显然有。</p><div class="ms mt mu mv gt ab cb"><figure class="oz nh pa pb pc pd pe paragraph-image"><img src="../Images/e2b319c4ecb20a52299f97941c9345b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:692/format:webp/1*XV-SkGw8rAQgNGZZc9p_CA.png"/></figure><figure class="oz nh pf pb pc pd pe paragraph-image"><img src="../Images/49c4937fe38f3fca54eebb6b37e052d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:666/format:webp/1*Iq5k-FAxyNo9NC_FxB74nw.png"/><p class="nq nr gj gh gi ns nt bd b be z dk pg di ph pi translated">剔除异常值后的et和knn_tuned结果</p></figure></div><p id="6eea" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">我们看到et的性能从85.43%提高到86.16%，knn_tuned的性能从87.86%提高到88.3%。褶皱间的标准差也有所降低。</p><p id="d5c6" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated"><strong class="ll jd">集合模型</strong></p><p id="9947" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">我们还可以尝试看看bagging/boosting是否可以提高模型性能。我们可以使用PyCaret中的<strong class="ll jd"><em class="mk">ensemble _ model()</em></strong>函数，通过下面的代码快速查看集成方法如何改善结果:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="8228" class="nb ks it mx b gy nc nd l ne nf">et_bagged = ensemble_model(et,method=’Bagging’)<br/>knn_tuned_bagged = ensemble_model(knn_tuned, method='Bagging')</span></pre><p id="b073" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">上述代码将显示类似的交叉验证分数，但没有显示出太大的改进。回购中的笔记本链接可以看到结果。</p><p id="b309" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated"><strong class="ll jd">混合模型</strong></p><p id="232f" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">我们可以混合前2个模型(et和knn_tuned)来看看混合模型是否可以表现得更好。人们经常看到，混合模型经常学习不同的模式，并且它们一起具有更好的预测能力。为此我将使用PyCaret的<strong class="ll jd"><em class="mk">blend _ models()</em></strong>函数。它接受一个训练模型列表，并返回一个混合模型和10倍交叉验证分数。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="c875" class="nb ks it mx b gy nc nd l ne nf">blend_knn_et = blend_models(estimator_list=[knn_tuned,et])</span></pre><figure class="ms mt mu mv gt nh gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/5e76bdf4a7d4c7f58bba6b7f493ea683.png" data-original-src="https://miro.medium.com/v2/resize:fit:688/format:webp/1*KBFj0LhJQrw8tI1frwPntg.png"/></div><p class="nq nr gj gh gi ns nt bd b be z dk translated">混合模型的结果</p></figure><p id="c36a" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">在上表中，我们看到混合的<strong class="ll jd"> <em class="mk"> knn_tuned </em> </strong>和<strong class="ll jd"> <em class="mk"> et </em> </strong>返回比两者更好地表示R2。与<strong class="ll jd"> <em class="mk"> knn_tuned </em> </strong>相比，R2的平均R2增加了1.9%，标准差减少了1.9%，这意味着跨褶皱的性能更好、更一致。</p><p id="9970" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">90.2%的平均R2意味着我们的模型能够从我们提供的特征中捕捉平均90.2%的黄金回报变化。</p><p id="64f8" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated"><strong class="ll jd">堆叠模型</strong></p><p id="c132" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">虽然混合模型的结果很好，但我想看看是否有可能从数据中提取更多的R2基点。为此，我们将建立一个多层次的模型堆栈。这不同于混合，因为模型层是按顺序堆叠的，因此一层中模型的预测将与原始要素一起传递到模型的下一层(如果restack = True)。一组模型的预测极大地帮助了后续模型的预测。链的末端是元模型(默认是线性的)。PyCaret guide有更多关于<a class="ae mr" href="https://pycaret.org/stack-models/" rel="noopener ugc nofollow" target="_blank">主题</a>的细节。在笔记本中，我尝试了几种架构。下面展示的是性能最佳的产品:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="ece0" class="nb ks it mx b gy nc nd l ne nf">stack2 = create_stacknet(estimator_list=[[catb,et,knn_tuned],[blend_knn_et]], restack=True)</span></pre><figure class="ms mt mu mv gt nh gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/4aebda0982ceeb32ea77bcf8ff799654.png" data-original-src="https://miro.medium.com/v2/resize:fit:662/format:webp/1*C0bE6lZdqnuM1sQ4N1idpg.png"/></div><p class="nq nr gj gh gi ns nt bd b be z dk translated">堆叠2的结果(多层堆叠)</p></figure><p id="976e" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">正如我们在上面看到的，<strong class="ll jd"> <em class="mk"> stack2 </em> </strong>模型比<strong class="ll jd"> <em class="mk"> blend_knn_et </em> </strong>有1%的R2，我们将选择<strong class="ll jd"> <em class="mk"> stack2 </em> </strong>作为最佳模型，并保存它用于预测。</p><p id="43c8" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated"><strong class="ll jd">保存模式</strong></p><p id="9079" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">一旦模型定型，我们需要保存模型，以便在新数据上使用它来进行预测。我们可以通过save_model()来实现。这会将模型保存在当前目录或任何已定义的路径中。下面的代码将模型和预处理管道保存为名称<strong class="ll jd"><em class="mk">【22天回归器】</em> </strong></p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="fc50" class="nb ks it mx b gy nc nd l ne nf">save_model(model=stack2, model_name=’22Day Regressor’)</span></pre><p id="e560" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated"><strong class="ll jd">对新数据进行预测</strong></p><p id="afee" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">一旦我们保存了我们的模型，我们将希望在新数据到达时对其进行预测。我们可以依靠yahoofinancials软件包来给出所有工具的收盘价，但是，我们需要再次准备新的数据，以便能够使用该模型。这些步骤与我们在准备培训数据时所做的类似，唯一的区别是我们将导入最新的数据，并且我们不会创建标签(我们不能创建标签，因为我们没有未来的价格)。下面的代码chuck应该导入并调整数据，使其为预测做好准备。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="d87c" class="nb ks it mx b gy nc nd l ne nf"><strong class="mx jd"><em class="mk">#Importing Libraries</em></strong><br/>import pandas as pd<br/>from datetime import datetime<br/>import matplotlib.pyplot as plt<br/>from yahoofinancials import YahooFinancials</span><span id="a77d" class="nb ks it mx b gy nk nd l ne nf">ticker_details = pd.read_excel("Ticker List.xlsx")<br/>ticker = ticker_details['Ticker'].to_list()<br/>names = ticker_details['Description'].to_list()</span><span id="28b0" class="nb ks it mx b gy nk nd l ne nf"><strong class="mx jd"><em class="mk">#Preparing Date Range</em></strong><br/>end_date= datetime.strftime(datetime.today(),'%Y-%m-%d')<br/>start_date = "2019-01-01"<br/>date_range = pd.bdate_range(start=start_date,end=end_date)<br/>values = pd.DataFrame({ 'Date': date_range})<br/>values['Date']= pd.to_datetime(values['Date'])</span><span id="fbd8" class="nb ks it mx b gy nk nd l ne nf"><strong class="mx jd"><em class="mk">#Extracting Data from Yahoo Finance and Adding them to Values table using date as key</em></strong><br/>for i in ticker:<br/>    raw_data = YahooFinancials(i)<br/>    raw_data = raw_data.get_historical_price_data(start_date, end_date, "daily")<br/>    df = pd.DataFrame(raw_data[i]['prices'])[['formatted_date','adjclose']]<br/>    df.columns = ['Date1',i]<br/>    df['Date1']= pd.to_datetime(df['Date1'])<br/>    values = values.merge(df,how='left',left_on='Date',right_on='Date1')<br/>    values = values.drop(labels='Date1',axis=1)</span><span id="59d9" class="nb ks it mx b gy nk nd l ne nf"><strong class="mx jd"><em class="mk">#Renaming columns to represent instrument names rather than their ticker codes for ease of readability</em></strong><br/>names.insert(0,'Date')<br/>values.columns = names</span><span id="8148" class="nb ks it mx b gy nk nd l ne nf"><strong class="mx jd"><em class="mk">#Front filling the NaN values in the data set</em></strong><br/>values = values.fillna(method="ffill",axis=0)<br/>values = values.fillna(method="bfill",axis=0)</span><span id="4a5d" class="nb ks it mx b gy nk nd l ne nf"><strong class="mx jd"><em class="mk"># Co-ercing numeric type to all columns except Date</em></strong><br/>cols=values.columns.drop('Date')<br/>values[cols] = values[cols].apply(pd.to_numeric,errors='coerce').round(decimals=1)<br/>imp = ['Gold','Silver', 'Crude Oil', 'S&amp;P500','MSCI EM ETF']</span><span id="dc14" class="nb ks it mx b gy nk nd l ne nf"><strong class="mx jd"><em class="mk"># Calculating Short term -Historical Returns</em></strong><br/>change_days = [1,3,5,14,21]</span><span id="954e" class="nb ks it mx b gy nk nd l ne nf">data = pd.DataFrame(data=values['Date'])<br/>for i in change_days:<br/>    x= values[cols].pct_change(periods=i).add_suffix("-T-"+str(i))<br/>    data=pd.concat(objs=(data,x),axis=1)<br/>    x=[]</span><span id="bd20" class="nb ks it mx b gy nk nd l ne nf"><strong class="mx jd"><em class="mk"># Calculating Long term Historical Returns</em></strong><br/>change_days = [60,90,180,250]</span><span id="a037" class="nb ks it mx b gy nk nd l ne nf">for i in change_days:<br/>    x= values[imp].pct_change(periods=i).add_suffix("-T-"+str(i))<br/>    data=pd.concat(objs=(data,x),axis=1)<br/>    x=[]</span><span id="16b7" class="nb ks it mx b gy nk nd l ne nf"><strong class="mx jd"><em class="mk">#Calculating Moving averages for Gold</em></strong><br/>moving_avg = pd.DataFrame(values['Date'],columns=['Date'])<br/>moving_avg['Date']=pd.to_datetime(moving_avg['Date'],format='%Y-%b-%d')<br/>moving_avg['Gold/15SMA'] = (values['Gold']/(values['Gold'].rolling(window=15).mean()))-1<br/>moving_avg['Gold/30SMA'] = (values['Gold']/(values['Gold'].rolling(window=30).mean()))-1<br/>moving_avg['Gold/60SMA'] = (values['Gold']/(values['Gold'].rolling(window=60).mean()))-1<br/>moving_avg['Gold/90SMA'] = (values['Gold']/(values['Gold'].rolling(window=90).mean()))-1<br/>moving_avg['Gold/180SMA'] = (values['Gold']/(values['Gold'].rolling(window=180).mean()))-1<br/>moving_avg['Gold/90EMA'] = (values['Gold']/(values['Gold'].ewm(span=90,adjust=True,ignore_na=True).mean()))-1<br/>moving_avg['Gold/180EMA'] = (values['Gold']/(values['Gold'].ewm(span=180,adjust=True,ignore_na=True).mean()))-1<br/>moving_avg = moving_avg.dropna(axis=0)</span><span id="c0a3" class="nb ks it mx b gy nk nd l ne nf"><strong class="mx jd"><em class="mk">#Merging Moving Average values to the feature space</em></strong></span><span id="ae71" class="nb ks it mx b gy nk nd l ne nf">data['Date']=pd.to_datetime(data['Date'],format='%Y-%b-%d')<br/>data = pd.merge(left=data,right=moving_avg,how='left',on='Date')<br/>data = data[data['Gold-T-250'].notna()]<br/>prediction_data = data.copy()</span></pre><p id="b4fb" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">准备好数据后，我们需要加载模型并进行预测。为了加载模型，我们将再次使用PyCaret的回归模块。下面的代码将加载模型，对新数据进行预测，并使用数据集中每个日期的历史价格、预计回报和3周内的预测价格。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="d750" class="nb ks it mx b gy nc nd l ne nf">from pycaret.regression import *</span><span id="5bd5" class="nb ks it mx b gy nk nd l ne nf"><strong class="mx jd"><em class="mk">#Loading the stored model<br/></em></strong>regressor_22 = load_model("22Day Regressor");</span><span id="63e3" class="nb ks it mx b gy nk nd l ne nf"><strong class="mx jd"><em class="mk">#Making Predictions<br/></em></strong>predicted_return_22 = predict_model(regressor_22,data=prediction_data)<br/>predicted_return_22=predicted_return_22[['Date','Label']]<br/>predicted_return_22.columns = ['Date','Return_22']</span><span id="bf6f" class="nb ks it mx b gy nk nd l ne nf"><strong class="mx jd"><em class="mk">#Adding return Predictions to Gold Values</em></strong><br/>predicted_values = values[['Date','Gold']]<br/>predicted_values = predicted_values.tail(len(predicted_return_22))<br/>predicted_values = pd.merge(left=predicted_values,right=predicted_return_22,on=['Date'],how='inner')<br/>predicted_values['Gold-T+22']=(predicted_values['Gold']*(1+predicted_values['Return_22'])).round(decimals =1)</span><span id="32bc" class="nb ks it mx b gy nk nd l ne nf"><strong class="mx jd"><em class="mk">#Adding T+22 Date<br/></em></strong>from datetime import datetime, timedelta</span><span id="dbbd" class="nb ks it mx b gy nk nd l ne nf">predicted_values['Date-T+22'] = predicted_values['Date']+timedelta(days = 22)<br/>predicted_values.tail()</span></pre><figure class="ms mt mu mv gt nh gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/03c371b9281ddfe68e734623e2c60138.png" data-original-src="https://miro.medium.com/v2/resize:fit:694/format:webp/1*OKAIYzGtwmhzagdQ1rIXlQ.png"/></div></figure><p id="4631" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">上表输出显示，黄金在2020年4月17日的收盘价为1，694.5美元，模型预测在接下来的22天内，回报将为-2.3%，导致2020年5月9日的价格目标为1，655美元。我为预测建立了一个单独的笔记本，标题为<strong class="ll jd"> <em class="mk">“黄金预测新数据—回归”</em> </strong>，可以在回购<a class="ae mr" href="https://github.com/Riazone/Gold-Return-Prediction/blob/master/Regression/Gold%20Prediction%20New%20Data%20-%20Regression.ipynb" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="08f5" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">我们可以使用相同的概念和技术来预测T+14天。代码和输出可以在Jupyter笔记本标题<strong class="ll jd"> <em class="mk">“黄金预测实验回归—py caret”</em></strong>中找到，在repo <a class="ae mr" href="https://github.com/Riazone/Gold-Return-Prediction/blob/master/Regression/Gold%20Prediction%20Experiment%20%20Regression-%20PyCaret.ipynb" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><h1 id="ef26" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">重要链接</h1><p id="6a53" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><strong class="ll jd"> <em class="mk">链接第三部分— </em> </strong> <a class="ae mr" rel="noopener" target="_blank" href="/predicting-crashes-in-gold-prices-using-machine-learning-5769f548496"> <strong class="ll jd"> <em class="mk">预测金价暴跌</em> </strong> </a></p><p id="d209" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated"><strong class="ll jd"> <em class="mk">链接到</em> </strong> <a class="ae mr" href="https://github.com/Riazone/Gold-Return-Prediction" rel="noopener ugc nofollow" target="_blank"> <strong class="ll jd"> <em class="mk"> Github资源库</em> </strong> </a></p><p id="2971" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated"><strong class="ll jd"> <em class="mk">关注我上</em></strong><a class="ae mr" href="https://www.linkedin.com/in/riazuddin-mohammad/" rel="noopener ugc nofollow" target="_blank"><strong class="ll jd"><em class="mk">LinkedIn</em></strong></a></p><p id="9604" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated"><strong class="ll jd"> <em class="mk">指南</em></strong><a class="ae mr" href="https://pycaret.org/guide/" rel="noopener ugc nofollow" target="_blank"><strong class="ll jd"><em class="mk">py caret</em></strong></a></p></div></div>    
</body>
</html>