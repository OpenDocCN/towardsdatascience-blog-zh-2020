<html>
<head>
<title>Deploying ML Models in Distributed Real-time Data Streaming Applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在分布式实时数据流应用中部署 ML 模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/deploying-ml-models-in-distributed-real-time-data-streaming-applications-217954a0b423?source=collection_archive---------7-----------------------#2020-01-11">https://towardsdatascience.com/deploying-ml-models-in-distributed-real-time-data-streaming-applications-217954a0b423?source=collection_archive---------7-----------------------#2020-01-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2c35" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">探索在 Apache Flink/Spark 或其他实时数据流应用程序中部署 ML 模型的各种策略。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b502e0b24edaa8177046a13fc132e492.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Lw62ttKzZ87B3ckn"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kv" href="https://unsplash.com/@franckinjapan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Franck V. </a>拍摄的照片</p></figure><p id="4fba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">过去十年，机器学习从零到一。ML 的崛起可以被视为科技行业最具决定性的时刻之一。今天，ML 模型在几乎所有的服务中无处不在。</p><p id="83ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">至今仍然存在的挑战之一是使用实时数据对模型进行训练和推断。让我们来看看在数据流生产作业中可以用来进行预测的各种策略。</p><h1 id="b476" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">沿着管道建模</h1><p id="6c9a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">对实时数据进行预测的自然方法是在处理数据的管道中运行 ML 模型。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/82fc484520dfc294c717f6cc65b10322.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*91pmmz85GYMstCMxIPKC_A.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在管道执行器中部署模型</p></figure><p id="4030" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种方法有两个主要的复杂性-</p><ol class=""><li id="13f3" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">管道代码和模型代码的集成。</li><li id="8d75" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">优化集成管道以有效利用底层资源。</li></ol><h2 id="67b0" class="ne lt iq bd lu nf ng dn ly nh ni dp mc lf nj nk me lj nl nm mg ln nn no mi np bi translated">综合</h2><p id="8b27" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">大多数实时数据管道都是用 Java 或 Python 编写的。<a class="ae kv" href="https://spark.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache Spark </a>和<a class="ae kv" href="https://flink.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache Flink </a>都提供 Python API。这使得使用<a class="ae kv" href="https://scikit-learn.org/stable/" rel="noopener ugc nofollow" target="_blank"> Scikit-Learn </a>或<a class="ae kv" href="https://www.tensorflow.org/" rel="noopener ugc nofollow" target="_blank"> Tensorflow </a>编写的模型可以轻松集成。</p><p id="5466" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您也可以使用<a class="ae kv" href="https://spark.apache.org/mllib/" rel="noopener ugc nofollow" target="_blank"> Spark MLlib </a>或<a class="ae kv" href="https://github.com/FlinkML" rel="noopener ugc nofollow" target="_blank"> Flink ML </a>来创建模型。这些模型便于集成，您不必担心可伸缩性和容错性。</p><p id="d3dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是如果你有一个用 Java 或 Scala 编写的预先存在的数据管道呢？在这种情况下，使用 Tensorflow Java API 或第三方库(如<a class="ae kv" href="https://github.com/combust/mleap" rel="noopener ugc nofollow" target="_blank"> MLeap </a>或<a class="ae kv" href="https://github.com/jpmml/jpmml-evaluator" rel="noopener ugc nofollow" target="_blank"> JPMML </a>)来导出您的 Scikit-learn 模型并在您的代码中使用它们更有意义。JPMML 支持很多模型，但是 MLeap 更快。</p><h2 id="cf8e" class="ne lt iq bd lu nf ng dn ly nh ni dp mc lf nj nk me lj nl nm mg ln nn no mi np bi translated">最佳化</h2><p id="b213" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Python 和 Java/Scala 之间的选择代表了通用性和性能之间的权衡。如果您根据用例、预期的数据量和预期的延迟做出决策，那将是最好的。对于大多数应用程序，我更喜欢 Scala，因为预期的输入记录是每秒数百万条。</p><p id="8afa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一个优化是您应该分配给模型的并行执行器的数量。如果是逻辑回归或小型随机森林等轻量级模型，您甚至可以运行模型的单个实例，并将数据重新分区到单个执行器(这在生产中从来都不是一个好主意)。对于大型随机森林或深度神经网络之类的大型模型，找到正确的执行者数量主要是一项反复试验的工作。</p><p id="d4ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可能还需要优化您的 ML 模型，以便它们能够适合内存。有几种工具可用于此目的。</p><div class="nq nr gp gr ns nt"><a href="https://www.tensorflow.org/lite" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd ir gy z fp ny fr fs nz fu fw ip bi translated">TensorFlow Lite</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">TensorFlow Lite 是一个开源的深度学习框架，用于设备上的推理。</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">www.tensorflow.org</p></div></div><div class="oc l"><div class="od l oe of og oc oh kp nt"/></div></div></a></div><p id="aeea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种方法的另一个复杂之处是将模型更新到一个更新的版本。更新通常需要全新的部署。这也使得 A/B 测试相当重要。</p><h1 id="274f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">作为 REST 服务的模型</h1><p id="07cd" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这是最流行的推理方法之一。在 docker 容器中运行 python 代码，并提供一个 REST 接口来获得结果。Tensorflow 已经提供了开箱即用的 REST 模型。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/406285a3fd8e4a36230dae327e7619e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QZuaJQQbhaMErv1B1_-x7Q.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">将 ML 模型部署为服务</p></figure><p id="574d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于 Java，可以使用 MLeap 或者 DeepLearning4J。在这种方法中，您还可以根据吞吐量动态地增加/减少服务器的数量。</p><p id="57b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您的模型调用是异步的，这种方法在数据突发的情况下(比如在重启期间)无法触发背压。这可能会导致模型服务器中的 OOM 故障。必须采取额外的预防措施来防止这种情况。</p><p id="219d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">延迟也很高，因为您需要一个网络调用来获取结果。通过使用<a class="ae kv" href="https://grpc.io/" rel="noopener ugc nofollow" target="_blank"> gRPC </a>代替 REST，可以稍微减少延迟。</p><div class="nq nr gp gr ns nt"><a href="https://codeburst.io/heres-how-you-can-go-beyond-http-1-1-59e73f68bf75" rel="noopener follow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd ir gy z fp ny fr fs nz fu fw ip bi translated">以下是超越 Http 1.1 的方法</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">实现自己的 http/2 服务。</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">codeburst.io</p></div></div><div class="oc l"><div class="oj l oe of og oc oh kp nt"/></div></div></a></div><h1 id="aa58" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">数据库作为模型存储</h1><p id="b572" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如果您有固定的模型架构，例如线性回归、随机森林或小型神经网络，权重可以存储在分布式数据库中，如 Cassandra。您可以在运行时使用权重创建模型，并对新模型进行预测。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/34b86064b6fa4e56fb0553c5f3771ff2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6dQ664fVvw38WQvf1bQX6g.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">将模型存储在数据库中</p></figure><p id="6895" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种方法是第一种和第二种方法的混合。它允许您在运行时更新模型，而不需要新的部署，同时还提供了背压功能。这是以多功能性为代价的，因为您限制了模型的潜在选项的数量。</p><h2 id="4b8e" class="ne lt iq bd lu nf ng dn ly nh ni dp mc lf nj nk me lj nl nm mg ln nn no mi np bi translated">那么应该选择哪种方法呢？</h2><p id="5f92" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">好吧，如果你想做一个简单的 POC 或者你的模型非常轻量级，就用 REST 模型服务器。运行您的模型所需的易于集成和非常少的代码更改使它成为一个有吸引力的选择。A/B 测试也可以快速完成。</p><p id="006f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您需要在几十毫秒内进行预测，流水线方法是首选。</p><p id="954d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，模型存储方法应该只在有几个模型的情况下使用，例如，每个城市数据有一个 ML 模型，并且它们也是轻量级的。</p></div></div>    
</body>
</html>