<html>
<head>
<title>A developer’s guide to understand the basics of database scaling</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解数据库伸缩基础的开发人员指南</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-developers-guide-to-understanding-the-basics-of-database-scaling-37c8fef94c11?source=collection_archive---------42-----------------------#2020-07-24">https://towardsdatascience.com/a-developers-guide-to-understanding-the-basics-of-database-scaling-37c8fef94c11?source=collection_archive---------42-----------------------#2020-07-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="97a5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何扩展数据库以承受传入的流量，以及如何降低其潜在性并提高其性能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a44ab065133cb7cdbd88a0b4bfa23195.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9qc9K1789ey4RPKi"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">菲德尔·费尔南多在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="8840" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们有一个服务，用一个数据库服务器处理每月几千个请求，这个服务器处理来自应用服务器的所有读/写请求。</p><p id="d161" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止，一切都运行良好，但是随着时间的推移，您开始观察到传入流量的峰值，即使尝试了以下方法，您也无法减少<strong class="lb iu">延迟</strong>和<strong class="lb iu">数据库故障</strong>:</p><ul class=""><li id="539b" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">拥有一个拥有大量内存和高性能闪存的数据库。</li><li id="0c1c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">实现了最佳缓存以减少延迟。</li><li id="768c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">对数据库查询进行适当的索引和优化。</li></ul><p id="08c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，现在您需要<strong class="lb iu">解决您的数据库基础设施</strong>，以便它能够承受传入的流量。</p><p id="5366" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看数据库<strong class="lb iu">分片</strong>和<strong class="lb iu">复制</strong>如何提供一个高度可靠和高性能的数据库系统，能够承受数百万的规模。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="c00d" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">分身术</h1><p id="5b5d" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">数据复制是将相同的数据存储在多个数据库服务器上的过程，可减少延迟、提高读取可伸缩性、简化数据恢复和提高数据可用性。</p><p id="540a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，数据副本存储在单独的硬件组件中，因为如果该硬件崩溃，您不希望副本崩溃。</p><p id="c0c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最常用的复制策略是<strong class="lb iu">单领导者复制。</strong></p><h2 id="8a0a" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated">单头复制</h2><p id="7786" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在这种复制中，有一个主节点负责所有写入，并处理所有其他节点上的数据复制。<br/>领导节点通常称为主节点，其他从属节点称为从节点。</p><p id="f201" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">读取和写入仅在主服务器上启用，从服务器只能处理读取查询。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/c020958fd21a0b994b355e8697409e8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/format:webp/1*VZ1z3jUgBXY-FTooGD760w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="oa">作者图片— </em>单头主从复制</p></figure><p id="c293" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，要更新从属服务器上的数据，我们可以选择同步复制或 T21 异步复制。这两者各有利弊。</p><p id="4026" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 1。同步复制:</strong>一旦收到确认，它就完成写入并通知客户端。</p><p id="5d82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="ob">同步复制的好处</em> </strong></p><ul class=""><li id="42e8" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">它通过确保所有节点都拥有更新的数据来提供数据一致性，因为所有从节点都与主节点同步。</li><li id="096a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">如果主节点出现故障，任何从节点都可以轻松成为主节点，而不会丢失任何数据。</li></ul><p id="807c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="ob">同步复制的缺点</em> </strong></p><ul class=""><li id="f628" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">有时，当主设备等待来自所有从设备的确认时，系统可能是高度潜伏的。</li><li id="0c60" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">如果任何从属服务器不可用或出现故障，则主服务器会阻止所有写入，直到同步副本再次可用。因此导致较低的可用性。</li></ul><p id="c19f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 2。异步复制:<br/></strong></p><p id="0b33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，即使所有从节点都出现故障，主节点也可以继续进行写入。</p><p id="f068" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="ob">异步复制的好处</em> </strong></p><ul class=""><li id="c5fe" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">它提供了低延迟，因为主设备不等待从设备上的数据更新。</li><li id="8f0f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">更高的可用性，因为即使任何从节点发生故障，也不会影响主节点。</li></ul><p id="4991" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="ob">异步复制的缺点</em> </strong></p><ul class=""><li id="6da1" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">由于<strong class="lb iu">复制滞后</strong>，可能导致数据不一致。即主设备到从设备的数据复制可能需要很长时间。<br/>因此，如果在主服务器和从服务器上运行相同的查询(并发执行)，可能会得到不同的结果。</li><li id="5418" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">如果异步系统中的主节点发生故障，新指定的主节点可能无法完成前一个主节点的所有写操作。如果先前的主设备重新联机并成为从设备，它将具有冲突的写入。</li></ul><p id="d1f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，对数据库的<strong class="lb iu">读取规模</strong>可以通过复制来实现。<br/>但是怎么加一个<strong class="lb iu">写尺度</strong>？答案是<strong class="lb iu">分片</strong>。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="4f64" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">分片</h1><p id="8829" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">比方说，你有一个比萨饼，你不能一个人吃整个，所以你把它切成片，然后打电话给你的朋友。</p><p id="23a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，这些朋友中的每一个都将得到一片比萨饼。你所做的是根据每个朋友的份额有效地划分比萨饼，就像我们可以有多个数据库服务器，它们将承担发送到它的请求的负载。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/e238dd2dd6eaac561df21049a330d802.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ksKZsf1Eq1LvxPQO"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@mahyarmotebassem?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> mahyar motebassem </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="d92e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，从技术上讲，我们将在分片中将完整的数据库负载分配给 N 个数据库服务器。</p><p id="c8ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个传入请求的子集将由一个单独的服务器提供服务。现在，每个分区都位于完全不同的物理机器上，并受具有相同数据库模式的独立数据库实例的控制。</p><p id="b944" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这被称为<strong class="lb iu">分片</strong>。它也可以称为水平分区，因为分片基本上是跨不同物理机器/节点的水平分区。</p><p id="e570" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">分片提供了更高的可用性，减少了读/写数据库延迟，并且可以高效地处理高数据库负载。</strong></p><p id="d792" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在为数据库启用分片时，需要考虑多种因素。需要考虑的两个主要问题如下:</p><h2 id="f21e" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated"><strong class="ak">碎片键:</strong></h2><p id="8651" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我们需要一些标识符来决定一个特定的请求应该从哪个数据库服务器得到服务。也就是说，应该有一个键，我们应该根据这个键来决定一个请求应该放在哪个碎片上。我们称之为<strong class="lb iu">碎片密钥</strong>或<strong class="lb iu">分区密钥</strong>。<br/>一般我们选择表格的任意一列作为<strong class="lb iu"> shard_key </strong>。</p><h2 id="3803" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated"><strong class="ak">哈希函数</strong>:</h2><p id="c120" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">哈希是使用<strong class="lb iu">数学函数将任意长度的输入转换成固定大小的文本字符串的过程。<br/> </strong>这意味着任何文本无论多长都可以转换成数字和字母的数组。</p><p id="405d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个用于生成散列值的数学函数<strong class="lb iu">被称为<strong class="lb iu">散列函数</strong>。</strong></p><p id="05c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们使用散列函数计算 shard_key 的散列值，然后将该散列值映射到 DB 服务器。</p><p id="3827" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下图中，<strong class="lb iu">散列函数</strong>将 shard_key (row-id)作为输入，并返回一个值，通过这个值我们可以确定它应该进入哪个 shard。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/23791d9e7067b88219282dfd3c0fe299.png" data-original-src="https://miro.medium.com/v2/resize:fit:1322/format:webp/1*ljDh14Yq-QMNfUva0xtTXg.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="oa">作者提供的图片- </em>带有 4 个碎片集群的数据库碎片</p></figure><p id="b2fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，<strong class="lb iu"> NoSQL </strong>像 Mongo DB 这样的数据库为分片提供了一个内置的标准实现。<br/>更多在数据库级别提供分片的数据库是 Cassandra、Hadoop 和 Apache H-Base e.t.c。</p><p id="06ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而在 MySQL 这样的关系数据库中，没有分片的标准实现。因此，通常的做法是让<strong class="lb iu">应用程序级分片</strong>用于关系数据库。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="06d0" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">由于分片可能产生的问题</h1><h2 id="3bfe" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated">1.数据的重新分布:</h2><p id="308b" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">如果在一个数据库集群中，一个数据库服务器出现故障，或者您正在向集群添加一个新的数据库碎片，那么您可能需要重新分发或重新散列数据。</p><p id="1230" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种开销直接依赖于我们用来在不同碎片之间分发数据的散列函数。</p><p id="185c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果散列函数是一个简单的取模函数，它采用<strong class="lb iu">行 id </strong>的<strong class="lb iu">取模</strong>和<strong class="lb iu">个碎片</strong>来决定请求应该到达的碎片，那么在这种情况下，它将导致数据的完全重新散列，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/ae82211765ecc93cda48d68b30a0c345.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*wzkEvxj127eT3US-1t7gZQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="oa">作者提供的图片- </em> <strong class="bd of">在添加服务器的情况下重新散列数据</strong></p></figure><p id="a0e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ob">在上图中，我们可以看到 4 个碎片的数据映射基于 id 模 4(碎片数)</em></p><p id="2def" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">12%4 -&gt;第 0 分片<br/> 29%4 - &gt;第 1 分片<br/> 27%4 - &gt;第 3 分片</p><p id="c375" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ob">对于 5 个分片，数据映射基于 id 模 5(分片数)</em></p><p id="9087" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">12%5 -&gt;第二碎片<br/> 29%5 - &gt;第四碎片<br/> 27%5 - &gt;第二碎片</p><p id="35ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们在这里观察到，当我们向现有的<strong class="lb iu"> four shard 集群</strong>添加一个 DB shard 时，所有的行都需要重新映射。</p><p id="01ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种<strong class="lb iu">重新分配</strong>通常需要系统停机，这对您的系统来说是有风险的。</p><h2 id="5e83" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated">如何避免:</h2><ul class=""><li id="97ad" class="lv lw it lb b lc ni lf nj li og lm oh lq oi lu ma mb mc md bi translated">为了避免这种情况，我们可以使用一种特殊的散列技术，名为<a class="ae ky" href="https://en.wikipedia.org/wiki/Consistent_hashing" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> <em class="ob">一致散列</em> </strong> </a>，它通常只需要重新映射<code class="fe oj ok ol om b">k/N</code>个键，其中<code class="fe oj ok ol om b">k</code>是键的数量，<code class="fe oj ok ol om b">N</code>是数据库服务器的数量(更具体地说，是服务器的初始和最终数量的最大值)。</li></ul><h2 id="61f5" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated">2.数据非规范化(关系数据库)</h2><p id="bcdc" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">对于单个数据库服务器，需要连接的查询可以很容易地完成，但是我们知道在分布式架构中，数据跨越多个区域。因此，驻留在多个区域上的表的连接将需要大量的处理，并且是相当潜在的。</p><p id="26bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，您可能需要进行数据反规范化，以尽可能避免连接。</p><h2 id="ab99" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated">如何避免:</h2><ul class=""><li id="c3cf" class="lv lw it lb b lc ni lf nj li og lm oh lq oi lu ma mb mc md bi translated">你也可以去 NoSQL 数据库的情况下，你想避免这一点。但是在某些情况下，你可能对关系数据库有一个确切的需求。</li><li id="6acc" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">共享连接:<br/> </strong>一般来说，为了避免关系数据库中的连接，我们尝试将同一碎片中的行的 FK 映射放在不同的表中。因此，所有需要连接的行都位于同一个片上。</li></ul><p id="02f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了实现这一点，我们选择可以连接的列作为<strong class="lb iu"> shard_key </strong>。因此，不同表中具有相同的<strong class="lb iu"> shard_key </strong>列值的行将位于同一个 shard 中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/6934ef5c45c0a525e83412309f0fcd6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sQmqi3cJEH0pq68OZGSX0w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="oa">作者图片——共享加入</em></p></figure><p id="4609" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面医院数据库的例子中，我们选择<strong class="lb iu"> patient-id </strong>作为分片键。<br/>因此，具有相同<strong class="lb iu">患者 id </strong>的不同表格的所有条目将位于相同的碎片中。</p><h2 id="600a" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated">3.热点关键问题</h2><p id="39bc" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">对同一分片中的一个或多个特定键的过度访问会导致节点耗尽。</p><p id="a9c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，大部分请求由一小部分碎片提供服务，而其他碎片在大部分时间保持理想状态。这可能会导致节点故障或过载，从而导致延迟和故障激增。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/cd22ea9cc685a157bba0d65c8610b861.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*an4gunTcnSeHsHNg0EBtHQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="oa">作者图片- </em> <strong class="bd of">大多数请求由 shard-1 </strong>提供服务</p></figure><p id="2543" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上图中，我们可以看到大多数请求由<strong class="lb iu"> shard-1 </strong>提供服务，因此负载很重。而<strong class="lb iu">碎片-2 </strong>和<strong class="lb iu">碎片-3 </strong>几乎是理想的。</p><p id="5175" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可能导致 shard-1 所服务的所有请求的延迟和失败增加。</p><p id="ef5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个真实的例子是，假设脸书选择<strong class="lb iu">用户名</strong>作为其用户表的<strong class="lb iu">碎片键</strong>。所有访问量最大的个人资料，如克里斯蒂亚诺·罗纳尔多的<br/> <strong class="lb iu">、Lady Gaga 的</strong>和贾斯汀比伯的最终都在同一个碎片中。那么与其他碎片相比，该特定碎片将是请求的热点。</p><h2 id="8560" class="nn mr it bd ms no np dn mw nq nr dp na li ns nt nc lm nu nv ne lq nw nx ng ny bi translated">如何避免:</h2><ul class=""><li id="0782" class="lv lw it lb b lc ni lf nj li og lm oh lq oi lu ma mb mc md bi translated">为了避免这种情况，我们需要选择碎片键和散列函数，使得整个应用程序负载几乎平均分布在所有数据库碎片中。</li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="293e" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">结论</h1><p id="4760" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">分片是以一种巧妙的方式抵御传入流量的绝佳方式。但是你需要确定什么时候是分片的确切需求，因为你可以看到数据分区和分片会带来很多额外的复杂性。</p><p id="76ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，在决定共享数据库之前，您应该考虑其他选项来提高数据库的性能，比如索引或缓存。</p><p id="0999" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果您仍然决定设计一个分布式数据库系统，那么您还必须考虑其他的权衡。</p><p id="e7ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。编码快乐！</p></div></div>    
</body>
</html>