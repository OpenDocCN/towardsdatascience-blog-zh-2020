<html>
<head>
<title>Scaling Machine Learning from ZERO to HERO</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从零到英雄的机器学习</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/scaling-machine-learning-from-zero-to-hero-d63796442526?source=collection_archive---------42-----------------------#2020-05-07">https://towardsdatascience.com/scaling-machine-learning-from-zero-to-hero-d63796442526?source=collection_archive---------42-----------------------#2020-05-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="41d1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过使用AWS Lambda、无服务器框架和PyTorch来扩展您的机器学习模型。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/520ac5baa6aad7e66ff17ed5c89db1da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*apcNkD1X4MqjP_Q2GBqpEA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">凯尔·格伦在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="a13b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">原载于2020年5月8日</em><a class="ae ky" href="https://www.philschmid.de/scaling-machine-learning-from-zero-to-hero" rel="noopener ugc nofollow" target="_blank"><em class="lv">https://www . philschmid . de</em></a><em class="lv">。</em></p><h1 id="1399" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">介绍</h1><p id="cebf" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">构建机器学习模型的工作流程往往在评估阶段就结束了:你已经达到了一个可以接受的准确度，你可以在你的“研究环境”和“哒哒！任务完成。”但这还不是全部！机器学习工作流程中最后也是最重要的一步是<strong class="lb iu">部署</strong>你的模型用于生产。</p><blockquote class="mt mu mv"><p id="157f" class="kz la lv lb b lc ld ju le lf lg jx lh mw lj lk ll mx ln lo lp my lr ls lt lu im bi translated"><em class="it">在生产中不工作的模型是没有价值的</em></p></blockquote><p id="dd1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">部署的模型可以定义为无缝集成到生产环境中的任何单元，它可以接收输入并返回输出。但公司面临的机器学习的主要问题之一是找到一种方法在这样的环境中部署这些模型。</p><blockquote class="mt mu mv"><p id="1531" class="kz la lv lb b lc ld ju le lf lg jx lh mw lj lk ll mx ln lo lp my lr ls lt lu im bi translated"><a class="ae ky" href="https://medium.com/vsinghbisen/these-are-the-reasons-why-more-than-95-ai-and-ml-projects-fail-cd97f4484ecc" rel="noopener"> <em class="it">据报道，大约40%的失败项目停滞在开发阶段，没有投入生产</em> </a> <em class="it">。</em> <a class="ae ky" href="https://medium.com/vsinghbisen/these-are-the-reasons-why-more-than-95-ai-and-ml-projects-fail-cd97f4484ecc" rel="noopener"> <strong class="lb iu"> <em class="it">来源</em> </strong> </a></p></blockquote><p id="89b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将一步步向您展示如何使用AWS Lambda部署您自己定制的Pytorch模型，并使用API将其集成到您的生产环境中。我们将大规模利用简化的无服务器计算方法。</p><h2 id="ffeb" class="mz lx it bd ly na nb dn mc nc nd dp mg li ne nf mi lm ng nh mk lq ni nj mm nk bi translated">什么是AWS Lambda？</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/9fac40b039a172c9433ec56b8986f759.png" data-original-src="https://miro.medium.com/v2/resize:fit:382/format:webp/1*wtvYRZg_iZmpjOhCZeUhAw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://aws.amazon.com/de/lambda/features/" rel="noopener ugc nofollow" target="_blank"> AWS Lambda特性</a></p></figure><p id="524c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">AWS Lambda 是一种计算服务，让你无需管理服务器就能运行代码。它只在需要的时候执行你的代码，并且自动伸缩，从每天几个请求到每秒几千个请求。您只需为您消耗的计算时间付费，当您的代码不运行时，则不收费。</p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h1 id="1c71" class="lw lx it bd ly lz nt mb mc md nu mf mg jz nv ka mi kc nw kd mk kf nx kg mm mn bi translated">要求</h1><p id="1e8f" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">本文假设您已经安装并配置了用于部署AWS Lambda功能的<a class="ae ky" href="https://serverless.com/" rel="noopener ugc nofollow" target="_blank">无服务器框架</a>，以及一个工作Docker环境。无服务器框架帮助我们开发和部署AWS Lambda功能。它是一个CLI，开箱即可提供结构、自动化和最佳实践。它还允许您专注于构建复杂的、事件驱动的、无服务器的架构，由函数和事件组成。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/2eee2af0b4ee8744b1dbd824a147bcf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*GKqBWVzXAVsWk337pINN2g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">无服务器框架徽标</p></figure><p id="041e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你不熟悉或者还没有设置无服务器框架，看看这个<a class="ae ky" href="https://serverless.com/framework/docs/providers/aws/guide/quick-start/" rel="noopener ugc nofollow" target="_blank">无服务器框架快速入门</a>。</p><p id="92fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过修改无服务器的YAML文件，你可以连接SQS，比如说，创建一个深度学习管道，或者甚至通过AWS Lex将其连接到聊天机器人。</p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h1 id="5f59" class="lw lx it bd ly lz nt mb mc md nu mf mg jz nv ka mi kc nw kd mk kf nx kg mm mn bi translated">辅导的</h1><p id="ba77" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在我们开始之前，我想给你一些关于我们将要使用的模型的信息。我在google colab 中训练了一个Pytorch图像分类器。如果你想知道Google Colab是什么，看看这里的<a class="ae ky" href="https://colab.research.google.com/drive/1Ehy2Tfadj4XASpMDMuNTqHZsXHtDvTmf#scrollTo=Rp7DFKE18vHI" rel="noopener ugc nofollow" target="_blank"/>。我为分类<a class="ae ky" href="https://www.kaggle.com/philschmid/car-damage-image-classifier" rel="noopener ugc nofollow" target="_blank">汽车损坏检测</a>创建了一个数据集，并微调了一个resnet50图像分类器。在本教程中，我们将使用<code class="fe nz oa ob oc b">Python3.8</code>和<code class="fe nz oa ob oc b">Pytorch1.5</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/2e3f24c9503b336c3b54b6a6ca02c311.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*yIdCAEbxTAl2FQCSik69Pg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">数据集中的示例图像</p></figure><p id="d89c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们要做什么:</p><ul class=""><li id="956e" class="oe of it lb b lc ld lf lg li og lm oh lq oi lu oj ok ol om bi translated">使用无服务器框架创建Python Lambda函数</li><li id="4956" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated">将Pytorch添加到Lambda环境</li><li id="46ff" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated">写一个预测函数来分类图像</li><li id="ee2b" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated">创建一个S3存储桶，用于保存模型和上传模型的脚本</li><li id="6d0c" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated">配置无服务器框架以设置API网关进行推理</li></ul><p id="af2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们正在构建的架构将会是这样的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/442a02d9622945ed1bd702b349f034d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O6b9t0Zue_s57IGAbc4lzw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">项目的架构</p></figure><p id="ef21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们开始学习教程。</p><h1 id="48ff" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">创建AWS Lambda函数</h1><p id="fa1b" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">首先，我们通过使用带有<code class="fe nz oa ob oc b">aws-python3</code>模板的无服务器CLI创建AWS Lambda函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="ac01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个CLI命令将创建一个包含<code class="fe nz oa ob oc b">handler.py</code>、<code class="fe nz oa ob oc b">.gitignore</code>和<code class="fe nz oa ob oc b">serverless.yaml</code>文件的新目录。<code class="fe nz oa ob oc b">handler.py</code>包含一些基本的样板代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h1 id="9431" class="lw lx it bd ly lz nt mb mc md nu mf mg jz nv ka mi kc nw kd mk kf nx kg mm mn bi translated">添加Python需求</h1><p id="a512" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">接下来，我们将Python需求添加到AWS Lambda函数中。为此，我们使用无服务器插件<code class="fe nz oa ob oc b">serverless-python-requirements</code>。它自动捆绑来自<code class="fe nz oa ob oc b">requirements.txt</code>的依赖项，并使它们可用。<code class="fe nz oa ob oc b">serverless-python-requirements</code>插件允许你捆绑非纯Python模块。更多关于<a class="ae ky" href="https://github.com/UnitedIncome/serverless-python-requirements#readme" rel="noopener ugc nofollow" target="_blank">的信息，请点击这里</a>。</p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h2 id="d39b" class="mz lx it bd ly na nb dn mc nc nd dp mg li ne nf mi lm ng nh mk lq ni nj mm nk bi translated">安装插件</h2><p id="6823" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">要安装插件，请运行以下命令。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="e344" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将自动把插件添加到你的项目的<code class="fe nz oa ob oc b">package.json</code>和<code class="fe nz oa ob oc b">serverless.yml</code>中的插件部分。</p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h2 id="7faf" class="mz lx it bd ly na nb dn mc nc nd dp mg li ne nf mi lm ng nh mk lq ni nj mm nk bi translated">向<code class="fe nz oa ob oc b">requirements.txt</code>添加要求</h2><p id="96b3" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我们必须在根级别创建一个<code class="fe nz oa ob oc b">requirements.txt</code>文件，包含所有需要的Python包。但是您必须小心，解压缩后的部署包大小不能超过250MB。你可以在这里找到所有AWS Lambda限制的列表<a class="ae ky" href="https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-limits.html" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="fb04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们用<code class="fe nz oa ob oc b">pip install torch</code>安装Pytorch，这个包大约有470 MB，这对于部署在AWS Lambda环境中来说太大了。因此，我们在<code class="fe nz oa ob oc b">requirements.txt</code>中直接添加到python wheel文件(<code class="fe nz oa ob oc b">.whl</code>)的链接。所有PyTorch和torchvision包的列表请参考此列表。</p><p id="b7f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nz oa ob oc b">requirements.txt</code>应该是这样的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="58fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了使依赖性更小，我们将在<code class="fe nz oa ob oc b">serverless-python-requirements</code>插件中使用三种技术:</p><ul class=""><li id="483e" class="oe of it lb b lc ld lf lg li og lm oh lq oi lu oj ok ol om bi translated"><code class="fe nz oa ob oc b">zip</code> -将<code class="fe nz oa ob oc b">requirements.txt</code>中的依赖项压缩到一个附加的<code class="fe nz oa ob oc b">.requirements.zip</code>文件中，并将<code class="fe nz oa ob oc b">unzip_requirements.py</code>添加到最终的包中。</li><li id="3a72" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated"><code class="fe nz oa ob oc b">slim</code> -删除不需要的文件和目录，如<code class="fe nz oa ob oc b">*.so</code>、<code class="fe nz oa ob oc b">*.pyc</code>、<code class="fe nz oa ob oc b">dist-info</code>等。</li><li id="a8bb" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated"><code class="fe nz oa ob oc b">noDeploy</code> -从部署中省略某些包。我们将使用标准列表，排除那些已经内置到Lambda中的包，以及Tensorboard。</li></ul><p id="877a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在“配置我们的<code class="fe nz oa ob oc b">serverless.yaml</code>文件”部分看到它的实现。</p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h1 id="585f" class="lw lx it bd ly lz nt mb mc md nu mf mg jz nv ka mi kc nw kd mk kf nx kg mm mn bi translated">预测功能</h1><p id="4716" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我们的Lambda函数实际上由4个函数组成。</p><ul class=""><li id="61de" class="oe of it lb b lc ld lf lg li og lm oh lq oi lu oj ok ol om bi translated"><code class="fe nz oa ob oc b">load_model_from_s3()</code>用于将我们的模型从S3加载到内存中，创建我们的PyTorch模型和一个名为<code class="fe nz oa ob oc b">classes</code>的列表，它包含可预测的类。</li><li id="26cd" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated"><code class="fe nz oa ob oc b">transform_image()</code>用于将输入图片转换成PyTorch张量。</li><li id="9440" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated"><code class="fe nz oa ob oc b">get_prediction()</code>，使用变换后的图像作为输入来获得预测。</li><li id="21ef" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated"><code class="fe nz oa ob oc b">detect_damage()</code>是我们Lambda环境的主要功能。</li></ul><h2 id="62ac" class="mz lx it bd ly na nb dn mc nc nd dp mg li ne nf mi lm ng nh mk lq ni nj mm nk bi translated">伪代码</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="e8b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">工作程序代码看起来像这样。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h1 id="b240" class="lw lx it bd ly lz nt mb mc md nu mf mg jz nv ka mi kc nw kd mk kf nx kg mm mn bi translated">将训练好的模型添加到我们的项目</h1><p id="6cb4" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">如前所述，我在<a class="ae ky" href="https://colab.research.google.com/drive/1Ehy2Tfadj4XASpMDMuNTqHZsXHtDvTmf#scrollTo=Rp7DFKE18vHI" rel="noopener ugc nofollow" target="_blank"> colab笔记本</a>中训练了一个汽车损坏检测模型，它以一幅图像作为输入，并返回所描绘的汽车是<code class="fe nz oa ob oc b">01-whole</code>还是<code class="fe nz oa ob oc b">00-damaged</code>。我还添加了一些代码，为您完成所有的捆绑魔术:如果您运行笔记本，它将创建一个名为<code class="fe nz oa ob oc b">cardamage.tar.gz</code>的文件，准备部署在AWS上。记住，Lambda函数解压缩后的大小只能是250MB。因此，我们不能将我们的模型直接包含到函数中。相反，我们需要用<code class="fe nz oa ob oc b">load_model_from_s3()</code>从S3下载它。</p><p id="ae4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们需要一个S3桶。您可以使用管理控制台或此脚本创建一个。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="0869" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们创建桶之后，我们可以上传我们的模型。您可以手动或使用提供的python脚本来完成。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h1 id="5792" class="lw lx it bd ly lz nt mb mc md nu mf mg jz nv ka mi kc nw kd mk kf nx kg mm mn bi translated">配置<code class="fe nz oa ob oc b">serverless.yaml</code></h1><p id="e1b5" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">下一步是调整<code class="fe nz oa ob oc b">serverless.yaml</code>并包括<code class="fe nz oa ob oc b">custom</code> Python需求配置。我们将编辑<code class="fe nz oa ob oc b">serverless.yaml</code>的四个部分，...</p><ul class=""><li id="b987" class="oe of it lb b lc ld lf lg li og lm oh lq oi lu oj ok ol om bi translated">保存我们的运行时和IAM权限的<code class="fe nz oa ob oc b">provider</code>部分。</li><li id="97cd" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated">我们配置<code class="fe nz oa ob oc b">serverless-python-requirements</code>插件的<code class="fe nz oa ob oc b">custom</code>部分。</li><li id="3cef" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated">在<code class="fe nz oa ob oc b">package</code>部分，我们将文件夹排除在生产之外。</li><li id="2eb4" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated">在<code class="fe nz oa ob oc b">function</code>部分，我们创建函数并定义调用Lambda函数的事件。</li></ul><p id="aa8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看一下完整的<code class="fe nz oa ob oc b">serverless.yaml</code>。不要担心，我将在一分钟内详细解释所有四个部分。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><h2 id="7807" class="mz lx it bd ly na nb dn mc nc nd dp mg li ne nf mi lm ng nh mk lq ni nj mm nk bi translated">供应者</h2><p id="6e6d" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在无服务器框架中，我们在<code class="fe nz oa ob oc b">provider</code>部分定义我们的功能部署在哪里。我们使用<code class="fe nz oa ob oc b">aws</code>作为我们的提供商，其他选项包括<code class="fe nz oa ob oc b">google</code>、<code class="fe nz oa ob oc b">azure</code>等等。您可以在此找到完整的提供商列表<a class="ae ky" href="https://www.serverless.com/framework/docs/providers/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="58ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们定义我们的运行时、环境变量和Lambda函数拥有的权限。</p><p id="a8fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为运行时，我们使用<code class="fe nz oa ob oc b">python3.8</code>。为了让我们的函数工作，我们需要两个环境变量<code class="fe nz oa ob oc b">S3_BUCKET</code>和<code class="fe nz oa ob oc b">MODEL_PATH</code>。<code class="fe nz oa ob oc b">S3_BUCKET</code>包含我们之前创建的S3存储桶的名称。<code class="fe nz oa ob oc b">MODEL_PATH</code>是我们的<code class="fe nz oa ob oc b">cardamage.tar.gz</code>文件在S3桶中的路径。我们仍然缺少将模型从S3导入lambda函数的权限。<code class="fe nz oa ob oc b">iamRoleStatements</code>处理我们的lambda函数的权限。我们从S3获取模型所需的许可是<code class="fe nz oa ob oc b">s3:getObject</code>，将我们的S3桶的ARN ( <a class="ae ky" href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html" rel="noopener ugc nofollow" target="_blank">亚马逊资源名</a>)作为资源。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><h2 id="2619" class="mz lx it bd ly na nb dn mc nc nd dp mg li ne nf mi lm ng nh mk lq ni nj mm nk bi translated">习俗</h2><p id="be81" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在<code class="fe nz oa ob oc b">serverless.yml</code>的<code class="fe nz oa ob oc b">custom</code>部分，我们可以定义插件或其他脚本的配置。更多详情，请参考本<a class="ae ky" href="https://www.serverless.com/framework/docs/providers/aws/guide/variables/" rel="noopener ugc nofollow" target="_blank">指南</a>。如前所述，我们使用<code class="fe nz oa ob oc b">serverless-python-requirements</code>来同时安装和减少依赖项的大小，这样我们就可以将所有东西打包到Lambda运行时中。如果你想知道它是如何工作的，你可以在这里阅读<a class="ae ky" href="https://www.npmjs.com/package/serverless-python-requirements" rel="noopener ugc nofollow" target="_blank"/>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><h2 id="1a11" class="mz lx it bd ly na nb dn mc nc nd dp mg li ne nf mi lm ng nh mk lq ni nj mm nk bi translated">包裹</h2><p id="e571" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated"><code class="fe nz oa ob oc b">package</code>部分可用于从最终包中排除目录/文件夹。这为包装过程提供了更多的控制。你可以<code class="fe nz oa ob oc b">exclude</code>特定的文件夹和文件，比如<code class="fe nz oa ob oc b">node_modules/</code>。更多细节请看这里。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><h2 id="83a3" class="mz lx it bd ly na nb dn mc nc nd dp mg li ne nf mi lm ng nh mk lq ni nj mm nk bi translated">功能</h2><p id="8780" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">第四个也是最后一个部分——<code class="fe nz oa ob oc b">function</code>——包含了Lambda函数的配置。我们在这里定义分配的内存大小、超时和<code class="fe nz oa ob oc b">events</code>。在<code class="fe nz oa ob oc b">function</code>的<code class="fe nz oa ob oc b">events</code>部分，我们可以定义一些事件，这些事件将触发我们的lambda函数。对于我们的项目，我们使用<code class="fe nz oa ob oc b">http</code>，它将自动创建一个指向我们函数的API网关。您还可以为<code class="fe nz oa ob oc b">sqs</code>、<code class="fe nz oa ob oc b">cron</code>、<code class="fe nz oa ob oc b">s3</code>等定义事件。你可以在这里找到完整的列表<a class="ae ky" href="https://www.serverless.com/framework/docs/providers/aws/guide/events/" rel="noopener ugc nofollow" target="_blank"/>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><h1 id="47d8" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">部署功能</h1><p id="fafe" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">为了部署该功能，我们在<code class="fe nz oa ob oc b">package.json</code>中创建一个<code class="fe nz oa ob oc b">deploy</code>脚本。要部署我们的功能，我们需要启动并运行docker。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="7621" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后，我们可以运行<code class="fe nz oa ob oc b">yarn deploy</code>或<code class="fe nz oa ob oc b">npm run deploy</code>来部署我们的功能。这可能需要一段时间，因为我们正在用docker创建一个Python环境，并在其中安装我们所有的依赖项，然后将所有内容上传到AWS。</p><p id="e6d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个过程完成后，我们应该看到类似这样的东西。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/061af6feea84fddde5bd335110a1d95c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vo53iDNpVUMdWz1b1mODgw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">部署的lambda函数</p></figure><h1 id="0a56" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">测试和结果</h1><p id="c6be" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">为了测试我们的lambda函数，我们可以使用失眠症、邮差或任何其他rest客户端。只需在请求中添加一张受损或整辆汽车的图片作为多部分输入。让我们用这张图片试试。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/4333c3471fad30fdc32031645c39960e.png" data-original-src="https://miro.medium.com/v2/resize:fit:554/format:webp/1*oZFwhrPrlrjwyyqDXsMs3A.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">测试图像</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/8713bc5b80ab5657309371b96eb671df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6eehqbSB6KZIsAOPQ1Lbug.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">失眠请求</p></figure><p id="95e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为我们对红色汽车测试的结果，我们得到了<code class="fe nz oa ob oc b">01-whole</code>，这是正确的。此外，您可以看到完整的请求花费了319毫秒，而lambda执行时间大约为250毫秒。老实说，这相当快。</p><p id="aa81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您打算重新构建分类器，您必须小心，第一个请求可能需要一段时间。首先，Lambda正在解压和安装我们的依赖项，然后从S3下载模型。完成一次后，lambda需要大约250毫秒-1000毫秒，这取决于分类的输入图像大小。</p><p id="5faa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">最棒的是，如果有几个传入请求，我们的分类器会自动扩展！</strong></p><p id="a221" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以毫无顾虑地扩展到数千个并行请求。</p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><p id="c7c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。你可以在这里找到GitHub库的完整代码<a class="ae ky" href="https://github.com/philschmid/scale-machine-learning-w-pytorch" rel="noopener ugc nofollow" target="_blank"/>，在这里找到colab笔记本<a class="ae ky" href="https://colab.research.google.com/drive/1Ehy2Tfadj4XASpMDMuNTqHZsXHtDvTmf#scrollTo=vV9cHcwN0MXw" rel="noopener ugc nofollow" target="_blank"/>。如果你有任何问题，随时联系我。</p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><p id="34be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="oy oz ep" href="https://medium.com/u/33e6e3b8da22?source=post_page-----d63796442526--------------------------------" rel="noopener" target="_blank"> <em class="lv"> Lance Miles </em> </a> <em class="lv">提到，您可能必须在API网关的设置中包含“多部分/表单数据”作为二进制媒体类型，以便网关能够以base64编码通过失眠症发送的图像。</em></p></div></div>    
</body>
</html>