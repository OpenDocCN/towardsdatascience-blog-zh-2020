<html>
<head>
<title>Building a Dynamic data pipeline with Databricks and Azure Data Factory</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Databricks 和 Azure 数据工厂构建动态数据管道</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-a-dynamic-data-pipeline-with-databricks-and-azure-data-factory-5460ce423df5?source=collection_archive---------10-----------------------#2020-01-06">https://towardsdatascience.com/building-a-dynamic-data-pipeline-with-databricks-and-azure-data-factory-5460ce423df5?source=collection_archive---------10-----------------------#2020-01-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1878" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">利用 Databricks 和 Azure Data Factory 使您的数据管道更加动态</h2></div><p id="0aa0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">TL；DR 一些简单有用的技术，可以应用在数据工厂和数据块中，使您的数据管道在可重用性方面更加动态。传递参数、嵌入笔记本、在单个作业集群上运行笔记本。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/ed4920d07fdea05d11c1bb81511eb184.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xnjSUw4YSQPaP0lRxq-CKg.jpeg"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">坦纳·博瑞克在<a class="ae lu" href="https://unsplash.com/s/photos/data?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="c932" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="lv">-简单骨架数据管道</em></p><p id="6942" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="lv">-执行时传递管道参数</em></p><p id="9809" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="lv">-嵌入笔记本</em></p><p id="d830" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="lv">-将数据工厂参数传递给 Databricks 笔记本</em></p><p id="e7f0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="lv">-在一个作业集群上运行多个临时作业</em></p><h1 id="435c" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated"><strong class="ak">第一步:简单骨架数据管道</strong></h1><p id="7aa9" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated"><em class="lv">该段将在基础管线的高层次分解</em></p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi mt"><img src="../Images/edf585ee308bec4c8bba7a52bc14835b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fyUt2I-e_j8aoLiYBGTLiQ.png"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">图 1 — ETL 外壳文件检查器(外部管道)</p></figure><p id="56fa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">主要思想是构建一个 shell 管道，在其中我们可以将变量的任何实例参数化。在本例中，我们将使用 get 元数据返回文件夹列表，然后使用 foreach 遍历文件夹并检查任何 csv 文件(*。csv)，然后将变量设置为<strong class="kk iu">真。</strong>然后*if*在具有 Databricks 组件的 true activities 内部条件为真以执行笔记本。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="c8bf" class="lw lx it bd ly lz nb mb mc md nc mf mg jz nd ka mi kc ne kd mk kf nf kg mm mn bi translated">执行时传递管道参数</h1><p id="21f6" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">不用说，完成一个管道来确保尽可能多的值是参数化的。这是为了在运行时或被触发时将值传递给管道。减少尽可能多的硬编码值将减少在将 shell 管道用于相关的其他工作时所需的更改数量。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/83502300014cfc5e01ff033967377593.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/format:webp/1*3pa8SYP09csfI3ri-MqR6Q.png"/></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">传递管道参数容器 ClusterID</p></figure></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="102c" class="lw lx it bd ly lz nb mb mc md nc mf mg jz nd ka mi kc ne kd mk kf nf kg mm mn bi translated"><strong class="ak">嵌入笔记本</strong></h1><p id="b452" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">出于可维护性的原因，将可重复使用的功能保存在单独的笔记本中，并在需要的地方嵌入运行它们。一个简单的例子:具有修剪任何额外空白的所有列的功能。</p><p id="0112" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="lv">儿童笔记本(包含功能)</em></p><pre class="lf lg lh li gt nh ni nj nk aw nl bi"><span id="da80" class="nm lx it ni b gy nn no l np nq">def trim_all_columns(x):<br/>    """<br/>    Trim white space from ends of each value across all series in   dataframe<br/>    """<br/>    trim_strings = lambda x: x.strip() if type(x) is str else x<br/>    return x.applymap(trim_strings)</span></pre><p id="a5e3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="lv">父笔记本(调用功能)</em></p><pre class="lf lg lh li gt nh ni nj nk aw nl bi"><span id="e2e3" class="nm lx it ni b gy nn no l np nq">%run /<a class="ae lu" href="mailto:Users/a2270226-msp01@ey.net" rel="noopener ugc nofollow" target="_blank">Users/..U</a>sername../ParentFunctions</span><span id="8280" class="nm lx it ni b gy nr no l np nq">df = trim_all_columns(data)</span></pre></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="f697" class="lw lx it bd ly lz nb mb mc md nc mf mg jz nd ka mi kc ne kd mk kf nf kg mm mn bi translated"><strong class="ak">将数据工厂参数传递给 Databricks 笔记本</strong></h1><p id="e785" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">可以在数据块中选择高并发集群，或者只使用作业集群分配来选择临时作业。创建连接后，下一步是工作流中的组件。下面我们来看看如何利用高并发集群。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/080c76960d0c952a46cc5426755568f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*570bSY5rmktQM83WeAQg2A.png"/></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">图 1 —数据块 ADF 管道组件设置</p></figure><p id="cb6c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如图 1 所示，在这里调整基本参数设置将允许 Databricks 笔记本能够检索这些值。这是通过使用 getArgument("BlobStore ")函数实现的。这些参数可以从父管道传递。这使得它特别有用，因为可以使用触发器来调度它们的传递。</p><p id="1022" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">创建到 Blob 存储的连接的一个关键部分是<a class="ae lu" href="https://pypi.org/project/azure-storage-blob/" rel="noopener ugc nofollow" target="_blank"> azure-storage </a>库。这将允许我们创建到 blob 的连接，因此必须将该库添加到集群中。</p><p id="72f4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae lu" href="https://docs.databricks.com/security/secrets/secret-scopes.html" rel="noopener ugc nofollow" target="_blank">下一部分将假设您已经在 databricks CLI </a>中为 blob 存储创建了一个秘密范围。在这里，您可以为 blob 存储存储 SAS URIs。如果您需要进行数据隔离，并隔离对帐户中各个容器的访问，这可能特别有用。</p><pre class="lf lg lh li gt nh ni nj nk aw nl bi"><span id="17d1" class="nm lx it ni b gy nn no l np nq">from azure.storage.blob import (BlockBlobService,ContainerPermissions)<br/>import pandas as pd</span><span id="089e" class="nm lx it ni b gy nr no l np nq">from importlib import reload<br/>import sys, re, io</span><span id="bce0" class="nm lx it ni b gy nr no l np nq">trigger = getArgument("DepartmentName")<br/>scope = "" # Insert Secret scope name here</span><span id="2e59" class="nm lx it ni b gy nr no l np nq">dbutils.secrets.list(scope=scope)<br/>keyC = trigger+"-home"</span><span id="7cb2" class="nm lx it ni b gy nr no l np nq">Secrets = dbutils.secrets.get(scope = scope ,key = keyC)<br/>storage_account_name = getArgument("BlobStore")<br/>container_name = trigger+"-home-exp"</span><span id="e53d" class="nm lx it ni b gy nr no l np nq">blobService = BlockBlobService(account_name=storage_account_name, account_key=None, sas_token=Secrets[1:])</span><span id="6be9" class="nm lx it ni b gy nr no l np nq">generator = blobService.list_blobs(container_name)<br/>for blob in generator:<br/>  print(blob.name)<br/>blobs = [b for b in generator]</span></pre><p id="d4b5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面是一个使用 Databricks 笔记本连接到 blob 存储的示例。半信半疑地说，有<a class="ae lu" href="https://docs.databricks.com/data/data-sources/azure/azure-storage.html" rel="noopener ugc nofollow" target="_blank">其他有记载的方法可以连接 Scala 或 pyspark </a>并将数据加载到 spark 数据帧而不是 pandas 数据帧。</p><p id="d32f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在创建用于连接的代码块并将数据加载到数据帧中之后。现在，您可以在将数据输出到容器之前执行任何数据操作或清理。</p><p id="85f3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后一步是清理活动的处理容器，并将新文件发送到它自己的 blob 容器中，或者与其他整理过的数据一起发送。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="4e14" class="lw lx it bd ly lz nb mb mc md nc mf mg jz nd ka mi kc ne kd mk kf nf kg mm mn bi translated"><strong class="ak">在一个作业集群上运行所有临时作业</strong></h1><p id="d64b" class="pw-post-body-paragraph ki kj it kk b kl mo ju kn ko mp jx kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">在处理较小的工作(不是很大的数据任务)时，为了提高效率，在单个工作集群上动态运行笔记本电脑。如果出于任何特殊原因，您选择不使用作业池或高并发集群，则使用此选项。</p><p id="9553" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里的想法是，您可以将变量或管道参数传递给这些值。为了演示这个例子的简单性，我将它们硬编码。其中 name<strong class="kk iu"><em class="lv">data structure _ * n *</em></strong>定义了数据块中 4 个不同笔记本的名称。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/fe324e1dc7b5061724942d18d9f5b669.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/1*LSndv2ZMc9yFKku8mcqubQ.png"/></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">ADF 中的数据块组件</p></figure><p id="80a2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果发现从名为 exists 的数据工厂传递的参数，下面来自 Databricks 笔记本的代码将运行列表 nbl 中的笔记本。这方面的一个用例可能是，您有 4 种不同的数据转换要应用于不同的数据集，并且更喜欢将它们隔离起来。</p><p id="3693" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="lv">嵌入式笔记本</em></p><pre class="lf lg lh li gt nh ni nj nk aw nl bi"><span id="b244" class="nm lx it ni b gy nn no l np nq">nbl = ['dataStructure_1', 'dataStructure_2', <br/>       'dataStructure_3', 'dataStructure_4']</span><span id="9c8a" class="nm lx it ni b gy nr no l np nq">arg1 = "exists"<br/>exitParam =[]</span><span id="6731" class="nm lx it ni b gy nr no l np nq">def argCheck(list: nbl):<br/>    return [getArgument(i) for i in nbl]<br/>var_s = argCheck(nbl)</span><span id="fd0c" class="nm lx it ni b gy nr no l np nq">def notebookExe(list: nbl):<br/>  for x,y in zip(nbl,var_s):<br/>    try:<br/>      if y == arg1:<br/>        output = dbutils.notebook.run("/..NotebookLocation/JobA/"+ x, 60,<br/>                             {"key": x})<br/>        print(x,y)<br/>        print(output)<br/>        exitParam.append(output)<br/>      else:<br/>        pass<br/>    except:<br/>      pass<br/>notebookExe(nbl)<br/>dbutils.notebook.exit(exitParam)</span></pre><p id="ea60" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">希望你能从中获得一些有用的信息，或者给我一些建议。请不要客气。</p></div></div>    
</body>
</html>