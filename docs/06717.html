<html>
<head>
<title>Identifying the Number of Open Ion Channels with Hidden Markov Models</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用隐马尔可夫模型识别开放离子通道的数量</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/identifying-the-number-of-open-ion-channels-with-hidden-markov-models-334fab86fc85?source=collection_archive---------34-----------------------#2020-05-26">https://towardsdatascience.com/identifying-the-number-of-open-ion-channels-with-hidden-markov-models-334fab86fc85?source=collection_archive---------34-----------------------#2020-05-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8308" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一篇关于我们如何差点赢得“利物浦大学—离子交换”Kaggle竞赛的报道</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/36991a3de0070ceccb9af9c1ad74919a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ff56t2S6j-pywr60QDkKIA.png"/></div></div></figure><p id="f249" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">2020年4月6日编辑:我们已经发布了我们的代码！T3】</p><p id="a2ed" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">2月24日，<a class="ae ln" href="http://www.kaggle.com" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>与<a class="ae ln" href="https://www.liverpool.ac.uk/" rel="noopener ugc nofollow" target="_blank">利物浦大学</a>合作发布了一项新的“研究”竞赛，奖金高达25000美元。在这场比赛中，我们获得了与离子通道数据相对应的电信号，我们的目标是创建一种算法，可以自动识别每个时间点打开的通道数量。最初，比赛以一种奇特的“二次加权科恩卡帕评分(QWK)”开始，但这导致了发布后不久近乎完美的结果，这使得<a class="ae ln" href="https://www.kaggle.com/c/liverpool-ion-switching/discussion/132527" rel="noopener ugc nofollow" target="_blank"> me不愿加入</a>。过了一段时间，竞争指标变成了更合理的宏观F1分数，之后很明显我们离完美的解决方案还很远。我决定加入是因为几个原因:</p><ul class=""><li id="5c92" class="lo lp iq kt b ku kv kx ky la lq le lr li ls lm lt lu lv lw bi translated">这是时间序列数据。</li><li id="93c8" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">这只是一个单一的时间序列，这使我们能够更专注于预处理和建模，而不是功能工程。</li><li id="2cf8" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">数据集相当小，在训练集中总共有500万个测量值，在测试集中有200万个测量值。所需的总存储空间约为125 MB。</li></ul><p id="cfb6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我有幸与我曾有机会共事过的两个最聪明的人合作:<a class="ae ln" href="https://www.kaggle.com/khahuras" rel="noopener ugc nofollow" target="_blank">卡沃</a>和<a class="ae ln" href="https://www.kaggle.com/zidmie" rel="noopener ugc nofollow" target="_blank">兹德米</a>。<strong class="kt ir">最终，我们成功获得了第三名和5，000美元奖金，并在2600多个团队中脱颖而出。</strong> <a class="ae ln" href="https://www.kaggle.com/c/liverpool-ion-switching/discussion/153824" rel="noopener ugc nofollow" target="_blank">第一名和第二名设法在比赛快结束时在私人测试数据中发现了一个漏洞</a>，我们没有发现(只是在知道它的存在之后)。换句话说，我们有了<strong class="kt ir">最佳无泄漏解决方案</strong>！最后，我们能够在很短的时间内<a class="ae ln" href="#cf75" rel="noopener ugc nofollow">自己找到这个漏洞</a>，这让我们更加沮丧…</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mc"><img src="../Images/d62b3c2d783be131194bd099253944e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V10hsLxhpun-sNbcF0dqgQ.png"/></div></div></figure><p id="5563" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这篇博文将提供我们解决方案的详细概述，并提供我们提出解决方案所需的见解。以下是目录:</p><ul class=""><li id="41e8" class="lo lp iq kt b ku kv kx ky la lq le lr li ls lm lt lu lv lw bi translated"><a class="ae ln" href="#d423" rel="noopener ugc nofollow"> <strong class="kt ir">简介</strong> </a> <br/> - <a class="ae ln" href="#da77" rel="noopener ugc nofollow">问题陈述</a> <br/> - <a class="ae ln" href="#08e4" rel="noopener ugc nofollow">一看数据&amp;竞赛度量</a></li><li id="88cd" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated"><a class="ae ln" href="#634a" rel="noopener ugc nofollow"> <strong class="kt ir">预处理</strong> </a> <br/> - <a class="ae ln" href="#2d98" rel="noopener ugc nofollow">预处理一:去除漂移</a>-<br/>-<a class="ae ln" href="#9466" rel="noopener ugc nofollow">预处理二:线性变换</a> <br/> - <a class="ae ln" href="#5270" rel="noopener ugc nofollow">预处理三:电力线干扰去除</a> <br/> - <a class="ae ln" href="#cf75" rel="noopener ugc nofollow">类别5 =类别4 +类别4 </a></li><li id="6d22" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated"><a class="ae ln" href="#5857" rel="noopener ugc nofollow"> <strong class="kt ir">建模</strong> </a> <br/> - <a class="ae ln" href="#2e4c" rel="noopener ugc nofollow">隐马尔可夫模型:1通道数据</a>-<a class="ae ln" href="#2bb4" rel="noopener ugc nofollow">-【隐】隐马尔可夫模型</a> <br/> - <a class="ae ln" href="#8d9f" rel="noopener ugc nofollow">将隐马尔可夫模型扩展到K通道</a> <br/> - <a class="ae ln" href="#2bfb" rel="noopener ugc nofollow">在隐马尔可夫模型中引入记忆</a></li><li id="986c" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated"><a class="ae ln" href="#fe33" rel="noopener ugc nofollow"> <strong class="kt ir">后处理</strong> </a> <br/> - <a class="ae ln" href="#2b73" rel="noopener ugc nofollow">后处理后验概率</a>-<br/>-<a class="ae ln" href="#0a56" rel="noopener ugc nofollow">一点点融合</a></li><li id="1e4e" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated"><a class="ae ln" href="#0d40" rel="noopener ugc nofollow"> <strong class="kt ir">结论</strong> </a></li></ul><h1 id="d423" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">介绍</h1><h2 id="da77" class="mv me iq bd mf mw mx dn mj my mz dp mn la na nb mp le nc nd mr li ne nf mt ng bi translated"><strong class="ak">问题陈述</strong></h2><p id="25ee" class="pw-post-body-paragraph kr ks iq kt b ku nh jr kw kx ni ju kz la nj lc ld le nk lg lh li nl lk ll lm ij bi translated"><a class="ae ln" href="https://en.wikipedia.org/wiki/Ion_channel" rel="noopener ugc nofollow" target="_blank">离子通道</a>是成孔膜蛋白，存在于动物和植物中，允许离子通过通道孔。它们对学习和记忆进行编码，帮助对抗感染，发出疼痛信号，刺激肌肉收缩。这些离子通道可以通过<a class="ae ln" href="https://en.wikipedia.org/wiki/Patch_clamp" rel="noopener ugc nofollow" target="_blank">膜片钳技术</a>进行记录和分析，以推断疾病的某些特性。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/bbb0b7eccddd1719de4fb90ceb70afca.png" data-original-src="https://miro.medium.com/v2/resize:fit:580/format:webp/0*HIIcIbkyZt-SB3YQ.png"/></div><p class="nn no gj gh gi np nq bd b be z dk translated">来自<a class="ae ln" href="https://en.wikipedia.org/wiki/Ion_channel" rel="noopener ugc nofollow" target="_blank">维基百科</a>的离子通道示意图。</p></figure><p id="7bd3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">组织者这样描述这个挑战:“当离子通道打开时，它们传递电流。检测这些状态变化的现有方法既慢又费力。人类必须监督分析，这除了乏味之外，还会带来相当大的偏差。这些困难限制了可用于研究的离子通道电流分析的容量。科学家希望该技术能够在原始数据中快速自动检测离子通道电流事件。在过去的20年里，分析电池中电数据的技术没有发生重大变化。如果我们更好地了解离子通道活动，这项研究可能会影响许多与细胞健康和迁移相关的领域。从人类疾病到气候变化如何影响植物，更快地检测离子通道可以大大加快解决重大世界问题。”</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/7a6534fcd06561d08c7700c4acc615eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/0*6j-rZexieclEBDEy.jpg"/></div><p class="nn no gj gh gi np nq bd b be z dk translated">当离子通道打开时，我们可以清楚地看到电流的增加。</p></figure><h2 id="08e4" class="mv me iq bd mf mw mx dn mj my mz dp mn la na nb mp le nc nd mr li ne nf mt ng bi translated">了解数据和竞争指标</h2><p id="2e4b" class="pw-post-body-paragraph kr ks iq kt b ku nh jr kw kx ni ju kz la nj lc ld le nk lg lh li nl lk ll lm ij bi translated">提供给我们的数据相当简单，这是这场比赛的好处之一。数据只包含三列:</p><ul class=""><li id="812e" class="lo lp iq kt b ku kv kx ky la lq le lr li ls lm lt lu lv lw bi translated">时间戳</li><li id="13cc" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">每个时间戳的安培值(电流)。这些值是在10千赫的采样频率下测量的。</li><li id="559d" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">该时间戳对应的开放通道数(仅针对训练数据提供)。</li></ul><p id="cd94" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">训练数据集包含500万行，而测试数据集包含200万行。竞赛的目标是在这200万行上最大化宏观F1分数。特定类别的F1分数被定义为精确度和召回率的调和平均值:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/d2a3245acecea770261dfd8acedee31f.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*HWciPNLkZkWQj7nwq91HRw.png"/></div></figure><p id="2bd2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">“宏”</strong> F1简单来说就是每个班级的平均F1分数。因此，如果我们有<em class="nt"> K </em>类，我们将计算<em class="nt"> K </em> F1分数，然后取这些<em class="nt"> K </em>分数的平均值。如果我们检查提供的数据，我们已经可以得出一些有趣的事情…</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/f95de604b6348680097283f178ac201d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r3shxOo2LsF-bAh85DVtEQ.png"/></div></div><p class="nn no gj gh gi np nq bd b be z dk translated">提供的原始数据(训练和测试)</p></figure><p id="8391" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，通过检查训练数据中的开放通道，我们可以看到<em class="nt">数据由批量500K测量值</em>组成。我们也可以在电信号中批量看到这些转换。在测试集中，我们可以找到100K 的<em class="nt">批次。而且，事实证明，训练集中500K的批次实际上由5x 100K的批次组成。</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/8fa97c9ed2213a7fc56d8c71ffea62e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HVX4NzoE__QLqXnZ.png"/></div></div><p class="nn no gj gh gi np nq bd b be z dk translated">训练由多批500K组成。摘自<a class="ae ln" href="https://www.kaggle.com/cdeotte/one-feature-model-0-930" rel="noopener ugc nofollow" target="_blank">Chris Deotte</a><a class="ae ln" href="https://www.kaggle.com/cdeotte" rel="noopener ugc nofollow" target="_blank">的【一个特征模型】</a>。</p></figure><p id="04b3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过更多地检查训练集中的开放频道，我们可以在训练集中找到五个不同的组:</p><ul class=""><li id="d009" class="lo lp iq kt b ku kv kx ky la lq le lr li ls lm lt lu lv lw bi translated">开放信道等于0或1的组。有许多0和一些1。<strong class="kt ir">(类别1) </strong></li><li id="1fb8" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">开放信道等于0或1的群。很多1，很少0。<strong class="kt ir">(类别2) </strong></li><li id="3cc3" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">等于0，1，2，3的一组开放通道。<strong class="kt ir">(第三类)</strong></li><li id="cefd" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">等于0，1，2，3，4，5的一组开放通道。<strong class="kt ir">(第四类)</strong></li><li id="b776" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">等于0，1，2，3，4，5，6，7，8，9，10的一组开放通道。<strong class="kt ir">(类别5) </strong></li><li id="c0ae" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">令人惊讶的是，测试数据包含许多看起来非常类似于类别1的数据，但在电信号中有一些尖峰，这些尖峰没有出现在列车数据中。因此，我们将这些分类为单独的类别<strong class="kt ir">(类别6) </strong></li></ul><p id="b1d6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当将这种洞察力与竞争指标相结合时，很明显<em class="nt">具有多达10个开放频道</em> <strong class="kt ir"> <em class="nt">(类别5) </em> </strong> <em class="nt">的组将对宏观F1平均值产生最大影响。</em>它有5个独特的类别(6、7、8、9、10)，没有出现在其他组中，因此，这组数据对我们的宏观F1分数的贡献超过50%。在比赛过程中，<a class="ae ln" href="https://www.kaggle.com/waylongo" rel="noopener ugc nofollow" target="_blank"> Waylon Wu </a> <a class="ae ln" href="https://www.kaggle.com/c/liverpool-ion-switching/discussion/133142" rel="noopener ugc nofollow" target="_blank">通过打探发现</a>公共LB由前30%(或600000)的测试值组成，而私有LB由剩下的70% (1400000)组成。</p><h1 id="634a" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">预处理</h1><h2 id="2d98" class="mv me iq bd mf mw mx dn mj my mz dp mn la na nb mp le nc nd mr li ne nf mt ng bi translated">预处理I:消除漂移</h2><p id="5afe" class="pw-post-body-paragraph kr ks iq kt b ku nh jr kw kx ni ju kz la nj lc ld le nk lg lh li nl lk ll lm ij bi translated">我们注意到，在训练信号的开始和结束以及测试信号的不同位置都存在奇怪的漂移…我们注意到两种类型的漂移:曲线漂移(例如，在训练信号的结束)和线性漂移(例如，在训练信号的开始，时间=50左右)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/bb0bb4dd30d2afdd0a71cac2fe9fcc0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/1*BeNRo1oOChFq6M16zTy0Vg.png"/></div><p class="nn no gj gh gi np nq bd b be z dk translated">来自信号的两个子样本说明了两种类型的漂移。</p></figure><p id="18dc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，事实证明“线性”漂移根本不是线性的，而实际上只是“弯曲”漂移的一小部分(例如，我们的弯曲漂移的前半部分看起来也是线性的)。比赛开始后不久，<a class="ae ln" href="https://www.kaggle.com/eunholee" rel="noopener ugc nofollow" target="_blank"> Eunho Lee </a>和<a class="ae ln" href="https://www.kaggle.com/friedchips" rel="noopener ugc nofollow" target="_blank"> Markus F </a>发现比赛组织者通过使用频率非常低的(周期值为1.000.000)的<a class="ae ln" href="https://www.kaggle.com/eunholee/remove-drift-using-a-sine-function" rel="noopener ugc nofollow" target="_blank">正弦函数，在数据中引入了人为噪声。</a><a class="ae ln" href="https://www.kaggle.com/cdeotte" rel="noopener ugc nofollow" target="_blank"> Chris Deotte </a>将来自两个独立分析的见解捆绑在一起，以执行最干净的漂移消除，并<a class="ae ln" href="https://www.kaggle.com/cdeotte/data-without-drift" rel="noopener ugc nofollow" target="_blank">从中制作一个数据集</a>，该数据集可被所有其他竞争对手使用(感谢Chris！).我们的新数据现在看起来如下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/72167ff7e41b8e22ad38a24880aaae7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MOpf986ZhNr02-GTHd6Rwg.png"/></div></div><p class="nn no gj gh gi np nq bd b be z dk translated">漂移消除后的数据</p></figure><p id="753d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以注意到，从时间=360到时间=390，有些事情仍然在出错。我们决定不为此费心，因为这样的异常在测试集中不存在，并且我们从我们的训练集中删除了这个数据。</p><h2 id="9466" class="mv me iq bd mf mw mx dn mj my mz dp mn la na nb mp le nc nd mr li ne nf mt ng bi translated">预处理II:线性变换</h2><p id="b251" class="pw-post-body-paragraph kr ks iq kt b ku nh jr kw kx ni ju kz la nj lc ld le nk lg lh li nl lk ll lm ij bi translated">通过检查数据，很明显列车信号和开放频道的数量是高度相关的。事实上，对电信号应用线性变换，然后对结果值进行舍入，已经表现得相当好了。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/17bd3c1b6b686e593d82cd48a72e740a.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*oQei2zhpLI55h16mKTw53w.png"/></div><p class="nn no gj gh gi np nq bd b be z dk translated">电信号和开放通道的数量密切相关。</p></figure><p id="9ad5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们决定学习每类数据的线性变换，将电信号值最好地映射到开放通道的数量，这使得在未来的步骤中更容易分析。转换相当简单，我们学习了以下函数的两个不同参数(1D线性回归):</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/e5a2d8fa0d6e743c14d527540dc378ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:618/0*X0p4yvxk4QEV4Q2U"/></div><p class="nn no gj gh gi np nq bd b be z dk translated">1D线性回归，以更好地将电信号(x)与其各自的开放通道数对齐。o是偏移量，s是线性回归的斜率。</p></figure><p id="6248" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们的斜率对于每个类别都是相同的(0.8107)，并且偏移取决于类别(对于类别2、3、4和6是2.221318；类别5为4.4288541，类别1为2.180783)</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/78b04aaff3803a1c3f4bb6ef69932d88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*77gUhYIK9fF4uerdS7fDGA.png"/></div></div><p class="nn no gj gh gi np nq bd b be z dk translated">对齐的数据。请注意，电信号现在已经非常好地对应于各个开放通道的数量。对信号值进行舍入已经会产生强基线。</p></figure><p id="d875" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae ln" href="https://github.com/GillesVandewiele/Liverpool-Ion-Switching/blob/master/notebooks/1%20-%20Align%20Channels%20and%20Signal.ipynb" rel="noopener ugc nofollow" target="_blank">我们提供了一个包含python代码的笔记本来说明这一点。</a></p><h2 id="5270" class="mv me iq bd mf mw mx dn mj my mz dp mn la na nb mp le nc nd mr li ne nf mt ng bi translated">预处理三:电力线干扰消除</h2><p id="5f0c" class="pw-post-body-paragraph kr ks iq kt b ku nh jr kw kx ni ju kz la nj lc ld le nk lg lh li nl lk ll lm ij bi translated">正如我在上一节中提到的，舍入我们对齐的电信号值将会产生一个强基线。不幸的是，它不会产生一个完美的分数…这是由于噪音存在于我们的数据集中(幸运的是，否则这将是一个相当微不足道的挑战)！我们可以通过简单地计算以下等式来检查这种噪声:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/a430e8272923aba434b83a5aac740e17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LXgbNe5eof62lRdF"/></div></div></figure><p id="b40c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面是我们的训练集的前10000个噪声值的图:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/dc77006c6d03a3a952a6cf74229d7573.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aPsnamNFcxwULwrYckIRQA.png"/></div></div><p class="nn no gj gh gi np nq bd b be z dk translated">我们训练集的前10000个噪音值</p></figure><p id="6392" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">虽然可能很难用肉眼看到，但在我们的噪声中存在某种波形。如果我们取一个大小为50的居中窗口的移动平均线，这就变得更加清楚了:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/759e2dbedd40d2289e92f8c56bc7e17f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qIIesVf_EAE3tZ7Fee-FDQ.png"/></div></div><p class="nn no gj gh gi np nq bd b be z dk translated">我们10000个噪声值的移动平均值(大小为50的居中窗口)。</p></figure><p id="4a08" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以清楚地看到平均每200个值就有一个波峰。以10 kHz的采样频率测得的周期约为200的周期性信号对应于50 Hz的频率。原来英国的交流电(比赛是利物浦大学的)频率是50 Hz！为了从我们的噪声中消除这种模式，我们决定在每批100000个噪声值上拟合一个正弦函数(为此，您可以使用<a class="ae ln" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.curve_fit.html" rel="noopener ugc nofollow" target="_blank"> scipy.optimize </a>)。虽然信号处理技术，如带通和带阻滤波器也可以做到这一点，但我们用简单的正弦函数可以得到更好的结果。结果还表明，正弦函数中有多个分量(即多个正弦波具有不同的振幅、相位和频率)效果最佳。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi od"><img src="../Images/b5a3638ae245c5b42741e38ad6699ee4.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*TeUQ1qDI3X1etGtS-Wrg0g.png"/></div><p class="nn no gj gh gi np nq bd b be z dk translated">10000个噪声值和相应的拟合正弦函数。</p></figure><p id="458a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae ln" href="https://github.com/GillesVandewiele/Liverpool-Ion-Switching/blob/master/notebooks/2%20-%20Remove%20Power%20Line%20Interference.ipynb" rel="noopener ugc nofollow" target="_blank">同样，我们提供了一个笔记本来用python代码演示这一点。</a></p><h2 id="cf75" class="mv me iq bd mf mw mx dn mj my mz dp mn la na nb mp le nc nd mr li ne nf mt ng bi translated">类别5 =类别4 +类别4</h2><p id="bb95" class="pw-post-body-paragraph kr ks iq kt b ku nh jr kw kx ni ju kz la nj lc ld le nk lg lh li nl lk ll lm ij bi translated">看起来我们的噪声去除技术对所有类别都很有效，除了一个类别……类别5中的数据有一些独特之处，使其区别于其他所有类别。通过做一些实验，我们注意到我们可以通过将类别4中的两个随机批次相加，很好地模拟类别5中的数据。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/d6d8beb7c47172bfab233ff78faaa98d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1SuVZ9D2vnW7Xtix9_dH7A.png"/></div></div><p class="nn no gj gh gi np nq bd b be z dk translated">通过将两批类别4相加，生成类别5的合成数据。</p></figure><p id="3bf5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过这种假设，我们也可以假设5类噪声是两个正弦函数的叠加。此外，这种见解允许对例如神经网络有用的数据扩充。</p><p id="6828" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">事实证明，这一见解实际上也是漏洞。我们没有追求这条途径足够长的时间，但私人测试数据正好是两个类别4批次的总和，其中一个可以在训练集中找到...比赛结束后，我的队友Zidmie，</strong> <a class="ae ln" href="https://www.kaggle.com/c/liverpool-ion-switching/discussion/153824" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir">在大约30分钟的寻找中发现了这个漏洞</strong> </a> <strong class="kt ir">(将我们的私人得分提高到0.95430)。令人沮丧的是，由于一个漏洞，我们在30分钟内改进的模型比我们两个月的工作都多。后来他发现了整个泄密:</strong> <code class="fe of og oh oi b">y_test[570000:5800000] = predict(X_test[5700000:5800000] - X_train[4000000:4100000]) + y_train[4000000:4100000]</code> <strong class="kt ir">。因为你现在预测的是第4类数据(最多5个通道)，所以任务变得容易多了。</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/5bd03f891a5cfb4f7f826219e9384454.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lbhvwQWi5DAvbZNJ5nLnNQ.png"/></div></div><p class="nn no gj gh gi np nq bd b be z dk translated">再现#1和#2使用的泄漏。#1从X_test中提取X_train，而#2从X_test中提取y_train。提取X_train比y_train好，因为你也把噪音降低了一半！</p></figure><h1 id="5857" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">建模</h1><h2 id="2e4c" class="mv me iq bd mf mw mx dn mj my mz dp mn la na nb mp le nc nd mr li ne nf mt ng bi translated">隐马尔可夫模型:单通道数据</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/f340c77bcc133b202ceb67a063e4f72c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-H853VcrN1aab5AFZ3eXDQ.png"/></div></div><p class="nn no gj gh gi np nq bd b be z dk translated">这个迷因太适合不使用它了。最后，<strong class="bd ol">事实证明，私有测试数据的泄露是真正的赢家</strong>(也许我应该创造一个新的迷因……)。</p></figure><p id="f29e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">序列状态空间模型，如隐马尔可夫模型，在很长一段时间内是这类问题的最新技术。只是在最近，深度学习的变体才被提出来(例如竞赛组织者提出的<a class="ae ln" href="https://www.nature.com/articles/s42003-019-0729-3" rel="noopener ugc nofollow" target="_blank">本文</a>)，因为这些变体通常对漂移之类的事情更加鲁棒。由于我们正在预处理我们的数据以消除所有的伪像，我们决定采用隐马尔可夫模型作为我们这次比赛的建模技术。</p><p id="0b4c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有很多关于隐马尔可夫模型的精彩介绍，所以我在这里就不再赘述了。我们需要知道的是，每个隐马尔可夫模型都有不同的参数:</p><ul class=""><li id="2f4a" class="lo lp iq kt b ku kv kx ky la lq le lr li ls lm lt lu lv lw bi translated">隐藏状态的数量(= K)</li><li id="7ede" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">初始化概率(大小为K的向量)</li><li id="7fa6" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">一个转移矩阵(K×K矩阵)</li><li id="dad8" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">排放概率。每个隐藏状态都发出一定的可观测值。这些发射可以具有不同的分布，例如离散发射的多项分布和连续发射的高斯分布(我们将在这里使用，因为我们的电信号是连续的)。</li></ul><p id="c531" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">简而言之，开放通道(隐藏变量)遵循特定的马尔可夫过程，并以由转移矩阵确定的特定概率从一个值转移到另一个值。当马尔可夫过程处于某个隐藏/潜在状态时，会发出一个可观测值，这里就是电信号。</p><p id="451c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">作为一个例子，我们将关注具有二元响应变量(开放通道= 0或1)的类别2，并假设我们的马尔可夫模型具有2个隐藏状态。当打开通道的数量等于0时为隐藏状态，当它等于1时为一个隐藏状态。通过查看我们的训练数据(即，计算从一个状态到另一个状态的转换，并查看与一定数量的开放通道相对应的信号值)，我们可以很容易地估计转换矩阵和发射分布:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/2dd7bad14c6eee5d27c5f32d9915b6d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zBfxc_ZCuDv9AnzACgF4hQ.png"/></div></div><p class="nn no gj gh gi np nq bd b be z dk translated">第二类训练数据的估计高斯分布和转移概率。</p></figure><p id="a06a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这意味着，例如，如果开放通道的数量等于1，信号值也将大约为1(有一点差异)。下一个值将以93.6%的概率等于1，或者以6.4%的概率等于0。如上所述，这些参数可以通过使用训练数据来估计，但是也可以通过应用<a class="ae ln" href="https://en.wikipedia.org/wiki/Baum%E2%80%93Welch_algorithm" rel="noopener ugc nofollow" target="_blank">鲍姆-韦尔奇算法</a>来估计。该算法是期望最大化算法的一个特例，期望最大化算法是一个<strong class="kt ir">无监督算法</strong>(不需要交叉验证，允许更快的迭代)。简而言之(也是简单化的方式)，它会基于其初始参数进行预测，然后使用这些预测来更新参数，直到收敛。一旦学习了参数，我们就可以通过应用两种算法中的一种来执行推理:</p><ul class=""><li id="d679" class="lo lp iq kt b ku kv kx ky la lq le lr li ls lm lt lu lv lw bi translated"><a class="ae ln" href="https://en.wikipedia.org/wiki/Viterbi_algorithm" rel="noopener ugc nofollow" target="_blank">维特比算法</a>——将返回最可能的序列</li><li id="2f03" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated"><a class="ae ln" href="https://en.wikipedia.org/wiki/Forward%E2%80%93backward_algorithm" rel="noopener ugc nofollow" target="_blank">前向-后向算法</a>(或最大后验概率)——返回TxK概率矩阵P，其中<code class="fe of og oh oi b">P[t][k]</code>将是在时间<code class="fe of og oh oi b">t</code>处于隐藏状态<code class="fe of og oh oi b">k</code>的概率。</li></ul><p id="03ec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae ln" href="https://www.kaggle.com/group16/lb-0-936-1-feature-forward-backward-vs-viterbi" rel="noopener ugc nofollow" target="_blank">初始实验</a>已经表明，前向-后向算法比维特比算法工作得稍好(尽管较慢)。注意，这些算法也用于Baum-Welch算法。在Python中应用所有这些算法的一个很棒的库是<a class="ae ln" href="https://hmmlearn.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> hmmlearn </a>。</p><p id="0c99" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们在类别2的预处理数据上拟合一个双态HMM:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div><p class="nn no gj gh gi np nq bd b be z dk translated">创建具有两个隐藏状态的隐藏马尔可夫模型，我们基于我们的训练数据估计我们的发射分布和转移矩阵的参数。“长度=[100000]*10”来自于类别2有2批数据的事实。每批长度为500K，同样由5批100K组成。因此，我们总共有10个长度为100000的序列。</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi op"><img src="../Images/a1885e02cfd1bc4670c288d15549adc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*dFI8ah7uiBClf67EbcVvVg.png"/></div><p class="nn no gj gh gi np nq bd b be z dk translated">我们脚本的输出。hmmlearn库执行Baum-Welch算法5次迭代以适应我们的参数，之后它收敛。这类数据的F1分数等于0.9961</p></figure><p id="8524" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，通过使用这个相当简单的方法，我们已经可以在我们的数据类别2上获得0.9961的F1分数。应该注意的是，我们的数据的类别1和类别2是最简单的，具有近乎完美的性能。F1分数随着开放频道的最大数量而迅速下降。例如，我们无法在数据的类别5上达到0.9的F1分数。<a class="ae ln" href="https://github.com/GillesVandewiele/Liverpool-Ion-Switching/blob/master/notebooks/3%20-%20Fit%204-state%20HMM%20(Cat%203).ipynb" rel="noopener ugc nofollow" target="_blank">请看这本笔记本，了解更详细的例子。</a></p><h2 id="2bb4" class="mv me iq bd mf mw mx dn mj my mz dp mn la na nb mp le nc nd mr li ne nf mt ng bi translated">“隐”隐马尔可夫模型</h2><p id="ff5c" class="pw-post-body-paragraph kr ks iq kt b ku nh jr kw kx ni ju kz la nj lc ld le nk lg lh li nl lk ll lm ij bi translated">当阅读组织者发表的一篇论文时，可以清楚地看到，尽管开放频道的数量遵循马尔可夫过程，但它们又是由隐马尔可夫模型生成的。：</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/ea65033dea24e143e430e9f72a69fd23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*NL2Ido9Rki_oidEc.png"/></div></div><p class="nn no gj gh gi np nq bd b be z dk translated">地面真相(开放通道)由马尔可夫过程产生，这可以是合成的(这是该比赛的情况)或真实的(因为假设真实离子通道遵循马尔可夫过程)。这个地面真相然后通过膜片钳放大器播放并记录下来，这产生了我们的带噪声(电信号)的可观测数据。<a class="ae ln" href="https://www.nature.com/articles/s42003-019-0729-3/figures/1" rel="noopener ugc nofollow" target="_blank">图取自主办方的一篇论文。</a></p></figure><p id="66ad" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个隐马尔可夫模型由比唯一的开放信道值的数量更多的隐藏状态组成。这是<a class="ae ln" href="https://www.kaggle.com/friedchips" rel="noopener ugc nofollow" target="_blank"> Markus F </a>在比赛中<a class="ae ln" href="https://www.kaggle.com/c/liverpool-ion-switching/discussion/140634" rel="noopener ugc nofollow" target="_blank">指出的</a>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/09cc7887f879780477066dc136482388.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MZJdMmSWQOmda0Cld0RUrQ.png"/></div></div><p class="nn no gj gh gi np nq bd b be z dk translated">左边是“香草”HMM，右边是2层或隐马尔可夫模型。</p></figure><p id="8a40" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一个简单的方法是在我们的2层模型中忽略中间层(y(t))。因此，我们有一个隐藏马尔可夫过程，其隐藏状态的数量大于唯一开放通道的数量。让我们将这一观点应用到我们的类别2数据中。我们将在HMM中使用4个隐藏状态(我们已经用其他数字进行了实验，但是4个效果最好)。前两个隐藏状态将对应于开放通道的数量等于1时，随后的两个隐藏状态对应于开放通道为0时。估计初始转移矩阵现在变得更加困难，因为我们不能从我们的训练数据中直接估计它，我们手动调整了转移矩阵。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div><p class="nn no gj gh gi np nq bd b be z dk translated">为了适合4状态HMM，我们手动初始化转移矩阵，并对不同的隐藏状态重复使用我们的均值和协方差。</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi os"><img src="../Images/c4c0b3f35e21c6ef7ca60fab8cf59e32.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/format:webp/1*ZcYx2VCKnY5sdHn-uGZuOA.png"/></div><p class="nn no gj gh gi np nq bd b be z dk translated">我们脚本的输出。请注意，hmmlearn在迭代过程中打印的负对数似然比具有两个隐藏状态的对数似然大一倍。</p></figure><p id="6d4a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">可以注意到，我们现在获得了0.9972的F1分数，与仅使用2个隐藏状态相比，这大约增加了0.001。这种改善非常显著，尤其是考虑到随着开放频道数量的增加，这种改善甚至会增加更多。F1分数0.001的差距就是一枚银牌和一枚金牌的差距。通过引入更多的隐藏状态或调整初始转移矩阵，F1可能会得到更大的改进，但较小的转移矩阵有几个优点，这将在后面更加清楚。在这本笔记本中可以找到这方面的Python代码。关于我们如何手动调整转换矩阵的更多信息，我们建议读者查阅<a class="ae ln" href="https://github.com/GillesVandewiele/Liverpool-Ion-Switching/blob/master/notebooks/4%20-%20Setting%20the%20Transition%20Matrix.ipynb" rel="noopener ugc nofollow" target="_blank">这本笔记本。</a></p><h2 id="8d9f" class="mv me iq bd mf mw mx dn mj my mz dp mn la na nb mp le nc nd mr li ne nf mt ng bi translated">将隐马尔可夫模型扩展到K信道</h2><p id="d8ef" class="pw-post-body-paragraph kr ks iq kt b ku nh jr kw kx ni ju kz la nj lc ld le nk lg lh li nl lk ll lm ij bi translated">看起来我们可以非常精确地对我们数据的类别1和类别2建模，这两个类别有多达1个开放通道。现在的问题(25，000美元)是，我们是否可以将这种方法应用于我们的具有一个以上公开渠道的数据的其他类别。事实证明，这远不是一个微不足道的情况…设计一个大型的初始转移矩阵，并确定哪些隐藏状态对应于哪些数量的开放通道是困难和昂贵的(我们的搜索空间实际上是无限大的)。</p><p id="b6ef" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，我们假设当一批数据中的最大开放通道数等于<code class="fe of og oh oi b">K</code>时，我们正在处理<code class="fe of og oh oi b">K</code>个独立的二元马尔可夫过程。此外，这些马尔可夫过程中的每一个都具有与我们的第二类数据非常相似的参数。让几个独立的隐藏过程产生一个可观察变量非常适合<a class="ae ln" href="http://www.ee.columbia.edu/~sfchang/course/svia-F03/papers/factorial-HMM-97.pdf" rel="noopener ugc nofollow" target="_blank">阶乘隐马尔可夫模型</a>。不幸的是，我们没有在Python中找到一个好的库(有<a class="ae ln" href="https://github.com/regevs/factorial_hmm" rel="noopener ugc nofollow" target="_blank"> factorialHMM </a>，这是一个很棒的包，但我们在比赛期间没有让它足够快地工作，还有<a class="ae ln" href="http://pyro.ai/" rel="noopener ugc nofollow" target="_blank"> Pyro.ai </a>，但学习曲线非常陡峭(至少对我来说)。</p><p id="c5f0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于没有可用的实现，我们意识到自己实现这一点将是一个困难而漫长的过程。因此，我们决定在独立流程方面“突破”,将用于模拟多达1个开放通道数据的较小转换矩阵转换为较大的转换矩阵。我们新的大型马尔可夫过程中的每个隐藏状态对应于独立过程中隐藏状态的可能组合。顺序无关紧要(即(0，2)(这意味着1个进程处于隐藏状态0，另一个处于隐藏状态2)与(2，0)相同)。这种构造是递归完成的，如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ot"><img src="../Images/fe5496446a6d86df146eae11689326ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YYCzMIwujJPGYCc7G4r7WA.png"/></div></div><p class="nn no gj gh gi np nq bd b be z dk translated">为了对两个独立的过程建模，我们首先将4个隐藏状态扩展到16个隐藏状态，这16个隐藏状态捕获了隐藏状态的所有可能组合。之后，我们将相似的状态组合在一起(用相同的颜色标记)。然后，我们可以通过将新的10x10矩阵扩展为40x40，并将其还原为20x20(以此类推)来进一步继续模型3流程。<strong class="bd ol">马尔可夫链中所有状态之间都有转移(我只是没有全部画出来)。</strong></p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/78a77971a656f4d3d7b13d3848e09832.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*vXSSZos4qva0co4EpAlENg.png"/></div><p class="nn no gj gh gi np nq bd b be z dk translated">扩展4x4转换矩阵以模拟独立流程。</p></figure><p id="ab51" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在每次迭代中，我们首先扩展我们的转移矩阵。如果初始转移矩阵是N×N，那么我们新扩展的矩阵将是N * K×N * K，它捕获了我们的N个初始状态与K个新的可能状态的所有可能的相互作用。当有两个独立的进程时，一个例子是进程1处于隐藏状态0，进程2处于隐藏状态1。在此扩展之后，我们将相似的状态分组在一起(例如我们图中的绿色单元)。使用我们的示例，进程1处于隐藏状态0，进程2处于隐藏状态1，相当于进程1处于隐藏状态1，进程2处于隐藏状态0。在这个过程之后，我们新生成的矩阵的维数将是C×C，其中C等于来自K个可能状态中的P个独立过程的重复组合的数量。作为一个例子，对于4个隐藏状态和3个独立进程，C将等于20(Comb _ with _ repeation(4，3)= Comb(4+3–1，3) = 20)。</p><p id="6eeb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面是实现这一点的Python代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="9758" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">应该注意的是，这种算法实现起来并不那么简单，当进程数等于10时，一个简单(但可读性更好)的实现估计需要几周的运行时间。这一实施已经花费了大约2分钟来生成包含10个流程的转换矩阵，初始矩阵为4x4，对于5x5矩阵来说已经花费了更长的时间(因此我们仍然使用4x4)。</p><h2 id="2bfb" class="mv me iq bd mf mw mx dn mj my mz dp mn la na nb mp le nc nd mr li ne nf mt ng bi translated">在隐马尔可夫模型中引入记忆</h2><p id="9e27" class="pw-post-body-paragraph kr ks iq kt b ku nh jr kw kx ni ju kz la nj lc ld le nk lg lh li nl lk ll lm ij bi translated">我们自己实现了向前向后算法，这给了我们很大的自由度。我们对算法的普通实现尝试了许多不同的调整，但导致最显著改进的是内存的引入。当在向后传递中计算时间步长<code class="fe of og oh oi b">t</code>的概率时，我们使用向前传递的时间步长<code class="fe of og oh oi b">t</code>的计算概率:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/2115168dfbcef45e5c156b49cd15807f.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/0*k3rG36bLha9dpvIH"/></div><p class="nn no gj gh gi np nq bd b be z dk translated">计算后向概率(betas)。Psig是我们的发射概率，Ptran是我们的跃迁概率，c是系数(越高，前向概率的影响越大)。</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/47cf969338d822079475150e6b0c075f.png" data-original-src="https://miro.medium.com/v2/resize:fit:922/0*1Hi3mNzldPVqxzXj"/></div><p class="nn no gj gh gi np nq bd b be z dk translated">计算我们的未来概率。</p></figure><p id="e779" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">总的来说，我们执行三遍。一次向前传递，其中我们在下一次向后传递中使用alphas，最后一次向前传递使用我们新计算的betas。我们的Psig计算如下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/f1a1f60d2af58d603cd30a212d322192.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/0*2_CfMQsWt07y3NX_"/></div><p class="nn no gj gh gi np nq bd b be z dk translated">计算我们的Psig使用平均值为0的高斯分布和可以调整的sigma。这导致|状态|概率。</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on oo l"/></div><p class="nn no gj gh gi np nq bd b be z dk translated">我们的适应函数，用于向前和向后传递。对于反向传递，我们只是转置了转移矩阵并反转了信号。</p></figure><p id="c75d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae ln" href="https://github.com/GillesVandewiele/Liverpool-Ion-Switching/blob/master/notebooks/6%20-%20Custom%20Forward-Backward%20(Cat%203).ipynb" rel="noopener ugc nofollow" target="_blank">在这里可以找到这种定制的向前向后算法的工作示例。</a></p><h1 id="fe33" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">后处理</h1><h2 id="2b73" class="mv me iq bd mf mw mx dn mj my mz dp mn la na nb mp le nc nd mr li ne nf mt ng bi translated">后处理后验概率</h2><p id="5cd2" class="pw-post-body-paragraph kr ks iq kt b ku nh jr kw kx ni ju kz la nj lc ld le nk lg lh li nl lk ll lm ij bi translated">在我们的向前向后算法之后，我们剩下一个<code class="fe of og oh oi b">TxK</code>,它具有每个可能的隐藏状态和每个时间步长的概率。由于我们有多个对应于相同开放通道值的隐藏状态，我们需要另一个后处理步骤来将这些概率转换为预测。作为第一步，我们用我们的<code class="fe of og oh oi b">K</code>状态取每个时间步中我们的<code class="fe of og oh oi b">K</code>概率的点积，这与加权和相同，因此得到连续的值<code class="fe of og oh oi b">Y</code>。然后我们决定学习每一类和每一类数据的阈值。如果<code class="fe of og oh oi b">Y</code>落在两个阈值之间，那么它被分配到相应的类。</p><p id="1ff8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了确定这些阈值，我们使用了某种无人监管的技术。首先，我们过滤掉接近其舍入值的信号(因为这些信号中不存在大量噪声),并使用其舍入值作为标签。然后，我们确定这些舍入值的分布，并选择阈值，以便产生类似的分布。</p><p id="7df1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae ln" href="https://github.com/GillesVandewiele/Liverpool-Ion-Switching/blob/master/notebooks/7%20-%20Prediction%20Post-Processing%20(Cat%203).ipynb" rel="noopener ugc nofollow" target="_blank">请使用我们的后处理代码检查此笔记本。</a></p><h2 id="0a56" class="mv me iq bd mf mw mx dn mj my mz dp mn la na nb mp le nc nd mr li ne nf mt ng bi translated">一点混合</h2><p id="7ba3" class="pw-post-body-paragraph kr ks iq kt b ku nh jr kw kx ni ju kz la nj lc ld le nk lg lh li nl lk ll lm ij bi translated">这个HMM的许多变体已经在这个比赛的过程中被制造。我的队友Zidmie在他的脚本中使用了一个计数器，他最终是342(所以342个不同的脚本只由他自己编写)。在整个比赛过程中，我们不断提高我们的简历和公众LB分数。通常，连续版本之间的差异比CV分数的差异要大得多，这意味着新版本所做的改变并不都是正确的。因此，我们将前向-后向算法的不同输出混合在一起(通过使用它们的计算概率)。这给了我们一些边际增长。</p><h2 id="0d40" class="mv me iq bd mf mw mx dn mj my mz dp mn la na nb mp le nc nd mr li ne nf mt ng bi translated">结束语</h2><p id="d8fe" class="pw-post-body-paragraph kr ks iq kt b ku nh jr kw kx ni ju kz la nj lc ld le nk lg lh li nl lk ll lm ij bi translated">我对我们的最终结果感到非常自豪。我认为这个解决方案相当优雅，因为它不是你在Kaggle上经常看到的1001个不同模型的典型集合，而且它在不到一个小时内运行。我们也从未使用竞赛组织者的代码来创建额外的数据或对数据生成过程进行逆向工程。最后，我有点失望地掉了两个位置，因为一个漏洞被其他车队发现了，而不是我们。尽管如此，我在这次比赛中学到了很多，因为我以前从未使用过隐马尔可夫模型，并且认识了两个伟大而聪明的人！</p><p id="0a9b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">请关注这个页面，因为在接下来的几天里，它可能会收到一些小的更新。此外，我们正在努力发布我们的代码！</p><p id="fb8b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">再次感谢<a class="ae ln" href="https://www.kaggle.com/khahuras" rel="noopener ugc nofollow" target="_blank"> Kha Vo </a>和<a class="ae ln" href="https://www.kaggle.com/zidmie" rel="noopener ugc nofollow" target="_blank"> Zidmie </a>在这次比赛中有很多乐趣！</p><p id="2bb8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">致谢:</strong>作者感谢<a class="ae ln" href="https://www.kaggle.com/marcogorelli" rel="noopener ugc nofollow" target="_blank"> Marco Gorelli </a>的建设性反馈。</p><h2 id="9afb" class="mv me iq bd mf mw mx dn mj my mz dp mn la na nb mp le nc nd mr li ne nf mt ng bi translated">来源</h2><div class="oy oz gp gr pa pb"><a href="https://www.kaggle.com/c/liverpool-ion-switching/overview" rel="noopener  ugc nofollow" target="_blank"><div class="pc ab fo"><div class="pd ab pe cl cj pf"><h2 class="bd ir gy z fp pg fr fs ph fu fw ip bi translated">利物浦大学-离子交换</h2><div class="pi l"><h3 class="bd b gy z fp pg fr fs ph fu fw dk translated">确定每个时间点打开的通道数量</h3></div><div class="pj l"><p class="bd b dl z fp pg fr fs ph fu fw dk translated">www.kaggle.com</p></div></div><div class="pk l"><div class="pl l pm pn po pk pp kp pb"/></div></div></a></div><div class="oy oz gp gr pa pb"><a href="https://en.wikipedia.org/wiki/Ion_channel" rel="noopener  ugc nofollow" target="_blank"><div class="pc ab fo"><div class="pd ab pe cl cj pf"><h2 class="bd ir gy z fp pg fr fs ph fu fw ip bi translated">离子通道</h2><div class="pi l"><h3 class="bd b gy z fp pg fr fs ph fu fw dk translated">离子通道是成孔膜蛋白，允许离子通过通道孔。他们的功能…</h3></div><div class="pj l"><p class="bd b dl z fp pg fr fs ph fu fw dk translated">en.wikipedia.org</p></div></div><div class="pk l"><div class="pq l pm pn po pk pp kp pb"/></div></div></a></div><div class="oy oz gp gr pa pb"><a href="https://www.nature.com/articles/s42003-019-0729-3" rel="noopener  ugc nofollow" target="_blank"><div class="pc ab fo"><div class="pd ab pe cl cj pf"><h2 class="bd ir gy z fp pg fr fs ph fu fw ip bi translated">Deep-Channel使用深度神经网络从膜片钳数据中检测单分子事件</h2><div class="pi l"><h3 class="bd b gy z fp pg fr fs ph fu fw dk translated">努曼·切利克等人提出了一种深度学习模型，可以在嘈杂的环境中自动检测单分子事件</h3></div><div class="pj l"><p class="bd b dl z fp pg fr fs ph fu fw dk translated">www.nature.com</p></div></div><div class="pk l"><div class="pr l pm pn po pk pp kp pb"/></div></div></a></div><div class="oy oz gp gr pa pb"><a href="https://papers.nips.cc/paper/1144-factorial-hidden-markov-models" rel="noopener  ugc nofollow" target="_blank"><div class="pc ab fo"><div class="pd ab pe cl cj pf"><h2 class="bd ir gy z fp pg fr fs ph fu fw ip bi translated">阶乘隐马尔可夫模型</h2><div class="pi l"><h3 class="bd b gy z fp pg fr fs ph fu fw dk translated">神经信息处理系统电子会议录</h3></div><div class="pj l"><p class="bd b dl z fp pg fr fs ph fu fw dk translated">papers.nips.cc</p></div></div></div></a></div><div class="oy oz gp gr pa pb"><a href="https://github.com/hmmlearn/hmmlearn" rel="noopener  ugc nofollow" target="_blank"><div class="pc ab fo"><div class="pd ab pe cl cj pf"><h2 class="bd ir gy z fp pg fr fs ph fu fw ip bi translated">hmmlearn/hmmlearn</h2><div class="pi l"><h3 class="bd b gy z fp pg fr fs ph fu fw dk translated">hmmlearn是一组用于隐马尔可夫模型的无监督学习和推理的算法。对于受监督的…</h3></div><div class="pj l"><p class="bd b dl z fp pg fr fs ph fu fw dk translated">github.com</p></div></div><div class="pk l"><div class="ps l pm pn po pk pp kp pb"/></div></div></a></div></div></div>    
</body>
</html>