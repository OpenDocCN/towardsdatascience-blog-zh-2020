<html>
<head>
<title>The CartPole Problem — Competitive Performance With Particle Swarm Optimization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">标杆问题——粒子群优化算法的竞争性能</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-cartepole-problem-competitive-performance-with-particle-swarm-optimization-672f018ede3c?source=collection_archive---------46-----------------------#2020-06-23">https://towardsdatascience.com/the-cartepole-problem-competitive-performance-with-particle-swarm-optimization-672f018ede3c?source=collection_archive---------46-----------------------#2020-06-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d7bc" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">粒子群元启发式算法在并行深度学习中的性能</h2></div><p id="b107" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">OpenAI 的 CartPole 问题是强化学习中的一个主要问题，它是许多 RL 最先进算法应用的基准。然而，并不是只有 RL 算法可以解决控制问题。在这篇文章中，我将概述粒子群优化算法(PSO)；它如何应用于控制问题，以及它如何与深度 Q 学习相比较。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lc"><img src="../Images/5a7997113fad66d2ec78cb5ebdbdf518.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*han2jqTAybAscbiGqW925Q.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated"><a class="ae lb" href="https://unsplash.com/@citychurchchristchurch" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="3a53" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你想了解我为这篇文章编写的所有代码，可以在这个 Jupyter 笔记本上看到:<a class="ae lb" href="https://github.com/adamprice97/Control/blob/master/PSOCartpole.ipynb" rel="noopener ugc nofollow" target="_blank">https://github . com/Adam price 97/Control/blob/master/psocartpole . ipynb</a></p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="eebd" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">什么是粒子群优化？</h1><p id="59d4" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">粒子群优化是一种元启发式优化算法。元启发式算法搜索给定函数的最大(或最小)值，而不需要函数的太多先验知识。</p><p id="aba7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">粒子群通过在搜索空间中移动粒子进行优化。在离散的时间步骤，通过使用粒子的位置作为适应度函数(该函数被优化)的参数来评估粒子。然后，粒子被吸引向全局最佳解(由群中的另一个粒子找到)和他们找到的最佳解。</p><p id="6286" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">PSO 是无梯度的，这使得它可以快速地执行更新(当使用大群体时很有用)，但是，它不能保证收敛到局部最小值(或最大值)。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/20dc86217724509de8d3c3db8772f7e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/1*BCdU1fXUPPe7lzO21cxsCg.gif"/></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">PSO 在行动。By <a class="ae lb" href="https://commons.wikimedia.org/wiki/User:Ephramac" rel="noopener ugc nofollow" target="_blank">伊弗马克</a>。</p></figure><p id="b147" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">单个粒子的速度由 3 个参数控制:</p><ul class=""><li id="583d" class="mx my iq kh b ki kj kl km ko mz ks na kw nb la nc nd ne nf bi translated">全球权重(φᵍ) —全球最佳解决方案所在地的吸引力。</li><li id="e351" class="mx my iq kh b ki ng kl nh ko ni ks nj kw nk la nc nd ne nf bi translated">局部权重(φˡ) —粒子最佳解决方案位置的吸引力。</li><li id="e438" class="mx my iq kh b ki ng kl nh ko ni ks nj kw nk la nc nd ne nf bi translated">惯性(ω)——粒子改变轨迹的难易程度。</li></ul><p id="1858" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还需要为算法提供:搜索空间边界(阻止粒子离开搜索空间)；优化的适应度函数；和要使用的粒子数量。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nl nm l"/></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">我的 PSO 的 python 实现。</p></figure><h1 id="2361" class="lz ma iq bd mb mc nn me mf mg no mi mj jw np jx ml jz nq ka mn kc nr kd mp mq bi translated">粒子群算法在横竿问题中的应用</h1><p id="af38" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">我们创建的 PSO 框架非常灵活。我们只需要给它传递一个函数 f(θ)，其中θ是一个参数向量，它会试图找到使函数最大化的θ。</p><p id="44d5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了将粒子群算法应用于横竿问题，我们需要使用粒子在搜索空间中的位置，来生成横竿问题要遵循的策略。为此，我们使用具有两个输出的线性网络，这两个输出通过 softmax 函数来创建随机策略。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi ns"><img src="../Images/55730e60da9e6033075c9d5a4646ed3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vBWYOYbTRlQCHttqXNEMMQ.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">π(a，s θ)</p></figure><p id="6659" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用小车的当前状态作为输入层，粒子的位置作为权重，我们产生选择两个动作(向左或向右移动小车)的概率。</p><p id="4549" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">粒子位置的适合度由策略的性能(奖励累积)给出。环境的初始状态是随机的，因此我们必须针对多个事件评估策略，以获得对策略质量的估计。这在某些环境中可能被证明是低效，但是运行 CartPole 到终端在计算上是非常便宜的。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="7bbf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了这些，我们就可以开始实验了！</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h1 id="eb63" class="lz ma iq bd mb mc nn me mf mg no mi mj jw np jx ml jz nq ka mn kc nr kd mp mq bi translated">表演</h1><p id="bbb0" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">当我们运行上面的脚本时，我们发现 CartPole 问题在平均 2.4 次迭代中得到解决。与其他学习方法相比，这是非常少的迭代。优化良好的深度 Q 学习方法往往需要大约 30 次迭代来求解 CartPole。</p><p id="0599" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么 PSO 有没有胜过深度学习方法呢？</p><p id="763d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要记住使用的蜂群。在标准 RL 实现中，使用单个代理，它每次迭代只能运行单个剧集。我们的群每次迭代有效地运行 15 集，因此可以说 PSO 实际上用了 36 (2.4*15)集来解决问题。这和 deep Q 差不多。</p><p id="5ba9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一方面，单个 RL 代理比单个 swarm 代理需要更多的计算。在深度学习实现的情况下，每个时间步长可能会有 1000 个权重被更新。相比之下，我们整个群体在每集之间优化了 120 (8*15)个权重。</p><p id="9ac7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">也许我们可以根据找到解决方案所需的时间来比较不同的方法？但是我们需要考虑计算机架构。深度方法受益于 GPU，而粒子群算法将受益于并行计算。</p><p id="b186" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最终，很难准确地比较这些不同的方法。但是，我确实认为我们已经设法为控制中的元启发式的进一步研究提供了一个很好的案例。</p></div></div>    
</body>
</html>