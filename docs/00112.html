<html>
<head>
<title>Heteroscedasticity is nothing to be afraid of</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">异方差没有什么可怕的</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/heteroscedasticity-is-nothing-to-be-afraid-of-730dd3f7ca1f?source=collection_archive---------4-----------------------#2020-01-04">https://towardsdatascience.com/heteroscedasticity-is-nothing-to-be-afraid-of-730dd3f7ca1f?source=collection_archive---------4-----------------------#2020-01-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/9b1a9bff82f435f78ab70b8f14473576.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ij8bs7kdgkF15x33A1dPUA.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">(图片由<a class="ae jg" href="https://sachin-date.medium.com/" rel="noopener">作者</a>提供)</p></figure><div class=""/><div class=""><h2 id="ddf7" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">使用 Python 的原因、影响、测试和解决方案</h2></div></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><p id="ff3f" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">回归建模环境中的异方差，是指当数据中的<em class="mb">条件方差</em>不恒定时，数据中的异方差。条件方差是你在因变量<strong class="lh jk"> <em class="mb"> y </em> </strong>中看到的解释变量<strong class="lh jk"> <em class="mb"> X </em> </strong>的每一个值，或者时间段<strong class="lh jk"><em class="mb"/></strong>的每一个值的可变性(对于时间序列数据)。</p><p id="a444" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">条件方差表示为<em class="mb">方差(</em><strong class="lh jk"><em class="mb">y</em></strong><em class="mb">|</em><strong class="lh jk"><em class="mb">X</em></strong><em class="mb">)、Var(</em><strong class="lh jk"><em class="mb">y</em></strong><em class="mb">|</em><strong class="lh jk"><em class="mb">×σ(</em><strong class="lh jk"><em class="mb">y</em></strong><em class="mb">|<em class="mb">)并且对于给定的<strong class="lh jk"><em class="mb">【X】</em></strong>(或<strong class="lh jk"> <em class="mb"> t </em> </strong>)值，读取为<strong class="lh jk"> <em class="mb"> y </em> </strong>中看到的方差。</em></em></strong></p><p id="0d63" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">当您的数据是异方差的:</p><p id="90a4" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><em class="mb">方差(</em><strong class="lh jk"><em class="mb">y</em></strong><em class="mb">|</em><strong class="lh jk"><em class="mb">X</em></strong><em class="mb">)= f(</em><strong class="lh jk"><em class="mb">X</em></strong><em class="mb">)</em></p><p id="a45a" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">其中<em class="mb"> f </em>是<strong class="lh jk">XT115】的某个函数。异方差的反义词是<strong class="lh jk">同方差</strong>，其中方差是常数，即:</strong></p><p id="3998" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><em class="mb">方差(</em><strong class="lh jk"><em class="mb">y</em></strong><em class="mb">|</em><strong class="lh jk"><em class="mb">X</em></strong><em class="mb">)=σ…一个常数值。</em></p><p id="5f76" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">下图说明了异方差数据集:</p><figure class="mc md me mf gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/9b1a9bff82f435f78ab70b8f14473576.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ij8bs7kdgkF15x33A1dPUA.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">异方差(图片由<a class="ae jg" href="https://sachin-date.medium.com/" rel="noopener">作者</a>提供)</p></figure><p id="cab5" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">下图说明了一个同质数据集:</p><figure class="mc md me mf gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/ec57dab56278f11d3a0fff7e1b046514.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oy8od7F8VaXARwHyM3DhOw.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">同方差(图片由<a class="ae jg" href="https://sachin-date.medium.com/" rel="noopener">作者</a>提供)</p></figure></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h2 id="e652" class="mg mh jj bd mi mj mk dn ml mm mn dp mo lo mp mq mr ls ms mt mu lw mv mw mx my bi translated">异方差时间序列</h2><p id="d419" class="pw-post-body-paragraph lf lg jj lh b li mz kk lk ll na kn ln lo nb lq lr ls nc lu lv lw nd ly lz ma im bi translated">下面的黄金价格指数图说明了异方差时间序列。请注意，当指数值较高时，后期的变化会更大。</p><figure class="mc md me mf gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ne"><img src="../Images/5b8d73e56e8fd69995acb7e078e943b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h3DurtuC5ZKlEHIUmievog.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">出口价格指数(最终用途):非货币黄金(来源:<a class="ae jg" href="https://fred.stlouisfed.org/series/IQ12260#0" rel="noopener ugc nofollow" target="_blank">美国弗雷德</a>)(图片由<a class="ae jg" href="https://sachin-date.medium.com/" rel="noopener">作者</a>提供)</p></figure><p id="5ed1" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">黄金价格指数的第一个差异带来了异方差:</p><figure class="mc md me mf gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nf"><img src="../Images/2c82d636d34f66b9584bd5129e270039.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I-6IosowRewTgYAru2q5gA.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">不同的时间序列(图片由<a class="ae jg" href="https://sachin-date.medium.com/" rel="noopener">作者</a>提供)</p></figure></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h2 id="ca63" class="mg mh jj bd mi mj mk dn ml mm mn dp mo lo mp mq mr ls ms mt mu lw mv mw mx my bi translated">异方差的原因和形式</h2><p id="e2a1" class="pw-post-body-paragraph lf lg jj lh b li mz kk lk ll na kn ln lo nb lq lr ls nc lu lv lw nd ly lz ma im bi translated">异方差的一种常见形式是波动量是值的一部分。货币数据通常会出现这种情况，例如:</p><ul class=""><li id="1a63" class="ng nh jj lh b li lj ll lm lo ni ls nj lw nk ma nl nm nn no bi translated">价格(股票价格、商品价格、医疗程序成本)，</li><li id="f17f" class="ng nh jj lh b li np ll nq lo nr ls ns lw nt ma nl nm nn no bi translated">支出(家庭支出、雇员工资、租金)，</li><li id="d300" class="ng nh jj lh b li np ll nq lo nr ls ns lw nt ma nl nm nn no bi translated">价格指数(上面举例说明的黄金价格指数)。</li></ul><h2 id="d15e" class="mg mh jj bd mi mj mk dn ml mm mn dp mo lo mp mq mr ls ms mt mu lw mv mw mx my bi translated">测量过程引入的异方差</h2><p id="a6ec" class="pw-post-body-paragraph lf lg jj lh b li mz kk lk ll na kn ln lo nb lq lr ls nc lu lv lw nd ly lz ma im bi translated">创建数据集时，可能会无意中引入异方差。让我们用一个例子来说明这一点:</p><p id="e886" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">假设您正在测量注入抗生素的样本中的细菌生长。我们假设样本中的细菌呈线性增长，如下所示:</p><pre class="mc md me mf gt nu nv nw nx aw ny bi"><span id="af79" class="mg mh jj nv b gy nz oa l ob oc"><em class="mb">Actual_Bacterial_Count = 100 + 5*Time_Period</em></span></pre><p id="7adf" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">假设你的细胞计数器计数误差≤ 10%。可以将其操作特性建模如下:</p><pre class="mc md me mf gt nu nv nw nx aw ny bi"><span id="2e31" class="mg mh jj nv b gy nz oa l ob oc"><em class="mb">Observed_Bacterial_Count = 100 + 5*Time_Period + <br/></em><strong class="nv jk"><em class="mb">ROUND( (-1.0+2*RAND(0,1))*0.1*True_Bacterial_Count,0)</em></strong></span></pre><p id="4fa0" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">计数器引入的误差(在 MS Excel 语法中)为:<br/><strong class="lh jk"><em class="mb">ROUND((-1.0+2 * RAND(0，1))*0.1*True_Bacterial_Count，0) </em> </strong></p><p id="7fc0" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">术语<strong class="lh jk"> <em class="mb"> ( -1.0+2*RAND(0，1) ) </em> </strong>表示具有<em class="mb">(-1，1) </em>均匀分布的随机变量，乘以真实计数的 10%。</p><p id="38c3" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">运行计数器 150 个时间周期会产生下面的图，显示由计数器的误差特性引入的异方差:</p><figure class="mc md me mf gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi od"><img src="../Images/d60c9eb6a707ef5af38d28966a730a98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gmDTtpkZlPh8gKt0yJK6Ag.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">测量误差引入的异方差(图片由<a class="ae jg" href="https://sachin-date.medium.com/" rel="noopener">作者</a>提供)</p></figure><p id="3d47" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><strong class="lh jk">如何解决问题:</strong></p><ul class=""><li id="71c5" class="ng nh jj lh b li lj ll lm lo ni ls nj lw nk ma nl nm nn no bi translated">对数转换<strong class="lh jk"> <em class="mb"> y </em> </strong>变量以‘抑制’一些异方差，然后为<em class="mb">对数(</em><strong class="lh jk"><em class="mb">y</em></strong><em class="mb">)</em>建立一个 OLSR 模型。</li><li id="9646" class="ng nh jj lh b li np ll nq lo nr ls ns lw nt ma nl nm nn no bi translated">使用一个<strong class="lh jk"> G </strong>一般化<strong class="lh jk"> L </strong>线性<strong class="lh jk"> M </strong>模型(<strong class="lh jk"> GLM </strong>)，例如负二项式回归模型，它不假设数据集是同质的。如果你的数据是离散的和非负的，NB 回归模型会特别有效。</li><li id="62c2" class="ng nh jj lh b li np ll nq lo nr ls ns lw nt ma nl nm nn no bi translated">使用一个<strong class="lh jk"> W </strong>八个<strong class="lh jk"> L </strong>东<strong class="lh jk"> S </strong>方(<strong class="lh jk"> WLS </strong>)或一个<strong class="lh jk"> G </strong>一般化<strong class="lh jk"> L </strong>东<strong class="lh jk"> S </strong>方(<strong class="lh jk"> GLS </strong>)模型——这两个模型不假设均方误差。<em class="mb"> Python statsmodels </em>包支持<a class="ae jg" href="https://www.statsmodels.org/stable/index.html" rel="noopener ugc nofollow" target="_blank"><em class="mb">stats models . API</em></a>包中的两种模型。</li></ul><h2 id="de55" class="mg mh jj bd mi mj mk dn ml mm mn dp mo lo mp mq mr ls ms mt mu lw mv mw mx my bi translated">异方差引入了季节性异常值和通货膨胀</h2><p id="5e17" class="pw-post-body-paragraph lf lg jj lh b li mz kk lk ll na kn ln lo nb lq lr ls nc lu lv lw nd ly lz ma im bi translated">以下酒类销售的时间序列图说明了由 12 月和 1 月的异常值以及月度价格上涨的影响引起的缓慢增长的差异:</p><figure class="mc md me mf gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oe"><img src="../Images/d3d62f5620f1854afb3d82178fb0e37d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZCot0VhZr0U_mvKmltH2-w.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">零售:啤酒、葡萄酒和酒类商店。(图片来源:美国弗雷德)(图片由<a class="ae jg" href="https://sachin-date.medium.com/" rel="noopener">作者</a>)</p></figure><p id="8abf" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><strong class="lh jk">如何解决问题:</strong></p><ul class=""><li id="a6c7" class="ng nh jj lh b li lj ll lm lo ni ls nj lw nk ma nl nm nn no bi translated">季节性影响可以通过对数据集进行季节性调整来抵消。</li><li id="5c26" class="ng nh jj lh b li np ll nq lo nr ls ns lw nt ma nl nm nn no bi translated">通货膨胀的影响可以通过对时间序列进行通货膨胀调整来消除。</li></ul><pre class="mc md me mf gt nu nv nw nx aw ny bi"><span id="3f89" class="mg mh jj nv b gy nz oa l ob oc"><strong class="nv jk">Related post:</strong> <a class="ae jg" rel="noopener" target="_blank" href="/the-what-and-why-of-inflation-adjustment-5eedb496e080">How to Deflate Your Time Series</a></span></pre><p id="0945" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">在处理诸如销售量、成本、价格指数等货币数据时，应该始终考虑这两个数据转换步骤。</p><h2 id="f0ff" class="mg mh jj bd mi mj mk dn ml mm mn dp mo lo mp mq mr ls ms mt mu lw mv mw mx my bi translated">缺失指定模型引入的异方差</h2><p id="fb24" class="pw-post-body-paragraph lf lg jj lh b li mz kk lk ll na kn ln lo nb lq lr ls nc lu lv lw nd ly lz ma im bi translated">即使在执行季节调整、紧缩和对数转换之后，如果您的模型无法充分解释经<em class="mb">转换的</em>数据集中的方差，无法解释的方差将会泄漏到模型的剩余误差中，潜在地使它们成为异方差的。</p><p id="7c08" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><strong class="lh jk">如何解决问题:</strong></p><ul class=""><li id="60f4" class="ng nh jj lh b li lj ll lm lo ni ls nj lw nk ma nl nm nn no bi translated">检查您的模型中是否缺少重要的解释变量，并将它们添加进来。</li><li id="45f2" class="ng nh jj lh b li np ll nq lo nr ls ns lw nt ma nl nm nn no bi translated">切换到 GLM、WSS 或 GLS 模式</li><li id="c4b2" class="ng nh jj lh b li np ll nq lo nr ls ns lw nt ma nl nm nn no bi translated"><em class="mb">接受你目前的模型。如果您的模型在其他方面表现良好，那么模型残差中的少量异方差是可以接受的。</em></li></ul></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h2 id="918b" class="mg mh jj bd mi mj mk dn ml mm mn dp mo lo mp mq mr ls ms mt mu lw mv mw mx my bi translated">异方差的实际后果</h2><p id="3bca" class="pw-post-body-paragraph lf lg jj lh b li mz kk lk ll na kn ln lo nb lq lr ls nc lu lv lw nd ly lz ma im bi translated">如果线性回归模型的残差是异方差的，例如线性回归模型的残差是异方差的，那么 OLSR 模型就不再是 T42 有效的，也就是说，它不能保证是数据的最佳无偏线性估计。有可能构造具有更好拟合优度的不同估计量。</p><p id="cb91" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">如果您的数据包含异方差，OLSR 模型可能会低估或高估<em class="mb">总体</em>中的方差，这取决于它在训练样本中看到的方差类型。</p><p id="217d" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">这导致了一系列问题:模型参数的标准误差变得不正确，导致它们的 p 值出错，置信区间过窄或过宽。这可能会误导您相信某些参数值是重要的，而实际上它们并不重要，反之亦然。整个模型变得不可靠。</p><p id="a3bf" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">这个问题不仅限于 OLSR 车型。任何假设均方数据或均方残差的模型都容易受到这些问题的影响。</p></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h2 id="4d9f" class="mg mh jj bd mi mj mk dn ml mm mn dp mo lo mp mq mr ls ms mt mu lw mv mw mx my bi translated">如何检测异方差</h2><p id="6300" class="pw-post-body-paragraph lf lg jj lh b li mz kk lk ll na kn ln lo nb lq lr ls nc lu lv lw nd ly lz ma im bi translated">首先绘制因变量与自变量或时间的关系图，寻找因变量变化遵循某种模式的迹象。</p><p id="fba4" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">另一种方法是根据数据训练一个合适的模型，并根据因变量绘制其残差，再次寻找可变性的模式。</p><p id="aa8f" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">第三种更好的方法是使用以下异方差统计测试之一:</p><ul class=""><li id="58cc" class="ng nh jj lh b li lj ll lm lo ni ls nj lw nk ma nl nm nn no bi translated"><a class="ae jg" href="https://en.wikipedia.org/wiki/Park_test" rel="noopener ugc nofollow" target="_blank">停车测试</a></li><li id="47fd" class="ng nh jj lh b li np ll nq lo nr ls ns lw nt ma nl nm nn no bi translated"><a class="ae jg" href="https://en.wikipedia.org/wiki/Glejser_test" rel="noopener ugc nofollow" target="_blank">格雷泽测试</a></li><li id="22e8" class="ng nh jj lh b li np ll nq lo nr ls ns lw nt ma nl nm nn no bi translated"><a class="ae jg" href="https://en.wikipedia.org/wiki/Breusch%E2%80%93Pagan_test" rel="noopener ugc nofollow" target="_blank">布鲁赫-异教徒测试</a></li><li id="20ba" class="ng nh jj lh b li np ll nq lo nr ls ns lw nt ma nl nm nn no bi translated"><a class="ae jg" href="https://en.wikipedia.org/wiki/White_test" rel="noopener ugc nofollow" target="_blank">白色测试</a></li><li id="21ac" class="ng nh jj lh b li np ll nq lo nr ls ns lw nt ma nl nm nn no bi translated"><a class="ae jg" href="https://en.wikipedia.org/wiki/Goldfeld%E2%80%93Quandt_test" rel="noopener ugc nofollow" target="_blank">戈德菲尔德–匡特测试</a></li></ul><blockquote class="of og oh"><p id="b899" class="lf lg mb lh b li lj kk lk ll lm kn ln oi lp lq lr oj lt lu lv ok lx ly lz ma im bi translated">我们很快就会看到如何在黄金价格数据集上运行<strong class="lh jk">Python<strong class="lh jk">中的</strong>异方差白色测试。</strong></p></blockquote><p id="ee21" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">同时，让我们看看这些测试是如何工作的。他们中的大多数使用下面的标准方法来检测异方差:</p><ol class=""><li id="10b9" class="ng nh jj lh b li lj ll lm lo ni ls nj lw nk ma ol nm nn no bi translated">根据数据训练一个合适的<em class="mb">主</em>回归模型。</li><li id="d3d7" class="ng nh jj lh b li np ll nq lo nr ls ns lw nt ma ol nm nn no bi translated">接下来，在主模型的残差平方上拟合一个<em class="mb">辅助</em>回归模型，解释变量是主模型的解释变量，或者这些变量的某种组合。上述测试使用以下一个或多个回归表达式作为辅助模型:<br/><strong class="lh jk"><em class="mb">ϵ</em></strong><em class="mb">=</em><strong class="lh jk"><em class="mb">β_ 0</em></strong><em class="mb">+</em><strong class="lh jk"><em class="mb">β_ 1</em></strong><em class="mb">*</em><strong class="lh jk"><em class="mb">x</em></strong><em class="mb">+</em><strong class="lh jk"><em class="mb">γ</em></strong><em class="mb"><em class="mb"> </em><strong class="lh jk"><em class="mb">x</em></strong><em class="mb">+</em><strong class="lh jk"><em class="mb">β_ 2</em></strong><em class="mb">*</em><strong class="lh jk"><em class="mb">x</em></strong><em class="mb">+</em><strong class="lh jk"><em class="mb">γ<br/>ϵ</em></strong><em class="mb">=</em><strong class="lh jk"><em class="mb">β_ 1 </em><strong class="lh jk">√<em class="mb"/></strong><em class="mb">+</em><strong class="lh jk"><em class="mb">γ<br/>【ϵ】</em></strong><em class="mb">=</em><strong class="lh jk"><em class="mb">β_ 0</em></strong><em class="mb">+</em><strong class="lh jk"><em class="mb">β_ 1/x</em></strong><em class="mb">+</em><strong class="lh jk"><em class="mb"> <br/><strong class="lh jk"><em class="mb">β_ 1</em></strong>是回归系数的向量，<br/> <strong class="lh jk"> <em class="mb"> X </em> </strong>是主模型的解释变量矩阵，<br/> <strong class="lh jk"> <em class="mb"> γ </em> </strong>是误差项的向量。</em></strong></strong></em></li><li id="2a8b" class="ng nh jj lh b li np ll nq lo nr ls ns lw nt ma ol nm nn no bi translated">对于拟合的辅助模型，计算合适的拟合优度统计量，例如用于回归分析的<strong class="lh jk"> R </strong>或<a class="ae jg" rel="noopener" target="_blank" href="/fisher-test-for-regression-analysis-1e1687867259"> <strong class="lh jk"> F 统计量</strong> </a>，以查看残差与主模型的解释变量的拟合程度。</li><li id="7dd2" class="ng nh jj lh b li np ll nq lo nr ls ns lw nt ma ol nm nn no bi translated">如果检验统计量<strong class="lh jk">没有</strong>显示显著的拟合优度，则接受残差是同方差的零假设。否则，接受残差是异方差的替代假设，这反过来意味着 1)主要模型的<strong class="lh jk"> <em class="mb"> y </em> </strong>的条件方差是异方差的，或者 2)我们的主要模型是未指定的，或者 3)(1)和(2)都成立。</li></ol></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h2 id="3631" class="mg mh jj bd mi mj mk dn ml mm mn dp mo lo mp mq mr ls ms mt mu lw mv mw mx my bi translated">使用 Python 和 statsmodels 测试异方差性</h2><p id="41b7" class="pw-post-body-paragraph lf lg jj lh b li mz kk lk ll na kn ln lo nb lq lr ls nc lu lv lw nd ly lz ma im bi translated">让我们使用 Python 在黄金价格指数数据集上运行<strong class="lh jk">白色测试</strong>来检验异方差性(在这里找到<a class="ae jg" href="https://gist.github.com/sachinsdate/c2a92fd009c62fee9364c835aff7e2f0" rel="noopener ugc nofollow" target="_blank"/>)。</p><p id="1622" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">导入所有必需的包。</p><pre class="mc md me mf gt nu nv nw nx aw ny bi"><span id="7770" class="mg mh jj nv b gy nz oa l ob oc">import pandas as pd</span><span id="1155" class="mg mh jj nv b gy om oa l ob oc">import numpy as np</span><span id="f8e7" class="mg mh jj nv b gy om oa l ob oc">from matplotlib import pyplot as plt</span></pre><h2 id="7251" class="mg mh jj bd mi mj mk dn ml mm mn dp mo lo mp mq mr ls ms mt mu lw mv mw mx my bi translated">加载数据集并绘制因变量</h2><p id="fcff" class="pw-post-body-paragraph lf lg jj lh b li mz kk lk ll na kn ln lo nb lq lr ls nc lu lv lw nd ly lz ma im bi translated">将数据集加载到 pandas 数据框中，并打印前 10 行:</p><pre class="mc md me mf gt nu nv nw nx aw ny bi"><span id="f393" class="mg mh jj nv b gy nz oa l ob oc">df = pd.read_csv('monthly_gold_price_index_fred.csv', header=0, infer_datetime_format=True, parse_dates=[0], index_col=[0])</span><span id="d7c3" class="mg mh jj nv b gy om oa l ob oc">print(df.head(10))</span></pre><figure class="mc md me mf gt iv gh gi paragraph-image"><div class="gh gi on"><img src="../Images/409c8703d8945de513f4501b41e14800.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/format:webp/1*bBfESlCCQ33eRkdE6ynk0Q.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">(图片由<a class="ae jg" href="https://sachin-date.medium.com/" rel="noopener">作者</a>)</p></figure><p id="5d77" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">我们将向名为<strong class="lh jk"> Time_Period </strong>的数据帧添加一个新列，包含从 1 到 132 的整数。</p><pre class="mc md me mf gt nu nv nw nx aw ny bi"><span id="0a85" class="mg mh jj nv b gy nz oa l ob oc">df['Time_Period'] = range(1, len(df)+1)</span><span id="7e08" class="mg mh jj nv b gy om oa l ob oc">print(df.head(10))</span></pre><figure class="mc md me mf gt iv gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/d6f179831032021ef4cdaeff8b49e541.png" data-original-src="https://miro.medium.com/v2/resize:fit:1306/format:webp/1*9NGJWupeuUs-WJ2zdUvLkg.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">(图片由<a class="ae jg" href="https://sachin-date.medium.com/" rel="noopener">作者</a>提供)</p></figure><p id="54fe" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">绘制数据:</p><pre class="mc md me mf gt nu nv nw nx aw ny bi"><span id="e007" class="mg mh jj nv b gy nz oa l ob oc"><strong class="nv jk">#Create a new mpyplot figure to plot into</strong><br/>fig = plt.figure()</span><span id="b0c6" class="mg mh jj nv b gy om oa l ob oc"><strong class="nv jk">#Set the title of the plot<br/></strong>fig.suptitle('Export Price Index of Gold')</span><span id="d483" class="mg mh jj nv b gy om oa l ob oc">#Set the X and Y axis labels<br/>plt.xlabel('Time Period')<br/>plt.ylabel('Price Index')</span><span id="9479" class="mg mh jj nv b gy om oa l ob oc"><strong class="nv jk">#plot the time series and store the plot in the <em class="mb">actual</em> variable. We'll need that later for the legend.<br/></strong>actual, = plt.plot(df['Time_Period'], df['Export_Price_Index_of_Gold'], 'bo-', label='Gold Price Index')</span><span id="72da" class="mg mh jj nv b gy om oa l ob oc"><strong class="nv jk">#Set up the legend. There is only one time series in the legend.<br/></strong>plt.legend(handles=[actual])</span><span id="b7f4" class="mg mh jj nv b gy om oa l ob oc"><strong class="nv jk">#Show everything<br/></strong>plt.show()</span></pre><p id="2cd6" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">这是我们得到的图:</p><figure class="mc md me mf gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi op"><img src="../Images/5831f81cec401eb1055f965f06c57d0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bVWEAfDQHSGewhPiSfedow.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">从 2001 年 1 月到 2011 年 12 月连续 132 个月的黄金出口价格指数(图片由<a class="ae jg" href="https://sachin-date.medium.com/" rel="noopener">作者</a>提供)</p></figure><pre class="mc md me mf gt nu nv nw nx aw ny bi"><span id="bf77" class="mg mh jj nv b gy nz oa l ob oc"><strong class="nv jk">The price data appears to be both heteroscedastic and nonlinear.</strong></span></pre><h2 id="b64e" class="mg mh jj bd mi mj mk dn ml mm mn dp mo lo mp mq mr ls ms mt mu lw mv mw mx my bi translated">取因变量的对数变换</h2><p id="7841" class="pw-post-body-paragraph lf lg jj lh b li mz kk lk ll na kn ln lo nb lq lr ls nc lu lv lw nd ly lz ma im bi translated">对因变量进行对数变换是最常用的技术之一，不仅可以使因变量<strong class="lh jk"><em class="mb"/></strong>线性化，还可以抑制<strong class="lh jk"> <em class="mb"> y </em> </strong> <em class="mb">中的异方差(如果存在)。</em></p><p id="61ac" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">让我们向名为 LOG _<em class="mb">Export _ Price _ Index _ of _ Gold</em>的数据框添加一个新列，其中包含。我们将使用<em class="mb"> numpy.log() </em>来完成这项工作。</p><pre class="mc md me mf gt nu nv nw nx aw ny bi"><span id="c53f" class="mg mh jj nv b gy nz oa l ob oc">df['LOG_Export_Price_Index_of_Gold'] = np.log(df['Export_Price_Index_of_Gold'])</span></pre><p id="425f" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">原始数据和对数变换数据的并排比较揭示了对数变换降低了时间序列中的非线性:</p><figure class="mc md me mf gt iv gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/e2acbda03b06f3f63d90facd59e2ad0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*j5977q1XikvNdymXI9mDEQ.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">原始和对数转换价格指数数据的比较(图片由<a class="ae jg" href="https://sachin-date.medium.com/" rel="noopener">作者</a>提供)</p></figure><h2 id="74bc" class="mg mh jj bd mi mj mk dn ml mm mn dp mo lo mp mq mr ls ms mt mu lw mv mw mx my bi translated">将 OLS 线性回归模型拟合到经对数变换的数据集</h2><p id="3e33" class="pw-post-body-paragraph lf lg jj lh b li mz kk lk ll na kn ln lo nb lq lr ls nc lu lv lw nd ly lz ma im bi translated">如果你还记得我们之前概述的测试配方，我们称这个模型为我们的<strong class="lh jk">主模型</strong>。</p><p id="6f02" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">我们主要模型的回归表达式为:</p><p id="875f" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><strong class="lh jk"><em class="mb">log _ export _ price _ index _ of _ gold</em></strong><em class="mb">=</em><strong class="lh jk"><em class="mb">β_ 0</em></strong><em class="mb">+</em><strong class="lh jk"><em class="mb">β_ 1</em></strong><em class="mb">*</em><strong class="lh jk"><em class="mb">time _ period</em></strong><em class="mb">+</em><strong class="lh jk"><em class="mb">ϵ</em></strong></p><p id="257b" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">即我们正在寻求预测<em class="mb">log(</em><strong class="lh jk"><em class="mb">Export _ Price _ Index _ of _ Gold</em></strong><em class="mb">)</em><strong class="lh jk"><em class="mb"/></strong>使用<strong class="lh jk"> <em class="mb"> Time_Period </em> </strong>)。</p><p id="e39f" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">导入回归包:</p><pre class="mc md me mf gt nu nv nw nx aw ny bi"><span id="8e18" class="mg mh jj nv b gy nz oa l ob oc"><strong class="nv jk">import </strong>statsmodels.api <strong class="nv jk">as </strong>sm<br/><strong class="nv jk">import </strong>statsmodels.formula.api <strong class="nv jk">as </strong>smf<br/><strong class="nv jk">from </strong>patsy <strong class="nv jk">import </strong>dmatrices</span></pre><p id="18b5" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">在<a class="ae jg" href="https://patsy.readthedocs.io/en/latest/quickstart.html" rel="noopener ugc nofollow" target="_blank"> patsy 语法</a>中形成模型表达式。我们告诉 Patsy<em class="mb">LOG _ Export _ Price _ Index _ of _ Gold</em>依赖于<em class="mb"> Time_Period </em>。Patsy 将自动包含截距<em class="mb"> β_0 </em>:</p><pre class="mc md me mf gt nu nv nw nx aw ny bi"><span id="8bb5" class="mg mh jj nv b gy nz oa l ob oc">expr = 'LOG_Export_Price_Index_of_Gold ~ Time_Period'</span></pre><p id="9837" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">建立和培训 OLSR 模型:</p><pre class="mc md me mf gt nu nv nw nx aw ny bi"><span id="7676" class="mg mh jj nv b gy nz oa l ob oc">olsr_results = smf.ols(expr, df).fit()</span></pre><p id="9727" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">相对于<em class="mb">时间段</em>绘制剩余误差(存储在<code class="fe or os ot nv b"><em class="mb">olsr_results.resid</em></code>字段中):</p><pre class="mc md me mf gt nu nv nw nx aw ny bi"><span id="0c58" class="mg mh jj nv b gy nz oa l ob oc"><strong class="nv jk">#Create a new pyplot figure to plot into<br/></strong>fig = plt.figure()</span><span id="324e" class="mg mh jj nv b gy om oa l ob oc"><strong class="nv jk">#Set the title of the plot<br/></strong>fig.suptitle('Residual errors against Time_Period')</span><span id="96c3" class="mg mh jj nv b gy om oa l ob oc"><strong class="nv jk">#Set the X and Y axis labels<br/></strong>plt.xlabel('Time_Period')</span><span id="dc2e" class="mg mh jj nv b gy om oa l ob oc">plt.ylabel('Residual Errors')</span><span id="9a9a" class="mg mh jj nv b gy om oa l ob oc"><strong class="nv jk">#plot the time series and store the plot in the <em class="mb">actual</em> variable. </strong>actual, = plt.plot(df['Time_Period'], olsr_results.resid, 'go-', label='Residual Errors')</span><span id="8ff3" class="mg mh jj nv b gy om oa l ob oc"><strong class="nv jk">#Set up the legend. There is only one time series in the legend.</strong><br/>plt.legend(handles=[actual])</span><span id="5553" class="mg mh jj nv b gy om oa l ob oc"><strong class="nv jk">#Show everything</strong><br/>plt.show()</span></pre><p id="7e18" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">剧情是这样的:</p><figure class="mc md me mf gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ou"><img src="../Images/36af6ce3e3504c5baeafbd6ebc4d6fd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZEFED69Gzv_-M9IczuOsew.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">(图片由<a class="ae jg" href="https://sachin-date.medium.com/" rel="noopener">作者</a>提供)</p></figure><h2 id="e966" class="mg mh jj bd mi mj mk dn ml mm mn dp mo lo mp mq mr ls ms mt mu lw mv mw mx my bi translated">对残差进行异方差的怀特检验</h2><p id="74ca" class="pw-post-body-paragraph lf lg jj lh b li mz kk lk ll na kn ln lo nb lq lr ls nc lu lv lw nd ly lz ma im bi translated">白色测试使用辅助 OLSR 模型，其中因变量是主模型残差的平方，解释变量是主模型的解释变量、它们的平方和叉积。</p><p id="014d" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">在我们的例子中，我们只有一个解释变量:<em class="mb"> Time_Period </em>。</p><p id="d46f" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">让我们向 pandas 数据框中添加两列，一列是主模型残差的平方，另一列是<em class="mb">时间周期</em>的平方。<em class="mb"> numpy.power() </em>方法是一种快速的方法。</p><pre class="mc md me mf gt nu nv nw nx aw ny bi"><span id="5147" class="mg mh jj nv b gy nz oa l ob oc">df['SQ_RESID'] = np.power(olsr_results.resid, 2.0)</span><span id="a055" class="mg mh jj nv b gy om oa l ob oc">df['SQ_Time_Period'] = np.power(df['Time_Period'], 2.0)</span></pre><p id="1bd1" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">为我们的辅助模型构建模型表达式(使用 patsy 语法):</p><pre class="mc md me mf gt nu nv nw nx aw ny bi"><span id="f944" class="mg mh jj nv b gy nz oa l ob oc">aux_expr = 'SQ_RESID ~ Time_Period + SQ_Time_Period'</span></pre><p id="5c3d" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">构建<strong class="lh jk"> <em class="mb"> X </em> </strong>和<strong class="lh jk"> <em class="mb"> y </em> </strong>矩阵。熊猫让这变得非常容易:</p><pre class="mc md me mf gt nu nv nw nx aw ny bi"><span id="e44d" class="mg mh jj nv b gy nz oa l ob oc">y, X = dmatrices(aux_expr, df, return_type='dataframe')</span></pre><p id="5c8f" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">在<strong class="lh jk"> <em class="mb"> X </em> </strong>中增加一列，用于保存回归截距:</p><pre class="mc md me mf gt nu nv nw nx aw ny bi"><span id="7e6d" class="mg mh jj nv b gy nz oa l ob oc">X = sm.add_constant(X)</span></pre><p id="0e84" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">在(y，X)数据集上建立和训练 OLSR 模型:</p><pre class="mc md me mf gt nu nv nw nx aw ny bi"><span id="eeb6" class="mg mh jj nv b gy nz oa l ob oc">aux_olsr_results = sm.OLS(y, X).fit()</span></pre><p id="7428" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">打印结果:</p><pre class="mc md me mf gt nu nv nw nx aw ny bi"><span id="1415" class="mg mh jj nv b gy nz oa l ob oc">print(aux_olsr_results.summary())</span></pre><p id="7305" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">这将打印以下输出:</p><figure class="mc md me mf gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ov"><img src="../Images/46f9ee618736542b954f0d91436f4a43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*khyFwZBRX50ytblx12YJ_w.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">辅助 OLSR 模型的输出(图片由<a class="ae jg" href="https://sachin-date.medium.com/" rel="noopener">作者</a>提供)</p></figure><h2 id="5c09" class="mg mh jj bd mi mj mk dn ml mm mn dp mo lo mp mq mr ls ms mt mu lw mv mw mx my bi translated">分析辅助模型的结果</h2><p id="7972" class="pw-post-body-paragraph lf lg jj lh b li mz kk lk ll na kn ln lo nb lq lr ls nc lu lv lw nd ly lz ma im bi translated">R-squared: 该模型只能解释残差平方中 0.8%的方差，表明拟合度相当差。</p><p id="3f88" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><a class="ae jg" rel="noopener" target="_blank" href="/fisher-test-for-regression-analysis-1e1687867259"><strong class="lh jk">F-统计量</strong></a>:0.593 的极高 p 值让我们接受了 f 检验的零假设，即模型的参数值没有联合显著性。这个模型比均值模型好不了多少。</p><pre class="mc md me mf gt nu nv nw nx aw ny bi"><span id="98d3" class="mg mh jj nv b gy nz oa l ob oc"><strong class="nv jk">Related Post:</strong> <a class="ae jg" rel="noopener" target="_blank" href="/fisher-test-for-regression-analysis-1e1687867259">The F-test for Regression Analysis</a></span></pre><p id="e71b" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><strong class="lh jk">回归系数的显著性:</strong><em class="mb">Time _ Period</em>(0.812)和<em class="mb"> SQ_Time_Period </em> (0.634)的 p 值相当高，导致我们接受 t 检验的零假设，即两个系数都不显著，即基本为零。</p><p id="a7c3" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">所有可用的证据表明残差是同方差的。</p><p id="f39a" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">所发生的是，对数变换也抑制了原始黄金价格指数的异方差性，使其达到了怀特测试无法检测的水平。</p><h2 id="da05" class="mg mh jj bd mi mj mk dn ml mm mn dp mo lo mp mq mr ls ms mt mu lw mv mw mx my bi translated">使用 statsmodels 运行白色测试</h2><p id="b060" class="pw-post-body-paragraph lf lg jj lh b li mz kk lk ll na kn ln lo nb lq lr ls nc lu lv lw nd ly lz ma im bi translated">Python <em class="mb"> statsmodels </em>库包含怀特测试的实现。让我们看看它是如何工作的:</p><p id="8838" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><strong class="lh jk">步骤 1: </strong>导入测试包。</p><pre class="mc md me mf gt nu nv nw nx aw ny bi"><span id="7e8e" class="mg mh jj nv b gy nz oa l ob oc"><strong class="nv jk">from</strong> statsmodels.stats.diagnostic <strong class="nv jk">import</strong> het_white</span><span id="03d1" class="mg mh jj nv b gy om oa l ob oc"><strong class="nv jk">from </strong>statsmodels.compat <strong class="nv jk">import </strong>lzip</span></pre><p id="deec" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">statsmodels 中的<a class="ae jg" href="https://www.statsmodels.org/stable/generated/statsmodels.stats.diagnostic.het_white.html" rel="noopener ugc nofollow" target="_blank"> <em class="mb"> het_white(resid，exog) </em> </a> <em class="mb"> </em>测试需要两个参数:</p><p id="45d7" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><strong class="lh jk"> <em class="mb"> resid </em> </strong>:主回归模型的残差数组。在我们的例子中，<strong class="lh jk"> <em class="mb"> resid </em> </strong>是<em class="mb"> olsr_results.resid </em></p><p id="88c1" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><strong class="lh jk"> <em class="mb"> exog </em> </strong>:主模型的解释变量<strong class="lh jk"> <em class="mb"> X </em> </strong>的矩阵(如 numpy 数组)。在我们的例子中<strong class="lh jk"> <em class="mb"> exog </em> </strong>是<em class="mb"> Time_Period + Intercept </em></p><p id="aefc" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><strong class="lh jk">第二步:</strong>根据数据建立并训练主回归模型。回想一下，我们已经这样做了，剩余误差可在<code class="fe or os ot nv b">olsr_results.resid</code>中找到。</p><p id="8eb1" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">第三步:使用<em class="mb"> patsy </em>，从<em class="mb"> pandas </em>数据帧中拉出包含<strong class="lh jk"> <em class="mb"> Time_Period </em> </strong>和<strong class="lh jk"> <em class="mb"> intercept </em> </strong>列的<strong class="lh jk"> <em class="mb"> X </em> </strong>矩阵:</p><pre class="mc md me mf gt nu nv nw nx aw ny bi"><span id="ef22" class="mg mh jj nv b gy nz oa l ob oc">expr = 'LOG_Export_Price_Index_of_Gold ~ Time_Period'</span><span id="cfe6" class="mg mh jj nv b gy om oa l ob oc">y, X = dmatrices(expr, df, return_type='dataframe')</span></pre><p id="7de5" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><strong class="lh jk">步骤 4: </strong>执行白色测试:</p><pre class="mc md me mf gt nu nv nw nx aw ny bi"><span id="d681" class="mg mh jj nv b gy nz oa l ob oc">keys = ['<strong class="nv jk">Lagrange Multiplier statistic:</strong>', '<strong class="nv jk">LM test\'s p-value:</strong>', '<strong class="nv jk">F-statistic:</strong>', '<strong class="nv jk">F-test\'s p-value:</strong>']</span><span id="b34f" class="mg mh jj nv b gy om oa l ob oc">results = <strong class="nv jk">het_white</strong>(olsr_results.resid, X)</span><span id="482b" class="mg mh jj nv b gy om oa l ob oc">lzip(keys, results)</span></pre><p id="285b" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">以下是输出结果:</p><pre class="mc md me mf gt nu nv nw nx aw ny bi"><span id="0d65" class="mg mh jj nv b gy nz oa l ob oc">[<br/>('<strong class="nv jk">Lagrange Multiplier statistic:</strong>', 1.0637754647238826),<br/> ("<strong class="nv jk">LM test's p-value:</strong>", 0.5874948891258364),<br/> ('<strong class="nv jk">F-statistic:</strong>', 0.5240224217417021),<br/> ("<strong class="nv jk">F-test's p-value:</strong>", 0.5933889438779911)<br/>]</span></pre><p id="811f" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><strong class="lh jk"> LM 检验:</strong>LM 检验的统计量遵循卡方分布，自由度=模型的 DF 减 1 =(3–1)= 2。它的 p 值(0.587)很高。因此，我们接受检验的零假设，即残差中没有异方差。</p><p id="7066" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><strong class="lh jk">F-检验:</strong>F-检验的统计量服从 F-分布。同样，0.593 的高 p 值<strong class="lh jk">证实了检验的零假设</strong>，即残差中不存在异方差性。</p><p id="c43f" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><strong class="lh jk">总体上，我们的结论是残差是同胚的。</strong></p><p id="d349" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">这与我们之前的分析一致，即残差是同胚的。</p></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><p id="6d90" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><em class="mb">我写关于数据科学的话题，特别关注时间序列分析和预测。</em></p><p id="2e01" class="pw-post-body-paragraph lf lg jj lh b li lj kk lk ll lm kn ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated"><em class="mb">如果你喜欢这篇文章，请跟我到</em> <a class="ae jg" href="https://timeseriesreasoning.medium.com" rel="noopener"> <strong class="lh jk"> <em class="mb">拜见</em> </strong> </a> <em class="mb">接受关于时间序列分析、建模和预测的提示、操作方法和编程建议。</em></p></div></div>    
</body>
</html>