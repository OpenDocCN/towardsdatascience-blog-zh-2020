<html>
<head>
<title>5 best practices for Professional Object-Oriented Programming in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 专业面向对象编程的 5 个最佳实践</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/5-best-practices-for-professional-object-oriented-programming-in-python-20613e08baee?source=collection_archive---------3-----------------------#2020-07-19">https://towardsdatascience.com/5-best-practices-for-professional-object-oriented-programming-in-python-20613e08baee?source=collection_archive---------3-----------------------#2020-07-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4101" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">处理异常的最好方法是编写文档、类继承的装饰器和自动清理代码的包。</h2></div><p id="2f08" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">构建 Python 类总是很有趣。但是为了效率、外部使用和文档化，对它们进行适当的打包是非常重要的。在本文中，我将介绍记录、维护和测试 Python 类的五种最佳实践。这些方法包括处理异常、编写文档和文档测试、类继承和数据管理的装饰器、抽象类以及清理和格式化代码的自动化包的最佳方式。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/59ab2fc606ede837cab1e29580cab3fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-xTOMH5MEpysvqUV"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">来源:<a class="ae lu" href="https://unsplash.com/photos/D9Zow2REm8U" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><h1 id="9413" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak"> 1 -异常处理</strong></h1><p id="a82d" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">构建 Python 类很酷。但同样重要的是，要确保当不正确的输入被输入到函数中时，你正在引发正确的错误。这里有一个例子:假设你正在构建一个函数来接受一个整数“n ”,并用它来构建一个大小为 n×n 的数组。下面是代码的样子:</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="d8aa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，让我们运行这个函数，但是我们将输入一个字符串“a”而不是一个整数。以下是我们得到的结果:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi mu"><img src="../Images/9de104b074597b3fb43bb91063a4c619.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HhpWQR1iW-h-QxnSMplBBQ.png"/></div></div></figure><p id="03bd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">TypeError 不是帮助调试问题的最直观的消息，尤其是如果您的包将被广泛的受众使用。让我们对我们的原始代码做一点修改。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="fac1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码检查输入的整数是否是整数。如果不是，它将引发一个带有定制消息的 TypeError。它还检查整数是否为非负。如果不是，它会引发一个 ValueError，要求用户必须提供一个正整数。</p><p id="2bf9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是一些测试案例:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi mv"><img src="../Images/f8e60af3ba3244e39debef5d93c253ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PJvDs9xdoAs7WYYNXBOf2Q.png"/></div></div></figure><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi mw"><img src="../Images/ca41547e95f80c8d6c498a982d4fefbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IiMjLCBUQF2l776YbyHwxQ.png"/></div></div></figure><p id="5508" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">为什么这很重要？</strong>提出正确类型的直观消息对于构建易于调试的包极其重要。如果用户不能理解或调试你的包的需求，他们就不会使用它。</p><p id="865a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">用户可以引发各种各样的内置错误，如 SystemError、FileNotFoundError 等。你可以在这里阅读更多关于它们的信息。通过调试这些错误，用户为包构建用例。这就把我们带到了下一步——文档。</p><h1 id="a4ef" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak"> 2 —文件</strong></h1><p id="e33b" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">曾几何时，我们常常在代码中编写注释来恰当地解释它。但是注释并不是记录工作流的最结构化或最具视觉吸引力的方式。您应该使用带三个撇号的结构化文档来为您的代码编写结构化文档。这里有一个例子:</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="f710" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们已经将所有的信息转移到我们在函数开始时写的一个段落中。所有信息都包含在开头的三个撇号和结尾的三个撇号中。大多数 Python 包都是用这种技术记录的。</p><h1 id="4102" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak"> 3 —测试(Doc 测试)</strong></h1><p id="56b3" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">在大多数 python 文档中，开发人员还包括该函数的文档化用例。这些用例也被用作“测试”,以确保函数提供正确的响应。利用我们在上面学到的文档技术，我们还可以编写文档测试，既可以用作用例，也可以在函数上运行测试。在这些测试中，我们指定了预期的输出。如果实际输出与预期输出不匹配，doctest 就会失败。下面是一个生成随机 id 的函数中的文档测试示例:</p><pre class="lf lg lh li gt mx my mz na aw nb bi"><span id="1130" class="nc lw it my b gy nd ne l nf ng">def random_id(length):<br/>    """<br/>    This function creates a random configuration <br/>    key for a given length.</span><span id="7847" class="nc lw it my b gy nh ne l nf ng">    Inputs:<br/>      - length (Type: int and positive)<br/>    Outputs:<br/>      - ID (Type: str)<br/>    <br/>    DocTest 1<br/>    &gt;&gt;&gt; len(random_id(50)) == 50<br/>    True<br/>    <br/>    DocTest2<br/>    &gt;&gt;&gt; random_id('hello')<br/>    Traceback (most recent call last):<br/>        ...<br/>    TypeError: The input must be a positive integer.<br/>    """</span><span id="facc" class="nc lw it my b gy nh ne l nf ng">    if type(length) != int or length &lt; 1:<br/>        raise TypeError('The input must be a positive integer.')</span><span id="feb1" class="nc lw it my b gy nh ne l nf ng">    choices = '0123456789abcdefghijklmnopqrstuvwxyz'</span><span id="dd68" class="nc lw it my b gy nh ne l nf ng">    id = ''</span><span id="f310" class="nc lw it my b gy nh ne l nf ng">    for _ in range(length):<br/>        id += random.choice(choices)<br/>    return id</span></pre><p id="ab94" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的文档中，文档测试由符号“&gt; &gt; &gt;”表示。该符号之后的 python 代码由 doctests 编译器执行。预期产出显示在该线下方。如果是错误，会在第二个 doctest 中指出，如上所示。让我们用 doctest 库运行这个文件。</p><p id="d218" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您需要在。包含上述代码的 py 文件:</p><pre class="lf lg lh li gt mx my mz na aw nb bi"><span id="c5fc" class="nc lw it my b gy nd ne l nf ng">if __name__ == "__main__":<br/>    import <strong class="my iu">doctest</strong><br/>    doctest.testmod()</span></pre><p id="1264" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，让我们用下面的 bash 命令运行 doctest:(我已经将我的文件命名为 random_id.py)</p><pre class="lf lg lh li gt mx my mz na aw nb bi"><span id="31e3" class="nc lw it my b gy nd ne l nf ng">python random_id.py -v</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/60437cecf38a01feb6fa285985497582.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*s-dvw3rprLeD3UR-60qKEQ.png"/></div></figure><p id="8283" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以我们的代码通过了所有的文档测试。但是这些 doc 测试非常简单。您也可以编写更复杂的 doc 测试。当您继续编辑和维护 Python 类时，确保没有任何会导致 doc 测试失败的错误或问题是很重要的。</p><h1 id="c96b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak"> 4 —遵循 pep8 指南</strong></h1><p id="97b8" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">pep8 指南是 Python 包的编码约定。虽然这些约定并不严格，也不影响代码的正确性，但是它们对于发布易于阅读、理解和维护的代码是有价值的。一些最突出的准则如下:</p><ul class=""><li id="2e7f" class="nj nk it kk b kl km ko kp kr nl kv nm kz nn ld no np nq nr bi translated"><strong class="kk iu">每行代码不得超过 80 个字符</strong>。如果代码行超过了这个长度，您可以使用' \ '符号在下一行继续编写代码。如果在函数中指定输入，就不需要使用反冲，因为 Python 保持代码连续。这只是字符串的问题，这就是' \ '有用的地方。</li><li id="609e" class="nj nk it kk b kl ns ko nt kr nu kv nv kz nw ld no np nq nr bi translated">所有库必须在开始时一起导入，不能有任何重复。为什么？如果存在依赖问题，它会被提前突出显示，而不是在代码执行的时候。</li><li id="9209" class="nj nk it kk b kl ns ko nt kr nu kv nv kz nw ld no np nq nr bi translated">冗余变量或中间变量(不执行进一步的操作)应该被删除以节省内存。</li></ul><p id="bb44" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是您不必手动实现所有这些准则。有一个名为 pycodestyle 的 python 包，它将一个 python 文件作为输入，并突出显示它的每个问题。</p><p id="5430" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们在同一个 random_id.py 文件中运行 pycodestyle。该消息强调了两个函数之间没有足够的行(推荐的空行是 2 行),并且第 6 行太长。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi nx"><img src="../Images/fbbf82833115f9e9ea1c8caa8152518d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lJsMfrmcCWeSdwrdNnBjsQ.png"/></div></div></figure><p id="8335" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您还可以运行一个名为 autopep8 的包，它获取一个 python 文件，并根据 pep8 准则自动对其进行重新格式化。点击此处了解更多关于 autpep8 <a class="ae lu" href="https://pypi.org/project/autopep8/#usage" rel="noopener ugc nofollow" target="_blank">的用法。</a></p><h1 id="9b26" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak"> 5 —使用抽象类和继承</strong></h1><p id="d735" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">在面向对象编程中，人们应该减少他们必须做的编码量。这意味着编码者应该构建抽象的类，并且更普遍地适用于广泛的对象。例如，我正在构建一个桌子的模拟，我需要编写代码来模拟钢笔、笔记本、铅笔、橡皮、卷笔刀等对象。但是我们不会为每一个对象编写另一个类。我们将编写一个名为“Table_Object”的抽象类，如下所示:</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="5b5f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">abstractclass 装饰器是一个特殊的函数，它表示对象的类型。现在，让我们定义另一个类，它用 object_type 的特定函数继承这个类的所有数据。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="c5ee" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这里，我们定义了两个类，它们从 Table_Object 类“继承”,然后成为与成为表对象的主要思想相关的专用继承类。类继承允许减少代码的重复性，也允许类的层次结构对于不是专家的程序员来说是有意义的。</p><p id="ff2a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您在 Table_Object 中看到的“@”符号称为装饰符。装饰器是另一个简单的函数，它允许你为不同的函数添加一个特殊的特性。Python 类中还有另一个装饰器，叫做静态方法。这些方法是“静态”的，调用时不会继承该类。它们通常用于保持类的一部分不受变化的影响。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="ba84" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于专门的数据驱动类，您应该使用 dataclass 装饰器。在这里阅读更多关于他们<a class="ae lu" href="https://realpython.com/python-data-classes/" rel="noopener ugc nofollow" target="_blank">的信息。</a></p><p id="398e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我希望你喜欢阅读这篇文章。如果你有任何问题，请随时通过 LinkedIn 联系我。编码快乐！</p></div></div>    
</body>
</html>