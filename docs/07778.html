<html>
<head>
<title>Time Series Analysis using Pandas in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python中的Pandas进行时间序列分析</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/time-series-analysis-using-pandas-in-python-f726d87a97d8?source=collection_archive---------1-----------------------#2020-06-10">https://towardsdatascience.com/time-series-analysis-using-pandas-in-python-f726d87a97d8?source=collection_archive---------1-----------------------#2020-06-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4730" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">对季节性、趋势、自相关等关键词的额外介绍。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5347f63fa98c0c1a98d12a6c2417207a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*94gYiagcWKlVn--t.jpg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://www.google.com/url?sa=i&amp;url=https%3A%2F%2Fmemegenerator.net%2Finstance%2F12285574&amp;psig=AOvVaw34w5OHkrFMF7ReEEzeX68D&amp;ust=1591861120789000&amp;source=images&amp;cd=vfe&amp;ved=0CAMQjB1qFwoTCPietPje9ukCFQAAAAAdAAAAABAD" rel="noopener ugc nofollow" target="_blank">迷因生成器</a></p></figure><p id="2434" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">马上，时间序列数据不是你的平均数据集！您可能已经处理过住房数据，其中每一行代表一所特定房屋的特征(例如总面积、卧室数量、建造年份)，或者学生数据集，其中每一行代表学生的信息(例如年龄、性别、以前的GPA)。在所有这些数据集中，共同点是所有样本(或数据集中的行)通常都是相互独立的<em class="lv">。这些数据集与时间序列数据的区别在于，在后者中，每一行都代表一个时间点，因此很自然地，数据有一些固有的<em class="lv">排序</em>。典型的时间序列数据看起来是这样的:</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/79a9f0f2af6b6b1330ecbeed1bfc7a54.png" data-original-src="https://miro.medium.com/v2/resize:fit:644/format:webp/1*kucXL9WwXyaOHUEvZKKzow.png"/></div></figure><p id="fa04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的数据集中，我们记录了1991年1月的每一天的一些<em class="lv">值</em>(比如温度)。当然，除了温度之外，您还可以在特定的一天收集更多的值，比如当天的湿度或风速。</p><h1 id="ddec" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">让我们开始研究数据吧！</h1><p id="a062" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">我们将使用公开的数据集开放电力系统数据。你可以在这里下载数据<a class="ae ky" href="https://raw.githubusercontent.com/jenfly/opsd/master/opsd_germany_daily.csv" rel="noopener ugc nofollow" target="_blank">。它包含2006-2017年的电力消耗、风力发电和太阳能发电。</a></p><p id="f1a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将数据集加载到Jupyter笔记本:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="cd65" class="mz ly it mv b gy na nb l nc nd">url='<a class="ae ky" href="https://raw.githubusercontent.com/jenfly/opsd/master/opsd_germany_daily.csv'" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/jenfly/opsd/master/opsd_germany_daily.csv'</a><br/>data = pd.read_csv(url,sep=",")</span></pre><p id="35c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的数据看起来是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/478b3eeb5a13aefd3f1fba56763fef30.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/format:webp/1*KbJ-lS2bRLE83-V2b21Qyg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图一</p></figure><h1 id="d11e" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">将数据转换为正确的格式</h1><p id="9792" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">如果你读过我以前的文章，你就会知道正确的日期时间格式的重要性。同样，当处理时间序列时，如果我们将<code class="fe nf ng nh mv b">Date</code>列表示为一个<strong class="lb iu">时间戳</strong>，就会变得容易得多。时间戳是pandas处理日期和时间的主要数据结构。pandas函数<code class="fe nf ng nh mv b">to_datetime()</code>可以帮助我们将字符串转换成适当的日期/时间格式。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="7413" class="mz ly it mv b gy na nb l nc nd"><em class="lv"># to explicitly convert the date column to type DATETIME</em><br/>data['Date'] = pd.to_datetime(data['Date'])<br/>data.dtypes</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/586d0f2cdeb95247e4dabdd3f2d10dac.png" data-original-src="https://miro.medium.com/v2/resize:fit:528/format:webp/1*XIWf-EeChMu4obHp6cbFJg.png"/></div></figure><p id="29e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在将继续使用<code class="fe nf ng nh mv b">set_index()</code>调用将该列设置为数据帧的索引。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="88fb" class="mz ly it mv b gy na nb l nc nd">data = data.set_index('Date')<br/>data</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/bf81b332595b722bf90e0203a02c6d0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:734/format:webp/1*G6DYocnrx1ZcmKa1iJ1pFg.png"/></div></figure><p id="764e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果将它与上面图1中的输出进行比较，您会注意到数据帧的索引不再在0到4382的范围内。取而代之的是，现在这些指数是各自收集数据的日期。</p><p id="df2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以明确地检查索引:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="136e" class="mz ly it mv b gy na nb l nc nd">data.index</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/9b8dc0f11b793447dce13522f1db0831.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aVFZdhuHxByE2l59YIzMlg.png"/></div></div></figure><p id="b8cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里要注意一个有趣的事情是<code class="fe nf ng nh mv b">freq = None</code>。这意味着不知道数据是按小时、天、分钟等收集的。然而，仅仅通过目测这些指数，我们可以看到这些数据似乎是按天收集的。将这些信息显式地放入数据框也是很好的，我们将很快看到如何做到这一点！但首先快速绕道…</p><h2 id="4bb5" class="mz ly it bd lz nl nm dn md nn no dp mh li np nq mj lm nr ns ml lq nt nu mn nv bi translated">如果我想将日期<em class="nw">和时间</em>都设为索引，该怎么办？</h2><p id="b89a" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">您会遇到这样的数据集，在收集数据时，<strong class="lb iu">日期</strong>和<strong class="lb iu">时间</strong>被记录为单独的列。将它们设置为数据索引的一个简单而巧妙的技巧是:</p><ul class=""><li id="e193" class="nx ny it lb b lc ld lf lg li nz lm oa lq ob lu oc od oe of bi translated">连接这两列，但在它们之间留一个空格。<br/>空间很重要！！</li><li id="72a3" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated">使用<code class="fe nf ng nh mv b">to_datetime()</code>将这个串联的列转换成时间戳。</li><li id="88c2" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated">使用<code class="fe nf ng nh mv b">set_index()</code>将该串联列设置为索引。</li></ul><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="f9a9" class="mz ly it mv b gy na nb l nc nd">df['Datetime'] = pd.to_datetime(df['date'] + ' ' + df['time'])<br/>df = df.set_index('Datetime')</span></pre><p id="ec6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，您可以在读取文件时将它们设置为索引，如下所示:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="286e" class="mz ly it mv b gy na nb l nc nd">pd.read_csv('xyz.csv', parse_dates = [['Date','Time']], index_col = 0)</span></pre><h1 id="70a3" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">缺失值插补</h1><p id="9afd" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">正如我们前面提到的，快速浏览一下数据表明它是以24小时(或一天)的间隔收集的。但是，数据反映的是<code class="fe nf ng nh mv b">freq = None</code>。我们可以纠正如下:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="cd4a" class="mz ly it mv b gy na nb l nc nd">data_freq = data.asfreq('D')<br/>data_freq</span></pre><blockquote class="ol om on"><p id="4e0e" class="kz la lv lb b lc ld ju le lf lg jx lh oo lj lk ll op ln lo lp oq lr ls lt lu im bi translated">注意:pandas中可用的频率包括每小时一次(' H ')、日历每天一次(' D ')、商业每天一次(' B ')、每周一次(' W ')、每月一次(' M ')、每季度一次(' Q ')、每年一次(' A ')以及许多其他频率。</p></blockquote><p id="fa4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在上面所做的就是说“嘿，数据是以一天为间隔收集的，因此每一行都是新的一天”。所以从技术上讲，我们应该有从2006年到2017年所有天的电力消耗、太阳能生产、风力生产等的数值。</p><p id="282c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们的数据中缺少某些天，上面的代码将插入空行，并且在这些行的每一行中，对应于列的值都将是<code class="fe nf ng nh mv b">NaNs.</code>为了避免这些<code class="fe nf ng nh mv b">NaN</code>值，我们可以告诉<code class="fe nf ng nh mv b">as.freq</code>函数如何填充这些空值</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="3abf" class="mz ly it mv b gy na nb l nc nd">data_freq = data.asfreq('D', method = 'ffill')<br/>data_freq</span></pre><p id="fec2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nf ng nh mv b">ffill</code>是指<em class="lv">正向填充</em>。这意味着当某一列为空时，它将被前一行中的值替换。举个例子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/9db2245f9508d800df6d8f0ac90fe042.png" data-original-src="https://miro.medium.com/v2/resize:fit:710/format:webp/1*umkIkI64w0WyGwJCxOJ_xw.png"/></div></figure><p id="55ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上表中，向前填充空值将产生以下数据帧:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi os"><img src="../Images/863b0d2e13b29a4d937adac7dafadec7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1178/format:webp/1*u3bay0Zma0B70J9sCzTr7Q.png"/></div></figure><p id="15d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种向前填充的技术在某种程度上是有意义的——如果我们不知道今天的耗电量，我们总是可以假设它与昨天相同。</p><p id="6c69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似地，填充时间序列数据集中的缺失数据可以通过以下方式实现:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="020c" class="mz ly it mv b gy na nb l nc nd">data = data.ffill().head()</span></pre><blockquote class="ol om on"><p id="fc08" class="kz la lv lb b lc ld ju le lf lg jx lh oo lj lk ll op ln lo lp oq lr ls lt lu im bi translated">请记住，对于时间序列数据，用中位数或平均值替换缺失数据并不是一个好主意。存在更好的替代方案，例如向前填充、向后填充、线性插值、最近邻居的平均值等。</p></blockquote><p id="65e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，在修复了频率类型并输入缺失值后，查看我们的数据集，我们发现我们的数据集与以前一样(没有添加新行。我猜不管是谁做的数据收集工作都做得很出色！)</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/bdfa3500aff5523903be99fe8b82117e.png" data-original-src="https://miro.medium.com/v2/resize:fit:706/format:webp/1*sN038IGqnVmr1GVTKibrjA.png"/></div></div></figure><p id="3bd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能想知道为什么仍然有一些空值，尤其是在数据集的开头。原因是这些<em class="lv">已经被</em>向前填充了，但是因为第一行的值是空的，所以我们看不出有什么不同。</p><h1 id="cf01" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">重采样</h1><p id="322f" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">重采样简单地指的是某个时间段内的数据聚合。其性能类似于SQL中的group by函数，即首先将数据拆分到时间仓中，然后在每个仓上执行一些计算。例如，给定我们的每日数据，我们可以按月或年对其进行<em class="lv">重采样</em>(或bin)并生成一些相关的统计数据，如最小值、最大值或平均值。</p><h2 id="b68e" class="mz ly it bd lz nl nm dn md nn no dp mh li np nq mj lm nr ns ml lq nt nu mn nv bi translated">每周重新取样</h2><p id="6c70" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">要计算电力消耗、风力和太阳能生产的周平均值:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="f6d6" class="mz ly it mv b gy na nb l nc nd">data_columns = ['Consumption', 'Wind', 'Solar', 'Wind+Solar']<br/>data_weekly_mean = data[data_columns].resample('W').mean() # W stands for weekly<br/>data_weekly_mean</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/ff2bd6f0b7f537027dc4efa12b3bfddc.png" data-original-src="https://miro.medium.com/v2/resize:fit:818/format:webp/1*grgejkCeTiUMyqS77P2HEg.png"/></div></figure><p id="822e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你注意到输出中的指数，你会发现它们有一周的间隔，我们有2006年1月1日，接着是2006年1月8日，等等。上面标记为2006–01–01的第一行包含时间框2006–01–01到2006–01–07中包含的所有数据的平均值。</p><h2 id="417e" class="mz ly it bd lz nl nm dn md nn no dp mh li np nq mj lm nr ns ml lq nt nu mn nv bi translated">每月重新取样</h2><p id="83c8" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">类似地，要计算电力消耗、风力和太阳能生产的月最大值:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="f504" class="mz ly it mv b gy na nb l nc nd">data_columns = ['Consumption', 'Wind', 'Solar', 'Wind+Solar']<br/>data_monthly_max = data[data_columns].resample('M').max() # W stands for weekly<br/>data_monthly_max</span></pre><h1 id="1d75" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">滚动窗户</h1><p id="490c" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">这与我们刚刚学习的重采样过程非常相似。区别在于在其上执行一些聚合功能的仓)是重叠的。</p><ul class=""><li id="7f4f" class="nx ny it lb b lc ld lf lg li nz lm oa lq ob lu oc od oe of bi translated">每周<strong class="lb iu">重采样</strong>的箱:1月1日-1月7日；1月8日至1月14日、1月15日至1月21日等等</li><li id="ddc9" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated">每周<strong class="lb iu">滚动</strong>的箱柜:1月1日-1月7日；1月2日至1月8日、1月3日至1月9日等等。</li></ul><p id="00f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要计算7天滚动平均值:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="1ff3" class="mz ly it mv b gy na nb l nc nd">data_columns = ['Consumption', 'Wind', 'Solar', 'Wind+Solar']<br/>data_7d_rol = data[data_columns].rolling(window = 7, center = True).mean()<br/>data_7d_rol</span></pre><p id="9e51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的命令中，<code class="fe nf ng nh mv b">center = True</code>表示时间框，比如1月1日到1月8日，滚动平均值将被计算并放置在框的中心附近，即1月4日。为了更清楚，让我们检查一下上面代码的输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/8f4346c2e6155649811d5e605b32ea5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/1*bsvvQuSIQoJ3p5q3eYpK-w.png"/></div></figure><p id="b41d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，2006年1月至2004年的平均消费值(1361.471英镑)是通过对2006年1月至2006年1月至2007年的值进行平均计算得出的。同样，2006年1月至2005年的平均消费值(1381.300英镑)是通过平均2006年1月至2006年1月至2008年的值计算出来的。</p><p id="a1cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">按照同样的逻辑，要计算2006年1月1日的平均消费值，我们需要计算2005年12月29日至2006年1月4日的平均值。但是，缺少2005年的数据，因此我们获得了前几行的空值。</p><h2 id="8ecd" class="mz ly it bd lz nl nm dn md nn no dp mh li np nq mj lm nr ns ml lq nt nu mn nv bi translated">使用滚动方法可视化数据趋势</h2><p id="99d2" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">滚动方法对于评估我们数据集中的<strong class="lb iu">趋势</strong>非常方便。但是首先，什么是趋势？</p><blockquote class="ol om on"><p id="1e66" class="kz la lv lb b lc ld ju le lf lg jx lh oo lj lk ll op ln lo lp oq lr ls lt lu im bi translated">趋势是时间序列的平滑长期趋势。随着时间的推移，它可能会改变方向(增加或减少)。</p></blockquote><p id="40b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个增长趋势是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/8072e49251f166196d17ed09049ba6e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YPGpyXqHoYG11-N-qbkEgA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图3</p></figure><blockquote class="ol om on"><p id="3b3a" class="kz la lv lb b lc ld ju le lf lg jx lh oo lj lk ll op ln lo lp oq lr ls lt lu im bi translated">可视化这些趋势的一个简单方法是使用不同时间尺度的<code class="fe nf ng nh mv b">rolling</code>方法。</p></blockquote><p id="6c76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们以年度为尺度(365天)使用滚动平均值来查看我们的数据集中的电力消耗趋势:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="a54a" class="mz ly it mv b gy na nb l nc nd">data_365d_rol = data[data_columns].rolling(window = 365, center = True).mean()</span></pre><p id="d840" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们将我们的结果可视化，以便更好地了解趋势。我们将根据每日和7天滚动平均值绘制年度趋势图:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="721d" class="mz ly it mv b gy na nb l nc nd">fig, ax = plt.subplots(figsize = (11,4))</span><span id="7ee6" class="mz ly it mv b gy ox nb l nc nd"><em class="lv"># plotting daily data</em><br/>ax.plot(data['Consumption'], marker='.', markersize=2, color='0.6',linestyle='None', label='Daily')</span><span id="ceab" class="mz ly it mv b gy ox nb l nc nd"><em class="lv"># plotting 7-day rolling data<br/></em>ax.plot(data_7d_rol['Consumption'], linewidth=2, label='7-d Rolling <br/>Mean')</span><span id="c77a" class="mz ly it mv b gy ox nb l nc nd"><em class="lv"># plotting annual rolling data</em><br/>ax.plot(data_365d_rol['Consumption'], color='0.2', linewidth=3, label='Trend (365-d Rolling Mean)')</span><span id="408e" class="mz ly it mv b gy ox nb l nc nd"><em class="lv"># Beautification of plot</em><br/>ax.xaxis.set_major_locator(mdates.YearLocator())<br/>ax.legend()<br/>ax.set_xlabel('Year')<br/>ax.set_ylabel('Consumption (GWh)')<br/>ax.set_title('Trends in Electricity Consumption')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/8f5cbd8ed5c8b337471a2c302fabebb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*drL2ir1YbXUIVw1AXxD2Fg.png"/></div></div></figure><p id="6595" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">观察365天的滚动平均时间序列，我们可以看到，电力消费的整体年度趋势相当稳定，2009年和2013年左右的消费量较低。</p><h2 id="a443" class="mz ly it bd lz nl nm dn md nn no dp mh li np nq mj lm nr ns ml lq nt nu mn nv bi translated">去趋势时间序列</h2><p id="68b6" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">有时，从我们的数据中移除趋势是有益的，特别是当趋势非常明显时(如图3所示)，这样我们就可以评估季节变化(几分钟后会详细介绍)或时间序列中的噪声。移除趋势(或去趋势)还可以简化建模过程并提高模型性能。</p><blockquote class="ol om on"><p id="246e" class="kz la lv lb b lc ld ju le lf lg jx lh oo lj lk ll op ln lo lp oq lr ls lt lu im bi translated">有趋势的时间序列称为<strong class="lb iu">非平稳</strong>。<br/>没有趋势或趋势被移除的时间序列被称为<strong class="lb iu">平稳</strong>。</p></blockquote><p id="c175" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">去趋势时间序列用作学习算法的输入，例如ARIMA(用于分析和预测时间序列数据的Python库)，或者也可以用作机器学习算法的附加输入。</p><h2 id="3d16" class="mz ly it bd lz nl nm dn md nn no dp mh li np nq mj lm nr ns ml lq nt nu mn nv bi translated">如何从时间序列中去除趋势？</h2><p id="a911" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">我们可以使用一种叫做<code class="fe nf ng nh mv b">differencing</code>的方法来消除这种趋势。这实质上意味着创建一个新的时间序列，其中<br/> <strong class="lb iu">时间(t)的值=时间(t)的原始值-时间(t-1)的原始值</strong></p><blockquote class="ol om on"><p id="e1bd" class="kz la lv lb b lc ld ju le lf lg jx lh oo lj lk ll op ln lo lp oq lr ls lt lu im bi translated">差分对于将你的时间序列转化为平稳的时间序列非常有帮助。</p></blockquote><h2 id="2c7e" class="mz ly it bd lz nl nm dn md nn no dp mh li np nq mj lm nr ns ml lq nt nu mn nv bi translated">用于差分的Python代码</h2><p id="981a" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">要创建时间序列的一阶差分:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="6b5c" class="mz ly it mv b gy na nb l nc nd"><em class="lv"># creating the first order differencing data</em><br/>data_first_order_diff = data[data_columns].diff()</span></pre><div class="kj kk kl km gt ab cb"><figure class="oz kn pa pb pc pd pe paragraph-image"><img src="../Images/f434f3df2d86db79405ff41a10e65b33.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/1*JwSat2d6VYtbt4OdRsCl4w.png"/></figure><figure class="oz kn pf pb pc pd pe paragraph-image"><img src="../Images/b6cbf7e8bc0f53fc985a9934d968e230.png" data-original-src="https://miro.medium.com/v2/resize:fit:866/format:webp/1*RzQxC7WfCAKfx1frL_Ap4Q.png"/><p class="ku kv gj gh gi kw kx bd b be z dk pg di ph pi translated">左:原始数据集；右图:数据集的差异去趋势版本</p></figure></div><p id="61d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">左边是原始数据集，右边是去趋势差异的版本。查看“消耗”列，我们可以看到2006–01–02年的值现在已从1380.521变为311.337，这是通过减去2006–01–02年和2006–01–01年的消耗值获得的(1380.521–1069.184 = 311.337)。</p><p id="9f5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一般来说，差分时间序列告诉我们的不是特定时间点的实际值，而是它与前一时间点的值有多少差异。这意味着当我们绘制这个差分时间序列时，这些值中的大部分将位于x轴的任一侧(或<code class="fe nf ng nh mv b">y=0</code>)。</p><p id="5569" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">绘制不同时间序列的图像:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="a81d" class="mz ly it mv b gy na nb l nc nd">start, end = '2017-01', '2017-06'<br/><br/>fig, ax = plt.subplots(figsize=(11, 4))<br/><br/>ax.plot(data_first_order_diff.loc[start:end, 'Consumption'],<br/>marker='o', markersize=4, linestyle='-', label='First Order Differencing')</span><span id="c7c5" class="mz ly it mv b gy ox nb l nc nd">ax.set_ylabel('Electricity Consumption (GWh)')<br/>ax.legend();</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pj"><img src="../Images/ffa263ecc6640ea8fcf6ce9409599523.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V_Dp7k_3Q3Cx-m3jqYDkZQ.png"/></div></div></figure><p id="8045" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们没有任何趋势，所以你可能很难看出趋势是否已经消除。但你不一定要相信我的话！当您对自己的数据执行一阶差分时(如左图所示，该数据具有趋势分量)，您应该能够看到类似于右图的变换:</p><div class="kj kk kl km gt ab cb"><figure class="oz kn pk pb pc pd pe paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/85fbdcc2e58794917abee566d75b148c.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/format:webp/1*CqO074z4VlJn23eoC6jaYQ.png"/></div></figure><figure class="oz kn pl pb pc pd pe paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/ddfa37b6fd34514770bf4c08d7b063c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*4H4Ae2PIl9v-yB2BY3iQ8A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk pg di ph pi translated">左:非平稳时间序列(有趋势)；右图:平稳时间序列(去趋势)</p></figure></div><p id="4477" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">页（page的缩写）s:如果一阶差分无法消除趋势，您可以使用公式进行二阶差分:<br/><strong class="lb iu">(t)时的值= t时的原始值—2 * t-1时的原始值+t-2时的原始值</strong></p><p id="1536" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">P.P.S .:二阶差分得到的时间序列有<em class="lv"> N — 2 </em>个观测值。这是因为不能为前两个观察值创建差值(没有什么可以从中减去)。</p><h1 id="d198" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">季节性(或周期性)</h1><p id="9b8c" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">如果时间序列以相等的间隔重复，比如每12个月、每1周、每4个月等等，那么它就是周期性的。</p><p id="869f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们检查一下我们的时间序列是否有季节性因素。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="2d0f" class="mz ly it mv b gy na nb l nc nd">plt.figure(figsize=(11,4), dpi= 80)<br/>data['Consumption'].plot(linewidth = 0.5)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pm"><img src="../Images/308b7630d4570205f0fd9dcbdbeeafe5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F6CAcrVqhj_2INh1IMRaog.png"/></div></div></figure><p id="b8c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">似乎我们的消费时间序列每12个月重复一次。我们可以在每年的年初和年末看到一个高峰，在仲夏月份看到一个低谷。</p><p id="a41d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以深入研究某一年，看看是否有任何周季节性。这里我们来看两个月的数据:2010年1月和2010年2月:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="9492" class="mz ly it mv b gy na nb l nc nd">data.loc['2010-01': '2010-02','Consumption'].plot(marker = 'o', figsize=(11, 9))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/83a2b1ac7296c4cec9d3a46579834bde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*Age-SC3CXzg_BMV3XUuTfg.png"/></div></figure><p id="ae34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，周线振荡非常明显。周末的耗电量通常较低，而工作日的耗电量则相当高。</p><h1 id="79f1" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">自相关</h1><p id="ff3a" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">自相关是一种分析季节性的技术。它描绘了时间序列在不同时间滞后时与其自身的相关性。</p><p id="a0e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很困惑吗？</p><p id="8c3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用教程<a class="ae ky" href="https://www.datacamp.com/community/tutorials/time-series-analysis-tutorial" rel="noopener ugc nofollow" target="_blank">这里的</a>，我学到了一种理解自相关的非常直观的方法。它基本上是说，如果你把一个时间序列向前或向后移动12个月(滞后= 12)，它会以某种方式映射到自身。自相关是判断这种映射有多好的一种方式。如果非常好，这意味着时间序列和移位的时间序列几乎相似，并且在该时间滞后处的相关性会很高。自相关的概念捕捉到了一个时间序列与其自身的这种移动版本的相关性(大声喊出<a class="po pp ep" href="https://medium.com/u/f2a4d039f34a?source=post_page-----f726d87a97d8--------------------------------" rel="noopener" target="_blank">雨果·鲍恩-安德森</a>这个精彩的解释，我在这里重复了一遍)。</p><h2 id="a571" class="mz ly it bd lz nl nm dn md nn no dp mh li np nq mj lm nr ns ml lq nt nu mn nv bi translated">用Python绘制时间序列的自相关</h2><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="a4ea" class="mz ly it mv b gy na nb l nc nd">plt.figure(figsize=(11,4), dpi= 80)<br/>pd.plotting.autocorrelation_plot(data.loc['2012-01': '2013-01', 'Consumption']);</span></pre><p id="041c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我展示剧情之前，最好能给我一些关于如何阅读剧情的建议。在x轴上，你有滞后，在y轴上，你有时间序列在滞后时的相关程度。如果原始的消费时间序列每两天重复一次，您将会在自相关图中看到滞后2天的峰值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pq"><img src="../Images/2e8b2b47b2f535110248af549f94a19f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_R60xqyXCEvUSq9598fYuA.png"/></div></div></figure><p id="e1ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从图中，我们可以看到在第7天的滞后时有一个相关性高峰，然后在第14天再次出现，依此类推。这意味着时间序列每7天重复一次，即每周一次。这种模式会在3个月后(大约100天)消失。随着你越走越远，相关性越来越小。</p><p id="9cbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面图中的虚线实际上告诉了你相关的统计意义。上升到虚线之上或下降到虚线之下的每个尖峰被认为是统计上显著的。</p><p id="4008" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们可以确定消费序列是真正的自相关的，滞后一周。</p><p id="4dac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:为了简洁，我们只绘制了时间序列数据子集的自相关图。如果我们要扩展到包括完整的数据集，自相关图看起来还是一样的。</p><h1 id="ea5d" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">从时间序列数据中提取重要特征</h1><p id="5d7f" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">有时，提取每个时间戳(即我们数据的每一行)的月份、星期几、日期等是很重要的。由于我们已经有了日期时间格式的索引集，提取这些元素变得非常容易:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="6f49" class="mz ly it mv b gy na nb l nc nd"><em class="lv"># Extract the year, month, date separately using the index set</em><br/>data['Year'] = data.index.year<br/>data['Month'] = data.index.month<br/>data['Weekday_Name'] = data.index.weekday_name</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/568218db452259d4c68dd3f886b9e946.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*McXhWi19-xB542uAPf5E-Q.png"/></div></figure><p id="42ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以将这些附加特征作为模型的输入。但是在Python中的时间序列建模的第2部分中会有更多的介绍(希望下周)。</p><p id="9a2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些附加功能对于数据集的探索性分析也很有用。例如，我们可以画出每个月的中值功耗。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="ccac" class="mz ly it mv b gy na nb l nc nd">import seaborn as sns</span><span id="f60e" class="mz ly it mv b gy ox nb l nc nd">fig, axes = plt.subplots(3, 1, figsize=(11, 10), sharex=True)</span><span id="aee0" class="mz ly it mv b gy ox nb l nc nd">for name, ax in zip(['Consumption', 'Solar', 'Wind'], axes):<br/>    sns.boxplot(data=data, x='Month', y=name, ax=ax)<br/>    ax.set_ylabel('GWh')<br/>    ax.set_title(name)<br/>    <em class="lv"># Keep the x-axis label for only the bottom subplot</em><br/>    if ax != axes[-1]:<br/>        ax.set_xlabel('')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ps"><img src="../Images/c36eae833e597d1454be4e0b6e7fe052.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uKdrvrVcMA_CZbyioaIyqg.png"/></div></div></figure></div><div class="ab cl pt pu hx pv" role="separator"><span class="pw bw bk px py pz"/><span class="pw bw bk px py pz"/><span class="pw bw bk px py"/></div><div class="im in io ip iq"><p id="f521" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望这篇热情洋溢的时序数据介绍足以让您入门。在本文的<a class="ae ky" href="https://medium.com/@vishi2020/time-series-modeling-using-scikit-pandas-and-numpy-682e3b8db8d1" rel="noopener">第2部分</a>中，我们将学习如何开发预测模型来预测某一天的用电量。在<a class="ae ky" href="https://medium.com/towards-artificial-intelligence/tackling-the-time-series-take-home-assignment-a-case-study-in-python-b2a3bd78d956" rel="noopener">第三部分</a>，我们将进行一个案例研究，分析呼叫中心产生的时间序列数据，主要是分析(可怕的)放弃率的增加。</p><p id="d01b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">直到下次:)</p></div><div class="ab cl pt pu hx pv" role="separator"><span class="pw bw bk px py pz"/><span class="pw bw bk px py pz"/><span class="pw bw bk px py"/></div><div class="im in io ip iq"><p id="721c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我喜欢写循序渐进的初学者指南、操作指南、面试问题、ML/AI中使用的解码术语等。如果你想完全访问我的所有文章(以及其他媒体上的文章)，那么你可以使用 <a class="ae ky" href="https://varshitasher.medium.com/membership" rel="noopener"> <strong class="lb iu"> <em class="lv">我的链接</em></strong></a><strong class="lb iu"><em class="lv"/></strong><em class="lv">这里</em> <strong class="lb iu"> <em class="lv">注册。</em> </strong></p><div class="qa qb gp gr qc qd"><a rel="noopener follow" target="_blank" href="/data-scientists-guide-to-efficient-coding-in-python-670c78a7bf79"><div class="qe ab fo"><div class="qf ab qg cl cj qh"><h2 class="bd iu gy z fp qi fr fs qj fu fw is bi translated">数据科学家的Python高效编码指南</h2><div class="qk l"><h3 class="bd b gy z fp qi fr fs qj fu fw dk translated">我每天用来编写干净代码的技巧和窍门</h3></div><div class="ql l"><p class="bd b dl z fp qi fr fs qj fu fw dk translated">towardsdatascience.com</p></div></div><div class="qm l"><div class="qn l qo qp qq qm qr ks qd"/></div></div></a></div><div class="qa qb gp gr qc qd"><a rel="noopener follow" target="_blank" href="/understanding-python-imports-init-py-and-pythonpath-once-and-for-all-4c5249ab6355"><div class="qe ab fo"><div class="qf ab qg cl cj qh"><h2 class="bd iu gy z fp qi fr fs qj fu fw is bi translated">了解Python导入，__init__。py和pythonpath —一劳永逸</h2><div class="qk l"><h3 class="bd b gy z fp qi fr fs qj fu fw dk translated">了解如何导入包和模块(以及两者之间的区别)</h3></div><div class="ql l"><p class="bd b dl z fp qi fr fs qj fu fw dk translated">towardsdatascience.com</p></div></div><div class="qm l"><div class="qs l qo qp qq qm qr ks qd"/></div></div></a></div><div class="qa qb gp gr qc qd"><a rel="noopener follow" target="_blank" href="/time-series-modeling-using-scikit-pandas-and-numpy-682e3b8db8d1"><div class="qe ab fo"><div class="qf ab qg cl cj qh"><h2 class="bd iu gy z fp qi fr fs qj fu fw is bi translated">使用Scikit、Pandas和Numpy进行时间序列建模</h2><div class="qk l"><h3 class="bd b gy z fp qi fr fs qj fu fw dk translated">直观地利用季节性来提高模型准确性。</h3></div><div class="ql l"><p class="bd b dl z fp qi fr fs qj fu fw dk translated">towardsdatascience.com</p></div></div><div class="qm l"><div class="qt l qo qp qq qm qr ks qd"/></div></div></a></div><div class="qa qb gp gr qc qd"><a rel="noopener follow" target="_blank" href="/step-by-step-guide-to-explaining-your-ml-project-during-a-data-science-interview-81dfaaa408bf"><div class="qe ab fo"><div class="qf ab qg cl cj qh"><h2 class="bd iu gy z fp qi fr fs qj fu fw is bi translated">在数据科学面试中解释你的ML项目的逐步指南。</h2><div class="qk l"><h3 class="bd b gy z fp qi fr fs qj fu fw dk translated">在结尾有一个额外的样本脚本，让你谨慎地展示你的技术技能！</h3></div><div class="ql l"><p class="bd b dl z fp qi fr fs qj fu fw dk translated">towardsdatascience.com</p></div></div><div class="qm l"><div class="qu l qo qp qq qm qr ks qd"/></div></div></a></div><div class="qa qb gp gr qc qd"><a rel="noopener follow" target="_blank" href="/beginners-guide-to-building-artificial-neural-networks-using-keras-in-python-bdc4989dab00"><div class="qe ab fo"><div class="qf ab qg cl cj qh"><h2 class="bd iu gy z fp qi fr fs qj fu fw is bi translated">使用Python中的Keras构建人工神经网络的初学者指南</h2><div class="qk l"><h3 class="bd b gy z fp qi fr fs qj fu fw dk translated">创建网络架构、训练、验证和保存模型并使用它进行推理的提示和技巧。</h3></div><div class="ql l"><p class="bd b dl z fp qi fr fs qj fu fw dk translated">towardsdatascience.com</p></div></div><div class="qm l"><div class="qv l qo qp qq qm qr ks qd"/></div></div></a></div></div></div>    
</body>
</html>