<html>
<head>
<title>Learn Python Lambda from Scratch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从头开始学习 Python Lambda</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/learn-python-lambda-from-scratch-f4a9c07e4b34?source=collection_archive---------33-----------------------#2020-07-06">https://towardsdatascience.com/learn-python-lambda-from-scratch-f4a9c07e4b34?source=collection_archive---------33-----------------------#2020-07-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4c9e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Python 中 lambda 函数的注意事项</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b0ee4aecac3b466e0f15cbac21ecb4c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MCHpC_2pvsTbI6Wv"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@benwhitephotography" rel="noopener ugc nofollow" target="_blank">本在<a class="ae ky" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank">上写下</a>un splash</a></p></figure><p id="8b50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated">当处理元素列表时，Python 程序员通常有三种选择:常规的<em class="me"> for 循环</em>、<em class="me">列表理解</em>和<em class="me"> lambda 函数</em>。对于 Python 初学者来说，lambda 函数通常被认为是“一个很酷的特性”，因为它的语法很短，而且与函数式编程很相似。但是对于初学者来说，这通常不是很简单。另一方面，即使对于长期使用 Python 的人来说，也不是每个人都一定熟悉 lambda，因为他们总能找到简单的替代方法。</p><p id="d3da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相对于 lambda 函数，我个人更喜欢<em class="me">list/dict</em>comprehension。在本文中，我们将一起从头开始学习 Python Lambda 及其注意事项，无论您是初级还是高级 Python 程序员。我们开始吧！</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h2 id="2691" class="mm mn it bd mo mp mq dn mr ms mt dp mu li mv mw mx lm my mz na lq nb nc nd ne bi translated">什么是 Lambda 函数？</h2><p id="828b" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">Python 中的 Lambda 函数是一个小型匿名函数。它不同于其他函数式编程语言，在其他函数式编程语言中，lambda 函数增加了功能。根据<a class="ae ky" href="https://docs.python.org/3/faq/design.html" rel="noopener ugc nofollow" target="_blank"> Python 设计 Q &amp; A </a>:</p><blockquote class="nk"><p id="116a" class="nl nm it bd nn no np nq nr ns nt lu dk translated">如果你懒得定义一个函数，Python lambdas 只是一种速记符号。</p></blockquote><p id="d675" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">我们都喜欢做懒惰的程序员，但仅此而已吗？</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h2 id="4450" class="mm mn it bd mo mp mq dn mr ms mt dp mu li mv mw mx lm my mz na lq nb nc nd ne bi translated">创建 Lambda 函数</h2><p id="64af" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">lambda 函数是用一个表达式定义的，而不是我们通常在 Python 中使用的<code class="fe nz oa ob oc b">def</code>。任何 lambda 函数都遵循相同的规则:</p><pre class="kj kk kl km gt od oc oe of aw og bi"><span id="2c0c" class="mm mn it oc b gy oh oi l oj ok">lambda arguments: expression</span></pre><p id="b75e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它由三部分组成:</p><ul class=""><li id="aa13" class="ol om it lb b lc ld lf lg li on lm oo lq op lu oq or os ot bi translated"><code class="fe nz oa ob oc b">lambda</code>:任意 lambda 函数的关键字</li><li id="04bb" class="ol om it lb b lc ou lf ov li ow lm ox lq oy lu oq or os ot bi translated"><code class="fe nz oa ob oc b">arguments</code>:输入函数的参数。该函数允许多个输入参数。</li><li id="2571" class="ol om it lb b lc ou lf ov li ow lm ox lq oy lu oq or os ot bi translated"><code class="fe nz oa ob oc b">expression</code>:函数在单个表达式中将做什么。Lambda 只接受一个表达式，但可以生成多个输出。</li></ul><p id="f607" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="me">论据</em> </strong></p><p id="d580" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python lambda 函数支持各种输入参数，就像一个<code class="fe nz oa ob oc b">def</code>函数一样。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oz pa l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/8128edd32bd48402583329f4453caa5d" rel="noopener ugc nofollow" target="_blank"> lambda-arguments.py </a></p></figure><p id="756a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="me">表情</em> </strong></p><p id="acce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Lambda 函数只接受单个表达式。因为它是一个表达式，所以可能会也可能不会被赋予名称。在下面的例子中，第二个 lambda 函数被赋予值<code class="fe nz oa ob oc b">sum_lambda</code>。但是第三个 lambda 函数没有名字。正如你所看到的，它仍然工作，但是代码第一眼很难读懂。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oz pa l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/b0e3c89f9ae24ab3642278c37683f002" rel="noopener ugc nofollow" target="_blank">λfunction . py</a></p></figure><p id="9579" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要记住的一点是，<strong class="lb iu"> lambda 函数不能包含任何语句</strong>。区分表达式和语句的一个简单的技巧是，如果你可以打印它或者给它赋值，那么它就是一个表达式。否则就是声明。</p><p id="c373" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在 Python 中，语句包括<code class="fe nz oa ob oc b">return</code>、<code class="fe nz oa ob oc b">try</code>、<code class="fe nz oa ob oc b">assert</code>、<code class="fe nz oa ob oc b">if</code>、<code class="fe nz oa ob oc b">for</code>、<code class="fe nz oa ob oc b">raise</code>等。如果 lambda 函数包含一个语句，程序将引发<code class="fe nz oa ob oc b">SyntaxError</code>异常。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h2 id="e866" class="mm mn it bd mo mp mq dn mr ms mt dp mu li mv mw mx lm my mz na lq nb nc nd ne bi translated">检查 Lambda 函数</h2><p id="a7ae" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">那么，lambda 函数和常规函数有什么不同呢？让我们检查功能！</p><p id="b60a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用上一个例子中的函数。让我们首先检查两个函数的类型。好吧，他们属于<code class="fe nz oa ob oc b">function</code>类这就说得通了。</p><pre class="kj kk kl km gt od oc oe of aw og bi"><span id="8eba" class="mm mn it oc b gy oh oi l oj ok">&gt;&gt; print(type(sum))<br/>&gt;&gt; &lt;class 'function'&gt;<br/>&gt;&gt; print(type(sum_lambda))<br/>&gt;&gt; &lt;class 'function'&gt;</span></pre><p id="3836" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，让我们检查一下表示法。<code class="fe nz oa ob oc b">sum_lambda</code>的名字是<code class="fe nz oa ob oc b">&lt;lambda&gt;</code>而不是“函数名”。即使我们给 lambda 函数赋值，它仍然是一个匿名函数。这种行为将导致一个我们将在最后讨论的限制。(先想想)</p><pre class="kj kk kl km gt od oc oe of aw og bi"><span id="c74b" class="mm mn it oc b gy oh oi l oj ok">&gt;&gt; sum<br/>&gt;&gt; &lt;function sum at 0x10d2f30e0&gt;<br/>&gt;&gt; sum_lambda<br/>&gt;&gt; &lt;function &lt;lambda&gt; at 0x10d390200&gt;</span></pre></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h2 id="db79" class="mm mn it bd mo mp mq dn mr ms mt dp mu li mv mw mx lm my mz na lq nb nc nd ne bi translated">将 Lambda 函数与 Python 高阶函数一起使用</h2><p id="716c" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">Lambda 函数通常与 Python 高阶函数结合使用。根据维基百科，</p><blockquote class="nk"><p id="606c" class="nl nm it bd nn no np nq nr ns nt lu dk translated">高阶函数是至少执行下列操作之一的函数:a)将一个或多个函数作为参数。b)返回一个函数作为结果。</p></blockquote><p id="0ed2" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">在 Python 中，有几个内置的高阶函数，如<code class="fe nz oa ob oc b">map</code>、<code class="fe nz oa ob oc b">filter</code>、<code class="fe nz oa ob oc b">reduce</code>、<code class="fe nz oa ob oc b">sorted</code>、<code class="fe nz oa ob oc b">sum</code>、<code class="fe nz oa ob oc b">any</code>、<code class="fe nz oa ob oc b">all</code>。其中，<code class="fe nz oa ob oc b">map</code>、<code class="fe nz oa ob oc b">filter</code>和<code class="fe nz oa ob oc b">reduce</code>最常与 lambda 函数一起使用。</p><p id="5fb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="me">地图</em> </strong></p><p id="e95f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数有两个参数:一个输入映射函数和一个 iterable。映射函数将应用于 iterable 中的每个元素。<code class="fe nz oa ob oc b">map()</code>函数返回包含映射元素的迭代器。</p><p id="dfc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">映射函数可以用简洁的λ函数来表示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oz pa l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/1a9fc67ffa0087bbee95699a1756e565" rel="noopener ugc nofollow" target="_blank"> map-lambda.py </a></p></figure><p id="71c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="me">滤镜</em> </strong></p><p id="8f87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nz oa ob oc b">filter()</code>函数采用与<code class="fe nz oa ob oc b">map()</code>相同的参数:一个输入过滤函数和一个 iterable。过滤函数将应用于每个元素，<code class="fe nz oa ob oc b">filter()</code>函数返回一个包含过滤元素的迭代器。</p><p id="ffea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个使用<code class="fe nz oa ob oc b">def</code>函数和 lambda 函数过滤偶数的例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oz pa l"/></div></figure><p id="356c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="me">减少</em> </strong></p><p id="6425" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nz oa ob oc b">reduce()</code>函数来自 Python 内置模块<code class="fe nz oa ob oc b">functools</code>。它实际上是将一个函数累积应用于 iterable 中的所有元素，并生成一个值。函数有 3 个参数:一个输入函数，一个可迭代函数和一个可选的初始化函数。</p><p id="a6f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第三个例子定义了一个初始值设定项 0，每次都将 dictionary 元素中的值添加到初始值设定项中。如果初始化器没有被定义，那么默认情况下程序将把第一个元素作为初始化器，这将引发一个<code class="fe nz oa ob oc b">TypeError</code>异常。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oz pa l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/ee00a3909be0a297b6c228de28998982" rel="noopener ugc nofollow" target="_blank">减少-λpy</a></p></figure></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h2 id="38a2" class="mm mn it bd mo mp mq dn mr ms mt dp mu li mv mw mx lm my mz na lq nb nc nd ne bi translated">在 pytest 中使用 Lambda 函数</h2><p id="824d" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">您可能有一个函数<code class="fe nz oa ob oc b">generate</code>生成一个随机值列表，这些值依赖于一个外部系统。当你进行单元测试时，你不希望<code class="fe nz oa ob oc b">generate</code>函数与外部系统通信。此外，您需要来自<code class="fe nz oa ob oc b">generate</code>函数的可重复结果，而不是每次的随机值。</p><p id="2254" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在 Pytest 中，您可以使用<a class="ae ky" href="https://docs.pytest.org/en/stable/monkeypatch.html" rel="noopener ugc nofollow" target="_blank"> monkeypatch </a> fixture 来修补生成这些随机值的部分。另外，使用 lambda 函数作为补丁函数使得代码更加简洁。</p><p id="f91d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是示例代码。它使用 lambda 函数<code class="fe nz oa ob oc b">lambda _: 0</code>来修补<code class="fe nz oa ob oc b">random.randint()</code>。lambda 函数总是生成 0，它不关心输入参数，所以输入参数可以用<code class="fe nz oa ob oc b">_</code>来表示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oz pa l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/3e5e72476450ddd94a7890b10e163231" rel="noopener ugc nofollow" target="_blank"> pytest-lambda.py </a></p></figure></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h2 id="181f" class="mm mn it bd mo mp mq dn mr ms mt dp mu li mv mw mx lm my mz na lq nb nc nd ne bi translated">列表理解与λ函数</h2><p id="f7a4" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">lambda 函数的一个很好的选择是列表理解。对于<code class="fe nz oa ob oc b">map()</code>、<code class="fe nz oa ob oc b">filter()</code>、<code class="fe nz oa ob oc b">reduce()</code>，都可以用列表理解来完成。列表理解是一种介于常规 for 循环和 lambda 函数之间的解决方案。在我看来，这是一个简洁而直观的解决方案。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oz pa l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/50588b57f6322e3785450108c5f2dbe4" rel="noopener ugc nofollow" target="_blank"> list-comprehension.py </a></p></figure><p id="c68c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很好奇大家对列表理解和 lambda 函数的看法。你更喜欢哪一个，为什么？</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h2 id="569b" class="mm mn it bd mo mp mq dn mr ms mt dp mu li mv mw mx lm my mz na lq nb nc nd ne bi translated">性能比较</h2><p id="17da" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">了解 lambda 函数的性能并与常规的<code class="fe nz oa ob oc b">def</code>函数进行比较也很有趣。Lambda 函数需要的代码少，会对性能有影响吗？</p><p id="e0b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">比较内容包括:</p><ol class=""><li id="5757" class="ol om it lb b lc ld lf lg li on lm oo lq op lu pb or os ot bi translated">创建函数(v.s .常规函数)的时间</li><li id="cf0f" class="ol om it lb b lc ou lf ov li ow lm ox lq oy lu pb or os ot bi translated">调用函数的时间(v.s .常规函数)</li><li id="a45a" class="ol om it lb b lc ou lf ov li ow lm ox lq oy lu pb or os ot bi translated">是时候调用高阶函数了，比如<code class="fe nz oa ob oc b">map()</code> (v.s. for-loop 和 list comprehension)</li></ol><p id="d9e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我使用 Python 内置函数<code class="fe nz oa ob oc b"><a class="ae ky" href="https://docs.python.org/3.8/library/timeit.html" rel="noopener ugc nofollow" target="_blank">timeit</a></code>对代码片段计时。首先，我使用<code class="fe nz oa ob oc b">def</code>和 lambda 函数创建一个函数来计算一个数的平方。结果发现创建一个函数的时间几乎是一样的。</p><p id="bf4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我调用这两个函数。它们比创建一个函数花费更长的时间，但是 lambda 函数在这里没有赢得任何时间。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oz pa l"/></div></figure><p id="f73a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一个是比较 for-loop <em class="me">、</em> list comprehension 和 lambda 函数的性能。由于从映射对象到列表的转换，Lambda 函数花费的时间最长。在这种情况下，列表理解表现最好。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oz pa l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/0f8cc87c8b5895653ae97eb8c85e2af2" rel="noopener ugc nofollow" target="_blank"> lambda-compare-map.py </a></p></figure><p id="f4e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="me">速度性能可以帮助我们决定选择哪种代码风格，但不应该是唯一的因素。我们还需要考虑代码的可读性和可维护性。</em></p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h2 id="2b61" class="mm mn it bd mo mp mq dn mr ms mt dp mu li mv mw mx lm my mz na lq nb nc nd ne bi translated">使用 Lambda 函数的限制</h2><p id="e2db" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">到目前为止，我们已经讨论了 lambda 函数的一些用例。它的简写符号使代码更加优雅和简洁。然而，总是有得有失。Python 开发者要理解 lambda 函数的局限性，避免“不必要的优化”。</p><ol class=""><li id="2020" class="ol om it lb b lc ld lf lg li on lm oo lq op lu pb or os ot bi translated">在追溯中丢失信息</li></ol><p id="0258" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Lambda 函数是匿名函数，所以没有真正的函数名。当引发异常时，这可能会丢失信息。回溯只显示<code class="fe nz oa ob oc b">&lt;lambda&gt;</code>而不是有意义的函数名。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oz pa l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/97b7b76cc5f66b57517a07f4e915ee2e" rel="noopener ugc nofollow" target="_blank">λ-exception . py</a></p></figure><p id="24f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.调试麻烦</p><p id="a717" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在 IDE 中调试<code class="fe nz oa ob oc b">print(list(map(lambda x: x ** 2, [1, 2, 3])))</code>这样的语句并不容易。一种解决方法是给 lambda 函数添加一个“装饰器”。通常，我们会给一个<code class="fe nz oa ob oc b">def</code>函数添加一个像<code class="fe nz oa ob oc b">@debug</code>这样的装饰器，但是对于 lambda 函数来说这是不可能的。但实际上，decorator 是一个函数的 wapper，所以它可以将 lambda 函数作为输入参数。</p><p id="9efd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个将<code class="fe nz oa ob oc b">debug</code>装饰器应用到<code class="fe nz oa ob oc b">def</code>函数和 lambda 函数的例子。修饰 lambda 函数有助于理解 lambda 函数在高阶函数中的行为。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oz pa l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/bbe78aafacedb8075bf161064cdb7c20" rel="noopener ugc nofollow" target="_blank"> lambda-debug.py </a></p></figure><p id="59a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3.不符合 PEP8</p><p id="8104" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您将 Flake8 这样的 linter 应用到您的程序中，您将会得到一个警告:</p><blockquote class="nk"><p id="9928" class="nl nm it bd nn no np nq nr ns nt lu dk translated">不要分配 lambda 表达式，使用 def (E731)</p></blockquote><p id="a7f7" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">Flake8 给出了一个非常合理的解释,这与我之前的观点相联系:</p><blockquote class="nk"><p id="6659" class="nl nm it bd nn no np nq nr ns nt lu dk translated">这样做的主要原因是调试。Lambdas 在回溯中显示为<code class="fe nz oa ob oc b">&lt;lambda&gt;</code>，其中函数将显示函数名。</p></blockquote><p id="ce0d" class="pw-post-body-paragraph kz la it lb b lc nu ju le lf nv jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">4.不支持注释</p><p id="5b4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据<a class="ae ky" href="https://www.python.org/dev/peps/pep-3107/#lambda" rel="noopener ugc nofollow" target="_blank"> PEP 3107 </a>，lambda 的语法不支持注释。一种解决方法是使用代表函数的<code class="fe nz oa ob oc b">typing.Callable</code>。例如，<code class="fe nz oa ob oc b">Callable[[int, int], str]</code>表示一个带有两个类型为<code class="fe nz oa ob oc b">int</code>的输入参数的函数，返回值的类型为<code class="fe nz oa ob oc b">str</code>。我们可以用它来暗示 lambda 函数的类型。</p><p id="a84d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是我们如何在高阶函数中提示 lambda 函数的类型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oz pa l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/ee22a7f43843aee2f4c0d8e57a9d5144" rel="noopener ugc nofollow" target="_blank">λ-hint . py</a></p></figure><p id="9afb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢这篇文章，并且理解 Python lambda 函数的一些注意事项！如果你有任何想法，请在下面留下你的评论。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h2 id="c069" class="mm mn it bd mo mp mq dn mr ms mt dp mu li mv mw mx lm my mz na lq nb nc nd ne bi translated">参考</h2><div class="pc pd gp gr pe pf"><a href="https://realpython.com/python-lambda" rel="noopener  ugc nofollow" target="_blank"><div class="pg ab fo"><div class="ph ab pi cl cj pj"><h2 class="bd iu gy z fp pk fr fs pl fu fw is bi translated">如何使用 Python Lambda 函数——真正的 Python</h2><div class="pm l"><h3 class="bd b gy z fp pk fr fs pl fu fw dk translated">参加测验“Python 和其他编程语言中的 lambda 表达式源于 Lambda 演算，是一种……</h3></div><div class="pn l"><p class="bd b dl z fp pk fr fs pl fu fw dk translated">realpython.com</p></div></div><div class="po l"><div class="pp l pq pr ps po pt ks pf"/></div></div></a></div><div class="pc pd gp gr pe pf"><a href="https://realpython.com/python-reduce-function/" rel="noopener  ugc nofollow" target="_blank"><div class="pg ab fo"><div class="ph ab pi cl cj pj"><h2 class="bd iu gy z fp pk fr fs pl fu fw is bi translated">Python 的 reduce():从函数式到 Python 式——真正的 Python</h2><div class="pm l"><h3 class="bd b gy z fp pk fr fs pl fu fw dk translated">在本教程中，您将学习到:函数式编程是一种编程范式，它基于将一个问题分解成…</h3></div><div class="pn l"><p class="bd b dl z fp pk fr fs pl fu fw dk translated">realpython.com</p></div></div><div class="po l"><div class="pu l pq pr ps po pt ks pf"/></div></div></a></div></div></div>    
</body>
</html>