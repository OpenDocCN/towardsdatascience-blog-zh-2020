# Python 陷阱:可变默认参数

> 原文：<https://towardsdatascience.com/python-pitfall-mutable-default-arguments-9385e8265422?source=collection_archive---------14----------------------->

## 一种让几乎所有人都感到不快的语言特征

![](img/6fafba059956ae0940cea018a3753648.png)

照片由 [uomo libero](https://unsplash.com/@uomo_libero?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

许多编程语言允许您编写接受可选参数的函数。Python 就是其中之一。这是一种使函数调用简洁(当参数可以省略时)和灵活(当需要特定的参数值时)的简便方法。但是粗心的人也潜伏着危险。

## 一个例子

为了便于说明，我们来看一个简单的算法。假设您有一个类似于`aaabbaccaaa`的字符串，并且您想要计算该字符串中每个字母的个数。您需要一个函数来返回一个字典，该字典的键是字母，值是每个字母在字符串中出现的次数的正整数。

下面是这种思想作为 Python 函数的简单实现。

## 增强:累积计数

这个功能起作用。这正是我们想要的。但现在让我们添加一个转折。如果有时我们想对一系列字符串进行计数并组合结果呢？我们希望选择多次调用`Tally`,最终得到一个包含字母计数的字典。

一种方法是将`count`字典作为函数的另一个参数:

这是一个更灵活的函数，因为它可以处理一系列字符串，而不仅仅是单个字符串。当然，如果我们愿意，我们仍然可以单独处理字符串:

## 简洁的代码，天真的方式

如果分开计数是我们最经常想要的呢？不必在每个调用中都键入空字典参数，这当然很好。不熟悉 Python，但熟悉其他编程语言中的默认参数的开发人员通常会遵循以下方法:

*   他们在网上寻找 Python 是否允许默认函数参数。
*   他们发现答案是肯定的。
*   他们很快就写出了类似这样的代码:

## 哦不，它坏了！

这是编写`Tally`函数的最显而易见的方式，这样你就不需要传入一个显式的空字典。它看起来确实是对的。但这是错误的。有一个细微的瑕疵会咬到你！让我们测试一下，看看会发生什么:

第一行完全按照我们的预期工作。它找到一个`a`，一个`b`，一个`c`。但在那之后，事情变得古怪了。这里到底发生了什么事？

## 对错误的解释

核心问题是，在 Python 中，**默认参数的值只计算一次，当函数被声明为**时。默认的参数语法`count = {}`导致 Python 解释器创建一个空字典，但是每次调用函数时都是*相同的字典对象。*

为了澄清问题，我们的中断函数的行为与此相同:

## 为什么 Python 会这样？

这不是 Python 中的 bug。即行为是故意的，不是偶然的。

然而，如果我们偏离事实，进入舆论世界，许多人——我也是其中之一——认为这是 Python 的一个设计缺陷，尽管它有合理的技术原因。这种行为违背了[函数式编程](https://en.wikipedia.org/wiki/Functional_programming)的理念。这使得编写一个返回值仅取决于其参数的确定性函数变得更加困难。

更根本的是，它违反了[最小惊喜原则](https://en.wikipedia.org/wiki/Principle_of_least_astonishment)。这种行为不是大多数程序员所期望的，这导致了错误。

用一个工具的危险怪癖来发泄自己的挫败感是很自然的。但事实就是如此。这是 Python 的行为，不会改变。改变语言中的这种古怪为时已晚，因为这样做会破坏许多依赖于它的现有程序。作为专业开发人员，理解我们的工具并正确使用它们是我们的责任。

## 如何解决这个问题

这是否意味着使用默认函数参数太危险了？一点也不。解决这个问题是可能的，这样我们仍然可以编写一个按我们想要的方式运行的`Tally`函数。这只是避免使用一个*可变的*默认值的问题。

每次调用函数时，默认情况下创建一个新的可变对象的常见方法是使用不可变的占位符值，如`None`。该函数查找占位符值，如果找到，就用一个全新的可变类型实例替换它。

这听起来很抽象，所以为了清楚起见，让我们将这个想法应用到现在熟悉的`Tally`函数中。

现在我们终于有了一个满足我们所有要求的函数。当给定一个字符串参数时，它会计算该字符串中的不同字符。当给定一个字符串参数和一个字典参数时，它将字符串的字母计数添加到给定的字典中。

## 最后的想法

如果您想要的默认值已经是一个不可变的类型，就没有必要担心这些。但是有很多可变类型需要小心，比如列表、字典、集合和大多数类实例。如果元组包含可变成员，那么它也是有风险的。

即使您的函数没有改变可选参数，如果您的函数向调用者公开可变值，也会出现不希望的副作用。例如，如果函数返回可变值，并且调用代码修改了它的状态，那么对该函数的后续调用将会看到这些修改，即使它们没有被显式传入。更糟糕的是，完全不相关的代码(可能在不同的模块中)可以调用同一个函数，从而污染彼此的内部工作。

我最近被这个问题弄得焦头烂额。我希望这篇文章能让你避免我在 Python 代码中遇到的那种令人困惑的错误。从自己的错误中学习是令人钦佩的，但我想你会同意从别人的错误中学习更令人愉快！

## 脚注

1.  关于函数定义的官方 [Python 文档是这样说的:*默认参数值在函数定义执行时从左到右求值。这意味着当函数被定义时，表达式被计算一次，并且相同的“预先计算的”值被用于每个调用。当缺省参数是一个可变对象(比如一个列表或一个字典)时，理解这一点尤其重要:如果函数修改了对象(例如，通过向列表追加一个项目)，缺省值实际上被修改了。这通常不是我们想要的。*](https://docs.python.org/3/reference/compound_stmts.html#function-definitions)
2.  参见[中有趣的讨论，这个堆栈溢出线程](https://stackoverflow.com/questions/1132941/least-astonishment-and-the-mutable-default-argument)用 Python 讨论这个设计选择。Python 的符号作用域的工作方式不同于其他语言。另外，Python 函数声明是可执行语句，而不是像其他语言那样的静态声明。这些因素导致了 Python 行为方式的技术原因。我提出“设计缺陷”的指责是出于尊重的理解，即在调用时评估默认表达式会给 Python 的设计者带来更严重的问题。