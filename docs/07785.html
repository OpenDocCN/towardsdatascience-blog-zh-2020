<html>
<head>
<title>ROC Curve explained using a COVID-19 hypothetical example: Binary &amp; Multi-Class Classification tutorial</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用新冠肺炎假设的例子解释 ROC 曲线:二元和多类分类教程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/roc-curve-explained-using-a-covid-19-hypothetical-example-binary-multi-class-classification-bab188ea869c?source=collection_archive---------8-----------------------#2020-06-10">https://towardsdatascience.com/roc-curve-explained-using-a-covid-19-hypothetical-example-binary-multi-class-classification-bab188ea869c?source=collection_archive---------8-----------------------#2020-06-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2293" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在这篇文章中，我清楚地解释了什么是 ROC 曲线以及如何阅读它。我用一个新冠肺炎的例子来说明我的观点，我也谈到了混淆矩阵。最后，我提供了用于绘制多类分类案例的 ROC 和混淆矩阵的 Python 代码。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2701299ea6d998962a2c83799612bbcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qW3Mobeew1xxnXJnBPy8LQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者做的手工素描。</p></figure><h1 id="a160" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">1.介绍</h1><p id="8c90" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">在使用机器学习<strong class="ls iu">分类</strong> <strong class="ls iu">模型</strong>的 99%的情况下，人们报告其<strong class="ls iu"> ROC </strong>曲线图(以及 AUC:ROC 下面积)以及其他指标，如模型的准确性<strong class="ls iu">混淆</strong> <strong class="ls iu">矩阵</strong>。</p><p id="94dc" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">但是<strong class="ls iu">什么是 ROC 曲线</strong>？<strong class="ls iu">它告诉我们什么？<strong class="ls iu">为什么大家都在用</strong>？<strong class="ls iu">它是如何连接到混淆矩阵的？继续阅读，你将能够回答所有这些问题。</strong></strong></p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="6480" class="ky kz it bd la lb my ld le lf mz lh li jz na ka lk kc nb kd lm kf nc kg lo lp bi translated">1.1.ROC 定义</h1><p id="6685" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated"><strong class="ls iu">受试者工作特性曲线(ROC)曲线</strong>是显示<strong class="ls iu">二元</strong> <strong class="ls iu">分类器</strong>在其<strong class="ls iu">判别阈值</strong>变化<strong class="ls iu"/>时的诊断能力的曲线图。</p><p id="20dc" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">在我深入研究细节之前，我们需要理解这个区分阈值<strong class="ls iu">在不同的模型中并不相同，而是特定于模型的。例如，如果我们有一个支持向量机(<strong class="ls iu"> SVC </strong>，那么这个阈值只不过是<strong class="ls iu">决策</strong> <strong class="ls iu">边界</strong>方程的<strong class="ls iu">偏差</strong>项。通过改变 SVM 模型中的偏差，我们实际上只是改变了决策边界的位置。看看我之前发表的 SVM 的文章，了解更多关于 SVM 车型的细节。</strong></p><p id="0f72" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">通过在各种<strong class="ls iu">阈值</strong>设置下绘制<a class="ae ne" href="https://en.wikipedia.org/wiki/True_positive_rate" rel="noopener ugc nofollow" target="_blank">真阳性率</a> ( <strong class="ls iu"> TPR </strong>)对<a class="ae ne" href="https://en.wikipedia.org/wiki/False_positive_rate" rel="noopener ugc nofollow" target="_blank">假阳性率</a> ( <strong class="ls iu"> FPR </strong>)来创建<strong class="ls iu"> ROC </strong>曲线。真阳性率也称为<a class="ae ne" href="https://en.wikipedia.org/wiki/Sensitivity_(tests)" rel="noopener ugc nofollow" target="_blank">敏感度</a>、<a class="ae ne" href="https://en.wikipedia.org/wiki/Precision_and_recall#Definition_(classification_context)" rel="noopener ugc nofollow" target="_blank">回忆</a>或机器学习中的检测概率。假阳性率也称为虚警概率，可以计算为(1<a class="ae ne" href="https://en.wikipedia.org/wiki/Specificity_(tests)" rel="noopener ugc nofollow" target="_blank">特异性</a>)。它告诉我们，我们的模型能够很好地区分这些类别。</p><p id="a9ef" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated"><em class="nd">很多术语吧？</em>等一下，我将在下一节用一个例子解释所有这些术语，这个例子会让你永远记住所有这些术语。</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><p id="37e2" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">如果你想在交互式路线图和活跃的学习社区的支持下自学数据科学，看看这个资源:<a class="ae ne" href="https://aigents.co/learn" rel="noopener ugc nofollow" target="_blank">https://aigents.co/learn</a></p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="95a5" class="ky kz it bd la lb my ld le lf mz lh li jz na ka lk kc nb kd lm kf nc kg lo lp bi translated">1.2.术语解释清楚(TP、TN、FP、FN)</h1><h2 id="fc20" class="nf kz it bd la ng nh dn le ni nj dp li lz nk nl lk md nm nn lm mh no np lo nq bi translated">新冠肺炎测试示例</h2><p id="0423" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">让我们想象一下，我们有一个<strong class="ls iu">新冠肺炎测试</strong>，它能够在几秒钟内告诉我们一个人是否被<strong class="ls iu">病毒</strong>或<strong class="ls iu">感染<strong class="ls iu">而不是</strong>。所以测试</strong>的<strong class="ls iu">输出可以是<strong class="ls iu">正</strong>(受影响)或<strong class="ls iu">负</strong>(不受影响)——我们<strong class="ls iu">有一个二进制分类情况。</strong></strong></p><p id="2a5e" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">让我们也<strong class="ls iu">假设</strong>我们知道<strong class="ls iu">地</strong> <strong class="ls iu">真相</strong>并且我们有两个种群:</p><ul class=""><li id="afc5" class="nr ns it ls b lt mm lw mn lz nt md nu mh nv ml nw nx ny nz bi translated"><strong class="ls iu"> a) </strong>认为<strong class="ls iu">确实受到影响的人</strong> ( <strong class="ls iu"> TP:真阳性，蓝色</strong>分布在下图中)以及</li><li id="de6e" class="nr ns it ls b lt oa lw ob lz oc md od mh oe ml nw nx ny nz bi translated"><strong class="ls iu"> b) </strong>人即<strong class="ls iu">不受影响</strong> ( <strong class="ls iu"> TN </strong> : <strong class="ls iu">真底片，下图中红色</strong>分布)——<strong class="ls iu">二元分类情况。</strong></li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/f4ab23a4a9ed911c773f15f8aea41a45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gcRJIQrhAdaAZ1yE2fzRPQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者做的手工素描。假设我们真的知道真相，两个人群的例子，一个受新冠肺炎影响，另一个不受影响。</p></figure><p id="a8a9" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">因此，如前所述，我们假设我们知道基本事实，即我们真的知道谁生病了，谁没生病。</p><p id="5eae" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">接下来，我们<strong class="ls iu">使用我们的 covid 测试</strong>并定义一个<strong class="ls iu">阈值</strong>(假设为 20)。如果<strong class="ls iu">测试值</strong>如果<strong class="ls iu">高于</strong><strong class="ls iu"/><strong class="ls iu">阈值</strong>，那么将此人表示为<strong class="ls iu">受影响</strong>(阳性，covid-受影响)。另一方面，如果<strong class="ls iu">测试值</strong>如果<strong class="ls iu">低于</strong><strong class="ls iu"/><strong class="ls iu">阈值</strong>，那么我们将此人表示为<strong class="ls iu">非</strong> - <strong class="ls iu">受影响</strong>(阴性，无 covid)。因此，基于测试的<strong class="ls iu">输出，我们可以将一个人表示为<strong class="ls iu">受影响</strong> ( <strong class="ls iu">阳性</strong>、<strong class="ls iu">蓝色</strong>人群)或<strong class="ls iu">非</strong>、<strong class="ls iu">受影响</strong> ( <strong class="ls iu">阴性、红色</strong>人群)。</strong></p><p id="56bb" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">要消化所有这些，请看下图。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/881a9b1e5f58395270fb025987affe14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9700_D40R0AOqLkniWqipg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者做的手工素描。假设我们真的知道真相，两个人群的例子，一个受新冠肺炎影响，另一个不受影响。此外，基于测试的输出，我们可以将一个人表示为受影响的(蓝色人群)或不受影响的(红色人群)。</p></figure><blockquote class="oh"><p id="f8a8" class="oi oj it bd ok ol om on oo op oq ml dk translated">但是有一个问题！我们的测试不可能完美！</p></blockquote><p id="9431" class="pw-post-body-paragraph lq lr it ls b lt or ju lv lw os jx ly lz ot mb mc md ou mf mg mh ov mj mk ml im bi translated">有些人会<strong class="ls iu">错误地将</strong> <em class="nd">误归类</em>为<strong class="ls iu">阳性</strong> (covid-affected，我们称此为<strong class="ls iu">假阳性</strong> ( <strong class="ls iu"> FP </strong>)或<strong class="ls iu">阴性</strong> (covid-free，我们称此为<strong class="ls iu">假</strong> <strong class="ls iu">阴性</strong> ( <strong class="ls iu"> FN </strong>)。</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h2 id="2cdb" class="nf kz it bd la ng nh dn le ni nj dp li lz nk nl lk md nm nn lm mh no np lo nq bi translated">总结:</h2><ul class=""><li id="1115" class="nr ns it ls b lt lu lw lx lz ow md ox mh oy ml nw nx ny nz bi translated"><strong class="ls iu">真阳性</strong> ( <strong class="ls iu"> TP </strong>，<strong class="ls iu">蓝色</strong>分布)是真正拥有新冠肺炎病毒的人<strong class="ls iu">。</strong></li><li id="7ec0" class="nr ns it ls b lt oa lw ob lz oc md od mh oe ml nw nx ny nz bi translated"><strong class="ls iu">真阴性(TN，红色</strong>分布<strong class="ls iu"> ) </strong>是真正没有新冠肺炎病毒的人<strong class="ls iu">。</strong></li><li id="6e45" class="nr ns it ls b lt oa lw ob lz oc md od mh oe ml nw nx ny nz bi translated"><strong class="ls iu">假阳性(FP) </strong>是指<strong class="ls iu">确实没有患病</strong>但<strong class="ls iu">根据检测</strong>，他们被<strong class="ls iu">假</strong> ( <strong class="ls iu">假</strong>)表示为<strong class="ls iu">患病</strong> ( <strong class="ls iu">阳性</strong>)。</li><li id="40b1" class="nr ns it ls b lt oa lw ob lz oc md od mh oe ml nw nx ny nz bi translated"><strong class="ls iu">假阴性(FN) </strong>是指<strong class="ls iu">真正患病</strong>而<strong class="ls iu">根据检测</strong>，他们被<strong class="ls iu">假</strong> ( <strong class="ls iu">假</strong>)表示为<strong class="ls iu">非</strong> <strong class="ls iu">患病</strong> ( <strong class="ls iu">阴性</strong>)。</li><li id="fee2" class="nr ns it ls b lt oa lw ob lz oc md od mh oe ml nw nx ny nz bi translated">对于<strong class="ls iu">完美</strong> <strong class="ls iu">情况</strong>，我们会想要<strong class="ls iu">高</strong> <strong class="ls iu">值</strong> <strong class="ls iu"> TP </strong>和<strong class="ls iu"> TN </strong>和<strong class="ls iu">零</strong> <strong class="ls iu"> FP </strong>和<strong class="ls iu">FN——这将是具有完美 ROC 曲线的完美模型。</strong></li></ul></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="1c96" class="ky kz it bd la lb my ld le lf mz lh li jz na ka lk kc nb kd lm kf nc kg lo lp bi translated">1.3.ROC 曲线、AUC 和混淆矩阵</h1><h2 id="5e9c" class="nf kz it bd la ng nh dn le ni nj dp li lz nk nl lk md nm nn lm mh no np lo nq bi translated">中华民国</h2><p id="4b93" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">既然我们已经理解了术语<strong class="ls iu"> TP、TN、FP、FN </strong>让我们再回头看看 ROC 曲线的定义。</p><blockquote class="oh"><p id="52df" class="oi oj it bd ok ol oz pa pb pc pd ml dk translated">在不同的<strong class="ak">阈值</strong>设置下，绘制<a class="ae ne" href="https://en.wikipedia.org/wiki/True_positive_rate" rel="noopener ugc nofollow" target="_blank">真阳性率</a> ( <strong class="ak"> TPR </strong>)相对于<a class="ae ne" href="https://en.wikipedia.org/wiki/False_positive_rate" rel="noopener ugc nofollow" target="_blank">假阳性率</a> ( <strong class="ak"> FPR </strong>)的<strong class="ak"> ROC </strong>曲线。换句话说，ROC 曲线显示了对于基础模型的<strong class="ak">不同阈值设置</strong>的<strong class="ak">TPR 和 FPR </strong>的权衡。</p></blockquote><figure class="pf pg ph pi pj kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/e4b0f79629f182dbbfa3472d17722fcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*thd4n2-mg4b2XW9ZkAzz4Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者做的手工素描。ROC 曲线显示了基础模型不同阈值设置的 TPR 和 FPR 之间的权衡。如果曲线在对角线之上，则模型是好的，并且高于概率(对于二元情况，概率是 50%)。如果曲线在对角线以下，模型就真的不好。</p></figure><ul class=""><li id="c64d" class="nr ns it ls b lt mm lw mn lz nt md nu mh nv ml nw nx ny nz bi translated">如果曲线在对角线上方<strong class="ls iu">，则型号为<strong class="ls iu">好</strong>且<strong class="ls iu">在</strong>上方的几率(二进制情况下几率为 50%)。如果<strong class="ls iu">曲线</strong>在</strong>对角线下方<strong class="ls iu">，则<strong class="ls iu">型号</strong>为<strong class="ls iu">不良</strong>。</strong></li></ul><h2 id="0557" class="nf kz it bd la ng nh dn le ni nj dp li lz nk nl lk md nm nn lm mh no np lo nq bi translated">联合自卫军</h2><p id="5d5b" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">如果曲线在之上<strong class="ls iu">或在</strong>之下<strong class="ls iu">对角线</strong>(机会水平)，则<strong class="ls iu"> AUC(曲线下面积)表示</strong>。<strong class="ls iu"> AUC 的值范围</strong>从<strong class="ls iu"> 0 到 1 </strong>。预测 100%错误的模型的 AUC 为 0.0，预测 100%正确的模型的 AUC 为 1.0。</p><h2 id="00fb" class="nf kz it bd la ng nh dn le ni nj dp li lz nk nl lk md nm nn lm mh no np lo nq bi translated">混乱矩阵</h2><p id="0d7f" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">使用上述所有术语，我们还可以构建由这些指标组成的著名的<strong class="ls iu">混淆矩阵</strong>，然后我们可以计算出<strong class="ls iu">真阳性率</strong>和<strong class="ls iu">假阳性率</strong>，如下图所示为<strong class="ls iu">二进制分类情况。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pk"><img src="../Images/5633f3191160d345211193b642002fa7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*COAOj2SX-v3Z-L9uuG9Idg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图来自<a class="ae ne" href="https://en.wikipedia.org/wiki/Confusion_matrix" rel="noopener ugc nofollow" target="_blank">维基百科</a>。</p></figure><p id="7817" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">估计了<strong class="ls iu">真阳性率</strong>和<strong class="ls iu">假阳性率</strong>(使用上表中的公式)<strong class="ls iu"> </strong>后，我们现在可以绘制 ROC 曲线。但是等一下！</p><p id="a37b" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated"><strong class="ls iu">真阳性率</strong>和<strong class="ls iu">假阳性率</strong>只是 2 个<strong class="ls iu">标量</strong>。<strong class="ls iu">如何才能在 ROC 剧情里真的有曲线？</strong></p><blockquote class="oh"><p id="b492" class="oi oj it bd ok ol oz pa pb pc pd ml dk translated">这是通过改变一些阈值设置来实现的。ROC 曲线显示了 TPR 和 FPR 对于不同阈值的权衡。</p></blockquote><p id="dce6" class="pw-post-body-paragraph lq lr it ls b lt or ju lv lw os jx ly lz ot mb mc md ou mf mg mh ov mj mk ml im bi translated">例如，在<strong class="ls iu">支持</strong> <strong class="ls iu">矢量</strong> <strong class="ls iu">机器</strong> ( <strong class="ls iu"> SVC </strong>)的情况下，这个<strong class="ls iu">阈值</strong>只不过是<strong class="ls iu">决策边界</strong>等式中的<strong class="ls iu">偏差</strong>项。因此，我们<strong class="ls iu">将改变这个偏差</strong>(这将改变决策边界的位置)并且<strong class="ls iu">为<strong class="ls iu">偏差</strong>的给定值估计</strong><strong class="ls iu"/>和<strong class="ls iu"> TPR </strong>。</p><p id="52b7" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">要了解关于支持向量机的一切，请看<a class="ae ne" rel="noopener" target="_blank" href="/support-vector-machines-svm-clearly-explained-a-python-tutorial-for-classification-problems-29c539f3ad8?source=friends_link&amp;sk=80f72ab272550d76a0cc3730d7c8af35">这篇</a>帖子。</p><h1 id="3db8" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">1.4.多类分类问题的 ROC 曲线和混淆矩阵</h1><p id="fb31" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated"><strong class="ls iu"> ROC </strong>曲线仅<strong class="ls iu">为<strong class="ls iu">二元</strong> <strong class="ls iu">分类</strong> <strong class="ls iu">问题</strong>定义。但是有一种方法可以整合到<strong class="ls iu">多类分类问题</strong>中。为此，如果我们有 N 个<strong class="ls iu">类，那么我们将需要定义几个</strong>模型。</strong></p><p id="47e2" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">例如，如果我们有<strong class="ls iu"> N=3 个类别</strong>，那么我们将需要定义以下案例:<strong class="ls iu">类别 1 对类别 2 的<strong class="ls iu">案例/模型 1 </strong>，类别 1 对类别 2 的<strong class="ls iu">案例/模型 2 </strong>，以及类别 1 对类别 3 的<strong class="ls iu">案例/模型 3 </strong>。</strong></p><p id="acdd" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated"><strong class="ls iu">记住</strong>在我们的新冠肺炎测试例子中，我们有两种可能的结果，即受病毒影响(<strong class="ls iu">阳性</strong>)和不受影响(<strong class="ls iu">阴性</strong>)。类似地，在多类情况下，我们再次必须定义积极和消极的结果。</p><p id="d637" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">在多类情况下，对于每种情况，<strong class="ls iu">正</strong>类是第<strong class="ls iu">第二</strong>T10】类:</p><ul class=""><li id="7913" class="nr ns it ls b lt mm lw mn lz nt md nu mh nv ml nw nx ny nz bi translated"><em class="nd">为</em> <strong class="ls iu"> <em class="nd">例</em></strong><em class="nd"/><strong class="ls iu"><em class="nd">1</em></strong><em class="nd">:</em><strong class="ls iu"><em class="nd">1 类 vs 类</em> </strong> <em class="nd">，</em> <strong class="ls iu"> <em class="nd">正</em> </strong> <em class="nd">类为 2 类</em></li><li id="6f96" class="nr ns it ls b lt oa lw ob lz oc md od mh oe ml nw nx ny nz bi translated"><em class="nd">为</em> <strong class="ls iu"> <em class="nd">例</em></strong><em class="nd"/><strong class="ls iu"><em class="nd">2</em></strong><em class="nd">:</em><strong class="ls iu"><em class="nd">类 2 vs</em></strong><em class="nd"/><strong class="ls iu"><em class="nd">正</em> </strong> <em class="nd">类 3 </em></li><li id="6927" class="nr ns it ls b lt oa lw ob lz oc md od mh oe ml nw nx ny nz bi translated"><em class="nd">为</em> <strong class="ls iu"> <em class="nd">例</em></strong><em class="nd">3:</em><strong class="ls iu"><em class="nd">类 1 vs</em></strong><em class="nd"/><strong class="ls iu"><em class="nd">正</em> </strong> <em class="nd">类 3 </em></li></ul><p id="8bfc" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">换句话说，我们可以这样想:我们问分类器“这个样本是正的还是负的？”并且分类器将预测标签(<strong class="ls iu">正</strong>或<strong class="ls iu">负</strong>)。<strong class="ls iu">将独立估计每种情况的 ROC，2，3。</strong></p><p id="f1b1" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">这同样适用于混淆矩阵。对于每种情况，我们都有一个混淆矩阵<strong class="ls iu">。</strong></p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="13d9" class="ky kz it bd la lb my ld le lf mz lh li jz na ka lk kc nb kd lm kf nc kg lo lp bi translated"><strong class="ak"> 2。Python 工作示例</strong></h1><p id="149b" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">现在，你应该对 ROC 曲线和混淆矩阵了如指掌，也应该熟悉 TP、TN、FP、FN、TPR、FPR 等术语。现在让我们构建一个<strong class="ls iu"> python </strong>工作<strong class="ls iu">的例子</strong>。</p><h2 id="2158" class="nf kz it bd la ng nh dn le ni nj dp li lz nk nl lk md nm nn lm mh no np lo nq bi translated">2.1 分类模型</h2><p id="5a42" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">在之前的<a class="ae ne" rel="noopener" target="_blank" href="/support-vector-machines-svm-clearly-explained-a-python-tutorial-for-classification-problems-29c539f3ad8?source=friends_link&amp;sk=80f72ab272550d76a0cc3730d7c8af35">帖子</a>中，我解释了什么是<strong class="ls iu"> SVC </strong>，所以这里我们将使用这样一个模型。</p><h2 id="1777" class="nf kz it bd la ng nh dn le ni nj dp li lz nk nl lk md nm nn lm mh no np lo nq bi translated"><strong class="ak"> 2.2 数据集</strong></h2><p id="e10f" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">在虹膜数据集中，我们有 3 类花和总共 4 个特征。所以分类问题不再是二元的了，因为我们有 3 个类。然而，下面的代码将为我们的<strong class="ls iu">多类分类问题</strong>估计和绘制 ROC 曲线。</p><p id="c4d7" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">为此，该模型将用于<strong class="ls iu">1 级对 2 级、2 级对 3 级以及 1 级对 3 级</strong>。因此，我们在末端有<strong class="ls iu"> 3 种情况</strong>，在每种情况下有<strong class="ls iu">，偏置将变化</strong>，以便得到给定 <strong class="ls iu">情况</strong>下<strong class="ls iu">的<strong class="ls iu"> ROC </strong>曲线—因此，3 条 ROC 曲线作为输出。</strong></p><h2 id="be2a" class="nf kz it bd la ng nh dn le ni nj dp li lz nk nl lk md nm nn lm mh no np lo nq bi translated">2.3 使用 Iris 数据和 scikit-learn 的示例</h2><h2 id="ff25" class="nf kz it bd la ng nh dn le ni nj dp li lz nk nl lk md nm nn lm mh no np lo nq bi translated">ROC 曲线和 AUC 指标</h2><pre class="kj kk kl km gt pl pm pn po aw pp bi"><span id="2ea8" class="nf kz it pm b gy pq pr l ps pt">import matplotlib.pyplot as plt<br/>from sklearn import svm, datasets<br/>from sklearn.model_selection import train_test_split<br/>from sklearn.preprocessing import label_binarize<br/>from sklearn.metrics import roc_curve, auc<br/>from sklearn.multiclass import OneVsRestClassifier<br/>from itertools import cycle<br/>plt.style.use('ggplot')</span></pre><p id="06ae" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">让我们加载数据集，将标签二进制化，并将数据分成训练集和测试集(以避免过度拟合):</p><pre class="kj kk kl km gt pl pm pn po aw pp bi"><span id="6cf6" class="nf kz it pm b gy pq pr l ps pt"># Load the iris data<br/>iris = datasets.load_iris()<br/>X = iris.data<br/>y = iris.target</span><span id="be30" class="nf kz it pm b gy pu pr l ps pt"># Binarize the output<br/>y_bin = label_binarize(y, classes=[0, 1, 2])<br/>n_classes = y_bin.shape[1]</span><span id="6608" class="nf kz it pm b gy pu pr l ps pt"># We split the data into training and test sets<br/>X_train, X_test, y_train, y_test = train_test_split(X, y_bin, test_size= 0.5, random_state=0)</span></pre><p id="fc6d" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">最后，我们建立我们的模型(SVC)并估计 3 种情况的 ROC 曲线:<strong class="ls iu">1 类对 2 类、2 类对 3 类和 1 类对 3 类。</strong></p><p id="54c2" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">每次<strong class="ls iu">正</strong>类是<strong class="ls iu">第二个</strong> <strong class="ls iu">一个</strong>即<em class="nd">为</em> <strong class="ls iu"> <em class="nd">例</em></strong><em class="nd"/><strong class="ls iu"><em class="nd">1</em></strong><em class="nd">:</em><strong class="ls iu"><em class="nd">类 1 vs</em></strong><em class="nd"/><strong class="ls iu"><em class="nd">正</em> </strong></p><pre class="kj kk kl km gt pl pm pn po aw pp bi"><span id="0519" class="nf kz it pm b gy pq pr l ps pt">#We define the model as an SVC in OneVsRestClassifier setting.<br/>#this means that the model will be used for class 1 vs class 2, #class 2vs class 3 and class 1 vs class 3. So, we have 3 cases at #the end and within each case, the bias will be varied in order to #get the ROC curve of the given case - 3 ROC curves as output.<br/>classifier = OneVsRestClassifier(svm.SVC(kernel='linear', probability=True, random_state=0))</span><span id="ca95" class="nf kz it pm b gy pu pr l ps pt">y_score = classifier.fit(X_train, y_train).decision_function(X_test)</span><span id="87e1" class="nf kz it pm b gy pu pr l ps pt"># Plotting and estimation of FPR, TPR<br/>fpr = dict()<br/>tpr = dict()<br/>roc_auc = dict()<br/>for i in range(n_classes):<br/>    fpr[i], tpr[i], _ = roc_curve(y_test[:, i], y_score[:, i])<br/>    roc_auc[i] = auc(fpr[i], tpr[i])<br/>colors = cycle(['blue', 'red', 'green'])<br/>for i, color in zip(range(n_classes), colors):<br/>    plt.plot(fpr[i], tpr[i], color=color, lw=1.5, label='ROC curve of class {0} (area = {1:0.2f})' ''.format(i+1, roc_auc[i]))<br/>plt.plot([0, 1], [0, 1], 'k-', lw=1.5)<br/>plt.xlim([-0.05, 1.0])<br/>plt.ylim([0.0, 1.05])<br/>plt.xlabel('False Positive Rate')<br/>plt.ylabel('True Positive Rate')<br/>plt.title('Receiver operating characteristic for multi-class data')<br/>plt.legend(loc="lower right")<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pv"><img src="../Images/bd42de222c8b2256d9ada5cc4ae81c40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B0ziBoAZHqd5xtD4dNoQdg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">输出图产生了我上面介绍的 python 代码。</p></figure><p id="4a2c" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated"><strong class="ls iu"> <em class="nd">提醒</em></strong>:ROC 曲线显示<strong class="ls iu">交易</strong> - <strong class="ls iu">关</strong>的<strong class="ls iu"> TPR </strong>和<strong class="ls iu"> FPR </strong>为<strong class="ls iu">不同</strong> <strong class="ls iu">阈值</strong> <strong class="ls iu">设置</strong>的底层模型。如果曲线<strong class="ls iu">高于</strong>对角线<strong class="ls iu">对角线</strong>，则模型为<strong class="ls iu">好</strong>且<strong class="ls iu">高于</strong>几率(二进制情况几率为 50%)。如果<strong class="ls iu">曲线</strong>低于对角线<strong class="ls iu">对角线</strong>，则<strong class="ls iu">型号</strong>为<strong class="ls iu">不良</strong>。</p><p id="cb0f" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">如果曲线高于的<strong class="ls iu">或低于</strong>的<strong class="ls iu">对角线</strong>(机会水平)，则<strong class="ls iu"> AUC(曲线下面积)表示</strong>。</p><h2 id="d82e" class="nf kz it bd la ng nh dn le ni nj dp li lz nk nl lk md nm nn lm mh no np lo nq bi translated">混乱矩阵</h2><p id="37e3" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">现在我们也来估算一下<strong class="ls iu">混淆矩阵。</strong></p><pre class="kj kk kl km gt pl pm pn po aw pp bi"><span id="555d" class="nf kz it pm b gy pq pr l ps pt">from sklearn import svm, datasets<br/>from sklearn.model_selection import train_test_split<br/>from sklearn.metrics import confusion_matrix</span><span id="2589" class="nf kz it pm b gy pu pr l ps pt"># Load the iris data<br/>iris = datasets.load_iris()<br/>X = iris.data<br/>y = iris.target</span><span id="db2d" class="nf kz it pm b gy pu pr l ps pt"># We split the data into training and test sets<br/>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size= 0.5, random_state=0)</span><span id="cbff" class="nf kz it pm b gy pu pr l ps pt"># the model<br/>classifier_svc = svm.SVC(kernel='linear',random_state=0)</span><span id="db7a" class="nf kz it pm b gy pu pr l ps pt"># fit the model using the training set<br/>classifier_svc.fit(X_train, y_train)</span><span id="da21" class="nf kz it pm b gy pu pr l ps pt"># predict the labels/classes of the test set<br/>y_pred = classifier_svc.predict(X_test)</span></pre><p id="cdda" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">有了<strong class="ls iu">预测</strong> <code class="fe pw px py pm b">y_pred</code>和<strong class="ls iu">基础</strong>真相<strong class="ls iu">标签</strong> <code class="fe pw px py pm b">y_test</code>，估计混淆矩阵:</p><pre class="kj kk kl km gt pl pm pn po aw pp bi"><span id="d09f" class="nf kz it pm b gy pq pr l ps pt"># build the confusion matrix<br/>cnf_matrix = confusion_matrix(y_test, y_pred)</span><span id="7f21" class="nf kz it pm b gy pu pr l ps pt">print(cnf_matrix)<br/>#[[21  0  0]<br/># [ 0 29  1]<br/># [ 0  1 23]]</span></pre><p id="106f" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">我们可以看到，我们可以<strong class="ls iu">真的</strong> <strong class="ls iu">预测</strong><strong class="ls iu">所有 3 组</strong>的标签/类别(对角线上的值大多表示高<strong class="ls iu">真的</strong> <strong class="ls iu">正的</strong> ( <strong class="ls iu"> TP </strong>)比率)。</p><p id="dd56" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated"><strong class="ls iu"> <em class="nd">提醒</em> </strong>:混淆矩阵给你看的是 TN，TP，FN，FP。对角线上的值是 TP 的计数，因此这些值越高，模型的预测能力越好。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pz"><img src="../Images/1c0d9c7b800e8bd443ca5bc440875802.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZJ5I4Q-B92v54OpjJNf8uA.png"/></div></div></figure><p id="f9a4" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">那都是乡亲们！希望你喜欢这篇文章！</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="4e66" class="ky kz it bd la lb my ld le lf mz lh li jz na ka lk kc nb kd lm kf nc kg lo lp bi translated">最新帖子</h1><div class="qa qb gp gr qc qd"><a rel="noopener follow" target="_blank" href="/time-series-forecasting-predicting-stock-prices-using-facebooks-prophet-model-9ee1657132b5"><div class="qe ab fo"><div class="qf ab qg cl cj qh"><h2 class="bd iu gy z fp qi fr fs qj fu fw is bi translated">时间序列预测:用脸书的先知模型预测股票价格</h2><div class="qk l"><h3 class="bd b gy z fp qi fr fs qj fu fw dk translated">使用可从《先知脸书》公开获得的预测模型预测股票价格</h3></div><div class="ql l"><p class="bd b dl z fp qi fr fs qj fu fw dk translated">towardsdatascience.com</p></div></div><div class="qm l"><div class="qn l qo qp qq qm qr ks qd"/></div></div></a></div><div class="qa qb gp gr qc qd"><a rel="noopener follow" target="_blank" href="/support-vector-machines-svm-clearly-explained-a-python-tutorial-for-classification-problems-29c539f3ad8"><div class="qe ab fo"><div class="qf ab qg cl cj qh"><h2 class="bd iu gy z fp qi fr fs qj fu fw is bi translated">支持向量机(SVM)解释清楚:分类问题的 python 教程…</h2><div class="qk l"><h3 class="bd b gy z fp qi fr fs qj fu fw dk translated">在这篇文章中，我解释了支持向量机的核心，为什么以及如何使用它们。此外，我还展示了如何绘制支持…</h3></div><div class="ql l"><p class="bd b dl z fp qi fr fs qj fu fw dk translated">towardsdatascience.com</p></div></div><div class="qm l"><div class="qs l qo qp qq qm qr ks qd"/></div></div></a></div><div class="qa qb gp gr qc qd"><a rel="noopener follow" target="_blank" href="/pca-clearly-explained-how-when-why-to-use-it-and-feature-importance-a-guide-in-python-7c274582c37e"><div class="qe ab fo"><div class="qf ab qg cl cj qh"><h2 class="bd iu gy z fp qi fr fs qj fu fw is bi translated">PCA 清楚地解释了——如何、何时、为什么使用它以及特性的重要性:Python 指南</h2><div class="qk l"><h3 class="bd b gy z fp qi fr fs qj fu fw dk translated">在这篇文章中，我解释了什么是 PCA，何时以及为什么使用它，以及如何使用 scikit-learn 在 Python 中实现它。还有…</h3></div><div class="ql l"><p class="bd b dl z fp qi fr fs qj fu fw dk translated">towardsdatascience.com</p></div></div><div class="qm l"><div class="qt l qo qp qq qm qr ks qd"/></div></div></a></div><div class="qa qb gp gr qc qd"><a rel="noopener follow" target="_blank" href="/everything-you-need-to-know-about-min-max-normalization-in-python-b79592732b79"><div class="qe ab fo"><div class="qf ab qg cl cj qh"><h2 class="bd iu gy z fp qi fr fs qj fu fw is bi translated">关于 Python 中的最小-最大规范化，您需要知道的一切</h2><div class="qk l"><h3 class="bd b gy z fp qi fr fs qj fu fw dk translated">在这篇文章中，我将解释什么是最小-最大缩放，什么时候使用它，以及如何使用 scikit 在 Python 中实现它</h3></div><div class="ql l"><p class="bd b dl z fp qi fr fs qj fu fw dk translated">towardsdatascience.com</p></div></div><div class="qm l"><div class="qu l qo qp qq qm qr ks qd"/></div></div></a></div><div class="qa qb gp gr qc qd"><a rel="noopener follow" target="_blank" href="/how-and-why-to-standardize-your-data-996926c2c832"><div class="qe ab fo"><div class="qf ab qg cl cj qh"><h2 class="bd iu gy z fp qi fr fs qj fu fw is bi translated">Scikit-Learn 的标准定标器如何工作</h2><div class="qk l"><h3 class="bd b gy z fp qi fr fs qj fu fw dk translated">在这篇文章中，我将解释为什么以及如何使用 scikit-learn 应用标准化</h3></div><div class="ql l"><p class="bd b dl z fp qi fr fs qj fu fw dk translated">towardsdatascience.com</p></div></div><div class="qm l"><div class="qv l qo qp qq qm qr ks qd"/></div></div></a></div></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="f0ac" class="ky kz it bd la lb my ld le lf mz lh li jz na ka lk kc nb kd lm kf nc kg lo lp bi translated">敬请关注并支持这一努力</h1><p id="0ead" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">如果你喜欢并发现这篇文章有用，请关注我！</p><p id="5381" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">有问题吗？把它们作为评论贴出来，我会尽快回复。</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="1eaf" class="ky kz it bd la lb my ld le lf mz lh li jz na ka lk kc nb kd lm kf nc kg lo lp bi translated">参考</h1><p id="61d5" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">[1]<a class="ae ne" href="https://en.wikipedia.org/wiki/Confusion_matrix" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Confusion_matrix</a></p><p id="1094" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated"><a class="ae ne" href="https://en.wikipedia.org/wiki/Support_vector_machine" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Support_vector_machine</a></p><p id="1380" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">[3]<a class="ae ne" href="https://en.wikipedia.org/wiki/Receiver_operating_characteristic" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Receiver _ operating _ character istic</a></p><p id="244e" class="pw-post-body-paragraph lq lr it ls b lt mm ju lv lw mn jx ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">[4]<a class="ae ne" href="https://scikit-learn.org/stable/modules/generated/sklearn.svm.SVC.html" rel="noopener ugc nofollow" target="_blank">https://sci kit-learn . org/stable/modules/generated/sk learn . SVM . SVC . html</a></p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="f2fd" class="ky kz it bd la lb my ld le lf mz lh li jz na ka lk kc nb kd lm kf nc kg lo lp bi translated">和我联系</h1><ul class=""><li id="2b14" class="nr ns it ls b lt lu lw lx lz ow md ox mh oy ml nw nx ny nz bi translated"><strong class="ls iu">领英</strong>:【https://www.linkedin.com/in/serafeim-loukas/】T4</li><li id="e5a6" class="nr ns it ls b lt oa lw ob lz oc md od mh oe ml nw nx ny nz bi translated"><strong class="ls iu">研究之门</strong>:<a class="ae ne" href="https://www.researchgate.net/profile/Serafeim_Loukas" rel="noopener ugc nofollow" target="_blank">https://www.researchgate.net/profile/Serafeim_Loukas</a></li><li id="9d18" class="nr ns it ls b lt oa lw ob lz oc md od mh oe ml nw nx ny nz bi translated"><strong class="ls iu">https://people.epfl.ch/serafeim.loukas</strong>EPFL<strong class="ls iu">简介</strong> : <a class="ae ne" href="https://people.epfl.ch/serafeim.loukas" rel="noopener ugc nofollow" target="_blank">美国</a></li><li id="96db" class="nr ns it ls b lt oa lw ob lz oc md od mh oe ml nw nx ny nz bi translated"><strong class="ls iu">堆栈</strong> <strong class="ls iu">溢出</strong>:<a class="ae ne" href="https://stackoverflow.com/users/5025009/seralouk" rel="noopener ugc nofollow" target="_blank">https://stackoverflow.com/users/5025009/seralouk</a></li></ul></div></div>    
</body>
</html>