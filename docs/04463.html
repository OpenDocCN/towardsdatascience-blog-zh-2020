<html>
<head>
<title>Data Warehouse Transformation Code Smells</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据仓库转换代码有味道</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/data-warehouse-transformation-code-smells-17877bb6521d?source=collection_archive---------32-----------------------#2020-04-21">https://towardsdatascience.com/data-warehouse-transformation-code-smells-17877bb6521d?source=collection_archive---------32-----------------------#2020-04-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c5f1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><em class="ki">留意SQL转换中的这些问题迹象</em></h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/68a3cf52237c27354be0b951752e6de8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7EjnK9gxr756na56"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://unsplash.com/@foodiesfeed?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">雅各布·卡普斯纳克</a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="7147" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">当涉及到转换代码时，在数据工程中有一个奇怪的范例。虽然我们越来越多地将提取和加载(“EL”)编程作为生产软件标准，但是转换代码仍然被视为二等公民。具有讽刺意味的是，转换代码通常包含复杂的业务逻辑，这可以从像对待软件一样对待软件中获益匪浅。</p><p id="1871" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">代码气味是一种表面迹象，通常对应于系统中更深层次的问题。“更简单地说，代码气味是软件中的模式，它要求我们更仔细地观察。您应用程序中的代码气味与冰箱中的实际气味没有什么不同:刺鼻的气味可能表明有令人讨厌的东西存在(就像那盒放了十年的木须肉)，或者它可能像林堡干酪一样无害。代码味道并不保证问题存在，通常情况下，最佳重构类似于不同的味道。其价值在于，每一次出现都会提示您，哪种解决方案提供了最易读、最易维护的转换代码。</p><p id="603f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">下面是一组特定于多维数据仓库转换的代码味道。遇到它们会让你停下来，给你机会离开代码库，比你发现它的时候更好。</p><h1 id="9287" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">多列联合语句</h1><pre class="kk kl km kn gt mo mp mq mr aw ms bi"><span id="8bf3" class="mt lx it mp b gy mu mv l mw mx">COALESCE(reciept_price,  <br/>         COALESCE(label_price,  <br/>                  COALESCE(catalog_price),0))) AS item_price</span></pre><p id="9981" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">翻译成英文:</strong>“如果没有收据价格，试试标签价格，如果没有标签价格，试试目录价格，如果其他都不行，把价格算成0。”</p><p id="1a09" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">为什么会有味道:</strong>在少数几列中摸索以获取第一个可用值表明数据没有被很好地理解。要么代码不知道<em class="my">为什么</em>一个列值值得优先选择，要么结果列是几个应该独立的状态的混搭。</p><p id="cd2d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">可能的重构:</strong>上面的嵌套联合很可能表示多个独立的状态被强制为假条件。考虑用显式决策树(通常是一个<code class="fe mz na nb mp b">CASE</code>语句)替换，或者将每个状态分解成不同的事实。</p><h1 id="6164" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">作为标识符的保留字</h1><pre class="kk kl km kn gt mo mp mq mr aw ms bi"><span id="663c" class="mt lx it mp b gy mu mv l mw mx">SELECT user_sp_role AS "ROLE"</span></pre><p id="ffbf" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">翻译成英文:</strong>“命名user_sp_role列<code class="fe mz na nb mp b">ROLE</code>，大家就知道是什么意思了。”</p><p id="8bcf" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">数据仓库设计的一个核心原则是界面应该简单。使用保留字(甚至是你的特定方言允许的保留字)会带来复杂性和混淆的机会。</p><p id="0002" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">可能的重构:</strong>坚持使用易于使用的详细标识符，不需要引号，并且将保持所有SQL能力的用户都可以访问数据仓库。<code class="fe mz na nb mp b">ROLE</code>可以更直观地命名为<code class="fe mz na nb mp b">web_application_role</code>，避免无谓的混淆。</p><h1 id="4f39" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">维度中的基本空值</h1><pre class="kk kl km kn gt mo mp mq mr aw ms bi"><span id="c480" class="mt lx it mp b gy mu mv l mw mx">SELECT  <br/>    customer_name  <br/>    ,customer_address_id # null means we have no address on file  <br/>    ,customer_phone  <br/>FROM   <br/>   customer</span></pre><p id="5a65" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">翻译成英文:</strong>“如果您想要所有没有注册电话号码的客户，只需选择电话号码为<code class="fe mz na nb mp b">NULL</code>的位置。”</p><p id="a19b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">为什么有味道:</strong> <code class="fe mz na nb mp b">NULL</code>在数据仓库世界里是一个非常重要的值。如果一个join出错，将会有<code class="fe mz na nb mp b">NULL</code>值。如果一个<code class="fe mz na nb mp b">group by</code>失败或者一个窗口函数没有像我们预期的那样滑动，那么就有<code class="fe mz na nb mp b">NULL</code>值。当<code class="fe mz na nb mp b">NULL</code>作为合法数据值执行双重任务时，调试变得几乎不可能。除此之外，BI工具在呈现<code class="fe mz na nb mp b">NULL</code>值时通常表现不一致，这为bug提供了一个完美的藏身之处。</p><p id="d3af" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">可能的重构:</strong>不要在维度中使用<code class="fe mz na nb mp b">NULL</code>值；明确陈述每个可能的条件(即在<code class="fe mz na nb mp b">CASE</code>语句中使用<code class="fe mz na nb mp b">ELSE</code>),这样任何<code class="fe mz na nb mp b">NULL</code>值都会立即引起审查。这不仅会强化您的转换代码，而且有助于最终产品数据的直观性。<code class="fe mz na nb mp b">NULL</code>可以表示很多东西，但是<code class="fe mz na nb mp b">'No Phone Number Available'</code>是非常清楚的。</p><p id="b955" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这种味道只适用于维度属性。<code class="fe mz na nb mp b">NULL</code>数值不仅是正确的，而且是附加事实的重要数据点(如<code class="fe mz na nb mp b">total_sale_value</code>)。</p><h1 id="38d8" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">神奇的数字</h1><pre class="kk kl km kn gt mo mp mq mr aw ms bi"><span id="2938" class="mt lx it mp b gy mu mv l mw mx">SELECT  <br/>    customer_name  <br/>    ,customer_address  <br/>    ,customer_phone  <br/>... <br/>WHERE  <br/>    customer_unit_id IN (1,3,19)  <br/>AND  <br/>    customer_value_type = "a"</span></pre><p id="f677" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">翻译成英文:</strong>“我们不再使用客户单元8或13，所以我们忽略它们(ted说1、3和19才是最重要的)。我们也只关心主要的网站客户价值类型(Bob说这些是用‘a’表示的)。</p><p id="23af" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">为什么有味道:</strong>好的代码是自文档化的。这通常意味着你可以在没有解码环的情况下阅读代码并理解它的作用。上面的例子并不是因为复杂的业务逻辑或技术复杂性而具有挑战性，而是因为它充满了<a class="ae kz" href="https://yoyodynedata.com/blog/tribal-knowledge.html" rel="noopener ugc nofollow" target="_blank">部落知识</a>。</p><p id="afc1" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">可能的重构:</strong>cte是很好的数据映射工具:</p><pre class="kk kl km kn gt mo mp mq mr aw ms bi"><span id="73a5" class="mt lx it mp b gy mu mv l mw mx">WITH   <br/>value_types AS (  <br/>    "a" AS primary_website_customer  <br/>...<br/>)  <br/>...  <br/>AND  <br/>    customer_value_type = value_types.primary_website_customer</span></pre><p id="02fb" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">当更大的重构不可行时，注释总比没有好。寻找可以更形象地命名的变量和常量，作为一种大大改进代码库的廉价方法。</p><h1 id="2da6" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">数据消除</h1><pre class="kk kl km kn gt mo mp mq mr aw ms bi"><span id="b17d" class="mt lx it mp b gy mu mv l mw mx">WITH all_visits AS (  <br/>    SELECT   <br/>        *  <br/>    FROM  <br/>        website_visits  <br/>),  <br/>SELECT  <br/>    *  <br/>FROM   <br/>    website_visits  <br/>WHERE   <br/>    visit_id IS NOT NULL</span></pre><p id="3745" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">翻译成英语:</strong>“网站访问应该总是有一个<code class="fe mz na nb mp b">visit_id</code>，所以如果他们没有，记录就是坏的，我们应该把它扔出去。”</p><p id="7042" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">为什么有味道:</strong>任何数据仓库的基础都是<em class="my">真理</em>。不仅仅是一些，而是全部的真相，这是破坏性的转换所不能提供的。缺少记录(甚至是“坏”记录)的数据仓库没有可信度，您会很快发现消费者要求访问原始源。</p><p id="92ee" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">可能的重构:</strong>转换逻辑应该是附加的，为最终用户提供更大的价值。在上面的例子中，一个新的列<code class="fe mz na nb mp b">valid_record</code>将过滤到BI层中的同一个数据集，同时为消费者提供访问“所有数据”的信心。</p><h1 id="5e93" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">假设的商业逻辑</h1><pre class="kk kl km kn gt mo mp mq mr aw ms bi"><span id="8187" class="mt lx it mp b gy mu mv l mw mx">CASE   <br/>   WHEN user_time_zone IS NULL THEN (last_login time at time zone 'pst')  <br/>   ELSE (last_login_time at time zone user_time_zone)  <br/>END AS last_login_time</span></pre><p id="ed86" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">翻译成英语:</strong>“我们的大部分网络流量来自旧金山湾区，所以如果一个网络访问丢失了时间戳，我们就把它更新到太平洋标准时间。”</p><p id="f730" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">为什么有味道:</strong>数据仓库的工作是为用户提供做出明智决策的能力，而不是为他们做决策。每次转换逻辑为数据选择路径时，它都不可避免地在这个过程中删除消费者的选项。</p><p id="e2ba" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">可能的重构:</strong>在上面的例子中，最初的<code class="fe mz na nb mp b">last_login_time</code>将理想地呈现<code class="fe mz na nb mp b">last_login_time_without_timezone</code>和<code class="fe mz na nb mp b">last_login_time_with_timezone</code>；最终用户可以自行决定对缺失的时区做出假设。</p><h1 id="0211" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">运行时间作为输入</h1><pre class="kk kl km kn gt mo mp mq mr aw ms bi"><span id="4e8b" class="mt lx it mp b gy mu mv l mw mx">SELECT  <br/>   *  <br/>FROM  <br/>   all_records  <br/>WHERE  <br/>   created_at::DATE &gt;= DATEADD('days',-1, CURRENT_DATE())</span></pre><p id="6e05" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">翻译成英文:</strong>“创建日期大于昨天的记录是新记录。”</p><p id="be47" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">为什么有异味:</strong>任何时候，相同的代码可以针对相同的数据运行两次，并返回不同的结果，请考虑这是一个问题。好的转换逻辑既是<a class="ae kz" href="https://en.wikipedia.org/wiki/Idempotence" rel="noopener ugc nofollow" target="_blank">幂等的</a>又是<a class="ae kz" href="https://en.wikipedia.org/wiki/Deterministic_system" rel="noopener ugc nofollow" target="_blank">确定性的</a>。当前日期或时间等不稳定元素会使代码变得脆弱，如果转换作业失败或运行两次，很容易使系统处于不可纠正的状态。</p><p id="a672" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">可能的重构:</strong>以自我修复的方式设计转换。使用相同的示例:</p><ul class=""><li id="ccc4" class="nc nd it lc b ld le lg lh lj ne ln nf lr ng lv nh ni nj nk bi translated">如果记录<em class="my">保证</em>增加(没有迟到的记录)，只需要稍微修改。</li></ul><pre class="kk kl km kn gt mo mp mq mr aw ms bi"><span id="a09e" class="mt lx it mp b gy mu mv l mw mx">SELECT <br/>   * <br/>FROM <br/>   all_records <br/>WHERE<br/>   created_at &gt; (SELECT MAX(created_at) FROM target_table)</span></pre><ul class=""><li id="4625" class="nc nd it lc b ld le lg lh lj ne ln nf lr ng lv nh ni nj nk bi translated">源数据的更大波动性要求更大的转换复杂性(和更大的计算成本)。根据记录到达的时间有多晚，可以使用谓词语句将代码限制在一个窗口中。</li></ul><pre class="kk kl km kn gt mo mp mq mr aw ms bi"><span id="c267" class="mt lx it mp b gy mu mv l mw mx">SELECT  <br/>all_records.*  <br/>FROM  <br/>all_records <br/>WHERE  <br/>MD5(all_records.*::TEXT) NOT IN (SELECT MD5(target_table.*::TEXT) FROM target_table)<br/><br/>/*   <br/>if records are always &lt; 30 days late, you could restrict the lookup ie (SELECT MD5(target_table.*::TEXT) FROM target_table WHERE target_table.created_at::DATE &gt;= DATEADD('days',-30, CURRENT_DATE()))  <br/>*/</span></pre><h1 id="565b" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">不一致的时态、前缀和后缀</h1><pre class="kk kl km kn gt mo mp mq mr aw ms bi"><span id="d0ce" class="mt lx it mp b gy mu mv l mw mx">SELECT <br/>   user_id <br/>   ,id <br/>   ,identifier <br/>FROM <br/>   users <br/>JOIN <br/>   site <br/>... <br/>JOIN <br/>   dim_visits</span></pre><p id="d8bf" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">翻译成英语:</strong>围绕标识符的非结构化语法，列名的不规则前缀，以及缺乏词汇系统。</p><p id="eb6c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在数据仓库中，模式就是产品接口。不可预测的词汇会给用户带来不必要的摩擦。桌子是<code class="fe mz na nb mp b">order</code>还是<code class="fe mz na nb mp b">orders</code>？栏目是<code class="fe mz na nb mp b">sale_price</code>还是<code class="fe mz na nb mp b">order_sale_price</code>？没有模式，这些都是数据仓库可用性的开销。</p><p id="eafc" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">可能的重构:</strong>选择约定。记录下来。更新转换代码以反映它们。使用同类语言的相同查询可能如下所示:</p><pre class="kk kl km kn gt mo mp mq mr aw ms bi"><span id="1b69" class="mt lx it mp b gy mu mv l mw mx">SELECT<br/>    user_id<br/>    ,site_id<br/>    ,visit_id<br/>FROM<br/>    user<br/>JOIN<br/>    site<br/>...<br/>JOIN<br/>    visit</span></pre><h1 id="6b40" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">标识符中的技术参考</h1><pre class="kk kl km kn gt mo mp mq mr aw ms bi"><span id="a73e" class="mt lx it mp b gy mu mv l mw mx">CREATE OR REPLACE TABLE POSTGRES_USERS AS ...</span></pre><p id="7023" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">翻译成英文:</strong>任何名称反映源系统(即<code class="fe mz na nb mp b">postgres_user</code>)、提取-加载介质(即<code class="fe mz na nb mp b">DATA_WAREHOUSE.STITCH.USERS</code>)或ELT过程的任何其他机械组件(即<code class="fe mz na nb mp b">cron_daily.users</code>)的表、视图、模式、数据库或列。</p><p id="dc5b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">为什么会有气味:工程师很难走出我们自己的生活空间。这种味道通常是由于设计一个“源代码向下”而不是“最终用户向上”的模式而产生的。数据仓库<em class="my">必须</em>以反映业务领域对象的方式表示信息；举个例子，某医院并没有把自己的消费者想成“<em class="my">账单用户</em>”和“<em class="my">图表系统用户</em>”和“<em class="my">处方用户</em>”，他们都是简单的“<em class="my">患者</em>”。</p><p id="679a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这是一种特别难察觉的味道，因为业务领域经常与技术领域非常接近，用户可能已经训练自己不正确地将一个与另一个对齐。如果零售商有不同的电子商务和物理销售点系统，很容易认为电子商务系统代表<code class="fe mz na nb mp b">web_users</code>而POS系统代表<code class="fe mz na nb mp b">in_store_users</code>。但事实并非如此；这家企业只有<code class="fe mz na nb mp b">CUSTOMERS</code>可能会在商店、网上或两者兼而有之。</p><p id="97bd" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">可能的重构:把你的数据产品想象成UX设计师设计意图驱动的应用程序界面的方式。如果您登录您的Medium帐户，系统会要求您输入您的<em class="my">用户名</em>和<em class="my">密码</em>，而不是您的“<a class="ae kz" href="https://medium.engineering/the-stack-that-helped-medium-drive-2-6-millennia-of-reading-time-e56801f7c492#5371" rel="noopener ugc nofollow" target="_blank">dynamo _ db</a>”<em class="my">用户名</em>和<em class="my">密码</em>。按照同样的逻辑，你的数据仓库用户群感兴趣的是<em class="my">页面访问量，</em>而不是<em class="my">谷歌分析页面访问量</em>或<em class="my"> Adobe分析页面访问量</em>。</p><h1 id="9ac9" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">代码库外部的过程/函数</h1><pre class="kk kl km kn gt mo mp mq mr aw ms bi"><span id="8f34" class="mt lx it mp b gy mu mv l mw mx">SELECT  <br/>   super_amazing_stored_proc(122, 'another_magic_value') AS RPI_VALUE</span></pre><p id="5707" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">翻译成英语:</strong>不是目标数据仓库的本地SQL方言的一部分，也不是作为代码库的一部分创建的函数。</p><p id="a25b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">为什么会有味道:</strong>如果我们将转换代码库视为构建数据仓库的蓝图，那么存储过程(不是作为代码库的一部分创建的)就是“帐外工作”。代码库不再拥有机器的所有元素，不能有效地复制仓库。这种危险而脆弱的状态使得仓库在实例崩溃时面临灾难性的失败。</p><p id="a4c1" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">可能的重构:</strong>如果你正在使用像DBT这样的SQL框架(或者任何真正的SQL预编译)，完全避免存储过程和函数。对于那些存储过程或函数是唯一可行的解决方案的罕见情况(或者如果您使用存储过程作为您的转换层)，在您的代码库中包含具有<code class="fe mz na nb mp b">DROP.. CREATE</code>或<code class="fe mz na nb mp b">CREATE OR REPLACE</code>模式的过程的定义，以确保每次运行都从您的代码中重新创建<em class="my">。这将最小化代码状态和产品状态之间的差距。</em></p><h1 id="0b65" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">引用标识符</h1><pre class="kk kl km kn gt mo mp mq mr aw ms bi"><span id="826f" class="mt lx it mp b gy mu mv l mw mx">SELECT 1776 AS "FOUNDING_YEAR" FROM countries."America"."Important Dates"</span></pre><p id="18be" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">翻译成英文:</strong>区分大小写或包含特殊字符或保留字的标识符。</p><p id="4b56" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">为什么这么说:</strong> SQL是第四代语言<a class="ae kz" href="https://en.wikipedia.org/wiki/Fourth-generation_programming_language" rel="noopener ugc nofollow" target="_blank"/>，像大小写折叠(将标识符视为不区分大小写的值)这样的约定的目的是为了更好地模拟人与人之间的交流。引用的标识符通常与这种意图背道而驰，迫使用户考虑大写，并可能导致混淆<code class="fe mz na nb mp b">"Leads_Prod"</code>与<code class="fe mz na nb mp b">"leads_prod"</code>的情况(这是两个不同的表！).</p><p id="a1e2" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">可能的重构:</strong>永远不要引用标识符。通过对数据库、表/视图和列使用详细的描述性名称来避免混淆和开销。额外的好处是，这样你的代码将是可移植的(case folding在不同的平台上是<em class="my">不</em>一致的，所以任何引用的标识符都是立即不可移植的)。</p><p id="c548" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在数据仓库的早期，有一种勇敢的努力来引用所有的东西，使得标识符尽可能的漂亮，并且可以用像T2这样的列名来准备报告。在当时，这很有意义，因为大部分消费是直接从数据仓库表到报告和电子表格摘录。今天，我认为BI工具是这种“表示抛光”的最佳场所，并且数据仓库通过保持标识符的干净和冗长而受益更多。</p><h1 id="c5c2" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">没有时区的时间戳/时区不在UTC中</h1><pre class="kk kl km kn gt mo mp mq mr aw ms bi"><span id="1fb2" class="mt lx it mp b gy mu mv l mw mx">SELECT  <br/>   TIMESTAMP '2020-01-01 13:10:02' AS questionable_tstamp  <br/>   ,TIMESTAMP WITH TIME ZONE '2020-01-01 01:11:21+04' AS another_confusing_tstamp</span></pre><p id="6f6e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">翻译成英文:</strong>任何未显式转换为UTC值的时间戳，尤其是使用“本地时间”作为标准。</p><p id="5905" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">为什么有味道:</strong>时间戳是最混乱的数据类型。时间戳的实现和处理因平台、语言和工具的不同而有很大的差异。</p><p id="5fee" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">可能的重构:</strong>显式地将所有时间戳转换为UTC进行存储。请注意，这与转换然后剥离时区<em class="my">不同</em>(这是一种奇怪但痛苦的常见做法，可能源于一种信念，即没有时区的时间戳“更容易”)。<br/>统一使用UTC将简化新数据集的入职流程，消除夏令时混乱，以及超越单一时区的面向未来的组织知识。让BI工具去担心时间戳表示(大多数工具都会这样做，那些“有用的”上游转换可能弊大于利)。</p><h1 id="f4f2" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">正常化</h1><pre class="kk kl km kn gt mo mp mq mr aw ms bi"><span id="fff1" class="mt lx it mp b gy mu mv l mw mx">SELECT  <br/>   u.user_name  <br/>   ,u.user_area_code  <br/>   ,si.site_name  <br/>FROM   <br/>   users u  <br/>INNER JOIN  <br/>   sites s  <br/>ON   <br/>   u.site_id = s.id  <br/>INNER JOIN  <br/>   site_identifiers si  <br/>ON   <br/>   s.id = si.site_id</span></pre><p id="17bb" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">翻译成英语:</strong>反映传统的<a class="ae kz" href="https://en.wikipedia.org/wiki/Boyce%E2%80%93Codd_normal_form" rel="noopener ugc nofollow" target="_blank"> BCNF </a>的模式，你会期望在事务数据库设计中找到这些模式。在这个例子中，<code class="fe mz na nb mp b">site_identifiers</code>已经从<code class="fe mz na nb mp b">site</code>中规范化出来，以保护引用完整性。</p><p id="0e63" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">闻起来的原因:</strong>数据仓库是<a class="ae kz" href="https://en.wikipedia.org/wiki/Online_analytical_processing" rel="noopener ugc nofollow" target="_blank"> OLAP </a>结构，它满足了与事务数据库完全不同的需求。规范化和引用约束是OLTP系统如何工作的重要部分——但是这些工具不利于知识库的目标。数据仓库并不代表期望的状态(即所有的<code class="fe mz na nb mp b">page_views</code>都有一个存在于<code class="fe mz na nb mp b">traffic_sources</code>表中的<code class="fe mz na nb mp b">source_id</code>，它们代表的是<em class="my">现实</em>(即一个bug将一百万个<code class="fe mz na nb mp b">page_views</code>关联到一个不存在的源)。从更高的角度来看，大量规范化的存在可能是一个强有力的指标，表明在整个代码库中已经遵循了其他OLTP约定。</p><p id="ab51" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">可能的重构:</strong>维度模型设计超出了本文的范围(为了更好地理解维度模型与事务模型的区别，我强烈推荐Ralph Kimball的<a class="ae kz" href="https://www.amazon.com/gp/product/1118530802/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1118530802&amp;linkCode=as2&amp;tag=ethanknox-20&amp;linkId=fc8ac37534bc1fe08f5177a015dfba5d" rel="noopener ugc nofollow" target="_blank">数据仓库工具包</a>)。一般来说，这些标准化值应该“退化”成宽而平的维度表，如下所示:</p><pre class="kk kl km kn gt mo mp mq mr aw ms bi"><span id="dc00" class="mt lx it mp b gy mu mv l mw mx">SELECT  <br/>   name  <br/>   ,area_code  <br/>   ,site_name  <br/>FROM   <br/>   users</span></pre><h1 id="b900" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">隐藏的“模糊”逻辑</h1><pre class="kk kl km kn gt mo mp mq mr aw ms bi"><span id="9c3f" class="mt lx it mp b gy mu mv l mw mx">-- DDL for DATA_WAREHOUSE.SESSIONS  <br/>WITH   <br/>ordered_sessions AS (  <br/>SELECT   <br/>   *   <br/>FROM   <br/>   sessions   <br/>ORDER BY insert_id  <br/>)  <br/>,session_merger AS (  <br/>SELECT  <br/>   CASE  <br/>     WHEN TIMESTAMP_DIFF(a.session_end,b.session_start) &lt; 60  <br/>   AND  <br/>     ABS(a.thumbprint_hash_points - b.thumbprint_hash_points) &lt; 5   <br/>   AND   <br/>     EARTH_DISTNACE(a.location,b.location) &lt; 0.5  <br/>   THEN LEAST(a.session_id,b.session_id)  <br/>   ELSE NULL   <br/>   END AS merged_session_id  <br/>FROM  <br/>   ordered_sessions a  <br/>INNER JOIN  <br/>   ordered_sessions b   <br/>ON   <br/>a.insert_id +1 = b.insert_id  <br/>)  <br/>,refined_sessions AS (  <br/>SELECT   <br/>   o.*  <br/>FROM  <br/>   ordered_sessions o  <br/>WHERE  <br/>   o.session_id IN (SELECT merged_session_id FROM session_merger)   <br/>)  <br/>CREATE TABLE sessions AS <br/>SELECT * FROM refined_sessions</span></pre><p id="7ea2" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">翻译成英文:</strong>被看似稳定的标识符掩盖的复杂变换。</p><p id="aaa7" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">为什么有味道:</strong>“粘糊糊的”逻辑是任意合理的业务逻辑:在上面的例子中，代码判定“两个间隔不到一分钟、指纹非常接近、来自(几乎)相同位置的会话很可能是同一个用户会话。”这里的味道不是逻辑——这是否是合并浏览器会话的准确方式取决于企业；气味代表“可能与绝对值相同的用户会话”<code class="fe mz na nb mp b">session</code>。</p><p id="531f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">可能的重构:</strong>数据仓库转换代码表示<em class="my">已知</em>为真的东西。在这个例子中，我们<em class="my">知道</em>每个会话都存在，而我们<em class="my">假设</em>某些会话实际上是同一个会话。如果假设得到业务的支持，它可以很容易地以<code class="fe mz na nb mp b">likely_parent_session</code>列的形式表示为<em class="my">附加信息</em>。这个假设之上的聚合可以存在于另外的物化中，即<code class="fe mz na nb mp b">dim_collapsed_session</code>和<code class="fe mz na nb mp b">fact_collapsed_conversion</code>等。通常需要不止一个假设来支持业务用例的范围。在这种情况下，每个假设要么可以在特定领域的市场中进一步具体化，要么被“标记”并用于丰富数据仓库中的<code class="fe mz na nb mp b">dim_session</code>。</p><pre class="kk kl km kn gt mo mp mq mr aw ms bi"><span id="1f68" class="mt lx it mp b gy mu mv l mw mx">/* downstream mart */<br/>SELECT<br/>	amalgamated_session_id <br/>	,duration<br/>	...<br/>FROM marketing.amalgamated_sessions<br/><br/>/* "branded" in dim_session */<br/>SELECT<br/>	session_id	<br/>	,aggressive_merge_session_id<br/>    ,conservative_merge_session_id<br/>    ,halifax_merge_session_id<br/>...<br/>FROM<br/>    dim_session</span></pre><h1 id="330c" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">没有消费者文件</h1><pre class="kk kl km kn gt mo mp mq mr aw ms bi"><span id="4572" class="mt lx it mp b gy mu mv l mw mx">/* what do these mean?!? */<br/>SELECT<br/>	halifax_merge_session_id <br/>	,aggressive_merge_session_id <br/>FROM<br/>	dim_session</span></pre><p id="be1e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">翻译成英语:</strong>对于使用数据仓库的消费者来说，他们需要来自转换作者的输入。</p><p id="c185" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">为什么有味道:</strong>数据仓库既是商业工具，也是消费品。像任何商业用途的复杂工具一样，它<em class="my">必须附带全面的文档。想象一下，学习使用Excel中的<code class="fe mz na nb mp b">VLOOKUP</code>函数的唯一方法是打电话给微软工程师！没有<a class="ae kz" href="https://support.office.com/en-us/article/vlookup-function-0bbc8083-26fe-4963-8ab8-93a18ad188a1" rel="noopener ugc nofollow" target="_blank">面向消费者的文档</a>，产品将无法使用。</em></p><p id="207d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">可能的重构:文档可以存在于很多地方。几乎所有的数据仓库平台都支持SQL <code class="fe mz na nb mp b">comment</code> meta for objects。如果你使用像DBT这样的转换框架，那么面向消费者的文档就和T6结合在一起了。文档也可以用类似于<a class="ae kz" href="https://www.sphinx-doc.org/en/master/" rel="noopener ugc nofollow" target="_blank"> Sphinx </a>、<a class="ae kz" href="https://readthedocs.org/" rel="noopener ugc nofollow" target="_blank">Read Docs</a>的工具来管理，甚至是简单的markdown文件。文档解决方案至少必须:*易于消费者访问。*作为数据产品的一部分进行维护。*支持有效的搜索和导航。*尽可能完整,“内部”参考</p><h1 id="813f" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">查询式标识符命名</h1><pre class="kk kl km kn gt mo mp mq mr aw ms bi"><span id="6291" class="mt lx it mp b gy mu mv l mw mx">SELECT<br/>	s.order_id<br/>	,w.order_id<br/>...<br/>FROM<br/>	confirmed_ecom_system_orders s<br/>JOIN<br/>	client_side_web_orders w</span></pre><p id="05d3" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">翻译成英文:</strong>使用速记模式的别名，往往一两个字母长。</p><p id="0694" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">为什么有味道:</strong>缩写的速记对于编写快速的即席查询非常有用。但是像所有好的软件一样，转换代码应该是自文档化的，并使用有<em class="my">含义的对象名。</em></p><p id="a47c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">可能的重构:</strong>命名标识符是软件开发中的两大难题之一。使用在转换中具有描述性和唯一性的别名，并传达所表示的表/CTE/数据集的内容:</p><pre class="kk kl km kn gt mo mp mq mr aw ms bi"><span id="a66d" class="mt lx it mp b gy mu mv l mw mx">SELECT<br/>	ecom_orders.order_id<br/>	,web_orders.order_id<br/>...<br/>FROM<br/>	confirmed_ecom_system_orders ecom_orders<br/>JOIN<br/>	client_side_web_orders web_orders</span></pre><h1 id="2d03" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">KPI中的迎合逻辑</h1><pre class="kk kl km kn gt mo mp mq mr aw ms bi"><span id="418a" class="mt lx it mp b gy mu mv l mw mx">SELECT<br/>	is_conversion_marketing<br/>	,is_conversion_business_development<br/>	,is_conversion_finance<br/>FROM <br/>	web_orders</span></pre><p id="cb11" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">翻译成英语:</strong>“垂直行业拒绝就围绕KPI的业务逻辑达成一致，因此我们支持真相的多个版本。”</p><p id="5130" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">为什么这么臭:</strong> <a class="ae kz" href="https://yoyodynedata.com/blog/is-your-company-too-dumb-to-be-data-driven.html" rel="noopener ugc nofollow" target="_blank">组织成熟度</a>是任何成功的数据计划的关键要素。如果企业不愿意(或不能)做出有时很困难的决策，并使用统一的事实来源向前推进，这种犹豫不决将反映在数据仓库代码库中。</p><p id="91ed" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">可能的重构:</strong>对这种气味的重构在技术上很简单，但实际上很难。业务必须发展，并宣布一个所有垂直行业都将采用的单一定义。在SQL中，这很简单:</p><pre class="kk kl km kn gt mo mp mq mr aw ms bi"><span id="efc3" class="mt lx it mp b gy mu mv l mw mx">SELECT<br/>	is_conversion<br/>FROM <br/>	web_orders</span></pre><p id="6b6b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在现实世界中，这可能是一个政治雷区。</p><p id="ef22" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">最初发表于<a class="ae kz" href="https://yoyodynedata.com" rel="noopener ugc nofollow" target="_blank">https://yoyodynedata.com</a>。</p></div></div>    
</body>
</html>