<html>
<head>
<title>Integrating Tensorflow and Qiskit for Quantum Machine Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">整合 Tensorflow 和 Qiskit 用于量子机器学习</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/integrating-tensorflow-and-qiskit-for-quantum-machine-learning-7fa6b14d5294?source=collection_archive---------31-----------------------#2020-08-13">https://towardsdatascience.com/integrating-tensorflow-and-qiskit-for-quantum-machine-learning-7fa6b14d5294?source=collection_archive---------31-----------------------#2020-08-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/4f63d5fcf978a88e449195bcf9c4b80a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iFmq169lT1vXr0N1ZrGuVA.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">来源:<a class="ae kf" href="https://pixabay.com/vectors/neural-network-thought-mind-mental-3816319/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><h1 id="5a9e" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">概观</h1><p id="94ec" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在标准深度学习库中存在两种流行的量子计算包集成:</p><ol class=""><li id="e9ae" class="mc md it lg b lh me ll mf lp mg lt mh lx mi mb mj mk ml mm bi translated">张量流和 Cirq 为<a class="ae kf" href="https://www.tensorflow.org/quantum" rel="noopener ugc nofollow" target="_blank">张量流量子</a></li><li id="9aeb" class="mc md it lg b lh mn ll mo lp mp lt mq lx mr mb mj mk ml mm bi translated"><a class="ae kf" href="https://qiskit.org/textbook/ch-machine-learning/machine-learning-qiskit-pytorch.html" rel="noopener ugc nofollow" target="_blank"> Pytorch 和 Qiskit </a></li></ol><p id="f949" class="pw-post-body-paragraph le lf it lg b lh me lj lk ll mf ln lo lp ms lr ls lt mt lv lw lx mu lz ma mb im bi translated">在本文中，我们将讨论在自定义 Keras 层中集成 Qiskit。</p><h1 id="b255" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">介绍</h1><p id="f47f" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">量子机器学习有一个有趣的应用，即使用量子层来帮助经典神经网络，这些量子层涉及经典无法实现的计算。学术界最近的工作强调了<em class="mv">量子辅助深度学习</em>的应用，它可以具有复杂的激活、更好的表示和其他在经典网络中无法实现的显著特征。</p><p id="49bd" class="pw-post-body-paragraph le lf it lg b lh me lj lk ll mf ln lo lp ms lr ls lt mt lv lw lx mu lz ma mb im bi translated">对于实现方面，这意味着找到一种在正常的深度神经网络中集成量子处理的方法。有几种方法可以实现这一点。在这里，我们讨论集成 Qiskit 作为 Keras 层的子类。让我们开始吧。</p><h1 id="d01e" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">定义量子层</h1><p id="09c7" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这显然取决于具体的应用。需要记住的是，这一层的输入和输出要保持一致。Tensorflow 2.x 中默认使用<code class="fe mw mx my mz b">eager_execution</code>,因此很自然地会使用<code class="fe mw mx my mz b">numpy</code>数组作为所有量子层的默认输入和输出。</p><figure class="na nb nc nd gt ju"><div class="bz fp l di"><div class="ne nf l"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">样品量子层</p></figure><p id="6ba7" class="pw-post-body-paragraph le lf it lg b lh me lj lk ll mf ln lo lp ms lr ls lt mt lv lw lx mu lz ma mb im bi translated">这是一个任意的量子层，接收四个输入，输出一个长度为 4 的 numpy 数组。我们计算标准泡利算符的期望，创建一个列表，并返回它。这一层将根据底层应用程序的具体情况而变化。</p><h1 id="2443" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">与量子层相互作用</h1><p id="f724" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">现在我们需要创建一个<code class="fe mw mx my mz b">Keras</code>层来整合我们之前定义的量子层。为此，我们需要扩展允许为 Keras 模型编写定制层的<code class="fe mw mx my mz b">tensorflow.keras.Layer</code>类。</p><figure class="na nb nc nd gt ju"><div class="bz fp l di"><div class="ne nf l"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">子类层</p></figure><p id="6516" class="pw-post-body-paragraph le lf it lg b lh me lj lk ll mf ln lo lp ms lr ls lt mt lv lw lx mu lz ma mb im bi translated">该层根据训练的<code class="fe mw mx my mz b">batch_size</code>接收输入。因此，我们需要确保每个训练示例都通过量子层来创建输出，因此需要循环。</p><p id="f56a" class="pw-post-body-paragraph le lf it lg b lh me lj lk ll mf ln lo lp ms lr ls lt mt lv lw lx mu lz ma mb im bi translated"><code class="fe mw mx my mz b">tf.executing_eagerly()</code>很重要，因为它允许我们通过<code class="fe mw mx my mz b">inputs.numpy()</code>将默认输入<code class="fe mw mx my mz b">Tensor</code>转换成一个<code class="fe mw mx my mz b">numpy</code>数组。如果应用程序依赖于 Tensorflow 1.x，则可能会调用<code class="fe mw mx my mz b">tf.enable_eager_execution()</code>来启用急切执行。直观地说，急切执行允许我们在张量的值可用时访问它们。如果它被禁用，我们需要引入 tensorflow 的会话和执行图的复杂性。</p><h1 id="2724" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">构建模型</h1><p id="416c" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">构建模型很简单。我们可以建立一个功能模型或顺序模型供我们使用。</p><figure class="na nb nc nd gt ju"><div class="bz fp l di"><div class="ne nf l"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">模型工作流</p></figure><p id="c44c" class="pw-post-body-paragraph le lf it lg b lh me lj lk ll mf ln lo lp ms lr ls lt mt lv lw lx mu lz ma mb im bi translated">用<code class="fe mw mx my mz b">run_eagerly</code>编译模型很重要。我观察到一些保存的模型在加载后不能像预期的那样工作，如果它们不是在<code class="fe mw mx my mz b">run_eagerly</code>设置为<code class="fe mw mx my mz b">True</code>的情况下编译的话。</p><h1 id="a280" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">保存和加载模型</h1><p id="79f1" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">保存照常进行。然而，加载要求您为我们创建的自定义层定义自定义类。</p><figure class="na nb nc nd gt ju"><div class="bz fp l di"><div class="ne nf l"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">保存和加载模型</p></figure><p id="8030" class="pw-post-body-paragraph le lf it lg b lh me lj lk ll mf ln lo lp ms lr ls lt mt lv lw lx mu lz ma mb im bi translated"><code class="fe mw mx my mz b">custom_objects</code>允许您定义自定义对象。它需要一个字典，其中的<code class="fe mw mx my mz b">keys</code>对应于您拥有的定制层，它们的<code class="fe mw mx my mz b">values</code>对应于您希望定制层与之相关联的定制类。这有一个微妙的警告:在一些模型的不同训练会话之间，可以改变这些层的实现。如果你有一个在本文前面给出的量子层上训练的模型，可以加载这样一个模型，并在其他一些量子逻辑上重新训练它。</p><h1 id="cba2" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">结论</h1><p id="5514" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这篇文章是使用 Qiskit 和 Tensorflow 建立一个工作的<em class="mv">量子辅助深度学习</em>架构的基本框架。有些事情需要注意:</p><ol class=""><li id="fd96" class="mc md it lg b lh me ll mf lp mg lt mh lx mi mb mj mk ml mm bi translated">计算期望值是一个主要的瓶颈。对于大批量，可能会经历巨大的减速，因为我们已经完全放弃了经典深度学习中矩阵乘法的优势。</li><li id="08c5" class="mc md it lg b lh mn ll mo lp mp lt mq lx mr mb mj mk ml mm bi translated">期望值可能真的很小。可以使用适当的标量乘数来放大它们。</li></ol><p id="2341" class="pw-post-body-paragraph le lf it lg b lh me lj lk ll mf ln lo lp ms lr ls lt mt lv lw lx mu lz ma mb im bi translated">希望这将帮助您开始在 Tensorflow 网络中使用 Qiskit powered 层。祝您愉快:)</p></div></div>    
</body>
</html>