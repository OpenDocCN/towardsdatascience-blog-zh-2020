<html>
<head>
<title>Graph Theory | Depth First Search</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">图论|深度优先搜索</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/graph-theory-depth-first-search-977c1ae386e1?source=collection_archive---------42-----------------------#2020-05-02">https://towardsdatascience.com/graph-theory-depth-first-search-977c1ae386e1?source=collection_archive---------42-----------------------#2020-05-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="3fa5" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/graph-theory-simplified" rel="noopener" target="_blank">图论简化版</a></h2><div class=""/><blockquote class="jz ka kb"><p id="9e9d" class="kc kd ke kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la im bi translated">这是我系列文章的第三篇，<a class="ae lb" href="https://medium.com/@kelvinjose/graph-theory-go-hero-1b5917da4fc1" rel="noopener">图论:Go 英雄</a>。我强烈推荐查看以前帖子的索引。</p><p id="f295" class="kc kd ke kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la im bi translated">在图论中，<strong class="kf jd">深度优先搜索</strong> ( <strong class="kf jd"> DFS </strong>)是一种重要的算法，在一些包含图的应用中起着至关重要的作用。</p></blockquote><h2 id="6979" class="lc ld it bd le lf lg dn lh li lj dp lk ll lm ln lo lp lq lr ls lt lu lv lw iz bi translated">概观</h2><p id="d546" class="pw-post-body-paragraph kc kd it kf b kg lx ki kj kk ly km kn ll lz kq kr lp ma ku kv lt mb ky kz la im bi translated">DFS 是我们可以用来探索图的节点和边的最基本的算法。这是一种遍历算法。关于 DFS 的首要事实是它的工程简单性和可理解性。DFS 运行的时间复杂度为<strong class="kf jd"> O(V + E) </strong>，其中<strong class="kf jd"> O </strong>代表<strong class="kf jd">大 O </strong>，<strong class="kf jd"> V </strong>代表<strong class="kf jd">顶点</strong>，<strong class="kf jd"> E </strong>代表<strong class="kf jd">边</strong>。不过，它的一致性可以用于其他不同的应用，如检测桥梁和关节点，计算连接的组件和估计连通性。</p><h2 id="9d63" class="lc ld it bd le lf lg dn lh li lj dp lk ll lm ln lo lp lq lr ls lt lu lv lw iz bi translated"><strong class="ak">基本 DFS </strong></h2><p id="a229" class="pw-post-body-paragraph kc kd it kf b kg lx ki kj kk ly km kn ll lz kq kr lp ma ku kv lt mb ky kz la im bi translated">顾名思义，DFS 算法访问<strong class="kf jd"> <em class="ke">深度</em> </strong>，而不管当前节点或边之后是哪个节点或边，如果我们到达了一个死胡同——从那里我们不能再前进——我们<strong class="kf jd"> <em class="ke">回溯</em> </strong>到未被访问的节点，并递归地继续这个过程<strong class="kf jd"><em class="ke"/></strong>,直到我们访问了所有可能的节点和边。我们必须确保我们的<strong class="kf jd"> <em class="ke">不会再</em> </strong>访问同一个节点<strong class="kf jd"><em class="ke"/></strong>。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/296ece68db484418bab84071ce72db11.png" data-original-src="https://miro.medium.com/v2/resize:fit:628/format:webp/1*DBj_f7UqY_c3fiQLr_qoPA.png"/></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">作者照片</p></figure><p id="525a" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn ll kp kq kr lp kt ku kv lt kx ky kz la im bi translated">对于给定的图形，有多种遍历选项可用。我在这里展示的是从节点 0 开始，然后像 1，2，3，…，9 这样继续下去。实际路径应该是 0-1-2-1-3-1-4-5-6-7-6-5-8-5-4-9。注意，我们再次回溯到几个节点，找出新的未访问路径。</p><h2 id="3273" class="lc ld it bd le lf lg dn lh li lj dp lk ll lm ln lo lp lq lr ls lt lu lv lw iz bi translated">伪码</h2><pre class="md me mf mg gt mo mp mq mr aw ms bi"><span id="d8b7" class="lc ld it mp b gy mt mu l mv mw"># global variables<br/><strong class="mp jd">n = number_of_nodes_in_the_graph<br/>g = adjacency_list<br/>visited = [false] * n</strong></span><span id="0fdc" class="lc ld it mp b gy mx mu l mv mw"><strong class="mp jd">function dfs(at):<br/>    if visited[at]:<br/>        return<br/>    visited[at] = true</strong></span><span id="8ee6" class="lc ld it mp b gy mx mu l mv mw"><strong class="mp jd">    neighbors = g[at]<br/>    for node in neighbors:<br/>        dfs(node)</strong></span><span id="41bb" class="lc ld it mp b gy mx mu l mv mw"># start DFS at node 0<br/><strong class="mp jd">start_node = 0<br/>dfs(start_node) </strong></span></pre><p id="ce7f" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn ll kp kq kr lp kt ku kv lt kx ky kz la im bi translated">我们开始定义图中节点的总数(<strong class="kf jd"><em class="ke">【n】</em></strong>)。我们将有一个<a class="ae lb" rel="noopener" target="_blank" href="/get-started-with-graph-theory-2b4460eeafc"> <strong class="kf jd"> <em class="ke">邻接表</em></strong></a>——一个用于在内存中存储图形的结构——它包括每个节点及其对应的相邻连接。这是节点到边列表的映射。我们定义一个大小为<strong class="kf jd"> <em class="ke"> n </em> </strong>的列表来表示该节点是否已经被访问过。在初始化时，列表将包含所有的<strong class="kf jd"> <em class="ke">假</em> </strong>值，因为我们还没有访问任何节点。当我们访问每个节点时，相应的位置就会被替换为<strong class="kf jd"> <em class="ke">真</em> </strong>。已经定义了一个名为<strong class="kf jd"> <em class="ke"> dfs() </em> </strong>的函数，并在伪代码末尾调用了该函数。我们将第一个要访问的节点设置为 0。当函数<em class="ke"> dfs() </em>被调用时，它检查该节点是否已经被访问过，如果没有，我们将用标志着成功访问的 true 替换此时为 false 的 visited[node]。然后，我们检索刚刚访问过的节点的邻居，并对每个邻居递归地调用<em class="ke"> dfs() </em>函数。</p><h2 id="06f1" class="lc ld it bd le lf lg dn lh li lj dp lk ll lm ln lo lp lq lr ls lt lu lv lw iz bi translated">连接的组件</h2><p id="0bd2" class="pw-post-body-paragraph kc kd it kf b kg lx ki kj kk ly km kn ll lz kq kr lp ma ku kv lt mb ky kz la im bi translated">让我们讨论一下 DFS 的一个主要用例，即在图中查找连接的组件。无向图的<strong class="kf jd">连通分量</strong>是节点的最大集合，使得每对节点通过路径连接。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi my"><img src="../Images/11015e62d4a16759731ea343195c1a01.png" data-original-src="https://miro.medium.com/v2/resize:fit:930/format:webp/1*HuK7c9GOehKUwMIsS0LEXg.png"/></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">作者照片</p></figure><p id="ecd7" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn ll kp kq kr lp kt ku kv lt kx ky kz la im bi translated">有时一个图可能被分成多个部分。连通分量形成了图顶点集合的一个<strong class="kf jd"> <em class="ke">划分</em> </strong>，意味着连通分量是非空的，它们是成对不相交的，并且连通分量的并集形成了所有顶点的集合。没有关联边的顶点也是一个独立的组件。从图中识别组件的一种方法是给它们着色。因此，每个组件都有与之相关的独特颜色。给组件着色对人类很有吸引力，但相关的问题是——如何给机器着色，例如计算机。在机器的情况下，我们可以用相似的 id(可能是一些整数)来标记组件的每个节点。就像配色方案一样，每个组件都拥有一个唯一的 id。</p><p id="be83" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn ll kp kq kr lp kt ku kv lt kx ky kz la im bi translated">我们来看看上面描述的标注是怎么做的。为了方便起见，我从上面的图表中提取了一组组件，如下所示。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi mz"><img src="../Images/6443d81f7c58ded1a97b6d371cef8cee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bYJYIa9War9hcNX3du2aZA.png"/></div></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">作者照片</p></figure><p id="c061" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn ll kp kq kr lp kt ku kv lt kx ky kz la im bi translated">首先，我们必须从<strong class="kf jd"> <em class="ke"> 0 </em> </strong>到<strong class="kf jd"> <em class="ke"> n </em> </strong>对每个节点进行显式编号，其中 n 是节点的最大数量。其思想是在每个尚未访问的节点上启动 DFS，并将所有可到达的节点标记为同一组件的一部分。如果我们从节点 0 开始，它本身已经是一个组件，因为它没有传入或传出连接，我们用整数 1 标记它。现在，如果我们选择节点 6 作为下一个节点，我们按照 6 - 14 - 16 - 14 - 5 - 11 的顺序进行 DFS，并将该组件的所有节点标记为 2。我们对图中的每个其他组件重复相同的过程。最终的结果看起来会更加丰富多彩，如下图所示。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi ne"><img src="../Images/eb17b50c9bb9969cf666ba16c52a115d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Orsi8Pypd9AQTOyybNxUCA.png"/></div></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">作者照片</p></figure><h2 id="1356" class="lc ld it bd le lf lg dn lh li lj dp lk ll lm ln lo lp lq lr ls lt lu lv lw iz bi translated">伪码</h2><pre class="md me mf mg gt mo mp mq mr aw ms bi"><span id="4401" class="lc ld it mp b gy mt mu l mv mw"># global variables<br/><strong class="mp jd">n = number_of_nodes_in_the_graph<br/>g = adjacency_list<br/>count = 0<br/>component = []<br/>visited = [false] * n</strong></span><span id="41ae" class="lc ld it mp b gy mx mu l mv mw"><strong class="mp jd">function find_components()<br/>    for(i=0; i&lt;n: i++):<br/>        if !visited[i]:<br/>            count ++<br/>            dfs(i)<br/>    return count</strong></span><span id="3efd" class="lc ld it mp b gy mx mu l mv mw"><strong class="mp jd">function dfs(at):<br/>    visited[at] = true<br/>    component[at] = count<br/>    for next in g[at]:<br/>        if !visited[next]:<br/>            dfs(next)</strong></span></pre><p id="fb1b" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn ll kp kq kr lp kt ku kv lt kx ky kz la im bi translated">我们首先定义了一些全局变量来存储列表中节点的数量，邻接表，一个存储组件数量的计数器，一个跟踪组件标签的列表和一个查看节点是否已经被访问过的列表。</p><p id="2df9" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn ll kp kq kr lp kt ku kv lt kx ky kz la im bi translated">我定义了两个名为<strong class="kf jd"><em class="ke">find _ components()</em></strong>和<strong class="kf jd"> <em class="ke"> dfs() </em> </strong>的函数。第一个函数循环遍历我们拥有的每个节点，并确保它被访问。如果没有，计数器将增加 1，以标记新组件的存在，并调用<em class="ke"> dfs() </em>函数对组件进行深度优先搜索。</p><p id="aa7d" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn ll kp kq kr lp kt ku kv lt kx ky kz la im bi translated"><em class="ke"> dfs() </em>函数采用一个参数，即每个节点的 id 作为自变量。函数<em class="ke"> dfs() </em>做的第一件也是最重要的事情是，它标记当前访问的节点，并用计数器更新组件列表。计数器值表示组件的标签。同一组件中的所有节点将具有相同的标签。然后，该函数在邻接表中搜索任何可用的邻居，并递归调用相同的函数。</p><h2 id="a865" class="lc ld it bd le lf lg dn lh li lj dp lk ll lm ln lo lp lq lr ls lt lu lv lw iz bi translated">DFS 还能做什么</h2><p id="a971" class="pw-post-body-paragraph kc kd it kf b kg lx ki kj kk ly km kn ll lz kq kr lp ma ku kv lt mb ky kz la im bi translated">我们可以将 DFS 算法扩展到:</p><ul class=""><li id="2065" class="nf ng it kf b kg kh kk kl ll nh lp ni lt nj la nk nl nm nn bi translated">计算最小生成树。</li><li id="e398" class="nf ng it kf b kg no kk np ll nq lp nr lt ns la nk nl nm nn bi translated">检测和查找图中的循环。</li><li id="ab3c" class="nf ng it kf b kg no kk np ll nq lp nr lt ns la nk nl nm nn bi translated">确定二分图。</li><li id="ff70" class="nf ng it kf b kg no kk np ll nq lp nr lt ns la nk nl nm nn bi translated">寻找强连接的组件。</li><li id="ffa0" class="nf ng it kf b kg no kk np ll nq lp nr lt ns la nk nl nm nn bi translated">对节点进行排序。</li><li id="8eba" class="nf ng it kf b kg no kk np ll nq lp nr lt ns la nk nl nm nn bi translated">找到桥梁和关节点。</li></ul><p id="8e8f" class="pw-post-body-paragraph kc kd it kf b kg kh ki kj kk kl km kn ll kp kq kr lp kt ku kv lt kx ky kz la im bi translated">这就是深度优先搜索。当然，下一个是关于<strong class="kf jd">广度优先搜索</strong>的细节。我绝对应该感谢你的时间，感谢你的努力。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi nt"><img src="../Images/12a42ea150b669878b350084c16af78d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lgzROdVHD1jDW91xwO8mVA.png"/></div></div></figure></div></div>    
</body>
</html>