<html>
<head>
<title>Introducing Hone: The Modular Object-Oriented Graphing Library For Julia</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">介绍Hone:Julia的模块化面向对象图形库</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/introducing-hone-a-modular-object-oriented-graphing-library-for-julia-823b028b462a?source=collection_archive---------67-----------------------#2020-04-20">https://towardsdatascience.com/introducing-hone-a-modular-object-oriented-graphing-library-for-julia-823b028b462a?source=collection_archive---------67-----------------------#2020-04-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cebe" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为Julia对我的图形库的第一个版本进行最后的润色。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/42c5d57f804981ccdc99317b4d1f921c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pk3AncUhPmKKzfJrQxu5fw.png"/></div></div></figure><p id="7d23" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi lq translated">绘制数据可能非常令人兴奋，尤其是当你已经使用了一段时间的绘图功能，并且它最终以你想要的方式工作的时候。尽管仍然缺少许多参数，仍然有许多令人头痛的工作要做，但是有许多非常有前途的特性已经解决了。伴随着这些伟大的东西，第一版的《征服》也随之而来。现在您可以从Github URL将Hone添加到您的Julia环境中，</p><div class="lz ma gp gr mb mc"><a href="https://github.com/emmettgb/Hone.jl" rel="noopener  ugc nofollow" target="_blank"><div class="md ab fo"><div class="me ab mf cl cj mg"><h2 class="bd iu gy z fp mh fr fs mi fu fw is bi translated">emmettgb/Hone.jl</h2><div class="mj l"><h3 class="bd b gy z fp mh fr fs mi fu fw dk translated">模块化的形状，网格和线条容易预制快速绘图简单和轻型车床集成(即将推出)…</h3></div><div class="mk l"><p class="bd b dl z fp mh fr fs mi fu fw dk translated">github.com</p></div></div><div class="ml l"><div class="mm l mn mo mp ml mq ks mc"/></div></div></a></div><blockquote class="mr"><p id="dfe2" class="ms mt it bd mu mv mw mx my mz na lp dk translated"><a class="ae nb" href="https://github.com/emmettgb/Emmetts-DS-NoteBooks/blob/master/Julia/Metaprogramming%20a%20Scatterplot%20with%20compose%20(Pt.%203).ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a></p><p id="3f22" class="ms mt it bd mu mv nc nd ne nf ng lp dk translated"><a class="ae nb" rel="noopener" target="_blank" href="/metaprogramming-a-coordinate-parser-with-compose-in-julia-a0d163c6fb21">第一部</a></p><p id="45b7" class="ms mt it bd mu mv nc nd ne nf ng lp dk translated"><a class="ae nb" rel="noopener" target="_blank" href="/metaprogramming-a-graph-class-in-julia-90a90e8ab45b">第二部分</a></p></blockquote><p id="99a0" class="pw-post-body-paragraph ku kv it kw b kx nh ju kz la ni jx lc ld nj lf lg lh nk lj lk ll nl ln lo lp im bi translated">如果您一直关注这个小系列，您可能会记得，在上一篇文章中，我们在绘图软件中留下了两个大漏洞:</p><blockquote class="mr"><p id="9b14" class="ms mt it bd mu mv nc nd ne nf ng lp dk translated">颜色和轴。</p></blockquote><h1 id="e328" class="nm nn it bd no np nq nr ns nt nu nv nw jz nx ka ny kc nz kd oa kf ob kg oc od bi translated">颜色</h1><p id="e083" class="pw-post-body-paragraph ku kv it kw b kx oe ju kz la of jx lc ld og lf lg lh oh lj lk ll oi ln lo lp im bi translated">因为我们使用meta标签来保存我们所有的数据，所以将数据转换成字符串格式可能会非常繁琐，这使得设置形状的填充颜色比通常情况下更具挑战性。哪里有问题，哪里就有想法，我想尝试的下一个想法是把我之前的两个想法结合起来。看一下我们的Circle函数，我们可以看到这个特定的问题是如何在原本打算放在那里的meta中放了一个重要的洞。</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="aaa3" class="oo nn it ok b gy op oq l or os">function Circle(x,y,diameter,fillin)<br/>   # composition = compose(context(), circle(x,y,diameter), fill(string(fillin))<br/>   #     "compose(context(),circle(.5,.5,.1))<br/>    tag = string("circle(",string(x),", ",string(y),", ",string(diameter),"fill(string(","))")<br/>    tree() = introspect(composition)<br/>    show() = composition<br/>    x = x<br/>    y = y<br/>    update(x,y) =  string("circle(",string(x),",",string(y),',',diameter,",fill(string(",Symbol(fillin),")))")<br/>    (var)-&gt;(show;composition;tree;tag;x;y;update;diameter)<br/>end</span></pre><p id="9780" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我决定的第一件事是明确使用符号而不是字符串。我决定这样做，因为我认为这样会让我在将来出于其他目的需要调用这些对象的创建时不那么头疼。我们要做的第一件事是将我在第二部分中提到的正则表达式连接到我们的符号上。我们的符号还需要字符串类型断言，如下所示:</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="6f49" class="oo nn it ok b gy op oq l or os">color = string("\"",string(fillin),"\"")</span></pre><p id="50d0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">简单得很，现在我们所要做的就是重建我们的更新函数，它要么工作，要么不工作。</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="e648" class="oo nn it ok b gy op oq l or os">update(x,y) =  string("circle(",string(x),",",string(y),',',diameter,"), fill(", color , "),")</span></pre><p id="d7b0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在让我们画些东西来测试一下！</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="03f4" class="oo nn it ok b gy op oq l or os">x = [5,6,5,5.25,5.5,5.8,5,20]<br/>y = [7,7,4,3.8,3.7,3.8,4,20]<br/>shape = Circle(.5,.5,.01,:blue)<br/>b = Scatter(x,y,shape)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/219cf1f9eb564933a1d42206a590ec28.png" data-original-src="https://miro.medium.com/v2/resize:fit:618/format:webp/1*-S6pyX9isA5NItDeSar85g.png"/></div></figure><blockquote class="mr"><p id="b29e" class="ms mt it bd mu mv mw mx my mz na lp dk translated">我可能把它画倒了…</p></blockquote><p id="5f29" class="pw-post-body-paragraph ku kv it kw b kx nh ju kz la ni jx lc ld nj lf lg lh nk lj lk ll nl ln lo lp im bi translated">现在让我们试着把颜色改成粉红色:</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="53a5" class="oo nn it ok b gy op oq l or os">x = [5,6,5,5.25,5.5,5.8,5,20]<br/>y = [7,7,4,3.8,3.7,3.8,4,20]<br/>shape = Circle(.5,.5,.01,:pink)<br/>b = Scatter(x,y,shape)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/2f8fe4f2d56ded160dc0c44f9fbfa4a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*kzWgpPFsSN2UuoVL8jnFrw.png"/></div></figure></div><div class="ab cl ov ow hx ox" role="separator"><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa"/></div><div class="im in io ip iq"><h1 id="f19b" class="nm nn it bd no np pc nr ns nt pd nv nw jz pe ka ny kc pf kd oa kf pg kg oc od bi translated">轴</h1><p id="567c" class="pw-post-body-paragraph ku kv it kw b kx oe ju kz la of jx lc ld og lf lg lh oh lj lk ll oi ln lo lp im bi translated">我休息的另一个特性是绘制x轴和y轴的能力。当然，轴只是从向量2 (0，0)到向量2 (1，0)为X轴，从向量2(0，0)到向量2(0，1)为Y轴绘制的简单直线。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/73ef64c94b4c5757fa6ed007ef2db78f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*LKDqhPF6Zl5288C-NhhdEA.png"/></div></figure><p id="d3ec" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是我们留在“Line”对象中的代码，它允许我们这样做:</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="6c86" class="oo nn it ok b gy op oq l or os">function Line(pairs, color)<br/>    tree() = introspect(composition)<br/>    show() = composition<br/>    composition = compose(context(), line(pairs), stroke(string(color)))<br/>    pairstring = ""<br/>    for i in pairs<br/>        s = string(i) * ","<br/>        pairstring = pairstring * s<br/>    end<br/>    update(pairs) = string("line([",string(join(pairstring)),"]), stroke(",string(color) ,")", )<br/>    (var)-&gt;(show;composition;tree;update;color;pairs)<br/>end</span></pre><p id="4e02" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个函数遵循与shape函数相同的自然流程，首先进行合成，然后输入元信息，然后创建一个可调用的函数，用于返回一个标签。这个函数中最突出的部分可能是迭代循环，其中创建了一个空字符串，然后与坐标位置的各个向量连接起来。之所以这样做，是因为Julia的NTuple-to-string类型断言并不像您预期的那样工作，因此一个很好的解决方法是在一个循环内将单个dim转换为字符串，而不是整个变量。</p><p id="3553" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这段代码中缺少的另一点是改变meta标记内部颜色的能力。为了解决这个问题，我当然会重复使用之前改变形状颜色的方法。第一步是将这一行添加到函数的第二步，其中定义了元表达式的各个部分。</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="449b" class="oo nn it ok b gy op oq l or os">color = string("\"",string(color),"\"")</span></pre><blockquote class="mr"><p id="b990" class="ms mt it bd mu mv mw mx my mz na lp dk translated">相当简单…</p></blockquote><p id="e5c4" class="pw-post-body-paragraph ku kv it kw b kx nh ju kz la ni jx lc ld nj lf lg lh nk lj lk ll nl ln lo lp im bi translated">现在我们可以将该字符串添加到更新函数中:</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="1f7f" class="oo nn it ok b gy op oq l or os">string("line([",string(join(pairstring)),"]), stroke(", color, "),")</span></pre><p id="11e3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">既然我们的Line对象的update函数实际上正在工作(我希望如此)，我们可以将逻辑添加到我们的Scatter类中来实际呈现线条。第一步是获取标签:</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="8ffc" class="oo nn it ok b gy op oq l or os">axisx = Line([(-1,-1), (-1,1), (1,1)],:blue)<br/>   axisx_tag = axisx.update([(-1,-1), (-1,1), (1,1)])<br/>    axisy = Line([(0,0), (0,1), (0,1)],:blue)<br/>    axisy_tag = axisy.update([(0,0), (0,1), (0,1)])</span></pre><p id="dbca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">与Shape对象不同，我们不能用update函数一致地调用同一个line对象。这是因为需要保留update函数，以便返回不会混淆整个类的内容。用不太宽泛的术语来说，如果我们要在这里添加一个回报:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pi"><img src="../Images/fe033f717da020adca8e5f11f7a5a26b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-5cyjB5_DzUV82H4lP7TKg.png"/></div></div></figure><p id="06c5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，当我们运行函数“Line”来创建行时，我们将从更新函数中获得返回。考虑到这一点，尝试避免每个函数都返回一个值是非常明智的，这样我们仍然可以在不妨碍函数的情况下获得标签。问题是，只有在调用上面的迭代循环时，这些对才会被更新，您可能记得这是将数据转换为字符串所必需的。</p><p id="8252" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在是简单的部分；回到我们的Scatter函数，我们只需要在坐标解析器完成它的工作之前向表达式添加两行标记。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/4f81cb1958e0fabdbd9b08a9f3dac818.png" data-original-src="https://miro.medium.com/v2/resize:fit:1370/format:webp/1*Sb9uJDCfL_X_27dOeFJeVg.png"/></div></figure><p id="b6ae" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可能已经注意到我硬编码了轴的颜色，这不是一成不变的，将来也不会是这样。在编程中，我从来不喜欢为了一个测试做不必要的事情。你可能还注意到我添加了一个“debug”参数，这只是为了让我更容易看到将要被计算的表达式，而不必添加临时打印。我认为这也可以帮助最终用户，因为这个库是模块化的，他们可能会自己构建很多东西。</p><blockquote class="mr"><p id="a626" class="ms mt it bd mu mv nc nd ne nf ng lp dk translated">所以让我们来测试一下吧！</p></blockquote><figure class="pl pm pn po pp kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pk"><img src="../Images/781427190da6f190240a8b4fc2fd4e0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yPeQ4iT1EhttVQ-ecyFD0A.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pq"><img src="../Images/ea273f05579735fc03f7fb8dfa55a8f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BZt-HZ2zJzdI46pFrwCm1w.png"/></div></div></figure><h2 id="8184" class="oo nn it bd no pr ps dn ns pt pu dp nw ld pv pw ny lh px py oa ll pz qa oc qb bi translated">观察</h2><p id="3289" class="pw-post-body-paragraph ku kv it kw b kx oe ju kz la of jx lc ld og lf lg lh oh lj lk ll oi ln lo lp im bi translated">首先，您可能已经注意到，笔画也应用到了圆上。这可能是一个简单的解决办法，我只需要给我们的表达式添加一个新的上下文。另一个值得注意的是右下角的点。这一点之所以存在，是因为否则颠倒的笑脸会正好在图的边缘。我认为这明确说明了在散点对象中作为参数的边距的必要性。</p><h1 id="6c5c" class="nm nn it bd no np nq nr ns nt nu nv nw jz qc ka ny kc qd kd oa kf qe kg oc od bi translated">绘制真实数据！</h1><p id="cc5a" class="pw-post-body-paragraph ku kv it kw b kx oe ju kz la of jx lc ld og lf lg lh oh lj lk ll oi ln lo lp im bi translated">既然我们的散点图起作用了，是时候用一些真实的数据来测试它了！对于这个例子，我将使用我的小“WeatherHistory.csv ”,我不知道我从哪里获得的，也不知道我有多长时间了…</p><blockquote class="mr"><p id="18f5" class="ms mt it bd mu mv nc nd ne nf ng lp dk translated">数据狂人的症状。</p></blockquote><p id="669f" class="pw-post-body-paragraph ku kv it kw b kx nh ju kz la ni jx lc ld nj lf lg lh nk lj lk ll nl ln lo lp im bi translated">像往常一样，我们需要做的第一件事是用CSV.jl读入数据。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qf"><img src="../Images/05adf63cf429a20771e899bb32b17dfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VpJWsmdxb-SZhe4bSa9tJg.png"/></div></div></figure><p id="c964" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在(不幸的是),我们需要显示参数allcols设置为true的数据。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qg"><img src="../Images/af39e5d73f8077e6a537f2a6c0394e95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eupCxuwXHvVQcJiEwbaxoA.png"/></div></div></figure><blockquote class="mr"><p id="8265" class="ms mt it bd mu mv mw mx my mz na lp dk translated">数据筛选开始了…</p></blockquote><p id="e582" class="pw-post-body-paragraph ku kv it kw b kx nh ju kz la ni jx lc ld nj lf lg lh nk lj lk ll nl ln lo lp im bi translated">找到我想要绘制的列后，我将它们放入名为“x”和“y”的变量中供我们使用。</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="d901" class="oo nn it ok b gy op oq l or os">x = df[Symbol("Wind Speed (km/h)")]<br/>y = df[Symbol("Temperature (C)")]</span></pre><p id="ee85" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，我们需要创建我们想要用来绘制点的形状:</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="77d8" class="oo nn it ok b gy op oq l or os">shape = Circle(.5,.5,.10,:lightblue)</span></pre><p id="f853" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后我们可以把它代入我们的散射函数:</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="39fe" class="oo nn it ok b gy op oq l or os">plot = Scatter(x,y,shape)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qh"><img src="../Images/692955bd3819b0324b3748b54f62103a.png" data-original-src="https://miro.medium.com/v2/resize:fit:406/format:webp/1*b5wAPcVjG-lqMT3YXFUE9A.png"/></div></div></figure><blockquote class="mr"><p id="5ad6" class="ms mt it bd mu mv mw mx my mz na lp dk translated">所以…这杀死了内核，但我不能说我感到惊讶。</p></blockquote><p id="6abc" class="pw-post-body-paragraph ku kv it kw b kx nh ju kz la ni jx lc ld nj lf lg lh nk lj lk ll nl ln lo lp im bi translated">事实上，它不仅杀死了我的内核，我认为它也杀死了韦兰。我的终端清空了，这意味着它CD回到了家里，彻底关闭了我的Jupyter服务器。</p><blockquote class="mr"><p id="5701" class="ms mt it bd mu mv nc nd ne nf ng lp dk translated">很奇怪。</p></blockquote><figure class="pl pm pn po pp kn gh gi paragraph-image"><div class="gh gi qi"><img src="../Images/4b0ab16a9d30ab369b0812de19d222fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*cnRUYVs1Hl7mbIkCef_ILg.png"/></div></figure><p id="e833" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在用for循环将X和Y数组的dim数限制到700之后(我打赌有一个默认函数我可以使用)，我们终于有了输出！令人惊讶的是，这实际上并没有花费我预期的那么长时间。我还对函数进行了计时，这样我们就可以很好地了解计算速度和分配情况。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qj"><img src="../Images/8c00e798159ac1cd121e634d96028918.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zmj-vSMCDcuCzM9ndByyRw.png"/></div></div></figure><p id="51fb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我决定做的下一件事是将它与Plots.jl进行比较，plots . JL是用于在Julia中绘图的标准库。Plots模块的问题在于它依赖于GR、Plot.ly和Matplotlib。虽然这很有趣，因为它们都是非常不同的库，并且将它们放在一个模块中肯定很酷也很奇怪，但我不认为使用Pythonic代码在Julia中绘图对性能来说是个好主意。我做的第一件比较的事情是设置限幅器到3000暗，做一个相对基本的测试。结果如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qk"><img src="../Images/f6da3e3e67ee75a6ca0863942c78a60f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xjrGAzS6AHYcqBoQbivnpg.png"/></div></div></figure><p id="1efb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于Plots.jl:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ql"><img src="../Images/3b618595367f751ef9292477e5a03476.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BCnkOiRuFABAneqBymzGSg.png"/></div></div></figure><p id="7375" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些时间没有说明的另一件事是导入Plots.jl所花费的令人痛苦的时间。好消息是我的函数比Plots.jl快得多。虽然clearly Plots绘制了更多的线条，以及图例和轴标签，但我不认为从长远来看这有什么价值，尤其是在我修改函数并寻求更多优化之后。</p><h1 id="57ac" class="nm nn it bd no np nq nr ns nt nu nv nw jz qc ka ny kc qd kd oa kf qe kg oc od bi translated">结论</h1><p id="3a5f" class="pw-post-body-paragraph ku kv it kw b kx oe ju kz la of jx lc ld og lf lg lh oh lj lk ll oi ln lo lp im bi translated">对于Hone，我还有很多事情需要完成，因为它还处于生命的早期。我认为我现在所做的所有工作将会使添加新的特征和形状变得非常容易，因为所要做的只是添加一个元表达式。使用meta的另一个很大的优点是，每个单独的对象仍将存储在内存中，并完全可以由最终用户调整，因为它存储在debug设置为true时，您可能会想起打印的相同表达式中。我对Hone最大的担忧可能是性能。虽然现在我当然可以进行一些优化，但我担心大量的优化可能会导致整个模块的彻底返工，就像发生在车床上的情况一样。虽然这可能是不可避免的，因为我喜欢不断地改进我工作的软件，我非常希望不必重写模块。</p><p id="e18a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">刚刚绘制的阵列大约有96，000个观察值，这当然是一个很大的数字，</p><blockquote class="mr"><p id="3f2e" class="ms mt it bd mu mv nc nd ne nf ng lp dk translated">但应该不是不可能的。</p></blockquote><p id="2d99" class="pw-post-body-paragraph ku kv it kw b kx nh ju kz la ni jx lc ld nj lf lg lh nk lj lk ll nl ln lo lp im bi translated">我也打算尽我所能地挑战极限，所以从这里开始并不一定是一件好事，因为这意味着我面前可能有很多工作要做。重要的是要记住，这些也是可缩放的图形；这意味着我们可以预期，在没有拉动一些字符串的情况下，类似的光栅化输出库的性能会更差。</p><p id="5c32" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">尽管它的问题和一些改进肯定是可以做的，我对它目前为止的表现非常满意，我期待着为这个包添加更多的功能和优化。</p></div></div>    
</body>
</html>