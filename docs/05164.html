<html>
<head>
<title>Recursion in Python, an exploration</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中的递归，探索</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/recursion-in-python-an-exploration-bfaa452d3260?source=collection_archive---------21-----------------------#2020-05-03">https://towardsdatascience.com/recursion-in-python-an-exploration-bfaa452d3260?source=collection_archive---------21-----------------------#2020-05-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6dc76da2c3ad85e167f9ca7feb1420ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_bl7r2rQX48Toa7D"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://xkcd.com/" rel="noopener ugc nofollow" target="_blank">图片来源</a>，<a class="ae kc" href="https://creativecommons.org/licenses/by-nc/2.5/" rel="noopener ugc nofollow" target="_blank">牌照</a></p></figure><p id="31c2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">递归是那些看起来遥不可及的想法之一，可能来自编程存在的更高层次。a .你不知道它为什么是一个东西，b .你不认为你会需要利用它。毕竟，在撰写本文时，<a class="ae kc" href="https://www.tiobe.com/tiobe-index/" rel="noopener ugc nofollow" target="_blank"> TIOBE 指数</a>的前 10 名中还没有函数式编程语言。再想想，再想想…</p><p id="cf99" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">也许你是对的，递归只对编码面试有用，否则就算了。然而，我认为学习不同的编程范例，以及它们解析问题的方式，最终会让你成为一名更好的数据科学家/程序员。学习一个新的范例会让你接触到新的思维方式和不同的代码结构。“这是我们一贯的做法”不会成为你这种态度的口头表达的一部分。因此，您将学到更多知识，并能更好地解决遇到的数据挑战。另外，如果你像我一样喜欢数学，让我们面对它，如果你在做数据科学，不喜欢数学，那么现在就离开(抱歉的语气，我爱你)，然后你会发现这项练习本身就是令人愉快的。</p><h2 id="f5b6" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">什么是递归？</h2><p id="b8ad" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">为了介绍递归，让我们做一个简单的、假设的例子来比较解决方案。您有一个数组或一个数字列表，在被程序的其余部分使用之前，需要对它们求平方。我们可以使用 python 中的循环或<strong class="kf ir">列表理解</strong>的<strong class="kf ir">来创建平方版本。</strong></p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="f58e" class="lb lc iq me b gy mi mj l mk ml"># Set array<br/>my_array = [10,11,12,13,14,15]</span><span id="0706" class="lb lc iq me b gy mm mj l mk ml"># Method 1<br/># Create a new squared array with for loop (can be considered an anti-pattern)<br/>squared_array = []<br/>for num in my_array:<br/>   squared_array.append(num*num)</span><span id="23a5" class="lb lc iq me b gy mm mj l mk ml"># Method 2<br/># Create a new squared array with list comprehension, a bit more beautiful and concise<br/>my_squared_array = [x*x for x in my_array]</span></pre><blockquote class="mn mo mp"><p id="b3f9" class="kd ke mq kf b kg kh ki kj kk kl km kn mr kp kq kr ms kt ku kv mt kx ky kz la ij bi translated">通常，当我们在 Python 这样的命令式语言中循环值时，我们使用<strong class="kf ir"> for </strong>循环或<strong class="kf ir"> while </strong>循环。这些是我们已经习惯的概念，我们经常使用它们，它们是我们的第二天性。但是如果 for 和 while 循环明天被 python 砍掉了呢？除了世界上大部分停止运作，我们还有更紧迫的问题…现在如何使用递归？？</p></blockquote><h2 id="974a" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">递归简介:平方数组</h2><p id="7802" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">我们不能使用列表理解，所以让我们使用新的 pal 递归来平方我们的数组。为此，我们需要编写一个新的函数。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="5687" class="lb lc iq me b gy mi mj l mk ml"># Set array<br/>my_array = [10,11,12,13,14,15]</span><span id="7d07" class="lb lc iq me b gy mm mj l mk ml"># Define our recursive, squared function that returns a new array<br/>def squares(an_array, n=None, ret_array=None):<br/>   if n == None:<br/>      n = len(an_array)<br/>      ret_array = []<br/>   pos = len(ret_array)<br/>   squared = an_array[pos] ** 2<br/>   ret_array.append(squared)<br/>   if n-1 == 0:<br/>       return ret_array<br/>   else:<br/>       return squares(an_array, n-1, ret_array)</span></pre><p id="bc71" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好吧，当一个列表理解就足够了的时候，这有点丑陋和冗长，但是它表明我们可以使用递归来代替 for 循环。该函数首先初始化一个保存平方值的新数组，使用 n 作为计数器来确定我们在按位置遍历数组时的位置，然后它调用自己，直到我们遍历了整个数组，随后得到新的平方数组。</p><h2 id="bd91" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">有用的提示</h2><p id="5048" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">把递归函数想象成一段代码，它不仅仅驻留在内存中的一个地方。当然，函数是在一个地方定义的，但是当数据传入时可以多次调用。这被称为<strong class="kf ir">调用堆栈。不要把它想成一条蟒蛇在吃自己的尾巴，尽管许多 R 用户会欢呼。想象一下，一群克隆人传递一个小盒子，每个人放入一枚硬币，然后将盒子传递给下一个克隆人。好吧，也许现在你更困惑了。回顾以下三个案例将有助于你理解这一点，并消除你可能有的任何困惑。</strong></p><h2 id="f84e" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">递归案例 1:标准阶乘</h2><p id="6c58" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">让我们用递归来做每个接触过递归的人都做过的事情，计算一个阶乘。还有谁爱离散数学！？</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="0868" class="lb lc iq me b gy mi mj l mk ml">def factorial(num):<br/>    if num == 1:<br/>        return 1<br/>    return num*factorial(num-1)</span></pre><p id="ce35" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">n 的阶乘(记为 n！)是所有小于 n 的正整数的乘积，是对定义为 n 的任意数的运算！= n *(n-1)*(n-2)……(1！)，其中 1！= 1.这就是我们代码中所说的<strong class="kf ir">停止条件</strong>。这个想法对递归非常重要，因为没有它，我们的代码可能会进入无限循环，导致“时间悖论，其结果可能会引起连锁反应，破坏时空连续体的结构并摧毁整个宇宙。”—布朗博士</p><blockquote class="mu"><p id="c313" class="mv mw iq bd mx my mz na nb nc nd la dk translated">S <strong class="ak"> ay 什么？</strong></p></blockquote><p id="b585" class="pw-post-body-paragraph kd ke iq kf b kg ne ki kj kk nf km kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated">这里有一个有用的方法来形象化 4 的阶乘函数。。</p><p id="f01b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">阶乘(4)= 4 *阶乘(3)= 4 * 3 *阶乘(2)= 4 * 3 * 2 *阶乘(1) = 4*3*2*1 = 24</p><p id="38e6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">factorial 函数的每个实例都与我们在<em class="mq"> def factorial() </em>中定义的相同，但它是一个新的实例，接受前一个 factorial 函数实例的结果并传递一个新的结果，所有这些都从基本情况 1 开始，在这种情况下，所有这些都将累积到最终计算中。</p><h2 id="7308" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">递归情况 2:前 N 个整数的和</h2><p id="b952" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">下面是如何使用递归对 0 和 n 之间的整数求和</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="e0c4" class="lb lc iq me b gy mi mj l mk ml">def sum_n(n):<br/>    if n == 0:<br/>        return 0<br/>    return n + sum_n(n-1)</span><span id="4e42" class="lb lc iq me b gy mm mj l mk ml">sum_n(1000)</span><span id="46b0" class="lb lc iq me b gy mm mj l mk ml">Outputs: <br/>500500</span></pre><p id="6891" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们用相同操作的封闭形式来检查我们的结果，以确保我们正确地定义了递归函数。抽查总是一个好主意，因为正如理查德·费曼所说:“首要原则是你不能欺骗自己——而你是最容易被欺骗的人。”在报价中插入我和我自己，使其个性化。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="ad3f" class="lb lc iq me b gy mi mj l mk ml">def check_sum(n):<br/>    return int(n*(n+1)/2)</span><span id="c474" class="lb lc iq me b gy mm mj l mk ml">check_sum(1000)</span><span id="d1c0" class="lb lc iq me b gy mm mj l mk ml">Outputs:<br/>500500</span></pre><h2 id="8e61" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">递归案例 3:复利</h2><p id="a7fe" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">你可能以前见过复利的公式。</p><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/2744e1a090eeca73429fbac50b3a5435.png" data-original-src="https://miro.medium.com/v2/resize:fit:324/format:webp/1*Uf9Im6GfGRuA3uWy5qQ9YQ.jpeg"/></div></figure><p id="3f9d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为我们有一个指数的数字(1+r ),那么我们可以使用递归来计算我们的未来值 FV。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="5040" class="lb lc iq me b gy mi mj l mk ml">def future_val(pv, rate, t):<br/>    if t == 0:<br/>        return pv<br/>    pv = pv*(1+rate)<br/>    return future_val(pv, rate, t-1)</span></pre><p id="30b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">前面的函数假设复利 n=1。这意味着我们每个周期 t 只复利一次，这里 t 通常是指一年的时间。让我们扩展我们的例子，以包括不同的复合利率，如每月。</p><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/fc851dca10a68e6f3c31612314fb8def.png" data-original-src="https://miro.medium.com/v2/resize:fit:368/format:webp/1*-b-KM3bCYU0FsO1cLTkXfw.jpeg"/></div></figure><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="2b26" class="lb lc iq me b gy mi mj l mk ml">def future_val_n(pv, rate, t, n):<br/>    if t == 0:<br/>        return pv<br/>    pv = future_val(pv, rate/n, n)<br/>    return future_val_n(pv, rate, t-1, n)</span></pre><p id="9173" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们已经能够回收我们的 future_val 函数，并扩展它，使我们在每个时间段 t 内复利 n 次，我们的函数起作用吗？</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="e19b" class="lb lc iq me b gy mi mj l mk ml">future_val_n(1000, 0.07, 20, 12)</span><span id="0b48" class="lb lc iq me b gy mm mj l mk ml">Outputs:<br/>4038.73</span><span id="dd61" class="lb lc iq me b gy mm mj l mk ml"># Now we check our value from future_val_n</span><span id="1b86" class="lb lc iq me b gy mm mj l mk ml">print(1000*(1+0.07/12)**(20*12))</span><span id="3f6d" class="lb lc iq me b gy mm mj l mk ml">Outputs:<br/>4038.73</span></pre><h2 id="9058" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">最后的话</h2><p id="0ea0" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">记住一些事情</p><ol class=""><li id="5506" class="nl nm iq kf b kg kh kk kl ko nn ks no kw np la nq nr ns nt bi translated">我们不一定要有一门纯函数式语言才能开始在我们的代码中使用函数式编程技术</li><li id="ed70" class="nl nm iq kf b kg nu kk nv ko nw ks nx kw ny la nq nr ns nt bi translated">Python 不是一种纯粹的函数式语言(当然)，但借鉴了它们的许多特性，比如作为第一类对象的函数和命名一对夫妇的列表理解。</li></ol><p id="ddb9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">考虑到这两点，我们意识到 python 对函数的递归调用次数有限制。此限制定义如下:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="01f9" class="lb lc iq me b gy mi mj l mk ml">sys.getrecursionlimit()</span><span id="c179" class="lb lc iq me b gy mm mj l mk ml">Outputs:<br/>3000</span></pre><p id="4468" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们在 n&gt;3000 的情况下运行 sum_n 函数，它将抛出一个<strong class="kf ir"> RecursionError </strong>，即使该函数适用于小于限制的递归深度。这是在将这些类型的函数合并到 python 代码库时需要考虑的事情。</p><p id="28b5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">既然你已经知道了递归，你将开始用不同的方式看待事物，也许你的下一个项目会有一些创造性的解决方案。我希望这是对递归和函数式编程范例的有趣而有启发性的介绍！</p></div></div>    
</body>
</html>