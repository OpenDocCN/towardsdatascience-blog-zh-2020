<html>
<head>
<title>Data Science Tip #005: Two Correct Ways to Perform One-Hot Encoding!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据科学技巧#005:执行 One-Hot 编码的两种正确方法！</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/data-science-tip-005-two-correct-ways-to-perform-one-hot-encoding-7c21e1db7aa2?source=collection_archive---------27-----------------------#2020-09-07">https://towardsdatascience.com/data-science-tip-005-two-correct-ways-to-perform-one-hot-encoding-7c21e1db7aa2?source=collection_archive---------27-----------------------#2020-09-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/60d9deb55323435d0de12a9b0e20b207.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*viT2PRY3v6wK7gAlxzwX8A.png"/></div></div></figure><div class=""/><div class=""><h2 id="51c6" class="pw-subtitle-paragraph kb jd je bd b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dk translated">教你两种不同的正确方法来执行一键编码(和一种“错误”的方法)</h2></div><p id="0c01" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">大家好，大家好！我希望你们都享受一个愉快的劳动节周末。我个人也在周五休假，将周末延长到四天，在过去的几天里，我和女儿们度过了许多美好的时光。但是你知道我，我总是渴望保持一定的生产能力！</p><p id="07ee" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在我们开始这篇文章之前，请务必参考<a class="ae lp" href="https://github.com/dkhundley/ds-quick-tips/tree/master/005_two_ways_to_ohe" rel="noopener ugc nofollow" target="_blank">我的个人 GitHub </a>中我们将在下面讨论的所有代码。这很简单，但是如果你想在一个简洁的 Jupyter 笔记本中学习，那么我鼓励你去看看。为了简洁起见，我不打算在这篇文章中讨论什么是热门编码，而是鼓励你<a class="ae lp" href="https://medium.com/@dkhundley/data-science-quick-tips-001-reversing-one-hot-encoding-b0c9a892356b" rel="noopener">查看我以前的一篇文章</a>，在那里我会更彻底地讨论这个问题。</p><p id="fe0c" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">好的，所以当我第一次学习一键编码时，我很好奇的被告知一种我认为是数据科学领域“错误”的做法。这并不是说它不能产生编码的特征，而是它对于应用机器学习来说还不够。感觉我在遇到的所有教程中一遍又一遍地看到这种特殊的方法。</p><p id="2ff9" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">那种不正确的方式？熊猫的“get_dummies”功能。</p><p id="c958" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">为了演示为什么不使用 Pandas 的“get_dummies”以及为什么使用我将推荐的其他选项，让我们首先通过导入必要的 Python 库来快速设置我们的项目，并使用假动物数据创建一个微小的数据帧。(我将在下面解释我们正在导入的内容，以及如果您以前没有安装第二个选项，如何安装它。)</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="50ee" class="lz ma je lv b gy mb mc l md me"># Importing the required libraries<br/>import pandas as pd<br/>import joblib<br/>from sklearn import preprocessing<br/>from category_encoders import one_hot</span><span id="1b49" class="lz ma je lv b gy mf mc l md me"># Creating a small DataFrame with fake animal data<br/>animals_df = pd.DataFrame({'animal': ['cat', 'dog', 'bird', 'monkey', 'elephant', 'cat', 'bird']})</span></pre><figure class="lq lr ls lt gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mg"><img src="../Images/debd823431e271b3ed4a805841bc44e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3rIRZ0Km0UJ2TbPhquHafg.png"/></div></div></figure><p id="ebb6" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">如您所见，我故意复制了几个值来证明我们的编码可以工作。有了我们的数据框架，让我们继续，看看当我们使用<a class="ae lp" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.get_dummies.html" rel="noopener ugc nofollow" target="_blank">基本的熊猫“get_dummies”函数</a>时会发生什么。</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="3819" class="lz ma je lv b gy mb mc l md me"># Performing one-hot encoding with Pandas' "get_dummies" function<br/>pandas_dummies = pd.get_dummies(animals_df['animal'])</span></pre><figure class="lq lr ls lt gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mh"><img src="../Images/614f63542f5a6079023227d01ebf1bdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ol8q-Xo_4OrxUwlIYRdD4g.png"/></div></div></figure><p id="518a" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">你可能会想，问题出在哪里？这不是对我们有用吗？虽然它在这个非常特殊的实例中确实有效，但是这个方法<em class="mi">不</em>允许推理管道中的未来转换。J <strong class="kv jf">就像我们为推理转换导出模型或数据缩放器一样，有<em class="mi">的</em>方法来导出一些东西以执行一致的一键编码</strong>。不幸的是，熊猫的“get_dummies”不允许这样做。(为什么这一点没有在更多的数据科学课程中讲授得更好，这让我感到困惑！)</p><p id="1bfc" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">幸运的是，有一些方法可以解决这个问题，我将向您展示其中的两个方法！</p><p id="3c7d" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">第一个正确的方法内置在 Scikit-Learn 中。就像任何 ML 算法一样，有一个名为 OneHotEncoder 的 Scikit-Learn 库，它允许您将数据与实例化的编码器对象相匹配，然后根据需要转换类似的数据以适当填充所有列。</p><p id="e5fa" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">但是事情是这样的…我对 Scikit-Learn 的实现并不狂热。它可以工作，技术上也是正确的，但是它有一点点…不完整？自己看看下面的代码。</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="805a" class="lz ma je lv b gy mb mc l md me"># Instantiating the Scikit-Learn OHE object<br/>sklearn_ohe = preprocessing.OneHotEncoder()</span><span id="eb6a" class="lz ma je lv b gy mf mc l md me"># Fitting the animals DataFrame to the Scikit-Learn one-hot encoder<br/>sklearn_dummies = sklearn_ohe.fit_transform(animals_df)</span><span id="168a" class="lz ma je lv b gy mf mc l md me"># Using the output dummies and transformer categories to produce a cleaner looking dataframe<br/>sklearn_dummies_df = pd.DataFrame(data = sklearn_dummies.toarray(), <br/>                                  columns = sklearn_ohe.categories_)</span><span id="2e7e" class="lz ma je lv b gy mf mc l md me"># Dumping the transformer to an external pickle file<br/>joblib.dump(sklearn_ohe, 'sklearn_ohe.pkl')</span></pre><figure class="lq lr ls lt gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mj"><img src="../Images/c6a04be4c68551fefb1e4d370b0414f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3L-Vg_S4fS7URwJpYyLX8g.png"/></div></div></figure><p id="cf40" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">正如您在 Jupyter 截图中看到的，转换后的数据帧的直接输出不是数据帧。它实际上是一个浮点值的稀疏矩阵。使用该输出确实可以生成一个数据帧，但是需要做一些额外的工作。不是不可能，但也不直观。我第一次了解这一点时，花了几个小时来思考这个输出。此外，它在结果中生成浮点值，而不是原始数据集中的整数值，这并不是预期的行为。但是这是可以改变的，所以我们仍然可以称它为正确的方法。</p><p id="111e" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">执行一键编码的第二个正确方法是使用<a class="ae lp" href="https://contrib.scikit-learn.org/category_encoders/index.html" rel="noopener ugc nofollow" target="_blank">一个叫做<strong class="kv jf">类别编码器</strong> </a>的特殊 Python 库。如果你以前没有用过，你所要做的就是快速安装 pip 或 conda。为了方便起见，我将相应的 shell 命令粘贴在下面。</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="ea37" class="lz ma je lv b gy mb mc l md me">pip install category_encoders</span><span id="0705" class="lz ma je lv b gy mf mc l md me">conda install -c conda-forge category_encoders</span></pre><p id="e290" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我实际上是在日常工作中被一些数据科学家同事介绍到这个库的，我个人更喜欢它，而不是 Scikit-Learn 的实现。我认为在下面的代码中原因很明显。<a class="ae lp" href="https://contrib.scikit-learn.org/category_encoders/onehot.html" rel="noopener ugc nofollow" target="_blank">这是关于 OneHotEncoder 的 Category Encoder 版本的具体文档</a>。</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="82ff" class="lz ma je lv b gy mb mc l md me"># Instantiating the Category Encoders OHE object<br/>ce_ohe = one_hot.OneHotEncoder(use_cat_names = True)</span><span id="30a3" class="lz ma je lv b gy mf mc l md me"># Fitting the animals DataFrame to the Category Encoders one-hot encoder<br/>ce_dummies = ce_ohe.fit_transform(animals_df)</span><span id="a444" class="lz ma je lv b gy mf mc l md me"># Dumping the transformer to an external pickle file<br/>joblib.dump(ce_ohe, 'ce_ohe.pkl')</span></pre><figure class="lq lr ls lt gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mk"><img src="../Images/47241a08716c63fbba2173765fadfabd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*22DUXum6DskuNzrzFMOO3A.png"/></div></div></figure><p id="efd9" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">如您所见，将数据拟合到转换器的输出产生了一个漂亮、干净的数据帧。此外，它将原始的“animal”列名附加上该列中的值，以生成干净的列名。现在，我实际上认为这是一个更好的实现，因为当您开始一键编码多个特性时，最好能在输出中知道它们最初来自哪个特性！</p><p id="627f" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">(如果有任何不好的地方，Scikit-Learn 的实现所转储的 pickle 文件要小得多，但是大小几乎可以忽略不计。我们在这里谈论的是字节对千字节，这几乎是什么，但我觉得我还是要与大家分享。)</p><p id="c847" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">为了证明这些变形金刚正在做我们希望它们做的事情，我从它们导出的 pickle 文件中重新导入了它们，并在一个新版本的动物数据帧上进行编码。它和原来的非常相似，但是我重新排列了值。</p><pre class="lq lr ls lt gt lu lv lw lx aw ly bi"><span id="4d19" class="lz ma je lv b gy mb mc l md me"># Creating a newly ordered animals dataframe<br/>new_animals_df = pd.DataFrame({'animal': ['cat', 'cat', 'dog', 'monkey', 'elephant', 'cat', 'bird', 'dog']})</span><span id="7539" class="lz ma je lv b gy mf mc l md me"># Importing the exported pickle files<br/>imported_sklearn_ohe = joblib.load('sklearn_ohe.pkl')<br/>imported_ce_ohe = joblib.load('ce_ohe.pkl')</span><span id="d6d0" class="lz ma je lv b gy mf mc l md me"># Running the new animals DataFrame through the Scikit-Learn imported transformer<br/>loaded_sklearn_dummies = imported_sklearn_ohe.transform(new_animals_df)<br/>loaded_sklearn_dummies_df = pd.DataFrame(data = loaded_sklearn_dummies.toarray(), <br/>                                         columns = imported_sklearn_ohe.categories_)</span><span id="643a" class="lz ma je lv b gy mf mc l md me"># Running the new animals DataFrame through the Category Encoders imported transformer<br/>loaded_ce_dummies = imported_ce_ohe.transform(new_animals_df)</span></pre><figure class="lq lr ls lt gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ml"><img src="../Images/2977c0c99e4538709b164b6e35336e4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*25pV0F3BNy4y227o1pcFsA.png"/></div></div></figure><figure class="lq lr ls lt gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mm"><img src="../Images/db721a05a4bcb8603565695f56ad1883.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZKigBTlRbvOngZdpjukS6A.png"/></div></div></figure><p id="4566" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">瞧，成功了！当我们对原始数据集执行转换时，每个输出的转换都具有我们第一次看到的相同特征。我没有在这篇文章中演示它，但它甚至有一些内置的特性，这些特性规定了当传递未知值或空值时会发生什么样的正确行为。整洁！</p><p id="7d60" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这就结束了另一篇文章！尽管 Pandas 的“get_dummies”功能很好，但你真的不应该将它用于应用 ML 目的。它在类似 API 的东西中导致了一个非常容错的、不完整的实现，无论如何，使用 Scikit-Learn 或 Category Encoder 的 one-hot 编码器都更容易使用。希望你们都喜欢这个帖子！请务必查看我过去的提示，并在未来的帖子中推荐任何您想看到的内容！在那之前，我要结束了，祝你劳动节周末快乐。</p></div></div>    
</body>
</html>