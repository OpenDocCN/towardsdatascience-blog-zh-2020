<html>
<head>
<title>Is the Point Inside the Polygon?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">点在多边形里面吗？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/is-the-point-inside-the-polygon-574b86472119?source=collection_archive---------7-----------------------#2020-09-10">https://towardsdatascience.com/is-the-point-inside-the-polygon-574b86472119?source=collection_archive---------7-----------------------#2020-09-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><blockquote class="jq jr js"><p id="fe36" class="jt ju jv jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr im bi translated">在计算几何中，<strong class="jw iu">多边形中的点</strong> ( <strong class="jw iu">点</strong>)问题询问平面中的给定点是位于多边形的内部、外部还是边界上维基百科。</p></blockquote><p id="cf05" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">一种快速简单的算法来确定一个点是位于多边形内部、之上还是之外，在各种应用中非常有用，如计算机图形学、地理信息系统(GIS)、运动规划、CAD、计算机视觉等。</p><p id="91be" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">作为一名计算机视觉工程师，我看到的一些直接应用是:</p><ol class=""><li id="547e" class="kv kw it jw b jx jy kb kc ks kx kt ky ku kz kr la lb lc ld bi translated"><strong class="jw iu">车道检测</strong>:由于车道可以用梯形来表示，因此<strong class="jw iu"> PIP </strong>可以用来判断像素是否位于梯形(车道)内。</li><li id="5542" class="kv kw it jw b jx le kb lf ks lg kt lh ku li kr la lb lc ld bi translated"><strong class="jw iu">使用边缘检测计算对象的面积:</strong>任何对象的面积都可以通过对其执行边缘检测来计算，然后通过检查像素是否位于对象边缘形成的多边形内来计算面积。</li></ol><p id="1b31" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">解决画中画问题的一些方法是通过使用<a class="ae lj" href="https://en.wikipedia.org/wiki/Point_in_polygon#cite_note-5" rel="noopener ugc nofollow" target="_blank"> <strong class="jw iu">光线投射算法</strong> </a>和<a class="ae lj" href="https://en.wikipedia.org/wiki/Point_in_polygon#cite_note-5" rel="noopener ugc nofollow" target="_blank"> <strong class="jw iu">缠绕数算法</strong> </a> <strong class="jw iu">。</strong>需要注意的一点是，对于真正靠近多边形的点，缠绕数算法比光线投射更精确。此外，在较新的实现中，它也比光线投射算法更快。对于凸多边形，PIP 问题被进一步简化，我们将讨论一种这样的方法来解决它。</p><blockquote class="lk"><p id="b15b" class="ll lm it bd ln lo lp lq lr ls lt kr dk translated"><strong class="ak"> <em class="lu">在这篇文章中我将解释解决任意多边形画中画的缠绕数算法。然后，我将介绍一种解决凸多边形 PIP 的简化方法。这两种方法的 C++代码都可以在这里找到</em></strong><a class="ae lj" href="https://github.com/anirudhtopiwala/OpenSource_Problems/tree/master/point_in_polygon" rel="noopener ugc nofollow" target="_blank"><strong class="ak"><em class="lu"/></strong></a><strong class="ak"><em class="lu">。</em> </strong></p></blockquote><h1 id="adc7" class="lv lw it bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated"><strong class="ak">绕组数量算法</strong></h1><p id="c49a" class="pw-post-body-paragraph jt ju it jw b jx mt jz ka kb mu kd ke ks mv kh ki kt mw kl km ku mx kp kq kr im bi translated">缠绕次数由曲线围绕一个点逆时针旋转的次数来定义。</p><figure class="mz na nb nc gt nd gh gi paragraph-image"><div class="gh gi my"><img src="../Images/4f6842b5d9d16ea1a06beed1801f80a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:568/format:webp/1*xr7LqK0Ie3iQhwhJGaS70g.png"/></div><p class="ng nh gj gh gi ni nj bd b be z dk translated">点 p 的绕组数是 2。(来源:维基百科)</p></figure><blockquote class="jq jr js"><p id="ee18" class="jt ju jv jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr im bi translated"><strong class="jw iu">该算法规定，对于多边形内的任何一点，缠绕数都不为零。因此它也被称为非零规则算法。</strong></p></blockquote><figure class="mz na nb nc gt nd gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/69ebd31cefdbda9a62b670dc74e2c327.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*SRq6LB3wV-oHd49ygi5MOA.png"/></div><p class="ng nh gj gh gi ni nj bd b be z dk translated">来源:作者</p></figure><p id="b958" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">计算缠绕数的一种方法是计算多边形的每条边与查询点所成的角度。这分别由 AB 边、BC 边、CD 边和 DA 边的角度θ1、θ2、θ3 和θ4 表示。如果这些角度的总和为 2 <strong class="jw iu"> π </strong>，则该点位于多边形内部，如果总和为 0，则该点位于多边形外部。</p><pre class="mz na nb nc gt nl nm nn no aw np bi"><span id="57fb" class="nq lw it nm b gy nr ns l nt nu">sum_of_angles = θ1 + θ2 + θ3 + θ4 = 2 π <strong class="nm iu">-&gt; Point is inside<br/></strong>sum_of_angles = θ1 + θ2 + θ3 + θ4 = 0<strong class="nm iu"> -&gt; Point is outside.</strong></span></pre><p id="6b1e" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">类似于光线投射算法，该算法的时间复杂度将是 O(n ),但是它将涉及反三角函数(如 atan2)的重复计算，以获得多边形的边与查询点所对的角度。</p><p id="9dcc" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">如<a class="ae lj" href="https://wrf.ecse.rpi.edu//Research/Short_Notes/pnpoly.html" rel="noopener ugc nofollow" target="_blank"> W. Randolph Franklin </a>所述，降低复杂性的一种方法是简单地观察实际上围绕查询点的边，而所有其他边可以忽略。</p><blockquote class="jq jr js"><p id="1ed8" class="jt ju jv jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr im bi translated"><strong class="jw iu">算法:</strong>对于任意多边形，求该多边形所有与通过查询点的直线相交且平行于 y _ 轴的边。对于这些边，检查当逆时针方向看所有边时，查询点是在边的左侧还是右侧。如果查询点位于向上交叉路口的左侧，则绕组数(wn)值增加 1，如果查询点位于向下交叉路口的右侧，则 wn 值减少 1。如果最终缠绕数不为零，则该点位于多边形内部。</p></blockquote><pre class="mz na nb nc gt nl nm nn no aw np bi"><span id="a40f" class="nq lw it nm b gy nr ns l nt nu"><strong class="nm iu">Example:<br/>For part a) in the figure below:</strong><br/>Initially wn = 0<br/>Only edges CD and AB cut the line passing through P1 and parallel to y axis.<br/>1) wn++ for CD as it is an upward crossing for which P1 is left of CD<br/>2) wn wont be changed as P1 is on left of AB (downward crossing).<br/><strong class="nm iu">As final winding number wn = 1 which is not equal to zero point P1 lies inside the polygon.</strong></span><span id="3f60" class="nq lw it nm b gy nv ns l nt nu"><strong class="nm iu">A similar case can be made for b) part of the figure.</strong> Although it should be noted that we are avoiding the added complexity of the polygon and hence make the algorithm more efficient.</span><span id="6efe" class="nq lw it nm b gy nv ns l nt nu"><strong class="nm iu">For c) part in the figure below:</strong><br/>Initially wn = 0<br/>Only edges DE and BC cut the line passing through P1 and parallel to y axis.<br/>1) wn++ for DE as it is upward crossing for which P1 is left of CD<br/>2) wn-- for BC as it is downward crossing for which P1 is right of BC<br/><strong class="nm iu">As final winding number wn = 0 point P1 lies outside the polygon.</strong></span></pre><figure class="mz na nb nc gt nd gh gi paragraph-image"><div role="button" tabindex="0" class="nx ny di nz bf oa"><div class="gh gi nw"><img src="../Images/5bea99cd218f37e3421626f5da53a09d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DpniaSbB6xx9aDmrVc8LIQ.png"/></div></div><p class="ng nh gj gh gi ni nj bd b be z dk translated"><strong class="bd ob"> a) </strong> wn = 1，因为 P1 在上边缘 CD <strong class="bd ob"> b) </strong> wn = 1 的左边，因为 P1 在上边缘 FG <strong class="bd ob"> c) </strong> wn = 0 的左边，因为 P1 在上边缘 DE 的左边但在下边缘 BC 的右边。<strong class="bd ob">注意:对于 a)和 b ),点 p1 在多边形内，如 wn！= 0，不考虑 b)中多边形的附加复杂性。(</strong>来源:作者)</p></figure><p id="b869" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated"><a class="ae lj" href="https://github.com/anirudhtopiwala/OpenSource_Problems/tree/master/point_in_polygon" rel="noopener ugc nofollow" target="_blank"> <strong class="jw iu"> Cpp 代码:(GitHub 句柄)</strong> </a></p><ol class=""><li id="5e97" class="kv kw it jw b jx jy kb kc ks kx kt ky ku kz kr la lb lc ld bi translated"><strong class="jw iu"><em class="jv">substitute _ point _ in _ line():</em></strong>该函数计算点位于直线的哪一侧。</li><li id="ea5b" class="kv kw it jw b jx le kb lf ks lg kt lh ku li kr la lb lc ld bi translated"><strong class="jw iu">is _ point _ inside _ polygon<em class="jv">():</em></strong>这是完整的算法，计算一个点是否在内<strong class="jw iu">、在</strong>外<strong class="jw iu">或在</strong>上<strong class="jw iu">，给定逆时针方向的多边形顶点。通过按逆时针方向列出顶点来固定边的方向有助于锁定线段的左侧和右侧(多边形边)。</strong></li></ol><h1 id="4e3e" class="lv lw it bd lx ly lz ma mb mc md me mf mg oc mi mj mk od mm mn mo oe mq mr ms bi translated"><strong class="ak">多边形中的点为凸多边形</strong></h1><p id="2d99" class="pw-post-body-paragraph jt ju it jw b jx mt jz ka kb mu kd ke ks mv kh ki kt mw kl km ku mx kp kq kr im bi translated">凸多边形是指所有内角都小于 180°的多边形，这意味着所有顶点都指向远离多边形内部的方向。</p><p id="6743" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">我们单独讨论这一点，因为在计算机视觉中遇到的最常见的多边形类型是凸多边形。这些包括所有的三角形、正方形、平行四边形、梯形等。</p><blockquote class="jq jr js"><p id="a4e1" class="jt ju jv jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr im bi translated"><strong class="jw iu">算法:</strong>对于一个凸多边形，如果多边形的边可以认为是从任意一个顶点开始的路径。然后，如果查询点位于构成路径的所有线段的同一侧，则称该点位于多边形内部。这可以从下图中看出。</p></blockquote><figure class="mz na nb nc gt nd gh gi paragraph-image"><div class="gh gi of"><img src="../Images/0638ac072a582af3040003d9355b04fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/format:webp/1*NiIOW77RPO-PIQF3iFlycA.png"/></div><p class="ng nh gj gh gi ni nj bd b be z dk translated">点 P1 位于上面显示的两个多边形内，因为 P1 位于两个多边形所有边的同一侧。(来源:作者)</p></figure><p id="362b" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">要找出该点位于线段的哪一侧，我们可以简单地将该点代入线段方程。例如，对于由(x1，y1)和(x2，y2)形成的线，查询点(xp，yp)可以被替换如下:</p><pre class="mz na nb nc gt nl nm nn no aw np bi"><span id="bda5" class="nq lw it nm b gy nr ns l nt nu"><strong class="nm iu">result = (yp - y1) * (x2 -x1) - (xp - x1) * (y2 - y1)</strong></span></pre><p id="3470" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">当逆时针方向看线段时，如果结果是:</p><ol class=""><li id="103c" class="kv kw it jw b jx jy kb kc ks kx kt ky ku kz kr la lb lc ld bi translated">结果&gt; 0:查询点位于行的左侧。</li><li id="cfd7" class="kv kw it jw b jx le kb lf ks lg kt lh ku li kr la lb lc ld bi translated">结果= 0:查询点位于直线上。</li><li id="5597" class="kv kw it jw b jx le kb lf ks lg kt lh ku li kr la lb lc ld bi translated">结果&lt; 0: Query point lies on right of the line.</li></ol><p id="6f90" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated"><a class="ae lj" href="https://github.com/anirudhtopiwala/OpenSource_Problems/tree/master/point_in_polygon" rel="noopener ugc nofollow" target="_blank"> <strong class="jw iu"> Cpp 代码:(GitHub 句柄)</strong> </a></p><ol class=""><li id="7567" class="kv kw it jw b jx jy kb kc ks kx kt ky ku kz kr la lb lc ld bi translated"><strong class="jw iu"><em class="jv">substitute _ point _ in _ line():</em></strong>该函数计算点位于直线的哪一侧。</li><li id="f7ee" class="kv kw it jw b jx le kb lf ks lg kt lh ku li kr la lb lc ld bi translated"><strong class="jw iu"><em class="jv">is _ point _ inside _ convex _ polygon():</em></strong>这是完整的算法，计算给定顺时针或逆时针方向的多边形顶点，一个点是否在凸多边形的内<strong class="jw iu">、<strong class="jw iu">外</strong>或</strong>上<strong class="jw iu">。</strong></li></ol><p id="f887" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">如前所述，凸多边形中的点也包括以下情况</p><ol class=""><li id="7dd9" class="kv kw it jw b jx jy kb kc ks kx kt ky ku kz kr la lb lc ld bi translated">梯形中的点</li><li id="65e2" class="kv kw it jw b jx le kb lf ks lg kt lh ku li kr la lb lc ld bi translated">平行四边形中的点</li><li id="665a" class="kv kw it jw b jx le kb lf ks lg kt lh ku li kr la lb lc ld bi translated">矩形中的点</li></ol><blockquote class="lk"><p id="143c" class="ll lm it bd ln lo og oh oi oj ok kr dk translated">总而言之，我们讲述了如何找到一个多边形的缠绕数，并用它来确定这个点是在多边形的内部、上面还是外部。我们还看到了一个更简单的解决方案，可以应用于凸多边形来解决画中画。</p></blockquote><p id="0a76" class="pw-post-body-paragraph jt ju it jw b jx ol jz ka kb om kd ke ks on kh ki kt oo kl km ku op kp kq kr im bi translated">如果你有任何问题，请联系我，希望你喜欢这个数学。</p><h1 id="f6a9" class="lv lw it bd lx ly lz ma mb mc md me mf mg oc mi mj mk od mm mn mo oe mq mr ms bi translated">参考资料:</h1><ol class=""><li id="4372" class="kv kw it jw b jx mt kb mu ks oq kt or ku os kr la lb lc ld bi translated"><a class="ae lj" href="https://en.wikipedia.org/wiki/Point_in_polygon#cite_note-5" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Point_in_polygon#cite_note-5</a></li><li id="ccf1" class="kv kw it jw b jx le kb lf ks lg kt lh ku li kr la lb lc ld bi translated"><a class="ae lj" href="http://www.eecs.umich.edu/courses/eecs380/HANDOUTS/PROJ2/InsidePoly.html" rel="noopener ugc nofollow" target="_blank">http://www . eecs . umich . edu/courses/eecs 380/讲义/PROJ2/InsidePoly.html </a></li><li id="6a3c" class="kv kw it jw b jx le kb lf ks lg kt lh ku li kr la lb lc ld bi translated"><a class="ae lj" href="http://geomalgorithms.com/a03-_inclusion.html" rel="noopener ugc nofollow" target="_blank">http://geomalgorithms.com/a03-_inclusion.html</a></li><li id="1126" class="kv kw it jw b jx le kb lf ks lg kt lh ku li kr la lb lc ld bi translated">Wm。Randolph Franklin，<a class="ae lj" href="https://wrf.ecse.rpi.edu//Research/Short_Notes/pnpoly.html" rel="noopener ugc nofollow" target="_blank">“多边形测试中的点包含”</a></li></ol></div></div>    
</body>
</html>