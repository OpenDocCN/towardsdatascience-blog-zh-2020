<html>
<head>
<title>Testing your Python Project with GitHub Actions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 GitHub 动作测试您的 Python 项目</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/testing-your-python-project-with-github-actions-ec9bf82b20dc?source=collection_archive---------56-----------------------#2020-04-13">https://towardsdatascience.com/testing-your-python-project-with-github-actions-ec9bf82b20dc?source=collection_archive---------56-----------------------#2020-04-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="c6c8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">几天前，我第一次在我的一个项目中使用 GitHub Actions。总的来说，结果是非常积极的，但也有一些工作要做。希望这篇文章能帮助你以更低的成本做到这一点！</p><h1 id="6335" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">激活 GitHub 动作</h1><p id="0298" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">在项目的根目录下创建一个<code class="fe lr ls lt lu b">.github/workflows</code>目录:</p><pre class="lv lw lx ly gt lz lu ma mb aw mc bi"><span id="63b4" class="md kp it lu b gy me mf l mg mh">mkdir -p .github/workflows</span></pre><p id="606f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在该目录中，用您选择名称创建一个或多个 YAML 文件。</p><p id="8a44" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我的例子中，我创建了两个文件:</p><ul class=""><li id="ef02" class="mi mj it js b jt ju jx jy kb mk kf ml kj mm kn mn mo mp mq bi translated"><code class="fe lr ls lt lu b"><a class="ae mr" href="https://github.com/mwouts/jupytext/blob/master/.github/workflows/continuous-integration-pip.yml" rel="noopener ugc nofollow" target="_blank">continuous-integration-pip.yml</a></code>，以及</li><li id="ed78" class="mi mj it js b jt ms jx mt kb mu kf mv kj mw kn mn mo mp mq bi translated"><code class="fe lr ls lt lu b"><a class="ae mr" href="https://github.com/mwouts/jupytext/blob/master/.github/workflows/continuous-integration-conda.yml" rel="noopener ugc nofollow" target="_blank">continuous-integration-conda.yml</a></code>。</li></ul><h1 id="4de4" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">命名您的行动</h1><p id="f4d9" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">在 YAML 文件的顶部，我们有这个字段:<code class="fe lr ls lt lu b">name: CI (pip)</code>。虽然 YAML 文件的名称似乎没有任何影响，但文件顶部的<code class="fe lr ls lt lu b">name</code>字段是出现在您的<a class="ae mr" href="https://github.com/mwouts/jupytext/actions" rel="noopener ugc nofollow" target="_blank">操作选项卡</a>中的字段，也是您将在工卡上看到的名称:</p><figure class="lv lw lx ly gt my gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi mx"><img src="../Images/4e39c2d4d1331f75cad6438b353194f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*A8p3z-x2dWQSPJxn.png"/></div></div></figure><p id="816d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用<code class="fe lr ls lt lu b">on</code>字段，您可以选择哪些事件应该触发一个动作。我最初尝试了<code class="fe lr ls lt lu b">on: [push, pull_request]</code>，但是我很快就感觉触发了太多的构建。现在我使用<code class="fe lr ls lt lu b">on: [push]</code>，这似乎就足够了。这样，当贡献者的一个提交破坏了配置项时，他们会收到一封电子邮件，因此他们可以在打开拉请求之前修复问题。使用<code class="fe lr ls lt lu b">on: [push]</code>,您已经在 pull 请求中获得了状态更新:</p><figure class="lv lw lx ly gt my gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi nf"><img src="../Images/56d0295c15b932bbb9f1c6390f00f0e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/0*0WkL6Y6gUPmUSDtW.png"/></div></div></figure><p id="1812" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">几分钟后:</p><figure class="lv lw lx ly gt my gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/38f255844fcc04b0dc936852d6f1f6e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1338/format:webp/0*rZA3kY1JPz3Jk5Go.png"/></div></figure><h1 id="2a20" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">测试 Python 的多个变体</h1><p id="f88f" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">Python 代码是可移植的，但实际上，我更喜欢在各种平台上测试我的代码。</p><p id="96ca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我的项目中，我想测试</p><ul class=""><li id="a4cf" class="mi mj it js b jt ju jx jy kb mk kf ml kj mm kn mn mo mp mq bi translated">Python 环境使用<code class="fe lr ls lt lu b">pip</code>和<code class="fe lr ls lt lu b">conda</code>构建</li><li id="a80a" class="mi mj it js b jt ms jx mt kb mu kf mv kj mw kn mn mo mp mq bi translated">Python 版本 2.7、3.5、3.6、3.7 和 3.8</li><li id="f93e" class="mi mj it js b jt ms jx mt kb mu kf mv kj mw kn mn mo mp mq bi translated">Linux、Mac OS 或 Windows 上的 Python。</li></ul><p id="b415" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意，我不需要测试完整的矩阵(30 个作业)。如果我在所有可能的操作系统(11 个作业)上测试了 pip 和 Linux 的所有 Python 版本，以及 conda 的 Python 2.7 和 3.7，那么我已经可以确信我的程序将在几乎所有地方工作。</p><p id="739c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">先说<code class="fe lr ls lt lu b">pip</code>，超级容易设置。这里是我的<code class="fe lr ls lt lu b"><a class="ae mr" href="https://github.com/mwouts/jupytext/blob/master/.github/workflows/continuous-integration-pip.yml" rel="noopener ugc nofollow" target="_blank">continuous-integration-pip.yml</a></code>文件的摘录，显示:</p><ul class=""><li id="4644" class="mi mj it js b jt ju jx jy kb mk kf ml kj mm kn mn mo mp mq bi translated">如何使用<code class="fe lr ls lt lu b">actions/checkout@v2</code>查看 GitHub 库</li><li id="2306" class="mi mj it js b jt ms jx mt kb mu kf mv kj mw kn mn mo mp mq bi translated">如何在<code class="fe lr ls lt lu b">python-version: ${{ matrix.python-version }}</code>参数化的版本中用<code class="fe lr ls lt lu b">actions/setup-python@v1</code>安装 Python</li><li id="1367" class="mi mj it js b jt ms jx mt kb mu kf mv kj mw kn mn mo mp mq bi translated">如何从项目的<code class="fe lr ls lt lu b">requirements.txt</code>和<code class="fe lr ls lt lu b">requirements-dev.txt</code>文件安装包</li><li id="3d68" class="mi mj it js b jt ms jx mt kb mu kf mv kj mw kn mn mo mp mq bi translated">如何安装可选依赖项</li></ul><pre class="lv lw lx ly gt lz lu ma mb aw mc bi"><span id="6f64" class="md kp it lu b gy me mf l mg mh">name: CI (pip)<br/>on: [push]<br/><br/>jobs:<br/>  build:<br/>    strategy:<br/>      matrix:<br/>        python-version: [2.7, 3.5, 3.6, 3.7, 3.8]<br/>    runs-on: ubuntu-latest<br/>    steps:<br/>      - name: Checkout<br/>        uses: actions/checkout@v2<br/>      - name: Set up Python ${{ matrix.python-version }}<br/>        uses: actions/setup-python@v1<br/>        with:<br/>          python-version: ${{ matrix.python-version }}<br/>      - name: Install dependencies<br/>        run: |<br/>          python -m pip install --upgrade pip<br/>          pip install -r requirements.txt<br/>          pip install -r requirements-dev.txt<br/>          # install black if available (Python 3.6 and above)<br/>          pip install black || true</span></pre><p id="748b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们前往<code class="fe lr ls lt lu b">conda</code>。我的<code class="fe lr ls lt lu b"><a class="ae mr" href="https://github.com/mwouts/jupytext/blob/master/.github/workflows/continuous-integration-conda.yml" rel="noopener ugc nofollow" target="_blank">continuous-integration-conda.yml</a></code>文件摘录显示:</p><ul class=""><li id="6d4d" class="mi mj it js b jt ju jx jy kb mk kf ml kj mm kn mn mo mp mq bi translated">如何用<code class="fe lr ls lt lu b">actions/checkout@v2</code>检查你的 GitHub 库</li><li id="873e" class="mi mj it js b jt ms jx mt kb mu kf mv kj mw kn mn mo mp mq bi translated">如何在 Ubuntu (Linux)、Mac OS、Windows 中选择操作系统</li><li id="c59b" class="mi mj it js b jt ms jx mt kb mu kf mv kj mw kn mn mo mp mq bi translated">如何用<code class="fe lr ls lt lu b">goanpeca/setup-miniconda@v1</code>安装 Miniconda，用<code class="fe lr ls lt lu b">python-version: ${{ matrix.python-version }}</code>参数化的 Python 版本</li><li id="675b" class="mi mj it js b jt ms jx mt kb mu kf mv kj mw kn mn mo mp mq bi translated">如何从<code class="fe lr ls lt lu b"><a class="ae mr" href="https://github.com/mwouts/jupytext/blob/master/environment.yml" rel="noopener ugc nofollow" target="_blank">environment.yml</a></code> <a class="ae mr" href="https://github.com/mwouts/jupytext/blob/master/environment.yml" rel="noopener ugc nofollow" target="_blank">文件</a>创建 conda 环境</li><li id="6761" class="mi mj it js b jt ms jx mt kb mu kf mv kj mw kn mn mo mp mq bi translated">以及如何激活相应的环境</li></ul><pre class="lv lw lx ly gt lz lu ma mb aw mc bi"><span id="2f6e" class="md kp it lu b gy me mf l mg mh">name: CI (conda)<br/>on: [push]<br/><br/>jobs:<br/>  build:<br/>    strategy:<br/>      matrix:<br/>        os: ['ubuntu-latest', 'macos-latest', 'windows-latest']<br/>        python-version: [2.7, 3.7]<br/>    runs-on: ${{ matrix.os }}<br/>    steps:<br/>      - name: Checkout<br/>        uses: actions/checkout@v2<br/>      - name: Setup Miniconda<br/>        uses: goanpeca/setup-miniconda@v1<br/>        with:<br/>          auto-update-conda: true<br/>          auto-activate-base: false<br/>          miniconda-version: 'latest'<br/>          python-version: ${{ matrix.python-version }}<br/>          environment-file: environment.yml<br/>          activate-environment: jupytext-dev</span></pre><h1 id="ae2c" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">代码质量</h1><p id="1c56" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">在运行任何测试之前，确保所有代码都是有效的是一个好主意，我用<code class="fe lr ls lt lu b">flake8</code>做到了这一点。</p><p id="a779" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我的<code class="fe lr ls lt lu b"><a class="ae mr" href="https://github.com/mwouts/jupytext/blob/master/.github/workflows/continuous-integration-pip.yml" rel="noopener ugc nofollow" target="_blank">continuous-integration-pip.yml</a></code>文件中对应的步骤是</p><pre class="lv lw lx ly gt lz lu ma mb aw mc bi"><span id="076d" class="md kp it lu b gy me mf l mg mh">      - name: Lint with flake8<br/>        run: |<br/>          # stop the build if there are Python syntax errors or undefined names<br/>          flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics<br/>          # all Python files should follow PEP8 (except some notebooks, see setup.cfg)<br/>          flake8 jupytext tests<br/>          # exit-zero treats all errors as warnings.  The GitHub editor is 127 chars wide<br/>          flake8 . --count --exit-zero --max-complexity=10 --statistics</span></pre><p id="847e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<code class="fe lr ls lt lu b"><a class="ae mr" href="https://github.com/mwouts/jupytext/blob/master/.github/workflows/continuous-integration-conda.yml" rel="noopener ugc nofollow" target="_blank">continuous-integration-conda.yml</a></code>中，需要一个额外的<code class="fe lr ls lt lu b">shell</code>参数。我第一次尝试<code class="fe lr ls lt lu b">shell: pwsh</code> (PowerShell)，效果不错，所以我现在在用</p><pre class="lv lw lx ly gt lz lu ma mb aw mc bi"><span id="4bac" class="md kp it lu b gy me mf l mg mh">      - name: Lint with flake8<br/>        shell: pwsh<br/>        run: |<br/>          # stop the build if there are Python syntax errors or undefined names<br/>          flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics<br/>          # all Python files should follow PEP8 (except some notebooks, see setup.cfg)<br/>          flake8 jupytext tests<br/>          # exit-zero treats all errors as warnings.  The GitHub editor is 127 chars wide<br/>          flake8 . --count --exit-zero --max-complexity=10 --statistics</span></pre><h1 id="bf00" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">了解 CI 错误</h1><p id="174c" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">我最初对<code class="fe lr ls lt lu b">flake8</code>步骤有疑问。错误是:</p><pre class="lv lw lx ly gt lz lu ma mb aw mc bi"><span id="e20c" class="md kp it lu b gy me mf l mg mh">Lint with flake8<br/>4s<br/>##[error]Process completed with exit code 2.<br/>Run # stop the build if there are Python syntax errors or undefined names<br/>  # stop the build if there are Python syntax errors or undefined names<br/>  flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics<br/>  all Python files should follow PEP8 (except some notebooks, see setup.cfg)<br/>  flake8 jupytext tests<br/>  # exit-zero treats all errors as warnings.  The GitHub editor is 127 chars wide<br/>  flake8 . --count --exit-zero --max-complexity=10 --statistics<br/>  shell: /bin/bash -e {0}<br/>  env:<br/>    pythonLocation: /opt/hostedtoolcache/Python/3.6.10/x64<br/>0<br/>/home/runner/work/_temp/98d1db20-f0af-4eba-af95-cb39421c77b0.sh: line 3: syntax error near unexpected token `('<br/>##[error]Process completed with exit code 2.</span></pre><p id="798a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我的理解是，<code class="fe lr ls lt lu b">/home/runner/work/_temp/98d1db20-f0af-4eba-af95-cb39421c77b0.sh</code>是一个临时脚本，包含该步骤的命令。所以当我们被告知脚本抛出这个错误:<em class="nh">第 3 行:意外标记`(</em>)附近的语法错误时，我们应该看看那个步骤的<code class="fe lr ls lt lu b">run</code>属性的第三行。在我的命令中，那是<em class="nh">所有的 Python 文件都应该遵循 PEP8(除了一些笔记本，见 setup.cfg) </em>，而且确实是少了一个注释 char！</p><h1 id="ff13" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">运行 Pytest</h1><p id="e51c" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">一旦我们确信代码在语法上是正确的，我们就想知道是否所有的单元测试都通过了。相应的步骤是:</p><pre class="lv lw lx ly gt lz lu ma mb aw mc bi"><span id="100a" class="md kp it lu b gy me mf l mg mh">      - name: Test with pytest<br/>        run: coverage run --source=. -m py.test</span></pre><p id="3603" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意，我使用<code class="fe lr ls lt lu b">coverage run --source=. -m py.test</code>而不仅仅是<code class="fe lr ls lt lu b">pytest</code>，因为我也想知道代码覆盖率。还有，对于 conda 文件，我们需要添加一个<code class="fe lr ls lt lu b">shell: pwsh</code>属性，否则找不到<code class="fe lr ls lt lu b">coverage</code>或者<code class="fe lr ls lt lu b">pytest</code>命令。</p><h1 id="8fa7" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">上传覆盖范围</h1><p id="e028" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">在配置项中计算覆盖率是很好的，但是在拉请求中更新覆盖率，并在自述文件中显示覆盖率标记就更好了。为此，我使用<a class="ae mr" href="https://codecov.io/" rel="noopener ugc nofollow" target="_blank"> codecov </a>。我更喜欢只上传 conda CI 的覆盖率，因为它让我可以测试更多的可选功能。覆盖率上传步骤是<code class="fe lr ls lt lu b"><a class="ae mr" href="https://github.com/mwouts/jupytext/blob/master/.github/workflows/continuous-integration-conda.yml" rel="noopener ugc nofollow" target="_blank">continuous-integration-conda.yml</a></code>中的最后一步:</p><pre class="lv lw lx ly gt lz lu ma mb aw mc bi"><span id="d946" class="md kp it lu b gy me mf l mg mh">      - name: Upload coverage<br/>        shell: pwsh<br/>        run: coverage report -m</span></pre><p id="ad2a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有了这个，我就有了保险徽章</p><p id="3ba1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我可以添加到我的<a class="ae mr" href="https://github.com/mwouts/jupytext/blob/master/README.md" rel="noopener ugc nofollow" target="_blank">自述文件</a>中，详细的覆盖率统计数据和图表在<a class="ae mr" href="https://codecov.io/gh/mwouts/jupytext/branch/master" rel="noopener ugc nofollow" target="_blank"> codecov.io </a>中，以及拉请求中的覆盖率报告:</p><figure class="lv lw lx ly gt my gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/973bbffe90ddd4fe1566d1fed1fbe072.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/0*41UrmL_8S3GD92TC.png"/></div></figure><h1 id="1f92" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">自动化作业取消</h1><p id="9530" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">一开始让我感到惊讶，但很有意义的一个特性是自动作业取消。当 CI 中的一个作业失败时，所有其他仍在运行或挂起的作业都会被取消。</p><p id="6902" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面是我的项目中的一个例子——Windows 版本出现了一个问题，导致剩余的 Windows 和 Mac OS 作业被取消:</p><figure class="lv lw lx ly gt my gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi nj"><img src="../Images/02f295f3cb16e42f98b43fd2ff0e33bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qqII7ND5VPU7iB2V.png"/></div></div></figure><h1 id="1655" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">与 Travis-CI 的差异</h1><p id="d874" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">在发现 GitHub 动作之前，我使用的是<a class="ae mr" href="https://travis-ci.com" rel="noopener ugc nofollow" target="_blank"> Travis-CI </a>。我喜欢它！我在许多项目中使用过 Travis-CI，包括这个<a class="ae mr" href="https://github.com/CFMTech/jupytext_papermill_post" rel="noopener ugc nofollow" target="_blank">奇特的项目</a>，在那里我们<a class="ae mr" href="https://github.com/CFMTech/jupytext_papermill_post/blob/master/.travis.yml" rel="noopener ugc nofollow" target="_blank">测试…自述文件本身</a>！</p><p id="d227" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我将以两者之间的简单比较来结束我的发言。</p><ul class=""><li id="2dc8" class="mi mj it js b jt ju jx jy kb mk kf ml kj mm kn mn mo mp mq bi translated">特拉维斯. CI 在那里的时间要长得多。我可能担心 GitHub 操作的文档会更难找到，但事实并非如此。有用的参考有:<a class="ae mr" href="https://help.github.com/en/actions/language-and-framework-guides/using-python-with-github-actions" rel="noopener ugc nofollow" target="_blank">使用 Python 和 GitHub 动作</a>和<a class="ae mr" href="https://github.com/marketplace/actions/setup-miniconda" rel="noopener ugc nofollow" target="_blank">设置 Miniconda </a>。</li><li id="aacb" class="mi mj it js b jt ms jx mt kb mu kf mv kj mw kn mn mo mp mq bi translated">就像 Travis-CI 一样，Github Actions 可以免费用于公共项目。</li><li id="6602" class="mi mj it js b jt ms jx mt kb mu kf mv kj mw kn mn mo mp mq bi translated">GitHub 集成对于 Travis-CI 和 GitHub 操作来说都非常出色，尽管这些操作在项目页面上有一个专用的选项卡，这使得访问 CI 更加容易。</li><li id="f364" class="mi mj it js b jt ms jx mt kb mu kf mv kj mw kn mn mo mp mq bi translated">用 Github 动作配置 conda 比用 Travis-CI 更简单，为此我使用了<a class="ae mr" href="https://github.com/mwouts/jupytext/blob/509e09ab6e0b72afe56f2cf4cbe0526e3ab981c4/.travis.yml#L17-L36" rel="noopener ugc nofollow" target="_blank">这个 hack </a>。</li><li id="15f7" class="mi mj it js b jt ms jx mt kb mu kf mv kj mw kn mn mo mp mq bi translated">我发现这个矩阵(比如 Python 版本乘以 OS，比如这里的<a class="ae mr" href="https://github.com/mwouts/jupytext/blob/master/.github/workflows/continuous-integration-conda.yml" rel="noopener ugc nofollow" target="_blank"/>)在 Github 动作上使用起来更简单。</li><li id="e175" class="mi mj it js b jt ms jx mt kb mu kf mv kj mw kn mn mo mp mq bi translated">我没有注意到工作持续时间的显著差异。在我的示例 PR 中，Travis-CI 上的六个作业(pip 和 conda，仅 Linux)在<a class="ae mr" href="https://travis-ci.com/github/mwouts/jupytext/builds/160045470" rel="noopener ugc nofollow" target="_blank"> 8m 33s </a>中运行，而在 GitHub Actions 上，第一系列的五个 pip 作业(仅 Linux)在<a class="ae mr" href="https://github.com/mwouts/jupytext/actions/runs/77140156" rel="noopener ugc nofollow" target="_blank"> 4m 57s </a>中运行，而其他系列的六个 conda 作业(Linux、Mac OS、Windows)在<a class="ae mr" href="https://github.com/mwouts/jupytext/actions/runs/77140151" rel="noopener ugc nofollow" target="_blank"> 12m 48s </a>中并行运行——因此，在该示例中，GitHub Actions 花费了 50%的时间，但也覆盖了更多的数量</li></ul><p id="ee1a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">感谢你阅读这篇文章！如果你想了解更多，可以看看我在<a class="ae mr" href="https://medium.com/@marc.wouts" rel="noopener"> Medium </a>上的其他帖子，在<a class="ae mr" href="https://github.com/mwouts/" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上我的开源项目，或者在<a class="ae mr" href="https://twitter.com/marcwouts" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我。此外，如果您有在其他环境中使用 GitHub 操作的经验，例如，如果您知道如何在线发布文档，请在此处发表评论让我们知道，或者随时就此<a class="ae mr" href="https://github.com/mwouts/github_actions_python" rel="noopener ugc nofollow" target="_blank">回购</a>提出问题或请求！</p></div></div>    
</body>
</html>