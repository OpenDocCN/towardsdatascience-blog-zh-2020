<html>
<head>
<title>7 Pandas Functions That Will Reduce Your Data Manipulation Stress</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">7 个熊猫功能将减轻您的数据操作压力</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/7-pandas-functions-to-reduce-your-data-manipulation-stress-25981e44cc7d?source=collection_archive---------9-----------------------#2020-04-11">https://towardsdatascience.com/7-pandas-functions-to-reduce-your-data-manipulation-stress-25981e44cc7d?source=collection_archive---------9-----------------------#2020-04-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/8f3667740a073a1e38a6d2df911e7497.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oHKJGjEy3dauaiz4cCDeuQ.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">左图和来自 Pixabay 的代码图。来自 Unsplash 的熊猫图像。</p></figure><div class=""/><div class=""><h2 id="99ab" class="pw-subtitle-paragraph kf jh ji bd b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dk translated">熊猫没有白毛是有原因的</h2></div><p id="d7d0" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">熊猫为什么没有灰毛？显然，因为它们有如此多的智能功能来操纵数据，所以它们不会像人类那样过度紧张。</p><p id="6b70" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">数据似乎永远不会以我们希望的形式出现。以我个人的经验，花在数据科学项目上的绝大部分时间只是花在操纵数据上。当我们想对数据做些什么，但我们不知道一个方便的熊猫函数来做时，是时候使用旧的<code class="fe lt lu lv lw b">for</code>循环和<code class="fe lt lu lv lw b">.loc</code>手动改变单元格了，由<code class="fe lt lu lv lw b">if</code>语句指导。</p><p id="afe1" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">在本文中，我将展示和解释 7 个 pandas 函数，当它们单独使用或一起使用时，有望为您节省大量数据操作压力。</p><p id="692d" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">为了演示，我们将主要对纽约市 Airbnb 开放数据进行操作，该数据混合了数据类型，包括数字、文本和日期。</p><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ly"><img src="../Images/309918393845508779e9a0c19b911f02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8SZDZ8DeYKn7MfHF2qpXbA.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">数据的前几列。</p></figure></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="1cb1" class="mk ml ji bd mm mn mo mp mq mr ms mt mu ko mv kp mw kr mx ks my ku mz kv na nb bi translated">1 | pandas.factorize(x)</h1><p id="2f85" class="pw-post-body-paragraph kx ky ji kz b la nc kj lc ld nd km lf lg ne li lj lk nf lm ln lo ng lq lr ls im bi translated">当我们需要对一些东西进行标签编码时，通常你会使用<code class="fe lt lu lv lw b">sci-kit learn</code>的<code class="fe lt lu lv lw b">LabelEncoder</code>，但是熊猫可以在没有任何进口的情况下这样做。最重要的是，访问什么标签对应什么需要从<code class="fe lt lu lv lw b">sklearn</code>中的<code class="fe lt lu lv lw b">LabelEncoder</code>对象调用函数，但是默认情况下包含在<code class="fe lt lu lv lw b">pandas</code>中。</p><p id="dfd6" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">假设我们想要对数据中的<code class="fe lt lu lv lw b">neighbourhood</code>列进行标签编码。</p><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nh"><img src="../Images/39b43f0e36a7cdc619033ba3e685faba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*17hcze8Ai6P33CFYS743tw.png"/></div></div></figure><pre class="lz ma mb mc gt ni lw nj nk aw nl bi"><span id="19fb" class="nm ml ji lw b gy nn no l np nq">pd.factorize(data['neighbourhood'])</span></pre><p id="4acd" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">生产</p><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nr"><img src="../Images/0d6b59a22b78e4acd07bd817c1f9100a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9m33AzXmoxvIQZ03Bqmozw.png"/></div></div></figure><p id="c953" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">元组的第一个元素是一个数组，包含序列的标签编码值。元组的第二个元素是索引/列表，其中每个元素的索引对应于第一个元素中的标签。例如，第一个标签编码值是 0。这意味着它的反向编码值是第二个 tuple 元素的第 0 个索引，也就是 Kensington(可以向上滚动来确认这一点)。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="a172" class="mk ml ji bd mm mn mo mp mq mr ms mt mu ko mv kp mw kr mx ks my ku mz kv na nb bi translated">2 | pandas.get_dummies(x)</h1><p id="b2f6" class="pw-post-body-paragraph kx ky ji kz b la nc kj lc ld nd km lf lg ne li lj lk nf lm ln lo ng lq lr ls im bi translated">有时，标签编码不起作用，因为它将数字属性分配给本来就不是数字的对象，例如“哈莱姆是肯辛顿的两倍”或“肯辛顿加三是布鲁克林”。在这种情况下，首选一位热编码，它没有数字偏差，表示相同的数据(尽管以非常稀疏的方式)。</p><p id="e6c1" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">传统的方法是使用<code class="fe lt lu lv lw b">sklearn</code>的<code class="fe lt lu lv lw b">OneHotEncoder</code>，这需要导入<code class="fe lt lu lv lw b">sklearn</code>，并训练一个<code class="fe lt lu lv lw b">OneHotEncoder</code>对象。</p><p id="b472" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">假设我们想对数据集中的同一个<code class="fe lt lu lv lw b">neighborhood </code>列进行一次性编码。</p><pre class="lz ma mb mc gt ni lw nj nk aw nl bi"><span id="d3e7" class="nm ml ji lw b gy nn no l np nq">pd.get_dummies(data['neighbourhood'])</span></pre><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ns"><img src="../Images/ff7f26d14ece5ca09021e7b10f2ad9c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NUNTOnN8xIlRm5gZwkz6sg.png"/></div></div></figure><p id="a67e" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">它甚至按字母顺序排列我们的栏目！</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="55aa" class="mk ml ji bd mm mn mo mp mq mr ms mt mu ko mv kp mw kr mx ks my ku mz kv na nb bi translated">3 | pandas.qcut(x，分位数)</h1><p id="3c00" class="pw-post-body-paragraph kx ky ji kz b la nc kj lc ld nd km lf lg ne li lj lk nf lm ln lo ng lq lr ls im bi translated">通常，对于回归任务(例如，在本例中预测 Airbnb 房源的价格)，将价格范围离散为几个分位数(大小相等的桶)可能会有所帮助。在分位数可接受的情况下，这可以提高精确度并减少模型的不确定性。</p><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nt"><img src="../Images/c23ad0c185647a0bc79733e0c5143d1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PmWFMD09mXMLAiHtYagiJg.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">将变量离散化为分位数。原象</p></figure><p id="34fc" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">熊猫可以用<code class="fe lt lu lv lw b">.qcut</code>自动为你离散化变量。</p><p id="98cc" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">假设我们想要将<code class="fe lt lu lv lw b">price</code>变量离散化为四个分位数。pandas 会自动将价格区间分成你指定的任意数量的分位数。请注意，pandas 将价格范围分成几个桶，每个桶中有相同数量的商品。</p><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nu"><img src="../Images/81b0696468e77e513dee54ed85a808ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bkVlOxOTyiksjVk24660ew.png"/></div></div></figure><pre class="lz ma mb mc gt ni lw nj nk aw nl bi"><span id="24a1" class="nm ml ji lw b gy nn no l np nq">pd.qcut(data['price'],4) #second number specifies num of quantiles</span></pre><p id="4f47" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">生产</p><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nv"><img src="../Images/de4d0a4005b9de6f8186f1315d965cd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LXldghT0_FJg_Gdk1W5qgg.png"/></div></div></figure><p id="06be" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">这是一系列的区间对象。在每个间隔中有偶数个对象。看着系列中的第一个物体，</p><pre class="lz ma mb mc gt ni lw nj nk aw nl bi"><span id="5e29" class="nm ml ji lw b gy nn no l np nq">pd.qcut(data['price'],4)[0]</span></pre><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/c18a84e57d45138ff269b770d06d403a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*5_tATRQlPRS8uXFrjacjfQ.png"/></div></figure><p id="5982" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">…它是一个区间对象。您可以通过应用<code class="fe lt lu lv lw b">str()</code>将其转换成可读性更好的形式。</p><pre class="lz ma mb mc gt ni lw nj nk aw nl bi"><span id="a0ee" class="nm ml ji lw b gy nn no l np nq">str(pd.qcut(data['price'],4)[0])</span></pre><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/6e96d5ab3f143186c708819499421671.png" data-original-src="https://miro.medium.com/v2/resize:fit:550/format:webp/1*xhwjmtUbQ2PmmaX21LGdYg.png"/></div></figure><p id="56f0" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">您可以使用<code class="fe lt lu lv lw b">.apply()</code>将该功能应用于整个系列。然后，如果你喜欢，你可以使用。因式分解对离散化样本进行标签编码。使用这个函数和前面的<code class="fe lt lu lv lw b">.factorize</code>函数的一个好处是，与某些情况不同，标签编码(而不是之后使用<code class="fe lt lu lv lw b">.get_dummies</code>的一次性编码)本身是可以的。</p><p id="fdce" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">一键编码背后的原因是标签编码指定标签之间的数字关系，例如说肯辛顿比哈莱姆小，而对象不能进行数字比较。然而，离散样本可以，因为他们是从一个数字，连续线。</p><p id="d40a" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">请注意，如果您不希望分位数被分割成每个箱中有相等数量的数据点，而是将范围定量地分成相等的部分，请使用<code class="fe lt lu lv lw b">pandas.cut</code>。它与<code class="fe lt lu lv lw b">pandas.qcut</code>接受相同的参数并起相同的作用。</p><pre class="lz ma mb mc gt ni lw nj nk aw nl bi"><span id="8e15" class="nm ml ji lw b gy nn no l np nq">pd.cut(data['price'],4)</span></pre><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ny"><img src="../Images/04827164168eefabc7afbf11f6b0817b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZHk_Sn3iwAXJ0n2XmG75yw.png"/></div></div></figure></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="d5d2" class="mk ml ji bd mm mn mo mp mq mr ms mt mu ko mv kp mw kr mx ks my ku mz kv na nb bi translated">4 | pandas.to_datetime(x)</h1><p id="b2c9" class="pw-post-body-paragraph kx ky ji kz b la nc kj lc ld nd km lf lg ne li lj lk nf lm ln lo ng lq lr ls im bi translated">转换数据对象是数据清理和数据操作中最令人沮丧的方面之一，其中最令人沮丧的可能就是日期。它们以如此多的形式出现，以如此多的方式编写，以至于将它们全部转换成一个干净的 datetime 对象是一件麻烦的事情。</p><p id="7804" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">输入熊猫的<code class="fe lt lu lv lw b">to_datetime</code>。这个函数可以合理地推断任何日期，并将其转换为 datetime 对象，而不需要导入 datetime 或任何其他模块！</p><p id="8b16" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">让我们用不同的命名协议创建四列:</p><pre class="lz ma mb mc gt ni lw nj nk aw nl bi"><span id="b8dd" class="nm ml ji lw b gy nn no l np nq">data['date1'] = '1,2,2019'<br/>data['date2'] = '1/2/2019'<br/>data['date3'] = '1-2-2019'<br/>data['date4'] = '1.2.2019'</span></pre><p id="2de1" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">…然后应用<code class="fe lt lu lv lw b">to_datetime</code>看看熊猫是怎么转换的。</p><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nz"><img src="../Images/5a621cb972908fb125ac9af0259e75f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*94rt0NxOgtXgDJjhV7Raog.png"/></div></div></figure><p id="3d4a" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">熊猫自动为你转换一切！如果日期的排列有点不同，熊猫也可以接受描述月、日和年的排列的字符串。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="9acd" class="mk ml ji bd mm mn mo mp mq mr ms mt mu ko mv kp mw kr mx ks my ku mz kv na nb bi translated">5 |熊猫。数据框架</h1><p id="abaf" class="pw-post-body-paragraph kx ky ji kz b la nc kj lc ld nd km lf lg ne li lj lk nf lm ln lo ng lq lr ls im bi translated">矩阵的转置功能是当<em class="oa"> x </em>和<em class="oa"> y </em>轴相互交换时，因此矩阵反映在对角线上。</p><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/c0fa3f0eb522161e29c4f71e1e6485e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:420/0*e2BJG8KNqUZxSQQ_.gif"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae lx" href="https://upload.wikimedia.org/wikipedia/commons/e/e4/Matrix_transpose.gif" rel="noopener ugc nofollow" target="_blank">来源</a>。图像免费分发和商业使用。</p></figure><p id="ec00" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">这对数据帧也很有帮助。例如，看看这个按日期排列的每个国家因冠状病毒死亡的时间序列数据。</p><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oc"><img src="../Images/400be3911c1a113e280341a2dbe5633e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LkhfOoCkSu14KP1rRioJNw.png"/></div></div></figure><p id="5abc" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">只选择美国来绘制数据，并删除国家、省、纬度和经度等列，我们得到了一个奇怪的数据形状。</p><pre class="lz ma mb mc gt ni lw nj nk aw nl bi"><span id="1fcc" class="nm ml ji lw b gy nn no l np nq">us = data[data['Country/Region'] == 'US']<br/>us.drop(['Province/State','Country/Region','Lat','Long'],axis=1,inplace=True)<br/>us</span></pre><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi od"><img src="../Images/397f64eb8f7e3fa08f8419a9225a9d4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_o9Z3mvRN5jslLQQWo1Lrg.png"/></div></div></figure><p id="45e9" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">处理这个问题的简单方法是将每个列值复制到一个 numpy 数组中进行可视化。然而，有了移调功能，就简单了。</p><pre class="lz ma mb mc gt ni lw nj nk aw nl bi"><span id="d54b" class="nm ml ji lw b gy nn no l np nq">us = us.T<br/>us</span></pre><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/2e39dc3dfc68719b6ffed6e96dd900da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*KetVBKV-7bAQSsHZeCxfvw.png"/></div></figure><p id="f4ff" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">从这里绘图很容易。</p><pre class="lz ma mb mc gt ni lw nj nk aw nl bi"><span id="d12a" class="nm ml ji lw b gy nn no l np nq">us.plot()</span></pre><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi of"><img src="../Images/a9b039eeba81a63256d826a8787a77b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RNzKzZZgxDDOC4tomJvoWw.png"/></div></div></figure><p id="1afd" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">那省了我们很多工作！</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="5e87" class="mk ml ji bd mm mn mo mp mq mr ms mt mu ko mv kp mw kr mx ks my ku mz kv na nb bi translated">6 |熊猫。DataFrame.drop_duplicates()</h1><p id="9b7d" class="pw-post-body-paragraph kx ky ji kz b la nc kj lc ld nd km lf lg ne li lj lk nf lm ln lo ng lq lr ls im bi translated">数据中的一个大问题是重复数据。在从多个来源收集的数据中，重复数据通常会出现，从而导致重复行。太多重复的行会使分析或机器学习模型产生偏差，因此删除它们非常重要。</p><p id="432c" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">熊猫有一个默认的删除重复的功能，<code class="fe lt lu lv lw b">drop_duplicates()</code>。</p><p id="a807" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">让我们设置第一行等于第二行，然后删除任何重复的。</p><pre class="lz ma mb mc gt ni lw nj nk aw nl bi"><span id="3d50" class="nm ml ji lw b gy nn no l np nq">data.loc[1] = data.loc[0]<br/>data.drop_duplicates()</span></pre><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi og"><img src="../Images/6694c933e11f566a1838fe5ea327f1c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D_w5f73KwsOQ-gc93AfaUQ.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">向右多列。</p></figure><p id="a7bd" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">第一排没了。出于演示的目的，我们保留了索引以演示第一行中的分隔符(第一个索引，第二个“行”，如果您想这样引用它的话)。然而，<code class="fe lt lu lv lw b">.drop_duplicates()</code>接受了一个额外的可选参数<code class="fe lt lu lv lw b">ignore_index</code>，如果设置为 True，将创建一个不会被删除中断的连续索引。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="7ffc" class="mk ml ji bd mm mn mo mp mq mr ms mt mu ko mv kp mw kr mx ks my ku mz kv na nb bi translated">7 |熊猫。Series.clip()</h1><p id="343a" class="pw-post-body-paragraph kx ky ji kz b la nc kj lc ld nd km lf lg ne li lj lk nf lm ln lo ng lq lr ls im bi translated">离群值。他们搞砸了分析，丢弃了数据。为了处理异常值，pandas 有一个方便的函数。clip()，不仅要删除异常值，还要删除数据中的潜在错误(比如我最近在一个数据集中看到的，冠状病毒病例数量为负数)。</p><p id="1dbc" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated"><code class="fe lt lu lv lw b">.clip()</code>接受两个参数——一个上限和一个下限——并将上限以上的任何值赋给上限，下限以下的任何值赋给下限。</p><p id="fbc1" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">例如，假设 Airbnb 有一个规则，人们可以列出他们的财产的最高价格是 125 美元，最低价格是 100 美元，超出这些界限的任何东西都是错误的(夸大的假设)。</p><p id="b66e" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">供参考，原始价格:</p><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oh"><img src="../Images/e85f2b33b6f8b913440eedbac8900196.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vUCnAIGl9qK0ujfyHTmmLQ.png"/></div></div></figure><p id="41de" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">让我们将 price 列设置为其自身的一个裁剪版本，其下限和上限是我们从真实世界上下文中理解的。</p><pre class="lz ma mb mc gt ni lw nj nk aw nl bi"><span id="924b" class="nm ml ji lw b gy nn no l np nq">data['price'] = data['price'].clip(100,125)<br/>data.head()</span></pre><figure class="lz ma mb mc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oi"><img src="../Images/932e890d790763cc484d0ff9d5e3298c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8kR0flgONSS8c9fggAooHw.png"/></div></div></figure><p id="315a" class="pw-post-body-paragraph kx ky ji kz b la lb kj lc ld le km lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">所有高于 125 美元的价格都被设置为 125 美元，任何低于 100 美元的价格都被设置为该值。<code class="fe lt lu lv lw b">.clip()</code>应始终与上下文知识一起应用，以确保没有错误，或/和与统计异常值界限一起使用。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="3b99" class="mk ml ji bd mm mn mo mp mq mr ms mt mu ko mv kp mw kr mx ks my ku mz kv na nb bi translated">感谢阅读！</h1><p id="5a5a" class="pw-post-body-paragraph kx ky ji kz b la nc kj lc ld nd km lf lg ne li lj lk nf lm ln lo ng lq lr ls im bi translated">我希望这七个功能能够让你的数据操作、清理和分析更加顺畅。</p></div></div>    
</body>
</html>