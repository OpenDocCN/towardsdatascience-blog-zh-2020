<html>
<head>
<title>How (not) to kill your SQL Server performance with implicit conversion</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何(不)通过隐式转换来降低 SQL Server 的性能</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-not-to-kill-your-sql-server-performance-with-implicit-conversion-e754ac2eb134?source=collection_archive---------34-----------------------#2020-07-06">https://towardsdatascience.com/how-not-to-kill-your-sql-server-performance-with-implicit-conversion-e754ac2eb134?source=collection_archive---------34-----------------------#2020-07-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9fbd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何避免性能杀手并帮助 SQL Server 为查询选择最佳执行计划</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8f16e0f9522cb92ada20049fba75e349.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QHTF_XDayFAARlRXd-oxuw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">莎拉·瓜尔蒂里在<a class="ae ky" href="https://unsplash.com/s/photos/apple-and-oranges?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="c067" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我最近的<a class="ae ky" rel="noopener" target="_blank" href="/datetime2-why-you-should-not-use-it-70e50ae2bab9">文章</a>中，我研究了使用 DATETIME 和 DATETIME2 数据类型之间的<em class="lv">【优点】</em><em class="lv">【缺点】</em>。这项调查似乎让我大开眼界，因为在阅读关于这些数据类型和使用 DATETIME2 时的潜在缺点的文档时，我发现了一组我需要注意的全新内容！</p><h2 id="5b5d" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">什么是隐式转换？</h2><p id="1981" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">简而言之，<em class="lv">隐式转换</em>发生在 SQL Server 需要自动将部分数据从一种数据类型转换为另一种数据类型的时候。</p><p id="235d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在某些情况下，当您执行<em class="lv"> JOIN </em> s 或使用 WHERE 子句过滤结果时，您正在比较“苹果”和“橙子”——因此，SQL Server 需要将“苹果”转换为“橙子”，反之亦然。</p><h2 id="5135" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">为什么隐式转换不好？</h2><p id="ef31" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">为了解决数据类型之间的不一致，SQL Server 必须付出额外的努力并消耗更多的资源。因此，性能会受到影响，导致索引的低效使用和 CPU 的大量使用。</p><p id="c7d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，理论已经足够了，让我们来看看隐式转换在现实中是如何影响性能的。</p><h2 id="b328" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">真实用例</h2><p id="c4f1" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">我有一个包含客户发起的聊天数据的表格。这个表大约有 860 万行。其中一列是<em class="lv">“SourceID”</em>，是来自源系统的聊天 ID。在我的表中，该列是<em class="lv"> VARCHAR(20) </em>类型，尽管所有值都只包含数字。</p><p id="8f93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在 SourceID 列上有一个惟一的非聚集索引，在<em class="lv"> DatetmStartUTC </em>列上有一个索引(该索引包括所有其他外键列)，所以让我们运行几个查询来检查后台发生了什么。</p><p id="9d79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我还打开了 IO 和时间的统计，以便能够比较结果。最后，我打开了实际的执行计划，以便更深入地了解查询执行中的每一个具体步骤。</p><h2 id="5110" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">问题 1 又名“黑仔”</h2><p id="7733" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">当有人在该表中执行简单的数据分析，并且只看到<em class="lv"> SourceID </em>列中的数字时，完全可以编写这样的查询:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="b46e" class="lw lx it mv b gy mz na l nb nc">DECLARE @sourceIDi INT = 8000000<br/><br/>SELECT sourceID<br/>FROM factChat<br/>WHERE sourceID &gt;= @sourceIDi</span></pre><p id="549e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SQL Server 返回大约 822，000 行，这大约是整个表中数据的 10%。</p><p id="4a00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">人们可能会认为 SQL Server 在 SourceID 上使用了索引，但是让我们检查一下情况是否如此:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/8bb6e9a74ba45880509069ec9269b008.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WKsXCMJQDQEAJCIfq_vrwA.png"/></div></div></figure><p id="f008" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所注意到的，SQL Server 使用我们的索引，但是它没有选择执行预期的索引查找操作，而是扫描索引。如果我们将鼠标悬停在索引扫描步骤上，我们将在谓词窗格中看到发生了隐式转换，因为 SQL Server 必须在查询过程中在后台应用数据转换。</p><p id="cc88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该操作对性能有许多额外的影响——仅看一些逻辑读取和 CPU 成本，我们就可以得出结论，这与最佳性能相差甚远:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/17cd110c3456a173dfd6cfe8c1cabfa4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1iFBuG8taNqUivZDYqfddg.png"/></div></div></figure><h2 id="11d1" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">问题 2 又名“好人 1”</h2><p id="0f7c" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">现在，让我们检查当我们向 SQL Server 提供匹配的数据类型时，它是如何反应的:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="5ffc" class="lw lx it mv b gy mz na l nb nc">DECLARE @sourceID varchar(20) = '8000000'<br/><br/><br/>SELECT sourceID<br/>FROM factChat<br/>WHERE sourceID &gt;= @sourceID</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/ea04631f4f5fe4b2ccaaf5c978ebea4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rt6KxQBhiuMirCmLbx5v_Q.png"/></div></div></figure><p id="af5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，SQL Server 按预期执行索引搜索，所以让我们另外检查 SQL Server 在后台做了什么来获取我们的结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/1f0d6cf630dec0364697e956860672ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XiAdPZj243AHsy_iOC0wfg.png"/></div></div></figure><p id="504c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哇，逻辑读取和 CPU 时间减少了近 10 倍！也正因为 SQL Server 在查询过程中不必努力应用隐式转换。</p><p id="2720" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，想象一下大部分数据(记住，这个查询只返回表中 10%的数据)或大表的性能差异。</p><h2 id="e528" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">问题 3 又名“好人 2”</h2><p id="fbad" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">现在，我想向您展示帮助 SQL Server 做它最擅长的事情的另一种方法——选择执行查询的最佳计划。</p><p id="3c2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们仍然可以使用 INT 数据类型，而不是在我们的变量定义中给 SQL Server 正确的数据类型，但是我们可以稍后<strong class="lb iu"> <em class="lv">显式地</em> </strong>告诉 SQL Server 我们想要比较“苹果”和“苹果”(在我们的例子中，VARCHAR 和 VARCHAR):</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="b15c" class="lw lx it mv b gy mz na l nb nc">DECLARE @sourceIDi INT = 8000000<br/><br/>SELECT sourceID<br/>FROM factChat<br/>WHERE sourceID &gt;= CAST(@sourceIDi AS VARCHAR(20))</span></pre><p id="ffb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在这里做了什么？我们明确地通知 SQL Server 我们希望他做什么:将 VARCHAR(20)列 SourceID 与变量的 VARCHAR(20)值进行比较。</p><p id="08ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SQL Server 对此很感激，我们可以看看结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/dcf371bc2eb7ceb780bde35d1946f25a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h8HbXS2TtUHbT6V5JxR0fw.png"/></div></div></figure><p id="20fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一开始，索引查找操作是存在的。让我们来看看统计数据:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/2baafe142f48cfb7a3d4e990335a3488.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1ldjbnSuQzahRARUQOZ-sw.png"/></div></div></figure><p id="8f94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数字与前一次运行中的相似，因此我们可以得出结论，这两次运行几乎相同。</p><h2 id="04ed" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">结论</h2><p id="b829" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">隐式转换可能是一个巨大的性能杀手，而且特别危险，因为它不是那么明显和容易发现。</p><p id="9b62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我推荐阅读 Jonathan Kehayias 撰写的<a class="ae ky" href="https://www.sqlskills.com/blogs/jonathan/finding-implicit-column-conversions-in-the-plan-cache/" rel="noopener ugc nofollow" target="_blank">这篇文章</a>，其中他提供了一个非常有用的脚本，用于识别计划缓存中的隐式转换。</p><p id="e597" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，如果您想确定何时发生隐式转换，请直接查看由微软提供的这个<a class="ae ky" href="https://docs.microsoft.com/en-us/sql/t-sql/data-types/data-type-conversion-database-engine?view=sql-server-ver15" rel="noopener ugc nofollow" target="_blank">超级有用的表</a>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/cf8e56e0300b135a755825c16818dc38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WNdDyLdbMg29Q-s5p8XNcA.png"/></div></div></figure><h2 id="05ca" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">数据类型优先级</h2><p id="eb95" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">数据类型优先级可以在这里找到<a class="ae ky" href="https://docs.microsoft.com/en-us/sql/t-sql/data-types/data-type-precedence-transact-sql?view=sql-server-ver15" rel="noopener ugc nofollow" target="_blank">，这有助于理解 SQL Server 将如何处理数据类型转换。例如，INT 的优先级高于 VARCHAR，这意味着 SQL Server 会将 VARCHAR 转换为 INT，而不是相反。</a></p><p id="d18e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，如果您将 INT 类型的列与 VARCHAR 类型的值进行比较，您的索引仍然可以使用，因为用于比较的列不需要转换。</p><p id="441c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，当比较来自同一“家族”的类型(例如，INT 和 BIGINT)时，SQL Server 仍然倾向于索引查找操作，因为它足够聪明，能够识别这些情况并使用适当的索引。</p><p id="1d6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总之，作为一个<strong class="lb iu"> <em class="lv">一般的经验法则</em> </strong>:不要指望 SQL Server 的“仁慈”或者用数据类型优先来挠头——数据类型应该尽可能匹配，或者比较最终应该使用显式转换来处理。</p></div></div>    
</body>
</html>