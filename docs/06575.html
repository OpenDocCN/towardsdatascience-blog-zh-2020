<html>
<head>
<title>Pythonic Big Data Using Julia?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Julia 的 Pythonic 大数据？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/pythonic-big-data-using-julia-f06dec411a95?source=collection_archive---------47-----------------------#2020-05-24">https://towardsdatascience.com/pythonic-big-data-using-julia-f06dec411a95?source=collection_archive---------47-----------------------#2020-05-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="02ee" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">车床. jl</h2><div class=""/><div class=""><h2 id="16a7" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">Python 可以在 Julia 的帮助下处理大堆数据吗？</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/bc0181332b5f7066bf6717d20836fc05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hK7n0C4sWia3Rt7WnvuPhw.png"/></div></div></figure><p id="7618" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi lz translated">最近，我一直在尝试用 Julia 作为 Python 的后端。虽然这在理论上肯定是一个伟大的概念，但有些东西似乎在翻译中丢失了。这是我和几位 Julia 和 Python 科学家一直在进行的讨论，因为从 Python 中使用 Julia 的道路目前走得很少。我在另一篇文章中也提到了这个概念，您可以在这里阅读:</p><div class="mi mj gp gr mk ml"><a rel="noopener follow" target="_blank" href="/is-julias-place-co-existence-with-python-eff2cb834f41"><div class="mm ab fo"><div class="mn ab mo cl cj mp"><h2 class="bd jd gy z fp mq fr fs mr fu fw jc bi translated">Julia 的位置与 Python 共存吗？</h2><div class="ms l"><h3 class="bd b gy z fp mq fr fs mr fu fw dk translated">Julia 是未来的 ML 语言，还是 Python 不太为人所知的伙伴？</h3></div><div class="mt l"><p class="bd b dl z fp mq fr fs mr fu fw dk translated">towardsdatascience.com</p></div></div><div class="mu l"><div class="mv l mw mx my mu mz lb ml"/></div></div></a></div><p id="a058" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在本文中，我讨论了 Julia 作为 Python 后端取代 C 的潜力。虽然在某种程度上，我确实认为这是一个奇怪的想法——因为 Julia 并不太难，并且在语法上与 Python 非常相似，这也有一个显著的优势。我认为使用 Python 与 Julia 的兼容层可能有用的原因是，Python 有更成熟的 web 框架，更容易部署，而且 Python 有更多为它创建的高级 API。能够将这些强大的工具与 Julia 的速度结合起来处理更多的数据和更大的算法将是梦想成真。</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/91cb685728af57ba0812dcd6bfdf0f42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*Wv7crlmKdgr8gnOov98SmA.jpeg"/></div></figure><h1 id="041f" class="ni nj it bd nk nl nm nn no np nq nr ns ki nt kj nu kl nv km nw ko nx kp ny nz bi translated">顶部加载器</h1><p id="342b" class="pw-post-body-paragraph ld le it lf b lg oa kd li lj ob kg ll lm oc lo lp lq od ls lt lu oe lw lx ly im bi translated">作为 Python 和 Julia 共生技术的一部分，我们需要一个名为 TopLoader 的包。TopLoader 是一个 Pythonic 接口，用于管理 Julia 虚拟环境和包。您可以使用 Pip 添加 TopLoader，如下所示:</p><pre class="ks kt ku kv gt of og oh oi aw oj bi"><span id="086b" class="ok nj it og b gy ol om l on oo">sudo pip3 install TopLoader</span></pre><p id="9f65" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">你可以在 Github 上找到 TopLoader:</p><div class="mi mj gp gr mk ml"><a href="https://github.com/emmettgb/TopLoader" rel="noopener  ugc nofollow" target="_blank"><div class="mm ab fo"><div class="mn ab mo cl cj mp"><h2 class="bd jd gy z fp mq fr fs mr fu fw jc bi translated">emmettgb/TopLoader</h2><div class="ms l"><h3 class="bd b gy z fp mq fr fs mr fu fw dk translated">你好，装载愉快！您可以使用以下命令安装 TopLoader:sudo pip 3 立即从 TopLoader 安装 TopLoader 您可以…</h3></div><div class="mt l"><p class="bd b dl z fp mq fr fs mr fu fw dk translated">github.com</p></div></div><div class="mu l"><div class="op l mw mx my mu mz lb ml"/></div></div></a></div><p id="9b56" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">要设置 TopLoader，首先需要进入 Python REPL 并导入 TopLoader。这将安装和更新 PyCall，并将 Julia 可执行文件设置为从 Python 运行。当然，你也需要正确安装 Julia 来完成这项工作。Apt 软件包管理器安装 Julia 时存在一个已知问题，TopLoader 将无法找到 Julia。</p><p id="047a" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">为了解决这个问题，</p><blockquote class="oq"><p id="cb10" class="or os it bd ot ou ov ow ox oy oz ly dk translated">不要通过 APT 安装 JULIA！</p></blockquote><p id="9ea4" class="pw-post-body-paragraph ld le it lf b lg pa kd li lj pb kg ll lm pc lo lp lq pd ls lt lu pe lw lx ly im bi translated">以下是 Julia Computing 给出的一些 Julian 建议:直接从 Julia Computing 安装 Julia 二进制文件，或<a class="ae pf" href="http://julialang" rel="noopener ugc nofollow" target="_blank"> http://julialang </a>。org。使用 Julia 的包管理器版本会产生以下问题:</p><ul class=""><li id="a260" class="pg ph it lf b lg lh lj lk lm pi lq pj lu pk ly pl pm pn po bi translated">你可能会有一个过时版本的朱莉娅。例如，我使用 Fedora，Dnf 只有 1.2 版的 Julia，而当前版本是 1.4。如果没有最新版本的 Julia，您将无法使用新功能，例如使用@spawn 进行并行计算，这意味着除了多行 for 循环之外，您将无法运行任何线程。</li><li id="a5d8" class="pg ph it lf b lg pp lj pq lm pr lq ps lu pt ly pl pm pn po bi translated">您的 Julia 可执行文件可能会出现在错误的位置。您的包管理器以一种特殊的方式在您的系统上放置文件，拥有一个到/opt 的可执行链接肯定比必须预测每个包管理器将 Julia 二进制文件放在哪里，然后必须通过~/在 Bash 中导出它们更好。或者在每次启动 Julia 之前运行该命令。</li></ul><p id="1e7a" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">当您最终可以导入 TopLoader 时，请确保它是通过 REPL 来完成的。跨越 Julia 和 Python 的解释所涉及的设置不能在其他任何地方发生。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pu"><img src="../Images/29e88c17de74cde4a75b1d4894a37010.png" data-original-src="https://miro.medium.com/v2/resize:fit:1118/format:webp/1*GEySgmgh3q7hr3J3_bXEAw.png"/></div></figure></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h1 id="1d20" class="ni nj it bd nk nl pv nn no np pw nr ns ki px kj nu kl py km nw ko pz kp ny nz bi translated">添加车床</h1><blockquote class="oq"><p id="ad2c" class="or os it bd ot ou ov ow ox oy oz ly dk translated"><a class="ae pf" href="https://github.com/emmettgb/Emmetts-DS-NoteBooks/blob/master/Python3/Lathe%20from%20TL.ipynb" rel="noopener ugc nofollow" target="_blank">(笔记本)</a></p></blockquote><figure class="qb qc qd qe qf kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qa"><img src="../Images/77458fce101ca2efa1c7ccaa0d13164a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1rOzH7T9zpiMN4r9ouF-8A.png"/></div></div></figure><div class="mi mj gp gr mk ml"><a href="http://lathe.ai/" rel="noopener  ugc nofollow" target="_blank"><div class="mm ab fo"><div class="mn ab mo cl cj mp"><h2 class="bd jd gy z fp mq fr fs mr fu fw jc bi translated">车床</h2><div class="ms l"><h3 class="bd b gy z fp mq fr fs mr fu fw dk translated">车床使用更快的方法和简单的方法。使得包装快速、简单且轻便。许多工具和模型…</h3></div><div class="mt l"><p class="bd b dl z fp mq fr fs mr fu fw dk translated">车床. ai</p></div></div><div class="mu l"><div class="qg l mw mx my mu mz lb ml"/></div></div></a></div><p id="545f" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi lz translated"><span class="l ma mb mc bm md me mf mg mh di"> L </span> athe 使用 Julia 的语法表达式来模拟 Python 和 C++等典型鸭式语言中的类。这很好，因为这意味着模型在通过预测方法运行之前得到了初始化。这意味着我们可以像这样拟合一个模型:</p><pre class="ks kt ku kv gt of og oh oi aw oj bi"><span id="9ce6" class="ok nj it og b gy ol om l on oo">model = LogisticRegression(trainX, trainy)</span></pre><p id="753c" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这个表达式将继续计算逻辑回归模型预测所需的任何值。然后我们可以调用 predict 方法，它是我们新模型对象的子对象，来获取我们的<strong class="lf jd"> ŷ.</strong></p><pre class="ks kt ku kv gt of og oh oi aw oj bi"><span id="486d" class="ok nj it og b gy ol om l on oo"><strong class="og jd">ŷ </strong>= model.predict(testX)</span></pre><p id="5857" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">为了演示如何使用 Python 中的 Lathe，我们将首先创建一个带有 TopLoader 的环境，然后向其中添加 Lathe:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qh"><img src="../Images/9eef1dce52178285d8efdd09ec350583.png" data-original-src="https://miro.medium.com/v2/resize:fit:934/format:webp/1*Jz6duar-VmM2KTvTPnonug.png"/></div></figure><p id="c397" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这个环境已经存在，并且已经有车床在里面了。然而，我们将需要安装车床的不稳定分支，以便我们可以修改和测试它。虽然我们可以从 Python 中做到这一点，但我也想演示一下我们如何从朱莉娅·REPL 中做到这一点，在我看来，这要容易得多，也更有意义。我们需要做的就是在当前目录中输入朱莉娅·REPL:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qi"><img src="../Images/4f40f3fd8c8b027b5591098bd80f79b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*C5AigxddCgrIaBu74TxM0g.png"/></div></figure><p id="a823" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">然后用]进入 Pkg REPL，用激活命令激活我们的环境:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qj"><img src="../Images/f411a37db02bd11e5f76a1cfcc3be913.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*9QcPP5aMtV2QbnZi-EPt4w.png"/></div></figure><p id="38d0" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">现在我们可以添加或删除任何我们想要的包。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qk"><img src="../Images/ccbc797bbe0798b2de59aa59596f7b0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RRtGlYGB62j2cAv_2EZ_yw.png"/></div></div></figure><p id="c791" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">现在，如果我们在 TopLoader 中重新加载我们的环境，并使用 List()函数，我们将获得新的更新版本的 Lathe。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ql"><img src="../Images/ccf31a72ecf7ee4ba0e8b81b331b65e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:726/format:webp/1*M965iyaqlw9jltqyYyTcwA.png"/></div></figure><p id="62f9" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们可以从我们的环境中使用 using()方法将 Lathe 导入 Python:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qm"><img src="../Images/c7ab7a854e07fcbcb077c768e5a451be.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/format:webp/1*CPFqd9a9nN0nCbKRSCl1KA.png"/></div></figure><p id="58ea" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">每当我们创建一个模型类型的时候，一切都完全按照预期运行。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qn"><img src="../Images/b730f6b12de35f4f56f6bd84d932373c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/format:webp/1*dG49t8iYeEzuuVJKtGPf_w.png"/></div></figure><p id="3cd0" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">同样，predict()方法也是如此:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qo"><img src="../Images/4024a1c494f15f97ceab0909c6b524ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*B-nFEMgH2nUQP7fWAOv14Q.png"/></div></div></figure><h1 id="f02f" class="ni nj it bd nk nl nm nn no np nq nr ns ki nt kj nu kl nv km nw ko nx kp ny nz bi translated">尝试大型数据集</h1><p id="eb33" class="pw-post-body-paragraph ld le it lf b lg oa kd li lj ob kg ll lm oc lo lp lq od ls lt lu oe lw lx ly im bi translated">为了确定我们是否真的从使用 Julia 而不是 Python 中获得了性能提升，我们需要一个基线。为了做到这一点，我把同样的线性回归函数翻译成 Python。这是一个相当基本的机器学习模型，所以幸运的是 Python 将能够自己完成我们的许多测试。</p><pre class="ks kt ku kv gt of og oh oi aw oj bi"><span id="70f3" class="ok nj it og b gy ol om l on oo">def dot(x,y):<br/>    lst = []<br/>    for i,w in zip(x,y):<br/>        lst.append(i * w)<br/>    return(lst)<br/>def sq(x):<br/>    x = [c ** 2 for c in x]<br/>    return(x)<br/>class LinearRegression:<br/>    def __init__(self,x,y):<br/>        # a = ((∑y)(∑x^2)-(∑x)(∑xy)) / (n(∑x^2) - (∑x)^2)<br/>        # b = (x(∑xy) - (∑x)(∑y)) / n(∑x^2) - (∑x)^2<br/>        if len(x) != len(y):<br/>            pass<br/>        # Get our Summations:<br/>        Σx = sum(x)<br/>        Σy = sum(y)<br/>        # dot x and y<br/>        xy = dot(x,y)<br/>        # ∑dot x and y<br/>        Σxy = sum(xy)<br/>        # dotsquare x<br/>        x2 = sq(x)<br/>        # ∑ dotsquare x<br/>        Σx2 = sum(x2)<br/>        # n = sample size<br/>        n = len(x)<br/>        # Calculate a<br/>        self.a = (((Σy) * (Σx2)) - ((Σx * (Σxy)))) / ((n * (Σx2))-(Σx**2))<br/>        # Calculate b<br/>        self.b = ((n*(Σxy)) - (Σx * Σy)) / ((n * (Σx2)) - (Σx ** 2))<br/>        # The part that is super struct:<br/>    def predict(self,xt):<br/>        xt = [self.a + (self.b * i) for i in xt]<br/>        return(xt)</span></pre><p id="be07" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我还导入了熊猫并读入了我的机器上的两个 CSV 文件，我用它们来进行速度测试。数据集有 10，000，000 个观察值，这可能仍然很容易执行，但几乎肯定会给 Python 一个很好的锻炼。为了给这些计算计时，我将使用 IPython 神奇的命令 timeit。</p><pre class="ks kt ku kv gt of og oh oi aw oj bi"><span id="0512" class="ok nj it og b gy ol om l on oo">%timeit LinearRegression(df["X"],df["Y"]).predict(testdf["X"])</span></pre><p id="d354" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们的结果是 8.78 秒。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qp"><img src="../Images/f046ab99b76dfb3b2774a8ad4fb9f60a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1270/format:webp/1*BnF3WbpWTO51_c679iL2OQ.png"/></div></figure><p id="5d6a" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">与 Julia 在这个精确计算中的速度相比，结果是 0.362333 秒</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qq"><img src="../Images/698f01489c5a12041b274221ec154d64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PVxx-xWy94LEjk5vit9Rlg.png"/></div></div></figure><p id="0ea5" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">但是使用 Python 的 TopLoader 呢？我们能期待类似于 Julia、Python 或介于两者之间的性能吗？在最坏的情况下，由于转换层的原因，性能也会受到严重影响。不幸的是，这似乎正是 TopLoader 以 1 分 10 秒的成绩出现时发生的情况。</p><blockquote class="oq"><p id="97bc" class="or os it bd ot ou ov ow ox oy oz ly dk translated">糟糕透了。</p></blockquote><figure class="qb qc qd qe qf kw gh gi paragraph-image"><div class="gh gi qr"><img src="../Images/c6c395e4b293640b64ca810475cd5e02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1336/format:webp/1*m7SeP-_5t5_iLlPy71MC6w.png"/></div></figure><h1 id="6545" class="ni nj it bd nk nl nm nn no np nq nr ns ki nt kj nu kl nv km nw ko nx kp ny nz bi translated">结论</h1><blockquote class="oq"><p id="b8db" class="or os it bd ot ou ov ow ox oy oz ly dk translated">我不得不接受这个无效假设。</p></blockquote><p id="de96" class="pw-post-body-paragraph ld le it lf b lg pa kd li lj pb kg ll lm pc lo lp lq pd ls lt lu pe lw lx ly im bi translated">简短的回答是否定的，我的估计是正确的，兼容性层导致了太多的速度下降。然而，我认为这个观察可以洞察现实，如果有一个更好的系统，Python 中的 Julia 可能会很棒。TopLoader 的问题是，它需要将 Pythonic 数据转换成 Julian 数据，然后再将这些数据转换回 Julian 数据。也许如果有一种方法可以在后台运行 Julia 实例，从而更有效地从 Python 接收大量数据，那么可能有一种方法可以实现这一点。</p><p id="2081" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">随着对一个更好的系统的需求被清楚地阐明，也许我会开始一个新的项目来实现这个目标。然而，与此同时，在处理数据方面，Julia 肯定对 Python 没有任何帮助，而且使用兼容层似乎比使用 Python 本身要慢。虽然这个概念的未来可能是大胆的，甚至可能意味着用更少的努力获得更快的 Python 包，但未来肯定不是现在。</p><p id="bcd8" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">不管 TopLoader 在这方面有什么缺点，我仍然认为它是一个非常酷的包。用 Python 搭建 Julia 虚拟环境当然是一个很酷的想法，我只能希望最终能够确定一种方法来实现这个概念的全部功能。</p></div></div>    
</body>
</html>