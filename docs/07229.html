<html>
<head>
<title>Hands-on Time Series Forecasting with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python进行实际时间序列预测</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/hands-on-time-series-forecasting-with-python-d4cdcabf8aac?source=collection_archive---------4-----------------------#2020-06-02">https://towardsdatascience.com/hands-on-time-series-forecasting-with-python-d4cdcabf8aac?source=collection_archive---------4-----------------------#2020-06-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="370b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">建立SARIMA模型的Box-Jenkins建模策略</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d4f4fe37425eb71f40fc87f3788fd919.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Oabg7P3_-z_V3eNn"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">布莱恩·苏曼在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="067d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Time_series" rel="noopener ugc nofollow" target="_blank">时间序列</a>分析是从按时间顺序排列的数据点中提取有意义的摘要和统计信息的努力。它们广泛用于应用科学和工程，涉及时间测量，如信号处理、模式识别、数学金融、天气预报、控制工程、医疗数字化、智能城市应用等。</p><p id="567e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着我们不断监测和收集时间序列数据，应用时间序列分析和预测的机会正在增加。</p><p id="fa26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将展示如何用Python开发一个带有季节成分的ARIMA时间序列预测模型。我们将遵循Box-Jenkins三阶段建模方法，以得出预测的最佳模型。</p><p id="3989" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我鼓励任何人查看我的GitHub上的<a class="ae ky" href="https://github.com/Idilismiguzel/Time-Series/blob/master/SARIMA-forecasting.ipynb" rel="noopener ugc nofollow" target="_blank"> Jupyter笔记本</a>以获得完整的分析。</p><p id="e41f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在时间序列分析中，<a class="ae ky" href="https://en.wikipedia.org/wiki/Box%E2%80%93Jenkins_method" rel="noopener ugc nofollow" target="_blank"> Box-Jenkins方法</a>以统计学家George Box和Gwilym Jenkins命名，他们应用ARIMA模型来寻找时间序列模型的最佳拟合。</p><p id="0665" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该模型分为3个步骤:模型识别、参数估计和模型验证。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/0038d55ecb31ed2e3bdb89aa04ef8bdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*subwkhOzjDj19PvgDgpkiw.png"/></div></div></figure><h1 id="6e41" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated"><strong class="ak">时间序列</strong></h1><p id="7713" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">作为数据，我们将使用<a class="ae ky" href="https://bigml.com/user/czuriaga/gallery/dataset/5a8dacbd2a834705180000ec" rel="noopener ugc nofollow" target="_blank">每月牛奶产量数据集。</a>它包括1962年至1975年间每头奶牛的月生产记录(磅)。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="aa3c" class="my lx it mu b gy mz na l nb nc">df = pd.read_csv('./monthly_milk_production.csv', sep=',',                            parse_dates=['Date'], index_col='Date')</span></pre><h2 id="01eb" class="my lx it bd ly nd ne dn mc nf ng dp mg li nh ni mi lm nj nk mk lq nl nm mm nn bi translated">时间序列数据检验</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/6184c21b090df4820c4a15c25245fe60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kKN5_2Ofom4opoMePDEZaQ.png"/></div></div></figure><p id="27f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们从上面的图中可以观察到的，我们的数据有增长的趋势和很强的季节性。</p><p id="05ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用Python的<a class="ae ky" href="https://www.statsmodels.org/stable/index.html" rel="noopener ugc nofollow" target="_blank"> statsmodels </a>库来执行时间序列分解。时间序列分解是将时间序列解构为其<strong class="lb iu">趋势、季节</strong>和<strong class="lb iu">残差分量的统计方法。</strong></p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="2b82" class="my lx it mu b gy mz na l nb nc">import statsmodels.api as sm<br/>from statsmodels.tsa.seasonal import seasonal_decompose</span><span id="861f" class="my lx it mu b gy np na l nb nc">decomposition = seasonal_decompose(df['Production'], freq=12)<br/>decomposition.plot()<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/6a55a7081c0369421dfe72402cf18090.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M8H4ty9kXPSQ3dHW8bkNnA.png"/></div></div></figure><p id="cb67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">分解图表明，每月产奶量具有增长趋势和季节性模式。</p><p id="811b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想更精确地观察季节性成分，我们可以根据月份来绘制数据。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/dd8c491772211f0470a5fb3ec17c2c18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DzdauVWxRmvVvcadQFPtEg.png"/></div></div></figure><h1 id="d5fc" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">1.模型识别</h1><p id="d980" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在这一步，我们需要检测时间序列是否是平稳的，如果不是，我们需要了解需要什么样的变换才能使其平稳。</p><p id="c289" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当时间序列的统计属性(如均值、方差和自相关)随时间保持不变时，该时间序列就是稳定的。换句话说，当时间序列不依赖于时间并且没有趋势或季节效应时，它就是平稳的。大多数统计预测方法都是基于时间序列是(近似)平稳的假设。</p><p id="77ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想象一下，我们有一个随着时间持续增长的时间序列，样本均值和方差将随着样本的大小而增长，他们总是会低估未来期间的均值和方差。这就是为什么，我们需要从一个平稳的时间序列开始，从它的时间相关的趋势和季节成分中去除。</p><p id="c895" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用不同的方法来检查平稳性:</p><ul class=""><li id="9d4f" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated">我们可以从图中了解到，比如我们之前看到的分解图，我们已经观察到了趋势和季节性。</li><li id="e521" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">我们可以绘制<a class="ae ky" href="https://en.wikipedia.org/wiki/Autocorrelation" rel="noopener ugc nofollow" target="_blank">自相关函数</a>和<a class="ae ky" href="https://en.wikipedia.org/wiki/Partial_autocorrelation_function" rel="noopener ugc nofollow" target="_blank">偏自相关函数</a>图，它们提供了关于时间序列值对其先前值的依赖性的信息。如果时间序列是平稳的，那么ACF/PACF图将在少量滞后之后显示出一个快速截止点。</li></ul><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="1e8b" class="my lx it mu b gy mz na l nb nc">from statsmodels.graphics.tsaplots import plot_acf, plot_pacf</span><span id="cc93" class="my lx it mu b gy np na l nb nc">plot_acf(df, lags=50, ax=ax1)<br/>plot_pacf(df, lags=50, ax=ax2)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/6d75392c257825fd2fc75a26ee8cb273.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ctYURoMZNhgtBxvF9hz1pw.png"/></div></div></figure><p id="040a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们看到ACF和PACF图都没有显示快速切入95%置信区间区域(蓝色)，这意味着时间序列不是静止的。</p><ul class=""><li id="c68c" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated">我们可以应用统计检验和扩大的Dickey-Fuller检验是广泛使用的一种。检验的零假设是时间序列有一个单位根，这意味着它是非平稳的。我们使用测试的p值来解释测试结果。如果p值低于阈值(5%或1%)，我们拒绝零假设，时间序列是平稳的。如果p值高于阈值，我们无法拒绝零假设，时间序列是非平稳的。</li></ul><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="52c9" class="my lx it mu b gy mz na l nb nc">from statsmodels.tsa.stattools import adfuller</span><span id="c74a" class="my lx it mu b gy np na l nb nc">dftest = adfuller(df['Production'])</span><span id="aa43" class="my lx it mu b gy np na l nb nc">dfoutput = pd.Series(dftest[0:4], index=['Test Statistic','p-value','#Lags Used','Number of Observations Used'])<br/>for key, value in dftest[4].items():<br/>    dfoutput['Critical Value (%s)'%key] = value<br/>print(dfoutput)</span></pre><blockquote class="of og oh"><p id="6658" class="kz la oi lb b lc ld ju le lf lg jx lh oj lj lk ll ok ln lo lp ol lr ls lt lu im bi translated">Dickey-Fuller检验的结果:<br/>检验统计量-1.303812 <br/> p值0.627427 <br/> #Lags使用13.000000 <br/>观察次数使用154.000000 <br/>临界值(1%) -3.473543 <br/>临界值(5%) -2.880498 <br/>临界值(10%) -2.</p></blockquote><p id="3497" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">p值大于阈值，我们无法拒绝零假设，时间序列是非平稳的，它具有时间相关的成分。</p><p id="9208" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有这些方法都表明<strong class="lb iu">我们拥有非平稳数据。现在，我们需要找到一种方法让它静止不动。</strong></p><p id="a3fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">非平稳时间序列背后有两大原因；趋势和季节性。我们可以应用差分法，从当前观测值中减去以前的观测值，使时间序列平稳。这样我们将消除趋势和季节性，并稳定时间序列的平均值。由于趋势和季节性因素，我们应用了一个非季节性差异<code class="fe om on oo mu b">diff()</code>和一个季节性差异<code class="fe om on oo mu b">diff(12)</code>。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="08ae" class="my lx it mu b gy mz na l nb nc">df_diff = df.diff().diff(12).dropna()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/a16c25f23f1b051d3557b21c839ac35e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RgkvcTrMKBRqQ0ei_kpslQ.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/629ca3e79919f94b6414b86dbe63e002.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uslO0Yw922H0wgylY5E74g.png"/></div></div></figure><blockquote class="of og oh"><p id="d46d" class="kz la oi lb b lc ld ju le lf lg jx lh oj lj lk ll ok ln lo lp ol lr ls lt lu im bi translated">Dickey-Fuller检验结果:<br/>检验统计量-5.038002 <br/> p值0.000019 <br/> #Lags使用11.000000 <br/>观察次数使用143.000000 <br/>临界值(1%) -3.476927 <br/>临界值(5%) -2.881973 <br/>临界值(10%) -2.</p></blockquote><p id="61f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">应用前面列出的平稳性检查，我们注意到差分时间序列图没有揭示任何特定的趋势或季节行为，ACF/PACF图有一个快速截止点，ADF测试结果返回p值几乎为0.00。其低于阈值。所有这些检查表明<strong class="lb iu">差异数据是稳定的。</strong></p><p id="ce46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将应用季节性自回归综合移动平均(SARIMA或季节性ARIMA ),这是ARIMA的扩展，支持带有季节性成分的时间序列数据。ARIMA代表自回归综合移动平均，是时间序列预测最常用的技术之一。</p><p id="9a6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ARIMA模型用ARIMA(p，D，Q)的顺序表示，而萨里玛模型用萨里玛(P，D，q)(P，D，Q)m的顺序表示</p><p id="6621" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> AR(p) </strong>是一个回归模型，它利用了一个观测值和一些滞后观测值之间的依赖关系。</p><p id="eea7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> I(d) </strong>是使时间序列平稳的差分阶。</p><p id="addf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> MA(q) </strong>是一种利用观测值与应用于滞后观测值的移动平均模型的残差之间的相关性的模型。</p><p id="d3f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(P，D，Q)m是专门描述模型的季节性组件的附加参数集。p、D和Q代表季节回归、差分和移动平均系数，m代表每个季节周期中的数据点数。</p><h1 id="c253" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">2.模型参数估计</h1><p id="3116" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我们将使用Python的pmdarima库，为我们的季节性arima模型自动提取最佳参数。在auto_arima函数中，我们将指定<code class="fe om on oo mu b">d=1</code>和<code class="fe om on oo mu b">D=1</code>，因为我们一次区分趋势，一次区分季节性，<code class="fe om on oo mu b">m=12</code>因为我们有月度数据，<code class="fe om on oo mu b">trend='C'</code>包括常数，<code class="fe om on oo mu b">seasonal=True</code>适合季节性arima。此外，我们指定<code class="fe om on oo mu b">trace=True</code>来打印配合的状态。这有助于我们通过比较AIC分数来确定最佳参数。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="1ad5" class="my lx it mu b gy mz na l nb nc">import pmdarima as pm</span><span id="a00b" class="my lx it mu b gy np na l nb nc">model = pm.auto_arima(df['Production'], d=1, D=1,<br/>                      m=12, trend='c', seasonal=True, <br/>                      start_p=0, start_q=0, max_order=6, test='adf',<br/>                      stepwise=True, trace=True)</span></pre><p id="6142" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Akaike_information_criterion" rel="noopener ugc nofollow" target="_blank"> AIC </a> (Akaike信息准则)是样本外预测误差和我们模型的相对质量的估计量。期望的结果是找到尽可能低的AIC分数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/e866fc2a4c6c2cc1aa77139693f3810d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GauXaCxdAgbY1EKIRPkNlw.png"/></div></div></figure><p id="5f28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">具有各种(P，D，q)(P，D，Q)m参数的auto_arima函数的结果表明，当参数等于(1，1，0)(0，1，1，12)时，获得最低的AIC分数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/250789a66ab17be62c0dbe2f3cbbdba6.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/format:webp/1*6NJ0yflPzGk1l7suQd2JUg.png"/></div></figure><p id="3ed7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将数据集分成训练集和测试集。在这里，我用85%作为火车分裂的大小。我们用建议的参数在列车组上创建一个SARIMA模型。我们使用的是statsmodel库中的SARIMAX函数(X描述的是外生参数，这里不加任何)。拟合模型后，我们还可以打印汇总统计数据。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="a423" class="my lx it mu b gy mz na l nb nc">from statsmodels.tsa.statespace.sarimax import SARIMAX</span><span id="ffbe" class="my lx it mu b gy np na l nb nc">model = SARIMAX(train['Production'],<br/>                order=(1,1,0),seasonal_order=(0,1,1,12))<br/>results = model.fit()<br/>results.summary()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/9bc7d347b1c0b574dcb690950b61d6c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:892/format:webp/1*91SE51GMbJIE7dl7Co9Bkg.png"/></div></figure><h1 id="aac4" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">3.模型验证</h1><p id="36af" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">该模型主要关注的是确保残差正态分布，均值为零且不相关。</p><p id="74bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了检查残差统计，我们可以打印模型诊断:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="7e4f" class="my lx it mu b gy mz na l nb nc">results.plot_diagnostics()<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/e3610ffc626ed0f68305d6142cfa23ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I7T5kl1g-c0NA6tpgzdt5A.png"/></div></div></figure><ul class=""><li id="bd32" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated">左上角的图显示了一段时间内的残差，它似乎是一个没有季节性成分的白噪声。</li><li id="65d9" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">右上角的图显示kde线(红色)紧密跟随N(0，1)线，N(0，1)线是均值为零、标准差为1的正态分布的标准符号，表明残差是正态分布的。</li><li id="a0a2" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">左下方的正态QQ图显示残差的有序分布(蓝色)紧密遵循从标准正态分布中提取的样本的线性趋势，表明残差呈正态分布。</li><li id="8401" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">右下角是相关图，表明残差与滞后版本的相关性较低。</li></ul><p id="6302" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有这些结果都表明残差呈低相关性正态分布。</p><p id="9c21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了衡量预测的准确性，我们将测试集上的预测值与其真实值进行比较。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="967d" class="my lx it mu b gy mz na l nb nc">forecast_object = results.get_forecast(steps=len(test))<br/>mean = forecast_object.predicted_mean<br/>conf_int = forecast_object.conf_int()<br/>dates = mean.index</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/99cdb801c73b264c05eff178d62b8c99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oN7dIlU7J8mh0r1bGky9ag.png"/></div></div></figure><p id="21d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从图中，我们看到模型预测几乎与测试集的真实值相匹配。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="f99e" class="my lx it mu b gy mz na l nb nc">from sklearn.metrics import r2_score</span><span id="84d5" class="my lx it mu b gy np na l nb nc">r2_score(test['Production'], predictions)</span><span id="b677" class="my lx it mu b gy np na l nb nc">&gt;&gt;&gt; 0.9240433686806808</span></pre><p id="acde" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">模型的<strong class="lb iu"> R的平方</strong>为0.92，表明模型的决定系数为92%。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="8b2c" class="my lx it mu b gy mz na l nb nc">mean_absolute_percentage_error = np.mean(np.abs(predictions - test['Production'])/np.abs(test['Production']))*100</span><span id="b2ce" class="my lx it mu b gy np na l nb nc">&gt;&gt;&gt; 1.649905</span></pre><p id="b8b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">平均绝对百分比误差</strong> (MAPE)是最常用的精度指标之一，以误差的百分比来表示精度。模型的MAPE得分等于1.64，表明预测误差1.64%，准确率为98.36%。</p><p id="74a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于诊断测试和准确性指标都表明我们的模型近乎完美，我们可以继续进行未来预测。</p><p id="291a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是未来60个月的预测。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="a2a0" class="my lx it mu b gy mz na l nb nc">results.get_forecast(steps=60)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/c362d1651ec8659573a7b6c608422c36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p_xUc6zmfffJB3ir4iQThQ.png"/></div></div></figure></div><div class="ab cl ot ou hx ov" role="separator"><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy"/></div><div class="im in io ip iq"><p id="1eed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望您喜欢学习本教程并在Python中构建时间序列预测。</p><p id="e389" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="oi">如果你喜欢这篇文章，你可以</em> <strong class="lb iu"> <em class="oi"> </em> </strong> <a class="ae ky" href="https://medium.com/@idilismiguzel" rel="noopener"> <strong class="lb iu"> <em class="oi">在这里阅读我的其他文章</em></strong></a><strong class="lb iu"><em class="oi"/></strong><em class="oi">和</em> <a class="ae ky" href="http://medium.com/@idilismiguzel/follow" rel="noopener"> <strong class="lb iu"> <em class="oi">关注我上媒</em></strong></a><strong class="lb iu"><em class="oi"/></strong>如果有任何问题或建议，请告诉我。✨</p><p id="2ffe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">喜欢这篇文章吗？ <a class="ae ky" href="https://idilismiguzel.medium.com/membership" rel="noopener"> <strong class="lb iu">成为会员求更！</strong> </a></p></div></div>    
</body>
</html>