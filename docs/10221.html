<html>
<head>
<title>Edges and Contours Basics with OpenCV</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">OpenCV 的边缘和轮廓基础知识</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/edges-and-contours-basics-with-opencv-66d3263fd6d1?source=collection_archive---------8-----------------------#2020-07-19">https://towardsdatascience.com/edges-and-contours-basics-with-opencv-66d3263fd6d1?source=collection_archive---------8-----------------------#2020-07-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2055" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何使用 Python 和 OpenCV 从图像中提取轮廓</h2></div><p id="32d8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我一直在尝试用 OpenCV 学习计算机视觉，在这篇文章中，我将探索边缘检测和轮廓。</p><p id="2350" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上次我讲了内核和卷积的基础知识。这些方法被广泛用于不同的目的；其中一个引起了我的注意，我觉得这应该是学习计算机视觉的一个极好的下一步。</p><p id="bf35" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">边缘检测和轮廓用于定位图像中颜色或亮度有很大变化的点。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/1a5f111a0d5cc9054211e0a54670c630.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f4d4AeLvaDtsthvUqXrK0g.png"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">原图由<a class="ae lu" href="https://pixabay.com/illustrations/lips-art-painting-design-teeth-3164202/" rel="noopener ugc nofollow" target="_blank"> Stefano </a>提供。</p></figure><p id="1fbf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对我们来说，这看起来很简单直观，但对计算机来说，这可能会很棘手。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="afc5" class="mc md it bd me mf mg dn mh mi mj dp mk kr ml mm mn kv mo mp mq kz mr ms mt mu bi translated">谨慎的</h2><p id="5b33" class="pw-post-body-paragraph ki kj it kk b kl mv ju kn ko mw jx kq kr mx kt ku kv my kx ky kz mz lb lc ld im bi translated">Canny 边缘检测是一种用于从图像中提取边缘的算法，由于它看起来非常简单，我相信我们可以从它开始。</p><p id="b3db" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该算法有四个阶段:</p><ul class=""><li id="738b" class="na nb it kk b kl km ko kp kr nc kv nd kz ne ld nf ng nh ni bi translated"><strong class="kk iu">第一个</strong> —用高斯模糊进行降噪；</li><li id="7fb6" class="na nb it kk b kl nj ko nk kr nl kv nm kz nn ld nf ng nh ni bi translated"><strong class="kk iu">第二个</strong> —用<a class="ae lu" href="https://en.wikipedia.org/wiki/Sobel_operator" rel="noopener ugc nofollow" target="_blank"> Sobel 核</a>得到梯度方向和大小；</li><li id="ca00" class="na nb it kk b kl nj ko nk kr nl kv nm kz nn ld nf ng nh ni bi translated"><strong class="kk iu">第三</strong> —应用非最大抑制，去除不属于轮廓的多余像素；</li><li id="beb5" class="na nb it kk b kl nj ko nk kr nl kv nm kz nn ld nf ng nh ni bi translated"><strong class="kk iu">第四个</strong> —应用使用最小值和最大值的滞后阈值，通过强度梯度过滤轮廓。</li></ul><p id="11fc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尽管看起来不那么容易，但是用 OpenCV 实现 Canny 检测还是很舒服的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="18a6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们从导入库开始。</p><pre class="lf lg lh li gt no np nq nr aw ns bi"><span id="23a8" class="mc md it np b gy nt nu l nv nw">import cv2<br/>import numpy as np<br/>import matplotlib.pyplot as plt</span></pre><p id="de86" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们可以看看我们想要提取轮廓的图像。</p><pre class="lf lg lh li gt no np nq nr aw ns bi"><span id="ee60" class="mc md it np b gy nt nu l nv nw">image = cv2.imread('Images/12.png')<br/>image = cv2.cvtColor(image,cv2.COLOR_BGR2RGB)</span><span id="75c9" class="mc md it np b gy nx nu l nv nw">fig, ax = plt.subplots(1, figsize=(12,8))<br/>plt.imshow(image)</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi ny"><img src="../Images/f0ea2629ac77653e82b5f9cd846d4db2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IxkXfO99pUlHRpxmVu_wPA.png"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">插图由<a class="ae lu" href="https://pixabay.com/illustrations/lips-art-painting-design-teeth-3164202/" rel="noopener ugc nofollow" target="_blank"> Stefano </a>绘制。</p></figure><p id="def5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要使用 Canny，我们需要将图像转换为灰度，然后使用方法。小心处理图像，以及最小和最大阈值。</p><p id="1dfc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我建议您尝试这些阈值，看看结果如何变化。</p><pre class="lf lg lh li gt no np nq nr aw ns bi"><span id="e651" class="mc md it np b gy nt nu l nv nw">g = cv2.cvtColor(image,cv2.COLOR_RGB2GRAY)<br/>edge = cv2.Canny(g, 60, 180)</span><span id="0de4" class="mc md it np b gy nx nu l nv nw">fig, ax = plt.subplots(1, figsize=(12,8))<br/>plt.imshow(edge, cmap='Greys')</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi nz"><img src="../Images/fc9243c3a943003459fde23a5cf9ae28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ltlc5GUwkw-4I2MA5HGJLw.png"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">轮廓。</p></figure><p id="652f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">很好，我们现在可以使用。寻找轮廓和。绘制轮廓，获取并绘制用 Canny 检测发现的外部轮廓。</p><pre class="lf lg lh li gt no np nq nr aw ns bi"><span id="d3ec" class="mc md it np b gy nt nu l nv nw">contours = cv2.findContours(edge, <br/>                            cv2.RETR_EXTERNAL,<br/>                            cv2.CHAIN_APPROX_NONE)</span><span id="31a8" class="mc md it np b gy nx nu l nv nw">cv2.drawContours(image, contours[0], -1, (0,0,255), thickness = 2)</span><span id="9e91" class="mc md it np b gy nx nu l nv nw">fig, ax = plt.subplots(1, figsize=(12,8))<br/>plt.imshow(image)</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi oa"><img src="../Images/a81926b3fbeb025cda82bcae64d0aeab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oZI28d4EzIf1HKAmyUrPLg.png"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">图像上的轮廓。</p></figure><p id="8cd7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">酷，轮廓变量是一个包含所有 Canny 检测到的轮廓的列表——这意味着我们可以像这样访问和操作它们。</p><p id="8cc9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以对这个列表进行排序，并传递 OpenCV 函数。countourArea 作为关键字，它将根据大小对所有检测到的轮廓进行排序。</p><p id="d00c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们试着只画最大的等高线。</p><pre class="lf lg lh li gt no np nq nr aw ns bi"><span id="23e9" class="mc md it np b gy nt nu l nv nw">image = cv2.imread('Images/12.png')<br/>image = cv2.cvtColor(image,cv2.COLOR_BGR2RGB)</span><span id="b7bb" class="mc md it np b gy nx nu l nv nw">contours, h = cv2.findContours(edge, <br/>                               cv2.RETR_EXTERNAL,<br/>                               cv2.CHAIN_APPROX_NONE)</span><span id="5dd1" class="mc md it np b gy nx nu l nv nw">contours = sorted(contours, key=cv2.contourArea, reverse=True)</span><span id="db97" class="mc md it np b gy nx nu l nv nw">cv2.drawContours(image, contours[0], -1, (0,0,255), thickness = 5)</span><span id="673e" class="mc md it np b gy nx nu l nv nw">fig, ax = plt.subplots(1, figsize=(12,8))<br/>plt.imshow(image)</span></pre><p id="bf85" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">*请注意，我重新加载了原始图像，因为我们绘制了最后一个图像。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi ob"><img src="../Images/e7256e76555418fcf0a5d77a1d6a000a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vUcxQELq0IljGFWWZSUbBQ.png"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">面积最大的等高线。</p></figure><p id="1591" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有意思，我想我期待的是别的东西，比如整个嘴唇，甚至是舌头。相反，最突出的轮廓是嘴的一部分，不知何故与牙齿相连。</p><p id="9218" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我想这向我们表明，这些方法要么需要以前的操作，要么需要更直观的图像来达到预期的结果。以现在的方式，我们的轮廓在正确的位置，但它们太颗粒化，无法恢复一个完整的形状。</p><p id="b9da" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尽管如此，该方法允许我们选择我们正在寻找的特定轮廓，甚至过滤一些范围的值。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="940e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还有其他寻找轮廓的方法；例如，简单的二值化也可以完成这项工作。</p><pre class="lf lg lh li gt no np nq nr aw ns bi"><span id="729a" class="mc md it np b gy nt nu l nv nw">image = cv2.imread('Images/12.png')<br/>image = cv2.cvtColor(image,cv2.COLOR_BGR2RGB)</span><span id="03b2" class="mc md it np b gy nx nu l nv nw">gray = cv2.cvtColor(image, cv2.COLOR_RGB2GRAY)<br/>r, t = cv2.threshold(gray, 200, 255, cv2.THRESH_BINARY_INV)</span><span id="bea6" class="mc md it np b gy nx nu l nv nw">contours, h = cv2.findContours(t, cv2.RETR_LIST, cv2.CHAIN_APPROX_NONE)<br/>contours = sorted(contours, key=cv2.contourArea, reverse=True)</span><span id="3cab" class="mc md it np b gy nx nu l nv nw">cv2.drawContours(image, contours, -1, (0,0,255), thickness = 5)</span><span id="8c4e" class="mc md it np b gy nx nu l nv nw">fig, ax = plt.subplots(1, figsize=(12,8))<br/>plt.imshow(image)</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi oc"><img src="../Images/8d9ddcd2ad8c51b74a75f49e00106a1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s6dMjIWVHCqXAuhnO1BgNQ.png"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">具有阈值和二值化的轮廓。</p></figure><p id="f61e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，您可以尝试更改阈值，看看会发生什么。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="f751" class="mc md it bd me mf mg dn mh mi mj dp mk kr ml mm mn kv mo mp mq kz mr ms mt mu bi translated">凸包</h2><p id="3f4e" class="pw-post-body-paragraph ki kj it kk b kl mv ju kn ko mw jx kq kr mx kt ku kv my kx ky kz mz lb lc ld im bi translated">轮廓的典型应用是检测图像中的几何形状，这对于简化涉及分类或对象检测的问题非常有用。</p><p id="f4ee" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">问题是，根据质量、角度、噪声和许多其他因素，轮廓很少是简单的多边形。这就是凸包出现的原因。这里的想法是简化由我们以前的边缘检测方法生成的多边形。</p><p id="2b18" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">看看<a class="ae lu" href="https://en.wikipedia.org/wiki/Convex_hull" rel="noopener ugc nofollow" target="_blank">维基百科对凸包的定义</a>:</p><blockquote class="od oe of"><p id="0a19" class="ki kj og kk b kl km ju kn ko kp jx kq oh ks kt ku oi kw kx ky oj la lb lc ld im bi translated">在几何学中，一个形状的凸包或凸包络或凸闭包是包含它的最小凸集。</p></blockquote><p id="4a04" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相当复杂，但是 OpenCV 用函数. convexHull 简化了这一步。</p><pre class="lf lg lh li gt no np nq nr aw ns bi"><span id="813f" class="mc md it np b gy nt nu l nv nw">image = cv2.imread('Images/14.jpg')<br/>image = cv2.cvtColor(image,cv2.COLOR_BGR2RGB)</span><span id="01d0" class="mc md it np b gy nx nu l nv nw">g = cv2.cvtColor(image,cv2.COLOR_RGB2GRAY)<br/>edge = cv2.Canny(g, 140, 210)</span><span id="aeb8" class="mc md it np b gy nx nu l nv nw">contours, hierarchy = cv2.findContours(edge, cv2.RETR_LIST, cv2.CHAIN_APPROX_NONE)</span><span id="ec3d" class="mc md it np b gy nx nu l nv nw">for c in contours:<br/>    hull = cv2.convexHull(c)<br/>    cv2.drawContours(image, [hull], 0, (0, 255, 0), 2)</span><span id="6479" class="mc md it np b gy nx nu l nv nw">fig, ax = plt.subplots(1, figsize=(12,8))<br/>plt.imshow(image)</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/62c743f2e231d020856c27ac4c8735c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*5wb2l4a7A3YsDIDYclFcgA.png"/></div><p class="lq lr gj gh gi ls lt bd b be z dk translated"><a class="ae lu" href="https://pixabay.com/illustrations/watercolor-rain-weather-paint-1244885/" rel="noopener ugc nofollow" target="_blank">漫游者创作的插图</a></p></figure><p id="93f5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">很好，我们可以看到轮廓并不完全符合图纸，而是简化了水滴的形状。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="760f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我认为这是一个良好的开端，边缘检测，轮廓，以及不同的操作和步骤，我们可以添加到这个过程中。我鼓励你尝试边缘检测的参数、阈值和不同方法。</p><p id="7fec" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢阅读我的文章。我希望你喜欢它。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="65fd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">往期文章</strong> : <br/> <a class="ae lu" rel="noopener" target="_blank" href="/basics-of-kernels-and-convolutions-with-opencv-c15311ab8f55">核与卷积基础知识</a>；<br/> <a class="ae lu" rel="noopener" target="_blank" href="/transformations-with-opencv-ff9a7bea7f8b">变换基础知识</a>；<br/><a class="ae lu" rel="noopener" target="_blank" href="/getting-started-with-opencv-249e86bd4293">OpenCV 入门</a>；</p><p id="0b3b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">资源:<br/></strong><a class="ae lu" href="https://docs.opencv.org/trunk/da/d22/tutorial_py_canny.html" rel="noopener ugc nofollow" target="_blank">OpenCV Canny</a>；<br/> <a class="ae lu" href="https://docs.opencv.org/trunk/dd/d1a/group__imgproc__feature.html#ga04723e007ed888ddf11d9ba04e2232de" rel="noopener ugc nofollow" target="_blank"> OpenCV 特征检测</a>；<br/> <a class="ae lu" href="https://docs.opencv.org/3.4/d7/d1d/tutorial_hull.html" rel="noopener ugc nofollow" target="_blank"> OpenCV 凸包</a>；<br/> <a class="ae lu" href="http://www.math.ucsd.edu/~fan/ron/papers/83_09_convex_hull.pdf" rel="noopener ugc nofollow" target="_blank">求简单多边形的凸包——罗纳德·l·格雷厄姆</a>；<br/> <a class="ae lu" href="https://docs.opencv.org/2.4/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html?highlight=convexhull" rel="noopener ugc nofollow" target="_blank"> OpenCV 结构分析和形状描述</a>；</p></div></div>    
</body>
</html>