<html>
<head>
<title>Easy Matplotlib Legends with Functional Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有函数式编程的简易 Matplotlib 图例</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/easy-matplotlib-legends-with-functional-programming-64615b529118?source=collection_archive---------32-----------------------#2020-07-10">https://towardsdatascience.com/easy-matplotlib-legends-with-functional-programming-64615b529118?source=collection_archive---------32-----------------------#2020-07-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="975f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用多轴绘图时简化构建 matplotlib 图例的过程</h2></div><h1 id="da8f" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">介绍</h1><p id="61b7" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">Matplotlib 是标准的 Python 绘图库。它几乎可以完成您可能需要的任何事情，并生成出版物质量的图形。然而，它确实有点冗长。一个例子是，当一个图包含多个轴时，构建一个完整图例所需的代码量。</p><p id="6286" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">幸运的是，Python 标准库<code class="fe ly lz ma mb b">itertools</code>可用于开发一个简单的函数，收集所有轴上的所有标签，将它们组合成一个图例。</p><h1 id="a3d7" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">案例示例</h1><p id="48ec" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们来举例说明。考虑以下四个不同函数的数据—线性函数、对数函数、指数函数和幂函数。因为我们将每个函数的截距强制为零(或者指数函数和幂函数的截距为 1)，所以我们可以很容易地计算出每个函数的斜率，即每个函数的斜率值为<em class="mc"> f </em> ( <em class="mc"> x </em> =1000) = 100。让我们首先导入<code class="fe ly lz ma mb b">numpy</code>和<code class="fe ly lz ma mb b">matplotlib</code>并评估我们的函数:</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="00c9" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">然后我们可以绘制这些图进行比较:</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="mi mj l"/></div></figure><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mk"><img src="../Images/4bdd5cdea56b2c3d939b38b31de76676.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z-VxFEo9y8aQGFAMADjkDw.png"/></div></div><p class="mr ms gj gh gi mt mu bd b be z dk translated">我们四种不同功能的比较</p></figure><p id="28e3" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">很简单，对吧？但是，如果我们要线性化每一个函数呢？我们可以通过使用对数轴的各种组合来实现这一点。这意味着我们需要将每个函数绘制在它自己的轴上:</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="mi mj l"/></div></figure><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mv"><img src="../Images/850961b045d8d7e8f5c62b47d28c110e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vDS_2xMHTvRqxrIe3v3oqA.png"/></div></div><p class="mr ms gj gh gi mt mu bd b be z dk translated">每个轴都有自己的图例</p></figure><p id="a159" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">好了，我们已经线性化了每个函数…但是我们现在对每个图都有一个图例，而不是一个单独的图例！解决这个问题的标准方法是将每个对<code class="fe ly lz ma mb b">plot()</code>的调用分配给一个变量，然后在我们调用<code class="fe ly lz ma mb b">plt.legend()</code>时组合这些变量:</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="mi mj l"/></div></figure><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mv"><img src="../Images/a35697d5015a92de7628ce2635003004.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C_qreIAgQ9nIzuNi2QxTmw.png"/></div></div><p class="mr ms gj gh gi mt mu bd b be z dk translated">手动累积所有控点和标签会产生所需的图例样式</p></figure><p id="b8e7" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">这是可行的——但是，有几个问题。首先，正如我们在介绍中提到的，它非常冗长。随着我们的情节变得越来越复杂，我们必须分配许多临时变量。其次，我们必须按照图例的正确顺序提供这些。第三，我们必须在对图例的调用中写出标签，而不是在相关行的实际情节调用中保留它们。</p><h1 id="2546" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated"><code class="fe ly lz ma mb b">`chain</code>功能</h1><p id="2a12" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">那么我们能做什么呢？理想情况下，我们能够以编程方式获得每个轴的序列<code class="fe ly lz ma mb b">handles</code>和<code class="fe ly lz ma mb b">labels</code>，组合它们，并将它们传递给<code class="fe ly lz ma mb b">plt.legend()</code>。<code class="fe ly lz ma mb b">matplotlib</code>确实有获得<code class="fe ly lz ma mb b">handles</code>和<code class="fe ly lz ma mb b">labels</code>的功能！我们可以叫<code class="fe ly lz ma mb b">ax.get_legend_handles_labels()</code>。不幸的是，我们必须为每个轴调用这个函数，这意味着我们仍然需要编写一个<code class="fe ly lz ma mb b">for</code>循环，并将<code class="fe ly lz ma mb b">handle</code>和<code class="fe ly lz ma mb b">label</code>追加到一个列表中。这意味着我们也需要一种自动获取所有轴的方法…否则，我们只是将手动输入每一行替换为手动输入每一个轴！</p><p id="f545" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">幸运的是，<code class="fe ly lz ma mb b">plt.Figure</code>类确实包含一个<code class="fe ly lz ma mb b">axes</code>属性，它是轴的序列。但是我们仍然没有解决迭代每个轴的需要。解决方案在于采用函数式编程方法。在命令式编程中，我们编写一个控制结构来循环遍历某个值序列，我们可以使用函数式编程概念来将<a class="ae mw" href="https://en.wikipedia.org/wiki/Map_(higher-order_function)" rel="noopener ugc nofollow" target="_blank"> <strong class="kz ir"> <em class="mc">映射</em> </strong>一个函数到那个序列</a>。<code class="fe ly lz ma mb b">itertools</code>是这类技术的最佳选择。</p><p id="e530" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated"><code class="fe ly lz ma mb b">itertools</code>是一个标准的 Python 库，包含了多个有用的函数。我们将使用<code class="fe ly lz ma mb b"><a class="ae mw" href="https://docs.python.org/2/library/itertools.html#itertools.chain" rel="noopener ugc nofollow" target="_blank">chain()</a></code>，它将多个<code class="fe ly lz ma mb b">Iterable</code>有效地“组合”成一个<code class="fe ly lz ma mb b">Iterable</code>(例如，像一个链中的链接)。虽然<code class="fe ly lz ma mb b">chain()</code>对任意长度的参数序列进行操作，但是如果我们只有一个<code class="fe ly lz ma mb b">Iterable</code>的<code class="fe ly lz ma mb b">Iterable</code>呢？那样的话，我们还有另外一个功能，<code class="fe ly lz ma mb b">chain.from_iterable()</code>。这里有一个简单的例子来说明这些是如何工作的:</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="8b77" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">我们需要的另一个函数是<code class="fe ly lz ma mb b">zip()</code>。这个函数接受一个序列<code class="fe ly lz ma mb b">Iterable</code>并返回一个<code class="fe ly lz ma mb b">Iterable</code>的<code class="fe ly lz ma mb b">Iterable</code>，其中第一个<code class="fe ly lz ma mb b">Iterable</code>是每个参数的第一项，第二个是每个参数的第二项，依此类推。没有<code class="fe ly lz ma mb b">zip.from_iterable()</code>，但是我们可以使用<code class="fe ly lz ma mb b">*</code>操作符简单地“拍打”一下<code class="fe ly lz ma mb b">Iterable</code>。让我们也来举例说明一下:</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="6af4" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">Python 中的列表理解(在实践中)与<code class="fe ly lz ma mb b">map</code>相同，所以我们将使用该语言的习语来编写我们的函数。首先，我们得到句柄和标签，这给了我们<code class="fe ly lz ma mb b">[[handle_1, handle_2, ...], [label_1, label_2, ...]]</code>。</p><p id="953c" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">接下来，我们<code class="fe ly lz ma mb b">zip()</code>将轴 1 的句柄与轴 2、轴 3 等的句柄组合起来。，变成自己的<code class="fe ly lz ma mb b">Iterable</code>。对于标签也是如此。我们得到类似于<code class="fe ly lz ma mb b">([[handle_1, handle_2, ...], [handle_4, handle_5, ...]], [[label_1, label_2, ...], [label_4, label_5, ...]])</code>的东西。</p><p id="a15f" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">最后，我们使用<code class="fe ly lz ma mb b">chain()</code>将所有句柄组合成一个<code class="fe ly lz ma mb b">Iterable</code>，将所有<code class="fe ly lz ma mb b">labels</code>组合成一个<code class="fe ly lz ma mb b">Iterable</code>，并返回一个<code class="fe ly lz ma mb b">Tuple[handles, labels]</code>。然后在作业中解包。</p><p id="d344" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">如果在函数调用中传递的是一系列轴，而不是一个数字，我们只需添加一个<code class="fe ly lz ma mb b">chain()</code>来组合<code class="fe ly lz ma mb b">fig</code>参数和剩余的<code class="fe ly lz ma mb b">args</code>参数。</p><p id="3597" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">让我们把它编码起来:</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="af99" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">我们在类型注释中看到，这个函数可以接受<strong class="kz ir"><em class="mc"/></strong><code class="fe ly lz ma mb b">plt.Figure</code>或<code class="fe ly lz ma mb b">plt.Axes</code>的序列。最简单的就是通过数字。然而，如果我们想改变图例中手柄的顺序，我们可以手动传递轴。该函数返回一个字典，然后我们可以使用 splat 操作符(**)将它作为关键字参数解包到<code class="fe ly lz ma mb b">plt.legend()</code>。让我们使用我们的新功能:</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="mi mj l"/></div></figure><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mv"><img src="../Images/a35697d5015a92de7628ce2635003004.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C_qreIAgQ9nIzuNi2QxTmw.png"/></div></div><p class="mr ms gj gh gi mt mu bd b be z dk translated">和以前一样，但是更容易！</p></figure><p id="fa7c" class="pw-post-body-paragraph kx ky iq kz b la lt jr lc ld lu ju lf lg lv li lj lk lw lm ln lo lx lq lr ls ij bi translated">我们做到了！不管我们创建了多少个轴，我们的函数总是会将每一行添加到我们的图例中。更好的是，我们可以通过在绘制线条时是否提供<code class="fe ly lz ma mb b">label</code>参数来轻松控制将哪些线条添加到图例中。这大大简化了多轴复杂地块的构建。当我们绘制每条线时，我们可以控制我们所需要的，不需要手动跟踪额外的变量及其顺序。</p></div></div>    
</body>
</html>