<html>
<head>
<title>Building a Rock Paper Scissors AI using Tensorflow and OpenCV with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Tensorflow和OpenCV与Python构建石头剪刀布人工智能</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-a-rock-paper-scissors-ai-using-tensorflow-and-opencv-d5fc44fc8222?source=collection_archive---------18-----------------------#2020-05-22">https://towardsdatascience.com/building-a-rock-paper-scissors-ai-using-tensorflow-and-opencv-d5fc44fc8222?source=collection_archive---------18-----------------------#2020-05-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="dab5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">古老的游戏被重新想象和更新……</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/86017a08f54da7c8baa84a0f8a9e2298.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8du96SQUQ0NlWmWvVu20Zw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="ky">图片由</em> <a class="ae kz" href="https://www.esquireme.com/content/20945-how-to-win-at-rock-paper-scissors" rel="noopener ugc nofollow" target="_blank"> <em class="ky"> EsquireME </em> </a></p></figure><blockquote class="la lb lc"><p id="87f4" class="ld le lf lg b lh li ju lj lk ll jx lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">该项目的代码可以在我的<a class="ae kz" href="https://github.com/HOD101s/RockPaperScissor-AI-" rel="noopener ugc nofollow" target="_blank"> Github </a>找到</p></blockquote><div class="ma mb gp gr mc md"><a href="https://github.com/HOD101s/RockPaperScissor-AI-" rel="noopener  ugc nofollow" target="_blank"><div class="me ab fo"><div class="mf ab mg cl cj mh"><h2 class="bd iu gy z fp mi fr fs mj fu fw is bi translated">HOD101s/RockPaperScissor-AI-</h2><div class="mk l"><h3 class="bd b gy z fp mi fr fs mj fu fw dk translated">这个回购是针对初学者谁想要尝试和建立自己的机器人容易。所以让我们开始吧！任何…的基础</h3></div><div class="ml l"><p class="bd b dl z fp mi fr fs mj fu fw dk translated">github.com</p></div></div><div class="mm l"><div class="mn l mo mp mq mm mr ks md"/></div></div></a></div><h1 id="bf1b" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">简介:</h1><p id="f706" class="pw-post-body-paragraph ld le it lg b lh nk ju lj lk nl jx lm nm nn lp lq no np lt lu nq nr lx ly lz im bi translated">这个项目的基础是实验深度学习和图像分类，目的是建立一个简单而有趣的臭名昭著的石头剪刀布游戏的迭代。首先，我想说这个项目是我在5月份的COVID19隔离期间无聊的产物，希望在你读到这封信的时候，一切都恢复正常了。通过这个解释的过程，我的目的是解释这个项目的基础，以简单的术语面向初学者。让我们开始吧...</p><p id="9c15" class="pw-post-body-paragraph ld le it lg b lh li ju lj lk ll jx lm nm lo lp lq no ls lt lu nq lw lx ly lz im bi translated">在构建任何类型的深度学习应用时，都有三个主要步骤:</p><p id="03e3" class="pw-post-body-paragraph ld le it lg b lh li ju lj lk ll jx lm nm lo lp lq no ls lt lu nq lw lx ly lz im bi translated">1.收集和处理数据</p><p id="f9b4" class="pw-post-body-paragraph ld le it lg b lh li ju lj lk ll jx lm nm lo lp lq no ls lt lu nq lw lx ly lz im bi translated">2.建立一个合适的人工智能模型</p><p id="7987" class="pw-post-body-paragraph ld le it lg b lh li ju lj lk ll jx lm nm lo lp lq no ls lt lu nq lw lx ly lz im bi translated">3.部署使用</p><p id="d442" class="pw-post-body-paragraph ld le it lg b lh li ju lj lk ll jx lm nm lo lp lq no ls lt lu nq lw lx ly lz im bi translated">整个项目涉及并与我的<a class="ae kz" href="https://github.com/HOD101s/RockPaperScissor-AI-" rel="noopener ugc nofollow" target="_blank"> Github repo </a>齐头并进，所以请做好准备以供参考。</p></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><h1 id="3f5b" class="ms mt it bd mu mv nz mx my mz oa nb nc jz ob ka ne kc oc kd ng kf od kg ni nj bi translated">收集我们的数据:</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/bce346867bae29a5143d5d1103566849.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FnkQhOGXoRNmYFnPO3gWNA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae kz" href="https://pixabay.com/users/SookyungAn-6281801/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=2704015" rel="noopener ugc nofollow" target="_blank"> Sookyung An </a>来自<a class="ae kz" href="https://pixabay.com/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=2704015" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="ccd8" class="pw-post-body-paragraph ld le it lg b lh li ju lj lk ll jx lm nm lo lp lq no ls lt lu nq lw lx ly lz im bi translated">任何深度学习模型的基础都是<strong class="lg iu">数据</strong>。任何机器学习工程师都会同意，在ML中，<strong class="lg iu">数据远比算法本身更重要。我们需要收集石头、布、剪刀这些符号的图像。我没有下载别人的数据并在上面进行训练，而是制作了自己的数据集，并鼓励大家也建立自己的数据集。稍后，尝试更改数据并重新训练模型，以查看数据对深度学习模型的严重影响。</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="e221" class="pw-post-body-paragraph ld le it lg b lh li ju lj lk ll jx lm nm lo lp lq no ls lt lu nq lw lx ly lz im bi translated">我已经使用Python的OpenCV库进行了所有与相机相关的操作。所以这里的<em class="lf">标签</em>也是指图片属于什么类ie。RPS，根据标签，图像保存在适当的目录中。<em class="lf"> ct </em>和<em class="lf"> maxCt </em>是保存图像的起始和结束索引。剩下的是标准的OpenCV代码，以获取网络摄像头的饲料和保存图像到一个目录。一个<strong class="lg iu">需要注意的关键点</strong>是我所有的图片都是<strong class="lg iu"> 300 x 300尺寸</strong>。运行后，我的目录树看起来像这样。</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="3502" class="om mt it oi b gy on oo l op oq">C:.<br/>├───paper<br/>    │ paper0.jpg<br/>    │ paper1.jpg<br/>    │ paper2.jpg<br/>│<br/>├───rock<br/>    │ rock0.jpg<br/>    │ rock1.jpg<br/>    │ rock2.jpg<br/>│<br/>└───scissor<br/>     scissor0.jpg<br/>     scissor1.jpg<br/>     scissor2.jpg</span></pre><p id="8ed9" class="pw-post-body-paragraph ld le it lg b lh li ju lj lk ll jx lm nm lo lp lq no ls lt lu nq lw lx ly lz im bi translated">如果你是指<a class="ae kz" href="https://github.com/HOD101s/RockPaperScissor-AI-" rel="noopener ugc nofollow" target="_blank"> Github repo </a> getData.py为你做的工作！！</p><h1 id="a916" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">预处理我们的数据:</h1><p id="b330" class="pw-post-body-paragraph ld le it lg b lh nk ju lj lk nl jx lm nm nn lp lq no np lt lu nq nr lx ly lz im bi translated">计算机理解数字，我们有图像供我们使用。因此，我们将把所有的图像转换成它们各自的矢量表示。此外，我们的标签尚未生成，因为已建立的标签不能是文本，所以我已经使用<em class="lf"> shape_to_label </em>字典为每个类手动构建了<strong class="lg iu"> One-Hot-Encoded </strong>表示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="c669" class="pw-post-body-paragraph ld le it lg b lh li ju lj lk ll jx lm nm lo lp lq no ls lt lu nq lw lx ly lz im bi translated">由于我们已经根据类别将图像保存在目录中，因此目录名用作标签，并使用<em class="lf"> shape_to_label </em>字典将其转换为一键显示。接下来，我们遍历系统中的文件来访问图像，<a class="ae kz" href="https://www.geeksforgeeks.org/python-opencv-cv2-imread-method/" rel="noopener ugc nofollow" target="_blank"><em class="lf">cv2 . imread()</em></a><em class="lf"/>函数返回图像的矢量表示。我们通过翻转图像和放大图像来手动增加数据。这增加了我们的数据集大小，而无需拍摄新照片。数据扩充是生成数据集的关键部分。最后，图像和标签存储在单独的numpy数组中。</p><p id="3c1a" class="pw-post-body-paragraph ld le it lg b lh li ju lj lk ll jx lm nm lo lp lq no ls lt lu nq lw lx ly lz im bi translated">更多关于数据扩充的信息请点击。</p><h1 id="134c" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">用迁移学习构建我们的模型:</h1><p id="5c53" class="pw-post-body-paragraph ld le it lg b lh nk ju lj lk nl jx lm nm nn lp lq no np lt lu nq nr lx ly lz im bi translated">当涉及到处理图像数据时，有许多预先训练好的模型可用，这些模型已经在数据集上进行了训练，这些数据集有数千个标签可供我们使用，这要感谢Tensorflow和Keras通过它们的<a class="ae kz" href="https://www.tensorflow.org/api_docs/python/tf/keras/applications" rel="noopener ugc nofollow" target="_blank">应用程序api </a>分发了这些模型。这使得在我们的应用程序中包含这些预先训练好的模型变得轻而易举！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/0796aaee20e94d770983ae106e017c86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ehyqIuoXgThsSymZ4h5yFQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae kz" href="https://mc.ai/transfer-learning-with-deep-learning-machine-learning-techniques/" rel="noopener ugc nofollow" target="_blank">洛伦佐·法米格里尼</a></p></figure><p id="3cfd" class="pw-post-body-paragraph ld le it lg b lh li ju lj lk ll jx lm nm lo lp lq no ls lt lu nq lw lx ly lz im bi translated">简言之，迁移学习采用预先训练的模型，不包括做出最终预测的最终层，从而留给我们模型的强大部分，该部分可以区分这种情况下图像中的特征，并将这些信息传递给我们自己的密集神经网络。</p><p id="0cc6" class="pw-post-body-paragraph ld le it lg b lh li ju lj lk ll jx lm nm lo lp lq no ls lt lu nq lw lx ly lz im bi translated">为什么不训练自己的模型？这完全取决于你！！然而，使用迁移学习可以在很多时候让你的进步更快，从某种意义上说，你可以避免<em class="lf">重新发明轮子</em>。</p><p id="5ecf" class="pw-post-body-paragraph ld le it lg b lh li ju lj lk ll jx lm nm lo lp lq no ls lt lu nq lw lx ly lz im bi translated">其他一些受欢迎的预培训模型:</p><ul class=""><li id="6c73" class="os ot it lg b lh li lk ll nm ou no ov nq ow lz ox oy oz pa bi translated">InceptionV3</li><li id="ad57" class="os ot it lg b lh pb lk pc nm pd no pe nq pf lz ox oy oz pa bi translated">VGG16/19</li><li id="0177" class="os ot it lg b lh pb lk pc nm pd no pe nq pf lz ox oy oz pa bi translated">雷斯内特</li><li id="c4be" class="os ot it lg b lh pb lk pc nm pd no pe nq pf lz ox oy oz pa bi translated">MobileNet</li></ul><p id="972c" class="pw-post-body-paragraph ld le it lg b lh li ju lj lk ll jx lm nm lo lp lq no ls lt lu nq lw lx ly lz im bi translated">这里有一篇关于迁移学习的有趣的<a class="ae kz" href="https://ruder.io/transfer-learning/" rel="noopener ugc nofollow" target="_blank">文章</a>！</p><p id="4a3f" class="pw-post-body-paragraph ld le it lg b lh li ju lj lk ll jx lm nm lo lp lq no ls lt lu nq lw lx ly lz im bi translated">注意:每当我们处理图像数据时，数据卷积神经层的使用几乎是已知的。这里使用的迁移学习模型有这些层次。欲了解CNN<a class="ae kz" href="https://medium.com/@RaghavPrabhu/understanding-of-convolutional-neural-network-cnn-deep-learning-99760835f148" rel="noopener">的更多信息，请访问</a>。</p><h1 id="dbd3" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated"><strong class="ak">实现:</strong></h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/af1f9e9b500bd3cf57e518dad0278432.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*weR1zuGPXfdG7zIKbV2k0A.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">gif by <a class="ae kz" href="https://gifer.com/" rel="noopener ugc nofollow" target="_blank"> Gifer </a></p></figure><p id="24fe" class="pw-post-body-paragraph ld le it lg b lh li ju lj lk ll jx lm nm lo lp lq no ls lt lu nq lw lx ly lz im bi translated">我已经使用DenseNet121模型进行特征提取，其输出最终将输入到我自己的密集神经网络中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="f196" class="pw-post-body-paragraph ld le it lg b lh li ju lj lk ll jx lm nm lo lp lq no ls lt lu nq lw lx ly lz im bi translated"><strong class="lg iu">要点:</strong></p><ul class=""><li id="78d0" class="os ot it lg b lh li lk ll nm ou no ov nq ow lz ox oy oz pa bi translated">由于我们的图像是300x300，指定的输入形状是相同的。额外的3代表RGB层，因此这一层有足够的神经元来处理整个图像。</li><li id="7150" class="os ot it lg b lh pb lk pc nm pd no pe nq pf lz ox oy oz pa bi translated">我们使用DenseNet层作为我们的基础/第一层，然后是我们自己的密集神经网络。</li><li id="a780" class="os ot it lg b lh pb lk pc nm pd no pe nq pf lz ox oy oz pa bi translated">我已经将可训练参数设置为真，这也将重新训练DenseNet的重量。这给了我更好的结果，虽然twas相当耗时。我建议在您自己的实现中，通过更改这些参数(也称为超参数)来尝试不同的迭代。</li><li id="74d0" class="os ot it lg b lh pb lk pc nm pd no pe nq pf lz ox oy oz pa bi translated">因为我们有3个类石头剪子布，最后一层是一个密集层，有3个神经元和softmax激活。</li><li id="76b4" class="os ot it lg b lh pb lk pc nm pd no pe nq pf lz ox oy oz pa bi translated">这最后一层返回图像属于3个类别中的特定类别的概率。</li></ul><p id="075f" class="pw-post-body-paragraph ld le it lg b lh li ju lj lk ll jx lm nm lo lp lq no ls lt lu nq lw lx ly lz im bi translated">如果你指的是<a class="ae kz" href="https://github.com/HOD101s/RockPaperScissor-AI-" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a> train.py负责数据准备和模型训练！</p><p id="e5ad" class="pw-post-body-paragraph ld le it lg b lh li ju lj lk ll jx lm nm lo lp lq no ls lt lu nq lw lx ly lz im bi translated">至此，我们已经收集了数据，构建并训练了模型。剩下的唯一部分是使用OpenCV进行部署。</p><h1 id="5e3f" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">OpenCV实现:</h1><p id="6ffa" class="pw-post-body-paragraph ld le it lg b lh nk ju lj lk nl jx lm nm nn lp lq no np lt lu nq nr lx ly lz im bi translated">这个实现的流程很简单:</p><ul class=""><li id="19b2" class="os ot it lg b lh li lk ll nm ou no ov nq ow lz ox oy oz pa bi translated">启动网络摄像头并读取每一帧</li><li id="7250" class="os ot it lg b lh pb lk pc nm pd no pe nq pf lz ox oy oz pa bi translated">将此帧传递给分类ie模型。预测类别</li><li id="00fb" class="os ot it lg b lh pb lk pc nm pd no pe nq pf lz ox oy oz pa bi translated">用电脑随机移动</li><li id="3801" class="os ot it lg b lh pb lk pc nm pd no pe nq pf lz ox oy oz pa bi translated">计算分数</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="361a" class="pw-post-body-paragraph ld le it lg b lh li ju lj lk ll jx lm nm lo lp lq no ls lt lu nq lw lx ly lz im bi translated">上面的代码片段包含了相当重要的代码块，剩下的部分只是让游戏更加用户友好，RPS规则和得分。</p><p id="b4fd" class="pw-post-body-paragraph ld le it lg b lh li ju lj lk ll jx lm nm lo lp lq no ls lt lu nq lw lx ly lz im bi translated">所以我们从加载我们训练好的模型开始。接下来是石器时代的for-loop实现，在开始程序的预测部分之前显示倒计时。预测之后，分数会根据玩家的移动进行更新。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ph"><img src="../Images/cdabac2f200898bfd8b48816ef1968b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O_vyy3az_GfJowSWafCHjg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae kz" href="https://medium.com/@manasbass.99" rel="noopener">马纳斯·阿查里亚</a></p></figure><p id="a9fb" class="pw-post-body-paragraph ld le it lg b lh li ju lj lk ll jx lm nm lo lp lq no ls lt lu nq lw lx ly lz im bi translated">我们使用<em class="lf"> cv2.rectangle()显式绘制一个目标区域。</em>在使用<em class="lf"> prepImg() </em>函数进行预处理后，只有这部分帧被传递给模型进行预测。</p><p id="725b" class="pw-post-body-paragraph ld le it lg b lh li ju lj lk ll jx lm nm lo lp lq no ls lt lu nq lw lx ly lz im bi translated">完整的play.py代码可以在我的回购协议上的<a class="ae kz" href="https://github.com/HOD101s/RockPaperScissor-AI-/blob/master/play.py" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p><h1 id="4904" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">结论:</h1><p id="2a30" class="pw-post-body-paragraph ld le it lg b lh nk ju lj lk nl jx lm nm nn lp lq no np lt lu nq nr lx ly lz im bi translated">我们已经成功地实施并理解了这个项目的运作。所以继续前进，分叉我的<a class="ae kz" href="https://github.com/HOD101s/RockPaperScissor-AI-" rel="noopener ugc nofollow" target="_blank">实现</a>并进行试验。一个主要的改进可能是增加手部检测，这样我们就不需要明确地绘制目标区域，模型将首先检测手部位置，然后做出预测。我尽量让我的语言对初学者友好，如果你还有任何问题，请发表评论。我鼓励你改进这个项目，并把你的建议发给我。精益求精！</p><div class="ma mb gp gr mc md"><a href="https://www.linkedin.com/in/manas-acharya/" rel="noopener  ugc nofollow" target="_blank"><div class="me ab fo"><div class="mf ab mg cl cj mh"><h2 class="bd iu gy z fp mi fr fs mj fu fw is bi translated">Manas Acharya -机器学习工程师- KubixSquare | LinkedIn</h2><div class="mk l"><h3 class="bd b gy z fp mi fr fs mj fu fw dk translated">机器学习和数据科学爱好者，曾在前端Web领域担任全栈开发人员…</h3></div><div class="ml l"><p class="bd b dl z fp mi fr fs mj fu fw dk translated">www.linkedin.com</p></div></div><div class="mm l"><div class="pi l mo mp mq mm mr ks md"/></div></div></a></div><div class="ma mb gp gr mc md"><a href="https://medium.com/@manasbass.99/facemask-detection-using-tensorflow-and-opencv-824b69cad837" rel="noopener follow" target="_blank"><div class="me ab fo"><div class="mf ab mg cl cj mh"><h2 class="bd iu gy z fp mi fr fs mj fu fw is bi translated">基于Tensorflow和OpenCV的人脸检测</h2><div class="mk l"><h3 class="bd b gy z fp mi fr fs mj fu fw dk translated">有效的实时面具检测。</h3></div><div class="ml l"><p class="bd b dl z fp mi fr fs mj fu fw dk translated">medium.com</p></div></div><div class="mm l"><div class="pj l mo mp mq mm mr ks md"/></div></div></a></div></div></div>    
</body>
</html>