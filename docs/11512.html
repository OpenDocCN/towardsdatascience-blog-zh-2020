<html>
<head>
<title>How to Build a Spam Classifier in 10 Steps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用 10 个步骤构建垃圾邮件分类器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-build-your-first-spam-classifier-in-10-steps-fdbf5b1b3870?source=collection_archive---------5-----------------------#2020-08-10">https://towardsdatascience.com/how-to-build-your-first-spam-classifier-in-10-steps-fdbf5b1b3870?source=collection_archive---------5-----------------------#2020-08-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="49e7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你刚刚开始机器学习，很有可能你会进行一个分类项目。作为一个初学者，我建立了一个垃圾短信分类器，但做了大量的研究，知道从哪里开始。在本文中，我将用 10 个步骤向您介绍我的项目，让您更容易使用 Tf-IDF 矢量器和朴素贝叶斯模型构建您的第一个垃圾邮件分类器！</p><h1 id="1324" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">1.加载并简化数据集</h1><p id="239a" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">如果您在 pandas 中阅读，我们的 SMS 文本消息数据集有 5 列:v1(包含每条文本消息的分类标签 ham/spam)、v2(包含文本消息本身)和三个没有使用的未命名列。我们将 v1 和 v2 列分别重命名为 class_label 和 message，同时去掉其余的列。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="24b6" class="ma kp it lw b gy mb mc l md me">import pandas as pd<br/>df = pd.read_csv(r'spam.csv',encoding='ISO-8859-1')<br/>df.rename(columns = {'v1':'class_label', 'v2':'message'}, inplace = True)<br/>df.drop(['Unnamed: 2', 'Unnamed: 3', 'Unnamed: 4'], axis = 1, inplace = True)</span><span id="3786" class="ma kp it lw b gy mf mc l md me">df</span></pre><figure class="lr ls lt lu gt mh gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/d2900da2d48e333e6817f6957991066b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1218/format:webp/1*sUR5ZF9GiqLstnqCUaVfqw.png"/></div></figure><p id="f2aa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">看看“5572 行 x 2 列”意味着我们的数据集有 5572 条短信！</p><h1 id="3160" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">2.浏览数据集:条形图</h1><p id="a997" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">在开始处理数据之前，在分类问题中执行一些探索性数据分析(EDA)是一个好主意，以便可视化、从中获取一些信息或找到数据的任何问题。我们将查看我们有多少垃圾邮件，并为其创建一个条形图。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="baf8" class="ma kp it lw b gy mb mc l md me">#exploring the dataset</span><span id="64cb" class="ma kp it lw b gy mf mc l md me">df['class_label'].value_counts()</span></pre><figure class="lr ls lt lu gt mh gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/7bebee07a6ac8327b5fa18bd4c2dd5c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/format:webp/1*Iz7x-8dki4OsM4vSfR2RFA.png"/></div></figure><p id="dc12" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们的数据集有 4825 封垃圾邮件和 747 封垃圾邮件。这是一个不平衡的数据集；火腿信息的数量远远高于垃圾信息的数量！这可能会导致我们的模型有偏差。为了解决这个问题，我们可以对我们的数据进行重新采样，以获得相同数量的垃圾邮件。</p><p id="e106" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了生成条形图，我们使用 Matplotlib 中的 NumPy 和 pyplot。</p><figure class="lr ls lt lu gt mh gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/5d3a79aed41b2cbc07f1ebc55367f56d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*xkrpe4Ew5Jb8El66K0gWtw.png"/></div></figure><h1 id="0c84" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">3.探索数据集:单词云</h1><p id="8c4f" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">在我的项目中，我生成了垃圾邮件中最常出现的单词的单词云。</p><p id="d500" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，我们将从数据集中过滤掉所有垃圾邮件。df_spam 是一个只包含垃圾消息的数据帧。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="9d9e" class="ma kp it lw b gy mb mc l md me">df_spam = df[df.class_label=='spam']</span><span id="920d" class="ma kp it lw b gy mf mc l md me">df_spam</span></pre><figure class="lr ls lt lu gt mh gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/df1cafe516c916709c9a9ab12313dfb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/1*Ii033N655R8fCK7G8b7NMA.png"/></div></figure><p id="1537" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们将把数据帧转换成一个列表，列表中的每个元素都是垃圾消息。然后，我们将列表中的每个元素连接成一个大的垃圾邮件字符串。该字符串的小写形式是我们创建单词云所需的格式。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="453d" class="ma kp it lw b gy mb mc l md me">spam_list= df_spam['message'].tolist()</span><span id="40c5" class="ma kp it lw b gy mf mc l md me">filtered_spam = filtered_spam.lower()</span></pre><p id="b158" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，我们将导入相关的库，并将我们的字符串作为参数传入:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="b21f" class="ma kp it lw b gy mb mc l md me">import os<br/>from wordcloud import WordCloud<br/>from PIL import Image</span><span id="60f2" class="ma kp it lw b gy mf mc l md me">comment_mask = np.array(Image.open("comment.png"))<br/>#create and generate a word cloud image<br/>wordcloud = WordCloud(max_font_size = 160, margin=0, mask = comment_mask, background_color = "white", colormap="Reds").generate(filtered_spam)</span></pre><p id="1a7b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">显示后:</p><figure class="lr ls lt lu gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi mn"><img src="../Images/efa6b1d18195eadb0a7f05a67ad6d5dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_h-9R05TGjciymCZ5f37Iw.png"/></div></div></figure><p id="4bff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">很酷吧。在我们的数据集中，垃圾短信中最常见的词是“免费”、“立即打电话”、“认领”、“中奖”等。</p><p id="e033" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于这个单词云，我们需要枕头库，只是因为我使用了遮罩来创建漂亮的语音气泡形状。如果您希望它是方形的，请省略 mask 参数。</p><p id="a818" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">类似地，对于业余消息:</p><figure class="lr ls lt lu gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi ms"><img src="../Images/ac2f58c355b1b2db1b4d5e7244c2716f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1gpUzCturYN6KX40QnRBQQ.png"/></div></div></figure><h1 id="16a2" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">4.处理不平衡的数据集</h1><p id="70a4" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">要处理不平衡的数据，您有多种选择。我在我的项目中得到了一个相当好的 f 值，即使是未采样的数据，但是如果你想重新采样，请看<a class="ae mt" href="https://elitedatascience.com/imbalanced-classes" rel="noopener ugc nofollow" target="_blank">这个</a>。</p><h1 id="0f7c" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">5.分割数据集</h1><p id="e125" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">首先，让我们将类标签从字符串转换成数字形式:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="075c" class="ma kp it lw b gy mb mc l md me">df['class_label'] = df['class_label'].apply(lambda x: 1 if x == 'spam' else 0)</span></pre><p id="fc94" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在机器学习中，我们通常将数据分成两个子集——训练和测试。我们将训练集以及它的已知输出值(在本例中，0 或 1 对应于垃圾邮件或火腿)提供给我们的模型，以便它学习我们数据中的模式。然后，我们使用测试集来获得模型在这个子集上的预测标签。让我们看看如何分割我们的数据。</p><p id="4cc2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，我们从 sklearn 库中导入相关的模块:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="773e" class="ma kp it lw b gy mb mc l md me">from sklearn.model_selection import train_test_split</span></pre><p id="392b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后我们分开:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="3572" class="ma kp it lw b gy mb mc l md me">x_train, x_test, y_train, y_test = train_test_split(df['message'], df['class_label'], test_size = 0.3, random_state = 0)</span></pre><p id="1197" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，让我们看看我们的测试和训练子集有多少条消息:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="830f" class="ma kp it lw b gy mb mc l md me">print('rows in test set: ' + str(x_test.shape))<br/>print('rows in train set: ' + str(x_train.shape))</span></pre><figure class="lr ls lt lu gt mh gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/f5a487a746102f54ff7bda5df100c33d.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*7rVnAzCA5O0Bu5voCjApOQ.png"/></div></figure><p id="c27d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以我们有 1672 条消息用于测试，3900 条消息用于训练！</p><h1 id="1997" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">6.应用 Tf-IDF 矢量器进行特征提取</h1><p id="3a64" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">我们的朴素贝叶斯模型要求数据要么在 Tf-IDF 向量中，要么在单词向量计数中。后者是使用计数矢量器实现的，但我们将通过使用 Tf-IDF 矢量器获得前者。</p><p id="4ffe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Tf-IDF 矢量器为短信中的每个单词创建 TF-IDF 值。Tf-IDF 值的计算方式是为出现频率较低的词赋予较高的值，以便由于英语语法而出现多次的词不会掩盖出现频率较低但更有意义和有趣的词。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="4a44" class="ma kp it lw b gy mb mc l md me">lst = x_train.tolist()<br/>vectorizer = TfidfVectorizer(<br/>input= lst ,  # input is the actual text<br/>lowercase=True,      # convert to lowercase before tokenizing<br/>stop_words='english' # remove stop words<br/>)</span><span id="1be0" class="ma kp it lw b gy mf mc l md me">features_train_transformed = vectorizer.fit_transform(list) #gives tf idf vector for x_train<br/>features_test_transformed  = vectorizer.transform(x_test) #gives tf idf vector for x_test</span></pre><h1 id="6e8a" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">7.训练我们的朴素贝叶斯模型</h1><p id="c4fd" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">我们将我们的朴素贝叶斯模型(也称为多项式)拟合到 x_train 的 Tf-IDF 矢量版本，并将真实输出标签存储在 y_train 中。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="fd60" class="ma kp it lw b gy mb mc l md me">from sklearn.naive_bayes import MultinomialNB<br/># train the model<br/>classifier = MultinomialNB()<br/>classifier.fit(features_train_transformed, y_train)</span></pre><figure class="lr ls lt lu gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi mv"><img src="../Images/0f3c5e00449cb1413753b285b0ec1358.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fdkjyznmQdRmaxAtShaDew.png"/></div></div></figure><h1 id="1b90" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">8.检查精确度和 f 值</h1><p id="d528" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">是时候传入我们对应于 x_test 的 Tf-IDF 矩阵，以及真实的输出标签(y_test)了，来看看我们的模型做得有多好！</p><p id="f28f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，让我们看看模型的准确性:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="3e53" class="ma kp it lw b gy mb mc l md me">print("classifier accuracy {:.2f}%".format(classifier.score(features_test_transformed, y_test) * 100))</span></pre><figure class="lr ls lt lu gt mh gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/0099b3e4efae7b8227b0304236e07701.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/format:webp/1*bnuH-b-mINB4qO8nE0CT1Q.png"/></div></figure><p id="85ac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们的准确度很高！然而，如果我们的模型变得有偏差，这并不是一个很好的指标。因此，我们执行下一步。</p><h1 id="f2a0" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">9.查看混淆矩阵和分类报告</h1><p id="dfd8" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">现在让我们看看我们的混淆矩阵和 f-measure 分数，以<em class="mx">确认</em>我们的模型是否正常:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="df9f" class="ma kp it lw b gy mb mc l md me">labels = classifier.predict(features_test_transformed)<br/>from sklearn.metrics import f1_score<br/>from sklearn.metrics import confusion_matrix<br/>from sklearn.metrics import accuracy_score<br/>from sklearn.metrics import classification_report</span><span id="d254" class="ma kp it lw b gy mf mc l md me">actual = y_test.tolist()<br/>predicted = labels<br/>results = confusion_matrix(actual, predicted)<br/>print('Confusion Matrix :')<br/>print(results)<br/>print ('Accuracy Score :',accuracy_score(actual, predicted))<br/>print ('Report : ')<br/>print (classification_report(actual, predicted) )<br/>score_2 = f1_score(actual, predicted, average = 'binary')<br/>print('F-Measure: %.3f' % score_2)</span></pre><figure class="lr ls lt lu gt mh gh gi paragraph-image"><div class="gh gi my"><img src="../Images/f13fcad76de0b6f5b2b2c5c3cb521297.png" data-original-src="https://miro.medium.com/v2/resize:fit:1346/format:webp/1*zvcwTqsw3wIHtc1RRhvOIw.png"/></div></figure><p id="80e2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们的 f 值是 0.853，我们的混淆矩阵显示我们的模型只做了 61 个错误的分类。在我看来相当不错😊</p><h1 id="e0cc" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">10.我们混淆矩阵的热图(可选)</h1><p id="0c0f" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">您可以使用 seaborn 库创建一个热图来可视化您的混淆矩阵。下面的代码就是这么做的。</p><figure class="lr ls lt lu gt mh gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/0b53e87c0b9d4126eb4df63bd9a07008.png" data-original-src="https://miro.medium.com/v2/resize:fit:1130/format:webp/1*Ya5odVkCA4TtEcWMYdTmxQ.png"/></div></figure><p id="1121" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这就是制作你自己的垃圾邮件分类器！总而言之，我们导入了数据集并对其进行了可视化。然后我们把它分成 train/test，转换成 Tf-IDF 向量。最后，我们训练了我们的朴素贝叶斯模型，并看到了结果！如果你愿意，你可以更进一步，把它部署成一个 web 应用程序。</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h2 id="38ae" class="ma kp it bd kq nh ni dn ku nj nk dp ky kb nl nm lc kf nn no lg kj np nq lk nr bi translated">参考资料/资源:</h2><p id="0c45" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">[1] <strong class="js iu"> </strong> D. T，混淆矩阵可视化(2019)，<a class="ae mt" href="https://medium.com/@dtuk81/confusion-matrix-visualization-fc31e3f30fea" rel="noopener">https://medium . com/@ dtuk 81/混淆-矩阵-可视化-fc31e3f30fea </a></p><ol class=""><li id="6b1b" class="ns nt it js b jt ju jx jy kb nu kf nv kj nw kn nx ny nz oa bi translated">C.文斯，<strong class="js iu"> </strong>朴素贝叶斯垃圾邮件分类器(2018)，<a class="ae mt" href="https://www.codeproject.com/Articles/1231994/Naive-Bayes-Spam-Classifier" rel="noopener ugc nofollow" target="_blank">https://www . code project . com/Articles/1231994/Naive-Bayes-Spam-Classifier</a></li><li id="c08c" class="ns nt it js b jt ob jx oc kb od kf oe kj of kn nx ny nz oa bi translated">H.Attri，<strong class="js iu"> </strong>使用 TF-IDF 算法的特征提取(2019)，<a class="ae mt" href="https://medium.com/@hritikattri10/feature-extraction-using-tf-idf-algorithm-44eedb37305e" rel="noopener">https://medium . com/@ hritikattri 10/Feature-Extraction-using-TF-IDF-algorithm-44 eedb 37305 e</a></li><li id="6c7e" class="ns nt it js b jt ob jx oc kb od kf oe kj of kn nx ny nz oa bi translated">A.Bronshtein，Python 中的训练/测试拆分和交叉验证(2017)，<a class="ae mt" rel="noopener" target="_blank" href="/train-test-split-and-cross-validation-in-python-80b61beca4b6">https://towardsdatascience . com/Train-Test-Split-and-Cross-Validation-in-Python-80 b 61 beca 4 b 6</a></li><li id="23fa" class="ns nt it js b jt ob jx oc kb od kf oe kj of kn nx ny nz oa bi translated"><strong class="js iu">数据集</strong>:<a class="ae mt" href="https://www.kaggle.com/uciml/sms-spam-collection-dataset" rel="noopener ugc nofollow" target="_blank">https://www.kaggle.com/uciml/sms-spam-collection-dataset</a></li><li id="f188" class="ns nt it js b jt ob jx oc kb od kf oe kj of kn nx ny nz oa bi translated"><strong class="js iu">完整代码</strong>:<a class="ae mt" href="https://github.com/samimakhan/Spam-Classification-Project/tree/master/Naive-Bayes" rel="noopener ugc nofollow" target="_blank">https://github . com/samimakhan/Spam-Classification-Project/tree/master/Naive-Bayes</a></li></ol></div></div>    
</body>
</html>