<html>
<head>
<title>Transforming Text Files to Data Tables with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python将文本文件转换成数据表</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/transforming-text-files-to-data-tables-with-python-553def411855?source=collection_archive---------9-----------------------#2020-05-23">https://towardsdatascience.com/transforming-text-files-to-data-tables-with-python-553def411855?source=collection_archive---------9-----------------------#2020-05-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ceb0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">从任何文本文件中提取信息的可重用方法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/df5ca149a0792df02fab05c73ed9a06a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bTbTW4xLZa-cAR2n"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Maksym Kaharlytskyi 在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="0f9a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我描述了如何将一组文本文件转换成可用于自然语言处理和机器学习的数据表。为了展示我的方法，我使用了D. Greene和P. Cunningham在2006年发表的原始BBC新闻文章<a class="ae kv" href="http://mlg.ucd.ie/datasets/bbc.html" rel="noopener ugc nofollow" target="_blank">数据集</a>。</p><p id="2c7e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在进入IDE并开始编码之前，我通常会遵循一个过程，包括理解数据、定义输出以及将所有内容翻译成代码。我认为编码前的任务通常是最重要的，因为它们有助于更有效地构建和遵循编码过程。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ls"><img src="../Images/07fe9d6911523a06137b44acd2c8ea04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n6l0MqrwP09-gRfgfQndZA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">我这个项目的三步流程</p></figure><h1 id="21ce" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">1.数据理解</h1><p id="6060" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在能够从文本文件中提取任何信息之前，我们希望知道它的信息是如何构造的，以及文本文件是如何存储的以及存储在哪里(例如，名称、目录)。</p><h2 id="59e2" class="mq lu iq bd lv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated">结构</h2><p id="6f50" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">为了理解这种结构，我们看一下一些文本文件，了解一下数据的结构。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="ed3f" class="mq lu iq nd b gy nh ni l nj nk">Claxton hunting first major medal<br/><br/>British hurdler Sarah Claxton is confident she can win her first major medal at next month's European Indoor Championships in Madrid.<br/><br/>The 25-year-old has already smashed the British record over 60m hurdles twice this season, setting a new mark of 7.96 seconds to win the AAAs title. "I am quite confident," said Claxton. "But I take each race as it comes. "As long as I keep up my training but not do too much I think there is a chance of a medal." Claxton has won the national 60m hurdles title for the past three years but has struggled to translate her domestic success to the international stage.<br/>...</span></pre><p id="af9f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在新闻文章的上下文中，可以容易地假设第一和第二部分分别对应于标题和副标题。以下各段是文章的正文。查看示例数据，我们还发现这些片段由新行分隔，这些新行可用于拆分文本。</p><h2 id="10ff" class="mq lu iq bd lv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated">储存；储备</h2><p id="505f" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">要编写一个自动运行每个文本文件的脚本，我们需要知道文本文件是如何存储的。因此，我们对目录的命名和组织感兴趣。潜在地，我们需要重新构造东西，这样我们就可以更容易地遍历文件。</p><div class="kg kh ki kj gt ab cb"><figure class="nl kk nm nn no np nq paragraph-image"><img src="../Images/7f9ea1dca5fd084c1ad3c2f9a2eda6a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:870/format:webp/1*-_daJNr-04MWT0ABN29ZXw.png"/></figure><figure class="nl kk nr nn no np nq paragraph-image"><img src="../Images/ed2f46bfdcc26ddd9912112a4c6f3f0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/format:webp/1*dL07LsXpw1GvrKqounX4sQ.png"/><p class="kr ks gj gh gi kt ku bd b be z dk ns di nt nu translated">文本文件的命名和组织</p></figure></div><p id="ee4b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">幸运的是，<a class="ae kv" href="http://mlg.ucd.ie/datasets/bbc.html" rel="noopener ugc nofollow" target="_blank"> BBC新闻数据集</a>已经为自动化信息提取构建好了结构。从上面的截图中可以看出，文本文件根据它们的类型存储在不同的目录中。每个流派的名称也是相似的，由前导零(如果文件号小于100)、文件号和“.”组成。txt”。</p><h1 id="2e4a" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">2.输出定义</h1><p id="0558" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">基于数据理解步骤的见解，我们可以定义输出中应该包含哪些信息。为了确定输出，我们必须考虑上一步的学习，并考虑输出的潜在用例。</p><p id="e5b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">基于我们可能从文本文件中提取的信息，我提出了两种不同的机器学习训练用例:</p><ul class=""><li id="e3fc" class="nv nw iq ky b kz la lc ld lf nx lj ny ln nz lr oa ob oc od bi translated">文本分类(基于文本的类型预测)</li><li id="f2f4" class="nv nw iq ky b kz oe lc of lf og lj oh ln oi lr oa ob oc od bi translated">文本生成(基于文本的标题或副标题生成)</li></ul><p id="ecc3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了满足这两个潜在用例的需求，我建议提取以下信息。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ls"><img src="../Images/55acc28c1fcefa8228470bdfb05cf72d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f9urjDVrvcGG9VT-1e6HdA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">文本文件信息抽取的目标输出</p></figure><p id="c238" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我还将包括文本的长度(以记号的数量表示)，以便以后更容易过滤更短或更长的文本。为了存储提取的数据，我建议使用制表符分隔值(.tsv)文件，因为逗号或分号可以出现在文本列中。</p><h1 id="bcac" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">3.编码</h1><p id="90c6" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">由于前面的步骤，我们知道我们正在处理的数据以及在转换过程结束时我们想要输出什么样的信息。现在你可能知道了，我喜欢把任务分成更小的部分。编码步骤也不例外:)通常，我会将编码分成至少三个不同的部分，并将它们包装在单独的函数中:</p><ul class=""><li id="bcfa" class="nv nw iq ky b kz la lc ld lf nx lj ny ln nz lr oa ob oc od bi translated">读取和分割文件</li><li id="4bc0" class="nv nw iq ky b kz oe lc of lf og lj oh ln oi lr oa ob oc od bi translated">提取信息</li><li id="a67c" class="nv nw iq ky b kz oe lc of lf og lj oh ln oi lr oa ob oc od bi translated">构建数据框</li></ul><p id="031e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了使这个新闻文章提取器可重用，我创建了一个实现这些函数的新类。</p><h2 id="dc03" class="mq lu iq bd lv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated">读取和分割文件</h2><p id="f5df" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">为了用python读取文件，我们需要由目录和文件名组成的相应路径。正如我们在数据理解步骤中观察到的，文件存储在它们对应的流派目录中。这意味着要访问一个文件，我们需要基本路径(对我来说是“数据”)、类型和名称。</p><p id="b4ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果文件存在，我们要读取它，用新的行字符(' \n ')分割它，过滤空字符串，并将剩余的文本部分作为列表返回。在文件不存在的情况下(例如，文件数大于可用文件数)，我们希望返回一个空列表。如果文件不存在，我更喜欢这样做，而不是使用异常或不返回任何异常。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="c5b7" class="mq lu iq nd b gy nh ni l nj nk">def read_and_split_file(self, genre: str, file_name: str) -&gt; list:<br/>    text_data = list()<br/>    current_file = os.path.abspath(os.path.join('data', genre, file_name))<br/>    if os.path.exists(current_file):<br/>        open_file = open(current_file, 'r', encoding="latin-1")<br/>        text_data = open_file.read().split('\n')<br/>        text_data = list(filter(None, text_data))<br/>    return text_data</span></pre><p id="29a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如您在上面的代码中看到的，使用操作系统包。因此，我们需要导入这个包。</p><h2 id="bcf6" class="mq lu iq bd lv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated">提取信息</h2><p id="e214" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">为了提取文本文件的信息并为下一步做好准备，我建议对每种体裁都这样做。这意味着，我们循环遍历相应流派目录中的每个文件。通过保存一个current_number变量，我们可以用前导零来格式化文件名，然后通过调用上面实现的方法来读取和拆分文件。</p><p id="cc1e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果返回的列表是空的，我们想要停止循环，因为这意味着我们到达了循环的末尾，并且在目录中没有任何新的文件。</p><p id="1d87" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">否则，我们将阅读和拆分功能返回的信息添加到特定的数据容器中，如标题、副标题和文本。因为我建议在最终输出中也提供文本的令牌计数，所以我们可以使用nltk包对文本进行令牌化，并将令牌列表的长度添加到token_counts列表中。最后，我们将current_number加1，继续提取下一个文件。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="8bab" class="mq lu iq nd b gy nh ni l nj nk">def extract_genre_files(self, genre: str) -&gt; pd.DataFrame:<br/>    found = True<br/>    current_number = 1<br/>    titles = list()<br/>    subtitles = list()<br/>    texts = list()<br/>    token_counts = list()<br/>    while found:<br/>        file_name = "{:03d}.txt".format(current_number)<br/>        text_data = self.read_and_split_file(genre, file_name)<br/>        if len(text_data) != 0:<br/>            titles.append(text_data[0])<br/>            subtitles.append(text_data[1])<br/>            article_text = ' '.join(text_data[2:])<br/>            texts.append(article_text)<br/>            token_counts.append(len(nltk.word_tokenize(article_text)))<br/>            current_number += 1<br/>        else:<br/>            found = False<br/><br/>    genres = [genre] * len(titles)<br/>    data = {'genre': genres, 'title': titles, 'subtitle': subtitles, 'text': texts, 'token_counts': token_counts}<br/>    data_frame = pd.DataFrame(data)<br/>    return data_frame</span></pre><p id="bd80" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在完成类型文件的循环之后，我们基于存储在特定列表中的提取信息创建一个数据帧。与上一步类似，我们需要导入两个包(nltk和pandas)。还请确保您已经下载了nltk包的“punkt”数据，因为它是标记文本所必需的。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="4311" class="mq lu iq nd b gy nh ni l nj nk">import nltk<br/># nltk.download('punkt')<br/>import pandas as pd</span></pre><h2 id="3a8a" class="mq lu iq bd lv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated">构建数据框</h2><p id="7540" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在最后一步，我们必须在现有流派上创建一个循环，通过调用上面实现的方法提取每个流派的信息，连接每个流派的输出，最后将连接的数据帧保存为带有所需分隔符的csv。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="8457" class="mq lu iq nd b gy nh ni l nj nk">def transform_texts_to_df(self, name, genre_list, delimiter = '\t'):<br/>    article_df_list = list()<br/>    for genre in genre_list:<br/>        article_df_list.append(self.extract_genre_files(genre))<br/>    df = pd.concat(article_df_list)<br/>    df.to_csv(name, sep=delimiter)<br/>    return df</span></pre><p id="f116" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在实现了类及其方法之后，我们需要创建ArticlecsvParser类的一个实例，并调用transform_texts_to_df方法，方法是为生成的CSV提供所需的名称和一个包含所有流派的列表。就这样。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="3596" class="mq lu iq nd b gy nh ni l nj nk">if __name__ == "__main__":<br/>    genre_list = ['business', 'entertainment', 'politics', 'sport', 'tech']<br/>    parser = ArticleCSVParser()<br/>    df = parser.transform_texts_to_df('bbc_articles.csv', genre_list)<br/>    print(df.head())</span></pre><h1 id="e94d" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">结论</h1><p id="70aa" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在本文中，我展示了如何将文本文件转换成数据帧，并将其保存为csv/tsv。为了对不同的数据集重用该类，只需创建一个从ArticleCSVParser继承的新类，并覆盖必须更改的方法。</p><p id="869e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您也可以在这个<a class="ae kv" href="https://github.com/guggio/bbc_news/tree/master/article_to_csv" rel="noopener ugc nofollow" target="_blank">存储库</a>中找到完整的代码和数据集。</p><p id="daae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望你喜欢并快乐编码！</p></div></div>    
</body>
</html>