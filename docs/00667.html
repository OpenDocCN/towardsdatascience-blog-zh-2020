<html>
<head>
<title>Reducing Tensorflow Debugging Time by 90 Percent</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将Tensorflow调试时间减少90%</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/reducing-tensorflow-debugging-time-by-90-percent-41e8d60f9494?source=collection_archive---------19-----------------------#2020-01-19">https://towardsdatascience.com/reducing-tensorflow-debugging-time-by-90-percent-41e8d60f9494?source=collection_archive---------19-----------------------#2020-01-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a448" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">介绍可应用于Tensorflow代码的VeriTensor代码方法，以提高调试效率。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b6de370c10a02917bfe42a5998233c37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KpAuewkVCOWvZBGUJOgdEQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自Pixabay的<a class="ae ky" href="https://pixabay.com/illustrations/scan-system-bug-virus-malware-3963099/" rel="noopener ugc nofollow" target="_blank">图片</a></p></figure><p id="27ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你被困在付费墙前，使用<a class="ae ky" rel="noopener" target="_blank" href="/reducing-tensorflow-debugging-time-by-90-percent-41e8d60f9494?sk=a47e01af4a84a59c3fc4357967f0c8ff">好友链接</a>。</p><p id="2e4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Tensorflow代码很难调试。我过去常常花数周时间调试我的代码。更糟糕的是，大多数时候，我不知道如何继续——我可以看到我的代码没有学习，但我不知道这是因为模型没有学习能力，还是因为实现有bug。如果是后者，bug在哪里？</p><p id="bb33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是很多机器学习从业者面临的挫败感。本文介绍了我为调试张量流代码而设计的VeriTensor方法。VeriTensor基于合同方法的<a class="ae ky" href="https://en.wikipedia.org/wiki/Design_by_contract" rel="noopener ugc nofollow" target="_blank">设计。它包括三种技术。这种方法将我的调试时间从数周减少到数小时，提高了90%以上。更好的是，在我完成调试后，我知道代码中没有错误。多棒的感觉啊！</a></p><h1 id="d95a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">通过断言的规范</h1><p id="1a65" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">有效调试的关键是编写规范来定义代码的正确性。规格说明描述了代码应该做什么，实现描述了代码如何做。一段代码只有在其规格说明方面才是正确的。在Python中，使用断言来编写规范，如下面清单中的第2行和第4行所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="6699" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是你说，写断言是非常困难的。我同意你的观点。我花了15年时间用断言验证代码。我开发了基于断言的技术，微软将其包含在必应搜索引擎中。我知道规格有多复杂。这就是为什么当我开发VeriTensor时，我确保它是实用的。</p><blockquote class="mv"><p id="e9c5" class="mw mx it bd my mz na nb nc nd ne lu dk translated">有效调试的关键是通过断言告诉调试器代码应该做什么。</p></blockquote><h1 id="e224" class="lv lw it bd lx ly lz ma mb mc md me mf jz nf ka mh kc ng kd mj kf nh kg ml mm bi translated">绝对张量方法</h1><p id="0680" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">VeriTensor包括3种技术。您可以在编写Tensorflow代码后应用它们。这意味着这些技术是现成的，你不需要从头开始使用它们。</p><h2 id="1413" class="ni lw it bd lx nj nk dn mb nl nm dp mf li nn no mh lm np nq mj lq nr ns ml nt bi translated"><strong class="ak">技术1:张量形状断言</strong></h2><p id="c5ca" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">当你引入张量时，你需要写断言来检查它们的形状。关于张量形状的不正确假设经常会导致棘手的错误。而<a class="ae ky" href="https://www.tensorflow.org/performance/xla/broadcasting" rel="noopener ugc nofollow" target="_blank"> TensorFlow的广播</a>机制可以把它们隐藏的很深。</p><p id="b4b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，在一个回归算法中，比如深度Q网络(DQN)，你有一个来自神经网络的<em class="ms">预测</em>张量，一个<em class="ms">目标</em>张量和一个<em class="ms">损失</em>张量:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="6c09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ms">预测</em>代表预测值。<em class="ms">目标</em>张量代表期望值，由<em class="ms">奖励</em>张量和<em class="ms">自举_q </em>张量计算得出，<em class="ms"> gamma </em>为浮点数。<em class="ms">损失</em>张量将我们的训练损失表示为均方误差。</p><p id="2170" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们为引入的张量添加断言，如下面的清单所示。这些断言检查<em class="ms">预测</em>和<em class="ms">目标</em>的形状在<em class="ms">批量大小</em>和<em class="ms">动作尺寸方面必须相同。这些是DQN算法中使用的一些量。如果你不熟悉他们，不要担心。这里重要的是，我们编写断言来检查张量形状。最后，由于<em class="ms">损失</em>评估为一个数字，断言声明其形状为[]。</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="8113" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果张量的形状与期望值不匹配，你会得到断言违反。你不会相信你的形状断言经常被违反！</p><h2 id="2056" class="ni lw it bd lx nj nk dn mb nl nm dp mf li nn no mh lm np nq mj lq nr ns ml nt bi translated">技巧2:张量依赖性</h2><p id="b910" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">Tensorflow程序是一个计算图。所以你需要确保你正确地构建了张量图。如果张量B的值依赖于张量A的值(例如B=A+1)，那么在图中应该有一条从节点B到节点A的边。</p><p id="570e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用TensorBoard可视化您的张量流图。然而，理解这个图是困难的，因为现实的张量图通常有数百个节点和边。下图显示了典型的张量板可视化。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/59ce7cedd43a92f114b9041095444d5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hTF8f0RhyJFdbS9rWZlU2w.png"/></div></div></figure><p id="cc89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的关键见解是:要检查你的张量图的结构，你只需要可视化你引入的张量之间的关系。你可以把许多张量组合成一个节点。例如，在具有许多变量的多层神经网络中，每个变量都是一个张量。但是你只需要把整个网络想象成一个单独的节点。</p><p id="9b92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我开发了一个Python包，<em class="ms"> VeriTensor，</em>来简化张量图可视化。我将很快对这个包进行开源。它包含一个类<em class="ms"> TensorGroupDependency。这个类允许你只注册你想要可视化的张量。它为注册的张量生成一个新的、小得多的可视化。</em></p><p id="3d05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一个清单显示了如何使用<em class="ms"> TensorGroupDependency。</em>您首先调用<em class="ms"> add </em>方法来注册张量。然后调用<em class="ms">generate _ dot _ re presentation</em>方法给你一个可视化。该可视化仅显示了已注册的张量及其相关性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="2f9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第1行到第5行创建了一个张量依赖图对象，并注册了要可视化其关系的张量。第8行和第9行用<a class="ae ky" href="https://en.wikipedia.org/wiki/DOT_(graph_description_language)" rel="noopener ugc nofollow" target="_blank">点</a>语言生成并打印这些张量依赖关系，可以用图形方式呈现:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/675816a164bdaf9b575909a5ff9a3da0.png" data-original-src="https://miro.medium.com/v2/resize:fit:660/format:webp/1*Ny1rKYTS_quNgHIWaIMzmw.png"/></div></figure><p id="3526" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来理解上面的依赖关系图:</p><ul class=""><li id="9d7b" class="nw nx it lb b lc ld lf lg li ny lm nz lq oa lu ob oc od oe bi translated">图中的节点代表一个张量或一组张量(例如神经网络中的所有变量)。</li><li id="2c57" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated">如果B中至少有一个张量依赖于A中的一个张量，那么从节点B到节点A就有一条有向边。在我们的例子中，<em class="ms">损失</em>张量依赖于<em class="ms">预测</em>和<em class="ms">目标</em>张量。所以从预测节点和目标节点到丢失节点有两条有向边。</li><li id="9d57" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated">在每个节点中，你看到它的种类，比如【张量】、【占位符】、【变量】。</li><li id="5eed" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated">在每个节点中，您还可以看到张量形状，例如(None，1)，这意味着二维张量，第一维是动态长度None，第二维是长度1。而<em class="ms">损失</em>张量有shape()，因为它是标量。</li></ul><p id="9262" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了检查图结构的正确性，你需要解释为什么每条边都存在。这意味着解释那些张量之间的依赖关系。如果你无法解释某些边的存在，那么你脑海中的想法和你构建的实际图形之间就存在差异。这通常意味着一个错误。</p><p id="4d22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦解释了所有的边，就可以通过调用<em class="ms"> generate_assertions </em>方法来生成描述图的断言，如上面代码片段中的第12行所示。下面的清单显示了生成的断言。它们描述了相同的依赖图。它们将成为您代码的一部分，并将在所有未来的执行中被检查:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="8e35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">顺便说一下，如果您在Tensorflow代码中仔细设计了名称作用域，并在TensorBoard可视化中执行了严格的折叠，您可以得到与上面的库相同的东西。但是我认为图书馆很好，因为:</p><ol class=""><li id="9c78" class="nw nx it lb b lc ld lf lg li ny lm nz lq oa lu ok oc od oe bi translated">最有可能的是，你没有仔细设计你的名字范围——我说的对吗？</li><li id="6c45" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ok oc od oe bi translated">有了这个库，您可以生成那些张量依赖断言，这将有助于您在所有未来的执行中进行调试。</li></ol><h2 id="b1ae" class="ni lw it bd lx nj nk dn mb nl nm dp mf li nn no mh lm np nq mj lq nr ns ml nt bi translated">技术3:张量方程评估</h2><p id="4335" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">到目前为止，您已经验证了您定义的张量之间的依赖关系。最后一步是检查张量是否执行了正确的数值计算。例如，方程B = A +1和B = A -1都引入了从B到A的依赖关系，因此它们的依赖图是相同的。但是你需要指定B=A+1是正确的实现。使用张量方程评估对算法中的每个方程执行此操作:</p><ul class=""><li id="2d25" class="nw nx it lb b lc ld lf lg li ny lm nz lq oa lu ob oc od oe bi translated">在每个优化步骤中，通过在<em class="ms">会话中添加张量来评估所涉及的张量。</em></li><li id="561e" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated">在numpy中用那些张量求值写出相同的等式，以计算所需的值。然后断言期望值与实际值相同。</li></ul><p id="7896" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一个列表显示了对<em class="ms">损失</em>张量的张量方程评估。<em class="ms"> session.run </em>对<em class="ms"> parameter_update_operations，</em>这是你通常拥有的东西，就像梯度下降步骤。除了这些通常的工作，现在<em class="ms"> session.run </em>还评估<em class="ms">预测</em>、<em class="ms">目标</em>和<em class="ms">损失</em>张量。你可以从这三个张量计算出期望的损失。最后，您在第4行和第5行断言实际损失等于期望损失。注意，第4行和第5行是在Python世界中。在Python世界里，你可以使用循环，调用任意函数；这比在张量流世界里容易多了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="353c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">这些技术是否有效和实用？</h1><p id="0a90" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们已经将这些技术应用于我们所有的张量流学习者。下表报告了我们验证五个模型所花费的时间以及我们发现的错误数量。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/35923ceb1437a4f27cf8af34c75ec03d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YHGi175REtVrimuBpotHyg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">表1。使用断言技术检测到的错误</p></figure><p id="a582" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">“学习模块”列列出了机器学习模型的名称。这些是深度强化学习中的演员-评论家算法。</p><p id="e019" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">“编码时间”列报告了我们为这些学习者编写代码所花费的时间，以小时为单位。我们总共花了24小时。</p><p id="c34c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">“验证时间”列报告了我们在验证中花费的时间。这包括编写断言、运行代码、观察断言违规和修复检测到的错误。我们总共花了5个小时。换句话说，验证需要多付出20%的努力。</p><p id="d373" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">“Bugs detected by”列是对每种断言技术的细分。它显示了花费在每项技术上的时间百分比以及检测到的bug数量。总的来说，我们仅在5小时内就发现了23个错误。更重要的是，在应用了这些技术之后，我们知道我们的代码是正确的。</p><p id="9b2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以清楚地看到VeriTensor在检测bug方面是有效的。</p><h1 id="f52c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">为什么VeriTensor对检测bug有效？</h1><p id="78af" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">首先，它们要求您通过断言来定义代码的正确性。编写规范并不是一个新想法，但VeriTensor使它变得切实可行:</p><ul class=""><li id="5624" class="nw nx it lb b lc ld lf lg li ny lm nz lq oa lu ob oc od oe bi translated">形状断言要求你写下你引入的张量的形状——很简单！</li><li id="b87f" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated">张量依赖只需要你关注你引入的张量。这个阶段不需要检查数值运算。这将图形从数百个节点减少到十几个，使人类调查变得切实可行。自动生成断言减少了写下断言所需的时间。</li><li id="7681" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ob oc od oe bi translated">在张量方程求值中，你检查Python世界中的每一个方程。Python世界比Tensorflow世界简单多了。</li></ul><p id="cca0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二，在Tensorflow中找到bug的来源是一件令人畏惧的事情。人们花大部分时间定位错误的来源。一旦我们知道了根源，修复bug通常就很容易了。当按顺序应用时，绝对张量技术可以帮助你定位断层。当你在张量依赖阶段遇到问题时，你知道所有涉及的张量都有正确的形状。当你对一个张量方程有问题时，你知道依赖结构是正确的。简而言之，你可以更好地关注和定位每一个问题。</p><p id="191e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第三，VeriTensor将Tensorflow代码调试从一门艺术变成了一个软件工程过程。如果您遵循一个简单的待办事项列表，该过程将确保代码是正确的:</p><ol class=""><li id="7e72" class="nw nx it lb b lc ld lf lg li ny lm nz lq oa lu ok oc od oe bi translated">为你引入的所有张量写一个形状断言。</li><li id="b97e" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ok oc od oe bi translated">解释这些张量之间的所有依赖边，并自动生成结构化断言。</li><li id="c65e" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ok oc od oe bi translated">写一个断言来检查算法中的每个等式。</li></ol><p id="6540" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">验证和/或测试代码时的一个常见问题是知道如何进行以及何时停止。你从代码的哪一部分开始？应该检查哪些方面？你怎么知道你已经测试够了呢？</p><p id="351e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的三项技术消除了这些疑虑。你一个一个地应用它们，每种技术都有有限的和可管理的步骤。步骤的数量受到你在代码中引入的张量和方程的数量的限制——通常在十几个左右。最后，你知道你的代码是正确的。这是一个工程过程，不是一门艺术，不要忽视这样一个工程过程的力量。当人们知道确切的步骤时，他们会更有效率。</p><blockquote class="mv"><p id="057a" class="mw mx it bd my mz na nb nc nd ne lu dk translated">不要忽视这样一个工程过程的力量。当人们知道确切的步骤时，他们会更有效率。</p></blockquote><h1 id="d791" class="lv lw it bd lx ly lz ma mb mc md me mf jz nf ka mh kc ng kd mj kf nh kg ml mm bi translated">验证代码正确性，而不是性能</h1><p id="e2a0" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我需要说明的是，VeriTensor验证代码的正确性。它不评估代码的性能。正确性意味着你实现的代码符合你的想法。性能是它学习有意义模型的能力。性能通常通过绘制损失、交叉验证、测试数据来衡量。</p><p id="c07d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只有在确定了代码的正确性之后，您才应该查看代码的性能。我称之为先正确后性能原则。否则，你需要担心糟糕的性能是因为学习算法不够好还是代码中存在一些bug。显然你想要后者，但是你将很难证明你的代码没有错误。</p><blockquote class="mv"><p id="23c7" class="mw mx it bd my mz na nb nc nd ne lu dk translated">先正确后性能原则:只有在确定了代码的正确性之后，才考虑代码的性能。</p></blockquote><p id="457a" class="pw-post-body-paragraph kz la it lb b lc om ju le lf on jx lh li oo lk ll lm op lo lp lq oq ls lt lu im bi translated">可悲的是，我看到许多人使用的模式是使用性能指标来驱动调试。当他们的代码没有学习时，他们通过绘制损失函数来开始调试。这违反了先正确后性能的原则，因此无法有效地发现bug。这是因为:</p><ol class=""><li id="dbd5" class="nw nx it lb b lc ld lf lg li ny lm nz lq oa lu ok oc od oe bi translated">性能指标是渐进定向的，而不是单调的。例如，损失函数应该随时间而降低。但是在任何时间点，包括你正在调试的时间点，这些数字都可能上升或下降。没有一个正确的值会让你很难识别出是否有问题。将这与断言进行比较:当存在断言违规时，您知道事情是错误的。</li><li id="609e" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ok oc od oe bi translated">即使您可以看到性能指标明显是错误的，它们也不会告诉您错误源自哪里。将其与VeriTensor的故障定位支持进行比较。你分阶段发现bugs张量形状阶段、张量依赖阶段、张量值阶段。在每个阶段，你都可以专注。</li><li id="2d8b" class="nw nx it lb b lc of lf og li oh lm oi lq oj lu ok oc od oe bi translated">在您修复了bug之后，很难为该bug编写回归测试。这是因为bug的起源和性能度量的症状离得很远。将这与使用断言的测试用例编写体验进行比较。你只需要把主学习循环变成一个学习时间步长更小的单元测试，就可以使测试更快地终止。您可以使用真实输入或随机输入。</li></ol><h1 id="cc0f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">支持我</h1><p id="2497" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如果你喜欢我的故事，如果你考虑通过这个链接成为一名灵媒会员来支持我，我将不胜感激:<a class="ae ky" href="https://jasonweiyi.medium.com/membership" rel="noopener">https://jasonweiyi.medium.com/membership</a>。</p><p id="8f53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我会继续写这些故事。</p><h1 id="66c9" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">视频演示</h1><p id="32b3" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">一年半前，我在Tensorflow深潜活动上展示了VeriTensor。这个演讲很受欢迎。这是演示文稿。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or mu l"/></div></figure><p id="b6a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在那之后的20个月里，我将VeriTensor应用于我所有的机器学习代码，它一次又一次地工作。希望对你也有帮助。</p></div></div>    
</body>
</html>