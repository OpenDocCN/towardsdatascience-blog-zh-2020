<html>
<head>
<title>Detecting Face Features and Applying Filters with JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 JavaScript 检测人脸特征并应用滤镜</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/detecting-face-features-and-applying-filters-with-javascript-34a2081daebb?source=collection_archive---------67-----------------------#2020-07-13">https://towardsdatascience.com/detecting-face-features-and-applying-filters-with-javascript-34a2081daebb?source=collection_archive---------67-----------------------#2020-07-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e6de" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用 JavaScript 构建类似 Snapchat 的过滤器</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c5d95d30282a34dd14b809c1be7d5c81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q1B6a2QpC8hoTcCt78SRpg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">从应用程序中截取—背景照片由<a class="ae ky" href="https://unsplash.com/@theorql?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Théo rql </a>在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="ac51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">几天前我发表了一篇关于“用 Python 检测面部特征”的文章，我在 Twitter<a class="ae ky" href="https://twitter.com/livecodestream" rel="noopener ugc nofollow" target="_blank">上收到了很多关于如何用 JavaScript 做这件事的问题。今天我们将回答这个问题，我们将添加一些额外的东西，比如用蜘蛛侠滤镜或者经典的狗滤镜来遮盖你的脸。参与这个项目非常有趣，我希望你会喜欢。</a></p><p id="648e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文将涵盖两个主要主题:</p><ul class=""><li id="81aa" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">人脸特征识别</li><li id="0458" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">添加过滤器</li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="e568" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">如何检测面部特征？</h1><p id="8794" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">类似于 DLib 的工作方式，对于 JavaScript，我们有一个名为<a class="ae ky" href="https://github.com/auduno/clmtrackr" rel="noopener ugc nofollow" target="_blank"> clmtrackr </a>的库，它将完成检测人脸在图像上的位置的繁重工作，并且还将识别人脸特征，如鼻子、嘴、眼睛等。</p><p id="8be9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该库提供了一些通用模型，这些模型已经过预训练，可以按照如下特征编号使用:</p><p id="74b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">点地图</p><p id="e384" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们用这个库处理一个图像时，它将为地图上的每个点返回一个数组，其中每个点由它在<code class="fe nn no np nq b">x</code>和<code class="fe nn no np nq b">y</code>轴上的位置来标识。当我们构建过滤器时，这将变得非常重要。你可能已经猜到了，如果我们想要画一些东西来代替人的鼻子，我们可以使用鼻子的中心点<code class="fe nn no np nq b">62</code>。</p><p id="0ecb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不过，说够了，让我们开始研究一些很酷的东西吧！</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="74cc" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">我们在建造什么？</h1><p id="226a" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在本文中，我们将利用<code class="fe nn no np nq b">clmtrackr</code>来识别视频流中的人脸(在我们的例子中是网络摄像头或摄像机),并应用可以通过屏幕上的下拉菜单选择的自定义过滤器。这是 codepen 上的应用程序演示(请确保您在浏览器中允许应用程序访问相机，否则它将无法工作):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="2010" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">厉害！它可能不完美，但看起来很神奇！</p><p id="720a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们分解代码并解释我们正在做什么。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="f6b0" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">基本代码结构</h1><p id="1e67" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">为了构建应用程序，我们使用了<a class="ae ky" href="https://p5js.org/" rel="noopener ugc nofollow" target="_blank"> p5.js </a>库，这是一个 JavaScript 库，主要用于处理 canvas，非常适合我们的用例。P5JS 不是你传统的 UI 库，它使用事件来定义什么时候构建 UI，什么时候更新 UI。类似于一些游戏引擎。</p><p id="dd09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想介绍 p5 的 3 个主要事件:</p><ul class=""><li id="3862" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe nn no np nq b">preload</code>:在库加载之后，构建任何 UI 或在屏幕上绘制任何东西之前执行。这使得加载资产变得非常完美。</li><li id="25af" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe nn no np nq b">setup</code>:也是在<code class="fe nn no np nq b">preload</code>之后执行一次，我们在这里准备一切并构建初始 UI</li><li id="9a9e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe nn no np nq b">draw</code>:循环调用的函数，每次系统需要渲染屏幕时执行。</li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="e64d" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">事先装好</h1><p id="a7da" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">根据定义，我们将使用<code class="fe nn no np nq b">preload</code>事件来加载我们将在后面的代码中使用的图像，如下所示:</p><pre class="kj kk kl km gt nt nq nu nv aw nw bi"><span id="2f1a" class="nx mr it nq b gy ny nz l oa ob">function preload() {<br/>    // Spiderman Mask Filter asset<br/>    imgSpidermanMask = loadImage("https://i.ibb.co/9HB2sSv/spiderman-mask-1.png");<br/>    <br/>    // Dog Face Filter assets<br/>    imgDogEarRight = loadImage("https://i.ibb.co/bFJf33z/dog-ear-right.png");<br/>    imgDogEarLeft = loadImage("https://i.ibb.co/dggwZ1q/dog-ear-left.png");<br/>    imgDogNose = loadImage("https://i.ibb.co/PWYGkw1/dog-nose.png");<br/>}</span></pre><p id="cb6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很简单。如您所料，p5 中的函数<code class="fe nn no np nq b">loadImage</code>将加载图像并使其作为 P5 图像对象可用。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="64e9" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">设置</h1><p id="9f7a" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">这里的事情变得更有趣了，因为它是我们加载 UI 的地方。我们将把在这个事件中执行的代码分成 4 个部分</p><h1 id="529d" class="mq mr it bd ms mt oc mv mw mx od mz na jz oe ka nc kc of kd ne kf og kg ng nh bi translated">创建画布</h1><p id="6183" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">因为我们希望我们的代码具有响应性，所以我们的画布将具有动态大小，该大小将根据窗口大小并使用 4:3 的纵横比来计算。在代码中使用这样的纵横比并不理想，但是我们会做一些假设，以保持代码简洁，便于演示。在我们知道画布的尺寸后，我们可以用 P5 函数<code class="fe nn no np nq b">createCanvas</code>创建一个，如下所示。</p><pre class="kj kk kl km gt nt nq nu nv aw nw bi"><span id="dc1f" class="nx mr it nq b gy ny nz l oa ob">const maxWidth = Math.min(windowWidth, windowHeight);<br/>pixelDensity(1);<br/>outputWidth = maxWidth;<br/>outputHeight = maxWidth * 0.75; // 4:3</span><span id="b0c8" class="nx mr it nq b gy oh nz l oa ob">createCanvas(outputWidth, outputHeight);</span></pre><h1 id="4145" class="mq mr it bd ms mt oc mv mw mx od mz na jz oe ka nc kc of kd ne kf og kg ng nh bi translated">捕获视频流</h1><p id="fbdc" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在我们的画布工作后，我们需要从网络摄像头或摄像机捕捉视频流，并将其放入画布，幸运的是 P5 通过<code class="fe nn no np nq b">videoCapture</code>函数可以很容易地做到这一点。</p><pre class="kj kk kl km gt nt nq nu nv aw nw bi"><span id="2e8e" class="nx mr it nq b gy ny nz l oa ob">// webcam capture<br/>videoInput = createCapture(VIDEO);<br/>videoInput.size(outputWidth, outputHeight);<br/>videoInput.hide();</span></pre><h1 id="d89e" class="mq mr it bd ms mt oc mv mw mx od mz na jz oe ka nc kc of kd ne kf og kg ng nh bi translated">构建过滤器选择器</h1><p id="f75d" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我们的应用程序很棒，可以为多个过滤器提供选项，所以我们需要建立一种方法来选择我们想要激活的过滤器。同样…我们可以在这里变得非常有趣，然而，为了简单起见，我们将使用一个简单的下拉菜单，我们可以使用 P5 <code class="fe nn no np nq b">createSelect()</code>函数来创建它。</p><pre class="kj kk kl km gt nt nq nu nv aw nw bi"><span id="3fea" class="nx mr it nq b gy ny nz l oa ob">// select filter<br/>const sel = createSelect();<br/>const selectList = ['Spiderman Mask', 'Dog Filter']; // list of filters<br/>sel.option('Select Filter', -1); // Default no filter<br/>for (let i = 0; i &lt; selectList.length; i++)<br/>{<br/>    sel.option(selectList[i], i);<br/>}<br/>sel.changed(applyFilter);</span></pre><h1 id="0648" class="mq mr it bd ms mt oc mv mw mx od mz na jz oe ka nc kc of kd ne kf og kg ng nh bi translated">创建图像跟踪器</h1><p id="7836" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">图像跟踪器是一个可以附加到视频馈送的对象，它将为每一帧识别所有的脸及其特征。对于给定的视频源，跟踪器需要设置一次。</p><pre class="kj kk kl km gt nt nq nu nv aw nw bi"><span id="8cbf" class="nx mr it nq b gy ny nz l oa ob">// tracker<br/>faceTracker = new clm.tracker();<br/>faceTracker.init();<br/>faceTracker.start(videoInput.elt);</span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="400b" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">绘制视频和滤镜</h1><p id="4ae0" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">现在一切都设置好了，我们需要从 P5 更新我们的<code class="fe nn no np nq b">draw</code>事件，将视频源输出到画布，并应用任何选中的过滤器。在我们的例子中,<code class="fe nn no np nq b">draw</code>函数将非常简单，将复杂性推到每个过滤器定义中。</p><pre class="kj kk kl km gt nt nq nu nv aw nw bi"><span id="8fc3" class="nx mr it nq b gy ny nz l oa ob">function draw() {<br/>  image(videoInput, 0, 0, outputWidth, outputHeight); // render video from webcam</span><span id="1cd3" class="nx mr it nq b gy oh nz l oa ob">  // apply filter based on choice<br/>  switch(selected)<br/>  {<br/>    case '-1': break;<br/>    case '0': drawSpidermanMask(); break;<br/>    case '1': drawDogFace(); break;<br/>  }<br/>}</span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="e74e" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">建立蜘蛛侠面具过滤器</h1><p id="2b50" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">蜘蛛侠面具滤镜</p><p id="9164" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">构建过滤器可能是一项简单或非常复杂的任务。这将取决于过滤器应该做什么。对于蜘蛛侠的面具，我们只需要将蜘蛛侠的面具图像放在屏幕的中央。为此，我们首先通过使用<code class="fe nn no np nq b">faceTraker.getCurrentPosition()</code>来确保我们的 faceTracker 对象确实检测到了人脸。</p><p id="12a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们检测到我们的面部，我们使用 P5 来使用面部点 62 渲染图像，面部点 62 是作为图像中心的鼻子的中心，并且具有如下表示面部大小的宽度和高度。</p><pre class="kj kk kl km gt nt nq nu nv aw nw bi"><span id="06d7" class="nx mr it nq b gy ny nz l oa ob">const positions = faceTracker.getCurrentPosition();<br/>if (positions !== false)<br/>{<br/>    push();<br/>    const wx = Math.abs(positions[13][0] - positions[1][0]) * 1.2; // The width is given by the face width, based on the geometry<br/>    const wy = Math.abs(positions[7][1] - Math.min(positions[16][1], positions[20][1])) * 1.2; // The height is given by the distance from nose to chin, times 2<br/>    translate(-wx/2, -wy/2);<br/>    image(imgSpidermanMask, positions[62][0], positions[62][1], wx, wy); // Show the mask at the center of the face<br/>    pop();<br/>}</span></pre><p id="e946" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很酷吧？</p><p id="5263" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在狗过滤器以同样的方式工作，但是使用三张图片而不是一张，每只耳朵一张，鼻子一张。我不会用更多相同的代码来烦你，但是如果你想检查它，回顾一下<a class="ae ky" href="https://codepen.io/livecodestream/pen/rNxrMzp" rel="noopener ugc nofollow" target="_blank"> codepen </a>，它包含了演示的完整代码。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="d8ca" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">结论</h1><p id="04b0" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在 JavaScript 库的帮助下，识别面部特征并开始构建自己的过滤器是非常容易的。不过，还有一些我们在本教程中没有涉及到的注意事项。比如脸不直对着镜头会怎么样？我们如何扭曲我们的过滤器，使它们符合面部的曲率？或者，如果我想添加 3d 对象而不是 2d 滤镜，该怎么办？</p><p id="3012" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我知道你们中的很多人会用它来做一些很酷的东西，我很想听听你们做了什么，如果你们也能和我分享你们的例子。你可以在推特上找到我。</p><p id="7387" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>