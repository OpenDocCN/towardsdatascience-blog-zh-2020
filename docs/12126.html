<html>
<head>
<title>Data Structures in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中的数据结构</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/data-structures-in-python-da813beb2a0d?source=collection_archive---------17-----------------------#2020-08-21">https://towardsdatascience.com/data-structures-in-python-da813beb2a0d?source=collection_archive---------17-----------------------#2020-08-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/eb1f713f3833a0ed184f9216d475173c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*opY-Jox1pweFhjJD"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">丁满·克劳斯在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><div class=""/><div class=""><h2 id="c2d6" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">精通列表——Python 最通用的数据结构</h2></div><p id="913d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这篇文章是关于<strong class="la jk">列表</strong>的。它们是 Python 中最通用、最足智多谋的<strong class="la jk">内置数据结构</strong>。它们可以同时保存<strong class="la jk">异构数据</strong>，即整数、浮点、字符串、NaN、布尔、函数等。在同一个列表中。它们是条目的有序序列，这意味着在访问列表时元素的顺序是保持不变的。它们是<strong class="la jk">可变的</strong>，即你可以改变<strong class="la jk"> </strong>(添加、删除、修改)列表中的任何一项。它们可以有旧的重复项，不像“集合”Python 中的另一种数据结构。</p><p id="f59a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">读完这篇文章后，你将对 Python 列表有一个清晰的理解并有能力在<strong class="la jk">高级水平上工作。</strong></p><p id="e5a5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我将讨论以下主题:</p><ul class=""><li id="448a" class="lu lv jj la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated"><strong class="la jk">创建列表并添加元素</strong></li><li id="f4d2" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><strong class="la jk">访问列表元素</strong></li><li id="198d" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><strong class="la jk">删除列表元素</strong></li><li id="0cc4" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><strong class="la jk">插入元素</strong></li><li id="9d6f" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><strong class="la jk">列表运算</strong></li><li id="b0c7" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><strong class="la jk">反转列表</strong></li><li id="445f" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><strong class="la jk">排序列表</strong></li><li id="12e2" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><strong class="la jk">某项的索引</strong></li><li id="8408" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><strong class="la jk">盘点列表中的项目频率</strong></li><li id="ec58" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><strong class="la jk">列举理解</strong></li><li id="2401" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><strong class="la jk">复制列表</strong></li><li id="3786" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><strong class="la jk">嵌套列表</strong></li></ul></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="6a52" class="mp mq jj bd mr ms mt mu mv mw mx my mz kp na kq nb ks nc kt nd kv ne kw nf ng bi translated">1)创建列表并添加元素</h1><p id="5034" class="pw-post-body-paragraph ky kz jj la b lb nh kk ld le ni kn lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">首先，我们初始化一个名为“数据”的<strong class="la jk">空列表</strong>。该列表是使用方括号创建的。自然，空列表的长度为零。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="e162" class="nv mq jj nr b gy nw nx l ny nz">data = []</span><span id="c901" class="nv mq jj nr b gy oa nx l ny nz">len(data)<br/>&gt;&gt;&gt; 0</span><span id="5d33" class="nv mq jj nr b gy oa nx l ny nz"># Check the type of the variable 'data'<br/>type(data)<br/>&gt;&gt;&gt; list</span></pre><p id="150e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在让我们将第一个元素添加到这个列表中。这是使用<strong class="la jk"> append() </strong>函数完成的。你会注意到它的长度现在变成了 1。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="08f8" class="nv mq jj nr b gy nw nx l ny nz">data.append(100)</span><span id="a0b5" class="nv mq jj nr b gy oa nx l ny nz">data <br/>&gt;&gt;&gt; [100]</span><span id="ad43" class="nv mq jj nr b gy oa nx l ny nz">len(data)<br/>&gt;&gt;&gt; 1</span></pre><p id="4adb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们添加第二个元素。它将被附加(添加)在列表的末尾。同样，您可以添加任意多的元素。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="007f" class="nv mq jj nr b gy nw nx l ny nz">data.append(200)<br/>data<br/>&gt;&gt;&gt; [100, 200]</span><span id="8d6f" class="nv mq jj nr b gy oa nx l ny nz">len(data)<br/>&gt;&gt;&gt; 2</span><span id="d6b4" class="nv mq jj nr b gy oa nx l ny nz">data.append(300)<br/>data<br/>&gt;&gt;&gt; [100, 200, 300]</span></pre><p id="ba17" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当<strong class="la jk">您事先不知道</strong>列表中有多少元素时，<strong class="la jk">追加</strong>功能很有用。例如，要存储每小时进入商店的人数，需要追加每小时的顾客人数。但是，如果你只是主持了一次考试，你就知道到底有多少学生写了试卷。现在，如果你想在一个列表中存储他们的成绩，而不是追加，你可以初始化你的列表。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="b86f" class="nv mq jj nr b gy nw nx l ny nz">grades = [70, 100, 97, 67, 85]</span><span id="418c" class="nv mq jj nr b gy oa nx l ny nz">len(grades)<br/>&gt;&gt;&gt; 5</span></pre><p id="2eb3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">不用担心！</strong>您仍然可以使用 append 向已经初始化的列表中添加更多的元素。只需简单地使用<code class="fe ob oc od nr b">data.append(80)</code>来添加第六个学生的成绩，它将被附加在列表的末尾。</p><h2 id="819c" class="nv mq jj bd mr oe of dn mv og oh dp mz lh oi oj nb ll ok ol nd lp om on nf oo bi translated"><strong class="ak">如何一次性将两个或两个以上学生的分数相加？</strong></h2><p id="2da0" class="pw-post-body-paragraph ky kz jj la b lb nh kk ld le ni kn lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">假设你想同时追加三个学生的分数。您不能使用<strong class="la jk"> grades.append(99，100，95) </strong>，因为<strong class="la jk">“append”只接受一个参数</strong>。您将不得不使用“追加”功能三次。</p><p id="6efd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，您可以使用<strong class="la jk"> extend() </strong>而不是追加三次。您需要将这三个元素放在一个元组形式中(一个 iterable)。</p><p id="7eae" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意<strong class="la jk">不能使用 extend 来追加单个元素</strong>，即<code class="fe ob oc od nr b">data.extend((90))</code>不起作用。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="8645" class="nv mq jj nr b gy nw nx l ny nz">grades = [70, 100, 97, 67, 85]<br/>grades.extend((99, 100, 95))<br/>print (grades)<br/>&gt;&gt;&gt; [70, 100, 97, 67, 85, 99, 100, 95]</span></pre><h2 id="e7d4" class="nv mq jj bd mr oe of dn mv og oh dp mz lh oi oj nb ll ok ol nd lp om on nf oo bi translated"><strong class="ak">现在你会问，“为什么我们不能一次追加三个等级？”</strong></h2><p id="7f8c" class="pw-post-body-paragraph ky kz jj la b lb nh kk ld le ni kn lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">可以，<strong class="la jk">但是有一个条件</strong>。如下所示，一起插入的三个等级在主列表中显示为一个列表。这样的列表被称为<strong class="la jk">【嵌套列表】</strong>。我将在本文的最后一节展示更多的例子。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="25a0" class="nv mq jj nr b gy nw nx l ny nz">grades = [70, 100, 97, 67, 85]<br/>grades.append([99, 100, 95])<br/>print (grades)<br/>&gt;&gt;&gt; [70, 100, 97, 67, 85, [99, 100, 95]] # A nested list</span></pre></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="ceca" class="mp mq jj bd mr ms mt mu mv mw mx my mz kp na kq nb ks nc kt nd kv ne kw nf ng bi translated">2)访问列表元素</h1><p id="0c6e" class="pw-post-body-paragraph ky kz jj la b lb nh kk ld le ni kn lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">如果<em class="op"> </em>你正在处理数据结构，了解<strong class="la jk">索引</strong>的概念<strong class="la jk"> </strong>是非常有用的。你可以认为索引是分配给列表中每个元素的序列号。简单来说，就是类似于你在一个班级的点名。</p><blockquote class="oq"><p id="577e" class="or os jj bd ot ou ov ow ox oy oz lt dk translated"><em class="pa"/><strong class="ak"><em class="pa">最重要的</em> </strong> <em class="pa">要知道的是，Python 中的</em> <strong class="ak"> <em class="pa">索引是从 0 </em> </strong> <em class="pa">开始的。</em></p></blockquote><p id="3918" class="pw-post-body-paragraph ky kz jj la b lb pb kk ld le pc kn lg lh pd lj lk ll pe ln lo lp pf lr ls lt im bi translated">因此，第一个元素的索引为 0，第二个元素的索引为 1，依此类推。在五个元素的列表中，最后一个(第五个)元素的索引值为 4。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="c8cc" class="nv mq jj nr b gy nw nx l ny nz">grades = [70, 100, 97, 67, 85]</span><span id="8dee" class="nv mq jj nr b gy oa nx l ny nz"># First element (index 0)<br/>grades[0]<br/>&gt;&gt;&gt; 70</span><span id="130b" class="nv mq jj nr b gy oa nx l ny nz"># Second element (index 1)<br/>grades[1]<br/>&gt;&gt;&gt; 100</span><span id="5438" class="nv mq jj nr b gy oa nx l ny nz"># Last element (index 4)<br/>grades[4]<br/>&gt;&gt;&gt; 85</span></pre><p id="fe07" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不要越界。如果你试图使用一个大于列表长度的索引值，你将得到一个<strong class="la jk"> IndexError </strong>。因此，在一个包含 5 个元素的列表中，不能使用索引 5(因为它引用了第 6 个元素)。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="f446" class="nv mq jj nr b gy nw nx l ny nz">grades[5]<br/><strong class="nr jk">-----------------------------------------------------------------</strong><br/><strong class="nr jk">IndexError</strong> Traceback (most recent call last)<br/><strong class="nr jk">&lt;ipython-input-29-d8836f1h2p9&gt;</strong> in &lt;module&gt;<br/><strong class="nr jk">----&gt; 1 </strong>data<strong class="nr jk">[5]</strong></span><span id="9bf6" class="nv mq jj nr b gy oa nx l ny nz"><strong class="nr jk">IndexError</strong>: list index out of range</span></pre><h2 id="f6cd" class="nv mq jj bd mr oe of dn mv og oh dp mz lh oi oj nb ll ok ol nd lp om on nf oo bi translated">访问列表的多个元素</h2><p id="bfd5" class="pw-post-body-paragraph ky kz jj la b lb nh kk ld le ni kn lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">如果您想要前三个元素，您可以使用<strong class="la jk">切片</strong>来访问它们。一般格式是<code class="fe ob oc od nr b">list[start_index:end_index]</code>。这里比较棘手的部分<strong class="la jk"> </strong>是这个符号会返回值，直到<strong class="la jk"> end_index - 1 </strong>的索引值。这意味着，要获得索引为 0、1 和 2 的列表的前三个元素，需要以下方法。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="73cc" class="nv mq jj nr b gy nw nx l ny nz">grades = [70, 100, 97, 67, 85]<br/>grades[0:3]<br/>&gt;&gt;&gt; [70, 100, 97]</span></pre><p id="68bc" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您只想访问索引为 0 的第一个元素，可以使用切片符号来获取它。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="9905" class="nv mq jj nr b gy nw nx l ny nz">grades[0:1]<br/>&gt;&gt;&gt; [70]</span></pre><h2 id="92d1" class="nv mq jj bd mr oe of dn mv og oh dp mz lh oi oj nb ll ok ol nd lp om on nf oo bi translated">反向索引</h2><p id="7d7a" class="pw-post-body-paragraph ky kz jj la b lb nh kk ld le ni kn lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">现在你也应该知道我称之为<strong class="la jk">【反向索引】</strong>或<strong class="la jk">【负索引】</strong>的有用概念。</p><p id="52e6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要访问最后一个元素，首先需要知道列表的长度。因此，在 5 个元素的列表中，需要使用索引 4(= 5–1，因为索引从 0 开始)。因此，数据[4]将是您的最后一个元素。类似地，倒数第二个元素将是 data[3]，依此类推。</p><p id="abdd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如您所见，这种计算很麻烦。负指数将在这里帮助你。<strong class="la jk"> </strong>简单来说就是<strong class="la jk"> </strong>从末尾开始数元素个数。最后一个元素不能在索引-0 处，因为没有这样的数字。因此，您需要使用索引值-1 来访问它。类似地，倒数第二个元素可以使用索引值-2 来访问，依此类推。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="bd7d" class="nv mq jj nr b gy nw nx l ny nz">grades = [70, 100, 97, 67, 85]<br/>grades[-1]<br/>&gt;&gt;&gt; 85</span><span id="332a" class="nv mq jj nr b gy oa nx l ny nz">grades[-2]<br/>&gt;&gt;&gt; 67</span></pre><h2 id="4f67" class="nv mq jj bd mr oe of dn mv og oh dp mz lh oi oj nb ll ok ol nd lp om on nf oo bi translated">"负索引可以用来访问最后 3 个元素吗？"。</h2><p id="27cc" class="pw-post-body-paragraph ky kz jj la b lb nh kk ld le ni kn lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">是的。您需要指定起始负索引。要获取从倒数第三个元素开始的所有元素，不需要指定结束索引。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="d5cb" class="nv mq jj nr b gy nw nx l ny nz">grades = [70, 100, 97, 67, 85]<br/>grades[-3:]<br/>&gt;&gt;&gt; [97, 67, 85]</span></pre><p id="2fac" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，假设您想要获取倒数第三个和倒数第二个元素，而不是最后一个元素。您可以将结束索引限制为:</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="44d2" class="nv mq jj nr b gy nw nx l ny nz">grades[-3:-1]<br/>&gt;&gt;&gt; [97, 67]</span></pre><h2 id="a782" class="nv mq jj bd mr oe of dn mv og oh dp mz lh oi oj nb ll ok ol nd lp om on nf oo bi translated">2.1)定期访问元素</h2><p id="d54f" class="pw-post-body-paragraph ky kz jj la b lb nh kk ld le ni kn lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">到目前为止，您已经学习了如何访问单个元素或几个连续的元素。假设你想从列表中得到第 n 个项目。这样做的一般语法是<code class="fe ob oc od nr b">list[start_index : stop_index : step]</code>。</p><p id="453b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">举例:</strong>如果你想从第一个元素开始到第七个元素，即从[1，2，3，4，5，6，7]开始，每隔一个元素访问一次，你需要[1，3，5，7]。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="aa39" class="nv mq jj nr b gy nw nx l ny nz">data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]<br/>data[0:7:2]<br/>&gt;&gt;&gt; [1, 3, 5, 7]</span></pre><p id="72fe" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你想要从第一个元素开始的整个列表中的第二个元素，你可以跳过<code class="fe ob oc od nr b">start_index</code>和<code class="fe ob oc od nr b">stop_index</code>。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="7651" class="nv mq jj nr b gy nw nx l ny nz">data[::2]<br/>&gt;&gt;&gt; [1, 3, 5, 7, 9]</span></pre><p id="9dc0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您想要从第二个元素开始的整个列表中的每第二个元素，使用下面的代码。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="a405" class="nv mq jj nr b gy nw nx l ny nz">data[1::2]<br/>&gt;&gt;&gt; [2, 4, 6, 8, 10]</span></pre><p id="cef8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">注意:</strong>你也可以使用<code class="fe ob oc od nr b">data[::1]</code>来访问整个列表，因为这将返回从开始到结束的所有元素。</p><p id="3272" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">以固定的间隔向后遍历一个列表<br/> </strong>你需要使用一个负的步长值。要获取从末尾开始的每个元素，即整个列表的逆序，请使用下面的代码。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="a9ab" class="nv mq jj nr b gy nw nx l ny nz">data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]<br/>data[::-1]<br/>&gt;&gt;&gt; [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]</span></pre><p id="2b92" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">若要从最后一个元素开始每隔一个元素访问一次，请使用以下代码。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="5328" class="nv mq jj nr b gy nw nx l ny nz">data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]<br/>data[::-2]<br/>&gt;&gt;&gt; [10, 8, 6, 4, 2]</span></pre><p id="4d2c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看一个更复杂的反向遍历例子。假设<strong class="la jk"> </strong>你想从倒数第三个元素开始，一直到第四个元素，每隔一个元素选择一个。您的开始索引现在变为-3，停止索引变为 3(第四个元素的索引从 0 开始)。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="fe9d" class="nv mq jj nr b gy nw nx l ny nz">data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]<br/>data[-3:3:-2]<br/>&gt;&gt;&gt; [8, 6]</span></pre></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="dcc0" class="mp mq jj bd mr ms mt mu mv mw mx my mz kp na kq nb ks nc kt nd kv ne kw nf ng bi translated">3)删除列表元素</h1><p id="6f1f" class="pw-post-body-paragraph ky kz jj la b lb nh kk ld le ni kn lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">有三种方法可以从列表中删除元素。这三种方法都执行就地删除，也就是说，在删除之后，您不需要将列表重新分配给新的变量。</p><p id="3aaa" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">a) <code class="fe ob oc od nr b">del</code>(内置函数)<strong class="la jk">能否一次删除多个项目</strong><br/>b)<code class="fe ob oc od nr b">remove()</code>(列表的方法)<strong class="la jk">能否一次删除一个项目</strong><br/>c)<code class="fe ob oc od nr b">pop()</code>(列表的方法)<strong class="la jk">能否一次删除一个项目</strong></p><p id="5611" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们逐一研究它们。</p><h2 id="ae08" class="nv mq jj bd mr oe of dn mv og oh dp mz lh oi oj nb ll ok ol nd lp om on nf oo bi translated">a)德尔</h2><p id="1044" class="pw-post-body-paragraph ky kz jj la b lb nh kk ld le ni kn lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">使用<code class="fe ob oc od nr b">del</code>时，需要传递要删除的元素的索引或一部分索引。您可以使用上面介绍的所有索引/切片概念，通过<strong class="la jk"> del </strong>删除元素。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="698f" class="nv mq jj nr b gy nw nx l ny nz"># Deleting first element<br/>data = [79, 65, 100, 85, 94]<br/>del data[0]<br/>print (data)<br/>&gt;&gt;&gt; [65, 100, 85, 94] </span><span id="e92c" class="nv mq jj nr b gy oa nx l ny nz">#############################################################</span><span id="1c8a" class="nv mq jj nr b gy oa nx l ny nz"># Deleting second last element<br/>data = [79, 65, 100, 85, 94]<br/>del data[-2]<br/>print (data)<br/>&gt;&gt;&gt; [79, 65, 100, 94]</span><span id="2753" class="nv mq jj nr b gy oa nx l ny nz">############################################################# </span><span id="94e2" class="nv mq jj nr b gy oa nx l ny nz"># Deleting multiple consecutive elements using slice<br/>data = [79, 65, 100, 85, 94]<br/>del data[0:3]<br/>print (data)<br/>&gt;&gt;&gt; [85, 94]</span><span id="1f4c" class="nv mq jj nr b gy oa nx l ny nz">############################################################## </span><span id="3d80" class="nv mq jj nr b gy oa nx l ny nz"># Deleting multiple elements at regular interval using slice<br/>data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]<br/>del data[1::2]<br/>data<br/># [1, 3, 5, 7, 9]</span></pre><h2 id="620a" class="nv mq jj bd mr oe of dn mv og oh dp mz lh oi oj nb ll ok ol nd lp om on nf oo bi translated">b)移除()</h2><p id="c12c" class="pw-post-body-paragraph ky kz jj la b lb nh kk ld le ni kn lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">这个方法用于<strong class="la jk">从列表中删除一个特定的元素</strong>。如果一个元素出现不止一次，那么<strong class="la jk">只有第一次出现的元素</strong>会被删除。例如，在下面的列表中，1 出现了 3 次。所以使用<code class="fe ob oc od nr b">remove(1)</code>将删除第一个值，保留其余的值。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="dc77" class="nv mq jj nr b gy nw nx l ny nz">data = [1, 1, 4, 4, 3, 1, 3, 2, 4, 2]<br/>data.remove(1)<br/>print (data)<br/>&gt;&gt;&gt; [1, 4, 4, 3, 1, 3, 2, 4, 2]</span></pre><p id="591e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">奖励:</strong>你可以使用一个<strong class="la jk"> while 循环</strong>来移除所有出现的 1。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="2c8e" class="nv mq jj nr b gy nw nx l ny nz">data = [1, 1, 4, 4, 3, 1, 3, 2, 4, 2]<br/>to_del = 1</span><span id="3eb5" class="nv mq jj nr b gy oa nx l ny nz">while to_del in data:<br/>    data.remove(to_del)<br/>    <br/>print (data)<br/>&gt;&gt;&gt; [4, 4, 3, 3, 2, 4, 2]</span></pre><h2 id="4f2e" class="nv mq jj bd mr oe of dn mv og oh dp mz lh oi oj nb ll ok ol nd lp om on nf oo bi translated">c) pop()</h2><p id="1d3c" class="pw-post-body-paragraph ky kz jj la b lb nh kk ld le ni kn lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">这个方法的语法是<code class="fe ob oc od nr b">list.pop(i)</code>，它从列表中弹出(删除)索引‘I’<strong class="la jk"/>处的元素。下面的代码演示了它在连续应用于一个列表时是如何工作的。</p><p id="ee6e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">注意:</strong>如果不指定索引，最后一个元素将被删除。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="5f2b" class="nv mq jj nr b gy nw nx l ny nz"># Using pop(i) by specifying the index i<br/>data = [1, 2, 3, 4, 5]<br/>data.pop(0)<br/>print (data)<br/>&gt;&gt;&gt; [2, 3, 4, 5]</span><span id="0d4a" class="nv mq jj nr b gy oa nx l ny nz">data.pop(1)<br/>print (data)<br/>&gt;&gt;&gt; [2, 4, 5]</span><span id="49bb" class="nv mq jj nr b gy oa nx l ny nz">data.pop(1)<br/>print (data)<br/>&gt;&gt;&gt; [2, 5]</span><span id="5cd4" class="nv mq jj nr b gy oa nx l ny nz">#############################################################</span><span id="8832" class="nv mq jj nr b gy oa nx l ny nz"># Using pop() without specifying the index i<br/>data = [1, 2, 3, 4, 5]<br/>data.pop()<br/>print (data)<br/>&gt;&gt;&gt; [1, 2, 3, 4]</span><span id="d9b4" class="nv mq jj nr b gy oa nx l ny nz">data.pop()<br/>print (data)<br/>&gt;&gt;&gt; [1, 2, 3]</span></pre></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="8f70" class="mp mq jj bd mr ms mt mu mv mw mx my mz kp na kq nb ks nc kt nd kv ne kw nf ng bi translated">4)插入元素</h1><p id="3502" class="pw-post-body-paragraph ky kz jj la b lb nh kk ld le ni kn lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">可以使用功能<code class="fe ob oc od nr b">list.insert(i, element)</code>在指定位置插入一个元素。这里的‘I’是列表中要插入<code class="fe ob oc od nr b">element</code>的现有元素的索引。正如您之前看到的，<code class="fe ob oc od nr b">append()</code>函数将元素插入到列表的末尾。</p><p id="193d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">注意:</strong>这是一个<strong class="la jk">就地操作</strong>，所以你不必重新分配列表。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="6931" class="nv mq jj nr b gy nw nx l ny nz"># Inserting value of 4 at the start, before the element at index 0<br/>data = [1, 2, 3]<br/>data.insert(0, 4) <br/>print (data)<br/>&gt;&gt;&gt; [4, 1, 2, 3]</span><span id="3e14" class="nv mq jj nr b gy oa nx l ny nz">#############################################################</span><span id="6b5e" class="nv mq jj nr b gy oa nx l ny nz"># Inserting value of 4 before the element at index 1<br/>data = [1, 2, 3]<br/>data.insert(1, 4)<br/>print (data)<br/>&gt;&gt;&gt; [1, 4, 2, 3]</span></pre><p id="a1c8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你想在列表的末尾插入，也就是说，追加，那么简单地使用列表的长度作为插入的位置。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="c92e" class="nv mq jj nr b gy nw nx l ny nz">data = [1, 2, 3]<br/>data.insert(len(data), 4)<br/>print (data)<br/>&gt;&gt;&gt; [1, 2, 3, 4]</span></pre></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="d219" class="mp mq jj bd mr ms mt mu mv mw mx my mz kp na kq nb ks nc kt nd kv ne kw nf ng bi translated">5)列表算法</h1><p id="f905" class="pw-post-body-paragraph ky kz jj la b lb nh kk ld le ni kn lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">当您添加两个或更多列表时会发生什么？假设您有以下两个列表。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="76a3" class="nv mq jj nr b gy nw nx l ny nz">list_A = [1, 2, 3, 4, 5]<br/>list_B = [6, 7, 8, 9, 10]</span></pre><p id="e6be" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您添加它们，您会期望两个列表的元素相加。但是，您将得到一个列表，其中两个列表的元素按照相加的顺序被附加(连接)在一起。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="dba8" class="nv mq jj nr b gy nw nx l ny nz">list_A + list_B <br/>&gt;&gt;&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></pre><p id="db66" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">顺序很重要。对于列表来说，A + B 不等于 B+A<strong class="la jk"/>所以，如果颠倒加法的顺序，就会得到不同的结果。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="808e" class="nv mq jj nr b gy nw nx l ny nz">list_B + list_A<br/>&gt;&gt;&gt; [6, 7, 8, 9, 10, 1, 2, 3, 4, 5]</span></pre><h2 id="db18" class="nv mq jj bd mr oe of dn mv og oh dp mz lh oi oj nb ll ok ol nd lp om on nf oo bi translated">你能做两个列表的减法、乘法或除法吗？</h2><p id="2a53" class="pw-post-body-paragraph ky kz jj la b lb nh kk ld le ni kn lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">不，你不能。举个例子，如果你试着把上面两个列表相减，你会得到一个<code class="fe ob oc od nr b">TypeError</code>。类似地，乘法或除法也会抛出错误。尝试一下说服自己。</p><p id="95b1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你将列表乘以一个大于 0 的正整数，你的列表将重复(复制)那么多次。例如，将列表乘以 3 会将列表重复 3 次。乘以浮点数(3.0)会产生错误。将列表乘以 0 或负整数产生一个空列表<strong class="la jk">。</strong></p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="7c0f" class="nv mq jj nr b gy nw nx l ny nz"># Multiplication by positive integer<br/>data = [1, 2, 3]<br/>data * 3 # equivalent to data + data + data<br/>&gt;&gt;&gt; [1, 2, 3, 1, 2, 3, 1, 2, 3]</span><span id="120e" class="nv mq jj nr b gy oa nx l ny nz"># Multiplication by 0<br/>data * 0<br/>&gt;&gt;&gt; []</span></pre><p id="ed2c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">注意:</strong>如果您试图乘以[3]而不是 3，将会报告错误。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="9542" class="mp mq jj bd mr ms mt mu mv mw mx my mz kp na kq nb ks nc kt nd kv ne kw nf ng bi translated">6)反转列表</h1><p id="3283" class="pw-post-body-paragraph ky kz jj la b lb nh kk ld le ni kn lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">有两种方法可以反转列表。</p><p id="3ccb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">a)使用<strong class="la jk">切片</strong>作为[::-1]。这不会就地更改列表。您必须重新分配列表，以反映原始列表中的更改。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="b3be" class="nv mq jj nr b gy nw nx l ny nz">data = [1, 2, 3]<br/>data[::-1]<br/>&gt;&gt;&gt; [3, 2, 1]</span><span id="b589" class="nv mq jj nr b gy oa nx l ny nz">print (data)<br/>&gt;&gt;&gt; [1, 2, 3] # The original list does not change</span><span id="cad2" class="nv mq jj nr b gy oa nx l ny nz"># You have to re-assign the list after reversing<br/>data = [1, 2, 3]<br/>data = data[::-1] # Re-assign print (data)<br/>&gt;&gt;&gt; [3, 2, 1]</span></pre><p id="540f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">b)使用<code class="fe ob oc od nr b"><strong class="la jk">list.reverse()</strong></code> <strong class="la jk"> </strong>功能。在这里，您不需要重新分配，因为列表是就地反转的。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="06d4" class="nv mq jj nr b gy nw nx l ny nz">data = [1, 2, 3]<br/>data.reverse() # reverses the list in-place print (data)<br/>&gt;&gt;&gt; [3, 2, 1] # The original list does not change</span></pre></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="1aeb" class="mp mq jj bd mr ms mt mu mv mw mx my mz kp na kq nb ks nc kt nd kv ne kw nf ng bi translated">7)对列表进行排序</h1><p id="62c7" class="pw-post-body-paragraph ky kz jj la b lb nh kk ld le ni kn lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">对列表进行排序有两种直接的方法。</p><p id="45b0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">a)使用<code class="fe ob oc od nr b"><strong class="la jk">sorted()</strong></code> <strong class="la jk"> </strong>功能。这不会对列表进行就地排序。<br/> b)使用<code class="fe ob oc od nr b"><strong class="la jk">list.sort()</strong></code> <strong class="la jk"> </strong>功能。<strong class="la jk"> </strong>执行就地排序。</p><p id="dce9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这两个函数中，您可以使用关键字“reverse”选择升序或降序排序。如果“reverse=True”，则列表按降序排序。默认情况下，列表按升序排序。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="e024" class="nv mq jj nr b gy nw nx l ny nz"># First method using sorted()<br/>data = [7, 4, 1, 3, 8, 5, 9, 6, 2]<br/>sorted(data, reverse=False) # Same as sorted(data) due to default<br/>&gt;&gt;&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9]</span><span id="0c19" class="nv mq jj nr b gy oa nx l ny nz">#############################################################</span><span id="4cf5" class="nv mq jj nr b gy oa nx l ny nz"># Second method using list.sort()<br/>data = [7, 4, 1, 3, 8, 5, 9, 6, 2]<br/>data.sort(reverse=True)<br/>print (data)<br/>&gt;&gt;&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9]</span></pre><h2 id="324a" class="nv mq jj bd mr oe of dn mv og oh dp mz lh oi oj nb ll ok ol nd lp om on nf oo bi translated"><strong class="ak">字符串是如何排序的？</strong></h2><ul class=""><li id="600c" class="lu lv jj la b lb nh le ni lh pg ll ph lp pi lt lz ma mb mc bi translated">默认情况下，不同长度的字符串将按字母顺序排序。</li><li id="1a84" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">如果字符串的起始字母相同，但大小写不同，则大写字母优先。</li><li id="ac49" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">如果两个或两个以上的字符串具有相同的大小写首字母，它们将根据第二个字母<strong class="la jk"> </strong>按字母顺序排序，依此类推。</li></ul><p id="5de7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看一些使用第二种方法的字符串示例。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="9170" class="nv mq jj nr b gy nw nx l ny nz">data = ['pineapple', 'kiwi', 'apple', 'azure', 'Apricot', 'mango']<br/>data.sort() # in-place sorting<br/>print (data)<br/>&gt;&gt;&gt; ['Apricot', 'apple', 'azure', 'kiwi', 'mango', 'pineapple']</span><span id="a84a" class="nv mq jj nr b gy oa nx l ny nz">#############################################################</span><span id="02ed" class="nv mq jj nr b gy oa nx l ny nz">data = ['pineapple', 'kiwi', 'apple', 'Apricot', 'mango']<br/>data.sort(reverse=True)<br/>print (data)<br/>&gt;&gt;&gt; ['pineapple', 'mango', 'kiwi', 'apple', 'Apricot']</span></pre><h2 id="f47d" class="nv mq jj bd mr oe of dn mv og oh dp mz lh oi oj nb ll ok ol nd lp om on nf oo bi translated"><strong class="ak">如何根据字符串的长度进行排序？</strong></h2><p id="7a4b" class="pw-post-body-paragraph ky kz jj la b lb nh kk ld le ni kn lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">你需要使用关键字<code class="fe ob oc od nr b">key=len</code>。如果你想要长度降序排列，使用一个额外的关键字<code class="fe ob oc od nr b">reverse=True</code>。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="1593" class="nv mq jj nr b gy nw nx l ny nz">data = ['pineapple', 'kiwi', 'apple', 'Apricot', 'orange', 'mango']<br/>data.sort(key=len, reverse=True)<br/>print (data)<br/>&gt;&gt;&gt; ['pineapple', 'Apricot', 'orange', 'apple', 'mango', 'kiwi']</span></pre></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="fb4c" class="mp mq jj bd mr ms mt mu mv mw mx my mz kp na kq nb ks nc kt nd kv ne kw nf ng bi translated">8)项目的索引</h1><p id="5895" class="pw-post-body-paragraph ky kz jj la b lb nh kk ld le ni kn lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">如果您想获得给定列表中某个条目的索引，可以使用命令<code class="fe ob oc od nr b">list.index(item)</code>来实现。它在整个列表中搜索项目。如果同一个项目出现多次，您将只获得它第一次出现的索引。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="18eb" class="nv mq jj nr b gy nw nx l ny nz">grades = [70, 100, 97, 70, 85]<br/>grades.index(100)<br/>&gt;&gt;&gt; 7</span><span id="b7b6" class="nv mq jj nr b gy oa nx l ny nz">grades.index(70) # 70 appears twice at indices 0 and 3<br/>&gt;&gt;&gt; 0            # Only the first index returns</span></pre><p id="f97a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设您的列表非常大，并且您希望只在列表的特定子集中搜索一个元素。您可以为子集指定“开始”和“结束”索引。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="4f10" class="nv mq jj nr b gy nw nx l ny nz">grades = [70, 100, 97, 70, 85, 100, 400, 200, 32] </span><span id="7b23" class="nv mq jj nr b gy oa nx l ny nz"># Search in the whole list<br/>grades.index(100)<br/>&gt;&gt;&gt; 7</span><span id="0a70" class="nv mq jj nr b gy oa nx l ny nz"># Search in the partial list from index 3 until index 8</span><span id="b1bb" class="nv mq jj nr b gy oa nx l ny nz">grades.index(100, 3, 8)<br/>&gt;&gt;&gt; 5  # Now the index of the second 100 is returned</span></pre></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="3598" class="mp mq jj bd mr ms mt mu mv mw mx my mz kp na kq nb ks nc kt nd kv ne kw nf ng bi translated">9)统计列表中的项目频率</h1><p id="1f47" class="pw-post-body-paragraph ky kz jj la b lb nh kk ld le ni kn lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">您可以使用<code class="fe ob oc od nr b">list.count(item)</code>统计列表中给定项目的出现频率。让我们考虑下面的例子。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="b4b9" class="nv mq jj nr b gy nw nx l ny nz">data = [6, 4, 1, 4, 4, 3, 4, 8, 5, 4, 6, 2, 6]<br/>data.count(4)<br/>&gt;&gt;&gt; 5</span></pre><h2 id="7038" class="nv mq jj bd mr oe of dn mv og oh dp mz lh oi oj nb ll ok ol nd lp om on nf oo bi translated"><strong class="ak">功能使用示例</strong>T2】</h2><p id="ea82" class="pw-post-body-paragraph ky kz jj la b lb nh kk ld le ni kn lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">假设您想要计算并打印所有元素的频率。为此，我们首先需要列表中的唯一项目。我会用 NumPy 的<code class="fe ob oc od nr b">unique()</code>。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="4b8e" class="nv mq jj nr b gy nw nx l ny nz">import numpy as np</span><span id="0ed5" class="nv mq jj nr b gy oa nx l ny nz">data = [1, 1, 4, 4, 3, 1, 3, 2, 4, 2]</span><span id="7ddf" class="nv mq jj nr b gy oa nx l ny nz">for item in np.unique(data):<br/>    print("{} occurs {} times in the list"\<br/>           .format(item, data.count(item)))</span><span id="53ac" class="nv mq jj nr b gy oa nx l ny nz">&gt;&gt;&gt; 1 occurs 3 times in the list<br/>&gt;&gt;&gt; 2 occurs 2 times in the list<br/>&gt;&gt;&gt; 3 occurs 2 times in the list<br/>&gt;&gt;&gt; 4 occurs 3 times in the list</span></pre></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="1c0a" class="mp mq jj bd mr ms mt mu mv mw mx my mz kp na kq nb ks nc kt nd kv ne kw nf ng bi translated">10)列出理解</h1><p id="38d4" class="pw-post-body-paragraph ky kz jj la b lb nh kk ld le ni kn lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">假设您想计算从 0 到 5 的数字的立方，并将它们存储在一个列表中。首先需要初始化一个空列表，创建一个 for 循环，然后将各个数字的立方体追加到这个列表中。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="1237" class="nv mq jj nr b gy nw nx l ny nz">cubes = []<br/>for i in range(6):<br/>    cubes.append(i**3)<br/>    <br/>print (cubes)<br/>&gt;&gt;&gt; [0, 1, 8, 27, 64, 125]</span></pre><p id="f85f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面的代码对于这么简单的任务来说太多了吧？嗯，你可以简单地使用【列表理解】<strong class="la jk"> </strong>如下所示。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="8542" class="nv mq jj nr b gy nw nx l ny nz">cubes = [i**3 for i in range(6)]<br/>print (cubes)<br/>&gt;&gt;&gt; [0, 1, 8, 27, 64, 125]</span></pre></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="39cd" class="mp mq jj bd mr ms mt mu mv mw mx my mz kp na kq nb ks nc kt nd kv ne kw nf ng bi translated">11)复制列表</h1><p id="4f3a" class="pw-post-body-paragraph ky kz jj la b lb nh kk ld le ni kn lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">假设你有一个名为‘list _ A’的列表，你把这个列表分配给另一个名为‘list _ B’的列表。如果您从“list_A”中删除一个元素，您会期望“list_B”不会改变。下面的代码表明事实并非如此。从“list_A”中删除元素也会将其从“list_B”中删除。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="1f45" class="nv mq jj nr b gy nw nx l ny nz">list_A = [1, 2, 3, 4, 5]<br/>list_B = list_A</span><span id="0d13" class="nv mq jj nr b gy oa nx l ny nz">del list_A[0] # Delete an element from list_A</span><span id="e169" class="nv mq jj nr b gy oa nx l ny nz">print (list_A, list_B)<br/># [2, 3, 4, 5] [2, 3, 4, 5]</span></pre><h2 id="3dee" class="nv mq jj bd mr oe of dn mv og oh dp mz lh oi oj nb ll ok ol nd lp om on nf oo bi translated"><strong class="ak">为什么 list_B 会受到影响？</strong></h2><p id="48f0" class="pw-post-body-paragraph ky kz jj la b lb nh kk ld le ni kn lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">这是因为当你写<code class="fe ob oc od nr b">list_A = list_B</code>的时候，你创建了一个对‘列表 _ A’的引用。因此,‘list _ A’中的变化也会反映到‘list _ B’中的<strong class="la jk"> </strong>。</p><h2 id="c098" class="nv mq jj bd mr oe of dn mv og oh dp mz lh oi oj nb ll ok ol nd lp om on nf oo bi translated"><strong class="ak">如何避免 list_B 的变化？</strong></h2><p id="210f" class="pw-post-body-paragraph ky kz jj la b lb nh kk ld le ni kn lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">答案是创建一个浅拷贝。我将解释做这件事的两种方法。</p><p id="efe5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">a)使用<code class="fe ob oc od nr b">list.copy()<br/></code> b)使用<code class="fe ob oc od nr b">list[:]</code></p><p id="af26" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面的例子表明，现在从‘list _ A’中删除一个元素并不影响浅层拷贝，即‘list _ B’。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="4b88" class="nv mq jj nr b gy nw nx l ny nz"># First method using list.copy()<br/>list_A = [1, 2, 3, 4, 5]<br/>list_B = list_A.copy()</span><span id="eafc" class="nv mq jj nr b gy oa nx l ny nz">del list_A[0] # Delete an element from list_A<br/>print (list_A, list_B)<br/># [2, 3, 4, 5] [1, 2, 3, 4, 5]</span><span id="3f7f" class="nv mq jj nr b gy oa nx l ny nz">#############################################################<br/># Second method using list[:]<br/>list_A = [1, 2, 3, 4, 5]<br/>list_B = list_A[:]</span><span id="17b7" class="nv mq jj nr b gy oa nx l ny nz">del list_A[0] # Delete an element from list_A<br/>print (list_A, list_B)<br/># [2, 3, 4, 5] [1, 2, 3, 4, 5]</span></pre></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="e3fd" class="mp mq jj bd mr ms mt mu mv mw mx my mz kp na kq nb ks nc kt nd kv ne kw nf ng bi translated">12)嵌套列表</h1><p id="abd0" class="pw-post-body-paragraph ky kz jj la b lb nh kk ld le ni kn lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">包含另一个子列表作为元素的列表称为<strong class="la jk">嵌套列表</strong>。元素子列表可以包含更多的子列表。子列表中的元素也可以使用索引和切片来访问。让我们考虑下面的例子。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="3ed0" class="nv mq jj nr b gy nw nx l ny nz">data = [1, 2, 3, [4, 5, 6]]</span><span id="1c00" class="nv mq jj nr b gy oa nx l ny nz">data[2]   # Single element<br/>&gt;&gt;&gt; 3     </span><span id="2c7e" class="nv mq jj nr b gy oa nx l ny nz">data[3]   # Sublist<br/>&gt;&gt;&gt; [4, 5, 6]</span></pre><p id="88ae" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在的问题是，“如何访问子列表的元素？”。您可以使用双重索引来访问它们。例如，data[3]返回子列表。所以这个子列表的第一个元素可以使用 data[3][0]来访问。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="7cf6" class="nv mq jj nr b gy nw nx l ny nz">data[3][0]<br/>&gt;&gt;&gt; 4</span><span id="bed9" class="nv mq jj nr b gy oa nx l ny nz">data[3][1]<br/>&gt;&gt;&gt; 5</span><span id="60b0" class="nv mq jj nr b gy oa nx l ny nz">data[3][2]<br/>&gt;&gt;&gt; 6</span></pre><p id="d0aa" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在考虑下面的<strong class="la jk">列表，它在子列表</strong>中有一个子列表。列表的长度是 4，其中前 3 个元素是 1、2 和 3，最后一个元素是[4、5、6、[7、8、9]]。最后一个元素的长度是 4，它是一个子列表。这样，你就可以越来越深入到嵌套列表中。</p><p id="0282" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要访问子列表的元素，您需要使用<strong class="la jk">双索引、三索引</strong>等。如下例所示。</p><pre class="nm nn no np gt nq nr ns nt aw nu bi"><span id="b469" class="nv mq jj nr b gy nw nx l ny nz">data = [1, 2, 3, [4, 5, 6, [7, 8, 9]]] # A nested list</span><span id="5878" class="nv mq jj nr b gy oa nx l ny nz"># Length of the list<br/>len(data)<br/>&gt;&gt;&gt; 4</span><span id="ce6d" class="nv mq jj nr b gy oa nx l ny nz"># The last element<br/>data[3]<br/>&gt;&gt;&gt; [4, 5, 6, [7, 8, 9]]</span><span id="f727" class="nv mq jj nr b gy oa nx l ny nz"># Length of the last element<br/>len(data[3])<br/>&gt;&gt;&gt; 4</span><span id="ce16" class="nv mq jj nr b gy oa nx l ny nz">#############################################################<br/># Accessing the elements of the first sublist<br/>data[3][1]     # Double indices<br/>&gt;&gt;&gt; 5</span><span id="696a" class="nv mq jj nr b gy oa nx l ny nz">data[3][3]     # Double indices<br/>&gt;&gt;&gt; [7, 8, 9]</span><span id="9952" class="nv mq jj nr b gy oa nx l ny nz">#############################################################<br/># Accessing the elements of the second sublist<br/>data[3][3][0]  # Triple indices <br/>&gt;&gt;&gt; 7</span><span id="5ba8" class="nv mq jj nr b gy oa nx l ny nz">data[3][3][-1] # Triple indices<br/>&gt;&gt;&gt; 9</span></pre></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><p id="9f3a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这让我想到了这篇文章的结尾。我介绍了与列表相关的大部分操作，现在读者应该对 Python 中的列表有了进一步的了解。如果你有兴趣了解即将到来的 Python 3.10 版本和<strong class="la jk"> Matplotlib 3.0 </strong>中的<strong class="la jk">新特性，请参考以下帖子。</strong></p><div class="is it gp gr iu pj"><a rel="noopener follow" target="_blank" href="/python-in-2021-timeline-and-upcoming-features-c8369abbcc52"><div class="pk ab fo"><div class="pl ab pm cl cj pn"><h2 class="bd jk gy z fp po fr fs pp fu fw ji bi translated">2021 年的 Python 时间表和即将推出的功能</h2><div class="pq l"><h3 class="bd b gy z fp po fr fs pp fu fw dk translated">Python 3.10 的一些新特性的预览</h3></div><div class="pr l"><p class="bd b dl z fp po fr fs pp fu fw dk translated">towardsdatascience.com</p></div></div><div class="ps l"><div class="pt l pu pv pw ps px ja pj"/></div></div></a></div><div class="is it gp gr iu pj"><a rel="noopener follow" target="_blank" href="/whats-new-in-matplotlib-3-1b3b03f18ddc"><div class="pk ab fo"><div class="pl ab pm cl cj pn"><h2 class="bd jk gy z fp po fr fs pp fu fw ji bi translated">Matplotlib 3 的新特性</h2><div class="pq l"><h3 class="bd b gy z fp po fr fs pp fu fw dk translated">第 3 代中最重要的更新概述</h3></div><div class="pr l"><p class="bd b dl z fp po fr fs pp fu fw dk translated">towardsdatascience.com</p></div></div><div class="ps l"><div class="py l pu pv pw ps px ja pj"/></div></div></a></div></div></div>    
</body>
</html>