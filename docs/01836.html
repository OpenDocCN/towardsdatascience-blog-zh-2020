<html>
<head>
<title>Preview of the Neo4j Graph Data Science plugin with examples from the “Graph Algorithms: Practical Examples in Apache Spark and Neo4j” book</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Neo4j 图形数据科学插件的预览，包含“图形算法:Apache Spark 和 Neo4j 中的实用示例”一书中的示例</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/introducing-the-neo4j-graph-data-science-plugin-with-examples-from-the-graph-algorithms-19b831f66f2?source=collection_archive---------13-----------------------#2020-02-20">https://towardsdatascience.com/introducing-the-neo4j-graph-data-science-plugin-with-examples-from-the-graph-algorithms-19b831f66f2?source=collection_archive---------13-----------------------#2020-02-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="0b93" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在过去的几年里，数据科学领域获得了很大的发展。它已经成为商业和学术研究的重要组成部分。结合日益流行的图形和图形数据库，<a class="ae kl" href="https://neo4j.com/" rel="noopener ugc nofollow" target="_blank"> Neo4j </a>的人们决定发布<a class="ae kl" href="https://github.com/neo4j/graph-data-science" rel="noopener ugc nofollow" target="_blank">图形数据科学</a> (GDS)插件。它是<a class="ae kl" href="https://github.com/neo4j-contrib/neo4j-graph-algorithms" rel="noopener ugc nofollow" target="_blank">图形算法</a>插件的继承者，即将被弃用。然而，这仍然是 GDS 的预览版，正式发布将在未来几周内进行。</p><p id="5acc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那些熟悉图形算法插件的人会注意到，为了更平滑的过渡，语法没有太大的变化。为了展示所发生的变化，我准备了迁移指南，形式为<a class="ae kl" href="https://zeppelin.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache Zeppelin </a>笔记本，可以在<a class="ae kl" href="https://github.com/tomasonjo/zeppelin-graph-algo" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p><p id="9630" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Apache Zeppelin 的 Neo4j 连接器由 Andrea Santurbano 开发，他还设计了这个项目的漂亮主页笔记本，并帮助他出主意。在迁移指南中，我们使用了来自<a class="ae kl" href="https://neo4j.com/graph-algorithms-book/" rel="noopener ugc nofollow" target="_blank">图算法的例子:由<a class="ae kl" href="https://twitter.com/markhneedham" rel="noopener ugc nofollow" target="_blank"> Mark Needham </a>和<a class="ae kl" href="https://twitter.com/amyhodler" rel="noopener ugc nofollow" target="_blank"> Amy Hodler </a>撰写的 Apache Spark 和 Neo4j </a>书中的实际例子。由于这本书还演示了图算法的 Apache Spark 实现，我们决定也包括它们是合适的。在建立 Apache Spark 环境时，我遇到了与这本书的合著者相同的问题，他写了一篇关于这个问题的博文<a class="ae kl" href="https://markhneedham.com/blog/2019/04/17/pyspark-class-not-found-exception-org-graphframes-graphframepythonapi/" rel="noopener ugc nofollow" target="_blank"/>。大声喊马克！</p><p id="8def" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下是你可以从这个项目中期待的:</p><ul class=""><li id="ddfa" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">16 本单图算法笔记本，包含 Apache Spark 中的实现以及到 GDS 的迁移指南</li><li id="bcda" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">《移植到 GDS》中的链接预测分析</li></ul><p id="3d2a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="la"> Neo4j 图形数据科学和图形算法插件不兼容，因此它们不会在 Neo4j 的单个实例上协同工作。在这个项目中，我们使用了两个 Neo4j 实例来演示新旧语法。</em></p><p id="1b52" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了更好地了解笔记本所提供的功能，我们现在将浏览 PageRank 示例笔记本。你将在这篇博文中看到的所有引文都是从上述书中摘录的。</p><h1 id="c930" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">PageRank 算法简介</h1><p id="a46c" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">每个图形算法都有一个主笔记本，其中包括算法及其用例的简短介绍。以下是对 PageRank 算法的介绍:</p><blockquote class="me mf mg"><p id="c9d5" class="jn jo la jp b jq jr js jt ju jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj kk ij bi translated">PageRank 是以谷歌联合创始人拉里·佩奇的名字命名的，他创建了 Page rank 来对谷歌搜索结果中的网站进行排名。基本的假设是，一个有更多传入和更有影响力的传入链接的页面更有可能是一个可信的来源。PageRank 测量节点的传入关系的数量和质量，以确定对该节点重要性的估计。在网络上具有更大影响力的节点被认为具有来自其他有影响力的节点的更多传入关系。</p></blockquote><p id="2545" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在主笔记本的底部，您会找到 Neo4j 和/或 Apache Spark 算法实现的链接。</p><h1 id="9e90" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Neo4j 中的 PageRank 实现</h1><p id="4355" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">在实际的笔记本中，你会发现图形算法和图形数据科学算法的例子。尽管如此，为了这篇博文的清晰，我决定只展示新的 GDS 语法。</p><h2 id="2d9d" class="mk lc iq bd ld ml mm dn lh mn mo dp ll jy mp mq lp kc mr ms lt kg mt mu lx mv bi translated">加载示例图表:</h2><p id="3d15" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">GitHub 上的示例图是一个 CSV 文件，可以使用<code class="fe mw mx my mz b">LOAD CSV</code> cypher 语句轻松获取。</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="2d42" class="mk lc iq mz b gy ni nj l nk nl">// import nodes<br/>WITH “<a class="ae kl" href="https://raw.githubusercontent.com/neo4j-graph-analytics/book/master/data/social-nodes.csv" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/neo4j-graph-analytics/book/master/data/social-nodes.csv</a>"<br/>AS uri<br/>LOAD CSV WITH HEADERS FROM uri AS row<br/>MERGE (:User {id: row.id});</span><span id="1f41" class="mk lc iq mz b gy nm nj l nk nl">// import relationships<br/>WITH “<a class="ae kl" href="https://raw.githubusercontent.com/neo4j-graph-analytics/book/master/data/social-relationships.csv" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/neo4j-graph-analytics/book/master/data/social-relationships.csv</a>"<br/>AS uri<br/>LOAD CSV WITH HEADERS FROM uri AS row<br/>MATCH (source:User {id: row.src})<br/>MATCH (destination:User {id: row.dst})<br/>MERGE (source)-[:FOLLOWS]-&gt;(destination);</span></pre><p id="c725" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以通过使用下面的 cypher 语句来可视化 Zeppelin 中的示例图:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="5b7c" class="mk lc iq mz b gy ni nj l nk nl">MATCH p=(:User)-[:FOLLOWS]-&gt;(:User)<br/>RETURN p;</span></pre><p id="f859" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">结果</p><figure class="na nb nc nd gt no gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/451599e9173c70946f2b7c1ce10dbf27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/format:webp/1*FuMPM3HT34bDhDYXqsVuSw.png"/></div><p class="nr ns gj gh gi nt nu bd b be z dk translated">Apache Zeppelin 中可视化的示例图</p></figure><h1 id="5a63" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">图形数据科学插件</h1><h2 id="caca" class="mk lc iq bd ld ml mm dn lh mn mo dp ll jy mp mq lp kc mr ms lt kg mt mu lx mv bi translated">创建预加载的命名图</h2><p id="4d24" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">推荐使用 GDS 库的方法是预加载命名图。投影图可以存储在内存中，以后可以通过任何图形算法使用其名称进行检索。这允许更有效的图形分析管道，其中我们在同一个内存图形上按顺序运行许多图形算法。</p><p id="b25a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一般语法是:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="a3ad" class="mk lc iq mz b gy ni nj l nk nl">CALL gds.graph.create('nameOfGraph','NodeLabel','RelationshipType')</span></pre><p id="6c25" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本例中，我们将使用以下 cypher 语句将图形加载到内存中:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="8e36" class="mk lc iq mz b gy ni nj l nk nl">CALL gds.graph.create(‘pagerank_example’, ‘User’, ‘FOLLOWS’);</span></pre><h2 id="6a59" class="mk lc iq bd ld ml mm dn lh mn mo dp ll jy mp mq lp kc mr ms lt kg mt mu lx mv bi translated">流式传输算法的结果</h2><p id="32af" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">算法结果流的一般语法是:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="b156" class="mk lc iq mz b gy ni nj l nk nl">CALL gds.&lt;algorithm&gt;.stream()</span></pre><p id="2100" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于 PageRank 示例，cypher 过程如下所示:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="6c33" class="mk lc iq mz b gy ni nj l nk nl">CALL gds.pageRank.stream(‘pagerank_example’,<br/>    {maxIterations: 20, dampingFactor: 0.85}) YIELD nodeId, score<br/>RETURN gds.util.asNode(nodeId).id AS name, score<br/>ORDER BY score DESC LIMIT 10</span></pre><p id="0a01" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">结果</p><figure class="na nb nc nd gt no"><div class="bz fp l di"><div class="nv nw l"/></div><p class="nr ns gj gh gi nt nu bd b be z dk translated">Neo4j 页面排名结果</p></figure><blockquote class="me mf mg"><p id="95ed" class="jn jo la jp b jq jr js jt ju jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj kk ij bi translated">正如我们所料，Doug 拥有最高的 PageRank，因为在他的子图中，所有其他用户都跟随他。虽然马克只有一个追随者，这个追随者就是<br/>道格，所以马克在这个图中也被认为是重要的。重要的不仅仅是关注者的数量，还有那些关注者的重要性。</p></blockquote><h2 id="b104" class="mk lc iq bd ld ml mm dn lh mn mo dp ll jy mp mq lp kc mr ms lt kg mt mu lx mv bi translated">写回算法的结果</h2><p id="71f7" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">有时候，我们想把算法的结果写回图中，而不是流出来。写回算法的一般语法是:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="93fb" class="mk lc iq mz b gy ni nj l nk nl">CALL gds.&lt;algorithm&gt;.write({writeProperty:'pagerank'})</span></pre><p id="68ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其中如果您想写回结果，参数<code class="fe mw mx my mz b">writeProperty</code>是强制的。这是为了防止对图形进行任何不必要的写入。</p><p id="5d8b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的 PageRank 示例中，我们使用:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="239a" class="mk lc iq mz b gy ni nj l nk nl">CALL gds.pageRank.write(‘pagerank_example’,<br/>    {maxIterations: 20, dampingFactor: 0.85,     <br/>     writeProperty:’pageRank’})</span></pre><h2 id="6f72" class="mk lc iq bd ld ml mm dn lh mn mo dp ll jy mp mq lp kc mr ms lt kg mt mu lx mv bi translated">从内存中释放加载的图形</h2><p id="df74" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">完成图形分析后，我们想使用下面的 cypher 语句从内存中释放 GDS 图。</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="7255" class="mk lc iq mz b gy ni nj l nk nl">CALL gds.graph.drop(‘pagerank_example’);</span></pre><h1 id="0a48" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">用 Apache Spark 实现的 PageRank</h1><p id="76ec" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">如前所述，这本书还提供了 Apache Spark 中图形算法的实现，所以我只是将它们复制到笔记本上。</p><h2 id="adb7" class="mk lc iq bd ld ml mm dn lh mn mo dp ll jy mp mq lp kc mr ms lt kg mt mu lx mv bi translated">加载示例图表:</h2><p id="da09" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">在这个例子中，我们使用 GraphFrames 库来加载图表并计算 PageRank 中心性。</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="2734" class="mk lc iq mz b gy ni nj l nk nl">def create_social_graph():<br/>    nodes = spark.read.csv(“spark-warehouse/social-nodes.csv”, header=True)<br/>    relationships = spark.read.csv(“spark-warehouse/social-relationships.csv”, header=True)<br/>    return GraphFrame(nodes, relationships)</span><span id="6cd4" class="mk lc iq mz b gy nm nj l nk nl">g = create_social_graph()</span></pre><h2 id="4156" class="mk lc iq bd ld ml mm dn lh mn mo dp ll jy mp mq lp kc mr ms lt kg mt mu lx mv bi translated">迭代次数固定的 PageRank</h2><blockquote class="me mf mg"><p id="42a9" class="jn jo la jp b jq jr js jt ju jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj kk ij bi translated">让我们看一个固定迭代方法的例子。<br/>注意在 Spark 中，阻尼因子更直观地被称为<br/>重置概率，具有相反的值。换句话说，本例中 reset <br/> Probability=0.15 相当于 Neo4j 中的 dampingFactor:0.85。</p></blockquote><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="fc88" class="mk lc iq mz b gy ni nj l nk nl">results = g.pageRank(resetProbability=0.15, maxIter=20)<br/>results.vertices.sort(“pagerank”, ascending=False).show()</span></pre><p id="06e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">结果</p><figure class="na nb nc nd gt no"><div class="bz fp l di"><div class="nv nw l"/></div><p class="nr ns gj gh gi nt nu bd b be z dk translated">具有固定迭代次数的 Spark PageRank</p></figure><p id="16d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">结果类似于 Neo4j 的结果。</p><blockquote class="me mf mg"><p id="6222" class="jn jo la jp b jq jr js jt ju jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj kk ij bi translated">PageRank 的实现各不相同，因此即使排序相同，它们也会产生不同的<br/>得分。Neo4j 使用值 1 减去阻尼因子来初始化节点<br/>，而 Spark 使用值 1 初始化<br/>。在这种情况下，相对排名(Pag 的目标是<br/> eRank)是相同的，但是用于达到<br/>这些结果的基础分值是不同的。</p></blockquote><h2 id="e130" class="mk lc iq bd ld ml mm dn lh mn mo dp ll jy mp mq lp kc mr ms lt kg mt mu lx mv bi translated">PageRank 直到收敛</h2><blockquote class="me mf mg"><p id="2cac" class="jn jo la jp b jq jr js jt ju jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj kk ij bi translated">现在，让我们尝试运行 PageRank 的收敛实现，直到它在设定的容差范围内逼近一个解决方案:</p></blockquote><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="1823" class="mk lc iq mz b gy ni nj l nk nl">results = g.pageRank(resetProbability=0.15, tol=0.01)<br/>results.vertices.sort(“pagerank”, ascending=False).show()</span></pre><p id="8c36" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">结果</p><figure class="na nb nc nd gt no"><div class="bz fp l di"><div class="nv nw l"/></div><p class="nr ns gj gh gi nt nu bd b be z dk translated">带收敛策略的 Spark PageRank</p></figure><blockquote class="me mf mg"><p id="2a85" class="jn jo la jp b jq jr js jt ju jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj kk ij bi translated">每个人的 PageRank 分数与固定迭代次数变量略有不同，但正如我们所料，他们的顺序保持不变。</p></blockquote><h1 id="790c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">个性化页面排名</h1><blockquote class="me mf mg"><p id="2b0e" class="jn jo la jp b jq jr js jt ju jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj kk ij bi translated">我们可以通过传入 sourceId 参数来计算给定节点的个性化 PageRank 分数。以下代码计算道格的 PPR:</p></blockquote><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="9810" class="mk lc iq mz b gy ni nj l nk nl">me = “Doug”<br/>results = g.pageRank(resetProbability=0.15, maxIter=20, sourceId=me)<br/>people_to_follow = results.vertices.sort(“pagerank”, ascending=False)</span><span id="1f52" class="mk lc iq mz b gy nm nj l nk nl">already_follows = list(g.edges.filter(“src = ‘{me}’”).toPandas()[“dst”])<br/>people_to_exclude = already_follows + [me]</span><span id="df55" class="mk lc iq mz b gy nm nj l nk nl">people_to_follow[~people_to_follow.id.isin(people_to_exclude)].show()</span></pre><p id="61d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">结果</p><figure class="na nb nc nd gt no"><div class="bz fp l di"><div class="nv nw l"/></div><p class="nr ns gj gh gi nt nu bd b be z dk translated">Spark 个性化页面排名</p></figure><blockquote class="me mf mg"><p id="303d" class="jn jo la jp b jq jr js jt ju jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj kk ij bi translated">这个查询的结果可以用来为道格应该关注的人提供建议。请注意，我们还确保从我们的最终结果中排除道格已经关注的人以及他自己。</p><p id="b7f8" class="jn jo la jp b jq jr js jt ju jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj kk ij bi translated">爱丽丝是道格应该追随的最佳人选，但我们也可以推荐迈克尔和布里奇特。</p></blockquote><h1 id="1398" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="4bb5" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">再次感谢 Amy 和 Mark 编写了这本优秀的书，感谢 Neo4j 图表数据科学团队提供了如此出色的工具来帮助我们在图表中找到更多见解。正如我在这篇博文的介绍中提到的，目前这仍然是 GDS 插件的预览版，正式发布将在接下来的几周内进行。自己试试<a class="ae kl" href="https://github.com/neo4j/graph-data-science" rel="noopener ugc nofollow" target="_blank">图形数据科学</a>插件，请分享任何评论、反馈或建议。</p><p id="71da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一如既往，你可以在<a class="ae kl" href="https://github.com/tomasonjo/zeppelin-graph-algo" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到这些笔记本。</p></div></div>    
</body>
</html>