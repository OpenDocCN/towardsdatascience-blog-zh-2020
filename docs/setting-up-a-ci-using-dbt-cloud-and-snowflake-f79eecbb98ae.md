# 使用 dbt 云和雪花设置配置项

> 原文：<https://towardsdatascience.com/setting-up-a-ci-using-dbt-cloud-and-snowflake-f79eecbb98ae?source=collection_archive---------27----------------------->

## 融合到大师，晚上睡觉

![](img/a6dfd0ead49fddec8781a2c1303aedd6.png)

照片由 [Kian Lem](https://unsplash.com/@kianlem?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 在 [Unsplash](https://unsplash.com/?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄

在 [HousingAnywhere](https://housinganywhere.com/) ，我们正在使用 [dbt](https://www.getdbt.com/) 和雪花对我们的数据进行建模，以便为我们的业务分析师和数据科学家提供有意义的视图和物化。我们的数据仓库充满了来自各种不同来源的原始结构化数据，其中大部分是通过 [Stitch](https://www.stitchdata.com/) 复制的；一个简单且可扩展的即插即用的托管 ETL 工具。其他人需要更多的个人接触，并使用气流与临时定期任务[相结合。在这两种情况下，从这些来源提取有意义的见解可能会令人沮丧，因为普遍存在肮脏、不一致和/或存储在过度设计的结构中的数据，这些结构在设计时没有考虑到易于访问和信息提取。](/testing-airflow-jobs-on-google-cloud-composer-using-pytest-9e0a1198b4cd?source=friends_link&sk=c1580e3682d25ea3f6b86a72f04d35c0)

![](img/a69cb362e61c446961292378509aa6fe.png)

HousingAnywhere 的 ETL 架构的简化表示

**dbt** 本身是一个命令行工具，允许数据工程师高效地转换他们数据仓库中的数据。当需要更复杂的逻辑或访问关于作业执行或目标模式/表的信息时，它使用用 Jinja 模板丰富的 SQL。数据仓库被用作一个数据源，数据从这个数据源被转换并推回到同一个仓库中，尽管是在不同的位置。dbt 的结果通常更容易理解和维护，通常由可能来自不同数据源的表的多个连接组成。BI 工具(如 Mode、Looker 等)通常只能看到这些结果表，而不是原始的原始数据源。

> dbt 的结果通常更容易理解和维护，通常由可能来自不同数据源的表的多个连接组成。

举一个例子:假设有一个表，包含关于一个属性的各种信息，用纬度和经度来描述它的位置。查询这种数据不容易。我们使用 dbt 创建了一个模型，该模型添加了一个“城市”列，通过计算从酒店位置到我们业务感兴趣的城市的 haversine 距离来检索。计算这些距离，并将最近的城市分配给该物业，以用于报告目的。业务分析师可以简单地查询第二个表，而不必担心幕后复杂的逻辑。

dbt 是分布在 pypi 上的 Python 模块，可以部署在任何运行 Python 的机器上。也就是说，使用 [dbt Cloud](https://www.getdbt.com/) 肯定更方便，它允许您免费进行高效的 dbt 部署(当然，最初是随增长付费的模式)。dbt Cloud 还为核心产品[添加了许多有趣的功能](https://www.getdbt.com/product/)，用户友好的 web 界面使其成为在生产环境中实现 dbt 的最佳方式。由于与 Github 的无缝集成，所有的模型和配置都可以使用 git 进行代码版本化，开发过程可以像任何其他经典软件工程项目一样进行，并行打开多个分支，并通过 pull requests (PR)合并 master 上的更改。在预定的时间，dbt Cloud 选取主分支，并针对生产数据运行所选的模型，按照代码中的定义转换它们，并交付更改。

> 由于与 Github 的无缝集成，所有模型和配置都可以使用 git 进行代码版本化，开发过程可以像任何其他经典软件工程项目一样进行。

这允许一个高效、可观察且易于维护的环境，尽管让 master 直接连接到生产仓库并不是最可靠的做法。dbt 语法很容易出错，即使理想情况下可以在本地编译(Jinja 模板必须翻译成 SQL)，也不容易评估这些变化是否破坏了数据中的一些语义约束。在一个简单的实现中，没有什么可以阻止您通过一个破坏某些东西的 commit 来合并到 master，只是当计划的任务在晚上某个时候运行时，您会发现您的方法中的错误。不理想。

![](img/f3f5705e197ecd6e7460c389495675f5.png)

dbt 云上的“请求时运行”功能

幸运的是，dbt Cloud 来帮忙了，当从连接的存储库上打开的 PR 触发时，允许针对自定义分支运行作业。换句话说:生产作业的精确副本可以使用每次打开 PR 时在分支上找到的模型来运行，在相同的生产环境中根据临时模式来具体化。当 PR 关闭或合并时，临时模式被删除，但是当 PR 打开时，它可以像数据库上的任何其他模式一样被访问，以运行测试或手动检查东西——如果需要的话。这个特性对于检查分支内容的语法和高级一致性特别有用，可以防止参与者合并重大变更。如果生产[中的 dbt 管道已经包含测试](https://docs.getdbt.com/docs/building-a-dbt-project/tests/)，那么这些测试也将针对临时模式运行，以便在语义级别上检查其内容。

![](img/e88340ed667cc0b289e49d42501e4469.png)

CI 检查失败，阻止开发人员合并

然而，尽管在临时模式上复制整个生产环境在理论上很有吸引力，但是实现每次提交都有数亿行的表是不可行的。拥有 CI 的主要目的是为开发人员提供对他们工作的快速检查，而一些表的完全重新填充在最好的情况下可能需要几个小时。在执行 dbt 作业时，很容易区分生产运行和 CI 运行，考虑到严格的命名模式和用于此目的的临时模式(本文发布时的 dbt_cloud_pr_xx)。在 dbt 模型中克服对原始表的引用，并在执行 CI 作业时减少被引用的临时实例的大小，这样就可以让 CI 运行使用一小部分生产数据，从而大大减少对每个 PR 进行可靠检查所需的时间。

![](img/d815b921ff06daef704982dbcf7da68a.png)

第一步:删除 dbt 模型中对原始表的硬编码引用

从语法上来说，缩小表的范围以避免篡改数据结构的外部引用是一项简单的工作，没有任何经验法则可以正确地完成这项工作。我们决定在一个主表上限制时间范围，并填充其他表，以便保留连接和引用。

![](img/36673b9ac7fcc2fbc4ee3c6ae061df68.png)

第二步:在针对 CI 模式运行时，缩小原始表的范围

这里有一个离现实不远的例子:想象一个数据库模式，其中有租户和广告商之间关于一些房屋属性(列表)的对话。最合乎逻辑的决定是只选择在特定时间间隔内创建的对话(例如，2019 年 1 月，大约数万个样本)，以强制存在与这些对话相关的列表，当然还有双方涉及的用户。产生的模式大小减小了，但仍然一致。按照这个方向推理，我们可以关闭与模式的这一部分相关的所有可传递的依赖关系，可能的话，在同一时期对与这些没有直接依赖关系的其他表进行时间约束。

感谢 [Julian Smidek](https://www.linkedin.com/in/julian-smidek/) 和 [Stephen O' Farrell](https://www.linkedin.com/in/stephen-o-farrell-20207a16b/) 对这个项目和这个职位的贡献。