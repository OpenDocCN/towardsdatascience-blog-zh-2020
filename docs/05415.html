<html>
<head>
<title>Vectorization in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的矢量化</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/vectorization-in-python-46486819d3a?source=collection_archive---------17-----------------------#2020-05-07">https://towardsdatascience.com/vectorization-in-python-46486819d3a?source=collection_archive---------17-----------------------#2020-05-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="1379" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/pytrix-series" rel="noopener" target="_blank"> PyTrix系列</a></h2><div class=""/><div class=""><h2 id="90b2" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">PyTrix#1:加速我们的Python代码</h2></div><p id="0441" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">Python是一种流行的数据科学语言。它的语法很容易学习(和阅读),这使得新手更容易掌握和使用这种语言。然而，不涉及细节，Python是一种<a class="ae ln" href="https://en.wikipedia.org/wiki/Interpreted_language" rel="noopener ugc nofollow" target="_blank">解释语言</a>，这意味着它运行起来比像c这样的<a class="ae ln" href="https://en.wikipedia.org/wiki/Compiled_language" rel="noopener ugc nofollow" target="_blank">编译语言</a>慢得多</p><p id="50c1" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">当我们执行深度学习时，我们可能会使用大量数据，因为这是深度学习蓬勃发展的时候。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi lo"><img src="../Images/0258797334685cacdcf31d18324f9a4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1b57MV6akYI-O-7dmJlFbQ.png"/></div></div><p class="ma mb gj gh gi mc md bd b be z dk translated">图Coursera上吴恩达深度学习专业化的照片</p></figure><p id="2b7e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">为什么我要说这些？很棒的问题！</p><p id="c5ae" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">如果我们有大量的数据和缓慢的python代码，我们很可能最终得到一个以蜗牛速度运行的模型，因为我们的代码在计算上不是最优的...人类对这场大灾难的解决方案是什么？矢量化！B-)</p><p id="bfcd" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">什么是矢量化？</strong></p><p id="f629" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">通俗地说，它加快了Python代码的速度，而不需要循环、索引等。在数据科学中，我们使用Numpy来完成这项工作——Numpy是科学编程的事实框架。从技术上来说，当我们在Numpy中实现矢量化形式时，我们仍然执行这些操作，但不在Python中——在幕后。相反，这些操作是在优化的预编译C代码中完成的——参见<a class="ae ln" href="https://numpy.org/devdocs/user/whatisnumpy.html" rel="noopener ugc nofollow" target="_blank">文档</a>了解更多信息。</p><blockquote class="mf"><p id="e0eb" class="mg mh it bd mi mj mk ml mm mn mo lm dk translated">这种用数组表达式替换显式循环的做法通常被称为向量化。一般来说，矢量化数组运算通常比纯python运算快一两个(或更多)数量级，在任何类型的数值计算中都有最大的影响”——McKinney，2012年，第97页</p></blockquote></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><p id="b88f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">纯Python vs Numpy示例</strong></p><p id="e8d7" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在这一节中，我将用python实现一些例子，然后用numpy实现相同的代码，并比较两者的计算时间，这样我们可以对矢量化有一个直观的了解。下面是我的Github库的代码链接。</p><div class="mw mx gp gr my mz"><a href="https://github.com/kurtispykes/demo/tree/master/pytrix" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd jd gy z fp ne fr fs nf fu fw jc bi translated">kurtispykes/演示</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">github.com</p></div></div><div class="ni l"><div class="nj l nk nl nm ni nn ly mz"/></div></div></a></div><p id="9277" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">外部产品</strong></p><p id="5368" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">两个向量的外积将产生一个矩阵。例如，如果我们有两个维度为<code class="fe no np nq nr b">n</code>和<code class="fe no np nq nr b">m</code>的向量，那么这两个向量的外积——见图2。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/b50c598d8d039cf49e886cd670955680.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/format:webp/1*BwHV54X2d6BnGi6FW1K7jw.png"/></div><p class="ma mb gj gh gi mc md bd b be z dk translated">图2:外积公式<a class="ae ln" href="https://en.wikipedia.org/wiki/Outer_product" rel="noopener ugc nofollow" target="_blank">【来源】</a></p></figure><pre class="lp lq lr ls gt nt nr nu nv aw nw bi"><span id="aa3c" class="nx ny it nr b gy nz oa l ob oc">import numpy as np<br/>import time</span><span id="a997" class="nx ny it nr b gy od oa l ob oc">a = np.arange(10000)<br/>b = np.arange(10000)</span><span id="e40d" class="nx ny it nr b gy od oa l ob oc"># pure Python outer product implementation<br/>tic = time.process_time()</span><span id="5aca" class="nx ny it nr b gy od oa l ob oc">outer_product = np.zeros((10000, 10000))<br/>for i in range(len(a)):<br/>    for j in range(len(b)):<br/>        outer_product[i][j]= a[i] * b[j]</span><span id="60a5" class="nx ny it nr b gy od oa l ob oc">toc = time.process_time()</span><span id="8f45" class="nx ny it nr b gy od oa l ob oc">print("python_outer_product = "+ str(outer_product))<br/>print("Time = "+str(1000*(toc - tic ))+"ms\n")</span><span id="7d2f" class="nx ny it nr b gy od oa l ob oc"># Numpy outer product implementation<br/>n_tic = time.process_time()</span><span id="ac7d" class="nx ny it nr b gy od oa l ob oc">outer_product = np.outer(a, b)</span><span id="7704" class="nx ny it nr b gy od oa l ob oc">n_toc = time.process_time()</span><span id="f4dd" class="nx ny it nr b gy od oa l ob oc">print("numpy_outer_product = "+str(outer_product));<br/>print("Time = "+str(1000*(n_toc - n_tic ))+"ms")</span></pre><p id="6296" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这个细胞输出…</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi oe"><img src="../Images/e41162b27785c945b12aa5b43ed577f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X1p9Cq3v57OIcX9qrUtgow.png"/></div></div><p class="ma mb gj gh gi mc md bd b be z dk translated">图3:上面代码块的输出</p></figure></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><p id="e197" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">点积</strong></p><p id="b8e6" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">也称为内积，点积接受两个长度相等的数字序列，并返回一个标量—参见图4。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi of"><img src="../Images/ab5f93f7a97a204877d718c109c7f498.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kg47AdKQPGMRdEMZJHc8OA.png"/></div></div><p class="ma mb gj gh gi mc md bd b be z dk translated">图4:点积公式</p></figure><pre class="lp lq lr ls gt nt nr nu nv aw nw bi"><span id="2d6c" class="nx ny it nr b gy nz oa l ob oc">import numpy as np<br/>import time</span><span id="ca7f" class="nx ny it nr b gy od oa l ob oc">a = np.arange(10000000)<br/>b = np.arange(10000000)</span><span id="7c02" class="nx ny it nr b gy od oa l ob oc"># pure Python outer product implementation<br/>tic = time.process_time()</span><span id="2025" class="nx ny it nr b gy od oa l ob oc">dot_product = 0<br/>for i in range(len(a)):<br/>    dot_product += a[i] * b[i]</span><span id="f9ee" class="nx ny it nr b gy od oa l ob oc">toc = time.process_time()</span><span id="3d7a" class="nx ny it nr b gy od oa l ob oc">print("python_dot_product = "+ str(dot_product))<br/>print("Time = "+str(1000*(toc - tic ))+"ms\n")</span><span id="7dbe" class="nx ny it nr b gy od oa l ob oc"># Numpy outer product implementation<br/>n_tic = time.process_time()</span><span id="c0d6" class="nx ny it nr b gy od oa l ob oc">dot_product = np.dot(a, b)</span><span id="28ba" class="nx ny it nr b gy od oa l ob oc">n_toc = time.process_time()</span><span id="f8dc" class="nx ny it nr b gy od oa l ob oc">print("numpy_dot_product = "+str(dot_product))<br/>print("Time = "+str(1000*(n_toc - n_tic ))+"ms")</span></pre><p id="af1c" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这个代码块的输出…</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi og"><img src="../Images/ebcf0dd697b8b3a2b3094bd5297fd1aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:806/format:webp/1*ZxTE8uBRAAI1wBoP8oXCLw.png"/></div><p class="ma mb gj gh gi mc md bd b be z dk translated">图5:上面代码块的结果。</p></figure></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><p id="39f0" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">最终，矢量化不仅使我们的代码更快、更容易阅读，还减少了我们必须编写的代码量，这通常意味着我们得到的bug更少。最重要的是，我们编写的代码看起来更“Pythonic化”,因为我们去掉了代码库中所有低效的、难以阅读的for循环。</p><blockquote class="oh oi oj"><p id="cdc7" class="kr ks me kt b ku kv kd kw kx ky kg kz ok lb lc ld ol lf lg lh om lj lk ll lm im bi translated">注:如果这对你来说是全新的，我建议你观看下面链接的来自吴恩达的视频，这些视频来自Coursera上的<a class="ae ln" href="https://www.coursera.org/specializations/deep-learning?utm_source=gg&amp;utm_medium=sem&amp;utm_content=17-DeepLearning-ROW&amp;campaignid=6465471773&amp;adgroupid=77415260637&amp;device=c&amp;keyword=coursera%20artificial%20intelligence&amp;matchtype=b&amp;network=g&amp;devicemodel=&amp;adpostion=&amp;creativeid=379493352691&amp;hide_mobile_promo&amp;gclid=CjwKCAjw4871BRAjEiwAbxXi28Rmr9JrCIczEjB8MLDHTReKsNdfG0nPYnGFTbtH4583TDzvUal7GhoC6gkQAvD_BwE" rel="noopener ugc nofollow" target="_blank">深度学习专业</a>，并开始掌握<a class="ae ln" href="https://numpy.org/" rel="noopener ugc nofollow" target="_blank"> Numpy文档</a></p></blockquote><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="on oo l"/></div><p class="ma mb gj gh gi mc md bd b be z dk translated">图6:深度学习专业化课程1中关于矢量化的吴恩达。</p></figure><div class="mw mx gp gr my mz"><a href="https://www.khanacademy.org/math/linear-algebra/vectors-and-spaces" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd jd gy z fp ne fr fs nf fu fw jc bi translated">向量和空间|线性代数|数学|可汗学院</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">如果您看到此消息，这意味着我们在网站上加载外部资源时遇到了问题。如果你是…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">www.khanacademy.org</p></div></div><div class="ni l"><div class="op l nk nl nm ni nn ly mz"/></div></div></a></div></div></div>    
</body>
</html>