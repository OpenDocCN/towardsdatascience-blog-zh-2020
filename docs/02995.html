<html>
<head>
<title>Introduction to Ensemble Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">集成学习简介</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/introduction-to-ensemble-learning-27af286ac470?source=collection_archive---------24-----------------------#2020-03-22">https://towardsdatascience.com/introduction-to-ensemble-learning-27af286ac470?source=collection_archive---------24-----------------------#2020-03-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="719e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">装袋和增压技术概述</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/09196f341ad102480086686c8b8e8da9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HPWjneh6FroeA8fSaOgxjQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图:<a class="ae kv" href="https://www.lasemainedecastres.fr/quand-les-arbres-communiquent-entre-eux/" rel="noopener ugc nofollow" target="_blank">团结成长理念</a></p></figure><p id="6eef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="ls">“弱者团结起来也变得强大。”</em> </strong> <em class="ls"> —弗里德里希·冯·席勒</em></p><p id="bc92" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是集合方法背后的基本思想。弱学习器，也称为基础模型，被有策略地组合在一起，形成一个强学习器，称为集成模型。集成模型使用多种学习算法来解决特定的分类/回归问题，该问题不能由它的任何组成学习器单独有效地学习。</p><p id="3648" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">组合弱学习器的不同技术在如何聚集这些弱学习器中的每一个的输出以获得最终输出方面有所不同。我们将研究两种实现集合模型的流行技术:</p><ol class=""><li id="8914" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated">制袋材料</li><li id="6e25" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">助推</li></ol><p id="b050" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在继续之前，让我们直观地理解这些技术对模型性能的影响。一个好的机器学习算法理论上被期望在学习训练数据时实现低偏差和低方差。然而，实现两者是不可能的，这被称为<strong class="ky ir">偏差-方差权衡</strong>。这两种误差源(偏差/方差)都妨碍了模型对训练数据进行归纳，从而无法对看不见的数据进行有效处理。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mh"><img src="../Images/63831d20afab96d646f16c422d60fb2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*baJbTXOBQgYiZW-T8z2kPQ.png"/></div></div></figure><blockquote class="mi mj mk"><p id="f736" class="kw kx ls ky b kz la jr lb lc ld ju le ml lg lh li mm lk ll lm mn lo lp lq lr ij bi translated">偏差是由算法做出的错误假设引起的误差。这会导致模型错过训练数据中的特征和目标输出之间的关系(欠拟合)。</p><p id="4ce1" class="kw kx ls ky b kz la jr lb lc ld ju le ml lg lh li mm lk ll lm mn lo lp lq lr ij bi translated">方差是由对训练数据中微小波动的敏感性引起的误差。这将导致模型从训练数据中学习噪声(过拟合)。</p></blockquote><p id="0ecf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">集合方法用于根据基础模型的弱点来减少偏差或方差。根据我们试图减少的误差源，选择不同的组合技术。</p></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="8bad" class="mv mw iq bd mx my mz na nb nc nd ne nf jw ng jx nh jz ni ka nj kc nk kd nl nm bi translated">打包(引导汇总)</h1><blockquote class="mi mj mk"><p id="dcd3" class="kw kx ls ky b kz la jr lb lc ld ju le ml lg lh li mm lk ll lm mn lo lp lq lr ij bi translated">Bagging 涉及在不同的训练数据集上并行训练弱学习模型，并使用某种平均方法组合这些基础模型的结果。</p></blockquote><p id="1cc9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 1。采样</strong></p><p id="6eb6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我说多组训练数据时，你肯定在想这将需要大量的训练数据来馈送多个数据饥渴的深度学习网络。但我们需要的只是一组训练数据的多个样本。这可以使用一种叫做<strong class="ky ir">自举的技术来实现。</strong></p><blockquote class="mi mj mk"><p id="adff" class="kw kx ls ky b kz la jr lb lc ld ju le ml lg lh li mm lk ll lm mn lo lp lq lr ij bi translated">Bootstrapping 是一种从原始数据中进行采样的统计方法，其中样本几乎是独立的，并且代表原始数据分布(大约独立于原始数据分布，并且与原始数据分布相同)。</p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/bd6c889c71f28d733c57bf7efdc2a33c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ceqmiy56bYrh4iL0wxYoLg.png"/></div></div></figure><p id="2e30" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 2。培训</strong></p><p id="1ba8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我们从大小为<em class="ls"> N </em>的原始数据集生成<em class="ls"> L </em>个大小为<em class="ls"> N </em>的样本，并进行替换。然后，我们在通过自举生成的这些<em class="ls"> L </em>个样本中的每一个样本上训练<em class="ls"> L </em>个同质基础模型。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/4598c53e9e1bb3703aafb638bdcdc026.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*drHVJ4zW-GmJcG3vqbVI7A.png"/></div></div></figure><p id="6162" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 3。聚集</strong></p><p id="78ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们有了来自<em class="ls"> L </em>基本模型的预测，我们需要使用某种平均方法来汇总这些预测。在回归问题的情况下，我们可以找到基础模型预测的字面平均值，以此来弥补集合模型的预测。</p><blockquote class="np"><p id="e3e5" class="nq nr iq bd ns nt nu nv nw nx ny lr dk translated">Y = ( y1+y2+y3+…+yL ) / L</p></blockquote><p id="33c0" class="pw-post-body-paragraph kw kx iq ky b kz nz jr lb lc oa ju le lf ob lh li lj oc ll lm ln od lp lq lr ij bi translated">对于分类问题，如果我们让基本模型返回类别标签，那么一种聚合方式是将每个弱分类器返回的类别视为投票，并且具有最高票数的类别由集成模型返回— <strong class="ky ir">硬投票</strong>。</p><blockquote class="np"><p id="6631" class="nq nr iq bd ns nt nu nv nw nx ny lr dk translated">Y = max ( y1，y2，y3，…，yL)</p></blockquote><p id="a8a5" class="pw-post-body-paragraph kw kx iq ky b kz nz jr lb lc oa ju le lf ob lh li lj oc ll lm ln od lp lq lr ij bi translated">另一方面，如果我们有返回每个类别概率的基础模型，那么一种方法是从所有基础模型中找到每个类别预测的平均值，并且具有最高平均概率的类别由集合模型返回— <strong class="ky ir">软投票</strong>。</p><blockquote class="np"><p id="10b5" class="nq nr iq bd ns nt nu nv nw nx ny lr dk translated">Y = max [ P(y1)，P(y2)，P(y3)，…，P(yL) ]</p></blockquote><p id="a64f" class="pw-post-body-paragraph kw kx iq ky b kz nz jr lb lc oa ju le lf ob lh li lj oc ll lm ln od lp lq lr ij bi translated"><strong class="ky ir">什么时候用什么时候不用装袋？</strong></p><ul class=""><li id="af5f" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr oe lz ma mb bi translated">装袋方法主要集中在<strong class="ky ir">减少方差</strong>，不影响偏倚。<strong class="ky ir">因此，当基础模型具有高方差和低偏差时，选择这种技术，这通常是对于复杂数据具有高自由度的模型的情况(例如:深度决策树)。</strong></li><li id="240a" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr oe lz ma mb bi translated">Bagging 不适用于具有高偏差和低方差的模型，因为组合不太适合训练数据(欠拟合)的基础模型的结果在聚合时不会改变结果。</li><li id="ffd8" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr oe lz ma mb bi translated">具有高自由度(复杂数据)的模型需要更多的训练时间。由于基本模型是并行训练的，训练每个基本模型所花费的时间相当于训练它们中的任何一个，使得 bagging 成为集成方法的一个好选择。</li></ul></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="d8e8" class="mv mw iq bd mx my mz na nb nc nd ne nf jw ng jx nh jz ni ka nj kc nk kd nl nm bi translated"><strong class="ak">增压</strong></h1><blockquote class="mi mj mk"><p id="bc9a" class="kw kx ls ky b kz la jr lb lc ld ju le ml lg lh li mm lk ll lm mn lo lp lq lr ij bi translated">Boosting 涉及逐步训练弱学习者，每次，模型直观地将其努力集中在它的前任难以学习的观察上。</p></blockquote><p id="61c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">基本模型以非常<em class="ls">自适应</em>的方式组合以形成集合模型。集合模型是组成基本模型的加权和。主要有两种流行的<em class="ls">元算法</em>，它们与弱学习者的聚集方式有着明显的不同。它们都旨在以迭代方式优化集合模型。</p><ol class=""><li id="18a5" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated">自适应增强(Adaboost)</li><li id="2692" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">梯度推进(阿达格拉德)</li></ol><p id="f2cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">自适应增压</strong></p><p id="18dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个基础学习者<strong class="ky ir">更新数据集中每个观察值的权重</strong>。对<em class="ls"> L </em>学习器重复下面的步骤，其中每个基本模型试图使用权重来纠正其前一个模型的错误。</p><p id="d9c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">(I)在弱学习者被训练之后，数据集中的每个数据点被分配一个表示分类准确性的权重。即，具有较高准确度的数据点将被分配较低的权重，反之亦然。</p><p id="7f85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">(ii)这个加权数据集然后被用作下一个弱学习者的训练集。该学习者将直观地更加关注具有较高权重的数据点，并尝试对它们进行正确分类。</p><p id="36de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">(iii)对于错误分类的样本，结果数据集被重新加权，并被用作下一个学习者的输入。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/bbb49a07b1a50f6005548e895b177a41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2V_zUVnQ_pnugnkx79s4wA.png"/></div></div></figure><p id="5deb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">梯度增强</strong></p><p id="f8fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个基础学习器<strong class="ky ir">更新数据集中的观察值</strong>。像在 Adaboost 中，下一个模型取决于前一个模型的误差。顾名思义，我们使用梯度下降顺序组合弱学习者。每个基本模型都试图将数据拟合到与我们迄今为止从集合模型获得的误差梯度相反的方向。</p><blockquote class="np"><p id="09ac" class="nq nr iq bd ns nt nu nv nw nx ny lr dk translated">西ᵢ =西ᵢ-₁ — (α * ∇东ᵢ-₁)</p></blockquote><p id="777b" class="pw-post-body-paragraph kw kx iq ky b kz nz jr lb lc oa ju le lf ob lh li lj oc ll lm ln od lp lq lr ij bi translated">W ᵢ是基本模型 I 的权重，α是步长，E ᵢ-₁是基本模型(i-1)的误差。</p><p id="08cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于数据集中的每个观察值，我们计算观察值和预测值之间的差异。这些值被称为<strong class="ky ir">伪残差。</strong>它们指示下一个学习者应该更新的方向，以获得正确的值。</p><ol class=""><li id="4359" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated">最初，我们将伪残差设置为已知目标的平均值。</li><li id="ce8a" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">对于每个弱学习算法 I，我们预测在(i-1)中获得的伪残差。</li><li id="8b65" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">由此获得的伪残差是后续弱学习器的目标。</li></ol><blockquote class="np"><p id="0802" class="nq nr iq bd ns nt og oh oi oj ok lr dk translated">伪残差= Yᵗᵃʳᵍᵉᵗ - Yᵖʳᵉᵈ</p></blockquote><figure class="om on oo op oq kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/e43de459f4f1d241e175bd9da1e7434f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WXQizapI8a0rwerkCk2iWA.png"/></div></div></figure><p id="36f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">什么时候用什么时候不用升压？</strong></p><ul class=""><li id="ae9a" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr oe lz ma mb bi translated">一般使用<strong class="ky ir">低方差高偏差</strong>的模型，自由度少(例如:浅层决策树)。</li><li id="54a5" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr oe lz ma mb bi translated">与并行训练模型的 bagging 不同，这里的模型是顺序训练的。依次训练几个复杂的模型会使计算变得昂贵。</li></ul></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><p id="f982" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">参考文献</strong></p><p id="b1ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[1]伊恩·古德菲勒、约舒阿·本吉奥、亚伦·库维尔——深度学习。</p><p id="fdae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[2]约瑟夫·罗卡，<a class="ae kv" rel="noopener" target="_blank" href="/ensemble-methods-bagging-boosting-and-stacking-c9214a10a205">集合方法:装袋，助推，堆垛</a>。</p><p id="cd7f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[3]使用<a class="ae kv" href="https://venngage.com/" rel="noopener ugc nofollow" target="_blank">拍卖</a>创建的数字。</p><p id="f871" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想过来打个招呼，请通过<a class="ae kv" href="https://www.linkedin.com/in/pallavirbharadwaj" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae kv" href="https://twitter.com/pallavibharadwj" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae kv" href="https://github.com/pallavibharadwaj" rel="noopener ugc nofollow" target="_blank">Github</a>与我联系。</p></div></div>    
</body>
</html>