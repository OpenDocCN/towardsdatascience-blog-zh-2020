<html>
<head>
<title>Higher Order Numeric Differential Equations(Python)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高阶数值微分方程(Python)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/higher-order-numeric-differential-equations-python-bc23dd148a0b?source=collection_archive---------16-----------------------#2020-02-27">https://towardsdatascience.com/higher-order-numeric-differential-equations-python-bc23dd148a0b?source=collection_archive---------16-----------------------#2020-02-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="af6c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">这篇文章展示了如何在python中使用高阶方法求解微分方程，以最小化截断误差并更快地收敛。</h2></div><p id="85a8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">根据题目的性质，需要对微积分和基本编程有所了解。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="92c7" class="ll lm it bd ln lo lp lq lr ls lt lu lv jz lw ka lx kc ly kd lz kf ma kg mb mc bi translated">进口</h1><p id="c8e4" class="pw-post-body-paragraph ki kj it kk b kl md ju kn ko me jx kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">安装来自https://www.anaconda.com/distribution/的巨蟒</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="cfe8" class="ms lm it mo b gy mt mu l mv mw">import numpy as np<br/>import matplotlib.pyplot as plt<br/>from mpl_toolkits.mplot3d import Axes3D # For 3D Plotting of Systems</span></pre><h1 id="a3c0" class="ll lm it bd ln lo mx lq lr ls my lu lv jz mz ka lx kc na kd lz kf nb kg mb mc bi translated">遵守代码</h1><p id="bbf1" class="pw-post-body-paragraph ki kj it kk b kl md ju kn ko me jx kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">我鼓励你在Google colab上试验一下代码，链接是<a class="ae mi" href="https://colab.research.google.com/drive/14KT0sLGFphRF_QeL8e3by7tfNY0xkzq5" rel="noopener ugc nofollow" target="_blank">这里</a>或者<a class="ae mi" href="https://colab.research.google.com/drive/14KT0sLGFphRF_QeL8e3by7tfNY0xkzq5" rel="noopener ugc nofollow" target="_blank">https://colab . research . Google . com/drive/14kt 0 slgfphrf _ qel 8 E3 by 7 tfny 0x kzq 5</a></p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="a7f8" class="ll lm it bd ln lo lp lq lr ls lt lu lv jz lw ka lx kc ly kd lz kf ma kg mb mc bi translated">背景</h1><p id="ca7b" class="pw-post-body-paragraph ki kj it kk b kl md ju kn ko me jx kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">提供一些背景知识，说明为什么我们关心截断误差，以及为什么我们需要使用高阶方法来实现更低的截断误差</p><h2 id="2220" class="ms lm it bd ln nc nd dn lr ne nf dp lv kr ng nh lx kv ni nj lz kz nk nl mb nm bi translated"><a class="ae mi" href="https://en.wikipedia.org/wiki/Taylor_series" rel="noopener ugc nofollow" target="_blank">基本泰勒展开式</a></h2><figure class="mj mk ml mm gt no gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/26a2f057ac1b18c95cdf21a2ec5ee368.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/0*2xVqij7NQA3VJLQT.png"/></div></figure><p id="60a4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你对泰勒展开式感到困惑，我推荐<a class="ae mi" href="https://www.youtube.com/watch?v=3d6DsjIBzJ4" rel="noopener ugc nofollow" target="_blank"> 3blue1brown关于这个主题的视频</a></p><h2 id="8d25" class="ms lm it bd ln nc nd dn lr ne nf dp lv kr ng nh lx kv ni nj lz kz nk nl mb nm bi translated">什么是截断误差？</h2><p id="b9ec" class="pw-post-body-paragraph ki kj it kk b kl md ju kn ko me jx kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">从微积分我们知道截断误差是泰勒级数的下一项，展开式的第(n+1)项。也就是说，它们是作为部分和逼近一个无穷和的误差。</p><figure class="mj mk ml mm gt no gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi nr"><img src="../Images/ae24ec1e6bed906c655aeb9930be37c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*08bpM32G-tR5xCKFpD7E_g.jpeg"/></div></div></figure><p id="2c49" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">就计算机而言，有一个术语叫做机器ε或双精度。超过这个精度，计算机就无法区分两个数字。这是机器ε的截断误差，虽然在数学中不被认为是精确的结果，仍然是近似值，但在科学计算中被认为是精确的。</p><figure class="mj mk ml mm gt no gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/565f822926c7d00beae3856312d700c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:158/format:webp/1*BVd_PA-bG9sUdggp0cEwog.png"/></div><p class="nx ny gj gh gi nz oa bd b be z dk translated">机器Epsilon</p></figure><h2 id="7fbe" class="ms lm it bd ln nc nd dn lr ne nf dp lv kr ng nh lx kv ni nj lz kz nk nl mb nm bi translated"><a class="ae mi" href="https://en.wikipedia.org/wiki/Euler_method" rel="noopener ugc nofollow" target="_blank">欧拉法</a></h2><figure class="mj mk ml mm gt no gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/064336388700c690e94a7a1af0cc2cc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:710/format:webp/0*cjrLDD0WKe243iMD.png"/></div></figure><p id="e40d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上式中，h或dx是时间步长。该方程的截断误差为O(h ),这意味着要将误差从e-8减小到e-10，新的时间步长必须比旧的时间步长小e-2。这使得欧拉方法的精度增加极其缓慢。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="81a1" class="ll lm it bd ln lo lp lq lr ls lt lu lv jz lw ka lx kc ly kd lz kf ma kg mb mc bi translated">动机</h1><h2 id="3706" class="ms lm it bd ln nc nd dn lr ne nf dp lv kr ng nh lx kv ni nj lz kz nk nl mb nm bi translated">为什么收敛速度很重要？</h2><p id="7981" class="pw-post-body-paragraph ki kj it kk b kl md ju kn ko me jx kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">现在有人可能会问，为什么收敛速度很重要。除了更高的收敛速度会减少大型计算的等待时间这一事实之外，还有另一个原因。原因是我们面临的另一个误差，叫做舍入误差。</p><blockquote class="oc od oe"><p id="fc75" class="ki kj of kk b kl km ju kn ko kp jx kq og ks kt ku oh kw kx ky oi la lb lc ld im bi translated"><strong class="kk iu">舍入误差</strong>、<a class="ae mi" href="https://en.wikipedia.org/wiki/Round-off_error#cite_note-1" rel="noopener ugc nofollow" target="_blank">【1】</a>也称为<strong class="kk iu">舍入误差</strong>、<a class="ae mi" href="https://en.wikipedia.org/wiki/Round-off_error#cite_note-2" rel="noopener ugc nofollow" target="_blank">【2】</a>是给定<a class="ae mi" href="https://en.wikipedia.org/wiki/Algorithm" rel="noopener ugc nofollow" target="_blank">算法</a>使用精确算法产生的结果与相同算法使用有限精度舍入算法产生的结果之间的差异。</p></blockquote><p id="2b8f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这实质上意味着我们做的每一个计算，每一个时间步，都会有一点点误差。时间步长越多，我们执行的计算越多，舍入误差就越大。存在一个舍入误差将超过截断误差的点，执行更多的计算将使结果值不准确。</p><figure class="mj mk ml mm gt no gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi oj"><img src="../Images/7ebb0439b70398a282f2811cda1533cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w644FYVa4eBRKdJw3lSPLw.png"/></div></div></figure><p id="696d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的例子突出了两种不同近似的截断误差和舍入误差，一种用紫色表示截断误差～h，另一种用黄色表示截断误差~h⁴。</p><h2 id="4586" class="ms lm it bd ln nc nd dn lr ne nf dp lv kr ng nh lx kv ni nj lz kz nk nl mb nm bi translated">低阶方法的问题(欧拉方法)</h2><p id="7376" class="pw-post-body-paragraph ki kj it kk b kl md ju kn ko me jx kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">请注意，在上图中，截断误差为2 ~h阶的紫色图(类似于欧拉法)比高阶的黄色图精度低得多(截断误差更高)。</p><p id="a6a1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是因为误差仅以二次方式缩放，也就是说，如果将时间减少一半，误差会减少四分之一。而4阶的高阶方法，同样将时间步长减少一半，所得误差将减少十六分之一。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="25dd" class="ll lm it bd ln lo lp lq lr ls lt lu lv jz lw ka lx kc ly kd lz kf ma kg mb mc bi translated">寻找高阶方法</h1><p id="9e6e" class="pw-post-body-paragraph ki kj it kk b kl md ju kn ko me jx kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">这种方法适用于任何订单；然而，在本帖中，我们将重点关注4阶方法，特别是RK4。</p><p id="e6e6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们将泰勒展开式扩展到我们所希望的阶，我们将得到高阶方法。</p><figure class="mj mk ml mm gt no gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi ok"><img src="../Images/207f59b8798773d98116c5ada06453a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gsqxz7DxtsNhsmp6odhCIg.png"/></div></div><p class="nx ny gj gh gi nz oa bd b be z dk translated"><a class="ae mi" href="https://www.youtube.com/watch?v=hGN54bkE8Ac" rel="noopener ugc nofollow" target="_blank">四阶龙格-库塔法</a></p></figure><p id="0d08" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，通常很难对微分方程进行微分以得到d/dx(f(x))，但是不同的数学家发现了不同的四阶方法，本文将重点介绍的一种方法是由Runge发现的，它被称为RK4。</p><figure class="mj mk ml mm gt no gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/aa52f8d5dd372694bfe5717c1127167e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1154/format:webp/1*UejksdF9adatfjQkzaY8zg.png"/></div><p class="nx ny gj gh gi nz oa bd b be z dk translated">RK4方法</p></figure><figure class="mj mk ml mm gt no gh gi paragraph-image"><div class="gh gi om"><img src="../Images/339ec1d0ec864c87db986d2ed2b77597.png" data-original-src="https://miro.medium.com/v2/resize:fit:926/format:webp/1*JOgBySr6Jl5LNIQLqXq6sQ.png"/></div><p class="nx ny gj gh gi nz oa bd b be z dk translated">RK4坡度估计值/权重</p></figure><p id="5322" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该函数具有截断误差~O(h⁴，这意味着从e-8移动到e-10，时间步长的差异将是∜(e-2，这将使计算量低得多。</p><p id="a499" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章中，我不会太深入地研究数学，因为我相信在计算机科学中有很多实际的应用可以在不深入理解基础数学的情况下实现。我链接了下面的资源来帮助更好地理解<a class="ae mi" href="https://www.youtube.com/watch?v=hGN54bkE8Ac" rel="noopener ugc nofollow" target="_blank">数学。</a></p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="3c47" class="ll lm it bd ln lo lp lq lr ls lt lu lv jz lw ka lx kc ly kd lz kf ma kg mb mc bi translated">解微分方程</h1><p id="4da5" class="pw-post-body-paragraph ki kj it kk b kl md ju kn ko me jx kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">最后，有趣的部分开始了，所以我们必须选择我们要解决的微分方程系统。我将展示一个更复杂的微分方程系统的例子，因为这将涵盖解决更简单的系统所需的技能。</p><p id="5372" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们今天要求解的系统是洛伦兹系统，更普遍的说法是蝴蝶效应。</p><figure class="mj mk ml mm gt no gh gi paragraph-image"><div class="gh gi on"><img src="../Images/145e53d1011b8392c630ce4431ecee70.png" data-original-src="https://miro.medium.com/v2/resize:fit:446/format:webp/1*xR57qzQHp96sxwlfTjEI-g.png"/></div><p class="nx ny gj gh gi nz oa bd b be z dk translated"><a class="ae mi" href="https://en.wikipedia.org/wiki/Lorenz_system" rel="noopener ugc nofollow" target="_blank">洛伦兹系统</a></p></figure><figure class="mj mk ml mm gt no gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/ee63f252452bbd34e402b00e225a2d25.png" data-original-src="https://miro.medium.com/v2/resize:fit:448/format:webp/1*QVjUNhvO-c0n-jMRYfHh4A.png"/></div><p class="nx ny gj gh gi nz oa bd b be z dk translated">常量的值</p></figure><figure class="mj mk ml mm gt no"><div class="bz fp l di"><div class="op oq l"/></div><p class="nx ny gj gh gi nz oa bd b be z dk translated"><a class="ae mi" href="https://gist.github.com/CryogenicPlanet/04f4f580581488516662795373e5d859" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/cryogenic planet/04f 4f 580581488516662795373 e5d 859</a></p></figure><p id="003f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码片段执行单个时间步长的操作，即dt以向量的形式在[dx，dy，dz]中移动。把它看作一个向量运算会更容易理解，这就是NumPy的亮点，它允许你把这个时间步长作为一个向量函数来求解。</p><p id="d086" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的函数是一个通用的rk4，时间步长，它对于高效求解高阶微分方程是必不可少的，然而，为了求解Lorenz系统，我们需要设置一些其他函数来使用这个公式。</p><p id="0077" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，让我们用洛伦兹系统的常数建立函数dx，dy，dz</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="64d3" class="ms lm it mo b gy mt mu l mv mw"># Constants of the Lorenz System<br/>b = 8/3<br/>s = 10<br/>r = 28</span><span id="c239" class="ms lm it mo b gy or mu l mv mw"># Functions dx,dy,dz of the Lorenz System</span><span id="7961" class="ms lm it mo b gy or mu l mv mw">def dx(t,x,y,z):<br/>    return s*(y-x)</span><span id="e60f" class="ms lm it mo b gy or mu l mv mw">def dy(t,x,y,z):<br/>    return x*(r-z) -y</span><span id="c35e" class="ms lm it mo b gy or mu l mv mw">def dz(t,x,y,z):<br/>    return x*y - b*z</span></pre><p id="8a86" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在做一个函数来计算洛伦兹系统的点</p><figure class="mj mk ml mm gt no"><div class="bz fp l di"><div class="op oq l"/></div><p class="nx ny gj gh gi nz oa bd b be z dk translated"><a class="ae mi" href="https://gist.github.com/CryogenicPlanet/e07988808d14be57334c1ef6d8112e09" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/cryogenic planet/e 07988808d 14 be 57334 C1 ef 6d 8112 e 09</a></p></figure><p id="de8a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们可以从退出部分开始，图形化和可视化数据。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="dc40" class="ll lm it bd ln lo lp lq lr ls lt lu lv jz lw ka lx kc ly kd lz kf ma kg mb mc bi translated">以3D方式可视化数据</h1><p id="a6f6" class="pw-post-body-paragraph ki kj it kk b kl md ju kn ko me jx kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">这里我们将使用我们之前导入的Axes3D模块。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="7449" class="ms lm it mo b gy mt mu l mv mw">#Calling the previous function arbitrary start points</span><span id="bc48" class="ms lm it mo b gy or mu l mv mw">x,y,z = lorenz(0,1,1.05,0,0.01)<br/>fig = plt.figure(figsize=(12,10))</span><span id="e9b3" class="ms lm it mo b gy or mu l mv mw"># This is how we set the 3D plot<br/>ax = fig.gca(projection='3d')</span><span id="69a1" class="ms lm it mo b gy or mu l mv mw"># Plotting the values<br/>ax.plot(x, y, z, lw=0.5,alpha=0.7)<br/> <br/># Plotting the final values<br/>ax.scatter(x[-1],y[-1],z[-1],color=(1,0,0))</span><span id="4a0c" class="ms lm it mo b gy or mu l mv mw">#Very slightly different starting values<br/>x_1,y_1,z_1 = lorenz(0,0.9,1.04,0,0.01)</span><span id="0698" class="ms lm it mo b gy or mu l mv mw">#Plotting slightly different starting values<br/>ax.scatter(x_1[-1],y_1[-1],z_1[-1],color=(0,0,0))</span><span id="b2db" class="ms lm it mo b gy or mu l mv mw">#Setting Axis Titles<br/>ax.set_xlabel("X Axis")<br/>ax.set_ylabel("Y Axis")<br/>ax.set_zlabel("Z Axis")<br/>ax.set_title("Lorenz Attractor")</span></pre><figure class="mj mk ml mm gt no gh gi paragraph-image"><div class="gh gi os"><img src="../Images/5f32344481e0f1e2e300650b4065fc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/1*6v13Ximb1q47tY_UoNVBcw.png"/></div><p class="nx ny gj gh gi nz oa bd b be z dk translated">上面函数调用的情节</p></figure><p id="3ce2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这凸显了洛伦兹系统固有的混沌现象，即略微不同的起始值会产生截然不同的终点。同样，这篇文章不是关于洛伦兹系统的资源，你可以在这里了解更多<a class="ae mi" href="https://en.wikipedia.org/wiki/Lorenz_system" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Lorenz_system</a></p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="7a4e" class="ll lm it bd ln lo lp lq lr ls lt lu lv jz lw ka lx kc ly kd lz kf ma kg mb mc bi translated">概述</h1><ul class=""><li id="34e0" class="ot ou it kk b kl md ko me kr ov kv ow kz ox ld oy oz pa pb bi translated">创建你的微分方程作为函数</li><li id="d9de" class="ot ou it kk b kl pc ko pd kr pe kv pf kz pg ld oy oz pa pb bi translated">用RK4作为向量求解微分方程组</li><li id="5d37" class="ot ou it kk b kl pc ko pd kr pe kv pf kz pg ld oy oz pa pb bi translated">创建rk4中所有点的列表</li><li id="1432" class="ot ou it kk b kl pc ko pd kr pe kv pf kz pg ld oy oz pa pb bi translated">使用Axis3D和matplotlib绘制3D点</li></ul><p id="d299" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">再一次，我强烈建议您亲自尝试一下这些代码，您可以登录<a class="ae mi" href="https://colab.research.google.com/drive/14KT0sLGFphRF_QeL8e3by7tfNY0xkzq5" rel="noopener ugc nofollow" target="_blank">https://colab . research . Google . com/drive/14kt 0 slgfphrf _ qel 8 E3 by 7 tfny 0x kzq 5</a></p></div></div>    
</body>
</html>