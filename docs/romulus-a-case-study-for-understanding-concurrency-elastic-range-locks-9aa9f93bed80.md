# Romulus:理解并发性和弹性范围锁的案例研究

> 原文：<https://towardsdatascience.com/romulus-a-case-study-for-understanding-concurrency-elastic-range-locks-9aa9f93bed80?source=collection_archive---------58----------------------->

## 超越一维串行程序，开发多核世界

下面的文章希望通过构建一个调度器(名为 Romulus)的案例研究，将读者带入一个并发性、弹性和现代计算趋势的旅程，该调度器可以自动将任何串行数据结构转换为高性能的并发键值存储。通过将分布式计算和数据库设计的概念引入本地内存，范围锁的分析和可扩展性方面的新范例将形成一系列简单而强大的治理原则，这些原则根据目标争用的功能对数据进行分区和保护。

![](img/2932f5d70d8d5163e85a22dbbba51b11.png)

来源:迈克尔·克里姆根 via [Baeldung](https://www.baeldung.com/lock-free-programming)

# 介绍

正如 ASP los’17 的最佳论文所描述的:

> 并发数据结构被用在软件栈中的任何地方，从内核(例如，用于调度的优先级队列)，到应用程序库(例如，尝试存储器分配)，到应用程序(例如，用于索引的平衡树)。这些数据结构效率低下时，会降低性能。”Calciu et。铝

直到最近，由于单核机器的大规模改进，计算机的能力才得以复合。性能界限每两年翻一番，由于当时的应用程序还不够先进，无法满足现代高性能计算的要求，因此串行程序主宰了应用层。渐渐地，摩尔定律的经典形式消亡了。为了重振它的趋势，程序员开始将他们的工作负载分布在同步的资源上，并分配到专门的计算单元中(你好，GPU)。今天，计算不再由一维的串行程序来定义。相反，软件已经超越了本地内存寄存器的逻辑，进入了多个内核，在这些内核中，它们必须在可变的位置和时间下，在它们的并发事务中遵循某种形式的一致性和治理。

![](img/fcd919f0a2724f066dcdb552365a256b.png)

来源:[卡尔·鲁普](https://www.karlrupp.net/2018/02/42-years-of-microprocessor-trend-data/)

简单的同步技术，比如粗粒度锁，提供了一种简单但不可扩展的方法来管理共享内存。另一方面，细粒度的异步技术对于普通开发人员来说可能过于复杂。开发这些内核对于构建任何高性能计算环境的基础至关重要。但是为什么不为所有的应用程序开发商用硬件的全部功能呢？希望这个案例研究可以为日常开发人员提供一个新的理解，从基本原则的角度来构建并发系统并分析其中的性能。对于更有经验的开发人员，该研究提出了一种更强大的范围锁方法，该方法利用基本的启发式算法，在任何不平衡的工作负载下主动地追逐和收敛到争用级别。如果你还在阅读，系好安全带准备长途旅行。

# 形式摘要

以下摘要将构成开发和表征 Romulus 的指南:

> Romulus 在每个事务中注入一个调度器，以消除一系列弹性分区之间的争用，通过自适应读取-复制-更新(RCU)来同步这些库，并为所有工作负载提供稳定的执行状态。Romulus 的设计灵感来自 MapReduce:一个简单的框架，它并行地编排各种任务的处理，利用状态空间的全局视图来分布和管理跨资源的通信。Romulus 的主要目的是自动将任何串行 API 翻译成并发数据结构，同时达到手工制作的最先进算法的性能。然而，它最重要的贡献是一组竞争试探法，为系统提供了向目标竞争级别收敛的能力。更详细地说，Romulus 通过采用一种新颖的锁设计，根据实时线程冲突来拆分和合并分区，从而快速适应不平衡的工作负载。因此，这种方法可以扩展到其他应用程序中，在这些应用程序中，当不对称的工作负载超越其系统时，稀缺资源必须在线适应。此外，Romulus 通过提供一种在有序键值存储中进行有效范围查询的算法，将数据库设计中的概念引入本地内存。总的来说，Romulus 提出了一种调度算法，通过即插即用部署模型实现可预测的并行性。

有三个基本目标将推动该调度器架构中的决策:

(1)可扩展到任何有序键值存储的简单方法，也接近最先进的手工解决方案的性能(2)保证跨所有操作(包括范围查询)的可序列化性
(3)通过冲突试探法可预测的争用
(4)对不对称工作负载的强大容忍度

![](img/dd7c41bb10005dfcc68f7e7d57bd4766.png)

最终设计预览

# 箱子/球的理论原理

眼前的基本问题是一个调度问题:如何将输入连接到计算资源的公平分布(类似于 MapReduce ),该计算资源以预定义的争用级别为目标，并通过数百个线程进行扩展。摘要暗示 Romulus 将把数据分成一系列分区。因此，在进入 Romulus 的设计之前，对需要多少个分区来达到冲突率的第一原理分析可以(I)明确所追求的平衡/行为(ii)快速揭示性能预期。此外，它将提供一个(非常松散的)正式模型，通过将 Romulus 上的预期冲突映射到单个分区中的测量来证明争用的收敛性。正如后续章节所揭示的，当线程确定一系列离散测量违反了分区的预期阈值时，它们会将分区分成两半，以消除争用并适应不平衡的工作负载。因此，以下部分对我们的第三和第四个目标至关重要。

数学分析是通过对球中的经典箱问题的先前工作的垂直整合形成的:将 M 个球放入 N 个箱中的概率结果。这个模型以前已经在计算机科学中以多种形式应用于负载平衡。

![](img/e40745635a2446f86a00314501e28fdc.png)

箱柜/球数学模型

在最基本的模型中，M 个球通过一个随机函数——产生一个均匀分布——并被放入 N 个箱子中的一个。以下部分集中于理解三个重要现象:(I)观察不到碰撞的概率(ii)在单个箱中观察到大于 K 的高度的概率(iii)在所有 N 个箱中观察到大于 K 的高度的概率。这将有助于我们理解与线程相比，如何扩展分区的数量。

## **第一种情况:观察不到碰撞的概率**

![](img/23a7fbad6d8c22eac01343b0d54c737c.png)

[生日悖论](https://en.wikipedia.org/wiki/Birthday_problem)再次上演

如果我们让 X 表示在所有箱中没有观察到碰撞的概率，并假设 M ≤ N，那么通常 M 个球必须放置在 N 个唯一的箱中。通过采用泰勒级数近似，并将其限制在一个可忽略的误差范围内(已知 u = 1/N 很小)，我们可以这样估计 Pr[X]:

![](img/2b397cd09bf7ab9354725a7f9dbf0690.png)

对于常数 Pr[X] = C，可以看出 C = O(m/n)；也就是说，为了保持恒定的无冲突概率，箱的数量必须以 n = 0(m)的比率缩放

## **第二种情况:一个箱内的碰撞**

![](img/e2064060e8efeb76f6b7375ff486a29b.png)

设 Pr[Xi ≥ K]代表在单个 Xi 中至少 K 次碰撞的概率。这可以表示为:

![](img/42b36028e59eadaf858ee5d46ab53d59.png)

对于常数 Pr[xi ≥ K] = C，如果 N ≥ M，则保持恒定期望高度所需的面元必须按比例缩放到 N = O(M)。无论输入的绝对值如何，对于 N = M，该预期高度保持相对恒定。

## 第三种情况:N 个箱的 K 次碰撞

![](img/626119e2ed06bc5baa0cde5880aa9f61.png)

设 Pr[X ≥k]表示在所有 N 个面元上至少发生 K 次碰撞的概率。假设 M= O(N ),并且每个面元彼此独立，则通过并集规则形成上界:

![](img/a57684b17e752cc8563d6feb3c1a320d.png)

我们估计 M:N 的比值为 1。虽然在 M:N = 0.1 的未来讨论中可能不会出现这种情况，但上限仍将在这种情况下成立，并为进一步的数值分析提供足够的背景。应用这个比值，可以发现当 N(因此 M)一起向更大的值增加时，K 如何变化:

![](img/686f9ca17478bd4fa3ad935f71950a93.png)

为什么 K 的预期值在单个容器中保持不变，但随着 N 和 M 一起缩放，一系列容器的预期值会增加？从逻辑的角度来看，随着我们增加出现差异的机会，我们增加了 K 在任何单个桶中远远超出其预期高度的机会。

## 结果

这些推导对罗慕路斯的三个期望很重要:

(I)为了保持不发生冲突的恒定概率，必须以 N = O(M)的比率相对于球的数量指数地缩放容器的数量。Romulus 不会遵循这种方法，因为这对于高线程数是不切实际的，因此，调度器不会试图消除所有冲突

(ii)如果将容器的数量与球的数量成线性比例，则每个容器中球的预期平均高度保持不变。但是，对于较大的 N 和 M 值，由于方差的性质，在热点中任何离散时间点的冲突可能更高。注意 Romulus 将遵循这个模型，因此，它将试图保持一个目标冲突率

(iii)当从单个仓构建整个系统的视图时，假设工作负载一致，可以创建关于系统状态的置信区间。更具体地，通过测量单个箱柜上的 K(即球队列的高度)，可以确定其值是否持续违反阈值并超过概率。如果是这样的话，调度器应该预测一个偏斜的工作负载已经超越了系统并违反了均匀分布假设

毫无疑问，这是一个超级粗糙的模型(带有许多未言明的假设)，但对于理解未来的总体趋势很有帮助。

# 数值分析

让我们将这个旧的视图转换成一个线程对库执行更新操作的新视图

![](img/38b4c2c24ff6690d830728cf3fdb35a3.png)

下一节在线程在一系列分区上执行更新操作的理论环境中，证实了箱成球问题的理论趋势，并揭示了并发环境中两个明显的锁现象:(1)将锁分区减少到更细粒度的范围(即增加箱的数量)对于消除争用具有递减的回报(2)作为结果，给定无限资源的最佳理论配置是将锁的数量最大化到尽可能最小的分区中。然而，在许多情况下，系统只有少量的资源可以消耗。因此，利用范围锁来实现适当的并行性，而没有 40 字节 pthread_lock_t 的内存开销。**然而，最重要的是，由于向更细粒度的范围减少锁分区具有递减的回报，Romulus 理论上可以利用更少数量级的锁，同时在许多场景中仍然接近手工制作的性能。**

为了将经典的箱柜转化为球的问题建模，我们形成了值域锁的概念；存在一个 N 个仓的锁表——代表一系列 N 个抽象分区——它独立于底层存储层的实际大小。线程的数量代表了球的数量，它们通过即时插入/移除来跨这些分区操作。为了观察争用超时，我们对一个无限的迭代游戏建模如下:

1)在游戏开始时，线程被随机放入一个分区/箱(即锁)

2)每个分区都有一个等待完成的操作队列。对于游戏中的每一轮，一个线程充当系统中的并行代理。队列前面的所有线程都被清空，将自己回收到另一个分区中。他们通过遵循均匀分布的随机数生成来选择下一个分区。这表示一个线程获得一个分区的所有权，执行一个操作，释放该区域，然后继续下一个操作。所有不在队列前面(即在队列中其他线程后面)的线程不执行任何动作，而是等待，直到它们在未来的循环中移动到队列的前面。

3)游戏永远重复自己，类似于真实的系统

该模型有许多重要的假设，最明显的是:所有操作都是瞬时的，每轮完成一次，工作负载具有均匀分布，并且消除了内存访问、线程间通信和其他特定于体系结构的开销的可变性。当然，真实的系统有资源限制，比如内存和 I/O，它们会改变价值等式。然而，正如未来的测试床所揭示的，总体趋势保持不变，并为分析奠定了基础。实验在 Python 中以 10K、100K 和 1M 回合进行。无论游戏时间长短，结果都趋向于相同的值

![](img/7eaadf169ff69db611ae146c97add93f.png)

左边的两个图描绘了在两种极端设置下游戏每一轮的队列高度，希望提供高争用与低争用环境中冲突变化的定性说明。第一张图片展示了一个有 64 个线程和 48 个分区的游戏。第二个图像表示一个游戏，有 64 个线程和 640 个分区。

在第一个游戏中，我们可以看到当分区数量太少时可能发生的灾难性影响。在第二场比赛中，虽然存在许多争夺点，但绝大多数操作都没有冲突。下面的实验将计划第二种情况，Romulus 试图模仿这种情况以获得更好的并行性/性能。

![](img/f69298402b760f95b3f4264b6a99faf2.png)

在该图中，我们将活动队列的平均高度定为 1.05，并绘制了在不同线程速率下达到该高度所需的分区数量。这是通过以恒定的 100K 回合玩一些游戏并发现产生适当平均高度的最接近的分区数目来计算的。本实验的目的是了解如何在线程间保持目标争用级别；从结果和先前的分析可以确认，对于 M / N <1，必须将分区的数量缩放为线程数量的线性函数。

![](img/edfe377304865c474a21b3a4576f66bf.png)

在该图中，我们重申了这一点，并假设分区数量为 10 *个线程，将平均高度表示为线程数量的函数。包含了锁的最佳数量(底层结构的大小，表示为 1M ),以展示两种方法的一致差异

![](img/eea4efaa097cc7a9a6e6cab5339b4e64.png)

最后，这最后一个实验说明了增加分区在消除争用方面的好处在减少。从逻辑上讲，这是有道理的。有一个箱子和 64 个球，一个箱子可以装 64 个球。随着两个箱子的增加，球平均分裂，平均高度达到 32。有了四个容器，球再次均匀分裂，但体积仅从 32 个容器减少到 16 个容器。因此，随着时间的推移，分离的边际量继续减少。

这些图表揭示了罗穆卢斯争用计划的首要原则中的重要期望。**首先也是最重要的，Romulus 在理论上永远无法击败手工制作的经典读/写工作负载，它表现出两个特征:( 1)无等待遍历;( 2)每个元素一个锁;( 3)搜索成本相当于转换层。这是因为 Romulus 并不试图消除其系统中的所有竞争**；它在某种程度上限制了并行性，即在一系列元素上获取所有权，将粗粒度的锁分布在更小的分区上。因此，它将遭受更多的争用，导致冲突线程的性能下降一个数量级。然而，实际上，达到合理的并行水平所需的范围数量将比元素数量小一个数量级(假设 10 *线程< <映射大小)

# 回到设计罗慕路斯:方法论

Romulus 将代表一个调度器，它将一个抽象数据结构分割成一系列弹性分区。这些容器不限于任何大小，而是动态地适应来自应用程序线程的不相等的力。对于有序的键值存储，这些分区代表一系列键。假设程序员总是为有序的键值存储提供 API。

![](img/06b19ef917d7470772e9ecfd273d0ad4.png)

罗慕路斯的抽象方法论

塑造 Romulus 需要三个重要的层:**适应性翻译层、数据层和同步层**。在翻译层，算法必须为给定的输入键产生适当的分区。但是，它不应该表示类似于哈希映射的静态范围集，因为人们必须反射性地修改分区以展平倾斜的输入。在数据层，程序员为添加、包含和删除提供了一个抽象 API 来存储和访问一个元素。同步层确保操作的严格可串行化，并且通常跨转换层和数据层集成自身；这对于在每个分区中创建隔离和其他可序列化保证非常重要。对于图中描述的方法，我们利用读取-拷贝-更新(RCU)并创建两个数据拷贝。写入者视图(数据的活动部分)是写入者独立执行更新操作的状态空间，并且需要一个互斥锁。读者视图(数据的副本部分)使读者能够继续无等待地遍历系统。因此，Romulus 中的争用只来自更新分区的写线程。这就是为什么我们没有把读者包括在上面的数字分析中。

罗穆卢斯的方法论为其具体实现产生了许多变体；也就是说，它可以被视为一种抽象和模块化的并发方法(但最适合于有序的键值存储)。因此，从程序员的角度来看，此后的算法集中于优化性能，尽管仍然存在许多其他的适应，并提供正确的语义。在定义 Romulus 的具体实现之前，调度算法必须首先应用优先竞争分析的原则来决定如何最初划分范围，并求解阈值，使 Romulus 能够动态适应偏差输入。

## 应用竞争试探法

在 Romulus 中，偏斜的输入分布可以被描述为导致争用的输入操作的不平等加权。这意味着不对称是通过两种现象形成的:(I)不同权重的操作(ii)非均匀的访问分布。在基于违反竞争试探法来分割范围时，罗穆卢斯方法对歪斜的原因是不可知的，只是作为一种反射力

为了将锁队列的平均高度定为 1.05(理论上)，系统分成 10 * t 个分区，其中 t 是应用程序中的线程数(这在实践中证明效果很好，尽管常数会根据机器的具体情况而变化)。在执行过程中，Romulus 遵循两个简单的启发式方法来分割/合并范围:

(1)如果应用程序线程测量到竞争高于阈值 K，则它们在应用它们的更新操作之前将一个范围分成两个新的分区。k 是通过将 95%的置信区间应用于先前的理论分析和新的假设 N = 10 * M 来确定的，其中 N =分区的数量，M =线程的数量:

![](img/ed3b16649a8eaa6b790428183e387898.png)

在队列中等待的线程数量的测量有很大的差异，特别是当系统中线程和分区的数量增加时，正如之前所看到的那样。因此，Romulus 通过强制线程投票赞成拆分来减少误报的数量，并且在投票被批准后，拆分继续进行

(2)在获得一系列范围的访问分布之后，当两个分区的邻域被访问的次数低于每个分区的平均访问次数的 2 倍时，后台线程将合并这两个分区。虽然合并很重要，但它可以被视为节省资源的一种方式，而不是提高任何操作的吞吐量(未来的分析表明它不会影响范围查询性能)

# Romulus 实现

![](img/dd7c41bb10005dfcc68f7e7d57bd4766.png)

这描绘了 Romulus 的标准实现的快照，而一个不对称的工作负载在一段时间内超越了系统。Romulus 的目标不是创建一个每个元素都有一个锁的散列映射，而是节省资源并在面对范围查询时表现良好。

转换层被实现为定制的散列树。线程将散列到的树的级别是具有完整的内部分区集的最底层。

数据层是有序的键值存储；有效支持范围查询的要求。

同步层利用 RCU 的自定义适应，特别是在提交协议中，以便在范围查询和单个元素操作中为读者进行优化。同步层深入到转换层，在转换层中存储了一个原子计数器，以便向写线程通知执行一个范围的分区的范围查询的数量。在 Romulus 的抽象需求中，翻译层中的上层树——从分区集向上构建——是不必要的。然而，为了跨分区同步范围查询，该模型扩展了 Romulus 的要求，并形成了一个称为 CRRQS(跨区域范围查询)的上层。接下来的几节从工作负载的要求和对堆栈的更深层次的影响开始，详细介绍了每一层的重要方面。

## **批量操作(范围查询)**

为了提供可序列化的范围查询，Romulus 通过集成多粒度同步从数据库中引入概念。有两种极端的优化方法:基于锁的查询和无锁范围查询。对于跨许多单独分区的大范围查询，基于锁的实现会导致显著的性能下降，同时在各种类型的操作之间实现了公平性。例如，系统可以在活动分区中实现读写锁，阻止更新发生，直到完成它们的操作。获取一系列这些锁的开销对于实际应用来说太高了。因此，在实验开始时，Romulus 在分区的顶部构建了一个上层树层，其中表示要同步的范围的粒度。当范围查询想要在一个范围内操作时，它从较高的树层的根向下搜索，直到找到符合其界限的最小范围。此后，范围查询自动递增节点中的计数器，并继续执行其操作。这向系统中的所有其他代理发出正在执行范围查询的信号，通过将必要的状态集中到单个位置，以恒定成本在无锁机制中同步这些操作。下面讨论提交操作对写线程的影响。尽管如此，范围查询线程的两个附加方面是，它们必须在操作开始时读取指示时间戳的全局纪元，并且它们必须使用该时间戳来指示是否用分区上的最近操作来更新它们的结果。不过，这一需求的成本是不变的，不会对大型查询产生显著影响。

## RCU

在 Romulus 中使用读取-复制-更新(RCU)作为同步机制具有重要的二阶效应。首先，它使读操作能够无锁地访问分区。其次，它需要额外的存储空间和操作开销。Romulus 的翻译层中的一个分区通过以下元数据表示(不包括指向树中左右子节点的指针):

![](img/c05b1726ea67afcf24cc1ed06fa3b2e5.png)

因此，调度程序将数据复制到称为副本和活动的两种结构中。复制指针为读线程提供进入底层存储层的入口，而活动指针为写线程提供进入另一层的入口。在经典的 RCU 算法中，人们会将手头的内存复制到一个线程本地地址，并在提交之前隔离执行操作。在此实现中，已经提供了数据，以避免每次更新时复制大范围内存所带来的存储和计算成本。相反，为了保持操作的可序列化性，编写器线程遵循不同的操作序列。首先，写线程通过自定义互斥体获得分区的所有权。这个互斥体包含一个“无效”状态，它表示先前发生了一个合并/拆分操作，以及争用锁的写入程序的数量。假设没有任何东西被无效，并且不需要发生合并/拆分，写线程在活动数据结构上执行其更新操作。此后，当且仅当提交操作有效时，写线程执行原子比较和交换(CAS)以用新鲜状态替换副本指针。这表示更新操作的线性化点。由于调度器知道活动结构上的更新操作的结果，当且仅当操作返回真(即，成功地更新了元素)时，线程然后将等待所有读取器线程离开旧的副本，然后在执行相同的操作时将其陈旧的结构更新到新的状态。完成后，线程完成两个分区到较新版本的复制，并释放锁。RCU 操作中的一个关键点是确定提交操作是否有效。在经典的 RCU 算法中，写线程不需要等待系统中的其他代理提交。相反，提交操作以非阻塞方式进行。当范围查询被启用时，写线程必须确保当它认为范围查询可能在它的分区上操作时，它没有执行更新操作。为了确定范围查询是否依赖于分区，编写器向上遍历翻译层，并检查每个父级没有范围查询，如下所示:

![](img/a08141f6be4b8bbdb61c3609de076328.png)

如果它继续通过这个依赖路径，并且似乎没有范围查询发生，那么写线程将认为提交操作是有效的。当更新线程遍历从叶到根的路径中的元素时，出现了一个问题，并且范围查询此后在写入者的路径视图中以较低级呈现陈旧状态开始:

![](img/ed7efa69da0030f998e6d8815298055a.png)

这个问题有一个简单的解决方案。在提交更新之前，范围查询会将操作记录到分区的 MRO 中，并带有相应的全局时间戳。在范围查询记录了它对分区的读操作之后，它将检查时间戳。如果发现节点的时间戳违反了范围查询的时间戳，那么它将撤销其本地记录中最近的操作。因此，范围查询要么不会遇到更新冲突，要么能够在没有太多开销的情况下解决它。重要的是要注意，在与上述相同的条件下，如果另一个写线程希望更新该分区，它将不会提交另一个操作(这将覆盖 MRO ),直到范围查询完成，因为它肯定会在路径的更新版本中看到范围查询的信号。因此，可以说写线程将一直延迟自己，直到不再需要 MRO，并且它可以替换 MRO，而没有进一步的影响。毫无疑问，上面的实现针对大量读取的实验进行了优化，在这些实验中，范围查询跨一系列分区执行。写操作不仅要花更长的时间通过从叶到根的路径来提交操作，而且还会因为阻塞范围查询而被饿死。

## 哈希树

散列树代表 Romulus 中的转换层:给定一个输入键，它提供存储该键的分区。对于读/写操作，调度器首先散列关键字，以便为线程提供要遍历的初始起始级别。哈希层的位置不会影响正确性，但会影响性能，并希望通过从较低的节点开始来降低转换层搜索成本。从这里开始，线程必须向下搜索，直到到达对应于保存其键的分区的叶节点。树叶代表数据层，包含指向结构的正确指针；它们还被连接起来，以使范围查询能够跨分区线性继续。读取操作无锁进入副本，而写入操作遵循上面的自定义 RCU 算法。但是，在获取锁之前，写线程会增加一个变量，该变量表示分区中写线程冲突的数量。

![](img/5eaf536d4f50c0b9743b1664e30994fb.png)

步骤 1:读取等待队列的大小

然后，写入方记录分区中写入方冲突数量的测量结果。如果度量值高于预先计算的阈值(如前面的分析所示)，那么他们投票决定分割分区。如果获得了足够的投票，一旦任何写线程获得了锁的所有权，它们将执行拆分操作

![](img/1865c49e7247bb1e738ed3d36f1e49ea.png)

第 2 步:通过 fork(K) API 执行一个 split 操作，其中 K 表示要在范围内进行拆分的值。

在活动数据结构内完成拆分操作后，它会通过向当前分区添加两个新叶而传播到哈希树中。两个新的活动分区将实际上被放入叶子的副本指针中，因为这代表了 RCU 原语中预先的提交。从这里开始，由于所有新的读取器都被重定向到更新的结构，写入器线程将等待所有旧的读取器完成，然后对陈旧的副本结构执行相同的操作。最后，线程在自定义互斥体上指示它不再有效，所有竞争的线程重新开始它们的操作，慢慢进入更新的状态空间，并希望均匀地分散在两个新的区域。

![](img/af160191b6521565e6c9248d8f0abc0e.png)

翻译层的自反递归性质

这个过程可以根据需要重复多次，以消除阈值以下的争用。

# 合并/拆分

近年来，在设计跨公共数据结构的合并/拆分操作方面已经开展了许多工作。SkipLists、红黑树、链表和许多其他结构可以执行分割操作，其时间复杂度与它们的搜索操作相同。因此，当程序员在这种假设下提供 fork(K)的实现时，Romulus 中的 split 操作在算法上使其中一个线程完成更新操作的时间加倍(排除范围查询的存在)。上面提供的用于合并/拆分的实现利用应用程序线程来自己识别争用，并通过同步方法在它们的关键路径内执行操作。这在算法中产生了错误分类热点的风险，并且需要精确的阈值模型来衡量。有人可能会说，将这项工作卸载到后台线程可能有意义；然而，进一步的分析表明并非如此。通过助手线程对争用做出异步、迟缓的反应可能有助于系统完全准确地达到稳定状态，但是用单个助手线程识别大型数据结构的热点的时间和复杂性将无法立即解决不平衡的工作负载。干草堆里的一根针的故事。结果，由于持续的冲突，这些线程的并行性会显著降低。因此，在大多数情况下，解决问题的时间可能比应用程序线程自己处理拆分花费的时间更多。此外，更重要的一点是，如果不对称继续变化，那么异步线程将很可能获得冲突的误报，并且可能永远无法解决动态不对称。这扩展到异步估计的更一般的问题，因为竞争的近似变得更加难以为动态系统建模。这种对不平衡工作负载的忽视会给需要跨不同场景弹性的系统带来灾难，因此会阻碍 Romulus 的主流应用。

## 其他注释

从前面的图和未来的分析中可以看出，转换层的形状反映了穿过罗穆卢斯的偏斜分布；也就是说，对于经常发生冲突的热点，Romulus 将深化翻译层，以消除更多范围内的争用。一个要考虑的有趣问题是，给定一个偏斜分布，Romulus 的翻译层是否收敛到一个稳定状态。非常宽松的形式分析和实验结果证明，Romulus 在给定偏斜分布的情况下确实收敛到稳定状态，并且它通过主动适应冲突中的应用程序线程本身的争用来快速收敛。因此，Romulus 将在翻译层实现顺序行为，直到新的偏斜超越系统并强制分区更新。在线系统经常困扰性能的一个方面是内存回收行为:安全地释放内存以供重用。Romulus 已经将内存回收的开销融入了它的分区隔离中；也就是说，不需要向 Romulus 添加任何新的元数据来保护内存的释放。此外，可以同步回收内存，而不是异步回收内存(这是一种常见的方法，它会延迟回收，直到其他线程无法在通往退休元素的路径上继续前进)

## 结果呢

作为一种调度算法，Romulus 中性能的一般趋势应该事先知道:
(1)没有其他瓶颈，如内存，Romulus 将很好地从单线程基线扩展到更高的线程数
(2)倾斜的输入将很快得到解决，并将争用分散到以前的级别

这些在下面的图表和分析中得到证实。另一方面，与竞争对手的相对绩效和其中的垄断案例很难量化；一个人必须遵循一个发现过程。为了准确了解 Romulus 的性能，应该部署一个串行跳表，并与两个手工制作的、最先进的并发跳表解决方案进行比较:NUMASK 和 Herihly。这分别代表了两种最快的无锁和基于锁的结构(至少目前如此)。以下实验中使用的测试平台由一台配备 4 枚英特尔至强白金 8160 处理器的服务器组成，总共提供 192 个线程。有 4 个插槽通过 4 个 NUMA 区(一对一)和 768 GB 内存托管 4 个处理器。所有数字是十次试验的平均值。在实验中，应用程序线程平均分布在 NUMA 区域。注意:竞争对手不提供可序列化的范围查询解决方案，因此我们根据他们的上限进行基准测试，因为他们不安全地遍历结构，并在其批量操作中显示陈旧的结果。尽管如此，对于 200 万大小的数据结构，10%的 500 个预期元素的范围查询、70%的读取和 20%的更新操作，可以观察到以下性能:

![](img/b4e5e98603f07ffa07f31a650922e3df.png)

synchrobench 中的吞吐量比较

该结构在手工制作的解决方案的性能上限方面有很好的伸缩性，直到 60 个线程。尽管如此，罗穆卢斯在即插即用加速器方面做得非常好。它比 Node Replication(ASPLOS ' 17 的最佳论文，从一开始就是报价的来源)更好的一个领域是他们订购的关键价值商店；不过，在堆栈/队列/其他结构中，它会比较差，因为在这些结构中，操作只是从结构的前面和后面弹出来——它们在那里找到了自己的最佳位置。

![](img/b2a349d7f6798b0300d42c83282a519c.png)

在跳过列表键值存储中，NR 由于其复制方法中的单个编写器要求而不能很好地扩展

基准链接列表是一个有趣但无效的实验，因为翻译层卓越的算法性能降低了搜索成本，导致了超线性加速。

既然我们已经知道了在 Skip Lists 中手工制作的方法的性能，那么 Romulus 的其余声明必须针对手边的数据结构进行研究；具体来说，(Romulus 在偏斜分布下的表现如何？(ii)不同的存储桶如何影响更新/RQ 性能？

确定合并/拆分算法成功与否的两个最重要的衡量标准是它适应争用的速度(即解决争用的时间)以及与均匀分布相比对性能的总体影响。罗穆卢斯在这两方面都表现出色。下图拍摄了实验中每毫秒吞吐量的快照，以创建吞吐量随时间变化的视图。应用程序线程在~5 秒钟引入一个偏斜分布，以便观察(1) Romulus 如何适应采用分叉/合并操作的工作负载(2)Romulus 未采用分叉/合并的天真版本的性能增益

![](img/aceb164053e08046bd70276999e43312.png)

这证实，即使罗穆卢斯牺牲了几毫秒的短期性能，系统的长期性能也会因为即将到来的偏差而迅速恢复到接近先前的水平。

对于相同的工作负载，系统的自反性质可以通过在实验结束时查看 Romulus 叶节点中的三个访问分布来描述。下图绘制了(1)输入偏斜(即无分叉/合并时的访问分布)(2)具有 48 个线程和 200 万大小的 100%更新操作的实验结果(即启用分叉/合并时的访问分布),以及(3)给定 Romulus 部署的试探法集，该实验的目标理论结果(K = 3)。它通过查看每个分区的访问百分比(单个分区中观察到的访问/跨分区的总访问)来实现这一点

![](img/06d13d973e61037b65f162835d587575.png)

Romulus 低于理论目标，并且在分区数量上的开销比预期的多，很可能是由于悲观的宽松竞争启发式算法(K = 3)。具有强保证的明确定义的阈值对于 Romulus 收敛到分区的目标最终平衡状态是至关重要的。阈值太高，启发式算法无法正确适应不平衡的工作负载。阈值太低，系统消耗的资源超过初始目标，并且对输入分布进行错误分类。

最后，一个有趣的观察结果是，在分别希望合并和分割范围时，范围查询和更新会产生冲突。下图显示了当增加纯范围查询和更新工作负载的存储桶时，吞吐量如何变化

![](img/a3457bc9835c26ad931d39bcbe9993bc.png)

范围查询 v 根据存储桶更新吞吐量增长。(i) 64 个线程(ii)100 万个大小(iii)完整数据结构的范围查询(iv)对数轴(v)标准化意味着将每个数字除以最大获得值，以限制 0 和 1 内的所有点

总的来说，Romulus 可以用手工制作的最先进的解决方案很好地扩展，并且由于合并/分割算法的自反性质和竞争的概率方法，在偏斜分布下表现得相当好。我希望在这项工作中发现的更多的想法将被正式化，并使其成为现代系统中寻找一种简单的并发方法。

//