<html>
<head>
<title>10 Python built-in functions you should know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你应该知道的10个Python内置函数</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/10-python-built-in-functions-you-should-know-fbd5c879e0ab?source=collection_archive---------28-----------------------#2020-06-07">https://towardsdatascience.com/10-python-built-in-functions-you-should-know-fbd5c879e0ab?source=collection_archive---------28-----------------------#2020-06-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f8ce" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">第2部分—使用示例</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/faec8b7121a932912d5f85b5f6562f63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GUx8tee1xezBN3L6r9q4-g.png"/></div></div></figure><p id="3709" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">功能</strong>是一组允许你执行特定任务的语句。它们对于避免代码重复、使程序更有条理、更易于调试特别有用。尽管你可以随时定义自己的函数，<strong class="kw iu"> Python </strong>提供了多个<strong class="kw iu">内置函数</strong>随时可用。在本文中，我们将详细解释其中的10个功能。我们开始吧！</p><h1 id="fb26" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">1.目录</h1><p id="1ba4" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated"><strong class="kw iu"> dir([object]) </strong>函数返回包含<strong class="kw iu"> Python中任意<strong class="kw iu">对象</strong>的<strong class="kw iu">属性</strong>和<strong class="kw iu">方法</strong>的字符串排序列表。</strong>该函数将单个<strong class="kw iu">对象</strong>作为输入，并有助于获取关于我们可以对该对象执行的操作的信息。</p><p id="0726" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">其中，我们可以使用<strong class="kw iu"> dir函数</strong>与:</p><ul class=""><li id="1e17" class="mn mo it kw b kx ky la lb ld mp lh mq ll mr lp ms mt mu mv bi translated"><strong class="kw iu">内置容器(如字典)</strong></li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="bd8a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如您所看到的，<strong class="kw iu"> dir函数</strong>返回一个列表，其中包含Python中字典可用的所有方法(甚至是魔法方法)。</p><ul class=""><li id="5e42" class="mn mo it kw b kx ky la lb ld mp lh mq ll mr lp ms mt mu mv bi translated"><strong class="kw iu">模块(例如来自Python标准库)</strong></li></ul><p id="356c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在下面的代码块中，<strong class="kw iu"> dir函数</strong>返回在<strong class="kw iu"> glob </strong>模块中定义的所有属性和方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><ul class=""><li id="386f" class="mn mo it kw b kx ky la lb ld mp lh mq ll mr lp ms mt mu mv bi translated"><strong class="kw iu">自己的对象</strong></li></ul><p id="1a47" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们创建了一个名为Rectangle的新类，它通过矩形的高度和宽度来定义矩形。接下来，我们创建这个类的一个实例，名为rectangle_1。然后，我们使用<strong class="kw iu"> dir函数</strong>获取rectangle_1对象的所有属性和方法(包括继承的魔法方法)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="542a" class="lq lr it bd ls lt nf lv lw lx ng lz ma jz nh ka mc kc ni kd me kf nj kg mg mh bi translated">2.列举</h1><p id="1c1b" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated"><strong class="kw iu">枚举(iterable，start=0) </strong>函数将一个计数器添加到一个iterable(例如一个列表)中，并返回一个枚举对象。这个对象可以直接在for循环中使用，每次迭代都获得一个形式为(<strong class="kw iu"> index，item </strong>)的<strong class="kw iu">双项元组</strong>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="cb06" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如上所示，<strong class="kw iu">枚举函数</strong>创建了一个元组的<strong class="kw iu">可迭代对象，它可以直接在指定两个变量的<strong class="kw iu"> for循环中解包。</strong></strong></p><p id="bc63" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">或者，我们可以使用<strong class="kw iu"> next() </strong>函数来遍历<strong class="kw iu">枚举</strong>对象，因为该对象支持<strong class="kw iu">迭代协议</strong>，这意味着<strong class="kw iu"> __iter__ </strong>和<strong class="kw iu"> __next__ </strong>方法都被实现。<strong class="kw iu">下一个函数</strong>每次被调用时都从<strong class="kw iu">枚举对象</strong>返回下一个元组。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="b5be" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了检查<strong class="kw iu">枚举对象</strong>，我们可以通过以下方式使用内置函数<strong class="kw iu"> list() </strong>将其转换为一个列表。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="38e8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">默认情况下，<strong class="kw iu">枚举函数</strong>从0开始计数。但是，在某些情况下，您希望计数器从不同的数字开始计数。我们可以通过在第二个参数(<strong class="kw iu"> start) </strong>中指定索引(整数)来轻松地更改<strong class="kw iu">起始索引</strong>，如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="16dc" class="lq lr it bd ls lt nf lv lw lx ng lz ma jz nh ka mc kc ni kd me kf nj kg mg mh bi translated">3.evaluate 评价</h1><p id="5401" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated"><strong class="kw iu"> eval(expression[，globals[，locals]])函数</strong>执行包含Python代码的字符串并返回结果。这个函数有3个参数:(1) <strong class="kw iu">表达式</strong> , (2) <strong class="kw iu">全局变量</strong>,( 3)<strong class="kw iu">局部变量</strong>。第一个参数包含要作为Python表达式计算的字符串。另外两个参数是可选的，包含全局/局部方法和变量。</p><p id="fe19" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如下图所示，使用<strong class="kw iu"> eval函数</strong>，我们不仅可以对<strong class="kw iu">表达式</strong>求值，还可以调用<strong class="kw iu">方法</strong>和<strong class="kw iu">函数</strong>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="c68c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> eval函数</strong>仅适用于<strong class="kw iu">表达式</strong>，试图将<strong class="kw iu">语句</strong>作为输入将引发异常(<strong class="kw iu"> SyntaxError </strong>)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="b7f2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">虽然<strong class="kw iu"> eval函数</strong>在评估用户引入的<strong class="kw iu">表达式</strong>时很方便，但该函数有重要的<strong class="kw iu">安全缺陷。</strong>用户可以将不受信任的代码传递给<strong class="kw iu"> eval函数</strong>，甚至可以删除您系统中的文件。这个问题的解决方案是通过修改<strong class="kw iu">全局</strong>和<strong class="kw iu">局部</strong>参数来限制<strong class="kw iu"> eval函数</strong>的执行环境。</p><p id="4652" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你想知道更多关于eval函数的信息，我真的建议你看看下面的文章。</p><div class="nk nl gp gr nm nn"><a href="https://realpython.com/python-eval-function/" rel="noopener  ugc nofollow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd iu gy z fp ns fr fs nt fu fw is bi translated">Python eval():动态计算表达式——真正的Python</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">在本教程中，您将了解到:您可以使用内置的Python eval()从一个…</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">realpython.com</p></div></div><div class="nw l"><div class="nx l ny nz oa nw ob ks nn"/></div></div></a></div></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="1020" class="lq lr it bd ls lt nf lv lw lx ng lz ma jz nh ka mc kc ni kd me kf nj kg mg mh bi translated">4.全部</h1><p id="f121" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">当给定的<strong class="kw iu">可迭代</strong>(例如一个列表)中的所有元素都为真时，<strong class="kw iu"> all(iterable) </strong>函数返回<strong class="kw iu"> True </strong>。如果不是，则返回<strong class="kw iu">假</strong>。</p><p id="6cb8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在Python中，以下值被视为<strong class="kw iu">假</strong>(假值):</p><ul class=""><li id="55d2" class="mn mo it kw b kx ky la lb ld mp lh mq ll mr lp ms mt mu mv bi translated">没有人</li><li id="98f7" class="mn mo it kw b kx oc la od ld oe lh of ll og lp ms mt mu mv bi translated">False(布尔类型)</li><li id="4d42" class="mn mo it kw b kx oc la od ld oe lh of ll og lp ms mt mu mv bi translated">任何数值类型的零(例如0，0.0，0j)</li><li id="9f98" class="mn mo it kw b kx oc la od ld oe lh of ll og lp ms mt mu mv bi translated">空序列(例如()，[])</li><li id="9634" class="mn mo it kw b kx oc la od ld oe lh of ll og lp ms mt mu mv bi translated">空映射(例如{})</li></ul><p id="f90c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所有这些值在布尔上下文中评估为<strong class="kw iu">假</strong>，并且它们可以在<strong class="kw iu"> if </strong>或<strong class="kw iu"> while </strong>语句中使用，也可以与操作数<strong class="kw iu">和</strong>、<strong class="kw iu">或</strong>以及<strong class="kw iu"> not </strong>一起使用。</p><p id="c382" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果其中一个False值包含在<strong class="kw iu">可迭代</strong>中，则<strong class="kw iu"> all()函数</strong>返回<strong class="kw iu"> False </strong>，如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="3bd6" class="lq lr it bd ls lt nf lv lw lx ng lz ma jz nh ka mc kc ni kd me kf nj kg mg mh bi translated">5.任何的</h1><p id="b88e" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated"><strong class="kw iu"> any(iterable) </strong>函数接受一个iterable(如列表、字典或元组)作为输入，如果<strong class="kw iu"> iterable </strong>的任何元素为真，则返回<strong class="kw iu"> True </strong>。如果不是，则返回<strong class="kw iu">假</strong>。</p><p id="f9a3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">与<strong class="kw iu"> all()函数</strong>一样，any()不限于评估<strong class="kw iu">布尔数据类型</strong>。该函数评估iterable的值是True还是falsy，如果任何值为True，则返回<strong class="kw iu"> True </strong>。(参见第4部分中被视为虚假的值)</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="5be8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要检查一个值是真还是假，我们可以使用如下所示的<strong class="kw iu"> bool() </strong>函数。</p><ul class=""><li id="9146" class="mn mo it kw b kx ky la lb ld mp lh mq ll mr lp ms mt mu mv bi translated">如果输入值为<strong class="kw iu">真值</strong>，该函数返回<strong class="kw iu">真值</strong>。</li><li id="7838" class="mn mo it kw b kx oc la od ld oe lh of ll og lp ms mt mu mv bi translated">如果输入值为<strong class="kw iu"> falsy </strong>，则返回<strong class="kw iu"> False </strong>。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h1 id="1541" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">6.混杂</h1><p id="192a" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated"><strong class="kw iu">哈希表</strong>是将<strong class="kw iu">键</strong>映射到<strong class="kw iu">值</strong>的数据结构。一个<strong class="kw iu">哈希表</strong>使用一个<strong class="kw iu">哈希函数</strong>来获得<strong class="kw iu">索引</strong>，其中<strong class="kw iu">值</strong>可以在下表中找到，如下图所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/f8e3431a6e4b1a0801b07102d365de0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9PHIL6uhGCWTGw7F3FQ1Hg.png"/></div></div></figure><p id="1c4f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> hash() </strong>函数返回一个对象的<strong class="kw iu">哈希值</strong>(如果它有一个的话)，意思是提供在<strong class="kw iu">哈希表</strong>中查找的索引。</p><p id="c114" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如您所看到的，如果提供了一个<strong class="kw iu">不可变的</strong>对象作为输入，这个函数将返回一个<strong class="kw iu">整数</strong> ( <strong class="kw iu">哈希值</strong>)。相反，如果提供了一个<strong class="kw iu">可变</strong>对象，则<strong class="kw iu"> hash()函数</strong>会引发一个异常(<strong class="kw iu"> TypeError </strong>),因为可变对象(例如列表)是<strong class="kw iu">不可共享的</strong>(它们可以在其生命周期内改变)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="dc9b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当提供特定的<strong class="kw iu">输入</strong>时，<strong class="kw iu"> hash()函数</strong>总是返回相同的数字<strong class="kw iu">输出</strong>值，这意味着它是一个<strong class="kw iu">确定性函数</strong>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="aa90" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请记住，<strong class="kw iu">散列函数</strong>的输出在您的计算机上可能不同，因为这个函数<strong class="kw iu">是依赖于平台的</strong>。</p><p id="ab18" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> Python </strong>对字典和集合使用<strong class="kw iu">哈希表</strong>。因此，我们可以很容易地确定一个对象是否属于一个字典或集合，因为我们知道它在内存数组中的索引(哈希函数的输出)。因此，在字典或集合中搜索一个元素的时间复杂度仅为<strong class="kw iu"> O(1)(无哈希冲突)。</strong></p><p id="bd5e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">相反，如果我们将元素存储在列表中，我们需要潜在地搜索列表中的每个元素，以确定给定元素是否存在(<strong class="kw iu">时间复杂度O(n) </strong>)。</p><p id="a0a9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面的代码块显示了在集合中搜索元素要比在列表中快得多。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="db60" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如我之前所说的，<strong class="kw iu"> hash()函数</strong>的输入应该是一个<strong class="kw iu">不可变的</strong>对象。出于这个原因，我们不能使用<strong class="kw iu">可变的</strong>对象作为字典的键或者集合的元素。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="5af2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如上所示，当试图使用一个列表作为字典的键时，会引发一个TypeError。</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="1baf" class="lq lr it bd ls lt nf lv lw lx ng lz ma jz nh ka mc kc ni kd me kf nj kg mg mh bi translated"><strong class="ak"> 7。可调用</strong></h1><p id="5398" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">如果作为参数传递的对象是可调用的，则<strong class="kw iu"> callable(object) </strong>函数返回<strong class="kw iu"> True </strong>。如果没有，返回<strong class="kw iu">假</strong>。</p><p id="bc03" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">可调用对象</strong>是可以用函数运算符<strong class="kw iu">()调用的对象。Python </strong>有五个可调用的对象:(1) <strong class="kw iu">函数</strong>，(2) <strong class="kw iu">方法</strong>，(3) <strong class="kw iu">类</strong>，(4) <strong class="kw iu">类实例(</strong>如果__call__方法被定义<strong class="kw iu"> ) </strong>，(5) <strong class="kw iu">生成器</strong>。</p><p id="7d12" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如下所示，如果这些对象中的任何一个作为输入被提供，<strong class="kw iu">可调用函数</strong>返回<strong class="kw iu"> True </strong>。相反，如果我们提供一个整数，函数返回<strong class="kw iu"> False </strong>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="2db9" class="lq lr it bd ls lt nf lv lw lx ng lz ma jz nh ka mc kc ni kd me kf nj kg mg mh bi translated">8.范围</h1><p id="9e0b" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated"><strong class="kw iu"> range([start]，stop，[step]) </strong>函数返回一个不可变的<strong class="kw iu">整数序列</strong> (range对象)，将三个参数作为输入:</p><ul class=""><li id="a306" class="mn mo it kw b kx ky la lb ld mp lh mq ll mr lp ms mt mu mv bi translated"><strong class="kw iu">开始→ </strong>序列的开始索引(默认为0)</li><li id="0eed" class="mn mo it kw b kx oc la od ld oe lh of ll og lp ms mt mu mv bi translated"><strong class="kw iu">停止→ </strong>范围的上限(总是被排除)</li><li id="189f" class="mn mo it kw b kx oc la od ld oe lh of ll og lp ms mt mu mv bi translated"><strong class="kw iu">步长→ </strong>序列的步长(默认为1)</li></ul><p id="8ded" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">启动</strong>和<strong class="kw iu">步骤</strong>是可选参数，调用该函数时<strong class="kw iu">停止</strong>是唯一需要的参数。为了可视化一个<strong class="kw iu"> range对象</strong>的元素，我们可以使用内置函数<strong class="kw iu"> list() </strong>将其转换为一个列表。</p><p id="a3eb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面的代码块显示了使用range函数生成的多个整数范围。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="7c8b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">范围函数</strong>通常与<strong class="kw iu">一起用于循环</strong>以迭代一系列<strong class="kw iu">数字</strong>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="1a01" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如上所示，range函数的上限总是被排除在外。</p><p id="2641" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">虽然不太常用，但是<strong class="kw iu">范围函数</strong>也与<strong class="kw iu"> while循环</strong>和<strong class="kw iu"> if语句</strong>一起使用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="d831" class="lq lr it bd ls lt nf lv lw lx ng lz ma jz nh ka mc kc ni kd me kf nj kg mg mh bi translated">9.低输入联网（low-entry networking的缩写）</h1><p id="3436" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated"><strong class="kw iu"> len(object) </strong> <strong class="kw iu">函数</strong>返回一个对象中的项数。如下图所示，<strong class="kw iu"> len()函数</strong>的输入可以是集合、序列、<strong class="kw iu"> NumPy数组、</strong>甚至是<strong class="kw iu">熊猫系列。</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="b168" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> len()函数</strong>通常与<strong class="kw iu"> range()函数</strong>一起使用，以迭代<strong class="kw iu">可迭代</strong>的<strong class="kw iu">索引</strong>。</p><p id="440e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如下所示，我们可以使用语法<strong class="kw iu"> range(len(iterable))迭代从0到iterable长度的数字。</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="3e54" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面的代码块产生与前面相同的输出，但是在这种情况下，我们迭代列表的<strong class="kw iu">项</strong>，而不是索引。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="9f1e" class="lq lr it bd ls lt nf lv lw lx ng lz ma jz nh ka mc kc ni kd me kf nj kg mg mh bi translated">10.轮次</h1><p id="d8db" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated"><strong class="kw iu"> round(number[，ndigits]) </strong>函数返回一个浮点数<strong class="kw iu">四舍五入到小数点后n位数</strong>。函数的第二个参数是可选的，如果省略，函数将返回一个整数作为输出。</p><p id="3338" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如下图所示，我们可以很容易地用<strong class="kw iu"> round()函数</strong>将圆周率四舍五入到小数点后两位或最接近的整数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="ab90" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> Python </strong>包括更多的<strong class="kw iu">内置函数</strong>，它们执行<strong class="kw iu">数学运算</strong>，比如:</p><ul class=""><li id="1796" class="mn mo it kw b kx ky la lb ld mp lh mq ll mr lp ms mt mu mv bi translated"><strong class="kw iu"> abs(x) </strong> →获取一个数的绝对值<strong class="kw iu"> x </strong></li><li id="0d2b" class="mn mo it kw b kx oc la od ld oe lh of ll og lp ms mt mu mv bi translated"><strong class="kw iu">复数([real[，imag]]) → </strong>定义一个复数<strong class="kw iu"> real+imagj </strong></li><li id="8d78" class="mn mo it kw b kx oc la od ld oe lh of ll og lp ms mt mu mv bi translated"><strong class="kw iu"> max(iterable) </strong> →获得<strong class="kw iu"> iterable </strong>中的最大项目</li><li id="8e50" class="mn mo it kw b kx oc la od ld oe lh of ll og lp ms mt mu mv bi translated"><strong class="kw iu">最小(可迭代)</strong> →获得<strong class="kw iu">可迭代</strong>中的最小项目</li></ul><h1 id="067a" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">有趣的网页</h1><p id="a964" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">除了官方文档之外，还有各种各样的网页可以找到有趣的例子！</p><div class="nk nl gp gr nm nn"><a href="https://docs.python.org/3/library/functions.html" rel="noopener  ugc nofollow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd iu gy z fp ns fr fs nt fu fw is bi translated">内置函数- Python 3.8.3文档</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">Python解释器内置了许多始终可用的函数和类型。它们被列出…</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">docs.python.org</p></div></div></div></a></div><div class="nk nl gp gr nm nn"><a href="https://www.w3schools.com/python/python_ref_functions.asp" rel="noopener  ugc nofollow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd iu gy z fp ns fr fs nt fu fw is bi translated">Python内置函数</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">Python有一组内置函数。</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">www.w3schools.com</p></div></div><div class="nw l"><div class="oi l ny nz oa nw ob ks nn"/></div></div></a></div><div class="nk nl gp gr nm nn"><a href="https://www.programiz.com/python-programming/methods/built-in" rel="noopener  ugc nofollow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd iu gy z fp ns fr fs nt fu fw is bi translated">Python内置函数</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">Python有几个现成的函数可供使用。这些函数称为内置函数。在这个…</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">www.programiz.com</p></div></div></div></a></div><div class="nk nl gp gr nm nn"><a href="https://www.geeksforgeeks.org/" rel="noopener  ugc nofollow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd iu gy z fp ns fr fs nt fu fw is bi translated">极客论坛|极客的计算机科学门户</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">极客的计算机科学门户。它包含写得很好，很好的思想和很好的解释计算机科学和…</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">www.geeksforgeeks.org</p></div></div><div class="nw l"><div class="oj l ny nz oa nw ob ks nn"/></div></div></a></div><div class="nk nl gp gr nm nn"><a href="https://www.udacity.com/course/introduction-to-python--ud1110" rel="noopener  ugc nofollow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd iu gy z fp ns fr fs nt fu fw is bi translated">Python编程简介| Udacity</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">在本课程中，您将学习Python编程语言的基础，以及编程最佳…</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">www.udacity.com</p></div></div><div class="nw l"><div class="ok l ny nz oa nw ob ks nn"/></div></div></a></div><h1 id="3133" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">第一部分</h1><p id="5d78" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">如果你还有兴趣了解更多关于内置函数的知识。阅读第1部分:)</p><div class="nk nl gp gr nm nn"><a rel="noopener follow" target="_blank" href="/10-python-built-in-functions-you-should-know-f6beba1698bb"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd iu gy z fp ns fr fs nt fu fw is bi translated">你应该知道的10个Python内置函数</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">带有用法示例</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">towardsdatascience.com</p></div></div><div class="nw l"><div class="ol l ny nz oa nw ob ks nn"/></div></div></a></div><p id="40ad" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Python提供了各种各样的内置函数，随时可供使用，这使得您的编程生活变得更加容易，因为您不需要浪费时间编写自己的代码。此外，Python标准库以及第三方模块提供了更多功能来处理日常编程。因此，在大多数情况下，掌握Python编程就是了解可用的代码。💪</p><p id="5207" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我希望你喜欢阅读这篇文章！再见👐</p><p id="3242" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">阿曼达💜</p></div></div>    
</body>
</html>