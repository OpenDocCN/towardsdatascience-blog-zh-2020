<html>
<head>
<title>Combining numerous artistic styles in Tensorflow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 Tensorflow 中结合众多艺术风格</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/combining-numerous-artistic-styles-in-tensorflow-6e12a99b103f?source=collection_archive---------61-----------------------#2020-06-01">https://towardsdatascience.com/combining-numerous-artistic-styles-in-tensorflow-6e12a99b103f?source=collection_archive---------61-----------------------#2020-06-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e425" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">神经类型转换在 Tensorflow 中非常容易，但只有一种类型。了解如何对图像应用多种样式。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/deba5cd2eb743258a3d6695b6b220884.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*e5trdYNJrUDVlt_1"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">安妮·斯普拉特在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="0e55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">去年，发布了一篇关于使用 Tensorflow Lite 的<a class="ae ky" href="https://www.tensorflow.org/lite/models/style_transfer/overview" rel="noopener ugc nofollow" target="_blank">艺术风格转换的文章，其中内容图像的风格根据您喜欢的任何风格进行更改。这是超级有趣，非常容易使用。你只需要指定图片的路径就可以了。它使用两个 TfLite 模型，一个用于预测样式，另一个用于转换。</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/8cc7c50b3ce4b28d98d9a9a098c47975.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*aOhuZJW4LZB3Omw3.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一些图片风格转换的例子。<a class="ae ky" href="https://www.tensorflow.org/lite/models/style_transfer/overview" rel="noopener ugc nofollow" target="_blank">来源</a>。</p></figure><p id="c41e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，它在将单一样式传递到内容图像方面非常有效，但是我们如何传递多种样式呢？这就是你将在这篇文章中发现的。</p><h1 id="c32b" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">目录</h1><ol class=""><li id="b9b7" class="mo mp it lb b lc mq lf mr li ms lm mt lq mu lu mv mw mx my bi translated">艺术风格转移阐释</li><li id="034b" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">组合样式</li></ol><ul class=""><li id="250c" class="mo mp it lb b lc ld lf lg li ne lm nf lq ng lu nh mw mx my bi translated">等量地</li><li id="5790" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu nh mw mx my bi translated">一个的样式和一个的颜色</li><li id="03bd" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu nh mw mx my bi translated">一个支配另一个</li></ul></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="fdd0" class="lw lx it bd ly lz np mb mc md nq mf mg jz nr ka mi kc ns kd mk kf nt kg mm mn bi translated">艺术风格转移阐释</h1><p id="5db6" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">在这一节中，我将解释风格转换是如何工作的。如果你已经了解它，只是想结合不同的风格，请随意进入下一部分。进行必要的导入，如 TensorFlow、NumPy 和 Matplotlib。设置内容和样式图像的路径，并下载所需的 Tensorflow Lite 模型。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="e72e" class="oc lx it ny b gy od oe l of og">import tensorflow as tf<br/>import matplotlib.pyplot as plt<br/>import matplotlib as mpl<br/>mpl.rcParams['figure.figsize'] = (12,12)<br/>mpl.rcParams['axes.grid'] = False<br/>import numpy as np</span><span id="dcf2" class="oc lx it ny b gy oh oe l of og">content_path = content.jpg <br/>style_path = style.jpg</span><span id="1a6c" class="oc lx it ny b gy oh oe l of og">style_predict_path = tf.keras.utils.get_file('style_predict.tflite', 'https://tfhub.dev/google/lite-model/magenta/arbitrary-image-stylization-v1-256/int8/prediction/1?lite-format=tflite')<br/>style_transform_path = tf.keras.utils.get_file('style_transform.tflite', 'https://tfhub.dev/google/lite-model/magenta/arbitrary-image-stylization-v1-256/int8/transfer/1?lite-format=tflite')</span></pre><p id="6139" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">加载图像和模型后，我们需要对它们进行预处理。图像应该是 RGB 格式的 float32 值，像素值需要在 0 和 1 之间。样式图像的尺寸应为(1，256，256，3)，内容图像的尺寸应为(1，384，384，3)。在 Tensorflow 博客中，宽度和高度的较小维度分别根据样式或内容图像等于 256 或 384，然后在中央裁剪。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="c0fc" class="oc lx it ny b gy od oe l of og"># Function to load an image from a file, and add a batch dimension.<br/>def load_img(path_to_img):<br/>  img = tf.io.read_file(path_to_img)<br/>  img = tf.io.decode_image(img, channels=3)<br/>  img = tf.image.convert_image_dtype(img, tf.float32)<br/>  img = img[tf.newaxis, :]</span><span id="e462" class="oc lx it ny b gy oh oe l of og">  return img</span><span id="e711" class="oc lx it ny b gy oh oe l of og"># Function to pre-process by resizing an central cropping it.<br/>def preprocess_image(image, target_dim):<br/>  # Resize the image so that the shorter dimension becomes 256px.<br/>  shape = tf.cast(tf.shape(image)[1:-1], tf.float32)<br/>  short_dim = min(shape)<br/>  scale = target_dim / short_dim<br/>  new_shape = tf.cast(shape * scale, tf.int32)<br/>  image = tf.image.resize(image, new_shape)</span><span id="3168" class="oc lx it ny b gy oh oe l of og">  # Central crop the image.<br/>  image = tf.image.resize_with_crop_or_pad(image, target_dim, target_dim)</span><span id="4830" class="oc lx it ny b gy oh oe l of og">  return image</span><span id="e6db" class="oc lx it ny b gy oh oe l of og"># Load the input images.<br/>content_image = load_img(content_path)<br/>style_image = load_img(style_path)</span><span id="1a2b" class="oc lx it ny b gy oh oe l of og"># Preprocess the input images.<br/>preprocessed_content_image = preprocess_image(content_image, 384)<br/>preprocessed_style_image = preprocess_image(style_image, 256)</span><span id="6706" class="oc lx it ny b gy oh oe l of og">print('Style Image Shape:', preprocessed_style_image.shape)<br/>print('Content Image Shape:', preprocessed_content_image.shape)</span></pre><p id="fc8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们需要使用加载的模型来预测样式图像上的样式。如果你想知道如何在 Python 中使用<a class="ae ky" href="https://www.tensorflow.org/lite/convert/python_api" rel="noopener ugc nofollow" target="_blank"> Tensorflow Lite，你可以看看这篇文章。创建模型的<em class="oi">解释器</em>并获取其输出。样式模型输出一个<em class="oi">样式瓶颈</em>，它有一个(1，1，1，100)的形状，我们将对它进行修改以组合多种样式。</a></p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="10cb" class="oc lx it ny b gy od oe l of og"># Function to run style prediction on preprocessed style image.<br/>def run_style_predict(preprocessed_style_image):<br/>  # Load the model.<br/>  interpreter = tf.lite.Interpreter(model_path=style_predict_path)</span><span id="a573" class="oc lx it ny b gy oh oe l of og">  # Set model input.<br/>  interpreter.allocate_tensors()<br/>  input_details = interpreter.get_input_details()<br/>  interpreter.set_tensor(input_details[0]["index"], preprocessed_style_image)</span><span id="8ef3" class="oc lx it ny b gy oh oe l of og">  # Calculate style bottleneck.<br/>  interpreter.invoke()<br/>  style_bottleneck = interpreter.tensor(<br/>      interpreter.get_output_details()[0]["index"]<br/>      )()</span><span id="e9ee" class="oc lx it ny b gy oh oe l of og">  return style_bottleneck</span><span id="86c5" class="oc lx it ny b gy oh oe l of og"># Calculate style bottleneck for the preprocessed style image.<br/>style_bottleneck = run_style_predict(preprocessed_style_image)<br/>print('Style Bottleneck Shape:', style_bottleneck.shape)</span></pre><p id="67da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这之后，我们需要在我们的内容图像上应用这个样式瓶颈来改变它的样式，所以我们使用另一个加载的模型。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="8669" class="oc lx it ny b gy od oe l of og"># Run style transform on preprocessed style image<br/>def run_style_transform(style_bottleneck, preprocessed_content_image):<br/>  # Load the model.<br/>  interpreter = tf.lite.Interpreter(model_path=style_transform_path)</span><span id="ac8c" class="oc lx it ny b gy oh oe l of og">  # Set model input.<br/>  input_details = interpreter.get_input_details()<br/>  interpreter.allocate_tensors()</span><span id="356f" class="oc lx it ny b gy oh oe l of og">  # Set model inputs.<br/>  interpreter.set_tensor(input_details[0]["index"], preprocessed_content_image)<br/>  interpreter.set_tensor(input_details[1]["index"], style_bottleneck)<br/>  interpreter.invoke()</span><span id="b02a" class="oc lx it ny b gy oh oe l of og">  # Transform content image.<br/>  stylized_image = interpreter.tensor(<br/>      interpreter.get_output_details()[0]["index"]<br/>      )()</span><span id="1a85" class="oc lx it ny b gy oh oe l of og">  return stylized_image</span><span id="c86a" class="oc lx it ny b gy oh oe l of og"># Stylize the content image using the style bottleneck.<br/>stylized_image = run_style_transform(style_bottleneck, preprocessed_content_image)</span><span id="57c9" class="oc lx it ny b gy oh oe l of og"># Visualize the output.<br/>stylized_image = tf.squeeze(stylized_image, axis=0)<br/>plt.imshow(stylized_image)<br/>plt.title('Stylized Image')</span></pre><p id="eda3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章中的流程图最好地概括了这个过程。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/d099ec0e789ab99c16a3ad549701bcba.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/0*0i7SS5SqHu2JTzlu.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://www.tensorflow.org/lite/models/style_transfer/overview" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><h1 id="f3ee" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">组合样式</h1><p id="2c87" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">我将要处理的图像如下所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/f61e63a6e233b48be1be3f89a3d52806.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Vtmd3vxDjwkhilCYeD6kg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">前两张是文章中的相同图片，第三张取自<a class="ae ky" href="https://www.pinterest.co.uk/pin/353251164510356461/" rel="noopener ugc nofollow" target="_blank">这里</a>。</p></figure><p id="9a7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">任何人对组合它们的第一个猜测都是先应用一种样式，然后在生成的图像上应用第二种样式。让我们看看我们通过它得到的结果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/11001840633833186c9c35ec95b9aa39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZtMZsyTwdBU038bEltJdvg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">前两张图片是个人风格。在第三幅图像中，样式 2 应用于第一幅图像</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/7697a336603ebda574e1eed76e96a3e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r9PKDVNptHBYE1Q_gXj-nQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在第三个图像中，样式 1 应用于第二个图像</p></figure><p id="a09c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样的结果不太好。结果看起来有点笨拙，只有应用于它的最终样式的颜色。所以，让我们来研究一下风格瓶颈，看看会发生什么。</p><h2 id="c4de" class="oc lx it bd ly om on dn mc oo op dp mg li oq or mi lm os ot mk lq ou ov mm ow bi translated">等量地</h2><p id="6efc" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">为了给两种风格以同等的权重，我们可以采用风格瓶颈的平均值。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="bdf8" class="oc lx it ny b gy od oe l of og">style_bottleneck = style_bottleneck1.copy()<br/>for i in range(100):<br/>    style_bottleneck[0, 0, 0, i] += style_bottleneck2[0, 0, 0, i]<br/>    style_bottleneck[0, 0, 0, i] /= 2</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/8341318e99c23122362347bd84fe37d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MlUiGw1ypkxfLG4dHjYe4w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">通过手段结合他们的风格瓶颈后的结果。</p></figure><p id="1647" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这看起来比我们之前得到的结果更好，而且颜色组合得更好。</p><h2 id="7501" class="oc lx it bd ly om on dn mc oo op dp mg li oq or mi lm os ot mk lq ou ov mm ow bi translated">一个的样式和一个的颜色</h2><p id="bd92" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">这个结果完全出乎意料，是瞎混的结果。这并不是说其他风格不会像我们获得的第一个结果那样对图像的颜色有任何发言权，在此之后我们继续进行风格瓶颈，但这将是微妙的，并淡化其他风格。将您想要的颜色样式放在所有偶数索引处，将您想要的纹理样式放在奇数索引处。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="cf9e" class="oc lx it ny b gy od oe l of og">style_bottleneck = style_bottleneck1.copy()<br/>for i in range(100):<br/>    if i % 2 == 0: # change 0 to 1 for second image<br/>        style_bottleneck[0, 0, 0, i] = style_bottleneck2[0, 0, 0, i]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/5db122c98eb91d0a868ceae032deef5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VLW1lmonQpOp0NRJdy-JfQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">第二种款式的颜色和第一种的质地。</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/6874d70cfdcc6a368cdddbc27366daa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3sQgsKx6gXxdULhaS1EwcQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">第一款的颜色和第二款的质地。</p></figure><h2 id="c174" class="oc lx it bd ly om on dn mc oo op dp mg li oq or mi lm os ot mk lq ou ov mm ow bi translated">一个支配另一个</h2><p id="54e7" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">我们知道风格瓶颈的大小是(1，1，1，100)。因此，如果我们取一种风格的前 50 个值，取另一种风格的后 50 个值，那么取前 50 个值的风格应该更占优势。</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="e0fb" class="oc lx it ny b gy od oe l of og">style_bottleneck = style_bottleneck1.copy()<br/>for i in range(50, 100): #change to (50) for second image<br/>    style_bottleneck[0, 0, 0, i] = style_bottleneck2[0, 0, 0, i]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/749e127ac53e3da42dd4cfe140c00daa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QA3FqLL5ZUjr350Zh-RRLw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">风格 1 优于风格 2</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/fdf716f741acaeb510a64fe860ab2781.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5HOOs_btX3GdchDucs1YPA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">风格 2 优于风格 1</p></figure></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><p id="561e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我尝试在一张图片中结合两种风格。你可以试着把两个以上的组合起来，看看是什么样子。完整的代码如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div></figure></div></div>    
</body>
</html>