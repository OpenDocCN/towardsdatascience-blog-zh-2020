<html>
<head>
<title>Fast &amp; Asynchronous in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中的快速和异步</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/fast-and-async-in-python-accelerate-your-requests-using-asyncio-62dafca83c33?source=collection_archive---------0-----------------------#2020-03-01">https://towardsdatascience.com/fast-and-async-in-python-accelerate-your-requests-using-asyncio-62dafca83c33?source=collection_archive---------0-----------------------#2020-03-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="be70" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用 asyncio 加速您的请求</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/60af37a442205703c62d72e22f90855b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6mXdFHFZG3xh3TMSigUoCA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@marcojodoin" rel="noopener ugc nofollow" target="_blank">马克-奥利维尔·乔多因</a>在<a class="ae ky" href="https://unsplash.com/photos/NqOInJ-ttqM" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="095f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">几周前，我正在编写一个 Python 脚本，为一个基于内容的推荐器提取图书的元数据。几个小时后，我意识到我需要向 Google Books API 发出数千个请求来获取数据。所以我想一定有办法可以加速这个过程。</p><p id="9feb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我喜欢学习，尤其是当这也是一个拖延我的目标的机会时，我决定用 asyncio 建立一个项目。后来，我为浪费的时间感到内疚，决定用我在这个过程中学到的东西来写这篇教程。</p><p id="3e0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文旨在提供如何使用<em class="lv"> asyncio </em>向 API 发出异步请求的基础知识。我主要关注实际代码，跳过大部分理论(除了下面的简短介绍)。但是，如果您正在寻找关于<em class="lv"> asyncio </em>的更深入的介绍，请查看参考资料中的建议。</p><h1 id="0c0e" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">30 秒或更短时间内的异步</h1><p id="549a" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">asyncio 是一个 Python 库，它允许你以看似并发的方式执行一些任务。它通常用于网络服务器和数据库连接。它对于加速 IO 绑定的任务也很有用，比如需要发出许多请求或等待外部 API 的服务。</p><p id="1812" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv"> asyncio </em>的本质在于，它允许程序在等待特定进程完成时继续执行其他指令(例如，对 API 的请求)。在本教程中，我们将看到如何使用<em class="lv"> asyncio </em>来加速一个向 API 发出多个请求的程序。</p><h1 id="aa92" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">顺序与异步</h1><p id="c5dd" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">所以还是言归正传吧。为了从本教程中获得最大收益，请尝试自己运行代码。这些代码片段已经通过了 Python 3.8.3 的测试。您可以尝试使用更新的版本运行它们，但是它们可能需要一些小的更改。</p><p id="5deb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在运行代码之前，您需要安装所需的库:<code class="fe mt mu mv mw b">requests</code>和<code class="fe mt mu mv mw b">aiohttp</code>。然后，你可以在一个<strong class="lb iu"> Jupyter 笔记本</strong>中运行下面的代码片段。如果你想使用一个<strong class="lb iu"> Python 脚本</strong>来运行代码片段，你需要做一些小的改动来让它工作。</p><p id="3a5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将构建一个小程序的顺序版本和异步版本，并比较它们的结果和结构。这两个程序将做同样的事情:</p><ol class=""><li id="6f35" class="mx my it lb b lc ld lf lg li mz lm na lq nb lu nc nd ne nf bi translated">阅读 ISBNs(图书的国际标识符)列表</li><li id="22f2" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">向 Google Books API 请求图书的元数据</li><li id="4356" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">解析请求的结果</li><li id="efe2" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">将结果打印到屏幕上。</li></ol><p id="0c4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该算法类似于下图。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/af8284bdca9fd7efeaf12f8eafe0bdb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dUHB-DfslHrb3cx_.jpg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">算法图</p></figure><p id="b60a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们将比较两种构建该算法的可能方法。首先是<em class="lv">选项 A </em>，它按顺序执行请求。然后，<em class="lv">选项 B </em>，它使用<em class="lv"> asyncio </em>异步运行请求。</p><h1 id="c120" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">选项 A:顺序算法</h1><p id="66c1" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">该算法的顺序版本可能如下所示:</p><pre class="kj kk kl km gt nm mw nn no aw np bi"><span id="626c" class="nq lx it mw b gy nr ns l nt nu">import os<br/>import json<br/>import requests  <br/>from requests.exceptions import HTTPError<br/><br/><br/>GOOGLE_BOOKS_URL = "https://www.googleapis.com/books/v1/volumes?q=isbn:"<br/>LIST_ISBN = [<br/>    '9780002005883',<br/>    '9780002238304',<br/>    '9780002261982',<br/>    '9780006163831',<br/>    '9780006178736',<br/>    '9780006280897',<br/>    '9780006280934',<br/>    '9780006353287',<br/>    '9780006380832',<br/>    '9780006470229',<br/>]<br/><br/><br/>def extract_fields_from_response(item):<br/>	"""Extract fields from API's response"""<br/>    volume_info = item.get("volumeInfo", {})<br/>    title = volume_info.get("title", None)<br/>    subtitle = volume_info.get("subtitle", None)<br/>    description = volume_info.get("description", None)<br/>    published_date = volume_info.get("publishedDate", None)<br/>    return (<br/>        title,<br/>        subtitle,<br/>        description,<br/>        published_date,<br/>    )<br/><br/><br/>def get_book_details_seq(isbn, session):<br/>	"""Get book details using Google Books API (sequentially)"""<br/>    url = GOOGLE_BOOKS_URL + isbn<br/>    response = None<br/>    try:<br/>        response = session.get(url)<br/>        response.raise_for_status()<br/>        print(f"Response status ({url}): {response.status_code}")<br/>    except HTTPError as http_err:<br/>        print(f"HTTP error occurred: {http_err}")<br/>    except Exception as err:<br/>        print(f"An error ocurred: {err}")<br/>    response_json = response.json()<br/>    items = response_json.get("items", [{}])[0]<br/>    return items<br/><br/><br/>with requests.Session() as session:<br/>    for isbn in LIST_ISBN:<br/>        try:<br/>            response = get_book_details_seq(isbn, session)<br/>            parsed_response = extract_fields_from_response(response)<br/>            print(f"Response: {json.dumps(parsed_response, indent=2)}")<br/>        except Exception as err:<br/>            print(f"Exception occured: {err}")<br/>            pass</span></pre><p id="6fe5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们分解代码来理解发生了什么。</p><p id="5cbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像往常一样，我们从导入所需的库开始。然后，我们定义两个变量:</p><ul class=""><li id="0238" class="mx my it lb b lc ld lf lg li mz lm na lq nb lu nv nd ne nf bi translated">用于指定我们将用于请求的 Google API 的 URL。对 Google Books API 的请求看起来是这样的:<code class="fe mt mu mv mw b"><a class="ae ky" href="https://www.googleapis.com/books/v1/volumes?q=isbn:9780002005883" rel="noopener ugc nofollow" target="_blank">https://www.googleapis.com/books/v1/volumes?q=isbn:9780002005883</a></code></li><li id="5e1f" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nv nd ne nf bi translated"><code class="fe mt mu mv mw b">LIST_ISBN</code>、<em class="lv">、</em>这是测试程序的 ISBNs 的样本列表。</li></ul><pre class="kj kk kl km gt nm mw nn no aw np bi"><span id="793d" class="nq lx it mw b gy nr ns l nt nu">import os<br/>import json<br/>import requests<br/>from requests.exceptions import HTTPError<br/><br/>GOOGLE_BOOKS_URL = "https://www.googleapis.com/books/v1/volumes?q=isbn:"<br/>LIST_ISBN = [<br/>    '9780002005883',<br/>    '9780002238304',<br/>    '9780002261982',<br/>    '9780006163831',<br/>    '9780006178736',<br/>    '9780006280897',<br/>    '9780006280934',<br/>    '9780006353287',<br/>    '9780006380832',<br/>    '9780006470229',<br/>]</span></pre><p id="41a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们定义<code class="fe mt mu mv mw b">extract_fields_from_response</code> <em class="lv"> </em>功能。该函数将来自 API 的响应作为输入，并提取我们感兴趣的字段。</p><pre class="kj kk kl km gt nm mw nn no aw np bi"><span id="998a" class="nq lx it mw b gy nr ns l nt nu">def extract_fields_from_response(response):<br/>    """Extract fields from API's response"""<br/>    item = response.get("items", [{}])[0]<br/>    volume_info = item.get("volumeInfo", {})<br/>    title = volume_info.get("title", None)<br/>    subtitle = volume_info.get("subtitle", None)<br/>    description = volume_info.get("description", None)<br/>    published_date = volume_info.get("publishedDate", None)<br/>    return (<br/>        title,<br/>        subtitle,<br/>        description,<br/>        published_date,<br/>    )</span></pre><p id="0c95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mt mu mv mw b">extract_fields_from_response</code>中的解析过程基于来自 Google Books API 的响应结构，如下所示:</p><pre class="kj kk kl km gt nm mw nn no aw np bi"><span id="6c92" class="nq lx it mw b gy nr ns l nt nu">{<br/> "kind": "books#volumes",<br/> "totalItems": 1,<br/> "items": [<br/>  {<br/>   "kind": "books#volume",<br/>   "id": "3Mx4QgAACAAJ",<br/>   "etag": "FWJF/JY16xg",<br/>   "selfLink": "https://www.googleapis.com/books/v1/volumes/3Mx4QgAACAAJ",<br/>   "volumeInfo": {<br/>    "title": "Mapping the Big Picture",<br/>    "subtitle": "Integrating Curriculum and Assessment, K-12",<br/>    ...</span></pre><p id="dc75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们进入程序最相关的部分:我们如何向 Google Books API 发出请求。</p><pre class="kj kk kl km gt nm mw nn no aw np bi"><span id="2d9a" class="nq lx it mw b gy nr ns l nt nu">def get_book_details_seq(isbn, session):<br/>	"""Get book details using Google Books API (sequentially)"""<br/>    url = GOOGLE_BOOKS_URL + isbn<br/>    response = None<br/>    try:<br/>        response = session.get(url)<br/>        response.raise_for_status()<br/>        print(f"Response status ({url}): {response.status_code}")<br/>    except HTTPError as http_err:<br/>        print(f"HTTP error occurred: {http_err}")<br/>    except Exception as err:<br/>        print(f"An error ocurred: {err}")<br/>    response_json = response.json()<br/>    items = response_json.get("items", [{}])[0]<br/>    return items<br/><br/><br/>with requests.Session() as session:<br/>    for isbn in LIST_ISBN:<br/>        try:<br/>            response = get_book_details_seq(isbn, session)<br/>            parsed_response = extract_fields_from_response(response)<br/>            print(f"Response: {json.dumps(parsed_response, indent=2)}")<br/>        except Exception as err:<br/>            print(f"Exception occured: {err}")<br/>            pass</span></pre><p id="bfa4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有两个主要部分:</p><ul class=""><li id="fc9e" class="mx my it lb b lc ld lf lg li mz lm na lq nb lu nv nd ne nf bi translated"><code class="fe mt mu mv mw b">get_book_details_seq</code>，它是执行请求的函数。它将一个 ISBN 和一个会话 object⁴作为输入，并将来自 API 的响应作为 JSON 结构返回。它还处理可能的错误，比如提供了错误的 URL 或者超出了每天的请求限额。</li><li id="4ecf" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nv nd ne nf bi translated">在<code class="fe mt mu mv mw b">with requests.Session() as session</code>下的代码块，是整个管道被编排的地方。它遍历 ISBNs 列表，获取书籍的详细信息，解析它们，最后将详细信息打印到屏幕上。</li></ul><p id="42e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对我来说，<strong class="lb iu">执行这个过程需要 4 到 6 秒</strong>。如果你只需要这样做几次，你不会发现使用<em class="lv"> asyncio </em>有什么好处。然而，如果不是 10 个请求，而是 10，000 个请求，那么程序中的并发性是值得的。在下一节中，我们将看到如何使用<em class="lv"> asyncio </em>使这个算法更快。</p><h1 id="2059" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">选项 B:异步算法</h1><p id="b5a4" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">同一算法的异步版本可能如下所示:</p><pre class="kj kk kl km gt nm mw nn no aw np bi"><span id="cc2b" class="nq lx it mw b gy nr ns l nt nu">import aiohttp<br/>import asyncio<br/>import json<br/>import os</span><span id="8947" class="nq lx it mw b gy nw ns l nt nu">from aiohttp import ClientSession<br/><br/><br/>GOOGLE_BOOKS_URL = "https://www.googleapis.com/books/v1/volumes?q=isbn:"<br/>LIST_ISBN = [<br/>    '9780002005883',<br/>    '9780002238304',<br/>    '9780002261982',<br/>    '9780006163831',<br/>    '9780006178736',<br/>    '9780006280897',<br/>    '9780006280934',<br/>    '9780006353287',<br/>    '9780006380832',<br/>    '9780006470229',<br/>]<br/><br/><br/>def extract_fields_from_response(response):<br/>    """Extract fields from API's response"""<br/>    item = response.get("items", [{}])[0]<br/>    volume_info = item.get("volumeInfo", {})<br/>    title = volume_info.get("title", None)<br/>    subtitle = volume_info.get("subtitle", None)<br/>    description = volume_info.get("description", None)<br/>    published_date = volume_info.get("publishedDate", None)<br/>    return (<br/>        title,<br/>        subtitle,<br/>        description,<br/>        published_date,<br/>    )<br/><br/><br/>async def get_book_details_async(isbn, session):<br/>    """Get book details using Google Books API (asynchronously)"""<br/>    url = GOOGLE_BOOKS_URL + isbn<br/>    try:<br/>        response = await session.request(method='GET', url=url)<br/>        response.raise_for_status()<br/>        print(f"Response status ({url}): {response.status}")<br/>    except HTTPError as http_err:<br/>        print(f"HTTP error occurred: {http_err}")<br/>    except Exception as err:<br/>        print(f"An error ocurred: {err}")<br/>    response_json = await response.json()<br/>    return response_json<br/><br/><br/>async def run_program(isbn, session):<br/>    """Wrapper for running program in an asynchronous manner"""<br/>    try:<br/>        response = await get_book_details_async(isbn, session)<br/>        parsed_response = extract_fields_from_response(response)<br/>        print(f"Response: {json.dumps(parsed_response, indent=2)}")<br/>    except Exception as err:<br/>        print(f"Exception occured: {err}")<br/>        pass<br/><br/>async with ClientSession() as session:<br/>    await asyncio.gather(*[run_program(isbn, session) for isbn in LIST_ISBN])</span></pre><p id="aabb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，检查<code class="fe mt mu mv mw b">get_book_details_async</code>功能。一个<code class="fe mt mu mv mw b">async</code>关键字在它前面。这个关键字告诉 Python 你的函数是一个协程。然后，在函数体中，有两个 await 关键字。这些命令告诉协程暂停执行，并在等待操作完成时将控制权交还给事件循环。</p><p id="0501" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个<em class="lv">协程</em>是 Python 中的一种生成器函数，它不产生值，而是消耗 values⁵.有趣的是，在等待新数据发送给它时，它的执行会暂停。在我们的例子中，这允许程序的其他部分以表面上并发的方式继续执行。</p><p id="ac8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，当请求正在执行时，<code class="fe mt mu mv mw b">get_book_details_async</code>的执行被暂停:<code class="fe mt mu mv mw b">await session.request(method='GET', url=url)</code>。当请求响应被解析成 JSON 结构:<code class="fe mt mu mv mw b">await response.json()</code>时，它再次被挂起。</p><p id="a28a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们有了<code class="fe mt mu mv mw b">run_program</code>协程。这个只是从 API 获取响应、解析响应并在屏幕上打印结果的管道的包装器。它<em class="lv">等待</em>协程<code class="fe mt mu mv mw b">get_book_details_async</code>的执行。</p><p id="1169" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们有了<code class="fe mt mu mv mw b">async with ClientSession() as session:</code>下的代码块。使用<code class="fe mt mu mv mw b">asyncio.gather</code>语法，我们告诉程序根据我们提供的协程列表来调度所有任务。这使得我们可以同时执行任务。</p><p id="9141" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对我来说，<strong class="lb iu">运行这个过程大约需要 800-1000 毫秒。</strong></p><h1 id="d9e1" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">结果</h1><p id="742a" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">比较这两个版本，我们看到异步版本比顺序版本快 4 到 7.5 倍。如果我们增加请求的数量，您可能会获得更高的加速。此外，<strong class="lb iu">使用<em class="lv"> asyncio </em>的版本并不比顺序版本</strong>复杂多少，这使得使用 asyncio 成为我们在教程中回顾的那类任务的一个极好的选择。</p><h1 id="7468" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">其他建议</h1><p id="885a" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">以下是我在与 asyncio 合作时收集的一些技巧</p><ul class=""><li id="2830" class="mx my it lb b lc ld lf lg li mz lm na lq nb lu nv nd ne nf bi translated"><em class="lv"> asyncio </em>一直在变，警惕老栈溢出答案。其中许多都不符合当前的最佳实践</li><li id="825c" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nv nd ne nf bi translated">外部 API 不允许您运行无限的并发请求。为了克服这一点，看看 asyncio 的<em class="lv"> </em>信号量。它将使您能够限制应用程序的并发性。</li><li id="61f1" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nv nd ne nf bi translated">不是所有的程序都可以用 asyncio 加速。在对代码进行任何实质性的修改之前，研究一下你所面临的问题的类型。其他的选择可能对你有用(例如，<a class="ae ky" href="https://docs.python.org/3/library/threading.html" rel="noopener ugc nofollow" target="_blank">线程，</a> <a class="ae ky" href="https://docs.python.org/2/library/multiprocessing.html" rel="noopener ugc nofollow" target="_blank">多重处理</a>)</li><li id="aa15" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nv nd ne nf bi translated">我制作了一个完整版本的程序，用于获取近 7 千本书的元数据。下面是它的链接:<a class="ae ky" href="https://github.com/dylanjcastillo/google_books_crawler" rel="noopener ugc nofollow" target="_blank">谷歌图书爬虫</a>。</li></ul><h1 id="792c" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">注释和参考文献</h1><p id="9ca4" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">[1] Real Python 有两篇精彩的文章介绍了<em class="lv">asyncio</em>:<a class="ae ky" href="https://realpython.com/async-io-python/" rel="noopener ugc nofollow" target="_blank">Python 中的异步 IO</a>和<a class="ae ky" href="https://realpython.com/python-concurrency" rel="noopener ugc nofollow" target="_blank">用并发性加速您的 Python 程序</a></p><p id="efce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[2]不是严格的并发执行。但实际上，看起来确实如此。</p><p id="b8e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[3] S. Buczyński，<a class="ae ky" href="https://www.quora.com/What-is-the-use-case-for-asyncio-and-coroutines-in-Python-3-6" rel="noopener ugc nofollow" target="_blank">Python 3.6 中协程和 asyncio 的用例是什么？</a></p><p id="eb6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[4]会话对象是来自请求库的一种功能，它允许您跨会话保持某些参数。这通常会降低请求的延迟。点击阅读更多<a class="ae ky" href="https://2.python-requests.org/en/v1.1.0/user/advanced/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="5e9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[5] D. Beasly，<a class="ae ky" href="http://www.dabeaz.com/coroutines/Coroutines.pdf" rel="noopener ugc nofollow" target="_blank">一门关于 Couroutines 和并发性的奇特课程</a> (2009)</p></div></div>    
</body>
</html>