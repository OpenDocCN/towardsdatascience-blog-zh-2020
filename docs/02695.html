<html>
<head>
<title>A Review of Conditional and Iterated Expectations using Linear Regression Models in R</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用R中的线性回归模型对条件期望和迭代期望的回顾</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/understanding-conditional-and-iterated-expectations-with-a-linear-regression-model-f90fb0a5533b?source=collection_archive---------33-----------------------#2020-03-15">https://towardsdatascience.com/understanding-conditional-and-iterated-expectations-with-a-linear-regression-model-f90fb0a5533b?source=collection_archive---------33-----------------------#2020-03-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3a76" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">重访(意料之外？！)概率论结果使用<code class="fe kf kg kh ki b">lm()</code></h2></div><h2 id="88b4" class="kj kk iq bd kl km kn dn ko kp kq dp kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated"><strong class="ak">太长；没看:</strong></h2><ul class=""><li id="c2d0" class="lf lg iq lh b li lj lk ll ks lm kw ln la lo lp lq lr ls lt bi translated">您可以对分组变量<em class="lu">加上任何其他变量</em>的结果进行回归，未调整和调整后的分组均值将是相同的。</li><li id="0957" class="lf lg iq lh b li lv lk lw ks lx kw ly la lz lp lq lr ls lt bi translated">我们可以在一个使用<code class="fe kf kg kh ki b">iris</code>数据的简单示例中看到这一点:</li></ul><pre class="ma mb mc md gt me ki mf mg aw mh bi"><span id="a9bd" class="kj kk iq ki b gy mi mj l mk ml">iris %&gt;%<br/> # fit a linear regression for sepal length given sepal width and species <br/> # make a new column containing the fitted values for sepal length<br/> mutate(preds = predict(lm(Sepal.Length ~ Sepal.Width + Species, data = .))) %&gt;%<br/> # compute unadjusted and adjusted group means group_by(Species)<br/> %&gt;% summarise(mean_SL = mean(Sepal.Length), mean_SL_preds = mean(preds)) %&gt;%<br/> kable()</span></pre><figure class="ma mb mc md gt mn gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi mm"><img src="../Images/7197465eccae60311202494882851aa1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V4WHcSkJ9CRWWUuY3dvm5Q.png"/></div></div></figure><ul class=""><li id="fddf" class="lf lg iq lh b li mu lk mv ks mw kw mx la my lp lq lr ls lt bi translated">这是因为E[E[Y|X，Z]| Z =<em class="lu">Z</em>]= E[Y | Z =<em class="lu">Z</em>。</li><li id="98f5" class="lf lg iq lh b li lv lk lw ks lx kw ly la lz lp lq lr ls lt bi translated">我们可以将回归得到的拟合值E[Y|X，Z]视为随机变量来帮助我们理解这一点。</li><li id="273e" class="lf lg iq lh b li lv lk lw ks lx kw ly la lz lp lq lr ls lt bi translated"><a class="ae mz" href="https://www.khstats.com/blog/iterated-expectations/iterated-expectations/#step-by-step-proof" rel="noopener ugc nofollow" target="_blank">跳到最后</a>看证明。</li></ul></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><figure class="ma mb mc md gt mn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/707f3be90e4288a4ec05aa020b42b09d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/0*m0pv4-6C6AL8H8Bk.png"/></div></figure><p id="4d3e" class="pw-post-body-paragraph ni nj iq lh b li mu jr nk lk mv ju nl ks nm nn no kw np nq nr la ns nt nu lp ij bi translated">我承认我在概率论第一学期的大部分时间都在努力理解X和x 之间的区别。当我最终学会了随机变量期望的所有规则时，我仍然对它们在我未来作为一名应用统计学家的工作中的影响毫无兴趣。</p><p id="20cc" class="pw-post-body-paragraph ni nj iq lh b li mu jr nk lk mv ju nl ks nm nn no kw np nq nr la ns nt nu lp ij bi translated">最近，当我试图在<code class="fe kf kg kh ki b">R</code>中编写一个看似简单的函数时，我发现自己陷入了期望属性的兔子洞。现在我已经把函数的输出整理好了，我对如何使用回归(一个我非常熟悉的框架)来重新思考我在概率论课程中学到的一些性质有了新的认识。</p><p id="bef5" class="pw-post-body-paragraph ni nj iq lh b li mu jr nk lk mv ju nl ks nm nn no kw np nq nr la ns nt nu lp ij bi translated">在函数中，我回归了几个变量加上一个分组变量的结果，然后返回拟合值的分组平均值。我的函数一直输出调整后的组平均值，这些平均值与未调整的组平均值相同。</p><p id="b991" class="pw-post-body-paragraph ni nj iq lh b li mu jr nk lk mv ju nl ks nm nn no kw np nq nr la ns nt nu lp ij bi translated">我很快意识到，对于我需要做的事情，我的分组变量不应该在回归模型中。然而，我仍然感到困惑的是，调整后的和未调整的组均值怎么可能是相同的。</p><p id="a1bb" class="pw-post-body-paragraph ni nj iq lh b li mu jr nk lk mv ju nl ks nm nn no kw np nq nr la ns nt nu lp ij bi translated">我创建了一个非常基本的例子来测试这个意外的结果。我回归了一个来自<code class="fe kf kg kh ki b">iris</code>数据集的变量<code class="fe kf kg kh ki b">Sepal.Length</code>，一个叫做<code class="fe kf kg kh ki b">Sepal.Width</code>的变量和一个分组变量<code class="fe kf kg kh ki b">Species</code>。然后，我查看了未调整的<code class="fe kf kg kh ki b">Sepal.Length</code>和来自我的线性回归模型的<code class="fe kf kg kh ki b">Sepal.Length</code>的拟合值在<code class="fe kf kg kh ki b">Species</code>的每个类别中的平均值。</p><pre class="ma mb mc md gt me ki mf mg aw mh bi"><span id="0bbd" class="kj kk iq ki b gy mi mj l mk ml">library(dplyr) <br/>library(knitr)</span><span id="8c04" class="kj kk iq ki b gy nv mj l mk ml">iris %&gt;% <br/># fit a linear regression for sepal length given sepal width and species <br/># make a new column containing the fitted values for sepal length<br/> mutate(preds = predict(lm(Sepal.Length ~ Sepal.Width + Species, data = .))) %&gt;%<br/> # compute unadjusted and adjusted group means<br/> group_by(Species) %&gt;%<br/> summarise(mean_SL = mean(Sepal.Length), mean_SL_preds = mean(preds)) %&gt;%<br/> kable()</span></pre><figure class="ma mb mc md gt mn gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi nw"><img src="../Images/0b879584f34e93290a8d28e383c61f07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j6CJWbVnqVjAQ4WMI1mEmA.png"/></div></div></figure><p id="6e42" class="pw-post-body-paragraph ni nj iq lh b li mu jr nk lk mv ju nl ks nm nn no kw np nq nr la ns nt nu lp ij bi translated">我看到了同样奇怪的输出，甚至在我的简单示例中也是如此。我意识到这一定是我学过但后来忘了的一些统计学特性，所以我决定写下我在expectations中做了什么。</p><p id="5046" class="pw-post-body-paragraph ni nj iq lh b li mu jr nk lk mv ju nl ks nm nn no kw np nq nr la ns nt nu lp ij bi translated">首先，我以期望值的形式写下了未调整组的均值。我写下了一个条件期望，因为当<code class="fe kf kg kh ki b">Species</code>被限制在某个类别时，我们在看<code class="fe kf kg kh ki b">Sepal.Length</code>的平均值。我们可以通过取一个随机变量<strong class="lh ir">萼片长度</strong>的期望值，同时设置另一个随机变量<strong class="lh ir">物种</strong>，一次只等于一个类别，来明确地展示这一点。</p><p id="dde2" class="pw-post-body-paragraph ni nj iq lh b li mu jr nk lk mv ju nl ks nm nn no kw np nq nr la ns nt nu lp ij bi translated">E[ <strong class="lh ir">分离</strong> | <strong class="lh ir">物种</strong> = <em class="lu">刚毛</em></p><p id="7933" class="pw-post-body-paragraph ni nj iq lh b li mu jr nk lk mv ju nl ks nm nn no kw np nq nr la ns nt nu lp ij bi translated">E[ <strong class="lh ir">分离度</strong> | <strong class="lh ir">种类</strong> = <em class="lu">海滨锦鸡儿</em></p><p id="92bc" class="pw-post-body-paragraph ni nj iq lh b li mu jr nk lk mv ju nl ks nm nn no kw np nq nr la ns nt nu lp ij bi translated">E[ <strong class="lh ir">独立</strong> | <strong class="lh ir">物种</strong> = <em class="lu">云芝</em></p><p id="eaa0" class="pw-post-body-paragraph ni nj iq lh b li mu jr nk lk mv ju nl ks nm nn no kw np nq nr la ns nt nu lp ij bi translated">更一般地，我们可以使用一个组指示变量<strong class="lh ir">物种</strong>写出未调整的组均值，它可以采用所有可能的值<em class="lu">物种</em>。</p><p id="1f3c" class="pw-post-body-paragraph ni nj iq lh b li mu jr nk lk mv ju nl ks nm nn no kw np nq nr la ns nt nu lp ij bi translated">E[ <strong class="lh ir">分离</strong> | <strong class="lh ir">种</strong> = <em class="lu">种</em></p><p id="af82" class="pw-post-body-paragraph ni nj iq lh b li mu jr nk lk mv ju nl ks nm nn no kw np nq nr la ns nt nu lp ij bi translated">这就是我们的未调整群的意思。调整后的群体均值呢？我们可以从写出线性回归模型开始，它是以随机变量<strong class="lh ir"> SepalWidth </strong>和<strong class="lh ir">物种</strong>为条件的<strong class="lh ir"> SepalLength </strong>的期望值。</p><p id="72fc" class="pw-post-body-paragraph ni nj iq lh b li mu jr nk lk mv ju nl ks nm nn no kw np nq nr la ns nt nu lp ij bi translated">E[ <strong class="lh ir">萼片长度</strong> | <strong class="lh ir">萼片长度</strong>，<strong class="lh ir">种类</strong></p><p id="a86d" class="pw-post-body-paragraph ni nj iq lh b li mu jr nk lk mv ju nl ks nm nn no kw np nq nr la ns nt nu lp ij bi translated">当我对线性回归模型的拟合使用<code class="fe kf kg kh ki b">predict</code>函数时，我从该期望值中获得了拟合值，然后将拟合值分组以获得分组平均值。我们可以将这些拟合值视为随机变量本身，并使用分组指示变量写出另一个条件均值，就像我们之前对未调整的分组均值所做的那样。</p><p id="2c05" class="pw-post-body-paragraph ni nj iq lh b li mu jr nk lk mv ju nl ks nm nn no kw np nq nr la ns nt nu lp ij bi translated">E[E[ <strong class="lh ir">分离长度</strong> | <strong class="lh ir">分离宽度</strong>，<strong class="lh ir">物种</strong>|<strong class="lh ir">物种</strong> = <em class="lu">物种</em> ]]</p><p id="604a" class="pw-post-body-paragraph ni nj iq lh b li mu jr nk lk mv ju nl ks nm nn no kw np nq nr la ns nt nu lp ij bi translated">我的未调整和调整的萼片长度的表因此向我显示:</p><p id="e8e4" class="pw-post-body-paragraph ni nj iq lh b li mu jr nk lk mv ju nl ks nm nn no kw np nq nr la ns nt nu lp ij bi translated">[E[E[<strong class="lh ir">sepal length</strong>|<strong class="lh ir">sepal width，Species</strong>|<strong class="lh ir">Species</strong>=<em class="lu">Species</em></p><p id="c715" class="pw-post-body-paragraph ni nj iq lh b li mu jr nk lk mv ju nl ks nm nn no kw np nq nr la ns nt nu lp ij bi translated">= E[ <strong class="lh ir">分离长度</strong> | <strong class="lh ir">物种</strong> = <em class="lu">物种</em> ]]</p><p id="d0e7" class="pw-post-body-paragraph ni nj iq lh b li mu jr nk lk mv ju nl ks nm nn no kw np nq nr la ns nt nu lp ij bi translated">或者，用更一般的符号来说:</p><p id="b6dc" class="pw-post-body-paragraph ni nj iq lh b li mu jr nk lk mv ju nl ks nm nn no kw np nq nr la ns nt nu lp ij bi translated">E[E[Y|X，Z]|Z=z] = E[Y|Z=z]]</p><p id="bc97" class="pw-post-body-paragraph ni nj iq lh b li mu jr nk lk mv ju nl ks nm nn no kw np nq nr la ns nt nu lp ij bi translated">是真的吗？！剧透警报-是的。让我们一个一个地完成证明的步骤。</p></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><h1 id="6e3a" class="nx kk iq bd kl ny nz oa ko ob oc od kr jw oe jx kv jz of ka kz kc og kd ld oh bi translated">验证设置</h1><p id="aaf2" class="pw-post-body-paragraph ni nj iq lh b li lj jr nk lk ll ju nl ks oi nn no kw oj nq nr la ok nt nu lp ij bi translated">让我们假设证明我们的 Y <em class="lu">(结果)</em> X <em class="lu">(调整变量)和</em> Z <em class="lu">(分组变量)都是分类(离散)变量。这只是为了使数学更清晰，因为离散变量的期望(加权求和)比连续变量的期望(概率密度函数的积分乘以随机变量的实现)更容易显示。</em></p><p id="1190" class="pw-post-body-paragraph ni nj iq lh b li mu jr nk lk mv ju nl ks nm nn no kw np nq nr la ns nt nu lp ij bi translated"><em class="lu">我们需要一些基本的预期结果:</em></p><h2 id="7b25" class="kj kk iq bd kl km kn dn ko kp kq dp kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">条件概率</h2><p id="8e7b" class="pw-post-body-paragraph ni nj iq lh b li lj jr nk lk ll ju nl ks oi nn no kw oj nq nr la ok nt nu lp ij bi translated">P(A | B)= P(A∩B)P(B)P(A | B)= P(A∩B)P(B)</p><h2 id="7158" class="kj kk iq bd kl km kn dn ko kp kq dp kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">划分定理</h2><p id="802d" class="pw-post-body-paragraph ni nj iq lh b li lj jr nk lk ll ju nl ks oi nn no kw oj nq nr la ok nt nu lp ij bi translated">e[a|b]=∑ba⋅p(a=a|b=b)e[a|b]=∑ba⋅p(a=a|b=b)</p><h2 id="dca9" class="kj kk iq bd kl km kn dn ko kp kq dp kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">联合分布的边际分布</h2><p id="4f08" class="pw-post-body-paragraph ni nj iq lh b li lj jr nk lk ll ju nl ks oi nn no kw oj nq nr la ok nt nu lp ij bi translated">∑a∑ba⋅p(a=a,b=b)=∑aa∑b⋅p(a=a,b=b)=∑aa⋅p(a=a)=e[a]</p><h1 id="b9ac" class="nx kk iq bd kl ny ol oa ko ob om od kr jw on jx kv jz oo ka kz kc op kd ld oh bi translated">逐步证明</h1><p id="3ef3" class="pw-post-body-paragraph ni nj iq lh b li lj jr nk lk ll ju nl ks oi nn no kw oj nq nr la ok nt nu lp ij bi translated">点击每个步骤后的上标数字了解更多信息。</p><p id="e115" class="pw-post-body-paragraph ni nj iq lh b li mu jr nk lk mv ju nl ks nm nn no kw np nq nr la ns nt nu lp ij bi translated">E[E[Y|X，Z]| Z =<em class="lu">Z</em>E[E[Y | X，Z]|Z= <em class="lu"> z </em></p><p id="ef77" class="pw-post-body-paragraph ni nj iq lh b li mu jr nk lk mv ju nl ks nm nn no kw np nq nr la ns nt nu lp ij bi translated">=E[E[Y|X，Z =<em class="lu">Z</em>]| Z =<em class="lu">Z</em>]= E[E[Y | X，Z =<em class="lu">Z</em>]| Z =<em class="lu">Z</em><a class="ae mz" href="https://www.khstats.com/blog/iterated-expectations/iterated-expectations/#fn1" rel="noopener ugc nofollow" target="_blank">1</a></p><p id="6fd6" class="pw-post-body-paragraph ni nj iq lh b li mu jr nk lk mv ju nl ks nm nn no kw np nq nr la ns nt nu lp ij bi translated">=∑XE[Y|X= <em class="lu"> x </em>，z =<em class="lu">z</em>]⋅p(x=<em class="lu">x</em>| z =<em class="lu">z</em>)=∑x e[y | x =<em class="lu">x</em>，z =<em class="lu">z</em>]⋅p(x=<em class="lu">x</em>| z =<em class="lu">z</em>)<a class="ae mz" href="https://www.khstats.com/blog/iterated-expectations/iterated-expectations/#fn2" rel="noopener ugc nofollow" target="_blank">2</a></p><p id="2137" class="pw-post-body-paragraph ni nj iq lh b li mu jr nk lk mv ju nl ks nm nn no kw np nq nr la ns nt nu lp ij bi translated">=∑x∑y⋅p(y=<em class="lu">y</em>| x =<em class="lu">x</em>，z =<em class="lu">z</em>)⋅p(x=<em class="lu">x</em>| z =<em class="lu">z</em>)=∑x∑y⋅p(y=<em class="lu">y</em>| x =<em class="lu">x</em>，z =<em class="lu">z</em>)⋅p(x=<em class="lu">x</em>| z =<em class="lu">z</em><a class="ae mz" href="https://www.khstats.com/blog/iterated-expectations/iterated-expectations/#fn3" rel="noopener ugc nofollow" target="_blank">3</a></p><p id="4fc5" class="pw-post-body-paragraph ni nj iq lh b li mu jr nk lk mv ju nl ks nm nn no kw np nq nr la ns nt nu lp ij bi translated">=∑X∑Y⋅P(Y= <em class="lu"> y </em>，X= <em class="lu"> x </em>，z =<em class="lu">z</em>p(X= <em class="lu">x</em>，Z= <em class="lu"> z </em> )⋅P(X= <em class="lu"> x </em>，z =<em class="lu">z</em>p(z =<em class="lu">z</em>)=∑x∑y⋅p(y=<em class="lu">y</em>，x =【t</p><p id="b99e" class="pw-post-body-paragraph ni nj iq lh b li mu jr nk lk mv ju nl ks nm nn no kw np nq nr la ns nt nu lp ij bi translated">=∑X∑Y⋅P(Y= <em class="lu"> y </em>，X= <em class="lu"> x </em>，z =<em class="lu">z</em>p(z =<em class="lu">z</em>)=∑x∑y⋅p(y=<em class="lu">y</em>，X= <em class="lu"> x </em>，z =<em class="lu">z</em>p(z =<em class="lu">z</em>)<a class="ae mz" href="https://www.khstats.com/blog/iterated-expectations/iterated-expectations/#fn5" rel="noopener ugc nofollow" target="_blank">5</a></p><p id="3848" class="pw-post-body-paragraph ni nj iq lh b li mu jr nk lk mv ju nl ks nm nn no kw np nq nr la ns nt nu lp ij bi translated">=∑Y∑X⋅P(Y= <em class="lu"> y </em>，X= <em class="lu"> x </em>，z =<em class="lu">z</em>p(z =<em class="lu">z</em>)=∑y∑x⋅p(y=<em class="lu">y</em>，X= <em class="lu"> x </em>，z =<em class="lu">z</em>p(z =<em class="lu">z</em>)<a class="ae mz" href="https://www.khstats.com/blog/iterated-expectations/iterated-expectations/#fn6" rel="noopener ugc nofollow" target="_blank">6</a></p><p id="452e" class="pw-post-body-paragraph ni nj iq lh b li mu jr nk lk mv ju nl ks nm nn no kw np nq nr la ns nt nu lp ij bi translated">=∑Y⋅P(Y= <em class="lu"> y </em>，z =<em class="lu">z</em>p(z =<em class="lu">z</em>)=∑y⋅p(y=<em class="lu">y</em>，z =<em class="lu">z</em>p(z =<em class="lu">z</em>)<a class="ae mz" href="https://www.khstats.com/blog/iterated-expectations/iterated-expectations/#fn7" rel="noopener ugc nofollow" target="_blank">7</a></p><p id="e2c5" class="pw-post-body-paragraph ni nj iq lh b li mu jr nk lk mv ju nl ks nm nn no kw np nq nr la ns nt nu lp ij bi translated">=∑y⋅p(y=<em class="lu">y</em>z =<em class="lu">z</em>)=∑y⋅p(y=<em class="lu">y</em>| z =<em class="lu">z</em>)<a class="ae mz" href="https://www.khstats.com/blog/iterated-expectations/iterated-expectations/#fn8" rel="noopener ugc nofollow" target="_blank">8</a></p><p id="8220" class="pw-post-body-paragraph ni nj iq lh b li mu jr nk lk mv ju nl ks nm nn no kw np nq nr la ns nt nu lp ij bi translated">= E[Y | Z =<em class="lu">Z</em>]= E[Y | Z =<em class="lu">Z</em><a class="ae mz" href="https://www.khstats.com/blog/iterated-expectations/iterated-expectations/#fn9" rel="noopener ugc nofollow" target="_blank">9</a></p><p id="2d8c" class="pw-post-body-paragraph ni nj iq lh b li mu jr nk lk mv ju nl ks nm nn no kw np nq nr la ns nt nu lp ij bi translated">所以，我们已经证明了:</p><p id="4d55" class="pw-post-body-paragraph ni nj iq lh b li mu jr nk lk mv ju nl ks nm nn no kw np nq nr la ns nt nu lp ij bi translated">E[E[Y|X，Z]| Z =<em class="lu">Z</em>= E[Y | Z =<em class="lu">Z</em>]</p><p id="1d2d" class="pw-post-body-paragraph ni nj iq lh b li mu jr nk lk mv ju nl ks nm nn no kw np nq nr la ns nt nu lp ij bi translated">谢天谢地，这意味着我有了函数输出混乱的答案。我突然意识到，我可以把内心的期望看作一个随机变量，我学到的关于条件和迭代期望的所有规则都可以应用到我每天拟合的回归中。</p><p id="2d9f" class="pw-post-body-paragraph ni nj iq lh b li mu jr nk lk mv ju nl ks nm nn no kw np nq nr la ns nt nu lp ij bi translated">这里希望你也能感受到不时重温概率论的灵感，即使你的工作非常实用。毕竟，这是一个社交距离的完美活动！😷</p></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><h1 id="adb5" class="nx kk iq bd kl ny nz oa ko ob oc od kr jw oe jx kv jz of ka kz kc og kd ld oh bi translated">说明</h1><ol class=""><li id="1e5d" class="lf lg iq lh b li lj lk ll ks lm kw ln la lo lp oq lr ls lt bi translated">因为我们使我们的外部期望以Z= <em class="lu"> z </em>为条件，我们也可以将Z= <em class="lu"> z </em>移入我们的内心期望。这在<code class="fe kf kg kh ki b">iris</code>示例中变得很明显，因为我们仅使用来自<code class="fe kf kg kh ki b">Species</code>的一个类别的拟合值来获得该类别的调整组均值。<a class="ae mz" href="https://www.khstats.com/blog/iterated-expectations/iterated-expectations/#fnref1" rel="noopener ugc nofollow" target="_blank"> ↩ </a></li><li id="2c4c" class="lf lg iq lh b li lv lk lw ks lx kw ly la lz lp oq lr ls lt bi translated">我们可以将E[Y|X，Z= <em class="lu"> z </em>改写为X可以取的所有可能值的加权求和。E[Y|X，Z= <em class="lu"> z </em>将只能取在<em class="lu"> x </em>，E[Y|X= <em class="lu"> x </em>，Z= <em class="lu"> z </em>范围内变化的X值，因为我们的值<em class="lu"> z </em>已经固定了。我们可以用P(X= <em class="lu"> x </em> |Z= <em class="lu"> z </em>)来加权这些可能的E[Y|X= <em class="lu"> x </em>，Z= <em class="lu"> z </em>值中的每一个，因为这是X在我们已经固定的<em class="lu"> z </em>取值<em class="lu"> x </em>的概率。于是，我们就可以开始用P(X =<em class="lu">X</em>| Z =<em class="lu">Z</em>)P(X =<em class="lu">X</em>| Z =<em class="lu">Z</em>)对每个E[Y|X=x，Z= <em class="lu"> z </em>进行加权，并把它们全部加起来，就可以求出E[E[Y|X，Z =<em class="lu">Z</em>| Z =<em class="lu">Z</em>]定理。<a class="ae mz" href="https://www.khstats.com/blog/iterated-expectations/iterated-expectations/#fnref2" rel="noopener ugc nofollow" target="_blank"> ↩ </a></li><li id="4ef0" class="lf lg iq lh b li lv lk lw ks lx kw ly la lz lp oq lr ls lt bi translated">我们可以通过与步骤2类似的过程(用P(Y= <em class="lu"> y </em> |X= <em class="lu"> x </em>，Z =<em class="lu">Z</em>P(Y =<em class="lu">Y</em>| X =<em class="lu">X</em>，Z= <em class="lu"> z </em>)加权每个<em class="lu"> y </em>得到Y在X的每个可能值上的期望值。<a class="ae mz" href="https://www.khstats.com/blog/iterated-expectations/iterated-expectations/#fnref3" rel="noopener ugc nofollow" target="_blank"> ↩ </a></li><li id="8e0f" class="lf lg iq lh b li lv lk lw ks lx kw ly la lz lp oq lr ls lt bi translated">根据条件概率定律，我们可以将条件概率改写为联合分布。<a class="ae mz" href="https://www.khstats.com/blog/iterated-expectations/iterated-expectations/#fnref4" rel="noopener ugc nofollow" target="_blank"> ↩ </a></li><li id="168c" class="lf lg iq lh b li lv lk lw ks lx kw ly la lz lp oq lr ls lt bi translated">第一个分数的分母与第二个分数的分子相抵消。<a class="ae mz" href="https://www.khstats.com/blog/iterated-expectations/iterated-expectations/#fnref5" rel="noopener ugc nofollow" target="_blank"> ↩ </a></li><li id="97a8" class="lf lg iq lh b li lv lk lw ks lx kw ly la lz lp oq lr ls lt bi translated">我们可以交换求和，这样<em class="lu"> y </em>在x的所有值的求和之外。这让我们只得到y和z的联合分布。<a class="ae mz" href="https://www.khstats.com/blog/iterated-expectations/iterated-expectations/#fnref6" rel="noopener ugc nofollow" target="_blank"> ↩ </a></li><li id="8f52" class="lf lg iq lh b li lv lk lw ks lx kw ly la lz lp oq lr ls lt bi translated">这是一个有条件的期望，写成联合分布的形式。<a class="ae mz" href="https://www.khstats.com/blog/iterated-expectations/iterated-expectations/#fnref7" rel="noopener ugc nofollow" target="_blank"> ↩ </a></li><li id="1cbb" class="lf lg iq lh b li lv lk lw ks lx kw ly la lz lp oq lr ls lt bi translated">根据分割定理。<a class="ae mz" href="https://www.khstats.com/blog/iterated-expectations/iterated-expectations/#fnref8" rel="noopener ugc nofollow" target="_blank"> ↩ </a></li><li id="f5fa" class="lf lg iq lh b li lv lk lw ks lx kw ly la lz lp oq lr ls lt bi translated">将之前的等式改写为期望值。<a class="ae mz" href="https://www.khstats.com/blog/iterated-expectations/iterated-expectations/#fnref9" rel="noopener ugc nofollow" target="_blank"> ↩ </a></li></ol><h1 id="3f54" class="nx kk iq bd kl ny ol oa ko ob om od kr jw on jx kv jz oo ka kz kc op kd ld oh bi translated">参考</h1><p id="df08" class="pw-post-body-paragraph ni nj iq lh b li lj jr nk lk ll ju nl ks oi nn no kw oj nq nr la ok nt nu lp ij bi translated"><a class="ae mz" href="https://www.math.arizona.edu/~tgk/464_07/cond_exp.pdf" rel="noopener ugc nofollow" target="_blank">一个条件期望——亚利桑那数学</a></p><p id="72f3" class="pw-post-body-paragraph ni nj iq lh b li mu jr nk lk mv ju nl ks nm nn no kw np nq nr la ns nt nu lp ij bi translated"><em class="lu">原载于2020年3月15日</em><a class="ae mz" href="https://www.khstats.com/blog/iterated-expectations/iterated-expectations/" rel="noopener ugc nofollow" target="_blank"><em class="lu">【https://www.khstats.com】</em></a><em class="lu">。</em></p></div></div>    
</body>
</html>