<html>
<head>
<title>Simple MLOps with Amazon SageMaker, Lambda and AWS Step Functions Data Science SDK</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有 Amazon SageMaker、Lambda 和 AWS 阶跃函数的简单 Data Science SDK</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/simple-mlops-with-amazon-sagemaker-lambda-and-aws-step-functions-data-science-sdk-e8052825a56c?source=collection_archive---------13-----------------------#2020-03-27">https://towardsdatascience.com/simple-mlops-with-amazon-sagemaker-lambda-and-aws-step-functions-data-science-sdk-e8052825a56c?source=collection_archive---------13-----------------------#2020-03-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c7e0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用 AWS 上的无服务器组件构建您自己的 ML CI/CD 管道。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/32d052409cfe67f10c91a34ebdd3f267.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tIQiHq7XwrJGN9tKlY734Q.png"/></div></div></figure><p id="5b7c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由<a class="lq lr ep" href="https://medium.com/u/5b52acb0f7e6?source=post_page-----e8052825a56c--------------------------------" rel="noopener" target="_blank">斯特凡·纳图、</a>T2、史瑞亚斯·苏布拉曼尼安、<a class="ae ls" href="https://www.linkedin.com/in/liqingwei/" rel="noopener ugc nofollow" target="_blank">李庆伟</a></p><h1 id="05da" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">介绍</h1><p id="9b7a" class="pw-post-body-paragraph ku kv it kw b kx ml ju kz la mm jx lc ld mn lf lg lh mo lj lk ll mp ln lo lp im bi translated">随着机器学习领域的成熟，越来越需要简单的方法来自动化 ML 管道并将其部署到生产中。随着数据科学平台的爆炸式增长，公司和团队经常使用不同的机器学习平台进行数据探索、提取-转换-加载(ETL)作业、模型训练和部署。在这篇博客中，我们描述了用户如何使用 Docker 自带算法代码来构建训练和推理图像，使用 Amazon SageMaker 和 AWS StepFunctions 来训练和托管他们的模型。我们使用 Mask R-CNN，这是一种非常流行的实例分割模型，用于许多计算机视觉用例，如[1]。希望亲自了解这篇博客内容的读者可以参考我们的<a class="ae ls" href="https://github.com/aws-samples/aws-stepfunctions-byoc-mlops-using-data-science-sdk" rel="noopener ugc nofollow" target="_blank">Github</a>【2】。</p><h1 id="1fb3" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">使用的 AWS 服务</h1><p id="10b8" class="pw-post-body-paragraph ku kv it kw b kx ml ju kz la mm jx lc ld mn lf lg lh mo lj lk ll mp ln lo lp im bi translated"><strong class="kw iu">AWS code build:</strong>AWS code build 是一个完全托管的持续集成(CI)服务，允许用户将代码编译和打包成可部署的工件。在这里，我们将使用 CodeBuild 将我们的自定义 Mask R-CNN 容器打包到 Docker 映像中，我们将该映像上传到 Amazon Elastic Container Registry(ECR)<br/><br/><strong class="kw iu">AWS Lambda:</strong>AWS Lambda 是一种服务，它允许您在不提供服务器的情况下运行代码。这里我们将使用 AWS Lambda 来部署一个代码构建作业。<br/><br/><strong class="kw iu">AWS step functions:</strong>AWS step functions 是一个编排工具，允许用户构建管道并将微服务协调到工作流中。然后，AWS StepFunctions 可以以事件驱动的方式触发该工作流，而无需用户管理任何底层服务器或计算机。<br/> <br/> <strong class="kw iu">亚马逊 SageMaker: </strong>亚马逊 SageMaker 是一个完全托管的机器学习平台，用于构建、训练和部署机器学习模型。在这里，我们使用 Amazon SageMaker 编写培训和模型部署作业，使用 SageMaker Jupyter 笔记本编写 StepFunctions 工作流。</p><h1 id="fb6c" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">创建一个屏蔽 R-CNN 容器</h1><p id="9fa8" class="pw-post-body-paragraph ku kv it kw b kx ml ju kz la mm jx lc ld mn lf lg lh mo lj lk ll mp ln lo lp im bi translated">因为我们在培训或托管中运行相同的映像，所以 Amazon SageMaker 用参数<code class="fe mq mr ms mt b">train</code>或<code class="fe mq mr ms mt b">serve</code>运行您的容器。当 Amazon SageMaker 运行训练时，你的<code class="fe mq mr ms mt b">train</code>脚本就像一个普通的 Python 程序一样运行。托管与训练有着非常不同的模型，因为托管是对通过 HTTP 传入的推理请求做出响应。在这个例子中，我们使用我们推荐的 Python 服务栈来提供推理请求的健壮和可伸缩的服务:</p><h2 id="54b9" class="mu lu it bd lv mv mw dn lz mx my dp md ld mz na mf lh nb nc mh ll nd ne mj nf bi translated">集装箱</h2><p id="ec5f" class="pw-post-body-paragraph ku kv it kw b kx ml ju kz la mm jx lc ld mn lf lg lh mo lj lk ll mp ln lo lp im bi translated">在“container”目录中，是您打包 Amazon SageMager 的示例算法所需的所有组件。</p><pre class="kj kk kl km gt ng mt nh ni aw nj bi"><span id="e08f" class="mu lu it mt b gy nk nl l nm nn">├── Dockerfile<br/>    ├── build_and_push.sh<br/>    └── mask_r_cnn<br/>        ├── nginx.conf<br/>        ├── predictor.py<br/>        ├── serve<br/>        ├── wsgi.py<br/>        ├── transforms.py<br/>        ├── utils.py<br/>        ├── coco_eval.py<br/>        ├── coco_utils.py<br/>        ├── engine.py<br/>        └── helper.py</span></pre><p id="f71b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们依次讨论这些问题:</p><ul class=""><li id="5784" class="no np it kw b kx ky la lb ld nq lh nr ll ns lp nt nu nv nw bi translated"><code class="fe mq mr ms mt b"><strong class="kw iu">Dockerfile</strong></code>描述如何构建 Docker 容器映像。更多细节见下文。</li><li id="011b" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp nt nu nv nw bi translated"><code class="fe mq mr ms mt b"><strong class="kw iu">build_and_push.sh</strong></code>是一个脚本，它使用 docker 文件来构建你的容器图像，然后将其推送到 ECR。我们将在本笔记的后面直接调用这些命令，但是您可以复制并运行您自己算法的脚本。</li><li id="d747" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp nt nu nv nw bi translated"><code class="fe mq mr ms mt b"><strong class="kw iu">mask_r_cnn</strong></code>是包含将要安装到容器中的文件的目录。</li></ul><p id="3b46" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这个简单的应用程序中，我们只在容器中安装了五个文件。我们将放入容器的文件是:</p><ul class=""><li id="b9db" class="no np it kw b kx ky la lb ld nq lh nr ll ns lp nt nu nv nw bi translated"><code class="fe mq mr ms mt b"><strong class="kw iu">nginx.conf</strong></code>是 nginx 前端的配置文件。通常，您应该能够照原样接受这个文件。</li><li id="9509" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp nt nu nv nw bi translated"><code class="fe mq mr ms mt b"><strong class="kw iu">predictor.py</strong></code>是实际实现 Flask web 服务器和该应用程序的决策树预测的程序。</li><li id="6998" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp nt nu nv nw bi translated"><code class="fe mq mr ms mt b"><strong class="kw iu">serve</strong></code>容器启动托管时程序是否启动。它只是启动 gunicorn 服务器，运行在<code class="fe mq mr ms mt b">predictor.py</code>中定义的 Flask 应用程序的多个实例。您应该能够照原样接受这个文件。</li><li id="5e7d" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp nt nu nv nw bi translated"><code class="fe mq mr ms mt b"><strong class="kw iu">train</strong></code>是运行容器进行训练时调用的程序。</li><li id="626c" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp nt nu nv nw bi translated"><code class="fe mq mr ms mt b"><strong class="kw iu">wsgi.py</strong></code>是一个用来调用 Flask app 的小包装器。您应该能够照原样接受这个文件。</li></ul><p id="9deb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们已经定制了<code class="fe mq mr ms mt b">train.py</code>和<code class="fe mq mr ms mt b">predictor.py</code>用于在训练期间微调掩码 R-CNN，以及用于加载调整后的模型、反序列化请求数据、进行预测和发送回序列化结果。</p><h2 id="9c40" class="mu lu it bd lv mv mw dn lz mx my dp md ld mz na mf lh nb nc mh ll nd ne mj nf bi translated">文档文件</h2><p id="1d84" class="pw-post-body-paragraph ku kv it kw b kx ml ju kz la mm jx lc ld mn lf lg lh mo lj lk ll mp ln lo lp im bi translated">Dockerfile 文件描述了我们想要构建的图像。我们将从一个标准的 Ubuntu 安装开始，运行普通的工具来安装所需的东西，比如 python、torch、torchvision 和 Pillow。最后，我们将实现特定算法的代码添加到容器中，并设置合适的运行环境。docker 文件如下所示，</p><pre class="kj kk kl km gt ng mt nh ni aw nj bi"><span id="26d2" class="mu lu it mt b gy nk nl l nm nn">FROM ubuntu:16.04</span><span id="03bb" class="mu lu it mt b gy oc nl l nm nn">MAINTAINER Amazon AI &lt;sage-learner@amazon.com&gt;<br/></span><span id="0037" class="mu lu it mt b gy oc nl l nm nn">RUN apt-get -y update &amp;&amp; apt-get install -y --no-install-recommends \<br/>         wget \<br/>         gcc\<br/>         g++\<br/>         python3 \<br/>         python3-dev\<br/>         nginx \<br/>         ca-certificates \<br/>    &amp;&amp; rm -rf /var/lib/apt/lists/*<br/></span><span id="0916" class="mu lu it mt b gy oc nl l nm nn">RUN wget <a class="ae ls" href="https://bootstrap.pypa.io/get-pip.py" rel="noopener ugc nofollow" target="_blank">https://bootstrap.pypa.io/get-pip.py</a> &amp;&amp; python3 get-pip.py &amp;&amp; \<br/>    pip install cython numpy==1.16.2 scipy==1.2.1 pandas flask gevent gunicorn &amp;&amp; \<br/>        (cd /usr/local/lib/python3.5/dist-packages/scipy/.libs; rm *; ln ../../numpy/.libs/* .) &amp;&amp; \<br/>        rm -rf /root/.cache<br/>RUN pip install  torch torchvision fastai thinc  Pillow</span><span id="14e6" class="mu lu it mt b gy oc nl l nm nn">ENV PYTHONUNBUFFERED=TRUE<br/>ENV PYTHONDONTWRITEBYTECODE=TRUE<br/>ENV PATH="/opt/program:${PATH}"</span><span id="3aa5" class="mu lu it mt b gy oc nl l nm nn"># Set up the program in the image<br/>COPY mask_r_cnn /opt/program<br/>WORKDIR /opt/program</span></pre><h1 id="9391" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">使用 AWS Lambda 和 CodeBuild 构建您的映像</h1><h2 id="0958" class="mu lu it bd lv mv mw dn lz mx my dp md ld mz na mf lh nb nc mh ll nd ne mj nf bi translated">SageMaker 集装箱项目</h2><p id="2e71" class="pw-post-body-paragraph ku kv it kw b kx ml ju kz la mm jx lc ld mn lf lg lh mo lj lk ll mp ln lo lp im bi translated">为了构建 SageMaker-ready 容器，比如上面讨论的 Mask R-CNN，我们使用开源的“SageMaker 容器”项目，可以在 https://github.com/aws/sagemaker-containers<a class="ae ls" href="https://github.com/aws/sagemaker-containers" rel="noopener ugc nofollow" target="_blank">这里找到。SageMaker Containers 为您提供了创建 SageMaker 兼容的 Docker 容器的工具，并提供了用于创建框架的附加工具(可以运行任意 Python 或 shell 脚本的 SageMaker 兼容的 Docker 容器)。目前，这个库被以下容器使用:</a><a class="ae ls" href="https://github.com/aws/sagemaker-tensorflow-container/tree/script-mode" rel="noopener ugc nofollow" target="_blank"> TensorFlow 脚本模式</a>、<a class="ae ls" href="https://github.com/aws/sagemaker-mxnet-container" rel="noopener ugc nofollow" target="_blank"> MXNet </a>、<a class="ae ls" href="https://github.com/aws/sagemaker-pytorch-container" rel="noopener ugc nofollow" target="_blank"> PyTorch </a>、<a class="ae ls" href="https://github.com/aws/sagemaker-chainer-container" rel="noopener ugc nofollow" target="_blank"> Chainer </a>和<a class="ae ls" href="https://github.com/aws/sagemaker-scikit-learn-container" rel="noopener ugc nofollow" target="_blank"> Scikit-learn </a>。要创建 Sagemaker 兼容容器，我们需要以下组件:</p><ol class=""><li id="279b" class="no np it kw b kx ky la lb ld nq lh nr ll ns lp od nu nv nw bi translated">train.py 文件和您的培训代码，以及</li><li id="e4b7" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp od nu nv nw bi translated">Dockerfile，如上图所示</li></ol><p id="cf1e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">训练脚本必须位于文件夹<code class="fe mq mr ms mt b">/opt/ml/code</code>下，其相对路径在环境变量<code class="fe mq mr ms mt b">SAGEMAKER_PROGRAM</code>中定义。支持以下脚本:</p><ul class=""><li id="ff8c" class="no np it kw b kx ky la lb ld nq lh nr ll ns lp nt nu nv nw bi translated">Python 脚本:将 Python 解释器用于任何带有。py 后缀</li><li id="1944" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp nt nu nv nw bi translated">Shell 脚本:使用 Shell 解释器来执行任何其他脚本</li></ul><p id="115e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当训练开始时，解释器执行上面例子中的入口点:</p><pre class="kj kk kl km gt ng mt nh ni aw nj bi"><span id="ed11" class="mu lu it mt b gy nk nl l nm nn">python train.py</span></pre><p id="9533" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">关于超参数和环境变量的更多信息，请参考<a class="ae ls" href="https://github.com/aws/sagemaker-containers#id10" rel="noopener ugc nofollow" target="_blank">https://github.com/aws/sagemaker-containers#id10</a>。</p><h2 id="eda5" class="mu lu it bd lv mv mw dn lz mx my dp md ld mz na mf lh nb nc mh ll nd ne mj nf bi translated">使用 Lambda 和 CodeBuild 自动化容器构建</h2><p id="7b6d" class="pw-post-body-paragraph ku kv it kw b kx ml ju kz la mm jx lc ld mn lf lg lh mo lj lk ll mp ln lo lp im bi translated">我们将使用云形成模板来自动化我们的掩模 R-CNN 的容器构建。该模板建立了以下体系结构:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/aed62c095414071b7a012cae46709c6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:462/format:webp/1*Ekly4AVv1SVwHVTvWsJpTg.png"/></div></figure><p id="2d84" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Lambda 函数包含可以内联编辑的 train.py 文件和 Dockerfile 文件。一旦触发(手动或通过下一节所示的阶跃函数方法)，Lambda 函数:</p><ol class=""><li id="461d" class="no np it kw b kx ky la lb ld nq lh nr ll ns lp od nu nv nw bi translated">创建一个 ECR 存储库(如果还不存在的话),用于存储构建后的容器映像</li><li id="fe93" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp od nu nv nw bi translated">将 train.py 和 docker 文件上传到 S3 存储桶</li><li id="4efe" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp od nu nv nw bi translated">创建一个 Codebuild 项目，并使用上述带有 buildspec.yml 的文件来启动构建容器的过程，将映像推送到 ECR。</li></ol><p id="1836" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Lambda 函数还包含有用的环境变量，可以针对新的构建进行重新配置。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/ce39466c14f555335c033e05b2085dbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1AOAipJ4jWoBwbO6jHS0Lw.png"/></div></div></figure><h1 id="ed22" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">使用 AWS Step 函数 Data Science SDK 训练和部署您的容器</h1><p id="8f44" class="pw-post-body-paragraph ku kv it kw b kx ml ju kz la mm jx lc ld mn lf lg lh mo lj lk ll mp ln lo lp im bi translated">一旦 Lambda 函数设置完毕，我们现在就可以构建自动化管道来训练和部署模型到端点。为此，我们将使用 AWS Step Functions，这是一个编排工具，它允许用户将状态机作为 JSON 对象创作并执行它们，而无需提供或管理任何服务器。Step Functions 现在还提供了一个数据科学 Python SDK，用于在熟悉的 Jupyter 笔记本环境中使用 Python 创作机器学习管道。我们建议读者参考 Github 存储库的 Step Functions 来开始[3]。<br/> <br/>这里我们简单演示一下我们的 Github [2]中详细描述的管道的关键组件。为了编写代码，我们将使用 Amazon SageMaker，AWS 完全管理的机器学习平台。<br/> <br/>与所有 AWS 服务一样，我们首先需要提供适当的 IAM 服务权限来调用其他 AWS 服务。为此，我们首先需要允许 Amazon SageMaker 调用 Step 函数 API，并允许 AWS Step 函数调用 SageMaker 进行模型训练、端点创建和部署。[3]中详细介绍了如何设置正确的 IAM 凭证。<br/> <br/>一旦设置好，我们将首先创建一个 Lambda 状态来运行 Lambda 函数，该函数获取代码并将其作为容器部署到 ECR 中。</p><pre class="kj kk kl km gt ng mt nh ni aw nj bi"><span id="ef38" class="mu lu it mt b gy nk nl l nm nn">lambda_state = LambdaStep(<br/>    state_id="Calls CodeBuild to Build Container",<br/>    parameters={  <br/>        "FunctionName": "Docker_Lambda", #replace with the name of the Lambda function you created<br/>        "Payload": {  <br/>           "input": "HelloWorld"<br/>        }<br/>    }<br/>)</span><span id="1f8e" class="mu lu it mt b gy oc nl l nm nn">lambda_state.add_retry(Retry(<br/>    error_equals=["States.TaskFailed"],<br/>    interval_seconds=15,<br/>    max_attempts=2,<br/>    backoff_rate=4.0<br/>))</span><span id="35dc" class="mu lu it mt b gy oc nl l nm nn">lambda_state.add_catch(Catch(<br/>    error_equals=["States.TaskFailed"],<br/>    next_step=Fail("LambdaTaskFailed")<br/>))</span></pre><p id="3589" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里添加了重试和捕获步骤，用于错误处理。您可以用您的自定义错误处理步骤来修改这些，但是如果 Lambda 函数未能部署容器，这将让步骤函数知道结束工作流。<br/> <br/>接下来的步骤是将训练任务和来自已训练工件的模型创建链接在一起。幸运的是，Step Functions Data Science SDK 提供了将这些步骤链接在一起的逻辑和 API，以及可能需要的任何自定义分支逻辑。</p><pre class="kj kk kl km gt ng mt nh ni aw nj bi"><span id="3144" class="mu lu it mt b gy nk nl l nm nn">train_step = TrainingStep('Train Step',<br/>estimator=maskrcnn,<br/>data=os.path.dirname(data_location),<br/>job_name=execution_input['JobName'])</span><span id="2f3d" class="mu lu it mt b gy oc nl l nm nn">model_step = ModelStep('Save model',<br/>model=train_step.get_expected_model(),<br/>model_name=execution_input['ModelName'])</span><span id="2334" class="mu lu it mt b gy oc nl l nm nn">endpoint_config_step = EndpointConfigStep(<br/>    "Create Endpoint Config",<br/>    endpoint_config_name=execution_input['ModelName'],<br/>    model_name=execution_input['ModelName'],<br/>    initial_instance_count=1,<br/>    instance_type='ml.m5.large'<br/>)</span><span id="66c8" class="mu lu it mt b gy oc nl l nm nn">endpoint_step = EndpointStep("Create Endpoint",<br/>endpoint_name=execution_input['EndpointName'],<br/>endpoint_config_name=execution_input['ModelName'])</span></pre><p id="463a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这里，我们使用我们的<strong class="kw iu"> mask-rcnn </strong>估计器，它是一个通用的 SageMaker 估计器对象，允许我们指定我们想要在其上训练我们的模型的实例的类型，识别任何网络或安全设置(如果需要)和模型超参数，以及模型的输出路径。估计器的输入是由上面的 Lambda 函数创建的容器图像。</p><pre class="kj kk kl km gt ng mt nh ni aw nj bi"><span id="64ee" class="mu lu it mt b gy nk nl l nm nn">maskrcnn = sagemaker.estimator.Estimator(image,<br/>                       role, 1, 'ml.p2.xlarge', #feel free to modify with your own. A cost estimate is provided in Readme.<br/>                       output_path="s3://{}/{}/output".format(sess.default_bucket(), key),<br/>                       sagemaker_session=sess)</span><span id="62d5" class="mu lu it mt b gy oc nl l nm nn">maskrcnn.set_hyperparameters(num_epochs = 1,<br/>                              num_classes = 2)</span></pre><p id="b9ce" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过使用 Chain 实用程序，我们可以将上述所有步骤串联起来，按顺序进行。然后，我们可以选择将整个工作流输出为 JSON，例如，可以在更大的云形成模板中使用，该模板还包括关于实例供应、网络安全设置等的信息。，或者自行运行。通过创建工作流和呈现图形，将在 Amazon Step Functions 控制台中创建一个状态机。</p><pre class="kj kk kl km gt ng mt nh ni aw nj bi"><span id="4f07" class="mu lu it mt b gy nk nl l nm nn">workflow_definition = Chain([<br/>    lambda_state,<br/>    train_step,<br/>    model_step,<br/>    endpoint_config_step,<br/>    endpoint_step<br/>])</span><span id="9db9" class="mu lu it mt b gy oc nl l nm nn"># Next, we define the workflow<br/>workflow = Workflow(<br/>    name="MyWorkflow-BYOC-MaskRCNN-{}".format(uuid.uuid1().hex),<br/>    definition=workflow_definition,<br/>    role=workflow_execution_role<br/>)</span><span id="a759" class="mu lu it mt b gy oc nl l nm nn">workflow.render_graph()</span></pre><p id="99c7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这将呈现以下输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/32d052409cfe67f10c91a34ebdd3f267.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tIQiHq7XwrJGN9tKlY734Q.png"/></div></div></figure><p id="c62e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就完成了我们的步骤功能工作流程。我们现在可以直接在 Amazon SageMaker <br/>中执行这个工作流，并使用 workflow.execute 和 workflow . render _ progress()API 或直接从 Step Functions 控制台检查进度。执行将被记录在 CloudWatch 中，并可用于在下游系统中向用户发送警报和通知。<br/> <br/>借助 AWS Step Functions Data Science SDK，数据科学家和工程师可以无缝部署定制容器、训练 ML 模型并将其部署到生产中。为了将其他 AWS 大数据工具(如 EMR 和 AWS Glue)集成到 Step Functions 工作流中，我们建议读者参考[4，5]。</p><h1 id="f002" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">参考</h1><p id="c566" class="pw-post-body-paragraph ku kv it kw b kx ml ju kz la mm jx lc ld mn lf lg lh mo lj lk ll mp ln lo lp im bi translated">[1] He，k .，Gkioxari，g .，Dollar，p .，Girshick，R .，Mask R-CNN，<a class="ae ls" href="https://arxiv.org/abs/1703.06870" rel="noopener ugc nofollow" target="_blank">https://arxiv.org/abs/1703.06870.</a><br/>【2】<a class="ae ls" href="https://github.com/aws-samples/aws-stepfunctions-byoc-mlops-using-data-science-sdk" rel="noopener ugc nofollow" target="_blank">https://github . com/AWS-samples/AWS-step functions-byoc-mlops-using-data-science-SDK</a><br/>【3】<a class="ae ls" href="https://github.com/awslabs/amazon-sagemaker-examples/tree/master/step-functions-data-science-sdk" rel="noopener ugc nofollow" target="_blank">https://github . com/aw slats/Amazon-sagemaker-examples/tree/master/step-functions-data-science-SD</a></p></div></div>    
</body>
</html>