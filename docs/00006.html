<html>
<head>
<title>From scratch to search: playing with your data (Elasticsearch Ingest Pipelines)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从零开始到搜索:处理数据(Elasticsearch 摄取管道)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/from-scratch-to-search-playing-with-your-data-elasticsearch-ingest-pipelines-6d054bf5d866?source=collection_archive---------5-----------------------#2020-01-01">https://towardsdatascience.com/from-scratch-to-search-playing-with-your-data-elasticsearch-ingest-pipelines-6d054bf5d866?source=collection_archive---------5-----------------------#2020-01-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="47cd" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一条管道来统治他们，一条管道来吸收他们，一条管道来转变他们，并在弹性搜索中绑定他们。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/035ec924ffe2e4a98913c5c60f5ea339.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UYAOkAd90wQHutBp"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">朱利安·维勒拉在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="7545" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">介绍</h1><p id="8ea3" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在这篇文章中，我想快速浏览一下 Elasticsearch 提供的一个有趣的特性，我也倾向于在作为摄取管道的生产设置中使用它。此功能允许<a class="ae kv" href="https://www.elastic.co/guide/en/elasticsearch/reference/master/ingest.html" rel="noopener ugc nofollow" target="_blank"> <em class="mk">在实际文档索引发生</em>之前预处理文档 </a> <em class="mk">。听起来很有趣，为什么…</em></p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="84b2" class="mq kx iq mm b gy mr ms l mt mu"><strong class="mm ir"><em class="mk">Note: for an introductory hands-on overview of the Elasticsearch technology check out </em></strong><a class="ae kv" rel="noopener" target="_blank" href="/from-scratch-to-search-setup-elasticsearch-under-4-minutes-load-a-csv-with-python-and-read-e31405d244f1"><strong class="mm ir"><em class="mk">my previous article</em></strong></a><strong class="mm ir"><em class="mk">.</em></strong></span></pre><p id="4662" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated">这在很多方面都很有用，但我认为有两个主要原因。首先，当你更多地处于(大)数据分析/处理方面时，你的优先事项(和任务)可能不会涉及源系统的主动变更。因此，您必须在原始数据到来时对其进行处理，并对其进行预处理以满足您的数据需求。第二，即使你打算改变生产者，你 A)可能不能直接控制所有的生产者(例如，由于一些组织方面的原因，例如，他们的遗留性质)和/或 B)仍然需要做好准备，改变可能需要相当长的时间(例如，想想你想要在你的共享日志库的新版本上升级数十/数百个微服务，等等)。).</p><p id="f05f" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated">对于这些情况，您可以调用来维护接收管道。</p><h1 id="f602" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">它是如何工作的</h1><p id="2e15" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">摄取管道是数据解析和转换领域的新玩家，长期以来一直被 Logstash 所占据。摄取管道实际上<a class="ae kv" href="https://www.elastic.co/blog/should-i-use-logstash-or-elasticsearch-ingest-nodes" rel="noopener ugc nofollow" target="_blank">不是 Logstash 的完全替代</a>。但是使用 Logstash 的考虑是，它不可避免地给你的架构带来了另一个 sw 组件，从而使它的操作更加复杂。摄取管道则不是这样，因为它们是由集群中的任何(或所有)常规 Elasticsearch <a class="ae kv" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-node.html" rel="noopener ugc nofollow" target="_blank">节点</a>直接执行的。该节点只需要是<a class="ae kv" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/ingest.html" rel="noopener ugc nofollow" target="_blank">摄取节点</a>的类型(这是默认的)，这样当您想要开始使用它们时，甚至不需要修改配置。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi na"><img src="../Images/2e94a665f72deee639cba6e4180c01f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GUE1YHCC9Ye4lPwa"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在索引操作期间，在协调器节点接收到请求之后，在摄取节点上执行流水线。图片来源:<a class="ae kv" href="https://www.elastic.co/pdf/elasticsearch-sizing-and-capacity-planning.pdf" rel="noopener ugc nofollow" target="_blank">elastic.co</a>。</p></figure><h1 id="2fe5" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">管道定义</h1><p id="9936" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">一般来说，管道是通过一个简单的<a class="ae kv" href="https://www.elastic.co/guide/en/elasticsearch/reference/master/pipeline.html" rel="noopener ugc nofollow" target="_blank"> JSON 文档</a>定义的，该文档包含一个处理器阵列，它代表一组有序的步骤，这些步骤应用于所有传入的文档并在其上执行。实际的处理器有各种各样的风格，所以我强烈推荐您浏览一下文档中的列表来熟悉一下。</p><p id="bddd" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated">处理器有一些共同之处。这些是:</p><ul class=""><li id="157a" class="nb nc iq lq b lr mv lu mw lx nd mb ne mf nf mj ng nh ni nj bi translated">能够使用花括号模板<code class="fe nk nl nm mm b">{{service-name}}</code>在定义中<a class="ae kv" href="https://www.elastic.co/guide/en/elasticsearch/reference/master/accessing-data-in-pipelines.html" rel="noopener ugc nofollow" target="_blank">访问/引用已处理文档的数据</a></li><li id="2223" class="nb nc iq lq b lr nn lu no lx np mb nq mf nr mj ng nh ni nj bi translated">能够定义处理器的<a class="ae kv" href="https://www.elastic.co/guide/en/elasticsearch/reference/master/ingest-conditionals.html" rel="noopener ugc nofollow" target="_blank">条件执行</a>，如果<em class="mk">子句仅允许在检查条件后执行该步骤</em></li><li id="5f3a" class="nb nc iq lq b lr nn lu no lx np mb nq mf nr mj ng nh ni nj bi translated">能够使用<em class="mk"> on_failure </em>子句<a class="ae kv" href="https://www.elastic.co/guide/en/elasticsearch/reference/master/handling-failure-in-pipelines.html" rel="noopener ugc nofollow" target="_blank">处理处理器</a>的故障</li><li id="fcfb" class="nb nc iq lq b lr nn lu no lx np mb nq mf nr mj ng nh ni nj bi translated">可以通过<em class="mk">标记</em>子句进行标记，这对于错误跟踪等非常有用</li></ul><p id="f11f" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated">稍后将详细介绍这些内容。</p><h1 id="4a12" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">测试环境加速旋转</h1><p id="e55c" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">理论已经讲得够多了，让我们在本地机器上的 Docker 中构建一个简单的(单节点)集群，并尝试第一个管道定义。<em class="mk">注意:如果你需要更多关于 docker 部分的信息，可以在</em> <a class="ae kv" rel="noopener" target="_blank" href="/from-scratch-to-search-setup-elasticsearch-under-4-minutes-load-a-csv-with-python-and-read-e31405d244f1"> <em class="mk">我之前的文章</em> </a> <em class="mk">中找到。让我们也做一个 Kibana 的实例，以便有一个简单的 GUI 来查看。</em></p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="c0a0" class="mq kx iq mm b gy mr ms l mt mu">#!/bin/bash</span><span id="4be7" class="mq kx iq mm b gy ns ms l mt mu">docker network create elastic-network</span><span id="0829" class="mq kx iq mm b gy ns ms l mt mu">docker run --rm --detach --name elastic4pipelines -p 9200:9200 -v esdata01:/usr/share/elasticsearch/data --network elastic-network -e "node.name=elastic4pipelines" -e "discovery.type=single-node" -e "bootstrap.memory_lock=true" --ulimit memlock=-1:-1 -e ES_JAVA_OPTS="-Xms2g -Xmx2g" docker.elastic.co/elasticsearch/elasticsearch:7.5.1</span><span id="eb90" class="mq kx iq mm b gy ns ms l mt mu">docker run --rm --detach --link elastic4pipelines:elasticsearch --name kibana4pipelines --network elastic-network -p 5601:5601 docker.elastic.co/kibana/kibana:7.5.1</span></pre><p id="d8f7" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated">当您运行上面的脚本并等待几分钟时，您的临时弹性堆栈应该开始运行并为我们的管道测试做好准备(Kibana 在<a class="ae kv" href="http://localhost:5601/" rel="noopener ugc nofollow" target="_blank"> http://localhost:5601/ </a>上运行)。</p><h1 id="9756" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">用管道处理文档</h1><p id="f5c0" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">为了进行测试，我们将从小处着手，创建一个管道，它将:</p><ul class=""><li id="982e" class="nb nc iq lq b lr mv lu mw lx nd mb ne mf nf mj ng nh ni nj bi translated">用<a class="ae kv" href="https://www.elastic.co/guide/en/elasticsearch/reference/master/split-processor.html" rel="noopener ugc nofollow" target="_blank">分割处理器</a>按特定分隔符分割一个字段的值</li><li id="4f1c" class="nb nc iq lq b lr nn lu no lx np mb nq mf nr mj ng nh ni nj bi translated">在下一步中，使用<a class="ae kv" href="https://www.elastic.co/guide/en/elasticsearch/reference/master/foreach-processor.html" rel="noopener ugc nofollow" target="_blank"> Foreach 处理器</a>遍历新数组的所有值，并使用<a class="ae kv" href="https://www.elastic.co/guide/en/elasticsearch/reference/master/uppercase-processor.html" rel="noopener ugc nofollow" target="_blank">大写处理器</a>转换为大写字符</li></ul><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="292b" class="mq kx iq mm b gy mr ms l mt mu">curl -XPUT localhost:9200/_ingest/pipeline/my_simple_pipeline \<br/>-H "Content-Type: application/json" \<br/>-d '{<br/>    "processors": [<br/>        {<br/>            "split": {<br/>                "field": "meta.tags",<br/>                "separator": " ",<br/>                "target_field": "meta.tags_parsed",<br/>                "ignore_missing": true<br/>            }<br/>        },<br/>        {<br/>            "foreach": {<br/>                "field": "meta.tags_parsed",<br/>                "processor": {<br/>                    "uppercase": {<br/>                        "field": "_ingest._value"<br/>                    }<br/>                }<br/>            }<br/>        }<br/>    ]<br/>}'</span></pre><p id="cabf" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated">现在，让我们创建一个索引，将该管道用作默认的接收管道。</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="ceae" class="mq kx iq mm b gy mr ms l mt mu">curl -XPUT localhost:9200/my_index \<br/>-H "Content-Type: application/json" \<br/>-d '{<br/>    "settings": {<br/>        "index.default_pipeline": "my_simple_pipeline"<br/>    }<br/>}'</span></pre><p id="f85d" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated">最后，让我们索引一个将由这个管道处理的虚拟文档。</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="1767" class="mq kx iq mm b gy mr ms l mt mu">curl -XPOST localhost:9200/my_index/_doc \<br/>-H "Content-Type: application/json" \<br/>-d '{<br/>    "comment": "I liked this article on pipelines!",<br/>    "meta": {<br/>        "tags": "good enjoyed recommended"<br/>    }<br/>}'</span></pre><p id="3595" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated">现在我们可以看看基巴纳的文件。注意:不要忘记创建一个索引模式。我们可以看到适当的转换。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/c55d6d2d8f3b3690f6220f0543d190dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YN4YIU6gyU5CrpzfFmBdoQ.png"/></div></div></figure><h1 id="d6fe" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">基于值的脚本和条件执行</h1><p id="4c2e" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">不，让我们尝试两件事，为了更有效，让我们在一个处理器中同时使用这两件事:)</p><ul class=""><li id="a921" class="nb nc iq lq b lr mv lu mw lx nd mb ne mf nf mj ng nh ni nj bi translated">使用<code class="fe nk nl nm mm b">if</code>子句的条件执行(对所有处理器都是可能的)</li><li id="7c37" class="nb nc iq lq b lr nn lu no lx np mb nq mf nr mj ng nh ni nj bi translated">使用<a class="ae kv" href="https://www.elastic.co/guide/en/elasticsearch/reference/master/script-processor.html" rel="noopener ugc nofollow" target="_blank">脚本处理器</a>进行更复杂的处理(当预制处理器不够用时)</li></ul><p id="9128" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated">这两者都使用了一种简单的脚本语言(基于 Groovy)。阅读<a class="ae kv" href="https://www.elastic.co/guide/en/elasticsearch/painless/master/painless-guide.html" rel="noopener ugc nofollow" target="_blank">无痛指南</a>了解更多信息。然而重要的是:</p><ul class=""><li id="d0af" class="nb nc iq lq b lr mv lu mw lx nd mb ne mf nf mj ng nh ni nj bi translated">可以通过<code class="fe nk nl nm mm b">ctx</code>变量(所谓的<a class="ae kv" href="https://www.elastic.co/guide/en/elasticsearch/painless/master/painless-ingest-processor-context.html" rel="noopener ugc nofollow" target="_blank">摄取处理器上下文</a>)在脚本中访问您处理过的文档</li><li id="88ff" class="nb nc iq lq b lr nn lu no lx np mb nq mf nr mj ng nh ni nj bi translated">ctx 包含提取的 JSON 的映射结构(用方括号<code class="fe nk nl nm mm b">ctx['my_field']</code>引用各个字段)</li><li id="0b5f" class="nb nc iq lq b lr nn lu no lx np mb nq mf nr mj ng nh ni nj bi translated">您可以修改 ctx 变量的值来添加、修改或删除文档的字段</li></ul><p id="efee" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated">简单的例子:如果 rest 对我们的目的没有用，我们可以用它只索引原始文本的一部分(子串)。所以只要更换管道…</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="9190" class="mq kx iq mm b gy mr ms l mt mu">curl -XPUT localhost:9200/_ingest/pipeline/my_simple_pipeline \<br/>-H "Content-Type: application/json" \<br/>-d '{<br/>    "processors": [<br/>        {<br/>            "script": {<br/>                "source": "ctx.comment = ctx.comment.substring(0,20) + '\'' (…)'\''",<br/>                "if": "ctx.containsKey('\''comment'\'') &amp;&amp; ctx['\''comment'\''].length() &gt; 20"<br/>            }<br/>        }<br/>    ]<br/>}'</span></pre><p id="2377" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated">…并为新文档编制索引。</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="044f" class="mq kx iq mm b gy mr ms l mt mu">curl -XPOST localhost:9200/my_index/_doc \<br/>-H "Content-Type: application/json" \<br/>-d '{<br/>    "comment": "Hello, this is a message which deserves a hair cut."<br/>}'</span></pre><h1 id="9902" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">提取结构化字段(解析默认 NGINX 日志行格式)</h1><p id="c094" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">如果您正在处理以某种定义明确的格式构建的数据(但不是在单个字段中提取的)，您可以尝试使用<a class="ae kv" href="https://www.elastic.co/guide/en/elasticsearch/reference/master/dissect-processor.html" rel="noopener ugc nofollow" target="_blank">剖析处理器</a>。只需用带百分号<code class="fe nk nl nm mm b">%{my_field}</code>的花括号描述提取的单个字段的模式。</p><p id="cc71" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated">我们可以使用这个处理器解析默认 NGINX 日志行格式(combined/main)之外的结构化字段，该格式具有以下结构。</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="17b9" class="mq kx iq mm b gy mr ms l mt mu">log_format main '$remote_addr - $remote_user [$time_local] '<br/>'"$request" $status $body_bytes_sent '<br/>'"$http_referer" "$http_user_agent"';</span></pre><p id="c824" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated">有关 NGINX 日志的更多信息，请参见日志模块<a class="ae kv" href="http://nginx.org/en/docs/http/ngx_http_log_module.html#log_format" rel="noopener ugc nofollow" target="_blank"> ngx_http_log_module </a>的文档。我们还可以使用<a class="ae kv" href="https://www.elastic.co/guide/en/elasticsearch/reference/master/date-processor.html" rel="noopener ugc nofollow" target="_blank">日期处理器</a>提取@timestamp，因为原始值默认为非标准格式。</p><p id="126f" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated">让我们把它放在新管道里。</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="5664" class="mq kx iq mm b gy mr ms l mt mu">curl -X PUT <a class="ae kv" href="http://localhost:9200/_ingest/pipeline/my_simple_pipeline" rel="noopener ugc nofollow" target="_blank">localhost:9200/_ingest/pipeline/nginx_pipeline</a> \<br/>  -H 'Content-Type: application/json' \<br/>  -d '{<br/>    "processors": [<br/>        {<br/>            "dissect": {<br/>                "field": "message",<br/>                "pattern" : "%{remote_addr} - %{remote_user} [%{time_local}] \"%{request}\" %{status} %{body_bytes_sent} \"%{http_referer}\" \"%{http_user_agent}\" \"%{http_x_forwarded_for}\""<br/>            }<br/>        },<br/>        {<br/>            "date": {<br/>                "field": "time_local",<br/>                "formats": [<br/>                    "dd/MMM/yyyy:HH:mm:ss Z"<br/>                ],<br/>                "timezone": "Europe/Prague"<br/>            }<br/>        }<br/>    ]<br/>}'</span></pre><p id="1ad8" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated">现在，您可以在消息字段中发布一个日志行并提取它。注意，您可以用查询字符串中的新管道覆盖索引中的默认管道。</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="a76a" class="mq kx iq mm b gy mr ms l mt mu">curl -X POST localhost:9200/my_index/_doc?pipeline=nginx_pipeline \<br/>  -H 'Content-Type: application/json' \<br/>  -d '{<br/>    "message": "172.17.0.1 - - [24/Dec/2019:10:09:42 +0000] \"GET / HTTP/1.1\" 200 95 \"-\" \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36\" \"-\""<br/>}'</span></pre><p id="4c3c" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated">刷新您的索引模式，并在 Kibana 中查看一下。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/5bd6af95245c411f43fdab17a37c986c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g3qlXO3cqqZs8n79oW-xkg.png"/></div></div></figure><p id="e28c" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated">如果你想尝试一下，只需启动<a class="ae kv" href="https://hub.docker.com/_/nginx" rel="noopener ugc nofollow" target="_blank"> nginx docker 容器</a>并在/var/log/nginx 中找到你的日志。</p><p id="9ab6" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated">您可以对不同格式的内容使用类似的处理器，例如<a class="ae kv" href="https://www.elastic.co/guide/en/elasticsearch/reference/master/csv-processor.html" rel="noopener ugc nofollow" target="_blank"> CSV 处理器</a>(从 CSV 中提取字段)、<a class="ae kv" href="https://www.elastic.co/guide/en/elasticsearch/reference/master/kv-processor.html" rel="noopener ugc nofollow" target="_blank"> KV 处理器</a>(解析 key=value 对)或基于 regex 的<a class="ae kv" href="https://www.elastic.co/guide/en/elasticsearch/reference/master/grok-processor.html" rel="noopener ugc nofollow" target="_blank"> Grok 处理器</a>。</p><h1 id="c502" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">用另一个索引的值充实</h1><p id="3493" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们要使用的最后一个东西是<a class="ae kv" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.x/enrich-processor.html" rel="noopener ugc nofollow" target="_blank"> Enrich 处理器</a>，它可以用来自另一个索引的数据来丰富您的文档。酷吧！</p><p id="5d95" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated">在管道中使用它之前，有三个先决条件:</p><ul class=""><li id="d2a0" class="nb nc iq lq b lr mv lu mw lx nd mb ne mf nf mj ng nh ni nj bi translated">您需要有我们将从中获取浓缩数据的源索引</li><li id="d17c" class="nb nc iq lq b lr nn lu no lx np mb nq mf nr mj ng nh ni nj bi translated">您需要定义一个丰富策略来定义源索引、匹配字段和附加字段</li><li id="439e" class="nb nc iq lq b lr nn lu no lx np mb nq mf nr mj ng nh ni nj bi translated">您需要<code class="fe nk nl nm mm b">_execute</code>enrich 策略来为该策略创建一个 enrich 索引</li></ul><p id="2896" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated">让我们扩展前面的例子，使用已知 IP 地址的源索引(让我们忘记我们现在运行在 localhost 上的事实:)，我们将检查添加一些数据，看看 IP 是否不在潜在的黑名单上。</p><p id="6986" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated">首先创建源索引和一个文档(注意:使用<code class="fe nk nl nm mm b">refresh</code>查询参数来确保索引可以立即用于搜索):</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="6c7c" class="mq kx iq mm b gy mr ms l mt mu">curl -X POST localhost:9200/ip_source_index/_doc?refresh=wait_for \<br/>  -H 'Content-Type: application/json' \<br/>  -d '{<br/>    "ip": "172.17.0.1",<br/>    "black_listed": false,<br/>    "user_category": "test"<br/>}'</span></pre><p id="796d" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated">下一步将创建<a class="ae kv" href="https://www.elastic.co/guide/en/elasticsearch/reference/master/enrich-policy-definition.html" rel="noopener ugc nofollow" target="_blank">充实政策</a>。很简单——只需链接我们的源索引(我们在上面创建的),匹配 ip 字段并列出相关字段。</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="31d5" class="mq kx iq mm b gy mr ms l mt mu">curl -X PUT localhost:9200/_enrich/policy/ip-policy \<br/>  -H 'Content-Type: application/json' \<br/>  -d '{<br/>    "match": {<br/>        "indices": "ip_source_index",<br/>        "match_field": "ip",<br/>        "enrich_fields": ["black_listed", "user_category"]<br/>    }<br/>}'</span></pre><p id="1272" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated">我们需要执行它来创建 enrich 索引。</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="f40c" class="mq kx iq mm b gy mr ms l mt mu">curl -X POST <a class="ae kv" href="http://localhost:9200/_enrich/policy/ip-policy/_execute" rel="noopener ugc nofollow" target="_blank">localhost:9200/_enrich/policy/ip-policy/_execute</a></span></pre><p id="134a" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated">现在我们终于可以将<a class="ae kv" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.x/enrich-processor.html" rel="noopener ugc nofollow" target="_blank"> Enrich 处理器</a>添加到我们之前的 nginx 管道中了。我们需要引用 enrich 策略、我们将匹配的字段(我们在上一步中提取的 remote_addr)、enrich 数据的目标字段和 max_matches(要包含的最大匹配文档数)。将以下内容添加到处理器中…</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="896b" class="mq kx iq mm b gy mr ms l mt mu">{<br/>    "enrich" : {<br/>        "policy_name": "ip-policy",<br/>        "field" : "remote_addr",<br/>        "target_field": "meta.ip",<br/>        "max_matches": "1"<br/>    }<br/>}</span></pre><p id="aa36" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated">现在只需(重新)发布之前的文档(使用相同的 nginx 日志行)并提取日志内容，然后从我们的“ip info”索引中丰富日志内容。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/ba8690fd8370352d970b91fb69f0f11f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c_YQ33IL1Al4FYa4WuE1cw.png"/></div></div></figure><p id="41cc" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated">不错！</p><h1 id="3a17" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">“生产”建议</h1><p id="c6d5" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">最后，我想向您介绍摄取管道的其他概念和功能，当您想在实际场景中开始使用管道时，这些概念和功能与它们结合使用是非常有用的。</p><h2 id="a92b" class="mq kx iq bd ky nu nv dn lc nw nx dp lg lx ny nz li mb oa ob lk mf oc od lm oe bi translated">与索引模板一起使用</h2><p id="e932" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">如果您旋转索引(在处理时间序列数据时，您可能应该这样做，大小在几十 GB 以上，等等。)如果您通过<a class="ae kv" href="https://www.elastic.co/guide/en/elasticsearch/reference/master/index-lifecycle-management.html" rel="noopener ugc nofollow" target="_blank">索引生命周期管理</a>(我倾向于这样做)实现了这些自动化，那么更值得推荐的是利用<a class="ae kv" href="https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html" rel="noopener ugc nofollow" target="_blank">索引模板</a>。这些有助于将从索引模板创建的所有索引的配置(设置和映射)形式化。</p><p id="9054" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated">从管道角度来看，您可以在设置中指定:</p><ul class=""><li id="6818" class="nb nc iq lq b lr mv lu mw lx nd mb ne mf nf mj ng nh ni nj bi translated"><strong class="lq ir"> index.default_pipeline </strong>如果请求中没有直接指定其他管道，则默认应用该管道(如果有，则默认被覆盖)。</li><li id="88a3" class="nb nc iq lq b lr nn lu no lx np mb nq mf nr mj ng nh ni nj bi translated"><strong class="lq ir"> index.final_pipeline </strong>默认管道或请求管道之后每次运行的管道。</li></ul><p id="c36c" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated">在包含它们之前，请确保您的管道存在，否则您的请求将会失败。</p><h2 id="faf4" class="mq kx iq bd ky nu nv dn lc nw nx dp lg lx ny nz li mb oa ob lk mf oc od lm oe bi translated">管道模拟</h2><p id="afc6" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">通过<a class="ae kv" href="https://www.elastic.co/guide/en/elasticsearch/reference/master/simulate-pipeline-api.html" rel="noopener ugc nofollow" target="_blank"> _simulate API </a>来测试这些无疑是有用的(当你已经准备好管道并且需要执行一些改变的时候)。您可以在请求体中指定新的管道定义以及几个测试文档，并像处理这些文档一样获得结果。</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="de70" class="mq kx iq mm b gy mr ms l mt mu">POST /_ingest/pipeline/_simulate<br/>{<br/>    "pipeline": {<br/>        "processors": [<br/>            ...<br/>        ]<br/>    },<br/>    "docs": [<br/>        {<br/>            "_index": "index",<br/>            "_id": "id",<br/>            "_source": {<br/>                // your doc here<br/>            }<br/>        }<br/>    ]<br/>}</span></pre><h2 id="3778" class="mq kx iq bd ky nu nv dn lc nw nx dp lg lx ny nz li mb oa ob lk mf oc od lm oe bi translated">故障处理</h2><p id="da35" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">确保您<a class="ae kv" href="https://www.elastic.co/guide/en/elasticsearch/reference/master/handling-failure-in-pipelines.html" rel="noopener ugc nofollow" target="_blank">处理流水线执行过程中发生的最终故障</a>。通过在特定处理器级别或作为一个整体的流水线级别定义<code class="fe nk nl nm mm b">on_failure</code>块(由一些其他处理器组成)来实现。</p><p id="7797" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated">将有问题的文档传递到不同的索引。</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="c6c1" class="mq kx iq mm b gy mr ms l mt mu">{<br/>    "processors": [ … ],<br/>    "on_failure": [<br/>        {<br/>            "set": {<br/>                "field": "_index",<br/>                "value": "failed-{{ _index }}"<br/>            }<br/>        }<br/>    ]<br/>}</span></pre><h2 id="e139" class="mq kx iq bd ky nu nv dn lc nw nx dp lg lx ny nz li mb oa ob lk mf oc od lm oe bi translated">空值的处理</h2><p id="d4d1" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">对于需要条件执行的情况(即只有在字段存在的情况下),确保在引用的字段丢失或具有无效值时处理这些情况。你可以通过一些处理器提供的<code class="fe nk nl nm mm b">ignore_missing</code>属性(转换、重命名、删除……)或者在<code class="fe nk nl nm mm b">if</code>块中实现。</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="cdcd" class="mq kx iq mm b gy mr ms l mt mu">"if": "ctx.containsKey('foo') &amp;&amp; ctx['foo'].containsKey('bar')"</span></pre><h2 id="6b1b" class="mq kx iq bd ky nu nv dn lc nw nx dp lg lx ny nz li mb oa ob lk mf oc od lm oe bi translated">重新索引</h2><p id="e6cf" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">通常，当您发现接收管道时，您的现有索引中已经有大量数据。要让新的 shiny 管道处理这些数据，只需创建一个新的索引，并使用<a class="ae kv" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-reindex.html" rel="noopener ugc nofollow" target="_blank"> reindex API </a>来复制数据。若要处理数据，请在索引设置或 reindex 请求正文中指定管道。</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="1593" class="mq kx iq mm b gy mr ms l mt mu">POST /_reindex<br/>{<br/>    "source": {<br/>        "index": "source-index-*"<br/>    },<br/>    "dest": {<br/>        "index": "destination-index",<br/>        "pipeline": "my_pipeline"<br/>    }<br/>}</span></pre><p id="ae99" class="pw-post-body-paragraph lo lp iq lq b lr mv jr lt lu mw ju lw lx mx lz ma mb my md me mf mz mh mi mj ij bi translated">注意:用 ILM 重新索引<a class="ae kv" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/ilm-reindexing-into-rollover.html" rel="noopener ugc nofollow" target="_blank">时要更加小心。</a></p><h1 id="be13" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">好了</h1><p id="4d58" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们研究了接收管道的各种特性，并进行了测试。希望你喜欢这个介绍，你可以在你的场景中看到一些潜力。</p></div></div>    
</body>
</html>