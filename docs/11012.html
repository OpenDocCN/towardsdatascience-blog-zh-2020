<html>
<head>
<title>A Comprehensive Tutorial to Rust Operators for Beginners</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个全面的教程，以信任运营商的初学者</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-comprehensive-tutorial-to-rust-operators-for-beginners-11554b2c64d4?source=collection_archive---------23-----------------------#2020-07-31">https://towardsdatascience.com/a-comprehensive-tutorial-to-rust-operators-for-beginners-11554b2c64d4?source=collection_archive---------23-----------------------#2020-07-31</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="895a" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">方法、相关函数、将 Python 转换成 Rust 等等</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/52f3e3485bb57a52aa30308dc752c926.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T7hpXq1pu_S-bMQGCmTLDw.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">由 pikisuperstar 创建的健康矢量—<a class="ae kz" href="http://www.freepik.com" rel="noopener ugc nofollow" target="_blank">www.freepik.com</a></p></figure><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="5163" class="lf lg iu lb b gz lh li l lj lk"><strong class="lb iv">Table of Contents</strong></span><span id="b6a8" class="lf lg iu lb b gz ll li l lj lk"><a class="ae kz" href="#f77d" rel="noopener ugc nofollow"><strong class="lb iv">Introduction</strong></a></span><span id="9469" class="lf lg iu lb b gz ll li l lj lk">🦀 <a class="ae kz" href="#7b55" rel="noopener ugc nofollow">Arithmetic Operators</a><br/>🦀 <a class="ae kz" href="#ec1d" rel="noopener ugc nofollow">Comparison Operators</a><br/>🦀 <a class="ae kz" href="#71e3" rel="noopener ugc nofollow">Logical Operators</a><br/>🦀 <a class="ae kz" href="#b809" rel="noopener ugc nofollow">Bitwise Operators</a><br/>🦀 <a class="ae kz" href="#06a0" rel="noopener ugc nofollow">Compound Assignment Operators</a><br/>🦀 <a class="ae kz" href="#de94" rel="noopener ugc nofollow">Operator Overloading</a><br/>🦀 <a class="ae kz" href="#f515" rel="noopener ugc nofollow">XOR and Bitwise Operators Truth Table</a><br/>🦀 <a class="ae kz" href="#bb38" rel="noopener ugc nofollow">Problem 1: Single Number</a><br/>🦀 <a class="ae kz" href="#6fa3" rel="noopener ugc nofollow">Python Solution</a><br/>🦀 <a class="ae kz" href="#0af4" rel="noopener ugc nofollow">Rust Code</a><br/>🦀 <a class="ae kz" href="#c7fe" rel="noopener ugc nofollow">Method and Associated Functions</a><br/>🦀 <a class="ae kz" href="#7878" rel="noopener ugc nofollow">Solution Using an Associated Function</a><br/>🦀 <a class="ae kz" href="#a615" rel="noopener ugc nofollow">Problem 2: Number of Steps to Reduce a Number to Zero</a></span><span id="1c6a" class="lf lg iu lb b gz ll li l lj lk"><a class="ae kz" href="#678b" rel="noopener ugc nofollow"><strong class="lb iv">Conclusion</strong></a></span></pre><p id="e38b" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">[更新于 2020 年 2 月 18 日。代码更改为要点并添加了链接]</p><h1 id="f77d" class="mi lg iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">介绍</h1><p id="b896" class="pw-post-body-paragraph lm ln iu lo b lp mz jv lr ls na jy lu lv nb lx ly lz nc mb mc md nd mf mg mh in bi translated">运算符告诉编译器或解释器执行特定的数学、关系或逻辑运算。许多编程语言都使用类似的操作符。</p><p id="1280" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">我们将讨论 Rust 中重要的算术、关系和逻辑操作符，并将它们与 Python 进行比较。</p><p id="9aaf" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">我们将学习方法和相关函数之间的区别。</p><p id="6611" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">我们还将两个简单的 Python 代码转换成 Rust 代码，以了解更多关于 Rust 编程的知识。</p><p id="0e03" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">我们开始吧！</p></div><div class="ab cl ne nf hy ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="in io ip iq ir"><div class="kk kl km kn gu nl"><a rel="noopener follow" target="_blank" href="/learning-rust-by-converting-python-to-rust-259e735591c6"><div class="nm ab fp"><div class="nn ab no cl cj np"><h2 class="bd iv gz z fq nq fs ft nr fv fx it bi translated">通过将 Python 转换成 Rust 来学习 Rust</h2><div class="ns l"><h3 class="bd b gz z fq nq fs ft nr fv fx dk translated">Rust 基础入门教程</h3></div><div class="nt l"><p class="bd b dl z fq nq fs ft nr fv fx dk translated">towardsdatascience.com</p></div></div><div class="nu l"><div class="nv l nw nx ny nu nz kt nl"/></div></div></a></div></div><div class="ab cl ne nf hy ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="in io ip iq ir"><h1 id="7b55" class="mi lg iu bd mj mk oa mm mn mo ob mq mr ka oc kb mt kd od ke mv kg oe kh mx my bi translated">算术运算符</h1><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj of"><img src="../Images/4a0c260bfaf2c4332bdfb6d6243c141d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q6NEUPwIClKKeGoIj4z8Zw.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Rust 和 Python 算术运算符。图片由作者提供。</p></figure><p id="338d" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">Python 和 Rust 共享相同的算术符号，如上表所示。锈称<code class="fe og oh oi lb b">%</code>为<strong class="lo iv"> <em class="oj">余数</em> </strong>而不是<strong class="lo iv"> <em class="oj">模数</em> </strong>。</p><p id="ab9b" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">我们将在后面的<a class="ae kz" rel="noopener" target="_blank" href="/a-comprehensive-tutorial-to-rust-operators-for-beginners-11554b2c64d4#de94">操作符过载</a>中讨论“生锈过载特性”。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ok ol l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://tech.io/snippet/DgvhrO7" rel="noopener ugc nofollow" target="_blank">网上试试这个 Rust lang 代码。</a></p></figure><p id="d717" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">输出:</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="3287" class="lf lg iu lb b gz lh li l lj lk">a: 20, b: 20+1=21, c: 20-2=18, d: 20*3=60, e: 20/4=5, f: 20%3=2</span></pre><p id="212b" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">在 Rust 中，不能在一个操作中使用不同的<strong class="lo iv">数据</strong> <strong class="lo iv">类型</strong>。例如，如果你试图从一个<a class="ae kz" rel="noopener" target="_blank" href="/unsinged-signed-integers-and-casting-in-rust-9a847bfc398f#3e54"> <strong class="lo iv">有符号整数</strong> </a>中减去一个<a class="ae kz" rel="noopener" target="_blank" href="/unsinged-signed-integers-and-casting-in-rust-9a847bfc398f#f4ce"> <strong class="lo iv">无符号整数</strong> </a>，就会失败:</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="e61e" class="lf lg iu lb b gz lh li l lj lk">// This will fail.<br/>fn main() {<br/>    let a = 8u8;<br/>    let b = 2i32;<br/>    println!("{}", a - b);<br/>}</span></pre><p id="9c1c" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">Rust 使用<code class="fe og oh oi lb b"><a class="ae kz" href="https://doc.rust-lang.org/std/keyword.as.html" rel="noopener ugc nofollow" target="_blank"><strong class="lo iv">as</strong></a></code> <a class="ae kz" href="https://doc.rust-lang.org/std/keyword.as.html" rel="noopener ugc nofollow" target="_blank">关键字</a>在<strong class="lo iv">原语类型</strong>之间进行强制转换。请点击阅读更多关于《铁锈》剧组<a class="ae kz" rel="noopener" target="_blank" href="/unsinged-signed-integers-and-casting-in-rust-9a847bfc398f#0883">的内容。</a></p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ok ol l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">在线试用这个 Rust lang 代码。</p></figure><p id="3ce1" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">输出:</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="97af" class="lf lg iu lb b gz lh li l lj lk">6</span></pre><p id="b55b" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated"><strong class="lo iv">指数<br/> </strong> Python 使用<code class="fe og oh oi lb b">**</code>符号表示指数:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ok ol l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://tech.io/snippet/Sxrd9HE" rel="noopener ugc nofollow" target="_blank">网上试试这个锈郎代码。</a></p></figure><p id="2c3b" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">输出:</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="548c" class="lf lg iu lb b gz lh li l lj lk">2^3 is  8<br/>3^3 is  27<br/>3^3.2 is  33.63473536961897</span></pre><p id="cfec" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">锈的用途<code class="fe og oh oi lb b"><strong class="lo iv">pow</strong></code>、<code class="fe og oh oi lb b"><strong class="lo iv">powi</strong></code>、<code class="fe og oh oi lb b"><strong class="lo iv">powf</strong></code>、<strong class="lo iv">、</strong>取决于类型:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ok ol l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://tech.io/snippet/0kq8GOD" rel="noopener ugc nofollow" target="_blank">网上试试这个 Rust lang 代码。</a></p></figure><p id="d751" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">输出:</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="a7c0" class="lf lg iu lb b gz lh li l lj lk">2 ^ 3 in Rust: 2u8.pow(3) = 8<br/>2 ^ 3 in Rust: 2i32.pow(3) is 8<br/>3.0 ^ 3 in Rust: 3.0f32.powi(3) 27<br/>3.0 ^ 3.2 in Rust: 3.0_f32.powf(3.2) is 33.63474<br/>a = 3, a ^ 3 in Rust: i32::pow(a,3) = 27<br/>b = 3.1, b ^ 3 in Rust: f64::powi(b, 3) = 29.791000000000004<br/>b = 3.1, b ^ PI in Rust: std::f64::consts::PI) = 34.96699308140392</span></pre><p id="87e8" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">在 Rust 中，您可以注释类似于<code class="fe og oh oi lb b">2u8</code>或<code class="fe og oh oi lb b">2_u8</code>的数字类型。<code class="fe og oh oi lb b">u8</code>是一个<a class="ae kz" rel="noopener" target="_blank" href="/unsinged-signed-integers-and-casting-in-rust-9a847bfc398f#f4ce">无符号 8 位整数类型</a>而<code class="fe og oh oi lb b">i32</code>是一个<a class="ae kz" rel="noopener" target="_blank" href="/unsinged-signed-integers-and-casting-in-rust-9a847bfc398f#3e54">有符号整数类型</a>。</p><p id="9c8b" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated"><code class="fe og oh oi lb b"><a class="ae kz" href="https://doc.rust-lang.org/std/primitive.i32.html" rel="noopener ugc nofollow" target="_blank">i32</a></code>和<code class="fe og oh oi lb b"><a class="ae kz" href="https://doc.rust-lang.org/std/primitive.f32.html" rel="noopener ugc nofollow" target="_blank">f32</a></code>有一组内置方法。所有的整数类型<code class="fe og oh oi lb b">u8</code>、<code class="fe og oh oi lb b">u16</code>、<code class="fe og oh oi lb b">u32</code>、<code class="fe og oh oi lb b">u64</code>、<code class="fe og oh oi lb b">u128</code>、<code class="fe og oh oi lb b">i16</code>、<code class="fe og oh oi lb b">i32</code>、<code class="fe og oh oi lb b">i64</code>、<code class="fe og oh oi lb b">i128</code>、<code class="fe og oh oi lb b">isize</code>、<code class="fe og oh oi lb b">usize</code>都有<code class="fe og oh oi lb b"><a class="ae kz" href="https://doc.rust-lang.org/std/primitive.i32.html#method.pow" rel="noopener ugc nofollow" target="_blank"><strong class="lo iv">pow</strong></a></code>方法。</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="f6af" class="lf lg iu lb b gz lh li l lj lk">pub fn pow(self, exp: u32) -&gt; i32</span></pre><p id="576c" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">上面的定义告诉你，使用<code class="fe og oh oi lb b">pow</code>方法将 self 提升到<code class="fe og oh oi lb b">exp</code>(也就是<code class="fe og oh oi lb b">u32</code>)的幂，并返回<code class="fe og oh oi lb b">i32</code>(有符号整数)。</p><p id="5af5" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated"><strong class="lo iv">浮点类型</strong>、<code class="fe og oh oi lb b">f32</code>和<code class="fe og oh oi lb b">f64</code>有<code class="fe og oh oi lb b"><a class="ae kz" href="https://doc.rust-lang.org/std/primitive.f32.html#method.powi" rel="noopener ugc nofollow" target="_blank"><strong class="lo iv">powi</strong></a></code>和<code class="fe og oh oi lb b"><a class="ae kz" href="https://doc.rust-lang.org/std/primitive.f32.html#method.powf" rel="noopener ugc nofollow" target="_blank"><strong class="lo iv">powf</strong></a></code>方法。</p><p id="61c8" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated"><code class="fe og oh oi lb b"><strong class="lo iv">powi</strong></code>对一个数字进行整数幂运算，而<code class="fe og oh oi lb b"><strong class="lo iv">powf</strong></code>对一个数字进行浮点幂运算。</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="a16c" class="lf lg iu lb b gz lh li l lj lk">pub fn powi(self, n: i32) -&gt; f32<br/>pub fn powf(self, n: f32) -&gt; f32</span></pre><p id="9788" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated"><strong class="lo iv">楼层划分<br/> </strong>在 Python 中，我们用<code class="fe og oh oi lb b">//</code>来找一个楼层划分。比如<code class="fe og oh oi lb b">5//2=2</code>。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ok ol l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://tech.io/snippet/Oph8VrM" rel="noopener ugc nofollow" target="_blank">网上试试这个 Rust lang 代码。</a></p></figure><p id="d174" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">输出:</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="55ce" class="lf lg iu lb b gz lh li l lj lk">5 // 2 is  2<br/>-5 // 2 is  -3</span></pre><p id="a3d3" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated"><a class="ae kz" href="https://doc.rust-lang.org/book/ch03-02-data-types.html#floating-point-types" rel="noopener ugc nofollow" target="_blank"> Rust 的浮点类型</a>使用<a class="ae kz" href="https://doc.rust-lang.org/std/primitive.f64.html#method.floor" rel="noopener ugc nofollow" target="_blank"> floor 方法</a>。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ok ol l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://tech.io/snippet/gVdlQlz" rel="noopener ugc nofollow" target="_blank">试试这个 Rust lang 在线代码。</a></p></figure><p id="a130" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">输出:</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="6b7e" class="lf lg iu lb b gz lh li l lj lk">2<br/>-3</span></pre><h1 id="ec1d" class="mi lg iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">比较运算符</h1><p id="890c" class="pw-post-body-paragraph lm ln iu lo b lp mz jv lr ls na jy lu lv nb lx ly lz nc mb mc md nd mf mg mh in bi translated">Python 和 Rust 共享所有比较运算符的相同符号。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj om"><img src="../Images/63cef855bf22118f2741e87159bc1198.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JE8dMyd4T_IHIVZSmpkreA.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Rust 和 Python 比较运算符。图片由作者提供。</p></figure><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ok ol l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://tech.io/snippet/7rIY3ZZ" rel="noopener ugc nofollow" target="_blank">网上试试这个 Rust lang 代码。</a></p></figure><p id="266e" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">输出:</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="f95b" class="lf lg iu lb b gz lh li l lj lk">    a: 7, b: 4, <br/>    c: 7 == 4 is false, <br/>    d: 7 != 4 is true, <br/>    e: 7&lt;4 is false, <br/>    f: 7&gt;4 is true, <br/>    g: 7&lt;=7 is true, <br/>    h: 7&gt;=7 is true</span></pre><h1 id="71e3" class="mi lg iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">逻辑运算符</h1><p id="e121" class="pw-post-body-paragraph lm ln iu lo b lp mz jv lr ls na jy lu lv nb lx ly lz nc mb mc md nd mf mg mh in bi translated">Rust 逻辑运算符符号不同于 Python 符号。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj on"><img src="../Images/da094f6636bbb27b8bb4a513486a5e8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7aeDzOUJj3yVPDaCJ6Qo8g.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Rust 和 Python 逻辑运算符。图片由作者提供。</p></figure><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ok ol l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://tech.io/snippet/aYZheXe" rel="noopener ugc nofollow" target="_blank">网上试试这个锈郎代码。</a></p></figure><p id="b94c" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">输出:</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="fa8e" class="lf lg iu lb b gz lh li l lj lk">    a: true, b: false, <br/>    c: !true is false, <br/>    d: true &amp;&amp; false is false, <br/>    e: true || false is true</span></pre><h1 id="b809" class="mi lg iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">按位运算符</h1><p id="87f7" class="pw-post-body-paragraph lm ln iu lo b lp mz jv lr ls na jy lu lv nb lx ly lz nc mb mc md nd mf mg mh in bi translated">所有 Rust 和 Python 按位运算符共享相同的按位运算符符号，除了按位 NOT。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oo"><img src="../Images/7fa94d4202a43064263ced2ef5cdabf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7KnNGDP8rXMmePAfoopqoQ.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Rust 和 Python 按位运算符。图片由作者提供。</p></figure><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ok ol l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://tech.io/snippet/hFNtUaq" rel="noopener ugc nofollow" target="_blank">网上试试这个 Rust lang 代码。</a></p></figure><p id="75bb" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">输出:</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="b6df" class="lf lg iu lb b gz lh li l lj lk">    a: 1, b: 2, <br/>    c: 1 &amp; 2 is 0, <br/>    d: 1 | 2 is 3, <br/>    e: 1 ^ 2 is 3,<br/>    f: 1 &lt;&lt; 2 is 4,<br/>    f2: 1 &lt;&lt; 4 is 16,<br/>    g: 1 &gt;&gt; 2 is 0,<br/>    g2: 1 &gt;&gt; 2 is 1,<br/>    h: !1 = -2</span></pre><p id="71bd" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated"><a class="ae kz" rel="noopener" target="_blank" href="/unsinged-signed-integers-and-casting-in-rust-9a847bfc398f#108b"> <strong class="lo iv">按位求反</strong> </a> <code class="fe og oh oi lb b">!1</code>返回<code class="fe og oh oi lb b">-2</code>。Rust 使用二进制补码来查找有符号类型的按位求反。Rust 的有符号整数类型被称为<strong class="lo iv">有符号二进制补码整数类型</strong>。</p><p id="ee77" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">可以用<code class="fe og oh oi lb b">1 &lt;&lt; n</code>求出 2 的指数。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ok ol l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://tech.io/snippet/IxBOL73" rel="noopener ugc nofollow" target="_blank">网上试试这个 Rust lang 代码。</a></p></figure><p id="e604" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">输出:</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="ec40" class="lf lg iu lb b gz lh li l lj lk">2 ^ 3 = 8<br/>2 ^ 4 = 16<br/>2 ^ 5 = 32</span></pre><h1 id="06a0" class="mi lg iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">复合赋值运算符</h1><p id="aa72" class="pw-post-body-paragraph lm ln iu lo b lp mz jv lr ls na jy lu lv nb lx ly lz nc mb mc md nd mf mg mh in bi translated">所有 Rust 和 Python 复合赋值运算符具有相同的符号，除了 Rust 不具有幂赋值<code class="fe og oh oi lb b">**=</code>和楼层划分赋值<code class="fe og oh oi lb b">//=</code>的等价性。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj op"><img src="../Images/6e90fcbfc391a00e5a510ab6455ce02c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*psY06OU2ByG9L9OgTWtHhQ.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Rust 和 Python 复合赋值运算符</p></figure><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ok ol l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://tech.io/snippet/OkhjR8Q" rel="noopener ugc nofollow" target="_blank">网上试试这个 Rust lang 代码。</a></p></figure><p id="5b1a" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">输出:</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="1416" class="lf lg iu lb b gz lh li l lj lk">a is 2<br/>1: a += 5 is 7<br/>2: a -= 2 is 5<br/>3: a *= 5 is 25<br/>4: a /= 2 is 12<br/>5: a %= 5 is 2<br/>6: a &amp;= 2 is 2<br/>7: a |= 5 is 7<br/>8: a ^= 2 is 5<br/>9: a &lt;&lt;= 1 is 10<br/>10: a &gt;&gt;= 2 is 2</span></pre><h1 id="de94" class="mi lg iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">运算符重载</h1><p id="8a9d" class="pw-post-body-paragraph lm ln iu lo b lp mz jv lr ls na jy lu lv nb lx ly lz nc mb mc md nd mf mg mh in bi translated">运算符重载就是在同一个范围内为一个运算符指定多个定义。<a class="ae kz" href="https://www.programiz.com/python-programming/operator-overloading" rel="noopener ugc nofollow" target="_blank"> Python </a>和<a class="ae kz" href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#default-generic-type-parameters-and-operator-overloading" rel="noopener ugc nofollow" target="_blank"> Rust </a>提供操作符重载。你可以在<a class="ae kz" href="https://doc.rust-lang.org/std/ops/index.html" rel="noopener ugc nofollow" target="_blank">标准库 ops 模块</a>中找到 Rust 重载运算符。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ok ol l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://tech.io/snippet/DfobnuL" rel="noopener ugc nofollow" target="_blank">网上试试这个 Rust lang 代码。</a></p></figure><p id="5be9" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">输出:</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="9020" class="lf lg iu lb b gz lh li l lj lk">Point { x: 3, y: 3 }</span></pre><h1 id="f515" class="mi lg iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">XOR 和按位运算符真值表</h1><p id="7c03" class="pw-post-body-paragraph lm ln iu lo b lp mz jv lr ls na jy lu lv nb lx ly lz nc mb mc md nd mf mg mh in bi translated">正如我们之前看到的，Python 和 Rust 对位符号<code class="fe og oh oi lb b">AND</code>、<code class="fe og oh oi lb b">OR</code>和<code class="fe og oh oi lb b">XOR</code>使用相同的符号。</p><p id="f7c8" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated"><code class="fe og oh oi lb b">&amp;</code>是按位<code class="fe og oh oi lb b">AND</code>，<code class="fe og oh oi lb b">|</code>是按位<code class="fe og oh oi lb b">OR</code>，<code class="fe og oh oi lb b">^</code>是按位异或(异或)。下面可以看到真值表和维恩图。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj op"><img src="../Images/266f3a3f696a93b3436f31bb10e76157.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JsniU7JWvLJcotFSqifrjA.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">与、或和异或的真值表。</p></figure><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oq"><img src="../Images/24b50dfd4d232f264c0f72aac3ea564b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rbKQSjFMR9LCLWZySA7kLg.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">与、异或或文氏图</p></figure><p id="152e" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">当您将<code class="fe og oh oi lb b">XOR</code>用于相同数字的偶数时，输出始终为 0。</p><p id="7497" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">在 Rust 中，可以用<code class="fe og oh oi lb b">{:#b}</code>打印<a class="ae kz" href="https://doc.rust-lang.org/std/fmt/trait.Binary.html" rel="noopener ugc nofollow" target="_blank">二进制</a>。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ok ol l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://tech.io/snippet/g16peM6" rel="noopener ugc nofollow" target="_blank">网上试试这个 Rust lang 代码。</a></p></figure><p id="efe3" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">输出:</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="e94f" class="lf lg iu lb b gz lh li l lj lk">0 ^ 0 = 0<br/>Binary: 0 ^ 0 = 0b0<br/>1 ^ 1 = 0<br/>Binary: 1 ^ 1 = 0b0<br/>2 ^ 2 = 0<br/>Binary: 2 ^ 2 = 0b0<br/>3 ^ 5 ^ 3 ^ 5 = 0<br/>Binary: 3 ^ 5 ^ 3 ^ 5 = 0b0<br/>1 ^ 1 ^ 1 = 1<br/>Binary: 1 ^ 1 ^ 1 = 0b1<br/>1 ^ 1 ^ 5 = 5<br/>Binary: 1 ^ 1 ^ 5 = 0b101</span></pre><p id="5144" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">你可以在这里找到 Python 代码<a class="ae kz" href="https://tech.io/snippet/EwQF2dO" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="bb38" class="mi lg iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">问题一:单号</h1><p id="95fa" class="pw-post-body-paragraph lm ln iu lo b lp mz jv lr ls na jy lu lv nb lx ly lz nc mb mc md nd mf mg mh in bi translated">我们要用这个<code class="fe og oh oi lb b">XOR</code>来解决叫做<a class="ae kz" href="https://leetcode.com/problems/single-number/" rel="noopener ugc nofollow" target="_blank">单号</a>的 LeetCoder 问题。</p><p id="65f4" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">在这个问题中，一个数组输入有一对数字，除了一个，例如<code class="fe og oh oi lb b">[1, 1, 5, 5, 2]</code>。你需要从这个数组中找到一个 sing 数，在这种情况下，输出应该是<code class="fe og oh oi lb b">2</code>。</p><p id="8901" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">更多例子:输入为<code class="fe og oh oi lb b">[2, 2, 1]</code>时，输出应为<code class="fe og oh oi lb b">1</code>。当输入为<code class="fe og oh oi lb b">[4, 1, 2, 1, 2]</code>时，输出应为<code class="fe og oh oi lb b">4</code>。</p><p id="d797" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">这是一个使用<code class="fe og oh oi lb b">XOR</code>操作符的好例子。</p><h1 id="6fa3" class="mi lg iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">Python 解决方案</h1><p id="edf0" class="pw-post-body-paragraph lm ln iu lo b lp mz jv lr ls na jy lu lv nb lx ly lz nc mb mc md nd mf mg mh in bi translated">我们简单地浏览一下 Python 解决方案，看看这个问题是如何解决的。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ok ol l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">在线尝试这段 Python 代码。</p></figure><p id="3bd7" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">输出:</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="f909" class="lf lg iu lb b gz lh li l lj lk">4</span></pre><p id="dcc9" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">第 1 行:我们使用的 Python <code class="fe og oh oi lb b">typing</code>是从 v3.5 引入的<a class="ae kz" href="https://docs.python.org/3/library/typing.html" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="55af" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">第 3–4 行:导入<code class="fe og oh oi lb b">List</code>后，我们创建了一个名为<code class="fe og oh oi lb b">Solution</code>的类和一个名为<code class="fe og oh oi lb b">singleNumber</code>的方法。</p><p id="d531" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">使用<a class="ae kz" href="https://mypy.readthedocs.io/en/stable/cheat_sheet_py3.html" rel="noopener ugc nofollow" target="_blank"> Python 类型提示</a>，我们将类型的名称大写，并将集合中的类型名称放在括号中，如上所示<code class="fe og oh oi lb b">num: List[int]</code>。</p><p id="14aa" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">第 5–8 行:我们将变量<code class="fe og oh oi lb b">ans</code>设置为 0。使用一个<code class="fe og oh oi lb b">for</code>循环，我们使用<code class="fe og oh oi lb b">XOR</code>复合赋值<code class="fe og oh oi lb b">ans ^= n</code>迭代输入数组<code class="fe og oh oi lb b">nums</code>。这将从数组中输出一个数字。</p><p id="06fb" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">第 10–11 行:我们实例化类<code class="fe og oh oi lb b">Solution</code>并调用方法<code class="fe og oh oi lb b">singleNumber</code>。</p><p id="48f6" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">(如果您对<a class="ae kz" href="https://tech.io/snippet/ak3wW3m" rel="noopener ugc nofollow" target="_blank">感兴趣</a>，您可以在没有类型符号的情况下运行这段 Python 代码。)</p><p id="aa37" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">以下是 LeetCode 环境的解决方案:</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="cbe5" class="lf lg iu lb b gz lh li l lj lk">class Solution:<br/>    def singleNumber(self, nums: List[int]) -&gt; int:<br/>        ans = 0<br/>        for n in nums:<br/>            ans ^= n<br/>        return ans</span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj or"><img src="../Images/b9157f16ab87d09e2da0a2de1f9efca4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G4FT1HOlNPdQ60FeIY7stw.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Python 结果。</p></figure><h1 id="0af4" class="mi lg iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">生锈代码</h1><p id="0073" class="pw-post-body-paragraph lm ln iu lo b lp mz jv lr ls na jy lu lv nb lx ly lz nc mb mc md nd mf mg mh in bi translated">Rust <a class="ae kz" rel="noopener" target="_blank" href="/learning-rust-by-converting-python-to-rust-259e735591c6#27aa"> <em class="oj">结构</em> </a>包含命名字段。我们使用关键字<code class="fe og oh oi lb b">struct</code>并在花括号内设置字段类型。我们把方法放到一个<code class="fe og oh oi lb b">impl</code>块中。</p><p id="1a93" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated"><strong class="lo iv">起始代码</strong></p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ok ol l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://tech.io/snippet/zHoobRv" rel="noopener ugc nofollow" target="_blank">试试这个 Rust lang 在线代码。</a></p></figure><p id="4856" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">输出:</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="48f7" class="lf lg iu lb b gz lh li l lj lk">1</span></pre><p id="ddb2" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">第 1 行:我们取消<code class="fe og oh oi lb b">dead_code</code>警告。</p><p id="dce5" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">第 2–4 行:创建一个名为<code class="fe og oh oi lb b">Solution</code>的<code class="fe og oh oi lb b">struct</code>,它接受一个类型为<code class="fe og oh oi lb b">Vec&lt;i32&gt;</code>的字段<code class="fe og oh oi lb b">nums </code>。(更多关于<a class="ae kz" rel="noopener" target="_blank" href="/learning-rust-by-converting-python-to-rust-259e735591c6#bac7">向量</a>。)</p><p id="5cc3" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">第 6–10 行:我们在<code class="fe og oh oi lb b">impl Solution</code>中创建了一个方法<code class="fe og oh oi lb b">single_number</code>。<code class="fe og oh oi lb b">single_number</code>取第一个参数<code class="fe og oh oi lb b">&amp;self</code> ( <a class="ae kz" rel="noopener" target="_blank" href="/learning-rust-by-converting-python-to-rust-259e735591c6#f6fb">详见</a> <code class="fe og oh oi lb b"><a class="ae kz" rel="noopener" target="_blank" href="/learning-rust-by-converting-python-to-rust-259e735591c6#f6fb">self</a></code> <a class="ae kz" rel="noopener" target="_blank" href="/learning-rust-by-converting-python-to-rust-259e735591c6#f6fb"> </a>)。)而我们现在只是返回<code class="fe og oh oi lb b">1</code>。</p><p id="2f73" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">第 12–17 行:在 main 函数中，我们创建了一个实例并使用方法打印了<code class="fe og oh oi lb b">1</code>。</p><p id="91d4" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">看起来一切正常，所以我们接下来要完成<code class="fe og oh oi lb b">single_number</code>方法。</p><h1 id="c7fe" class="mi lg iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">方法和相关功能</h1><blockquote class="os"><p id="3211" class="ot ou iu bd ov ow ox oy oz pa pb mh dk translated">方法是在一个结构的上下文中定义的，它们的第一个参数总是<code class="fe og oh oi lb b">self</code>，它代表调用方法的结构的实例。Rust 编程语言</p></blockquote><p id="37e1" class="pw-post-body-paragraph lm ln iu lo b lp pc jv lr ls pd jy lu lv pe lx ly lz pf mb mc md pg mf mg mh in bi translated">关联函数不把<code class="fe og oh oi lb b">self</code>作为参数，它们也不是方法，因为它们没有可以使用的结构实例。</p><p id="3e57" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">一个很好的例子就是<code class="fe og oh oi lb b">String::from</code>函数。</p><p id="b91c" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">我们使用带有结构名的<code class="fe og oh oi lb b">::</code>语法来调用这个关联的函数，而当我们调用一个方法时，我们使用<code class="fe og oh oi lb b">.</code>。</p><p id="6a45" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">一个常见的关联函数是<code class="fe og oh oi lb b">new</code>函数，它返回与关联函数相关联的类型的值。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ok ol l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://tech.io/snippet/a5eUfxW" rel="noopener ugc nofollow" target="_blank">网上试试这个 Rust lang 代码。</a></p></figure><p id="c577" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">输出:</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="67c5" class="lf lg iu lb b gz lh li l lj lk">x: 5, y: 4<br/>x: 8, y: 9</span></pre><p id="c05a" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated"><strong class="lo iv">最终代码</strong></p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ok ol l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://tech.io/snippet/FeScAHr" rel="noopener ugc nofollow" target="_blank">网上试试这个 Rust lang 代码。</a></p></figure><p id="4256" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">第 7–11 行:我们创建了一个类型为<code class="fe og oh oi lb b">i32</code>的可变变量<code class="fe og oh oi lb b">ans</code>。使用<code class="fe og oh oi lb b">for</code>循环，我们使用<code class="fe og oh oi lb b">ans ^=n</code>迭代<code class="fe og oh oi lb b">&amp;self.nums</code>。</p><p id="128f" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">输出:</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="e090" class="lf lg iu lb b gz lh li l lj lk">5</span></pre><p id="da2e" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">我们根据 LeetCode 环境调整上面的代码。</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="5781" class="lf lg iu lb b gz lh li l lj lk">impl Solution {<br/>    pub fn single_number(nums: Vec&lt;i32&gt;) -&gt; i32 {<br/>        let mut ans: i32 = 0;<br/>        for n in nums {<br/>            ans ^= n;<br/>        }<br/>        ans        <br/>    }<br/>}</span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ph"><img src="../Images/775491ec5b67732366f234b3e2f3d1a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fHwro_yatM8FdTMLELtwRQ.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">铁锈导致了 LeetCode</p></figure><p id="48dd" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">内存使用在 Rust 中是 2.2 MB，在 Python 中是 16.5 MB。(<a class="ae kz" rel="noopener" target="_blank" href="/learning-rust-by-converting-python-to-rust-259e735591c6#7e45">更多关于运行时&amp;内存使用量</a>)</p><h1 id="7878" class="mi lg iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">使用关联函数的解决方案</h1><p id="f83e" class="pw-post-body-paragraph lm ln iu lo b lp mz jv lr ls na jy lu lv nb lx ly lz nc mb mc md nd mf mg mh in bi translated">既然学了关联函数，那就把它应用到这个问题上吧。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ok ol l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://tech.io/snippet/ndXlJXg" rel="noopener ugc nofollow" target="_blank">网上试试这个 Rust lang 代码。</a></p></figure><p id="45cf" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">输出:</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="bec4" class="lf lg iu lb b gz lh li l lj lk">1<br/>4</span></pre><p id="6954" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">第 6–10 行:我们创建一个关联函数，<code class="fe og oh oi lb b">new</code>，就像我们之前做的那样。这个<code class="fe og oh oi lb b">new</code>函数采用一个参数<code class="fe og oh oi lb b">nums</code>，该参数是一个带有<code class="fe og oh oi lb b">i32</code>项的向量。</p><p id="bbb4" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">当参数名和 struct 字段名完全相同时，我们可以使用<strong class="lo iv"> <em class="oj">字段初始化简写</em> </strong>语法作为<code class="fe og oh oi lb b">nums</code>而不是<code class="fe og oh oi lb b">nums: nums</code>。</p><p id="6ddc" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">在 main 函数中，我们调用一个关联函数<code class="fe og oh oi lb b">new</code>，并将<code class="fe og oh oi lb b">nums</code>作为参数传递。我们使用<em class="oj">方法语法</em>来调用<code class="fe og oh oi lb b">ans3</code>实例上的<code class="fe og oh oi lb b">single_number</code>方法。</p><h1 id="a615" class="mi lg iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">问题 2:将一个数化为零的步骤数</h1><p id="c04d" class="pw-post-body-paragraph lm ln iu lo b lp mz jv lr ls na jy lu lv nb lx ly lz nc mb mc md nd mf mg mh in bi translated">在<a class="ae kz" href="https://leetcode.com/problems/number-of-steps-to-reduce-a-number-to-zero/" rel="noopener ugc nofollow" target="_blank">这个问题</a>中，你输入一个非负整数<code class="fe og oh oi lb b">num</code>，返回步数使其降为零。如果当前数是偶数，你就要把它除以 2，否则，你就要从中减去 1。</p><p id="4044" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">例如:</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="9212" class="lf lg iu lb b gz lh li l lj lk">Input: num = 14<br/>Output: 6<br/>Explanation: <br/>Step 1) 14 is even; divide by 2 and obtain 7. <br/>Step 2) 7 is odd; subtract 1 and obtain 6.<br/>Step 3) 6 is even; divide by 2 and obtain 3. <br/>Step 4) 3 is odd; subtract 1 and obtain 2. <br/>Step 5) 2 is even; divide by 2 and obtain 1. <br/>Step 6) 1 is odd; subtract 1 and obtain 0.</span><span id="3b30" class="lf lg iu lb b gz ll li l lj lk">Input: num = 8<br/>Output: 4<br/>Explanation: <br/>Step 1) 8 is even; divide by 2 and obtain 4. <br/>Step 2) 4 is even; divide by 2 and obtain 2. <br/>Step 3) 2 is even; divide by 2 and obtain 1. <br/>Step 4) 1 is odd; subtract 1 and obtain 0.</span></pre><p id="3966" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">这是一个很好的例子，我们可以使用模数/余数运算符和复合赋值运算符。</p><p id="2f96" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated"><strong class="lo iv"> Python 解决方案</strong></p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ok ol l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">在线尝试这段 Python 代码。</p></figure><p id="3dea" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">输出:</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="bf89" class="lf lg iu lb b gz lh li l lj lk">6<br/>4</span></pre><p id="4089" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">第 3–10 行:我们对<code class="fe og oh oi lb b">num &gt; 0</code>使用了一个<code class="fe og oh oi lb b">while</code>循环。如果模数是 0，那么它一定是一个偶数，所以我们使用复合赋值<code class="fe og oh oi lb b">/=2</code>将<code class="fe og oh oi lb b">num</code>除以 2，否则，我们使用复合赋值<code class="fe og oh oi lb b">-=1</code>减去 1。我们将<code class="fe og oh oi lb b">steps</code>增加 1。最后，我们返回<code class="fe og oh oi lb b">steps</code>。</p><p id="8fbe" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">我们根据 LeetCode 环境调整上面的代码。</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="c440" class="lf lg iu lb b gz lh li l lj lk">class Solution:<br/>    def numberOfSteps (self, num: int) -&gt; int:<br/>        steps = 0<br/>        while num &gt; 0:<br/>            if num % 2 == 0:<br/>                num //= 2 <br/>            else:<br/>                num -=1 <br/>            steps += 1<br/>        return steps</span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj pi"><img src="../Images/4723b99f5aa9498f171c2188b12ef3aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/1*i_Vf1qoqjEbjG1PaN6q-Xw.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">LeetCode 的 Python 结果。</p></figure><p id="4b0b" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated"><strong class="lo iv">防锈液</strong></p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ok ol l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://tech.io/snippet/G2gbuse" rel="noopener ugc nofollow" target="_blank">网上试试这个 Rust lang 代码。</a></p></figure><p id="1142" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">输出:</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="c0fa" class="lf lg iu lb b gz lh li l lj lk">6<br/>4</span></pre><p id="802a" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">在 Rust 中，我们采取了与 Python 相同的步骤。</p><p id="a3e3" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">第 7–16 行:我们将 0 赋给一个可变变量<code class="fe og oh oi lb b">steps</code>。当<code class="fe og oh oi lb b">self.num</code>大于 0 时，如果<code class="fe og oh oi lb b">self.num</code>的余数为 0，我们使用复合赋值<code class="fe og oh oi lb b">/=2</code>，否则，我们减去 1，并将步数增加 1。</p><p id="1bbc" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">我们根据 LeetCode 环境调整上面的代码。</p><pre class="kk kl km kn gu la lb lc ld aw le bi"><span id="ceb5" class="lf lg iu lb b gz lh li l lj lk">impl Solution {<br/>    pub fn number_of_steps (mut num: i32) -&gt; i32 {<br/>        let mut steps = 0;<br/>        while num &gt; 0 {<br/>            if num % 2 == 0 {<br/>                num /= 2;<br/>            } else {<br/>                num -=1;<br/>            }<br/>            steps += 1;<br/>        }<br/>        steps<br/>    }<br/>}</span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj pj"><img src="../Images/cd502820b925ba32321129d55d0e03a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/format:webp/1*sKtcUWLy-COEp1GlzrRVdQ.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">生锈是由漏电引起的</p></figure><h1 id="678b" class="mi lg iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">结论</h1><p id="56ef" class="pw-post-body-paragraph lm ln iu lo b lp mz jv lr ls na jy lu lv nb lx ly lz nc mb mc md nd mf mg mh in bi translated">我们在 Rust 中学习了算术、比较、逻辑、按位和复合赋值操作符。我们还学习了操作符重载、关联函数和方法之间的区别，以及如何通过将简单的 Python 代码转换为 Rust 来使用 Rust 中的操作符。</p><p id="96d7" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated">我希望你学到了一些东西，并为下一步做好了准备。请继续关注下一篇文章。</p></div><div class="ab cl ne nf hy ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="in io ip iq ir"><p id="c310" class="pw-post-body-paragraph lm ln iu lo b lp lq jv lr ls lt jy lu lv lw lx ly lz ma mb mc md me mf mg mh in bi translated"><strong class="lo iv">通过</strong> <a class="ae kz" href="https://blog.codewithshin.com/membership" rel="noopener ugc nofollow" target="_blank"> <strong class="lo iv">成为</strong> </a> <strong class="lo iv">的会员，可以完全访问媒体上的每一个故事。</strong></p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj pk"><img src="../Images/0be3ee559fee844cb75615290e4a8b29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*DjTM9iFtVc2wlcWcOms7VQ.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://blog.codewithshin.com/subscribe" rel="noopener ugc nofollow" target="_blank">https://blog.codewithshin.com/subscribe</a></p></figure></div><div class="ab cl ne nf hy ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="in io ip iq ir"><h1 id="6031" class="mi lg iu bd mj mk oa mm mn mo ob mq mr ka oc kb mt kd od ke mv kg oe kh mx my bi translated">参考</h1><p id="9873" class="pw-post-body-paragraph lm ln iu lo b lp mz jv lr ls na jy lu lv nb lx ly lz nc mb mc md nd mf mg mh in bi translated">以下资源用于编写这篇文章:</p><ul class=""><li id="2ff5" class="pl pm iu lo b lp lq ls lt lv pn lz po md pp mh pq pr ps pt bi translated"><a class="ae kz" href="https://doc.rust-lang.org/book/appendix-02-operators.html#operators" rel="noopener ugc nofollow" target="_blank">https://doc . rust-lang . org/book/appendix-02-operators . html # operators</a></li><li id="9faa" class="pl pm iu lo b lp pu ls pv lv pw lz px md py mh pq pr ps pt bi translated"><a class="ae kz" href="https://www.programiz.com/python-programming/operators" rel="noopener ugc nofollow" target="_blank">https://www.programiz.com/python-programming/operators</a></li></ul></div><div class="ab cl ne nf hy ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="in io ip iq ir"><div class="kk kl km kn gu nl"><a rel="noopener follow" target="_blank" href="/unsinged-signed-integers-and-casting-in-rust-9a847bfc398f"><div class="nm ab fp"><div class="nn ab no cl cj np"><h2 class="bd iv gz z fq nq fs ft nr fv fx it bi translated">无符号、有符号整数和 Rust 初学者的造型</h2><div class="ns l"><h3 class="bd b gz z fq nq fs ft nr fv fx dk translated">理解符号和幅度、一的补码和二的补码</h3></div><div class="nt l"><p class="bd b dl z fq nq fs ft nr fv fx dk translated">towardsdatascience.com</p></div></div><div class="nu l"><div class="pz l nw nx ny nu nz kt nl"/></div></div></a></div></div></div>    
</body>
</html>