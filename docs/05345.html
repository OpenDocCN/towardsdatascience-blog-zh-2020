<html>
<head>
<title>Pipelines &amp; Custom Transformers in scikit-learn: The step-by-step guide (with Python code)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">scikit-learn中的管道和定制变压器:分步指南(带Python代码)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/pipelines-custom-transformers-in-scikit-learn-the-step-by-step-guide-with-python-code-4a7d9b068156?source=collection_archive---------0-----------------------#2020-05-06">https://towardsdatascience.com/pipelines-custom-transformers-in-scikit-learn-the-step-by-step-guide-with-python-code-4a7d9b068156?source=collection_archive---------0-----------------------#2020-05-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="05fc" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解scikit的基本知识和工作方式——从头开始学习管道，这样您就可以构建自己的管道。</h2></div><p id="c921" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文将涵盖:</p><ol class=""><li id="1588" class="lb lc iq kh b ki kj kl km ko ld ks le kw lf la lg lh li lj bi translated">为什么另一个关于管道的教程？</li><li id="9b1b" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la lg lh li lj bi translated">从头开始创建一个自定义转换器，以包含在管道中。</li><li id="3c2b" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la lg lh li lj bi translated">修改和参数化变压器。</li><li id="3a4a" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la lg lh li lj bi translated">通过<em class="lp">TransformedTargetRegressor</em>定制目标转换。</li><li id="611f" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la lg lh li lj bi translated">将所有东西链接在一个管道中。</li><li id="e519" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la lg lh li lj bi translated">链接到<a class="ae lq" href="https://github.com/HCGrit/MachineLearning-iamJustAStudent/tree/master/PipelineFoundation" rel="noopener ugc nofollow" target="_blank">从GitHub下载</a>完整代码。</li></ol><blockquote class="lr ls lt"><p id="0bef" class="kf kg lp kh b ki kj jr kk kl km ju kn lu kp kq kr lv kt ku kv lw kx ky kz la ij bi translated">对于那些喜欢这种格式的人来说，最后有一个代码的<a class="ae lq" href="https://youtu.be/mOYJCR0IDk8" rel="noopener ugc nofollow" target="_blank">视频演示</a>。我个人喜欢书面教程，但过去也有人要求视频版本，所以就有了。</p></blockquote><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi lx"><img src="../Images/913ecda9c86079a61df5e65c6af3ea94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cl2jZ1tgwrdgWFjtRXFcDA.jpeg"/></div></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">图片来自<a class="ae lq" href="https://pixabay.com/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=681175" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae lq" href="https://pixabay.com/users/Robzor-840419/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=681175" rel="noopener ugc nofollow" target="_blank">罗布森·马查多</a></p></figure><h1 id="c0eb" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated"><strong class="ak">为什么还要有关于管道的教程？</strong></h1><p id="6b4f" class="pw-post-body-paragraph kf kg iq kh b ki nf jr kk kl ng ju kn ko nh kq kr ks ni ku kv kw nj ky kz la ij bi nk translated">既然你在这里，很有可能你已经知道管道通过预处理数据使你的生活变得简单。我也听说了，并试图在我的代码中实现一个。</p><blockquote class="lr ls lt"><p id="4eb1" class="kf kg lp kh b ki kj jr kk kl km ju kn lu kp kq kr lv kt ku kv lw kx ky kz la ij bi translated">对我能找到的关于这个主题的几个很棒的教程的大声呼喊！我建议你在这篇文章之前或之后浏览一下:</p></blockquote><p id="bca4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一、<a class="ae lq" rel="noopener" target="_blank" href="/custom-transformers-and-ml-data-pipelines-with-python-20ea2a7adb65"><em class="lp">https://towards data science . com/custom-transformers-and-ml-data-pipelines-with-python-20 ea 2 a 7 ADB 65</em></a><br/>二、<a class="ae lq" href="https://machinelearningmastery.com/how-to-transform-target-variables-for-regression-with-scikit-learn/" rel="noopener ugc nofollow" target="_blank"><em class="lp">https://machine learning mastery . com/how-to-transform-target-variables-for-regression-with-scikit-learn</em></a><br/>三、<a class="ae lq" href="http://zacstewart.com/2014/08/05/pipelines-of-featureunions-of-pipelines.html" rel="noopener ugc nofollow" target="_blank"><em class="lp">http://Zac Stewart . com/2014/08/05/pipelines-of-feature unions-of-pipelines . html</em></a></p><p id="f717" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在跟随教程和使用标准的输入、缩放、功率变换等时，一切都很好。但是后来我想编写应用于数据的特定逻辑，并且不太确定什么在哪里被调用？</p><p id="1b1e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我试图寻找一个清晰的解释，说明构造函数fit()，transform()函数何时被调用，但是找不到一个简单的例子。因此，我决定一步一步地完成代码，并向任何想从头开始理解它的人展示我的理解。</p><p id="4890" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那我们开始吧！</p><h1 id="2cc5" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">从头开始创建自定义转换器，以包含在管道中</h1><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi nt"><img src="../Images/69fe9f7d15f966a789517e2bfefb6c74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8knrEH1zFaVvhtw1MA64pg.png"/></div></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">创建数据框架</p></figure><p id="a114" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi nk translated"><span class="l nl nm nn bm no np nq nr ns di">为了更好地理解示例，我们将创建一个数据集来帮助我们更好地探索代码。</span></p><p id="9020" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码创建了遵循等式<code class="fe nu nv nw nx b">y = X1 + 2 * sqrt(X2)</code>的数据。这确保了简单的线性回归模型不能完美地拟合它。</p><p id="021e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看看有哪些预测结果抛给了我们:</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi ny"><img src="../Images/eb581758ab570a440dec9cd9051d8d78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/format:webp/1*P05EEG-koQ2QEJ1_MfB_ug.png"/></div></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">原始数据的线性回归预测</p></figure><p id="38e5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完美的预测是14和17。预测并不差，但是我们是否可以对输入要素进行一些计算以使预测更好？</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi nz"><img src="../Images/beb6361a8b88992b8f2187f12671eed1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M2s09ZVCUalfzwLSxthiYg.png"/></div></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">输入特征操作后的预测</p></figure><p id="c65c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输入操作使其符合完美的线性趋势(现在是<code class="fe nu nv nw nx b">y=X1+X2</code>)，从而得到完美的预测。现在，这只是一个例子，但是假设对于一个数据集，你的分析说这样的输入转换是好的，你如何通过管道以一种安全的方式做到这一点。</p><p id="2b70" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看一个使用管道拟合的基本LinearRegression()模型。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi oa"><img src="../Images/0f823b1ddc9ba9d3916015c528fc4d6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UabbjB0Kf-7Z6T_mAzDnug.png"/></div></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">带有管道的LinearRegression()</p></figure><p id="ad31" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不出所料，我们得到了与第一次尝试相同的预测。此时的语法非常简单—</p><ol class=""><li id="aa6c" class="lb lc iq kh b ki kj kl km ko ld ks le kw lf la lg lh li lj bi translated">我们使用内部有<code class="fe nu nv nw nx b">steps</code>数组的<code class="fe nu nv nw nx b">Pipeline</code>类声明了一个<code class="fe nu nv nw nx b">pipe1</code>变量。该步骤的名称(在本例中为<code class="fe nu nv nw nx b">linear_model</code>)可以是您选择的任何独特的名称。其后是一个实际的变压器或估计器(在这种情况下，我们的<code class="fe nu nv nw nx b">LinearRegression()</code>模型)。</li><li id="89af" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la lg lh li lj bi translated">像任何其他模型一样，它是根据训练数据拟合的，但是使用了<code class="fe nu nv nw nx b">pipe1</code>变量。</li><li id="18f6" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la lg lh li lj bi translated">使用<code class="fe nu nv nw nx b">pipe1</code>对测试集进行预测，就像您在任何其他模型中所做的那样。</li></ol><p id="f68a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了执行输入计算/转换，我们将设计一个定制的转换器。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi ob"><img src="../Images/de39d95919df892643ef13ac61acafc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jOT9Z8uZue8Ociwd1ejfrg.png"/></div></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">定制输入变压器</p></figure><p id="a082" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们创建一个类，并将其命名为<code class="fe nu nv nw nx b">ExperimentalTransformer</code>。我们设计的所有变形金刚都将继承<code class="fe nu nv nw nx b">BaseEstimator</code>和<code class="fe nu nv nw nx b">TransformerMixin</code>类，因为它们免费提供给我们已有的方法。你可以在我上面提供的文章链接中读到更多关于它们的内容。</p><p id="edc8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里有3种方法可以处理:</p><ol class=""><li id="ebaf" class="lb lc iq kh b ki kj kl km ko ld ks le kw lf la lg lh li lj bi translated"><code class="fe nu nv nw nx b">__init__</code>:这是构造器。初始化管道时调用。</li><li id="cbd3" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la lg lh li lj bi translated"><code class="fe nu nv nw nx b">fit()</code>:拟合管道时调用。</li><li id="36be" class="lb lc iq kh b ki lk kl ll ko lm ks ln kw lo la lg lh li lj bi translated"><code class="fe nu nv nw nx b">transform()</code>:在管道上使用fit或transform时调用。</li></ol><p id="6418" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">目前，让我们将print()消息放在__init__ &amp; fit()中，并将我们的计算写在transform()中。正如您在上面看到的，我们在那里返回修改后的值。当调用fit()或transform()时，所有的输入特征将被传递到<code class="fe nu nv nw nx b">X</code>。</p><p id="bb14" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们把它放到一个管道中，看看这些函数被调用的顺序。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi oc"><img src="../Images/2eb33fcceac6ef6de834d261e09a932c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ezBGILQtOVC6DNZoECztkQ.png"/></div></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">管道中的实验变压器</p></figure><p id="82a1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以在上面的代码注释中看到，也可以使用更短的<a class="ae lq" href="https://scikit-learn.org/stable/modules/generated/sklearn.pipeline.make_pipeline.html" rel="noopener ugc nofollow" target="_blank"> make_pipeline() </a>语法来创建管道。</p><p id="58f1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在输出:</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi od"><img src="../Images/33231dce1b3380a4d8f7bb9afb0c7cef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y-0kRdxTQkJ1IfuxWuybUQ.png"/></div></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">实验变压器输出</p></figure><p id="908e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">需要注意的3件重要事情:</p><p id="808e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">a.__init__在我们初始化<code class="fe nu nv nw nx b">pipe2</code>变量时被调用。</p><p id="3ee0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">b.<strong class="kh ir">当我们对训练数据拟合管道时，我们的实验转换器的</strong> fit()和transform()都被调用。这是有意义的，因为这就是模型拟合的工作方式。在尝试预测train_y时，您需要变换输入要素。</p><p id="31e8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">c.当我们调用predict(test_X)时，会像预期的那样调用transform()-在进行预测之前，输入测试要素也需要平方根并加倍。</p><p id="dc88" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果——完美的预测！</p><h1 id="dfd0" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">修改和参数化变压器</h1><p id="1e9d" class="pw-post-body-paragraph kf kg iq kh b ki nf jr kk kl ng ju kn ko nh kq kr ks ni ku kv kw nj ky kz la ij bi nk translated"><span class="l nl nm nn bm no np nq nr ns di"> B </span> ut..</p><p id="abdf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在实验转换器的transform()函数中假设列名是X2。我们不要这样做，而是通过构造函数__init__()传递列名。</p><p id="f326" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是我们的<code class="fe nu nv nw nx b">ExperimentalTransformer_2</code>:</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi oe"><img src="../Images/8cb0d2962fddaa068fdd458e6f421684.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hk05A38Nv_E5jDP3bjRfSQ.png"/></div></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">向构造函数传递参数</p></figure><p id="989e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意保持函数参数和类变量中的参数名完全相同(<code class="fe nu nv nw nx b">feature_name</code>或任何你选择的名字)。当我们试图转换目标特征(y)时，改变它会导致问题。由于某种原因，它导致了对__init__的双重调用。</p><p id="2bf6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我还添加了一个带有默认值的additional_param，只是为了混淆一下。在我们的例子中，它并不真的需要，而是作为一个可选的参数。</p><p id="5fc5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在创建新管道:</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi of"><img src="../Images/8b46543eb70e27402a913927ea720630.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nfx5VWTqU130x00kJvtkwg.png"/></div></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">用新管道调用</p></figure><p id="bdaa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出符合预期:</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi og"><img src="../Images/f8fc7b8fca4f78ada441f2a539e4e081.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mDiG777k3ejzBao0q_xfSw.png"/></div></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">新输出，与以前相同</p></figure><h1 id="06a2" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">通过TransformedTargetRegressor自定义目标转换</h1><p id="5e4e" class="pw-post-body-paragraph kf kg iq kh b ki nf jr kk kl ng ju kn ko nh kq kr ks ni ku kv kw nj ky kz la ij bi nk translated"><span class="l nl nm nn bm no np nq nr ns di"> W </span>什么情况下需要做一些前后处理？</p><p id="c779" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">考虑一个稍微修改过的数据集:</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi oh"><img src="../Images/46a01e4d188014a89e0c11abb63774cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f28krk9Kfp_PaiG5n_df4g.png"/></div></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">数据集中的y平方</p></figure><p id="11c0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一切照旧，但现在<code class="fe nu nv nw nx b">y</code>已经摆平。为了将它拟合到一个简单的线性模型中，我们需要在拟合我们的模型之前对<code class="fe nu nv nw nx b">y</code>求平方根，然后对模型做出的任何预测求平方。</p><p id="1320" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用scikit-learn的<code class="fe nu nv nw nx b">TransformedTargetRegressor</code>来指示我们的管道对目标变量执行一些计算和反计算。让我们首先编写这两个函数:</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi oi"><img src="../Images/588ffc308ecff1364560c53457184214.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tCiPr9HUEo_snJp00Wb-cg.png"/></div></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">变换和逆变换函数</p></figure><p id="02d7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个平方根<code class="fe nu nv nw nx b">y</code>，另一个平方回来。</p><p id="7c45" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过管道调用:</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi oj"><img src="../Images/6f3da1f9107968d4cb6a094c84310983.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JhmhLlY2cHfyyXMiFBL2Tg.png"/></div></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">TransformedTargetRegressor调用</p></figure><p id="9a3e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">TransformedTargetRegressor类接受将我们的管道连接到这些新函数的<code class="fe nu nv nw nx b">regressor</code>、<code class="fe nu nv nw nx b">func</code>和<code class="fe nu nv nw nx b">inverse_func</code>参数。</p><p id="8126" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意我们现在如何安装<code class="fe nu nv nw nx b">model</code>，而不是管道。</p><p id="b62e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不过，输出显示了一些有趣且出乎意料的东西:</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi ok"><img src="../Images/032755915a8ca123622b8add91c0d0c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iZ78j7Qe3GEFJwNGcdsYhQ.png"/></div></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">TargetRegressor的第一个输出</p></figure><p id="6d3f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果很好，但是您能看到当fit()被调用时，我们的target_transform()和inverse_target_transform()方法是如何被多次调用的吗？这将成为大型项目和复杂管道的开销。处理这个问题所需的更改只是将TransformedTargetRegressor的<code class="fe nu nv nw nx b">check_inverse</code>参数设置为False。我们将在下一步中这样做，同时寻找另一种处理目标转换的方法——在TransformedTargetRegressor中使用<code class="fe nu nv nw nx b">transformer</code> param，而不是func和inverse_func。</p><p id="ffce" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以传递一个内置的转换器或我们自定义的转换器，而不是我们设计的两个函数。定制的转换器看起来与我们之前为我们的管道设计的几乎相同，但是在它里面有一个额外的<code class="fe nu nv nw nx b">inverse_transform</code>功能。实现如下:</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi ol"><img src="../Images/6c3431e5033cb19e9434146f087ca11a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rs6zdQkYagtKQrZC6c_YtQ.png"/></div></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">自定义目标变压器</p></figure><p id="cd76" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就这样，现在就在我们的TransformedTargetRegressor调用中使用它:</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi om"><img src="../Images/c528d3e58dd4f16beb51fc8093d975ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-IhQDrIiHTeaSWLaEFFZ4A.png"/></div></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">用变压器参数调用</p></figure><p id="37b4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出现在看起来是固定的:</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi on"><img src="../Images/04d49a558d8c60ee7ff4c10179e37b70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d1e1uiO5jJROnqc7cjqmRg.png"/></div></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">没有重复调用的输出</p></figure><p id="94a6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里要做的最后一件事。我们将利用<a class="ae lq" href="https://scikit-learn.org/stable/modules/compose.html?highlight=transformedtargetregressor#pipeline-chaining-estimators" rel="noopener ugc nofollow" target="_blank">缓存</a>来保存计算，并查看如何从外部获取或设置我们的管道参数(如果您想在此基础上应用GridSearch，稍后将需要这一点)。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi oo"><img src="../Images/a1425042cdc14b17e374c6edb5f83702.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dlrPaRLK2sdqoTDLjbXIPg.png"/></div></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">get_params()</p></figure><p id="a171" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，如何通过使用名称后跟双下划线<code class="fe nu nv nw nx b">__</code>来访问管道每个组件的每个参数。</p><p id="5111" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将把它们联系在一起，甚至尝试从外部设置一个参数——我们已经传递给构造函数的列名<code class="fe nu nv nw nx b">X2</code>。</p><figure class="ly lz ma mb gt mc gh gi paragraph-image"><div class="gh gi op"><img src="../Images/4fa0357653f15151b09a71a1dd1c1e53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/1*7sVjs_VekJlp98D0snfoyQ.png"/></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">把这一切联系在一起</p></figure><blockquote class="lr ls lt"><p id="3dc6" class="kf kg lp kh b ki kj jr kk kl km ju kn lu kp kq kr lv kt ku kv lw kx ky kz la ij bi translated">完整代码:<a class="ae lq" href="https://github.com/HCGrit/MachineLearning-iamJustAStudent/tree/master/PipelineFoundation" rel="noopener ugc nofollow" target="_blank">https://github . com/HC grit/machine learning-iamJustAStudent/tree/master/pipeline foundation</a></p><p id="19cc" class="kf kg lp kh b ki kj jr kk kl km ju kn lu kp kq kr lv kt ku kv lw kx ky kz la ij bi translated">代码演练:【https://youtu.be/mOYJCR0IDk8 T2】</p></blockquote><figure class="ly lz ma mb gt mc"><div class="bz fp l di"><div class="oq or l"/></div><p class="mj mk gj gh gi ml mm bd b be z dk translated">代码走查</p></figure><h1 id="69ad" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">接下来呢？</h1><p id="3c79" class="pw-post-body-paragraph kf kg iq kh b ki nf jr kk kl ng ju kn ko nh kq kr ks ni ku kv kw nj ky kz la ij bi nk translated"><span class="l nl nm nn bm no np nq nr ns di">如果不使用<strong class="kh ir"> FeatureUnion </strong>或<strong class="kh ir"> ColumnTransformer </strong>，任何实际的流水线实现都很难完成。我在上面提供的第一个参考链接会带你浏览FeatureUnions。我发现对ColumnTransformers和FeatureUnions非常有帮助的参考资料有:</span></p><p id="7d6d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一.<a class="ae lq" href="https://scikit-learn.org/stable/modules/compose.html#featureunion-composite-feature-spaces" rel="noopener ugc nofollow" target="_blank"><em class="lp">https://sci kit-learn . org/stable/modules/compose . html # feature union-composite-feature-spaces</em></a><br/>二<a class="ae lq" href="https://scikit-learn.org/stable/modules/generated/sklearn.compose.ColumnTransformer.html#sklearn.compose.ColumnTransformer" rel="noopener ugc nofollow" target="_blank"><em class="lp">https://scikit-learn . org/stable/modules/generated/sk learn . compose . column transformer . html # sk learn . compose . column transformer</em></a></p><p id="7fa2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，您最终将在您的模型上使用GridSearch。在这里用管道解释一下:<a class="ae lq" href="https://scikit-learn.org/stable/auto_examples/compose/plot_feature_union.html?highlight=pipeline" rel="noopener ugc nofollow" target="_blank"><em class="lp">https://scikit-learn . org/stable/auto _ examples/compose/plot _ feature _ union . html？高亮显示=管道</em> </a></p><p id="456d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">既然您已经很好地掌握了管道创建的基础，使用这些概念应该很容易。</p></div><div class="ab cl os ot hu ou" role="separator"><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox"/></div><div class="ij ik il im in"><p id="98c0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对分享想法、提问或简单讨论想法感兴趣？在<a class="ae lq" href="https://www.linkedin.com/in/himanshu-chandra-33512811/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>、<a class="ae lq" href="https://www.youtube.com/channel/UChNybQwpqrX9SOc1D4K_x5Q" rel="noopener ugc nofollow" target="_blank"> YouTube </a>、<a class="ae lq" href="https://github.com/HCGrit/MachineLearning-iamJustAStudent" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上或通过我的网站与我联系:<a class="ae lq" href="http://iamjustastudent.com/about" rel="noopener ugc nofollow" target="_blank">我只是一个学生</a>。</p><p id="6455" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">回头见&amp;学习愉快！</p><div class="oz pa gp gr pb pc"><a href="https://www.linkedin.com/in/himanshu-chandra-33512811/" rel="noopener  ugc nofollow" target="_blank"><div class="pd ab fo"><div class="pe ab pf cl cj pg"><h2 class="bd ir gy z fp ph fr fs pi fu fw ip bi translated">Himanshu Chandra -业务主管-ML</h2><div class="pj l"><p class="bd b dl z fp ph fr fs pi fu fw dk translated">www.linkedin.com</p></div></div><div class="pk l"><div class="pl l pm pn po pk pp mh pc"/></div></div></a></div></div></div>    
</body>
</html>