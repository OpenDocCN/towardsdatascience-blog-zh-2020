<html>
<head>
<title>Beyond CUDA: GPU Accelerated C++ for Machine Learning on Cross-Vendor Graphics Cards Made Simple with Kompute</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">超越 CUDA: GPU 加速的 C++在跨厂商显卡上进行机器学习，使用 Kompute 变得简单</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/machine-learning-and-data-processing-in-the-gpu-with-vulkan-kompute-c9350e5e5d3a?source=collection_archive---------11-----------------------#2020-09-12">https://towardsdatascience.com/machine-learning-and-data-processing-in-the-gpu-with-vulkan-kompute-c9350e5e5d3a?source=collection_archive---------11-----------------------#2020-09-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e5f4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过使用 Kompute 框架和 Vulkan SDK 的实际机器学习示例介绍 GPU 计算</h2></div><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="kn ko l"/></div><p class="kp kq gj gh gi kr ks bd b be z dk translated">C++中 Vulkan SDK 和 Kompute 的视频概述</p></figure><p id="d5e6" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">机器学习，以及许多其他高级数据处理范例，非常适合 GPU 计算提供的并行处理架构。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi lp"><img src="../Images/6d3b4b63fa1aa6ee9efcd6ba9b68e480.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M4MmQ0BsdGYws9At9aLFUg.png"/></div></div><p class="kp kq gj gh gi kr ks bd b be z dk translated">图片作者<a class="ae lw" href="https://docs.google.com/presentation/d/1WBLcBmk7J04Zu8cD3ugagPkEpKkDuJpNr-HfroNe4X8/edit#slide=id.p" rel="noopener ugc nofollow" target="_blank">作者</a></p></figure><p id="b7ae" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在本文中，您将学习如何用 GPU 优化代码从头开始编写自己的 ML 算法，该算法将能够在几乎任何硬件上运行，包括您的手机。我们将介绍核心的 GPU &amp; ML 概念，并展示如何使用<a class="ae lw" href="https://github.com/axsaucedo/vulkan-kompute#vulkan-kompute" rel="noopener ugc nofollow" target="_blank"> <strong class="kv iu"> Kompute 框架</strong> </a>只用几行代码就能实现它。</p><p id="0d08" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们将首先构建一个简单的算法，将两个数组并行相乘，这将介绍 GPU 处理的基础知识。然后，我们将在 GPU 中从头开始编写一个逻辑回归算法。您可以在以下链接中找到回购协议的完整代码:</p><ul class=""><li id="cfc5" class="lx ly it kv b kw kx kz la lc lz lg ma lk mb lo mc md me mf bi translated"><a class="ae lw" href="https://github.com/EthicalML/vulkan-kompute" rel="noopener ugc nofollow" target="_blank"> Kompute 库</a></li><li id="df62" class="lx ly it kv b kw mg kz mh lc mi lg mj lk mk lo mc md me mf bi translated">GPU 阵列乘法<a class="ae lw" href="https://github.com/axsaucedo/vulkan-kompute/tree/4e3802cb9dbf8742f9caf0374ef1612466c5ab1a/examples/array_multiplication#kompute-array-multiplication-example" rel="noopener ugc nofollow" target="_blank">库</a>和<a class="ae lw" href="https://github.com/axsaucedo/vulkan-kompute/blob/4e3802cb9dbf8742f9caf0374ef1612466c5ab1a/examples/array_multiplication/src/Main.cpp#L15" rel="noopener ugc nofollow" target="_blank"> Kompute 代码</a></li><li id="5a05" class="lx ly it kv b kw mg kz mh lc mi lg mj lk mk lo mc md me mf bi translated">GPU 逻辑回归<a class="ae lw" href="https://github.com/axsaucedo/vulkan-kompute/tree/7906406dd1e8bbfb01c1c5d68be44f63587440aa/examples/logistic_regression#kompute-logistic-regression-example" rel="noopener ugc nofollow" target="_blank">库</a>、<a class="ae lw" href="https://github.com/axsaucedo/vulkan-kompute/blob/7906406dd1e8bbfb01c1c5d68be44f63587440aa/examples/logistic_regression/src/Main.cpp#L15" rel="noopener ugc nofollow" target="_blank"> Kompute 代码</a>和<a class="ae lw" href="https://github.com/axsaucedo/vulkan-kompute/blob/7906406dd1e8bbfb01c1c5d68be44f63587440aa/examples/logistic_regression/shaders/glsl/logistic_regression.comp#L7" rel="noopener ugc nofollow" target="_blank">着色器代码</a></li></ul><h1 id="6bc0" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">动机</h1><p id="19e3" class="pw-post-body-paragraph kt ku it kv b kw nd ju ky kz ne jx lb lc nf le lf lg ng li lj lk nh lm ln lo im bi translated">近年来，GPU 计算的潜力和采用率一直呈爆炸式增长——从下图中的图表可以看出采用率的增长速度。在深度学习中，采用 GPU 进行处理的数量大幅增加，同时支持在越来越多的 GPU 节点上大规模并行分配计算任务的范例也大量增加。有许多令人兴奋的研究围绕着技术，这些技术提出了实现<a class="ae lw" href="https://mxnet.apache.org/versions/1.7/api/faq/model_parallel_lstm.html" rel="noopener ugc nofollow" target="_blank">模型并行性</a>和<a class="ae lw" href="https://en.wikipedia.org/wiki/Data_parallelism" rel="noopener ugc nofollow" target="_blank">数据并行性</a>的新方法——这两种方法都允许算法和数据分别细分为广泛的方法，以最大限度地提高处理效率。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi ni"><img src="../Images/7531f258641c84235d4548ba1526aecc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EZ27EB0hMtEdgm0d"/></div></div><p class="kp kq gj gh gi kr ks bd b be z dk translated"><strong class="bd nj">本农、塔尔和托尔斯滕·霍夫勒。“揭开并行和分布式深度学习的神秘面纱:深度并发分析。”美国计算机学会计算调查(CSUR)52.4(2019):1–43。</strong></p></figure><p id="38c6" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在本文中，我们概述了理论，并实践了一些工具，这些工具将使初学者和经验丰富的 GPU 计算从业者能够利用这些迷人的高性能计算领域的当前开发和讨论，并为之做出贡献。</p><h1 id="8c23" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">Vulkan 框架</h1><p id="b525" class="pw-post-body-paragraph kt ku it kv b kw nd ju ky kz ne jx lb lc nf le lf lg ng li lj lk nh lm ln lo im bi translated">在开始之前，有必要介绍一下核心框架，它使得构建超优化、跨平台和可扩展的 GPU 算法成为可能，这就是 Vulkan 框架。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/93bd9c499b4ad8eaed1a28e269c25f35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/0*zdzITvlNrxnHSlan"/></div><p class="kp kq gj gh gi kr ks bd b be z dk translated">与 Khronos 成员一起玩“瓦尔多在哪里”(图片由 Vincent Hindriksen 通过<a class="ae lw" href="https://streamhpc.com/blog/2017-05-04/what-is-khronos-as-of-today/" rel="noopener ugc nofollow" target="_blank"> StreamHPC </a>提供)</p></figure><p id="a4b1" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">Vulkan 是由 Khronos Group 领导的一个开源项目，Khronos Group 是一个由大量技术公司组成的联盟，他们聚集在一起致力于定义和推进移动和桌面媒体(和计算)技术的开放标准。在左边，你可以看到范围广泛的 Khronos 成员。</p><p id="2ade" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">您可能想知道，<em class="nm">为什么我们还需要另一个新的 GPU 框架，而这里已经有许多选项可用于编写可并行化的 GPU 代码？</em>主要原因是，与一些闭源的同类产品(如 NVIDIA 的 CUDA 或苹果的 Metal)不同，Vulkan 是完全开源的，并且与一些旧的选项(如 OpenGL)不同，Vulkan 是以现代 GPU 架构为基础构建的，提供了非常细粒度的 GPU 优化。最后，虽然一些替代产品为 GPU 提供了特定于供应商的支持，但 Vulkan 提供了<strong class="kv iu">跨平台</strong>和<strong class="kv iu">跨供应商</strong>支持，这意味着它打开了移动处理、边缘计算等领域的机会之门。</p><p id="9905" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">Vulkan SDK 提供对 GPU 的非常低级的访问，这允许非常专业的优化。这对 GPU 开发人员来说是一笔巨大的财富——主要缺点是冗长，需要 500–2000 多行代码才能获得编写应用程序逻辑所需的基本样板文件。这不仅会导致昂贵的开发周期，而且容易导致更大问题的小错误。</p><p id="106c" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这实际上可以在许多新的和知名的机器学习和深度学习项目中看到，如 Pytorch、Tensorflow 和阿里巴巴 DNN 等，这些项目已经集成或正在寻求集成 Vulkan GPU SDK，以添加移动 GPU(和跨供应商 GPU)支持。所有这些框架都以非常相似和极其冗长的样板代码告终，这意味着它们会从使用统一的基线中受益(并且仍然会受益)。这是我们启动<strong class="kv iu"> Kompute </strong>项目的主要动机之一。</p><h1 id="9e29" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">输入 Kompute</h1><p id="ad87" class="pw-post-body-paragraph kt ku it kv b kw nd ju ky kz ne jx lb lc nf le lf lg ng li lj lk nh lm ln lo im bi translated"><a class="ae lw" href="https://github.com/axsaucedo/vulkan-kompute#vulkan-kompute" rel="noopener ugc nofollow" target="_blank"> <strong class="kv iu"> Kompute </strong> </a>是一个构建在 Vulkan SDK 之上的框架，专门用于扩展其计算能力，作为一个简单易用、高度优化、移动友好的通用 GPU 计算框架。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi nn"><img src="../Images/bdce1c5ed55c9d3fe47a899ecef2e458.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xPB9mQd-SDgHQRc29HRz0A.png"/></div></div><p class="kp kq gj gh gi kr ks bd b be z dk translated">Kompute <a class="ae lw" href="https://ethicalml.github.io/vulkan-kompute/" rel="noopener ugc nofollow" target="_blank">文档</a>(图片由作者提供)</p></figure><p id="602e" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">Kompute 不是为了隐藏任何核心的 Vulkan 概念而构建的 Vulkan API 设计得非常好——相反，它通过 BYOV(自带 Vulkan)设计增强了 Vulkan 的计算能力，通过减少所需的样板代码和自动化编写 Vulkan 应用程序中涉及的一些更常见的工作流来支持开发人员。</p><p id="56cb" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">对于想了解更多信息的新开发人员来说，它为开始使用 GPU 计算提供了坚实的基础。对于更高级的 Vulkan 开发人员，Kompute 允许他们将其集成到现有的 Vulkan 应用程序中，并通过在需要时访问所有 Vulkan 内部来执行非常精细的优化。该项目是完全开源的，我们欢迎错误报告、文档扩展、新示例或建议——请随时在回购中<a class="ae lw" href="https://github.com/axsaucedo/vulkan-kompute/issues" rel="noopener ugc nofollow" target="_blank">提出问题</a>。</p><h1 id="84b6" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">编写你的第一个计算机</h1><p id="cea6" class="pw-post-body-paragraph kt ku it kv b kw nd ju ky kz ne jx lb lc nf le lf lg ng li lj lk nh lm ln lo im bi translated">为了使用 Kompute 构建我们的第一个简单的数组乘法 GPU 计算应用程序，我们将创建以下内容:</p><ul class=""><li id="5874" class="lx ly it kv b kw kx kz la lc lz lg ma lk mb lo mc md me mf bi translated">两个<strong class="kv iu">康普顿张量</strong>存储输入数据</li><li id="42fa" class="lx ly it kv b kw mg kz mh lc mi lg mj lk mk lo mc md me mf bi translated">一个<strong class="kv iu">计算机张量</strong>存储输出数据</li><li id="f7bf" class="lx ly it kv b kw mg kz mh lc mi lg mj lk mk lo mc md me mf bi translated">一个<strong class="kv iu">计算机操作</strong>创建并复制张量到 GPU</li><li id="cfbc" class="lx ly it kv b kw mg kz mh lc mi lg mj lk mk lo mc md me mf bi translated">带有 Kompute 算法的<strong class="kv iu"> Kompute 操作</strong>，该算法将保存要在 GPU 中执行的代码(称为“着色器”)</li><li id="8ccd" class="lx ly it kv b kw mg kz mh lc mi lg mj lk mk lo mc md me mf bi translated">将 GPU 数据同步回本地张量的<strong class="kv iu"> Kompute 操作</strong></li><li id="d36a" class="lx ly it kv b kw mg kz mh lc mi lg mj lk mk lo mc md me mf bi translated">一个<strong class="kv iu"> Kompute 序列</strong>记录操作，批量发送到 GPU(我们将使用<strong class="kv iu"> Kompute 管理器</strong>来简化工作流程)</li></ul><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="gh gi no"><img src="../Images/108e55e577c2bd0430e080d0d85f5272.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/0*Env2QAL1QVnE-XeR.jpg"/></div><p class="kp kq gj gh gi kr ks bd b be z dk translated">Kompute <a class="ae lw" href="https://ethicalml.github.io/vulkan-kompute/overview/reference.html" rel="noopener ugc nofollow" target="_blank">建筑设计</a>(图片由作者提供)</p></figure><p id="7951" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">Kompute 的核心是用于 GPU 操作的“Kompute 操作”，以及处理 GPU 数据和内存的“Kompute 张量”操作。更具体地说，这个图显示了 Kompute 组件之间的关系(包括显式内存所有权)。</p><p id="7bbd" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">当与 GPU 交互时，您必须将指令发送给 GPU 来执行，并且您需要确保 GPU 在 GPU 内存中有所有可用的相关数据来开始处理。使用 Vulkan，您可以通过队列将这些指令发送到 GPU，因此为了直观地简化事情，您可以将您的 GPU 视为远程服务器，其中数据序列化、资源创建和内存分配是昂贵的，并且指令是通过队列提交的——仍然有 GPU-CPU 共享内存，但您倾向于仅将它用于向 GPU 传输数据。</p><p id="6f7b" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">让我们直接进入代码。通常，在 Kompute 应用程序中，我们将遵循以下步骤:</p><ol class=""><li id="eebf" class="lx ly it kv b kw kx kz la lc lz lg ma lk mb lo np md me mf bi translated">创建 Kompute 管理器来管理资源</li><li id="4a71" class="lx ly it kv b kw mg kz mh lc mi lg mj lk mk lo np md me mf bi translated">创建 Kompute 张量来保存数据</li><li id="ec95" class="lx ly it kv b kw mg kz mh lc mi lg mj lk mk lo np md me mf bi translated">使用 Kompute 操作初始化 GPU 中的 Kompute 张量</li><li id="a1dc" class="lx ly it kv b kw mg kz mh lc mi lg mj lk mk lo np md me mf bi translated">将在 GPU 上运行的代码定义为“计算着色器”</li><li id="ef6e" class="lx ly it kv b kw mg kz mh lc mi lg mj lk mk lo np md me mf bi translated">使用 Kompute 操作对 Kompute 张量运行着色器</li><li id="11f5" class="lx ly it kv b kw mg kz mh lc mi lg mj lk mk lo np md me mf bi translated">使用 Kompute 操作将 GPU 输出数据映射到本地张量</li><li id="3491" class="lx ly it kv b kw mg kz mh lc mi lg mj lk mk lo np md me mf bi translated">打印您的结果</li></ol><h2 id="f3b4" class="nq mm it bd mn nr ns dn mr nt nu dp mv lc nv nw mx lg nx ny mz lk nz oa nb ob bi translated">1.创建 Kompute 管理器来管理资源</h2><p id="880c" class="pw-post-body-paragraph kt ku it kv b kw nd ju ky kz ne jx lb lc nf le lf lg ng li lj lk nh lm ln lo im bi translated">首先，我们将创建 Kompute 管理器，它负责创建和管理所有底层 Vulkan 资源。</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="oc ko l"/></div></figure><p id="e72d" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">正如你所看到的，这里我们正在初始化我们的 Kompute 管理器，期望它在设备 0 上创建所有的基本 Vulkan 资源(在我的例子中，设备 0 是我的 NVIDIA 卡，设备 1 是我的集成显卡)。对于更高级的用例，也可以用自己的 Vulkan 资源(设备、队列等)初始化 Kompute 管理器，但这超出了本文的范围。</p><h2 id="b949" class="nq mm it bd mn nr ns dn mr nt nu dp mv lc nv nw mx lg nx ny mz lk nz oa nb ob bi translated">2.创建 Kompute 张量来保存数据</h2><p id="0a49" class="pw-post-body-paragraph kt ku it kv b kw nd ju ky kz ne jx lb lc nf le lf lg ng li lj lk nh lm ln lo im bi translated">我们现在将创建用于输入和输出的 Kompute 张量。这些将保存所需的数据，这些数据将被映射到 GPU 来执行这个简单的乘法。</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="oc ko l"/></div></figure><p id="463d" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">Kompute 设计使用<code class="fe od oe of og b">std::shared_ptr</code>的原因是为了避免通过值传递对象，而是使用<a class="ae lw" href="https://docs.microsoft.com/en-us/cpp/cpp/smart-pointers-modern-cpp?view=vs-2019" rel="noopener ugc nofollow" target="_blank">智能指针</a>传递对象。</p><h2 id="6ff2" class="nq mm it bd mn nr ns dn mr nt nu dp mv lc nv nw mx lg nx ny mz lk nz oa nb ob bi translated">3.使用 Kompute 操作初始化 GPU 中的 Kompute 张量</h2><p id="3272" class="pw-post-body-paragraph kt ku it kv b kw nd ju ky kz ne jx lb lc nf le lf lg ng li lj lk nh lm ln lo im bi translated">现在我们已经用本地数据创建了张量，我们将把数据映射到 GPU 中。为此，我们将使用<code class="fe od oe of og b"><a class="ae lw" href="https://axsaucedo.github.io/vulkan-kompute/overview/reference.html#optensorcreate" rel="noopener ugc nofollow" target="_blank">kp::OpTensorCreate</a></code> Kompute 操作，该操作将初始化底层 Vulkan 缓冲区和 GPU 内存，并执行到 GPU 的相应映射。</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="oc ko l"/></div></figure><p id="22f5" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">同样值得一提的是，通过利用 Kompute 管理器<code class="fe od oe of og b">buildTensor</code>助手功能，可以缩短张量创建的步骤。这将允许您跳过显式创建<code class="fe od oe of og b">shared_ptr</code>以及下面概述的<code class="fe od oe of og b">kp::OpTensorCreate</code>操作的需要(您也可以在这里找到<a class="ae lw" href="https://github.com/axsaucedo/vulkan-kompute/blob/2e8a5aa3a6d6172abb51ac038e1b75c5c2d58af9/test/TestMultipleAlgoExecutions.cpp#L274" rel="noopener ugc nofollow" target="_blank">这个变体的完整代码实现</a>)。</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="oc ko l"/></div></figure><h2 id="1102" class="nq mm it bd mn nr ns dn mr nt nu dp mv lc nv nw mx lg nx ny mz lk nz oa nb ob bi translated">4.将在 GPU 上运行的代码定义为“计算着色器”</h2><p id="58ec" class="pw-post-body-paragraph kt ku it kv b kw nd ju ky kz ne jx lb lc nf le lf lg ng li lj lk nh lm ln lo im bi translated">现在我们已经初始化了必要的 Kompute 张量分量，并且它们被映射到 GPU 内存中，我们可以添加将在 GPU 中执行的 Kompute 算法。这被称为“着色器”代码，遵循类似 C 的语法。你可以在下面看到完整的着色器代码，我们将在下面分解每个部分。</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="oc ko l"/></div></figure><p id="0896" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><code class="fe od oe of og b">#version 450</code>和<code class="fe od oe of og b">layout(local_size_x = 1) in;</code>部分指定了版本和并行线程执行结构(我们将在文章的后面进一步研究)。然后，我们可以看到以以下格式定义的 GPU 数据输入和输出:</p><blockquote class="oh oi oj"><p id="1315" class="kt ku nm kv b kw kx ju ky kz la jx lb ok ld le lf ol lh li lj om ll lm ln lo im bi translated"><code class="fe od oe of og b"><em class="it">layout(binding = &lt;INDEX&gt;) buffer &lt;UNIQUENAME&gt; {float &lt;VARNAME&gt;[]};</em></code></p></blockquote><ul class=""><li id="b53a" class="lx ly it kv b kw kx kz la lc lz lg ma lk mb lo mc md me mf bi translated"><index> —将张量映射到 GPU 输入的索引</index></li><li id="a7c5" class="lx ly it kv b kw mg kz mh lc mi lg mj lk mk lo mc md me mf bi translated"><uniquename> —这必须是缓冲区的唯一名称</uniquename></li><li id="b061" class="lx ly it kv b kw mg kz mh lc mi lg mj lk mk lo mc md me mf bi translated"><varname> —这是在着色器代码中使用的变量名</varname></li></ul><p id="014c" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这些是可以在着色器代码中用于处理的参数。也就是说，在这种情况下，处理是在<code class="fe od oe of og b">main </code>函数内部完成的。第一个变量<code class="fe od oe of og b">uint index = gl_GlobalInvocationID.x;</code>是当前的并行执行指数，它将允许我们处理每个数据输入。</p><p id="f973" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">然后，我们进入该算法的核心，即乘法<code class="fe od oe of og b">o[index] = a[index] * b[index]. </code>，这一部分非常简单明了——我们将 GPU 数组<code class="fe od oe of og b">a[]</code>和<code class="fe od oe of og b">b[]</code>的元素相乘，然后将输出存储在数组<code class="fe od oe of og b">o[]</code>中。</p><h2 id="6be5" class="nq mm it bd mn nr ns dn mr nt nu dp mv lc nv nw mx lg nx ny mz lk nz oa nb ob bi translated">5.使用 Kompute 操作对 Kompute 张量运行着色器</h2><p id="cc8c" class="pw-post-body-paragraph kt ku it kv b kw nd ju ky kz ne jx lb lc nf le lf lg ng li lj lk nh lm ln lo im bi translated">为了运行上面的着色器，我们将创建 Kompute 操作<code class="fe od oe of og b"><a class="ae lw" href="https://axsaucedo.github.io/vulkan-kompute/overview/reference.html#opalgobase" rel="noopener ugc nofollow" target="_blank">kp::OpAlgoBase</a></code>。这个 Kompute 操作所需的参数包括绑定到 GPU 指令中的张量，以及着色器代码本身。</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="oc ko l"/></div></figure><p id="bbb7" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">值得一提的是，Kompute 允许用户通过文件路径传递着色器，或者也有 Kompute 工具允许您将着色器二进制文件转换为 C++头文件。</p><h2 id="c25c" class="nq mm it bd mn nr ns dn mr nt nu dp mv lc nv nw mx lg nx ny mz lk nz oa nb ob bi translated">6.使用 Kompute 操作将 GPU 输出数据映射到本地张量</h2><p id="ad40" class="pw-post-body-paragraph kt ku it kv b kw nd ju ky kz ne jx lb lc nf le lf lg ng li lj lk nh lm ln lo im bi translated">一旦算法被触发，结果数据将保存在输出张量的 GPU 内存中。我们现在可以使用<code class="fe od oe of og b"><a class="ae lw" href="https://axsaucedo.github.io/vulkan-kompute/overview/reference.html#optensorsynclocal" rel="noopener ugc nofollow" target="_blank">kp::OpTensorSyncLocal</a> </code> Kompute 操作按照下面的代码块同步 Tensor GPU 内存。</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="oc ko l"/></div></figure><h2 id="69d4" class="nq mm it bd mn nr ns dn mr nt nu dp mv lc nv nw mx lg nx ny mz lk nz oa nb ob bi translated">7.打印您的结果</h2><p id="68f0" class="pw-post-body-paragraph kt ku it kv b kw nd ju ky kz ne jx lb lc nf le lf lg ng li lj lk nh lm ln lo im bi translated">最后，我们可以打印出张量的输出数据。</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="oc ko l"/></div></figure><p id="4fa1" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">当你运行它时，你会看到输出张量的值被打印出来。就这样，你写了你的第一个 Kompute！</p><p id="5cd6" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">您也可以在 repo 中找到完整的示例，这样您就可以运行它并根据需要扩展它。你可以在<a class="ae lw" href="https://github.com/axsaucedo/vulkan-kompute/tree/4e3802cb9dbf8742f9caf0374ef1612466c5ab1a/examples/array_multiplication#kompute-array-multiplication-example" rel="noopener ugc nofollow" target="_blank">这个库</a>中找到完整的独立示例，其中包括如何构建它的说明以及<a class="ae lw" href="https://github.com/axsaucedo/vulkan-kompute/blob/4e3802cb9dbf8742f9caf0374ef1612466c5ab1a/examples/array_multiplication/src/Main.cpp#L15" rel="noopener ugc nofollow" target="_blank"> Kompute C++代码</a>。</p><p id="9c8d" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">虽然看起来不明显，但上面介绍了 GPU 计算中核心概念和设计思维的一些直觉，同时还抽象了一些更深入的概念。在接下来的几节中，我们将提供更具体的术语，我们将触及一些更高级的概念，如线程、块、内存步长和共享内存(尽管很多内容将作为进一步的阅读材料提供)。</p><h1 id="6c88" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">潜入机器学习直觉</h1><p id="4241" class="pw-post-body-paragraph kt ku it kv b kw nd ju ky kz ne jx lb lc nf le lf lg ng li lj lk nh lm ln lo im bi translated">让我们看一个更高级的 GPU 计算用例，具体实现机器学习的 hello world，逻辑回归。在我们介绍实现之前，我们将提供一些理论上的直觉，以及我们将贯穿始终使用的术语。</p><p id="4d63" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在机器学习中，我们总是有两个阶段，训练和推理。在下图中，您可以看到两个简化的流程。最上面是训练流程，在这里你识别一些训练数据，提取一些特征，训练一个模型，直到你对精度满意为止。一旦您有了一个经过训练的模型，您就可以持久化模型“权重”,并将模型部署到第二个工作流中，在第二个工作流中，模型将对看不见的数据执行推理。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi on"><img src="../Images/10ce29488bcbfca55aafb9bc4f5d25bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qjzd2Q5vinPtO5c6"/></div></div><p class="kp kq gj gh gi kr ks bd b be z dk translated">数据科学流程(图片由作者提供)</p></figure><p id="f680" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在这种情况下，我们将有一个输入数据集<code class="fe od oe of og b">X</code>，其中每个元素是一对<code class="fe od oe of og b">xi</code>和<code class="fe od oe of og b">xj</code>。我们的输入数据如下:</p><ul class=""><li id="9d59" class="lx ly it kv b kw kx kz la lc lz lg ma lk mb lo mc md me mf bi translated"><code class="fe od oe of og b">xi = { 0, 1, 1, 1, 1 }</code></li><li id="2e84" class="lx ly it kv b kw mg kz mh lc mi lg mj lk mk lo mc md me mf bi translated"><code class="fe od oe of og b">xj = { 0, 0, 0, 1, 1 }</code></li></ul><p id="77ee" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">利用该输入数据，要预测的预期目标值<code class="fe od oe of og b">Y</code>将如下:</p><ul class=""><li id="86d6" class="lx ly it kv b kw kx kz la lc lz lg ma lk mb lo mc md me mf bi translated"><code class="fe od oe of og b">Y = {0, 0, 0, 1, 1}</code></li></ul><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/20466429c92984ce5c97be7d0eea198b.png" data-original-src="https://miro.medium.com/v2/resize:fit:970/format:webp/1*C9Sl7wor6-pydyD7NXcC5Q.png"/></div><p class="kp kq gj gh gi kr ks bd b be z dk translated">来自<a class="ae lw" href="https://www.datasciencecentral.com/profiles/blogs/why-logistic-regression-should-be-the-last-thing-you-learn-when-b" rel="noopener ugc nofollow" target="_blank"> DS Central </a>的逻辑回归示例</p></figure><p id="71d9" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们在机器学习中的主要目标是学习使用这些数据来找到函数(和参数)，这将允许我们仅使用<code class="fe od oe of og b">X</code>作为输入来预测值<code class="fe od oe of og b">Y</code>。</p><p id="f738" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">值得注意的是，预测值被定义为<code class="fe od oe of og b">ŷ</code>，它是用我们的推理函数计算出来的值，不同于我们上面定义的<code class="fe od oe of og b">Y</code>的“真”或“实际”值。</p><p id="a769" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们将用于逻辑回归的函数如下:</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="gh gi op"><img src="../Images/2ac956c69153faeb64a66f6abddaaa40.png" data-original-src="https://miro.medium.com/v2/resize:fit:216/format:webp/0*ueYCdrdgQqwteXNe.png"/></div></figure><p id="c9d3" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">让我们来分解这个函数:</p><ul class=""><li id="8416" class="lx ly it kv b kw kx kz la lc lz lg ma lk mb lo mc md me mf bi translated"><code class="fe od oe of og b">z</code>——是我们的线性映射函数</li><li id="feca" class="lx ly it kv b kw mg kz mh lc mi lg mj lk mk lo mc md me mf bi translated"><code class="fe od oe of og b">ŷ</code>—结果预测输出</li><li id="b8ca" class="lx ly it kv b kw mg kz mh lc mi lg mj lk mk lo mc md me mf bi translated"><code class="fe od oe of og b">X</code>ᵀ——包含我们的输入 xi 和 xj 的矩阵的转置</li><li id="4ca7" class="lx ly it kv b kw mg kz mh lc mi lg mj lk mk lo mc md me mf bi translated"><code class="fe od oe of og b">σ</code>—sigmoid 函数，将在下面详细介绍</li></ul><p id="4eeb" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们希望通过机器学习算法学习的参数是:</p><ul class=""><li id="b7fe" class="lx ly it kv b kw kx kz la lc lz lg ma lk mb lo mc md me mf bi translated"><code class="fe od oe of og b">W</code> —将应用于输入的权重</li><li id="f084" class="lx ly it kv b kw mg kz mh lc mi lg mj lk mk lo mc md me mf bi translated"><code class="fe od oe of og b">b</code> —将要添加的偏差</li></ul><p id="56b3" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">还有环绕函数<code class="fe od oe of og b">σ </code>也就是 sigmoid 函数。该函数迫使我们的输入更接近 0 或 1，这可以直观地视为我们预测为“真”的概率，定义如下:</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/9af0d474a479168f7634cf5d15210a46.png" data-original-src="https://miro.medium.com/v2/resize:fit:234/format:webp/0*B4vJKaqNBrPgeAG_.png"/></div></figure><p id="f429" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这就是现在的推理功能，它将允许我们处理来自新数据点的预测。例如，如果我们说我们有一组新的看不见的输入<code class="fe od oe of og b">X = { (0, 1) }</code>，并且我们假设在通过我们的训练数据运行我们的机器学习算法之后，学习到的参数是<code class="fe od oe of og b">W = (1, 1), b = 0 </code>(稍后我们将这样做)，那么我们将能够通过我们的预测函数来运行它，方法是代入以下值:</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="gh gi or"><img src="../Images/1b53b2b2bd2fe2500a8800df2a449cb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:926/format:webp/0*vPB55aWa874FYfwa.png"/></div></figure><p id="2bf2" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在这种情况下，预测是<code class="fe od oe of og b">0.73...</code>，这将是一个肯定的预测。这当然只是为了演示一旦我们学习了参数<code class="fe od oe of og b">W</code>和<code class="fe od oe of og b">b.</code>我们的推理函数会是什么样子</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="gh gi os"><img src="../Images/27f47a93433b6c683e51cc3609a5eecd.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/1*e88JKNWAFok3vpjeuPfHig.gif"/></div><p class="kp kq gj gh gi kr ks bd b be z dk translated">从<a class="ae lw" href="https://mi-academy.com/2018/10/04/the-history-of-gradient-descent/" rel="noopener ugc nofollow" target="_blank"> ML Academy </a>可视化的梯度下降</p></figure><p id="6b64" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们学习参数的方法是进行预测，计算误差，然后相应地重新调整权重。用于基于“预测误差”来“重新调整”权重的方法将通过利用梯度下降来完成。这将被重复多次以找到更精确的参数。</p><p id="5155" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">为此，我们将需要使用每个公式的导数。第一个是我们的线性映射函数<code class="fe od oe of og b">z</code>的导数:</p><ul class=""><li id="8b5b" class="lx ly it kv b kw kx kz la lc lz lg ma lk mb lo mc md me mf bi translated">∂z = z(x) - y</li></ul><p id="8ae7" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">其中变量定义如下:</p><ul class=""><li id="fb89" class="lx ly it kv b kw kx kz la lc lz lg ma lk mb lo mc md me mf bi translated"><code class="fe od oe of og b">∂z</code> —线性映射函数的导数<code class="fe od oe of og b">z(x)</code></li><li id="e9cf" class="lx ly it kv b kw mg kz mh lc mi lg mj lk mk lo mc md me mf bi translated"><code class="fe od oe of og b">z(x)</code> —应用于输入<code class="fe od oe of og b">x</code>的线性映射函数的结果</li><li id="822b" class="lx ly it kv b kw mg kz mh lc mi lg mj lk mk lo mc md me mf bi translated"><code class="fe od oe of og b">y</code> —输入 x 的预期实际值标签</li></ul><p id="2dd3" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">类似地，w 和 b 的导数分别如下:</p><ul class=""><li id="3de4" class="lx ly it kv b kw kx kz la lc lz lg ma lk mb lo mc md me mf bi translated">∂w = (x - ∂z)/m</li><li id="3d38" class="lx ly it kv b kw mg kz mh lc mi lg mj lk mk lo mc md me mf bi translated">∂b = ∂z/m</li></ul><p id="9581" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在这种情况下，<code class="fe od oe of og b">m</code>是输入元素的总数。</p><p id="fca0" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们现在能够使用上述方法重新调整参数，如下所示:</p><ul class=""><li id="c6e4" class="lx ly it kv b kw kx kz la lc lz lg ma lk mb lo mc md me mf bi translated">w = w - θ ∂w</li><li id="722a" class="lx ly it kv b kw mg kz mh lc mi lg mj lk mk lo mc md me mf bi translated">b = b - θ ∂b</li></ul><p id="1279" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在这种情况下，θ是学习率，顾名思义，它控制每次迭代中参数被修改的比率。直观地说，越小，算法收敛所需的迭代次数就越多，然而，如果学习量太大，它将会超调，导致永远无法收敛(从上面的图像中，你可以想象它将不断从一边跳到另一边，永远不会到达底部)。</p><p id="bbac" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">为了计算损失，我们将使用对数损失函数，也称为交叉熵损失函数。该功能定义如下:</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/438f3c7e5939cdf5b9919cd184f6fd0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:414/format:webp/0*TgKVkmzh9rpbnlaD.png"/></div><p class="kp kq gj gh gi kr ks bd b be z dk translated">对数损失(交叉熵损失)函数</p></figure><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi ou"><img src="../Images/77a242942a7e6a22a1e8dfe5b796bc39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SQh95-Fn58JTDgzX.png"/></div></div><p class="kp kq gj gh gi kr ks bd b be z dk translated">直观的图表，直观显示 ML Mastery 的成本函数<a class="ae lw" href="https://machinelearningmastery.com/how-to-score-probability-predictions-in-python/" rel="noopener ugc nofollow" target="_blank"/></p></figure><p id="4ed4" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">函数本身是这样设置的，预测类和期望类之间的差异越大，误差就越大(你可以看到如果预测类在完全不同的标签上，它会受到多大的惩罚)。</p><p id="1110" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">损失函数将为我们提供一个在迭代中改进算法的思路。</p><p id="1192" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">最后，这里最重要的一点将是我们如何利用 GPU 的并行架构来优化计算背后的直觉。在这种情况下，我们可以同时处理多个输入参数，称为微批处理，然后批量重新调整参数。这被称为数据并行化，是许多可用技术之一。在下一节中，我们将看到这是如何实现的，即传递一小批输入，存储权重，然后在下一次迭代之前重新调整它们。</p><blockquote class="oh oi oj"><p id="adec" class="kt ku nm kv b kw kx ju ky kz la jx lb ok ld le lf ol lh li lj om ll lm ln lo im bi translated">注意:在这篇文章中，我们不会深入研究太多细节，也不会研究机器学习的最佳实践，但是在文章的最后，我们将列出一系列广泛的来源，供有兴趣将其机器学习(或 GPU 计算)知识提升到一个新水平的人使用。</p></blockquote><h1 id="6125" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">机器学习 GPU 代码实现</h1><p id="3417" class="pw-post-body-paragraph kt ku it kv b kw nd ju ky kz ne jx lb lc nf le lf lg ng li lj lk nh lm ln lo im bi translated">现在我们已经讨论了一些核心概念，我们将能够了解着色器的实现，它是将在 GPU 中执行的代码。</p><p id="e6a9" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">首先，我们需要如下定义所有的输入和输出缓冲器:</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="oc ko l"/></div></figure><p id="fbc4" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">如果您还记得，在上一节的结尾，我们提到了如何利用微批处理的概念来使用 GPU 处理的并行架构。这在实践中意味着，我们将把 X 的多个实例一次传递给 GPU 来处理，而不是期望 GPU 一个接一个地处理它。这就是为什么我们看到上面有一个分别用于<code class="fe od oe of og b">xi, xj, y, wOuti, wOutj, </code>和<code class="fe od oe of og b">bOut</code>的数组。</p><p id="6999" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">更详细地说:</p><ul class=""><li id="f148" class="lx ly it kv b kw kx kz la lc lz lg ma lk mb lo mc md me mf bi translated">作为数组 xi 和 xj 的输入<code class="fe od oe of og b">X </code>将保存小批量的输入</li><li id="5c5b" class="lx ly it kv b kw mg kz mh lc mi lg mj lk mk lo mc md me mf bi translated">数组<code class="fe od oe of og b">y </code>将保存微批量输入的所有预期标签</li><li id="213e" class="lx ly it kv b kw mg kz mh lc mi lg mj lk mk lo mc md me mf bi translated">两个输入权重参数<code class="fe od oe of og b">wini</code>和<code class="fe od oe of og b">woutj</code>将用于计算预测</li><li id="1436" class="lx ly it kv b kw mg kz mh lc mi lg mj lk mk lo mc md me mf bi translated">将用于计算预测的输入参数<code class="fe od oe of og b">b</code></li><li id="1fca" class="lx ly it kv b kw mg kz mh lc mi lg mj lk mk lo mc md me mf bi translated">输出权重<code class="fe od oe of og b">wouti</code>和<code class="fe od oe of og b">woutj </code>包含权重，并将存储应被减去的所有微批次的 W 的导数</li><li id="6438" class="lx ly it kv b kw mg kz mh lc mi lg mj lk mk lo mc md me mf bi translated">类似地，输出偏差数组包含所有应批量减去的微量批次的<code class="fe od oe of og b">b </code>的导数</li><li id="ccfd" class="lx ly it kv b kw mg kz mh lc mi lg mj lk mk lo mc md me mf bi translated">最后<code class="fe od oe of og b">lout</code>包含了损失将被返回的输出数组</li></ul><p id="439d" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们还收到常数<code class="fe od oe of og b">M</code>，它将是元素的总数——如果你记得这个参数将用于导数的计算。我们还将看到这些参数是如何从 C++ Kompute 端传递到着色器的。</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="oc ko l"/></div></figure><p id="a021" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">现在我们已经定义了所有的输入和输出参数，我们可以启动<code class="fe od oe of og b">main</code>函数，它将包含我们的机器学习训练算法的实现。</p><p id="386c" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们将首先跟踪全局调用的当前索引。由于 GPU 并行执行，这些运行中的每一个都将直接并行运行，因此这允许当前执行一致地跟踪当前正在执行的迭代索引。</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="oc ko l"/></div></figure><p id="7a90" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们现在可以开始准备所有的变量，我们将在整个算法中使用。我们所有的输入都是缓冲数组，所以我们希望将它们存储在 vec2 和 float 变量中。</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="oc ko l"/></div></figure><p id="eec6" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在这种情况下，我们基本上明确了当前“线程运行”所使用的变量。GPU 架构由稍微更细微的执行结构组成，涉及线程块、内存访问限制等，但我们不会在本例中涉及这些。</p><p id="c23c" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">现在我们进入更有趣的部分——实现推理功能。下面我们将实现推理函数来计算ŷ，它既涉及线性映射函数，也涉及 sigmoid 函数。</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="oc ko l"/></div></figure><p id="7761" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">现在我们有了<code class="fe od oe of og b">yHat</code>，我们现在可以用它来计算导数(∂z、∂w 和∂b)，在本例中是当前执行的索引输入元素的导数。</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="oc ko l"/></div></figure><p id="ee11" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们现在可以将导数作为输出传递，因此可以为下一次迭代重新调整参数。</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="oc ko l"/></div></figure><p id="64e8" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">最后，我们能够计算损耗并将其添加到输出<code class="fe od oe of og b">lout</code>数组中。</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="oc ko l"/></div></figure><p id="4d11" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">就这样，我们现在已经完成了着色器，这将使我们能够在 GPU 中训练逻辑回归算法——你可以在 GPU 逻辑回归<a class="ae lw" href="https://github.com/axsaucedo/vulkan-kompute/tree/7906406dd1e8bbfb01c1c5d68be44f63587440aa/examples/logistic_regression#kompute-logistic-regression-example" rel="noopener ugc nofollow" target="_blank">示例库</a>中找到着色器的<a class="ae lw" href="https://github.com/axsaucedo/vulkan-kompute/blob/7906406dd1e8bbfb01c1c5d68be44f63587440aa/examples/logistic_regression/shaders/glsl/logistic_regression.comp#L7" rel="noopener ugc nofollow" target="_blank">完整代码。</a></p><p id="0ba6" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">现在，我们将介绍 Kompute 代码，该代码需要针对数据集运行，以训练我们的第一个模型并找到参数。</p><h1 id="f3da" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">Kompute 的机器学习编排</h1><p id="362d" class="pw-post-body-paragraph kt ku it kv b kw nd ju ky kz ne jx lb lc nf le lf lg ng li lj lk nh lm ln lo im bi translated">为了使用 Kompute 在 GPU 中运行我们上面创建的着色器，我们将遵循以下步骤:</p><ol class=""><li id="c20e" class="lx ly it kv b kw kx kz la lc lz lg ma lk mb lo np md me mf bi translated">导入 Kompute 并创建我们的主要功能</li><li id="f4b7" class="lx ly it kv b kw mg kz mh lc mi lg mj lk mk lo np md me mf bi translated">创建所有需要的 Kompute 张量</li><li id="7816" class="lx ly it kv b kw mg kz mh lc mi lg mj lk mk lo np md me mf bi translated">创建 Kompute 管理器并初始化 Kompute 序列</li><li id="2f4a" class="lx ly it kv b kw mg kz mh lc mi lg mj lk mk lo np md me mf bi translated">通过 Kompute 序列执行 Kompute 张量 GPU 初始化</li><li id="7ea5" class="lx ly it kv b kw mg kz mh lc mi lg mj lk mk lo np md me mf bi translated">记录 Kompute 序列中的批处理算法执行</li><li id="7671" class="lx ly it kv b kw mg kz mh lc mi lg mj lk mk lo np md me mf bi translated">迭代 100 次:运行微批处理执行并更新权重</li><li id="7d68" class="lx ly it kv b kw mg kz mh lc mi lg mj lk mk lo np md me mf bi translated">打印结果参数，用于进一步推断</li></ol><p id="5d58" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">如你所见，这比我们上面使用的简单例子更复杂。在这种情况下，我们将使用 Kompute 序列，而不是直接使用 Kompute 管理器，因为我们希望对命令进行更深入的控制，这些命令可以被记录下来并批量发送到 GPU。我们将在讲述每个步骤时更详细地讨论这一点。让我们开始吧。</p><h2 id="271b" class="nq mm it bd mn nr ns dn mr nt nu dp mv lc nv nw mx lg nx ny mz lk nz oa nb ob bi translated">1.导入 Kompute 并创建我们的主要功能</h2><p id="07f5" class="pw-post-body-paragraph kt ku it kv b kw nd ju ky kz ne jx lb lc nf le lf lg ng li lj lk nh lm ln lo im bi translated">我们将导入 Kompute 的单个头文件——如果需要，也可以使用更细粒度的基于类的头文件。我们还将创建一些基本配置变量；即<code class="fe od oe of og b">ITERATIONS</code>和<code class="fe od oe of og b">learningRate</code>，它们将在后面的码块中使用。</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="oc ko l"/></div></figure><h2 id="421d" class="nq mm it bd mn nr ns dn mr nt nu dp mv lc nv nw mx lg nx ny mz lk nz oa nb ob bi translated">2.创建所有需要的 Kompute 张量</h2><p id="116d" class="pw-post-body-paragraph kt ku it kv b kw nd ju ky kz ne jx lb lc nf le lf lg ng li lj lk nh lm ln lo im bi translated">现在我们将创建所有需要的张量。在这一小节中，你会注意到我们将引用着色器中使用的所有缓冲区/数组。我们还将介绍参数传递的顺序如何与数据绑定到着色器的方式相关联，以便可以访问数据。</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="oc ko l"/></div></figure><p id="1c51" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们还将它们存储在一个参数向量中，以便于访问:</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="oc ko l"/></div></figure><h2 id="c71c" class="nq mm it bd mn nr ns dn mr nt nu dp mv lc nv nw mx lg nx ny mz lk nz oa nb ob bi translated">3.创建 Kompute 管理器并初始化 Kompute 序列</h2><p id="bda4" class="pw-post-body-paragraph kt ku it kv b kw nd ju ky kz ne jx lb lc nf le lf lg ng li lj lk nh lm ln lo im bi translated">如果您还记得前面的例子，我们能够使用 Kompute 管理器直接执行命令。然而，如果我们想要更精细地记录可以在处理之前提交并加载到 GPU 中的命令批次，我们可以使用 Kompute 序列资源。为此，我们将创建一个 Kompute 管理器，然后通过它创建一个 Kompute 序列。</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="oc ko l"/></div></figure><h2 id="54b7" class="nq mm it bd mn nr ns dn mr nt nu dp mv lc nv nw mx lg nx ny mz lk nz oa nb ob bi translated">4.通过 Kompute 序列执行 Kompute 张量 GPU 初始化</h2><p id="960b" class="pw-post-body-paragraph kt ku it kv b kw nd ju ky kz ne jx lb lc nf le lf lg ng li lj lk nh lm ln lo im bi translated">我们现在可以从在 GPU 资源上运行指令开始——也就是说，我们将从初始化张量并将其映射到各自的 GPU 内存开始。在这里，您将看到 Kompute 序列如何在命令执行上为您提供进一步的粒度，但是直到 ML 推理部分，您才会看到 Kompute 序列的灵活性。</p><p id="8162" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">让我们从记录命令开始，即 OpTensorCreate 命令，然后评估上面所有张量的操作。此操作将创建各自的 Vulkan 内存/缓冲区资源。</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="oc ko l"/></div></figure><h2 id="874d" class="nq mm it bd mn nr ns dn mr nt nu dp mv lc nv nw mx lg nx ny mz lk nz oa nb ob bi translated">5.记录 Kompute 序列中的批处理算法执行</h2><p id="333c" class="pw-post-body-paragraph kt ku it kv b kw nd ju ky kz ne jx lb lc nf le lf lg ng li lj lk nh lm ln lo im bi translated">在本节中，我们将清除 Kompute 序列的先前记录，并开始记录一组序列。您会注意到，与前一节不同，在这种情况下，我们不会立即运行<code class="fe od oe of og b">eval()</code>，因为我们必须多次运行它，并使用额外的命令来重新调整参数。</p><p id="df7b" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">您还会注意到，我们将记录三种类型的 Kompute 操作，即:</p><ul class=""><li id="d2d9" class="lx ly it kv b kw kx kz la lc lz lg ma lk mb lo mc md me mf bi translated"><code class="fe od oe of og b"><a class="ae lw" href="https://axsaucedo.github.io/vulkan-kompute/overview/reference.html#optensorsyncdevice" rel="noopener ugc nofollow" target="_blank">kp::OpTensorSyncDevice</a></code> —此操作通过将张量的本地数据映射到 GPU 数据，确保张量与其 GPU 内存同步。在这种情况下，这些张量使用设备专用内存来提高处理效率，因此在操作中使用分级张量来执行映射(为了提高效率，在整个操作中重复使用分级张量)。在这里，我们只想同步输入权重，因为这些权重将随各自的导数在本地更新。</li><li id="c3ad" class="lx ly it kv b kw mg kz mh lc mi lg mj lk mk lo mc md me mf bi translated"><code class="fe od oe of og b"><a class="ae lw" href="https://axsaucedo.github.io/vulkan-kompute/overview/reference.html#opalgobase" rel="noopener ugc nofollow" target="_blank">kp::OpAlgoBase</a></code> —这是一个 Kompute 操作，将我们上面写的着色器与所有本地 CPU/主机资源绑定在一起。这包括提供张量。值得一提的是，作为参数提供的张量的索引是它们通过各自的绑定在着色器中映射的顺序(正如您可以在着色器中看到的，每个向量都具有格式<code class="fe od oe of og b">layout(binding = NUMBER)</code>)。</li><li id="61d9" class="lx ly it kv b kw mg kz mh lc mi lg mj lk mk lo mc md me mf bi translated"><code class="fe od oe of og b"><a class="ae lw" href="https://axsaucedo.github.io/vulkan-kompute/overview/reference.html#optensorsynclocal" rel="noopener ugc nofollow" target="_blank">kp::OpTensorSyncLocal</a></code> —该 Kompute 操作执行与上述同步操作类似的一组指令，但它不是将数据复制到 GPU 存储器，而是相反。这个 Kompute 操作将 GPU 内存中的数据映射到本地张量向量，因此可以从 GPU/主机访问它。如你所见，我们只在输出张量中运行这个操作。</li></ul><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="oc ko l"/></div></figure><h2 id="8486" class="nq mm it bd mn nr ns dn mr nt nu dp mv lc nv nw mx lg nx ny mz lk nz oa nb ob bi translated">6.迭代 100 次:运行微批处理执行并更新权重</h2><p id="3cfc" class="pw-post-body-paragraph kt ku it kv b kw nd ju ky kz ne jx lb lc nf le lf lg ng li lj lk nh lm ln lo im bi translated">现在我们已经记录了命令，我们可以开始运行这些预加载命令的执行。在这种情况下，我们将运行一个微批处理迭代的执行，然后在本地更新参数，以便在接下来的迭代中使用它们。</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="oc ko l"/></div></figure><h2 id="60b5" class="nq mm it bd mn nr ns dn mr nt nu dp mv lc nv nw mx lg nx ny mz lk nz oa nb ob bi translated">7.打印结果参数，用于进一步推断</h2><p id="b5a2" class="pw-post-body-paragraph kt ku it kv b kw nd ju ky kz ne jx lb lc nf le lf lg ng li lj lk nh lm ln lo im bi translated">我们现在有了一个经过训练的逻辑回归模型，或者至少我们已经能够优化其各自的功能，以确定合适的参数。我们现在能够打印这些参数，并在看不见的数据集中使用这些参数进行推理。</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="oc ko l"/></div></figure><p id="1d30" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们完事了。</p><p id="5232" class="pw-post-body-paragraph kt ku it kv b kw kx ju ky kz la jx lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">您可以在示例存储库中找到这个完整的示例，您将能够运行和扩展它。你会在 GPU 逻辑回归<a class="ae lw" href="https://github.com/axsaucedo/vulkan-kompute/tree/7906406dd1e8bbfb01c1c5d68be44f63587440aa/examples/logistic_regression#kompute-logistic-regression-example" rel="noopener ugc nofollow" target="_blank">示例 repo </a>中找到所有完整的文件，包括<a class="ae lw" href="https://github.com/axsaucedo/vulkan-kompute/blob/7906406dd1e8bbfb01c1c5d68be44f63587440aa/examples/logistic_regression/src/Main.cpp#L15" rel="noopener ugc nofollow" target="_blank"> Kompute C++代码</a>，以及<a class="ae lw" href="https://github.com/axsaucedo/vulkan-kompute/blob/7906406dd1e8bbfb01c1c5d68be44f63587440aa/examples/logistic_regression/shaders/glsl/logistic_regression.comp#L7" rel="noopener ugc nofollow" target="_blank">着色器文件</a>。</p><h1 id="7a78" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">接下来呢？</h1><p id="e0a3" class="pw-post-body-paragraph kt ku it kv b kw nd ju ky kz ne jx lb lc nf le lf lg ng li lj lk nh lm ln lo im bi translated">恭喜你，你一路走到了最后！虽然这篇文章涵盖了广泛的主题，但是也有大量的概念被浏览过。其中包括底层 Vulkan 概念、GPU 计算基础、机器学习最佳实践和更高级的 Kompute 概念。幸运的是，网上有大量的资源可以扩展你在这些方面的知识。我推荐作为进一步阅读的一些链接包括:</p><ul class=""><li id="9f1c" class="lx ly it kv b kw kx kz la lc lz lg ma lk mb lo mc md me mf bi translated"><a class="ae lw" href="https://axsaucedo.github.io/vulkan-kompute/" rel="noopener ugc nofollow" target="_blank"> Kompute 文档</a>了解更多细节和示例</li><li id="f38e" class="lx ly it kv b kw mg kz mh lc mi lg mj lk mk lo mc md me mf bi translated"><a class="ae lw" href="https://ethical.institute/mle.html" rel="noopener ugc nofollow" target="_blank">机器学习工程师时事通讯</a>如果你想了解关于机器学习的最新文章</li><li id="bfe4" class="lx ly it kv b kw mg kz mh lc mi lg mj lk mk lo mc md me mf bi translated"><a class="ae lw" href="https://github.com/EthicalML/awesome-production-machine-learning/" rel="noopener ugc nofollow" target="_blank">令人敬畏的生产机器学习</a>开源工具列表，用于部署、监控、版本化和扩展您的机器学习</li><li id="6418" class="lx ly it kv b kw mg kz mh lc mi lg mj lk mk lo mc md me mf bi translated"><a class="ae lw" href="https://www.fast.ai/2018/09/26/ml-launch/" rel="noopener ugc nofollow" target="_blank">FastAI 的 ML for Coders 课程简介</a>进一步学习机器学习概念</li><li id="8eb2" class="lx ly it kv b kw mg kz mh lc mi lg mj lk mk lo mc md me mf bi translated"><a class="ae lw" href="https://vulkan-tutorial.com/" rel="noopener ugc nofollow" target="_blank"> Vulkan SDK 教程</a>深入了解底层 Vulkan 组件</li></ul></div></div>    
</body>
</html>