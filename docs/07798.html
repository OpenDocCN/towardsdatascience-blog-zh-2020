<html>
<head>
<title>Reshaping DataFrames in Pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">重塑熊猫的数据框架</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/reshaping-dataframes-in-pandas-f6bfbb2c5b0f?source=collection_archive---------21-----------------------#2020-06-10">https://towardsdatascience.com/reshaping-dataframes-in-pandas-f6bfbb2c5b0f?source=collection_archive---------21-----------------------#2020-06-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="d2a2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">用python重塑数据帧的终极指南</p><h1 id="b9f9" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">介绍</h1><p id="d42e" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">Pandas无疑是python中使用最多的包之一。对于阅读本文的大多数人来说，这可能并不奇怪。许多人用熊猫来做不同种类的数据分析等等。但是，在某些情况下，我们可能希望以不同于最初提供的格式来重塑或可视化数据。这可能是由于各种原因。这可能是因为人们发现不同的表达方式更容易理解。这也可能是因为你想有一个特定的格式来运行你的代码。无论原因是什么，重塑数据框架可以被视为我们大多数人在作为数据科学家/分析师的旅程中所做的一项常见任务。本文将简要介绍一些有用的函数，这些函数可以用来重塑熊猫的数据帧。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/ed5c6a1292bf656eb7a204855ce4c00c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/1*DM92Crfd5zW-fhu2On3hzA.png"/></div><p class="lz ma gj gh gi mb mc bd b be z dk translated">作者图片</p></figure><p id="2700" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我喜欢认为重塑函数有两种类型。第一类功能简单的改造现有的数据框架。例如，它们将列更改为行，将行更改为列。第二种类型的功能将聚合信息并对其进行重组。在大多数真实情况下，我们会使用第二种类型的函数，因为它可以根据需要让我们看到更高级别的汇总或聚合。</p><h1 id="a383" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">类型1:没有聚集的重整</h1><p id="f5d6" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">理想情况下，没有聚合的重组可以而且应该应用于存在唯一选择组合的数据。否则，他们很可能会对某些函数抛出错误。</p><p id="dd87" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了解释没有聚集的重整，我们将首先声明一个数据框架。声明和数据框架如下:</p><figure class="ls lt lu lv gt lw"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="c01a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用这个数据框架，我们可以看到一些对改造/整形有用的功能。</p><h2 id="0b7b" class="mf kp it bd kq mg mh dn ku mi mj dp ky kb mk ml lc kf mm mn lg kj mo mp lk mq bi translated">在枢轴上转动</h2><p id="fb7d" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">Pivot方法通常用于创建数据的透视样式视图，用户可以在其中指定行(在python中称为索引)和列。这两个参数将为视图提供一个结构，而要填充的信息将来自用于创建pivot的数据。也可以使用values参数有选择地填充信息。现在让我们看一些例子来更好地理解它。</p><pre class="ls lt lu lv gt mr ms mt mu aw mv bi"><span id="db59" class="mf kp it ms b gy mw mx l my mz">df.pivot(index='Date', columns='Class', values='Numbers')</span></pre><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi na"><img src="../Images/6b31c87c052229795d5a8abff767c9ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:588/format:webp/1*Ix9I4TZf8cHxJGppdOaZxw.png"/></div><p class="lz ma gj gh gi mb mc bd b be z dk translated">作者图片</p></figure><p id="cfdc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如我们从上面所看到的，一旦指定了索引、列、值，就形成了新的透视样式数据帧的结构，并相应地填充了索引、列对的组合所特有的信息。</p><p id="b714" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请记住，建议始终填充索引和列参数，因为这将决定最终数据帧/视图的结构。让我们看看如果不声明values参数会发生什么。</p><pre class="ls lt lu lv gt mr ms mt mu aw mv bi"><span id="6720" class="mf kp it ms b gy mw mx l my mz">df.pivot(index='Date', columns='Class')</span></pre><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/3a060ca4fbe4558501e1782a4799d527.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*LjEpKsb3-OQl0QUoaAPg3g.png"/></div><p class="lz ma gj gh gi mb mc bd b be z dk translated">作者图片</p></figure><p id="e1bc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们不指定values参数，pandas将创建所有各种可能的视图，同时将所有列名与上面指定的索引和列分开。因此，对于具有多个列的大型数据集，建议也指定value参数。</p><p id="5d02" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，使用上面的代码并稍微调整一下，还有另一种方法来提取关于一列的信息。这将是如下。</p><pre class="ls lt lu lv gt mr ms mt mu aw mv bi"><span id="205e" class="mf kp it ms b gy mw mx l my mz">df.pivot(index='Date', columns='Class')['Numbers']</span></pre><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/c8707fff08f1f7b26aeb2873718495e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:556/format:webp/1*FhQJYYw1gq64Ppy095ZKlw.png"/></div><p class="lz ma gj gh gi mb mc bd b be z dk translated">作者图片</p></figure><p id="0aae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们提到上面给出的列名，而没有指定values参数，那么结果输出将是相同的。这样做的唯一缺点是需要更长的时间来执行。需要注意的是，列名声明类似于数据帧子集的语法。这是因为我们确实正在这样做。使用上面的代码，pandas首先获得所有列的结果，然后使用括号中指定的列名，pandas对数据帧进行子集化并显示出来。这也是为什么这个方法的执行时间比我们使用values参数的方法要长。</p><p id="19c9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意:使用pivot函数时，如果行*列的组合有多个条目，该函数将抛出一个错误，因为pivot不会进行任何类型的聚合。</p><h2 id="199c" class="mf kp it bd kq mg mh dn ku mi mj dp ky kb mk ml lc kf mm mn lg kj mo mp lk mq bi translated">熔化</h2><p id="9ca9" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">Melt是一个用于将列转换为行的函数。这意味着当用户希望将一列或多列信息放入行中时，这个函数非常有用。该函数将通过删除除id_vars参数中提到的列之外的所有其他列来创建两个新列，并在一列中显示列名，在另一列中显示其值。让我们看一个例子来更好地理解它。</p><pre class="ls lt lu lv gt mr ms mt mu aw mv bi"><span id="9941" class="mf kp it ms b gy mw mx l my mz">df.melt(id_vars=['Date','Class'])</span></pre><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/00186835a980da3721a78150841be0e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:560/format:webp/1*FSUlm8K_tDSVm1FibLSbLw.png"/></div><p class="lz ma gj gh gi mb mc bd b be z dk translated">作者图片</p></figure><p id="193e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在数据帧df中，我们有四列，其中在id_vars参数中提到了日期和类别。这将给我们留下列号和列号2。正如我们在上面看到的，该函数创建了两个名为variable和value的新列，并用列名和Date+class+列名组合的唯一值填充它们，同时删除列号和Numbers2。</p><p id="ba27" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果只有特定的列要以这种方式转换，而不是所有的列，那么参数value_vars将帮助我们实现这一点。</p><pre class="ls lt lu lv gt mr ms mt mu aw mv bi"><span id="81d7" class="mf kp it ms b gy mw mx l my mz">df.melt(id_vars=['Date','Class'], value_vars=['Numbers'])</span></pre><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/05aa50fdc2697229ade4c516fbb25072.png" data-original-src="https://miro.medium.com/v2/resize:fit:548/format:webp/1*isIh_cV-hXMr6DwM3xialw.png"/></div><p class="lz ma gj gh gi mb mc bd b be z dk translated">作者图片</p></figure><p id="c458" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如我们所看到的，当value_vars参数中提到特定的列名时，只有该列的信息会根据需要进行融合。还有两个额外的参数value_name和var_name，它们将通过参数中提到的字符串来重命名列value和variable。让我们看一个例子来更好地理解这一点。</p><pre class="ls lt lu lv gt mr ms mt mu aw mv bi"><span id="d598" class="mf kp it ms b gy mw mx l my mz">df.melt(id_vars=['Date','Class'], value_vars=['Numbers'], value_name="Numbers_Value", var_name="Num_Var")</span></pre><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/16beefd80faccd719a9506c743b463c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:618/format:webp/1*FItGFaRQvGNRpANy-V_ADQ.png"/></div><p class="lz ma gj gh gi mb mc bd b be z dk translated">作者图片</p></figure><p id="fc3f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如我们所看到的，列被重命名为参数中指定的列。</p><h2 id="a046" class="mf kp it bd kq mg mh dn ku mi mj dp ky kb mk ml lc kf mm mn lg kj mo mp lk mq bi translated">堆叠和取消堆叠</h2><p id="81e1" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">Stack和Unstack分别执行列到行和行到列的操作。这两个功能肯定是熊猫整形中较少使用的功能之一，因为人们会使用pivot来实现他们大多数时间想要的结果，因此不需要它。我们仍将研究它们，以了解它们是如何工作的，因为它们在一些特定的场景中可能是有用的。</p><p id="b901" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">stack和melt之间的主要区别是stack需要将id_vars设置为index，而不是必须单独将它们作为参数传递。让我们看一下stack来理解它做什么。</p><pre class="ls lt lu lv gt mr ms mt mu aw mv bi"><span id="4cf8" class="mf kp it ms b gy mw mx l my mz">df.set_index(["Date","Class"]).stack()</span></pre><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/7c8957e1df8b6a5cd30ef3778abf39ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/format:webp/1*qk9ff9QGZv3j-3e_HDezXA.png"/></div><p class="lz ma gj gh gi mb mc bd b be z dk translated">作者图片</p></figure><p id="a57a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如我们所观察到的，它具有与melt相同的功能，将列转换为行。</p><p id="6670" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一方面，拆分与堆叠正好相反。它将行带到列，像堆栈一样，它需要索引才能按预期运行。</p><pre class="ls lt lu lv gt mr ms mt mu aw mv bi"><span id="29ec" class="mf kp it ms b gy mw mx l my mz">df.set_index(["Date","Class"]).stack().unstack()</span></pre><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/cba4c9396ad6f14c377e08239b80008d.png" data-original-src="https://miro.medium.com/v2/resize:fit:530/format:webp/1*q9I4t_5sErWFa6rmRoBJgQ.png"/></div><p class="lz ma gj gh gi mb mc bd b be z dk translated">作者图片</p></figure><p id="77cf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如我们所看到的，如果没有输入，unstack基本上会撤消堆叠操作。当更改拆分括号内的数字输入时，输出会有所不同。如果你对这个话题感兴趣，这将是一个很好的话题。</p><h1 id="1686" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">类型2:通过聚合进行改革</h1><p id="8bf3" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">与类型1函数不同，类型2函数提供了信息的汇总视图。如果用户想要对数据进行某种类型的汇总，这将非常有用。我们将使用用于类型1函数的相同数据框架来研究类型2函数。</p><p id="aa0c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了解释没有聚集的重整，我们将首先声明一个数据框架。声明和数据框架如下:</p><figure class="ls lt lu lv gt lw"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="3b61" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用这个数据框架，我们可以看到一些对改造/整形有用的功能。</p><h2 id="f525" class="mf kp it bd kq mg mh dn ku mi mj dp ky kb mk ml lc kf mm mn lg kj mo mp lk mq bi translated">分组依据</h2><p id="d142" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">Group by是我使用最频繁的函数，超过了本文中提到的任何其他函数。这是因为，它使用起来非常直观，并且具有非常有用的参数，可以帮助用户查看不同列的不同聚合。让我们通过语句来研究一个简单的组。</p><pre class="ls lt lu lv gt mr ms mt mu aw mv bi"><span id="182e" class="mf kp it ms b gy mw mx l my mz">df.groupby('Date')["Numbers"].mean()</span></pre><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/ab9fa1843764696188ef3bb684434f7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:456/format:webp/1*Lz1W2Zz86b6Zw2ya-tyxxg.png"/></div><p class="lz ma gj gh gi mb mc bd b be z dk translated">作者图片</p></figure><p id="d40b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在group by语句中，我们在第一个括号内指定需要对数据进行分组的一列或多列。这里，我们既可以给出一个单独的字符串，也可以给出与列名相关的字符串列表。下一个括号是指定要聚合的数据，最后我们调用聚合应该使用的方法。在上面的例子中，我们使用平均聚合来聚合日期的列数。</p><p id="fe2a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意，输出不是数据帧，而是看起来类似于熊猫系列。要将其转换为dataframe，我们可以使用reset_index方法，或者也可以使用group by语句中可用的参数。我将使用后者。</p><pre class="ls lt lu lv gt mr ms mt mu aw mv bi"><span id="eeb4" class="mf kp it ms b gy mw mx l my mz">df.groupby('Date', as_index=False)["Numbers"].mean()</span></pre><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/c33917eda540a92610807f1ea6c400d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:330/format:webp/1*MjxMMtLbjxcmBwcR8YCuYw.png"/></div><p class="lz ma gj gh gi mb mc bd b be z dk translated">作者图片</p></figure><p id="4f24" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如上图所示，as_index参数可用于将group by的结果转换为dataframe。</p><p id="0981" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们再看一个例子，在这个例子中，我们使用一种方法对多个列进行聚合。</p><pre class="ls lt lu lv gt mr ms mt mu aw mv bi"><span id="e70a" class="mf kp it ms b gy mw mx l my mz">df.groupby(['Date','Class'], as_index=False)["Numbers"].mean()</span></pre><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/9a258b5b9ba29ed51462954c45f2a8d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:422/format:webp/1*KNgG_5LjyumScZWwKvWvYA.png"/></div><p class="lz ma gj gh gi mb mc bd b be z dk translated">作者图片</p></figure><p id="06ca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如我们在上面看到的，我们可以使用一个字符串列表(列名)在多个列上聚合多个列，而不是指定一个字符串(列名)。但是，我们也可以对不同的列使用不同的聚合函数。让我们看一下下面的例子，以了解如何做到这一点。</p><pre class="ls lt lu lv gt mr ms mt mu aw mv bi"><span id="85ad" class="mf kp it ms b gy mw mx l my mz">df.groupby(['Date'], as_index=False).aggregate({"Numbers":"sum", "Numbers2":"mean"})</span></pre><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/d149882cfa100758b054d849366b7ba6.png" data-original-src="https://miro.medium.com/v2/resize:fit:472/format:webp/1*p142IspMVNVgXogniKlgPA.png"/></div><p class="lz ma gj gh gi mb mc bd b be z dk translated">作者图片</p></figure><p id="a83d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上图中，我们用sum函数聚合日期列上的数字列，同样，我们用mean函数聚合日期列上的数字2列。</p><h2 id="7b36" class="mf kp it bd kq mg mh dn ku mi mj dp ky kb mk ml lc kf mm mn lg kj mo mp lk mq bi translated">数据透视表</h2><p id="87a5" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">数据透视表的功能与透视表相同。然而，pivot table有一个额外的重要参数，它指定了我们将用来聚合数据的聚合函数。让我们看下面的例子来更好地理解它。</p><p id="1244" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们从一个简单的数据透视表开始。</p><pre class="ls lt lu lv gt mr ms mt mu aw mv bi"><span id="f841" class="mf kp it ms b gy mw mx l my mz">df.pivot_table(index="Date", columns="Class")</span></pre><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/8503d2ec7544b1be555ae796c666fa02.png" data-original-src="https://miro.medium.com/v2/resize:fit:954/format:webp/1*LclLlJ-HREEp-uIGsZlRzg.png"/></div><p class="lz ma gj gh gi mb mc bd b be z dk translated">作者图片</p></figure><p id="f961" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意，pivot table的方法调用是pivot_table，它不同于pivot的pivot。如果未指定聚合函数，将使用默认函数mean来聚合信息。</p><pre class="ls lt lu lv gt mr ms mt mu aw mv bi"><span id="1a29" class="mf kp it ms b gy mw mx l my mz">df.pivot_table(index="Date", columns="Class", aggfunc="sum")</span></pre><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/2e6fdd10dc8830a516a6b592adc2b98f.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/format:webp/1*HMY--v8p6R2pp3JrqsnX4A.png"/></div><p class="lz ma gj gh gi mb mc bd b be z dk translated">作者图片</p></figure><p id="b902" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是，如果用户想要指定一个特定的函数，他们可以在参数aggfunc中这样做，如上图所示。</p><h2 id="1d88" class="mf kp it bd kq mg mh dn ku mi mj dp ky kb mk ml lc kf mm mn lg kj mo mp lk mq bi translated">交叉表</h2><p id="2cbc" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">本文中的最后一个函数是交叉表。默认情况下，该函数会给出两个不同列的值之间出现的次数或频率。让我们看一个例子。</p><pre class="ls lt lu lv gt mr ms mt mu aw mv bi"><span id="1045" class="mf kp it ms b gy mw mx l my mz">pd.crosstab(df.Date, df.Class)</span></pre><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi no"><img src="../Images/5ffa908191f5dd699d066133266011f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:344/format:webp/1*Np_8m8DHao5AkCIIyvo82A.png"/></div><p class="lz ma gj gh gi mb mc bd b be z dk translated">作者图片</p></figure><p id="d57a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面的视图意味着在1A班级和2019-02-02日期的组合中有两个不同的条目可用。类似地，其他信息也可以被解释。</p><p id="1ead" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在代替出现频率的情况下，如果用户希望有一些其他的聚合函数，可以使用aggfunc参数。</p><pre class="ls lt lu lv gt mr ms mt mu aw mv bi"><span id="d2b4" class="mf kp it ms b gy mw mx l my mz">pd.crosstab(df.Date, df.Class, values=df.Numbers, aggfunc='sum')</span></pre><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi np"><img src="../Images/6eb5d64c3ed3635127ae9dd95de56824.png" data-original-src="https://miro.medium.com/v2/resize:fit:558/format:webp/1*Yo0tQyobHargbaq0uCXOrg.png"/></div><p class="lz ma gj gh gi mb mc bd b be z dk translated">作者图片</p></figure><pre class="ls lt lu lv gt mr ms mt mu aw mv bi"><span id="c3a2" class="mf kp it ms b gy mw mx l my mz">pd.crosstab(df.Date, df.Class, values=df.Numbers, aggfunc='mean')</span></pre><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi np"><img src="../Images/dafa8e4c931c64d86c185df09d077720.png" data-original-src="https://miro.medium.com/v2/resize:fit:558/format:webp/1*ea5tEPN9UzScVYQb5KXZ6Q.png"/></div><p class="lz ma gj gh gi mb mc bd b be z dk translated">作者图片</p></figure><p id="1ad5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面的图片给人一种如何使用它的感觉。即使输出看起来与数据透视表相似，但实现的方式是不同的。但是人们更喜欢使用数据透视表而不是交叉表函数。</p><h1 id="b16a" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">结论</h1><p id="72b5" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">我们已经在本文中看到了多个函数，并理解了各种参数及其用法。</p><p id="2673" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">总之，每个人都知道实践使人完美。这句话也适用于技术领域，对吗？为了让你更容易实践我们在本文中讨论的多个概念，我创建了一个Jupiter笔记本，你可以在这里下载<a class="ae nq" href="https://github.com/nandurianirudh/mediumblogcodes/blob/master/Reshaping_dataframes_using_pandas.ipynb" rel="noopener ugc nofollow" target="_blank"/>。练习的好时光！！！</p></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="nz oa di ob bf oc"><div class="gh gi ny"><img src="../Images/327064580b234665211277e3902eb069.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*44yldyMiX59H8QwwNP7ydw.png"/></div></div></figure><p id="3601" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果有任何疑问、建设性的批评和任何反馈，请随时联系我这里的<a class="ae nq" href="https://www.linkedin.com/in/anirudh-nanduri-14239025/" rel="noopener ugc nofollow" target="_blank"/>。</p></div></div>    
</body>
</html>