<html>
<head>
<title>Digital Pollution From Modern Data Formats</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">来自现代数据格式的数字污染</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/digital-pollution-5a579f8c9bf?source=collection_archive---------53-----------------------#2020-05-15">https://towardsdatascience.com/digital-pollution-5a579f8c9bf?source=collection_archive---------53-----------------------#2020-05-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="43f4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">抛弃 JSON 如何减轻我们对环境的影响，并使应用程序更加灵敏和高效。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a0e4e70965cb8ea5ba002261c9b19bfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u5d6N3Y6taqRf11jMz6_gA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@punkidu" rel="noopener ugc nofollow" target="_blank">艾拉·伊万内斯库</a></p></figure><p id="c9de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当听到数字污染时，你可能会想到一个位于农村的大型服务器农场，托管着废弃的脸书账户，其中有数百张照片，这些照片永远不会再被加载到浏览器中。或者你可能认为垃圾填埋场堆满了仍在工作，但几乎无用的 iPhone 4s。</p><p id="d3ab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为开发者，为了地球和未来的人类，我们应该留下尽可能小的足迹。与废弃的脸书照片不同，我们的足迹可以成倍增长。让我解释一下…</p><p id="11c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们考虑一些看似简单的事情。<a class="ae kv" href="http://hn.algolia.com/api/v1/search?query=digitalpollution&amp;tags=story" rel="noopener ugc nofollow" target="_blank">这是为<a class="ae kv" href="https://news.ycombinator.com/" rel="noopener ugc nofollow" target="_blank"> Y-combinator 的黑客新闻</a>实现的一个 API</a>。</p><p id="2c5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://hn.algolia.com/api/v1/search?query=digitalpollution&amp;tags=story" rel="noopener ugc nofollow" target="_blank">http://hn.algolia.com/api/v1/search?query=digitalpollution&amp;标签=故事</a></p><p id="8e25" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是上面调用 API 的结果:(您不必阅读)</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ls"><img src="../Images/dfe187807161ee3bd699391bb4e73a55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1YgDBQMrs6cyuzUccjDa9g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">JSON 结果</p></figure><p id="38f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">酷毙了。按下按钮，拿香蕉。发出 URL 请求并获得您想要的故事，所有这些都可以在人类可读、机器可解析的 JSON 中获得。但是等等。</p><p id="cff7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从什么时候开始我们的数据需要人类可读了？当然，在一个 API 的开发过程中拥有它可能是件好事，但是在最终产品中呢？看起来这是对文字和花括号的极大浪费。“[]} }]”是否向读者传达了很多意图或意义？但是当你把人类可读的格式和机器可解析的格式结合起来时，就会发生这种情况。有必要吗？这一切有什么意义？这样我就可以获取这个故事，并以一种漂亮的、人类可读的方式显示在我的应用程序中。我会向我的客户展示这个 JSON 吗？不要！那么，为什么我们要以人类可读的格式传递数据呢？</p><p id="40c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我将其归咎于“<a class="ae kv" href="https://en.wikipedia.org/wiki/Cargo_cult_programming" rel="noopener ugc nofollow" target="_blank">货邪教编程</a>”之前，也许我们应该进一步分析？人类出于什么原因想要阅读这些“数据”作为一名开发人员，拥有这个伟大的 API 不是很好吗？当然可以。这是一件好事。能够将我的请求结果打印到屏幕上，以确保我得到了“我需要的数据”，这真是太棒了但这不是我需要的数据。这是我需要的包装在文本中的数据，我不需要。这是我需要用文本表示的数据，我必须将它转换成我需要的数据。现在我有了 burn 资源和 CPU 解析和转换这些乱七八糟的东西，所以我终于可以得到我需要的数据了。</p><p id="6e3b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果数据“人类可读”的目的是为了在开发过程中有所帮助，那么为什么不在对人类可读版本的请求中添加一个参数呢？类似于，"<em class="lt"> &amp;格式=可读。"</em>然后<em class="lt">，一个</em>在我们知道我们正在读入正确的数据后，我可以删除那个参数，得到实际的数据。</p><h1 id="d7ee" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">这是为什么污染？</h1><p id="ac30" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">因为这是对 CPU、收音机和调制解调器的不必要的使用。这需要时间、金钱和精力。</p><h1 id="7419" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">不必要的 CPU 使用</h1><p id="6251" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">为什么我们需要解析数据？如果我们只是收到了我们需要的数据，以约定的格式，我们可以把它放入我们需要的变量中。我们不需要一个 JSON 解码库，里面有处理器的成千上万条 if-then 指令。</p><h1 id="8473" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">无线电和调制解调器的不必要使用</h1><p id="0c73" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">尺寸很重要。与发送 200 字节的信息相比，发送 100 字节的信息会减少蜂窝无线电、家庭调制解调器或服务器调制解调器的能耗。</p><p id="a172" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为一个快速演示，让我们检查上面的一点 JSON。</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="9c89" class="mw lv iq ms b gy mx my l mz na">"num_comments":0</span></pre><p id="3c4a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这让我们知道上面检索到的文章标题没有评论。我可以在我的新闻阅读器应用程序中使用它，显示这篇文章没有评论。我们收到了多少 JSON 格式的数据？</p><p id="e7f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">JSON 通常以 UTF-8 格式传输。UTF 8 中的字符是可变长度的，但在这种情况下，它们都属于一个字节的范围。所以上面的<em class="lt">“num _ comments”:0</em>等于实际字符数。这里是 16 个字符，所以是 16 个字节。如果有 100 条注释，那么由于多了两个零，它应该是 18 个字节。"00."1000 条评论就是 19 个字节，依此类推。</p><p id="4427" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们不使用 JSON，只是将它作为序列化数据发送，我们可以将它作为无符号整数发送。这将只是 2 个字节，代表从 0 到 65，536 条评论。19 字节对 2 字节。我们节省了 17 个字节，节省了将近 90%。</p><p id="a06d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> JSON 版本:</strong></p><p id="c7e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi">00100010 01101110 01110101 01101101 01011111 01100011 01101111 01101101 01101101 01100101 01101110 01110100 01110011 00100010 00111010 00110000</p><p id="bdbb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">数据版本:</strong></p><p id="0123" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi">00000000</p><p id="521e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">传递同样的信息，这是一个非常显著的差异。<br/>下面是一个 swift 示例，展示了类似这样的东西在 Swift 中的表现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="04ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在操场上运行代码，打印结果将是:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="2d18" class="mw lv iq ms b gy mx my l mz na"><strong class="ms ir">Article(id: 18798989, title: "JSON = fat", comments: 3, likes: 1000)</strong></span><span id="a04e" class="mw lv iq ms b gy nd my l mz na"><strong class="ms ir">{length = 16, bytes = 0x0a004a534f4e203d206661740300e803}</strong></span><span id="7963" class="mw lv iq ms b gy nd my l mz na"><strong class="ms ir">Article(id: 18798989, title: "JSON = fat", comments: 3, likes: 1000)</strong></span></pre><p id="9d6a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它用 ID、标题、评论数和赞数来序列化文章标题。结果是 16 个字节。</p><p id="5ecd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用我们之前的 JSON 例子发送给我们的相同数量的数据<strong class="ky ir">仅仅是评论数，我们得到了两个更有意义的数字和文章的标题…哦，还有评论数。</strong></p><p id="47b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这需要多少 JSON？</p><p id="d19a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ne nf ng ms b">{<br/> "id": 18798989,<br/> "title": "JSON = fat",<br/> "comments": 3,<br/> "likes": 1000<br/>}</code></p><p id="16a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">67 字节的 JSON 与 16 字节的紧密序列化数据。所以是的，我给 JSON fat 打了电话。</p><p id="b4e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，我们使用不到 25%的数据来表示相同的信息。当然，一旦我们开始在一篇实际的文章中发送大量的内容，实际的节省将会下降。占用空间的实际文本。许多 API 甚至不包含长文文本。许多是以数字为中心的，这些节省是最显著的。</p><p id="5e06" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑来自同一黑客新闻 API 的以下请求，该 API 仅返回头版文章的元信息:</p><p id="5212" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="http://hn.algolia.com/api/v1/search?tags=front_page" rel="noopener ugc nofollow" target="_blank">http://hn.algolia.com/api/v1/search?tags=front_page</a></p><p id="96b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">在撰写本文时，这是它返回的 16137 个字节:</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/b983d81f684f44baf93f7680deae2424.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bn5nBvW8P5ei9BUqiYqQTw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">巨大的 JSON 回报</p></figure><p id="574b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">16 千字节，而如果我们使用紧密序列化数据，可能是 4 千字节。为了什么？只是为了让开发人员可以浏览一些文本，以验证我们在测试这段代码时是否得到了它，而不考虑这段代码可能会被使用成千上万次。想想如果 CNN 或福克斯新闻频道在他们的应用中使用这种类型的 API。他们可能是。想象一下如果 twitter 有呢？<a class="ae kv" href="https://developer.twitter.com/en/docs/tweets/data-dictionary/overview/intro-to-tweet-json" rel="noopener ugc nofollow" target="_blank">看起来是的。</a></p><h1 id="a4f2" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">数据就是金钱</h1><p id="65f1" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">他们可以在数据传输成本上节省多少钱？有人估计 twitter 每天使用<a class="ae kv" href="https://bigdatashowcase.com/how-much-big-data-companies-make-on-internet/" rel="noopener ugc nofollow" target="_blank">12tb。在 AWS 上，这是 12，000 GB，每 GB 约 8 美分，每天约 960 美元或每年 350，400 美元。理论上，紧密的数据序列化可以将它们的传输成本降低到当前使用量的 25%。这可以为他们每年节省 262，800 美元。还不错。</a></p><p id="ca36" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">他们也在存储这些数据，可能是序列化的… JSON，这是要花钱的。一年每天 12tb 的新推文，每年 4,380。让我们假设他们只保留了最近 5 年的推文。这相当于 21，000 万亿字节的存储推文数据。刚刚检查了 AWS 上的简单存储。这将花费每月 452，147 美元或每年 5，425，764 美元。紧密的电子监管似乎每年可以为他们节省 4，069，323 美元。也许他们正在压缩？JSON 通常会压缩到 50%左右。所以也许紧密的序列化每年只能节省几百万美元？但是压缩和解压缩会节省 CPU 周期。计算变得复杂，但证据相当简单。公司可以使用紧密的序列化来节省空间、时间和金钱。</p><p id="de65" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这也是一个环境问题。成本和数据节约接近 1:1。环境影响减少更多。减少 75%的数据将比减少 75%的排放或能源使用量还要多。能量消耗在于储存、压缩、发送和接收。通常，发送和接收是通过多个服务器或节点进行的。来自 twitter 的一个字节可能会跳过五个或更多的服务器到达你的设备。考虑这个从随机用户服务器到 twitter 服务器的跟踪路由。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/3bcb3bccda685c094299b35caa1dbd56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H8TQ1D3ezQEw6P6cuZMDPw.png"/></div></div></figure><p id="14d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从您的电话，这将包括您和第一个服务器之间或您的电话和您的路由器之间的无线电跳。然后……五个左右收发(10x)之间。减少 75%的数据比减少 75%的能源成本要多得多。每次发送和接收都减少了 75%。在这种情况下，数据减少 4 倍相当于传输的能源成本减少 40 倍。</p><h1 id="460b" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">效率和延迟</h1><p id="aea0" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">较小的数据传输速度更快，到达速度也更快。这使得您的应用程序响应速度更快。紧密序列化的数据不必通过 JSON 解码器用数千条 if-then 语句来解析。这使得你的应用程序反应更快。为了省钱，数据不必在服务器上压缩，这使得你的应用在请求数据时响应更快。纯粹、紧密、序列化的数据让你的应用更快。这使得客户体验更好，您的应用程序更节能。</p><p id="a135" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我在我的应用程序中这样做时，我发现性能和响应能力都得到了提高。</p><h1 id="eb09" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">结论</h1><p id="2859" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">我喜欢<a class="ae kv" href="https://medium.com/@icex33/stop-using-json-in-production-386f0115ae47" rel="noopener"> Maxim Zaks 在他题为<em class="lt">停止在生产中使用 JSON 的文章中所说的</em></a>。“模式的主要好处是它描述了有效负载。当你有一个模式时，你的负载携带的描述是多余的。”API 开发人员花费数天时间编写模式来描述他们的 JSON 格式，这种格式已经在他们的 JSON 格式中描述过了。我们应该停止在生产中使用 JSON。我们应该描述从我们的参数返回的数据格式。</p><p id="b00d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我把这个问题的解决方案称为“紧密序列化”类似的解决方案还有平面映射或协议缓冲区。最终，它只是由提供者描述并被接收者理解的有序数据。它不需要是人类可读的。它可以节省时间、金钱和能源，并使您的应用程序响应更快。</p></div></div>    
</body>
</html>