<html>
<head>
<title>Demystifying Scrapy Item Loaders</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭开杂乱物品装载器的神秘面纱</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/demystifying-scrapy-item-loaders-ffbc119d592a?source=collection_archive---------6-----------------------#2020-02-24">https://towardsdatascience.com/demystifying-scrapy-item-loaders-ffbc119d592a?source=collection_archive---------6-----------------------#2020-02-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="4b6e" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">权威指南</h2><div class=""/><div class=""><h2 id="8e78" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">自动清理和扩展你的垃圾蜘蛛</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/6be3e37dd9ee2fb01e916c38f86eaa64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VsX41vK96VE7b_aF18Hw0w.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">来自Unsplash的Nicolasintravel</p></figure><h1 id="d926" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">项目和项目加载器</h1><p id="0161" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">当从网站上抓取数据时，它可能是混乱和不完整的。现在scrapy上的大部分教程都引入了物品的概念。项目为报废的数据提供容器。但是物品装载器在这里起什么作用呢？它们提供了填充项目容器的机制。</p><p id="00db" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">项目加载器自动执行常见任务，如在项目容器之前解析数据。它还提供了一种更干净的方式来管理提取的数据，因为你扩大了你的蜘蛛。</p><p id="8047" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">要跟进，请阅读scrapy文档中的项目。有必要对这个有个了解再继续！</p><h1 id="474f" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">路线图</h1><p id="2687" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">在本文中，我们将定义什么是与项目相比较的项目加载器。然后我们将讨论项目加载器如何通过处理器来完成这项工作。这些处理器是内置的或定制的。它们为我们提供了在填充项目字段之前解析数据的能力。然后，我们将向您展示项目加载器如何使数据提取更加干净。这是在传送到处理器之前。我们将解释如何让我们自己的处理器超越内置函数，按照我们认为合适的方式改变我们的数据。我们将介绍如何扩展ItemLoader。这允许我们在网站改变时扩大我们的蜘蛛的功能。</p><h2 id="8500" class="nb lj it bd lk nc nd dn lo ne nf dp ls mj ng nh lu mn ni nj lw mr nk nl ly iz bi translated">清单</h2><ol class=""><li id="4598" class="nm nn it mc b md me mg mh mj no mn np mr nq mv nr ns nt nu bi translated">定义项目装入者职责</li><li id="dcc9" class="nm nn it mc b md nv mg nw mj nx mn ny mr nz mv nr ns nt nu bi translated">定义输入和输出处理器，这是项目装载器的发电站</li><li id="c142" class="nm nn it mc b md nv mg nw mj nx mn ny mr nz mv nr ns nt nu bi translated">定义ItemLoaders方法。这就是ItemLoaders为处理器获取数据的方式</li><li id="53c5" class="nm nn it mc b md nv mg nw mj nx mn ny mr nz mv nr ns nt nu bi translated">定义项目装入程序上下文。这是处理器之间共享键和值的一种方式，非常有用</li><li id="c6b9" class="nm nn it mc b md nv mg nw mj nx mn ny mr nz mv nr ns nt nu bi translated">定义内置处理器<code class="fe oa ob oc od b">Identity()</code>、<code class="fe oa ob oc od b">TakeFirst()</code>、<code class="fe oa ob oc od b">Join()</code>、<code class="fe oa ob oc od b">Compose()</code>、<code class="fe oa ob oc od b">MapCompose()</code></li><li id="c6d8" class="nm nn it mc b md nv mg nw mj nx mn ny mr nz mv nr ns nt nu bi translated">如何定义项目加载器所需的特定输入和输出处理器。这为您提供了灵活性。您可以为不同的项目字段选择不同的输入和输出处理器。</li><li id="4222" class="nm nn it mc b md nv mg nw mj nx mn ny mr nz mv nr ns nt nu bi translated">定义NestedLoader。当所有数据都在一个HTML块中时，这是一种清理我们编写项目加载器的方式。</li><li id="d2c0" class="nm nn it mc b md nv mg nw mj nx mn ny mr nz mv nr ns nt nu bi translated">如何扩展ItemLoader和插件功能。对于可伸缩性和网站变化非常有用。</li></ol><h1 id="601f" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">使用项目装入器填写项目</h1><p id="da93" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">让我们来看看物品装载器的幕后。为了利用这一点，我们必须创建一个ItemLoader。这是一个名为Scrapy.Loader.Itemloader的类，它有三个主要参数。</p><ol class=""><li id="604b" class="nm nn it mc b md mw mg mx mj oe mn of mr og mv nr ns nt nu bi translated">Item:指定我们为蜘蛛创建的一个或多个条目，以便用ItemLoader填充。如果没有指定，scrapy会创建一个名为default_item_class的新项目对象</li><li id="db1a" class="nm nn it mc b md nv mg nw mj nx mn ny mr nz mv nr ns nt nu bi translated">选择器:为Itemloaders方法使用选择器。如果没有指定，Scrapy会创建一个新的选择器类。然后给变量default_selector_class赋值。</li><li id="bf40" class="nm nn it mc b md nv mg nw mj nx mn ny mr nz mv nr ns nt nu bi translated">用于使用default_selector_class构造选择器的响应</li></ol><h2 id="6906" class="nb lj it bd lk nc nd dn lo ne nf dp ls mj ng nh lu mn ni nj lw mr nk nl ly iz bi translated">句法</h2><p id="44c7" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated"><code class="fe oa ob oc od b">ItemLoader([item,selector,response,] **kwargs)</code></p><p id="3a08" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">为了开始使用ItemLoader，我们将它导入到我们的spider中。然后，我们导入我们在spiders items.py中指定的项目</p><pre class="ks kt ku kv gt oh od oi oj aw ok bi"><span id="f80b" class="nb lj it od b gy ol om l on oo">from scrapy.loader import ItemLoader<br/>from myproject.items import Product</span></pre><p id="aef8" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">现在让我们看看如何启动ItemLoader，注意我们在这里没有指定选择器。如果我们不定义默认选择器，Itemloader实际上会填充它。</p><pre class="ks kt ku kv gt oh od oi oj aw ok bi"><span id="a86f" class="nb lj it od b gy ol om l on oo">def parse(self,response):<br/>    l = ItemLoader(Product(), response)</span></pre><p id="f186" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">注意事项<br/> 1。我们从parse函数开始，这是ItemLoader实例形成的地方。</p><p id="9af6" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">2.我们将变量l赋给ItemLoader类实例。我们在spiders Items.py和响应中定义了我们的<code class="fe oa ob oc od b">product()</code> items实例。</p><p id="d865" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">使用ItemLoader类的下一步是ItemLoader方法。这让我们有能力从我们的网站获取数据，并允许我们操纵它。我们通过一种叫做处理器的东西来操纵它。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi op"><img src="../Images/a0f2d57db90c5673852f208a06bc1655.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TvuWPREShA57eL0k-YQdPg.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">Unsplash的哈勃望远镜</p></figure><h1 id="e622" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">输入输出处理器</h1><p id="4262" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">对于每个项目字段，项目加载器都有一个输入处理器和一个输出处理器。一旦收到提取的数据，它们就进行处理。在ItemLoad方法中定义处理器来解析数据(下一节)。</p><p id="b944" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">一旦我们用输入处理器处理了数据。然后，它会将提供给它的任何数据追加到ItemLoader中的一个内部列表中。因为这些数据被放入一个列表中，所以允许ItemLoader的一个条目字段有多个值。这个内部列表的结果然后被馈送到输出处理器。然后输出处理器的结果被分配给Item字段。</p><p id="1f04" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">处理器是调用数据进行解析并返回解析值的对象。有了它，我们就可以将任何函数用作输入或输出处理器。唯一的条件是处理器函数的第一个参数必须是可迭代的。</p><p id="efc6" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">Scrapy还内置了我们将在本文中讨论的处理器。</p><p id="fbe6" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">我们现在可以讨论真正神奇的ItemLoader方法了！</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/6efdb80d0a77e8a8bba5e7c6a3441b96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*immqfPiKtgGi3tdJ263Kyw.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">来自Unsplash的Slejven Djurakovic</p></figure><h1 id="9467" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">项目加载器方法</h1><p id="4ef9" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">ItemLoader类具有允许我们在项目字段中使用数据之前更改数据的方法。我们将在这里讨论一些重要的方法。有关详细信息，请参考文档。</p><p id="3fa7" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">如果我们看一下ItemLoader类，它有几个处理提取数据的函数。最常见的三种是<code class="fe oa ob oc od b">add_xpath()</code>、<code class="fe oa ob oc od b">add_css()</code>、<code class="fe oa ob oc od b">add_value()</code>。</p><p id="b17c" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">它们都接受一个项目字段名，然后接受一个xpath选择器、css选择器或字符串值。它还允许使用处理器来改变数据。</p><h2 id="6420" class="nb lj it bd lk nc nd dn lo ne nf dp ls mj ng nh lu mn ni nj lw mr nk nl ly iz bi translated">句法</h2><p id="dce5" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated"><code class="fe oa ob oc od b">add_xpath(field_name, xpath,*processors,**kwargs)</code></p><p id="6fb4" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><code class="fe oa ob oc od b">add_css(field_name,css, processors,**kwargs)</code></p><p id="773c" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><code class="fe oa ob oc od b">add_value(field_name,value,processors,**kwargs)</code></p><p id="1e54" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">ItemLoader的核心功能是通过输入处理器实现的。这就是为什么ItemLoader方法提供了指定它的选项。</p><p id="2ab8" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">您可以通过指定自己的输入处理器来更改提取的数据。现在，如果没有指定处理器，默认的处理器是。然后只返回提取数据的值。</p><p id="c347" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">现在输出处理器接受这个收集的内部列表。这可能会也可能不会被我们自己的输入处理器改变。这提供了要填充的新值。</p><p id="a5d1" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">为了用提取的数据填充条目字段，我们使用load_item()方法。一旦通过处理程序，这将填充“项目”字段。</p><p id="e10e" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">现在让我们通过一个简单的例子来看看这在实践中是如何工作的。</p><pre class="ks kt ku kv gt oh od oi oj aw ok bi"><span id="994c" class="nb lj it od b gy ol om l on oo">def parse(self,response):<br/>    l = ItemLoader(Product(), response)<br/>    l.add_xpath('Title', //*[@itemprop="name"][1]/text()')<br/>    return l.load_item()</span></pre><p id="1f6f" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">笔记</p><p id="f9da" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">1.我们用我们定义的项目<code class="fe oa ob oc od b">product()</code>和响应来定义我们的项目加载器</p><p id="b2cf" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">2.我们使用<code class="fe oa ob oc od b">add_xpath</code>方法指定条目字段标题和标题的xpath选择器。</p><p id="50f3" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">3.然后我们使用<code class="fe oa ob oc od b">load_item()</code>方法填充这个条目字段</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oq"><img src="../Images/d484978083a5ae7a8316935a5a2795ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*toe984upAAQ2mDDMgZTvPQ.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">来自Unsplash的Markus Spiske</p></figure><h1 id="3c3f" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">项目装入程序上下文</h1><p id="5bb8" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">在进入内置处理器之前。讨论项目加载器上下文很重要。这些是可以共享的键和值。我们创建的ItemLoader将已定义的项目/选择器/响应分配给loader_context。然后他们可以习惯于改变输入/输出处理器。</p><p id="855a" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">一些内置处理器可以使用它，了解这一点很重要。</p><p id="0ed5" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">处理器函数中的<code class="fe oa ob oc od b">loader_context</code>参数允许处理器共享数据。</p><p id="f0cc" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">一个简单的例子</p><pre class="ks kt ku kv gt oh od oi oj aw ok bi"><span id="9074" class="nb lj it od b gy ol om l on oo">def parse_length(text,loader_context):<br/>    unit = loader_context.get('unit','m')<br/>#length parsing code goes here</span><span id="d85d" class="nb lj it od b gy or om l on oo">return parse_length</span></pre><p id="7ee9" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">现在，您可以通过多种方式更改项目加载器上下文值。</p><ol class=""><li id="b789" class="nm nn it mc b md mw mg mx mj oe mn of mr og mv nr ns nt nu bi translated">修改当前活动的项目加载器上下文</li></ol><pre class="ks kt ku kv gt oh od oi oj aw ok bi"><span id="c525" class="nb lj it od b gy ol om l on oo">loader = ItemLoader(product)<br/>loader.context['unit'] = 'cm'</span></pre><p id="c98c" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">2.在项目加载器实例化时(作为关键字参数)</p><pre class="ks kt ku kv gt oh od oi oj aw ok bi"><span id="d714" class="nb lj it od b gy ol om l on oo">loader = ItemLoader(product, unit='cm')</span></pre><p id="2f24" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">3.关于输入/输出处理器的项目加载器声明，例如MapCompose</p><pre class="ks kt ku kv gt oh od oi oj aw ok bi"><span id="480d" class="nb lj it od b gy ol om l on oo">class ProductLoader(ItemLoader):<br/>    length_out = MapCompose(parse_length, unit='cm')</span></pre><p id="8465" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">ItemLoader上下文对于传递我们希望在处理器中使用的键和值非常有用。</p><h1 id="f7e2" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">内置处理器</h1><p id="0c4c" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">现在我们已经确定了项目加载器的基础。让我们来看看Scrapy提供给我们的一些样板文件。</p><p id="8055" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">在Scrapy代码库中，内置处理器的类在一个名为processes.py的单独文件中。我们必须导入它们才能使用它们。</p><pre class="ks kt ku kv gt oh od oi oj aw ok bi"><span id="b572" class="nb lj it od b gy ol om l on oo">from scrapy.loader.processors import BUILTIN PROCESSORS</span></pre><p id="d028" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">Scrapy提供了<code class="fe oa ob oc od b">Identity()</code>、<code class="fe oa ob oc od b">TakeFirst()</code>、<code class="fe oa ob oc od b">Join()</code>、<code class="fe oa ob oc od b">Compose()</code>、<code class="fe oa ob oc od b">MapCompose()</code>、<code class="fe oa ob oc od b">SelectJmes()</code>六个内置处理器。我们将带你经历前五个。</p><h2 id="26af" class="nb lj it bd lk nc nd dn lo ne nf dp ls mj ng nh lu mn ni nj lw mr nk nl ly iz bi translated">身份()</h2><p id="51e9" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated"><code class="fe oa ob oc od b">Identity()</code>是最简单的处理器，它返回值不变。</p><pre class="ks kt ku kv gt oh od oi oj aw ok bi"><span id="1e9d" class="nb lj it od b gy ol om l on oo">from scrapy.loader.processors import Identity<br/>proc = Identity()<br/>proc(['one','two','three'])</span></pre><p id="272b" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">输出:</p><pre class="ks kt ku kv gt oh od oi oj aw ok bi"><span id="8ff7" class="nb lj it od b gy ol om l on oo">['one,'two','three']</span></pre><p id="248b" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">这个内置处理器你已经不知不觉用上了。当在我们讨论的ItemLoader方法中没有指定处理器时，identity类实例被赋予变量default_input_processor和default_output_processor。这意味着如果我们不指定处理器，ItemLoader返回的值不变。</p><h2 id="1cbd" class="nb lj it bd lk nc nd dn lo ne nf dp ls mj ng nh lu mn ni nj lw mr nk nl ly iz bi translated">Takefirst()</h2><p id="4279" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated"><code class="fe oa ob oc od b">Takefirst()</code>从接收的值中返回第一个非空值。它被用作单值字段的输出处理器。</p><pre class="ks kt ku kv gt oh od oi oj aw ok bi"><span id="68f8" class="nb lj it od b gy ol om l on oo">from scrapy.loader.processors import TakeFirst<br/>proc = TakeFirst()<br/>proc(['', 'One','Two','Three'])</span></pre><p id="3fbf" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">输出:</p><pre class="ks kt ku kv gt oh od oi oj aw ok bi"><span id="60d6" class="nb lj it od b gy ol om l on oo">'one'</span></pre><h2 id="4204" class="nb lj it bd lk nc nd dn lo ne nf dp ls mj ng nh lu mn ni nj lw mr nk nl ly iz bi translated">加入()</h2><p id="f025" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated"><code class="fe oa ob oc od b">Join(separator=u’ ’)</code>返回连接在一起的值。分隔符可以用来在每一项之间放置一个表达式。默认为<code class="fe oa ob oc od b">u’’</code>。在下面的例子中，我们输入<code class="fe oa ob oc od b">&lt;br&gt;</code>。</p><pre class="ks kt ku kv gt oh od oi oj aw ok bi"><span id="8adf" class="nb lj it od b gy ol om l on oo">from scrapy.loader.processors import Join<br/>proc = Join() <br/>proc(['One, 'Two', 'Three'])<br/>proc2 = Join('&lt;br&gt;')<br/>proc2(['One', 'Two','Three'])</span></pre><p id="469a" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">输出:</p><pre class="ks kt ku kv gt oh od oi oj aw ok bi"><span id="25cd" class="nb lj it od b gy ol om l on oo">'one two three'</span><span id="1d8c" class="nb lj it od b gy or om l on oo">'one&lt;br&gt;two&lt;br&gt;three'</span></pre><h2 id="3a13" class="nb lj it bd lk nc nd dn lo ne nf dp ls mj ng nh lu mn ni nj lw mr nk nl ly iz bi translated">撰写()</h2><p id="c414" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated"><code class="fe oa ob oc od b">Compose()</code>获取一个输入值，并将其传递给参数中指定的函数。如果指定了另一个函数，结果会传递给该函数。这样一直持续下去，直到最后一个函数返回这个处理器的输出值。这个函数是我们用来改变输入值的。<code class="fe oa ob oc od b">Compose()</code>用作输入处理器。</p><p id="d201" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">语法是<code class="fe oa ob oc od b">compose(*functions,**default_loader_context)</code></p><p id="209a" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">现在每个函数可以接收一个<code class="fe oa ob oc od b">loader_context</code>参数。这将把活动加载器上下文键和值传递给处理器。现在，如果没有指定<code class="fe oa ob oc od b">loader_context</code>，则指定一个<code class="fe oa ob oc od b">default_loader_context</code>变量。这什么都不能通过。</p><pre class="ks kt ku kv gt oh od oi oj aw ok bi"><span id="d6dc" class="nb lj it od b gy ol om l on oo">from scrapy.loader.processor import Compose<br/>proc = Compose(Lambda v: v[0], str.upper)<br/>proc(['hello','world])</span></pre><p id="ea69" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">输出:</p><pre class="ks kt ku kv gt oh od oi oj aw ok bi"><span id="f594" class="nb lj it od b gy ol om l on oo">'HELLO'</span></pre><p id="39bc" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">笔记</p><ol class=""><li id="ab1f" class="nm nn it mc b md mw mg mx mj oe mn of mr og mv nr ns nt nu bi translated">组合内置处理器被调用</li><li id="6a22" class="nm nn it mc b md nv mg nw mj nx mn ny mr nz mv nr ns nt nu bi translated">Proc由我们用函数指定的compose类定义。这种情况下是lambda函数和string upper方法。每个列表项从小写字母变成大写字母。</li></ol><h2 id="af58" class="nb lj it bd lk nc nd dn lo ne nf dp ls mj ng nh lu mn ni nj lw mr nk nl ly iz bi translated">地图合成()</h2><p id="0723" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">很像<code class="fe oa ob oc od b">compose()</code>，但处理方式不同。输入值被迭代，第一个函数应用于每个元素。结果被连接起来以构造一个新的iterable。然后将它用于第二个函数。最后一个函数的输出值连接在一起，形成输出。</p><p id="785c" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">这为创建只处理单个值的函数提供了一种便捷的方式。当字符串对象从选择器中被提取出来时，它被用作输入处理器。</p><pre class="ks kt ku kv gt oh od oi oj aw ok bi"><span id="06e5" class="nb lj it od b gy ol om l on oo">def filter_world(x):<br/>    return None if x == 'world else x</span><span id="0795" class="nb lj it od b gy or om l on oo">from scrapy.loader.processors import MapCompose<br/>proc = MapCompose(filter_world, str.upper)<br/>proc(['hello', 'world', 'this','is', 'scrapy'])</span></pre><p id="42ba" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">输出</p><pre class="ks kt ku kv gt oh od oi oj aw ok bi"><span id="1746" class="nb lj it od b gy ol om l on oo">['HELLO, 'THIS', 'IS', 'SCRAPY']</span></pre><p id="a389" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">笔记。</p><p id="5310" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">1.我们创建了一个名为<code class="fe oa ob oc od b">filter_world</code>的简单函数</p><p id="fcba" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">2.<code class="fe oa ob oc od b">Mapcompose</code>被导入</p><p id="beed" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">3.过程被分配<code class="fe oa ob oc od b">MapCompose</code>。两个函数<code class="fe oa ob oc od b">filter_world</code>和一个类似函数的str方法。</p><p id="35cc" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">4.然后Proc被输入一个iterable，每一项都被传递给<code class="fe oa ob oc od b">filter_world</code>,然后应用一个string方法。</p><p id="4d89" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">5.注意查看第二个项目<code class="fe oa ob oc od b">‘world’</code>如何被输入到<code class="fe oa ob oc od b">filter_world</code>函数。这将返回none，该函数的输出将被忽略。现在可以在下一个项目中进行进一步的处理。正是这一点给了我们这样的输出，项目“世界”被过滤掉了。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi os"><img src="../Images/a6f0cb8f06bb03cfb50cb2a0e8fdf0e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vNEBOHpWXNWHo9wJYmofRg.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">来自Unsplash的大卫·拉托雷·罗梅罗</p></figure><h1 id="5bfa" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">声明自定义项目装入器处理器</h1><p id="89fd" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">我们可以像声明项目一样声明项目加载器处理器。也就是使用类定义语法。</p><pre class="ks kt ku kv gt oh od oi oj aw ok bi"><span id="d859" class="nb lj it od b gy ol om l on oo">from scrapy.loader import ItemLoader<br/>from scrapy.loader.processors import TakeFirst, MapCompose, Join</span><span id="26df" class="nb lj it od b gy or om l on oo">class ProductLoader(ItemLoader):<br/>    default_output_processor = Takefirst()<br/>    name_in = MapCompose(unicode.title)<br/>    name_out = Join()<br/>    price_in = MapCompose(unicode.strip)</span></pre><p id="d8e6" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">笔记。</p><ol class=""><li id="6d19" class="nm nn it mc b md mw mg mx mj oe mn of mr og mv nr ns nt nu bi translated">ProductLoader类扩展了ItemLoader类</li><li id="1a5f" class="nm nn it mc b md nv mg nw mj nx mn ny mr nz mv nr ns nt nu bi translated"><code class="fe oa ob oc od b">_in</code>后缀定义输入处理器，<code class="fe oa ob oc od b">_out</code>后缀声明输出处理器。我们将Item字段(在本例中为name)放在后缀之前，以定义我们希望流程处理哪个字段。</li><li id="b633" class="nm nn it mc b md nv mg nw mj nx mn ny mr nz mv nr ns nt nu bi translated"><code class="fe oa ob oc od b">name_in</code>分配一个<code class="fe oa ob oc od b">MapCompose</code>实例，并定义了函数unicode.title。这将用于名称项字段。</li><li id="bbe2" class="nm nn it mc b md nv mg nw mj nx mn ny mr nz mv nr ns nt nu bi translated"><code class="fe oa ob oc od b">name_out</code>被定义为<code class="fe oa ob oc od b">Join()</code>类实例</li><li id="8664" class="nm nn it mc b md nv mg nw mj nx mn ny mr nz mv nr ns nt nu bi translated"><code class="fe oa ob oc od b">price_in</code>被定义为一个<code class="fe oa ob oc od b">Mapcompose</code>实例。为价格项目字段定义函数<code class="fe oa ob oc od b">unicode.strip</code>。</li></ol><p id="666d" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">也可以在项目字段中声明处理器，让我们看看它是如何工作的。</p><pre class="ks kt ku kv gt oh od oi oj aw ok bi"><span id="b436" class="nb lj it od b gy ol om l on oo">import scrapy <br/>from scrapy.loader.processors import Join, MapCompose, Takefirst<br/>from w3lib.html import remove_tags</span><span id="bbb5" class="nb lj it od b gy or om l on oo">def filter_price(value):<br/>   if value.isdigit():<br/>       return value</span><span id="fe72" class="nb lj it od b gy or om l on oo">class Product(scrapy.Item):<br/>    name = scrapy.Field(input_processor=MapCompose(remove_tags), outputprocessor=Join(),)</span><span id="f36d" class="nb lj it od b gy or om l on oo">    price = scrapy.Field(input_processor=MapCompose(remove_tags,     filter_price), outprocessor=Takefirst(),)</span></pre><p id="5889" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">笔记</p><ol class=""><li id="841e" class="nm nn it mc b md mw mg mx mj oe mn of mr og mv nr ns nt nu bi translated">我们导入内置处理器和另一个移除标签的包。</li><li id="6551" class="nm nn it mc b md nv mg nw mj nx mn ny mr nz mv nr ns nt nu bi translated">我们定义了<code class="fe oa ob oc od b">filter_price</code>函数，如果输入是一个数字，它将被返回。</li><li id="befb" class="nm nn it mc b md nv mg nw mj nx mn ny mr nz mv nr ns nt nu bi translated">然后，我们通过扩展Scrapy来定义项目。项目分类。</li><li id="f83a" class="nm nn it mc b md nv mg nw mj nx mn ny mr nz mv nr ns nt nu bi translated">Name被定义为ItemField。我们指定应该使用哪些输入和输出处理器。</li><li id="7025" class="nm nn it mc b md nv mg nw mj nx mn ny mr nz mv nr ns nt nu bi translated">价格被定义为ItemField。我们指定应该使用哪些输入和输出处理器。</li><li id="4316" class="nm nn it mc b md nv mg nw mj nx mn ny mr nz mv nr ns nt nu bi translated">价格有两个被调用的函数，即<code class="fe oa ob oc od b">remove_tags</code>和<code class="fe oa ob oc od b">filter_price</code>。<code class="fe oa ob oc od b">filter_price</code>是我们定义的函数。</li></ol><p id="9a5d" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">现在，我们可以在蜘蛛的data.py文件中使用ItemLoader实例。注意，我们已经通过我们的spider中的items.py指定了我们的输入和输出处理器。</p><pre class="ks kt ku kv gt oh od oi oj aw ok bi"><span id="222f" class="nb lj it od b gy ol om l on oo">from scrapy.loader import ItemLoader<br/>    <br/>il = ItemLoader(item=Product())<br/>il.add_value('name',[u'Welcome to my', u'&lt;strong&gt;website&lt;/strong&gt;'])<br/>il.add_value('price', [u'&amp;euro;', u'&lt;span&gt;1000&lt;/span&gt;'])<br/>il.load_item()</span></pre><p id="8a0b" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">输出:</p><pre class="ks kt ku kv gt oh od oi oj aw ok bi"><span id="63fe" class="nb lj it od b gy ol om l on oo">{'name': u'Welcome to my website', 'price': u'1000'}</span></pre><p id="358b" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">注释<br/> 1。我们现在导入ItemLoader类<br/> 2。我们用创建的项目字段定义项目加载器<br/> 3。我们使用<code class="fe oa ob oc od b">add_value</code>方法，定义名称项字段，并传递一个包含字符串的列表。<br/> 4。我们使用<code class="fe oa ob oc od b">add_value</code>方法来定义价格项目字段，并传递另一个包含两个项目的列表。<br/> 5。当我们添加第一个值字符串时，它的标签被移除，两个项目被连接在一起<br/> 6。当我们添加第二个值时，第一项被忽略，因为它不是一个字符串，我们将数字变为1000。<br/> 7。<code class="fe oa ob oc od b">load_item()</code>方法给了我们一个条目字段名和修改后的数据的字典。这被输入到项目字段中。</p><p id="ff80" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">现在，输入和输出处理器的优先顺序是从1号到3号。</p><p id="04d0" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">1.项目加载器特定于字段的属性field_in和field_out</p><p id="628b" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">2.字段元数据(输入处理器和输出处理器关键字参数)</p><p id="53de" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">3.项目加载器默认<code class="fe oa ob oc od b">itemLoad.default_input_processor()</code>和<code class="fe oa ob oc od b">itemLoad.default_output_processor()</code></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/445d8bb9fa6d29bad977c76073aee375.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fbp97Od5okiKbXZhZNuwlw.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">来自Unsplash的Brian Kostiuk</p></figure><h1 id="f957" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">嵌套加载程序</h1><p id="12a3" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">当你想要抓取的信息在一个大的块中时，我们可以使用一个嵌套的加载器来提高可读性。它允许我们通过创建相对路径来缩短ItemLoader方法的路径。这可以让你的零碎项目更容易阅读，但不要过度使用它！</p><pre class="ks kt ku kv gt oh od oi oj aw ok bi"><span id="c0ff" class="nb lj it od b gy ol om l on oo">Loader = ItemLoader(item=Item())<br/>footer_loader = loader.nested_xpath('//footer/)<br/>footer_loader.add_xpath('social','a[@class="social"]/@href')<br/>loader.load_item()</span></pre><p id="4277" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">笔记</p><ol class=""><li id="48a8" class="nm nn it mc b md mw mg mx mj oe mn of mr og mv nr ns nt nu bi translated">我们像前面一样实例化一个Itemloader类</li><li id="4b78" class="nm nn it mc b md nv mg nw mj nx mn ny mr nz mv nr ns nt nu bi translated">我们为嵌套的加载程序定义了一个变量。我们指定了<code class="fe oa ob oc od b">nested_xpath()</code>方法，它接受一个选择器。在这种情况下我们给它<code class="fe oa ob oc od b">//footer/</code>。</li><li id="fa03" class="nm nn it mc b md nv mg nw mj nx mn ny mr nz mv nr ns nt nu bi translated">我们使用footer_loader来访问ItemLoader方法。这意味着我们不必多次指定页脚选择器。在这种情况下，我们调用<code class="fe oa ob oc od b">add_xpath()</code>方法，定义项目字段和我们想要的相对xpath选择器。这样我们就不必一直编写xpath选择器的<code class="fe oa ob oc od b">//footer/</code>部分</li></ol><p id="b07f" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">4.我们像以前一样调用<code class="fe oa ob oc od b">load_item()</code>方法将它输入到我们的项目字段social中。</p><h1 id="d87f" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">重用和扩展项目加载器</h1><p id="503d" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">我们可以使用继承的属性来扩展我们的项目加载器。这提供了无需创建单独的ItemLoader的功能。当网站改变时，这变得特别重要。这就是项目加载器的力量，当网站改变时，我们可以按比例增加。</p><p id="3bec" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">当需要不同的输入处理器时，我们倾向于扩展ItemLoader类。使用Item.py来定义输出处理器更加定制化。</p><pre class="ks kt ku kv gt oh od oi oj aw ok bi"><span id="015b" class="nb lj it od b gy ol om l on oo">from scrapy.loader.processors import MapCompose<br/>from myproduct.ItemLoaders import ProductLoader</span><span id="0cfd" class="nb lj it od b gy or om l on oo">def strip_dashes(x):<br/>    return x.strip('-')</span><span id="3f7e" class="nb lj it od b gy or om l on oo">class SiteSpecificLoader(ProductLoader):<br/>    name_in = MapCompose(strip_dashes, ProductLoader.name_in)</span></pre><p id="90ab" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">笔记</p><ol class=""><li id="d0fc" class="nm nn it mc b md mw mg mx mj oe mn of mr og mv nr ns nt nu bi translated">我们导入地图合成流程</li><li id="7679" class="nm nn it mc b md nv mg nw mj nx mn ny mr nz mv nr ns nt nu bi translated">我们还导入了一个<code class="fe oa ob oc od b">ProductLoader</code>，这是我们定义的ItemLoader</li></ol><p id="073c" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">3.然后我们创建一个函数<code class="fe oa ob oc od b">strip_dashes</code>来删除破折号</p><p id="6a35" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">4.然后我们在<code class="fe oa ob oc od b">SiteSpecificLoader</code>中扩展<code class="fe oa ob oc od b">ProductLoader</code></p><p id="c94e" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">5.我们将字段输入处理器的名称定义为<code class="fe oa ob oc od b">MapCompose</code>。我们传入<code class="fe oa ob oc od b">strip_dash</code>函数并调用ProductLoader <code class="fe oa ob oc od b">name_in</code>方法。</p><p id="5d78" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">然后我们可以在我们的<code class="fe oa ob oc od b">SiteSpecificLoader</code>中使用<code class="fe oa ob oc od b">name_in</code>输入处理器。与所有其他的<code class="fe oa ob oc od b">ProductLoader</code>样板。</p><p id="f409" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">Scrapy让你能够为不同的站点或数据扩展和重用你的项目加载器。</p><h1 id="7acd" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">摘要</h1><p id="4d00" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">在这里，您已经了解了项目和项目加载器之间的关系。我们已经展示了处理器如何习惯于能够解析我们提取的数据。ItemLoader方法是我们从网站获取数据进行更改的方式。我们已经讨论了scrapy拥有的不同内置处理器。这也让我们可以为项目字段指定内置或新的处理器。</p><h1 id="a3e9" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">相关文章</h1><div class="ot ou gp gr ov ow"><a rel="noopener follow" target="_blank" href="/scrapy-this-is-how-to-successfully-login-with-ease-ea980e2c5901"><div class="ox ab fo"><div class="oy ab oz cl cj pa"><h2 class="bd jd gy z fp pb fr fs pc fu fw jc bi translated">Scrapy:这就是如何轻松成功登录</h2><div class="pd l"><h3 class="bd b gy z fp pb fr fs pc fu fw dk translated">揭秘用Scrapy登录的过程。</h3></div><div class="pe l"><p class="bd b dl z fp pb fr fs pc fu fw dk translated">towardsdatascience.com</p></div></div><div class="pf l"><div class="pg l ph pi pj pf pk lb ow"/></div></div></a></div><div class="ot ou gp gr ov ow"><a rel="noopener follow" target="_blank" href="/how-to-download-files-using-python-ffbca63beb5c"><div class="ox ab fo"><div class="oy ab oz cl cj pa"><h2 class="bd jd gy z fp pb fr fs pc fu fw jc bi translated">如何使用Python下载文件</h2><div class="pd l"><h3 class="bd b gy z fp pb fr fs pc fu fw dk translated">了解如何使用Python下载web抓取项目中的文件</h3></div><div class="pe l"><p class="bd b dl z fp pb fr fs pc fu fw dk translated">towardsdatascience.com</p></div></div><div class="pf l"><div class="pl l ph pi pj pf pk lb ow"/></div></div></a></div><h1 id="e2ba" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">关于作者</h1><p id="a6e6" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">我是一名医学博士，对教学、python、技术和医疗保健有浓厚的兴趣。我在英国，我教在线临床教育以及运行网站<a class="ae lh" href="http://www.coding-medics.com./" rel="noopener ugc nofollow" target="_blank">www.coding-medics.com。</a></p><p id="ceb6" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">您可以通过asmith53@ed.ac.uk或twitter <a class="ae lh" href="https://twitter.com/AaronSm46722627" rel="noopener ugc nofollow" target="_blank">这里</a>联系我，欢迎所有意见和建议！如果你想谈论任何项目或合作，这将是伟大的。</p><p id="5026" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">如需更多技术/编码相关内容，请在此注册我的简讯<a class="ae lh" href="https://aaronsmith.substack.com/p/coming-soon?r=6yuie&amp;utm_campaign=post&amp;utm_medium=web&amp;utm_source=copy" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>