<html>
<head>
<title>Implementation of Queues from Two Stacks in Python: Data Structure</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中两个堆栈队列的实现:数据结构</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/implementation-of-queue-from-two-stacks-in-python-data-structure-c35da025eaf6?source=collection_archive---------60-----------------------#2020-06-07">https://towardsdatascience.com/implementation-of-queue-from-two-stacks-in-python-data-structure-c35da025eaf6?source=collection_archive---------60-----------------------#2020-06-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9522" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解堆栈和队列。然后使用两个堆栈实现一个队列。</h2></div><p id="6201" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">栈和队列都是列表。但是他们有不同的更严格的规则。本文将讨论堆栈和队列。首先，将有一个堆栈实现，然后是一个带有堆栈的队列。</p><h2 id="cab4" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">堆</h2><p id="d7a8" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">堆栈是具有后进先出(LIFO)规则的列表。最后进去的元素先出来。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/85097e72b47a122b463f657dfc8a4387.png" data-original-src="https://miro.medium.com/v2/resize:fit:574/format:webp/1*r7p6VCGtZxtBQDkGDDQGIA.png"/></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">来源:作者</p></figure><p id="d1be" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可能会想这有什么用。编辑器中的撤销操作就是一个很好的例子。当我们“撤销”时，它会撤销上一次操作。编译器使用堆栈检查匹配的括号。以下是堆栈所需的功能:</p><ol class=""><li id="7cee" class="mo mp it kk b kl km ko kp kr mq kv mr kz ms ld mt mu mv mw bi translated">空列表的初始化。</li><li id="ccf1" class="mo mp it kk b kl mx ko my kr mz kv na kz nb ld mt mu mv mw bi translated">向列表中添加元素。</li><li id="aec9" class="mo mp it kk b kl mx ko my kr mz kv na kz nb ld mt mu mv mw bi translated">从列表中弹出元素。</li><li id="1bb4" class="mo mp it kk b kl mx ko my kr mz kv na kz nb ld mt mu mv mw bi translated">检查列表是否为空。</li><li id="d4cd" class="mo mp it kk b kl mx ko my kr mz kv na kz nb ld mt mu mv mw bi translated">确定列表的顶部元素。</li><li id="f2ac" class="mo mp it kk b kl mx ko my kr mz kv na kz nb ld mt mu mv mw bi translated">拿到名单。</li></ol><p id="21d6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以上功能的 Python 实现:</p><pre class="md me mf mg gt nc nd ne nf aw ng bi"><span id="8832" class="le lf it nd b gy nh ni l nj nk">class Stack():<br/>    def __init__(self):<br/>        self.elements = []</span><span id="1098" class="le lf it nd b gy nl ni l nj nk">def push(self, element):<br/>        self.elements.append(element)</span><span id="7946" class="le lf it nd b gy nl ni l nj nk">def pop(self):<br/>        return self.elements.pop()</span><span id="89d2" class="le lf it nd b gy nl ni l nj nk">def is_empty(self):<br/>        return self.elements == []</span><span id="953d" class="le lf it nd b gy nl ni l nj nk">def peek():<br/>        if not self.elements.is_empty():<br/>            return self.elements[-1]</span><span id="a413" class="le lf it nd b gy nl ni l nj nk">def get_elements(self):<br/>        return self.elements</span></pre><h2 id="af4e" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">长队</h2><p id="a6e8" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">队列也是一个列表或容器。它遵循先进先出(FIFO)规则。一个很好的例子是在杂货店排队。先排队的人有机会先付钱后离开。当一个新来的人想排队时，她/他必须排在队伍的后面。队列有两个操作。入队和出队。其中 enqueue 表示添加列表或容器中的元素。出列意味着从列表底部删除一个元素。</p><p id="fbd6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下图清楚地显示了堆栈和队列的区别:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/7df67782e8f5e2b840175ef2f42af87b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*ov8kIBcJNTJ27V2Fm8C9Ww.png"/></div></figure><p id="e0ca" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用两个堆栈来实现一个队列。</p><ol class=""><li id="3d55" class="mo mp it kk b kl km ko kp kr mq kv mr kz ms ld mt mu mv mw bi translated">将 stack1 中的元素排队。</li><li id="dca4" class="mo mp it kk b kl mx ko my kr mz kv na kz nb ld mt mu mv mw bi translated">出列可能很棘手。因为 stack 从顶部移除了一个元素。但是 queue 从底部移除了一个元素。我们需要弹出 stack1 中的所有元素，并不断将它们添加到 stack2 中。因此，stack1 的底部元素将是 stack2 的顶部元素。现在，如果我们从 stack2 中弹出一个元素，我们就弹出了 stack1 的底部元素。这就是我们的出列操作。操作完成后，我们应该再次将元素放回 stack1 中。下面是代码的样子:</li></ol><pre class="md me mf mg gt nc nd ne nf aw ng bi"><span id="fe5e" class="le lf it nd b gy nh ni l nj nk">class Queue:<br/>    def __init__(self):<br/>        self.stack_1 = Stack()<br/>        self.stack_2 = Stack()</span><span id="e432" class="le lf it nd b gy nl ni l nj nk">def enqueue(self, item):<br/>        self.stack_1.push(item)</span><span id="440a" class="le lf it nd b gy nl ni l nj nk">def dequeue(self):<br/>        if not self.stack_1.is_empty():<br/>            while self.stack_1.size()&gt; 0:<br/>                self.stack_2.push(self.stack_1.pop())<br/>            res = self.stack_2.pop()<br/>            while self.stack_2.size()&gt;0:<br/>                self.stack_1.push(self.stack_2.pop())<br/>            return res</span></pre><p id="3008" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我想分享这个，因为它是学习算法和数据结构的一个很好的练习材料。</p><p id="0bfd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一篇关于使用排序算法解决一些问题的文章:</p><ol class=""><li id="f987" class="mo mp it kk b kl km ko kp kr mq kv mr kz ms ld mt mu mv mw bi translated"><a class="ae nn" rel="noopener" target="_blank" href="/find-the-intersection-of-two-sets-of-coordinates-and-sort-by-colors-using-python-oop-7785f47a93b3">求两组坐标的交集，按颜色对桶进行排序。</a></li></ol></div></div>    
</body>
</html>