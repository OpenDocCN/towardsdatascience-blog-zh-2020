<html>
<head>
<title>Scaling Machine Learning models using Tensorflow Serving &amp; Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Tensorflow Serving &amp; Kubernetes 扩展机器学习模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/scaling-machine-learning-models-using-tensorflow-serving-kubernetes-ed00d448c917?source=collection_archive---------28-----------------------#2020-05-28">https://towardsdatascience.com/scaling-machine-learning-models-using-tensorflow-serving-kubernetes-ed00d448c917?source=collection_archive---------28-----------------------#2020-05-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="59ae" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">将 ML 模型投入生产和规模的开发人员指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4f220423adaf9d7c853bc6cdde6527b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3SbRO6tOaXCGyr6oHrpw2w.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:<a class="ae kv" href="https://unsplash.com/@hharritt" rel="noopener ugc nofollow" target="_blank">哈里特</a>，转自<a class="ae kv" href="https://unsplash.com/photos/Ype9sdOPdYc" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="c267" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://www.tensorflow.org/tfx/guide/serving" rel="noopener ugc nofollow" target="_blank"> Tensorflow serving </a>是一个神奇的工具，可以将您的模型投入生产，从处理请求到有效地使用 GPU 处理多个模型。当请求数量增加，系统很难跟上请求时，问题就出现了。这就是 Kubernetes 可以帮助编排和扩展多个 docker 容器的地方。</p><h1 id="1181" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">大纲:</h1><ol class=""><li id="38f0" class="mk ml iq ky b kz mm lc mn lf mo lj mp ln mq lr mr ms mt mu bi translated">设置<strong class="ky ir">对接</strong></li><li id="3e0f" class="mk ml iq ky b kz mv lc mw lf mx lj my ln mz lr mr ms mt mu bi translated">获取<strong class="ky ir">型号</strong></li><li id="90da" class="mk ml iq ky b kz mv lc mw lf mx lj my ln mz lr mr ms mt mu bi translated"><strong class="ky ir">集装箱化</strong>模式</li><li id="d0a6" class="mk ml iq ky b kz mv lc mw lf mx lj my ln mz lr mr ms mt mu bi translated">设置谷歌云<strong class="ky ir">集群</strong></li><li id="f13c" class="mk ml iq ky b kz mv lc mw lf mx lj my ln mz lr mr ms mt mu bi translated"><strong class="ky ir">使用 Kubernetes 部署</strong>型号</li></ol><p id="8608" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们开始吧:</p><h1 id="f8e6" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">1.设置 Docker</h1><p id="e91c" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">Docker 是什么？— Docker 提供了在松散隔离的环境(称为容器)中打包和运行应用程序的能力。(<a class="ae kv" href="https://opensource.com/resources/what-docker" rel="noopener ugc nofollow" target="_blank">详情</a>)</p><p id="e989" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要安装<strong class="ky ir">docker 你可以在这里勾选<a class="ae kv" href="https://docs.docker.com/get-docker/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"/></a><strong class="ky ir"/>它支持多个平台。</strong></p><p id="776a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你使用的是 ubuntu，你可以使用:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="19d2" class="ni lt iq ne b gy nj nk l nl nm"><em class="nn"># Install docker community edition<br/></em>curl -fsSL <a class="ae kv" href="https://download.docker.com/linux/ubuntu/gpg" rel="noopener ugc nofollow" target="_blank">https://download.docker.com/linux/ubuntu/gpg</a> | sudo apt-key add -</span><span id="30fa" class="ni lt iq ne b gy no nk l nl nm">sudo add-apt-repository "deb [arch=amd64] <a class="ae kv" href="https://download.docker.com/linux/ubuntu" rel="noopener ugc nofollow" target="_blank">https://download.docker.com/linux/ubuntu</a> $(lsb_release -cs) stable"</span><span id="f122" class="ni lt iq ne b gy no nk l nl nm">sudo apt-get update<br/>sudo apt-get install -y docker-ce</span></pre><p id="0a1d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要在 Ubuntu 中使用 docker，我们通常需要添加前缀 sudo，但是如果你不想每次都添加 sudo，你可以这样做:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="b1f9" class="ni lt iq ne b gy nj nk l nl nm"><em class="nn"># Remove sudo access needed for docker<br/></em>sudo groupadd docker<br/>sudo gpasswd -a $USER docker</span></pre><p id="d742" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将需要一个<a class="ae kv" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> DockerHub </strong> </a>账户，以便以后我们可以推动我们的 docker 形象。如果您没有帐户，请创建一个帐户。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="ed4f" class="ni lt iq ne b gy nj nk l nl nm"><em class="nn"># Once your Dockerhub account is setup, login to docker<br/></em>docker login</span></pre><h1 id="cbc0" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">2.获取模型</h1><p id="5654" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated"><a class="ae kv" href="https://www.tensorflow.org/tfx/guide/serving" rel="noopener ugc nofollow" target="_blank"> TensorFlow serving </a>仅支持<a class="ae kv" href="https://www.tensorflow.org/tutorials/keras/save_and_load#savedmodel_format" rel="noopener ugc nofollow" target="_blank"> SavedModel </a>格式，因此我们需要将任何 TensorFlow 模型或 Keras 模型转换为 SavedModel 格式。这里有一个关于如何保存到保存的模型格式的例子<a class="ae kv" href="https://www.tensorflow.org/guide/saved_model" rel="noopener ugc nofollow" target="_blank">https://www.tensorflow.org/guide/saved_model</a></p><p id="0055" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为简单起见，我们将从 Tensorflow/models 下载一个预先训练好的 ResNet 保存模型。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="7de3" class="ni lt iq ne b gy nj nk l nl nm"><em class="nn"># Downloading ResNet saved models<br/></em>mkdir /tmp/myresnet</span><span id="6186" class="ni lt iq ne b gy no nk l nl nm">curl -s <a class="ae kv" href="https://storage.googleapis.com/download.tensorflow.org/models/official/20181001_resnet/savedmodels/resnet_v2_fp32_savedmodel_NHWC_jpg.tar.gz" rel="noopener ugc nofollow" target="_blank">https://storage.googleapis.com/download.tensorflow.org/models/official/20181001_resnet/savedmodels/resnet_v2_fp32_savedmodel_NHWC_jpg.tar.gz</a> | tar --strip-components=2 -C /tmp/myresnet -xvz</span></pre><h1 id="6c0d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">3.集装箱服务模式</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi np"><img src="../Images/35f47d3ddb8680410053fa94693c03ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*zRz7zI9AP3u657U6kO-rpw.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">原始来源:<a class="ae kv" href="https://tenor.com/view/whale-docker-container-gif-12376852" rel="noopener ugc nofollow" target="_blank">期限</a></p></figure><p id="c571" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们需要制作一个 Tensorflow 服务图像。幸运的是<a class="ae kv" href="https://hub.docker.com/r/tensorflow/serving/tags/" rel="noopener ugc nofollow" target="_blank"> Tensorflow 服务图片</a>已经在 Dockerhub 中建立并可用。它有 GPU 和 CPU 两个版本。让我们下载它。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="d454" class="ni lt iq ne b gy nj nk l nl nm"><em class="nn"># Downloading the CPU version</em><br/>docker pull tensorflow/serving:2.1.0</span><span id="a6b2" class="ni lt iq ne b gy no nk l nl nm"><em class="nn"># To download the GPU version you can just<br/># docker pull tensorflow/serving:2.1.0-gpu</em></span></pre><p id="d111" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nn">' tensor flow/serving:2 . 1 . 0 '</em>容器图像或任何其他 TF 服务图像的默认<a class="ae kv" href="https://docs.docker.com/engine/reference/builder/#entrypoint" rel="noopener ugc nofollow" target="_blank">入口点</a>为'<strong class="ky ir">/usr/bin/TF _ serving _ entry point . sh</strong>'。我们将创建自己的<em class="nn">TF _ serving _ entry point . sh</em>，我会在下面告诉你为什么:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">tf_serving_entrypoint.sh</p></figure><p id="ed85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的脚本运行 Tensorflow 服务，从'<strong class="ky ir"> /models/resnet/ </strong>'加载模型，为<a class="ae kv" href="https://www.grpc.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> gRPC </strong> </a> <strong class="ky ir">，</strong>打开端口 8500，为<strong class="ky ir"> REST-API </strong>打开端口 8501。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="b0f7" class="ni lt iq ne b gy nj nk l nl nm"><em class="nn"># Download the tf_serving_script.sh<br/></em>curl -s <a class="ae kv" href="https://gist.githubusercontent.com/bendangnuksung/67c59cdfb2889e2738abdf60f8290b1d/raw/918cfa09d6efcc200bb2d617859138fd9e7c2eb4/tf_serving_entrypoint.sh" rel="noopener ugc nofollow" target="_blank">https://gist.githubusercontent.com/bendangnuksung/67c59cdfb2889e2738abdf60f8290b1d/raw/918cfa09d6efcc200bb2d617859138fd9e7c2eb4/tf_serving_entrypoint.sh</a> --output tf_serving_entrypoint.sh</span><span id="8a5b" class="ni lt iq ne b gy no nk l nl nm"><em class="nn"># Make it executable<br/></em>chmod +x tf_serving_script.sh</span></pre><p id="1373" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">建议创建我们自己的服务脚本，因为您将可以控制<strong class="ky ir"> <em class="nn">模型名称</em> </strong>、<em class="nn"> </em> <strong class="ky ir">、端口 </strong>和<strong class="ky ir"> <em class="nn">模型路径</em> </strong>。如果您有多个模型，默认的“tf_serving_entrypoint.sh”将抛出一个错误。为了服务多个模型，您需要为您的多个模型创建一个<a class="ae kv" href="https://www.tensorflow.org/tfx/serving/serving_config#model_server_config_details" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir">models . config</strong></a>并更新您的脚本。您的服务模型看起来有点像这样:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="08b0" class="ni lt iq ne b gy nj nk l nl nm"><em class="nn"># Just an example of running TF serving with models.cofig<br/># tensorflow_model_server --port=8500 --rest_api_port=8501 <br/># --model_config_file=/path/to/models.config</em></span></pre><p id="8714" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要了解更多关于用 docker 上菜的 TF，请参考<a class="ae kv" href="https://www.tensorflow.org/tfx/serving/docker" rel="noopener ugc nofollow" target="_blank"> tfx/serving/docker </a>。</p><p id="b35d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将<strong class="ky ir"> RestNet 保存的模型</strong>和<strong class="ky ir"> tf_serving_script.sh </strong>移动到 docker 镜像中并运行:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="5427" class="ni lt iq ne b gy nj nk l nl nm"><em class="nn"># Run the tf/serving containerimage<br/></em>docker run -d --name=servingbase tensorflow/serving:2.1.0</span><span id="c223" class="ni lt iq ne b gy no nk l nl nm"><em class="nn"># copy the saved model<br/></em>docker cp /tmp/resnet/ servingbase:/models/</span><span id="9a1d" class="ni lt iq ne b gy no nk l nl nm"><em class="nn"># copy tf_serving_script.sh<br/></em>docker cp tf_serving_entrypoint.sh servingbase:/usr/bin/tf_serving_entrypoint.sh</span><span id="f22d" class="ni lt iq ne b gy no nk l nl nm"><em class="nn"># commit <br/></em>docker commit servingbase myresnet:latest</span><span id="5409" class="ni lt iq ne b gy no nk l nl nm"><em class="nn"># kill the container<br/></em>docker kill servingbase</span><span id="b819" class="ni lt iq ne b gy no nk l nl nm"><em class="nn"># running new created image<br/></em>docker run -d --name=myresnet -p 8500:8500 -p 8501:8501 myresnet:latest</span><span id="cf4e" class="ni lt iq ne b gy no nk l nl nm"><em class="nn"># list running container and see whether its running<br/></em>docker ps</span></pre><p id="00d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们测试一下码头工人是否响应我们的请求。将下载一个客户端脚本，使用<a class="ae kv" href="https://www.grpc.io" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> gRPC </strong> </a>和<strong class="ky ir"> RESTAPI </strong>进行推理。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="28a9" class="ni lt iq ne b gy nj nk l nl nm"><em class="nn"># Download the Restnet client script<br/></em>curl <a class="ae kv" href="https://gist.githubusercontent.com/bendangnuksung/8e94434a8c85308c2933e419ec29755a/raw/0a52618cdce47d16f2e71c900f2a1ee92063933f/resnet_client_restapi_grpc.py" rel="noopener ugc nofollow" target="_blank">https://gist.githubusercontent.com/bendangnuksung/8e94434a8c85308c2933e419ec29755a/raw/0a52618cdce47d16f2e71c900f2a1ee92063933f/resnet_client_restapi_grpc.py</a> --output <a class="ae kv" href="https://gist.github.com/bendangnuksung/8e94434a8c85308c2933e419ec29755a" rel="noopener ugc nofollow" target="_blank">resnet_client_restapi_grpc.py</a></span></pre><p id="2b5b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">测试客户端脚本</strong>:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="02d4" class="ni lt iq ne b gy nj nk l nl nm"><em class="nn"># Test using GRPC<br/></em>python <a class="ae kv" href="https://gist.github.com/bendangnuksung/8e94434a8c85308c2933e419ec29755a" rel="noopener ugc nofollow" target="_blank">resnet_client_restapi_grpc.py</a> -p 8500 -ip localhost</span><span id="7de1" class="ni lt iq ne b gy no nk l nl nm"><em class="nn"># Test using RESTAPI<br/></em>python resnet_client_restapi_grpc.py -p 8501 -ip localhost</span><span id="7416" class="ni lt iq ne b gy no nk l nl nm"><em class="nn"># We will see that GRPC has faster response time than RESTAPI<br/># Once its deployed in cloud the difference is much higher</em></span><span id="e5bd" class="ni lt iq ne b gy no nk l nl nm"><em class="nn"># Stop running container<br/></em>docker stop myresnet</span></pre><p id="392a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">将图像推送到</strong><a class="ae kv" href="https://hub.docker.com" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir">docker hub</strong></a><strong class="ky ir">:</strong></p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="ed89" class="ni lt iq ne b gy nj nk l nl nm"><em class="nn"># Push image to Dockerhub | replace </em><strong class="ne ir"><em class="nn">DOCKERHUB_USERNAME</em> </strong>with your<strong class="ne ir"> </strong>A/c name<br/>docker tag myresnet:latest <strong class="ne ir">DOCKERHUB_USERNAME</strong>/myresnet:latest<br/>docker push <strong class="ne ir">DOCKERHUB_USERNAME</strong>/myresnet:latest</span></pre><h1 id="4bf2" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">4.设置 Google 云集群</h1><p id="b88a" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">我们将使用<a class="ae kv" href="https://cloud.google.com" rel="noopener ugc nofollow" target="_blank">谷歌云平台(GCP) </a>，因为它提供 Kubernetes 引擎，并提供一年 300 美元的免费试用，这对我们来说是一个惊人的资源。您可以在这里 免费试用您的<a class="ae kv" href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwiLsZ27787pAhXazDgGHYj1BhMQFjAAegQICRAC&amp;url=https%3A%2F%2Fcloud.google.com%2Ffree&amp;usg=AOvVaw1o4_byaUt6R1U9GFwHeAd6" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">。您需要启用您的帐单来激活您的 300 美元免费试用。</strong></a></p><p id="7643" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">GCP 允许你使用<a class="ae kv" href="https://cloud.google.com/sdk/gcloud" rel="noopener ugc nofollow" target="_blank"> Gcloud SDK </a>通过 CLI 处理资源。<strong class="ky ir">为<a class="ae kv" href="https://cloud.google.com/sdk/docs/quickstart-debian-ubuntu" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir">Ubuntu</strong></a><a class="ae kv" href="https://cloud.google.com/sdk/docs/quickstart-macos" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir">Mac</strong></a>安装</strong> Gcloud SDK。</p><p id="7829" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://kubernetes.io/docs/reference/kubectl/overview/" rel="noopener ugc nofollow" target="_blank"> Kubectl </a>也需要控制 Kubernetes 集群。从<a class="ae kv" href="https://kubernetes.io/docs/tasks/tools/install-kubectl/" rel="noopener ugc nofollow" target="_blank">T21 这里 </a> <strong class="ky ir">安装 Kubectl。</strong></p><p id="2b2e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">设置 GCloud 项目并实例化集群</strong>:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="3c8c" class="ni lt iq ne b gy nj nk l nl nm"><em class="nn"># Proceed once Gcloud and Kubectl is installed</em></span><span id="017d" class="ni lt iq ne b gy no nk l nl nm"><em class="nn"># Gcloud login </em><br/>gcloud auth login</span><span id="8eca" class="ni lt iq ne b gy no nk l nl nm"><em class="nn"># Create unique Project name | Replace </em><strong class="ne ir"><em class="nn">USERNAME</em></strong><em class="nn"> with any unique name</em><br/>gcloud projects create <strong class="ne ir">USERNAME</strong>-servingtest-project</span><span id="7961" class="ni lt iq ne b gy no nk l nl nm"><em class="nn"># Set project<br/></em>gcloud config set project <strong class="ne ir">USERNAME</strong>-servingtest-project</span></pre><p id="21bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">激活 Kubernetes 引擎 API </strong>。<a class="ae kv" href="https://console.cloud.google.com/apis/api/container.googleapis.com/overview?project=USERNAME-servingtest-project" rel="noopener ugc nofollow" target="_blank">https://console . cloud . Google . com/APIs/API/container . Google APIs . com/overview？project =<strong class="ky ir">USERNAME</strong>-serving test-project</a>(将<strong class="ky ir"> </strong>链接中的<strong class="ky ir"> USERNAME </strong>替换为您之前提供的唯一名称)</p><p id="5a77" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">创建并连接集群:</strong></p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="c250" class="ni lt iq ne b gy nj nk l nl nm"><em class="nn"># Creating a cluster with 2 nodes</em><br/>gcloud beta container --project "<strong class="ne ir">USERNAME</strong>-servingtest-project" clusters create "cluster-1" --zone "us-central1-c" --disk-size "30" --num-nodes "2"</span><span id="9e56" class="ni lt iq ne b gy no nk l nl nm"><em class="nn"># You can change the zone and disk size. More Details at  </em><a class="ae kv" href="https://cloud.google.com/sdk/gcloud/reference/container/clusters/create" rel="noopener ugc nofollow" target="_blank"><em class="nn">https://cloud.google.com/sdk/gcloud/reference/container/clusters/create</em></a></span><span id="baaf" class="ni lt iq ne b gy no nk l nl nm"><em class="nn"># Connect to cluster</em><br/>gcloud container clusters get-credentials cluster-1 --zone us-central1-c --project <strong class="ne ir">USERNAME</strong>-servingtest-project</span><span id="a405" class="ni lt iq ne b gy no nk l nl nm"><em class="nn"># Check whether the 2 Nodes are ready:</em><br/>kubectl get nodes</span><span id="8384" class="ni lt iq ne b gy no nk l nl nm"><em class="nn"># Sample output: <br/></em># <em class="nn">NAME                STATUS   ROLES    AGE   VERSION<br/></em># <em class="nn">gke-cluster-1-...   Ready    &lt;none&gt;   74s   v1.14.10-gke.36<br/></em># <em class="nn">gke-cluster-1-...   Ready    &lt;none&gt;   75s   v1.14.10-gke.36</em></span></pre><h1 id="1040" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">5.使用 Kubernetes 部署模型</h1><p id="5dd7" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">什么是 Kubernetes？—它是一个容器编制器。你可以认为 Kubernetes 是一个很好的俄罗斯方块玩家，所以每当不同形状和大小的新容器进来时，Kubernetes 都会找到放置容器的最佳位置。</p><p id="de00" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">务必查看此<a class="ae kv" href="https://youtu.be/u8dW8DrcSmo?t=671" rel="noopener ugc nofollow" target="_blank">视频</a>以便更好地理解。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns nr l"/></div></figure><p id="5a0f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">分两个阶段使用 Kubernetes 部署容器模型:</p><ol class=""><li id="800f" class="mk ml iq ky b kz la lc ld lf nt lj nu ln nv lr mr ms mt mu bi translated"><strong class="ky ir">部署</strong>:部署负责保持一套<a class="ae kv" href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/" rel="noopener ugc nofollow" target="_blank">吊舱</a>运行。我们为 pod 定义了所需状态的列表，部署控制器将实际状态更改为所需状态。</li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="e5c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.<strong class="ky ir">服务</strong>:将运行在一组<a class="ae kv" href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/" rel="noopener ugc nofollow" target="_blank">pod</a>上的应用程序公开为网络服务的抽象方式。我们定义了一个状态列表，比如端口应该监听哪里或者应该监听哪个应用程序。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq nr l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">service.yaml</p></figure><p id="89c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">让我们下载这两个文件</strong>:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="fc92" class="ni lt iq ne b gy nj nk l nl nm"># Download deployment &amp; service yaml files<br/>curl <a class="ae kv" href="https://gist.githubusercontent.com/bendangnuksung/f1482aa9da7100bc3050616aaf503a2c/raw/7dc54db4ee1311c2ec54f0f4bd7e8a343d7fe053/deployment.yaml" rel="noopener ugc nofollow" target="_blank">https://gist.githubusercontent.com/bendangnuksung/f1482aa9da7100bc3050616aaf503a2c/raw/7dc54db4ee1311c2ec54f0f4bd7e8a343d7fe053/deployment.yaml</a>--output <a class="ae kv" href="https://gist.githubusercontent.com/bendangnuksung/f1482aa9da7100bc3050616aaf503a2c/raw/5634d69757aad3d392343bfbe15a85badcdf76c9/deployment.yaml" rel="noopener ugc nofollow" target="_blank">deployment.yaml</a></span><span id="fed4" class="ni lt iq ne b gy no nk l nl nm">curl <a class="ae kv" href="https://gist.githubusercontent.com/bendangnuksung/5f3edd5f16ea5bc4c2bc58a783b562c0/raw/f36856c612ceb1ac0958a88a67ec02da3d437ffe/service.yaml" rel="noopener ugc nofollow" target="_blank">https://gist.githubusercontent.com/bendangnuksung/5f3edd5f16ea5bc4c2bc58a783b562c0/raw/f36856c612ceb1ac0958a88a67ec02da3d437ffe/service.yaml</a> --output service.yaml</span></pre><p id="087c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将需要对'<strong class="ky ir"> deployment.yaml </strong>'进行更改</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="3fe3" class="ni lt iq ne b gy nj nk l nl nm"><em class="nn">line 16: Change bendang to Your Dockerhub account name<br/>from: image: bendang/myresnet:latest<br/>to  : image: </em><strong class="ne ir">DOCKERHUB_USERNAME</strong><em class="nn">/myresnet:latest</em></span></pre><p id="48f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">开始部署</strong>:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="42f7" class="ni lt iq ne b gy nj nk l nl nm"><strong class="ne ir">kubectl get deployment<br/></strong><em class="nn">#Output:No resources found in default namespace.</em></span><span id="3379" class="ni lt iq ne b gy no nk l nl nm"><strong class="ne ir">kubectl apply -f deployment.yaml<br/></strong><em class="nn">#Output: deployment.extensions/myresnet-deployment created</em></span><span id="d7e1" class="ni lt iq ne b gy no nk l nl nm"><em class="nn"># Wait until the depoyment is ready: 2/2</em></span><span id="fea3" class="ni lt iq ne b gy no nk l nl nm"><strong class="ne ir">kubectl get deployment</strong><br/><em class="nn">#Output: <br/># NAME                  READY   UP-TO-DATE   AVAILABLE   AGE<br/># myresnet-deployment   2/2     2            2           1m</em></span></pre><p id="6dd7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将把“<em class="nn"> myresnet:latest”映像加载到“deployment . YAML”</em>文件中定义的两个窗格中。</p><p id="2bf5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">启动服务</strong>:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="8fee" class="ni lt iq ne b gy nj nk l nl nm"><strong class="ne ir">kubectl get service<br/></strong><em class="nn"># output:<br/>#NAME         TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE<br/>#kubernetes   ClusterIP   10.7.240.1   &lt;none&gt;        443/TCP   28h</em></span><span id="8e9b" class="ni lt iq ne b gy no nk l nl nm"><strong class="ne ir">kubectl apply -f service.yaml<br/></strong><em class="nn">#output: service/myresnet-service created</em></span><span id="e8c4" class="ni lt iq ne b gy no nk l nl nm"><em class="nn"># wait until it allocate external IP for LoadBalancer</em></span><span id="f5ab" class="ni lt iq ne b gy no nk l nl nm"><strong class="ne ir">kubectl get service</strong><br/><em class="nn">#output<br/>#NAME         TYPE          CLUSTER-IP   EXTERNAL-IP     PORT(S)                         <br/>#kubernetes   ClusterIP     10.7.240.1   &lt;none&gt;          443/TCP                       <br/>#myresnet-s.  LoadBalancer  10.7.252.203 </em><strong class="ne ir"><em class="nn">35.192.46.666</em></strong><em class="nn">  8501 &amp; 8500</em></span></pre><p id="0ed7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">运行<em class="nn">‘service . YAML’</em>后，我们将获得一个外部 IP，在本例中，它是<strong class="ky ir"> <em class="nn"> 35.192.46.666。这个 IP 现在将成为我们的单一访问点，我们可以在这里调用我们的模型，所有的负载平衡都在内部处理。</em></strong></p><p id="6cc8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">测试:</strong></p><p id="9b0d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们仍将使用相同的脚本'<em class="nn">resnet _ client _ restapi _ grpc . py</em>'，唯一的变化是提供我们创建的服务的'<em class="nn">外部 IP </em>'。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="724c" class="ni lt iq ne b gy nj nk l nl nm"><em class="nn"># Test using GRPC <br/></em>python <a class="ae kv" href="https://gist.github.com/bendangnuksung/8e94434a8c85308c2933e419ec29755a" rel="noopener ugc nofollow" target="_blank">resnet_client_restapi_grpc.py</a> -p 8500 -ip <strong class="ne ir"><em class="nn">35.192.46.666</em></strong></span><span id="68d9" class="ni lt iq ne b gy no nk l nl nm"><em class="nn"># Test using RESTAPI<br/></em>python <a class="ae kv" href="https://gist.github.com/bendangnuksung/8e94434a8c85308c2933e419ec29755a" rel="noopener ugc nofollow" target="_blank">resnet_client_restapi_grpc.py</a> -p 8501 -ip <strong class="ne ir"><em class="nn">35.192.46.666</em></strong></span></pre></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><p id="0f3c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你有任何问题，请在下面的评论中告诉我。</p><p id="0caf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nn">敬请关注我下一篇关于</em> <strong class="ky ir"> <em class="nn">在谷歌云功能上部署机器学习模型</em> </strong> <em class="nn">。</em></p></div></div>    
</body>
</html>