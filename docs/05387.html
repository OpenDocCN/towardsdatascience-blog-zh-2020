<html>
<head>
<title>Dynamic Allocation of Data Types and Variables in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中数据类型和变量的动态分配</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/dynamic-allocation-of-data-types-and-variables-in-python-1e9d259149d2?source=collection_archive---------42-----------------------#2020-05-06">https://towardsdatascience.com/dynamic-allocation-of-data-types-and-variables-in-python-1e9d259149d2?source=collection_archive---------42-----------------------#2020-05-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="714a" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">数据科学/ Python编程语言</h2><div class=""/><div class=""><h2 id="1252" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">让我们看看如何在Python中动态分配数据类型和变量，同时遍历一个循环。</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/e4165f9b73ef10bf94b7996768f69397.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s7BDqcP_67bkBM5vNJR3pg.png"/></div></div></figure><p id="6f3f" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi lw translated">假设你有一个包含10个元素的列表(list_main)。你必须把它分成三部分。第一部分分配给list1，第二部分分配给list2，第三部分分配给list3。列表的这种划分或分割类似于K重交叉验证。对于外行来说，交叉验证是一个重新采样的过程，用来评估预测模型在实践中的准确性。在K-fold交叉验证中，数据集被分为训练数据(通常为80%)和测试数据(通常为20%，并将保持不可见的数据)。训练数据再次被分成k倍或分区，这又被认为是训练数据和验证数据。该模型将在训练数据上被训练，并且该模型的验证将使用验证数据来完成。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mf"><img src="../Images/312c5cb9fb764d9355a241c6df5a32bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S1mXEBFxFkKn70c5LpBUOw.png"/></div></div><p class="mg mh gj gh gi mi mj bd b be z dk translated"><a class="ae mk" href="https://commons.wikimedia.org/wiki/User:Gufosowa" rel="noopener ugc nofollow" target="_blank">古佛索瓦</a></p></figure><p id="c76e" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">下面的代码将列表分成3个分区或部分，并将每个部分的元素分配给一个列表。</p><pre class="kp kq kr ks gt ml mm mn mo aw mp bi"><span id="2d8a" class="mq mr iq mm b gy ms mt l mu mv">list_main = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]<br/>folds = 3<br/>section = int(len(list_main)/folds)<br/>start_index = 0<br/>end_index = 0<br/>counter = 1</span><span id="d083" class="mq mr iq mm b gy mw mt l mu mv">for i in range(folds):<br/>    if counter == 1:<br/>        end_index += section<br/>        list1 = list_main[start_index:end_index]<br/>        counter += 1<br/>    elif counter == folds:<br/>        list3 = list_main[end_index: ]<br/>        counter += 1<br/>    elif counter &lt; folds:<br/>        start_index = end_index<br/>        end_index += section<br/>        list2 = list_main[start_index:end_index]<br/>        counter += 1<br/>print(f'List1: {list1}')<br/>print(f'List2: {list2}')<br/>print(f'List3: {list3}')</span><span id="0580" class="mq mr iq mm b gy mw mt l mu mv">list1 = [1, 2, 3]<br/>list2 = [4, 5, 6]<br/>list3 = [7, 8, 9, 10]</span></pre><p id="bf3b" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">输出:</p><pre class="kp kq kr ks gt ml mm mn mo aw mp bi"><span id="5fb1" class="mq mr iq mm b gy ms mt l mu mv">List1: [1, 2, 3]<br/>List2: [4, 5, 6]<br/>List3: [7, 8, 9, 10]</span></pre><p id="3e3a" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">但是，代码不是通用的，更像是硬编码类型。例如，如果list_main的划分(折叠)数量增加到4，则需要另一个列表(list4)来存储列表元素。如果增加到6个，则总共需要6个列表。为了适应基于分区数量的变化，需要更改代码。具体来说，需要分配新的列表。然而，这导致了更多的复杂性和混乱。例如，如果folds=4，那么第二个分区和第三个分区在上面的代码中具有相同的条件(计数器&lt; folds).</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/03a6ce6ed0a070a52b26aafcd5dafe8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XSivcpTNn6Xz9ZWes-ooSw.png"/></div></div><p class="mg mh gj gh gi mi mj bd b be z dk translated">©iambipin</p></figure><p id="43ce" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">It would have been better if we write a generic code that can allocate lists as the number of folds increases or decreases. The globals() function in Python made the seemingly impossible job possible. It returns the global symbol table as a dictionary.</p><pre class="kp kq kr ks gt ml mm mn mo aw mp bi"><span id="4e01" class="mq mr iq mm b gy ms mt l mu mv">print(globals())</span><span id="c420" class="mq mr iq mm b gy mw mt l mu mv">{'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': &lt;_frozen_importlib_external.SourceFileLoader object at 0x02A8C2D0&gt;, '__spec__': None, '__annotations__': {}, '__builtins__': &lt;module 'builtins' (built-in)&gt;, '__file__': 'demo_ref_globals.py', '__cached__': None, 'x'_ {...}}</span></pre><p id="c190" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">The modified code:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="9186" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">The output:</p><pre class="kp kq kr ks gt ml mm mn mo aw mp bi"><span id="a1a2" class="mq mr iq mm b gy ms mt l mu mv">Enter the no. of folds: 5<br/>List 0: [1, 2]<br/>List 1: [3, 4]<br/>List 2: [5, 6]<br/>List 3: [7, 8]<br/>List 4: [9, 10]</span></pre><p id="604b" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">You can do this dynamic allocation(frankly speaking, I don’t know the appropriate term for the allotment of data types)with other data types like variables, tuple, set, etc. You can find the codes <a class="ae mk" href="https://github.com/pbipin/dynamic_allocation_lists.git" rel="noopener ugc nofollow" target="_blank">这里是</a>)。</p><p id="98b6" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">我们都在经历艰难时期。不确定性笼罩着未来。然而，每片乌云都有一线光明。疫情对地球的治愈程度超过了环保主义者的任何其他任务。所以我忍不住分享了我在WhatsApp上收到的朋友转发的这个很棒的迷因。我真的想感谢这个迷因的未知创造者，感谢他的创造力和对我们生活的世界的残酷现实的描绘。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mz"><img src="../Images/a7e657a3f5dcbabe4a865c9fd5f0a6a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FSUJRABz-uXv71UPdj-eTA.jpeg"/></div></div><p class="mg mh gj gh gi mi mj bd b be z dk translated">来源:互联网(来源不明)</p></figure><p id="1a06" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">当世界正一瘸一拐地走过一个流行病已经达到巨大规模的前所未有的时代时，我们人类别无选择，只能求助于社交距离(每当我们冒险外出寻找必需品时)并呆在家里。当你处于自我隔离状态时，提升你的技能，学习新的东西。希望你能学到新的东西。编码快乐！！！</p></div></div>    
</body>
</html>