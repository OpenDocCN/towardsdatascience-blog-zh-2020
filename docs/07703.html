<html>
<head>
<title>Multivariate Logistic Regression in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的多元逻辑回归</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/multivariate-logistic-regression-in-python-7c6255a286ec?source=collection_archive---------11-----------------------#2020-06-09">https://towardsdatascience.com/multivariate-logistic-regression-in-python-7c6255a286ec?source=collection_archive---------11-----------------------#2020-06-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="da8c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用于分类的机器学习技术</h2></div><p id="fc2a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你很可能一天用几十次机器学习，甚至都不知道。在谷歌上进行简单的网络搜索效果如此之好，是因为其背后的ML软件已经学会了计算出哪些页面应该被排名以及如何排名。同样，你也不用费力地阅读大量的垃圾邮件，因为你的电脑已经学会区分垃圾邮件和非垃圾邮件。</p><p id="43c7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">机器学习是分析大量数据的一种聪明的替代方法。根据执行的任务和输出的性质，您可以将机器学习模型分为三种类型:</p><ol class=""><li id="afa4" class="le lf it kk b kl km ko kp kr lg kv lh kz li ld lj lk ll lm bi translated"><strong class="kk iu">回归:</strong>待预测的输出变量为连续变量</li><li id="7334" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><strong class="kk iu">分类:</strong>待预测的输出变量为分类变量</li><li id="128f" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><strong class="kk iu">聚类:</strong>没有预先定义的标签概念分配给所形成的组/聚类。</li></ol><p id="a670" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">分类领域中的大量重要问题领域——监督机器学习的一个重要领域。尽管逻辑回归中有“回归”一词，但事实上，它是最基本的分类算法之一。与输出连续数值的线性回归不同，逻辑回归使用逻辑sigmoid函数来转换其输出，以返回一个概率值，然后可以将该概率值映射到两个或多个离散类。</p><h2 id="7e48" class="ls lt it bd lu lv lw dn lx ly lz dp ma kr mb mc md kv me mf mg kz mh mi mj mk bi translated"><strong class="ak">逻辑回归的类型:</strong></h2><ol class=""><li id="2fa9" class="le lf it kk b kl ml ko mm kr mn kv mo kz mp ld lj lk ll lm bi translated">二进制(对/错，是/否)</li><li id="3cb0" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated">多类(羊、猫、狗)</li><li id="6ff7" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated">序数(工作满意度——不满意、满意、高度满意)</li></ol><p id="6e0b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们开始构建多元逻辑回归模型之前，我们需要熟悉一些概念前提。</p><h1 id="7ded" class="mq lt it bd lu mr ms mt lx mu mv mw ma jz mx ka md kc my kd mg kf mz kg mj na bi translated"><strong class="ak">乙状结肠功能</strong></h1><p id="d0ae" class="pw-post-body-paragraph ki kj it kk b kl ml ju kn ko mm jx kq kr nb kt ku kv nc kx ky kz nd lb lc ld im bi translated">前面我们谈到了将值映射到概率。这可以通过调用sigmoid函数来实现，该函数会将任何实数值映射到0和1之间的另一个值。机器学习使用这个函数将预测映射到概率。</p><p id="fd67" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">数学上，</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/c39f17a297ce6c77fde2e525332a7211.png" data-original-src="https://miro.medium.com/v2/resize:fit:674/format:webp/1*zAZQNBM8LYoaN3muszsilQ.png"/></div></figure><p id="90dc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其中，f(x)= 0和1之间的输出(概率估计值)</p><p id="9e0d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从图形上看，</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/3f849109130cda0d2a607f8443597243.png" data-original-src="https://miro.medium.com/v2/resize:fit:630/format:webp/1*K4YU1l4nRQSGsm6MkEqsSg.jpeg"/></div></figure><p id="f5b6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">代码:</p><pre class="nf ng nh ni gt nn no np nq aw nr bi"><span id="34cb" class="ls lt it no b gy ns nt l nu nv"><strong class="no iu">def</strong> sigmoid(z):<br/>  <strong class="no iu">return</strong> 1.0 / (1 + np.exp(-z))</span></pre><h1 id="1f81" class="mq lt it bd lu mr ms mt lx mu mv mw ma jz mx ka md kc my kd mg kf mz kg mj na bi translated"><strong class="ak">决定边界</strong></h1><p id="9625" class="pw-post-body-paragraph ki kj it kk b kl ml ju kn ko mm jx kq kr nb kt ku kv nc kx ky kz nd lb lc ld im bi translated">为了更好地理解逻辑回归假设函数所计算的内容，我们需要知道一个叫做“决策边界”的概念。我们使用的预测函数将返回一个介于0和1之间的概率分数。为了将这个分数映射到一个离散的类(正/负，真/假)，我们选择一个阈值，比如0.5，高于这个阈值，我们将值分类为类1，低于这个阈值，值将属于类2。</p><p id="79d3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，假设预测函数返回值0.8，这将被分类为真/正(因为它高于选定的阈值)。另一方面，值0.3将被归类为假/负。在处理多元逻辑回归时，我们选择预测概率最高的类。</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/7c3edead94f2b40f5520da6b6369fa39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/format:webp/1*vCexDryHfBmDDbpPOWd0QQ.png"/></div><p class="nx ny gj gh gi nz oa bd b be z dk translated">来源:<a class="ae ob" href="https://ml-cheatsheet.readthedocs.io/en/latest/logistic_regression.html#sigmoid-activation" rel="noopener ugc nofollow" target="_blank">https://ml-cheat sheet . readthedocs . io/en/latest/logistic _ regression . html # sigmoid-activation</a></p></figure><h1 id="0088" class="mq lt it bd lu mr ms mt lx mu mv mw ma jz mx ka md kc my kd mg kf mz kg mj na bi translated"><strong class="ak">赔率和对数赔率</strong></h1><p id="34d5" class="pw-post-body-paragraph ki kj it kk b kl ml ju kn ko mm jx kq kr nb kt ku kv nc kx ky kz nd lb lc ld im bi translated">逻辑回归使用的是概率而不是比例。几率简单地计算为两种可能结果的比例之比。设p是一个结果的比例，那么1-p就是第二个结果的比例。</p><p id="ef18" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">数学上，</p><p id="3065" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">赔率= p/1-p</p><p id="9f04" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">逻辑回归的统计模型是</p><p id="5234" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">log (p/1-p) = β0 + β1x</p><h1 id="ca4e" class="mq lt it bd lu mr ms mt lx mu mv mw ma jz mx ka md kc my kd mg kf mz kg mj na bi translated"><strong class="ak">多元逻辑回归</strong></h1><p id="3845" class="pw-post-body-paragraph ki kj it kk b kl ml ju kn ko mm jx kq kr nb kt ku kv nc kx ky kz nd lb lc ld im bi translated">为了理解多变量逻辑回归的工作原理，我们将考虑一个在线教育平台的问题陈述，在该平台上，我们将查看帮助我们选择最有希望的潜在客户的因素，即最有可能转化为付费客户的潜在客户。</p><p id="dee7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="oc">注:</em> </strong> <em class="oc">请按照下面给定的链接(GitHub Repo)查找数据集、数据字典和详细的解决这个问题的语句。</em></p><div class="od oe gp gr of og"><a href="https://github.com/sowmya20/LeadConversion_LogReg" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">sowmya20/LeadConversion_LogReg</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">在GitHub上创建一个帐户，为sowmya20/LeadConversion_LogReg开发做贡献。</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">github.com</p></div></div><div class="op l"><div class="oq l or os ot op ou nk og"/></div></div></a></div><p id="3d57" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">数据清理&amp;准备</strong></p><p id="9558" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦加载了必要的库和数据集，让我们使用head()命令来看看前几个条目。</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="ow ox di oy bf oz"><div class="gh gi ov"><img src="../Images/a285100b13b16026310fbce80eedf991.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ivJpAAiwcnMYGPb11ywe1g.png"/></div></div></figure><p id="74f9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">shape命令告诉我们数据集总共有9240个数据点和37列。下面列出了该数据集中的列名:</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="ow ox di oy bf oz"><div class="gh gi pa"><img src="../Images/dbc5c2c49f780ba7bd39abf1c7fb5989.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wSvcWESCIrWSzJyeolxyJw.png"/></div></div></figure><p id="f4e5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如您所看到的，列出的大多数特性变量都非常直观。请查阅数据字典，以便更好地理解它们。</p><p id="6563" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">进一步的分析揭示了数据集中分类变量的存在，我们需要为其创建虚拟变量。在此之前，我们处理数据集以删除空值列和行以及我们认为对该分析不必要的变量(例如，城市、国家)。快速检查保留行的百分比告诉我们69%的行已被保留，这看起来足够好了。</p><p id="9710" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">测试列车拆分</strong></p><p id="04e7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此数据集的目标变量是“Converted ”,它告诉我们过去的销售线索是否被转换，其中1表示它被转换，0表示它没有被转换。</p><p id="ee90" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">导入test_train_split库，对数据集进行70%训练和30%测试分割。</p><p id="e9a0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">数据集中很少有数值变量具有不同的比例，因此使用最小最大比例缩放器缩放这些变量。变量将以这样的方式缩放，即使用数据中的最大值和最小值，所有值都位于0和1之间。</p><p id="a03e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">模型建立</strong></p><p id="20ca" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">转到模型构建部分，我们看到这个数据集中有许多我们无法处理的变量。因此，我们将使用RFE从该池中选择一小部分要素。下面是相同的代码:</p><pre class="nf ng nh ni gt nn no np nq aw nr bi"><span id="d487" class="ls lt it no b gy ns nt l nu nv"># Import 'LogisticRegression' and create a LogisticRegression object</span><span id="1033" class="ls lt it no b gy pb nt l nu nv">from sklearn.linear_model import LogisticRegression<br/>logreg = LogisticRegression()</span><span id="9dab" class="ls lt it no b gy pb nt l nu nv"># Import RFE and select 15 variables</span><span id="bf8b" class="ls lt it no b gy pb nt l nu nv">from sklearn.feature_selection import RFE<br/>rfe = RFE(logreg, 15)             <br/>rfe = rfe.fit(X_train, y_train)</span></pre><p id="6632" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们现在将使用statsmodels来创建基于p值和Vif的逻辑回归模型。首先，我们将在添加一个常数后在训练集上创建一个模型，并输出摘要。这是广义模型回归结果的样子:</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="ow ox di oy bf oz"><div class="gh gi pc"><img src="../Images/7a89d17108092feea01ae8dbbf0e21b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QTrFY8nawJrwE2KGp6cIdg.png"/></div></div></figure><p id="2383" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还将以类似的方式计算所有要素的VIF，并删除具有高p值和高VIF的变量。在用新的特征集重新拟合模型之后，我们将再次检查p值和Vif所在的范围。如果合适，下一步我们将继续进行模型评估。</p><p id="b61e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">车型评测</strong></p><p id="4c34" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们现在将预测训练集上的概率，并创建一个包含实际转换标志和模型预测的概率的新数据帧。添加一个列来捕获条件等于1(如果支付概率的值大于0.5)或0的预测值。</p><p id="09f1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在开始评估模型之前，需要熟悉一些重要的概念:</p><p id="fd46" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">混乱矩阵</strong></p><p id="69b2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将分类准确度定义为正确预测与总预测的比率。这种方法的一个主要问题是，它常常隐藏了您可能需要更好地理解模型性能的细节。一个很有可能遇到这个问题的例子是当你处理一个超过两个类的数据时。你可以达到85%的准确率，但是你不知道这是因为你的模型忽略了一些类还是所有的类都预测的一样好。</p><blockquote class="pd pe pf"><p id="fcd8" class="ki kj oc kk b kl km ju kn ko kp jx kq pg ks kt ku ph kw kx ky pi la lb lc ld im bi translated"><strong class="kk iu"> <em class="it">混乱矩阵解决了这个问题。它告诉你你的模型在做预测时被混淆的确切次数。</em>T9】</strong></p></blockquote><p id="71ad" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它是对分类模型预测结果的总结。</p><p id="a16f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在两类问题中，我们通过将事件行指定为“正”并将非事件行指定为“负”来构建混淆矩阵。预测的事件列被指定为“真”，非事件列被指定为“假”。</p><p id="7c41" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该矩阵将由以下要素组成:</p><p id="7e76" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">(I)真阳性——用于正确预测的事件值</p><p id="df82" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">(ii)真阴性-对于正确预测的无事件值</p><p id="5039" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">(iii)假阳性——错误预测的事件值</p><p id="b9ea" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">(iv)假阴性——错误预测的无事件值</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/b783f5fa52be43ba0303bf8be5b94e99.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/format:webp/1*UH4o9Wkxs7IAaucmADGnjA.png"/></div></figure><p id="1a99" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从混淆矩阵中得出的一些基本性能指标有:</p><p id="6ae6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">(a) <strong class="kk iu">灵敏度:</strong>灵敏度(SN)的计算方法为正确的阳性预测数除以阳性总数。它也被称为回忆(REC)或真阳性率(TPR)。</p><p id="8512" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">数学上，</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/84e80259c2d83b2aa1410dd16f016e02.png" data-original-src="https://miro.medium.com/v2/resize:fit:280/format:webp/1*P1_t3hokwpuUaVaxb5-YCQ.png"/></div></figure><p id="6156" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">(b) <strong class="kk iu">特异性:</strong>特异性(SP)计算为正确阴性预测数除以阴性总数。它也被称为真实负利率(TNR)。</p><p id="ca3a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">数学上，</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/a92ae64817295c91f461a5ec74da09c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:228/format:webp/1*pkxiG3htDRMpGIcCr3A36A.png"/></div></figure><p id="f2a3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">(c) <strong class="kk iu">精度:</strong>精度(PREC)的计算方法是正确的肯定预测数除以肯定预测总数。它也被称为阳性预测值(PPV)</p><p id="a934" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">数学上，</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/0ec3ea02d2c0fced2467a7fe9f9f9a6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:282/format:webp/1*MHAuvpT7ncGKCOsv_6DjBg.png"/></div></figure><p id="c4db" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">(d) <strong class="kk iu">回忆:</strong>这是我们正确预测的所有现有阳性的分数。</p><p id="898f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">数学上，</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/ef1c0d05e9fa5d9e7813baa30c5ae0d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:280/format:webp/1*HZtk5Q0cyYIrA8trcbWYsQ.png"/></div></figure><p id="505a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将使用上述矩阵和指标来评估模型。0.5是随机选择的值，用于测试模型性能。我们需要优化阈值以获得更好的结果，我们将通过绘制和分析ROC曲线来做到这一点。</p><p id="c33f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">接收器工作特性曲线</strong>基本上是位于0和1之间的多个阈值的假阳性率和真阳性率之间的曲线。</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/b30163c4c4b2911e33ad2955b0afd884.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*T_bU3aygL79Z9z8P0rseQw.png"/></div></figure><p id="1b30" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"><em class="oc">ROC曲线帮助我们比较具有不同阈值的不同模型的曲线，而AUC(曲线下面积)为我们提供了模型技巧的总结。</em>T13】</strong></p><p id="fd63" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这里，AUC是0.86，这似乎很好。为了找到最佳分界点，让我们也检查不同概率分界点下模型的灵敏度和特异性，并绘制相同的图。</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div class="gh gi po"><img src="../Images/b3cc7d0b4edaadd3b935454f793137f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/1*xY7WaZudfDco3-feFUBN8g.png"/></div></figure><p id="5ec1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在0.42处，三个指标的曲线似乎相交，因此我们将选择它作为临界值。(您可能希望再次使用这一点来计算指标)我们将按照相同的方法对测试集进行预测。</p><p id="195e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">精确召回权衡</strong></p><p id="bb81" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在建立分类模型时，我们需要同时考虑精度和召回率。牺牲一个值来增加另一个值总是可能的(侧重于召回的模型/侧重于精度的模型)。在为这两个指标选择最佳值时，我们应该始终牢记我们要解决的问题类型。</p><p id="e7a9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们检查一下我们选择的临界值(即0.42)的权衡。</p><figure class="nf ng nh ni gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="ow ox di oy bf oz"><div class="gh gi pp"><img src="../Images/5790f2bd19ca5cb3a7caa824c2b12027.png" data-original-src="https://miro.medium.com/v2/resize:fit:1114/format:webp/1*7xFAfvx681X5gM6dw7omKg.png"/></div></div></figure><p id="01c9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">权衡曲线和指标似乎表明我们选择的截止点是最佳的。因此，我们将在测试集上运行最后一次预测，并确认指标。</p><pre class="nf ng nh ni gt nn no np nq aw nr bi"><span id="95ce" class="ls lt it no b gy ns nt l nu nv"># Let's check the overall accuracy</span><span id="e8b2" class="ls lt it no b gy pb nt l nu nv">metrics.accuracy_score(y_pred_final['Converted'], y_pred_final.final_predicted)</span><span id="9cc3" class="ls lt it no b gy pb nt l nu nv">TP = confusion2[1,1] # true positive <br/>TN = confusion2[0,0] # true negatives<br/>FP = confusion2[0,1] # false positives<br/>FN = confusion2[1,0] # false negatives</span><span id="ed4e" class="ls lt it no b gy pb nt l nu nv"># Calculate Precision</span><span id="df9b" class="ls lt it no b gy pb nt l nu nv">TP/(TP+FP)</span><span id="9f81" class="ls lt it no b gy pb nt l nu nv"># Calculate Recall</span><span id="ba6a" class="ls lt it no b gy pb nt l nu nv">TP/(TP+FN)</span></pre><p id="2986" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">度量标准似乎适用于测试数据。看起来我们已经创建了一个不错的模型，因为测试和训练数据集的指标都不错。</p><p id="e0da" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，您已经熟悉了使用Python构建和评估逻辑回归模型的基础知识。通常，这是一种简单的方法:</p><p id="c4d9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">(i) <strong class="kk iu">导入</strong>必要的包和库</p><p id="24d7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">(二)<strong class="kk iu">数据</strong>清洗、转换</p><p id="74cf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">(三)<strong class="kk iu">分类</strong>用现有数据创建和训练模型</p><p id="5196" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">(四)<strong class="kk iu">评估</strong>并检查模型性能</p><p id="2833" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">(v) <strong class="kk iu">对测试集进行预测</strong></p></div></div>    
</body>
</html>