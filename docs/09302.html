<html>
<head>
<title>An Introduction to Making Dynamic and Interactive Plots with D3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 D3 制作动态交互式图形的介绍</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/an-introduction-to-making-dynamic-and-interactive-plots-with-d3-a9e859413c5a?source=collection_archive---------22-----------------------#2020-07-03">https://towardsdatascience.com/an-introduction-to-making-dynamic-and-interactive-plots-with-d3-a9e859413c5a?source=collection_archive---------22-----------------------#2020-07-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0fd9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用 D3.js 让您的科学数据变得生动</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a86e3c7c7bc0b57cc6ff1afbe083c342.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5ZTNYszuanockkyQ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@chuttersnap?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> chuttersnap </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="c91b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我一直对学习如何使用 D3.js 犹豫不决。它似乎总是比其他库(如<code class="fe lv lw lx ly b">matplotlib</code>)更不直观，我已经写了很多关于它的文章。然而，在这里，我发现自己正在编写一个关于在 D3 中制作绘图的教程——如果你正在开发一个网站或 web 应用程序，并且想要动态和交互式的数据可视化，熟悉这个库可能会很有用。在本文中，我收集了许多反复试验的结果，希望它既能作为参考，又能帮助您在这个过程中避免一些简单的初学者错误。本文的目标是再现我早期作品中的样本吸光度图:</p><div class="lz ma gp gr mb mc"><a rel="noopener follow" target="_blank" href="/an-introduction-to-making-scientific-publication-plots-with-python-ea19dfa7f51e"><div class="md ab fo"><div class="me ab mf cl cj mg"><h2 class="bd iu gy z fp mh fr fs mi fu fw is bi translated">用 Python 制作科学出版物图简介</h2><div class="mj l"><h3 class="bd b gy z fp mh fr fs mi fu fw dk translated">介绍如何使用 Python 为科学出版物绘制数据</h3></div><div class="mk l"><p class="bd b dl z fp mh fr fs mi fu fw dk translated">towardsdatascience.com</p></div></div><div class="ml l"><div class="mm l mn mo mp ml mq ks mc"/></div></div></a></div><p id="9c67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们开始之前，我想先退一步。我以前在培养基方面的很多工作都是面向实验科学家的，因为这是我自己的个人背景。说到这一人群，我相信将这一新工具(D3)添加到您的工具箱将有助于您使您的数据变得生动，并且能够接触到比通常仅通过共享您发布的期刊文章更广泛的受众。所以，事不宜迟，我们开始吧。作为免责声明，对 JavaScript、HTML 和 CSS 的基本理解肯定会对读者有所帮助。</p><h1 id="804c" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated"><strong class="ak">创建我们的文件</strong></h1><p id="80af" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">首先，我们需要创建 3 个文件(将它们都放在计算机上的同一个文件夹中):</p><ol class=""><li id="331c" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated"><code class="fe lv lw lx ly b">index.html</code> —这是主 HTML 文件，我们将能够在我们的网络浏览器中打开它来查看我们的可视化</li><li id="6aec" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated"><code class="fe lv lw lx ly b">style.css</code>——我们将使用 CSS 样式化我们可视化中的一些元素</li><li id="b186" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated"><code class="fe lv lw lx ly b">plot.js</code>——这将是我们项目的主力，包含我们绘制地图所需的所有 D3 代码</li></ol><h1 id="0f43" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated"><strong class="ak">设置我们的 HTML 文件</strong></h1><p id="f709" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">我们的<code class="fe lv lw lx ly b">index.html</code>不会包含太多内容，因为我们将使用 JavaScript 操作文档。我们从任何 HTML 文件的一般框架代码开始。</p><pre class="kj kk kl km gt oc ly od oe aw of bi"><span id="db7b" class="og ms it ly b gy oh oi l oj ok">&lt;!DOCTYPE html&gt;</span><span id="158a" class="og ms it ly b gy ol oi l oj ok">&lt;html&gt;<br/><br/>&lt;/html&gt;</span></pre><p id="427e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的<code class="fe lv lw lx ly b">html</code>标签中，我们将创建两个部分:<code class="fe lv lw lx ly b">head</code>和<code class="fe lv lw lx ly b">body</code>。在<code class="fe lv lw lx ly b">head</code>部分，我们将添加对 CSS 样式表的引用，以及到 D3.js 的链接，这样我们以后就可以使用所有的模块。</p><pre class="kj kk kl km gt oc ly od oe aw of bi"><span id="2dd2" class="og ms it ly b gy oh oi l oj ok"><strong class="ly iu">&lt;!--Import D3 and our CSS in the head section--&gt;</strong></span><span id="7835" class="og ms it ly b gy ol oi l oj ok">&lt;head&gt;<br/>  &lt;link <em class="om">rel</em>='stylesheet' <em class="om">href</em>='./style.css'&gt;<br/>  &lt;script <em class="om">src</em>="https://d3js.org/d3.v5.min.js"&gt;&lt;/script&gt;<br/>&lt;/head&gt;</span></pre><p id="d31d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，在我们的 HTML 文件的<code class="fe lv lw lx ly b">body</code>中，我们将创建一个名为<code class="fe lv lw lx ly b">plot_area</code>的<code class="fe lv lw lx ly b">div</code>，我们将用我们的<code class="fe lv lw lx ly b">plot.js</code>文件操作它，我们也将把它导入到当前文件中。</p><pre class="kj kk kl km gt oc ly od oe aw of bi"><span id="1d2a" class="og ms it ly b gy oh oi l oj ok"><strong class="ly iu">&lt;!--Create div for our plot and import plot.js--&gt;</strong></span><span id="d9d2" class="og ms it ly b gy ol oi l oj ok">&lt;body&gt;<br/>  &lt;div <em class="om">id</em>='plot_area'&gt;&lt;/div&gt;<br/>  &lt;script <em class="om">src</em>='./plot.js'&gt;&lt;/script&gt;<br/>&lt;/body&gt;</span></pre><p id="2a35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经完成了对<code class="fe lv lw lx ly b">index.html</code>的所有编辑——现在让我们继续我们可视化的主要工作，JavaScript。</p><h1 id="fe35" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated"><strong class="ak">使用 D3.js </strong></h1><p id="fc4d" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">D3 是一个 JavaScript 库，是数据驱动文档的缩写，提供了一系列使用和操作 SVG(可缩放矢量图形)的函数。我们要做的第一件事是定义我们的 SVG 的高度和宽度(以像素为单位)—除此之外，我们将定义一个填充值，以确保我们的绘图轴不与我们的 SVG 框架的边界垂直。</p><pre class="kj kk kl km gt oc ly od oe aw of bi"><span id="f9c1" class="og ms it ly b gy oh oi l oj ok"><strong class="ly iu">// Set SVG width, height, and padding</strong><em class="om"><br/></em>const w = 500;<br/>const h = 500;<br/>const padding = 60;</span></pre><h2 id="f665" class="og ms it bd mt on oo dn mx op oq dp nb li or os nd lm ot ou nf lq ov ow nh ox bi translated"><strong class="ak">加载我们的数据</strong></h2><p id="6362" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">接下来，我们需要加载我们的数据——为此，我们可以利用一个内置函数，其中<code class="fe lv lw lx ly b">format_fnc()</code>是我们格式化数据的 JavaScript 函数，而<code class="fe lv lw lx ly b">manipulate_fnc()</code>是我们将用来操作数据的函数:</p><pre class="kj kk kl km gt oc ly od oe aw of bi"><span id="3999" class="og ms it ly b gy oh oi l oj ok">d3.csv('path_to_file', format_fnc()).then(manipulate_fnc());</span></pre><p id="3ea5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用的文件路径是我上一篇文章中的 CSV 文件，我们将把它传递给一个回调函数，该函数将我们的数据重新格式化为多维数组。我们可以通过列名(' Wavelength '，' Sample _ 1 _ absorption '和' Sample _ 2 _ absorption ')引用每个 CSV 行中的字段—我们必须添加一个<code class="fe lv lw lx ly b">+</code>，因为默认情况下<code class="fe lv lw lx ly b">d3.csv()</code>将数据作为字符串加载，所以这可以确保我们存储的是数值。我们的最终数据数组将包含每个数据点的子数组，其中第一个元素是波长，第二个元素是样品 1 的吸光度，第三个元素是样品 2 的吸光度。最后，我们将格式化后的数据传递给我们接下来要编写的<code class="fe lv lw lx ly b">plot_data()</code>函数。</p><pre class="kj kk kl km gt oc ly od oe aw of bi"><span id="8d7e" class="og ms it ly b gy oh oi l oj ok"><strong class="ly iu">// Load our CSV data</strong><em class="om"><br/></em>d3.csv('https://raw.githubusercontent.com/naveenv92/python-science-tutorial/master/intro/Absorbance_Data.csv', function (d) {<br/>return [<br/>  +d['Wavelength'],<br/>  +d['Sample_1_Absorbance'],<br/>  +d['Sample_2_Absorbance']<br/>]<br/>}).then(plot_data);</span></pre><p id="9a04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以开始构建<code class="fe lv lw lx ly b">plot_data()</code>函数——我们要做的第一件事是定义轴限值:</p><pre class="kj kk kl km gt oc ly od oe aw of bi"><span id="acb0" class="og ms it ly b gy oh oi l oj ok"><strong class="ly iu">// Data plotting function</strong><em class="om"><br/></em>function plot_data(data) {</span><span id="ffe1" class="og ms it ly b gy ol oi l oj ok"><strong class="ly iu">  // Set axis limits</strong><em class="om"><br/>  </em>const xMin = 400;<br/>  const xMax = 950;<br/>  const yMin = 0;<br/>  const yMax = 2;<br/>}</span></pre><h2 id="dfd3" class="og ms it bd mt on oo dn mx op oq dp nb li or os nd lm ot ou nf lq ov ow nh ox bi translated"><strong class="ak">创建轴刻度</strong></h2><p id="e182" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">我们将继续添加这个函数的主体——我们现在需要设置轴缩放，我们将使用<code class="fe lv lw lx ly b">d3.scaleLinear()</code>来完成，因为我们的两个轴都将具有线性缩放。在此基础上，我们将链接另外两个方法:<code class="fe lv lw lx ly b">domain()</code>和<code class="fe lv lw lx ly b">range()</code>。域对应于我们将传递给标尺的输入值，范围对应于将在 SVG 上绘制的输出(以像素为单位)。你会注意到 D3 的一个主题是我们可以链接任意数量的方法。在这两个范围中，我们将通过我们的<code class="fe lv lw lx ly b">padding</code>变量的值来偏移端点，以便我们在轴周围有一些空白。你会注意到的另一个有趣的事情是，y 轴范围似乎是向后的！这是因为 SVG 的原点在左上角，所以我们需要翻转 y 值，以便将这个原点移到左下角。</p><pre class="kj kk kl km gt oc ly od oe aw of bi"><span id="613d" class="og ms it ly b gy oh oi l oj ok"><strong class="ly iu">// Set x and y-axis scales</strong><em class="om"><br/></em>const xScale = d3.scaleLinear()<br/>                 .domain([xMin, xMax])<br/>                 .range([padding, w - padding]);</span><span id="cf88" class="og ms it ly b gy ol oi l oj ok">const yScale = d3.scaleLinear()<br/>                 .domain([yMin, yMax])<br/>                 .range([h - padding, padding]);</span></pre><p id="040d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管我们已经为输入值指定了一个域，但我们的缩放函数仍将绘制这些范围之外的数据。为了确保所有数据都在我们的 x 轴域中，我们将创建一个新数组，只包含该区域中的点:</p><pre class="kj kk kl km gt oc ly od oe aw of bi"><span id="b0ee" class="og ms it ly b gy oh oi l oj ok"><strong class="ly iu">// Trim data points to only be in range of x-axis</strong><em class="om"><br/></em>let data_in_range = [];<br/>data.forEach(function (e) {<br/>  if (e[0] &gt;= xMin &amp;&amp; e[0] &lt;= xMax) {<br/>  data_in_range.push(e);<br/>  }<br/>});</span></pre><h2 id="60b7" class="og ms it bd mt on oo dn mx op oq dp nb li or os nd lm ot ou nf lq ov ow nh ox bi translated"><strong class="ak">创建初始 SVG </strong></h2><p id="669f" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">我们现在可以创建 SVG 对象了——在 D3 中，这通常是由函数<code class="fe lv lw lx ly b">d3.select()</code>和<code class="fe lv lw lx ly b">d3.selectAll()</code>驱动的。我们将选择我们之前用<code class="fe lv lw lx ly b">id=plot_area</code>创建的<code class="fe lv lw lx ly b">div</code>，并用<code class="fe lv lw lx ly b">append('svg')</code>为它附加一个 SVG。然后我们可以用<code class="fe lv lw lx ly b">attr()</code>编辑 SVG 的属性，并传递我们已经定义的高度和宽度值。</p><pre class="kj kk kl km gt oc ly od oe aw of bi"><span id="109d" class="og ms it ly b gy oh oi l oj ok"><strong class="ly iu">// Append an svg to the plot_area div</strong><em class="om"><br/></em>const svg = d3.select('#plot_area')<br/>              .append('svg')<br/>              .attr('width', w)<br/>              .attr('height', h);</span></pre><h2 id="3e59" class="og ms it bd mt on oo dn mx op oq dp nb li or os nd lm ot ou nf lq ov ow nh ox bi translated"><strong class="ak">绘制我们的第一行</strong></h2><p id="f14c" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">为了绘制第一条线(样品 1 的吸光度)，我们将在 SVG 中添加一个<code class="fe lv lw lx ly b">path</code>对象。然后，我们可以使用<code class="fe lv lw lx ly b">datum()</code>函数将相关数据绑定到该行。然后我们可以像上面一样编辑属性，但是要实际创建行，我们需要编辑<code class="fe lv lw lx ly b">d</code>属性并使用<code class="fe lv lw lx ly b">d3.line()</code>。我们将为 x 和 y 数据传递回调函数，其中我们将数据点与我们之前创建的<code class="fe lv lw lx ly b">xScale</code>和<code class="fe lv lw lx ly b">yScale</code>函数结合使用。</p><pre class="kj kk kl km gt oc ly od oe aw of bi"><span id="4abd" class="og ms it ly b gy oh oi l oj ok"><strong class="ly iu">// Append path object for sample 1</strong><em class="om"><br/></em>svg.append('path')<br/>   .datum(data_in_range)<br/>   .attr('stroke', 'black')<br/>   .attr('stroke-width', 2)<br/>   .attr('fill', 'none')<br/>   .attr('d', d3.line()<br/>                .x((d) =&gt; xScale(d[0]))<br/>                .y((d) =&gt; yScale(d[1])));</span></pre><p id="c1e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果一切顺利，我们现在可以在浏览器中打开<code class="fe lv lw lx ly b">index.html</code>文件，应该会看到以下内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/8c5c272fbd044bf84b877adf82226c50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oH1ShIi_rVk_OWKDZKkvZg.png"/></div></div></figure><p id="8f76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">婴儿学步！现在让我们添加第二行，就像我们添加第一行一样:</p><pre class="kj kk kl km gt oc ly od oe aw of bi"><span id="4e75" class="og ms it ly b gy oh oi l oj ok"><strong class="ly iu">// Append path object for sample 2</strong><em class="om"><br/></em>svg.append('path')<br/>   .datum(data_in_range)<br/>   .attr('stroke', 'steelblue')<br/>   .attr('stroke-width', 2)<br/>   .attr('fill', 'none')<br/>   .attr('d', d3.line()<br/>                .x((d) =&gt; xScale(d[0]))<br/>                .y((d) =&gt; yScale(d[2])));</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/6f7c6bad7f9c63a9f4c8992a1577e079.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kGvZTqkT2FmjaKn5_WD6qA.png"/></div></div></figure><p id="08da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经成功地绘制了两条线，但是没有任何轴，没有数据的上下文，所以让我们添加这些。</p><h2 id="bfea" class="og ms it bd mt on oo dn mx op oq dp nb li or os nd lm ot ou nf lq ov ow nh ox bi translated"><strong class="ak">给我们的剧情添加了坐标轴</strong></h2><p id="5ef5" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">为了创建 x 轴，我们使用<code class="fe lv lw lx ly b">d3.axisBottom()</code>，为了创建 y 轴，我们使用<code class="fe lv lw lx ly b">d3.axisLeft()</code>。然而，这两种方法都是让 x 和 y 轴指向正确的方向(x 轴在 SVG 的顶部，y 轴在 SVG 的左侧)——我们仍然需要将它们转换到 SVG 中它们各自的部分，这可以通过<code class="fe lv lw lx ly b">transform</code>属性来实现:</p><pre class="kj kk kl km gt oc ly od oe aw of bi"><span id="ec76" class="og ms it ly b gy oh oi l oj ok"><strong class="ly iu">// Add x-axis</strong><em class="om"><br/></em>svg.append('g')<br/>   .style('font-size', '12px')<br/>   .attr('transform', 'translate(0,' + (h - padding) + ')')<br/>   .call(d3.axisBottom(xScale));</span><span id="5e83" class="og ms it ly b gy ol oi l oj ok"><strong class="ly iu">// Add y-axis</strong><em class="om"><br/></em>svg.append('g')<br/>   .style('font-size', '12px')<br/>   .attr('transform', 'translate(' + padding + ',0)')<br/>   .call(d3.axisLeft(yScale));</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/35d0b6d92b8366bcae09360b775e3fc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XjKZ9WkUXexO8rOtgLOrrw.png"/></div></div></figure><h2 id="e83d" class="og ms it bd mt on oo dn mx op oq dp nb li or os nd lm ot ou nf lq ov ow nh ox bi translated"><strong class="ak">添加轴标签</strong></h2><p id="e4b1" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">D3 没有直接创建轴标签的方法，所以我们通过添加<code class="fe lv lw lx ly b">text</code>对象来实现。我们可以使用已经存储的高度和宽度变量轻松定位标签。在下面的代码块中，我将标签从 SVG 的边缘偏移 15 个像素。同样，但是将<code class="fe lv lw lx ly b">text-anchor</code>属性设置为<code class="fe lv lw lx ly b">middle</code>，我们可以将文本对象在轴上居中。</p><p id="8bbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于 y 轴标签，我们必须做一个额外的步骤。当旋转一个文本对象时，默认情况下它会围绕原点旋转，即使我们手动设置了<code class="fe lv lw lx ly b">x</code>和<code class="fe lv lw lx ly b">y</code>属性。为了解决这个问题，我们将在旋转的同时使用平移来重置旋转点，并旋转-90 度。</p><pre class="kj kk kl km gt oc ly od oe aw of bi"><span id="aec1" class="og ms it ly b gy oh oi l oj ok"><strong class="ly iu">// Add x-axis label</strong><em class="om"><br/></em>svg.append('text')<br/>   .attr('x', w/2)<br/>   .attr('y', h - 15)<br/>   .attr('text-anchor', 'middle')<br/>   .style('font-family', 'sans-serif')<br/>   .text('Wavelength (nm)');</span><span id="2211" class="og ms it ly b gy ol oi l oj ok"><strong class="ly iu">// Add y-axis label</strong><em class="om"><br/></em>svg.append('text')<br/>   .attr('text-anchor', 'middle')<br/>   .attr('transform', 'translate(15,' + h/2 + ')rotate(-90)')<br/>   .style('font-family', 'sans-serif')<br/>   .text('Absorbance (O.D.)');</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/9773ed2325af46f475b8539439b7e82c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0-2MbyFCFosVMFI4SLz--g.png"/></div></div></figure><h2 id="eff2" class="og ms it bd mt on oo dn mx op oq dp nb li or os nd lm ot ou nf lq ov ow nh ox bi translated"><strong class="ak">添加图例</strong></h2><p id="8b77" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">再说一次，就创造一个传奇而言，我们几乎只能靠自己了。我们的行动方针如下:</p><ol class=""><li id="da85" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">通过创建两点数据集为图例创建线</li><li id="9ae6" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">为每个图例标签追加文本对象</li></ol><p id="9dcd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的图中，图例从[750，800]开始，样本 1 的 y 值为 1.9，样本 2 的 y 值为 1.7。</p><pre class="kj kk kl km gt oc ly od oe aw of bi"><span id="6a2c" class="og ms it ly b gy oh oi l oj ok"><strong class="ly iu">// Add legend</strong><em class="om"><br/></em>svg.append('path')<br/>   .datum([[750, 1.9], [800, 1.9]])<br/>   .attr('stroke', 'black')<br/>   .attr('stroke-width', 2)<br/>   .attr('d', d3.line()<br/>                .x((d) =&gt; xScale(d[0]))<br/>                .y((d) =&gt; yScale(d[1])));</span><span id="61cd" class="og ms it ly b gy ol oi l oj ok">svg.append('path')<br/>   .datum([[750, 1.7], [800, 1.7]])<br/>   .attr('stroke', 'steelblue')<br/>   .attr('stroke-width', 2)<br/>   .attr('d', d3.line()<br/>                .x((d) =&gt; xScale(d[0]))<br/>                .y((d) =&gt; yScale(d[1])));</span></pre><p id="cd24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以在每条新绘制的线旁边附加文本标签:</p><pre class="kj kk kl km gt oc ly od oe aw of bi"><span id="7f36" class="og ms it ly b gy oh oi l oj ok">svg.append('text')<br/>   .attr('x', xScale(805))<br/>   .attr('y', yScale(1.9))<br/>   .attr('alignment-baseline', 'central')<br/>   .style('font-family', 'sans-serif')<br/>   .style('font-size', '16px')<br/>   .text('Sample 1');</span><span id="7da8" class="og ms it ly b gy ol oi l oj ok">svg.append('text')<br/>   .attr('x', xScale(805))<br/>   .attr('y', yScale(1.7))<br/>   .attr('alignment-baseline', 'central')<br/>   .style('font-family', 'sans-serif')<br/>   .style('font-size', '16px')<br/>   .text('Sample 2');</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/bb2822868fcf642437ca4027eaab1a9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uGOO9aWFEX51by3cTesZkg.png"/></div></div></figure><h2 id="8047" class="og ms it bd mt on oo dn mx op oq dp nb li or os nd lm ot ou nf lq ov ow nh ox bi translated"><strong class="ak">让我们的剧情动态化</strong></h2><p id="23e6" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">现在，如果你认为我们费了很大的劲才做出你在上面看到的这个简单的图，你可能是对的。用 R 或 Python 等其他编程软件制作静态图形非常简单。但是让我们的剧情动态化才是 D3 真正展示威力的地方。首先，让我们创建一个小动画，其中两条线都从 0 开始，然后在一秒钟内上升到它们的值。</p><p id="770a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们将返回并编辑路径的初始绘图。我们使用<code class="fe lv lw lx ly b">transition()</code>方法和<code class="fe lv lw lx ly b">duration()</code>来改变我们的属性，在本例中是<code class="fe lv lw lx ly b">d</code>属性。我们最初将所有的 y 值设置为 0，然后将它们更改为各自的值。</p><pre class="kj kk kl km gt oc ly od oe aw of bi"><span id="953b" class="og ms it ly b gy oh oi l oj ok"><strong class="ly iu">// Append path object for sample 1</strong><em class="om"><br/></em>svg.append('path')<br/>   .datum(data_in_range)<br/>   .attr('stroke', 'black')<br/>   .attr('stroke-width', 2)<br/>   .attr('fill', 'none')<br/>   .attr('d', d3.line()<br/>                .x((d) =&gt; xScale(d[0]))<br/>                .y(yScale(0)))<br/>   .transition()<br/>   .duration(1000)<br/>   .attr('d', d3.line()<br/>                .x((d) =&gt; xScale(d[0]))<br/>                .y((d) =&gt; yScale(d[1])));</span><span id="fd86" class="og ms it ly b gy ol oi l oj ok"><strong class="ly iu">// Append path object for sample 2</strong><em class="om"><br/></em>svg.append('path')<br/>   .datum(data_in_range)<br/>   .attr('stroke', 'steelblue')<br/>   .attr('stroke-width', 2)<br/>   .attr('fill', 'none')<br/>   .attr('d', d3.line()<br/>                .x((d) =&gt; xScale(d[0]))<br/>                .y(yScale(0)))<br/>   .transition()<br/>   .duration(1000)<br/>   .attr('d', d3.line()<br/>                .x((d) =&gt; xScale(d[0]))<br/>                .y((d) =&gt; yScale(d[2])));</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/33f17f3af0bd8dd7e61a185849d0404e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/1*I6JET3FAdkEgRPDkWkAj_Q.gif"/></div></figure><p id="2944" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们制作它，这样我们就可以用鼠标悬停在实际的数据点上，并获得它们的确切值。为此，我将为每个数据点添加圆圈。在这种情况下，我们将使用<code class="fe lv lw lx ly b">d3.selectAll()</code>来选择我们将要创建的圆形对象。我们使用<code class="fe lv lw lx ly b">data()</code>而不是<code class="fe lv lw lx ly b">datum()</code>来绑定数据，因为我们正在为每个数据点创建一个新的圆，而不是像上面那样使用所有的数据点来创建一个路径。</p><p id="6db2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于每个圆，我们分别为圆的 x 和 y 坐标编辑属性<code class="fe lv lw lx ly b">cx</code>和<code class="fe lv lw lx ly b">cy</code>，为圆的半径编辑属性<code class="fe lv lw lx ly b">r</code>。我们将填充颜色设置为与线条相同。然后每个圆被赋予一个类值<code class="fe lv lw lx ly b">points</code>，我们将使用 CSS 来修改它。最后，我们将<code class="fe lv lw lx ly b">pointer-events</code>设置为<code class="fe lv lw lx ly b">all</code>，这样如果圆圈的任何部分进入鼠标指针，我们就可以触发一个事件。</p><p id="0d61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了创建工具提示，我们将<code class="fe lv lw lx ly b">title</code>对象附加到每个圆上，并将它们的<code class="fe lv lw lx ly b">text</code>属性设置为对应于该点的数据。所以当我们悬停在其中一个点上时，我们会看到数据。</p><pre class="kj kk kl km gt oc ly od oe aw of bi"><span id="3390" class="og ms it ly b gy oh oi l oj ok"><strong class="ly iu">// Append circles for hovering points for sample 1</strong><em class="om"><br/></em>svg.selectAll('circle_samp_1')<br/>   .data(data_in_range)<br/>   .enter()<br/>   .append('circle')<br/>   .attr('cx', (d) =&gt; xScale(d[0]))<br/>   .attr('cy', (d) =&gt; yScale(d[1]))<br/>   .attr('r', 4)<br/>   .attr('fill', 'black')<br/>   .attr('class', 'points')<br/>   .style('pointer-events', 'all')<br/>   .append('title')<br/>   .text(function (d) {<br/>      return (<br/>      'Wavelength: ' + d[0] + ' nm' + '\n' + 'Absorbance: ' + d[1]<br/>      );<br/>   });</span><span id="f3a3" class="og ms it ly b gy ol oi l oj ok"><strong class="ly iu">// Append circles for hovering for sample 2</strong><em class="om"><br/></em>svg.selectAll('circle_samp_2')<br/>   .data(data_in_range)<br/>   .enter()<br/>   .append('circle')<br/>   .attr('cx', (d) =&gt; xScale(d[0]))<br/>   .attr('cy', (d) =&gt; yScale(d[2]))<br/>   .attr('r', 4)<br/>   .attr('fill', 'steelblue')<br/>   .attr('class', 'points')<br/>   .style('pointer-events', 'all')<br/>   .append('title')<br/>   .text(function (d) {<br/>   return (<br/>      'Wavelength: ' + d[0] + ' nm' + '\n' + 'Absorbance: ' + d[2]<br/>      );<br/>   });</span></pre><h2 id="6dc9" class="og ms it bd mt on oo dn mx op oq dp nb li or os nd lm ot ou nf lq ov ow nh ox bi translated"><strong class="ak">编辑 CSS 将所有内容整合在一起</strong></h2><p id="520f" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">我希望我们在上面画的圆圈是看不见的，直到我们悬停在它们上面。我们可以通过编辑<code class="fe lv lw lx ly b">visibility</code>属性在 CSS 中非常简单地做到这一点。我们从隐藏它们开始，然后在触发<code class="fe lv lw lx ly b">points:hover</code>事件时使它们可见。</p><pre class="kj kk kl km gt oc ly od oe aw of bi"><span id="2e62" class="og ms it ly b gy oh oi l oj ok"><strong class="ly iu">/* Make points visible on hover */</strong><em class="om"><br/>.points</em> {<br/>visibility: hidden;<br/>}</span><span id="6ecf" class="og ms it ly b gy ol oi l oj ok">.points:hover {<br/>visibility: visible;<br/>}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/e2320b90347d7d2864d02883c3eb1cf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/1*7L7UGJObbKpobEgiS5Xr_A.gif"/></div></figure><p id="1f1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你知道了！用 D3 制作的吸光度图的交互式版本！</p><h1 id="72a1" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated"><strong class="ak">结束语</strong></h1><p id="0c03" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">感谢您的阅读！本文的所有分析都可以在这个<a class="ae ky" href="https://github.com/venkatesannaveen/medium-articles" rel="noopener ugc nofollow" target="_blank"> Github 资源库</a>中找到。我很感激任何反馈，你可以在<a class="ae ky" href="https://twitter.com/naveenv_92" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上找到我，并在<a class="ae ky" href="https://www.linkedin.com/in/naveenvenkatesan/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上与我联系以获得更多更新和文章。</p></div></div>    
</body>
</html>