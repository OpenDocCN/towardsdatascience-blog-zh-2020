<html>
<head>
<title>5-Step Guide to generate 3D meshes from point clouds with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python从点云生成3D网格的5步指南</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/5-step-guide-to-generate-3d-meshes-from-point-clouds-with-python-36bad397d8ba?source=collection_archive---------0-----------------------#2020-04-21">https://towardsdatascience.com/5-step-guide-to-generate-3d-meshes-from-point-clouds-with-python-36bad397d8ba?source=collection_archive---------0-----------------------#2020-04-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="ef0a" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">3D Python</h2><div class=""/><div class=""><h2 id="87ca" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">生成3D网格的教程(。obj，。ply，。stl，。gltf)自动从三维点云使用python。(加分)表面重建，创造几个层次的细节。</h2></div><p id="b437" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在本文中，我将向您展示我的3D表面重建过程，使用python从点云快速创建网格。您将能够导出，可视化和集成到您最喜爱的三维软件的结果，没有任何编码经验。此外，我将为您提供一种生成多层次细节(LoD)的简单方法，如果您想要创建实时应用程序(例如，使用Unity的虚拟现实)，这将非常有用。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ln"><img src="../Images/79495078bdc1de504323c438c69bdb6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*7FXcj2OMq8eydds_9dJB8g.gif"/></div></div><p class="lz ma gj gh gi mb mc bd b be z dk translated">使用Python自动生成的几个网格。在本文结束时，您将能够从点云创建数据集</p></figure><p id="330a" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">3D网格是一种几何数据结构，通常由一组相连的三角形组成，这些三角形明确描述了一个表面🤔。它们被用于从地理空间重建到VFX、电影和视频游戏的广泛应用中。当需要一个物理副本时，或者当我需要在游戏引擎中集成环境时，我经常创建它们，在这些情况下，点云支持是有限的。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi md"><img src="../Images/529a1ab2d75501d38a25240f879120e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iJl6rTuSbaK6cFA0tn8XQQ.png"/></div></div><p class="lz ma gj gh gi mb mc bd b be z dk translated">Roman Robroek 为<a class="ae me" href="https://www.insider.com/3d-virtual-tours-of-abandoned-places-2020-4#the-factory-was-the-largest-space-that-robroek-and-poux-have-converted-into-a-3d-image-8" rel="noopener ugc nofollow" target="_blank">酷遗产项目从3D捕捉环境生成的网格示例。(左)3D点云，(中)网格覆盖的顶点，(右)纹理网格。如果你想了解如何获得这样的结果，请查看</a><a class="ae me" href="https://learngeodata.eu/" rel="noopener ugc nofollow" target="_blank">地理数据学院</a>令人惊叹的地层3D重建器。</p></figure><p id="a1a3" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">它们很好地集成在大多数软件专业人员的工作中。最重要的是，如果你想探索3D打印的奇迹，你需要能够从你拥有的数据中生成一致的网格。本文旨在为您提供一个高效的工作流程，分为5个可定制的步骤，并在文章结尾提供了我的可远程执行的脚本。让我们开始吧！</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="1430" class="mm mn it bd mo mp mq mr ms mt mu mv mw ki mx kj my kl mz km na ko nb kp nc nd bi translated">步骤1:设置环境</h1><p id="80be" class="pw-post-body-paragraph kr ks it kt b ku ne kd kw kx nf kg kz la ng lc ld le nh lg lh li ni lk ll lm im bi translated">在上一篇文章中，我们看到了如何使用Anaconda轻松设置环境，以及如何使用GUI Spyder管理代码。我们将以这种方式继续，仅使用两个库。</p><div class="nj nk gp gr nl nm"><a rel="noopener follow" target="_blank" href="/discover-3d-point-cloud-processing-with-python-6112d9ee38e7"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd jd gy z fp nr fr fs ns fu fw jc bi translated">使用Python探索3D点云处理</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">教程简单地设置python环境，开始处理和可视化3D点云数据。</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">towardsdatascience.com</p></div></div><div class="nv l"><div class="nw l nx ny nz nv oa lx nm"/></div></div></a></div><p id="352d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">为了从点云中自动获取3D网格，我们将在我们的环境中添加另一个库，Open3D。它是一个开源库，允许使用一组高效的数据结构和算法来处理3D数据。安装需要单击您的环境旁边的▶️图标。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ob"><img src="../Images/11200bbc3f23b2cf1cded5ed93e05e9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*JaQJOanr6PpBvcEsS4gLZA.gif"/></div></div></figure><p id="e7e9" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">打开终端并运行以下命令:</p><pre class="lo lp lq lr gt oc od oe of aw og bi"><span id="7c71" class="oh mn it od b gy oi oj l ok ol">conda install -c open3d-admin open3d==0.8.0.0</span></pre><p id="9a52" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">🤓<strong class="kt jd"> <em class="om">注</em></strong><em class="om">:</em>open 3d包兼容python、3.5、3.6版本。如果您有另一个环境，您可以创建一个新的环境(best ),或者如果您从上一篇文章开始，通过在终端中键入<code class="fe on oo op od b">conda install python=3.5</code>来更改您的终端中的python版本。</p><p id="ce04" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这将自动安装软件包及其依赖项，您可以在终端提示时输入<code class="fe on oo op od b">y</code>来允许这个过程。现在，您已经为项目做好了准备。</p><h1 id="7cbf" class="mm mn it bd mo mp oq mr ms mt or mv mw ki os kj my kl ot km na ko ou kp nc nd bi translated">步骤2:加载和准备数据</h1><p id="dc62" class="pw-post-body-paragraph kr ks it kt b ku ne kd kw kx nf kg kz la ng lc ld le nh lg lh li ni lk ll lm im bi translated">启动你的python脚本工具(Spyder GUI，Jupyter或者Google Colab)，在这里我们将调用2个库:Numpy和Open3D。</p><pre class="lo lp lq lr gt oc od oe of aw og bi"><span id="850d" class="oh mn it od b gy oi oj l ok ol">import numpy as np<br/>import open3d as o3d</span></pre><p id="bd20" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">然后，我们创建保存数据路径和点云数据的变量:</p><pre class="lo lp lq lr gt oc od oe of aw og bi"><span id="8f45" class="oh mn it od b gy oi oj l ok ol">input_path="your_path_to_file/"<br/>output_path="your_path_to_output_folder/"<br/>dataname="sample.xyz"<br/>point_cloud= np.loadtxt(input_path+dataname,skiprows=1)</span></pre><p id="073b" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">🤓<strong class="kt jd"> <em class="om">注</em> </strong> <em class="om"> : </em>至于前面的帖子，我们会使用一个采样的点云，你可以从<a class="ae me" href="https://drive.google.com/drive/folders/1Ih_Zz9a6UcbUlaA-puEB_is7DYvXrb4w?usp=sharing" rel="noopener ugc nofollow" target="_blank">这个库</a>中自由下载。如果想在不安装任何东西的情况下提前可视化，可以查看<a class="ae me" href="https://www.flyvast.com/flyvast/app/page-snapshot-viewer.html#/333/ec8d9a6c-de38-7249-e6fc-026c4ff67ef7" rel="noopener ugc nofollow" target="_blank"> webGL版本</a>。</p><p id="0a37" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">最后，我们将<code class="fe on oo op od b">point_cloud</code>变量类型从Numpy转换为Open3D <code class="fe on oo op od b">o3d.geometry.PointCloud</code>类型，以便进一步处理:</p><pre class="lo lp lq lr gt oc od oe of aw og bi"><span id="c12c" class="oh mn it od b gy oi oj l ok ol">pcd = o3d.geometry.PointCloud()<br/>pcd.points = o3d.utility.Vector3dVector(point_cloud[:,:3])<br/>pcd.colors = o3d.utility.Vector3dVector(point_cloud[:,3:6]/255)<br/>pcd.normals = o3d.utility.Vector3dVector(point_cloud[:,6:9])</span></pre><p id="cdd7" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">🤓<strong class="kt jd"> <em class="om">注意</em> </strong> <em class="om"> : </em>下面这个命令首先实例化Open3d点云对象，然后从原来的NumPy数组给它添加点、颜色、法线。</p><p id="ef35" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">为了快速查看您加载的内容，您可以执行以下命令(在Google Colab中不起作用):</p><pre class="lo lp lq lr gt oc od oe of aw og bi"><span id="d433" class="oh mn it od b gy oi oj l ok ol">o3d.visualization.draw_geometries([pcd])</span></pre><h1 id="1130" class="mm mn it bd mo mp oq mr ms mt or mv mw ki os kj my kl ot km na ko ou kp nc nd bi translated">第三步:选择啮合策略</h1><p id="b711" class="pw-post-body-paragraph kr ks it kt b ku ne kd kw kx nf kg kz la ng lc ld le nh lg lh li ni lk ll lm im bi translated">现在我们准备通过网格化<code class="fe on oo op od b">pcd</code>点云开始表面重建过程。我将给出我最喜欢的有效获得结果的方法，但是在我们开始之前，一些浓缩的细节对于理解底层的过程是必要的。我将把自己限制在两个啮合策略。</p><h2 id="f382" class="oh mn it bd mo ov ow dn ms ox oy dp mw la oz pa my le pb pc na li pd pe nc iz bi translated">策略1:球旋转算法[1]</h2><p id="3fba" class="pw-post-body-paragraph kr ks it kt b ku ne kd kw kx nf kg kz la ng lc ld le nh lg lh li ni lk ll lm im bi translated">球旋转算法(BPA)背后的思想是模拟使用虚拟球从点云中生成网格。我们首先假设给定的点云由从物体表面采样的点组成。点必须<strong class="kt jd">严格</strong>表示一个表面(无噪声)，即重建的网格显式。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi pf"><img src="../Images/f897ecdddb5822a3914dc71e105d5b02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NMgJB4jZIwSUkeTe65qHVQ.png"/></div></div></figure><p id="5e04" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">使用这个假设，想象在点云“表面”上滚动一个微小的球。这个小球取决于网格的比例，应该比点与点之间的平均间距稍大。当你把一个球丢到点的表面时，球会被抓住并停留在三个点上，这三个点将形成<em class="om">种子三角形。从那个位置，球沿着两点形成的三角形边缘滚动。然后球在一个新的位置:一个新的三角形由两个先前的顶点形成，一个新的三角形被添加到网格中。随着我们继续滚动和旋转球，新的三角形形成并添加到网格中。球继续滚动，直到网完全形成。</em></p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/14e0fa6b74ad31f16fb208f8dfac8c8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:958/format:webp/1*PYLul_pGg_600CD5zSliMw.png"/></div><p class="lz ma gj gh gi mb mc bd b be z dk translated">Brett Rapponotti，Michael Snowden和Allen Zeng的插图。<a class="ae me" href="https://cs184team.github.io/cs184-final/writeup.html" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="67b2" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">球旋转算法背后的想法很简单，但是当然，这个过程有许多注意事项，如最初表达的<a class="ae me" href="https://cs184team.github.io/cs184-final/writeup.html" rel="noopener ugc nofollow" target="_blank">这里的</a>:</p><ul class=""><li id="5ef9" class="ph pi it kt b ku kv kx ky la pj le pk li pl lm pm pn po pp bi translated"><em class="om">球半径是如何选择的？</em>半径是根据输入点云的大小和比例根据经验获得的。理论上，球的直径应该略大于点与点之间的平均距离。</li><li id="2c42" class="ph pi it kt b ku pq kx pr la ps le pt li pu lm pm pn po pp bi translated"><em class="om">如果某些位置的点相隔太远，球掉了怎么办？</em>当球沿着一条边旋转时，它可能会错过表面上的适当点，而是击中对象上的另一个点，甚至正好是它的三个旧点。在这种情况下，我们检查新三角形<code class="fe on oo op od b">Facet</code>的法线与点的<code class="fe on oo op od b">Vertex</code>法线方向一致。如果不是，那么我们拒绝三角形并创建一个洞。</li><li id="6856" class="ph pi it kt b ku pq kx pr la ps le pt li pu lm pm pn po pp bi translated"><em class="om">如果表面有折痕或凹陷，使得表面与自身之间的距离小于球的大小，该怎么办？</em>在这种情况下，球只会滚过折痕，而忽略折痕内的点。但是，这不是理想的行为，因为重建的网格对对象不精确。</li><li id="b43c" class="ph pi it kt b ku pq kx pr la ps le pt li pu lm pm pn po pp bi translated"><em class="om">如果曲面被分隔成多个点区域，使得球无法在这些区域之间成功滚动，该怎么办？</em>虚拟球在不同的位置多次掉落到表面上。这确保球捕获整个网格，即使这些点的间隔不一致。</li></ul><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi pv"><img src="../Images/1f0f7636d2b6872162a68989e208ec98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qDA2b_O4B2v6DehKxylVBg.png"/></div></div><p class="lz ma gj gh gi mb mc bd b be z dk translated">5视觉效果中的半径影响。您可以看到，最佳网格会自动平衡最佳几何体拟合和三角形数量。</p></figure><h2 id="3af6" class="oh mn it bd mo ov ow dn ms ox oy dp mw la oz pa my le pb pc na li pd pe nc iz bi translated">策略2:泊松重建[2]</h2><p id="c227" class="pw-post-body-paragraph kr ks it kt b ku ne kd kw kx nf kg kz la ng lc ld le nh lg lh li ni lk ll lm im bi translated">泊松重建更具技术性/数学性。它的方法被称为隐式网格化方法，我将其描述为试图将数据“包裹”在一块光滑的布中。在不涉及太多细节的情况下，我们试图通过创建一个全新的点集来拟合原始点集的水密表面，该点集代表一个与法线关联的等值面。有几个参数会影响网格划分的结果:</p><ul class=""><li id="9491" class="ph pi it kt b ku kv kx ky la pj le pk li pl lm pm pn po pp bi translated"><em class="om">哪个深度？</em>树深度用于重建。网格越高越详细(默认值:8)。对于有噪声的数据，您可以在生成的网格中保留离群点，但算法不会检测到它们。所以低值(可能在5到7之间)提供了平滑效果，但是你会丢失细节。深度值越高，生成的网格的顶点数量就越多。</li></ul><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi pw"><img src="../Images/39eef7185d7ae96664625235d2b9e037.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aSt77Z3OCXWfoFUo9s15Lg.png"/></div></div></figure><ul class=""><li id="2540" class="ph pi it kt b ku kv kx ky la pj le pk li pl lm pm pn po pp bi translated"><em class="om">哪个宽度？</em>这指定了树结构最细层次的目标宽度，称为八叉树🤯。不要担心，我将在另一篇文章中讨论这一点以及3D的最佳数据结构，因为它扩展了本文的范围。无论如何，如果指定了深度，这个参数将被忽略。</li><li id="29ab" class="ph pi it kt b ku pq kx pr la ps le pt li pu lm pm pn po pp bi translated"><em class="om">哪个尺度？</em>它描述了用于重建的立方体直径与样本包围立方体直径之间的比率。非常抽象，默认参数通常很好用(1.1)。</li></ul><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi pw"><img src="../Images/35035ac59d63614780465b024dea42d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qMMPeRvEaYWhGaFDqbJO6g.png"/></div></div><p class="lz ma gj gh gi mb mc bd b be z dk translated">比例参数对结果的影响。看看它是如何包围初始点云的。</p></figure><ul class=""><li id="aeef" class="ph pi it kt b ku kv kx ky la pj le pk li pl lm pm pn po pp bi translated"><em class="om">哪个合适？</em>linear _ fit参数如果设置为真，则让重建器使用线性插值来估计等值顶点的位置。</li></ul><h1 id="e43b" class="mm mn it bd mo mp oq mr ms mt or mv mw ki os kj my kl ot km na ko ou kp nc nd bi translated">步骤4:处理数据</h1><h2 id="4156" class="oh mn it bd mo ov ow dn ms ox oy dp mw la oz pa my le pb pc na li pd pe nc iz bi translated">策略1: BPA</h2><p id="ebca" class="pw-post-body-paragraph kr ks it kt b ku ne kd kw kx nf kg kz la ng lc ld le nh lg lh li ni lk ll lm im bi translated">我们首先根据从所有点之间的距离计算出的平均距离来计算必要的半径参数:</p><pre class="lo lp lq lr gt oc od oe of aw og bi"><span id="e2e6" class="oh mn it od b gy oi oj l ok ol">distances = pcd.compute_nearest_neighbor_distance()<br/>avg_dist = np.mean(distances)<br/>radius = 3 * avg_dist</span></pre><p id="7fe6" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在一个命令行中，我们可以创建一个网格并将其存储在<code class="fe on oo op od b">bpa_mesh</code>变量中:</p><pre class="lo lp lq lr gt oc od oe of aw og bi"><span id="f62d" class="oh mn it od b gy oi oj l ok ol">bpa_mesh = o3d.geometry.TriangleMesh.create_from_point_cloud_ball_pivoting(pcd,o3d.utility.DoubleVector([radius, radius * 2]))</span></pre><p id="c1ea" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在导出网格之前，我们可以将结果缩减采样到可接受的三角形数量，例如100k个三角形:</p><pre class="lo lp lq lr gt oc od oe of aw og bi"><span id="fe6d" class="oh mn it od b gy oi oj l ok ol">dec_mesh = mesh.simplify_quadric_decimation(100000)</span></pre><p id="2ed3" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">此外，如果您认为网格可能会出现一些奇怪的工件，您可以运行以下命令来确保其一致性:</p><pre class="lo lp lq lr gt oc od oe of aw og bi"><span id="f1fe" class="oh mn it od b gy oi oj l ok ol">dec_mesh.remove_degenerate_triangles()<br/>dec_mesh.remove_duplicated_triangles()<br/>dec_mesh.remove_duplicated_vertices()<br/>dec_mesh.remove_non_manifold_edges()</span></pre><h2 id="2457" class="oh mn it bd mo ov ow dn ms ox oy dp mw la oz pa my le pb pc na li pd pe nc iz bi translated">策略2:泊松重建</h2><p id="c2af" class="pw-post-body-paragraph kr ks it kt b ku ne kd kw kx nf kg kz la ng lc ld le nh lg lh li ni lk ll lm im bi translated">🤓<strong class="kt jd"> <em class="om">注</em> </strong> <em class="om"> : </em> <em class="om">该策略从Open3D的</em> <strong class="kt jd"> <em class="om">版本0.9.0.0 </em> </strong> <em class="om">开始可用，因此目前只能远程工作。你可以通过我提供的google colab代码执行</em> <a class="ae me" href="https://colab.research.google.com/drive/1HXVOK53ac6BJHAFxdEVluhFr7UAZKtDV" rel="noopener ugc nofollow" target="_blank"> <em class="om">这里</em> </a> <em class="om">。</em></p><p id="857f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">要用泊松得到结果，非常简单。您只需调整传递给函数的参数，如上所述:</p><pre class="lo lp lq lr gt oc od oe of aw og bi"><span id="f1b9" class="oh mn it od b gy oi oj l ok ol">poisson_mesh = o3d.geometry.TriangleMesh.create_from_point_cloud_poisson(pcd, depth=8, width=0, scale=1.1, linear_fit=False)[0]</span></pre><p id="4607" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">🤓<strong class="kt jd"> <em class="om">注意</em> </strong> <em class="om"> : </em> <em class="om">该函数输出一个由o3d.geometry对象后跟Numpy数组组成的列表。您只想选择o3d.geometry来调整结尾的[0]。</em></p><p id="c685" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">为了获得清晰的结果，通常需要添加一个裁剪步骤来清除下图中突出显示为黄色的不想要的伪像:</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi px"><img src="../Images/73e2b3ed3bfe7aee2ccd4ce3e845b5a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nC7BHAOgMvnWCnmp0QtOMg.png"/></div></div><p class="lz ma gj gh gi mb mc bd b be z dk translated">原始泊松重建(左)和裁剪网格(右)</p></figure><p id="ad54" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">为此，我们计算包含原始点云的初始边界框，并使用它从边界框外的网格中过滤所有表面:</p><pre class="lo lp lq lr gt oc od oe of aw og bi"><span id="9d68" class="oh mn it od b gy oi oj l ok ol">bbox = pcd.get_axis_aligned_bounding_box()<br/>p_mesh_crop = poisson_mesh.crop(bbox)</span></pre><p id="f460" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">你现在有了一个或多个变量，每个变量都包含了网格几何体，干得好！在应用程序中获得它的最后一步是导出它！</p><h1 id="4310" class="mm mn it bd mo mp oq mr ms mt or mv mw ki os kj my kl ot km na ko ou kp nc nd bi translated">步骤5:导出并可视化</h1><p id="9477" class="pw-post-body-paragraph kr ks it kt b ku ne kd kw kx nf kg kz la ng lc ld le nh lg lh li ni lk ll lm im bi translated">使用<code class="fe on oo op od b">write_triangle_mesh</code>函数可以直接导出数据。我们只需在创建的文件的名称中指定我们想要的扩展名。ply，。obj，。stl或者。gltf和要导出的网格。下面，我们将BPA和泊松重建导出为。ply文件:</p><pre class="lo lp lq lr gt oc od oe of aw og bi"><span id="0411" class="oh mn it od b gy oi oj l ok ol">o3d.io.write_triangle_mesh(output_path+"bpa_mesh.ply", dec_mesh)<br/>o3d.io.write_triangle_mesh(output_path+"p_mesh_c.ply", p_mesh_crop)</span></pre><p id="5b4c" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">为了快速生成细节层次(LoD ),让我们编写第一个函数。这真的很简单。该函数将网格、LoD列表(作为三角形的目标数量)、结果文件的文件格式和文件写入路径作为参数。该函数(在脚本中编写)如下所示:</p><pre class="lo lp lq lr gt oc od oe of aw og bi"><span id="a1f8" class="oh mn it od b gy oi oj l ok ol">def lod_mesh_export(mesh, lods, extension, path):<br/>    mesh_lods={}<br/>    for i in lods:<br/>        mesh_lod = mesh.simplify_quadric_decimation(i)<br/>        o3d.io.write_triangle_mesh(path+"lod_"+str(i)+extension, mesh_lod)<br/>        mesh_lods[i]=mesh_lod<br/>    print("generation of "+str(i)+" LoD successful")<br/>    return mesh_lods</span></pre><p id="8b4b" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">💡<strong class="kt jd"> <em class="om">提示:</em> </strong> <em class="om">我将在另一篇文章中介绍这个函数的基本功能以及它的结构。此时，了解该函数将(1)以所需的文件格式将数据导出到您选择的指定位置，以及(2)如果需要在python中进行更多处理，可以将结果存储在变量中，这是很有用的。</em></p><p id="0c18" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这个函数有一些魔力，但是一旦执行，它看起来就像什么也没发生。不要担心，您的程序现在知道什么是<code class="fe on oo op od b">lod_mesh_export</code>，您可以在控制台中直接调用它，在那里我们只需根据需要的值更改参数:</p><pre class="lo lp lq lr gt oc od oe of aw og bi"><span id="10f7" class="oh mn it od b gy oi oj l ok ol">my_lods = lod_mesh_export(bpa_mesh, [100000,50000,10000,1000,100], ".ply", output_path)</span></pre><p id="a908" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">有趣的是，现在你不需要每次为不同的负载重写一堆代码。您只需向函数传递不同的参数:</p><pre class="lo lp lq lr gt oc od oe of aw og bi"><span id="7067" class="oh mn it od b gy oi oj l ok ol">my_lods2 = lod_mesh_export(bpa_mesh, [8000,800,300], ".ply", output_path)</span></pre><p id="3647" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">如果您想在python中可视化一个特定的LoD，比如有100个三角形的LoD，您可以通过以下命令访问并可视化它:</p><pre class="lo lp lq lr gt oc od oe of aw og bi"><span id="55b0" class="oh mn it od b gy oi oj l ok ol">o3d.visualization.draw_geometries([my_lods[100]])</span></pre><p id="73cf" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">为了在python之外进行可视化，你可以使用你选择的软件(例如开源的Blender、MeshLab和CloudCompare)并在GUI中加载导出的文件。直接在web上通过WebGL，您可以使用<a class="ae me" href="https://threejs.org/editor/" rel="noopener ugc nofollow" target="_blank"> Three.js </a>编辑器或<a class="ae me" href="https://www.flyvast.com/flyvast/app/index.html#/login/overviewOfferFree" rel="noopener ugc nofollow" target="_blank"> Flyvast </a>来简单地访问网格。</p><p id="a7df" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">最后，你可以将它导入任何3D打印软件，并通过在线打印服务获得报价🤑。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi py"><img src="../Images/a57c08c21f5b38271dbde12229458aad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J56Qm0YW7fZrcQWqb8AAsw.png"/></div></div><p class="lz ma gj gh gi mb mc bd b be z dk translated">约20 cm的模型金色印花示例。使用在线服务获得价格的大致概念，你可以计算出一个基本的树脂打印需要400欧元。这扩展了本教程的范围，将在另一篇文章中讨论</p></figure><p id="8bc5" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">太棒了。在这个5步指南中，我们介绍了如何从点云设置自动python 3D网格创建器。这是一个非常好的工具，将证明在许多3D自动化项目中非常方便！然而，我们假设点云已经是无噪声的，并且法线方向良好。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi pz"><img src="../Images/d57dbca7c63cacea4564ffd39bf00294.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u9rdK47LDdpgCxBZwt2fXg.png"/></div></div><p class="lz ma gj gh gi mb mc bd b be z dk translated">一些显示的法线</p></figure><p id="750f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">如果不是这种情况，那么就需要一些额外的步骤，下面文章中已经讨论过的一些很好的见解将在另一篇文章中讨论</p><p id="061b" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">完整的代码可以在这里获得:<a class="ae me" href="https://colab.research.google.com/drive/1HXVOK53ac6BJHAFxdEVluhFr7UAZKtDV" rel="noopener ugc nofollow" target="_blank">谷歌Colab笔记本</a></p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="30e0" class="mm mn it bd mo mp mq mr ms mt mu mv mw ki mx kj my kl mz km na ko nb kp nc nd bi translated">结论</h1><p id="787a" class="pw-post-body-paragraph kr ks it kt b ku ne kd kw kx nf kg kz la ng lc ld le nh lg lh li ni lk ll lm im bi translated">您刚刚学习了如何导入、网格化、导出和可视化由数百万个点组成的具有不同LoD的点云！干得好！但这条路并没有到此为止，未来的帖子将深入点云空间分析、文件格式、数据结构、可视化、动画和网格划分。我们将特别关注如何管理大点云数据，如下面的文章中所定义的。</p><div class="nj nk gp gr nl nm"><a rel="noopener follow" target="_blank" href="/the-future-of-3d-point-clouds-a-new-perspective-125b35b558b9"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd jd gy z fp nr fr fs ns fu fw jc bi translated">三维点云的未来:一个新的视角</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">被称为点云的离散空间数据集通常为决策应用奠定基础。但是他们能不能…</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">towardsdatascience.com</p></div></div><div class="nv l"><div class="qa l nx ny nz nv oa lx nm"/></div></div></a></div><p id="f681" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我的贡献旨在浓缩可操作的信息，以便您可以从零开始为您的项目构建3D自动化系统。你可以从今天开始在<a class="ae me" href="https://learngeodata.eu" rel="noopener ugc nofollow" target="_blank">地理数据学院</a>参加一个编队</p><div class="nj nk gp gr nl nm"><a href="https://learngeodata.eu/point-cloud-processor-formation/" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd jd gy z fp nr fr fs ns fu fw jc bi translated">点云处理在线课程- 3D地理数据学院</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">编队学习先进的点云处理和三维自动化。开发新的python地理数据技能和开源…</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">learngeodata.eu</p></div></div><div class="nv l"><div class="qb l nx ny nz nv oa lx nm"/></div></div></a></div><h2 id="8609" class="oh mn it bd mo ov ow dn ms ox oy dp mw la oz pa my le pb pc na li pd pe nc iz bi translated">参考</h2><p id="4b4a" class="pw-post-body-paragraph kr ks it kt b ku ne kd kw kx nf kg kz la ng lc ld le nh lg lh li ni lk ll lm im bi translated">1.贝尔纳迪尼，女；米特勒曼，j。拉什迈尔；席尔瓦角；表面重建的球旋转算法。<em class="om">可视化与计算机图形学汇刊</em> <strong class="kt jd"> 1999 </strong>，<em class="om"> 5 </em>，349–359。</p><p id="d4ac" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">2.卡日丹，m；波利索，m；泊松表面重建。<em class="om">欧洲几何图形研讨会</em> <strong class="kt jd"> 2006 </strong>，1–10。</p></div></div>    
</body>
</html>