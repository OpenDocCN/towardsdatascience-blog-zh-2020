<html>
<head>
<title>Data analysis made easy: Text2Code for Jupyter notebook</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据分析变得简单:Jupyter 笔记本的 text 2 代码</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/data-analysis-made-easy-text2code-for-jupyter-notebook-5380e89bb493?source=collection_archive---------12-----------------------#2020-09-06">https://towardsdatascience.com/data-analysis-made-easy-text2code-for-jupyter-notebook-5380e89bb493?source=collection_archive---------12-----------------------#2020-09-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/d25c187c75e0e731e9f390e15fa1a7f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aDP4Jc3SYjhJ6x_IQGFOhA.png"/></div></div></figure><figure class="kc kd ke kf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi kb"><img src="../Images/6d7624cff5af4fd7820d0574046f4b3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*LiR1Sg1nqCeWJ4kEUKZ8XQ.gif"/></div></div><p class="kg kh gj gh gi ki kj bd b be z dk translated">运行中的插件示例</p></figure><h2 id="8a24" class="kk kl it bd km kn ko dn kp kq kr dp ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated"><strong class="ak">灵感:GPT-3 </strong></h2><p id="7c0b" class="pw-post-body-paragraph lg lh it li b lj lk ll lm ln lo lp lq kt lr ls lt kx lu lv lw lb lx ly lz ma im bi translated">2020 年 6 月，OpenAI 推出了他们的新模型 GPT-3，它不仅具有未来的 NLP(自然语言处理)能力，还能够生成<a class="ae mb" href="https://twitter.com/sharifshameem/status/1284421499915403264?lang=en" rel="noopener ugc nofollow" target="_blank">反应代码</a>并简化<a class="ae mb" href="https://twitter.com/super3/status/1284567835386294273" rel="noopener ugc nofollow" target="_blank">命令行命令</a>。</p><p id="8440" class="pw-post-body-paragraph lg lh it li b lj mc ll lm ln md lp lq kt me ls lt kx mf lv lw lb mg ly lz ma im bi translated">观看这些演示对我们来说是一个巨大的鼓舞，我们意识到在进行数据分析时，很多时候，<strong class="li iu">我们经常忘记不常用的熊猫或 plotly 语法，需要搜索它们</strong>。从 StackOverflow 复制代码需要相应地修改变量和列名。我们开始探索能够为人工查询生成现成代码的东西，比如:</p><blockquote class="mh mi mj"><p id="9e2a" class="lg lh mk li b lj mc ll lm ln md lp lq ml me ls lt mm mf lv lw mn mg ly lz ma im bi translated">在数据帧 df 的热图中显示降雨量和湿度</p></blockquote><p id="cf23" class="pw-post-body-paragraph lg lh it li b lj mc ll lm ln md lp lq kt me ls lt kx mf lv lw lb mg ly lz ma im bi translated">或者</p><blockquote class="mh mi mj"><p id="dc4a" class="lg lh mk li b lj mc ll lm ln md lp lq ml me ls lt mm mf lv lw mn mg ly lz ma im bi translated">按州对 df 进行分组，并获取用户年龄的平均值和最大值</p></blockquote><p id="4ec7" class="pw-post-body-paragraph lg lh it li b lj mc ll lm ln md lp lq kt me ls lt kx mf lv lw lb mg ly lz ma im bi translated">Snippets 是我们使用了一段时间的一个扩展，但是在使用了一定数量的 Snippets 之后，UI 变得不直观了。虽然静态模板很好，但是我们需要更多的东西来处理用例的动态特性。</p><figure class="kc kd ke kf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mo"><img src="../Images/d9407315210b88d237314303ed642650.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NWpmHw7_bVXmgggM.gif"/></div></div><p class="kg kh gj gh gi ki kj bd b be z dk translated">代码段扩展示例</p></figure><p id="0e90" class="pw-post-body-paragraph lg lh it li b lj mc ll lm ln md lp lq kt me ls lt kx mf lv lw lb mg ly lz ma im bi translated">为此，我们决定尝试建造一个新的 jupyter 扩展。不幸的是，我们没有 GPT-3 的测试版，所以使用那个神奇的模型不是一个选项。</p><h1 id="d658" class="mp kl it bd km mq mr ms kp mt mu mv ks mw mx my kw mz na nb la nc nd ne le nf bi translated">简化任务:</h1><p id="7cd6" class="pw-post-body-paragraph lg lh it li b lj lk ll lm ln lo lp lq kt lr ls lt kx lu lv lw lb lx ly lz ma im bi translated">我们希望构建一些可以在我们的桌面上运行的东西(使用 GPU)。我们最初试图将该问题视为聊天机器人问题，并从 Rasa 开始，但由于缺乏适当的训练数据，很快就停止了。</p><p id="df49" class="pw-post-body-paragraph lg lh it li b lj mc ll lm ln md lp lq kt me ls lt kx mf lv lw lb mg ly lz ma im bi translated">由于未能建立一个真正的生成模型，我们决定开发一个监督模型，该模型可以为培训管道中定义的用例工作，并且可以很容易地扩展。受 chatbot 管道的启发，我们决定将问题简化为以下几个部分:</p><ul class=""><li id="1b93" class="ng nh it li b lj mc ln md kt ni kx nj lb nk ma nl nm nn no bi translated">生成/收集培训数据</li><li id="e92d" class="ng nh it li b lj np ln nq kt nr kx ns lb nt ma nl nm nn no bi translated">意图匹配:用户想要做什么？</li><li id="08cf" class="ng nh it li b lj np ln nq kt nr kx ns lb nt ma nl nm nn no bi translated">NER(命名实体识别):识别句子中的变量(实体)</li><li id="5120" class="ng nh it li b lj np ln nq kt nr kx ns lb nt ma nl nm nn no bi translated">填充模板:使用固定模板中提取的实体来生成代码</li><li id="c2b3" class="ng nh it li b lj np ln nq kt nr kx ns lb nt ma nl nm nn no bi translated">在 jupyter 扩展中换行</li></ul><h2 id="2759" class="kk kl it bd km kn ko dn kp kq kr dp ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">生成训练数据:</h2><p id="2b36" class="pw-post-body-paragraph lg lh it li b lj lk ll lm ln lo lp lq kt lr ls lt kx lu lv lw lb lx ly lz ma im bi translated">为了模拟最终“用户”将向系统查询什么，我们从一些我们认为自己用来描述英语命令的格式开始。例如:</p><blockquote class="mh mi mj"><p id="4484" class="lg lh mk li b lj mc ll lm ln md lp lq ml me ls lt mm mf lv lw mn mg ly lz ma im bi translated">从<strong class="li iu"> $varname </strong>开始，在 y 轴上显示<strong class="li iu"> $colname </strong>，在 x 轴上显示<strong class="li iu"> $colname </strong></p></blockquote><p id="6f7a" class="pw-post-body-paragraph lg lh it li b lj mc ll lm ln md lp lq kt me ls lt kx mf lv lw lb mg ly lz ma im bi translated">然后，我们通过使用一个非常简单的生成器替换$colname 和$varname 来生成变体，以获得训练集中的变体。</p><figure class="kc kd ke kf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nu"><img src="../Images/b7dab8bb3a315f2055bce516206a15f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aaBj7QRez3gx82nECmfLZQ.png"/></div></div><p class="kg kh gj gh gi ki kj bd b be z dk translated">一些示例(intent_id、ner 格式)</p></figure><h2 id="46da" class="kk kl it bd km kn ko dn kp kq kr dp ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">意图匹配:</h2><p id="55d8" class="pw-post-body-paragraph lg lh it li b lj lk ll lm ln lo lp lq kt lr ls lt kx lu lv lw lb lx ly lz ma im bi translated">在生成数据之后，该数据被映射为特定意图的唯一“intent_id ”,然后我们使用<a class="ae mb" href="https://tfhub.dev/google/universal-sentence-encoder/4" rel="noopener ugc nofollow" target="_blank">通用语句编码器</a>来获得用户查询的嵌入，并找到与我们预定义的意图查询(生成的数据)的余弦相似性。<code class="fe nv nw nx ny b">Universal Sentence Encoder</code>类似于生成嵌入的<code class="fe nv nw nx ny b">word2vec</code>，但是是针对句子而不是单词。</p><figure class="kc kd ke kf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nz"><img src="../Images/921e65028255e82e94fc330f908482e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AZ69_CDgBPiJvkwOnk78FA.png"/></div></div><p class="kg kh gj gh gi ki kj bd b be z dk translated">意图匹配的示例</p></figure><h2 id="0a78" class="kk kl it bd km kn ko dn kp kq kr dp ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">NER(命名实体识别):</h2><p id="1260" class="pw-post-body-paragraph lg lh it li b lj lk ll lm ln lo lp lq kt lr ls lt kx lu lv lw lb lx ly lz ma im bi translated">然后，可以使用相同的生成数据来训练定制的实体识别模型，该模型可以检测列、变量、库名称。为此，我们探索了<a class="ae mb" href="https://huggingface.co/transformers/usage.html#named-entity-recognition" rel="noopener ugc nofollow" target="_blank"> HuggingFace </a>模型，但最终使用<a class="ae mb" href="http://spacy.io/" rel="noopener ugc nofollow" target="_blank"> Spacy </a>来训练一个定制模型，主要是因为 HuggingFace 模型是基于变压器的模型，与 Spacy 相比有点重。</p><figure class="kc kd ke kf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oa"><img src="../Images/26255ca0d4d3ba71cb128d86cda078e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vFMHkWXE9hakI4kEK6U9_w.png"/></div></div><p class="kg kh gj gh gi ki kj bd b be z dk translated">实体识别示例</p></figure><h2 id="21d9" class="kk kl it bd km kn ko dn kp kq kr dp ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">填充模板:</h2><p id="3a46" class="pw-post-body-paragraph lg lh it li b lj lk ll lm ln lo lp lq kt lr ls lt kx lu lv lw lb lx ly lz ma im bi translated">一旦实体被正确识别并且意图被正确匹配，填充模板就非常容易。例如，“显示 df 中的 5 行”查询将产生两个实体:一个变量和一个数字。这方面的模板代码写起来很简单。</p><figure class="kc kd ke kf gt ju gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/996fd2043b2a075a753e85c5869ff718.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*7RjvILv8ZK_S3x-Tx1FwHA.png"/></div><p class="kg kh gj gh gi ki kj bd b be z dk translated">df.head()或 df.head(5)</p></figure><h2 id="a993" class="kk kl it bd km kn ko dn kp kq kr dp ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">与 Jupyter 集成:</h2><p id="7083" class="pw-post-body-paragraph lg lh it li b lj lk ll lm ln lo lp lq kt lr ls lt kx lu lv lw lb lx ly lz ma im bi translated">令人惊讶的是，这一个被证明是最复杂的，因为为 Jupyter 编写如此复杂的扩展有点棘手，而且几乎没有可用的文档或示例(与 HuggingFace 或 Spacy 等其他库相比)。经过一些尝试和错误，以及对现有扩展的一些复制粘贴，我们终于能够将所有东西打包成一个 python 包，可以通过<code class="fe nv nw nx ny b">pip install</code>安装</p><p id="fba6" class="pw-post-body-paragraph lg lh it li b lj mc ll lm ln md lp lq kt me ls lt kx mf lv lw lb mg ly lz ma im bi translated">我们必须创建一个前端和一个服务器扩展，当<code class="fe nv nw nx ny b">jupyter notebook</code>被触发时，它就会被加载。前端将查询发送到服务器以获取生成的模板代码，然后将其插入到单元中并执行它。</p><h2 id="a3cf" class="kk kl it bd km kn ko dn kp kq kr dp ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">演示:</h2><p id="37cf" class="pw-post-body-paragraph lg lh it li b lj lk ll lm ln lo lp lq kt lr ls lt kx lu lv lw lb lx ly lz ma im bi translated">演示视频由<a class="oc od ep" href="https://medium.com/u/a08b1e531f9c?source=post_page-----5380e89bb493--------------------------------" rel="noopener" target="_blank"> Sanyam Bhutani </a>在<a class="ae mb" href="https://www.kaggle.com/rohanrao/chai-time-data-science?select=Episodes.csv" rel="noopener ugc nofollow" target="_blank"> Chai Time 数据科学</a>数据集上制作。</p><figure class="kc kd ke kf gt ju"><div class="bz fp l di"><div class="oe of l"/></div><p class="kg kh gj gh gi ki kj bd b be z dk translated">支持的命令的简短视频</p></figure><h2 id="69fa" class="kk kl it bd km kn ko dn kp kq kr dp ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">局限性:</h2><p id="f66f" class="pw-post-body-paragraph lg lh it li b lj lk ll lm ln lo lp lq kt lr ls lt kx lu lv lw lb lx ly lz ma im bi translated">像许多 ML 模型一样，有时意图匹配和 NER 失败得很惨，即使意图对人眼来说是显而易见的。我们可以尝试改善这种情况的一些领域是:</p><ul class=""><li id="4dbd" class="ng nh it li b lj mc ln md kt ni kx nj lb nk ma nl nm nn no bi translated">收集/生成更高质量的英语句子训练数据。是一种我们还没有尝试过的技术，可以产生不同的方式来说同一个句子。</li><li id="8372" class="ng nh it li b lj np ln nq kt nr kx ns lb nt ma nl nm nn no bi translated">收集真实世界的变量名、库名，而不是随机生成它们。</li><li id="fcab" class="ng nh it li b lj np ln nq kt nr kx ns lb nt ma nl nm nn no bi translated">尝试用基于变压器的模型 NER。</li><li id="56a5" class="ng nh it li b lj np ln nq kt nr kx ns lb nt ma nl nm nn no bi translated">有了足够的数据，训练一个语言模型，像 GPT-3 那样直接做英语-&gt;代码，而不是在流水线中有单独的阶段。</li></ul></div><div class="ab cl og oh hx oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="im in io ip iq"><p id="3363" class="pw-post-body-paragraph lg lh it li b lj mc ll lm ln md lp lq kt me ls lt kx mf lv lw lb mg ly lz ma im bi translated">那都是乡亲们！</p><p id="2b00" class="pw-post-body-paragraph lg lh it li b lj mc ll lm ln md lp lq kt me ls lt kx mf lv lw lb mg ly lz ma im bi translated">我希望你喜欢读这篇文章。这个扩展的全部代码已经准备好安装在本地 GPU 机器上，在这里可以找到<a class="ae mb" href="https://github.com/deepklarity/jupyter-text2code" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="c86e" class="pw-post-body-paragraph lg lh it li b lj mc ll lm ln md lp lq kt me ls lt kx mf lv lw lb mg ly lz ma im bi translated">Deepak 和我一起花了几个周末黑了这个。这些代码还不能用于生产，但是已经足够好了，人们可以自己修改和使用。我们希望听到反馈和改进意见。:)</p></div></div>    
</body>
</html>