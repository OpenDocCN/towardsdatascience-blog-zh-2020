<html>
<head>
<title>Deploy Any Python Project to Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将任何 Python 项目部署到 Kubernetes</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/deploy-any-python-project-to-kubernetes-2c6ad4d41f14?source=collection_archive---------16-----------------------#2020-04-15">https://towardsdatascience.com/deploy-any-python-project-to-kubernetes-2c6ad4d41f14?source=collection_archive---------16-----------------------#2020-04-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bb3c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">是时候深入 Kubernetes，使用这个成熟的项目模板将您的 Python 项目带到云中了！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/02ea9eca0dd8f25f68dbf74bb8fa3404.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CV-VVMuRILKD0sf2Ctywxg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@arstyy?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">奥斯汀·尼尔</a>在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的原始照片</p></figure><p id="4c07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着项目的增长，它可能会变得难以用单个虚拟机或一些简单的 SaaS 解决方案来处理。你可以通过切换到更强大的解决方案来解决这个问题，如<em class="lv"> Kubernetes </em>。然而，如果你不熟悉它的概念或者以前从未使用过它，这可能会有点太复杂。因此，为了帮助您——在本文中——我们将介绍您入门并在集群上部署您的<em class="lv"> Python </em>项目所需的所有内容——包括集群设置、所有的<em class="lv"> Kubernetes </em>清单和一些额外的自动化，以使您的生活更加轻松！</p><p id="988c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">这是上一篇关于</em> <a class="ae ky" rel="noopener" target="_blank" href="/automating-every-aspect-of-your-python-project-6517336af9da"> <em class="lv">自动化您的 Python 项目</em> </a> <em class="lv">的每一个方面的文章的后续，所以在阅读本文之前，您可能想要检查一下。</em></p><p id="8cd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">TL；博士:这是我的储存库，里面有完整的源代码和文档:</em><a class="ae ky" href="https://github.com/MartinHeinz/python-project-blueprint" rel="noopener ugc nofollow" target="_blank">【https://github.com/MartinHeinz/python-project-blueprint】T21</a></p><h1 id="5160" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">舒适的开发设置</h1><p id="8e6e" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">为了在你的开发过程中富有成效，你需要有一个舒适的本地开发环境。在这种情况下，这意味着在本地使用简单的<em class="lv"> Kubernetes </em>，密切镜像您的真实生产集群，为此，我们将使用<em class="lv">种类</em>:</p><p id="95d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">KinD(Kubernetes-in-Docker)</em>顾名思义，在<em class="lv"> Docker </em>容器中运行<em class="lv"> Kubernetes </em>集群。它是<em class="lv"> Kubernetes </em>维护人员用于<em class="lv"> Kubernetes </em> v1.11+一致性测试的官方工具。它支持多节点集群以及高可用性集群。因为在<em class="lv"> Docker </em>中运行<em class="lv"> K8s </em>，<em class="lv"> KinD </em>可以在 Windows、Mac、Linux 上运行。所以，你可以在任何地方运行它，你只需要安装 Docker。</p><p id="1b1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，让我们安装<em class="lv">类</em>(在 Linux 上——如果你在 Windows 上，在这里看安装信息<a class="ae ky" href="https://github.com/kubernetes-sigs/kind#installation-and-usage" rel="noopener ugc nofollow" target="_blank">):</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="8fb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，我们就可以设置我们的集群了。为此，我们需要以下 YAML 文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="d4a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这份清单描述了我们的星团。它将有 3 个节点—控制平面(<code class="fe mv mw mx my b">role: control-plane</code>)和 2 个工作者<code class="fe mv mw mx my b">role: worker</code>。我们还为它提供了一些更多的设置和参数，以便以后可以设置入口控制器，这样我们就可以在该集群上拥有 HTTPS。关于这些设置，您需要知道的只是<code class="fe mv mw mx my b">extraPortMappings</code>告诉集群将端口从主机转发到节点上运行的入口控制器。</p><p id="09d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">注意:集群和 Python 应用程序的所有清单都可以在我的仓库</em> <a class="ae ky" href="https://github.com/MartinHeinz/python-project-blueprint" rel="noopener ugc nofollow" target="_blank"> <em class="lv">中找到，这里是</em> </a> <em class="lv">中的</em> <code class="fe mv mw mx my b"><em class="lv">k8s</em></code> <em class="lv">目录。</em></p><p id="186b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们需要运行几个命令来启动它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="a063" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要创建集群，我们只需要运行第一个命令。之后，我们可以通过运行<code class="fe mv mw mx my b">cluster-info</code>和<code class="fe mv mw mx my b">get nodes</code>命令来检查是否可以运行。一段时间后，输入这些命令会变得很烦人，所以我们以后会更简单，但这样我们就可以启动并运行集群了。</p><p id="fd70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们要为我们的集群设置<a class="ae ky" href="https://kubernetes.io/docs/concepts/services-networking/ingress/" rel="noopener ugc nofollow" target="_blank">入口</a>。为此，我们必须运行一些<code class="fe mv mw mx my b">kubectl</code>命令，使其与<em class="lv">类</em>一起工作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="828b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们部署强制性的<code class="fe mv mw mx my b">ingress-nginx</code>组件。最重要的是，我们使用<em class="lv">节点端口</em>来公开<em class="lv"> nginx </em>服务，这就是第二个命令所做的。最后一个命令为入口控制器应用一些<em class="lv">类</em>特定补丁。</p><h1 id="02e6" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">定义清单</h1><p id="54fc" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">集群就绪后，就该设置和部署我们的应用程序了。为此，我们将使用非常简单的<em class="lv"> Flask </em>应用程序— <em class="lv"> echo 服务器</em>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="a247" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我选择了<em class="lv"> Flask </em>应用程序，而不是一些 CLI 工具(或<em class="lv"> Python </em>包)，因为我们需要不会像一些<em class="lv"> Python </em>包那样立即终止的应用程序。另外，请注意<code class="fe mv mw mx my b">host</code>参数被设置为<code class="fe mv mw mx my b">0.0.0.0</code>，如果没有这个参数，当我们通过<em class="lv"> Kubernetes </em>服务和入口公开应用程序时，将无法访问它。</p><p id="e836" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来我们需要的是这个应用程序的 YAML 清单，让我们把它分成单独的对象:</p><ul class=""><li id="5376" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">命名空间:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="7fb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里没什么好谈的。我们通常不希望在<code class="fe mv mw mx my b">default</code>名称空间中部署应用程序，所以我们将使用这个名称空间。</p><ul class=""><li id="bad3" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">配置映射:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="76a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们可以为应用程序定义变量的地方。这些来自<code class="fe mv mw mx my b">data</code>部分的变量将作为环境变量注入到应用程序容器中。作为一个例子，我包括了<code class="fe mv mw mx my b">FLASK_ENV</code>和<code class="fe mv mw mx my b">FLASK_DEBUG</code>，当应用程序启动时，它们将被<em class="lv">烧瓶</em>自动拾取。</p><ul class=""><li id="9ad9" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">秘密:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="c2fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与我们指定纯文本变量的方式相同，我们可以使用<em class="lv"> Secret </em>向我们的应用程序添加凭证和密钥之类的东西。但是，不应该将该对象推送到您的存储库中，因为它包含敏感数据。我们可以使用以下命令动态创建它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="a6ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">注意:部署应用程序所需的此命令和其他命令列在存储库中的 README 以及底部清单文件</em> <a class="ae ky" href="https://github.com/MartinHeinz/python-project-blueprint/blob/master/k8s/app.yaml" rel="noopener ugc nofollow" target="_blank"> <em class="lv">中，此处为</em> </a> <em class="lv">。</em></p><ul class=""><li id="fb3c" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">部署:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk">.</p></figure><p id="cea0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在是最重要的部分——部署。这里的相关部分是指定图像、端口和环境变量的<code class="fe mv mw mx my b">spec</code>部分。对于<code class="fe mv mw mx my b">image</code>，我们指定来自<em class="lv"> Docker Hub </em>的图像。如果我们想使用像<em class="lv"> Artifactory </em>这样的私有注册表，我们就必须添加<code class="fe mv mw mx my b">imagePullSecret</code>来提供集群获取映像的凭证。可以使用以下命令创建该密码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="bbcb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这显示了您如何允许从<em class="lv"> GitHub 包注册表</em>中提取您的映像，不幸的是，由于上述 YAML 中列出的问题，它现在不能与<em class="lv">类</em>一起工作，但是它可以与您在云中的生产集群一起工作(假设它没有使用<em class="lv">类</em>)。</p><p id="f8f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想避免每次重新部署应用程序时都将映像推送到远程注册表，那么您可以使用<code class="fe mv mw mx my b">kind load docker-image martinheinz/python-project-blueprint:flask</code>将<em class="lv">映像加载到集群中。</em></p><p id="ef8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe mv mw mx my b">image</code>之后，我们还指定了<code class="fe mv mw mx my b">ports</code>。这些是我们的应用程序正在监听的端口，在本例中是<code class="fe mv mw mx my b">5000</code>，因为我们的应用程序开始使用<code class="fe mv mw mx my b">app.run(host='0.0.0.0', port=5000)</code>。</p><p id="ec98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一部分，<code class="fe mv mw mx my b">envFrom</code>部分用于从上面显示的<em class="lv">配置图</em>和<em class="lv">秘密</em>中注入明文变量和秘密，通过在各自的<code class="fe mv mw mx my b">Ref</code>字段中指定它们的名称。</p><ul class=""><li id="ef7c" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">服务:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="b6e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们已经有了在<code class="fe mv mw mx my b">port</code>上监听的应用程序，我们需要<em class="lv">服务</em>来公开它。所有这些对象定义了在端口<code class="fe mv mw mx my b">5000</code>上监听的应用程序应该在端口<code class="fe mv mw mx my b">443</code>上的集群节点上公开。</p><ul class=""><li id="2840" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">入口:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="9f0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一大难题是<em class="lv">入口</em>——一个管理集群中<em class="lv">服务</em>外部访问的对象。让我们首先看看<code class="fe mv mw mx my b">rules</code>部分——在这种情况下，我们定义我们的主机是<code class="fe mv mw mx my b">localhost</code>。我们还将<code class="fe mv mw mx my b">path</code>设置为<code class="fe mv mw mx my b">/</code>，这意味着发送到<code class="fe mv mw mx my b">localhost/</code>的任何请求都属于由之前显示的<em class="lv">服务</em>及其<code class="fe mv mw mx my b">port</code>的名称定义的关联<code class="fe mv mw mx my b">backend</code>。</p><p id="f663" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的另一部分是<code class="fe mv mw mx my b">tls</code>。本节通过指定包含<code class="fe mv mw mx my b">tls.crt</code>和<code class="fe mv mw mx my b">tls.key</code>的<em class="lv">秘密</em>为列出的<code class="fe mv mw mx my b">hosts</code>提供 HTTPS。让我们创造这个<em class="lv">秘密</em>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="670e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码片段首先设置了几个变量，然后使用<code class="fe mv mw mx my b">openssl</code>为 TLS 生成证书和密钥文件。最后一个命令创建包含这两个文件的<em class="lv">秘密</em>。</p><h1 id="f99d" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">部署应用程序</h1><p id="93c3" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">准备好所有清单后，我们终于可以部署我们的应用程序了:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="a964" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的大多数命令我们已经在前面的章节中看到过了。新功能是<code class="fe mv mw mx my b">kubectl apply -f app.yaml</code>，它在我们的集群中创建了所有必要的对象。创建后，我们可以使用<code class="fe mv mw mx my b">kubectl get all</code>检查这些对象的存在。最后，我们可以使用<code class="fe mv mw mx my b">cURL</code>来检查应用程序是否是可访问的，它是可访问的！这样，我们的应用程序就可以在集群上运行了！</p><h1 id="2663" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">简单一点</h1><p id="7ad5" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">如果你还没有完全适应所有的<code class="fe mv mw mx my b">kind</code>和<code class="fe mv mw mx my b">kubectl</code>命令，或者你像我一样懒，不想把它们都打出来，那么我有几个<code class="fe mv mw mx my b">Make</code>目标给你——让你的生活更轻松:</p><ul class=""><li id="c495" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">调出集群:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><ul class=""><li id="5868" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">重新部署/重新启动应用程序:</li></ul><p id="a060" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果集群还没有准备好，那么<code class="fe mv mw mx my b">make cluster</code>命令将为您设置集群，如果准备好了，它将为您提供关于它的所有信息。如果您需要检查节点的状态并切换到您的开发名称空间，这很好。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="222e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个非常简单，它所做的只是推出新的部署，因此如果有新的映像，它将部署它，否则它将重新启动您的应用程序。</p><ul class=""><li id="c753" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">调试:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="709f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您需要调试您的应用程序，您可能想要查看与应用程序窗格相关的最近事件以及最近(上一小时)的日志。这正是<code class="fe mv mw mx my b">make cluster-debug</code>为你做的。</p><ul class=""><li id="9570" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">获取远程外壳:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="58bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果日志不足以解决您可能遇到的一些问题，并且您决定需要在容器内部探索一下，那么您可以运行<code class="fe mv mw mx my b">make cluster-rsh</code>来获得远程 shell。</p><ul class=""><li id="7ba6" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">更新清单:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="3746" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们以前见过这个命令。它只是重新应用了 YAML 清单，这在您调整<em class="lv"> Kubernetes </em>对象的一些属性时非常方便。</p><h1 id="3d55" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">结论</h1><p id="bc7e" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">这篇文章并不是 Kubernetes 的教程，但是我认为它足够让你快速启动并运行你的应用程序。为了学习更多关于 Kubernetes 的知识，我建议在清单中玩一玩，调整一下，改变一下，看看会发生什么。在我看来，这是了解事物如何工作并熟悉<code class="fe mv mw mx my b">kubectl</code>命令的好方法。如果您有任何疑问、建议或问题，请随时联系我或在我的<a class="ae ky" href="https://github.com/MartinHeinz/python-project-blueprint" rel="noopener ugc nofollow" target="_blank">资源库</a>中创建问题。在这个报告中，你还可以找到本文中显示的文档和所有清单。</p><h2 id="fd69" class="ni lx it bd ly nj nk dn mc nl nm dp mg li nn no mi lm np nq mk lq nr ns mm nt bi translated">资源</h2><ul class=""><li id="ad94" class="mz na it lb b lc mo lf mp li nu lm nv lq nw lu ne nf ng nh bi translated"><a class="ae ky" href="https://banzaicloud.com/blog/kind-ingress/" rel="noopener ugc nofollow" target="_blank">Kubernetes ingress on kind(Docker 中的 Kubernetes)</a></li><li id="c13e" class="mz na it lb b lc nx lf ny li nz lm oa lq ob lu ne nf ng nh bi translated"><a class="ae ky" href="https://kind.sigs.k8s.io/docs/user/ingress/" rel="noopener ugc nofollow" target="_blank">入口设置的种类文件</a></li></ul></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><p id="d0c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">本文最初发布于</em><a class="ae ky" href="https://martinheinz.dev/blog/20" rel="noopener ugc nofollow" target="_blank"><em class="lv">martinheinz . dev</em></a></p></div></div>    
</body>
</html>