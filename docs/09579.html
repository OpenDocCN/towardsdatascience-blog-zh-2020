<html>
<head>
<title>5 Different Meanings of Underscore in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中下划线的 5 种不同含义</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/5-different-meanings-of-underscore-in-python-3fafa6cd0379?source=collection_archive---------3-----------------------#2020-07-08">https://towardsdatascience.com/5-different-meanings-of-underscore-in-python-3fafa6cd0379?source=collection_archive---------3-----------------------#2020-07-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="66ab" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">确保使用正确的语法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0058c08a4ed000d0f564253217e00c9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*O_1yzv-RP0MXIHKE"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Erik Witsoe 在<a class="ae ky" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="b24a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated"><span class="l lw lx ly bm lz ma mb mc md di">如果</span>你是一个 Python 程序员，你可能对下划线很熟悉。Python 使用两种类型的下划线:单下划线<code class="fe me mf mg mh b">_</code>和双下划线<code class="fe me mf mg mh b">__</code>。不要小看 Python 中的下划线，这是一个非常强大的语法。在这篇文章中，我将谈论 5 种不同的下划线模式。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h2 id="4a19" class="mp mq it bd mr ms mt dn mu mv mw dp mx li my mz na lm nb nc nd lq ne nf ng nh bi translated">单个独立下划线 _</h2><p id="809c" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">单个下划线<code class="fe me mf mg mh b">_</code>是一个<a class="ae ky" href="https://docs.python.org/3/reference/lexical_analysis.html#identifiers" rel="noopener ugc nofollow" target="_blank"> Python 标识符</a>的有效字符，所以它可以用作变量名。</p><ol class=""><li id="66f4" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated"><strong class="lb iu">代表解释器中的最后一个表达式</strong></li></ol><blockquote class="nw nx ny"><p id="0241" class="kz la nz lb b lc ld ju le lf lg jx lh oa lj lk ll ob ln lo lp oc lr ls lt lu im bi translated">根据<a class="ae ky" href="https://docs.python.org/3/reference/lexical_analysis.html#reserved-classes-of-identifiers" rel="noopener ugc nofollow" target="_blank"> Python 文档</a>，在交互式解释器中使用特殊标识符<code class="fe me mf mg mh b">_</code>来存储上次评估的结果。它存储在内置模块中。</p></blockquote><p id="32ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个例子。首先，我们检查<code class="fe me mf mg mh b">_</code>没有存储在内置模块中，然后我们编写一个没有变量名的表达式。如果我们再次检查内置模块，我们会在模块中找到<code class="fe me mf mg mh b">_</code>并且值是最后一次评估。</p><pre class="kj kk kl km gt od mh oe of aw og bi"><span id="9694" class="mp mq it mh b gy oh oi l oj ok">&gt;&gt;&gt; '_' in dir(__builtins__)<br/>False<br/>&gt;&gt;&gt; 1+1<br/>2<br/>&gt;&gt;&gt; '_' in dir(__builtins__)<br/>True<br/>&gt;&gt;&gt; _<br/>2</span></pre><p id="a914" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 2。代表我们不关心的价值观</strong></p><p id="8266" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">单下划线<code class="fe me mf mg mh b">_</code>的另一个用例是表示你不关心的或者在程序后面不会用到的值。如果您将类似 Flake8 的 linter 应用到您的程序中，如果您分配了一个变量名但从未使用过，您将从 linter 得到一个错误(<a class="ae ky" href="https://flake8.pycqa.org/en/2.6.0/warnings.html" rel="noopener ugc nofollow" target="_blank"> F841 </a>)。把自己不在乎的变量赋给<code class="fe me mf mg mh b">_</code>就能解决这个问题。</p><p id="105c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一些代码。<em class="nz"> Example1 </em>使用<code class="fe me mf mg mh b">_</code>来表示列表中每个元素的索引。在<em class="nz">例 2 </em>中，我们只关心来自元组的<code class="fe me mf mg mh b">year</code>、<code class="fe me mf mg mh b">month</code>和<code class="fe me mf mg mh b">day</code>，所以把<code class="fe me mf mg mh b">_</code>赋给其余的(时、分、秒)。但是如果我们打印出<code class="fe me mf mg mh b">_</code>，我们只会得到最后一个表达式，也就是 59。</p><p id="0244" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">来自 Python 3。*，它支持<a class="ae ky" href="https://www.python.org/dev/peps/pep-3132/" rel="noopener ugc nofollow" target="_blank">扩展的可迭代解包</a>，这意味着我们可以使用<code class="fe me mf mg mh b">*_</code>来表示多个值。在<em class="nz">示例 3 </em>中，<code class="fe me mf mg mh b">_</code>实际上代表了我们想要忽略的值的列表。</p><p id="84cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Lambda 功能也支持<code class="fe me mf mg mh b">_</code>。在<em class="nz">例 4 </em>中，lambda 函数用于 monkeypatch 函数<code class="fe me mf mg mh b">random.randint</code>，并且将始终生成相同的输出。在这种情况下，输入参数不再重要。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="5037" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 3。用于数字分组的可视分隔符</strong></p><p id="0b1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从 Python 3.6 开始，下划线<code class="fe me mf mg mh b">_</code>也可以用作数字分组的可视分隔符。正如<a class="ae ky" href="https://www.python.org/dev/peps/pep-0515/" rel="noopener ugc nofollow" target="_blank"> PEP515 </a>所说，它适用于整数、浮点和复数文字。</p><pre class="kj kk kl km gt od mh oe of aw og bi"><span id="b51a" class="mp mq it mh b gy oh oi l oj ok">integer = 1_000<br/>amount = 1_000_000.1<br/>binary = 0b_0100_1110<br/>hex = 0xCAFE_F00D<br/>&gt;&gt;&gt; print(amount)<br/>1000000.1<br/>&gt;&gt;&gt; print(binary)<br/>78<br/>&gt;&gt;&gt; print(hex)<br/>3405705229</span></pre></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h2 id="92aa" class="mp mq it bd mr ms mt dn mu mv mw dp mx li my mz na lm nb nc nd lq ne nf ng nh bi translated">单前导下划线 _var</h2><blockquote class="nw nx ny"><p id="1db8" class="kz la nz lb b lc ld ju le lf lg jx lh oa lj lk ll ob ln lo lp oc lr ls lt lu im bi translated">根据<a class="ae ky" href="https://www.python.org/dev/peps/pep-0008/" rel="noopener ugc nofollow" target="_blank"> PEP8 </a>，单前导下划线<code class="fe me mf mg mh b">_var</code>供内部使用。从 M 导入*不导入名称以下划线开头的对象。</p></blockquote><p id="ec7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe me mf mg mh b">_</code>在变量或方法名前是一个弱内部使用指示器。它警告开发人员不要公开导入和使用这个变量、方法或函数。然而，Python 并没有完全阻止它们被导入和使用。</p><p id="a83f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的例子中，我们有一个公共变量<code class="fe me mf mg mh b">external</code>和一个私有变量<code class="fe me mf mg mh b">_internal</code>。如果我们做<em class="nz">通配符导入</em> <code class="fe me mf mg mh b">from m import *</code>，不包括<code class="fe me mf mg mh b">_internal</code>变量(main1.py)。但是如果我们显式导入<code class="fe me mf mg mh b">_internal</code>(main 2 . py)或者使用<em class="nz">常规导入</em> (main3.py)就可以了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/56d949910ef69b5c7a60df66505c2099" rel="noopener ugc nofollow" target="_blank">下划线-单前导. py </a></p></figure><p id="a2ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">单个前导下划线在类中被大量使用。程序员可以创建<em class="nz">私有</em>变量和方法，但是和前面的例子一样，这些变量和方法仍然可以从外部使用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/4bfc051dfc49c7969759ca22ba2a02fb" rel="noopener ugc nofollow" target="_blank">下划线-单前导-class.py </a></p></figure><p id="0dc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一般来说，单个前导下划线只是一种命名约定，表示变量或函数供内部使用。如果程序员真的想的话，他们仍然可以导入这个名字。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h2 id="25ed" class="mp mq it bd mr ms mt dn mu mv mw dp mx li my mz na lm nb nc nd lq ne nf ng nh bi translated">单个尾随下划线<code class="fe me mf mg mh b">var_</code></h2><p id="27cb" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">使用单个尾随下划线的原因只有一个，那就是避免与 Python 关键字冲突。这在<a class="ae ky" href="https://www.python.org/dev/peps/pep-0008/" rel="noopener ugc nofollow" target="_blank"> PEP8 </a>中也有提及。</p><p id="3659" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用<code class="fe me mf mg mh b">keyword</code>模块来检查 Python 中的关键字列表。如果你想给一个变量名叫做<code class="fe me mf mg mh b">global</code>，那么你应该把它命名为<code class="fe me mf mg mh b">gloabl_</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/31c1a41ebc33e9cd25381ae595580dd7" rel="noopener ugc nofollow" target="_blank">下划线-关键字. py </a></p></figure></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h2 id="eb3e" class="mp mq it bd mr ms mt dn mu mv mw dp mx li my mz na lm nb nc nd lq ne nf ng nh bi translated">双前导下划线<code class="fe me mf mg mh b">__var</code></h2><p id="3adf" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">到目前为止，我们讨论的模式基本上是不同的命名约定，但是使用双前导下划线，Python 的行为会有所不同。</p><p id="8787" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python 解释器将对带有前导下划线的标识符进行名称处理。<strong class="lb iu">名称篡改是在一个类中覆盖这些标识符的过程，以避免当前类及其子类之间的名称冲突。</strong></p><p id="657c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">综上所述，<code class="fe me mf mg mh b">__var</code>在类中会有不同的名字。让我们看看下面的例子。该示例使用内置函数<code class="fe me mf mg mh b"><a class="ae ky" href="https://docs.python.org/3/library/functions.html#dir" rel="noopener ugc nofollow" target="_blank">dir</a></code>返回当前本地范围内的名称列表。在列表的最后，我们看到了<code class="fe me mf mg mh b">_hour</code>、<code class="fe me mf mg mh b">day</code>、<code class="fe me mf mg mh b">month</code>和<code class="fe me mf mg mh b">year</code>，这意味着我们可以通过<code class="fe me mf mg mh b">time._hour</code>或<code class="fe me mf mg mh b">time.year</code>直接检索这些属性。</p><p id="6e06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，对于<code class="fe me mf mg mh b">__minute</code>，它却另有故事。其名称被覆盖为<code class="fe me mf mg mh b">_Time__minute</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/f747c5738e690df8914f297ddc1edf8b" rel="noopener ugc nofollow" target="_blank">下划线-双前导. py </a></p></figure><p id="b20b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将产生两个后果:</p><ol class=""><li id="f561" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">属性<code class="fe me mf mg mh b">__day</code>在类<code class="fe me mf mg mh b">Time</code>之外不可访问。如你所见，<code class="fe me mf mg mh b">__day</code>没有被<code class="fe me mf mg mh b">Time</code>类识别，它被替换为<code class="fe me mf mg mh b">_Time__day</code>。</li></ol><pre class="kj kk kl km gt od mh oe of aw og bi"><span id="d29e" class="mp mq it mh b gy oh oi l oj ok">print(time.__day)</span><span id="60b1" class="mp mq it mh b gy on oi l oj ok"># AttributeError: 'Time' object has no attribute '__day'</span><span id="9475" class="mp mq it mh b gy on oi l oj ok">print(time._Time__day)<br/># 10</span></pre><p id="0051" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.属性<code class="fe me mf mg mh b">__day</code>不能在<code class="fe me mf mg mh b">Time</code>的子类中被覆盖。在下面的例子中，我们创建了一个从类<code class="fe me mf mg mh b">Time</code>扩展而来的子类<code class="fe me mf mg mh b">TimeSubClass</code>，并使用<code class="fe me mf mg mh b">dir</code>来检查本地名称。</p><p id="5024" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在输出中，你可以找到<code class="fe me mf mg mh b">_TimeSubclass__day</code>、<code class="fe me mf mg mh b">_Time__day</code>、<code class="fe me mf mg mh b">_month</code>和<code class="fe me mf mg mh b">year</code>。这意味着<code class="fe me mf mg mh b">_month</code>和<code class="fe me mf mg mh b">year</code>已经被新值覆盖，但<code class="fe me mf mg mh b">__day</code>没有。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/1745f0dfa4d1bc97e83387cf32a20737" rel="noopener ugc nofollow" target="_blank">下划线-双前导-subclass.py </a></p></figure><p id="2397" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们检查一下数值。<code class="fe me mf mg mh b">_TimeSubclass__day</code>被赋予新值，而<code class="fe me mf mg mh b">_Time__day</code>仍为原始值。</p><pre class="kj kk kl km gt od mh oe of aw og bi"><span id="1dff" class="mp mq it mh b gy oh oi l oj ok">print(time_subclass._TimeSubclass__day)<br/># 30<br/>print(time_subclass._Time__day)<br/># 1</span></pre><p id="4154" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然不能通过直接访问获得值，但是仍然可以通过方法获得值，在方法中，返回<code class="fe me mf mg mh b">self.__day</code>。对<code class="fe me mf mg mh b">@property</code>也有效。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/2bf0645235fd57720d77e11f01deac39" rel="noopener ugc nofollow" target="_blank">下划线-double-method.py </a></p></figure></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h2 id="4894" class="mp mq it bd mr ms mt dn mu mv mw dp mx li my mz na lm nb nc nd lq ne nf ng nh bi translated">双前导和尾随下划线<code class="fe me mf mg mh b">__var__</code></h2><p id="a382" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">与单尾随下划线不同，双尾随下划线没有特殊含义。你大概可以把<code class="fe me mf mg mh b">var__</code>看成是<code class="fe me mf mg mh b">var_</code>的延伸。</p><p id="cca7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，双前导和尾部下划线<code class="fe me mf mg mh b">__var__</code>是完全不同的，它是 Python 中非常重要的模式。Python 不会对这样的属性应用名称处理，但是带有双前导和尾随下划线的<strong class="lb iu">名称在 Python </strong>中是为特殊用途而保留的。他们被称为<strong class="lb iu">神奇的名字。</strong>你可以查看<a class="ae ky" href="https://docs.python.org/3/reference/datamodel.html" rel="noopener ugc nofollow" target="_blank"> Python 文档</a>来获得魔法名称列表。像<code class="fe me mf mg mh b">__init__</code>、<code class="fe me mf mg mh b">__call__</code>、<code class="fe me mf mg mh b">__slots__</code>这些名字都是神奇的方法。</p><p id="916c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些魔法属性和魔法方法是允许被覆盖的，但是你需要知道你在做什么。让我们看一个例子。<code class="fe me mf mg mh b">__str__</code>是一个返回对象的字符串表示的方法。当你做<code class="fe me mf mg mh b">print()</code>或者<code class="fe me mf mg mh b">str()</code>的时候这个方法被调用。在这个例子中，我们覆盖了字符串表示，然后我们将在输出中得到一个新的格式。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/highsmallxu/9643fdb67fcee926fa213c4e6cf5a455" rel="noopener ugc nofollow" target="_blank">下划线-双前导-尾随. py </a></p></figure><p id="a3df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以有一个自定义的名字，像<code class="fe me mf mg mh b">__day__</code>一样有双下划线。Python 会把它作为一个常规的属性名，不会对它应用名称篡改。但是，没有很强的理由就起这样的名字，并不是一个好的做法。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h2 id="733f" class="mp mq it bd mr ms mt dn mu mv mw dp mx li my mz na lm nb nc nd lq ne nf ng nh bi translated">结论</h2><p id="c616" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在本文中，我们讨论了 Python 中下划线的 5 种不同模式。我们来总结一下。</p><ol class=""><li id="a03b" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">单独立下划线<code class="fe me mf mg mh b">_</code>T12】单前导下划线<code class="fe me mf mg mh b">_var</code>T13】单尾随下划线<code class="fe me mf mg mh b">var_</code>。</li></ol><p id="1999" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">带有单下划线的模式基本上是命名约定。Python 解释器不会阻止它们在模块/类之外被导入和使用。</p><p id="5523" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.双前导下划线<code class="fe me mf mg mh b">__var</code>T14】双前导和尾随下划线<code class="fe me mf mg mh b">__var__</code>。</p><p id="fa6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">带有双下划线的模式更加严格。它们要么不允许被覆盖，要么需要一个好的理由来这样做。请注意，双尾下划线<code class="fe me mf mg mh b">var__</code>没有特殊含义。</p><p id="615a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢这篇文章！如果你有任何想法，请在下面留下你的评论。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h2 id="b416" class="mp mq it bd mr ms mt dn mu mv mw dp mx li my mz na lm nb nc nd lq ne nf ng nh bi translated">参考</h2><div class="oo op gp gr oq or"><a href="https://www.datacamp.com/community/tutorials/role-underscore-python" rel="noopener  ugc nofollow" target="_blank"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd iu gy z fp ow fr fs ox fu fw is bi translated">下划线(_)在 Python 中的作用</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">许多 Python 开发人员不知道中下划线(_)的功能。它帮助用户编写 Python…</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">www.datacamp.com</p></div></div><div class="pa l"><div class="pb l pc pd pe pa pf ks or"/></div></div></a></div><div class="oo op gp gr oq or"><a href="https://dbader.org/blog/meaning-of-underscores-in-python" rel="noopener  ugc nofollow" target="_blank"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd iu gy z fp ow fr fs ox fu fw is bi translated">Python-dbader.org 中下划线的含义</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">Python 中单下划线和双下划线(“dunder”)的各种含义和命名约定，如何命名…</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">dbader.org</p></div></div><div class="pa l"><div class="pg l pc pd pe pa pf ks or"/></div></div></a></div></div></div>    
</body>
</html>