<html>
<head>
<title>AI in Industry: How to use sensors’ accuracy to create augmented data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">工业中的人工智能:如何利用传感器的准确性来创建增强数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/ai-in-industry-how-to-use-sensors-accuracy-to-create-augmented-data-86c685a98379?source=collection_archive---------88-----------------------#2020-06-15">https://towardsdatascience.com/ai-in-industry-how-to-use-sensors-accuracy-to-create-augmented-data-86c685a98379?source=collection_archive---------88-----------------------#2020-06-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="500d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">了解如何通过估算传感器的准确性来扩充数据集，从而克服标注数据的不足。本文通过使用Tensorflow和Scikit-learn在一个工业案例上的实际实现来说明。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/88467fac3bf58a110d1408083b4fe349.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cn_W7na0HXorjtUK"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated"><a class="ae le" href="https://unsplash.com/@spacexuan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">郭锦恩</a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><blockquote class="lf"><p id="04c1" class="lg lh it bd li lj lk ll lm ln lo kn dk translated">深度学习算法确实需要大量的数据！(委婉……)</p></blockquote><p id="9cff" class="pw-post-body-paragraph jq jr it js b jt lp jv jw jx lq jz ka kb lr kd ke kf ls kh ki kj lt kl km kn im bi translated">当可用的标记数据不足以达到良好的准确度水平时，用于图像识别的标准技术是创建“增强图片”。</p><p id="18a1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">原理很简单:你可以创建同一只狗的人工图片，并进行或多或少的细微变化，这将有助于你的模型微调其网络权重，并最终提高其准确性，而不是只给你的深度学习算法提供一张狗的图片。</p><p id="88c9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">原始图片的经典修改将会以以下形式出现:</p><ul class=""><li id="c9dc" class="lu lv it js b jt ju jx jy kb lw kf lx kj ly kn lz ma mb mc bi translated"><strong class="js iu">对称(水平、垂直)</strong></li><li id="6557" class="lu lv it js b jt md jx me kb mf kf mg kj mh kn lz ma mb mc bi translated"><strong class="js iu">旋转(角度)</strong></li><li id="2285" class="lu lv it js b jt md jx me kb mf kf mg kj mh kn lz ma mb mc bi translated"><strong class="js iu">宽度或高度移动</strong></li><li id="03d1" class="lu lv it js b jt md jx me kb mf kf mg kj mh kn lz ma mb mc bi translated"><strong class="js iu">缩放、剪切、颜色或亮度变化</strong></li></ul><p id="3a64" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它们可以用<a class="ae le" href="https://keras.io/api/preprocessing/image/#imagedatagenerator-class" rel="noopener ugc nofollow" target="_blank"> Tensorflow </a>中的几行代码轻松实现:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/5bcc627072fdfa02d29a72effb0f72fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*FQ67n4sIbNJ5t2i6CMv2Og.jpeg"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">伯爵，我可爱的狗🐶(原图)</p></figure><pre class="kp kq kr ks gt mj mk ml mm aw mn bi"><span id="9657" class="mo mp it mk b gy mq mr l ms mt">from tensorflow.keras.preprocessing.image import ImageDataGenerator</span><span id="2d31" class="mo mp it mk b gy mu mr l ms mt">train_datagen = ImageDataGenerator(<br/>    rotation_range=10,<br/>    horizontal_flip=True,<br/>    vertical_flip=False,<br/>    width_shift_range=0.1,<br/>    height_shift_range=0.1,<br/>    #zoom_range=0.2,<br/>    #brightness_range=(0.1, 0.9),<br/>    #shear_range=15<br/>    )</span></pre><p id="1f19" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我总是对我的狗很好(即使是虚拟的！)所以我故意限制了转换！</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mv"><img src="../Images/9ee4b6a372be8a95906215864d4ce06d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fiS8FK2MwNGMu-ktQWUlsg.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">扩增克隆人伯爵！</p></figure><p id="8396" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">很容易理解，这种机制对于图片来说是合理的，因为这些变化不会影响主体</strong>，并且它还将帮助您的模型解释具有不同方向、颜色等的狗图片..</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="7ecf" class="nd mp it bd ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny nz bi translated"><strong class="ak">是否有可能将该技术应用于工业过程数据，以达到更高水平的预测准确度？</strong></h1><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/52c7c360d6d861452e1624e021ad6e83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xQQAX7nmJtHysr1P"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">照片由<a class="ae le" href="https://unsplash.com/@spacexuan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">郭锦恩</a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="0c53" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们探索一个我过去工作过的用例。数据集(经过净化、规范化和预处理)存储在<a class="ae le" href="https://drive.google.com/file/d/1-0b5dL9sCobVOGu1czYvxSUex2ArGmJa/view?usp=sharing" rel="noopener ugc nofollow" target="_blank">这里</a>并且具有250 x 52的形状。</p><p id="abc2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">尽管每周7天、每天24小时、每30秒测量一次工艺参数，但由于获取一个样品的难度和成本，对应于最终产品浓度的标签数量是有限的。采样频率通常在3到4天左右。</p><p id="a70e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个小数据集的每一行都对应于在获取样本之前的最后30分钟内过程参数的平均值。</p><p id="df62" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在评估了“经典”机器学习模型(RandomForest、SVM和GradientBoostedRegressor)之后，我惊讶地发现，根据所选的度量标准:<strong class="js iu">平均绝对误差</strong>，一个简单的Keras模型正在实现最佳精度。</p><p id="fb65" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个“不太深”的学习架构设计如下:</p><pre class="kp kq kr ks gt mj mk ml mm aw mn bi"><span id="bb02" class="mo mp it mk b gy mq mr l ms mt">model = keras.Sequential([<br/># The 1st layer as the same shape as the number of input features<br/>        layers.Dense(df.shape[1],<br/>                     activation='relu',<br/>                     input_shape=[X.shape[1]]),<br/>        layers.BatchNormalization(),<br/>        layers.Dense(12, activation='relu'),<br/>        layers.BatchNormalization(),<br/>        layers.Dense(1)<br/>])</span></pre><p id="ad8a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">深度学习模型没有嵌入式交叉验证方法，因为在处理大量数据时通常不需要。</p><p id="9c73" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">然而，当处理这样的小数据集时，训练/测试分割操作可以输出非常不同的配置，并且确实需要一个。</strong></p><p id="191f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">经过5 k倍交叉验证后，该Keras模型的平均绝对误差达到了<strong class="js iu"> 2.4 </strong>(相当于4%的相对误差)。</p><p id="63e5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">是的，这不是一个非常高的精度，但从现场的角度来看，这仍然意味着从"<strong class="js iu">盲目地在每个样品之间"</strong>"切换到"<strong class="js iu">"在每一个时刻获得一个非常好的产品浓度估计值！</strong>”</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><p id="5269" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们来看看这篇文章的核心:<strong class="js iu">我们的样本测量过程的统计评估(通过ANOVA gauge R &amp; R)确定了一个</strong> <strong class="js iu"> 2%的相对准确度。</strong></p><p id="a2a3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">简而言之，当我们测量100时，真实值可能是98到102之间的任何值。</p><p id="b29d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我与一位专门从事深度学习和图像识别的数据科学家同事讨论时，我抱怨说，我不可能像他那样为工业过程产生增强数据！</p><p id="1d0c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这就是他建议利用传感器的准确性来创造人为值的时候！</p><pre class="kp kq kr ks gt mj mk ml mm aw mn bi"><span id="fe84" class="mo mp it mk b gy mq mr l ms mt"><strong class="mk iu">X1, X2, X3, ..., X51 =&gt; Sample measurement at 100</strong></span><span id="ae6a" class="mo mp it mk b gy mu mr l ms mt">could actually corresponds to:</span><span id="8caf" class="mo mp it mk b gy mu mr l ms mt"><strong class="mk iu">X1, X2, X3, ..., X51 =&gt; Sample measurement at 98</strong><br/>or<br/><strong class="mk iu">X1, X2, X3, ..., X51 =&gt; Sample measurement at 99.5</strong><br/>or<br/><strong class="mk iu">X1, X2, X3, ..., X51 =&gt; Sample measurement at 100.2</strong><br/>or<br/><strong class="mk iu">X1, X2, X3, ..., X51 =&gt; Sample measurement at 101</strong><br/>etc.</span></pre><p id="970c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">问题是:它是否会帮助我们的模型获得比仅用初始数据集训练时更高的精度？</p><p id="8512" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">答案是…</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oa"><img src="../Images/2d64aecd4765e302d2080d02c9facb9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zhV4rrYkn8opVaL3"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">乔恩·泰森在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="b2d7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">至少，对于这个非常特殊的用例！</p><p id="5af1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我玩的“超参数”是:</p><ul class=""><li id="9b85" class="lu lv it js b jt ju jx jy kb lw kf lx kj ly kn lz ma mb mc bi translated"><strong class="js iu">传感器的估计精度</strong>:我决定谨慎行事，只考虑1%</li><li id="bad7" class="lu lv it js b jt md jx me kb mf kf mg kj mh kn lz ma mb mc bi translated"><strong class="js iu">初始数据集的复制因子</strong>:我用过1，2，5，10。这是什么意思？</li></ul><p id="8243" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">复制因子为2时，最终数据集将是以下内容的组合:</p><ul class=""><li id="f690" class="lu lv it js b jt ju jx jy kb lw kf lx kj ly kn lz ma mb mc bi translated">初始数据集<br/></li><li id="ab34" class="lu lv it js b jt md jx me kb mf kf mg kj mh kn lz ma mb mc bi translated">一个扩充数据集，基于初始数据集，但其大小是初始数据集的两倍，标记的数据与原始值相差1%:</li></ul><pre class="kp kq kr ks gt mj mk ml mm aw mn bi"><span id="ff43" class="mo mp it mk b gy mq mr l ms mt">Initial row:<strong class="mk iu"><br/>X1, X2, X3, ..., X51 =&gt; 100</strong></span><span id="b655" class="mo mp it mk b gy mu mr l ms mt">Final rows:<br/><strong class="mk iu">X1, X2, X3, ..., X51 =&gt; 100 (initial)<br/>X1, X2, X3, ..., X51 =&gt; 99.5 (augmented)<br/>X1, X2, X3, ..., X51 =&gt; 100.2 (augmented)</strong></span></pre><p id="c432" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我见证的改进如下:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ob"><img src="../Images/45c3892aecf9fb1fa62a9a6cbb1bed71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8-5NIztlHxJ4FUa6hAaGYA.png"/></div></div></figure><pre class="kp kq kr ks gt mj mk ml mm aw mn bi"><span id="1658" class="mo mp it mk b gy mq mr l ms mt">MAE Initial:             2,404342</span><span id="28bf" class="mo mp it mk b gy mu mr l ms mt">MAE (Replication x 1):   2,222344 (-0,18)<br/>MAE (Replication x 2):   2,240588 (-0,16)<br/>MAE (Replication x 5):   2,200172 (-0,20)<br/>MAE (Replication x 10):  2,343116 (-0,06)</span></pre><p id="85c1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这种方法有明显的好处，但我想补充以下注意事项和警告:</p><ul class=""><li id="bfba" class="lu lv it js b jt ju jx jy kb lw kf lx kj ly kn lz ma mb mc bi translated"><strong class="js iu">复制因子的“最佳点”似乎位于2和5之间:<br/> </strong> -低因子(&lt; 1)不会对数据集产生真正的显著改进。<br/> -超过5将开始添加许多与实际值相比的随机值，精确度的提高可能会很快下降(只要看看10个复制因子的结果)。</li><li id="66cc" class="lu lv it js b jt md jx me kb mf kf mg kj mh kn lz ma mb mc bi translated"><strong class="js iu">我没有试图增加X数据集</strong>，因为这里的例子中的输入特征已经是过去30分钟的平均值，因此，与“y”上的唯一采样相比，不容易出现不准确。</li><li id="756e" class="lu lv it js b jt md jx me kb mf kf mg kj mh kn lz ma mb mc bi translated"><strong class="js iu">一些非常特殊的训练分割配置</strong>(尤其是在非常小的数据集上)<strong class="js iu">与不利的扩充数据随机化相结合，可能会导致实现比初始模型性能更低的性能</strong>。</li><li id="6456" class="lu lv it js b jt md jx me kb mf kf mg kj mh kn lz ma mb mc bi translated"><strong class="js iu">只能在列车测试分割后执行增强过程</strong>！否则，一些几乎相同的值将落入训练集和测试集中。该算法将很容易推断出测试集中的值，如果它已经用它的几乎孪生兄弟训练过的话…这将错过训练和测试样本的全部意义。</li></ul><h1 id="9189" class="nd mp it bd ne nf oc nh ni nj od nl nm nn oe np nq nr of nt nu nv og nx ny nz bi translated">长话短说:像往常一样，盲目复制粘贴这种技术是有风险的！</h1><p id="15e4" class="pw-post-body-paragraph jq jr it js b jt oh jv jw jx oi jz ka kb oj kd ke kf ok kh ki kj ol kl km kn im bi translated">为了帮助您自己运行这个示例，并可能提出一些问题、评论、顾虑或想法，这里有相应的笔记本(最初创建于Google Colab)。</p><p id="d383" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意，出于保密原因，带标签的数据(y)也已标准化。因此，你应该在<strong class="js iu"> 0.035 </strong>和<strong class="js iu"> 0.055 </strong>之间找到MAE。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="om on l"/></div></figure><div class="oo op gp gr oq or"><a href="https://pl-bescond.medium.com/pierre-louis-besconds-articles-on-medium-f6632a6895ad" rel="noopener follow" target="_blank"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd iu gy z fp ow fr fs ox fu fw is bi translated">皮埃尔-路易·贝斯康德关于媒介的文章</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">数据科学、机器学习和创新</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">pl-bescond.medium.com</p></div></div><div class="pa l"><div class="pb l pc pd pe pa pf ky or"/></div></div></a></div></div></div>    
</body>
</html>