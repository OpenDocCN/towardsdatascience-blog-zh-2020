<html>
<head>
<title>How Japanese Tokenizers Work</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">日语标记器是如何工作的</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-japanese-tokenizers-work-87ab6b256984?source=collection_archive---------19-----------------------#2020-09-06">https://towardsdatascience.com/how-japanese-tokenizers-work-87ab6b256984?source=collection_archive---------19-----------------------#2020-09-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="56da" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过开源库示例深入探讨日语标记化及其组件(字典、点阵、维特比算法等)</h2></div><p id="b8b4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我最近一直在研究 Kotori 和日本的 NLP 工具。我写这篇文章是为了分享我到目前为止对日语标记化及其组成部分的了解。</p><p id="12e4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lc">如果你没听说过，</em> <a class="ae lb" href="https://github.com/wanasit/kotori" rel="noopener ugc nofollow" target="_blank"> <em class="lc"> Kotori 是用 Kotlin </em> </a> <em class="lc">编写的日语分词器和词法分析引擎。如果你喜欢这篇文章，请在 Github 上查看 Kotori 并给它一些星星。</em></p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi ld"><img src="../Images/ef5e222d3ced6a4e8fd5769380fe95bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Hv1K60BZzfwAWdXZ"/></div></div><p class="lp lq gj gh gi lr ls bd b be z dk translated">照片由<a class="ae lb" href="https://unsplash.com/@hiro7jp?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Hiroshi Tsubono </a>在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h2 id="17da" class="lt lu iq bd lv lw lx dn ly lz ma dp mb ko mc md me ks mf mg mh kw mi mj mk ml bi translated">日本标记化者</h2><p id="176f" class="pw-post-body-paragraph kf kg iq kh b ki mm jr kk kl mn ju kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">在其他 NLP 任务(例如，文本分类)之前，标记化或者将文本分解成单词列表是重要的步骤。在英语中，单词通常由空格或其他符号分隔，这样更容易标记。然而，在日语中，单词之间通常没有任何空格。日语标记化需要阅读/分析整个句子，识别单词，并在没有任何显式分隔符的情况下确定单词边界。</p><p id="eff3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">大多数日语记号化器使用<strong class="kh ir"> <em class="lc">基于点阵的</em>记号化</strong>。顾名思义，基于格的记号赋予器构建一个<em class="lc">格</em>(或者一个类似图形的数据结构)，它由输入文本上出现的所有可能的记号(术语或者子串)组成。它使用<strong class="kh ir"> <em class="lc">维特比</em> </strong>算法来寻找通过格的最佳连通路径。</p><p id="ff74" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最流行的基于格的记号赋予器是<a class="ae lb" href="https://taku910.github.io/mecab/" rel="noopener ugc nofollow" target="_blank"> MeCab </a>(用 C++编写)。大多数开源的日语标记器库要么只是 MeCab 的包装器，要么是在不同平台上基于格的标记化的重新实现。</p><p id="468a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如:</p><ul class=""><li id="1d92" class="mr ms iq kh b ki kj kl km ko mt ks mu kw mv la mw mx my mz bi translated"><a class="ae lb" href="https://github.com/wanasit/kotori" rel="noopener ugc nofollow" target="_blank"> Kotori </a>中的<em class="lc"> Kotlin </em></li><li id="b1c4" class="mr ms iq kh b ki na kl nb ko nc ks nd kw ne la mw mx my mz bi translated"><a class="ae lb" href="https://github.com/WorksApplications/Sudachi" rel="noopener ugc nofollow" target="_blank"> Sudachi </a>和<a class="ae lb" href="https://github.com/atilika/kuromoji" rel="noopener ugc nofollow" target="_blank"> Kuromoji </a>在<em class="lc"> Java </em>中</li><li id="9782" class="mr ms iq kh b ki na kl nb ko nc ks nd kw ne la mw mx my mz bi translated"><a class="ae lb" href="https://mocobeta.github.io/janome/en/" rel="noopener ugc nofollow" target="_blank"> Janome </a>和<em class="lc"> Python </em>中的<a class="ae lb" href="https://github.com/WorksApplications/SudachiPy" rel="noopener ugc nofollow" target="_blank"> SudachiPy </a></li><li id="e924" class="mr ms iq kh b ki na kl nb ko nc ks nd kw ne la mw mx my mz bi translated"><a class="ae lb" href="https://github.com/ikawaha/kagome" rel="noopener ugc nofollow" target="_blank">戈薇</a>在<em class="lc">走</em>。</li></ul><p id="867a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lb" href="https://taku910.github.io/mecab/#download" rel="noopener ugc nofollow" target="_blank"> MeCab 的 IPA 字典</a> (IPADIC)也是最受欢迎的字典。它被用作大多数分词器的基线或主词典。</p><p id="b997" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我将通过简化版的 Kotori 代码和 MeCab 参考资料详细解释基于格的字典和标记化是如何工作的。</p><h1 id="49f1" class="nf lu iq bd lv ng nh ni ly nj nk nl mb jw nm jx me jz nn ka mh kc no kd mk np bi translated">词典</h1><p id="f59d" class="pw-post-body-paragraph kf kg iq kh b ki mm jr kk kl mn ju kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">对于基于格的记号化器来说，<em class="lc">字典</em>是一个对象或数据结构，它提供关于可用的<em class="lc">术语</em>的信息，以及根据日语语法或概率这些术语应该如何彼此相邻出现。</p><p id="deec" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽管不同的记号赋予器库使用不同的内存数据结构并读取不同的字典文件格式，但所有基于格的记号赋予器字典共享几乎相同的接口或逻辑结构。</p><p id="a6e1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究<a class="ae lb" href="http://taku910.github.io/mecab/dic.html" rel="noopener ugc nofollow" target="_blank"> MeCab 的字典格式</a>。具体是 MeCab 的 IPADIC，你可以在这里下载<a class="ae lb" href="https://drive.google.com/uc?export=download&amp;id=0B4y35FiV1wh7MWVlSDBCSXZMTXM" rel="noopener ugc nofollow" target="_blank">(自己看内容和笔记对比)。</a></p><p id="df48" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">记号赋予器字典由两个重要部分组成:</p><h2 id="b48e" class="lt lu iq bd lv lw lx dn ly lz ma dp mb ko mc md me ks mf mg mh kw mi mj mk ml bi translated">术语词典</h2><p id="fb0a" class="pw-post-body-paragraph kf kg iq kh b ki mm jr kk kl mn ju kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi">Term-Dictionary (単語辞書 or <em class="lc">Lexicon</em>) is a list of known terms (or words). In MeCab’s dictionary directory, <strong class="kh ir">all CSV files</strong> together make up this term dictionary part.</p><p id="cb58" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，在<em class="lc"> Noun.place.csv </em>中，您可以找到这样的行:</p><pre class="le lf lg lh gt nq nr ns nt aw nu bi"><span id="dacd" class="lt lu iq nr b gy nv nw l nx ny"><strong class="nr ir">東京,1293,1293,3003</strong>,名詞,固有名詞,地域,一般,*,*,東京,トウキョウ,トーキョー<br/><br/><strong class="nr ir">京都,1293,1293,2135</strong>,名詞,固有名詞,地域,一般,*,*,京都,キョウト,キョート<br/><br/><strong class="nr ir">札幌,1293,1293,3440</strong>,名詞,固有名詞,地域,一般,*,*,札幌,サッポロ,サッポロ<br/><br/><strong class="nr ir">渋谷,1293,1293,4310</strong>,名詞,固有名詞,地域,一般,*,*,渋谷,シブヤ,シブヤ</span></pre><p id="ea66" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每个<em class="lc">术语</em>(或<em class="lc">行</em>)由多个<em class="lc">列</em>(或<em class="lc">字段</em>)组成，但只有<strong class="kh ir">的前四列</strong>对标记化很重要。</p><ul class=""><li id="f938" class="mr ms iq kh b ki kj kl km ko mt ks mu kw mv la mw mx my mz bi"><strong class="kh ir">Surface Form</strong> (表層形): The string or term that should appear in the text.</li><li id="2ac0" class="mr ms iq kh b ki na kl nb ko nc ks nd kw ne la mw mx my mz bi"><strong class="kh ir">Left/Right Context ID</strong> (左/右-文脈 ID): This is used for determining connection cost or how likely it is for a term to follow other terms.</li><li id="c2b5" class="mr ms iq kh b ki na kl nb ko nc ks nd kw ne la mw mx my mz bi translated"><strong class="kh ir">成本</strong>:拥有这个术语的成本。成本取决于该术语被使用的可能性。成本越高，该术语使用频率越低或越罕见。</li></ul><p id="bd62" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">剩余的列是关于术语的附加特征(例如，<em class="lc">词性</em>、<em class="lc">规范化形式</em>、<em class="lc">发音</em>、…，等等)</p><p id="df59" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意事项:</p><ul class=""><li id="6d11" class="mr ms iq kh b ki kj kl km ko mt ks mu kw mv la mw mx my mz bi translated">实际上，术语词典又大又全。它通常包含几十万个术语(例如，在 IPADIC 中大约有 290，000 个术语)</li><li id="a913" class="mr ms iq kh b ki na kl nb ko nc ks nd kw ne la mw mx my mz bi">Please don’t confuse <em class="lc">Dictionary</em> (辞書) with <em class="lc">Term-Dictionary (</em>単語辞書<em class="lc">)</em>. Throughout this article, I will use the <em class="lc">term-dictionary</em> to mean the table of terms part, while the <em class="lc">dictionary</em> would refer to the whole (term-dictionary + connection cost + others).</li></ul><h2 id="7fa2" class="lt lu iq bd lv lw lx dn ly lz ma dp mb ko mc md me ks mf mg mh kw mi mj mk ml bi translated">连接成本</h2><p id="1805" class="pw-post-body-paragraph kf kg iq kh b ki mm jr kk kl mn ju kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi">Connection Cost (連接コース) is a cost structure to measure how likely it is for a term to be before or after one another.</p><p id="1ed2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">连接可能性被解释为连接<strong class="kh ir">前一单词的右上下文 ID </strong>和<strong class="kh ir">后一单词的左上下文 ID </strong>的成本。</p><pre class="le lf lg lh gt nq nr ns nt aw nu bi"><span id="ee61" class="lt lu iq nr b gy nv nw l nx ny">(Prev term's rightID, Next term's leftID) -&gt; Cost</span></pre><p id="4025" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与术语的成本类似，连接成本越高，给定术语被连接的可能性就越小。</p><p id="37c8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个映射是 MeCab 字典中的<code class="fe nz oa ob nr b">matrix.def</code>文件。文件结构非常简单。第一行是可能的 rightID 和 leftID 的数量(在本例中均为 1316)，后面是一列<strong class="kh ir">(rigid，left id，cost) </strong>元组。</p><pre class="le lf lg lh gt nq nr ns nt aw nu bi"><span id="23b7" class="lt lu iq nr b gy nv nw l nx ny">1316 1316<br/>0 0 -434<br/>0 1 1<br/>0 2 -1630<br/>0 3 -1671</span><span id="a8fb" class="lt lu iq nr b gy oc nw l nx ny">...</span><span id="8c2d" class="lt lu iq nr b gy oc nw l nx ny">1315 1313 -4369<br/>1315 1314 -1712<br/>1315 1315 -129</span></pre><h2 id="0697" class="lt lu iq bd lv lw lx dn ly lz ma dp mb ko mc md me ks mf mg mh kw mi mj mk ml bi translated">未知术语处理</h2><p id="7d08" class="pw-post-body-paragraph kf kg iq kh b ki mm jr kk kl mn ju kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">除了<em class="lc">术语字典</em>和<em class="lc">连接成本</em>之外，另一个在实践中对标记化至关重要的字典组件是<em class="lc">未知术语</em>(或<em class="lc">超出词汇表</em>)处理策略。它用于识别术语词典之外的一些单词、子字符串或符号(例如人名)，并允许分词器跳过或分词它们。</p><p id="1ce3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在 MeCab 中，未知术语的处理是通过基于字符类型的启发式规则完成的(例如，连续的片假名字符可能是一个名词)。规则和字符类型在<code class="fe nz oa ob nr b">unk.def</code>和<code class="fe nz oa ob nr b">char.def</code>文件中定义。</p><p id="bdf7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我将留下未知单词处理的细节，并假设术语词典包括文本中的每个术语。</p><h1 id="c678" class="nf lu iq bd lv ng nh ni ly nj nk nl mb jw nm jx me jz nn ka mh kc no kd mk np bi translated">基于格的记号化</h1><p id="970d" class="pw-post-body-paragraph kf kg iq kh b ki mm jr kk kl mn ju kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">如前所述，基于格的标记化是构建一个术语格，并通过该格找到最佳路径。</p><p id="98e8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">给定字典，记号赋予器将文本上“出现”的所有术语识别为子串，将它们连同它们的子串开始/结束位置一起添加到格中，然后运行算法来寻找连接术语的最佳路径。</p><p id="0f15" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">简化的代码如下所示:</p><pre class="le lf lg lh gt nq nr ns nt aw nu bi"><span id="30c0" class="lt lu iq nr b gy nv nw l nx ny">val lattice = Lattice.create()</span><span id="3738" class="lt lu iq nr b gy oc nw l nx ny">for i in 0..text.length {</span><span id="3a5b" class="lt lu iq nr b gy oc nw l nx ny">    val terms = <strong class="nr ir">findAllTermStartingAt</strong>(text, i)</span><span id="3d9c" class="lt lu iq nr b gy oc nw l nx ny">    for term in terms {</span><span id="3430" class="lt lu iq nr b gy oc nw l nx ny">        lattice.add(term, startIndex=i, endIndex=i+term.length)</span><span id="711d" class="lt lu iq nr b gy oc nw l nx ny">    }<br/>    ...<br/>}<br/>...</span><span id="cb1f" class="lt lu iq nr b gy oc nw l nx ny">return lattice.findTheBestPath()</span></pre><p id="c446" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在示例代码中，我们使用<code class="fe nz oa ob nr b">findAllTermStartingAt(..)</code>来查找字典中从该位置开始具有表面形式的所有术语。</p><p id="072c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi">For example, if <code class="fe nz oa ob nr b">text="東京都に住む"</code>:</p><ul class=""><li id="67ca" class="mr ms iq kh b ki kj kl km ko mt ks mu kw mv la mw mx my mz bi"><code class="fe nz oa ob nr b">findAllTermStartingAt(text, 0)</code> should return 東 (East), 東京 (Tokyo)</li><li id="0b6d" class="mr ms iq kh b ki na kl nb ko nc ks nd kw ne la mw mx my mz bi"><code class="fe nz oa ob nr b">findAllTermStartingAt(text, 1)</code> should return 京 (Capital), 京都 (Kyoto)</li><li id="dc22" class="mr ms iq kh b ki na kl nb ko nc ks nd kw ne la mw mx my mz bi">…</li></ul><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi od"><img src="../Images/2414405f4a94b9df19c834a134225539.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EV33nzmD8vUIDaGr5LMqhQ.png"/></div></div><p class="lp lq gj gh gi lr ls bd b be z dk translated"><em class="oe">作者图片</em></p></figure><p id="50c4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意:</p><ul class=""><li id="0ed6" class="mr ms iq kh b ki kj kl km ko mt ks mu kw mv la mw mx my mz bi translated">拥有一个快速的<code class="fe nz oa ob nr b">findAllTermStartingAt(..)</code>对于记号赋予器的性能非常重要。因此，该功能通常通过高效的字符串匹配/查找数据结构来实现，例如<em class="lc"> Trie </em>或<em class="lc">有限状态转换器(FST) </em>。我将把这些数据结构的实现细节留给以后的文章。</li><li id="60d7" class="mr ms iq kh b ki na kl nb ko nc ks nd kw ne la mw mx my mz bi translated">在所示的版本中，我们识别可能的术语，并在运行算法找到最终的最佳路径之前将它们全部保存在内存中。有些记号赋予器使用贪婪的或基于窗口的方法来主动删除不必要的术语，以保持较低的内存使用率。Kotori 使用所示的方法，因为我发现它更有效(又名。更快)，而且内存使用在实践中从来都不是问题。</li></ul><p id="b633" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nz oa ob nr b">Lattice</code>是一个图结构，包含所有作为<em class="lc">节点</em>出现的术语。图的边连接从每个位置开始的节点(或术语)和在相同位置结束的节点。</p><p id="f3fa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi">For example, 東 (ending at index=1) connected to 京 and 京都 (starting at index=1).</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div class="gh gi of"><img src="../Images/17ce00e571a225e3e107fe43b643088e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1130/format:webp/1*FWQSUFaQpWIezoO1ELjv2A.png"/></div><p class="lp lq gj gh gi lr ls bd b be z dk translated"><em class="oe">作者图片</em></p></figure><p id="8f23" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每个节点和连接都有与之相关联成本:</p><ul class=""><li id="db1a" class="mr ms iq kh b ki kj kl km ko mt ks mu kw mv la mw mx my mz bi translated"><strong class="kh ir">节点</strong>的成本(橙色)是其<strong class="kh ir">术语的成本</strong>(在<em class="lc">术语字典</em>中定义)</li><li id="09ce" class="mr ms iq kh b ki na kl nb ko nc ks nd kw ne la mw mx my mz bi translated"><strong class="kh ir">连接的成本</strong>(红色)是结束项的<strong class="kh ir">右上下文 ID </strong>和开始项的<strong class="kh ir">左上下文 ID </strong>之间的连接成本(定义见<em class="lc">连接成本</em>)。</li></ul><p id="2b2b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，除了表面术语中的节点，我们还需要在网格中包含两个特殊的节点。</p><ul class=""><li id="97ae" class="mr ms iq kh b ki kj kl km ko mt ks mu kw mv la mw mx my mz bi translated">一个特殊的<em class="lc">开始</em>节点<code class="fe nz oa ob nr b">index=0, rightID=0, cost=0</code></li><li id="9549" class="mr ms iq kh b ki na kl nb ko nc ks nd kw ne la mw mx my mz bi translated">一个特殊的<em class="lc">端</em>节点<code class="fe nz oa ob nr b">index=text.length, leftID=0, cost=0</code></li></ul><p id="3cc6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">术语成本和连接成本代表了它们的使用频率。成本越低，术语和连接的可能性就越大。因此，分词器的目标是从头到尾找到<strong class="kh ir">最小成本路径</strong>(或“最佳”路径)。这样做将产生最有可能出现在日语中的标记序列。</p><h2 id="5189" class="lt lu iq bd lv lw lx dn ly lz ma dp mb ko mc md me ks mf mg mh kw mi mj mk ml bi translated"><strong class="ak">维特比算法</strong></h2><p id="7e02" class="pw-post-body-paragraph kf kg iq kh b ki mm jr kk kl mn ju kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">维特比算法是一种通过图寻找<em class="lc">最优路径</em>(或<em class="lc">最可能路径</em>，或<em class="lc">最小代价路径</em>等)的算法。大多数维特比算法的例子都来自于它与<em class="lc">隐马尔可夫模型</em>的应用(例如<em class="lc">词性标注</em>)。然而，我发现维特比算法在标记化中的用法非常不同。</p><p id="b02a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我对基于格的符号化应用的维特比算法的解释如下:</p><blockquote class="og oh oi"><p id="606e" class="kf kg lc kh b ki kj jr kk kl km ju kn oj kp kq kr ok kt ku kv ol kx ky kz la ij bi translated">为了找到从起点到<em class="iq"> tᵗʰ </em>节点的最小路径，我们需要通过计算每条路径的总成本来考虑通过每个<em class="iq"> (t-1)ᵗʰ </em>节点到<em class="iq"> tᵗʰ </em>节点的路径，并从中挑选最小路径。</p></blockquote><p id="5df4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于每个<em class="lc"> (t-1)ᵗʰ </em>节点通向<em class="lc"> tᵗʰ </em>节点:</p><ul class=""><li id="cfbe" class="mr ms iq kh b ki kj kl km ko mt ks mu kw mv la mw mx my mz bi translated">(递归地)找出从<em class="lc">开始</em>到那个<em class="lc"> (t-1)ᵗʰ </em>节点的最小成本/路径。</li><li id="b5d7" class="mr ms iq kh b ki na kl nb ko nc ks nd kw ne la mw mx my mz bi translated">找出连接那个<em class="lc"> (t-1)ᵗʰ </em>节点到<em class="lc"> tᵗʰ </em>节点的成本</li><li id="6f45" class="mr ms iq kh b ki na kl nb ko nc ks nd kw ne la mw mx my mz bi translated">找到<em class="lc"> tᵗʰ </em>节点本身的成本</li><li id="02ee" class="mr ms iq kh b ki na kl nb ko nc ks nd kw ne la mw mx my mz bi translated">把它们加在一起。这是从<em class="lc">开始</em>到<em class="lc"> tᵗʰ </em>节点通过<em class="lc"> (t-1)ᵗʰ </em>节点的<strong class="kh ir">总成本</strong></li></ul><p id="c84b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，在通过不同<em class="lc"> (t-1)ᵗʰ </em>节点到<em class="lc"> tᵗʰ </em>节点的路径中，挑选总成本最小的路径。</p><p id="b92a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">实现这个算法的一个有效方法是<strong class="kh ir">动态规划</strong>。我们可以从最靠近起点的节点开始寻找最小路径，并重用它们到跟随它们的节点的最小路径。不断重复，直到我们计算出每个节点的最小路径。</p><pre class="le lf lg lh gt nq nr ns nt aw nu bi"><span id="7e17" class="lt lu iq nr b gy nv nw l nx ny">for i in 0..text.length {</span><span id="9473" class="lt lu iq nr b gy oc nw l nx ny">  for node in nodes.startingAt(i) {</span><span id="658a" class="lt lu iq nr b gy oc nw l nx ny">    for prevNode in nodes.endingAt(i) {</span><span id="a6df" class="lt lu iq nr b gy oc nw l nx ny">      val prevTotalCost = prevNode.totalCost<br/>      val termCost = node.cost<br/>      val connectionCost = getConnectionCost(prevNode.rightId, node.leftId)</span><span id="fa3b" class="lt lu iq nr b gy oc nw l nx ny">      val totalCost = prevTotalCost + connectionCost + termCost<br/>      <br/>      if (totalCost &lt; node.totalCost) {<br/>         <br/>        node.totalCost = totalCost<br/>        node.prevNode = prevNode</span><span id="6870" class="lt lu iq nr b gy oc nw l nx ny">      }<br/>    }<br/>  }<br/>}</span></pre><p id="f953" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">执行算法后，可以找到从<em class="lc">开始</em>到<em class="lc">结束</em>的最短路径，即<em class="lc">结束</em>节点。我们只需要跟随<code class="fe nz oa ob nr b">prevNode</code>指针回到<em class="lc">开始</em>节点。</p></div><div class="ab cl om on hu oo" role="separator"><span class="op bw bk oq or os"/><span class="op bw bk oq or os"/><span class="op bw bk oq or"/></div><div class="ij ik il im in"><p id="bb14" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这篇文章总结了我从零开始构建日语分词器所学到的知识。同样，如果你喜欢这篇文章或者想了解更多关于日语标记化的知识，请在 Github 上查看<a class="ae lb" href="https://github.com/wanasit/kotori" rel="noopener ugc nofollow" target="_blank"> Kotori。</a></p><p id="d998" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意:Kotori 深受其他开源库的影响。特别感谢<a class="ae lb" href="https://www.atilika.org/" rel="noopener ugc nofollow" target="_blank">阿蒂里卡</a>(黑次)<a class="ae lb" href="https://github.com/WorksApplications" rel="noopener ugc nofollow" target="_blank">工作申请人</a>(须田)<a class="ae lb" href="https://github.com/mocobeta" rel="noopener ugc nofollow" target="_blank">外川智子内田</a>(贾诺梅)。</p><p id="946f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其他资源(日语):</p><ul class=""><li id="d56e" class="mr ms iq kh b ki kj kl km ko mt ks mu kw mv la mw mx my mz bi">Manabu Okumura, 自然言語処理の基礎 (book)</li><li id="64fb" class="mr ms iq kh b ki na kl nb ko nc ks nd kw ne la mw mx my mz bi">Cookpad Developers’ Blog, <a class="ae lb" href="https://techlife.cookpad.com/entry/2016/05/11/170000" rel="noopener ugc nofollow" target="_blank">日本語形態素解析の裏側を覗く！MeCab はどのように形態素解析しているか</a></li></ul></div></div>    
</body>
</html>