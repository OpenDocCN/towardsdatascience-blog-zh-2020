<html>
<head>
<title>Part 1: The Matrix Profile</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第1部分:矩阵简介</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-matrix-profile-e4a679269692?source=collection_archive---------10-----------------------#2020-06-16">https://towardsdatascience.com/the-matrix-profile-e4a679269692?source=collection_archive---------10-----------------------#2020-06-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ca10" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">STUMPY:用于现代时间序列分析的强大且可伸缩的Python库</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/9fd66b41f4ef2eff9d45b6935cb7160e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SABnYfT-DtAuwGOgkqs79g.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">(图片由<a class="ae kv" href="https://unsplash.com/@sortino?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">约书亚·索蒂诺</a>提供)</p></figure><h1 id="1688" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">整体大于部分之和</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi lo"><img src="../Images/b9dc45622efb5d6ddbb94d3e2f91b304.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/1*NWV2vLKBciK49BAVfzvN4Q.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">(图片由作者提供)</p></figure><p id="1394" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated"><a class="ae kv" href="https://github.com/TDAmeritrade/stumpy" rel="noopener ugc nofollow" target="_blank"> STUMPY是一个强大且可扩展的Python库，用于现代时间序列分析</a>，在其核心，有效地计算出一种叫做<em class="ml">矩阵轮廓</em>的东西。这个多部分系列的目标是解释什么是matrix profile，以及如何开始利用<a class="ae kv" href="https://stumpy.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> STUMPY </a>完成所有现代时间序列数据挖掘任务！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">(作者视频)</p></figure><p id="fb25" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated"><em class="ml">注:这些教程最初出现在</em> <a class="ae kv" href="https://stumpy.readthedocs.io/en/latest/tutorials.html" rel="noopener ugc nofollow" target="_blank"> <em class="ml"> STUMPY文档</em> </a> <em class="ml">中。</em></p><p id="af9b" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">第一部分:<a class="ae kv" rel="noopener" target="_blank" href="/the-matrix-profile-e4a679269692">矩阵轮廓图</a> <br/>第二部分:<a class="ae kv" rel="noopener" target="_blank" href="/stumpy-basics-21844a2d2d92"> STUMPY基础知识</a> <br/>第三部分:<a class="ae kv" rel="noopener" target="_blank" href="/part-3-time-series-chains-da281450abbf">时间序列链</a> <br/>第四部分:<a class="ae kv" rel="noopener" target="_blank" href="/part-4-semantic-segmentation-b42c3792833d">语义分割</a> <br/>第五部分:<a class="ae kv" rel="noopener" target="_blank" href="/part-5-fast-approximate-matrix-profiles-with-scrump-c6d9c984c560">快速近似矩阵轮廓图与STUMPY </a> <br/>第六部分:<a class="ae kv" rel="noopener" target="_blank" href="/matrix-profiles-for-streaming-time-series-data-f877ff6f9eef">用于流式时间序列数据的矩阵轮廓图</a> <br/>第七部分:<a class="ae kv" rel="noopener" target="_blank" href="/part-7-fast-pattern-searching-with-stumpy-2baf610a8de1">快速模式搜索与STUMPY </a> <br/>第八部分:【T2 10: <a class="ae kv" rel="noopener" target="_blank" href="/part-10-discovering-multidimensional-time-series-motifs-45da53b594bb">发现多维时间序列模体</a> <br/>第十一部分:<a class="ae kv" rel="noopener" target="_blank" href="/part-11-user-guided-motif-search-d3d317caf9ea">用户引导的模体搜索</a> <br/>第十二部分:<a class="ae kv" rel="noopener" target="_blank" href="/part-12-matrix-profiles-for-machine-learning-2dfd98d7ff3f">机器学习的矩阵轮廓</a></p><h1 id="ddf0" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">奠定基础</h1><p id="e31c" class="pw-post-body-paragraph lp lq iq lr b ls mo jr lu lv mp ju lx ly mq ma mb mc mr me mf mg ms mi mj mk ij bi translated">在一个简单的句子中，<em class="ml">矩阵配置文件</em>本质上是<em class="ml"> </em>一个向量，它存储了时间序列中任何子序列与其最近邻居之间的<a class="ae kv" href="https://youtu.be/LnQneYvg84M?t=374" rel="noopener ugc nofollow" target="_blank"> z归一化欧几里德距离</a>。</p><p id="f62e" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">为了充分理解这意味着什么，让我们后退一步，从一个简单的示例以及一些基本定义开始:</p><h1 id="2999" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">长度n = 13的时间序列</h1><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="fd0c" class="my kx iq mu b gy mz na l nb nc">time_series = [0, 1, 3, 2, 9, 1, 14, 15, 1, 2, 2, 10, 7]<br/>n = len(time_series)</span></pre><p id="aa70" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">为了分析这个长度为<code class="fe nd ne nf mu b">n = 13</code>的时间序列，我们可以可视化数据或计算全局汇总统计数据(即平均值、中值、众数、最小值、最大值)。如果你有一个长得多的时间序列，那么你甚至会觉得有必要建立一个ARIMA模型，执行异常检测，或尝试一个预测模型，但这些方法可能会很复杂，可能经常有假阳性或没有可解释的见解。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/099fdcc04c0a5bccf001d9516fbb1d78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aE3YMJ96S20oQNS8TYnGxg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">(图片由作者提供)</p></figure><p id="a4ef" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">然而，如果我们应用奥卡姆剃刀，那么我们可以对这个时间序列进行分析的最简单和直观的方法是什么？</p><p id="3906" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">要回答这个问题，让我们从我们的第一个定义开始:</p><h1 id="691d" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">子序列/ˈsəbsəkwəns/名词</h1><h2 id="389a" class="my kx iq bd ky nh ni dn lc nj nk dp lg ly nl nm li mc nn no lk mg np nq lm nr bi translated">完整时间序列的一部分或一段</h2><p id="b950" class="pw-post-body-paragraph lp lq iq lr b ls mo jr lu lv mp ju lx ly mq ma mb mc mr me mf mg ms mi mj mk ij bi translated">因此，以下都被认为是我们的<code class="fe nd ne nf mu b">time_series</code>的子序列，因为它们都可以在上面的时间序列中找到。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/3008c485579d4bd8b8a9ff38b97c6094.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d-B9XbUnEjbVDWWUSDMb8g.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">(图片由作者提供)</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/9f9dee8a26c4caa02592d40113952444.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kwwFjeH0iNhIwhQxO1ehjA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">(图片由作者提供)</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/0aa17b8752322c94277c6d58a4a8cb8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MRA-rZwn_V19cDzPXuuUXw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">(图片由作者提供)</p></figure><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="7efd" class="my kx iq mu b gy mz na l nb nc">print(time_series[0:2])<br/>print(time_series[4:7])<br/>print(time_series[2:10])</span><span id="1f83" class="my kx iq mu b gy ns na l nb nc">[0, 1]<br/>[9, 1, 14]<br/>[3, 2, 9, 1, 14, 15, 1, 2]</span></pre><p id="be6b" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">我们可以看到每个子序列可以有不同的序列长度，我们称之为<code class="fe nd ne nf mu b">m</code>。例如，如果我们选择<code class="fe nd ne nf mu b">m = 4</code>，那么我们可以考虑如何比较任意两个相同长度的子序列。</p><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="3b69" class="my kx iq mu b gy mz na l nb nc">m = 4<br/>i = 0  # starting index for the first subsequence<br/>j = 8  # starting index for the second subsequence<br/><br/>subseq_1 = time_series[i:i+m]<br/>subseq_2 = time_series[j:j+m]<br/><br/>print(subseq_1, subseq_2)</span><span id="c2b8" class="my kx iq mu b gy ns na l nb nc">[0, 1, 3, 2] [1, 2, 2, 10]</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/e1912fb6efb180cbbdb941e28783a8b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a83TpnWpZgvqAFl8IzDqoQ.jpeg"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/e1912fb6efb180cbbdb941e28783a8b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a83TpnWpZgvqAFl8IzDqoQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">(图片由作者提供)</p></figure><p id="8027" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">比较任何两个子序列的一种方法是计算所谓的欧几里德距离。</p><h1 id="25de" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">欧几里德距离/yo͞oˈklidēən/ /ˈdistəns/名词</h1><h2 id="f6fb" class="my kx iq bd ky nh ni dn lc nj nk dp lg ly nl nm li mc nn no lk mg np nq lm nr bi translated">两点之间的直线距离</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/85ca392f57569981b5afce2cf179a37d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*74U9ueQrH8qCvlaHobH_fw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">(图片由作者提供)</p></figure><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="9fbe" class="my kx iq mu b gy mz na l nb nc">import math<br/><br/>D = 0<br/>for k in range(m):<br/>    D += (time_series[i+k] - time_series[j+k])**2<br/>print(f"The square root of {D} = {math.sqrt(D)}")</span><span id="91c3" class="my kx iq mu b gy ns na l nb nc">The square root of 67 = 8.18535277187245</span></pre><h1 id="42f2" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">距离轮廓-成对欧几里得距离</h1><p id="c880" class="pw-post-body-paragraph lp lq iq lr b ls mo jr lu lv mp ju lx ly mq ma mb mc mr me mf mg ms mi mj mk ij bi translated">现在，我们可以更进一步，保持一个子序列不变(参考子序列)，以滑动窗口的方式改变第二个子序列，并计算每个窗口的欧几里德距离。成对欧几里得距离的结果向量也称为距离轮廓。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/f491241c1169cdf0b84bd738db418f0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*vYHOUbblGGyYL8jf__Br5Q.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">(图片由作者提供)</p></figure><p id="eba1" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">当然，并不是所有这些距离都有用。具体来说，自匹配(或平凡匹配)的距离并不提供信息，因为当您将子序列与其自身进行比较时，距离将始终为零。因此，我们将忽略它，取而代之的是，从距离配置文件中记录下一个最小的距离，并选择它作为我们的最佳匹配:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/81b94864eb710edc7dd446013e8c52ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*el760fuH1rYKn9V4yqTZaw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">(图片由作者提供)</p></figure><p id="8068" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">接下来，我们可以一次在一个元素上移动我们的参考子序列，并重复相同的滑动窗口过程来计算每个新的参考子序列的距离分布。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/67cce43143e34cba9043d0cd3fde5242.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*BMO70SxXyQ4UMkpUjN_RkQ.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">(图片由作者提供)</p></figure><h1 id="bc02" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">距离矩阵</h1><p id="f700" class="pw-post-body-paragraph lp lq iq lr b ls mo jr lu lv mp ju lx ly mq ma mb mc mr me mf mg ms mi mj mk ij bi translated">如果我们把为每个参考子序列计算的所有距离分布图一个接一个地堆叠起来，那么我们就得到一个叫做距离矩阵的东西</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/1e96e949d6de4c174bc0bb2d9dc12d67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1Zh-MVWXeDDcTR07dHmBsg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">(图片由作者提供)</p></figure><p id="b365" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">现在，我们可以通过只查看每个子序列的最近邻居来简化这个距离矩阵，这将带我们进入下一个概念:</p><h1 id="08f6" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">矩阵轮廓/mātriks//ˈprōˌfīl/名词</h1><h2 id="da61" class="my kx iq bd ky nh ni dn lc nj nk dp lg ly nl nm li mc nn no lk mg np nq lm nr bi translated">存储时间序列中任何子序列与其最近邻居之间的<a class="ae kv" href="https://youtu.be/LnQneYvg84M?t=374" rel="noopener ugc nofollow" target="_blank"> (z归一化)欧几里得距离</a>的向量</h2><p id="da0a" class="pw-post-body-paragraph lp lq iq lr b ls mo jr lu lv mp ju lx ly mq ma mb mc mr me mf mg ms mi mj mk ij bi translated">实际上，这意味着矩阵简档只对存储来自每个距离简档的最小非平凡距离感兴趣，这显著地将空间复杂度降低到O(n):</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/b2272a87147dcd10617c69a66459299e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*HIbbfQxQM9DbinjJ-M8CRg.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">(图片由作者提供)</p></figure><p id="ea26" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">我们现在可以在原始时间序列下绘制这个矩阵图。并且，事实证明，具有小矩阵分布值的参考子序列(即，它具有显著“靠近”的最近邻居)可以指示可能的模式，而具有大矩阵分布值的参考子序列(即，它的最近邻居显著“远离”)可以暗示异常的存在。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/1310d5e25d809f10e2aaa8d34c28ae60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B_OztHECjhOKOBlS4L5ABA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">(图片由作者提供)</p></figure><p id="d11e" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">因此，通过简单地计算和检查矩阵轮廓，人们可以很容易地挑出顶部模式(全局最小值)和最罕见的异常(全局最大值)。一旦你计算出矩阵的轮廓，这仅仅是可能的一小部分！</p><h1 id="67df" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">真正的问题是——暴力方法</h1><p id="0b61" class="pw-post-body-paragraph lp lq iq lr b ls mo jr lu lv mp ju lx ly mq ma mb mc mr me mf mg ms mi mj mk ij bi translated">现在，在这一点上看起来很简单，但我们需要做的是考虑如何有效地计算完整的距离矩阵。让我们从强力方法开始:</p><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="3d55" class="my kx iq mu b gy mz na l nb nc">for i in range(n-m+1):<br/>    for j in range(n-m+1):<br/>        D = 0<br/>        for k in range(m):<br/>            D += (time_series[i+k] - time_series[j+k])**2<br/>        D = math.sqrt(D)</span></pre><p id="16d6" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">乍一看，这可能看起来不太糟糕，但如果我们开始考虑计算复杂性以及空间复杂性，那么我们就开始理解真正的问题了。事实证明，对于较长的时间序列(即n &gt;&gt; 10，000)，计算复杂度为O(mn^2(如上面代码中的三个for循环所示)，存储完整距离矩阵的空间复杂度为O(n^2).</p><p id="2b73" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">为了客观地看待这一点，想象一下，如果您有一个单一的传感器，在5年的时间里每分钟收集20次数据。这将导致:</p><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="7c40" class="my kx iq mu b gy mz na l nb nc">n = 20 * 60 * 24 * 364 * 5  # 20 times/min x 60 mins/hour x 24 hours/day x 365 days/year x 5 years<br/>print(f"There would be n = {n} data points")</span><span id="b1ed" class="my kx iq mu b gy ns na l nb nc">There would be n = 52416000 data points</span></pre><p id="355f" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">假设内循环中的每个计算需要0.0000001秒，那么这将需要:</p><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="be0e" class="my kx iq mu b gy mz na l nb nc">time = 0.0000001 * (n * n - n)/2<br/>print(f"It would take {time} seconds to compute")</span><span id="f676" class="my kx iq mu b gy ns na l nb nc">It would take 137371850.1792 seconds to compute</span></pre><p id="027d" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">相当于1，598.7天(或4.4年)和11.1 PB内存来计算！因此，使用我们简单的暴力方法来计算距离矩阵显然是不可行的。相反，我们需要找出如何通过有效地生成矩阵轮廓来降低计算复杂度，这就是<a class="ae kv" href="https://stumpy.readthedocs.io/en/latest/index.html" rel="noopener ugc nofollow" target="_blank"> STUMPY </a>发挥作用的地方。</p><h1 id="6ac6" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">多残株的</h1><p id="bff8" class="pw-post-body-paragraph lp lq iq lr b ls mo jr lu lv mp ju lx ly mq ma mb mc mr me mf mg ms mi mj mk ij bi translated">2016年秋天，来自加州大学河滨分校<a class="ae kv" href="https://www.cs.ucr.edu/~eamonn" rel="noopener ugc nofollow" target="_blank">和新墨西哥</a><a class="ae kv" href="https://www.cs.unm.edu/~mueen/" rel="noopener ugc nofollow" target="_blank">大学</a>的研究人员发表了一组漂亮的<a class="ae kv" href="https://www.cs.ucr.edu/~eamonn/MatrixProfile.html" rel="noopener ugc nofollow" target="_blank">背靠背论文</a>，描述了一种叫做STOMP的精确方法，用于计算任何时间序列的矩阵轮廓，计算复杂度为O(n2)！他们还使用GPU进一步证明了这一点，他们将这种更快的方法称为GPU-STOMP。</p><p id="0fcb" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">考虑到学者、数据科学家和开发人员，我们采用了这些概念，并开源了<a class="ae kv" href="https://stumpy.readthedocs.io/en/latest/index.html" rel="noopener ugc nofollow" target="_blank"> STUMPY </a>，这是一个强大的可扩展库，可以根据这一已发布的研究有效地计算矩阵轮廓。此外，由于其他开源软件，如<a class="ae kv" href="http://numba.pydata.org/" rel="noopener ugc nofollow" target="_blank"> Numba </a>和<a class="ae kv" href="https://dask.org/" rel="noopener ugc nofollow" target="_blank"> Dask </a>，我们的实现是高度并行化的(对于具有多个CPU或多个GPU的单个服务器)，高度分布式的(多个CPU跨多个服务器)。我们已经在多达256个CPU内核(分布在32台服务器上)或16个NVIDIA GPU设备(在同一台DGX-2服务器上)上测试了<a class="ae kv" href="https://stumpy.readthedocs.io/en/latest/index.html" rel="noopener ugc nofollow" target="_blank"> STUMPY </a>，并获得了与公布的GPU-STOMP工作类似的<a class="ae kv" href="https://github.com/TDAmeritrade/stumpy#performance" rel="noopener ugc nofollow" target="_blank">性能</a>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/c61edce222430beb55df786d0cbfb6e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3guU4d92402QUoBS27RvcQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">(图片由作者提供)</p></figure><h1 id="9f24" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">结论</h1><p id="9cc3" class="pw-post-body-paragraph lp lq iq lr b ls mo jr lu lv mp ju lx ly mq ma mb mc mr me mf mg ms mi mj mk ij bi translated">根据原始作者的说法，“这些是过去二十年中时间序列数据挖掘的最佳想法”，并且“鉴于矩阵配置文件，<a class="ae kv" href="https://www.cs.ucr.edu/~eamonn/100_Time_Series_Data_Mining_Questions__with_Answers.pdf" rel="noopener ugc nofollow" target="_blank">大多数时间序列数据挖掘问题都可以在几行代码中解决</a>”。</p><p id="2df3" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">根据我们的经验，这绝对是真的，我们很高兴与您分享<a class="ae kv" href="https://stumpy.readthedocs.io/en/latest/index.html" rel="noopener ugc nofollow" target="_blank"> STUMPY </a>！请联系我们，让我们知道<a class="ae kv" href="https://stumpy.readthedocs.io/en/latest/index.html" rel="noopener ugc nofollow" target="_blank"> STUMPY </a>是如何帮助您完成时间序列分析工作的，我们非常希望听到您的反馈！</p><h1 id="494e" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">附加注释</h1><p id="8326" class="pw-post-body-paragraph lp lq iq lr b ls mo jr lu lv mp ju lx ly mq ma mb mc mr me mf mg ms mi mj mk ij bi translated">为了完整起见，我们将为那些想将自己的matrix profile实现与STUMPY进行比较的人提供更多的评论。然而，由于原始论文中省略了许多细节，我们强烈建议您使用<a class="ae kv" href="https://stumpy.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> STUMPY </a>。</p><p id="2384" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">在我们上面的解释中，我们只考虑了无关紧要的匹配。然而，这是不够的，因为附近的子序列(即<code class="fe nd ne nf mu b">i ± 1</code>)很可能是高度相似的，并且我们需要将其扩展到相对于对角线平凡匹配更大的“排除区”。在这里，我们可以看到不同的隔离区是什么样子:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/42f267dbfc9a137f4d14028c370ebf0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DixfrzhE89yJFDNR.jpeg"/></div></div></figure><p id="7cc4" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx ly lz ma mb mc md me mf mg mh mi mj mk ij bi translated">然而，在实践中，已经发现<code class="fe nd ne nf mu b">i ± int(np.ceil(m / 4))</code>的排除区域工作良好(其中<code class="fe nd ne nf mu b">m</code>是子序列窗口大小),并且在为<code class="fe nd ne nf mu b">ith</code>子序列提取矩阵轮廓值之前，在该区域中计算的距离被设置为<code class="fe nd ne nf mu b">np.inf</code>。因此，窗口尺寸越大，禁区就越大。此外，请注意，由于NumPy索引具有包含性起始索引和排他性终止索引，确保对称排除区的正确方法是:</p><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="6279" class="my kx iq mu b gy mz na l nb nc">excl_zone = int(np.ceil(m / 4))<br/>zone_start = i - excl_zone<br/>zone_end = i + excl_zone + 1  <em class="ml"># Notice that we add one since this is exclusive</em><br/>distance_profile[zone_start : zone_end] = np.inf</span></pre><h1 id="54ef" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">资源</h1><p id="0530" class="pw-post-body-paragraph lp lq iq lr b ls mo jr lu lv mp ju lx ly mq ma mb mc mr me mf mg ms mi mj mk ij bi translated"><a class="ae kv" href="https://stumpy.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> STUMPY Matrix Profile文档</a><br/><a class="ae kv" href="https://github.com/TDAmeritrade/stumpy" rel="noopener ugc nofollow" target="_blank">STUMPY Matrix Profile Github代码库</a></p><h2 id="4bcb" class="my kx iq bd ky nh ni dn lc nj nk dp lg ly nl nm li mc nn no lk mg np nq lm nr bi translated"><a class="ae kv" rel="noopener" target="_blank" href="/stumpy-basics-21844a2d2d92">第二部分:短粗基础知识</a> →</h2></div></div>    
</body>
</html>