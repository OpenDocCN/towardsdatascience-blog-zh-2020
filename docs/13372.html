<html>
<head>
<title>Using joblib to speed up your Python pipelines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 joblib 加速 Python 管道</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/using-joblib-to-speed-up-your-python-pipelines-dd97440c653d?source=collection_archive---------10-----------------------#2020-09-14">https://towardsdatascience.com/using-joblib-to-speed-up-your-python-pipelines-dd97440c653d?source=collection_archive---------10-----------------------#2020-09-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/fc157d657ca84a62e98740129fa05fcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*x705Mk0IZFWKVPoH"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">Marc-Olivier Jodoin 在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><div class=""/><p id="f06a" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让您的 Python 工作得更快！</p><figure class="lf lg lh li gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi le"><img src="../Images/e95719a1bc02813076ced785115f0c30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wbGwQcCBk9CV2Vd-ludyaw.jpeg"/></div></div></figure><h2 id="9e92" class="lj lk jj bd ll lm ln dn lo lp lq dp lr kr ls lt lu kv lv lw lx kz ly lz ma mb bi translated">动机:</h2><p id="828f" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">随着多个预处理步骤和计算密集型流水线的增加，在某些点上有必要使流程高效。这可以通过删除一些冗余步骤或获得更多内核/CPU/GPU 来提高速度来实现。很多时候，我们专注于获得最终结果，而不考虑效率。我们很少努力优化管道或进行改进，直到耗尽内存或计算机挂起。最终，我们会觉得…</p><figure class="lf lg lh li gt iv"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="c8bc" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">幸运的是，已经有了一个被称为<em class="mj"> joblib </em>的框架，它提供了一组工具，使得 Python 中的管道在很大程度上变得轻量级。</p><h2 id="ae68" class="lj lk jj bd ll lm ln dn lo lp lq dp lr kr ls lt lu kv lv lw lx kz ly lz ma mb bi translated">为什么是 joblib？</h2><p id="cc09" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">将<em class="mj"> joblib </em>工具集成为 ML 管道的一部分有几个原因。在他们的<a class="ae jg" href="https://joblib.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">网站</a>上提到了使用它的两个主要原因。然而，我想重新表述一下:</p><ul class=""><li id="874e" class="mk ml jj ki b kj kk kn ko kr mm kv mn kz mo ld mp mq mr ms bi translated">能够使用缓存，避免重新计算某些步骤</li><li id="d941" class="mk ml jj ki b kj mt kn mu kr mv kv mw kz mx ld mp mq mr ms bi translated">执行并行化，充分利用 CPU/GPU 的所有内核。</li></ul><p id="6f38" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">除此之外，我推荐<em class="mj"> joblib </em>还有其他几个原因:</p><ol class=""><li id="3857" class="mk ml jj ki b kj kk kn ko kr mm kv mn kz mo ld my mq mr ms bi translated">可以轻松集成</li><li id="3635" class="mk ml jj ki b kj mt kn mu kr mv kv mw kz mx ld my mq mr ms bi translated">没有特定的依赖关系</li><li id="50bd" class="mk ml jj ki b kj mt kn mu kr mv kv mw kz mx ld my mq mr ms bi translated">节省成本和时间</li><li id="1f01" class="mk ml jj ki b kj mt kn mu kr mv kv mw kz mx ld my mq mr ms bi translated">简单易学</li></ol><p id="c39d" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还有其他一些功能也很丰富，如果包含在日常工作中会很有帮助。</p><h2 id="c9a6" class="lj lk jj bd ll lm ln dn lo lp lq dp lr kr ls lt lu kv lv lw lx kz ly lz ma mb bi translated">1.使用缓存的结果</h2><p id="7ece" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在测试或创建模型时，我们经常需要多次重新运行我们的管道。有些函数可能会被调用多次，使用相同的输入数据，然后再次进行计算。Joblib 提供了一种更好的方法来避免重复计算相同的函数，从而节省了大量的时间和计算成本。比如下面我们举个简单的例子:</p><figure class="lf lg lh li gt iv"><div class="bz fp l di"><div class="mz mi l"/></div></figure><figure class="lf lg lh li gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi na"><img src="../Images/876dbfb29ae87fe2dc6461eac42f9ca6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5Mia3QjsQ1Ekgs6VKUs4Fw.png"/></div></div></figure><p id="bf4a" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如上所述，该函数只是计算一个给定范围内的数字的平方。大约需要 20 秒才能得到结果。现在，让我们使用<em class="mj"> joblib 的内存</em>函数，定义一个位置来存储缓存，如下所示:</p><figure class="lf lg lh li gt iv"><div class="bz fp l di"><div class="mz mi l"/></div></figure><figure class="lf lg lh li gt iv gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/3b935832ebf77f763fe209a02fbb393b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/format:webp/1*5PZWfnEY0izm6Kls6FIQeA.png"/></div></figure><p id="463f" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在第一次计算时，结果与之前的大约 20 秒非常相似，因为结果是第一次计算，然后存储到一个位置。让我们再试一次:</p><figure class="lf lg lh li gt iv"><div class="bz fp l di"><div class="mz mi l"/></div></figure><figure class="lf lg lh li gt iv gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/41730624e4edcc769f2f8772e7b888a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1394/format:webp/1*pX1ytlC1Vz6XLxHlZP0DPQ.png"/></div></figure><p id="227d" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">瞧啊。提供结果花了 0.01 秒。时间缩短了近 2000 倍。这主要是因为结果已经被计算并存储在计算机的缓存中。<em class="mj">所有功能的效率并不相同！</em>它可能因所请求的计算类型而有很大不同。但是你肯定会有这种通过缓存来加速管道的超能力！</p><p id="319f" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要清除缓存结果，可以使用一个直接命令:</p><figure class="lf lg lh li gt iv"><div class="bz fp l di"><div class="mz mi l"/></div></figure><p id="5ed1" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是在使用这段代码之前要小心。你可能会毁掉你几周的计算工作。</p><h2 id="664c" class="lj lk jj bd ll lm ln dn lo lp lq dp lr kr ls lt lu kv lv lw lx kz ly lz ma mb bi translated">2.并行化</h2><p id="1aaf" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">顾名思义，我们可以使用“<em class="mj"> joblib 并行计算任何具有多个参数的指定函数。平行”。</em>在后台，当使用多个作业(如果指定)时，每个计算不会等待前一个完成，可以使用不同的处理器来完成任务。为了更好地理解，我展示了如何在缓存中运行并行作业。</p><p id="3991" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">考虑以下生成的随机数据集:</p><figure class="lf lg lh li gt iv"><div class="bz fp l di"><div class="mz mi l"/></div></figure><p id="cb59" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是我们正常顺序处理的运行，其中新的计算仅在先前的计算完成后开始。</p><figure class="lf lg lh li gt iv"><div class="bz fp l di"><div class="mz mi l"/></div></figure><figure class="lf lg lh li gt iv gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/33de63ab6eac5c83a7d0dcfe8587f6c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*92LshFqDaxG09H4zUUpOMQ.png"/></div></figure><p id="18b2" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于并行处理，我们设置作业数= 2。作业的数量受限于 CPU 拥有或可用(空闲)的核心数量。</p><figure class="lf lg lh li gt iv"><div class="bz fp l di"><div class="mz mi l"/></div></figure><figure class="lf lg lh li gt iv gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/0447f8d6a46b321bc1511033fa4ac98b.png" data-original-src="https://miro.medium.com/v2/resize:fit:746/format:webp/1*XqDNLZ0YZGau75dhYb76Yg.png"/></div></figure><p id="34ec" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里我们可以看到使用并行方法处理的时间减少了<strong class="ki jk"> <em class="mj"> 2x </em> </strong>。</p><blockquote class="nf ng nh"><p id="6f19" class="kg kh mj ki b kj kk kl km kn ko kp kq ni ks kt ku nj kw kx ky nk la lb lc ld im bi translated"><strong class="ki jk"> <em class="jj">注意</em> </strong>:如果用于计算量较小的函数，使用此方法可能会降低性能。</p></blockquote><h2 id="8929" class="lj lk jj bd ll lm ln dn lo lp lq dp lr kr ls lt lu kv lv lw lx kz ly lz ma mb bi translated">3.倾卸和装载</h2><p id="2c50" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们经常需要存储和加载数据集、模型、计算结果等。在电脑上的某个位置来回移动。Joblib 提供了可用于轻松转储和加载的函数:</p><figure class="lf lg lh li gt iv"><div class="bz fp l di"><div class="mz mi l"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">将数据转储到某个位置的代码</p></figure><figure class="lf lg lh li gt iv"><div class="bz fp l di"><div class="mz mi l"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">从某个位置加载数据的代码</p></figure><h2 id="fd42" class="lj lk jj bd ll lm ln dn lo lp lq dp lr kr ls lt lu kv lv lw lx kz ly lz ma mb bi translated">4.压缩方法</h2><figure class="lf lg lh li gt iv"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="3336" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当处理较大的数据集时，这些文件占用的空间非常大。使用特征工程，当我们添加更多的列时，文件会变得更大。幸运的是，如今，随着存储变得如此便宜，这不再是一个问题。然而，为了提高效率，<em class="mj"> joblib </em>提供的一些压缩方法使用起来非常简单:</p><p id="fd64" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk"> a .简单压缩:</strong></p><p id="9beb" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">非常简单的就是上面显示的那个。它不提供任何压缩，但却是存储任何文件的最快方法</p><figure class="lf lg lh li gt iv"><div class="bz fp l di"><div class="mz mi l"/></div></figure><figure class="lf lg lh li gt iv gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/6863e0aae53bcebef5f9010cbae46897.png" data-original-src="https://miro.medium.com/v2/resize:fit:538/format:webp/1*zlNMu5JnrUx7Q4i5MUGKdQ.png"/></div></figure><figure class="lf lg lh li gt iv"><div class="bz fp l di"><div class="mz mi l"/></div></figure><figure class="lf lg lh li gt iv gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/6a0d5b91559fa1e7a451a4db59b497a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*ddQNqdD7WP4WAwudmw_09w.png"/></div></figure><p id="aeee" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk"> b .使用 Zlib 压缩:</strong></p><p id="1737" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是一个很好的 3 级压缩方法，实现如下:</p><figure class="lf lg lh li gt iv"><div class="bz fp l di"><div class="mz mi l"/></div></figure><figure class="lf lg lh li gt iv gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/acfbc2e8a81b8a87db3fee514d98321a.png" data-original-src="https://miro.medium.com/v2/resize:fit:586/format:webp/1*Fd4uRnWyApqRo_sOVNGniQ.png"/></div></figure><figure class="lf lg lh li gt iv"><div class="bz fp l di"><div class="mz mi l"/></div></figure><figure class="lf lg lh li gt iv gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/662a6236f1fdd71503cb52ec880d2bb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:586/format:webp/1*cL79VpjN3ZBGld-fPhBH8Q.png"/></div></figure><p id="e2bd" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk"> c .使用 lz4 压缩:</strong></p><p id="3335" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是另一个很棒的压缩方法，也是已知最快的压缩方法之一，但压缩率略低于 Zlib。我个人认为这是<strong class="ki jk">最好的方法</strong>，因为它是<em class="mj">压缩大小和压缩率之间的一个很好的平衡</em>。下面是实现它的方法:</p><figure class="lf lg lh li gt iv"><div class="bz fp l di"><div class="mz mi l"/></div></figure><figure class="lf lg lh li gt iv gh gi paragraph-image"><div class="gh gi no"><img src="../Images/0fe7d92d19cbcef37df12cb7ca325b32.png" data-original-src="https://miro.medium.com/v2/resize:fit:540/format:webp/1*ImwtWBmzu7-28FTA5VuXIg.png"/></div></figure><figure class="lf lg lh li gt iv"><div class="bz fp l di"><div class="mz mi l"/></div></figure><figure class="lf lg lh li gt iv gh gi paragraph-image"><div class="gh gi np"><img src="../Images/a29ec9a90cdf279a4bf0591e5f74e0ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:562/format:webp/1*_hd61CtjLW1GXJn1wnfvWQ.png"/></div></figure><p id="b994" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将所有内容放在一个表格中，如下所示:</p><figure class="lf lg lh li gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nq"><img src="../Images/e871aac0a1e5695e28ecae7b1a3f1136.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pYUkDsTXm4D80o84rqYKhQ.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者创造的形象</p></figure><h2 id="5493" class="lj lk jj bd ll lm ln dn lo lp lq dp lr kr ls lt lu kv lv lw lx kz ly lz ma mb bi translated">结束语:</h2><p id="9a2a" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我发现 joblib 是一个非常有用的库。我已经开始将它们集成到我的许多机器学习管道中，并且肯定看到了许多改进。</p><p id="36fd" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您抽出时间阅读这篇文章。任何意见/反馈总是很感谢！</p></div></div>    
</body>
</html>