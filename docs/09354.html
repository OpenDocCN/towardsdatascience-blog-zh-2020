<html>
<head>
<title>Slicing and Indexing with Pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用熊猫切片和索引</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/slicing-and-indexing-with-pandas-2bff05ec361e?source=collection_archive---------30-----------------------#2020-07-04">https://towardsdatascience.com/slicing-and-indexing-with-pandas-2bff05ec361e?source=collection_archive---------30-----------------------#2020-07-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="25bd" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/pytrix-series" rel="noopener" target="_blank"> PyTrix 系列</a></h2><div class=""/><div class=""><h2 id="e671" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">PyTrix #4:用熊猫访问数据</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/89928e610431eca3f3550544200c5bec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2hTgLSmM7IG05usF"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/@marvelous?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Marvin Meyer </a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="968d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">PyTrix 是一个每周一期的系列文章，我在其中展示了可以用 Python 完成的对数据科学家有用的很酷的东西。在 PyTrix 系列的前几周，我们主要研究了 Numpy 数组，具体来说是索引和切片…</p><div class="me mf gp gr mg mh"><a rel="noopener follow" target="_blank" href="/working-with-numpy-arrays-indexing-e4c08595ed57"><div class="mi ab fo"><div class="mj ab mk cl cj ml"><h2 class="bd jd gy z fp mm fr fs mn fu fw jc bi translated">使用 Numpy 数组:索引</h2><div class="mo l"><h3 class="bd b gy z fp mm fr fs mn fu fw dk translated">访问 Numpy 数组中的元素</h3></div><div class="mp l"><p class="bd b dl z fp mm fr fs mn fu fw dk translated">towardsdatascience.com</p></div></div><div class="mq l"><div class="mr l ms mt mu mq mv lb mh"/></div></div></a></div><div class="me mf gp gr mg mh"><a rel="noopener follow" target="_blank" href="/working-with-numpy-arrays-slicing-4453ec757ff0"><div class="mi ab fo"><div class="mj ab mk cl cj ml"><h2 class="bd jd gy z fp mm fr fs mn fu fw jc bi translated">使用 Numpy 数组:切片</h2><div class="mo l"><h3 class="bd b gy z fp mm fr fs mn fu fw dk translated">PyTrix #3:访问 Numpy 数组中的序列</h3></div><div class="mp l"><p class="bd b dl z fp mm fr fs mn fu fw dk translated">towardsdatascience.com</p></div></div><div class="mq l"><div class="mw l ms mt mu mq mv lb mh"/></div></div></a></div><p id="e266" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Pandas 是一个快速、强大、灵活且易于使用的开源框架，它构建在 Python 之上，用于数据操作和分析，就像 Numpy 一样，是数据科学事实上的库之一。很大一部分人很可能是从学习熊猫开始他们的数据科学之旅的，如果你没有，那么我强烈建议你阅读<a class="ae lh" href="https://pandas.pydata.org/pandas-docs/version/0.25.3/" rel="noopener ugc nofollow" target="_blank">文档</a>——当然是在阅读了这个故事之后。</p><p id="9974" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">要访问 Github 中使用的代码，请单击下面的链接。</p><div class="me mf gp gr mg mh"><a href="https://github.com/kurtispykes/demo/blob/master/pytrix/pytrix_pandas_indexing-and-slicing.ipynb" rel="noopener  ugc nofollow" target="_blank"><div class="mi ab fo"><div class="mj ab mk cl cj ml"><h2 class="bd jd gy z fp mm fr fs mn fu fw jc bi translated">kurtispykes/演示</h2><div class="mo l"><h3 class="bd b gy z fp mm fr fs mn fu fw dk translated">permalink dissolve GitHub 是超过 5000 万开发人员的家园，他们一起工作来托管和审查代码，管理…</h3></div><div class="mp l"><p class="bd b dl z fp mm fr fs mn fu fw dk translated">github.com</p></div></div><div class="mq l"><div class="mx l ms mt mu mq mv lb mh"/></div></div></a></div><h2 id="dfad" class="my mz it bd na nb nc dn nd ne nf dp ng lr nh ni nj lv nk nl nm lz nn no np iz bi translated">索引的选择</h2><p id="9d12" class="pw-post-body-paragraph li lj it lk b ll nq kd ln lo nr kg lq lr ns lt lu lv nt lx ly lz nu mb mc md im bi translated">对于许多学习熊猫来说，他们的多轴索引方法很少被实践者理解，这是公平的，因为有许多方法来进行对象选择:</p><ul class=""><li id="d7c3" class="nv nw it lk b ll lm lo lp lr nx lv ny lz nz md oa ob oc od bi translated"><code class="fe oe of og oh b">.loc</code>主要基于标签，这意味着它从索引中选择带有显式标签的行(或列)。因此，如果没有找到项目，将引发一个<code class="fe oe of og oh b">KeyError</code>。</li><li id="a190" class="nv nw it lk b ll oi lo oj lr ok lv ol lz om md oa ob oc od bi translated"><code class="fe oe of og oh b">.iloc</code>主要基于整数位置(从 0 到轴的长度-1 ),这意味着行(或列)是根据其在索引中的位置来选择的——它只接受整数。如果索引器越界，则会引发<code class="fe oe of og oh b">IndexError</code>。</li><li id="1edc" class="nv nw it lk b ll oi lo oj lr ok lv ol lz om md oa ob oc od bi translated"><code class="fe oe of og oh b">[]</code>主要用于筛选出低维切片。</li></ul><blockquote class="on oo op"><p id="ab85" class="li lj oq lk b ll lm kd ln lo lp kg lq or ls lt lu os lw lx ly ot ma mb mc md im bi translated"><strong class="lk jd">注意:</strong>Python 和 NumPy 索引操作符<code class="fe oe of og oh b">[]</code>和属性操作符<code class="fe oe of og oh b">.</code>提供了跨越广泛用例的对 pandas 数据结构的快速和简单的访问。这使得交互式工作变得直观，因为如果您已经知道如何处理 Python 字典和 NumPy 数组，就没有什么新东西需要学习了。然而，由于要访问的数据类型事先不知道，直接使用标准操作符有一些优化限制。对于生产代码，我们建议您利用本章中介绍的优化的 pandas 数据访问方法。</p><p id="42a1" class="li lj oq lk b ll lm kd ln lo lp kg lq or ls lt lu os lw lx ly ot ma mb mc md im bi translated">-熊猫的摘录<a class="ae lh" href="https://pandas.pydata.org/pandas-docs/version/0.25.3/user_guide/indexing.html" rel="noopener ugc nofollow" target="_blank">文档</a></p></blockquote></div><div class="ab cl ou ov hx ow" role="separator"><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz"/></div><div class="im in io ip iq"><h2 id="96aa" class="my mz it bd na nb nc dn nd ne nf dp ng lr nh ni nj lv nk nl nm lz nn no np iz bi translated">使用[ ]的属性访问</h2><p id="9242" class="pw-post-body-paragraph li lj it lk b ll nq kd ln lo nr kg lq lr ns lt lu lv nt lx ly lz nu mb mc md im bi translated">对于那些一直关注 PyTrix 系列的读者，或者如果您对 Python 索引行为有所了解，那么您会知道用于索引低维切片的主要方法是<code class="fe oe of og oh b">[]</code>。</p><pre class="ks kt ku kv gt pb oh pc pd aw pe bi"><span id="7f32" class="my mz it oh b gy pf pg l ph pi">import pandas as pd<br/>import numpy as np </span><span id="5127" class="my mz it oh b gy pj pg l ph pi">df= pd.DataFrame(np.random.randn(5, 5), <br/>             columns=["col_1", "col_2", "col_3", "col_4", "col_5"])</span><span id="775a" class="my mz it oh b gy pj pg l ph pi">df </span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/1e67ac82217783f76fda79119a533686.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*RyaT47bRAUawtQFCsJgDYg.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图 1</p></figure><pre class="ks kt ku kv gt pb oh pc pd aw pe bi"><span id="0f7c" class="my mz it oh b gy pf pg l ph pi"><em class="oq"># access all elements in "col_1"</em> <br/>df["col_1"]</span><span id="ba1b" class="my mz it oh b gy pj pg l ph pi">&gt;&gt;&gt;&gt; 0    0.32<br/>1    0.74<br/>2    0.14<br/>3    0.79<br/>4    0.58<br/>Name: col_1, dtype: float64</span></pre><p id="9fd3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">从上面我们可以看到，使用<code class="fe oe of og oh b">[]</code>来索引 Pandas DataFrame 类会返回一个对应于列名的<code class="fe oe of og oh b">series</code>。如果数据是一个<code class="fe oe of og oh b">series</code>，将返回一个标量，例如我将使用上面返回的序列来显示我们可以像这样返回一个标量:</p><pre class="ks kt ku kv gt pb oh pc pd aw pe bi"><span id="cca4" class="my mz it oh b gy pf pg l ph pi">a = df["col_1"]<br/>a[1] </span><span id="2698" class="my mz it oh b gy pj pg l ph pi">&gt;&gt;&gt;&gt; 0.79390631428754759</span></pre><p id="eb4b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是最基本的索引形式。我们也可以将一个列列表传递给<code class="fe oe of og oh b">[]</code>来按顺序选择列。</p><pre class="ks kt ku kv gt pb oh pc pd aw pe bi"><span id="34c5" class="my mz it oh b gy pf pg l ph pi">df[["col_2", "col_3", "col_4"]]</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/2b551db1070523c52db3a9a77008b8c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*X0NjnYqTymuIxE75EgPtsA.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图二。</p></figure><p id="d3e0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我不会深入研究这个功能，因为它非常类似于普通 Python 和 Numpy 中的索引和切片，除了开始和结束边界都被返回。</p></div><div class="ab cl ou ov hx ow" role="separator"><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz"/></div><div class="im in io ip iq"><h2 id="8dd0" class="my mz it bd na nb nc dn nd ne nf dp ng lr nh ni nj lv nk nl nm lz nn no np iz bi translated">按标签选择</h2><p id="a588" class="pw-post-body-paragraph li lj it lk b ll nq kd ln lo nr kg lq lr ns lt lu lv nt lx ly lz nu mb mc md im bi translated">Pandas 使用一个严格的基于包含的原则，允许所有用于基于标签的索引的方法正确运行——未能提供一个不在索引中的标签将引发<code class="fe oe of og oh b">KeyError</code>。</p><p id="74ad" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于这一部分，我将创建一个新的熊猫数据框架</p><pre class="ks kt ku kv gt pb oh pc pd aw pe bi"><span id="5e8c" class="my mz it oh b gy pf pg l ph pi">new_df = pd.DataFrame(np.random.randn(10, 4), index=list("abcdefghij"), columns=list("ABCD"))</span><span id="a95b" class="my mz it oh b gy pj pg l ph pi">new_df</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pm"><img src="../Images/b04fa8e70105fb44db9d394c132577c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*0zplqjZ2brNZq0sXlNTMrQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图 3。</p></figure><p id="a1b2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">按标签选择时，<code class="fe oe of og oh b">.loc</code>属性是主要的访问方法。<code class="fe oe of og oh b">.loc</code>的有效输入如下:</p><ul class=""><li id="bd95" class="nv nw it lk b ll lm lo lp lr nx lv ny lz nz md oa ob oc od bi translated">单个标签(注意，标签可以是整数，不涉及沿索引的整数位置)</li></ul><pre class="ks kt ku kv gt pb oh pc pd aw pe bi"><span id="2781" class="my mz it oh b gy pf pg l ph pi"># cross-section using a single label<br/>new_df.loc["a"]</span><span id="a923" class="my mz it oh b gy pj pg l ph pi">&gt;&gt;&gt;&gt; A    0.952954<br/>B   -1.310324<br/>C   -1.376740<br/>D    0.276258<br/>Name: a, dtype: float64</span></pre><ul class=""><li id="183b" class="nv nw it lk b ll lm lo lp lr nx lv ny lz nz md oa ob oc od bi translated">标签的列表或数组</li></ul><pre class="ks kt ku kv gt pb oh pc pd aw pe bi"><span id="f0f2" class="my mz it oh b gy pf pg l ph pi"># A list or array of labels<br/>new_df.loc[["a", "d ", "i"]]</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/b0bcfdec7155f92dbcff87976b7a2273.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/format:webp/1*YHySM5CjSc_FGie29K3_JA.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图 4。</p></figure><ul class=""><li id="b861" class="nv nw it lk b ll lm lo lp lr nx lv ny lz nz md oa ob oc od bi translated">带标签的切片(注意，与 Python 切片相反，开始和结束边界都包含在切片中)</li></ul><pre class="ks kt ku kv gt pb oh pc pd aw pe bi"><span id="fc0b" class="my mz it oh b gy pf pg l ph pi"># slice with labels<br/>new_df.loc["a":"d", "B":]</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi po"><img src="../Images/661cc4f674bae376e216cc41ebcf43b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:716/format:webp/1*wNpJ30FrSngYRzOF7SgfmA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图 5。</p></figure><ul class=""><li id="d554" class="nv nw it lk b ll lm lo lp lr nx lv ny lz nz md oa ob oc od bi translated">布尔数组</li></ul><pre class="ks kt ku kv gt pb oh pc pd aw pe bi"><span id="dc18" class="my mz it oh b gy pf pg l ph pi"># a boolean array<br/>new_df.loc["j"] &gt; 0.5</span><span id="ebd7" class="my mz it oh b gy pj pg l ph pi">&gt;&gt;&gt;&gt; A    False<br/>B    False<br/>C     True<br/>D     True<br/>Name: j, dtype: bool</span><span id="7d29" class="my mz it oh b gy pj pg l ph pi"><br/># another way to use a boolean array <br/>new_df.loc[:, new_df.loc["j"] &gt; 0.5]</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/9aa7e18147653e427794702eca600c2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:488/format:webp/1*4mYFOM2KQ_1TlynXPJ-yyA.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图 6。</p></figure><h2 id="127b" class="my mz it bd na nb nc dn nd ne nf dp ng lr nh ni nj lv nk nl nm lz nn no np iz bi translated">按位置选择</h2><p id="8f88" class="pw-post-body-paragraph li lj it lk b ll nq kd ln lo nr kg lq lr ns lt lu lv nt lx ly lz nu mb mc md im bi translated">Pandas 使用符合 Python 和 Numpy 切片语义的<code class="fe oe of og oh b">0-based</code>索引。有多种方法可用于通过使用纯基于整数的索引按位置访问元素。试图使用一个非整数，不管其有效性如何，都会引发一个<code class="fe oe of og oh b">IndexError</code>。</p><pre class="ks kt ku kv gt pb oh pc pd aw pe bi"><span id="a119" class="my mz it oh b gy pf pg l ph pi"><em class="oq"># using same df but new index values<br/></em>new_df.index = list(range(0, 10))<br/>new_df</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pq"><img src="../Images/e4aef90885356538c505fb8aa158f4f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/format:webp/1*GZNxr7Ltt2_HzCy7bRIn0A.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图 7。</p></figure><p id="bf83" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">按位置选择时，<code class="fe oe of og oh b">.iloc</code>属性是主要的访问方法。<code class="fe oe of og oh b">.iloc</code>的有效输入如下:</p><ul class=""><li id="91a3" class="nv nw it lk b ll lm lo lp lr nx lv ny lz nz md oa ob oc od bi translated">整数</li></ul><pre class="ks kt ku kv gt pb oh pc pd aw pe bi"><span id="2e20" class="my mz it oh b gy pf pg l ph pi"><em class="oq"># cross section using an integer position</em><br/>new_df.iloc[3]</span><span id="619a" class="my mz it oh b gy pj pg l ph pi">&gt;&gt;&gt;&gt; A   -0.650225<br/>B    1.571667<br/>C   -1.204090<br/>D    0.637101<br/>Name: 3, dtype: float64</span></pre><ul class=""><li id="f6ed" class="nv nw it lk b ll lm lo lp lr nx lv ny lz nz md oa ob oc od bi translated">整数的列表或数组</li></ul><pre class="ks kt ku kv gt pb oh pc pd aw pe bi"><span id="c072" class="my mz it oh b gy pf pg l ph pi"><em class="oq"># list or array of integers</em><br/>new_df.iloc[[1, 5, 2, 3]]</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/0258eebb2262ed6771b262da9e7beae9.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*wWJBb1AwOhd_iJZ3Ih2gCQ.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图 8。</p></figure><pre class="ks kt ku kv gt pb oh pc pd aw pe bi"><span id="da64" class="my mz it oh b gy pf pg l ph pi"># another example <br/>new_df.iloc[[1, 2, 3, 4], [0, 1, 2]]</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ps"><img src="../Images/e7b3caee5f3296d2b0e92a271a80d628.png" data-original-src="https://miro.medium.com/v2/resize:fit:714/format:webp/1*dYYyGvxyQnMY90M0MhASag.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图 9。</p></figure><ul class=""><li id="cb01" class="nv nw it lk b ll lm lo lp lr nx lv ny lz nz md oa ob oc od bi translated">带有整数的切片对象</li></ul><pre class="ks kt ku kv gt pb oh pc pd aw pe bi"><span id="0713" class="my mz it oh b gy pf pg l ph pi"># integer slicing<br/>new_df.iloc[:3] </span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pt"><img src="../Images/0cc689025e3dc312f64ae253be0f231e.png" data-original-src="https://miro.medium.com/v2/resize:fit:914/format:webp/1*78y9eAx2SIV-kVb9fM1P0g.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图 10。</p></figure><pre class="ks kt ku kv gt pb oh pc pd aw pe bi"><span id="6a20" class="my mz it oh b gy pf pg l ph pi"># integer slicing by column<br/>new_df.iloc[:, :3]</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pu"><img src="../Images/7c0e750834565c69e8acc212b971ffa0.png" data-original-src="https://miro.medium.com/v2/resize:fit:734/format:webp/1*bq_6BgCc1o65ST2V5Ksn6A.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图 11。</p></figure><ul class=""><li id="f098" class="nv nw it lk b ll lm lo lp lr nx lv ny lz nz md oa ob oc od bi translated">布尔数组。</li></ul><pre class="ks kt ku kv gt pb oh pc pd aw pe bi"><span id="3f92" class="my mz it oh b gy pf pg l ph pi">new_df.iloc[1:] &gt; 0.5</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pv"><img src="../Images/20682193dc7bb0724719f9756bcc2b7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*qxDaPq3r1M47AV32raG3ow.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图 12。</p></figure><p id="1ecc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当使用超出界限的切片时，这可能导致空轴。</p><pre class="ks kt ku kv gt pb oh pc pd aw pe bi"><span id="233c" class="my mz it oh b gy pf pg l ph pi">new_df.iloc[10:13]</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pw"><img src="../Images/2e43a15bc63fb3302d738557a963c0c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:270/format:webp/1*248h_wfQxceE12JVzVxfzw.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图 13。</p></figure><p id="c7df" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，如果我们试图调用一个越界的索引器，这将引发<code class="fe oe of og oh b">IndexError</code>。此外，如果我们试图调用任何元素越界的索引器列表，那么这也会引发一个<code class="fe oe of og oh b">IndexError</code>。</p><blockquote class="on oo op"><p id="9e26" class="li lj oq lk b ll lm kd ln lo lp kg lq or ls lt lu os lw lx ly ot ma mb mc md im bi translated"><strong class="lk jd">注意:是否为设置操作返回副本或引用，可能取决于上下文。这有时被称为</strong> <code class="fe oe of og oh b"><strong class="lk jd">chained assignment</strong></code> <strong class="lk jd">，应该避免。参见</strong> <a class="ae lh" href="https://pandas.pydata.org/pandas-docs/version/0.25.3/user_guide/indexing.html#indexing-view-versus-copy" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd">返回视图与</strong> </a> <strong class="lk jd">复制。</strong></p></blockquote></div><div class="ab cl ou ov hx ow" role="separator"><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz"/></div><div class="im in io ip iq"><h2 id="5fb7" class="my mz it bd na nb nc dn nd ne nf dp ng lr nh ni nj lv nk nl nm lz nn no np iz bi translated">可调用选择</h2><p id="eaac" class="pw-post-body-paragraph li lj it lk b ll nq kd ln lo nr kg lq lr ns lt lu lv nt lx ly lz nu mb mc md im bi translated">以上所有属性都可以接受一个叫做<code class="fe oe of og oh b">callable</code>的东西作为索引器。对<code class="fe oe of og oh b">callable</code>的要求是，它必须是一个带有一个参数的函数，返回索引的有效输出。</p><pre class="ks kt ku kv gt pb oh pc pd aw pe bi"><span id="c3ba" class="my mz it oh b gy pf pg l ph pi"># selection by a callable using []<br/>new_df[lambda df: df.columns[3]]</span><span id="3591" class="my mz it oh b gy pj pg l ph pi">&gt;&gt;&gt;&gt; 0    0.276258<br/>1   -0.617174<br/>2    0.229638<br/>3    0.637101<br/>4    0.977468<br/>5    0.401624<br/>6   -0.659852<br/>7    0.984220<br/>8    0.947080<br/>9    1.182526<br/>Name: D, dtype: float64</span></pre><p id="ae0a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这将返回索引 3 处的一系列列(在此场景中，索引 3 处的列是“D”)。</p><pre class="ks kt ku kv gt pb oh pc pd aw pe bi"><span id="830b" class="my mz it oh b gy pf pg l ph pi"># selection by a callable using .loc <br/>new_df.loc[:, lambda df: ["A", "B"]] </span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi px"><img src="../Images/338dfef11deb3802b4bffc63c6ec0a88.png" data-original-src="https://miro.medium.com/v2/resize:fit:504/format:webp/1*j2Y23894455nVnj09GzQgg.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图 14。</p></figure><p id="db24" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这个例子中，我们使用<code class="fe oe of og oh b">.loc</code>属性返回所有的行和列 A 和 B。下面我们将使用<code class="fe oe of og oh b">.iloc</code>做完全相同的事情。</p><pre class="ks kt ku kv gt pb oh pc pd aw pe bi"><span id="48b5" class="my mz it oh b gy pf pg l ph pi"># selection by a callable using .iloc <br/>new_df.iloc[:, lambda df: [0, 1]]</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi px"><img src="../Images/338dfef11deb3802b4bffc63c6ec0a88.png" data-original-src="https://miro.medium.com/v2/resize:fit:504/format:webp/1*j2Y23894455nVnj09GzQgg.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图 15。</p></figure></div><div class="ab cl ou ov hx ow" role="separator"><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz"/></div><div class="im in io ip iq"><h2 id="2dc7" class="my mz it bd na nb nc dn nd ne nf dp ng lr nh ni nj lv nk nl nm lz nn no np iz bi translated">包裹</h2><p id="e19c" class="pw-post-body-paragraph li lj it lk b ll nq kd ln lo nr kg lq lr ns lt lu lv nt lx ly lz nu mb mc md im bi translated">Pandas 对于数据科学家来说是一个非常有用的工具。值得通读一下<a class="ae lh" href="https://pandas.pydata.org/pandas-docs/version/0.25.3/user_guide/indexing.html" rel="noopener ugc nofollow" target="_blank">文档</a>看看这个包里还有什么很酷的东西，因为有太多东西我在这篇文章里没有涉及到，例如如何在<code class="fe oe of og oh b">pd.Series</code>上使用这些操作。</p><p id="f35c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">感谢您花时间阅读这个故事。如果你喜欢它，你可以在 PyTrix 系列中找到更多类似的文章。</p><div class="me mf gp gr mg mh"><a href="https://towardsdatascience.com/tagged/pytrix-series" rel="noopener follow" target="_blank"><div class="mi ab fo"><div class="mj ab mk cl cj ml"><h2 class="bd jd gy z fp mm fr fs mn fu fw jc bi translated">Pytrix 系列-走向数据科学</h2><div class="mo l"><h3 class="bd b gy z fp mm fr fs mn fu fw dk translated">阅读《走向数据科学》中关于 Pytrix 系列的文章。共享概念、想法和代码的媒体出版物。</h3></div><div class="mp l"><p class="bd b dl z fp mm fr fs mn fu fw dk translated">towardsdatascience.com</p></div></div><div class="mq l"><div class="py l ms mt mu mq mv lb mh"/></div></div></a></div><p id="ab6f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果您想亲自联系我，我是 LinkedIn 上最活跃的用户，我会非常乐意与您联系！</p><div class="me mf gp gr mg mh"><a href="https://www.linkedin.com/in/kurtispykes/" rel="noopener  ugc nofollow" target="_blank"><div class="mi ab fo"><div class="mj ab mk cl cj ml"><h2 class="bd jd gy z fp mm fr fs mn fu fw jc bi translated">Kurtis Pykes -人工智能博客-走向数据科学| LinkedIn</h2><div class="mo l"><h3 class="bd b gy z fp mm fr fs mn fu fw dk translated">在世界上最大的职业社区 LinkedIn 上查看 Kurtis Pykes 的个人资料。Kurtis 有两个工作列在他们的…</h3></div><div class="mp l"><p class="bd b dl z fp mm fr fs mn fu fw dk translated">www.linkedin.com</p></div></div><div class="mq l"><div class="pz l ms mt mu mq mv lb mh"/></div></div></a></div></div></div>    
</body>
</html>