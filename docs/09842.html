<html>
<head>
<title>GARCH &amp; Google getting along good. GG!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GARCH 和谷歌相处融洽。GG！</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/garch-google-getting-along-good-gg-aaaefff2e498?source=collection_archive---------41-----------------------#2020-07-12">https://towardsdatascience.com/garch-google-getting-along-good-gg-aaaefff2e498?source=collection_archive---------41-----------------------#2020-07-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="12ec" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用 GARCH 过程预测谷歌股票收益的波动性。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e5b9315934ee50ece9aa5964575aa1d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_zLJ1kTp4Za-fMzk"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@angelacompagnone?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">安吉拉·孔波妮</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="7972" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated"><span class="l lw lx ly bm lz ma mb mc md di"> G </span>在本文中，我们将关注 GARCH/ARCH 模型及其重要性，尤其是在金融相关领域。在这里，我们将对谷歌股票价格回报的波动性进行建模和预测，然后进行一些与未来几天回报值的波动性相关的推断。在应用中，如果一只股票的回报波动性较小，我们可能会投资于风险较小的股票，而不是在给定的时期内，同样的模型波动性更大或变化更大。</p><p id="cd7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">研究<em class="me">条件异方差</em>的主要动机与金融中资产收益的波动性有关。波动性的重要性是显而易见的，因为它有广泛的应用，如期权定价、风险管理(风险价值计算)、波动指数(VIX)交易。因此，如果我们能有效地预测波动性/方差，我们就能创造更复杂的工具来制定交易策略。这里有一个快速的术语介绍，忽略这里的数学方程。更多信息，请参考。</p><h1 id="f813" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">广义自回归</h1><p id="f580" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">AR 或自回归项突出了与序列中先前元素相关联的方差的线性组合。AR 滞后阶数，<em class="me"> p </em>定义滞后版本的阶数，用于回归给定时间序列中的方差。换句话说，ARCH(p)过程遵循一个<a class="ae ky" href="https://machinelearningmastery.com/autoregression-models-time-series-forecasting-python/" rel="noopener ugc nofollow" target="_blank"> AR(p) </a>过程。相关的问题是，我们是否可以应用<a class="ae ky" href="https://otexts.com/fpp2/MA.html" rel="noopener ugc nofollow" target="_blank"> MA(q) </a>或移动平均模型来模拟我们的方差以及 AR 过程，这是 GARCH 或广义 ARCH 过程的动机，它试图考虑移动平均成分以及自回归成分。因此，GARCH(2，2)过程由 AR(2)和 MA(2)过程组成。而简单的 ARCH 过程不考虑移动平均项；ARCH(p)模型。</p><h1 id="b20b" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">条件异方差</h1><p id="832d" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">让我们先快速地看一下我们所说的<em class="me">异方差</em>是什么意思，然后是<em class="me">条件</em>部分。当在一个变量集合中，我们看到一个在某个区域(或子集)上相当大的增加或减少的方差分组时，比如在一段时间内，它通常不同于集合中的其余变量，并且我们可以看到变化方差的“群集”，那么这种形式的规则变化在数学上被称为异方差。这种不同形式的金融波动可以由各种原因触发，这些原因导致序列<em class="me">相关</em>异方差，以变化方差的周期为条件。换句话说，方差的增加与方差的进一步增加相关。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><p id="b409" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们对正在进行的工作有了一个大致的了解，让我们开始实现，并通过预测一段时间内的值来做一些有趣的预测。</p><h2 id="8787" class="nj mg it bd mh nk nl dn ml nm nn dp mp li no np mr lm nq nr mt lq ns nt mv nu bi translated">程序步骤:</h2><ol class=""><li id="a226" class="nv nw it lb b lc mx lf my li nx lm ny lq nz lu oa ob oc od bi translated">从雅虎财经获取谷歌股票数据。</li><li id="6ec2" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated">计算和分析资产回报。</li><li id="cbc5" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated">确定阶数并拟合 GARCH 模型。</li><li id="e23f" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated">训练模型。</li><li id="4ec1" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated">验证模型。</li><li id="cf6b" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated">预测。</li></ol><blockquote class="oj ok ol"><p id="fc24" class="kz la me lb b lc ld ju le lf lg jx lh om lj lk ll on ln lo lp oo lr ls lt lu im bi translated"><strong class="lb iu">获取谷歌股票数据</strong></p></blockquote><p id="a267" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python 中的 yfinance 包支持直接从 yahoo finance 中轻松获取股票数据。我们必须提供正确的股票代码，如谷歌的“GOOG”或微软的“MSFT ”,以创建股票包装器。然后，我们使用<em class="me">。包装器的 history() </em>方法，通过指定数据的开始和结束日期来获取数据帧形式的数据(这里是<em class="me"> df_goog </em>)。我们获取 2015 年到最近可用日期的数据。</p><pre class="kj kk kl km gt op oq or os aw ot bi"><span id="799e" class="nj mg it oq b gy ou ov l ow ox">today = datetime.today().strftime('%Y-%m-%d')<br/>td1 = yf.Ticker('GOOG')<br/>df_goog = td1.history(start = '2015-01-01', end = today, period = '1d')<br/>df_goog.info()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/06f8aea5170cc8073060038447831b70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NCDG2IMyug6gfKp0EzrxpA.png"/></div></div></figure><blockquote class="oj ok ol"><p id="c6d6" class="kz la me lb b lc ld ju le lf lg jx lh om lj lk ll on ln lo lp oo lr ls lt lu im bi translated"><strong class="lb iu">计算和分析资产收益</strong></p></blockquote><p id="3ec8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们通过将我们的数据帧移动一个周期，然后使用 NumPy 的<em class="me">，来计算对数回报(这里知道<a class="ae ky" href="https://tradingqna.com/t/why-stock-returns-are-calculated-in-log-scale/806" rel="noopener ugc nofollow" target="_blank"><em class="me"/></a>为什么对数回报优于正常回报)。【T21 日志()】法。我们的数据框中添加了一个相同的列。</em></p><pre class="kj kk kl km gt op oq or os aw ot bi"><span id="3e20" class="nj mg it oq b gy ou ov l ow ox">df_goog_shifted = df_goog.Close.shift(1)<br/>df_goog['Return'] = np.log(df_goog.Close/df_goog_shifted).mul(100)<br/>df_goog.dropna(inplace = True)<br/>df_goog</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/6142bf295326eb3496450ed33807340d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i6ORC1nHsoC9DyYRrV1MAQ.png"/></div></div></figure><p id="0794" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们通过绘制 2015 年以来每天的数据来可视化我们的资产回报。</p><pre class="kj kk kl km gt op oq or os aw ot bi"><span id="a700" class="nj mg it oq b gy ou ov l ow ox">yr = pd.date_range(start = '2015', end = '2020' , freq = 'Y')<br/>ret = df_goog['Return']<br/>fig = plt.figure()<br/>plt.plot(ret)<br/>plt.title("Asset Returns")<br/>for i in yr:<br/>    plt.axvline(i, linestyle = '--' , color = 'gray')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/fb5a38b633e94364842624e8701fdd88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GYiCxlEAgFh9NQbq-pdYRQ.png"/></div></div></figure><p id="8547" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了检查回报是否平稳，我们应用了<a class="ae ky" href="https://www.machinelearningplus.com/time-series/augmented-dickey-fuller-test/#:~:text=Augmented%20Dickey%20Fuller%20test%20(ADF%20Test)%20is%20a%20common%20statistical,the%20stationary%20of%20a%20series." rel="noopener ugc nofollow" target="_blank"> <em class="me">增广迪基富勒</em> </a>测试；零假设的统计检验，表明由于趋势分量，序列是非平稳的。从<em class="me">stats models . TSA . stat tools</em>我们导入<em class="me"> adfuller </em> API 作为<em class="me"> adf。</em>检验的 p 值是检验结果的第二个要素。</p><pre class="kj kk kl km gt op oq or os aw ot bi"><span id="a751" class="nj mg it oq b gy ou ov l ow ox">p_val = adf(ret)[1]<br/>print("Since the pvalue:",p_val,"in the Augmented Dicky Fuller test is less than 5% we easily reject \<br/>the null-hypothesis that returns are non-stationary")</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/cab88c732d68dd75e5089ff56b79fb1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DS4tX0bNIOSuU-7_3Ds2RA.png"/></div></div></figure><p id="09d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们可以得出结论，我们的回报是相当稳定的，可以建模。这是必要的，以确保平稳性，因为这种模型像 ARMA，ARIMA，GARCH 等。可以应用于平稳过程。(知道<a class="ae ky" href="https://www.itl.nist.gov/div898/handbook/pmc/section4/pmc442.htm#:~:text=A%20common%20assumption%20in%20many,do%20not%20change%20over%20time.&amp;text=The%20differenced%20data%20will%20contain%20one%20less%20point%20than%20the%20original%20data." rel="noopener ugc nofollow" target="_blank">为什么吗？</a>)此外，直观上看不出季节性。</p><blockquote class="oj ok ol"><p id="23ed" class="kz la me lb b lc ld ju le lf lg jx lh om lj lk ll on ln lo lp oo lr ls lt lu im bi translated"><strong class="lb iu">确定阶次并拟合 GARCH 模型</strong></p></blockquote><p id="5253" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过绘制几个滞后的收益平方的偏自相关图，我们得到了 GARCH 过程的阶<em class="me"> p </em>和<em class="me"> q </em>的概念。<em class="me">stats models . graphics . TSA plots</em>的<em class="me"> plot_pacf </em>就是用来实现这个目的的。</p><p id="64d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="me">从 statsmodels.graphics.tsaplots 导入 plot_pacf </em></p><pre class="kj kk kl km gt op oq or os aw ot bi"><span id="c074" class="nj mg it oq b gy ou ov l ow ox">fig = plot_pacf(ret**2, lags = 20, zero = False)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/c189210090d974cb2ec38eb20609ef86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NRHJo-z-_-dk3-44fJgL4A.png"/></div></div></figure><p id="69ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们观察到，在滞后 2 之后，该图似乎停止了，这表明了它的重要性。这表明我们可以尝试 GARCH(2，2)过程。现在，我们拟合模型，为此，我们使用了<em class="me"> arch </em> API 的<em class="me"> arch_model </em>函数。假设标准化残差的分布函数是学生 t 的分布函数。</p><p id="f5b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="me">从 arch 导入 arch_model </em></p><pre class="kj kk kl km gt op oq or os aw ot bi"><span id="3e4a" class="nj mg it oq b gy ou ov l ow ox">model = arch_model(ret , p = 2, q = 2, dist = 't').fit(disp='off')<br/>model.summary()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/bee2f7e7de88a09b8831cffe00d27da3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hIpqlc8mjoUn7MJEkiQqpA.png"/></div></div></figure><blockquote class="oj ok ol"><p id="e69e" class="kz la me lb b lc ld ju le lf lg jx lh om lj lk ll on ln lo lp oo lr ls lt lu im bi translated"><strong class="lb iu">训练模型</strong></p></blockquote><p id="f0e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了训练我们的模型，我们使用固定<a class="ae ky" href="https://www.r-bloggers.com/formal-ways-to-compare-forecasting-models-rolling-windows/" rel="noopener ugc nofollow" target="_blank"> <em class="me">滚动窗口预测</em> </a>(一种回溯测试)的技术，其中窗口大小是固定的。我们的想法是预测特定范围内的值，然后在我们知道该范围内的实际(真实)值时，移动窗口以包括这些预测值，从而更好地训练我们的模型，并再次预测下一个范围。这使预测适应新的观测结果，并避免回顾偏差。它也较少受到过度拟合的影响。在所取的窗口大小上重复该过程。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/a43a85a29143bb3e2861809d880b3323.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4Zf5Mks02mCkjVSymostBQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://eng.uber.com/omphalos/" rel="noopener ugc nofollow" target="_blank">图像来源</a></p></figure><p id="233f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们取一个窗口大小为一年中交易天数的 5 倍(即 252)，并利用历史数据来训练我们的模型。生成回报以及预测值的曲线图。在使用<em class="me"> arch_model </em>函数拟合一个模型之后，我们使用<em class="me">。forecast() </em>方法通过设置参数<em class="me"> horizon = 1 来预测紧接的下一个值。</em>准确地说，是进行 1 天滚动窗口预测。请记住，我们需要找到标准偏差，这就是为什么我们取预测方差的平方根。</p><pre class="kj kk kl km gt op oq or os aw ot bi"><span id="7e54" class="nj mg it oq b gy ou ov l ow ox">rolling = []<br/>window = 252*5<br/>for i in range(window):<br/>    train_data = ret[:-(window-i)]<br/>    model = arch_model(train_data, p = 2, q = 2).fit(disp='off')<br/>    pred = model.forecast(horizon = 1)<br/>    rolling.append(np.sqrt(pred.variance.values)[-1,:][0])<br/>rolling = pd.Series(rolling , index = ret.index[-window:])<br/>plt.plot(ret[-window:])<br/>plt.plot(rolling)<br/>plt.legend(['Returns','Volatility'])<br/>plt.title('Rolling Window Forecast')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/8e9ef754d33292074363cd6f3f3f99ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_IkGnKTkiyGTKLfkMFDRyg.png"/></div></div></figure><p id="1fc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到，我们的模型能够捕捉随时间变化的方差。有必要知道橙色曲线表明我们的股票回报有多波动。当收益偏离均值时，波动率曲线也会偏离，以表明方差变化的时期。橙色长尖峰表示高波动时期，而较短的尖峰表示资产回报波动较小的时期。从视觉上看，我们的模型似乎工作得还不错，但最好在其他统计测试的帮助下进行验证。</p><blockquote class="oj ok ol"><p id="a11f" class="kz la me lb b lc ld ju le lf lg jx lh om lj lk ll on ln lo lp oo lr ls lt lu im bi translated"><strong class="lb iu">验证模型</strong></p></blockquote><p id="b05f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数学上，标准残差是残差除以其标准差。它是对观察值和期望值之间差异强度的度量。标准残差应遵循一个<a class="ae ky" href="https://en.wikipedia.org/wiki/White_noise" rel="noopener ugc nofollow" target="_blank">白噪声</a>过程；一个过程，其中变量是连续不相关的(在任何滞后时间都相互独立)，具有零均值和有限方差。我们将在这里使用三种验证技术:</p><p id="3c00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">a)绘制标准化残差图，直观地查看残差是否遵循白噪声<em class="me"> </em>过程。这里，标准化残差<em class="me"> std_resid </em>通过使用<em class="me">来计算。resid </em>和<em class="me">。我们的模型对象的 conditional_volatility </em>属性如下面的代码所示。</p><p id="ae02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">b)绘制自动相关图，以验证标准残差在任何滞后时间都不显著相关。除了滞后零点之外，在图中看不到明显的滞后。</p><p id="8ef6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从<em class="me">stats models . graphics . TSA plots</em>导入<em class="me"> plot_acf </em></p><pre class="kj kk kl km gt op oq or os aw ot bi"><span id="d184" class="nj mg it oq b gy ou ov l ow ox">std_resid = model.resid/model.conditional_volatility<br/>fig, ax = plt.subplots(nrows = 2, ncols = 0)<br/>ax[0] = plt.plot(std_resid, color = ‘r’)<br/>plt.title(‘Standardised Residuals’)<br/>for i in yr:<br/> plt.axvline(i, linestyle = ‘ — ‘ , color = ‘gray’)<br/>ax[1] = plot_acf(std_resid,lags = 20)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/26e898e2c0b883c31d35d8e20129e124.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IaxeU2TmynwSsIhH-eW2tA.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pf"><img src="../Images/9665aabb5dbfe8666d1964792b414950.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X6cQUM-JozCGm56eZdy9DQ.png"/></div></div></figure><p id="3691" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">c)执行<a class="ae ky" href="https://www.statisticshowto.com/ljung-box-test/" rel="noopener ugc nofollow" target="_blank">l 接线盒</a>测试。这个测试的动机不仅仅是检查不同滞后的随机性，就像案例 b 一样，相反，它让我们了解基于指定滞后数的变量的总体随机性。零假设:数据是独立分布的。每个滞后的 p 值大于 5%，表明我们未能拒绝零假设。</p><p id="b56b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="me">从 statsmodels.stats.diagnostic 导入 acorr_ljungbox </em></p><pre class="kj kk kl km gt op oq or os aw ot bi"><span id="70f7" class="nj mg it oq b gy ou ov l ow ox">lb_test = acorr_ljungbox(std_resid, lags = 20)<br/>lb_test[1] //gives us the p-values at each lag</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/047bbc39eb2275e47743a7a5df51e7eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p8noIoaINGDM92fzv0bIFA.png"/></div></div></figure><p id="8060" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上述所有三种情况下，可以得出合理的结论，因为我们的模型正在产生表示白噪声过程的标准化残差，变量是随机的，因此彼此不相关，我们拟合和训练的模型工作得相当好。</p><blockquote class="oj ok ol"><p id="32c9" class="kz la me lb b lc ld ju le lf lg jx lh om lj lk ll on ln lo lp oo lr ls lt lu im bi translated"><strong class="lb iu">预测</strong></p></blockquote><p id="0b33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，是时候做一些预测了！我们将使用我们的模型来获得未来七天的波动预测。为了实现这一点，我们指定<em class="me">视界</em>参数<em class="me"> </em>等于 7。这里需要注意的是，这些预测逐渐趋向于长期平均值。</p><pre class="kj kk kl km gt op oq or os aw ot bi"><span id="f984" class="nj mg it oq b gy ou ov l ow ox">future_index = pd.date_range(start = (df_goog.index[-1]+timedelta(1)).strftime("%Y-%m-%d"), periods = 7, freq = 'D')<br/>predict = model.forecast(horizon = 7)<br/>pred_vol = np.sqrt(predict.variance.values[-1:][0])<br/>pred_vol = pd.Series(pred_vol,index = future_index)<br/>plt.plot(pred_vol, marker = 'o', markerfacecolor = 'r', linestyle = '--', markeredgecolor = 'k', markersize = 6)<br/>plt.title("Next seven day volatility forecast")<br/>plt.grid(True)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ph"><img src="../Images/bb8f55707df33d7ea7f6639f59257ec7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mt5QTtzHMdC5gvtvGpvzAQ.png"/></div></div></figure><p id="886d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">预测表明波动性变化会略有增加，然后最终下降。那么回报的波动性是高还是低呢？投资谷歌是不是一个风险很大的时候？你能有多自信？</p><p id="3485" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="me">注:</em>您可以选择更高阶的模型，如 GARCH(3，0)或 GARCH(3，3)模型，但请记住，模型摘要中的<em class="me"> omega </em>、<em class="me"> alpha、</em>和<em class="me"> beta </em>参数的值应该非常重要。另外，不要忘记检查和验证相应的标准残差。</p><p id="3030" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的<a class="ae ky" href="https://github.com/swarn6/GARCH/blob/master/Untitled4.ipynb" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到 jupyter 笔记本。</p><p id="d86c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="me">参考资料:- </em></p><div class="pi pj gp gr pk pl"><a href="https://www.quantstart.com/articles/Generalised-Autoregressive-Conditional-Heteroskedasticity-GARCH-p-q-Models-for-Time-Series-Analysis/" rel="noopener  ugc nofollow" target="_blank"><div class="pm ab fo"><div class="pn ab po cl cj pp"><h2 class="bd iu gy z fp pq fr fs pr fu fw is bi translated">时间序列的广义自回归条件异方差 GARCH(p，q)模型</h2><div class="ps l"><h3 class="bd b gy z fp pq fr fs pr fu fw dk translated">在这篇文章中，我们将考虑著名的广义自回归条件异方差模型…</h3></div><div class="pt l"><p class="bd b dl z fp pq fr fs pr fu fw dk translated">www.quantstart.com</p></div></div><div class="pu l"><div class="pv l pw px py pu pz ks pl"/></div></div></a></div><p id="8fcf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">领英:- </p><div class="pi pj gp gr pk pl"><a href="https://www.linkedin.com/in/swarn6/" rel="noopener  ugc nofollow" target="_blank"><div class="pm ab fo"><div class="pn ab po cl cj pp"><h2 class="bd iu gy z fp pq fr fs pr fu fw is bi translated">Swarnim Pandey — SRM 大学—印度北方邦勒克瑙| LinkedIn</h2><div class="ps l"><h3 class="bd b gy z fp pq fr fs pr fu fw dk translated">查看世界上最大的职业社区 LinkedIn 上的 Swarnim Pandey 的个人资料。Swarnim 有 2 份工作列在…</h3></div><div class="pt l"><p class="bd b dl z fp pq fr fs pr fu fw dk translated">www.linkedin.com</p></div></div><div class="pu l"><div class="qa l pw px py pu pz ks pl"/></div></div></a></div></div></div>    
</body>
</html>