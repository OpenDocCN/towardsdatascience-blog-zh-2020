<html>
<head>
<title>NHL Analytics With Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python进行NHL分析</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/nhl-analytics-with-python-6390c5d3206d?source=collection_archive---------14-----------------------#2020-04-24">https://towardsdatascience.com/nhl-analytics-with-python-6390c5d3206d?source=collection_archive---------14-----------------------#2020-04-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c4f6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我用数据理解NHL的冒险</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a3c881f3eb3330b4d549bcb40d8c0aef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*11_2jyRK8Dser9oAG2ATfQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这就是我们今天要做的！分析的最终结果显示，亚历克斯·奥韦奇金是左翼之王。</p></figure><p id="5999" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi lu translated">阿纳达。曲棍球。有些人可能会说，他们是一体的，然而我从来没有真正成为一个超级体育迷。在枫叶队进入季后赛的罕见情况下，我会穿上蓝色的衣服，和我的朋友一起去酒吧等待不可避免的失望，但是当他们开始谈论球员和他们在赛季中的表现时，我开始感觉有点疏远。因此，为了更好地理解这款游戏，我决定戴上数据分析帽，深入研究一些NHL球员的数据。</p><p id="de95" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我做的第一件事是查看什么样的数据是可用的，哦，我没有失望！实际上有一个未记录的NHL数据API，包含从球队日程和花名册到<strong class="la iu"> <em class="md">的所有内容，包括在冰上拍摄的每一个镜头，包括地点，涉及的球员和发生的时间</em> </strong>。对于那些好奇的人，一个很棒的人创建了一个GIT页面，其中有API调用的摘要(<a class="ae me" href="https://github.com/dword4/nhlapi" rel="noopener ugc nofollow" target="_blank"> NHL API文档</a>)。有了这个，我就有了提取数据和开始做一些球员分析所需的一切。</p><h1 id="b140" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">正在提取NHL API数据</h1><p id="3e34" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">我所有的分析都是用Python完成的，为了更简单，我使用Kaggle作为我的编码平台。如果你还没有检查Kaggle出来，你真的应该。他们有一堆开放的数据集、竞赛以及分享和存储你的笔记本的方式(Jupyter)。我将在这里展示的所有代码都可以从我的Kaggle帐户上公开获得(参见底部的参考资料),所以请随意探索和使用它。由于数据集如此之深，我决定只提取2019-2020赛季的游戏事件数据进行分析。这让我可以访问到目前为止的所有比赛，包括所有冰上项目(击球、击球、对抗等。).</p><p id="bc09" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">和往常一样，首先要做的是加载包和初始化变量。这里你会看到我使用<strong class="la iu">请求</strong>从API获取数据，使用<strong class="la iu"> pickle </strong>保存数据以备后用。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="23d1" class="nh mg it nd b gy ni nj l nk nl">import requests<br/>import pickle</span><span id="7c86" class="nh mg it nd b gy nm nj l nk nl"><strong class="nd iu"># Set up the API call variables</strong><br/>game_data = []<br/>year = '2019'<br/>season_type = '02' <br/>max_game_ID = 1290</span></pre><p id="abe3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">API的格式允许我们传入赛季的年份，选择比赛类型，如预赛/常规赛/季后赛(本例中02是常规赛)，最后是<em class="md"> max_game_ID </em>。这是给定年份中游戏事件的最大数量。</p><p id="871f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">是时候提取数据并将json格式的数据存储到一个列表中了。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="2c33" class="nh mg it nd b gy ni nj l nk nl"><strong class="nd iu"># Loop over the counter and format the API call</strong><br/>for i in range(0,max_game_ID):<br/>    r = requests.get(url='<a class="ae me" href="http://statsapi.web.nhl.com/api/v1/game/'" rel="noopener ugc nofollow" target="_blank">http://statsapi.web.nhl.com/api/v1/game/'</a><br/>        + year + season_type +str(i).zfill(4)+'/feed/live')</span><span id="c93e" class="nh mg it nd b gy nm nj l nk nl">    data = r.json()<br/>    game_data.append(data)</span></pre><p id="a480" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在所有的甜蜜数据都存储在一个列表中，我们可以把它保存为一个pickle文件。我这样做的原因是，我可以把它上传到Kaggle上，并让任何想做一些分析的人都可以使用它。Pickle文件还允许存储对象，并且加载速度非常快。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="1f7c" class="nh mg it nd b gy ni nj l nk nl">with open('./'+year+'FullDataset.pkl', 'wb') as f:<br/>    pickle.dump(game_data, f, pickle.HIGHEST_PROTOCOL)</span></pre><p id="dd66" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这样我们就有了一个名为<strong class="la iu"> 2019FullDataset.pkl </strong>的新文件，我们将其保存为Kaggle上的数据集。您可以查看底部的参考资料，获取指向我的数据集的链接。</p><p id="24b2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在是有趣的事情！你可以做很多事情，但我想做的是观察任何球员在冰面上不同位置的<strong class="la iu"><em class="md"/></strong>投篮效率，并将它们与整个联盟的平均成功率进行比较。</p><h1 id="777c" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">分析球员投篮数据</h1><p id="545f" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">利用NHL的数据，我想看看<em class="md">在哪里</em>球员的投篮效率最高(进球/总投篮百分比)与联盟平均水平相比。首先，让我们导入所有必需的包。注意我使用<strong class="la iu"> <em class="md"> matplotlib </em> </strong>进行所有的绘图。我还安装了<strong class="la iu"> <em class="md">枕头</em> </strong>来导入图像数据。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="e254" class="nh mg it nd b gy ni nj l nk nl">import numpy as np <br/>import pandas as pd <br/>import pickle    <br/>import matplotlib<br/>import matplotlib.pyplot as plt<br/>color_map = plt.cm.winter<br/>from matplotlib.patches import RegularPolygon<br/>import math<br/>from PIL import Image</span><span id="94f7" class="nh mg it nd b gy nm nj l nk nl"><strong class="nd iu"># Needed for custom colour mapping!<br/></strong>from matplotlib.colors import ListedColormap,LinearSegmentedColormap<br/>import matplotlib.colors as mcolors</span></pre><p id="1bb5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于我所有的绘图，我将使用matplotlib方法ListedColormap来使用自定义的颜色图。因为我想给正值涂上不同于负值的颜色，所以我做了两个颜色映射。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="aeae" class="nh mg it nd b gy ni nj l nk nl">c = mcolors.ColorConverter().to_rgb()<br/>positive_cm = ListedColormap([c(‘#e1e5e5’),c(‘#d63b36’)])<br/>negative_cm = ListedColormap([c(‘#e1e5e5’),c(‘#28aee4’)]) </span></pre><p id="bb09" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们已经解决了这个问题，让我们加载2019年常规赛的pickle数据文件，其中包含了每场比赛的所有事件数据。注意，我们正在加载之前生成的pickle文件。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="0a93" class="nh mg it nd b gy ni nj l nk nl">with open(‘../input/nhl-data/2019FullDataset.pkl’, ‘rb’) as f:<br/>    game_data = pickle.load(f)</span></pre><h1 id="e877" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">计算平均投篮命中率%</h1><p id="21a7" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">加载数据后，我想首先计算出联盟在冰上每一点的平均命中率。使用字典中的<em class="md">事件</em>和<em class="md">坐标</em>对象输入数据。在我们的分析中，我们只想关注“射门”和“进球”类型的事件。</p><p id="9e66" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是一步一步的细分:</p><p id="9396" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，我们创建一个字典来保存整个联盟的所有射门和进球数据坐标。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="b1f3" class="nh mg it nd b gy ni nj l nk nl"><strong class="nd iu"># Do some dictionary initialisation to hold our cleaned and condensed league data</strong><br/>league_data = {};</span><span id="78a2" class="nh mg it nd b gy nm nj l nk nl">league_data[‘Shot’] = {};<br/>league_data[‘Shot’][‘x’] = [];<br/>league_data[‘Shot’][‘y’] = [];</span><span id="c8fe" class="nh mg it nd b gy nm nj l nk nl">league_data[‘Goal’] = {};<br/>league_data[‘Goal’][‘x’] = [];<br/>league_data[‘Goal’][‘y’] = [];</span></pre><p id="0c66" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们只想保留射门和进球数据中的事件。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="7c4d" class="nh mg it nd b gy ni nj l nk nl">event_types = ['Shot','Goal']</span></pre><p id="88f4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，我们循环播放每一个游戏，并将相关信息提取到我们的字典中。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="eb68" class="nh mg it nd b gy ni nj l nk nl"><strong class="nd iu"># First loop over the elements of game_data. Each one of these is an NHL game and contains all of the game event data.</strong><br/>for data in game_data:</span><span id="fd03" class="nh mg it nd b gy nm nj l nk nl"><strong class="nd iu">   # It is possible that the game data is not assigned to the data<br/>   set, so to handle this we look for the key ‘liveData’ which <br/>   contains all of the data we are looking for, otherwise we<br/>   continue</strong><br/>   if 'liveData' not in data:<br/>        continue</span><span id="1252" class="nh mg it nd b gy nm nj l nk nl"><strong class="nd iu">   # Drilling down into the dataset to extract the play by play<br/>   information for the game</strong><br/>   plays = data['liveData']['plays']['allPlays'] <br/>    <br/>    for play in plays: <strong class="nd iu"># For each play</strong><br/>         for event in event_types: <strong class="nd iu"> # For each event (Shot,Goal)</strong></span><span id="d368" class="nh mg it nd b gy nm nj l nk nl">            <strong class="nd iu"># If the play contains one of the events</strong><br/>            if play['result']['event'] in [event]:  </span><span id="2356" class="nh mg it nd b gy nm nj l nk nl">              <strong class="nd iu"># If the event contains coordinates</strong><br/>               if 'x' in play['coordinates']:</span><span id="5dc5" class="nh mg it nd b gy nm nj l nk nl"><strong class="nd iu">                  # Save the coordinates to the growing list<br/></strong>                  league_data[event]<br/>                       ['x'].append(play['coordinates']['x'])<br/>                    league_data[event]<br/>                       ['y'].append(play['coordinates']['y'])</span></pre></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><p id="a8c8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们有了联赛数据，我们可以对给定的球员做同样的事情。唯一的区别是，在提取数据时，我们将筛选射手子事件类型。</p><p id="71b3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在咨询了一些冰球迷后，我被告知亚历克斯·奥韦奇金是一个很好的测试案例。他活跃在一个非常独特的领域，我们应该能够基于此来验证事情。</p><p id="3678" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">球员数据提取与联赛数据提取非常相似，所以我在这里只注意变化:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="ac28" class="nh mg it nd b gy ni nj l nk nl"><strong class="nd iu"># Initialise the player dictionary<br/>full_name = 'Alex Ovechkin'</strong><br/>player_data = {};</span><span id="b9e4" class="nh mg it nd b gy nm nj l nk nl">player_data['Shot'] = {};<br/>player_data['Shot']['x'] = [];<br/>player_data['Shot']['y'] = [];</span><span id="392b" class="nh mg it nd b gy nm nj l nk nl">player_data['Goal'] = {};<br/>player_data['Goal']['x'] = [];<br/>player_data['Goal']['y'] = [];</span></pre><p id="009c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们基本上做和以前一样的过程，但是寻找球员数据。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="402f" class="nh mg it nd b gy ni nj l nk nl"><strong class="nd iu"># Same code as before<br/></strong>...</span><span id="13c3" class="nh mg it nd b gy nm nj l nk nl">for play in plays:<br/>   <strong class="nd iu">if 'players' in play:<br/>      for player in play['players']:<br/>         if player['player']['fullName'] in [full_name]  <br/>            and player['playerType'] in ["Shooter","Scorer"]:</strong></span><span id="d409" class="nh mg it nd b gy nm nj l nk nl"><strong class="nd iu">            </strong>for event in event_types:<br/>                        <br/>...</span></pre><p id="2f68" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面加粗的部分，你可以看到我们正在过滤作为<em class="md">射手</em>或<em class="md">得分手</em>的玩家。每场比赛都包括谁参与其中，所以我们可以简单地看看奥韦奇金是否被列为射手或得分手。有了它，我们可以处理一些数字，做一些很酷的分析。</p><h1 id="141f" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">计算基本统计数据</h1><p id="99df" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">在我们绘制位置数据之前，我想计算一下与联盟平均水平相比，玩家的高水平数据。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="465a" class="nh mg it nd b gy ni nj l nk nl"><strong class="nd iu"># Get the total number of shots made by the player<br/></strong>player_total_shots = len(player_data['Shot']['x']) +<br/>   len(player_data['Goal']['x'])</span><span id="bc26" class="nh mg it nd b gy nm nj l nk nl"><strong class="nd iu"># Find the players goal score percentage</strong><br/>player_goal_pct = len(player_data['Goal']['x'])/player_total_shots</span><span id="aa59" class="nh mg it nd b gy nm nj l nk nl"><strong class="nd iu"># Find the total number of shots taken in the league<br/></strong>league_total_shots = len(league_data['Shot']['x']) +<br/>   len(league_data['Goal']['x'])</span><span id="5c11" class="nh mg it nd b gy nm nj l nk nl"><strong class="nd iu"># Get the league percentage</strong><br/>league_goal_pct = len(league_data['Goal']['x'])/league_total_shots</span><span id="42fc" class="nh mg it nd b gy nm nj l nk nl"><strong class="nd iu"># Calculate the spread of the SOG (Shots on Goal) %</strong><br/>PL_e_spread = player_goal_pct-league_goal_pct</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/06b2c646037cc9ff7e92740c4d91dffa.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/1*_HPs1cqt1RaWv3NF0SiF4g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">汇总统计数据</p></figure><p id="fdf4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是我们的第一个结果。我们可以把它与官方数据进行比较，结果是一致的。</p><blockquote class="nv nw nx"><p id="6d61" class="ky kz md la b lb lc ju ld le lf jx lg ny li lj lk nz lm ln lo oa lq lr ls lt im bi translated">我们可以看到，奥韦奇金5.85%的利差意味着他是一个高效的得分手。</p></blockquote><p id="59a6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是在冰面上所有的点都是这样吗？他有强势的一面吗，或者有什么弱点吗？现在我们可以开始位置分析了。</p><h1 id="430e" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">射击位置分析和标绘</h1><p id="f033" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">我们首先要做的是建立一个宁滨网格。我想知道在冰上的什么地方拍摄，但我不想看到所有的个人镜头。通过进行空间平均，我们可以做出更有洞察力和更直观的表示。来自API的位置数据来自:</p><ul class=""><li id="1faa" class="ob oc it la b lb lc le lf lh od ll oe lp of lt og oh oi oj bi translated">X: -100至100米</li><li id="97c6" class="ob oc it la b lb ok le ol lh om ll on lp oo lt og oh oi oj bi translated">Y: -42.5至42.5米</li></ul><p id="3285" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于我们的宁滨，我们使用来自matplotlib的十六进制图来提取原始的宁滨数据，并将使用绘制的矩形(同样是matplotlib)来获得最终的视觉效果。</p><p id="6cba" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，我们定义我们的图形尺寸和网格大小:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="ca39" class="nh mg it nd b gy ni nj l nk nl"><strong class="nd iu"># To keep the aspect ration correct we use a square figure size</strong><br/>xbnds = np.array([-100.,100.0])<br/>ybnds = np.array([-100,100])<br/>extent = [xbnds[0],xbnds[1],ybnds[0],ybnds[1]]</span><span id="71ac" class="nh mg it nd b gy nm nj l nk nl"><strong class="nd iu"># We are going to bin in 30 unit increments.  It is fun to play with this!  </strong><br/>gridsize= 30;mincnt=0</span></pre><p id="0f0a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来我们会发现联盟在冰上各个位置的效率。为此，我们调用hexbin方法并提取位置顶点和计数数据。</p><p id="a97d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">需要注意的一点是，由于记分员从不在自己的网上得分，我们必须确保反面位置总是代表进攻方。</p><p id="2c24" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这都是因为每一个周期玩家都会换边，而坐标系是固定的。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="87c9" class="nh mg it nd b gy ni nj l nk nl"><strong class="nd iu"># First concatenate the arrays for x and y league data<br/></strong>league_x_all_shots = league_data['Shot']['x'] <br/>   + league_data['Goal']['x'];<br/>league_y_all_shots = league_data['Shot']['y'] <br/>   + league_data['Goal']['y']</span><span id="72a4" class="nh mg it nd b gy nm nj l nk nl"><strong class="nd iu"># Perform the coordinate flipping!<br/></strong>league_x_all_shots_normalized = [];<br/>league_y_all_shots_normalized = []</span><span id="f940" class="nh mg it nd b gy nm nj l nk nl"><strong class="nd iu"># Enumerate the list so we can use the index for y also</strong><br/>for i,s in enumerate(league_x_all_shots):<br/>    if league_x_all_shots[i] &lt;0:<br/>        league_x_all_shots_normalized.append(-league_x_all_shots[i])<br/>        league_y_all_shots_normalized.append(-league_y_all_shots[i])<br/>    else:<br/>        league_x_all_shots_normalized.append(league_x_all_shots[i])<br/>        league_y_all_shots_normalized.append(league_y_all_shots[i])<br/>        <br/><strong class="nd iu"># Do the same treatment for the goals</strong><br/>league_x_goal_normalized = [];<br/>league_y_goal_normalized=[]<br/>for i,s in enumerate(league_data['Goal']['x']):<br/>    if league_data['Goal']['x'][i] &lt;0:<br/>       league_x_goal_normalized.append(-league_data['Goal']['x'][i])<br/>       league_y_goal_normalized.append(-league_data['Goal']['y'][i])<br/>    else:<br/>       league_x_goal_normalized.append(league_data['Goal']['x'][i])<br/>       league_y_goal_normalized.append(league_data['Goal']['y'][i])</span></pre><p id="def4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">酷毙了。现在是为了钱！调用hexbin图并提取计数和位置。这部分有点长，但只要跟着评论走，就应该很清楚了。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="1a83" class="nh mg it nd b gy ni nj l nk nl"><strong class="nd iu"># First we will used the hexbin function to simply bucket our shot data into basically a 2D histogram</strong><br/>league_hex_data = plt.hexbin(league_x_all_shots_normalized,<br/>   league_y_all_shots_normalized,gridsize=gridsize,<br/>   extent=extent,mincnt=mincnt,alpha=0.0)</span><span id="3dda" class="nh mg it nd b gy nm nj l nk nl"><strong class="nd iu"># Now we extract the bin coordinates and counts</strong><br/>league_verts = league_hex_data.get_offsets();<br/>league_shot_frequency = league_hex_data.get_array();</span><span id="b203" class="nh mg it nd b gy nm nj l nk nl"><strong class="nd iu"># Do the same thing for the goal data</strong><br/>league_goal_hex_data =  plt.hexbin(league_x_goal_normalized,<br/>   league_y_goal_normalized,gridsize=gridsize,<br/>   extent=extent,mincnt=mincnt,alpha=0.0)</span><span id="f2ff" class="nh mg it nd b gy nm nj l nk nl"><strong class="nd iu"># Since the grid is the same we can use a shared bin coordinate set from the above. So here we just get the counts</strong><br/>league_goal_frequency = league_goal_hex_data.get_array();</span></pre><p id="7813" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们有了拍摄数据的位置和数量，我们将尝试以一种有用的方式展示它。首先，我们加载半个NHL溜冰场的比例模型图像。然后，我们将确保缩放我们的坐标，以匹配图像的大小，从而获得照片在冰上的准确位置。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="f0af" class="nh mg it nd b gy ni nj l nk nl"><strong class="nd iu"># Using matplotlib we create a new figure for plotting</strong><br/>fig=plt.figure(figsize=(10,10))<br/>ax = fig.add_subplot(111)</span><span id="16d5" class="nh mg it nd b gy nm nj l nk nl"><strong class="nd iu"># Clean up the figure to be completely blank</strong><br/>ax.set_facecolor("white")<br/>fig.patch.set_facecolor("white")<br/>fig.patch.set_alpha(0.0)</span><span id="d69a" class="nh mg it nd b gy nm nj l nk nl"><strong class="nd iu"># Remove the labelling of axes</strong><br/>ax.set_xticklabels(labels = [''], fontsize = 18,<br/>   alpha = .7,minor=False)<br/>ax.set_yticklabels(labels = [''], fontsize = 18,<br/>   alpha = .7,minor=False)</span><span id="fbbb" class="nh mg it nd b gy nm nj l nk nl"><strong class="nd iu"># Using pillow to get the rink image and extract the image size</strong><br/>I = Image.open('../input/nhl-images/half.png')<br/>ax.imshow(I);width, height = I.size</span></pre><p id="1fa1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此时，我们应该有一个曲棍球场的图像被绘制成matplotlib图像。接下来，我们要确定一些缩放因子和偏移，以对齐我们的图像和数据坐标系。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="ebcf" class="nh mg it nd b gy ni nj l nk nl"><strong class="nd iu"># Calculate the scaling factor and offset (trial and error)</strong><br/>scalingx=width/100-0.6;<br/>scalingy=height/100+0.5;<br/>x_trans=33;<br/>y_trans=height/2</span><span id="f48e" class="nh mg it nd b gy nm nj l nk nl"><strong class="nd iu"># We will want to scale the size of our hex bins with the image so we calculate a "radius" scaling factor here</strong><br/>S = 3.8*scalingx;</span></pre><p id="8171" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">终于我们准备好了。Matplotlib允许在给定的多边形形状中添加面片元素。所以我们将使用六边形元素在溜冰场图像上添加补丁。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="0e31" class="nh mg it nd b gy ni nj l nk nl"><strong class="nd iu"># Loop over the locations and draw the hex</strong><br/>for i,v in enumerate(league_verts):</span><span id="0e49" class="nh mg it nd b gy nm nj l nk nl">   <strong class="nd iu"># Ignore empty locations</strong><br/>   if league_shot_frequency[i] &lt; 1:continue<br/>   <br/>   <strong class="nd iu"># Normalize the shot frequency data between 0-1 </strong><br/>   scaled_league_shot_frequency =<br/>      league_shot_frequency[i]/max(league_shot_frequency)</span><span id="c1f8" class="nh mg it nd b gy nm nj l nk nl">   <strong class="nd iu"># Scale the hexagon size based on shot frequency</strong><br/>   radius = S*math.sqrt(scaled_league_shot_frequency)</span><span id="6912" class="nh mg it nd b gy nm nj l nk nl"><strong class="nd iu">   # Finally we will plot the hexagon including the scaling and<br/>   translations we found earlier</strong><br/>   hex = RegularPolygon((x_trans+v[0]*scalingx, <br/>      y_trans-v[1]*scalingy),numVertices=6, radius=radius,<br/>      orientation=np.radians(0),alpha=0.5, edgecolor=None)</span><span id="2a8a" class="nh mg it nd b gy nm nj l nk nl">   ax.add_patch(hex)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/318e70f3dc81f7f0e7784b960d8aabaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/1*i1yDFIt0VhEDGsaW83jAmw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">成功！我们在联盟中有一个很好的<strong class="bd oq">拍摄分布</strong>。</p></figure><p id="3e91" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以看到，平均而言，这些射门相当对称，而且大多发生在网前。你也可以在蓝线上看到一个大的下降，这也是有道理的。</p><p id="3c8b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在让我们对球员数据做同样的事情。唯一的区别是所有的变量都用“球员”替换了“联赛”前缀。例如:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="1912" class="nh mg it nd b gy ni nj l nk nl"><strong class="nd iu">player</strong>_x_all_shots = <strong class="nd iu">player</strong>_data['Shot']['x'] <br/>  + <strong class="nd iu">player</strong>_data['Goal']['x'];</span><span id="7127" class="nh mg it nd b gy nm nj l nk nl"><strong class="nd iu">player</strong>_y_all_shots = <strong class="nd iu">player</strong>_data['Shot']['y'] <br/>  + <strong class="nd iu">player</strong>_data['Goal']['y']</span></pre><p id="2684" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们将不再只是绘制照片，而是用绿色的显示<em class="md">的目标。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/9c5dbbfaf79135c38015389d41c118ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/1*DLH4I8nGiE55HYF6atR61w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">展示了奥韦奇金的射门和进球。</p></figure><p id="37a5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">非常酷！我们可以看到他在圆圈上方的左侧非常活跃。在和我的冰球朋友商量后，我发现这真的是他的地盘！但是现在我们应该看看他在冰上的效率。这是他的地盘吗，因为他经常在那里投篮？</p><blockquote class="nv nw nx"><p id="b6e0" class="ky kz md la b lb lc ju ld le lf jx lg ny li lj lk nz lm ln lo oa lq lr ls lt im bi translated">为了做到这一点，我将使十六进制的大小，射击频率和颜色代表他的效率。</p></blockquote><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="8f06" class="nh mg it nd b gy ni nj l nk nl"><strong class="nd iu"># Get some lists initialised </strong><br/>league_efficiency = []<br/>player_efficiency = []<br/>relative_efficiency = []</span><span id="8536" class="nh mg it nd b gy nm nj l nk nl"><strong class="nd iu"># Looping over the league shots (which are the same in length as player)</strong><br/>for i in range(0,len(league_shot_frequency)):</span><span id="43b0" class="nh mg it nd b gy nm nj l nk nl"><strong class="nd iu">    # We will only look at positions on the ice where the player or<br/>    league had more than two shots during the season</strong><br/>    if league_shot_frequency[i]&lt;2 or player_shot_frequency[i]&lt;2:<br/>        continue<br/>    </span><span id="b5b5" class="nh mg it nd b gy nm nj l nk nl"><strong class="nd iu"># Calculate the efficiencies </strong><br/>league_efficiency.append(<br/>   league_goal_frequency[i]/league_shot_frequency[i])<br/>    <br/>player_efficiency.append(<br/>   player_goal_frequency[i]/player_shot_frequency[i])<br/>    <br/><strong class="nd iu"># And the relative efficiency</strong><br/>relative_efficiency.append(<br/>   (player_goal_frequency[i]/player_shot_frequency[i]-<br/>   (league_goal_frequency[i]/league_shot_frequency[i]))</span><span id="625a" class="nh mg it nd b gy nm nj l nk nl"><strong class="nd iu"># Keep track of the max so we can scale the colour and radius of the hex plot after</strong><br/>max_league_efficiency = max(league_efficiency)<br/>max_player_efficiency = max(player_efficiency)<br/>max_relative_efficiency = max(relative_efficiency)<br/>min_relative_efficiency = min(relative_efficiency)</span></pre><p id="a784" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，我们为绘制在给定位置拍摄的相对效率的最后阶段做好了准备。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="7de5" class="nh mg it nd b gy ni nj l nk nl"><strong class="nd iu"># Loop over the locations and draw the hex</strong><br/>for i,v in enumerate(player_verts):</span><span id="af6d" class="nh mg it nd b gy nm nj l nk nl"><strong class="nd iu">    # Here we will only include locations where the player made at<br/>    least on shot.  We will adjust this later for plotting.</strong><br/>    if player_shot_frequency[i] &lt; 1:continue<br/>    <br/>   <strong class="nd iu"> # Scaling the frequencies</strong><br/>    scaled_player_shot_frequency =<br/>        player_shot_frequency[i]/max(player_shot_frequency)</span><span id="9029" class="nh mg it nd b gy nm nj l nk nl">    <strong class="nd iu"># Calculate a radius of the hex</strong><br/>    radius = S*math.sqrt(scaled_player_shot_frequency)<br/>   <br/><strong class="nd iu">    # Find the player efficiency and relative at this point on the<br/>    ice.  <br/>    </strong>player_efficiency =<br/>        player_goal_frequency[i]/player_shot_frequency[i]<br/>    league_efficiency =<br/>        league_goal_frequency[i]/league_shot_frequency[i]</span><span id="0654" class="nh mg it nd b gy nm nj l nk nl"><strong class="nd iu">    # This is what we were after the whole time!   </strong><br/>    relative_efficiency = player_efficiency - league_efficiency<br/>  <br/>   <strong class="nd iu"># Since there can be positive and negative efficiencies<br/>   (relative) we colour the more efficient locations red and the<br/>   less blue.<br/>   </strong>if relative_efficiency&gt;0:<br/>        colour = positive_cm(math.pow(relative_efficiency,0.1))<br/>   else:<br/>        colour = negative_cm(math.pow(-relative_efficiency,0.1))<br/>   <br/>   <strong class="nd iu"># And finally we plot!   </strong> <br/>   hex = RegularPolygon((x_trans+v[0]*scalingx,<br/>       y_trans-v[1]*scalingy),numVertices=6, radius=radius,<br/>       orientation=np.radians(0),facecolor=colour,alpha=1,<br/>       edgecolor=None)<br/>   ax.add_patch(hex)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/852e007554d5fbf3a11a0e4616a66f48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/1*f6OYpwgsj-OFShbOkkdekQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">看起来不错，但是有点忙。</p></figure><p id="9fe2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后一步，我们可以增加要查看的数据点的阈值。让我们只看看他在赛季中拍摄超过4张照片的地点。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/790bc744b2226d7ee72eb5a9764bf16f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/1*MO93vKmNLg0Vnh03bQ_3sg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">最终图像可用于后期处理和发布。</p></figure><p id="a856" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">哇！现在看起来相当不错！我们可以清楚地看到奥韦奇金在左路是一个超级高效的球员，这也是他投篮最多的地方。与联盟平均水平相比，他是惊人的。</p><p id="7439" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们确实发现的一件事是，当谈到在网前投篮时，他低于平均水平(根据十六进制尺寸，这看起来很常见)。这可能是帮助他提高或用来对付他的东西！</p><p id="fed9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，我把这个给了我的曲棍球朋友，经过回顾，他们基本上说:</p><blockquote class="or"><p id="bbb7" class="os ot it bd ou ov ow ox oy oz pa lt dk translated">”丫显然嗯了一声。那完全是他的地盘！”</p></blockquote><p id="6a30" class="pw-post-body-paragraph ky kz it la b lb pb ju ld le pc jx lg lh pd lj lk ll pe ln lo lp pf lr ls lt im bi translated">你知道吗？这是我能收到的最好的评论。</p><h1 id="6781" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">参考和代码</h1><p id="75f0" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated"><strong class="la iu">图片</strong></p><blockquote class="nv nw nx"><p id="2bb1" class="ky kz md la b lb lc ju ld le lf jx lg ny li lj lk nz lm ln lo oa lq lr ls lt im bi translated">本文中的所有图片都是我自己用python + Photopea制作的</p></blockquote><p id="686e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">数据抓取</strong></p><div class="pg ph gp gr pi pj"><a href="https://www.kaggle.com/kapastor/nhl-analytics-data-collection" rel="noopener  ugc nofollow" target="_blank"><div class="pk ab fo"><div class="pl ab pm cl cj pn"><h2 class="bd iu gy z fp po fr fs pp fu fw is bi translated">NHL分析-数据收集</h2><div class="pq l"><h3 class="bd b gy z fp po fr fs pp fu fw dk translated">使用Kaggle笔记本探索和运行机器学习代码|使用来自非数据源的数据</h3></div><div class="pr l"><p class="bd b dl z fp po fr fs pp fu fw dk translated">www.kaggle.com</p></div></div><div class="ps l"><div class="pt l pu pv pw ps px ks pj"/></div></div></a></div><p id="97b0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">数据集</strong></p><div class="pg ph gp gr pi pj"><a href="https://www.kaggle.com/kapastor/nhl-data" rel="noopener  ugc nofollow" target="_blank"><div class="pk ab fo"><div class="pl ab pm cl cj pn"><h2 class="bd iu gy z fp po fr fs pp fu fw is bi translated">NHL数据</h2><div class="pq l"><h3 class="bd b gy z fp po fr fs pp fu fw dk translated">2015-2019赛季常规NHL数据。包括所有游戏和事件。</h3></div><div class="pr l"><p class="bd b dl z fp po fr fs pp fu fw dk translated">www.kaggle.com</p></div></div><div class="ps l"><div class="py l pu pv pw ps px ks pj"/></div></div></a></div><p id="164d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">数据分析</strong></p><div class="pg ph gp gr pi pj"><a href="https://www.kaggle.com/kapastor/nhl-analysis-shot-distribution" rel="noopener  ugc nofollow" target="_blank"><div class="pk ab fo"><div class="pl ab pm cl cj pn"><h2 class="bd iu gy z fp po fr fs pp fu fw is bi translated">NHL分析-镜头分布</h2><div class="pq l"><h3 class="bd b gy z fp po fr fs pp fu fw dk translated">使用Kaggle笔记本探索和运行机器学习代码|使用来自多个数据源的数据</h3></div><div class="pr l"><p class="bd b dl z fp po fr fs pp fu fw dk translated">www.kaggle.com</p></div></div><div class="ps l"><div class="pz l pu pv pw ps px ks pj"/></div></div></a></div><p id="d1d4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> NHL API </strong></p><blockquote class="nv nw nx"><p id="ad0e" class="ky kz md la b lb lc ju ld le lf jx lg ny li lj lk nz lm ln lo oa lq lr ls lt im bi translated"><a class="ae me" href="http://statsapi.web.nhl.com/api/v1/game/'" rel="noopener ugc nofollow" target="_blank">http://statsapi.web.nhl.com/api/v1/game/</a></p></blockquote></div></div>    
</body>
</html>