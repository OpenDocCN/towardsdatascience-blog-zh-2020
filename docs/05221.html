<html>
<head>
<title>Handling Pandas Groupby and its Multi-Indexes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">熊猫分组及其多指标处理</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/handling-pandas-groupby-and-its-multi-indexes-efae3e6b788c?source=collection_archive---------17-----------------------#2020-05-04">https://towardsdatascience.com/handling-pandas-groupby-and-its-multi-indexes-efae3e6b788c?source=collection_archive---------17-----------------------#2020-05-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="973d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">熊猫群入门</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/baf3b1658ea4d8dd027b369f38e9bbcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RyvIa5rJU1KaDtJJ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Pandas groupby 方法产生了几个级别的索引和列</p></figure><p id="f734" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Pandas 被认为是任何使用 Python 的数据科学家的必备工具。一个常用的特性是<code class="fe lu lv lw lx b">groupby</code> <em class="ly"> </em>方法。然而，那些刚刚过渡到 pandas 的人可能会觉得有点困惑，尤其是如果你来自 SQL 的世界。</p><p id="cbd0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了比较，我们先来看看<code class="fe lu lv lw lx b">GROUP BY</code>在 SQL 中是如何工作的。我们将使用几个部门的手术数据集，其中包含手术时间的信息:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/a9205c5402100aaaf93c8b98a495f994.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/format:webp/1*MwNrUzDDmMdNatjSyDEnZg.png"/></div></figure><p id="6cb3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要获得 SQL 中过程的平均长度:</p><pre class="kj kk kl km gt ma lx mb mc aw md bi"><span id="b757" class="me mf it lx b gy mg mh l mi mj">SELECT department, procedure_name, COUNT(*) AS count, AVG(procedure_minutes) AS length <br/>FROM cases<br/>GROUP BY procedure_name<br/>ORDER BY department</span></pre><p id="a9a1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">ORDER BY</code> <em class="ly">部门</em>允许我们对属于同一个部门的程序进行分组。</p><p id="893d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/94694973cba2b80bc54f6bdfd6a33306.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*kboWLPtLi_1tFQ2idYx6vA.png"/></div></figure><p id="ff17" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这几乎相当于熊猫使用<code class="fe lu lv lw lx b">groupby</code>:</p><pre class="kj kk kl km gt ma lx mb mc aw md bi"><span id="0368" class="me mf it lx b gy mg mh l mi mj">gp = cases.groupby(['department','procedure_name']).mean()<br/>gp</span></pre><p id="d22f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/3898f9ff6bde63bee6368c7d76350fb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*_1RM_URo_qfE0e4zYdoKQA.png"/></div></figure><p id="5c7c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如您所见，我们遗漏了<em class="ly">计数</em>列。通过直接调用<code class="fe lu lv lw lx b">mean</code>函数，我们不能插入多个聚合函数。让我们通过使用<code class="fe lu lv lw lx b">agg</code> <em class="ly"> </em>函数<em class="ly"> </em>来解决这个问题:</p><pre class="kj kk kl km gt ma lx mb mc aw md bi"><span id="0d0d" class="me mf it lx b gy mg mh l mi mj">gp = cases.groupby(['department','procedure_name']).agg(['mean', 'count'])<br/>gp</span></pre><p id="de9d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/c5b8dd21c2f4a0e68b1bdecf8e26948d.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*-yH2PA0JvtEhQE459JFm9A.png"/></div></figure><p id="580f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">太好了，现在这个看起来更熟悉了。注意<em class="ly">程序 _ 会议记录</em>标题与<em class="ly">部门</em>和<em class="ly">程序 _ 名称</em>标题不对齐。这就是我们开始看到 SQL 表和 pandas 数据帧之间差异的地方。</p><p id="972a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在 SQL 中，从查询派生的每个新表都由列组成。熊猫里有<em class="ly">索引</em>和<em class="ly">栏目。索引</em>类似于 SQL 的<em class="ly">主键</em>列，它唯一地标识表中的每一行。然而，熊猫数据帧可以有多个索引。在这种情况下，<em class="ly">部门</em>和<em class="ly">程序名</em>都是<em class="ly">索引</em>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/b7d3d83315b19851281de5b22ed9f76b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/format:webp/1*I7j2QWWQU6Z49mydHOAGJg.png"/></div></figure><p id="adaa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要使用索引找到一行，我们只需使用<code class="fe lu lv lw lx b">.loc</code> <em class="ly"> </em>方法一个接一个地传递索引:</p><pre class="kj kk kl km gt ma lx mb mc aw md bi"><span id="d012" class="me mf it lx b gy mg mh l mi mj">gp.loc[`Cardiology’,‘Pericardiocentesis’]</span></pre><p id="a6d3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/9018ab463df3ee1f4dbe34def56cb3ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:702/format:webp/1*drMbDDqfZZ6AteQIaflH5g.png"/></div></figure><p id="b2ac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在 SQL 中，使用<code class="fe lu lv lw lx b">AS</code>语句重命名<em class="ly">‘过程名称’，</em><em class="ly">‘计数’</em>和<em class="ly">‘过程长度</em>’列非常简单。因为 pandas 有<em class="ly">索引</em>和<em class="ly">列</em>，重命名它们有点棘手。要重命名<em class="ly">索引</em>:</p><pre class="kj kk kl km gt ma lx mb mc aw md bi"><span id="b666" class="me mf it lx b gy mg mh l mi mj">gp.index.rename(['Department','Procedure'],inplace=True)<br/>gp</span></pre><p id="eeeb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/511e3de58af833606e032bd1307aea4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:890/format:webp/1*jt0pOTry0Qrt04QNH7akBQ.png"/></div></figure><p id="e32e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于这些列有多个级别，重命名它们需要更多的努力:</p><pre class="kj kk kl km gt ma lx mb mc aw md bi"><span id="4cb9" class="me mf it lx b gy mg mh l mi mj">gp.columns.set_levels(['Length'],level=0,inplace=True)<br/>gp.columns.set_levels(['Count','Mean'],level=1,inplace=True)<br/>gp</span></pre><p id="d580" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/aa872408321d19e58d522e255b24fa2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:818/format:webp/1*BAMQRWuaI3FKv6SBF2w_Ow.png"/></div></figure><p id="6eb5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">尽管与 SQL 相比，命名列很复杂，但是 pandas 有很多优点。在这篇文章中探索一切可能太长了，但是这里有一个简单的。请注意，<em class="ly">甲状腺切除术</em>既可以是<em class="ly">耳鼻喉科</em>也可以是<em class="ly">普通外科</em>手术。为了获得两个部门的<em class="ly">甲状腺切除术</em>的平均值:</p><pre class="kj kk kl km gt ma lx mb mc aw md bi"><span id="4aa3" class="me mf it lx b gy mg mh l mi mj">gp.xs('Thyroidectomy', level=1)</span></pre><p id="9ca5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/de888456592d74100c493e0fc3b0fd82.png" data-original-src="https://miro.medium.com/v2/resize:fit:490/format:webp/1*9bGV9FL0GOZ83w7k510vkA.png"/></div></figure><p id="046d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，如果您仍然喜欢类似于好的 ol' SQL 的表，只需传入<em class="ly"> reset_index </em>:</p><pre class="kj kk kl km gt ma lx mb mc aw md bi"><span id="b4df" class="me mf it lx b gy mg mh l mi mj">gp.reset_index(inplace=True)<br/>gp</span></pre><p id="4d1a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/a0c1ae6cbb831b1bab5e6027148908c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:830/format:webp/1*KR3jtSxE_VbBNjD7xmSboQ.png"/></div></figure><p id="df09" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这就对了，熊猫分组方法入门。希望有所帮助！</p></div></div>    
</body>
</html>