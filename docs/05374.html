<html>
<head>
<title>Regular Expressions (RegEx): Plainly Explained with Cheat Sheet to Appreciate Them</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">正则表达式(RegEx):用备忘单清楚地解释它们</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/regular-expressions-regex-dont-fear-them-it-is-simpler-than-you-think-3a4d6de77058?source=collection_archive---------29-----------------------#2020-05-06">https://towardsdatascience.com/regular-expressions-regex-dont-fear-them-it-is-simpler-than-you-think-3a4d6de77058?source=collection_archive---------29-----------------------#2020-05-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/0598df7d79fc348c91f494826492215c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JU8ILuNQ-lMI7tVU-Fqf3g.png"/></div></div></figure><p id="8ede" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正则表达式(或<strong class="kd iu"> regex </strong>)是用来表示<strong class="kd iu">字符串模式</strong>的工具。它们用于检测、检查、修改和操作字符串。基本上，如果你想在一个文本中找到所有的专有名词，你可以使用正则表达式。我们知道名称只包含字母，并且以大写字母开头。Regex允许我们<strong class="kd iu">将自然的人类短语转录成计算机表示</strong>。他们精通Python或Java，甚至Excel，对于工程师、营销人员或其他人来说非常有用。</p><p id="ac45" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是正则表达式，<strong class="kd iu">乍一看，毫无魅力</strong>。一个人可以害怕他们，但是错误地害怕他们。除了少数例外，它们在所有平台上都以相同的方式使用。因此，我将展示使用Python了解regex的要点。</p><p id="7271" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我为你准备了一张<a class="ae kz" href="https://github.com/AxelThevenot/RegularExpressionPython/raw/master/RegEx%20Cheatsheet.pdf" rel="noopener ugc nofollow" target="_blank"> <em class="la">小抄，你可以下载</em> </a>来总结这篇文章中会看到的内容。</p><figure class="lc ld le lf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lb"><img src="../Images/99dde864645054871a9f243309d2a5dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-OjBnO8awwU60WijFJsSvA.png"/></div></div></figure><h1 id="bd52" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">准备一个Python脚本，自己进行可视化测试</h1><h2 id="be55" class="me lh it bd li mf mg dn lm mh mi dp lq km mj mk lu kq ml mm ly ku mn mo mc mp bi translated">(非强制性)</h2><p id="ea65" class="pw-post-body-paragraph kb kc it kd b ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku mu kw kx ky im bi translated">为了让这篇文章尽可能的有用和互动，我很快为你创建了一个小的python脚本。你将能够用清晰的视觉实时地<strong class="kd iu">自己</strong>测试任何你想要的东西。</p><p id="3487" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你没有python或者只是想看帖子那么<a class="ae kz" href="#16a7" rel="noopener ugc nofollow"> <strong class="kd iu">你可以去下一节</strong> </a>没有任何问题。本帖<strong class="kd iu">中的图片展示了结果</strong>。</p><figure class="lc ld le lf gt ju"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="ec21" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，您将要做的所有测试都将位于一个您将命名为<code class="fe mx my mz na b">file.json</code>的<strong class="kd iu"> JSON文件</strong>中。你可以把你的正则表达式写在引号内<code class="fe mx my mz na b">"Regular expressions" :</code>之后。注意，在JSON格式中，<code class="fe mx my mz na b">\</code>是一个叫做<strong class="kd iu">转义符</strong>的特殊字符。所以你必须写一个双反斜杠<code class="fe mx my mz na b">\\</code>。</p><figure class="lc ld le lf gt ju"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="4531" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">动态结果将自动在控制台中<strong class="kd iu">显示。因此，为了格式化我的文本，我创建了一个<code class="fe mx my mz na b">class SGR</code>，代表“选择图形再现”。你可以在这里找到更多关于<a class="ae kz" href="https://en.wikipedia.org/wiki/ANSI_escape_code#SGR_parameters" rel="noopener ugc nofollow" target="_blank">如何格式化你的文本的信息。</a></strong></p><p id="09d0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后一段代码用于<strong class="kd iu">提取并在控制台</strong>中显示从测试句子的正则表达式中编译的数据。这允许你有你在上面看到的渲染。有必要了解什么是regex才能更好的理解这个脚本。我对代码做了注释，所以你可以在读完这篇文章后再来看。</p><figure class="lc ld le lf gt ju"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h1 id="16a7" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">让我们从基础开始</h1><p id="800d" class="pw-post-body-paragraph kb kc it kd b ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku mu kw kx ky im bi translated">假设我们正在寻找所有的<strong class="kd iu">字母</strong> "e <em class="la"> " </em>。那么关联的正则表达式就是简单的<code class="fe mx my mz na b">e</code>。如果我们寻找所有出现的字符串“el”，那么相关的正则表达式就是<code class="fe mx my mz na b">el</code>。注意，正则表达式是区分大小写的。换句话说，<code class="fe mx my mz na b">e</code>不同于<code class="fe mx my mz na b">E</code>。</p><figure class="lc ld le lf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nb"><img src="../Images/678edc4cbfb87d1bca7c22d3360ffc72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*StC7vnKzWA9nESr20YQfXg.png"/></div></div></figure><p id="69bf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你同时使用了我上面的脚本或其他工具来测试，我邀请你尽可能多地自己尝试这个概念，例如，正则表达式<code class="fe mx my mz na b">hello</code>或正则表达式<code class="fe mx my mz na b">Welcome</code>。只有<code class="fe mx my mz na b">Welcome</code>正则表达式会给出结果，因为它区分大小写。</p><h1 id="ff07" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">范围</h1><p id="510f" class="pw-post-body-paragraph kb kc it kd b ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku mu kw kx ky im bi translated">到目前为止，<strong class="kd iu">没什么复杂的</strong>，我们甚至可以不用正则表达式。正是从这一点开始，正则表达式引起了他们所有的兴趣。让我们想象一下，我们想要捕捉文本中所有的<strong class="kd iu">元音</strong>。我们不能编写regex <code class="fe mx my mz na b">aeiouAEIOU</code>(记住它是区分大小写的)来完成这个任务。所以我们不得不引入<strong class="kd iu">区间</strong>的概念。音程写在<strong class="kd iu">方括号内[…] </strong>。为了匹配所有的元音，我们需要正则表达式<code class="fe mx my mz na b">[aeiouAEIOU]</code>。如果我们必须对它进行人工解读，我们会说我们在寻找所有的字符“a”或“e”或“I”或“O”或“U”。</p><figure class="lc ld le lf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nc"><img src="../Images/df7a3d59e8049fa9ac320b14c0b3c8ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FCXiDvTS2forpoAGTyGc3Q.png"/></div></div></figure><p id="df12" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们希望<strong class="kd iu">所有大写字母</strong>(大写)<strong class="kd iu">从“D”到“W”</strong>，我们将使用正则表达式<code class="fe mx my mz na b">[D-W]</code>。</p><figure class="lc ld le lf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nd"><img src="../Images/bc4f86f8f53de5dede11301ea991d7c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ILIEQU9CZuVCDIqVIF9Tzw.png"/></div></div></figure><p id="0594" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了熟悉这个区间(或范围)的概念，你可以使用<a class="ae kz" href="https://github.com/AxelThevenot/RegularExpressionPython/raw/master/RegEx%20Cheatsheet.pdf" rel="noopener ugc nofollow" target="_blank"> <em class="la">附带的备忘单</em> </a>中的区间<strong class="kd iu">尝试</strong>出新的正则表达式。</p><h1 id="8529" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">字符类别</h1><p id="5241" class="pw-post-body-paragraph kb kc it kd b ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku mu kw kx ky im bi translated">要用大写和小写说出字母表中的每个字母，必须写<code class="fe mx my mz na b">[a-zA-Z]</code>。我承认付出了很多努力，但收效甚微。这就是为什么有不同的<strong class="kd iu">类</strong>可用于构建正则表达式:</p><ul class=""><li id="d38b" class="ne nf it kd b ke kf ki kj km ng kq nh ku ni ky nj nk nl nm bi translated">为了替换<code class="fe mx my mz na b">[a-zA-Z]</code>，(所有的字母)我们有<code class="fe mx my mz na b">\w</code>，这相当于说我们想要<strong class="kd iu">的任何单词字符</strong>。</li><li id="2753" class="ne nf it kd b ke nn ki no km np kq nq ku nr ky nj nk nl nm bi translated">对于任何数字字符，我们有T2类。</li><li id="4be8" class="ne nf it kd b ke nn ki no km np kq nq ku nr ky nj nk nl nm bi translated"><code class="fe mx my mz na b">\s</code>相当于一个<strong class="kd iu">空格字符。</strong></li><li id="9c47" class="ne nf it kd b ke nn ki no km np kq nq ku nr ky nj nk nl nm bi translated"><strong class="kd iu">换行</strong>由<code class="fe mx my mz na b">\n.</code>给出</li><li id="fb62" class="ne nf it kd b ke nn ki no km np kq nq ku nr ky nj nk nl nm bi translated">而<code class="fe mx my mz na b">.</code>意味着我们希望<strong class="kd iu">占位符中的任意字符</strong>(除了换行符<code class="fe mx my mz na b">\n</code>)。</li></ul><p id="8627" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，如果我们想找到所有由空格包围的<strong class="kd iu">双字单词，我们有正则表达式<code class="fe mx my mz na b">\s\w\w\s</code>。</strong></p><figure class="lc ld le lf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lb"><img src="../Images/f11320c887e89a225fd1389ce25a071c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2N-RnmenoiKZDakEqg43ZA.png"/></div></div></figure><p id="640c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意每个类都有它的<strong class="kd iu">否定</strong>。否定是用<strong class="kd iu">大写</strong>格式写的。也就是说，如果我们想要除了字母以外的所有东西，我们就必须写<code class="fe mx my mz na b">\W </code>(注意<code class="fe mx my mz na b">\W</code>也表示没有数字)。如果我们想捕捉除了数字以外的所有东西，我们可以使用<code class="fe mx my mz na b">\D</code>类。同样适用于<code class="fe mx my mz na b">\S</code>。</p><p id="7dcb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了捕捉<strong class="kd iu">三次任何不是单词或数字</strong>字符的东西，我们可以选择<code class="fe mx my mz na b">...\W</code>。</p><figure class="lc ld le lf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nc"><img src="../Images/13da7d1820cc35fe88b5bd5a9bd86f6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_xn2wSV7D8GIHT1aWQe0JA.png"/></div></div></figure><h1 id="0c2b" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated"><strong class="ak">量词</strong></h1><p id="064e" class="pw-post-body-paragraph kb kc it kd b ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku mu kw kx ky im bi translated">在前面的例子中，我们使用regex <code class="fe mx my mz na b">...\W</code>来获取不以字母结尾的4个字符的字符串。假设我们想要同样的东西，但是有8个字符。我们可以写<code class="fe mx my mz na b">.......\W</code>,但是很明显你看到了其中的问题。最好的方法是<strong class="kd iu">能够选择我们想要的重复次数</strong>。这正是量词的作用。</p><p id="0782" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">给定在<strong class="kd iu">括号{…} </strong>之间，量词<strong class="kd iu">应用于其后的字符</strong>。因此，为了让<strong class="kd iu">每个空格后跟4个字的字符</strong>，我们可以使用<code class="fe mx my mz na b">\s\w{4}</code>。</p><figure class="lc ld le lf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ns"><img src="../Images/87da4650379b2d0e0d885f9d1ef5ad17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ydK_B9cYRng-DJAJTJFd7A.png"/></div></div></figure><p id="5af8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你也可以更进一步，选择<strong class="kd iu">最小或最大重复次数</strong>，或者询问重复间隔。对于两个到七个字母之间的单词，我们有正则表达式<code class="fe mx my mz na b">\w{2,7}</code>。</p><p id="f631" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">还有其他的量词:</p><ul class=""><li id="fff3" class="ne nf it kd b ke kf ki kj km ng kq nh ku ni ky nj nk nl nm bi translated"><code class="fe mx my mz na b">+</code>允许我们指定1个或多个<strong class="kd iu">等同于<code class="fe mx my mz na b">{1,}</code>。</strong></li><li id="6476" class="ne nf it kd b ke nn ki no km np kq nq ku nr ky nj nk nl nm bi translated"><code class="fe mx my mz na b">*</code>可以表示0或更多的<strong class="kd iu"/>，相当于<code class="fe mx my mz na b">{0,}</code>。</li><li id="7498" class="ne nf it kd b ke nn ki no km np kq nq ku nr ky nj nk nl nm bi translated">最后，<code class="fe mx my mz na b">?</code>表示<strong class="kd iu"> 0或1乘以</strong>，与<code class="fe mx my mz na b">{0,1}</code>相同。</li></ul><p id="0feb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了演示它，让我们想象一下，由于某种原因，我们需要捕捉<strong class="kd iu">每个空格，后跟最多2个任意字符，后跟另一个空格，然后是一个单词</strong>。一个词当然包含至少一个字符(<code class="fe mx my mz na b">+</code>量词)，所以我们必须检查所有对应于<code class="fe mx my mz na b">\s.{,2}\s\w+</code>的模式。(<strong class="kd iu">直写</strong>但不一定要读)</p><figure class="lc ld le lf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nt"><img src="../Images/7a56f0c0f6ee991d1ae396fae3cd5ca9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1qmWIRb9Oi-xIEnXVrA8PQ.png"/></div></div></figure></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><p id="f187" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">大量信息堆积起来。熟能生巧，所以你需要一开始就把小抄带在身边。在进入下一部分之前，让我们稍微休息一下，看看这只猫。我保证这一跳看起来很难，但其实并不难。</p><figure class="lc ld le lf gt ju"><div class="bz fp l di"><div class="ob mw l"/></div><p class="oc od gj gh gi oe of bd b be z dk translated"><a class="ae kz" href="https://giphy.com/gifs/thumbnail-Jd5YlXOVTcQtW" rel="noopener ugc nofollow" target="_blank">资料来源:GIPHY </a></p></figure><h1 id="6101" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">组</h1><p id="1209" class="pw-post-body-paragraph kb kc it kd b ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku mu kw kx ky im bi translated">接下来的部分将详细介绍python能做些什么。如果你看了我提供的代码，你会注意到有一个<strong class="kd iu">组</strong>的概念。为了简单起见，让我们假设我们想要提取问候“Hello”、“Welcome”和“Hey”。我们可以一个接一个地做3个正则表达式<code class="fe mx my mz na b">[Hh]ello</code>、<code class="fe mx my mz na b">[Ww]elcome</code>和<code class="fe mx my mz na b">[Hh]ey</code>、T23。(注意，在这些正则表达式中，我们考虑到a可以以大写字母开头)。<br/>但是我们可以<strong class="kd iu">通过在<strong class="kd iu">括号(…) </strong>之间建立一个所谓的组，并用一个<strong class="kd iu">竖线| </strong>分隔，将这三个正则表达式<strong class="kd iu">聚集成一个</strong>。我们得到正则表达式<code class="fe mx my mz na b">([Hh]ello|[Ww]elcome|[Hh]ey)</code>。</strong></p><figure class="lc ld le lf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi og"><img src="../Images/0c0642869c4e4c9028544f44eb395ec6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tZybW1GY-IXRzWQNCIyPWQ.png"/></div></div></figure><p id="909f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你可以在上面的图片上看到<strong class="kd iu">组可以被python检测到</strong>并返回。所以最大的好处就是<strong class="kd iu">组可以作为变量返回</strong>。你也可以使用<strong class="kd iu">字典组</strong>。也就是说，在python字典中返回给我们的组。只需更改组的开头，如斜体所示<code class="fe mx my mz na b">(<em class="la">?P&lt;greetings&gt;</em>[Hh]ello|[Ww]elcome|[Hh]ey)</code>。<br/>所以你最终得到一个带有<strong class="kd iu">键<em class="la">问候语</em> </strong>的字典，从你的脚本中访问这场比赛，如下图所示。注意所有的<strong class="kd iu">字典组都包含在组</strong>中。</p><figure class="lc ld le lf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi og"><img src="../Images/63f44c330079b4dd44fb482422735961.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*20GleDgJ-swq3z-o25juBA.png"/></div></div></figure><p id="b64f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您也可以决定不使用<code class="fe mx my mz na b">(<em class="la">?:</em>[Hh]ello|[Ww]elcome|[Hh]ey)</code>格式返回组。但我再次邀请你<strong class="kd iu">用这张纸自己试一下</strong>。</p><h1 id="e998" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated"><strong class="ak">断言</strong></h1><p id="21c8" class="pw-post-body-paragraph kb kc it kd b ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku mu kw kx ky im bi translated">您还可以使用许多可能的断言，包括:</p><ul class=""><li id="4a30" class="ne nf it kd b ke kf ki kj km ng kq nh ku ni ky nj nk nl nm bi translated"><code class="fe mx my mz na b">^</code>表示一个字符串的开始</li><li id="7a80" class="ne nf it kd b ke nn ki no km np kq nq ku nr ky nj nk nl nm bi translated"><code class="fe mx my mz na b">$</code>为结尾或一串</li><li id="9146" class="ne nf it kd b ke nn ki no km np kq nq ku nr ky nj nk nl nm bi translated"><code class="fe mx my mz na b">\b</code>象征一个字的边界</li></ul><p id="b549" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你现在想抓住所有以感叹号结尾的句子。然后就和要求一句话<strong class="kd iu">从头到尾结尾带感叹号且不管中间是什么一样。</strong>此处节录<strong class="kd iu"> </strong> <code class="fe mx my mz na b"><strong class="kd iu">^.*!$</strong></code></p><figure class="lc ld le lf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oh"><img src="../Images/793e1b66a4cd7e1da0dc62a5dde9fbf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3bJODB2z7tuLMjQN_8c4Wg.png"/></div></div><p class="oc od gj gh gi oe of bd b be z dk translated">我刚发现做这个截图很有趣:)</p></figure><p id="eda9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">还有其他一些需要更多关注的断言</p><p id="5c51" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了总结正则表达式可以做的事情，我想通过一个例子来介绍其中的一个。这一部分的目的是复制下面的正则表达式。<strong class="kd iu">不要慌</strong>，它又长又丑。但是我敢打赌，我可以告诉你，一个正则表达式，从一部分来看，实际上并没有那么复杂。</p><figure class="lc ld le lf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oi"><img src="../Images/674edd34fc52cfabaa8868929f77a659.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i313ld_rMjYVbLzBAvjjSQ.png"/></div></div></figure><p id="5e05" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">本部分的目的是回答以下问题:“<strong class="kd iu">您与谁会面</strong>”？<br/>所以要回答这个问题，我们需要提取出<strong class="kd iu">直接放在</strong>前面的名字“with”。<strong class="kd iu">这是一个断言</strong>。从字面上来看，它是一个<strong class="kd iu">正向后视</strong>标记为<strong class="kd iu">(?&lt; =…) </strong>。积极是因为“是”而不是“不是”，回顾是因为“在前”而不是“在后”。</p><p id="61aa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了提取单词“with”(和一个空格字符)前面的内容，我们以regex <code class="fe mx my mz na b">(?&lt;=with\s).*</code>结束。</p><figure class="lc ld le lf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nd"><img src="../Images/bb024cca3773703f8b4378e904032df7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U8G6xYRHfehEzJOxGJhPMw.png"/></div></div></figure><p id="7e1a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，我们摘录了直接跟在“with”后面的内容。但是我们想知道这个人的名字。</p><p id="80fb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那么让我们想象一个困难的情况，其中有一个“迈克尔-菲利普·约翰逊”。他的名字也可以写成:“M.-P”。或者“MP”或者“M”或者“M-P”。为了让<strong class="kd iu">只有</strong> <strong class="kd iu">个大写字母或一个点或连字符，后面可能跟着小写字母</strong><strong class="kd iu"/>，我们使用了正则表达式<code class="fe mx my mz na b">[A-Z\.\-]+[a-z]*</code>。(注意<code class="fe mx my mz na b">.</code>是留给“任意字符”的。如果你真的想要一个点，你必须在前面加上转义字符<code class="fe mx my mz na b">\</code>。对于<code class="fe mx my mz na b">-</code>来说也是同样的想法。)</p><p id="d53a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后在dictionary中将这个组作为<strong class="kd iu">返回，这个步骤很简单，我们可以在末尾添加一个<code class="fe mx my mz na b">?</code>，因为名字也可以不写。并且加一个<code class="fe mx my mz na b">\s</code>保证字尾。</strong></p><p id="3576" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们得到<code class="fe mx my mz na b">(?P&lt;firstname&gt;[A-Z\.\-]+[a-z]*)?\s</code>。<strong class="kd iu">将</strong>与我们已经拥有的东西串联起来:<br/>我们得到<code class="fe mx my mz na b">(?&lt;=with\s)(?P&lt;firstname&gt;[A-Z\.\-]+[a-z]*)?\s</code>。</p><figure class="lc ld le lf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oj"><img src="../Images/b87adafe43dd804d8ce5d25fc3bfd7df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FLkFfPFRbIMJccwXkWZONw.png"/></div></div></figure><p id="5360" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那么很容易！姓氏由一个大写字母和几个小写字母定义，因此我们可以编写<code class="fe mx my mz na b">[A-Z][a-z]+</code>正则表达式。通过在python字典中添加return，它变成了<code class="fe mx my mz na b">(?P&lt;lastname&gt;[A-Z][a-z]+)</code>。<br/>如果姓氏和“with”之间没有名字，则没有额外的空格。我们加一个<code class="fe mx my mz na b">?</code>来保证这种情况。串联一切和<strong class="kd iu"> Tadam！<br/> </strong> <code class="fe mx my mz na b">(?&lt;=with\s)(?P&lt;firstname&gt;[A-Z\.\-]+[a-z]*)?\s?(?P&lt;lastname&gt;[A-Z][a-z]+)</code></p><figure class="lc ld le lf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ok"><img src="../Images/ce596ccf5f1b9f10f5e99b16ccd9ef1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eRbRxgb3hcXLNBLbfZupUA.png"/></div></div></figure><h1 id="f562" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">旗帜</h1><p id="bae4" class="pw-post-body-paragraph kb kc it kd b ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku mu kw kx ky im bi translated">最后还有<strong class="kd iu">多面旗</strong>。我不会解释如何使用它们，因为它们在不同的编程语言中有不同的用法。它们当然会出现在备忘单中。例如，如果您想要:</p><ul class=""><li id="8639" class="ne nf it kd b ke kf ki kj km ng kq nh ku ni ky nj nk nl nm bi translated"><strong class="kd iu">忽略区分大小写</strong>你可以使用<strong class="kd iu"> I </strong>标志</li><li id="28e8" class="ne nf it kd b ke nn ki no km np kq nq ku nr ky nj nk nl nm bi translated"><strong class="kd iu">允许注释</strong>和空格在正则表达式中你可以使用<strong class="kd iu"> X </strong>标志</li><li id="bf2e" class="ne nf it kd b ke nn ki no km np kq nq ku nr ky nj nk nl nm bi translated"><strong class="kd iu">允许多线</strong>带<strong class="kd iu"> M </strong>。</li></ul><p id="ba78" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">(python re包中的例子)。</p><figure class="lc ld le lf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ol"><img src="../Images/a41213d2ce618721d92c099fba464fc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eGtKKRvZfNm6mIdQlVXisA.png"/></div></div></figure><blockquote class="om on oo"><p id="cd08" class="kb kc la kd b ke kf kg kh ki kj kk kl op kn ko kp oq kr ks kt or kv kw kx ky im bi translated">知识就是分享。 <br/> <strong class="kd iu">支持</strong>我，一键获得<strong class="kd iu">访问<a class="ae kz" href="https://axel-thevenot.medium.com/membership" rel="noopener"> <strong class="kd iu">中我所有文章的</strong>。</a></strong></p></blockquote><figure class="lc ld le lf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ol"><img src="../Images/94e903d7d66ff043ca9645dbc42c33bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y7Q5U2MjIji7pvt6DRzq3A.png"/></div></div></figure><h1 id="cde7" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated"><strong class="ak">来源</strong></h1><p id="61e0" class="pw-post-body-paragraph kb kc it kd b ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku mu kw kx ky im bi translated"><a class="ae kz" href="https://docs.python.org/3/library/re.html" rel="noopener ugc nofollow" target="_blank">正则表达式操作</a>，Python文档</p><p id="8293" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所有的图片和脚本都是自制的，可以免费使用。</p><p id="500a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里是<a class="ae kz" href="https://github.com/AxelThevenot/RegularExpressionPython/blob/master/README.md" rel="noopener ugc nofollow" target="_blank"> github库</a>你可以在那里找到脚本</p><p id="0883" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae kz" href="https://github.com/AxelThevenot/RegularExpressionPython/raw/master/RegEx%20Cheatsheet.pdf" rel="noopener ugc nofollow" target="_blank">我的小抄又来了</a>，免费的时候总是更好！🆓 🆓 🆓</p></div></div>    
</body>
</html>