# Python 中的时间序列处理

> 原文：<https://towardsdatascience.com/time-series-processing-in-python-32a8d085e6e5?source=collection_archive---------42----------------------->

## 第一部分:使用熊猫的基本分析

![](img/948d47b4243cc7986568ee14d74ec8fd.png)

[Ales Krivec](https://unsplash.com/@aleskrivec?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 在 [Unsplash](https://unsplash.com/s/photos/time-series?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄的照片

时间序列是一段时间内的一系列值。旧金山过去 30 天的日平均气温就是一个例子。

时间序列出现在各行各业，从天气到经济到产品销售到健康指标。

为什么要分析时间序列？因为这可以揭示趋势和其他模式。从中可以预测未来的价值。

这篇文章通过一个简单的运行和发展的例子，介绍了 Python 中 Pandas 库中处理时间序列的各种特性。

熊猫时间序列特征可以分为两类:时间序列中的值的特征和这些值后面的时间指数的特征。本帖涵盖前者。后者本身就是一个完整的主题，将在后续的帖子中讨论。

**示例设置:温度**

要开始使用熊猫，只需

```
import pandas as pd
```

接下来，让我们创建我们的第一个时间序列。

```
temps = pd.Series([70,75,65,70,75,70,30, 100, 80,72,76,79,85,76,81,69, 78])
```

把`temps`想象成存储旧金山连续几天的日平均温度。日期隐含在索引中 *t* = 0，1，2，…

Pandas 支持更精细的时间指数。例如，我们可以存储 temps 封面的实际日期。我们不会在这里讨论这些。因此，我们可以将重点放在值的操作上，这些值有很大的变化。

**温度最小值、最大值、平均值、可变性**

`temps`的平均(或最低或最高)温度是多少？简单:只需做`temps.mean()`、`temps.min()`或`temps.max()`。气温波动有多大？Do: `temps.std()`获得数量感。它会给出标准差。

让我们从数据中感受一下。`temps.mean()`返回约 73.58。这接近于人们仅仅通过观察数据所猜测的。`temps.min()`和`temps.max()`分别是 30 和 100。范围很广。

`temps.std()`返回约 13.74。因此，大多数温度徘徊在平均值的 13 度以内——正负。我们一眼就能看出这一点。

另一种方法是通过计算第 5 和第 95 个百分点，这可以被认为是 min 和 max 的软化。`temps.quantile(0.05)`为 58.0，`temps.quantile(0.95)`约为 88。所以这也给了我们一个相似的范围。

接下来，让我们给`temps`添加一个异常值，看看它如何影响我们的分析。这种异常值可能是由数据输入错误引起的。

```
temps_with_outlier = pd.Series([70,75,65,70,75,70,30, 100, 80,72,76,79,**10000**,85,76,81,69, 78])
```

我们看到`temps_with_outlier.mean()`是一个巨大的 625.055！而`temps_with_outlier.std()`安，更是高达 2339.715！由此得出的教训是，无论是均值还是标准差，对异常值都不稳健。

统计学家建议，在这种情况下，我们应该使用中位数和平均绝对偏差(mad)来代替。它们是对异常值稳健的均值和标准差版本。`temps_with_outlier.**median**()`是 75.5。哇！`temps_with_outlier.**mad**()`是 1041.66。有点帮助。不够。经验教训:一定要用中位数。

**从华氏温度转换到摄氏温度**

你可能已经猜到我们的温度目前是华氏温度。怎样才能让这些进入摄氏温度？不多。

```
temps_celcius = (temps-32)*5/9
```

相当多的事情发生在幕后。首先，从`temps`中的每个值中减去 32，得到一个新的时间序列。接下来，结果时间序列中的每个值都乘以 5/9。

**关联邻近城市的温度**

接下来，让我们根据旧金山的估计温度虚构一个圣何塞的估计温度时间序列(尽管是真实的)。

```
temps_sj = temps + 10
```

这里的想法是，圣何塞往往比旧金山暖和几度，因为它远离海洋，在一个避风的山谷里。

我们注意到`temps`和`temps_sj`是相关的，即它们一起移动。在任何一天，`temps_sj`中的值总是比 temps 中的值高 10 度。

这让我们不禁要问:如何度量同一时间点上的两个时间序列是相关的？在探讨这个之前，我们先设置一个“控制”。这将与温度无关。所以我们可以衡量我们的措施有多有效。通过比较`temps`和`temps_sj`相对于`temps`和控制的公式相关性。

```
import random
temps_random = pd.Series(random.sample(range(58,88),len(temps)))
```

这里发生了很多事。我们来解释一下。

`random.sample(range(58,88),len(temps))`从 58 到 88 的范围内独立均匀地采样`len(temps)`值。我们试图近似我们在`temps`中看到的数值范围，同时平均分配这些数值。这就是为什么`temps`和`temps_random`有相似的值，只是它们不相关。

提出相关性度量的第一个合理尝试是将这两个时间序列的各个部分相乘，以产生一个新的时间序列。然后对这个时间序列中的所有值求和。让我们来看看实际情况。先应用到`temps`和`temps_sj`上吧。

```
m = temps*temps_sj
m.sum()
```

`m`中的前两个值是 5600 和 6375。5600 等于`temps[0]*temps_sj[0]`，6375 等于`temps[1]*temps_sj[1]`。

`*`操作也称为点积。

`m.sum()`等于 107593。价值大。我们不知道这是怎么回事。这就是控制权的来源。如果我们的相关性度量很好，如果我们用`temps_random`代替`temps_sj`，那么`m.sum()`的值应该会低得多。

`(temps*temps_random).sum()`等于 88480。所以确实低了，意料之中！也就是说，它应该更低，对不对？

嗯，让我们试试不同的东西。在进行点积之前，让我们先将`temps`和`temps_random`分别居中。随着代码变得越来越复杂，让我们把它封装成一个函数。

```
def centered_dot_product(time_series_1,time_series_2):
    ts1_centered = time_series_1- time_series_1.mean()
    ts2_centered = time_series_2- time_series_2.mean()
    return (ts1_centered*ts2_centered).sum()
```

`centered_dot_product(temps,temps_sj)`返回 3024.11，而`centered_dot_product(temps,temps_random)`返回-414.58。那好多了。区别更加明显。

为什么前者效果不好？因为在所有的时间序列中，大部分温度都在 58 到 88 度之间。点积发现了这种相似性。先定中心“减去”这种相似性，这样得到的测量结果可以不关注时间序列中的值，而是关注它们如何*共变*。

我们可以在这个指标上进一步改进，但我们不会。我们希望涵盖其他功能。

**发现温度异常值**

考虑一下`temps_with_outlier`。以前我们用它来说明处理异常值的统计数据。在这里，我们研究如何找到离群值。

我们已经将发现异常值封装到一个函数中。它的代码有点复杂。我们建议先读一遍，然后看看我们接下来的解释，如果你还有点不清楚的话，可能还会再读一遍。

```
def outliers(time_series,lowp,highp):
   low = time_series.quantile(lowp)
   high = time_series.quantile(highp)
   in_range = time_series.between(low,high)
   outliers = []
   for t,v in in_range.items():
      if not v:
          outliers.append([t,time_series[t]])
   return outliers
```

在解释幕后发生的事情之前，让我们打个电话给它，看看它会有什么回报。此外，这也给了我们一个解释参数`lowp`和`highp`的机会。

`outliers(temps_with_outlier,0.01,0.99)`返回[[6，30]，[12，10000]]。这表明温度 30 和 10000 被视为异常值，分别出现在时间点 6 和 12。有道理！

我们在决定什么是离群值时有多严格？这是由分位数的下限和上限指定的，我们在此图中选择的值是 0.01 和 0.99。提高下限和降低上限将放宽离群值标准。让我们看看这是如何运作的。

`outliers(temps_with_outlier,0.1,0.9)`返回[[2，65]，[6，30]，[7，100]，[12，10000]]。在我们之前的异常值列表中又增加了两个:65 度和 100 度。新发现的可能被合理地解释为分别是“异常冷”和“异常热”。

不错。

**气温上升了吗？**

考虑`temps`的以下变体:

```
temps = pd.Series([60,65,62,68,65,67,70,67,73,67,75,66,77,69,77,69,79])
```

你看到了什么？气温呈上升趋势。通过适当区分时间序列，可以使这种趋势更加生动。让我们看看这个效果如何。

首先尝试`temps.diff(1)`。这导致了`temps`中一步差的时间序列。即:NaN，temps[1]-temps[0]，temps[2]-temps[1]，…第一个值是 NaN，因为`temps[-1]`未定义。

```
nan 5.0 -3.0 6.0 -3.0 2.0 3.0 -3.0 6.0 -6.0 8.0 -9.0 11.0 -8.0 8.0 -8.0 10.0
```

嗯，还没那么生动。让我们试试`temps.diff(**4**)`。这导致了`temps`中 4 步差的时间序列。结果中的第个条目是`temps[i]-temps[i-4]`。

```
nan nan nan nan 5.0 2.0 8.0 -1.0 8.0 0.0 5.0 -1.0 4.0 2.0 2.0 3.0 2.0
```

好多了！趋势暴露了。

让我们做`temps.diff(4).mean()`，这导致了 3.0。这可以被解释为平均每 4 天气温升高 3 度。

让我们看看通过不同的计算得到了什么:`temps.diff(10).mean()`给出了 7.85。请注意，3.0/4 大致等于 7.85/10。换句话说，两者都表明平均气温每天上升约 0.75 度。不错。

**温度*上升的百分比*是多少？**

假设我们想知道`temps`每天的平均*百分比*增长。熊猫里的`shift`操作员会在这里帮忙。

我们将逐步构建我们的解决方案，因为它有点复杂。让我们从`temps.shift(4)`开始。这产生了一个版本的`temps`，其中时间移动了 4 步。下面是原始版本和转换后的版本

```
**Original**: 60 65 62 68 65 67 70 67 73 67 75 66 77 69 77 69 79
**Shifted**: nan nan nan nan 60.0 65.0 62.0 68.0 65.0 67.0 70.0 67.0 73.0 67.0 75.0 66.0 77.0
```

我们选择移动 4 步，因为这 4 步的差异在之前对相同的数据进行了很好的计算。

另外，注意`temps — temps.shift(4)`相当于`temps.diff(4)`。

我们最后的表达是

```
100.0*(temps-temps.shift(4))/temps.shift(4)
```

将时间序列`temps-temps.shift(4)`除以时间序列`temps.shift(4)`得到分数变化的时间序列。(请注意，这种划分是针对组件的。)乘以 100.0 以百分比表示。

**消除温度波动**

均线是对时间序列的一种重要操作。它产生一个新的时间序列，其值是前一个时间序列中相邻值的平均值。这具有消除瞬时波动的效果。

认为

```
temps = pd.Series([60,65,62,68,65,67,70,67,73,67,75,66,77,69,77,69,79])
temps_smoothed = temps.rolling(2).mean()
```

我们先来看结果，在`temps_smoothed`。

```
nan 62.5 63.5 65.0 66.5 66.0 68.5 68.5 70.0 70.0 71.0 70.5 71.5 73.0 73.0 73.0 74.0
```

哇——这些绝对是平滑的！它们更生动地揭示了上升趋势。

现在让我们来解释一下幕后发生了什么。告诉熊猫建造宽度为 2 的滚动窗户。`mean()`然后计算窗口中的平均值。这个滚动过程产生平滑的时间序列。

默认情况下，窗口在右边，不居中。我们可以通过检查结果来推测这一点。注意`temps_smoothed[1]`是 62.5，是`temps[0]`的平均值，是 60，`temps[1]`是 65。