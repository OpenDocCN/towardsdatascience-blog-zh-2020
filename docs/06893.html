<html>
<head>
<title>Flood Map Animations with Mapbox and Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Mapbox 和 Python 制作洪水地图动画</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/flood-map-animations-with-mapbox-and-python-fb0b5d3109a7?source=collection_archive---------44-----------------------#2020-05-28">https://towardsdatascience.com/flood-map-animations-with-mapbox-and-python-fb0b5d3109a7?source=collection_archive---------44-----------------------#2020-05-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="49ea" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">进来吧，水很好！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f8bd44a56fe49da948eb4b5e4787132b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DD5hbs6AtD2uFHU84ECI0w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">纽约市洪水(凯尔·帕斯托尔)</p></figure><p id="7146" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我以前写的一篇文章中，我们谈到了使用 Mapbox 和 Python 来获得超高分辨率的卫星图像。除了卫星图像之外，我们还能够获得海拔地图，它基本上告诉我们每一个像素的海拔高度，以米为单位。有关更多详细信息，请参见以下内容:</p><div class="lu lv gp gr lw lx"><a rel="noopener follow" target="_blank" href="/creating-high-resolution-satellite-images-with-mapbox-and-python-750b3ac83dd7"><div class="ly ab fo"><div class="lz ab ma cl cj mb"><h2 class="bd iu gy z fp mc fr fs md fu fw is bi translated">用 Mapbox 和 Python 制作高分辨率卫星影像</h2><div class="me l"><h3 class="bd b gy z fp mc fr fs md fu fw dk translated">超高分辨率卫星和高程图像</h3></div><div class="mf l"><p class="bd b dl z fp mc fr fs md fu fw dk translated">towardsdatascience.com</p></div></div><div class="mg l"><div class="mh l mi mj mk mg ml ks lx"/></div></div></a></div><p id="5a13" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这次我想把这些数据应用到一些有趣的事情上。</p><blockquote class="mm mn mo"><p id="6fe2" class="ky kz mp la b lb lc ju ld le lf jx lg mq li lj lk mr lm ln lo ms lq lr ls lt im bi translated">如果海平面上升会发生什么？一座城市被水淹没后会是什么样子？</p></blockquote><p id="4f4c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将假设我们运行了代码来获取之前的影像，所以我们在这里想要做的是编写一个简短的脚本，它将随着时间的推移来制作洪水水位的动画。</p><p id="4b2e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">像往常一样，我们从导入和子目录开始</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="514f" class="my mz it mu b gy na nb l nc nd">import numpy as np<br/>import PIL <strong class="mu iu"># Image manipulation library<br/></strong>mkdir ./depth  <strong class="mu iu"># Just a place to store our animation frames</strong></span></pre><p id="ca4f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，我们将简单地循环我们感兴趣的深度级别。这就是一些艺术性来选择一个很好的水平范围来制作一个流畅有趣的动画。你可能要玩一会儿了！</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="ad8a" class="my mz it mu b gy na nb l nc nd"><strong class="mu iu"># Loop over a range between 0 and 100 in 0.25 increments</strong><br/>for i, level in enumerate(np.arange(0,100,0.25)):<br/>    <br/>    <strong class="mu iu"># First open up the satellite image we want as the background</strong><br/>    im = PIL.Image.open('./composite_images/satellite.png')<br/>        .convert('RGBA')</span><span id="8cbb" class="my mz it mu b gy ne nb l nc nd">   <strong class="mu iu"> # Create a solid image that looks like deep water (dark blue)</strong><br/>    overlay = PIL.Image.new('RGBA', im.size,(4,22,37,255))</span><span id="a943" class="my mz it mu b gy ne nb l nc nd">    <strong class="mu iu"># Convert it into a numpy array</strong><br/>    ni = np.array(overlay)</span><span id="e945" class="my mz it mu b gy ne nb l nc nd">    <strong class="mu iu"># Next we extract the elevation data into a numpy array</strong><br/>    e = np.array([np.array(xi) for xi in elevation_data])</span><span id="9dd8" class="my mz it mu b gy ne nb l nc nd">    <strong class="mu iu"># NB: both ni and e are the same shape so we can operation on<br/>    them with numpy</strong></span><span id="5346" class="my mz it mu b gy ne nb l nc nd">    <strong class="mu iu"># Perform element-wise subtraction with the level</strong><br/>    depth = level - e</span></pre><p id="7a49" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在循环的这一点上，我将快速离开一下。这里我们有一个与原始图像大小相同的数组。它包含每个像素的深度。下一步是决定如何根据深度修改<em class="mp">叠加图像。</em>在这个例子中，我决定根据深度缩放 alpha 通道(透明度)。越深，透明度越低，我们看到的水就越暗。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="5dbb" class="my mz it mu b gy na nb l nc nd">    alpha_mask = np.copy(depth)<br/>    alpha_mask = alpha_mask*255/alpha_mask.max()<br/>    alpha_mask  = np.where(alpha_mask&lt;0, 0, alpha_mask)<br/>    alpha_mask = alpha_mask**.2 <br/>    alpha_mask = alpha_mask*255/alpha_mask.max()</span></pre><p id="e98f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们再一次一行一行地回顾我们刚刚做的事情。</p><p id="db4f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">L1:我们通过<strong class="la iu"> <em class="mp">复制</em> </strong>深度数组做了一个阿尔法遮罩。复制是非常重要的，否则它就是对对象的引用(如果对象改变了，它也会改变)。</p><p id="ad04" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">L2:然后我们缩放蒙版，最深的像素设置为 255(最大不透明度)。这当然重新调整了所有的元素，这正是我们想要的。</p><p id="761e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">L3:任何小于零(水面以上)的东西我们都将设置为完全透明。</p><p id="f2e4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">L4:我遇到的一个问题是水的整体外观没有给人一种视觉上的深度感。它要么看起来完全黑暗，要么非常透明。我决定放大这些点，这样透明度会有一个梯度下降。我使用 x**0.2 作为我的函数，但你可以改变它，以适应什么好看。</p><p id="6f28" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">L5:在我们的功率标度之后，我们做了另一个重新标度。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="511e" class="my mz it mu b gy na nb l nc nd"><strong class="mu iu">    # Set the overlay layer opacity channel to the alpha mask</strong><br/>    ni[...,3] = alpha_mask[...]</span><span id="0250" class="my mz it mu b gy ne nb l nc nd"><strong class="mu iu">    # Convert the numpy array back to an image</strong><br/>    W = PIL.Image.fromarray(ni)</span><span id="4e66" class="my mz it mu b gy ne nb l nc nd">    <strong class="mu iu"># Paste the image and save every depth frame</strong><br/>    im.paste(W , (0,0),W)<br/>    im.save('./depth/'+ str(i).zfill(4) +'.png')</span></pre><p id="c341" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了体验一下单帧图像的效果，下面是多伦多大约 100 米深处的图像。你可以看到缩放使山谷看起来有更深的水。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/3b62a3745145889a66fc4fa7cbb4a4d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OHJB4_lzzjSj-4quCQsOiA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">多伦多被淹至 100 米左右(凯尔·帕斯托尔)</p></figure><p id="1ef3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这看起来很不错，所以现在是时候制作动画了。我们将使用 ffmpeg 把我们的许多帧图像转换成一个. mp4 文件。首先，我们必须安装所需的软件包。注意，我在 Kaggle(在线 python 笔记本)上做了所有这些，它在最后有链接。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="3d04" class="my mz it mu b gy na nb l nc nd"><strong class="mu iu"># Install the package in linux</strong><br/>apt-get update<br/>apt install -y ffmpeg</span><span id="127f" class="my mz it mu b gy ne nb l nc nd"><strong class="mu iu"># Run the command</strong><br/>ffmpeg  -i ./depth/%04d.png -c:v libx264 -c:a aac -ar 44100 -filter "minterpolate='fps=30'" -pix_fmt yuv420p output.mp4</span></pre><p id="4d44" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所用的一组参数大多是为了使 mp4 的最终编码可以在 insta gram(@ datastufplus)上发布。</p><p id="aa78" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们运行这个并做了一些简单的文字叠加(使用 inshot for android)之后，我们得到了最终的动画。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/7040461f5fdb106a8c044ddb93a774a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*O6TdSz7tHTXZQ3i8aV6sNg.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">多伦多洪水(凯尔·帕斯托尔)</p></figure><p id="1eef" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">哇，看起来真酷！</p><p id="8e7f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最棒的是，你可以在任何地方重新运行。整个事情都是自动化的！</p><h1 id="8f9a" class="nh mz it bd ni nj nk nl nm nn no np nq jz nr ka ns kc nt kd nu kf nv kg nw nx bi translated">参考和链接</h1><p id="80f9" class="pw-post-body-paragraph ky kz it la b lb ny ju ld le nz jx lg lh oa lj lk ll ob ln lo lp oc lr ls lt im bi translated">我做了这一切，因此图像是我的！万岁！</p><p id="4345" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">代码链接可在此处找到:</p><div class="lu lv gp gr lw lx"><a href="https://www.kaggle.com/kapastor/flood-map-with-mapbox-and-python" rel="noopener  ugc nofollow" target="_blank"><div class="ly ab fo"><div class="lz ab ma cl cj mb"><h2 class="bd iu gy z fp mc fr fs md fu fw is bi translated">使用 Mapbox 和 Python 制作洪水地图</h2><div class="me l"><h3 class="bd b gy z fp mc fr fs md fu fw dk translated">使用 Kaggle 笔记本探索和运行机器学习代码|使用来自非数据源的数据</h3></div><div class="mf l"><p class="bd b dl z fp mc fr fs md fu fw dk translated">www.kaggle.com</p></div></div><div class="mg l"><div class="od l mi mj mk mg ml ks lx"/></div></div></a></div></div></div>    
</body>
</html>