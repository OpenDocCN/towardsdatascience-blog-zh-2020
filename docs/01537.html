<html>
<head>
<title>Basic Algorithms — Quicksort</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基本算法—快速排序</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/basic-algorithms-quicksort-b549ea9ef27?source=collection_archive---------18-----------------------#2020-02-11">https://towardsdatascience.com/basic-algorithms-quicksort-b549ea9ef27?source=collection_archive---------18-----------------------#2020-02-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c7e9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用随机选择的枢轴对数组排序</h2></div><p id="fcfe" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我在<a class="ae le" rel="noopener" target="_blank" href="/basic-algorithms-finding-the-closest-pair-5fbef41e9d55">的上一篇文章</a>中介绍了一种叫做 Merge-Sort 的排序算法，并在这篇文章中继续讨论另一种排序算法 Quicksort。快速排序的期望代价是<em class="lf">θ(nlgn)</em>，而代价为<em class="lf">θ(n)</em>的最坏情况只会以 2 <em class="lf"> /n 的概率出现！。</em>我将在稍后的性能比较中展示隐藏在<em class="lf">θ</em>符号中的常数在 Quicksort 中更低，因此该算法优于成本相同的 Merge-Sort<em class="lf">θ(nlgn)。</em></p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/cbdc0bab4cdafa24bb02ffa4650c7ec7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SSPktXEI5PNx9gW2"/></div></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">安德鲁·布坎南在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h2 id="4a21" class="lw lx it bd ly lz ma dn mb mc md dp me kr mf mg mh kv mi mj mk kz ml mm mn mo bi translated">插入排序</h2><p id="a983" class="pw-post-body-paragraph ki kj it kk b kl mp ju kn ko mq jx kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">插入排序是一种强力算法，它比较数组中的所有对来排序。这是人们在 porker 或其他纸牌游戏中常用的发牌方式。代价是<em class="lf">θ(n)。</em></p><pre class="lh li lj lk gt mu mv mw mx aw my bi"><span id="180c" class="lw lx it mv b gy mz na l nb nc">def <strong class="mv iu">insertion_sort</strong>(array):<br/>    for j in range(1, len(array)):<br/>        key = array[j]<br/>        i = j - 1<br/>        while i &gt;= 0 and array[i] &gt; key:<br/>            array[i+1] = array[i]<br/>            i -= 1<br/>        array[i+1] = key<br/>    return array</span></pre><h2 id="9794" class="lw lx it bd ly lz ma dn mb mc md dp me kr mf mg mh kv mi mj mk kz ml mm mn mo bi translated">合并排序</h2><p id="32df" class="pw-post-body-paragraph ki kj it kk b kl mp ju kn ko mq jx kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">在<a class="ae le" rel="noopener" target="_blank" href="/basic-algorithms-finding-the-closest-pair-5fbef41e9d55">之前的文章</a>中，我们讨论了作为基本分治算法之一的合并排序算法。这一次，我们将使用一个更简单的版本，因为我们只处理一维数组。</p><pre class="lh li lj lk gt mu mv mw mx aw my bi"><span id="a089" class="lw lx it mv b gy mz na l nb nc">def <strong class="mv iu">merge_sort</strong>(array):<br/>    <br/>    length = len(array)<br/>    <br/>    if length == 1:<br/>        return array<br/>    <br/>    elif length == 2:<br/>        if array[0] &gt; array[1]:<br/>            return np.array([array[1], array[0]])<br/>        else:<br/>            return array<br/>    <br/>    elif length &gt; 2:<br/>        array_l = array[:length//2]<br/>        array_r = array[length//2:]<br/>        array_l_sorted = <strong class="mv iu">merge_sort</strong>(array_l)<br/>        array_r_sorted = <strong class="mv iu">merge_sort</strong>(array_r)</span><span id="e41c" class="lw lx it mv b gy nd na l nb nc">        l = 0<br/>        r = 0<br/>        <br/>        l_length = len(array_l)<br/>        r_length = len(array_r)<br/>        <br/>        sorted_list = []<br/>        <br/>        for i in range(length):<br/>            if r == r_length:<br/>                sorted_list.append(array_l_sorted[l])<br/>                l += 1</span><span id="66a0" class="lw lx it mv b gy nd na l nb nc">            elif l == l_length:<br/>                sorted_list.append(array_r_sorted[r])<br/>                r += 1               <br/>                <br/>            elif array_l_sorted[l] &gt; array_r_sorted[r]:<br/>                sorted_list.append(array_r_sorted[r])<br/>                r += 1<br/>                <br/>            elif array_l_sorted[l] &lt; array_r_sorted[r]:<br/>                sorted_list.append(array_l_sorted[l])<br/>                l += 1<br/>        <br/>        return np.array(sorted_list)</span></pre><h2 id="adb6" class="lw lx it bd ly lz ma dn mb mc md dp me kr mf mg mh kv mi mj mk kz ml mm mn mo bi translated">快速排序</h2><p id="dddb" class="pw-post-body-paragraph ki kj it kk b kl mp ju kn ko mq jx kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">快速排序算法从一个数组中随机选取一个轴心，并将原始数组分成两个子数组:一个子数组由小于轴心的数字组成，另一个子数组由较大的数字组成。通过递归地这样做，我们将最终获得排序后的数组。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/953fe81ab5f5622becf2346daa622b6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:568/format:webp/1*na-K3EHbqqmZZuxVW-95bA.png"/></div></figure><p id="75fb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里有一个简单的例子，你有一个 8 个数字的数组。在这种情况下，随机选择的支点变成了 6 个。然后，将小于 6 的数字分配给左边的子数组，将较大的数字分配给右边的子数组。</p><p id="9b5a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下一步是将算法递归应用到子阵列；随机枢轴现在在左(较小)子阵列中有两个，在右(较大)子阵列中有七个。通过递归地这样做，你将得到一个排序后的数组。</p><pre class="lh li lj lk gt mu mv mw mx aw my bi"><span id="f437" class="lw lx it mv b gy mz na l nb nc">def <strong class="mv iu">quick_sort</strong>(array):<br/>    length = len(array)<br/>    <br/>    if length &lt;= 1:<br/>        return array<br/>    <br/>    if length == 2:<br/>        if array[0] &gt; array[1]:<br/>            return [array[1], array[0]]<br/>        else:<br/>            return array<br/>        <br/>    else:<br/>        pivot = np.random.randint(0, length)<br/>        small = []<br/>        large = []<br/>        <br/>        for element in array:<br/>            if element &lt; array[pivot]:<br/>                small.append(element)<br/>            elif element &gt; array[pivot]:<br/>                large.append(element)<br/>                <br/>        if not small:<br/>            return [array[pivot]] + <strong class="mv iu">quick_sort</strong>(large)<br/>        elif not large:<br/>            return <strong class="mv iu">quick_sort</strong>(small) + [array[pivot]]<br/>        else:<br/>            return (<strong class="mv iu">quick_sort</strong>(small)<br/>                    + [array[pivot]]<br/>                    + <strong class="mv iu">quick_sort</strong>(large))</span></pre><p id="a36c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在最坏的情况下，你可以按升序或降序随机选择支点(例如，在上面的例子中，1 比 8 或 8 比 1)，成本将是<em class="lf">θ(n)。然而，这是可以忽略的，因为它发生的概率只有 2/n！</em>(例中 21600 次一次)。所以我们考虑算法的期望成本。</p><p id="2f7e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">排序算法的成本取决于它们比较了多少对。让我们考虑一下一个数组中的两个数<em class="lf"> Zi </em>和<em class="lf"> Zj (i &lt; j) </em>进行比较的概率。<em class="lf"> Zi </em>和<em class="lf"> Zj </em>只有在<em class="lf"> Zi </em>或<em class="lf"> Zj </em>被选作支点时才直接比较，如果<em class="lf"> Zi </em>和<em class="lf"> Zj </em>之间的任意一个数被选作支点，则从不直接比较(<em class="lf"> Zi </em>和<em class="lf"> Zj </em>被分配给单独的子阵)。当在<em class="lf">子</em>和<em class="lf"> Zj、</em>之外选择一个支点时，不会影响概率，因为<em class="lf">子</em>和<em class="lf"> Zj </em>在同一个子阵列中。这样，<em class="lf">子</em>和<em class="lf"> Zj </em>直接比较的概率是<em class="lf"> 2/(j - i+1) </em>。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/04c8471857133fb98f43cf163adae440.png" data-original-src="https://miro.medium.com/v2/resize:fit:518/format:webp/1*8GCgZC6IrRd5xAMkynw0oA.png"/></div></figure><p id="e9a6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，预期的比较次数是数组中所有数字对的<em class="lf"> 2/(j - i+1) </em>之和。</p><p id="1af7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过一些如左图所示的变形，我们发现该数字收敛到熟悉的<em class="lf">θ(nlgn)。</em>我们可以说快速排序算法的期望代价是<em class="lf">θ(nlgn)。</em></p><h2 id="8d27" class="lw lx it bd ly lz ma dn mb mc md dp me kr mf mg mh kv mi mj mk kz ml mm mn mo bi translated">就地快速排序</h2><p id="36a9" class="pw-post-body-paragraph ki kj it kk b kl mp ju kn ko mq jx kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">我们可以就地编写 Quicksort 算法，这意味着该算法只存储原始数组之外的常量数据。就地算法具有占用内存少的优点。下面是就地快速排序算法的代码。</p><pre class="lh li lj lk gt mu mv mw mx aw my bi"><span id="1ab8" class="lw lx it mv b gy mz na l nb nc">def <strong class="mv iu">quick_sort_in_place</strong>(array, start, end):<br/>    if start &lt; end:<br/>        <br/>        if start + 1 == end:<br/>            if array[start] &gt; array[end]:<br/>                larger = array[start]<br/>                array[start] = array[end]<br/>                array[end] = larger<br/>        <br/>        pivot = np.random.randint(start, end+1)<br/>        pivot_value = array[pivot]<br/>        <br/>        array[pivot] = array[-1]<br/>        array[-1] = pivot_value<br/>        <br/>        border = start - 1<br/>        <br/>        for i in range(start, end):<br/>            if array[i] &lt; pivot_value:<br/>                border += 1<br/>                border_value = array[i]<br/>                array[i] = array[border]<br/>                array[border] = border_value<br/>        array[-1] = array[border+1]<br/>        array[border+1] = pivot_value<br/>        <br/>        array = <strong class="mv iu">quick_sort_in_place</strong>(array, start, border+1)<br/>        array = <strong class="mv iu">quick_sort_in_place</strong>(array, border+2, end)</span><span id="5f1d" class="lw lx it mv b gy nd na l nb nc">    return array</span></pre><h2 id="f69d" class="lw lx it bd ly lz ma dn mb mc md dp me kr mf mg mh kv mi mj mk kz ml mm mn mo bi translated">性能检查</h2><p id="dc44" class="pw-post-body-paragraph ki kj it kk b kl mp ju kn ko mq jx kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">现在我们比较插入排序(<em class="lf">θ(n)</em>)、合并排序(<em class="lf">θ(nlgn)</em>)和快速排序(预期<em class="lf">θ(nlgn)</em>)的性能。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi ng"><img src="../Images/23b1441bb3aa4db53cb25c859eabac02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UdURW_0ursBHpcZx3FrCNA.png"/></div></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">来源:作者的计算</p></figure><p id="7bb4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">显然，合并排序和快速排序比插入排序有优势，它们的斜率比插入排序平缓。由于隐藏在<em class="lf">θ(nlgn)</em>符号中的常数较低，快速排序算法比合并排序更快，而快速就地排序与合并排序花费的时间一样多(即就地优势被一些其他成本抵消)。</p><p id="cb05" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于快速排序算法包含一些随机性，所以查看试验的成本分布是有用的。这是快速排序和合并排序算法处理 2 个⁰数 10，000 次试验的成本直方图。注意，如图所示，合并排序也容易出现随机性。两种分布都向最便宜的一端倾斜(左)。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi ng"><img src="../Images/2f300df952178983824054ca5cea27d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U7zzSQ2Vpi7ZY8ML4XX9kQ.png"/></div></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">来源:作者的计算</p></figure><p id="6f3d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们从快速排序算法中学到的一件事是，随机性可以成为我们的朋友。快速排序比其他排序算法更有效地处理大量数字。有了适当的概率论知识，我们也许能够写出成本较低的算法。</p></div></div>    
</body>
</html>