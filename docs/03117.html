<html>
<head>
<title>Computer Vision 101: Working with Color Images in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">计算机视觉101:用Python处理彩色图像</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/computer-vision-101-working-with-color-images-in-python-7b57381a8a54?source=collection_archive---------6-----------------------#2020-03-25">https://towardsdatascience.com/computer-vision-101-working-with-color-images-in-python-7b57381a8a54?source=collection_archive---------6-----------------------#2020-03-25</a></blockquote><div><div class="fc ij ik il im in"/><div class="io ip iq ir is"><figure class="iu iv gp gr iw ix gh gi paragraph-image"><div role="button" tabindex="0" class="iy iz di ja bf jb"><div class="gh gi it"><img src="../Images/f5f0922a7e13a7619916879579206182.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dQsnsb5ndX53BEH-ea98wQ.jpeg"/></div></div><p class="je jf gj gh gi jg jh bd b be z dk translated">来源:<a class="ae ji" href="https://www.pexels.com/photo/art-artistic-bright-color-220320/" rel="noopener ugc nofollow" target="_blank">佩克斯</a>。com</p></figure><div class=""/><div class=""><h2 id="d921" class="pw-subtitle-paragraph ki jk jl bd b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dk translated">了解处理RGB和实验室图像的基础知识，以促进您的计算机视觉项目！</h2></div><p id="1fa0" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">每一个计算机视觉项目——无论是猫/狗分类器还是<a class="ae ji" href="https://github.com/jantic/DeOldify" rel="noopener ugc nofollow" target="_blank">给旧图像/电影</a>添加颜色——都涉及到图像处理。而最终，模型只能和底层数据一样好——<em class="lw">垃圾入，垃圾出</em>。这就是为什么在这篇文章中，我重点解释在Python中处理彩色图像的基础知识，它们是如何表示的，以及如何将图像从一种颜色表示转换成另一种颜色表示。</p><h1 id="f6f0" class="lx ly jl bd lz ma mb mc md me mf mg mh kr mi ks mj ku mk kv ml kx mm ky mn mo bi translated">设置</h1><p id="ed09" class="pw-post-body-paragraph la lb jl lc b ld mp km lf lg mq kp li lj mr ll lm ln ms lp lq lr mt lt lu lv io bi translated">在本节中，我们将设置Python环境。首先，我们导入所有需要的库:</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="f1d6" class="nd ly jl mz b gy ne nf l ng nh">import numpy as np</span><span id="c5df" class="nd ly jl mz b gy ni nf l ng nh">from skimage.color import rgb2lab, rgb2gray, lab2rgb<br/>from skimage.io import imread, imshow</span><span id="3081" class="nd ly jl mz b gy ni nf l ng nh">import matplotlib.pyplot as plt</span></pre><p id="f11f" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">我们使用<a class="ae ji" href="https://scikit-image.org/" rel="noopener ugc nofollow" target="_blank"> scikit-image </a>，这是来自<code class="fe nj nk nl mz b">scikit-learn</code>家族的一个库，专注于处理图像。有许多可供选择的方法，一些库包括<code class="fe nj nk nl mz b">matplotlib</code>、<code class="fe nj nk nl mz b">numpy</code>、<a class="ae ji" href="https://pypi.org/project/opencv-python/" rel="noopener ugc nofollow" target="_blank"> OpenCV </a>、<a class="ae ji" href="https://pillow.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank"> Pillow </a>等。</p><p id="174b" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">在第二步中，我们定义一个helper函数，用于打印出关于图像的信息摘要——它的形状和每一层中的值的范围。</p><figure class="mu mv mw mx gt ix"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="2760" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">该函数的逻辑非常简单，一旦我们描述了图像是如何存储的，维度切片就有意义了。</p><h1 id="bd9e" class="lx ly jl bd lz ma mb mc md me mf mg mh kr mi ks mj ku mk kv ml kx mm ky mn mo bi translated">灰度等级</h1><p id="0789" class="pw-post-body-paragraph la lb jl lc b ld mp km lf lg mq kp li lj mr ll lm ln ms lp lq lr mt lt lu lv io bi translated">我们从最基本的情况开始，灰度图像。这些图像完全是由灰色阴影构成的。极端情况是黑色(对比度的最弱<a class="ae ji" href="https://en.wikipedia.org/wiki/Lightness" rel="noopener ugc nofollow" target="_blank">强度</a>)和白色(最强强度)。</p><p id="e33f" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">在遮光罩下，图像被存储为整数矩阵，其中一个像素的值对应于给定的灰度。灰度图像的数值范围从0(黑色)到255(白色)。下图直观地概述了这一概念。</p><figure class="mu mv mw mx gt ix gh gi paragraph-image"><div role="button" tabindex="0" class="iy iz di ja bf jb"><div class="gh gi no"><img src="../Images/fa4638c6bd1cfaf6a0233579cce32f06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aQunkG371Badww70sRF9HA.png"/></div></div><p class="je jf gj gh gi jg jh bd b be z dk translated"><a class="ae ji" href="https://ai.stanford.edu/~syyeung/cvweb/Pictures1/imagematrix.png" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="0302" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">在这篇文章中，我们将使用你已经看到的缩略图，彩色蜡笔的圆圈。选了这么一张有色彩的图不是偶然的:)</p><p id="dc95" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">我们首先将灰度图像加载到Python中并打印出来。</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="082b" class="nd ly jl mz b gy ne nf l ng nh">image_gs = imread('crayons.jpg', as_gray=True)</span><span id="f6df" class="nd ly jl mz b gy ni nf l ng nh">fig, ax = plt.subplots(figsize=(9, 16))<br/>imshow(image_gs, ax=ax)<br/>ax.set_title('Grayscale image')<br/>ax.axis('off');</span></pre><figure class="mu mv mw mx gt ix gh gi paragraph-image"><div role="button" tabindex="0" class="iy iz di ja bf jb"><div class="gh gi np"><img src="../Images/13578677753ca3191fe8ed1dbcd980c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aY8otylp46Jz4USxN6N_Mw.png"/></div></div></figure><p id="784a" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">由于原始图像是彩色的，我们使用<code class="fe nj nk nl mz b">as_gray=True</code>将其加载为灰度图像。或者，我们可以使用默认设置<code class="fe nj nk nl mz b">imread</code>加载图像(这将加载一个RGB图像——在下一节介绍),并使用<code class="fe nj nk nl mz b">rgb2gray</code>功能将其转换为灰度。</p><p id="aa59" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">接下来，我们运行helper函数来打印图像摘要。</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="b10f" class="nd ly jl mz b gy ne nf l ng nh">print_image_summary(image_gs, ['G'])</span></pre><p id="9409" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">运行代码会产生以下输出:</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="c279" class="nd ly jl mz b gy ne nf l ng nh">--------------<br/>Image Details:<br/>--------------<br/>Image dimensions: (1280, 1920)<br/>Channels:<br/>G : min=0.0123, max=1.0000</span></pre><p id="5690" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">图像存储为1280行×1920列的2D矩阵(高清晰度分辨率)。通过查看最小值和最大值，我们可以看到它们在[0，1]范围内。这是因为它们被自动除以255，这是处理图像的常见预处理步骤。</p><h1 id="7c72" class="lx ly jl bd lz ma mb mc md me mf mg mh kr mi ks mj ku mk kv ml kx mm ky mn mo bi translated">RGB</h1><p id="26d8" class="pw-post-body-paragraph la lb jl lc b ld mp km lf lg mq kp li lj mr ll lm ln ms lp lq lr mt lt lu lv io bi translated">现在是使用颜色的时候了。我们从<a class="ae ji" href="https://en.wikipedia.org/wiki/RGB_color_model" rel="noopener ugc nofollow" target="_blank"> <strong class="lc jm"> RGB模型</strong> </a>开始。简而言之，这是一个加法模型，其中红色、绿色和蓝色(因此得名)的阴影以各种比例添加在一起，以再现广泛的颜色光谱。</p><p id="2b79" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">在<code class="fe nj nk nl mz b">scikit-image</code>中，这是使用<code class="fe nj nk nl mz b">imread</code>加载图像的默认模式:</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="3829" class="nd ly jl mz b gy ne nf l ng nh">image_rgb = imread('crayons.jpg')</span></pre><p id="6205" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">在打印图像之前，让我们检查一下摘要，以了解图像在Python中的存储方式。</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="4621" class="nd ly jl mz b gy ne nf l ng nh">print_image_summary(image_rgb, ['R', 'G', 'B'])</span></pre><p id="bd78" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">运行代码会生成以下摘要:</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="01d1" class="nd ly jl mz b gy ne nf l ng nh">--------------<br/>Image Details:<br/>--------------<br/>Image dimensions: (1280, 1920, 3)<br/>Channels:<br/>R : min=0.0000, max=255.0000<br/>G : min=0.0000, max=255.0000<br/>B : min=0.0000, max=255.0000</span></pre><p id="fd5b" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">与灰度图像相比，这次图像存储为3D <code class="fe nj nk nl mz b">np.ndarray</code>。额外的维度表示3个颜色通道中的每一个。和以前一样，颜色的强度在0-255的范围内显示。它经常被重新调整到[0，1]范围。然后，任何层中的像素值为0表示该像素的特定通道中没有颜色。</p><p id="3c4d" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">一个有用的提示:当使用OpenCV的<code class="fe nj nk nl mz b">imread</code>函数时，图像被加载为BGR而不是RGB。为了使它与其他库兼容，我们需要改变通道的顺序。</p><p id="4071" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">是时候打印图像和不同的颜色通道了:</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="a931" class="nd ly jl mz b gy ne nf l ng nh">fig, ax = plt.subplots(1, 4, figsize = (18, 30))</span><span id="2185" class="nd ly jl mz b gy ni nf l ng nh">ax[0].imshow(image_rgb/255.0) <br/>ax[0].axis('off')<br/>ax[0].set_title('original RGB')</span><span id="a350" class="nd ly jl mz b gy ni nf l ng nh">for i, lab in enumerate(['R','G','B'], 1):<br/>    temp = np.zeros(image_rgb.shape)<br/>    temp[:,:,i - 1] = image_rgb[:,:,i - 1]<br/>    ax[i].imshow(temp/255.0) <br/>    ax[i].axis("off")<br/>    ax[i].set_title(lab)</span><span id="102c" class="nd ly jl mz b gy ni nf l ng nh">plt.show()</span></pre><p id="4a57" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">在下图中，我们可以分别看到原始图像和3个颜色通道。我喜欢这幅图像的原因是，通过关注单个蜡笔，我们可以看到RGB通道中的哪些颜色以及哪些比例构成了原始图像中的最终颜色。</p><figure class="mu mv mw mx gt ix gh gi paragraph-image"><div role="button" tabindex="0" class="iy iz di ja bf jb"><div class="gh gi nq"><img src="../Images/c647dde68ab37376faa55951691d4639.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-2EVHtSCFwyFRzmYSzRCyw.png"/></div></div></figure><p id="32d8" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">或者，我们可以绘制单独的颜色通道，如下所示:</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="9e14" class="nd ly jl mz b gy ne nf l ng nh">fig, ax = plt.subplots(1, 4, figsize = (18, 30))</span><span id="6c8a" class="nd ly jl mz b gy ni nf l ng nh">ax[0].imshow(image_rgb) <br/>ax[0].axis('off')<br/>ax[0].set_title('original RGB')</span><span id="0202" class="nd ly jl mz b gy ni nf l ng nh">for i, cmap in enumerate(['Reds','Greens','Blues']):<br/>    ax[i+1].imshow(image_rgb[:,:,i], cmap=cmap) <br/>    ax[i+1].axis('off')<br/>    ax[i+1].set_title(cmap[0])</span><span id="62c2" class="nd ly jl mz b gy ni nf l ng nh">plt.show()</span></pre><p id="62c5" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">什么会生成以下输出:</p><figure class="mu mv mw mx gt ix gh gi paragraph-image"><div role="button" tabindex="0" class="iy iz di ja bf jb"><div class="gh gi nr"><img src="../Images/f5954313a29aa6a4accc5f027790e49e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PvFSwUfqiJYG_M9rKd6hwQ.png"/></div></div></figure><p id="eec9" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">我更喜欢这种绘制RGB通道的变体，因为我发现它更容易区分不同的颜色(由于其他颜色更亮和透明，它们更突出)及其强度。</p><p id="3bb9" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">在处理图像分类任务时，我们经常会遇到RGB图像。当将卷积神经网络(CNN)应用于该任务时，我们需要将所有操作应用于所有3个颜色通道。在这篇文章中，我展示了如何使用CNN来处理二值图像分类问题。</p><h1 id="0350" class="lx ly jl bd lz ma mb mc md me mf mg mh kr mi ks mj ku mk kv ml kx mm ky mn mo bi translated">工党</h1><p id="9c67" class="pw-post-body-paragraph la lb jl lc b ld mp km lf lg mq kp li lj mr ll lm ln ms lp lq lr mt lt lu lv io bi translated">除了RGB，另一种流行的表示彩色图像的方式是使用<strong class="lc jm"> Lab色彩空间</strong>(也称为CIELAB)。</p><p id="43c0" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">在进入更多细节之前，指出颜色模型和颜色空间之间的区别是有意义的。颜色模型是描述颜色的数学方法。颜色空间是将真实的、可观察的颜色映射到颜色模型的离散值的方法。更多详情请参考<a class="ae ji" href="https://photo.stackexchange.com/questions/48984/what-is-the-difference-or-relation-between-a-color-model-and-a-color-space" rel="noopener ugc nofollow" target="_blank">本答案</a>。</p><p id="9c8f" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">Lab颜色空间将颜色表示为三个值:</p><ul class=""><li id="3629" class="ns nt jl lc b ld le lg lh lj nu ln nv lr nw lv nx ny nz oa bi translated"><em class="lw"> L </em>:从0(黑色)到100(白色)范围内的亮度，实际上是灰度图像</li><li id="4014" class="ns nt jl lc b ld ob lg oc lj od ln oe lr of lv nx ny nz oa bi translated"><em class="lw"> a </em>:绿-红色谱，数值范围为-128(绿色)~ 127(红色)</li><li id="3c58" class="ns nt jl lc b ld ob lg oc lj od ln oe lr of lv nx ny nz oa bi translated"><em class="lw"> b </em>:蓝黄色光谱，数值范围为-128(蓝色)~ 127(黄色)</li></ul><p id="bd76" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">换句话说，Lab将图像编码为灰度层，并将三个颜色层减少为两个。</p><p id="4fdd" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">我们首先将图像从RGB转换到Lab，并打印图像摘要:</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="f9a8" class="nd ly jl mz b gy ne nf l ng nh">image_lab = rgb2lab(image_rgb / 255)</span></pre><p id="8577" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated"><code class="fe nj nk nl mz b">rgb2lab</code>函数假设RGB被标准化为0到1之间的值，这就是为什么所有值都除以255的原因。从下面的总结中，我们看到实验室值的范围在上面规定的范围内。</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="0a90" class="nd ly jl mz b gy ne nf l ng nh">--------------<br/>Image Details:<br/>--------------<br/>Image dimensions: (1280, 1920, 3)<br/>Channels:<br/>L : min=0.8618, max=100.0000<br/>a : min=-73.6517, max=82.9795<br/>b : min=-94.7288, max=91.2710</span></pre><p id="6453" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">下一步，我们将图像可视化——实验室一号和每个单独的通道。</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="9dc1" class="nd ly jl mz b gy ne nf l ng nh">fig, ax = plt.subplots(1, 4, figsize = (18, 30))</span><span id="2a64" class="nd ly jl mz b gy ni nf l ng nh">ax[0].imshow(image_lab) <br/>ax[0].axis('off')<br/>ax[0].set_title('Lab')</span><span id="b34b" class="nd ly jl mz b gy ni nf l ng nh">for i, col in enumerate(['L', 'a', 'b'], 1):<br/>    imshow(image_lab[:, :, i-1], ax=ax[i])<br/>    ax[i].axis('off')<br/>    ax[i].set_title(col)</span><span id="7234" class="nd ly jl mz b gy ni nf l ng nh">fig.show()</span></pre><figure class="mu mv mw mx gt ix gh gi paragraph-image"><div role="button" tabindex="0" class="iy iz di ja bf jb"><div class="gh gi og"><img src="../Images/4a6c24d51b1745d6b8c7d8c3120d5300.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xglC0aD1jZs2BBl-49g8FA.png"/></div></div><p class="je jf gj gh gi jg jh bd b be z dk translated">第一次尝试绘制实验室图像</p></figure><p id="2b87" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">嗯，第一次可视化Lab色彩空间的尝试远远没有成功。第一张图像几乎无法辨认，L层不是灰度。根据本答案中<a class="ae ji" href="https://stackoverflow.com/questions/46415948/converting-rgb-images-to-lab-using-scikit-image" rel="noopener ugc nofollow" target="_blank">的见解，为了正确打印，实验室值必须重新调整到【0，1】范围。这一次，第一个图层的重定比例与后两个不同。</a></p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="d943" class="nd ly jl mz b gy ne nf l ng nh">#scale the lab image<br/>image_lab_scaled = (image_lab + [0, 128, 128]) / [100, 255, 255]</span><span id="5ffd" class="nd ly jl mz b gy ni nf l ng nh">fig, ax = plt.subplots(1, 4, figsize = (18, 30))</span><span id="3df8" class="nd ly jl mz b gy ni nf l ng nh">ax[0].imshow(image_lab_scaled) <br/>ax[0].axis('off')<br/>ax[0].set_title('Lab scaled')</span><span id="69a3" class="nd ly jl mz b gy ni nf l ng nh">for i, col in enumerate(['L', 'a', 'b'], 1):<br/>    imshow(image_lab_scaled[:, :, i-1], ax=ax[i])<br/>    ax[i].axis('off')<br/>    ax[i].set_title(col)<br/>    <br/>fig.show()</span></pre><p id="9c64" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">第二次尝试要好得多。在第一幅图像中，我们看到了彩色图像的Lab表示。这一次，<em class="lw"> L </em>层是实际的灰度图像。仍然可以改进的是最后两层，因为它们也是灰度的。</p><figure class="mu mv mw mx gt ix gh gi paragraph-image"><div role="button" tabindex="0" class="iy iz di ja bf jb"><div class="gh gi oh"><img src="../Images/9c232f3a1d558bc988b72bc6289c0773.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UOcrblHxSHL-s3LTfD5Nng.png"/></div></div><p class="je jf gj gh gi jg jh bd b be z dk translated">第二次尝试绘制实验室图像</p></figure><p id="2462" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">在最后一次尝试中，我们将彩色贴图应用到实验室图像的<em class="lw"> a </em>和<em class="lw"> b </em>层。</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="5278" class="nd ly jl mz b gy ne nf l ng nh">fig, ax = plt.subplots(1, 4, figsize = (18, 30))</span><span id="6287" class="nd ly jl mz b gy ni nf l ng nh">ax[0].imshow(image_lab_scaled) <br/>ax[0].axis('off')<br/>ax[0].set_title('Lab scaled')</span><span id="bcd1" class="nd ly jl mz b gy ni nf l ng nh">imshow(image_lab_scaled[:,:,0], ax=ax[1]) <br/>ax[1].axis('off')<br/>ax[1].set_title('L')</span><span id="9e21" class="nd ly jl mz b gy ni nf l ng nh">ax[2].imshow(image_lab_scaled[:,:,1], cmap='RdYlGn_r') <br/>ax[2].axis('off')<br/>ax[2].set_title('a')</span><span id="e985" class="nd ly jl mz b gy ni nf l ng nh">ax[3].imshow(image_lab_scaled[:,:,2], cmap='YlGnBu_r') <br/>ax[3].axis('off')<br/>ax[3].set_title('b')<br/>    <br/>plt.show()</span></pre><p id="81f0" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">这一次结果令人满意。我们可以清楚的分辨出<em class="lw"> a </em>和<em class="lw"> b </em>图层中不同的颜色。仍然可以改进的是色彩映射表本身。为了简单起见，我使用了预定义的颜色贴图，它包含一种介于两种极端颜色之间的颜色(黄色代表图层<em class="lw"> a </em>，绿色代表图层<em class="lw"> b </em>)。一个潜在的解决方案是手动编码彩色地图。</p><figure class="mu mv mw mx gt ix gh gi paragraph-image"><div role="button" tabindex="0" class="iy iz di ja bf jb"><div class="gh gi oi"><img src="../Images/af6efb2a2993bda0e008217dba29c8af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n2KAEwR-CFAfkL4Zr9csCQ.png"/></div></div><p class="je jf gj gh gi jg jh bd b be z dk translated">第三次尝试绘制实验室图像</p></figure><p id="da3a" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">在处理图像着色问题时，经常会遇到Lab图像，例如著名的<a class="ae ji" href="https://github.com/jantic/DeOldify" rel="noopener ugc nofollow" target="_blank">去模糊</a>。</p><h1 id="6292" class="lx ly jl bd lz ma mb mc md me mf mg mh kr mi ks mj ku mk kv ml kx mm ky mn mo bi translated">结论</h1><p id="1ac6" class="pw-post-body-paragraph la lb jl lc b ld mp km lf lg mq kp li lj mr ll lm ln ms lp lq lr mt lt lu lv io bi translated">在本文中，我回顾了使用Python处理彩色图像的基础知识。使用所介绍的技术，你可以开始自己解决计算机视觉问题。我认为理解图像是如何存储的以及如何将它们转换成不同的表示是很重要的，这样你就不会在训练深度神经网络时遇到意想不到的问题。</p><p id="0299" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">另一个流行的色彩空间是XYZ。<code class="fe nj nk nl mz b">scikit-image</code>还包含将RGB或Lab图像转换成XYZ的功能。</p><p id="c92b" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">您可以在我的<a class="ae ji" href="https://github.com/erykml/medium_articles/blob/master/Computer%20Vision/working_with_color_images.ipynb" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到本文使用的代码。一如既往，我们欢迎任何建设性的反馈。你可以在推特上或者评论里联系我。</p></div><div class="ab cl oj ok hz ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="io ip iq ir is"><p id="688d" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">我最近出版了一本关于使用Python解决金融领域实际任务的书。如果你有兴趣，我贴了一篇文章<a class="ae ji" rel="noopener" target="_blank" href="/introducing-my-book-python-for-finance-cookbook-de219ca0d612">介绍这本书的内容。你可以在亚马逊或者T21的网站上买到这本书。</a></p></div><div class="ab cl oj ok hz ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="io ip iq ir is"><h1 id="dccd" class="lx ly jl bd lz ma oq mc md me or mg mh kr os ks mj ku ot kv ml kx ou ky mn mo bi translated">参考</h1><p id="0a15" class="pw-post-body-paragraph la lb jl lc b ld mp km lf lg mq kp li lj mr ll lm ln ms lp lq lr mt lt lu lv io bi translated">[1]<a class="ae ji" href="https://ai.stanford.edu/~syyeung/cvweb/tutorial1.html" rel="noopener ugc nofollow" target="_blank">https://ai.stanford.edu/~syyeung/cvweb/tutorial1.html</a></p><p id="28fa" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated"><a class="ae ji" href="https://github.com/scikit-image/scikit-image/issues/1185" rel="noopener ugc nofollow" target="_blank">https://github.com/scikit-image/scikit-image/issues/1185</a></p></div></div>    
</body>
</html>