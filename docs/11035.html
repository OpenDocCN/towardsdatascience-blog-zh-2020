<html>
<head>
<title>Machine Learning and Supply Chain Management: Hands-on Series #2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">机器学习和供应链管理:动手系列#2</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/machine-learning-and-supply-chain-management-hands-on-series-2-d723125f749e?source=collection_archive---------46-----------------------#2020-07-31">https://towardsdatascience.com/machine-learning-and-supply-chain-management-hands-on-series-2-d723125f749e?source=collection_archive---------46-----------------------#2020-07-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="f51a" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" rel="noopener" target="_blank" href="https://towardsdatascience.com/machine-learning/home">内部 AI </a></h2><div class=""/><div class=""><h2 id="27b0" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">不准确的预测比不预测更糟糕。学习保存机器学习训练的模型以备将来使用，并测量模型的准确性。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/9d8cf164ac81bfb197d70db707ec7d8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0d2ItOaAS-xB_wTEHl4CVg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@shaahshahidh?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Shaah Shahidh</a>&amp;<a class="ae lh" href="https://unsplash.com/@alexkixa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Alexandre debiève</a>在<a class="ae lh" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="416b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在本系列的第<a class="ae lh" href="https://medium.com/@kaushikthoughts/machine-learning-and-supply-chain-management-1a1d9462eb35" rel="noopener">部分</a>中，我已经讨论了机器学习算法的一个基本简化实现，它可以根据输入参数预测未来采购订单的缺陷百分比。</p><p id="adad" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这一部分中，我将谈到训练模型的准确性度量。我们有许多参数(称为估计量的超参数),这些参数在模型中作为变量传递以执行预测。在实践中，基于训练模型的准确性度量结果，在模型被实施用于生产中的预测之前，超参数被调整。算法可以搜索并推荐优化的超参数，而不是通过试错法手动调整超参数来获得优化的准确度分数。我将在本系列的后面部分讨论有效的参数搜索策略。</p><p id="d902" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">正如在本系列的前一部分中提到的，在预测之前每次都从头开始训练模型是不实际的。我还将讨论如何保存一个训练好的模型，并将其直接导入另一个程序进行预测。</p><p id="861b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="me">注</em>:我将详细解释新的领域和概念，并将避免详细重复我之前文章中解释的部分。我鼓励您参考前面的<a class="ae lh" href="https://medium.com/@kaushikthoughts/machine-learning-and-supply-chain-management-1a1d9462eb35" rel="noopener">部分</a>。</p><p id="2e98" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> <em class="me">第一步</em> </strong></p><p id="3ef3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">首先，我们将导入模型所需的包。<strong class="lk jd">需要使用 StratifiedShuffleSplit </strong>导入来构建一个训练模型，其样本集很好地代表了不同的子集值范围。<strong class="lk jd"> Pickle </strong>模块将帮助我们保存训练好的模型，然后直接在其他程序中导入模型进行预测。最后，sklearn.metrics 有一套方法来衡量任何模型的准确性。</p><pre class="ks kt ku kv gt mf mg mh mi aw mj bi"><span id="eddb" class="mk ml it mg b gy mm mn l mo mp">import pandas as pd</span><span id="bded" class="mk ml it mg b gy mq mn l mo mp">import numpy as np</span><span id="15ad" class="mk ml it mg b gy mq mn l mo mp">from sklearn.model_selection import StratifiedShuffleSplit #import to have equal weigtage samples in training dataset</span><span id="51c8" class="mk ml it mg b gy mq mn l mo mp">from sklearn.tree import DecisionTreeRegressor # import for Decision Tree Algorithm</span><span id="cc89" class="mk ml it mg b gy mq mn l mo mp">import pickle</span><span id="ad98" class="mk ml it mg b gy mq mn l mo mp">from sklearn.preprocessing import StandardScaler</span><span id="ab80" class="mk ml it mg b gy mq mn l mo mp">from sklearn.svm import SVR #import for support vector regressor</span><span id="68f2" class="mk ml it mg b gy mq mn l mo mp">from sklearn.metrics import mean_squared_error  # import to calculate root mean square</span></pre><p id="ac9b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> <em class="me">第二步</em> </strong></p><p id="feb3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">将从 ERP 和其他应用程序导出的样本数据集读入 pandas 数据框架。请参考<a class="ae lh" href="https://www.linkedin.com/pulse/machine-learning-supply-chain-management-hands-on-series-choudhury/?trackingId=RRoR7gjSWF1Sfz5tBIWipA%3D%3D" rel="noopener ugc nofollow" target="_blank">早前的文章</a>了解数据集的结构和其他细节。</p><pre class="ks kt ku kv gt mf mg mh mi aw mj bi"><span id="65af" class="mk ml it mg b gy mm mn l mo mp">SourceData=pd.read_excel("Supplier Past Performance.xlsx") # Load the data into Pandas DataFrame</span></pre><p id="6f4f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> <em class="me">第三步</em> </strong></p><p id="b412" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">粗略分析数据样本后，似乎“PO 数量”对“缺陷百分比”有着密切而强烈的影响，因此我们希望确保使用不同范围的“PO 数量”记录来训练模型。如果我们用由 30，000 到 60，000 英镑之间的“PO 数量”过度表示的数据集来训练我们的模型，那么我们的模型学习将不会准确到现实生活场景，并且可能不会准确预测。</p><p id="443a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在下面的代码中，引入了一个新的列“采购订单类别”,将 0 至 30，000 英镑的“采购订单金额”分类为采购订单类别 1，30，000 至 60，000 英镑的为采购订单类别 2。</p><pre class="ks kt ku kv gt mf mg mh mi aw mj bi"><span id="1349" class="mk ml it mg b gy mm mn l mo mp">SourceData["PO Category"]=pd.cut(SourceData["PO Amount"],<br/>                                     bins=[0., 30000, 60000, 90000,<br/>np.inf],                                     <br/>labels=[1, 2, 3, 4])</span></pre><p id="f293" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> <em class="me">第四步</em> </strong></p><p id="3cc8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">StatifiedShuffleSplit 提供训练和测试索引，将过去的数据集分成训练集和测试集。在下面的代码中，我们保留了 30%的数据用于测试模型，60%用于训练模型</p><pre class="ks kt ku kv gt mf mg mh mi aw mj bi"><span id="2d65" class="mk ml it mg b gy mm mn l mo mp">split = StratifiedShuffleSplit(n_splits=2, test_size=0.3)</span></pre><p id="39ba" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> <em class="me">第五步</em> </strong></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi mr"><img src="../Images/13b0f1334ff866dc2ccdabc372d9f956.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cs9Z3K0iGFfVfEvb"/></div></div></figure><p id="b681" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">使用前面步骤中的训练和测试索引，我们将初始源数据分成两部分，即。strat_train_set 作为训练数据集，strat_test_set 分别作为模型的测试和训练数据集。</p><p id="232b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在下面的代码中，我们使用“采购订单类别”来确保在每个分开的集合中，不同的采购订单类别都得到很好的表示。</p><pre class="ks kt ku kv gt mf mg mh mi aw mj bi"><span id="7bc5" class="mk ml it mg b gy mm mn l mo mp">for train_index, test_index in split.split(SourceData, SourceData["PO Category"]):<br/>    strat_train_set = SourceData.loc[train_index]  # stratfied train dataset <br/>    strat_test_set = SourceData.loc[test_index] #stratified test dataset</span></pre><p id="6cbd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> <em class="me">第六步</em> </strong></p><p id="a170" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们引入了一个额外的列“PO Category ”,以确保在测试和训练数据集中充分表示来自所有 PO 金额范围的采购订单。由于已经完成，因此我们将从数据集中删除这个额外的 PO 类别。</p><pre class="ks kt ku kv gt mf mg mh mi aw mj bi"><span id="55f3" class="mk ml it mg b gy mm mn l mo mp">for set_ in (strat_train_set, strat_test_set): <br/>    set_.drop("PO Category", axis=1, inplace=True)</span></pre><p id="4807" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> <em class="me">第七步</em> </strong></p><p id="cbb3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，我们将为我们的模型定义、测试和训练数据独立变量和因变量。我们将使用独立和从属训练数据集来训练模型，因为它是一种受监督的机器学习。此外，我们将使用模型之前没有见过的测试数据集来测试模型性能。</p><pre class="ks kt ku kv gt mf mg mh mi aw mj bi"><span id="e5c9" class="mk ml it mg b gy mm mn l mo mp">SourceData_train_independent= strat_train_set.drop(["Defect Percent"], axis=1)<br/>SourceData_train_dependent=strat_train_set["Defect Percent"].copy()</span><span id="7cc4" class="mk ml it mg b gy mq mn l mo mp">SourceData_test_independent= strat_test_set.drop(["Defect Percent"], axis=1)<br/>SourceData_test_dependent=strat_test_set["Defect Percent"].copy()</span></pre><p id="8d99" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> <em class="me">第八步</em> </strong></p><p id="c48a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">由于数据属性具有不同的范围，因此我们需要在使用它进行训练之前对其进行缩放。关于缩放数据的更多信息，请参考我之前的文章。</p><p id="0afa" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在下面的代码中，我们使用 pickle.dump()将 scale 保存为“Scaler.sav ”,以后我们可以在其他程序中导入以供使用。</p><pre class="ks kt ku kv gt mf mg mh mi aw mj bi"><span id="45be" class="mk ml it mg b gy mm mn l mo mp">sc_X = StandardScaler()<br/>X_train=sc_X.fit_transform(SourceData_train_independent.values)<br/>y_train=SourceData_train_dependent</span><span id="e7c4" class="mk ml it mg b gy mq mn l mo mp">pickle.dump(sc_X, open("Scaler.sav", 'wb'))</span><span id="b1d8" class="mk ml it mg b gy mq mn l mo mp">X_test=sc_X.fit_transform(SourceData_test_independent.values)<br/>y_test=SourceData_test_dependent</span></pre><p id="be0a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> <em class="me">第九步</em> </strong></p><p id="f6d9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们将用训练数据集训练支持向量模型，并用 pickle 将训练好的模型保存为“SVR_TrainedModel.sav”。“SVR_TrainedModel.sav”和当前程序保存在同一个文件目录中，因为我们没有提供完整的路径和唯一的文件名作为保存参数。</p><pre class="ks kt ku kv gt mf mg mh mi aw mj bi"><span id="f51f" class="mk ml it mg b gy mm mn l mo mp">svm_reg = SVR(kernel="linear", C=1)<br/>svm_reg.fit(X_train, y_train)</span><span id="f3e9" class="mk ml it mg b gy mq mn l mo mp">filename = 'SVR_TrainedModel.sav'<br/>pickle.dump(svm_reg, open(filename, 'wb'),protocol=-1)</span></pre><p id="6917" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> <em class="me">第十步</em> </strong></p><p id="6f34" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，我们将从经过训练的独立数据集预测因变量，即缺陷百分比值，并测量模型的误差/准确性。在下面的代码中，我们传递训练数据集，然后将模型的预测值与实际值进行比较。将独立训练变量数据集的预测与实际值进行比较，并通过评分方法返回回归估计量的 R 分数。</p><pre class="ks kt ku kv gt mf mg mh mi aw mj bi"><span id="96da" class="mk ml it mg b gy mm mn l mo mp">decision_predictions = svm_reg.predict(X_train)</span><span id="981c" class="mk ml it mg b gy mq mn l mo mp">Score = (svm_reg.score(X_train, y_train))  # It provides the R-Squared Value<br/>print ( "The score of the Support  Vector model is", round(Score,2))</span><span id="2ef0" class="mk ml it mg b gy mq mn l mo mp">lin_mse = mean_squared_error(y_train, decision_predictions)<br/>print("MSE  of  Vector  model is ", round(lin_mse,2))</span><span id="0ac5" class="mk ml it mg b gy mq mn l mo mp">lin_rmse = mean_squared_error(y_train, decision_predictions, squared=False)<br/>print("RMSE of  Support  Vector  Learning model is ", round(lin_rmse,2))</span></pre><p id="4a97" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这篇文章中，我不会涉及 R-Square、均方差和均方根误差的统计细节，我强烈建议大家阅读维基百科中关于这些统计指标的页面。这将有助于解释模型是否被训练到可接受的极限，或者我们需要微调数据和超参数。</p><pre class="ks kt ku kv gt mf mg mh mi aw mj bi"><span id="235d" class="mk ml it mg b gy mm mn l mo mp">The score of the Support  Vector model is 0.09<br/>MSE  of  Vector  model is  0.05<br/>RMSE of  Support  Vector  Learning model is  0.12</span></pre><p id="33ef" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> <em class="me">第十一步</em> </strong></p><p id="7824" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于决策树学习模型，我们遵循相同的步骤，并检查模型的准确性。</p><pre class="ks kt ku kv gt mf mg mh mi aw mj bi"><span id="7f88" class="mk ml it mg b gy mm mn l mo mp">tree_reg = DecisionTreeRegressor()<br/>tree_reg.fit(X_train, y_train)<br/>filename = 'DecisionTree_TrainedModel.sav'<br/>pickle.dump(tree_reg, open(filename, 'wb'),protocol=-1<br/></span><span id="71af" class="mk ml it mg b gy mq mn l mo mp">predictions = tree_reg.predict(X_train) </span><span id="d1a3" class="mk ml it mg b gy mq mn l mo mp">Score = (tree_reg.score(X_train, y_train))  # It provides the R-Squared Value<br/>print ( "The score of model Decision Tree model is ", round(Score,2))</span><span id="20bc" class="mk ml it mg b gy mq mn l mo mp">lin_mse = mean_squared_error(y_train, predictions)<br/>print("MSE of Decision Tree model is ", round(lin_mse,2))</span><span id="e994" class="mk ml it mg b gy mq mn l mo mp">lin_rmse = mean_squared_error(y_train, decision_predictions, squared=False)<br/>print("RMSE of Decision Tree model is ", round(lin_rmse,2))</span></pre><p id="59b2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> <em class="me">第十二步</em> </strong></p><p id="ac19" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一旦模型预测的结果在可接受的误差范围内，我们就可以将模型以前没有见过的测试数据集输入到预测模型中。我们可以用与训练数据集相同的方式来比较测试数据集相关的数据准确性。</p><pre class="ks kt ku kv gt mf mg mh mi aw mj bi"><span id="291a" class="mk ml it mg b gy mm mn l mo mp">test_predictions = tree_reg.predict(X_test)<br/>test_decision_predictions = svm_reg.predict(X_test)</span></pre><p id="82ff" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">导入训练好的模型和预测</strong></p><p id="7ae5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">要在另一个程序中使用训练好的模型，我们需要使用“pickle.load”导入自变量 scales 和学习模型，如下面的代码片段所示。</p><p id="c4de" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里，我们从“Supply Chain Predict.xlsx”文件中读取新的独立值数据集，预测相应因变量的进一步步骤如上文针对测试数据所述。</p><pre class="ks kt ku kv gt mf mg mh mi aw mj bi"><span id="7675" class="mk ml it mg b gy mm mn l mo mp">import pickle<br/>import pandas as pd </span><span id="b0e7" class="mk ml it mg b gy mq mn l mo mp">testdata=pd.read_excel("Supply Chain Predict.xlsx") # Load the test data</span><span id="5640" class="mk ml it mg b gy mq mn l mo mp">sc_X = pickle.load(open('Scaler.sav', 'rb'))  # Load the pickle</span><span id="9a19" class="mk ml it mg b gy mq mn l mo mp">loaded_model = pickle.load(open('DecisionTree_TrainedModel.sav', 'rb')) # load the trained model</span><span id="b124" class="mk ml it mg b gy mq mn l mo mp">X_test=sc_X.transform(testdata.values) # scale the independent variables for test data</span><span id="c615" class="mk ml it mg b gy mq mn l mo mp">decision_predictions = loaded_model.predict(X_test) # Predict the value of dependent variable</span><span id="2eca" class="mk ml it mg b gy mq mn l mo mp">print("The prediction by Decision Treemodel is " , decision_predictions )</span></pre><p id="2060" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="me">完整的代码片段</em></p><pre class="ks kt ku kv gt mf mg mh mi aw mj bi"><span id="8e50" class="mk ml it mg b gy mm mn l mo mp"># Importing the required modules <br/>import pandas as pd<br/>import numpy as np<br/>from sklearn.model_selection import StratifiedShuffleSplit #import to have equal weigtage samples in training dataset<br/>from sklearn.tree import DecisionTreeRegressor # import for Decision Tree Algorithm<br/>import pickle<br/>from sklearn.preprocessing import StandardScaler<br/>from sklearn.svm import SVR #import for support vector regressor<br/>from sklearn.metrics import mean_squared_error  # import to calculate root mean square</span><span id="b90f" class="mk ml it mg b gy mq mn l mo mp">SourceData=pd.read_excel("Supplier Past Performance.xlsx") # Load the data into Pandas DataFrame<br/>SourceData_independent= SourceData.drop(["Defect Percent"], axis=1) # Drop depedent variable from training dataset<br/>SourceData_dependent=SourceData["Defect Percent"].copy() # New dataframe with only independent variable value for training dataset<br/>SourceData["PO Category"]=pd.cut(SourceData["PO Amount "],<br/>                                     bins=[0., 30000, 60000, 90000,<br/>np.inf],                                     <br/>labels=[1, 2, 3, 4])<br/>split = StratifiedShuffleSplit(n_splits=1, test_size=0.3)<br/>for train_index, test_index in split.split(SourceData, SourceData["PO Category"]):<br/>    strat_train_set = SourceData.loc[train_index]  # stratfied train dataset <br/>    strat_test_set = SourceData.loc[test_index] #stratified test dataset</span><span id="4f2d" class="mk ml it mg b gy mq mn l mo mp">for set_ in (strat_train_set, strat_test_set): <br/>    set_.drop("PO Category", axis=1, inplace=True)</span><span id="451e" class="mk ml it mg b gy mq mn l mo mp">    <br/>SourceData_train_independent= strat_train_set.drop(["Defect Percent"], axis=1)<br/>SourceData_train_dependent=strat_train_set["Defect Percent"].copy()<br/>SourceData_test_independent= strat_test_set.drop(["Defect Percent"], axis=1)<br/>SourceData_test_dependent=strat_test_set["Defect Percent"].copy()<br/>sc_X = StandardScaler()<br/>X_train=sc_X.fit_transform(SourceData_train_independent.values)<br/>y_train=SourceData_train_dependent<br/>pickle.dump(sc_X, open("Scaler.sav", 'wb'))<br/>X_test=sc_X.fit_transform(SourceData_test_independent.values)<br/>y_test=SourceData_test_dependent</span><span id="9a3a" class="mk ml it mg b gy mq mn l mo mp">svm_reg = SVR(kernel="linear", C=1)<br/>svm_reg.fit(X_train, y_train)<br/>filename = 'SVR_TrainedModel.sav'<br/>pickle.dump(svm_reg, open(filename, 'wb'),protocol=-1)<br/>decision_predictions = svm_reg.predict(X_test)<br/>Score = (svm_reg.score(X_test, y_test))  # It provides the R-Squared Value<br/>print ( "The score of the Support  Vector model is", round(Score,2))<br/>lin_mse = mean_squared_error(y_test, decision_predictions)<br/>print("MSE  of  Vector  model is ", round(lin_mse,2))<br/>lin_rmse = mean_squared_error(y_test, decision_predictions, squared=False)<br/>print("RMSE of  Support  Vector  Learning model is ", round(lin_rmse,2))</span><span id="e045" class="mk ml it mg b gy mq mn l mo mp">tree_reg = DecisionTreeRegressor()<br/>tree_reg.fit(X_train, y_train)<br/>filename = 'DecisionTree_TrainedModel.sav'<br/>pickle.dump(tree_reg, open(filename, 'wb'),protocol=-1)<br/>predictions = tree_reg.predict(X_test) <br/>Score = (tree_reg.score(X_test, y_test))  # It provides the R-Squared Value<br/>print ( "The score of model Decision Tree model is ", round(Score,2))<br/>lin_mse = mean_squared_error(y_test, predictions)<br/>print("MSE of Decision Tree model is ", round(lin_mse,2))<br/>lin_rmse = mean_squared_error(y_test, decision_predictions, squared=False)<br/>print("RMSE of Decision Tree model is ", round(lin_rmse,2))</span></pre><p id="4007" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在本文的下一个系列中，我将讨论不同机器学习算法中的超参数，以及可用于为健壮的机器学习模型确定这些参数的最佳值的选项。</p><p id="9404" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><a class="ae lh" href="https://medium.com/@kaushikthoughts/machine-learning-and-supply-chain-management-1a1d9462eb35" rel="noopener"> <em class="me">机器学习与供应链管理:动手系列#1 </em> </a></p><p id="7820" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在<a class="ae lh" rel="noopener" target="_blank" href="/how-to-identify-the-right-independent-variables-for-machine-learning-supervised-algorithms-439986562d32">上学习结构化方法如何识别机器学习监督算法的正确自变量？</a></p></div></div>    
</body>
</html>