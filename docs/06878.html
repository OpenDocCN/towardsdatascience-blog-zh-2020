<html>
<head>
<title>3.6 million points, 1 GIF — Visualise big data in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">360 万个点，1 个 GIF —用 Python 可视化大数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/create-a-gif-with-3-million-points-using-dask-caf7dcd0667e?source=collection_archive---------29-----------------------#2020-05-28">https://towardsdatascience.com/create-a-gif-with-3-million-points-using-dask-caf7dcd0667e?source=collection_archive---------29-----------------------#2020-05-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a577" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用 Dask 和 Datashader 库用 Python 创建大数据 GIF 的详细分步指南。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b33ce728fe2804526da965901815f34d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*dCLAwcPZhvOa8a9SCiHisA.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">纽约市从 1989 年到 2019 年每年提交的建筑许可证。图片作者。</p></figure><p id="9554" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你好！本文将带您一步一步地创建 GIF 来可视化 Python 中的大数据。gif 是显示随时间变化的好方法，尤其是对于大型数据集。本文使用了过去 30 年纽约市建筑许可证，由建筑部门发布，摘自纽约市开放数据。这张 GIF 是我和我的好朋友雅普·云起于 2019 年秋天在纽约市进行的<a class="ae lu" href="https://leannechan.github.io/Gentrification-Trends-In-NYC/" rel="noopener ugc nofollow" target="_blank">项目</a>的一部分。</p><p id="9738" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">IPython 笔记本和环境文件可以在这里找到:【https://github.com/LeanneChan/create-a-GIF】T4。要下载笔记本并用 Jupyter Notebook 打开，可以关注我的另一篇文章<a class="ae lu" href="https://medium.com/swlh/installing-jupyter-notebook-and-using-your-own-environment-on-mac-fa41efd4639d" rel="noopener">这里</a>。您也可以在 GoogleColab 中运行代码，但是根据过去的经验，在 GoogleColab 中加载 geopandas 库需要额外的步骤。</p><h1 id="bfcc" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">方法</h1><p id="5934" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">GIF 是拼接在一起的图像集合。因此，我们创建 GIF 的方法是为每个不同的时间框架(在本例中为几年)创建单独的图，然后将它们拼接在一起。如果我们的数据集足够小，我们可以使用 matplotlib 来绘制这些点。但是，对于更大的数据集，我们将使用<a class="ae lu" href="https://datashader.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu"> Datashader </strong> </a>，一个用于可视化大数据集的库。为了处理大型数据集，我们将使用<a class="ae lu" href="https://docs.dask.org/en/latest/" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu"> Dask </strong> </a>，这是一个 Python 中灵活的并行计算库。</p><h2 id="36e5" class="ms lw it bd lx mt mu dn mb mv mw dp mf lh mx my mh ll mz na mj lp nb nc ml nd bi translated">数据着色器</h2><p id="a479" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">Datashader 是 HoloViz 家族的一部分(其他包包括 HoloViews、hvPlot)，用于创建大型数据集的表示。它能够通过<em class="ne">光栅化</em>(将一个图分成像素)绘图区域并聚集落在每个像素中的点的值来可视化大型数据集。然后根据该聚合值对像素进行着色。</p><h2 id="2aaf" class="ms lw it bd lx mt mu dn mb mv mw dp mf lh mx my mh ll mz na mj lp nb nc ml nd bi translated">达斯克</h2><p id="3af3" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">Dask 允许我们存储比笔记本电脑内存还大的数据。此外，Dask 使用起来不会太吓人，因为 Dask 数据帧镜像 Pandas，Dask 数组镜像 NumPy。Dask 将作为 Pandas DataFrame 对象的分区分开，只在必要时将数据加载到我们的计算机内存中。</p><h2 id="50b0" class="ms lw it bd lx mt mu dn mb mv mw dp mf lh mx my mh ll mz na mj lp nb nc ml nd bi translated">所需的库</h2><p id="4451" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">dask、datashader、colorcet、matplotlib、numpy、imageio、geopandas</p><h1 id="f308" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">我们开始吧！</h1><h2 id="4168" class="ms lw it bd lx mt mu dn mb mv mw dp mf lh mx my mh ll mz na mj lp nb nc ml nd bi translated">步骤 1:加载施工许可数据</h2><p id="47cf" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">数据集具有 shape (3616003，60)，这意味着有 60 个列/要素和 360 万行/点。这是一个地理空间数据集和可视化，所以每一行代表纽约市的一个点，这是我们想要绘制的。由于有 3.6M 行，我们将需要 dask.dataframe 库。<code class="fe nf ng nh ni b">import</code>用于将库中的库加载到你当前的工作区/会话中，这允许我们使用库中的方法。</p><pre class="kj kk kl km gt nj ni nk nl aw nm bi"><span id="ab89" class="ms lw it ni b gy nn no l np nq">import dask.dataframe as dd</span></pre><p id="5a88" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你以前用过 pandas，语法真的很类似，调用<code class="fe nf ng nh ni b">read_csv</code>读入 dataframe，我从 NYC open data 下载的，保存在我 Jupyter 笔记本的同一个文件夹里，名为‘DOB _ permit _ issuement . CSV’。</p><pre class="kj kk kl km gt nj ni nk nl aw nm bi"><span id="343e" class="ms lw it ni b gy nn no l np nq">permits = dd.read_csv(‘./data/DOB_Permit_Issuance.csv’) permits.head()</span></pre><p id="2764" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，如果<strong class="la iu">您得到下面的错误，</strong>您也将需要寻址具有混合类型的列。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/a7c1fe71222195155d651b043b538a20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9x4ASyHn68otBQXI2PbXWg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">未指定某些列的数据类型时的错误。图片作者。</p></figure><p id="48a6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个例子中，我必须为某些列指定<code class="fe nf ng nh ni b">dtype</code>,因为它们具有混合类型，这在尝试调用 dataframe 时会引发错误。dtype 指定了列中数据的格式，因此当 pandas/dask 不得不猜测太多的列类型时会出现错误。我还使用<code class="fe nf ng nh ni b">usecols</code>只选择了三列，而不是 60 列，以使未来的过程更快。这些栏显示了许可证提交的日期(以便以后提取年份)和许可证的 lat/lng。解决“混合数据类型”问题的另一种方法是只选择有用的、没有混合数据类型的列。事后看来，这是我本可以做的事，以节省自己很多时间！</p><pre class="kj kk kl km gt nj ni nk nl aw nm bi"><span id="70b3" class="ms lw it ni b gy nn no l np nq">permits = dd.read_csv('./data/DOB_Permit_Issuance.csv',<br/>                     dtype={<br/>                         'Lot': 'int64',<br/>                         'Block': 'int64',<br/>                         "Owner's Phone # ": 'float64',<br/>                         "Owner’s House Zip Code": 'float64',<br/>                         "Permittee's License #": 'float64',<br/>                         "Zip Code":'int64' <br/>                     },<br/>                     usecols=['Filing Date', 'LATITUDE', 'LONGITUDE'])</span></pre><p id="2b3c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">显示我们数据帧的前 5 行。(仅供参考，调用<code class="fe nf ng nh ni b">dataframe.head(x)</code>，其中 x 是任意整数，将打印出数据帧的前 x 行！)</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/4c060d8578c8ae0391407d25ae7fa06e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/format:webp/1*0bNhqEL0IZFMBZAXqmYTpg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这是我们将使用的数据帧的前 5 行。图片作者。</p></figure><h2 id="b1ab" class="ms lw it bd lx mt mu dn mb mv mw dp mf lh mx my mh ll mz na mj lp nb nc ml nd bi translated">第二步:数据准备</h2><p id="20dd" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated"><strong class="la iu">首先是</strong>，我们要提取每个许可证的年份。我使用了熊猫函数<code class="fe nf ng nh ni b">to_datetime()</code>，将“提交日期”列转换为日期-时间对象。由于该列现在是一个 datetime 对象，我可以使用另一个函数<code class="fe nf ng nh ni b">.dt.strftime(“%Y”)</code>来访问每个点的年份以创建一个新列。</p><pre class="kj kk kl km gt nj ni nk nl aw nm bi"><span id="871a" class="ms lw it ni b gy nn no l np nq"># change the column type<br/>permits['Filing Date'] = dd.to_datetime(permits['Filing Date'])</span><span id="da1e" class="ms lw it ni b gy nt no l np nq"># create new column for the year<br/>permits=permits.assign(year= permits['Filing Date'].dt.strftime("%Y"))</span></pre><p id="44eb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">其次</strong>，我们需要为我们的坐标决定一个标准化的投影。这是地理空间数据科学中非常重要的一点，因为如果你的底图和你的点在不同的投影和坐标系中，混乱就会随之而来。一个<a class="ae lu" href="https://www.earthdatascience.org/courses/earth-analytics/spatial-data-r/intro-to-coordinate-reference-systems/" rel="noopener ugc nofollow" target="_blank">坐标参考系统(CRS) </a>，是一个代码(epsg 代码)，指的是空间数据(本来就是圆的，因为扁平的地球是一个<em class="ne">骗局</em>)如何被投影到一个扁平的 2D 屏幕上。它还指定了测量单位，通常是英尺、米或十进制度。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/b0e2f45188211a97f36c619cc2aec04d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b6kAPWcOhV0njMjyMtpYfA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:earth data science . org:<a class="ae lu" href="https://www.earthdatascience.org/courses/earth-analytics/spatial-data-r/intro-to-coordinate-reference-systems/" rel="noopener ugc nofollow" target="_blank">https://www . earth data science . org/courses/earth-analytics/spatial-data-r/intro-to-coordinate-reference-systems/</a></p></figure><p id="d39c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于这个例子，我使用了<strong class="la iu"> Web-Mercator 投影(epsg: 3857)，</strong>基于米的投影。虽然在本例中没有这样做，但如果您想使用 OpenStreetMap 或 GoogleMaps 中的底图，这种投影特别有用，因为它们采用 epsg:3857 投影。Datashader 有一个很有用的函数<code class="fe nf ng nh ni b">lnglat_to_meters</code>，可以将经度和纬度(epsg:4326，十进制度数)转换为 web-mercator(米)。<strong class="la iu">确保您知道转换后哪个是您的 lat 和 lng，并按照每个函数中要求的正确顺序对它们进行编码，这一点非常重要。</strong></p><pre class="kj kk kl km gt nj ni nk nl aw nm bi"><span id="2352" class="ms lw it ni b gy nn no l np nq"># conversion to web mercator <br/>from datashader.utils import lnglat_to_meters</span><span id="9235" class="ms lw it ni b gy nt no l np nq"># create new columns 'x' (longitude) and 'y' (latitude)<br/>permits['x'], permits['y'] = lnglat_to_meters(permits['LONGITUDE'], permits['LATITUDE'])</span><span id="b7df" class="ms lw it ni b gy nt no l np nq"># keep a clean dataframe <br/>permits = permits.drop(['LONGITUDE', 'LATITUDE'], axis=1)</span></pre><h2 id="a87f" class="ms lw it bd lx mt mu dn mb mv mw dp mf lh mx my mh ll mz na mj lp nb nc ml nd bi translated">步骤 3:实施 Dask 最佳实践</h2><p id="2f8e" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">我们遵循一些 Dask 最佳实践，将索引设置为我们想要按年份分组的列。尽管使用<code class="fe nf ng nh ni b">set_index</code>需要大约 8 分钟，这使得稍后的子集设置<em class="ne">快了 100 倍</em>(0.001 秒！).</p><pre class="kj kk kl km gt nj ni nk nl aw nm bi"><span id="b6e9" class="ms lw it ni b gy nn no l np nq"># set index so that it is arranged by year <br/># drop na, if not will not be able to set index <br/>permits = permits.dropna()<br/></span><span id="aa86" class="ms lw it ni b gy nt no l np nq"># dataframe will be arranged by year<br/>permits_indexed = permits.set_index('year')<br/>#  set_index takes about 8-9 minutes </span></pre><p id="6468" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">分区:</strong> Dask 通过将大型数据集分割成分区来运行。提到的最佳实践之一是根据您感兴趣的子集(在我们的例子中是年)来设置您的分区。</p><pre class="kj kk kl km gt nj ni nk nl aw nm bi"><span id="58c5" class="ms lw it ni b gy nn no l np nq"># create list of strings of years<br/>dateRange = list(range(1989,2020))<br/>years = []</span><span id="539b" class="ms lw it ni b gy nt no l np nq">for year in dateRange: <br/>    str_year = str(year)<br/>    years.append(str_year)</span><span id="f035" class="ms lw it ni b gy nt no l np nq"># repartition the data - takes 0.001 seconds<br/>permits_repartitioned = permits_indexed.repartition(divisions=years)</span></pre><p id="677c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> Compute: </strong> <code class="fe nf ng nh ni b">.compute()</code>在我们的 Dask 数据帧上执行所有上述过程，并返回一个普通的数据帧。这样做会大大增加创建 GIF 所需的时间。如果此处没有调用<code class="fe nf ng nh ni b">compute()</code>，上述所有数据争论将在 dataframe 的每次调用中重新计算，每帧耗时 10 分钟。那就是 30 帧的<em class="ne"> 300 分钟</em>！</p><pre class="kj kk kl km gt nj ni nk nl aw nm bi"><span id="aa9e" class="ms lw it ni b gy nn no l np nq">permits_computed = permits_repartitioned.compute()</span></pre><p id="a2ef" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这需要<em class="ne"> 9 分钟</em>，但是如上所述，为我们节省了更多的时间。</p><h2 id="678f" class="ms lw it bd lx mt mu dn mb mv mw dp mf lh mx my mh ll mz na mj lp nb nc ml nd bi translated">步骤 4:设置绘图边界</h2><p id="f782" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">从一开始的示例 GIF 开始，这些地块包括纽约市各区的轮廓——曼哈顿、布鲁克林、皇后区、布朗克斯和斯塔滕岛。我从纽约开放数据下载了<a class="ae lu" href="https://data.cityofnewyork.us/City-Government/Borough-Boundaries/tqmj-j8zm" rel="noopener ugc nofollow" target="_blank">形状文件</a>‘行政区边界’。我们将需要<code class="fe nf ng nh ni b">geopandas</code>库来读取 shapefile。不要忘记将 CRS 设置为与您在步骤 2 中用于数据点的 CRS 相同。</p><pre class="kj kk kl km gt nj ni nk nl aw nm bi"><span id="c74c" class="ms lw it ni b gy nn no l np nq"># add NYC borough boundaries (coords must be in 3857)</span><span id="ec99" class="ms lw it ni b gy nt no l np nq">import geopandas as gpd<br/>NYCBoroughs= gpd.read_file("./data/borough boundaries")<br/>NYCBoroughs = NYCBoroughs.to_crs({'init': 'epsg:3857'})</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/8bef5c89f315ebdfe255e60aa2466991.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/1*PLTbsmNJ3QGElw1QL8_HpQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">纽约市行政区的形状。截图自 NYC 公开资料:<a class="ae lu" href="https://data.cityofnewyork.us/City-Government/Borough-Boundaries/tqmj-j8zm" rel="noopener ugc nofollow" target="_blank">https://Data . cityofnewyork . us/City-Government/Borough-Boundaries/tqmj-j8zm</a>。</p></figure><p id="4268" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于我们希望地块也能完美地围绕城市，我们需要将地块上 x 和 y 坐标的范围设置为纽约市的界限，这是我从 GoogleMaps 中的拖放点获得的。再一次，不忘把坐标转换成 epsg: 3857。至于绘图尺寸，我建议你先摆弄那些图形，然后在画布上绘图(见下一节),看看什么最适合你。</p><pre class="kj kk kl km gt nj ni nk nl aw nm bi"><span id="3766" class="ms lw it ni b gy nn no l np nq"># NYC limits - lng(east/west) and lat(north/south)<br/>NYC        = (( -74.25,  -73.7), (40.50, 40.92)) <br/>x_range, y_range = [list(r) for r in lnglat_to_meters(NYC[0], NYC[1])]</span><span id="7c34" class="ms lw it ni b gy nt no l np nq"># plot dimensions<br/>plot_width  = int(750)<br/>plot_height = int(plot_width//1.2)</span></pre><h2 id="2674" class="ms lw it bd lx mt mu dn mb mv mw dp mf lh mx my mh ll mz na mj lp nb nc ml nd bi translated">步骤 5:创建图像</h2><p id="240e" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">至此，我们已经拥有了制作 GIF 所需的所有部分，我们只需要把它们放在一起！首先，我们需要导入一些库来帮助我们绘图。正如在“方法”中提到的，我们将在绘图前使用 datashader 来聚合点。我们不只是想要地图上的点，而是让地图告诉我们哪里有更高频率的点。Datashader 将在此基础上帮助我们给点着色。</p><pre class="kj kk kl km gt nj ni nk nl aw nm bi"><span id="5754" class="ms lw it ni b gy nn no l np nq"># plotting functions<br/>from colorcet import fire <br/>import datashader as ds<br/>import datashader.transfer_functions as tf</span></pre><p id="071f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们创建一个助手函数来绘制施工许可证，我们可以在以后绘制每年的不同点时使用它。</p><p id="f661" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">该函数接受参数:<br/> </strong> df —数据，<br/> x_range，y_range—底座上 x/y 坐标的范围(见步骤 3)，<br/> w/h —绘图的宽度和高度(见步骤 3)，<br/> cmap —用于给点着色的彩色地图。</p><pre class="kj kk kl km gt nj ni nk nl aw nm bi"><span id="8824" class="ms lw it ni b gy nn no l np nq">def create_image(df, x_range, y_range, w=plot_width, h=plot_height, cmap=fire):<br/>    <br/>    # create the canvas<br/>    cvs = ds.Canvas(plot_width=w, plot_height=h, x_range=x_range, y_range=y_range)<br/>    <br/>    # the construction permits, aggregated by their count<br/>    agg = cvs.points(df, 'x', 'y')<br/>    <br/>    # shade the pixels <br/>    img = tf.shade(agg, cmap=cmap, how='eq_hist')<br/>    <br/>    # return a PIL image<br/>    return tf.set_background(img, "black").to_pil()</span></pre><p id="8cbe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该函数使用<strong class="la iu"> datashader 的 canvas 函数<em class="ne"> </em> </strong>来表示我们要在其中绘制点的空间。首先，我们创建画布，指定尺寸。接下来，我们使用<code class="fe nf ng nh ni b">cvs.points()</code>输入数据，它接收数据，‘x’—转换后的经度，和‘y’—转换后的纬度。<code class="fe nf ng nh ni b">cvs</code>是在第一行创建的画布对象。</p><p id="7cc0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">聚合数据<br/> </strong>您可以在<code class="fe nf ng nh ni b">cvs.points()</code>中指定的另一个参数是<code class="fe nf ng nh ni b">agg</code>，它将通知 datashader 如何聚合您的数据。假设你有一个名为“z”的第三列，如果你想在这个聚合空间中绘制 z 的平均值，你可以包括<code class="fe nf ng nh ni b">agg=ds.mean('z')</code>。如果没有指定，<code class="fe nf ng nh ni b">agg</code>的缺省值是‘count ’,这是我们在这个例子中想要的，因此没有指定。</p><p id="8e59" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，<code class="fe nf ng nh ni b">datashader.transfer_functions.shade</code>指定如何给每个像素着色。我们使用的色图是火，来自<code class="fe nf ng nh ni b">colorcet</code>库。<code class="fe nf ng nh ni b">how</code>指定颜色图的比例。一些选项包括:' eq _ hist '[默认值]，' cbrt '(立方根)，' log '(对数)和'线性'。有关更多信息，请参见结尾链接的 datashader 文档。然后，我们将背景指定为黑色，并将图像转换为 Python 图像库(PIL)格式。</p><h2 id="9050" class="ms lw it bd lx mt mu dn mb mv mw dp mf lh mx my mh ll mz na mj lp nb nc ml nd bi translated">步骤 6:每年绘图的函数</h2><p id="dff3" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">我们快完成了！我们不想为每个时间帧手动创建新图像，所以我们将其打包在另一个函数中。对于这个函数，我们将需要 matplotlib 的 pyplot 来设置轴，并需要 numpy 来将图形值转换到范围 0–255(dtype = uint 8)以创建最终的图像。</p><pre class="kj kk kl km gt nj ni nk nl aw nm bi"><span id="a4cb" class="ms lw it ni b gy nn no l np nq">from matplotlib import pyplot as plt<br/>import numpy as np </span></pre><p id="45d0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">该函数接受参数:<br/> </strong> fig—来自 pyplot，<br/> all_data —我们的数据框架，<br/> year —要绘制的具体年份，<br/> city_limits —要绘制的边界的 shapefile，<br/> x_range，y_range —基底上 x/y 坐标的范围(见步骤 3)。</p><pre class="kj kk kl km gt nj ni nk nl aw nm bi"><span id="78d0" class="ms lw it ni b gy nn no l np nq">def plot_permits_by_year(fig, all_data, year, city_limits, x_range, y_range):</span><span id="c6bb" class="ms lw it ni b gy nt no l np nq">    # trim to the specific year<br/>    df_this_year = all_data.loc[year]</span><span id="5048" class="ms lw it ni b gy nt no l np nq">    # create the datashaded image<br/>    img = create_image(df_this_year, x_range, y_range)</span><span id="7b70" class="ms lw it ni b gy nt no l np nq">    # plot the image on a matplotlib axes<br/>    plt.clf() # this clears current figure<br/>    ax = fig.gca() # this gets the axes from fig<br/>    ax.imshow(img, extent=[x_range[0], x_range[1], y_range[0], y_range[1]]) # show the image on the axes<br/>    ax.set_axis_off() <br/>    <br/>    # plot the city limits (NYC borough boundaries)<br/>    city_limits.plot(ax=ax, facecolor="none", edgecolor="white")</span><span id="bcf1" class="ms lw it ni b gy nt no l np nq">    # add a text label for the year<br/>    ax.text(<br/>        0.0,<br/>        0.9,<br/>        "Yearly Construction Permits\nFiled in NYC",<br/>        color="white",<br/>        fontsize=20,<br/>        ha="left",<br/>        transform=ax.transAxes,<br/>    )</span><span id="4709" class="ms lw it ni b gy nt no l np nq">    ax.text(<br/>        0.7,<br/>        0.1,<br/>        year,<br/>        color="white",<br/>        fontsize=40,<br/>        ha="left",<br/>        transform=ax.transAxes,<br/>    )</span><span id="3fb0" class="ms lw it ni b gy nt no l np nq">    # draw the figure and return the image<br/>    fig.canvas.draw()<br/>    image = np.frombuffer(fig.canvas.tostring_rgb(), dtype="uint8")<br/>    image = image.reshape(fig.canvas.get_width_height()[::-1] + (3,))</span><span id="453e" class="ms lw it ni b gy nt no l np nq">    return image</span></pre><p id="b8ae" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用<code class="fe nf ng nh ni b">loc</code>对我们的数据进行子集划分只需要 0.001 秒。</p><p id="c415" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该函数还指定要在每一帧上显示的文本，这是使用 matplotlib 函数<code class="fe nf ng nh ni b">ax.text()</code>完成的，其中<code class="fe nf ng nh ni b">ax</code>指的是图像的轴。</p><h2 id="d249" class="ms lw it bd lx mt mu dn mb mv mw dp mf lh mx my mh ll mz na mj lp nb nc ml nd bi translated">第七步:把图片做成 GIF！</h2><p id="7ddd" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated"><strong class="la iu">我们就在最后，</strong>我们只需要使用<code class="fe nf ng nh ni b">imageio</code>库将图像数组转换成 gif。为了创建 GIF，我们使用步骤 5 中的函数创建图像，将它们附加到一个数组中，然后使用<code class="fe nf ng nh ni b">image.io</code>将它们拼接成一个 GIF。</p><pre class="kj kk kl km gt nj ni nk nl aw nm bi"><span id="7b94" class="ms lw it ni b gy nn no l np nq"># library to create GIF <br/>import imageio</span></pre><p id="8147" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">运行下面的块代码来创建完整的 GIF！如果您对设计不满意，请在步骤 5 的功能中更改参数(如标签的位置/颜色/尺寸)。<em class="ne">(参见 matplotlib 文档)</em> <br/> <em class="ne">注</em>:‘years’数组是在第 3 步分区过程中创建的。</p><pre class="kj kk kl km gt nj ni nk nl aw nm bi"><span id="794d" class="ms lw it ni b gy nn no l np nq"># create a figure<br/>fig, ax = plt.subplots(figsize=(10,10), facecolor='black')</span><span id="ca51" class="ms lw it ni b gy nt no l np nq"># Create an image for each hour<br/>imgs = []<br/>for year in years:<br/>    print('processing ' + year + ' ...')<br/>    img = plot_permits_by_year(fig, permits_computed, year, NYCBoroughs, x_range=x_range, y_range=y_range)<br/>    imgs.append(img)<br/>      <br/># Combining the images for each hour into a single GIF<br/>imageio.mimsave('1989_2019_permits.gif', imgs, fps=1)</span></pre><p id="b08c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这段创建 30 帧的代码块仅用了<em class="ne"> 9.56463 秒</em>运行！</p><p id="14a6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">就是这样！</strong>谢谢你的关注，如果我能澄清什么，请告诉我！</p></div><div class="ab cl nw nx hx ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="im in io ip iq"><p id="b4bc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="ne">过去的编辑和关于时间复杂性的附加信息<br/></em><strong class="la iu">2020 年 5 月 30 日</strong> —更改流程以加快子集设置，并调用<code class="fe nf ng nh ni b">.compute()</code>以减少 Dask 操作。(当前文章反映了正确的代码。)</p><p id="af3d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在初始过程中(代码不再显示)，我跳过了第 3 步，在 plot_by_year 函数中设置了数据帧的子集。因此，打印每年的框架大约需要 10 分钟。这也是因为由于 Dask 的性质，每次调用 dataframe 时，数据集上的数据争论都会重复。我的直觉是，在每次调用 plot_by_year 函数时，必须再次执行将坐标转换为墨卡托坐标、转换“归档日期”列和设置数据框子集的过程。在 Dask 数据帧上调用<code class="fe nf ng nh ni b">compute()</code>解决了这个重复问题。</p><p id="6541" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了检查花费的时间，我使用了<code class="fe nf ng nh ni b">time</code>图书馆。</p><p id="66cf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="ne">子集花费的时间:旧方法</em></p><pre class="kj kk kl km gt nj ni nk nl aw nm bi"><span id="6432" class="ms lw it ni b gy nn no l np nq">start=time.time()<br/>df_this_year = permits.loc[permits["Filing Date"].dt.strftime("%Y") == '2009'].compute()<br/>print(time.time()-start)</span><span id="f82f" class="ms lw it ni b gy nt no l np nq"># 616.4123058319092 seconds</span></pre><p id="1be9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="ne">子集花费的时间:新方法</em></p><pre class="kj kk kl km gt nj ni nk nl aw nm bi"><span id="5bf1" class="ms lw it ni b gy nn no l np nq">start = time.time()<br/>permits_2009 = computed_repartitioned.loc['2009']<br/>print(time.time()-start)</span><span id="e617" class="ms lw it ni b gy nt no l np nq"># 0.0010952949523925781 seconds</span></pre><p id="6259" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个新过程是对我花了几个小时创建 GIF 的原始代码的巨大改进！感谢<a class="ae lu" href="https://medium.com/@james.a.bednar" rel="noopener"> @james.a.bednar </a>为改进原代码所做的小小额外推动！</p></div><div class="ab cl nw nx hx ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="im in io ip iq"><p id="88ad" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">致谢:<br/> </strong> Nicholas Hand，MUSA 620 教授，他教会了我大部分的 python 数据可视化技巧！</p><p id="4303" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">数据来源:<br/> </strong>建筑许可证，纽约市公开数据，建筑署<a class="ae lu" href="https://data.cityofnewyork.us/Housing-Development/DOB-Permit-Issuance/ipu4-2q9a" rel="noopener ugc nofollow" target="_blank">https://Data . cityofnewyork . us/Housing-Development/DOB-Permit-issued/IPU 4-2q9a</a></p><p id="0851" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">纽约市行政区边界，纽约市公开数据，城市规划部<a class="ae lu" href="https://data.cityofnewyork.us/City-Government/Borough-Boundaries/tqmj-j8zm" rel="noopener ugc nofollow" target="_blank">https://Data . cityofnewyork . us/City-Government/Borough-Boundaries/tqmj-j8zm</a></p><p id="17d5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> Datashader 文档:</strong><a class="ae lu" href="https://readthedocs.org/projects/datashader/downloads/pdf/stable/" rel="noopener ugc nofollow" target="_blank">https://readthedocs . org/projects/data shader/downloads/pdf/stable/</a></p></div></div>    
</body>
</html>