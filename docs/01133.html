<html>
<head>
<title>Using Stringr and Regex to Extract Features from Textual and Alphanumeric Data in R</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Stringr和Regex从R中的文本和字母数字数据中提取特征</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/using-stringr-and-regex-to-extract-features-from-textual-alphanumeric-and-punctuation-data-in-r-2565256c0a77?source=collection_archive---------18-----------------------#2020-02-01">https://towardsdatascience.com/using-stringr-and-regex-to-extract-features-from-textual-alphanumeric-and-punctuation-data-in-r-2565256c0a77?source=collection_archive---------18-----------------------#2020-02-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8421" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Titanic数据集的特征提取教程</h2></div><p id="d39b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">大型数据集通常充斥着难以破译的数据。人们可能会想到文本数据、名称、唯一标识符和其他种类的代码。通常，分析这些数据集的人会很快丢弃这些变量。然而，有时这种类型的数据中可能有有价值的信息，这可能有助于您的分析。</p><p id="69d4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">很高兴地，R提供了惊人的包“stringr”，它非常适合这些目的。本快速教程将向您展示如何从这些变量中提取微小但仍有洞察力的数据。在这种情况下，我们将从Titanic数据集提取这种数据。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/af683f51727a64d2ed87a6dcde7c9f84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kVRErcDn5y1gNn8M"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">美国国家海洋和大气管理局在<a class="ae lu" href="https://unsplash.com/s/photos/titanic?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><h1 id="bc5c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">加载数据集</h1><p id="3d48" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">如果你想跟随教程，使用下面的命令加载Titanic数据集。泰坦尼克号数据集以泰坦尼克号乘客的各种信息为特色，以练习预测他们的生存。本教程旨在研究一些大多数人在开始分析时会立即丢弃的变量(如姓名和票证)。然而，我们希望与他们合作，看看我们是否能提取一些有用的信息。如果您想知道如何使用Stringr和regex，请跳过这一部分。</p><pre class="lf lg lh li gt ms mt mu mv aw mw bi"><span id="a46a" class="mx lw it mt b gy my mz l na nb">### install package<br/>install.packages("titanic")</span><span id="9b77" class="mx lw it mt b gy nc mz l na nb">### load package<br/>library(titanic)</span><span id="f239" class="mx lw it mt b gy nc mz l na nb">### load dataset<br/>df = titanic_train #load dataset</span></pre><h1 id="7868" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">安装和加载字符串</h1><p id="4996" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">在开始之前，我们需要安装和加载Stringr包。</p><pre class="lf lg lh li gt ms mt mu mv aw mw bi"><span id="c342" class="mx lw it mt b gy my mz l na nb">### install package<br/>install.packages("stringr")</span><span id="5e5a" class="mx lw it mt b gy nc mz l na nb">### load package<br/>library(stringr)</span></pre><p id="cc06" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，我们都准备好了，可以开始了。</p><h1 id="f841" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">从名称中提取标题</h1><p id="63f4" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">作为第一个练习，我想从名字中提取标题。这是因为我相信，比如说，贵族比凡人更有可能生存下来。还有，我假设年轻的未婚女性(“小姐”)更有可能活下来。可能，标题中可能有很多信息。</p><p id="b7c9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">titanic数据集中的名称(df$Name)都是这样保存的:</p><blockquote class="nd"><p id="d8f2" class="ne nf it bd ng nh ni nj nk nl nm ld dk translated">Futrelle，夫人雅克希思(莉莉可能皮)</p></blockquote><p id="8303" class="pw-post-body-paragraph ki kj it kk b kl nn ju kn ko no jx kq kr np kt ku kv nq kx ky kz nr lb lc ld im bi translated">为了避免任何错误，我们首先要运行一个命令，将所有这些字符串转换成小写，并保存为新变量:</p><pre class="lf lg lh li gt ms mt mu mv aw mw bi"><span id="0954" class="mx lw it mt b gy my mz l na nb">df$lcName = str_to_lower( df$Name )</span></pre><p id="6bde" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">标题(上例中的Mrs)前面有一个空格，前面有一个点。我们可以使用regex(正则表达式)作为一种语言，将这种模式传递给Stringr，并要求它以如下方式查找标题:</p><blockquote class="nd"><p id="20d0" class="ne nf it bd ng nh ni nj nk nl nm ld dk translated">(?&lt;=\\s)[[:alpha:]]+(?=\\.)</p></blockquote><p id="24ca" class="pw-post-body-paragraph ki kj it kk b kl nn ju kn ko no jx kq kr np kt ku kv nq kx ky kz nr lb lc ld im bi translated">This pattern consists of three parts:</p><ol class=""><li id="1678" class="ns nt it kk b kl km ko kp kr nu kv nv kz nw ld nx ny nz oa bi translated"><strong class="kk iu">(？&lt; =\\s) </strong>告诉Stringr我们要寻找的文本段在(？由空格(\\s)分隔。</li><li id="4f83" class="ns nt it kk b kl ob ko oc kr od kv oe kz of ld nx ny nz oa bi translated"><strong class="kk iu"> [[:alpha:]]+ </strong>告诉Stringr我们要寻找的文本由一个或多个(+)字母([[:alpha:]])组成。</li><li id="a2c1" class="ns nt it kk b kl ob ko oc kr od kv oe kz of ld nx ny nz oa bi translated"><strong class="kk iu">(？=\\.)</strong>告诉Stringr我们要找的那段文本已经开始(？=)加一个点(\\。).</li></ol><p id="676c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可以看到regex使用了各种符号来交流模式。当你想开发自己的模式时，<a class="ae lu" href="http://edrub.in/CheatSheets/cheatSheetStringr.pdf" rel="noopener ugc nofollow" target="_blank"> Stringr备忘单</a>是一个有用的指南。<a class="ae lu" href="https://www.regextester.com/" rel="noopener ugc nofollow" target="_blank">这个网站</a>提供了一个测试正则表达式模式的简单方法。</p><p id="222d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们提取标题，并通过让Stringr在小写的“Name”字符串中查找这个模式，将其保存为一个新变量。</p><pre class="lf lg lh li gt ms mt mu mv aw mw bi"><span id="cb5a" class="mx lw it mt b gy my mz l na nb">df$title = str_extract( df$lcName, "(?&lt;=\\s)[[:alpha:]]+(?=\\.)" )</span></pre><p id="ca59" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们使用Ggplot2和下面的命令来绘制我们的新变量“title”。</p><pre class="lf lg lh li gt ms mt mu mv aw mw bi"><span id="bd03" class="mx lw it mt b gy my mz l na nb">### install package (ggplot2 is a must have)<br/>install.packages("ggplot2")</span><span id="40e8" class="mx lw it mt b gy nc mz l na nb">### load package<br/>library(ggplot2)</span><span id="5e49" class="mx lw it mt b gy nc mz l na nb">### plot titles<br/>ggplot(data.frame(table(df$title)),aes(x=reorder(Var1, -Freq),y=Freq))+<br/>  geom_col()+<br/>  labs(title="Count of Title", x="Title",y="Count")</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi og"><img src="../Images/638b76186083a4e1ad69bdbbd2f28a87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FqR9xLS6bPZ6KnRvZn_1vw.png"/></div></div></figure><p id="e85e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以看到，Stringr很好地从名称中提取了所有的标题，现在我们有了一个新的分类变量，可以用作我们分析的输入。</p><h1 id="b69f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">从名称中提取族</h1><p id="21e8" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">作为第二个练习，我想从names字符串中提取姓氏。我相信家庭成员可能是生存的一个预测因素，也就是说，如果一个家庭成员存活，在控制了性别等其他因素后，其他成员也更有可能存活。</p><p id="d92d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的示例“name”字符串中，您可以看到这个人的姓，例如Futrelle，是第一个单词。所以我们可以告诉Stringr获取第一个匹配模式([[:alpha:]]+)的单词(str_extract)并获取第一个单词，这就是family。</p><p id="d36b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，数据集中有姓氏，如“范德·普兰克”或“奥德怀尔”如果我们在这种情况下取第一个单词，我们只会得到“vander”或“o”，而不是整个家族的名字。因此，我们需要修改模式以包含任何类型的字符(。)长度为1个字符以上，后跟一个逗号(？=\\,).</p><pre class="lf lg lh li gt ms mt mu mv aw mw bi"><span id="a33e" class="mx lw it mt b gy my mz l na nb">df$family=str_extract(df$lcName,".+(?=,)")</span></pre><p id="e7a6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这一次，因为我们有很多姓，所以让我们画出10个最常用的姓。</p><pre class="lf lg lh li gt ms mt mu mv aw mw bi"><span id="9222" class="mx lw it mt b gy my mz l na nb">t=data.frame(table(df$family))</span><span id="1dc6" class="mx lw it mt b gy nc mz l na nb">t=t[order(-t$Freq),]</span><span id="b487" class="mx lw it mt b gy nc mz l na nb">ggplot(head(t,10),aes(x=reorder(Var1,-Freq),y=Freq))+<br/>  geom_col()+<br/>  labs(title="Count of Family Name", x="Title",y="Family Name")</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi oh"><img src="../Images/c4885db258f1845fc7c6483a4244d91e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YRA8b8k44Dm5lNGWqfhXWg.png"/></div></div></figure><p id="0b80" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，我们现在有了新的变量“family name”，我们可以使用它进行进一步的分析。</p><h1 id="aad9" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">从票中提取信息</h1><p id="bf8a" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">在大多数对泰坦尼克号数据集的分析中，人们很快就丢弃了船票信息。然而，机票代码中的一些字母可能意味着什么。例如，它们可以表示票是最后一分钟购买的，并且乘客没有为航行做好充分准备。</p><p id="a679" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，这些缩写和代码的写法不一致(例如，“SOC”和“S.o.C .”)，这就是为什么这些数据需要一些准备工作。让我们打扫它。</p><pre class="lf lg lh li gt ms mt mu mv aw mw bi"><span id="647f" class="mx lw it mt b gy my mz l na nb">### set ticket codes to lowercase<br/>df$lcTicket=str_to_lower(df$Ticket)</span><span id="514a" class="mx lw it mt b gy nc mz l na nb">### remove punctuation from ticket codes<br/>df$lcTicket=str_replace_all(df$lcTicket,"[:punct:]","")</span></pre><p id="7112" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们已经清理了一些数据，让我们提取这些缩写。通常，机票代码看起来像这样:</p><blockquote class="nd"><p id="cadc" class="ne nf it bd ng nh ni nj nk nl nm ld dk translated">索托诺2 3101287</p></blockquote><p id="446f" class="pw-post-body-paragraph ki kj it kk b kl nn ju kn ko no jx kq kr np kt ku kv nq kx ky kz nr lb lc ld im bi translated">在我看来，“sotono 2”是一个首字母缩写词，可能意味着什么，“3101287”是一些机票号码(我稍后会详细介绍)。如果我们考虑缩写词的模式，它是字符(。)后面跟一个空格(\\s)，空格后面跟一个三位数或更长的数字([[:digit]])({ 3，})。有时，整个机票代码是一些首字母缩写词(例如，一个乘客将“line”作为机票)，这意味着我们可以给Stringer另一个选项(“|”是“or”运算符)，即整个代码是感兴趣的首字母缩写词([[:alpha:]]+)。我们使用下面的命令告诉Stringr查找这个模式，并将其保存在一个新变量“ticketinfo”中。然后，我们删除空白并替换NA值。</p><pre class="lf lg lh li gt ms mt mu mv aw mw bi"><span id="0635" class="mx lw it mt b gy my mz l na nb">### identify acronym<br/>df$Ticketinfo = str_extract( df$lcTicket, ".+(?=\\s(?=[[:digit:]]{3,}))|[[:alpha:]]+" )</span><span id="a965" class="mx lw it mt b gy nc mz l na nb">### remove whitespaces from ticketinfo<br/>df$Ticketinfo = str_replace_all( df$Ticketinfo, "\\s", "" )</span><span id="74b7" class="mx lw it mt b gy nc mz l na nb">### remove NA values<br/>df$Ticketinfo = ifelse( is.na(df$Ticketinfo), "none", df$Ticketinfo )</span></pre><p id="9992" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们再次绘制10个最常见的ticketinfo值。</p><pre class="lf lg lh li gt ms mt mu mv aw mw bi"><span id="b2f5" class="mx lw it mt b gy my mz l na nb">t=data.frame(table(df$Ticketinfo[df$Ticketinfo!="none"]))</span><span id="2eb5" class="mx lw it mt b gy nc mz l na nb">t=t[order(-t$Freq),]</span><span id="8213" class="mx lw it mt b gy nc mz l na nb">ggplot(head(t,10),aes(x=reorder(Var1,-Freq),y=Freq))+<br/>  geom_col()+<br/>  labs(title="Count of Ticketinfo Acronym", x="Ticketinfo Acronym",y="Count")</span></pre><p id="0210" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可以看到这对许多乘客来说增加了相当多的信息。将近60名乘客的值为“PC”在检查数据后，我相信它可能意味着“私人客舱”，因为许多(但不是所有)头等舱乘客的机票上都印有这个值。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi oi"><img src="../Images/4a2f9efda01486c4c896c1204238f670.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TwwC8EKqFBvrLzF8YnT7Bg.png"/></div></div></figure><h1 id="6099" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">从机票号码中提取免费升级</h1><p id="fb9f" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">关于泰坦尼克号命运多舛的处女航，有趣的是船只有一半的容量。这艘船本可以轻而易举地运送更多的乘客横渡大西洋。这让我想到一些乘客可能已经“免费”升级到了更高的舱位。对机票号码的初步检查显示，第一个数字似乎与乘客等级(Pclass)相关，但也有例外。我假设第一个数字可以携带一些关于阶级变化的信息，这将对乘客的生存概率产生深远的影响。让我们提取首字母缩写词后的数字的第一个数字，并将其保存为假定的乘客类别(PresumedPclass)。</p><p id="7b59" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们先提取一下票号。同样，票号由数字([[:digit:]])组成，长度为3个或更多字符({3，})。让我们也将它存储为一个字符(as.character)，而不是一个数字，以便仍然对它使用Stringr。</p><pre class="lf lg lh li gt ms mt mu mv aw mw bi"><span id="f19f" class="mx lw it mt b gy my mz l na nb">df$Ticketno = as.character( str_extract( df$lcTicket, "[[:digit:]]{3,}" ))</span></pre><p id="6651" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么我们就取这个票号的第一个数字([[:digit:]])存储为推定的旅客类别。</p><pre class="lf lg lh li gt ms mt mu mv aw mw bi"><span id="87a8" class="mx lw it mt b gy my mz l na nb">df$PresumedPclass = str_extract( as.character(df$Ticketno) ,"[[:digit:]]{1}")</span></pre><p id="c634" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，让我们再次绘制这个新变量，但是让我们在所提供的乘客类的上下文中绘制它，看看它是如何相关的。</p><pre class="lf lg lh li gt ms mt mu mv aw mw bi"><span id="85d2" class="mx lw it mt b gy my mz l na nb">ggplot(df, aes(x=Pclass, fill=PresumedPclass))+<br/>  geom_bar()+<br/>  labs(title="Count of Passenger Class", x="Passenger Class",y="Count")+<br/>  scale_fill_discrete(name="Presumed Passenger Class")</span></pre><p id="6106" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们在下图中看到的，这两个值大部分是相关的。但有时他们不会。在这两个类别不匹配的情况下，这可能是令人兴奋的信息。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi oj"><img src="../Images/bb111c5997b6c739558fd0bef018272e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-TK9ZJXESXxDuNJ_bRGAzw.png"/></div></div></figure></div><div class="ab cl ok ol hx om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="im in io ip iq"><h2 id="61ba" class="mx lw it bd lx or os dn mb ot ou dp mf kr ov ow mh kv ox oy mj kz oz pa ml pb bi translated">进一步阅读</h2><p id="7182" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">您想了解更多信息吗？<a class="ae lu" href="https://medium.com/@mattifuchs" rel="noopener">在Medium上关注我</a>看我的其他故事！</p></div></div>    
</body>
</html>