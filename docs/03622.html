<html>
<head>
<title>Parallel API connections in R</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">R中的并行API连接</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/parallel-web-scraping-and-api-connection-a-way-to-save-lots-of-time-part-i-r-bf740f6cfbd0?source=collection_archive---------39-----------------------#2020-04-05">https://towardsdatascience.com/parallel-web-scraping-and-api-connection-a-way-to-save-lots-of-time-part-i-r-bf740f6cfbd0?source=collection_archive---------39-----------------------#2020-04-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="63d2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">节省大量时间的方法。</h2></div><p id="aabf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建新数据集是数据科学家和分析师目前面临的挑战之一。创建数据集的一种流行方式是网上冲浪，并根据需要从不同的网站收集信息。但是您可能知道，这非常耗时，因此在不使用多个虚拟机或集群的情况下加速这一过程是您的数据科学家工具集的一部分。在这里，我们将深入探讨如何使用r进行并行API连接。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="f4bd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个关于如何使用并行计算的简单指南。这个想法是，你的计算机的每个线程/工作者/核心使用不同的连接来访问网络，因此，你不需要等待API响应或动态网站的加载来开始抓取另一个。只需将简单的命令添加到代码中，并以巧妙的方式包装它，就可以加快速度，节省大量时间。</p><h1 id="70cc" class="li lj iq bd lk ll lm ln lo lp lq lr ls jw lt jx lu jz lv ka lw kc lx kd ly lz bi translated">并行API连接</h1><p id="e1a6" class="pw-post-body-paragraph kf kg iq kh b ki ma jr kk kl mb ju kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">我们将从并行使用R和API连接开始。这将允许我们更有效地下载信息，就像在你的网络浏览器中打开多个标签一样。对于我们的例子，我们将使用<a class="ae mf" href="http://www.omdbapi.com/" rel="noopener ugc nofollow" target="_blank"> OMDB API </a>。这个API让您可以访问许多关于电影的信息，对于我们的测试，我们使用了Poster API来下载电影海报并将其保存在本地，以便我们可以在以后处理它们。</p><h2 id="cb5b" class="mg lj iq bd lk mh mi dn lo mj mk dp ls ko ml mm lu ks mn mo lw kw mp mq ly mr bi translated">1.-加载库</h2><p id="a15b" class="pw-post-body-paragraph kf kg iq kh b ki ma jr kk kl mb ju kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">第一步是加载所有需要的库。对于并行设置我们的代码，我们将使用，<em class="ms"> future。</em>这个库设置了我们将要使用的并行方法。对于并行功能，我们选择，<em class="ms"> furr </em>包。这个包是<em class="ms"> purrr </em>包的未来版本。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="8344" class="mg lj iq my b gy nc nd l ne nf">library(RCurl)<br/>library(curl)<br/>library(future)<br/>library(furrr)</span></pre><h2 id="7b4e" class="mg lj iq bd lk mh mi dn lo mj mk dp ls ko ml mm lu ks mn mo lw kw mp mq ly mr bi translated">2.-创建一个函数</h2><p id="504a" class="pw-post-body-paragraph kf kg iq kh b ki ma jr kk kl mb ju kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">其次，我们需要创建一个新功能。这个函数将是我们进行API连接和下载的地方。在这里，我们可以将API连接代码更改为web抓取代码。</p><p id="9087" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了演示如何做，该函数将打开一个与Poster API的<em class="ms"> curl </em>连接，并将一个图像下载到一个名为<em class="ms"> images </em>的新目录中。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="aea7" class="mg lj iq my b gy nc nd l ne nf">imgAPI &lt;- '<a class="ae mf" href="http://img.omdbapi.com/?apikey=9c9e16a&amp;i=tt'" rel="noopener ugc nofollow" target="_blank">http://img.omdbapi.com/?apikey=<em class="ms">[your-own-api-key]</em>'</a><br/>rootDir &lt;- 'images/'<br/>get_img &lt;- function(id){<br/>  url &lt;- paste0(imgAPI,str_pad(id, 7, pad = "0"))<br/>  if(url.exists(url)){<br/>    curl_download(url = url ,destfile = paste0(rootDir,'tt',id,'.png'))<br/>  }<br/>}</span></pre><p id="8d44" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用并行连接和传统的并行处理之间的一个区别是，您几乎可以肯定您的代码能够并行运行，因为通常连接本质上是独立的。</p><h2 id="f82e" class="mg lj iq bd lk mh mi dn lo mj mk dp ls ko ml mm lu ks mn mo lw kw mp mq ly mr bi translated">3.-在所有连接上运行future_map</h2><p id="2263" class="pw-post-body-paragraph kf kg iq kh b ki ma jr kk kl mb ju kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">最后，我们需要在我们的链接列表上运行我们之前创建的函数。为了实现这一点，我们使用了<em class="ms"> future_map </em>，一个并行版本的map函数。这就是并行连接发生的地方。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="0d3e" class="mg lj iq my b gy nc nd l ne nf">#load file with list of movie ids to create API links<br/>links &lt;- read_csv('links.csv')</span><span id="4cab" class="mg lj iq my b gy ng nd l ne nf">future_map(links,get_img)</span></pre><p id="2b1d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">重要</strong>:为了让我们的代码知道它需要并行运行，我们需要告诉它如何去做，以及它应该使用多少个不同的内核。未来库中有两个函数允许我们这样做:<em class="ms">【可用资源()</em> &amp; <em class="ms">【计划()</em>。第一个读取关于我们的计算机有多少内核的信息，第二个告诉代码有多少内核以及如何并行化<em class="ms">未来的</em>功能。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="40f0" class="mg lj iq my b gy nc nd l ne nf">n_cores &lt;- availableCores() - 1<br/>plan(multiprocess, workers = cores)</span></pre><p id="7315" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为不属于您代码的其他计算机进程留出一个空闲的内核总是一个好的做法。</p><h2 id="7f27" class="mg lj iq bd lk mh mi dn lo mj mk dp ls ko ml mm lu ks mn mo lw kw mp mq ly mr bi translated">4.-测试和结果</h2><p id="9999" class="pw-post-body-paragraph kf kg iq kh b ki ma jr kk kl mb ju kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">使用之前定义的代码，我们将运行一个小测试，看看这些并行连接如何提高我们的下载速度。对于该测试，我们使用4种不同的配置:</p><ul class=""><li id="31ca" class="nh ni iq kh b ki kj kl km ko nj ks nk kw nl la nm nn no np bi translated">完全没有平行，使用正常的<em class="ms">映射</em>功能。</li><li id="1ac4" class="nh ni iq kh b ki nq kl nr ko ns ks nt kw nu la nm nn no np bi translated">多重处理计划和设置3个核心。</li><li id="0401" class="nh ni iq kh b ki nq kl nr ko ns ks nt kw nu la nm nn no np bi translated">多重处理计划和设置5个核心。</li><li id="5efd" class="nh ni iq kh b ki nq kl nr ko ns ks nt kw nu la nm nn no np bi translated">多重处理计划和设置7个核心。</li></ul><p id="c2e9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">内核数量是根据8个内核的机器选择的，至少有1个内核空闲。</p><p id="4124" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了进行测试，我们在3个不同的场景中运行每个配置，以检查卷如何影响性能。这些场景基于我们将要下载的电影海报数量(500，1000，2500)。在每个场景中，我们运行5次，取下载所有电影的平均时间。</p><p id="da27" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果如下图所示。</p><figure class="mt mu mv mw gt nw gh gi paragraph-image"><div role="button" tabindex="0" class="nx ny di nz bf oa"><div class="gh gi nv"><img src="../Images/36c7e52512ae6f9848d2a200df49dd60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rcZi8-CYmJ-YimY_OKkCBw.jpeg"/></div></div><p class="od oe gj gh gi of og bd b be z dk translated">作者图片</p></figure><h1 id="ab6e" class="li lj iq bd lk ll lm ln lo lp lq lr ls jw lt jx lu jz lv ka lw kc lx kd ly lz bi translated">结论</h1><p id="7cf1" class="pw-post-body-paragraph kf kg iq kh b ki ma jr kk kl mb ju kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">该测试向我们展示了使用并行计算从web访问信息可以极大地丰富我们的工具包。作为数据科学家，我们有很多关于访问API以访问信息的项目，这是一种加速这一过程的方法。即使这个过程不是那么庞大，改进也是巨大的。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="079f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以在这个<a class="ae mf" href="https://github.com/gody/ParallelScraping" rel="noopener ugc nofollow" target="_blank"> GitHub链接</a>中访问该实验的代码。</p></div></div>    
</body>
</html>