<html>
<head>
<title>Two Simple Ways to Loop More Effectively in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 Python 中更有效地循环的两种简单方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/two-simple-ways-to-loop-more-effectively-in-python-886526008a70?source=collection_archive---------13-----------------------#2020-04-08">https://towardsdatascience.com/two-simple-ways-to-loop-more-effectively-in-python-886526008a70?source=collection_archive---------13-----------------------#2020-04-08</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="a277" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">使用枚举和压缩编写更好的 Python 循环</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/b7e2db585b48a670728d2107364ad0c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lX7j4t8slTd_6i9K"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">许多循环。由<a class="ae kz" href="https://unsplash.com/@daviidstreit?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> David Streit </a>在<a class="ae kz" href="https://unsplash.com/s/photos/loops?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="e4a9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Python <code class="fe lw lx ly lz b">range</code>函数非常强大，但它通常可以被其他内置函数所替代，使您的循环更容易编写和阅读。在本文中，我将向您展示何时可以用<code class="fe lw lx ly lz b">enumerate</code>或<code class="fe lw lx ly lz b">zip</code>来替换<code class="fe lw lx ly lz b">range</code>。</p><h1 id="6fe5" class="ma mb iu bd mc md me mf mg mh mi mj mk ka ml kb mm kd mn ke mo kg mp kh mq mr bi translated">使用 enumerate(object)而不是 range(len(object))</h1><p id="b408" class="pw-post-body-paragraph la lb iu lc b ld ms jv lf lg mt jy li lj mu ll lm ln mv lp lq lr mw lt lu lv in bi translated"><strong class="lc iv">问题 1 </strong>:你经常有像列表这样的对象需要迭代，同时还要跟踪每次迭代的索引。给定下面的列表，您将如何使用 for 循环来生成所需的输出？</p><pre class="kk kl km kn gu mx lz my mz aw na bi"><span id="8a62" class="nb mb iu lz b gz nc nd l ne nf">my_list = ['apple', 'orange', 'cat', 'dog']</span><span id="da9e" class="nb mb iu lz b gz ng nd l ne nf"># desired output<br/>Item 0: apple<br/>Item 1: orange<br/>Item 2: cat<br/>Item 3: dog</span></pre><p id="7469" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">方案一</strong>:使用<code class="fe lw lx ly lz b">for i in range(len(my_list))</code></p><pre class="kk kl km kn gu mx lz my mz aw na bi"><span id="5c6c" class="nb mb iu lz b gz nc nd l ne nf">for i in range(len(my_list)):<br/>    print(f"Item {i}: {my_list[i]}")</span><span id="dc19" class="nb mb iu lz b gz ng nd l ne nf">Item 0: apple<br/>Item 1: orange<br/>Item 2: cat<br/>Item 3: dog</span></pre><p id="e874" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">更好的解决方案</strong>:使用<code class="fe lw lx ly lz b">for i, value in enumerate(my_list)</code></p><pre class="kk kl km kn gu mx lz my mz aw na bi"><span id="789d" class="nb mb iu lz b gz nc nd l ne nf">for i, value in enumerate(my_list):<br/>    print(f"Item {i}: {value}")</span><span id="fd9c" class="nb mb iu lz b gz ng nd l ne nf">Item 0: apple<br/>Item 1: orange<br/>Item 2: cat<br/>Item 3: dog</span></pre><p id="ca23" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">解释</strong> : <code class="fe lw lx ly lz b">enumerate</code>在迭代器<code class="fe lw lx ly lz b">my_list</code>上循环，并在迭代对象时将条目及其索引作为索引条目元组返回(参见下面的代码和输出以查看元组输出)。当我们将循环构造为<code class="fe lw lx ly lz b">for i, value in enumerate(my_list)</code>时，我们解包索引项元组。</p><pre class="kk kl km kn gu mx lz my mz aw na bi"><span id="5397" class="nb mb iu lz b gz nc nd l ne nf">for i in enumerate(my_list):<br/>    print(i)</span><span id="0d34" class="nb mb iu lz b gz ng nd l ne nf">(0, 'apple')  # tuple, which can be unpacked (see code chunk above)<br/>(1, 'orange')<br/>(2, 'cat')<br/>(3, 'dog')</span></pre><p id="b068" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">问题 2 </strong>:给定与上面相同的列表，编写一个循环来生成所需的输出(确保第一个索引从 101 开始，而不是从 0 开始)。</p><pre class="kk kl km kn gu mx lz my mz aw na bi"><span id="ef9c" class="nb mb iu lz b gz nc nd l ne nf">my_list = ['apple', 'orange', 'cat', 'dog']</span><span id="0c15" class="nb mb iu lz b gz ng nd l ne nf"># desired output<br/>Item 101: apple<br/>Item 102: orange<br/>Item 103: cat<br/>Item 104: dog</span></pre><p id="f5fe" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">解决方案二</strong>:使用<code class="fe lw lx ly lz b">for i, value in enumerate(my_list, 101)</code></p><p id="7a85" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">函数<code class="fe lw lx ly lz b">enumerate(iterable, start=0)</code>让您从任何想要的数字开始计数索引(默认为 0)。</p><pre class="kk kl km kn gu mx lz my mz aw na bi"><span id="b88d" class="nb mb iu lz b gz nc nd l ne nf">for i, value in enumerate(my_list, 101):<br/>    print(f"Item {i}: {value}")</span><span id="87fb" class="nb mb iu lz b gz ng nd l ne nf">Item 101: apple<br/>Item 102: orange<br/>Item 103: cat<br/>Item 104: dog</span></pre><p id="0814" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">外卖</strong></p><ul class=""><li id="35c2" class="nh ni iu lc b ld le lg lh lj nj ln nk lr nl lv nm nn no np bi translated"><code class="fe lw lx ly lz b">enumerate</code>内置函数在迭代器上循环，并从迭代器中返回索引和条目作为索引条目元组</li><li id="fd9e" class="nh ni iu lc b ld nq lg nr lj ns ln nt lr nu lv nm nn no np bi translated">使用<code class="fe lw lx ly lz b">enumerate(object)</code>而不是<code class="fe lw lx ly lz b">range(len(object))</code>来获得更简洁易读的代码</li><li id="a848" class="nh ni iu lc b ld nq lg nr lj ns ln nt lr nu lv nm nn no np bi translated">提供第二个参数来指示开始计数的数字(默认值为 0)</li></ul><h1 id="f923" class="ma mb iu bd mc md me mf mg mh mi mj mk ka ml kb mm kd mn ke mo kg mp kh mq mr bi translated">使用 zip 并行迭代多个对象</h1><p id="d201" class="pw-post-body-paragraph la lb iu lc b ld ms jv lf lg mt jy li lj mu ll lm ln mv lp lq lr mw lt lu lv in bi translated"><strong class="lc iv">问题 3: </strong>你有多个想要并行迭代的列表或者对象。给定下面的三个列表，你将如何产生期望的输出？</p><pre class="kk kl km kn gu mx lz my mz aw na bi"><span id="95a0" class="nb mb iu lz b gz nc nd l ne nf">my_list = ['apple', 'orange', 'cat', 'dog']<br/>my_list_n = [11, 12, 25, 26]<br/>my_list_idx = [1, 2, 3, 4]</span><span id="8776" class="nb mb iu lz b gz ng nd l ne nf"># desired output<br/>1. apple: 11<br/>2. orange: 12<br/>3. cat: 25<br/>4. dog: 26</span></pre><p id="725c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">解决方案 3 </strong>:使用<code class="fe lw lx ly lz b">range(len(my_list))</code>获取索引</p><pre class="kk kl km kn gu mx lz my mz aw na bi"><span id="95fe" class="nb mb iu lz b gz nc nd l ne nf">for i in range(len(my_list)):<br/>    print(f"{my_list_idx[i]}. {my_list[i]}: {my_list_n[i]}")</span><span id="2b0a" class="nb mb iu lz b gz ng nd l ne nf">1. apple: 11<br/>2. orange: 12<br/>3. cat: 25<br/>4. dog: 26</span></pre><p id="074b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">更好的解决方案</strong>:使用<code class="fe lw lx ly lz b">zip(my_list_idx, my_list, my_list_n)</code></p><pre class="kk kl km kn gu mx lz my mz aw na bi"><span id="bff0" class="nb mb iu lz b gz nc nd l ne nf">for i, obj, count in zip(<!-- -->my_list_idx<!-- -->, <!-- -->my_list<!-- -->, <!-- -->my_list_n<!-- -->):<br/>    print(f"{i}. {obj}: {count}")</span><span id="2462" class="nb mb iu lz b gz ng nd l ne nf">1. apple: 11<br/>2. orange: 12<br/>3. cat: 25<br/>4. dog: 26</span></pre><p id="fc56" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">说明</strong>:可以使用<code class="fe lw lx ly lz b">zip</code>同时迭代多个对象。<code class="fe lw lx ly lz b">zip</code>返回可以在循环中解包的元组。参见下面的例子来理解这个函数是如何工作的。</p><p id="48d9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe lw lx ly lz b">zip</code>返回元组:</p><pre class="kk kl km kn gu mx lz my mz aw na bi"><span id="13e9" class="nb mb iu lz b gz nc nd l ne nf">for i in zip(my_list_idx, my_list, my_list_n):<br/>    print(i)</span><span id="d413" class="nb mb iu lz b gz ng nd l ne nf">(1, 'apple', 11)  # 3-item tuple<br/>(2, 'orange', 12)<br/>(3, 'cat', 25)<br/>(4, 'dog', 26)</span></pre><p id="5558" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">元组中的每个元素都可以手动提取:</p><pre class="kk kl km kn gu mx lz my mz aw na bi"><span id="344f" class="nb mb iu lz b gz nc nd l ne nf">for i in zip(my_list_idx, my_list, my_list_n):<br/>    print(f"{i[0]}. {i[1]}: {i[2]}")  # i is a 3-item tuple</span><span id="c5f6" class="nb mb iu lz b gz ng nd l ne nf">1. apple: 11<br/>2. orange: 12<br/>3. cat: 25<br/>4. dog: 26</span></pre><p id="05b8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">外卖</strong></p><ul class=""><li id="8e4a" class="nh ni iu lc b ld le lg lh lj nj ln nk lr nl lv nm nn no np bi translated"><code class="fe lw lx ly lz b">zip</code>内置函数可以同时迭代多个迭代器。</li><li id="5bc8" class="nh ni iu lc b ld nq lg nr lj ns ln nt lr nu lv nm nn no np bi translated"><code class="fe lw lx ly lz b">zip</code>创建一个惰性生成器来生成元组</li></ul><h1 id="4088" class="ma mb iu bd mc md me mf mg mh mi mj mk ka ml kb mm kd mn ke mo kg mp kh mq mr bi translated">结论</h1><p id="998a" class="pw-post-body-paragraph la lb iu lc b ld ms jv lf lg mt jy li lj mu ll lm ln mv lp lq lr mw lt lu lv in bi translated">使用内置的 Python 函数<code class="fe lw lx ly lz b">enumerate</code>和<code class="fe lw lx ly lz b">zip</code>可以帮助您编写更好的 Python 代码，可读性更强，更简洁。</p><p id="330c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果您对提高数据科学技能感兴趣，以下文章可能会有所帮助:</p><div class="nv nw gq gs nx ny"><a rel="noopener follow" target="_blank" href="/reshaping-numpy-arrays-in-python-a-step-by-step-pictorial-tutorial-aed5f471cf0b"><div class="nz ab fp"><div class="oa ab ob cl cj oc"><h2 class="bd iv gz z fq od fs ft oe fv fx it bi translated">在 Python 中重塑 numpy 数组—一步一步的图形教程</h2><div class="of l"><h3 class="bd b gz z fq od fs ft oe fv fx dk translated">本教程和备忘单提供了可视化效果，帮助您理解 numpy 如何重塑数组。</h3></div><div class="og l"><p class="bd b dl z fq od fs ft oe fv fx dk translated">towardsdatascience.com</p></div></div><div class="oh l"><div class="oi l oj ok ol oh om kt ny"/></div></div></a></div><div class="nv nw gq gs nx ny"><a href="https://medium.com/better-programming/code-and-develop-more-productively-with-terminal-multiplexer-tmux-eeac8763d273" rel="noopener follow" target="_blank"><div class="nz ab fp"><div class="oa ab ob cl cj oc"><h2 class="bd iv gz z fq od fs ft oe fv fx it bi translated">使用终端多路复用器 tmux 提高编码和开发效率</h2><div class="of l"><h3 class="bd b gz z fq od fs ft oe fv fx dk translated">简单的 tmux 命令来提高您的生产力</h3></div><div class="og l"><p class="bd b dl z fq od fs ft oe fv fx dk translated">medium.com</p></div></div><div class="oh l"><div class="on l oj ok ol oh om kt ny"/></div></div></a></div><div class="nv nw gq gs nx ny"><a rel="noopener follow" target="_blank" href="/real-or-spurious-correlations-attractive-people-you-date-are-nastier-fa44a30a9452"><div class="nz ab fp"><div class="oa ab ob cl cj oc"><h2 class="bd iv gz z fq od fs ft oe fv fx it bi translated">真实或虚假的关联:你约会的有魅力的人更令人讨厌</h2><div class="of l"><h3 class="bd b gz z fq od fs ft oe fv fx dk translated">使用 Python 模拟数据、测试直觉并提高数据科学技能</h3></div><div class="og l"><p class="bd b dl z fq od fs ft oe fv fx dk translated">towardsdatascience.com</p></div></div><div class="oh l"><div class="oo l oj ok ol oh om kt ny"/></div></div></a></div><div class="nv nw gq gs nx ny"><a rel="noopener follow" target="_blank" href="/free-online-data-science-courses-during-covid-19-crisis-764720084a2"><div class="nz ab fp"><div class="oa ab ob cl cj oc"><h2 class="bd iv gz z fq od fs ft oe fv fx it bi translated">新冠肺炎危机期间的免费在线数据科学课程</h2><div class="of l"><h3 class="bd b gz z fq od fs ft oe fv fx dk translated">像 Udacity、Codecademy 和 Dataquest 这样的平台现在免费提供课程</h3></div><div class="og l"><p class="bd b dl z fq od fs ft oe fv fx dk translated">towardsdatascience.com</p></div></div><div class="oh l"><div class="op l oj ok ol oh om kt ny"/></div></div></a></div><p id="9787" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><em class="oq">更多帖子，</em> <a class="ae kz" href="https://hauselin.ck.page/587b46fb05" rel="noopener ugc nofollow" target="_blank"> <em class="oq">订阅我的邮件列表</em> </a> <em class="oq">。</em></p></div></div>    
</body>
</html>