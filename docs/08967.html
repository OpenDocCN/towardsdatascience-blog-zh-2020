<html>
<head>
<title>Deployment could be easy — A Data Scientist’s Guide to deploy an Image detection FastAPI API using Amazon ec2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">部署可能很容易——使用 Amazon ec2 部署图像检测 FastAPI API 的数据科学家指南</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/deployment-could-be-easy-a-data-scientists-guide-to-deploy-an-image-detection-fastapi-api-using-329cdd80400?source=collection_archive---------11-----------------------#2020-06-28">https://towardsdatascience.com/deployment-could-be-easy-a-data-scientists-guide-to-deploy-an-image-detection-fastapi-api-using-329cdd80400?source=collection_archive---------11-----------------------#2020-06-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/aa2f07d19ba77567f71f8b0128ccdf5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gFAGel1erOdcg21c"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">科迪·布莱克在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><div class=""/><div class=""><h2 id="ba99" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">使用亚马逊 EC2+Pytorch+Fastapi 和 Docker</h2></div><p id="8169" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就在最近，我写了一篇关于 FastAPI 的简单的<a class="ae jg" rel="noopener" target="_blank" href="/a-layman-guide-for-data-scientists-to-create-apis-in-minutes-31e6f451cd2f">教程</a>，内容是关于简化和理解 API 如何工作，以及使用框架创建一个简单的 API。</p><p id="28fd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="lu">那个帖子得到了相当好的回应，但是被问得最多的问题是</em> <strong class="la jk"> <em class="lu">如何在 ec2 上部署 FastAPI API，以及如何使用图像数据而不是简单的字符串、整数和浮点数作为 API </em> </strong> <em class="lu">的输入。</em></p><blockquote class="lv"><p id="352e" class="lw lx jj bd ly lz ma mb mc md me lt dk translated">我在网上搜索了一下，但是我能找到的只是一些不太熟悉的文档和人们使用 NGINX 或 ECS 进行部署的许多不同方式。对我来说，这些都不是特别伟大或完整的。</p></blockquote><p id="aa48" class="pw-post-body-paragraph ky kz jj la b lb mf kk ld le mg kn lg lh mh lj lk ll mi ln lo lp mj lr ls lt im bi translated">所以，我试着在 FastAPI 文档的帮助下自己做这件事。在本帖中，我们将主要关注四件事:</p><ul class=""><li id="459a" class="mk ml jj la b lb lc le lf lh mm ll mn lp mo lt mp mq mr ms bi translated">设置 Amazon 实例</li><li id="976f" class="mk ml jj la b lb mt le mu lh mv ll mw lp mx lt mp mq mr ms bi translated">创建用于对象检测的 FastAPI API</li><li id="7877" class="mk ml jj la b lb mt le mu lh mv ll mw lp mx lt mp mq mr ms bi translated">使用 Docker 部署 FastAPI</li><li id="a07a" class="mk ml jj la b lb mt le mu lh mv ll mw lp mx lt mp mq mr ms bi translated">带有用户界面的端到端应用</li></ul><p id="e283" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> <em class="lu">那么，事不宜迟，我们开始吧。</em>T19】</strong></p><p id="b183" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以跳过任何你认为你精通的部分，尽管我希望你浏览整篇文章，尽管它可能很长，因为概念之间有很多相互联系。</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="7e53" class="nf ng jj bd nh ni nj nk nl nm nn no np kp nq kq nr ks ns kt nt kv nu kw nv nw bi translated">1.设置 Amazon 实例</h1><p id="4092" class="pw-post-body-paragraph ky kz jj la b lb nx kk ld le ny kn lg lh nz lj lk ll oa ln lo lp ob lr ls lt im bi translated">在开始使用 Amazon ec2 实例之前，我们需要设置一个实例。你可能需要用你的电子邮件 ID 注册，并在<a class="ae jg" href="https://aws.amazon.com/" rel="noopener ugc nofollow" target="_blank"> AWS 网站</a>上设置支付信息。就像单点登录一样工作。从这里开始，我将假设您有一个 AWS 帐户，因此我将解释接下来的重要部分，以便您可以继续操作。</p><ul class=""><li id="2e53" class="mk ml jj la b lb lc le lf lh mm ll mn lp mo lt mp mq mr ms bi translated">使用<a class="ae jg" href="https://us-west-2.console.aws.amazon.com/console" rel="noopener ugc nofollow" target="_blank">https://us-west-2.console.aws.amazon.com/console</a>进入 AWS 管理控制台。</li><li id="7985" class="mk ml jj la b lb mt le mu lh mv ll mw lp mx lt mp mq mr ms bi translated">在 AWS 管理控制台上，您可以选择“启动虚拟机”在这里，我们试图设置一台机器，在那里我们将部署我们的 FastAPI API。</li><li id="487c" class="mk ml jj la b lb mt le mu lh mv ll mw lp mx lt mp mq mr ms bi translated">第一步，您需要为机器选择 AMI 模板。我选的是 Ubuntu 以来的 18.04 Ubuntu 服务器。</li></ul><figure class="od oe of og gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oc"><img src="../Images/0d36126c9c91a0a338e1330bb67dea35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*geMPHklLQeCcHIA3RXZTOw.png"/></div></div></figure><ul class=""><li id="a123" class="mk ml jj la b lb lc le lf lh mm ll mn lp mo lt mp mq mr ms bi translated">在第二步中，我选择了<code class="fe oh oi oj ok b">t2.xlarge</code>机器，它有 4 个 CPU 和 16GB RAM，而不是空闲层，因为我想使用对象检测模型，并且需要一些资源。</li></ul><figure class="od oe of og gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ol"><img src="../Images/8dbb39a418d3fe7bd9cc7a9c1efbd743.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LOZOYrpCDqW76uFec9ZaZg.png"/></div></div></figure><ul class=""><li id="25e6" class="mk ml jj la b lb lc le lf lh mm ll mn lp mo lt mp mq mr ms bi translated">继续按下一步，直到你到达“6。配置安全组”选项卡。这是最关键的一步。您需要添加一个类型为“HTTP”且端口范围为 80 的规则。</li></ul><figure class="od oe of og gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi om"><img src="../Images/8ca4150c615166c175db713667daf27e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BbfzEypfbmB26M4-QfiapQ.png"/></div></div></figure><ul class=""><li id="99de" class="mk ml jj la b lb lc le lf lh mm ll mn lp mo lt mp mq mr ms bi translated">您可以单击“查看并启动”，最后单击“启动”按钮来启动实例。单击启动后，您可能需要创建一个新的密钥对。这里我创建了一个名为<code class="fe oh oi oj ok b">fastapi</code>的新密钥对，并使用“Download Key Pair”按钮下载它。请妥善保管此密钥，因为每次您需要登录到此特定机器时都会用到它。下载密钥对后，单击“启动实例”</li></ul><figure class="od oe of og gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi on"><img src="../Images/2ad65fc69ceb8edb6ff53dfdd1433a77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dO-36pTCF_rmg41dh6ctIw.png"/></div></div></figure><ul class=""><li id="fa52" class="mk ml jj la b lb lc le lf lh mm ll mn lp mo lt mp mq mr ms bi translated">现在，您可以转到您的实例，查看您的实例是否已经启动。提示:查看实例状态；它应该显示“运行”</li></ul><figure class="od oe of og gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oo"><img src="../Images/48b9e304433e46606d2bfcace37b700a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_fo54NwqQ089OtWkK8MnQw.png"/></div></div></figure><ul class=""><li id="f0d6" class="mk ml jj la b lb lc le lf lh mm ll mn lp mo lt mp mq mr ms bi translated">另外，这里要注意的是公共 DNS(IPv4)地址和 IPv4 公共 IP。我们将需要它来连接到这台机器。对我来说，它们是:</li></ul><pre class="od oe of og gt op ok oq or aw os bi"><span id="a8f3" class="ot ng jj ok b gy ou ov l ow ox">Public DNS (IPv4): ec2-18-237-28-174.us-west-2.compute.amazonaws.com</span><span id="b661" class="ot ng jj ok b gy oy ov l ow ox">IPv4 Public IP: 18.237.28.174</span></pre><ul class=""><li id="ef1d" class="mk ml jj la b lb lc le lf lh mm ll mn lp mo lt mp mq mr ms bi translated">一旦你在文件夹中运行了下面的命令，你就保存了<code class="fe oh oi oj ok b">fastapi.pem</code>文件。如果文件被命名为<code class="fe oh oi oj ok b">fastapi.txt</code>，你可能需要将其重命名为<code class="fe oh oi oj ok b">fastapi.pem.</code></li></ul><pre class="od oe of og gt op ok oq or aw os bi"><span id="1883" class="ot ng jj ok b gy ou ov l ow ox"># run fist command if fastapi.txt gets downloaded.<br/># mv fastapi.txt fastapi.pem</span><span id="3ff9" class="ot ng jj ok b gy oy ov l ow ox">chmod 400 fastapi.pem<br/>ssh -i "fastapi.pem" ubuntu@&lt;Your Public DNS(IPv4) Address&gt;</span></pre><figure class="od oe of og gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oz"><img src="../Images/42a5a42c43a7c900ad8b47a9ef6a2a08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vrkhPaGABYeNPXLhK-gNRQ.png"/></div></div></figure><p id="d035" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们已经启动并运行了 Amazon 实例。我们可以在这里继续讨论帖子的真实部分。</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="e0b2" class="nf ng jj bd nh ni nj nk nl nm nn no np kp nq kq nr ks ns kt nt kv nu kw nv nw bi translated">2.创建用于对象检测的 FastAPI API</h1><p id="aaef" class="pw-post-body-paragraph ky kz jj la b lb nx kk ld le ny kn lg lh nz lj lk ll oa ln lo lp ob lr ls lt im bi translated">在我们部署 API 之前，我们需要有一个 API，对吗？在我最近的一篇文章中，我写了一个简单的<a class="ae jg" rel="noopener" target="_blank" href="/a-layman-guide-for-data-scientists-to-create-apis-in-minutes-31e6f451cd2f">教程来理解 FastAPI </a>和 API 基础。如果你想了解 FastAPI 的基础知识，请阅读这篇文章。</p><p id="7ff7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，这里我将尝试创建一个图像检测 API。至于如何把图像数据传递给 API？想法是——<strong class="la jk"><em class="lu">除了字符串，什么是图像？</em> </strong>一个图像只是由字节组成，我们可以把这些字节编码成一个字符串。我们将使用 base64 字符串表示法，这是一种将二进制数据转换为 ASCII 字符的流行方法。并且，我们将传递这个字符串表示来给我们的 API 一个图像。</p><h2 id="3b94" class="ot ng jj bd nh pa pb dn nl pc pd dp np lh pe pf nr ll pg ph nt lp pi pj nv pk bi translated">A.一些图像基础知识:什么是图像，但一个字符串？</h2><p id="fed6" class="pw-post-body-paragraph ky kz jj la b lb nx kk ld le ny kn lg lh nz lj lk ll oa ln lo lp ob lr ls lt im bi translated">所以，让我们先看看如何将图像转换成字符串。我们使用<code class="fe oh oi oj ok b">‘rb’ </code>标志从图像文件中读取二进制数据，并使用<code class="fe oh oi oj ok b">base64.b64encode</code>函数将其转换为 base64 编码的数据表示。然后，我们使用<code class="fe oh oi oj ok b">decode</code>到<code class="fe oh oi oj ok b">utf-8</code>函数将基本编码数据转换成人类可读的字符。如果现在还没什么意义，也不用担心。<strong class="la jk"> <em class="lu">只要明白任何数据都是二进制的，我们可以使用一系列步骤将二进制数据转换为其字符串表示。</em> </strong></p><p id="8b9c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">举个简单的例子，如果我有一个像下面这样的简单图像，我们可以用下面的方法把它转换成一个字符串:</p><figure class="od oe of og gt iv gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/316b87a38d831bc4e1c29ccaa7fded8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/format:webp/0*WusF_iW5Gglzp_XN.jpg"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">狗 _ 带 _ 球. jpg</p></figure><pre class="od oe of og gt op ok oq or aw os bi"><span id="4d35" class="ot ng jj ok b gy ou ov l ow ox">import base64</span><span id="42b5" class="ot ng jj ok b gy oy ov l ow ox">with open("sample_images/dog_with_ball.jpg", "rb") as image_file:<br/>    base64str = base64.b64encode(image_file.read()).decode("utf-8")</span></pre><figure class="od oe of og gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pm"><img src="../Images/8a6c595e393484abc418748947395632.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uygRTlY0_SvXJ3V13tchfQ.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">我们可以得到任何图像的字符串表示</p></figure><p id="d81b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我的笔记本电脑上，这里有一个名为<code class="fe oh oi oj ok b">dog_with_ball.png</code>的文件的字符串表示。</p><p id="051f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">很好，我们现在有了图像的字符串表示。并且，我们可以将这个字符串表示发送给我们的 FastAPI。但是我们还需要有一种方法从图像的字符串表示中读回图像。毕竟，我们使用 PyTorch 和任何其他包的图像检测 API 需要有一个可以预测的图像对象，这些方法不能在字符串上工作。</p><p id="7a18" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里有一种从图像的 base64 字符串创建 PIL 图像的方法。大多数情况下，我们只是以同样的顺序做相反的步骤。我们使用<code class="fe oh oi oj ok b">.encode.</code>在<code class="fe oh oi oj ok b">‘utf-8’</code>中编码，然后使用<code class="fe oh oi oj ok b">base64.b64decode</code>解码成字节。我们使用这些字节通过<code class="fe oh oi oj ok b">io.BytesIO</code>创建一个 bytes 对象，并使用<code class="fe oh oi oj ok b">Image.open</code>将这个 bytes IO 对象作为 PIL 图像打开，这可以很容易地用作我的 PyTorch 预测代码的输入。<strong class="la jk"> <em class="lu">再简单一点，它只是将</em> </strong> <code class="fe oh oi oj ok b"><strong class="la jk"><em class="lu">base64</em></strong></code> <strong class="la jk"> <em class="lu">图像串转换为实际图像的一种方式。</em> </strong></p><pre class="od oe of og gt op ok oq or aw os bi"><span id="9ff3" class="ot ng jj ok b gy ou ov l ow ox">import base64<br/>import io<br/>from PIL import Image</span><span id="e4cb" class="ot ng jj ok b gy oy ov l ow ox">def base64str_to_PILImage(base64str):<br/>   base64_img_bytes = base64str.encode('utf-8')<br/>   base64bytes = base64.b64decode(base64_img_bytes)<br/>   bytesObj = io.BytesIO(base64bytes)<br/>   img = Image.open(bytesObj) <br/>   return img</span></pre><p id="9007" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那么这个功能起作用吗？我们自己看吧。我们可以只使用字符串来获取图像。</p><figure class="od oe of og gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pm"><img src="../Images/00513cd053c20bac0a9193dc8265a8ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hq-YfDikmu1-V_ss3zMLZA.png"/></div></div></figure><p id="5a00" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们的快乐狗狗又回来了。比绳子好看。</p><h2 id="3117" class="ot ng jj bd nh pa pb dn nl pc pd dp np lh pe pf nr ll pg ph nt lp pi pj nv pk bi translated">B.编写实际的 FastAPI 代码</h2><p id="08cf" class="pw-post-body-paragraph ky kz jj la b lb nx kk ld le ny kn lg lh nz lj lk ll oa ln lo lp ob lr ls lt im bi translated">因此，现在我们知道我们的 API 可以从我们的用户那里获得一个字符串形式的图像，让我们创建一个对象检测 API，它使用这个字符串形式的图像，并输出带有对象类的对象的边界框。</p><p id="5e5f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这里，我将使用来自<code class="fe oh oi oj ok b">torchvision.models</code>的 Pytorch 预训练<code class="fe oh oi oj ok b">fasterrcnn_resnet50_fpn</code>检测模型进行对象检测，该模型是在 COCO 数据集上训练的，以保持代码简单，但可以使用任何模型。如果你想用 Pytorch 训练你的自定义<a class="ae jg" rel="noopener" target="_blank" href="/end-to-end-pipeline-for-setting-up-multiclass-image-classification-for-data-scientists-2e051081d41c">图像分类</a>或者<a class="ae jg" href="https://lionbridge.ai/articles/create-an-end-to-end-object-detection-pipeline-using-yolov5/" rel="noopener ugc nofollow" target="_blank">图像检测</a>模型，可以看看这些帖子。</p><p id="25a1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是 FastAPI 的完整代码。虽然它看起来很长，但我们已经知道了所有的部分。在这段代码中，我们主要执行以下步骤:</p><ul class=""><li id="6f7c" class="mk ml jj la b lb lc le lf lh mm ll mn lp mo lt mp mq mr ms bi translated">使用 FastAPI()构造函数创建我们的 fast API 应用程序。</li><li id="5d59" class="mk ml jj la b lb mt le mu lh mv ll mw lp mx lt mp mq mr ms bi translated">加载我们的模型和它被训练的类。我从 PyTorch <a class="ae jg" href="https://pytorch.org/docs/stable/torchvision/models.html" rel="noopener ugc nofollow" target="_blank">文档</a>中获得了课程列表。</li><li id="4604" class="mk ml jj la b lb mt le mu lh mv ll mw lp mx lt mp mq mr ms bi translated">我们还定义了一个新的类<code class="fe oh oi oj ok b">Input</code>，它使用一个名为<code class="fe oh oi oj ok b">pydantic</code>的库来验证我们将从 API 最终用户那里获得的输入数据类型。在这里，终端用户给出<code class="fe oh oi oj ok b">base64str</code>和一些用于目标检测预测的分数<code class="fe oh oi oj ok b">threshold</code>。</li><li id="2dd8" class="mk ml jj la b lb mt le mu lh mv ll mw lp mx lt mp mq mr ms bi translated">我们添加了一个名为<code class="fe oh oi oj ok b">base64str_to_PILImage</code>的函数，正如它的名字一样。</li><li id="303c" class="mk ml jj la b lb mt le mu lh mv ll mw lp mx lt mp mq mr ms bi translated">我们编写了一个名为<code class="fe oh oi oj ok b">get_predictionbase64</code>的预测函数，它使用图像的 base64 字符串表示和一个阈值作为输入，返回边界框和类的字典。我们还在这个函数的顶部添加了<code class="fe oh oi oj ok b"><a class="ae jg" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.put(“/predict”)</code>来定义我们的端点。如果你需要理解 put 和 endpoint，请参考我之前在 FastAPI 上发表的文章。</li></ul><figure class="od oe of og gt iv"><div class="bz fp l di"><div class="pn po l"/></div></figure><h2 id="9611" class="ot ng jj bd nh pa pb dn nl pc pd dp np lh pe pf nr ll pg ph nt lp pi pj nv pk bi translated">C.先本地后全局:在本地测试 FastAPI 代码</h2><p id="bd22" class="pw-post-body-paragraph ky kz jj la b lb nx kk ld le ny kn lg lh nz lj lk ll oa ln lo lp ob lr ls lt im bi translated">在我们转向 AWS 之前，让我们检查一下代码是否在我们的本地机器上工作。我们可以使用以下命令在笔记本电脑上启动 API:</p><pre class="od oe of og gt op ok oq or aw os bi"><span id="4005" class="ot ng jj ok b gy ou ov l ow ox">uvicorn fastapiapp:app --reload</span></pre><p id="4717" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以上意味着您的 API 现在正在您的本地服务器上运行，<code class="fe oh oi oj ok b">--reload</code>标志表示当您更改<code class="fe oh oi oj ok b">fastapiapp.py</code>文件时，API 会自动更新。这在开发和测试时非常有用，但是当您将 API 投入生产时，您应该删除这个<code class="fe oh oi oj ok b">--reload</code>标志。</p><p id="e1b1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您应该会看到类似这样的内容:</p><figure class="od oe of og gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pp"><img src="../Images/fbee96e8e1e2b2e8b0e8a62fc6ce5428.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Je9u4KZ2GDD0QzlDBt_85w.png"/></div></div></figure><p id="a87d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，您可以尝试使用请求模块来访问这个 API 并查看它是否工作:</p><pre class="od oe of og gt op ok oq or aw os bi"><span id="e8ed" class="ot ng jj ok b gy ou ov l ow ox">import requests,json</span><span id="fae8" class="ot ng jj ok b gy oy ov l ow ox">payload = json.dumps({<br/>  "base64str": base64str,<br/>  "threshold": 0.5<br/>})</span><span id="5868" class="ot ng jj ok b gy oy ov l ow ox">response = requests.put("<a class="ae jg" href="http://127.0.0.1:8000/predict" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8000/predict</a>",data = payload)<br/>data_dict = response.json()</span></pre><figure class="od oe of og gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pq"><img src="../Images/672b6f6ab06306d00863dc947f1ef113.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iLsFLNtFg-kXIoaOtTROyQ.png"/></div></div></figure><p id="a4af" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以我们使用 API 得到我们的结果。这个图像包含一只狗和一个运动球。我们也有边界框的角 1 ( <code class="fe oh oi oj ok b">x1,y1)</code>和角 2 ( <code class="fe oh oi oj ok b">x2,y2</code>)坐标。</p><h2 id="5581" class="ot ng jj bd nh pa pb dn nl pc pd dp np lh pe pf nr ll pg ph nt lp pi pj nv pk bi translated">D.让我们想象一下</h2><p id="c11d" class="pw-post-body-paragraph ky kz jj la b lb nx kk ld le ny kn lg lh nz lj lk ll oa ln lo lp ob lr ls lt im bi translated">虽然并非绝对必要，但我们可以在 Jupyter 笔记本中想象结果:</p><figure class="od oe of og gt iv"><div class="bz fp l di"><div class="pn po l"/></div></figure><p id="7e63" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是输出:</p><figure class="od oe of og gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pr"><img src="../Images/51bbf42df374d28d2bd1421dcc80ca07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lx1qI8Qws9Eu4HDMouTSfw.png"/></div></div></figure><p id="0dfd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里你会注意到，我从本地文件系统中获取了图像，这可以被认为是欺骗，因为我们不想保存用户通过 web UI 发送给我们的每个文件。我们应该能够使用相同的<code class="fe oh oi oj ok b">base64string</code>对象，我们也必须创建这个图像。对吗？</p><p id="7d02" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">别担心，我们也能做到。还记得我们的<code class="fe oh oi oj ok b">base64str_to_PILImage </code>功能吗？我们也可以用这个。</p><pre class="od oe of og gt op ok oq or aw os bi"><span id="356c" class="ot ng jj ok b gy ou ov l ow ox">img = base64str_to_PILImage(base64str)<br/>drawboundingbox(img, data_dict['boxes'], data_dict['classes'])</span></pre><figure class="od oe of og gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ps"><img src="../Images/fbd046a17cd08c1cc2d5b4bca7867a31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zgW8pQ06OdPGGbKUiZ7t5g.png"/></div></div></figure><p id="5f4c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">看起来很棒。我们有工作的 FastAPI，也有 amazon 实例。我们现在可以开始部署了。</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="048d" class="nf ng jj bd nh ni nj nk nl nm nn no np kp nq kq nr ks ns kt nt kv nu kw nv nw bi translated">3.在 Amazon ec2 上部署</h1><p id="f7ab" class="pw-post-body-paragraph ky kz jj la b lb nx kk ld le ny kn lg lh nz lj lk ll oa ln lo lp ob lr ls lt im bi translated">到目前为止，我们已经创建了一个 AWS 实例，还创建了一个 FastAPI，它将图像的 base64 字符串表示作为输入，并返回边界框和相关的类。但是所有的 FastAPI 代码仍然驻留在我们的本地机器上。<strong class="la jk"> <em class="lu">我们怎么把它放到 ec2 服务器上？并在云上运行预测。</em>T11】</strong></p><h2 id="6f16" class="ot ng jj bd nh pa pb dn nl pc pd dp np lh pe pf nr ll pg ph nt lp pi pj nv pk bi translated">A.安装 Docker</h2><p id="c026" class="pw-post-body-paragraph ky kz jj la b lb nx kk ld le ny kn lg lh nz lj lk ll oa ln lo lp ob lr ls lt im bi translated">我们将使用 docker 部署我们的应用程序，正如<code class="fe oh oi oj ok b">fastAPI</code>创建者自己所建议的那样。我会试着解释 docker 是如何工作的。下面的部分可能看起来令人生畏，但它只是一系列的命令和步骤。所以和我在一起。</p><p id="8121" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以从安装 docker 开始，使用:</p><pre class="od oe of og gt op ok oq or aw os bi"><span id="41a2" class="ot ng jj ok b gy ou ov l ow ox">sudo apt-get update<br/>sudo apt install docker.io</span></pre><p id="b642" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，我们使用以下命令启动 docker 服务:</p><pre class="od oe of og gt op ok oq or aw os bi"><span id="3846" class="ot ng jj ok b gy ou ov l ow ox">sudo service docker start</span></pre><h2 id="c685" class="ot ng jj bd nh pa pb dn nl pc pd dp np lh pe pf nr ll pg ph nt lp pi pj nv pk bi translated">B.为 docker 创建文件夹结构</h2><pre class="od oe of og gt op ok oq or aw os bi"><span id="e954" class="ot ng jj ok b gy ou ov l ow ox">└── dockerfastapi<br/>    ├── Dockerfile<br/>    ├── app<br/>    │   └── main.py<br/>    └── requirements.txt</span></pre><p id="e371" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里<code class="fe oh oi oj ok b">dockerfastapi</code>是我们项目的主文件夹。这是这个文件夹中的不同文件:</p><p id="c1d0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">一、</strong> <code class="fe oh oi oj ok b"><strong class="la jk">requirements.txt</strong></code> <strong class="la jk"> : </strong> Docker 需要一个文件，这个文件告诉它我们的 app 运行需要哪些所有的库。这里我列出了我在 Fastapi API 中使用的所有库。</p><pre class="od oe of og gt op ok oq or aw os bi"><span id="4e7d" class="ot ng jj ok b gy ou ov l ow ox">numpy<br/>opencv-python<br/>matplotlib<br/>torchvision<br/>torch<br/>fastapi<br/>pydantic</span></pre><p id="0e1c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">二。</strong> <code class="fe oh oi oj ok b"><strong class="la jk">Dockerfile</strong></code> <strong class="la jk"> : </strong>第二个文件是 Dockerfile。</p><pre class="od oe of og gt op ok oq or aw os bi"><span id="08c6" class="ot ng jj ok b gy ou ov l ow ox">FROM tiangolo/uvicorn-gunicorn-fastapi:python3.7</span><span id="ac9a" class="ot ng jj ok b gy oy ov l ow ox">COPY ./app /app<br/>COPY requirements.txt .<br/>RUN pip --no-cache-dir install -r requirements.txt</span></pre><p id="0bd8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"><em class="lu">Docker 是如何工作的？:</em> </strong>你可以跳过这一节，但这将有助于了解 docker 是如何工作的。</p><figure class="od oe of og gt iv gh gi paragraph-image"><div class="gh gi pt"><img src="../Images/1825761b13a7eadd9a5ade8a74fa7c2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*YslYlVgBrZrKB2mE8RuP9g.png"/></div></figure><p id="6c4b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">可以把<code class="fe oh oi oj ok b">dockerfile</code>想成类似于<code class="fe oh oi oj ok b">sh file,</code>的东西，它包含创建可以在容器中运行的 docker 映像的命令。人们可以把 docker 映像想象成一个安装了 Python 和 Python 库等所有东西的环境。容器是一个单元，它只是我们系统中一个使用 docker <code class="fe oh oi oj ok b">image</code>的孤立盒子。使用 docker 的好处是，我们可以创建多个 docker 映像，并在多个容器中使用它们。例如，一个图像可能包含 python36，而另一个图像可能包含 python37。我们可以在一台 Linux 服务器上生成多个容器。</p><p id="9917" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们的<code class="fe oh oi oj ok b">Dockerfile</code>包含了几样东西:</p><ul class=""><li id="06ca" class="mk ml jj la b lb lc le lf lh mm ll mn lp mo lt mp mq mr ms bi translated"><code class="fe oh oi oj ok b">FROM</code>命令:这里第一行<code class="fe oh oi oj ok b">FROM</code>指定我们从<code class="fe oh oi oj ok b">tiangolo’s</code> (FastAPI creator) Docker 镜像开始。根据他的网站:“<em class="lu">这个图像有一个“自动调整”机制，这样你就可以添加你的代码，自动获得同样的高性能。【不作牺牲】</em>。我们所做的只是从一个镜像开始，它为我们安装了 python3.7 和<strong class="la jk"> <em class="lu"> </em> </strong>，并自动为<code class="fe oh oi oj ok b">uvicorn</code>和<code class="fe oh oi oj ok b">gunicorn</code> ASGI 服务器添加了一些配置和一个用于 ASGI 服务器的<code class="fe oh oi oj ok b">start.sh</code>文件。对于喜欢冒险的人来说，特别是<code class="fe oh oi oj ok b"><a class="ae jg" href="https://github.com/tiangolo/uvicorn-gunicorn-fastapi-docker/blob/master/docker-images/python3.7.dockerfile" rel="noopener ugc nofollow" target="_blank">commandset</a>1</code>和<code class="fe oh oi oj ok b"><a class="ae jg" href="https://github.com/tiangolo/uvicorn-gunicorn-docker/blob/master/docker-images/python3.7.dockerfile" rel="noopener ugc nofollow" target="_blank">commandset2</a></code>通过一种命令菊花链的方式被执行。</li><li id="af14" class="mk ml jj la b lb mt le mu lh mv ll mw lp mx lt mp mq mr ms bi translated"><code class="fe oh oi oj ok b">COPY</code>命令:我们可以把 docker 镜像看作一个包含文件等的文件夹。在这里，我们将之前创建的<code class="fe oh oi oj ok b">app</code>文件夹和<code class="fe oh oi oj ok b">requirements.txt</code>文件复制到 docker 映像中。</li><li id="e211" class="mk ml jj la b lb mt le mu lh mv ll mw lp mx lt mp mq mr ms bi translated"><code class="fe oh oi oj ok b">RUN</code>命令:我们运行 pip install 命令，使用 docker 映像上的<code class="fe oh oi oj ok b">requirements.txt </code>文件安装所有 python 依赖项。</li></ul><p id="174d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">三。main.py: </strong>这个文件包含了我们之前创建的<code class="fe oh oi oj ok b">fastapiapp.py</code>代码。记住只保留文件名<code class="fe oh oi oj ok b">main.py</code>。</p><h2 id="d827" class="ot ng jj bd nh pa pb dn nl pc pd dp np lh pe pf nr ll pg ph nt lp pi pj nv pk bi translated">C.码头工人建造</h2><p id="4cd9" class="pw-post-body-paragraph ky kz jj la b lb nx kk ld le ny kn lg lh nz lj lk ll oa ln lo lp ob lr ls lt im bi translated">我们已经得到了所需结构的所有文件，但是我们还没有使用任何 docker 命令。我们首先需要使用 Dockerfile 构建一个包含所有依赖项的映像。</p><p id="e9a8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以简单地通过以下方式做到这一点:</p><pre class="od oe of og gt op ok oq or aw os bi"><span id="092f" class="ot ng jj ok b gy ou ov l ow ox">sudo docker build -t myimage .</span></pre><p id="f07b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这将从<code class="fe oh oi oj ok b">tiangolo’s</code>映像下载、复制和安装一些文件和库，并创建一个名为<code class="fe oh oi oj ok b">myimage.</code>的映像。这个<code class="fe oh oi oj ok b">myimage</code>有 python37 和一些由<code class="fe oh oi oj ok b">requirements.txt </code>文件指定的 python 包。</p><figure class="od oe of og gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pu"><img src="../Images/2645ac53e144844a8085de2f7b9f28c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pb6wMffLFPEz5v61dEtEYg.png"/></div></div></figure><p id="cae6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后我们只需要启动一个运行这个图像的容器。我们可以通过以下方式做到这一点:</p><pre class="od oe of og gt op ok oq or aw os bi"><span id="e68c" class="ot ng jj ok b gy ou ov l ow ox">sudo docker run -d --name mycontainer -p 80:80 myimage</span></pre><p id="4b6d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这将创建一个名为<code class="fe oh oi oj ok b">mycontainer</code>的容器，它运行我们的 docker 映像<code class="fe oh oi oj ok b">myimage</code>。部分<code class="fe oh oi oj ok b">80:80</code>将我们的 docker 容器端口 80 连接到我们的 Linux 机器端口 80。</p><figure class="od oe of og gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pv"><img src="../Images/e00285a719f484058ea0b61263c7bf5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Meohd3gCiTCbR3RkXx9Bkw.png"/></div></div></figure><p id="c9bb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">事实上就是这样。此时，您应该能够在浏览器中打开下面的 URL。</p><pre class="od oe of og gt op ok oq or aw os bi"><span id="1f5c" class="ot ng jj ok b gy ou ov l ow ox"># &lt;IPV4 public IP&gt;/docs<br/>URL: 18.237.28.174/docs</span></pre><figure class="od oe of og gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pw"><img src="../Images/477b21b07782061460aabd27f030b321.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KGQCXRHFGfuKXHgiPYUCRg.png"/></div></div></figure><p id="edad" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以通过编程来检查我们的应用程序，使用:</p><pre class="od oe of og gt op ok oq or aw os bi"><span id="dd8e" class="ot ng jj ok b gy ou ov l ow ox">payload = json.dumps({<br/>  "base64str": base64str,<br/>  "threshold": 0.5<br/>})</span><span id="1538" class="ot ng jj ok b gy oy ov l ow ox">response = requests.put("<a class="ae jg" href="http://18.237.28.174/predict" rel="noopener ugc nofollow" target="_blank">http://18.237.28.174/predict</a>",data = payload)<br/>data_dict = response.json()<br/>print(data_dict)</span></pre><figure class="od oe of og gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi px"><img src="../Images/3875092587a05972ec06ff0a65996219.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vPcRDDBQJmGIwBYJbviKWA.png"/></div></div></figure><blockquote class="lv"><p id="80e0" class="lw lx jj bd ly lz py pz qa qb qc lt dk translated">是的，我们的 API 终于部署好了。</p></blockquote><h2 id="ea02" class="ot ng jj bd nh pa qd dn nl pc qe dp np lh qf pf nr ll qg ph nt lp qh pj nv pk bi translated">D.故障排除，因为现实世界并不完美</h2><figure class="od oe of og gt iv"><div class="bz fp l di"><div class="qi po l"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae jg" href="https://giphy.com/gifs/ball-bounce-recovery-HNhz3wGdH62LS/embed" rel="noopener ugc nofollow" target="_blank">来源</a>:因为这就是真实世界部署的样子。</p></figure><p id="1e06" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以上所述都是好的，如果你严格按照说明去做，它们会立即发挥作用，但是现实世界并不是这样的。在这个过程中，您肯定会遇到一些错误，并且需要调试您的代码。因此，为了帮助您，一些 docker 命令可能会派上用场:</p><ul class=""><li id="ba31" class="mk ml jj la b lb lc le lf lh mm ll mn lp mo lt mp mq mr ms bi translated"><strong class="la jk">日志:</strong>当我们使用<code class="fe oh oi oj ok b">sudo docker run</code>运行我们的容器时，我们没有得到很多信息，这是调试时的一个大问题。您可以使用下面的命令查看实时日志。如果您在这里看到一个错误，您将需要更改您的代码并重新构建映像。</li></ul><pre class="od oe of og gt op ok oq or aw os bi"><span id="9a48" class="ot ng jj ok b gy ou ov l ow ox">sudo docker logs -f mycontainer</span></pre><figure class="od oe of og gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi qj"><img src="../Images/95ef33b15297b0c2986380df94a8d8a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Oe6J-_fTKTOStVju_nn1JQ.png"/></div></div></figure><ul class=""><li id="4fd0" class="mk ml jj la b lb lc le lf lh mm ll mn lp mo lt mp mq mr ms bi translated"><strong class="la jk">启动和停止 Docker: </strong>有时候，重启 Docker 可能会有帮助。在这种情况下，您可以使用:</li></ul><pre class="od oe of og gt op ok oq or aw os bi"><span id="d3e8" class="ot ng jj ok b gy ou ov l ow ox">sudo service docker stop<br/>sudo service docker start</span></pre><ul class=""><li id="574f" class="mk ml jj la b lb lc le lf lh mm ll mn lp mo lt mp mq mr ms bi translated"><strong class="la jk">列出图像和容器:</strong>使用 docker，您将最终创建图像和容器，但是您将无法在工作目录中看到它们。您可以使用以下方式列出图像和容器:</li></ul><pre class="od oe of og gt op ok oq or aw os bi"><span id="d3ba" class="ot ng jj ok b gy ou ov l ow ox">sudo docker container ls<br/>sudo docker image ls</span></pre><figure class="od oe of og gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi qk"><img src="../Images/589f4c22ab385f9ab241d462eead39c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tBC3siWbqJGjqSD213Jjnw.png"/></div></div></figure><ul class=""><li id="5d83" class="mk ml jj la b lb lc le lf lh mm ll mn lp mo lt mp mq mr ms bi translated"><strong class="la jk">删除未使用的 docker 图像或容器:</strong>您可能需要删除一些图像或容器，因为它们会占用系统的大量空间。这是你如何做的。</li></ul><pre class="od oe of og gt op ok oq or aw os bi"><span id="8fab" class="ot ng jj ok b gy ou ov l ow ox"># the prune command removes the unused containers and images<br/>sudo docker system prune</span><span id="057c" class="ot ng jj ok b gy oy ov l ow ox"># delete a particular container<br/>sudo docker rm mycontainer</span><span id="9c0c" class="ot ng jj ok b gy oy ov l ow ox"># remove myimage<br/>sudo docker image rm myimage</span><span id="f1d7" class="ot ng jj ok b gy oy ov l ow ox"># remove all images<br/>sudo docker image prune — all</span></pre><ul class=""><li id="789f" class="mk ml jj la b lb lc le lf lh mm ll mn lp mo lt mp mq mr ms bi translated"><strong class="la jk">检查 localhost:</strong>Linux 服务器没有浏览器，但是我们仍然可以看到浏览器的输出，虽然有点难看:</li></ul><pre class="od oe of og gt op ok oq or aw os bi"><span id="0f9a" class="ot ng jj ok b gy ou ov l ow ox">curl localhost</span></pre><figure class="od oe of og gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ql"><img src="../Images/aa18fa069226ef8dc173ae89ded7feb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pn_lMuNHNdtiSgcABiKMcg.png"/></div></div></figure><ul class=""><li id="a0bb" class="mk ml jj la b lb lc le lf lh mm ll mn lp mo lt mp mq mr ms bi translated"><strong class="la jk">开发时不需要一次又一次地重新加载映像:</strong>对于开发来说，只需在我们的机器上更改代码内容并进行现场测试，而不必每次都构建映像，这是非常有用的。在这种情况下，在每次代码更改时自动运行带有实时自动重载的服务器也是很有用的。这里，我们使用 Linux 机器上的应用程序目录，在开发过程中，我们用开发选项<code class="fe oh oi oj ok b">/start-reload.sh</code>替换缺省值(<code class="fe oh oi oj ok b">/start.sh</code>)。一切正常后，我们可以再次构建我们的映像，并在容器中运行它。</li></ul><pre class="od oe of og gt op ok oq or aw os bi"><span id="2e00" class="ot ng jj ok b gy ou ov l ow ox">sudo docker run -d -p 80:80 -v $(pwd):/app myimage /start-reload.sh</span></pre><p id="bd7e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果这还不够，在这里添加一个包含有用的 docker 命令的 docker 备忘单:</p><figure class="od oe of og gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi qm"><img src="../Images/165bc80e90c87aef800c3668178b2294.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QT498j1zpVFoUikG.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae jg" href="http://dockerlabs.collabnix.com/docker/cheatsheet/" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="67ba" class="nf ng jj bd nh ni nj nk nl nm nn no np kp nq kq nr ks ns kt nt kv nu kw nv nw bi translated">4.带有用户界面的端到端应用</h1><p id="e9c2" class="pw-post-body-paragraph ky kz jj la b lb nx kk ld le ny kn lg lh nz lj lk ll oa ln lo lp ob lr ls lt im bi translated">我们已经完成了 API 的创建，但是我们还可以使用 FastAPI 创建一个基于 UI 的应用程序。这不是你在生产环境中要做的事情(在生产环境中，你可能让开发人员使用 react、node.js 或 javascript 来制作应用程序),但这里主要是检查如何使用图像 API 的端到端流程。我将在本地而不是 ec2 服务器上托管这个准系统 Streamlit 应用程序，它将从托管在 ec2 上的 FastAPI API 获取边界框信息和类。</p><p id="9bcf" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你需要了解更多关于 streamlit 是如何工作的，你可以看看这篇<a class="ae jg" rel="noopener" target="_blank" href="/how-to-write-web-apps-using-simple-python-for-data-scientists-a227a1a01582">帖子</a>。此外，如果您想将这个 streamlit 应用程序也部署到 ec2，这里还有一个<a class="ae jg" rel="noopener" target="_blank" href="/how-to-deploy-a-streamlit-app-using-an-amazon-free-ec2-instance-416a41f69dc3">教程</a>。</p><p id="fc49" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是 ec2 上带有 UI 和 FastAPI API 的整个 app 的流程:</p><figure class="od oe of og gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi qn"><img src="../Images/67f1aafd0cbf810cdbbd6dec02e5d5c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VTOlxMJFnPaAid4CXL2lQg.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">项目架构</p></figure><p id="312b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们的 streamlit 应用中，我们需要解决的最重要的问题是:</p><h2 id="1150" class="ot ng jj bd nh pa pb dn nl pc pd dp np lh pe pf nr ll pg ph nt lp pi pj nv pk bi translated">如何使用 Streamlit 从用户处获取图像文件？</h2><p id="6a50" class="pw-post-body-paragraph ky kz jj la b lb nx kk ld le ny kn lg lh nz lj lk ll oa ln lo lp ob lr ls lt im bi translated"><strong class="la jk">答:使用文件上传器:</strong>我们可以通过以下方式使用文件上传器:</p><pre class="od oe of og gt op ok oq or aw os bi"><span id="6dc7" class="ot ng jj ok b gy ou ov l ow ox">bytesObj = st.file_uploader(“Choose an image file”)</span></pre><p id="72e3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下一个问题是，我们从 streamlit 文件上传者那里得到的这个 bytesObj 是什么？在 streamlit 中，我们将从<code class="fe oh oi oj ok b">file_uploader</code>中获得一个<code class="fe oh oi oj ok b">bytesIO</code>对象，我们需要将它转换为 base64str，用于我们的 FastAPI 应用程序输入。这可以通过以下方式实现:</p><pre class="od oe of og gt op ok oq or aw os bi"><span id="12e7" class="ot ng jj ok b gy ou ov l ow ox">def bytesioObj_to_base64str(bytesObj):<br/>   return base64.b64encode(bytesObj.read()).decode("utf-8")</span><span id="6473" class="ot ng jj ok b gy oy ov l ow ox">base64str = bytesioObj_to_base64str(bytesObj)</span></pre><p id="7aa7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> B .使用 URL: </strong>我们也可以使用<code class="fe oh oi oj ok b">text_input</code>从用户那里获得一个图片 URL。</p><pre class="od oe of og gt op ok oq or aw os bi"><span id="10e9" class="ot ng jj ok b gy ou ov l ow ox">url = st.text_input(‘Enter URL’)</span></pre><p id="5721" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，我们可以使用请求模块和 base64 编码和<code class="fe oh oi oj ok b">utf-8</code>解码从 URL 获取 base64 字符串格式的图像:</p><pre class="od oe of og gt op ok oq or aw os bi"><span id="e0ac" class="ot ng jj ok b gy ou ov l ow ox">def ImgURL_to_base64str(url):<br/>    return base64.b64encode(requests.get(url).content).decode("utf-8")</span><span id="a3df" class="ot ng jj ok b gy oy ov l ow ox">base64str = ImgURL_to_base64str(url)</span></pre><p id="0e68" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是我们的 Streamlit 应用程序的完整代码。你已经看到了这篇文章中的大部分代码。</p><figure class="od oe of og gt iv"><div class="bz fp l di"><div class="pn po l"/></div></figure><p id="eead" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以使用以下方式在本地运行这个 streamlit 应用程序:</p><pre class="od oe of og gt op ok oq or aw os bi"><span id="08b5" class="ot ng jj ok b gy ou ov l ow ox">streamlit run streamlitapp.py</span></pre><p id="81a7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以看到在我们的<code class="fe oh oi oj ok b">localhost:8501.</code>上运行的应用程序可以很好地处理用户上传的图像以及基于 URL 的图像。这里有一张猫的图片，也给你们中的一些猫爱好者。</p><div class="od oe of og gt ab cb"><figure class="qo iv qp qq qr qs qt paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><img src="../Images/2fe57ddcb09ab9021fbd1c9de23a4225.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/format:webp/1*rOhKde3MAUzNX3d_HJIPcw.png"/></div></figure><figure class="qo iv qu qq qr qs qt paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><img src="../Images/320ae4844bac05089788888bc2d43bdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*bJfyFxVULA0a6X-kpMpBwA.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk qv di qw qx translated">我们使用所有组件— Streamlit、FastAPI 和 Docker 的最终结果。</p></figure></div><p id="0d2c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">原来如此。我们在这里创建了一个完整的工作流，通过 FastAPI 在 ec2 上部署图像检测模型，并在 Streamlit 中利用这些结果。我希望这能帮助您解决在生产中部署模型的问题。你可以在我的<a class="ae jg" href="https://github.com/MLWhiz/data_science_blogs/tree/master/deployFastApi" rel="noopener ugc nofollow" target="_blank"> GitHub </a>库找到这篇文章的代码以及我所有的文章。</p><p id="588f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我知道你是否喜欢这篇文章，以及你是否愿意在你的日常部署需求中包含 Docker 或 FastAPI 或 Streamlit。我也希望在 Docker 上创建一个更详细的帖子，请关注我，关注我的写作。详情如下。</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="5c9e" class="nf ng jj bd nh ni nj nk nl nm nn no np kp nq kq nr ks ns kt nt kv nu kw nv nw bi translated">继续学习</h1><p id="886d" class="pw-post-body-paragraph ky kz jj la b lb nx kk ld le ny kn lg lh nz lj lk ll oa ln lo lp ob lr ls lt im bi translated">如果你想了解更多关于建立机器学习模型并将其投入生产的知识，AWS 上的这个<a class="ae jg" href="https://coursera.pxf.io/e45BJ6" rel="noopener ugc nofollow" target="_blank">课程可以满足你的要求。</a></p><p id="685e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">谢谢你的阅读。将来我也会写更多初学者友好的帖子。在<a class="ae jg" href="https://medium.com/@rahul_agarwal?source=post_page---------------------------" rel="noopener"> Medium </a>上关注我或者订阅我的<a class="ae jg" href="http://eepurl.com/dbQnuX?source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank">博客</a>来了解他们。一如既往，我欢迎反馈和建设性的批评，可以通过 Twitter <a class="ae jg" href="https://twitter.com/MLWhiz?source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank"> @mlwhiz </a>联系</p><p id="9ffb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，一个小小的免责声明——这篇文章中可能会有一些相关资源的附属链接，因为分享知识从来都不是一个坏主意。</p></div></div>    
</body>
</html>