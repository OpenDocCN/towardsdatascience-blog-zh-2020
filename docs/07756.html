<html>
<head>
<title>Island adventures with T-SQL Window Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用T-SQL窗口函数的孤岛冒险</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/island-adventures-with-t-sql-window-functions-3c2bdf050797?source=collection_archive---------64-----------------------#2020-06-09">https://towardsdatascience.com/island-adventures-with-t-sql-window-functions-3c2bdf050797?source=collection_archive---------64-----------------------#2020-06-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a9c1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用T-SQL窗口函数可以轻松解决传统的“间隙和孤岛”问题</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5f68b97cb30083a4cd91b0f6bd2fdda0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CZCd-968IFqg1hdZKVU_sQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">拉胡尔从<a class="ae ky" href="https://www.pexels.com/photo/clouds-crescent-moon-daylight-glass-2162909/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">派克斯</a>拍摄的照片</p></figure><p id="6878" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最近，我公司的一位业务用户请求我创建一个报告，显示资金周转率大于X值的连续天数。当我开始准备来自SQL Server数据库的数据时，有一些棘手的问题需要解决。</p><h2 id="580d" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">抽样资料</h2><p id="e386" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">为了演示我是如何解决这个问题的，我将使用<em class="mt"/><strong class="lb iu"><em class="mt">栈溢出</em> </strong> <em class="mt"> </em>示例数据库。让我们将业务请求转化为以下内容:找出连续几天有超过50篇帖子并且每篇帖子都有超过50，000次浏览的情况。</p><p id="d4dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">表<em class="mt"> dbo。Posts </em>包含大约1720万行。首先，让我们看看每天有多少帖子的浏览量超过50，000:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="0083" class="lv lw it mv b gy mz na l nb nc">SELECT convert(date,CreationDate) as CreationDate<br/>    ,count(Id) as TotalPosts<br/>FROM Posts <br/>WHERE CreationDate &gt;= '20080731'<br/>    AND CreationDate &lt; '20140101'<br/>        AND ViewCount &gt; 50000<br/>GROUP BY convert(date,CreationDate)<br/>ORDER BY CreationDate</span></pre><p id="0fea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我运行这个查询时，我得到以下结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/6ad0bd718c968a91b149d243e7f00bfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:394/format:webp/1*cMhJx6pNZ-qFySltPoOptg.png"/></div></figure><p id="7ad8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了更好地处理正在运行的查询，我在CreationDate列上创建了一个非聚集索引，包括ViewCount列。现在，当我运行查询来检查有超过50篇帖子、超过50，000次浏览的日期时，我得到了以下结果:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="9a9d" class="lv lw it mv b gy mz na l nb nc">;WITH CTE_POSTS as(<br/>select convert(date,CreationDate) CreationDate<br/>    ,count(Id) totalPosts<br/>from Posts <br/>where CreationDate &gt;= '20080731'<br/>    and CreationDate &lt; '20140101'<br/>    and ViewCount &gt; 50000<br/>group by convert(date,CreationDate)<br/>)<br/><br/>SELECT * <br/>FROM CTE_POSTS<br/>WHERE totalPosts &gt; 50<br/>order by CreationDate</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/8d55eb9ddd6eac57976d203c6aefe7c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/format:webp/1*heYattWSNqw8-C76Oep1BQ.png"/></div></figure><p id="6892" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你所注意到的，从2008年9月15日到9月19日，所有日期都包括在内。然后，第20个和第21个不见了……这个问题就是众所周知的<strong class="lb iu"> <em class="mt">【缺口与孤岛】</em> </strong>问题。在这里，第一桶日期(15日—19日)代表“岛”，20日和21日代表“沟”。</p><h2 id="324c" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">欢迎来到这个岛…</h2><p id="fb87" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">让我们首先确定我们的“岛”(满足标准的连续日期的桶:在我们的例子中，超过50个帖子的日期有50.000以上的浏览量):</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="10c7" class="lv lw it mv b gy mz na l nb nc">; WITH CTE_POSTS as(<br/>SELECT CONVERT(DATE,CreationDate) CreationDate<br/>    ,COUNT(Id) totalPosts<br/>from Posts <br/>WHERE CreationDate &gt;= '20080731'<br/>    AND CreationDate &lt; '20140101'<br/>    AND ViewCount &gt; 50000<br/>GROUP BY convert(date,CreationDate)<br/>HAVING COUNT(Id) &gt; 50<br/>)<br/><br/><br/>,starting as (<br/>SELECT CreationDate<br/>    ,ROW_NUMBER() OVER(ORDER BY CreationDate) rnm<br/>FROM CTE_POSTS as CTE1<br/>WHERE NOT EXISTS (<br/>    SELECT * <br/>    FROM CTE_POSTS as CTE2<br/>    WHERE DATEDIFF(dd,CTE2.CreationDate,CTE1.CreationDate) = 1)<br/>    )<br/><br/>,ending as (<br/>SELECT CreationDate<br/>    ,ROW_NUMBER() OVER(ORDER BY CreationDate) rnm<br/>FROM CTE_POSTS as CTE1<br/>WHERE NOT EXISTS (<br/>    SELECT * <br/>    FROM CTE_POSTS as CTE2<br/>    WHERE DATEDIFF(dd,CTE2.CreationDate,CTE1.CreationDate) = -1)<br/>    )<br/><br/>SELECT s.CreationDate as startingDate<br/>    ,e.CreationDate as endingDate <br/>        ,DATEDIFF(dd,s.CreationDate,e.CreationDate) as ConsecutiveDays<br/>FROM starting s<br/>INNER JOIN ending e on s.rnm = e.rnm</span></pre><p id="3f5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，我们确定了我们的“岛屿”，正如您在下面的截图中看到的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/6f0ad4aa100e558d6ff33cd501a71697.png" data-original-src="https://miro.medium.com/v2/resize:fit:638/format:webp/1*IxGyG8dgboGJTHkgMddfLg.png"/></div></figure><h2 id="8213" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">利用领先/落后优势</h2><p id="6b16" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">如果您运行的SQL Server版本是2012年或更高版本，您可以利用时间偏移函数<em class="mt">超前</em>和<em class="mt">滞后</em>。默认情况下，LEAD将返回序列中的下一个值，但是也可以使用可选参数来调整偏移量，而后者将执行完全相反的操作，即返回序列中的上一个值(默认情况下)。</p><p id="dff3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看<em class="mt"> LEAD </em>在我们的场景中是如何工作的:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="0b80" class="lv lw it mv b gy mz na l nb nc">; WITH CTE_POSTS as(<br/>select CONVERT(DATE,CreationDate) CreationDate<br/>    ,COUNT(Id) totalPosts<br/>FROM Posts <br/>WHERE CreationDate &gt;= '20080731'<br/>    AND CreationDate &lt; '20140101'<br/>    AND ViewCount &gt; 50000<br/>GROUP BY CONVERT(DATE,CreationDate)<br/>HAVING COUNT(Id) &gt; 50<br/>)<br/><br/>,CTE_LEAD AS<br/>(<br/>SELECT CreationDate<br/>    , DATEADD(day, -1 * DENSE_RANK() OVER(ORDER BY CreationDate), CreationDate) AS DateGroup<br/>FROM CTE_POSTS<br/>)<br/><br/>SELECT MIN(CreationDate) AS start_range<br/>    ,MAX(CreationDate) AS end_range<br/>    ,DATEDIFF(dd,MIN(CreationDate),MAX(CreationDate)) AS consecutiveDays<br/>FROM CTE_LEAD<br/>GROUP BY DateGroup;</span></pre><p id="800d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个解决方案更加直观，因为您避免了自连接的复杂性，但是更重要的是，这段代码运行得更快。</p><p id="b96f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我从<em class="mt"> ROW_NUMBER() </em>函数开始，而不是<em class="mt"> DENSE_RANK() </em>。但是，后来我从<strong class="lb iu"> Itzik Ben-Gan </strong>的书<em class="mt">“使用窗口函数的Microsoft SQL Server 2012高性能T-SQL”</em>中找到了一个很好的解释，他在书中阐明了<em class="mt"> DENSE_RANK() </em>保证即使我们的序列中有重复值，代码也会正常工作，而<em class="mt"> ROW_NUMBER() </em>则不会。</p><p id="a18a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果和预期的一样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/4f0984e44d091e93aaee46500b35d2e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:542/format:webp/1*yFl0OZGpSM9RVeMlVzkd5A.png"/></div></figure><h2 id="9d5f" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">寻找差距</h2><p id="b680" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在某些情况下，您希望检查业务请求未得到满足的范围。例如，您希望检查您的销售额低于某个阈值的日期，或者您的系统无法正常工作的日期。</p><p id="73c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的例子中，我将显示不超过50个帖子有50，000以上的浏览量的日期。</p><h2 id="64c9" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">传统T-SQL解决方案</h2><p id="218a" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">与寻找“孤岛”相反，我们需要检查连续的值并检测它们之间的“间隙”在哪里。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="05a9" class="lv lw it mv b gy mz na l nb nc">; WITH CTE_POSTS as(<br/>select CONVERT(DATE,CreationDate) CreationDate<br/>    ,COUNT(Id) totalPosts<br/>FROM Posts <br/>WHERE CreationDate &gt;= '20080731'<br/>    AND CreationDate &lt; '20140101'<br/>    AND ViewCount &gt; 50000<br/>GROUP BY CONVERT(DATE,CreationDate)<br/>HAVING COUNT(Id) &gt; 50<br/>)<br/><br/>SELECT DATEADD(dd,1,CreationDate) AS startDate<br/>    ,DATEADD(dd,-1,(SELECT MIN(t2.CreationDate)<br/>     FROM CTE_POSTS t2<br/>     WHERE t2.CreationDate &gt; t1.CreationDate)) AS endDate<br/>FROM CTE_POSTS t1<br/>WHERE NOT EXISTS (<br/>        SELECT *<br/>    FROM CTE_POSTS t2<br/>    WHERE t2.CreationDate = DATEADD(dd,1,t1.CreationDate)<br/>           AND CreationDate &lt; (SELECT MAX(CreationDate) from CTE_POSTS))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/dcec6211cad02faa00dad47efc56ef45.png" data-original-src="https://miro.medium.com/v2/resize:fit:390/format:webp/1*eLqDh0CC6AGf30rBjGTi_Q.png"/></div></div></figure><h2 id="9b70" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">使用窗口功能变得复杂</h2><p id="8460" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">至于“孤岛”问题，可以实施类似的逻辑来寻找“缺口”。因此，和前面的例子一样，我们将使用<em class="mt"> LEAD </em>函数来实现我们的目标:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="0b73" class="lv lw it mv b gy mz na l nb nc">; WITH CTE_POSTS as(<br/>select CONVERT(DATE,CreationDate) CreationDate<br/>    ,COUNT(Id) totalPosts<br/>FROM Posts <br/>WHERE CreationDate &gt;= '20080731'<br/>    AND CreationDate &lt; '20140101'<br/>    AND ViewCount &gt; 50000<br/>GROUP BY CONVERT(DATE,CreationDate)<br/>HAVING COUNT(Id) &gt; 50<br/>)<br/>,CTE_LEAD AS<br/>(<br/>SELECT CreationDate AS startDate<br/>    , LEAD(CreationDate) OVER(ORDER BY CreationDate) AS endDate<br/>FROM CTE_POSTS<br/>)<br/>SELECT DATEADD(dd, 1, startDate) AS startDate<br/>    ,DATEADD(dd, -1, endDate) endDate<br/>FROM CTE_LEAD<br/>WHERE DATEDIFF(dd, startDate, endDate) &gt; 1;</span></pre><p id="6e2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，有了<em class="mt">的引导</em>，代码更加直观，可读性更好。在这里，我们只是检查连续日期之间的范围，如果它大于1，这意味着我们的序列中有一个缺口。当满足该标准时，我们只是在序列中的最后一个“岛”日期上加一天，以获得第一个“间隔”日期，同时从下一个序列中的第一个“岛”日期减去一天，以获得“间隔”的最后一个日期。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/8d8fd1b7c77ee03f5ff93bc13555982f.png" data-original-src="https://miro.medium.com/v2/resize:fit:402/format:webp/1*aZ33ebzhzLTixrjnU9DnFQ.png"/></div></figure></div></div>    
</body>
</html>