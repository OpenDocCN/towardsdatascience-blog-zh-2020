<html>
<head>
<title>Implementing the Linked List and Selection Sort in python! (from scratch)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 python 实现链表和选择排序！(从头开始)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/implementing-the-linked-list-and-selection-sort-in-python-from-scratch-67434fde5977?source=collection_archive---------14-----------------------#2020-02-08">https://towardsdatascience.com/implementing-the-linked-list-and-selection-sort-in-python-from-scratch-67434fde5977?source=collection_archive---------14-----------------------#2020-02-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/2c28f61b08ebc7ce0ed026edf9e84eac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E1ioMvhxv605YxHpN1agnQ.jpeg"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">信用:PixaBay.com</p></figure><p id="2b56" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在这篇文章中，我将从头开始实现链表，并构建重要的功能，如插入(和 insert_at)、删除、交换和排序。作为数据科学的研究生，我发现大部分材料都集中在机器学习背后的统计学和数学上。毫无疑问，在这里取得成功对数据科学领域的职业生涯至关重要。然而，计算机科学基础的重要性往往被边缘化。</p><h1 id="c1c2" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">那么什么是链表呢？</h1><p id="56ca" class="pw-post-body-paragraph kf kg it kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc im bi translated">链表是一个由节点组成的对象，节点(你猜对了)也是对象。这两者我们都需要实现。每个节点都包含一个值和一个到后续节点的链接。这是强制性的。一个双向链表(我们在这里只涉及定性术语)是一个类似的对象，它的节点也包含到它们之前节点的链接。一个<em class="mg">头</em>是必不可少的。它是链表中的第一个条目。默认情况下，它的下一个节点属性设置为“无”。当我们添加第二个项目时，我们实例化一个节点对象并设置 heads 的 next 属性来引用我们刚刚创建的(新)节点。如果我们向链表中添加第三个节点，我们将实例化一个新的节点对象，并将第二个节点的 next 属性设置为引用新创建的节点。并且对于我们想要插入到链表中的任意数量的值，重复这个过程。</p><p id="bce7" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">当我们想在列表中间插入一个值时，事情变得更加棘手。假设我们有一个由三个元素<code class="fe mh mi mj mk b">0,2,3</code>组成的链表，我们希望将值<code class="fe mh mi mj mk b">1</code>插入到索引位置<code class="fe mh mi mj mk b">1</code>。目前，头部是<code class="fe mh mi mj mk b">0</code>，它的下一个属性引用了<code class="fe mh mi mj mk b">2</code>。我们需要实例化一个节点对象，将值设置为<code class="fe mh mi mj mk b">1</code>。从这里开始，我们需要将头部的 next 属性设置为<code class="fe mh mi mj mk b">1</code>，将<code class="fe mh mi mj mk b">1</code>的 next 属性设置为<code class="fe mh mi mj mk b">2</code>。</p><p id="c975" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">听起来很简单，对吗？您会注意到，为了通过索引到达一个节点，我们需要遍历所有以前的节点，从头部开始。虽然没有明确说明，但是我们需要定义一个名为<code class="fe mh mi mj mk b">get_next()</code>的类方法，它将引用下面的节点。当我们在最后一个节点时会发生什么？除非我们考虑到这一点，否则我们会触发一个错误。有必要考虑链表的长度以及从头部开始我们已经走了多远。我们将通过创建一个名为<code class="fe mh mi mj mk b">count</code>的类属性来做到这一点，它将引用链表的长度或其中最后一项的索引(在这个实现中，我选择了后一个选项。)</p><p id="39f3" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">当我们删除一个值时，我们需要将计数减 1；同样，当我们插入一个值时，我们需要将计数增加 1。当我们交换值时，这个过程变得更加棘手。我们需要删除和插入值；因此，链表中的计数和相对位置可以根据我们执行这些过程的顺序而变化。跟踪我们所处的位置需要注意细节。</p><p id="4b31" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">最困难的任务是对链表进行排序。我选择使用选择排序作为算法的选择。<em class="mg">优秀的排序算法确实存在，</em>但是我们将把重点放在选择排序上，因为它是排序算法中相对简单的。该算法通过建立排序值的索引位置来工作。当我们开始时，这个索引被设置为 0。我们将 selection 设置为后续值，并遍历列表的剩余部分，在和<code class="fe mh mi mj mk b">sorted_idx</code>的右边寻找最小值<em class="mg">。如果一个节点的值小于<code class="fe mh mi mj mk b">selection</code>，那么我们将选择设置为这个值，并跟踪它的索引。遍历链表并找到最小值后，我们删除这个节点，实例化一个值等于选择的新节点，并将这个节点插入到<code class="fe mh mi mj mk b">sorted_idx</code>。最后，我们将<code class="fe mh mi mj mk b">sorted_idx</code>增加 1，并重复直到这个索引等于 count 属性减 1(因为在我们到达最后一个节点后，没有节点可遍历。)</em></p><p id="e4db" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">您会注意到，这个过程从将<code class="fe mh mi mj mk b">sorted_idx</code>设置为 0 开始，并将<code class="fe mh mi mj mk b">selection</code>设置为紧跟着头部的节点的值。在 head 是最大值的情况下，当进程终止时，它将被推到列表的末尾，这没有问题。但如果头不是最大值，还是会被推到底；但这是一个不完整的排序。我们需要构建最后一个步骤来计算最后一个条目的值，并遍历整个链表。在每一步，节点的值将与最终条目进行比较。如果大于节点的值，我们将遍历到下一个节点并再次比较。这个过程一直重复，直到我们到达一个节点，这个节点的值大于条目的最终值，这是我们前面提到的。当达到一个更高的值时(并且因为所有先前的值都更小)，我们现在知道最后一个条目的真正家<em class="mg">在哪里。我们删除最后一个条目，并将其值插入索引中，直到第一个值大于我们的选择。如果我们遍历列表的长度(除了最后一个条目)，并且所有的值都较小，那么我们可以有把握地得出结论，最后一个条目是最大值，并且已经在它适当的位置。咻！</em></p><p id="43eb" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">让我们来看看代码！</p><figure class="ml mm mn mo gt ju"><div class="bz fp l di"><div class="mp mq l"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae mr" href="https://gist.github.com/jdmoore7/6f9fbc76139ddb0c7d485f97349b3bbf" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/jdmoore 7/6 F9 FBC 76139 DDB 0 c 7d 485 f 97349 B3 bbf</a></p></figure><p id="5389" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">完整的资源库可以在这里找到:<a class="ae mr" href="https://github.com/jdmoore7/linked_list/blob/master/LinkedList.py" rel="noopener ugc nofollow" target="_blank">https://github . com/jdmoore 7/linked _ list/blob/master/linked list . py</a></p><p id="ed4f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">感谢阅读！</p></div></div>    
</body>
</html>