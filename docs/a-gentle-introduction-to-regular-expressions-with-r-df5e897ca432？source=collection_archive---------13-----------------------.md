# R 正则表达式的简明介绍

> 原文：<https://towardsdatascience.com/a-gentle-introduction-to-regular-expressions-with-r-df5e897ca432?source=collection_archive---------13----------------------->

## 教程| R |正则表达式(Regex)

## 正则表达式是数据科学家对付非结构化文本最强大的武器

![](img/bfcde32937a7183c20fa182f146a5a49.png)

蒂姆·柯林斯在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

我们生活在一个以数据为中心的时代。数据已被描述为[新油](https://www.wired.com/insights/2014/07/data-new-oil-digital-economy/)。但是就像石油一样，原始数据并不总是有用的。一种在其原始形式下特别难以使用的数据形式是 [**非结构化数据**](https://www.datamation.com/big-data/structured-vs-unstructured-data.html) 。

很多数据是非结构化数据。非结构化数据不太适合分析格式，比如 Excel 电子表格或[数据框](https://www.tutorialspoint.com/r/r_data_frames.htm)。文本数据是一种常见的非结构化数据，这使得它很难处理。输入**正则表达式**，简称 **regex** 。一开始它们可能看起来有点吓人，但是一旦你开始使用，使用它们将会很容易！

> 更适应 python？请尝试我的教程来使用 python 的正则表达式:

[](/a-gentle-introduction-to-regular-expressions-with-python-4f3fce46dcb4) [## Python 正则表达式的简明介绍

### 正则表达式是数据科学家对付非结构化文本最强大的武器

towardsdatascience.com](/a-gentle-introduction-to-regular-expressions-with-python-4f3fce46dcb4) 

# `stringr`图书馆

我们将使用`stringr`库。`stringr`库是基于 C 库构建的，所以它的所有功能都非常快。

要在 R 中安装和加载`stringr`库，使用以下命令:

看到多简单了吗？更简单的是，`stringr`包中的大多数函数名都以`str`开头。让我们来看看本模块中提供的几个功能:

1.  `str_extract_all(string, pattern)`:该函数返回一个包含`string`中`pattern`所有实例的向量列表
2.  `str_replace_all(string, pattern, replacement)`:该函数返回`string`，将`string`中的`pattern`实例替换为`replacement`

您可能已经使用过这些功能。他们有非常简单的应用程序，不需要添加正则表达式。回想一下社交距离之前的时代，想象一次公园里的野餐，就像上面的图片。这里有一个例子，是每个人带去野餐的东西。我们可以用它来演示 regex 函数的基本用法:

```
basicString <- "Drew has 3 watermelons, Alex has 4 hamburgers, Karina has 12 tamales, and Anna has 6 soft pretzels"
```

如果我想从这个字符串中提取一个人名字的每个实例，我只需将名字和`basic_string`传递给`str_extract_all()`:

结果将是一个包含该模式所有实例的列表。使用这个例子，`basicExtractAll`将有下面的列表，其中 1 个向量作为输出:

```
[[1]]
[1] "Drew"
```

现在让我们想象一下，亚历克斯把他的 4 个汉堡包忘在野餐的地方，被肖恩偷走了。`str_replace_all`可以用 Shawn 替换 Alex 的任何实例:

结果字符串将显示*肖恩*现在有 4 个汉堡。多么幸运的家伙🍔。

```
"Drew has 3 watermelons, Shawn has 4 hamburgers, Karina has 12 tamales, and Anna has 6 soft pretzels"
```

到目前为止，这些例子都很基本。他们有一个时间和地点，但是如果我们想知道野餐中总共有多少食物呢？有物品的都是些什么人？如果我们需要数据框中的这些数据来进行进一步分析，该怎么办？这就是你开始看到 regex 的好处的地方。

# 正则表达式词汇

驱动正则表达式的有几个概念:

1.  字符集
2.  元字符
3.  量词
4.  捕获组

这不是一个详尽的列表，但足以帮助我们立即行动。

## 字符集

字符集表示括号内的选项，正则表达式只匹配其中一个选项。我们可以对字符集做很多事情:

*   匹配一组**字符**:我们可以通过将每个元音放在括号中找到字符串中的所有元音，例如`[aeiou]`

```
[[1]]
 [1] "e" "a" "a" "e" "e" "o" "e" "a" "a" "u" "e" "a" "i" "a"
[15] "a" "a" "a" "e" "a" "a" "a" "o" "e" "e"
```

*   匹配一个**范围的字符**:我们可以通过使用**连字符**、`[A-F]`找到从“A”到“F”的任何**大写字母**。字符集**区分大小写**，因此`[A-F]`与`[a-f]`不同

```
[[1]]
[1] "D" "A" "K" "A"
```

*   匹配一个**范围的数字**:我们可以通过添加数字到我们的字符集中来查找一个范围内的数字，`[0-9]`来查找任何数字。请注意，这些数字是作为字符串提取的，而不是转换成数字

```
[[1]]
[1] "3" "4" "1" "2" "6"
```

字符集可以同时包含这一部分的所有内容，所以类似于`[A-Ct-z7-9]`的内容仍然有效。它将匹配从大写字母“A”到大写字母“C”、小写字母“t”到小写字母“z”以及 7 到 9 的所有字符。

到目前为止，我们还不能回答之前提出的关于括号组的任何问题。让我们为我们的正则表达式库添加更多的武器。

## 元字符

元字符代表一种类型的字符。它们通常以反斜杠`\`开头。由于反斜杠`\`是 R 中的一个特殊字符，每次和另一个反斜杠一起使用时都需要进行转义。换句话说， **R 在使用元字符**时需要 2 个反斜杠。每个元字符将匹配单个字符。以下是一些最重要的例子:

*   `\\s`:这个元字符代表**空格**。这将匹配每个空格、制表符和换行符。您还可以分别为制表符和换行符指定`\\t`和`\\n`。附注:我们的示例字符串没有任何制表符，但是在寻找它们时要小心。许多[集成开发环境](https://www.codecademy.com/articles/what-is-an-ide)或 IDE 都有一个设置，当你输入时，它会用空格替换所有的制表符。在示例字符串中，`\\s`返回一个包含 17 个空格的向量列表，这是示例字符串中空格的确切数目！

```
[[1]]
 [1] " " " " " " " " " " " " " " " " " " " " " " " " " " " "
[15] " " " " " "
```

*   `\\w`:该元字符代表**字母数字字符**。这包括所有字母 a-z，大写和小写，以及数字 0-9。这相当于括号组`[A-Za-z0-9]`，只是写起来更快。记住`\\w`元字符本身只捕获单个字符，而不是整个单词或数字。你会在例子中看到。不要担心，我们将在下一节处理这个问题。

```
[[1]]
 [1] "D" "r" "e" "w" "h" "a" "s" "3" "w" "a" "t" "e" "r" "m"
[15] "e" "l" "o" "n" "s" "A" "l" "e" "x" "h" "a" "s" "4" "h"
[29] "a" "m" "b" "u" "r" "g" "e" "r" "s" "K" "a" "r" "i" "n"
[43] "a" "h" "a" "s" "1" "2" "t" "a" "m" "a" "l" "e" "s" "a"
[57] "n" "d" "A" "n" "n" "a" "h" "a" "s" "6" "s" "o" "f" "t"
[71] "p" "r" "e" "t" "z" "e" "l" "s"
```

*   `\\d`:该元字符代表**数字**。使用我们的野餐例子，看看它如何只找到字符串中的数字。你会注意到，像括号组一样，它选取 5 个数字，而不是我们期望的 4 个。这是因为它寻找的是每个单独的数字，而不是一组数字。接下来我们将看到如何用量词来解决这个问题。

```
[[1]]
[1] "3" "4" "1" "2" "6"
```

## 量词

正如我们在上一节中看到的，单个元字符的功能有限。当涉及到单词或数字时，**我们通常希望一次找到 1 个以上的字符**。这就是量词的用武之地。它们允许你量化你期望的字符数量。他们总是在被量化的人物之后出现，有几种类型:

*   `+`量化 1 个或多个匹配。让我们看一个新的例子来开发一些关于每个量词将返回什么的直觉:`quantExample`

当我们在`quantExample`上使用`+`量词时，它将返回 4 个匹配。提到 regex 寻找非重叠匹配是一个很好的理由。在这种情况下，它会查看每个 B 及其后面的字符。因为我们使用了`+`量词，所以它继续匹配，直到到达一组 B 的末尾。

```
[[1]]
[1] "B"    "BB"   "BBB"  "BBBB"
```

*   `{}`量化特定数量或范围的匹配。当像`{2}`这样书写时，它将精确匹配前面的 2 个字符。我们会看到一些有趣的结果。它找到了 4 根火柴。这是因为它正在寻找每个不重叠的 2 B 组。第 1 组中有一个匹配，第 2 组中只有 1 个非重叠匹配，第 4 组中有 2 个非重叠匹配。

```
[[1]]
[1] "BB" "BB" "BB" "BB"
```

当写成类似`{2,4}`的形式时，它将匹配出现 2 到 4 次的任意数量的 B。注意，在正则表达式中放一个空格是无效的。它将返回一个空列表。

```
[[1]]
[1] "BB"   "BBB"  "BBBB"
```

我们也可以写这个量词，像`{2,}`一样省略上界。这将匹配 2 个或更多实例。对于`quantExample`，它将返回与`{2,4}`完全相同的结果。

*   `*`量化零个或多个匹配项**。这在我们寻找可能在字符串中也可能不在字符串中的东西时很有帮助。**

`*`量词单独使用时会返回一些奇怪的匹配，所以我们可以省略一个用`quantExample`的例子。我们将在下面的例子中看到，当某人在我们的野餐中带来一个有多个单词名称的食物时，它是如何应用的。没有它，我们就不会正确地捕捉到安娜带来了软椒盐卷饼！

让我们结合目前所知的字符集、元字符和量词来回答一些关于我们的野餐字符串的问题。我们想知道字符串中的所有单词，以及字符串中的数字。

对于单词，我们可以使用一个全部大写和小写字母的字符集，给它添加一个`+`量词。这将找到任何长度的字母字符组合在一起。换句话说，它会找到所有的单词。Regex 看起来越来越有用了。

```
[[1]]
 [1] "Drew"        "has"         "watermelons" "Alex"       
 [5] "has"         "hamburgers"  "Karina"      "has"        
 [9] "tamales"     "and"         "Anna"        "has"        
[13] "soft"        "pretzels"
```

为了找到每种食物的数量，我们可以使用`\\d`元字符和量词`{1,2}`。这将查找长度为 1 或 2 个字符的数字组。这是一个更有用的输出，因为我们有同样数量的食物和人！

```
[[1]]
[1] "3"  "4"  "12" "6"
```

为了找到每种食物的数量和名称，我们可以将量词和元字符结合起来。我们知道每个数字后面都有一个食物项目，所以我们可以添加到前面的例子中。我们知道有一个空格和一个单词(`\\s\\w+`)后面可以跟另一个单词，比如“软椒盐卷饼”是如何出现的。要指定第二个词可能不在那里，我们可以用量词`*`与第二个词连用。就像这样，我们有一份清单，上面列有野餐中所有物品的数量和名称。

```
[[1]]
[1] "3 watermelons"   "4 hamburgers"    "12 tamales"     
[4] "6 soft pretzels"
```

## 捕获组

捕获组允许您查找整个短语，并且只返回其中的一部分。以我们的例子为例，我需要每个人的名字，他们带了什么，带了多少。到目前为止，我们一直使用`str_extract_all`。它有一个清晰的输出，对于我们的例子来说很容易阅读，但是它实际上不能与捕获组一起工作。有帮助的是，`stringr`提供了`str_match_all`，它确实可以与捕获组一起工作。但是，它输出的结果是包含矩阵的列表，而不是包含向量的列表。

```
[[1]]
     [,1]
[1,] "Drew has 3 watermelons"
[2,] "Alex has 4 hamburgers"
[3,] "Karina has 12 tamales"
[4,] "Anna has 6 soft pretzels"
```

我们在`captureGroup1`中使用的正则表达式正在寻找一个名称，它以一个大写字母开始，后面有任意数量的小写字母(`[A-Z][a-z]+`)。然后在一个空格之后，它匹配模式空格、单词、空格`\\s\\w+\\s`。接下来，我们寻找一个 1 到 2 位数的数字，后跟一个空格和一个单词(`\\d{1,2}\\s\\w+`)。您可以在输出中看到矩阵的每一行都是一个字符串，包含每个人的详细信息。

现在，这是从我们开始的地方迈出的一大步，但我们并不真正关心“有”这个词，我们希望能够从数量中制作一个数据框。让我们添加捕获组。通过使用捕获组，我们可以返回一个矩阵，其中每一列包含一条特定的信息。我们将创建包含每个名称、数量和项目的捕获组。捕获组只是用括号括起来的正则表达式的一部分。

```
[[1]]
     [,1]                       [,2]     [,3]  [,4]
[1,] "Drew has 3 watermelons"   "Drew"   "3"   "watermelons"
[2,] "Alex has 4 hamburgers"    "Alex"   "4"   "hamburgers"
[3,] "Karina has 12 tamales"    "Karina" "12"  "tamales"
[4,] "Anna has 6 soft pretzels" "Anna"   "6"   "soft pretzels"
```

矩阵中的第一列包含整个正则表达式，忽略了捕获组。矩阵的其余列分别对应于我们为名称、数量和项目定义的捕获组。

# 将我们的文本合并到一个数据框中

在进行数据分析时，最有用的 R 数据结构之一是数据帧。毫无疑问，如果你点击了这篇文章，你就已经知道了。数据框支持计算列统计数据和绘制数据等功能。因为我们有一个包含所有我们想要的信息的矩阵，把它转换成一个数据框架并不太难。除了矩阵的第一列，我们将对所有内容使用`data.frame`函数。`data.frame`给出了默认的列名，所以我们将修改它们以匹配每一列中的内容。

关于符号的一个快速注释:在`captureGroup2` ( `[[1]]`)之后的第一组括号访问列表的第一个元素，我们的矩阵。第二组括号(`[,-1]`)选择除第一行以外的所有行和列。

```
|   | Name   | Quantity | Item          |
| - | ------ | -------- | ------------- |
| 1 | Drew   | 3        | watermelons   |
| 2 | Alex   | 4        | hamburgers    |
| 3 | Karina | 12       | tamales       |
| 4 | Anna   | 6        | soft pretzels |
```

# 结论和进一步学习

我们只讨论了 regex 如何帮助处理非结构化文本数据的一小部分。这是一个很好的入门基础，但是不久之后你将需要知道一些概念，比如如何找到除了一个字符之外的所有内容(否定)，或者找到紧接在其他内容之前或之后的内容(环视)。你可以在我的后续文章中了解这些:

[](https://medium.com/@atseewal/anchors-away-more-regex-concepts-in-r-f00fe7f07d52) [## 起锚！R 中更多的正则表达式概念

### 更先进的正则表达式工具，为您的 R 文本争论武器库

medium.com](https://medium.com/@atseewal/anchors-away-more-regex-concepts-in-r-f00fe7f07d52) 

这里有更多的资源可以帮助您了解 regex 中的其他概念:

*   [tidy verse 网站](https://stringr.tidyverse.org/index.html)官方 `[stringr](https://stringr.tidyverse.org/index.html)` [页面:](https://stringr.tidyverse.org/index.html) [RStudio](https://rstudio.com/) 的伙计们整理了资源帮助学习`stringr`之类的软件包。他们甚至包括一个`[stringr](https://github.com/rstudio/cheatsheets/blob/master/strings.pdf)` [备忘单](https://github.com/rstudio/cheatsheets/blob/master/strings.pdf)，你可以打印出来参考。
*   [R for Data Science](https://r4ds.had.co.nz/strings.html) :作者 Hadley Wickham，`stringr` package 的作者，这本书对于 R 中的任何东西都是一个很好的参考。甚至有一章涵盖了 R 中更高级的正则表达式。它可以在网上免费获得[这里](https://r4ds.had.co.nz/strings.html)，或者你可以在这里购买硬拷贝[。*免责声明:我通过此链接收到您购买的佣金*。](https://amzn.to/2QUBYaG)
*   [Datacamp 课程](https://www.datacamp.com/join-me/ODczNDQ5):一个致力于数据科学、机器学习和数据可视化的在线学习社区。查看他们的课程“用 r 中的 stringr 进行字符串操作”，网站上每个课程的第一章都是免费的！*免责声明:如果您使用* [***此***](https://www.datacamp.com/join-me/ODczNDQ5) *链接注册每月 Datacamp 订阅，您将获得订阅折扣，我将获得佣金。在你学习的同时支持我的写作！*

[](https://realdrewdata.medium.com/membership) [## 通过我的推荐链接加入 Medium-Drew Seewald

### 作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…

realdrewdata.medium.com](https://realdrewdata.medium.com/membership)