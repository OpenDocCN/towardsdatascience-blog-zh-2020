<html>
<head>
<title>What Makes a Song Great? Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">是什么让一首歌伟大？第一部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/rollingstone-for-medium-f1f638b9568e?source=collection_archive---------49-----------------------#2020-07-23">https://towardsdatascience.com/rollingstone-for-medium-f1f638b9568e?source=collection_archive---------49-----------------------#2020-07-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="7bb9" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/what-makes-a-song-great" rel="noopener" target="_blank">什么让一首歌变得伟大</a></h2><div class=""/><div class=""><h2 id="50a6" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">使用 Selenium 和 BeautifulSoup 在 Python 中动态抓取生成的内容</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/90c37e738bc6e02bdeafeb5183184310.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-A5AeHRA5634sX4h"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">Natalie Cardona 在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="5215" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja">【这是</strong> <a class="ae le" href="https://towardsdatascience.com/tagged/what-makes-a-song-great" rel="noopener" target="_blank"> <strong class="lh ja">系列三篇文章中的第一篇</strong></a><strong class="lh ja"/></p><h2 id="ba76" class="mb mc iq bd md me mf dn mg mh mi dp mj lo mk ml mm ls mn mo mp lw mq mr ms iw bi translated">Web 抓取、可视化、列表理解、正则表达式、熊猫！这个项目拥有一切——包括泡菜！</h2><p id="232b" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated"><em class="my">【2020 年 9 月 1 日更新:自本文首次发表以来，《滚石》已将源代码改为其页面。因此，我已经更新了代码，允许检索动态生成的内容。】</em></p><p id="c85a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">一旦你学会了一些编码和基本的数据科学技能，标准的建议是去做项目，做很多项目。不幸的是，我们中的许多人很难找到这样的项目。</p><p id="1d32" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">前几天我在翻<em class="my">滚石</em>的<a class="ae le" href="https://www.rollingstone.com/music/music-lists/500-greatest-songs-of-all-time-151127/" rel="noopener ugc nofollow" target="_blank"> <em class="my">有史以来最伟大的 500 首歌</em> </a>的榜单。我开始问自己:‘谁的歌在榜单上最多？或者:“会偏向于过去几十年，因为这些评论家可能还不到 20 多岁？”？。在我开始这个项目的第二天，我就一直在寻找一个能够让我将一些<strong class="lh ja">网络搜集</strong>技术与一些探索性数据分析(<strong class="lh ja"> EDA </strong>)结合起来的项目。我从中获得了很多乐趣:我希望通过分享它，你也能学到一些东西并从中获得乐趣。</p><p id="8781" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我将在这里展示的是许多库、工具和技能集:这是一个端到端的项目，从数据检索开始，到可视化结束，涉及解析、清理和分析数据。我们将涉及的一些内容:</p><ul class=""><li id="4d82" class="mz na iq lh b li lj ll lm lo nb ls nc lw nd ma ne nf ng nh bi translated">网页抓取(使用<code class="fe ni nj nk nl b">BeautifulSoup</code>和<code class="fe ni nj nk nl b">Selenium</code></li><li id="192c" class="mz na iq lh b li nm ll nn lo no ls np lw nq ma ne nf ng nh bi translated">正则表达式(使用 Python 的<code class="fe ni nj nk nl b">re</code>模块)</li><li id="51a3" class="mz na iq lh b li nm ll nn lo no ls np lw nq ma ne nf ng nh bi translated">API(即 Spotify 的)(使用<code class="fe ni nj nk nl b">spotipy</code>)</li><li id="0986" class="mz na iq lh b li nm ll nn lo no ls np lw nq ma ne nf ng nh bi translated">数据分析和可视化(用<code class="fe ni nj nk nl b">pandas</code>和<code class="fe ni nj nk nl b">matplotlib</code>)。</li></ul><p id="71cf" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我会认为这个项目适合高级初学者到中级程序员。它本身并不复杂:但它确实涉及许多不同的领域。注意，HTML 和 CSS 的一些非常基础的知识对于第一部分可能是有用的。</p><h2 id="9a53" class="mb mc iq bd md me mf dn mg mh mi dp mj lo mk ml mm ls mn mo mp lw mq mr ms iw bi translated">网络搜集:获取数据并清理数据</h2><p id="fcfc" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">首先，让我们导入我们需要的库。</p><pre class="kp kq kr ks gt nr nl ns nt aw nu bi"><span id="7dfb" class="mb mc iq nl b gy nv nw l nx ny"># webscraping libraries<br/>import urllib # to retrieve web pages<br/>from bs4 import BeautifulSoup # to parse web pages<br/>from selenium import webdriver # to retrieve dynamically generated content<br/>import time  # allows us to wait before scraping or interacting with web pages</span><span id="1cbb" class="mb mc iq nl b gy nz nw l nx ny"># data, cleaning, analysis and visualization<br/>import pandas as pd # the goto python library for data cleaning and analysis<br/>import matplotlib.pyplot as plt # the goto python library for data visualization<br/>import seaborn as sns # data visualization (but nicer!)<br/>import re # Python's library for regular expressions (see more below)</span><span id="a406" class="mb mc iq nl b gy nz nw l nx ny"># to interact with Spotify's API<br/>import spotipy # to query Spotify's API<br/>from spotipy.oauth2 import SpotifyClientCredentials # for API login<br/></span><span id="a8df" class="mb mc iq nl b gy nz nw l nx ny"># display charts in jupyter notebook<br/>%matplotlib inline</span></pre><h2 id="62aa" class="mb mc iq bd md me mf dn mg mh mi dp mj lo mk ml mm ls mn mo mp lw mq mr ms iw bi translated">第一步:用硒和美丽的汤刮动态生成的内容</h2><p id="afa8" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">打开浏览器，导航至<a class="ae le" href="https://www.rollingstone.com/music/music-lists/500-greatest-songs-of-all-time-151127/" rel="noopener ugc nofollow" target="_blank">我们的列表</a>。首先，请注意，该列表是以 50 为一组进行“分批”的。这告诉我们，一旦我们开始抓取，我们可能需要迭代不同的地址来获取我们的数据——稍后将详细介绍。</p><p id="18ef" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">向下滚动我们找到我们的歌曲。我们要检索五类数据:</p><ul class=""><li id="ab7d" class="mz na iq lh b li lj ll lm lo nb ls nc lw nd ma ne nf ng nh bi translated">艺术家</li><li id="43d1" class="mz na iq lh b li nm ll nn lo no ls np lw nq ma ne nf ng nh bi translated">歌曲名称</li><li id="3ab8" class="mz na iq lh b li nm ll nn lo no ls np lw nq ma ne nf ng nh bi translated">作者</li><li id="a110" class="mz na iq lh b li nm ll nn lo no ls np lw nq ma ne nf ng nh bi translated">生产者</li><li id="7f6f" class="mz na iq lh b li nm ll nn lo no ls np lw nq ma ne nf ng nh bi translated">发布日期</li></ul><p id="7738" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">如果你<code class="fe ni nj nk nl b">ctrl-click</code>(在 Mac 上)点击页面的一个元素，并从弹出的菜单中选择<strong class="lh ja">检查</strong>，你会看到相应的 HTML 高亮显示。在这种情况下，要获得艺术家和歌曲的标题，我们需要查找标签为<code class="fe ni nj nk nl b">&lt;h2&gt;</code>的元素，该元素属于类<code class="fe ni nj nk nl b">c-gallery_vertical-album__title</code>。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oa"><img src="../Images/6369f32af4d07e170edd0b5bee0a3053.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X2KA4Tnyb_X0192qcZzcYg.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">检查 web 元素</p></figure><p id="e6dd" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">通常，我们会使用<code class="fe ni nj nk nl b">urllib</code>检索页面，并使用参数<code class="fe ni nj nk nl b">html.parser</code>将结果传递给<a class="ae le" href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/" rel="noopener ugc nofollow" target="_blank">beautiful soup</a>:BeatifulSoup 会解析我们检索到的 HTML，并允许我们找到使用<code class="fe ni nj nk nl b">find_all</code>方法识别的元素。<br/>然而，事实证明页面是动态生成的(如果你查看源代码，你不会发现任何这些元素)。因此，首先我们将使用<code class="fe ni nj nk nl b"><a class="ae le" href="https://selenium-python.readthedocs.io" rel="noopener ugc nofollow" target="_blank">Selenium</a></code>来模拟浏览器打开页面，然后才检索内容。</p><pre class="kp kq kr ks gt nr nl ns nt aw nu bi"><span id="14ce" class="mb mc iq nl b gy nv nw l nx ny">def get_page_source(url):<br/>    """<br/>    Input: a str (the target url)<br/>    Returns: a Beautiful Soup object (the parsed page source)<br/>    -----------------------------------------------------------------------<br/>    Retrieves the target page's contents and passes them to Beautiful Soup.<br/>    -----------------------------------------------------------------------<br/>    """<br/>    options = webdriver.ChromeOptions()<br/>    options.add_argument('--ignore-certificate-errors')<br/>    options.add_argument('--incognito')<br/>    options.add_argument('--headless')<br/>    driver = webdriver.Chrome(options=options)<br/>    time.sleep(10) # sleep for 10s to allow the page to load<br/>    target_page = url<br/>    driver.get(target_page) <br/>    page_source = driver.page_source #get the contents<br/>    soup =  BeautifulSoup(page_source)<br/>    driver.quit() # close the driver<br/>    return soup</span><span id="54d2" class="mb mc iq nl b gy nz nw l nx ny">target_url ="https://www.rollingstone.com/music/music-lists/500-greatest-songs-of-all-time-151127/smokey-robinson-and-the-miracles-shop-around-71184/"<br/>soup = get_page_source(target_url) # pass the HTML contents to Beautiful Soup for parsing.</span></pre><p id="bb32" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">现在使用 Beautiful Soup 的<code class="fe ni nj nk nl b">find_all</code>方法，并传递适当的 CSS 标识符，我们就可以检索到我们定位的所有项目。</p><pre class="kp kq kr ks gt nr nl ns nt aw nu bi"><span id="a50c" class="mb mc iq nl b gy nv nw l nx ny">song_all = soup.find_all('h2', {'class':'c-gallery-vertical-album__title'})<br/>song_all[0]</span><span id="576a" class="mb mc iq nl b gy nz nw l nx ny">&lt;h2 class="c-gallery-vertical-album__title"&gt;Smokey Robinson and the Miracles, 'Shop Around'&lt;/h2&gt;</span></pre><p id="5d10" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">好吧，我们有进展了。让我们进一步挖掘。</p><h2 id="f8c8" class="mb mc iq bd md me mf dn mg mh mi dp mj lo mk ml mm ls mn mo mp lw mq mr ms iw bi translated">第二步:用正则表达式清理</h2><p id="3e19" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">列表项不仅包含我们正在寻找的数据，还包含 HTML 标签。为了只获取数据，我们使用<code class="fe ni nj nk nl b">get_text()</code>如下:</p><pre class="kp kq kr ks gt nr nl ns nt aw nu bi"><span id="89fd" class="mb mc iq nl b gy nv nw l nx ny">song_all[0].get_text()</span><span id="44cc" class="mb mc iq nl b gy nz nw l nx ny">"Smokey Robinson and the Miracles, 'Shop Around'"</span></pre><p id="c9ea" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">可恶。很多格式，空白，额外的引号。我选择通过<code class="fe ni nj nk nl b">re</code>模块使用<a class="ae le" href="https://en.wikipedia.org/wiki/Regular_expression" rel="noopener ugc nofollow" target="_blank">正则表达式</a>或<em class="my"> Regex </em>来清理数据。</p><p id="4a1d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">RegEx 是一种功能强大的微编程语言，对于搜索字符串中的字符模式非常有价值。它有一个相当陡峭的学习曲线，所以我尽量经常使用它:正如他们所说:练习，练习，练习！(点击下面的正则表达式介绍)。</p><div class="ob oc gp gr od oe"><a href="https://medium.com/better-programming/introduction-to-regex-8c18abdd4f70" rel="noopener follow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd ja gy z fp oj fr fs ok fu fw iz bi translated">正则表达式简介</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">使用 Python 逐步介绍正则表达式</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">medium.com</p></div></div><div class="on l"><div class="oo l op oq or on os ky oe"/></div></div></a></div></div><div class="ab cl ot ou hu ov" role="separator"><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy"/></div><div class="ij ik il im in"><pre class="kp kq kr ks gt nr nl ns nt aw nu bi"><span id="1bfd" class="mb mc iq nl b gy nv nw l nx ny">def strip_extra_chars(line):<br/>    """<br/>    Strips non-alphanumerical, whitespace and newline characters away from string<br/>    """<br/>    line = line.get_text()<br/>    line = re.sub("\A\S[^a-zA-z0-9]", "", line) # remove any non-whitespace non-alphanumeric character from the beginning of the line<br/>    line = re.sub("[’‘]", "", line).strip() # get rid of extra quotes and remove whitespace with .strip()<br/>    line = re.sub("\n", "", line) # get rid of newlines<br/>    return line.strip()</span></pre><p id="4de7" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">函数<code class="fe ni nj nk nl b">strip_extra_chars</code>将从我们的数据中提取一行，去掉所有的垃圾，包括那些讨厌的引号。更多细节见函数中的注释，试试<a class="ae le" href="https://regex101.com" rel="noopener ugc nofollow" target="_blank">这个</a>是测试和学习 RegEx 的好资源。</p><h2 id="80fc" class="mb mc iq bd md me mf dn mg mh mi dp mj lo mk ml mm ls mn mo mp lw mq mr ms iw bi translated">步骤 3:遍历列表</h2><p id="8293" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">我们差不多完成了。还记得一开始我们注意到我们的网页只包含 50 首歌曲，因此我们需要迭代内容吗？如果我们通过顶部导航菜单上的<code class="fe ni nj nk nl b">ctrl-clicking</code>再次检查页面，我们会发现它指向我们需要的 URL。这里我们定义了一个<code class="fe ni nj nk nl b">get_links</code>函数，它将 URL 存储在一个列表中。</p><p id="bc89" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">然后，我们可以轻松地遍历列表并检索所有数据。</p><pre class="kp kq kr ks gt nr nl ns nt aw nu bi"><span id="1f0a" class="mb mc iq nl b gy nv nw l nx ny">def get_links(url):<br/>    options = webdriver.ChromeOptions()<br/>    options.add_argument('--ignore-certificate-errors')<br/>    options.add_argument('--incognito')<br/>    options.add_argument('--headless')<br/>    options.add_argument("--start-maximized");<br/>    driver = webdriver.Chrome(options=options)<br/>    # note that in order to get all the urls we need to set the browser's window to max size<br/>    driver.set_window_size(1024, 768) <br/>    time.sleep(10) # sleep for 10s to allow the page to load<br/>    target_page = url<br/>    driver.get(target_page) <br/>    header = driver.find_element_by_id('pmc-gallery-list-nav-bar-render')<br/>    links = header.find_elements_by_tag_name('a')<br/>    urls = [link.get_attribute("href") for link in links]<br/>    driver.quit()<br/>    return urls</span><span id="31ef" class="mb mc iq nl b gy nz nw l nx ny">urls = get_links(target_url)</span></pre><p id="9023" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">现在我们有了 URL，下一步是将数据存储在列表中。对于每个 URL，我们将启动我们的<code class="fe ni nj nk nl b">get_page_source</code>功能，提取相关数据，并存储它。我们将每个页面的数据存储到两个列表中:<code class="fe ni nj nk nl b">song_all</code>，其中包含艺术家和歌曲的标题，以及<code class="fe ni nj nk nl b">other_all</code>，其中包含关于作者、制作人和发行日期的数据。通过对它们进行迭代，我们提取相关的文本，通过调用我们的<code class="fe ni nj nk nl b">strip_extra_chars</code>函数去掉多余的字符和格式，并将结果附加到我们之前初始化的三个空列表中:一个用于艺术家，一个用于标题，一个用于其他信息(接下来我们将对其进行解析)。</p><pre class="kp kq kr ks gt nr nl ns nt aw nu bi"><span id="7708" class="mb mc iq nl b gy nv nw l nx ny">songs = []<br/>artists = []<br/>other_data = []</span><span id="f9d1" class="mb mc iq nl b gy nz nw l nx ny">for url in urls:<br/>    print(f"retrieving data from {url}")<br/>    soup = get_page_source(url)<br/>    song_all = soup.find_all('h2', {'class':'c-gallery-vertical-album__title'})<br/>    other_all = soup.find_all(attrs={'class': 'c-gallery-vertical-album__description'})<br/>    for song in song_all:<br/>        song = strip_extra_chars(song)<br/>        title = song.split(',')[1]<br/>        title_inner = title[2:len(title)-1]<br/>        songs.append(title_inner)<br/>        artists.append(song.split(',')[0])<br/>    for other in other_all:<br/>        other = strip_extra_chars(other)<br/>        other_data.append(other)<br/>driver.quit()</span></pre><p id="0583" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">借助正则表达式和一点字符串切片将清理和分割包含在<code class="fe ni nj nk nl b">other</code>中的数据。我们在一个<code class="fe ni nj nk nl b">split_others</code>函数中这样做，然后我们在一个循环中调用这个函数来产生三个作者、制作人和发布日期的列表。</p><pre class="kp kq kr ks gt nr nl ns nt aw nu bi"><span id="8c23" class="mb mc iq nl b gy nv nw l nx ny">def split_others(line):<br/>    x = "(Writers:|Writer:)"<br/>    y = "(Producer:|Producers:)"<br/>    z = "Released:"<br/>    a = re.split(x, line)<br/>    a = re.split(y, a[2])<br/>    writers = a[0].strip()<br/>    b = re.split(z, a[2])<br/>    producers = b[0]<br/>    released = b[1].split(',')[0]<br/>    released<br/>    return writers, producers, released</span><span id="86fb" class="mb mc iq nl b gy nz nw l nx ny">writers = []<br/>producer = []<br/>release_date = []<br/>for item in other_data:<br/>    w, p, r = split_others(item)<br/>    writers.append(w.strip())<br/>    producer.append(p.strip())<br/>    release_date.append(r[-2:].strip())</span></pre><h2 id="0544" class="mb mc iq bd md me mf dn mg mh mi dp mj lo mk ml mm ls mn mo mp lw mq mr ms iw bi translated">第四步:把所有的东西放在一起！</h2><p id="1881" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">就是这样！我们已经取回了我们的数据。我们现在可以使用字典并将我们的数据传递给熊猫，以便将其存储在数据帧中。</p><pre class="kp kq kr ks gt nr nl ns nt aw nu bi"><span id="44d5" class="mb mc iq nl b gy nv nw l nx ny">d = {'Artist':artists, 'Song title': songs, 'Writers': writers, 'Producer': producer, 'Year': release_date} <br/>df = pd.DataFrame(data=d)</span></pre><p id="336d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">(可选:因为抓取相当耗时，我将把我们检索到的数据存储在一个<code class="fe ni nj nk nl b">pickle</code> — <a class="ae le" href="https://www.datacamp.com/community/tutorials/pickle-python-tutorial?utm_source=adwords_ppc&amp;utm_campaignid=898687156&amp;utm_adgroupid=48947256715&amp;utm_device=c&amp;utm_keyword=&amp;utm_matchtype=b&amp;utm_network=g&amp;utm_adpostion=&amp;utm_creative=332602034349&amp;utm_targetid=dsa-429603003980&amp;utm_loc_interest_ms=&amp;utm_loc_physical_ms=1008463&amp;gclid=EAIaIQobChMIo5LS7Yza6wIV1-vtCh1k1Aa9EAAYASAAEgIAW_D_BwE" rel="noopener ugc nofollow" target="_blank">中，这个</a>是一个很好的教程。要将其加载回来，您需要用三重引号取消对该部分的注释。</p><pre class="kp kq kr ks gt nr nl ns nt aw nu bi"><span id="570d" class="mb mc iq nl b gy nv nw l nx ny"><br/>import pickle<br/><br/>filename = 'ROLLING_STONE_DATA'<br/>outfile = open(filename,'wb')<br/>pickle.dump(d,outfile)<br/>outfile.close()<br/>'''<br/>filename = 'ROLLING_STONE_DATA'<br/>infile = open(filename,'rb')<br/>d = pickle.load(infile)<br/>infile.close()<br/>'''</span><span id="076c" class="mb mc iq nl b gy nz nw l nx ny">df = pd.DataFrame(data=d)</span></pre><p id="6759" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">既然我们都是好奇的动物，那就稍微尝一尝，看看谁是唱歌最多的艺人，用<code class="fe ni nj nk nl b">matplotlib</code>来剧情结果。</p><pre class="kp kq kr ks gt nr nl ns nt aw nu bi"><span id="31e9" class="mb mc iq nl b gy nv nw l nx ny">top_10 = df['Artist'].value_counts()[:10]</span><span id="d3d9" class="mb mc iq nl b gy nz nw l nx ny">plt.barh(top_10.index, top_10)</span><span id="f70e" class="mb mc iq nl b gy nz nw l nx ny">&lt;BarContainer object of 10 artists&gt;</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="ab gu cl pa"><img src="../Images/cec09748d03ca4fd7c9bf9192686443d.png" data-original-src="https://miro.medium.com/v2/format:webp/1*NruRp2w4u7Tt2fIDr5NyJA.png"/></div></figure></div></div>    
</body>
</html>