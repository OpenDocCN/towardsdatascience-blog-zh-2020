<html>
<head>
<title>Implementing the General Tree and Depth-First-Search (DFS) in python! (from scratch)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在python中实现通用树和深度优先搜索(DFS )!(从头开始)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/implementing-the-general-tree-and-depth-first-search-dfs-in-python-from-scratch-b3187e9e117d?source=collection_archive---------8-----------------------#2020-02-10">https://towardsdatascience.com/implementing-the-general-tree-and-depth-first-search-dfs-in-python-from-scratch-b3187e9e117d?source=collection_archive---------8-----------------------#2020-02-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/ff280175973de030153ec58770835f63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wfSjIUzwhohCxMHSHMtAvA.jpeg"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">信用:Pixabay</p></figure><p id="7d6d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">最近，我在《走向数据科学》上发表了一篇关于从零开始实现链表的文章。阅读之前的故事对于理解这里的核心概念是不必要的，但是之前使用的代码将被引用；因此，我将把GitHub Gists链接到链表和一般的树实现。</p><p id="db8e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">作为一名数据科学领域的研究生，我经常发现统计概念得到了大量的课程介绍，但基本的CS概念往往被抽象掉了。也许有充分的理由；知道如何实现一棵树对于训练一个随机的森林来说是不必要的。更高级的API允许我们利用基本概念，而不会被细节所困扰。</p><h1 id="0a02" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">那么什么是一般的树——你为什么要关心呢？</h1><p id="ddec" class="pw-post-body-paragraph kf kg it kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc im bi translated">到目前为止，二叉树在CS基础中更常见。每棵树都有三个强制元素:一个值、一个左子引用和一个右子引用。实现的任何其他东西都是为了满足程序员预见的独特目的。</p><p id="4927" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">另一方面，一般的树不限于有<em class="mg">确切地说是</em>两个孩子。这尤其有用，因为分层数据在web上非常普遍。<strong class="kh iu">例如，考虑探索API查询结果的任务。XML和JSON数据都是树状数据。</strong>通用树会给你工具来快速搜索特定字符串、数值等的查询结果。</p><p id="63c4" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们的数据结构不局限于两个或零个孩子，将比二叉树灵活得多，但它也将迫使我们做出重要的设计决策。其中最重要的是——树节点必须有有限数量的属性。如果任何节点都可以有任意数量的子节点，我们该如何解决这个难题呢？列表、元组和字典是自然的选择；单个通用树节点可以将其<code class="fe mh mi mj mk b">children</code>属性设置为单个变量，该变量可以引用可变数量的通用树节点。</p><p id="de6b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">但是我承诺从头实现它，因为我最近从头实现了链表，我们将继续以同样的势头向前冲。简单回顾一下——链表是由节点组成的。每个节点引用序列中的下一个节点(也可以是前一个节点——也就是双向链表)。)第一个节点是头，因此，必须从头遍历到序列中的任何其他节点。在头部位置的插入是微不足道的(与动态数组相比)，您只需实例化一个引用头部的新节点，并将head属性设置为链表的新头部。</p><p id="a838" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们将以两种方式构建链表:我们将直接使用链表来跟踪我们已经访问过的树节点；我们将借用链表<em class="mg">的精神来</em>指导我们的设计选择。</p><p id="9202" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">考虑下图。典型的通用树将允许任何子节点被给定的父节点访问。因为我们的数据结构将建立在一个链表上，一个给定的父节点将只引用一个子节点，<em class="mg">，特别是最左边的子节点</em>。要访问它的其他子节点，我们必须遍历兄弟节点。只要我们意识到这一点，并且我们的设计选择考虑到这一点，这就不是问题。另外，我们没有借用python的内置数据类型，这意味着我们最大化了我们的学习体验。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/7fd0cf3c3513f7359ead68881b2a9bef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*acly68OoaV-TQKxbSIupLA.png"/></div></figure><p id="cb0c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">让我们从一般的树节点开始，它将有以下参数:<em class="mg">值、父节点、左兄弟节点、右兄弟节点和子节点</em>。这本质上是一个双向链表，因为它在水平和垂直方向上都是双向链接的。很像链表，我们需要定义<em class="mg">getter</em>和<em class="mg">setter</em>。这些函数将设置一个节点对另一个节点的引用属性，或者获取这个值的值(如果存在的话)。</p><p id="be1c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">到目前为止，我们已经讨论了体系结构，但是通用树的真正用途来自于搜索它的能力。有多种策略来遍历一般的树；最常见的两种是广度优先搜索(BFS)和深度优先搜索(DFS)。我们今天将只实现后者。在高层次上，策略是尽可能深入第一个分支；当我们不能再往下走时，我们退回到前面的父节点，并遍历它的第一个兄弟节点。我们能下去吗？如果是这样，我们探索这个分支的深度。如果不能，我们探索下一个兄弟姐妹。这听起来极其复杂，但是当我们从基于条件的策略的角度来考虑时，就容易多了。</p><p id="0304" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">DFS的五个场景:</p><ol class=""><li id="23d0" class="mq mr it kh b ki kj km kn kq ms ku mt ky mu lc mv mw mx my bi translated">如果一个子节点存在并且还没有被浏览，那么<em class="mg">遍历到这个子节点。</em></li><li id="48e1" class="mq mr it kh b ki mz km na kq nb ku nc ky nd lc mv mw mx my bi translated">如果<em class="mg">右</em>兄弟存在且尚未被浏览，则<em class="mg">向右遍历。</em></li><li id="4297" class="mq mr it kh b ki mz km na kq nb ku nc ky nd lc mv mw mx my bi translated">如果我们在最右边的孩子，我们<em class="mg">可以</em>退回到左边，那么<em class="mg">遍历到左边。</em> <strong class="kh iu">【撤退】</strong></li><li id="b5bd" class="mq mr it kh b ki mz km na kq nb ku nc ky nd lc mv mw mx my bi translated">如果我们不在最左边的子节点<em class="mg">上，但是我们已经在右边的</em>和<em class="mg">上找到了</em>的兄弟节点，那么<em class="mg">遍历到左边。</em> <strong class="kh iu">(撤退)</strong></li><li id="0849" class="mq mr it kh b ki mz km na kq nb ku nc ky nd lc mv mw mx my bi translated">否则，<em class="mg">遍历父项。</em> <strong class="kh iu">【撤退】</strong></li></ol><p id="784a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这里真正的技巧是使用递归，这是每个程序员都应该努力掌握的技能。递归函数有两个元素:终止条件和其他一切。如果终止条件被触发，函数将存在并返回一些期望的输出。如果终止条件不满足，<strong class="kh iu">该函数将采取措施向终止条件推进，然后调用自身。</strong></p><p id="aaad" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">出于我们的目的，我们需要对<em class="mg">和</em>有一些概念，为此我们将定义<code class="fe mh mi mj mk b">current_node</code>和<code class="fe mh mi mj mk b">current_value</code>变量。每当我们遍历到另一个节点时，我们就更新这些值。我们的终止条件是这样的:<em class="mg">如果当前值是</em> <strong class="kh iu"> <em class="mg">根节点值</em> </strong> <em class="mg">或</em> <strong class="kh iu"> <em class="mg">搜索值</em> </strong> <em class="mg">，我们退出</em> <strong class="kh iu">。</strong>(显然，每个节点有一个唯一的名称很重要，让我们过早退出。)如果不满足这个条件，我们观察上面的五个条件规则，根据当前节点执行任何合适的规则/策略，并重复直到满足终止条件。这就是全部了。</p><p id="1865" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们将在下面定义三种截然不同但非常相似的方法。第一个是<code class="fe mh mi mj mk b">depth_first_traversal</code>。这里，我们将根据DFS协议研究整个树。没有搜索值，因此我们仅在到达根节点时终止(即，我们已经探索了所有子节点的所有子节点。)其次我们来定义<code class="fe mh mi mj mk b">depth_first_search</code>。这里，我们<em class="mg">将</em>提供一个搜索值。如果达到这个值，我们将退出循环。如果我们一直追溯到根节点，这个值在树中就不存在了。值得注意的是，这两个函数将通知程序员节点<em class="mg">实际被遍历的顺序。</em>换句话说，<strong class="kh iu">兄弟遍历将被考虑。</strong></p><p id="bac4" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们需要定义第三个函数，它对真实的层次数据有用。例如，在文件存储系统中。一旦您将目录更改为给定的文件夹，您就不需要遍历所有文件和文件夹，直到您到达所需的文件夹后再打开它。相反，您只需遍历<code class="fe mh mi mj mk b">parent -&gt; child</code>并重复，直到您到达所需的子目录。对我们的影响:<em class="mg">使用我们的架构，我们需要清除兄弟遍历，这样我们的输出就和任何其他通用树的输出一样。</em></p><p id="ee6e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这种改变没有你想象的那么困难。但是在我们讨论它之前，我们需要谈谈上面讨论的所有三种方法的共性。需要创建一个<code class="fe mh mi mj mk b">visited </code>类属性。正如前面所讨论的，这将是一个链表，其中一旦一个树节点被访问，它的值将被追加到链表的末尾。这使得这三种方法避免了从父到子到父的无限遍历…一次又一次。</p><p id="8826" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">后两种方法使用了path类属性的变体，这是——您猜对了——另一个链表(持续给予的礼物！)这里的想法是<em class="mg">只维护不涉及撤退的</em>节点，不像被访问的属性。<code class="fe mh mi mj mk b">path</code>和<code class="fe mh mi mj mk b">child_path</code>最大的区别在于，前者包括对兄弟姐妹的遍历，而后者不包括。子路径是最令人感兴趣的，因为它在真实世界的数据中很有用，而path属性只在我们程序的上下文中有用。在任一情况下，使用我们上面的五个DFS条件规则/策略，条件3、4、&amp; 5都是撤退，这意味着当撤退时我们从我们的路径/子路径中清除这些节点值。(如果推理还不明显，当我们回顾代码时，它会更有意义。简单地说，这些分支是死胡同，我们从路径/子路径变量中剪除。)</p><p id="b6df" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">重新考虑终止条件，我们做的最后一件事是为将来的迭代重置。这是通过将我们的路径复制到一个临时变量，将所有其他变量重新定义到它们的起始条件，然后返回临时变量来实现的。过一会儿这就更有意义了——我保证！(如果我们不重置，我们将需要重新实例化我们的通用树类，以便搜索不同的值，因为我们的变量将存在于非启动条件下，从而触发错误。)</p><p id="7e57" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在——代码！让我们回顾一下链表。</p><figure class="mm mn mo mp gt ju"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="3760" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">并在一般的树(最后！！)</p><figure class="mm mn mo mp gt ju"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="c874" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">考虑下面的树:</p><pre class="mm mn mo mp gt ng mk nh ni aw nj bi"><span id="f150" class="nk le it mk b gy nl nm l nn no">a1<br/>|<br/>b1 - b2 - b3 <br/>|         |<br/>d1        c1</span></pre><p id="b132" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果我们运行下面的单元格，我们将把这个树实例化到通用树类对象中，然后找到从根到节点c1的最短路径(有和没有兄弟)。</p><pre class="mm mn mo mp gt ng mk nh ni aw nj bi"><span id="5af0" class="nk le it mk b gy nl nm l nn no">a1 = GeneralTreeNode(value='a1')<br/>b1 = GeneralTreeNode(value='b1')<br/>b2 = GeneralTreeNode(value='b2')<br/>b3 = GeneralTreeNode(value='b3')<br/>a1.set_child(b1)<br/>b1.set_parent(a1)<br/>b1.set_right(b2)<br/>b2.set_left(b1)<br/>b2.set_right(b3)<br/>b3.set_left(b2)</span><span id="1f6c" class="nk le it mk b gy np nm l nn no">c1 = GeneralTreeNode(value='c1')<br/>c1.set_parent(b3)<br/>b3.set_child(c1)</span><span id="d2c7" class="nk le it mk b gy np nm l nn no">d1 = GeneralTreeNode(value='d1')<br/>d1.set_parent(b1)<br/>b1.set_child(d1)</span><span id="bdf2" class="nk le it mk b gy np nm l nn no">r = GeneralTree(root=a1)</span><span id="49c4" class="nk le it mk b gy np nm l nn no">r.depth_first_search(search_val='c1')<br/>&gt;&gt;&gt;&gt;<br/>Node:  a1<br/>Node:  b1<br/>Node:  b2<br/>Node:  b3<br/>Node:  c1</span><span id="8fbc" class="nk le it mk b gy np nm l nn no">r.child_depth_first_search(search_val='c1')<br/>&gt;&gt;&gt;&gt;<br/>Node:  a1<br/>Node:  b3<br/>Node:  c1</span></pre><p id="6e68" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">看到<code class="fe mh mi mj mk b">depth_first_search</code>和<code class="fe mh mi mj mk b">child_depth_first_search</code>的区别了吗？在后者中，节点b1和b2被省略，因为它们在一般树的传统定义中不是必需的遍历。<em class="mg">后一种方法是您想要在现实世界问题中使用的方法</em>(就像我们之前的文件系统导航示例一样。)</p><p id="c16f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果你对本教程如何更有帮助有想法，对扩展有想法，请求合作等，请联系我。名义上，我计划要么创建一个XML解析器、JSON解析器，要么使用树来搜索嵌套字典，等等。</p><p id="34c9" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我希望你喜欢今天和我一起深入研究基本面！</p></div></div>    
</body>
</html>