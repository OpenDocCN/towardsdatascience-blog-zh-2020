<html>
<head>
<title>Implement Canny Edge Detection from Scratch with Pytorch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Pytorch从头开始实现Canny边缘检测</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/implement-canny-edge-detection-from-scratch-with-pytorch-a1cccfa58bed?source=collection_archive---------17-----------------------#2020-04-26">https://towardsdatascience.com/implement-canny-edge-detection-from-scratch-with-pytorch-a1cccfa58bed?source=collection_archive---------17-----------------------#2020-04-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/20614f85a92f8f13e7c970f99e77f1a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RqMdS4Gxke1CJOEoakCvNg.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">Canny边缘检测</p></figure><p id="17cb" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu"> Canny滤波器</strong>无疑是边缘检测中最知名和最常用的滤波器。我将逐步解释用于<strong class="kh iu">轮廓检测</strong>的canny滤波器。一步一步因为canny滤波器是一个<strong class="kh iu">多级滤波器</strong>。Canny过滤器很少被集成到深度学习模型中。所以我会描述不同的部分，同时用<strong class="kh iu"> Pytorch </strong>实现。它几乎可以无限制地定制，我允许自己有一些偏差。</p><figure class="ld le lf lg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/9a864e95a24a7a0964dcc001f2c5fb6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qLvvyAA_IbXLff5mAZYbiA.png"/></div></div></figure><figure class="ld le lf lg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lh"><img src="../Images/ff70e59d9dfb59ea029c27cf5f9d0cdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dh9_rGTRkKYmqGECJwxkzA.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">输入图像和内核之间的卷积</p></figure><p id="84c3" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我来介绍一下什么是<strong class="kh iu">卷积矩阵</strong>(或者说<strong class="kh iu">内核</strong>)。卷积矩阵描述了我们将要在输入图像上通过的<strong class="kh iu">滤波器</strong>。简单来说，内核将通过应用<strong class="kh iu">卷积乘积</strong>在整个图像上从左到右、从上到下移动。该操作的输出被称为<strong class="kh iu">滤波图像</strong>。</p></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h1 id="ed96" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">高斯滤波</h1><p id="dee0" class="pw-post-body-paragraph kf kg it kh b ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky mr la lb lc im bi translated">首先，我们通常通过应用<strong class="kh iu">模糊过滤器</strong>来移除输入图像中存在的<strong class="kh iu">噪声</strong>。这个滤镜的选择由你决定，但是我们大多用的是<strong class="kh iu">高斯</strong>滤镜。</p><figure class="ld le lf lg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ms"><img src="../Images/02fb359d77d98c0193e9aee7662ae664.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*13XkXfrnOFC9Mur6Mq2h1A.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">高斯核</p></figure><figure class="ld le lf lg gt ju"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="3f4a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">可以制作不同大小的高斯核</strong>，或多或少居中或展平。显然，核越大，输出图像越模糊。</p><figure class="ld le lf lg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/9e823b1d1098c76c60bba3318c42dce5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KgPohJ3cxJ7PU51uMGhhXA.png"/></div></div></figure></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h1 id="99c7" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">索贝尔滤波</h1><p id="f73c" class="pw-post-body-paragraph kf kg it kh b ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky mr la lb lc im bi translated">为了<strong class="kh iu">检测边缘</strong>，必须对图像应用过滤器<strong class="kh iu">以提取梯度</strong>。</p><figure class="ld le lf lg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mv"><img src="../Images/4bde19f689f7438515a04a36b7fdc48d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SErRJqe-G3vhTrRRVAMD5Q.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">X上的Sobel核</p></figure><figure class="ld le lf lg gt ju"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="ld le lf lg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/d228c6b4951ea307f5d5c1ee47f549d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dA2w0Ve7bLPA1dQf5vLfUw.png"/></div></div></figure><p id="2382" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">最常用的滤波器是<strong class="kh iu">索贝尔滤波器</strong>。分解成两个滤波器，第一个内核用于水平提取<strong class="kh iu">梯度</strong>。粗略地说，右边的像素与左边的像素相比越亮，过滤图像的结果就越高。反之亦然。这一点在莉娜的帽子左侧可以清晰的看到。</p><figure class="ld le lf lg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mv"><img src="../Images/c1aac31a8e7945ed73ec560b11f4c904.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pyau_WgBWcZdKrHPo0gjog.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">Y上的Sobel核</p></figure><p id="d15e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">第二个内核用于垂直提取<strong class="kh iu">梯度</strong>。一个是另一个的转置。这两个核心具有相同的作用，但是在不同的轴上。</p><figure class="ld le lf lg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/2e200a3d398997150d50aec09e5cac48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9r0sgtk1ajQSYAxAZZn1qA.png"/></div></div></figure></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h1 id="57a6" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">计算梯度</h1><p id="26c5" class="pw-post-body-paragraph kf kg it kh b ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky mr la lb lc im bi translated">嗯，我们在图像的两个轴上都有梯度。为了检测轮廓，我们想要梯度的<strong class="kh iu">大小</strong>。我们可以使用绝对值范数或<strong class="kh iu">欧几里德范数</strong>。</p><figure class="ld le lf lg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ms"><img src="../Images/6675d766b2c5d3b7cba2fa509fe0314e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5wvb40bviMZgCAOIyRbUXQ.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">梯度的大小和方向</p></figure><figure class="ld le lf lg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/3e14d6edf7cdb5aca3db937fa95f0ce5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fFz9SgOHhzUGorL_YBm8og.png"/></div></div></figure><p id="0709" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">使用我们的梯度的大小，边缘现在被完美地检测到了。但是<strong class="kh iu">他们很粗</strong>。如果能只保留轮廓的细线就太好了。因此，我们同时计算我们的梯度的<strong class="kh iu">方向</strong>，这将被用来只保留这些<strong class="kh iu">细线</strong>。<br/>在Lena的图片中，渐变是由强度来象征的，因为渐变的角度很重要。</p></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h1 id="8a25" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">非最大抑制</h1><p id="9b39" class="pw-post-body-paragraph kf kg it kh b ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky mr la lb lc im bi translated">为了细化边缘，可以使用<strong class="kh iu">非最大抑制</strong>方法。在此之前，我们需要创建45×45方向的内核。(可以参考<a class="ae mw" rel="noopener" target="_blank" href="/how-to-transform-a-2d-image-into-a-3d-space-5fc2306e3d36">本帖</a>了解旋转矩阵)</p><figure class="ld le lf lg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mx"><img src="../Images/86f87569f6c9b4a958ee6686063543ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dFJOUwE9vEUOlnBuPss0kQ.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">方向核</p></figure><figure class="ld le lf lg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/f9854c0ed764e40d189eef47fc761d80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qKLOOraO_C52cdYbxCbPsg.png"/></div></div></figure><figure class="ld le lf lg gt ju"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="ab3b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">因此，该过程将需要检查<strong class="kh iu">8-邻域</strong>(或称为摩尔邻域)。这个概念很容易理解。对于每个像素，我们将<strong class="kh iu">检查方向</strong>。我们将会看到这个像素是否比它的梯度方向的邻居更强烈。如果是，那么我们将该像素与其相反方向的邻居进行比较。如果该像素与其双向邻居相比具有<strong class="kh iu">最大强度</strong>，则它是<strong class="kh iu">局部最大值</strong>。这个像素将被<strong class="kh iu">保持</strong>。在所有其他情况下，它不是局部最大值，并且像素被<strong class="kh iu">移除</strong>。</p><figure class="ld le lf lg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/b9f9d37cd49d4ff180d28caf0d1f0be6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vAqlMAtOcBYP0-USnyc9Xg.png"/></div></div></figure><figure class="ld le lf lg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/ed86721c308b9db5bc00e830a493e6db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a1JGEXleOlXYdc3L9V26uw.png"/></div></div></figure></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h1 id="7234" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">阈值和迟滞</h1><p id="bdbe" class="pw-post-body-paragraph kf kg it kh b ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky mr la lb lc im bi translated">最后，只剩下应用<strong class="kh iu">阈值</strong>了。有三种方法可以做到这一点:</p><ul class=""><li id="5932" class="my mz it kh b ki kj km kn kq na ku nb ky nc lc nd ne nf ng bi translated"><strong class="kh iu">低-高</strong>阈值:强度高于阈值的像素设置为1，其他设置为0。</li><li id="c4f4" class="my mz it kh b ki nh km ni kq nj ku nk ky nl lc nd ne nf ng bi translated"><strong class="kh iu">低-弱</strong>和<strong class="kh iu">弱-高</strong>阈值:我们将具有高强度的像素设置为1，将具有低强度的像素设置为0，并且在两个阈值之间我们将它们设置为0.5。他们被认为是弱者。</li><li id="d9fc" class="my mz it kh b ki nh km ni kq nj ku nk ky nl lc nd ne nf ng bi translated"><strong class="kh iu">低-弱</strong>和<strong class="kh iu">弱-高</strong>带<strong class="kh iu">滞后</strong>:同上。弱像素通过它们的滞后水平进行评估，并被重新分配为高或低。</li></ul><figure class="ld le lf lg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nm"><img src="../Images/1fbe1b49813ed9afe71cc6eb84f2b8b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RJIja0LoH5DIS0yCHNVRcw.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">阈值</p></figure><blockquote class="nn no np"><p id="bae4" class="kf kg nq kh b ki kj kk kl km kn ko kp nr kr ks kt ns kv kw kx nt kz la lb lc im bi translated">滞后是系统状态对其历史的依赖性。—维基百科</p></blockquote><p id="ca79" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在我们的例子中，滞后可以理解为一个像素对其邻居的<strong class="kh iu">依赖性。在canny滤波器的滞后步骤中，我们说，如果弱像素在其8个邻居中有一个高邻居，则该弱像素将被分类为高。</strong></p><p id="3919" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我更喜欢用不同的方法，用最终的卷积滤波器对弱像素进行分类。如果它的卷积乘积<strong class="kh iu">大于1 </strong>，那么我将其归类为高。高邻比0.25分，弱半0.25。</p><figure class="ld le lf lg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nu"><img src="../Images/5f7b65d1614ea437ff443a67327ea978.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_XUeA_giewkwy-WHKVdsIw.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">滞后内核</p></figure><figure class="ld le lf lg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/6b110e9fc81d2a3bab879e74f0eb0e11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IfsfAAGOLNNs7TO1H5JRJQ.png"/></div></div></figure></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h1 id="e6e9" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">“你说Pytorch？”</h1><p id="fd5d" class="pw-post-body-paragraph kf kg it kh b ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky mr la lb lc im bi translated">的确是的，现在是<strong class="kh iu"> Pytorch代码</strong>的时候了。一切都组合成<strong class="kh iu">一nn。模块</strong>。我不能保证实现会得到优化。使用OpenCV的特性将加快处理速度。但是这种实现方式至少具有以下优点:灵活性<strong class="kh iu"/>，<strong class="kh iu">可参数化</strong>，并且根据需要容易<strong class="kh iu">改变</strong>。</p><figure class="ld le lf lg gt ju"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="ld le lf lg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nv"><img src="../Images/a41213d2ce618721d92c099fba464fc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eGtKKRvZfNm6mIdQlVXisA.png"/></div></div></figure><blockquote class="nn no np"><p id="cd08" class="kf kg nq kh b ki kj kk kl km kn ko kp nr kr ks kt ns kv kw kx nt kz la lb lc im bi translated"><strong class="kh iu">知识就是分享。</strong> <br/> <strong class="kh iu">支持</strong>我，一键获取<a class="ae mw" href="https://axel-thevenot.medium.com/membership" rel="noopener"> <strong class="kh iu">中<strong class="kh iu">我所有文章的</strong>访问</strong> </a>。</p></blockquote><figure class="ld le lf lg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nv"><img src="../Images/94e903d7d66ff043ca9645dbc42c33bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y7Q5U2MjIji7pvt6DRzq3A.png"/></div></div></figure><h1 id="87a3" class="lp lq it bd lr ls nw lu lv lw nx ly lz ma ny mc md me nz mg mh mi oa mk ml mm bi translated">来源</h1><p id="9eb9" class="pw-post-body-paragraph kf kg it kh b ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky mr la lb lc im bi translated"><a class="ae mw" href="https://www.researchgate.net/publication/239398674_An_Isotropic_3x3_Image_Gradient_Operator" rel="noopener ugc nofollow" target="_blank">各向同性3×3图像梯度算子，I. Sobel </a></p><p id="04be" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><a class="ae mw" href="https://perso.esiee.fr/~perretb/I5FM/TAI/convolution/index.html" rel="noopener ugc nofollow" target="_blank">卷积，ESIEE </a></p><p id="669c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><a class="ae mw" href="https://en.wikipedia.org/wiki/Canny_edge_detector" rel="noopener ugc nofollow" target="_blank"> Canny边缘检测器，维基百科</a></p><p id="6d9c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><a class="ae mw" href="https://docs.opencv.org/trunk/da/d22/tutorial_py_canny.html" rel="noopener ugc nofollow" target="_blank"> Canny边缘检测，OpenCV </a></p><p id="237a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">所有的图像都是自制的(除了莉娜和指南针)</p></div></div>    
</body>
</html>