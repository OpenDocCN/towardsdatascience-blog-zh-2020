<html>
<head>
<title>Unit Testing for Data Scientists</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据科学家的单元测试</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/unit-testing-for-data-scientists-dc5e0cd397fb?source=collection_archive---------6-----------------------#2020-05-18">https://towardsdatascience.com/unit-testing-for-data-scientists-dc5e0cd397fb?source=collection_archive---------6-----------------------#2020-05-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="2b4d" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">机器学习</h2><div class=""/><div class=""><h2 id="fb45" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated"><strong class="ak">使用 Pytest 提高管道的稳定性</strong></h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/ca7b70f07d86b836354d4e027f78c60b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8aLkzFBSWg5ESeK25XE44A.png"/></div></div></figure><p id="4b7e" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">随着数据科学在大型组织中变得越来越重要，对代码进行适当的<strong class="lf jd">测试的需求慢慢变得越来越集成到数据科学家的技能组合中。</strong></p><p id="1260" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">假设您正在创建一个预测组织中客户流失的渠道。在部署您的解决方案几个月后，有一些新的变量可能会提高它的性能。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi lz"><img src="../Images/c2f7ae6c15e46f22e03c177206ac3673.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oWCNf5PGlcm8NQAOybAGvw.png"/></div></div></figure><p id="3752" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">不幸的是，在添加了那些变量之后，代码突然停止工作了！您不熟悉错误消息，并且您很难找到自己的错误。</p><p id="6390" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这就是<strong class="lf jd">测试</strong>，特别是<strong class="lf jd">单元测试</strong>的用武之地！</p><p id="8376" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">为特定模块编写测试可以提高代码的稳定性，并使错误更容易被发现。尤其是在处理大型项目时，进行适当的测试是基本的需求。</p><blockquote class="ma mb mc"><p id="647f" class="ld le md lf b lg lh kd li lj lk kg ll me ln lo lp mf lr ls lt mg lv lw lx ly im bi translated">没有某种形式的测试，任何数据解决方案都是不完整的</p></blockquote><p id="816c" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这篇文章将关注一个小的，但是非常重要的，也可以说是测试的基础，即<strong class="lf jd">单元测试</strong>。下面，我将详细讨论为什么测试是必要的，什么是单元测试，以及如何将它们集成到您的数据科学项目中。</p><h1 id="2498" class="mh mi it bd mj mk ml mm mn mo mp mq mr ki ms kj mt kl mu km mv ko mw kp mx my bi translated">1.你为什么要测试你的代码？</h1><p id="0d5b" class="pw-post-body-paragraph ld le it lf b lg mz kd li lj na kg ll lm nb lo lp lq nc ls lt lu nd lw lx ly im bi translated">虽然这看起来是显而易见的，但实际上测试代码有很多原因:</p><ul class=""><li id="ffec" class="ne nf it lf b lg lh lj lk lm ng lq nh lu ni ly nj nk nl nm bi translated">防止意外输出</li><li id="dde8" class="ne nf it lf b lg nn lj no lm np lq nq lu nr ly nj nk nl nm bi translated">简化代码更新</li><li id="f251" class="ne nf it lf b lg nn lj no lm np lq nq lu nr ly nj nk nl nm bi translated">提高开发代码的整体效率</li><li id="283e" class="ne nf it lf b lg nn lj no lm np lq nq lu nr ly nj nk nl nm bi translated">有助于检测边缘情况</li><li id="8e3e" class="ne nf it lf b lg nn lj no lm np lq nq lu nr ly nj nk nl nm bi translated">最重要的是<strong class="lf jd">防止你将任何破损的代码投入生产！</strong></li></ul><p id="203b" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这只是我的一个想法！</p><p id="2d1d" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">即使对于那些编写产品代码的人，我也建议他们至少为代码中最重要的模块编写测试。</p><blockquote class="ns"><p id="6a5e" class="nt nu it bd nv nw nx ny nz oa ob ly dk translated">如果你运行一个深度学习管道，但在 3 个小时后，你本可以轻松测试的东西失败了，那该怎么办？</p></blockquote><figure class="od oe of og oh kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oc"><img src="../Images/16f421ca113dfa1331384bff48abce92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T6193R_AJYCwnJ8ZqkzjCw.png"/></div></div></figure><p id="35ee" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf jd">注意</strong>:我完全可以想象不想为只花了你两天时间编写的一次性分析编写专用测试。没关系。由你来决定什么时候测试是有帮助的。最重要的是要认识到，他们可以节省你很多工作。</p><h1 id="623d" class="mh mi it bd mj mk ml mm mn mo mp mq mr ki ms kj mt kl mu km mv ko mw kp mx my bi translated">2.单元测试</h1><p id="9b03" class="pw-post-body-paragraph ld le it lf b lg mz kd li lj na kg ll lm nb lo lp lq nc ls lt lu nd lw lx ly im bi translated">单元测试是一种软件测试方法，它检查哪些特定的单个代码单元适合使用。例如，如果您想在 python 中测试<code class="fe oi oj ok ol b">sum</code>函数，您可以编写以下测试:</p><pre class="ks kt ku kv gt om ol on oo aw op bi"><span id="fa4c" class="oq mi it ol b gy or os l ot ou">assert sum([1, 2, 3]) == 6</span></pre><p id="173e" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们知道 1+2+3=6，所以应该没什么问题就通过了。</p><p id="40b4" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们可以通过创建一个定制的 sum 函数来扩展这个例子，并对元组和列表进行测试:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="75a6" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">当-1+2+3 不等于 6 时，<code class="fe oi oj ok ol b">test_new_sum_tuple</code>的输出将是一个断言错误。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ox"><img src="../Images/4b27272547b5f625b18f2deb6b4a4084.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aPRbnmtiDThZYinnYz1ITQ.png"/></div></div></figure><p id="b1ef" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf jd">单元测试</strong>帮助你在许多不同的环境下测试代码。然而，有一件重要的事情<strong class="lf jd">需要记住:</strong></p><blockquote class="ma mb mc"><p id="340c" class="ld le md lf b lg lh kd li lj lk kg ll me ln lo lp mf lr ls lt mg lv lw lx ly im bi translated">单元测试并不完美，几乎不可能达到 100%的代码覆盖率</p></blockquote><p id="70eb" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">单元测试是捕捉 bug 的好方法，但是不会捕捉到所有的东西，因为测试容易出现与你要测试的代码相同的逻辑错误。</p><p id="2584" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">理想情况下，您会希望包括集成测试、代码审查、正式验证等。但是这超出了本文的范围。</p><h1 id="9339" class="mh mi it bd mj mk ml mm mn mo mp mq mr ki ms kj mt kl mu km mv ko mw kp mx my bi translated">3.Pytest</h1><p id="8e08" class="pw-post-body-paragraph ld le it lf b lg mz kd li lj na kg ll lm nb lo lp lq nc ls lt lu nd lw lx ly im bi translated">上面例子的问题是，它将在第一次面对<code class="fe oi oj ok ol b">AssertionError</code>时停止运行。理想情况下，我们希望看到所有通过或失败的测试的概述。</p><p id="64fd" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这就是测试跑步者的用武之地，比如<a class="ae oy" href="https://github.com/pytest-dev/pytest" rel="noopener ugc nofollow" target="_blank"> Pytest </a>。Pytest 是一个很好的工具，可以根据您定义的测试创建广泛的诊断。</p><p id="c76d" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们从<strong class="lf jd">安装 Pytest </strong>开始:</p><p id="49a5" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><code class="fe oi oj ok ol b">pip install pytest</code></p><p id="bd55" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这样做之后，创建一个<code class="fe oi oj ok ol b">test_new_sum.py</code>文件，并用下面的代码填充它:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="6dde" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">最后，将<code class="fe oi oj ok ol b">cd</code>放入存放<code class="fe oi oj ok ol b">test_new_sum.py</code>的文件夹，然后简单地运行<code class="fe oi oj ok ol b">pytest -v</code>。结果应该是这样的:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oz"><img src="../Images/fceabf64ce06472d58f2b8df76ff2dc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AJ1KfkUHHYfAnoG6biqpPw.png"/></div></div></figure><p id="2ba3" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">你可以在上面的图片中看到，它显示了哪些测试通过了，哪些测试失败了。</p><p id="0750" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">令人惊奇的是 Pytest 向您展示了预期的值以及它失败的地方。这可以让你很快看到哪里出了问题！</p><h1 id="f779" class="mh mi it bd mj mk ml mm mn mo mp mq mr ki ms kj mt kl mu km mv ko mw kp mx my bi translated">4.数据科学家的单元测试</h1><p id="7e56" class="pw-post-body-paragraph ld le it lf b lg mz kd li lj na kg ll lm nb lo lp lq nc ls lt lu nd lw lx ly im bi translated">为了理解我们如何将 Pytest 用于数据科学解决方案，我将通过几个例子来说明。以下数据用于示例:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pa"><img src="../Images/8e5f4de2acddb8e8f0e7783bcc95fcdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nGTX3pvCgl_VI1M2IdVHaw.png"/></div></div><p class="pb pc gj gh gi pd pe bd b be z dk translated">示例数据</p></figure><p id="8544" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在这些数据中，我们有一个目标类和几个可以用作预测器的特征。</p><h2 id="741a" class="oq mi it bd mj pf pg dn mn ph pi dp mr lm pj pk mt lq pl pm mv lu pn po mx iz bi translated">基本用法</h2><p id="d8e8" class="pw-post-body-paragraph ld le it lf b lg mz kd li lj na kg ll lm nb lo lp lq nc ls lt lu nd lw lx ly im bi translated">让我们从几个简单的预处理函数开始。我们想知道每个类的每个特征的平均值。为此，我们创建了以下基本函数，<code class="fe oi oj ok ol b">aggregate_mean</code>:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="80e5" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">太好了！我们放入一个数据框和列，它应该会产生一个字典，其中包含每个类的平均值。</p><p id="6f1d" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">为了测试这一点，我们编写了下面的<code class="fe oi oj ok ol b">test_aggregate_mean.py</code>文件:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="1b93" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">当我们运行<code class="fe oi oj ok ol b">pytest -v</code>时，它应该不会给出错误！</p><h2 id="fa09" class="oq mi it bd mj pf pg dn mn ph pi dp mr lm pj pk mt lq pl pm mv lu pn po mx iz bi translated">用参数表示</h2><blockquote class="ma mb mc"><p id="4ba3" class="ld le md lf b lg lh kd li lj lk kg ll me ln lo lp mf lr ls lt mg lv lw lx ly im bi translated">使用参数化运行多个测试用例</p></blockquote><p id="8012" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如果我们想要测试许多不同的场景，那么创建一个测试的许多副本会很麻烦。为了防止这种情况，我们可以使用 Pytest 的参数化函数。</p><p id="7f84" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">参数化通过允许我们测试<strong class="lf jd">多个场景来扩展测试功能。</strong>我们简单地添加参数化装饰器并陈述不同的场景。</p><p id="3765" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">例如，如果我们想测试功能 1 和 3 的 aggregate_mean 函数，我们采用如下代码:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="40bc" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">运行<code class="fe oi oj ok ol b">pytest -v</code>之后，特性 3 的结果似乎不是我们所期望的。原来，我们之前看到的<strong class="lf jd"> None </strong>值其实是一个<strong class="lf jd">字符串</strong>！</p><p id="e7f5" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如果我们没有进行测试，我们自己可能不会发现这个错误。</p><h2 id="e3da" class="oq mi it bd mj pf pg dn mn ph pi dp mr lm pj pk mt lq pl pm mv lu pn po mx iz bi translated">固定装置</h2><blockquote class="ma mb mc"><p id="96c8" class="ld le md lf b lg lh kd li lj lk kg ll me ln lo lp mf lr ls lt mg lv lw lx ly im bi translated">用 Fixtures 防止单元测试中的重复代码</p></blockquote><p id="0c49" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">当创建这些测试用例时，我们通常希望在每个测试用例之前运行一些代码。我们创建<strong class="lf jd">fixture</strong>来为我们的测试建立基线代码，而不是在每个测试中重复相同的代码。</p><p id="9daf" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">它们通常用于初始化数据库连接、加载数据或实例化类。</p><p id="226b" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">使用前面的例子，我们想把<code class="fe oi oj ok ol b">load_data()</code>变成一个夹具。我们把它的名字改为<code class="fe oi oj ok ol b">data()</code>，以便更好地代表这个夹具。然后，<code class="fe oi oj ok ol b">@pytest.fixture(scope='module')</code>作为装饰器被添加到函数中。最后，我们将 fixture 作为参数添加到单元测试中:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="b53c" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如你所见，没有必要将<code class="fe oi oj ok ol b">data()</code>设置为变量，因为它会自动调用并存储在输入参数中。</p><p id="fad8" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">Fixtures 是增加可读性和减少测试函数中任何错误的好方法。</p><h2 id="b775" class="oq mi it bd mj pf pg dn mn ph pi dp mr lm pj pk mt lq pl pm mv lu pn po mx iz bi translated">嘲弄的</h2><blockquote class="ma mb mc"><p id="9f92" class="ld le md lf b lg lh kd li lj lk kg ll me ln lo lp mf lr ls lt mg lv lw lx ly im bi translated">我在你的管道中修改代码，通过模仿来加速测试</p></blockquote><p id="7cb3" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在许多数据驱动的解决方案中，您将需要处理大型文件，这会极大地降低您的管道速度。为这些代码创建测试是困难的，因为快速测试是首选。</p><p id="18f9" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">假设您用<code class="fe oi oj ok ol b">pd.read_csv</code>加载了一个 2GB 的 csv 文件，并且您想要测试管道的输出是否正确。有了<strong class="lf jd"> unittest.mock.patch </strong>，我们可以用自己的输出替换<code class="fe oi oj ok ol b">pd.read_csv</code>的输出，用更小的数据测试流水线。</p><p id="8da2" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">假设您已经为管道创建了以下代码库:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="7d4c" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">现在，为了测试这个管道是否像预期的那样工作，我们想要使用一个更小的数据集，这样我们就可以更准确地测试用例。为此，我们用迄今为止一直使用的较小数据集来修补<code class="fe oi oj ok ol b">pd.read_csv</code>:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="772b" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">当我们运行<code class="fe oi oj ok ol b">pytest -v</code>时，大的。csv 将不被加载，取而代之的是我们的小数据集。测试运行迅速，我们可以很容易地测试新的情况！</p><h2 id="229d" class="oq mi it bd mj pf pg dn mn ph pi dp mr lm pj pk mt lq pl pm mv lu pn po mx iz bi translated">新闻报道</h2><blockquote class="ma mb mc"><p id="fb8b" class="ld le md lf b lg lh kd li lj lk kg ll me ln lo lp mf lr ls lt mg lv lw lx ly im bi translated">你用单元测试覆盖了你的大部分代码吗？</p></blockquote><p id="8319" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">单元测试无论如何都不是一个完美的方法，但是知道你测试了多少代码是非常有用的。特别是当你有复杂的管道时，知道你的测试是否覆盖了你的大部分代码是很好的。</p><p id="6ae3" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">为了检查这一点，我建议你安装<a class="ae oy" href="https://github.com/pytest-dev/pytest-cov" rel="noopener ugc nofollow" target="_blank"> Pytest-cov </a>，它是 Pytest 的一个扩展，向你显示你的代码有多少被测试覆盖。</p><p id="1337" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">简单地安装 Pytest-cov，如下所示:</p><pre class="ks kt ku kv gt om ol on oo aw op bi"><span id="763d" class="oq mi it ol b gy or os l ot ou">pip install pytest-cov</span></pre><p id="1c26" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">完成后，运行以下测试:</p><p id="a594" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><code class="fe oi oj ok ol b">pytest --cov=codebase</code></p><p id="aa3c" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这意味着我们正在运行 Pytest，并检查有多少测试覆盖了 codebase.py。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pp"><img src="../Images/ad8ee8c54070396a896dce0a8b5a7814.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PSP62STLQYpNt8u9K5f1ag.png"/></div></div></figure><p id="5fbc" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">幸运的是，我们的测试覆盖了<code class="fe oi oj ok ol b">codebase.py</code>中的所有代码！</p><p id="e445" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如果我们注意到覆盖了任何行，那么该值将显示在<code class="fe oi oj ok ol b"><strong class="lf jd">Miss</strong></code> <strong class="lf jd">下。</strong></p><h1 id="fbb0" class="mh mi it bd mj mk ml mm mn mo mp mq mr ki ms kj mt kl mu km mv ko mw kp mx my bi translated">感谢您的阅读！</h1><p id="fedd" class="pw-post-body-paragraph ld le it lf b lg mz kd li lj na kg ll lm nb lo lp lq nc ls lt lu nd lw lx ly im bi translated">如果你像我一样，对人工智能、数据科学或心理学充满热情，请随时在<a class="ae oy" href="https://www.linkedin.com/in/mgrootendorst/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上添加我，或者在<a class="ae oy" href="https://twitter.com/MaartenGr" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我。</p><p id="790e" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">本文中的所有示例和代码都可以在这里找到:</p><div class="pq pr gp gr ps pt"><a href="https://github.com/MaartenGr/UnitTesting" rel="noopener  ugc nofollow" target="_blank"><div class="pu ab fo"><div class="pv ab pw cl cj px"><h2 class="bd jd gy z fp py fr fs pz fu fw jc bi translated">MaartenGr/单元测试</h2><div class="qa l"><h3 class="bd b gy z fp py fr fs pz fu fw dk translated">为数据驱动的解决方案创建单元测试的代码和说明相应的文章可以在这里找到:To…</h3></div><div class="qb l"><p class="bd b dl z fp py fr fs pz fu fw dk translated">github.com</p></div></div><div class="qc l"><div class="qd l qe qf qg qc qh lb pt"/></div></div></a></div></div></div>    
</body>
</html>