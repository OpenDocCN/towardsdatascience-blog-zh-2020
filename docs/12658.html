<html>
<head>
<title>Five Python Gotchas!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">五个 Python 陷阱！</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/five-python-gotchas-3073145fe083?source=collection_archive---------54-----------------------#2020-08-31">https://towardsdatascience.com/five-python-gotchas-3073145fe083?source=collection_archive---------54-----------------------#2020-08-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9ec8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">当你最不期待的时候会期待什么！</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e7874e9c5922bbbe1acf1f9299b77674.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aukCM2JHgsvAnCjnQptNhA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://www.pexels.com/@yankrukov?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">颜</a>从<a class="ae kv" href="https://www.pexels.com/photo/photo-of-woman-showing-frustrations-on-her-face-4458420/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">像素</a></p></figure><p id="deb3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">许多贴子都列出了 Python 和/或其最流行的包的“陷阱”。这篇博客是该系列的又一篇文章，但有一点不同:我自己实际上也确实犯过这些错误(其中一些错误的发生频率令人尴尬)。然而，只要知道每个经典 Python 对象的定义和类型，就可以帮助您在工作中避免大多数(如果不是全部)这样的错误！</p><p id="b929" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事不宜迟，我们开始吧。</p><h1 id="26ff" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">1.Truthy 还是 Falsy: NumPy.nan 和 Pandas.nan</h1><p id="51ea" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">您可能知道，要检查一个对象的值是真还是假，您可以像下面这样做:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="ec84" class="mu lt iq mq b gy mv mw l mx my">lst = [1, 2, 3]<br/>a = None</span><span id="b0c4" class="mu lt iq mq b gy mz mw l mx my"># rather than this ...<br/>if len(lst) &gt; 0 or a is not None: print('success')</span><span id="d242" class="mu lt iq mq b gy mz mw l mx my"># you can simply do this ...<br/>if lst or not a: print('success')</span></pre><p id="f7cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是因为空列表(以及所有其他空序列/集合)、<code class="fe na nb nc mq b">False</code>、<code class="fe na nb nc mq b">None</code>、0(任何数值类型)的计算结果都为 False。这组对象和值因此被称为“<a class="ae kv" href="https://docs.python.org/3/library/stdtypes.html#truth-value-testing" rel="noopener ugc nofollow" target="_blank"> falsy </a>”。</p><p id="0150" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑下面的例子:您有一个项目及其成本的字典，您用它来构建一些分析的数据框架。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="5fe5" class="mu lt iq mq b gy mv mw l mx my">import pandas as pd</span><span id="8ef0" class="mu lt iq mq b gy mz mw l mx my">d1 = {'item': ['foo', 'bar', 'baz'], 'cost': [100, None, 20]}<br/>df = pd.DataFrame(d1)<br/># lots of analysis here ...</span><span id="006e" class="mu lt iq mq b gy mz mw l mx my"># if an item has a cost, print the item and its cost<br/>for i, r in df.iterrows():<br/>    if r['cost']:<br/>        print(f"item = {r['item']} and cost = {r['cost']}")</span></pre><p id="ea83" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您期望:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="0c2d" class="mu lt iq mq b gy mv mw l mx my">item = foo, cost = 100.0<br/>item = baz, cost = 20.0</span></pre><p id="14eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是你会得到:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="9551" class="mu lt iq mq b gy mv mw l mx my">item = foo, cost = 100.0<br/>item = bar, cost = nan<br/>item = baz, cost = 20.0</span></pre><p id="57f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">原因是<a class="ae kv" href="https://pandas.pydata.org/pandas-docs/dev/user_guide/missing_data.html#values-considered-missing" rel="noopener ugc nofollow" target="_blank">熊猫</a>认为<code class="fe na nb nc mq b">None</code>失踪或不在，因此用<code class="fe na nb nc mq b">nan</code>代表。由于<code class="fe na nb nc mq b">nan</code>不是虚假的，它流过。</p><p id="d143" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">乍一看，这似乎违反直觉，但是<code class="fe na nb nc mq b">nan</code> s 是丢失的值，如果丢失了什么，您并不真正<em class="nd">知道它是什么。例如，数字列中给定的<code class="fe na nb nc mq b">nan</code>可以代表 100(真)或 0(假)吗？如果是字符串，是' hello' (truthy)还是空字符串(你猜对了，是 falsy)？熊猫不确定，所以它不会假设是假的。</em></p><p id="b3be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">小心避免考虑<code class="fe na nb nc mq b">nan</code> falsy。</p><h1 id="a95f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">2.是 NaN == NaN？</h1><p id="07bc" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">考虑下面的例子:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="aad5" class="mu lt iq mq b gy mv mw l mx my">&gt;&gt;&gt; s1 = {True, 1, 1.0}<br/>&gt;&gt;&gt; s1<br/>{True}</span></pre><p id="2661" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是意料之中的，因为我们知道<code class="fe na nb nc mq b">1==1.0==True</code>的计算结果为真。</p><p id="f84c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在来看看这个案例:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="0b64" class="mu lt iq mq b gy mv mw l mx my">&gt;&gt;&gt; s2 = {float('nan'), float('nan'), float('nan')}<br/>&gt;&gt;&gt; s2<br/>{nan, nan, nan}</span></pre><p id="7a45" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑前面例子中的逻辑:因为<code class="fe na nb nc mq b">nan</code>是一个缺失值，所以不可能知道三个缺失值是否相同。因此，<code class="fe na nb nc mq b">nan == nan</code>的计算结果始终为 False。(如果您想了解更多相关信息，请务必查看<a class="ae kv" href="https://www.python.org/dev/peps/pep-0754/" rel="noopener ugc nofollow" target="_blank"> PEP 754 — IEEE 754 浮点特殊值</a>。)</p><h1 id="e748" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">3.所有和任何</h1><p id="19d2" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我认为<code class="fe na nb nc mq b">any</code>和<code class="fe na nb nc mq b">all</code>的工作方式如下:如果你有一个可迭代的，如果可迭代的任何元素为真，那么<code class="fe na nb nc mq b">any</code>将返回真。如果 iterable 的所有元素都为真，那么<code class="fe na nb nc mq b">all</code>将返回真。</p><p id="53fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以，让我们来看看。第一，<code class="fe na nb nc mq b">any</code>:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="09f8" class="mu lt iq mq b gy mv mw l mx my">&gt;&gt;&gt; any([0, None, False])  # expected False<br/>False<br/>&gt;&gt;&gt; any([0, None, False, 'False'])  # expected True<br/>True<br/>&gt;&gt;&gt; any([float('nan'), 0])  # expected True<br/>True<br/>&gt;&gt;&gt; any([])  # expected False<br/>False</span></pre><p id="0e7a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">到目前为止，一切顺利！让我们检查一下<code class="fe na nb nc mq b">all</code>:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="9d6a" class="mu lt iq mq b gy mv mw l mx my">&gt;&gt;&gt; all((1, 0, 0))  # expected False<br/>False<br/>&gt;&gt;&gt; all([float('nan'), 1])  # expected True<br/>True<br/>&gt;&gt;&gt; all([])  # expected False<br/>True</span></pre><p id="83ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我认为所有的元素都应该是真的，空的列表显然是假的。那么为什么<code class="fe na nb nc mq b">all([])</code>评估为真呢？</p><p id="f6a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">答案在<a class="ae kv" href="https://docs.python.org/3.8/library/functions.html#all" rel="noopener ugc nofollow" target="_blank"> Python 文档</a>(我的强调是附加的):</p><blockquote class="ne nf ng"><p id="644d" class="kw kx nd ky b kz la jr lb lc ld ju le nh lg lh li ni lk ll lm nj lo lp lq lr ij bi translated"><code class="fe na nb nc mq b"><strong class="ky ir">all</strong></code> <em class="iq"> ( </em>可迭代<em class="iq"> ) </em></p><p id="a7f8" class="kw kx nd ky b kz la jr lb lc ld ju le nh lg lh li ni lk ll lm nj lo lp lq lr ij bi translated">如果<em class="iq"> iterable </em>的所有元素都为真(<strong class="ky ir">或者 iterable 为空</strong>)，则返回<code class="fe na nb nc mq b">True</code>。</p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/618c8a306007c0c3fd98f09ff5736a99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/0*qmUVL2m6gr20Jdqb.gif"/></div></figure><p id="5b8c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但这是为什么呢？嗯，长话短说，是因为<a class="ae kv" href="https://en.wikipedia.org/wiki/Vacuous_truth" rel="noopener ugc nofollow" target="_blank">空洞的真相</a>。“如果我有七英尺高，我也是万亿超级英雄”对我来说永远是真的。我还差大约 6 英寸(忽略我同事的任何相反的证词)，所以不管逗号后面是什么，该语句都是真的。这是一个永远不会错的说法<strong class="ky ir"/>因为我没有七英尺高，因此不可能评价我的万亿富翁超级英雄身份。</p><p id="ee2d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了更仔细地阅读文档之外，记住<code class="fe na nb nc mq b">all()</code>这种行为的最好方法是不要认为它是“如果 iterable 的所有元素都为真”，而是“如果 iterable 中没有 false 元素”当 iterable 为空时，其中不能有 false 元素，这意味着<code class="fe na nb nc mq b">all([])</code>的计算结果为 True。</p><h1 id="4be1" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">4.可变默认参数</h1><p id="dbd5" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我认为这是目前为止最常见的 Python“gotcha”。我们开始吧。</p><p id="d830" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑以下函数:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="2992" class="mu lt iq mq b gy mv mw l mx my">def foo(a, a_list=[]):<br/>    a_list.append(a)<br/>    return a_list</span></pre><p id="2410" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们使用这个函数<code class="fe na nb nc mq b">foo</code>来创建两个单独的列表:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="0a1a" class="mu lt iq mq b gy mv mw l mx my">&gt;&gt;&gt; my_list = foo(10)<br/>&gt;&gt;&gt; print(my_list)  # expected [10]<br/>[10]</span><span id="e512" class="mu lt iq mq b gy mz mw l mx my">&gt;&gt;&gt; another_list = foo(20)<br/>&gt;&gt;&gt; print(another_list)  # expected [20]<strong class="mq ir"><br/></strong>[10, 20]</span></pre><p id="5911" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可能希望每个函数调用都创建一个新的列表，但是在第一次调用<code class="fe na nb nc mq b">foo</code>时创建的列表会在每个后续调用中使用。</p><p id="3ddb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">发生这种情况是因为，在 Python 中，只有当函数被定义时，默认参数才会被计算<strong class="ky ir">，而不是每次函数被调用时(你可以在<a class="ae kv" href="https://docs.python.org/3/tutorial/controlflow.html#default-argument-values" rel="noopener ugc nofollow" target="_blank"> Python 的文档</a>中了解更多)。如果我们使用一个可变的默认参数(比如<code class="fe na nb nc mq b">foo</code>中的<code class="fe na nb nc mq b">a_list=[]</code>)并在函数中改变它，那么每当调用函数时，这个对象就会发生变化。</strong></p><p id="e3bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">避免这种混乱的最好方法是在函数中使用不可变的默认参数。下面是<code class="fe na nb nc mq b">foo</code>的相应更新版本:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="fc3f" class="mu lt iq mq b gy mv mw l mx my">def foo_v2(a, a_list=None):<br/>    if a_list is None:<br/>        a_list = []<br/>    a_list.append(a)<br/>    return a_list</span></pre><p id="359a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个<code class="fe na nb nc mq b">foo</code>的定义假设每次调用都有一个新的列表是可取的。但是，在某些情况下，您可能希望有意传递一个可变对象。一种这样的情况是在编写递归函数时，这需要从一个调用到下一个调用保存对象的状态。<a class="ae kv" href="https://en.wikipedia.org/wiki/Depth-first_search" rel="noopener ugc nofollow" target="_blank">深度优先搜索(DFS) </a>算法的以下实现是这种情况的一个例子:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="2a3a" class="mu lt iq mq b gy mv mw l mx my">def dfs(graph, node):<br/>    """dfs from a given node"""<br/>    return _dfs(graph, node, [])</span><span id="eaaa" class="mu lt iq mq b gy mz mw l mx my">def _dfs(graph, node, path)<br/>    """interior utility function"""<br/>    path += [node]<br/>    for neighbor in graph[node]:<br/>        if neighbor not in path:<br/>            path = _dfs(graph, neighbor, path)<br/>    return path</span><span id="5f24" class="mu lt iq mq b gy mz mw l mx my">&gt;&gt;&gt; graph = {'A': ['B', 'C'], 'B': ['D', 'E'], 'C': ['G'], <br/>         'D': ['F'], 'E': [], 'F': [], 'G': []}<br/>&gt;&gt;&gt; print(dfs(graph, 'A'))  # give the path starting from node 'A'<br/>['A', 'B', 'D', 'F', 'E', 'C', 'G']</span></pre><h1 id="d538" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">5.迭代时修改列表</h1><p id="d6f2" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我已经在我的<a class="ae kv" rel="noopener" target="_blank" href="/bite-sized-python-recipes-52cde45f1489">小食谱</a>帖子中讨论了这最后一个“陷阱”,但是因为我亲眼看到一些人落入这个陷阱，所以我也在这里提一下。</p><p id="a4c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设您想从列表中删除所有小于 5 的数字。</p><p id="bcab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nd">错误实现:</em>迭代时移除元素！</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="21bd" class="mu lt iq mq b gy mv mw l mx my">nums = [1, 2, 3, 5, 6, 7, 0, 1]<br/>for ind, n in enumerate(nums):<br/>    if n &lt; 5:<br/>        del(nums[ind])# expected: nums = [5, 6, 7]<br/>&gt;&gt;&gt; nums<br/>[2, 5, 6, 7, 1]</span></pre><p id="3b00" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nd">正确实施:</em></p><p id="7255" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用列表理解创建一个新列表，只包含您想要的元素:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="5b2c" class="mu lt iq mq b gy mv mw l mx my">&gt;&gt;&gt; id(nums)  # before modification <br/>2090656472968<br/>&gt;&gt;&gt; nums = [n for n in nums if n &gt;= 5]<br/>&gt;&gt;&gt; nums<br/>[5, 6, 7]<br/>&gt;&gt;&gt; id(nums)  # after modification<br/>2090656444296</span></pre><p id="ce29" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面可以看到<code class="fe na nb nc mq b"><a class="ae kv" href="https://docs.python.org/3/library/functions.html#id" rel="noopener ugc nofollow" target="_blank">id</a>(nums)</code>是前后勾选的，说明其实两个列表是不一样的。因此，如果在其他地方使用该列表，并且改变现有列表很重要，而不是创建一个同名的新列表，则将它分配给切片:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="b9dc" class="mu lt iq mq b gy mv mw l mx my">&gt;&gt;&gt; nums = [1, 2, 3, 5, 6, 7, 0, 1]<br/>&gt;&gt;&gt; id(nums)  # before modification <br/>2090656472008<br/>&gt;&gt;&gt; nums[:] = [n for n in nums if n &gt;= 5]<br/>&gt;&gt;&gt; id(nums)  # after modification<br/>2090656472008</span></pre></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><p id="705e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望这篇博客对你有用。我可以在<a class="ae kv" href="https://twitter.com/EhsanKhoda" rel="noopener ugc nofollow" target="_blank"><em class="nd">Twitter</em></a><em class="nd">和</em><a class="ae kv" href="https://www.linkedin.com/in/ehsankhodabandeh" rel="noopener ugc nofollow" target="_blank"><em class="nd">LinkedIn</em></a><em class="nd">上联系到我，我欢迎任何反馈。</em></p></div></div>    
</body>
</html>