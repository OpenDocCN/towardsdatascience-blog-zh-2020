<html>
<head>
<title>Understanding Data Structures in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解 Python 中的数据结构</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/understanding-data-structures-in-python-86e7da6a9b39?source=collection_archive---------40-----------------------#2020-06-10">https://towardsdatascience.com/understanding-data-structures-in-python-86e7da6a9b39?source=collection_archive---------40-----------------------#2020-06-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="20b9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">最有用的内置数据结构概述。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e6620bee603bb6d0d0b71b0e6287a730.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UvZ3SppNua3Rl-3ds1Y5iw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@rihok" rel="noopener ugc nofollow" target="_blank"> Riho Kroll </a>在<a class="ae ky" href="https://unsplash.com/photos/RgLaH00kZOk" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="5eb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated">ython 有很大的可能性来处理我们的数据。让我们仔细看看列表、元组/命名元组、集合和字典的功能。我不打算深入研究，例如，如何在列表中添加或删除元素。我的目标是用简单直接的方式展示每个集合的操作，举例说明它们的陈述。在每个解释的最后，将展示每个系列的主要特征。这些例子将用 Python 语言编写，但是由于重点是概念而不是应用程序，所以您可以将这些应用到您的编程语言中，这可能会以非常相似的方式工作。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="7bbe" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">实验数字电视系统</h1><p id="24df" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated"><strong class="lb iu">2020–06–18</strong></p><ul class=""><li id="4a30" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated">从 Python 3.7 开始，字典保证保持插入顺序。坦克<a class="nr ns ep" href="https://medium.com/u/88e14d0476bd?source=post_page-----86e7da6a9b39--------------------------------" rel="noopener" target="_blank">让-弗朗索瓦·科比特</a></li></ul><h1 id="b948" class="ml mm it bd mn mo nt mq mr ms nu mu mv jz nv ka mx kc nw kd mz kf nx kg nb nc bi translated">元组</h1><p id="2517" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">元组是可以按顺序存储特定数量的其他对象的对象。一旦元素被放入 tuple 中，它们就变得不可变，这意味着您将无法在运行时添加、删除或移动这些元素。反过来，元组在大多数情况下用于存储数据，因此它的主要功能是在一个地方存储不同类型的数据。元组有两种声明方式，不管是否使用括号(，它们的项之间用逗号分隔。</p><p id="d507" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">带括号和不带括号的元组示例。</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="7962" class="od mm it nz b gy oe of l og oh">items = ('Name', 75, 80, 90)<br/>items = 'Name', 75, 80, 90</span></pre><p id="1731" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们可以在元组中添加函数，例如:</p><p id="5377" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oi oj ok nz b">items = calculate((“Name”, 75, 80, 90), datetime.date(2020,01,01))</code></p><p id="3e2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我们需要括号，所以函数的第一个参数是我们的元组，第二个是数据，最后，我们关闭函数的括号，这样我们的 Python 解释器将知道函数的开始和结束位置。</p><h2 id="816d" class="od mm it bd mn ol om dn mr on oo dp mv li op oq mx lm or os mz lq ot ou nb ov bi translated">主要特征:</h2><ul class=""><li id="5828" class="ni nj it lb b lc nd lf ne li ow lm ox lq oy lu nn no np nq bi translated">无序的</li><li id="f7ac" class="ni nj it lb b lc oz lf pa li pb lm pc lq pd lu nn no np nq bi translated">不变的</li><li id="14d9" class="ni nj it lb b lc oz lf pa li pb lm pc lq pd lu nn no np nq bi translated">比列表更快</li></ul></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="2061" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">命名元组</h1><p id="73b7" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">上面我们看到了元组的使用，但在某些情况下，我们可能希望单独访问我们的一些键，让我们分析下面的例子，其中我希望使用元组来表示 RGB 中的颜色。</p><p id="d153" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oi oj ok nz b">rgb_color = (55, 155, 255)</code></p><p id="7428" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以同意，对这个作业的解读并不完全错误。读到这里，我可以确切地理解，当访问 rgb_color [0]键时，它反过来将返回值 55。通过对变量的描述，我知道值 55 代表 RGD 红，但在大多数情况下，这可能不是显而易见的，要么是由于使用的上下文，要么是由于开发人员的经验。举例说明了使用命名元组处理这种情况的更好方法。</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="e3fd" class="od mm it nz b gy oe of l og oh">from collections import namedtuple<br/><br/>Color = namedtuple("Color", "red blue green")<br/>color = Color(red=55, blue=155, green=255)</span></pre><p id="cc2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">命名元组的声明类似于传统元组的声明，在我们的 named tuple 中，作为第一个参数，我们必须通知我们的标识符，第二个参数字符串用空格或逗号分隔。结果是一个与传递的标识符完全相同的对象。这样，我们可以通过访问它的一个属性来解包您的值，例如:<code class="fe oi oj ok nz b">cor.blue</code></p><h2 id="1b2a" class="od mm it bd mn ol om dn mr on oo dp mv li op oq mx lm or os mz lq ot ou nb ov bi translated">主要特征:</h2><ul class=""><li id="5352" class="ni nj it lb b lc nd lf ne li ow lm ox lq oy lu nn no np nq bi translated">类似于元组</li><li id="40dd" class="ni nj it lb b lc oz lf pa li pb lm pc lq pd lu nn no np nq bi translated">让您的元组自文档化。</li><li id="fd78" class="ni nj it lb b lc oz lf pa li pb lm pc lq pd lu nn no np nq bi translated">不需要使用索引来访问元素</li></ul></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="869b" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">目录</h1><p id="5de3" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">列表是几个项目序列的概念，其中，根据需要，您需要将它们分组或按顺序放置。列表的一个特性是，如果有必要，我们可以单独访问列表的每个位置，在 Python 中，它是在两个方括号[]之间声明的，它的内部项由逗号(，)分隔。</p><p id="bfce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oi oj ok nz b">fruits = [‘apple’, ‘banana’, ‘orange’]</code></p><p id="13ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了已经举例说明的数据之外，您还可以用其他类型的数据填充您的列表，比如对象、整数、元组甚至列表的列表。根据定义，我们应该总是优先在我们的列表中存储相同类型的数据，如果你觉得有必要做这种类型的操作，也许你应该看看字典提供了什么。</p><h2 id="454f" class="od mm it bd mn ol om dn mr on oo dp mv li op oq mx lm or os mz lq ot ou nb ov bi translated">主要特征:</h2><ul class=""><li id="c7d4" class="ni nj it lb b lc nd lf ne li ow lm ox lq oy lu nn no np nq bi translated">整齐的</li><li id="1059" class="ni nj it lb b lc oz lf pa li pb lm pc lq pd lu nn no np nq bi translated">易变的</li><li id="f140" class="ni nj it lb b lc oz lf pa li pb lm pc lq pd lu nn no np nq bi translated">接受重复元素</li><li id="827e" class="ni nj it lb b lc oz lf pa li pb lm pc lq pd lu nn no np nq bi translated">按索引访问元素</li><li id="ee92" class="ni nj it lb b lc oz lf pa li pb lm pc lq pd lu nn no np nq bi translated">可以嵌套</li><li id="b916" class="ni nj it lb b lc oz lf pa li pb lm pc lq pd lu nn no np nq bi translated">动态增长</li></ul></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="7124" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">设置</h1><p id="a421" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">您可以将该集合视为列表的扩展，在您想要存储唯一值的情况下应该使用它，而列表本身并没有提供这些值。它的主要特性是存储唯一的和无序的值。在 Python 中，在某些时候，你必须意识到所有的东西都是对象，默认情况下，我们的集合只存储每个对象的相同副本。集合在初始声明时用括号()声明。</p><p id="2f3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的示例中，我们有一个列表，其中包含汽车型号和品牌的元组:</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="4196" class="od mm it nz b gy oe of l og oh">brand_model = [("Fiesta", " Ford"), ("Gol", "VW"), ("KA", "Ford"), ("Uno", Fiat)]<br/>unique_brands = set()<br/><br/>for model, brand in brand_model:<br/>    unique_brands.add(brand)<br/>    <br/>&gt;&gt;&gt; {'Fiat', 'Ford', 'VW'}</span></pre><p id="dbe6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个结果显示了我们独特的汽车品牌，一个重要的细节是，我们的 set 并不按照插入的顺序将结果返回给我们，就像字典一样，Set 并不保证其元素的顺序。我们可以利用集合的一个很好的用途是能够看到集合中有什么或没有什么。</p><h2 id="9f6f" class="od mm it bd mn ol om dn mr on oo dp mv li op oq mx lm or os mz lq ot ou nb ov bi translated">主要特征:</h2><ul class=""><li id="b615" class="ni nj it lb b lc nd lf ne li ow lm ox lq oy lu nn no np nq bi translated">无序的</li><li id="3b75" class="ni nj it lb b lc oz lf pa li pb lm pc lq pd lu nn no np nq bi translated">不允许重复项目</li><li id="bf18" class="ni nj it lb b lc oz lf pa li pb lm pc lq pd lu nn no np nq bi translated">与列表相比，访问速度更快</li><li id="5f8a" class="ni nj it lb b lc oz lf pa li pb lm pc lq pd lu nn no np nq bi translated">支持数学运算(并、交、差)</li></ul></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="bd6a" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">字典</h1><p id="4479" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">根据我作为开发人员的经验，字典是使用 Python 操作数据的最简单和最有效的方式，因为您的问题和数据都可以使用字典。基本上，它在键和值存储中是有意识的，所以 redis 的主要目标是存储来自键-值对的信息，例如:color = blue，其中 color 是我的键，blue 是我的值。非常类似哈希内容，其他语言的 hashmap。在 Python 中，它是在两个大括号{}之间声明的，其内部项用逗号(，)分隔。</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="5042" class="od mm it nz b gy oe of l og oh">car = {'model': 'Ka', 'brand': 'Ford', 'Year': 2012}</span></pre><h2 id="9062" class="od mm it bd mn ol om dn mr on oo dp mv li op oq mx lm or os mz lq ot ou nb ov bi translated">主要特征:</h2><ul class=""><li id="f6c3" class="ni nj it lb b lc nd lf ne li ow lm ox lq oy lu nn no np nq bi translated">无序的</li><li id="38ac" class="ni nj it lb b lc oz lf pa li pb lm pc lq pd lu nn no np nq bi translated">存储不同类型数据的能力</li><li id="631d" class="ni nj it lb b lc oz lf pa li pb lm pc lq pd lu nn no np nq bi translated">可以嵌套</li><li id="b5c9" class="ni nj it lb b lc oz lf pa li pb lm pc lq pd lu nn no np nq bi translated">动态增长</li></ul></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="b3dc" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">结论</h1><p id="ef0e" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">展示的每个系列都有自己的特色，每个系列都必须用于特定的场合。它们的结合使用为我们处理数据提供了极大的灵活性，并使我们解决实际问题的主要目标变得更加容易。</p><h1 id="27d2" class="ml mm it bd mn mo nt mq mr ms nu mu mv jz nv ka mx kc nw kd mz kf nx kg nb nc bi translated">进一步阅读。</h1><p id="56d5" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">如果你想更深入地理解或者看到不同的方法，我在 Medium 上挑选了一些深入研究这个主题的文章。好好学习。</p><div class="pe pf gp gr pg ph"><a rel="noopener follow" target="_blank" href="/pythons-collections-module-high-performance-container-data-types-cb4187afb5fc"><div class="pi ab fo"><div class="pj ab pk cl cj pl"><h2 class="bd iu gy z fp pm fr fs pn fu fw is bi translated">Python 的集合模块——高性能容器数据类型。</h2><div class="po l"><h3 class="bd b gy z fp pm fr fs pn fu fw dk translated">Python 集合模块的快速概述。</h3></div><div class="pp l"><p class="bd b dl z fp pm fr fs pn fu fw dk translated">towardsdatascience.com</p></div></div><div class="pq l"><div class="pr l ps pt pu pq pv ks ph"/></div></div></a></div><div class="pe pf gp gr pg ph"><a href="https://blog.usejournal.com/python-basics-data-structures-d378d854df1b" rel="noopener  ugc nofollow" target="_blank"><div class="pi ab fo"><div class="pj ab pk cl cj pl"><h2 class="bd iu gy z fp pm fr fs pn fu fw is bi translated">Python 基础-数据结构</h2><div class="po l"><h3 class="bd b gy z fp pm fr fs pn fu fw dk translated">Python 内置集合简介</h3></div><div class="pp l"><p class="bd b dl z fp pm fr fs pn fu fw dk translated">blog.usejournal.com</p></div></div><div class="pq l"><div class="pw l ps pt pu pq pv ks ph"/></div></div></a></div><div class="pe pf gp gr pg ph"><a href="https://medium.com/swlh/python-collections-you-should-always-be-using-b579b9e59e4" rel="noopener follow" target="_blank"><div class="pi ab fo"><div class="pj ab pk cl cj pl"><h2 class="bd iu gy z fp pm fr fs pn fu fw is bi translated">您应该始终使用的 Python 集合</h2><div class="po l"><h3 class="bd b gy z fp pm fr fs pn fu fw dk translated">Python collections 是一个被低估的库，它可以将您的编码提升到下一个级别。</h3></div><div class="pp l"><p class="bd b dl z fp pm fr fs pn fu fw dk translated">medium.com</p></div></div><div class="pq l"><div class="px l ps pt pu pq pv ks ph"/></div></div></a></div></div></div>    
</body>
</html>