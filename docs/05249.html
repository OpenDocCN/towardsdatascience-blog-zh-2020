<html>
<head>
<title>Build an interactive dashboard to simulate Coronavirus scenarios in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建一个交互式仪表板，用 Python 模拟冠状病毒场景</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-an-interactive-dashboard-to-simulate-coronavirus-scenarios-in-python-ed23100e0046?source=collection_archive---------45-----------------------#2020-05-04">https://towardsdatascience.com/building-an-interactive-dashboard-to-simulate-coronavirus-scenarios-in-python-ed23100e0046?source=collection_archive---------45-----------------------#2020-05-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/4b246e643b23a05e311ace45ecae5a9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ew2zThNCHzlWiO4u-N6iyA.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">最终仪表板</p></figure><p id="b405" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在本文中，我将带您从头开始使用 Python Plotly/Dash 库构建整个仪表板——不需要任何 Plotly/Dash 方面的经验。我不会深入研究用于模拟的模型；你可以复制粘贴那部分。我已经在这里<a class="ae ld" rel="noopener" target="_blank" href="/infectious-disease-modelling-part-i-understanding-sir-28d60e29fdfc"/>(背景)和这里<a class="ae ld" rel="noopener" target="_blank" href="/infectious-disease-modelling-beyond-the-basic-sir-model-216369c584c4"/>(确切模型)解释过了。</p><p id="a014" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">你可以在这里查看我们将在本文<a class="ae ld" href="https://cosim.herokuapp.com/" rel="noopener ugc nofollow" target="_blank">中构建的仪表板，源代码在</a><a class="ae ld" href="https://github.com/hf2000510/infectious_disease_modelling" rel="noopener ugc nofollow" target="_blank">这个库</a>中的文件<em class="le"> app.py </em>中。</p><p id="9b4f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">让我们开始吧！Plotly/Dash 让您可以用很少几行代码构建基于 web 的反应式仪表盘。你只需要 Python，不需要 Javascript/HTML/CSS 等。创建漂亮的仪表板，并显示来自 Python 函数和脚本的数据非常简单。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="ecf8" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">非常短的 Dash 游戏攻略</h1><p id="c27b" class="pw-post-body-paragraph kf kg it kh b ki mk kk kl km ml ko kp kq mm ks kt ku mn kw kx ky mo la lb lc im bi translated">网上有很多很棒的 Dash 教程，所以我就长话短说。</p><h2 id="c903" class="mp ln it bd lo mq mr dn ls ms mt dp lw kq mu mv ma ku mw mx me ky my mz mi na bi translated">简单的应用程序</h2><p id="04d4" class="pw-post-body-paragraph kf kg it kh b ki mk kk kl km ml ko kp kq mm ks kt ku mn kw kx ky mo la lb lc im bi translated">首先，这里有一个非常简单的 Dash 应用程序，直接来自官方网站。首先，将下面的代码保存在文件<em class="le"> app.py </em>中</p><figure class="nb nc nd ne gt ju"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="65d5" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">然后，打开终端，进入<em class="le"> python3 app.py </em></p><p id="4d73" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">以下是您应该看到的内容:</p><figure class="nb nc nd ne gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nh"><img src="../Images/302bdcf0c3d15d67e7be18dcd804e342.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EaVnliQ3WlUCImMuSEHWUA.png"/></div></div></figure><p id="5fdc" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在，打开网络浏览器，进入我圈出的地址。你应该知道这个:</p><figure class="nb nc nd ne gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ni"><img src="../Images/52a5cdff38fd17eed931822a225e78de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6X7VW2QFKDbw3zuMaTfcjA.png"/></div></div></figure><p id="1153" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">请注意，在我们没有做任何事情的情况下，情节已经是反应式的了——这就是 Dash 的威力。现在再看一下代码。应该很容易看出哪些行对应于网页的哪些部分</p><p id="5cf6" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们实际上只需要一个额外的功能来编写我们的应用程序，其余的只是扩展简介中的简单示例。</p><h2 id="fb79" class="mp ln it bd lo mq mr dn ls ms mt dp lw kq mu mv ma ku mw mx me ky my mz mi na bi translated">复试</h2><p id="3722" class="pw-post-body-paragraph kf kg it kh b ki mk kk kl km ml ko kp kq mm ks kt ku mn kw kx ky mo la lb lc im bi translated">我们在屏幕上有一个可视化，但是用户只能<em class="le">看</em>，而不能<em class="le">改变他或她所看到的</em>。这就是回调的用武之地:回调允许我们构建与用户输入协同工作并对其做出反应的应用程序——方法如下:</p><p id="225b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">让我们实现一个输入，从用户那里获取文本并打印出来(同样，取自 Plotly 示例页面):</p><figure class="nb nc nd ne gt ju"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="7f1a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">从代码中的注释可以清楚地看到发生了什么。每当用户输入一些东西时，我们得到输入并打印出来。同样，运行它(和以前一样的方式)应该会得到这样的输出(不可否认不是太漂亮):</p><figure class="nb nc nd ne gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nj"><img src="../Images/6b6e6f7991fa96b731170609391ea49c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*38hPWF_25Ad58xPE8oOOPQ.png"/></div></div></figure><p id="72ec" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">当然，我们将使用一些其他功能(滑块、不同的图表和日期选择器等)，但核心功能和设置保持不变:</p><ol class=""><li id="03b4" class="nk nl it kh b ki kj km kn kq nm ku nn ky no lc np nq nr ns bi translated">指定一个布局，说明<em class="le">显示什么</em>内容<em class="le">在哪里</em></li><li id="83ef" class="nk nl it kh b ki nt km nu kq nv ku nw ky nx lc np nq nr ns bi translated">实现回调来更新用户输入的内容</li><li id="5a0b" class="nk nl it kh b ki nt km nu kq nv ku nw ky nx lc np nq nr ns bi translated">运行应用程序</li></ol><h1 id="4708" class="lm ln it bd lo lp ny lr ls lt nz lv lw lx oa lz ma mb ob md me mf oc mh mi mj bi translated">数据</h1><p id="e8f4" class="pw-post-body-paragraph kf kg it kh b ki mk kk kl km ml ko kp kq mm ks kt ku mn kw kx ky mo la lb lc im bi translated">正如我在文章的开头所说的，我不会在这里解释这个模型，因为我已经在<a class="ae ld" rel="noopener" target="_blank" href="/infectious-disease-modelling-part-i-understanding-sir-28d60e29fdfc">这篇</a>和<a class="ae ld" rel="noopener" target="_blank" href="/infectious-disease-modelling-beyond-the-basic-sir-model-216369c584c4">这篇</a>文章中解释过了——你可以随意查看这些来获得对这个模型的理解，但是，你不需要这样做来理解这篇文章。</p><p id="da5b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">下面是模型的代码(所有需要的导入都在顶部):</p><figure class="nb nc nd ne gt ju"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="cbe3" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">您可以从代码中复制并粘贴<em class="le"> </em>，但是我已经在文章末尾链接了整个源代码，所以真的没有必要。</p><p id="e1dd" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这里重要的事情是不要被代码中的等式分散注意力，而是要关注控制流:</p><p id="7348" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">你不必关心函数<em class="le"> deriv </em>，它只是在模型内部用来计算一些东西。同样的道理也适用于<em class="le">逻辑 _R_0 </em>。仪表板(和您)唯一重要的功能是<em class="le">型号</em>。这个函数接收用户输入并返回图形数据，所以这就是回调函数的工作。</p><h1 id="2b96" class="lm ln it bd lo lp ny lr ls lt nz lv lw lx oa lz ma mb ob md me mf oc mh mi mj bi translated">布局</h1><p id="683a" class="pw-post-body-paragraph kf kg it kh b ki mk kk kl km ml ko kp kq mm ks kt ku mn kw kx ky mo la lb lc im bi translated">让我们定义用户在屏幕上的什么地方可以看到什么。我们将使用一个<em class="le">外部样式表</em>，这基本上意味着屏幕上的所有元素看起来都很好，而不需要我们摆弄 CSS。</p><p id="961d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">首先，我们需要控件的布局(这是用户可以按下和调整的所有东西)，我们分开做是为了保持代码的整洁:</p><figure class="nb nc nd ne gt ju"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="8b35" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们现在已经定义了这里用红色圈出的所有内容:</p><figure class="nb nc nd ne gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi od"><img src="../Images/5b2fdca74ee2c7582cb24e80abcc3ae8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eg2OzBCX-A3Nvegq7yA6ww.png"/></div></div></figure><p id="69a3" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">通过阅读注释并将代码与输出图片进行比较，应该很容易看出不同组件做了什么。</p><p id="144b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在让我们定义实际的布局，也就是说，我们告诉 Dash 我们刚刚定义的这些控件应该在哪里，图表应该在哪里，以及我们希望在页面顶部有什么样的标题和描述:</p><figure class="nb nc nd ne gt ju"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="ceb0" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">很好，我们现在有了数据、控件和告诉我们在哪里显示控件和数据的布局。现在我们唯一缺少的就是回调。</p><h1 id="0ece" class="lm ln it bd lo lp ny lr ls lt nz lv lw lx oa lz ma mb ob md me mf oc mh mi mj bi translated">复试</h1><p id="e912" class="pw-post-body-paragraph kf kg it kh b ki mk kk kl km ml ko kp kq mm ks kt ku mn kw kx ky mo la lb lc im bi translated">我们不想对用户应用到输入中的每一个微小变化都做出反应，因为那会使我们的程序很快崩溃。相反，您可能已经注意到控件下面有一个“应用”按钮，所以我们只在按钮被按下时才改变输出(即触发回调)。这就是为什么与开始的例子不同，我们的回调看起来像这样:</p><figure class="nb nc nd ne gt ju"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="09af" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">首先，我们列出了<em class="le">输出</em>——这只是我们的图表。然后，我们只有一个<em class="le">输入</em>，即蓝色的“应用”按钮，因此我们的回调仅由它触发。然后我们有几个<em class="le">状态，</em>，这些都是用户可以更改的参数。总而言之，这意味着我们接下来要定义的函数(在回调时被触发)</p><ol class=""><li id="e7da" class="nk nl it kh b ki kj km kn kq nm ku nn ky no lc np nq nr ns bi translated">当用户按下“应用”按钮时，</li><li id="5f70" class="nk nl it kh b ki nt km nu kq nv ku nw ky nx lc np nq nr ns bi translated">将用户可以调整的各种参数的当前<em class="le">状态</em>作为输入(按照上面定义的顺序，即初始日期、人口……)，以及</li><li id="d69f" class="nk nl it kh b ki nt km nu kq nv ku nw ky nx lc np nq nr ns bi translated">应该返回四个数字:一个是主图，一个是死亡率图，一个是 R 值，一个是一段时间内的死亡数，按此顺序。</li></ol><p id="2913" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">让我们定义这样一个函数:</p><figure class="nb nc nd ne gt ju"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="4c03" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这非常简单:将回调中定义的状态作为输入，使用上面的<em class="le">模型</em>函数来计算模拟，并将回调中定义的所有图形作为输出返回。</p><p id="bcc1" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">只有两行代码不见了:</p><pre class="nb nc nd ne gt oe of og oh aw oi bi"><span id="a803" class="mp ln it of b gy oj ok l ol om">if __name__ == '__main__':<br/>    app.run_server(<em class="le">debug</em>=True)</span></pre><p id="4c38" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">仅此而已。像以前一样通过终端启动应用程序，您应该会看到仪表盘！</p><figure class="nb nc nd ne gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nj"><img src="../Images/9d21df5149cca68f4a19ae0baf1d26d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BLA1kNY5ekaL7qrP5IeBxQ.png"/></div></div></figure><p id="763e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">你可以在这个库的<em class="le"> app.py </em>文件中找到代码。如果你也想在网络上发布你的应用，我强烈推荐<a class="ae ld" href="https://medium.com/@austinlasseter/how-to-deploy-a-simple-plotly-dash-app-to-heroku-622a2216eb73" rel="noopener">这个教程</a>。如果你现在想理解和扩展这里使用的模型，请阅读<a class="ae ld" rel="noopener" target="_blank" href="/infectious-disease-modelling-beyond-the-basic-sir-model-216369c584c4">这个</a>！</p><p id="0ba5" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu"> <em class="le">编者注:</em> </strong> <em class="le"> </em> <a class="ae ld" href="http://towardsdatascience.com" rel="noopener" target="_blank"> <em class="le">迈向数据科学</em> </a> <em class="le">是一份以数据科学和机器学习研究为主的中型刊物。我们不是健康专家或流行病学家，本文的观点不应被解释为专业建议。想了解更多关于疫情冠状病毒的信息，可以点击</em> <a class="ae ld" href="https://www.who.int/emergencies/diseases/novel-coronavirus-2019/situation-reports" rel="noopener ugc nofollow" target="_blank"> <em class="le">这里</em> </a> <em class="le">。</em></p></div></div>    
</body>
</html>