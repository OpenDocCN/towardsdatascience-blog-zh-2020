<html>
<head>
<title>Python Numba or NumPy: understand the differences</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python Numba或NumPy:理解区别</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-numba-or-numpy-understand-the-differences-b448dabd5b5b?source=collection_archive---------7-----------------------#2020-02-28">https://towardsdatascience.com/python-numba-or-numpy-understand-the-differences-b448dabd5b5b?source=collection_archive---------7-----------------------#2020-02-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="363c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">有例子支持的简短描述。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/46728e05e163820425912289aedddd15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sVd-1GJJozTJ3ElCFw6IQw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">帕特里克·托马索在<a class="ae ky" href="https://unsplash.com/s/photos/books?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="ba64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated"><span class="l lw lx ly bm lz ma mb mc md di"> N </span> umPy和Numba是两个很棒的用于矩阵计算的Python包。这两种方法都可以有效地处理多维矩阵。在Python中，列表的创建是动态的。向这样的列表追加值将动态地增加矩阵的大小。NumPy的工作方式不同。它以固定的大小构建数组对象。添加或删除任何元素都意味着在内存中创建一个全新的数组。在本文中，我们正在寻找一种有效的对象结构来解决一个简单的问题。</p><p id="d7a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要讨论的不仅是如何创建数组对象，还有如何对这些数组应用科学操作，尤其是扫描数组。当我们对它们应用一些昂贵的逻辑时，性能是拥有这些库的主要动机。例如，当我们开发机器学习(ML)模型时，尤其是在生产环境中，我们会花费合理的时间来优化生成训练数据的代码，应用任何所需的数据转换或任何其他ETL操作。使用一些编译过的编程语言如C或Fortran是理想的，但是这需要我们到处构建一些包装器来将管道返回到Python。</p><h2 id="0cb8" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">在Python中实现数组</h2><p id="73b4" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">让我们举一个简单的例子:首先，我们将用python创建一个包含一千万个值的简单列表。较大的数字会很容易地突出性能上的差异。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="4e53" class="me mf it nd b gy nh ni l nj nk"># We need to import the random package to fillup the array with some random values.</span><span id="b1ca" class="me mf it nd b gy nl ni l nj nk">import random<br/>array = []</span></pre><p id="ce8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我用的是IPython如果你是在Jupyter笔记本上运行这段代码，那么我推荐使用内置的magic (time)。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="56dc" class="me mf it nd b gy nh ni l nj nk">%%time<br/>for i in range(0,10000000):<br/>    val = random.randint(0,1000)<br/>    array.append(val)</span></pre><h2 id="ae22" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">计算频率</h2><p id="4b7a" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">让我们在这个列表中搜索有多少行包含值999？</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="fc64" class="me mf it nd b gy nh ni l nj nk">%%time<br/>freq = 0 <br/>for value in array: <br/>    if value == 999: <br/>        freq = freq + 1</span></pre><p id="41d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的机器用了461毫秒，这个函数找到了值999的10184个实例。现在让我们看看如何使用NumPy数组完成同样的工作。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="9801" class="me mf it nd b gy nh ni l nj nk">import numpy as np</span><span id="79f7" class="me mf it nd b gy nl ni l nj nk"># We use the same list created earlier: <br/>np_array = np.array(array)<br/># To get a sense of the size of the bumpy array, simply call up the function 'shape'<br/>print('The size of the numpy array: ', np_array.shape)</span></pre><p id="ec00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">搜索NumPy数组中包含值999的行只有一行代码:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="463d" class="me mf it nd b gy nh ni l nj nk">%%time<br/>result = np.where(np_array == 999)</span></pre><p id="fecb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了编写一些指令之外，我的机器花了12.6 ms来完成与列表数组相同的工作。</p><p id="b181" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，NumPy数组的索引机制类似于任何普通的Python列表。</p><p id="ee67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们将通过对数组值引入一些数学运算来使这个例子更有趣一些。首先，我们将从原始列表中构造三个向量(X，Y，Z ),然后使用NumPy做同样的工作。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="f29c" class="me mf it nd b gy nh ni l nj nk">def apply_operation_list(array): <br/>    # We need to build an X vector from the original array<br/>    # The math operations in this function represents some random logic.<br/>    x_array = [] <br/>    for array_v in array: <br/>        x_array.append(array_v * 2)<br/>    <br/>    # Building the Y vector<br/>    y_array = []<br/>    for array_v, x_array_v in zip(array, x_array): <br/>        y_array.append(array_v + x_array_v)<br/>    <br/>    # Building the Z vector<br/>    z_array = []<br/>    for array_v, x_array_v, y_array_v in zip(array, x_array, y_array):<br/>        if x_array_v == 0: <br/>            z_array.append(0)<br/>        else: <br/>            z_array.append((array_v - x_array_v ) + y_array_v)<br/>    <br/>    return x_array, y_array, z_array</span><span id="38cf" class="me mf it nd b gy nl ni l nj nk">%%time<br/>x_array, y_array, z_array = apply_operation_list(array)</span></pre><p id="913f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在列表上应用操作花费了3.01秒。</p><p id="5ae6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用<strong class="lb iu"> Numpy </strong>定义同样的函数:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="a31c" class="me mf it nd b gy nh ni l nj nk">def apply_operation_numpy(array): <br/>    # We need to build an X vector from the original array<br/>    # The math operations in this function represent some random logic.<br/>    x_array = array * 2<br/>    <br/>    # Building the Y vector<br/>    y_array = array + x_array<br/>    <br/>    # Building the Z vector<br/>    z_array = ( array - x_array ) + y_array<br/>    <br/>    return x_array, y_array, z_array</span></pre><p id="bc63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用Numpy，只用了132 ms。</p><h1 id="cf2f" class="nm mf it bd mg nn no np mj nq nr ns mm jz nt ka mp kc nu kd ms kf nv kg mv nw bi translated"><strong class="ak">数字巴</strong></h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/e5b004abf6afa95804a299dd3ca27f57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hKI_Yqw384nOYQIILsNChg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">原始照片由<a class="ae ky" href="https://unsplash.com/@pkmfaris?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Faris Mohammed </a>在<a class="ae ky" href="https://unsplash.com/@pkmfaris?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="da6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Numba与Python配合得非常好，它给了你使用你最喜欢的数学库的特权，但是要编译成本机指令[2]。使用Numba很简单，不需要您改变编写函数的方式:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="5ede" class="me mf it nd b gy nh ni l nj nk"># Loading the Numba package<br/># Jit tells numba the function we want to compile<br/>from numba import jit</span></pre><p id="feb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，与上面定义的Numpy函数相比，我们需要做的所有更改。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="a871" class="me mf it nd b gy nh ni l nj nk"><a class="ae ky" href="http://twitter.com/jit" rel="noopener ugc nofollow" target="_blank">@jit</a><br/>def apply_operation_numba(array): <br/>    # We need to build an X vector from the original array<br/>    # The math operations in this function represents some random logic.<br/>    x_array = array * 2<br/>    <br/>    # Building the Y vector<br/>    y_array = array + x_array<br/>    <br/>    # Building the Z vector<br/>    z_array = ( array - x_array ) + y_array<br/>    <br/>    return x_array, y_array, z_array</span></pre><p id="4042" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用Numba，计算三个向量只需要71.5毫秒。</p><h1 id="b6aa" class="nm mf it bd mg nn no np mj nq nr ns mm jz nt ka mp kc nu kd ms kf nv kg mv nw bi translated">选哪个？</h1><blockquote class="ny"><p id="15ae" class="nz oa it bd ob oc od oe of og oh lu dk translated">“NumPy是使用Python进行科学计算的基础包。其中包含:一个强大的N维数组对象、复杂的(广播)函数、集成C/C++和Fortran代码的工具、有用的线性代数、傅立叶变换和随机数功能”[1]</p></blockquote><p id="a3fa" class="pw-post-body-paragraph kz la it lb b lc oi ju le lf oj jx lh li ok lk ll lm ol lo lp lq om ls lt lu im bi translated">NumPy是一个巨大的容器，可以压缩向量空间并提供更有效的数组。最显著的优势是那些容器在执行数组操作时的性能。</p><p id="38db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，Numba旨在提供镜像python函数的本机代码。Python可以被看作Numba API代码的包装器。根据我的经验，每当已经提供的Numpy API不支持我们在向量上执行的操作时，我们就使用Numba。如果实现的定制函数在我们的环境中不够快，那么Numba可以帮助我们在Python解释器中生成函数。这也是来自Numba <a class="ae ky" href="http://numba.pydata.org/numba-doc/0.12/tutorial_numpy_and_numba.html" rel="noopener ugc nofollow" target="_blank">文档</a>的建议。</p><p id="f70c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">前面提供的例子没有显示出差异有多大？这是真的，因为我们只搜索单个值的频率。让我们通过计算一列中所有值的频率来重复这个实验。</p><p id="c684" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Python中，避免嵌套循环(O^2)的最有效方法是使用函数<em class="on"> count() </em>。只需一行代码，我们就可以计算整列的频率:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="67ec" class="me mf it nd b gy nh ni l nj nk">%%time<br/>count = {x:x_array.count(x) for x in x_array}</span></pre><p id="93fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，根据您的处理能力，这个函数可能需要几个小时来完成1000万条记录。接下来让我们看看Numpy能提供什么:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="8ff9" class="me mf it nd b gy nh ni l nj nk">%%time<br/>x_elements_np, x_counts_np = np.unique(x_array_np, return_counts=True)</span></pre><p id="7fdc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<strong class="lb iu"> Numpy </strong>计算一个百万值列的频率需要388毫秒。一个大的性能救济！请注意，该函数仅通过计算不同值的频率来增强。这个例子说明了在大数据环境中使用嵌套循环是多么不现实。</p><p id="5934" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">直到最近，Numba还不支持np.unique()函数，但如果与return_counts一起使用，您仍然不会得到任何好处。这只是为了说明有时Numpy可能是最好的选择。</p><p id="917d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，接下来的两个图显示了使用不同数据对象结构的运行时性能。x轴代表数据大小从10，000行到10亿行的增量。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/18f056595b0342929312546404556a2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M1arUGZuk1aRR5TNUsQTZA.png"/></div></div></figure><p id="58bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下图显示了Numby with Numba库的性能。请注意，该数字可能因数据大小而异。图中的数字表示重复实验五次的平均值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/b9dcfc690bcef2451507fbd457f8cd7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7eXvhey6o4BZTvESLPOqHA.png"/></div></div></figure><h1 id="e36a" class="nm mf it bd mg nn no np mj nq nr ns mm jz nt ka mp kc nu kd ms kf nv kg mv nw bi translated">更多示例</h1><h2 id="2dd0" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">计算奇异值分解</h2><p id="5bd1" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">频率示例只是一个可能不足以给人留下深刻印象的应用，所以让我们选择SVD作为另一个示例。SVD是一种众所周知的无监督学习算法。它允许我们将一个大矩阵分解成多个小矩阵的乘积。奇异值分解在最大似然法中有许多应用，用于降低维数。<a class="ae ky" rel="noopener" target="_blank" href="/svd-8c2f72e264f">这里</a>是一篇推荐文章，供进一步阅读。</p><p id="9bed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的例子只使用了两个维度(列),行数与前面的例子相同。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="bf7a" class="me mf it nd b gy nh ni l nj nk">from scipy.linalg import svd</span><span id="233c" class="me mf it nd b gy nl ni l nj nk"># We will consider in this example only two dimensions. <br/># m x 2 <br/># U: m x r <br/># s: Diagonal matrix r x r<br/># VT: n x r<br/>U, s, VT = svd(array_np[:, 0:2])<br/>Sigma = np.zeros((array_np.shape[0], 2))<br/>Sigma[:2, :2] = np.diag(s)</span></pre><p id="34a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您尝试运行该代码，您可能会得到与下面的失败类似的错误:“ValueError:需要太大的工作数组—无法使用标准的32位LAPACK执行计算。”。这是因为lapack-lite的内部实现使用<code class="fe oq or os nd b">int</code>作为索引。对于像我们的数组这样的大小，它肯定会导致溢出。我们要么减小向量的大小，要么使用另一种算法。如果SVD函数与Numba一起使用，我们也不会得到任何明显的好处，因为我们调用的是LAPACK SVD函数。</p><h2 id="8af2" class="me mf it bd mg mh mi dn mj mk ml dp mm li mn mo mp lm mq mr ms lq mt mu mv mw bi translated">矩阵乘法</h2><p id="695a" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">矩阵乘法是另一个展示Numba如何有助于提高处理时间的例子。即使没有Cuda，我们也可以实现更好的性能。让我们一步步来看这个例子。正如我们之前所做的，我们将使用Python list实现一个函数。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="456e" class="me mf it nd b gy nh ni l nj nk">def matrix_multiplication(A,B):<br/>    row, col_A = A.shape<br/>    col_B = B.shape[1]</span><span id="d37d" class="me mf it nd b gy nl ni l nj nk">    result = np.zeros((row,col_B))</span><span id="6305" class="me mf it nd b gy nl ni l nj nk">    for i in range(0,row):<br/>        for j in range(0,col_B):<br/>            for k in range(0,col_A):<br/>                result[i,j] += A[i,k]*B[k,j] <br/>    return result</span></pre><p id="47fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于1000万行，列表处理乘法运算相当快。运行时间只有1分7秒。使用Numpy，完成同样的工作需要95秒。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="7bd4" class="me mf it nd b gy nh ni l nj nk">def matrix_multiplication_numpy(A,B):<br/>    result = np.dot(A,B)<br/>    return result</span><span id="92c1" class="me mf it nd b gy nl ni l nj nk"><br/>%%time<br/>result = matrix_multiplication_numpy(array_np, array_np)</span></pre><p id="5cb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在用Numba代替Numby，我们用一个简单的函数减少了高成本的乘法运算，结果只用了68秒，减少了28%的时间。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="9ba9" class="me mf it nd b gy nh ni l nj nk"><a class="ae ky" href="http://twitter.com/jit" rel="noopener ugc nofollow" target="_blank">@jit</a><br/>def matrix_multiplication_numba(A, B, result):<br/>    for i in range(result.shape[0]):<br/>        for j in range(result.shape[1]):<br/>            tmp = 0.<br/>            for k in range(A.shape[1]):<br/>                tmp += A[i, k] * B[k, j]<br/>            result[i, j] = tmp</span></pre><p id="9bfb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下图显示了使用Python列表、Numby和Numba库的矩阵乘法的性能。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/a59abcd5d899f9b193ab0412a4855607.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x8IJIem_uJugHESGeF7kzA.png"/></div></div></figure><p id="d3d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本出版物中提供的示例已在15英寸2018 MacBook Pro上运行，容量为16 GB，使用anaconda发行版。这些例子中使用的代码可以在<a class="ae ky" href="https://github.com/malhamid/Python-useful-tools/blob/master/NumPy_Numba_comparisons.ipynb" rel="noopener ugc nofollow" target="_blank"> my Github repo </a>中找到。使用GPU环境可以提高性能，但在这次比较中没有考虑到这一点。</p><h1 id="d7cf" class="nm mf it bd mg nn no np mj nq nr ns mm jz nt ka mp kc nu kd ms kf nv kg mv nw bi translated">参考</h1><p id="4dd3" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">NumPy官方网站，可在线访问https://numpy.org<a class="ae ky" href="https://numpy.org" rel="noopener ugc nofollow" target="_blank"/></p><p id="cd93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Numba官方网站，可在http://numba.pydata.org<a class="ae ky" href="http://numba.pydata.org" rel="noopener ugc nofollow" target="_blank">在线访问</a></p></div></div>    
</body>
</html>