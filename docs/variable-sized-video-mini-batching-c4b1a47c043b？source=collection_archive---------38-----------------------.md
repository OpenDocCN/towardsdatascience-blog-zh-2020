# 可变大小的视频小批量

> 原文：<https://towardsdatascience.com/variable-sized-video-mini-batching-c4b1a47c043b?source=collection_archive---------38----------------------->

## 一种处理帧数不等的视频的批处理算法

![](img/0c9688d38cc17e289debea84eef2f289.png)

亨特·哈里特在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

T 训练和测试高效机器学习模型最重要的一步是收集大量数据并使用这些数据有效训练它的能力。小批量有助于解决这个问题，因为它能够在每次迭代中使用一小部分数据进行训练。但是，随着大量的机器学习任务在视频数据集上执行，出现了有效批处理不等长视频的固有问题。大多数方法依赖于将视频修剪为相等的长度，以便在迭代期间可以提取相同数量的帧并发送给批处理。但在我们需要每一帧的信息来有效预测一些事情的情况下，尤其是在自动驾驶汽车和动作识别的情况下，这不是特别有帮助。这就是创建小批量视频数据集的动机，该数据集可以处理不同长度的视频。

我使用 **LoadStreams** 作为由[Glenn Jocher](https://medium.com/u/f9a2a698dab8?source=post_page-----c4b1a47c043b--------------------------------)([*https://github.com/ultralytics/yolov3*](https://github.com/ultralytics/yolov3))创建的 Yolov3 的 Pytorch 模型的基础，在此基础上我对我的 **LoadStreamsBatch** 类进行建模。

## 类初始化

在 *__init__* 函数中，我接受四个参数。虽然 **img_size** 与原始版本相同，但其他三个参数定义如下:

*   **sources:** 它接受一个目录路径或一个文本文件作为输入。
*   **批量大小:**这是所需的最小批量的大小
*   **subdir_search:** 该选项可以切换，以确保当目录作为 *sources* 参数传递时，在所有子目录中搜索相关文件

我首先检查 **sources** 参数是一个目录还是一个文本文件。如果是一个目录，我会读取目录中的所有内容(如果 **subdir_search** 参数为 *True* ，子目录也包括在内)，否则我会读取文本文件中视频的路径。视频的路径存储在列表中。维护指针 **cur_pos** 以跟踪列表中的当前位置。

列表以 **batch_size** 为最大值进行迭代，并进行额外检查以跳过错误视频或不存在的视频。这些被发送到信箱功能，以调整图像的大小，并将所有组件堆叠在一起，这与原始版本没有变化，除非所有视频都有问题/不可用。

## 函数定期检索帧

由线程调用的 *update* 函数有一个小的变化，我们额外存储了默认的图像大小，用于所有视频都被拾取进行处理，但由于长度不等，一个在另一个之前完成的情况。当我解释代码的下一部分，也就是 *__next__* 函数时，会更清楚。

## 迭代程序

在获得初始运行的所有帧之后，用于处理的帧可以在每个视频的迭代的不同点结束。如果该帧存在，它像往常一样被传递给信箱函数。在帧为 ***None*** 的情况下，这意味着视频已经被完全处理，我们检查列表中的所有视频是否已经被处理。如果有更多视频需要处理，指针 **cur_pos** 用于获取下一个可用视频的位置。
在列表中不再有视频被拾取，但某些视频仍在处理的情况下，一个空白帧被发送到其他批次组件，即它根据其他批次中的剩余帧动态地调整视频的大小。

# 结论

由于花费在数据收集和数据预处理上的时间量，我相信这可以通过减少花费在使视频适合模型上的时间而有所帮助，并且我们可以更专注于使模型适合数据。

我在这里附上完整的源代码。希望这有所帮助！