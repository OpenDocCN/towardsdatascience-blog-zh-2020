<html>
<head>
<title>MLOps with the Feature Store — Hopsworks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用功能商店的MLOps-hops works</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/mlops-with-a-feature-store-816cfa5966e9?source=collection_archive---------6-----------------------#2020-03-05">https://towardsdatascience.com/mlops-with-a-feature-store-816cfa5966e9?source=collection_archive---------6-----------------------#2020-03-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="8db3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">TLDR；如果人工智能要嵌入到企业计算系统的DNA中，企业必须首先重新调整他们的机器学习(ML)开发流程，以包括ML资产(特征和模型)的自动化测试、版本控制、治理和存储。这篇博客详细介绍了如何用特性库实现MLOps过程。</p><h1 id="f391" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">什么是MLOps？</h1><p id="5828" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">MLOps是一个最近的术语，描述了如何应用DevOps原理来自动化ML系统的构建、测试和部署。<a class="ae lo" href="https://github.com/cdfoundation/sig-mlops" rel="noopener ugc nofollow" target="_blank">连续交付基金会的SIG-MLOps </a>将MLOps定义为“DevOps方法的扩展，将机器学习和数据科学资产作为DevOps生态中的一等公民”。MLOps旨在统一ML应用程序开发和ML应用程序的操作，使团队更容易更频繁地部署更好的模型。<a class="ae lo" href="https://martinfowler.com/articles/cd4ml.html" rel="noopener ugc nofollow" target="_blank">Martinfowler.com将MLOps </a>定义为:<br/>“一种软件工程方法，在这种方法中，跨职能团队基于代码、数据和模型，以小而安全的增量生产机器学习应用程序，这些应用程序可以在短的适应周期内随时重现并可靠发布。”</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi lp"><img src="../Images/9631074fc19e5a80cbc02e2d0d48bfba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h2PJ1_TBQg30Vj2W1uaXmw.png"/></div></div><p class="mb mc gj gh gi md me bd b be z dk translated">MLOps的目标是尽可能快地获得一个完整的工作ML系统，并进行增量更改以改进该系统，测试功能和模型，以增强您在不破坏下游模型消费者的情况下进行小更改的能力的信心。</p></figure><p id="b280" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与DevOps相比，MLOps的具体挑战是如何测试、版本化、存储、管理和使用ML系统中产生的两个主要资产:<strong class="jp ir">特性</strong>和<strong class="jp ir">模型</strong>。相比之下，DevOps关心的主要资产是源代码。</p><h1 id="7e0e" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">DevOps与MLOps</h1><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi mf"><img src="../Images/a2ddb1f6ef49b56332677c9f2d3169e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FGI2XPpgoCYc5TwunrODCg.png"/></div></div><p class="mb mc gj gh gi md me bd b be z dk translated">由源代码更改触发的传统DevOps CI/CD工作流。</p></figure><p id="1748" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Git是世界上最流行的源代码版本控制系统。它用于跟踪源代码随时间的变化，并支持不同版本的源代码。对版本控制的支持是自动化和<a class="ae lo" href="https://cloud.google.com/solutions/devops/devops-tech-continuous-integration" rel="noopener ugc nofollow" target="_blank">持续集成</a> (CI)解决方案的先决条件，因为它能够以全自动的方式对任何环境进行可重复的配置。也就是说，我们假设提供环境所需的配置信息存储在版本控制系统中，以及我们将要测试的系统的源代码。通常，在使用DevOps时，每次提交Git都会触发包的自动创建，只需使用版本控制中的信息就可以将这些包部署到任何环境中。</p><p id="b8f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在许多DevOps设置中，<a class="ae lo" href="https://jenkins.io/" rel="noopener ugc nofollow" target="_blank"> Jenkins </a>与Git一起用作自动化服务器，以可控和可预测的方式构建、测试和部署您的版本化代码。Jenkins遵循的CI/CD管道的典型步骤是:提供测试虚拟机(VMs容器，将代码签出到机器上，编译代码，运行测试，打包二进制文件，以及部署二进制文件。对于Java，这涉及到运行一个像maven这样的构建工具来编译、测试和打包Java二进制文件，然后再将二进制文件部署到某个登台或生产系统中。对于Docker化的应用程序，这意味着编译Docker文件，然后构建Docker映像并将其部署到Docker注册表中。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi mg"><img src="../Images/4920b8438db50b6a3807993797e454d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H5GLqScU2xu7Cq8NaL7_ow.png"/></div></div><p class="mb mc gj gh gi md me bd b be z dk translated">MLOps:特征工程和模型训练的CI/CD工作流可以由源代码或数据的变化触发。</p></figure><p id="aeec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">也许MLOps最具定义性的特征是需要管理数据和代码，以便为训练模型提供可重现的工作流。Git不适合作为对大量数据进行版本控制的平台。</p><p id="55f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，Git和Jenkins对于MLOps来说是不够的，在MLOps中，构建过程涉及运行复杂的分布式工作流，我们需要<em class="mh"/><em class="mh">版本化代码</em>和<em class="mh">版本化数据</em>来确保可复制的自动化构建。但是数据不是管理特征和模型的正确抽象层次。</p><p id="9b8a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">特征是特征存储中的可变数据</strong> —用于创建特征的新数据应该不断到达，否则使用这些特征进行推理的模型将不再创造任何价值。特征还具有模式、自定义元数据，并且在被模型用于训练或推断之前可能需要特定于模型的转换。(特定于模型的转换发生在特征存储之后(例如标准化一个数字特征)，因此特征数据可以更容易地在不同模型之间重用)。特征数据也应该被验证，例如，使用像<a class="ae lo" href="https://www.hopsworks.ai/post/data-validation-for-enterprise-ai-using-great-expectations-with-hopsworks" rel="noopener ugc nofollow" target="_blank">远大前程</a>这样的框架。</p><p id="d178" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">模型是模型注册表中不可变的数据</strong>。模型是版本化的，可以通过推理或训练管道安全地下载和缓存。模型还具有用于治理的模式和定制元数据(例如，描述如何以及在哪里可以使用模型)。还应该对模型进行验证，以确保它们在看不见的数据上有足够好的性能，没有偏差(通过测试模型在不同测试数据切片上的表现)，并且对非分布特征值具有鲁棒性。</p><h1 id="435d" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">Hopsworks特征库(和模型注册表)</h1><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi mi"><img src="../Images/cb00dbab11063a2fb00968c6735574ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xHPVlvztTwDRC_RuN353HQ.png"/></div></div><p class="mb mc gj gh gi md me bd b be z dk translated">特性库使您能够将您的整体ML管道重构为3个管道，每个管道都可以以自己的节奏运行:一个特性管道、一个训练管道和一个推理管道。</p></figure><p id="93b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">功能存储解决了整体式ML管道的以下问题:</p><ul class=""><li id="0c92" class="mj mk iq jp b jq jr ju jv jy ml kc mm kg mn kk mo mp mq mr bi translated">通过在不同模型中启用功能重用，实现功能的发现和重用；</li><li id="102d" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated">为相同的特性启用双离线/在线API:对用于训练和批量推断的特性数据的高吞吐量批量访问，以及对在线模型的特性的低延迟读取；</li><li id="2452" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated">确保特征、训练和推理管道中转换的一致性——用于计算特征的函数的单个定义在三个不同的管道中重复使用；</li><li id="b8c5" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated">确保训练数据中特征的时间点正确性(确保没有数据泄漏)；</li><li id="5dd2" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated">分离特征、训练和推理管道，以便操作管道(特征、推理)可以以它们自己的节奏运行，并且训练可以按需完成。</li></ul><h1 id="76de" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">F‍eature管道公司</h1><p id="0bd0" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">特征管线与数据管线共享许多相同的最佳实践DevOps实践。数据/特征的一些自动测试类型包括:</p><ul class=""><li id="2f42" class="mj mk iq jp b jq jr ju jv jy ml kc mm kg mn kk mo mp mq mr bi translated">所有特性化代码的单元测试和集成测试(当代码被推送到Git时，Jenkins可以运行这些测试)；</li><li id="22d3" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated">测试特征值是否在预期范围内；</li><li id="dde9" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated">测试特性的唯一性、完整性和独特性；</li><li id="7188" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated">测试特性分布是否符合您的期望；</li><li id="713a" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated">测试每个特征和标记之间的关系，以及单个信号之间的成对相关性；</li><li id="9575" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated">测试每个功能的成本；</li><li id="1480" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated">测试个人身份信息不会泄露到功能中(自定义测试)。</li></ul><p id="53f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当特征存储可用时，特征管线的输出存储在特征存储中称为<em class="mh">特征组</em>的表中。理想情况下，目标数据接收器将支持版本化数据，例如在Apache胡迪的Hopsworks功能存储中。在Hopsworks中，特征管线将数据向上插入(插入或更新)到现有的特征组中，其中特征组是一起计算的一组特征(通常是因为它们来自相同的后端系统，并且通过一些实体或键相关)。每次为要素组运行要素管道时，它都会在汇胡迪数据集中创建一个新的提交，并且还可能会更新在线数据库中的最新要素值。</p><h1 id="c902" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">模型培训渠道</h1><p id="f797" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">在模型验证步骤中执行的自动化测试类型包括:</p><ul class=""><li id="274e" class="mj mk iq jp b jq jr ju jv jy ml kc mm kg mn kk mo mp mq mr bi translated">在看不见的数据上测试模型的性能，</li><li id="d03b" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated">测试模型在不同数据切片上的表现以检查偏差，</li><li id="76d2" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated">测试模型对非分布特征值的稳健性。</li></ul><h1 id="fd62" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">推理管道—特征监控和预测监控</h1><p id="08ae" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">可以监控特征的漂移——与特征数据的<em class="mh">参考窗口</em>相比，特征数据的<em class="mh">检测窗口</em>中有意义的(也可能是统计上显著的)变化。类似地，<em class="mh">模型预测</em>可以与<em class="mh">结果</em>进行比较，以查看预测性能是否有有意义的变化。乔希·托宾很好地描述了在这里寻找什么。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi mx"><img src="../Images/2a262cbdd599debe2f53fc24105aa467.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I6J5hPF0mj9PtjbgYnF6gg.png"/></div></div><p class="mb mc gj gh gi md me bd b be z dk translated">图片来自[<a class="ae lo" href="https://concept-drift.fastforwardlabs.com/" rel="noopener ugc nofollow" target="_blank">https://concept-drift.fastforwardlabs.com/</a></p></figure><p id="66f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上图中，我们可以看到，我们有时可以直观地比较漂移数据的分布。在Hopsworks要素存储中，我们仅有的实际数据集是要素组和训练数据集。当一个特征组(或一个特征组的子集)是参考窗口时，我们可以检测<em class="mh">特征组漂移</em>。当在其上训练的模型的训练数据集是参考窗口时，我们可以检测模型的<em class="mh">特征漂移。</em></p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi my"><img src="../Images/ab2e327fb59329ca78261ff24bebc01a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3e2QnyRzHI1c7PF-Eo8Y3A.png"/></div></div><p class="mb mc gj gh gi md me bd b be z dk translated">特征组转移是在数据被写入特征存储之前，模型的特征漂移是为了识别已部署模型的特征分布中的漂移，而概念漂移是为了测试模型的陈旧性。</p></figure><p id="40de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上图显示了监控基础设施可以识别的三种不同类型的漂移:</p><ul class=""><li id="0c09" class="mj mk iq jp b jq jr ju jv jy ml kc mm kg mn kk mo mp mq mr bi translated"><strong class="jp ir">特征存储中特征的特征漂移</strong>，在特征存储中，我们监控将要写入特征组的特征分布的变化；</li><li id="f0bc" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated"><strong class="jp ir">已部署模型的特征漂移</strong>，其中我们监控模型的推断数据窗口与模型的训练数据的特征分布相比的漂移；</li><li id="10ec" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated"><strong class="jp ir">概念漂移</strong>模型产生的预测变得越来越差(例如，与模型评估期间相比，您根据看不见的数据评估模型性能)。</li></ul><h2 id="5588" class="mz km iq bd kn na nb dn kr nc nd dp kv jy ne nf kz kc ng nh ld kg ni nj lh nk bi translated">摘要</h2><p id="e0db" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">我们现在已经介绍了一个基于MLOps原则的端到端ML管道和一个特性库。对管道代码或新到达的数据的更新使得变化能够被持续地测试，并且模型能够被持续地更新和部署到生产中。我们展示了特征库如何使整体的端到端ML管道分解成特征管道和模型训练管道。我们还讨论了如何利用现代数据湖框架(如Apache胡迪)实现数据版本控制。在下一篇博客中，我们将更详细地介绍ML管道和可重复实验Hopsworks，以及如何轻松地将管道从开发环境迁移到生产环境。我们还将展示如何使用Airflow开发特征管道和模型训练管道。</p><h2 id="18a5" class="mz km iq bd kn na nb dn kr nc nd dp kv jy ne nf kz kc ng nh ld kg ni nj lh nk bi translated">Hopsworks入门</h2><ul class=""><li id="e791" class="mj mk iq jp b jq lj ju lk jy nl kc nm kg nn kk mo mp mq mr bi translated"><a class="ae lo" href="https://app.hopsworks.ai" rel="noopener ugc nofollow" target="_blank">app . hops works . ai</a>(5分钟后开始)</li><li id="eb40" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated"><a class="ae lo" href="https://docs.hopsworks.ai" rel="noopener ugc nofollow" target="_blank"> docs.hopsworks.ai </a></li><li id="262e" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated"><a class="ae lo" href="https://www.hopsworks.ai" rel="noopener ugc nofollow" target="_blank"> www.hopsworks.ai </a></li></ul><h1 id="5425" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">参考</h1><ul class=""><li id="4c03" class="mj mk iq jp b jq lj ju lk jy nl kc nm kg nn kk mo mp mq mr bi translated"><a class="ae lo" href="http://www.featurestore.org/" rel="noopener ugc nofollow" target="_blank">机器学习的特征库</a></li><li id="146b" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated"><a class="ae lo" href="https://www.hopsworks.ai/the-python-centric-feature-store" rel="noopener ugc nofollow" target="_blank">hops works功能商店</a></li><li id="2a18" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated"><a class="ae lo" href="https://storage.googleapis.com/pub-tools-public-publication-data/pdf/45742.pdf" rel="noopener ugc nofollow" target="_blank">斯卡利等人，你们的ML测试成绩是多少？ML生产系统的规则</a></li><li id="0040" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated"><a class="ae lo" href="http://stevenwhang.com/tfx_paper.pdf" rel="noopener ugc nofollow" target="_blank"> Baylor等人，TFX:基于TensorFlow的生产规模机器学习平台</a></li><li id="e13a" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated"><a class="ae lo" href="https://github.com/cdfoundation/sig-mlops" rel="noopener ugc nofollow" target="_blank"> CDF特殊兴趣小组— MLOps </a></li><li id="fa06" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated"><a class="ae lo" href="https://martinfowler.com/articles/cd4ml.html" rel="noopener ugc nofollow" target="_blank">机器学习的连续交付</a></li></ul><p id="fbff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mh">本文于2020年3月首次发表，并于2023年2月21日进行了大量编辑。这篇文章的原文可以在</em> <a class="ae lo" href="https://www.logicalclocks.com/blog/mlops-with-a-feature-store" rel="noopener ugc nofollow" target="_blank"> <em class="mh">逻辑时钟的博客</em> </a> <em class="mh">上找到。</em></p></div></div>    
</body>
</html>