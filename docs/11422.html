<html>
<head>
<title>OmniNet: If Ben’s Omnitrix had a better Machine Learning/Artificial Intelligence system inbuilt?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">OmniNet:如果本的 Omnitrix 内置了更好的机器学习/人工智能系统？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/omninet-if-bens-omnitrix-had-a-better-machine-learning-artificial-intelligence-inbuilt-70dcb321be79?source=collection_archive---------45-----------------------#2020-08-07">https://towardsdatascience.com/omninet-if-bens-omnitrix-had-a-better-machine-learning-artificial-intelligence-inbuilt-70dcb321be79?source=collection_archive---------45-----------------------#2020-08-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4072" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">OmniNet:如果本的 Omnitrix 内置了更好的机器学习/人工智能系统？</h2></div><p id="b09f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我是 Ben 10 系列的忠实粉丝，我一直想知道为什么 Ben 的 Omnitrix 没有变成 Ben 选择成为的外星人<a class="ae lb" href="https://5yl.fandom.com/wiki/Omnimatrix_Devices" rel="noopener ugc nofollow" target="_blank">(这很大程度上是因为手表中已经内置了一个弱人工智能系统)</a>。为了帮助本，我们将设计<strong class="kh ir">“OmniNet”，一种能够根据给定情况预测合适外星人的神经网络。</strong></p><p id="eca6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如节目中所讨论的，Omnitrix 基本上是一个连接到行星<strong class="kh ir"> Primus </strong>的服务器，用来控制大约 10000 个外星人的 DNA！如果我是这款设备的工程师，我肯定会给手表增加一个或多个功能。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lc"><img src="../Images/876ea2a794c004865d0a6e4ad9b6ef9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mbbV91BBJtzeZXgB"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">普里默斯位于太空深处。(<a class="ae lb" href="https://unsplash.com/photos/E0AHdsENmDg" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/photos/E0AHdsENmDg</a>)</p></figure><h1 id="d26e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">为什么和如何？</h1><p id="a37f" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi mp translated"><span class="l mq mr ms bm mt mu mv mw mx di">W</span>T10】hy:Omnitrix/ulti matrix 是一个特例，因为它不知道周围的环境。根据 Azmuth 和其他人的说法，Omnitrix 有时会给出错误的转换，因为它自己的人工智能系统会得到错误的分类。让我们想象一下，造物主阿兹慕雇佣我们来建造一个新的人工智能/ML 系统。</p><p id="f4dd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi mp translated"><span class="l mq mr ms bm mt mu mv mw mx di"> H </span> ow:为了建立我们的系统，我们需要某种形式的初始数据，感谢我们的地球同胞，我们有了<a class="ae lb" href="https://www.kaggle.com/shiddharthsaran/ben-10-dataset" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>的 Ben 10 数据集。</p><h1 id="d63b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">要求</h1><p id="4b7a" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">对于任何项目，我们都需要一个良好的需求列表，对于这个项目，我们需要:</p><ul class=""><li id="c396" class="mz na iq kh b ki kj kl km ko nb ks nc kw nd la ne nf ng nh bi translated">Python 3.8:编程语言</li><li id="9a68" class="mz na iq kh b ki ni kl nj ko nk ks nl kw nm la ne nf ng nh bi translated">Scikit-Learn:通用机器学习</li><li id="1093" class="mz na iq kh b ki ni kl nj ko nk ks nl kw nm la ne nf ng nh bi translated">熊猫:用于数据分析</li><li id="4bd9" class="mz na iq kh b ki ni kl nj ko nk ks nl kw nm la ne nf ng nh bi translated">Numpy:用于数值计算</li><li id="3734" class="mz na iq kh b ki ni kl nj ko nk ks nl kw nm la ne nf ng nh bi translated">张量流:构建我们的深层神经网络</li><li id="2293" class="mz na iq kh b ki ni kl nj ko nk ks nl kw nm la ne nf ng nh bi translated">Matplotlib:绘制我们的进度</li></ul><h1 id="6add" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">数据预处理</h1><p id="f9ea" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi mp translated">T21 的数据集由 3 列 97 行组成。这些列是不言自明的，在分析数据时，我们立即将所有的分类表示转化为数字表示。</p><ul class=""><li id="84f4" class="mz na iq kh b ki kj kl km ko nb ks nc kw nd la ne nf ng nh bi translated"><strong class="kh ir">角色</strong>:本 10 系列角色</li><li id="8ef4" class="mz na iq kh b ki ni kl nj ko nk ks nl kw nm la ne nf ng nh bi translated"><strong class="kh ir">异能等级</strong>:角色的异能等级</li><li id="bbb6" class="mz na iq kh b ki ni kl nj ko nk ks nl kw nm la ne nf ng nh bi translated"><strong class="kh ir">本 10 系列</strong>:与角色相关的系列</li></ul><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/8bfd83b8937dddfd4e2cc4d4836c40f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:698/format:webp/1*Bh2-ZYw1XbMs0q1AWW8OCw.png"/></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">资料组</p></figure><pre class="ld le lf lg gt no np nq nr aw ns bi"><span id="5fec" class="nt lt iq np b gy nu nv l nw nx">lr = LabelEncoder()</span><span id="07fd" class="nt lt iq np b gy ny nv l nw nx">def convert_id_to_category(index, mapping=None):<br/>    """<br/>        Convert the id into the label<br/>        Arguments:<br/>            mappping: The Mapping built by the LabelEncoder<br/>            id: id corresponding to the label<br/>        Returns:<br/>            str: the label<br/>    """<br/>    return mapping.get(index, False)</span><span id="864b" class="nt lt iq np b gy ny nv l nw nx">def convert_to_mapping(lr:LabelEncoder):<br/>    """<br/>        Extract the mapping from the LabelEncoder<br/>        <br/>        Returns:<br/>            Dict: key/value for the label encoded<br/>    """<br/>    mapping = dict(list(zip(lr.transform(lr.classes_),lr.classes_)))<br/>    return mapping</span><span id="a0e3" class="nt lt iq np b gy ny nv l nw nx">def get_power_level_mapping(df=None):<br/>    mapping = {}<br/>    for i in range(0, len(df)):<br/>        mapping[df.loc[i].Character] = df.loc[i].Power_Level<br/>    vtok = {}<br/>    for i,j in enumerate(mapping):<br/>        vtok[mapping[j]] = j<br/>    return mapping, vtok</span><span id="14f1" class="nt lt iq np b gy ny nv l nw nx"># Ben_10_Series<br/>df['Ben_10_Series'] = lr.fit_transform(df['Ben_10_Series'])<br/>mapping_ben_10_series = convert_to_mapping(lr)<br/>df['Character'] = lr.fit_transform(df['Character'])<br/>mapping_character = convert_to_mapping(lr)</span><span id="c95c" class="nt lt iq np b gy ny nv l nw nx">print ("Length [Ben_10_Series]: {}".format(len(mapping_ben_10_series)))<br/>print ("Length [Character]: {}".format(len(mapping_character)))</span><span id="007d" class="nt lt iq np b gy ny nv l nw nx">def remove_string_powerlevel(df=None):<br/>    """<br/>        Replaces the string format of power level into an integer. (Manually checked the data)<br/>        <br/>        Arguments:<br/>            df: Pandas DataFrame<br/>        Returns<br/>            None<br/>    """<br/>    <br/>    # lowe bound<br/>    df.loc[28, "Power_Level"] = "265"<br/>    df.loc[93, "Power_Level"] = "12.5"<br/>    df.loc[51, "Power_Level"] = "195"<br/>    df.loc[52, "Power_Level"] = "160"<br/>    df.loc[62, "Power_Level"] = "140"<br/>    df.loc[67, "Power_Level"] = "20"<br/>    df['Power_Level'] = df['Power_Level'].str.replace(",","")<br/>    <br/>    # converting power_level to float<br/>    df['Power_Level'] = df['Power_Level'].astype(float)<br/>    df['Character'] = df['Character'].astype(int)</span><span id="b12d" class="nt lt iq np b gy ny nv l nw nx">remove_string_powerlevel(df)</span></pre><p id="1db3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi mp translated"><span class="l mq mr ms bm mt mu mv mw mx di">在</span>中，除了更改分类表示，我们还清理了数据(列:Power_Level ),因为它包含一些文本级别。该列还包含逗号，因此我们也对其进行了清理。</p><h1 id="9125" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">特征转换</h1><p id="f2e4" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi mp translated"><span class="l mq mr ms bm mt mu mv mw mx di">在</span>上检查进一步的数据，我们可以清楚地看到一些异常值。(原子 X 和外星人 X)。如果你熟悉本 10，你应该知道这些外星人非常强大！</p><blockquote class="nz oa ob"><p id="b9c1" class="kf kg my kh b ki kj jr kk kl km ju kn oc kp kq kr od kt ku kv oe kx ky kz la ij bi translated">除了要素转换，我们将创建一个能够处理多类分类问题的<strong class="kh ir">新数据集。</strong></p><p id="c98f" class="kf kg my kh b ki kj jr kk kl km ju kn oc kp kq kr od kt ku kv oe kx ky kz la ij bi translated">为了查看我们可以在哪里应用特征变换，我们将首先检查任何异常值。</p></blockquote><p id="89de" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面给出的散点图展示了这两个 Power_Level 的偏差程度。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi of"><img src="../Images/f2febb48f438a7f0fa43344cceaae336.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*xHZ_pIfZ8qrSOjCU_CtKKw.png"/></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">极端值</p></figure><p id="969f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi mp translated"><span class="l mq mr ms bm mt mu mv mw mx di">我们</span>可以清楚地看到有两个异常值，检查异常值的明显方法是分析它们的<a class="ae lb" href="https://en.wikipedia.org/wiki/Standard_score" rel="noopener ugc nofollow" target="_blank"> zscores </a>并设置一个阈值。</p><pre class="ld le lf lg gt no np nq nr aw ns bi"><span id="50d7" class="nt lt iq np b gy nu nv l nw nx">values = df['Power_Level'].values<br/>zscore(values, 0) &gt; zscore(values, 0).mean() # All the True values are outliers.</span><span id="d1be" class="nt lt iq np b gy ny nv l nw nx">values[96] = np.mean(values)<br/>values[36] = np.mean(values)<br/># changing the outliers to mean value<br/># handpicking abnormal values and setting it a justified value.</span></pre><ul class=""><li id="4206" class="mz na iq kh b ki kj kl km ko nb ks nc kw nd la ne nf ng nh bi translated">如果我们将<strong class="kh ir">阈值设置为 zscore 值的平均值，我们可以清楚地看到所有为真的异常值。</strong></li><li id="0ec9" class="mz na iq kh b ki ni kl nj ko nk ks nl kw nm la ne nf ng nh bi translated">现在我们不想删除这些值，因为<strong class="kh ir">每个字符都很重要</strong>。</li></ul><blockquote class="og"><p id="b961" class="oh oi iq bd oj ok ol om on oo op la dk translated">但是，由于我们知道数据集，我们不想删除任何外国人，我们将手动改变离群指数的平均功率水平。</p></blockquote><figure class="or os ot ou ov lh gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/1fe7a535370022829bdefd9d55c1f13f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/1*ZswjK6bgsVjcj1LK2NKKIQ.png"/></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">我们修改过的 Power_Level 列</p></figure><h1 id="3da4" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">新数据集的创建</h1><p id="7476" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi mp translated">制定一个新的问题不是一件容易的事情，但是因为我们是 Ben 10 系列的狂热粉丝，我们可以很容易地制定一个新的数据集。</p><blockquote class="og"><p id="7b45" class="oh oi iq bd oj ok ow ox oy oz pa la dk translated">由于缺乏信息(特征)，我们将首先根据一个因子拆分修改后的 Power_Level。为了任务的简洁，我们将把整数分成另外三列。</p></blockquote><h2 id="7c7d" class="nt lt iq bd lu pb pc dn ly pd pe dp mc ko pf pg me ks ph pi mg kw pj pk mi pl bi translated"><strong class="ak"> 1。沙之力</strong>:陆地上人物的力量</h2><h2 id="806d" class="nt lt iq bd lu pb pm dn ly pd pn dp mc ko po pg me ks pp pi mg kw pq pk mi pl bi translated"><strong class="ak"> 2。空气力量</strong>:角色在空气中的力量</h2><h2 id="62e9" class="nt lt iq bd lu pb pm dn ly pd pn dp mc ko po pg me ks pp pi mg kw pq pk mi pl bi translated"><strong class="ak"> 3。水力</strong>:水中人物的力量</h2><pre class="ld le lf lg gt no np nq nr aw ns bi"><span id="3feb" class="nt lt iq np b gy nu nv l nw nx">def split_powerlevel(df, factor=3):<br/>    """<br/>        Split the power level by the specified factor<br/>        Arguments:<br/>            df:DataFrame<br/>            factor: int<br/>        Returns:<br/>            data: dict[str] = list[str]<br/>            <br/>    """<br/>    data = {'air_power1':[], 'sand_power1':[], 'water_power1':[], "air_power2":[], "sand_power2":[], "water_power2":[]}<br/>    for i in df['power_level1']:<br/>        t = i/factor # float<br/>        data['air_power1'].append(t)<br/>        data['sand_power1'].append(t)<br/>        data['water_power1'].append(t)<br/>    for i in df['power_level2']:<br/>        t = i/factor # float<br/>        data['air_power2'].append(t)<br/>        data['sand_power2'].append(t)<br/>        data['water_power2'].append(t)<br/>    return data</span><span id="d226" class="nt lt iq np b gy ny nv l nw nx">def return_individual_data(th = .5, winner='c1'):<br/>        """<br/>            Returns a row in our dataset.<br/>            <br/>            Arguments:<br/>                th: threshold<br/>                winner: The winning character<br/>                <br/>            Returns:<br/>                (str,str, float, float, str)<br/>        """<br/>        characters = np.array(list(mapping_character.keys()))<br/>        mapping_ch_to_pl, mapping_pl_to_ch = get_power_level_mapping(df)<br/>        random_character1 = np.random.choice(characters)<br/>        random_character2 = np.random.choice(characters)<br/>        p1 = mapping_ch_to_pl[random_character1]<br/>        p2 = mapping_ch_to_pl[random_character2]<br/>        power_diff = np.abs(mapping_ch_to_pl[random_character1] - mapping_ch_to_pl[random_character2])<br/>        if winner == 'c1':<br/>            return random_character1, random_character2,p1, p2, random_character1<br/>        else:<br/>            return random_character1, random_character2,p1, p2, random_character2</span></pre><p id="6d32" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于每个字符，我们在最终的数据帧中增加了 3 列</p><blockquote class="og"><p id="21cc" class="oh oi iq bd oj ok ow ox oy oz pa la dk translated">F <!-- -->对于我们数据集中的每一行，我们随机选择角色，并以 50:50 的比例将其分配给集合<strong class="ak">(角色 1 赢得 50 %的决斗，角色 2 赢得 50%的决斗)</strong>。</p></blockquote><figure class="or os ot ou ov lh gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/11a6f304689b25dd68f554d7956e1c3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*nPm8ZGAsiB2OYvZdQETWYw.png"/></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">调用 return_individual_data</p></figure><p id="86e3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了这条信息，功率水平除以因子 3 以创建一组 10 个特征。</p><p id="568b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了总结所有内容，我们将每一行合并并调用它 n 次，每次将功率级分成 3 列。</p><pre class="ld le lf lg gt no np nq nr aw ns bi"><span id="3bde" class="nt lt iq np b gy nu nv l nw nx">def create_data(df, split_size=0.2, size=1000):<br/>    """<br/>        Create Data for Multiclass classification problem<br/>        Arguments:<br/>            df: Pandas DataFrame<br/>        Returns:<br/>            data: Pandas DataFrame<br/>    """<br/>    def return_individual_data(th = .5, winner='c1'):<br/>        """<br/>            Returns a row in our dataset.<br/>            <br/>            Arguments:<br/>                th: threshold<br/>                winner: The winning character<br/>                <br/>            Returns:<br/>                (str,str, float, float, str)<br/>        """<br/>        characters = np.array(list(mapping_character.keys()))<br/>        mapping_ch_to_pl, mapping_pl_to_ch = get_power_level_mapping(df)<br/>        random_character1 = np.random.choice(characters)<br/>        random_character2 = np.random.choice(characters)<br/>        p1 = mapping_ch_to_pl[random_character1]<br/>        p2 = mapping_ch_to_pl[random_character2]<br/>        power_diff = np.abs(mapping_ch_to_pl[random_character1] - mapping_ch_to_pl[random_character2])<br/>        if winner == 'c1':<br/>            return random_character1, random_character2,p1, p2, random_character1<br/>        else:<br/>            return random_character1, random_character2,p1, p2, random_character2</span><span id="72b6" class="nt lt iq np b gy ny nv l nw nx"># win is by character1 (by default)<br/>    data = {'character1':[], 'character2':[], 'power_level1':[],'power_level1':[],'power_level2':[], 'win':[]}<br/>    <br/>    # first half<br/>    for i in range(0, size//2):<br/>        c1, c2, p1, p2, c1 = return_individual_data(winner='c1')<br/>        data['character1'].append(c1)<br/>        data['character2'].append(c2)<br/>        data['power_level1'].append(p1)<br/>        data['power_level2'].append(p2)<br/>        data['win'].append(c1)<br/>    <br/>    # second half<br/>    for i in range(0, size//2):<br/>        c1, c2, p1, p2, c2 = return_individual_data(winner='c2')<br/>        data['character1'].append(c1)<br/>        data['character2'].append(c2)<br/>        data['power_level1'].append(p1)<br/>        data['power_level2'].append(p2)<br/>        data['win'].append(c2)<br/>    <br/>    data_df = pd.DataFrame(data=data, columns=['character1', 'character2', 'power_level1', 'power_level2', 'win'])<br/>    data_df = shuffle(data_df)<br/>    <br/>    toadd = split_powerlevel(data_df)<br/>    for k,v in enumerate(toadd):<br/>        data_df[v] = toadd[v]<br/>    <br/>    features, labels = data_df.drop(columns=['win']).values, data_df.win.values<br/>    <br/>    x_train, x_test, y_train, y_test = train_test_split(features, labels, test_size=0.2, random_state=42)<br/>    x_train, x_val, y_train, y_val = train_test_split(x_train, y_train, test_size=0.25, random_state=42)<br/>    <br/>    <br/>    print ("Generated data of size:{}".format(size))</span><span id="754b" class="nt lt iq np b gy ny nv l nw nx">return features, labels,x_train, x_test, y_train, y_test,x_val, y_val, data_df</span></pre><blockquote class="nz oa ob"><p id="268e" class="kf kg my kh b ki kj jr kk kl km ju kn oc kp kq kr od kt ku kv oe kx ky kz la ij bi translated">我们计算获胜的次数来检查班级的不平衡。</p></blockquote><pre class="ld le lf lg gt no np nq nr aw ns bi"><span id="4035" class="nt lt iq np b gy nu nv l nw nx">def count_wins(df=None):<br/>    """</span><span id="c1c1" class="nt lt iq np b gy ny nv l nw nx">        Count number of character wins. # to check for class imbalance<br/>        Returns: <br/>            c1_wins: Character 1 wins<br/>            c2_wins: Character 2 wins<br/>    """<br/>    for i in range(0, len(df)):<br/>        if df.loc[i].character1 == df.loc[i].win:<br/>            c1_wins.append(i)<br/>        else:<br/>            c2_wins.append(i)<br/>    print("Character 1 wins: {}, Character 2 wins: {}".format(len(c1_wins), len(c2_wins)))       <br/>    <br/>features, labels,x_train, x_test, y_train, y_test,x_val, y_val,data = create_data(df, size=5000)</span></pre><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi ps"><img src="../Images/01c5128b9e6683f43be2170a92c3f37f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sUi5L6-c_LeP1N_TvLqNJQ.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">我们的最终数据集(其中大小= 5000)</p></figure><h1 id="51b2" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">模型创建</h1><p id="59e8" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi mp translated"><span class="l mq mr ms bm mt mu mv mw mx di"> O </span> ur 神经网络是一个简单的前馈网络，具有一组隐藏层，随后是一组丢弃层(减少过拟合的最佳方式，因为该数据集很容易过拟合)，最后是一个具有 90(唯一字符总数)个单元的 softmax 层。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi pt"><img src="../Images/9a90d2590b316e5d4623a2e39c0b4679.png" data-original-src="https://miro.medium.com/v2/resize:fit:1044/format:webp/1*6XVouCqvNWZpgQXGCMBz1A.png"/></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">我们的模型架构</p></figure><blockquote class="og"><p id="777f" class="oh oi iq bd oj ok ol om on oo op la dk translated">我们的数据已经在 create_data()方法中被分割成 x_train、x_test、y_train、y_test、x_val、y_val。</p></blockquote><p id="dffb" class="pw-post-body-paragraph kf kg iq kh b ki pu jr kk kl pv ju kn ko pw kq kr ks px ku kv kw py ky kz la ij bi translated">我们用 Adam 优化器训练模型(学习率= 3e-4，损失= 300 个历元的交叉熵)。</p><blockquote class="nz oa ob"><p id="10fe" class="kf kg my kh b ki kj jr kk kl km ju kn oc kp kq kr od kt ku kv oe kx ky kz la ij bi translated">300 是一个实验数字，因为在 300 个时期之后，模型倾向于过度拟合。</p></blockquote><pre class="ld le lf lg gt no np nq nr aw ns bi"><span id="a1a1" class="nt lt iq np b gy nu nv l nw nx">model.compile(optimizer=tf.keras.optimizers.Adam(learning_rate=3e-4), loss=tf.keras.losses.sparse_categorical_crossentropy, metrics=['acc'])</span><span id="9803" class="nt lt iq np b gy ny nv l nw nx">history = model.fit(x_train, y_train, epochs=300, validation_data=(x_val, y_val), callbacks=[tensorboard])</span></pre><h1 id="3436" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结果和预测</h1><p id="1532" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi mp translated"><span class="l mq mr ms bm mt mu mv mw mx di">答</span>经过大约 300 个历元的训练，我们能够在验证数据上达到<strong class="kh ir"> 2.6692 </strong>的损失和<strong class="kh ir"> 2.6995 </strong>的验证损失以及<strong class="kh ir"> 26% </strong>的准确率。这个结果是用<strong class="kh ir"> 5000 行假生成的数据得到的。</strong></p><blockquote class="og"><p id="48ea" class="oh oi iq bd oj ok ow ox oy oz pa la dk translated">低精度模型是比过度拟合模型更好的选择。</p></blockquote><p id="0e4f" class="pw-post-body-paragraph kf kg iq kh b ki pu jr kk kl pv ju kn ko pw kq kr ks px ku kv kw py ky kz la ij bi translated">如果我们增加我们的数据，然后训练我们的模型，我们肯定会得到更好的结果。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi pz"><img src="../Images/c7929a65f111bbcaf6eadece49a72ae6.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/format:webp/1*7H8mxWgxRbTAhQVPqdSGZg.png"/></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">我们模型的损失和价值损失</p></figure><p id="00d9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了测试我们的模型，我们进行了一次评估，得到了 26%的准确率。为了清楚起见，我们开发了一个测试函数，为 90 个字符中的每一个生成概率。</p><pre class="ld le lf lg gt no np nq nr aw ns bi"><span id="4725" class="nt lt iq np b gy nu nv l nw nx">def test():<br/>    for i, j in enumerate(model.predict(x_test[0].reshape(1,-1))[0]):<br/>        print ("{} -&gt; {}".format(mapping_character[i], j))</span><span id="26b7" class="nt lt iq np b gy ny nv l nw nx">test()</span></pre><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi qa"><img src="../Images/1c5c94a083aa143b22c20ddcc88aaa4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/1*HTiQKidcNMwSDLL4PtRRCQ.png"/></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">预言</p></figure><h1 id="0fe4" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="a634" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi mp translated"><span class="l mq mr ms bm mt mu mv mw mx di">总而言之，我们开发了一个网络，能够预测 90 个角色中每个角色的获胜概率。我们对来自 Kaggle 的初始数据集进行预处理，得到一个新的能够进行多类分类的数据集。我们的模型没有达到很高的精度，但也没有过度拟合。<strong class="kh ir">在尝试了书中的每一种技术来应对过度拟合后，我们得出了生成更多数据来训练我们的模型的结论。</strong></span></p><p id="07a7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们能够开发 OmniNet，这使得 Azmuth，创造者，授予我们开发 Omnitrix 软件的终身合同。</p><p id="8aec" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="my"> Github 链接:</em><a class="ae lb" href="https://github.com/aaditkapoor/OmniNet" rel="noopener ugc nofollow" target="_blank"><em class="my">https://github.com/aaditkapoor/OmniNet</em>T21】</a></p></div></div>    
</body>
</html>