<html>
<head>
<title>Association Rule Mining in Python: Complete Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的关联规则挖掘:完全指南</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/market-basket-analysis-using-association-rule-mining-in-python-pyshark-412aa6b4d0ea?source=collection_archive---------38-----------------------#2020-03-24">https://towardsdatascience.com/market-basket-analysis-using-association-rule-mining-in-python-pyshark-412aa6b4d0ea?source=collection_archive---------38-----------------------#2020-03-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a370" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在本文中，我们将使用Python中的各种关联规则挖掘算法来探索购物篮分析。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1da001b461ca446f8bb3a407cd1844fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*baa5EEsT49ciN34X-HqCRg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@mrsmaria?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">玛利亚·林·金</a>在<a class="ae ky" href="https://unsplash.com/s/photos/grocery?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="19ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">目录:</strong></p><ul class=""><li id="b8af" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">介绍</li><li id="8d42" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">关联规则挖掘(概述)</li><li id="255f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">概念</li><li id="a4d4" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">Apriori算法</li><li id="34e1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">喝彩</li><li id="ace6" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">F-P增长</li><li id="62cd" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">算法比较</li><li id="9caa" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">Python中的关联规则挖掘(示例)</li><li id="e16f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">结论</li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="0447" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">介绍</h1><p id="c6f3" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">随着电子商务网站的快速增长和跨行业(尤其是零售业)转向数据答案的普遍趋势，每个组织都在努力寻找更多机会，以获得最佳产品组合来进行折扣和促销。</p><p id="28f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对这些决策的回报是期望销售的增长和库存水平的降低。</p><p id="a58c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对“一起买了什么”进行分析通常会产生非常有趣的结果。</p><p id="a15c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">零售业的一个经典故事是关于一家沃尔玛商店，其中一家商店的同事开始将商品捆绑在一起，以便更容易找到。例如，他们把面包和果酱放在一起，牛奶和鸡蛋，等等。</p><p id="2378" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些是我们在商店购物时马上想到的例子。</p><p id="96dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">他们没想到的是，在分析了每个顾客的收据后，他们发现了一个规律，美国爸爸在一张收据上有尿布和啤酒(尤其是在周五)。</p><p id="d6f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">市场购物篮分析(或相似性分析)主要是一种数据挖掘过程，有助于识别用户组执行的某些事件/活动的同现。在我们的例子中，我们将通过使用Python中的关联规则挖掘来分析个人的收据，从而关注个人在零售店中的购买行为。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="cb69" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">关联规则挖掘(概述)</h1><p id="e5ff" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">关联规则学习是一种基于规则的方法，用于发现大型数据集中变量之间的关系。对于零售POS(销售点)交易分析，我们的变量将是零售产品。它本质上发现了具有某种“强”水平的强关联(规则)，这由几个参数表示。</p><p id="0dfd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们将转向一些数学，以技术的方式解释关联规则。</p><p id="6130" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是Agrawal、Imieliński、Swami在他们的<a class="ae ky" href="https://dl.acm.org/doi/10.1145/170035.170072" rel="noopener ugc nofollow" target="_blank">论文</a>(以此为基础)中描述关联规则学习的总结，以及我们的一些补充:</p><ol class=""><li id="515b" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nn mb mc md bi translated">设<strong class="lb iu"> <em class="no"> I </em> </strong> <em class="no"> = i_1，i_2，…，i_n </em>为一组<em class="no"> n </em>的商品(在一个零售例子中:让我们把它想象成商店中所有可用产品的列表:香蕉、牛奶等等)。</li><li id="63df" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nn mb mc md bi translated">设<strong class="lb iu"> <em class="no"> D </em> </strong> <em class="no"> = t_1，t_2，…，t_m) </em>为一组<em class="no"> m </em>的交易(在一个零售的例子中:姑且认为是客户收据)。</li></ol><p id="9e73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"><em class="no"/></strong>中的每笔交易<em class="no"> t_m </em>都有一个唯一的ID(在一个零售例子中:每张收据都有一个唯一的编号)。</p><p id="a7fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，每笔交易<em class="no"> t_m </em>由集合<strong class="lb iu"> <em class="no"> I </em> </strong>中的商品子集组成(在零售示例中:每张收据包含来自商店的产品)。</p><p id="737a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个<strong class="lb iu"> <em class="no">规则</em> </strong>被定义为形式<strong class="lb iu"><em class="no">y</em></strong>-&gt;<strong class="lb iu"><em class="no">x</em></strong>其中<strong class="lb iu"><em class="no">x</em></strong>⊆<strong class="lb iu"><em class="no">I</em></strong>和<strong class="lb iu"><em class="no">y</em></strong>⊆<strong class="lb iu"><em class="no">I</em></strong>(相当于</p><p id="adec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些数学术语的含义如下:</p><ul class=""><li id="9738" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><strong class="lb iu"><em class="no">x</em></strong>⊆<strong class="lb iu"><em class="no">I</em></strong>是指<strong class="lb iu"> <em class="no"> X </em> </strong>是<strong class="lb iu"> <em class="no"> I </em> </strong>的子集(在一个零售例子中:<strong class="lb iu"> <em class="no"> X </em> </strong>可以是商店中所有可用产品列表中的1个或多个产品)。</li><li id="e35a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu"><em class="no">y</em></strong>⊆<strong class="lb iu"><em class="no">I</em></strong>的意思是<strong class="lb iu"> <em class="no"> Y </em> </strong>也是<strong class="lb iu"> <em class="no"> I </em> </strong>的子集(解释同上)。</li><li id="2938" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu"><em class="no">X</em></strong>∩<strong class="lb iu"><em class="no">Y</em></strong>= 0表示<strong class="lb iu"> <em class="no"> X </em> </strong>和<strong class="lb iu"> <em class="no"> Y </em> </strong>没有公共元素(两个项集不能有相同的乘积)。</li></ul><p id="33cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了便于理解，我们来看下面的例子:</p><ol class=""><li id="bfe7" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nn mb mc md bi translated">你去购物，你的收据上有以下商品:{面包、牛奶、鸡蛋、苹果}。</li><li id="47f3" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nn mb mc md bi translated">我们来创建一个任意项集<strong class="lb iu"><em class="no">X</em></strong>:{面包，鸡蛋}。</li><li id="cb17" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nn mb mc md bi translated">让我们创建一个任意项集<strong class="lb iu"><em class="no">Y</em></strong>:{ apple }。</li></ol><p id="6ac4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回头看看<em class="no">规则</em>的定义，你会发现你已经满足了所有的假设。项目集<strong class="lb iu"> <em class="no"> X </em> </strong>中的每个项目都是收据上产品列表中的一个产品。项目集<strong class="lb iu"> <em class="no"> Y </em> </strong>中的每个项目都是收据上产品列表中的一个产品。<strong class="lb iu"> <em class="no"> X </em> </strong>和<strong class="lb iu"> <em class="no"> Y </em> </strong>中的产品不重复(在您的收据上的产品列表中是唯一的)。</p><p id="b0ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用这些项目集，<em class="no">规则</em>的一个例子是:<strong class="lb iu">{面包，鸡蛋}→{苹果} </strong>，这意味着买面包和鸡蛋的人可能会买苹果。</p><p id="7f7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止，我们只处理了作者选择的两个项目集。然而，我们的收据有4个项目，所以我们可以创建更多的项目集，从而创建更多的规则。例如，另一个<em class="no">规则</em>可能是<strong class="lb iu"> {milk}→{eggs} </strong>或<strong class="lb iu"> {bread，milk}→{eggs} </strong>。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="c17b" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">概念</h1><p id="9e4b" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">正如您在上一部分中看到的，我们能够提出几个任意的<strong class="lb iu"> <em class="no">规则</em> </strong>，这些规则甚至可以从一个非常小的包含几个项目的交易样本中导出。</p><p id="be2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在要做的是确定几个有用的度量，允许我们评估可以作为潜在关联规则提出的<em class="no">规则</em>的“强度”。我们基本上会努力寻找最有意义和最重要的规则。</p><p id="ffcd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们从杂货店创建一个任意的交易数据库:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/70e99058a4d3b8c55d240743832d8938.png" data-original-src="https://miro.medium.com/v2/resize:fit:978/format:webp/1*aWV1E99yvpTbQyLa7NPDeQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="40e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的数据库中，每一行都是来自客户的唯一收据。其他列中的值为布尔值(1表示真，0表示假)。这张表格显示了我们在什么收据上买了什么。</p><p id="8a0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们都准备好做一些计算了。</p><p id="ee8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设两个单项集<strong class="lb iu"> <em class="no"> X </em> </strong>和<strong class="lb iu"> <em class="no"> Y </em> </strong>，其中<strong class="lb iu"> <em class="no"> X </em> </strong>包含牛奶(<strong class="lb iu"> <em class="no"> X </em> </strong> : {Milk})和<strong class="lb iu"> <em class="no"> Y </em> </strong>包含鸡蛋(<strong class="lb iu"> <em class="no"> Y </em> </strong> : {Eggs})。</p><p id="60f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们要探讨的是<strong class="lb iu"><em class="no">X</em></strong>-&gt;<strong class="lb iu"><em class="no">Y</em></strong>，即“购买牛奶的顾客也购买鸡蛋的<em class="no">规则</em>有多强？”</p><p id="1311" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要熟悉购物篮分析中最常用的一组概念。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h2 id="2653" class="nq mr it bd ms nr ns dn mw nt nu dp na li nv nw nc lm nx ny ne lq nz oa ng ob bi translated">支持</h2><p id="0ca8" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">一个项集<strong class="lb iu"> <em class="no"> X </em> </strong>的支持度定义为数据库中包含<strong class="lb iu"> <em class="no"> X </em> </strong>的事务的比例。</p><p id="8643" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理论:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/9d95b90c460fb51b36635656d9424d01.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*31SEWZp8_mJA0vZ1VNEZag.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="27a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么我们来统计一下看到<strong class="lb iu"> <em class="no"> X </em> </strong>(奶)出现的交易数量。这是3个事务(id:001，002，003)。交易总数为4。</p><p id="6913" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们的计算如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/ffffc12ae35f6e6ec5e62eff5a731041.png" data-original-src="https://miro.medium.com/v2/resize:fit:424/format:webp/1*H5ZpkeXzMkxg2oHqyX8eMw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h2 id="1722" class="nq mr it bd ms nr ns dn mw nt nu dp na li nv nw nc lm nx ny ne lq nz oa ng ob bi translated">信心</h2><p id="54e9" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">置信度是对<em class="no">规则</em>为真的指示的显著性的度量。简单来说，就是计算项集<strong class="lb iu"> <em class="no"> Y </em> </strong>被项集<strong class="lb iu"> <em class="no"> X </em> </strong>购买的可能性。</p><p id="76f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理论:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/28c4fb6513f2fc30736c3dba7651d0ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:536/format:webp/1*JQUfZu6EPNQj7PgQQdKfAg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="7fa9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们需要计算项目集<strong class="lb iu"> <em class="no"> X </em> </strong>和<strong class="lb iu"> <em class="no"> Y </em> </strong>的联合支持度。这是牛奶和鸡蛋同时出现的交易数(交易的<a class="ae ky" href="https://pyshark.com/python-set-operations/#python-set-intersection" rel="noopener ugc nofollow" target="_blank">交集</a>)。</p><p id="5d4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是两个事务(id:001，002)。交易总数为4。</p><p id="7a60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们的计算如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/bae16cb0312ad42bc1f8d6ccf0d87575.png" data-original-src="https://miro.medium.com/v2/resize:fit:490/format:webp/1*auPM85MVFPx9rhnaDW_vkg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="8f87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上一部分我们知道supp(<strong class="lb iu"><em class="no">X</em></strong>)= 0.75。</p><p id="fda5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用上面的数字，我们得到:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/dd879821e6044a432b6edc24061a8225.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/format:webp/1*-js4giqyv2TX12P2fK-7Iw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="b595" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这表明，每次顾客购买牛奶，有66%的机会他们也会购买鸡蛋。</p><p id="8161" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也可以称为<strong class="lb iu"> <em class="no"> Y </em> </strong>对<strong class="lb iu"> <em class="no"> X </em> </strong>的条件概率:P(<strong class="lb iu"><em class="no">Y</em></strong>|<strong class="lb iu"><em class="no">X</em></strong>)= 0.66。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h2 id="d88b" class="nq mr it bd ms nr ns dn mw nt nu dp na li nv nw nc lm nx ny ne lq nz oa ng ob bi translated">电梯</h2><p id="f1a9" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">如果<strong class="lb iu"> <em class="no"> X </em> </strong>和<strong class="lb iu"> <em class="no"> Y </em> </strong>是独立的，则提升是观察到的支持与预期支持的比率。</p><p id="0995" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">换句话说，它告诉我们<strong class="lb iu"> <em class="no">规则</em> </strong>在计算结果时，同时考虑到项目集<strong class="lb iu"> <em class="no"> Y </em> </strong>的流行度有多好。</p><p id="d7f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理论:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/4d5bcd3cc31267b43242d7c4ea37a633.png" data-original-src="https://miro.medium.com/v2/resize:fit:602/format:webp/1*W8OoH6jQDbfcCN0r1OeQPw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><ul class=""><li id="1874" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">如果lift(<strong class="lb iu"><em class="no">X</em></strong>-&gt;<strong class="lb iu"><em class="no">Y</em></strong>)= 1，那么这就意味着项目集<strong class="lb iu"> <em class="no"> X </em> </strong>和项目集<strong class="lb iu"><em class="no"/></strong>的出现概率是相互独立的，也就是说<strong class="lb iu"> <em class="no">规则</em> </strong>不显示任何</li><li id="5787" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">如果lift(<strong class="lb iu"><em class="no">X</em></strong>-&gt;<strong class="lb iu"><em class="no">Y</em></strong>)&gt;为1，则意味着项目集<strong class="lb iu"> <em class="no"> X </em> </strong>和<strong class="lb iu"> <em class="no"> Y </em> </strong>的出现概率是正相关的。它还会告诉我们依赖程度的大小。提升值越高，依赖性越高，这也可以称为项目集是互补的。</li><li id="7817" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">如果lift(<strong class="lb iu"><em class="no">X</em></strong>-&gt;<strong class="lb iu"><em class="no">Y</em></strong>)&lt;为1，那么这就意味着项目集<strong class="lb iu"> <em class="no"> X </em> </strong>和<strong class="lb iu"> <em class="no"> Y </em> </strong>出现的概率是相互负相关的。提升值越低，依赖性越低，这也可以称为项目集相互替代。</li></ul><p id="74ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止，我们已经计算了我们需要的大部分值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/c3b52898ddebbd5395102dda7e7f3c55.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/format:webp/1*Ugm7a9R9dVN3KhJIz4f3mQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="4c4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/46311f7d4f07cc1f06c6691095b868c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:434/format:webp/1*LIkSS3xk-zuvun7FsHe7Ng.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="9f95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们找到第三块:supp( <strong class="lb iu"> <em class="no"> Y </em> </strong>)</p><p id="4809" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要鸡蛋出现的交易数量。这是3个事务(id:001，002，004)。交易总数为4。</p><p id="0d24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们的计算如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/fd3150559a152c73d773164295578790.png" data-original-src="https://miro.medium.com/v2/resize:fit:424/format:webp/1*G8hsflutVKmcbgMOXSaCjA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="d333" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将所有这些代入一个公式，我们得到:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/bac4bed9405687f7ab87ed7ce42db687.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*7bKru-ZwbTLuX-riNgZW1g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="5d9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们发现升力有一个有趣的值。当我们看表时，似乎很明显牛奶和鸡蛋经常一起买。我们还知道，从本质上讲，这些产品通常会一起购买，因为我们知道有多种菜肴同时需要这两种产品。</p><p id="a068" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:即使从统计学上来说，它们不是互补的，我们用我们的判断来评估关联<strong class="lb iu"> <em class="no">规则</em> </strong>。这是我们需要强调领域知识的时刻。公式不知道我们知道什么，我们可以获得很多信息，公式做的一切都基于数字。计算这些值是对你决策的补充，而不是替代。评估关联规则时，由您来设置最小阈值。在Python中执行关联规则挖掘之前，理解这一部分很重要。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="87ff" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">Apriori算法(举例说明)</h1><p id="7938" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">Apriori算法(最初由Agarwal提出)是购物篮分析中最常用的技术之一。它用于分析事务数据库中的频繁项集，然后用于生成产品之间的关联规则。</p><p id="c36d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们来举个例子。回想一下我们在“概念”课程中介绍的数据集:</p><p id="3921" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是Apriori算法如何探索牛奶关联规则的示例树:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/7d050a869ec4d2512210b7ebc7b6311a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WaE16FRcNZ9agx3s"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="73d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本例中，算法首先查看级别1(牛奶)并找到其频率，然后移动到下一个深度层并查看[牛奶、鸡蛋]、[牛奶、苹果]和[牛奶、面包]的频率。在分析了第二个深度级别后，它会移动到下一个深度级别。这将一直持续到最后一个深度级别，这意味着一旦不再有新的项集，算法将停止计算。</p><p id="1499" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为说明，考虑上面的图表，但是现在我们将标记算法采取的步骤，而不是项目:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/b0b7ebe5fb2e5f8e7f9f49c8bc4e10f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HV3m4reHD3kmKVx4"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="c1ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上图显示了算法在执行搜索时所采取的步骤(1:16)。</p><p id="c6b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，它计算对所有可能的项集组合的支持。请记住，由我们来设置支持的最小参数。如果我们将它设置为0.01，我们显然会看到比设置为0.4更多的可能规则。</p><p id="4f3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果输出将是一个关联规则列表，这些规则是在满足我们设置的参数值时发现的。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="55de" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">ECLAT(举例说明)</h1><p id="f7a3" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">ECLAT算法是另一种流行的购物篮分析工具。它代表等价类聚类和自底向上的格遍历。它被称为“更有效”的Apriori算法。</p><p id="ba68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一种深度优先搜索(DFS)方法，通过数据集结构进行垂直搜索。该算法从树根开始搜索，然后探索下一个深度级别节点，并继续向下搜索，直到到达第一个终端节点。然后，它后退一步(到n-1级),探索其他节点，并向下到达终端节点。</p><p id="f7a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们把它作为一棵树来探索时，它更有意义。回想一下我们在“Apriori算法”部分中使用的数据集(在本课中进一步添加以供参考)。下面是DFS将如何分析它:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/fd12413f88ec1e537116c2afef77b31a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kcfuqZ03Ytt_Mu5j"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="23fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">逻辑的总结是:</p><ul class=""><li id="9ab4" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">找到根(方框1)。</li><li id="53c0" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">探索下一个深度级别节点，直到到达一个终端节点(框2:4)。</li><li id="6dca" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">一旦到达终端节点(框4)，后退一步到先前的深度级别，并查看是否有其他节点可供探索(框3级别没有)。</li><li id="78ce" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">再后退一步(回到方框2的层次)，现在有另一条“路径”可用(方框5)。</li><li id="8ac3" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">向下走，直到到达终点(方框6)。</li><li id="520e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">不断重复上述步骤，直到不再有节点需要探索。</li></ul><p id="0f3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们将其与广度优先搜索(BFS)进行比较，计算速度将取决于树的宽度和深度(顶点排序的不同属性)。</p><p id="9f65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到ECLAT算法的技术部分，其流程如下:</p><ul class=""><li id="8694" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">在第一次运行中，ECLAT查找所有单个项目集(k=1)的事务id。</li><li id="17d1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">在第二次运行时，ECLAT查找所有两项项目集(k=2)的事务id。</li></ul><p id="d67b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们再举个例子。这是我们的数据集:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/70e99058a4d3b8c55d240743832d8938.png" data-original-src="https://miro.medium.com/v2/resize:fit:978/format:webp/1*aWV1E99yvpTbQyLa7NPDeQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="f8fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面展示了ECLAT算法将对该数据集执行的所有运行:</p><ul class=""><li id="0a5e" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">对于k=1:</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi om"><img src="../Images/9976aa5503ad73815667de8fac4645b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:520/format:webp/1*hQsOmc4ERr4C6I8lmgS9ow.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><ul class=""><li id="4426" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">对于<em class="no"> k </em> =2:</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/758891d20efbd30d8b01a09538a17072.png" data-original-src="https://miro.medium.com/v2/resize:fit:644/format:webp/1*c_cnMTOx9lHCo7QAUZapBg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><ul class=""><li id="d0ae" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">对于<em class="no"> k </em> =3:</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/4ad6aa71d0eaaee3e1fdacc1140168ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*L8cPL9ICvEah5xEuMOghPQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><ul class=""><li id="a2d1" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">对于<em class="no"> k </em> =4: <br/>一旦我们到达四项项目集，我们可以从我们的数据中看到没有任何一项。在这种情况下，ECLAT算法将在<em class="no"> k </em> =3时停止搜索。</li></ul><p id="a873" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要注意一些事情:</p><ul class=""><li id="68fd" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">如果两个项目没有一起出现在任何交易上(比如{牛奶，苹果})，它就不会出现在矩阵中。</li><li id="ff8e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">该矩阵不包含重复项({牛奶、鸡蛋}与{鸡蛋、牛奶}相同)。</li></ul><p id="4805" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">结果:</strong></p><p id="7e13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，假设我们已经为ECLAT搜索预设了最小支持计数要求等于2(支持计数=2)。<br/>这意味着一个规则要符合输出条件，它必须至少有两个出现这些项目的交易:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/703bee09fbf559a34fc09b94795a2d15.png" data-original-src="https://miro.medium.com/v2/resize:fit:358/format:webp/1*nzKoAviUSglLbVPYDA6aUA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="544c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:支持计数和支持是两个不同的概念。支持计数(σ)是项目发生的事务计数。Support是项目出现的事务占事务总数的分数(支持计数除以事务总数)。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="13b2" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">F-P增长(举例说明)</h1><p id="ffe3" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">F-P增长(或频繁模式增长)算法是购物篮分析中另一种流行的技术(首先由韩介绍)。它产生与Apriori算法相同的结果，但由于数学上不同的技术(分治)，计算速度更快。</p><ol class=""><li id="4678" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nn mb mc md bi translated">首先，它计算事务数据集中每个项目的出现次数。</li><li id="f56a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nn mb mc md bi translated">然后，它使用事务创建一个搜索树结构。</li></ol><p id="2887" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">F-P增长遵循两步数据预处理方法:</p><p id="accc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与Apriori算法不同，F-P Growth在将事务插入到树中之前，根据事务出现的频率从大到小对事务进行排序。这是它比Apriori算法具有显著计算优势的地方，因为它在早期就进行频率排序。不符合最低支持(频率)要求(我们可以设置)的项目将从树中丢弃。</p><p id="b4f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个优点是重复的频繁项集将具有相同的路径(不像Apriori算法，每个项集具有唯一的路径)。</p><p id="3372" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个例子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/b52bb926970415757c3fcb93358533b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mZPL_KDWWIrsROaO"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="ed28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">左手边是Apriori算法，它通过以下步骤查看两个单独的序列:</p><ol class=""><li id="2194" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nn mb mc md bi translated">牛奶-&gt;鸡蛋-&gt;苹果</li><li id="b97e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nn mb mc md bi translated">牛奶-&gt;鸡蛋-&gt;面包</li></ol><p id="97bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">右手边是F-P生长算法，它查看两个序列，其中公共部分[牛奶、鸡蛋]被压缩:</p><ol class=""><li id="4381" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nn mb mc md bi translated">【牛奶、鸡蛋】-&gt;苹果</li><li id="8e53" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nn mb mc md bi translated">【牛奶、鸡蛋】-&gt;面包</li></ol><p id="0cf7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这允许对树的根进行更高的压缩和更少的计算步骤(在这种情况下是2步)，这意味着计算比Apriori算法快得多(在这种情况下是4步)。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="2356" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">算法比较</h1><p id="dc7d" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">本节旨在通过比较和对比的方式，向您简要介绍本课程中学习的三种算法。</p><p id="03b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请参考下表:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/dbef206d23ec3a07f0ee3195bc5bf315.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/1*TdoMT2Vy1ZVjR1M0hqYCCQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="0fd9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上表表明，主要的速度优势是由于不同的计算技术和数据格式。因为F-P增长只遍历数据库两次，所以在大量项目集上要快得多。在我们使用的例子中，整个数据库只包含4个唯一的条目，计算速度的差异很小，不明显。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="e9a3" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">Python中的关联规则挖掘(示例)</h1><p id="9383" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在这一节中，我们将创建一些Python中关联规则挖掘的例子。</p><p id="6132" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们回忆一下我们在本课程的第一节课中创建的数据集:</p><p id="40dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将把它作为模型的输入。</p><p id="437a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了继续学习本教程，我们需要两个Python库:pandas和mlxtend。</p><p id="edc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您没有安装它们，请打开“命令提示符”(在Windows上)并使用以下代码安装它们:</p><pre class="kj kk kl km gt or os ot ou aw ov bi"><span id="7032" class="nq mr it os b gy ow ox l oy oz">pip install pandas<br/>pip install mlxtend</span></pre><p id="9d53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦下载并安装了库，我们就可以继续Python代码实现了。</p><h2 id="8b27" class="nq mr it bd ms nr ns dn mw nt nu dp na li nv nw nc lm nx ny ne lq nz oa ng ob bi translated">步骤1:创建包含所需数据的列表</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pa pb l"/></div></figure><p id="12dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码创建了一个我们将使用的事务列表。</p><p id="5308" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看结果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pa pb l"/></div></figure><pre class="kj kk kl km gt or os ot ou aw ov bi"><span id="543b" class="nq mr it os b gy ow ox l oy oz">[['Milk', 'Eggs', 'Bread'], ['Milk', 'Eggs'], ['Milk', 'Bread'], ['Eggs', 'Apple']]</span></pre><h2 id="a7d2" class="nq mr it bd ms nr ns dn mw nt nu dp na li nv nw nc lm nx ny ne lq nz oa ng ob bi translated">步骤2:用布尔值将列表转换成数据帧</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pa pb l"/></div></figure><p id="5869" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们首先导入所需的库。然后我们将TransactionEncoder()函数保存为局部变量<strong class="lb iu"> te </strong>。<br/>下一步是从<strong class="lb iu">数据集</strong>列表中创建一个具有真/假值的数组(<strong class="lb iu"> te_array </strong>)。<br/>然后，我们使用条目作为列名，将这个数组转换成dataframe ( <strong class="lb iu"> df </strong>)。</p><p id="5252" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看结果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pa pb l"/></div></figure><pre class="kj kk kl km gt or os ot ou aw ov bi"><span id="976b" class="nq mr it os b gy ow ox l oy oz">Apple  Bread   Eggs   Milk<br/>0  False   True   True   True<br/>1  False  False   True   True<br/>2  False   True  False   True<br/>3   True  False   True  False</span></pre><p id="817b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这向我们显示了在所有事务处理中，哪些项目会/不会出现在特定的收据上。</p><h2 id="3b07" class="nq mr it bd ms nr ns dn mw nt nu dp na li nv nw nc lm nx ny ne lq nz oa ng ob bi translated">步骤3.1:使用Apriori算法找到频繁出现的项目集</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pa pb l"/></div></figure><p id="9380" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们从库中导入Apriori算法函数。<br/>然后，我们将该算法应用于我们的数据，以提取具有最小支持值0.01(该参数可以改变)的项目集。</p><p id="675a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看结果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pa pb l"/></div></figure><pre class="kj kk kl km gt or os ot ou aw ov bi"><span id="9c49" class="nq mr it os b gy ow ox l oy oz">support             itemsets<br/>0     0.25              (Apple)<br/>1     0.50              (Bread)<br/>2     0.75               (Eggs)<br/>3     0.75               (Milk)<br/>4     0.25        (Eggs, Apple)<br/>5     0.25        (Eggs, Bread)<br/>6     0.50        (Bread, Milk)<br/>7     0.50         (Eggs, Milk)<br/>8     0.25  (Eggs, Bread, Milk)</span></pre><h2 id="72b6" class="nq mr it bd ms nr ns dn mw nt nu dp na li nv nw nc lm nx ny ne lq nz oa ng ob bi translated">步骤3.2:使用F-P增长找到频繁出现的项目集</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pa pb l"/></div></figure><p id="75b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们从库中导入F-P增长算法函数。<br/>然后，我们将该算法应用于我们的数据，以提取最小支持值为0.01的项目集(该参数可以根据具体情况进行调整)。</p><p id="0d8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看结果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pa pb l"/></div></figure><pre class="kj kk kl km gt or os ot ou aw ov bi"><span id="1de1" class="nq mr it os b gy ow ox l oy oz">support             itemsets<br/>0     0.75               (Milk)<br/>1     0.75               (Eggs)<br/>2     0.50              (Bread)<br/>3     0.25              (Apple)<br/>4     0.50         (Eggs, Milk)<br/>5     0.50        (Bread, Milk)<br/>6     0.25        (Eggs, Bread)<br/>7     0.25  (Eggs, Bread, Milk)<br/>8     0.25        (Eggs, Apple)</span></pre><p id="0a86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:您所观察到的是，无论您使用何种技术，您都会得到相同的项目集和支持值。唯一的区别是它们出现的顺序。你应该注意到，F-P增长的产出是以降序出现的，因此证明了我们在理论部分提到的这个算法。</p><h2 id="6cf9" class="nq mr it bd ms nr ns dn mw nt nu dp na li nv nw nc lm nx ny ne lq nz oa ng ob bi translated">第四步:挖掘关联规则</h2><p id="de2f" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在最后一步中，我们将找到在第三步中计算的频繁项集的关联规则。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pa pb l"/></div></figure><p id="e498" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们从页面导入所需的函数，使用一些参数集来确定给定数据集的关联规则。然后，我们将它应用于我们在步骤3中创建的两个频繁项目数据集。</p><p id="b934" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:“metric”和“min_threshold”参数可以根据具体情况进行调整，这取决于业务问题的需求。</p><p id="08d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看这两套规则:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pa pb l"/></div></figure><pre class="kj kk kl km gt or os ot ou aw ov bi"><span id="0887" class="nq mr it os b gy ow ox l oy oz">antecedents consequents  antecedent support  consequent support  support  confidence      lift  leverage  conviction<br/>0        (Apple)      (Eggs)                0.25                0.75     0.25         1.0  1.333333    0.0625         inf<br/>1        (Bread)      (Milk)                0.50                0.75     0.50         1.0  1.333333    0.1250         inf<br/>2  (Eggs, Bread)      (Milk)                0.25                0.75     0.25         1.0  1.333333    0.0625         inf</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pa pb l"/></div></figure><pre class="kj kk kl km gt or os ot ou aw ov bi"><span id="d5e7" class="nq mr it os b gy ow ox l oy oz">antecedents consequents  antecedent support  consequent support  support  confidence      lift  leverage  conviction<br/>0        (Bread)      (Milk)                0.50                0.75     0.50         1.0  1.333333    0.1250         inf<br/>1  (Eggs, Bread)      (Milk)                0.25                0.75     0.25         1.0  1.333333    0.0625         inf<br/>2        (Apple)      (Eggs)                0.25                0.75     0.25         1.0  1.333333    0.0625         inf</span></pre><p id="870a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上面的两个例子中，我们看到两种算法都找到了系数相同的关联规则，只是顺序不同。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="62e7" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">结论</h1><p id="6306" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">本文是一个用Python实现用于购物篮分析的关联规则挖掘的基本示例的演练。我们关注最常见算法的理论和应用。</p><p id="55d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事情远不止如此:</p><ul class=""><li id="3909" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">更多算法</li><li id="c94e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">更多参数调整</li><li id="037a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">更多的数据复杂性</li></ul><p id="fa85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文的目的是展示这种数据挖掘技术在Python中应用于购物篮分析的可能性，这肯定可以进一步探索。</p><p id="f4cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你有任何问题或对编辑有任何建议，请随时在下面留下评论，并查看更多我的<a class="ae ky" href="https://pyshark.com/category/python-programming/" rel="noopener ugc nofollow" target="_blank">统计</a>文章。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><p id="f737" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">推荐人:</strong></p><ul class=""><li id="0cfc" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">阿格拉瓦尔河；t .伊梅利斯基；Swami，A. (1993年)。“挖掘大型数据库中项目集之间的关联规则”。<em class="no">1993年ACM SIGMOD数据管理国际会议记录—SIGMOD’93</em>。第207页。<a class="ae ky" href="https://en.wikipedia.org/wiki/CiteSeerX" rel="noopener ugc nofollow" target="_blank">citeserx</a>T910 . 1 . 1 . 40 . 6984。<a class="ae ky" href="https://en.wikipedia.org/wiki/Digital_object_identifier" rel="noopener ugc nofollow" target="_blank">doi</a>:<a class="ae ky" href="https://doi.org/10.1145%2F170035.170072" rel="noopener ugc nofollow" target="_blank">10.1145/170035.170072</a>。国际标准书号<a class="ae ky" href="https://en.wikipedia.org/wiki/Special:BookSources/978-0897915922" rel="noopener ugc nofollow" target="_blank">978–0897915922</a>。</li><li id="cdb0" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">韩(2000)。<em class="no">挖掘无候选生成的频繁模式</em>。<em class="no">2000年ACM SIGMOD数据管理国际会议论文集</em>。西格蒙德00。第1-12页。<a class="ae ky" href="https://en.wikipedia.org/wiki/CiteSeerX" rel="noopener ugc nofollow" target="_blank">citeserx</a><a class="ae ky" href="https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.40.4436" rel="noopener ugc nofollow" target="_blank">10 . 1 . 1 . 40 . 4436</a>。<a class="ae ky" href="https://en.wikipedia.org/wiki/Digital_object_identifier" rel="noopener ugc nofollow" target="_blank">doi</a>:<a class="ae ky" href="https://doi.org/10.1145%2F342009.335372" rel="noopener ugc nofollow" target="_blank">10.1145/342009.335372</a>。</li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><p id="4fd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="no">原载于2020年3月24日https://pyshark.com</em><a class="ae ky" href="https://pyshark.com/market-basket-analysis-using-association-rule-mining-in-python/" rel="noopener ugc nofollow" target="_blank"><em class="no"/></a>/<em class="no">。</em></p></div></div>    
</body>
</html>