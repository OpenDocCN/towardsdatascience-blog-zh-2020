<html>
<head>
<title>A Gentle Introduction to SQL Sub-Queries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SQL子查询简介</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-gentle-introduction-to-sql-sub-queries-ee288174d285?source=collection_archive---------19-----------------------#2020-02-14">https://towardsdatascience.com/a-gentle-introduction-to-sql-sub-queries-ee288174d285?source=collection_archive---------19-----------------------#2020-02-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="2b92" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">SQL变得简单</h2><div class=""/><div class=""><h2 id="6a17" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">了解为什么以及何时应该使用它们！</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/99a9f7f823519c26a684868ebf0b94d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KRD7iVcJOm56WuF0"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">有时候学习SQL感觉像是我们在矩阵里面，但是不需要那样！马库斯·斯皮斯克在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="5fcb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">SQL是任何数据科学家为了探索数据库都应该掌握的基本工具之一。它有简单易用的美誉。但是并不是所有的事情都是轻而易举的，对于新手来说，最大的挑战之一就是理解子查询的使用。</p><p id="61b0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在我们开始之前，有代码的笔记本一如既往地在这里等着你<a class="ae lh" href="https://github.com/lucasmoratof/sql-projects/blob/master/Introduction_to_SQL_sub_queries.ipynb" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="67ea" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">假设您熟悉SQL，我们首先要学习的一件事是主语句的顺序必须如下:</p><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="ca5c" class="mj mk it mf b gy ml mm l mn mo"><strong class="mf jd">1- SELECT </strong>column_name,<br/><strong class="mf jd">2- FROM </strong>table_name,<br/><strong class="mf jd">3- WHERE </strong>condition;</span></pre><p id="7726" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是有一点不太明显，那就是这不是处理查询的方式！实际上，几乎是反过来的:</p><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="87b8" class="mj mk it mf b gy ml mm l mn mo"><strong class="mf jd">1- FROM the </strong>table_name<br/><strong class="mf jd">2- WHERE this </strong>condition <strong class="mf jd">is true<br/>3- SELECT the rows of the </strong>column_name;</span></pre><p id="f737" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为什么知道这一点很重要？因为如果理解了这个逻辑，以后就更容易可视化子查询的需求了。对于SQL，理解幕后的工作与知道如何编写查询一样重要。</p><p id="709f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">假设您有下表<em class="mp"> team_data </em>:</p><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="5888" class="mj mk it mf b gy ml mm l mn mo">| <strong class="mf jd">team        </strong>| <strong class="mf jd">country </strong>| <strong class="mf jd">season</strong> | <strong class="mf jd">total_goals </strong>|<br/>|-------------|---------|--------|-------------|<br/>| Real Madrid | Spain   | 2019   | 53          |<br/>| Barcelona   | Spain   | 2019   | 47          |<br/>| Arsenal     | UK      | 2019   | 52          |<br/>| Real Madrid | Spain   | 2018   | 49          |<br/>| Barcelona   | Spain   | 2018   | 45          |<br/>| Arsenal     | UK      | 2018   | 50          |</span></pre><p id="db65" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果我们想按团队检索平均目标，查询将是:</p><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="af98" class="mj mk it mf b gy ml mm l mn mo"><strong class="mf jd">SELECT </strong>team,<br/>    <strong class="mf jd">AVG</strong>(total_goals) AS avg_goals<br/><strong class="mf jd">FROM </strong>team_data<br/><strong class="mf jd">GROUP BY</strong> team;</span></pre><p id="dfc9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这将给出以下结果:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/ed0b4b8cbe008e61418ed1c845269319.png" data-original-src="https://miro.medium.com/v2/resize:fit:438/format:webp/1*dZfizJD8NofbUL1DCXX1iA.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">按团队分组的平均目标</p></figure><p id="395e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">到目前为止，没有神秘，对不对？但是如果我们只想过滤平均得分高于50的团队呢？通常，我们的第一种方法是这样的:</p><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="c6e8" class="mj mk it mf b gy ml mm l mn mo"><strong class="mf jd">SELECT </strong>team <strong class="mf jd">AS </strong>team_name,<br/>    <strong class="mf jd">AVG</strong>(total_goals) <strong class="mf jd">AS </strong>avg_goals<br/><strong class="mf jd">FROM </strong>team_data<br/><strong class="mf jd">WHERE </strong>avg_goals &gt; 50<br/><strong class="mf jd">GROUP </strong>BY team;</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/4903600dfaec9d458849bfb5bd7483d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1078/format:webp/1*vPAa47yEcyp7aKl9l8pAYw.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">第一次尝试会产生聚合错误。</p></figure><p id="8a05" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这给了我们一个聚合错误，但是为什么呢？让我们根据查询的处理方式来执行这些步骤:</p><ul class=""><li id="a485" class="ms mt it lk b ll lm lo lp lr mu lv mv lz mw md mx my mz na bi translated">1: <strong class="lk jd"> FROM team_data </strong> —好的，表格存在，我们继续；</li><li id="93ec" class="ms mt it lk b ll nb lo nc lr nd lv ne lz nf md mx my mz na bi translated">2:<strong class="lk jd">WHERE avg _ goals&gt;50</strong>—嗯，这里我们有一个错误，<strong class="lk jd">如果计算还没有完成，如何过滤这些值呢？</strong></li></ul><p id="da11" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是一个需要使用子查询的完美例子。我们需要做的是首先生成字段<em class="mp"> avg_goals，</em>，这样当<strong class="lk jd"> WHEN </strong>语句开始过滤时，计算就已经完成了！根据查询逻辑，这个过程需要在来自语句的<strong class="lk jd">上完成，因为它在</strong>时出现在过滤器<strong class="lk jd">之前。让我们看看这个查询是怎样的:</strong></p><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="1636" class="mj mk it mf b gy ml mm l mn mo"><strong class="mf jd">SELECT </strong>team_name, avg_goals</span><span id="9b27" class="mj mk it mf b gy ng mm l mn mo"><strong class="mf jd">FROM </strong>(</span><span id="4541" class="mj mk it mf b gy ng mm l mn mo">-- Here we make our sub-query:<br/>    <strong class="mf jd">SELECT </strong>team AS team_name,<br/>    <strong class="mf jd">AVG</strong>(total_goals) AS avg_goals<br/>    <strong class="mf jd">FROM </strong>team_data<br/>    <strong class="mf jd">GROUP BY</strong> team) tp<br/>-- End of the sub-query</span><span id="895c" class="mj mk it mf b gy ng mm l mn mo"><strong class="mf jd">WHERE </strong>avg_goals &gt; 50;</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/3328ab4c33eb274a0c5688d64f0a9020.png" data-original-src="https://miro.medium.com/v2/resize:fit:416/format:webp/1*MayW0IuAvhc6ZVHTcyzxKw.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">成功！</p></figure><p id="51dc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你现在能看到发生了什么吗？</p><ul class=""><li id="16a6" class="ms mt it lk b ll lm lo lp lr mu lv mv lz mw md mx my mz na bi translated">1:来自语句的<strong class="lk jd">生成了我们需要的分组值；</strong></li><li id="f884" class="ms mt it lk b ll nb lo nc lr nd lv ne lz nf md mx my mz na bi translated">2: <strong class="lk jd">当</strong>按照我们的规范过滤后；</li><li id="f2b9" class="ms mt it lk b ll nb lo nc lr nd lv ne lz nf md mx my mz na bi translated">3:最后，<strong class="lk jd">选择</strong>获取我们指定的列。</li></ul><p id="43b2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">基本上，<strong class="lk jd">我们需要子查询大多数时候我们需要过滤聚集字段</strong>。写的时候给你一些帮助:</p><ul class=""><li id="8129" class="ms mt it lk b ll lm lo lp lr mu lv mv lz mw md mx my mz na bi translated">不要忘记在子查询之后创建一个别名。在这个例子中，在它的结尾有一个“tp ”,但是它可以是你想要的任何东西。</li><li id="aa18" class="ms mt it lk b ll nb lo nc lr nd lv ne lz nf md mx my mz na bi translated">即使SQL不区分大小写，将语句大写也是一个好习惯。使用缩进也很好，因为它提高了查询的可读性。即使是很小的查询也很容易迷路。</li></ul><p id="e6fb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">今天就到这里。我希望现在子查询对你来说更加神秘了！请在评论中告诉我你的想法，并随时添加一些更实际的例子！</p></div></div>    
</body>
</html>