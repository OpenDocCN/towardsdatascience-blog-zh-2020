<html>
<head>
<title>Spark in Docker in Kubernetes: A Practical Approach for Scalable NLP</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes Docker 中的 Spark:一种可扩展 NLP 的实用方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/spark-in-docker-in-kubernetes-a-practical-approach-for-scalable-nlp-9dd6ef47c31e?source=collection_archive---------12-----------------------#2020-01-18">https://towardsdatascience.com/spark-in-docker-in-kubernetes-a-practical-approach-for-scalable-nlp-9dd6ef47c31e?source=collection_archive---------12-----------------------#2020-01-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a031" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用谷歌云平台的 Kubernetes 引擎的自然语言处理</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9bb3c393d358b8e6191571bd76c38ae2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k3pT53E9cK18bNebIhC8Iw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由 Free 提供-照片来自 Pixabay</p></figure><p id="9385" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本文是一个更大项目的一部分。如果您也对可伸缩的 web 抓取或构建高度可伸缩的仪表板感兴趣，您会在本文末尾找到相应的链接。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="13d0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">目录</h1><ol class=""><li id="e94a" class="mu mv it la b lb mw le mx lh my ll mz lp na lt nb nc nd ne bi translated"><a class="ae nf" href="#fff0" rel="noopener ugc nofollow">读者必备</a></li><li id="28bf" class="mu mv it la b lb ng le nh lh ni ll nj lp nk lt nb nc nd ne bi translated"><a class="ae nf" href="#30a0" rel="noopener ugc nofollow">简介</a> <br/> <a class="ae nf" href="#30a0" rel="noopener ugc nofollow"> 2.1 本项目目的</a> <br/> <a class="ae nf" href="#bbe0" rel="noopener ugc nofollow"> 2.2 可扩展 NLP 简介</a></li><li id="1071" class="mu mv it la b lb ng le nh lh ni ll nj lp nk lt nb nc nd ne bi translated"><a class="ae nf" href="#61f5" rel="noopener ugc nofollow">架构</a></li><li id="18a3" class="mu mv it la b lb ng le nh lh ni ll nj lp nk lt nb nc nd ne bi translated"><a class="ae nf" href="#27dd" rel="noopener ugc nofollow">设置</a></li><li id="183a" class="mu mv it la b lb ng le nh lh ni ll nj lp nk lt nb nc nd ne bi translated"><a class="ae nf" href="#0f7a" rel="noopener ugc nofollow">如何在 Python 中使用 Spark-NLP </a> <br/> <a class="ae nf" href="#0f7a" rel="noopener ugc nofollow"> 5.1 概述</a><br/><a class="ae nf" href="#038f" rel="noopener ugc nofollow">5.2 Spark-NLP</a><br/><a class="ae nf" href="#18aa" rel="noopener ugc nofollow">5.3 构建 Docker </a></li><li id="09fb" class="mu mv it la b lb ng le nh lh ni ll nj lp nk lt nb nc nd ne bi translated"><a class="ae nf" href="#9960" rel="noopener ugc nofollow">部署到 Kubernetes </a> <br/> <a class="ae nf" href="#9960" rel="noopener ugc nofollow"> 6.1 设置 Kubernetes 集群</a> <br/> <a class="ae nf" href="#ca50" rel="noopener ugc nofollow"> 6.2 设置 Redis 为 kubernetseservice</a><br/><a class="ae nf" href="#55e6" rel="noopener ugc nofollow">6.3 用任务填充 Redis 队列</a> <br/> <a class="ae nf" href="#f59a" rel="noopener ugc nofollow"> 6.4 部署 Docker 容器</a> <br/> <a class="ae nf" href="#9e45" rel="noopener ugc nofollow"> 6.5 检查结果</a></li></ol></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fff0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.读者的先决条件</h1><p id="44d9" class="pw-post-body-paragraph ky kz it la b lb mw ju ld le mx jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">该项目是在谷歌云平台上开发的，建议也在那里做教程。然而，您可以在本地机器上运行它，但是您需要修改代码并替换一些已使用的资源。</p><p id="ac4d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本文的目标读者是已经对 Google 云平台和 Linux shell 有所了解的读者。为了帮助新读者入门，可以在本文中找到其他资源的链接。如果你没有使用过 Google Cloud Plattform，你可以使用 Google 的免费试用程序。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="30a0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.介绍</h1><h2 id="f3ed" class="no md it bd me np nq dn mi nr ns dp mm lh nt nu mo ll nv nw mq lp nx ny ms nz bi translated">2.1 本项目的目的</h2><p id="348b" class="pw-post-body-paragraph ky kz it la b lb mw ju ld le mx jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">本文的目标是展示实体(例如 Docker、Hadoop 等)如何。)可以使用 NLP 以可扩展的方式从文章中提取(基于 TowardsDatascience 的结构)。我们还将看看如何使用其他自然语言处理方法，如词性标注。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="bbe0" class="no md it bd me np nq dn mi nr ns dp mm lh nt nu mo ll nv nw mq lp nx ny ms nz bi translated">2.2 可扩展自然语言处理简介</h2><p id="7948" class="pw-post-body-paragraph ky kz it la b lb mw ju ld le mx jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated"><strong class="la iu">自然语言处理(NLP) <br/> </strong>自然语言处理使机器能够理解自然语言的结构和意义，并允许它们识别文本中的模式和关系。</p><p id="cec2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为什么它应该是可扩展的？<br/> 书面语言的处理可能非常复杂，如果没有可扩展的架构，可能需要很长时间。当然，您可以升级任何系统并使用更快的处理器，但这样做的成本增加与实现的效率收益不成比例。最好选择一种能够将计算负载分布在几台机器上的体系结构。</p><p id="9c9d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> Apache Spark </strong> <br/> Spark 是一个让数据处理和机器学习可扩展的好方法。它可以在本地或集群上运行，使用分布式数据集和处理管道。关于 Spark 的更多信息可以在这里找到:</p><div class="oa ob gp gr oc od"><a rel="noopener follow" target="_blank" href="/introduction-to-apache-spark-207a479c3001"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd iu gy z fp oi fr fs oj fu fw is bi translated">Apache Spark 简介</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">MapReduce 和 Spark 都用于大规模数据处理。然而，MapReduce 有一些缺点…</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">towardsdatascience.com</p></div></div><div class="om l"><div class="on l oo op oq om or ks od"/></div></div></a></div><p id="9f90" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Spark-NLP 是一个 Python 和 Scala 的库，允许用 Spark 处理书面语言。这将在后面的章节中介绍。更多信息可在此处找到:</p><div class="oa ob gp gr oc od"><a rel="noopener follow" target="_blank" href="/introduction-to-spark-nlp-foundations-and-basic-components-part-i-c83b7629ed59"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd iu gy z fp oi fr fs oj fu fw is bi translated">Spark NLP 简介:基础和基本组件</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">为什么我们需要另一个 NLP 库？</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">towardsdatascience.com</p></div></div><div class="om l"><div class="os l oo op oq om or ks od"/></div></div></a></div><p id="ce3e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> Redis <br/> </strong> Redis 是一个键值存储，我们将使用它来构建任务队列。</p><p id="e1ea" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> Docker 和 Kubernetes<br/></strong>Docker 容器可以想象成一个盒子里的完整系统。如果代码在容器中运行，它就独立于宿主的操作系统。这限制了 Spark 的可伸缩性，但可以通过使用 Kubernetes 集群来弥补。这些集群可以通过容器的数量快速轻松地扩展。如果您想了解更多信息，请访问:</p><div class="oa ob gp gr oc od"><a href="https://blog.containership.io/k8svsdocker/" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd iu gy z fp oi fr fs oj fu fw is bi translated">Kubernetes？码头工人？有什么区别？</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">从远处看，Docker 和 Kubernetes 可以看起来是类似的技术；它们都可以帮助您运行应用程序…</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">blog.containership.io</p></div></div><div class="om l"><div class="ot l oo op oq om or ks od"/></div></div></a></div></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="61f5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.体系结构</h1><p id="da6a" class="pw-post-body-paragraph ky kz it la b lb mw ju ld le mx jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">首先，这是我们的架构的样子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/8656e4f98b944201da1408de0550468b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t93whFHnV_evBV0lJ9sYiw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用于可伸缩文本处理的体系结构</p></figure><p id="500f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如您所见，这种方法是批处理架构。Python 脚本处理存储在 Google Datastore 中的文本，并创建一个作业队列。这个队列将由 Kubernetes pods 处理，结果将被写入 BigQuery。</p><p id="2a2a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了使本教程尽可能简短，只对计算量更大的语言处理部分进行缩放。任务队列创建器是一个简单的 Python 脚本(也可以在 Docker 中运行)。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="27dd" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">4.设置</h1><h2 id="d7eb" class="no md it bd me np nq dn mi nr ns dp mm lh nt nu mo ll nv nw mq lp nx ny ms nz bi translated">启动谷歌云外壳</h2><p id="73d6" class="pw-post-body-paragraph ky kz it la b lb mw ju ld le mx jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">我们将与谷歌的云控制台合作。要打开它，您需要创建一个项目并激活计费。</p><p id="ed59" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后你应该会看到右上角的云壳按钮。</p><p id="013c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">点击后，外壳应该在窗口的下半部分打开(如果遇到麻烦，使用 Chrome 浏览器)。为了更好地使用 shell，我建议启动编辑器:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/a17658900d596300a7ddddf3b44a7a6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:534/format:webp/1*rpc5sa4WDOEIk-5dNbricg.png"/></div></figure><h2 id="b3c8" class="no md it bd me np nq dn mi nr ns dp mm lh nt nu mo ll nv nw mq lp nx ny ms nz bi translated">获取存储库</h2><p id="cbc8" class="pw-post-body-paragraph ky kz it la b lb mw ju ld le mx jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">您可以使用以下命令下载<a class="ae nf" href="https://github.com/Juergen-Schmidl/TWD-01-2020" rel="noopener ugc nofollow" target="_blank">存储库</a>:</p><pre class="kj kk kl km gt ow ox oy oz aw pa bi"><span id="8c4a" class="no md it ox b gy pb pc l pd pe">git clone <a class="ae nf" href="https://github.com/Juergen-Schmidl/TWD-01-2020.git" rel="noopener ugc nofollow" target="_blank">https://github.com/Juergen-Schmidl/TWD-01-2020.git</a></span></pre><p id="5789" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">和必要的模型模板:</p><pre class="kj kk kl km gt ow ox oy oz aw pa bi"><span id="c5ff" class="no md it ox b gy pb pc l pd pe">$cd TWD-01-2020/5_NLP</span><span id="71dc" class="no md it ox b gy pf pc l pd pe">$bash get_model.sh &amp;<br/><em class="lu">Your Cloud Shell may freeze, try reconnecting after a few minutes</em></span></pre><h2 id="78ba" class="no md it bd me np nq dn mi nr ns dp mm lh nt nu mo ll nv nw mq lp nx ny ms nz bi translated">将项目 ID 设置为环境变量</h2><p id="1d67" class="pw-post-body-paragraph ky kz it la b lb mw ju ld le mx jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">由于我们在很多情况下都需要项目 ID，因此将其设置为环境变量更容易。请注意，如果您在本教程中中断了 shell，您必须再次设置它。您可以使用以下方式查找 ID 为的项目:</p><pre class="kj kk kl km gt ow ox oy oz aw pa bi"><span id="196f" class="no md it ox b gy pb pc l pd pe">$<!-- -->gcloud projects list</span></pre><p id="d85f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请运行:</p><pre class="kj kk kl km gt ow ox oy oz aw pa bi"><span id="e4cf" class="no md it ox b gy pb pc l pd pe">$export Project="yourprojectID"</span></pre><h2 id="d74d" class="no md it bd me np nq dn mi nr ns dp mm lh nt nu mo ll nv nw mq lp nx ny ms nz bi translated"><strong class="ak">获取您的服务账户</strong></h2><p id="a017" class="pw-post-body-paragraph ky kz it la b lb mw ju ld le mx jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">您经常需要服务帐户的密钥。要了解如何创建一个，你可以阅读<a class="ae nf" href="https://cloud.google.com/iam/docs/creating-managing-service-account-keys?hl=en#iam-service-account-keys-create-console" rel="noopener ugc nofollow" target="_blank">这个</a>。我更喜欢使用 IAM web 界面的方法，但是还有很多方法。为了简单起见，它应该被赋予“编辑器”的角色，但是从长远来看，建议进行更精细的调整。之后，执行以下步骤:</p><ul class=""><li id="5af1" class="mu mv it la b lb lc le lf lh pg ll ph lp pi lt pj nc nd ne bi translated">以 JSON 文件的形式下载密钥</li><li id="f173" class="mu mv it la b lb ng le nh lh ni ll nj lp nk lt pj nc nd ne bi translated">将您的密钥重命名为 sa.json</li><li id="8a2c" class="mu mv it la b lb ng le nh lh ni ll nj lp nk lt pj nc nd ne bi translated">在每个目录中放置一个副本(4_Setup，5_NLP，6_Scheduler)</li></ul><p id="4cab" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您的目录现在应该如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/bf49fbfde4805622f8d72f72324c792b.png" data-original-src="https://miro.medium.com/v2/resize:fit:568/format:webp/1*jA_YsD58TnEblS-8TK7low.png"/></div></figure><p id="0f06" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">设置输入-数据:</strong> <br/>(如果你已经完成了项目的<a class="ae nf" href="https://medium.com/@Postiii/9c0c23e3ebe5" rel="noopener">第一部分，可以跳过这个。)</a></p><p id="3fd0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们在数据存储模式下使用 Google Cloud Datastore 来提供源数据。为了准备数据存储，您必须将其置于数据存储模式。为此，只需在云平台中搜索数据存储，然后单击“选择数据存储模式”。(如果需要，也选择一个位置)</p><p id="8d61" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">之后，将目录更改为 4_Setup 并运行:</p><pre class="kj kk kl km gt ow ox oy oz aw pa bi"><span id="6f0f" class="no md it ox b gy pb pc l pd pe">$cd .. ; cd 4_Setup<br/><em class="lu">(You may have to enter this command manually)</em></span><span id="ca1a" class="no md it ox b gy pf pc l pd pe">$python3 Create_Samples.py</span></pre><p id="1250" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您看到“Samples generated”，那么您的云数据存储中有 20 个样本条目。</p><p id="8fa9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">设置输出表<br/> </strong>为了存储处理后的数据，我们创建了几个 BigQuery 表。我们使用下面的 bash 脚本来实现这一点:</p><pre class="kj kk kl km gt ow ox oy oz aw pa bi"><span id="7f28" class="no md it ox b gy pb pc l pd pe">$bash Create_BQ_Tables.sh</span></pre><p id="d28a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果创建了所有的表，我们就成功地创建了所有需要的资源。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0f7a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">5.如何使用 Spark-NLP</h1><h2 id="3795" class="no md it bd me np nq dn mi nr ns dp mm lh nt nu mo ll nv nw mq lp nx ny ms nz bi translated">5.1 概述</h2><p id="f5e5" class="pw-post-body-paragraph ky kz it la b lb mw ju ld le mx jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">NLP 模块位于存储库文件夹“5_NLP”中。请移动到这个目录(使用 shell)。文件夹中应包含以下文件:</p><ul class=""><li id="6654" class="mu mv it la b lb lc le lf lh pg ll ph lp pi lt pj nc nd ne bi translated"><a class="ae nf" href="https://github.com/Juergen-Schmidl/TWD-01-2020/blob/master/5_NLP/Explainer.py" rel="noopener ugc nofollow" target="_blank"><strong class="la iu">explainer . py</strong></a><strong class="la iu"><br/></strong>主脚本。在这里，Spark 将被启动，管道将被创建并用管道模型填充。文本处理也在这里进行。</li><li id="b079" class="mu mv it la b lb ng le nh lh ni ll nj lp nk lt pj nc nd ne bi translated"><a class="ae nf" href="https://drive.google.com/open?id=1l_ZZMfZpe1YdLMDkgaLJ9ZTEhQ8086oP" rel="noopener ugc nofollow" target="_blank"><strong class="la iu">Model _ template . zip</strong></a><br/>从文本中提取实体，即专有名称的示例模型。</li><li id="5621" class="mu mv it la b lb ng le nh lh ni ll nj lp nk lt pj nc nd ne bi translated"><strong class="la iu"> sa.json </strong> <br/>你的谷歌云服务账户。如果遇到 404 或 403 错误，请检查 IAM 中为此服务帐户授予的权限。</li><li id="8221" class="mu mv it la b lb ng le nh lh ni ll nj lp nk lt pj nc nd ne bi translated"><a class="ae nf" href="https://github.com/Juergen-Schmidl/TWD-01-2020/blob/master/5_NLP/Dockerfile" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu"> Dockerfile </strong> </a> <br/>这个文件包含了为环境设置的脚本。确切的设置解释如下。</li><li id="8bfb" class="mu mv it la b lb ng le nh lh ni ll nj lp nk lt pj nc nd ne bi translated"><a class="ae nf" href="https://github.com/Juergen-Schmidl/TWD-01-2020/blob/master/5_NLP/requirements.txt" rel="noopener ugc nofollow" target="_blank"><strong class="la iu">requirements . txt</strong></a><br/>该文件包含所需的 Python 库，这些库是在创建 Docker 映像的过程中安装的。</li><li id="c429" class="mu mv it la b lb ng le nh lh ni ll nj lp nk lt pj nc nd ne bi translated"><a class="ae nf" href="https://github.com/Juergen-Schmidl/TWD-01-2020/blob/master/5_NLP/Explainer.yaml" rel="noopener ugc nofollow" target="_blank"><strong class="la iu">explainer . YAML</strong></a><br/>这个文件包含了 Kubernetes 应该如何处理 Docker 图像的信息。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="038f" class="no md it bd me np nq dn mi nr ns dp mm lh nt nu mo ll nv nw mq lp nx ny ms nz bi translated">Python 中的 5.2 Spark-NLP</h2><p id="531b" class="pw-post-body-paragraph ky kz it la b lb mw ju ld le mx jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">如上所述，spark-nlp 是一个允许我们在 spark 中处理文本的库。为此，我们将该库与 Python 脚本“Explainer.py”一起使用。我对代码做了大量的注释，所以我在这里只讨论几个部分:</p><p id="532f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，您可能需要指定您的服务帐户文件的名称(如果您还没有坚持 sa.json):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pl pm l"/></div></figure><p id="78aa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">脚本的入口点使用<a class="ae nf" href="http://peter-hoffmann.com/2012/python-simple-queue-redis-queue.html" rel="noopener ugc nofollow" target="_blank"> Peter Hoffmann 的</a> Redis 类定期向 Redis 实例查询任务队列中的新条目。我们还没有设置实例，所以脚本还不能工作。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pl pm l"/></div></figure><p id="9692" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦任务到达任务队列，就调用“解释”函数，在那里进行处理。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pl pm l"/></div></figure><p id="8f0f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如您所看到的，实际的逻辑位于存储在(self)中的模型中。型号)。这个模型包含了自然语言处理的所有重要步骤，比如标记化、词汇化或者实体标注，并且是用函数 Load_Model()从一个 ZIP 文件中解压出来的。自己搭建模型，请参考本<a class="ae nf" href="https://colab.research.google.com/drive/1QlHLvO2tLY-MXS5MxBPs_ahm6vgtO_LC" rel="noopener ugc nofollow" target="_blank">笔记本</a>:</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="18aa" class="no md it bd me np nq dn mi nr ns dp mm lh nt nu mo ll nv nw mq lp nx ny ms nz bi translated">5.3 建造码头</h2><p id="fb95" class="pw-post-body-paragraph ky kz it la b lb mw ju ld le mx jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">Python 文件需要一个工作的 Spark 环境。为了提供这种环境，使用 docker 文件创建 docker 容器。我们的 docker 文件如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pl pm l"/></div></figure><p id="a350" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">docker 文件允许我们使用一个文件创建一个完整的系统。最重要的命令是:</p><p id="9093" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">从:</strong>设置基础图像。基本映像可以是本机操作系统，但可能已经安装了其他程序。</p><p id="92ff" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Spark 需要一些环境变量来工作。使用 ENV 命令，这些是为 Docker 容器设置的。</p><p id="075f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> COPY and WORKDIR </strong> : COPY 将 docker 文件的整个父目录复制到容器中，WORKDIR 将该目录设置为工作目录。</p><p id="e58c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">运行:</strong>调用在 Docker 容器外壳中执行的命令。通常用于安装应用程序。</p><p id="5503" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> CMD: </strong>一个 docker 文件只能有一个 CMD，这里调用实际的 Python 脚本。u 操作符对于从容器中获取日志非常重要。</p><p id="99e7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要构建 Docker 文件，请将目录切换到“5_NLP”并执行以下命令:</p><pre class="kj kk kl km gt ow ox oy oz aw pa bi"><span id="d5ea" class="no md it ox b gy pb pc l pd pe">$docker build --tag explainer_img .<br/><em class="lu">(You may have to enter this command manually)</em></span></pre><p id="0b7b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个命令从这个目录中的 Docker 文件构建 Docker 映像。我们还不能启动它，因为 Redis 实例没有运行，但是我们已经成功地创建了映像。</p><p id="0356" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了稍后在 Kubernetes 集群上运行它，我们必须将映像推入容器注册中心。为此，请使用 Google 云平台激活 API，并搜索“容器注册表”。然后，运行以下命令:</p><pre class="kj kk kl km gt ow ox oy oz aw pa bi"><span id="fd41" class="no md it ox b gy pb pc l pd pe">$docker tag explainer_img gcr.io/$Project/nlp_explainer:latest</span><span id="82c0" class="no md it ox b gy pf pc l pd pe">$docker push gcr.io/$Project/nlp_explainer:latest</span></pre><p id="1d89" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，您应该能够在容器注册表中看到您的文件了:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pn"><img src="../Images/fcb4b7675db6a43d1a94a5ebe6de9ced.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m2komo16-cC15pp05eZdRQ.png"/></div></div></figure><p id="e6b1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果到目前为止这是有效的，那么我们现在可以转移到 Kubernetes 集群，让这个项目发挥作用。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9960" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">6 次部署到 Kubernetes</h1><h2 id="4349" class="no md it bd me np nq dn mi nr ns dp mm lh nt nu mo ll nv nw mq lp nx ny ms nz bi translated">6.1 建立 Kubernetes 集群</h2><p id="b2e2" class="pw-post-body-paragraph ky kz it la b lb mw ju ld le mx jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">这部分非常简单，因为 Google 允许我们通过命令行创建一个 Kubernetes 集群。您可以运行这个命令来创建一个非常小的集群。</p><pre class="kj kk kl km gt ow ox oy oz aw pa bi"><span id="74fc" class="no md it ox b gy pb pc l pd pe">$bash Create_Cluster.sh</span></pre><p id="68ca" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">创建可能需要几分钟时间。如果您想创建一个更大的集群，请查看 Google Cloud Plattform 上的 Kubernetes 引擎。如果您使用 Kubernetes 引擎的 web 界面创建了集群，那么最初需要将您的控制台连接到集群。您可以通过点击“连接”来获得该声明:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi po"><img src="../Images/91893d97b5f148862d3c3542c160af86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zjiMvikxT8OFCtNHA_mk8A.png"/></div></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="ca50" class="no md it bd me np nq dn mi nr ns dp mm lh nt nu mo ll nv nw mq lp nx ny ms nz bi translated">6.2 将 Redis 设置为 Kubernetes 服务</h2><p id="4ef6" class="pw-post-body-paragraph ky kz it la b lb mw ju ld le mx jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">首先，我们必须使 Redis 在 Kubernetes 集群上可用，并将其注册为服务。这是必要的，因为容器是彼此隔离运行的。如果一个容器被注册为服务，所有容器都可以连接到它。</p><p id="b04b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为此，Redis 容器必须从位于“6_Scheduler”文件夹中的. yaml 文件创建。运行:</p><pre class="kj kk kl km gt ow ox oy oz aw pa bi"><span id="b4c6" class="no md it ox b gy pb pc l pd pe">$kubectl create -f redis-master-service.yaml</span></pre><p id="a08b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">并将其注册为服务(来自另一个。yaml 文件):</p><pre class="kj kk kl km gt ow ox oy oz aw pa bi"><span id="cf2c" class="no md it ox b gy pb pc l pd pe">$kubectl create -f redis-master.yaml</span></pre><p id="c54a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你仔细看看。yaml 文件，您将看到您可以指定所有需要的设置。行“replicas:”特别重要，因为它的值定义了并行实例的数量，因此也定义了处理数据的能力(当然受到底层机器的限制)。</p><p id="c3bb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们在一台相当小的机器上工作，所以我们不应该创建一个以上的副本。</p><p id="b3b2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果创建成功，您应该会看到以下输出:</p><pre class="kj kk kl km gt ow ox oy oz aw pa bi"><span id="f236" class="no md it ox b gy pb pc l pd pe">$kubectl get pods</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/a1f4aad735db22b5d36ee74c8394c8be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*1ihJaJoVDs35jdHXC0oQnw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这是包含 Redis 的豆荚</p></figure><pre class="kj kk kl km gt ow ox oy oz aw pa bi"><span id="0069" class="no md it ox b gy pb pc l pd pe">$kubectl get services</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pq"><img src="../Images/390cdecc90030cdd32323522c210966a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*Z65_eF_OJYXDN9PmDKnwVw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在这里，您可以看到为其他 pod 提供连接的服务</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="55e6" class="no md it bd me np nq dn mi nr ns dp mm lh nt nu mo ll nv nw mq lp nx ny ms nz bi translated">6.3 用任务填充 Redis 队列</h2><p id="a4a8" class="pw-post-body-paragraph ky kz it la b lb mw ju ld le mx jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">现在我们已经设置了 Redis 实例，我们可以开始用任务填充它了。首先，我们需要建立与 Redis 服务的本地连接。为此需要以下命令:</p><pre class="kj kk kl km gt ow ox oy oz aw pa bi"><span id="faa9" class="no md it ox b gy pb pc l pd pe">$kubectl port-forward deployment/redis-master 6379 &amp;</span></pre><p id="0fe3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后我们必须在本地机器上安装 Redis:</p><pre class="kj kk kl km gt ow ox oy oz aw pa bi"><span id="edef" class="no md it ox b gy pb pc l pd pe">$sudo pip3 install redis</span></pre><p id="7db2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">之后，可以调用 Python 脚本。它从云数据存储中检索数据，对其进行预处理，并将其放入 Redis 任务队列中。<br/>您可以使用以下命令启动脚本:</p><pre class="kj kk kl km gt ow ox oy oz aw pa bi"><span id="a187" class="no md it ox b gy pb pc l pd pe">$python3 Scheduler.py</span></pre><p id="7144" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该脚本已被详细注释，因此我仅提及几点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pl pm l"/></div></figure><p id="ee32" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">“过程批处理”方法包含实际的逻辑。在这里，文章被成批地从云数据存储中读取，并被传递给“Send_Job”方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pl pm l"/></div></figure><p id="71d3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为 Redis 不喜欢特殊字符，所以这些字符被删除以确保顺利处理。</p><p id="e617" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，创建的作业存储在 Redis 数据库中。发布命令。</p><p id="5482" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意:检查我们是否需要调用 regex 方法比替换快 10 倍。如果在填充数据存储时已经考虑了特殊字符，那么调度器的工作速度会快得多。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pr"><img src="../Images/6433271fa4fee45f02cab85fbbe6e026.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OyQC2W3PRXLJb_6Eg4oJnQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">执行时间的比较</p></figure><p id="4c35" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您应该会看到以下输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ps"><img src="../Images/afd5756fbf51fb8e898ebf59ed2e2efd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fISvQ1ExY6_3tZ_0e_r0dQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">任务队列已满</p></figure><p id="4c46" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">之后不要忘记终止端口转发:</p><pre class="kj kk kl km gt ow ox oy oz aw pa bi"><span id="91f1" class="no md it ox b gy pb pc l pd pe">$pkill kubectl -9</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="f59a" class="no md it bd me np nq dn mi nr ns dp mm lh nt nu mo ll nv nw mq lp nx ny ms nz bi translated">6.4 部署 Docker 容器</h2><p id="0634" class="pw-post-body-paragraph ky kz it la b lb mw ju ld le mx jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">您已经在 5.3 中为 explainer 创建了 docker 容器，并将其推送到名为“<code class="fe pt pu pv ox b">gcr/[your Project]nlp_explainer:latest</code>”的云容器注册表中。我们现在将在 Kubernetes 集群上部署它。</p><p id="590a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为此，将再次使用包含 Kubernetes 所有相关信息的. yaml 文件。</p><p id="e5c0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">请注意，你必须从注册表中插入你自己的容器(图片:)！</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pl pm l"/></div></figure><p id="0029" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">来推动。yaml 文件，您只需要在“5_NLP”文件夹中执行以下命令:</p><pre class="kj kk kl km gt ow ox oy oz aw pa bi"><span id="b803" class="no md it ox b gy pb pc l pd pe">$kubectl create -f Explainer.yaml</span></pre><p id="55bb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您使用小型集群，我建议只部署一个副本！<br/>否则你会遇到因表现不佳而导致的问题。</p><p id="4b7a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">之后，您可以使用以下方式查看 pod:</p><pre class="kj kk kl km gt ow ox oy oz aw pa bi"><span id="76c8" class="no md it ox b gy pb pc l pd pe">$kubectl get pods</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pw"><img src="../Images/d9db2cf63aa7de8459630cd6865e33a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g9RC0tfQ8BW4c7yRtgSmFg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">根据您的 Explainer.yaml 文件，pod 的数量可能有所不同</p></figure><p id="533d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">创建容器后，您应该使用以下命令获得此结果(可能需要 2 分钟):</p><pre class="kj kk kl km gt ow ox oy oz aw pa bi"><span id="1c20" class="no md it ox b gy pb pc l pd pe">$kubectl logs [pod-name]</span><span id="d712" class="no md it ox b gy pf pc l pd pe">for example:<br/>$kubectl logs explainer-544d123125-7nzbg</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi px"><img src="../Images/29ac3a59c3c3b2cb68e265315e807d5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1098/format:webp/1*yMvE-afXk0kyctMF3Z3vUw.png"/></div></figure><p id="4fd8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果出现问题，您还可以在日志中看到错误。</p><p id="bc6b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果所有的事情都被处理了，那么 pod 就会保持空闲，或者被 Kubernetes 驱逐并重新创建(因为它使用了一个循环，并且没有完成)。</p><p id="b5db" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要删除所有没有娱乐用途的窗格:</p><pre class="kj kk kl km gt ow ox oy oz aw pa bi"><span id="b038" class="no md it ox b gy pb pc l pd pe">$kubectl delete deployments [deployment]</span><span id="3ef1" class="no md it ox b gy pf pc l pd pe">for example:<br/>$kubectl delete deployments explainer</span></pre><p id="74bf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你不想再使用 Kubernetes 集群，你应该通过 web 界面或者使用下面的命令删除它，否则 Google 会继续向你收费。</p><pre class="kj kk kl km gt ow ox oy oz aw pa bi"><span id="6845" class="no md it ox b gy pb pc l pd pe">$<!-- -->gcloud config set project $Project<br/>$gcloud container clusters delete [your-clustername] --zone [Zone]</span><span id="27cf" class="no md it ox b gy pf pc l pd pe">for example:<br/>$gcloud config set project $Project<br/>$gcloud container clusters delete "your-first-cluster-1" --zone "us-central1-a"</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="9e45" class="no md it bd me np nq dn mi nr ns dp mm lh nt nu mo ll nv nw mq lp nx ny ms nz bi translated">6.5 检查结果</h2><p id="1ab8" class="pw-post-body-paragraph ky kz it la b lb mw ju ld le mx jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">要查看结果，请到谷歌云平台，搜索“BigQuery”。</p><p id="b0c6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您应该能够在左下方看到以下表格:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi py"><img src="../Images/36e8834a38d02e45512312791dea8821.png" data-original-src="https://miro.medium.com/v2/resize:fit:636/format:webp/1*0F96_jZ2M_z6OgHGL9iLPA.png"/></div></figure><p id="c384" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">“文章 _ 主数据”和“文章 _ 标签”这两个表格是由调度程序创建的，以满足连续项目的需要。但是我们希望看到“Entitiy _ raw”表的内容。</p><p id="1706" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要访问它们，请单击它，然后转到“预览”:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pz"><img src="../Images/775708940a15e03e1bfbe9d9b330917b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KCi0sgmpjhA4o7pmVA6S4w.png"/></div></div></figure><p id="97eb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您应该会看到实体识别的结果以及相应的文章 ID。</p><p id="9618" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就这样，你完了！</p><blockquote class="qa qb qc"><p id="1b6f" class="ky kz lu la b lb lc ju ld le lf jx lg qd li lj lk qe lm ln lo qf lq lr ls lt im bi translated">如果您有兴趣了解如何基于这些数据创建一个高度可伸缩的仪表板，我们会很高兴您阅读下面的教程:<a class="ae nf" href="https://medium.com/@arnold.lutsch/fa2bc6271f1d" rel="noopener"> <em class="it">构建一个高度可伸缩的仪表板，它运行在阿诺德·卢奇的 Kubernetes </em> </a> <em class="it">上</em></p><p id="f046" class="ky kz lu la b lb lc ju ld le lf jx lg qd li lj lk qe lm ln lo qf lq lr ls lt im bi translated">您还可以使用本教程将示例数据替换为真实的文章:<a class="ae nf" href="https://medium.com/@Postiii/9c0c23e3ebe5" rel="noopener"> <em class="it">使用 Selenium 和 python 构建一个可伸缩的 web crawler</em></a><em class="it"/></p></blockquote></div></div>    
</body>
</html>