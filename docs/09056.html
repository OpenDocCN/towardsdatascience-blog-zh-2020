<html>
<head>
<title>Object Detection- Tensorflow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对象检测-张量流</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/object-detection-tensorflow-854c7eb65fa?source=collection_archive---------33-----------------------#2020-06-29">https://towardsdatascience.com/object-detection-tensorflow-854c7eb65fa?source=collection_archive---------33-----------------------#2020-06-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="09c8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><em class="kf">使用 Tensorflow 对象检测 API 为 Pascal VOC 数据集训练对象检测模型</em></h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi kg"><img src="../Images/3756b4fe0477f000494a1e2ca867e73c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*YAV7fDPcPxjQsNlHQ_-qyw.jpeg"/></div><p class="ko kp gj gh gi kq kr bd b be z dk translated">Pascal VOC 数据集中图像的目标检测</p></figure><p id="e256" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi lo translated"><span class="l lp lq lr bm ls lt lu lv lw di"> T </span>使用 Tensorflow 对象检测 API 训练该模型，用于在 Pascal VOC 2012 数据集上训练 20 个类的模型。</p><p id="d806" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><em class="lx">自从机器学习和深度神经网络被搁置了几年后，它们的受欢迎程度又恢复了，人们对此议论纷纷。最近，世界各地的社区已经开始为机器学习领域做出贡献。自从其发展以来，对象检测和对象识别已经获得了巨大的普及，并且世界各地的研究人员已经贡献了各种最先进的架构。</em></p><blockquote class="ly lz ma"><p id="7a42" class="ks kt lx ku b kv kw jr kx ky kz ju la mb lc ld le mc lg lh li md lk ll lm ln ij bi translated">谷歌的 Tensorflow 贡献了一个专用的 API(对象检测 API ),它提供了一堆在大型语料库上训练过的模型。这些模型是免费提供的，也允许用户贡献。在这篇文章中，我将使用预训练的模型来训练一个模型，以检测<strong class="ku ir"> PASCAL VOC </strong>数据集中的对象。</p><p id="528e" class="ks kt lx ku b kv kw jr kx ky kz ju la mb lc ld le mc lg lh li md lk ll lm ln ij bi translated">本博客使用的数据集可在此免费获取(2012 版)。但是，服务器大部分时间都是关闭的，所以您可以在这里找到数据集。</p></blockquote><h1 id="8424" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated"><em class="kf">关于数据集</em></h1><p id="0422" class="pw-post-body-paragraph ks kt iq ku b kv mw jr kx ky mx ju la lb my ld le lf mz lh li lj na ll lm ln ij bi translated">我们使用的数据集代表 XML 文件和相应图像中的数据。数据中的每个 XML 文件都包含所有边界框的信息。对象检测 API 使用这些 XML 文件，并将它们转换为 csv 格式，CSV 格式可以进一步转换为训练模型所需的 tf 记录格式。在我们的例子中，我们使用的是 PASCAL VOC 数据集，tensorflow 已经为其提供了各种实用工具，使我们的生活变得更加轻松。我们将继续讨论细节。</p><h1 id="8119" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated"><strong class="ak"> <em class="kf">所以，现在是时候开始一些真正的编码了……</em></strong></h1><p id="2bf6" class="pw-post-body-paragraph ks kt iq ku b kv mw jr kx ky mx ju la lb my ld le lf mz lh li lj na ll lm ln ij bi translated">API 为我们抽象了所有棘手的东西。但是，在使用 API 之前，用户需要满足一些要求。</p><p id="f2a4" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">API 使用 tf 记录格式的数据集。它是表示数据的二进制格式。API 使用这种格式来加速训练过程。Tf record 在内部以允许并行处理的格式表示数据。</p><p id="97be" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">让我们从克隆 tensorflow 模型开始，它是正在研究的模型和正式发布的模型的集合。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="7952" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><em class="lx">现在我们需要在 models/research 的 object detection 文件夹中安装协议缓冲文件。此外，我们需要安装研究文件夹中的所有模型。让我们开始吧… </em></p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="a93a" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在研究文件夹中安装了所有的模型之后，我们就可以将数据转换成 tf 记录格式了。现在，在我们使用<strong class="ku ir"> PASCAL VOC </strong>数据集的情况下，tensorflow 为我们提供了一个脚本，我们可以用它来转换 tf 记录格式的数据。我们还需要标签数据，该数据包含要为其训练模型的类的数量。标签文件看起来像这样…</p><pre class="kh ki kj kk gt nd ne nf ng aw nh bi"><span id="ea0c" class="ni mf iq ne b gy nj nk l nl nm">item {<br/>  id: 0<br/>  name: 'businesscard'<br/>}<!-- --> </span></pre><p id="aa0f" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这里，每个 id 映射到一个从开始的唯一数字，名称是类名。在我们的例子中，我们有 20 个类，并且在同一个文件中有 20 个唯一的项目 JSON 对象。出于我们的目的，tensorflow 为我们的数据集提供了一个标签文件，该文件可以在您的 colab 笔记本<strong class="ku ir"><em class="lx">/content/models/research/object _ detection/data/Pascal _ label _ map . Pb txt</em></strong>中的以下路径找到</p><h1 id="4042" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated"><strong class="ak">实际调用脚本将数据转换成 Tf-record 格式的时间。</strong></h1><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nb nc l"/></div><p class="ko kp gj gh gi kq kr bd b be z dk translated">这将节省。列车数据的记录文件。</p></figure><p id="5b14" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">同样，您需要运行 create _ Pascal _ TF _ record _ test . py 来将测试数据转换成所需的格式。</p><h1 id="fa5e" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">现在该训练模型了…</h1><p id="6334" class="pw-post-body-paragraph ks kt iq ku b kv mw jr kx ky mx ju la lb my ld le lf mz lh li lj na ll lm ln ij bi translated">在处理 API 时，有各种各样的兼容性问题需要处理。这是由于 API 的初始版本。我花了大约 3 天时间解决了我们大多数人都面临的一个主要问题，那就是超薄模块。即使在提供了正确的路径和阅读了大量的博客和评论后，我最初也无法解决这个问题。但是，我会指导你的步骤，以帮助你按照目前的版本。运行培训流程时，需要使用瘦模块。要导入 slim 模块，您首先需要制作一个新的笔记本，导入并下载所有的库，并在其中克隆模型。</p><p id="7381" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在 colab 笔记本开始时，您必须首先使用以下命令<strong class="ku ir"><em class="lx">% tensorflow _ version 1.x</em></strong>将 tensor flow 版本转换为 1 . x</p><p id="e31c" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">出于我们的培训目的，我们将使用<strong class="ku ir"><em class="lx">SSD _ mobilenet _ v1 _ coco</em></strong><em class="lx">模型。我也尝试使用其他模型，但不知何故，在遵循相同的过程后，我无法摆脱那里的错误。但是对于</em><strong class="ku ir"><em class="lx">SSD _ mobilenet _ v1</em></strong><em class="lx">型号来说一切都很好。它是在 COCO 数据集上训练的模型，因此可以检测 90 个类别。但是出于我们的目的，我们只需要为 VOC 数据集中的 20 个类训练它。</em></p><p id="04f4" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">首先从 tensorflow 官网下载模型(<a class="ae nn" href="https://github.com/tensorflow/models/blob/master/research/object_detection/g3doc/detection_model_zoo.md" rel="noopener ugc nofollow" target="_blank">此处</a>)。现在，我们将提取模型 tar 文件。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="4a9a" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">现在，我将为您提供一些命令，您可以运行这些命令来解决 slim 问题。将以下命令复制并粘贴到您的笔记本中，以安装 slim 库，一次在 research/slim 文件夹中，第二次，复制 object_detection 文件夹中的所有 slim 文件，并将它们也安装在那里。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="2ecd" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">有时，使用 pip install tf-slim 直接安装 tf-slim 包也是可行的(大多数情况下是 kaggle 笔记本)</p><p id="e8ce" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">接下来，您需要从<a class="ae nn" href="https://github.com/tensorflow/models" rel="noopener ugc nofollow" target="_blank"><strong class="ku ir">models</strong></a><strong class="ku ir">/</strong><a class="ae nn" href="https://github.com/tensorflow/models/tree/master/research" rel="noopener ugc nofollow" target="_blank"><strong class="ku ir">research</strong></a><strong class="ku ir">/</strong><a class="ae nn" href="https://github.com/tensorflow/models/tree/master/research/object_detection" rel="noopener ugc nofollow" target="_blank"><strong class="ku ir">object _ detection</strong></a><strong class="ku ir">/</strong><a class="ae nn" href="https://github.com/tensorflow/models/tree/master/research/object_detection/samples" rel="noopener ugc nofollow" target="_blank"><strong class="ku ir">samples</strong></a><strong class="ku ir">/configs/</strong>文件夹中下载模型的 config 文件，并将输入 tf 记录文件、标签映射文件、测试 tf 记录文件的路径和目录更改为现在，运行命令开始训练过程。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nb nc l"/></div></figure><blockquote class="ly lz ma"><p id="e569" class="ks kt lx ku b kv kw jr kx ky kz ju la mb lc ld le mc lg lh li md lk ll lm ln ij bi translated"><strong class="ku ir"> <em class="iq">注意:在 colab 笔记本中，即使修改了 fine_tune_checkpoint 路径，检查点也会保存在 colab 笔记本根目录下的 tmp 文件夹中。如果这种情况仍然存在，一定要考虑一下。此外，如果训练中出现错误，则通过重新启动会话切换到 tensorflow 2.x。这样现在就不会出现小错误了。</em> </strong></p></blockquote><h1 id="0c02" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">推理</h1><p id="9506" class="pw-post-body-paragraph ks kt iq ku b kv mw jr kx ky mx ju la lb my ld le lf mz lh li lj na ll lm ln ij bi translated">在为 20 个类训练好模型之后，我们需要将检查点文件转换成可重用的格式。为了将模型转换成所需的格式，tensorflow 提供了一个可以使用的脚本。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nb nc l"/></div><p class="ko kp gj gh gi kq kr bd b be z dk translated">在 trained_checkpoint_prefix 中提供最新的检查点路径，但最多不超过您看到的最大检查点数量。</p></figure><blockquote class="ly lz ma"><p id="2ba1" class="ks kt lx ku b kv kw jr kx ky kz ju la mb lc ld le mc lg lh li md lk ll lm ln ij bi translated"><strong class="ku ir">注意:如果 export_inference_graph.py 脚本抛出一个错误，指出必须使用 output_file 提供路径，那么您需要用另一个可以下载的脚本替换这个脚本，在这里找到</strong><a class="ae nn" href="https://github.com/tensorflow/models/blob/master/research/object_detection/export_inference_graph.py" rel="noopener ugc nofollow" target="_blank"><strong class="ku ir"/></a><strong class="ku ir">，然后运行上面的命令</strong></p></blockquote><h1 id="5ab2" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">获得预测</h1><p id="ccaa" class="pw-post-body-paragraph ks kt iq ku b kv mw jr kx ky mx ju la lb my ld le lf mz lh li lj na ll lm ln ij bi translated">为了获得预测，我们将使用 tensorflow 工具来获得概率和边界框值，然后在图片上显示边界框。预测的全部代码非常简单，遵循相同的结构。你可以在下面找到代码…</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="8d0e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">您可以在我的 github repo 上找到完整的工作笔记本:</p><div class="no np gp gr nq nr"><a href="https://github.com/sahilgupta001/Object_Recognition_Pascal_VOC" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd ir gy z fp nw fr fs nx fu fw ip bi translated">sahilgupta 001/Object _ Recognition _ Pascal _ VOC</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">GitHub 是超过 5000 万开发人员的家园，他们一起工作来托管和审查代码、管理项目和构建…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">github.com</p></div></div><div class="oa l"><div class="ob l oc od oe oa of km nr"/></div></div></a></div><p id="9049" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我希望本教程能在培训和测试的各个方面帮助你。如果你有任何疑问，你可以在评论区提问。</p><h1 id="fd25" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated"><strong class="ak">谢谢！</strong></h1></div></div>    
</body>
</html>