<html>
<head>
<title>Closures and Decorators in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中的闭包和装饰器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/closures-and-decorators-in-python-2551abbc6eb6?source=collection_archive---------1-----------------------#2020-02-05">https://towardsdatascience.com/closures-and-decorators-in-python-2551abbc6eb6?source=collection_archive---------1-----------------------#2020-02-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="13a7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你将最终理解什么是闭包和装饰器</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/63119b55cd3b2c40d6ad74dcab1c3b8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6d9UKHIPO_-AA-IGhAu-GA.jpeg"/></div></div></figure><p id="b727" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">闭包是函数式编程中的一个重要工具，一些重要的概念如<em class="lq">curring</em>和<em class="lq"> partial application </em>可以使用它们来实现。装饰器也是 Python 中一个强大的工具，它使用闭包来实现，允许程序员修改函数的行为，而不用永久地修改它。在本文中，我将首先解释闭包和它们的一些应用程序，然后介绍装饰器。</p><p id="d911" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">变量范围</strong></p><p id="7836" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了更好地理解闭包，我们首先需要了解 Python 中变量的作用域。变量的<em class="lq">作用域</em>是指可以看到或访问变量的区域。变量不能在其作用域之外被访问。变量的范围由它在源代码中的赋值位置决定。通常，变量可以在三个不同的地方赋值，对应三个不同的作用域:</p><p id="ea30" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lq">全局作用域</em>:当一个变量在所有函数之外被定义时。文件中的所有函数都可以访问全局变量。</p><p id="8335" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lq">局部作用域</em>:当一个变量被定义在一个函数内部时，它是这个函数的局部变量。局部变量只能在定义它的函数内部访问。</p><p id="324f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lq">非局部作用域</em>:当一个变量在封闭函数中赋值时，它对其嵌套函数来说是非局部的。定义非局部变量的函数及其所有嵌套函数都可以访问非局部变量。</p><p id="5b7f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你在一个函数内部重新分配一个全局变量，一个新的同名局部变量将被创建，这个全局变量被称为被这个局部变量<em class="lq">遮蔽</em>。在函数内部对这个局部变量的任何改变都不会影响全局变量。所以如果你想在函数中改变一个全局值，你必须在 Python 中使用<code class="fe lr ls lt lu b">global</code>关键字。</p><p id="763c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如在清单 1 中，最初，我们定义了两个全局变量<code class="fe lr ls lt lu b">x</code>和<code class="fe lr ls lt lu b">y</code>。当我们在函数<code class="fe lr ls lt lu b">f()</code>内部重新赋值<code class="fe lr ls lt lu b">x</code>时，定义了一个新的同名局部变量，它并不影响全局变量<code class="fe lr ls lt lu b">x</code>。然而，通过使用<code class="fe lr ls lt lu b">global</code>关键字，我们可以访问<code class="fe lr ls lt lu b">f()</code>中的全局变量<code class="fe lr ls lt lu b">y</code>。<code class="fe lr ls lt lu b">z</code>是<code class="fe lr ls lt lu b">f()</code>的局部变量，不能在外部访问。退出<code class="fe lr ls lt lu b">f()</code>后，该变量不在内存中，因此不能再访问。</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="6bb6" class="lz ma it lu b gy mb mc l md me"># Listing 1</span><span id="1f7d" class="lz ma it lu b gy mf mc l md me">x = 1 # x is a global variable  <br/>y = 5 # y is a global variable <br/>def f():<br/>    global y <br/>    x = 2   # x is a local variable<br/>    y += 1  # Reassigning the global variable y<br/>    z = 10   # z is a local variable<br/>    print("Local variable x =", x)<br/>    print("Global variable y =", y)<br/>    print("Local variable z =", z)<br/>f()<br/>print("Global variable  x =", x)<br/>print("Global variable y =", y)</span></pre><p id="6d9d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">输出:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="1cf6" class="lz ma it lu b gy mb mc l md me">Local variable x = 2<br/>Global variable y = 6<br/>Local variable z = 10<br/>Global variable  x = 1<br/>Global variable y = 6</span></pre><p id="e88c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在 Python 中，一切都是对象，变量是对这些对象的引用。当你将一个变量传递给一个函数时，Python 会将一个引用的副本传递给该变量所引用的对象。它不发送对象或对函数的原始引用。因此，函数作为参数接收的原始引用和复制引用都引用同一个对象。现在，如果我们传递一个不可变的全局对象(比如一个整数或一个字符串)，函数就不能使用它的参数来修改它。然而，如果对象是可变的(比如一个列表)，函数可以修改它。这里有一个例子:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="c11f" class="lz ma it lu b gy mb mc l md me">Listing 2</span><span id="f6f3" class="lz ma it lu b gy mf mc l md me">a = [1, 2, 3]<br/>b = 5<br/>def func(x, y):<br/>    x.append(4)<br/>    y = y + 1</span><span id="3dfa" class="lz ma it lu b gy mf mc l md me">func(a, b)<br/>print("a=", a)  #  Output is a=[1, 2, 3, 4]<br/>print("b=", b)  #  Output is b=5</span></pre><p id="458f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将两个变量<code class="fe lr ls lt lu b">a</code>和<code class="fe lr ls lt lu b">b</code>传递给<code class="fe lr ls lt lu b">func</code>。<code class="fe lr ls lt lu b">a</code>是对可变对象列表的引用，而<code class="fe lr ls lt lu b">b</code>是对不可变整数的引用。<code class="fe lr ls lt lu b">func</code>接收作为<code class="fe lr ls lt lu b">x</code>的<code class="fe lr ls lt lu b">a</code>的副本和作为<code class="fe lr ls lt lu b">y</code>的<code class="fe lr ls lt lu b">b</code>的副本。向<code class="fe lr ls lt lu b">x</code>添加新元素将改变<code class="fe lr ls lt lu b">a</code>引用的原始对象。但是在<code class="fe lr ls lt lu b">func</code>里面给<code class="fe lr ls lt lu b">y</code>加 1 并不影响<code class="fe lr ls lt lu b">b</code>所引用的对象。它只创建了一个包含 6 的新整数对象，现在<code class="fe lr ls lt lu b">y</code>将引用它(图 1)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mg"><img src="../Images/1a998d452fc6309134e740bdfa3a4227.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nzE2CtKUX3HQ25VVA1r6cA.jpeg"/></div></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">图 1</p></figure><p id="1b8d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">内部函数</strong></p><p id="c278" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lq">内部函数</em>(或<em class="lq">嵌套函数</em>)是定义在另一个函数(外部函数)内部的函数。外部函数的局部变量对其内部函数来说是非局部的。内部函数可以访问非局部变量，但不能改变它们。重新分配它们只是在内部函数中创建一个同名的新局部变量，而不会影响非局部变量。所以如果你想在一个嵌套函数中改变一个非局部变量，你必须使用<code class="fe lr ls lt lu b">nonlocal</code>关键字。</p><p id="177a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本文中，我们可以简单地称外部函数的变量为非局部变量，但这意味着它相对于内部函数是非局部的。如果删除内部函数，它将只是外部函数的一个局部变量。此外，内部函数应该以某种方式访问这个变量或者声明它为<code class="fe lr ls lt lu b">nonlocal</code>来调用它作为一个非局部变量。如果内部函数不接触外部函数的局部变量，它就不是内部函数的非局部变量。</p><p id="7cad" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本文中，我们从不试图改变函数参数。因此，只要知道外部函数参数的行为类似于非局部变量，并且也可以被内部函数访问(或读取)就足够了。</p><p id="5a5f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在清单 3 中，函数参数<code class="fe lr ls lt lu b">x</code>，变量<code class="fe lr ls lt lu b">y</code>、<code class="fe lr ls lt lu b">z</code>和<code class="fe lr ls lt lu b">t</code>是<code class="fe lr ls lt lu b">f()</code>的局部变量。</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="7f46" class="lz ma it lu b gy mb mc l md me"># Listing 3</span><span id="e264" class="lz ma it lu b gy mf mc l md me">def f(x):<br/>    y = 5<br/>    z = 10<br/>    t = 10<br/>    def g():<br/>        nonlocal y<br/>        y += 1<br/>        z = 20<br/>        print("Nonlocal variable x =", x)<br/>        print("Local variable z =", z) <br/>    print("Local variable t =", t)    <br/>    g()<br/>    print("Nonlocal variable x =", x)<br/>    print("Nonlocal variable y =", y)<br/>    print("Local variable z =", z)<br/>f(5)<br/># This does not work:<br/># g()</span></pre><p id="2721" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">输出:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="4fb6" class="lz ma it lu b gy mb mc l md me">Local variable t = 10<br/>Nonlocal variable x = 5<br/>Local variable z = 20 <br/>Nonlocal variable x = 5<br/>Nonlocal variable y = 6<br/>Local variable z = 10</span></pre><p id="6688" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lr ls lt lu b">x</code>，和<code class="fe lr ls lt lu b">y</code>也是其内部函数<code class="fe lr ls lt lu b">g()</code>的非局部变量。它们在<code class="fe lr ls lt lu b">g()</code>内部被访问。当你重新赋值<code class="fe lr ls lt lu b">z</code>时，在<code class="fe lr ls lt lu b">g()</code>内部会创建一个新的同名局部变量，它不会影响<code class="fe lr ls lt lu b">f()</code>中的局部变量<code class="fe lr ls lt lu b">z</code>，所以<code class="fe lr ls lt lu b">z</code>不是一个非局部变量(到<code class="fe lr ls lt lu b">g</code>)。然而，通过使用关键字<code class="fe lr ls lt lu b">nonlocal</code>你可以改变<code class="fe lr ls lt lu b">y</code>，它仍然是一个非局部变量。变量<code class="fe lr ls lt lu b">t</code>根本不被<code class="fe lr ls lt lu b">g</code>访问，所以它不是一个非局部变量。</p><p id="16a2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">变量<code class="fe lr ls lt lu b">y</code>和<code class="fe lr ls lt lu b">z</code>属于<code class="fe lr ls lt lu b">f()</code>的局部范围，不能在<code class="fe lr ls lt lu b">f()</code>之外访问。内部函数<code class="fe lr ls lt lu b">g()</code>也被定义在<code class="fe lr ls lt lu b">f()</code>内部，只能在那里被调用。事实上，如果您试图运行清单 3 并在<code class="fe lr ls lt lu b">f()</code>之外调用<code class="fe lr ls lt lu b">g()</code>，Python 会给出一个错误。</p><p id="b909" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是如果我们能找到一种方法在<code class="fe lr ls lt lu b">g()</code>之外调用它呢？那么我们会有第二个问题。退出外部函数后，其局部变量(不属于<code class="fe lr ls lt lu b">g()</code>的局部变量)不再存在于内存中。在这种情况下，内部函数不能再访问它们。闭包使得在外部函数之外调用内部函数并访问其非局部变量成为可能。</p><p id="3fb0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">关闭</strong></p><p id="4503" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，我们需要找到一种在外部函数之外调用内部函数的方法。记住函数总是可以返回值的。在清单 4 中，<code class="fe lr ls lt lu b">x</code>和<code class="fe lr ls lt lu b">y</code>是<code class="fe lr ls lt lu b">f()</code>的局部变量:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="b3f6" class="lz ma it lu b gy mb mc l md me"># Listing 4</span><span id="b55f" class="lz ma it lu b gy mf mc l md me">def f():<br/>    x = 5<br/>    y = 10<br/>    return x<br/>h=f()</span></pre><p id="01f8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以在运行<code class="fe lr ls lt lu b">h=f()</code>之后，<code class="fe lr ls lt lu b">f()</code>的所有局部变量都消失了，你再也不能访问<code class="fe lr ls lt lu b">x</code>和<code class="fe lr ls lt lu b">y</code>了。但是我们仍然有<code class="fe lr ls lt lu b">x</code>的值，它被返回并存储在<code class="fe lr ls lt lu b">h</code>中。所以也许我们可以让外层函数返回内层函数。这在 Python 中是可能的，因为 Python 函数是第一类。这意味着 Python 将函数视为值，因此您可以将函数赋给变量，将其作为函数参数传递或由另一个函数返回。在清单 5 中，外部函数<code class="fe lr ls lt lu b">f(x)</code>返回其内部函数<code class="fe lr ls lt lu b">g</code>。</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="11d3" class="lz ma it lu b gy mb mc l md me"># Listing 5</span><span id="8ca4" class="lz ma it lu b gy mf mc l md me">def f(x):<br/>    def g(y):<br/>        return y<br/>    return g<br/>a = 5<br/>b = 1<br/>h=f(a)<br/>h(b)  # Output is 1</span></pre><p id="f3d9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在<code class="fe lr ls lt lu b">f(x)</code>返回函数<code class="fe lr ls lt lu b">g</code>。所以当我们写<code class="fe lr ls lt lu b">h=f(a)</code>时，我们将<code class="fe lr ls lt lu b">g</code>赋给<code class="fe lr ls lt lu b">h</code>，现在<code class="fe lr ls lt lu b">h</code>可以像<code class="fe lr ls lt lu b">g</code>一样被对待，并接受<code class="fe lr ls lt lu b">g</code>的参数。结果<code class="fe lr ls lt lu b">h(b)</code>就像调用<code class="fe lr ls lt lu b">g(b)</code>。</p><p id="9f17" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">函数的<code class="fe lr ls lt lu b">__name__</code>属性存储定义函数的名称。如果我们写:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="94a4" class="lz ma it lu b gy mb mc l md me">h.__name__   </span></pre><p id="7233" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它回来了</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="a099" class="lz ma it lu b gy mb mc l md me">'g'</span></pre><p id="01ec" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">也就是说<code class="fe lr ls lt lu b">h</code>现在指的是函数<code class="fe lr ls lt lu b">g</code>。</p><p id="74de" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你应该注意到<code class="fe lr ls lt lu b">f(x)</code>返回的是函数<code class="fe lr ls lt lu b">g</code>而不是一个特定的值。比如说。如果我们写下如下内容:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="2418" class="lz ma it lu b gy mb mc l md me"># Listing 6</span><span id="a205" class="lz ma it lu b gy mf mc l md me">def f(x):<br/>    def g(y):<br/>        return y<br/>    return g(y)<br/>a = 5<br/>b = 1<br/>h=f(a) <br/># This does not work:<br/># h(b)</span></pre><p id="3d73" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后我们得到一个错误。原因是我们是由<code class="fe lr ls lt lu b">f(x)</code>(也就是 1)返回<code class="fe lr ls lt lu b">g(y)</code>的值，所以<code class="fe lr ls lt lu b">h=1</code>，不能用它来调用函数。</p><p id="42c9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们不需要将<code class="fe lr ls lt lu b">f(a)</code>存储在<code class="fe lr ls lt lu b">h</code>中。而是可以直接调用<code class="fe lr ls lt lu b">f(a)(b)</code>。</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="6a5f" class="lz ma it lu b gy mb mc l md me"># Listing 7</span><span id="8de3" class="lz ma it lu b gy mf mc l md me">def f(x):<br/>    def g(y):<br/>        return y<br/>    return g<br/>a = 5<br/>b = 1<br/>f(a)(b)  # Output is 1</span></pre><p id="bc83" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">需要注意的是，要区分<code class="fe lr ls lt lu b">f(a, b)</code>和<code class="fe lr ls lt lu b">f(a)(b)</code>。函数<code class="fe lr ls lt lu b">f(a, b)</code>有两个参数。然而，<code class="fe lr ls lt lu b">f(a)(b)</code>是一系列嵌套函数，每个函数都有一个参数。只有一个参数的函数叫做一元函数。所以<code class="fe lr ls lt lu b">f(a)(b)</code>是两个嵌套的一元函数的序列。如图 2 所示，Python 从左到右计算这些嵌套函数。所以首先对<code class="fe lr ls lt lu b">f(a)</code>进行评估。为了能够链接这些函数，<code class="fe lr ls lt lu b">f(a)</code>应该返回另一个函数。这里它返回内部函数<code class="fe lr ls lt lu b">g</code>。所以<code class="fe lr ls lt lu b">f(a)(b)=g(b)</code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ml"><img src="../Images/6802c1a15acbcd9d3724f9c9911c3c89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fxPw-BUfHoPcGkIBBWTgHQ.jpeg"/></div></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">图 2</p></figure><p id="c714" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以很容易地扩展这个方法，得到一个更长的一元函数序列。清单 8 展示了我们如何拥有三个嵌套的一元函数。第一个函数<code class="fe lr ls lt lu b">f(x)</code>具有内部函数<code class="fe lr ls lt lu b">g(y)</code>并且<code class="fe lr ls lt lu b"> g(y)</code>具有内部函数<code class="fe lr ls lt lu b">h(z)</code>。每个外部函数返回其内部函数。</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="5058" class="lz ma it lu b gy mb mc l md me"># Listing 8</span><span id="2b94" class="lz ma it lu b gy mf mc l md me">def f(x):<br/>    def g(y):<br/>        def h(z):<br/>            return z<br/>        return h<br/>    return g<br/>a = 5<br/>b = 2<br/>c = 1<br/>f(a)(b)(c)  # Output is 1</span></pre><p id="0d11" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是如果外层函数有一些非局部变量会怎么样呢？这里有一个例子:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="f6e7" class="lz ma it lu b gy mb mc l md me"># Listing 9</span><span id="05fb" class="lz ma it lu b gy mf mc l md me">def f(x):<br/>    z = 2<br/>    def g(y):<br/>        return z*x + y<br/>    return g<br/>a = 5<br/>b = 1<br/>h = f(a)<br/>h(b)  # Output is 11</span></pre><p id="cd54" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们运行它，我们可以看到它工作正常，并且<code class="fe lr ls lt lu b">g(y)</code>可以访问变量<code class="fe lr ls lt lu b">x</code>和<code class="fe lr ls lt lu b">z</code>。但这怎么可能呢？运行<code class="fe lr ls lt lu b">f(x)</code>后，我们不再在<code class="fe lr ls lt lu b">f(x)</code>的范围内，变量<code class="fe lr ls lt lu b">x</code>和<code class="fe lr ls lt lu b">z</code>应该是不可访问的。为什么<code class="fe lr ls lt lu b">g(y)</code>仍然可以访问它们？那是因为内部函数<code class="fe lr ls lt lu b">g(y)</code>现在是一个<em class="lq">闭包</em>。</p><p id="f6bf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">闭包是具有扩展范围的内部函数，它包含外部函数的非局部变量。所以它记住了封闭范围中的非局部变量，即使它们不在内存中。像<code class="fe lr ls lt lu b">y</code>这样在内部函数<code class="fe lr ls lt lu b">g(y)</code>局部范围内的变量称为<em class="lq">绑定变量</em>。只有有界变量的函数称为<em class="lq">闭项</em>。另一方面，像<code class="fe lr ls lt lu b">z</code>这样的非局部变量被称为<em class="lq">自由变量</em>，因为它可以在<code class="fe lr ls lt lu b">g(y)</code>之外自由定义，而包含自由变量的函数被称为<em class="lq">开项</em>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mm"><img src="../Images/74ec1620e137ad6df6ce456d685fbb5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m1O3u3lZIknaLn1XutKa4Q.jpeg"/></div></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">图 3</p></figure><p id="85f6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">“闭包”这个名字来源于这样一个事实，即它捕获其自由(非局部)变量的绑定，并且是<em class="lq">关闭</em>一个开放项的结果。</p><p id="6306" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以闭包是一个开放项，它通过捕获自由(非局部)变量的绑定而被封闭。在清单 9 中，只要内部函数<code class="fe lr ls lt lu b">g(y)</code>有一个尚未绑定的自由变量(<code class="fe lr ls lt lu b">x</code>和<code class="fe lr ls lt lu b">z</code>)，它就不是闭包。一旦我们对<code class="fe lr ls lt lu b">h=f(a)</code>求值，封闭函数<code class="fe lr ls lt lu b">f(x)</code>也被求值，自由变量<code class="fe lr ls lt lu b">x</code>和<code class="fe lr ls lt lu b">z</code>分别被绑定到 5 和 2。所以由<code class="fe lr ls lt lu b">f(a)</code>返回的<code class="fe lr ls lt lu b">g(y)</code>变成了一个闭包，并且<code class="fe lr ls lt lu b">h</code>现在引用了一个闭包(图 4)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mn"><img src="../Images/248413e5229a937e4e0df718451788d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zjrkiqxMi7Dy5aFL2OkawQ.jpeg"/></div></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">图 4</p></figure><p id="d0ba" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Python 可以跟踪每个函数的自由变量。我们可以简单地使用<code class="fe lr ls lt lu b">__code__.co_freevars</code>属性来查看内部函数捕获了哪些自由变量。例如，对于清单 9 中定义的闭包，我们可以写:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="ef0c" class="lz ma it lu b gy mb mc l md me">h.__code__.co_freevars</span></pre><p id="0900" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">输出将是:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="481f" class="lz ma it lu b gy mb mc l md me">('x', 'z')</span></pre><p id="6142" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您还可以使用<code class="fe lr ls lt lu b">closure</code>属性获得这些自由变量的值:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="9aba" class="lz ma it lu b gy mb mc l md me">print(h.__code__.co_freevars[0], "=",<br/>      h.__closure__[0].cell_contents) <br/>print(h.__code__.co_freevars[1], "=",<br/>      h.__closure__[1].cell_contents)</span></pre><p id="c560" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">输出将是</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="b3e2" class="lz ma it lu b gy mb mc l md me">x = 5<br/>z = 2</span></pre><p id="9797" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">重要的是要注意，为了有一个闭包，内部函数应该<em class="lq">访问</em>外部函数的非局部变量。当内部函数中没有自由变量被访问时，它不会捕获它们，因为它已经是一个封闭项，不需要被封闭。例如，如果我们将清单 9 中的内部函数改为:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="86f6" class="lz ma it lu b gy mb mc l md me"># Listing 10</span><span id="a491" class="lz ma it lu b gy mf mc l md me">def f(x):<br/>    z = 2<br/>    def g(y):<br/>        return y<br/>    return g<br/>a = 5<br/>b = 1<br/>h = f(a)<br/>h(b)  # Output is 1</span></pre><p id="fc0f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那就不能再认为这是一个终结了。原因是非局部变量<code class="fe lr ls lt lu b">x</code>和<code class="fe lr ls lt lu b">z</code>在<code class="fe lr ls lt lu b">g(y)</code>内部没有被访问，不需要<code class="fe lr ls lt lu b">g(y)</code>去捕获它们。我们可以很容易地通过写下:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="df00" class="lz ma it lu b gy mb mc l md me">h.__code__.co_freevars</span></pre><p id="e03b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">输出将是:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="3db6" class="lz ma it lu b gy mb mc l md me">()</span></pre><p id="a8c1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，<code class="fe lr ls lt lu b">h.__closure</code>返回<code class="fe lr ls lt lu b">None</code>，这意味着<code class="fe lr ls lt lu b">h</code>不再是闭包。如果您没有访问一个非局部变量，而是在内部函数中将它定义为<code class="fe lr ls lt lu b">nonlocal</code>,它仍然会被闭包捕获。所以在清单 11 中，<code class="fe lr ls lt lu b">g(y)</code>是一个闭包，因为它捕获了<code class="fe lr ls lt lu b">t</code>。</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="b7d1" class="lz ma it lu b gy mb mc l md me"># Listing 11</span><span id="f40c" class="lz ma it lu b gy mf mc l md me">def f(x):<br/>    z = 2<br/>    t = 3<br/>    def g(y):<br/>        nonlocal t<br/>        return y<br/>    return g<br/>a = 5<br/>b = 1<br/>h = f(a)<br/>h(b)  <br/>h.__code__.co_freevars  # Output is ('t',)</span></pre><p id="0c38" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另一个例子有点复杂:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="b2bd" class="lz ma it lu b gy mb mc l md me"># Listing 12</span><span id="04bb" class="lz ma it lu b gy mf mc l md me">def f(x):<br/>    def g(y = x):<br/>        return y<br/>    return g<br/>a = 5<br/>b = 1<br/>h = f(a)<br/>h()  # Output is 5</span></pre><p id="2b12" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里<code class="fe lr ls lt lu b">g(y)</code>也不是一个闭包，因为<code class="fe lr ls lt lu b">x</code>的值只是用来初始化<code class="fe lr ls lt lu b">y</code>，而<code class="fe lr ls lt lu b">g</code>不需要捕获<code class="fe lr ls lt lu b">x</code>。</p><p id="15d0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当您有多个嵌套函数时，每个闭包都能够捕获更高层的所有非局部变量。例如，如果我们有三个嵌套函数:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="1fc5" class="lz ma it lu b gy mb mc l md me"># Listing 13</span><span id="be80" class="lz ma it lu b gy mf mc l md me">def f(x):<br/>    def g(y):<br/>        def h(z):<br/>            return x * y * z<br/>        return h<br/>    return g<br/>a = 5<br/>b = 2<br/>c = 1<br/>f(a)(b)(c)  # Output is 10</span></pre><p id="78a1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后<code class="fe lr ls lt lu b">h(z)</code>正在访问<code class="fe lr ls lt lu b">f</code>和<code class="fe lr ls lt lu b">g</code>的非局部变量，所以它将捕获这两个变量，所以</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="c248" class="lz ma it lu b gy mb mc l md me"># f(a)(b) refers to h<br/>f(a)(b).__code__.co_freevars</span></pre><p id="ed71" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将会是:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="7363" class="lz ma it lu b gy mb mc l md me">('x', 'y')</span></pre><p id="49ed" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，<code class="fe lr ls lt lu b">g(y)</code>也是一个闭包，它捕获<code class="fe lr ls lt lu b">x</code>作为一个非局部变量。我们可以很容易的检查出来(记住<code class="fe lr ls lt lu b">f(a)</code>指的是<code class="fe lr ls lt lu b">g(y)</code>):</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="ce7b" class="lz ma it lu b gy mb mc l md me">f(a).__code__.co_freevars  # Output is ('x',)</span></pre><p id="694d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是<code class="fe lr ls lt lu b">g(y)</code>不访问<code class="fe lr ls lt lu b">x</code>。为什么<code class="fe lr ls lt lu b">g(y)</code>要变成关闭并捕获<code class="fe lr ls lt lu b">x</code>？原因是它的内在功能是访问它。<code class="fe lr ls lt lu b">h(z)</code>需要捕获<code class="fe lr ls lt lu b">x</code>，但是一个闭包只能捕获其外部函数的自由变量，在本例中是<code class="fe lr ls lt lu b">g(y)</code>。所以首先<code class="fe lr ls lt lu b">g(y)</code>应该扩展其范围并捕获<code class="fe lr ls lt lu b">x</code>，然后<code class="fe lr ls lt lu b">h(z)</code>可以扩展其范围并捕获<code class="fe lr ls lt lu b">x</code>作为<code class="fe lr ls lt lu b">g(y)</code>的自由变量。如果我们将清单 13 替换为:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="c75b" class="lz ma it lu b gy mb mc l md me"># Listing 14</span><span id="f7ad" class="lz ma it lu b gy mf mc l md me">def f(x):<br/>    def g(y):<br/>        def h(z):<br/>            return y * z<br/>        return h<br/>    return g<br/>a = 5<br/>b = 2<br/>c = 1<br/>f(a).__code__.co_freevars  # Output is ()</span></pre><p id="4ef3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以看到<code class="fe lr ls lt lu b">g(y)</code>不再是一个闭包。那是因为<code class="fe lr ls lt lu b">h(z)</code>不需要捕捉<code class="fe lr ls lt lu b">x</code>。结果，<code class="fe lr ls lt lu b">g(y)</code>也没有捕捉到，没有成为闭包。</p><p id="1504" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可能已经注意到，为了调用闭包，我们不使用内部函数的名称。我们只使用外部函数的名称。所以如果我们只有一个表达式，我们也可以用 lambda 函数代替内部函数。例如，我们可以用一个匿名函数替换清单 10 中的内部函数<code class="fe lr ls lt lu b">g</code>:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="58ef" class="lz ma it lu b gy mb mc l md me"># Listing 15</span><span id="f277" class="lz ma it lu b gy mf mc l md me">def f(x):<br/>    z = 2<br/>    return lambda y: z*x+y<br/>a = 5<br/>b = 1<br/>f(a)(b)  # Output is 11</span></pre><p id="de57" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">至此，我想总结一下到目前为止我们学到的关于闭包的知识。为了定义闭包，我们需要一个内部函数:</p><p id="0449" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">1-它应该由外部函数返回。</p><p id="69c7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">2-它应该捕获外部函数的一些非局部变量。这可以通过访问这些变量，或者将它们定义为非局部变量，或者使用需要捕获它们的嵌套闭包来实现。</p><p id="ef34" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在定义闭包之后，为了初始化它，您必须调用外部函数来返回闭包。</p><p id="2112" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在函数式编程中，闭包可以将数据绑定到函数，而不需要将它们作为参数传递。这类似于面向对象编程中的类。在清单 16 中，我们比较了这些范例。我们首先创建一个类来计算一个数的 n 次方根。</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="a132" class="lz ma it lu b gy mb mc l md me"># Listing 16</span><span id="c28f" class="lz ma it lu b gy mf mc l md me">class NthRoot:<br/>    def __init__(self, n=2):<br/>        self.n = n<br/>    def set_root(n):<br/>        self.n = n<br/>    def calc(self, x):<br/>        return x ** (1/self.n)<br/>    <br/>thirdRoot = NthRoot(3)<br/>print(thirdRoot.calc(27))  # Output is 3</span><span id="a812" class="lz ma it lu b gy mf mc l md me">def nth_root(n=2):<br/>    def calc(x):<br/>        return x ** (1/n)<br/>    return calc</span><span id="5f3c" class="lz ma it lu b gy mf mc l md me">third_root = nth_root(3)<br/>print(third_root(27))  # Output is 3</span></pre><p id="2e06" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如你所见，外部函数在这里可以为我们扮演一个构造函数的角色。它初始化内部函数将使用的非局部变量。然而，也有一些不同之处。<code class="fe lr ls lt lu b">NthRoot</code>类可以有更多可以被对象<code class="fe lr ls lt lu b">thirdRoot</code>调用的方法。然而，<code class="fe lr ls lt lu b">nth_root</code>返回的是一个函数本身。所以这个方法比类能做的更有限。既然我们已经熟悉了闭包，我们可以看看它们的一些应用。</p><p id="aae6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">构图</strong></p><p id="9d0a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们有两个函数<em class="lq"> f </em>和<em class="lq"> g </em>，我们可以以这样的方式组合它们，使得<em class="lq"> f </em>的输出成为<em class="lq"> g </em>的输入。在数学上，这种运算叫做<em class="lq">合成</em>。因此合成操作采用两个函数<em class="lq"> f </em>和<em class="lq"> g </em>并产生一个函数<em class="lq"> h </em>，使得<em class="lq">h</em>(<em class="lq">x</em>)=<em class="lq">g</em>(<em class="lq">f</em>(<em class="lq">x</em>)。我们可以使用闭包轻松实现它:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="2493" class="lz ma it lu b gy mb mc l md me"># Listing 17</span><span id="1198" class="lz ma it lu b gy mf mc l md me">def compose(g, f):<br/>    def h(*args, **kwargs):<br/>        return g(f(*args, **kwargs))<br/>    return h</span></pre><p id="dd55" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里的<code class="fe lr ls lt lu b">h</code>是一个闭包，因为它捕获了非局部变量<code class="fe lr ls lt lu b">f</code>和<code class="fe lr ls lt lu b">g</code>。这些非局部变量本身就是函数。这个闭包返回的是<code class="fe lr ls lt lu b">f</code>和<code class="fe lr ls lt lu b">g</code>的组合，也就是<code class="fe lr ls lt lu b">g(f(*args, **kwargs))</code>。我们使用了<code class="fe lr ls lt lu b">*args</code>和<code class="fe lr ls lt lu b">**kwargs</code>来传递多个参数或关键字参数给<code class="fe lr ls lt lu b">h</code>，</p><p id="35d5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一个简单的应用程序。假设我们有一些转换单位的函数。例如，假设我们有两个函数，分别将<em class="lq">英寸</em>转换为<em class="lq">英尺</em>和<em class="lq">英尺</em>转换为<em class="lq">米</em>。现在我们可以使用我们的<code class="fe lr ls lt lu b">compose()</code>函数将它们合并成一个函数，将<em class="lq">英寸</em>转换成<em class="lq">米</em>:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="7cde" class="lz ma it lu b gy mb mc l md me"># Listing 18</span><span id="d249" class="lz ma it lu b gy mf mc l md me">inch_to_foot= lambda x: x/12<br/>foot_meter= lambda x: x * 0.3048</span><span id="81ee" class="lz ma it lu b gy mf mc l md me">inch_to_meter = compose(foot_meter, inch_to_foot)<br/>inch_to_meter(12)   # Output 0.3048</span></pre><p id="e174" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">局部应用</strong></p><p id="996e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在数学中，一个函数接受的参数数量被称为该函数的 arity。部分应用是减少函数的 arity 的操作。这意味着它允许你固定一些参数的值，并冻结它们来得到一个参数更少的函数。所以它在某种程度上简化了功能。</p><p id="4ac5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">比如<em class="lq"> f </em> ( <em class="lq"> x，y，z) </em>的 arity 是 3。<em class="lq"> </em>我们可以将自变量<em class="lq"> x </em>的值固定在<em class="lq"> a </em>处，得到<em class="lq"> f(x=a，y，z) = g(y，z) </em>。<em class="lq"> </em>现在<em class="lq"> g(y，z) </em>的 arity 为 2，是<em class="lq"> f(x，y，z) </em>部分应用的结果。所以偏(<em class="lq">f</em>)=&gt;T32】g。我们可以使用闭包来实现部分应用程序:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="fda6" class="lz ma it lu b gy mb mc l md me"># Listing 19</span><span id="a0b6" class="lz ma it lu b gy mf mc l md me">def partial(f, *f_args, **f_keywords):<br/>    def g(*args, **keywords):<br/>        new_keywords = f_keywords.copy()<br/>        new_keywords.update(keywords)<br/>        return f(*(f_args + args), **new_keywords)<br/>    return g</span></pre><p id="8d44" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里，外部函数接收需要修复的<code class="fe lr ls lt lu b">f</code>和<code class="fe lr ls lt lu b">f</code>的位置和关键字参数。内部函数<code class="fe lr ls lt lu b">g</code>将这些固定参数添加到<code class="fe lr ls lt lu b">f</code>的剩余参数中，稍后它将接收这些参数作为部分函数。最后，它用所有收集到的参数调用<code class="fe lr ls lt lu b">f</code>。清单 20 给出了一个使用部分函数的例子:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="fc68" class="lz ma it lu b gy mb mc l md me"># Listing 20</span><span id="6f80" class="lz ma it lu b gy mf mc l md me">func = lambda x,y,z: x**2 + 2*y + z</span><span id="3c7f" class="lz ma it lu b gy mf mc l md me">pfunc = partial(func, 1)<br/>pfunc(2, 3)  # Output is 8</span></pre><p id="8ef5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里我们将<code class="fe lr ls lt lu b">x</code>的值固定为 1，并将<code class="fe lr ls lt lu b">func</code>转换为<code class="fe lr ls lt lu b">pfunc</code>，现在它有两个参数<code class="fe lr ls lt lu b">y</code>和<code class="fe lr ls lt lu b">z</code>。</p><p id="34ac" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">阿谀奉承</strong></p><p id="9041" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在数学中，currying 意味着将一个具有多个参数的函数转换成一系列嵌套的一元函数。如前所述，一元函数是一个只有一个参数的函数。例如，如果我们有一个函数<em class="lq"> f(x，y，z) </em>。Currying 将其转换为<em class="lq">g(x)(y)(z)</em>=<em class="lq">((g(x))(y))(z)</em>。清单 21 展示了我们如何用 Python 实现它:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="0d5b" class="lz ma it lu b gy mb mc l md me"># Listing 21</span><span id="02f0" class="lz ma it lu b gy mf mc l md me">def curry(f):<br/>    argc = f.__code__.co_argcount<br/>    f_args = []<br/>    f_kwargs = {}<br/>    def g(*args, **kwargs):<br/>        nonlocal f_args, f_kwargs<br/>        f_args += args<br/>        f_kwargs.update(kwargs)<br/>        if len(f_args)+len(f_kwargs) == argc:<br/>            return f(*f_args, **f_kwargs)<br/>        else:<br/>            return g          <br/>    return g</span></pre><p id="48aa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们可以将它应用于清单 20 中定义的函数:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="0c90" class="lz ma it lu b gy mb mc l md me">cfunc = curry(func)<br/>cfunc(1)(2)</span><span id="decc" class="lz ma it lu b gy mf mc l md me"># Output:<br/># &lt;function __main__.curry.&lt;locals&gt;.g(*args, **kwargs)&gt;</span></pre><p id="7ec1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">和</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="55c9" class="lz ma it lu b gy mb mc l md me">cfunc(3)  # Output is 8</span></pre><p id="74a2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们再次使用了闭包。但是这个闭包<code class="fe lr ls lt lu b">g</code>是一个递归函数。图 5 显示了这个函数是如何工作的。首先，外部函数<code class="fe lr ls lt lu b">curry</code>接收<code class="fe lr ls lt lu b">f</code>作为参数。<code class="fe lr ls lt lu b">f</code>是应该进行 currying 的函数。我们使用<code class="fe lr ls lt lu b">co_argcount</code>属性获得<code class="fe lr ls lt lu b">f</code>接受的参数数量(即<code class="fe lr ls lt lu b">f</code>的 arity)并将其存储在<code class="fe lr ls lt lu b">argc</code>中。在本例中<code class="fe lr ls lt lu b">args</code> =3。我们有两个非局部变量<code class="fe lr ls lt lu b">f_args</code>和<code class="fe lr ls lt lu b">f_kwargs</code>，它们用于存储<code class="fe lr ls lt lu b">g</code>接受的参数。<code class="fe lr ls lt lu b">curry</code>返回闭包<code class="fe lr ls lt lu b">g</code>并将其分配给<code class="fe lr ls lt lu b">cfunc</code>。所以当我们调用<code class="fe lr ls lt lu b">cfunc(1)(2) </code>时，我们是在调用<code class="fe lr ls lt lu b">g(1)(2)</code>。首先将对<code class="fe lr ls lt lu b">g(1)</code>进行评估。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mo"><img src="../Images/da1ccd14de5a17425bda0a2fd4f00da7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yd1Pau6OUA9Yp3Vbn9O6Ag.jpeg"/></div></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">图 5</p></figure><p id="6b7f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lr ls lt lu b">g</code>将其参数添加到<code class="fe lr ls lt lu b">f_args</code>列表中，由于它没有捕获<code class="fe lr ls lt lu b">func</code>的所有参数，因此它递归地返回自身。所以<code class="fe lr ls lt lu b">g(1)</code>的结果是<code class="fe lr ls lt lu b">g</code>，<code class="fe lr ls lt lu b">g(1)(2)</code>变成了<code class="fe lr ls lt lu b">g(2)</code>。现在<code class="fe lr ls lt lu b">g(2)</code>评估。再次<code class="fe lr ls lt lu b">g</code>将其参数添加到<code class="fe lr ls lt lu b">f_args</code>列表中，并且<code class="fe lr ls lt lu b">f_args</code> =[1，2]。<code class="fe lr ls lt lu b">g</code>再次返回自身，但此时它没有要计算的参数。因此，<code class="fe lr ls lt lu b">cfunc(1)(2)</code>的最终输出是<code class="fe lr ls lt lu b">g</code>，在 Python 中显示为<code class="fe lr ls lt lu b">&lt;function __main__.curry.&lt;locals&gt;.g(*args, **kwargs)&gt;</code>。然后我们运行<code class="fe lr ls lt lu b">cfunc(3)</code>。这次对<code class="fe lr ls lt lu b">g(3)</code>求值，给<code class="fe lr ls lt lu b">f_args</code>加 3，就等于[1，2，3]。现在<code class="fe lr ls lt lu b">len(f_args)</code>等于<code class="fe lr ls lt lu b">argc</code>，已经捕获了<code class="fe lr ls lt lu b">func</code>的所有原始参数，所以最后<code class="fe lr ls lt lu b">func(1,2,3)</code>会被<code class="fe lr ls lt lu b">g</code>求值并返回。</p><p id="af74" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您应该知道清单 21 中的<code class="fe lr ls lt lu b">curry</code>函数不仅仅可以做数学运算。这个函数的输出并不局限于嵌套的一元函数，我们可以有更高 arity 的嵌套函数。例如，我们也可以写:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="0dd4" class="lz ma it lu b gy mb mc l md me">cfunc = curry(func)<br/>cfunc(1, 2)<br/>cfunc(3) # Output is 8</span></pre><p id="3d9e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">得到同样的结果。这就好比把<em class="lq"> f(x，y，z) </em>转换成<em class="lq"> g(x，y)(z) </em>。</p><h1 id="a899" class="mp ma it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated"><strong class="ak">装修和装饰工</strong></h1><p id="2b5f" class="pw-post-body-paragraph ku kv it kw b kx ng ju kz la nh jx lc ld ni lf lg lh nj lj lk ll nk ln lo lp im bi translated">在谈论 decorators 之前，我需要提一下 Python 中的函数。当您在 Python 中定义函数时，该函数的名称只是对函数体(函数定义)的引用。所以通过给它赋一个新值，你可以强制它引用另一个函数定义。清单 22 给出了一个简单的例子:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="c476" class="lz ma it lu b gy mb mc l md me"># Listing 22</span><span id="d8a7" class="lz ma it lu b gy mf mc l md me">def f():<br/>    return("f definition")<br/>def g():<br/>    return("g definition")</span><span id="fb85" class="lz ma it lu b gy mf mc l md me">print("f is referring to ", f())<br/>print("g is referring to ", g())</span><span id="075b" class="lz ma it lu b gy mf mc l md me">print("Swapping f and g")<br/>temp = f<br/>f = g<br/>g = temp</span><span id="3998" class="lz ma it lu b gy mf mc l md me">print("f is referring to ", f())<br/>print("g is referring to ", g())</span></pre><p id="0b65" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">输出:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="40b0" class="lz ma it lu b gy mb mc l md me">f is referring to  f definition<br/>g is referring to  g definition<br/>Swapping f and g<br/>f is referring to  g definition<br/>g is referring to  f definition</span></pre><p id="9d5c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">到目前为止，我们已经通过将外部函数的结果赋给一个新变量创建了一个闭包:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="e691" class="lz ma it lu b gy mb mc l md me">h=f(a)</span></pre><p id="76c8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在假设我们有一个名为<code class="fe lr ls lt lu b">deco(f)</code>的外部函数，它在清单 23 中定义:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="097d" class="lz ma it lu b gy mb mc l md me"># Listing 23</span><span id="0676" class="lz ma it lu b gy mf mc l md me">def deco(f):<br/>    def g(*args, **kwargs):<br/>        return f(*args, **kwargs)<br/>    return g</span><span id="2ee6" class="lz ma it lu b gy mf mc l md me">def func(x):<br/>     return 2*x</span><span id="a55a" class="lz ma it lu b gy mf mc l md me">func = deco(func)<br/>func(2)  # Output is 4</span></pre><p id="743d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里，外部函数是<code class="fe lr ls lt lu b">deco(f)</code>，它将函数<code class="fe lr ls lt lu b">f</code>作为参数，内部函数<code class="fe lr ls lt lu b">g</code>被定义为闭包。我们定义另一个函数<code class="fe lr ls lt lu b">func</code>并对其应用<code class="fe lr ls lt lu b">deco</code>。但是为了初始化闭包，我们将<code class="fe lr ls lt lu b">deco</code>的结果赋给<code class="fe lr ls lt lu b">func</code>。所以<code class="fe lr ls lt lu b">deco</code>将<code class="fe lr ls lt lu b">func</code>作为参数，并再次将其闭包赋给<code class="fe lr ls lt lu b">func</code>。在这种情况下，我们说<code class="fe lr ls lt lu b">func</code>是由<em class="lq"> </em> <code class="fe lr ls lt lu b">deco</code>修饰，<code class="fe lr ls lt lu b">deco</code>是<em class="lq">的修饰者</em>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/9f348fe066901e85ed6112a283ba1120.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bCL9EtwhR9IXndx2Q3iTxA.jpeg"/></div></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">图 6</p></figure><p id="4560" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">需要注意的是，在将装饰器的结果赋给<code class="fe lr ls lt lu b">func</code>之后，<code class="fe lr ls lt lu b">func</code>指的是闭包<code class="fe lr ls lt lu b">g</code>。所以叫<code class="fe lr ls lt lu b">func(a)</code>就像叫<code class="fe lr ls lt lu b">g(a)</code>。如果我们写:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="3e34" class="lz ma it lu b gy mb mc l md me">func.__name__</span></pre><p id="502e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">输出将是<code class="fe lr ls lt lu b">'g'</code>。实际上，变量<code class="fe lr ls lt lu b">func</code>只是对函数定义的引用。最初指<code class="fe lr ls lt lu b">func(x)</code>定义，装修后指<code class="fe lr ls lt lu b">g(*args, **kwargs)</code>。</p><p id="f00b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是对于原始函数<code class="fe lr ls lt lu b">func(x)</code>会发生什么呢？我们会失去它吗？记住装饰器接收<code class="fe lr ls lt lu b">func</code>作为它的参数。所以它有一个引用<code class="fe lr ls lt lu b">func</code>的副本作为它的局部变量<code class="fe lr ls lt lu b">f</code>。如果原引用发生变化，并不影响这个局部变量，所以在<code class="fe lr ls lt lu b">g</code>内部，<code class="fe lr ls lt lu b">f</code>仍然引用<code class="fe lr ls lt lu b">func(x)</code>定义(我说的函数定义，是指如图 7 所示的函数<code class="fe lr ls lt lu b">func(x)</code>的实际体)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/f816a814cd5a01bea818a98305fa6a32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wql7OYmp7rTrt-yaO35MKQ.jpeg"/></div></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">图 7</p></figure><p id="c603" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以总结一下，修饰后变量<code class="fe lr ls lt lu b">func</code>指闭包<code class="fe lr ls lt lu b">g</code>，内部<code class="fe lr ls lt lu b">g</code>，<code class="fe lr ls lt lu b">f</code>指<code class="fe lr ls lt lu b">func(x)</code>定义。事实上，<code class="fe lr ls lt lu b">g</code>现在充当了被修饰的原始函数<code class="fe lr ls lt lu b">func(x)</code>的接口。我们不能在<code class="fe lr ls lt lu b">g</code>之外直接调用<code class="fe lr ls lt lu b">func(x)</code>。而是先调用<code class="fe lr ls lt lu b">func</code>调用<code class="fe lr ls lt lu b">g</code>，然后在<code class="fe lr ls lt lu b">g</code>内部可以调用<code class="fe lr ls lt lu b">f</code>调用原函数<code class="fe lr ls lt lu b">func(x)</code>。所以我们使用闭包<code class="fe lr ls lt lu b">g</code>调用原始函数<code class="fe lr ls lt lu b">func(x)</code>。</p><p id="acd8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在使用这个闭包，我们可以添加更多的代码在调用<code class="fe lr ls lt lu b">func(x)</code>之前或之后运行。我举个简单的例子。假设我们想调试清单 23 中的代码。我们想知道<code class="fe lr ls lt lu b">func(x)</code>是什么时候被调用的。我们可以简单地在<code class="fe lr ls lt lu b">func(x)</code>中放置一个打印语句，让我们知道它何时运行:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="a8db" class="lz ma it lu b gy mb mc l md me">def func(x):<br/>    print("func is called") <br/>    return 2*x</span></pre><p id="e3b2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是它改变了功能，我们必须记得稍后删除它。更好的解决方案是定义一个装饰器来包装函数，并将 print 语句添加到闭包中。</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="6a02" class="lz ma it lu b gy mb mc l md me"># Listing 24</span><span id="12d4" class="lz ma it lu b gy mf mc l md me">def deco(f):<br/>    def g(*args, **kwargs):<br/>        print("Calling ", f.__name__)<br/>        return f(*args, **kwargs)<br/>    return g</span><span id="6576" class="lz ma it lu b gy mf mc l md me">def func(x):<br/>    return 2*x</span><span id="0c68" class="lz ma it lu b gy mf mc l md me">func = deco(func)<br/>func(2)  </span></pre><p id="88cd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">输出是:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="905e" class="lz ma it lu b gy mb mc l md me">Calling  func<br/>4</span></pre><p id="493c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个例子显示了装饰器有多有用。现在我们可以看到亵渎的更多应用:</p><p id="e997" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">记忆</strong></p><p id="4b25" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">内存优化是一种用来加速程序的编程技术。它源自拉丁语<em class="lq">备忘录</em>，意思是“被记住”。顾名思义，它是基于记忆或缓存昂贵的函数调用的结果。如果使用相同的输入或具有相同参数的函数调用，则之前缓存的结果将用于避免不必要的计算。在 Python 中，我们可以使用闭包和装饰器自动记忆函数。</p><p id="490c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">清单 25 展示了一个计算斐波那契数列的函数。斐波那契数列是递归定义的。每个数字都是前面两个数字的和，从 0 和 1 开始:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="0fba" class="lz ma it lu b gy mb mc l md me"># Listing 25</span><span id="c316" class="lz ma it lu b gy mf mc l md me">def fib(n):<br/>    if n == 0:<br/>        return 0<br/>    elif n == 1:<br/>        return 1<br/>    else:<br/>        return fib(n-1) + fib(n-2)<br/>for i in range(6):<br/>    print(fib(i), end=" ")</span><span id="0ff1" class="lz ma it lu b gy mf mc l md me"># Output<br/># 0 1 1 2 3 5</span></pre><p id="5166" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们定义一个新函数，它可以记忆另一个函数:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="92b8" class="lz ma it lu b gy mb mc l md me"># Listing 26</span><span id="f8e6" class="lz ma it lu b gy mf mc l md me">def memoize(f):<br/>    memo = {}<br/>    def memoized_func(n):<br/>        if n not in memo:            <br/>            memo[n] = f(n)<br/>        return memo[n]<br/>    return memoized_func</span></pre><p id="5639" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要使用<code class="fe lr ls lt lu b">memoize</code>函数，我们可以将其用作<code class="fe lr ls lt lu b">fib</code>的装饰器:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="ccd7" class="lz ma it lu b gy mb mc l md me">fib = memoize(fib)<br/>fib(30) # Output is 832040</span></pre><p id="aeff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以功能<code class="fe lr ls lt lu b">fib</code>现在由<code class="fe lr ls lt lu b">memoize()</code>修饰。现在<code class="fe lr ls lt lu b">fib</code>指的是关闭<code class="fe lr ls lt lu b">memoized_func</code>，所以当我们叫<code class="fe lr ls lt lu b">fib(30)</code>的时候，就像叫<code class="fe lr ls lt lu b">memoized_func(30)</code>。装饰器接收原始的<code class="fe lr ls lt lu b">fib</code>作为它的参数<code class="fe lr ls lt lu b">f</code>，所以<code class="fe lr ls lt lu b">f</code>引用<code class="fe lr ls lt lu b">memoized_func</code>中的<code class="fe lr ls lt lu b">fib(n)</code>定义。闭包<code class="fe lr ls lt lu b">memoized_func</code>首先检查<code class="fe lr ls lt lu b">n</code>是否在备忘录字典中。如果在里面，就简单的返回<code class="fe lr ls lt lu b">memo[n]</code>，不调用原来的<code class="fe lr ls lt lu b">fib(n)</code>。如果<code class="fe lr ls lt lu b">n</code>不在 memo 字典中，它首先调用引用原始<code class="fe lr ls lt lu b">fib(n).</code>的<code class="fe lr ls lt lu b">f(n)</code>,然后将结果存储在<code class="fe lr ls lt lu b">memo</code>字典中，最后将其作为最终结果返回。</p><p id="7166" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">追踪递归函数</strong></p><p id="bb39" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">假设我们想调试清单 25 中定义的递归 Fibonacci 函数。我们想看看这个函数是如何调用自己来计算最终结果的。我们可以定义一个装饰器来跟踪函数调用:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="75a9" class="lz ma it lu b gy mb mc l md me"># Listing 27</span><span id="923f" class="lz ma it lu b gy mf mc l md me">def trace(f):<br/>    level = 1<br/>    def helper(*arg):<br/>        nonlocal level<br/>        print((level-1)*"  │",  "  ┌",  f.__name__,<br/>              "(", ",".join(map(str, arg)), ")", sep="")<br/>        level += 1<br/>        result = f(*arg)<br/>        level -= 1<br/>        print((level-1)*"  │", "  └",  result, sep="")<br/>        return result<br/>    return helper</span></pre><p id="2f64" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们可以写:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="0610" class="lz ma it lu b gy mb mc l md me">def fib(n):<br/>    if n == 0:<br/>        return 0<br/>    elif n == 1:<br/>        return 1<br/>    else:<br/>        return fib(n-1) + fib(n-2)<br/>fib = trace(fib)<br/>fib(4)</span></pre><p id="eeed" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">输出是:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="dd2f" class="lz ma it lu b gy mb mc l md me">  ┌fib(4)<br/>  │  ┌fib(3)<br/>  │  │  ┌fib(2)<br/>  │  │  │  ┌fib(1)<br/>  │  │  │  └1<br/>  │  │  │  ┌fib(0)<br/>  │  │  │  └0<br/>  │  │  └1<br/>  │  │  ┌fib(1)<br/>  │  │  └1<br/>  │  └2<br/>  │  ┌fib(2)<br/>  │  │  ┌fib(1)<br/>  │  │  └1<br/>  │  │  ┌fib(0)<br/>  │  │  └0<br/>  │  └1<br/>  └3</span><span id="96dd" class="lz ma it lu b gy mf mc l md me">3</span></pre><p id="4389" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">装饰函数<code class="fe lr ls lt lu b">trace</code>接收<code class="fe lr ls lt lu b">fib</code>作为它的参数。在调用装饰者之后，<code class="fe lr ls lt lu b">fib</code>指的是关闭<code class="fe lr ls lt lu b">helper</code>。<code class="fe lr ls lt lu b">trace</code>有一个名为<code class="fe lr ls lt lu b">level</code>的非局部变量，显示递归深度，初始设置为 1。<code class="fe lr ls lt lu b">helper</code>首先打印一些填充字符，包括<code class="fe lr ls lt lu b">│</code>、<code class="fe lr ls lt lu b">┌</code>，并显示递归树结构。<code class="fe lr ls lt lu b">│</code>字符的数量与<code class="fe lr ls lt lu b">level</code>的数值成正比。</p><p id="c7d8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">随着递归深度的增加，更多的<code class="fe lr ls lt lu b">│</code>被打印。对于第一次调用，因为<code class="fe lr ls lt lu b">level-1</code>等于零，所以<code class="fe lr ls lt lu b">|</code>不打印。然后打印函数名及其参数的当前值。之后<code class="fe lr ls lt lu b">level</code>加 1 以显示下一级递归。然后评估函数<code class="fe lr ls lt lu b">f</code>(指传递给装饰器的原始函数)。因此对<code class="fe lr ls lt lu b">fib(n)</code>定义进行评估。由于<code class="fe lr ls lt lu b">fib</code>是递归定义的，它会在某个时候调用自己。记住装修后 fib 指的是封闭<code class="fe lr ls lt lu b">helper</code>。所以递归调用会再次调用<code class="fe lr ls lt lu b">helper</code>，下一级递归会被打印出来。</p><p id="163c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">递归继续，直到我们到达递归基本情况，并且函数定义<code class="fe lr ls lt lu b">fib(n)</code>返回 1。然后<code class="fe lr ls lt lu b">level</code>减一，将返回的结果与返回它的函数名联系起来。返回值被一个接一个地打印出来，直到我们回到第一个调用。</p><p id="777e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">句法糖</strong></p><p id="6f24" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">语法糖是编程语言中的语法，它使事情更容易阅读或表达。使用语法糖，你可以更清楚或更简洁地编写代码。例如，在 Python 中，<code class="fe lr ls lt lu b">+=</code>操作符是语法糖。所以不用写<code class="fe lr ls lt lu b">a=a+1</code>，你可以简单地写<code class="fe lr ls lt lu b">a+=1</code>。</p><p id="1544" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在清单 24 中，我们编写了<code class="fe lr ls lt lu b">func = deco(func)</code>来修饰函数<code class="fe lr ls lt lu b">func</code>。实际上，我们可以用更简单的方法来做，最终结果是一样的:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="8fad" class="lz ma it lu b gy mb mc l md me"># Listing 28</span><span id="104a" class="lz ma it lu b gy mf mc l md me">def deco(f):<br/>    def g(*args, **kwargs):<br/>        print("Calling ", f.__name__)<br/>        return f(*args, **kwargs)<br/>    return g</span><span id="2e10" class="lz ma it lu b gy mf mc l md me">@deco<br/>def func(x):<br/>    return 2*x</span><span id="139d" class="lz ma it lu b gy mf mc l md me">func(2)</span></pre><p id="aa64" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里我们简单地在应该由<code class="fe lr ls lt lu b">deco(f)</code>修饰的函数上写<code class="fe lr ls lt lu b">@deco</code>，而不是写<code class="fe lr ls lt lu b">func = deco(func)</code>。这是修饰函数的语法糖，有时被称为<em class="lq">派</em>派<em class="lq">语法</em>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/5ddf8496b9586eb23b49ea3d8c6ad34e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RUws6WJNez6Mmp9PEkVavQ.jpeg"/></div></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">图 8</p></figure><p id="3942" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">关于这个语法的一些注意事项。<code class="fe lr ls lt lu b">@deco</code>不能在其他地方，并且在<code class="fe lr ls lt lu b">@deco</code>和<code class="fe lr ls lt lu b">func(x)</code>的定义之间不允许有更多的语句。你不应该在<code class="fe lr ls lt lu b">@deco</code>后面写<code class="fe lr ls lt lu b">deco</code>的参数。语法假设<code class="fe lr ls lt lu b">deco</code>只接受一个参数，这个参数是应该被修饰的函数。稍后我会解释如果装饰函数有更多的参数该怎么做。</p><p id="dab0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在清单 24 中，一旦编写了<code class="fe lr ls lt lu b">func = deco(func)</code>，装饰就开始了。但是在清单 28 中什么时候会发生呢？用 pie 语法定义的 decorators 的一个关键特性是它们在被修饰的函数被定义后立即运行。这通常是在 Python 加载模块时的导入时间。</p><p id="d269" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">堆叠装饰者</strong></p><p id="0a47" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在清单 29 中，我们定义了两个装饰器:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="b7a1" class="lz ma it lu b gy mb mc l md me"># Listing 29</span><span id="fd36" class="lz ma it lu b gy mf mc l md me">def deco1(f):<br/>    def g1(*args, **kwargs):<br/>        print("Calling ", f.__name__, "using deco1")<br/>        return f(*args, **kwargs)<br/>    return g1</span><span id="fe7f" class="lz ma it lu b gy mf mc l md me">def deco2(f):<br/>    def g2(*args, **kwargs):<br/>        print("Calling ", f.__name__, "using deco2")<br/>        return f(*args, **kwargs)<br/>    return g2</span><span id="ce21" class="lz ma it lu b gy mf mc l md me">def func(x):<br/>    return 2*x</span><span id="4ebb" class="lz ma it lu b gy mf mc l md me">func = deco2(deco1(func))<br/>func(2)</span></pre><p id="88c7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里我们首先将<code class="fe lr ls lt lu b">deco1</code>应用于<code class="fe lr ls lt lu b">func</code>，然后将<code class="fe lr ls lt lu b">deco2</code>应用于<code class="fe lr ls lt lu b">deco1</code>返回的闭包。所以我们有两个堆叠的装饰者。我们先用<code class="fe lr ls lt lu b">deco1</code>装饰<code class="fe lr ls lt lu b">func</code>，再用<code class="fe lr ls lt lu b">deco2</code>装饰。输出是:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="8618" class="lz ma it lu b gy mb mc l md me">Calling  g1 using deco2<br/>Calling  func using deco1<br/>4</span></pre><p id="e11c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">事实上<code class="fe lr ls lt lu b">g2</code>和<code class="fe lr ls lt lu b">g1</code>现在充当被修饰的原始函数<code class="fe lr ls lt lu b">func(x)</code>的接口。为了达到最初的功能<code class="fe lr ls lt lu b">func(x)</code>，我们首先调用<code class="fe lr ls lt lu b">func</code>，它指的是<code class="fe lr ls lt lu b">g2</code>。在<code class="fe lr ls lt lu b">g2</code>内部，参数<code class="fe lr ls lt lu b">f</code>指的是<code class="fe lr ls lt lu b">g1</code>。所以通过调用<code class="fe lr ls lt lu b">f</code>，我们在调用<code class="fe lr ls lt lu b">g1</code>，然后在<code class="fe lr ls lt lu b">g1</code>内部我们可以调用<code class="fe lr ls lt lu b">f</code>来调用原来的函数<code class="fe lr ls lt lu b">func(x)</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/435e8dc16a080a5bfc45b165813663ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dS0BlV9uexW8oKfmxOM_zw.jpeg"/></div></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">图 9</p></figure><p id="c841" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还可以使用 pie 语法将堆栈装饰器应用到函数中。为此，我们可以写:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="1780" class="lz ma it lu b gy mb mc l md me"># Listing 30</span><span id="9c4a" class="lz ma it lu b gy mf mc l md me">def deco1(f):<br/>    def g1(*args, **kwargs):<br/>        print("Calling ", f.__name__, "using deco1")<br/>        return f(*args, **kwargs)<br/>    return g1</span><span id="1639" class="lz ma it lu b gy mf mc l md me">def deco2(f):<br/>    def g2(*args, **kwargs):<br/>        print("Calling ", f.__name__, "using deco2")<br/>        return f(*args, **kwargs)<br/>    return g2</span><span id="2ed3" class="lz ma it lu b gy mf mc l md me">@deco2<br/>@deco1<br/>def func(x):<br/>    return 2*x</span><span id="be11" class="lz ma it lu b gy mf mc l md me">func(2)</span></pre><p id="2626" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这里，装饰者按照包装函数的顺序堆叠在函数定义的顶部。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/0935a5b59d4568810f198a857e31db7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IdDXXpVOnM1wtoHgjRFX2Q.jpeg"/></div></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">图 10</p></figure><p id="ddc1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还可以使用清单 17 中引入的函数<code class="fe lr ls lt lu b">compose</code>来组合这两个装饰器，然后将它们应用到目标函数。合成操作可以采用两个函数<code class="fe lr ls lt lu b">deco1(f)</code>和<code class="fe lr ls lt lu b">deco2(f)</code>，并产生一个函数<code class="fe lr ls lt lu b">deco</code>，使得<code class="fe lr ls lt lu b">deco(f) = deco2(deco1(f))</code>。这如清单 31 所示。</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="b0ec" class="lz ma it lu b gy mb mc l md me"># Listing 31</span><span id="da9c" class="lz ma it lu b gy mf mc l md me">def deco1(f):<br/>    def g1(*args, **kwargs):<br/>        print("Calling ", f.__name__, "using deco1")<br/>        return f(*args, **kwargs)<br/>    return g1<br/>def deco2(f):<br/>    def g2(*args, **kwargs):<br/>        print("Calling ", f.__name__, "using deco2")<br/>        return f(*args, **kwargs)<br/>    return g2</span><span id="3642" class="lz ma it lu b gy mf mc l md me">deco = compose(deco2, deco1) <br/>@deco<br/>def func(x):<br/>    return 2*x<br/>func(2)</span></pre><p id="f937" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们可以看到一个堆叠装饰器的例子。记得我们为记忆定义了一个装饰器。我们还定义了一个装饰器来跟踪递归函数。现在我们可以把它们结合起来，用记忆来追踪一个递归函数。我们首先用清单 26 中给出的<code class="fe lr ls lt lu b">memoize</code>装饰器装饰 Fibonacci 函数，然后用清单 27 中给出的<code class="fe lr ls lt lu b">trace</code>装饰器。我们先试着算一下<code class="fe lr ls lt lu b">fib(5)</code>。</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="7a2f" class="lz ma it lu b gy mb mc l md me"># Listing 32</span><span id="b11d" class="lz ma it lu b gy mf mc l md me">@trace<br/>@memoize<br/>def fib(n):<br/>    if n == 0:<br/>        return 0<br/>    elif n == 1:<br/>        return 1<br/>    else:<br/>        return fib(n-1) + fib(n-2)</span><span id="4a00" class="lz ma it lu b gy mf mc l md me">fib(5)</span></pre><p id="e6bf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">输出是:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="8cee" class="lz ma it lu b gy mb mc l md me">  ┌memoized_func(5)<br/>  │  ┌memoized_func(4)<br/>  │  │  ┌memoized_func(3)<br/>  │  │  │  ┌memoized_func(2)<br/>  │  │  │  │  ┌memoized_func(1)<br/>  │  │  │  │  └1<br/>  │  │  │  │  ┌memoized_func(0)<br/>  │  │  │  │  └0<br/>  │  │  │  └1<br/>  │  │  │  ┌memoized_func(1)<br/>  │  │  │  └1<br/>  │  │  └2<br/>  │  │  ┌memoized_func(2)<br/>  │  │  └1<br/>  │  └3<br/>  │  ┌memoized_func(3)<br/>  │  └2<br/>  └5</span><span id="1752" class="lz ma it lu b gy mf mc l md me">5</span></pre><p id="5e44" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于 memo 字典最初是空的，它将执行所有的递归调用来计算结果。现在，如果我们尝试<code class="fe lr ls lt lu b">fib(6)</code>，我们会得到:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="e1b9" class="lz ma it lu b gy mb mc l md me">  ┌memoized_func(6)<br/>  │  ┌memoized_func(5)<br/>  │  └5<br/>  │  ┌memoized_func(4)<br/>  │  └3<br/>  └8<br/>8</span></pre><p id="2e7f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这次<code class="fe lr ls lt lu b">fib(5)</code>和<code class="fe lr ls lt lu b">fib(4)</code>的结果已经存储在<code class="fe lr ls lt lu b">memo</code>字典中。所以它只需要检索它们来计算结果，不需要更多的递归。你可能已经注意到了，函数<code class="fe lr ls lt lu b">fib</code>的名字没有打印在递归树中。相反，我们看到了闭包的名字<code class="fe lr ls lt lu b">memoized_func</code>。原因是我们有两个堆叠的装饰器，并且<code class="fe lr ls lt lu b">trace</code>装饰器接收<code class="fe lr ls lt lu b">memoized_func</code>作为它的参数，而不是函数<code class="fe lr ls lt lu b">fib</code>。所以在<code class="fe lr ls lt lu b">trace</code>里面现在<code class="fe lr ls lt lu b">f</code>是指<code class="fe lr ls lt lu b">memoized_func</code>，<code class="fe lr ls lt lu b">f.__name__</code>返回<code class="fe lr ls lt lu b">memoized_func</code>。在下一节中，我将向您展示我们如何解决这个问题。</p><p id="9989" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">装饰者附加参数</strong></p><p id="54bc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">到目前为止，我们讨论的装饰器只接受一个参数，即被装饰的函数，然而，我们可以有额外的参数。还记得我们在清单 24 中看到的装饰器吗？它在调用之前打印一条消息，加上被修饰函数的名称。现在我们想创建一个装饰器，它将消息作为一个附加参数。事实上，我们希望向装饰器传递两个额外的参数。一个是在调用修饰函数之前将被打印的消息，另一个是在调用它之后将被打印的消息。</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="9125" class="lz ma it lu b gy mb mc l md me"># Listing 33</span><span id="67b1" class="lz ma it lu b gy mf mc l md me">def deco(msg_before, msg_after):<br/>    def original_deco(f):<br/>        def g(*args, **kwargs):<br/>            print(msg_before + " " + f.__name__)<br/>            result =  f(*args, **kwargs)<br/>            print(msg_after + " " + f.__name__)<br/>            return result<br/>        return g<br/>    return original_deco<br/>def func(x):<br/>    return 2*x<br/>func = deco("Starting", "Finished")(func)<br/>func(2)</span></pre><p id="eb59" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">输出是:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="61f8" class="lz ma it lu b gy mb mc l md me">Starting func<br/>Finished func<br/>4</span></pre><p id="e268" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如您所看到的，要将附加参数传递给装饰器，我们需要用另一个接受这些附加参数的函数来包装原来的装饰器函数。现在，这个函数将是装饰器，而最初的装饰器将是它内部的一个嵌套闭包。为了调用装饰器，我们需要首先将附加参数传递给<code class="fe lr ls lt lu b">deco</code>，然后被装饰的函数<code class="fe lr ls lt lu b">f</code>将被传递给它返回的闭包(这是最初的装饰器)。我们还可以使用清单 34 和图 11 所示的饼图语法。</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="eb78" class="lz ma it lu b gy mb mc l md me"># Listing 34</span><span id="fde7" class="lz ma it lu b gy mf mc l md me">def deco(msg_before, msg_after):<br/>    def original_deco(f):<br/>        def g(*args, **kwargs):<br/>            print(msg_before + " " + f.__name__)<br/>            result =  f(*args, **kwargs)<br/>            print(msg_after + " " + f.__name__)<br/>            return result<br/>        return g<br/>    return original_deco</span><span id="9253" class="lz ma it lu b gy mf mc l md me">@deco("Starting", "Finished")<br/>def func(x):<br/>    return 2*x</span><span id="6635" class="lz ma it lu b gy mf mc l md me">func(2)</span></pre><p id="83e2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后我们只需要将附加参数传递给<code class="fe lr ls lt lu b">@deco</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/71410547e5cdf2e62427405f0649ac67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6cjS_0GQcEF7LrKG-Xy_gw.jpeg"/></div></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">图 11</p></figure><p id="1c0f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可能会问为什么我们不能把额外的参数传递给最初的装饰者？实际上我们可以:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="e540" class="lz ma it lu b gy mb mc l md me"># Listing 35</span><span id="c840" class="lz ma it lu b gy mf mc l md me">def deco(msg_before, msg_after, f):<br/>    def g(*args, **kwargs):<br/>        print(msg_before + " " + f.__name__)<br/>        result =  f(*args, **kwargs)<br/>        print(msg_after + " " + f.__name__)<br/>        return result<br/>    return g<br/>    <br/>def func(x):<br/>    return 2*x<br/>func = deco("Starting", "Finished", func)<br/>func(2)<br/>sds</span></pre><p id="f384" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里我们简单地传递附加参数和函数名。问题是如果你这样定义，你就不能使用 pie 语法。所以如果你写:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="7c16" class="lz ma it lu b gy mb mc l md me"># This does not work:<br/>@deco("Starting", "Finished")<br/>def func(x):<br/>    return 2*x<br/>#func = deco("Starting", "Finished")<br/>func(2)</span></pre><p id="1269" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Python 给出一个错误。也可以使用我们在清单 21 中定义的函数<code class="fe lr ls lt lu b">curry</code>来简化装饰函数。<code class="fe lr ls lt lu b">curry</code>函数将另一个函数作为它的参数，并返回一个闭包，因此它可以用来装饰我们的装饰器。所以我们可以用下面的代码替换清单 34:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="0f8c" class="lz ma it lu b gy mb mc l md me"># Listing 36</span><span id="27f3" class="lz ma it lu b gy mf mc l md me">@curry<br/>def deco(msg_before, msg_after, f):<br/>    def g(*args, **kwargs):<br/>        print(msg_before + " " + f.__name__)<br/>        result =  f(*args, **kwargs)<br/>        print(msg_after + " " + f.__name__)<br/>        return result<br/>    return g<br/>    <br/>@deco("Starting", "Finished")<br/>def func(x):<br/>    return 2*x</span><span id="a9e6" class="lz ma it lu b gy mf mc l md me">func(2)</span></pre><p id="a71a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">运行函数<code class="fe lr ls lt lu b">deco</code>后，可以单独获取其参数。因此，通过编写<code class="fe lr ls lt lu b">@deco(“Starting”, “Finished”)</code>，我们提供了<code class="fe lr ls lt lu b">deco</code>的前两个参数，现在它只需要一个参数，即修饰函数。所以我们可以使用 pie 语法，我们不需要定义另一个函数来获取额外的参数。</p><p id="647c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们现在可以回到上一节中的问题。我们希望在修饰后保留被修饰函数的签名。我们可以为此定义一个新的装饰器:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="9b85" class="lz ma it lu b gy mb mc l md me"># Listing 37</span><span id="f3d2" class="lz ma it lu b gy mf mc l md me">def wraps(f):<br/>    def decorator(g):<br/>        def helper(*args, **kwargs):<br/>            return g(*args, **kwargs)<br/>        attributes = ('__module__', '__name__', '__qualname__',<br/>                      '__doc__', '__annotations__')         <br/>        for attr in attributes:<br/>            try:<br/>                value = getattr(f, attr)<br/>            except AttributeError:<br/>                pass<br/>            else:<br/>                setattr(helper, attr, value)<br/>        return helper<br/>    return decorator</span></pre><p id="671c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了理解这个装饰器，假设我们有一个名为<code class="fe lr ls lt lu b">f</code>的函数，我们想用另一个函数<code class="fe lr ls lt lu b">g</code>来装饰它。但是我们也希望<code class="fe lr ls lt lu b">g</code>(也就是<code class="fe lr ls lt lu b">helper</code>)返回的闭包有<code class="fe lr ls lt lu b">f</code>的相同签名，这样我们可以在装修后保留<code class="fe lr ls lt lu b">f</code>的签名。<code class="fe lr ls lt lu b">wraps</code>是一个装饰器，它接收<code class="fe lr ls lt lu b">f</code>作为附加参数，并装饰传递给其嵌套闭包<code class="fe lr ls lt lu b">decorate</code>的函数<code class="fe lr ls lt lu b">g</code>。然后，它使用<code class="fe lr ls lt lu b">getattr()</code>获取<code class="fe lr ls lt lu b">f</code>的所有属性，并将它们分配给闭包<code class="fe lr ls lt lu b">helper</code>，闭包最终作为修饰的结果返回。现在<code class="fe lr ls lt lu b">helper</code>有了<code class="fe lr ls lt lu b">f</code>的签名。</p><p id="8e9c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将这个装饰器添加到清单 26 中定义的 memoize 函数中。这里<code class="fe lr ls lt lu b">wraps</code>保存了应该被记忆的函数<code class="fe lr ls lt lu b">f</code>的签名。</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="4d07" class="lz ma it lu b gy mb mc l md me"># Listing 38</span><span id="0142" class="lz ma it lu b gy mf mc l md me">def memoize(f):<br/>    memo = {}<br/>    @wraps(f)<br/>    def memoized_func(n):<br/>        if n not in memo:            <br/>            memo[n] = f(n)<br/>        return memo[n]<br/>    return memoized_func</span></pre><p id="6a29" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">功能<code class="fe lr ls lt lu b">trace</code>保持不变，我们可以和<code class="fe lr ls lt lu b">memoize</code>一起使用来正确跟踪<code class="fe lr ls lt lu b">fib</code>:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="eed2" class="lz ma it lu b gy mb mc l md me"># Listing 39</span><span id="bee9" class="lz ma it lu b gy mf mc l md me">@trace<br/>@memoize<br/>def fib(n):<br/>    if n == 0:<br/>        return 0<br/>    elif n == 1:<br/>        return 1<br/>    else:<br/>        return fib(n-1) + fib(n-2)</span><span id="193e" class="lz ma it lu b gy mf mc l md me">fib(5)</span></pre><p id="3f54" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在输出显示了正确的函数名:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="4f37" class="lz ma it lu b gy mb mc l md me">  ┌fib(5)<br/>  │  ┌fib(4)<br/>  │  │  ┌fib(3)<br/>  │  │  │  ┌fib(2)<br/>  │  │  │  │  ┌fib(1)<br/>  │  │  │  │  └1<br/>  │  │  │  │  ┌fib(0)<br/>  │  │  │  │  └0<br/>  │  │  │  └1<br/>  │  │  │  ┌fib(1)<br/>  │  │  │  └1<br/>  │  │  └2<br/>  │  │  ┌fib(2)<br/>  │  │  └1<br/>  │  └3<br/>  │  ┌fib(3)<br/>  │  └2<br/>  └5</span><span id="ade3" class="lz ma it lu b gy mf mc l md me">5</span></pre><p id="3958" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以通过评估<code class="fe lr ls lt lu b">fib(6)</code>来检查记忆。输出是:</p><pre class="kj kk kl km gt lv lu lw lx aw ly bi"><span id="6c42" class="lz ma it lu b gy mb mc l md me">  ┌fib(6)<br/>  │  ┌fib(5)<br/>  │  └5<br/>  │  ┌fib(4)<br/>  │  └3<br/>  └8<br/>8</span></pre><p id="fda7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个例子展示了不同类型的装饰器如何组合在一起产生期望的输出。</p><p id="cc14" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">装饰器是 Python 中元编程的有用工具。元编程是关于创建以操作代码为主要目标的函数。本文中的例子展示了如何通过用不同的装饰器包装它们来改变函数的行为。我希望你喜欢阅读这篇文章。如果您有任何问题或建议，请告诉我。本文中的所有代码清单都可以作为 Jupyter 笔记本从 GitHub 下载，网址是:【https://github.com/reza-bagheri/Closures-and-decorators T21】</p></div></div>    
</body>
</html>