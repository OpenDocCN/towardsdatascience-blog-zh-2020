<html>
<head>
<title>Kubernetes HPA with Custom Metrics from Prometheus</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes HPA 采用来自 Prometheus 的定制指标</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/kubernetes-hpa-with-custom-metrics-from-prometheus-9ffc201991e?source=collection_archive---------1-----------------------#2020-06-26">https://towardsdatascience.com/kubernetes-hpa-with-custom-metrics-from-prometheus-9ffc201991e?source=collection_archive---------1-----------------------#2020-06-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e70a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">当需要基于自定义指标的 K8s pod 自动扩展时，可以使用一个有用的示例和分步指南。</h2></div><p id="2c40" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我决定编写这些步骤，因为我最近参与了将一个复杂的应用程序从 AWS 迁移到 GCP 的工作，与其他此类系统一样，我们不能仅仅依靠 CPU 或内存使用指标来满足它们的 SLA。</p><p id="f467" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自动扩展是一种根据资源使用情况自动扩大或缩小工作负载的方法。K8s <strong class="kh ir">水平 Pod 自动缩放器</strong>:</p><ul class=""><li id="eae3" class="lb lc iq kh b ki kj kl km ko ld ks le kw lf la lg lh li lj bi translated">被实现为一个控制循环，它通过 metrics.k8s.io API 定期查询资源指标 API 以获取<strong class="kh ir">核心指标、</strong>，如 CPU/内存和自定义指标 API 以获取<strong class="kh ir">应用特定指标</strong> (external.metrics.k8s.io 或 custom.metrics.k8s.io API)。它们由 metrics 解决方案供应商提供的“适配器”API 服务器提供。有一些已知的解决方案，但是这些实现都不是 Kubernetes 的正式部分</li><li id="43ff" class="lb lc iq kh b ki ll kl lm ko ln ks lo kw lp la lg lh li lj bi translated">根据观察到的指标，自动调整部署或副本集中的单元数量。</li></ul><p id="13b4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在下文中，我们将重点关注自定义指标，因为自定义指标 API 使得像<a class="ae lk" href="https://prometheus.io/" rel="noopener ugc nofollow" target="_blank"> Prometheus </a>这样的监控系统能够向 HPA 控制器公开特定于应用的指标。</p><p id="c367" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了基于自定义指标进行扩展，我们需要两个组件:</p><ul class=""><li id="ba69" class="lb lc iq kh b ki kj kl km ko ld ks le kw lf la lg lh li lj bi translated">一个从我们的应用程序中收集指标，并将它们存储到 Prometheus 时间序列数据库中。</li><li id="40e6" class="lb lc iq kh b ki ll kl lm ko ln ks lo kw lp la lg lh li lj bi translated">第二个扩展了 Kubernetes 定制度量 API，使用收集器提供的度量，即<a class="ae lk" href="https://github.com/DirectXMan12/k8s-prometheus-adapter" rel="noopener ugc nofollow" target="_blank"> k8s-prometheus-adapter </a>。这是一个自定义指标 API 的实现，它试图支持任意指标。</li></ul><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi lq"><img src="../Images/cd52efc686418ade9d9194ce369db453.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_BdOsoS41c-fYchLimpiAg.jpeg"/></div></div></figure><h1 id="e134" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated"><strong class="ak">配置 HPA 的分步指南</strong></h1><ol class=""><li id="5746" class="lb lc iq kh b ki mu kl mv ko mw ks mx kw my la mz lh li lj bi translated">让我们假设我们有以下两个应用程序(名为<strong class="kh ir"> myapplication </strong>)特定的指标发布给 Prometheus，它正在我们的集群中监听 http://Prometheus-server . Prometheus:</li></ol><pre class="lr ls lt lu gt na nb nc nd aw ne bi"><span id="4029" class="nf md iq nb b gy ng nh l ni nj"><strong class="nb ir">myapplication_api_response_time_count</strong>{endpoint="api/users",environment="test",environment_type="development",instance="10.4.66.85:9102",job="myapplication-pods",namespace="myapplication",pod="myapplication-85cfb49cf6-kvl2v",status_code="2xx",verb="GET"}</span></pre><p id="93ff" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">和</p><pre class="lr ls lt lu gt na nb nc nd aw ne bi"><span id="5b63" class="nf md iq nb b gy ng nh l ni nj"><strong class="nb ir">myapplication_api_response_time_sum</strong>{endpoint="api/users",environment="test",environment_type="development",instance="10.4.66.85:9102",job="myapplication-pods",namespace="myapplication",pod="myapplication-85cfb49cf6-kvl2v",status_code="2xx",verb="GET"}</span></pre><p id="33db" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们希望根据端点延迟来扩展我们的应用单元。</p><p id="7cbd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2.既然我们已经有了 Prometheus metrics，使用 Prometheus 适配器从 Prometheus 提供 metrics 是有意义的。Kubeapps Hub 上列出了一个舵图，名为<a class="ae lk" href="https://github.com/helm/charts/blob/master/stable/prometheus-adapter/README.md" rel="noopener ugc nofollow" target="_blank">stable/Prometheus-adapter</a>，可用于安装适配器:</p><pre class="lr ls lt lu gt na nb nc nd aw ne bi"><span id="5280" class="nf md iq nb b gy ng nh l ni nj">helm install --name my-release-name stable/prometheus-adapter</span></pre><p id="2f63" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">3.使用<strong class="kh ir">my application _ API _ response _ time _ avg</strong>自定义指标配置适配器:</p><pre class="lr ls lt lu gt na nb nc nd aw ne bi"><span id="595a" class="nf md iq nb b gy ng nh l ni nj">prometheus-adapter:<br/>  prometheus:<br/>    url: http://prometheus-server.prometheus<br/>    port: 80<br/><br/>  rules:<br/>    custom:<br/>    - seriesQuery: '{__name__=~"myapplication_api_response_time_.*",namespace!="",pod!=""}'<br/>      resources:<br/>        overrides:<br/>          namespace:<br/>            resource: namespace<br/>          pod:<br/>            resource: pod<br/>      name:<br/>        matches: ^(.*)<br/>        as: "myapplication_api_response_time_avg"<br/>      metricsQuery: 1000 * (sum(rate(myapplication_api_response_time_sum[5m]) &gt; 0) by (&lt;&lt;.GroupBy&gt;&gt;) / sum(rate(myapplication_api_response_time_count[5m]) &gt; 0) by (&lt;&lt;.GroupBy&gt;&gt;))</span></pre><p id="15c2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们公开了<strong class="kh ir">my application _ API _ response _ time _ avg</strong>，这将被 HPA 查询。每个规则必须指定一些资源覆盖，并且<strong class="kh ir"> <em class="nk"> metricsQuery </em> </strong>告诉适配器在检索数据时应该执行哪个 Prometheus 查询。</p><p id="3b14" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">4.使用以下命令检查指标的值，该命令向 Kubernetes API 服务器发送一个原始的 GET 请求:</p><pre class="lr ls lt lu gt na nb nc nd aw ne bi"><span id="16d2" class="nf md iq nb b gy ng nh l ni nj">kubectl get --raw "/apis/custom.metrics.k8s.io/v1beta1/namespaces/myapplication/pods/*/myapplication_api_response_time_avg" | jq .</span></pre><p id="4287" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nk">响应:</em></p><pre class="lr ls lt lu gt na nb nc nd aw ne bi"><span id="2c0a" class="nf md iq nb b gy ng nh l ni nj">{<br/>   "kind":"MetricValueList",<br/>   "apiVersion":"custom.metrics.k8s.io/v1beta1",<br/>   "metadata":{<br/>      "selfLink":"/apis/custom.metrics.k8s.io/v1beta1/namespaces/myapplication/pods/*/myapplication_api_response_time_avg"<br/>   },<br/>   "items":[<br/>      {<br/>         "describedObject":{<br/>            "kind":"Pod",<br/>            "namespace":"myapplication",<br/>            "name":"myapplication-85cfb49cf6-54hhf",<br/>            "apiVersion":"/v1"<br/>         },<br/>         "metricName":"myapplication_api_response_time_avg",<br/>         "timestamp":"2020-06-24T07:24:13Z",<br/>         "value":"10750m",<br/>         "selector":null<br/>      },<br/>      {<br/>         "describedObject":{<br/>            "kind":"Pod",<br/>            "namespace":"myapplication",<br/>            "name":"myapplication-85cfb49cf6-kvl2v",<br/>            "apiVersion":"/v1"<br/>         },<br/>         "metricName":"myapplication_api_response_time_avg",<br/>         "timestamp":"2020-06-24T07:24:13Z",<br/>         "value":"12",<br/>         "selector":null<br/>      }<br/>   ]<br/>}</span></pre><p id="e064" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，API 使用 Kubernetes 风格的数量来描述度量值。在 metrics API 中最常见的是<code class="fe nl nm nn nb b">m</code>后缀，这意味着毫单位，或一个单位的千分之一。如果度量正好是单位的整数，我们可能看不到后缀。</p><p id="7646" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，在这里，<code class="fe nl nm nn nb b">10750m</code>将是 10，75 毫秒，<code class="fe nl nm nn nb b">12</code>将是 12 毫秒</p><p id="048f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">5.创建一个 HPA，如果<strong class="kh ir">my application _ API _ response _ time _ avg</strong>暴露的延迟超过 500 ms，该 HPA 将按比例增加<strong class="kh ir">my application-deployment</strong>，几秒钟后，HPA 从 metrics API 中获取<strong class="kh ir">my application _ API _ response _ time _ avg</strong>值。</p><pre class="lr ls lt lu gt na nb nc nd aw ne bi"><span id="e6be" class="nf md iq nb b gy ng nh l ni nj">apiVersion: autoscaling/v2beta1<br/>kind: HorizontalPodAutoscaler<br/>metadata:<br/>  name: myapplication-hpa<br/>spec:<br/>  scaleTargetRef:<br/>    apiVersion: apps/v1<br/>    kind: Deployment<br/>    name: myapplication-deployment<br/>  minReplicas: 3<br/>  maxReplicas: 15<br/>  metrics:<br/>  - type: Pods<br/>    pods:<br/>      metricName: myapplication_api_response_time_avg<br/>      targetAverageValue: "500"</span></pre><p id="7089" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">6.检查新创建的 HPA。我们可能会注意到，自动缩放器不会立即对延迟峰值做出反应。默认情况下，指标同步每 30 秒发生一次，只有在过去 3-5 分钟内没有重新缩放的情况下，才会发生缩放。通过这种方式，HPA 可以防止冲突决策的快速执行，并为集群自动伸缩提供时间。</p><pre class="lr ls lt lu gt na nb nc nd aw ne bi"><span id="19d5" class="nf md iq nb b gy ng nh l ni nj">kubectl describe hpa myapplication-hpa -n myapplication</span></pre><h1 id="5e1e" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated"><strong class="ak">结论</strong></h1><p id="adfb" class="pw-post-body-paragraph kf kg iq kh b ki mu jr kk kl mv ju kn ko no kq kr ks np ku kv kw nq ky kz la ij bi translated">处理自动伸缩基本上是每个生产就绪系统中的一项常见任务，我在引言中提到的应用程序也是如此，例如，为了处理突发流量，我们必须根据延迟进行自动伸缩。通过检测该应用程序，并通过 Prometheus 公开正确的指标进行自动扩展，我们可以对其进行微调，以更好地处理突发事件并确保高可用性。</p></div></div>    
</body>
</html>