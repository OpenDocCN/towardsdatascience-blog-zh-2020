<html>
<head>
<title>AI, Cluster Analysis of Categorical Data (Part II)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分类数据的聚类分析(第二部分)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/ai-cluster-analysis-of-categorical-data-part-ii-47f3a13601a2?source=collection_archive---------37-----------------------#2020-05-21">https://towardsdatascience.com/ai-cluster-analysis-of-categorical-data-part-ii-47f3a13601a2?source=collection_archive---------37-----------------------#2020-05-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="f9cd" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">CRL元卡片组的聚类分析</h2><div class=""/><div class=""><h2 id="3004" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">使用Clash Royale原始数据提取最新的元卡片组</h2></div><p id="8f55" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><strong class="kt jd">整个过程</strong></p><p id="419a" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><a class="ae ln" href="https://github.com/arditoibryan/Projects/tree/master/20200518_CRL" rel="noopener ugc nofollow" target="_blank">我的仓库里有完整的代码。</a>笔记本名为:CRL_Clustering。</p><ol class=""><li id="298f" class="lo lp it kt b ku kv kx ky la lq le lr li ls lm lt lu lv lw bi translated">使用API下载匹配数据集</li><li id="ebf6" class="lo lp it kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">预处理:对每一行进行个性化排序</li><li id="b851" class="lo lp it kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">预处理:整个数据集的标签编码</li><li id="21be" class="lo lp it kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">预处理:整个数据集的one_hot编码</li><li id="8c32" class="lo lp it kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">执行聚类分析</li><li id="5563" class="lo lp it kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">训练K节点算法</li><li id="2f7a" class="lo lp it kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">调整聚类数以获得准确的结果</li><li id="2ad3" class="lo lp it kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">估计最高元牌组</li></ol><p id="1dee" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">到目前为止，<a class="ae ln" rel="noopener" target="_blank" href="/ai-cluster-analysis-of-categorical-data-part-i-8e702ca6675b">第一部分</a>涵盖了第三步:对整个数据集进行标签编码。在本教程的最后一部分，我将介绍接下来的五个步骤。</p><h1 id="9728" class="mc md it bd me mf mg mh mi mj mk ml mm ki mn kj mo kl mp km mq ko mr kp ms mt bi translated">4.预处理:整个数据集的one_hot编码</h1><p id="5d6a" class="pw-post-body-paragraph kr ks it kt b ku mu kd kw kx mv kg kz la mw lc ld le mx lg lh li my lk ll lm im bi translated">在步骤3中，我们已经标记了数据集中的每个元素，获得了以下结果:</p><figure class="na nb nc nd gt ne gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/7d31bc5c1e1bd63b70ddfbff73916ee0.png" data-original-src="https://miro.medium.com/v2/resize:fit:716/format:webp/1*27liwfTSEiJMyqqmqSBW4w.png"/></div></figure><p id="d222" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">为了将我们的数据集输入到AI中，我们需要使用one_hot编码。只有这样，模型才能处理分类数据。我们所有的列都是可互换的:这意味着我们将需要一大块one_hot变量。</p><p id="9b9d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">如果我们必须对每一列都应用one_hot编码，我们将会得到每一列一个one_hot块:这就是我们现在想要的。对于8个现有要素，列之间的数据将被认为是独立的，标签将应用于各个列，而不是单个数据集:</p><figure class="na nb nc nd gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nh"><img src="../Images/63104448374df1bce18d4202c35856c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C57MutAJMPCF4Sup8VIQqw.png"/></div></div></figure><p id="03b5" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">从上图可以看出，如果我们必须对每一列应用one_hot编码，就会出现这种情况。在上面的例子中，b在两列中，但它将被分解为1_b和2_b，b将被拆分为两个独立的变量。这意味着一张卡片。第一列中的巨人和第二列中的巨人将完全不同。因为事实并非如此(卡片组的顺序不应该影响元卡片组的选择)，所以当数据集中的相同变量位于不同的列中时，我们必须找到一种方法来避免它们的分离。</p><pre class="na nb nc nd gt nm nn no np aw nq bi"><span id="370f" class="nr md it nn b gy ns nt l nu nv">print(max(one_row_labeled+1), len(X_labeled))<br/>95 664</span></pre><p id="465d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们的数据集总共有94张牌在任何可能的牌组中被玩家使用。这意味着每一行必须有94列，每一列代表一个虚拟变量。</p><pre class="na nb nc nd gt nm nn no np aw nq bi"><span id="c4fb" class="nr md it nn b gy ns nt l nu nv">#  one_hot of multiple columns at the same time<br/>#create an empty dataset of equal lenght of max. label (94), but equal width of our X (664)<br/>m = [[0 for x in range(max(one_row_labeled)+1)] for x in range(len(X_labeled))]</span></pre><p id="bc0e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我首先创建了这个空数据集作为多维数组:</p><figure class="na nb nc nd gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nw"><img src="../Images/5251e01c59226f020cbaf5f57fff94d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r4pUWYCQ5PPJzQt5SavpJA.png"/></div></div></figure><p id="0dfc" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我现在将遍历x的每一行。每一行将包含8个不同的数字，我将找到相应的虚拟变量行并将其设置为1。</p><pre class="na nb nc nd gt nm nn no np aw nq bi"><span id="6916" class="nr md it nn b gy ns nt l nu nv">#turn each corresponding label to 1<br/>for row in range(len(X_labeled.values)):<br/>for num in range(len(X_labeled.values[1])):<br/>m[row][X_labeled.values[row][num]] = 1<br/>m = pd.DataFrame(m)<br/>m</span></pre><p id="9a62" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在正确的位置添加了1之后，我将把列表转换成数据帧。这就是我们最终得到的结果:</p><figure class="na nb nc nd gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nx"><img src="../Images/5c1bfdb6e79598a13df57e8c2c519b74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-vu3PUFiik2N3haBONXibQ.png"/></div></div></figure><p id="93e0" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在我们可以把它输入到模型中。</p><h1 id="beab" class="mc md it bd me mf mg mh mi mj mk ml mm ki mn kj mo kl mp km mq ko mr kp ms mt bi translated">5.执行聚类分析</h1><p id="53e0" class="pw-post-body-paragraph kr ks it kt b ku mu kd kw kx mv kg kz la mw lc ld le mx lg lh li my lk ll lm im bi translated">现在我们已经准备好了数据，我们需要确定最佳的集群数量:</p><pre class="na nb nc nd gt nm nn no np aw nq bi"><span id="4160" class="nr md it nn b gy ns nt l nu nv">#graph the number of clusters<br/>from sklearn.cluster import KMeans<br/>import matplotlib.pyplot as plt</span><span id="2e91" class="nr md it nn b gy ny nt l nu nv">wcss = []<br/>for i in range(1, 100):<br/>km = KMeans(n_clusters = i, init = 'k-means++', max_iter = 300, n_init = 20, random_state = 0)<br/>km.fit(m)<br/>wcss.append(km.inertia_)</span><span id="ca1f" class="nr md it nn b gy ny nt l nu nv">plt.plot(range(1, 100), wcss)<br/>plt.title('The Elbow Method')<br/>plt.xlabel('No. of Clusters')<br/>plt.ylabel('wcss')<br/>plt.show()</span></pre><figure class="na nb nc nd gt ne gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/ce922e766dd10a9dcdf88c708191b23e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1210/format:webp/1*csr2H1ip_WIIWN8nEJB6gA.png"/></div></figure><p id="d64c" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们正试图通过肘方法来评估最佳集群的数量。通常，我们会寻找图中曲线弯曲最厉害的地方。不幸的是，我们可以立即看到，没有明确的迹象表明有一定数量的集群(也许大约20个集群有一个可能的弯曲)。特别是在K模式中，由于特征的分类性质，很难估计最佳的聚类数目。我们需要通过多次迭代并比较结果来找到最佳的聚类数。</p><h1 id="252a" class="mc md it bd me mf mg mh mi mj mk ml mm ki mn kj mo kl mp km mq ko mr kp ms mt bi translated">6.训练K节点算法</h1><pre class="na nb nc nd gt nm nn no np aw nq bi"><span id="ef22" class="nr md it nn b gy ns nt l nu nv">!pip install kmodes</span></pre><p id="4eb0" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">* * *因为我正在使用Google Colab，所以我将使用上面的代码安装kmodes包，但是，根据您是在本地机器上还是远程运行您的算法，它可能会有所不同。</p><h2 id="813d" class="nr md it bd me oa ob dn mi oc od dp mm la oe of mo le og oh mq li oi oj ms iz bi translated">将每一行与其所属的聚类进行映射</h2><p id="acf3" class="pw-post-body-paragraph kr ks it kt b ku mu kd kw kx mv kg kz la mw lc ld le mx lg lh li my lk ll lm im bi translated">现在让我们在数据集上运行一个使用K-Mode的实验。我需要指出对数据集进行分组的聚类数。本质上，输出是一个664个数字的数组。每个数字映射一行及其对应的分类。</p><pre class="na nb nc nd gt nm nn no np aw nq bi"><span id="616c" class="nr md it nn b gy ns nt l nu nv">#mapping each row to its correponding cluster<br/>from kmodes.kmodes import KModes<br/>test=KModes(n_clusters=20, init='Cao') #Huang in another possibil<br/>cluster=test.fit_predict(m, categorical=list(m.columns))</span><span id="c99e" class="nr md it nn b gy ny nt l nu nv">cluster<br/>array([11,  0, 11,  4,  5,  3,  3, 11, 11,  9, 11, 11, 16,  5,  5,  0,  6,         1, 11,  3, 15,  0,  8,  1,  8,  0, 15,  5,  7, 15,  8, 17,  1, 15,         5,  2, 19, 13,  1,  9,  7, 16,  7,  1, 16,  3,  5,  1,  8,  7,  6,        16, 18,  7,  0,  3,  3,  3, 13, 19, 15, 11,  8,  4, 14,  4,  2, 14,         5,  7,  6,  1,  8,  1,  3,  8,  4,  3,  5, 19,  2,  1,  5,  0,  1,         6, 14,  8,  3,  4,  7,  4,  1, 14,  1,  5, 11, 18,  5,  1,  0,  2,        12,  3,  8,  9,  2,  4,  7,  7, 16, 11,  4, 11, 11,  1, 16,  6,  0,        16, 12,  0,  3,  7, 18,  1, 12,  0, 16, 18, 16,  3,  4,  7,  1,  1,         1,  2,  3, 19,  5, 11,  4, 16,  4,  0,  3, 12,  0, 12,  0, 12,  5,         2, 14, 11, 12, 15,  1, 11,  7,  2, 12,  0,  3,  3, 12,  7,  7, 18,         1, 16,  7, 17,  1, 12, 11, 14, 15,  3,  5,  0,  8, 14,  2,  2,  0,         4,  7, 16,  8, 11,  0,  6,  1,  5, 19,  7,  7, 16,  0,  2, 11,  4,         7,  5,  1,  8, 14,  0,  0, 19, 11,  7, 15,  5,  9,  2, 11,  7, 19,        14,  3, 11, 11,  1,  9,  5, 12, 12,  7, 12, 14, 14, 11,  0,  8,  3,         4, 11,  4,  5,  8, 15, 15, 14,  7,  4,  3,  6,  3,  5,  7,  4,  6,        15,  5, 13, 11,  4, 16,  7,  0, 14, 16,  7,  3,  9, 15,  0,  7,  0,         1,  8, 15,  5, 11,  3,  6,  4, 12, 15,  1,  2,  7,  1,  6,  1,  3,         8,  1,  0, 17,  5,  5, 14, 11,  3,  4,  2,  3,  7,  7, 11,  3,  0,         4,  1,  3,  7,  7,  4,  8,  3,  0,  3,  3,  9, 12,  3,  7,  7,  8,        12,  2,  3,  2, 19,  5,  7,  2, 14,  7,  2,  4,  1,  5, 19,  3,  2,        13,  5,  5,  3, 19,  4,  2, 15, 19,  1,  0, 12, 13,  8, 13,  0, 17,         7, 14,  3,  4,  0, 14, 12,  0,  1,  8, 12,  4,  3, 17, 15,  7,  4,         3, 14,  0, 12,  0,  9,  1, 14,  4, 12,  7,  4,  3,  2,  3, 15, 16,         2,  4,  0,  2, 15, 12,  7, 15,  2,  1,  1,  4,  0, 19,  6,  5, 11,        12,  8,  3, 16,  2,  3, 19,  0,  0,  1,  3, 17, 11, 10,  2, 15,  2,         0,  3,  7,  4, 17,  5,  5,  1,  8,  6,  6, 12,  5, 13, 19,  2,  6,         3,  3,  4,  3, 12, 17,  5, 15,  0, 19,  6,  0,  3,  2,  3,  0, 12,        11,  2, 14,  1,  1,  0,  7,  7, 12,  8,  4,  1, 12, 14, 17, 17,  8,         0,  2,  3,  2,  0, 16,  2,  6,  2,  0,  6,  3,  1,  0,  8,  3,  7,        11, 15,  0, 11, 11,  7,  2,  6,  5, 11,  4,  3,  5, 17, 15,  2,  0,        11, 11,  4,  3, 16, 19,  8, 15, 14,  0,  5, 13,  2,  0,  2, 14, 19,         8,  0,  1,  1, 14,  6, 15, 19, 19,  2,  0,  1,  1, 11,  5,  3,  3,         6,  8,  8,  1,  0, 19,  7,  2,  8,  4,  0, 12, 12, 12, 14,  4,  2,        16,  9,  0,  0,  4,  0,  2,  8,  4,  0,  2, 15,  4, 13, 15,  3,  0,         0,  4,  5,  6,  9,  0,  4, 14, 19,  1, 15, 15, 14,  2, 17,  4,  0,        15,  2, 12,  8, 14,  2,  1, 15,  2,  2,  2, 11, 12,  6,  0,  0, 12,         3, 17, 14, 11,  4,  0,  2,  4, 17,  0,  3,  5, 16,  0, 12,  0, 17,        17,  6,  4,  0, 16, 16,  0, 14,  3, 12, 11, 19,  6,  8,  2,  0,  4,         0,  7, 17,  1,  0, 15, 16, 13,  1,  7, 16,  0, 14,  6,  0,  0, 16,         5], dtype=uint16)</span></pre><h2 id="f3b3" class="nr md it bd me oa ob dn mi oc od dp mm la oe of mo le og oh mq li oi oj ms iz bi translated">了解20个集群</h2><p id="2c95" class="pw-post-body-paragraph kr ks it kt b ku mu kd kw kx mv kg kz la mw lc ld le mx lg lh li my lk ll lm im bi translated">现在，我们如何隔离集群并了解它们需要具备哪些特征？</p><pre class="na nb nc nd gt nm nn no np aw nq bi"><span id="8eb4" class="nr md it nn b gy ns nt l nu nv">test.cluster_centroids_<br/>array([<br/>[0, 0, 0, …, 0, 0, 0], <br/>[0, 1, 0, …, 0, 0, 0], <br/>[0, 0, 0, …, 0, 0, 0], <br/>…, <br/>[0, 0, 0, …, 0, 0, 0], <br/>[0, 0, 0, …, 0, 0, 1], <br/>[0, 0, 0, …, 0, 0, 1]<br/>])</span></pre><p id="2490" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这20个one_hot数字列表描述了每个单个集群的特征。每一个都由94个元素组成，其中一些是1，大多数是0。如果对于每个列表，我们将把这94个二进制值转换成数字，然后把数字转换成卡片名称，我们将得到20副元牌。</p><h2 id="7bfd" class="nr md it bd me oa ob dn mi oc od dp mm la oe of mo le og oh mq li oi oj ms iz bi translated">将数字转换为卡片名称</h2><p id="312d" class="pw-post-body-paragraph kr ks it kt b ku mu kd kw kx mv kg kz la mw lc ld le mx lg lh li my lk ll lm im bi translated">目前，结果对我们来说是不可理解的。我们需要把它们翻译成我们能理解的语言。下面的算法采用K模式算法的输出，并将其转换为原始字符串:</p><pre class="na nb nc nd gt nm nn no np aw nq bi"><span id="b02d" class="nr md it nn b gy ns nt l nu nv">#convert one_hot numbers to final decks<br/>def archetypes(knode_list):<br/>  archetypes_list = list()</span><span id="05cb" class="nr md it nn b gy ny nt l nu nv">#for each 1 inside the one_hot cluster form return its number<br/>  #not all clusters have the same lenght<br/>  #store all number is arrays<br/>  cc = list()<br/>  for n_centroids in range(len(km.cluster_centroids_)):<br/>    for k in range(len(km.cluster_centroids_[n_centroids])):<br/>      if km.cluster_centroids_[n_centroids][k] == 1:<br/>      cc.append(k)<br/>  len(cc)</span><span id="d598" class="nr md it nn b gy ny nt l nu nv">#determines number of chunks per cluster<br/>  n_chunks = list()<br/>  for am in range(len(km.cluster_centroids_)):<br/>    n_chunks.append((list(km.cluster_centroids_[am]).count(1)))<br/>  n_chunks</span><span id="7606" class="nr md it nn b gy ny nt l nu nv">#creates the meta-decks<br/>  from itertools import islice<br/>  it = iter(cc)<br/>  sliced =[list(islice(it, 0, i)) for i in n_chunks]<br/>  sliced</span><span id="615c" class="nr md it nn b gy ny nt l nu nv">sliced_list = list()<br/>  #convertion numbers to card names<br/>  for o in sliced:<br/>    sliced_list.append(order_row(list(le.inverse_transform(o))))</span><span id="6ae1" class="nr md it nn b gy ny nt l nu nv">#we only conserve the win conditions<br/>  card_dictionary = dict(zip(cards_classifier[0],<br/>  cards_classifier[1]))<br/>  card_dictionary</span><span id="f279" class="nr md it nn b gy ny nt l nu nv">#an absurd way of making a copy of our dataset, .copy() does not work<br/>  list_tot_classification = [x[:] for x in sliced_list] #un modo     assurdo per fare copia, altrimenti non funziona</span><span id="045e" class="nr md it nn b gy ny nt l nu nv">for o1 in range(len(list_tot_classification)):<br/>    for o2 in range(len(list_tot_classification[o1])):<br/>      a = card_dictionary.get(list_tot_classification[o1][o2])<br/>      list_tot_classification[o1][o2] = a</span><span id="8a96" class="nr md it nn b gy ny nt l nu nv">only_win_conditions = list()<br/>  #only conserve lists with win conditions<br/>  for o3 in range(len(list_tot_classification)):<br/>    if 'Win Condition' in list_tot_classification[o3]:<br/>    only_win_conditions.append(sliced_list[o3])</span><span id="94ca" class="nr md it nn b gy ny nt l nu nv">#we store all the lists with a lenght of 8: full decks<br/>  for _ in sorted(only_win_conditions):<br/>    if len(_) == 8:<br/>      archetypes_list.append(_)</span><span id="09c6" class="nr md it nn b gy ny nt l nu nv">return archetypes_list</span></pre><h1 id="4796" class="mc md it bd me mf mg mh mi mj mk ml mm ki mn kj mo kl mp km mq ko mr kp ms mt bi translated">7.调整聚类数以获得准确的结果</h1><p id="9119" class="pw-post-body-paragraph kr ks it kt b ku mu kd kw kx mv kg kz la mw lc ld le mx lg lh li my lk ll lm im bi translated">现在，让我们尝试我们刚刚编写的算法的不同配置，并比较结果。我将运行总共60个集群，存储每次迭代的结果和元组数:</p><pre class="na nb nc nd gt nm nn no np aw nq bi"><span id="cc23" class="nr md it nn b gy ns nt l nu nv">import numpy as np<br/>from kmodes.kmodes import KModes</span><span id="5546" class="nr md it nn b gy ny nt l nu nv">archetypes_len = list()<br/>for clus in range (8, 60): ###FUNZIONA IN UN FOR CYCLE, MA NON IN UNA FUNZIONE<br/>  km = KModes(n_clusters=clus, init='Cao', n_init=100, verbose=0)<br/>  clusters = km.fit_predict(m)</span><span id="5f9a" class="nr md it nn b gy ny nt l nu nv">#one_hot results to archetypes sorted by win condition<br/>  archetypes_list = archetypes(km.cluster_centroids_)<br/>  archetypes_len.append(len(archetypes_list))<br/>  for _ in archetypes_list:<br/>    print(clus, _)<br/>#25 is the optimal number of meta-decks</span></pre><figure class="na nb nc nd gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi ok"><img src="../Images/04d75b6ab9774e117c42ca8f721e8886.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t-wiCIBEWNevthuOnotn6Q.png"/></div></div><p class="ol om gj gh gi on oo bd b be z dk translated">具有最小数量分类的初始输出的屏幕截图</p></figure><figure class="na nb nc nd gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi op"><img src="../Images/296ed57d9aaee48a6bc0b31bb9b38717.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EBa_2kcbPevWrN6O2ypsdw.png"/></div></div><p class="ol om gj gh gi on oo bd b be z dk translated">具有更多分类的输出屏幕截图</p></figure><p id="7ea7" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">正如我们从上一张图中看到的，簇的数量越多，相似元牌的数量就越多。本质上，在某一点上，甲板变化也包括在计算中。</p><h2 id="38d1" class="nr md it bd me oa ob dn mi oc od dp mm la oe of mo le og oh mq li oi oj ms iz bi translated">n簇和n元牌</h2><p id="27e3" class="pw-post-body-paragraph kr ks it kt b ku mu kd kw kx mv kg kz la mw lc ld le mx lg lh li my lk ll lm im bi translated">我现在已经将集群的数量存储在了archetypes_len中。我将创建一个包含集群范围的列表，这样我们就可以绘制出集群数量和元组数量之间的关系。</p><pre class="na nb nc nd gt nm nn no np aw nq bi"><span id="741b" class="nr md it nn b gy ns nt l nu nv">import seaborn as sns<br/>archetypes_iteration = [x for x in range(8, 60)]<br/>archetypes_iteration<br/>sns.set(rc={‘figure.figsize’:(11.7,8.27)})<br/>sns.scatterplot(archetypes_iteration, archetypes_len)</span></pre><figure class="na nb nc nd gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi oq"><img src="../Images/d81ff94fbcc6160ceade9b4f4de0bc1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jj5htAXD7gPOGvErR6WaOA.png"/></div></div></figure><p id="0e54" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这如何转化为我们的元卡片组的层次结构？</p><figure class="na nb nc nd gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi or"><img src="../Images/0f19c15b6c355914b8ad125bd5350cad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KpdTIFVvq8toJv6et37lkQ.png"/></div></div></figure><h2 id="8ca3" class="nr md it bd me oa ob dn mi oc od dp mm la oe of mo le og oh mq li oi oj ms iz bi translated">集群的正确数量是多少？</h2><ul class=""><li id="5a94" class="lo lp it kt b ku mu kx mv la os le ot li ou lm ov lu lv lw bi translated">如果集群的数量太少，我们最终只有几个元甲板。它们将是正确的，可能是列表顶部的那些，但它们仅代表元组池中的一小部分。</li><li id="9163" class="lo lp it kt b ku lx kx ly la lz le ma li mb lm ov lu lv lw bi translated">如果集群的数量太大，我们不仅会列出顶层，还会列出它们的所有变体，最后会列出一个模糊了元层概念的层。</li></ul><p id="897e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">只有在数量合适的情况下，我们才能对当前赛季中使用最多的元套牌有一个概念。</p><figure class="na nb nc nd gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi ow"><img src="../Images/c5c1aafb761f9ba30fef01765081c191.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EKh1eAaPkGxmlsrSWXvX-g.png"/></div></div><p class="ol om gj gh gi on oo bd b be z dk translated">一副元牌示例:从:<a class="ae ln" href="https://www.reddit.com/r/ClashRoyale/comments/e5arf5/any_tips_for_icebow/" rel="noopener ugc nofollow" target="_blank">www.reddit.com</a>检索</p></figure><h1 id="5c8b" class="mc md it bd me mf mg mh mi mj mk ml mm ki mn kj mo kl mp km mq ko mr kp ms mt bi translated">8.估计顶级元牌</h1><p id="2d33" class="pw-post-body-paragraph kr ks it kt b ku mu kd kw kx mv kg kz la mw lc ld le mx lg lh li my lk ll lm im bi translated">最后，在查看了数据之后，我选择了一些簇，这些簇显示了变化最小的顶层元素。我们可以得出结论，这些是第11季的元套牌，即当前的皇家冲突季:</p><pre class="na nb nc nd gt nm nn no np aw nq bi"><span id="03af" class="nr md it nn b gy ns nt l nu nv">#questo funziona<br/>n_clusters = 25<br/>km = KModes(n_clusters=n_clusters, init='Cao', n_init=100, verbose=0)<br/>clusters = km.fit_predict(m)</span><span id="0205" class="nr md it nn b gy ny nt l nu nv">#one_hot results to archetypes sorted by win condition<br/>archetypes_list = archetypes(km.cluster_centroids_)<br/>for _ in archetypes_list:<br/>  print(_)</span></pre><figure class="na nb nc nd gt ne gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi ox"><img src="../Images/26c7ba63e4b97df2ece241f8d49bc7cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WlDmDW16PDCYNrUrm7HXzw.png"/></div></div><p class="ol om gj gh gi on oo bd b be z dk translated">输出</p></figure></div></div>    
</body>
</html>