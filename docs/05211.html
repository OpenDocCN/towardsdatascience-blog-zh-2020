<html>
<head>
<title>8 Popular SQL Window Functions Replicated In Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中复制的8个流行的SQL窗口函数</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/8-popular-sql-window-functions-replicated-in-python-e17e6b34d5d7?source=collection_archive---------7-----------------------#2020-05-04">https://towardsdatascience.com/8-popular-sql-window-functions-replicated-in-python-e17e6b34d5d7?source=collection_archive---------7-----------------------#2020-05-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="9262" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/programming" rel="noopener" target="_blank">编程</a> | <a class="ae ep" href="https://towardsdatascience.com/tagged/interviewing" rel="noopener" target="_blank">面试</a> | <a class="ae ep" href="https://towardsdatascience.com/tagged/office-hours" rel="noopener" target="_blank">办公时间</a></h2><div class=""/><div class=""><h2 id="b26c" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">关于如何在业务分析中利用Pandas高效复制最常用的SQL窗口函数的教程。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/2331b4193a3a950142a2b4cf8fd7d468.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hXYCql1ziCzt7cFtImvAfQ.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://unsplash.com/photos/dMeEJRE18VI" rel="noopener ugc nofollow" target="_blank">un splash:David Backer的紫色建筑仰视图</a></p></figure><p id="53a4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="me">更新:你们中的许多人联系我，要求在从SQL </em>  <em class="me">过渡的同时，为数据科学或数据分析学习Python提供有价值的资源</em> <strong class="lk jd"> <em class="me">。</em> <strong class="lk jd"> <em class="me"> </em> </strong> <em class="me">下面我分享4个我强烈推荐坚持学习的课程/平台:</em></strong></p><ul class=""><li id="d1ba" class="mf mg it lk b ll lm lo lp lr mh lv mi lz mj md mk ml mm mn bi translated"><a class="ae lh" href="https://stratascratch.com/?via=antonello" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd"> <em class="me"> SQL &amp; Python高级编码问题(StrataScratch)</em></strong></a><strong class="lk jd"><em class="me">→</em></strong><em class="me">目前为止我找到的准备SQL编码面试的最好平台！比LeetCode便宜多了。</em></li><li id="622d" class="mf mg it lk b ll mo lo mp lr mq lv mr lz ms md mk ml mm mn bi translated"><a class="ae lh" href="https://imp.i115008.net/2rrmW7" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd"> <em class="me">用Python进行数据科学编程</em> </strong> </a> →非常高质量的内容。</li><li id="5508" class="mf mg it lk b ll mo lo mp lr mq lv mr lz ms md mk ml mm mn bi translated"><a class="ae lh" href="https://click.linksynergy.com/deeplink?id=533LxfDBSaM&amp;mid=39197&amp;murl=https%3A%2F%2Fwww.udemy.com%2Fcourse%2Fdata-manipulation-in-python%2F" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd"> <em class="me">用Python操纵数据:一只熊猫速成班</em> </strong> </a></li><li id="e414" class="mf mg it lk b ll mo lo mp lr mq lv mr lz ms md mk ml mm mn bi translated"><a class="ae lh" href="https://datacamp.pxf.io/a1ezzR" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd"> <em class="me"> SQL汇总统计&amp;窗口功能</em> </strong> </a></li></ul><p id="928d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">希望你也会发现它们有用！现在享受这篇文章:D这个职位包括附属链接，我可能会赚一小笔佣金，没有额外的费用给你，你应该购买。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><p id="69af" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">任何致力于构建公司KPI或创建分析业务绩效的报告的数据分析师都知道<strong class="lk jd"> SQL窗口函数</strong>是一个强大的工具。使用它们的真正优势是可以在不同的时间范围内计算许多指标，而不会影响原始数据集的粒度。这反过来意味着不需要使用多个自连接或cte就可以实现更多功能，从而节省大量代码。</p><p id="c1e0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果到目前为止，您主要使用SQL来构建指标和提取见解，并且正在学习Python，那么您可能想知道如何在Pandas中复制您喜爱的窗口函数。在接下来的教程中，我将展示如何利用Python中的窗口函数使代码更加紧凑和高效。</p><h1 id="935d" class="na nb it bd nc nd ne nf ng nh ni nj nk ki nl kj nm kl nn km no ko np kp nq nr bi translated">数据集1</h1><p id="2d86" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">在教程的第一部分，我们将使用一个模拟的<strong class="lk jd">客户订单</strong>数据集，可以通过<a class="ae lh" href="https://github.com/anbento0490/code_tutorials/blob/master/8%20Python%20Window%20Functions/customer_orders.csv" rel="noopener ugc nofollow" target="_blank"> GitHub </a>下载。数据集最初包括七列(<em class="me">订单日期、订单ID、客户ID、商品ID、商品价格、数量</em>和<em class="me">已付金额()</em>)，但是我们还将添加<em class="me">订单月份</em>，如下所示:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nx ny l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/75d3bba877e1d62860a457860fa833e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/0*-47M-6UYBkflmAdh.png"/></div></figure><p id="b138" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们发现数据集包括50个不同的订单id和8列，但是如果我们想进一步研究它，我们可以通过运行以下命令来分析订单的分布和客户支付的金额:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nx ny l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oa"><img src="../Images/cd69368b42688fd8ea0900b58bc1050e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*B9DweGcVIH7uvlZK.png"/></div></div></figure><p id="5c37" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以看到，总共有四个客户，其中<em class="me"> customer_1 </em>是完成订单最多(<em class="me"> 18 </em>)和消费金额最高(<em class="me"> 1291.75 </em>)的客户。请注意如何在Python中使用<strong class="lk jd"> DataFrame.groupby() </strong>方法来实现与我们在SQL中通过查询末尾的列进行分组相同的结果。但是还有更多，因为这个方法也被用来复制典型的窗口函数的<strong class="lk jd"> over(partition by…) </strong>子句，我们将在下面学习。</p><div class="ob oc gp gr od oe"><a rel="noopener follow" target="_blank" href="/6-sql-window-functions-coding-problems-on-ranking-interview-countdown-p1-9be0ccf66453"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd jd gy z fp oj fr fs ok fu fw jc bi translated">排名上的6个SQL窗口函数编码问题——采访倒计时P1</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">SQL面试即将来临，您正在寻找一些具有挑战性的练习来测试您的准备情况？你是…</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">towardsdatascience.com</p></div></div><div class="on l"><div class="oo l op oq or on os lb oe"/></div></div></a></div><h1 id="03d0" class="na nb it bd nc nd ne nf ng nh ni nj nk ki nl kj nm kl nn km no ko np kp nq nr bi translated"><strong class="ak">Python中的窗口函数</strong></h1><ol class=""><li id="39ef" class="mf mg it lk b ll ns lo nt lr ot lv ou lz ov md ow ml mm mn bi translated"><strong class="lk jd">行号()→ Rank(method='first') </strong></li></ol><p id="be98" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">SQL<strong class="lk jd"/><a class="ae lh" href="https://www.sqlservertutorial.net/sql-server-window-functions/sql-server-row_number-function/" rel="noopener ugc nofollow" target="_blank"><strong class="lk jd">Row Number()</strong>函数</a>，为数据集分区内的每一行分配一个连续整数。它通常用于创建一个辅助列，根据指定的分区和顺序对字段进行排序。然后，该列可用于更有效地筛选或联接数据集。</p><p id="7d3a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">假设我们希望根据订单日期按客户对订单进行排序，从最近的订单开始。为了在SQL中实现这一结果，我们可以编写:</p><pre class="ks kt ku kv gt ox oy oz pa aw pb bi"><span id="6ca4" class="pc nb it oy b gy pd pe l pf pg"><strong class="oy jd">row number() over(partition by customer_id order by order_date)</strong></span></pre><p id="9a1c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于熊猫，同样的结果可以通过应用<a class="ae lh" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.rank.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd">来实现。rank(method = ' first ')</strong></a><strong class="lk jd"/>函数对按订单日期筛选的GroupBy对象执行操作，以创建<em class="me">行号</em>列:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="318b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以验证<em class="me"> customer_1 </em>确实完成了18个订单，其中第一个订单发生在2019–02–13(<strong class="lk jd">row num = 1</strong>)，最后一个订单发生在2020–04–25(<strong class="lk jd">row num = 18</strong>)。因为我们是按客户ID进行划分和排序的，一旦所有18个订单都被排序，该函数将开始对<em class="me"> customer_2 </em>的订单进行排序:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ph"><img src="../Images/b284c303753c74533fc0367f2117e1e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TwmqTTydnmEkMeGvkGMmCQ.png"/></div></div></figure><p id="c41e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">问题1: <em class="me">如果我们想按降序(从最近到最早的顺序)分配行号会怎样？</em>T19】</strong></p><p id="3ab2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这很简单，因为尽管代码中没有显示，pandas <strong class="lk jd"> rank(method = …) </strong>函数有一个<strong class="lk jd"> <em class="me">升序</em> </strong>参数，默认设置为<strong class="lk jd"> true </strong>。通过将其设置为<strong class="lk jd">假</strong>，我们将颠倒等级的分配方式:</p><pre class="ks kt ku kv gt ox oy oz pa aw pb bi"><span id="a346" class="pc nb it oy b gy pd pe l pf pg"><strong class="oy jd">orders.groupby([‘Customer ID’])[‘Order Date’].rank(method=’first’, ascending = False)</strong></span></pre><p id="1d94" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">问题2: <em class="me">如果我们想按多列(如客户ID和订单月份)进行分区，该怎么办？</em> </strong></p><p id="56d3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这种情况下，我们只需要将首选字段添加到GroupBy对象中:</p><pre class="ks kt ku kv gt ox oy oz pa aw pb bi"><span id="3b8a" class="pc nb it oy b gy pd pe l pf pg"><strong class="oy jd">#SQL Syntax<br/>row number() over(partition by customer_id, order_month order by order_date)</strong></span><span id="c7b0" class="pc nb it oy b gy pi pe l pf pg"><strong class="oy jd">#Python Syntax<br/>orders.groupby([‘Customer ID’, 'Order Month'])[‘Order Date’].rank(method=’first')</strong></span></pre><p id="ab87" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> #2。Rank() → Rank(method='min') </strong></p><p id="75fb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">SQL <a class="ae lh" href="https://www.sqlservertutorial.net/sql-server-window-functions/sql-server-rank-function/" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd"> RANK() </strong>函数</a>，为结果集分区内的每一行分配一个等级。与<strong class="lk jd"> ROW NUMBER()不同，</strong>等级不是连续的，这意味着一个分区内共享相同值的行将获得相同的等级。使用与上面相同的示例，SQL语法将是:</p><pre class="ks kt ku kv gt ox oy oz pa aw pb bi"><span id="8232" class="pc nb it oy b gy pd pe l pf pg"><strong class="oy jd">rank() over(partition by customer_id order by order_date)</strong></span></pre><p id="6b51" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">而它在Python中的对应物是:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nx ny l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pj"><img src="../Images/41ce10e15e3e10edf8982705fe7f02bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KG7EUcX1xFqic9JIumZGeA.png"/></div></div></figure><p id="e225" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因为<em class="me"> customer_1 </em>在2019–02–21执行了两个订单，这两个订单都被分配了rank = 3，下面的订单被分配了rank = 5，那么完全跳过rank = 4。如果我们必须使用SQL rank()窗口函数，这正是我们将得到的排名类型。</p><p id="540a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> #3。dense _ Rank()→Rank(method = ' dense ')</strong></p><p id="d3c1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果我们想避免排名值的差距，我们应该使用SQL <strong class="lk jd"> dense_rank() </strong>函数。实际上，与<strong class="lk jd"> rank() </strong>函数不同，使用<strong class="lk jd"> dense_rank() </strong>会返回连续的等级值。在我们的例子中，SQL语法应该是:</p><pre class="ks kt ku kv gt ox oy oz pa aw pb bi"><span id="a3d0" class="pc nb it oy b gy pd pe l pf pg"><strong class="oy jd">dense_rank() over(partition by customer_id order by order_date)</strong></span></pre><p id="b2d2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">而在Python中，我们只需要在<strong class="lk jd"> rank() </strong>函数<strong class="lk jd"> : </strong>中将<strong class="lk jd"> method='min' </strong>替换为<strong class="lk jd"> method='dense' </strong></p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nx ny l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pk"><img src="../Images/2c0306ffeeb934dbe616fff810aabff9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iEm7JSczTpQ45CR_dEaBaQ.png"/></div></div></figure><p id="6e2a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">不出所料，<em class="me"> customer_1 </em>于2019_02_23执行的订单现在已被分配<strong class="lk jd"> rank = 4 </strong>，<strong class="lk jd"> </strong>，尽管它是客户在分析期间的第5个订单。</p><p id="a922" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">总结一下我们到目前为止所学的内容:尽管在SQL中有3个不同的函数来计算数字数据的等级，但在pandas中，我们只需要使用<strong class="lk jd"> rank() </strong>函数和方法(<strong class="lk jd"><em class="me">‘first’，【min’</em></strong>或<strong class="lk jd"> <em class="me">，【dense’</em></strong>)以及升序(<strong class="lk jd"> <em class="me"> True </em> </strong>或<strong class="lk jd"> <em class="me"> False </em> </strong>)参数来获得想要的结果 </p><p id="b6da" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> #4。Sum(…) over(partition by … order by..前面无界的行)→ cumsum() </strong></p><p id="87b2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们现在希望计算每个月每个客户支付金额的<strong class="lk jd"><em class="me"/></strong>累计金额，按订单日期排序。这种计算也被称为<strong class="lk jd"> <em class="me">运行总数</em> </strong>，它可能是商业分析中最常用的指标之一。在SQL中实现这一点的一种方法是:</p><pre class="ks kt ku kv gt ox oy oz pa aw pb bi"><span id="6e5a" class="pc nb it oy b gy pd pe l pf pg"><strong class="oy jd">sum(amount_paid) over(partition by customer_id, order_month order by order_date rows unbounded preceding)</strong></span></pre><p id="3e56" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">上面的语法并不是最有效和最直观的:有相当多的代码要写，如果我们希望按<strong class="lk jd"> order_date </strong>排序，我们还必须包括<strong class="lk jd"> rows… </strong>子句来计算所选窗口中的累积和而不是总和。</p><p id="351d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是Python因其简洁而大放异彩的情况之一，为了达到与上面相同的结果，我们只需要编写:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nx ny l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pl"><img src="../Images/1ffde4a63a7c4f3fb519be2dbf5ec8ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SdbQCSxxyZXexXzfHT727w.png"/></div></div></figure><p id="1f4d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">正如预期的那样，<strong class="lk jd"> Run Tot ( ) </strong>列显示每个客户在一个月内支付的<strong class="lk jd">金额()</strong>的累进总和，该行对应于该月内的最后一个订单，最终显示该客户在该月的总消费金额。</p><p id="2f84" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> #5。avg(…)over(partition by…)→transform(NP . mean)</strong></p><p id="1c33" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">以类似的方式，我们可能还希望计算每个客户每月花费的平均金额。这一次，SQL语法非常直观:</p><pre class="ks kt ku kv gt ox oy oz pa aw pb bi"><span id="4916" class="pc nb it oy b gy pd pe l pf pg"><strong class="oy jd">avg(amount_paid) over(partition by customer_id, order_month)</strong></span></pre><p id="0311" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，详细阐述Python解决方案是值得的:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="4aa8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们之所以使用pandas<a class="ae lh" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.transform.html" rel="noopener ugc nofollow" target="_blank"><strong class="lk jd">data frame . transform()</strong></a>函数，是因为它允许我们在GroupBy对象上计算均值后，保持序列的长度等于原始数据集的长度。这种方法让我们得到了想要的结果:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pm"><img src="../Images/351c5b9a3890ec4cd0e5d32ffee1988a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZjBZerMjh1qIzukfyUvS6g.png"/></div></div></figure><h2 id="dc08" class="pc nb it bd nc pn po dn ng pp pq dp nk lr pr ps nm lv pt pu no lz pv pw nq iz bi translated">数据集2</h2><p id="6c71" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">在本教程的第二部分，我们将使用<strong class="lk jd"> yfinance </strong>包从雅虎财经获取<strong class="lk jd"> AAPL </strong>和<strong class="lk jd"> AMZN </strong>股票调整收盘价。我们应该已经在一开始就导入了它，但是如果不是这样，我们现在可以通过运行以下命令来完成:</p><pre class="ks kt ku kv gt ox oy oz pa aw pb bi"><span id="ea23" class="pc nb it oy b gy pd pe l pf pg"><strong class="oy jd">!pip install yfinance # &lt;-- to install the package<br/>import yfinance as yf</strong></span><span id="0a14" class="pc nb it oy b gy pi pe l pf pg"><strong class="oy jd">aapl = yf.download(“AAPL”, start=”2020–04–20", end=”2020–04–30").resample(‘D’).ffill()</strong></span><span id="dd31" class="pc nb it oy b gy pi pe l pf pg"><strong class="oy jd">amzn = yf.download(“AMZN”, start=”2020–04–20", end=”2020–04–30").resample(‘D’).ffill()</strong></span></pre><p id="9e0e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">使用上面的代码，我们还使用<strong class="lk jd"> yf.download() </strong>方法为<em class="me">2020–04–20</em>到<em class="me">2020–04–30</em>期间创建了两个新数据集(<strong class="lk jd"> aapl </strong>和<strong class="lk jd"> amzn </strong>)。为了将周末和节假日包括在内，数据被重新采样，缺失的股票价格被替换为之前最近的调整收盘价格观察值。对数据集进行了额外的操作(<a class="ae lh" href="https://github.com/anbento0490/code_tutorials/blob/master/8%20Python%20Window%20Functions/Python%20-%20Window%20Functions%20.ipynb" rel="noopener ugc nofollow" target="_blank">GitHub</a>中提供了全部代码)，这些数据集最终被合并到<strong class="lk jd">股票</strong>数据框架中:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi px"><img src="../Images/19d8917e28bceeaa7cb0d2b55ef8f0bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:556/format:webp/1*DIztYWnWmczIMvXtwrh6mA.png"/></div></figure><p id="e5fe" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> #6超前/滞后(返回值，偏移)→移位(n) </strong></p><p id="ed93" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">使用<strong class="lk jd">股票</strong>数据集，我们现在希望计算<strong class="lk jd"> DoD </strong>和<strong class="lk jd">WoW adj . Close Price % Change</strong>并通过保持数据帧长度不变来做到这一点，我们需要一个函数来访问当前行之前特定物理偏移量处的行。在SQL中，该窗口函数被命名为<a class="ae lh" href="https://www.sqlservertutorial.net/sql-server-window-functions/sql-server-lag-function/" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd"> lag() </strong> </a>，在我们的示例中，其语法如下:</p><pre class="ks kt ku kv gt ox oy oz pa aw pb bi"><span id="b82f" class="pc nb it oy b gy pd pe l pf pg">#Retrieves the stock price located 1 row back from the current row<br/><strong class="oy jd">lag(adj_close, 1) over(partition by symbol order by date)</strong></span><span id="5fd5" class="pc nb it oy b gy pi pe l pf pg">#Retrieves the stock price located 7 rows back from the current row<br/><strong class="oy jd">lag(adj_close, 7) over(partition by symbol order by date)</strong></span></pre><p id="7921" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">重要提示:<em class="me"> </em> </strong> <em class="me">因为我们已经对其进行了重新采样，我们的数据集现在有了每日粒度，</em> <strong class="lk jd"> <em class="me"> </em> </strong> <em class="me">这意味着要获得昨天的股票价格，我们只需向后移动一行，而要获得上周同一天记录的股票价格，我们只需向后移动7行。如果我们把周末和假期排除在外，这些计算就不会这么简单了。</em></p><p id="159d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在Python中，我们可以通过对GroupBy对象(按<strong class="lk jd"> <em class="me">符号</em> </strong>分组，并按<strong class="lk jd"> <em class="me"> Adj. Close </em> </strong>过滤)应用<a class="ae lh" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.shift.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd"> shift() </strong> </a>函数来创建<strong class="lk jd"> <em class="me"> Lag1 </em> </strong>和<strong class="lk jd"> <em class="me"> Lag7 </em> </strong>列，从而获得相同的结果。注意，因为我们希望分别向后移动1行和7行(我们的数据集有一个<em class="me">降序</em>),<strong class="lk jd">shift()</strong>函数将一个<em class="me">负整数</em> <strong class="lk jd"> </strong>作为参数:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nx ny l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi py"><img src="../Images/ab979c2861e728905a4269ccb334d22b.png" data-original-src="https://miro.medium.com/v2/resize:fit:702/format:webp/1*nzEqgw5XkqHTDg33XUHDPg.png"/></div></figure><p id="54b7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以看到，<strong class="lk jd"> shift( <em class="me"> n </em> ) </strong>函数已经正确地应用于每只股票，因此在第一个观察日期(<em class="me">2020–04–20</em>)，在没有先前价格的情况下，显示NaN值。同样，Lag7列中显示的第一个有效值出现在第一个观察日期(<em class="me">2020–04–27</em>)之后7天。</p><p id="db3f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">到目前为止，我们只是设法检索滞后的股票价格，而不是计算百分比变化。为了做到这一点，我们可以应用公式:</p><pre class="ks kt ku kv gt ox oy oz pa aw pb bi"><span id="7ae4" class="pc nb it oy b gy pd pe l pf pg"><strong class="oy jd">[(Adj Close / Lag1) - 1] x 100 &lt;-- DoD % Change</strong></span><span id="0b34" class="pc nb it oy b gy pi pe l pf pg"><strong class="oy jd">[(Adj Close / Lag7) -1] x 100 &lt;-- WoW % Change</strong></span></pre><p id="2ff7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">或者使用<a class="ae lh" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.pct_change.html" rel="noopener ugc nofollow" target="_blank"><strong class="lk jd">pct _ change(<em class="me">n</em>)</strong></a>函数来计算变动的股票价格，并返回它们的变化百分比:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nx ny l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pz"><img src="../Images/670073f0071debcb2cc29a2a1d7bdcb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:970/format:webp/1*Glh0NgNePbml5FSivUfT6w.png"/></div></figure><p id="7806" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了简洁起见，在本教程中我们不会展示一个使用<a class="ae lh" href="https://www.sqlservertutorial.net/sql-server-window-functions/sql-server-lead-function/" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd"> lead() </strong> </a>函数的等价示例，但是很容易猜到唯一真正的变化是分配给<strong class="lk jd"> shift() </strong>和<strong class="lk jd"> pct_change() </strong>函数的整数的符号。请记住，数据集的排序方式会影响应该传递给函数以获得预期结果的符号。</p><p id="a3d8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> #7。第一个/最后一个值()→ rank(method ='first '，ascending = True/False) == 1 </strong></p><p id="d4b4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><a class="ae lh" href="https://www.sqlservertutorial.net/sql-server-window-functions/sql-server-first_value-function/" rel="noopener ugc nofollow" target="_blank"><strong class="lk jd">first value()</strong></a><strong class="lk jd"/>和<a class="ae lh" href="https://www.sqlservertutorial.net/sql-server-window-functions/sql-server-last_value-function/" rel="noopener ugc nofollow" target="_blank"><strong class="lk jd">last value()</strong></a><strong class="lk jd"/>窗口函数用于在数据集的有序分区中检索第一行或最后一行的值。让我们假设我们想要找到<strong class="lk jd">AAPL股票每月第一个和最后一个可获得的可调收盘价</strong>。我们将使用的修改后的<strong class="lk jd"> aapl </strong>数据集的前10行如下所示:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qa"><img src="../Images/5813c9f76f7116a94701c2d01090aded.png" data-original-src="https://miro.medium.com/v2/resize:fit:524/format:webp/1*rNgSGkxiSA2Q_pfYWs8yhg.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">访问我的<a class="ae lh" href="https://github.com/anbento0490/code_tutorials/blob/master/8%20Python%20Window%20Functions/Python%20-%20Window%20Functions%20.ipynb" rel="noopener ugc nofollow" target="_blank"> GitHub账户</a>获取完整代码</p></figure><p id="5330" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们处理SQL查询的方式是:</p><pre class="ks kt ku kv gt ox oy oz pa aw pb bi"><span id="66d0" class="pc nb it oy b gy pd pe l pf pg"><strong class="oy jd">#The aapl dataset includes prices for one stock only, therefore the #partition is just applied on order_month</strong></span><span id="a79b" class="pc nb it oy b gy pi pe l pf pg"><strong class="oy jd">first value(adj_close) over(partition by order_month order by date)</strong></span><span id="20e0" class="pc nb it oy b gy pi pe l pf pg"><strong class="oy jd">last value(adj_close) over(partition by order_month order by date)</strong></span></pre><p id="9fee" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在Python中，并不存在与<strong class="lk jd"> first/last value() </strong>完全相同的函数，但是可以通过使用Pandas<strong class="lk jd">rank(method = ' first ')</strong>函数对分区中的值进行排序，然后只返回rank = 1的值，从而获得类似的结果。根据我们如何在rank()函数中设置<strong class="lk jd">升序</strong>参数，rank = 1的值将与分区中的第一个或最后一个值匹配。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="3741" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">尽管不是特别有挑战性，但这个过程还是有点麻烦，因为我们最终需要回填或前填整个分区的第一个或最后一个值，以获得想要的结果:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qb"><img src="../Images/1a8112dae143b0ecb1dd4ea0ae10dd0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1126/format:webp/1*2wFowDYcT02fKdXzipVBug.png"/></div></figure><p id="f928" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在<em class="me">2020–03–16</em>至<em class="me">2020–04–14</em>期间有效，三月份AAPL的第一个(或最近的)可用调整收盘价为242.2美元(<em class="me">排名Asc = 1 </em>)，最后一个(或最近的)为254.3美元(<em class="me">排名Desc = 1 </em>)。类似地，在4月，AAPL的第一个可用的Adj. Close价格是240.9美元，最后一个是287美元。</p><p id="c519" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> #8。Avg(…) over(partition by … order by..前n行和当前行之间的行)→滚动(window = …)。平均值()</strong></p><p id="c3b1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们在本教程中要复制的最后一个窗口函数是一个<strong class="lk jd">移动平均值</strong>。移动平均线是更一般函数的特例:</p><pre class="ks kt ku kv gt ox oy oz pa aw pb bi"><span id="280c" class="pc nb it oy b gy pd pe l pf pg"><strong class="oy jd">avg(return_value) over()</strong></span></pre><p id="3c81" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">至于在SQL中计算它，我们需要声明一个<strong class="lk jd"> rows … </strong>子句(就像我们对运行总数所做的那样)。例如，如果我们想用SQL ( <em class="me">假设数据集按升序排列</em>)计算AAPL调整收盘价的7天移动平均值，我们应该写:</p><pre class="ks kt ku kv gt ox oy oz pa aw pb bi"><span id="6d2b" class="pc nb it oy b gy pd pe l pf pg"><strong class="oy jd">avg(adj_close) over(order by date rows between 6 preceding and current row)</strong></span></pre><p id="4e2e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在<strong class="lk jd"> rows … </strong>子句中，我们简单地说明了我们希望在计算平均值时包括最近的观察值，因此我们只需要前面的6条记录就可以得到7天的窗口。对于更有经验的分析师来说，这些概念可能看起来微不足道，但是在新手中可能会引起混乱。</p><p id="766c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">幸运的是，用熊猫计算移动平均数是一件真正令人愉快的事情，因为我们只需要创建一个<strong class="lk jd">滚动对象</strong>(指定所需的<strong class="lk jd"> <em class="me">窗口</em> </strong>)，然后对其应用<strong class="lk jd"> <em class="me"> mean() </em> </strong>函数。或者，我们也不妨计算一下<strong class="lk jd"> <em class="me">和</em> </strong>，<strong class="lk jd"> <em class="me"> </em> </strong>这本身就是移动平均线的一个特例:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nx ny l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qc"><img src="../Images/5df16d2929cedb9f0e6ad42acc7dc6c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GLEcHvVEog95twlAl4wQPg.png"/></div></div></figure><p id="a0fe" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">实际上，这两个指标的区别在于<strong class="lk jd">当我们对滚动的对象应用函数时，窗口大小保持不变，而对于扩展的对象，窗口保持增长。</strong>使用扩展窗口背后的逻辑是，随着每一天的过去，我们都会观察到一个新的价格，可以添加到我们的均值计算中。这是我们希望包含在计算指标中的新信息。</p><h2 id="f21c" class="pc nb it bd nc pn po dn ng pp pq dp nk lr pr ps nm lv pt pu no lz pv pw nq iz bi translated">结论</h2><p id="c607" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">在这篇文章中，我们学习了如何使用Pandas在Python中复制8个流行的SQL窗口函数。如果您正在从事分析工作，那么您现在应该已经准备好使用SQL或Python来构建KPI以监控性能。在这两种语言中，当然有多种方法可以达到相同的效果，因此请在回复部分分享您的经验。希望你喜欢这篇教程，并期待下一篇！</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h2 id="27d3" class="pc nb it bd nc pn po dn ng pp pq dp nk lr pr ps nm lv pt pu no lz pv pw nq iz bi translated">我的读者请注意</h2><p id="8cdd" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">这个帖子包括附属链接，如果你购买的话，我可以免费给你一点佣金。</p><h2 id="b9fc" class="pc nb it bd nc pn po dn ng pp pq dp nk lr pr ps nm lv pt pu no lz pv pw nq iz bi translated">您可能还喜欢:</h2><div class="ob oc gp gr od oe"><a href="https://levelup.gitconnected.com/15-git-commands-you-should-learn-before-your-very-first-project-f8eebb8dc6e9" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd jd gy z fp oj fr fs ok fu fw jc bi translated">在你开始第一个项目之前，要掌握15个Git命令</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">您需要掌握的最后一个Git教程是命令行版本控制。</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="on l"><div class="qd l op oq or on os lb oe"/></div></div></a></div><div class="ob oc gp gr od oe"><a href="https://medium.com/@anbento4/connect-to-databases-using-python-and-hide-secret-keys-with-env-variables-a-brief-tutorial-4f68e33a6dc6" rel="noopener follow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd jd gy z fp oj fr fs ok fu fw jc bi translated">使用Python连接到数据库时使用环境变量隐藏密钥:简要教程</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">环境变量可用于在连接到数据库时隐藏您的秘密细节。了解如何在这个快速…</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">medium.com</p></div></div><div class="on l"><div class="qe l op oq or on os lb oe"/></div></div></a></div></div></div>    
</body>
</html>