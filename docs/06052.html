<html>
<head>
<title>Should you learn Julia?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">该不该学朱莉娅？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/should-i-learn-julia-986696ca031d?source=collection_archive---------22-----------------------#2020-05-17">https://towardsdatascience.com/should-i-learn-julia-986696ca031d?source=collection_archive---------22-----------------------#2020-05-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="f0e4" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">意见</h2><div class=""/><div class=""><h2 id="be25" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">Python 和 MATLAB 的高性能 lovechild 到底好不好？</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/50a2d03570a32dfee14a70903a198e80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gD2BFf3ot-8QbO6fgISPtw.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://pixabay.com" rel="noopener ugc nofollow" target="_blank"> pixabay </a>上的<a class="ae lh" href="https://pixabay.com/users/free-photos-242387/" rel="noopener ugc nofollow" target="_blank"> Free-photo </a>拍摄</p></figure><p id="5fd2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">朱莉娅是目前最新的“it”语言，所以我想我应该试一试。问题是，它值得加入数据科学家的武器库吗？</p><h2 id="9f7f" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">装置</h2><p id="7672" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">关于 Julia，首先要知道的是它很容易下载和使用(无论如何，在 Mac 上，祝 Windows 用户好运)。安装内核让它在 Jupyter 笔记本上运行也是轻而易举的事情。</p><h2 id="cf07" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">句法</h2><p id="04b9" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">Julia 不像 Python 那样是面向对象的语言，所以要写作，我们需要放弃一些(但不是全部)整洁的“Python 式”做事方式。</p><p id="68c4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在 Julia 中没有类，所以我们必须像处理 MATLAB 一样处理结构。同样，像 MATLAB 一样，Julia 采用了语言中内置的优秀的线性代数语法。这取代了对像 NumPy 这样的模块的需要，有利于更直观的语法，如用于乘法、复共轭和逐点除法的<code class="fe nb nc nd ne b">A*x</code>、<code class="fe nb nc nd ne b">x'</code>和<code class="fe nb nc nd ne b">./</code>。</p><p id="2146" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">用户应该警惕的另一件事是用关键字<code class="fe nb nc nd ne b">end</code>结束函数和循环，并且必须习惯使用 Julia。然而，你会很高兴地听到这样做的原因是因为 Julia 不是一种对空格敏感的语言，所以你再也不会看到“缩进中制表符和空格使用不一致”的错误了！</p><h2 id="5030" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">打字</h2><p id="ef35" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">从技术上讲，Julia 仍然是一种动态类型语言，这意味着你不需要<em class="nf">告诉它哪个变量具有哪个类型——类似于 Python 的工作方式。</em></p><p id="5b35" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，与 Python 不同，Julia 支持将变量强制为特定类型的类型化。这非常方便，原因有二:</p><ol class=""><li id="79bb" class="ng nh it lk b ll lm lo lp lr ni lv nj lz nk md nl nm nn no bi translated">它允许 Julia 代码比完全动态的语言运行得更快，如果一个变量被键入，那么它不需要在执行计算之前检查它是什么类型。</li><li id="8794" class="ng nh it lk b ll np lo nq lr nr lv ns lz nt md nl nm nn no bi translated">在处理类型化变量时，调试更容易，因为在没有显式执行的情况下，变量不会被意外地赋给不同的类型。为了在 Python 中获得同样的效果，你必须花很多时间在每个函数输入上实现<code class="fe nb nc nd ne b">assert</code>语句，即使这样，事情仍然可能出错！</li></ol><h2 id="6b09" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">Unicode 支持！</h2><p id="0411" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">这是朱莉娅最有特色的地方之一…</p><p id="f249" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在 MATLAB 或 Python 中实现数学表达式时，我们经常会遇到像<code class="fe nb nc nd ne b">x_hat</code>或<code class="fe nb nc nd ne b">sigma</code>这样的变量。然而，在 Julia 中，我们可以使用 Unicode 字符作为变量，而不是给我们<code class="fe nb nc nd ne b">x̂</code>和<code class="fe nb nc nd ne b">σ</code>！</p><p id="d2d5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">“我怎么能记住<code class="fe nb nc nd ne b">x̂</code>和<code class="fe nb nc nd ne b">σ</code>的键盘组合呢？我不会每次想用的时候都去谷歌一下！”</p><p id="aca3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是一个合理的担忧，但不必担心，因为 Julia 的核心开发人员比我们领先一步。对于<code class="fe nb nc nd ne b">x̂</code>，只需写<code class="fe nb nc nd ne b">x\hat ⇥</code>，对于<code class="fe nb nc nd ne b">σ</code>，写<code class="fe nb nc nd ne b">\sigma ⇥</code>，类似于你在 LaTex 中的做法。</p><p id="e395" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">虽然愤世嫉俗者可能认为这是一个噱头，但我认为它允许更多的可读代码，正如 Python 的<a class="ae lh" href="https://www.python.org/dev/peps/pep-0020/" rel="noopener ugc nofollow" target="_blank">禅</a>所说，“可读性很重要”。</p><h2 id="fdb4" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">实际写作是什么感觉？</h2><p id="f67c" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">在我的<a class="ae lh" rel="noopener" target="_blank" href="/understand-and-build-logistic-regression-from-scratch-4ca4a7a40a4">上一篇文章</a>中，我们从头实现了一个逻辑回归模型，但是在 Julia 中它看起来像什么呢？</p><pre class="ks kt ku kv gt nu ne nv nw aw nx bi"><span id="1b11" class="me mf it ne b gy ny nz l oa ob">function σ(x::Array{Float64,2})<br/>    return 1.0 ./ (1.0 .+ exp.(-x))<br/>end</span><span id="1136" class="me mf it ne b gy oc nz l oa ob">function fit(<br/>        X::Array{Float64,2},<br/>        y::Array{Float64,1},<br/>        epochs::Int64=100,<br/>        μ::Float64=0.0001<br/>    )<br/>    ε::Float64 = 0.00001<br/>    loss = []<br/>    <br/>    X = vcat(X, ones(1,size(X)[end]))<br/>    dims, n_data_points = size(X)<br/>    <br/>    w = randn(1,dims)</span><span id="9fc9" class="me mf it ne b gy oc nz l oa ob">    for i in 1:epochs<br/>        X̂ = w*X<br/>        ŷ = σ(X̂)</span><span id="aded" class="me mf it ne b gy oc nz l oa ob">    cost = -sum(y'.*log.(ŷ .+ ε) .+ (1 .- y').*log.(1 .- ŷ .+ ε))<br/>        <br/>        dc_dw = -sum((y' .- ŷ).*X,dims=2)'        <br/>        w = w .- dc_dw * μ<br/>        append!(loss,cost)<br/>    end<br/>    return w,loss<br/>end</span><span id="4e72" class="me mf it ne b gy oc nz l oa ob">function predict(X::Array{Float64,2},w::Array{Float64,1})<br/>    X = vcat(X, ones(1,size(X)[end]))<br/>    X̂ = w*X<br/>    ŷ = σ(X̂)<br/>    return ŷ<br/>end</span></pre><p id="ab07" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这个实现中，我们可以看到 Julia 的 Unicode 字符如何使代码更具可读性的完美例子。本地线性代数支持进一步简化了代码，每次我们想要执行乘法或求和时，都删除了<code class="fe nb nc nd ne b">np.</code>。我们还输入了函数输入，以确保输入的类型和维度都有效。</p><h2 id="772a" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">速度！</h2><p id="54e8" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">Julia 基于 C 的血统和类型使得它的速度比缓慢的 Python 有了很大的提高。这些都可以在不对代码效率进行任何重大改进的情况下完成。</p><p id="89fa" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们用这个简单的 Python 函数来计算前 10，000 个素数:</p><pre class="ks kt ku kv gt nu ne nv nw aw nx bi"><span id="74c4" class="me mf it ne b gy ny nz l oa ob">def n_primes(n:int)-&gt;list:<br/>    primes = []<br/>    i = 2<br/>    while len(primes) &lt; n:<br/>        prime_bool = True<br/>        for j in range(2,i//2+1):<br/>            if i%j == 0:<br/>                prime_bool = False<br/>        if prime_bool == True:<br/>              primes.append(i)<br/>        i += 1<br/>    return primes</span></pre><p id="38c8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">耗时 2 分 42 秒。当我们使用打字时，让我们将它与 Julia 进行比较:</p><pre class="ks kt ku kv gt nu ne nv nw aw nx bi"><span id="c502" class="me mf it ne b gy ny nz l oa ob">function n_primes(n::Int64)<br/>    primes = Int64[]<br/>    i::Int64 = 2<br/>    while size(primes)[1] &lt; n<br/>        prime_bool::Bool = true<br/>        for j = 2:i÷2<br/>            if i%j == 0<br/>                prime_bool = false<br/>            end<br/>        end<br/>        if prime_bool == true<br/>              append!(primes,i)<br/>        end<br/>        i += 1<br/>    end<br/>    return primes<br/>end<br/>&gt;&gt; @time n_primes(10000)</span></pre><p id="1ba1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这只花了 7.55 秒！</p><h2 id="8ba5" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">Julia 编译成二进制…这很酷</h2><p id="b585" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">对于那些想在野外部署代码的无畏者来说，编译成二进制文件是一个有用的工具。</p><p id="5e82" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Python 开发人员对定义依赖关系并与<code class="fe nb nc nd ne b">pip</code>搏斗以确保所有包保持互操作性的问题并不陌生。Julia 对此的巧妙解决方案是编译成一个二进制文件。这不仅意味着部署可以像将二进制文件放入 Docker 容器并启动您的服务一样简单，而且还意味着这带来了与使用 Go 等语言相同的安全性改进。</p><h2 id="9ba3" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">但是我真的很喜欢 Python…</h2><p id="9697" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">那么不要让 Julia 阻止你，有一个 Python 解释器直接内置在 Julia 中，所以使用 Python 就像使用<a class="ae lh" href="https://github.com/JuliaPy/PyCall.jl" rel="noopener ugc nofollow" target="_blank"> Pycall </a>一样简单。</p><pre class="ks kt ku kv gt nu ne nv nw aw nx bi"><span id="cf60" class="me mf it ne b gy ny nz l oa ob">using Pycall<br/>packagename = pyimport(“packagename”)</span></pre><p id="30ed" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">真的就这么简单！Pycall 允许使用所有内置的 Python 名称空间函数和特性(甚至使用上下文管理器)。</p><h2 id="9265" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">这听起来很不错，有什么问题吗？</h2><p id="c476" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">调试不像在 Python 中那么容易；这可能是因为我只是熟悉 Python 的回溯错误，或者 Python 只是用一种更具描述性的方式告诉你错误在哪里。</p><p id="fb96" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里有一个简单的例子，可以尝试用 Python 来说明:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi od"><img src="../Images/6bb0d78b2448778b2f7aaf88bca3d580.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TuI46Qq_pp39FZJeOrrRsA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">Python 将两个列表相乘</p></figure><p id="bff7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">…在朱莉娅身上:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi od"><img src="../Images/9ef1238fd9fb82495285999614cced9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wyQc5Faqa7riBG7pByX47w.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">Julia 将两个数组相乘</p></figure><p id="da34" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我认为其中一个比另一个要清楚得多…</p><p id="2f11" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Julia 的另一个问题是缺乏对机器学习库的支持。这可能是其相对年轻的产物，但它仍然是一个令人沮丧的特征。Julia 有熊猫、TensorFlow 和 Sklearn 的包装器，但如果我们想获得预训练的 ResNet 50 或 Bert 模型，这并不能帮助我们，因为它们很可能是用 Python 编写的。</p><p id="e929" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">话虽如此，Julia 社区正在成长，更多的本地库几乎每天都在建立，像<a class="ae lh" href="https://github.com/emmettgb/Lathe.jl" rel="noopener ugc nofollow" target="_blank">车床</a>和<a class="ae lh" href="https://alan-turing-institute.github.io/MLJ.jl/v0.1/" rel="noopener ugc nofollow" target="_blank"> MLJ </a>，所以我们还有希望！</p><p id="51dd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Julia 缺少基于类的对象，这也使得在 Python 之外使用这些库有些笨拙。例如熊猫的<code class="fe nb nc nd ne b">df.loc[] </code>变成了<code class="fe nb nc nd ne b">loc!(df, )</code>。</p><p id="4881" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最后，Julia 的基础命名空间中有太多的函数。在某些方面，这是方便的，并允许类似 MATLAB 级别的可用性和编写代码的简易性。然而，这使得 Julia 代码的可读性更差，通常很难判断一个函数是默认存在的，还是用户自定义的，或者是从另一个模块导入的。</p><h2 id="9984" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">所以，该不该学朱莉娅？</h2><p id="69de" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">我同意！这有什么坏处呢？鉴于缺乏可用的受支持库，在 Julia 中编写生产代码目前会很困难。但是，Julia 确实提供了易于学习的语法、极快的代码执行、内置的 Python 解释器以及对数据科学家工作流程的许多其他潜在改进。鉴于它越来越受欢迎，可能有理由在未来转换，或者，也许你的下一个项目有一些非常严格的性能约束？朱莉娅可能就是答案。</p></div></div>    
</body>
</html>