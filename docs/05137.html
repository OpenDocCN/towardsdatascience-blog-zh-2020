<html>
<head>
<title>Adding Control To My Modular Graphing Library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">向我的模块化图形库添加控件</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/adding-control-to-my-modular-graphing-library-2c5424a8d3b7?source=collection_archive---------61-----------------------#2020-05-02">https://towardsdatascience.com/adding-control-to-my-modular-graphing-library-2c5424a8d3b7?source=collection_archive---------61-----------------------#2020-05-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="972c" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">Hone.jl</h2><div class=""/><p id="703a" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">用控件表单扩展Hone.jl的可用性。</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi kx"><img src="../Images/d4dcb14fa1a0c48420072d740e176871.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*oA6_H1YOgl96ujKHhsRoEw.gif"/></div></div></figure><blockquote class="lj"><p id="b749" class="lk ll it bd lm ln lo lp lq lr ls kw dk translated"><a class="ae lt" href="https://medium.com/me/stats/post/15426b00dcaf" rel="noopener">上一部分</a></p><p id="a6aa" class="lk ll it bd lm ln lu lv lw lx ly kw dk translated"><a class="ae lt" href="https://github.com/emmettgb/Emmetts-DS-NoteBooks/blob/master/Julia/Hone%20Grid.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a></p></blockquote><p id="7818" class="pw-post-body-paragraph jz ka it kb b kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw im bi me translated">如果您一直在关注Hone.jl的开发，这是一个模块化的、面向对象的图形库，可以有效地在静态类型语言中隐藏类型，那么您可能还记得我上次离开时留下的问题…每当解析新网格对象的连接表达式时，都会返回意外的\ "，\ "错误。最初，我认为这可能是我用来在表达式中生成字符串的正则表达式的问题。</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi mn"><img src="../Images/be76dec8844e6f7ca4b179cb32fb8e63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zycVQk019opptmiZIvAkPg.png"/></div></div></figure><p id="f5e1" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">这实际上非常令人沮丧，花了整整半个小时才解决，但这不一定是我的错——嗯，是我的错——我实际上错过的是错误中间的<code class="fe mo mp mq mr b">,</code>。我对正则表达式字符串分隔符的使用无疑使错误变得有点混乱。幸运的是，缺少逗号是一个非常</p><blockquote class="lj"><p id="5a38" class="lk ll it bd lm ln lu lv lw lx ly kw dk translated">解析字符串时经常出错。</p></blockquote><p id="97ba" class="pw-post-body-paragraph jz ka it kb b kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw im bi translated">现在创建我们的网格对象:</p><pre class="ky kz la lb gt ms mr mt mu aw mv bi"><span id="24d8" class="mw mx it mr b gy my mz l na nb">h = Grid(4)</span></pre><p id="31f2" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">并调用Grid.show()方法:</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/f56e2665622e545db04402070598714b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*M1Sp8o-FK8yw5CfSo7hXJw.png"/></div></figure><blockquote class="lj"><p id="4f4e" class="lk ll it bd lm ln lo lp lq lr ls kw dk translated">太棒了。</p></blockquote><p id="9af6" class="pw-post-body-paragraph jz ka it kb b kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw im bi translated">现在我们只需要把它加到我们的散射函数中。这就像创建网格并将其标签添加到散布函数中的表达式一样简单。下面是当一个数组被传递时分派路线的功能:</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi nd"><img src="../Images/d83fc8c80abb33252eed3f67236c6fea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mB7EjBuo9cJJrtLMRVx6YA.png"/></div></div></figure><p id="5c1c" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">我认为将网格作为一个对象而不是一个细分量添加到参数中是最优雅的，这样可以使模型的其他部分与方法论保持一致。现在我们创建一些无意义的数据:</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi ne"><img src="../Images/eb561d23cfcb4791cf06320ddae8386a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OiNYs2rRgip3bcBvpMZ08w.png"/></div></div></figure><blockquote class="lj"><p id="62fb" class="lk ll it bd lm ln lo lp lq lr ls kw dk translated">嘣！</p><p id="dc9b" class="lk ll it bd lm ln lu lv lw lx ly kw dk translated">我们有网格了！</p></blockquote></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><p id="c2d9" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">我想实现的下一件事是保存渲染的矢量图形的能力。为此，我在Hone的所有对象函数中添加了一个新的方法定义:</p><pre class="ky kz la lb gt ms mr mt mu aw mv bi"><span id="4049" class="mw mx it mr b gy my mz l na nb">save(name) = draw(SVG(name), composition);</span></pre><p id="7de6" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">然后将其添加到我们类型的导出数据和方法的长列表中:</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/ce527b26207b785cd8f36072bbd21da8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1054/format:webp/1*DnKPXPHCsamRC1nNyfrhxg.png"/></div></figure><p id="e5d2" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">现在，无论何时用字符串调用save()方法，都会保存一个本地SVG文件，</p><blockquote class="lj"><p id="73c5" class="lk ll it bd lm ln lu lv lw lx ly kw dk translated">酷！</p></blockquote></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><h2 id="3bc6" class="mw mx it bd nn no np dn nq nr ns dp nt kk nu nv nw ko nx ny nz ks oa ob oc iz bi translated">速度恶魔</h2><p id="c2a1" class="pw-post-body-paragraph jz ka it kb b kc od ke kf kg oe ki kj kk of km kn ko og kq kr ks oh ku kv kw im bi translated">我的长期读者可能知道，我喜欢速度。我决定(再次)测试Plots.jl的速度。</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi oi"><img src="../Images/b866e0479dfcaf8441e4d69e0bc13f98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QkDTobVYF2HaNbCFTYL0vg.png"/></div></div></figure><blockquote class="lj"><p id="5f7b" class="lk ll it bd lm ln lo lp lq lr ls kw dk translated">5秒4.11 M分配！</p></blockquote><p id="54ba" class="pw-post-body-paragraph jz ka it kb b kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw im bi translated">这还不算太坏——所有必需品都考虑在内。但是Plots.jl如何与之抗衡呢？</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi oj"><img src="../Images/3e96fc1ca448948615a4c791d9ec63a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v51lQqN77z-5dw30ZFIBdg.png"/></div></div></figure><blockquote class="lj"><p id="1351" class="lk ll it bd lm ln lo lp lq lr ls kw dk translated">一些观察结果:</p></blockquote><ul class=""><li id="5ffd" class="ok ol it kb b kc lz kg ma kk om ko on ks oo kw op oq or os bi translated">Hone需要更多的内存来渲染图像。这可能部分是由于元表达式，部分是由于矢量和光栅化图像渲染之间的差异。</li><li id="8ace" class="ok ol it kb b kc ot kg ou kk ov ko ow ks ox kw op oq or os bi translated">Plots.jl的加载时间与地块本身的加载时间大致相同，总共约为15秒。</li><li id="c698" class="ok ol it kb b kc ot kg ou kk ov ko ow ks ox kw op oq or os bi translated">剧情。JL平均要慢2秒左右</li><li id="4ebf" class="ok ol it kb b kc ot kg ou kk ov ko ow ks ox kw op oq or os bi translated">他们的情节比我的更漂亮，因为我还没有添加一些突出的特征，比如传说。</li></ul></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><h1 id="3b3c" class="oy mx it bd nn oz pa pb nq pc pd pe nt pf pg ph nw pi pj pk nz pl pm pn oc po bi translated">控制</h1><p id="3204" class="pw-post-body-paragraph jz ka it kb b kc od ke kf kg oe ki kj kk of km kn ko og kq kr ks oh ku kv kw im bi translated">对于在Hone中实现控件表单，我有一些有趣的想法。这将允许更多的图形绘制，以及增加边距和改变个别上下文的分辨率。这是我开始使用的函数:</p><pre class="ky kz la lb gt ms mr mt mu aw mv bi"><span id="114a" class="mw mx it mr b gy my mz l na nb">function Frame(width,height,m_left,m_right,m_top,m_bottom)<br/>    tag = string("context(UnitBox(0,0," ,width,",", height, ",",m_left, "", m_right,<br/>    ",",m_top, ",", m_bottom,"))")<br/>    add(obj) = tag = string(tag,obj)<br/>    show() = exp = Meta.parse(string("draw(SVG('c'),",tag, "))"));eval(exp)<br/>    save() = draw(SVG(name), eval(tag))<br/>    (var)-&gt;(add;show;tag)<br/>end</span></pre><p id="6fe6" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">然而，这个函数有几个基本问题。最重要的是，不涉及任何组合，这意味着在向表单中添加对象后查看表单是不可能的。另一个问题；add函数只能在整个函数处理完之后调用，如果我们要添加compose方法，设置标记的第一行如果没有括号就无法解析。这有点自相矛盾，因为您需要创建对象来添加它，但是如果没有来自对象标签的右括号，您就不能创建对象。考虑到这一点，我重新编写了函数:</p><pre class="ky kz la lb gt ms mr mt mu aw mv bi"><span id="493f" class="mw mx it mr b gy my mz l na nb">function Frame(width, height, lm, rm, tm, bm)<br/>    base = string("compose(context(units=UnitBox(0,0,",<br/>    width, ",",<br/>    height, ",",<br/>    lm, ",", rm,",",<br/>    tm, ",", bm,<br/>        ")),")<br/>    objects = []<br/>    composition = nothing<br/>    add(objects) = composition,objects,tag = _frameup(base,objects)<br/>    show() = composition<br/>    tree() = introspect(composition)<br/>    save(name) = draw(SVG(name), composition)<br/>    (var)-&gt;(add;show;tag;base;objects;composition;save;tree;width;height)<br/>end</span></pre><p id="3bb9" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">这一次我决定创建一个名为“objects”的iterable，它将把我们所有的Julia类型存储在一个我们可以循环访问的数组中。我所做的一个重大改变是添加了compose方法和_frameup()方法，这将为我们返回解析后的组合、对象和元标记。</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/57d8e195070475c44eb74de5bcaeb8a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*kxp0gqISCVILjVTSJKwV7g.png"/></div></figure><p id="9e02" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">这个函数本身相当简单，尽管它的返回列表很长。首先，我们在一个迭代循环中添加每个对象的标签。这个循环肯定不是我喜欢的方式，可以缩短为</p><pre class="ky kz la lb gt ms mr mt mu aw mv bi"><span id="c07e" class="mw mx it mr b gy my mz l na nb">tag = [string(tag,object.tag) for object in objects]</span></pre><p id="c20a" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">无论如何，之后，我们为compose()方法添加括号，然后解析标签并在最终返回之前创建一个组合。</p><p id="b33b" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi me translated">现在我们有了add()函数和一个操作框架，接下来要做的是修改我们的散布函数，使其适合框架，而不是停留在没有参数的上下文中。我首先用默认框架向我的函数添加了一个参数:</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi pq"><img src="../Images/ef78ea86d2864883f14f2533935ade3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xtiiLHhX4S4jkYSm74x_yw.png"/></div></div></figure><p id="bd34" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">现在我们可以在Frame上使用add方法——哦，等等，我们不能。在我们可以渲染我们的框架之前，还有一个重要的问题。_frameup函数调用要传递的对象的标记，但是我们的对象在技术上确实具有属性“tag”，但是我们无法在创建对象的同时传递带有子“tag”的对象。为了解决这个问题，我简单地添加了一个名为“TransferType”的随机结构来保存子标签。我们可以快速构造这个类型，并把它放入函数中，就像它是我们的散射对象一样。</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi pr"><img src="../Images/2dd24aac028f0b9c6b2441bede3f27dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0U9DLChPupU7FlJ9PmG6TA.png"/></div></div></figure><p id="d5f0" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">现在我们将再次填充我们的函数:</p><pre class="ky kz la lb gt ms mr mt mu aw mv bi"><span id="9207" class="mw mx it mr b gy my mz l na nb">plot = _arrayscatter(x,y,shape)</span></pre><p id="832f" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">当我们调用show()方法时:</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi ps"><img src="../Images/8484a37f3845c4dd6c8d76b2e2b30db6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mI8SsRO2Rkk42r5fgGx2wQ.png"/></div></div></figure><p id="a7b0" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">如果你仔细看左上方，</p><blockquote class="lj"><p id="9806" class="lk ll it bd lm ln lu lv lw lx ly kw dk translated">那是我们的散点图！</p></blockquote></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><p id="a955" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">所以很明显，伸缩将会是一个痛苦的问题，我将不得不尽快处理，并且我可能会对库增加更多的控制。很多事情进行得特别顺利，但也有很多事情进行得相当糟糕——但总的来说，我认为这个项目进行得很好。关于Hone.jl的伟大之处在于，一旦我完成了基本方法，渲染任何东西都会变得非常容易。好消息是:这些更新已经被推送到Github上的0.0.2分支:</p><div class="pt pu gp gr pv pw"><a href="http://github.com/emmettgb/Hone.jl" rel="noopener  ugc nofollow" target="_blank"><div class="px ab fo"><div class="py ab pz cl cj qa"><h2 class="bd jd gy z fp qb fr fs qc fu fw jc bi translated">emmettgb/Hone.jl</h2><div class="qd l"><h3 class="bd b gy z fp qb fr fs qc fu fw dk translated">模块化的形状，网格和线条容易预制快速绘图简单和轻型车床集成(即将推出)…</h3></div><div class="qe l"><p class="bd b dl z fp qb fr fs qc fu fw dk translated">github.com</p></div></div><div class="qf l"><div class="qg l qh qi qj qf qk lh pw"/></div></div></a></div><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi ql"><img src="../Images/77458fce101ca2efa1c7ccaa0d13164a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1rOzH7T9zpiMN4r9ouF-8A.png"/></div></div></figure><p id="a9c3" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">更好的消息是，我刚刚向master推送了车床0.1.0版本！0.1.0中有很多很酷的特性，比如幂逻辑、实验性的基于网格的卷积神经网络，当然还有一些更棒的东西！车床很快就要和Hone交织在一起了，所以这肯定是令人兴奋的。Hone和车床的一个显著优点是我可以使用Hone.jl而不用接触它的代码库。</p><div class="pt pu gp gr pv pw"><a href="http://lathe.ai" rel="noopener  ugc nofollow" target="_blank"><div class="px ab fo"><div class="py ab pz cl cj qa"><h2 class="bd jd gy z fp qb fr fs qc fu fw jc bi translated">车床</h2><div class="qd l"><h3 class="bd b gy z fp qb fr fs qc fu fw dk translated">车床使用更快的方法和简单的方法。使得包装快速、简单且轻便。许多工具和模型…</h3></div><div class="qe l"><p class="bd b dl z fp qb fr fs qc fu fw dk translated">车床. ai</p></div></div></div></a></div><p id="73c7" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">如果您还记得，我添加了一个参数，用于将自定义元标签插入到Hone对象中，因此将它与机器学习的元素结合起来肯定会很有趣。一个很好的例子就是置信区间，我不需要把它们编程到Hone中，我可以用这种方式为使用车床的Hone编程一个扩展。</p></div></div>    
</body>
</html>