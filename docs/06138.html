<html>
<head>
<title>Airflow: how and when to use it (Advanced)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">气流:如何和何时使用它(高级)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/airflow-how-and-when-to-use-it-advanced-238ea6b63f13?source=collection_archive---------42-----------------------#2020-05-18">https://towardsdatascience.com/airflow-how-and-when-to-use-it-advanced-238ea6b63f13?source=collection_archive---------42-----------------------#2020-05-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="f5f3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae ko" href="https://medium.com/@alexagriffith/airflow-how-and-when-to-use-it-2e07108ac9f5" rel="noopener">在《气流:如何以及何时使用它</a>中，我们讨论了<a class="ae ko" href="https://airflow.apache.org/docs/" rel="noopener ugc nofollow" target="_blank">气流</a>的基本组件以及如何构建 DAG。一旦你开始构建 DAG，你会发现它变得很复杂。选择运算符和设置 DAG 结构需要一些时间。随着我们在<a class="ae ko" href="https://www.bluecore.com/" rel="noopener ugc nofollow" target="_blank"> Bluecore </a>的不断发展壮大，我们将继续寻找更好地创建和扩展数据管道的解决方案。以下是我们一路走来学到的一些东西。</p><h1 id="6bab" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">运算符:高级</h1><p id="6018" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">从基本概念开始，我们将讨论气流操作符的一些更实际的应用。在 Bluecore，我们开发了自己的<a class="ae ko" href="https://github.com/TriggerMail/incubator-airflow/blob/master/airflow/contrib/operators/kubernetes_operator.py" rel="noopener ugc nofollow" target="_blank">kubernetjoboperator</a>和<a class="ae ko" href="https://github.com/TriggerMail/incubator-airflow/blob/master/airflow/contrib/operators/app_engine_operator.py" rel="noopener ugc nofollow" target="_blank"> AppEngine(同步/异步)操作符</a>。这些都是开源的，所以请随意查看。气流也有自己的 KubernetesPodOperator 和 AppEngineOperator。PythonOperator、AppEngineOperators 和 KubernetesJobOperator 是我们使用的三个主要运算符。因此，这是我要讨论的三个问题。</p><h2 id="9767" class="ls kq it bd kr lt lu dn kv lv lw dp kz kb lx ly ld kf lz ma lh kj mb mc ll md bi translated">python 运算符</h2><p id="784c" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">PythonOperator 运行可从 DAG 调用的 python 函数。该运算符对于处理 DAG 中的大量简单工作非常有用。</p><p id="e403" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们使用 python 运算符的方法示例</p><ul class=""><li id="4d04" class="me mf it js b jt ju jx jy kb mg kf mh kj mi kn mj mk ml mm bi translated">设置气流变量</li><li id="7f42" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">在“气流”数据库上运行 SQL 查询</li><li id="d94b" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">将 xcom 值添加到“XCom”表中</li><li id="5c0c" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">发送数据狗指标</li></ul><h2 id="de38" class="ls kq it bd kr lt lu dn kv lv lw dp kz kb lx ly ld kf lz ma lh kj mb mc ll md bi translated">KubernetesJobOperator</h2><p id="4365" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">KubernetesJobOperator 从一个<a class="ae ko" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker </a>映像运行代码。这意味着它几乎可以做任何事情！</p><p id="ba7f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们使用 KubernetsJobOperator 的方法示例</p><ul class=""><li id="a3a8" class="me mf it js b jt ju jx jy kb mg kf mh kj mi kn mj mk ml mm bi translated">查询/写入数据库(Bigtable、BigQuery、Datastore 等)。)</li><li id="8c54" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">迁移数据</li><li id="36da" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">训练数据科学模型</li></ul><p id="6354" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是迄今为止对我们最有用的操作符，但也是使用起来最复杂的。如果你使用<a class="ae ko" href="https://cloud.google.com/gcp/?utm_source=google&amp;utm_medium=cpc&amp;utm_campaign=na-US-all-en-dr-bkws-all-all-trial-b-dr-1008076&amp;utm_content=text-ad-lpsitelinkCCexp2-any-DEV_c-CRE_113120492407-ADGP_Hybrid+%7C+AW+SEM+%7C+BKWS+%7C+US+%7C+en+%7C+BMM+~+Google+Cloud+Platform-KWID_43700009942847394-kwd-26415333781&amp;utm_term=KW_%2Bgoogle%20%2Bcloud%20%2Bplatform-ST_%2Bgoogle+%2Bcloud+%2Bplatform&amp;gclid=EAIaIQobChMIqcvU0vS76QIVI_3jBx0jXguvEAAYASAAEgL4L_D_BwE" rel="noopener ugc nofollow" target="_blank">谷歌云平台</a>并从<a class="ae ko" href="https://cloud.google.com/container-registry" rel="noopener ugc nofollow" target="_blank">谷歌容器注册表</a>中提取你的图片，这些是基本步骤</p><figure class="mt mu mv mw gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ms"><img src="../Images/b70440ac607198694dc8cbbf310d4582.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zs9ugsg6QW-JOOP1QcLTTA.png"/></div></div></figure><h2 id="f2e2" class="ls kq it bd kr lt lu dn kv lv lw dp kz kb lx ly ld kf lz ma lh kj mb mc ll md bi translated">示例:使用 Kubernetes 构建任务</h2><p id="ecd6" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">只要 Docker 映像在容器注册表中，代码就可以存在于任何地方。如果您将代码编写为脚本，那么您可以在操作符中将其用作命令，并在本地进行测试。在脚本中，接受参数并解析它们将允许 DAG 文件中的变量到达脚本。Kubernetes 的秘密也可以作为脚本可以使用的环境变量传入。</p><figure class="mt mu mv mw gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ne"><img src="../Images/93f20023c6900407c8a0ed19e20e763c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EpQzWBXeEdrSAy8LQUGixA.png"/></div></div><p class="nf ng gj gh gi nh ni bd b be z dk translated">代码由 docker 文件构建，并指定入口点。</p></figure><p id="065f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将 model_one_metrics.py 代码编译成映像后，就可以编写任务了。</p><figure class="mt mu mv mw gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nj"><img src="../Images/98f44fdcd0a849bb721349ee574f08b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NqnbYmSOvJHc54NvzLeNcQ.png"/></div></div><p class="nf ng gj gh gi nh ni bd b be z dk translated">KubernetesJobOperator 的示例代码</p></figure><h2 id="bab0" class="ls kq it bd kr lt lu dn kv lv lw dp kz kb lx ly ld kf lz ma lh kj mb mc ll md bi translated">应用工程师</h2><p id="602e" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">App Engine 操作员在<a class="ae ko" href="https://cloud.google.com/appengine" rel="noopener ugc nofollow" target="_blank"> Google App Engine (GAE) </a>中运行一个命令。Bluecore 也创建了两个操作符。分别是<a class="ae ko" href="https://github.com/TriggerMail/incubator-airflow/blob/master/airflow/contrib/operators/app_engine_operator.py" rel="noopener ugc nofollow" target="_blank"> AppEngineSyncOperator 和 appengineoperatorsync</a>。我们的大部分代码都是用 AppEngine 编写的，所以这些操作符有很多用处。</p><p id="e6d3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们使用 app engine 运算符的方式示例</p><ul class=""><li id="daed" class="me mf it js b jt ju jx jy kb mg kf mh kj mi kn mj mk ml mm bi translated">检索所有活动合作伙伴的列表</li><li id="5247" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">更新合作伙伴权限和功能</li><li id="124f" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">设置电子邮件发送时间</li><li id="46b4" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">压缩表格</li></ul><figure class="mt mu mv mw gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nk"><img src="../Images/a4053a695ec87ac0dcc26e32e2e78350.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PLg5DHCzEObojYEaKNPLBA.png"/></div></div></figure><h2 id="8957" class="ls kq it bd kr lt lu dn kv lv lw dp kz kb lx ly ld kf lz ma lh kj mb mc ll md bi translated">调试/Kubectl</h2><p id="70c6" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated"><a class="ae ko" href="https://medium.com/bluecore-engineering/kubernetes-pod-logging-in-the-airflow-ui-ed9ca6f37e9d" rel="noopener"> Pod 日志对于调试 DAG 问题非常有帮助。</a>在 UI 中点击任务即可找到。</p><div class="mt mu mv mw gt ab cb"><figure class="nl mx nm nn no np nq paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><img src="../Images/5cfbe703a31126f29a941eae38e8e2e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/format:webp/1*QEqI_R7UV_Xcov00o0CHOg.png"/></div></figure><figure class="nl mx nr nn no np nq paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><img src="../Images/91dab49865556ccf749ea6db1b9d31c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1318/format:webp/1*K3JQNSQd6tO8tPj05vri2w.png"/></div><p class="nf ng gj gh gi nh ni bd b be z dk ns di nt nu translated">气流用户界面中的日志页面。</p></figure></div><p id="1f3c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果这些日志还不够，使用<a class="ae ko" href="https://kubernetes.io/docs/reference/kubectl/overview/" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> kubectl </strong> </a> <strong class="js iu">研究 pod/worker/scheduler/web 日志。</strong></p><h1 id="e76f" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">DAG 结构和策略</h1><h2 id="71f3" class="ls kq it bd kr lt lu dn kv lv lw dp kz kb lx ly ld kf lz ma lh kj mb mc ll md bi translated">任务结构</h2><p id="537a" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">有两种不同的视图，底部是“图形视图”，右边是“树视图”在下面的 DAG 中，我们查询一个任务中所有伙伴的列表，但是在右边的 DAG 中，我们在每个伙伴的基础上查询使用“corec”模型的伙伴。该结构取决于运行一项任务所需的时间。正确的任务在一个任务中查询每个伙伴花费的时间太长，所以最好将任务拆分。</p><figure class="mt mu mv mw gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nv"><img src="../Images/efaf7c4d22c51c7f98fbe378cabe97a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M9fg5YQaxLzf6dCN8iRx-w.png"/></div></div><p class="nf ng gj gh gi nh ni bd b be z dk translated">更新变量的 Dag 的两种不同视图。左下方的 DAG 显示在“图形视图”中，右上方的 DAG 显示在“树视图”中。</p></figure><h2 id="25f0" class="ls kq it bd kr lt lu dn kv lv lw dp kz kb lx ly ld kf lz ma lh kj mb mc ll md bi translated">动态 DAG 创建</h2><p id="8cf8" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">我们有三种不同类型的共同推荐，我们在一个 DAG 中运行它们。每个合作伙伴对三个模型中的每一个都有三组不同的任务。这条狗变得又大又慢。现在，我们从一个 corecommendations DAG 文件中动态生成三个 DAG，并且我们可以在不同的时间设置计划，这样就不会一次占用太多的资源。</p><figure class="mt mu mv mw gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nw"><img src="../Images/bcdf634e5636ff583a98e2a2ea4d1898.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GpggFWJs2_9QMDXmvdSTlw.png"/></div></div><p class="nf ng gj gh gi nh ni bd b be z dk translated">corecommendations DAG 文件动态创建三个 DAG，每个模型一个。</p></figure><h2 id="a6db" class="ls kq it bd kr lt lu dn kv lv lw dp kz kb lx ly ld kf lz ma lh kj mb mc ll md bi translated">DAG 分离</h2><p id="f7c1" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">我们的一个模型有一些不同的 Dag。如果某些任务不依赖于当前 DAG 中的时间表或上游任务，则最好将 DAG 分开，尤其是在 DAG 需要经常运行，并且任务会降低 DAG 速度的情况下。</p><h2 id="0ada" class="ls kq it bd kr lt lu dn kv lv lw dp kz kb lx ly ld kf lz ma lh kj mb mc ll md bi translated">任务逻辑</h2><p id="54aa" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">我们曾经每周为每个合作伙伴运行两次模型。这导致 DAG 运行缓慢，因为所有任务都试图同时训练。为了解决这个问题，我们创建了一个合作伙伴 mod 7 的散列，结果是一周中运行该模型的那一天。加上三，我们得到第二天。这分散了每个合作伙伴的培训。</p><p id="dc6a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，每周只需要培训两次，但每天都需要“随机分配”。添加了涉及跳过的任务逻辑来处理这种情况。第一个任务决定应该采取哪条路径，并且，如果不是训练该伙伴的日子，则跳过训练和服务任务。</p><figure class="mt mu mv mw gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nx"><img src="../Images/e28d1bc0da23b6d609144ba271a64ead.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C4D5eYwyoeiN0gXsEz6AIA.png"/></div></div><p class="nf ng gj gh gi nh ni bd b be z dk translated">一个 DAG 中的两组不同的任务。左侧显示的是合作伙伴 a，右侧显示的是合作伙伴 b。在这次 DAG 运行中，是合作伙伴 a 而不是合作伙伴 b 进行训练。</p></figure><p id="b793" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">DAG 细分:</p><ol class=""><li id="0430" class="me mf it js b jt ju jx jy kb mg kf mh kj mi kn ny mk ml mm bi translated">决定走哪条路(搭档 a 训练，搭档 b 不训练)</li></ol><p id="4d95" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">2.将不需要的路径任务标记为“跳过”(需要传递给随机分配的虚拟任务)</p><p id="8cf3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">3.向<a class="ae ko" href="https://www.datadoghq.com/product/" rel="noopener ugc nofollow" target="_blank">数据狗</a>发送通过/失败指标</p><h1 id="4603" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">当气流不是最佳选择时</h1><p id="22e8" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">将<a class="ae ko" href="https://cloud.google.com/scheduler/docs/creating" rel="noopener ugc nofollow" target="_blank">谷歌云调度器</a>用于<a class="ae ko" href="https://en.wikipedia.org/wiki/Cron" rel="noopener ugc nofollow" target="_blank"> cron </a>作业可能更适合不需要扇入/扇出的简单管道。</p><p id="ffa4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当在 DAG 中调度大量任务时，Airfow 存在扩展问题。UI 在加载 DAG 时出现问题，这使得调试和检查变得困难。当试图加载这些大型 Dag 时，web pod 有时会崩溃</p><figure class="mt mu mv mw gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nz"><img src="../Images/26e48692942c354de819acd2fecb8429.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QZCrFKD-IOYfF8c90YPWGw.png"/></div></div></figure><p id="f992" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">目前，我们已经实施了一些变通办法来避免这个问题，但我们目前仍在研究改进的方法。这可能是气流不适合这种工作流程，也许<a class="ae ko" href="https://www.kubeflow.org/" rel="noopener ugc nofollow" target="_blank"> Kubeflow </a>或<a class="ae ko" href="https://argoproj.github.io/" rel="noopener ugc nofollow" target="_blank"> Argo </a>是更好的选择。让我知道，如果你有任何想法/意见缩放大型 Dag！</p><h1 id="add1" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">摘要</h1><p id="ec5f" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">在<a class="ae ko" href="https://medium.com/@alexagriffith/airflow-how-and-when-to-use-it-2e07108ac9f5" rel="noopener">气流:如何以及何时使用它</a>中，我们讨论了如何使用气流和创建 Dag 的基础知识。在本文中，我们以这些主题为基础，更详细地讨论了如何创建操作符和构建 DAG。具体来说，我们</p><ul class=""><li id="fcd7" class="me mf it js b jt ju jx jy kb mg kf mh kj mi kn mj mk ml mm bi translated">探究构建任务的更高级的方法</li><li id="a968" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">检查 DAG 结构和策略</li></ul><p id="0d2a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">气流是一个很好的工具。UI 使得监控、调度和设计 Dag 变得相当容易。当扩展超过 500 个任务的 Dag 时，气流开始变得困难。要么需要应用变通方法来保持 Dag 的可观察性，要么可能需要另一个管道软件。</p></div></div>    
</body>
</html>