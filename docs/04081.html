<html>
<head>
<title>mlmachine - GroupbyImputer, KFoldEncoder, and Skew Correction</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ml machine-group by inputr、KFoldEncoder 和倾斜校正</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/mlmachine-groupbyimputer-kfoldencoder-and-skew-correction-357f202d2212?source=collection_archive---------32-----------------------#2020-04-14">https://towardsdatascience.com/mlmachine-groupbyimputer-kfoldencoder-and-skew-correction-357f202d2212?source=collection_archive---------32-----------------------#2020-04-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/b44df831a1840f9d71f0df95d17cfb1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gb3xivOLieHujt2ybqOrpg.jpeg"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">图片由<a class="ae jd" href="https://pixabay.com/users/geralt-9301/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=2764820" rel="noopener ugc nofollow" target="_blank"> Gerd Altmann </a>从<a class="ae jd" href="https://pixabay.com/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=2764820" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>拍摄</p></figure><h2 id="cd31" class="je jf jg bd b dl jh ji jj jk jl jm dk jn translated" aria-label="kicker paragraph">多层机器</h2><div class=""/><div class=""><h2 id="cd2d" class="pw-subtitle-paragraph km jp jg bd b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dk translated">这个新的 Python 包加速了基于笔记本的机器学习实验</h2></div><h2 id="6a41" class="le lf jg bd lg lh li dn lj lk ll dp lm ln lo lp lq lr ls lt lu lv lw lx ly jm bi translated">TL；速度三角形定位法(dead reckoning)</h2><p id="e8fb" class="pw-post-body-paragraph lz ma jg mb b mc md kq me mf mg kt mh ln mi mj mk lr ml mm mn lv mo mp mq mr ij bi translated">mlmachine 是一个 Python 库，用于组织和加速基于笔记本的机器学习实验。</p><p id="3934" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">在本文中，我们使用 mlmachine 来完成原本需要大量编码和工作的操作，包括:</p><ul class=""><li id="b0ee" class="mx my jg mb b mc ms mf mt ln mz lr na lv nb mr nc nd ne nf bi translated">缺少值-评估和分组估算</li><li id="c7f3" class="mx my jg mb b mc ng mf nh ln ni lr nj lv nk mr nc nd ne nf bi translated">KFold 编码——无泄漏的奇异编码</li><li id="fe48" class="mx my jg mb b mc ng mf nh ln ni lr nj lv nk mr nc nd ne nf bi translated">Box、Cox、Yeo &amp; Johnson - Skew 校正器</li></ul><p id="89eb" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">查看这篇文章的<a class="ae jd" href="https://github.com/petersontylerd/mlmachine/blob/master/notebooks/mlmachine_part_2.ipynb" rel="noopener ugc nofollow" target="_blank"> Jupyter 笔记本</a>。</p><p id="559b" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">在 GitHub 上查看<a class="ae jd" href="https://github.com/petersontylerd/mlmachine" rel="noopener ugc nofollow" target="_blank">项目</a>。</p><p id="77c6" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">查看 mlmachine 系列的其他条目:</p><div class="ip iq gp gr ir nl"><a rel="noopener follow" target="_blank" href="/mlmachine-clean-ml-experiments-elegant-eda-pandas-pipelines-daba951dde0a"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd jq gy z fp nq fr fs nr fu fw jp bi translated">mlmachine -干净的 ML 实验，优雅的 EDA 和 Pandas 管道</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">这个新的 Python 包加速了基于笔记本的机器学习实验</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">towardsdatascience.com</p></div></div><div class="nu l"><div class="nv l nw nx ny nu nz ix nl"/></div></div></a></div><div class="ip iq gp gr ir nl"><a rel="noopener follow" target="_blank" href="/mlmachine-crowd-sourced-feature-selection-50cd2bbda1b7"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd jq gy z fp nq fr fs nr fu fw jp bi translated">mlmachine -众包特征选择</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">这个新的 Python 包加速了基于笔记本的机器学习实验</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">towardsdatascience.com</p></div></div><div class="nu l"><div class="oa l nw nx ny nu nz ix nl"/></div></div></a></div></div><div class="ab cl ob oc hu od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="ij ik il im in"><h1 id="c59c" class="oi lf jg bd lg oj ok ol lj om on oo lm kv op kw lq ky oq kz lu lb or lc ly os bi translated">缺少值-评估和分组估算</h1><p id="6caf" class="pw-post-body-paragraph lz ma jg mb b mc md kq me mf mg kt mh ln mi mj mk lr ml mm mn lv mo mp mq mr ij bi translated">让我们首先实例化两个<code class="fe ot ou ov ow b"><strong class="mb jq">Machine()</strong></code>对象，一个用于我们的训练数据，另一个用于我们的验证数据</p><figure class="ox oy oz pa gt is"><div class="bz fp l di"><div class="pb pc l"/></div></figure><h2 id="eab8" class="le lf jg bd lg lh li dn lj lk ll dp lm ln lo lp lq lr ls lt lu lv lw lx ly jm bi translated"><strong class="ak">评估</strong></h2><p id="ec3c" class="pw-post-body-paragraph lz ma jg mb b mc md kq me mf mg kt mh ln mi mj mk lr ml mm mn lv mo mp mq mr ij bi translated">每个<code class="fe ot ou ov ow b"><strong class="mb jq">Machine()</strong></code>对象包含一个以表格和图形形式总结缺失的方法:</p><figure class="ox oy oz pa gt is"><div class="bz fp l di"><div class="pb pc l"/></div></figure><figure class="ox oy oz pa gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pd"><img src="../Images/7b6b66378050840458042da875aa9fac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*br8CMWfY-sZsQPL4zXoGzw.png"/></div></div></figure><p id="4159" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">默认情况下，这个方法作用于与<code class="fe ot ou ov ow b"><strong class="mb jq">mlmachine_train</strong></code>相关联的<code class="fe ot ou ov ow b"><strong class="mb jq">data</strong></code>属性。让我们对验证数据集做同样的事情:</p><figure class="ox oy oz pa gt is"><div class="bz fp l di"><div class="pb pc l"/></div></figure><figure class="ox oy oz pa gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pd"><img src="../Images/41f2e0336fd7fadb896e77cff8e3be31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xleJGPmSfj1TiiY-kBoDgQ.png"/></div></div></figure><p id="c336" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">接下来，我们需要确定在训练数据中是否有缺失值的特征，而不是验证数据，反之亦然。这告诉我们应该如何设置我们的转换管道。例如，如果某个特征在验证数据集中有缺失值，但在训练数据集中没有，我们仍然希望在训练数据上对该特征进行拟合变换，以学习插补值，从而应用于验证数据集中的空值。</p><p id="6539" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">我们可以观察上面的表格和图像来比较两个数据集中的缺失状态，但是这可能很繁琐，尤其是对于大型数据集。相反，我们将利用我们的<code class="fe ot ou ov ow b"><strong class="mb jq">Machine()</strong></code>对象中的一个方法。我们简单地将验证数据集传递给<code class="fe ot ou ov ow b"><strong class="mb jq">mlmachine_titanic_train</strong></code>的方法<code class="fe ot ou ov ow b"><strong class="mb jq">missing_col_compare</strong></code>，该方法返回一个双向缺失汇总。</p><figure class="ox oy oz pa gt is"><div class="bz fp l di"><div class="pb pc l"/></div></figure><figure class="ox oy oz pa gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pe"><img src="../Images/6baae0cdfe3b9ff88fc4cea52cbdd77f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MeNzDEGGHLocKq9SNQ0RRA.png"/></div></div></figure><p id="2ce7" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">这里的关键观察是“Fare”完全填充在训练数据中，而不是验证数据中。我们需要确保我们的管道知道如何根据训练数据估算这些缺失值，尽管事实上训练数据在该特征中没有缺失任何值。</p><h2 id="4397" class="le lf jg bd lg lh li dn lj lk ll dp lm ln lo lp lq lr ls lt lu lv lw lx ly jm bi translated"><code class="fe ot ou ov ow b">GroupbyImputer</code></h2><p id="7bce" class="pw-post-body-paragraph lz ma jg mb b mc md kq me mf mg kt mh ln mi mj mk lr ml mm mn lv mo mp mq mr ij bi translated">mlmachine 包括一个名为<code class="fe ot ou ov ow b"><strong class="mb jq">GroupbyImputer()</strong></code>的转换器，它可以轻松执行 Scikit-learn 的<code class="fe ot ou ov ow b"><strong class="mb jq">SimpleImputer()</strong></code>提供的相同基本插补技术，但增加了根据数据集中的另一个特征进行分组的能力。让我们看一个例子:</p><figure class="ox oy oz pa gt is"><div class="bz fp l di"><div class="pb pc l"/></div></figure><p id="f7d8" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">在上面的代码片段中，我们指的是由“SibSp”分组的 input“Age”。我们将“Age”传递给<code class="fe ot ou ov ow b"><strong class="mb jq">null_column</strong></code>参数以指示哪一列包含空值，并将“SibSp”传递给<code class="fe ot ou ov ow b"><strong class="mb jq">groupby_column</strong></code>参数。<code class="fe ot ou ov ow b"><strong class="mb jq">strategy</strong></code>参数接收与 Scikit-learn 的<code class="fe ot ou ov ow b"><strong class="mb jq">SimpleImputer()</strong></code>相同的指令-“均值”、“中值”和“最频繁”。</p><p id="7ebb" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">为了检查学习到的值，我们可以显示对象的<code class="fe ot ou ov ow b"><strong class="mb jq">train_value</strong></code>属性，这是一个包含类别/值对的<code class="fe ot ou ov ow b"><strong class="mb jq">DataFrame</strong></code>:</p><figure class="ox oy oz pa gt is gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/9f781159ddffba7adc3af73530fb3d04.png" data-original-src="https://miro.medium.com/v2/resize:fit:584/format:webp/1*-tDO6xa-AhQvBnkkX_IeKg.png"/></div></figure><p id="f420" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated"><code class="fe ot ou ov ow b"><strong class="mb jq">GroupbyImputer()</strong></code>使用这些对来估算“年龄”中缺失的值。在不太可能的情况下，如果<code class="fe ot ou ov ow b"><strong class="mb jq">groupby_column</strong></code>中的某个级别在<code class="fe ot ou ov ow b"><strong class="mb jq">null_column</strong></code>中只有空值，那么与该级别相关的缺失值将被估算为整个特征的平均值、中值或众数。</p><h2 id="b22c" class="le lf jg bd lg lh li dn lj lk ll dp lm ln lo lp lq lr ls lt lu lv lw lx ly jm bi translated">归罪</h2><p id="e1e2" class="pw-post-body-paragraph lz ma jg mb b mc md kq me mf mg kt mh ln mi mj mk lr ml mm mn lv mo mp mq mr ij bi translated">现在我们将在<code class="fe ot ou ov ow b"><strong class="mb jq">PandasFeatureUnion()</strong></code>中使用<code class="fe ot ou ov ow b"><strong class="mb jq">GroupbyImputer()</strong></code>来估算训练和验证数据集中的空值。</p><figure class="ox oy oz pa gt is"><div class="bz fp l di"><div class="pb pc l"/></div></figure><p id="734a" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">此时，我们已经估算了所有的空值。这里是输出，仍然在一个<code class="fe ot ou ov ow b"><strong class="mb jq">DataFrame</strong></code>:</p><figure class="ox oy oz pa gt is gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/9dff8a890f351b58c4d5379da4b0b956.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*71h5FUBxCDe4HPjudqYOVw.jpeg"/></div></figure><p id="0b2c" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated"><code class="fe ot ou ov ow b"><strong class="mb jq">GroupbyImputer()</strong></code>在这个<code class="fe ot ou ov ow b"><strong class="mb jq">PandasFeatureUnion()</strong></code>操作中出现了两次。在第 4 行，我们通过特征“SibSp”分组来估算平均“年龄”值，在第 8 行，我们通过特征“Pclass”分组来估算平均“票价”值。</p><p id="d71f" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">“上船”和“船舱”的估算以简单的方式完成——“上船”简单地用模式估算，“船舱”用常数值“X”估算。</p><p id="843c" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">最后，我们在<code class="fe ot ou ov ow b"><strong class="mb jq">mlmachine_titanic_train.data</strong></code>上<code class="fe ot ou ov ow b"><strong class="mb jq">fit_transform()</strong></code>了<code class="fe ot ou ov ow b"><strong class="mb jq">PandasFeatureUnion()</strong></code>，并通过在<code class="fe ot ou ov ow b"><strong class="mb jq">mlmachine_titanic_valid.data</strong></code>上调用<code class="fe ot ou ov ow b"><strong class="mb jq">transform()</strong></code>来完成填充我们的空值。</p></div><div class="ab cl ob oc hu od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="ij ik il im in"><h1 id="55ab" class="oi lf jg bd lg oj ok ol lj om on oo lm kv op kw lq ky oq kz lu lb or lc ly os bi translated">KFold 编码——无泄漏的奇异编码</h1><p id="327e" class="pw-post-body-paragraph lz ma jg mb b mc md kq me mf mg kt mh ln mi mj mk lr ml mm mn lv mo mp mq mr ij bi translated">基于目标值的编码技术，如均值编码、CatBoost 编码和证据权重编码，经常在 Kaggle 竞赛中讨论。这些技术的主要优点是它们使用目标变量来通知编码特性的值。然而，这也带来了将目标信息泄露到编码值中的风险。</p><p id="7dc5" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">KFold 交叉验证有助于避免这个问题。关键是将编码值仅应用于折叠外观察值。这种可视化说明了一般模式:</p><figure class="ox oy oz pa gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ph"><img src="../Images/87a082abeee5260f9bf132096efa7749.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X4uxLMeIasto7RK__7xRvw.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">由<a class="ae jd" href="https://medium.com/@pouryaayria" rel="noopener"> Pourya </a>在<a class="ae jd" href="https://medium.com/@pouryaayria/k-fold-target-encoding-dfe9a594874b" rel="noopener">介质</a>上拍摄的照片</p></figure><ul class=""><li id="2b8f" class="mx my jg mb b mc ms mf mt ln mz lr na lv nb mr nc nd ne nf bi translated">将验证子集从训练数据集中分离出来。</li><li id="786b" class="mx my jg mb b mc ng mf nh ln ni lr nj lv nk mr nc nd ne nf bi translated">从训练数据和相关联的目标值中学习编码值。</li><li id="108e" class="mx my jg mb b mc ng mf nh ln ni lr nj lv nk mr nc nd ne nf bi translated">仅将学习值应用于验证观察。</li><li id="af4f" class="mx my jg mb b mc ng mf nh ln ni lr nj lv nk mr nc nd ne nf bi translated">对 K-1 剩余的折叠重复该过程。</li></ul><h2 id="a79d" class="le lf jg bd lg lh li dn lj lk ll dp lm ln lo lp lq lr ls lt lu lv lw lx ly jm bi translated">KFoldEncoder</h2><p id="98c4" class="pw-post-body-paragraph lz ma jg mb b mc md kq me mf mg kt mh ln mi mj mk lr ml mm mn lv mo mp mq mr ij bi translated">mlmachine 有一个名为<code class="fe ot ou ov ow b"><strong class="mb jq">KFoldEncoder()</strong></code>的类，它通过选择一个编码器来促进 KFold 编码。让我们使用一小部分功能来看看这是如何工作的。</p><p id="31f5" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">我们希望对两个特征进行目标编码:“Pclass”和“Age”。由于“年龄”是一个连续的特征，我们首先需要将值映射到 bin，这实际上是一个有序的分类列。我们在下面简单的<code class="fe ot ou ov ow b">PandasFeatureUnion</code>中处理所有这些:</p><figure class="ox oy oz pa gt is"><div class="bz fp l di"><div class="pb pc l"/></div></figure><figure class="ox oy oz pa gt is gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/5800bc6244fa548dfee323fdd0dcff45.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*enJrWcCDfIYcb548H8NZvA.png"/></div></figure><p id="9467" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">该操作返回“Age”的装箱版本，以及原始的“Age”和“Pclass”特性。</p><p id="8d56" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">接下来，我们使用包 category_encoders 提供的均值编码、CatBoost 编码和证据权重编码对“Pclass”和“Age_binned_5”进行目标编码。</p><figure class="ox oy oz pa gt is"><div class="bz fp l di"><div class="pb pc l"/></div></figure><figure class="ox oy oz pa gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pj"><img src="../Images/5e9c4cfb9c5bdc273b9d325a360c829a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kn2t9adlzL08yzWdi5MWrg.png"/></div></div></figure><p id="f231" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">让我们回顾一下关键的<code class="fe ot ou ov ow b"><strong class="mb jq">KFoldEncoder()</strong></code>参数:</p><ul class=""><li id="fc2e" class="mx my jg mb b mc ms mf mt ln mz lr na lv nb mr nc nd ne nf bi translated"><code class="fe ot ou ov ow b"><strong class="mb jq">target</strong></code>:我们<code class="fe ot ou ov ow b"><strong class="mb jq">mlmachine_titanic_train</strong></code>对象的目标属性</li><li id="93d0" class="mx my jg mb b mc ng mf nh ln ni lr nj lv nk mr nc nd ne nf bi translated"><code class="fe ot ou ov ow b"><strong class="mb jq">cv</strong></code>:交叉验证对象</li><li id="5f29" class="mx my jg mb b mc ng mf nh ln ni lr nj lv nk mr nc nd ne nf bi translated"><code class="fe ot ou ov ow b"><strong class="mb jq">encoder</strong></code>:目标编码器类</li></ul><p id="8101" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated"><code class="fe ot ou ov ow b"><strong class="mb jq">KFoldEncoder()</strong></code>学习训练数据上的编码值，并将这些值应用于失调观测值。</p><p id="e627" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">对于验证数据，过程更简单:我们计算应用于训练数据的平均出格编码，并将这些值应用于所有验证观察。</p></div><div class="ab cl ob oc hu od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="ij ik il im in"><h1 id="6137" class="oi lf jg bd lg oj ok ol lj om on oo lm kv op kw lq ky oq kz lu lb or lc ly os bi translated">Box、Cox、Yeo &amp; Johnson——我们的偏斜校正器</h1><h2 id="e226" class="le lf jg bd lg lh li dn lj lk ll dp lm ln lo lp lq lr ls lt lu lv lw lx ly jm bi translated">评价</h2><p id="73c3" class="pw-post-body-paragraph lz ma jg mb b mc md kq me mf mg kt mh ln mi mj mk lr ml mm mn lv mo mp mq mr ij bi translated">正如我们有一个快速评估缺失的方法一样，我们也有一个快速评估偏斜的方法。</p><figure class="ox oy oz pa gt is"><div class="bz fp l di"><div class="pb pc l"/></div></figure><figure class="ox oy oz pa gt is gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/a609d0ac2c79e36c742bacbe19091fbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:726/format:webp/1*JkYqsydnMz5n7kGXeTxtww.jpeg"/></div></figure><p id="f7dd" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated"><code class="fe ot ou ov ow b"><strong class="mb jq">skew_summary()</strong></code>方法返回一个<code class="fe ot ou ov ow b"><strong class="mb jq">DataFrame</strong></code>，它总结了每个特性的偏斜，以及一个“Percent zero”列，它告诉我们特性中为零的值的百分比。</p><h2 id="8946" class="le lf jg bd lg lh li dn lj lk ll dp lm ln lo lp lq lr ls lt lu lv lw lx ly jm bi translated">菱形校正</h2><p id="78e4" class="pw-post-body-paragraph lz ma jg mb b mc md kq me mf mg kt mh ln mi mj mk lr ml mm mn lv mo mp mq mr ij bi translated">mlmachine 包含一个名为<code class="fe ot ou ov ow b"><strong class="mb jq">DualTransformer()</strong></code>的类，默认情况下，它将 Yeo-Johnson 和 Box-Cox 变换应用于指定的特征，目的是纠正倾斜。Box-Cox 变换自动寻找使对数似然函数最大化的λ值。</p><p id="5b22" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">由于 Box-Cox 变换要求特征中的所有值都大于零，当违反此规则时，<code class="fe ot ou ov ow b"><strong class="mb jq">DualTransformer()</strong></code>应用两个简单特征调整中的一个:</p><ul class=""><li id="1870" class="mx my jg mb b mc ms mf mt ln mz lr na lv nb mr nc nd ne nf bi translated">如果要素中的最小值为零，则该要素中的每个值在变换前都会增加 1。</li><li id="47c1" class="mx my jg mb b mc ng mf nh ln ni lr nj lv nk mr nc nd ne nf bi translated">如果最小值小于零，则每个特征值将增加该特征中最小值的绝对值，再加上变换前的 1。</li></ul><p id="fe70" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">让我们使用<code class="fe ot ou ov ow b"><strong class="mb jq">DualTransformer()</strong></code>来看看我们是否可以最小化原始“年龄”特征中的偏差:</p><figure class="ox oy oz pa gt is"><div class="bz fp l di"><div class="pb pc l"/></div></figure><figure class="ox oy oz pa gt is gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/49d223d75b0f8acbdb63b83713ba9d00.png" data-original-src="https://miro.medium.com/v2/resize:fit:620/format:webp/1*4u1fQFZwVVmKXAKP_ZIQGQ.jpeg"/></div></figure><p id="7c78" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated"><code class="fe ot ou ov ow b"><strong class="mb jq">DualTransformer()</strong></code>增加了“Age_BoxCox”和“Age_YeoJohnson”功能。让我们再次执行<code class="fe ot ou ov ow b"><strong class="mb jq">skew_summary()</strong></code>,看看<code class="fe ot ou ov ow b"><strong class="mb jq">DualTransformer()</strong></code>是否解决了我们原始特性中的倾斜:</p><figure class="ox oy oz pa gt is"><div class="bz fp l di"><div class="pb pc l"/></div></figure><figure class="ox oy oz pa gt is gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/6b4c2ff21a6fcb2f00c2df1fc169584d.png" data-original-src="https://miro.medium.com/v2/resize:fit:716/format:webp/1*TwTQwBHZDwzl7l2LjWxUbA.jpeg"/></div></figure><p id="0ca7" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">“Age_BoxCox”和“Age_YeoJohnson”的偏斜度分别为 0.0286 和 0.0483。</p></div><div class="ab cl ob oc hu od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="ij ik il im in"><h1 id="a494" class="oi lf jg bd lg oj ok ol lj om on oo lm kv op kw lq ky oq kz lu lb or lc ly os bi translated">最后</h1><p id="ec01" class="pw-post-body-paragraph lz ma jg mb b mc md kq me mf mg kt mh ln mi mj mk lr ml mm mn lv mo mp mq mr ij bi translated">我们刚刚学习了如何使用 mlmachine 来执行新颖的插补技术、奇异的分类特征编码和有效的偏斜校正。</p><p id="30ba" class="pw-post-body-paragraph lz ma jg mb b mc ms kq me mf mt kt mh ln mu mj mk lr mv mm mn lv mw mp mq mr ij bi translated">查看<a class="ae jd" href="https://github.com/petersontylerd/mlmachine" rel="noopener ugc nofollow" target="_blank"> GitHub 库</a>，并继续关注其他专栏条目。</p></div></div>    
</body>
</html>