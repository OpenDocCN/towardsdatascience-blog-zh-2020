<html>
<head>
<title>Testing a Python-based API call with a data science charm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用数据科学的魅力测试基于 Python 的 API 调用</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/testing-a-python-based-api-call-with-a-data-science-charm-8aeee0d63432?source=collection_archive---------36-----------------------#2020-08-03">https://towardsdatascience.com/testing-a-python-based-api-call-with-a-data-science-charm-8aeee0d63432?source=collection_archive---------36-----------------------#2020-08-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/ae8ab00994a6dead5932e2f0299740e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P72Ig6f7F_m7KAccmzJnjg.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">尤利娅·卢卡希娜</p></figure><div class=""/><div class=""><h2 id="07b4" class="pw-subtitle-paragraph kf jh ji bd b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dk translated">使用 Python <a class="ae kx" href="https://docs.python.org/3/library/asyncio.html?highlight=asyncio%23module-asyncio" rel="noopener ugc nofollow" target="_blank"> asyncio </a>和<a class="ae kx" href="https://docs.python.org/3/library/concurrent.futures.html" rel="noopener ugc nofollow" target="_blank"> concurrent.futures </a>包测试 ThreadPoolExecutor 函数中的线程数量(max_workers 参数)的实验。</h2></div><h1 id="c80a" class="ky kz ji bd la lb lc ld le lf lg lh li ko lj kp lk kr ll ks lm ku ln kv lo lp bi translated">软件测试一瞥</h1><p id="22a1" class="pw-post-body-paragraph lq lr ji ls b lt lu kj lv lw lx km ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">随着计算机应用程序趋向于被授予更多的人类决策权，软件工程行业已经认识到测试是开发过程的一个基本部分。</p><p id="5f93" class="pw-post-body-paragraph lq lr ji ls b lt mm kj lv lw mn km ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">软件测试的方法多种多样。应用程序作为一个整体，或者作为集成系统，甚至是一个单元一个单元地被测试。我们有测试工程师、测试经理和测试人员。有提供外包手工测试的平台，也有自动化测试:从字面上看，应用程序操作其他应用程序，甚至经常模仿一个活生生的用户。</p><h1 id="062e" class="ky kz ji bd la lb lc ld le lf lg lh li ko lj kp lk kr ll ks lm ku ln kv lo lp bi translated">为什么要测试 API？</h1><p id="a8ee" class="pw-post-body-paragraph lq lr ji ls b lt lu kj lv lw lx km ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">案例研究是关于测试 API 调用性能的。Python asyncio 和 concurrent.futures 包用于运行多个 API 调用。他们将循环运行分成池，并以并行方式通过几个池，从而同时执行多个调用。这减少了总的执行时间。</p><p id="ec4b" class="pw-post-body-paragraph lq lr ji ls b lt mm kj lv lw mn km ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">最佳线程数的问题出现在以下方面。让我们想象一下，有一个移动应用程序访问一个提供 API 的开源数据库。我需要编写一个 API 调用来成功检索数据，并将其集成到应用程序中。这种集成应该包括接收数据的第一次处理。</p><p id="d7ce" class="pw-post-body-paragraph lq lr ji ls b lt mm kj lv lw mn km ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">正如我将在下一节中展示的，在最初处理数据的过程中，我遇到了一些问题。数据只能以小块的形式下载，因此，迫使我提出多个请求。这可能会降低应用程序的性能，破坏用户体验。</p><p id="6196" class="pw-post-body-paragraph lq lr ji ls b lt mm kj lv lw mn km ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">这个事实让我更加关注 API 调用本身，尽管最初，我的主要任务是在应用程序内部构建一个数据管道。</p><p id="7439" class="pw-post-body-paragraph lq lr ji ls b lt mm kj lv lw mn km ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">因此，我开始尝试 API 调用。</p><p id="cb4a" class="pw-post-body-paragraph lq lr ji ls b lt mm kj lv lw mn km ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">这个实验的目的是<strong class="ls jj">找出一个最佳的线程数量</strong>，或者并行调用的最大数量。这个数字有其限制，取决于不同的因素。</p><p id="ede1" class="pw-post-body-paragraph lq lr ji ls b lt mm kj lv lw mn km ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">在我经历了一些痛苦的错误之后，我设法坚持了一个特别的系统化的方法，我将会公开这个方法。这篇文章展示了完成测试代码的步骤，附在文章的最后。</p><h1 id="1e2a" class="ky kz ji bd la lb lc ld le lf lg lh li ko lj kp lk kr ll ks lm ku ln kv lo lp bi translated">对数据的第一次了解</h1><p id="8d8a" class="pw-post-body-paragraph lq lr ji ls b lt lu kj lv lw lx km ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我用一个电影数据库中的数据来说明本文，该数据库包含关于电影的信息，比如标题、发行日期、类型、演员和工作人员等等。API 调用应该获取特定电影类型的所有电影的数据。</p><p id="559a" class="pw-post-body-paragraph lq lr ji ls b lt mm kj lv lw mn km ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">我使用了一个通用的 Python 请求包来发出一个简单的请求，并检查这个请求是否有意义。我获取了一个 JSON 并将其打印到控制台。第一眼看上去不错。但后来似乎有一些人为强加的限制。我只能读到 500 页，收集 10，000 部电影。</p><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mr"><img src="../Images/bfaf7ad097a0c6a8fae8dbcb7254a3d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EDkDhb0y9j9MQw_mUuQjBw.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">发现页面限制</p></figure><p id="c44c" class="pw-post-body-paragraph lq lr ji ls b lt mm kj lv lw mn km ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">我查了一下电影的实际数量，结果是 20 部。</p><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mw"><img src="../Images/5c4bc3b796839c05fdaafa0b171996ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IF00GYNH50kDTVUW5fjSdg.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">每页/API 请求的结果</p></figure><p id="09de" class="pw-post-body-paragraph lq lr ji ls b lt mm kj lv lw mn km ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">我发出了第二个请求，表明我希望通过添加“&amp;page=2”来提取第 2 页。结果是相似的，只是我得到了另外 20 部电影。</p><p id="c65d" class="pw-post-body-paragraph lq lr ji ls b lt mm kj lv lw mn km ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">似乎我必须快速翻阅一大堆页面才能找到所有的电影。我添加了一个遍历 500 页的 for 循环。我抓取了 asyncio 和 concurrent.futures 包，通过使用多线程(我设置为 100)来加速 for 循环的执行。</p><p id="a23f" class="pw-post-body-paragraph lq lr ji ls b lt mm kj lv lw mn km ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">这一过程在几秒钟内完成，并成功收集了 10，000 部电影。</p><pre class="ms mt mu mv gt mx my mz na aw nb bi"><span id="5cca" class="nc kz ji my b gy nd ne l nf ng">import asyncio</span><span id="9886" class="nc kz ji my b gy nh ne l nf ng">import nest_asyncio</span><span id="3036" class="nc kz ji my b gy nh ne l nf ng">import concurrent.futures</span><span id="9b31" class="nc kz ji my b gy nh ne l nf ng">import requests</span><span id="d845" class="nc kz ji my b gy nh ne l nf ng">nest_asyncio.apply()</span><span id="d60e" class="nc kz ji my b gy nh ne l nf ng">movies = []</span><span id="eefd" class="nc kz ji my b gy nh ne l nf ng">async def main(url, m_workers):</span><span id="4ff0" class="nc kz ji my b gy nh ne l nf ng">with concurrent.futures.ThreadPoolExecutor(max_workers=m_workers) as executor:</span><span id="cde2" class="nc kz ji my b gy nh ne l nf ng">loop = asyncio.get_event_loop()</span><span id="8c4b" class="nc kz ji my b gy nh ne l nf ng">futures = [</span><span id="2797" class="nc kz ji my b gy nh ne l nf ng">loop.run_in_executor(</span><span id="5e52" class="nc kz ji my b gy nh ne l nf ng">executor,</span><span id="5aab" class="nc kz ji my b gy nh ne l nf ng">requests.get,</span><span id="f569" class="nc kz ji my b gy nh ne l nf ng">url + '&amp;page=' + str(i),</span><span id="c6a2" class="nc kz ji my b gy nh ne l nf ng">)</span><span id="41e3" class="nc kz ji my b gy nh ne l nf ng">for i in range(1, 501)</span><span id="c7da" class="nc kz ji my b gy nh ne l nf ng">]</span><span id="447c" class="nc kz ji my b gy nh ne l nf ng">for response in await asyncio.gather(*futures):</span><span id="4d2b" class="nc kz ji my b gy nh ne l nf ng">try:</span><span id="16c7" class="nc kz ji my b gy nh ne l nf ng">dict = response.json()</span><span id="fb0c" class="nc kz ji my b gy nh ne l nf ng">for item in dict['results']:</span><span id="71e6" class="nc kz ji my b gy nh ne l nf ng">movies.append(item)</span><span id="afec" class="nc kz ji my b gy nh ne l nf ng">except:</span><span id="7165" class="nc kz ji my b gy nh ne l nf ng">pass</span><span id="7245" class="nc kz ji my b gy nh ne l nf ng">loop = asyncio.get_event_loop()</span><span id="007b" class="nc kz ji my b gy nh ne l nf ng">loop.run_until_complete(main(my_url, 100))</span></pre><p id="35b2" class="pw-post-body-paragraph lq lr ji ls b lt mm kj lv lw mn km ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">但我必须记住，这个请求是为移动应用程序考虑的。到目前为止，我构建了请求代码，并使用运行在云中的 Google Colaboratory 检查了数据。</p><h1 id="ac1a" class="ky kz ji bd la lb lc ld le lf lg lh li ko lj kp lk kr ll ks lm ku ln kv lo lp bi translated">API 性能因素</h1><p id="4c33" class="pw-post-body-paragraph lq lr ji ls b lt lu kj lv lw lx km ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">正如一位 StackOverflow 开发者指出的那样，API 调用的速度取决于以下因素:</p><ul class=""><li id="4468" class="ni nj ji ls b lt mm lw mn lz nk md nl mh nm ml nn no np nq bi translated">网络速度和延迟</li><li id="daca" class="ni nj ji ls b lt nr lw ns lz nt md nu mh nv ml nn no np nq bi translated">服务器可用性和负载</li><li id="21a7" class="ni nj ji ls b lt nr lw ns lz nt md nu mh nv ml nn no np nq bi translated">数据有效负载的大小</li><li id="4ec5" class="ni nj ji ls b lt nr lw ns lz nt md nu mh nv ml nn no np nq bi translated">客户端设备资源</li><li id="9962" class="ni nj ji ls b lt nr lw ns lz nt md nu mh nv ml nn no np nq bi translated">客户代码</li><li id="81da" class="ni nj ji ls b lt nr lw ns lz nt md nu mh nv ml nn no np nq bi translated">在所有这些因素中，我只能控制网络、设备和客户端代码。</li></ul><h2 id="5423" class="nc kz ji bd la nw nx dn le ny nz dp li lz oa ob lk md oc od lm mh oe of lo og bi translated">网络</h2><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oh"><img src="../Images/aedf4d3d7c1e43cd46cc846f90a8774e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g42HIylRCqxtbehxEjYDkg.jpeg"/></div></div></figure><p id="bcbd" class="pw-post-body-paragraph lq lr ji ls b lt mm kj lv lw mn km ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">为了模拟移动网络速度，我将移动热点连接到笔记本电脑上。根据来自<a class="ae kx" href="https://speedtest.computerbild.de" rel="noopener ugc nofollow" target="_blank"> Computerbild.de </a>的信息，我所在位置的 LTE 网络显示速度如下:</p><h2 id="60fe" class="nc kz ji bd la nw nx dn le ny nz dp li lz oa ob lk md oc od lm mh oe of lo og bi translated">计算机网络服务器</h2><p id="3958" class="pw-post-body-paragraph lq lr ji ls b lt lu kj lv lw lx km ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我必须在测试中发现服务器的容量。我没有控制这个参数。</p><h2 id="8977" class="nc kz ji bd la nw nx dn le ny nz dp li lz oa ob lk md oc od lm mh oe of lo og bi translated">数据量</h2><p id="00dd" class="pw-post-body-paragraph lq lr ji ls b lt lu kj lv lw lx km ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">每个 API 调用发送同一个请求并下载相同数量的数据。这个实验不测试数据量的任何变化。</p><p id="4f63" class="pw-post-body-paragraph lq lr ji ls b lt mm kj lv lw mn km ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">每个请求返回一个字典。它的结果部分—一个列表—包含多达 20 个条目。每个条目都是一个有 14 个键和值的字典。</p><p id="d12b" class="pw-post-body-paragraph lq lr ji ls b lt mm kj lv lw mn km ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">使用另一个 JSON 解析器是可能的，但是我不认为标准解析器是个问题。</p><h2 id="6c21" class="nc kz ji bd la nw nx dn le ny nz dp li lz oa ob lk md oc od lm mh oe of lo og bi translated">最终用户设备</h2><p id="a8d0" class="pw-post-body-paragraph lq lr ji ls b lt lu kj lv lw lx km ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">由于数据将通过移动网络发送和接收，因此在实验中考虑了这一因素。</p><p id="2c28" class="pw-post-body-paragraph lq lr ji ls b lt mm kj lv lw mn km ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">我在本地的一台 Mac 电脑上用一台 Jupyter 笔记本进行了 API 调用测试，这台电脑有两个内核，运行速度为 1.7 GHz。</p><p id="5cff" class="pw-post-body-paragraph lq lr ji ls b lt mm kj lv lw mn km ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">网络连接，我用的是 iPhone 6。正如 Everymac.com 的<a class="ae kx" href="https://everymac.com/systems/apple/iphone/iphone-faq/iphone-processor-types.html" rel="noopener ugc nofollow" target="_blank">所说:</a></p><blockquote class="oi oj ok"><p id="3d90" class="lq lr ol ls b lt mm kj lv lw mn km ly om mo mb mc on mp mf mg oo mq mj mk ml im bi translated">它拥有双核，运行频率约为 1.4 GHz。</p></blockquote><p id="f568" class="pw-post-body-paragraph lq lr ji ls b lt mm kj lv lw mn km ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">采用 A13 芯片的最新 iOS 设备拥有六个 CPU 核心，两个 Lightings 和四个 Thunders。第一批运行频率为 2.66 GHz。(信息来自<a class="ae kx" href="https://www.wired.com/story/apple-a13-bionic-chip-iphone/" rel="noopener ugc nofollow" target="_blank">一篇连线文章</a>)。</p><p id="b918" class="pw-post-body-paragraph lq lr ji ls b lt mm kj lv lw mn km ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">来比较一下，最近一款典型的<a class="ae kx" href="https://www.samsung.com/global/galaxy/what-is/octa-core-processor/" rel="noopener ugc nofollow" target="_blank">三星智能手机</a>，<a class="ae kx" href="https://www.samsung.com/global/galaxy/what-is/octa-core-processor/" rel="noopener ugc nofollow" target="_blank">官网</a>上说，</p><blockquote class="oi oj ok"><p id="5df7" class="lq lr ol ls b lt mm kj lv lw mn km ly om mo mb mc on mp mf mg oo mq mj mk ml im bi translated">在八核(2.3GHz 四核+ 1.6GHz 四核)或四核(2.15GHz + 1.6GHz 双核)处理器上运行，具体取决于国家或运营商。</p></blockquote><p id="7999" class="pw-post-body-paragraph lq lr ji ls b lt mm kj lv lw mn km ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">在这方面，我的测试是一种最坏的情况。</p><h2 id="9c02" class="nc kz ji bd la nw nx dn le ny nz dp li lz oa ob lk md oc od lm mh oe of lo og bi translated">客户代码</h2><p id="ebb4" class="pw-post-body-paragraph lq lr ji ls b lt lu kj lv lw lx km ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">考虑到目前的限制，比如数据的规定结构，我只能在线程数量上做些调整。这基本上是客户端代码的主要变化。</p><h1 id="5e94" class="ky kz ji bd la lb lc ld le lf lg lh li ko lj kp lk kr ll ks lm ku ln kv lo lp bi translated">在线程数上循环</h1><p id="2d8b" class="pw-post-body-paragraph lq lr ji ls b lt lu kj lv lw lx km ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">所以，让我们回到主测试。</p><p id="99eb" class="pw-post-body-paragraph lq lr ji ls b lt mm kj lv lw mn km ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">我从云转移到本地运行时，并做了一些网络和硬件降级。</p><p id="af2b" class="pw-post-body-paragraph lq lr ji ls b lt mm kj lv lw mn km ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">在这个新环境中，我提出了几乎相同的要求。两次运行 100 个线程都抛出了类似的错误:</p><pre class="ms mt mu mv gt mx my mz na aw nb bi"><span id="d524" class="nc kz ji my b gy nd ne l nf ng">HTTPSConnectionPool(host=’api.host.org’, port=443): Max retries exceeded with url: apiurlwithapikey (Caused by NewConnectionError(‘&lt;urllib3.connection.VerifiedHTTPSConnection object at 0x10e44f2d0&gt;: Failed to establish a new connection: [Errno 8] nodename nor servname provided, or not known’))</span></pre><p id="557f" class="pw-post-body-paragraph lq lr ji ls b lt mm kj lv lw mn km ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">这意味着我用尽了网络或服务器，或者两者都用尽了。我把它减速到 50 个线程，让它运行两次，但还是出现了同样的错误。仅用 10 个线程，我就安全下载了所有 10，000 部电影。</p><p id="e41e" class="pw-post-body-paragraph lq lr ji ls b lt mm kj lv lw mn km ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">由于我仍然认为 10 个线程对于确保移动应用程序中令人满意的用户体验来说太少了，所以我引入了一个 for 循环，该循环多次运行 main()函数，以等于 10 的步长将最大活动线程数从 10 改为 100。</p><p id="b1f7" class="pw-post-body-paragraph lq lr ji ls b lt mm kj lv lw mn km ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">我添加了一个简单的跟踪方法，保存异步循环的持续时间、返回的电影数量、检查的页面数量和线程数量。持续时间是通过两个时间戳之间的差来测量的:一个在循环开始之前，一个在循环完成之后。</p><p id="769e" class="pw-post-body-paragraph lq lr ji ls b lt mm kj lv lw mn km ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">我把列表转换成字典，然后字典变成了熊猫的数据框。</p><p id="327d" class="pw-post-body-paragraph lq lr ji ls b lt mm kj lv lw mn km ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">为了防止服务器耗尽，我使用了时间包中的睡眠功能来安排通话中断。</p><pre class="ms mt mu mv gt mx my mz na aw nb bi"><span id="78cf" class="nc kz ji my b gy nd ne l nf ng">import asyncio</span><span id="8da9" class="nc kz ji my b gy nh ne l nf ng">import nest_asyncio</span><span id="e7be" class="nc kz ji my b gy nh ne l nf ng">import concurrent.futures</span><span id="ece8" class="nc kz ji my b gy nh ne l nf ng">import requests</span><span id="1e3b" class="nc kz ji my b gy nh ne l nf ng">from datetime import datetime</span><span id="4019" class="nc kz ji my b gy nh ne l nf ng">import time</span><span id="de29" class="nc kz ji my b gy nh ne l nf ng">import pandas</span><span id="6535" class="nc kz ji my b gy nh ne l nf ng">async def main(url, m_workers):</span><span id="3d4d" class="nc kz ji my b gy nh ne l nf ng">with concurrent.futures.ThreadPoolExecutor(max_workers=m_workers) as executor:</span><span id="4ead" class="nc kz ji my b gy nh ne l nf ng">try:</span><span id="2a98" class="nc kz ji my b gy nh ne l nf ng">loop = asyncio.get_event_loop()</span><span id="c71f" class="nc kz ji my b gy nh ne l nf ng">except:</span><span id="8087" class="nc kz ji my b gy nh ne l nf ng">pass</span><span id="ade9" class="nc kz ji my b gy nh ne l nf ng">try:</span><span id="6da4" class="nc kz ji my b gy nh ne l nf ng">futures = [</span><span id="25ef" class="nc kz ji my b gy nh ne l nf ng">loop.run_in_executor(</span><span id="98c9" class="nc kz ji my b gy nh ne l nf ng">executor,</span><span id="48b5" class="nc kz ji my b gy nh ne l nf ng">requests.get,</span><span id="b241" class="nc kz ji my b gy nh ne l nf ng">url + '&amp;page=' + str(i),</span><span id="9771" class="nc kz ji my b gy nh ne l nf ng">)</span><span id="06d4" class="nc kz ji my b gy nh ne l nf ng">for i in range(1, 501)</span><span id="c386" class="nc kz ji my b gy nh ne l nf ng">]</span><span id="8f52" class="nc kz ji my b gy nh ne l nf ng">except requests.exceptions.ConnectionError:</span><span id="1611" class="nc kz ji my b gy nh ne l nf ng">print("Connection refused")</span><span id="d3d3" class="nc kz ji my b gy nh ne l nf ng">pass</span><span id="66dc" class="nc kz ji my b gy nh ne l nf ng">for response in await asyncio.gather(*futures):</span><span id="e2b1" class="nc kz ji my b gy nh ne l nf ng">try:</span><span id="ebe6" class="nc kz ji my b gy nh ne l nf ng">dict = response.json()</span><span id="d066" class="nc kz ji my b gy nh ne l nf ng">for item in dict['results']:</span><span id="5a6b" class="nc kz ji my b gy nh ne l nf ng">movies.append(item)</span><span id="7392" class="nc kz ji my b gy nh ne l nf ng">except:</span><span id="c3f6" class="nc kz ji my b gy nh ne l nf ng">pass</span><span id="9ea3" class="nc kz ji my b gy nh ne l nf ng">nummoviesList = []</span><span id="007a" class="nc kz ji my b gy nh ne l nf ng">pagescheckedList = []</span><span id="95ad" class="nc kz ji my b gy nh ne l nf ng">itlastedList = []</span><span id="f526" class="nc kz ji my b gy nh ne l nf ng">maxworkersList = []</span><span id="990a" class="nc kz ji my b gy nh ne l nf ng">for threads in range(10,101,10):</span><span id="0fe2" class="nc kz ji my b gy nh ne l nf ng">try:</span><span id="e28e" class="nc kz ji my b gy nh ne l nf ng">movies = []</span><span id="a3ac" class="nc kz ji my b gy nh ne l nf ng">executorList = []</span><span id="451c" class="nc kz ji my b gy nh ne l nf ng">n = datetime.now()</span><span id="4c0c" class="nc kz ji my b gy nh ne l nf ng">loop = asyncio.get_event_loop()</span><span id="ecd1" class="nc kz ji my b gy nh ne l nf ng">try:</span><span id="cee2" class="nc kz ji my b gy nh ne l nf ng">loop.run_until_complete(main(genre_18_url, threads))</span><span id="9f8b" class="nc kz ji my b gy nh ne l nf ng">except:</span><span id="a312" class="nc kz ji my b gy nh ne l nf ng">pass</span><span id="def4" class="nc kz ji my b gy nh ne l nf ng">nummoviesList.append(len(movies))</span><span id="9132" class="nc kz ji my b gy nh ne l nf ng">pagescheckedList.append(len(movies) / 20)</span><span id="35c5" class="nc kz ji my b gy nh ne l nf ng">nn = datetime.now()</span><span id="8add" class="nc kz ji my b gy nh ne l nf ng">diff = nn - n</span><span id="ce35" class="nc kz ji my b gy nh ne l nf ng">itlastedList.append(diff)</span><span id="3bdc" class="nc kz ji my b gy nh ne l nf ng">maxworkersList.append(threads)</span><span id="9a03" class="nc kz ji my b gy nh ne l nf ng">except:</span><span id="9ddd" class="nc kz ji my b gy nh ne l nf ng">print("interrupted at ", threads)</span><span id="13d4" class="nc kz ji my b gy nh ne l nf ng">time.sleep(10)</span><span id="c5a2" class="nc kz ji my b gy nh ne l nf ng">resultsdict = {'threads': maxworkersList, 'movies': nummoviesList, 'pages': pagescheckedList, 'duration': itlastedList}</span><span id="5f30" class="nc kz ji my b gy nh ne l nf ng">testresults = pandas.DataFrame(resultsdict)</span></pre><p id="a965" class="pw-post-body-paragraph lq lr ji ls b lt mm kj lv lw mn km ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">我确实得到了大部分空的响应，但是有几个返回了正常的结果:</p><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div class="gh gi op"><img src="../Images/54588b600b85088f81c806d5104c8153.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*-_Dl21XXsCJRYI3KkaKIiQ.png"/></div></figure><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oq"><img src="../Images/69189588414f7f97b1a3039290b67c96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oY_9VUW0i2fILHArSq37NA.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">测试结果运行 1</p></figure><p id="b38b" class="pw-post-body-paragraph lq lr ji ls b lt mm kj lv lw mn km ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">这种趋势并不十分明显:当线程数量增加时，API 调用会变得更快，在 10 到 30 个线程之间，速度会大大加快。但是持续时间(显示为完成一个请求的秒数)变得不稳定，并且又增加了 100 个线程。</p><p id="c535" class="pw-post-body-paragraph lq lr ji ls b lt mm kj lv lw mn km ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">所有红点表示没有获取任何数据的运行。乍一看，持续时间/速度、线程数量和检索到的数据之间没有联系。我再次运行包装循环，结果明显不同:</p><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div class="gh gi or"><img src="../Images/b15cdc6605a07c0ad313bbb6569d4626.png" data-original-src="https://miro.medium.com/v2/resize:fit:798/format:webp/1*gX-OV_bwElubDmf00XTkvw.png"/></div></figure><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi os"><img src="../Images/21957768c4fd5ac89f0eb8cc6d1de4cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JRSl3oqnMUCUBS_v8Vwt4A.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">测试结果运行 2</p></figure><p id="2342" class="pw-post-body-paragraph lq lr ji ls b lt mm kj lv lw mn km ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">趋势几乎是一样的:越匆忙——我使用的线程越多——得不到数据的可能性就越大。</p><p id="eaea" class="pw-post-body-paragraph lq lr ji ls b lt mm kj lv lw mn km ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">另一件重要的事情，也是我继续测试的原因。从移动应用发出的每个 API 请求至少需要 8 分钟，这是一场灾难。没有用户会等这么久！</p><h1 id="ebf5" class="ky kz ji bd la lb lc ld le lf lg lh li ko lj kp lk kr ll ks lm ku ln kv lo lp bi translated">在下一个循环中包装代码</h1><p id="137f" class="pw-post-body-paragraph lq lr ji ls b lt lu kj lv lw lx km ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我本可以再按几次“运行”来重复循环，但是我决定添加另一个循环——我通常喜欢循环——并且我以代码结束:</p><pre class="ms mt mu mv gt mx my mz na aw nb bi"><span id="7a2a" class="nc kz ji my b gy nd ne l nf ng">import asyncio</span><span id="39a5" class="nc kz ji my b gy nh ne l nf ng">import nest_asyncio</span><span id="c094" class="nc kz ji my b gy nh ne l nf ng">import concurrent.futures</span><span id="64b6" class="nc kz ji my b gy nh ne l nf ng">import requests</span><span id="9c0b" class="nc kz ji my b gy nh ne l nf ng">from datetime import datetime</span><span id="cb8f" class="nc kz ji my b gy nh ne l nf ng">import time</span><span id="507d" class="nc kz ji my b gy nh ne l nf ng">import pandas</span><span id="2c14" class="nc kz ji my b gy nh ne l nf ng">async def main(url, max_workers):</span><span id="1442" class="nc kz ji my b gy nh ne l nf ng">with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:</span><span id="2e5e" class="nc kz ji my b gy nh ne l nf ng">try:</span><span id="a689" class="nc kz ji my b gy nh ne l nf ng">loop = asyncio.get_event_loop()</span><span id="2776" class="nc kz ji my b gy nh ne l nf ng">except:</span><span id="5275" class="nc kz ji my b gy nh ne l nf ng">pass</span><span id="2e1a" class="nc kz ji my b gy nh ne l nf ng">try:</span><span id="286c" class="nc kz ji my b gy nh ne l nf ng">futures = [</span><span id="2867" class="nc kz ji my b gy nh ne l nf ng">loop.run_in_executor(</span><span id="a894" class="nc kz ji my b gy nh ne l nf ng">executor,</span><span id="88fd" class="nc kz ji my b gy nh ne l nf ng">requests.get,</span><span id="656c" class="nc kz ji my b gy nh ne l nf ng">url + '&amp;page=' + str(i),</span><span id="1d15" class="nc kz ji my b gy nh ne l nf ng">)</span><span id="0597" class="nc kz ji my b gy nh ne l nf ng">for i in range(1, 501)</span><span id="f78a" class="nc kz ji my b gy nh ne l nf ng">]</span><span id="57df" class="nc kz ji my b gy nh ne l nf ng">except:</span><span id="d05a" class="nc kz ji my b gy nh ne l nf ng">pass</span><span id="4e0b" class="nc kz ji my b gy nh ne l nf ng">for response in await asyncio.gather(*futures):</span><span id="cb83" class="nc kz ji my b gy nh ne l nf ng">try:</span><span id="ed82" class="nc kz ji my b gy nh ne l nf ng">dict = response.json()</span><span id="b0d0" class="nc kz ji my b gy nh ne l nf ng">for item in dict['results']:</span><span id="0ff3" class="nc kz ji my b gy nh ne l nf ng">movies.append(item)</span><span id="beaa" class="nc kz ji my b gy nh ne l nf ng">except:</span><span id="afef" class="nc kz ji my b gy nh ne l nf ng">pass</span><span id="de5e" class="nc kz ji my b gy nh ne l nf ng">grandresult = pandas.DataFrame(columns = ['threads', 'movies', 'pages', 'duration', 'run'])</span><span id="2a93" class="nc kz ji my b gy nh ne l nf ng">for x in range (1,11):</span><span id="8026" class="nc kz ji my b gy nh ne l nf ng">nummoviesList = []</span><span id="3009" class="nc kz ji my b gy nh ne l nf ng">pagescheckedList = []</span><span id="9046" class="nc kz ji my b gy nh ne l nf ng">itlastedList = []</span><span id="60ca" class="nc kz ji my b gy nh ne l nf ng">maxworkersList = []</span><span id="0ba5" class="nc kz ji my b gy nh ne l nf ng">for max_workers in range(10,101,10):</span><span id="7126" class="nc kz ji my b gy nh ne l nf ng">movies = []</span><span id="ec08" class="nc kz ji my b gy nh ne l nf ng">try:</span><span id="e82e" class="nc kz ji my b gy nh ne l nf ng">executorList = []</span><span id="6eba" class="nc kz ji my b gy nh ne l nf ng">n = datetime.now()</span><span id="5b11" class="nc kz ji my b gy nh ne l nf ng">loop = asyncio.get_event_loop()</span><span id="f07f" class="nc kz ji my b gy nh ne l nf ng">try:</span><span id="a4f1" class="nc kz ji my b gy nh ne l nf ng">loop.run_until_complete(main(my_url, max_workers))</span><span id="1e4d" class="nc kz ji my b gy nh ne l nf ng">except:</span><span id="64dd" class="nc kz ji my b gy nh ne l nf ng">pass</span><span id="7b03" class="nc kz ji my b gy nh ne l nf ng">nummoviesList.append(len(movies))</span><span id="3d24" class="nc kz ji my b gy nh ne l nf ng">pagescheckedList.append(len(movies) / 20)</span><span id="05f2" class="nc kz ji my b gy nh ne l nf ng">nn = datetime.now()</span><span id="a4b1" class="nc kz ji my b gy nh ne l nf ng">diff = nn - n</span><span id="2c23" class="nc kz ji my b gy nh ne l nf ng">itlastedList.append(diff)</span><span id="4d46" class="nc kz ji my b gy nh ne l nf ng">maxworkersList.append(max_workers)</span><span id="08d0" class="nc kz ji my b gy nh ne l nf ng">except:</span><span id="e2d3" class="nc kz ji my b gy nh ne l nf ng">print("interrupted at ", max_workers)</span><span id="8425" class="nc kz ji my b gy nh ne l nf ng">time.sleep(10)</span><span id="41ff" class="nc kz ji my b gy nh ne l nf ng">resultsdict = {'threads': maxworkersList, 'movies': nummoviesList, 'pages': pagescheckedList, 'duration': itlastedList}</span><span id="0422" class="nc kz ji my b gy nh ne l nf ng">testresults = pandas.DataFrame(resultsdict)</span><span id="adc8" class="nc kz ji my b gy nh ne l nf ng">testresults['run'] = x</span><span id="d08c" class="nc kz ji my b gy nh ne l nf ng">grandresult = grandresult.append(testresults)</span><span id="5a2a" class="nc kz ji my b gy nh ne l nf ng">print('end run ' + str(x))</span><span id="11d3" class="nc kz ji my b gy nh ne l nf ng">time.sleep(60)</span></pre><p id="1862" class="pw-post-body-paragraph lq lr ji ls b lt mm kj lv lw mn km ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">正如你所看到的，有一个新的列:“运行。”它显示了运行的顺序。</p><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/e2fcb1a8a9c3576ce66f55d02056233d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1110/format:webp/1*yQY0W1aWMMdiTZ-buaSInQ.png"/></div></figure><p id="2bc8" class="pw-post-body-paragraph lq lr ji ls b lt mm kj lv lw mn km ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">我复制了一份，以防万一。然后我查看了每个线程数的平均性能。</p><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ou"><img src="../Images/174bef6dccc27c215efe80b551a4ec57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6N3QGpl5O0sm9T9CI1mTkA.png"/></div></div></figure><p id="b8c2" class="pw-post-body-paragraph lq lr ji ls b lt mm kj lv lw mn km ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">我只跑了 9 次，所以电影栏变得有点混乱。如果平均值低于 450，则每次并未获取所有电影。但是我们仍然可以看到成功的运行是最慢的。最快的只是不完整。</p><p id="a583" class="pw-post-body-paragraph lq lr ji ls b lt mm kj lv lw mn km ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">让我们把它全部放在一张图表上。</p><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ov"><img src="../Images/a8fb50592e19f1d320a86876016f8ac5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zveh3uGL2kAIC2VHqTtY2w.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">API 调用持续时间与线程数量:按运行分组</p></figure><p id="c81b" class="pw-post-body-paragraph lq lr ji ls b lt mm kj lv lw mn km ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">对于这个可视化，我删除了三个或四个异常值。圆点的颜色表示外部 for 循环中的不同运行。没有任何颜色聚类表示单次运行在性能上没有区别。只有一些线程起作用。</p><p id="9b78" class="pw-post-body-paragraph lq lr ji ls b lt mm kj lv lw mn km ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">然后，我根据是否获取了任何数据来给这些点着色(深紫色或 0 表示没有数据，黄色或 1 表示下载了所有电影)。</p><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ow"><img src="../Images/736c664aea5fba21a618da8f505b523f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hXRcHDKietDtOHeHDL5dcw.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">API 调用持续时间与线程数量:按成功或失败分组(0 =失败，1-成功)</p></figure><p id="d987" class="pw-post-body-paragraph lq lr ji ls b lt mm kj lv lw mn km ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">最后一个可视化结果表明，坚持 10 到 30 个线程的范围是有意义的。但即使是这些也大多不可靠。</p><h1 id="3589" class="ky kz ji bd la lb lc ld le lf lg lh li ko lj kp lk kr ll ks lm ku ln kv lo lp bi translated">测试较窄的范围</h1><p id="5467" class="pw-post-body-paragraph lq lr ji ls b lt lu kj lv lw lx km ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">在陷入沮丧之前，我想做最后一次尝试，开始另一个实验，在 1 到 30 的范围内测试线程数，并制作一个 1 的小缺口。</p><p id="caa7" class="pw-post-body-paragraph lq lr ji ls b lt mm kj lv lw mn km ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">下一张图表显示，几乎没有避免空白回答的选项。然而，一个接一个地发送请求持续的时间太长了:175 秒。</p><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ox"><img src="../Images/bb607543ddc64b2501117ca67d8fae47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ww3Juy18arzj_EXRsnK4uA.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">API 调用持续时间与线程数量:按成功或失败分组(0 =失败，1-成功)</p></figure><p id="8cad" class="pw-post-body-paragraph lq lr ji ls b lt mm kj lv lw mn km ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">我可以选择过滤掉最长的持续时间，但是这些都是可靠的配置。最后我把 25 秒以上的都去掉了。在图表的网格布局上，可以看到这是一个大部分点所在的范围，还有很多黄色的点。</p><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oy"><img src="../Images/103986b6bb96c5cbaf8de5a7ed8f40e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CH6nS4Q3nUrLEoAjJOwKPA.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">API 调用的持续时间与线程数量:按成功或失败分组(0 =失败，1-成功)。持续时间范围:从 1 到 25。</p></figure><p id="ba2a" class="pw-post-body-paragraph lq lr ji ls b lt mm kj lv lw mn km ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">没有一个群集具有可接受的持续时间和可靠的结果。在从 9 到 14 个线程的范围内，所有的点都是黄色的，因此，这些线程数确实下载了电影数据。</p><p id="f908" class="pw-post-body-paragraph lq lr ji ls b lt mm kj lv lw mn km ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">在这里，最终的选择变得棘手。</p><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oz"><img src="../Images/8766f0ba819c165bd627171a7e3e67cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RP7kv9T_tViwjOsw4gL9Kw.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">9 到 13 个线程缩放</p></figure><p id="94c9" class="pw-post-body-paragraph lq lr ji ls b lt mm kj lv lw mn km ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">10 线程和 13 线程点簇的持续时间最短。13 线程点簇比其他簇有更多的低持续时间。9 线程集群似乎是最稳定的:所有的点都挤在一起。</p><p id="a3c1" class="pw-post-body-paragraph lq lr ji ls b lt mm kj lv lw mn km ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">是时候做一些描述性统计了。我计算了平均值、中间值、偏差等。并按从低到高的顺序排列，最低的得到最高的等级。</p><p id="850f" class="pw-post-body-paragraph lq lr ji ls b lt mm kj lv lw mn km ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">不太科学，但最终有可能确定最佳结果。</p><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pa"><img src="../Images/8a5669398c0a0d67034eb125c471c231.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rvk9OuQ1QAfDRU7h_MthwQ.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">根据基于中值、平均值和标准偏差值的排名的最佳线程数量</p></figure><p id="888f" class="pw-post-body-paragraph lq lr ji ls b lt mm kj lv lw mn km ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated"><strong class="ls jj">这是给定条件下的最佳线程数。</strong></p><p id="b71c" class="pw-post-body-paragraph lq lr ji ls b lt mm kj lv lw mn km ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">尽管如此，移动应用程序会让用户再等 13 秒来完成基于 API 调用的操作。这是采取下一步性能优化措施的好理由，比如减少要检索的数据量，或者考虑其他来源。这也是重新思考移动应用背后的商业决策的一个很好的理由。</p><h1 id="f831" class="ky kz ji bd la lb lc ld le lf lg lh li ko lj kp lk kr ll ks lm ku ln kv lo lp bi translated">为什么都用 Python？</h1><p id="dafd" class="pw-post-body-paragraph lq lr ji ls b lt lu kj lv lw lx km ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">至少有三个原因可能会导致您更喜欢使用 Python 作为编写软件测试的语言:</p><ul class=""><li id="1519" class="ni nj ji ls b lt mm lw mn lz nk md nl mh nm ml nn no np nq bi translated">你一般爱 Python！</li><li id="32a3" class="ni nj ji ls b lt nr lw ns lz nt md nu mh nv ml nn no np nq bi translated">你想要一个持续的检查，在你的服务器上永久运行。</li><li id="df98" class="ni nj ji ls b lt nr lw ns lz nt md nu mh nv ml nn no np nq bi translated">您希望将结果传输到一个 AI 中，该 AI 会自动纠正被测试的主软件中的线程数量(或任何其他参数)。</li></ul><h1 id="d78f" class="ky kz ji bd la lb lc ld le lf lg lh li ko lj kp lk kr ll ks lm ku ln kv lo lp bi translated">一些要带走的东西</h1><p id="3bc9" class="pw-post-body-paragraph lq lr ji ls b lt lu kj lv lw lx km ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">当然，我用一段清晰的代码说明了这篇文章，这段代码实际上是从一片混乱中诞生的。因此，关于如何不搞砸你的测试的一些学习。</p><ul class=""><li id="c005" class="ni nj ji ls b lt mm lw mn lz nk md nl mh nm ml nn no np nq bi translated">了解你的数据。我进行了第一个实验，循环浏览 1000 页。然后我发现只有 500 个可用的键，当我最终想要访问返回的字典中的所有键时。</li><li id="f5ec" class="ni nj ji ls b lt nr lw ns lz nt md nu mh nv ml nn no np nq bi translated">追踪你的测试。运行一次尝试后，不要在 Jupyter 或 Colab 的同一个单元格中编辑代码:而是复制粘贴！以前的版本反而可以变成更好的。</li><li id="c915" class="ni nj ji ls b lt nr lw ns lz nt md nu mh nv ml nn no np nq bi translated">花时间构建有意义的数据可视化。在我构建了包含成功和失败运行的图表后，我可以缩小范围并消除第 10 个缺口。</li><li id="b1ef" class="ni nj ji ls b lt nr lw ns lz nt md nu mh nv ml nn no np nq bi translated">检查隐藏的依赖性和系统模式:使用你的数据 vizzes。</li><li id="974b" class="ni nj ji ls b lt nr lw ns lz nt md nu mh nv ml nn no np nq bi translated">一步一步地发展你的最终代码。更容易还原自己的逻辑来报告测试结果。</li><li id="a25a" class="ni nj ji ls b lt nr lw ns lz nt md nu mh nv ml nn no np nq bi translated">小步前进。匆忙最终会耗费更多的时间。</li><li id="17f9" class="ni nj ji ls b lt nr lw ns lz nt md nu mh nv ml nn no np nq bi translated">从一个描述性的和更一般的方法开始，定位你的挑战，然后缩小你的焦点。我从一个单一的 API 请求开始，并把它发展成一个由三个循环相互包裹的代码。</li><li id="9d88" class="ni nj ji ls b lt nr lw ns lz nt md nu mh nv ml nn no np nq bi translated">要系统！</li></ul><p id="dea5" class="pw-post-body-paragraph lq lr ji ls b lt mm kj lv lw mn km ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">特别是关于 API 测试，我也想分享一些技巧:</p><ul class=""><li id="340e" class="ni nj ji ls b lt mm lw mn lz nk md nl mh nm ml nn no np nq bi translated">在代码中放入大量的“try-except”对，后跟“pass”语句。这有助于您在不中断循环的情况下进入下一次运行。运行可能会由于与测试无关的临时网络问题而终止。</li><li id="a83e" class="ni nj ji ls b lt nr lw ns lz nt md nu mh nv ml nn no np nq bi translated">放一个具体的例外，比如:</li></ul><pre class="ms mt mu mv gt mx my mz na aw nb bi"><span id="195b" class="nc kz ji my b gy nd ne l nf ng">except requests.exceptions.ConnectionError:</span><span id="5b67" class="nc kz ji my b gy nh ne l nf ng">print(“Connection refused”)</span><span id="0134" class="nc kz ji my b gy nh ne l nf ng">pass</span></pre><p id="f090" class="pw-post-body-paragraph lq lr ji ls b lt mm kj lv lw mn km ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">它会给你一个提示，为什么会出现这个问题。您还可以获取本机错误消息，我在“循环遍历数字…”一节中展示了这一点</p><ul class=""><li id="fe0a" class="ni nj ji ls b lt mm lw mn lz nk md nl mh nm ml nn no np nq bi translated">在多线程请求之间放置一个“睡眠”中断。不要让服务器生气！</li><li id="23cf" class="ni nj ji ls b lt nr lw ns lz nt md nu mh nv ml nn no np nq bi translated">当尝试不同数量的线程时:从一个间隙开始，跟踪一个成功的范围；消除间隙并测试增益。</li><li id="3bdb" class="ni nj ji ls b lt nr lw ns lz nt md nu mh nv ml nn no np nq bi translated">尝试不同的网络容量和硬件。</li><li id="209b" class="ni nj ji ls b lt nr lw ns lz nt md nu mh nv ml nn no np nq bi translated"><strong class="ls jj">模仿最终用户设置。</strong></li></ul><p id="c98b" class="pw-post-body-paragraph lq lr ji ls b lt mm kj lv lw mn km ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">在这里，您可以找到本文的所有代码片段，包括最终的代码和数据可视化片段:</p><div class="is it gp gr iu pb"><a href="https://colab.research.google.com/drive/1TX98-OpRYkdGEA5Onu81EDfv5GOOKHH2" rel="noopener  ugc nofollow" target="_blank"><div class="pc ab fo"><div class="pd ab pe cl cj pf"><h2 class="bd jj gy z fp pg fr fs ph fu fw jh bi translated">谷歌联合实验室</h2><div class="pi l"><p class="bd b dl z fp pg fr fs ph fu fw dk translated">测试 API 调用中的线程数:asyncio 和 concurrent.futures 包(Python)colab.research.google.com</p></div></div><div class="pj l"><div class="pk l pl pm pn pj po ja pb"/></div></div></a></div><p id="24ae" class="pw-post-body-paragraph lq lr ji ls b lt mm kj lv lw mn km ly lz mo mb mc md mp mf mg mh mq mj mk ml im bi translated">测试愉快！</p></div></div>    
</body>
</html>