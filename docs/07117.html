<html>
<head>
<title>Predict Matches in League of Legends While Learning PyTorch Basics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在学习PyTorch基础知识的同时预测英雄联盟中的比赛</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/predict-matches-in-league-of-legends-while-learning-pytorch-basics-3dd43cf8d16f?source=collection_archive---------48-----------------------#2020-05-31">https://towardsdatascience.com/predict-matches-in-league-of-legends-while-learning-pytorch-basics-3dd43cf8d16f?source=collection_archive---------48-----------------------#2020-05-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4d22" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在PyTorch中为一个很酷的独特用例场景构建一个简单的逻辑回归模型的演练</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/53a10531ff33b6d7022c010f463444fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LR1pssm_lrVG2pnKspizzw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者理查德·索</p></figure><p id="0050" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">《英雄联盟》是我一直以来最喜欢的游戏之一，尽管我真的很不擅长。LOL是一个极具竞争力的MOBA，两个5人的队伍<em class="lr">(蓝队和红队)</em>相互对抗，以摧毁对方的基地(nexus)。获胜通常需要大量的团队合作、协调，或者对于一个倾斜的玩家来说需要“运气”。不管怎样，对于一个联盟玩家(即使他们是相当新的)来说，根据游戏记录的死亡人数和许多其他数据来判断哪个队可能会赢并不太难。机器学习模型可以预测的东西…… <em class="lr">(这应该是这篇文章执行得不好的铺垫)</em></p><p id="e99a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我也开始用PyTorch学一点机器/深度学习(通过这个<a class="ae ls" href="http://zerotogans.com" rel="noopener ugc nofollow" target="_blank"><em class="lr">py torch Zero to GANs</em></a>课程)。其中一个课程作业是用PyTorch为一些用例场景建立一个回归模型，因此，我们现在就在这里！<em class="lr">当然，我们可以使用</em> <code class="fe lt lu lv lw b"><em class="lr">scikit-learn</em></code> <em class="lr">并称之为完成，但是对我(和你)来说，重点是学习构建PyTorch模型的基本原理。</em> <strong class="kx ir">这将是我通过构建一个简单的英雄联盟比赛预测器</strong>来学习PyTorch的过程中的一次演练，该预测器将合理准确地确定任何一队获胜的机会。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi me"><img src="../Images/a56298771dcf850c36adc0b9bbbca52b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gejeBAG1aRDFWOL8Uxz3dg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae ls" href="https://xkcd.com/1838/" rel="noopener ugc nofollow" target="_blank"> xkcd </a></p></figure><h1 id="ef9d" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">数据集</h1><p id="f6ac" class="pw-post-body-paragraph kv kw iq kx b ky mx jr la lb my ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">首先，我使用了大约1万场英雄联盟排名赛的<a class="ae ls" href="https://www.kaggle.com/bobbyscience/league-of-legends-diamond-ranked-games-10-min" rel="noopener ugc nofollow" target="_blank"> Kaggle数据集</a>。每场比赛的数据都是在开始的10分钟内收集的。所有的比赛都是由高钻石到低大师级别的玩家参加的。幸运的是，我没有需要填充的缺失值，也没有需要一次性编码的非数字数据。总而言之，不需要太多的数据操作。</p><p id="9dd2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，我们将导入所有必需的库:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="b0a9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们会看到数据是什么样的:</p><pre class="kg kh ki kj gt ne lw nf ng aw nh bi"><span id="bf12" class="ni mg iq lw b gy nj nk l nl nm">df.read_csv('<!-- -->high_diamond_ranked_10min.csv')</span></pre><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="fb53" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个数据集有40列，但其中一些实际上是多余的。例如，如果你知道蓝队(<code class="fe lt lu lv lw b">blueKills</code>)的杀戮，这几乎直接转化为红队(<code class="fe lt lu lv lw b">redDeaths</code>)的死亡。基于这个推论，我们只需要这两个中的一个。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><pre class="kg kh ki kj gt ne lw nf ng aw nh bi"><span id="fa95" class="ni mg iq lw b gy nj nk l nl nm">df.drop(['gameId','redFirstBlood','blueTotalGold','redTotalGold','blueTotalExperience','redTotalExperience','redGoldDiff','redExperienceDiff','redKills','redDeaths'], axis=1, inplace=True)</span></pre><p id="13ba" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这使得我们只剩下30列，包括标签列。这个数据集的标签<em class="lr">(我们想要预测的)</em>是列<code class="fe lt lu lv lw b">blueWins</code>，0或1表示蓝方是否在游戏的剩余时间内获胜。最后，我们将标签与功能分开…</p><pre class="kg kh ki kj gt ne lw nf ng aw nh bi"><span id="2d16" class="ni mg iq lw b gy nj nk l nl nm">targets = df[['blueWins']].values #only the `blueWins` column<br/>features = df.drop('blueWins', axis=1).values #all the other columns</span></pre><p id="1da7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">…拆分数据(80/10/10拆分用于培训、验证和测试),并将它们转化为PyTorch张量…</p><pre class="kg kh ki kj gt ne lw nf ng aw nh bi"><span id="5ac2" class="ni mg iq lw b gy nj nk l nl nm">test_size = int(.10 * 9879) <em class="lr"># 10% of the total size of the dataset</em><br/>val_size = test_size<br/>train_size = 9879 - test_size*2<br/>train_size , val_size, test_size</span><span id="1316" class="ni mg iq lw b gy nn nk l nl nm">dataset = TensorDataset(torch.tensor(features).float(), torch.from_numpy(targets).float()) # turning arrays into tensors</span><span id="739f" class="ni mg iq lw b gy nn nk l nl nm">train_ds, val_ds, test_ds = random_split(dataset, [train_size, val_size, test_size]) # doing an 80/10/10 split on the data</span></pre><p id="fd09" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">…并用批处理大小<code class="fe lt lu lv lw b">128</code>从它们中生成DataLoader对象。</p><pre class="kg kh ki kj gt ne lw nf ng aw nh bi"><span id="9f6f" class="ni mg iq lw b gy nj nk l nl nm">batch_size = 128</span><span id="f843" class="ni mg iq lw b gy nn nk l nl nm">#making data loader objects out of the splits<br/>train_loader = DataLoader(train_ds, batch_size, shuffle=True)<br/>val_loader = DataLoader(val_ds, batch_size)<br/>test_loader = DataLoader(test_ds, batch_size)</span></pre></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="5300" class="mf mg iq bd mh mi no mk ml mm np mo mp jw nq jx mr jz nr ka mt kc ns kd mv mw bi translated">模型</h1><p id="cc25" class="pw-post-body-paragraph kv kw iq kx b ky mx jr la lb my ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">好吧，这就是“有趣”的开始！是时候用PyTorch做logistic回归模型了。以下是我在构建这个过程中的思路:</p><ul class=""><li id="b215" class="nt nu iq kx b ky kz lb lc le nv li nw lm nx lq ny nz oa ob bi translated">一个逻辑回归模型在我们的PyTorch模型中只需要一个<code class="fe lt lu lv lw b">nn.Linear</code>层，接受29个输入，输出1: <code class="fe lt lu lv lw b">nn.Linear(29, 1)</code>。</li><li id="6fc0" class="nt nu iq kx b ky oc lb od le oe li of lm og lq ny nz oa ob bi translated">因为我们预测的值是从0到1，使用<code class="fe lt lu lv lw b">nn.Sigmoid()</code>会将模型的输出缩小到这个范围。</li><li id="5957" class="nt nu iq kx b ky oc lb od le oe li of lm og lq ny nz oa ob bi translated">除了一个可能不可微的精度指标<em class="lr">(这将意味着梯度无法确定，而这是模型在训练期间改进所必需的)</em>，我们将如何计算模型的“错误”程度？快速浏览一下<a class="ae ls" href="https://pytorch.org/docs/stable/nn.functional.html#torch.nn.functional.binary_cross_entropy" rel="noopener ugc nofollow" target="_blank"> PyTorch文档</a>可以得到成本函数:<code class="fe lt lu lv lw b">binary_cross_entropy</code>。</li><li id="4170" class="nt nu iq kx b ky oc lb od le oe li of lm og lq ny nz oa ob bi translated">因为准确性度量不能用于模型训练，并不意味着它不应该被实现！在这种情况下，准确性将通过阈值来衡量，如果模型预测和实际标签之间的差异低于该阈值，则进行计数。</li><li id="fe78" class="nt nu iq kx b ky oc lb od le oe li of lm og lq ny nz oa ob bi translated">我们希望跟踪每个历元后的验证损失/精度，每次这样做时，我们必须确保梯度没有被跟踪。</li><li id="7340" class="nt nu iq kx b ky oc lb od le oe li of lm og lq ny nz oa ob bi translated">我们希望打印出每隔几个时期的平均验证损失和精确度。</li></ul><p id="566c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">综上所述，实现如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh nd l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">定义一些变量供以后使用。</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">我们的模型“LOLModel”的python类。</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">精度函数。</p></figure><p id="0f38" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后，我们需要做一个训练循环，并决定使用哪个优化器。对于优化器，在首先尝试SGD之后，我选择了Adam:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">定义训练循环，由“fit()”函数定义。</p></figure><p id="204d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们定义了一个<code class="fe lt lu lv lw b">evaluate()</code>和<code class="fe lt lu lv lw b">fit()</code>函数，后者是主训练循环，它:</p><ol class=""><li id="8404" class="nt nu iq kx b ky kz lb lc le nv li nw lm nx lq oi nz oa ob bi translated">将一批数据输入模型</li><li id="7cfa" class="nt nu iq kx b ky oc lb od le oe li of lm og lq oi nz oa ob bi translated">以设定的学习率应用渐变</li><li id="1ead" class="nt nu iq kx b ky oc lb od le oe li of lm og lq oi nz oa ob bi translated">根据验证数据测试模型，得出验证损失/准确性</li><li id="46dd" class="nt nu iq kx b ky oc lb od le oe li of lm og lq oi nz oa ob bi translated">将数据追加到数组<code class="fe lt lu lv lw b">history</code>中进行绘图</li></ol></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="6739" class="mf mg iq bd mh mi no mk ml mm np mo mp jw nq jx mr jz nr ka mt kc ns kd mv mw bi translated">训练&amp;最后的揭示</h1><p id="d791" class="pw-post-body-paragraph kv kw iq kx b ky mx jr la lb my ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">总之，对于<strong class="kx ir">超参数</strong>，我训练了<code class="fe lt lu lv lw b">750</code>个时期，学习率为<code class="fe lt lu lv lw b">0.0001</code>:</p><pre class="kg kh ki kj gt ne lw nf ng aw nh bi"><span id="93d8" class="ni mg iq lw b gy nj nk l nl nm">model = LOLModel() #initiate the model</span></pre><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">让我们首先确保数据正确地通过模型。</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh nd l"/></div></figure><p id="4bf2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最终验证损失和精度分别为<code class="fe lt lu lv lw b">0.5494</code>和<code class="fe lt lu lv lw b">0.7209</code><em class="lr">(该模型中精度从0到1测量)</em>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh nd l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在这里，我们可以看到模型在每个时期迭代时验证准确性的变化。大约在公元150年有一个急剧的增长，并且在<code class="fe lt lu lv lw b">.8 accuracy since.</code>附近徘徊</p></figure><p id="51e9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，在过去的10%分割中测试模型(请击鼓！):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh nd l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">忽略' val_loss '和' val_acc '！</p></figure><p id="d48a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用<code class="fe lt lu lv lw b">evaluate()</code>，我们发现该模型在预测LOL比赛结果时的准确率约为74.5%，不算太差！</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="e7bd" class="mf mg iq bd mh mi no mk ml mm np mo mp jw nq jx mr jz nr ka mt kc ns kd mv mw bi translated">结论</h1><p id="37d6" class="pw-post-body-paragraph kv kw iq kx b ky mx jr la lb my ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">总而言之，我认为这是我的一次成功。我学到了很多关于在PyTorch中制作模型的基础知识，即使模型很简单。更酷的是:我很开心地看到我做的一些事情最终得到了很好的解决！希望你能像我做模型一样喜欢阅读这个过程。无论如何，快乐编码(或继续玩联赛)！</p><blockquote class="oj ok ol"><p id="12be" class="kv kw lr kx b ky kz jr la lb lc ju ld om lf lg lh on lj lk ll oo ln lo lp lq ij bi translated">如果你想知道这个迷你项目使用的jupyter笔记本的来源，请看这里:<a class="ae ls" href="https://jovian.ml/richardso21/lol-logistic" rel="noopener ugc nofollow" target="_blank">https://jovian.ml/richardso21/lol-logistic</a>。</p></blockquote></div></div>    
</body>
</html>