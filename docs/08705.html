<html>
<head>
<title>Build a Dash Web App for Binary Classification Model Selection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为二进制分类模型选择构建一个 Dash Web 应用程序</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/build-a-dash-web-app-for-binary-classification-model-selection-56ee1636b461?source=collection_archive---------44-----------------------#2020-06-23">https://towardsdatascience.com/build-a-dash-web-app-for-binary-classification-model-selection-56ee1636b461?source=collection_archive---------44-----------------------#2020-06-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="7801" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" rel="noopener" target="_blank" href="https://towardsdatascience.com/data-science-in-the-real-world/home">现实世界中的数据科学</a></h2><div class=""/><div class=""><h2 id="ecf3" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">自动管理机器学习视觉诊断的汇编</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/d4b18eef3456d496af48c9e22b2e4d9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kn1FOoxVrXmoGQuW"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="4eeb" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这篇文章展示了我开发的<a class="ae md" href="https://github.com/taylorplumer/classifiers-dash" rel="noopener ugc nofollow" target="_blank">分类器 dash </a> web 应用工具的一个用例，该工具用于自动管理二进制分类问题的机器学习视觉诊断汇编。这款网络应用程序提高了现有从业者的效率，增强了他们在建模选择过程中的交互性。此外，崭露头角的数据科学家和机器学习工程师可以获得一个额外的好处，即磨练他们对常见分类评估评分指标和基准的直觉。</p><h2 id="7901" class="me mf it bd mg mh mi dn mj mk ml dp mm lq mn mo mp lu mq mr ms ly mt mu mv iz bi translated">灵感</h2><p id="c949" class="pw-post-body-paragraph lh li it lj b lk mw kd lm ln mx kg lp lq my ls lt lu mz lw lx ly na ma mb mc im bi translated">这篇文章和网络应用的灵感来自于<a class="ae md" href="https://www.scikit-yb.org/en/latest/" rel="noopener ugc nofollow" target="_blank"> Yellowbrick </a>项目的<a class="ae md" href="https://github.com/DistrictDataLabs/yellowbrick/issues/1044" rel="noopener ugc nofollow" target="_blank">问题</a>“创建多个模型分数的一目了然的表示，以便我可以轻松地比较和对比不同的模型实例。”这种工具也有助于分析师在进入<em class="nb">超参数调整</em>阶段之前获得对<em class="nb">算法选择</em>的直觉。</p><p id="cbd2" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">利用<a class="ae md" href="https://plotly.com/dash/" rel="noopener ugc nofollow" target="_blank"> Dash by Plotly </a>的交互性，我扩展了这个概念，以合并现有的黄砖分类可视化，命名为 visualizers。在上面的标题图像中可以找到我们将在此用例中使用的内容的快照。</p><h2 id="9623" class="me mf it bd mg mh mi dn mj mk ml dp mm lq mn mo mp lu mq mr ms ly mt mu mv iz bi translated">用例</h2><p id="1b2a" class="pw-post-body-paragraph lh li it lj b lk mw kd lm ln mx kg lp lq my ls lt lu mz lw lx ly na ma mb mc im bi translated">本例中使用的数据是来自 UCI 机器学习知识库的<a class="ae md" href="http://archive.ics.uci.edu/ml/datasets/default+of+credit+card+clients" rel="noopener ugc nofollow" target="_blank">‘信用卡客户数据集的默认值’</a>。该数据集由台湾的客户违约付款组成。我们将使用它对分类的二元结果(可信或不可信的客户端)的模型性能进行评分。</p><p id="40cd" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">数据集包括一个二元变量“默认付款”，作为响应变量。有 23 个预测变量，包括人口统计信息、过去付款历史、账单金额等。</p><p id="56b4" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">数据已经被清理了，所以我们可以进入有趣的部分——建模！</p><h2 id="8a2f" class="me mf it bd mg mh mi dn mj mk ml dp mm lq mn mo mp lu mq mr ms ly mt mu mv iz bi translated">用于模型选择的模型</h2><p id="9aeb" class="pw-post-body-paragraph lh li it lj b lk mw kd lm ln mx kg lp lq my ls lt lu mz lw lx ly na ma mb mc im bi translated">在深入研究该工具之前，提供该工具在工作流中最有用的位置的上下文会很有帮助。我是 Arun Kumar 等人提供的<a class="ae md" href="http://pages.cs.wisc.edu/~arun/vision/SIGMODRecord15.pdf" rel="noopener ugc nofollow" target="_blank">模型选择三重</a>框架的粉丝</p><p id="e88e" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这三个阶段是:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/c853e93d7ddb6b89f6eccef0377991e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rbBi4DTSUJGpoAQD"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">Benjamin Bengfort 演讲的幻灯片，<a class="ae md" href="https://www.slideshare.net/BenjaminBengfort/visualizing-model-selection-with-scikityellowbrick-an-introduction-to-developing-visualizers" rel="noopener ugc nofollow" target="_blank">“用 Scikit-Yellowbrick 可视化模型选择:开发可视化工具简介”</a></p></figure><p id="26f3" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们的用例位于“算法选择”阶段，因为我们将使用 web 应用程序来缩小搜索空间，而不是执行详尽的搜索。</p><p id="6f5f" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><em class="nb">那么，为什么要用仪表板来分析模型性能呢？</em> <strong class="lj jd">因为视觉诊断对于建立更有效的机器学习的直觉至关重要！</strong></p><p id="28b7" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">..仪表板的交互性有助于获得更加无缝的 UX 体验，因为您可以避免在笔记本电脑上查看型号性能输出时看似无限的滚动。如果有大量支持数据可视化，这种滚动密集型练习尤其如此。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h2 id="2efe" class="me mf it bd mg mh mi dn mj mk ml dp mm lq mn mo mp lu mq mr ms ly mt mu mv iz bi translated">装置</h2><p id="9a7e" class="pw-post-body-paragraph lh li it lj b lk mw kd lm ln mx kg lp lq my ls lt lu mz lw lx ly na ma mb mc im bi translated">首先，克隆 Github 存储库</p><pre class="ks kt ku kv gt ne nf ng nh aw ni bi"><span id="ecba" class="me mf it nf b gy nj nk l nl nm">git clone <a class="ae md" href="https://github.com/taylorplumer/classifiers-dash" rel="noopener ugc nofollow" target="_blank">https://github.com/taylorplumer/classifiers-dash</a></span></pre><p id="e444" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">创建虚拟环境(推荐)后，可以使用以下命令安装依赖项:</p><pre class="ks kt ku kv gt ne nf ng nh aw ni bi"><span id="a871" class="me mf it nf b gy nj nk l nl nm">pip install -r requirements.txt</span></pre><h2 id="4be5" class="me mf it bd mg mh mi dn mj mk ml dp mm lq mn mo mp lu mq mr ms ly mt mu mv iz bi translated">配置</h2><p id="8f05" class="pw-post-body-paragraph lh li it lj b lk mw kd lm ln mx kg lp lq my ls lt lu mz lw lx ly na ma mb mc im bi translated">config.py 将是最需要动手操作的文件，因为我们将在这里为手头的问题进行必要的配置。</p><p id="01b8" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在此使用案例中，我们将探索各种流行的二元分类算法，这些算法可用作 sklearn 估计器，如高斯朴素贝叶斯、逻辑回归、随机森林和梯度增强。</p><p id="ead5" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">使用的黄砖可视化工具来自现有分类可视化工具的<a class="ae md" href="https://www.scikit-yb.org/en/latest/api/classifier/" rel="noopener ugc nofollow" target="_blank">套件。</a></p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nn nd l"/></div></figure><p id="a505" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">*请注意，需要导入克隆的 repo 中默认情况下未提供的任何 sklearn 评估程序和/或 yellowbrick 可视化程序。</p><h2 id="3862" class="me mf it bd mg mh mi dn mj mk ml dp mm lq mn mo mp lu mq mr ms ly mt mu mv iz bi translated">数据处理</h2><p id="55a8" class="pw-post-body-paragraph lh li it lj b lk mw kd lm ln mx kg lp lq my ls lt lu mz lw lx ly na ma mb mc im bi translated">在项目的根目录中运行以下命令来设置数据和图像。目标变量应该是 csv 文件中的第一列，然后是许多预测变量。</p><pre class="ks kt ku kv gt ne nf ng nh aw ni bi"><span id="af86" class="me mf it nf b gy nj nk l nl nm">python3 process_data.py credit.csv</span></pre><p id="b6a8" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">保存的输出如下:</p><ol class=""><li id="2fac" class="no np it lj b lk ll ln lo lq nq lu nr ly ns mc nt nu nv nw bi translated">sk learn . metrics . classification _ report 中每个模型的模型分数的 csv 文件</li><li id="7c69" class="no np it lj b lk nx ln ny lq nz lu oa ly ob mc nt nu nv nw bi translated">黄砖可视化保存为 png 文件。</li></ol><h2 id="edf0" class="me mf it bd mg mh mi dn mj mk ml dp mm lq mn mo mp lu mq mr ms ly mt mu mv iz bi translated">仪表板应用</h2><p id="f116" class="pw-post-body-paragraph lh li it lj b lk mw kd lm ln mx kg lp lq my ls lt lu mz lw lx ly na ma mb mc im bi translated">在描述组件之前，让我们运行 Dash Plotly web 应用程序。</p><pre class="ks kt ku kv gt ne nf ng nh aw ni bi"><span id="1eee" class="me mf it nf b gy nj nk l nl nm">python3 app.py</span></pre><p id="d9ca" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">该应用程序将在本地运行于<a class="ae md" href="http://127.0.0.1:8050/" rel="noopener ugc nofollow" target="_blank"> http://127.0.0.1:8050/ </a>(或您选择的任何端口)。我们直播了！</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oc nd l"/></div></figure><p id="2ce3" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">部署到 Heroku 的演示可在以下地址查看:<a class="ae md" href="https://classifier-dash-app.herokuapp.com/" rel="noopener ugc nofollow" target="_blank">https://classifier-dash-app.herokuapp.com/</a></p><p id="118a" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">该演示不适用于移动设备，因此请在桌面/PC 上查看完整功能。</p><p id="629b" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">web 应用程序由三个组件组成:</p><ol class=""><li id="d12a" class="no np it lj b lk ll ln lo lq nq lu nr ly ns mc nt nu nv nw bi translated">一个下拉菜单，允许用户查看带有训练数据的模型，这些数据可以是原样的，也可以是合成的上采样数据，以解决任何类别不平衡的问题。</li></ol><ul class=""><li id="6f40" class="no np it lj b lk ll ln lo lq nq lu nr ly ns mc od nu nv nw bi translated">默认情况下没有上采样</li><li id="ac3d" class="no np it lj b lk nx ln ny lq nz lu oa ly ob mc od nu nv nw bi translated">utils 目录中的 upsample.py 模块可以提供有关上采样方法的详细信息。</li></ul><p id="c8e3" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">2.包含每个 sklearn 模型的精确度、召回率和 f1 分数的热图，以及以下内容:</p><ul class=""><li id="2c19" class="no np it lj b lk ll ln lo lq nq lu nr ly ns mc od nu nv nw bi translated">宏观平均值:平均每个标签的未加权平均值</li><li id="7653" class="no np it lj b lk nx ln ny lq nz lu oa ly ob mc od nu nv nw bi translated">加权平均值:平均每个标签的支持加权平均值</li></ul><p id="b4e4" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">3.将鼠标悬停在 sklearn 模型的热图中的关联行上时，将出现 matplotlib 图的模型特定图像，这些图像是利用 Yellowbrick 分类可视化工具填充的。</p><ul class=""><li id="18bf" class="no np it lj b lk ll ln lo lq nq lu nr ly ns mc od nu nv nw bi translated">ROCAUC:绘制接收器工作特性和曲线下面积的图形。</li><li id="a1f4" class="no np it lj b lk nx ln ny lq nz lu oa ly ob mc od nu nv nw bi translated">精确度-召回曲线:绘制不同概率阈值的精确度和召回率。</li><li id="a297" class="no np it lj b lk nx ln ny lq nz lu oa ly ob mc od nu nv nw bi translated">分类报告:可视化的分类报告，以热图的形式显示每个类别的精确度、召回率和 F1 值。</li><li id="dd80" class="no np it lj b lk nx ln ny lq nz lu oa ly ob mc od nu nv nw bi translated">混淆矩阵:类别对混淆矩阵的热图视图。</li></ul><h2 id="7a94" class="me mf it bd mg mh mi dn mj mk ml dp mm lq mn mo mp lu mq mr ms ly mt mu mv iz bi translated">它告诉我们什么？</h2><p id="dfcc" class="pw-post-body-paragraph lh li it lj b lk mw kd lm ln mx kg lp lq my ls lt lu mz lw lx ly na ma mb mc im bi translated">我们可以清楚地看到，高斯朴素贝叶斯模型表现不佳(至少在给定参数集的情况下)。由于类别不平衡，逻辑回归模型是有偏差的，并且对于阳性病例在精确度和召回率上表现不佳。我们看到，当向上采样应用于训练数据时，它的性能更好，但它仍然没有达到类似于随机森林和梯度增强模型所代表的集成方法的性能。</p><p id="5716" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">可视化暗示集成方法表现更好，但是我们能更好地区分哪一族集成方法更好吗——bagging 还是 boosting？这可以通过编辑 config.py 文件合并额外的树和 AdaBoost 分类器来完成。</p><p id="0c1f" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">初始诊断还有助于告知我们如何分配时间向前发展，即查看决策树中的特征重要性，然后在这些算法中进行更详尽的超参数调整。</p><p id="7b51" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">机器学习是一个迭代的探索过程，所以我们可能会在模型选择的三个阶段之间来回穿梭。</p><h2 id="0ea9" class="me mf it bd mg mh mi dn mj mk ml dp mm lq mn mo mp lu mq mr ms ly mt mu mv iz bi translated">后续步骤</h2><p id="2f7d" class="pw-post-body-paragraph lh li it lj b lk mw kd lm ln mx kg lp lq my ls lt lu mz lw lx ly na ma mb mc im bi translated">如果你对 process_data.py 和 app.py 文件感兴趣，那么我鼓励你去看看<a class="ae md" href="https://github.com/taylorplumer/classifiers-dash" rel="noopener ugc nofollow" target="_blank"> github repo </a>！</p><p id="afd7" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果您有任何问题和/或想法要使该工具更加有效，请提出问题。编码快乐！</p><p id="6c58" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">[1]库马尔、阿伦&amp;麦肯、罗伯特&amp;诺顿、杰弗里&amp;帕特尔、吉格内什。模型选择管理系统:高级分析的下一个前沿(2016)，ACM SIGMOD 记录。44.17–22.10.1145/2935694.2935698.</p></div></div>    
</body>
</html>