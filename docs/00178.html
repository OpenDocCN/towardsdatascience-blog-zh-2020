<html>
<head>
<title>Scaling DAG Creation With Apache Airflow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Apache Airflow扩展DAG创建</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/scaling-dag-creation-with-apache-airflow-a7b34ba486ac?source=collection_archive---------19-----------------------#2020-01-06">https://towardsdatascience.com/scaling-dag-creation-with-apache-airflow-a7b34ba486ac?source=collection_archive---------19-----------------------#2020-01-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/41ce07331cac79456999409c59568b07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UVtRaulEHKgHohBW"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@campaign_creators?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">活动发起人</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="73e1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">数据科学社区中更困难的任务之一不是设计一个结构良好的业务问题的模型，或者开发在可伸缩环境中运行的代码库，而是在ETL或数据科学管道中安排任务，定期执行模型，并自动化中间的一切。</p><p id="41a5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是<a class="ae kf" href="https://airflow.apache.org/" rel="noopener ugc nofollow" target="_blank">阿帕奇气流</a>前来救援的地方！借助以图形形式显示任务的Airflow UI，以及以编程方式定义工作流以提高可追溯性的能力，在生产中定义和配置Data Science工作流变得更加容易。</p><p id="e07f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，还有一个困难。在某些情况下，相同的建模、整体流程会被用于不同的数据源。为了提高性能，最好让这些进程同时运行，而不是将它们添加到同一个dag中。</p><p id="d9e2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">没问题，让我们简单地为每个进程创建一个dag，所有进程都有相似的任务，并安排它们同时运行。如果我们遵循DRY软件开发原则，有没有一种方法可以用相同类型的任务创建多个不同的Dag，而不必手动创建它们？</p><blockquote class="le lf lg"><p id="4edb" class="kg kh lh ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">有没有一种方法可以创建具有相同类型任务的多个不同Dag，而不必手动创建它们？</p></blockquote><h2 id="d4ef" class="ll lm it bd ln lo lp dn lq lr ls dp lt kr lu lv lw kv lx ly lz kz ma mb mc md bi translated">最初的方法</h2><p id="04c9" class="pw-post-body-paragraph kg kh it ki b kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz mi lb lc ld im bi translated">首先，让我们假设我们的初始dag如下所示:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="834f" class="ll lm it mo b gy ms mt l mu mv">from datetime import datetime, timedelta<br/>from dateutil.relativedelta import relativedelta<br/>from time import sleep<br/><br/>from airflow import DAG<br/>from airflow.operators.python_operator import PythonOperator</span><span id="5a68" class="ll lm it mo b gy mw mt l mu mv"># the default arguments for the DAG<br/>default_args = {<br/>    "depends_on_past": False,<br/>    "start_date": datetime.now() - relativedelta(days=1),<br/>    "retries": 1,<br/>    "retry_delay": timedelta(seconds=120),<br/>    "email_on_failure": False<br/>}<br/><br/>dag = DAG("dummy", default_args=default_args, schedule_interval=None)</span><span id="3ccb" class="ll lm it mo b gy mw mt l mu mv"># python function we are to use that only sleeps for 60 seconds.<br/>def tmp():<br/>    sleep(60)<br/>    <br/>    print("Dag passed!")<br/>    return None<br/><br/>t1 = PythonOperator(python_callable=tmp, task_id="time", dag=dag)</span></pre><p id="ac82" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个dag的目的是简单地休眠，然后打印一个语句。这是一个非常简单的dag，但是让我们假设这将代表我们的数据科学工作流。如果这是我们部署到生产中的唯一数据科学工作流，我们很可能会感到满意。<br/> <br/>但是，如果像前面提到的那样，我们想要创建多个具有相同类型任务的Dag，而不必手动创建它们，该怎么办呢？例如，以我们上面的初始dag为例，如果我们想要配置在打印语句之前我们想要休眠的秒数会怎么样呢？这就是我们需要理解流程的哪些部分是可配置的，然后允许这些部分成为流程中的变量。让我们再次尝试我们的初始dag:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="99dc" class="ll lm it mo b gy ms mt l mu mv">from datetime import datetime, timedelta<br/>from dateutil.relativedelta import relativedelta<br/>from time import sleep<br/><br/>from airflow import DAG<br/>from airflow.operators.python_operator import PythonOperator<br/><br/>default_args = {<br/>    "depends_on_past": False,<br/>    "start_date": datetime.now() - relativedelta(days=1),<br/>    "retries": 1,<br/>    "retry_delay": timedelta(seconds=120),<br/>    "email_on_failure": False<br/>}</span><span id="f81f" class="ll lm it mo b gy mw mt l mu mv"># this function will create a dag, define the python callable and add it to the PythonOperator<br/>def create_dag(dag_id, seconds=60):<br/>    dag = DAG(dag_id, default_args=default_args, schedule_interval=None)<br/>    <br/>    def tmp():<br/>        sleep(seconds)<br/>        <br/>        print("Dag passed!")<br/>        return None<br/>    <br/>    t1 = PythonOperator(python_callable=tmp, task_id="time", dag=dag)<br/>    <br/>    return dag</span><span id="6802" class="ll lm it mo b gy mw mt l mu mv"># here we create a global variable called dummy dag, which will store the DAG object here.<br/>globals()["dummy_dag"] = create_dag("dummy", 60)</span></pre><p id="d8c8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当一个变量被添加到python脚本中的全局字典时，它被渲染并被视为在全局范围内创建的变量，即使它最初是在函数范围内创建的。现在，您可以轻松创建多个任务相似的Dag。</p><blockquote class="mx"><p id="7df8" class="my mz it bd na nb nc nd ne nf ng ld dk translated">现在，如果某些Dag的任务分配只有微小的变化，会怎么样呢？</p></blockquote><p id="a2c2" class="pw-post-body-paragraph kg kh it ki b kj nh kl km kn ni kp kq kr nj kt ku kv nk kx ky kz nl lb lc ld im bi translated">一般来说，大多数人会简单地用相似的DAG创建过程创建多个python脚本。</p><p id="4d3f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，有更好的办法。</p><h2 id="a54d" class="ll lm it bd ln lo lp dn lq lr ls dp lt kr lu lv lw kv lx ly lz kz ma mb mc md bi translated">特定Dag的可配置任务分配</h2><p id="79a5" class="pw-post-body-paragraph kg kh it ki b kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz mi lb lc ld im bi translated">考虑这个例子，我们最初在一个名为task_assigner.py的python模块中定义它</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="b23f" class="ll lm it mo b gy ms mt l mu mv">from functools import reduce<br/><br/>from airflow.operators import *<br/><br/># this will be just a small subset of operators that we will define<br/>task_dict = {<br/>    "external_task": ExternalTaskSensor,<br/>    'python_operator': PythonOperator,<br/>    'trigger_dag': TriggerDagOperator,<br/>    "bash": BashOperator<br/>}<br/><br/>class TaskAssigner:<br/><br/>    def __init__(self, parent_dag):<br/>        self.parent_dag = parent_dag<br/>    <br/>    def define_tasks(self, task_params):<br/>    """<br/>    This will use the task_dict to help map the task define to the appropriate task with the correct parameters<br/>     <br/>    :param tsk_name: The unique name of the task<br/>    :type: str<br/>    :param task_params: The parameters for all the task<br/>    :type: dict<br/>    """<br/>    <br/>        defined_tsk_dict = {}<br/>    <br/>        for tsk in task_params.keys():<br/>            dag_type = task_params[tsk]["type"]<br/>            params = task_params[tsk]["params"]<br/>            params["dag"] = self.parent_dag<br/>            params["task_id"] = tsk<br/>            <br/>            defined_tsk_dict[tsk] = task_dict[dag_type](**params)<br/>    <br/>        return defined_tsk_dict<br/>        <br/>    def map_task(self, tsk_names, defined_task_dict):<br/>    """<br/>    This will help map the sequence of the tasks to the appropriate defined task<br/>    <br/>    :param tsk_names: The sequence of the tasks to run<br/>    :type tsk_names: str<br/>    :param defined_task_dict: The dictionary of defined tasks<br/>    :type defined_task_dict: dict<br/>    """<br/>    <br/>        res_lst = []<br/>    <br/>        for tsks in tsk_names:<br/>            if isinstance(tsks, list):<br/>                res_lst.append(self.map_task(tsks, defined_task_dict))<br/>            elif isinstance(tsks, str):<br/>                res_lst.append(defined_task_dict[tsks])<br/>            else:<br/>                raise ValueError<br/>        <br/>        return res_lst    <br/>        <br/>    def run(self, task_sequence, task_params):<br/>    """<br/>    This will assign each task in the sequence, with the right parameters, to the parent dag<br/>    <br/>    :param task_sequence: This will be a list of, or a list of list, of strings<br/>    :type task_sequence: List[List[str]] or List[List[List[str]]], or something in between.<br/>    :param task_params: The parameters for all the task<br/>    :type task_params: dict<br/>    """<br/>    <br/>        defined_task_dict = self.define_tasks(task_params)<br/>    <br/>        # this is a List[List[Tasks]] or a List[List[List[Tasks]]]<br/>        run_lst = self.map_task(task_sequence, defined_task_dict)<br/>        <br/>        def tmf(tsks):<br/>            reduce(lambda tsk1, tsk2: tsk1 &gt;&gt; tsk2, tsks[1:], tsks[0])<br/>        <br/>        list(map(tmp, run_lst))<br/>        <br/>        return None</span></pre><p id="8d0f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后在另一个脚本中使用TaskAssigner，比如说在dag.py中</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="291b" class="ll lm it mo b gy ms mt l mu mv">import json<br/><br/>from datetime import datetime, timedelta<br/>from dateutil.relativedelta import relativedelta<br/>from time import sleep<br/><br/>from airflow import DAG<br/>from airflow.operators.python_operator import PythonOperator<br/><br/>from task_assigner import TaskAssigner<br/><br/>default_args = {<br/>    "depends_on_past": False,<br/>    "start_date": datetime.now() - relativedelta(days=1),<br/>    "retries": 1,<br/>    "retry_delay": timedelta(seconds=120),<br/>    "email_on_failure": False<br/>}</span><span id="fd4d" class="ll lm it mo b gy mw mt l mu mv"># now what we do is create a dag, pass it into the TaskAssigner<br/># with the dag sequence and the params for each task in the dag.</span><span id="1456" class="ll lm it mo b gy mw mt l mu mv">def create_dag(dag_id, dag_sequence, dag_params):<br/>    dag = DAG(dag_id, default_args=default_args, schedule_interval=None)<br/>    <br/>    tsk_assign = TaskAssigner(dag)<br/>    <br/>    tsk_assign.run(dag_sequence, dag_params)<br/>    <br/>    return dag</span><span id="668d" class="ll lm it mo b gy mw mt l mu mv"># we read in our configuration file with our parameters in the dag<br/>with open("dag_configs.json") as f:<br/>    config = json.load(f)</span><span id="923d" class="ll lm it mo b gy mw mt l mu mv"># we loop through each dag id in the JSON file, and then create our dag and add it as a global variable here.</span><span id="acb3" class="ll lm it mo b gy mw mt l mu mv">for dg_id in config.keys():<br/>    globals()[dg_id] = create_dag(dg_id, config[dg_id]["dag_sequence"], config[dg_id]["dag_params"])</span></pre><p id="d07c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里使用的dag_configs.json是:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="6bbf" class="ll lm it mo b gy ms mt l mu mv">{<br/>  "dummy": {<br/>    "dag_sequence": [["dummy"]],<br/>    "dag_params": {<br/>      "dummy": {<br/>        "type": "bash",<br/>        "params": {"bash_command": "sleep 60"}<br/>      }<br/>    }<br/>  }<br/>}</span></pre><h2 id="7eae" class="ll lm it bd ln lo lp dn lq lr ls dp lt kr lu lv lw kv lx ly lz kz ma mb mc md bi translated">把所有的放在一起</h2><p id="b908" class="pw-post-body-paragraph kg kh it ki b kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz mi lb lc ld im bi translated">现在，我们讨论了如何利用OOP定义多个Dag，这是DRY兼容的。但是，这是假设每个dag都是相互独立的，实际情况通常不是这样。有些情况下，每个dag都可能依赖于另一个dag。</p><p id="d15a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你认为解决办法是什么？</p><p id="40ce" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您有任何问题，请随时联系我们。</p><p id="629f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我正在创建的内容将只在blog.pyscale.net完全可用。请访问该网站获取更多内容，尤其是如果您想了解更多关于面向初学者的数据科学工具的信息！</p><p id="648a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一如既往，#happycoding！</p></div></div>    
</body>
</html>