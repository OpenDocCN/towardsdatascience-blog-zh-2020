<html>
<head>
<title>Abstract Base Classes in Python: Fundamentals for Data Scientists</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的抽象基类:数据科学家的基础</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/abstract-base-classes-in-python-fundamentals-for-data-scientists-3c164803224b?source=collection_archive---------2-----------------------#2020-06-26">https://towardsdatascience.com/abstract-base-classes-in-python-fundamentals-for-data-scientists-3c164803224b?source=collection_archive---------2-----------------------#2020-06-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8417" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用一个具体的例子来理解基础！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/523a4dd3f78912033ebb7543c223a58d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*i5AylVo6l8hqGVkD"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">约书亚·阿拉贡在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="9b47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Python中，<strong class="lb iu">抽象基类</strong>为具体类提供了蓝图。它们不包含实现。相反，它们提供一个接口，并确保派生的具体类得到正确实现。</p><ul class=""><li id="db71" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">抽象基类不能被实例化。相反，它们被具体的子类继承和扩展。</li><li id="e9ec" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">从特定抽象基类派生的子类必须实现该抽象基类中提供的方法和属性。否则，在对象实例化期间会引发错误。</li></ul><p id="198d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们编写一个Python3代码，其中包含实现抽象基类的简单示例:</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="b2c8" class="mo mp it mk b gy mq mr l ms mt">from <strong class="mk iu">abc</strong> import <strong class="mk iu">ABCMeta, abstractmethod</strong></span><span id="b35e" class="mo mp it mk b gy mu mr l ms mt"><em class="mv">class</em> <strong class="mk iu">AbstactClassCSV</strong>(<em class="mv">metaclass</em> = <em class="mv">ABCMeta</em>):<br/> <br/> <em class="mv">def</em> <strong class="mk iu">__init__</strong>(<em class="mv">self</em>, <em class="mv">path</em>, <em class="mv">file_name</em>):<br/>  self._path = path<br/>  self._file_name = file_name</span><span id="73a4" class="mo mp it mk b gy mu mr l ms mt"><strong class="mk iu"> @<em class="mv">property<br/> </em>@abstractmethod</strong><br/> <em class="mv">def</em> path(<em class="mv">self</em>):<br/>  pass</span><span id="f1ad" class="mo mp it mk b gy mu mr l ms mt"><strong class="mk iu"> @path.setter<br/> @abstractmethod</strong><br/> <em class="mv">def</em> path(<em class="mv">self</em>,<em class="mv">value</em>):<br/>  pass</span><span id="baae" class="mo mp it mk b gy mu mr l ms mt"><strong class="mk iu"> @<em class="mv">property<br/> </em>@abstractmethod</strong><br/> <em class="mv">def</em> file_name(<em class="mv">self</em>):<br/>  pass</span><span id="4658" class="mo mp it mk b gy mu mr l ms mt"><strong class="mk iu"> @file_name.setter<br/> @abstractmethod</strong><br/> <em class="mv">def</em> file_name(<em class="mv">self</em>,<em class="mv">value</em>):<br/>  pass</span><span id="948b" class="mo mp it mk b gy mu mr l ms mt"><strong class="mk iu"> @abstractmethod</strong><br/> <em class="mv">def</em> display_summary(<em class="mv">self</em>):<br/>  pass</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mw"><img src="../Images/b58c824002f886727759244e2a582bc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oJ7kAxGtU8nKk0Gh"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">约翰·邓肯在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="5b5e" class="mx mp it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">定义抽象基类</h1><p id="0e5b" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">Python为抽象基类定义提供了一个<strong class="lb iu"> abc </strong>模块。我们需要导入<strong class="lb iu"> ABCMeta </strong>元类，并将其分配给我们想要定义的抽象类。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="fd4a" class="mo mp it mk b gy mq mr l ms mt">from <strong class="mk iu">abc</strong> import <strong class="mk iu">ABCMeta, abstractmethod</strong></span><span id="d6ce" class="mo mp it mk b gy mu mr l ms mt"><em class="mv">class</em> <strong class="mk iu">AbstactClassCSV</strong>(<em class="mv">metaclass</em> = <em class="mv">ABCMeta</em>):<br/> .....<br/> .....</span></pre><p id="cef4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在抽象基类内部，我们使用<strong class="lb iu">@ abstract method</strong>decorator强制子类实现<strong class="lb iu"> path </strong>和<strong class="lb iu"> file_name </strong>属性。请注意，这些属性没有实现并且为空，因为抽象类仅用于定义接口。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="e3fd" class="mo mp it mk b gy mq mr l ms mt"><strong class="mk iu"> @<em class="mv">property<br/> </em>@abstractmethod</strong><br/> <em class="mv">def</em> path(<em class="mv">self</em>):<br/>  pass</span><span id="4f51" class="mo mp it mk b gy mu mr l ms mt"><strong class="mk iu"> @path.setter<br/> @abstractmethod</strong><br/> <em class="mv">def</em> path(<em class="mv">self</em>,<em class="mv">value</em>):<br/>  pass</span><span id="1c1c" class="mo mp it mk b gy mu mr l ms mt"><strong class="mk iu"> @<em class="mv">property<br/> </em>@abstractmethod</strong><br/> <em class="mv">def</em> file_name(<em class="mv">self</em>):<br/>  pass</span><span id="95d4" class="mo mp it mk b gy mu mr l ms mt"><strong class="mk iu"> @file_name.setter<br/> @abstractmethod</strong><br/> <em class="mv">def</em> file_name(<em class="mv">self</em>,<em class="mv">value</em>):<br/>  pass</span></pre><p id="c575" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，使用<strong class="lb iu"> @abstractmethod </strong>装饰器，我们可以定义一个抽象方法，并强制子类实现<strong class="lb iu">display _ summary(<em class="mv">self</em>)</strong>方法。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="9ad0" class="mo mp it mk b gy mq mr l ms mt"><strong class="mk iu"> @abstractmethod</strong><br/> <em class="mv">def</em> display_summary(<em class="mv">self</em>):<br/>  pass</span></pre><p id="9ce4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此时，如果我们试图实例化一个抽象类<strong class="lb iu"> AbstactClassCSV </strong>的对象，我们会得到一个错误。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="0f6f" class="mo mp it mk b gy mq mr l ms mt"><strong class="mk iu">abc_instantiation</strong> = <strong class="mk iu">AbstactClassCSV</strong>("/Users/erdemisbilen/Lessons/", "data_by_genres.csv")</span><span id="8fab" class="mo mp it mk b gy mu mr l ms mt"><strong class="mk iu">Output:</strong></span><span id="4560" class="mo mp it mk b gy mu mr l ms mt">Traceback (most recent call last):<br/>  File "ABCExample.py", line 119, in &lt;module&gt;<br/>    abc_instantiation = AbstactClassCSV("/Users/erdemisbilen/Lessons/", "data_by_genres.csv")<br/><strong class="mk iu">TypeError: Can't instantiate abstract class AbstactClassCSV with abstract methods display_summary, file_name, path</strong></span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/d79a94859b816edd50e4f75e4a1a3e92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nmoi4ZbQL4Q90Qfw"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Benoit Gauzere 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="ed5b" class="mx mp it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">创建从抽象基类派生的具体子类</h1><p id="f6b1" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">现在我们已经定义了抽象基类(<strong class="lb iu"> AbstactClassCSV) </strong>，我们可以通过继承来创建子类。</p><p id="415b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面，我通过继承<strong class="lb iu"> <em class="mv"> AbstactClassCSV </em> </strong>抽象类，创建了<strong class="lb iu"> CSVGetInfo </strong>具体类。因此，我必须严格遵循抽象类提供的接口，并在我的具体子类中正确实现所有规定的方法和属性。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="2d3e" class="mo mp it mk b gy mq mr l ms mt"><em class="mv">class</em> <strong class="mk iu">CSVGetInfo</strong>(<strong class="mk iu"><em class="mv">AbstactClassCSV</em></strong>):</span><span id="3af1" class="mo mp it mk b gy mu mr l ms mt"><strong class="mk iu">""" This class displays the summary of the tabular data contained in a CSV file """</strong></span><span id="0dd9" class="mo mp it mk b gy mu mr l ms mt"><strong class="mk iu"> @<em class="mv">property</em></strong><em class="mv"><br/> def</em> <strong class="mk iu">path(<em class="mv">self</em>)</strong>:<br/>  """ The docstring for the path property """<br/>  print("Getting value of path")<br/>  return self.<strong class="mk iu">_path</strong></span><span id="4bb8" class="mo mp it mk b gy mu mr l ms mt"><strong class="mk iu"> @path.setter</strong><br/> <em class="mv">def</em> <strong class="mk iu">path(<em class="mv">self</em>,<em class="mv">value</em>):</strong><br/>  if '/' in value:<br/>   self.<strong class="mk iu">_path</strong> = value<br/>   print("Setting value of path to {}".format(value))<br/>  else:<br/>   print("Error: {} is not a valid path string".format(value))</span><span id="9598" class="mo mp it mk b gy mu mr l ms mt"><strong class="mk iu">data_by_genres</strong> = CSVGetInfo("/Users/erdemisbilen/Lessons/", "data_by_genres.csv")</span><span id="7315" class="mo mp it mk b gy mu mr l ms mt"><strong class="mk iu">Output:</strong></span><span id="f14f" class="mo mp it mk b gy mu mr l ms mt">Traceback (most recent call last):<br/>  File "ABCExample.py", line 103, in &lt;module&gt;<br/>    <strong class="mk iu">data_by_genres</strong> = CSVGetInfo("/Users/erdemisbilen/Lessons/", "data_by_genres.csv")<br/>TypeError: Can't instantiate abstract class <strong class="mk iu">CSVGetInfo</strong> with abstract methods <strong class="mk iu">display_summary, file_name</strong></span></pre><p id="c5a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了演示这个案例，我只定义了<strong class="lb iu">路径</strong>属性，没有实现<strong class="lb iu">文件名</strong>属性和<strong class="lb iu">显示摘要</strong>方法。</p><p id="5f6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我试图在这种状态<strong class="lb iu">下实例化<strong class="lb iu"> CSVGetInfo </strong>的对象，就会出现上面的</strong>错误。</p><p id="389e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是抽象类如何防止不正确的子类定义。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="c157" class="mo mp it mk b gy mq mr l ms mt"><em class="mv">class</em> <strong class="mk iu">CSVGetInfo(<em class="mv">AbstactClassCSV)</em>:</strong><br/><strong class="mk iu"> """ This class displays the summary of the tabular data contained <br/> in a CSV file """</strong></span><span id="0a5f" class="mo mp it mk b gy mu mr l ms mt"><strong class="mk iu"> @<em class="mv">property</em></strong><em class="mv"><br/> def</em> <strong class="mk iu">path(<em class="mv">self</em>):</strong><br/>  """ The docstring for the path property """<br/>  print("Getting value of path")<br/>  return self._path</span><span id="817f" class="mo mp it mk b gy mu mr l ms mt"><strong class="mk iu"> @path.setter</strong><br/> <em class="mv">def</em> <strong class="mk iu">path(<em class="mv">self</em>,<em class="mv">value</em>):</strong><br/>  if '/' in value:<br/>   self._path = value<br/>   print("Setting value of path to {}".format(value))<br/>  else:<br/>   print("Error: {} is not a valid path string".format(value))</span><span id="7d85" class="mo mp it mk b gy mu mr l ms mt"><strong class="mk iu"> @<em class="mv">property</em></strong><em class="mv"><br/> def</em> <strong class="mk iu">file_name(<em class="mv">self</em>):</strong><br/>  """ The docstring for the file_name property """<br/>  print("Getting value of file_name")<br/>  return self._file_name</span><span id="ec83" class="mo mp it mk b gy mu mr l ms mt"><strong class="mk iu"> @file_name.setter</strong><br/> <em class="mv">def</em> <strong class="mk iu">file_name(<em class="mv">self</em>,<em class="mv">value</em>):</strong><br/>  if '.' in value:<br/>   self._file_name = value<br/>   print("Setting value of file_name to {}".format(value))<br/>  else:<br/>   print("Error: {} is not a valid file name".format(value))</span><span id="d01a" class="mo mp it mk b gy mu mr l ms mt"><em class="mv">def</em> <strong class="mk iu">display_summary(<em class="mv">self</em>):</strong><br/>  data = pd.read_csv(self._path + self._file_name)<br/>  print(self._file_name)<br/>  print(data.info())</span></pre><p id="941b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于我们已经定义了所有必需的属性和上面抽象类指定的方法，现在我们可以实例化并使用派生子类<strong class="lb iu"> CSVGetInfo </strong>的对象。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/8dabc3f037aeb481020bde2c9466c81a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ePF38cQtoYTkJwmd"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">文森特·范·扎林盖在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><h1 id="8bab" class="mx mp it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">关键要点</h1><ul class=""><li id="da9d" class="lv lw it lb b lc no lf np li nv lm nw lq nx lu ma mb mc md bi translated">抽象基类将接口与实现分开。</li><li id="1897" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">它们确保派生类实现抽象基类中指定的方法和属性。</li><li id="0408" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">抽象基类将接口与实现分开。它们定义了必须在子类中使用的泛型方法和属性。实现由具体的子类来处理，我们可以在其中创建可以处理任务的对象。</li><li id="ed48" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">它们有助于避免错误，并通过提供创建子类的严格方法，使类层次结构更容易维护。</li></ul><h1 id="a3e7" class="mx mp it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">结论</h1><p id="62e9" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">在这篇文章中，我解释了Python中抽象基类的基础知识。</p><p id="4927" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章中的代码可以在我的GitHub库中找到。</p><p id="dc7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这篇文章对你有用。</p><p id="624f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读！</p></div></div>    
</body>
</html>