<html>
<head>
<title>Are you using Python with APIs? Learn how to use a retry decorator!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你使用 Python 和 API 吗？了解如何使用重试装饰器！</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/are-you-using-python-with-apis-learn-how-to-use-a-retry-decorator-27b6734c3e6?source=collection_archive---------2-----------------------#2020-03-28">https://towardsdatascience.com/are-you-using-python-with-apis-learn-how-to-use-a-retry-decorator-27b6734c3e6?source=collection_archive---------2-----------------------#2020-03-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2cf0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">实现重试装饰器可以防止意外的一次性异常。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/da762d7a1f1703e0e7879c823405a297.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7hNq_fbZcX2zHtaILNbfcQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://pixabay.com/photos/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1081904" rel="noopener ugc nofollow" target="_blank">免费提供-照片</a>来自<a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1081904" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="1461" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">人们经常将 Python 描述为“胶合语言”术语“粘合语言”对我来说意味着一种语言有助于连接系统，并确保数据以期望的结构和格式从<code class="fe lv lw lx ly b"><strong class="lb iu">A</strong></code>传到<code class="fe lv lw lx ly b"><strong class="lb iu">B</strong></code>。</p><p id="56ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我用 Python 构建了无数 ETL 脚本(<strong class="lb iu"> E </strong>提取<strong class="lb iu"> T </strong>转换<strong class="lb iu"> L </strong> oad)。所有这些脚本本质上都是根据相同的原理运行的。他们从某个地方提取数据，转换数据，然后运行最后的操作。最后一个操作通常意味着将数据上传到某个地方，但也可能是有条件的删除。</p><p id="542b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">越来越多的典型公司基础设施正在向云迁移。越来越多的公司转向微服务方式。这些从本地到基于云的范式转变意味着您可能也面临过这样的情况，您必须从本地计算机之外的某个地方提取数据或将数据写入某个地方。</p><p id="32f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在小范围内，很少会有这方面的问题。如果某些提取或写回失败，您通常会注意到这一点，并能够纠正错误。但是，当您走向更大规模的操作和潜在的成千上万的事务时，您不希望由于 internet 连接的暂时中断、太多的并发写入、暂时无响应的源系统或天知道还有什么其他原因而受到影响。</p><p id="7d1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我发现一个非常简单的 retry-decorator 在无数类似的情况下是一个可取之处。我的大多数项目，或多或少，最终都在某个 util 模块中使用了 retry decorator。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="d666" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">装饰者</h1><h2 id="cb0a" class="my mh it bd mi mz na dn mm nb nc dp mq li nd ne ms lm nf ng mu lq nh ni mw nj bi translated">函数是一级对象</h2><p id="e0fb" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">在 Python 中，函数是一级对象。函数就像任何其他对象一样。这一事实意味着函数可以动态创建、传递给函数本身，甚至可以更改。看看下面这个例子(虽然有点傻):</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="cfce" class="my mh it ly b gy nt nu l nv nw"><strong class="ly iu">def </strong>my_function(x):<br/>    print(x)</span><span id="7235" class="my mh it ly b gy nx nu l nv nw"><strong class="ly iu">IN:<br/></strong>my_function(2)<br/><strong class="ly iu">OUT:<br/></strong>2</span><span id="289d" class="my mh it ly b gy nx nu l nv nw"><strong class="ly iu">IN:<br/></strong>my_function.yolo = 'you live only once'<br/>print(my_function.yolo)<br/><strong class="ly iu">OUT:<br/></strong>'you live only once'</span></pre><h2 id="e589" class="my mh it bd mi mz na dn mm nb nc dp mq li nd ne ms lm nf ng mu lq nh ni mw nj bi translated">装饰功能</h2><p id="c07b" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">很高兴知道我们可以用另一个函数包装一个函数来满足特定的需求。例如，我们可以确保函数在被调用时向某个日志记录端点报告，我们可以打印出参数，我们可以实现类型检查、预处理或后处理等等。让我们看一个简单的例子:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="e065" class="my mh it ly b gy nt nu l nv nw"><strong class="ly iu">def</strong> first_func(x):<br/>    <strong class="ly iu">return</strong> x**2<br/>    <br/><strong class="ly iu">def</strong> second_func(x):<br/>    <strong class="ly iu">return</strong> x - 2</span></pre><p id="5ffd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当用字符串<code class="fe lv lw lx ly b">'2'</code>调用时，两个函数都失败。我们可以在组合中加入一个类型转换函数，并用它来修饰我们的<code class="fe lv lw lx ly b">first_func</code>和<code class="fe lv lw lx ly b">second_func</code>。</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="9b79" class="my mh it ly b gy nt nu l nv nw"><strong class="ly iu">def</strong> convert_to_numeric(func):</span><span id="2c4a" class="my mh it ly b gy nx nu l nv nw">    <em class="ny"># define a function within the outer function</em><br/><strong class="ly iu">    def</strong> new_func(x):<br/>        <strong class="ly iu">return</strong> func(float(x))</span><span id="f34f" class="my mh it ly b gy nx nu l nv nw"><em class="ny">    # return the newly defined function<br/></em>    <strong class="ly iu">return</strong> new_func</span></pre><p id="bc57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个<code class="fe lv lw lx ly b">convert_to_numeric</code>包装函数期望一个函数作为参数，并返回另一个函数。</p><p id="501a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，虽然之前会失败，但是如果您包装这些函数，然后用一个字符串数字调用它们，所有功能都会按预期工作。</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="68e7" class="my mh it ly b gy nt nu l nv nw"><strong class="ly iu">IN:</strong><br/>new_fist_func = convert_to_numeric(first_func)</span><span id="884f" class="my mh it ly b gy nx nu l nv nw"><em class="ny">###############################</em><br/><em class="ny">convert_to_numeric returns this function:<br/></em><strong class="ly iu"><em class="ny">def</em></strong><em class="ny"> </em>new_func<em class="ny">(x):<br/>    </em><strong class="ly iu"><em class="ny">return</em></strong><em class="ny"> </em>first_func<em class="ny">(float(x))<br/>###############################</em></span><span id="f906" class="my mh it ly b gy nx nu l nv nw">new_fist_func('2')<br/><strong class="ly iu">OUT:<br/></strong>4.0</span><span id="4872" class="my mh it ly b gy nx nu l nv nw"><strong class="ly iu">IN:</strong><br/>convert_to_numeric(second_func)('2')<br/><strong class="ly iu">OUT:<br/></strong>0</span></pre><p id="1dfd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">那么这到底是怎么回事呢？</strong></p><p id="d070" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嗯，我们的<code class="fe lv lw lx ly b">convert_to_numeric</code>以一个函数<strong class="lb iu"> (A) </strong>作为参数，返回一个新的函数<strong class="lb iu"> (B) </strong>。新函数<strong class="lb iu"> (B) </strong>在被调用时，调用函数<strong class="lb iu"> (A) </strong>，但是它不是用传递的参数<code class="fe lv lw lx ly b">x</code>调用它，而是用<code class="fe lv lw lx ly b">float(x)</code>调用函数<strong class="lb iu"> (A) </strong>，因此解决了我们之前的<code class="fe lv lw lx ly b">TypeError</code>问题。</p><h2 id="44a8" class="my mh it bd mi mz na dn mm nb nc dp mq li nd ne ms lm nf ng mu lq nh ni mw nj bi translated">装饰语法</h2><p id="e381" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">为了让开发人员更容易理解，Python 提供了一种特殊的语法。我们还可以执行以下操作:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="1cb7" class="my mh it ly b gy nt nu l nv nw"><strong class="ly iu"><em class="ny">@convert_to_numeric</em></strong><br/>def first_func(x):<br/>    return x**2</span></pre><p id="8706" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上述语法相当于:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="4a9e" class="my mh it ly b gy nt nu l nv nw"><strong class="ly iu">def</strong> first_func(x):<br/>    <strong class="ly iu">return</strong> x**2</span><span id="1b15" class="my mh it ly b gy nx nu l nv nw">first_func = convert_to_numeric(first_func)</span></pre><p id="f049" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个语法让我们更清楚到底发生了什么，尤其是在使用多个 decorators 的时候。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="d3e4" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">重试！</h1><p id="ae71" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">现在我们已经讨论了基础知识，让我们转到我最喜欢和经常使用的<code class="fe lv lw lx ly b">retry</code>——装饰者:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/1599b86ee4869a32705a5866ea1b2105.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*njgc1GXrGNQpb2xDv8YmJg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">此处代码<a class="ae ky" href="https://gist.github.com/FBosler/be10229aba491a8c912e3a1543bbc74e" rel="noopener ugc nofollow" target="_blank">为</a>！</p></figure><p id="b643" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">包装被包装的函数。这是一些盗梦空间的东西。但是请原谅我，这并没有那么复杂！</p><p id="cb30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们一步一步地浏览代码:</p><ol class=""><li id="ecb6" class="oa ob it lb b lc ld lf lg li oc lm od lq oe lu of og oh oi bi translated">Outmost 函数<code class="fe lv lw lx ly b"><strong class="lb iu">retry</strong></code>:这将参数化我们的装饰器，即我们想要处理的异常是什么，我们想要多长时间尝试一次，我们在两次尝试之间等待多长时间，以及我们的指数补偿因子是什么(即我们每次失败时用什么数字乘以等待时间)。</li><li id="7acd" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated"><code class="fe lv lw lx ly b"><strong class="lb iu">retry_decorator</strong></code>:这是参数化的装饰器，由我们的<code class="fe lv lw lx ly b"><strong class="lb iu">retry</strong></code> <strong class="lb iu"> </strong>函数返回。我们正在用<code class="fe lv lw lx ly b"><strong class="lb iu">@wraps</strong></code>装饰<code class="fe lv lw lx ly b"><strong class="lb iu">retry_decorator</strong></code> <strong class="lb iu"> </strong>内的功能。严格来说，就功能而言，这是不必要的。这个包装器更新被包装函数的<code class="fe lv lw lx ly b">__name__</code>和<code class="fe lv lw lx ly b">__doc__</code>(如果我们不这样做，我们的函数<code class="fe lv lw lx ly b">__name__</code>将总是<code class="fe lv lw lx ly b"><strong class="lb iu">func_with_retries</strong></code>)</li><li id="153b" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated"><code class="fe lv lw lx ly b"><strong class="lb iu">func_with_retries</strong></code>应用重试逻辑。该函数将函数调用包装在 try-except 块中，并实现指数后退等待和一些日志记录。</li></ol><h2 id="8559" class="my mh it bd mi mz na dn mm nb nc dp mq li nd ne ms lm nf ng mu lq nh ni mw nj bi translated">用法:</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/6c1a3dd31b36f59dcd36452e44c8c469.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9ndhZJy2b-1Yqq1l_R-hSA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用 retry-decorator 修饰的函数，对任何异常最多尝试四次</p></figure><p id="989c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，更具体一点:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/043c5224b05465009c13a98d4adcf703.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*juxOt3AaEqg4AHZpIoilFw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用 retry on TimeoutError 修饰的函数将最多尝试两次。</p></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="0913" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结果:</h1><p id="4c96" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">调用修饰函数并遇到错误会导致如下结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/982e110c8b688453830f45dd62216a30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*2UAipPQ6OtajWfjrPLBLLw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">被调用的函数在 ConnectionRefusedError 上失败了两次，在 ConnectionResetError 上失败了一次，并在第四次尝试时成功。</p></figure><p id="ba58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们有很好的日志记录，我们打印出了<code class="fe lv lw lx ly b">args</code>和<code class="fe lv lw lx ly b">kwargs</code>以及函数名，这将使调试和修复问题变得轻而易举(如果在所有重试次数用完之后错误仍然存在)。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="8de7" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="f8f0" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">这就是了。您了解了装饰器如何在 Python 中工作，以及如何用一个简单的重试装饰器来装饰您的任务关键型函数，以确保它们即使在面临一些不确定性时也能执行。</p><p id="5d04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你喜欢你所阅读的内容，并且不想错过新的故事，请在此订阅:</p><div class="or os gp gr ot ou"><a href="https://medium.com/@fabianbosler/membership" rel="noopener follow" target="_blank"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd iu gy z fp oz fr fs pa fu fw is bi translated">通过我的推荐链接加入 Medium-Fabian Bosler</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">medium.com</p></div></div><div class="pd l"><div class="pe l pf pg ph pd pi ks ou"/></div></div></a></div><p id="b5ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于如何加速代码的进一步阅读:</p><div class="or os gp gr ot ou"><a href="https://medium.com/better-programming/every-python-programmer-should-know-the-not-so-secret-threadpool-642ec47f2000" rel="noopener follow" target="_blank"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd iu gy z fp oz fr fs pa fu fw is bi translated">每个 Python 程序员都应该知道并不秘密的线程池</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">通过多线程，您只需要几行代码就可以将代码速度提高几个数量级</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">medium.com</p></div></div><div class="pd l"><div class="pj l pf pg ph pd pi ks ou"/></div></div></a></div><div class="or os gp gr ot ou"><a href="https://medium.com/better-programming/every-python-programmer-should-know-lru-cache-from-the-standard-library-8e6c20c6bc49" rel="noopener follow" target="_blank"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd iu gy z fp oz fr fs pa fu fw is bi translated">每个 Python 程序员都应该知道标准库中的 Lru_cache</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">通过使用简单的缓存功能，只需一行代码就可以加快函数的速度</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">medium.com</p></div></div><div class="pd l"><div class="pk l pf pg ph pd pi ks ou"/></div></div></a></div></div></div>    
</body>
</html>