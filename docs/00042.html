<html>
<head>
<title>Logic Programming — Rethinking The Way We Program</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">逻辑编程——重新思考我们编程的方式</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/logic-programming-rethinking-the-way-we-program-8706b2adc3f1?source=collection_archive---------13-----------------------#2020-01-02">https://towardsdatascience.com/logic-programming-rethinking-the-way-we-program-8706b2adc3f1?source=collection_archive---------13-----------------------#2020-01-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9ab2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用Prolog介绍逻辑编程(和约束逻辑编程)中的一些最基本的概念。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4765790b57378b32d7f40ca6333ba13d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a9Mg8qd1IhJXZDElxYjwMQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:<a class="ae kv" href="https://pixabay.com/photos/art-school-of-athens-raphaël-1143741/" rel="noopener ugc nofollow" target="_blank"> Janeb13 </a></p></figure><h1 id="12b1" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">介绍</h1><p id="7d24" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">如果你以前编写过代码，你很可能熟悉命令式语言，比如Python、Java或C++。在这种范例中，程序是一系列指令，当执行时，这些指令修改它的状态。尽管这是最常见的编程方式，但不是本文的重点。</p><p id="6a3f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">相反，我们将介绍一种不同的编程范式，<strong class="lq ir">逻辑编程</strong>，其中程序是关系的数据库。当我们试图用最流行的逻辑语言之一<strong class="lq ir"> prolog </strong>解决一些简单的问题时，我们将展示主要的概念。</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="e7c5" class="kw kx iq bd ky kz mw lb lc ld mx lf lg jw my jx li jz mz ka lk kc na kd lm ln bi translated">与关系打交道——苏格拉底会死吗？</h1><p id="7d14" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">逻辑编程中最基本的概念之一是<strong class="lq ir">关系</strong>。但是关系到底是什么呢？</p><p id="fde5" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">为了更清楚地理解这一点，让我们看一段非常简单的prolog代码(你可以在这里下载prolog <a class="ae kv" href="https://www.swi-prolog.org/download/stable" rel="noopener ugc nofollow" target="_blank"/></p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="4676" class="ng kx iq nc b gy nh ni l nj nk">mortal(X) :- man(X).</span></pre><p id="bf80" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">一般情况下，<strong class="lq ir">“A:-B”</strong>给出的关系读作<strong class="lq ir">“若B则A”</strong>。上面的例子可以解读为，“如果你是人，那么你就是凡人”，又名<strong class="lq ir">“人是凡人】</strong>。请注意，句号只是用来结束关系的。现在，假设我们添加以下内容:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="f5a0" class="ng kx iq nc b gy nh ni l nj nk">man(socrates).</span></pre><p id="9b22" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这才陈述，<strong class="lq ir">“苏格拉底是人”</strong>。现在，你可能会想，“这很好，但是有什么意义呢？”我们定义关系的原因是我们能够执行<strong class="lq ir">查询</strong>。在prolog中，我们可以执行简单的查询:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="384a" class="ng kx iq nc b gy nh ni l nj nk">?- mortal(socrates).<br/>true.</span></pre><p id="8c44" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">上面查询的结果是<strong class="lq ir">【苏格拉底是凡人】</strong>。它使用我们构建的关系数据库来判断苏格拉底是一个人，既然人都会死，那么苏格拉底也一定会死。相反，如果我们想遍历所有人，我们可以这样做:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="0714" class="ng kx iq nc b gy nh ni l nj nk">?- mortal(X).<br/>X = socrates.</span></pre><p id="ffbf" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在prolog中，大写字母用来表示变量。</p><h2 id="3b9a" class="ng kx iq bd ky nl nm dn lc nn no dp lg lx np nq li mb nr ns lk mf nt nu lm nv bi translated">有向图的简单示例</h2><p id="39d8" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">为了用一个更全面的例子来说明这一点，让我们假设我们得到了下面的有向图，并且对建模和从中做出推论感兴趣。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/c6e6a3ac38933765317bc17c7718405a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*inHO5G4DOy6VJ9D0O79vfw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:<a class="ae kv" href="https://commons.wikimedia.org/wiki/File:Directed_graph.svg" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></figure><p id="1522" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们想做的第一件自然的事情是，以某种方式找到图形的表示。最明显的方法是用它的联系来表示它。</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="3796" class="ng kx iq nc b gy nh ni l nj nk">arrow(1,2).<br/>arrow(1,3).<br/>arrow(3,2).<br/>arrow(3,4).<br/>arrow(4,3).</span></pre><p id="1f94" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这个应该挺直观的。例如，<strong class="lq ir">箭头(1，2) </strong>只是表示从顶点<strong class="lq ir"> 1 </strong>到顶点<strong class="lq ir"> 2 </strong>有一个箭头。</p><p id="c19d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在，假设我们希望确定是否存在从给定节点<strong class="lq ir"> A </strong>到节点<strong class="lq ir"> B </strong>的路径。我们如何使用逻辑编程对此建模？让我们直观地思考一下这个问题。有两种可能的情况:要么<strong class="lq ir"> A </strong>和<strong class="lq ir"> B </strong>是邻居，这种情况下我们需要检查是否存在从<strong class="lq ir"> A </strong>到<strong class="lq ir"> B </strong>的箭头。否则，如果存在从<strong class="lq ir"> A </strong>到某个其他顶点<strong class="lq ir"> C </strong>的箭头以及从<strong class="lq ir"> C </strong>到<strong class="lq ir"> B </strong>的路径，则存在从<strong class="lq ir"> A </strong>到<strong class="lq ir"> B </strong>的路径。</p><p id="3fd8" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">第一个关系可以很容易地写成:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="87f2" class="ng kx iq nc b gy nh ni l nj nk">is_path(A,B) :- arrow(A, B). </span></pre><p id="ce1d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">第二个也相当简单:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="8163" class="ng kx iq nc b gy nh ni l nj nk">is_path(A,B) :-<br/>     arrow(A, C),<br/>     is_path(C, B). </span></pre><p id="db3e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在第二种情况下，逗号用来表示逻辑“与”。例如，从<strong class="lq ir"> 1 </strong>到<strong class="lq ir"> 4 </strong>有一条路径，因为从<strong class="lq ir"> 1 </strong>到<strong class="lq ir"> 3 </strong>有一个箭头，从<strong class="lq ir"> 3 </strong>到<strong class="lq ir"> 4 </strong>有一条路径。</p><p id="caef" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们可以更进一步，找出路径本身。我们可以这样定义<strong class="lq ir"> is_path/3 </strong>(这里的<strong class="lq ir"> /3 </strong>只是表示有3个自变量):</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="288f" class="ng kx iq nc b gy nh ni l nj nk">is_path(A, B, P). </span></pre><p id="5208" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们现在要给出条件来确定<strong class="lq ir"> P </strong>何时是从<strong class="lq ir"> A </strong>到<strong class="lq ir"> B </strong>的路径。为了清楚起见，我们希望以这样一种方式定义<strong class="lq ir"> is_path/3 </strong>,从而获得以下查询结果:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="b7e4" class="ng kx iq nc b gy nh ni l nj nk">?- is_path(1,4,[1,3,4]).<br/>true</span></pre><p id="c5b4" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们来写<strong class="lq ir"> is_path/3 </strong>，一步一步来。基本情况很简单:我们只需检查<strong class="lq ir"> P </strong>是否为<strong class="lq ir">【A，B】</strong>以及是否存在从<strong class="lq ir"> A </strong>到<strong class="lq ir"> B </strong>的箭头。</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="3073" class="ng kx iq nc b gy nh ni l nj nk">is_path(A, B, P) :-<br/>     P  = [A, B],<br/>     arrow(A,B). </span></pre><p id="d4b7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">另一种情况可以如下进行:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="ab61" class="ng kx iq nc b gy nh ni l nj nk">is_path(A, B, P) :-<br/>     P = [A|Tail],<br/>     arrow(A, C), <br/>     is_path(C, B, Tail).</span></pre><p id="2c20" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在让我们仔细看看上面的代码。我们做的第一件事是检查<strong class="lq ir"> P </strong>的形式:<strong class="lq ir"> A </strong>加上一个包含<strong class="lq ir"> A </strong>之后的元素的列表。然后，我们所做的就是检查是否存在从<strong class="lq ir"> A </strong>到其他顶点<strong class="lq ir"> C </strong>的箭头，并递归地尝试查看<strong class="lq ir"> P </strong>的尾部是否是从<strong class="lq ir"> C </strong>到<strong class="lq ir"> B </strong>的路径。</p><p id="e03e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如果我们把这个应用到前面的例子中，<strong class="lq ir">是_path(1，4，[1，3，4]) </strong>，我们需要检查<strong class="lq ir">【1，3，4】</strong>是否是从<strong class="lq ir"> 1 </strong>到<strong class="lq ir"> 4 </strong>的路径。我们看到<strong class="lq ir"> P </strong>可以写成<strong class="lq ir">【1 | Tail】</strong>带<strong class="lq ir">尾</strong>为<strong class="lq ir">【3，4】</strong>。因此，<strong class="lq ir"> [1，3，4] </strong>是从<strong class="lq ir"> 1 </strong>到<strong class="lq ir"> 4 </strong>的路径。</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="f71e" class="kw kx iq bd ky kz mw lb lc ld mx lf lg jw my jx li jz mz ka lk kc na kd lm ln bi translated">约束逻辑编程</h1><p id="b150" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">到目前为止，我们一直在Herbrand域上工作，但prolog(以及一般的逻辑编程)真正出彩的地方是在有限域上工作时，<strong class="lq ir"> CLP(FD) </strong>或reals，<strong class="lq ir"> CLP(ℝ) </strong>。</p><h2 id="142b" class="ng kx iq bd ky nl nm dn lc nn no dp lg lx np nq li mb nr ns lk mf nt nu lm nv bi translated">中电(R)</h2><p id="4b7a" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">ℝ上的约束逻辑编程允许你简化和求解实数上的方程组。在prolog中，我们首先需要按如下方式导入它:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="baf6" class="ng kx iq nc b gy nh ni l nj nk">:- use_module(library(clpr)).</span></pre><p id="35e8" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">为了给出一个简单明了的例子，让我们看看下面的方程组:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/d9040fe8b78d4d272be2250000ed3dbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:312/format:webp/1*P-YIYPnCD2eiApMgvMx8VA.png"/></div></figure><p id="4a27" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在prolog中表示这一点非常简单:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="646a" class="ng kx iq nc b gy nh ni l nj nk">?- {X + Y = 0, X &lt; 3, X &gt;= 2}.</span></pre><p id="c8a0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">该查询的结果将是上述系统的最简化版本，在这种情况下:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="29a9" class="ng kx iq nc b gy nh ni l nj nk">{X&gt;=2.0, X&lt;3.0, Y= -X}.</span></pre><p id="7dea" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这可用于简化(和求解)具有许多不同约束的方程。</p><h2 id="8eef" class="ng kx iq bd ky nl nm dn lc nn no dp lg lx np nq li mb nr ns lk mf nt nu lm nv bi translated">CLP(FD)</h2><p id="134d" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">有限域上的约束编程更适用于日常问题，如任务调度、优化或解谜(如n皇后问题)。</p><p id="2588" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">下面通过一个简单的例子来介绍一下<strong class="lq ir"> CLP(FD) </strong>。我们将考虑以下难题:我们需要给每个字母分配整数，使得</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/32ba109e9345799d6ce35f4c4bf3ef85.png" data-original-src="https://miro.medium.com/v2/resize:fit:584/format:webp/1*l7gYG9T9wejaSekCNVpK6g.png"/></div></figure><p id="ac62" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在prolog中，我们可以编写这个简单的程序来解决上述难题:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="532c" class="ng kx iq nc b gy nh ni l nj nk">:- use_module(library(clpfd)).<br/>puzzle([V,E,R,Y] + [N,I,C,E] = [M,E,M,E,S]) :-<br/>     Variables = [V,E,R,Y,N,I,C,M,S],<br/>     Variables ins 0..9,<br/>     all_different(Variables),<br/>     (1000*V + 100*E + 10*R + Y) + <br/>     (1000*N + 100*I + 10*C + E) #=<br/>     (10000*M  + 1000*E + 100*M + 10*E + S),<br/>     V #\= 0, N #\=0, M#\=0,<br/>     label(Variables).</span></pre><p id="70a6" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们首先将所有需要赋值的<strong class="lq ir">变量</strong>分组。接下来我们要做的是指定它们的域(在<strong class="lq ir"> 0 </strong>和<strong class="lq ir"> 9 </strong>之间)。然后，我们强迫他们都不一样。主要部分包括放置由难题给出的主要约束(在<strong class="lq ir"> CLP(FD </strong>)中，约束<strong class="lq ir"> " </strong> = "的语法是<strong class="lq ir"> "# </strong> = ")。此外，我们确保<strong class="lq ir"> </strong> V、<strong class="lq ir"> </strong> N和<strong class="lq ir"> </strong> M不同于<strong class="lq ir"> </strong> 0。我们做的最后一件事是<strong class="lq ir"> labe </strong> l，它迫使prolog吐出单个解决方案，而不是打印出最终传播的约束。</p><p id="25a7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在，我们可以进行以下查询来获得解决方案:</p><pre class="kg kh ki kj gt nb nc nd ne aw nf bi"><span id="3f1c" class="ng kx iq nc b gy nh ni l nj nk">?- puzzle(X).<br/>X = ([7, 6, 2, 3]+[8, 5, 4, 6]=[1, 6, 1, 6, 9])</span></pre></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="5de0" class="kw kx iq bd ky kz mw lb lc ld mx lf lg jw my jx li jz mz ka lk kc na kd lm ln bi translated">结论</h1><p id="43d0" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在本教程中，我们仅仅触及了逻辑编程的表面。在群论和人工智能(尤其是自然语言处理)中有更高级的应用，仅举几例。希望您现在对逻辑编程的一般概念以及如何将其应用于各种问题有了更好的了解。</p></div></div>    
</body>
</html>