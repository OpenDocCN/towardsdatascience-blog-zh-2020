<html>
<head>
<title>Predicting Apple Stock Prices with Neural Networks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用神经网络预测苹果股票价格</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/predicting-apple-stock-prices-with-neural-networks-4aefdf10afd0?source=collection_archive---------26-----------------------#2020-07-09">https://towardsdatascience.com/predicting-apple-stock-prices-with-neural-networks-4aefdf10afd0?source=collection_archive---------26-----------------------#2020-07-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ba8c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何使用递归神经网络预测股票价格？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/30fe90a694598f08f66b7666c0df2e8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IWKTDXElpzLDMMnFLdn4Zw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">克里斯·利维拉尼在<a class="ae ky" href="https://unsplash.com/s/photos/stock?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="391b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">股票价格预测肯定不是一件容易的事情，因为有许多因素需要考虑。整体市场状况、竞争对手的表现、新产品发布、全球关系的缓和都是有可能提高或降低股价的一些关键因素。除此之外，还可能发生意想不到的事件，例如我们目前遇到的冠状病毒情况。</p><p id="92d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们到目前为止列出的因素很难预测。因此，在这篇文章中，我们将把它们放在一边。可以用来预测股票价格的一个关键因素是历史价格。例如，如果一只股票已经稳定上涨了两年，我们可能会认为它还会继续上涨一个月。然而，股票通常不会遵循简单的连续上升或下降趋势。因此，我们需要更复杂的工具来进行难以捕捉的观察。</p><p id="79b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">LSTM(长短期记忆)，这是一种 RNN(递归神经网络)，可用于预测股票价格使用历史数据。LSTM 适合对序列数据建模，因为它维护一个内部状态来跟踪它已经看到的数据。LSTMs 的常见应用包括时间序列分析和自然语言处理。</p><p id="744e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们首先使用 pandas <strong class="lb iu"> datareader </strong>模块获取数据。它使得用几行代码获取股票价格数据变得非常简单。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="84db" class="ma mb it lw b gy mc md l me mf">import numpy as np<br/>import pandas as pd<br/>from pandas_datareader import data</span><span id="f592" class="ma mb it lw b gy mg md l me mf">aapl = data.DataReader("AAPL", <br/>                        start='2015-1-1',<br/>                        end='2019-12-31',<br/>                        data_source='yahoo')</span></pre><p id="debb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仅此而已！我们现在已经将 2015 年至 2020 年的苹果股价数据保存在熊猫数据框架中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/80c4ae55ff37b7fca0d3226de04dcd6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*cm1T_edlsNJU1GUCrtIwSQ.png"/></div></figure><p id="95cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用调整后的收盘价格。我们来看看 2015 年到 2020 年的大趋势。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="c032" class="ma mb it lw b gy mc md l me mf">#import dataviz libraries<br/>import matplotlib.pyplot as plt<br/>import seaborn as sns<br/>sns.set(style='darkgrid')<br/>%matplotlib inline</span><span id="6556" class="ma mb it lw b gy mg md l me mf">#Plot "Adj Close"<br/>plt.figure(figsize=(12,8))<br/>plt.title("APPLE Stock Prices", fontsize=15)<br/>sns.lineplot(x=aapl.index, y='Adj Close', data=aapl)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mi"><img src="../Images/0b6b29d8e308febbbf41c0d31c02c663.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t3XjrzEw8yOAJ0gmpz2RYw.png"/></div></div></figure><p id="8b1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2015 年似乎不是一个盈利的一年，随后是近 3 年的稳定上升趋势。我们观察到 2019 年底的急剧下降，随后是大约一年的稳定增长。</p><p id="54a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将尝试对 LSTM 层使用过去 90 天(即从 t-90 到 t-1)的历史价格来预测时间 t 的价格。请记住，我们将努力捕捉趋势，而不是确切的价格。</p><p id="be60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">LSTM 要求输入是具有形状(batch_size，timesteps，input_dim)的 3D 张量。</p><p id="c7c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于我们使用 90 天(t-90 到 t-1)的历史数据在时间 t 进行预测，因此<strong class="lb iu">时间步长</strong>的数量为 90。我们仅使用“Adj Close”价格进行预测，因此<strong class="lb iu"> input_dim </strong>为 1。Input_dim 可以通过添加附加功能来增加。例如，竞争对手股票价格的价值可能会影响苹果公司的股票价格。如果我们还使用第二个变量来进行预测，那么 input_dim 将是 2。<strong class="lb iu"> batch_size </strong>是在更新权重之前馈入 LSTM 层的观测值的数量。</p><h1 id="7ab5" class="mj mb it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated"><strong class="ak">数据预处理</strong></h1><p id="b66d" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">我们需要格式化数据，使每个输入包含 90 天期间(t-90 到 t-1)的股票价格，目标是时间 t 的价格。我们可以使用基本的 for 循环，如下所示:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="e741" class="ma mb it lw b gy mc md l me mf">hist = []<br/>target = []<br/>length = 90</span><span id="1de8" class="ma mb it lw b gy mg md l me mf">adj_close = aapl['Adj Close']</span><span id="dff6" class="ma mb it lw b gy mg md l me mf">for i in range(len(adj_close) - length):<br/>   x = adj_close[i:i+length]<br/>   y = adj_close[i+length]<br/>   hist.append(x)<br/>   target.append(y)</span></pre><p id="1904" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">“hist”的每个元素是 90 个项目的列表。既然我们加 1，那么“hist”的第二个元素的最后一项一定等于“target”的第一个元素。我们来确认一下:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="75ed" class="ma mb it lw b gy mc md l me mf">hist[1][89] == target[0]<br/>True</span></pre><p id="62b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">“历史”和“目标”是列表。我们需要将它们转换成 numpy 数组，并将目标变量整形为二维数组。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="434d" class="ma mb it lw b gy mc md l me mf">hist = np.array(hist)<br/>target = np.array(target)<br/>target = target.reshape(-1,1)</span><span id="7c9d" class="ma mb it lw b gy mg md l me mf">print(hist.shape)<br/>print(target.shape)</span><span id="2f73" class="ma mb it lw b gy mg md l me mf">(1168, 90) <br/>(1168, 1)</span></pre><p id="c6c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于在神经网络中进行了过多的计算，因此最好将这些值标准化。标准化可以通过一些简单的数学运算来完成，或者可以使用库的预定义函数。我会用 scikit-learn 的<strong class="lb iu"> MinMaxScaler </strong>。默认情况下，它将值规范化为范围[0，1]。</p><p id="9170" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们正在进行一项监督学习任务。我们将使用一些数据来训练该模型，并使用以前未见过的数据来测试其性能。因此，我们需要将数据分成训练集和测试集。为了获得准确的性能结果，模型不应该有任何关于测试集中数据的线索。在标准化数据时，我们也应该记住这一点。我们首先需要拆分数据。然后分别应用归一化。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="3450" class="ma mb it lw b gy mc md l me mf">#train/test split</span><span id="f70d" class="ma mb it lw b gy mg md l me mf">X_train = hist[:1138]<br/>X_test = hist[1138:]</span><span id="d314" class="ma mb it lw b gy mg md l me mf">y_train = target[:1138]<br/>y_test = target[1138:]</span></pre><p id="05a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们以这样一种方式分割数据，即用 1138 天的数据训练模型，并用随后 30 天的数据进行测试。</p><p id="06c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以进行标准化了。我们将首先创建一个 MinMaxScaler 对象，并对训练集应用<strong class="lb iu"> fit_transform </strong>方法。然后，我们将仅对测试集应用<strong class="lb iu">转换</strong>方法。进行这种分离是非常重要的。否则，我们将会从测试集中向模型泄露信息。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="3dcd" class="ma mb it lw b gy mc md l me mf">from sklearn.preprocessing import MinMaxScaler<br/>sc = MinMaxScaler()</span><span id="d3d4" class="ma mb it lw b gy mg md l me mf">#train set, fit_transform<br/>X_train_scaled = sc.fit_transform(X_train)<br/>y_train_scaled = sc.fit_transform(y_train)</span><span id="eca9" class="ma mb it lw b gy mg md l me mf">#test set, only transform<br/>X_test_scaled = sc.transform(X_test)<br/>y_test_scaled = sc.transform(y_test)</span></pre><p id="cb16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据预处理的最后一步是将输入转换为三维数组，因为 LSTM 接受三维数组作为输入。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="8c35" class="ma mb it lw b gy mc md l me mf">X_train_scaled = X_train_scaled.reshape((len(X_train_scaled), length, 1))</span><span id="3b2f" class="ma mb it lw b gy mg md l me mf">X_test_scaled = X_test_scaled.reshape((len(X_test_scaled), length, 1))</span></pre></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><h1 id="3804" class="mj mb it bd mk ml nm mn mo mp nn mr ms jz no ka mu kc np kd mw kf nq kg my mz bi translated"><strong class="ak">型号</strong></h1><p id="806c" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">我们将使用 Keras 的 LSTM 层实现神经网络，Keras 是 TensorFlow 的高级 API。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="1305" class="ma mb it lw b gy mc md l me mf">import tensorflow as tf<br/>from tensorflow.keras import layers</span></pre><p id="ae07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将创建一个有 4 个 LSTM 层和一个密集层的序列模型。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="7690" class="ma mb it lw b gy mc md l me mf">model = tf.keras.Sequential()</span><span id="1b57" class="ma mb it lw b gy mg md l me mf">model.add(layers.LSTM(units=64, return_sequences=True, input_shape=(90,1), dropout=0.2))</span><span id="df01" class="ma mb it lw b gy mg md l me mf">model.add(layers.LSTM(units=32, return_sequences=True, dropout=0.2))</span><span id="ae9a" class="ma mb it lw b gy mg md l me mf">model.add(layers.LSTM(units=32, return_sequences=True, dropout=0.2))</span><span id="3fbc" class="ma mb it lw b gy mg md l me mf">model.add(layers.LSTM(units=16, dropout=0.2))</span><span id="2aab" class="ma mb it lw b gy mg md l me mf">model.add(layers.Dense(units=1))</span><span id="bf42" class="ma mb it lw b gy mg md l me mf">model.summary()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/de00163ac7ff568a970279339ee89928.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gEfcMk8TVu_PTDjSmYvWqg.png"/></div></div></figure><p id="db68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一些要点需要记住:</p><ul class=""><li id="cbb8" class="ns nt it lb b lc ld lf lg li nu lm nv lq nw lu nx ny nz oa bi translated">如果一个 LSTM 层后面是另一个 LSTM 层，<strong class="lb iu"> return_sequences </strong>参数必须设为真。</li><li id="a432" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><strong class="lb iu">输入 _ 形状</strong>参数只需要为第一个 LSTM 层指定。对于其他层，模型根据前一层的输出计算出输入。</li><li id="3f72" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><strong class="lb iu"> Input_shape </strong>参数是一个包含<strong class="lb iu">时间步长</strong>和<strong class="lb iu"> input_dim </strong>的元组。Batch_size 是在训练期间指定的。</li><li id="e4cb" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><strong class="lb iu">单位</strong>参数是一层中使用的节点数。没有严格的规则来定义最佳节点数。</li><li id="fafd" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><strong class="lb iu">剔除</strong>用于防止模型过拟合。</li><li id="a7c3" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">密集图层的单位应为 1，因为它被用作输出图层。</li></ul><p id="cbc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以通过指定优化器和损失函数来编译模型。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="d617" class="ma mb it lw b gy mc md l me mf">model.compile(optimizer='adam', loss='mean_squared_error')</span></pre><p id="bacb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们训练模型。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="2295" class="ma mb it lw b gy mc md l me mf">history = model.fit(X_train_scaled, y_train_scaled, <br/>                    epochs=30, batch_size=16)</span></pre><p id="74cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经讨论了 batch_size。Epochs 表示整个数据集输入神经网络的次数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/99335cecc89576a5c99f6d6c4953ee66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KqPQL8r7vBQ6ZU3JzIXlbg.png"/></div></div></figure><p id="1e17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你在每个时期都会看到数字 72。它来自训练点数除以批量大小。X_train_scaled 有 1138 个数据点。批量大小为 16。1138/15=71.125，所以它在 72 个周期内完成。</p><p id="c42a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该模型实现了 0.0017 的 MSE。让我们看看它是如何通过 30 个时代发生变化的。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="f553" class="ma mb it lw b gy mc md l me mf">loss = history.history['loss']<br/>epoch_count = range(1, len(loss) + 1)</span><span id="5770" class="ma mb it lw b gy mg md l me mf">plt.figure(figsize=(12,8))<br/>plt.plot(epoch_count, loss, 'r--')<br/>plt.legend(['Training Loss'])<br/>plt.xlabel('Epoch')<br/>plt.ylabel('Loss')<br/>plt.show();</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/34e39f2c036bc5e2d75a26c85a2d937a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OCMXsbe5cYbxEiqwJuhWMg.png"/></div></div></figure><p id="aed0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该损失呈下降趋势，在第 25 个纪元后低于 0.002。然而，该模型尚未收敛。如果我们做更多的纪元，损失似乎会继续减少。让我们试试 50 个纪元。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/ca84c2249047a870dcdc9e03c0ab1333.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8uCFFBngFOyE3r8mFiM9_g.png"/></div></div></figure><p id="1241" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在亏损在 0.001 以下。请注意，不断减少损失并不总是最佳做法。过了一段时间后，我们可能会有一个过度拟合的模型，它过于关注训练集，而不是很好地推广。</p><p id="0303" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是时候做预测了。我们将尝试预测未来 30 天的股票价格趋势。请记住，我们的目标是预测趋势，而不是实际价格。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="c489" class="ma mb it lw b gy mc md l me mf">pred = model.predict(X_test_scaled)<br/>pred_transformed = sc.inverse_transform(pred)</span><span id="7ad0" class="ma mb it lw b gy mg md l me mf">y_test_transformed = sc.inverse_transform(y_test_scaled)</span><span id="7070" class="ma mb it lw b gy mg md l me mf">plt.figure(figsize=(12,8))<br/>plt.plot(y_test_transformed, color='blue', label='Real')<br/>plt.plot(pred_transformed, color='red', label='Prediction')<br/>plt.title('Apple Stock Price Prediction')<br/>plt.legend()<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/5d6d5eb1c5b6772c4cfdf563b15e37e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xHP06okBDD-pvKLT_Xc14w.png"/></div></div></figure><p id="14b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管这些值不完全匹配，但我们能够预测 30 天内的总体趋势。该模型在几天后的第 7 天到第 10 天之间对下降做出反应。然后它赶上了上升趋势。</p><p id="d9bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有许多方法可以尝试改进该模型的性能。您可以通过调整获得更好的结果:</p><ul class=""><li id="f3f9" class="ns nt it lb b lc ld lf lg li nu lm nv lq nw lu nx ny nz oa bi translated">层数</li><li id="c390" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">一层中的节点数</li><li id="7a22" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">时间步数</li><li id="b6fe" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">辍学率</li><li id="4008" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">时代数</li><li id="5f6d" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">批量</li></ul></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><p id="536a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读。如果您有任何反馈，请告诉我。</p></div></div>    
</body>
</html>