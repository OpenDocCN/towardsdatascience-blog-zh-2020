<html>
<head>
<title>End-to-end AWS Quantitative Analysis: Setting Up Our Scripts and AWS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">端到端AWS定量分析:设置我们的脚本和AWS</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/end-to-end-quantitative-trading-part-1-798dcfeb165a?source=collection_archive---------24-----------------------#2020-02-14">https://towardsdatascience.com/end-to-end-quantitative-trading-part-1-798dcfeb165a?source=collection_archive---------24-----------------------#2020-02-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/d4b0e2a5980c174d1a7d8413bfcf8281.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3UNtfZrmEiv3XFKs_xaRcA.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://www.pexels.com/@energepic-com-27411?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">energepic.com</a>从<a class="ae jg" href="https://www.pexels.com/photo/blue-and-yellow-graph-on-stock-market-monitor-159888/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">派克斯</a>拍摄</p></figure><h2 id="b10c" class="jh ji jj bd b dl jk jl jm jn jo jp dk jq translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/building-an-aws-pipeline" rel="noopener" target="_blank">建设AWS管道</a></h2><div class=""/><p id="c591" class="pw-post-body-paragraph kp kq jj kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">机器学习关注的是如何理解大量难以处理的数据。很大一部分机器学习工作现在可以在台式机上完成，甚至可以在笔记本电脑上完成，只要配置合适。</p><p id="2cca" class="pw-post-body-paragraph kp kq jj kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">尽管如此，仍有大量的工作需要在专业的云计算架构上完成，这些架构要在合理的时间内处理难以置信的大量数据。</p><p id="9d38" class="pw-post-body-paragraph kp kq jj kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在这篇文章中，我想重点介绍建立端到端管道的想法，这将利用亚马逊网络服务(AWS)进行量化交易。</p><p id="0dd9" class="pw-post-body-paragraph kp kq jj kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这篇文章的目的不是为您提供一台印钞机，而是展示在AWS上部署全自动工作流所需的步骤。</p><p id="7da1" class="pw-post-body-paragraph kp kq jj kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这组帖子将把工作流程分为四个主要部分:</p><ol class=""><li id="dc60" class="ln lo jj kr b ks kt kw kx la lp le lq li lr lm ls lt lu lv bi translated">编写脚本来获取数据，在数据上使用基本的ML模型，并将这些脚本存放在AWS上</li><li id="0cef" class="ln lo jj kr b ks lw kw lx la ly le lz li ma lm ls lt lu lv bi translated">为我们的基本ML模型建立一个AWS框架，并自动使用它</li><li id="034f" class="ln lo jj kr b ks lw kw lx la ly le lz li ma lm ls lt lu lv bi translated">通过Spark利用我们的ML功能</li><li id="3100" class="ln lo jj kr b ks lw kw lx la ly le lz li ma lm ls lt lu lv bi translated">在我们的ML完成运行后，自动准备我们的分析摘要</li></ol><h1 id="0073" class="mb mc jj bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">获取数据</h1><p id="987a" class="pw-post-body-paragraph kp kq jj kr b ks mz ku kv kw na ky kz la nb lc ld le nc lg lh li nd lk ll lm im bi translated">因为我们对股票的历史数据感兴趣，所以有几种选择。Quandl是一项可以提供每日股票数据(以分钟为单位)的服务，但它需要付费。对于这篇文章，我将选择免费选项，并使用雅虎财经。</p><p id="94e0" class="pw-post-body-paragraph kp kq jj kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">哈哈。Finance有几个库被设计成通过它的API与它交互，并建立到Python的桥梁，所以我将使用<a class="ae jg" href="https://github.com/ranaroussi/yfinance" rel="noopener ugc nofollow" target="_blank"> yfinance </a>。</p><p id="cdad" class="pw-post-body-paragraph kp kq jj kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">如果我们使用yfinance，我们可以构建以下代码</p><figure class="ne nf ng nh gt iv"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="ccb6" class="pw-post-body-paragraph kp kq jj kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">虽然这段代码完成了工作，但是到目前为止，它只针对一个独特的用例场景:</p><ol class=""><li id="dd09" class="ln lo jj kr b ks kt kw kx la lp le lq li lr lm ls lt lu lv bi translated">它只获取AAPL的数据</li><li id="96bd" class="ln lo jj kr b ks lw kw lx la ly le lz li ma lm ls lt lu lv bi translated">并且只在特定的日期范围内这样做</li></ol><p id="8328" class="pw-post-body-paragraph kp kq jj kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们也许应该把它包装成一个函数，这样我们就可以使它稍微更通用一些</p><figure class="ne nf ng nh gt iv"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="9a53" class="pw-post-body-paragraph kp kq jj kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在，我们需要一些方法来获取相关的日期，并使其适用于雅虎上的任何资产！金融。</p><h1 id="9ff8" class="mb mc jj bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">计算开始和结束日期</h1><p id="8b42" class="pw-post-body-paragraph kp kq jj kr b ks mz ku kv kw na ky kz la nb lc ld le nc lg lh li nd lk ll lm im bi translated">让我们从简单的部分开始，开始和结束时间。我们可以很容易地得到今天的日期，然后找到五年前的日期。然后，我们可以很容易地将两者转换成适当的字符串类型。</p><figure class="ne nf ng nh gt iv"><div class="bz fp l di"><div class="ni nj l"/></div></figure><pre class="ne nf ng nh gt nk nl nm nn aw no bi"><span id="3d95" class="np mc jj nl b gy nq nr l ns nt">&gt;&gt;&gt;&gt; 2020-02-13<br/>&gt;&gt;&gt;&gt; 2015-02-13</span></pre><p id="855f" class="pw-post-body-paragraph kp kq jj kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们可能也应该将它封装成一个函数:</p><figure class="ne nf ng nh gt iv"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h1 id="438e" class="mb mc jj bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">当我们获得数据时进行处理</h1><p id="28c6" class="pw-post-body-paragraph kp kq jj kr b ks mz ku kv kw na ky kz la nb lc ld le nc lg lh li nd lk ll lm im bi translated">获得数据后，我们想对它做一点处理，为机器学习做准备。<br/>首先，我们将在数据框中添加一个<code class="fe nu nv nw nl b">Return</code>字段，记录当天的回报是否为正。</p><p id="fb3b" class="pw-post-body-paragraph kp kq jj kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们可以计算连续收盘价之间的差值，也可以计算同一天的开盘价和收盘价之间的差值。我选择后者，只是为了让人们意识到这也是一个可以考虑的选择。</p><figure class="ne nf ng nh gt iv"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="77a0" class="pw-post-body-paragraph kp kq jj kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">一旦我们得到了回报，我们就可以创建一些特性，并在以后为我们的ML算法创建一个目标。让我们把那些也加上</p><figure class="ne nf ng nh gt iv"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h1 id="a834" class="mb mc jj bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">把所有的放在一起</h1><p id="f767" class="pw-post-body-paragraph kp kq jj kr b ks mz ku kv kw na ky kz la nb lc ld le nc lg lh li nd lk ll lm im bi translated">这部分代码的最后一部分是将我们编写的所有代码放入一个脚本，该脚本接受我们的股票id和一个路径作为命令行参数，并将股票数据帧保存到提供的路径中。我们将添加更多的文档来创建更易于管理的代码库。</p><p id="a9f3" class="pw-post-body-paragraph kp kq jj kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们将把这个脚本称为“获取数据”</p><figure class="ne nf ng nh gt iv"><div class="bz fp l di"><div class="ni nj l"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">获取数据</p></figure><p id="512a" class="pw-post-body-paragraph kp kq jj kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们已经添加了相当多的docstrings和其他文档，以防我们以后想要更改某些内容。</p><p id="bacb" class="pw-post-body-paragraph kp kq jj kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在我们可以称这个脚本为:</p><pre class="ne nf ng nh gt nk nl nm nn aw no bi"><span id="0aeb" class="np mc jj nl b gy nq nr l ns nt">python obtain_data.py MSFT  --output_directory \ /usr/boris/destination</span></pre><p id="c636" class="pw-post-body-paragraph kp kq jj kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">让它获取微软(MSFT)的数据，并将结果写入/usr/Boris/destination/msft . csv中的本地CSV文件</p><h1 id="1e62" class="mb mc jj bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">处理数据</h1><p id="0c05" class="pw-post-body-paragraph kp kq jj kr b ks mz ku kv kw na ky kz la nb lc ld le nc lg lh li nd lk ll lm im bi translated">在我们获得数据之后，我们想要以某种方式处理它。出于本教程的目的，我们将假设我们想要使用一个决策树来使用我们之前创建的<code class="fe nu nv nw nl b">Target</code>列对我们的数据进行分类。我们将从使用sklearn的<a class="ae jg" href="https://scikit-learn.org/stable/modules/generated/sklearn.tree.DecisionTreeClassifier.html" rel="noopener ugc nofollow" target="_blank">决策树分类器</a>开始。</p><figure class="ne nf ng nh gt iv"><div class="bz fp l di"><div class="ni nj l"/></div></figure><pre class="ne nf ng nh gt nk nl nm nn aw no bi"><span id="d28a" class="np mc jj nl b gy nq nr l ns nt">&gt;&gt;&gt; 0.0002604</span></pre><p id="bd0a" class="pw-post-body-paragraph kp kq jj kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">很明显，对于这种规模的数据集，我们真的不需要AWS。我们可以做一点小手脚，用下面的代码让数据集变大:</p><figure class="ne nf ng nh gt iv"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="05d9" class="pw-post-body-paragraph kp kq jj kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在，数据集的大小最终达到41，222，144行，在我的笔记本电脑上处理大约需要10分钟。</p><p id="251a" class="pw-post-body-paragraph kp kq jj kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们将创建另一个python脚本，它接受一个文件位置作为命令行参数，将文件扩展为其原始大小的2倍⁵，然后处理它。在AWS上，我们将使用sklearn和Spark来比较处理时间。</p><figure class="ne nf ng nh gt iv"><div class="bz fp l di"><div class="ni nj l"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">流程_数据. py</p></figure><h1 id="f2ec" class="mb mc jj bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">将脚本放在可访问的位置</h1><p id="4244" class="pw-post-body-paragraph kp kq jj kr b ks mz ku kv kw na ky kz la nb lc ld le nc lg lh li nd lk ll lm im bi translated">我们希望AWS计算实例能够运行我们的脚本。我们可以做的一件事就是简单地使用SSH将文件传输到实例，但是稍后我们想让我们的实例自动设置、运行和拆除，而不需要我们做太多，所以我们将这些脚本放在AWS的S3存储桶中。这将使我们未来的计算实例可以轻松地访问该文件。</p><p id="35cf" class="pw-post-body-paragraph kp kq jj kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">首先，我们需要创建一个S3桶(1)，并给它一个有用的描述性名称。创建完成后，我们可以在S3仪表板中看到它(2)。</p><figure class="ne nf ng nh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nx"><img src="../Images/76440b6a5b70e32313e92e440a35971e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dkgSDygFH4liM_5aizB1Gw.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">创建S3存储桶</p></figure><p id="267f" class="pw-post-body-paragraph kp kq jj kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">然后，我们将脚本上传到bucket中，以便我们的AWS实例可以访问脚本及其功能</p><figure class="ne nf ng nh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nx"><img src="../Images/6dca9ba52f148a05b28d5446d6843ffb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*esNL6iUNorUUZVQ78pCxMQ.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">上传我们刚刚创建的文件</p></figure><p id="54ca" class="pw-post-body-paragraph kp kq jj kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">此外，我们将设置另外三个存储桶；一个用于日志文件，一个用于数据文件，一个用于安装bash文件。我们最终的S3建筑应该是这样的:</p><figure class="ne nf ng nh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nx"><img src="../Images/e14331f64921fccc45702b9b1c51e6d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GxulnfvMp_LnHPIcSgxU0Q.png"/></div></div></figure><p id="f739" class="pw-post-body-paragraph kp kq jj kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们做到了！</p><p id="33f8" class="pw-post-body-paragraph kp kq jj kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">一个python脚本，可以在AWS上使用，为我们挖掘数据。下一步是创建一个运行脚本和处理挖掘数据的地方。下一篇文章将详细讨论这个问题！</p></div></div>    
</body>
</html>