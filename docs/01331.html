<html>
<head>
<title>How to download files using Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用 Python 下载文件</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-download-files-using-python-ffbca63beb5c?source=collection_archive---------4-----------------------#2020-02-06">https://towardsdatascience.com/how-to-download-files-using-python-ffbca63beb5c?source=collection_archive---------4-----------------------#2020-02-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/10154e7747f3d022e1b3cb3c45229d74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9xv8X9df2wojULtL4Gx9sg.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">émile Perron 未喷涂的图像</p></figure><h2 id="bc34" class="jh ji jj bd b dl jk jl jm jn jo jp dk jq translated" aria-label="kicker paragraph">权威指南</h2><div class=""/><div class=""><h2 id="4c7a" class="pw-subtitle-paragraph kp js jj bd b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dk translated">了解如何使用 python 下载 web 抓取项目中的文件</h2></div><p id="ebc6" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi md translated"><span class="l me mf mg bm mh mi mj mk ml di"> P </span> ython 非常适合在互联网上抓取网页，但在从我想做的网站上抓取一些标题或链接后，我的首要任务之一就是下载文件。我需要一种方法来自动化这个过程！</p><p id="afa1" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这里我们将概述如何做到这一点。</p><h1 id="325b" class="mm mn jj bd mo mp mq mr ms mt mu mv mw ky mx kz my lb mz lc na le nb lf nc nd bi translated">到本文结束时，您将</h1><ol class=""><li id="0635" class="ne nf jj lj b lk ng ln nh lq ni lu nj ly nk mc nl nm nn no bi translated">注意 python 中 HTTP 处理包的选择</li></ol><p id="8620" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">2.详细了解请求包</p><p id="be25" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">2.知道如何使用请求包下载文件</p><p id="868b" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">3.如何用请求包处理大文件？</p><p id="5f72" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">4.如何下载使用请求包重定向的文件。</p><p id="dee2" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">python 中有很多处理互联网的包。你没有必要知道所有这些，但是让你知道为什么人们会选择其中一个。</p><p id="7bfd" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">下面是处理 HTTP 请求的不同包。</p><ul class=""><li id="eacb" class="ne nf jj lj b lk ll ln lo lq np lu nq ly nr mc ns nm nn no bi translated">内置包:urllib 和 urllib2、urllib3</li><li id="5919" class="ne nf jj lj b lk nt ln nu lq nv lu nw ly nx mc ns nm nn no bi translated">请求(基于 urllib3 包)</li><li id="a725" class="ne nf jj lj b lk nt ln nu lq nv lu nw ly nx mc ns nm nn no bi translated">grequests(扩展请求以处理异步 HTTP 请求)</li><li id="82d6" class="ne nf jj lj b lk nt ln nu lq nv lu nw ly nx mc ns nm nn no bi translated">aiohttp(另一个处理异步 http 的包)</li></ul><p id="7f79" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">你可能会问同步请求和异步请求有什么区别？为什么这很重要？</p><p id="49af" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">同步请求阻塞客户端(浏览器)，直到操作完成。这意味着有时 CPU 什么也不做，会浪费计算时间。在我看来效率很高！</p><p id="bff8" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">异步请求不会阻塞浏览器，这允许客户端同时执行其他任务。这允许轻松扩展 1000 个请求。</p><p id="9d2f" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">url-lib 和 url-lib2 包有许多样板文件，有时可能有点难以阅读。我使用 requests 包，因为它是可读的，并且能够管理您无论如何都需要发出的大多数 HTTP 请求。</p><p id="ce50" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">当您有大量 HTTP 请求时，异步包非常有用。这是一个复杂的话题，但是可以提高 python 脚本的效率。我会在后面的文章中回到这一点！</p><h1 id="87ef" class="mm mn jj bd mo mp mq mr ms mt mu mv mw ky mx kz my lb mz lc na le nb lf nc nd bi translated">请求包介绍</h1><p id="2edb" class="pw-post-body-paragraph lh li jj lj b lk ng kt lm ln nh kw lp lq ny ls lt lu nz lw lx ly oa ma mb mc im bi translated">要使用请求包，我们必须导入请求模块。然后，我们可以使用一系列方法与互联网互动。使用请求包的最常见方式是使用 requests.get 方法。在幕后，它对选择的 URL 执行 HTTP GET 请求。</p><p id="3841" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">首先，我们创建一个发送到服务器的请求对象，然后服务器发回一个响应。这个对象携带关于请求的所有数据。</p><pre class="ob oc od oe gt of og oh oi aw oj bi"><span id="4a74" class="ok mn jj og b gy ol om l on oo">import requests</span><span id="3529" class="ok mn jj og b gy op om l on oo">url = 'PLEASE INSERT URL LINK'<br/>html = requests.get(url)</span></pre><p id="b6eb" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">要访问这个对象，我们可以调用 text 方法。这将允许我们看到字符串形式的响应。请求根据从服务器返回的数据进行编码。</p><p id="d49c" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们收到的信息有两部分，头和主体。标题为我们提供了关于响应的信息。可以把邮件头想象成将邮件发送到计算机所需的所有信息。</p><p id="60e9" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">请看下面一个来自媒体标题的例子！有很多信息告诉我们关于反应。</p><pre class="ob oc od oe gt of og oh oi aw oj bi"><span id="7462" class="ok mn jj og b gy ol om l on oo">{'Date': 'Thu, 30 Jan 2020 17:06:12 GMT', <br/>'Content-Type': 'text/html; charset=utf-8', <br/>'Transfer-Encoding': 'chunked', <br/>'Connection': 'keep-alive', <br/>'Set-Cookie': 'uid=lo_NHI3i4bLD514; Expires=Fri, 29-Jan-21 17:06:12 GMT; Domain=.medium.com; Path=/; Secure; HttpOnly, <br/>optimizelyEndUserId=lo_NHI3i4bLD514; path=/; expires=Fri, 29 Jan 2021 17:06:12 GMT; domain=.medium.com; samesite=none; secure, <br/>sid=1:Hu5pQRgkgEyZr7Iq5hNn6Sns/FKPUZaBJBtDCMI+nmsU48zG2lXM+dtrtlefPkfv; path=/; expires=Fri, 29 Jan 2021 17:06:12 GMT; domain=.medium.com; samesite=none; secure; httponly', <br/>'Sepia-Upstream': 'production', <br/>'x-frame-options': 'allow-from medium.com', <br/>'cache-control': 'no-cache, <br/>no-store, max-age=0, must-revalidate', <br/>'medium-fulfilled-by': 'lite/master-20200129-184608-2156addefa, rito/master-20200129-204844-eee64d76ba, tutu/medium-39848', 'etag': 'W/"179e9-KtF+IBtxWFdtJWnZeOZBkcF8rX8"', <br/>'vary': 'Accept-Encoding',<br/> 'content-encoding': 'gzip', <br/>'x-envoy-upstream-service-time': '162', <br/>'Strict-Transport-Security': 'max-age=15552000; includeSubDomains; preload', <br/>'CF-Cache-Status': 'DYNAMIC', <br/>'Expect-CT': 'max-age=604800, <br/>report-uri="https://report-uri.cloudflare.com/cdn-cgi/beacon/expect-ct"', 'Alt-Svc': 'h3-24=":443"; ma=86400, h3-23=":443"; ma=86400', 'X-Content-Type-Options': 'nosniff', <br/>'Server': 'cloudflare', <br/>'CF-RAY': '55d508f64e9234c2-LHR'}</span></pre><p id="0910" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">request package get 方法下载响应的正文，而不要求许可。这将与下一节相关！</p><p id="82a7" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">为了下载文件，我们希望以字节而不是字符串的形式获取请求对象。为此，我们调用 response.content 方法，这样可以确保我们接收的数据是字节格式的。</p><p id="6e20" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在要写一个文件，我们可以使用一个 open 函数，它是 python 内置函数的样板文件。我们指定文件名，而“wb”指的是写入字节。Python 3 需要明确地知道数据是否是二进制的，这就是我们定义它的原因！</p><p id="9070" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">然后，我们使用 write 方法写入 get 请求的已定义二进制内容。</p><pre class="ob oc od oe gt of og oh oi aw oj bi"><span id="ae13" class="ok mn jj og b gy ol om l on oo">with open('filename.txt', 'wb') as r: <br/>    r.write(html.content)</span></pre><p id="f4c3" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">with 语句打开了所谓的上下文管理器。这很有用，因为它将关闭 open 函数，而不需要额外的代码。否则，我们将不得不请求关闭 open 函数。我们不必使用 with 语句。</p><h1 id="056d" class="mm mn jj bd mo mp mq mr ms mt mu mv mw ky mx kz my lb mz lc na le nb lf nc nd bi translated">根据请求下载大文件</h1><p id="c5d3" class="pw-post-body-paragraph lh li jj lj b lk ng kt lm ln nh kw lp lq ny ls lt lu nz lw lx ly oa ma mb mc im bi translated">我们已经讨论了使用请求包下载的基本方法。get 方法参数帮助定义我们如何从服务器请求信息。我们可以用许多方法改变请求。请参阅请求文档以了解更多详细信息。</p><p id="03a5" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们说过请求下载二进制文件的主体，除非另有说明。这可以通过定义流参数来覆盖。这在请求文档中的标题“正文内容工作流”下。见<a class="ae jg" href="https://2.python-requests.org/en/master/user/advanced/#id7" rel="noopener ugc nofollow" target="_blank">此处</a>了解详情。这是一种控制何时下载二进制文件主体的方法。</p><pre class="ob oc od oe gt of og oh oi aw oj bi"><span id="10ce" class="ok mn jj og b gy ol om l on oo">request.get(url, stream=True)</span></pre><p id="389d" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在脚本的这一点上，只有二进制文件的头被下载。现在，我们可以通过一个名为 request.iter_content 的方法来控制如何下载文件。这个方法将整个文件停止在内存(缓存)中。</p><p id="a741" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在后台，iter_content 方法迭代响应对象。然后，您可以指定 chunk_size，这是我们定义要放入内存的大小。这意味着在所有数据传输完成之前，连接不会关闭。</p><p id="15e1" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">详情见<a class="ae jg" href="https://2.python-requests.org//en/master/api/#requests.Response.iter_content" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><pre class="ob oc od oe gt of og oh oi aw oj bi"><span id="59da" class="ok mn jj og b gy ol om l on oo">r = requests.get(url, Stream=True)<br/>with open("filename.pdf",'wb') as Pypdf:<br/>    for chunk in r.iter_content(chunk_size=1024)<br/>      if chunk: <br/>         pypdf.write(ch)</span></pre><p id="cd25" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">因此，这里我们使用一个请求 get 方法来获取内容。我们使用 with 语句作为上下文管理器，并调用 r.iter_content。我们使用 for 循环并定义变量 chunk，这个 chunk 变量将包含由 chunk_size 定义的每 1024 个字节。</p><p id="c81b" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们将 chunk_size 设置为 1024 字节，如果需要，可以是任何值。</p><p id="69d7" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们在将数据块放入内存的同时写入数据块。我们使用 if 语句查找是否有块要写，如果有，我们使用 write 方法来完成。这使得我们不会用尽所有的缓存，并以零碎的方式下载较大的文件。</p><h1 id="cbc9" class="mm mn jj bd mo mp mq mr ms mt mu mv mw ky mx kz my lb mz lc na le nb lf nc nd bi translated">下载重定向的文件</h1><p id="e7ad" class="pw-post-body-paragraph lh li jj lj b lk ng kt lm ln nh kw lp lq ny ls lt lu nz lw lx ly oa ma mb mc im bi translated">有时候你想下载一个文件，但网站重定向到检索该文件。请求包可以轻松处理这个问题。</p><pre class="ob oc od oe gt of og oh oi aw oj bi"><span id="d1b0" class="ok mn jj og b gy ol om l on oo">import requests<br/>url = 'insert url'<br/>response = requests.get(url, allow_redirects=True)<br/>with open('filename.pdf') as Pypdf:<br/>    pypdf.write(response.content)</span></pre><p id="6f90" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这里我们在 get 方法中使用 allow_redirects=True 参数。我们像前面一样使用 with 语句来编写文件。</p><p id="b542" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">本文到此为止！敬请期待下一部分。我们将看看验证下载，恢复下载和编码进度条！</p><p id="726c" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在后面的文章中，我们将讨论异步技术。这些可以扩大下载更大的文件集！</p><p id="cb42" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jt">关于作者</strong></p><p id="6d2a" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我是一名医学博士，对教学、python、技术和医疗保健有浓厚的兴趣。我在英国，我教在线临床教育以及运行 www.coding-medics.com<a class="ae jg" href="http://www.coding-medics.com./" rel="noopener ugc nofollow" target="_blank">网站。</a></p><p id="5439" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">您可以通过 asmith53@ed.ac.uk 或 twitter <a class="ae jg" href="https://twitter.com/AaronSm46722627" rel="noopener ugc nofollow" target="_blank">这里</a>联系我，欢迎所有意见和建议！如果你想谈论任何项目或合作，这将是伟大的。</p><p id="74b8" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">更多技术/编码相关内容，请点击这里注册我的简讯<a class="ae jg" href="https://aaronsmith.substack.com/p/coming-soon?r=6yuie&amp;utm_campaign=post&amp;utm_medium=web&amp;utm_source=copy" rel="noopener ugc nofollow" target="_blank">。</a></p><div class="is it gp gr iu oq"><a href="https://medium.com/analytics-vidhya/everything-you-need-to-know-about-enumerate-a49a7fd0d756" rel="noopener follow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd jt gy z fp ov fr fs ow fu fw js bi translated">关于 Enumerate()您需要知道的一切</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">使用 python 的枚举函数永远改变你的循环方式</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">medium.com</p></div></div><div class="oz l"><div class="pa l pb pc pd oz pe ja oq"/></div></div></a></div></div></div>    
</body>
</html>