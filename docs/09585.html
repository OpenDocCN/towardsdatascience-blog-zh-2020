<html>
<head>
<title>An open-source solution to deploy enterprise-level R Shiny applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">部署企业级应用程序的开源解决方案</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/an-open-source-solution-to-deploy-enterprise-level-r-shiny-applications-2e19d950ff35?source=collection_archive---------9-----------------------#2020-07-08">https://towardsdatascience.com/an-open-source-solution-to-deploy-enterprise-level-r-shiny-applications-2e19d950ff35?source=collection_archive---------9-----------------------#2020-07-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7b77" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用 docker + ShinyProxy 交付您的 R 数据可视化产品</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/400bf6882d5a6146059be8375a05d185.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mpyrgqwMjfclV2oN1U2VIA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片由<a class="ae kv" href="https://unsplash.com/s/photos/luke-chesser" rel="noopener ugc nofollow" target="_blank">卢克·切瑟</a>在<a class="ae kv" href="https://unsplash.com/photos/JKUTrJ4vK00" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="79ff" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi lz translated">对于许多 R 用户来说，<span class="l ma mb mc bm md me mf mg mh di">F</span>R Shiny 已经成为构建数据科学交互式 web 应用的流行平台。它允许人们轻松地从 R 可视化数据分析，而不需要弄乱许多行代码。你可以在<a class="ae kv" href="https://shiny.rstudio.com/gallery/" rel="noopener ugc nofollow" target="_blank"> R Shiny Gallery </a>中探索一些功能强大、视觉上吸引人的应用。</p><p id="65ac" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">作为一名生物信息学科学家，我为生物学家提供最先进的高通量实验数据的数据分析和可视化解决方案。随着合作者数量的增长，我需要构建一个 R Shiny 应用程序的主机，以确保模块化、标准化和可复制的工作流。然而，如果我想扩大我的项目规模，让这个系统得到更广泛的应用，我必须面对几个问题:</p><ol class=""><li id="89fb" class="mi mj iq lf b lg lh lj lk lm mk lq ml lu mm ly mn mo mp mq bi translated">如何在远程电脑或云端流畅运行 R Shiny apps？</li><li id="340b" class="mi mj iq lf b lg mr lj ms lm mt lq mu lu mv ly mn mo mp mq bi translated">如何从单个门户部署和管理多个 R Shiny 应用？</li><li id="2e69" class="mi mj iq lf b lg mr lj ms lm mt lq mu lu mv ly mn mo mp mq bi translated">R Shiny apps 如何在主机系统中动态读写文件？</li><li id="3757" class="mi mj iq lf b lg mr lj ms lm mt lq mu lu mv ly mn mo mp mq bi translated">在 R Shiny 应用程序中，不同的用户可以访问不同的数据集吗？</li></ol><p id="4ab3" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">这些当然可以通过 RStudio 提供的<a class="ae kv" href="https://rstudio.com/products/shiny-server-pro" rel="noopener ugc nofollow" target="_blank"> Shiny Server Pro </a>来实现。然而，我搜索了在线资源，经历了试验和错误，发现<strong class="lf ir"> docker + ShinyProxy </strong>是一个很好的开源解决方案，它使我能够成功地部署一系列具有所需功能的 R Shiny 应用程序。</p><p id="7d5b" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">虽然整个过程对技术要求不高，但我还没有看到如何从头开始构建这些的分步教程。在这里，我的目的是向您展示部署两个具有特定于用户的数据访问的 example R 闪亮应用程序的旅程，并希望它能启发您的项目。</p><p id="abfc" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">📝<strong class="lf ir">注:</strong> <em class="mw">本教程介绍如何在本地计算机上部署多应用系统。但是这些步骤通常适用于远程计算机或云上的部署。当远程部署需要注意时，我会特别说明。</em></p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="7896" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">ℹ️ <em class="mw">本教程需要的所有文件都托管在我的</em> <a class="ae kv" href="https://github.com/xmc811/ShinyProxy-template" rel="noopener ugc nofollow" target="_blank"> <em class="mw"> GitHub 库</em> </a> <em class="mw">上。repo 中有五个带编号的子目录，对应于本教程中构建最终系统的五个步骤(第 02-06 节)。在我们学习教程的过程中，我还会向您展示特定文件夹或文件的链接。</em></p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="ca23" class="mx my iq bd mz na nb nc nd ne nf ng nh jw ni jx nj jz nk ka nl kc nm kd nn no bi translated">01.软件要求</h1><p id="3d5a" class="pw-post-body-paragraph ld le iq lf b lg np jr li lj nq ju ll lm nr lo lp lq ns ls lt lu nt lw lx ly ij bi translated">我们应该已经安装了 R 和 RStudio。为了构建我们的示例 R 闪亮的应用程序，我们还需要通过调用<code class="fe nu nv nw nx b">install.packages()</code>来安装<code class="fe nu nv nw nx b">shiny</code>和<code class="fe nu nv nw nx b">tidyverse</code>。</p><p id="2af6" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">接下来，我们将安装 docker。由于我用的是 macOS，所以我用<a class="ae kv" href="https://docs.docker.com/docker-for-mac/install/" rel="noopener ugc nofollow" target="_blank">这个链接</a>安装 Docker 桌面。要在其他操作系统上安装它，您可以在这里找到信息<a class="ae kv" href="https://docs.docker.com/engine/install/" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="b1f0" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><strong class="lf ir">我们为什么要用 docker？</strong></p><p id="878e" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">docker 的理念是封装软件代码及其所有依赖项，以便它可以在任何基础设施上统一和一致地运行，即容器化策略。r 闪亮的应用通常有很多包依赖。我们将首先在本地计算机上测试它的运行，然后让他们远程工作。没有 docker 的容器化，我们将不得不确保所有运行应用程序的计算机都有相同的运行环境。这意味着我们将花费大量的精力来安装和配置大量的软件和软件包。当一个包在测试计算机上更新时，它必须在所有其他计算机上更新。我们可以看到，以这种方式管理多个 R shiny 应用程序很容易变得很痛苦。有了 docker，我们可以将应用程序、它们的依赖项和运行环境打包成一个整体<strong class="lf ir">映像</strong>。图像可以复制到其他计算机上，我们可以开始运行应用程序(只要那台计算机安装了 docker)。在不被繁琐的安装和配置所干扰的情况下，这种类型的实践大大加快了软件开发和部署的工作流程。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="5476" class="mx my iq bd mz na nb nc nd ne nf ng nh jw ni jx nj jz nk ka nl kc nm kd nn no bi translated">02.构建闪亮的应用程序</h1><p id="37a4" class="pw-post-body-paragraph ld le iq lf b lg np jr li lj nq ju ll lm nr lo lp lq ns ls lt lu nt lw lx ly ij bi translated">由于这只是一个概念验证教程，我们将构建两个简单的 R Shiny 应用程序。因为一般结构和文件系统是相同的，所以它们可以很容易地扩展到更大的项目中。</p><p id="00c8" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">第一个应用程序“Hist_App”读取存储在文件中的数字向量，并绘制其分布。如图 1 所示，我们可以选择四个数据集中的一个，并调整箱的数量。（💻<a class="ae kv" href="https://github.com/xmc811/ShinyProxy-template/tree/master/02-build-shiny-apps/Hist_App" rel="noopener ugc nofollow" target="_blank"> <strong class="lf ir">源文件</strong> </a>)</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/1ce2e8b43daa1e45e77342dbcdf4c61c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3y28Ml-OA3MLBPd6CDP6-A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd nz">图一。第一个 App“Hist _ App”的界面</strong></p></figure><p id="b5b1" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">第二个应用程序“Scatter_App”读取存储在文件中的两列数据帧，并绘制两个变量的散点图。同样，我们可以选择四个数据集之一，并改变点的颜色。（💻<a class="ae kv" href="https://github.com/xmc811/ShinyProxy-template/tree/master/02-build-shiny-apps/Scatter_App" rel="noopener ugc nofollow" target="_blank"> <strong class="lf ir">源文件</strong> </a>)。在这两个应用中，数据文件都位于<code class="fe nu nv nw nx b">./data/</code>文件夹中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/4bc1cfd58a9f28bd74f7e1fc1e84d772.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4AAOPpKg7NZ6sVzRhMQLEw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd nz">图二。第二个 app“散点 _App”的界面</strong></p></figure><p id="581b" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">当我们打开<code class="fe nu nv nw nx b">app.R</code>文件时，我们可以通过在 RStudio 中单击“运行应用”来本地测试这两个应用。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="2f18" class="mx my iq bd mz na nb nc nd ne nf ng nh jw ni jx nj jz nk ka nl kc nm kd nn no bi translated">03.构建并运行 R 闪亮的应用程序 docker 映像</h1><p id="b37d" class="pw-post-body-paragraph ld le iq lf b lg np jr li lj nq ju ll lm nr lo lp lq ns ls lt lu nt lw lx ly ij bi translated">现在我们已经构建了两个 R Shiny 应用程序，但它们只能在我们的本地机器上运行。为了让它们在其他计算机上工作，我们将利用我在上面解释的 docker 容器化策略来构建 docker 映像。</p><p id="9874" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">为了构建 docker 映像，我们需要一个<strong class="lf ir">基础映像</strong>来开始。我们可以复制文件并将附加软件或软件包安装到基本映像中，以构建新映像。<a class="ae kv" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker Hub </a>是一个可以公开获得大量预建 Docker 图像的地方。有一个名为'<a class="ae kv" href="https://hub.docker.com/u/rocker" rel="noopener ugc nofollow" target="_blank"> rocker </a>'的社区知识库，定期更新常见的 R 相关 docker 图片。我们将使用的图像是<code class="fe nu nv nw nx b"><a class="ae kv" href="https://hub.docker.com/r/rocker/shiny-verse" rel="noopener ugc nofollow" target="_blank">rocker/shiny-verse</a></code>。我们在终端中使用以下命令将映像拉至本地机器:</p><pre class="kg kh ki kj gt ob nx oc od aw oe bi"><span id="7a10" class="of my iq nx b gy og oh l oi oj">docker pull rocker/shiny-verse</span></pre><p id="6471" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">正如你可能猜到的，<code class="fe nu nv nw nx b">rocker/shiny-verse</code>是一个已经安装了 R，R Shiny server，以及包括<code class="fe nu nv nw nx b">tidyverse</code>在内的几个常用包的环境。<code class="fe nu nv nw nx b">rocker/shiny-verse</code>是在其基础镜像<code class="fe nu nv nw nx b">rocker/shiny</code>上通过安装<code class="fe nu nv nw nx b">tidyverse</code> <em class="mw">等构建而成。</em>。<code class="fe nu nv nw nx b">rocker/shiny</code>又是从<code class="fe nu nv nw nx b">rocker/r-ver</code>开始构建的，是 base R 环境。现在你可以看到它是如何工作的:<strong class="lf ir">docker 镜像是一层一层构建的</strong>。当我们需要构建 docker 映像时，我们不会从头开始(例如，从基本操作系统或基本 R 开始)。我们可以从一些预煮的食物开始，然后在上面加上我们的食谱。下图试图解释这个概念。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/7a08d8d9aaad387fdb67239e63e26f5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B9peiWvsZXjlyLoLbPDsOA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd nz">图三。逐层构建 docker 图像。</strong>蓝色图层和图像显示的是已经建成的；棕色的层和图像表明那些需要被建造。</p></figure><p id="7f95" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">通常，我们需要额外的 R 包来运行我们的应用程序。因此，我们可以在<code class="fe nu nv nw nx b">rocker/shiny-verse</code>之上安装这些包来构建<code class="fe nu nv nw nx b">shiny-more</code>映像。最后，复制并配置应用程序文件以构建准备运行的<code class="fe nu nv nw nx b">shiny-app</code>映像。幸运的是，我们的两个应用不需要更多的 R 包，因此<code class="fe nu nv nw nx b">shiny-more</code>图像是不必要的。我们可以从<code class="fe nu nv nw nx b">rocker/shiny-verse</code>直接构建<code class="fe nu nv nw nx b">shiny-app</code>。</p><p id="77b1" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">📝<strong class="lf ir">注意:</strong> <em class="mw">虽然在本教程中跳过了从</em> <code class="fe nu nv nw nx b">rocker/shiny-verse</code> <em class="mw">到</em> <code class="fe nu nv nw nx b">shiny-more</code> <em class="mw">的步骤，但是我在 GitHub 中包含了构建这个中间映像所需的</em> <a class="ae kv" href="https://github.com/xmc811/ShinyProxy-template/tree/master/optional" rel="noopener ugc nofollow" target="_blank"> <em class="mw">文件</em> </a> <em class="mw">，因为您将需要它们。从技术上来说，即使需要更多的软件包，人们仍然可以直接从</em> <code class="fe nu nv nw nx b">rocker/shiny-verse</code> <em class="mw">进入</em> <code class="fe nu nv nw nx b">shiny-app</code> <em class="mw">，但这样做的话，每次更新应用程序时，都需要花费几分钟来重新安装所有的软件包。因此，最佳实践是逐层构建图像</em><strong class="lf ir"><em class="mw"/></strong><em class="mw">。</em></p><p id="e234" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我们需要两个文件来构建<code class="fe nu nv nw nx b">shiny-app</code>映像:<code class="fe nu nv nw nx b">Dockerfile</code>，构建 docker 映像总是需要用到它；<code class="fe nu nv nw nx b">shiny-server.sh</code>，它运行着 R Shiny 服务器。从<a class="ae kv" href="https://github.com/xmc811/ShinyProxy-template/tree/master/03-shiny-apps-docker" rel="noopener ugc nofollow" target="_blank"> GitHub 目录</a>中可以看到，在每个 app 的文件夹中，这两个文件都被添加在之前的文件之上。现在，在终端的<code class="fe nu nv nw nx b">./Hist_App</code>文件夹中，运行以下命令:</p><pre class="kg kh ki kj gt ob nx oc od aw oe bi"><span id="c1ed" class="of my iq nx b gy og oh l oi oj">docker build . -t shiny-hist</span></pre><p id="9239" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">这将从<code class="fe nu nv nw nx b">rocker/shiny-verse</code>开始构建<code class="fe nu nv nw nx b">shiny-hist</code>图像。基本图像在<code class="fe nu nv nw nx b">Dockerfile</code> : <code class="fe nu nv nw nx b">FROM rocker/shiny-verse:latest</code>的第一行指定。剩下的几行只是要求 docker 进行复制/安装/配置的命令。在终端中，运行<code class="fe nu nv nw nx b">docker images</code>。现在我们应该看到<code class="fe nu nv nw nx b">rocker/shiny-verse</code>和<code class="fe nu nv nw nx b">shiny-hist</code>都在那里。然后，运行:</p><pre class="kg kh ki kj gt ob nx oc od aw oe bi"><span id="1eaa" class="of my iq nx b gy og oh l oi oj">docker run --rm -p 3838:3838 shiny-hist</span></pre><p id="013e" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">这将在端口 3838 的计算机上启动我们的直方图应用程序。打开网络浏览器，并转至<code class="fe nu nv nw nx b">localhost:3838</code>。我们将有一个闪亮的应用程序在 docker 中运行！</p><p id="31fd" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">运行散点图 app 的步骤是一样的:在<code class="fe nu nv nw nx b">./Scatter_App</code>文件夹内，运行<code class="fe nu nv nw nx b">docker build . -t shiny-scatter</code>(记得更改图像标签)，运行<code class="fe nu nv nw nx b">docker run —-rm -p 3838:3838 shiny-scatter</code>。散点图应用程序将通过端口 3838 访问。</p><p id="0bfc" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">现在，我们可以在本地计算机上运行 R 闪亮的应用程序 docker 映像。但是如何让它们在远程机器上运行呢？您可能会注意到<code class="fe nu nv nw nx b">rocker/shiny-verse</code>有一个<code class="fe nu nv nw nx b">rocker/</code>部件。这是 Docker Hub 上的存储库名称。我们构建的<code class="fe nu nv nw nx b">shiny-hist</code>和<code class="fe nu nv nw nx b">shiny-scatter</code>只是本地映像，并没有被推送到 Docker Hub。要进行推送，请注册 Docker Hub 帐户，并通过 Docker 桌面或终端登录:</p><pre class="kg kh ki kj gt ob nx oc od aw oe bi"><span id="fe2b" class="of my iq nx b gy og oh l oi oj">docker login -u "username" docker.io</span></pre><p id="fef3" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">用存储库名称重新标记应用程序后，我们可以将 docker 映像推送到网上:</p><pre class="kg kh ki kj gt ob nx oc od aw oe bi"><span id="a631" class="of my iq nx b gy og oh l oi oj">docker tag shiny-hist username/shiny-hist     <br/>docker tag shiny-scatter username/shiny-scatter</span><span id="cdef" class="of my iq nx b gy ol oh l oi oj">docker push username/shiny-hist<br/>docker push username/shiny-scatter</span></pre><p id="74cb" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">在其他安装了 docker 的电脑上，我们只需将图像拖到本地并运行应用程序。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="18ad" class="mx my iq bd mz na nb nc nd ne nf ng nh jw ni jx nj jz nk ka nl kc nm kd nn no bi translated">04.使用 ShinyProxy 部署多个 R Shiny 应用</h1><p id="760c" class="pw-post-body-paragraph ld le iq lf b lg np jr li lj nq ju ll lm nr lo lp lq ns ls lt lu nt lw lx ly ij bi translated">我们已经构建了两个 R Shiny 应用程序，可以利用 docker 轻松地将它们部署在不同的计算机上。下一个挑战是:我们如何从单个门户访问和管理多个应用程序，并为不同的用户添加身份验证。这时<a class="ae kv" href="https://www.shinyproxy.io/" rel="noopener ugc nofollow" target="_blank"> ShinyProxy </a>开始发挥作用。ShinyProxy 是一个开源解决方案，专门开发来结合 R Shiny 和 docker，并提供额外的多应用功能，包括用户认证(甚至 LDAP 认证)。这允许多个用户在企业环境中部署和使用一系列 R Shiny 应用程序。</p><p id="ad1e" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">假设我们想从一个网页访问我们构建的两个应用程序，并且只允许两个用户登录:Alice 和 Bob。为了实现这一点，我们需要在<strong class="lf ir">同一个文件夹</strong>中有三个新文件。两个文件<code class="fe nu nv nw nx b">Dockerfile</code>和<code class="fe nu nv nw nx b">application.yaml</code>在<a class="ae kv" href="https://github.com/xmc811/ShinyProxy-template/tree/master/04-shinyproxy" rel="noopener ugc nofollow" target="_blank"> GitHub </a>目录下。我们还应该从 ShinyProxy <a class="ae kv" href="https://www.shinyproxy.io/downloads/" rel="noopener ugc nofollow" target="_blank">下载页面</a>下载<code class="fe nu nv nw nx b">shinyproxy-2.3.1.jar</code>文件，因为它很大。</p><p id="3d51" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">在构建 ShinyProxy 映像和运行应用程序之前，我们应该看一下<code class="fe nu nv nw nx b">application.yaml</code>文件，了解它是如何配置运行的。线条<code class="fe nu nv nw nx b">authentication: simple</code>表示我们可以直接在<code class="fe nu nv nw nx b">user</code>部分设置用户名和密码。这里，设置了两个用户(“Alice”和“Bob”)及其密码。R 亮闪闪的 docker 映像在<code class="fe nu nv nw nx b">specs</code>部分配置:我们可以设置 ID、显示名称和应用程序的描述，最重要的是，<code class="fe nu nv nw nx b">container-image</code>应该是<code class="fe nu nv nw nx b">shiny-hist</code>或<code class="fe nu nv nw nx b">shiny-scatter</code>，这样 ShinyProxy 就知道运行正确的映像。</p><p id="4fb6" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">另一个新概念是 docker 网络。这使得 docker 通过连接多个容器变得更加强大。我们可以在<code class="fe nu nv nw nx b">application.yaml</code>中看到<code class="fe nu nv nw nx b">docker: internal-networking: true</code>和每个图像都有<code class="fe nu nv nw nx b">container-network: sp-test-net</code>。它使这两个应用程序在一个 docker 网络中运行，并由 ShinyProxy 管理。而且，ShinyProxy 本身可以作为容器运行。本节旨在建立一个包含<code class="fe nu nv nw nx b">shiny-hist</code>、<code class="fe nu nv nw nx b">shiny-scatter</code>和 ShinyProxy 的整体形象。同样，<strong class="lf ir">任何东西都可以打包并作为容器运行！</strong>下图展示了 ShinyProxy 的设计:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/2df8c52c5a2fd69426f250e9f295859f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8yP6I0-zWESm9aaroXjp2g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd nz">图 4。ShinyProxy 设计</strong></p></figure><p id="f525" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">因此，在构建 ShinyProxy 映像之前，我们需要首先构建 docker 网络:</p><pre class="kg kh ki kj gt ob nx oc od aw oe bi"><span id="dc1e" class="of my iq nx b gy og oh l oi oj">docker network create sp-test-net</span></pre><p id="af39" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">📝<strong class="lf ir">注意:</strong> <em class="mw">如果您尝试在远程服务器上构建 docker 网络，尤其是使用 VPN 时，您可能需要指定 IP 子网掩码以避免 IP 地址冲突。我用的命令是</em> <code class="fe nu nv nw nx b">docker network create --driver=bridge --subnet 172.17.253.9/30 sp-test-net</code> <em class="mw">。详细解释请见</em> <a class="ae kv" href="https://stackoverflow.com/questions/50514275/docker-bridge-conflicts-with-host-network" rel="noopener ugc nofollow" target="_blank"> <em class="mw">此链接</em> </a> <em class="mw">。</em></p><p id="e5b9" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">网络名称应该与我们在<code class="fe nu nv nw nx b">application.yaml</code>中指定的名称相同。接下来，我们构建 ShinyProxy 映像来连接多个 R Shiny 应用程序(该命令应该在带有<code class="fe nu nv nw nx b">application.yaml</code>、<code class="fe nu nv nw nx b">shinyproxy-2.3.1.jar</code>和<code class="fe nu nv nw nx b">Dockerfile</code>的目录中运行):</p><pre class="kg kh ki kj gt ob nx oc od aw oe bi"><span id="86be" class="of my iq nx b gy og oh l oi oj">docker build . -t shinyproxy-run</span></pre><p id="82fa" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">最后，我们运行<code class="fe nu nv nw nx b">shinyproxy-run</code>并在 web 浏览器上转到<code class="fe nu nv nw nx b">localhost:8080</code>来查看结果:</p><pre class="kg kh ki kj gt ob nx oc od aw oe bi"><span id="90ab" class="of my iq nx b gy og oh l oi oj">docker run --rm -v /var/run/docker.sock:/var/run/docker.sock --net sp-test-net -p 8080:8080 shinyproxy-run</span></pre><p id="fcf5" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我们应该会看到一个登录页面。通过使用“Alice”或“Bob”和密码登录，我们将被定向到带有两个可用应用程序的门户页面。</p><p id="21e8" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">📝<strong class="lf ir">注意:</strong><em class="mw"/><code class="fe nu nv nw nx b">application.yaml</code><em class="mw">文件中有很多选项可以配置，发挥 ShinyProxy 的全部潜力。详细文档可以在</em> <a class="ae kv" href="https://www.shinyproxy.io/configuration/" rel="noopener ugc nofollow" target="_blank"> <em class="mw">本页</em> </a> <em class="mw">找到。</em></p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="7cf1" class="mx my iq bd mz na nb nc nd ne nf ng nh jw ni jx nj jz nk ka nl kc nm kd nn no bi translated">05.通过 docker 卷进行动态数据访问</h1><p id="a0c8" class="pw-post-body-paragraph ld le iq lf b lg np jr li lj nq ju ll lm nr lo lp lq ns ls lt lu nt lw lx ly ij bi translated">完成前面的步骤后，我们现在可以从一个门户部署和管理多个 R Shiny 应用程序。但我们的多应用系统还有一个缺陷:目前，所有数据集都存储在每个应用的<code class="fe nu nv nw nx b">./data</code>文件夹中。这给动态数据访问带来了困难。如果 R Shiny 应用程序使用的数据集被更新，我们必须重新构建相应的应用程序 docker 映像，以使用户可以访问新数据。当更新频繁时，让用户看到即时的数据变化变得不可行。此外，我们可能还希望应用程序在主机系统中生成文件，如果 docker 容器只能操纵自己，这是不可能的。幸运的是，docker 可以使用<a class="ae kv" href="https://docs.docker.com/storage/volumes/" rel="noopener ugc nofollow" target="_blank"> <strong class="lf ir">卷</strong> </a> <strong class="lf ir"> </strong>在主机中创建一个“docker 区域”并将其挂载到容器中，因此容器可以访问和操作主机系统中的文件。</p><p id="670b" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">为了探索这个特性，我们应该首先将数据文件移出 app 文件夹。上一节的树形结构如下:</p><pre class="kg kh ki kj gt ob nx oc od aw oe bi"><span id="60f9" class="of my iq nx b gy og oh l oi oj">04-shinyproxy/<br/>├── Dockerfile<br/>├── Hist_App<br/>│   ├── Dockerfile<br/>│   ├── Hist_App.Rproj<br/>│   ├── app.R<br/>│   ├── data<br/>│   │   ├── alice_vector_1.txt<br/>│   │   ├── alice_vector_2.txt<br/>│   │   ├── bob_vector_1.txt<br/>│   │   └── bob_vector_2.txt<br/>│   └── shiny-server.sh<br/>├── Scatter_App<br/>│   ├── Dockerfile<br/>│   ├── Scatter_App.Rproj<br/>│   ├── app.R<br/>│   ├── data<br/>│   │   ├── alice_df_1.txt<br/>│   │   ├── alice_df_2.txt<br/>│   │   ├── bob_df_1.txt<br/>│   │   └── bob_df_2.txt<br/>│   └── shiny-server.sh<br/>├── application.yml<br/>└── shinyproxy-2.3.1.jar</span></pre><p id="a454" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">让我们重新组织结构，在应用程序文件夹之外创建一个目录，用于存储两个应用程序使用的数据文件:</p><pre class="kg kh ki kj gt ob nx oc od aw oe bi"><span id="5b4c" class="of my iq nx b gy og oh l oi oj">05-data-on-host/<br/>├── Data<br/>│   ├── DF<br/>│   │   ├── alice_df_1.txt<br/>│   │   ├── alice_df_2.txt<br/>│   │   ├── bob_df_1.txt<br/>│   │   └── bob_df_2.txt<br/>│   └── Vector<br/>│       ├── alice_vector_1.txt<br/>│       ├── alice_vector_2.txt<br/>│       ├── bob_vector_1.txt<br/>│       └── bob_vector_2.txt<br/>├── Dockerfile<br/>├── Hist_App<br/>│   ├── Dockerfile<br/>│   ├── Hist_App.Rproj<br/>│   ├── app.R<br/>│   └── shiny-server.sh<br/>├── Scatter_App<br/>│   ├── Dockerfile<br/>│   ├── Scatter_App.Rproj<br/>│   ├── app.R<br/>│   └── shiny-server.sh<br/>├── application.yml<br/>└── shinyproxy-2.3.1.jar</span></pre><p id="cf96" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">现在，如果我们尝试运行直方图应用程序的<code class="fe nu nv nw nx b">./Hist_App</code>文件夹中的<code class="fe nu nv nw nx b">docker build</code>，将会出现错误，因为<code class="fe nu nv nw nx b">./Hist_App/data</code>文件夹不再存在。相反，我们应该对<code class="fe nu nv nw nx b">Dockerfile</code>和<code class="fe nu nv nw nx b">app.R</code>进行修改(<a class="ae kv" href="https://github.com/xmc811/ShinyProxy-template/commit/19965c5f93584d18d33df61c6cbae6f8ff32ede6" rel="noopener ugc nofollow" target="_blank">见此处</a>的具体修改)。</p><p id="0848" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我们首先删除了<code class="fe nu nv nw nx b">Dockerfile</code>中的行<code class="fe nu nv nw nx b">COPY data /srv/shiny-server/data</code>，然后将<code class="fe nu nv nw nx b">app.R</code>中的<code class="fe nu nv nw nx b">./data/</code>改为<code class="fe nu nv nw nx b">/Data/Vector/</code>，以告知应用程序数据文件现在存储在不同的位置。用不同的标签重建 docker 映像后:</p><pre class="kg kh ki kj gt ob nx oc od aw oe bi"><span id="408a" class="of my iq nx b gy og oh l oi oj"># within ./Hist_App folder<br/>docker build . -t shiny-hist-data</span></pre><p id="7181" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我们运行以下命令:</p><pre class="kg kh ki kj gt ob nx oc od aw oe bi"><span id="62a0" class="of my iq nx b gy og oh l oi oj">docker run --rm -v /Users/mingchuxu/Documents/projects/ShinyProxy-template/05-data-on-host/Data/:/Data  -p 3838:3838 shiny-hist-data</span><span id="8e53" class="of my iq nx b gy ol oh l oi oj">## Note: The absolute path to /Data in your computer is different, please change it accordingly.</span></pre><p id="af73" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我们可以看到直方图应用在<code class="fe nu nv nw nx b">localhost:3838</code>上成功运行。app 如何知道数据文件的正确位置？窍门来自上面命令中的<code class="fe nu nv nw nx b">-v</code>选项。该选项告诉 docker，我们希望将主机目录<code class="fe nu nv nw nx b">/Users/mingchuxu/Documents/projects/ShinyProxy-template/05-data-on-hist/Data</code>挂载为容器中的<code class="fe nu nv nw nx b">/Data</code>(该选项接受<code class="fe nu nv nw nx b">&lt;host-dir&gt;:&lt;container-dir&gt;</code>格式)。这就是为什么当我们在<code class="fe nu nv nw nx b">app.R</code>中指定<code class="fe nu nv nw nx b">/Data/Vector/</code>时，直方图 app 知道去主机系统中的<code class="fe nu nv nw nx b">/Users/mingchuxu/Documents/projects/ShinyProxy-template/05-data-on-hist/Data/Vector</code>中找数据文件。</p><p id="4caf" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我们可以在散点图文件夹中进行相同的更改(<a class="ae kv" href="https://github.com/xmc811/ShinyProxy-template/commit/1acf7318eca674fb45bc14544bb71035b14942f2" rel="noopener ugc nofollow" target="_blank">参见这里的确切更改</a>)，构建一个新的 docker 映像，并在挂载主机目录的情况下运行它。散点图应用程序也应该在<code class="fe nu nv nw nx b">localhost:3838</code>运行:</p><pre class="kg kh ki kj gt ob nx oc od aw oe bi"><span id="59df" class="of my iq nx b gy og oh l oi oj"># within ./Scatter_App folder<br/>docker build . -t shiny-scatter-data</span><span id="2aee" class="of my iq nx b gy ol oh l oi oj">docker run --rm -v /Users/mingchuxu/Documents/projects/ShinyProxy-template/05-data-on-host/Data/:/Data  -p 3838:3838 shiny-scatter-data</span><span id="6a8b" class="of my iq nx b gy ol oh l oi oj">## Note: The absolute path to /Data in your computer is different, please change it accordingly.</span></pre><p id="9c65" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">下一步是将 docker 音量功能与 ShinyProxy 结合起来。在<code class="fe nu nv nw nx b">application.yaml</code>中，选项<code class="fe nu nv nw nx b">container-volumes</code>等同于<code class="fe nu nv nw nx b">docker run</code>中的<code class="fe nu nv nw nx b">-v</code>选项，允许我们进行相应的配置。让我们修改<code class="fe nu nv nw nx b">application.yaml</code>文件(<a class="ae kv" href="https://github.com/xmc811/ShinyProxy-template/commit/51237c0c9f8095218d12f6db925b4cd58ba27509" rel="noopener ugc nofollow" target="_blank">查看这里的确切变化</a>)，然后构建并运行一个新的 ShinyProxy 映像:</p><pre class="kg kh ki kj gt ob nx oc od aw oe bi"><span id="d3bc" class="of my iq nx b gy og oh l oi oj">docker build . -t shinyproxy-run-data</span><span id="576e" class="of my iq nx b gy ol oh l oi oj">docker run --rm -v /var/run/docker.sock:/var/run/docker.sock --net sp-test-net -p 8080:8080 shinyproxy-run-data</span></pre><p id="67e0" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">现在从<code class="fe nu nv nw nx b">localhost:8080</code>开始，我们可以运行多个 R 闪亮的应用程序，从我们的主机读取数据。下图说明了与图 4 相比改进的设计。我们可以自由地将<code class="fe nu nv nw nx b">./Data</code>文件夹移动到我们计算机上的任何地方。只要记住每次我们改变绝对路径并重建 ShinyProxy 映像时，都要修改<code class="fe nu nv nw nx b">application.yaml</code>中的<code class="fe nu nv nw nx b">container-volumes</code>选项。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi on"><img src="../Images/a685892ef24360f1445a00c57472bd7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zGTgkFt4_rcqfWzLp5q03g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd nz">图 5。带有 docker volumes 的改进 ShinyProxy 设计</strong></p></figure></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="1488" class="mx my iq bd mz na nb nc nd ne nf ng nh jw ni jx nj jz nk ka nl kc nm kd nn no bi translated">06.配置用户特定的数据访问</h1><p id="f435" class="pw-post-body-paragraph ld le iq lf b lg np jr li lj nq ju ll lm nr lo lp lq ns ls lt lu nt lw lx ly ij bi translated">完成了前面的步骤，我们现在面临最后一个问题:如何让 Alice 和 Bob 访问特定于用户的数据？这可以通过利用在 ShinyProxy 登录时创建的环境变量来解决:<code class="fe nu nv nw nx b">SHINYPROXY_USERNAME</code>。</p><p id="4288" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">首先，让我们在<code class="fe nu nv nw nx b">Data/</code>文件夹的层次结构中再增加一层。如下树形结构所示，<code class="fe nu nv nw nx b">alice*txt</code>放入<code class="fe nu nv nw nx b">Alice/</code>,<code class="fe nu nv nw nx b">bob*txt</code>放入<code class="fe nu nv nw nx b">Bob/</code>。这使得 R Shiny 应用可以基于不同的 ShinyProxy 登录用户名访问不同的文件夹。</p><pre class="kg kh ki kj gt ob nx oc od aw oe bi"><span id="e36d" class="of my iq nx b gy og oh l oi oj">Data<br/>├── DF<br/>│   ├── Alice<br/>│   │   ├── alice_df_1.txt<br/>│   │   └── alice_df_2.txt<br/>│   └── Bob<br/>│       ├── bob_df_1.txt<br/>│       └── bob_df_2.txt<br/>└── Vector<br/>    ├── Alice<br/>    │   ├── alice_vector_1.txt<br/>    │   └── alice_vector_2.txt<br/>    └── Bob<br/>        ├── bob_vector_1.txt<br/>        └── bob_vector_2.txt</span></pre><p id="ffd6" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">接下来要做一系列的修改。请参见此<a class="ae kv" href="https://github.com/xmc811/ShinyProxy-template/commit/fb892a84b042682c4ab72517e8676200519c3e07" rel="noopener ugc nofollow" target="_blank"> GitHub 提交</a>了解所有需要的更改。具体来说，在每个 app 的<code class="fe nu nv nw nx b">app.R</code>文件中，我们需要添加<code class="fe nu nv nw nx b">username &lt;- Sys.getenv("SHINYPROXY_USERNAME")</code>来获取登录用户名，在<code class="fe nu nv nw nx b">ui</code>和<code class="fe nu nv nw nx b">server</code>中都通过<code class="fe nu nv nw nx b">paste0()</code>来修改目录路径；在每个 app 的<code class="fe nu nv nw nx b">shiny-server.sh</code>文件中，我们应该添加以下两行，将环境变量传递到 R Shiny app 中(<a class="ae kv" href="https://stackoverflow.com/questions/39084284/how-to-pass-environment-variables-to-shinyapps" rel="noopener ugc nofollow" target="_blank">在此详细解释</a>):</p><pre class="kg kh ki kj gt ob nx oc od aw oe bi"><span id="d493" class="of my iq nx b gy og oh l oi oj">env &gt; /home/shiny/.Renviron<br/>chown shiny.shiny /home/shiny/.Renviron</span></pre><p id="952d" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">然后，就像在第 5 节中一样，我们将为每个应用程序构建新的 docker 映像。同样，我们使用新的 docker 图像标签来区分它们和前面章节中构建的图像。</p><pre class="kg kh ki kj gt ob nx oc od aw oe bi"><span id="082a" class="of my iq nx b gy og oh l oi oj"># within ./Hist_App folder<br/>docker build . -t shiny-hist-user</span><span id="ea05" class="of my iq nx b gy ol oh l oi oj"># within ./Scatter_App folder<br/>docker build . -t shiny-scatter-user</span></pre><p id="2760" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">在构建最终的 ShinyProxy 映像之前，我们还需要修改<code class="fe nu nv nw nx b">applicaiton.yaml</code>，因为 docker 映像和卷都已经发生了变化(<a class="ae kv" href="https://github.com/xmc811/ShinyProxy-template/commit/fb892a84b042682c4ab72517e8676200519c3e07" rel="noopener ugc nofollow" target="_blank">参见这里的确切变化</a>)。</p><p id="47f2" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">最后，使用以下命令:</p><pre class="kg kh ki kj gt ob nx oc od aw oe bi"><span id="be31" class="of my iq nx b gy og oh l oi oj">docker build . -t shinyproxy-run-user       <br/># Note the tag name change</span><span id="9c30" class="of my iq nx b gy ol oh l oi oj">docker run --rm -v /var/run/docker.sock:/var/run/docker.sock --net sp-test-net -p 8080:8080 shinyproxy-run-user</span></pre><p id="1769" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我们可以检查<code class="fe nu nv nw nx b">localhost:8080</code>并看到 Bob 现在只能访问<code class="fe nu nv nw nx b">Bob/</code>文件夹中的文件。最后，我们构建了一个简单的 R Shiny app 系列原型，允许用户认证和特定于用户的数据访问！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/c5117c123cf7e8c4972ed9c36f4c313e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*erQ2Y32NY3Dilmm_NMqwrQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd nz">图 6。ShinyProxy </strong>针对用户的数据访问</p></figure></div></div>    
</body>
</html>