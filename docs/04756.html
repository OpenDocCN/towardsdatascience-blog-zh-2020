<html>
<head>
<title>Program like it’s 1970!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">像 1970 年一样编程！</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/program-like-its-1970-6708df2ed101?source=collection_archive---------49-----------------------#2020-04-26">https://towardsdatascience.com/program-like-its-1970-6708df2ed101?source=collection_archive---------49-----------------------#2020-04-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2970" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">有点回到人工智能过去的样子</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/beafd1e770ba35fcf706d4e3d7c040a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5XhthR0VtFoV1igq"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">洛伦佐·埃雷拉在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="ebd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">机器学习现在风靡一时！CNN、GANs 和 LSTMs 是所有酷孩子现在都在做的事情。很多人忘记了人工智能！= Machnine learning，在 2010 年深度学习热潮之前，人工智能已经存在了很长时间。我想带你回去，用一个简单的例子来说明过去的人工智能方法。</p><h1 id="6018" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">地图着色</h1><p id="3b79" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">“地图着色”是制图学中一个著名的玩具问题，我们希望以两个相邻国家总是有不同颜色的方式给地图着色(图 1)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/939620d38653836d38946e915046f709.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ThDtZ0XPN_ERWhOEN90ofg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 1:解决地图着色问题</p></figure><p id="224f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了便于说明，我们将在下面的部分中尝试给澳大利亚的州着色(因为只有八个州)。</p><p id="f1f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有趣的是，在很长一段时间里，人们“知道”解决这个问题至少需要四种颜色。但是直到 90 年代末，还没有一个关于 T4 的数学证明。</p><h1 id="e409" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">约束满足问题</h1><p id="6fd7" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">地图着色问题属于一类特殊的问题，简称为“约束满足问题”。这些类型的问题由三个不同的部分组成:</p><ol class=""><li id="dcc9" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated">变量:我们要查找其值的占位符。在我们的案例中，这些是澳大利亚的州和地区:新南威尔士州、昆士兰州、维多利亚州、西澳大利亚州、南澳大利亚州、北部地区、澳大利亚首都直辖区和塔斯马尼亚州</li><li id="8f14" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">域:这些是变量的可能值。在这种情况下，所有变量的定义域都是相同的。每种状态都可以用红、绿、蓝、黄四种颜色中的一种来着色。</li><li id="0c75" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">约束:变量不能违反这些约束。例如，维多利亚和新南威尔士的颜色必须不同，因为这是两个相邻的州。</li></ol><p id="0aac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一般来说，解决 CSP 有两种不同的策略:</p><ol class=""><li id="1ec1" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated">推理</li><li id="af72" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">搜索</li></ol><p id="2789" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">重要的是，CSP 通常只能通过推理部分解决，因此需要搜索。简而言之，如果我们不需要进行某种随机猜测来寻找答案，那么 CSP 就是完全可以通过推理来求解的。一个典型的例子是数独游戏。我们有自己的变量(空字段)、域(1 到 9 之间的数字)和几个不能违反的约束(在一行、一列或一个正方形中不能有相同的数字)。在这里，我们不必随机选择一些数字，但我们可以通过以正确的顺序应用约束来解决整个难题。不幸的是，对于我们的地图着色问题，我们没有那么幸运:为了找到一个合适的解决方案，我们不可避免地要做一些猜测。</p><h1 id="af12" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">通常的方法:回溯</h1><p id="f118" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">解决类似 CSP 的常见方法是使用回溯算法。这是用 Python 实现的算法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">回溯算法</p></figure><p id="e4ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在将逐行检查代码，以确保我们理解这里发生了什么:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="5125" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上所述，我们的 CSP 由变量、域值和约束组成。重要的是要注意，如果可能的话，约束通常被转换成二元约束，以使事情变得更容易。二元约束描述了两个变量之间的关系。在我们的 Python 实现中，它们的形式是[('NSW '，' V ')，(' NSW '，' Q ')，(' NSW '，' SA ')，…，(' T '，' V')]。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="4c7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们有和变量一样多的赋值，那就意味着我们已经给每个变量赋值了，从而解决了问题！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="1058" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在必须选择一个仍然未赋值的变量，我们现在想找到它的值。如何选择这个值将在下面进一步讨论。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="c1a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在选择了一个未赋值的变量后，我们还必须选择一个顺序来测试这个变量的值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="763f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们为变量选择的值与我们的二元约束一致，我们就把它添加到我们所有赋值的列表中。现在真正酷的部分是:我们再次调用回溯函数，所以这是一个递归函数。我们找到了一个变量的有效赋值，所以现在是时候为下一个变量找到一个值了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="6032" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可能发生的情况是，递归调用的结果是‘None’。这意味着我们赋给变量的值在这个时候是局部一致的，但是不可能用这个值找到一个整体一致的解。所以我们把这个值从赋值列表中去掉了。如果我们不能找到一个单一的一致的解决方案，我们返回 None 给上面的递归函数。如果所有的递归调用都没有返回 None，这意味着问题是不可解决的。</p><p id="8823" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哦，这个理论说够了。让我们看看这个算法如何执行，如果我们让它运行在我们的地图着色问题:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/2773860172d1a6cc60d42eda80d3bdd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*rOz-N2Av9B3NMrxkhGZ_8A.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 2:天真的回溯</p></figure><p id="8b04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嗯…我们的算法似乎没有任何进展。剧透:它最终会找到一个解决方案，但这需要很长时间，这在上面的 gif 中没有显示。这是为什么呢？因为我们仍然没有回答上面的一个重要问题:我们如何选择下一个变量来赋值？在上图中，算法只是随机选择一个未赋值的值。显然这不是最好的方法。要选择一个变量，我们应该选择一个更好的启发式。我们实现了<strong class="lb iu">最小剩余值</strong>试探法或者<strong class="lb iu"> MRV </strong>试探法。这一点是不言自明的:我们选择的下一个变量总是剩下最少有效值的变量。这在直觉上也是有道理的。例如，如果我们只能将新南威尔士州涂成红色，但我们仍然可以将西澳大利亚州涂成红、绿和蓝色，那么我们应该首先将新南威尔士州涂成红色，因为如果我们将另一个州涂成红色，可能就不会再有任何有效的颜色留给新南威尔士州了。所以让我们用这个启发法再试一次:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/9d04953be99180329a8b6963285adb62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*BptklX3PjqQHZxIaxLoV7g.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 3:MRV 的原路返回</p></figure><p id="8812" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哇，这个好用多了！</p><p id="f8d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">比较随机选择和 MRV 启发式(图 3 ),我们可以看到后者通常更省时。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/5c4100ea2c858b6ea8d8c0dfbe9dc445.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*InJHdoCqXpNPnk3s5BqkiQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 4: MRV(左)与随机(右)选择下一个变量</p></figure><p id="3faa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是说实话，给澳大利亚涂色并不有趣，因为澳大利亚只有 8 块领土。所以，为了好玩，让我们试着给德国涂上颜色，这个国家有两倍多的州:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/c6263562efee0df8abf32d517ee4771d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*4PW6CssSuHhAvc7ungMDyQ.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 5:给德国上色</p></figure><p id="c3e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个也很管用！</p><h1 id="f689" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">捷径:序言</h1><p id="71fc" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">因此，到目前为止，整个过程都相当繁琐:我们需要编写所有这些回溯代码(递归函数有时会很棘手！)甚至想出一个好的启发式。没有更好的解决办法吗？介绍:序言。</p><p id="1aae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很可能，作为一个普通的程序员(就像我一样)，你已经接触过相当多的编程语言:Java、Python、C、C#、JavaScript 等等。它们可能完全不同，但它们都属于同一类编程语言:命令式编程。然而，Prolog 属于声明性编程语言，或者更确切地说，属于逻辑编程语言。那么有什么区别呢？在“普通”编程语言中，你指定<strong class="lb iu">事情应该如何</strong>完成。在 Prolog 中，你指定<strong class="lb iu">应该做什么</strong>。看看下面的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">简单的序言示例</p></figure><p id="5ef9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Prolog 中最重要的两个构造是<strong class="lb iu">事实</strong>和<strong class="lb iu">规则</strong>。在节目的开始，我们陈述了一些事实，例如，亨利是男性，玛丽是迈克尔的父母。再往下我们有一些规则。例如，我们声明，如果 Y 是男性，Y 是 X 的父，重要的是:所有变量都必须以大写字母开头。小写名称是固定的常数。</p><p id="bcab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们进入 Prolog 控制台时，我们可以问我们的 Prolog 程序一些问题。我们可以找出迈克尔的母亲是谁:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="3027" class="nq lw it nm b gy nr ns l nt nu">?- mother(michael, X).<br/>X = mary.</span></pre><p id="44dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者谁是迈克尔的祖父:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="39f7" class="nq lw it nm b gy nr ns l nt nu">?- grandfather(michael, X).<br/>X = henry ;</span></pre><p id="ba77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们写一个程序给澳大利亚上色:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="404b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这真是直截了当！首先，我们定义哪些状态应该用不同的颜色。Diffx 只是一个帮助函数，它帮助我们定义如果颜色 A 不同于 B，那么 B 也不同于 A。最后，我们只是声明所有的颜色都彼此不同(显然)。就是这样！15 行代码，我们只需要陈述规则和事实，不需要算法。</p><p id="5efb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们加载这个程序，要求变量赋值:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="68e1" class="nq lw it nm b gy nr ns l nt nu">?- map_coloring(WA, NT, SA, NSW, V, Q, T, ACT).<br/>WA = NSW, NSW = T, T = blue,<br/>NT = V, V = ACT, ACT = red,<br/>SA = green,<br/>Q = yellow</span></pre><p id="ec99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将这些值放入地图如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/7f62f3f68610f5acbd5689b467fe8b5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4E1d2fUzpuHSMLMJg8WiNg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 6:由 Prolog 程序确定的颜色</p></figure><p id="7d45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">的确，我们得到了一个有效的解！</p><h1 id="fe1c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="3bdc" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">当我通常处理人工智能时，它必须用神经网络做一些事情，所以对我来说，看看几十年前人们对“人工智能”这个术语的理解是非常有趣的。尤其是用 Prolog 编程对我来说非常独特。解决 CSP 和类似的问题显然是非常容易的。我对这种语言的主要问题是，我从来不知道到底发生了什么。我只是陈述一些事实和规则，但从不明确告诉程序该做什么。因此，如果任务失败，跟踪错误和调试问题几乎是不可能的。</p></div></div>    
</body>
</html>