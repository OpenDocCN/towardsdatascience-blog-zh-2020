<html>
<head>
<title>Computing Node Embedding with a Graph Database: Neo4j &amp; its Graph Data Science Library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用图形数据库嵌入计算节点:Neo4j 及其图形数据科学库</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/computing-node-embedding-with-a-graph-database-neo4j-its-graph-data-science-library-d45db83e54b6?source=collection_archive---------24-----------------------#2020-07-12">https://towardsdatascience.com/computing-node-embedding-with-a-graph-database-neo4j-its-graph-data-science-library-d45db83e54b6?source=collection_archive---------24-----------------------#2020-07-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1f2c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><em class="kf">借助 pygds，使用新版 Neo4j 图形数据科学插件计算节点嵌入并将其提取到熊猫数据帧中。</em></h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/7dfbfd515892e5753d4f5fe1e7b59967.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SoaWoM5IzH-Z7pWiaWnaDw.png"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">图片作者<a class="ae kw" href="https://pixabay.com/fr/users/geralt-9301/" rel="noopener ugc nofollow" target="_blank">格尔德·奥特曼</a></p></figure><p id="e839" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">现在的机器学习都是关于向量的。执行分类任务要求将数据排列成行(观测值)，每行包含相同数量的要素(列)。虽然这很容易从最初存储在 Excel 表或 SQL 或 noSQL 数据库中的数据中获得，但当问题涉及复杂对象(如文本、图像或图形)时，转换就远不明显。</p><p id="04d3" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">为了将这些对象表示为向量，使用了嵌入技术。嵌入算法将一个给定“小”尺寸的向量分配给这些复杂对象中的每一个，否则这些复杂对象将需要数千个(至少)特征。嵌入的挑战是保留您试图建模的对象的一些特征，同时减少特征的数量。例如，单词嵌入将尝试并捕获单词<em class="lt">的含义，</em>使得语义上彼此接近的单词具有相似的向量表示。</p><h1 id="5cc8" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">图形嵌入</h1><p id="1730" class="pw-post-body-paragraph kx ky iq kz b la mm jr lc ld mn ju lf lg mo li lj lk mp lm ln lo mq lq lr ls ij bi translated">根据要表示的对象，图嵌入涵盖了几种技术。最常见的是节点嵌入，其中要表示为向量的实体是节点，但我们也可以找到边嵌入或整图嵌入。本文将重点讨论前一个问题，节点嵌入。</p><h1 id="0cc3" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">图形数据库和 Neo4j</h1><p id="13da" class="pw-post-body-paragraph kx ky iq kz b la mm jr lc ld mn ju lf lg mo li lj lk mp lm ln lo mq lq lr ls ij bi translated">图形数据库的主要目的是使关系更容易管理，无论我们谈论的是具有复杂的多对多关系的 web 应用程序，还是图形数据科学。对这种商店的兴趣几乎一直在增加，特别是自从 Cypher 查询语言被引入 Neo4j 之后。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi mr"><img src="../Images/38209703ac1ddff391a11d94d2f69236.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-jsqhjOmv58S6MIIj9K92w.png"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">来源:<a class="ae kw" href="https://db-engines.com/de/blog_post/53" rel="noopener ugc nofollow" target="_blank">https://db-engines.com/de/blog_post/53</a></p></figure><p id="9bf2" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">Cypher 让编写直观的查询变得如此容易。例如，我确信您将立即了解这个查询正在做什么:</p><pre class="kh ki kj kk gt ms mt mu mv aw mw bi"><span id="6cb9" class="mx lv iq mt b gy my mz l na nb">MATCH (:User {name: "Emil"})-[:FOLLOWS]-&gt;(u:User)<br/>WHERE NOT u.name STARTS WITH "neo"<br/>RETURN u.name, u.dateJoined</span></pre><p id="25ac" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">上面的查询需要注意一些事情:</p><ul class=""><li id="5585" class="nc nd iq kz b la lb ld le lg ne lk nf lo ng ls nh ni nj nk bi translated">由括号<code class="fe nl nm nn mt b">()</code>分隔的节点有一个标签，通过前导<code class="fe nl nm nn mt b">:</code>可以识别</li><li id="bb9f" class="nc nd iq kz b la no ld np lg nq lk nr lo ns ls nh ni nj nk bi translated">由方括号<code class="fe nl nm nn mt b">[]</code>分隔的关系必须有一个类型。按照惯例，关系类型是大写的。</li></ul><h2 id="12d9" class="mx lv iq bd lw nt nu dn ma nv nw dp me lg nx ny mg lk nz oa mi lo ob oc mk od bi translated">正在尝试 Neo4j</h2><p id="0427" class="pw-post-body-paragraph kx ky iq kz b la mm jr lc ld mn ju lf lg mo li lj lk mp lm ln lo mq lq lr ls ij bi translated">说服给 Neo4j 一试？你有两种方法可以做到:</p><ul class=""><li id="6c1a" class="nc nd iq kz b la lb ld le lg ne lk nf lo ng ls nh ni nj nk bi translated">使用沙箱在有限的时间内(3 天，可以延长 7 天)运行 Neo4j 实例:<a class="ae kw" href="https://sandbox.neo4j.com/" rel="noopener ugc nofollow" target="_blank">https://sandbox.neo4j.com/</a></li><li id="34a7" class="nc nd iq kz b la no ld np lg nq lk nr lo ns ls nh ni nj nk bi translated">下载 Neo4j 桌面并在本地运行，享受所有功能:<a class="ae kw" href="https://neo4j.com/download/" rel="noopener ugc nofollow" target="_blank">https://neo4j.com/download/</a></li></ul><p id="83bb" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在这两种情况下，这是完全免费的。在这篇博客的后面，我将使用 Neo4j 4.1 创建一个新的图表。</p><h2 id="7b54" class="mx lv iq bd lw nt nu dn ma nv nw dp me lg nx ny mg lk nz oa mi lo ob oc mk od bi translated">导入一些数据</h2><p id="d440" class="pw-post-body-paragraph kx ky iq kz b la mm jr lc ld mn ju lf lg mo li lj lk mp lm ln lo mq lq lr ls ij bi translated">让我们将一些数据导入图表。为此，我们将使用<code class="fe nl nm nn mt b">got</code>浏览器指南来使用“权力的游戏”数据集。类型:</p><pre class="kh ki kj kk gt ms mt mu mv aw mw bi"><span id="e931" class="mx lv iq mt b gy my mz l na nb">:play got</span></pre><p id="32ea" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在浏览器中，并按照说明进行操作。</p><p id="151d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">导入数据后，图表模式如下所示:</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/ab8b6a259de13edd76c1395668dc606b.png" data-original-src="https://miro.medium.com/v2/resize:fit:478/format:webp/1*ygW71Sbfz5ZsdSWR56HFJQ.png"/></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">“权力的游戏”图表模式。(调用 db.schema.visualization)</p></figure><p id="7bef" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">它包含一个节点标签，<code class="fe nl nm nn mt b">Character</code>，五种关系类型(取决于哪本书中的人物彼此交互)和一个全局<code class="fe nl nm nn mt b">INTERACTS</code>关系。在这篇文章的剩余部分，我们将只使用最后一个。如果您想要可视化某些数据，您可以使用:</p><pre class="kh ki kj kk gt ms mt mu mv aw mw bi"><span id="eccb" class="mx lv iq mt b gy my mz l na nb">MATCH (n)<br/>RETURN n<br/>LIMIT 200</span></pre><p id="a246" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">让我们继续进行图形分析和节点嵌入。</p><h1 id="fcf4" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">图形数据科学插件(GDS)</h1><p id="c181" class="pw-post-body-paragraph kx ky iq kz b la mm jr lc ld mn ju lf lg mo li lj lk mp lm ln lo mq lq lr ls ij bi translated">GDS 是图形算法插件的继任者，其首次发布可追溯到 2018 年。它的目标是支持使用图形算法，从路径查找算法到图形神经网络，而不必从 Neo4j 中提取数据。</p><p id="e9f7" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">按照<a class="ae kw" href="https://neo4j.com/docs/graph-data-science/current/installation/#_neo4j_desktop" rel="noopener ugc nofollow" target="_blank">https://neo4j . com/docs/graph-data-science/current/installation/# _ neo4j _ desktop</a>中的步骤进行安装。</p><h2 id="241e" class="mx lv iq bd lw nt nu dn ma nv nw dp me lg nx ny mg lk nz oa mi lo ob oc mk od bi translated">投影图</h2><p id="b1df" class="pw-post-body-paragraph kx ky iq kz b la mm jr lc ld mn ju lf lg mo li lj lk mp lm ln lo mq lq lr ls ij bi translated">Neo4j 图通常包含大量数据:具有不同标签的节点、具有不同类型的关系以及附加到它们的属性。大多数时候，数据科学算法只需要这些实体中的一小部分:只有一些节点标签或一些关系类型，以及只有一个属性(例如，最短路径算法的关系权重)。这就是为什么 GDS 没有在完整的 Neo4j 图上运行，而是在一个<strong class="kz ir">投影</strong>(更轻)版本上运行。所以，让我们开始建立我们的投影图。在 Neo4j 浏览器中，执行:</p><pre class="kh ki kj kk gt ms mt mu mv aw mw bi"><span id="9b1c" class="mx lv iq mt b gy my mz l na nb">CALL gds.graph.create(<br/>    "MyGraph", <br/>    "Character", <br/>    "INTERACTS"<br/>)</span></pre><p id="3e88" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这里我们创建一个名为<code class="fe nl nm nn mt b">MyGraph</code>的投影图，包含所有标签为<code class="fe nl nm nn mt b">Character</code>的节点。此外，我们将类型<code class="fe nl nm nn mt b">INTERACTS</code>添加到这个投影图关系中。</p><p id="9df8" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们在这里，我们的投影图创建，我们可以继续下去，并在它上面执行算法。</p><h2 id="db18" class="mx lv iq bd lw nt nu dn ma nv nw dp me lg nx ny mg lk nz oa mi lo ob oc mk od bi translated">执行节点 2vec</h2><p id="5513" class="pw-post-body-paragraph kx ky iq kz b la mm jr lc ld mn ju lf lg mo li lj lk mp lm ln lo mq lq lr ls ij bi translated">在<code class="fe nl nm nn mt b">MyGraph</code>投影图上运行 node2vec 算法的最简单方法是使用这个简单的查询:</p><pre class="kh ki kj kk gt ms mt mu mv aw mw bi"><span id="e4e7" class="mx lv iq mt b gy my mz l na nb">CALL gds.alpha.node2vec.stream("MyGraph")</span></pre><p id="ca7f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">浏览器中的结果如下图所示，其中一个编号列表被分配给每个节点(由其内部 Neo4j ID，<code class="fe nl nm nn mt b">nodeId</code>标识):</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi of"><img src="../Images/ca4a8d74486d68e6c048b8017bdc0ea6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HjI8QkBLu1hna8wxPltGJg.png"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">带有默认参数的 node2vec 过程的输出。</p></figure><p id="ac2e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果您对 node2vec 的工作原理有所了解，您就会知道有许多配置参数可以用来配置:</p><ul class=""><li id="babb" class="nc nd iq kz b la lb ld le lg ne lk nf lo ng ls nh ni nj nk bi translated"><strong class="kz ir">建立训练数据</strong>(随机行走参数):步数、每个节点生成的行走数、输入输出和返回因子。</li><li id="48f5" class="nc nd iq kz b la no ld np lg nq lk nr lo ns ls nh ni nj nk bi translated"><strong class="kz ir">训练 skip-gram 神经网络</strong>:嵌入大小、初始学习速率等。</li></ul><p id="a725" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">参数的完整列表如下所示，来自 GDS 文档页面。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi og"><img src="../Images/5b185350a0c5249d4bc758b526eaf6d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YJwSWjw2TzOr-xnX4B2_GA.png"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">来自 GDS 文档的 Node2vec 参数<a class="ae kw" href="https://neo4j.com/docs/graph-data-science/current/algorithms/node-embeddings/node2vec/" rel="noopener ugc nofollow" target="_blank">https://neo4j . com/docs/graph-data-science/current/algorithms/node-embeddings/node 2 vec/</a></p></figure><p id="230b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">例如，让我们尝试减小嵌入大小:</p><pre class="kh ki kj kk gt ms mt mu mv aw mw bi"><span id="0ba4" class="mx lv iq mt b gy my mz l na nb">CALL gds.alpha.node2vec.stream(“MyGraph”, {walksPerNode: 2, embeddingSize: 10})</span></pre><p id="a1e1" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">不出所料，现在的输出如下所示:</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi oh"><img src="../Images/ff71e8981f7a963732bb1e42ee3ce9c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7qXGlUMHh39N6p_MIOpK8g.png"/></div></div></figure><p id="0528" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在处理这些结果的用法之前，让我们看看如何使用另一个嵌入算法 GraphSAGE。</p><h2 id="970f" class="mx lv iq bd lw nt nu dn ma nv nw dp me lg nx ny mg lk nz oa mi lo ob oc mk od bi translated">正在执行 GraphSAGE</h2><p id="a095" class="pw-post-body-paragraph kx ky iq kz b la mm jr lc ld mn ju lf lg mo li lj lk mp lm ln lo mq lq lr ls ij bi translated">虽然 Node2vec 只考虑图结构，但是 GraphSAGE 能够考虑节点属性(如果有的话)。</p><p id="6c0f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在我们的 GoT 图中，节点只有一个<code class="fe nl nm nn mt b">name</code>属性，这个属性对于嵌入没有多大意义。然后，我们将只使用节点度，或附加到它的关系数，作为属性:</p><pre class="kh ki kj kk gt ms mt mu mv aw mw bi"><span id="02fa" class="mx lv iq mt b gy my mz l na nb">CALL gds.alpha.graphSage.stream("MyGraph", {degreeAsProperty: true})</span></pre><p id="319b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">完整的参数列表包括属性配置(<code class="fe nl nm nn mt b">nodePropertyNames</code>)、聚合器功能(默认为<code class="fe nl nm nn mt b">mean</code>)、批量……完整列表见下图。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi og"><img src="../Images/a38a30e9b22e1b229b9a2a1693a5e0c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_RJB1dmkqmojvosaPagmoA.png"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">来自 GDS 文档的 GraphSAGE 参数:<a class="ae kw" href="https://neo4j.com/docs/graph-data-science/current/algorithms/alpha/graph-sage/" rel="noopener ugc nofollow" target="_blank">https://neo4j . com/docs/graph-data-science/current/algorithms/alpha/graph-sage/</a></p></figure><h1 id="c661" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">通过 Python 利用结果</h1><p id="dbc4" class="pw-post-body-paragraph kx ky iq kz b la mm jr lc ld mn ju lf lg mo li lj lk mp lm ln lo mq lq lr ls ij bi translated">Neo4j 提供了一个 python 驱动，可以通过 pip 轻松安装。然而，在这篇文章中，我将谈论我开发的一个小工具，它允许毫不费力地从 Python 中调用 GDS 过程:<a class="ae kw" href="https://github.com/stellasia/pygds" rel="noopener ugc nofollow" target="_blank"> pygds </a>。它仍然需要大量的测试，所以如果您发现任何问题，请随时报告。</p><p id="8876" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">让我们从在您最喜欢的 python 环境中安装软件包开始:</p><pre class="kh ki kj kk gt ms mt mu mv aw mw bi"><span id="7638" class="mx lv iq mt b gy my mz l na nb">pip install "pygds&gt;=0.2.0"</span></pre><p id="5d0a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">然后，您可以导入库并定义连接到 Neo4j 图形的凭证:</p><pre class="kh ki kj kk gt ms mt mu mv aw mw bi"><span id="efbe" class="mx lv iq mt b gy my mz l na nb">from pygds import GDS<br/><br/>URI = "bolt://localhost:7687"<br/>AUTH = ("neo4j", "&lt;YOUR_PASSWORD&gt;")</span></pre><p id="74e8" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><code class="fe nl nm nn mt b">pygds</code>的用法如下:</p><pre class="kh ki kj kk gt ms mt mu mv aw mw bi"><span id="b411" class="mx lv iq mt b gy my mz l na nb">with GDS(URI, auth=AUTH) as gds:<br/>    # create the projected graph<br/>    # NB: make sure a graph with the same does not already exists<br/>    # otherwise run CALL gds.graph.drop("MyGraph") <br/>    gds.graph.create(<br/>        "MyGraph", <br/>        "Character", <br/>        "INTERACTS",<br/>    )</span><span id="9f30" class="mx lv iq mt b gy oi mz l na nb">    # run any algorithm on it<br/>    </span></pre><p id="a41f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">例如，要运行 node2vec 算法，我们将编写:</p><pre class="kh ki kj kk gt ms mt mu mv aw mw bi"><span id="17f8" class="mx lv iq mt b gy my mz l na nb">result = gds.alpha.node2vec.stream(<br/>    "MyGraph", <br/>    {<br/>        "walksPerNode": 2, <br/>        "embeddingSize": 10<br/>    }<br/>)</span></pre><p id="9d9c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">然后可以将结果解析成一个<code class="fe nl nm nn mt b">DataFrame</code>:</p><pre class="kh ki kj kk gt ms mt mu mv aw mw bi"><span id="8880" class="mx lv iq mt b gy my mz l na nb">import pandas as pd</span><span id="e32b" class="mx lv iq mt b gy oi mz l na nb">_tmp = pd.DataFrame.from_records(result)<br/>df = pd.DataFrame(_tmp["embedding"].tolist())<br/>print(df.head())</span></pre><p id="490e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">从那里开始，您可以执行任何机器学习算法，从可视化的 PCA 到分类，如果节点也有一些目标类…</p><blockquote class="oj ok ol"><p id="5209" class="kx ky lt kz b la lb jr lc ld le ju lf om lh li lj on ll lm ln oo lp lq lr ls ij bi translated">最后一步，无论你使用的是 Cypher 还是 pygds，你都必须删除存储在你的计算机内存中的投影图:<code class="fe nl nm nn mt b">gds.graph.drop("MyGraph")</code></p></blockquote><h1 id="a1a6" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">想了解更多？</h1><p id="eb52" class="pw-post-body-paragraph kx ky iq kz b la mm jr lc ld mn ju lf lg mo li lj lk mp lm ln lo mq lq lr ls ij bi translated">太好了！GDS 包含更多奇妙的算法实现(路径查找、节点重要性、社区检测、节点相似性、链接预测)和功能(例如，将算法结果作为节点属性写入，以将结果持久存储在图中，而不是以流的形式存储)。</p><p id="e11f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果您有兴趣了解更多关于图算法和 Neo4j 的信息，可以查看以下几个在线资源:</p><ul class=""><li id="e2ef" class="nc nd iq kz b la lb ld le lg ne lk nf lo ng ls nh ni nj nk bi translated">免费书籍“图算法:Apache Spark 和 Neo4j 中的实际例子”，作者:<a class="op oq ep" href="https://medium.com/u/68584b0be0fb?source=post_page-----d45db83e54b6--------------------------------" rel="noopener" target="_blank">马克·李约瑟</a>:<a class="ae kw" href="https://neo4j.com/graph-algorithms-book/" rel="noopener ugc nofollow" target="_blank">https://neo4j.com/graph-algorithms-book/</a>(注意:这本书是使用图算法库(GDS 的前身)编写的，但仍然是理解图算法用例的必读书籍(此处有迁移指南<a class="ae kw" href="https://neo4j.com/docs/graph-data-science/1.0/appendix-b/" rel="noopener ugc nofollow" target="_blank"/>以及使用 GDS 更新的<a class="ae kw" rel="noopener" target="_blank" href="/introducing-the-neo4j-graph-data-science-plugin-with-examples-from-the-graph-algorithms-19b831f66f2">示例)；警告 2:它可能不会无限期免费，Neo4j 会定期宣布其“免费期”的结束，到目前为止，免费期一直在延长，但谁知道呢)</a></li><li id="fbe3" class="nc nd iq kz b la no ld np lg nq lk nr lo ns ls nh ni nj nk bi translated">查看<a class="op oq ep" href="https://medium.com/u/26bec2028463?source=post_page-----d45db83e54b6--------------------------------" rel="noopener" target="_blank"> Neo4j </a>创建的 GraphAcademy 及其数据科学课程:<br/><a class="ae kw" href="https://neo4j.com/graphacademy/online-training/data-science/part-0/" rel="noopener ugc nofollow" target="_blank">https://Neo4j . com/graph academy/online-training/data-science/part-0/</a></li><li id="0742" class="nc nd iq kz b la no ld np lg nq lk nr lo ns ls nh ni nj nk bi translated">你可以关注 medium 上的<a class="op oq ep" href="https://medium.com/u/57f13c0ea39a?source=post_page-----d45db83e54b6--------------------------------" rel="noopener" target="_blank">托马兹·布拉坦尼克</a>和他的博客，看看 GDS 所有算法的许多有趣的用例:<a class="ae kw" href="https://tbgraph.wordpress.com/" rel="noopener ugc nofollow" target="_blank">https://tbgraph.wordpress.com/</a></li><li id="3f5b" class="nc nd iq kz b la no ld np lg nq lk nr lo ns ls nh ni nj nk bi translated">当然，阅读文件:<a class="ae kw" href="https://neo4j.com/docs/graph-data-science/current/" rel="noopener ugc nofollow" target="_blank">https://neo4j.com/docs/graph-data-science/current/</a></li><li id="03d3" class="nc nd iq kz b la no ld np lg nq lk nr lo ns ls nh ni nj nk bi translated">关于这里讨论的算法的更多信息，例如参见 Kung-Hsiang，Huang (Steeve) 的【图神经网络(Basis、DeepWalk 和 GraphSage)的温和介绍】(T3):</li></ul></div></div>    
</body>
</html>