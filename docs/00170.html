<html>
<head>
<title>Let’s Make a KNN Classifier from Scratch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们从头开始制作一个 KNN 分类器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/lets-make-a-knn-classifier-from-scratch-e73c43da346d?source=collection_archive---------11-----------------------#2020-01-06">https://towardsdatascience.com/lets-make-a-knn-classifier-from-scratch-e73c43da346d?source=collection_archive---------11-----------------------#2020-01-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="82f3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你只需要一点钱和一点时间。包括源代码。</h2></div><p id="9e74" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从头开始编写整个机器的算法可能是一个乏味的过程。这就是为什么我们有图书馆。另一个原因是，如果我们没有投入足够的时间和精力，我们自己的实现很可能无法与来自<strong class="kk iu"> Scikit-Learn </strong>的现成解决方案竞争。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/ade6eb797ffa78b2a5e40911348448b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YF3xiqJX4r3xqtmP"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">由<a class="ae lu" href="https://unsplash.com/@englr?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿尔文·恩格勒</a>在<a class="ae lu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="b820" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，这并不意味着你不应该从头开始编写算法。以下是这样做的一些好处:</p><ol class=""><li id="4fdb" class="lv lw it kk b kl km ko kp kr lx kv ly kz lz ld ma mb mc md bi translated">你已经完成了对代码的控制</li><li id="16f7" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld ma mb mc md bi translated">你将把你对算法的理解提升到一个全新的水平</li></ol><p id="2916" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">今天，我想向你展示用<em class="mj"> NumPy </em>库编写一个简单的<strong class="kk iu"> K 最近邻算法</strong>是多么容易。当然，它不会是最先进的，会有很多东西需要优化，但这是一个好的开始。在这篇文章的结尾，我希望你能感觉到你已经发明了它。</p><p id="65d2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你不想自己写代码，这里有<a class="ae lu" href="https://github.com/daradecic/K-Nearest_Neighbors/blob/master/K-Nearest_Neighbors.ipynb" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>。</p><p id="8181" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">事不宜迟，我们开始吧。你唯一需要的库是<em class="mj"> Numpy </em>(暂时是<em class="mj"/>)所以确保导入它。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="48af" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">什么是 KNN？</h1><p id="eb43" class="pw-post-body-paragraph ki kj it kk b kl nj ju kn ko nk jx kq kr nl kt ku kv nm kx ky kz nn lb lc ld im bi translated">KNN 代表 K-最近邻。这基本上是一种分类算法，它将根据定义的最近邻数量来预测目标变量的类别。它将计算从您要分类的实例到训练数据集的每个实例的<strong class="kk iu">距离</strong>，然后根据 k 个最近实例的大多数类别对您的实例进行分类。</p><p id="eeb8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你是第一次阅读这篇文章，这听起来可能会令人困惑，但它实际上是一个非常简单的算法。</p><p id="6540" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于有大量的理论解释，我决定不再深入研究，而是把时间集中在实现方面。然而，如果你缺乏理论背景，请随意参考这篇文章(<em class="mj">或任何你在网上找到的其他文章</em>):</p><div class="no np gp gr nq nr"><a href="https://blog.usejournal.com/a-quick-introduction-to-k-nearest-neighbors-algorithm-62214cea29c7" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">K-最近邻算法快速介绍</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">大家好！今天我想谈谈 K-最近邻算法(或 KNN)。KNN 算法是一种…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">blog.usejournal.com</p></div></div><div class="oa l"><div class="ob l oc od oe oa of lo nr"/></div></div></a></div></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="d7e8" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">两个向量之间的距离</h1><p id="f55d" class="pw-post-body-paragraph ki kj it kk b kl nj ju kn ko nk jx kq kr nl kt ku kv nm kx ky kz nn lb lc ld im bi translated">你可以把数据集中的行和 X 看作向量。有了这个想法，你可能知道有很多方法可以测量向量之间的距离。我脑海中闪现的一些想法是:</p><ol class=""><li id="8d46" class="lv lw it kk b kl km ko kp kr lx kv ly kz lz ld ma mb mc md bi translated">欧几里得距离</li><li id="990f" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld ma mb mc md bi translated">余弦距离</li></ol><p id="f836" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我将把注意力集中在第一个方面，我们将从头开始编写代码。简单来说，欧氏距离就是欧氏空间中两个数据点之间的一个<strong class="kk iu">直线距离</strong>[1]。它可以计算如下:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi og"><img src="../Images/86f346a1460700fde56f9ad61862e2ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*MNP4KkfE-koqBe-TVptWSg.png"/></div></figure><p id="eac6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这真的是一个简单的公式，你不必事先知道维数。让我们用 Python 来编码:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/77d3083cdea4218c0ae71e81c8936022.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/1*GRuyhz94SC0mBt1y4iDKLg.png"/></div></figure><p id="fc5e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是全部了！</p><p id="49e9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们做两个快速检查:</p><ul class=""><li id="7e54" class="lv lw it kk b kl km ko kp kr lx kv ly kz lz ld oi mb mc md bi translated">在相同的向量上(<em class="mj">距离应为 0 </em>)</li><li id="cde6" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld oi mb mc md bi translated">在不同的向量上(<em class="mj">距离不应为 0 </em>)</li></ul><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/d0013d7c3dcd1b18c6389f310b360b6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/1*1x8c3hPC3dqDVeIThGZc1w.png"/></div></figure></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="5b8b" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">算法实现</h1><p id="b20f" class="pw-post-body-paragraph ki kj it kk b kl nj ju kn ko nk jx kq kr nl kt ku kv nm kx ky kz nn lb lc ld im bi translated">好了，前面的部分显然是工作的，现在是时候编码出算法的核心了。我将声明一个函数<code class="fe oj ok ol om b">predict()</code>，它将接受 3 个参数:</p><ul class=""><li id="3d49" class="lv lw it kk b kl km ko kp kr lx kv ly kz lz ld oi mb mc md bi translated"><code class="fe oj ok ol om b">k</code>:k 的值</li><li id="c311" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld oi mb mc md bi translated"><code class="fe oj ok ol om b">train_set</code>:带有目标变量的整个矩阵</li><li id="22b6" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld oi mb mc md bi translated"><code class="fe oj ok ol om b">test_instance</code>:没有目标变量值的单个矢量</li></ul><p id="ad6f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是所需的步骤:</p><ol class=""><li id="7242" class="lv lw it kk b kl km ko kp kr lx kv ly kz lz ld ma mb mc md bi translated">计算<code class="fe oj ok ol om b">test_instance</code>和<code class="fe oj ok ol om b">train_set</code>每行之间的欧氏距离</li><li id="13d1" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld ma mb mc md bi translated">按距离值对距离进行排序，从最低到最高</li><li id="f0d7" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld ma mb mc md bi translated">保持<code class="fe oj ok ol om b">k</code>最小的距离</li><li id="0bd2" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld ma mb mc md bi translated">获取距离最小的<code class="fe oj ok ol om b">k</code> <code class="fe oj ok ol om b">train_set</code>行的目标变量值</li><li id="2fa0" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld ma mb mc md bi translated">无论哪个目标变量类占多数，都将获胜</li></ol><p id="7c16" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我所说的，这个算法非常简单，编码出来应该不成问题。为了方便起见，我对每一行代码都做了注释，这样你就不会迷路了:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi on"><img src="../Images/70bc1ef69af3e0958c232ddecfd70a80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ITT9zJyBTjNfduIceQO-mA.png"/></div></div></figure><p id="420d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我知道要写相当多的代码，但这是值得的。</p><p id="8de1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，如果我们不能以某种方式<strong class="kk iu">评估</strong>这个算法，那么实现这个算法就毫无意义。这就是为什么我决定实现一个基本的准确性报告功能，它将报告算法在测试集上的表现如何:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/5c1f5738db18a9bcf724abc0b7cf1a4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/format:webp/1*u1vWjGF5JR8IB01R7GPHkA.png"/></div></figure></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="4ec1" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">让我们组成一个班级</h1><p id="fec8" class="pw-post-body-paragraph ki kj it kk b kl nj ju kn ko nk jx kq kr nl kt ku kv nm kx ky kz nn lb lc ld im bi translated">如果你问我，我认为一切看起来比它应该的更乱。这主要是因为我们到处都有函数。因此，让我们通过将所有这些函数放在一个名为<code class="fe oj ok ol om b">KNearestNeighbors</code>的类中来解决这个问题。你需要做一些小的修改，但是因为这些都是无关紧要的，所以我决定不对它们进行评论。</p><p id="29e9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不管怎样，这是完整的课程:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi op"><img src="../Images/b38111e09807dc384b1aeb7bee7973b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*23XNxD9tS6QRaFd6xnUtog.png"/></div></div></figure></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="6c43" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">我们来评价一下</h1><p id="540b" class="pw-post-body-paragraph ki kj it kk b kl nj ju kn ko nk jx kq kr nl kt ku kv nm kx ky kz nn lb lc ld im bi translated">是时候评估我们的算法了。为了简单起见，我决定使用著名的<strong class="kk iu">虹膜数据集</strong>，它可以从<em class="mj"> Scikit-Learn </em>加载。</p><p id="4af1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是让您开始工作的代码:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi op"><img src="../Images/ccf5fc42d02d68b84b0bf1642d9e59a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yc_Hr_fkNNglu_mu7MkR4g.png"/></div></div></figure><p id="e00c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是所有东西应该看起来的样子:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/2d280dfe05392544a79104ff0394d0f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/format:webp/1*RxBRwTgKCeT1x02UvJrxEQ.png"/></div></figure><p id="2e29" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你想知道什么是 Bamboolib，请看这篇文章:</p><div class="no np gp gr nq nr"><a rel="noopener follow" target="_blank" href="/introducing-bamboolib-a-gui-for-pandas-4f6c091089e3"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">熊猫图形用户界面 Bamboolib 简介</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">学习熊猫和数据分析从未如此容易</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">towardsdatascience.com</p></div></div><div class="oa l"><div class="or l oc od oe oa of lo nr"/></div></div></a></div><p id="1e39" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，我们需要以某种方式将数据集分成训练和测试部分。这很容易做到，代码如下:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi os"><img src="../Images/589f6940118ee721f25cd31beb9fa37a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*N7xBkFob6wQa6LMbguqoXQ.png"/></div></figure><p id="d03c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们创建一个<code class="fe oj ok ol om b">KNearestNeighbors</code>类的实例，并将<code class="fe oj ok ol om b">k</code>设置为 3。然后，我们可以训练模型并轻松评估其性能:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/e9fff6e9fae3f7f77f8279547f579f8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1050/format:webp/1*25dyq3w4egNv6-oyTg7dtQ.png"/></div></figure><p id="a2a0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> K = 3 </strong>似乎是一个合理的选择。就这样，我们得到了 94.6%的准确率，这是惊人的。</p><p id="75d6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是我们怎么知道这是不是 K 的最优值呢？T13】</p><p id="cb46" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们不知道，我们需要手动验证。归结起来就是在一个循环中从上面包围代码:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/e857d371d68e0b9216c921caf5b76350.png" data-original-src="https://miro.medium.com/v2/resize:fit:1114/format:webp/1*a_x9ZsEVcRWO-8KQb2AxVQ.png"/></div></figure><p id="3f3e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你想知道为什么我决定只使用奇数<strong class="kk iu"/>，那是因为这样在算法进行分类时不可能得到平局。</p><p id="68f9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">K 的值 3 和 5 似乎产生相同的精度，我们可以设置<strong class="kk iu"> K = 13 </strong>来获得更好的模型。对于您来说，准确性分数可能会有所不同，这是因为训练集和测试集是随机采样的，但不应该有任何明显的差异。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="fc87" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">下一步是什么？</h1><p id="dc15" class="pw-post-body-paragraph ki kj it kk b kl nj ju kn ko nk jx kq kr nl kt ku kv nm kx ky kz nn lb lc ld im bi translated">这是 K-最近邻算法的一个相当简单的实现。它工作得很好，但仍有一些事情你可以做，如:</p><ul class=""><li id="d60c" class="lv lw it kk b kl km ko kp kr lx kv ly kz lz ld oi mb mc md bi translated">尝试其他距离算法(<em class="mj">如余弦距离</em>)</li><li id="cede" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld oi mb mc md bi translated"><strong class="kk iu">数据标准化</strong></li></ul><p id="1d71" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">后者实际上对 KNN 正常工作非常重要，因为您的输入可能不在同一个单元中。可以这样想——2.5 米和 250 厘米对你来说是一样的，但是算法会认为后者更重要，因为<strong class="kk iu">的尺度更大</strong>。</p><p id="7c23" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Iris dataset 没有这个问题，所以我决定跳过这一部分。在真实世界的数据集上，您可能不应该这样做。</p><p id="f94e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢阅读，我希望你的机器一切正常。如果没有，就从我的<a class="ae lu" href="https://github.com/daradecic/K-Nearest_Neighbors/blob/master/K-Nearest_Neighbors.ipynb" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>下载代码。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><p id="6971" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">喜欢这篇文章吗？成为 <a class="ae lu" href="https://medium.com/@radecicdario/membership" rel="noopener"> <em class="mj">中等会员</em> </a> <em class="mj">继续无限制学习。如果你使用下面的链接，我会收到你的一部分会员费，不需要你额外付费。</em></p><div class="no np gp gr nq nr"><a href="https://medium.com/@radecicdario/membership" rel="noopener follow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">通过我的推荐链接加入 Medium-Dario rade ci</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">medium.com</p></div></div><div class="oa l"><div class="ov l oc od oe oa of lo nr"/></div></div></a></div></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="2d81" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">参考</h1><p id="addb" class="pw-post-body-paragraph ki kj it kk b kl nj ju kn ko nk jx kq kr nl kt ku kv nm kx ky kz nn lb lc ld im bi translated">[1]<a class="ae lu" href="https://en.wikipedia.org/wiki/Euclidean_distance" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Euclidean_distance</a></p></div></div>    
</body>
</html>