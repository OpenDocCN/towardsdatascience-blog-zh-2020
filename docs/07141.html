<html>
<head>
<title>Customer Segmentation in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中的客户细分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/customer-segmentation-in-python-9c15acf6f945?source=collection_archive---------4-----------------------#2020-06-01">https://towardsdatascience.com/customer-segmentation-in-python-9c15acf6f945?source=collection_archive---------4-----------------------#2020-06-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="a808" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">无监督学习</h2><div class=""/><div class=""><h2 id="ba41" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">基于 K-均值聚类算法的图像分割。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/b9e32ea3cee246645a38f11eb83ff39b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e8RodXrQFni7vA9HFddcqg.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">里卡多·戈麦斯·安吉尔在<a class="ae lh" href="https://unsplash.com/s/photos/difference?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="8599" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi me translated">T4:假设我们有一家公司销售该产品，你想知道该产品的销售情况如何。</p><p id="df3a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你有我们可以分析的数据，但是我们能做什么样的分析呢？</p><p id="f283" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">嗯，我们可以根据客户在市场上的购买行为对他们进行细分。</p><p id="c89c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">请记住，数据非常庞大，我们无法用肉眼来分析。我们将使用机器学习算法和计算能力。</p><p id="06c9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">本文将向您展示如何使用 Python 中的 K-Means 算法根据客户的行为对客户进行聚类。</p><p id="e4c0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我希望这篇文章能帮助你从准备数据到聚类，一步一步地进行客户细分。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="4d76" class="mu mv it bd mw mx my mz na nb nc nd ne ki nf kj ng kl nh km ni ko nj kp nk nl bi translated">行动（或活动、袭击）计划</h1><p id="4e05" class="pw-post-body-paragraph li lj it lk b ll nm kd ln lo nn kg lq lr no lt lu lv np lx ly lz nq mb mc md im bi translated">在我们进入这个过程之前，我会简要地告诉你我们将采取什么样的步骤。</p><ul class=""><li id="d355" class="nr ns it lk b ll lm lo lp lr nt lv nu lz nv md nw nx ny nz bi translated"><strong class="lk jd">收集数据</strong></li><li id="567e" class="nr ns it lk b ll oa lo ob lr oc lv od lz oe md nw nx ny nz bi translated"><strong class="lk jd">创建最近频率货币(RFM)表</strong></li><li id="3f91" class="nr ns it lk b ll oa lo ob lr oc lv od lz oe md nw nx ny nz bi translated"><strong class="lk jd">管理偏斜度并衡量每个变量</strong></li><li id="d515" class="nr ns it lk b ll oa lo ob lr oc lv od lz oe md nw nx ny nz bi translated"><strong class="lk jd">探索数据</strong></li><li id="aecc" class="nr ns it lk b ll oa lo ob lr oc lv od lz oe md nw nx ny nz bi translated"><strong class="lk jd">对数据进行聚类</strong></li><li id="7f43" class="nr ns it lk b ll oa lo ob lr oc lv od lz oe md nw nx ny nz bi translated"><strong class="lk jd">解读结果</strong></li></ul></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="78e6" class="mu mv it bd mw mx my mz na nb nc nd ne ki nf kj ng kl nh km ni ko nj kp nk nl bi translated">分析</h1><h2 id="f4d3" class="of mv it bd mw og oh dn na oi oj dp ne lr ok ol ng lv om on ni lz oo op nk iz bi translated"><strong class="ak">数据收集</strong></h2><p id="294e" class="pw-post-body-paragraph li lj it lk b ll nm kd ln lo nn kg lq lr no lt lu lv np lx ly lz nq mb mc md im bi translated">在这一步中，我们将首先收集数据。对于这种情况，我们将从 UCI 机器学习中获取名为在线零售数据集的数据。</p><p id="0be2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">数据集本身是一个交易数据，包含一家英国在线零售商从 2010 年 12 月 1 日到 2011 年 12 月 9 日的交易。</p><p id="2f46" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">每一行代表发生的交易。它包括产品名称、数量、价格和其他表示 ID 的列。</p><p id="c687" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您可以从<a class="ae lh" href="https://archive.ics.uci.edu/ml/datasets/online+retail" rel="noopener ugc nofollow" target="_blank">这里</a>访问数据集。</p><p id="33c7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是数据集的大小。</p><pre class="ks kt ku kv gt oq or os ot aw ou bi"><span id="f7af" class="of mv it or b gy ov ow l ox oy">(541909, 8)</span></pre><p id="d98f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这种情况下，我们不使用所有的行。相反，我们将从数据集中抽取 10000 行作为样本，并假设这是客户进行的全部交易。</p><p id="fd8f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">代码看起来会像这样，</p><pre class="ks kt ku kv gt oq or os ot aw ou bi"><span id="6c0b" class="of mv it or b gy ov ow l ox oy"><strong class="or jd"># Import The Libraries</strong><br/># ! pip install xlrd<br/>import pandas as pd<br/>import matplotlib.pyplot as plt<br/>import numpy as np</span><span id="3a98" class="of mv it or b gy oz ow l ox oy"><strong class="or jd"># Import The Dataset</strong><br/>df = pd.read_excel('dataset.xlsx')<br/>df = df[df['CustomerID'].notna()]</span><span id="3af3" class="of mv it or b gy oz ow l ox oy"><strong class="or jd"># Sample the dataset</strong><br/>df_fix = df.sample(10000, random_state = 42)</span></pre><p id="ffb3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是数据集的一瞥，</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pa"><img src="../Images/e7b99dfb64779253511f92f1d89dbf1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YXZPlnOu-OXR3Q0XBk8GiA.png"/></div></div></figure><h2 id="50e1" class="of mv it bd mw og oh dn na oi oj dp ne lr ok ol ng lv om on ni lz oo op nk iz bi translated"><strong class="ak">创建 RFM 表</strong></h2><p id="2a1d" class="pw-post-body-paragraph li lj it lk b ll nm kd ln lo nn kg lq lr no lt lu lv np lx ly lz nq mb mc md im bi translated">在我们对数据进行采样之后，我们将使数据更容易进行分析。</p><p id="7bd4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了细分客户，我们可以使用一些指标，如客户上次购买产品的时间、客户购买产品的频率以及客户为产品支付的金额。我们将这种分割称为 RFM 分割。</p><p id="1bce" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了制作 RFM 表，我们可以创建这些列，比如 Recency、Frequency 和 MonetaryValue 列。</p><p id="3c09" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">要获得最近的天数列，我们可以用事务发生的日期减去快照日期。</p><p id="d0f5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">要创建 frequency 列，我们可以计算每个客户的交易量。</p><p id="01dd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最后，为了创建货币值列，我们可以对每个客户的所有交易进行求和。</p><p id="e80f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">代码看起来像这样，</p><pre class="ks kt ku kv gt oq or os ot aw ou bi"><span id="966f" class="of mv it or b gy ov ow l ox oy"><strong class="or jd"># Convert to show date only<br/></strong>from datetime import datetime<br/>df_fix["InvoiceDate"] = df_fix["InvoiceDate"].dt.date</span><span id="237d" class="of mv it or b gy oz ow l ox oy"><strong class="or jd"># Create TotalSum colummn</strong><br/>df_fix["TotalSum"] = df_fix["Quantity"] * df_fix["UnitPrice"]</span><span id="e0ae" class="of mv it or b gy oz ow l ox oy"><strong class="or jd"># Create date variable that records recency</strong><br/>import datetime<br/>snapshot_date = max(df_fix.InvoiceDate) + datetime.timedelta(days=1)</span><span id="1b4c" class="of mv it or b gy oz ow l ox oy"><strong class="or jd"># Aggregate data by each customer</strong><br/>customers = df_fix.groupby(['CustomerID']).agg({<br/>    'InvoiceDate': lambda x: (snapshot_date - x.max()).days,<br/>    'InvoiceNo': 'count',<br/>    'TotalSum': 'sum'})</span><span id="7ab1" class="of mv it or b gy oz ow l ox oy"><strong class="or jd"># Rename columns</strong><br/>customers.rename(columns = {'InvoiceDate': 'Recency',<br/>                            'InvoiceNo': 'Frequency',<br/>                            'TotalSum': 'MonetaryValue'}, inplace=True)</span></pre><p id="dd73" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是数据集的一瞥，</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/7c11ba7ea4076adc815fc573c4b40bd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/format:webp/1*pFlGeRrg4X7iB59mn8OIsg.png"/></div></figure><p id="c25d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">目前，数据集由最近、频率和货币值列组成。但是我们还不能使用数据集，因为我们必须对数据进行更多的预处理。</p><h2 id="d2fa" class="of mv it bd mw og oh dn na oi oj dp ne lr ok ol ng lv om on ni lz oo op nk iz bi translated"><strong class="ak">管理偏斜度和缩放比例</strong></h2><p id="cad3" class="pw-post-body-paragraph li lj it lk b ll nm kd ln lo nn kg lq lr no lt lu lv np lx ly lz nq mb mc md im bi translated">我们必须确保数据符合这些假设，</p><blockquote class="pc"><p id="680c" class="pd pe it bd pf pg ph pi pj pk pl md dk translated">数据应该满足假设，即变量没有偏斜，并且具有相同的均值和方差。</p></blockquote><p id="7839" class="pw-post-body-paragraph li lj it lk b ll pm kd ln lo pn kg lq lr po lt lu lv pp lx ly lz pq mb mc md im bi translated">正因为如此，我们必须管理变量的偏斜度。</p><p id="c7e8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是每个变量的可视化，</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pr"><img src="../Images/f6b5cc47f9c3af0e7693e9bb21357ab8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tKnuPG6dTB1bmMUfacKUuA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">从左到右:最近、频率和货币值列</p></figure><p id="03ac" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">正如我们从上面看到的，我们必须转换数据，所以它有一个更对称的形式。</p><p id="002e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以使用一些方法来管理偏度，它们是，</p><ul class=""><li id="2b36" class="nr ns it lk b ll lm lo lp lr nt lv nu lz nv md nw nx ny nz bi translated"><strong class="lk jd">日志转换</strong></li><li id="58a1" class="nr ns it lk b ll oa lo ob lr oc lv od lz oe md nw nx ny nz bi translated"><strong class="lk jd">平方根变换</strong></li><li id="7c47" class="nr ns it lk b ll oa lo ob lr oc lv od lz oe md nw nx ny nz bi translated"><strong class="lk jd"> box-cox 变换</strong></li></ul><blockquote class="ps pt pu"><p id="103a" class="li lj pv lk b ll lm kd ln lo lp kg lq pw ls lt lu px lw lx ly py ma mb mc md im bi translated">注意:当且仅当变量只有正值时，我们才能使用转换。</p></blockquote><p id="5561" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">下面是每个变量的可视化，有和没有转换。每个变量从左上顺时针方向显示了没有变换、对数变换、平方根变换和 box-cox 变换的图。</p><div class="ks kt ku kv gt ab cb"><figure class="pz kw qa qb qc qd qe paragraph-image"><img src="../Images/71f1c8aee5d892e450e9fa64d8e4d16e.png" data-original-src="https://miro.medium.com/v2/resize:fit:704/format:webp/1*VjEUDLv2dAyXCYKBJdcJTA.png"/></figure><figure class="pz kw qa qb qc qd qe paragraph-image"><img src="../Images/a8be97d2b80cf65c8dae909305842d46.png" data-original-src="https://miro.medium.com/v2/resize:fit:704/format:webp/1*tSYHUpg17tw81t2fXRhSFQ.png"/><p class="ld le gj gh gi lf lg bd b be z dk qf di qg qh translated">左:最近列，右:频率列</p></figure></div><p id="886d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">基于这种可视化，它显示了具有 box-cox 变换的变量显示出比其他变换更对称的形式。</p><p id="efba" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了确保这一点，我们使用 skew 函数计算每个变量。结果看起来像这样，</p><pre class="ks kt ku kv gt oq or os ot aw ou bi"><span id="5300" class="of mv it or b gy ov ow l ox oy"><strong class="or jd">variable, without, log, sqrt, box-cox transformations<br/>Recency, 14.77, 0.85, 3.67, 0.16<br/>Frequency, 0.93, -0.72, 0.32, -0.1</strong></span></pre><p id="783e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">下面是如何解读偏斜度值。如果该值接近 0，变量往往具有对称形式。然而，如果不是这样，变量就有偏斜。基于这种计算，我们使用使用 box-cox 变换的变量。</p><p id="53d8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">基于该计算，我们将利用使用 box-cox 变换的变量。MonetaryValue 变量除外，因为该变量包含负值。为了处理这个变量，我们可以对数据使用立方根变换，所以比较看起来像这样，</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qi"><img src="../Images/247a089ccd617c7fd950acc86b6f36b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*Kqy1S2-T6rBx7eTFGFHgWQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">不含和含立方根变换</p></figure><p id="18dd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">通过使用这种转换，我们将得到不那么扭曲的数据。偏斜度值从 16.63 下降到 1.16。因此，我们可以用这段代码转换 RFM 表，</p><pre class="ks kt ku kv gt oq or os ot aw ou bi"><span id="b4cd" class="of mv it or b gy ov ow l ox oy">from scipy import stats<br/>customers_fix = pd.DataFrame()<br/>customers_fix["Recency"] = stats.boxcox(customers['Recency'])[0]<br/>customers_fix["Frequency"] = stats.boxcox(customers['Frequency'])[0]<br/>customers_fix["MonetaryValue"] = pd.Series(np.cbrt(customers['MonetaryValue'])).values<br/>customers_fix.tail()</span></pre><p id="5429" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">它看起来会像这样，</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qj"><img src="../Images/a07332fb314feeb6871e18f8472c33d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:692/format:webp/1*2QpDa7ea2NoXAcMhpiPXFQ.png"/></div></figure><p id="3eef" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们现在能使用数据吗？还没有。如果我们再看一下这个图，每个变量都没有相同的均值和方差。我们必须把它正常化。为了规范化，我们可以使用 scikit-learn 库中的 StandardScaler 对象来实现。代码看起来会像这样，</p><pre class="ks kt ku kv gt oq or os ot aw ou bi"><span id="3e02" class="of mv it or b gy ov ow l ox oy"><strong class="or jd"># Import library</strong><br/>from sklearn.preprocessing import StandardScaler</span><span id="85f7" class="of mv it or b gy oz ow l ox oy"><strong class="or jd"># Initialize the Object</strong><br/>scaler = StandardScaler()</span><span id="6b16" class="of mv it or b gy oz ow l ox oy"><strong class="or jd"># Fit and Transform The Data</strong><br/>scaler.fit(customers_fix)<br/>customers_normalized = scaler.transform(customers_fix)</span><span id="b064" class="of mv it or b gy oz ow l ox oy"><strong class="or jd"># Assert that it has mean 0 and variance 1</strong><br/>print(customers_normalized.mean(axis = 0).round(2)) <strong class="or jd"># [0. -0. 0.]<br/></strong>print(customers_normalized.std(axis = 0).round(2)) <strong class="or jd"># [1. 1. 1.]</strong></span></pre><p id="9d04" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">数据会像这样，</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qk"><img src="../Images/a927f38b9f108af32bba1d858bfe38de.png" data-original-src="https://miro.medium.com/v2/resize:fit:556/format:webp/1*hW-I8_c9WsY3w2QhUDDg_g.png"/></div></figure><p id="96d2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最后，我们可以使用这些数据进行聚类。</p><h2 id="18fe" class="of mv it bd mw og oh dn na oi oj dp ne lr ok ol ng lv om on ni lz oo op nk iz bi translated">系统模型化</h2><p id="e9b9" class="pw-post-body-paragraph li lj it lk b ll nm kd ln lo nn kg lq lr no lt lu lv np lx ly lz nq mb mc md im bi translated">在我们对数据进行预处理之后，现在我们可以专注于建模了。为了从数据中进行分割，我们可以使用 K-Means 算法来实现。</p><p id="9ec4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">K-Means 算法是一种无监督学习算法，它使用几何原理来确定哪个聚类属于数据。通过确定每个质心，我们计算到每个质心的距离。如果每个数据与另一个数据的距离最小，则该数据属于一个质心。如此重复，直到下一次总距离没有比之前有显著变化。</p><p id="2c65" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">用 Python 实现 K-Means 很容易。我们可以使用 scikit 中的 KMeans 函数——学会做这件事。</p><p id="d747" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了使我们的聚类达到最佳性能，我们必须确定哪个超参数适合数据。为了确定哪个超参数最适合我们的模型和数据，我们可以使用肘方法来决定。代码看起来会像这样，</p><pre class="ks kt ku kv gt oq or os ot aw ou bi"><span id="e0ea" class="of mv it or b gy ov ow l ox oy">from sklearn.cluster import KMeans</span><span id="058e" class="of mv it or b gy oz ow l ox oy">sse = {}<br/>for k in range(1, 11):<br/>    kmeans = KMeans(n_clusters=k, random_state=42)<br/>    kmeans.fit(customers_normalized)<br/>    sse[k] = kmeans.inertia_ # SSE to closest cluster centroid</span><span id="9fd1" class="of mv it or b gy oz ow l ox oy">plt.title('The Elbow Method')<br/>plt.xlabel('k')<br/>plt.ylabel('SSE')<br/>sns.pointplot(x=list(sse.keys()), y=list(sse.values()))<br/>plt.show()</span></pre><p id="2ec5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是结果，</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ql"><img src="../Images/8fe42177a6a714fa0adb6c5099c53faa.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/1*lXfgyyGfa3qt1HmTwW5yAg.png"/></div></figure><p id="7a02" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如何解读剧情？x 轴是 k 的值，y 轴是数据的 SSE 值。我们将通过查看 k 值在下一个连续 k 值的线性趋势来选择最佳参数。</p><p id="16b4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">根据我们的观察，k 值为 3 是我们模型的最佳超参数，因为下一个 k 值往往具有线性趋势。因此，我们对数据的最佳模型是<strong class="lk jd"> K-Means，聚类数是 3 </strong>。</p><p id="f905" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，我们可以用这段代码来拟合这个模型，</p><pre class="ks kt ku kv gt oq or os ot aw ou bi"><span id="eb36" class="of mv it or b gy ov ow l ox oy">model = KMeans(n_clusters=3, random_state=42)<br/>model.fit(customers_normalized)<br/>model.labels_.shape</span></pre><p id="cc3f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">通过拟合模型，我们可以得到每个数据所属的聚类。借此，我们可以分析数据。</p><h2 id="b291" class="of mv it bd mw og oh dn na oi oj dp ne lr ok ol ng lv om on ni lz oo op nk iz bi translated">解释该部分</h2><p id="6b47" class="pw-post-body-paragraph li lj it lk b ll nm kd ln lo nn kg lq lr no lt lu lv np lx ly lz nq mb mc md im bi translated">我们可以根据聚类来总结 RFM 表，并计算每个变量的平均值。代码看起来会像这样，</p><pre class="ks kt ku kv gt oq or os ot aw ou bi"><span id="94a1" class="of mv it or b gy ov ow l ox oy">customers["Cluster"] = model.labels_<br/>customers.groupby('Cluster').agg({<br/>    'Recency':'mean',<br/>    'Frequency':'mean',<br/>    'MonetaryValue':['mean', 'count']}).round(2)</span></pre><p id="4d31" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">代码的输出如下所示，</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qm"><img src="../Images/c953158c6e874b8a93e46a6dd933100b.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/format:webp/1*Bqj_30QK4IxBZGGcT1_dPA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">汇总表</p></figure><p id="32ac" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">除此之外，我们可以使用<strong class="lk jd">蛇情节</strong>来分析片段。它需要标准化数据集和聚类标签。通过使用该图，我们可以很好地从数据中直观地了解集群之间的差异。我们可以通过使用这些代码来绘制图表，</p><pre class="ks kt ku kv gt oq or os ot aw ou bi"><span id="f769" class="of mv it or b gy ov ow l ox oy"><strong class="or jd"># Create the dataframe</strong><br/>df_normalized = pd.DataFrame(customers_normalized, columns=['Recency', 'Frequency', 'MonetaryValue'])<br/>df_normalized['ID'] = customers.index<br/>df_normalized['Cluster'] = model.labels_</span><span id="1719" class="of mv it or b gy oz ow l ox oy"><strong class="or jd"># Melt The Data</strong><br/>df_nor_melt = pd.melt(df_normalized.reset_index(),<br/>                      id_vars=['ID', 'Cluster'],<br/>                      value_vars=['Recency','Frequency','MonetaryValue'],<br/>                      var_name='Attribute',<br/>                      value_name='Value')<br/>df_nor_melt.head()</span><span id="9dc6" class="of mv it or b gy oz ow l ox oy"><strong class="or jd"># Visualize it</strong><br/>sns.lineplot('Attribute', 'Value', hue='Cluster', data=df_nor_melt)</span></pre><p id="08a2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是结果，</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qn"><img src="../Images/7865e8c7eb4634a967098e23ec89e02a.png" data-original-src="https://miro.medium.com/v2/resize:fit:812/format:webp/1*IDtlvUl087RtMHu7wpiKxw.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">蛇的阴谋</p></figure><p id="fff0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">通过使用这个图，我们知道每个部分是如何不同的。它描述的比我们使用的汇总表更多。</p><p id="393f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们推断，集群 0 是经常性的，花费更多，他们最近购买产品。因此，这可能是一群<strong class="lk jd">的忠实客户</strong>。</p><p id="65e4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然后，集群 1 的频率较低，花费较少，但他们最近购买了该产品。因此，它可能是<strong class="lk jd">新客户</strong>的集群。</p><p id="949a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最后，集群 2 的频率更低，花费更少，他们在旧时间购买产品。因此，这可能是一群<strong class="lk jd">被搅动的顾客</strong>。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="c430" class="mu mv it bd mw mx my mz na nb nc nd ne ki nf kj ng kl nh km ni ko nj kp nk nl bi translated">结论</h1><p id="1a9b" class="pw-post-body-paragraph li lj it lk b ll nm kd ln lo nn kg lq lr no lt lu lv np lx ly lz nq mb mc md im bi translated">总之，客户细分对于了解每个客户的特征是非常必要的。本文向您展示了如何使用 Python 实现它。希望这篇文章对你有用，可以落实到你的案例上。</p><p id="02d3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你想知道代码是如何编写的，你可以查看这个谷歌实验室<a class="ae lh" href="https://colab.research.google.com/github/khalidmeister/Customer-Segmentation-using-Python/blob/master/Customer%20Segmentation%20in%20Python.ipynb" rel="noopener ugc nofollow" target="_blank">这里</a>。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h2 id="b87f" class="of mv it bd mw og oh dn na oi oj dp ne lr ok ol ng lv om on ni lz oo op nk iz bi translated">参考</h2><p id="61b2" class="pw-post-body-paragraph li lj it lk b ll nm kd ln lo nn kg lq lr no lt lu lv np lx ly lz nq mb mc md im bi translated">[1] Daqing C .，Sai L.S，和 kung g .<em class="pv">在线零售业的数据挖掘:使用数据挖掘进行基于 RFM 模型的客户细分的案例研究</em> (2012)，数据库营销和客户战略管理杂志<em class="pv">。</em><br/>【2】mill man k . J，Aivazis M. <em class="pv">面向科学家和工程师的 Python</em>(2011)，科学中的计算&amp;工程<em class="pv">。</em><br/>【3】<a class="ae lh" href="https://towardsdatascience.com/@radecicdario?source=post_page-----1334e0debf45----------------------" rel="noopener" target="_blank">rade CII</a><a class="ae lh" href="https://towardsdatascience.com/@radecicdario?source=post_page-----1334e0debf45----------------------" rel="noopener" target="_blank">D</a>。<a class="ae lh" rel="noopener" target="_blank" href="/top-3-methods-for-handling-skewed-data-1334e0debf45"> <em class="pv">处理偏斜数据的 3 大方法</em> </a> <em class="pv"> </em> (2020)，走向数据科学。<br/>【4】<a class="ae lh" href="https://www.geeksforgeeks.org/elbow-method-for-optimal-value-of-k-in-kmeans/" rel="noopener ugc nofollow" target="_blank"><em class="pv">肘法求 k 中最优值 KMeans </em> </a>，极客为极客。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h2 id="8f0a" class="of mv it bd mw og oh dn na oi oj dp ne lr ok ol ng lv om on ni lz oo op nk iz bi translated">感谢您阅读我的文章，您也可以在下面查看我以前的文章:</h2><div class="qo qp gp gr qq qr"><a rel="noopener follow" target="_blank" href="/introduction-to-time-series-analysis-with-r-a2f97650baa3"><div class="qs ab fo"><div class="qt ab qu cl cj qv"><h2 class="bd jd gy z fp qw fr fs qx fu fw jc bi translated">R 时间序列分析导论</h2><div class="qy l"><h3 class="bd b gy z fp qw fr fs qx fu fw dk translated">从探索，到预测。使用印度尼西亚 2002 年 12 月至 2020 年 4 月的消费者价格指数(CPI)数据</h3></div><div class="qz l"><p class="bd b dl z fp qw fr fs qx fu fw dk translated">towardsdatascience.com</p></div></div><div class="ra l"><div class="rb l rc rd re ra rf lb qr"/></div></div></a></div><div class="qo qp gp gr qq qr"><a rel="noopener follow" target="_blank" href="/time-series-forecasting-with-arima-model-in-r-77f4e2ae7abb"><div class="qs ab fo"><div class="qt ab qu cl cj qv"><h2 class="bd jd gy z fp qw fr fs qx fu fw jc bi translated">R 中 ARIMA 模型的时间序列预测</h2><div class="qy l"><h3 class="bd b gy z fp qw fr fs qx fu fw dk translated">从勘探到预测 1970 年至 2015 年的二氧化碳排放数据。</h3></div><div class="qz l"><p class="bd b dl z fp qw fr fs qx fu fw dk translated">towardsdatascience.com</p></div></div><div class="ra l"><div class="rg l rc rd re ra rf lb qr"/></div></div></a></div><div class="qo qp gp gr qq qr"><a rel="noopener follow" target="_blank" href="/data-engineering-for-entrepreneurs-fa10f9190831"><div class="qs ab fo"><div class="qt ab qu cl cj qv"><h2 class="bd jd gy z fp qw fr fs qx fu fw jc bi translated">企业家的数据工程</h2><div class="qy l"><h3 class="bd b gy z fp qw fr fs qx fu fw dk translated">这是一家更加数据驱动的公司。</h3></div><div class="qz l"><p class="bd b dl z fp qw fr fs qx fu fw dk translated">towardsdatascience.com</p></div></div><div class="ra l"><div class="rh l rc rd re ra rf lb qr"/></div></div></a></div></div></div>    
</body>
</html>