<html>
<head>
<title>Asynchronous Parallel Programming in Python with Multiprocessing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">多处理 Python 中的异步并行编程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/asynchronous-parallel-programming-in-python-with-multiprocessing-a3fc882b4023?source=collection_archive---------12-----------------------#2020-06-22">https://towardsdatascience.com/asynchronous-parallel-programming-in-python-with-multiprocessing-a3fc882b4023?source=collection_archive---------12-----------------------#2020-06-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f336" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一种在个人计算机上加速代码的灵活方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/edd5a7fe34fa50080daa86b75cca763d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PXMwLSWN_eZ2v3aj"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">托马斯·索贝克在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="455a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你希望你的 Python 脚本能运行得更快吗？也许他们可以。而且你不会(可能)不得不买一台新电脑，或者使用一台超级电脑。大多数现代计算机都包含多个处理核心，但默认情况下，python 脚本只使用一个核心。编写可以在多个处理器上运行的代码确实可以减少您的处理时间。本文将演示如何使用<code class="fe lv lw lx ly b">multiprocessing</code>模块来编写并行代码，这些代码使用所有机器的处理器并提升脚本的性能。</p><h2 id="5199" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">同步与异步模型</h2><p id="cce3" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">异步模型在新资源可用时立即启动任务，而不等待之前运行的任务完成。相比之下，同步模型在开始任务 2 之前等待任务 1 完成。有关示例的更详细解释，请查看启动中的<a class="ae ky" href="https://medium.com/swlh/understanding-sync-async-concurrency-and-parallelism-166686008fa4" rel="noopener">这篇文章</a>。如果您能够以适当的方式构建代码，异步模型通常会为性能改进提供最大的机会。也就是说，任务可以彼此独立运行。</p><p id="d830" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了简洁起见，本文将只关注异步并行化，因为这是最有可能提升性能的方法。此外，如果您在笔记本电脑上为异步并行化构建代码，那么升级到超级计算机会容易得多。</p><h2 id="fa9e" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">装置</h2><p id="223f" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">由于 Python 2.6 <code class="fe lv lw lx ly b">multiprocessing</code>已经作为基础模块包含，所以不需要安装。简单来说就是<code class="fe lv lw lx ly b">import multiprocessing</code>。因为“多重处理”需要一点时间来打字，所以我更喜欢<code class="fe lv lw lx ly b">import multiprocessing as mp</code>。</p><h2 id="3004" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">问题是</h2><p id="e2e0" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">我们有一组参数值，希望在灵敏度分析中使用。我们运行分析的函数计算量很大。我们可以通过同时并行运行多个参数来减少处理时间。</p><h2 id="b227" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">设置</h2><p id="a83e" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">导入<code class="fe lv lw lx ly b">multiprocessing</code>、<code class="fe lv lw lx ly b">numpy</code>和<code class="fe lv lw lx ly b">time</code>。然后定义一个函数，将行号、<code class="fe lv lw lx ly b">i</code>和三个参数作为输入。行号是必需的，以便以后可以将结果链接到输入参数。记住，异步模型不保持顺序。</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="bc0f" class="lz ma it ly b gy nb nc l nd ne">import multiprocessing as mp<br/>import numpy as np<br/>import time</span><span id="ccb3" class="lz ma it ly b gy nf nc l nd ne">def my_function(i, param1, param2, param3):<br/>    result = param1 ** 2 * param2 + param3<br/>    time.sleep(2)<br/>    return (i, result)</span></pre><p id="c2cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出于演示的目的，这是一个计算开销不大的简单函数。我添加了一行代码来暂停函数 2 秒钟，模拟长时间运行。函数输出对<code class="fe lv lw lx ly b">param1</code>最敏感，对<code class="fe lv lw lx ly b">param3</code>最不敏感。实际上，您可以用任何函数来替换它。</p><p id="d6df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要一个函数，可以将<code class="fe lv lw lx ly b">my_function</code>的结果添加到一个结果列表中，这个函数被创造性地命名为<code class="fe lv lw lx ly b">results</code>。</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="978c" class="lz ma it ly b gy nb nc l nd ne">def get_result(result):<br/>    global results<br/>    results.append(result)</span></pre><p id="dea9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们以串行(非并行)方式运行这段代码，看看需要多长时间。用 0 到 100 之间的 3 列随机数建立一个数组。这些是将被传递给<code class="fe lv lw lx ly b">my_function</code>的参数。然后创建空的<code class="fe lv lw lx ly b">results</code>列表。最后，遍历<code class="fe lv lw lx ly b">params</code>中的所有行，并将<code class="fe lv lw lx ly b">my_function</code>到<code class="fe lv lw lx ly b">results</code>的结果相加。计时，看看需要多长时间(大约 20 秒)，并打印出<code class="fe lv lw lx ly b">results</code>列表。</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="ed90" class="lz ma it ly b gy nb nc l nd ne">if __name__ == '__main__':<br/>    params = np.random.random((10, 3)) * 100.0<br/>    results = []<br/>    ts = time.time()<br/>    for i in range(0, params.shape[0]):<br/>        get_result(my_function(i, params[i, 0], params[i, 1],\<br/>         params[i, 2]))<br/>    print('Time in serial:', time.time() - ts)<br/>    print(results)</span></pre><p id="f584" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如所料，这段代码运行了大约 20 秒。另外，请注意结果是如何按顺序返回的。</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="2052" class="lz ma it ly b gy nb nc l nd ne">Time in serial: 20.006245374679565<br/>[(0, 452994.2250955602), (1, 12318.873058254741), (2, 310577.72144939064), (3, 210071.48540466625), (4, 100467.02727256044), (5, 46553.87276610058), (6, 11396.808561138329), (7, 543909.2528728382), (8, 79957.52205218966), (9, 47914.9078853125)]</span></pre><h2 id="330c" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">并行运行</h2><p id="4712" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">现在使用<code class="fe lv lw lx ly b">multiprocessing</code>并行运行相同的代码。只需将下面的代码直接添加到串行代码的下面进行比较。为清晰起见，本文末尾包含了完整 Python 脚本的要点。</p><p id="f9de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">重置<code class="fe lv lw lx ly b">results</code>列表，使其为空，并重置开始时间。我们需要指定我们想要使用多少个 CPU 进程。<code class="fe lv lw lx ly b">multiprocessing.cpu_count()</code>返回机器可用的全部进程。然后循环遍历<code class="fe lv lw lx ly b">params</code>的每一行，使用<code class="fe lv lw lx ly b">multiprocessing.Pool.apply_async </code>调用<code class="fe lv lw lx ly b">my_function</code>并保存结果。使用<code class="fe lv lw lx ly b">apply_async</code>的<code class="fe lv lw lx ly b">args</code>参数传递<code class="fe lv lw lx ly b">my_function</code>的参数，回调函数是发送<code class="fe lv lw lx ly b">my_function</code>结果的地方。这将在一个新进程可用时立即开始一个新进程，并继续这样做，直到循环完成。然后关闭进程池。等待执行任何后续代码，直到所有进程都运行完毕。现在打印这段代码运行的时间和结果。</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="d133" class="lz ma it ly b gy nb nc l nd ne">results = []<br/>ts = time.time()<br/>pool = mp.Pool(mp.cpu_count())<br/>for i in range(0, params.shape[0]):<br/>    pool.apply_async(my_function, args=(i, params[i, 0], params[i,\<br/>     1], params[i, 2]), callback=get_result)<br/>pool.close()<br/>pool.join()<br/>print('Time in parallel:', time.time() - ts)<br/>print(results)</span></pre><p id="9774" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，使用<code class="fe lv lw lx ly b">apply_async</code>将运行时间从 20 秒减少到 5 秒以下。另外，请注意，结果没有按顺序返回。这就是传递并返回行索引的原因。</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="2ba3" class="lz ma it ly b gy nb nc l nd ne">Time in parallel: 4.749683141708374<br/>[(0, 452994.2250955602), (2, 310577.72144939064), (1, 12318.873058254741), (3, 210071.48540466625), (4, 100467.02727256044), (5, 46553.87276610058), (6, 11396.808561138329), (7, 543909.2528728382), (9, 47914.9078853125), (8, 79957.52205218966)]</span></pre><h2 id="5a35" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">结论</h2><p id="3bd8" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">对代码实现异步并行化可以大大减少运行时间。<code class="fe lv lw lx ly b">multiprocessing</code>模块是在个人计算机上进行并行化的一个很好的选择。正如您在本文中看到的，根据您的机器规格，您可以获得显著的速度提升。如果你最终想升级到超级计算机，请注意<code class="fe lv lw lx ly b">multiprocessing</code>有局限性。如果您的目标是超级计算，那么您会希望使用与消息传递接口(MPI)兼容的并行化模型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure></div></div>    
</body>
</html>