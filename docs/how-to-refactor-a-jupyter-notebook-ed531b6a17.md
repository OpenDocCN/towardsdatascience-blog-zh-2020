# 如何重构 Jupyter 笔记本

> 原文：<https://towardsdatascience.com/how-to-refactor-a-jupyter-notebook-ed531b6a17?source=collection_archive---------31----------------------->

## 现实世界中的 DS

## 使用这些技术改进您的代码库并变得更加高效

![](img/d884a585997ada75cbacf4f6f93532b3.png)

(TL；DR——这张图片总结了整篇文章)

在 ML 世界中，代码会很快变得混乱。

最初令人惊叹的 ML 模型很容易变成一大堆难以理解的代码。修改代码变得痛苦且容易出错，对于 ML 从业者来说，发展他们的 ML 解决方案以满足新的{业务需求、特征工程策略、数据}变得越来越困难。

在这篇文章中，我将与你分享我重构 Jupyter 笔记本的过程，并向你展示我是如何将它从不可维护的状态提升到{可读、测试、可维护}的状态。一旦我们的代码库经过全面测试并且容易理解，**扩展和发展我们的 ML 解决方案就容易多了**。

*注意:如果你不确信需要重构你的 Jupyter 笔记本，看看这篇文章*[](https://www.thoughtworks.com/insights/blog/coding-habits-data-scientists)**👻**

# **1.支持重构的六个准备步骤**

> **重构是改变代码，使其更容易理解和修改，而不改变其可观察到的行为。(转述自[重构](https://www.refactoring.com/) —马丁·福勒)**

**代码并不总是可重构的。**

**很长一段时间以来，我一直盯着我的 Jupyter 笔记本，思考如何让它变得更好。我知道我应该写测试和重构我的代码。但是有一些阻碍我迈出第一步的障碍:(1)担心我可能会破坏一些东西，(2)担心我可能会删除其他人需要的代码，(Jupyter 笔记本中繁琐的重构机制(例如，尝试重命名变量)。**

**在运行了两次重构研讨会之后，我发现了六个启动和加速重构的准备步骤:**

1.  **从头到尾运行笔记本，确保一切正常。**

*   **这将为您省去不必要的麻烦，即必须弄清楚我们是否在重构时破坏了某些东西，或者代码是否已经被破坏了。**

**2.制作原始笔记本的副本。**

*   **这是令人惊讶的重要一步。它将把我们从任何情感依恋中解放出来(“嗯，我不知道，有人可能需要这个图表”)，并允许我们无情地清理任何不必要的代码。**
*   **通过分离这些关注点(即，核心数据转换和表示)，我们可以有两个独立的东西来很好地处理每个关注点，而不是一个巨大的笔记本同时以灾难性的方式处理这两个问题。**

**3.将 Jupyter notebook 转换成普通的 Python 文件。**

*   **这将使您获得使用 IDE 的所有好处(例如，自动完成、智能感知、内联文档、格式化、自动重命名、林挺、键盘快捷键等)。这让你[在重构中更有效率](https://www.youtube.com/watch?v=KUvqDINDzFE&list=PLO9pkowc_99ZhP2yuPU8WCfFNYEx2IkwR&index=6)。**
*   **命令:`jupyter nbconvert —-to script mynotebook.ipynb`**

**4.删除打印报表，如`print(...)`、`df.head()`、`df.plot(...)`**

*   **这消除了噪音和视觉混乱，使下一步变得更加容易。**

**5.看笔记本，列出[代码气味](https://github.com/davified/clean-code-ml)。**

*   **您识别的代码气味列表成为您重构中的待办事项列表(参见[示例](https://github.com/davified/clean-code-ml-exercise/blob/master/notebooks/titanic-notebook-refactoring-starter.ipynb))。这也将为您节省一些精神资源，避免您不断思考下一步要重构什么。**

**6.定义重构边界，并添加一个特征测试。**

*   **一个特征测试将你的程序视为一个黑盒，而*描述*它的行为(例如，我的笔记本输出一个准确率为 68%的模型)并断言该特征(例如，如果我们运行我们的代码，得到一个准确率低于 68%的模型，测试失败)**
*   ****这可以说是👏这👏最👏重要的👏迈步！****
*   **进行特征测试会给你快速的反馈，因为它可以在你重构的时候持续运行。**如果你不小心引入了突破性的变化，它会在几秒钟内告诉你**。**
*   **如果没有特性测试，你将不得不经常手动重启和重新运行整个 Jupyter 笔记本——这很麻烦，对你的流程有很大的破坏性，所以 2019 年。**
*   **这一步有点难以用文字来解释，所以我录制了这个演示[](https://www.youtube.com/watch?v=SVRdF6P5gek&list=PLO9pkowc_99ZhP2yuPU8WCfFNYEx2IkwR&index=4)****来告诉你如何定义重构边界并编写一个特性测试来支持你的重构。******

# ******2.重构周期(耶！)******

******![](img/d884a585997ada75cbacf4f6f93532b3.png)******

******在重构循环中，我们通过(I)添加单元测试和(ii)将复杂的实现细节抽象成模块化和可读的函数，增量地和迭代地改进我们的代码。******

******重构周期如下:******

******1.确定可以提取到纯函数中的代码块(例如，无论何时何地运行，对于给定的输入都返回完全相同的输出的函数)。******

******2.编写一个单元测试。(参见[演示](https://www.youtube.com/watch?v=e8_v2O7CRtE&list=PLO9pkowc_99ZhP2yuPU8WCfFNYEx2IkwR&index=3))******

*   ******在观察模式下运行单元测试:例如`nosetests -—with-watch —-rednose`******
*   ******为代码块编写单元测试******

******3.让测试通过。******

*   ******定义一个新函数，并将其放在一个新的 Python 模块/文件中(或者一个现有的模块/文件，如果您的代码中有合适的模块/文件的话)******
*   ******将现有实现从笔记本移到该功能中******
*   ******让失败的测试通过******

******4.在笔记本中，用新定义的函数替换原来的代码块。******

******5.确保特性测试仍然通过。******

******6.将您的更改提交给 git。******

******现在，如果你觉得你刚刚提取的代码还可以再改进一些，你可以用你的新单元测试的安全网进一步重构它。******

******否则，您可以在 Jupyter 笔记本中的另一个代码块上重复重构周期，并重复直到代码库被全面测试并重构为可读和可维护的状态。******

# ******3.我们费了那么大劲得到了什么？******

******简而言之，你可以从一个[凌乱难读的笔记本](https://github.com/davified/clean-code-ml/blob/master/notebooks/titanic-notebook-0.ipynb)变成一个[经过测试的模块化代码库](https://github.com/davified/clean-code-ml/blob/master/src/train.py)。🎉🎉🎉******

******自动化测试和重构的结合可以极大地帮助我们:******

1.  ********缩短反馈周期**。有了自动化测试，您现在可以立即知道错误和缺陷是如何引入的。如果测试覆盖面是全面的，它还会给你信心，让你知道一切都准备好了，并且节省你手动测试整个 Jupyter 笔记本的时间。******
2.  ********减少浪费**。通过测试和模块化功能，您可以减少花费在以下方面的精力:(I)阅读与您的任务无关的实现细节，(ii)即使我们只想更改一个简单的东西，也要记住整个 Jupyter 笔记本，(iii)修复我们昨天不小心引入的错误，以及(iv)[插入让您连续几个小时盯着笔记本看的东西]。******
3.  ********增加流量**。所有这些意味着您可以专注于手头的任务(例如，集成一组新功能)并交付价值，而不是上面提到的乏味、浪费的任务😎******

******谢谢你读到这里！我希望这对你有所帮助🚀🚀🚀******

******要查看我如何重构 Jupyter 笔记本的实际例子，请查看这个演示！******

*******这是数据科学家的* [*编程习惯*](https://www.youtube.com/watch?v=Edn6XxWmtEs&list=PLO9pkowc_99ZhP2yuPU8WCfFNYEx2IkwR&index=2) *系列教程的一部分，旨在帮助数据科学家通过学习良好的编程习惯变得更有生产力。*******