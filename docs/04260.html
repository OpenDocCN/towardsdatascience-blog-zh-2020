<html>
<head>
<title>53 Python Interview Questions and Answers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">53 Python面试问答</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/53-python-interview-questions-and-answers-91fa311eec3f?source=collection_archive---------0-----------------------#2020-04-18">https://towardsdatascience.com/53-python-interview-questions-and-answers-91fa311eec3f?source=collection_archive---------0-----------------------#2020-04-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="16bd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">面向数据科学家和软件工程师的Python问题</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/dbbff25e5d35ebe60d61cf30c9719f5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bIq13wgS4xuELojLnhsyOw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@brookecagle?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">布鲁克·卡吉尔</a>在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="eecf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不久前，我开始担任“数据科学家”的新角色，实际上是“Python工程师”。</p><p id="6e80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我提前温习Python的线程生命周期而不是推荐系统，我会准备得更充分。</p><p id="49c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本着这种精神，以下是我的python面试/工作准备问答。大多数数据科学家都写了很多代码，所以这对科学家和工程师都适用。</p><p id="e42e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论你是在面试候选人，准备申请工作，还是只是在温习Python，我认为这个列表都是非常宝贵的。</p><p id="6c61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">问题无序。我们开始吧。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="dc1e" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">1.列表和元组有什么区别？</h2><p id="3262" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在我参加的每一次python /数据科学面试中，我都会被问到这个问题。对答案了如指掌。</p><ul class=""><li id="1933" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">列表是可变的。它们可以在创建后进行修改。</li><li id="38ea" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">元组是不可变的。元组一旦创建，就不能更改</li><li id="9a85" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">列表是有顺序的。它们是有序的序列，通常属于同一类型的对象。Ie:按创建日期排序的所有用户名，<code class="fe no np nq nr b">["Seth", "Ema", "Eli"]</code></li><li id="4f79" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">元组有结构。每个索引可能存在不同的数据类型。Ie:内存中的一个数据库记录，<code class="fe no np nq nr b">(2, "Ema", "2020–04–16") # id, name, created_at</code></li></ul><h2 id="3fd6" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">2.字符串插值是如何执行的？</h2><p id="8a6f" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在不导入<code class="fe no np nq nr b">Template</code>类的情况下，有3种方法可以插入字符串。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="2adf" class="mc md it nr b gy nw nx l ny nz">name = 'Chris'</span><span id="e63d" class="mc md it nr b gy oa nx l ny nz"># 1. f strings<br/>print(f'Hello {name}')</span><span id="3341" class="mc md it nr b gy oa nx l ny nz"># 2. % operator<br/>print('Hey %s %s' % (name, name))</span><span id="c097" class="mc md it nr b gy oa nx l ny nz"># 3. format<br/>print(<br/> "My name is {}".format((name))<br/>)</span></pre><h2 id="a979" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">3.“是”和“==”有什么区别？</h2><p id="2ab0" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在我python职业生涯的早期，我认为这些都是一样的…你好，臭虫。因此，根据记录，<code class="fe no np nq nr b">is</code>检查身份，<code class="fe no np nq nr b">==</code>检查平等。</p><p id="4ae3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将浏览一个示例。创建一些列表，并将它们分配给名称。注意<code class="fe no np nq nr b">b</code>与下面的<code class="fe no np nq nr b">a</code>指向同一个对象。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="58fa" class="mc md it nr b gy nw nx l ny nz">a = [1,2,3]<br/>b = a<br/>c = [1,2,3]</span></pre><p id="0511" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">检查等式并注意它们都是相等的。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="d8e0" class="mc md it nr b gy nw nx l ny nz">print(a == b)<br/>print(a == c)<br/>#=&gt; True<br/>#=&gt; True</span></pre><p id="5909" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是他们有相同的身份吗？没有。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="a0de" class="mc md it nr b gy nw nx l ny nz">print(a is b)<br/>print(a is c)<br/>#=&gt; True<br/>#=&gt; False</span></pre><p id="f9e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过打印他们的对象id来验证这一点。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="724e" class="mc md it nr b gy nw nx l ny nz">print(id(a))<br/>print(id(b))<br/>print(id(c))<br/>#=&gt; 4369567560<br/>#=&gt; 4369567560<br/>#=&gt; 4369567624</span></pre><p id="be9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe no np nq nr b">c</code>的<code class="fe no np nq nr b">id</code>与<code class="fe no np nq nr b">a</code>和<code class="fe no np nq nr b">b</code>不同。</p><h2 id="d8fe" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">4.什么是室内设计师？</h2><p id="49f5" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我在每次面试中都会被问到的另一个问题。这本身就值得一贴，但是如果你能写下自己的例子，你就已经准备好了。</p><p id="cf6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">装饰器允许通过将现有函数传递给装饰器来为现有函数添加功能，装饰器执行现有函数和附加代码。</p><p id="f6fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将编写一个装饰器，在调用另一个函数时记录日志。</p><p id="b774" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">编写装饰函数。</strong>这需要一个函数<code class="fe no np nq nr b">func</code>作为参数。它还定义了一个函数<code class="fe no np nq nr b">log_function_called</code>，这个函数调用<code class="fe no np nq nr b">func()</code>并执行一些代码<code class="fe no np nq nr b">print(f'{func} called.')</code>。然后它返回它定义的函数</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="c35b" class="mc md it nr b gy nw nx l ny nz">def logging(func):<br/>  def log_function_called():<br/>    print(f'{func} called.')<br/>    func()<br/>  return log_function_called</span></pre><p id="ab13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们编写最终将添加装饰器的其他函数(但现在还没有)。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="07bc" class="mc md it nr b gy nw nx l ny nz">def my_name():<br/>  print('chris')</span><span id="556b" class="mc md it nr b gy oa nx l ny nz">def friends_name():<br/>  print('naruto')</span><span id="df76" class="mc md it nr b gy oa nx l ny nz">my_name()<br/>friends_name()<br/>#=&gt; chris<br/>#=&gt; naruto</span></pre><p id="693d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在将装饰器添加到两者中。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="fa11" class="mc md it nr b gy nw nx l ny nz"><a class="ae ky" href="http://twitter.com/logging" rel="noopener ugc nofollow" target="_blank">@logging</a><br/>def my_name():<br/> print('chris')</span><span id="15a8" class="mc md it nr b gy oa nx l ny nz"><a class="ae ky" href="http://twitter.com/logging" rel="noopener ugc nofollow" target="_blank">@logging</a><br/>def friends_name():<br/> print('naruto')</span><span id="66d3" class="mc md it nr b gy oa nx l ny nz">my_name()<br/>friends_name()<br/>#=&gt; &lt;function my_name at 0x10fca5a60&gt; called.<br/>#=&gt; chris<br/>#=&gt; &lt;function friends_name at 0x10fca5f28&gt; called.<br/>#=&gt; naruto</span></pre><p id="b780" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看看我们现在如何通过在上面添加<code class="fe no np nq nr b">@logging</code>来轻松地将日志添加到我们编写的任何函数中。</p><h2 id="64e5" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">5.解释范围函数</h2><p id="7521" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">Range生成一个整数列表，有3种方法可以使用它。</p><p id="7b65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该函数有1到3个参数。注意，我将每种用法都包装在列表理解中，这样我们就可以看到生成的值。</p><p id="129e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe no np nq nr b"><strong class="lb iu">range(stop)</strong></code> <strong class="lb iu"> : </strong>生成从0到“停止”整数的整数。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="e077" class="mc md it nr b gy nw nx l ny nz">[i for i in range(10)]<br/>#=&gt; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></pre><p id="84c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe no np nq nr b"><strong class="lb iu">range(start, stop)</strong></code> <strong class="lb iu"> : </strong>生成从“开始”到“停止”的整数。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="ef58" class="mc md it nr b gy nw nx l ny nz">[i for i in range(2,10)]<br/>#=&gt; [2, 3, 4, 5, 6, 7, 8, 9]</span></pre><p id="66c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe no np nq nr b"><strong class="lb iu">range(start, stop, step)</strong></code> <strong class="lb iu"> : </strong>以“步”为间隔，从“开始”到“停止”生成整数。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="2091" class="mc md it nr b gy nw nx l ny nz">[i for i in range(2,10,2)]<br/>#=&gt; [2, 4, 6, 8]</span></pre><p id="82e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢塞尔格·博瑞姆丘克建议了一种更pythonic化的方式来做这件事！</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="6e18" class="mc md it nr b gy nw nx l ny nz">list(range(2,10,2))<br/>#=&gt; [2, 4, 6, 8]</span></pre><h2 id="bb26" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">6.定义一个名为car的类，它有两个属性，“颜色”和“速度”。然后创建一个实例，返回速度。</h2><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="25e2" class="mc md it nr b gy nw nx l ny nz">class Car :<br/>    def __init__(self, color, speed):<br/>        self.color = color<br/>        self.speed = speed</span><span id="a286" class="mc md it nr b gy oa nx l ny nz">car = Car('red','100mph')<br/>car.speed<br/>#=&gt; '100mph'</span></pre><h2 id="a893" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">7.python中的实例、静态和类方法有什么区别？</h2><p id="0069" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><strong class="lb iu">实例方法:</strong>接受<code class="fe no np nq nr b">self</code>参数，并关联到类的一个特定实例。</p><p id="e033" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">静态方法:</strong>使用<code class="fe no np nq nr b">@staticmethod</code>装饰器，与特定实例无关，并且是独立的(不要修改类或实例属性)</p><p id="87bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">类方法:</strong>接受<code class="fe no np nq nr b">cls</code>参数并可以修改类本身</p><p id="b789" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将围绕一个虚构的<code class="fe no np nq nr b">CoffeeShop</code>类来说明这种差异。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="24ca" class="mc md it nr b gy nw nx l ny nz">class CoffeeShop:<br/>    specialty = 'espresso'<br/>    <br/>    def __init__(self, coffee_price):<br/>        self.coffee_price = coffee_price<br/>    <br/>    # instance method<br/>    def make_coffee(self):<br/>        print(f'Making {self.specialty} for ${self.coffee_price}')<br/>    <br/>    # static method    <br/>    <a class="ae ky" href="http://twitter.com/staticmethod" rel="noopener ugc nofollow" target="_blank">@staticmethod</a><br/>    def check_weather():<br/>        print('Its sunny')</span><span id="0df3" class="mc md it nr b gy oa nx l ny nz">    # class method<br/>    <a class="ae ky" href="http://twitter.com/classmethod" rel="noopener ugc nofollow" target="_blank">@classmethod</a><br/>    def change_specialty(cls, specialty):<br/>        cls.specialty = specialty<br/>        print(f'Specialty changed to {specialty}')</span></pre><p id="266f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe no np nq nr b">CoffeeShop</code>类有一个属性<code class="fe no np nq nr b">specialty</code>，默认设置为<code class="fe no np nq nr b">'espresso'</code>。<code class="fe no np nq nr b">CoffeeShop</code>的每个实例都用属性<code class="fe no np nq nr b">coffee_price</code>初始化。它也有3个方法，一个实例方法，一个静态方法和一个类方法。</p><p id="2815" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用<code class="fe no np nq nr b">5</code>的<code class="fe no np nq nr b">coffee_price</code>初始化咖啡店的一个实例。然后调用实例方法<code class="fe no np nq nr b">make_coffee</code>。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="11e9" class="mc md it nr b gy nw nx l ny nz">coffee_shop = CoffeeShop('5')<br/>coffee_shop.make_coffee()<br/>#=&gt; Making espresso for $5</span></pre><p id="f9db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在调用静态方法。静态方法不能修改类或实例状态，所以它们通常用于实用函数，例如，将两个数相加。我们用我们的来查天气。<code class="fe no np nq nr b">Its sunny</code>。太好了！</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="bd5a" class="mc md it nr b gy nw nx l ny nz">coffee_shop.check_weather()<br/>#=&gt; Its sunny</span></pre><p id="c79a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们用类的方法修改咖啡店的特产然后<code class="fe no np nq nr b">make_coffee</code>。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="3f23" class="mc md it nr b gy nw nx l ny nz">coffee_shop.change_specialty('drip coffee')<br/>#=&gt; Specialty changed to drip coffee</span><span id="fc4c" class="mc md it nr b gy oa nx l ny nz">coffee_shop.make_coffee()<br/>#=&gt; Making drip coffee for $5</span></pre><p id="02c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意<code class="fe no np nq nr b">make_coffee</code>以前是怎么做<code class="fe no np nq nr b">espresso</code>的，现在是怎么做<code class="fe no np nq nr b">drip coffee</code>的！</p><h2 id="a8a3" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">8.「func」和「func()」有什么区别？</h2><p id="2013" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">这个问题的目的是看你是否明白python中所有的函数也是对象。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="9f0b" class="mc md it nr b gy nw nx l ny nz">def func():<br/>    print('Im a function')<br/>    <br/>func<br/>#=&gt; function __main__.func&gt;</span><span id="5e8a" class="mc md it nr b gy oa nx l ny nz">func()    <br/>#=&gt; Im a function</span></pre><p id="baab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe no np nq nr b">func</code>是代表函数的对象，该函数可被赋给一个变量或传递给另一个函数。<code class="fe no np nq nr b">func()</code>用括号调用函数并返回它输出的内容。</p><h2 id="987c" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">9.解释地图功能的工作原理</h2><p id="c610" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><code class="fe no np nq nr b">map</code>返回一个映射对象(一个迭代器),它可以对序列中的每个元素应用一个函数而返回的值进行迭代。如果需要，地图对象也可以转换为列表。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="318b" class="mc md it nr b gy nw nx l ny nz">def add_three(x):<br/>    return x + 3</span><span id="09f0" class="mc md it nr b gy oa nx l ny nz">li = [1,2,3]</span><span id="c0fe" class="mc md it nr b gy oa nx l ny nz">[i for i in map(add_three, li)]<br/>#=&gt; [4, 5, 6]</span></pre><p id="b407" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面，我给列表中的每个元素加了3。</p><p id="54ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一位读者建议了一个更pythonic化的实现。感谢<a class="ob oc ep" href="https://medium.com/u/b3236beb43a6?source=post_page-----91fa311eec3f--------------------------------" rel="noopener" target="_blank">克里斯扬·伍斯特</a>！</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="fb09" class="mc md it nr b gy nw nx l ny nz">def add_three(x):<br/>    return x + 3</span><span id="e04f" class="mc md it nr b gy oa nx l ny nz">li = [1,2,3]<br/>list(map(add_three, li))<br/>#=&gt; [4, 5, 6]</span></pre><p id="5d72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，感谢<a class="ob oc ep" href="https://medium.com/u/a582f1392208?source=post_page-----91fa311eec3f--------------------------------" rel="noopener" target="_blank">迈克尔格雷姆肖特</a>的更正！</p><h2 id="1721" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">10.解释reduce函数的工作原理</h2><p id="4e69" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">这可能会很棘手，直到你使用它几次。</p><p id="7b73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe no np nq nr b">reduce</code>接受一个函数和一个序列，并对该序列进行迭代。在每次迭代中，当前元素和前一个元素的输出都被传递给函数。最后，返回一个值。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="aae6" class="mc md it nr b gy nw nx l ny nz">from functools import reduce</span><span id="deb2" class="mc md it nr b gy oa nx l ny nz">def add_three(x,y):<br/>    return x + y</span><span id="fe79" class="mc md it nr b gy oa nx l ny nz">li = [1,2,3,5]</span><span id="370b" class="mc md it nr b gy oa nx l ny nz">reduce(add_three, li)<br/>#=&gt; 11</span></pre><p id="e0e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">返回<code class="fe no np nq nr b">11</code>，它是<code class="fe no np nq nr b">1+2+3+5</code>的和。</p><h2 id="105a" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">11.解释过滤函数的工作原理</h2><p id="2a66" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">Filter确实如其名。它过滤序列中的元素。</p><p id="b800" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个元素被传递给一个函数，如果该函数返回<code class="fe no np nq nr b">True</code>，则该函数以输出序列返回，如果该函数返回<code class="fe no np nq nr b">False</code>，则该元素被丢弃。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="1eb4" class="mc md it nr b gy nw nx l ny nz">def add_three(x):<br/>    if x % 2 == 0:<br/>        return True        <br/>    else:<br/>        return False</span><span id="f195" class="mc md it nr b gy oa nx l ny nz">li = [1,2,3,4,5,6,7,8]</span><span id="163f" class="mc md it nr b gy oa nx l ny nz">[i for i in filter(add_three, li)]<br/>#=&gt; [2, 4, 6, 8]</span></pre><p id="4ae4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意所有不能被2整除的元素是如何被删除的。</p><h2 id="4475" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">12.python是按引用调用还是按值调用？</h2><p id="aa0c" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">如果你在谷歌上搜索这个问题并阅读了上面的几页，就要做好陷入语义陷阱的准备。</p><p id="e7ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之，所有的名字都是通过引用来调用的，但是一些内存位置保存对象，而另一些保存指向其他内存位置的指针。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="7fe5" class="mc md it nr b gy nw nx l ny nz">name = 'object'</span></pre><p id="77ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看这是如何处理字符串的。我们将实例化一个名称和对象，将其他名称指向它。然后删除名字。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="7e93" class="mc md it nr b gy nw nx l ny nz">x = 'some text'<br/>y = x<br/>x is y #=&gt; True</span><span id="5e4a" class="mc md it nr b gy oa nx l ny nz">del x # this deletes the 'a' name but does nothing to the object in memory</span><span id="783a" class="mc md it nr b gy oa nx l ny nz">z = y<br/>y is z #=&gt; True</span></pre><p id="d2be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到的是，所有这些名字都指向内存中的同一个对象，它不受<code class="fe no np nq nr b">del x</code>的影响。</p><p id="4469" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是另一个有趣的函数例子。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="f76f" class="mc md it nr b gy nw nx l ny nz">name = 'text'</span><span id="efb4" class="mc md it nr b gy oa nx l ny nz">def add_chars(str1):<br/>    print( id(str1) ) #=&gt; 4353702856<br/>    print( id(name) ) #=&gt; 4353702856<br/>    <br/>    # new name, same object<br/>    str2 = str1<br/>    <br/>    # creates a new name (with same name as the first) AND object<br/>    str1 += 's' <br/>    print( id(str1) ) #=&gt; 4387143328<br/>    <br/>    # still the original object<br/>    print( id(str2) ) #=&gt; 4353702856<br/>    <br/>    <br/>add_chars(name)<br/>print(name) #=&gt;text</span></pre><p id="aed5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意在函数内部的字符串中添加一个<code class="fe no np nq nr b">s</code>是如何创建一个新名称和一个新对象的。即使新名称与现有名称具有相同的“名称”。</p><p id="36c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢<a class="ob oc ep" href="https://medium.com/u/e0fac81c6192?source=post_page-----91fa311eec3f--------------------------------" rel="noopener" target="_blank">迈克尔·p·雷利</a>的指正！</p><h2 id="5c35" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">13.如何反转一个列表？</h2><p id="a392" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">请注意<code class="fe no np nq nr b">reverse()</code>是如何在列表上被调用并对其进行变异的。它不会返回变异后的列表本身。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="9843" class="mc md it nr b gy nw nx l ny nz">li = ['a','b','c']</span><span id="1849" class="mc md it nr b gy oa nx l ny nz">print(li)<br/>li.reverse()<br/>print(li)<br/>#=&gt; ['a', 'b', 'c']<br/>#=&gt; ['c', 'b', 'a']</span></pre><h2 id="578f" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">14.字符串乘法是如何工作的？</h2><p id="e5b8" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我们来看看字符串<code class="fe no np nq nr b">‘cat’</code>乘以3的结果。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="7f5b" class="mc md it nr b gy nw nx l ny nz">'cat' * 3<br/>#=&gt; 'catcatcat'</span></pre><p id="9c65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该字符串自身连接了三次。</p><h2 id="f94a" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">15.列表乘法是如何工作的？</h2><p id="261d" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">让我们看看一个列表<code class="fe no np nq nr b">[1,2,3]</code>乘以2的结果。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="1886" class="mc md it nr b gy nw nx l ny nz">[1,2,3] * 2<br/>#=&gt; [1, 2, 3, 1, 2, 3]</span></pre><p id="cc24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出包含重复两次的[1，2，3]的内容的列表。</p><h2 id="3991" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">16.一个班里的“自己”指的是什么？</h2><p id="1d10" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">Self指的是类本身的实例。这就是我们如何给予方法访问和更新它们所属对象的能力。</p><p id="4ca7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面，将self传递给<code class="fe no np nq nr b">__init__()</code>使我们能够在初始化时设置实例的<code class="fe no np nq nr b">color</code>。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="1778" class="mc md it nr b gy nw nx l ny nz">class Shirt:<br/>    def __init__(self, color):<br/>        self.color = color<br/>        <br/>s = Shirt('yellow')<br/>s.color<br/>#=&gt; 'yellow'</span></pre><h2 id="88a6" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">17.如何在python中连接列表？</h2><p id="f3ed" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">将两个列表相加会将它们连接起来。请注意，数组的工作方式不同。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="c7d3" class="mc md it nr b gy nw nx l ny nz">a = [1,2]<br/>b = [3,4,5]</span><span id="342b" class="mc md it nr b gy oa nx l ny nz">a + b<br/>#=&gt; [1, 2, 3, 4, 5]</span></pre><h2 id="0836" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">18.浅拷贝和深拷贝有什么区别？</h2><p id="d225" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我们将在一个可变对象(列表)的上下文中讨论这个问题。对于不可变的对象，浅和深并不相关。</p><p id="6090" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将经历3个场景。</p><p id="1879" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> i)引用原始对象。</strong>这个新名字<code class="fe no np nq nr b">li2</code>指向内存中<code class="fe no np nq nr b">li1</code>指向的相同位置。所以我们对<code class="fe no np nq nr b">li1</code>所做的任何改变也会发生在<code class="fe no np nq nr b">li2</code>上。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="5ecb" class="mc md it nr b gy nw nx l ny nz">li1 = [['a'],['b'],['c']]<br/>li2 = li1</span><span id="55a9" class="mc md it nr b gy oa nx l ny nz">li1.append(['d'])<br/>print(li2)<br/>#=&gt; [['a'], ['b'], ['c'], ['d']]</span></pre><p id="60ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> ii)创建原始文件的浅拷贝。</strong>我们可以用<code class="fe no np nq nr b">list()</code>构造函数，或者更pythonic化的<code class="fe no np nq nr b">mylist.copy()</code>(感谢<a class="ob oc ep" href="https://medium.com/u/b3236beb43a6?source=post_page-----91fa311eec3f--------------------------------" rel="noopener" target="_blank"> Chrisjan Wust </a>！).</p><p id="bec9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">浅表副本创建一个新对象，但用对原始对象的引用填充它。所以向原始集合添加一个新对象<code class="fe no np nq nr b">li3</code>，不会传播到<code class="fe no np nq nr b">li4</code>，但是修改<code class="fe no np nq nr b">li3</code>中的一个对象会传播到<code class="fe no np nq nr b">li4</code>。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="8c49" class="mc md it nr b gy nw nx l ny nz">li3 = [['a'],['b'],['c']]<br/>li4 = list(li3)</span><span id="54ea" class="mc md it nr b gy oa nx l ny nz">li3.append([4])<br/>print(li4)<br/>#=&gt; [['a'], ['b'], ['c']]</span><span id="71d7" class="mc md it nr b gy oa nx l ny nz">li3[0][0] = ['X']<br/>print(li4)<br/>#=&gt; [[['X']], ['b'], ['c']]</span></pre><p id="9e41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> iii)创建深层副本。</strong>这是通过<code class="fe no np nq nr b">copy.deepcopy()</code>完成的。这两个对象现在完全独立，对其中一个对象的更改不会影响另一个对象。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="aa33" class="mc md it nr b gy nw nx l ny nz">import copy</span><span id="9a39" class="mc md it nr b gy oa nx l ny nz">li5 = [['a'],['b'],['c']]<br/>li6 = copy.deepcopy(li5)</span><span id="e26d" class="mc md it nr b gy oa nx l ny nz">li5.append([4])<br/>li5[0][0] = ['X']<br/>print(li6)<br/>#=&gt; [['a'], ['b'], ['c']]</span></pre><h2 id="d3af" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">19.列表和数组有什么区别？</h2><p id="12dd" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><em class="od">注意:Python的标准库有一个数组对象，但这里我特指常用的Numpy数组。</em></p><ul class=""><li id="072f" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">列表存在于python的标准库中。数组由Numpy定义。</li><li id="4fa5" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">列表可以在每个索引处填充不同类型的数据。数组需要同质元素。</li><li id="c73b" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">列表算术在列表中添加或删除元素。每个线性代数上的数组函数的算术。</li><li id="72a8" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">阵列还使用更少的内存，并提供更多的功能。</li></ul><p id="4aba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我写了另一篇关于数组的综合文章。</p><h2 id="3eba" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">20.如何连接两个数组？</h2><p id="4661" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">记住，数组不是列表。数组来自Numpy和算术函数，如线性代数。</p><p id="c045" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要使用Numpy的concatenate函数来实现。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="6006" class="mc md it nr b gy nw nx l ny nz">import numpy as np</span><span id="d67f" class="mc md it nr b gy oa nx l ny nz">a = np.array([1,2,3])<br/>b = np.array([4,5,6])</span><span id="71b1" class="mc md it nr b gy oa nx l ny nz">np.concatenate((a,b))<br/>#=&gt; array([1, 2, 3, 4, 5, 6])</span></pre><h2 id="04e6" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">21.你喜欢Python的什么？</h2><p id="169d" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><em class="od">请注意，这是一个非常主观的问题，你需要根据角色的需求来修改你的回答。</em></p><p id="1545" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python可读性很强，几乎所有事情都有python式的方法，这意味着这是一种清晰简洁的首选方法。</p><p id="6d56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将此与Ruby进行对比，在Ruby中，通常有许多方法来做某件事，但没有哪种方法更好的指导原则。</p><h2 id="e16e" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">22.你最喜欢的Python库是什么？</h2><p id="dc05" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><em class="od">亦主观，见问题21。</em></p><p id="e865" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当处理大量数据时，没有什么比pandas更有用了，它使处理和可视化数据变得轻而易举。</p><h2 id="707a" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">23.命名可变和不可变对象</h2><p id="4e11" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">不可变意味着状态在创建后不能修改。例如:int、float、bool、string和tuple。</p><p id="df95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可变意味着状态在创建后可以修改。例子有列表、字典和集合。</p><h2 id="cb7a" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">24.你如何将一个数字四舍五入到小数点后三位？</h2><p id="104b" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">使用<code class="fe no np nq nr b">round(value, decimal_places)</code>功能。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="b006" class="mc md it nr b gy nw nx l ny nz">a = 5.12345<br/>round(a,3)<br/>#=&gt; 5.123</span></pre><h2 id="8d00" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">25.你如何分割一个列表？</h2><p id="e21f" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">切片表示法有3个参数，<code class="fe no np nq nr b">list[start:stop:step]</code>，其中step是返回元素的间隔。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="f84c" class="mc md it nr b gy nw nx l ny nz">a = [0,1,2,3,4,5,6,7,8,9]</span><span id="73a6" class="mc md it nr b gy oa nx l ny nz">print(a[:2])<br/>#=&gt; [0, 1]</span><span id="8479" class="mc md it nr b gy oa nx l ny nz">print(a[8:])<br/>#=&gt; [8, 9]</span><span id="ce5b" class="mc md it nr b gy oa nx l ny nz">print(a[2:8])<br/>#=&gt; [2, 3, 4, 5, 6, 7]</span><span id="bea2" class="mc md it nr b gy oa nx l ny nz">print(a[2:8:2])<br/>#=&gt; [2, 4, 6]</span></pre><h2 id="5bee" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">26.什么是腌制？</h2><p id="6d87" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">Pickling是Python中序列化和反序列化对象的常用方法。</p><p id="6df8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的例子中，我们序列化和反序列化一个字典列表。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="8af1" class="mc md it nr b gy nw nx l ny nz">import pickle</span><span id="1c19" class="mc md it nr b gy oa nx l ny nz">obj = [<br/>    {'id':1, 'name':'Stuffy'},<br/>    {'id':2, 'name': 'Fluffy'}<br/>]</span><span id="c3a7" class="mc md it nr b gy oa nx l ny nz">with open('file.p', 'wb') as f:<br/>    pickle.dump(obj, f)</span><span id="1c87" class="mc md it nr b gy oa nx l ny nz">with open('file.p', 'rb') as f:<br/>    loaded_obj = pickle.load(f)</span><span id="28db" class="mc md it nr b gy oa nx l ny nz">print(loaded_obj)<br/>#=&gt; [{'id': 1, 'name': 'Stuffy'}, {'id': 2, 'name': 'Fluffy'}]</span></pre><h2 id="f6d8" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">27.字典和JSON有什么区别？</h2><p id="f050" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">Dict是python数据类型，是一个索引但无序的键和值的集合。</p><p id="eba3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JSON只是一个遵循特定格式的字符串，用于传输数据。</p><h2 id="4026" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">28.你在Python中用过哪些ORM？</h2><p id="5250" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">ORMs(对象关系映射)将数据模型(通常在应用程序中)映射到数据库表，并简化数据库事务。</p><p id="d36b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SQLAlchemy通常用在Flask的上下文中，Django有自己的ORM。</p><h2 id="2f88" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">29.any()和all()是如何工作的？</h2><p id="87dd" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><strong class="lb iu"> Any </strong>接受一个序列，如果序列中的任何元素为真，则返回真。</p><p id="ddac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> All </strong>仅当序列中的所有元素都为真时返回真。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="66be" class="mc md it nr b gy nw nx l ny nz">a = [False, False, False]<br/>b = [True, False, False]<br/>c = [True, True, True]</span><span id="c6dd" class="mc md it nr b gy oa nx l ny nz">print( any(a) )<br/>print( any(b) )<br/>print( any(c) )<br/>#=&gt; False<br/>#=&gt; True<br/>#=&gt; True</span><span id="10d2" class="mc md it nr b gy oa nx l ny nz">print( all(a) )<br/>print( all(b) )<br/>print( all(c) )<br/>#=&gt; False<br/>#=&gt; False<br/>#=&gt; True</span></pre><h2 id="1d68" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">30.字典或列表查找更快吗？</h2><p id="2c0c" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在列表中查找一个值需要O(n)时间，因为需要遍历整个列表直到找到该值。</p><p id="f244" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在字典中查找一个键需要O(1)时间，因为它是一个散列表。</p><p id="23f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果有很多值，这会造成很大的时间差，因此为了加快速度，通常建议使用字典。但是它们也有其他的限制，比如需要唯一的键。</p><h2 id="c78b" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">31.模块和包的区别是什么？</h2><p id="5d39" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">模块是可以一起导入的文件(或文件集合)。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="a5ba" class="mc md it nr b gy nw nx l ny nz">import sklearn</span></pre><p id="d3ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">包是模块的目录。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="a90d" class="mc md it nr b gy nw nx l ny nz">from sklearn import cross_validation</span></pre><p id="76e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以包是模块，但不是所有的模块都是包。</p><h2 id="fdcc" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">32.Python中如何对一个整数进行加减运算？</h2><p id="ef97" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">可以用<code class="fe no np nq nr b">+-</code>和<code class="fe no np nq nr b">-=</code>来增加和减少。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="60ee" class="mc md it nr b gy nw nx l ny nz">value = 5</span><span id="8cbd" class="mc md it nr b gy oa nx l ny nz">value += 1<br/>print(value)<br/>#=&gt; 6</span><span id="2e42" class="mc md it nr b gy oa nx l ny nz">value -= 1<br/>value -= 1<br/>print(value)<br/>#=&gt; 4</span></pre><h2 id="c78e" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">33.如何返回整数的二进制？</h2><p id="45ab" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">使用<code class="fe no np nq nr b">bin()</code>功能。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="6ddf" class="mc md it nr b gy nw nx l ny nz">bin(5)<br/>#=&gt; '0b101'</span></pre><h2 id="ddd1" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">34.如何从列表中删除重复的元素？</h2><p id="7485" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">这可以通过将列表转换成集合，然后再转换回列表来实现。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="84f4" class="mc md it nr b gy nw nx l ny nz">a = [1,1,1,2,3]<br/>a = list(set(a))<br/>print(a)<br/>#=&gt; [1, 2, 3]</span></pre><p id="7af2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="od">注意，集合不一定保持列表的顺序。</em></p><h2 id="90fe" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">35.如何检查列表中是否有值？</h2><p id="ca10" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">使用<code class="fe no np nq nr b">in</code>。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="1fcb" class="mc md it nr b gy nw nx l ny nz">'a' in ['a','b','c']<br/>#=&gt; True</span><span id="5875" class="mc md it nr b gy oa nx l ny nz">'a' in [1,2,3]<br/>#=&gt; False</span></pre><h2 id="0a0f" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">36.追加和扩展有什么区别？</h2><p id="1027" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><code class="fe no np nq nr b">append</code>将一个值添加到一个列表，而<code class="fe no np nq nr b">extend</code>将另一个列表中的值添加到一个列表。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="3643" class="mc md it nr b gy nw nx l ny nz">a = [1,2,3]<br/>b = [1,2,3]</span><span id="67b7" class="mc md it nr b gy oa nx l ny nz">a.append(6)<br/>print(a)<br/>#=&gt; [1, 2, 3, 6]</span><span id="88f9" class="mc md it nr b gy oa nx l ny nz">b.extend([4,5])<br/>print(b)<br/>#=&gt; [1, 2, 3, 4, 5]</span></pre><h2 id="f9e8" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">37.如何取整数的绝对值？</h2><p id="fc40" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">这可以通过<code class="fe no np nq nr b">abs()</code>功能完成。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="5e0d" class="mc md it nr b gy nw nx l ny nz">abs(2)<br/>#=&gt; 2</span><span id="c179" class="mc md it nr b gy oa nx l ny nz">abs(-2)<br/>#=&gt; 2</span></pre><h2 id="c84f" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">38.如何将两个列表合并成一个元组列表？</h2><p id="518e" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">您可以使用<code class="fe no np nq nr b">zip</code>函数将列表组合成一个元组列表。这并不局限于只使用两个列表。也可以用3个或更多。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="ad38" class="mc md it nr b gy nw nx l ny nz">a = ['a','b','c']<br/>b = [1,2,3]</span><span id="b095" class="mc md it nr b gy oa nx l ny nz">[(k,v) for k,v in zip(a,b)]<br/>#=&gt; [('a', 1), ('b', 2), ('c', 3)]</span></pre><h2 id="474d" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">39.你如何按字母顺序按关键字给字典排序？</h2><p id="35b2" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">您不能“排序”字典，因为字典没有顺序，但是您可以返回一个排序的元组列表，其中包含字典中的键和值。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="1dd4" class="mc md it nr b gy nw nx l ny nz">d = {'c':3, 'd':4, 'b':2, 'a':1}</span><span id="bf0a" class="mc md it nr b gy oa nx l ny nz">sorted(d.items())<br/>#=&gt; [('a', 1), ('b', 2), ('c', 3), ('d', 4)]</span></pre><h2 id="c86d" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">40.Python中一个类如何继承另一个类？</h2><p id="0e31" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在下面的例子中，<code class="fe no np nq nr b">Audi</code>继承自<code class="fe no np nq nr b">Car</code>。随着这种继承而来的是父类的实例方法。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="223a" class="mc md it nr b gy nw nx l ny nz">class Car():<br/>    def drive(self):<br/>        print('vroom')</span><span id="7b09" class="mc md it nr b gy oa nx l ny nz">class Audi(Car):<br/>    pass</span><span id="c0e9" class="mc md it nr b gy oa nx l ny nz">audi = Audi()<br/>audi.drive()</span></pre><h2 id="cece" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">41.如何从字符串中删除所有空格？</h2><p id="3c05" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">最简单的方法是用空格分割字符串，然后不用空格重新连接。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="235f" class="mc md it nr b gy nw nx l ny nz">s = 'A string with     white space'</span><span id="5865" class="mc md it nr b gy oa nx l ny nz">''.join(s.split())<br/>#=&gt; 'Astringwithwhitespace'</span></pre><p id="0267" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2读者推荐了一种更Python化的方式来处理这个问题，这种方式遵循了<code class="fe no np nq nr b">Explicit is better than Implicit</code>的Python精神。它也更快，因为python不创建新的列表对象。感谢евгенийкрамаров和<a class="ob oc ep" href="https://medium.com/u/b3236beb43a6?source=post_page-----91fa311eec3f--------------------------------" rel="noopener" target="_blank"> Chrisjan Wust </a>！</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="f74a" class="mc md it nr b gy nw nx l ny nz">s = 'A string with     white space'<br/>s.replace(' ', '')<br/>#=&gt; 'Astringwithwhitespace'</span></pre><h2 id="e019" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">42.为什么在对序列进行迭代时要使用enumerate()。</h2><p id="1036" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><code class="fe no np nq nr b">enumerate()</code>迭代序列时允许跟踪索引。这比定义和递增一个表示索引的整数更有技巧。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="e235" class="mc md it nr b gy nw nx l ny nz">li = ['a','b','c','d','e']</span><span id="a7e3" class="mc md it nr b gy oa nx l ny nz">for idx,val in enumerate(li):<br/>    print(idx, val)<br/>#=&gt; 0 a<br/>#=&gt; 1 b<br/>#=&gt; 2 c<br/>#=&gt; 3 d<br/>#=&gt; 4 e</span></pre><h2 id="4f7e" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">43.传球、继续、突破有什么区别？</h2><p id="73e3" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><code class="fe no np nq nr b">pass</code>指无所事事。我们通常使用它，因为Python不允许在没有代码的情况下创建类、函数或if语句。</p><p id="260a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的例子中，如果在<code class="fe no np nq nr b">i &gt; 3</code>中没有代码，将会抛出一个错误，所以我们使用<code class="fe no np nq nr b">pass</code>。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="b2dc" class="mc md it nr b gy nw nx l ny nz">a = [1,2,3,4,5]</span><span id="fd65" class="mc md it nr b gy oa nx l ny nz">for i in a:<br/>    if i &gt; 3:<br/>        pass<br/>    print(i)<br/>#=&gt; 1<br/>#=&gt; 2<br/>#=&gt; 3<br/>#=&gt; 4<br/>#=&gt; 5</span></pre><p id="e250" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe no np nq nr b">continue</code>继续执行下一个元素，并停止执行当前元素。所以对于<code class="fe no np nq nr b">i &lt; 3</code>处的值，永远不会达到<code class="fe no np nq nr b">print(i)</code>。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="8877" class="mc md it nr b gy nw nx l ny nz">for i in a:<br/>    if i &lt; 3:<br/>        continue<br/>    print(i)<br/>#=&gt; 3<br/>#=&gt; 4<br/>#=&gt; 5</span></pre><p id="0982" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe no np nq nr b">break</code>中断循环，序列不再迭代。因此不打印从3开始的元素。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="852b" class="mc md it nr b gy nw nx l ny nz">for i in a:<br/>    if i == 3:<br/>        break<br/>    print(i)    <br/>#=&gt; 1<br/>#=&gt; 2</span></pre><h2 id="8e27" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">44.将下面的for循环转换成列表理解。</h2><p id="0ef7" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">这个<code class="fe no np nq nr b">for</code>循环。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="5f4d" class="mc md it nr b gy nw nx l ny nz">a = [1,2,3,4,5]<br/> <br/>a2 = []<br/>for i in a:<br/>     a2.append(i + 1)</span><span id="c1f1" class="mc md it nr b gy oa nx l ny nz">print(a2)<br/>#=&gt; [2, 3, 4, 5, 6]</span></pre><p id="1b86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">变成了。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="a33e" class="mc md it nr b gy nw nx l ny nz">a3 = [i+1 for i in a]</span><span id="5f65" class="mc md it nr b gy oa nx l ny nz">print(a3)<br/>#=&gt; [2, 3, 4, 5, 6]</span></pre><p id="389d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">列表理解通常被认为是更pythonic化的，因为它仍然是可读的。</p><h2 id="221f" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">45.举一个三元运算符的例子。</h2><p id="a6fe" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">三元运算符是一行if/else语句。</p><p id="d268" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">语法看起来像<code class="fe no np nq nr b">a if condition else b</code>。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="a45b" class="mc md it nr b gy nw nx l ny nz">x = 5<br/>y = 10</span><span id="2f1d" class="mc md it nr b gy oa nx l ny nz">'greater' if x &gt; 6 else 'less'<br/>#=&gt; 'less'</span><span id="3e80" class="mc md it nr b gy oa nx l ny nz">'greater' if y &gt; 6 else 'less'<br/>#=&gt; 'greater'</span></pre><h2 id="d215" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">46.检查字符串是否只包含数字。</h2><p id="926f" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">可以用<code class="fe no np nq nr b">isnumeric()</code>。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="a878" class="mc md it nr b gy nw nx l ny nz">'123a'.isnumeric()<br/>#=&gt; False</span><span id="227f" class="mc md it nr b gy oa nx l ny nz">'123'.isnumeric()<br/>#=&gt; True</span></pre><h2 id="b7b0" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">47.检查字符串是否只包含字母。</h2><p id="7f13" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">可以用<code class="fe no np nq nr b">isalpha()</code>。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="982b" class="mc md it nr b gy nw nx l ny nz">'123a'.isalpha()<br/>#=&gt; False</span><span id="e165" class="mc md it nr b gy oa nx l ny nz">'a'.isalpha()<br/>#=&gt; True</span></pre><h2 id="e17e" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">48.检查字符串是否只包含数字和字母。</h2><p id="b1f5" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">可以用<code class="fe no np nq nr b">isalnum()</code>。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="b653" class="mc md it nr b gy nw nx l ny nz">'123abc...'.isalnum()<br/>#=&gt; False</span><span id="a9bc" class="mc md it nr b gy oa nx l ny nz">'123abc'.isalnum()<br/>#=&gt; True</span></pre><h2 id="6812" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">49.从字典中返回一个键列表。</h2><p id="0a14" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">这可以通过将字典传递给python的<code class="fe no np nq nr b">list()</code>构造函数<code class="fe no np nq nr b">list()</code>来完成。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="ec2a" class="mc md it nr b gy nw nx l ny nz">d = {'id':7, 'name':'Shiba', 'color':'brown', 'speed':'very slow'}</span><span id="15e1" class="mc md it nr b gy oa nx l ny nz">list(d)<br/>#=&gt; ['id', 'name', 'color', 'speed']</span></pre><h2 id="8000" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">50.如何区分字符串的大小写？</h2><p id="a28f" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">您可以使用<code class="fe no np nq nr b">upper()</code>和<code class="fe no np nq nr b">lower()</code>字符串方法。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="fe87" class="mc md it nr b gy nw nx l ny nz">small_word = 'potatocake'<br/>big_word = 'FISHCAKE'</span><span id="1f43" class="mc md it nr b gy oa nx l ny nz">small_word.upper()<br/>#=&gt; 'POTATOCAKE'</span><span id="b863" class="mc md it nr b gy oa nx l ny nz">big_word.lower()<br/>#=&gt; 'fishcake'</span></pre><h2 id="21b8" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">51.remove，del，pop有什么区别？</h2><p id="a5a8" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><code class="fe no np nq nr b">remove()</code>删除第一个匹配值。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="e382" class="mc md it nr b gy nw nx l ny nz">li = ['a','b','c','d']</span><span id="2f18" class="mc md it nr b gy oa nx l ny nz">li.remove('b')<br/>li<br/>#=&gt; ['a', 'c', 'd']</span></pre><p id="205c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe no np nq nr b">del</code>按索引删除元素。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="d370" class="mc md it nr b gy nw nx l ny nz">li = ['a','b','c','d']</span><span id="c2b9" class="mc md it nr b gy oa nx l ny nz">del li[0]<br/>li<br/>#=&gt; ['b', 'c', 'd']</span></pre><p id="69fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe no np nq nr b">pop()</code>通过索引移除元素并返回该元素。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="6358" class="mc md it nr b gy nw nx l ny nz">li = ['a','b','c','d']</span><span id="946a" class="mc md it nr b gy oa nx l ny nz">li.pop(2)<br/>#=&gt; 'c'</span><span id="f3ea" class="mc md it nr b gy oa nx l ny nz">li<br/>#=&gt; ['a', 'b', 'd']</span></pre><h2 id="350d" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">52.举一个字典理解的例子。</h2><p id="d5ed" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">下面我们将创建一个字典，以字母表中的字母作为关键字，以字母表中的值作为索引。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="7dea" class="mc md it nr b gy nw nx l ny nz"># creating a list of letters<br/>import string<br/>list(string.ascii_lowercase)<br/>alphabet = list(string.ascii_lowercase)</span><span id="db2b" class="mc md it nr b gy oa nx l ny nz"># list comprehension<br/>d = {val:idx for idx,val in enumerate(alphabet)} </span><span id="af35" class="mc md it nr b gy oa nx l ny nz">d<br/>#=&gt; {'a': 0,<br/>#=&gt;  'b': 1,<br/>#=&gt;  'c': 2,<br/>#=&gt; ...<br/>#=&gt;  'x': 23,<br/>#=&gt;  'y': 24,<br/>#=&gt;  'z': 25}</span></pre><h2 id="4dfc" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">53.Python中的异常处理是如何执行的？</h2><p id="4484" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">Python提供了3个词来处理异常，<code class="fe no np nq nr b">try</code>、<code class="fe no np nq nr b">except</code>和<code class="fe no np nq nr b">finally</code>。</p><p id="a1f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">语法看起来像这样。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="2fb9" class="mc md it nr b gy nw nx l ny nz">try:<br/>    # try to do this<br/>except:<br/>    # if try block fails then do this<br/>finally:<br/>    # always do this</span></pre><p id="7eee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面这个简单的例子中，<code class="fe no np nq nr b">try</code>块失败了，因为我们不能将整数和字符串相加。<code class="fe no np nq nr b">except</code>块设定<code class="fe no np nq nr b">val = 10</code>，然后<code class="fe no np nq nr b">finally</code>块打印<code class="fe no np nq nr b">complete</code>。</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="4395" class="mc md it nr b gy nw nx l ny nz">try:<br/>    val = 1 + 'A'<br/>except:<br/>    val = 10<br/>finally:<br/>    print('complete')<br/>    <br/>print(val)<br/>#=&gt; complete<br/>#=&gt; 10</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0907" class="oe md it bd me of og oh mh oi oj ok mk jz ol ka mn kc om kd mq kf on kg mt oo bi translated">结论</h1><p id="9581" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">你永远不知道面试中会出现什么问题，最好的准备方式是拥有丰富的代码编写经验。</p><p id="4aa9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，这个列表应该涵盖了数据科学家或初级/中级python开发人员角色在python方面被问到的几乎所有问题。</p><p id="a2c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这对你和我一样有帮助。</p><p id="0a83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有没有我错过的很棒的问题？</p></div></div>    
</body>
</html>