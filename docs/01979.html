<html>
<head>
<title>Rank your things… An AES story</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">排列你的东西…一个AES的故事</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/rank-your-things-an-aes-story-1edf0e6d7ea8?source=collection_archive---------35-----------------------#2020-02-24">https://towardsdatascience.com/rank-your-things-an-aes-story-1edf0e6d7ea8?source=collection_archive---------35-----------------------#2020-02-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8122" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">自动论文评分(AES)是使用专门的计算机程序给在教育环境中撰写的论文打分。它的目标是将大量的文本实体分类到少量的离散类别中，对应于可能的等级。但是在这里，让我们从工业问题的角度来看。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e25d58f486ec0f668ff63165951e279f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TrCkkDHQDhH78L9C"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://www.pexels.com/photo/high-angle-photo-of-robot-2599244/" rel="noopener ugc nofollow" target="_blank">链接</a></p></figure><p id="4bc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你是篮球教练。你手下有40个想打球的孩子。你被要求选择一个由5个最高的孩子组成的团队。相当简单！你让他们按照身高的降序排列，然后你选出前5个。</p><p id="bdb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在说你是漫画作家。不是一个真正的作家，但你是那个能决定恶棍名字的人。你手下有很多实习生，他们为你创造反派角色的描述，并为你命名反派角色。他们为你的漫画创造了数百个这样的潜在反派角色，现在你必须在他们中选择你应该为你的漫画考虑的角色。棘手的是，你可能也想根据读者的喜好来选择。</p><p id="b339" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从技术上来说，你要给你的每一个潜在的坏人打分，然后<strong class="lb iu">按照读者亲和力得分(或评级)的降序给他们排名</strong>。</p><p id="b190" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(忽略你如何吸引读者的细节。假设漫画<strong class="lb iu">神</strong>给了你这些。)</p><p id="7e06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，你有你所有的反派(最终进入漫画)和他们各自的读者亲和力得分。现在你的任务是利用这些信息(不知何故，咄),对你的实习生创造的未来恶棍进行排名或评分。</p><p id="9ba2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在文献中，这被称为<a class="ae ky" href="https://en.wikipedia.org/wiki/Automated_essay_scoring" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">自动作文评分</strong> </a>或<strong class="lb iu">自动文本评分</strong>问题。</p><h1 id="2e01" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">方法</h1><p id="c83d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这是一个在研究领域不断发展的领域。所以，你会找到很多解决方法。让我们专注于一个能完成工作的解决方案。</p><p id="4e04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一种方法是将其视为一个预测问题，并尝试预测读者亲和力得分。但是有一个小问题，它可能无助于解决我们的问题。读者亲和力得分是针对整个漫画的，而不仅仅是针对反派。一个人喜欢剧情但讨厌反派还是可以给个好分数的。如果我们试图预测这个分数，我们将需要使用更多的信息(如漫画类别、发行月份、目标年龄组等)，而不仅仅是反派信息(如名字、描述等)。</p><p id="9d07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还要注意一个事实，一个反派的预测分数对我们来说并没有真正的用处，因为我们的工作是从一群反派中找出最好的反派。就个人而言，分数可能没有相对考虑时那么有意义。如果我们有100分，我们可以很容易地知道哪个恶棍可能比其他人表现得更好。</p><p id="e4bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们仍然可以继续我们的预测逻辑，但不是客观地看预测的分数，我们只需要确保它们与实际分数相关。这意味着，如果一个反面角色<em class="ms"> X </em>的得分高于反面角色<em class="ms"> Y </em>的得分，不管我们的预测有多好或多坏，如果实际得分也遵循相同的顺序或等级，那么它就是赢了。</p><h1 id="2c34" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">解决方案</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mt"><img src="../Images/069ac9b816bfa3b1a2b21e1082401775.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*q8CmQO0fTdGNXzw4.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://tfhub.dev/google/universal-sentence-encoder/1" rel="noopener ugc nofollow" target="_blank">链接</a></p></figure><p id="13fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">直接找到一个解决方案(在许多解决方案中，就像我说的，文献资料非常丰富🔥)，我们使用两种特定类型的模型。因为对文本进行评分是一项任务，所以我们需要某种文本嵌入技术来将我们的文本表示为向量。任何文本嵌入技术都可以选择，但我选择了<a class="ae ky" href="https://arxiv.org/abs/1803.11175" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">通用句子编码器</strong> </a>。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="4311" class="mz lw it mv b gy na nb l nc nd">usemodel = <strong class="mv iu">hub.Module</strong>('models/sentence_encoder')</span><span id="17e9" class="mz lw it mv b gy ne nb l nc nd"><strong class="mv iu">def</strong> get_use_vectors<strong class="mv iu">(list_text)</strong>:<br/>'''<br/>    Computing the USE vector representation of list of sentences<br/>    @param  list_text  :   list of sentences<br/>'''<br/>    messages = list_text   <br/>    num_batches = <strong class="mv iu">math.ceil</strong>(len(messages) / BATCH_SIZE)         </span><span id="e940" class="mz lw it mv b gy ne nb l nc nd">    message_embeddings = []<br/>    <strong class="mv iu">with</strong> tf.Session() <strong class="mv iu">as</strong> session:<br/>        session.<strong class="mv iu">run</strong>([tf.global_variables_initializer(),<br/>             tf.tables_initializer()])    <br/>        <strong class="mv iu">for</strong> batch <strong class="mv iu">in</strong> range(num_batches):<br/>            <strong class="mv iu">print</strong>(batch * batch_size, batch * batch_size + batch_size)<br/>            batch_msgs = messages[batch * batch_size: batch * batch_size + batch_size]<br/><br/>            message_embeddings_temp = session.run([model_use(batch_msgs)])      <br/>        <br/>             message_embeddings.append(message_embeddings_temp)<br/><br/>    all_embedding = np.concatenate(tuple(message_embeddings))<br/>    <strong class="mv iu">return</strong> all_embedding1, all_embedding2</span></pre><p id="2cae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该模型用于将恶棍的名字和他们的描述转换成向量，并且我们在预测模型中使用这些向量作为特征(连同其他特征)。其他特征可以是分类特征，例如漫画的类别、作者姓名等，或者是顺序特征，例如购买数量、价格等。</p><p id="b4ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些可以是一个热编码，并附加到我们的功能列表。</p><p id="522d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">预测模型是一个简单的<a class="ae ky" href="https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestRegressor.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">随机森林回归器</strong> </a>模型，直接取自<strong class="lb iu"> sklearn </strong>教程部分。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="ca58" class="mz lw it mv b gy na nb l nc nd"><strong class="mv iu">import</strong> pickle<br/><strong class="mv iu">from</strong> sklearn.ensemble <strong class="mv iu">import</strong> RandomForestRegressor<br/><br/>params = {'n_estimators':[20, 50, 100], 'max_depth':[2, 4, 6, 8, None], 'min_samples_split': [2, 4, 6, 8],<br/>          'n_jobs': [10]}<br/><br/><br/>rf = <strong class="mv iu">RandomForestRegressor</strong>(n_estimators = 250, random_state = 42)<br/><br/>grid = <strong class="mv iu">GridSearchCV</strong>(rf, params)<br/><br/>grid.<strong class="mv iu">fit</strong>(X_train, y_train)<br/><br/>predictions = grid.<strong class="mv iu">predict</strong>(X_test)<br/><br/>errors = abs(predictions - y_test)<br/><br/><strong class="mv iu">print</strong>(grid.best_score_)<br/><strong class="mv iu">print</strong>(grid.best_estimator_)</span></pre><p id="ed73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这给了我们一个模型，这个模型是根据我们过去的历史数据训练出来的，可以预测一个恶棍的名字/描述会有多好。从技术上来说，这是一个用户亲和力得分预测器。但是，正如我们所讨论的，由于我们没有使用所有可能和可用的特征来预测这个分数，并且由于我们没有将它作为用户亲密度分数预测模型，所以我们得到的最终预测将是不准确的。但是如果分数给了我们两个或更多恶棍的表现的相对指示，它将帮助我们挑选出头号恶棍。</p><h1 id="65ae" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">衡量标准</h1><p id="57ee" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Cohen%27s_kappa" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">科恩的Kappa评分</strong> </a>通常被用作一种衡量标准，以确定我们的预测排名或排序与实际排序相比有多接近。但是，该指标假设预测是诸如分数(0到5)之类的类别。我们有一个更连续的预测，因此这个指标对我们来说不太适用。</p><p id="a1ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们可以用简单的<a class="ae ky" href="https://en.wikipedia.org/wiki/Spearman%27s_rank_correlation_coefficient" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">斯皮尔曼</strong> </a>和<a class="ae ky" href="https://en.wikipedia.org/wiki/Pearson_correlation_coefficient" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">皮尔森</strong> </a>关联式。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/98742a7ffc8cab0e72a4e023fc38959e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nly1WeNk4TwpPaMv2jJxKg.png"/></div></div></figure><p id="d7a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">绘制实际分数与预测分数的对比图可以很好地说明我们的预测是否符合正确的趋势。</p><p id="3b8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对应于左侧预测的相关系数为:</p><blockquote class="ng nh ni"><p id="2b94" class="kz la ms lb b lc ld ju le lf lg jx lh nj lj lk ll nk ln lo lp nl lr ls lt lu im bi translated">皮尔森:0.65，p值= 2.14 e-92 | <strong class="lb iu">斯皮尔曼:0.60，p值=8.13 e-123</strong></p></blockquote></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><p id="2ce9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，通过这种方法，你可以使用预测的分数来排列或排序你的恶棍，并选择顶部的<em class="ms"> X </em>，前提是你的相关性和上面的情节看起来不错。别让实习生毁了你的漫画事业:)</p></div></div>    
</body>
</html>