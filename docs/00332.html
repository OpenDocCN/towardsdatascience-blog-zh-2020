<html>
<head>
<title>Breaking Down Goodreads Dataset using Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Python 分解 Goodreads 数据集</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/breaking-down-goodreads-dataset-using-python-388e9b9d6352?source=collection_archive---------20-----------------------#2020-01-10">https://towardsdatascience.com/breaking-down-goodreads-dataset-using-python-388e9b9d6352?source=collection_archive---------20-----------------------#2020-01-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="71a0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">找出下一本书</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5fbac0105ffc27ce09942bb09f087997.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y1BlqUDPLkFLsKQqDbhh_w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@eddrobertson?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Ed Robertson </a>在<a class="ae ky" href="https://unsplash.com/s/photos/books?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="8587" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我喜欢看书，总是在寻找下一本书来读，甚至在我开始读最近买的那本之前。所以，我决定摆弄这个<a class="ae ky" href="https://www.kaggle.com/jealousleopard/goodreadsbooks" rel="noopener ugc nofollow" target="_blank"> Goodreads 数据集</a>我偶然发现了 Kaggle，看看我最终会得到什么样的书籍推荐。</p><p id="d22e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这非常有趣，充满了学习！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="a958" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和往常一样，我使用了 Jupyter 笔记本，并使用<code class="fe mc md me mf b">virtualenv</code>建立了一个虚拟环境。所有步骤请查看本<a class="ae ky" rel="noopener" target="_blank" href="/demystifying-virtual-environments-in-python-7c0a0b255928">帖</a>。</p><h2 id="57f9" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">进口:</h2><pre class="kj kk kl km gt mz mf na nb aw nc bi"><span id="1609" class="mg mh it mf b gy nd ne l nf ng">import sys<br/>sys.path.append('./lib/python3.7/site-packages')<br/>import pandas as pd<br/>import re<br/>import math</span><span id="3bc6" class="mg mh it mf b gy nh ne l nf ng">data = pd.read_csv("books.csv")</span></pre><h2 id="6aa1" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">错误:</h2><p id="5ce3" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">读取 csv 文件时，会出现以下错误:</p><pre class="kj kk kl km gt mz mf na nb aw nc bi"><span id="9870" class="mg mh it mf b gy nd ne l nf ng">ParserError: Error tokenizing data. C error: Expected 10 fields in line 4012, saw 11</span></pre><p id="91c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">发生这种情况是因为，在某些行中，有逗号将所有值向右移动一个位置，从而添加了一个额外的列。</p><p id="5384" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可能要做的事情:</p><ul class=""><li id="f270" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">完全跳过这些行。但是我们事先并不知道这些行是什么。该数据集的 Kaggle 讨论区列出了这些行，但是删除它们将导致数据丢失。</li><li id="9d46" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">使用文本编辑器，用另一个分隔符如<code class="fe mc md me mf b">;</code>或<code class="fe mc md me mf b">|</code>替换所有逗号，然后手动转到有多个作者的行，并在那里放置逗号。这是一个麻烦的过程，需要太多的手动操作。如果损坏的行数太多，这个解决方案是不可行的。</li></ul><p id="2b2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我最终做的是——使用文本编辑器，并在最后添加一列以避免出现<code class="fe mc md me mf b">ParseError</code>。我给专栏命名为<code class="fe mc md me mf b">extra</code>，并使用<code class="fe mc md me mf b">pandas</code>读取 csv 文件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/5cfe9fdfa13ac6c597e9e18308a64f69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*erJMblMNiPL5A0Cad1ULuw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">添加了名为“额外”的列</p></figure><p id="9d0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以查看和分析数据了。</p><pre class="kj kk kl km gt mz mf na nb aw nc bi"><span id="8789" class="mg mh it mf b gy nd ne l nf ng">data.describe(include = "all")</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/552782033c19ecc68475be3bf6983aee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IsteLvgLRxEsHjhM6I0wYw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><code class="fe mc md me mf b">data.describe(include = "all")</code></p></figure><h2 id="f7ab" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">数据:</h2><p id="dbda" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated"><code class="fe mc md me mf b">bookID</code>:每本书的唯一标识号；<br/> <code class="fe mc md me mf b">title</code>:书的名字；<br/> <code class="fe mc md me mf b">authors</code>:该书作者的姓名。多个作者用<code class="fe mc md me mf b">-</code>分隔；<br/> <code class="fe mc md me mf b">average_rating</code>:该书的平均评分；<br/> <code class="fe mc md me mf b">isbn</code>:识别图书的唯一编号，国际标准书号；<br/> <code class="fe mc md me mf b">isbn13</code>:一个 13 位的 ISBN 来标识图书，而不是标准的 11 位 ISBN；<br/> <code class="fe mc md me mf b">language_code</code>:书的主要语言；<br/> <code class="fe mc md me mf b"># num_pages</code>:书的页数；<br/> <code class="fe mc md me mf b">ratings_count</code>:该书获得的总评分数；<br/> <code class="fe mc md me mf b">text_reviews_count</code>:该书收到的文字评论总数。</p><h2 id="7fee" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">损坏的行:</h2><p id="4b8f" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">13719 行中有 5 行损坏，即它们在<code class="fe mc md me mf b">extra</code>字段中有一个值。</p><p id="7b90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了找出这些行，我们检查哪些<strong class="lb iu">在该字段中不具有值<code class="fe mc md me mf b">NaN</code>，即具有整数值。因此，我将那些具有整数值的行的索引存储在字段<code class="fe mc md me mf b">extra</code>中。</strong></p><pre class="kj kk kl km gt mz mf na nb aw nc bi"><span id="ef13" class="mg mh it mf b gy nd ne l nf ng">corrupted_rows = []</span><span id="6eab" class="mg mh it mf b gy nh ne l nf ng">for index, i in data.iterrows():<br/>     if -math.inf &lt;= i['extra'] &lt;= math.inf:<br/>         print("index number:", index)<br/>         print("field value:", i['extra'])<br/>         print("...")</span><span id="def2" class="mg mh it mf b gy nh ne l nf ng">corrupted_rows.append(index)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/319d3b6bc099a7990096d62ba3babf3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*QM5KowfiR_R8hbRWPb_vRA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">损坏的行</p></figure><pre class="kj kk kl km gt mz mf na nb aw nc bi"><span id="6d6f" class="mg mh it mf b gy nd ne l nf ng">data.loc[corrupted_rows, :]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/0ccac6411f75214b81b86eb8a71d8cf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J0cQhIVk-dlkkXIo_LWVVQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><code class="fe mc md me mf b">data.loc[corrupted_rows, :]</code></p></figure><p id="2aea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们将多个作者合并到一个字段中。我使用<code class="fe mc md me mf b">authors</code>字段中的<code class="fe mc md me mf b">;</code>加入它们:</p><pre class="kj kk kl km gt mz mf na nb aw nc bi"><span id="1d81" class="mg mh it mf b gy nd ne l nf ng">data['authors'] = data['authors']+ ";" +data['average_rating']</span></pre><p id="fcd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们得到一个警告:<code class="fe mc md me mf b">SettingWithCopyWarning</code>。这不是一个错误，所以没有什么是坏的。然而，知道警告试图告诉我们什么总是好的，而不是忽视它。这里有一个<a class="ae ky" href="https://www.dataquest.io/blog/settingwithcopywarning/" rel="noopener ugc nofollow" target="_blank">解释</a>。</p><h2 id="feca" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">转变:</h2><p id="90c0" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">作者被合并在一个专栏中。现在剩下要做的是将列值从第三列开始(包括第三列，因为我们从索引 0 开始)，向左移动一个空格。这是通过使用<code class="fe mc md me mf b">shift</code>操作符来实现的，这里我们指定需要向左(或向右)移动多少个空格，以及是沿着行轴还是列轴。</p><pre class="kj kk kl km gt mz mf na nb aw nc bi"><span id="f64d" class="mg mh it mf b gy nd ne l nf ng"><strong class="mf iu">#-1 indicates one space to the left and axis=1 specifies column axis</strong></span><span id="2aad" class="mg mh it mf b gy nh ne l nf ng">data.iloc[corrupted_rows, 3:] = data.iloc[corrupted_rows, 3:].shift(-1, axis = 1)<!-- --> </span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/f1558a4ca5dc95586eadce908de75c3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KgveUiE8tNQNqBua_d46_w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">移位的结果(<strong class="bd og">这不是正确的方式</strong>)</p></figure><p id="40ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种移位的结果是两列中的值丢失:<code class="fe mc md me mf b"># num_pages</code>和<code class="fe mc md me mf b">text_reviews_count</code>。这是因为列的数据类型与最终移位值的数据类型不匹配。</p><p id="98bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解决方案是将所有列的数据类型临时转换为<code class="fe mc md me mf b">str</code>，执行 shift，然后将它们转换回原始数据类型。</p><pre class="kj kk kl km gt mz mf na nb aw nc bi"><span id="3ea8" class="mg mh it mf b gy nd ne l nf ng">data.iloc[corrupted_rows, 3:] = data.iloc[corrupted_rows, 3:].astype(str) <strong class="mf iu">#convert to str</strong></span><span id="3e78" class="mg mh it mf b gy nh ne l nf ng">data.iloc[corrupted_rows, 3:] = data.iloc[corrupted_rows, 3:].shift(-1, axis = 1) <strong class="mf iu">#the shift</strong></span><span id="be10" class="mg mh it mf b gy nh ne l nf ng">data.describe(include="all")</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/4d0f49f6a74bd95cd1a2c51994fc5b1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1jvJeo-wZV1eukQfLq2K6g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><code class="fe mc md me mf b">data.describe(include="all")</code></p></figure><p id="5476" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以删除最后一列。</p><pre class="kj kk kl km gt mz mf na nb aw nc bi"><span id="f71e" class="mg mh it mf b gy nd ne l nf ng"> <!-- -->del data['extra']</span></pre><p id="4444" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在必须将列的数据类型转换回它们的原始类型。</p><p id="133e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mc md me mf b">pd.to_numeric</code>自动配置<code class="fe mc md me mf b">float</code>或<code class="fe mc md me mf b">int</code>数据类型。</p><pre class="kj kk kl km gt mz mf na nb aw nc bi"><span id="950e" class="mg mh it mf b gy nd ne l nf ng">data["average_rating"] = pd.to_numeric(data.average_rating)<!-- --> </span><span id="be27" class="mg mh it mf b gy nh ne l nf ng">data["ratings_count"] = pd.to_numeric(data.ratings_count)<!-- --> </span><span id="da0f" class="mg mh it mf b gy nh ne l nf ng">data["# num_pages"] = pd.to_numeric(data.["# num_pages"])</span><span id="5b1b" class="mg mh it mf b gy nh ne l nf ng">data["text_reviews_count"] = pd.to_numeric(data.["text_reviews_count"])</span></pre><h2 id="dba9" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">过滤数据:</h2><p id="b76e" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我只想保留那些英文书。首先，我们需要一个正在使用的不同语言代码的列表。</p><pre class="kj kk kl km gt mz mf na nb aw nc bi"><span id="5684" class="mg mh it mf b gy nd ne l nf ng">language_code_unique = data.language_code.unique()<!-- --> </span></pre><p id="a90e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们打印列表时，我们看到英语语言代码以<code class="fe mc md me mf b">en</code>开头。因此，简单使用<code class="fe mc md me mf b">regex</code>将帮助我们过滤数据。</p><pre class="kj kk kl km gt mz mf na nb aw nc bi"><span id="2756" class="mg mh it mf b gy nd ne l nf ng"><strong class="mf iu">#list to store the different English language codes</strong><br/>english_lang_code = []<!-- --> </span><span id="ba83" class="mg mh it mf b gy nh ne l nf ng">language_code_regex = re.compile(r'^en')</span><span id="d856" class="mg mh it mf b gy nh ne l nf ng">for code in language_code_unique:<br/>    mo2 = language_code_regex.search(code)<br/>    if mo2 != None:<br/>        english_lang_code.append(code)</span></pre><p id="f36a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出是对应于英语的 5 种语言代码。然后，我们使用 define 函数直接在数据帧上使用。</p><pre class="kj kk kl km gt mz mf na nb aw nc bi"><span id="319d" class="mg mh it mf b gy nd ne l nf ng">def check_lang_code(row):<br/>     if row.language_code in english_lang_code:<br/>         return row</span><span id="4235" class="mg mh it mf b gy nh ne l nf ng">data = data[data.language_code.isin(english_lang_code)]</span></pre><p id="7081" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这给我们留下了英文书籍，并将行数减少到 12651。为了进一步减少数据量，我们只提取相关的列:<code class="fe mc md me mf b">title</code>、<code class="fe mc md me mf b">authors</code>、<code class="fe mc md me mf b">average_rating</code>、<code class="fe mc md me mf b">ratings_count</code>。</p><pre class="kj kk kl km gt mz mf na nb aw nc bi"><span id="4953" class="mg mh it mf b gy nd ne l nf ng">data_filtered = data.iloc[:, [1, 2, 3, 8]]<!-- --> </span></pre><p id="2a72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了获得更高质量的图书列表，我们需要设置一个阈值<code class="fe mc md me mf b">average_rating</code>和<code class="fe mc md me mf b">ratings_count</code>。我决定两者兼顾。</p><pre class="kj kk kl km gt mz mf na nb aw nc bi"><span id="c772" class="mg mh it mf b gy nd ne l nf ng">ratings_count_mean = data_filtered["ratings_count"].mean()</span><span id="2e30" class="mg mh it mf b gy nh ne l nf ng">average_rating_mean = data_filtered["average_rating"].mean()</span><span id="2798" class="mg mh it mf b gy nh ne l nf ng">data_filtered = data_filtered[(data_filtered.average_rating &gt; average_rating_mean)]</span><span id="492f" class="mg mh it mf b gy nh ne l nf ng">data_filtered = data_filtered[(data_filtered.ratings_count &gt; ratings_count_mean)]</span></pre><p id="f7f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这留给我们一个 1013 行× 4 列的数据集。</p><h2 id="d474" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">高评价书籍列表:</h2><p id="fddd" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">使用<code class="fe mc md me mf b">average_rating</code>作为获得顶级书籍列表的唯一因素是不够的。</p><pre class="kj kk kl km gt mz mf na nb aw nc bi"><span id="b664" class="mg mh it mf b gy nd ne l nf ng">data_filtered.sort_values(by=['average_rating'], ascending=False)<!-- --> </span></pre><p id="b12d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的列表不对。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/8506f1988ef85735cae56ffc977be5f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8yKf6VB1WjvitZXh6z1fgg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><code class="fe mc md me mf b">data_filtered.sort_values(by=['average_rating'], ascending=False)</code></p></figure><p id="3418" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要考虑到<code class="fe mc md me mf b">ratings_count</code>。我创建了一个新列<code class="fe mc md me mf b">weighted_rating</code>，作为<code class="fe mc md me mf b">ratings_count</code>和<code class="fe mc md me mf b">average_rating</code>的乘积。</p><pre class="kj kk kl km gt mz mf na nb aw nc bi"><span id="a208" class="mg mh it mf b gy nd ne l nf ng">data_filtered['weighted_rating'] = data_filtered['average_rating'] * data_filtered['ratings_count']</span><span id="155e" class="mg mh it mf b gy nh ne l nf ng"><strong class="mf iu">#sort in descending order of 'weighted_rating'<br/></strong>data_filtered = data_filtered.sort_values(by='weighted_rating', ascending=False) </span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/0fda156194bf7bcdbd3765cd68fbe66a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vp8AgJ7eFGuTSCUmGBaO1A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">data_filtered.head(10)</p></figure><p id="aa8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看起来好多了！</p><p id="77ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显然，哈利·波特是主角。现在，我已经读完了整个系列，所以我不想包括任何哈利波特的书。这是一个简单的<code class="fe mc md me mf b">regex</code>案例。</p><pre class="kj kk kl km gt mz mf na nb aw nc bi"><span id="50d9" class="mg mh it mf b gy nd ne l nf ng">match_regex = re.compile(r’Harry Potter’)</span><span id="ad42" class="mg mh it mf b gy nh ne l nf ng"><strong class="mf iu">#list to store all 'Harry Potter' titles</strong><br/>matched_titles = []</span><span id="2b07" class="mg mh it mf b gy nh ne l nf ng">for index, row in data_filtered.iterrows():<br/>    mo1 = match_regex.search(row.title)<br/>    if mo1 != None:<br/>        matched_titles.append(row.title)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/a4d3f86cac48d637c28c7cd8eb619164.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wXkoIy9M8H_qIfj07NpTwg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">匹配的 _ 标题</p></figure><pre class="kj kk kl km gt mz mf na nb aw nc bi"><span id="a1f0" class="mg mh it mf b gy nd ne l nf ng">data_without_hp = data_filtered[~data_filtered.title.isin(matched_titles)]</span></pre><p id="83ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">榜单前 20 本书:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/3e13794b5bbf7ef5bfbfeaa146935c2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6YSBGqR2yEjqbyieVu2T1A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">data_without_hp.head(20)</p></figure><p id="b33e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">列表中有我读过的书，通过添加到<code class="fe mc md me mf b">match_regex</code>可以很容易地过滤掉，但我决定就此打住。脱颖而出的书是“<em class="om">蜜蜂的秘密生活</em>”。我以前从未听说过这本书，这本书我一定要读一读！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="89cf" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">局限性:(</h2><p id="16a7" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">不幸的是，这个数据集没有流派类别(恐怖/犯罪/搞笑/…)和小说/非小说类别，如果有这两个类别，这份名单会更具策划性和个性化(想到创建这样一份名单，我会兴奋得尖叫)！</p><h2 id="e846" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">要点:</h2><p id="3848" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">→处理“损坏的行”<br/> →尽可能过滤掉数据以获得期望的结果并提高性能<br/> →一个主要的教训是尽可能减少<code class="fe mc md me mf b">for</code>循环的数量，因为它们比其他方法慢:</p><ul class=""><li id="e76d" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">定义一个函数，然后在数据帧上应用它</li><li id="5393" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">过滤数据框架括号内的数据</li><li id="f77b" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">直接计算函数值</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="6b9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望你喜欢带走一些有价值的见解！</p></div></div>    
</body>
</html>