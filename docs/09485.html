<html>
<head>
<title>A Data Engineering Perspective on Go vs. Python (Part 2 — Dataflow)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从数据工程的角度看 Go 与 Python(第 2 部分——数据流)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-data-engineering-perspective-on-go-vs-python-part-2-dataflow-472b42a14f9?source=collection_archive---------60-----------------------#2020-07-06">https://towardsdatascience.com/a-data-engineering-perspective-on-go-vs-python-part-2-dataflow-472b42a14f9?source=collection_archive---------60-----------------------#2020-07-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="510f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用 Apache Beam &amp; Dataflow 探索、剖析和基准测试 go SDK</h2></div><h1 id="cf55" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">介绍</h1><p id="3de3" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在我们从数据工程的角度比较 Python 和 go 的第 2 部分中，我们将最终看一下 Apache Beam 和 Google Dataflow，以及 go SDK 和 Python SDK 的不同之处，我们正在处理的缺点，通过运行大量基准测试它有多快，以及进行转换的可行性。</p><p id="9cf6" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">你可以在这里找到《T4》第一部。</p><h1 id="c8c7" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">阿帕奇光束和谷歌数据流</h1><p id="bf2d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">虽然我们已经在之前的<a class="ae mb" href="https://chollinger.com/blog/2018/06/analyzing-reddits-top-posts-images-with-google-cloud-part-1/#introducing-data-flow" rel="noopener ugc nofollow" target="_blank">中多次使用过</a><a class="ae mb" href="https://beam.apache.org/" rel="noopener ugc nofollow" target="_blank">阿帕奇光束</a>，请允许我再简单介绍一下。</p><blockquote class="mc md me"><p id="6fde" class="la lb mf lc b ld lw ju lf lg lx jx li mg ly ll lm mh lz lp lq mi ma lt lu lv im bi translated"><em class="it"> Apache Beam 是一个开源的统一模型，用于定义批处理和流数据并行处理管道。使用一个开源的 Beam SDKs，您可以构建一个定义管道的程序。然后，管道由 Beam 支持的分布式处理后端之一执行，包括 Apache Flink、Apache Spark 和 Google Cloud Dataflow。</em></p><p id="4238" class="la lb mf lc b ld lw ju lf lg lx jx li mg ly ll lm mh lz lp lq mi ma lt lu lv im bi translated"><a class="ae mb" href="https://beam.apache.org/get-started/beam-overview/" rel="noopener ugc nofollow" target="_blank"><em class="it">https://beam.apache.org/get-started/beam-overview/</em></a></p></blockquote><p id="feeb" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">Beam 可以用于各种数据用例，就像 Apache Spark 一样——ETL(提取、转换、加载)管道、流分析，或者从文件系统到 RDMBS 的简单数据移动。</p><h1 id="d232" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">为什么梁是有趣的</h1><p id="9c7e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我得到的最好的专业建议之一是问“那又怎样？”。话虽如此:那又怎样，我为什么关心梁？</p><p id="424d" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">对我来说，Beam 模型最有趣的方面之一是管道逻辑、语言和执行环境的解耦。我可以在一张纸上设计我的逻辑(例如，用一些<code class="fe mj mk ml mm b">Beam</code>-特定术语画一个<code class="fe mj mk ml mm b">DAG</code>-我们马上就可以完成)，用任何主要语言实现它-甚至是多种语言-并在任何支持的<code class="fe mj mk ml mm b">Runners</code>上运行它。</p><p id="f078" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">上次我们在这个博客上使用它时，我们用它编写了一个管道来分析 reddit 帖子，并在<code class="fe mj mk ml mm b">Dataflow</code> runner 上执行，如下所示:</p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi mn"><img src="../Images/f9d342f4b7c7a3c912ae5f2f053ecda7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*T9YQYRKtvQpNF4Oj.png"/></div></div></figure><p id="a169" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">因为这条管道是用 Python 编写的，所以没有什么可以阻止我们在本地 Hadoop 集群、AWS EMR 上运行<em class="mf">完全相同的作业</em>，或者只是使用<code class="fe mj mk ml mm b">DirectRunner</code>在本地运行它。这种水平的可移植性，结合我碰巧发现比<code class="fe mj mk ml mm b">Spark</code>更精简的编程模型，使得<code class="fe mj mk ml mm b">Beam</code>成为一个非常有趣的框架。</p><p id="963c" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">实际上，我们将在本文的示例部分中这样做，并设计一个管道，用<code class="fe mj mk ml mm b">Python</code>和<code class="fe mj mk ml mm b">go</code>编写它，并在不同的<code class="fe mj mk ml mm b">Runners</code>上运行它。</p><h1 id="42ac" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">核心概念</h1><p id="c745" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><code class="fe mj mk ml mm b">Beam</code>中的一切都始于<code class="fe mj mk ml mm b">Pipeline.</code><code class="fe mj mk ml mm b">Beam</code>编程模型的工作原理是通过代码暴露高级抽象，允许您的<code class="fe mj mk ml mm b">Pipeline</code>在给定数据集上执行<code class="fe mj mk ml mm b">PTransforms</code>的图形，这在术语上是在不可变集合上操作，称为<code class="fe mj mk ml mm b">PCollections</code>，可以通过<code class="fe mj mk ml mm b">IO</code>操作将其移动到持久状态。作业可以在不同的<code class="fe mj mk ml mm b">Runners</code>上执行，以提供一个(分布式)执行环境。</p><p id="0569" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">在我们看一个真实世界的例子之前，让我们深入研究一下这些概念。</p><blockquote class="mc md me"><p id="5dc4" class="la lb mf lc b ld lw ju lf lg lx jx li mg ly ll lm mh lz lp lq mi ma lt lu lv im bi translated"><em class="it">这是一个浓缩版的</em> <a class="ae mb" href="https://beam.apache.org/documentation/programming-guide/" rel="noopener ugc nofollow" target="_blank"> <em class="it">官方阿帕奇光束文档</em> </a> <em class="it">，建议你完整阅读以获得更深入的观点</em></p></blockquote><h1 id="a86d" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">管道</h1><p id="a6e9" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">一个<code class="fe mj mk ml mm b">Pipeline</code>对象是任何作业的起点，它通常由一个<code class="fe mj mk ml mm b">configuration</code>对象初始化，该对象定义了<em class="mf">如何</em>和<em class="mf">你的管道在哪里</em>运行。</p><h1 id="a7bf" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">p 收藏</h1><p id="fde7" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">与 Spark <code class="fe mj mk ml mm b">RDD</code>或<code class="fe mj mk ml mm b">DataFrame</code>不同的是，<code class="fe mj mk ml mm b">PCollection</code>是不可变的数据集合，可以通过管道的生命周期在内存中修改。</p><p id="9f05" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">一个<code class="fe mj mk ml mm b">PCollection</code>中的数据可以是任意类型，只要元素可以被编码为<code class="fe mj mk ml mm b">string</code>以便在工人之间序列化它们。</p><p id="c77a" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">可以是任意大小的，但是如果集合太大而不适合单个工作节点上的内存，它们的元素可能由不同的工作节点处理。此外，它们可以是<em class="mf">有界的</em>(即，具有固定的大小)或者是<em class="mf">无界的</em>(即，是“开放式的”，就像在流场景中一样)。</p><h1 id="5ac6" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">转换</h1><p id="29c9" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><code class="fe mj mk ml mm b">Transforms</code>通过<code class="fe mj mk ml mm b">apply</code>运算用户代码和逻辑，在<code class="fe mj mk ml mm b">PCollection</code>的单个元素上应用逻辑，并返回可在后续步骤中使用的完整的<code class="fe mj mk ml mm b">PCollection</code>。</p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi mn"><img src="../Images/9d73273c4dd1094234aba012746607da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P7jek9Tc2xwyPcS6vJaWWQ.png"/></div></div><p class="mz na gj gh gi nb nc bd b be z dk translated"><a class="ae mb" href="https://beam.apache.org/documentation/programming-guide/#applying-transforms" rel="noopener ugc nofollow" target="_blank">https://beam . Apache . org/documentation/programming-guide/# applying-transforms</a></p></figure><p id="0fc1" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">还可以通过将 DAG 分成多个独立的步骤来<code class="fe mj mk ml mm b">branch</code>流水线:</p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi mn"><img src="../Images/2b6ecd16e33b5a1a730ffd8874b3b7c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QAWIQnSs6-Cn-BL7LHkAFA.png"/></div></div><p class="mz na gj gh gi nb nc bd b be z dk translated"><a class="ae mb" href="https://beam.apache.org/documentation/programming-guide/#applying-transforms" rel="noopener ugc nofollow" target="_blank">https://beam . Apache . org/documentation/programming-guide/# applying-transforms</a></p></figure><p id="1149" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">自定义<code class="fe mj mk ml mm b">transforms</code>需要遵守一些规则，最显著的是<strong class="lc iu">可串行化</strong>(因为数据需要在工作线程之间传输)<strong class="lc iu">单线程执行</strong>(因为每个元素都应该在自己的线程中工作，由底层运行器协调)，以及<strong class="lc iu">等幂</strong>(因为可能会发生重试)。</p><p id="e527" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated"><code class="fe mj mk ml mm b">Beam</code>提供了几个可以开箱即用的内核<code class="fe mj mk ml mm b">transforms</code>:</p><ul class=""><li id="8b5e" class="nd ne it lc b ld lw lg lx lj nf ln ng lr nh lv ni nj nk nl bi translated"><code class="fe mj mk ml mm b">ParDo</code></li><li id="98a9" class="nd ne it lc b ld nm lg nn lj no ln np lr nq lv ni nj nk nl bi translated"><code class="fe mj mk ml mm b">GroupByKey</code></li><li id="4237" class="nd ne it lc b ld nm lg nn lj no ln np lr nq lv ni nj nk nl bi translated"><code class="fe mj mk ml mm b">CoGroupByKey</code></li><li id="7711" class="nd ne it lc b ld nm lg nn lj no ln np lr nq lv ni nj nk nl bi translated"><code class="fe mj mk ml mm b">Combine</code></li><li id="1846" class="nd ne it lc b ld nm lg nn lj no ln np lr nq lv ni nj nk nl bi translated"><code class="fe mj mk ml mm b">Flatten</code></li><li id="2624" class="nd ne it lc b ld nm lg nn lj no ln np lr nq lv ni nj nk nl bi translated"><code class="fe mj mk ml mm b">Partition</code></li></ul><h2 id="e6f0" class="nr kj it bd kk ns nt dn ko nu nv dp ks lj nw nx ku ln ny nz kw lr oa ob ky oc bi translated">帕尔多</h2><p id="ee43" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><code class="fe mj mk ml mm b">ParDo</code>转换可能是最常见的一种，因为它类似于<code class="fe mj mk ml mm b">map</code>操作:将逻辑应用于<code class="fe mj mk ml mm b">PCollection</code>的每个元素，并返回所述元素(或者不返回它，因此，<code class="fe mj mk ml mm b">filtering</code>返回集合)。</p><p id="ee90" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">将<code class="fe mj mk ml mm b">ParDo</code>作为构建博客的基础，在平面数据流上应用逻辑，然后可以通过<code class="fe mj mk ml mm b">grouping</code>、<code class="fe mj mk ml mm b">flattening</code>和其他聚合逻辑进一步增强。</p><p id="e106" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">为了理解一个<code class="fe mj mk ml mm b">ParDo</code>实际上做什么，<code class="fe mj mk ml mm b">Beam</code>文档对一个<code class="fe mj mk ml mm b">ParDo</code>的生命周期提供了很好的解释:</p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi mn"><img src="../Images/2ac06f3198930fe75e8d892ad588f9c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f1Fq8A8v_W2qRzl9Gp5QJQ.png"/></div></div><p class="mz na gj gh gi nb nc bd b be z dk translated"><a class="ae mb" href="https://beam.apache.org/documentation/programming-guide/#applying-transforms" rel="noopener ugc nofollow" target="_blank">https://beam . Apache . org/documentation/programming-guide/# applying-transforms</a></p></figure><h2 id="1559" class="nr kj it bd kk ns nt dn ko nu nv dp ks lj nw nx ku ln ny nz kw lr oa ob ky oc bi translated">CoGroupByKey</h2><p id="53fb" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><code class="fe mj mk ml mm b">CoGroupByKey</code>通过多个输入集合中的键聚集所有输入元素。CoGroupByKey 执行两个或更多具有相同键类型的键/值 p 集合的关系连接——这是一个非常有用的东西，我们将在下面的例子中使用。</p><h1 id="4095" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">计划</h1><p id="f5b8" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">一个<code class="fe mj mk ml mm b">Schema</code>定义了一个<code class="fe mj mk ml mm b">PCollection</code>中元素的逻辑结构和数据类型。<code class="fe mj mk ml mm b">Beam Schemas</code>类似于<code class="fe mj mk ml mm b">parquet</code>或<code class="fe mj mk ml mm b">database</code>模式，应该定义<code class="fe mj mk ml mm b">names</code>、<code class="fe mj mk ml mm b">types</code>，以及关于字段是否可以是<code class="fe mj mk ml mm b">NULL</code>的信息。</p><p id="bb2d" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">Beam 支持以下基本类型:</p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi od"><img src="../Images/987fb36c87c777ad8e1b5da2f88b040c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QtZX1EKMKhqn_JU6c-9Gaw.png"/></div></div><p class="mz na gj gh gi nb nc bd b be z dk translated"><a class="ae mb" href="https://chollinger.com/blog/2020/07/a-data-engineering-perspective-on-go-vs.-python-part-2-dataflow/#schemas" rel="noopener ugc nofollow" target="_blank">https://CHOL linger . com/blog/2020/07/a-data-engineering-perspective-on-go-vs .-python-part-2-data flow/# schemas</a></p></figure><h1 id="576f" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">输入－输出</h1><p id="558b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><code class="fe mj mk ml mm b">I/O</code>用于提供输入数据，并为管道提供一个或多个定义的输出。我将参考<a class="ae mb" href="https://chollinger.com/blog/2020/06/a-data-engineering-perspective-on-go-vs.-python-part-1/#io" rel="noopener ugc nofollow" target="_blank">第 1 部分</a>以获得 SDK 提供的所有<code class="fe mj mk ml mm b">I/O</code>连接器的完整列表。</p><p id="55a2" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated"><code class="fe mj mk ml mm b">I/O</code>还可以定制连接器，通过从现有基类继承来读取不支持的文件类型。这可能很有挑战性(因为您希望能够分割一个文件源，这样它就可以被多个工作人员处理)，但是过一会儿，这就变得非常简单了。</p><h1 id="e0c1" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">滑行装置</h1><p id="2dec" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><code class="fe mj mk ml mm b">Runners</code>定义哪个系统执行流水线，例如通过本地运行(<code class="fe mj mk ml mm b">DirectRunner</code>)、在<code class="fe mj mk ml mm b">Google Dataflow</code>上运行或通过<code class="fe mj mk ml mm b">Apache Spark</code>。</p><p id="3140" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">与<code class="fe mj mk ml mm b">I/O</code>类似，请参考<a class="ae mb" href="https://chollinger.com/blog/2020/06/a-data-engineering-perspective-on-go-vs.-python-part-1/#runners" rel="noopener ugc nofollow" target="_blank">第 1 部分</a>进行概述。</p><h1 id="d7a3" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">一个示例作业的用例</h1><p id="067d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">为了展示一些基本的区别，让我们定义一个可以在<code class="fe mj mk ml mm b">Python</code>和<code class="fe mj mk ml mm b">go</code>中实现的用例。</p><p id="c42f" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">在这个例子中，我们遵循这个简单的用户故事:“作为一个<em class="mf">电影爱好者</em>，我想<em class="mf">找到符合我喜好的电影</em>，这样<em class="mf">我就可以看一部新电影了”</em>。</p><p id="767a" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">我们的<em class="mf">偏好</em>应为:</p><ol class=""><li id="a003" class="nd ne it lc b ld lw lg lx lj nf ln ng lr nh lv oe nj nk nl bi translated">我们希望解析标题和评级(<em class="mf">读取数据</em>)</li><li id="856b" class="nd ne it lc b ld nm lg nn lj no ln np lr nq lv oe nj nk nl bi translated">我们只对电影感兴趣，对电视剧不感兴趣；此外，电影应该在 1970 年之后制作，以获得一些更可靠的元数据作为我们决策的基础，因为旧的电影通常只有基本信息(<em class="mf">过滤数据</em>)</li><li id="0999" class="nd ne it lc b ld nm lg nn lj no ln np lr nq lv oe nj nk nl bi translated">我们既要基本标题，也要来自不同来源的评级信息(<em class="mf">组合数据</em>)</li><li id="19f6" class="nd ne it lc b ld nm lg nn lj no ln np lr nq lv oe nj nk nl bi translated">我们想要可用格式的数据(<em class="mf">写数据</em> ) [0]</li></ol><p id="2552" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">为此，我们将使用<a class="ae mb" href="https://www.imdb.com/interfaces/" rel="noopener ugc nofollow" target="_blank"> IMDb 数据集</a>，它可用于非商业用途，并且每天更新。</p><p id="ffd3" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated"><em class="mf">完整的源代码可以在</em><a class="ae mb" href="https://github.com/chollinger93/beam-examples" rel="noopener ugc nofollow" target="_blank"><em class="mf">GitHub</em></a><em class="mf">上获得。</em></p><p id="0a71" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">到现在为止，您可能已经知道这些“偏好”是为了展示各种 <code class="fe mj mk ml mm b"><em class="mf">Beam</em></code> <em class="mf">功能——这不是一个花哨的推荐引擎，我们并不真正关心输出</em></p><h1 id="9676" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">绘制设计</h1><p id="0ea6" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">正如我在引言中所说的，我们可以先从设计管道开始，然后再讨论特定于语言的逻辑。</p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div class="gh gi of"><img src="../Images/79984df8e92a8aa5acd8431e7126389f.png" data-original-src="https://miro.medium.com/v2/resize:fit:602/format:webp/1*olttE5JeFlUr_7zfAEatyA.png"/></div><p class="mz na gj gh gi nb nc bd b be z dk translated"><a class="ae mb" href="https://chollinger.com/blog/2020/07/a-data-engineering-perspective-on-go-vs.-python-part-2-dataflow/#drawing-the-design" rel="noopener ugc nofollow" target="_blank">https://CHOL linger . com/blog/2020/07/a-data-engineering-perspective-on-go-vs .-python-part-2-data flow/# drawing-the-design</a></p></figure><p id="e28b" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">这里我们有两个主要的流程，它们做类似的事情:它们读取数据，解析数据格式，并对数据应用自定义过滤器。接下来，它们被组合成一个一致的集合，并写入一个或多个 I/O 目标。</p><p id="c992" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">让我们来看看如何把它翻译成代码。</p><h1 id="d4fd" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">获取数据</h1><p id="e9cf" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果你同意 IMDb 的许可证，你可以在这里找到数据<a class="ae mb" href="https://datasets.imdbws.com/" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="461f" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">我们将从基本的标题数据开始，并确保我们从一个小的测试集开始，这样我们就可以在没有集群的情况下进行本地开发。为了做到这一点，我们将获取随机测试数据，以及一部我们知道符合我们标准的电影，1971 年的经典“消失点”，id 为<code class="fe mj mk ml mm b">tt0067927</code>(因为我们不太可能在我们将使用的 2 个数据集之间找到更多匹配，否则，鉴于体积)。</p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="063c" class="nr kj it mm b gy ok ol l om on">wget https://datasets.imdbws.com/title.basics.tsv.gz &amp;&amp; gunzip title.basics.tsv.gz <br/># Create a small test file<br/>head -1 title.basics.tsv &gt; title.basics.100.tsv<br/>shuf -n 100 title.basics.tsv &gt;&gt; title.basics.100.tsv<br/>grep "tt0067927" title.basics.tsv &gt;&gt; title.basics.100.tsv</span></pre><h2 id="3fad" class="nr kj it bd kk ns nt dn ko nu nv dp ks lj nw nx ku ln ny nz kw lr oa ob ky oc bi translated"><code class="fe mj mk ml mm b">title.basics</code></h2><p id="cb78" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">该数据集包含基本标题信息，并且是一个<em class="mf"> 564MB 制表符分隔文件</em>。</p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi oo"><img src="../Images/e6bebbb77f8482512aa5bc174a20d4f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3gwisM-KmNRFJ9CSHjfqDA.png"/></div></div><p class="mz na gj gh gi nb nc bd b be z dk translated"><a class="ae mb" href="https://chollinger.com/blog/2020/07/a-data-engineering-perspective-on-go-vs.-python-part-2-dataflow/#getting-data" rel="noopener ugc nofollow" target="_blank">https://CHOL linger . com/blog/2020/07/a-data-engineering-perspective-on-go-vs .-python-part-2-data flow/# getting-data</a></p></figure><p id="ec7b" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">我们将用它来过滤大部分记录。</p><h2 id="b1cf" class="nr kj it bd kk ns nt dn ko nu nv dp ks lj nw nx ku ln ny nz kw lr oa ob ky oc bi translated"><code class="fe mj mk ml mm b">title.ratings</code></h2><p id="d628" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">该数据集包含所有标题的评级，并且是一个<em class="mf"> 18MB 制表符分隔文件</em>。</p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi op"><img src="../Images/cfc072ab57e11543201b5864fd51d3a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pK9fG-PkpEdKWFdLSKbPMw.png"/></div></div><p class="mz na gj gh gi nb nc bd b be z dk translated"><a class="ae mb" href="https://chollinger.com/blog/2020/07/a-data-engineering-perspective-on-go-vs.-python-part-2-dataflow/#getting-data" rel="noopener ugc nofollow" target="_blank">https://CHOL linger . com/blog/2020/07/a-data-engineering-perspective-on-go-vs .-python-part-2-data flow/# getting-data</a></p></figure><h1 id="b61a" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">创建管道</h1><p id="08d0" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们的 Beam 管道的第一步是创建一个创建<code class="fe mj mk ml mm b">Pipeline</code>对象的框架代码，解析参数，并设置一个记录器。</p><h1 id="ee51" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">计算机编程语言</h1><p id="e614" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们首先需要通过运行<code class="fe mj mk ml mm b">pip3 install --upgrade pip</code>和<code class="fe mj mk ml mm b">pip3 install apache-beam==2.22.0 --upgrade</code>来安装 Beam。</p><p id="e393" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">我们的框架使用<code class="fe mj mk ml mm b">Python</code>的标准<code class="fe mj mk ml mm b">logger</code>模块来记录日志，使用<code class="fe mj mk ml mm b">argparse</code>来读取将要传递给管道的参数。</p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="9d57" class="nr kj it mm b gy ok ol l om on">from __future__ import absolute_import<br/><br/>import argparse<br/>import logging<br/>import apache_beam as beam<br/>from apache_beam.io import ReadFromText<br/>from apache_beam.io import WriteToText<br/>from apache_beam.options.pipeline_options import PipelineOptions, GoogleCloudOptions<br/>from apache_beam.options.pipeline_options import SetupOptions<br/><br/>def run(argv=None):<br/>    # Parse arguments<br/>    parser = argparse.ArgumentParser()<br/>    parser.add_argument('--input-ratings',<br/>                        dest='input_ratings',<br/>                        required=True,<br/>                        help='Input rating file to process.')<br/>    parser.add_argument('--input-titles',<br/>                        dest='input_titles',<br/>                        required=True,<br/>                        help='Input title file to process.')<br/>    parser.add_argument('--output',<br/>                        dest='output',<br/>                        required=True,<br/>                        help='Output to write results to.')<br/>    known_args, pipeline_args = parser.parse_known_args(argv)<br/><br/>    pipeline_options = PipelineOptions(pipeline_args)<br/>    pipeline_options.view_as(SetupOptions).save_main_session = True<br/><br/>    # Create the pipeline<br/>    with beam.Pipeline(options=pipeline_options) as p:<br/>        # TODO: Run it<br/>        pass<br/><br/>if __name__ == '__main__':<br/>    # Set the logger<br/>    logging.getLogger().setLevel(logging.INFO)<br/>    logging.basicConfig(format='%(asctime)s,%(msecs)d %(levelname)-8s [%(filename)s:%(lineno)d] %(message)s',<br/>        datefmt='%Y-%m-%d:%H:%M:%S',<br/>        level=logging.INFO)<br/>    # Run the core pipeline<br/>    logging.info('Starting')<br/>    run()</span></pre><p id="44a9" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">这里没有太多需要注意的地方——我们所有的管道代码都在<code class="fe mj mk ml mm b">with</code>块下，一旦我们编写了自己的步骤，它将定义我们刚刚设计的<code class="fe mj mk ml mm b">DAG</code>。</p><h1 id="f572" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">去</h1><p id="2066" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">对于<code class="fe mj mk ml mm b">go</code>，我们可以通过<code class="fe mj mk ml mm b">go get</code>安装<code class="fe mj mk ml mm b">beam</code>，而不是通过<code class="fe mj mk ml mm b">go get -u github.com/apache/beam/sdks/go/...</code>安装<code class="fe mj mk ml mm b">pip</code></p><p id="fe1b" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">接下来，我们的管道框架将使用<code class="fe mj mk ml mm b">flags</code>包作为参数，使用<code class="fe mj mk ml mm b">log</code>作为日志。</p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="d2e4" class="nr kj it mm b gy ok ol l om on">package main<br/><br/>import (<br/>	"context"<br/>	"flag"<br/>	"log"<br/><br/>	"github.com/apache/beam/sdks/go/pkg/beam"<br/>	"github.com/apache/beam/sdks/go/pkg/beam/io/textio"<br/>	"github.com/apache/beam/sdks/go/pkg/beam/x/beamx"<br/>)<br/><br/>func main() {<br/>	// Define arguments<br/>	var inputBasePath = flag.String("input-basics", "", "Input base file")<br/>	var inputRatingsPath = flag.String("input-ratings", "", "Input ratings file")<br/>	var outputPath = flag.String("output", "", "Output path")<br/>	// Parse flags<br/>	flag.Parse()<br/><br/>	// Initialize Beam<br/>	beam.Init()<br/><br/>	// Input validation. Must be after Init().<br/>	if *inputBasePath == "" || *inputRatingsPath == "" || *outputPath == "" {<br/>		log.Fatal("Usage: movie_pipeline --input-basics $PATH, --input-ratings $PATH --output $PATH")<br/>	}<br/><br/>	// Create a Pipeline<br/>	p := beam.NewPipeline()<br/>	s := p.Root()<br/><br/>    // Pipeline code<br/><br/>	// Concept #1: The beamx.Run convenience wrapper allows a number of<br/>	// pre-defined runners to be used via the --runner flag.<br/>	if err := beamx.Run(context.Background(), p); err != nil {<br/>		log.Fatalf("Failed to execute job: %v", err)<br/>	}<br/>}</span></pre><p id="c381" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">这里有几个值得注意的地方。首先，<code class="fe mj mk ml mm b">flags</code>包不支持强制属性，因此我们必须手动检查由<code class="fe mj mk ml mm b">flag.Parse()</code>传递的字符串指针。你会在整个代码中发现类似的块，因为<code class="fe mj mk ml mm b">go</code>不知道<code class="fe mj mk ml mm b">Exception</code>的概念，因此，错误是返回元素(例如，一个函数可能返回一个数据元组和一个可选错误)，需要手动检查。</p><p id="ea0a" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">此外，注意如何在输入验证之前调用<code class="fe mj mk ml mm b">beam.Init()</code>。</p><h1 id="26ca" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">读取和解析数据</h1><p id="bebe" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">接下来，我们需要读取数据并解析<code class="fe mj mk ml mm b">TSV</code>格式。我们可以使用我们的第一个<code class="fe mj mk ml mm b">ParDo</code>调用来实现这一点。</p><h1 id="b8f8" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">计算机编程语言</h1><p id="e26e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">首先，让我们通过创建<code class="fe mj mk ml mm b">beam.DoFn</code>的子类来定义<code class="fe mj mk ml mm b">ParDo</code>操作，如下所示:</p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="b20c" class="nr kj it mm b gy ok ol l om on">class ParseCsv(beam.DoFn):<br/>    def __init__(self, col_names: list):<br/>        self.col_names = col_names<br/><br/>    def process(self, string: str):<br/>        reader = csv.DictReader(string.splitlines(), fieldnames=self.col_names, delimiter='\t')<br/>        for row in reader:<br/>            yield row</span></pre><p id="eb7c" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">这个类将简单地把我们的 CSV 从行<code class="fe mj mk ml mm b">str</code>解析成一个<code class="fe mj mk ml mm b">dict</code>，给我们<code class="fe mj mk ml mm b">dict</code>作为单独的元素在下一个<code class="fe mj mk ml mm b">transforms</code>中使用。</p><p id="08f6" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">对于自定义<code class="fe mj mk ml mm b">ParDo</code>，方法<code class="fe mj mk ml mm b">process</code>必须被覆盖。<code class="fe mj mk ml mm b">process</code>应该是一个<code class="fe mj mk ml mm b">generator</code>并因此，不得不<code class="fe mj mk ml mm b">yield</code>单独记录。对于 <code class="fe mj mk ml mm b"><em class="mf">PCollection</em></code>中的每条记录，该函数将被调用<em class="mf">。如果我们用<code class="fe mj mk ml mm b">return</code>代替<code class="fe mj mk ml mm b">yield</code>，你马上就会看到会发生什么。</em></p><p id="89c0" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">自定义参数可以通过覆盖<code class="fe mj mk ml mm b">__init__()</code>中的<code class="fe mj mk ml mm b">constructor</code>传递给类。</p><p id="d602" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">为了将它与管道集成，我们需要定义流程。在<code class="fe mj mk ml mm b">Beam Python SDK</code>中，<code class="fe mj mk ml mm b">&gt;&gt;</code>和<code class="fe mj mk ml mm b">|</code>操作符在<code class="fe mj mk ml mm b">PCollection</code>之上定义了我们单独的加工(<code class="fe mj mk ml mm b">apply</code>)步骤。</p><p id="9f39" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">对于每个步骤，我们可以调用<code class="fe mj mk ml mm b">beam.ParDo</code>并提供一个<code class="fe mj mk ml mm b">DoFn</code>子类的实例。</p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="4e90" class="nr kj it mm b gy ok ol l om on">with beam.Pipeline(options=pipeline_options) as p:<br/>    (p  | 'Read data' &gt;&gt; beam.io.ReadFromText(known_args.input_titles, skip_header_lines=1)<br/>        | 'Parse CSV' &gt;&gt; beam.ParDo(ParseCsv(['titleId', 'ordering','title','region','language','types','attributes','isOriginalTitle']))<br/>        | 'Print' &gt;&gt; beam.Map(print)<br/>    )</span></pre><p id="1617" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">这将读取文本文件，解析<code class="fe mj mk ml mm b">TSV</code>，产生一个<code class="fe mj mk ml mm b">PCollection</code>，并使用<code class="fe mj mk ml mm b">map</code>简单地打印值。</p><p id="2e6e" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">输出如下所示:</p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="fd7b" class="nr kj it mm b gy ok ol l om on">{'titleId': 'tt0000001', 'ordering': '1', 'title': 'Карменсіта', 'region': 'UA', 'language': '\\N', 'types': 'imdbDisplay', 'attributes': '\\N', 'isOriginalTitle': '0'}<br/>{'titleId': 'tt0000001', 'ordering': '2', 'title': 'Carmencita', 'region': 'DE', 'language': '\\N', 'types': '\\N', 'attributes': 'literal title', 'isOriginalTitle': '0'}</span></pre><p id="287d" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">这个简单的起点展示了<code class="fe mj mk ml mm b">Beam</code>与<code class="fe mj mk ml mm b">Python</code>一起使用的非常具体的语法。虽然它确实创建了一个清晰易读的逻辑，但它肯定比常规的方法链接方法更容易让人混淆。</p><h1 id="dbb7" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">去</h1><p id="3839" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在这里，我们可能会看到<code class="fe mj mk ml mm b">Python</code>和<code class="fe mj mk ml mm b">go</code>之间一些最显著的差异——但正如我所发现的，也有同样显著的相似之处。</p><p id="a721" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">读取数据并应用下一个<code class="fe mj mk ml mm b">ParDo</code>并不遵循<code class="fe mj mk ml mm b">Python</code>的重载语法(使用<code class="fe mj mk ml mm b">&gt;&gt;</code>和<code class="fe mj mk ml mm b">|</code>)<em class="mf">，而是导致在每个步骤</em>后返回各种 <code class="fe mj mk ml mm b"><em class="mf">PCollections</em></code> <em class="mf">:</em></p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="e00d" class="nr kj it mm b gy ok ol l om on">// Parse the movies file<br/>	lines_movies := textio.Read(s, *inputBasePath)<br/>	base_movies := beam.ParDo(s, &amp;movieFn{}, lines_movies)</span></pre><p id="78bc" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">虽然这可能看起来与<code class="fe mj mk ml mm b">Python</code>非常不同，但从根本上来说，发生了同样的事情:图形的每一步都返回一个<em class="mf">新的</em> <code class="fe mj mk ml mm b"><em class="mf">PCollection</em></code>，下一步可以对其进行处理。</p><p id="dfce" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">这里要提到的另一件事是指针的使用。<code class="fe mj mk ml mm b">*inputBasePath</code>是指向我们之前给出的<code class="fe mj mk ml mm b">flags</code>参数的指针。在<code class="fe mj mk ml mm b">go</code>中，一个<code class="fe mj mk ml mm b">*string</code>可以是<code class="fe mj mk ml mm b">nil</code>，而普通的字符串则不能(因为<code class="fe mj mk ml mm b">go</code>中的<code class="fe mj mk ml mm b">nil</code>表示“它不指向任何东西”，而<code class="fe mj mk ml mm b">string</code>只能是空的或者被字符填充——下面会详细介绍)。众所周知，<code class="fe mj mk ml mm b">Python</code>没有暴露的指针(T21 的另一种主要语言<code class="fe mj mk ml mm b">Java</code>也没有)。</p><p id="9681" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">下一个看起来非常不同的东西是实际的<code class="fe mj mk ml mm b">ParDo</code>。我们来分析一下。</p><p id="1190" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated"><code class="fe mj mk ml mm b">Beam</code>的泛型<code class="fe mj mk ml mm b">ParDo</code>函数签名如下:</p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="3b81" class="nr kj it mm b gy ok ol l om on">func ParDo(s Scope, dofn interface{}, col PCollection, opts ...Option) PCollection {<br/>	ret := MustN(TryParDo(s, dofn, col, opts...))<br/>	if len(ret) != 1 {<br/>		panic(formatParDoError(dofn, len(ret), 1))<br/>	}<br/>	return ret[0]<br/>}</span></pre><p id="0f1b" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">其中<code class="fe mj mk ml mm b">s Scope</code>是你的<code class="fe mj mk ml mm b">pipeline</code>对象，<code class="fe mj mk ml mm b">dofn interface{}</code>使用<code class="fe mj mk ml mm b">go</code>的<code class="fe mj mk ml mm b">empty interface</code>逻辑来定义一个可能保存任何类型的值的接口(我一会儿再回到那个)，而<code class="fe mj mk ml mm b">col</code>显然是我们的<code class="fe mj mk ml mm b">PCollection</code>，类似于我们在<code class="fe mj mk ml mm b">Python</code>中看到的。</p><p id="bb72" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">这意味着<code class="fe mj mk ml mm b">beam.ParDo(s, &amp;movieFn{}, lines_movies)</code>简单地声明:应用函数<code class="fe mj mk ml mm b">moveFn</code>，它必须是一个<code class="fe mj mk ml mm b">ParDo</code>(记住:静态类型！)，并将名为<code class="fe mj mk ml mm b">line_movies</code>的<code class="fe mj mk ml mm b">PCollection</code>作为输入。</p><p id="3e55" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">一旦理解了语法，这与</p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="7637" class="nr kj it mm b gy ok ol l om on">| 'Parse CSV' &gt;&gt; beam.ParDo(ParseCsv(['titleId', 'ordering','title','region','language','types','attributes','isOriginalTitle']))</span></pre><p id="8d7b" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">在 Python 中。</p><p id="31ac" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">我们将在下一节看看<code class="fe mj mk ml mm b">&amp;movieFn{}</code>做了什么。无论如何，在这一点上，我们有了输入<code class="fe mj mk ml mm b">TSV</code>中每一行的结构化表示。</p><h1 id="e26c" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">转换数据</h1><p id="094d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">接下来，我们需要转换我们的数据，以确保我们有可以在输出中使用的正确的数据类型，并确保我们在接下来的步骤中的<code class="fe mj mk ml mm b">filter</code>逻辑是清晰的。</p><h1 id="985c" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">计算机编程语言</h1><p id="8b86" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">请注意上面输出中的<code class="fe mj mk ml mm b">NULL</code>是如何被引用为<code class="fe mj mk ml mm b">\N</code>的，以及<code class="fe mj mk ml mm b">isOriginalTitle</code>听起来像是<code class="fe mj mk ml mm b">boolean</code>，但实际上是<code class="fe mj mk ml mm b">integer</code>。</p><p id="2b13" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">我们可以简单地创建另一个<code class="fe mj mk ml mm b">ParDo</code>转换来处理这个场景。为了避免每个文件只有一个<code class="fe mj mk ml mm b">ParDo</code>类，我们将使它动态化。</p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="6540" class="nr kj it mm b gy ok ol l om on">class CleanData(beam.DoFn):<br/>    def __init__(self, bool_cols=[]):<br/>        self.bool_cols = bool_cols<br/><br/>    def process(self, record: dict):<br/>        for k in record:<br/>            # Map \N to None<br/>            if record[k] == '\\N':<br/>                record[k] = None<br/>        # Convert e.g., `isOriginalTitle` to Boolean<br/>        for col in self.bool_cols:<br/>            if record[col] == '0': <br/>                record[col] = False<br/>            else:<br/>                record[col] = True<br/>        # Return<br/>        yield record</span></pre><p id="34c2" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">因为<code class="fe mj mk ml mm b">Python</code> <code class="fe mj mk ml mm b">dicts</code>可以接受任意类型，所以简单地在 dict 中改变值是很容易的。请注意我们必须如何将<code class="fe mj mk ml mm b">0</code>视为<code class="fe mj mk ml mm b">string</code>，因为<code class="fe mj mk ml mm b">Python</code>是动态类型的，在这里不强制类型，并且给定 TSV 输入，一切都是<code class="fe mj mk ml mm b">str</code>。</p><p id="9b05" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">此时，您可能会发现自己处于两种思想流派之一:要么，您很高兴<code class="fe mj mk ml mm b">Python</code>允许您使用<code class="fe mj mk ml mm b">dicts</code>编写管道，而不关心它们各自的类型(甚至不关心<code class="fe mj mk ml mm b">dict</code>中字段的数量或名称)！)——这使得编写管道更加容易。</p><p id="468c" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">或者，你遗漏了<code class="fe mj mk ml mm b">Java</code>和<code class="fe mj mk ml mm b">go</code>强制的严格打字。在这两种情况下，在将任何数据持久化到任何地方之前，我们都被迫关心结构和类型，以避免无效的转换或错误的输出到我们的目标系统中。</p><h1 id="1ccb" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">去</h1><p id="1b52" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">对于<code class="fe mj mk ml mm b">go</code>，让我们重温一下之前的<code class="fe mj mk ml mm b">&amp;movieFn{}</code>论点。</p><p id="4b8e" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">我们已经创建了一个名为<code class="fe mj mk ml mm b">moveFn</code>的<code class="fe mj mk ml mm b">struct</code>，它保存了我们的数据结构及其类型:</p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="ff88" class="nr kj it mm b gy ok ol l om on">type movieFn struct {<br/>	tconst, titleType, primaryTitle, originalTitle string<br/>	isAdult                                        bool<br/>	startYear, endYear, runtimeMinutes             int64<br/>	genres                                         string<br/>}</span></pre><p id="799e" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">然后我们在这个<code class="fe mj mk ml mm b">struct</code>上定义一个<code class="fe mj mk ml mm b">ParDo</code>方法:</p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="0100" class="nr kj it mm b gy ok ol l om on">func (f *movieFn) ProcessElement(line string, emit func(movieFn)) {<br/>	row := strings.Split(line, "\t")<br/>	fmt.Printf("%v\n", row)<br/>	// Skip the header<br/>	if row[0] != "tconst" {<br/>		// Map nulls<br/><br/>		// Convert the types<br/>		startYear, err1 := strconv.ParseInt(row[5], 10, 64)<br/>		endYear, _ := strconv.ParseInt(row[6], 10, 64)<br/>		runtimeMinutes, err3 := strconv.ParseInt(row[7], 10, 64)<br/>		// Convert Boolean<br/>		isAdultInt, err4 := strconv.ParseInt(row[4], 10, 64)<br/>		var isAdult bool<br/>		if isAdultInt == 0 {<br/>			isAdult = false<br/>		} else {<br/>			isAdult = true<br/>		}<br/>		if err1 == nil &amp;&amp; err3 == nil &amp;&amp; err4 == nil {<br/>			// If the types match, return a rating struct<br/>			m := movieFn{<br/>				tconst:         row[0],<br/>				titleType:      row[1],<br/>				primaryTitle:   row[2],<br/>				originalTitle:  row[3],<br/>				isAdult:        isAdult,<br/>				startYear:      startYear,<br/>				endYear:        endYear,<br/>				runtimeMinutes: runtimeMinutes,<br/>				genres:         row[8],<br/>			}<br/>			fmt.Printf("%v\n", m)<br/>			emit(m)<br/>		}<br/>	}<br/>}</span></pre><p id="9be3" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">它将解析行和将类型转换成单个的<code class="fe mj mk ml mm b">ParDo</code>结合起来。我们在 Python 中对此进行了分解以解释概念，但从根本上来说，发生了同样的事情:我们需要通过分隔符<code class="fe mj mk ml mm b">tab</code>来分割行，并创建一个类似<code class="fe mj mk ml mm b">json</code>的结构(这就是这个<code class="fe mj mk ml mm b">struct</code>将在内部序列化的内容！).</p><p id="44ce" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">为了避免不得不处理多个<code class="fe mj mk ml mm b">structs</code>，因为我们(与 Python 相反)不能简单地“重用<code class="fe mj mk ml mm b">dict</code>和改变类型【0】，我们在一个单一的步骤中进行转换。</p><p id="a9fb" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">在对<code class="fe mj mk ml mm b">ParDo</code>的实际调用中，<code class="fe mj mk ml mm b">&amp;movieFn{}</code>简单地翻译为“对<code class="fe mj mk ml mm b">movieFn</code>结构的内存位置的引用，它被初始化为空”。</p><p id="ff45" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">最后但同样重要的是，注意函数的返回是怎样的<code class="fe mj mk ml mm b">emit func(movieFn))</code>。<code class="fe mj mk ml mm b">Beam</code> SDK 使用反射从传入和传出的<code class="fe mj mk ml mm b">PCollections</code>中收集类型，在我们的例子中，输入为<code class="fe mj mk ml mm b">line string</code>，输出为<code class="fe mj mk ml mm b">movieFn</code>——通过指定一个函数作为<em class="mf">输入</em>，我们称之为类似于<code class="fe mj mk ml mm b">Python</code>的本机<code class="fe mj mk ml mm b">yield</code>。请注意实际的函数<em class="mf">没有返回任何东西</em>，因为<code class="fe mj mk ml mm b">emit</code>函数是我们的<code class="fe mj mk ml mm b">ParDo</code>的一个参数！</p><p id="7a91" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">您可以将这个函数称为任何东西— <code class="fe mj mk ml mm b">emit</code>只是在<a class="ae mb" href="https://github.com/apache/beam/tree/master/sdks/go/examples" rel="noopener ugc nofollow" target="_blank"> go 示例</a>中找到的样式。</p><p id="09cd" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">应该注意的是，这个<code class="fe mj mk ml mm b">struct</code>当然也可以通过简单地提供更多的方法来保存自定义方法(类似于<code class="fe mj mk ml mm b">Python</code>类)。</p><p id="1965" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">让我们重新访问一下<code class="fe mj mk ml mm b">string</code>和<code class="fe mj mk ml mm b">nil</code>注释，并尝试将<code class="fe mj mk ml mm b">'\N'</code>转换为<code class="fe mj mk ml mm b">nil</code>以匹配我们的<code class="fe mj mk ml mm b">Python</code>管道，假设我们想要一个<code class="fe mj mk ml mm b">NULL</code>类型用于将数据写入例如<code class="fe mj mk ml mm b">BigQuery</code>:</p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="9b82" class="nr kj it mm b gy ok ol l om on">func (f *movieFn) CleanNulls(row []string, nullColIds []int) []string {<br/>	for i, _ := range row {<br/>		if row[i] == "\\N" {<br/>			row[i] = nil<br/>		}<br/>	}<br/>	return row<br/>}</span></pre><p id="7d55" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">当然，编译器不接受:</p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="31bd" class="nr kj it mm b gy ok ol l om on">cannot use nil as type string in assignment</span></pre><p id="5e97" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">一种解决方法是使用<code class="fe mj mk ml mm b">*string</code>或者跟随，例如<code class="fe mj mk ml mm b"><a class="ae mb" href="https://godoc.org/cloud.google.com/go/bigquery#InferSchema" rel="noopener ugc nofollow" target="_blank">bigquery-&gt;InterSchema</a></code>将<code class="fe mj mk ml mm b">NULL</code>映射到期望它用于字符串的系统。</p><p id="39fa" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">此外，我们需要确保我们不会意外地导出这个方法，否则，我们将得到:</p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="910a" class="nr kj it mm b gy ok ol l om on">graph.AsDoFn: unexpected exported method CleanNulls present. Valid methods are: [Setup StartBundle ProcessElement FinishBundle Teardown CreateInitialRestriction SplitRestriction RestrictionSize CreateTracker</span></pre><p id="644b" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">这可以通过以小写字母“c”开始函数而简单地不导出它来解决:</p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="63e6" class="nr kj it mm b gy ok ol l om on">func (f *movieFn) cleanNulls(row []string) []string {<br/>	for i, _ := range row {<br/>		if row[i] == "\\N" {<br/>			row[i] = ""<br/>		}<br/>	}<br/>	return row<br/>}</span></pre><p id="36e7" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">这是与<code class="fe mj mk ml mm b">Python</code>的另一个区别，因为<code class="fe mj mk ml mm b">go</code>确保我们遵循预期的<code class="fe mj mk ml mm b">interface</code>。</p><p id="d918" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">虽然我个人确实认为逻辑<code class="fe mj mk ml mm b">go</code>强加了一个<code class="fe mj mk ml mm b">String</code>要么为空要么不为空，拥有两个不同的“空”类型并没有增加多少价值，但是从<code class="fe mj mk ml mm b">Python</code>或<code class="fe mj mk ml mm b">Java</code>的角度来看，我可以看到这对来自<code class="fe mj mk ml mm b">go</code>的人来说是非常令人不快的。</p><p id="14cf" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">我想我们可以用一个 <code class="fe mj mk ml mm b"><em class="mf">interface{}</em></code></p><h1 id="04ac" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">过滤数据</h1><p id="6304" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">接下来，我们要过滤数据，以确保我们只获得我们想要的电影和收视率。</p><h1 id="e5b5" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">计算机编程语言</h1><p id="b419" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">过滤数据可以通过使用另一个<code class="fe mj mk ml mm b">ParDo</code>类来完成，但是带有一个 catch。让我们试试这个:</p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="3bfa" class="nr kj it mm b gy ok ol l om on">class FilterBasicData(beam.DoFn):<br/>    def process(self, record: dict):<br/>        if record['titleType'] == 'movie' and not record['isAdult']:<br/>            yield record<br/>        else:<br/>            yield None</span></pre><p id="a3c6" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">输出看起来很糟糕:</p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="0fd8" class="nr kj it mm b gy ok ol l om on">None<br/>{'tconst': 'tt3080844', 'titleType': 'movie', 'primaryTitle': 'Almost Holy', 'originalTitle': 'Crocodile Gennadiy', 'isAdult': False, 'startYear': '2015', 'endYear': None, 'runtimeMinutes': '96', 'genres': 'Biography,Documentary,Drama'}<br/>None</span></pre><p id="c220" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">然而，如果我们回忆起<code class="fe mj mk ml mm b">DoFn</code>是一个生成器(而不仅仅是一个出于某种原因使用<code class="fe mj mk ml mm b">yield</code>而不是<code class="fe mj mk ml mm b">return</code>的方法)，我们可以快速使用它，简单地让<em class="mf">不返回无效记录</em>(以及添加我们的其他过滤标准)，从而创建一个更小的<code class="fe mj mk ml mm b">PCollection</code>来处理:</p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="2d82" class="nr kj it mm b gy ok ol l om on">class FilterBasicData(beam.DoFn):<br/>    def process(self, record: dict):<br/>        if record['titleType'] == 'movie' and not record['isAdult']: <br/>            yield record<br/>        # No else - no yield</span></pre><p id="728e" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">并获得看起来不错的输出:</p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="de94" class="nr kj it mm b gy ok ol l om on">{'tconst': 'tt3080844', 'titleType': 'movie', 'primaryTitle': 'Almost Holy', 'originalTitle': 'Crocodile Gennadiy', 'isAdult': False, 'startYear': '2015', 'endYear': None, 'runtimeMinutes': '96', 'genres': 'Biography,Documentary,Drama'}<br/>{'tconst': 'tt7497202', 'titleType': 'movie', 'primaryTitle': 'Wonderful Losers: A Different World', 'originalTitle': 'Wonderful Losers: A Different World', 'isAdult': False, 'startYear': '2017', 'endYear': None, 'runtimeMinutes': '71', 'genres': None}</span></pre><p id="b67a" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">但是我们的按年过滤呢？如果我们尝试把<code class="fe mj mk ml mm b">and record['startYear'] &gt;= 1970:</code>作为一个条件，我们会遇到:</p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="045a" class="nr kj it mm b gy ok ol l om on">TypeError: '&gt;=' not supported between instances of 'str' and 'int' [while running 'Filter data']</span></pre><p id="5a1b" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">因为 Python 缺乏严格的类型(还记得我们是如何在任何地方都没有定义模式的)。我们可以通过扩展<code class="fe mj mk ml mm b">CleanData</code>来修复这个问题:</p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="f2ed" class="nr kj it mm b gy ok ol l om on">class CleanData(beam.DoFn):<br/>    def __init__(self, bool_cols=[], int_cols=[]):<br/>        self.bool_cols = bool_cols<br/>        self.int_cols = int_cols<br/><br/>    def process(self, record: dict):<br/>        for k in record:<br/>            # Map \N to None<br/>            if record[k] == '\\N':<br/>                record[k] = None<br/>        # Convert e.g., `isOriginalTitle` to Boolean<br/>        for col in self.bool_cols:<br/>            if record[col] == '0':<br/>                record[col] = False<br/>            else:<br/>                record[col] = True<br/>        # Force-parse numeric values<br/>        for col in self.int_cols:<br/>            if record[col] and record[col].isdigit():<br/>                record[col] = int(record[col])<br/>        # Return<br/>        yield record</span></pre><p id="04b1" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">并将我们的过滤器调整为:</p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="5903" class="nr kj it mm b gy ok ol l om on">class FilterBasicData(beam.DoFn):<br/>    def process(self, record: dict):<br/>        if record['titleType'] == 'movie' and not record['isAdult'] and record['startYear'] and record['startYear'] &gt;= 1970:<br/>            yield record<br/>        # No else - no yield</span></pre><p id="c5bd" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">这给了我们一个电影列表。</p><h1 id="a915" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">去</h1><p id="242c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这里的过滤和<code class="fe mj mk ml mm b">go</code>没有太大区别。我们可以犯和在<code class="fe mj mk ml mm b">Python</code>中一样的错误，但是混淆<code class="fe mj mk ml mm b">return</code>和(在本例中)一个<code class="fe mj mk ml mm b">emit</code>函数:</p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="d1ee" class="nr kj it mm b gy ok ol l om on">// Filters Movies<br/>func filterMovies(movie movieFn) movieFn {<br/>	if !movie.isAdult &amp;&amp; movie.startYear &gt;= 1970 {<br/>		return movie<br/>	}<br/>	return movieFn{}<br/>}</span></pre><p id="ab69" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">它会回来的</p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="c788" class="nr kj it mm b gy ok ol l om on">{    false 0 0 0 }<br/>{tt3080844 movie Almost Holy Crocodile Gennadiy false 2015 0 96 Biography,Documentary,Drama}<br/>{    false 0 0 0 }</span></pre><p id="46f4" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">而我们在上一节中讨论的方法是可行的:</p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="13d7" class="nr kj it mm b gy ok ol l om on">// Filters Movies<br/>func filterMovies(movie movieFn, emit func(movieFn)) {<br/>	if !movie.isAdult &amp;&amp; movie.startYear &gt;= 1970 {<br/>		emit(movie)<br/>	}<br/>}</span></pre><p id="7934" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">请注意我们的静态类型的<code class="fe mj mk ml mm b">struct</code>不会有任何<code class="fe mj mk ml mm b">TypeError: '&gt;=' not supported between instances of 'str' and 'int'</code>类型的问题</p><h1 id="df92" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">侧面输入、CoGroupByKey 和连接</h1><p id="07f5" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">由于<code class="fe mj mk ml mm b">IMDb</code>数据的关系性质，我们将不得不处理多个文件来获得我们需要的所有标准。</p><p id="5a52" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">有两种主要的方法可以做到这一点:<code class="fe mj mk ml mm b">Side Inputs</code>，如果数据足够小，可以轻松地放入内存，或者<code class="fe mj mk ml mm b">CoGroupByKey</code>，这是一种更昂贵的变体，会导致<code class="fe mj mk ml mm b">shuffle</code>。</p><p id="059a" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">尽管我们只需要一种方法，但我们将两者都考虑。</p><p id="10e3" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">让我们获取评级数据，并从上面的输出中抓取一些记录，以确保我们至少有一个匹配:</p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="9bb3" class="nr kj it mm b gy ok ol l om on">wget https://datasets.imdbws.com/title.ratings.tsv.gz &amp;&amp; gunzip title.ratings.tsv.gz <br/># Create a small test file<br/>head -1 title.ratings.tsv &gt; title.ratings.100.tsv # header<br/>shuf -n 100 title.ratings.tsv &gt;&gt; title.ratings.100.tsv<br/>grep "tt0067927" title.ratings.tsv &gt;&gt; title.ratings.100.tsv</span></pre><h1 id="6ce0" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">CoGroupByKey</h1><p id="b2de" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">首先我们来看看<code class="fe mj mk ml mm b">CoGroupByKey</code>。这通常是更明智的选择，除非其中一个数据集的大小要小得多，并且可以作为内存中的数据传递<code class="fe mj mk ml mm b">Side Input</code>。</p><h1 id="c5e9" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">计算机编程语言</h1><p id="4e17" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们可以简单地分割我们的管道，这一次，返回一个<code class="fe mj mk ml mm b">PCollection</code>而不是将它传递给<code class="fe mj mk ml mm b">beam.Map(print)</code>。</p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="6449" class="nr kj it mm b gy ok ol l om on">with beam.Pipeline(options=pipeline_options) as p:<br/>        basic_data = (p | 'Read data' &gt;&gt; beam.io.ReadFromText(known_args.input_basics, skip_header_lines=1)<br/>           | 'Parse CSV' &gt;&gt; beam.ParDo(ParseCsv(columns_title_basic))<br/>           | 'Clean data' &gt;&gt; beam.ParDo(CleanData(bool_cols=['isAdult'], int_cols=['startYear', 'endYear', 'runtimeMinutes']))<br/>           | 'Filter data' &gt;&gt; beam.ParDo(FilterBasicData())<br/>         )</span></pre><p id="3f49" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">由于<code class="fe mj mk ml mm b">side inputs</code>不是<code class="fe mj mk ml mm b">PCollections</code>，我们可以使用<code class="fe mj mk ml mm b">Map</code>将<code class="fe mj mk ml mm b">ratings</code>转换为静态的<code class="fe mj mk ml mm b">json</code>:</p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="0189" class="nr kj it mm b gy ok ol l om on">rating_data = (p | 'Read data (Details)' &gt;&gt; beam.io.ReadFromText(known_args.input_ratings, skip_header_lines=1)<br/>           | 'Parse CSV (Details)' &gt;&gt; beam.ParDo(ParseCsv(columns_ratings))<br/>           | 'Clean data (Details)' &gt;&gt; beam.ParDo(CleanData(int_cols=['numVotes'], float_cols=['averageRating']))<br/>           | 'Filter data (Details)' &gt;&gt; beam.ParDo(FilterRatingData())<br/>         )<br/><br/>        rating_data = (p | 'Read data (Details)' &gt;&gt; beam.io.ReadFromText(known_args.input_ratings, skip_header_lines=1)<br/>           | 'Parse CSV (Details)' &gt;&gt; beam.ParDo(ParseCsv(columns_ratings))<br/>           | 'Clean data (Details)' &gt;&gt; beam.ParDo(CleanData(int_cols=['numVotes'], float_cols=['averageRating']))<br/>           | 'Filter data (Details)' &gt;&gt; beam.ParDo(FilterRatingData())<br/>         )</span></pre><p id="c934" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">一旦我们都有了<code class="fe mj mk ml mm b">PCollections</code>，我们就可以为<code class="fe mj mk ml mm b">CoGroupByKey</code>准备数据:</p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="eafc" class="nr kj it mm b gy ok ol l om on"># Create keys<br/>        movie_keys = (basic_data<br/>               | 'movie key' &gt;&gt; beam.Map(lambda r: (r['tconst'], r))<br/>               #| 'Print' &gt;&gt; beam.Map(print)<br/>        )<br/>        rating_keys = (rating_data<br/>               | 'rating key' &gt;&gt; beam.Map(lambda r: (r['tconst'], r))<br/>        )</span></pre><p id="1c39" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">最后，应用<code class="fe mj mk ml mm b">CoGroupByKey</code>变换和<code class="fe mj mk ml mm b">FlatMap</code>它们在一起:</p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="5201" class="nr kj it mm b gy ok ol l om on">joined_dicts = (<br/>            {'movie_keys': movie_keys, 'rating_keys': rating_keys} <br/>            | beam.CoGroupByKey()    <br/>            | beam.FlatMap(join_ratings)<br/>            | 'mergedicts' &gt;&gt; beam.Map(lambda dd: {**dd[0], **dd[1]})<br/>            | 'Print' &gt;&gt; beam.Map(print)<br/>        )</span></pre><p id="5e44" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">产生一条记录(我们随机选择输入):</p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="b54e" class="nr kj it mm b gy ok ol l om on">{'tconst': 'tt0067927', 'titleType': 'movie', 'primaryTitle': 'Vanishing Point', 'originalTitle': 'Vanishing Point', 'isAdult': False, 'startYear': 1971, 'endYear': None, 'runtimeMinutes': 99, 'genres': 'Action,Crime,Thriller', 'averageRating': 7.2, 'numVotes': 25933}</span></pre><h1 id="22fe" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">去</h1><p id="efa4" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">你会注意到缺少这些“高级”主题的例子，比如<code class="fe mj mk ml mm b">CoGroupByKey</code>，尽管它们实际上存在于<a class="ae mb" href="https://godoc.org/github.com/apache/beam/sdks/go/pkg/beam#CoGroupByKey" rel="noopener ugc nofollow" target="_blank"> godocs </a>中。因此，弄清楚这一部分花费的时间比我希望的要长一些，但是一旦理解了其中的逻辑，这是有意义的。</p><p id="070c" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">为了使用<code class="fe mj mk ml mm b">CoGroupByKey</code>，我们需要为每个<code class="fe mj mk ml mm b">PCollection</code>创建一个<code class="fe mj mk ml mm b">KV</code>对:</p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="2cbf" class="nr kj it mm b gy ok ol l om on">func extractRatingId(r ratingFn) (string, ratingFn) {<br/>	return r.tconst, r<br/>}<br/><br/>func extractMovieId(m movieFn) (string, movieFn) {<br/>	return m.tconst, m<br/>}</span></pre><p id="74d1" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">改变我们的产品系列:</p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="de66" class="nr kj it mm b gy ok ol l om on">// Combine<br/>	combined := beam.CoGroupByKey(s,<br/>		beam.ParDo(s, extractMovieId, filtered_movies),<br/>		beam.ParDo(s, extractRatingId, filtered_ratings))</span></pre><p id="973f" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">并按如下方式匹配它们:</p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="4c46" class="nr kj it mm b gy ok ol l om on">func combineFn(tconst string, movieIter func(*movieFn) bool, ratingIter func(*ratingFn) bool, emit func(targetMovie)) {<br/>	// Pointers to structs<br/>	m := &amp;movieFn{tconst: tconst}<br/>	r := &amp;ratingFn{tconst: tconst}<br/>	// If match, emit<br/>	if movieIter(m) &amp;&amp; ratingIter(r) {<br/>		fmt.Printf("%v %v\n", tconst, m)<br/>		emit(targetMovie{<br/>			Id:             m.tconst,<br/>			TitleType:      m.titleType,<br/>			PrimaryTitle:   m.primaryTitle,<br/>			OriginalTitle:  m.originalTitle,<br/>			IsAdult:        m.isAdult,<br/>			StartYear:      m.startYear,<br/>			EndYear:        m.endYear,<br/>			RuntimeMinutes: m.runtimeMinutes,<br/>			Genres:         m.genres,<br/>			AverageRating:  r.averageRating,<br/>			NumVotes:       r.numVotes,<br/>		})<br/>	}<br/>}</span></pre><p id="8dd4" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">注意<code class="fe mj mk ml mm b">func(*movieFn) bool</code>，期待一个指向<code class="fe mj mk ml mm b">struct</code>的指针，它将告诉我们是否有匹配。</p><h1 id="0833" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">侧面输入</h1><p id="bd8f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><code class="fe mj mk ml mm b">Side Inputs</code>比它们在<code class="fe mj mk ml mm b">go</code>中看起来要复杂得多，但在<code class="fe mj mk ml mm b">Python</code>中相对简单。</p><h1 id="e19c" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">计算机编程语言</h1><p id="e264" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果我们想使用<code class="fe mj mk ml mm b">Side Inputs</code>，我们可以将我们更小的<code class="fe mj mk ml mm b">ratings</code> <code class="fe mj mk ml mm b">PCollection</code>作为<code class="fe mj mk ml mm b">list</code>:</p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="727a" class="nr kj it mm b gy ok ol l om on">joined_dicts = (<br/>        basic_data<br/>        | 'Join' &gt;&gt; beam.ParDo(JoinRatings(), AsList(rating_data))<br/>    )</span></pre><p id="0ebc" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">到新的<code class="fe mj mk ml mm b">ParDo</code>:</p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="f3fc" class="nr kj it mm b gy ok ol l om on">class JoinRatings(beam.DoFn):<br/>    def process(self, movie: dict, ratings_side):<br/>        for k in ratings_side:<br/>            if k['tconst'] == movie['tconst']:<br/>                yield {**movie, **k}</span></pre><p id="f9a3" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">或者用<code class="fe mj mk ml mm b">AsDict</code>调用[0]:</p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="208d" class="nr kj it mm b gy ok ol l om on">class JoinRatings(beam.DoFn):<br/>    def process(self, movie: dict, ratings_side):<br/>        if 'tconst' in movie and movie['tconst'] in ratings_side:<br/>            yield {**movie, **ratings_side[movie['tconst']]}</span></pre><p id="bcff" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">并得到相同的结果，这次使用侧面输入。</p><p id="47c4" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated"><em class="mf">【0】一个</em> <code class="fe mj mk ml mm b"><em class="mf">dict</em></code> <em class="mf">在这里会比一个列表高效很多；不过据我看，</em> <code class="fe mj mk ml mm b"><em class="mf">go</em></code> <em class="mf"> SDK 并不支持 SideInputs 作为</em><code class="fe mj mk ml mm b"><em class="mf">map</em></code><em class="mf">；因此，我用</em> <code class="fe mj mk ml mm b"><em class="mf">lists</em></code> <em class="mf">和</em> <code class="fe mj mk ml mm b"><em class="mf">maps</em></code> <em class="mf"> / </em> <code class="fe mj mk ml mm b"><em class="mf">dicts</em></code> <em class="mf">实现了</em> <code class="fe mj mk ml mm b"><em class="mf">Python</em></code> <em class="mf">和<em class="mf"/><code class="fe mj mk ml mm b"><em class="mf">SideInputs</em></code><em class="mf">。</em></em></p><h1 id="110f" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">去</h1><p id="ba5e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们将在<code class="fe mj mk ml mm b">SideInput</code>这里强调我在<code class="fe mj mk ml mm b">Python</code>部分指出的可能性。</p><p id="c9c1" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">首先，我们需要另一个结构作为我们的输出结构:</p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="f410" class="nr kj it mm b gy ok ol l om on">type targetMovie struct {<br/>	Id             string<br/>	TitleType      string<br/>	PrimaryTitle   string<br/>	OriginalTitle  string<br/>	IsAdult        bool<br/>	StartYear      int64<br/>	EndYear        int64<br/>	RuntimeMinutes int64<br/>	Genres         string<br/>	// Ratings<br/>	AverageRating float64<br/>	NumVotes      int64<br/>}</span></pre><p id="a20c" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">注意这些值是从<a class="ae mb" href="https://golang.org/ref/spec#Exported_identifiers" rel="noopener ugc nofollow" target="_blank">导出的</a>，即以大写字母开始。</p><p id="de9c" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">我们简单地定义了一个<code class="fe mj mk ml mm b">combine</code>类型的函数，它需要一个<code class="fe mj mk ml mm b">slice</code>或<code class="fe mj mk ml mm b">ratingFn</code>，而不是一个<code class="fe mj mk ml mm b">PCollection</code>:</p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="f8f4" class="nr kj it mm b gy ok ol l om on">func combineMoviesRatings(movie movieFn, ratings []ratingFn, emit func(targetMovie)) {<br/>	for _, r := range ratings {<br/>		if r.tconst == movie.tconst {<br/>			emit(targetMovie{<br/>				Id:             movie.tconst,<br/>				TitleType:      movie.titleType,<br/>				PrimaryTitle:   movie.primaryTitle,<br/>				OriginalTitle:  movie.originalTitle,<br/>				IsAdult:        movie.isAdult,<br/>				StartYear:      movie.startYear,<br/>				EndYear:        movie.endYear,<br/>				RuntimeMinutes: movie.runtimeMinutes,<br/>				Genres:         movie.genres,<br/>				AverageRating:  r.averageRating,<br/>				NumVotes:       r.numVotes,<br/>			})<br/>		}<br/>	}<br/>}</span></pre><p id="f3a0" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">并且用<code class="fe mj mk ml mm b">Side Input</code>这样称呼它:</p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="05b6" class="nr kj it mm b gy ok ol l om on">combined := beam.ParDo(s, combineMoviesRatings, filtered_movies,<br/>		beam.SideInput{Input: filtered_ratings})</span></pre><p id="8232" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">这样，我们得到了相同的输出:</p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="fa65" class="nr kj it mm b gy ok ol l om on">{"Id":"tt0067927","TitleType":"movie","PrimaryTitle":"Vanishing Point","OriginalTitle":"Vanishing Point","IsAdult":false,"StartYear":1971,"EndYear":0,"RuntimeMinutes":99,"Genres":"Action,Crime,Thriller","AverageRating":7.2,"NumVotes":25933}</span></pre><p id="e452" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">类似于我们在<code class="fe mj mk ml mm b">Python</code>中看到的，做 n 次这个列表比较，我们得到 O(n*n)并且<em class="mf">会非常</em>无效。</p><p id="8186" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">由于我仍然不知道<code class="fe mj mk ml mm b">go</code> SDK 是否有一个等同于<code class="fe mj mk ml mm b">Python</code>的<code class="fe mj mk ml mm b">apache_beam.pvalue.AsDict</code>，我想出了这个可怕的变通方法，将一个<code class="fe mj mk ml mm b">PCollection</code>作为单例侧输入传递给一个<code class="fe mj mk ml mm b">ParDo</code>，并创建一个<code class="fe mj mk ml mm b">map[string]ratingFn</code>:</p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="823b" class="nr kj it mm b gy ok ol l om on">func makeRatingsMap(rr int, ratings []ratingFn, emit func(map[string]ratingFn)) {<br/>	m := make(map[string]ratingFn)<br/>	for _, r := range ratings {<br/>		m[r.tconst] = r<br/>	}<br/>	emit(m)<br/>}<br/><br/>func combineMoviesRatings(movie movieFn, ratings map[string]ratingFn, emit func(targetMovie)) {<br/>	r, ok := ratings[movie.tconst]<br/>	if ok {<br/>		emit(targetMovie{<br/>			Id:             movie.tconst,<br/>			TitleType:      movie.titleType,<br/>			PrimaryTitle:   movie.primaryTitle,<br/>			OriginalTitle:  movie.originalTitle,<br/>			IsAdult:        movie.isAdult,<br/>			StartYear:      movie.startYear,<br/>			EndYear:        movie.endYear,<br/>			RuntimeMinutes: movie.runtimeMinutes,<br/>			Genres:         movie.genres,<br/>			AverageRating:  r.averageRating,<br/>			NumVotes:       r.numVotes,<br/>		})<br/>	}<br/>}</span></pre><p id="5ade" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">我们称之为:</p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="93a3" class="nr kj it mm b gy ok ol l om on">// Fake PCollection to only run the next parDo once<br/>	fakePCol := beam.CreateList(s, [1]int{<br/>		0,<br/>	})<br/>	// To Map<br/>	filteredRatingsMap := beam.ParDo(s, makeRatingsMap, fakePCol, beam.SideInput{Input: filtered_ratings})<br/>	// And match<br/>	combined := beam.ParDo(s, combineMoviesRatings, filtered_movies,<br/>		beam.SideInput{Input: filteredRatingsMap})</span></pre><p id="3edb" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">虽然这可能属于“如果它有效，它就不愚蠢！”，我们将在后面的章节中查看在尝试使用<code class="fe mj mk ml mm b">Dataflow</code>时导致的许多问题——不过，请注意，这段代码确实可以在<code class="fe mj mk ml mm b">DirectRunner</code>上工作。</p><h1 id="d0fb" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">输入－输出</h1><p id="d493" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">最后，让我们写我们的数据。我们将首先关注写入磁盘。</p><h1 id="5567" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">计算机编程语言</h1><p id="abe0" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在<code class="fe mj mk ml mm b">Python</code>中，一个简单的调用将创建一个<code class="fe mj mk ml mm b">txt</code>文件，包含上面的<code class="fe mj mk ml mm b">json</code>:</p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="c206" class="nr kj it mm b gy ok ol l om on">joined_dicts | 'write' &gt;&gt; beam.io.WriteToText('./movies.txt')</span></pre><h1 id="ad48" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">去</h1><p id="b9a1" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><code class="fe mj mk ml mm b">Go</code>在这方面也非常相似——然而，我们必须将<code class="fe mj mk ml mm b">struct</code>“编码”为内联<code class="fe mj mk ml mm b">ParDo</code>中的<code class="fe mj mk ml mm b">JSON</code>:</p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="5c9d" class="nr kj it mm b gy ok ol l om on">combinedString := beam.ParDo(s, func(v targetMovie) string {<br/>		j, _ := json.Marshal(v)<br/>		return fmt.Sprintf(string(j))<br/>	}, combined)<br/>	// Write<br/>	textio.Write(s, *output, combinedString)</span></pre><h1 id="75fd" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">DirectRunner(本地)</h1><p id="4cad" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">让我们快速运行并讨论一下性能。上次，在我们的<code class="fe mj mk ml mm b">Mandelbrot</code>基准测试中，<code class="fe mj mk ml mm b">go</code>几乎比<code class="fe mj mk ml mm b">Python</code>快了 45 倍。让我们看看<code class="fe mj mk ml mm b">Beam</code>是如何支撑的。</p><p id="1ba6" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">在<code class="fe mj mk ml mm b">DirectRunner</code>上比较性能几乎是毫无意义的，因为这个运行器是为本地调试和开发而设计的，而不是生产使用。</p><h1 id="95c5" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">标杆管理</h1><p id="afd4" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">也就是说，我确实运行了一些基准测试，比较了分别使用<code class="fe mj mk ml mm b">Side Inputs</code>和<code class="fe mj mk ml mm b">lists</code>或<code class="fe mj mk ml mm b">dicts</code> / <code class="fe mj mk ml mm b">maps</code>的<code class="fe mj mk ml mm b">go</code>和<code class="fe mj mk ml mm b">Python</code>，以及使用三个不同测试数据集的<code class="fe mj mk ml mm b">CoGroupByKey</code>:100 条记录@ 9KB、100，000 条记录@ 9MB 和 1M 条记录@ 100MB。</p><p id="d5d8" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">先看各种<code class="fe mj mk ml mm b">Side Inputs</code>:</p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi op"><img src="../Images/fcda04493d2a2c98faf5740628335d10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0UMjbYmIn49TnKdn.png"/></div></div><p class="mz na gj gh gi nb nc bd b be z dk translated"><a class="ae mb" href="https://chollinger.com/blog/2020/07/a-data-engineering-perspective-on-go-vs.-python-part-2-dataflow/#directrunner-locally" rel="noopener ugc nofollow" target="_blank">https://CHOL linger . com/blog/2020/07/a-data-engineering-perspective-on-go-vs .-python-part-2-data flow/# direct runner-locally</a></p></figure><p id="e102" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">这里的速度明显更快，但这是意料之中的，因为它本质上是单线程运行的。使用<code class="fe mj mk ml mm b">lists</code>作为辅助输入要慢得多，以至于我已经放弃了在 1M 记录上运行<code class="fe mj mk ml mm b">go</code>和<code class="fe mj mk ml mm b">Python</code>的<code class="fe mj mk ml mm b">as list</code>用例。</p><p id="f7aa" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">现在，对于<code class="fe mj mk ml mm b">CoGroupByKey</code>:</p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi op"><img src="../Images/2050c1fd604f4deece0f91e90fe39333.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*StJ0ymg2i-vqylyD.png"/></div></div><p class="mz na gj gh gi nb nc bd b be z dk translated"><a class="ae mb" href="https://chollinger.com/blog/2020/07/a-data-engineering-perspective-on-go-vs.-python-part-2-dataflow/#directrunner-locally" rel="noopener ugc nofollow" target="_blank">https://CHOL linger . com/blog/2020/07/a-data-engineering-perspective-on-go-vs .-python-part-2-data flow/# direct runner-locally</a></p></figure><p id="53c6" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">我们看到一个非常相似的趋势，即<code class="fe mj mk ml mm b">go</code>快了几个数量级。印象深刻！</p><h1 id="75f5" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">推荐工作</h1><p id="b2a7" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我还用<code class="fe mj mk ml mm b">DirectRunner</code>上的<code class="fe mj mk ml mm b">title.basics</code>数据对<code class="fe mj mk ml mm b">wordcount</code>例子进行了基准测试，以确保我不会因为无意中编写了根本不同的代码而将苹果和橙子进行比较。</p><p id="d635" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">我在<code class="fe mj mk ml mm b">go</code>中是这样做的:</p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="c21d" class="nr kj it mm b gy ok ol l om on">go install github.com/apache/beam/sdks/go/examples/wordcount<br/>time wordcount --input ~/workspace/beam-examples/data/title.basics.tsv --output countsgo.txt</span></pre><p id="da87" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">和<code class="fe mj mk ml mm b">python</code>:</p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="35ef" class="nr kj it mm b gy ok ol l om on">time python3 -m apache_beam.examples.wordcount --input ~/workspace/beam-examples/data/title.basics.tsv --output wordcountpy.txt # without multiple workers</span></pre><p id="83fb" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">产生了:</p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi oq"><img src="../Images/90d26df428c48885acfed123205d72cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZBB5yt0GgCpYit4W.png"/></div></div><p class="mz na gj gh gi nb nc bd b be z dk translated"><a class="ae mb" href="https://chollinger.com/blog/2020/07/a-data-engineering-perspective-on-go-vs.-python-part-2-dataflow/#a-reference-job" rel="noopener ugc nofollow" target="_blank">https://CHOL linger . com/blog/2020/07/a-data-engineering-perspective-on-go-vs .-python-part-2-data flow/# a-reference-job</a></p></figure><p id="c100" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">这确实符合我们的观察，即<code class="fe mj mk ml mm b">Beam</code>和<code class="fe mj mk ml mm b">go</code>仍然比<code class="fe mj mk ml mm b">Python</code>快一点。</p><h1 id="ea32" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">数据流(谷歌云)</h1><p id="ad25" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">现在，在外部运行程序上运行这个程序只给我们留下了一个选项(因为<code class="fe mj mk ml mm b">go</code>不支持其他运行程序)，即<code class="fe mj mk ml mm b">Google Cloud</code>的<code class="fe mj mk ml mm b">Dataflow</code>。我应该补充一下，<code class="fe mj mk ml mm b">go</code>的<code class="fe mj mk ml mm b">Dataflow</code>仍然在版本<code class="fe mj mk ml mm b">0.5</code>中，还没有得到官方支持。</p><p id="8f28" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">确保您拥有:</p><ol class=""><li id="fd57" class="nd ne it lc b ld lw lg lx lj nf ln ng lr nh lv oe nj nk nl bi translated">谷歌云项目</li><li id="c456" class="nd ne it lc b ld nm lg nn lj no ln np lr nq lv oe nj nk nl bi translated">启用计费(或自由级合格帐户)</li><li id="891b" class="nd ne it lc b ld nm lg nn lj no ln np lr nq lv oe nj nk nl bi translated">数据流 API 已启用</li><li id="97a8" class="nd ne it lc b ld nm lg nn lj no ln np lr nq lv oe nj nk nl bi translated"><code class="fe mj mk ml mm b">gcloud sdk</code>已安装，已运行<code class="fe mj mk ml mm b">gcloud init</code>和<code class="fe mj mk ml mm b">gcloud auth login</code></li><li id="b3c9" class="nd ne it lc b ld nm lg nn lj no ln np lr nq lv oe nj nk nl bi translated"><code class="fe mj mk ml mm b">GOOGLE_APPLICATION_CREDENTIALS</code>被设定</li><li id="e45a" class="nd ne it lc b ld nm lg nn lj no ln np lr nq lv oe nj nk nl bi translated">如果你在谷歌上看到这篇文章，确保克里斯蒂安获得更多免费学分<em class="mf">(可选步骤)</em></li></ol><h1 id="a62c" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">计算机编程语言</h1><p id="950b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">对于<code class="fe mj mk ml mm b">Python</code>，我们需要使用经过认证的<code class="fe mj mk ml mm b">gcloud sdk</code>来运行它:</p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="c5a5" class="nr kj it mm b gy ok ol l om on">pip3 install --upgrade "apache-beam[gcp]"<br/>python3 movie_pipeline.py --input-basics "${BUCKET}/title.basics.tsv" \<br/>    --input-ratings "${BUCKET}/title.ratings.tsv" \<br/>    --output "${BUCKET}/out" \<br/>    --runner dataflow \<br/>    --project "${PROJECT}" \<br/>    --region "${REGION}" \<br/>    --temp_location "${BUCKET}/tmp/" \<br/>    --staging_location "${BUCKET}/binaries/" #\<br/>    #--num_workers 4</span></pre><p id="b0b7" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">但是，它将在<code class="fe mj mk ml mm b">Python 3.8</code>失败，原因是</p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="da55" class="nr kj it mm b gy ok ol l om on">Exception: Dataflow only supports Python versions 2 and 3.5+, got: (3, 8)</span></pre><p id="7c0b" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">所以这里用一个旧版本的<code class="fe mj mk ml mm b">Python</code>，<code class="fe mj mk ml mm b">3.7</code>效果很好。</p><p id="01d6" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">当作业运行时，它看起来像这样:</p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi or"><img src="../Images/1a0d15bad3872a26da3f8a19da71cbb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*biCzgmzaPhHrGvRU.png"/></div></div><p class="mz na gj gh gi nb nc bd b be z dk translated"><a class="ae mb" href="https://chollinger.com/blog/2020/07/a-data-engineering-perspective-on-go-vs.-python-part-2-dataflow/#dataflow-google-cloud" rel="noopener ugc nofollow" target="_blank">https://CHOL linger . com/blog/2020/07/a-data-engineering-perspective-on-go-vs .-python-part-2-data flow/# data flow-Google-cloud</a></p></figure><p id="8a43" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">一旦完成，就像这样:</p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div class="gh gi os"><img src="../Images/1659aad6dfb09a77a49d2ba8816797ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/format:webp/0*VYkoBwMnzKFbGbcE.png"/></div><p class="mz na gj gh gi nb nc bd b be z dk translated"><a class="ae mb" href="https://chollinger.com/blog/2020/07/a-data-engineering-perspective-on-go-vs.-python-part-2-dataflow/#dataflow-google-cloud" rel="noopener ugc nofollow" target="_blank">https://CHOL linger . com/blog/2020/07/a-data-engineering-perspective-on-go-vs .-python-part-2-data flow/# data flow-Google-cloud</a></p></figure><h1 id="1313" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">Go 数据流</h1><p id="422f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><em class="mf">本节将带您了解整个探索和开发过程，包括一些死胡同，以说明我所面临的一些挑战。如果你对解决方案感兴趣，跳到</em> <a class="ae mb" href="https://chollinger.com/blog/2020/07/a-data-engineering-perspective-on-go-vs.-python-part-2-dataflow/#finally-running-on-dataflow" rel="noopener ugc nofollow" target="_blank"> <em class="mf">最后一节</em> </a> <em class="mf">。</em></p><p id="3ca7" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">对于<code class="fe mj mk ml mm b">go</code>，我们需要使用经过认证的<code class="fe mj mk ml mm b">gcloud sdk</code>来构建和运行它。</p><p id="1e99" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">首先，确保所有的定制<code class="fe mj mk ml mm b">structs</code>都在<code class="fe mj mk ml mm b">init()</code>中注册，类似于你在<code class="fe mj mk ml mm b">Spark</code>中用<code class="fe mj mk ml mm b">Scala</code>处理<code class="fe mj mk ml mm b">Kryo</code>的操作。</p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="7f98" class="nr kj it mm b gy ok ol l om on">func init() {<br/>	beam.RegisterType(reflect.TypeOf((*ratingFn)(nil)).Elem())<br/>	beam.RegisterType(reflect.TypeOf((*movieFn)(nil)).Elem())<br/>	beam.RegisterType(reflect.TypeOf((*targetMovie)(nil)).Elem())<br/>}</span></pre><p id="062b" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">构建并运行:</p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="7421" class="nr kj it mm b gy ok ol l om on">go build movie_pipeline.go<br/>./movie_pipeline --input-basics "${BUCKET}/title.basics.tsv" \<br/>    --input-ratings "${BUCKET}/title.ratings.tsv" \<br/>    --output "${BUCKET}/out" \<br/>    --runner dataflow \<br/>    --project "${PROJECT}" \<br/>    --region "${REGION}" \<br/>    --temp_location "${BUCKET}/tmp/" \<br/>    --staging_location "${BUCKET}/binaries/" \<br/>    --worker_harness_container_image=apache/beam_go_sdk:latest #\<br/>    #--num_workers 4</span></pre><p id="bfdb" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">但是当试图使用 <code class="fe mj mk ml mm b"><strong class="lc iu">Side Input</strong></code> <strong class="lc iu">和</strong> <code class="fe mj mk ml mm b"><strong class="lc iu">map</strong></code> <strong class="lc iu">路线</strong>时，它不会运行<strong class="lc iu">:</strong></p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="3112" class="nr kj it mm b gy ok ol l om on">panic: Failed to encode custom coder for type json. Make sure the type was registered before calling beam.Init. For example: beam.RegisterType(reflect.TypeOf((*TypeName)(nil)).Elem())</span></pre><h1 id="fbca" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">注册数据流的类型</h1><p id="37b1" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这里显而易见的方法是简单地注册类型。然而，在 Beam 中注册类型时，我遇到了一些棘手的问题。</p><blockquote class="mc md me"><p id="2cb7" class="la lb mf lc b ld lw ju lf lg lx jx li mg ly ll lm mh lz lp lq mi ma lt lu lv im bi translated"><em class="it"> RegisterType 将“外部”类型插入到全局类型注册表中，以绕过序列化并保留完整的方法信息。应该只在 init()中调用它。TODO(wcn):“外部”的规范定义在 v1.proto 中。我们需要这个重要概念的面向用户的副本。</em></p><p id="0f54" class="la lb mf lc b ld lw ju lf lg lx jx li mg ly ll lm mh lz lp lq mi ma lt lu lv im bi translated"><a class="ae mb" href="https://godoc.org/github.com/apache/beam/sdks/go/pkg/beam#RegisterType" rel="noopener ugc nofollow" target="_blank">T34】https://godoc . org/github . com/Apache/beam/sdks/go/pkg/beam # register typeT36】</a></p></blockquote><p id="4a65" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">我们可以尝试这样注册<code class="fe mj mk ml mm b">map</code>:</p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="a79e" class="nr kj it mm b gy ok ol l om on">func init() {<br/>	// ..<br/>	var m map[string]ratingFn<br/>	beam.RegisterType(reflect.TypeOf(m).Elem())<br/>}</span></pre><p id="15e0" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">产量:</p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="0bb1" class="nr kj it mm b gy ok ol l om on">panic: Failed to encode custom coder for type json. Make sure the type was registered before calling beam.Init. For example: beam.RegisterType(reflect.TypeOf((*TypeName)(nil)).Elem())<br/>Full error:<br/>        encoding custom coder map[string]main.ratingFn[json] for type map[string]main.ratingFn<br/>unencodable type map[string]main.ratingFn</span></pre><p id="0982" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">当然，我们可以试着注册一个<code class="fe mj mk ml mm b">map</code>:</p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="ceb0" class="nr kj it mm b gy ok ol l om on">beam.RegisterType(reflect.MapOf(reflect.TypeOf(""), reflect.TypeOf((*ratingFn)(nil)).Elem()))</span></pre><p id="9d47" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">但这并没有达到预期的效果。为什么？</p><p id="848f" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">深入研究<code class="fe mj mk ml mm b">go</code> SDK 源代码，我发现了以下函数:</p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="2cdb" class="nr kj it mm b gy ok ol l om on">// TypeKey returns the external key of a given type. Returns false if not a<br/>// candidate for registration.<br/>func TypeKey(t reflect.Type) (string, bool) {<br/>	fmt.Printf("%v =&gt; PckPath: %v Name: %v Kind: %v\n", t, t.PkgPath(), t.Name(), t.Kind())<br/>	if t.PkgPath() == "" || t.Name() == "" {<br/>		return "", false // no pre-declared or unnamed types<br/>	}<br/>	return fmt.Sprintf("%v.%v", t.PkgPath(), t.Name()), true<br/>}</span></pre><p id="db69" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">我已经添加了<code class="fe mj mk ml mm b">fmt.Printf</code>用于调试。</p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="440f" class="nr kj it mm b gy ok ol l om on">main.ratingFn =&gt; PckPath: main Name: ratingFn Kind: struct<br/>main.movieFn =&gt; PckPath: main Name: movieFn Kind: struct<br/>main.targetMovie =&gt; PckPath: main Name: targetMovie Kind: struct<br/>map[string]main.ratingFn =&gt; PckPath:  Name:  Kind: map<br/>panic: invalid registration type: map[string]main.ratingFn</span></pre><p id="8683" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">此函数检查注册的类型是否实际上是自定义类型；一个<code class="fe mj mk ml mm b">map</code>不是。<code class="fe mj mk ml mm b">PckPath</code>和<code class="fe mj mk ml mm b">Name</code>从未设置，因为<code class="fe mj mk ml mm b">map</code>不是可以通过<code class="fe mj mk ml mm b">reflection</code>注册的自定义类型。</p><p id="9327" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">通过<a class="ae mb" href="https://issues.apache.org/jira/browse/BEAM-6652?jql=project%20%3D%20BEAM%20AND%20component%20%3D%20sdk-go%20AND%20text%20~%20%22map%22" rel="noopener ugc nofollow" target="_blank">吉拉</a>，我找到这个<a class="ae mb" href="https://github.com/apache/beam/pull/7857" rel="noopener ugc nofollow" target="_blank"> PR </a>，把我带到<a class="ae mb" href="https://github.com/lostluck/beam/blob/master/sdks/go/pkg/beam/core/typex/class_test.go#L55" rel="noopener ugc nofollow" target="_blank">这个</a>单元测试——让我相信<code class="fe mj mk ml mm b">go</code> SDK 不允许<code class="fe mj mk ml mm b">maps</code>使用定制类型。</p><p id="019b" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">我们能不能用一个<code class="fe mj mk ml mm b">list</code>代替<code class="fe mj mk ml mm b">Side Input</code>来让我们的生活更轻松？我想你知道答案——但是让我们来谈谈调试，因为我们已经在调试了。</p><h1 id="f54f" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">性能工具—性能分析<code class="fe mj mk ml mm b">Go</code></h1><p id="8cdf" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果我们要使用<code class="fe mj mk ml mm b">list</code>而不是<code class="fe mj mk ml mm b">map</code>，让我们快速使用来描述一下引擎盖下发生了什么。</p><p id="267a" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">对于这个测试，我使用了一个有 5，000，000 行的文件，总时钟大约为 500MB。</p><p id="a0ae" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">首先，按照说明为 profiler 添加额外的<code class="fe mj mk ml mm b">flags</code>后运行作业:</p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="9a2b" class="nr kj it mm b gy ok ol l om on">go run movie_pipeline.go --input-basics ../data/title.basics.5M.tsv --input-ratings ../data/title.ratings.5M.tsv --output ./test.txt  -cpuprofile ../profiler/cpu.out -memprofile ../profiler/mem.out</span></pre><p id="1180" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">尽管配备了英特尔 i7–9750h、16GB DDR 4 内存和 M.2 NVMe 固态硬盘，这项工作还是在本地花费了 84 分钟。</p><p id="bf0e" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">听听你可怜的笔记本电脑像喷气发动机的声音，并打印结果:</p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="f8b1" class="nr kj it mm b gy ok ol l om on">go tool pprof --svg ./cpu.out &gt; cpu.svg<br/>go tool pprof --svg ./mem.out &gt; mem.svg</span></pre><p id="5fd9" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">这就是结果:</p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi ot"><img src="../Images/f84c45b42016479cb84fbb1a08f021a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*W6_ZRjyncgFAmfXC.png"/></div></div><p class="mz na gj gh gi nb nc bd b be z dk translated"><a class="ae mb" href="https://chollinger.com/blog/2020/07/a-data-engineering-perspective-on-go-vs.-python-part-2-dataflow/#perf-tools---profiling-go" rel="noopener ugc nofollow" target="_blank">https://CHOL linger . com/blog/2020/07/a-data-engineering-perspective-on-go-vs .-python-part-2-data flow/# perf-tools-profiling-go</a></p></figure><p id="37c0" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">我们可以看到<code class="fe mj mk ml mm b">combineMovieRatings</code>，低效的列表迭代占用了大部分时间，通过监控<code class="fe mj mk ml mm b">htop</code>，我可以告诉你这个任务一直使用一个线程。</p><p id="cc8d" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">现在，看到迭代一个列表效率非常低并不奇怪——但是结合单线程执行(我认为这是由<code class="fe mj mk ml mm b">Splittable DoFn</code>问题引起的),正在导致大规模的运行时峰值。</p><h1 id="e501" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">定制编码器之旅</h1><p id="8e97" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在深入研究了吉拉和 GitHub 的 Pull 请求之后，我偶然发现了<a class="ae mb" href="https://godoc.org/github.com/apache/beam/sdks/go/pkg/beam#Coder" rel="noopener ugc nofollow" target="_blank">自定义编码者</a>和他们对内部类型的<a class="ae mb" href="https://github.com/apache/beam/blob/master/sdks/go/pkg/beam/core/runtime/coderx/string.go" rel="noopener ugc nofollow" target="_blank">用法。</a></p><p id="0cbc" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">我有一个绝妙的主意，为我们的地图类型注册一个自定义编码器:</p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="ea35" class="nr kj it mm b gy ok ol l om on">func NewCustomMap() (*coder.CustomCoder, error) {<br/>	return coder.NewCustomCoder("customMap", reflect.MapOf(reflect.TypeOf(""), reflect.TypeOf((*ratingFn)(nil)).Elem()), encCustomMap, decCustomMap)<br/>}<br/><br/>func encCustomMap(v typex.T) []byte {<br/>	dat, _ := json.Marshal(v)<br/>	return dat<br/>}<br/><br/>func decCustomMap(data []byte) typex.T {<br/>	return string(data)<br/>}</span></pre><p id="1517" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">不幸的是，<code class="fe mj mk ml mm b"><a class="ae mb" href="https://github.com/apache/beam/blob/master/sdks/go/pkg/beam/forward.go#L95" rel="noopener ugc nofollow" target="_blank">RegisterCoder</a></code>看起来是这样的:</p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="807e" class="nr kj it mm b gy ok ol l om on">func RegisterCoder(t reflect.Type, encoder, decoder interface{}) {<br/>	runtime.RegisterType(t)<br/>	runtime.RegisterFunction(encoder)<br/>	runtime.RegisterFunction(decoder)<br/>	coder.RegisterCoder(t, encoder, decoder)<br/>}</span></pre><p id="9e04" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">因此，也调用<code class="fe mj mk ml mm b">RegisterType(t)</code>，这将再次无法注册我们的类型或编码器。</p><h1 id="1fb1" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">地图-&gt; JSON -&gt;地图</h1><p id="11c6" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">虽然我很有可能误解了上面所有的<code class="fe mj mk ml mm b">go</code>代码和<code class="fe mj mk ml mm b">Jira</code>标签，但我的下一个方法是自己做<code class="fe mj mk ml mm b">json</code>解析。</p><p id="b6e9" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">首先，我们没有返回地图，而是返回了<code class="fe mj mk ml mm b">[]byte</code>，它返回了一个<code class="fe mj mk ml mm b">json</code>字符串:</p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="fe01" class="nr kj it mm b gy ok ol l om on">func makeRatingsMap(rr int, ratings []ratingFn, emit func([]byte)) {<br/>	m := make(map[string]ratingFn)<br/>	for _, r := range ratings {<br/>		m[r.tconst] = r<br/>	}<br/>	jsonMap, err := json.Marshal(m)<br/>	if err != nil {<br/>		log.Fatal(err)<br/>	}<br/>	emit(jsonMap)<br/>}</span></pre><p id="e204" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">然后，在我们的组合函数中，我们将数据<code class="fe mj mk ml mm b">unmarshall</code>到一个<code class="fe mj mk ml mm b">map[string]ratingFn</code>中。</p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="38aa" class="nr kj it mm b gy ok ol l om on">func combineMoviesRatings(movie movieFn, ratings []byte, emit func(targetMovie)) {<br/>	ratingsMap := make(map[string]ratingFn)<br/>	err := json.Unmarshal(ratings, &amp;ratingsMap)<br/>	if err != nil {<br/>		log.Fatal(err)<br/>	}<br/>	r, ok := ratingsMap[movie.tconst]<br/>	if ok {<br/>		emit(targetMovie{<br/>			Id:             movie.tconst,<br/>			TitleType:      movie.titleType,<br/>			PrimaryTitle:   movie.primaryTitle,<br/>			OriginalTitle:  movie.originalTitle,<br/>			IsAdult:        movie.isAdult,<br/>			StartYear:      movie.startYear,<br/>			EndYear:        movie.endYear,<br/>			RuntimeMinutes: movie.runtimeMinutes,<br/>			Genres:         movie.genres,<br/>			AverageRating:  r.averageRating,<br/>			NumVotes:       r.numVotes,<br/>		})<br/>	}<br/>}</span></pre><p id="e820" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">不幸的是，现在每一步都需要执行<code class="fe mj mk ml mm b">marshalling</code>，这极大地改变了本地性能数据:</p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi ou"><img src="../Images/265407018c87802f3a97ad1a0852a6a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*M4AAM2wlJFbXsMgu.png"/></div></div><p class="mz na gj gh gi nb nc bd b be z dk translated"><a class="ae mb" href="https://chollinger.com/blog/2020/07/a-data-engineering-perspective-on-go-vs.-python-part-2-dataflow/#map---json---map" rel="noopener ugc nofollow" target="_blank">https://CHOL linger . com/blog/2020/07/a-data-engineering-perspective-on-go-vs .-python-part-2-data flow/# map-JSON-map</a></p></figure><p id="df8d" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">如您所见，<code class="fe mj mk ml mm b">json (*decodeState)</code>和<code class="fe mj mk ml mm b">mapassign</code>导致了作业的巨大开销，至少在<code class="fe mj mk ml mm b">DirectRunner</code>上，<strong class="lc iu">不是一个可行的替代方案</strong>。</p><h1 id="ddeb" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">从头再来</h1><p id="8b3e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">此时，我们必须重新访问<code class="fe mj mk ml mm b">CoGroupByKey</code>或其他选项；然而，这些问题确实显示了一些更奇怪的(我可以补充一下，完全没有记录的)问题和 SDK 的不足。</p><p id="ffb0" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">说一个<code class="fe mj mk ml mm b">Side Input</code>是一个比<code class="fe mj mk ml mm b">CoGroupByKey</code>更好的<em class="mf">解决方案是有争议的，但是在我的例子中，我一般不能使用一个<code class="fe mj mk ml mm b">map</code>作为一个<code class="fe mj mk ml mm b">Side Input</code>。</em></p><h1 id="456a" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">最终在数据流上运行</h1><p id="670e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在切换回<code class="fe mj mk ml mm b">CoGroupByKey</code>之后，这些变化最终允许我将任务提交给<code class="fe mj mk ml mm b">Dataflow</code>。请记住，<code class="fe mj mk ml mm b"><em class="mf">go</em></code> <em class="mf"> SDK 还没有得到数据流</em>的官方支持。</p><p id="5577" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">这里，我们还可以通过向我们的<code class="fe mj mk ml mm b">struct</code>添加元数据来为<code class="fe mj mk ml mm b">BigQuery</code>添加另一个输出:</p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="0640" class="nr kj it mm b gy ok ol l om on">type targetMovie struct {<br/>	Id             string `bigquery:"Id"`<br/>	TitleType      string `bigquery:"TitleType"`<br/>	PrimaryTitle   string `bigquery:"PrimaryTitle"`<br/>	OriginalTitle  string `bigquery:"OriginalTitle"`<br/>	IsAdult        bool   `bigquery:"IsAdult"`<br/>	StartYear      int64  `bigquery:"StartYear"`<br/>	EndYear        int64  `bigquery:"EndYear"`<br/>	RuntimeMinutes int64  `bigquery:"RuntimeMinutes"`<br/>	Genres         string `bigquery:"Genres"`<br/>	// Ratings<br/>	AverageRating float64 `bigquery:"AverageRating"`<br/>	NumVotes      int64   `bigquery:"NumVotes"`<br/>}</span></pre><p id="ea0d" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">并写信给 BQ:</p><pre class="mo mp mq mr gt og mm oh oi aw oj bi"><span id="60ef" class="nr kj it mm b gy ok ol l om on">if *bq != "" {<br/>		project := gcpopts.GetProject(ctx)<br/>		bigqueryio.Write(s, project, *bq, combined)<br/>	}</span></pre><p id="6422" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">提交后，我们将看到我们的 DAG:</p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/1a560f245aaade704403e2d9896e4820.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/0*2acfqB3oCrDtrZvi.png"/></div><p class="mz na gj gh gi nb nc bd b be z dk translated"><a class="ae mb" href="https://chollinger.com/blog/2020/07/a-data-engineering-perspective-on-go-vs.-python-part-2-dataflow/#finally-running-on-dataflow" rel="noopener ugc nofollow" target="_blank">https://CHOL linger . com/blog/2020/07/a-data-engineering-perspective-on-go-vs .-python-part-2-data flow/# finally-running-on-data flow</a></p></figure><h1 id="0ef4" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">可拆分 DoFns</h1><p id="e6a2" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">免责声明</strong>:在需要加载<em class="mf">大文件的用例中<code class="fe mj mk ml mm b">go</code> SDK 的性能可能不如<code class="fe mj mk ml mm b">Python</code>和<code class="fe mj mk ml mm b">Java</code>。</em></p><p id="f54a" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">这是因为<strong class="lc iu"/><code class="fe mj mk ml mm b"><strong class="lc iu">go</strong></code><strong class="lc iu">SDK 不支持</strong> <a class="ae mb" href="https://beam.apache.org/blog/splittable-do-fn/" rel="noopener ugc nofollow" target="_blank"> <strong class="lc iu">可拆分 DoFns </strong> </a>。参考见<a class="ae mb" href="https://issues.apache.org/jira/browse/BEAM-3301" rel="noopener ugc nofollow" target="_blank"> BEAM-3301 </a>。</p><h1 id="1c95" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">数据流性能</h1><p id="5a24" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在比较性能时，我们将考察所有 3 种方法:</p><ol class=""><li id="9aea" class="nd ne it lc b ld lw lg lx lj nf ln ng lr nh lv oe nj nk nl bi translated">使用简单列表作为<code class="fe mj mk ml mm b">Side Input</code></li><li id="180b" class="nd ne it lc b ld nm lg nn lj no ln np lr nq lv oe nj nk nl bi translated">使用<code class="fe mj mk ml mm b">dict</code>作为<code class="fe mj mk ml mm b">Side Input</code> <em class="mf">(仅限 Python)</em></li><li id="4bd0" class="nd ne it lc b ld nm lg nn lj no ln np lr nq lv oe nj nk nl bi translated">使用<code class="fe mj mk ml mm b">CoGroupByKey</code></li></ol><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi ow"><img src="../Images/3b0c7e6ce8556180717e9a3bb6f60139.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WJaGsrp9uTfXwQuy.png"/></div></div><p class="mz na gj gh gi nb nc bd b be z dk translated"><a class="ae mb" href="https://chollinger.com/blog/2020/07/a-data-engineering-perspective-on-go-vs.-python-part-2-dataflow/#dataflow-performance" rel="noopener ugc nofollow" target="_blank">https://CHOL linger . com/blog/2020/07/a-data-engineering-perspective-on-go-vs .-python-part-2-data flow/# data flow-performance</a></p></figure><p id="c82c" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">实际上，我必须计算 Python 上的<code class="fe mj mk ml mm b">list</code>性能，因为作业在大约 2 小时后仍在运行，每秒大约 8-15 个元素。我通过查看<code class="fe mj mk ml mm b">CoGroupByKey</code>运行的预期输出和运行时间来估算运行时间，因此实际数字可能会更差！</p><p id="d169" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">这符合我们在<code class="fe mj mk ml mm b">DirectRunner</code> - <code class="fe mj mk ml mm b">go</code>上看到的更快，尽管没有上一个 Mandelbrot 示例中的“常规”<code class="fe mj mk ml mm b">go</code>与<code class="fe mj mk ml mm b">Python</code>代码快。我们无法比较<code class="fe mj mk ml mm b">dict</code> / <code class="fe mj mk ml mm b">map</code>逻辑，因为它只在<code class="fe mj mk ml mm b">DirectRunner</code>上运行。</p><p id="7263" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated"><em class="mf"> [0]我不确定为什么</em> <code class="fe mj mk ml mm b"><em class="mf">go</em></code> <em class="mf"> SDK 不产生“记录/秒”指标</em></p><h1 id="2074" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">绩效总结</h1><p id="3046" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">上次，在我们的<code class="fe mj mk ml mm b">Mandelbrot</code>基准测试中，<code class="fe mj mk ml mm b">go</code>几乎比<code class="fe mj mk ml mm b">Python</code>快了 45 倍。</p><p id="8607" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">这一次，总结是这样的:</p><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi ox"><img src="../Images/2649090c78ed7b372e3e7228ebea1518.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XDCU-pgrrwGAmeGEIA5VLQ.png"/></div></div><p class="mz na gj gh gi nb nc bd b be z dk translated"><a class="ae mb" href="https://chollinger.com/blog/2020/07/a-data-engineering-perspective-on-go-vs.-python-part-2-dataflow/#dataflow-performance" rel="noopener ugc nofollow" target="_blank">https://CHOL linger . com/blog/2020/07/a-data-engineering-perspective-on-go-vs .-python-part-2-data flow/# data flow-performance</a></p></figure><p id="ff64" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">所有运行程序和用例的平均性能增益(由于开销和近似运行时间，不包括 100 条记录)是<strong class="lc iu">1290.19%</strong>——如果我们从<code class="fe mj mk ml mm b">list</code>运行时间中取近似值，我们会看到<em class="mf"> 1351.40% </em>，尽管这并不真正公平。</p><p id="75b2" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">无论如何，这确实令人印象深刻。</p><h1 id="af16" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">结论</h1><p id="c9f3" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们学到了什么？</p><h1 id="6dce" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">动态与静态类型&amp; <code class="fe mj mk ml mm b">dict</code>与<code class="fe mj mk ml mm b">struct</code></h1><p id="ebcf" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这部分虽然非常主观，但让我思考了很多。当我第一次开始深入研究第 1 部分时，对我来说很明显<code class="fe mj mk ml mm b">Python</code>缺乏静态类型往往是一种诅咒，而不是一种祝福。我不得不花费大量的时间夜以继日地想弄明白为什么一项工作(无论是<code class="fe mj mk ml mm b">Beam</code>、<code class="fe mj mk ml mm b">Spark</code>、<code class="fe mj mk ml mm b">Pandas</code>、<code class="fe mj mk ml mm b">Dask</code>还是其他什么)不能完成我想要的工作，或者更迫切地说，当我从用户那里得到反馈说他们的数据看起来“不正常”时，这通常是由类型问题引起的。</p><p id="66fc" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">我在第 1 部分中对此进行了阐述——Python 不强制类型化。我经常使用外部库，比如<code class="fe mj mk ml mm b">numpy</code>，来编写在处理数据管道时使用外部配置强制输入的类。这可能遵循这样的逻辑“你的字典应该有属性<code class="fe mj mk ml mm b">averageTemp</code> ( <code class="fe mj mk ml mm b">if 'averageTemp' in dict</code>)，那就是一个<code class="fe mj mk ml mm b">FLOAT64</code>。<code class="fe mj mk ml mm b">FLOAT64</code>映射到 numpy 的<code class="fe mj mk ml mm b">np.float64</code>；为了确保它确实是<code class="fe mj mk ml mm b">FLOAT64</code>，我们将在作业的某一点尝试解析；如果失败，使用<code class="fe mj mk ml mm b">except</code>静默捕捉并将其设置为<code class="fe mj mk ml mm b">None</code>。</p><p id="483e" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">另一方面，在<code class="fe mj mk ml mm b">go</code>中，我不能舒服地那样做。我被迫遵守结构和类型——我甚至不能设置一个<code class="fe mj mk ml mm b">string</code>到<code class="fe mj mk ml mm b">nil</code>,尽管我可能已经非常习惯了。</p><p id="e9ca" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">现在，什么更好？嗯，我认为这是风格和设计的角度问题。虽然我发现在 Python 中“生产”级的工作通常很困难，但是由于上面的边缘情况和解决方法(请记住:如果我的数据不符合数据库规定的格式，我就是问题的一方！)，可以是挑战。</p><p id="d482" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">与此同时，就我个人而言，在<code class="fe mj mk ml mm b">go</code>写我的工作比在<code class="fe mj mk ml mm b">Python</code>花的时间要长得多——因为我需要更多地思考我要做什么。经常像我对待<code class="fe mj mk ml mm b">bash</code>或<code class="fe mj mk ml mm b">zsh</code>一样对待<code class="fe mj mk ml mm b">Python</code>——输入一些东西，希望它有用。引导我去…</p><h1 id="b016" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">编译程序</h1><p id="9eae" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">…编译器。编译器是我已经学会既讨厌又喜欢的东西。由于我没有提到它，让我用几个精选的例子告诉你编译器(或者更确切地说是<code class="fe mj mk ml mm b">go</code>工具链)是做什么的:</p><ol class=""><li id="6594" class="nd ne it lc b ld lw lg lx lj nf ln ng lr nh lv oe nj nk nl bi translated">不能有未使用的变量</li><li id="5c6a" class="nd ne it lc b ld nm lg nn lj no ln np lr nq lv oe nj nk nl bi translated">您不能有未使用的导入</li><li id="9ad9" class="nd ne it lc b ld nm lg nn lj no ln np lr nq lv oe nj nk nl bi translated">你不能使用错误的类型</li></ol><p id="69c6" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">我说的<code class="fe mj mk ml mm b">cannot</code>是指:“无论是<code class="fe mj mk ml mm b">go run</code>还是<code class="fe mj mk ml mm b">go build</code>都不会产生二进制”。</p><p id="9ab4" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">似乎很合理，对吧？嗯——借用我的评论，我发现它既有帮助又乏味。编写<code class="fe mj mk ml mm b">go</code>代码就像编写<code class="fe mj mk ml mm b">Python</code>代码，而<code class="fe mj mk ml mm b">pylint</code>处于高度戒备状态——它不会让你做任何可能让编译器不舒服的事情，同时，确保你所产生的东西将实际工作，而没有副作用。</p><p id="046d" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">同时，具体到<code class="fe mj mk ml mm b">Dataflow</code>，它显然不会捕捉任何特定于工具的东西——例如，不在<code class="fe mj mk ml mm b">init()</code>中注册类只会在您提交作业时成为一个问题。</p><p id="b06e" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated"><code class="fe mj mk ml mm b">Python</code>，另一方面，让我写的代码得到 1/10 的分数<code class="fe mj mk ml mm b">pyLint</code>，这可能是未来 me 的问题。</p><h1 id="d2f1" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">可读性</h1><p id="74b5" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我喜欢<code class="fe mj mk ml mm b">Python</code>中<code class="fe mj mk ml mm b">Beam</code>的语法。一旦你克服了它看起来有多“奇怪”,用类似伪代码的东西来构建<code class="fe mj mk ml mm b">DAG</code>确实是一个很好的方法。</p><p id="b6e4" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated"><code class="fe mj mk ml mm b">go</code>的方法更加学术化。它遵循标准的语言流程——每个函数返回一个<code class="fe mj mk ml mm b">PCollection</code>。这更加直观，但是我发现它失去了<code class="fe mj mk ml mm b">Python</code>的“DAG-as-code”逻辑的好处。</p><p id="1481" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">但是我会让你自己判断——在<a class="ae mb" href="https://github.com/chollinger93/beam-examples" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上查看<code class="fe mj mk ml mm b">Python</code>和<code class="fe mj mk ml mm b">go</code>的完整代码。</p><h1 id="bdb3" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">可拆分 DoFns 和性能</h1><p id="c541" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><code class="fe mj mk ml mm b">go</code>中的性能提升是巨大的，老实说，出乎意料。平均而言，<em class="mf"> 1290.19% </em>的提高是不可小觑的。</p><p id="b01e" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated"><code class="fe mj mk ml mm b">Splittable DoFns</code>另一方面，一旦我们越过相对较小的数据集，开始谈论多个 GB 或 TB，这实际上是一件大事——即使不是交易的破坏者，也使这种练习本质上主要是学术性的。</p><h1 id="f946" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">证明文件</h1><p id="5658" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这是我对 SDK 最大的不满之一，抱怨让我感觉很糟糕，因为绝对没有什么能阻止我致力于此(除了时间)。</p><p id="ed5f" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated"><code class="fe mj mk ml mm b">go</code>的<code class="fe mj mk ml mm b">Beam</code>文档非常乏味——许多功能和示例只适用于<code class="fe mj mk ml mm b">Python</code>和<code class="fe mj mk ml mm b">Java</code>。至少可以说，围绕<code class="fe mj mk ml mm b">go</code>寻找例子、逻辑和整体架构细节是一项挑战。我主要依靠<code class="fe mj mk ml mm b">godocs</code>和阅读相当多的源代码。</p><p id="230e" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">上面的报道应该可以证明这一点——我遇到了很多死胡同。</p><p id="0fbd" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">我使用<code class="fe mj mk ml mm b">go</code> SDK 的过程看起来有点像这样:</p><ol class=""><li id="9ddc" class="nd ne it lc b ld lw lg lx lj nf ln ng lr nh lv oe nj nk nl bi translated">在 Beam 的网站上吗？(通常没有)</li><li id="7aa2" class="nd ne it lc b ld nm lg nn lj no ln np lr nq lv oe nj nk nl bi translated">有带注释的例子吗？我克隆了回购，用<code class="fe mj mk ml mm b">grep</code>搜索关键字；没有很好的例子概述，提供的例子通常没有注释</li><li id="8b95" class="nd ne it lc b ld nm lg nn lj no ln np lr nq lv oe nj nk nl bi translated">难道是在<code class="fe mj mk ml mm b">godocs</code>里？如果是，他们给出例子或者解释如何使用函数性吗？(参见上面的<code class="fe mj mk ml mm b">coder</code>死胡同)</li><li id="3be2" class="nd ne it lc b ld nm lg nn lj no ln np lr nq lv oe nj nk nl bi translated">读取<code class="fe mj mk ml mm b">go</code> SDK 源代码</li></ol><p id="fecf" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">不用说，Google / StackOverflow 的结果几乎为零。</p><h1 id="5dcb" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">和睦相处</h1><p id="ea10" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我已经在第 1 部分提到过这一点，但是考虑到<code class="fe mj mk ml mm b">go</code> SDK 的实验性质，与<code class="fe mj mk ml mm b">Beam</code>特性和<code class="fe mj mk ml mm b">Runners</code>的兼容性显然不如在<code class="fe mj mk ml mm b">Python</code>或<code class="fe mj mk ml mm b">Java</code>中那么好。然而，对于简单的管道和使用<code class="fe mj mk ml mm b">Dataflow</code>作为流道，<code class="fe mj mk ml mm b">go</code>确实涵盖了基本内容。然而，你确实失去了我在引言中提到的一些好处——更少的跑步者意味着更少的选择。</p><h1 id="b708" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">那又怎样？</h1><p id="fa6b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><code class="fe mj mk ml mm b">go</code>是一种有趣的语言，但是在花了很多时间写这些文章、摆弄代码、文档和环境之后，我现在不推荐使用<code class="fe mj mk ml mm b">go</code>作为<code class="fe mj mk ml mm b">Beam</code>管道——至少不推荐作为一个总括声明。</p><p id="ba56" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">当然——它比<code class="fe mj mk ml mm b">Python</code>有优势，语言本身清晰，有据可查，而且快速。</p><p id="997c" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">然而，一旦你超越了标准用例、<code class="fe mj mk ml mm b">Splittable DoFns</code>问题、文档和兼容环境，功能性的缺乏使得使用<code class="fe mj mk ml mm b">Python</code>(或<code class="fe mj mk ml mm b">Java</code>)作为默认更加合理。虽然更熟悉<code class="fe mj mk ml mm b">Beam</code>的<code class="fe mj mk ml mm b">go</code> SDK 的人肯定可以解决我的一些问题——就像上面的<code class="fe mj mk ml mm b">map</code>问题——但是仍然有很多事情使得在<code class="fe mj mk ml mm b">Dataflow</code>管道的生产中使用<code class="fe mj mk ml mm b">go</code>至少是有问题的。</p><p id="3431" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">然而，对于更简单的管道——我相信，如果你可以接受一个官方尚未支持的运行器(<code class="fe mj mk ml mm b">Dataflow</code>)，那么性能提升是值得的。</p><p id="a648" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">也就是说，我肯定会密切关注<code class="fe mj mk ml mm b">Beam</code> SDK 的进展，如果有机会，我希望在未来致力于它——因为<code class="fe mj mk ml mm b">go</code>是一门非常有趣的语言，不能忽视。</p><p id="518d" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated"><em class="mf">所有的开发和基准测试都是在 GNU/Linux [PopOS！20.04 在内核 5.4 上]在 2019 System76 Gazelle 笔记本电脑上使用 12 个英特尔 i7–9750h v cores @ 4.5 GHz 和 16GB RAM，使用 0.5 版本的 data flows Go Runner</em></p><blockquote class="mc md me"><p id="df41" class="la lb mf lc b ld lw ju lf lg lx jx li mg ly ll lm mh lz lp lq mi ma lt lu lv im bi translated">最初发表@<a class="ae mb" href="https://chollinger.com/blog/2020/07/a-data-engineering-perspective-on-go-vs.-python-part-2-dataflow/" rel="noopener ugc nofollow" target="_blank">chollinger.com/blog</a></p></blockquote></div><div class="ab cl oy oz hx pa" role="separator"><span class="pb bw bk pc pd pe"/><span class="pb bw bk pc pd pe"/><span class="pb bw bk pc pd"/></div><div class="im in io ip iq"><p id="221e" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated"><em class="mf">原载于 2020 年 7 月 6 日</em><a class="ae mb" href="https://chollinger.com/blog/2020/07/a-data-engineering-perspective-on-go-vs.-python-part-2-dataflow/" rel="noopener ugc nofollow" target="_blank"><em class="mf">https://chollinger.com</em></a><em class="mf">。</em></p></div></div>    
</body>
</html>