<html>
<head>
<title>Introduction to Convolutional Neural Network (CNN) using Tensorflow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用张量流介绍卷积神经网络(CNN)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/introduction-to-convolutional-neural-network-cnn-de73f69c5b83?source=collection_archive---------2-----------------------#2020-03-02">https://towardsdatascience.com/introduction-to-convolutional-neural-network-cnn-de73f69c5b83?source=collection_archive---------2-----------------------#2020-03-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/08cbe5c795b403efc9ee0e52918d2b7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QnKckNSZilG3HxytJZUoAw.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">本页面的部分内容转载自Google创建和共享的作品，并根据知识共享4.0归属许可中描述的条款使用。<a class="ae kf" href="https://developers.google.com/machine-learning/practica/image-classification/images/cnn_architecture.svg" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure></div><div class="ab cl kg kh hx ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="im in io ip iq"><p id="b8f6" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">几乎每一种行业都在使用机器学习。它帮助人们最大限度地减少他们的工作量，因为机器能够高性能地执行大多数人工任务。机器可以进行预测分析，如分类和回归(预测数值)，以及驾驶汽车等需要某种智能的任务。</p><p id="89e2" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">机器学习是人工智能的一部分，其中我们向机器提供数据，以便它可以<strong class="kp iu"> <em class="ll">从数据</em> </strong>中学习模式，并且它将能够预测未来类似问题的解决方案。<strong class="kp iu">神经网络(NN) </strong>灵感来自人脑的神经网络。<strong class="kp iu">计算机视觉</strong>是人工智能的一个领域，专注于与图像相关的问题。CNN结合计算机视觉能够执行复杂的操作，从对图像进行分类到解决天文学的科学问题和建造自动驾驶汽车。。</p></div><div class="ab cl kg kh hx ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="im in io ip iq"><blockquote class="lm"><p id="f536" class="ln lo it bd lp lq lr ls lt lu lv lk dk translated">杰弗里·辛顿(Geoffrey Hinton)说，“我认为人们需要明白，深度学习正在幕后使许多事情变得更好。”</p></blockquote></div><div class="ab cl kg kh hx ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="im in io ip iq"><p id="a67a" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">所以问题是，这些机器如何学习处理图像？</p><p id="3537" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">它使用卷积神经网络来有效地完成这项任务。我们先来了解一下什么是卷积神经网络，又名<strong class="kp iu"> CNN </strong>。</p><p id="063c" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">众所周知，图像是二维像素阵列。任何图像都可以根据其特征进行分类。SVM、决策树、随机森林等科学学习算法擅长解决分类问题，但无法从图像中提取合适的特征。</p><p id="2cdb" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">这就是卷积神经网络发挥作用的地方。CNN是卷积层和神经网络的结合。</p><p id="70b7" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">基本上任何用于图像处理的<em class="ll">神经网络</em>都包括以下层</p><ul class=""><li id="2da6" class="lw lx it kp b kq kr ku kv ky ly lc lz lg ma lk mb mc md me bi translated">输入层，卷积层，汇集层，密集层。</li></ul><p id="88d5" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">卷积只不过是应用于图像<em class="ll">以从中提取特征</em>的过滤器。我们将使用这种不同的卷积来从图像中提取不同的特征，如边缘、高光图案。</p><figure class="mg mh mi mj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mf"><img src="../Images/dce9fe74bd31341e922b2b52c68514d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1086/1*Ff6mG3aPdWFkjb6hZPy3Xw.gif"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">卷积如何作用于图像。<a class="ae kf" href="https://mlnotebook.github.io/post/CNN1/" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="d05a" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">这个卷积的作用是创建一个一定大小的过滤器(默认大小为3X3)。创建过滤器后，它从图像的左上角开始执行元素乘法。逐元素乘法意味着将具有相同索引的元素相乘。将这些计算值相加以获得像素值，并将其存储在新矩阵中。我们将使用这个新生成的矩阵进行进一步处理。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="dbd2" class="mp mq it ml b gy mr ms l mt mu">Conv2D(32, 3, activation='relu') <br/># 32 filters or convolutions of size 3 X 3, with <em class="ll">relu</em> as activation function.<!-- --> </span></pre><p id="3e51" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">当我们继续在获得的矩阵上应用过滤器时，矩阵的大小减小。</p><blockquote class="lm"><p id="0080" class="ln lo it bd lp lq lr ls lt lu lv lk dk translated"><em class="mv">新矩阵的大小=(旧矩阵的大小-滤波器大小)+1 </em></p></blockquote><p id="b326" class="pw-post-body-paragraph kn ko it kp b kq mw ks kt ku mx kw kx ky my la lb lc mz le lf lg na li lj lk im bi translated">当我们说卷积层大小是32时。这意味着将对图像应用32个随机生成的滤波器，从而为该图像输出32个特征矩阵。这些特征矩阵作为输入传递到下一层。</p><p id="6994" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">在应用卷积之后，还有一个概念叫做<strong class="kp iu">池</strong>。池用于减小图像的大小。有两种类型的池:</p><ol class=""><li id="f026" class="lw lx it kp b kq kr ku kv ky ly lc lz lg ma lk nb mc md me bi translated"><strong class="kp iu">最大池:</strong>从指定大小的矩阵中选择最大值(默认大小为2 X 2)。这种方法有助于提取图像中具有高重要性或高亮显示的特征。</li></ol><p id="edc1" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">高亮度特征是具有高像素值的图像的一部分。</p><figure class="mg mh mi mj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nc"><img src="../Images/d46e752c755d82b6c773cdf4256a4607.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*vOxthD0FpBR6fJcpPxq6Hg.gif"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">最大池大小为2 X 2。<a class="ae kf" href="https://cdn-images-1.medium.com/max/1000/1*lRVHY6UXH7K5sfr9L_YVvg.gif" rel="noopener">来源</a></p></figure><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="ab66" class="mp mq it ml b gy mr ms l mt mu">MaxPooling2D() # method for Max-pooling layer <br/>               # default size of matrix is 2 X 2</span></pre><p id="b86e" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">2.<strong class="kp iu">平均池</strong>:与最大池不同，平均池取池层矩阵(默认大小为2 X 2)所有像素值的平均值。</p><figure class="mg mh mi mj gt ju gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/98407e19c501332b81f28b27f5fe51c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/format:webp/1*5U2dM5N8uI4eEunolJHRhg.jpeg"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">平均池。<a class="ae kf" href="http://static.zybuluo.com/mShuaiZhao/85xogdnxjl4hqd6hm3magreb/average_pooling.png" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="4333" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">在上面的例子中，图像大小是4 X 4，池大小是2 X 2。从左上角像素开始。它将计算2 X 2块矩阵的平均值。对于第一个2 X 2块，输出值计算为(1+3+2+9)/4 = 15/4 =<strong class="kp iu"><em class="ll">3.75</em></strong>。以类似的方式，将计算所有其他值。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="6387" class="mp mq it ml b gy mr ms l mt mu">AveragePooling2D()  <!-- --># method for Average pooling layer<br/>                    # default size of matrix is 2 X 2</span></pre><p id="c14c" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">在大多数情况下，使用最大池是因为它的性能比平均池好得多。</p><p id="b81e" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">在任何一个<em class="ll">神经网络</em>中，第一层是输入层，最后一层是输出层。输入层包含所有的输入，这里图像是输入。这些图像作为输入被提供给第一卷积层。第一层的输出将作为第二层的输入，依此类推&amp;。这个过程将持续到最后一层。</p><p id="ba26" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">在定义<em class="ll">神经网络</em>时，第一卷积层需要作为输入传递给它的图像的形状。在传递图像之后，通过所有卷积层和池层，输出将被传递到密集层。</p><p id="cc1b" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我们不能将卷积层的输出直接传递给密集层，因为卷积层的输出是多维形状的，而<strong class="kp iu">密集层需要一维</strong> <em class="ll"> </em> <strong class="kp iu">形状</strong>即一维数组的输入。</p><p id="1ffa" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">所以我们将在卷积层和密集层之间使用Flatten()方法。Flatten()方法将多维矩阵转换为一维矩阵。在<em class="ll">神经网络</em>中，非线性函数被用作<em class="ll">激活函数</em>。</p><figure class="mg mh mi mj gt ju gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/9135db3c929ed073a517c29dafaa6fe4.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*gbqQNd8x40ug4WOuiiNiiw.jpeg"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">线性函数图。<a class="ae kf" href="https://study.com/cimages/multimages/16/nonlinear_functions_graph_1.jpg" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="7a5c" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated"><strong class="kp iu">线性函数</strong>是最高指数为1的表达式。线性函数的图形是直线。</p><p id="aec2" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">例如:Y= 2X +3。</p><figure class="mg mh mi mj gt ju gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/8174d9838a48afbc27af4dd8a7830f3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*yiRkKeAHaxX2d3QDUT2WzA.jpeg"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">非线性函数图。<a class="ae kf" href="https://study.com/cimages/multimages/16/nonlinear_functions_graph_2.jpg" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="5a82" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">而<strong class="kp iu">非线性函数</strong>是最高指数大于1的表达式。非线性函数的图形不是直线，而是曲线。</p><p id="1a1c" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">例如:Y= X</p></div><div class="ab cl kg kh hx ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="im in io ip iq"><p id="c3c2" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">密集层是神经元的简单层，其中每个神经元接收来自前一层所有神经元的输入，因此称为<em class="ll">密集</em>。密集层用于根据卷积层的输出对图像进行分类。</p><figure class="mg mh mi mj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nf"><img src="../Images/8d0b3a308bfa5eb3ed17d402995453d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qm6h3XvYUzhpITZBIvzuLg.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">单个神经元的工作。一层包含多个这样的神经元。<a class="ae kf" href="https://i.stack.imgur.com/wXL9A.png" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="9794" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated"><em class="ll">神经网络</em>中的每一层都包含神经元，这些神经元计算其输入的<strong class="kp iu">加权平均值，并且这个加权平均值通过一个非线性函数传递，这个非线性函数被称为一个“<strong class="kp iu"> <em class="ll">激活函数”</em> </strong>。该激活函数结果被视为神经元的输出。以类似的方式，对所有层的所有神经元执行该过程。</strong></p><p id="582e" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">最后一层的输出将被视为该图像的输出。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="295c" class="mp mq it ml b gy mr ms l mt mu">#sample code for creating Convolutional Neural Network</span><span id="8943" class="mp mq it ml b gy ng ms l mt mu">model = models.Sequential()<br/>model.add(layers.Conv2D(32, (3, 3), activation='relu', input_shape=(32, 32, 3)))<br/>model.add(layers.MaxPooling2D())<br/>model.add(layers.Conv2D(64, (3, 3), activation='relu'))<br/>model.add(layers.MaxPooling2D())<br/>model.add(layers.Conv2D(64, (3, 3), activation='relu'))</span><span id="ee45" class="mp mq it ml b gy ng ms l mt mu">model.add(layers.Flatten()) <br/>model.add(layers.Dense(64, activation='relu'))<br/>model.add(layers.Dense(10, activation='softmax'))</span></pre><p id="3ced" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">这里，输出层有10个神经元具有<strong class="kp iu"> softmax </strong>激活功能。<strong class="kp iu"> Softmax </strong>激活功能在我们有2个或2个以上的类时使用。如果我们总共有10个类，那么输出层中的神经元数量将是10。<strong class="kp iu">每个神经元代表一个类。</strong></p><p id="a55a" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">所有10个神经元将返回各自类别的输入图像的概率。<em class="ll">具有最高概率的类别将被认为是该图像</em>的输出。</p><p id="c9a9" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">同样，我们将所有图像传递到卷积层，然后传递到<em class="ll">神经网络</em>，它将为这些图像产生相应的输出。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="88b7" class="mp mq it ml b gy mr ms l mt mu">model.summary()</span></pre><p id="cab9" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">summary()方法将显示模型的架构。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="cb3d" class="mp mq it ml b gy mr ms l mt mu">Model: "sequential"<br/>_________________________________________________________________<br/>Layer (type)                 Output Shape              Param #   <br/>=================================================================<br/>conv2d (Conv2D)              (None, 30, 30, 32)        896       <br/>_________________________________________________________________<br/>max_pooling2d (MaxPooling2D) (None, 15, 15, 32)        0         <br/>_________________________________________________________________<br/>conv2d_1 (Conv2D)            (None, 13, 13, 64)        18496     <br/>_________________________________________________________________<br/>max_pooling2d_1 (MaxPooling2 (None, 6, 6, 64)          0         <br/>_________________________________________________________________<br/>conv2d_2 (Conv2D)            (None, 4, 4, 64)          36928     <br/>_________________________________________________________________<br/>flatten (Flatten)            (None, 1024)              0         <br/>_________________________________________________________________<br/>dense (Dense)                (None, 64)                65600     <br/>_________________________________________________________________<br/>dense_1 (Dense)              (None, 10)                650       <br/>=================================================================<br/>Total params: 122,570<br/>Trainable params: 122,570<br/>Non-trainable params: 0<br/>_________________________________________________________________</span></pre><p id="7a74" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated"><strong class="kp iu">参数</strong> (params)是<em class="ll">权重和偏差</em>，将用于CNN所有神经元的<em class="ll">计算</em>。</p><p id="e4f6" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">当我们在一些图像上训练任何模型时，它将为所有参数(即权重和偏差)确定一些特定值，这些值用于处理图像和预测该图像的输出。</p><p id="eceb" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">卷积神经网络主要用于二元和多类、多标签分类。有一些p <em class="ll">重新训练的模型</em>像<em class="ll"> Inception、VGG16、VGG19、mobilenet </em>等，它们是一些研究人员在数百万张图像上训练它们以将图像分类到多个类别后创建的。这些模型已经学习了对图像进行分类的模式。如果你计划建立一个图像分类器，那么你也可以使用这些模型中的一个作为基础层，并在最后添加一些你选择的密集层。密集图层的数量将根据您的要求和输出类的数量而变化。</p><p id="c9d0" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">在本文中，我们做了卷积神经网络的基础知识，这是非常重要的建立图像分类模型的演练。在下一篇文章中，让我们看看如何使用预先训练的模型来构建一个图像分类器。</p><p id="5c12" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">如果想查看更多关于卷积神经网络的内容，可以参考Tensorflow官网，<a class="ae kf" href="https://www.tensorflow.org/tutorials/images/cnn" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><p id="02c0" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">感谢阅读。😊</p></div></div>    
</body>
</html>