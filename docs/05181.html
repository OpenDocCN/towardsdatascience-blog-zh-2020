<html>
<head>
<title>Multi faceted data exploration in the browser using Leaflet and amCharts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用传单和amCharts在浏览器中进行多方面的数据探索</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/multi-faceted-data-exploration-in-the-browser-using-leaflet-and-amcharts-f74d049d78d9?source=collection_archive---------38-----------------------#2020-05-03">https://towardsdatascience.com/multi-faceted-data-exploration-in-the-browser-using-leaflet-and-amcharts-f74d049d78d9?source=collection_archive---------38-----------------------#2020-05-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="be29" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在浏览器中创建一个数据探索仪表板，从Google Sheets加载实时记录，并将地理空间信息与时间数据交叉。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f3a539cd1048dcd20c8f877b53824d1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fFqET0clia1bRCMbmMIuAw.png"/></div></div></figure><p id="1260" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">演示:<a class="ae ln" href="https://smarques.github.io/mufa-leaf/" rel="noopener ugc nofollow" target="_blank">https://smarques.github.io/mufa-leaf/</a><br/>(演示中的数据是随机的，真正的研究还没有发表。)</p><p id="940f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这个充满挑战的CoVid时代，我被要求对我居住的意大利地区进行数据可视化。</p><p id="3fdf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这些数据由大约20k条记录组成，按照子行业、主题类型、数据来源和活动开始的年份进行地理参考和标记。</p><blockquote class="lo lp lq"><p id="49a3" class="kr ks lr kt b ku kv jr kw kx ky ju kz ls lb lc ld lt lf lg lh lu lj lk ll lm ij bi translated">例如:<br/><br/>subsector =&gt;sub C1，<br/>subject =&gt;subject 2，<br/> year = &gt; 1985，<br/>position =&gt;【45.375302，11.727905】<br/>source =&gt;gov . Census</p></blockquote><p id="1014" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我的目标是以不同的方式探索这些数据:<br/> - <strong class="kt ir">作为地图上的标记和聚类</strong>-<br/>-<strong class="kt ir">作为可导航的树形图</strong>-<br/>-<strong class="kt ir">通过过滤器和时间轴选择器</strong></p><p id="508c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">理想情况下，这种可视化应该应用于整个数据集或选定的数据子集，以便您可以应用过滤器，查看特定年份的分布情况，也可能仅针对给定省份的特定子行业。</p><p id="f48b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">想法是将数据作为JSON结构加载到浏览器中，并保存在内存中，根据用户与过滤器的交互加载子集，并将子集数据提供给每个可视化。</p><p id="64cc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我在这里将会介绍一些流程，具体的实现请参考GitHub repo:<a class="ae ln" href="https://github.com/smarques/mufa-leaf" rel="noopener ugc nofollow" target="_blank">https://github.com/smarques/mufa-leaf</a></p><h1 id="523e" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">准备数据</h1><p id="a6d8" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">由于数据仍在修改和重新分类中，我想从一个共享的谷歌表单中加载它。我还用谷歌工作表对地址进行地理编码，使用的是<a class="ae ln" href="https://github.com/nuket/google-sheets-geocoding-macro" rel="noopener ugc nofollow" target="_blank">这个漂亮的谷歌工作表宏</a>。</p><p id="f4fb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为人们仍在使用google sheet，所以我决定在将数据导入我的JS应用程序时直接进行数据检查和数据清理。</p><p id="c817" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要从Google工作表中加载数据，我找到的最佳选项是<a class="ae ln" href="https://www.papaparse.com/" rel="noopener ugc nofollow" target="_blank"> Papa Parse </a>。它可以让你把CSV解析成JSON，从任何地方加载，处理大文件，所有的事情，而且它有一个有趣的名字。</p><p id="d89f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们试一试。</p><p id="9c74" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，您需要在Google表单上执行两个操作:</p><ul class=""><li id="f96e" class="ms mt iq kt b ku kv kx ky la mu le mv li mw lm mx my mz na bi translated">发布到web:文件-&gt;发布到web，复制网址，会是这样的:<a class="ae ln" href="https://docs.google.com/spreadsheets/d/e/2PACX-1vSZ3vkQTK-CrT7Rv6Rdu3uDKmumQB94Ic7WrmBu4ezak-72QWbkUISb7FfvR_Z1AhmYgfASVad205BE/pubhtml" rel="noopener ugc nofollow" target="_blank"><em class="lr">https://docs.google.com/spreadsheets/d/e/&lt;哈希&gt;/pub html</em>T3】</a></li><li id="307d" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">分享:点击右上方的分享按钮，然后点击获取可分享链接。这将打开按链接共享，任何有链接的人都可以看到数据。</li></ul><p id="b10c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你需要提供给Papa Parse的url(呀，这个名字真有趣)是https://docs.google.com/spreadsheets/d/e/<em class="lr">T4&lt;哈希&gt; /pub？输出= CSV</em>T7】</p><p id="1882" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你也可以直接从google sheets导出JSON格式的数据，但是我们的朋友Papa给了我们更多的类型转换、数据清理等选项。</p><p id="c04a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">完成后，您只需通过以下方式导入数据:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div><p class="ni nj gj gh gi nk nl bd b be z dk translated"><a class="ae ln" href="https://gist.github.com/smarques/3dbfaaae4b3d8a204d2ac280f488528e" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/smarques/3d bfaaae 4 B3 D8 a 204 D2 AC 280 f 488528 e</a></p></figure><p id="15ae" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="lr"> processData </em>函数负责清理和提炼我们从Google Sheets收到的数据。有时你需要应用一些正则表达式，删除奇怪字符，修复输入错误。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h1 id="8e30" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">创建聚类地图</h1><p id="85e7" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">现在的目标是让这些家伙在地图上，可能在三个不同的层和不同的标记颜色层。我们还希望标记有一个不同的主题类型的图标。因为我们有将近30k个标记，所以设置一些聚类可能是个好主意。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6f8551abfd4644a2af90eabf61aab669.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-wqVpAm7Puz1uQWjULFdow.png"/></div></div></figure><p id="773b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我选择的地图库是<a class="ae ln" href="https://leafletjs.com/" rel="noopener ugc nofollow" target="_blank">传单</a>。它有很棒的代码和文档，非常灵活，有一个很好的插件生态系统。</p><p id="1396" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我添加了几个插件，如:<br/> <a class="ae ln" href="https://github.com/Leaflet/Leaflet.fullscreen" rel="noopener ugc nofollow" target="_blank">传单全屏控制</a>因为我只是喜欢让地图全屏<br/> <a class="ae ln" href="https://github.com/rowanwins/leaflet-easyPrint" rel="noopener ugc nofollow" target="_blank">传单轻松打印</a>:有几个打印插件，但这似乎对我最有效<br/> <a class="ae ln" href="https://github.com/leaflet-extras/leaflet-providers" rel="noopener ugc nofollow" target="_blank">传单提供者</a>:要轻松混合和匹配不同来源的瓷砖，我必须提到<a class="ae ln" href="https://stamen.com/opensource/" rel="noopener ugc nofollow" target="_blank">雄蕊水彩瓷砖</a>因为它们真的很赏心悦目。<br/> <a class="ae ln" href="https://github.com/lvoogdt/Leaflet.awesome-markers" rel="noopener ugc nofollow" target="_blank">传单牛逼标记</a>让你在地图标记上使用牛逼字体图标</p><p id="f634" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，如果您只需显示并最终过滤传单地图上的标记，通常的做法是将标记添加到相应的图层，然后调用地图上的函数来隐藏或显示整个图层或特定标记。我的想法有点不同，我想<strong class="kt ir">将所有数据保存在应用程序级别</strong>，这样我不仅可以将它用于地图，还可以用于其他图形和小部件。<strong class="kt ir">当我们应用过滤器时，我希望在应用程序级别过滤数据，随后重新绘制地图</strong>，以及应用程序中任何其他数据相关的小部件。</p><p id="b80b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">此时的问题是:地图和图形的重绘速度是否足够快，以提供良好的用户体验和数据探索？<br/>让我们来了解一下。<em class="lr">(剧透:yayyy他们做)</em></p><p id="5714" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，我们在应用程序中有一个名为<em class="lr"> currentData </em>的变量，它保存当前显示的完整记录集的子集。每次用户改变选择过滤器时，我们从<em class="lr"> App.data </em>开始创建一个新的数据选择，保存到<em class="lr"> App.currentData </em>中，并触发每个小部件的重绘。</p><pre class="kg kh ki kj gt nm nn no np aw nq bi"><span id="3a3f" class="nr lw iq nn b gy ns nt l nu nv">updateCurrentData(App.data);</span></pre><p id="863b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">即使我们只是在清理数据后初始化应用程序，我们也可以调用update函数来填充应用程序<em class="lr"> currentData </em>，因为用户没有机会过滤记录集，函数将只选择每一条记录，我们就可以开始了。</p><p id="d12a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在让我们看看如何使用地图小部件。</p><p id="2e21" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">没有聚类，地图会有点拥挤:不是很有用，而且在你的浏览器上也很沉重。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f714a9d2a3c38c7d8a01b0b38a0bdc20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UUQJsvWxWAWx6sC98whn6Q.png"/></div></div></figure><p id="6901" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，让我们使用<a class="ae ln" href="https://github.com/Leaflet/Leaflet.markercluster" rel="noopener ugc nofollow" target="_blank">传单添加一个聚类级别。标记集群</a>。</p><p id="d3c2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我根据标记所属的子部门来构造标记，这里只有4个可能的值，所以让每个子部门在不同的层上会使每个组的开关变得非常容易。此外，这将使每个子行业有可能有单独的集群，使显示更有趣，并为数据分布提供更好的线索。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f222771705df97a26097dc261bc07eee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LrVccAEzs2CwzO7MZcAxZA.png"/></div></div></figure><p id="c7ac" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">MarkerCluster允许您自定义显示聚类标记的功能(因此得名..)因此，根据集群的大小，我有稍微不同的标记。(例如，参见9对325红色星团)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="0a9a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于四个扇区中的每一个，我们实例化一个标记集群组，给出一个iconCreateFunction，如前所述。我还在集群图标上添加了一个鼠标悬停功能，这样你就可以通过将鼠标悬停在一个层上来向上浮动(改变它的z索引)。</p><p id="f081" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我还想强调这项研究涉及的领域。传单让你加载<a class="ae ln" href="https://geojson.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> GeoJSON </strong> </a>所以我所要做的就是在GitHub中搜索带有该区域形状的GeoJSON，并将其加载到自己的图层上。(感谢<a class="ae ln" href="https://github.com/stefanocudini" rel="noopener ugc nofollow" target="_blank">斯特凡诺·库迪尼</a>)</p><pre class="kg kh ki kj gt nm nn no np aw nq bi"><span id="4b96" class="nr lw iq nn b gy ns nt l nu nv">L.geoJson(venetoData).addTo(App.mainMap);</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/aeb7986f13d6ac331bf1b7444f95d0ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ivxyj8K5gUaVQZXIGIpeoA.png"/></div></div></figure><h1 id="09e4" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">过滤器！</h1><p id="fe27" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">我希望所有的过滤器都集成到地图中，所以我在地图的右侧添加了一个侧面板，让您可以打开不同的过滤器控制面板。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/d7bbdfdb6a04f35b3a6905d3c7bcaa89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YQI5pV3r58bmSzXQoVHzCg.png"/></div></div></figure><p id="3189" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我为整个子行业或某个行业内的单个主题创建了过滤器。然后过滤每个省</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/94f2a1412d34cdc4f4f1edeca98b88f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XTF-I7JhFnqa__0GEFM6cQ.png"/></div></div></figure><p id="c8de" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">并且对于每个数据源</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/6eaf46b409ad6a8f9efa3b7fe4bca989.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WMSZfX4pQoDVLNS3KYllCA.png"/></div></div></figure><p id="2738" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我不会深入讨论所有过滤器gui的实现细节，您可以在GitHub repo上查找，基本上是为了避免回调地狱每个gui元素都使用<a class="ae ln" href="https://baconjs.github.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> bacon.js </strong> </a>(一个反应函数库)连接到一个事件流。这样，任何过滤器中的任何更改都会导致调用相同的更新函数，传递完整的过滤器值集，以便我们可以将所有需要的条件应用到完整的数据集，并为每个要显示的小部件加载新的<em class="lr"> currentData </em>子集。</p><h1 id="b514" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">更新功能</h1><p id="9d1a" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">因为我希望将数据过滤保持在主应用程序级别，所以每次过滤器发生变化时，我都会调用一个更新函数来从整个集合中提取相关数据。<br/>我使用一个名为<a class="ae ln" href="https://github.com/agershun/alasql" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir">的js库alasql </strong> </a> <strong class="kt ir"> </strong>根据用户选择的过滤器处理15k记录数组。其中，alasql允许您对任何对象数组运行sql查询。这使得处理您的数据变得非常容易，并且使您的代码可读，易于调试和维护。</p><p id="fb80" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我可以运行如下查询:</p><pre class="kg kh ki kj gt nm nn no np aw nq bi"><span id="5f8f" class="nr lw iq nn b gy ns nt l nu nv">var res = alasql(`SELECT MIN(${App.field_names.year}) AS minYear, MAX(${App.field_names.year}) AS maxYear FROM ? WHERE ${App.field_names.year} &gt; 1900`, [App.currentData]);</span></pre><p id="9a65" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">至此，我在update函数中所要做的就是构建一个条件数组来添加到我的SELECT语句中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="bd81" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">事实证明，如果您删除所有图层标记并重新添加它们，MarkerCluster的更新速度非常快，所以当我有一个新的currentData对象时，我只需运行它并重新分配它。</p><h1 id="067d" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">时间轴选择器</h1><p id="c102" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">接下来，我们希望能够根据年间隔选择记录。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/3ec7f35c8a0ed1169d9d4d26de1da31b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zxI3v2UWJY6rrkRKSoIyWg.png"/></div></div></figure><p id="9265" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">传单控件只是html元素，所以我使用了<a class="ae ln" href="http://ionden.com/a/plugins/ion.rangeSlider/index.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> Ion。RangeSlider </strong> </a>并将其值添加到触发新查询和后续重绘的反应流中。<br/>当我第一次从Google Sheet接收数据时，我只获得了year列的最小值和最大值，所以我可以用它来显示时间选择器的合理范围。</p><h1 id="9bab" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">树形图</h1><p id="41f7" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">作为最后一个元素，我们添加了一个树形图，这样我们就可以可视化所选子集的结构。我包含了<a class="ae ln" href="https://www.amcharts.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> amCharts </strong> </a>库，并在我的更新函数中设置了一个调用来重绘图表。我选择按省份开始分解。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/61d93621cb03b1a9d523e87ef5fe0970.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JpQlIZzTIJcZmqRWm-QoQA.png"/></div></div></figure><p id="1c6e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，您可以点击树形图块，在可视化视图中向下钻取。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/68b2192c4becefb6dab01d0040ff8b97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oeFkWGyoiRqu0OmEzRF0oQ.png"/></div></div></figure><h1 id="132a" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">包装它</h1><p id="78cd" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">因此，现在我们有了一个主应用程序层，它负责加载完整的数据，根据不同的过滤器和用户行为进行子选择，然后触发不同图形和小部件的更新。这是一个很好的框架，可以让用户在浏览器中探索数据，并且很容易添加更多的可视化。关键是它们都引用相同的数据子集。<br/>例如，当您更改year参数时，查看位置和数据结构如何变化非常有用。您可以添加一个播放按钮，并创建一个显示每年变化的动画。<br/>另一个改进是通过IndexedDb (alasql支持它)同步本地存储上的数据，以便您有完整的离线体验。</p><p id="90cf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你想添加元素或进行实验，请随意在GitHub 上提出请求！</p></div></div>    
</body>
</html>