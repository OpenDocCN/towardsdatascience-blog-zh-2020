<html>
<head>
<title>Basic Curve Fitting of Scientific Data with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Python 实现科学数据的基本曲线拟合</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/basic-curve-fitting-of-scientific-data-with-python-9592244a2509?source=collection_archive---------0-----------------------#2020-04-12">https://towardsdatascience.com/basic-curve-fitting-of-scientific-data-with-python-9592244a2509?source=collection_archive---------0-----------------------#2020-04-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="9150" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/python-science-plotting" rel="noopener" target="_blank"> Python 科学绘图</a></h2><div class=""/><div class=""><h2 id="d560" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">使用 Python 将非线性函数拟合到实验数据点的基本指南</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/94a17425f6c7c0711349dd5fd1cea1c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bnc6XQfNbXR6QIX3tNVK8g.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">克里斯·利维拉尼在<a class="ae lh" href="https://unsplash.com/s/photos/statistics?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="9d10" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">除了从我们的实验中绘制数据点之外，我们还必须经常将它们拟合到理论模型中，以提取重要的参数。这篇短文将指导如何将一组点拟合到一个已知的模型方程，我们将使用<code class="fe me mf mg mh b">scipy.optimize.curve_fit</code>函数来完成。用 Python 为科学出版物绘制数据的基础知识可以在我之前的文章<a class="ae lh" rel="noopener" target="_blank" href="/an-introduction-to-making-scientific-publication-plots-with-python-ea19dfa7f51e">这里</a>中找到。我将介绍三种常见的非线性拟合:(1)指数拟合，(2)幂律拟合，以及(3)高斯峰值拟合。</p><p id="ad69" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了使用<code class="fe me mf mg mh b">curve_fit</code>函数，我们使用下面的<code class="fe me mf mg mh b">import</code>语句:</p><pre class="ks kt ku kv gt mi mh mj mk aw ml bi"><span id="5652" class="mm mn it mh b gy mo mp l mq mr"># Import curve fitting package from scipy<br/>from scipy.optimize import curve_fit</span></pre><p id="b160" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这种情况下，我们只使用<code class="fe me mf mg mh b">scipy</code>包中的一个特定函数，所以我们可以直接导入<em class="ms">只是</em> <code class="fe me mf mg mh b">curve_fit</code>。</p><h1 id="4da8" class="mt mn it bd mu mv mw mx my mz na nb nc ki nd kj ne kl nf km ng ko nh kp ni nj bi translated"><strong class="ak">指数拟合</strong></h1><p id="7df7" class="pw-post-body-paragraph li lj it lk b ll nk kd ln lo nl kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">假设我们有一个如下形式的一般指数函数，我们知道这个表达式适合我们的数据(其中<em class="ms"> a </em>和<em class="ms"> b </em>是我们将适合的常数):</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi np"><img src="../Images/7f84ff426a0756512625060895e126dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r9q_w49kC9y1jywUmj3CCw.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">一般指数函数</p></figure><p id="64f2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">首先，我们必须定义如上所示的指数函数，以便<code class="fe me mf mg mh b">curve_fit</code>可以使用它来进行拟合。</p><pre class="ks kt ku kv gt mi mh mj mk aw ml bi"><span id="6b7d" class="mm mn it mh b gy mo mp l mq mr"># Function to calculate the exponential with constants a and b<br/>def exponential(x, a, b):<br/>    return a*np.exp(b*x)</span></pre><p id="5b48" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们将从生成一个“虚拟”数据集来适应这个函数开始。要为我们的<em class="ms"> x </em>值生成一组均匀分布在指定间隔上的点，我们可以使用<code class="fe me mf mg mh b">np.linspace</code>函数。</p><pre class="ks kt ku kv gt mi mh mj mk aw ml bi"><span id="3599" class="mm mn it mh b gy mo mp l mq mr"># Generate dummy dataset<br/>x_dummy = np.linspace(start=5, stop=15, num=50)</span></pre><p id="1adb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe me mf mg mh b">start</code> —我们序列的起始值</p><p id="2f89" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe me mf mg mh b">stop</code> —序列的结束值(将包括该值，除非您提供额外的参数<code class="fe me mf mg mh b">endpoint=False</code>)</p><p id="8f41" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe me mf mg mh b">num</code> —将间隔分割成的点数(默认为<code class="fe me mf mg mh b">50</code>)</p><p id="cb7f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">注意，您不需要显式地写出输入名称— <code class="fe me mf mg mh b">np.linspace(-5, 5, 100)</code>同样有效，但是对于本文的目的来说，它使事情更容易理解。</p><p id="1290" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于我们的虚拟数据集，我们将把<em class="ms"> a </em>和<em class="ms"> b </em>的值都设置为 0.5。</p><pre class="ks kt ku kv gt mi mh mj mk aw ml bi"><span id="907a" class="mm mn it mh b gy mo mp l mq mr"># Calculate y-values based on dummy x-values<br/>y_dummy = exponential(x_dummy, 0.5, 0.5)</span></pre><p id="bd2e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了确保我们的数据集不是完美的，我们将使用<code class="fe me mf mg mh b">np.random.normal</code>在我们的数据中引入一些噪声，它从正态(高斯)分布中抽取一个随机数。然后，我们将这个随机值乘以一个标量因子(本例中为 5 ),以增加噪声量:</p><pre class="ks kt ku kv gt mi mh mj mk aw ml bi"><span id="7eef" class="mm mn it mh b gy mo mp l mq mr"># Add noise from a Gaussian distribution<br/>noise = 5*np.random.normal(size=y_dummy.size)<br/>y_dummy = y_dummy + noise</span></pre><p id="e46b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe me mf mg mh b">size</code> —随机数输出数组的形状(在这种情况下与<code class="fe me mf mg mh b">y_dummy</code>的大小相同)</p><p id="1c9c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，让我们绘制我们的虚拟数据集，以检查它看起来像什么。因为我们有一个噪声数据点的集合，我们将做一个散点图，我们可以很容易地使用<code class="fe me mf mg mh b">ax.scatter</code>函数。我将跳过许多情节美学上的修改，这些在我的<a class="ae lh" rel="noopener" target="_blank" href="/an-introduction-to-making-scientific-publication-plots-with-python-ea19dfa7f51e">上一篇文章</a>中详细讨论过。为了指定点的颜色，我直接使用了十六进制代码。</p><pre class="ks kt ku kv gt mi mh mj mk aw ml bi"><span id="610b" class="mm mn it mh b gy mo mp l mq mr"># Plot the noisy exponential data<br/>ax.scatter(x_dummy, y_dummy, s=20, color='#00b3b3', label='Data')</span></pre><p id="4c19" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe me mf mg mh b">s</code> —以(点)为单位的标记大小，因此当该值增加四倍时，标记大小加倍</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/ed0d302f1c41b56ed855a8390934142b.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*bWp8XO7ZYNLC1fTALHtE4Q.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">添加高斯噪声的虚拟指数数据散点图</p></figure><p id="248a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一种通常更有用的可视化指数数据的方法是使用半对数图，因为它将数据线性化。为了将<em class="ms"> y </em>轴的刻度从线性设置为对数，我们添加以下行:</p><pre class="ks kt ku kv gt mi mh mj mk aw ml bi"><span id="cda5" class="mm mn it mh b gy mo mp l mq mr"># Set the y-axis scaling to logarithmic<br/>ax.set_yscale('log')</span></pre><p id="2927" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">由于对数函数中的渐近线，我们现在还必须将 y 轴下限设置为大于零。此外，对于刻度线，我们现在将使用<code class="fe me mf mg mh b">LogLocator</code>功能:</p><pre class="ks kt ku kv gt mi mh mj mk aw ml bi"><span id="75ca" class="mm mn it mh b gy mo mp l mq mr"># Set the y-ticks<br/>ax.yaxis.set_major_locator(mpl.ticker.LogLocator(base=10.0))</span><span id="d600" class="mm mn it mh b gy nr mp l mq mr"># Set the y-axis limits<br/>ax.set_ylim(0.1, 1000)</span></pre><p id="1e6c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe me mf mg mh b">base</code> —用于对数轴主刻度的基数</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/a31e2315f4eb9d51a0318b2be135f3f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/format:webp/1*QlqrJjnohj0633b8jomLUg.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">带有对数 y 轴的虚拟指数数据散点图</p></figure><p id="747c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们现在可以将我们的数据拟合到一般的指数函数中，以提取参数<em class="ms"> a </em>和<em class="ms"> b </em>，并将拟合叠加到数据上。请注意，尽管我们在上面给出了半对数图，但我们实际上并没有<em class="ms">改变</em>y 数据——我们只是改变了<em class="ms"> y </em>轴的<em class="ms">刻度</em>。因此，我们仍然在拟合非线性数据，这通常更好，因为在拟合之前对数据进行线性化会改变拟合的残差和方差。</p><pre class="ks kt ku kv gt mi mh mj mk aw ml bi"><span id="3361" class="mm mn it mh b gy mo mp l mq mr"># Fit the dummy exponential data</span><span id="e1f0" class="mm mn it mh b gy nr mp l mq mr">pars, cov = curve_fit(f=exponential, xdata=x_dummy, ydata=y_dummy, p0=[0, 0], bounds=(-np.inf, np.inf))</span></pre><p id="7515" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">输入</strong></p><p id="406d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe me mf mg mh b">f</code> —用于装配的功能(在本例中为<code class="fe me mf mg mh b">exponential</code>)</p><p id="ec2a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe me mf mg mh b">xdata</code> —拟合的 x 数据数组</p><p id="45d7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe me mf mg mh b">ydata</code> —拟合的 y 数据数组</p><p id="83f9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe me mf mg mh b">p0</code> —拟合参数的初始猜测值数组(a<em class="ms">a</em>和 b<em class="ms">b</em>均为 0)</p><p id="38ef" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe me mf mg mh b">bounds</code> —参数的界限(-∞到∞)</p><p id="f9cc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">输出</strong></p><p id="ccd3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe me mf mg mh b">pars</code> —来自 fit 的参数数组(在本例中为<code class="fe me mf mg mh b">[a, b]</code>)</p><p id="91f9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe me mf mg mh b">cov</code>—<code class="fe me mf mg mh b">pars</code>的估计协方差，可用于确定拟合参数的标准偏差(对角线的平方根)</p><p id="b3a3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以从<code class="fe me mf mg mh b">curve_fit</code>输出中提取参数及其标准偏差，并通过从实际观察值(我们的虚拟数据)中减去计算值(从我们的拟合中)来计算残差</p><pre class="ks kt ku kv gt mi mh mj mk aw ml bi"><span id="90d2" class="mm mn it mh b gy mo mp l mq mr"># Get the standard deviations of the parameters (square roots of the # diagonal of the covariance)<br/>stdevs = np.sqrt(np.diag(cov))</span><span id="17aa" class="mm mn it mh b gy nr mp l mq mr"># Calculate the residuals<br/>res = y_dummy - exponential(x_dummy, *pars)</span></pre><p id="20a0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe me mf mg mh b">*pars</code> —允许我们展开<code class="fe me mf mg mh b">pars</code>数组，<em class="ms">即</em> <code class="fe me mf mg mh b">[a, b]</code>作为<code class="fe me mf mg mh b">a, b</code>输入</p><p id="8fcf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">拟合参数和标准偏差</strong></p><p id="7c65" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">a =0.509 0.017</p><p id="78d5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="ms"> b = </em> 0.499 0.002</p><p id="8fd1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们看到两个拟合参数都非常接近我们的输入值<code class="fe me mf mg mh b">a = 0.5</code>和<code class="fe me mf mg mh b">b = 0.5</code>，因此<code class="fe me mf mg mh b">curve_fit</code>函数收敛到正确的值。现在，我们可以将拟合叠加到散点数据上，还可以绘制残差，残差应该是随机分布的，并且接近于 0，从而确认我们有很好的拟合。</p><pre class="ks kt ku kv gt mi mh mj mk aw ml bi"><span id="ded7" class="mm mn it mh b gy mo mp l mq mr"># Plot the fit data as an overlay on the scatter data<br/>ax.plot(x_dummy, exponential(x_dummy, *pars), linestyle='--', linewidth=2, color='black')</span></pre><p id="1132" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe me mf mg mh b">linestyle</code> —绘制线的线型(<code class="fe me mf mg mh b">--</code>表示虚线)</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/df72a7c02abc5b4897db55972c4c0e23.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/format:webp/1*AX2c7lUfnMqW0Ziy-uWmfA.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">拟合线重叠的虚拟指数数据散点图</p></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/b0a81f2633290a1e98cd3e3b00853cf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:818/format:webp/1*AH3l2mUMQi7XeO9FE8eo4w.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">指数拟合的残差图</p></figure><h1 id="deaf" class="mt mn it bd mu mv mw mx my mz na nb nc ki nd kj ne kl nf km ng ko nh kp ni nj bi translated"><strong class="ak">幂律拟合</strong></h1><p id="ee17" class="pw-post-body-paragraph li lj it lk b ll nk kd ln lo nl kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">另一种常用的拟合函数是幂律，其一般公式可以是:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nu"><img src="../Images/4721a294101908b8f8d32b6c830c2823.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qKdKI_CoZt8ABRvmMnTyWw.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">一般幂律函数</p></figure><p id="e860" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">与之前的拟合类似，我们首先定义函数:</p><pre class="ks kt ku kv gt mi mh mj mk aw ml bi"><span id="db80" class="mm mn it mh b gy mo mp l mq mr"># Function to calculate the power-law with constants a and b<br/>def power_law(x, a, b):<br/>    return a*np.power(x, b)</span></pre><p id="af53" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然后，我们可以再次创建一个虚拟数据集，添加噪声，并绘制我们的幂律函数。</p><pre class="ks kt ku kv gt mi mh mj mk aw ml bi"><span id="82f8" class="mm mn it mh b gy mo mp l mq mr"># Generate dummy dataset<br/>x_dummy = np.linspace(start=1, stop=1000, num=100)<br/>y_dummy = power_law(x_dummy, 1, 0.5)</span><span id="8df0" class="mm mn it mh b gy nr mp l mq mr"># Add noise from a Gaussian distribution<br/>noise = 1.5*np.random.normal(size=y_dummy.size)<br/>y_dummy = y_dummy + noise</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/20b4530c5dac7cdce11c3ba7e57a9491.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*m2tehyZ8SsX00P3mUGYLBw.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">添加了高斯噪声的虚拟幂律数据的散点图</p></figure><p id="486e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">与指数拟合情况类似，幂律函数形式的数据可以通过绘制对数图来线性化，这一次，<em class="ms"> x </em>和<em class="ms"> y </em>轴都被缩放。</p><pre class="ks kt ku kv gt mi mh mj mk aw ml bi"><span id="f7e0" class="mm mn it mh b gy mo mp l mq mr"># Set the x and y-axis scaling to logarithmic<br/>ax.set_xscale('log')<br/>ax.set_yscale('log')</span><span id="2378" class="mm mn it mh b gy nr mp l mq mr"># Edit the major and minor tick locations of x and y axes<br/>ax.xaxis.set_major_locator(mpl.ticker.LogLocator(base=10.0))<br/>ax.yaxis.set_major_locator(mpl.ticker.LogLocator(base=10.0))</span><span id="0369" class="mm mn it mh b gy nr mp l mq mr"># Set the axis limits<br/>ax.set_xlim(10, 1000)<br/>ax.set_ylim(1, 100)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/c2257ae1024d5a2cfa45ac858d4a181a.png" data-original-src="https://miro.medium.com/v2/resize:fit:846/format:webp/1*DdL5xHP4QW2Y34QTKSIpXQ.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">对数轴虚拟幂律数据散点图</p></figure><p id="9197" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，我们可以遵循与指数数据相同的拟合步骤:</p><pre class="ks kt ku kv gt mi mh mj mk aw ml bi"><span id="9a4a" class="mm mn it mh b gy mo mp l mq mr"># Fit the dummy power-law data<br/>pars, cov = curve_fit(f=power_law, xdata=x_dummy, ydata=y_dummy, p0=[0, 0], bounds=(-np.inf, np.inf))</span><span id="0358" class="mm mn it mh b gy nr mp l mq mr"># Get the standard deviations of the parameters (square roots of the # diagonal of the covariance)<br/>stdevs = np.sqrt(np.diag(cov))</span><span id="39ac" class="mm mn it mh b gy nr mp l mq mr"># Calculate the residuals<br/>res = y_dummy - power_law(x_dummy, *pars)</span></pre><p id="2c23" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">拟合参数和标准偏差</strong></p><p id="573f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="ms"> a </em> = 1.057 0.096</p><p id="09f4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="ms"> b </em> = 0.492 0.014</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/5657bf256ce28192843fb67c31d91fdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:846/format:webp/1*3Tmq19fsljRDw2iIvgO67Q.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">具有重叠拟合线的虚拟幂律数据散点图</p></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/c014a89a1ae31efba18532c253be3bd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:874/format:webp/1*bBXT5CAbA8tlSD4pyQriqQ.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">幂律拟合的残差图</p></figure><h1 id="401c" class="mt mn it bd mu mv mw mx my mz na nb nc ki nd kj ne kl nf km ng ko nh kp ni nj bi translated"><strong class="ak">高斯峰值拟合</strong></h1><p id="e65c" class="pw-post-body-paragraph li lj it lk b ll nk kd ln lo nl kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">在诸如 X 射线衍射和光致发光的实验中，非常普遍地使用高斯函数、洛伦兹函数或两者组合的峰值拟合来确定线宽和其他属性。在这个例子中，我们将使用下面的通用公式来处理高斯峰值的拟合:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nx"><img src="../Images/e8865f8c989f698fdda92098f0b111d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YAOFMbQ7C8bTDKeJXVfw0g.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">一般高斯函数</p></figure><pre class="ks kt ku kv gt mi mh mj mk aw ml bi"><span id="527a" class="mm mn it mh b gy mo mp l mq mr"># Function to calculate the Gaussian with constants a, b, and c<br/>def gaussian(x, a, b, c):<br/>    return a*np.exp(-np.power(x - b, 2)/(2*np.power(c, 2)))</span><span id="dfa6" class="mm mn it mh b gy nr mp l mq mr"># Generate dummy dataset<br/>x_dummy = np.linspace(start=-10, stop=10, num=100)<br/>y_dummy = gaussian(x_dummy, 8, -1, 3)</span><span id="c56f" class="mm mn it mh b gy nr mp l mq mr"># Add noise from a Gaussian distribution<br/>noise = 0.5*np.random.normal(size=y_dummy.size)<br/>y_dummy = y_dummy + noise</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/c65feb2f6c42b1774e20a7eb907b4910.png" data-original-src="https://miro.medium.com/v2/resize:fit:784/format:webp/1*SMOlvvH99poTcuZvvd5whA.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">添加了噪声的虚拟高斯数据的散点图</p></figure><p id="af49" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">就像在指数和幂律拟合中一样，我们将尝试进行高斯拟合，每个参数的初始猜测值为 0。</p><pre class="ks kt ku kv gt mi mh mj mk aw ml bi"><span id="6997" class="mm mn it mh b gy mo mp l mq mr"># Fit the dummy Gaussian data<br/>pars, cov = curve_fit(f=gaussian, xdata=x_dummy, ydata=y_dummy, p0=[0, 0, 0], bounds=(-np.inf, np.inf))</span><span id="75af" class="mm mn it mh b gy nr mp l mq mr"># Get the standard deviations of the parameters (square roots of the # diagonal of the covariance)<br/>stdevs = np.sqrt(np.diag(cov))</span><span id="0a14" class="mm mn it mh b gy nr mp l mq mr"># Calculate the residuals<br/>res = y_dummy - power_law(x_dummy, *pars)</span></pre><p id="47af" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是，当我们这样做时，我们会得到以下结果:</p><pre class="ks kt ku kv gt mi mh mj mk aw ml bi"><span id="7bc6" class="mm mn it mh b gy mo mp l mq mr">print(pars)<br/>&gt;&gt;&gt; [0. 0. 0.]</span><span id="6747" class="mm mn it mh b gy nr mp l mq mr">print(stdevs)<br/>&gt;&gt;&gt; [inf inf inf]</span></pre><p id="c681" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">似乎我们的初始猜测不允许拟合参数收敛，所以我们可以用更真实的初始猜测再次运行拟合。您可以通过检查要拟合的峰值并选择合理的初始值来实现这一点。</p><pre class="ks kt ku kv gt mi mh mj mk aw ml bi"><span id="25ac" class="mm mn it mh b gy mo mp l mq mr"># Fit the dummy Gaussian data<br/>pars, cov = curve_fit(f=gaussian, xdata=x_dummy, ydata=y_dummy, p0=[5, -1, 1], bounds=(-np.inf, np.inf))</span></pre><p id="03f8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这一次，我们的拟合成功了，我们得到了以下拟合参数和残差:</p><p id="8128" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">拟合参数和标准偏差</strong></p><p id="7426" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="ms">一个</em> = 8.074 0.128</p><p id="51ab" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="ms">b</em>=–0.948 0.054</p><p id="f883" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="ms"> c </em> = 2.945 0.054</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/6a6f32b07b8a2f1446a3007cc83a566d.png" data-original-src="https://miro.medium.com/v2/resize:fit:784/format:webp/1*vN3Fuen7j4IJWNq3yuZzbQ.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">覆盖拟合的虚拟高斯数据散点图</p></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/5ce926b3c3e737e47f4ec1107870fc75.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/1*QdjIMWyzlv5L85r3ek2_QA.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">高斯拟合的残差图</p></figure><h1 id="fe74" class="mt mn it bd mu mv mw mx my mz na nb nc ki nd kj ne kl nf km ng ko nh kp ni nj bi translated"><strong class="ak">结论</strong></h1><p id="fea5" class="pw-post-body-paragraph li lj it lk b ll nk kd ln lo nl kg lq lr nm lt lu lv nn lx ly lz no mb mc md im bi translated">希望，在前面例子的引导下，你现在应该能够将你的实验数据拟合到任何非线性函数！我希望你喜欢这个教程，这里展示的所有例子都可以在这个<a class="ae lh" href="https://github.com/venkatesannaveen/python-science-tutorial" rel="noopener ugc nofollow" target="_blank"> Github 仓库</a>找到。</p></div></div>    
</body>
</html>