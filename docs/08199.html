<html>
<head>
<title>Modelling Regression Trees</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">建模回归树</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/modelling-regression-trees-b376e959d02e?source=collection_archive---------11-----------------------#2020-06-16">https://towardsdatascience.com/modelling-regression-trees-b376e959d02e?source=collection_archive---------11-----------------------#2020-06-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bf36" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何编写这个经典的机器学习算法(Python)</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9382c6265dbc0bca78dd4c76573d8159.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mYk0Ol8BEaIvj9Uk"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">🇨🇭·克劳迪奥·施瓦茨| @purzlbaum 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="2e88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">决策树可能是最流行的机器学习算法之一。在我的帖子<em class="lv"> " </em> <a class="ae ky" rel="noopener" target="_blank" href="/the-complete-guide-to-decision-trees-28a4e3c7be14"> <em class="lv">决策树完全指南</em> </a> <em class="lv"> s" </em>中，我详细描述了 DT:它们在现实生活中的应用，不同的 DT 类型和算法，以及它们的优缺点。我已经详细介绍了如何编写分类树，现在轮到回归树了。</p><p id="3822" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">回归树使用数字目标变量</strong>。与目标变量是定性的分类树不同，回归树用于预测连续输出变量。如果您想要预测诸如医疗成功的概率、金融股票的未来价格或给定人群的工资等事情，您可以使用此算法。让我们看一个用 Python 实现的例子。</p><h1 id="3b28" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">问题是</h1><p id="8c8c" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">波士顿住房数据集由美国波士顿不同地方的房价组成。除了价格之外，该数据集还提供了犯罪水平、城镇非零售商业区、房屋所有者的年龄以及其他属性等信息。</p><p id="d0ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">名为“MEDV”的变量表示房价，是目标变量。其余的变量是我们预测房子价值的预测因素。</p><h1 id="8542" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">台阶</h1><p id="643d" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">您可以通过处理更简单的子步骤来降低构建 DTs 的复杂性:DT 中的每个单独的子例程都将连接到其他子例程以增加复杂性，这种构造将让您获得更健壮的模型，更易于维护和改进。现在，让我们用 Python 构建一棵回归树(特殊类型的 DT)。</p><h2 id="a08a" class="mt lx it bd ly mu mv dn mc mw mx dp mg li my mz mi lm na nb mk lq nc nd mm ne bi translated">加载数据并描述数据集</h2><p id="13b7" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">加载数据文件是最简单的部分。问题(也是最耗时的部分)通常是指数据准备过程:设置正确的数据格式、处理缺失值和异常值、消除重复值等。</p><p id="d8b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在加载数据之前，我们将导入必要的库:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="0f70" class="mt lx it ng b gy nk nl l nm nn">import pandas as pd<br/>from pandas_datareader import data<br/>import numpy as np<br/>from sklearn.tree import DecisionTreeRegressor<br/>from sklearn.model_selection import train_test_split<br/>from sklearn import metrics<br/>from sklearn.metrics import r2_score</span></pre><p id="36d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们加载数据集并将其转换为熊猫数据帧:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="f369" class="mt lx it ng b gy nk nl l nm nn">boston = datasets.load_boston()<br/>df = pd.DataFrame(boston.data)</span></pre><p id="2282" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并将列命名为:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="8ea8" class="mt lx it ng b gy nk nl l nm nn">df.columns = boston.feature_names<br/>df[‘MEDV’] = boston.target</span></pre><p id="61dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先理解数据集并描述它:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="66a8" class="mt lx it ng b gy nk nl l nm nn">print(boston.DESCR)</span><span id="b055" class="mt lx it ng b gy no nl l nm nn">df.info()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/f06bd4f4003dded4dc9c250d4e6ec984.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PK9c9aKkJ8OZEXlrk8nuzw.png"/></div></div></figure><p id="c33c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不错:506 条记录，14 个数字变量，没有缺失值。我们不需要预处理数据，我们已经准备好建模。</p><h2 id="04c5" class="mt lx it bd ly mu mv dn mc mw mx dp mg li my mz mi lm na nb mk lq nc nd mm ne bi translated">选择特征和目标变量</h2><p id="4ddf" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">您需要将给定的列分成两种类型的变量:因变量(或目标变量)和自变量(或特征变量)。在我们的例子中，变量“MEDV”(自有住房的中值)是我们试图预测的。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="7ea8" class="mt lx it ng b gy nk nl l nm nn">X = df.iloc[:,0:13].copy()<br/>y = df.iloc[:,13].copy()</span></pre><h2 id="effc" class="mt lx it bd ly mu mv dn mc mw mx dp mg li my mz mi lm na nb mk lq nc nd mm ne bi translated">分割数据集</h2><p id="9932" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">要了解模型性能，将数据集分为定型集和测试集是一个好策略。通过将数据集分成两个独立的集合，我们可以使用一个集合进行训练，使用另一个集合进行测试。</p><ul class=""><li id="6e3c" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated"><strong class="lb iu">训练集:</strong>这些数据用来建立你的模型。例如使用 CART 算法来创建决策树。</li><li id="ff79" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><strong class="lb iu">测试集:</strong>该数据用于查看模型在看不见的数据上的表现，就像在现实世界中一样。在您想要测试您的模型以评估性能之前，这些数据应该是完全不可见的。</li></ul><p id="c8b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将数据集分成 70%训练和 30%测试。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="a2a7" class="mt lx it ng b gy nk nl l nm nn">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3)</span></pre><h2 id="b32c" class="mt lx it bd ly mu mv dn mc mw mx dp mg li my mz mi lm na nb mk lq nc nd mm ne bi translated">建立 DT 模型并微调</h2><p id="0c61" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">构建 DT 就像这样简单:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="2635" class="mt lx it ng b gy nk nl l nm nn">rt = DecisionTreeRegressor(criterion = ‘mse’, max_depth=5)</span></pre><p id="103e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，我们只定义了分裂标准(选择均方误差)和一个超参数(树的最大深度)。定义模型架构的参数被称为<strong class="lb iu">超参数</strong>，因此，搜索理想模型架构(最大化模型性能的架构)的过程被称为超参数调整<em class="lv">。</em> A <strong class="lb iu">超参数</strong>是在学习过程开始前就设定好值的参数，它们不能直接从数据中训练出来。</p><p id="1ae5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以通过调用模型来查看可以优化的其余超参数:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="e0dc" class="mt lx it ng b gy nk nl l nm nn">rt</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/b560ce2d4ae94907ca26548e04d4380d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6ObM7U8_jylScYN7qEy6uA.png"/></div></div></figure><p id="ee51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">模型可以有许多超参数，并且有不同的策略来寻找参数的最佳组合。你可以在<a class="ae ky" rel="noopener" target="_blank" href="/hyperparameter-tuning-explained-d0ebb2ba1d35">这个链接</a>上看看其中的一些。</p><h2 id="a023" class="mt lx it bd ly mu mv dn mc mw mx dp mg li my mz mi lm na nb mk lq nc nd mm ne bi translated">列车 DT 模型</h2><p id="3053" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">将模型拟合到训练数据代表了建模过程的训练部分。在模型定型后，可以使用预测方法调用来进行预测:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="4ed0" class="mt lx it ng b gy nk nl l nm nn">model_r = rt.fit(X_train, y_train)</span></pre><h2 id="2b51" class="mt lx it bd ly mu mv dn mc mw mx dp mg li my mz mi lm na nb mk lq nc nd mm ne bi translated">测试 DT 模型</h2><p id="67cb" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">测试数据集是独立于训练数据集的数据集。该测试数据集是您的模型的未知数据集，有助于您对其进行概化:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="30c5" class="mt lx it ng b gy nk nl l nm nn">y_pred = model_r.predict(X_test)</span></pre><h2 id="4e70" class="mt lx it bd ly mu mv dn mc mw mx dp mg li my mz mi lm na nb mk lq nc nd mm ne bi translated">设想</h2><p id="659d" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">DTs 最大的优势之一是它们的可解释性。可视化 DTs 不仅是理解模型的有效方法，也是传达模型工作原理的有效方法:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="1006" class="mt lx it ng b gy nk nl l nm nn">from sklearn import tree<br/>import graphviz<br/>dot_data = tree.export_graphviz(rt, feature_names=list(X), class_names=sorted(y.unique()), filled=True)<br/>graphviz.Source(dot_data)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/5bbeffc73696d17e5f78cf70be22d571.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m6Y4-ESWjAmZitfHLsIFjw.png"/></div></div></figure><p id="4a50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">变量“LSTAT”似乎对定义回归树的划分至关重要。我们将在计算要素重要性后检查这一点。</p><h2 id="c5f1" class="mt lx it bd ly mu mv dn mc mw mx dp mg li my mz mi lm na nb mk lq nc nd mm ne bi translated">评估绩效</h2><p id="3747" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">模型的质量与其预测值与实际值的匹配程度有关。评估你的机器学习算法是任何项目必不可少的一部分:你如何衡量它的成功，你什么时候知道它不应该再改进了？不同的机器学习算法有不同的评估指标，所以让我们提到一些回归问题的主要评估指标:</p><blockquote class="og oh oi"><p id="20d4" class="kz la lv lb b lc ld ju le lf lg jx lh oj lj lk ll ok ln lo lp ol lr ls lt lu im bi translated"><strong class="lb iu">平均绝对误差(MAE) </strong></p></blockquote><p id="9487" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是测试集中所有实例的单个预测误差绝对值的平均值<strong class="lb iu">。它告诉我们平均预期误差有多大。</strong></p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="f466" class="mt lx it ng b gy nk nl l nm nn">print(‘Mean Absolute Error:’, metrics.mean_absolute_error(y_test, y_pred))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/ff1c0317421098f72b3917b26afe624e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RPTXiaVTVnKa1qjxiMookA.png"/></div></div></figure><blockquote class="og oh oi"><p id="10fa" class="kz la lv lb b lc ld ju le lf lg jx lh oj lj lk ll ok ln lo lp ol lr ls lt lu im bi translated"><strong class="lb iu">均方误差</strong></p></blockquote><p id="751b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是测试集中所有实例的预测误差平方的平均值。因为 MSE 是平方的，所以它的单位与原始输出的单位不匹配，而且因为我们正在平方差值，所以 MSE 几乎总是大于 MAE:因此我们不能直接比较 MAE 和 MSE。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="16d1" class="mt lx it ng b gy nk nl l nm nn">print(‘Mean Squared Error:’, metrics.mean_squared_error(y_test, y_pred))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/83e04c746a733cc484853749da9cc0d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z0ePAWB9IsHL6hqGpHW2eg.png"/></div></div></figure><p id="c53b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">MSE 方程中平方项的影响在我们的数据中存在异常值时最为明显:虽然 MAE 中的每个残差按比例<strong class="lb iu">贡献给总误差</strong>，但 MSE 中的误差以二次方的方式<strong class="lb iu">增长。这最终意味着，我们数据中的异常值将导致 MSE 中比 MAE 中更高的总误差，并且该模型将因做出与相应实际值相差很大的预测而受到更多惩罚。</strong></p><blockquote class="og oh oi"><p id="3d3f" class="kz la lv lb b lc ld ju le lf lg jx lh oj lj lk ll ok ln lo lp ol lr ls lt lu im bi translated"><strong class="lb iu">均方根误差(RMSE) </strong></p></blockquote><p id="097e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是所有误差的平方的平均值的平方根。通过在计算平均值之前对误差求平方，然后取平均值的平方根，我们得到了一个误差大小的度量，该度量对较大但不常见的误差给予了比平均值更大的权重。我们还可以比较 RMSE 和梅，以确定预测是否包含大量但不常见的误差:RMSE 和梅之间的差异越大，误差大小越不一致。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="b814" class="mt lx it ng b gy nk nl l nm nn">print(‘Root Mean Squared Error:’, np.sqrt(metrics.mean_squared_error(y_test, y_pred)))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/edbc42c4aa3debbe61d2a0aa70302c07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FiWXVTvmGb49_tKB17nTIQ.png"/></div></div></figure><blockquote class="og oh oi"><p id="bce5" class="kz la lv lb b lc ld ju le lf lg jx lh oj lj lk ll ok ln lo lp ol lr ls lt lu im bi translated"><strong class="lb iu"> R 平方得分(R2) </strong></p></blockquote><p id="256e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用百分比解释由于特征变量的变化而引起的响应变量的变化量。<strong class="lb iu"> R 的平方</strong>可以取 0 到 1 之间的任何值，尽管它提供了一些关于回归模型的有用见解，但是您不应该只依赖这个度量来评估您的模型。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="b375" class="mt lx it ng b gy nk nl l nm nn">print(‘R Squared Score is:’, r2_score(y_test, y_pred))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/f53a52b04b7cf97efe871f21424405d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*maDfu-sXHgdtAND9HmLN4Q.png"/></div></div></figure><p id="ccd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对 R 平方最常见的解释是回归模型与观察数据的拟合程度。就像我们的例子一样，R 的平方为 0.74 表明 74%的数据符合回归模型。虽然较高的 R 平方表示模型更适合，但高度量值并不总是适合回归模型:统计度量值的质量取决于许多因素，例如模型中使用的变量的性质、变量的度量单位以及应用的数据转换。</p><blockquote class="og oh oi"><p id="3248" class="kz la lv lb b lc ld ju le lf lg jx lh oj lj lk ll ok ln lo lp ol lr ls lt lu im bi translated"><strong class="lb iu"> <em class="it">特征重要性</em> </strong></p></blockquote><p id="4b01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个关键指标包括为预测模型的输入特征分配分数，表明每个特征在进行预测时的相对重要性。<strong class="lb iu">特征重要性</strong>提供对数据、模型的洞察，并代表降维和特征选择的基础，这可以提高预测模型的性能。越多的属性用于 DT 的关键决策，其相对重要性就越高。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="de1d" class="mt lx it ng b gy nk nl l nm nn">for importance, name in sorted(zip(rt.feature_importances_, X_train.columns),reverse=True):<br/> print (name, importance)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/3266ae6eb001afa26be50d5739169c92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PW5qeVt2ChIF40UyImXhIw.png"/></div></div></figure><p id="1126" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如可视化中突出显示的，变量“LSTAT”相对于其他变量具有更高的重要性(是模型的主要特征)。让我们在图上看一下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/bd07fe5ea44b8ad382dd8a17cda0a514.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RMUVgrMfknWKMG8NXAs48A.png"/></div></div></figure><p id="89d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">特征“LSTAT”和“RM”占进行预测的重要性的 80%以上。</p><p id="7791" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们只能将我们模型的误差指标与<strong class="lb iu">竞争</strong>模型的误差指标进行比较(例如，2 个不同模型的 R 平方得分)，尽管这些指标提供了关于模型性能的宝贵见解，但请始终记住:</p><blockquote class="os"><p id="a8c0" class="ot ou it bd ov ow ox oy oz pa pb lu dk translated">仅仅因为一个预测在过去是准确的，并不意味着它在未来也是准确的。</p></blockquote><h1 id="22b2" class="lw lx it bd ly lz ma mb mc md me mf mg jz pc ka mi kc pd kd mk kf pe kg mm mn bi translated">最后的想法</h1><p id="7e74" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我们在建模过程中已经涵盖了几个步骤，其中每一个都是独立的学科:探索性数据分析、特征工程或超参数调整都是任何机器学习模型的广泛而复杂的方面。你应该考虑更深入地研究那些学科。</p><p id="cc9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与其他算法相比，决策树的一个重要方面是它划分数据空间的方式。如果您选择用<strong class="lb iu">线性回归</strong>来求解波士顿房价预测，您会看到如下图表:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pf"><img src="../Images/e27aba73603bfff5994fff1aed6b4acb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a50R28RqsAw1iBzc5q1wTw.png"/></div></div></figure><p id="6949" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">线性回归将搜索目标与其预测值之间的线性关系。在这个例子中，两个变量(“MEDV”和“RM”)似乎是线性相关的，这就是为什么这种方法可能工作得相对较好，但现实往往显示非线性关系。让我们看看回归树如何映射目标和预测值之间的相同关系:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/fa5e38fd367506d9d3f50ccaec13aada.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h01EUNreYnPvGl5sghZwDQ.png"/></div></div></figure><p id="2a42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在此示例中，使用 MSE 作为分区标准且 max_depth 为 5 的回归树以完全不同的方式划分数据空间，从而确定线性回归无法拟合的关系。</p><p id="db42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">决策树划分数据空间以优化给定标准的方式不仅取决于标准本身(例如 MSE 或 MAE 作为划分标准)，还取决于所有超参数的设置。超参数优化定义了决策树的工作方式，并最终决定了它的性能。一些超参数会严重影响模型的性能，找到它们的正确级别对于达到最佳性能至关重要。在下面的示例中，您可以看到超参数 max_depth 在设置为 0 到 10 之间时如何对回归树的 R 平方得分产生巨大影响，但在 10 以上，您选择的任何级别都不会对其产生影响:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ph"><img src="../Images/aeb30e0b75f30b052aa56234e276bd3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g4PT8Oyx54n0AqOchmoOWg.png"/></div></div></figure><p id="748b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了克服你试图为你的 DT 找到“完美的”超参数水平而使你的模型过度拟合的事实，你应该考虑探索集合方法。<strong class="lb iu">集成方法</strong>将几个 DTs 结合起来，产生比单个 DTs 更好的预测性能。<strong class="lb iu">系综</strong>模型背后的主要原理是一群弱学习者聚集在一起形成强学习者，显著提高单个 DT 的性能。它们用于减少模型的方差和偏差，并改进预测。既然你已经看到了决策树是如何工作的，我建议你继续使用集合方法，比如<a class="ae ky" rel="noopener" target="_blank" href="/ensemble-methods-bagging-boosting-and-stacking-c9214a10a205">打包或推进</a>。</p></div><div class="ab cl pi pj hx pk" role="separator"><span class="pl bw bk pm pn po"/><span class="pl bw bk pm pn po"/><span class="pl bw bk pm pn"/></div><div class="im in io ip iq"><blockquote class="og oh oi"><p id="cd5d" class="kz la lv lb b lc ld ju le lf lg jx lh oj lj lk ll ok ln lo lp ol lr ls lt lu im bi translated"><em class="it">对这些话题感兴趣？在</em><a class="ae ky" href="https://www.linkedin.com/in/lopezyse/" rel="noopener ugc nofollow" target="_blank"><em class="it">Linkedin</em></a><em class="it">或</em> <a class="ae ky" href="https://twitter.com/lopezyse" rel="noopener ugc nofollow" target="_blank"> <em class="it"> Twitter </em> </a>上关注我</p></blockquote></div></div>    
</body>
</html>