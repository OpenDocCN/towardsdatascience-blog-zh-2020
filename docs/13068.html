<html>
<head>
<title>Build a Subway Journey Planner Using Neo4j</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Neo4j 构建地铁旅程规划器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/build-a-subway-journey-planner-using-neo4j-566b1a53670a?source=collection_archive---------22-----------------------#2020-09-08">https://towardsdatascience.com/build-a-subway-journey-planner-using-neo4j-566b1a53670a?source=collection_archive---------22-----------------------#2020-09-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="409d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用流行的图形数据库计算出两个地铁站之间的最佳行驶路径</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3cb2b21421beaa2b45b991ea13021412.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wvXGj68-2HiYELTxdqo1fg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@lucabravo?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">卢卡·布拉沃</a>在<a class="ae ky" href="https://unsplash.com/s/photos/subway?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="2221" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我之前的教程中，我已经介绍了如何使用 Neo4j 构建一个餐馆推荐引擎。在本教程中，我们将进一步探索用户定义的过程和函数。这样的实现通常用 Java 实现，可以通过 Cypher 直接调用。这为您提供了一种方便的方法，可以创建您喜欢的任何图形算法的自定义实现，并在 Neo4j 中查询数据集时使用它。</p><p id="df16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从版本 4.1.1 开始，Neo4j 自带<a class="ae ky" href="https://github.com/neo4j-contrib/neo4j-apoc-procedures" rel="noopener ugc nofollow" target="_blank">APOC(Cypher 上的牛逼程序)库</a>。有两种版本可供选择:</p><ul class=""><li id="274f" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe me mf mg mh b">APOC Core</code> —没有外部依赖性或不需要配置的过程和功能</li><li id="3152" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">APOC Full</code>—包括<code class="fe me mf mg mh b">APOC Core</code>中的所有内容，以及额外的过程和函数。</li></ul><p id="8f70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，Neo4j 还为从事机器学习工作流的开发人员提供了自己的<a class="ae ky" href="https://neo4j.com/graph-data-science-library/" rel="noopener ugc nofollow" target="_blank"> GDSL(图形数据科学库)</a>。在撰写本文时，这个库中的一些算法仍处于 alpha 阶段。</p><p id="dd44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的示例项目将是关于地铁/地铁/大众捷运的旅程规划。在后台，它稍后将使用<code class="fe me mf mg mh b">APOC Core</code>提供的路径查找算法来查找从起点到终点的最短路径。</p><p id="eafd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们继续下一部分，开始安装必要的模块。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="e9fd" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">1.设置</h1><p id="efff" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">在继续之前，如果您是 Neo4j 的新手，强烈建议您阅读下面的指南<a class="ae ky" href="https://medium.com/better-programming/the-beginners-guide-to-the-neo4j-graph-platform-a39858ccdeaa" rel="noopener">Neo4j 图形平台初学者指南</a>。</p><h2 id="7ad9" class="nr mv it bd mw ns nt dn na nu nv dp ne li nw nx ng lm ny nz ni lq oa ob nk oc bi translated">APOC 核心</h2><p id="5af3" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">默认情况下，Neo4j 的安装附带了<code class="fe me mf mg mh b">APOC Core</code> jar 文件。您可以很容易地在以下目录中找到 jar 文件。<code class="fe me mf mg mh b">NEO4J_HOME</code>指您本地机器中 Neo4j 的主目录。</p><pre class="kj kk kl km gt od mh oe of aw og bi"><span id="4d3b" class="nr mv it mh b gy oh oi l oj ok">$NEO4J_HOME/labs</span></pre><p id="9676" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您需要做的就是将 jar 文件复制并粘贴到以下目录中</p><pre class="kj kk kl km gt od mh oe of aw og bi"><span id="4997" class="nr mv it mh b gy oh oi l oj ok">$NEO4J_HOME/plugins</span></pre><p id="05c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记住之后通过下面的命令重新启动 Neo4j 以使其生效。</p><pre class="kj kk kl km gt od mh oe of aw og bi"><span id="16c6" class="nr mv it mh b gy oh oi l oj ok">neo4j console</span></pre><p id="c74b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果要将其作为后台服务启动，请使用以下命令。</p><pre class="kj kk kl km gt od mh oe of aw og bi"><span id="36e6" class="nr mv it mh b gy oh oi l oj ok">neo4j start</span></pre><p id="4b73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以通过以下 URL 访问 Neo4j 浏览器</p><pre class="kj kk kl km gt od mh oe of aw og bi"><span id="dab5" class="nr mv it mh b gy oh oi l oj ok"><a class="ae ky" href="http://localhost:7474/browser/" rel="noopener ugc nofollow" target="_blank">http://localhost:7474/browser/</a></span></pre><h2 id="deee" class="nr mv it bd mw ns nt dn na nu nv dp ne li nw nx ng lm ny nz ni lq oa ob nk oc bi translated">Neo4j 驱动程序</h2><p id="5cc7" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">为了将您的 web 应用程序连接到 Neo4j 图形数据库，您需要根据您使用的编程语言安装以下驱动程序之一:</p><ul class=""><li id="43b0" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe me mf mg mh b">.NET</code>——。网络标准 2.0</li><li id="84ae" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">Java</code> —Java 8+(最新补丁发布)。</li><li id="da52" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">JavaScript</code> —所有<a class="ae ky" href="https://github.com/nodejs/LTS" rel="noopener ugc nofollow" target="_blank"> LTS 版本的节点。JS </a>，特别是 4.x 和 6.x 系列运行时。</li><li id="a5d1" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">Python</code> — CPython 3.5 及以上。</li><li id="a774" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">Go</code> —工作正在进行中。目前没有官方发布日期。</li></ul><p id="c716" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于本教程，我将在 FastAPI 中为我们的 web 应用程序使用 Python 驱动程序。您可以通过<a class="ae ky" href="https://neo4j.com/docs/driver-manual/current/get-started/#driver-get-started-installation" rel="noopener ugc nofollow" target="_blank">下面的链接</a>找到其余驱动程序的完整安装步骤。</p><p id="6aab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">强烈建议您在安装软件包之前创建一个虚拟环境。在终端中运行以下命令。</p><pre class="kj kk kl km gt od mh oe of aw og bi"><span id="41e8" class="nr mv it mh b gy oh oi l oj ok">pip install neo4j</span></pre><h2 id="4e45" class="nr mv it bd mw ns nt dn na nu nv dp ne li nw nx ng lm ny nz ni lq oa ob nk oc bi translated">FastAPI</h2><p id="48c0" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">我们的后端服务器将建立在 FastAPI 之上。如果你是 Flask 用户，请随意修改它，因为你可以随时<a class="ae ky" href="https://medium.com/better-programming/migrate-from-flask-to-fastapi-smoothly-cc4c6c255397" rel="noopener">将它从 Flask 迁移到 FastAPI </a>。通过 pip install 安装，如下所示:</p><pre class="kj kk kl km gt od mh oe of aw og bi"><span id="571f" class="nr mv it mh b gy oh oi l oj ok">pip install fastapi</span></pre><p id="8fb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，你还需要一台<code class="fe me mf mg mh b">ASGI</code>服务器。我将使用推荐的名为<code class="fe me mf mg mh b">Uvicorn</code>的<code class="fe me mf mg mh b">ASGI</code>服务器。在同一个终端中，运行以下命令进行安装</p><pre class="kj kk kl km gt od mh oe of aw og bi"><span id="8f6d" class="nr mv it mh b gy oh oi l oj ok">pip install uvicorn</span></pre><h2 id="acb6" class="nr mv it bd mw ns nt dn na nu nv dp ne li nw nx ng lm ny nz ni lq oa ob nk oc bi translated">资料组</h2><p id="fc33" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">我将使用下面的网络图作为我的用例的数据集。它基于新加坡<a class="ae ky" href="http://SMRT Corporation website" rel="noopener ugc nofollow" target="_blank">公共交通运营商之一</a>的实际网络图。</p><p id="dcbd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了简化我们的项目，我们的数据集将只包含上面地图的精简版本。因此，我将忽略其余的线路，只保留以下 5 条 MRT 线路。</p><ul class=""><li id="97d0" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">东西线(绿色)</li><li id="85b0" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">南北线(红色)</li><li id="d9f8" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">东北线(紫色)</li><li id="8b28" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">圆形线(圆形)</li><li id="5cf2" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">市区线(蓝色)</li></ul></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="b686" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">2.Neo4j 数据库</h1><p id="bfa4" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">在本节中，我们将执行图形查询语言(Cypher ),用于向 Neo4j 图形数据库插入数据以及从其中查询数据。您可以使用现有的或新的数据库。</p><p id="95d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们继续之前，让我们列出用例的所有节点和关系。我们将使用它来建模我们的领域，并在稍后创建 Cypher 查询。</p><h2 id="0620" class="nr mv it bd mw ns nt dn na nu nv dp ne li nw nx ng lm ny nz ni lq oa ob nk oc bi translated">假定</h2><p id="83a5" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">为了使事情简单而简短，我将为我们的用例做以下假设。</p><ul class=""><li id="faba" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">每站之间没有等待时间。在实际使用情况下，应该有乘客排队上车的等待时间。</li><li id="3778" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">当在换乘站之间改变线路时，没有行驶时间。在实际使用案例中，当改变线路时，你必须从一个平台走到另一个平台。</li><li id="62e9" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">从<code class="fe me mf mg mh b">Station A</code>到<code class="fe me mf mg mh b">Station B</code>花费的时间总是相同的，不管你是否在不同的线路上旅行。在实际使用案例中，从<code class="fe me mf mg mh b">Raffles Place</code>经<code class="fe me mf mg mh b">East-West Line</code>到<code class="fe me mf mg mh b">City Hall</code>所用的时间与经<code class="fe me mf mg mh b">North-South Line</code>所用的时间不同。</li><li id="f2e0" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">我们的旅程规划工具所使用的指标仅仅基于两个站点之间的总旅行时间。在实际使用案例中，您必须考虑影响旅行费用的进出站需求。</li></ul><p id="1edd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据您自己的用例随意修改和建模领域。</p><h2 id="30e2" class="nr mv it bd mw ns nt dn na nu nv dp ne li nw nx ng lm ny nz ni lq oa ob nk oc bi translated">站(节点)</h2><p id="93fe" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">每个站代表一个具有以下属性的<code class="fe me mf mg mh b">Node</code>:</p><ul class=""><li id="6a50" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe me mf mg mh b">name</code> —车站名称。所有的名字都是小写的。</li><li id="39ab" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">mrt</code> —代表车站所在的线路。我用的是简称。因此，<code class="fe me mf mg mh b">East-West Line</code>将是<code class="fe me mf mg mh b">ew</code>，而<code class="fe me mf mg mh b">Circle Line</code>将是<code class="fe me mf mg mh b">cc</code>。对于立体交叉，将改为标记为<code class="fe me mf mg mh b">x</code>。该属性将决定 React 应用程序中图标的颜色。</li></ul><h2 id="ff8d" class="nr mv it bd mw ns nt dn na nu nv dp ne li nw nx ng lm ny nz ni lq oa ob nk oc bi translated">旅行目的地(关系)</h2><p id="f4bf" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">两个<code class="fe me mf mg mh b">Station</code>之间的关系由具有以下属性的<code class="fe me mf mg mh b">TRAVEL_TO</code>表示:</p><ul class=""><li id="6be3" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe me mf mg mh b">time</code> —代表从一个站点到另一个站点所需的时间。它不包括从一条捷运线换乘到另一条捷运线的步行时间。车站间隔时间的数据集基于<a class="ae ky" href="https://www.transitlink.com.sg/eservice/eguide/rail_idx.php" rel="noopener ugc nofollow" target="_blank"> TransitLink </a>网站的输出结果。稍后，它将被用作路径查找算法的成本函数。</li></ul><h2 id="d9bb" class="nr mv it bd mw ns nt dn na nu nv dp ne li nw nx ng lm ny nz ni lq oa ob nk oc bi translated">清除数据库</h2><p id="0fdd" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">您可以运行以下密码来清理数据库。任何现有节点及其关系都将从数据库中完全删除。</p><pre class="kj kk kl km gt od mh oe of aw og bi"><span id="588e" class="nr mv it mh b gy oh oi l oj ok">MATCH (n) DETACH DELETE n</span></pre><h2 id="8edc" class="nr mv it bd mw ns nt dn na nu nv dp ne li nw nx ng lm ny nz ni lq oa ob nk oc bi translated">创建数据集</h2><p id="9453" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">您可以创建两个<code class="fe me mf mg mh b">Station</code>节点，并用如下关系将它们链接起来。我使用小写作为名称来标准化稍后 API 调用的输入参数。</p><pre class="kj kk kl km gt od mh oe of aw og bi"><span id="f297" class="nr mv it mh b gy oh oi l oj ok">CREATE (tuaslink:Station {name:"tuas link", mrt:"ew"})-[:TRAVEL_TO {time: 2}]-&gt;(tuaswestroad:Station {name:"tuas west road", mrt:"ew"})</span></pre><p id="f6f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它将创建两个带有<code class="fe me mf mg mh b">Station</code>标签的独立节点，并在它们之间建立<code class="fe me mf mg mh b">TRAVEL_TO</code>关系。现在，您应该注意到关系是单向创建的。这是默认行为，因为 Neo4j 只允许您在节点之间创建单向关系。但是，您可以指定在查询时忽略方向，以获得所需的双向结果。</p><p id="2ea8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随后，您可以通过声明的名称重用旧的<code class="fe me mf mg mh b">Station</code>节点，并将它链接到一个新的<code class="fe me mf mg mh b">Station</code>节点，如下所示。</p><pre class="kj kk kl km gt od mh oe of aw og bi"><span id="4931" class="nr mv it mh b gy oh oi l oj ok">(tuaswestroad)-[:TRAVEL_TO {time: 8}]-&gt;(tuascrescent:Station {name:"tuas crescent", mrt:"ew"})</span></pre><p id="2ef1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">链接节点时需要小心，因为如果从<code class="fe me mf mg mh b">Station A</code>到<code class="fe me mf mg mh b">Station B</code>存在两种不同的关系，会导致结果重复。例如，您可以通过<code class="fe me mf mg mh b">East-West Line</code>和<code class="fe me mf mg mh b">North-South Line</code>从<code class="fe me mf mg mh b">Raffles Place</code>连接到<code class="fe me mf mg mh b">City Hall</code>。一旦你为<code class="fe me mf mg mh b">East-West Line</code>声明了以下密码。</p><pre class="kj kk kl km gt od mh oe of aw og bi"><span id="0353" class="nr mv it mh b gy oh oi l oj ok">(rafflesplace:Station {name:"raffles place", mrt:"x"})-[:TRAVEL_TO {time: 2}]-&gt;(cityhall:Station {name:"city hall", mrt:"x"})</span></pre><p id="8656" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您不能为<code class="fe me mf mg mh b">North-South Line</code>再次声明它。</p><pre class="kj kk kl km gt od mh oe of aw og bi"><span id="64ad" class="nr mv it mh b gy oh oi l oj ok">(rafflesplace)-[:TRAVEL_TO {time: 2}]-&gt;(cityhall)</span></pre><p id="e17e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您打算将两个工作站建模为不同的实体，只需为同一个工作站创建两个不同的节点，并正确地链接它们。</p><p id="e177" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们将所有数据集合并到一个查询中。下面的<a class="ae ky" href="https://gist.github.com/wfng92/fb08e2aee22f7dd79150fc99bef50b7d" rel="noopener ugc nofollow" target="_blank">要点</a>包含该项目的完整密码查询。可以直接在 Neo4j 控制台运行。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="a13a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦执行了 Cypher 查询，您应该会看到下面的用户界面</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/ff00cabd7b49239a0228568114403563.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/format:webp/1*o9XrR3VvC292Tcb6QilPog.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h2 id="1ff8" class="nr mv it bd mw ns nt dn na nu nv dp ne li nw nx ng lm ny nz ni lq oa ob nk oc bi translated">获取全部</h2><p id="eb85" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">事实上，您可以运行以下查询来获取所有节点及其关系</p><pre class="kj kk kl km gt od mh oe of aw og bi"><span id="af5b" class="nr mv it mh b gy oh oi l oj ok">MATCH (n) RETURN (n)</span></pre><p id="122c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在您的 Neo4j 浏览器中，您应该会得到以下结果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/74dba87011785cc7d6822e27b797ac41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wenaHufNFjdecNoMYkSRgw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h2 id="18f7" class="nr mv it bd mw ns nt dn na nu nv dp ne li nw nx ng lm ny nz ni lq oa ob nk oc bi translated">Dijkstra(寻路算法)</h2><p id="6313" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated"><code class="fe me mf mg mh b">APOC Core</code>附带了一些有用的寻路算法，比如<code class="fe me mf mg mh b">dijkstra</code>和<code class="fe me mf mg mh b">astar</code>。在本教程中，我将使用<code class="fe me mf mg mh b">dijkstra</code>，因为我们只有一个成本函数。基于<a class="ae ky" href="https://neo4j.com/labs/apoc/4.1/overview/apoc.algo/apoc.algo.dijkstra/" rel="noopener ugc nofollow" target="_blank">官方文件</a>，它接受以下输入参数</p><ul class=""><li id="51c9" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe me mf mg mh b">startNode</code> —寻路算法的起始节点。</li><li id="d98b" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">endNode</code> —寻路算法的结束目的节点。</li><li id="55e8" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">relationshipTypesAndDirections</code> —字符串表示节点之间的关系。您也可以指定方向。</li><li id="14cf" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">weightPropertyName</code> —代表成本函数的属性名称的字符串。</li><li id="0e57" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">defaultWeight </code> —属性在节点中不存在时的默认权重。</li><li id="3c1e" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">numberOfWantedPaths</code> —要返回的路径数。默认值为 1。</li></ul><p id="0278" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并返回两个输出参数</p><ul class=""><li id="bf2d" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe me mf mg mh b">path</code> —寻路旅程的路径。</li><li id="3656" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">weight</code> —寻路旅程的总成本。</li></ul><p id="d36b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您只是从算法中寻找最佳路径，您可以忽略<code class="fe me mf mg mh b">defaultWeight</code>和<code class="fe me mf mg mh b">numberOfWantedPaths</code>参数。</p><h2 id="fe72" class="nr mv it bd mw ns nt dn na nu nv dp ne li nw nx ng lm ny nz ni lq oa ob nk oc bi translated">从 A 到 B 的最佳路径</h2><p id="c956" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">下面的例子说明了获得从<code class="fe me mf mg mh b">Jurong East</code>到<code class="fe me mf mg mh b">Dhoby Ghaut</code>的最佳路径的密码。</p><pre class="kj kk kl km gt od mh oe of aw og bi"><span id="1e56" class="nr mv it mh b gy oh oi l oj ok">MATCH (start:Station {name: 'jurong east'}), (end:Station {name: 'dhoby ghaut'})<br/>CALL apoc.algo.dijkstra(start, end, 'TRAVEL_TO', 'time') YIELD path, weight<br/>RETURN path, weight</span></pre><p id="a37d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您应该得到以下输出</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/57e772c2f685f738a003f3227cde1f59.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*1kkMnhKN0mk8kLpGDL6qWg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h2 id="9894" class="nr mv it bd mw ns nt dn na nu nv dp ne li nw nx ng lm ny nz ni lq oa ob nk oc bi translated">从 A 到 B 的前三条路径</h2><p id="8b85" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">假设您想从算法中获得前 3 条最佳路径。你应该使用下面的密码</p><pre class="kj kk kl km gt od mh oe of aw og bi"><span id="76b5" class="nr mv it mh b gy oh oi l oj ok">MATCH (start:Station {name: 'jurong east'}), (end:Station {name: 'dhoby ghaut'})<br/>CALL apoc.algo.dijkstra(start, end, 'TRAVEL_TO', 'time', 5, 3) YIELD path, weight<br/>RETURN path, weight</span></pre><p id="a8a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">执行后，Neo4j 浏览器将显示以下结果</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/0523859af6cb4db0d31d4aba20f8e0da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/format:webp/1*_uzcTq_v0Vsf0cFJcC9eRA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="522f" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">3.Python 驱动程序</h1><p id="dc63" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">在本节中，我们将创建一个简单的 FastAPI 后端，它通过 Python 驱动程序连接到 Neo4j 数据库。在您的工作目录中，创建一个新的 Python 文件。我打算把它叫做<code class="fe me mf mg mh b">journey.py</code>。</p><h2 id="be7a" class="nr mv it bd mw ns nt dn na nu nv dp ne li nw nx ng lm ny nz ni lq oa ob nk oc bi translated">导入</h2><p id="8e10" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">在 Python 文件的顶部添加以下导入声明。</p><pre class="kj kk kl km gt od mh oe of aw og bi"><span id="d6ae" class="nr mv it mh b gy oh oi l oj ok">from neo4j import GraphDatabase<br/>import logging<br/>from neo4j.exceptions import ServiceUnavailable</span></pre><h2 id="79a0" class="nr mv it bd mw ns nt dn na nu nv dp ne li nw nx ng lm ny nz ni lq oa ob nk oc bi translated">旅程等级</h2><p id="1718" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">接下来，创建一个新类，并在其中初始化以下函数</p><pre class="kj kk kl km gt od mh oe of aw og bi"><span id="350f" class="nr mv it mh b gy oh oi l oj ok">class Journey:<br/>    def __init__(self, uri, user, password):<br/>        self.driver = GraphDatabase.driver(uri, auth=(user, password))</span><span id="6278" class="nr mv it mh b gy or oi l oj ok">    def close(self):<br/>        self.driver.close()</span></pre><p id="0b52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该类负责以下功能:</p><ul class=""><li id="0331" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">返回数据库中所有电台的名称列表</li><li id="f27c" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">使用<code class="fe me mf mg mh b">dijkstra</code>寻路算法返回基于起点和终点的最佳路径</li></ul><h2 id="e8bd" class="nr mv it bd mw ns nt dn na nu nv dp ne li nw nx ng lm ny nz ni lq oa ob nk oc bi translated">获取电台名称</h2><p id="fde4" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">继续在<code class="fe me mf mg mh b">Journey</code>类中追加以下代码。第一个功能通过上下文管理器初始化会话。在函数内部，我们将调用<code class="fe me mf mg mh b">read_transaction()</code>方法并传入第二个函数，该函数将返回一个字典作为结果。</p><p id="501f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个函数主要负责通过<code class="fe me mf mg mh b">run()</code>函数执行查询字符串。我使用 dict comprehension 和<code class="fe me mf mg mh b">title()</code>函数将名字作为<code class="fe me mf mg mh b">Title</code> case 返回。基于官方文档，建议将该功能声明为<code class="fe me mf mg mh b">staticmethod</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><h2 id="6d1f" class="nr mv it bd mw ns nt dn na nu nv dp ne li nw nx ng lm ny nz ni lq oa ob nk oc bi translated">获取最佳路径</h2><p id="08ba" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">让我们再创建两个函数，使用<code class="fe me mf mg mh b">dijkstra</code>算法获得最佳路径。它接受以下参数:</p><ul class=""><li id="288b" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe me mf mg mh b">start_node</code> —旅程的起点</li><li id="e3f3" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">end_node</code> —旅程的终点</li><li id="178d" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">count</code> —返回的路径数</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="c5cb" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">4.FastAPI 服务器</h1><p id="987e" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">正如我前面提到的，我们的后端服务器基于 FastAPI。在与<code class="fe me mf mg mh b">journey.py</code>相同的目录下创建一个名为<code class="fe me mf mg mh b">myapp.py</code>的新 Python 文件。</p><h2 id="c293" class="nr mv it bd mw ns nt dn na nu nv dp ne li nw nx ng lm ny nz ni lq oa ob nk oc bi translated">导入</h2><p id="4caa" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">在文件的顶部，添加以下导入语句。</p><pre class="kj kk kl km gt od mh oe of aw og bi"><span id="6359" class="nr mv it mh b gy oh oi l oj ok">from fastapi import FastAPI<br/>import journey<br/>import atexit<br/>from fastapi.middleware.cors import CORSMiddleware</span></pre><p id="f144" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe me mf mg mh b">journey</code>是我们之前创建的模块的名称。如果这两个文件不在同一个目录中，请相应地修改它。</p><p id="a820" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当退出网络服务器时，我使用<code class="fe me mf mg mh b">atexit</code>来执行<code class="fe me mf mg mh b">close()</code>功能。要了解更多信息，请看下面关于如何为 Python 应用程序创建退出处理程序的教程。</p><p id="1f43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您从任何前端应用程序发出<code class="fe me mf mg mh b">AJAX</code>或<code class="fe me mf mg mh b">fetch</code>调用时，需要<code class="fe me mf mg mh b">CORSMiddleware</code>来防止问题。</p><h2 id="9b47" class="nr mv it bd mw ns nt dn na nu nv dp ne li nw nx ng lm ny nz ni lq oa ob nk oc bi translated">初始化</h2><p id="791f" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">初始化以下变量，这些变量是向 Neo4j 数据库进行身份验证的凭据。</p><pre class="kj kk kl km gt od mh oe of aw og bi"><span id="664c" class="nr mv it mh b gy oh oi l oj ok">uri = "neo4j://localhost:7687"<br/>user = "neo4j"<br/>password = "neo4j"</span><span id="acd0" class="nr mv it mh b gy or oi l oj ok">neo_db = journey.Journey(uri, user, password)</span></pre><h2 id="8c31" class="nr mv it bd mw ns nt dn na nu nv dp ne li nw nx ng lm ny nz ni lq oa ob nk oc bi translated">退出处理程序</h2><p id="23b8" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">然后，添加下面的代码来关闭与 Neo4j 数据库的连接。</p><pre class="kj kk kl km gt od mh oe of aw og bi"><span id="a351" class="nr mv it mh b gy oh oi l oj ok">def exit_application():<br/>    neo_db.close()</span><span id="80ea" class="nr mv it mh b gy or oi l oj ok">atexit.register(exit_application)</span></pre><h2 id="51b1" class="nr mv it bd mw ns nt dn na nu nv dp ne li nw nx ng lm ny nz ni lq oa ob nk oc bi translated">FastAPI</h2><p id="dc15" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">完成后，创建一个新的 FastAPI 实例。除此之外，让我们为<code class="fe me mf mg mh b">origins</code>指定一个变量，并在调用<code class="fe me mf mg mh b">add_middleware()</code>函数时将其作为输入参数传递。</p><pre class="kj kk kl km gt od mh oe of aw og bi"><span id="ef03" class="nr mv it mh b gy oh oi l oj ok">app = FastAPI()</span><span id="2046" class="nr mv it mh b gy or oi l oj ok">origins = [<br/>    "<a class="ae ky" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank">http://localhost:3000</a>"<br/>]</span><span id="ed08" class="nr mv it mh b gy or oi l oj ok">app.add_middleware(<br/>    CORSMiddleware,<br/>    allow_origins=origins,<br/>    allow_credentials=True,<br/>    allow_methods=["*"],<br/>    allow_headers=["*"],<br/>)</span></pre><p id="2b6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe me mf mg mh b">origins</code>由将调用您的 FastAPI 服务器的 URL 列表组成。假设您有一个在端口 3000 上本地运行 React 应用程序。您应该将以下 URL 添加到列表中</p><pre class="kj kk kl km gt od mh oe of aw og bi"><span id="0023" class="nr mv it mh b gy oh oi l oj ok"><a class="ae ky" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank">http://localhost:3000</a></span></pre><p id="be2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建一条新的<code class="fe me mf mg mh b">GET</code>路线，返回所有站点的名称。</p><pre class="kj kk kl km gt od mh oe of aw og bi"><span id="9ca9" class="nr mv it mh b gy oh oi l oj ok">@app.get('/get-station')<br/>async def get_station():<br/>    result = neo_db.find_all()</span><span id="57a1" class="nr mv it mh b gy or oi l oj ok">return result</span></pre><p id="19cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后，创建另一条<code class="fe me mf mg mh b">GET</code>路线以获得最佳路径。我们将把它与接受三个参数的<code class="fe me mf mg mh b">find_journey()</code>函数连接起来。每行包含一个字典对象，该对象包含<code class="fe me mf mg mh b">path</code>和<code class="fe me mf mg mh b">weight</code>参数。需要注意的一点是，<code class="fe me mf mg mh b">path</code>内部的节点是无序的，你可以通过<code class="fe me mf mg mh b">id</code>链接它们。第一个节点可以是起点，也可以是终点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><h2 id="81a3" class="nr mv it bd mw ns nt dn na nu nv dp ne li nw nx ng lm ny nz ni lq oa ob nk oc bi translated">运行 FastAPI</h2><p id="8d71" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">运行以下代码启动 FastAPI 服务器:</p><pre class="kj kk kl km gt od mh oe of aw og bi"><span id="b539" class="nr mv it mh b gy oh oi l oj ok">uvicorn myapp:app</span></pre><p id="69d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它应该在几秒钟后开始。让我们测试一下我们的 API，以获得从<code class="fe me mf mg mh b">Jurong East</code>到<code class="fe me mf mg mh b">Dhoby Ghaut</code>的最佳路径。在您的浏览器中浏览以下网址。</p><pre class="kj kk kl km gt od mh oe of aw og bi"><span id="ece2" class="nr mv it mh b gy oh oi l oj ok"><a class="ae ky" href="http://localhost:8000/get-journey?start=jurong%20east&amp;end=dhoby%20ghaut&amp;count=3" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/get-journey?start=jurong%20east&amp;end=dhoby%20ghaut&amp;count=3</a></span></pre><p id="2e1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您应该会得到以下结果。</p><pre class="kj kk kl km gt od mh oe of aw og bi"><span id="b186" class="nr mv it mh b gy oh oi l oj ok">[{"path":[{"name":"Jurong East","mrt":"x","time":"start here"},{"name":"Clementi","mrt":"ew","time":"4 minutes"},{"name":"Dover","mrt":"ew","time":"3 minutes"},{"name":"Bouna Vista","mrt":"ew","time":"3 minutes"},{"name":"Holland Village","mrt":"cc","time":"2 minutes"},{"name":"Farrer Road","mrt":"cc","time":"3 minutes"},{"name":"Botanic Gardens","mrt":"cc","time":"2 minutes"},{"name":"Stevens","mrt":"dt","time":"2 minutes"},{"name":"Newton","mrt":"dt","time":"3 minutes"},{"name":"Little India","mrt":"dt","time":"1 minutes"},{"name":"Dhoby Ghaut","mrt":"dt","time":"2 minutes"}],"weight":25.0},{"path":[{"name":"Jurong East","mrt":"x","time":"start here"},{"name":"Clementi","mrt":"ew","time":"4 minutes"},{"name":"Dover","mrt":"ew","time":"3 minutes"},{"name":"Bouna Vista","mrt":"ew","time":"3 minutes"},{"name":"Commonwealth","mrt":"ew","time":"2 minutes"},{"name":"Queenstown","mrt":"ew","time":"2 minutes"},{"name":"Red Hill","mrt":"ew","time":"3 minutes"},{"name":"Tiong Bahru","mrt":"ew","time":"2 minutes"},{"name":"Outram Park","mrt":"ew","time":"3 minutes"},{"name":"Chinatown","mrt":"ew","time":"2 minutes"},{"name":"Clarkequay","mrt":"ne","time":"2 minutes"},{"name":"Dhoby Ghaut","mrt":"ne","time":"2 minutes"}],"weight":28.0},{"path":[{"name":"Jurong East","mrt":"x","time":"start here"},{"name":"Clementi","mrt":"ew","time":"4 minutes"},{"name":"Dover","mrt":"ew","time":"3 minutes"},{"name":"Bouna Vista","mrt":"ew","time":"3 minutes"},{"name":"Holland Village","mrt":"cc","time":"2 minutes"},{"name":"Farrer Road","mrt":"cc","time":"3 minutes"},{"name":"Botanic Gardens","mrt":"cc","time":"2 minutes"},{"name":"Stevens","mrt":"dt","time":"2 minutes"},{"name":"Newton","mrt":"dt","time":"3 minutes"},{"name":"Orchard","mrt":"ns","time":"3 minutes"},{"name":"Somerset","mrt":"ns","time":"2 minutes"},{"name":"Dhoby Ghaut","mrt":"ns","time":"2 minutes"}],"weight":29.0}]</span></pre><p id="d2c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个推荐建议我们从<code class="fe me mf mg mh b">Jurong East</code>到<code class="fe me mf mg mh b">Bouna Vista</code>，然后一直坐<code class="fe me mf mg mh b">Circle Line</code>到<code class="fe me mf mg mh b">Botanic Gardens</code>。之后，沿着<code class="fe me mf mg mh b">Downtown Line</code>一直走到<code class="fe me mf mg mh b">Little India</code>，然后换乘<code class="fe me mf mg mh b">Dhoby Ghaut</code>。</p><p id="8b1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二条路径将我们从<code class="fe me mf mg mh b">Jurong East</code>引向<code class="fe me mf mg mh b">Outram Park</code>。然后，换乘<code class="fe me mf mg mh b">North East Line</code>，一直走到<code class="fe me mf mg mh b">Dhoby Ghaut</code>。</p><p id="17c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们的第三个建议指引我们在<code class="fe me mf mg mh b">Bouna Vista</code>换乘到达<code class="fe me mf mg mh b">Botanic Gardens</code>。之后，通过<code class="fe me mf mg mh b">Downtown Line</code>继续<code class="fe me mf mg mh b">Newton</code>。与第一趟不同，它建议我们从<code class="fe me mf mg mh b">Orchard</code>换乘<code class="fe me mf mg mh b">North South Line</code>前往<code class="fe me mf mg mh b">Dhoby Ghaut</code>。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="f3bb" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">5.从前端呼叫</h1><p id="97b1" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">你现在需要做的就是把它连接到任何一个前端应用。你可以根据自己的喜好使用任何框架或计算机语言。在本教程中，我将简单介绍如何将 React 与 FastAPI 服务器集成。为了避免过于冗长，我将不涉及用户界面。</p><h2 id="092c" class="nr mv it bd mw ns nt dn na nu nv dp ne li nw nx ng lm ny nz ni lq oa ob nk oc bi translated">例子</h2><p id="3eba" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">如果你正在寻找灵感，看看<a class="ae ky" href="http://journey.smrt.com.sg/" rel="noopener ugc nofollow" target="_blank">以下网站</a>提供的功能。以下示例显示了从<code class="fe me mf mg mh b">Jurong East</code>到<code class="fe me mf mg mh b">Dhoby Ghaut</code>的示例输出。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/3bcdc8044d31be05f4f28f0d673a9c39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kCnRLSd9zTy7Bw2A3nrRCA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者基于<a class="ae ky" href="http://journey.smrt.com.sg/" rel="noopener ugc nofollow" target="_blank"> SMRT 旅程规划</a>中提供的功能绘制。</p></figure><p id="5d0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，与我们的结果相比，它只提供了两种选择。第一个选项与我们的路径查找算法提出的第二个建议路径完全相同。</p><p id="b596" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以创建具有以下功能的 React 应用程序:</p><ul class=""><li id="af7e" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">将内容分成两部分的网格布局。左侧包含输入，而右侧将显示结果。</li><li id="1790" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">起点和终点的两个选择输入</li><li id="fecb" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">确认按钮</li><li id="365b" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">结果将显示为手风琴，连同总时间的旅程。每个旅程将包含站点名称以及每个站点之间的旅程时间。</li></ul><p id="aeb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最终的 React 应用程序可能看起来像这样。该用户界面基于 React 材质用户界面。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/592e1e5846993be4aca84ac46c114547.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wht7o8xqf1OkaW8_Ts0T1g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h2 id="158b" class="nr mv it bd mw ns nt dn na nu nv dp ne li nw nx ng lm ny nz ni lq oa ob nk oc bi translated">AJAX 调用</h2><p id="59d8" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">对于集成，您可以通过<code class="fe me mf mg mh b">AJAX</code>或<code class="fe me mf mg mh b">fetch</code>调用轻松实现。在本教程中，我将展示如何对 FastAPI 服务器进行<code class="fe me mf mg mh b">AJAX</code>调用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="f3bd" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">结论</h1><p id="8802" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">祝贺您完成本教程。</p><p id="2ee3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们回顾一下你今天所学的内容。我们首先简要介绍了 Cypher Library 上令人惊叹的程序。</p><p id="364d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后，我们继续安装必要的模块，从 Neo4j Python 驱动程序到 FastAPI。此外，我们为我们的旅程规划应用程序制作和建模了我们的域。</p><p id="24c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们完成了它，我们启动 Neo4j 作为控制台应用程序，并与 Cypher 一起玩。我们清理了数据库，创建了新记录，并尝试运行<code class="fe me mf mg mh b">djikstra</code>寻路算法来获得最佳路径。</p><p id="e909" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随后，我们构建了一个新的 Journey 类，作为通过 Python 驱动程序连接到 Neo4j 数据库的模块。我们还创建了一个 FastAPI 服务器，作为后端服务器。</p><p id="8ed9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们进一步探讨了如何通过 AJAX 调用将其与 React 应用程序集成。</p><p id="aaea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢你阅读这篇文章。希望在下一篇文章中再见到你！</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="621a" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">参考</h1><ol class=""><li id="b9f2" class="lv lw it lb b lc nm lf nn li ou lm ov lq ow lu ox mb mc md bi translated"><a class="ae ky" href="https://neo4j.com/" rel="noopener ugc nofollow" target="_blank"> Neo4j 网站</a></li><li id="253b" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ox mb mc md bi translated"><a class="ae ky" href="https://neo4j.com/docs/api/python-driver/4.1/" rel="noopener ugc nofollow" target="_blank"> Neo4j Python 驱动</a></li><li id="5a86" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ox mb mc md bi translated"><a class="ae ky" href="https://material-ui.com/" rel="noopener ugc nofollow" target="_blank">反应材质 UI </a></li></ol></div></div>    
</body>
</html>