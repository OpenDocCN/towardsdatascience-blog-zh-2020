<html>
<head>
<title>Type Casting In SQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SQL中的类型转换</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/type-casting-in-sql-2f92dc34a74b?source=collection_archive---------41-----------------------#2020-05-19">https://towardsdatascience.com/type-casting-in-sql-2f92dc34a74b?source=collection_archive---------41-----------------------#2020-05-19</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><figure class="it iu gq gs iv iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj is"><img src="../Images/e4a016c3d1f1a42ae15b9307e9e5ea9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f7YTTcLkypdiwkiUfVwUhg.jpeg"/></div></div><p class="jd je gk gi gj jf jg bd b be z dk translated">照片由<a class="ae jh" href="https://unsplash.com/@ultralinx?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Oliur </a>在<a class="ae jh" href="https://unsplash.com/s/photos/conversion?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h2 id="0f2f" class="ji jj jk bd b dl jl jm jn jo jp jq dk jr translated" aria-label="kicker paragraph">软件开发</h2><div class=""/><div class=""><h2 id="175e" class="pw-subtitle-paragraph kq jt jk bd b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dk translated">如何转换SQL中的数据类型及其对<a class="ae jh" href="https://linktr.ee/kovid" rel="noopener ugc nofollow" target="_blank">数据库&amp;查询性能</a>的影响</h2></div><p id="ba42" class="pw-post-body-paragraph li lj jk lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi me translated">从一种类型转换到另一种类型在SQL查询中非常常见。这种使用基本上源于糟糕的数据库设计、不断变化的需求、遗留的应用程序和懒惰的数据库维护。不是有意的，但是这些事情确保了数据消费者的需求永远不会被直接满足。消费者必须想出变通的解决方案来获取他们的数据。类型转换是主要的工具之一，尽管很少被提及。</p><p id="72af" class="pw-post-body-paragraph li lj jk lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">我们将使用下面的样本数据集来浏览在查询中进行转换的不同示例。</p><h1 id="41ef" class="mn mo jk bd mp mq mr ms mt mu mv mw mx kz my la mz lc na ld nb lf nc lg nd ne bi translated">资料组</h1><figure class="nf ng nh ni gu iw"><div class="bz fq l di"><div class="nj nk l"/></div></figure><p id="c442" class="pw-post-body-paragraph li lj jk lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">对于本文的范围，假设当我们谈论造型时，它包括所有SQL风格中所有与造型相关的函数，如Oracle中的<code class="fe nl nm nn no b">to_date</code>、MySQL中的<code class="fe nl nm nn no b">cast(something as int)</code>等等。然而，这些例子是基于MariaDB (MySQL)的。</p><h1 id="9187" class="mn mo jk bd mp mq mr ms mt mu mv mw mx kz my la mz lc na ld nb lf nc lg nd ne bi translated">隐式铸造</h1><p id="799d" class="pw-post-body-paragraph li lj jk lk b ll np ku ln lo nq kx lq lr nr lt lu lv ns lx ly lz nt mb mc md in bi translated">下例中的所有查询都会给出完全相同的输出——这意味着数据库引擎隐式地理解了我们给它的<code class="fe nl nm nn no b">where</code>子句输入。它根据自己的要求在<code class="fe nl nm nn no b">where</code>子句中把<code class="fe nl nm nn no b">'1'</code>内部转换为<code class="fe nl nm nn no b">1</code>，反之亦然。以下示例中的所有四个查询将产生相同的输出。</p><figure class="nf ng nh ni gu iw"><div class="bz fq l di"><div class="nj nk l"/></div></figure><p id="bcec" class="pw-post-body-paragraph li lj jk lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">这同样适用于从字符串到浮点数的转换，反之亦然。但是，并非所有数据库都在相同程度上支持隐式类型转换。对于本文的范围，我使用了MariaDB。</p><p id="6264" class="pw-post-body-paragraph li lj jk lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">当数据库能够隐式转换值时，我们可以假设它会对性能产生影响。隐式转换不是没有成本的，因为根据定义，它会为查询引擎增加更多的工作。事实上，隐式转换最终会比显式转换花费更多的成本，因为在显式转换中，您可以控制成本，而在隐式转换中，数据库处于控制之中，它决定采取什么行动，这反过来又会产生成本。</p><h1 id="0c5a" class="mn mo jk bd mp mq mr ms mt mu mv mw mx kz my la mz lc na ld nb lf nc lg nd ne bi translated">显式造型</h1><p id="cd6b" class="pw-post-body-paragraph li lj jk lk b ll np ku ln lo nq kx lq lr nr lt lu lv ns lx ly lz nt mb mc md in bi translated">这是人类指定铸造什么和铸造成什么的地方。因为字符串-整数、字符串-浮点转换由数据库引擎本身负责，所以当我们讨论日期时，转换的下一个最重要的用例就出现了。日期是数据库系统中最不同的存储信息。这里有很多变体，其中两个主要的是——时区和日期格式。大多数时候，日期不是以日期或时间戳的形式存储的，而是以字符串的形式存储的。这就是一切变得太有趣的地方。:)</p><p id="0e2e" class="pw-post-body-paragraph li lj jk lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">下面的示例显示了数据库引擎为将字符串转换为日期提供的许多选项。</p><figure class="nf ng nh ni gu iw"><div class="bz fq l di"><div class="nj nk l"/></div></figure><figure class="nf ng nh ni gu iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj nu"><img src="../Images/d3a12ff3f8dcb8de4a0e5a47b9730b1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*II-yY6HIg0IE8H_e36tQyA.png"/></div></div></figure><p id="acc3" class="pw-post-body-paragraph li lj jk lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">仔细查看数据库，当涉及到用字符串存储日期时，它是非常可靠和容易理解的。它可以解释几乎所有的日期格式，只有一个例外——<code class="fe nl nm nn no b">2019 12 12</code>——这是一个明显的数据库不能识别空间的例子。我猜也没人会这样写日期。但你无论如何也不能这么肯定。如果你的日期是这种格式，你可以做一个<code class="fe nl nm nn no b">replace(_date,' ','')</code>并把它转换成日期。</p><p id="31c6" class="pw-post-body-paragraph li lj jk lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">注意，数据库已经返回了结果集，但是有26个警告。让我们看看它们是什么。</p><figure class="nf ng nh ni gu iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj nv"><img src="../Images/7a31da6a7955e31180479843221bf328.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dzV_p0ccnVsVAz4yWJjauw.png"/></div></div></figure><p id="abbb" class="pw-post-body-paragraph li lj jk lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">警告不是错误。这里的警告是一个通知，表明数据库怀疑可能有问题。当您试图将一个副本<code class="fe nl nm nn no b">insert ignore</code>到一个表中时，也会发生类似的情况。如果你<code class="fe nl nm nn no b">insert</code>，它不会抛出警告，它会抛出错误。对于警告，数据库会假设您会在需要时查看这些警告。如果出现错误，除非您修复它们，否则无法继续。</p><p id="fd4f" class="pw-post-body-paragraph li lj jk lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">就像我们从字符串转换日期一样，许多其他的转换也是可能的，但是要小心。</p><h1 id="e621" class="mn mo jk bd mp mq mr ms mt mu mv mw mx kz my la mz lc na ld nb lf nc lg nd ne bi translated">对性能的影响</h1><p id="e3e0" class="pw-post-body-paragraph li lj jk lk b ll np ku ln lo nq kx lq lr nr lt lu lv ns lx ly lz nt mb mc md in bi translated">如前所述，添加到查询引擎的任何工作都会对性能产生一些影响。对于合理大小的数据集，隐式和显式转换(类型转换)可能<strong class="lk ju">而不是</strong>本身会大大降低查询速度。但是，您的查询很慢完全有可能是因为类型转换引起的其他问题。</p><p id="14d6" class="pw-post-body-paragraph li lj jk lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">类型转换(强制转换)会使查询的一个或多个索引变得无用。您可以使用<code class="fe nl nm nn no b">explain</code>或<code class="fe nl nm nn no b">explain extended</code>来检查查询计划中是否使用了索引。如果索引没有被使用，我们可以在<code class="fe nl nm nn no b">where</code>子句或<code class="fe nl nm nn no b">join</code>子句中显式类型转换列，等等。</p><p id="933c" class="pw-post-body-paragraph li lj jk lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">让我们看看这是如何影响索引的。</p><figure class="nf ng nh ni gu iw"><div class="bz fq l di"><div class="nj nk l"/></div></figure><p id="a00f" class="pw-post-body-paragraph li lj jk lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">运行下面的两个查询告诉我们，当我们在<code class="fe nl nm nn no b">where</code>子句中传递一个要与整数字段进行比较的字符串时，它会选择索引<code class="fe nl nm nn no b">idx_val_int</code>，但是在下一个查询中，当我们在<code class="fe nl nm nn no b">where</code>子句中传递一个要与字符串字段进行比较的整数时，它不会使用索引。它在可能的关键字中显示了索引的名称。</p><figure class="nf ng nh ni gu iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj nw"><img src="../Images/bd10671ce83ddecfd3e2a0aa4ed5a873.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TAaOKu3dIfq5HcOMX5rlGw.png"/></div></div></figure><p id="acf1" class="pw-post-body-paragraph li lj jk lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">还有关于为什么没有选择索引的附加信息。</p><figure class="nf ng nh ni gu iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj nx"><img src="../Images/692034f000519019c35fd0d4a6b0316a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dYc8T3R5YfPV59TUDr1RBQ.png"/></div></div></figure><p id="bc15" class="pw-post-body-paragraph li lj jk lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">连强行索引<code class="fe nl nm nn no b">idx_val_int_char</code>都不管用</p><figure class="nf ng nh ni gu iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj ny"><img src="../Images/aef726f0a3e252b151068af66bfdeac6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N_QMBfju-6xQlA9XtZiRMw.png"/></div></div></figure><p id="e797" class="pw-post-body-paragraph li lj jk lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">唯一的解决方法是以字符串的形式提供值，即<code class="fe nl nm nn no b">'1'</code>而不是<code class="fe nl nm nn no b">1</code>或<code class="fe nl nm nn no b">cast(1 as char)</code>，<code class="fe nl nm nn no b">1</code>是应用程序的输入，因此是可参数化的。</p><h1 id="5e07" class="mn mo jk bd mp mq mr ms mt mu mv mw mx kz my la mz lc na ld nb lf nc lg nd ne bi translated">结论</h1><p id="9ca8" class="pw-post-body-paragraph li lj jk lk b ll np ku ln lo nq kx lq lr nr lt lu lv ns lx ly lz nt mb mc md in bi translated">每个数据库都有许多将一种数据类型转换成另一种数据类型的选项，这些选项可以解决我们日常面临的大多数用例。尽管类型转换是一个很好的特性，但它确实伴随着<em class="nz">性能成本</em>，无论是隐式转换还是显式转换。</p><p id="47eb" class="pw-post-body-paragraph li lj jk lk b ll lm ku ln lo lp kx lq lr ls lt lu lv lw lx ly lz ma mb mc md in bi translated">虽然并不总是可行，但是避免这一切的一个很好的方法是以这样一种方式设计和维护数据库和查询，即需要最少的类型转换。如果这不可能，请确保您的查询使用了正确的索引，这样性能就不会受到更大的影响。还有更多关于字符集和排序的内容。我们将在另一个时间谈论那件事。</p></div></div>    
</body>
</html>