<html>
<head>
<title>Save The Date</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">保存日期</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/save-the-date-ad964b2397d0?source=collection_archive---------22-----------------------#2020-09-01">https://towardsdatascience.com/save-the-date-ad964b2397d0?source=collection_archive---------22-----------------------#2020-09-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8794" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何在 SQL 查询中生成缺失日期</h2></div><h2 id="d5d1" class="ki kj it bd kk kl km dn kn ko kp dp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">在本文中，我们将讨论:</h2><ol class=""><li id="5aa8" class="le lf it lg b lh li lj lk kr ll kv lm kz ln lo lp lq lr ls bi translated">如何使用 Presto SQL 生成一个包含日期范围的表</li><li id="9d35" class="le lf it lg b lh lt lj lu kr lv kv lw kz lx lo lp lq lr ls bi translated">连接应该从另一个表中补齐缺失数据的表的经验法则。</li></ol><p id="9e40" class="pw-post-body-paragraph ly lz it lg b lh ma ju mb lj mc jx md kr me mf mg kv mh mi mj kz mk ml mm lo im bi translated">在对数据进行计算之前，数据完整性是我们需要解决的最重要的事情之一。即使有正确的意图，我们有时也会忽略数据中的错误。当错误不在我们拥有的数据中，而是在我们没有的数据中时，这将变得非常困难。</p><p id="753c" class="pw-post-body-paragraph ly lz it lg b lh ma ju mb lj mc jx md kr me mf mg kv mh mi mj kz mk ml mm lo im bi translated">当执行考虑数据中样本数量的计算(计算平均值或中值)时，我们需要处理值为 NULL 或零的行。</p><p id="0629" class="pw-post-body-paragraph ly lz it lg b lh ma ju mb lj mc jx md kr me mf mg kv mh mi mj kz mk ml mm lo im bi translated">让我们假设我们经营一家网上商店，想要查看一个客户一个月内的平均日购买量。在客户没有购买的日期，我们的数据中不会有这种迹象。如果我们忽略这个问题，计算每个客户的平均购买量，我们会得到一个过高的估计。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="018c" class="ki kj it ms b gy mw mx l my mz">   customer_id    | order_date | purchase_amount |<br/>10000100005411274 | 2020-04-11 |        1        |<br/>10000100005411274 | 2020-04-16 |        1        |<br/>10000100005411274 | 2020-04-18 |        2        |<br/>10000100005411274 | 2020-04-21 |        2        |<br/>10000100005411274 | 2020-04-24 |        1        |</span></pre><p id="2bc8" class="pw-post-body-paragraph ly lz it lg b lh ma ju mb lj mc jx md kr me mf mg kv mh mi mj kz mk ml mm lo im bi translated"><em class="na">如果我们在不看我们的原始数据的情况下计算客户的日均购买量，我们会认为他的平均购买量是 1.4(真是个客户！).</em></p><p id="850a" class="pw-post-body-paragraph ly lz it lg b lh ma ju mb lj mc jx md kr me mf mg kv mh mi mj kz mk ml mm lo im bi translated">为了解决这个问题，我们必须为所有客户生成并匹配所有日期。通过 Presto SQL，我们可以在一个简单的查询中做到这一点:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="80bd" class="ki kj it ms b gy mw mx l my mz">SELECT<br/>     <em class="na">CAST</em>(date_column AS DATE) date_column<br/> FROM<br/>     (VALUES<br/>         (SEQUENCE(<em class="na">date</em>('2020-04-01'),<br/>                   <em class="na">date</em>('2020-04-30'),<br/>                   INTERVAL '1' DAY)<br/>         )<br/>     ) AS t1(date_array)<br/> CROSS JOIN<br/>     UNNEST(date_array) AS t2(date_column)</span></pre><p id="c65d" class="pw-post-body-paragraph ly lz it lg b lh ma ju mb lj mc jx md kr me mf mg kv mh mi mj kz mk ml mm lo im bi translated">使用 SEQUENCE，我们将创建一个日期在我们范围内的数组，并在数组中的每个元素与数组本身之间执行一个交叉连接。结果是每个不同日期对应一列。</p><p id="4e35" class="pw-post-body-paragraph ly lz it lg b lh ma ju mb lj mc jx md kr me mf mg kv mh mi mj kz mk ml mm lo im bi translated">一种快速的替代方法是从我们的初始数据中提取所有不同的日期，而不考虑客户，并将其存储为 WITH AS 语句。</p><p id="906b" class="pw-post-body-paragraph ly lz it lg b lh ma ju mb lj mc jx md kr me mf mg kv mh mi mj kz mk ml mm lo im bi translated">接下来，我们将执行另一个交叉连接，以匹配我们的客户和不同的日期，从而填充缺失的日期:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="eebf" class="ki kj it ms b gy mw mx l my mz">with all_dates as (<br/>SELECT<br/>     <em class="na">CAST</em>(date_column AS DATE) date_column<br/> FROM<br/>     (VALUES<br/>         (SEQUENCE(<em class="na">date</em>('2020-04-01'),<br/>                   <em class="na">date</em>('2020-04-30'),<br/>                   INTERVAL '1' DAY)<br/>         )<br/>     ) AS t1(date_array)<br/> CROSS JOIN<br/>     UNNEST(date_array) AS t2(date_column)<br/>)<br/>select distinct customer_id<br/>               ,date_column as order_date<br/>from customer_purchases<br/>cross join all_dates</span></pre><p id="a4a8" class="pw-post-body-paragraph ly lz it lg b lh ma ju mb lj mc jx md kr me mf mg kv mh mi mj kz mk ml mm lo im bi translated">最后，我们将把客户和日期之间的新匹配加入到包含我们数据的初始表中。</p><p id="1064" class="pw-post-body-paragraph ly lz it lg b lh ma ju mb lj mc jx md kr me mf mg kv mh mi mj kz mk ml mm lo im bi translated"><strong class="lg iu">*重要通知* </strong></p><p id="d090" class="pw-post-body-paragraph ly lz it lg b lh ma ju mb lj mc jx md kr me mf mg kv mh mi mj kz mk ml mm lo im bi translated"><strong class="lg iu">强</strong>表应该是我们用客户和日期创建的新表，而<em class="na">左</em>连接表应该是我们的初始数据。如果我们执行内部连接，我们将丢失所有没有购买的日期。此外，我们需要确保不要在 where 子句中放置处理左连接表中的列的条件，这将把左连接变成内连接。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="aab1" class="ki kj it ms b gy mw mx l my mz">with all_dates as (<br/>SELECT<br/>     <em class="na">CAST</em>(date_column AS DATE) date_column<br/> FROM<br/>     (VALUES<br/>         (SEQUENCE(<em class="na">date</em>('2020-04-01'),<br/>                   <em class="na">date</em>('2020-04-30'),<br/>                   INTERVAL '1' DAY)<br/>         )<br/>     ) AS t1(date_array)<br/> CROSS JOIN<br/>     UNNEST(date_array) AS t2(date_column)<br/>)</span><span id="b8a7" class="ki kj it ms b gy nb mx l my mz">,customers_dates as (<br/>select distinct customer_id<br/>               ,date_column as order_date<br/>from customer_purchases<br/>cross join all_dates</span><span id="ba15" class="ki kj it ms b gy nb mx l my mz">)<br/><br/>select u.customer_id<br/>     , u.order_date<br/>     , <em class="na">coalesce</em>(p.purchase_amount,0) purchase_amount<br/>from customers_dates u<br/>left join customer_purchases p<br/>on u.customer_id = p.customer_id<br/>and u.order_date = p.order_date<br/>order by customer_id asc</span><span id="a446" class="ki kj it ms b gy nb mx l my mz">--------------------------------------------------------------------</span><span id="a902" class="ki kj it ms b gy nb mx l my mz">   customer_id    | order_date | purchase_amount|<br/>................. | .......... | .............  |<br/>10000100005411274 | 2020-04-13 |       0        |<br/>10000100005411274 | 2020-04-14 |       0        |<br/>10000100005411274 | 2020-04-15 |       0        |<br/>10000100005411274 | 2020-04-16 |       1        |<br/>10000100005411274 | 2020-04-17 |       0        |<br/>10000100005411274 | 2020-04-18 |       2        |</span></pre><p id="e23e" class="pw-post-body-paragraph ly lz it lg b lh ma ju mb lj mc jx md kr me mf mg kv mh mi mj kz mk ml mm lo im bi translated"><em class="na">现在我们可以用正确的方法计算平均每日购买量。</em></p><h2 id="df23" class="ki kj it bd kk kl km dn kn ko kp dp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">总结(TL；博士):</h2><p id="3b45" class="pw-post-body-paragraph ly lz it lg b lh li ju mb lj lk jx md kr nc mf mg kv nd mi mj kz ne ml mm lo im bi translated">1.使用 SEQUENCE，我们可以创建一个包含一系列日期的数组，并将它们转换成表格。这种方法对于填充数据中缺失的日期非常有效，可以确保<em class="na">没有发生</em>的日期仍然会出现。</p><p id="1b59" class="pw-post-body-paragraph ly lz it lg b lh ma ju mb lj mc jx md kr me mf mg kv mh mi mj kz mk ml mm lo im bi translated">2.当在两个表之间执行左连接时，如果 where 子句中的条件寻址来自<em class="na">左</em>表的列，则将左连接转换为<strong class="lg iu">内连接</strong>。人们很容易忽略这一点，当在同一个查询中使用表间连接应用条件时，应该三思而行。</p></div></div>    
</body>
</html>