<html>
<head>
<title>Searching for the Best Forecasting Model: A Comparison of Different Univariate Forecasting Models</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">寻找最佳预测模型:不同单变量预测模型的比较</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/f-forecasting-5d23341462eb?source=collection_archive---------22-----------------------#2020-06-22">https://towardsdatascience.com/f-forecasting-5d23341462eb?source=collection_archive---------22-----------------------#2020-06-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2395" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用AR、MA、ARIMA和SARIMA进行单变量预测的最简单、最全面的指南。</h2></div></div><div class="ab cl kf kg hu kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="ij ik il im in"><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/62e09b14f6690f0d30d22f98987b6641.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iedphvSqGgK21sfC-iA_oQ.png"/></div></div></figure><p id="8b70" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">预测可能是一项艰巨的挑战，尤其是对那些只有很少或没有统计学背景的人来说。但我认为这比人们想象的要容易得多。在本文中，我将介绍基本的单变量预测模型，并相对轻松地预测一个变量。</p><h1 id="d25f" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">基本模型</h1><p id="e9f3" class="pw-post-body-paragraph ky kz iq la b lb mm jr ld le mn ju lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">单变量预测有两种基本模型。第一种是利用预测变量的过去值的自回归模型和使用白噪声误差项的过去值的移动平均模型。</p><p id="74cf" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><strong class="la ir">自回归模型</strong>看起来像这样</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/fc584920344c6a620344a931977f0a83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/format:webp/1*9Q4JI7SfkCotI9TCeq5O4Q.png"/></div><p class="ms mt gj gh gi mu mv bd b be z dk translated">自回归模型</p></figure><p id="c098" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">请注意，该模型仅使用预测变量(y)的过去(滞后)值。我们使用滞后的数量<em class="mw"> p </em>，<em class="mw"> p </em>通过一些测试来确定。</p><p id="2cc3" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><strong class="la ir">移动平均线模型</strong>看起来是这样的</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/3f4dcb05c1396157e5b49147b3e9abbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1106/format:webp/1*edSB5MwIZqTGf5taET3PYA.png"/></div><p class="ms mt gj gh gi mu mv bd b be z dk translated">移动平均模型</p></figure><p id="d387" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">像AR一样，MA使用过去的值，但它使用误差项，而不是预测变量。我们使用<em class="mw"> q </em>数量的滞后，<em class="mw"> q </em>由一些测试确定。</p><p id="5f1a" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们可以将自回归模型和移动平均模型结合在一个叫做ARMA的模型中。然而，通常情况下，我们的预测变量是非平稳的。这意味着该系列通常包含上升或下降趋势。为了减轻这一点，我们可以差分序列，以消除那些向上或向下的运动，使序列平稳。这样做，我们产生了ARIMA模型或自回归综合移动平均。一些时间序列变量可能具有季节性，如销售或收入，它们通常在假日期间激增。为了适应这种情况，我们有一个ARIMA的广义变体，称为SARIMA，它也包含了季节滞后。</p><p id="c5ed" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">ARIMA<strong class="la ir">模型看起来是这样的</strong></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi my"><img src="../Images/de785eaf31bab858c6c78798cdc5caa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:474/format:webp/1*PrF7lTeDq2f6nOargQCWHg.png"/></div><p class="ms mt gj gh gi mu mv bd b be z dk translated">滞后算子表示法中的ARIMA模型</p></figure><p id="3862" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在这个模型中，我们将系列<em class="mw">差d次</em>，直到它变得稳定<em class="mw">。</em>phi和theta分量分别代表AR和MA模型。</p><p id="f3f5" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">萨里玛模型看起来像这样</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/3fb165f0c0a3c6b2a3cdbf536618a232.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*5181u1BlSFFsnPUYQ00Osw.png"/></div><p class="ms mt gj gh gi mu mv bd b be z dk translated">滞后算子表示法中的SARIMA模型</p></figure><p id="abda" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这仅仅是ARIMA的一个概括，但是增加了季节差异、季节移动平均滞后和季节自回归滞后。</p><h1 id="586d" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">预赛</h1><p id="8bed" class="pw-post-body-paragraph ky kz iq la b lb mm jr ld le mn ju lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">我们的目标是预测下个月的通货膨胀率。您应该拥有的是逗号分隔的值文件(。从2000年1月到2020年4月菲律宾的月通货膨胀率。档案名称为InflationRateLecture.csv。如需完整系列，您可以从Bangko Sentral ng Pilipinas主要统计指标页面下载。您还应该在Mac或PC上安装R和RStudio的副本。如果这是你第一次使用R，不要害怕，只要遵循下面的代码就可以了。</p><p id="b363" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">第一步是安装必要的软件包。对于这个例子，我们需要安装所需的包。这些命令如下:tidyverse用于常规数据操作，urca、forecast、TSstudio和tseries用于必要的预测命令。请随意探索您可以从中获得的各种功能。</p><p id="c2cf" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">生成一个新的脚本，以便您可以跟踪事情。首要任务是安装所需的软件包。我们可以在tools选项卡中手动查找包，或者您可以只运行下面的命令。请注意，根据您的互联网连接，安装可能需要一些时间。</p><pre class="kn ko kp kq gt na nb nc nd aw ne bi"><span id="7110" class="nf lv iq nb b gy ng nh l ni nj">install.packages("tidyverse")<br/>install.packages("urca") <br/>install.packages("forecast") <br/>install.packages("tseries") <br/>install.packages("TSstudio")</span></pre><p id="ac07" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">安装完成后，您现在必须告诉R您将要使用这些包。我们通过调用library()函数来实现这一点。把这想象成从图书馆里拿一本书，你想借并在一次特定的学习中使用。</p><pre class="kn ko kp kq gt na nb nc nd aw ne bi"><span id="6348" class="nf lv iq nb b gy ng nh l ni nj">library(tidyverse)<br/>library(urca)<br/>library(forecast)<br/>library(tseries) <br/>library(TSstudio)</span></pre><p id="9560" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">运行完所有这些命令后，您应该准备好运行所有必要的命令。如果在预测过程中关闭R会话，只需再次使用库命令来重新加载包。无需重新安装(除非有可用的软件包更新)。</p><h2 id="ebd0" class="nf lv iq bd lw nk nl dn ma nm nn dp me lh no np mg ll nq nr mi lp ns nt mk nu bi translated">加载数据集</h2><p id="6c38" class="pw-post-body-paragraph ky kz iq la b lb mm jr ld le mn ju lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">加载数据集的一个简单方法是使用file.choose()函数，它会打开一个对话框，类似于我们打开文件时习惯使用的对话框。将数据集存储在对象中很重要，这样我们以后就可以引用它。首先，我们加载数据集并将其存储在一个对象中。在本教程中，我将物体命名为“膨胀”,但是你可以随意命名。代码和数据集可以在这里找到</p><p id="f4e6" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><a class="ae nv" href="https://drive.google.com/drive/folders/11RZI8p-qCvwLAmdro93FnslQLxCO39Ef?usp=sharing" rel="noopener ugc nofollow" target="_blank">https://drive . Google . com/drive/folders/11 rzi 8 p-qcvwlamdro 93 fnslqlxco 39 ef？usp =共享</a></p><pre class="kn ko kp kq gt na nb nc nd aw ne bi"><span id="ec9c" class="nf lv iq nb b gy ng nh l ni nj">inflation &lt;- read_csv(file.choose())</span></pre><p id="cad1" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">read_csv是tidyverse内R中readr包的一部分。这用于读取csv文件，并能够在r中加载它。您应该注意到，应该会出现一个对话框，提示您选择文件。一定要选InflationRateLecture.csv。</p><pre class="kn ko kp kq gt na nb nc nd aw ne bi"><span id="66ab" class="nf lv iq nb b gy ng nh l ni nj">head(inflation)<br/>nrow(inflation)</span></pre><p id="2303" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">运行head(inflation)命令会列出数据集的前6行。你应该看到2000年1月的通货膨胀率是5.5，2000年2月是5.6，以此类推。nrow(inflation)给出数据集中的总行数。这表明数据集中有244个时间段(月)。您也可以通过查看环境选项卡并单击通货膨胀旁边的网格来查看数据集。</p><h2 id="6c42" class="nf lv iq bd lw nk nl dn ma nm nn dp me lh no np mg ll nq nr mi lp ns nt mk nu bi translated">声明时序对象</h2><p id="7be8" class="pw-post-body-paragraph ky kz iq la b lb mm jr ld le mn ju lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">目前，我们加载的数据集是一个框架。为了能够预测，我们需要一系列。如果你查看数据集，我们只对预测其中的“利率”变量感兴趣。因此，我们需要将“利率”变量转换成一个序列。</p><pre class="kn ko kp kq gt na nb nc nd aw ne bi"><span id="3520" class="nf lv iq nb b gy ng nh l ni nj">inf &lt;- ts(inflation$Rate, start = c(2000,1,5), frequency = 12)</span></pre><p id="15e1" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们正在创建一个名为“inf”的新对象，这是我们将使用的系列。ts命令创建该对象。命令中的第一个参数是变量。$告诉R我们想从数据集通货膨胀中获得利率变量。之后，我们指定开始日期为2000年1月5日。r可以在这之后自动检测结束。最后，我们指定系列的频率。因为我们处理的是月度数据，所以频率应该是12。如果是每季度一次，频率为4，每周一次为52，每两年一次为2。</p><h2 id="2355" class="nf lv iq bd lw nk nl dn ma nm nn dp me lh no np mg ll nq nr mi lp ns nt mk nu bi translated">绘制时间序列图</h2><p id="406a" class="pw-post-body-paragraph ky kz iq la b lb mm jr ld le mn ju lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">将我们的系列形象化是很重要的。我们可以使用autoplot命令来做到这一点。</p><pre class="kn ko kp kq gt na nb nc nd aw ne bi"><span id="e236" class="nf lv iq nb b gy ng nh l ni nj">autoplot(inf) + ggtitle("Inflation Rate (Philippines), January 2000 to April 2020") + labs(x = "Time", y = "Inflation Rate")</span></pre><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nw"><img src="../Images/679950d402673ac3b91eba72d2527a67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F_3fMhkdEleL_nTH3rwz-Q.png"/></div></div><p class="ms mt gj gh gi mu mv bd b be z dk translated">通货膨胀率曲线图</p></figure><p id="2d32" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">该命令以相应的标题“通货膨胀率(菲律宾)，2000年1月至2020年4月”绘制系列“inf”，其中x轴标记为时间，y轴标记为通货膨胀率。对于这些规范，我们使用ggtitle和labs选项。如果你做的正确，你应该有一个类似上图的图。我们可以看到全球金融危机期间的通胀飙升，缩减恐慌，以及最近通过的第一套刺激方案。</p><h1 id="2a85" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">预测构建模块</h1><p id="df2f" class="pw-post-body-paragraph ky kz iq la b lb mm jr ld le mn ju lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">我们现在继续生成ACF和PACF图，并确定序列是否是非平稳的。</p><p id="ca31" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">让我们首先生成通货膨胀率的ACF和PACF。同样，ACF和ACF可以告诉我们很多关于这个系列的特性。通常，它给出了序列的基本过程的一些指示，无论它是AR、MA还是ARMA。此外，如果我们认为序列是非平稳的，我们将看到通货膨胀差值的ACF和PACF。</p><pre class="kn ko kp kq gt na nb nc nd aw ne bi"><span id="6ba5" class="nf lv iq nb b gy ng nh l ni nj">ggAcf(inf) + ggtitle("ACF of Inflation")<br/>ggPacf(inf) + ggtitle("PACF of Inflation")</span></pre><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nx"><img src="../Images/0d70ee4c0ece4a39bd85717907426251.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r3cHL_o_UleZFOOIU-MFyA.png"/></div></div><p class="ms mt gj gh gi mu mv bd b be z dk translated">ACF和PACF(水平)</p></figure><p id="2ce2" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">图中的ACF是几何衰减的，而PACF记录了立即截止。如果我们回忆一下上节课关于ACFand PACF的内容，这与AR过程是一致的。虽然还不确定，但这给了我们一个潜在过程的线索。在ACF中，请注意第一个到第十一个滞后具有统计显著性(超出蓝色置信带)。我们还可以看到，一些部分自相关是重要的，如第一、第二和第十四。</p><h2 id="68ff" class="nf lv iq bd lw nk nl dn ma nm nn dp me lh no np mg ll nq nr mi lp ns nt mk nu bi translated">系列差异</h2><p id="9d54" class="pw-post-body-paragraph ky kz iq la b lb mm jr ld le mn ju lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">减轻非平稳性的一种方法是对序列求差分。为此，我们使用diff()命令。</p><pre class="kn ko kp kq gt na nb nc nd aw ne bi"><span id="b110" class="nf lv iq nb b gy ng nh l ni nj">dinf &lt;- diff(inf)<br/>ggAcf(dinf) + ggtitle("ACF of Inflation (Differenced)") <br/>ggPacf(dinf) + ggtitle("PACF of Inflation (Differenced)")</span></pre><p id="66a5" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">第一个命令利用diff()函数对序列进行差分，并创建一个对象“dinf ”,它是通货膨胀的差值。默认情况下，它会差一次，但我们可以将其设置为差两次或指定的任何次数。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ny"><img src="../Images/de7cf563a5e2afee8cf53202ff92269b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tWVNecNqaKb73A4kPOR_ZA.png"/></div></div><p class="ms mt gj gh gi mu mv bd b be z dk translated">ACF和PACF(差异)</p></figure><p id="9930" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">类似于这些水平，我们可以看到ACF呈几何衰减，而在PACF中可以看到立即截止。这是支持AR过程的更多证据。但是，请注意，并不是很多滞后都很明显。这是一个信号，表明序列是“平稳的”,这迫使它显示协方差平稳的性质。我们将继续深入探讨这个问题。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nz"><img src="../Images/013730638a761adcfb776b14498ed9aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W3FHEaIBYsWbpyWlCzGgFQ.png"/></div></div><p class="ms mt gj gh gi mu mv bd b be z dk translated">水平与差异通货膨胀</p></figure><p id="ae53" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">比较通货膨胀的水平值和差值会得出一些有趣的结果。首先，使用简单的图形外观可以证明非平稳性。但是，在进行正式的统计测试之前，我们不能太确定。第二，请注意，在差分序列中仍然有野峰值(异常值)。这些可能是结构性突变的指标，我们需要考虑它们是否存在。</p><h2 id="8ec2" class="nf lv iq bd lw nk nl dn ma nm nn dp me lh no np mg ll nq nr mi lp ns nt mk nu bi translated">时间序列的分解</h2><p id="144a" class="pw-post-body-paragraph ky kz iq la b lb mm jr ld le mn ju lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">对我们拥有的时间序列进行适当的分解也很重要。这些成分是趋势、季节性和序列中的随机成分。幸运的是，R中有一些命令可以自动为我们绘制图表。</p><pre class="kn ko kp kq gt na nb nc nd aw ne bi"><span id="0e40" class="nf lv iq nb b gy ng nh l ni nj">ts_decompose(inf, type = "additive", showline = TRUE)</span></pre><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/f722c360e46f7d4c181bec672b41db3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5_E611satTNw5tIDN2H2Iw.png"/></div></div><p class="ms mt gj gh gi mu mv bd b be z dk translated">级数的分解</p></figure><p id="7ddc" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">TSstudio库中的ts_decompose命令为我们提供了该系列组件的可视化效果。此命令会将序列分割成序列的观察、趋势、季节和随机部分。请注意，可能在每年的八月或九月，会出现一些可观察到的季节性。原因我会留给你去想。TSstudio中的分解命令更具交互性，允许您将光标悬停在图形(由plot.ly，一个有趣的图形库生成)上，并深入研究该系列。随着时间的推移，我们将会更多地使用这种方法。</p><h1 id="14e6" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">非平稳性测试</h1><p id="0c40" class="pw-post-body-paragraph ky kz iq la b lb mm jr ld le mn ju lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">在测试非平稳性时，我们将使用三种最流行的测试。这些是扩展的迪基-富勒试验、菲利普-佩伦试验和KPSS试验。请记住ADF和PP测试是单位根测试。因此，他们的零假设是非平稳的，而他们的替代品是平稳的。相反，KPSS检验是平稳性检验，其零假设是平稳性，而其替代假设是非平稳性。</p><h2 id="2bb5" class="nf lv iq bd lw nk nl dn ma nm nn dp me lh no np mg ll nq nr mi lp ns nt mk nu bi translated">扩充迪基-富勒试验</h2><p id="e775" class="pw-post-body-paragraph ky kz iq la b lb mm jr ld le mn ju lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">进行ADF测试的命令是r中的adf.test()。我们将使用平稳性的两个备选假设对系列进行此测试。我们将在原始系列和差异系列上运行此操作。</p><pre class="kn ko kp kq gt na nb nc nd aw ne bi"><span id="d762" class="nf lv iq nb b gy ng nh l ni nj">adf.test(inf) <br/>adf.test(inf, k = 1)<br/>adf.test(inf, k = 2)<br/>adf.test(dinf)</span></pre><p id="7715" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">请注意，当我们运行第一行时，有一个提示提示序列是静止的。我们测试第四行的时候也是这样。虽然通货膨胀的差异变量肯定是稳定的，但该水平的值可能具有很大的欺骗性。正如我们前面说过的，ADF测试的限制是你必须指定滞后阶数。这些测试(第一次和第三次)在第六轮进行。如果我们使用一个更现实的滞后，比如1或2，这个序列被确定为非平稳的。</p><h2 id="e5ad" class="nf lv iq bd lw nk nl dn ma nm nn dp me lh no np mg ll nq nr mi lp ns nt mk nu bi translated">菲利普斯-佩龙试验</h2><p id="6adc" class="pw-post-body-paragraph ky kz iq la b lb mm jr ld le mn ju lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">对于Phillips Perron测试，我们使用pp.test()命令。与ADF测试不同，我们不再需要指定滞后阶数，并且更加通用。</p><pre class="kn ko kp kq gt na nb nc nd aw ne bi"><span id="ef09" class="nf lv iq nb b gy ng nh l ni nj">pp.test(inf)<br/>pp.test(dinf)</span></pre><p id="d030" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">PP测试的结果相当有说服力。我们看到，在水平，该系列是不稳定的，因为我们无法拒绝零假设。一旦求差，数列就稳定了。因此，当我们开始建立一个预测模型时，我们需要对通货膨胀进行差分，以使其平稳化。</p><h2 id="b4e1" class="nf lv iq bd lw nk nl dn ma nm nn dp me lh no np mg ll nq nr mi lp ns nt mk nu bi translated"><strong class="ak">科维亚特科夫斯基-菲利普斯-施密特-申试验</strong></h2><p id="2a1a" class="pw-post-body-paragraph ky kz iq la b lb mm jr ld le mn ju lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">最后，我们转向KPSS检验。请记住，这个测试的零假设是平稳性，而另一个假设是非平稳性。KPSS测试的命令是kpss.test()。我们可以指定一个名为null的选项为“趋势”或“水平”或两者。在这种情况下，我们就让它保持缺省值，考虑两者。</p><pre class="kn ko kp kq gt na nb nc nd aw ne bi"><span id="1edf" class="nf lv iq nb b gy ng nh l ni nj">kpss.test(inf)<br/>kpss.test(dinf)</span></pre><p id="c362" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">正如所料，我们发现水平序列不是平稳的。奇怪的是，检验还发现差分序列是非平稳的。尽管如此，我们也可以参考ADF和PP检验的结果来支持我们的主张，即差分序列是平稳的。</p><h1 id="b10b" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">预测本身</h1><p id="b099" class="pw-post-body-paragraph ky kz iq la b lb mm jr ld le mn ju lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">现在让我们转到预测本身。首先，在进行样本外预测之前，我们先进行样本内预测。正如我们在第一部分中提到的，预测样本的原因是为了查看生成的模型的质量，并让我们将不同的预测模型及其估计值与实际实现值进行比较。我们将使用上一章讨论的预测质量指标。最后，在接近尾声时，我们将使用我们确定的最佳预测模型来预测下一年的通货膨胀。</p><h2 id="fb35" class="nf lv iq bd lw nk nl dn ma nm nn dp me lh no np mg ll nq nr mi lp ns nt mk nu bi translated">将数据集分成训练集和测试集</h2><p id="9c9b" class="pw-post-body-paragraph ky kz iq la b lb mm jr ld le mn ju lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">首先，让我们将数据集分成两个样本，一个训练样本和一个测试样本。训练样本是我们必须预测的可用数据。测试样本是已经实现的数据(即我们已经知道系列值)，但我们坚持测试预测模型的质量。而以前，这一步曾经是一个痛苦，与R，它是一件轻而易举的事。我们使用ts_split命令来做到这一点。</p><pre class="kn ko kp kq gt na nb nc nd aw ne bi"><span id="5012" class="nf lv iq nb b gy ng nh l ni nj">split_inf &lt;- ts_split(inf, sample.out = 12)</span><span id="4dcb" class="nf lv iq nb b gy oa nh l ni nj">training &lt;- split_inf$train <br/>testing &lt;- split_inf$test</span><span id="0bcc" class="nf lv iq nb b gy oa nh l ni nj">length(training)<br/>length(testing)</span></pre><p id="c792" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们使用ts_split函数创建了一个名为split_inf的对象，它本质上是inf，但被分成两部分。对象inf分为两部分，其中测试集由命令sample.out给出。我们将sample.out设置为等于12，即12个月或一年。因此，我们希望我们的测试(验证)周期等于一年。之后，我们创建两个对象(培训和测试),这将创建两个独立的系列。使用length命令，我们可以确定每个生成的序列中有多少个周期。您会注意到，定型数据集有232个周期，而测试数据集有12个周期(与sample.out选项指定的数量相同)。</p><h2 id="0974" class="nf lv iq bd lw nk nl dn ma nm nn dp me lh no np mg ll nq nr mi lp ns nt mk nu bi translated">诊断训练集</h2><p id="209c" class="pw-post-body-paragraph ky kz iq la b lb mm jr ld le mn ju lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">至少对实现什么模型有一些概念是很重要的。要做到这一点，我们需要尝试和诊断我们必须的训练数据集，看看我们是否可以提出关于哪个模型可能适合该系列的建议。为此，我们恳求使用arima_diag()命令。</p><pre class="kn ko kp kq gt na nb nc nd aw ne bi"><span id="8d20" class="nf lv iq nb b gy ng nh l ni nj">arima_diag(training)</span></pre><p id="bb78" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">运行这个程序，我们就能得到要跟踪的数字。由于这是使用plot.ly创建的，因此交互性很强。我们可以看到，它显示了训练数据集的值以及相关的ACF和PACF。它还向我们展示了差异训练系列的图表。我们可以看到，ACF正以几何级数下降，在PACF看到了一个直接的截止。这类似于我们对ar模型的预期模式。要确定要使用的滞后数量，请注意在PACF中，前两个滞后仍然很重要。在第二个滞后之后，大多数剩余的滞后是不重要的。现在，让我们猜测两个自回归滞后。还要注意，在PACF和ACF中，有红色的数据点。这些红色的数据点表明了季节性滞后的可能性。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/82ea6e3d5e0cee5dcd0a9bc7c9af6c91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZzJKuG85M7VCdosywpcpgw.png"/></div></div><p class="ms mt gj gh gi mu mv bd b be z dk translated">ARIMA诊断图</p></figure><h2 id="b015" class="nf lv iq bd lw nk nl dn ma nm nn dp me lh no np mg ll nq nr mi lp ns nt mk nu bi translated">构建预测模型</h2><p id="4615" class="pw-post-body-paragraph ky kz iq la b lb mm jr ld le mn ju lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">让我们试着预测具有三种不同规格的三种模型。我们将尝试使用的三种模型是</p><p id="7163" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">安ARIMA(2，1，1)</p><p id="337e" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">萨里玛(2，1，1)(1，0，0)</p><p id="4f8f" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">该模型使用auto.arima()函数确定了最合适的值</p><p id="c192" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">对于第一个模型，我们将尝试使用2个自回归滞后，因为这是PACF所表明的。我们将对序列进行一次差分，因为我们知道在不同的水平上，序列是不稳定的，如ADF、PP和KPSS检验的结果所示。我们猜测我们有1移动平均线滞后。对于第二个模型，我们将使用与第一个相同的规范，只是我们添加了一个季节性自回归滞后。最后，对于第三个模型，我们使用R中内置的auto.arima()函数来避免猜测选择哪个lag规范是最好的。</p><p id="82d2" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">让我们转到模型1。我们创建一个名为arima211的对象，并使用arima()命令进行建模。arima()命令中的第一个选项是training，这是我们将使用的系列。阶数选项指定了ARIMA的阶数，在这种情况下，我们指定了一个具有两个自回归滞后、一个平稳化差异(即序列是1阶的积分)和一个移动平均滞后的ARIMA。autoplot()命令检查是否满足稳定性条件。这就是第二节中阐述的平稳性条件。由于我们处理的是逆根，所以所有的逆根都必须在单位圆内。最后，check_res命令提供对残差的诊断，我们希望残差是白噪声。模型2的结构与此相同，只是我们在调用arima()命令时添加了一个季节性订单。在这种情况下，我们添加1个季节性自回归滞后。模型3的结构与此相同，只是我们让R使用auto.arima()命令来决定顺序。选项search = TRUE只是确保它可以选择一个SARIMAmodel，如果它认为它是最佳的。</p><pre class="kn ko kp kq gt na nb nc nd aw ne bi"><span id="15dc" class="nf lv iq nb b gy ng nh l ni nj">#For Model 1</span><span id="b64b" class="nf lv iq nb b gy oa nh l ni nj">arima211 &lt;- arima(training, order = c(2,1,1))<br/>autoplot(arima211)<br/>check_res(arima211)</span><span id="505b" class="nf lv iq nb b gy oa nh l ni nj">#For Model 2 </span><span id="b8b0" class="nf lv iq nb b gy oa nh l ni nj">sarima2111 &lt;- arima(training, order = c(2,1,1), seasonal = list(order = c(1,0,0)))<br/>autoplot(sarima2111)<br/>check_res(sarima2111)</span><span id="e33a" class="nf lv iq nb b gy oa nh l ni nj">#For Model 3</span><span id="df59" class="nf lv iq nb b gy oa nh l ni nj">auto &lt;- auto.arima(training, seasonal = TRUE)<br/>auto #We obtained a SARIMA(2,1,0)(2,0,1) based on auto.arima()<br/>autoplot(auto)<br/>check_res(auto)</span></pre><p id="5a49" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">如果你做对了，你应该会看到后面的数字。请注意，对于所有三个模型，根都在单位圆内，因此，模型已经通过了平稳性标准，表明不再有单位根。查看残差图，我们看到所有三个模型的残差通常都是白噪声。然而，我们确实注意到有一些滞后在置信带之外，但毫无疑问，模型2和模型3相对于模型1产生更多的白噪声误差，模型1在第12个滞后时具有相当显著的ACF。这种红色滞后是季节性滞后，表明季节性模型更适合。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ob"><img src="../Images/9dbecfb2c8b8b747501343ab03ff1075.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xEmPtIdC6DwxYTmoLLxt3Q.png"/></div></div><p class="ms mt gj gh gi mu mv bd b be z dk translated">逆AR和MA根</p></figure><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi oc"><img src="../Images/d5641717b50a22b815d143c937e465a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7vTgjpfRtdetCf-Cb-nPUw.png"/></div></div><p class="ms mt gj gh gi mu mv bd b be z dk translated">残留诊断</p></figure><h2 id="c09c" class="nf lv iq bd lw nk nl dn ma nm nn dp me lh no np mg ll nq nr mi lp ns nt mk nu bi translated">生成预测和预测评估</h2><p id="fda1" class="pw-post-body-paragraph ky kz iq la b lb mm jr ld le mn ju lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">现在我们到了关键时刻。现在让我们使用每个模型生成预测，并根据基线对它们进行评估。每个型号的命令结构相似。首先，我们创建三个对象，即fcast1、fcast2和fcasta，它们代表每个模型的预测。每个对象都是使用forecast()函数生成的，该函数有两个选项。首先是我们键入它将使用什么模型进行预测。第二个是要预测的周期数。由于测试数据集有12个周期长，我们将范围<em class="mw"> h </em>设置为12。接下来，我们使用test_forecast()命令将预测值与实际值进行比较。该命令生成一个交互式图表，并将每个预测与实际值进行比较，同时还显示每个数据点的关键预测质量指标。最后，accuracy()命令生成我们在上一节中讨论的预测指标的完整平均值。accuracy()命令中的第一个选项是将每个模型生成的预测与测试或验证系列进行比较。</p><p id="09fa" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们可以在下图中看到实际值与预测值的对比图。我们注意到，使用auto.arima()命令生成的规范的模型3似乎是基于fit的最佳模型。请注意，当我们生成这些图表时，我们可以悬停在每个数据点上，它会给我们。</p><pre class="kn ko kp kq gt na nb nc nd aw ne bi"><span id="780a" class="nf lv iq nb b gy ng nh l ni nj">#For Model 1</span><span id="1a1b" class="nf lv iq nb b gy oa nh l ni nj">fcast1 &lt;- forecast(arima211, h = 12)<br/>test_forecast(actual = inf, forecast.obj = fcast1, test = testing)<br/>accuracy(fcast1,testing)</span><span id="fef1" class="nf lv iq nb b gy oa nh l ni nj">#For Model 2</span><span id="70c7" class="nf lv iq nb b gy oa nh l ni nj">fcast2 &lt;- forecast(sarima2111, h = 12)<br/>test_forecast(actual = inf, forecast.obj = fcast2, test = testing)<br/>accuracy(fcast2,testing)</span><span id="7877" class="nf lv iq nb b gy oa nh l ni nj">#For Model 3</span><span id="624e" class="nf lv iq nb b gy oa nh l ni nj">fcasta &lt;- forecast(auto, h = 12)<br/>test_forecast(actual = inf, forecast.obj = fcasta, test = testing)<br/>accuracy(fcasta,testing)</span></pre><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi od"><img src="../Images/2eeb5cc946177e58c52dc4f89683502c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PClVBAwFNVAQbrq7m9S53w.png"/></div></div><p class="ms mt gj gh gi mu mv bd b be z dk translated">预测与实际</p></figure><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi oe"><img src="../Images/51225475e488fb7f455a7226152d1605.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jggHMEO3J1zSXePmhmAzjw.png"/></div></div><p class="ms mt gj gh gi mu mv bd b be z dk translated">预测指标</p></figure><p id="f835" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">进一步使用accuracy()命令，我们可以看到每个模型的预测统计比较。预测指标如下表所示，由accuracy()命令生成。我们可以看到从模型1到模型2以及从模型2到模型3的改进。这表明添加季节滞后是至关重要的，基于这些指标，auto.arima()生成的模型似乎是最佳的。</p><h1 id="9eb7" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">样本外预测</h1><p id="2495" class="pw-post-body-paragraph ky kz iq la b lb mm jr ld le mn ju lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">既然我们知道了预测的最佳模型，我们现在将生成一个样本外预测。在这种情况下，我们不知道数列的实际值。我们只能利用我们所拥有的任何信息来预测未来。本质上，这是你一直期待的预测。</p><h2 id="6527" class="nf lv iq bd lw nk nl dn ma nm nn dp me lh no np mg ll nq nr mi lp ns nt mk nu bi translated">生成最佳拟合</h2><p id="bc52" class="pw-post-body-paragraph ky kz iq la b lb mm jr ld le mn ju lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">与生成模型类似，我们创建一个对象，在其中存储选择的模型。我们不使用训练数据，而是使用inf的整个膨胀序列。然后，我们测试逆AR和MA根以及残差。</p><pre class="kn ko kp kq gt na nb nc nd aw ne bi"><span id="997d" class="nf lv iq nb b gy ng nh l ni nj">finalfit &lt;- auto.arima(inf, seasonal = TRUE)<br/>autoplot(finalfit)<br/>check_res(finalfit)</span></pre><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi of"><img src="../Images/471928576c4b1c1aa61ce41bcbcd7315.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nz3Pl_bN7dM6i_ra6qwjlQ.png"/></div></div><p class="ms mt gj gh gi mu mv bd b be z dk translated">最终装配诊断</p></figure><p id="62b0" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们发现所有的逆根都在AR和MA单位圆内。这样，我们满足了稳定性条件，不再有任何单位根。在残差诊断中，虽然仍有一些明显的滞后，但通常已经是白噪声了。</p><h1 id="752b" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">生成样本外预测</h1><p id="bea5" class="pw-post-body-paragraph ky kz iq la b lb mm jr ld le mn ju lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">我们现在使用我们选择的模型进行预测。以下命令将生成预测。由于通货膨胀通常会被重新预测，让我们设定一个4个月的短期范围。然后，让我们看看它对2020年5月至8月通胀率的预测。summary()命令列出了未来四个月的点预测和置信区间。</p><pre class="kn ko kp kq gt na nb nc nd aw ne bi"><span id="9e5f" class="nf lv iq nb b gy ng nh l ni nj">fcastf &lt;- forecast(inf, model = finalfit, h = 4)<br/>plot_forecast(fcastf)<br/>summary(fcastf)</span></pre><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/97cbe747a9a6f1e685cb18ec26d1a864.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jng0APCUMEOrCnHsdh3lKA.png"/></div></div><p class="ms mt gj gh gi mu mv bd b be z dk translated">2020年5月至8月通胀率预测</p></figure><p id="8bce" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们可以看到，5月(2.0%)、6月(2.1%)、7月(2.1%)和8月(2.1%)的预测值与BSP的通胀目标和其他预测估计值相当一致。还要注意，随着地平线变得越来越大，置信带也随之扩大。干得好，你刚刚预测了你的第一个关键经济变量。</p><h1 id="a35d" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">结论</h1><p id="0293" class="pw-post-body-paragraph ky kz iq la b lb mm jr ld le mn ju lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">我们现在已经对样本外进行了预测，并获得了未来四个月的值。随着时间的推移，我们将会看到我们的预测是否确实可靠。可以说，预测是一个反复试验的过程，但我希望您看到指标和内置函数能够消除这一过程中的猜测。尽管如此，预测也是一门艺术，根据经济结构和直觉确定滞后和条件可能在改善预测方面发挥关键作用。当我们讨论多变量预测时，我们将会看到更多。</p><p id="f187" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">现在，建议您使用您现在已经学习过的许多工具进行试验，看看您是否能找到一个模型，它提供的预测质量指标甚至比使用auto.arima()函数选择的模型还要好。这当然是可能的，它只是表明，虽然机器已经进步了这么多，但在一个充满数学和科学的地方，仍然有艺术的空间。一个人只需要寻找这样做的动机。</p><p id="4999" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">为了获得更多的实践经验，我制作了这篇文章的视频，可以在我的YouTube频道上找到。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="og oh l"/></div></figure><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="og oh l"/></div></figure><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="og oh l"/></div></figure><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="og oh l"/></div></figure><h1 id="eb07" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">参考</h1><p id="10f4" class="pw-post-body-paragraph ky kz iq la b lb mm jr ld le mn ju lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">[1]布鲁克斯，C. <em class="mw">金融计量经济学导论</em>。(2019)剑桥大学出版社。</p><p id="4d57" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">[2]汉密尔顿，j .时间序列计量经济学。(1994) <em class="mw">普林斯顿大学出版社，普林斯顿</em>。</p></div></div>    
</body>
</html>