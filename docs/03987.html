<html>
<head>
<title>Modeling Your Stock Portfolio Performance with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python建模你的股票投资组合表现</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/modeling-your-stock-portfolio-performance-with-python-fbba4ef2ef11?source=collection_archive---------5-----------------------#2020-04-13">https://towardsdatascience.com/modeling-your-stock-portfolio-performance-with-python-fbba4ef2ef11?source=collection_archive---------5-----------------------#2020-04-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f6be" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用200行代码评估你的交易表现</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b2a1a086ba072d5c29a3f79e83c86c09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZF3GJGfCga3QGA_h"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@jamie452?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">杰米街</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="70de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我刚开始学习Python时，我的目标之一是理解如何更好地评估我的股票投资组合的财务表现。我看到了凯文·博勒(Kevin Boller)的一篇很棒的文章(T5 ),他用python将投资组合与标准普尔500指数进行了比较。我强烈建议花几分钟时间通读它，以便更好地理解基本的金融概念，因为我在这里不会深入探讨。</p><p id="2a14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我想要的是数据的时间序列显示，而这更多的是一个时间点的汇总。最初的代码还假设股票销售永远不会发生，我希望它反映在动态时间框架内买入/卖出头寸的现实。</p><p id="bfce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文的其余部分将探讨我如何构建代码的过程，在时间加权的基础上准确计算性能的挑战，以及如何显示最终结果。下面解释的文件和代码可以在这里<a class="ae ky" href="https://github.com/mattygyo/stock_portfolio_analysis" rel="noopener ugc nofollow" target="_blank">找到并分叉</a>。</p><h1 id="c21d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">构建问题</h1><p id="c381" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们的目标是从某人的投资组合中读取一个包含“买入”和“卖出”的CSV文件，然后计算任意指定时间范围内相对于某个指数的回报率。“听起来不可怕！”——在开始编码之前，我脑海中傲慢的声音说道。事实证明，语音是一个绝望的乐观主义者，实际上有很多障碍，包括:</p><ul class=""><li id="fdb1" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">对于相对的开始和结束日期，如何计算开始时的“当前”持有量？</li><li id="49eb" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">在给定的时间范围内，你如何计算同一仓位的多次买入和卖出？</li><li id="6ce5" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">当同一支股票在不同的成本基础上进行多次购买/销售时，如何准确描述成本基础？</li></ul><p id="78fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了更好地说明这些挑战，这里有一张图，试图将一个场景可视化:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/703b7b389dc7aa8c2e3da36cb285a60c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NBpgNv-ZbxaKixBimys_ZA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">显示买卖后正确计算的成本/份额的示例</p></figure><p id="b923" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请看插图，最上面的表格代表投资组合中的一些虚假的买入/卖出数据。下面的部分显示了所选时间段内不同时间点的每日快照。正如你所看到的，在开始日期之前的交易<strong class="lb iu">在计算时间段开始时的活跃余额时变得非常重要。仅仅因为我在开始日期之前购买了100股苹果股票，并不意味着它应该被排除在外。</strong></p><p id="6eb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你还会注意到，在表格的底部中间，卖出AAPL股票时，每股成本变成了11.53美元，这是为什么呢？因为AAPL股票是在两天后以不同的价格购买的，我们需要合计并平均成本。这意味着你销售的顺序变得很重要！对于本文，我们将假设一切都符合<a class="ae ky" href="https://en.wikipedia.org/wiki/FIFO_and_LIFO_accounting" rel="noopener ugc nofollow" target="_blank"> FIFO </a>标准，这意味着最早买入的股票是最先卖出的股票。最后，我们看到购买MSFT股票将被排除，因为它存在于时间范围之外，所以我们需要在我们的计划中考虑这一点。</p><h1 id="e1a2" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">解决方案提案</h1><p id="93ce" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在考虑了上面提到的挑战后，我决定创建一个新的持股和股票价格的“每日”计算，这对于生成准确的分析是必要的。作为一个额外的好处，凯文文章中提到的一切也是可行的，因为几乎所有的计算都是基于拍摄一张快照并将其与后来的快照进行比较。记住这一切，我们将采用以下方法来构建它:</p><ul class=""><li id="8368" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">读取包含所有买入/卖出交易日期的投资组合文件，然后在指定的结束日期之前提取所有报价机的每日数据(记住我们需要担心开始日期之前的买入/卖出)</li><li id="5f34" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">根据提供的起始日期，计算“活跃”投资组合持有量和调整后的单位持有成本</li><li id="e08f" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">在我的投资组合中创建一个每日“活跃持有”清单，以及股票的每日收盘价</li><li id="0efd" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">基于每天的合并数据创建计算</li></ul><p id="4e5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经有了一个我们想要完成的松散结构，让我们开始打字吧！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Doggo正在做一个蛇boi程序</p></figure><h1 id="44fc" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">步骤1 —获取数据</h1><p id="2a13" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们需要做的第一件事是获取我们投资组合中股票的每日数据，以及我们评估投资组合的基准数据。股票数据通常不会以开源或免费的形式提供，尽管有很多令人敬畏的服务，如用于核心分析的<a class="ae ky" href="https://www.quandl.com/" rel="noopener ugc nofollow" target="_blank"> Quandl </a>或<a class="ae ky" href="https://iexcloud.io/" rel="noopener ugc nofollow" target="_blank"> IEXFinance </a>，它们对我的普锐斯需求来说是一辆法拉利。幸运的是，有一个名为<a class="ae ky" href="https://github.com/ranaroussi/yfinance" rel="noopener ugc nofollow" target="_blank"> yfinance </a>的优秀库，它可以抓取雅虎财经的股票数据，并以结构化的形式返回。因此，让我们从导入我们需要的库和获取数据的前几个函数开始:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj ni l"/></div></figure><p id="fade" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们正在编写的第一个函数叫做<code class="fe nk nl nm nn b">create_market_cal</code>，它使用<a class="ae ky" href="https://github.com/rsheftel/pandas_market_calendars" rel="noopener ugc nofollow" target="_blank">pandas _ market _ calendars</a>库来查找指定时间段内的所有相关交易日。这个库根据市场自动过滤掉非交易日，所以我不需要担心通过使用类似<a class="ae ky" href="https://pandas.pydata.org/pandas-docs/version/0.22.0/generated/pandas.date_range.html" rel="noopener ugc nofollow" target="_blank"> pandas.date_range </a>的东西将数据连接到无效日期。由于我的股票都在美国，我将选择<code class="fe nk nl nm nn b">NYSE</code>作为我的日历，然后标准化时间戳，使它们便于以后加入。</p><p id="13f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nk nl nm nn b">get_data</code>函数获取一组股票报价器以及开始和结束日期，然后使用上面列出的yfinance库获取数据。您会注意到结束日期参数包括一个<code class="fe nk nl nm nn b">timedelta</code>转移，这是因为yfinance不包括您提供的结束日期。由于我们不想在设置参数时记住这个警告，我们将使用timedelta将这里的日期移动+1。</p><p id="445d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，<code class="fe nk nl nm nn b">get_benchmark</code>函数只是馈入<code class="fe nk nl nm nn b">get_data</code>，然后放下股票代码。现在我们已经有了初始函数，让我们运行下面的程序来给变量赋值:</p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="3b4a" class="ns lw it nn b gy nt nu l nv nw">portfolio_df = pd.read_csv('stock_transactions.csv')<br/>portfolio_df['Open date'] = pd.to_datetime(portfolio_df['Open date'])</span><span id="7cd9" class="ns lw it nn b gy nx nu l nv nw">symbols = portfolio_df.Symbol.unique()<br/>stocks_start = datetime.datetime(2017, 9, 1)<br/>stocks_end = datetime.datetime(2020, 4, 7)</span><span id="ce9f" class="ns lw it nn b gy nx nu l nv nw">daily_adj_close = get_data(symbols, stocks_start, stocks_end)<br/>daily_adj_close = daily_adj_close[['Close']].reset_index()<br/>daily_benchmark = get_benchmark(['SPY'], stocks_start, stocks_end)<br/>daily_benchmark = daily_benchmark[['Date', 'Close']]<br/>market_cal = create_market_cal(stocks_start, stocks_end)</span></pre><p id="0ea3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为参考，我的CSV文件包含以下各列，如果您尝试复制，您需要确保您的CSV包含相同的列:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/0fed99fa2c0b50ec14359f2d267e65b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8-jgnAFBN-41XeV0gwfOdQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">事务CSV格式</p></figure><p id="7120" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在有四个重要的数据集来继续:</p><ol class=""><li id="d660" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu nz my mz na bi translated"><code class="fe nk nl nm nn b">portfolio_df</code>根据我们的购买/销售交易历史</li><li id="0473" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu nz my mz na bi translated"><code class="fe nk nl nm nn b">daily_adj_close</code>在指定的结束日期之前，每天关闭我们库存中的所有票据</li><li id="d38f" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu nz my mz na bi translated"><code class="fe nk nl nm nn b">daily_benchmark</code>与每日收盘数据进行基准比较</li><li id="eeaa" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu nz my mz na bi translated"><code class="fe nk nl nm nn b">market_cal</code>包含我们时间段内市场开放的日期</li></ol><p id="2703" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">利用这一点，我们可以前进到下一步，走向辉煌！</p><h1 id="a3f1" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">第2步——找到我们最初的活跃投资组合</h1><p id="6332" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在我们有了这四个数据集，我们需要计算出在指定的起始日期我们积极持有了多少股票。为此，我们将创建两个函数，<code class="fe nk nl nm nn b">portfolio_start_balance</code>和<code class="fe nk nl nm nn b">position_adjust</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj ni l"/></div></figure><p id="3236" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将输出分配给一个变量应该会给你投资组合中的活跃头寸:</p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="5657" class="ns lw it nn b gy nt nu l nv nw">active_portfolio = portfolio_start_balance(portfolio_df, stocks_start)</span></pre><p id="8b22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以看到代码了，让我们看看内部的工作原理，用通俗的语言展示一下发生了什么。</p><h2 id="1bfd" class="ns lw it bd lx oa ob dn mb oc od dp mf li oe of mh lm og oh mj lq oi oj ml ok bi translated"><code class="fe nk nl nm nn b">portfolio_start_balance</code></h2><p id="1624" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">首先，我们向<code class="fe nk nl nm nn b">portfolio_start_balance</code>函数提供CSV数据和开始日期，并创建在开始日期之前发生的所有交易的数据框架。然后，我们将检查在start _ date之后<strong class="lb iu">是否有未来销售，因为我们最终将重建该数据帧的快照:</strong></p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="4521" class="ns lw it nn b gy nt nu l nv nw">positions_before_start = portfolio[portfolio['Open date'] &lt;= start_date]<br/>future_sales = portfolio[(portfolio['Open date'] &gt;= start_date) &amp; (portfolio['Type'] == 'Sell.FIFO')]</span></pre><p id="d55b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们将创建一个在start_date之前<strong class="lb iu">发生的销售数据框架。我们需要确保在指定的start_date，这些都从我们的活动投资组合中剔除:</strong></p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="a041" class="ns lw it nn b gy nt nu l nv nw">sales = positions_before_start[positions_before_start['Type'] == 'Sell.FIFO'].groupby(['Symbol'])['Qty'].sum()<br/>sales = sales.reset_index()</span></pre><p id="380f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将制作在指定时间段内没有任何销售发生的头寸的最终数据框架:</p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="03c4" class="ns lw it nn b gy nt nu l nv nw">positions_no_change = positions_before_start[~positions_before_start['Symbol'].isin(sales['Symbol'].unique())]</span></pre><p id="df33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们将遍历我们的<code class="fe nk nl nm nn b">sales</code>数据帧中的每一笔销售，调用我们的<code class="fe nk nl nm nn b">position_adjust</code>函数，然后将它的输出追加到我们的空<code class="fe nk nl nm nn b">adj_postitions_df</code>中:</p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="4e42" class="ns lw it nn b gy nt nu l nv nw">adj_positions_df = pd.DataFrame()<br/>for sale in sales.iterrows():<br/>    adj_positions = position_adjust(positions_before_start, sale)<br/>    adj_positions_df = adj_positions_df.append(adj_positions)</span></pre><p id="3fcc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们看看<code class="fe nk nl nm nn b">position_adjust</code>函数是如何工作的，这样我们就可以完全理解这里发生了什么。</p><h2 id="719b" class="ns lw it bd lx oa ob dn mb oc od dp mf li oe of mh lm og oh mj lq oi oj ml ok bi translated"><code class="fe nk nl nm nn b">position_adjust</code></h2><p id="d8c3" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">首先，我们将创建一个名为<code class="fe nk nl nm nn b">stocks_with_sales</code>的空数据框架，稍后我们将在其中添加调整后的头寸，另一个数据框架包含所有标记为“买入”的交易。</p><p id="4219" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，我们已经在<code class="fe nk nl nm nn b">portfolio_start_balance</code>函数中过滤了“未来购买”,因此无需在此重复。你还会注意到我们是按“开仓日期”排序的，这很重要，因为我们想用FIFO方法减去仓位。通过对日期进行排序，我们知道我们可以迭代地遍历从旧到新的位置列表:</p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="3321" class="ns lw it nn b gy nt nu l nv nw">stocks_with_sales = pd.DataFrame()    <br/>buys_before_start = daily_positions[daily_positions['Type'] == 'Buy'].sort_values(by='Open date')</span></pre><p id="d727" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们在一个数据框架中有了所有的买入，我们将过滤股票代码与卖出位置的股票代码相匹配的所有买入:</p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="c4ef" class="ns lw it nn b gy nt nu l nv nw">for position in buys_before_start[buys_before_start['Symbol'] == sale[1]['Symbol']].iterrows():</span></pre><p id="6606" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您会注意到，我们使用索引来访问数据中的“符号”列。这是因为使用<code class="fe nk nl nm nn b">iterrows()</code>从索引[0]和数据序列[1]创建了一个元组。这与我们在遍历<code class="fe nk nl nm nn b">buys_before_start</code>时使用索引的原因相同:</p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="77a2" class="ns lw it nn b gy nt nu l nv nw">for position in buys_before_start[buys_before_start['Symbol'] == sale[1]['Symbol']].iterrows():<br/>        if position[1]['Qty'] &lt;= sale[1]['Qty']:<br/>            sale[1]['Qty'] -= position[1]['Qty']<br/>            position[1]['Qty'] = 0<br/>        else:<br/>            position[1]['Qty'] -= sale[1]['Qty']<br/>            sale[1]['Qty'] -= sale[1]['Qty']<br/>        stocks_with_sales = stocks_with_sales.append(position[1])</span></pre><p id="caaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以循环中发生的是在<code class="fe nk nl nm nn b">buys_before_start</code>的每一次购买:</p><ul class=""><li id="f200" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">如果最早的买入数量≤卖出数量(也就是你卖出的数量超过了你最初的买入数量)，从卖出数量中减去买入数量，然后将买入数量设置为0</li><li id="13f6" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">否则(某一天你买入的数量&gt;卖出的数量)，从买入位置减去卖出数量，然后从卖出位置减去相同的数量</li><li id="08e3" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">将调整后的位置附加到空的<code class="fe nk nl nm nn b">stock_with_sales</code>数据帧中</li></ul><p id="9ee0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦循环通过每个销售位置，您的代码现在将执行<code class="fe nk nl nm nn b">portfolio_start_balance</code>的最后几行:</p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="64d7" class="ns lw it nn b gy nt nu l nv nw">adj_positions_df = adj_positions_df.append(positions_no_change)<br/>adj_positions_df = adj_positions_df.append(future_sales)<br/>adj_positions_df = adj_positions_df[adj_positions_df['Qty'] &gt; 0]</span></pre><p id="3d0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们在<code class="fe nk nl nm nn b">adj_positions_df</code>中获取调整后的头寸，添加从未有过销售的回售头寸，添加未来发生的回售头寸，并最终过滤掉<code class="fe nk nl nm nn b">position_adjust</code>清零的任何行。你现在应该有一个准确的记录，你的积极持有开始日期！</p><h1 id="85f6" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">步骤3 —创建每日性能快照</h1><p id="13a1" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在我们有了在开始日期持仓的准确报表，让我们创建每日业绩数据！我们的策略类似于我们在步骤2中所做的，事实上，我们将再次重复使用<code class="fe nk nl nm nn b">position_adjust</code>方法，因为我们需要考虑我们的日期范围内的潜在销售额。我们将继续创建两个新函数，<code class="fe nk nl nm nn b">time_fill</code>和<code class="fe nk nl nm nn b">fifo</code>，我将更详细地解释每个函数的作用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj ni l"/></div></figure><h2 id="013a" class="ns lw it bd lx oa ob dn mb oc od dp mf li oe of mh lm og oh mj lq oi oj ml ok bi translated">时间填充</h2><p id="b31a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">与<code class="fe nk nl nm nn b">portfolio_start_balance</code>类似，我们的目标是提供活跃头寸的数据框架，找到卖出头寸，并根据买入头寸将卖出头寸清零。这里的主要区别是，我们将使用有效交易日的<code class="fe nk nl nm nn b">market_cal</code>列表进行循环:</p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="44ae" class="ns lw it nn b gy nt nu l nv nw">sales = portfolio[portfolio['Type'] == 'Sell.FIFO'].groupby(['Symbol','Open date'])['Qty'].sum()<br/>sales = sales.reset_index()</span><span id="c09c" class="ns lw it nn b gy nx nu l nv nw">per_day_balance = []<br/>for date in market_cal:<br/>        if (sales['Open date'] == date).any():<br/>            portfolio = fifo(portfolio, sales, date)</span></pre><p id="2d65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，我们可以每天查看是否有销售发生，正确调整头寸，然后返回每日数据的正确快照。此外，我们还将过滤之前或当前<code class="fe nk nl nm nn b">date</code>发生的头寸，并确保只有买入。然后，我们将在market_cal循环中添加一个带有当前<code class="fe nk nl nm nn b">date</code>的<code class="fe nk nl nm nn b">Date Snapshot</code>列，然后将其追加到我们的<code class="fe nk nl nm nn b">per_day_balance</code>列表中:</p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="75af" class="ns lw it nn b gy nt nu l nv nw">daily_positions = portfolio[portfolio['Open date'] &lt;= date]<br/>daily_positions = daily_positions[daily_positions['Type'] == 'Buy']<br/>daily_positions['Date Snapshot'] = date<br/>per_day_balance.append(daily_positions)</span></pre><h2 id="d572" class="ns lw it bd lx oa ob dn mb oc od dp mf li oe of mh lm og oh mj lq oi oj ml ok bi translated">先入先出</h2><p id="06ce" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们的<code class="fe nk nl nm nn b">fifo</code>函数获取您的活跃投资组合头寸、在<code class="fe nk nl nm nn b">time_fill</code>中创建的销售数据框架以及在<code class="fe nk nl nm nn b">market_cal</code>列表中的当前<code class="fe nk nl nm nn b">date</code>。然后对<code class="fe nk nl nm nn b">sales</code>进行过滤，找出当前<code class="fe nk nl nm nn b">date</code>发生的任何情况，并创建不受<code class="fe nk nl nm nn b">sales</code>影响的位置的数据帧:</p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="0f14" class="ns lw it nn b gy nt nu l nv nw">sales = sales[sales['Open date'] == date]<br/>daily_positions = daily_positions[daily_positions['Open date'] &lt;= date]<br/>positions_no_change = daily_positions[~daily_positions['Symbol']. isin(sales['Symbol'].unique())]</span></pre><p id="4e4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们将使用我们可靠的<code class="fe nk nl nm nn b">position_adjust</code>函数来清除任何活跃销售的头寸。如果在特定日期没有销售，我们的函数将简单地将<code class="fe nk nl nm nn b">positions_no_change</code>附加到空的<code class="fe nk nl nm nn b">adj_positions</code>数据帧上，为您留下准确的每日头寸快照:</p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="731a" class="ns lw it nn b gy nt nu l nv nw">adj_positions = pd.DataFrame()<br/>for sale in sales.iterrows():<br/>    adj_positions = adj_positions.append(position_adjust( daily_positions, sale))<br/>adj_positions = adj_positions.append(positions_no_change)<br/>adj_positions = adj_positions[adj_positions['Qty'] &gt; 0]</span></pre><p id="bd20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行这行代码应该会返回指定时间范围内所有交易日的列表，以及每天头寸的准确计数:</p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="3e92" class="ns lw it nn b gy nt nu l nv nw">positions_per_day = time_fill(active_portfolio, market_cal)</span></pre><h1 id="8fb2" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">步骤4 —进行投资组合计算</h1><p id="0b48" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如果你还跟着我们，我们就在最后阶段了！现在我们已经有了我们的活跃持仓量的准确的每日分类账，我们可以继续创建生成图表所需的最终计算！为此，我们将在代码中添加另外六个函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj ni l"/></div></figure><p id="c620" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从最后一个函数<code class="fe nk nl nm nn b">per_day_portfolio_calcs</code>开始，因为它将使用所有其他函数。</p><h2 id="c131" class="ns lw it bd lx oa ob dn mb oc od dp mf li oe of mh lm og oh mj lq oi oj ml ok bi translated">每日投资组合计算</h2><p id="7eb8" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在我们已经有了步骤3中的<code class="fe nk nl nm nn b">positions_per_day</code>，我们的目标是将它与<code class="fe nk nl nm nn b">daily_benchmark</code>、<code class="fe nk nl nm nn b">daily_adj_close</code>和<code class="fe nk nl nm nn b">stocks_start</code>一起传递给这个新函数:</p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="2a2d" class="ns lw it nn b gy nt nu l nv nw">combined_df = per_day_portfolio_calcs(positions_per_day, daily_benchmark, daily_adj_close, stocks_start)</span></pre><p id="8103" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们将使用<code class="fe nk nl nm nn b">pd.concat</code>将我们的数据帧列表连接成一个列表:</p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="4524" class="ns lw it nn b gy nt nu l nv nw">df = pd.concat(per_day_holdings, sort=True)</span></pre><p id="2e15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们有了一个大数据帧，我们将把它传递给<code class="fe nk nl nm nn b">per_day_portfolio_calcs</code>中的其余函数。</p><h2 id="cdad" class="ns lw it bd lx oa ob dn mb oc od dp mf li oe of mh lm og oh mj lq oi oj ml ok bi translated">修改后的每股成本</h2><p id="b29a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如果我们想跟踪每天的表现，我们需要知道我们每天持有股票的理论价值。这需要计算当前持有的证券数量，然后乘以每只证券的每日收盘价。</p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="7b91" class="ns lw it nn b gy nt nu l nv nw">mcps = modified_cost_per_share(df, daily_adj_close, stocks_start)</span></pre><p id="5182" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们提供了新的单一df以及使用yfinance提取的每日数据，以及我们的开始日期。然后，我们将通过将投资组合快照的日期与每日数据的日期相结合，以及在自动收报机上相结合，来将我们的投资组合与每日收盘数据相结合。对于更熟悉SQL的人来说，这实际上是一个左连接:</p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="4b01" class="ns lw it nn b gy nt nu l nv nw">df = pd.merge(portfolio, adj_close, left_on=['Date Snapshot', 'Symbol'],right_on=['Date', 'Ticker'], how='left')</span></pre><p id="cdab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们合并了<code class="fe nk nl nm nn b">df</code>,我们将把每日收盘重新命名为“符号调整收盘”,然后用每日收盘乘以拥有的股票数量。删除额外的列将返回我们需要继续的数据帧:</p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="1f5d" class="ns lw it nn b gy nt nu l nv nw">df.rename(columns={'Close': 'Symbol Adj Close'}, inplace=True)<br/>df['Adj cost daily'] = df['Symbol Adj Close'] * df['Qty']<br/>df = df.drop(['Ticker', 'Date'], axis=1)</span></pre><h2 id="4670" class="ns lw it bd lx oa ob dn mb oc od dp mf li oe of mh lm og oh mj lq oi oj ml ok bi translated">基准_投资组合_计算</h2><p id="b775" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在我们有了证券的准确每日成本，我们希望将基准添加到数据集中，以便与我们的投资组合进行比较:</p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="0258" class="ns lw it nn b gy nt nu l nv nw">bpc = benchmark_portfolio_calcs(mcps, daily_benchmark)</span></pre><p id="6af8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们首先使用类似于<code class="fe nk nl nm nn b">modified_cost_per_share</code>中的合并将我们的每日基准数据合并到正确的快照中:</p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="51c9" class="ns lw it nn b gy nt nu l nv nw">portfolio = pd.merge(portfolio, benchmark, left_on=['Date Snapshot'], right_on=['Date'], how='left')<br/>portfolio = portfolio.drop(['Date'], axis=1)<br/>portfolio.rename(columns={'Close': 'Benchmark Close'}, inplace=True)</span></pre><p id="5150" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经将基准的每日收盘数据合并到我们的投资组合数据集中，我们将根据其最大和最小日期过滤我们的<code class="fe nk nl nm nn b">daily_benchmark</code>数据。使用最大值和最小值来对比你的开始和结束日期是很重要的，因为最大值/最小值会考虑市场开放的日子:</p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="1fd3" class="ns lw it nn b gy nt nu l nv nw">benchmark_max = benchmark[benchmark['Date'] == benchmark['Date'].max()]<br/>portfolio['Benchmark End Date Close'] = portfolio.apply(lambda x: benchmark_max['Close'], axis=1)</span><span id="effd" class="ns lw it nn b gy nx nu l nv nw">benchmark_min = benchmark[benchmark['Date'] == benchmark['Date'].min()]<br/>portfolio['Benchmark Start Date Close'] = portfolio.apply(lambda x: benchmark_min['Close'], axis=1)</span></pre><p id="b27f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了！因此，现在我们在投资组合数据集中也有了基准的绝对开始和结束收盘，这在计算每日回报时将非常重要。</p><h2 id="94ea" class="ns lw it bd lx oa ob dn mb oc od dp mf li oe of mh lm og oh mj lq oi oj ml ok bi translated">投资组合_年末_统计</h2><p id="621d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在我们的基准数据已经添加完毕，让我们进入下一步:</p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="6548" class="ns lw it nn b gy nt nu l nv nw">pes = portfolio_end_of_year_stats(bpc, daily_adj_close)</span></pre><p id="1ca9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们这里的目标是获取<code class="fe nk nl nm nn b">benchmark_portfolio_calcs</code>的输出，找到投资组合中所有股票的最后一天收盘，然后向我们的投资组合数据集中添加一个<code class="fe nk nl nm nn b">Ticker End Date Close</code>列。我们将再次合并到每日股票数据中，过滤最大日期，然后根据股票代码进行连接:</p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="c9eb" class="ns lw it nn b gy nt nu l nv nw">adj_close_end = adj_close_end[adj_close_end['Date'] == adj_close_end['Date'].max()]</span><span id="4cdf" class="ns lw it nn b gy nx nu l nv nw">portfolio_end_data = pd.merge(portfolio, adj_close_end, left_on='Symbol', right_on='Ticker')</span><span id="fe43" class="ns lw it nn b gy nx nu l nv nw">portfolio_end_data.rename(columns={'Close': 'Ticker End Date Close'}, inplace=True)</span><span id="2c13" class="ns lw it nn b gy nx nu l nv nw">portfolio_end_data = portfolio_end_data.drop(['Ticker', 'Date'], axis=1)</span></pre><p id="1aaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，在我们生成计算结果之前，只需再走一步！</p><h2 id="6660" class="ns lw it bd lx oa ob dn mb oc od dp mf li oe of mh lm og oh mj lq oi oj ml ok bi translated">投资组合_年初_统计</h2><p id="a131" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这最后一步采用更新的投资组合数据框架，即来自yfinance的每日股票数据，并为基准分配年初等价头寸:</p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="4c7e" class="ns lw it nn b gy nt nu l nv nw">pss = portfolio_start_of_year_stats(pes, daily_adj_close)</span></pre><p id="581f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将首先过滤开始日期的每日收盘数据，然后使用股票代码将我们的投资组合数据合并到其中。为了方便起见，我们将这种关闭称为<code class="fe nk nl nm nn b">Ticker Start Date Close</code>:</p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="dbd9" class="ns lw it nn b gy nt nu l nv nw">adj_close_start = adj_close_start[adj_close_start['Date'] == adj_close_start['Date'].min()]</span><span id="5042" class="ns lw it nn b gy nx nu l nv nw">portfolio_start = pd.merge(portfolio, adj_close_start[['Ticker', 'Close', 'Date']], left_on='Symbol', right_on='Ticker')</span><span id="8d71" class="ns lw it nn b gy nx nu l nv nw">portfolio_start.rename(columns={'Close': 'Ticker Start Date Close'}, inplace=True)</span></pre><p id="0528" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们需要调整每股成本，但是为什么呢？想象一下，你很久以前以500美元/股的价格购买了谷歌，但现在你想计算2020年你的头寸的YTD回报率。如果你用500美元作为你2020年初的成本基础，你不会有一个准确的比较，因为成本基础是多年前的。为了解决这个问题，我们将使用Numpy的<code class="fe nk nl nm nn b">where</code>函数:</p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="b67e" class="ns lw it nn b gy nt nu l nv nw">portfolio_start['Adj cost per share'] = np.where(portfolio_start['Open date'] &lt;= portfolio_start['Date'],<br/>         portfolio_start['Ticker Start Date Close'],<br/>         portfolio_start['Adj cost per share'])</span></pre><p id="4d6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单来说，这就是说‘如果开市日期≤开始日期的日期，那么<code class="fe nk nl nm nn b">Adj cost per share</code>等于<code class="fe nk nl nm nn b">Ticker Start Date Close</code>’(股票从yfinance数据上的min日期开始的收盘价)。如果没有，那就用现有的<code class="fe nk nl nm nn b">Adj cost per share</code>。</p><p id="9aff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">剩余部分根据修改后的每股成本修改调整后的成本，从合并中删除不需要的列，然后根据新计算的调整后成本计算您将拥有的基准股票的等量:</p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="8e67" class="ns lw it nn b gy nt nu l nv nw">portfolio_start['Adj cost'] = portfolio_start['Adj cost per share'] * portfolio_start['Qty']<br/>portfolio_start = portfolio_start.drop(['Ticker', 'Date'], axis=1)</span><span id="8c6a" class="ns lw it nn b gy nx nu l nv nw">portfolio_start['Equiv Benchmark Shares'] = portfolio_start['Adj cost'] / portfolio_start['Benchmark Start Date Close']</span><span id="80c4" class="ns lw it nn b gy nx nu l nv nw">portfolio_start['Benchmark Start Date Cost'] = portfolio_start['Equiv Benchmark Shares'] * portfolio_start['Benchmark Start Date Close']</span></pre><p id="9811" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">恭喜，我们现在已经有了正确计算回报的所有必要数据！让我们完成最后一部分，然后开始想象！</p><h2 id="46e6" class="ns lw it bd lx oa ob dn mb oc od dp mf li oe of mh lm og oh mj lq oi oj ml ok bi translated">计算返回</h2><p id="b252" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这里的最后一步只是从所有其他函数中提取聚合数据帧，对我们一直在修改的数据应用一系列计算，并返回最终数据帧:</p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="408a" class="ns lw it nn b gy nt nu l nv nw">returns = calc_returns(pss)</span></pre><p id="37d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一组<code class="fe nk nl nm nn b">Benchmark Return</code>和<code class="fe nk nl nm nn b">Ticker Return</code>都使用当前收盘价除以其初始成本基础来计算回报:</p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="7454" class="ns lw it nn b gy nt nu l nv nw">portfolio['Benchmark Return'] = portfolio['Benchmark Close'] / portfolio['Benchmark Start Date Close'] - 1</span><span id="1a7b" class="ns lw it nn b gy nx nu l nv nw">portfolio['Ticker Return'] = portfolio['Symbol Adj Close'] / portfolio['Adj cost per share'] - 1</span></pre><p id="7375" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每家公司的份额价值以相同的方式计算，使用我们之前计算的修改后的每日数量和等效基准份额:</p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="b468" class="ns lw it nn b gy nt nu l nv nw">portfolio['Ticker Share Value'] = portfolio['Qty'] * portfolio['Symbol Adj Close']</span><span id="69be" class="ns lw it nn b gy nx nu l nv nw">portfolio['Benchmark Share Value'] = portfolio['Equiv Benchmark Shares'] * portfolio['Benchmark Close']</span></pre><p id="35e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将再次做同样的事情来计算货币收益/损失，从我们在<code class="fe nk nl nm nn b">portfolio_start_of_year_stats</code>函数中计算的修改后的调整成本中减去股票价值列:</p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="1ad0" class="ns lw it nn b gy nt nu l nv nw">portfolio['Stock Gain / (Loss)'] = portfolio['Ticker Share Value'] - portfolio['Adj cost']</span><span id="aa38" class="ns lw it nn b gy nx nu l nv nw">portfolio['Benchmark Gain / (Loss)'] = portfolio['Benchmark Share Value'] - portfolio['Adj cost']</span></pre><p id="8875" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们将使用之前计算的基准指标来计算绝对回报值:</p><pre class="kj kk kl km gt no nn np nq aw nr bi"><span id="0fd8" class="ns lw it nn b gy nt nu l nv nw">portfolio['Abs Value Compare'] = portfolio['Ticker Share Value'] - portfolio['Benchmark Start Date Cost']</span><span id="dd7e" class="ns lw it nn b gy nx nu l nv nw">portfolio['Abs Value Return'] = portfolio['Abs Value Compare']/portfolio['Benchmark Start Date Cost']</span><span id="83e8" class="ns lw it nn b gy nx nu l nv nw">portfolio['Abs. Return Compare'] = portfolio['Ticker Return'] - portfolio['Benchmark Return']</span></pre><p id="2529" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嘣！现在，让我们弄清楚如何绘制我们的新数据，并完成这项工作。</p><h2 id="7c07" class="ns lw it bd lx oa ob dn mb oc od dp mf li oe of mh lm og oh mj lq oi oj ml ok bi translated">步骤4 —可视化数据</h2><p id="5d3c" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">那么，现在我们已经经历了所有这些来获得我们的日常性能数据，我们应该如何最好地显示它呢？每日数据的最大好处是可以看到你的头寸在一段时间内的表现<em class="ol"/>，所以让我们先来看看我们的汇总数据。</p><p id="78bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在最近的项目中，我一直在使用Plotly，所以为了做到这一点，我将选择simple并使用<a class="ae ky" href="https://plotly.com/python/plotly-express/" rel="noopener ugc nofollow" target="_blank"> Plotly Express </a>库。由于我们需要将每天的股票汇总到一个单一的每日指标中，我将把它写成一个函数，它采用您完成的数据框架和两个您想要相互对照的指标:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj ni l"/></div></figure><p id="2389" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，我们将提供ticker和基准收益/损失作为指标，然后使用groupby将每日业绩汇总到投资组合级别。画出来应该会返回类似这样的东西！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/b8f57a2f4b204e5c88630b428f37eb73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bL7jsV4EGfpsaK86j7-jHQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">每日累计损益与基准对比</p></figure><p id="7904" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还可以使用不同的指标(如<code class="fe nk nl nm nn b">Abs Value Compare</code>)进行聚合，将其视为一行:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/91a2acbf414ef49b4ae9cdb3aa31040d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*807gTjOhbqiFUCJxvSKl_A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用绝对值比较度量显示</p></figure><p id="a922" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这很棒，但在我看来，最有用的视图可以通过使用plotly express中的<code class="fe nk nl nm nn b">facet_col</code>选项来生成每个股票的图表，将基准与每个股票的性能进行比较:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj ni l"/></div></figure><p id="aaa6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还将使用<code class="fe nk nl nm nn b">facet_col_wrap</code>参数来限制每行的图表数量。运行这段代码应该会生成类似下面的输出！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/f7e22e3e335fb813814ff6738b0e1570.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L0ycfdVT17c42U13hqVuZQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">每只股票的基准回报比较示例数据</p></figure><h1 id="3029" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="c8a0" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们在这里讨论了很多内容，希望这对学习更多关于填充和分析财务数据的知识有所帮助！未来还有很多可以探索的领域，包括:</p><ul class=""><li id="4315" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">考虑分红和股票分割——yfinance有这个数据，但我想在添加更多功能之前先发布这个数据</li><li id="5671" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">加入更多奇异的指标，比如波动性比较和滚动平均。在投资组合层面与基准层面进行比较可能会很有意思</li><li id="3f8d" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">改善可操作性的信号。例如，你可以利用日间数据，观察短期均线何时穿过长期均线，作为潜在买入/卖出头寸的信号</li></ul><p id="ef31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望这对任何人都有帮助，并随时联系或在下面评论问题/评论。感谢阅读！</p></div></div>    
</body>
</html>