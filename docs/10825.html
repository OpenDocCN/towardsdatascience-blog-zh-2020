<html>
<head>
<title>Mining Telecom Product Recommendations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">挖掘电信产品推荐</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/mining-telecom-product-recommendations-cfe455f3e563?source=collection_archive---------30-----------------------#2020-07-28">https://towardsdatascience.com/mining-telecom-product-recommendations-cfe455f3e563?source=collection_archive---------30-----------------------#2020-07-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0b64" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">传统推荐系统在电信行业的应用原则</h2></div><h1 id="fb7a" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">摘要</h1><p id="1393" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在当前信息过载的时代，人们越来越难找到相关内容。推荐系统已经被引入来帮助人们从大量的选择中检索潜在有用的信息。它是一个基于数据分析向用户推荐产品、服务和信息的系统，在解决信息爆炸问题方面变得越来越重要。</p><p id="149d" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">近年来，在为电子商务、电子学习和电子治理中的各种基于网络的应用提供个性化推荐服务的方向上，已经采取了重要的步骤。然而，令人惊讶的是，尽管这一系统是必需的，但至今仍未出现在电信部门。因此，本博客探讨了电信公司对推荐系统的需求，以帮助其客户在线选择最合适的电信计划/产品。博客以开发和实现电信产品/服务的个性化推荐系统作为结尾，从数据中挖掘关联规则，为新客户找到合适的电信产品包/计划/产品。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="2bb9" class="ki kj it bd kk kl mi kn ko kp mj kr ks jz mk ka ku kc ml kd kw kf mm kg ky kz bi translated">介绍</h1><p id="4ff5" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">尽管人工智能(AI)无疑有能力改变电信行业，但它在很大程度上仍是一个新兴领域。然而，我认为电信公司在利用人工智能技术方面处于独特的有利地位，这主要是因为他们已经习惯于处理人工智能和机器学习(ML)所依赖的海量数据。由于这不是一时的时尚，所以电信公司必须与人工智能进行长期博弈，并考虑探索较少的领域，以释放新的收入流。</p><p id="c9d8" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">人工智能和人工智能需要大量的数据才能正常工作，但数据也必须有足够的质量。如果没有适当数量的高质量数据，人工智能或 ML 模型推荐的决策就不太可能准确或成功。</p><blockquote class="mn mo mp"><p id="fa3b" class="la lb mq lc b ld lw ju lf lg lx jx li mr ly ll lm ms lz lp lq mt ma lt lu lv im bi translated">从积极的一面来看，电信公司确实可以访问大量数据，可能比大多数其他行业的公司都要多。然而，困难在于捕获正确的数据集，并以 ML 所需的粒度存储它们。</p></blockquote><p id="5855" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">以传统的方式收集高质量的数据是一回事，但是以特定的方式获取这些数据是另一回事，您可能需要以特定的方式来解决一个用例。如今，大多数电信运营商的网页都有大量的选择，这使得客户越来越难找到自己想要的产品。</p><p id="3e00" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated"><em class="mq">如果同一个网页可以根据现有客户过去的选择，自动向您推荐各种附加产品/捆绑包，您不认为这将非常重要吗？</em></p><h1 id="2586" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">需要电信推荐系统</h1><figure class="mv mw mx my gt mz gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi mu"><img src="../Images/cf2bc980dc07cd88e4266b736b3bda4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eWFFTwN7CSzK_c7lpSstTg.jpeg"/></div></div><p class="ng nh gj gh gi ni nj bd b be z dk translated">将传统推荐系统的概念应用于电信行业(来源-<a class="ae nk" href="https://bit.ly/3f4XhA3" rel="noopener ugc nofollow" target="_blank">https://bit.ly/3f4XhA3</a></p></figure><p id="a8e1" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">可以根据其他用户的选择对推荐系统进行微调，以迎合用户简档/偏好。该系统的优点是通过应用信息过滤算法，基于特定用户的显性和隐性偏好，向他们建议正确的项目(基础计划或附加产品)。我用来实现的算法叫做 Apriori。</p><h2 id="f0e5" class="nl kj it bd kk nm nn dn ko no np dp ks lj nq nr ku ln ns nt kw lr nu nv ky nw bi translated">算法描述</h2><blockquote class="mn mo mp"><p id="6fdc" class="la lb mq lc b ld lw ju lf lg lx jx li mr ly ll lm ms lz lp lq mt ma lt lu lv im bi translated">Apriori 算法——它只是对客户交易数据库的研究，以确定不同计划/产品的购买之间的依赖关系。</p><p id="0839" class="la lb mq lc b ld lw ju lf lg lx jx li mr ly ll lm ms lz lp lq mt ma lt lu lv im bi translated">换句话说，就是“什么配什么”的学问。</p></blockquote><p id="8ea9" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">客户交易的详细信息的可用性导致了自动寻找存储在数据库中的项目之间的关联的技术的发展。示例—网络运营商在其数据库中收集关于每个计划/基础包以及附加产品的客户交易的数据。这种数据库由大量交易记录组成，其中每个记录列出了客户购买的基础计划或附加产品。</p><h1 id="a124" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">实施步骤</h1><h2 id="4d40" class="nl kj it bd kk nm nn dn ko no np dp ks lj nq nr ku ln ns nt kw lr nu nv ky nw bi translated">第一步</h2><p id="83c7" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">通过使用 Python 对客户交易数据执行基本 EDA，很可能会观察到某些基础包/计划比其他包/计划出现得更频繁。因此，作为第一步，显示一个流行的基础包列表是个好主意。假设所有数据都存储在 pandas dataframe 'df '中，我们可以使用下面的代码获得流行的基础包/计划列表。</p><pre class="mv mw mx my gt nx ny nz oa aw ob bi"><span id="8b83" class="nl kj it ny b gy oc od l oe of">df["BASE_PACKAGE_NAME"].value_counts()</span></pre><h2 id="cf0e" class="nl kj it bd kk nm nn dn ko no np dp ks lj nq nr ku ln ns nt kw lr nu nv ky nw bi translated">第二步</h2><p id="3996" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">使用 Python 将这些数据转换成每个记录都列出用户购买的所有商品的表单不会有太大的困难。</p><figure class="mv mw mx my gt mz gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi og"><img src="../Images/642b61a3e26c16d0442dd8a4af75c5b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NwBW-DRPx0hkPdzKqFWXsw.png"/></div></div><p class="ng nh gj gh gi ni nj bd b be z dk translated">客户交易数据库快照</p></figure><blockquote class="mn mo mp"><p id="4f22" class="la lb mq lc b ld lw ju lf lg lx jx li mr ly ll lm ms lz lp lq mt ma lt lu lv im bi translated"><em class="it">在这个阶段，我们想知道</em>某些组的商品是否总是一起购买<em class="it">，这可以在 Apriori 算法的帮助下找到。</em></p></blockquote><pre class="mv mw mx my gt nx ny nz oa aw ob bi"><span id="c33f" class="nl kj it ny b gy oc od l oe of">#Convert the dataframe to a list<br/>records = df.values.tolist()</span><span id="7e99" class="nl kj it ny b gy oh od l oe of">#Generate association rules with required <br/>#minimum support, confidence and lift<br/>from apyori import apriori<br/>association_rules = apriori(records, min_support=0.3346, min_confidence=0.20, min_lift=3, min_length=3)<br/>association_results = list(association_rules)</span></pre><p id="4bd8" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">Apriori 算法中有四个性能指标。这些参数用于排除结果中支持度和置信度分别低于最小支持度、置信度、提升或长度的关联规则。</p><ol class=""><li id="3661" class="oi oj it lc b ld lw lg lx lj ok ln ol lr om lv on oo op oq bi translated"><strong class="lc iu"> min_support </strong> —介于 0 和 1 之间的浮点值；用于选择支持值大于参数中指定值的项目。</li></ol><figure class="mv mw mx my gt mz gh gi paragraph-image"><div class="gh gi or"><img src="../Images/df69b433e833ac8e7d355fef14281de4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*uXeR_efXvoC-1wi5K5UkqQ.png"/></div></figure><p id="2962" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated"><strong class="lc iu"> 2。min_confidence </strong> —介于 0 和 1 之间的浮点值；用于筛选可信度大于参数中指定的可信度阈值的规则。</p><figure class="mv mw mx my gt mz gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi os"><img src="../Images/a5567df8d0f0c7e900b9f3c3aca909f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zZSNarGu5_Qkcl90TXP0sQ.png"/></div></div></figure><p id="59d5" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated"><strong class="lc iu"> 3。min_lift </strong> —指定入围规则的最小提升值。</p><figure class="mv mw mx my gt mz gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi ot"><img src="../Images/0347924388407fbc78868dee3b46f6d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4k-dmhWlDAIkAooxyW5gOQ.png"/></div></div></figure><p id="30c8" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated"><strong class="lc iu"> 4。min_length </strong> —指定希望在关联规则项目集中看到的最小项目数。</p><p id="677d" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">min_support、min_confidence 和 min_lift 参数的最佳值可以通过尝试不同的值并检查它们是否在项集之间产生有效的关联来设置。</p><h2 id="ae48" class="nl kj it bd kk nm nn dn ko no np dp ks lj nq nr ku ln ns nt kw lr nu nv ky nw bi translated">第三步</h2><p id="7896" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">以可理解的格式获取关联规则可能是一个挑战；以下是我如何克服的。请注意，<strong class="lc iu">‘前任’</strong>是在数据中找到的项目，而<strong class="lc iu">‘继任者’</strong>是结合前任找到的项目。</p><pre class="mv mw mx my gt nx ny nz oa aw ob bi"><span id="38dc" class="nl kj it ny b gy oc od l oe of">#Create a dataframe with all the necessary information<br/>df = pd.DataFrame(columns=('Items','Predecessor','Successor','Support','Confidence','Lift'))</span><span id="53a0" class="nl kj it ny b gy oh od l oe of">Support =[]<br/>Confidence = []<br/>Lift = []<br/>Items = []<br/>Predecessor= []<br/>Successor=[]</span><span id="7694" class="nl kj it ny b gy oh od l oe of">for RelationRecord in association_results:<br/>    for ordered_stat in RelationRecord.ordered_statistics:<br/>        Support.append(RelationRecord.support)<br/>        Items.append(RelationRecord.items)<br/>        Predecessor.append(ordered_stat.items_base)<br/>        Successor.append(ordered_stat.items_add)<br/>        Confidence.append(ordered_stat.confidence)<br/>        Lift.append(ordered_stat.lift)</span><span id="b8d7" class="nl kj it ny b gy oh od l oe of">df['Items'] = list(map(set, Items))                                   <br/>df['Predecessor'] = list(map(set, Predecessor))<br/>df['Successor'] = list(map(set, Successor))<br/>df['Support'] = Support<br/>df['Confidence'] = Confidence<br/>df['Lift']= Lift</span><span id="ec4c" class="nl kj it ny b gy oh od l oe of">#Sort the dataframe based on confidence <br/>df.sort_values(by ='Confidence', ascending = False, inplace = True)</span></pre><h2 id="2198" class="nl kj it bd kk nm nn dn ko no np dp ks lj nq nr ku ln ns nt kw lr nu nv ky nw bi translated">第四步</h2><p id="5a48" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果“前任”列值等于客户从流行套餐列表中选择的基础套餐名称，则通过挑选“继任者”列中的项目来提供正确的推荐。</p><pre class="mv mw mx my gt nx ny nz oa aw ob bi"><span id="841b" class="nl kj it ny b gy oc od l oe of">#Picking the records for a particular plan/base_package that has been selected by the customer on the GUI<br/>package_name = "1GB/Day(24 day Validity)"</span><span id="3931" class="nl kj it ny b gy oh od l oe of">index=[]<br/>for key, value in df["Predecessor"].iteritems(): <br/>    if len(value) == 1 and package_name in value:<br/>        print(key,value)<br/>        index.append(key)<br/>        <br/>recommendations = df[df.index.isin(index)]</span></pre><p id="48d4" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">瞧啊。</p><figure class="mv mw mx my gt mz gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi ou"><img src="../Images/19528452169b96badee5e23758150194.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T42_kgTbMucX-qLIYlLd_Q.png"/></div></div><p class="ng nh gj gh gi ni nj bd b be z dk translated">产品推荐列表</p></figure><p id="dd4b" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">请注意，频繁购买百分比是置信度参数的度量，它是由前面提到的 Apriori 算法计算的。</p><figure class="mv mw mx my gt mz gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/c8e565ab18a1ad1549170fd8c63d16b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/1*ddqJQCfEwbRPqDIXq7y8XA.gif"/></div></figure><h1 id="58a4" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">结论和未来工作</h1><p id="5b64" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">作为电信行业的一员，我已经有将近 5 年的时间了，我看到任何人工智能项目都有各种各样的技术和组织问题；这并不奇怪，因为人工智能是一个不切实际的东西，你需要给组织一些有形的东西。因此，从概念到实际项目的飞跃，或者从试点人工智能概念验证项目到实际部署是一个进一步的挑战。这篇博客中描述的关联规则挖掘方法证明了自动化相似性分析的好处，并且在我看来是电信公司的基本业务用例。非常重要的是，要清楚地了解这种投资的成功要素。</p><p id="863d" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">更进一步，上述实现仅限于为通过 web-GUI/kiosk 订阅网络的新客户提供推荐。该模型可以通过在初始阶段添加聚类算法向现有/新客户提供推荐来改进；这将根据年龄、工资、地理数据等对客户进行细分。此外，Apriori 算法的一些缺点是生成的规则太多，并且项目集的罕见组合往往会被忽略，因为它们不满足最低支持要求。使用更健壮的算法将有助于解决这个问题。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><p id="0efd" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated"><em class="mq">感谢您的阅读！</em></p><h1 id="b6e3" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">参考</h1><p id="5c1f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">[1]<a class="ae nk" href="https://www.appliedaicourse.com/" rel="noopener ugc nofollow" target="_blank">https://www.appliedaicourse.com/</a></p><p id="4096" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">[2]电信和人工智能:创造人工智能驱动的电信行业需要什么——2019 年 5 月，由 STL Partners 主办，诺基亚提供支持。</p><p id="a626" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">[3]北京农业信息技术研究中心和北京计算机科学技术学院的研究文章——利用缺失数据提高 Top-𝑁Recommendation 性能。</p><p id="a656" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">[4]研究文章 IEEE Communications Magazine 的预测性电信网络管理的推荐系统架构。</p></div></div>    
</body>
</html>