<html>
<head>
<title>Programming Quantum Information</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">量子信息编程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/programming-quantum-information-8f251ec6770?source=collection_archive---------46-----------------------#2020-05-13">https://towardsdatascience.com/programming-quantum-information-8f251ec6770?source=collection_archive---------46-----------------------#2020-05-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="3e78" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/the-singularity-research" rel="noopener" target="_blank">奇点研究</a></h2><div class=""/><div class=""><h2 id="3a29" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">使用 Python 和 Qiskit 的熵</h2></div><p id="d71f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在本文中，我们要来看看如何使用 Python 和 IBM 的免费开源量子计算软件 Qiskit 来理解量子系统中的<em class="ln">信息</em>和<em class="ln">熵</em>的概念。我们将看看熵的经典版本，以展示它与量子熵或<em class="ln">冯诺依曼熵的关系。我们会提供代码，最后会有一些免费的交互式 Jupyter 笔记本的链接，你可以在你的浏览器中运行，以更好地理解概念。</em></p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi lo"><img src="../Images/c49a0de15f5be641589dd7e1c03ba503.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*5ynkZw7h7k3htnZXRgUe4g.png"/></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">量子电路</p></figure><h2 id="35b4" class="ma mb it bd mc md me dn mf mg mh dp mi la mj mk ml le mm mn mo li mp mq mr iz bi translated">概率分布</h2><p id="cfc6" class="pw-post-body-paragraph kr ks it kt b ku ms kd kw kx mt kg kz la mu lc ld le mv lg lh li mw lk ll lm im bi translated">在信息研究中，我们首先遇到的概念之一是概率分布。<strong class="kt jd">有限概率分布</strong>是一个函数，</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/b59fd2d2dc45dd4afedc886d5b3bd065.png" data-original-src="https://miro.medium.com/v2/resize:fit:348/format:webp/1*KpSalnoZtrXehg5agXfi-g.png"/></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">概率分布</p></figure><p id="8d5c" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">从某个有限集𝑋到区间[0，1]。𝑥2,…,𝑥𝑛} 𝑋={𝑥1 的有限集通常被认为是可能发生的事件的集合，值𝑓(𝑥𝑖)∈[0,1]是𝑥𝑖事件发生的相关概率。函数𝑓必须满足以下条件</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi my"><img src="../Images/d9b2c9b7761aa363cfacc2cb15e60097.png" data-original-src="https://miro.medium.com/v2/resize:fit:412/format:webp/1*Z1r0EY0oun5i3lfD7mpf7w.png"/></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">概率之和必须为 1</p></figure><p id="0b39" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">所以所有的概率总和为 1。举个例子，如果我们有一枚硬币可以抛，我们可以把事件集合定为𝑋={ℎ,𝑡} (" <em class="ln">正面</em>"或"<em class="ln">反面</em>")，概率是𝑓(ℎ)=1/2 和𝑓(𝑡)=1/2.显然𝑓(ℎ)+𝑓(𝑡)=1，所以函数𝑓:𝑋→[0,1]是集合𝑋.上的概率分布如果我们有一个六面骰子，我们可以把事件集合看作是𝑌={1,2,3,4,5,6}，概率是</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/d382aa62bd63b0974cc2a293c52b02c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:556/format:webp/1*0UPnGbDkigjuttYmkscS9Q.png"/></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">六面骰子的概率</p></figure><p id="afcc" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">函数𝑔:𝑌→[0,1]也是一个概率分布(在事件集𝑌).上现在，我们可以有<strong class="kt jd">联合概率分布</strong>，它是由像(𝑓×𝑔):𝑋×𝑌→[0,1].)这样的函数描述的在这种情况下，我们可以写出概率表</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi na"><img src="../Images/83231630fe992c2699be4082cd1ae4a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/1*Qlk0it9eVnJbhDM8u27fVg.png"/></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">联合概率分布</p></figure><p id="261d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在这种情况下，𝑋X 组的结果与𝑌Y.组的结果在本质上是独立的。掷硬币对掷骰子没有影响，掷骰子对掷硬币也没有影响。然而情况并非总是如此。有时我们有相互依赖的联合概率。在这种情况下，我们有<strong class="kt jd">条件概率</strong>，其中𝑦∈𝑌事件发生的概率取决于𝑥∈𝑋.事件</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h2 id="d895" class="ma mb it bd mc md me dn mf mg mh dp mi la mj mk ml le mm mn mo li mp mq mr iz bi translated">香农熵</h2><p id="d550" class="pw-post-body-paragraph kr ks it kt b ku ms kd kw kx mt kg kz la mu lc ld le mv lg lh li mw lk ll lm im bi translated">在教科书中，可能发生的𝑋X 事件集通常被称为随机变量<strong class="kt jd"/>。<strong class="kt jd">香农熵</strong>给出了我们通过学习随机变量的值平均获得多少信息的精确定义。𝑋的<strong class="kt jd">熵</strong>定义了在得知结果值之前，我们对𝑋的不确定性。因此，假设我们有一些有限的事件集(或随机变量)𝑋={𝑥1,…,𝑥𝑛}，相关的概率分布𝑓:𝑋→[0,1]取值{𝑓(𝑥1),…,𝑓(𝑥𝑛)}.香农熵定义为</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/f4075ac4d05f84da4800a074d58d62ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:954/format:webp/1*Hzlqw6LLU2UNAobpIXMotQ.png"/></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">香农熵</p></figure><p id="b85c" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这里，对数以 2 为底。每个概率都是一个 0≤𝑓(𝑥𝑖)≤1.值让我们来看看抛硬币的例子。在这种情况下，香农熵就是</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/3c6e20bf2105f29ff50a94224e3c476a.png" data-original-src="https://miro.medium.com/v2/resize:fit:758/format:webp/1*WlNr0GqpJDO9y0vi7pqK3Q.png"/></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">抛硬币的香农熵</p></figure><p id="6dca" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在，让我们看看六面骰子的情况。这种情况下的香农熵为</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/76cab64b1b21374f5fd6d734129454aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:620/format:webp/1*1ac9aC7dLa3ehck6fyyz7g.png"/></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">六面模具的香农熵</p></figure><p id="b76d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">为了计算这一点(以及其他)，让我们用 Python 导入一些东西。首先，运行以下命令导入必要的库。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/9909bbdad4d02a183f032adfe084026c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/format:webp/1*LrbApPwLFwWI63N-fnpB-w.png"/></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">Python 导入</p></figure><p id="20ea" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们可以很容易地在 Python 中得到-log(1/6)的十进制近似值，如下所示。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/c696b1790a69006a564d1a5b3d382cf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*oJRBjAhbuTPkljQSplrVPw.png"/></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">Python 中的计算日志(1/6)</p></figure><p id="24dd" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">作为另一个例子，让我们以随机变量𝑋为例，它可以取值{𝑥1,𝑥2,𝑥3,𝑥4}.设相关的概率分布为</p><p id="92ae" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">{𝑓(𝑥1)=1/8, 𝑓(𝑥2)=1/4, 𝑓(𝑥3)=1/8, 𝑓(𝑥4)=1/2}.让我们用 Python 来定义这些概率。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="no np di nq bf nr"><div class="gh gi nn"><img src="../Images/c25d428a430c7553c99e2bdf98d0cd4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dWuyAFoSUOFI_VvO5tRQeQ.png"/></div></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">用 Python 定义概率</p></figure><p id="2be8" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在，让我们计算香农熵。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="no np di nq bf nr"><div class="gh gi ns"><img src="../Images/c997bb1565f66eae008bfeffbe3b0dd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kPokbibj6im_DVN_iJnWvw.png"/></div></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">X 的香农熵</p></figure><h2 id="37ef" class="ma mb it bd mc md me dn mf mg mh dp mi la mj mk ml le mm mn mo li mp mq mr iz bi translated">冯·诺依曼熵</h2><p id="c924" class="pw-post-body-paragraph kr ks it kt b ku ms kd kw kx mt kg kz la mu lc ld le mv lg lh li mw lk ll lm im bi translated">香农熵测量与经典概率分布相关的不确定性。我们在之前的笔记本中讨论过密度算子。回想一下，密度算符是一种描述量子系统可能状态的方式，或者等效地说，是一种描述可能测量结果的方式，与概率分布非常相似。量子态ρ(其中ρ是密度矩阵)的<strong class="kt jd">冯诺依曼熵</strong>定义为</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/41b517c51078e2e2ca0ca86618d2ae62.png" data-original-src="https://miro.medium.com/v2/resize:fit:514/format:webp/1*lnzxjEB0qrNbKvb_KQoUDw.png"/></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">冯·诺依曼熵</p></figure><p id="f02e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这里的对数现在是一个<em class="ln">矩阵对数</em>，也取为底数 2。如果我们让{𝜆𝑘}是矩阵ρ的<em class="ln">特征值</em>的全集，那么我们也可以将冯诺依曼熵定义为</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/040e7dc56b472ca2aef9af6e15ba0d46.png" data-original-src="https://miro.medium.com/v2/resize:fit:520/format:webp/1*7g8vkPmPQ7LZ7j6OKbLehg.png"/></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">冯·诺依曼熵</p></figure><p id="cd64" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">使用<code class="fe nv nw nx ny b">scipy.linalg.logm()</code>可以在 Python 中计算矩阵对数。我们已经从 SciPy 导入了<code class="fe nv nw nx ny b">linalg</code>作为<code class="fe nv nw nx ny b">la</code>。让我们看一个例子。拿着矩阵</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/1c779b2b1abb7c584ba3a794b5576d42.png" data-original-src="https://miro.medium.com/v2/resize:fit:520/format:webp/1*YpeGZkcX21NshLCskf_q5g.png"/></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">密度矩阵</p></figure><p id="7777" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在 Python 中，我们可以使用下面的代码来定义密度矩阵，</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/749960fc41963e51ca2a79af04662222.png" data-original-src="https://miro.medium.com/v2/resize:fit:930/format:webp/1*_W8G7kqK6N3byO24EMTnHw.png"/></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">Python 中的密度矩阵</p></figure><p id="f3cb" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">为了得到合适的基数 2，我们需要使用一个转换，</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/9f37d3f34b86973466209c5dc0a1fbbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:464/format:webp/1*__15wlUA8gbqbG7c3JL4Xg.png"/></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">对数的底数变化</p></figure><p id="873f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">所以，我们真正需要的是，</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/6000a3e045d3ac48f5ecbd0986012a3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:892/format:webp/1*A7aJIsKHDdpVi3fCkzrZXA.png"/></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">矩阵对数</p></figure><p id="92a0" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们可以使用这个矩阵的迹来计算冯·诺依曼熵，如下所示，</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/87d5153c5183278f3b72b0292d0967bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*FgkT7bucx1Z73rXL8IvGcw.png"/></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">冯·诺依曼熵</p></figure><p id="c936" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">正如所料，这是一个 1×1 矩阵，即标量值。让我们为密度矩阵定义一个计算冯·诺依曼熵的函数。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi od"><img src="../Images/a1421f84774c4a9ea32dd0604697984f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/format:webp/1*q4mUwlrXVjpMpgxAF-QppA.png"/></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">Python 中的冯诺依曼熵函数</p></figure><p id="75e1" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在，让我们在矩阵<code class="fe nv nw nx ny b">rho</code>上测试这个函数。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/3991be17230330075b2cecaa2282f090.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*XSuuWLQ3hUHk1nCbThUa4A.png"/></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">测试功能</p></figure><h2 id="87dc" class="ma mb it bd mc md me dn mf mg mh dp mi la mj mk ml le mm mn mo li mp mq mr iz bi translated">状态演化</h2><p id="ceed" class="pw-post-body-paragraph kr ks it kt b ku ms kd kw kx mt kg kz la mu lc ld le mv lg lh li mw lk ll lm im bi translated">在量子物理学中，状态很少保持不变。在量子计算的电路和门模型中，状态根据酉矩阵运算演化，状态向量的演化相当于线性代数。在其他模型中，我们可以使用哈密顿量来模拟状态的演化。有两种重要的状态叫做混合态和纯态。纯状态总是可以表示为状态向量与其自身的“外积”。混合状态通常表示为正交状态向量的和。在纯态的情况下，冯·诺依曼熵总是零。在混合态的情况下，熵可以是整个范围的值。让我们看一个例子，一个系统从纯态演化到混合态，然后又回到纯态。我们将看到冯·诺依曼熵逐渐增大，然后减小回到零。首先，我们来定义自旋向上和自旋向下的状态向量，以及外积给出的纯态。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi of"><img src="../Images/e5d5887aad536d0d388c0addb171c5b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/format:webp/1*yBOWP1CHDvhuCL3KUDPgbA.png"/></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">定义纯态</p></figure><p id="6885" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们可以使用下面的代码来绘制进化图，</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi og"><img src="../Images/de07b1aa07e8557d40cc77ee5ce6da7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*bWRo-eHqde4WoGQWdKJGOA.png"/></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">情节演变</p></figure><p id="cded" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们得到的图表如下，</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/21f4edd4d7acd585411bc82c2127c8a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*fD7XToCQFB0-CugNUpbGaw.png"/></div></figure><p id="dee6" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们可以将其与经典的香农熵进行比较</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/bd46df758b587fe31e98705c11cb317f.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/format:webp/1*jdnsD1L3Yk2pzxppf2JziQ.png"/></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">香农熵</p></figure><p id="671e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">看到它们实际上是一样的。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/ce23357f04b10ec278f25eb4694c0b00.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*YkEe1GLS5LO6_kkNPEb6tQ.png"/></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">香农熵图</p></figure><h2 id="b15f" class="ma mb it bd mc md me dn mf mg mh dp mi la mj mk ml le mm mn mo li mp mq mr iz bi translated">使用 Qiskit</h2><p id="cd86" class="pw-post-body-paragraph kr ks it kt b ku ms kd kw kx mt kg kz la mu lc ld le mv lg lh li mw lk ll lm im bi translated">在 Qiskit 中，我们可以对下面的量子电路进行编程，</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/6a6086284417b9701cb1f48acdab6e13.png" data-original-src="https://miro.medium.com/v2/resize:fit:618/format:webp/1*X-KGJVKNtpZKCL6ZUyOmUg.png"/></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">GHZ 状态</p></figure><p id="72a3" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">接下来，我们可以使用 Qiskti 的<code class="fe nv nw nx ny b">Statevector()</code>函数来打印状态向量。这将有助于使用 Qiskit 中的函数<code class="fe nv nw nx ny b">entropy()</code>计算相应密度矩阵的冯诺依曼熵。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/3a2401cc514c7130e598f4dc993859e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/format:webp/1*xjZTjmEaXOynRHkQYmIXqg.png"/></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">状态向量</p></figure><p id="7cd3" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">接下来，我们使用 Qiskit 的<code class="fe nv nw nx ny b">DensityMatrix()</code>函数，将上面定义的<code class="fe nv nw nx ny b">GHZ_state</code> ket-vector 传递给它。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi om"><img src="../Images/973ae4d0ba5bc975ec0535db3eb7010e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*O4Glv59hPLHqaIpDWqCVyw.png"/></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">Qiskit 中的密度矩阵</p></figure><p id="27e5" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在我们可以使用 Qiskit <code class="fe nv nw nx ny b">entropy()</code>函数来计算熵。我们可以通过<code class="fe nv nw nx ny b">Statevector</code>或<code class="fe nv nw nx ny b">DensityMatrix</code>。在第二种情况下，我们得到有效的零熵，在第一种情况下，我们得到精确的零熵。这是有意义的，因为态是纯态，密度矩阵是按𝐷=|𝜓⟩⟨𝜓|.计算的</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi on"><img src="../Images/337d29f50dfc33f46f859d32aa0ce533.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/format:webp/1*oDWXNhycS4_5algFyoMefQ.png"/></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">齐斯基特中的冯·诺依曼熵</p></figure><p id="a419" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">最后，让我们使用 Qiskit 函数<code class="fe nv nw nx ny b">random_density_matrix()</code>生成一个随机密度矩阵𝜌ρ。该函数的第一个参数是所需密度矩阵的维数，它不必是 2 的幂。然而，在具有量子位的量子电路的情况下，我们手动做出这种限制是很重要的。当然还有更一般的系统，包括像“<em class="ln"> qudits </em>这样的东西，它们可能产生任意维的密度矩阵。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/aa5163972a82fc92c18c2526150c13d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*QiyBWn3yBU0mLR0IEu__KA.png"/></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">随机密度矩阵</p></figure><p id="75a0" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们可以使用 Qiskit <code class="fe nv nw nx ny b">entropy()</code>函数来计算熵。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi op"><img src="../Images/50ba44c32bce1d9c9e522816f75ee781.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/1*3oN7529BsUkn2s68KoLBtg.png"/></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">冯·诺依曼熵</p></figure><p id="5a7a" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">让我们画出从 GHZ 态的密度矩阵𝐷给出的态演化到密度矩阵ρ描述的系统的熵。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/85cc86fda636d6749f4a9f1c1c8cba76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/format:webp/1*vtpZfhWLYgkCwrhJ0yidUQ.png"/></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">绘图熵</p></figure><p id="061b" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们得到的情节是，</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/af40d7fdb96d1ab8341e579190cbfcc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*Dvlk-RtJy1i51X1YUbRalQ.png"/></div></figure><p id="dd26" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">如果你想了解更多，<a class="ae or" href="https://github.com/sponsors/The-Singularity-Research?preview=true" rel="noopener ugc nofollow" target="_blank">可以考虑支持 Github </a>。有超过 20 个免费的，关于量子计算和量子机器学习的交互式笔记本，你可以在你的浏览器中运行。有关熵的笔记本请点击<a class="ae or" href="https://github.com/The-Singularity-Research/entropy" rel="noopener ugc nofollow" target="_blank">链接</a>。如果你想为这个项目做贡献，或者如果你需要在你正在做的事情中加入量子计算方面的咨询，请联系</p><p id="ce60" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">thesingularity.research@gmail.com</p><p id="8e01" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">一定要包括“黑客宇宙”这个主题，这样邮件才不会丢失。</p></div></div>    
</body>
</html>