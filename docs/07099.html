<html>
<head>
<title>Using BigQuery, Firebase Analytics to engage, attract and assess your App users</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用BigQuery、Firebase Analytics来吸引、吸引和评估您的应用用户</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/using-bigquery-firebase-analytics-to-engage-attract-and-assess-your-app-users-da02980daffa?source=collection_archive---------30-----------------------#2020-05-31">https://towardsdatascience.com/using-bigquery-firebase-analytics-to-engage-attract-and-assess-your-app-users-da02980daffa?source=collection_archive---------30-----------------------#2020-05-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0ce6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">处理点击流数据时的有用提示和重要转换，以及强大的查询示例。</h2></div><h1 id="8b16" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">什么是Firebase Analytics？</h1><p id="7ba3" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">你开发了一个令人惊叹的应用程序，但是你如何知道用户是否以正确的方式使用它，或者他们对应用程序的哪些部分更感兴趣？Firebase Analytics是记录用户分析的最好的免费库之一。无论你的应用是用于Web、iOS、Android，甚至是Flutter，<a class="ae lw" href="https://firebase.google.com/docs/analytics" rel="noopener ugc nofollow" target="_blank"> Firebase Analytics </a>都可以与之集成。一旦集成了分析库，您需要记录您感兴趣的所有事件以及特定于该事件的任何参数，如<em class="lx"> app_purchase </em>(购买金额)、<em class="lx"> audio_play </em>(音频id)等。默认情况下，Firebase向您显示许多不同的图表来解释您正在记录的事件。如果您想进行更多的定制分析，您可以在firebase仪表板中将您的firebase analytics链接到BigQuery。BigQuery将包含所有的原始数据事件，您可以处理它们来进行更复杂的分析。本文详细说明了如何…..</p><h1 id="c63e" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">这篇文章是给你的，如果…</h1><p id="06f9" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">您刚刚创建并启动了您的移动应用程序(或网站),现在您有兴趣知道如何查询Firebase在我们说话时每秒钟为您处理的庞大数据集。或者您只是好奇，想知道对点击流事件数据的一些有用查询，这些查询可以为您提供一些可操作的见解。无论如何，荣誉和欢迎教程。今天，我们将讨论使用Google BigQuery的技巧、诀窍和更多内容。我们开始吧！</p><h1 id="f71a" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">云控制台中的BigQuery Web UI</h1><p id="0d3b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">一旦将firebase analytics链接到BigQuery，您的控制台应该是这样的。我将在这个屏幕上提到几个我日常使用的项目:</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi ly"><img src="../Images/759d9f28cdd4f3cf37e60ca8ae27bebe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zII-LXIgBg51l6dmRkuCrA.png"/></div></div></figure><ul class=""><li id="d999" class="mk ml it lc b ld mm lg mn lj mo ln mp lr mq lv mr ms mt mu bi translated">查询编辑器:可以把它想象成我们写查询的黑板。</li><li id="e6bd" class="mk ml it lc b ld mv lg mw lj mx ln my lr mz lv mr ms mt mu bi translated">保存查询按钮:保存重要查询以供将来参考的按钮。</li><li id="8086" class="mk ml it lc b ld mv lg mw lj mx ln my lr mz lv mr ms mt mu bi translated">保存的查询:这是我们将要使用save query按钮保存的所有查询的主页。</li><li id="fb73" class="mk ml it lc b ld mv lg mw lj mx ln my lr mz lv mr ms mt mu bi translated">查询历史:它存储您过去运行过的所有查询(当您想要重用查询时很有用)。</li></ul><p id="47aa" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj na ll lm ln nb lp lq lr nc lt lu lv im bi translated">既然我们已经理解了基本的布局，让我们直接进入一些有用的查询。</p><h1 id="4436" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">日期时间格式</h1><p id="d24c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">Firebase擅长跟踪你的应用程序或网站的每次点击的大量<em class="lx">事件</em>数据。例如，关于应用首次打开的时间、应用最后更新的时间、应用内购买的时间等信息。这意味着与这些事件相关联的时间和日期对于提供洞察力非常有用。默认情况下，Firebase将事件的日期和时间记录为列<em class="lx"> event_timestamp </em>中的一个<em class="lx">整数</em>。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/c1a79ebc8b72ca7a4caadec307971e73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*Ej2reQ43H8xURg52DrUrpg.png"/></div></figure><p id="0d0a" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj na ll lm ln nb lp lq lr nc lt lu lv im bi translated">这个整数基本上是客户端记录事件的时间(以微秒计，UTC)。使用<code class="fe ne nf ng nh b">FORMAT_DATE</code> &amp; <code class="fe ne nf ng nh b">FORMAT_TIME</code>将这个整数转换成两个独立的(人类可读的)日期和时间列可能很有吸引力:</p><pre class="lz ma mb mc gt ni nh nj nk aw nl bi"><span id="b158" class="nm kj it nh b gy nn no l np nq">SELECT <br/>FORMAT_DATE('%d-%m-%Y', PARSE_DATE('%Y%m%d', event_date)) AS date, <br/>FORMAT_TIME('%T', TIME(TIMESTAMP_MICROS(event_timestamp))) AS time<br/>FROM <!-- -->analytics_xxxxxxxxx.events_*</span></pre><p id="e947" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj na ll lm ln nb lp lq lr nc lt lu lv im bi translated">这给出了以下简洁的输出:</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/83f25f05a40f32e4d44be7cb1d3eba30.png" data-original-src="https://miro.medium.com/v2/resize:fit:380/format:webp/1*LIYPMnaX3qlJ_oZMrfBJyA.png"/></div></figure><p id="fa00" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj na ll lm ln nb lp lq lr nc lt lu lv im bi translated">如果您的最终目标是向您的同事或其他利益相关者展示这两个专栏，这种格式应该很适合您。</p><p id="da68" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj na ll lm ln nb lp lq lr nc lt lu lv im bi translated">但是，您可能会使用事件日志文件中的日期和时间列对数据集进行大量转换。在那种情况下，<code class="fe ne nf ng nh b">FORMAT_DATE</code>将不会是最有效的转换。这是因为它返回的输出是类型为<em class="lx"> string </em>的，而BigQuery支持的大多数日期和时间函数(比如添加两个日期，将日期截断到特定的粒度)要求日期是date或DATETIME格式。</p><p id="bd24" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj na ll lm ln nb lp lq lr nc lt lu lv im bi translated">在这种情况下，我喜欢使用<code class="fe ne nf ng nh b">TIMESTAMP_MICROS</code>函数从event_timestamp中提取日期和时间，然后使用<code class="fe ne nf ng nh b">CAST AS DATETIME</code>将这个时间戳转换为DATETIME对象:</p><pre class="lz ma mb mc gt ni nh nj nk aw nl bi"><span id="736c" class="nm kj it nh b gy nn no l np nq">SELECT<br/>  CAST(TIMESTAMP_MICROS(event_timestamp) AS DATETIME) As UTC_Time <br/>FROM <!-- -->analytics_xxxxxxxxx.events_*</span></pre><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/a972b6f9d28aea8342a2d01ff547e11a.png" data-original-src="https://miro.medium.com/v2/resize:fit:452/format:webp/1*SbgsrefpcRiAu4ZzYydvFA.png"/></div><p class="nt nu gj gh gi nv nw bd b be z dk translated">注意:默认情况下，存储的时间是UTC时区</p></figure><p id="69d5" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj na ll lm ln nb lp lq lr nc lt lu lv im bi translated">与存储在<em class="lx"> event_timestamp </em>列中的整数相比，这种格式更加清晰。同时，我们设法保留了DATETIME格式，这样任何日期或时间转换仍然是可能的。我们在下面的例子中演示了这种格式的一种用法。</p><h2 id="0428" class="nm kj it bd kk nx ny dn ko nz oa dp ks lj ob oc ku ln od oe kw lr of og ky oh bi translated">将UTC时间转换为本地时间</h2><p id="0b85" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">UTC是Firebase用来存储与事件相关的日期和时间的默认时区。事件数据库中还记录了另一个名为<em class="lx">‘time _ zone _ offset _ seconds’</em>的功能，该功能以秒为单位存储与GMT的偏差(根据国家的不同，可能为正值或负值)。因此，将这个偏移量加到任何给定的UTC时间上，就会得到正确的本地时间。</p><p id="7d78" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj na ll lm ln nb lp lq lr nc lt lu lv im bi translated">以下是使用CTE(通用表表达式)计算本地时间的查询。它首先检查偏移量是否为空，在这种情况下，我们将UTC时间设置为本地时间。在非空偏移的情况下，我们首先将偏移秒转换为小时，并使用<code class="fe ne nf ng nh b">DATETIME_ADD</code>将其添加到UTC日期:</p><pre class="lz ma mb mc gt ni nh nj nk aw nl bi"><span id="4a02" class="nm kj it nh b gy nn no l np nq"><strong class="nh iu">WITH CTE AS (</strong><br/>SELECT *,<br/> CAST(TIMESTAMP_MICROS(event_timestamp) AS DATETIME) As UTC_Time,<br/> device.time_zone_offset_seconds AS offset_seconds,<br/>FROM analytics_xxxxxxxxx.events_*<br/><strong class="nh iu">)</strong></span><span id="5f1c" class="nm kj it nh b gy oi no l np nq"><strong class="nh iu">SELECT UTC_Time, offset_seconds,<br/>CASE<br/>WHEN offset_seconds is NULL then UTC_Time<br/>ELSE DATETIME_ADD(<br/>UTC_Time, INTERVAL CAST(offset_seconds/3600 AS INT64) HOUR)<br/>END As local_time<br/>FROM CTE</strong></span></pre><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/3e45ea1aa4f9b5f4132b823df9510579.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*y0HviDdx3U-PeCJiHkBebg.png"/></div></figure><p id="5abe" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj na ll lm ln nb lp lq lr nc lt lu lv im bi translated">老实说，我对我的数据库中的空偏移量感到很困扰(天哪，有很多！).因此，我决定通过检查Firebase存储的<em class="lx"> geo.country </em>列中的国家来手工编码偏移时间，从而解决<em class="lx">其中的一些问题。</em></p><p id="5a57" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj na ll lm ln nb lp lq lr nc lt lu lv im bi translated">因此，将上面的查询更新为:</p><pre class="lz ma mb mc gt ni nh nj nk aw nl bi"><span id="a3c9" class="nm kj it nh b gy nn no l np nq"><strong class="nh iu">WITH CTE AS (</strong><br/>SELECT *,<br/>  CAST(TIMESTAMP_MICROS(event_timestamp) AS DATETIME) As UTC_Time,<br/>  device.time_zone_offset_seconds AS offset_seconds,<br/>FROM analytics_xxxxxxxxx.events_*<br/><strong class="nh iu">)</strong><br/><br/><strong class="nh iu">SELECT *, <br/>CASE<br/>  WHEN offset_seconds IS NULL AND geo.country IN ('India', 'Pakistan') THEN DATETIME_ADD(UTC_Time, INTERVAL CAST(5.5 AS INT64) HOUR) <br/>  WHEN offset_seconds IS NULL AND geo.country = 'United States' THEN DATETIME_SUB(UTC_Time, INTERVAL CAST(5 AS INT64) HOUR) <br/>  WHEN offset_seconds IS NULL AND geo.country = 'Australia' THEN DATETIME_ADD(UTC_Time, INTERVAL CAST(10 AS INT64) HOUR) <br/>  WHEN offset_seconds IS NULL AND geo.country = 'Canada' THEN DATETIME_SUB(UTC_Time, INTERVAL CAST(5 AS INT64) HOUR) <br/>  WHEN offset_seconds IS NULL AND geo.country = 'China' THEN DATETIME_ADD(UTC_Time, INTERVAL CAST(8 AS INT64) HOUR) <br/>  WHEN offset_seconds IS NULL AND geo.country IN ('France', 'Spain', 'Germany', 'Sweden', 'Italy', 'Sweden', 'United Kingdom', 'Ireland') THEN DATETIME_ADD(UTC_Time, INTERVAL CAST(1 AS INT64) HOUR) <br/>  WHEN offset_seconds IS NOT NULL THEN DATETIME_ADD(UTC_Time, INTERVAL CAST(IFNULL(offset_seconds,0)/3600 AS INT64) HOUR) <br/>  ELSE UTC_time<br/>END As local_time<br/>FROM CTE</strong></span></pre><p id="09e6" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj na ll lm ln nb lp lq lr nc lt lu lv im bi translated">唷，这看起来好多了！我们已经设法修复了一些主流国家的时间，这些国家在应用程序上注册了大量的流量。</p><p id="6759" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj na ll lm ln nb lp lq lr nc lt lu lv im bi translated">附注:我使用的时差并不准确，例如，加拿大作为一个国家，在西部和东部观察不同的时区，但为了本教程的目的，我采取了更简单的方法。</p><h2 id="2623" class="nm kj it bd kk nx ny dn ko nz oa dp ks lj ob oc ku ln od oe kw lr of og ky oh bi translated">对本地时间进行转换，以提取星期几、工作日名称和时间</h2><p id="d80b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">一旦我们计算出了本地时间，我们就可以通过引入进一步的转换来更进一步。包含上述所有代码的最终查询如下所示:</p><pre class="lz ma mb mc gt ni nh nj nk aw nl bi"><span id="0b71" class="nm kj it nh b gy nn no l np nq">WITH CTE AS (<br/>SELECT *,<br/>  CAST(TIMESTAMP_MICROS(event_timestamp) AS DATETIME) As UTC_Time,<br/>  device.time_zone_offset_seconds AS offset_seconds,<br/>FROM analytics_xxxxxxxxx.events_*<br/>),</span><span id="a5d1" class="nm kj it nh b gy oi no l np nq"><strong class="nh iu">CTE2 AS (</strong><br/>SELECT *, <br/>CASE<br/>  WHEN offset_seconds IS NULL AND geo.country IN ('India', 'Pakistan') THEN DATETIME_ADD(UTC_Time, INTERVAL CAST(5.5 AS INT64) HOUR) <br/>  WHEN offset_seconds IS NULL AND geo.country = 'United States' THEN DATETIME_SUB(UTC_Time, INTERVAL CAST(5 AS INT64) HOUR) <br/>  WHEN offset_seconds IS NULL AND geo.country = 'Australia' THEN DATETIME_ADD(UTC_Time, INTERVAL CAST(10 AS INT64) HOUR) <br/>  WHEN offset_seconds IS NULL AND geo.country = 'Canada' THEN DATETIME_SUB(UTC_Time, INTERVAL CAST(5 AS INT64) HOUR) <br/>  WHEN offset_seconds IS NULL AND geo.country = 'China' THEN DATETIME_ADD(UTC_Time, INTERVAL CAST(8 AS INT64) HOUR) <br/>  WHEN offset_seconds IS NULL AND geo.country IN ('France', 'Spain', 'Germany', 'Sweden', 'Italy', 'Sweden', 'United Kingdom', 'Ireland') THEN DATETIME_ADD(UTC_Time, INTERVAL CAST(1 AS INT64) HOUR) <br/>  WHEN offset_seconds IS NOT NULL THEN DATETIME_ADD(UTC_Time, INTERVAL CAST(IFNULL(offset_seconds,0)/3600 AS INT64) HOUR) <br/>  ELSE UTC_time<br/>END As local_time<br/>FROM CTE<br/><strong class="nh iu">)</strong></span><span id="54ad" class="nm kj it nh b gy oi no l np nq"><strong class="nh iu">SELECT <br/>DATE(local_time) as date, -- returns a DATE<br/>EXTRACT(DAYOFWEEK FROM DATE(local_time)) as day_of_Week, <br/>FORMAT_DATE('%a', DATE(local_time)) as weekday_name,<br/>TIME(local_time) as time, -- returns a TIME<br/>CASE<br/>  WHEN TIME(local_time) BETWEEN '06:00:00' AND '11:00:00' THEN 'Morning'<br/>  WHEN TIME(local_time) BETWEEN '11:00:00' AND '16:00:00' THEN 'Afternoon'<br/>  WHEN TIME(local_time) BETWEEN '16:00:00' AND '19:00:00' THEN 'Evening'<br/>  WHEN TIME(local_time) BETWEEN '19:00:00' AND '23:59:00' THEN 'Night'<br/>  ELSE 'LateNight'<br/>END AS time_of_day<br/>from CTE2</strong></span></pre><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/8a4670d6e86a7c0d9cf0e840b43a6451.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*Eh6eoVTqoG_Wz4QaFi_t3g.png"/></div></figure><p id="de6c" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj na ll lm ln nb lp lq lr nc lt lu lv im bi translated">注意:<code class="fe ne nf ng nh b">day_of_Week</code>是星期日=1的数字；星期一=2，以此类推。</p><p id="767e" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj na ll lm ln nb lp lq lr nc lt lu lv im bi translated">这些本地时间的转换对于评估你的应用用户何时最活跃，或者一周中的哪一天向他们发送应用内购买营销电子邮件是有意义的，是非常强大的。</p><h1 id="4146" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">为推荐系统准备数据</h1><p id="ba31" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">推荐系统基于用户的显式(例如:评级)和隐式(例如:花费的时间)偏好、其他用户的偏好以及用户和项目属性来建议用户感兴趣的项目。在最基本的层面上，为您的应用程序构建任何此类建议所需的数据框需要三列:user_id、item_id和rating。让我们看看如何从数据库中查询它。</p><p id="64c9" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj na ll lm ln nb lp lq lr nc lt lu lv im bi translated">我已经做了几个星期的播客数据集了(感谢我的朋友，他一直在做一个神奇的播客应用程序，叫做<a class="ae lw" href="https://podurama.com/" rel="noopener ugc nofollow" target="_blank">Podurama</a>——可以在Android和iOS上使用)；我记录了一个名为<em class="lx"> logReview </em>的自定义事件。每当有人试图对应用程序上的播客进行评级并记录四条主要信息(以及其他信息)时，就会触发该事件:</p><ul class=""><li id="c2e2" class="mk ml it lc b ld mm lg mn lj mo ln mp lr mq lv mr ms mt mu bi translated"><em class="lx">收藏Id </em>:播客Id</li><li id="a12c" class="mk ml it lc b ld mv lg mw lj mx ln my lr mz lv mr ms mt mu bi translated"><em class="lx"> guid </em>:剧集id</li><li id="28ee" class="mk ml it lc b ld mv lg mw lj mx ln my lr mz lv mr ms mt mu bi translated"><em class="lx">评级:1到5之间的整数</em></li><li id="13fd" class="mk ml it lc b ld mv lg mw lj mx ln my lr mz lv mr ms mt mu bi translated"><em class="lx">交互类型</em> : 0-删除；1-创建；2-编辑</li></ul><p id="a186" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj na ll lm ln nb lp lq lr nc lt lu lv im bi translated">对于单个用户，该事件的行看起来是这样的:</p><pre class="lz ma mb mc gt ni nh nj nk aw nl bi"><span id="fb46" class="nm kj it nh b gy nn no l np nq">SELECT user_pseudo_id, event_name, event_params<br/>FROM analytics_xxxxxxxxx.events_*<br/>WHERE event_name LIKE '%logReview%'</span></pre><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi ol"><img src="../Images/27448d702e3b121d4ae62a163ace736f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Om8i_3Zd6oEyamwLp4S9fw.png"/></div></div></figure><p id="76d6" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj na ll lm ln nb lp lq lr nc lt lu lv im bi translated">我知道这看起来很吓人，但请耐心听我解释发生了什么。这些事件参数(比如<em class="lx"> rating </em>、<em class="lx"> guid </em>)并没有一个唯一的行，而是被分组到某种具有唯一键值对的JSON对象中。我可以解释得更详细，但没有什么能比得上托德·克佩尔曼的精彩解释。</p><p id="27f2" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj na ll lm ln nb lp lq lr nc lt lu lv im bi translated">底线是我们可以使用下面的查询中的<code class="fe ne nf ng nh b">UNNEST</code>只提取我们感兴趣的事件参数。再次向托德大声欢呼，感谢他为我节省了这么多时间，并在这个帖子中解释得如此漂亮。</p><pre class="lz ma mb mc gt ni nh nj nk aw nl bi"><span id="3506" class="nm kj it nh b gy nn no l np nq">SELECT user_pseudo_id,<br/>(SELECT value.int_value<br/>FROM UNNEST(event_params) WHERE key = 'rating'<br/>) AS rating<br/>FROM analytics_xxxxxxxxx.events_*<br/>WHERE event_name LIKE '%logReview%'</span></pre><p id="34c9" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj na ll lm ln nb lp lq lr nc lt lu lv im bi translated">我们在这里所做的是告诉BigQuery让<code class="fe ne nf ng nh b">unnest</code>或<em class="lx">将</em>和<em class="lx"> event_params </em>分开到单独的行中，并且只从那些<code class="fe ne nf ng nh b">key = rating</code> <em class="lx">所在的行中选取<code class="fe ne nf ng nh b">int_value</code>。</em></p><p id="0d9d" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj na ll lm ln nb lp lq lr nc lt lu lv im bi translated">输出如下所示:</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/de65a92dcf3987e897d6fcaaefb15fe3.png" data-original-src="https://miro.medium.com/v2/resize:fit:686/format:webp/1*UT56pu_9OaJ-8w1ljTJlLw.png"/></div></figure><p id="2e1d" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj na ll lm ln nb lp lq lr nc lt lu lv im bi translated">这看起来很棒，除了我们仍然不知道这个评级是哪个播客的插曲。因此，我们将继续提取剧集id和播客id。</p><pre class="lz ma mb mc gt ni nh nj nk aw nl bi"><span id="91f8" class="nm kj it nh b gy nn no l np nq">SELECT user_pseudo_id,<br/>(SELECT value.int_value<br/>FROM UNNEST(event_params) WHERE key = 'rating'<br/>) AS rating,<br/><strong class="nh iu">(SELECT value.string_value<br/>FROM UNNEST(event_params) WHERE key = 'guid'<br/>) AS episode_id,<br/>(SELECT value.int_value<br/>FROM UNNEST(event_params) WHERE key = 'collectionId'<br/>) AS podcast_id</strong></span><span id="d539" class="nm kj it nh b gy oi no l np nq">FROM analytics_xxxxxxxxx.events_*<br/>WHERE event_name LIKE '%logReview%'</span></pre><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi op"><img src="../Images/d6fa3a517574bbb590439fc8b62b0b44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1378/format:webp/1*64tam_jTmvQYs186e90_lQ.png"/></div></figure><p id="4fe1" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj na ll lm ln nb lp lq lr nc lt lu lv im bi translated">这看起来<em class="lx">几乎</em>完美！为什么几乎你问？这是因为我们没有考虑这个评级是否被更改过(记得我们为每个<em class="lx">日志审查</em>事件存储了<em class="lx">交互类型</em>)。</p><p id="4872" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj na ll lm ln nb lp lq lr nc lt lu lv im bi translated">从逻辑上讲，我们希望保留用户对播客剧集的最新评价。为了实现这一点，我们将使用<code class="fe ne nf ng nh b">LAST_VALUE</code>窗口函数、<code class="fe ne nf ng nh b">PARTITIONED BY</code> <em class="lx">用户id </em>和<em class="lx">剧集id </em>和<code class="fe ne nf ng nh b">ORDERED BY</code> <em class="lx">时间戳</em>:</p><pre class="lz ma mb mc gt ni nh nj nk aw nl bi"><span id="f1bb" class="nm kj it nh b gy nn no l np nq"><strong class="nh iu">WITH CTE AS (</strong><br/>SELECT user_pseudo_id,<br/>(<br/>SELECT value.int_value<br/>FROM UNNEST(event_params) WHERE key = 'rating'<br/>) AS rating,<br/>(<br/>SELECT value.string_value<br/>FROM UNNEST(event_params) WHERE key = 'guid'<br/>) AS episode_id,<br/>(<br/>SELECT value.int_value<br/>FROM UNNEST(event_params) WHERE key = 'collectionId'<br/>) AS podcast_id,<br/>(<br/>SELECT value.int_value<br/>FROM UNNEST(event_params) WHERE key = 'interactionType'<br/>) AS interaction_type,<br/>event_timestamp, time</span><span id="348f" class="nm kj it nh b gy oi no l np nq">FROM analytics_xxxxxxxxx.events_*<br/>WHERE event_name LIKE '%logReview%'<br/>)</span><span id="793f" class="nm kj it nh b gy oi no l np nq"><strong class="nh iu">SELECT DISTINCT user_pseudo_id, episode_id, podcast_id,<br/>LAST_VALUE(rating) OVER (PARTITION BY user_pseudo_id, episode_id ORDER BY event_timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)  AS latest_rating <br/>FROM CTE</strong></span></pre><p id="a6d6" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj na ll lm ln nb lp lq lr nc lt lu lv im bi translated"><code class="fe ne nf ng nh b">LAST_VALUE...</code>调用本质上是对数据进行分区，首先是按用户id，在每个用户id内，按播客剧集。然后，在这些<em class="lx">用户剧集</em>片段(或分区)的每一个中，结果行按照事件时间戳排序。最后，选择对应于分区中最后一行的额定值。</p><p id="7f27" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj na ll lm ln nb lp lq lr nc lt lu lv im bi translated">瞧啊。我们做到了。:)现在我们有了开始我们的推荐系统建模所需的数据框架。您可以单击保存结果按钮将数据框导出到本地计算机上。</p><h1 id="3e31" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">用于版本更新的定制电子邮件</h1><p id="202c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">作为一名应用程序开发人员，每隔几周就会推出一个新版本的应用程序，这是很自然的事情。理想情况下，新版本将有更多的特性和功能，并解决了以前版本的一些令人讨厌的错误。因此，确保大多数早期用户已经过渡到这个最新版本是很重要的，如果他们还没有，通过电子邮件给他们一些提示。</p><p id="4d84" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj na ll lm ln nb lp lq lr nc lt lu lv im bi translated">我们将检测所有在我们的应用程序上活跃但尚未切换到最新版本的用户。我们认为那些在过去10天内使用过该应用程序的用户是活跃的。</p><p id="4a24" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj na ll lm ln nb lp lq lr nc lt lu lv im bi translated">我们将使用<code class="fe ne nf ng nh b">FIRST_VALUE</code>来检测用户第一次使用我们的应用程序时使用了哪个版本的应用程序。同样，我们将使用我们的好朋友<code class="fe ne nf ng nh b">LAST_VALUE</code>来检测与该应用程序最近交互相关的应用程序版本，并提取该应用程序上次使用的日期。我们把这些都储存在CTE里。</p><pre class="lz ma mb mc gt ni nh nj nk aw nl bi"><span id="4ed5" class="nm kj it nh b gy nn no l np nq">WITH CTE AS (<br/>SELECT <br/>user_id,<br/>FIRST_VALUE(app_info.version) OVER (user_event_window) AS initial_version,<br/>LAST_VALUE(app_info.version) OVER (user_event_window) AS latest_version,<br/>LAST_VALUE(event_timestamp) OVER (user_event_window) AS app_last_used<br/>FROM analytics_xxxxxxxxx.events_*<br/>WHERE device.operating_system &lt;&gt; 'WEB' AND user_id IS NOT NULL<br/>WINDOW user_event_window AS (PARTITION BY user_id ORDER BY event_timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)<br/>)</span></pre><p id="61a0" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj na ll lm ln nb lp lq lr nc lt lu lv im bi translated">由于我们对web应用程序用户不感兴趣，我们指定了<code class="fe ne nf ng nh b">WHERE</code>条件来检查设备的操作系统。</p><p id="57ac" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj na ll lm ln nb lp lq lr nc lt lu lv im bi translated">我们还使用了一个<code class="fe ne nf ng nh b">WINDOW</code>调用<code class="fe ne nf ng nh b">user_event_window</code>来指定事件窗口，这使得代码使用起来更加简洁(通过简化所有冗余的<code class="fe ne nf ng nh b">PARTITION BY</code>调用)。</p><p id="060a" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj na ll lm ln nb lp lq lr nc lt lu lv im bi translated">现在我们有了应用程序最后一次使用的日期(存储为<code class="fe ne nf ng nh b">app_last_used</code>)，我们可以使用<code class="fe ne nf ng nh b">DATE_DIFF</code>从今天的日期中减去它。</p><pre class="lz ma mb mc gt ni nh nj nk aw nl bi"><span id="1063" class="nm kj it nh b gy nn no l np nq">DATE_DIFF(CURRENT_DATE(), DATE(TIMESTAMP_MICROS(app_last_used)), DAY) AS gap</span></pre><p id="3698" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj na ll lm ln nb lp lq lr nc lt lu lv im bi translated">如果结果小于或等于10，这意味着该用户是一个活跃用户，因此是我们的应用程序更新电子邮件的目标。</p><p id="1807" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj na ll lm ln nb lp lq lr nc lt lu lv im bi translated">现在是检索用户id的最终代码，这些用户应该根据他们上次使用应用程序的时间收到应用程序版本更新的电子邮件。</p><pre class="lz ma mb mc gt ni nh nj nk aw nl bi"><span id="9c37" class="nm kj it nh b gy nn no l np nq">WITH CTE AS (<br/>SELECT <br/>user_id,<br/>FIRST_VALUE(app_info.version) OVER (user_event_window) AS initial_version,<br/>LAST_VALUE(app_info.version) OVER (user_event_window) AS latest_version,<br/>LAST_VALUE(event_timestamp) OVER (user_event_window) AS app_last_used<br/>FROM `podcastapp-767c2.analytics_193436959.events_*`<br/>WHERE device.operating_system &lt;&gt; 'WEB' AND user_id IS NOT NULL<br/>WINDOW user_event_window AS (PARTITION BY user_id ORDER BY event_timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)<br/>)</span><span id="b09a" class="nm kj it nh b gy oi no l np nq"><strong class="nh iu">SELECT user_id, initial_version, latest_version,<br/>DATE(TIMESTAMP_MICROS(app_last_used)) AS last_used, <br/>DATE_DIFF(CURRENT_DATE(), DATE(TIMESTAMP_MICROS(app_last_used)), DAY) AS gap <br/>FROM CTE<br/>WHERE latest_version NOT IN ('1.1.3') -- update the version here in future<br/>GROUP BY user_id, initial_version, latest_version, app_last_used<br/>HAVING gap &lt;= 10</strong></span></pre><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/91ad88831c5a1c978cc4f4b20ba70871.png" data-original-src="https://miro.medium.com/v2/resize:fit:1154/format:webp/1*RzB3QmP46neirF_Al-vCGw.png"/></div></figure></div><div class="ab cl or os hx ot" role="separator"><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow"/></div><div class="im in io ip iq"><p id="d0d6" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj na ll lm ln nb lp lq lr nc lt lu lv im bi translated">我希望这篇文章为您提供了一些在BigQuery中使用事件数据的有用技巧。查看<a class="ae lw" rel="noopener" target="_blank" href="/process-mining-to-assess-app-user-behavior-from-clickstream-data-8e53a71428a4">这篇</a>文章，了解如何利用流程挖掘从事件数据中获取更多关于工作时间损失率和冷启动建议的信息。将来，我会提供一些食谱和其他有趣的查询，您可以尝试用于Firebase事件分析。</p><p id="a842" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj na ll lm ln nb lp lq lr nc lt lu lv im bi translated">直到下次:)</p><div class="oy oz gp gr pa pb"><a rel="noopener follow" target="_blank" href="/process-mining-to-assess-app-user-behavior-from-clickstream-data-8e53a71428a4"><div class="pc ab fo"><div class="pd ab pe cl cj pf"><h2 class="bd iu gy z fp pg fr fs ph fu fw is bi translated">从点击流数据中评估应用用户行为的流程挖掘</h2><div class="pi l"><h3 class="bd b gy z fp pg fr fs ph fu fw dk translated">对pm4py python库的深入介绍</h3></div><div class="pj l"><p class="bd b dl z fp pg fr fs ph fu fw dk translated">towardsdatascience.com</p></div></div><div class="pk l"><div class="pl l pm pn po pk pp mi pb"/></div></div></a></div><div class="oy oz gp gr pa pb"><a rel="noopener follow" target="_blank" href="/how-to-use-bigquery-api-with-your-own-dataset-c901972cebd"><div class="pc ab fo"><div class="pd ab pe cl cj pf"><h2 class="bd iu gy z fp pg fr fs ph fu fw is bi translated">如何对自己的数据集使用BigQuery API？</h2><div class="pi l"><h3 class="bd b gy z fp pg fr fs ph fu fw dk translated">使用Flask和Bigquery APIs根据用户查询参数从Bigquery数据集中提取数据。</h3></div><div class="pj l"><p class="bd b dl z fp pg fr fs ph fu fw dk translated">towardsdatascience.com</p></div></div><div class="pk l"><div class="pq l pm pn po pk pp mi pb"/></div></div></a></div><div class="oy oz gp gr pa pb"><a href="https://medium.com/analytics-vidhya/how-to-use-autokeras-to-build-image-classification-models-using-one-line-of-code-c35b0c36e66e" rel="noopener follow" target="_blank"><div class="pc ab fo"><div class="pd ab pe cl cj pf"><h2 class="bd iu gy z fp pg fr fs ph fu fw is bi translated">如何使用AutoKeras用一行代码建立图像分类模型？</h2><div class="pi l"><h3 class="bd b gy z fp pg fr fs ph fu fw dk translated">甚至不需要知道Conv2d、Maxpool或批处理规范化层是做什么的！</h3></div><div class="pj l"><p class="bd b dl z fp pg fr fs ph fu fw dk translated">medium.com</p></div></div><div class="pk l"><div class="pr l pm pn po pk pp mi pb"/></div></div></a></div></div></div>    
</body>
</html>