<html>
<head>
<title>Low Memory Instance Segmentation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">低内存实例分段</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/low-memory-instance-segmentation-b9c425b67db1?source=collection_archive---------30-----------------------#2020-07-26">https://towardsdatascience.com/low-memory-instance-segmentation-b9c425b67db1?source=collection_archive---------30-----------------------#2020-07-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7dc7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">将实例分段 web 应用程序部署到 google cloud</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d89ef3737af7720a605826e0d1f1261d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c2oWLUCnyMGsC3ySbd6QNQ.jpeg"/></div></div></figure><p id="7f94" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">机器学习模型是内存密集型的。我当前的 web 应用程序至少消耗 1GB 的内存。这使得它很难部署到云上。</p><p id="21f9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">想到的直接解决方案是增加 VM 实例的内存。但是我不想花更多的钱。毕竟，这是一个附带项目。</p><p id="b9fe" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以我想出了一个办法。它实际上是受杰森·安蒂奇的<a class="ae ln" href="https://github.com/jantic/DeOldify/tree/master/deoldify" rel="noopener ugc nofollow" target="_blank"> deoldify </a>的启发。在运行他的机器学习模型之前，Jason 使用渲染因子来缩小图像并将其转换为正方形。</p><p id="aad0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我认为在这里应用同样的思想可以减少内存需求。</p><h1 id="7d72" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">解决方案</h1><p id="e1d8" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">简而言之，这就是解决方案。很大程度上取自这里的<a class="ae ln" href="https://github.com/jantic/DeOldify/blob/master/deoldify/filters.py" rel="noopener ugc nofollow" target="_blank"/>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="fbee" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们缩放到大小为<code class="fe mn mo mp mq b">targ</code>的正方形。<code class="fe mn mo mp mq b">targ</code>本质上就是 Jason 在 deoldify 中提到的渲染因子。</p><p id="5878" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果渲染因子太高，可能会导致 OOM 错误<a class="ae ln" href="https://github.com/jantic/DeOldify/blob/edac73edf1d3557f95a71f860cffd6c4c91f66f0/deoldify/filters.py#L58" rel="noopener ugc nofollow" target="_blank">。太低的话，结果的分辨率会很差。</a></p><p id="d120" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">实际上这看起来很简单。首先，我们将图像缩放到一个大小为<code class="fe mn mo mp mq b">targ</code>的正方形。然后我们对缩放图像进行推理。推理的结果通过<code class="fe mn mo mp mq b">_unsquare</code>函数传递。这将我们的正方形大小的图像转换为原来的大小。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="9856" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">此后，我们终于可以在大多数云平台上部署，而不会出现任何面向对象的问题。如果你得到一个 OOM 错误，只要减少渲染因子。</p><p id="d371" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我将使用这里描述的 web 应用程序<a class="ae ln" href="https://spiyer99.github.io/Detectron2-Web-App/" rel="noopener ugc nofollow" target="_blank">作为起点。</a></p><p id="378c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们需要修改<code class="fe mn mo mp mq b">app.py</code>脚本来实现上面描述的<code class="fe mn mo mp mq b">run_inference_transform</code>函数。修改后的版本在<a class="ae ln" href="https://github.com/spiyer99/detectron2_web_app/blob/master/app.py" rel="noopener ugc nofollow" target="_blank"> Github </a>上。</p><p id="779d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有许多方法可以获得谷歌云的推广积分。所以我将在这个项目中使用他们的服务。我的计划是，我所做的一切都将由这些免费学分支付:)。</p><p id="12c0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我在 google cloud 上创建了一个<a class="ae ln" href="https://cloud.google.com/resource-manager/docs/creating-managing-projects" rel="noopener ugc nofollow" target="_blank">项目</a>,并最终部署工作。谷歌云<a class="ae ln" href="https://cloud.google.com/run/docs/quickstarts/build-and-deploy" rel="noopener ugc nofollow" target="_blank">文档</a>写得很好——但我还是会出错。我发现<a class="ae ln" href="https://github.com/npatta01/web-deep-learning-classifier/" rel="noopener ugc nofollow" target="_blank">这个回购</a>非常有用。</p><p id="60a1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">像往常一样，我创建了一个 shell 脚本来实现我们在终端中需要做的事情。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="70eb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一旦我们在 google cloud 上部署了这个，detectron2 模型终于可以工作了。输出的分辨率低于输入，但一切都符合 2G 内存的限制。</p><p id="d34d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在用<code class="fe mn mo mp mq b">docker stats</code>构建之后，我可以确认这种方法使用的内存要少得多。在我的本地计算机上，它在峰值时使用 1.16 GB 的内存。而之前的方法使用超过 2GB(大约。2.23 GB)。</p><p id="b17a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你可以点击访问<a class="ae ln" href="https://neelsmlapp-lfoa57ljxa-uc.a.run.app/" rel="noopener ugc nofollow" target="_blank">谷歌云实例分割 web 应用。</a></p></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><p id="917f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="my">原载于 2020 年 7 月 26 日</em><a class="ae ln" href="https://spiyer99.github.io/Detectron2-Web-App-gcloud/" rel="noopener ugc nofollow" target="_blank"><em class="my">https://spiyer 99 . github . io</em></a><em class="my">。</em></p></div></div>    
</body>
</html>