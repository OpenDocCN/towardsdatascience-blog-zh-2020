<html>
<head>
<title>Learning Rust by Converting Python to Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过将 Python 转换成 Rust 来学习 Rust</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/learning-rust-by-converting-python-to-rust-259e735591c6?source=collection_archive---------10-----------------------#2020-07-24">https://towardsdatascience.com/learning-rust-by-converting-python-to-rust-259e735591c6?source=collection_archive---------10-----------------------#2020-07-24</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="8f5a" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">Rust 基础入门教程</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/9ec8921315943b372e4f4aee0585acc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*j7CBar6f3FYV6Qpm"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://unsplash.com/@lewagon?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">乐旅行车</a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="6e5f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">[更新于 2021 年 2 月 18 日。代码更改为要点并添加了链接]</p><pre class="kk kl km kn gu lw lx ly lz aw ma bi"><span id="e646" class="mb mc iu lx b gz md me l mf mg"><strong class="lx iv">Table of Contents</strong></span><span id="b7aa" class="mb mc iu lx b gz mh me l mf mg"><a class="ae kz" href="#3cb0" rel="noopener ugc nofollow"><strong class="lx iv">Introduction</strong></a></span><span id="f0db" class="mb mc iu lx b gz mh me l mf mg">🦀 <a class="ae kz" href="#d2b3" rel="noopener ugc nofollow">Leetcode Unique Paths</a><br/>🦀 <a class="ae kz" href="#2aa3" rel="noopener ugc nofollow">Python Code</a><br/>🦀 <a class="ae kz" href="#f513" rel="noopener ugc nofollow">First Step in Rust</a><br/>🦀 <a class="ae kz" href="#5358" rel="noopener ugc nofollow">Examples of Primitive Data Types:</a><br/>🦀 <a class="ae kz" href="#3775" rel="noopener ugc nofollow">Functions</a><br/>🦀 <a class="ae kz" href="#edb9" rel="noopener ugc nofollow">Statements and Expressions</a><br/>🦀 <a class="ae kz" href="#0f1c" rel="noopener ugc nofollow">Variables</a><br/>🦀 <a class="ae kz" href="#dc94" rel="noopener ugc nofollow">Macros</a><br/>🦀 <a class="ae kz" href="#5346" rel="noopener ugc nofollow">if-else Statement (Step 2)</a><br/>🦀 <a class="ae kz" href="#f27b" rel="noopener ugc nofollow">Calling a Function</a><br/>🦀 <a class="ae kz" href="#5d38" rel="noopener ugc nofollow">Range</a><br/>🦀 <a class="ae kz" href="#52ef" rel="noopener ugc nofollow">Arrays, Tuples, and Vectors</a><br/>🦀 <a class="ae kz" href="#6263" rel="noopener ugc nofollow">as Keyword</a><br/>🦀 <a class="ae kz" href="#4543" rel="noopener ugc nofollow">Final Code</a><br/>🦀 <a class="ae kz" href="#27aa" rel="noopener ugc nofollow">Struct and Impl</a><br/>🦀 <a class="ae kz" href="#2c53" rel="noopener ugc nofollow">Trait</a><br/>🦀 <a class="ae kz" href="#7e45" rel="noopener ugc nofollow">Runtime &amp; Memory Usage</a></span><span id="4629" class="mb mc iu lx b gz mh me l mf mg"><a class="ae kz" href="#d7d1" rel="noopener ugc nofollow"><strong class="lx iv">Conclusion</strong></a></span></pre><h1 id="3cb0" class="mi mc iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">介绍</h1><p id="8e12" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">Rust 是一种静态和强类型的系统编程语言。Rust 是为渴望语言速度和稳定性的人准备的。</p><p id="197c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我认为自己是一个新手。写完<a class="ae kz" rel="noopener" target="_blank" href="/you-want-to-learn-rust-but-you-dont-know-where-to-start-fc826402d5ba">这篇文章</a>后，我开始学习 Rust，并且我每天都在学习新的东西。我现在可以将简单的 Python 代码转换成 Rust，并且能够解释我正在编写的代码。</p><p id="d447" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在本文中，我们将使用一个 Leetcode 问题的 Python 解决方案，并将其转换为 Rust 代码。你不仅会发现两种语言之间的相似之处，还会学到 Rust 编程。</p><p id="cae7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您可以运行代码，也可以在本文的示例中对其进行调整。</p><div class="ne nf gq gs ng nh"><a rel="noopener follow" target="_blank" href="/you-want-to-learn-rust-but-you-dont-know-where-to-start-fc826402d5ba"><div class="ni ab fp"><div class="nj ab nk cl cj nl"><h2 class="bd iv gz z fq nm fs ft nn fv fx it bi translated">你想学 Rust 但是不知道从哪里开始</h2><div class="no l"><h3 class="bd b gz z fq nm fs ft nn fv fx dk translated">Rust 初学者的完整资源</h3></div><div class="np l"><p class="bd b dl z fq nm fs ft nn fv fx dk translated">towardsdatascience.com</p></div></div><div class="nq l"><div class="nr l ns nt nu nq nv kt nh"/></div></div></a></div><h1 id="d2b3" class="mi mc iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">Leetcode 唯一路径</h1><p id="596b" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">LeetCode 是一个非常受欢迎的网站，在那里你可以提高你的编码技能。其中一个问题叫做<a class="ae kz" href="https://leetcode.com/problems/unique-paths/" rel="noopener ugc nofollow" target="_blank">“唯一路径”</a>，机器人位于一个<strong class="lc iv"> <em class="nw"> m </em> x <em class="nw"> n </em>网格</strong>的左上角。您只能将<strong class="lc iv">向下</strong>或<strong class="lc iv">向右</strong>移动，并且您需要找出两点之间有多少条唯一的路径。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj nx"><img src="../Images/c2d397a64fd6c6cac63e945caee48549.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*UO4JvdwGUH_D1T-h5Zhspg.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">图片来自 LeetCode</p></figure><p id="1ee2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">例如，在下图中，从 A 点到 B 点有 3 条唯一路径，从 A 点到 C 点有 5 条唯一路径。下图帮助您找到从 A 到每个区域的唯一路径的数量。由于您只需将<strong class="lc iv">向下移动</strong>或<strong class="lc iv">向右移动</strong>，您可以将上面和左边的数字相加，找到到达该点的唯一路径的数量。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj nx"><img src="../Images/a26877ac05061401ebd67fb2ae88390f.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*mcVL8vE-SSHq_0NIXAc2Lw.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">作者图片</p></figure><h1 id="2aa3" class="mi mc iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">Python 代码</h1><p id="646d" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">用 Python 解决这个问题肯定有很多方法，但是我们打算用下面的<a class="ae kz" href="https://tech.io/snippet/qpOVDt4" rel="noopener ugc nofollow" target="_blank">解决方案</a>。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ny nz l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">使用 Python 的解决方案。在线尝试这段 Python 代码。</p></figure><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oa"><img src="../Images/15f75df6ba9854f1dea182d6f38246bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*psIIjjKUUOj9-oudcuxzlw.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">LeetCode 上 Python 代码的结果。</p></figure><p id="9763" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在这段 Python 代码中:</p><ul class=""><li id="61bc" class="ob oc iu lc b ld le lg lh lj od ln oe lr of lv og oh oi oj bi translated">我们创建了一个名为 Solution 的类。我们定义了一个叫做“唯一路径”的方法。(是起始码。)</li><li id="2d43" class="ob oc iu lc b ld ok lg ol lj om ln on lr oo lv og oh oi oj bi translated">它将 self、integer <code class="fe op oq or lx b">m</code>和 integer <code class="fe op oq or lx b">n</code>作为参数，并返回一个整数。它使用<a class="ae kz" href="https://docs.python.org/3/library/typing.html" rel="noopener ugc nofollow" target="_blank">类型注释</a>。</li><li id="eb45" class="ob oc iu lc b ld ok lg ol lj om ln on lr oo lv og oh oi oj bi translated">如果<code class="fe op oq or lx b">m</code>或<code class="fe op oq or lx b">n</code>等于 1，那么它返回 1。</li><li id="6653" class="ob oc iu lc b ld ok lg ol lj om ln on lr oo lv og oh oi oj bi translated">如果<code class="fe op oq or lx b">n</code>小于<code class="fe op oq or lx b">m</code>，则它会切换位置并运行相同的方法。</li><li id="a0f7" class="ob oc iu lc b ld ok lg ol lj om ln on lr oo lv og oh oi oj bi translated"><code class="fe op oq or lx b">dp = [1]*n</code>将创建一个<code class="fe op oq or lx b">n</code>编号为 1 的列表。例如<code class="fe op oq or lx b">[1]*3</code>将创建<code class="fe op oq or lx b">[1,1,1]</code>。</li><li id="e0fd" class="ob oc iu lc b ld ok lg ol lj om ln on lr oo lv og oh oi oj bi translated">我们使用双 for 循环和 range 将前一个数字添加到下一个项目中。<code class="fe op oq or lx b">[1,2,3]</code>、<code class="fe op oq or lx b">[1,3,6]</code>等。您可以通过将返回值更改为<code class="fe op oq or lx b">return dp</code>来检查这一点。</li><li id="fe7a" class="ob oc iu lc b ld ok lg ol lj om ln on lr oo lv og oh oi oj bi translated">我们使用<code class="fe op oq or lx b">[-1]</code>返回列表中的最后一个数字。</li></ul><p id="6c5a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在本文中，我们将逐步将 Python 代码转换为 Rust。</p><p id="a2f1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">上面的结果显示运行时间为 36 ms，内存使用量为 13.6 MB。我们稍后会将这个结果与 Rust 结果进行比较。</p><p id="372b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">(当我再次提交给 LeetCode 时，结果发生了变化，上面的那个是最好的。你可能会有不同的结果。)</p><h1 id="f513" class="mi mc iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">生锈的第一步</h1><p id="00ef" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">我们将从一个<a class="ae kz" href="https://tech.io/snippet/MbIqTol" rel="noopener ugc nofollow" target="_blank">基本锈码</a>开始。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ny nz l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">生锈的第一步。<a class="ae kz" href="https://tech.io/snippet/MbIqTol" rel="noopener ugc nofollow" target="_blank">试试这个锈郎在线。</a></p></figure><p id="5311" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Rust 总是在你运行程序的时候先运行<code class="fe op oq or lx b"><strong class="lc iv">main</strong></code>功能。我们创建一个名为<code class="fe op oq or lx b">unique_paths</code>的函数，带有两个参数<code class="fe op oq or lx b">m</code>和<code class="fe op oq or lx b">n</code>，它们是<code class="fe op oq or lx b"><strong class="lc iv">i32</strong></code>类型。</p><p id="b454" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在函数中，我们必须声明每个参数的类型。Rust 程序中的每个变量、项目和值都有一个类型。</p><p id="80f1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">值的类型<a class="ae kz" href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html?highlight=heap#the-stack-and-the-heap" rel="noopener ugc nofollow" target="_blank">定义了</a>保存它的内存的解释。<code class="fe op oq or lx b"><strong class="lc iv">i32</strong></code>是<a class="ae kz" href="https://learning-rust.github.io/docs/a8.primitive_data_types.html" rel="noopener ugc nofollow" target="_blank">原语数据类型</a>之一，是一种 32 位固定大小的<a class="ae kz" href="https://learning-rust.github.io/docs/a8.primitive_data_types.html#i8-i16-i32-i64-i128" rel="noopener ugc nofollow" target="_blank">有符号整数类型</a>。<code class="fe op oq or lx b"><strong class="lc iv">i32</strong></code>可以容纳-(2)和 2 -1 之间的数字，前者为-2147483648，后者为 2147483647。</p><h1 id="5358" class="mi mc iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">原始数据类型的示例:</h1><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ny nz l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://tech.io/snippet/uwnXAR8" rel="noopener ugc nofollow" target="_blank">在线尝试这个原始数据类型示例</a>。</p></figure><p id="6483" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">更多的原始数据类型在这个<a class="ae kz" href="https://www.codingame.com/playgrounds/365/getting-started-with-rust/primitive-data-types" rel="noopener ugc nofollow" target="_blank">链接</a>中。</p><p id="9ade" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">顺便说一下，Rust 的默认整数类型是<code class="fe op oq or lx b"><strong class="lc iv">i32</strong></code>，所以如果你没有在一个<a class="ae kz" href="https://doc.rust-lang.org/book/ch13-01-closures.html?highlight=annotate,a,type#closure-type-inference-and-annotation" rel="noopener ugc nofollow" target="_blank"> <strong class="lc iv">闭包</strong> </a>中标注参数的类型，并且如果它们是整数，Rust 将使用<code class="fe op oq or lx b"><strong class="lc iv">i32</strong></code>。Rust 的编译器能够推断出参数和大多数变量的类型。</p><h1 id="3775" class="mi mc iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">功能</h1><p id="d8d7" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated"><a class="ae kz" href="https://doc.rust-lang.org/book/ch03-03-how-functions-work.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lc iv">功能</strong> </a>使用<code class="fe op oq or lx b"><strong class="lc iv">fn</strong></code>关键字启动。Rust code 使用蛇形外壳作为功能的<a class="ae kz" href="https://doc.rust-lang.org/1.0.0/style/style/naming/README.html" rel="noopener ugc nofollow" target="_blank">传统样式</a>。函数可以返回值，我们使用箭头<code class="fe op oq or lx b"><strong class="lc iv">-&gt;</strong></code>为返回值声明它们的类型。unique_paths 返回数据类型<code class="fe op oq or lx b"><strong class="lc iv">i32</strong></code>。Rust 使用<code class="fe op oq or lx b">{}</code>作为函数体。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ny nz l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://tech.io/snippet/quWpWFg" rel="noopener ugc nofollow" target="_blank">网上试试这个锈郎代码。</a>返回字符串的函数示例。</p></figure><h1 id="edb9" class="mi mc iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">陈述和表达</h1><p id="fb45" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">我们返回总和，<code class="fe op oq or lx b">m + n</code>。函数体由一系列语句组成，并以表达式结尾。</p><blockquote class="os"><p id="4006" class="ot ou iu bd ov ow ox oy oz pa pb lv dk translated">语句<em class="pc">是执行一些动作并且不返回值的指令。</em>表达式<em class="pc">计算出结果值。— </em> <a class="ae kz" href="https://doc.rust-lang.org/book/ch03-03-how-functions-work.html?highlight=expression,and,statement#function-bodies-contain-statements-and-expressions" rel="noopener ugc nofollow" target="_blank"> <em class="pc">函数体包含语句和表达式</em> </a></p></blockquote><p id="6b5a" class="pw-post-body-paragraph la lb iu lc b ld pd jv lf lg pe jy li lj pf ll lm ln pg lp lq lr ph lt lu lv in bi translated">表达式<code class="fe op oq or lx b">m + n</code>不包括结束分号，因为我们想返回它。如果你在一个表达式的末尾加一个分号，你就把它变成了一个语句，它不会返回值。</p><h1 id="0f1c" class="mi mc iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">变量</h1><p id="7d45" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">在<code class="fe op oq or lx b"><strong class="lc iv">main()</strong></code>函数中，我们用一个<a class="ae kz" href="https://doc.rust-lang.org/reference/keywords.html" rel="noopener ugc nofollow" target="_blank">关键字</a>T3】来表示一个变量。默认情况下，局部变量是不可变的，但是您可以使用<code class="fe op oq or lx b"><strong class="lc iv">mut</strong></code>使它们可变。对于我们的例子，我们不需要使它可变。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ny nz l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">试试<a class="ae kz" href="https://tech.io/snippet/ZWuAnj1" rel="noopener ugc nofollow" target="_blank">锈变量示例</a>在线。</p></figure><h1 id="dc94" class="mi mc iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">宏指令</h1><p id="1b75" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated"><code class="fe op oq or lx b"><strong class="lc iv">println!()</strong></code> <strong class="lc iv"> </strong>是<a class="ae kz" href="https://learning-rust.github.io/docs/d7.std_primitives_and_preludes.html#Standard-Macros" rel="noopener ugc nofollow" target="_blank">标准宏</a>之一。它解析格式字符串并将其转换为打印格式。</p><p id="54c5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe op oq or lx b">pritln!</code>按顺序填充占位符。可以用索引和<code class="fe op oq or lx b">name="vale"</code>。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ny nz l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">试试<a class="ae kz" href="https://tech.io/snippet/VKciz0J" rel="noopener ugc nofollow" target="_blank"> println！宏</a>在线。</p></figure><h1 id="5346" class="mi mc iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">if-else 语句(步骤 2)</h1><p id="017f" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">下一步，我们添加一个<code class="fe op oq or lx b"><strong class="lc iv">if-else</strong></code>语句。<code class="fe op oq or lx b"><strong class="lc iv">expr == expr</strong></code>(其中<code class="fe op oq or lx b">expr</code>表示表达式)是相等比较。<code class="fe op oq or lx b"><strong class="lc iv">expr || expr</strong></code>是逻辑<strong class="lc iv">还是</strong>。</p><p id="dbd3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果<code class="fe op oq or lx b">m</code>或<code class="fe op oq or lx b">n</code>中的任何一个等于 1，那么我们返回 1。请注意 1 后面没有分号，因为我们要返回 1。</p><p id="64ee" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Rust 对于<code class="fe op oq or lx b"><strong class="lc iv">if</strong></code>语句中的条件不使用括号。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ny nz l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">在线使用 if 语句尝试 Rust 中的<a class="ae kz" href="https://tech.io/snippet/XZMM4jx" rel="noopener ugc nofollow" target="_blank">步骤 2。</a></p></figure><p id="51cd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe op oq or lx b"><strong class="lc iv">if-else if-else</strong></code>有如下形式。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ny nz l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">在线尝试<a class="ae kz" href="https://tech.io/snippet/EI8viV3" rel="noopener ugc nofollow" target="_blank"> if-else if-else 示例</a>。</p></figure><h1 id="f27b" class="mi mc iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">调用函数</h1><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ny nz l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">在线尝试 Rust 中的<a class="ae kz" href="https://tech.io/snippet/ctjMBxw" rel="noopener ugc nofollow" target="_blank">步骤 3。</a></p></figure><p id="e464" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这可能不是传递 LeetCode 所必需的，但是这向您展示了如何从内部调用自己的函数。</p><p id="0cb1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果<code class="fe op oq or lx b"><strong class="lc iv">n</strong></code>小于<code class="fe op oq or lx b"><strong class="lc iv">m</strong></code>，我们交换变量位置，调用自己的函数。</p><h1 id="5d38" class="mi mc iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">范围</h1><p id="790e" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">在 Python 中，我们使用<code class="fe op oq or lx b">range</code>作为:</p><pre class="kk kl km kn gu lw lx ly lz aw ma bi"><span id="07f6" class="mb mc iu lx b gz md me l mf mg">for i in range(1,m):<br/>    for j in range(1,n):</span></pre><p id="8052" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在 Rust 中，我们使用<code class="fe op oq or lx b">..</code>或<code class="fe op oq or lx b">..=</code>。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ny nz l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">尝试<a class="ae kz" href="https://tech.io/snippet/yE8eJCK" rel="noopener ugc nofollow" target="_blank">范围..在锈</a>线上。</p></figure><p id="f107" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">上面的代码将输出 1 到 9。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ny nz l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">尝试<a class="ae kz" href="https://tech.io/snippet/6cKeArR" rel="noopener ugc nofollow" target="_blank">范围..= in Rust </a> online。</p></figure><p id="dd65" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">上面的代码将输出 1 到 10。</p><h1 id="52ef" class="mi mc iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">数组、元组和向量</h1><p id="ff1e" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">在 Python 中我们使用了<code class="fe op oq or lx b">dp = [1]*n</code>。这将创建[1]的<code class="fe op oq or lx b">n</code>个数字。例如当 n=3 时，<code class="fe op oq or lx b">[1, 1, 1]</code>。</p><p id="c870" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们看看 Rust 中的数组、元组或向量中哪一个可以用于此目的。</p><p id="01ef" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">阵列</strong></p><p id="5c9f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><a class="ae kz" href="https://doc.rust-lang.org/book/ch03-02-data-types.html#the-array-type" rel="noopener ugc nofollow" target="_blank">数组</a>必须有<strong class="lc iv">同类型定长</strong>。默认情况下，数组是不可变的，我们不能用<code class="fe op oq or lx b"><strong class="lc iv">mut</strong></code> <strong class="lc iv"> </strong>来改变它的元素。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ny nz l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">在线试用<a class="ae kz" href="https://tech.io/snippet/2iUgNLo" rel="noopener ugc nofollow" target="_blank">锈阵</a>。</p></figure><p id="53ac" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">输出:</p><pre class="kk kl km kn gu lw lx ly lz aw ma bi"><span id="e5d0" class="mb mc iu lx b gz md me l mf mg">one: 1, b: [4, 5, 6], c: [1, 1, 1, 1, 1], d: [1, 1, 1, 1, 1]</span></pre><p id="d177" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们也<strong class="lc iv">不能</strong>动态设置数组长度。因为数组的长度<em class="nw">是在编译时</em>定义的。变量在编译时是未知的，因为它可以<em class="nw">改变</em>。编译器不知道在堆栈上分配多少空间来为数组提供存储。</p><p id="bc44" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果你试图在没有<code class="fe op oq or lx b"><a class="ae kz" href="https://doc.rust-lang.org/std/fmt/index.html" rel="noopener ugc nofollow" target="_blank">{:?}</a></code>的情况下打印，你将会失败。我们不能用默认格式化程序格式化数组。所有 Rust 数据类型都实现了<code class="fe op oq or lx b">Debug</code>特征，您可以使用<code class="fe op oq or lx b">{:?}</code>来格式化它并打印一个数组。</p><p id="98c0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">所以我们不能在这里使用数组。</p><p id="b9e5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">元组</strong></p><p id="3e05" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><a class="ae kz" href="https://doc.rust-lang.org/book/ch03-02-data-types.html#the-tuple-type" rel="noopener ugc nofollow" target="_blank">元组</a>可以有<strong class="lc iv">不同的类型，并且有固定的长度</strong>。</p><pre class="kk kl km kn gu lw lx ly lz aw ma bi"><span id="ab1f" class="mb mc iu lx b gz md me l mf mg">let tup: (i32, f64, u8) = (100, 2.32, 4);</span></pre><p id="9c10" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">为了从元组中获取单个值，我们可以使用模式匹配来析构元组值。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ny nz l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">在线试试<a class="ae kz" href="https://tech.io/snippet/3bfkQfa" rel="noopener ugc nofollow" target="_blank">锈元组</a>。</p></figure><p id="74af" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">输出:</p><pre class="kk kl km kn gu lw lx ly lz aw ma bi"><span id="f972" class="mb mc iu lx b gz md me l mf mg">x = 500, y = 6.2, z = 4<br/>1</span></pre><p id="077b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">同样，我们不能使用元组，因为它们必须有固定的长度<strong class="lc iv"/>。</p><p id="bac7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">矢量</strong></p><p id="6fee" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Rust <a class="ae kz" href="https://doc.rust-lang.org/std/vec/struct.Vec.html" rel="noopener ugc nofollow" target="_blank">向量</a>在内存中存储多个相邻的值。向量存储相同类型的值。</p><blockquote class="os"><p id="f61a" class="ot ou iu bd ov ow ox oy oz pa pb lv dk translated">具有堆分配内容的连续可增长数组类型。——<a class="ae kz" href="https://doc.rust-lang.org/std/vec/index.html" rel="noopener ugc nofollow" target="_blank">doc.rust-lang.org</a></p></blockquote><p id="f2bb" class="pw-post-body-paragraph la lb iu lc b ld pd jv lf lg pe jy li lj pf ll lm ln pg lp lq lr ph lt lu lv in bi translated"><code class="fe op oq or lx b">vec!</code>宏创建一个新的向量，保存您给它的值。</p><pre class="kk kl km kn gu lw lx ly lz aw ma bi"><span id="314d" class="mb mc iu lx b gz md me l mf mg">let v = vec![1, 1, 1];<br/>// this is the same as above<br/>let u = vec![1; 3];</span></pre><p id="6eb6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">一个向量就像一个可调整大小的数组，但是所有的元素必须是同一类型。</p><p id="5c44" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">所以我们需要使用一个<a class="ae kz" href="https://doc.rust-lang.org/std/vec/struct.Vec.html" rel="noopener ugc nofollow" target="_blank">向量</a>。</p><pre class="kk kl km kn gu lw lx ly lz aw ma bi"><span id="b130" class="mb mc iu lx b gz md me l mf mg">dpm = vec![1; m as usize];<br/>dpn = vec![1; n as usize];</span></pre><h1 id="6263" class="mi mc iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">作为关键字</h1><p id="4be8" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">第二个数字，长度，在<code class="fe op oq or lx b">vec![1; 3]</code>中需要是<code class="fe op oq or lx b"><a class="ae kz" href="https://doc.rust-lang.org/std/primitive.usize.html" rel="noopener ugc nofollow" target="_blank"><strong class="lc iv">usize</strong></a></code>类型。我们将<code class="fe op oq or lx b"><strong class="lc iv">m</strong></code>和<code class="fe op oq or lx b"><strong class="lc iv">n</strong></code>标注为<code class="fe op oq or lx b"><strong class="lc iv">i32</strong></code> <strong class="lc iv"> </strong>，但是我们可以使用<code class="fe op oq or lx b"><strong class="lc iv">as</strong></code>关键字来转换类型。我们可以只使用<code class="fe op oq or lx b">as</code>表达式在原始类型之间转换。</p><blockquote class="os"><p id="5d05" class="ot ou iu bd ov ow ox oy oz pa pb lv dk translated">最常用于将基元类型转换为其他基元类型。——<a class="ae kz" href="https://doc.rust-lang.org/std/keyword.as.html" rel="noopener ugc nofollow" target="_blank">鲁斯特郎博士</a></p></blockquote><p id="8c60" class="pw-post-body-paragraph la lb iu lc b ld pd jv lf lg pe jy li lj pf ll lm ln pg lp lq lr ph lt lu lv in bi translated"><code class="fe op oq or lx b"><strong class="lc iv">vectors</strong></code>有一个方法<code class="fe op oq or lx b"><a class="ae kz" href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.len" rel="noopener ugc nofollow" target="_blank"><strong class="lc iv">len</strong></a></code>返回向量中元素的数量。</p><h1 id="4543" class="mi mc iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">最终代码</h1><p id="f661" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">我们使用上述所有代码来获得唯一路径的数量。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ny nz l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">在线尝试<a class="ae kz" href="https://tech.io/snippet/qyCu9nb" rel="noopener ugc nofollow" target="_blank">Rust</a>的最后一步。</p></figure><p id="a120" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你可能注意到了<code class="fe op oq or lx b">#[allow(unused_variables)]</code>。没有它也能工作，但是编译器会给你一个警告:</p><pre class="kk kl km kn gu lw lx ly lz aw ma bi"><span id="ca33" class="mb mc iu lx b gz md me l mf mg">warning: unused variable: `i`<br/>  --&gt; main.rs" data-line="11" data-column="13"&gt;main.rs:11:13<br/>   |<br/>11 |         for i in 1..dpm.len() {<br/>   |             ^ help: if this is intentional, prefix it with an underscore: `_i`<br/>   |<br/>   = note: `#[warn(unused_variables)]` on by default<br/><br/>warning: 1 warning emitted</span></pre><p id="5e08" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">为了消除这个警告，我们添加了<code class="fe op oq or lx b">#[allow(unused_variables)]</code>。</p><p id="f75a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">稍后我们将看到 LeetCode 的最终代码。在此之前，我们对这段代码进行了更深入的研究。</p><h1 id="27aa" class="mi mc iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">结构和实现</h1><p id="63b5" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">我们将对上述解决方案应用<code class="fe op oq or lx b">struct</code>、<code class="fe op oq or lx b">impl</code>和<code class="fe op oq or lx b">trait</code>。请注意，这在 LeetCode 上不起作用。</p><p id="9041" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">结构用于<strong class="lc iv">将相关属性</strong>封装成一个统一的数据类型。结构不同于其他语言中的类。例如，Rust 的 struct 不支持继承。</p><p id="6188" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">元组很方便，但是使用像<code class="fe op oq or lx b">t.0</code>这样的索引并跟踪每个部分的含义并不简单。</p><p id="5831" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Rust <em class="nw">结构</em>包含命名字段。我们使用关键字<code class="fe op oq or lx b">struct</code>并在花括号内设置字段类型。结构将数据定义为键值对。</p><pre class="kk kl km kn gu lw lx ly lz aw ma bi"><span id="b070" class="mb mc iu lx b gz md me l mf mg">struct Name_of_struct {<br/>   field1:data_type,<br/>   field2:data_type,<br/>   ...<br/>}</span></pre><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ny nz l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">在线试试<a class="ae kz" href="https://tech.io/snippet/laOPbRf" rel="noopener ugc nofollow" target="_blank">的防锈结构</a>。</p></figure><p id="af81" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv"> &amp;字符串和字符串</strong></p><p id="c4ff" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你可能想知道为什么我们需要<code class="fe op oq or lx b">to_string()</code>。Rust 主要有两种类型的弦:<code class="fe op oq or lx b"><a class="ae kz" href="https://doc.rust-lang.org/std/primitive.str.html" rel="noopener ugc nofollow" target="_blank">&amp;str</a></code>和<code class="fe op oq or lx b"><a class="ae kz" href="https://doc.rust-lang.org/book/ch08-02-strings.html#what-is-a-string" rel="noopener ugc nofollow" target="_blank">String</a></code>。<code class="fe op oq or lx b">&amp;str</code>叫做‘串片’。字符串切片具有固定的大小，不能变异。一个<code class="fe op oq or lx b">String</code>被存储为一个矢量。<code class="fe op oq or lx b">String</code>是堆分配的，可增长的，并且不是空终止的。(更多信息请点击<a class="ae kz" href="https://medium.com/series/learning-rust-all-about-strings-c7666812d893" rel="noopener">链接</a>。)</p><p id="0b48" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe op oq or lx b">"John"</code>是一个<code class="fe op oq or lx b">&amp;str</code>，由于我们在<code class="fe op oq or lx b">struct</code>中将<code class="fe op oq or lx b">first_name</code>的类型定义为字符串，我们需要使用<code class="fe op oq or lx b"><a class="ae kz" href="https://doc.rust-lang.org/std/string/trait.ToString.html" rel="noopener ugc nofollow" target="_blank">to_string</a></code>将其转换为字符串。</p><p id="96f5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们将<strong class="lc iv">关联函数</strong>放入<code class="fe op oq or lx b">impl</code>块中。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ny nz l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">在线试用<a class="ae kz" href="https://tech.io/snippet/qATByFz" rel="noopener ugc nofollow" target="_blank"> Rust impl </a>。</p></figure><p id="f6fb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">方法参数 self、&amp; self 和&amp; mut self </strong></p><p id="8348" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们在<code class="fe op oq or lx b">impl Person</code>中增加了一个<a class="ae kz" href="https://doc.rust-lang.org/book/ch05-03-method-syntax.html#method-syntax" rel="noopener ugc nofollow" target="_blank">方法</a> <code class="fe op oq or lx b">full_name</code>。该函数将<code class="fe op oq or lx b">&amp;self</code>作为第一个参数。它可以采用<code class="fe op oq or lx b">self</code>、<code class="fe op oq or lx b">&amp;self</code>或<code class="fe op oq or lx b">&amp;mut self</code>中的一种。</p><ul class=""><li id="a283" class="ob oc iu lc b ld le lg lh lj od ln oe lr of lv og oh oi oj bi translated">当我们想要读取结构中的数据，而不是写入数据时，我们使用<code class="fe op oq or lx b">&amp;self</code>。</li><li id="9087" class="ob oc iu lc b ld ok lg ol lj om ln on lr oo lv og oh oi oj bi translated">当我们希望方法获得所有权时，我们使用<code class="fe op oq or lx b">self</code>。</li><li id="4ea5" class="ob oc iu lc b ld ok lg ol lj om ln on lr oo lv og oh oi oj bi translated">当我们想让方法写入时，我们使用<code class="fe op oq or lx b">&amp;mut self</code>。</li></ul><p id="5ea3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们在<code class="fe op oq or lx b">p.full_name()</code>中的实例方法中使用点运算符来访问该字段。</p><p id="b07d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们将<code class="fe op oq or lx b">struct</code>和<code class="fe op oq or lx b">impl</code>用于我们的代码:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ny nz l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">使用 struct 和 impl 在线尝试<a class="ae kz" href="https://tech.io/snippet/tmTVm01" rel="noopener ugc nofollow" target="_blank">。</a></p></figure><h1 id="2c53" class="mi mc iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">特点</h1><p id="c263" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated"><a class="ae kz" href="https://blog.rust-lang.org/2015/05/11/traits.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lc iv">特性</strong> </a>类似于 OOP 语言中的<strong class="lc iv"> </strong>和<strong class="lc iv">接口</strong>。它们用于定义一个类型必须提供的功能。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ny nz l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">尝试使用 trait 在线编写代码。</p></figure><p id="c3e6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们用函数<code class="fe op oq or lx b">unique_paths</code>添加了一个名为 UiquePaths 的特征。我们需要使用<code class="fe op oq or lx b">impl trait-name for struct-name</code>更新<code class="fe op oq or lx b">impl</code>。</p><p id="6812" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们使用<code class="fe op oq or lx b">::</code>符号在<code class="fe op oq or lx b">main</code>函数中实例化它。</p><p id="b64a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在我们实现了<code class="fe op oq or lx b">struct</code>、<code class="fe op oq or lx b">impl</code>和<code class="fe op oq or lx b">trait</code>。</p><h1 id="7e45" class="mi mc iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">运行时和内存使用</h1><p id="10f0" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">以下解决方案针对 LeetCode 环境进行了调整。</p><pre class="kk kl km kn gu lw lx ly lz aw ma bi"><span id="a290" class="mb mc iu lx b gz md me l mf mg">impl Solution {<br/>    pub fn unique_paths(m: i32, n: i32) -&gt; i32 {<br/>        if m == 1 || n == 1 {<br/>            1<br/>        } else {<br/>            let mut dpm = vec![1; m as usize];<br/>            let mut dpn = vec![1; n as usize];<br/>            for i in 1..dpm.len() {<br/>                for j in 1..dpn.len() {<br/>                    dpn[j] += dpn[j-1];<br/>                }<br/>            }<br/>            *dpn.last().unwrap()<br/>        }   <br/>    }<br/>}</span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj pi"><img src="../Images/eaa61a5e9d7f46d2a92e20ec3b94f991.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4xUb2lHMUlV0DHCjrf1xDQ.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">铁锈的 LeetCode 结果</p></figure><p id="833a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">请注意运行时间 0 毫秒。Rust 没有运行时间。Rust 适用于<strong class="lc iv">零</strong> - <strong class="lc iv">成本抽象。你不必为某些强大的抽象或安全特性付出额外的运行时开销，而在其他语言中你必须为此付出运行时成本。</strong></p><blockquote class="os"><p id="613e" class="ot ou iu bd ov ow ox oy oz pa pb lv dk translated">…迭代器虽然是一种高级抽象，但会被编译成大致相同的代码，就好像您自己编写了低级代码一样。迭代器是 Rust 的<em class="pc">零成本抽象</em>之一，我们的意思是使用抽象不会带来额外的运行时开销。— <a class="ae kz" href="https://doc.rust-lang.org/book/ch13-04-performance.html?highlight=zero-cost,abstractions#comparing-performance-loops-vs-iterators" rel="noopener ugc nofollow" target="_blank"> Rust 编程语言</a></p></blockquote><p id="fa05" class="pw-post-body-paragraph la lb iu lc b ld pd jv lf lg pe jy li lj pf ll lm ln pg lp lq lr ph lt lu lv in bi translated">Rust 的内存使用量为 2.1 MB，而 Python 的内存使用量为 13.8 MB。</p><p id="7da2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Rust 有独特的管理堆内存的方式，它使用一个叫做所有权的概念来管理它。我建议您深入阅读<a class="ae kz" href="https://doc.rust-lang.org/book/title-page.html" rel="noopener ugc nofollow" target="_blank"> Rust 文档</a>以了解更多信息。</p><h1 id="d7d1" class="mi mc iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">结论</h1><p id="bb59" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">我们接触了原始数据类型、类型注释、函数、语句、表达式、变量、宏、if 语句、范围、数组、元组、向量、<code class="fe op oq or lx b">struct</code>、<code class="fe op oq or lx b">impl</code>和<code class="fe op oq or lx b">trait</code>的表面。你可以在官方书籍中找到更多信息。</p><p id="a256" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">正如我之前所说，我仍然在学习生锈。我感谢专家对如何改进解决方案的反馈。</p><p id="0203" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我希望你学到了一些东西，并为下一步做好了准备。有许多关键概念我们无法在本文中涵盖。请继续关注下一篇文章。</p></div><div class="ab cl pj pk hy pl" role="separator"><span class="pm bw bk pn po pp"/><span class="pm bw bk pn po pp"/><span class="pm bw bk pn po"/></div><div class="in io ip iq ir"><p id="ce50" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">通过</strong> <a class="ae kz" href="https://blog.codewithshin.com/membership" rel="noopener ugc nofollow" target="_blank"> <strong class="lc iv">成为</strong> </a> <strong class="lc iv">的会员，可以完全访问媒体上的每一个故事。</strong></p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj pq"><img src="../Images/0be3ee559fee844cb75615290e4a8b29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*DjTM9iFtVc2wlcWcOms7VQ.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://blog.codewithshin.com/subscribe" rel="noopener ugc nofollow" target="_blank">https://blog.codewithshin.com/subscribe</a></p></figure></div><div class="ab cl pj pk hy pl" role="separator"><span class="pm bw bk pn po pp"/><span class="pm bw bk pn po pp"/><span class="pm bw bk pn po"/></div><div class="in io ip iq ir"><div class="kk kl km kn gu nh"><a rel="noopener follow" target="_blank" href="/unsinged-signed-integers-and-casting-in-rust-9a847bfc398f"><div class="ni ab fp"><div class="nj ab nk cl cj nl"><h2 class="bd iv gz z fq nm fs ft nn fv fx it bi translated">无符号、有符号整数和 Rust 中的造型</h2><div class="no l"><h3 class="bd b gz z fq nm fs ft nn fv fx dk translated">理解符号和幅度、一的补码和二的补码</h3></div><div class="np l"><p class="bd b dl z fq nm fs ft nn fv fx dk translated">towardsdatascience.com</p></div></div><div class="nq l"><div class="pr l ns nt nu nq nv kt nh"/></div></div></a></div><div class="ne nf gq gs ng nh"><a href="https://medium.com/series/101-rust-tips-8f361510683c" rel="noopener follow" target="_blank"><div class="ni ab fp"><div class="nj ab nk cl cj nl"><h2 class="bd iv gz z fq nm fs ft nn fv fx it bi translated">学习生锈:常见概念</h2><div class="no l"><h3 class="bd b gz z fq nm fs ft nn fv fx dk translated">查看更多关于 Rust String 的信息。</h3></div><div class="np l"><p class="bd b dl z fq nm fs ft nn fv fx dk translated">medium.com</p></div></div><div class="nq l"><div class="ps l ns nt nu nq nv kt nh"/></div></div></a></div><div class="ne nf gq gs ng nh"><a href="https://medium.com/series/learning-rust-all-about-strings-c7666812d893" rel="noopener follow" target="_blank"><div class="ni ab fp"><div class="nj ab nk cl cj nl"><h2 class="bd iv gz z fq nm fs ft nn fv fx it bi translated">学习生锈:所有关于字符串</h2><div class="no l"><h3 class="bd b gz z fq nm fs ft nn fv fx dk translated">字符串和&amp;str</h3></div><div class="np l"><p class="bd b dl z fq nm fs ft nn fv fx dk translated">medium.com</p></div></div><div class="nq l"><div class="pt l ns nt nu nq nv kt nh"/></div></div></a></div></div></div>    
</body>
</html>