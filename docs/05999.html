<html>
<head>
<title>Apriori Algorithm Tutorial</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Apriori 算法教程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/apriori-algorithm-tutorial-2e5eb1d896ab?source=collection_archive---------21-----------------------#2020-05-16">https://towardsdatascience.com/apriori-algorithm-tutorial-2e5eb1d896ab?source=collection_archive---------21-----------------------#2020-05-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c655" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关系数据库上的数据挖掘和关联规则</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ba112b2a37caaa1ca6f9ae345a75ce39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-4cnnpMhGMrrQPlZY7DuTA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://unsplash.com/photos/stpjHJGqZyw" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/photos/stpjHJGqZyw</a></p></figure><p id="aad9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关联规则的主要目标是识别数据集中产品或变量之间的关系。这个想法是为了确定哪些产品经常在一起。例如，它被广泛应用于市场购物篮分析，分析师从一个包含所有交易的数据库开始，试图确定哪些产品以何种频率组合在一起，等等。</p><p id="3ff0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些信息有助于优化商店中各种产品的位置，或者在某种产品打折时制定销售计划。</p><p id="f61e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Apriori 算法是最流行的关联规则挖掘算法。它在数据库中查找最频繁的组合，并根据 3 个重要因素确定项目之间的关联规则:</p><ol class=""><li id="4b60" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><strong class="lb iu">支持度</strong>:X 和 Y 走到一起的概率</li><li id="9fc1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">置信度</strong>:Y 知道 X 的条件概率，换句话说，X 先发生的时候，Y 发生的频率。</li><li id="b6de" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">提升</strong>:支持度和信心度之比。提升 2 意味着同时购买 X 和 Y 的可能性是只购买 Y 的可能性的 2 倍。</li></ol><p id="1aae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在实践中，至少 1 的提升对于被认为相关的规则是必要的。</p><p id="50bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是使用 mlxtend 库实现的 apriori 算法。首先，让我们导入库并查看数据，这些数据来自一家餐馆的交易。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="0cfd" class="mo mp it mk b gy mq mr l ms mt">from mlxtend.frequent_patterns import apriori, association_rules</span><span id="be6e" class="mo mp it mk b gy mu mr l ms mt">df.head(15)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/daea766c73a4de6315f05c08a14581fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/1*TbFSf-E3MwV_-62Kj2PVNw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">数据帧的快照</p></figure><p id="2659" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该数据集包含 30，000 多行和大约 9，000 个事务。对于每笔交易(可以跨越多行)，对我们来说重要的是交易中包含的产品。</p><p id="8a73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们要做的第一件事是改变数据的结构，这样每个事务都变成一行。我们将对产品名称使用 unstack 函数，这样数据库中所有可能的产品都成为一列。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="ac49" class="mo mp it mk b gy mq mr l ms mt">tl = df.unstack(level='productName').fillna(0)</span></pre><p id="a83a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，对于每一笔交易，我们想知道一个产品是在(1)还是不在(0)。我们不关心产品的数量，只关心它是否出现在交易中。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="0e0d" class="mo mp it mk b gy mq mr l ms mt">#<strong class="mk iu">Function </strong><br/>def presence(x): <br/>    if(x&lt;= 0): <br/>        return 0<br/>    if(x&gt;= 1): <br/>        return 1</span><span id="0b1e" class="mo mp it mk b gy mu mr l ms mt"><strong class="mk iu">#Apply function <br/></strong>tl_encoded = tl.applymap(presence)</span></pre><p id="34a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以使用 apriori 函数构建模型，并使用 association_rules 函数收集所有满足最小支持度 0.01 的推断规则。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="f7cc" class="mo mp it mk b gy mq mr l ms mt"><strong class="mk iu"># Building the model <br/></strong>frq_items = apriori(tl_encoded, min_support = 0.01, use_colnames = True) <br/>  <br/><strong class="mk iu"># Collecting the inferred rules in a dataframe <br/></strong>rules = association_rules(frq_items, metric ="lift", min_threshold = 1) </span></pre><p id="896b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段代码将返回如下 frozensets:</p><p id="c6f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mw mx my mk b">[frozenset({'crpes sucre', 'Jus d'orange,'})]</code></p><p id="3497" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我个人觉得使用列表要方便得多。下面是进行转换并创建一个包含 apriori 算法创建的所有关联规则的数据帧的代码。</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="7383" class="mo mp it mk b gy mq mr l ms mt"><strong class="mk iu">#Sort the rules <br/></strong>rules = rules.sort_values(['lift'], ascending =[False])</span><span id="4662" class="mo mp it mk b gy mu mr l ms mt"><strong class="mk iu">#From Frozenset to string<br/></strong>rules["antecedents"] = rules["antecedents"].apply(lambda x: list(x)[0]).astype("unicode")<br/>rules["consequents"] = rules["consequents"].apply(lambda x: list(x)[0]).astype("unicode")</span><span id="7b79" class="mo mp it mk b gy mu mr l ms mt"><strong class="mk iu">#Table with most relevant rules<br/></strong>print(rules.sort_values('lift', ascending=False).nlargest(10, 'lift'))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/a756623f12047e9419e405fcbb46f355.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*egE2sMlTI3e6HfHRcSGtqQ.png"/></div></div></figure><p id="b42d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们解释一下第一条规则。它说，当加糖的薄饼在交易时，橙汁也经常来。3.22 的升力意味着一起购买薄饼和橙汁的可能性是只购买橙汁的可能性的 3.22 倍。0.01 的支持意味着它们一起出现在所有交易的 1%左右的交易中。</p><p id="db75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些信息可能有助于为客户创造新的优惠。例如，我们可以买一个可丽饼，买一杯半价的橙汁。</p><p id="220a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">非常感谢你的阅读！</p></div></div>    
</body>
</html>