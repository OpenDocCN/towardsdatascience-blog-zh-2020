<html>
<head>
<title>Intermediate Python: NumPy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">中级 Python: NumPy</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/intermediate-python-numpy-cec1c192b8e6?source=collection_archive---------19-----------------------#2020-01-02">https://towardsdatascience.com/intermediate-python-numpy-cec1c192b8e6?source=collection_archive---------19-----------------------#2020-01-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5f5b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过探索数字 Python 库 NumPy，让您的 Python 技能更上一层楼。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9ab1a9ee63e38d8e4e8ca5bf8bdd62eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MGrp7LvYlibzdS8kgw9GzA.jpeg"/></div></div></figure><p id="86ad" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您最近完成了一门关于 Python 基础的课程或一本书，现在想知道下一步去哪里，探索不同的 Python 包将是一个自然的下一步。NumPy 包(<em class="lq">数字 Python </em>的缩写)非常简单，但也非常有用，尤其是对于科学计算、数据科学和机器学习应用程序。</p><p id="5be0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">许多数据分析和机器学习 Python 库都是建立在 NumPy 之上的，因此掌握这些基础知识对于成功利用这些库至关重要。本文并不打算作为 NumPy 的全面或深入的资源。更确切地说，这更多的是对这个包的介绍，对于那些可能想探索科学或数据科学应用程序的 Python 新手来说，这是一种正确方向的推动。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="521e" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">先决条件</h1><p id="c353" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">要理解本文中的代码片段，显然需要在机器上安装 Python 和 NumPy 包。命令<code class="fe mv mw mx my b">pip install numpy</code>应该可以解决问题，但是如果你有任何问题，<a class="ae mz" href="https://www.numpy.org" rel="noopener ugc nofollow" target="_blank"> NumPy 站点</a>可以在入门部分帮助你设置。</p><p id="b6c0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，我建议使用 Jupyter 笔记本或 Spyder 中的 IPython 控制台来跟进，但 IDLE 也可以。Jupyter 和 Spyder 附带了<a class="ae mz" href="https://www.anaconda.com/distribution/" rel="noopener ugc nofollow" target="_blank"> Anaconda，你可以在这里</a>下载，这个包应该已经安装了 NumPy。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="10e7" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">为什么是 NumPy？</h1><p id="9feb" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">使用 NumPy 包的最大优点之一是 ndarray (n 维数组)数据结构。NumPy <code class="fe mv mw mx my b">ndarray </code>比 python <code class="fe mv mw mx my b">list</code>强大得多，并且提供了比 python <code class="fe mv mw mx my b">array</code>更多种类的操作和功能。为了理解这些优势，我们首先需要深入了解 Python 的基本数据类型。</p><p id="d963" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Python 是一种动态类型的语言，这是它易于使用的特性之一。Python 允许我们给一个变量赋一个整数值，然后将同一个变量重新赋给不同的类型(比如字符串):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="6aa5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，在像 C++这样的静态类型语言中，要给一个变量赋值，我们首先必须给这个变量分配一个类型。在变量被声明后，我们不能将它的值重新赋值给不同类型的值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="249d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种动态类型功能非常方便，但也有代价。Python 是用 C 实现的，Python 中的基本数据类型实际上不是原始数据类型，而是指向包含许多不同值的 C 结构的指针。存储在像<code class="fe mv mw mx my b">integer</code>这样的 Python 数据类型中的额外信息是允许动态类型化的，但是会带来很大的开销，当处理非常大量的数据时，性能成本会变得很明显。</p><p id="95f7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">高灵活性和高性能成本同样适用于 Python <code class="fe mv mw mx my b">lists</code>。因为<code class="fe mv mw mx my b">lists</code>可以是异构的(在同一个列表中包含不同的数据类型)，所以<code class="fe mv mw mx my b">list</code>中的每个元素都包含自己的类型和引用信息，就像 Python 对象一样。异构列表将从这种结构中受益，但是当列表中的所有元素都是相同的基本类型时，存储的类型信息变成了多余的，浪费了宝贵的内存。</p><p id="7ffe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Python <code class="fe mv mw mx my b">arrays</code>在存储统一数据类型方面比<code class="fe mv mw mx my b">lists</code>高效得多，但是 NumPy <code class="fe mv mw mx my b">ndarray</code>提供了<code class="fe mv mw mx my b">arrays</code>没有的功能(例如矩阵和向量运算)。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="4344" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">数组创建</h1><p id="0323" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">首先，检查您是否安装了 NumPy 导入并检查您的版本至少是 1.8。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/97eb053e38fec010a4ed06c1594c92ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:414/format:webp/1*1Md88lgPNAO8AHz-0Uo0yw.png"/></div></figure><blockquote class="nd ne nf"><p id="c3e6" class="ku kv lq kw b kx ky ju kz la lb jx lc ng le lf lg nh li lj lk ni lm ln lo lp im bi translated"><strong class="kw iu">注意</strong>:你可以直接<code class="fe mv mw mx my b"><em class="it">import numpy</em></code>而不是导入为<code class="fe mv mw mx my b"><em class="it">np</em></code>，但是对于教程的其余部分，无论你在哪里看到<code class="fe mv mw mx my b"><em class="it">np</em></code>，都用<code class="fe mv mw mx my b"><em class="it">numpy</em></code>代替就可以了(例如<code class="fe mv mw mx my b"><em class="it">np.array()</em></code> → <code class="fe mv mw mx my b"><em class="it">numpy.array()</em></code>)。此外，当使用术语“数组”或“ndarray”时，我可能会有点不一致，所以请记住这些术语指的是同一个东西。</p></blockquote><p id="f5c6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在让我们看看如何用 NumPy 创建多维数组(ndarrays)。既然我们将 ndarrays 与 Python 列表进行了比较，那么首先让我们看看 NumPy 如何让我们从列表中创建一个数组:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/1b5c52b1e3044d387c68f1e310ba1aab.png" data-original-src="https://miro.medium.com/v2/resize:fit:670/format:webp/1*OA1SRDxjgCfJKSL31cUTqA.png"/></div><p class="nk nl gj gh gi nm nn bd b be z dk translated">从 Python 列表创建数组</p></figure><p id="a074" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将 Python 列表<code class="fe mv mw mx my b">[1,1,2,3,5,8,13]</code>传递给<code class="fe mv mw mx my b">np.array()</code>会创建一个 32 位整数值的 ndarray。ndarrays 中保存的值将始终属于同一类型。对于所有 ndar array，<code class="fe mv mw mx my b">.dtype</code>属性将返回数组保存的值的数据类型。** <a class="ae mz" href="https://numpy.org/devdocs/user/basics.types.html" rel="noopener ugc nofollow" target="_blank">关于数据类型的 Numpy 文档</a></p><p id="0eb2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们将包含不同类型值的<code class="fe mv mw mx my b">list</code>传递给<code class="fe mv mw mx my b">np.array()</code>，NumPy 将向上转换这些值，这样它们就可以是相同的类型:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/f3009c7d39c9ad14b03ee9b5d6a6b20d.png" data-original-src="https://miro.medium.com/v2/resize:fit:638/format:webp/1*SclIOHxz-IY7KXRXuAgipA.png"/></div><p class="nk nl gj gh gi nm nn bd b be z dk translated">传递给 array()方法的列表包含整数和浮点数。从此列表创建的数组将整数转换为浮点数，以便所有值都是同一类型。</p></figure><p id="9500" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">* *注意:请确保当您调用<code class="fe mv mw mx my b">array()</code>时，您提供了一个数字列表作为单个参数:<code class="fe mv mw mx my b">np.array( [1,2,3] )</code>，而不仅仅是数字作为多个参数:<code class="fe mv mw mx my b">np.array( 1,2,3 )</code>；这是一个非常常见的错误。</p><p id="9459" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">NumPy 还允许您在使用<code class="fe mv mw mx my b">dtype</code>参数创建数组时显式指定数组的数据类型:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/9dcac667ebd9b0f51e0905972866af51.png" data-original-src="https://miro.medium.com/v2/resize:fit:712/format:webp/1*q3S5F6mN_LmYoviBywdang.png"/></div><p class="nk nl gj gh gi nm nn bd b be z dk translated">数组中的值最初是作为整数输入的，但是通过将数据类型指定为 float ( <strong class="bd nq"> dtype = float </strong>)，Numpy 将所有值都转换为 float(例如 1 → 1.0).</p></figure><p id="b4d8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">创建时知道数组的大小，但不知道数组的内容是很常见的。在这种情况下，NumPy 允许创建具有占位符值的指定大小的数组:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/916a21d8e34983836305c7dc174c21ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:622/format:webp/1*ewg0_X-qzCQ4uLYHuqWXuw.png"/></div><p class="nk nl gj gh gi nm nn bd b be z dk translated">用<strong class="bd nq"> np.zeros( ) </strong>将所有值初始化为 0 的 3x3 数组。</p></figure><p id="81a0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mv mw mx my b">np.ones()</code>和<code class="fe mv mw mx my b">np.empty()</code>也可以分别用于返回全 1 或不初始化条目的数组。如果您想指定一个值作为占位符，请使用<code class="fe mv mw mx my b">np.full(size, <strong class="kw iu">placeholder</strong>)</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/57117ecf081644e902fb1db116c293ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:434/format:webp/1*pmu-qqDPfsET_SSia0G7aQ.png"/></div></figure><p id="b64d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">数组也可以用<em class="lq">随机</em>值初始化。使用<code class="fe mv mw mx my b">np.random.random(s)</code>你可以创建一个大小为<code class="fe mv mw mx my b">s</code>的数组，用 0 到 1 之间的随机值填充。传递一个整数值将产生一个该长度的一维数组:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/dafbde5365b3dbbd4b8685a46634eace.png" data-original-src="https://miro.medium.com/v2/resize:fit:760/format:webp/1*MSC0Fb3wnyGr7HCxb5Y-nA.png"/></div><p class="nk nl gj gh gi nm nn bd b be z dk translated">长度为 5 的一维数组。</p></figure><p id="1240" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可以传递更高维数组的维度:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/97481cf1e61c33430e6e1ad1d9462c59.png" data-original-src="https://miro.medium.com/v2/resize:fit:694/format:webp/1*_WF1Ts0pDQculnRWvA0bsw.png"/></div><p class="nk nl gj gh gi nm nn bd b be z dk translated">传递(3，3)会产生一个二维的 3x3 数组，而传递(2，2，2)会产生一个三维的 2x2x2 数组。</p></figure><p id="d619" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你想要一个随机整数值的数组，使用<code class="fe mv mw mx my b">np.random.randint(min, max, size)</code>。指定<code class="fe mv mw mx my b">min</code>的最小值、<code class="fe mv mw mx my b">max</code>的最大值，当然还有<code class="fe mv mw mx my b">size</code>的数组大小，就像我们对<code class="fe mv mw mx my b">np.random.random()</code>所做的那样。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/d2defaab732dbefc3a32876ce404c596.png" data-original-src="https://miro.medium.com/v2/resize:fit:862/format:webp/1*e-O-yq-XMR8EJ2sf7cKyGA.png"/></div><p class="nk nl gj gh gi nm nn bd b be z dk translated"><strong class="bd nq"> In[32] </strong>:二维 3x3 数组的取值范围在 0 到 25 之间。<strong class="bd nq"> In[33] </strong>:一维 10x1 数组的范围在-50 到 50 之间。</p></figure><p id="5082" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">还有许多其他非常有用的创建 ndarrays 的方法，包括:</p><ul class=""><li id="02b3" class="nw nx it kw b kx ky la lb ld ny lh nz ll oa lp ob oc od oe bi translated">在给定范围内用<em class="lq"> </em> <strong class="kw iu">等间距</strong>值填充</li><li id="f591" class="nw nx it kw b kx of la og ld oh lh oi ll oj lp ob oc od oe bi translated">在一个正态分布<em class="lq"> </em> <strong class="kw iu">上用随机数填充一个数组</strong></li><li id="da09" class="nw nx it kw b kx of la og ld oh lh oi ll oj lp ob oc od oe bi translated">创建一个<strong class="kw iu">身份矩阵</strong></li></ul><p id="23b1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您感兴趣，请查看<a class="ae mz" href="https://docs.scipy.org/doc/numpy-1.15.1/reference/routines.array-creation.html" rel="noopener ugc nofollow" target="_blank">数组创建文档</a>,探索这些数组创建例程以及许多其他例程。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="4d58" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">数组操作</h1><p id="4e20" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">创建数组很好，但是 NumPy 真正出色的地方是使用数组进行操作和计算的方法。这些方法不仅简单易用，而且当涉及到基于元素的操作(尤其是在大型数组上)时，这些方法具有非常出色的性能——比遍历每个元素的性能好得多，就像通常不使用 NumPy 时所做的那样。</p><p id="71bc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mv mw mx my b">ndarray</code>对象允许我们对两个相同大小的数组执行算术运算<em class="lq">和</em>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/0970e79954bc26aeb63833831448d5a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:588/format:webp/1*pDXVKgX3ftOTesMua451Kw.png"/></div><p class="nk nl gj gh gi nm nn bd b be z dk translated">从<strong class="bd nq"> a </strong>中对应的元素中减去<strong class="bd nq"> b </strong>中的每个元素。同样，请注意，结果数组中的所有值都是浮点型的，因为正如我们在数组创建示例中看到的那样，整数被转换为浮点型。</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/37a0129f1637afde86e026afdc48ab34.png" data-original-src="https://miro.medium.com/v2/resize:fit:658/format:webp/1*AZU2bfGfAdYcHmG0bgETpQ.png"/></div><p class="nk nl gj gh gi nm nn bd b be z dk translated">在两个 ndarrays 上使用<strong class="bd nq"> + </strong>运算符产生元素相加。</p></figure><p id="dccc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请记住，在两个<code class="fe mv mw mx my b">lists</code>之间使用<code class="fe mv mw mx my b">+</code>操作符不会将它们按元素相加。这实际上导致了两个<code class="fe mv mw mx my b">lists</code>的串联。此外，如果我们试图在两个<code class="fe mv mw mx my b">lists</code>之间使用<code class="fe mv mw mx my b">-</code>操作符，Python 将返回一个错误，因为<code class="fe mv mw mx my b">lists</code>在没有使用 for 循环显式声明的情况下，自然不允许元素操作。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi om"><img src="../Images/05baba385e3b2a884cad24091e62e1b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/0*5e-opkkzTfnv-M2m.png"/></div><p class="nk nl gj gh gi nm nn bd b be z dk translated">语句<strong class="bd nq"> list_a + list_b </strong>连接两个列表，而<strong class="bd nq"> list_a -list_b </strong>返回一个错误。</p></figure><h2 id="511f" class="on lz it bd ma oo op dn me oq or dp mi ld os ot mk lh ou ov mm ll ow ox mo oy bi translated">元素方式与矩阵乘法</h2><p id="348c" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">如果你以前用过 MATLAB，你就会知道使用 n 维数组和矩阵是多么容易。NumPy 在提供一些方便的功能方面做得很好，并且对于 MATLAB 用户来说，可能比使用基本的 Python 更加熟悉。</p><p id="81e9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">MATLAB 中的矩阵乘法就像在两个矩阵上使用<code class="fe mv mw mx my b">*</code>运算符一样简单(例如<code class="fe mv mw mx my b">a * b</code>)。使用 NumPy，<code class="fe mv mw mx my b">*</code>操作符将实际返回元素级乘法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/64c1f8ef609d0fb878e2072c18361e74.png" data-original-src="https://miro.medium.com/v2/resize:fit:554/format:webp/0*HJghZXh8aepRmXIU.png"/></div></figure><p id="5ff0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于矩阵乘法，<code class="fe mv mw mx my b">@</code>运算符用于<code class="fe mv mw mx my b">arrays</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/ff8ecf20e94687ce3983d4d6addee72d.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/format:webp/0*-wf6w7jCnwZGbLDg.png"/></div></figure></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><blockquote class="nd ne nf"><p id="7c8b" class="ku kv lq kw b kx ky ju kz la lb jx lc ng le lf lg nh li lj lk ni lm ln lo lp im bi translated">而在矩阵乘法这个话题上，NumPy 也有一个<code class="fe mv mw mx my b"><em class="it">matrix</em></code>类，实际上是<code class="fe mv mw mx my b"><em class="it">array</em></code>的子类。<code class="fe mv mw mx my b"><em class="it">array</em></code>类用于一般用途，而<code class="fe mv mw mx my b"><em class="it">matrix</em></code>类用于线性代数计算。文档建议在大多数情况下，您应该使用<code class="fe mv mw mx my b"><em class="it">array</em></code>类，除非您专门从事线性代数计算。如果您想要处理更高维的数组(例如 3-D)，那么<code class="fe mv mw mx my b"><em class="it">array</em></code>类支持这一点，而<code class="fe mv mw mx my b"><em class="it">matrix</em></code>类总是处理 2 维数组。</p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/5b07160a3432c9b2b2bd2b9075a5d72b.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*tjX9qd4n7KFxm7-AXhZFeA.png"/></div><p class="nk nl gj gh gi nm nn bd b be z dk translated">使用 ndarray 类表示的三维数组。</p></figure><blockquote class="nd ne nf"><p id="549a" class="ku kv lq kw b kx ky ju kz la lb jx lc ng le lf lg nh li lj lk ni lm ln lo lp im bi translated">此外，<code class="fe mv mw mx my b"><em class="it">matrix</em></code>类不像<code class="fe mv mw mx my b"><em class="it">array</em></code>那样使用相同的操作。因此对于本文，我们将重点关注<code class="fe mv mw mx my b"><em class="it">array</em></code>类。</p></blockquote></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><p id="3588" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就像两个数组相乘一样，我们可以将一个数组的所有元素都乘以一个数字。NumPy 还使得获取数组的属性变得非常方便，比如数组(<code class="fe mv mw mx my b">ndim</code>)的<strong class="kw iu"> sum </strong>、<strong class="kw iu"> min </strong> / <strong class="kw iu"> max </strong>、<strong class="kw iu"> dimensions </strong>、以及<code class="fe mv mw mx my b">array</code>的<strong class="kw iu"> size </strong>(总元素数)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/47736cc8c4b20d5e0b6e0bb7070c93fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:590/format:webp/1*E_L2wZfKFb7khBhsQPdTbw.png"/></div></figure><p id="26b1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您还可以访问阵列的基本统计值:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/593ca7288a25656d1be3e1724c91bc33.png" data-original-src="https://miro.medium.com/v2/resize:fit:770/format:webp/1*6YERWkkQ8mBV3CrBhQ1L8A.png"/></div><p class="nk nl gj gh gi nm nn bd b be z dk translated">该数组的均值、标准差和方差很容易计算。</p></figure><h2 id="c298" class="on lz it bd ma oo op dn me oq or dp mi ld os ot mk lh ou ov mm ll ow ox mo oy bi translated">根据条件获取元素</h2><p id="5649" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">一个非常酷的<code class="fe mv mw mx my b">numpy</code>类方法是<code class="fe mv mw mx my b">numpy.where()</code>。这允许您从数组中返回满足指定条件的元素。例如，如果您有一个从 0 到 50 的 5x5 整数数组，并且您想知道大于 25 的值在哪里，您可以执行以下操作:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/575e44c4a743bc92f5196a3a40fec236.png" data-original-src="https://miro.medium.com/v2/resize:fit:610/format:webp/1*_F7ubKLsg0vWR8vHCaSjtg.png"/></div><p class="nk nl gj gh gi nm nn bd b be z dk translated"><strong class="bd nq"> np.where( ) </strong>对于保存大于 25 的值的索引返回 1，对于小于等于 25 的值返回 0。这里的<strong class="bd nq"> r </strong>是原数组</p></figure><p id="13a0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你想找到低值(例如&lt; 15) and replace them with a -1:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pf"><img src="../Images/d59ff799e9c3ac9887a93d58803253b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:686/format:webp/1*gfZqESKSKFnO5-sVojnhxg.png"/></div></div><p class="nk nl gj gh gi nm nn bd b be z dk translated">All values less than 15 have been replace with -1. Here <strong class="bd nq"> arr </strong>是原始数组 in Out[71]</p></figure><p id="d033" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可以用这个方法做很多事情，特别是用一点创造性的思维，但是只要记住它是如何工作的:<code class="fe mv mw mx my b">np.where(cond[, x, y])</code>——如果<code class="fe mv mw mx my b">cond</code>条件满足，返回<code class="fe mv mw mx my b">x</code>，否则返回<code class="fe mv mw mx my b">y</code>。</p><h2 id="5430" class="on lz it bd ma oo op dn me oq or dp mi ld os ot mk lh ou ov mm ll ow ox mo oy bi translated">索引、切片和整形</h2><p id="505d" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">步进的工作原理与<code class="fe mv mw mx my b">lists</code>相同:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/3703eb4bd6b0d60028948e0ad4ff4c34.png" data-original-src="https://miro.medium.com/v2/resize:fit:596/format:webp/1*QRFt4rfTZHWv-9pqdOYkow.png"/></div><p class="nk nl gj gh gi nm nn bd b be z dk translated">这里我们创建一个填充了 0 的三维数组，然后将索引<strong class="bd nq"> arr_3d[0][0][1] </strong>的值重新赋值为 20。</p></figure><p id="7efc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要检查数组中是否有值，可以像使用<code class="fe mv mw mx my b">lists</code>一样使用<code class="fe mv mw mx my b">in</code>关键字:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/939844bf3fe7caf1fd4710350bc068a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:372/format:webp/1*Rs6AnmSAi4fN92Pt8WPmng.png"/></div></figure><p id="112d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">切片与<code class="fe mv mw mx my b">arrays</code>一起工作，就像它与<code class="fe mv mw mx my b">lists</code>一样，并且<code class="fe mv mw mx my b">arrays</code>可以在多个维度上切片:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/caadfb99e260f05e5cb9992fc0e2ed93.png" data-original-src="https://miro.medium.com/v2/resize:fit:658/format:webp/1*Bkg6mBzJlG8BjW7wnd1ULA.png"/></div><p class="nk nl gj gh gi nm nn bd b be z dk translated"><strong class="bd nq"> In[8] </strong>:每行前 3 列。<strong class="bd nq">【9】:</strong>每列前 3 行。<strong class="bd nq"> In[10] </strong>:第 2 列所有项目。</p></figure><p id="a1d8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在转换方面，NumPy 有很多功能。例如，如果您有一个 3x5 的数组，并且想要<strong class="kw iu">将</strong>调整为 5x3:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/357fc6f2ff175887e06b8885f9d387ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:468/format:webp/1*7ieE39-oGqhx7KkbwFC2cw.png"/></div><p class="nk nl gj gh gi nm nn bd b be z dk translated">若要调整数组的形状，请将所需的维度传递给 shape()方法。</p></figure><p id="16bb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您也可以使用<code class="fe mv mw mx my b">array.T</code>将<strong class="kw iu">转置</strong> <code class="fe mv mw mx my b">arrays</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/93220796037fefc78543b519e04e40aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:846/format:webp/1*r2EDMqqaJXoSgol_ynauFw.png"/></div><p class="nk nl gj gh gi nm nn bd b be z dk translated">数组<strong class="bd nq"> r </strong>是 12x1 数组<strong class="bd nq"> p </strong>的整形，为 3x4 数组。数组<strong class="bd nq"> q </strong>是 r 的<strong class="bd nq">转置</strong>，通过使用<strong class="bd nq"> </strong> <code class="fe mv mw mx my b"><strong class="bd nq">r.T</strong></code></p></figure><p id="1e2c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mv mw mx my b">Arrays</code>也可以使用<code class="fe mv mw mx my b">np.transpose(a)</code>进行转置，其中<code class="fe mv mw mx my b">a</code>是您想要转置的数组。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><p id="bfd6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们只是触及了 NumPy 库的皮毛，如果你想知道你还能做什么，<a class="ae mz" href="https://docs.scipy.org/doc/numpy/index.html" rel="noopener ugc nofollow" target="_blank">官方文档</a>有一个很棒的入门指南，当然，你可以在那里探索库的其余部分。如果您想使用 Python 进行科学计算、机器学习或数据科学，NumPy 是您应该真正熟悉的库之一。</p><p id="675b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是我推荐的其他几个相关的 Python 库，它们被认为是这个领域的核心:</p><ul class=""><li id="b450" class="nw nx it kw b kx ky la lb ld ny lh nz ll oa lp ob oc od oe bi translated"><a class="ae mz" href="https://scipy.org/scipylib/index.html" rel="noopener ugc nofollow" target="_blank"> SciPy </a></li><li id="ab6e" class="nw nx it kw b kx of la og ld oh lh oi ll oj lp ob oc od oe bi translated">熊猫</li><li id="0162" class="nw nx it kw b kx of la og ld oh lh oi ll oj lp ob oc od oe bi translated"><a class="ae mz" href="https://matplotlib.org/" rel="noopener ugc nofollow" target="_blank"> Matplotlib </a></li><li id="0d95" class="nw nx it kw b kx of la og ld oh lh oi ll oj lp ob oc od oe bi translated"><a class="ae mz" href="https://scikit-learn.org/stable/" rel="noopener ugc nofollow" target="_blank"> Scikit-Learn </a></li></ul><p id="4b11" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，我将为您提供一些资源，让您继续掌握用于数据科学和科学应用的 Python。</p><p id="4b3d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Jake VanderPlas 著<a class="ae mz" href="https://jakevdp.github.io/PythonDataScienceHandbook/" rel="noopener ugc nofollow" target="_blank"><strong class="kw iu">《Python 数据科学手册》</strong> </a> <strong class="kw iu"> </strong> —这是一本真正优秀的数据科学入门入门读物。他还从一开始就介绍了 NumPy，但比本文详细得多。</p><p id="c38d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae mz" href="https://www.amazon.com/Hands-Machine-Learning-Scikit-Learn-TensorFlow/dp/1492032646/ref=pd_sbs_14_img_2/137-9753835-6236819?_encoding=UTF8&amp;pd_rd_i=1492032646&amp;pd_rd_r=64a4562d-7e7a-43c1-a234-1022743cb01c&amp;pd_rd_w=uasXi&amp;pd_rd_wg=FL8ji&amp;pf_rd_p=5cfcfe89-300f-47d2-b1ad-a4e27203a02a&amp;pf_rd_r=P3HGR2WXDBN7ZGB4Q91Z&amp;psc=1&amp;refRID=P3HGR2WXDBN7ZGB4Q91Z" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu">用 Scikit-Learn、Keras&amp;tensor flow by</strong></a><a class="ae mz" href="https://www.amazon.com/Aur%C3%A9lien-G%C3%A9ron/e/B004MOO740/ref=dp_byline_cont_book_1" rel="noopener ugc nofollow" target="_blank"><strong class="kw iu">aurélien géRon</strong></a>——如果你真的对机器学习和深度学习感兴趣，这本书可能是入门最常推荐的书。</p><p id="59fe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae mz" href="https://towardsdatascience.com/" rel="noopener" target="_blank"> <strong class="kw iu">走向数据科学</strong> </a> —数据科学、机器学习、AI、通用编程。这是关于媒体的最好的出版物之一，并且是关于数据科学的大量主题的极好资源。</p><p id="8994" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae mz" href="https://www.coursera.org/learn/machine-learning?ranMID=40328&amp;ranEAID=fDhiRyMTeO8&amp;ranSiteID=fDhiRyMTeO8-lab85VbDUwyusQOytt8f1Q&amp;siteID=fDhiRyMTeO8-lab85VbDUwyusQOytt8f1Q&amp;utm_content=10&amp;utm_medium=partners&amp;utm_source=linkshare&amp;utm_campaign=fDhiRyMTeO8#syllabus" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu">斯坦福大学与吴恩达</strong> </a>联合开设的机器学习课程——不完全是专门针对 Python 的，但如果你想真正进入机器学习，并在动手实践的同时钻研一些理论，如果你有时间致力于这门课程，这是一个绝佳的起点。吴恩达很聪明。</p><p id="7a44" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢阅读！</p></div></div>    
</body>
</html>