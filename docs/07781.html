<html>
<head>
<title>5 Ways to Query your Relational DB using JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用JavaScript查询关系数据库的5种方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/5-ways-to-query-your-relational-db-using-javascript-d5499711fc7d?source=collection_archive---------4-----------------------#2020-06-10">https://towardsdatascience.com/5-ways-to-query-your-relational-db-using-javascript-d5499711fc7d?source=collection_archive---------4-----------------------#2020-06-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/203cd62927f51a63b8233739f5b2cbde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*DKvGTtOTpZTjJ40R93YFwg.png"/></div><p class="jx jy gj gh gi jz ka bd b be z dk translated">图片在Shutterstock.com<a class="ae kb" href="http://shutterstock.com/" rel="noopener ugc nofollow" target="_blank">和T2</a><a class="ae kb" href="http://shutterstock.com/" rel="noopener ugc nofollow" target="_blank">的许可下使用</a></p></figure><p id="7b4b" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">如果您正在开发web应用程序，您几乎肯定会不断地与数据库进行交互。当需要选择<em class="la">方式</em>互动时，选择会让人不知所措。</p><p id="1da9" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">在本文中，我们将详细探讨使用JavaScript与数据库交互的5种不同方式，并讨论每种方式的优缺点。我们将从最底层的选择——SQL命令——开始，然后进入更高层的抽象。</p><p id="b302" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">为JavaScript应用程序选择正确的数据库库会对代码的可维护性、可伸缩性和性能产生很大的影响，所以花一些时间来找出您的选择是值得的。</p><h1 id="e37c" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">我们的示例应用程序</h1><p id="3b1c" class="pw-post-body-paragraph kc kd it ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz im bi translated">我们将使用一个托管在Heroku 上的普通Express应用程序作为例子。本文的所有代码都在这个<a class="ae kb" href="https://github.com/digitalronin/query-database-javascript.git" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中。随意克隆它并跟随它。</p><h1 id="d0d1" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">先决条件</h1><p id="fe72" class="pw-post-body-paragraph kc kd it ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz im bi translated">要运行示例应用程序，您的机器上需要以下软件:</p><ul class=""><li id="794f" class="me mf it ke b kf kg kj kk kn mg kr mh kv mi kz mj mk ml mm bi translated">一个类似unix的终端环境(Mac OSX和Linux都可以。如果你使用的是Windows，你将需要用于Linux的<a class="ae kb" href="https://docs.microsoft.com/en-us/windows/wsl/install-win10" rel="noopener ugc nofollow" target="_blank"> Windows子系统</a>。</li><li id="71f8" class="me mf it ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated"><a class="ae kb" href="https://git-scm.com/" rel="noopener ugc nofollow" target="_blank"> git </a>(还有一个github账号)。</li><li id="ca9b" class="me mf it ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated"><a class="ae kb" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank"> npm </a>(版本6或更高版本)。</li><li id="5c0b" class="me mf it ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated">Heroku <a class="ae kb" href="https://devcenter.heroku.com/articles/heroku-cli" rel="noopener ugc nofollow" target="_blank">命令行工具</a>。</li></ul><p id="a88e" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">如果你还没有Heroku账户，你需要<a class="ae kb" href="https://signup.heroku.com/" rel="noopener ugc nofollow" target="_blank">注册一个免费账户。如果你不想注册Heroku，你也可以在本地Postgres实例上运行应用程序。如果您对此感到满意，应该很容易看到您需要做哪些更改，而不是部署到Heroku。</a></p><p id="7b38" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">一旦你安装了以上所有的东西，在终端中运行<code class="fe ms mt mu mv b">heroku login</code>，你就可以开始了。</p><h1 id="ba73" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">构建和部署Hello World应用程序</h1><p id="cf2c" class="pw-post-body-paragraph kc kd it ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz im bi translated">首先，我们将设置以下内容:</p><ul class=""><li id="6a88" class="me mf it ke b kf kg kj kk kn mg kr mh kv mi kz mj mk ml mm bi translated">一个普通的<a class="ae kb" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> Express </a>应用程序，只提供一个“Hello，World”网页。</li><li id="19e5" class="me mf it ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated">一个Postgres数据库。</li><li id="9d75" class="me mf it ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated">两个表，分别代表“用户”和“评论”(一个用户有很多评论)。</li><li id="fd82" class="me mf it ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated">一些样本数据(在这种情况下，通过<a class="ae kb" href="https://mockaroo.com/" rel="noopener ugc nofollow" target="_blank">mockaroo.com</a>生成)。</li></ul><p id="bbb8" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">我已经创建了一个示例应用程序，它将为您设置所有这些(假设您已经如上所述运行了<code class="fe ms mt mu mv b">heroku login</code>)。要设置它，请从命令行执行以下命令:</p><p id="0cc6" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><code class="fe ms mt mu mv b">git clone <a class="ae kb" href="https://github.com/digitalronin/query-database-javascript.git" rel="noopener ugc nofollow" target="_blank">https://github.com/digitalronin/query-database-javascript.git</a></code></p><p id="3b5a" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><code class="fe ms mt mu mv b">cd query-database-javascript make setup</code></p><p id="a27f" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">这需要几分钟才能完成。在您等待的时候，您可以查看makefile来查看相关的命令，这些命令执行以下操作:</p><ul class=""><li id="df4e" class="me mf it ke b kf kg kj kk kn mg kr mh kv mi kz mj mk ml mm bi translated">创建一个新的Heroku应用程序。</li><li id="ea4e" class="me mf it ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated">添加Postgres数据库实例。</li><li id="51d2" class="me mf it ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated">将应用程序部署到Heroku。</li><li id="7423" class="me mf it ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated">在Heroku上运行一个命令来设置数据库表并导入CSV示例数据。</li><li id="fa52" class="me mf it ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated">在新的浏览器窗口中打开Heroku应用程序的URL。</li></ul><p id="8076" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">在此过程结束时，您应该会在网页上看到“Hello，World”。</p><h1 id="f6c1" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用SQL提取数据</h1><p id="a637" class="pw-post-body-paragraph kc kd it ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz im bi translated">好了，我们都准备好了！我们已经创建了一个包含两个表和一些示例数据的数据库。但是我们还没有做任何事情。下一步是让我们的web应用程序能够从数据库中检索数据。</p><p id="636f" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">无论何时与关系数据库交互，都是通过向数据库正在监听的网络套接字发送SQL命令来实现的。对于本文中我们将要研究的所有库来说都是如此——在最底层，它们都向数据库发送SQL命令，并检索返回的任何输出。</p><p id="606a" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">因此，我们要考虑的与数据库交互的第一种方式就是这样做——发送SQL命令。为此，我们将安装pg JavaScript库，它允许我们向Postgres数据库发送SQL并检索结果。</p><p id="4466" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">要安装pg库，请执行以下命令:</p><p id="be17" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><code class="fe ms mt mu mv b">npm install pg</code></p><p id="42c3" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">这将获取并安装这个库，并将它添加到package.json和package-lock.json文件中。让我们提交这些更改:</p><p id="9e39" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><code class="fe ms mt mu mv b">git add package.json package-lock.json git</code></p><p id="3840" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><code class="fe ms mt mu mv b">commit -m "Install the pg library"</code></p><p id="c139" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">要与我们的数据库对话，我们需要一些详细信息:</p><ul class=""><li id="0aa8" class="me mf it ke b kf kg kj kk kn mg kr mh kv mi kz mj mk ml mm bi translated">运行Postgres的机器的主机名。</li><li id="273b" class="me mf it ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated">Postgres正在监听的网络端口。</li><li id="6d89" class="me mf it ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated">我们的数据所在的数据库的名称。</li><li id="0875" class="me mf it ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated">有权访问数据的用户名和密码。</li></ul><p id="2a54" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">大多数数据库库会让我们建立一个连接，要么通过向库中提供一个对象，该对象包含所有这些细节的键和值，要么通过将它们组合成一个“数据库URL”，这就是我们将要做的。</p><p id="ebeb" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">当您向Heroku应用程序添加数据库时，您会自动获得一个名为DATABASE_URL的环境变量，其中包含连接数据库所需的所有详细信息。您可以通过运行以下命令来查看DATABASE_URL的值:</p><p id="0943" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><code class="fe ms mt mu mv b">heroku config</code></p><p id="8f9f" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">这将输出您的应用程序可以使用的所有环境变量。现在应该只有一个，所以您应该在输出中看到类似这样的内容:</p><p id="8c21" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">数据库_网址:<code class="fe ms mt mu mv b">postgres://clqcouauvejtvw:1b079cad50f3ff9b48948f15a7fa52123bc6795b875348d668864</code> <br/> <code class="fe ms mt mu mv b">07a266c0f5b@ec2-52-73-247-67.compute-1.amazonaws.com:5432/dfb3aad8c026in</code></p><p id="c39a" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">在我们的例子中，分解如下:</p><p id="e221" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">结构化查询语言</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="a910" class="ne lc it mv b gy nf ng l nh ni">{</span><span id="8472" class="ne lc it mv b gy nj ng l nh ni">"hostname": "ec2-52-73-247-67.compute-1.amazonaws.com",</span><span id="f00c" class="ne lc it mv b gy nj ng l nh ni"><br/>"port": 5432,</span><span id="5a69" class="ne lc it mv b gy nj ng l nh ni"><br/>"database": "dfb3aad8c026in",</span><span id="289c" class="ne lc it mv b gy nj ng l nh ni">"username": "clqcouauvejtvw",</span><span id="6fc1" class="ne lc it mv b gy nj ng l nh ni">"password": "1b079cad50f3ff9b48948f15a7fa52123bc6795b875348d66886407a266c0f5b"</span><span id="e225" class="ne lc it mv b gy nj ng l nh ni">}</span></pre><p id="bcb9" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">您的DATABASE_URL值会有所不同，但结构是相同的。</p><p id="abb3" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">现在我们已经安装了pg库，并且我们知道如何连接到我们的数据库，让我们执行我们的第一个与数据库交互的例子。我们将简单地获取用户列表，并将它们显示在我们的网页上。在index.js文件的顶部，我们需要pg库，并创建一个数据库连接对象。</p><p id="b311" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">Java Script语言</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="67b6" class="ne lc it mv b gy nf ng l nh ni">const { Pool } = require('pg');</span><span id="d42a" class="ne lc it mv b gy nj ng l nh ni">const conn = new Pool({ connectionString: process.env.DATABASE_URL });</span></pre><p id="6161" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">在<code class="fe ms mt mu mv b">express()</code>块中，我们将修改get行来调用显示数据库中用户列表的方法:</p><p id="2f10" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><code class="fe ms mt mu mv b">.get('/', (req, res) =&gt; listUsers(req, res))</code></p><p id="6a31" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">最后，我们将实现listUsers函数:</p><p id="29eb" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">Java Script语言</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="d884" class="ne lc it mv b gy nf ng l nh ni">async function listUsers(req, res) {</span><span id="615e" class="ne lc it mv b gy nj ng l nh ni">try {</span><span id="773e" class="ne lc it mv b gy nj ng l nh ni">const db = await conn.connect()</span><span id="a55a" class="ne lc it mv b gy nj ng l nh ni">const result = await db.query('SELECT * FROM users');</span><span id="b67b" class="ne lc it mv b gy nj ng l nh ni">const results = { users: (result) ? result.rows : null};</span><span id="7d1b" class="ne lc it mv b gy nj ng l nh ni">res.render('pages/index', results );</span><span id="0c44" class="ne lc it mv b gy nj ng l nh ni">db.release();</span><span id="ea47" class="ne lc it mv b gy nj ng l nh ni">} catch (err) {</span><span id="c0ac" class="ne lc it mv b gy nj ng l nh ni">console.error(err);</span><span id="dbd2" class="ne lc it mv b gy nj ng l nh ni">res.send("Error " + err);</span><span id="05f1" class="ne lc it mv b gy nj ng l nh ni">}</span><span id="8170" class="ne lc it mv b gy nj ng l nh ni">}</span></pre><p id="bd87" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">这段代码一直等到与我们的数据库建立了连接，然后使用query函数发送一个SQL查询并检索结果。</p><p id="6557" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">现在，这一步可能由于许多不同的原因而失败，所以在代码中，我们进行测试以确保我们获得了一些数据，如果我们获得了一些数据，我们就将result.rows分配给results对象的关键用户。接下来，我们将结果传递给render函数，然后释放数据库连接。</p><p id="5e8f" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">在views/pages/index.ejs中，我们可以访问结果对象，因此我们可以像这样显示我们的用户数据:</p><p id="579d" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">超文本标记语言</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="1b2d" class="ne lc it mv b gy nf ng l nh ni">&lt;h1&gt;Users&lt;/h1&gt;</span><span id="70b6" class="ne lc it mv b gy nj ng l nh ni">&lt;ul&gt;</span><span id="3850" class="ne lc it mv b gy nj ng l nh ni">&lt;% users.map((user) =&gt; { %&gt;</span><span id="16bc" class="ne lc it mv b gy nj ng l nh ni">&lt;li&gt;&lt;%= user.id %&gt; - &lt;%= user.first_name %&gt; &lt;%= user.last_name %&gt;&lt;/li&gt;</span><span id="469a" class="ne lc it mv b gy nj ng l nh ni">&lt;% }); %&gt;</span><span id="73f9" class="ne lc it mv b gy nj ng l nh ni">&lt;/ul&gt;</span></pre><p id="002f" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">你可以在这里看到这些变化的代码<a class="ae kb" href="https://github.com/digitalronin/query-database-javascript/tree/pg" rel="noopener ugc nofollow" target="_blank">。</a> <code class="fe ms mt mu mv b">first_name</code>和<code class="fe ms mt mu mv b">last_name</code>是我们数据库的users表中两列的名称。</p><p id="5332" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">让我们部署这些更改，这样我们就可以在Heroku应用程序中看到数据:</p><p id="9b1c" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><code class="fe ms mt mu mv b">git add index.js views/pages/index.ejs</code></p><p id="776b" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><code class="fe ms mt mu mv b">git commit -m "Display a list of users"</code></p><p id="1041" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><code class="fe ms mt mu mv b">git push heroku master</code></p><p id="136e" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">这将需要一两分钟来部署。当该命令执行完毕后，重新加载您的浏览器，您应该会在网页上看到一个用户列表。</p><h1 id="fbfe" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">MySQL示例</h1><p id="0e6d" class="pw-post-body-paragraph kc kd it ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz im bi translated">上面的例子是针对Postgres的，但是针对其他常见关系数据库的代码也是类似的。例如，如果您使用的是<a class="ae kb" href="https://www.mysql.com/" rel="noopener ugc nofollow" target="_blank"> MySQL </a>:</p><ul class=""><li id="67a1" class="me mf it ke b kf kg kj kk kn mg kr mh kv mi kz mj mk ml mm bi translated">使用<code class="fe ms mt mu mv b">npm install mysql2</code>而不是<code class="fe ms mt mu mv b">npm install pg</code>(使用mysql2，而不是MySQL——MySQL 2更快并且支持异步/等待)</li><li id="7990" class="me mf it ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated">在index.js中，您需要mysql，如下所示:</li></ul><p id="0278" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><code class="fe ms mt mu mv b">const mysql = require('mysql2/promise');</code></p><ul class=""><li id="086c" class="me mf it ke b kf kg kj kk kn mg kr mh kv mi kz mj mk ml mm bi translated">listUsers函数如下所示:</li></ul><p id="46ca" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">Java Script语言</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="49eb" class="ne lc it mv b gy nf ng l nh ni">async function listUsers(req, res) {</span><span id="5fb6" class="ne lc it mv b gy nj ng l nh ni">try {</span><span id="7e4b" class="ne lc it mv b gy nj ng l nh ni">const conn = await mysql.createConnection(process.env.DATABASE_URL);</span><span id="ff48" class="ne lc it mv b gy nj ng l nh ni">const [rows, fields] = await conn.execute('SELECT * FROM users');</span><span id="24a8" class="ne lc it mv b gy nj ng l nh ni">const results = { 'users': rows };</span><span id="5954" class="ne lc it mv b gy nj ng l nh ni">res.render('pages/index', results );</span><span id="e5da" class="ne lc it mv b gy nj ng l nh ni">await conn.end();</span><span id="9cd4" class="ne lc it mv b gy nj ng l nh ni">} catch (err) {</span><span id="4e57" class="ne lc it mv b gy nj ng l nh ni">console.error(err);</span><span id="4c01" class="ne lc it mv b gy nj ng l nh ni">res.send("Error " + err);</span><span id="3c34" class="ne lc it mv b gy nj ng l nh ni">}</span><span id="977f" class="ne lc it mv b gy nj ng l nh ni">}</span></pre><p id="c62a" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">视图/页面/索引. ejs保持不变。</p><p id="e305" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">您可以在这里看到带有这些变化的示例项目<a class="ae kb" href="https://github.com/digitalronin/query-database-javascript/tree/mysql" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="8bf4" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">现在，让我们研究几个构建在这个基础之上的库，它们添加了抽象层，让您能够以更“类似JavaScript”的方式读取和操作数据库数据。</p><p id="5c6b" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">到目前为止，我们已经看到了如何将原始SQL发送到数据库；像这样的陈述:</p><p id="3d59" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><code class="fe ms mt mu mv b">SELECT * FROM users</code></p><p id="cb2a" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">如果我们想得到某个特定用户的评论，比如说id为1的用户，我们可以使用这样的代码:</p><p id="c9bf" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><code class="fe ms mt mu mv b">SELECT * FROM comments WHERE user_id = 1</code></p><p id="8b11" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">以这种方式与您的数据库进行交互没有任何问题，但是可能会感觉有点麻烦，并且需要您在心理上保持“换档”。您用一种方式考虑您的JavaScript代码，但是当您需要考虑数据库中的数据时，您必须开始用SQL来考虑。</p><p id="b64f" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">我们要考虑的其余数据库库的目的是让您将数据库中的数据处理得更像应用程序中的JavaScript对象和代码。“在引擎盖下”都是SQL，但是你不需要太在意这些，除非你想。</p><h1 id="065f" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Knex —抽象出SQL</h1><p id="aba9" class="pw-post-body-paragraph kc kd it ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz im bi translated">我们要讨论的第一个库是<a class="ae kb" href="http://knexjs.org/" rel="noopener ugc nofollow" target="_blank"> Knex </a>。文档页面将Knex描述为“查询构建器”，其目的是在原始SQL之上提供一个抽象层。</p><h1 id="15e2" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">安装Knex</h1><p id="755f" class="pw-post-body-paragraph kc kd it ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz im bi translated">Knex需要pg(或者MySQL，如果您使用MySQL数据库的话)。我们已经安装了pg，所以我们只需像这样添加knex:</p><p id="b7e3" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><code class="fe ms mt mu mv b">npm install knex</code></p><p id="1921" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><code class="fe ms mt mu mv b">git add package.json package-lock.json</code></p><p id="33a4" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><code class="fe ms mt mu mv b">git commit -m "Install the knex library"</code></p><h1 id="2d45" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用Knex</h1><p id="9cd5" class="pw-post-body-paragraph kc kd it ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz im bi translated">knex的NPM页面将其描述为“查询生成器”Knex在一定程度上抽象了SQL，但不是很远。我们仍然需要理解底层的SQL，但是我们可以用更像JavaScript的语法来编写它，而不是将SQL字符串分割成小块。更重要的是，我们可以用一种对JavaScript程序员来说更舒服的方式使用组合来链接knex术语。</p><p id="2a8c" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">所以，当我们使用pg时，我们有这样的声明:</p><p id="6d7c" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><code class="fe ms mt mu mv b">const result = await db.query('SELECT * FROM users');</code></p><p id="c151" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">当我们使用knex时，我们可以这样写:</p><p id="1300" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><code class="fe ms mt mu mv b">const result = await db.select().from('users');</code></p><p id="5120" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">这可能看起来没有太大的区别，但是由于我们可以编写knex函数调用的方式，我们也可以这样做:</p><p id="08b9" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><code class="fe ms mt mu mv b">const result = await db.select().from('users').limit(5).offset(8);</code></p><p id="90e3" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">这里，我们得到了5个用户记录，从匹配我们查询的所有可能用户记录的第8个位置开始。您可以在<a class="ae kb" href="http://knexjs.org/" rel="noopener ugc nofollow" target="_blank"> knex文档</a>中看到全套可用选项。</p><p id="02ae" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">让我们将Express应用程序改为使用knex来显示数据库中的一些记录。首先，在index.js中替换这两行:</p><p id="3521" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">Java Script语言</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="440e" class="ne lc it mv b gy nf ng l nh ni">const { Pool } = require('pg');<br/>const conn = new Pool({ connectionString: process.env.DATABASE_URL });</span></pre><p id="9fd5" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">…有了这个:</p><p id="34f4" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">Java Script语言</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="174c" class="ne lc it mv b gy nf ng l nh ni">const db = require('knex')({<br/>client: 'pg',<br/>connection: process.env.DATABASE_URL<br/>});</span></pre><p id="586c" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">然后，将<code class="fe ms mt mu mv b">listUsers</code>的实现改为:</p><p id="3f4a" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">Java Script语言</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="bf14" class="ne lc it mv b gy nf ng l nh ni">async function listUsers(req, res) {<br/>try {<br/>const result = await db.select().from('users').limit(5).offset(5);<br/>const results = { 'users': (result) ? result : null};</span><span id="a284" class="ne lc it mv b gy nj ng l nh ni">res.render('pages/index', results );<br/>} catch (err) {<br/>console.error(err);</span><span id="3223" class="ne lc it mv b gy nj ng l nh ni">res.send("Error " + err);<br/>}<br/>}</span></pre><p id="892a" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">我们的views/pages/index.ejs文件可以保持和以前完全一样。</p><p id="a312" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">提交、推送和部署:</p><p id="d5d6" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><code class="fe ms mt mu mv b">git add index.js</code></p><p id="4315" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><code class="fe ms mt mu mv b">git commit -m "Use knex to display user data"</code></p><p id="7446" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><code class="fe ms mt mu mv b">git push heroku master</code></p><p id="0d5b" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">当您刷新浏览器时，应该会在页面上看到用户记录6到10。</p><p id="26bf" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">你可以在这里看到修改后的代码<a class="ae kb" href="https://github.com/digitalronin/query-database-javascript/tree/knex" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="b19f" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">对象关系映射</h1><p id="afa0" class="pw-post-body-paragraph kc kd it ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz im bi translated">Knex为我们提供了一种与数据库交互的方式，这更像JavaScript，但是当我们需要操作数据时，仍然需要以数据库为中心进行思考。</p><p id="e07e" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">接下来我们要讲的三个库都是建立在knex之上的(knex是建立在pg或者MySQL之上的)，是“对象关系映射”或者ORM库的例子。顾名思义，ORM库的目的是在关系数据库中的数据和应用程序中的JavaScript对象之间进行转换。这意味着，当您编写JavaScript代码时，不用考虑<strong class="ke iu"> users </strong>表中的记录，您可以考虑用户对象。</p><h1 id="6b7f" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">反对</h1><p id="6fc6" class="pw-post-body-paragraph kc kd it ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz im bi translated">我们要看的第一个库是<a class="ae kb" href="https://vincit.github.io/objection.js/" rel="noopener ugc nofollow" target="_blank"> objection </a>，它构建在knex之上:</p><p id="3124" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><code class="fe ms mt mu mv b">npm install objection</code></p><p id="4b40" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><code class="fe ms mt mu mv b">git add package.json package-lock.json</code></p><p id="8d27" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><code class="fe ms mt mu mv b">git commit -m "Install the objection library"</code></p><p id="2020" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">为了突出ORM库的一些效用，我们将修改我们的应用程序来显示用户和他们的评论。Objection构建在knex之上，因此在我们的index.js文件中，我们必须保留knex块，并添加更多的代码(为了简单起见，我将所有内容都放在index.js文件中。在真实的应用程序中，您会将代码分成单独的文件):</p><p id="6294" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><code class="fe ms mt mu mv b">const { Model } = require('objection');</code></p><p id="8128" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><code class="fe ms mt mu mv b">Model.knex(db);</code></p><p id="7e54" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">这给了我们一个模型类，我们可以继承它来定义两个类User和Comment。我们将首先定义注释:</p><p id="a8b0" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">Java Script语言</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="cf76" class="ne lc it mv b gy nf ng l nh ni">class Comment extends Model {</span><span id="bea7" class="ne lc it mv b gy nj ng l nh ni">static get tableName() {<br/>return 'comments';<br/>}<br/>}</span></pre><p id="dbb2" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">我们的类需要扩展<code class="fe ms mt mu mv b">Model</code>，并且必须实现一个<code class="fe ms mt mu mv b">tableName</code>函数来告诉Objection哪个数据库表包含底层记录。</p><p id="0217" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><code class="fe ms mt mu mv b">User</code>类是类似的，但是我们要给我们的类添加一些行为；一个<code class="fe ms mt mu mv b">fullName</code>函数，我们可以在视图模板中使用它。我们还将告诉异议<code class="fe ms mt mu mv b">Users</code>拥有<code class="fe ms mt mu mv b">Comments</code>(即用户拥有零个或多个评论)。用ORM的话来说，这通常被描述为“有许多关系”——即一个用户有许多评论。下面是它的代码:</p><p id="2e64" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">Java Script语言</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="6de1" class="ne lc it mv b gy nf ng l nh ni">class User extends Model {</span><span id="a9c8" class="ne lc it mv b gy nj ng l nh ni">static get tableName() {<br/>return 'users';<br/>}</span><span id="1cbd" class="ne lc it mv b gy nj ng l nh ni">fullName() {<br/>return `${this.first_name} ${this.last_name}`;<br/>}</span><span id="00fa" class="ne lc it mv b gy nj ng l nh ni">static get relationMappings() {</span><span id="8a6b" class="ne lc it mv b gy nj ng l nh ni">return {<br/>comments: {<br/>relation: Model.HasManyRelation,<br/>modelClass: Comment,<br/>join: {<br/>from: 'users.id',<br/>to: 'comments.user_id'<br/>}<br/>}<br/>};<br/>}<br/>}</span></pre><p id="4a9d" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">我们在我们的<code class="fe ms mt mu mv b">User</code>类中定义了一个<code class="fe ms mt mu mv b">relationMappings</code>对象，用一个注释键和一个值告诉异议这是<code class="fe ms mt mu mv b">Comment</code>类上的一个<code class="fe ms mt mu mv b">HasManyRelation</code>，其中users表的id列的值与comments表的user_id列的值相匹配。</p><p id="c8e6" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">现在我们已经定义了我们的类，让我们在代码中使用它们。下面是<code class="fe ms mt mu mv b">listUsers</code>的新实现:</p><p id="8cb6" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">Java Script语言</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="5573" class="ne lc it mv b gy nf ng l nh ni">async function listUsers(req, res) {</span><span id="a61c" class="ne lc it mv b gy nj ng l nh ni">try {<br/>const users = await User.query().limit(5);</span><span id="67d7" class="ne lc it mv b gy nj ng l nh ni">for (i in users) {<br/>const user = users[i];<br/>user.comments = await User.relatedQuery('comments').for(user.id);<br/>}</span><span id="873b" class="ne lc it mv b gy nj ng l nh ni">const results = { 'users': users };</span><span id="4b8c" class="ne lc it mv b gy nj ng l nh ni">res.render('pages/index', results );<br/>} catch (err) {<br/>console.error(err);</span><span id="4d20" class="ne lc it mv b gy nj ng l nh ni">res.send("Error " + err);<br/>}<br/>}</span></pre><p id="2430" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">在这里，我们获取5个用户，然后对于每个用户，我们获取他们的评论，并将其分配给用户对象的comments属性。在views/pages/index.ejs中，我们可以像这样显示我们的用户及其评论:</p><p id="c415" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">超文本标记语言</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="a28e" class="ne lc it mv b gy nf ng l nh ni">&lt;h1&gt;Users&lt;/h1&gt;<br/>&lt;ul&gt;<br/>&lt;% users.map((user) =&gt; { %&gt;<br/>&lt;li&gt;&lt;%= user.id %&gt; - &lt;%= user.fullName() %&gt;&lt;/li&gt;<br/>&lt;ul&gt;<br/>&lt;% user.comments.map((comment) =&gt; { %&gt;<br/>&lt;li&gt;&lt;%= comment.body %&gt;&lt;/li&gt;<br/>&lt;% }); %&gt;<br/>&lt;/ul&gt;<br/>&lt;% }); %&gt;<br/>&lt;/ul&gt;</span></pre><p id="665a" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">你可以在这里看到修改后的代码<a class="ae kb" href="https://github.com/digitalronin/query-database-javascript/tree/objection" rel="noopener ugc nofollow" target="_blank">。</a>像往常一样，提交并推送部署:</p><p id="bd56" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><code class="fe ms mt mu mv b">git add index.js views/pages/index.ejs</code></p><p id="169c" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><code class="fe ms mt mu mv b">git commit -m "Show users and comments using Objection"</code></p><p id="6867" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><code class="fe ms mt mu mv b">git push heroku master</code></p><p id="aa80" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">现在，当您重新加载页面时，您应该会看到用户和评论。</p><h1 id="5103" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">“N+1选择”问题</h1><p id="3e49" class="pw-post-body-paragraph kc kd it ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz im bi translated">这段代码强调了人们在使用ORM库时遇到的一个常见问题，称为“N+1选择”问题。</p><p id="def6" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">这是我们用来获取用户及其评论的代码块:</p><p id="3075" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">Java Script语言</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="78f4" class="ne lc it mv b gy nf ng l nh ni">const users = await User.query().limit(5);</span><span id="ed4e" class="ne lc it mv b gy nj ng l nh ni">for (i in users) {<br/>const user = users[i];<br/>user.comments = await User.relatedQuery('comments').for(user.id);<br/>}</span></pre><p id="e3f4" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">这是可行的，但是效率很低。首先，我们获取5个用户，然后对于这5个用户中的每一个，我们通过再次调用数据库来获取他们的评论<em class="la">。因此，我们为用户打了1个电话，然后又打了5个电话来获取评论。这是5次呼叫加上前1次，即5+1或N+1，其中N == 5。因此出现了“N+1选择”问题。</em></p><p id="6681" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">除非数据库查询非常复杂，否则往返调用数据库所需的时间要比数据库计算和传输查询结果所需的时间长得多。因此，为了保持应用程序的速度，我们需要尽可能减少对数据库的调用。上面的代码与此完全相反。</p><p id="42a8" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">对于这个微不足道的例子，您不会注意到任何差异，但是对于真实世界的应用程序，性能影响可能非常严重，并导致许多问题。</p><p id="0211" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">幸运的是，每个ORM库都有可以轻松避免这个问题的特性(前提是你知道它的存在)。以下是异议是如何做到的:在index.js中，将上面的代码块替换为:</p><p id="1191" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><code class="fe ms mt mu mv b">const users = await User.query().limit(5).withGraphFetched('comments');</code></p><p id="98a0" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">这一行代码与上面的代码块做的一样，但是以一种更加高效的数据库方式。Objection将使用我们提供的关系信息来确定如何在单个查询中获取用户数据和评论数据，并将结果解包并缝合到我们在使用for循环之前构建的同一对象结构中。</p><p id="2402" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">你可以在这里看到修改后的代码<a class="ae kb" href="https://github.com/digitalronin/query-database-javascript/tree/n-plus-one" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="0182" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">书架</h1><p id="7b65" class="pw-post-body-paragraph kc kd it ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz im bi translated">我们要看的下一个ORM库是<a class="ae kb" href="https://bookshelfjs.org/" rel="noopener ugc nofollow" target="_blank">书架</a>。</p><p id="a998" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">ORM库之间的许多差异取决于库针对什么用例进行了优化。在Bookshelf的例子中，它的设计显然是为了尽可能容易地呈现数据的分页列表，这在web应用程序中是一个非常常见的用例。</p><p id="55de" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">让我们在应用程序中将异议替换为书架:</p><p id="e4f9" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><code class="fe ms mt mu mv b">npm uninstall objection</code></p><p id="58a0" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><code class="fe ms mt mu mv b">npm install bookshelf</code></p><p id="42ae" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><code class="fe ms mt mu mv b">git add package.jsonpackage-lock.json</code></p><p id="eb0b" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><code class="fe ms mt mu mv b">git commit -m "Replace Objection with Bookshelf"</code></p><p id="5ad2" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">在index.js中，替换这些行:</p><p id="47cd" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">Java Script语言</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="f39f" class="ne lc it mv b gy nf ng l nh ni">const { Model } = require('objection');<br/>Model.knex(db);</span></pre><p id="79d0" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">…有了这个:</p><p id="fb6b" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">Java Script语言</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="19de" class="ne lc it mv b gy nf ng l nh ni">const bookshelf = require('bookshelf')(db);</span></pre><p id="7a98" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">用这些替换我们的类定义:</p><p id="eafc" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">Java Script语言</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="229d" class="ne lc it mv b gy nf ng l nh ni">const Comment = bookshelf.model('Comment', {<br/>tableName: 'comments'<br/>});</span><span id="a886" class="ne lc it mv b gy nj ng l nh ni">const User = bookshelf.model('User', {<br/>tableName: 'users',</span><span id="5a66" class="ne lc it mv b gy nj ng l nh ni">comments() {<br/>// by default, bookshelf infers that the foreign key is 'user_id'<br/>return this.hasMany('Comment');<br/>}</span><span id="db33" class="ne lc it mv b gy nj ng l nh ni">});</span></pre><p id="e04d" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">我们的<code class="fe ms mt mu mv b">listUsers</code>函数现在看起来像这样:</p><p id="90a8" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">Java Script语言</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="8e64" class="ne lc it mv b gy nf ng l nh ni">async function listUsers(req, res) {<br/>try {<br/>const models = await new User()<br/>.fetchPage({<br/>pageSize: 5,<br/>page: 1,<br/>withRelated: ['comments']<br/>});</span><span id="7c65" class="ne lc it mv b gy nj ng l nh ni">users = [];</span><span id="4437" class="ne lc it mv b gy nj ng l nh ni">models.map(m =&gt; {<br/>const user = m.attributes;<br/>const comments = m.related('comments');</span><span id="2cba" class="ne lc it mv b gy nj ng l nh ni">user.comments = comments.map(c =&gt; c.attributes);<br/>users.push(user);<br/>});</span><span id="dc95" class="ne lc it mv b gy nj ng l nh ni">const results = { 'users': users };</span><span id="b0ec" class="ne lc it mv b gy nj ng l nh ni">res.render('pages/index', results );<br/>} catch (err) {<br/>console.error(err);<br/>res.send("Error " + err);<br/>}<br/>}</span></pre><p id="d8f2" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">正如您所看到的，类的定义更简洁一些，但是Bookshelf需要一个更详细的定义来说明如何解包我们的数据以构建用户/评论结构。还要注意数据页面的概念是如何直接构建到库的API中的。</p><p id="e089" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">views/pages/index.ejs中的代码几乎相同(我已经从User类中删除了fullName函数):</p><p id="b510" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">超文本标记语言</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="3f5f" class="ne lc it mv b gy nf ng l nh ni">&lt;h1&gt;Users&lt;/h1&gt;<br/>&lt;ul&gt;<br/>&lt;% users.map((user) =&gt; { %&gt;<br/>&lt;li&gt;&lt;%= user.id %&gt; - &lt;%= user.first_name %&gt; &lt;%= user.last_name %&gt;&lt;/li&gt;<br/>&lt;ul&gt;<br/>&lt;% user.comments.map((comment) =&gt; { %&gt;<br/>&lt;li&gt;&lt;%= comment.body %&gt;&lt;/li&gt;<br/>&lt;% }); %&gt;<br/>&lt;/ul&gt;<br/>&lt;% }); %&gt;<br/>&lt;/ul&gt;</span></pre><p id="1077" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">你可以在这里看到这些变化<a class="ae kb" href="https://github.com/digitalronin/query-database-javascript/tree/bookshelf" rel="noopener ugc nofollow" target="_blank">的代码。当然，再次提交和部署。</a></p><p id="27ee" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><code class="fe ms mt mu mv b">git add index.js views/pages/index.ejs</code></p><p id="ecb8" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><code class="fe ms mt mu mv b">git commit -m "Show users and comments using Bookshelf"</code></p><p id="27b4" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><code class="fe ms mt mu mv b">git push heroku master</code></p><h1 id="c95e" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">序列</h1><p id="df9c" class="pw-post-body-paragraph kc kd it ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz im bi translated">我们要看的最后一个库是<a class="ae kb" href="https://sequelize.org/" rel="noopener ugc nofollow" target="_blank"> Sequelize </a>。</p><p id="a75f" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">Sequelize对数据的组织方式非常固执己见。如果你遵循它的惯例，你可以写更少的代码，让Sequelize为你做很多工作。特别是，Sequelize有很多特性可以帮助您创建表格，默认情况下，它会按照自己的结构和命名约定来创建表格。</p><p id="ea22" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">我们一直在使用的数据库的结构并不完全符合Sequelize的预期，所以我们需要添加一些额外的配置来允许Sequelize使用它。</p><h1 id="2661" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">安装序列</h1><p id="6128" class="pw-post-body-paragraph kc kd it ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz im bi translated">要删除bookshelf并安装sequelize，请运行以下命令:</p><p id="3d85" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><code class="fe ms mt mu mv b">npm uninstall bookshelf</code></p><p id="09bf" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><code class="fe ms mt mu mv b">npm install sequelize</code></p><p id="882d" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><code class="fe ms mt mu mv b">git add package.json package-lock.json</code></p><p id="b963" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><code class="fe ms mt mu mv b">git commit -m "Replace Bookshelf with Sequelize"</code></p><h1 id="56f0" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用序列</h1><p id="219a" class="pw-post-body-paragraph kc kd it ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz im bi translated">在index.js中，替换这些行:</p><p id="491c" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">Java Script语言</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="6752" class="ne lc it mv b gy nf ng l nh ni">const db = require('knex')({<br/>client: 'pg',<br/>connection: process.env.DATABASE_URL<br/>});</span><span id="d4af" class="ne lc it mv b gy nj ng l nh ni">const bookshelf = require('bookshelf')(db)</span></pre><p id="438c" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">…有了这些:</p><p id="6354" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">Java Script语言</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="29ba" class="ne lc it mv b gy nf ng l nh ni">const { Sequelize, DataTypes } = require('sequelize');<br/>const sequelize = new Sequelize(process.env.DATABASE_URL);</span></pre><p id="060a" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">然后，用以下代码替换User和Comment的类定义:</p><p id="61f0" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">Java Script语言</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="3daf" class="ne lc it mv b gy nf ng l nh ni">const User = sequelize.define('User', {<br/>first_name: { type: DataTypes.STRING },<br/>last_name: { type: DataTypes.STRING },<br/>email: { type: DataTypes.STRING }<br/>},<br/>{<br/>tableName: 'users',<br/>timestamps: false<br/>}<br/>);</span><span id="7403" class="ne lc it mv b gy nj ng l nh ni">const Comment = sequelize.define('Comment', {<br/>body: { type: DataTypes.STRING }<br/>}, {<br/>tableName: 'comments',<br/>timestamps: false<br/>}<br/>);</span><span id="d257" class="ne lc it mv b gy nj ng l nh ni">User.hasMany(Comment, { foreignKey: 'user_id' });</span></pre><p id="1ea2" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">注意，我们向<code class="fe ms mt mu mv b">sequelize.define</code>传递了两个对象。第一个对象定义了对象的属性，第二个对象包含一些元数据。</p><p id="5ebf" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">在这种情况下，我们告诉Sequelize，支撑用户类的数据库表称为“users”(默认情况下，Sequelize会推断该表称为“Users”)，而<code class="fe ms mt mu mv b">timestamps: false</code>告诉Sequelize，我们的表没有名为createdAt和updatedAt的时间戳列。</p><p id="7ddc" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">Sequelize使得编写为您创建表的代码变得非常容易，当您向数据库写入数据时，它会添加这些时间戳列并相应地设置它们的值。<a class="ae kb" href="https://sequelize.org/master/index.html" rel="noopener ugc nofollow" target="_blank">序列文档</a>非常好，有更多关于这方面的内容。</p><p id="06b0" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">我们传递给hasMany的是另一个我们必须告诉Sequelize我们没有遵循其惯例的地方。它期望(并将为我们创建)一个名为UserId的列，将评论链接到用户。</p><p id="1dd2" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">在我们的<code class="fe ms mt mu mv b">listUsers</code>函数中，我们可以替换所有这些代码:</p><p id="11c8" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">Java Script语言</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="f3f9" class="ne lc it mv b gy nf ng l nh ni">const models = await new User()</span><span id="cb78" class="ne lc it mv b gy nj ng l nh ni">.fetchPage({<br/>pageSize: 5,<br/>page: 1,<br/>withRelated: ['comments']<br/>});</span><span id="0c8e" class="ne lc it mv b gy nj ng l nh ni">users = [];</span><span id="0b59" class="ne lc it mv b gy nj ng l nh ni">models.map(m =&gt; {<br/>const user = m.attributes;<br/>const comments = m.related('comments');</span><span id="1b62" class="ne lc it mv b gy nj ng l nh ni">user.comments = comments.map(c =&gt; c.attributes);<br/>users.push(user);<br/>});</span></pre><p id="7a02" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">…只有这一行:</p><p id="7a2f" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">Java Script语言</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="a1a8" class="ne lc it mv b gy nf ng l nh ni">const users = await User.findAll({ include: Comment });</span></pre><p id="d14a" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">我们还必须在views/pages/index.ejs中做一个微小的更改。替换这一行:</p><p id="83ec" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><code class="fe ms mt mu mv b">&lt;% user.comments.map((comment) =&gt; { %&gt;</code></p><p id="f7cb" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">…与此(区别在于用户。Comments而不是user.comments):</p><p id="bffe" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><code class="fe ms mt mu mv b">&lt;% user.Comments.map((comment) =&gt; { %&gt;</code></p><p id="41d9" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">你可以在这里看到修改后的代码<a class="ae kb" href="https://github.com/digitalronin/query-database-javascript/tree/sequelize" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="3bd3" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><code class="fe ms mt mu mv b">git add index.js views/pages/index.ejs</code></p><p id="0732" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><code class="fe ms mt mu mv b">git commit -m "Show users and comments using Sequelize"</code></p><p id="4a72" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><code class="fe ms mt mu mv b">git push heroku master</code></p><h1 id="3261" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">那么哪个选项是最好的呢？</h1><p id="7f7b" class="pw-post-body-paragraph kc kd it ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz im bi translated">现在，您有了从JavaScript应用程序查询关系数据库的5种方法。我们从通过pg/mysql库的原始SQL开始，然后看了knex查询构建器，然后转到三个ORM库；反对，书架和顺序。</p><p id="80a9" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">那么，哪一个才是适合你应用的选择呢？</p><p id="c167" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">一如既往，视情况而定。使用ORM库，您可以做任何您使用查询构建器甚至原始SQL不能做的事情。因为一切都是在“幕后”使用SQL工作的。这并不奇怪。此外，即使您决定使用ORM，大多数库仍然会向您提供将原始SQL发送到数据库的方法。所以你使用什么样的抽象层次取决于你试图解决的问题，以及你想关注什么样的代码。</p><p id="0bb8" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">如果您大量使用数据库的特性，可能使用复杂的视图或存储过程，您可能会发现使用knex或raw SQL更容易。但是，对于大多数web应用程序来说，ORM库很可能会通过抽象出表结构并允许您将应用程序数据视为JavaScript对象来简化您的工作。</p><p id="3e41" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">如果你已经决定使用ORM，选择使用哪个ORM库并不总是一目了然的。JavaScript库的前景是非常动态的。新的库经常被创建，旧的库就不再受欢迎了。做出选择时，请考虑以下几点:</p><ul class=""><li id="2b3b" class="me mf it ke b kf kg kj kk kn mg kr mh kv mi kz mj mk ml mm bi translated">浏览一下库的文档，看看是否清晰全面。然后，决定API的组合方式对您是否有意义。不同的库使用不同的方法，您可能会发现其中一种方法比其他方法更适合您的需求和偏好。如果您正在编写使用现有数据库的代码，或者在开发应用程序时创建数据库，这一点尤其正确。</li><li id="acf8" class="me mf it ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated">看看图书馆周围的社区。这是很多人都在积极使用的东西吗？如果是这样，如果你需要的话，可能会有很多帮助和建议。一些库也有广泛的插件生态系统，可能是特定的插件让你的生活变得更容易。</li><li id="39a6" class="me mf it ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated">一个相关的问题是图书馆的年龄。如果已经有一段时间了，更有可能是发现并修复了常见问题。如果这是一个相对较新的图书馆，你可能需要自己想出更多的东西(如果你喜欢玩新的闪亮的玩具和解谜，这可能是一件好事)。</li><li id="c649" class="me mf it ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated">性能更可能取决于您如何使用库，而不是库本身。但是，如果您绝对必须从应用程序中挤出最后几微秒的延迟，那么使用SQL或knex在更接近数据库的地方工作会快一点。请注意，这通常是一个很小的好处，代码可维护性的成本很可能高于基准性能的收益。</li></ul><p id="8ff3" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">查询愉快！</p></div></div>    
</body>
</html>