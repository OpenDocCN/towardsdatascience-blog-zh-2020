<html>
<head>
<title>A generic framework of concurrent consumers for Google Cloud Platform Pub/Sub</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Google云平台发布/订阅的并发消费者通用框架</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-python-implementation-of-concurrent-consumers-for-google-cloud-platform-pub-sub-991ae8b9841d?source=collection_archive---------29-----------------------#2020-05-31">https://towardsdatascience.com/a-python-implementation-of-concurrent-consumers-for-google-cloud-platform-pub-sub-991ae8b9841d?source=collection_archive---------29-----------------------#2020-05-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="613e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一个示例展示了如何将消息发布到Pub/Sub，并使用Python多处理模块构建一个服务来同时使用这些消息</h2></div><p id="9b04" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个博客也可以在<a class="ae le" href="https://www.linkedin.com/pulse/python-implementation-concurrent-consumers-google-cloud-boning-zhang" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>找到。</p><p id="06ee" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本博客将向您介绍谷歌云平台(GCP)中的实时消息队列，即Pub/Sub。首先，我将解释什么是消息队列，以及我们何时需要消息队列。其次，我将向你介绍GCP酒吧。之后，我将展示如何向GCP发布消息。最后，我将解释一个使用Python中的<em class="lf">多处理</em>模块实现的并发消费者。我将在这一部分花大部分时间，因为它是使用Python <em class="lf">多处理</em>模块的并发消费者的通用代码框架，可以在您的项目中无需任何修改地重用。</p><h2 id="e1f1" class="lg lh it bd li lj lk dn ll lm ln dp lo kr lp lq lr kv ls lt lu kz lv lw lx ly bi translated">我们什么时候需要消息队列？</h2><p id="93cc" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mb kt ku kv mc kx ky kz md lb lc ld im bi translated">消息/任务队列接收来自一个或多个应用程序的消息，另一方面将这些请求/消息分派给多个分布式工作器来消费这些任务。在此过程中，产生任务并将其发布到任务队列中的应用程序称为生产者，而从任务队列中接收和消费任务的工作者称为消费者。一个好的任务队列应该能够支持分布式的工人/生产者，并以可接受的延迟分派任务。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi me"><img src="../Images/2ab7ca8c9d863f3abd6d5dedf8a22a93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kB3_n1twxykbkZa6Urw5Dg.png"/></div></div><p class="mq mr gj gh gi ms mt bd b be z dk translated">GCP发布/订阅的并发消费者示例</p></figure><p id="54b2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在后台运行异步任务的应用程序中需要任务队列，如下所示。我们有一个前端用户界面，用户通过点击提交按钮触发一系列的工作。这些作业需要异步运行，因为它们非常耗时。作为一个解决方案，我们在这个项目中需要一个任务队列，以守护模式将从生产者(即这个场景中的前端UI)接收的任务分派给消费者。您可以提出一个解决方案，将从前端接收的任务信息记录在一个MySQL表中，然后让工人使用MySQL表中的任务。嗯，MySQL表不适合做任务队列的原因有很多。在MySQL表作为任务队列的那种情况下，(1)你的工作人员需要从MySQL服务器上一遍又一遍的查询表，这会给你的服务器带来很大的负担，可能会影响你的其他MySQL操作。(2)也可能发生两个工作者试图同时消耗相同的任务，尽管使用适当的锁定逻辑，这种概率很小。(3)由于MySQL服务器不是分布式的，所以这种设计是不可扩展的。因此，我们应该考虑在这个场景中使用任务队列。</p><h2 id="8884" class="lg lh it bd li lj lk dn ll lm ln dp lo kr lp lq lr kv ls lt lu kz lv lw lx ly bi translated">什么是谷歌云平台Pub/Sub？</h2><p id="04c3" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mb kt ku kv mc kx ky kz md lb lc ld im bi translated">谷歌云平台(GCP) <a class="ae le" href="https://cloud.google.com/pubsub/docs/overview" rel="noopener ugc nofollow" target="_blank"> Pub/Sub </a>是一个消息队列管理系统。它类似于芹菜消息队列，但好处是您不需要构建和维护基础设施。在GCP发布/订阅中，一个<strong class="kk iu">主题</strong>是一个接收生产者发布的消息的任务队列。对于一个主题，我们可以创建一个或多个<strong class="kk iu">订阅</strong>。发布/订阅会将主题中的所有消息发送给每个订阅。多重订阅适用于有多个应用程序使用相同的消息但目的不同的情况。在我们的场景中，单一订阅就足够了。现在你可能会想，如果只有一个订阅，我们怎么会有多个消费者。嗯，订阅不是消费者，在Pub/Sub中表示为<strong class="kk iu">订阅者</strong>。一个订阅可以有多个分布式订阅者，因此发布/订阅会将消息分派给这些订阅者，以便他们可以并发地使用异步任务。</p><p id="2527" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本文将实现一个消费者/订阅者从发布/订阅请求多个消息，并并发运行工作器。要在实际项目中扩大规模，您只需要在不同的计算引擎中运行多个连接到同一个订户的消费者。</p><h2 id="5638" class="lg lh it bd li lj lk dn ll lm ln dp lo kr lp lq lr kv ls lt lu kz lv lw lx ly bi translated">如何向GCP发布消息？</h2><p id="9036" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mb kt ku kv mc kx ky kz md lb lc ld im bi translated">请参阅以下伪代码作为示例。类似的例子也可以在GCP的<a class="ae le" href="https://github.com/GoogleCloudPlatform/python-docs-samples/tree/master/pubsub/cloud-client" rel="noopener ugc nofollow" target="_blank"> GitHub </a>中找到。</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="518c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里，我们在对Pub/Sub的单个调用中批量处理多个消息，以提高吞吐量，因为在我们的场景中，延迟并不是那么关键。<em class="lf"> BatchSettings() </em>如果批量消息的大小达到10240字节或每60秒发布一次。在<em class="lf">from _ service _ account _ JSON()</em>中，我们使用gcp_key文件作为对gcp的认证。并且每次<em class="lf"> message_data </em>发布后，都会触发一个回调函数<em class="lf"> log_pub_result() </em>来显示其发布状态。这里注意，在Python3中，<em class="lf"> PublisherClient </em>只接受字节串作为数据类型，这就是为什么我们需要将“<em class="lf"> message_data </em>”编码为“<em class="lf"> utf-8 </em>”。</p><p id="f86f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们的示例中，Rest API将触发这个publisher模块，以便发布从前端接收到的消息。</p><h2 id="b41f" class="lg lh it bd li lj lk dn ll lm ln dp lo kr lp lq lr kv ls lt lu kz lv lw lx ly bi translated">如何接收GCP酒馆/订阅的消息？</h2><p id="105e" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mb kt ku kv mc kx ky kz md lb lc ld im bi translated">从Pub/Sub接收消息的方法有两种:<em class="lf"> pull </em>和<em class="lf"> push </em>。在<em class="lf">拉</em>的情况下，订阅者/消费者向Pub/Sub发送请求以拉消息，而Pub/Sub基于消息的发布率向订阅者/消费者推送消息。在我们的场景中，我们将实现消费者从发布/订阅获取消息，因为我们可以控制吞吐量，延迟对我们来说并不重要。在拉取过程中，我们还可以控制每次从服务中拉取的消息数量，这样我们就可以控制单个订阅者/消费者中并发工作人员的数量。一旦消息被发送给订户/消费者，在处理该消息时，它将不会被再次发送给其他订户/消费者。但是，如果消息在确认窗口内没有被确认，那么发布/订阅将考虑再次调度它。因此，在任务完成后确认消息并在任务完成前更新确认窗口非常重要。</p><h2 id="21be" class="lg lh it bd li lj lk dn ll lm ln dp lo kr lp lq lr kv ls lt lu kz lv lw lx ly bi translated">使用Python多重处理模块的并发消费者通用代码框架</h2><p id="162f" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mb kt ku kv mc kx ky kz md lb lc ld im bi translated">在这一部分中，我将解释使用Python中的多处理模块实现的并发消费者的通用代码框架。因为我们的任务是CPU受限的，所以我们将使用Python中的多处理模块实现并发订阅者/消费者。(1)我们将首先为每个员工分配一条消息/任务。我们将等待所有的工人完成他们的任务。(3)当我们等待工作者时，我们将定期检查消息的确认窗口是否需要每隔一段时间更新。(4)一旦工作者完成其任务，我们将确认该消息。在这样的实现中，如果在消息运行期间抛出任何异常，则消息将不会被确认，这样，发布/订阅将在以后再次将它们分派给订阅者。</p><p id="f4d4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我将详细解释守护程序服务。完整的示例代码可以在我的<a class="ae le" href="https://github.com/BoningZhang/GCP_PubSub_example" rel="noopener ugc nofollow" target="_blank"> GitHub </a>中找到。为守护进程服务实现了两个文件，<em class="lf"> service.py </em>和<em class="lf"> internal/subscriber.py </em>。<em class="lf"> service.py </em>由<em class="lf"> main </em>函数和任务组成，而<em class="lf"> internal/subscriber.py </em>由从Pub/Sub提取消息并启动并发工作器的所有助手函数组成。<em class="lf"> internal/subscriber.py </em>中的代码对于Pub/Sub的并发消费者来说是通用的，这些代码无需任何修改就可以在其他项目中重用。</p><p id="d4d2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们先来看看驱动部分，也就是<em class="lf"> service.py </em>中的<em class="lf"> main </em>函数。在这个例子中，它配置了<em class="lf">日志</em>，但这与我们的主题无关。除了<em class="lf">日志</em>部分，它除了<em class="lf"> start_service() </em>之外什么都不做。</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="a2c8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="lf"> start_service() </em>函数由python decorator包装，它是实现我们的任务的地方，例如示例中的<em class="lf"> run_step1() </em>和<em class="lf"> run_step2() </em>。需要提到的一点是<em class="lf"> start_service() </em>的输入参数。很容易知道“<em class="lf"> message </em>”是从Pub/Sub接收的消息，分配给这个worker，而“<em class="lf"> return_vals </em>是一个字典，用于与worker的调用函数进行通信。</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="c62d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">装饰器“<em class="lf"> listen </em>”在<em class="lf"> internal/subscriber.py </em>中实现。为了解释<em class="lf"> service.py </em>的作用，我需要展示它的实现。</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="2baf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">基本上，“<em class="lf"> listen </em>”接收一个函数作为输入参数，并返回一个新函数<em class="lf"> subscriber_wrapper() </em>，该函数包装了原始函数。因此，<em class="lf"> service.py </em>试图启动的服务是包装器:</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="f66f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，它通过<em class="lf"> connect_to_queue() </em>连接到GCP发布/订阅。然后运行死循环，直到守护程序服务被终止。在循环中，<em class="lf"> process_messages() </em>将拉取消息并启动workers来完成<em class="lf"> start_service </em>中实现的任务。在所有工作器完成这一轮的任务后，守护进程服务会休眠一段时间，然后反复启动下一轮，直到被杀死。</p><p id="728e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的解释中，我们实际上使用了普通函数来代替装饰器。在我们的实现中引入装饰器的原因是因为“<em class="lf"> listen </em>中的包装器可以重用，因此我们使用装饰器将它包含在<em class="lf"> internal/service.py </em>中。</p><p id="eefd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们来看<em class="lf"> connect_to_queue() </em>，就是连接GCP Pub/Sub，没什么特别的。同样，我们使用json密钥文件作为对GCP的认证。</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="f4be" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们来近距离观察一下<em class="lf"> process_messages() </em>。</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="5d67" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它首先从发布/订阅中提取8条消息。并调用<em class="lf"> start_workers() </em>衍生出8个进程，在每个进程中运行<em class="lf"> start_service() </em>。</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="9d97" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<em class="lf"> start_workers() </em>中使用了<em class="lf">多重处理</em>模块。对于每条消息，都会产生一个单独的进程来运行<em class="lf"> start_service() </em>(作为参数“<em class="lf"> fn </em>”)函数。如前所述，<em class="lf"> return_vals </em>是使用<em class="lf">多重处理</em> <em class="lf">管理器</em>创建的，用于与工人通信。注意"<em class="lf">workers[worker]=(message . ack _ id，msg_data，1，worker_num)" </em>记录每个worker的消息的<em class="lf"> ack_id </em>，以便在任务完成后用于确认消息。</p><p id="807e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们回到<em class="lf"> process_messages() </em>。创建并启动8个进程后，主进程将继续监控这8个进程，直到全部完成。在每一轮监控过程中，它都会检查每一个工蚁，看它是活着还是不活着。如果它已经死了，那么我们将检查由<em class="lf"> return_vals </em>返回的任务状态。如果任务完成，没有任何异常，那么我们将需要确认消息，否则不要确认，稍后Pub/Sub将再次调度它。</p><p id="b87e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果工作者仍然活着，那么我们需要检查是否需要扩展确认窗口。否则，在确认窗口到期后，当工作进程仍在处理该消息时，Pub/Sub将再次调度该消息。如果工作者已经运行了太长时间并且超过了SLA，那么我们将终止工作者而不延长确认窗口。请注意，每次我们将确认窗口延长<em class="lf"> ACK_DEADLINE_SECONDS </em>秒，这应该大于监控工人的睡眠间隔<em class="lf">ACK _ SLEEP _ INTERVALS _ SECONDS</em>。否则，可能会发生确认窗口没有及时更新的情况。</p><figure class="mf mg mh mi gt mj"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h2 id="903d" class="lg lh it bd li lj lk dn ll lm ln dp lo kr lp lq lr kv ls lt lu kz lv lw lx ly bi translated">结论</h2><p id="b47f" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mb kt ku kv mc kx ky kz md lb lc ld im bi translated">希望现在你已经清楚地了解为什么我们需要任务队列，什么是GCP发布/订阅，我们可以用它做什么。此外，希望在<em class="lf"> internal/service.py </em>中实现的代码可以在您自己的项目中重用。</p></div></div>    
</body>
</html>