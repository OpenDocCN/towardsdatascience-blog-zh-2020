<html>
<head>
<title>The Sardinas-Patterson Algorithm in Simple Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简单 Python 中的 Sardinas-Patterson 算法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-sardinas-patterson-algorithm-in-simple-python-9718242752c3?source=collection_archive---------30-----------------------#2020-07-30">https://towardsdatascience.com/the-sardinas-patterson-algorithm-in-simple-python-9718242752c3?source=collection_archive---------30-----------------------#2020-07-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1bef" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">检查可变长度代码的唯一可解码性</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/400c146b29264e9c38bdc3053bce107e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*pjlePlP_jdz_DPynO2qqvQ.jpeg"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">图片来自<a class="ae kr" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4031973" rel="noopener ugc nofollow" target="_blank">皮克斯拜</a></p></figure><p id="707d" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在关于数据科学的对话中，两个经常被冷落的领域是<a class="ae kr" href="https://en.wikipedia.org/wiki/Information_theory" rel="noopener ugc nofollow" target="_blank"> <strong class="ku ir">信息论</strong> </a> <strong class="ku ir">，</strong>研究信息的量化、存储和交流，<a class="ae kr" href="https://en.wikipedia.org/wiki/Coding_theory" rel="noopener ugc nofollow" target="_blank"> <strong class="ku ir">编码理论</strong> </a>，研究代码的属性及其各自对特定应用的适用性。加雷思·a·琼斯和 j·玛丽·琼斯的《信息和编码理论》是对这两个领域的精彩介绍。几年来，我一直把这本书列在我的待办事项清单上(我是在遇到作者的另一本书<a class="ae kr" href="https://link.springer.com/book/10.1007/978-1-4471-0613-5" rel="noopener ugc nofollow" target="_blank">初等数论</a>后添加的，在宾夕法尼亚州立大学数学 465 中)，最近决定打开它，看看它到底是关于什么的。</p><p id="4622" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">如题，这篇帖子讲的是<a class="ae kr" href="https://en.wikipedia.org/wiki/Sardinas%E2%80%93Patterson_algorithm" rel="noopener ugc nofollow" target="_blank">撒丁纳斯-帕特森算法</a> <strong class="ku ir"> </strong>(书中定义为<em class="lo">撒丁纳斯-帕特森定理</em>)，可以用来判定一个变长码是否唯一可解码。</p><p id="0441" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在我们深入研究算法之前，我们需要给出一些定义。出于可读性的考虑，我将在这里做一些演示，但更严格的定义和所有代码可以在我的 Github 上的<a class="ae kr" href="https://github.com/danhales/blog-sardinas-patterson" rel="noopener ugc nofollow" target="_blank">笔记本</a>中找到。</p><h2 id="83b8" class="lp lq iq bd lr ls lt dn lu lv lw dp lx lb ly lz ma lf mb mc md lj me mf mg mh bi translated">定义</h2><p id="52bd" class="pw-post-body-paragraph ks kt iq ku b kv mi jr kx ky mj ju la lb mk ld le lf ml lh li lj mm ll lm ln ij bi translated">出于我们的目的，我们可以把一个<strong class="ku ir">代码</strong> C 想象成一组独特的码字，这些码字由一些<strong class="ku ir">源字母表</strong>中的符号构成。在这篇文章中，我将把我的源字母表限制为{0，1，2}，只是为了保持简单，但是我们将看到的代码可以处理更多。<strong class="ku ir">本例中的码字</strong>将是由至少一个数字组成的字符串，如 012、1201021，甚至只是 0。</p><p id="b527" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">码字的<strong class="ku ir">长度</strong>是该码字中使用的符号序列的长度。例如，码字 0012 的长度是 4，因为它由序列(0，0，1，2)组成。</p><p id="ab06" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在许多频道上，没有指示一个码字在哪里结束，下一个码字在哪里开始——这是我们问题的核心。我们得到一串字母，只有代码本身的属性允许我们确定是否可以恢复编码的信息。例如，我们可能需要解释以下符号串:</p><p id="6198" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi">1202120</p><p id="ceb0" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">如果从代码字构造的每个符号串(例如上面的串)可以被唯一地分解成恰好一个代码字序列，则代码是唯一可解码的。可以很容易地证明，所有字都具有固定长度的代码是唯一可解码的，但是我们对更困难的问题感兴趣——确定码字具有可变长度的代码是否是唯一可解码的。</p><p id="b061" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">让我们看几个可能在字符串 1202120 中产生的不同代码，来说明我们所说的“唯一可解码性”是什么意思</p><h2 id="1710" class="lp lq iq bd lr ls lt dn lu lv lw dp lx lb ly lz ma lf mb mc md lj me mf mg mh bi translated"><strong class="ak">唯一可解码的代码</strong></h2><p id="97cf" class="pw-post-body-paragraph ks kt iq ku b kv mi jr kx ky mj ju la lb mk ld le lf ml lh li lj mm ll lm ln ij bi translated">首先，假设 C = {120，21，20}。</p><p id="2767" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们可以通过找到共享第一个字母的码字来开始解码消息 1202120，在这种情况下，120 也以 1 开始，因此我们可以将该消息“因式分解”为 120.2120。</p><p id="9f99" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">接下来，我们移动到下一个符号 120。<strong class="ku ir"> 2 </strong> 120，并检查是否有任何码字以 2 开头——我们有两个码字，21 和 20，所以我们看看是否找到下一个符号的匹配:120。<strong class="ku ir"> 21 </strong> 20。</p><p id="aa1c" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">答对了。</p><p id="410e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">21 是一个有效的代码字，幸运的是，接下来的两个符号 20 也是。我们可以将此消息因式分解为 120.21.20。</p><h2 id="a097" class="lp lq iq bd lr ls lt dn lu lv lw dp lx lb ly lz ma lf mb mc md lj me mf mg mh bi translated"><strong class="ak">不可唯一解码的代码</strong></h2><p id="aed2" class="pw-post-body-paragraph ks kt iq ku b kv mi jr kx ky mj ju la lb mk ld le lf ml lh li lj mm ll lm ln ij bi translated">现在，假设 C = {02，12，120，21，20}。</p><p id="6481" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">使用与上面相同的过程，我们可以得到 1202120 的两种不同的因式分解:</p><p id="258d" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi">12.02.120</p><p id="9107" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi">120.21.20</p><p id="6183" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">因为我们的频道没有告诉我们一个单词在哪里结束，下一个单词在哪里开始，所以我们不知道该用哪个。在特定情况下，这可能是毁灭性的。例如，假设我们像这样编码重要的英语单词:</p><p id="7a86" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">02 →不是</p><p id="b4ee" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">12 →还没有</p><p id="b2b1" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">120 →清除</p><p id="f175" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">21 →至</p><p id="8ff4" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">20 →引爆</p><p id="786b" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们的信息可以被解读为:</p><p id="b75a" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">还不清楚</p><p id="b51a" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">或者</p><p id="67dc" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">准备引爆</p><p id="fc35" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我会让你的想象力来填补这个不幸的场景，既导致这种混乱，又在误译后展开。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/1b4e9b7e23ae2c0e298eff225e42a2a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*eY8LFikM_kN_oacqbYYSww.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">图片来自<a class="ae kr" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=417894" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="78e6" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">为了避免这样的歧义，我们需要确保我们使用的代码字集是唯一可解码的。为此，我们有<strong class="ku ir">萨丁纳斯-帕特森算法</strong>。</p><h2 id="748c" class="lp lq iq bd lr ls lt dn lu lv lw dp lx lb ly lz ma lf mb mc md lj me mf mg mh bi translated">定义 C(n)</h2><p id="b708" class="pw-post-body-paragraph ks kt iq ku b kv mi jr kx ky mj ju la lb mk ld le lf ml lh li lj mm ll lm ln ij bi translated">我将试图说明这个算法是最简单的，最不数学的英语，但是我们需要建立我们的方法来达到它。</p><p id="a69b" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">首先，提醒一下:</p><p id="fda4" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">C 是我们感兴趣测试的一组代码字。当我们对我们的信息进行编码时，这就是我们映射到的单词集。在我们上面的非唯一可解码的例子中，C 是{02，12，120，21，20}。我们让<strong class="ku ir"> C(0) </strong>等于<strong class="ku ir"> C </strong>，我们将归纳定义一个新集合的序列 C(1)，C(2)，…。请记住，C(n)并不代表<em class="lo"> C </em>作为<em class="lo"> n，</em>的函数，而是下标 C_n 的索引。括号是为了以后的可读性。</p><blockquote class="mo mp mq"><p id="6c8d" class="ks kt lo ku b kv kw jr kx ky kz ju la mr lc ld le ms lg lh li mt lk ll lm ln ij bi translated"><strong class="ku ir"> C(1) </strong>是一组<em class="iq">后缀</em>，可以加到 C 中的单词上，以便得到 C 中的另一个单词</p></blockquote><p id="1479" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">例如，0 可以加到 12 上得到 120，所以 0 在 C(1)中。事实上，这是唯一的<em class="lo">后缀</em>，它可以添加到 C 中的一个单词，以创建 C 中的另一个单词，因此 C(1) = {0}。下面的代码演示了这一点，它找到了所有可以附加到“a”以在集合{a，an，apple}中创建另一个单词的后缀。</p><pre class="kg kh ki kj gt mu mv mw mx aw my bi"><span id="c060" class="lp lq iq mv b gy mz na l nb nc">c = set(['a', 'an', 'apple'])<br/>c1 = set()</span><span id="bb5b" class="lp lq iq mv b gy nd na l nb nc">for u in c:<br/>    for v in c:<br/>        if len(u) &gt; len(v) and u.find(v) == 0:<br/>            c1.add(u[len(v):])<br/>c1<br/># {'n', 'pple'}</span></pre><p id="7c1b" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们在外循环中遍历<code class="fe ne nf ng mv b">c</code>中的单词，然后(在这种情况下)在内循环中再次遍历单词(当你到达那里时，与下面的例子进行比较)。在每一步，我们检查内部循环的单词是否是代码中的一个单词的开头，如果是，我们就给<code class="fe ne nf ng mv b">c1</code>加上后缀。</p><p id="18b4" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">现在我们已经定义了 C、C(0)和 C(1)，我们可以归纳定义 C(n)的更一般的定义:</p><p id="0d53" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">C(n)是所有后缀的集合，这些后缀可以被添加到 C 中的原始码字之一以创建 C(n-1)中的后缀，或者可以被添加到 C(n-1)中的后缀以创建原始码字之一。</p><p id="047f" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">继续我们的 C = {02，12，120，21，20}和 C(1) = {0}的例子，C(2)是可以添加到 C 中的单词以创建“0”的所有后缀的集合(没有后缀)，或者是可以添加到 C(1)中的后缀以从 C 创建单词的后缀的集合——唯一的元素是“2”，它可以添加到“0”以创建 02。这意味着 C(2) = {2}。</p><p id="8cb4" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">诸如此类。我们可以将它包装在一个函数中，该函数接受 C 和 n，生成 C(n-1)，并执行与上面的函数相同的比较。因此，我们有<code class="fe ne nf ng mv b">generate_cn(c, n)</code>，我们可以用它来计算 C(3)、C(4)、C(5)和 C(6):</p><pre class="kg kh ki kj gt mu mv mw mx aw my bi"><span id="6da0" class="lp lq iq mv b gy mz na l nb nc">def generate_cn(c, n):<br/>    if n == 0:<br/>        return set(c)<br/>    else:<br/>        # create a set to hold our new elements<br/>        cn = set()<br/>        <br/>        # generate c_(n-1)<br/>        cn_minus_1 = generate_cn(c, n-1)<br/>        <br/>        for u in c:<br/>            for v in cn_minus_1:<br/>                if (len(u) &gt; len(v)) and u.find(v) == 0:<br/>                    cn.add(u[len(v):])<br/>        for u in cn_minus_1:<br/>            for v in c:<br/>                if len(u) &gt; len(v) and u.find(v) == 0:<br/>                    cn.add(u[len(v):])<br/>        return cn</span><span id="d0c7" class="lp lq iq mv b gy nd na l nb nc">for i in [3, 4, 5, 6]:<br/>    print(generate_cn(set(['02', '12', '120', '20', '21']), i))</span><span id="94cd" class="lp lq iq mv b gy nd na l nb nc"># {'0', '1'}<br/># {'20', '2'}<br/># {'0', '1'}<br/># {'20', '2'}</span></pre><p id="3549" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">一般逻辑与我们检查的第一段代码相同，但是现在我们必须检查 c 和 c(n-1)中的前缀。</p><p id="6e17" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">注意在输出中，对于我们的非唯一代码，我们最终会遇到一个输出循环；这是我们在构建撒丁岛-帕特森算法语句所需的最终集合时需要小心处理的事情。</p><p id="0f74" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在继续之前，还值得注意的是，如果 C(n)为空，那么 C(n+1)也将为空。考虑下面的代码，它构造了 C(0)、C(1)和 C(2)，对于代码{'0 '、' 1 '、' 21'}:</p><pre class="kg kh ki kj gt mu mv mw mx aw my bi"><span id="c966" class="lp lq iq mv b gy mz na l nb nc">c = set(['0’, '1', '21'])</span><span id="d27b" class="lp lq iq mv b gy nd na l nb nc">for n in range(2):<br/>    print(‘C({})’.format(n), ‘\t’, generate_cn(c, n))</span><span id="34a1" class="lp lq iq mv b gy nd na l nb nc">#C(0) {‘0’, ‘1’, ‘21’}<br/>#C(1) set()<br/>#C(2) set()</span></pre><p id="f5f7" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在构造 C(1)时，没有后缀可以附加到 C(0)中的任何单词上，以从 C(1)创建另一个单词。因此，在 C(2)中我们没有什么可追加的。可以想象，这意味着 C(3)，C(4)，等等也将是空的。</p><h2 id="0ab6" class="lp lq iq bd lr ls lt dn lu lv lw dp lx lb ly lz ma lf mb mc md lj me mf mg mh bi translated">定义(C∞)</h2><p id="3580" class="pw-post-body-paragraph ks kt iq ku b kv mi jr kx ky mj ju la lb mk ld le lf ml lh li lj mm ll lm ln ij bi translated">理解撒丁纳斯-帕特森算法的最后一块拼图如下:</p><p id="2dbe" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir"> C(∞) </strong>:所有 C(n)的并集，其中 n ≥1。</p><blockquote class="mo mp mq"><p id="9e0f" class="ks kt lo ku b kv kw jr kx ky kz ju la mr lc ld le ms lg lh li mt lk ll lm ln ij bi translated">C(∞)可以被认为是所有可能的后缀的集合，这些后缀从在解码中产生歧义的原始码字中导出。</p></blockquote><p id="4fbc" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们将通过构造 C(1)、C(2)、C(3)等等来计算它，直到发生以下两种情况之一:</p><ol class=""><li id="ef6a" class="nh ni iq ku b kv kw ky kz lb nj lf nk lj nl ln nm nn no np bi translated">C(n)为空，在这种情况下 C(n+1)将为空，在这种情况下 C(n+2)将为空…以此类推。</li><li id="d7da" class="nh ni iq ku b kv nq ky nr lb ns lf nt lj nu ln nm nn no np bi translated">我们遇到一个 C(n ),它等于先前计算的某个 C(m ),这表明一个类似上面看到的循环。</li></ol><p id="a9fd" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">可以证明，其中一个最终会发生；直观来看，一个有限的源字母表，一个有限的 C，拆原字的方式也一定是有限的。</p><p id="bf7b" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">考虑到这些因素，我们有以下函数:</p><pre class="kg kh ki kj gt mu mv mw mx aw my bi"><span id="c0c4" class="lp lq iq mv b gy mz na l nb nc">def generate_c_infinity(c):<br/>    cs = []<br/>    c_infinity = set()<br/>    n = 1<br/>    cn = generate_cn(c, n)<br/>    print('c_{}'.format(n), cn)</span><span id="fa72" class="lp lq iq mv b gy nd na l nb nc">while len(cn) &gt; 0:<br/>        if cn in cs:<br/>            print('Cycle detected. Halting algorithm.')<br/>            break<br/>        else:<br/>            cs.append(cn)<br/>            c_infinity = c_infinity.union(cn)<br/>            n += 1<br/>            cn = generate_cn(c, n)<br/>            print('c_{}'.format(n), c_infinity)<br/>    return c_infinity<br/>    <br/>c = set(['02', '12', '120', '20', '21'])<br/>generate_c_infinity(c)</span></pre><p id="a9fc" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">为了检测循环，我们将每个 C(n)存储在一个 Cs 列表中。如果我们遇到一个以前见过的 C(n ),我们就中断循环，如果我们遇到任何空的 C(n ),循环前提条件就失败。</p><p id="e00f" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">考虑到这一点，加上我们工具包中的这些函数，我们有足够的拼图块来最终组合成唯一可解码性的必要和充分条件，这就是所谓的<a class="ae kr" href="https://en.wikipedia.org/wiki/Sardinas%E2%80%93Patterson_algorithm" rel="noopener ugc nofollow" target="_blank">萨丁纳斯-帕特森算法</a>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nw nx di ny bf nz"><div class="gh gi nv"><img src="../Images/e92f76a3dd95884019bae3aa96e47c83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N9iUGaT-NSSVo8vYHD2Cqg.jpeg"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">马库斯·温克勒在<a class="ae kr" href="https://unsplash.com/s/photos/jigsaw?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h2 id="dc76" class="lp lq iq bd lr ls lt dn lu lv lw dp lx lb ly lz ma lf mb mc md lj me mf mg mh bi translated">撒丁纳斯-帕特森算法</h2><p id="4238" class="pw-post-body-paragraph ks kt iq ku b kv mi jr kx ky mj ju la lb mk ld le lf ml lh li lj mm ll lm ln ij bi translated"><strong class="ku ir">一个码 C 是唯一可解码的当且仅当集合 C 和 C(∞)不相交。</strong></p><p id="f43b" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">稍微解释一下，记住每个 C(n)给我们一个可能产生歧义的后缀，就像我们在 not . yet . clear/clear . to . explode 例子中看到的那样。这个定理的另一种表述方式是</p><blockquote class="mo mp mq"><p id="7036" class="ks kt lo ku b kv kw jr kx ky kz ju la mr lc ld le ms lg lh li mt lk ll lm ln ij bi translated">"在原始代码字集中没有产生歧义的后缀."</p></blockquote><p id="d1c6" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">使用我最喜欢的 set 的属性<a class="ae kr" href="https://medium.com/swlh/a-python-style-set-in-simple-java-698977f1b5d0" rel="noopener">，将它实现为一个函数非常简单:</a></p><pre class="kg kh ki kj gt mu mv mw mx aw my bi"><span id="6a65" class="lp lq iq mv b gy mz na l nb nc">def sardinas_patterson_theorem(c):<br/>    """<br/>    Returns True if c is uniquely decodable<br/>    """<br/>    c_infinity = generate_c_infinity(c)<br/>    return len(c.intersection(c_infinity)) == 0</span><span id="06c5" class="lp lq iq mv b gy nd na l nb nc">def check_decodability(c):<br/>    if sardinas_patterson_theorem(c):<br/>        print(c, 'is uniquely decodable')<br/>    else:<br/>        print(c, 'is not uniquely decodable')</span><span id="ab1e" class="lp lq iq mv b gy nd na l nb nc">c = set(['02', '12', '120', '20', '21'])<br/>check_decodability(c)</span></pre><p id="2606" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们做到了！判定一组码字是否唯一可解码的一个充要条件。</p><p id="660e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我已经尽了最大努力让普通读者远离大部分数学符号，但是如果你有兴趣阅读更正式的(并从书中整理和稍微改写)定义，或者如果你有兴趣深入笔记本本身，你可以在<a class="ae kr" href="https://github.com/danhales/blog-sardinas-patterson" rel="noopener ugc nofollow" target="_blank"> my github </a>上找到它们。</p></div></div>    
</body>
</html>