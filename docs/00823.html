<html>
<head>
<title>Testing, profiling, and optimizing NLP models with Pytest, Cython, and spaCy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Pytest、Cython和spaCy测试、分析和优化NLP模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/testing-profiling-and-optimizing-nlp-models-with-pytest-cython-and-spacy-a78a8397f9f3?source=collection_archive---------17-----------------------#2020-01-23">https://towardsdatascience.com/testing-profiling-and-optimizing-nlp-models-with-pytest-cython-and-spacy-a78a8397f9f3?source=collection_archive---------17-----------------------#2020-01-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bf4c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">单元测试你的机器学习模型，剖析你的代码，充分利用c的自然语言处理速度。</h2></div><h2 id="ae87" class="ki kj it bd kk kl km dn kn ko kp dp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">目录:</h2><ul class=""><li id="5f34" class="le lf it lg b lh li lj lk kr ll kv lm kz ln lo lp lq lr ls bi translated"><a class="ae lt" rel="noopener" target="_blank" href="/testing-profiling-and-optimizing-nlp-models-with-pytest-cython-and-spacy-a78a8397f9f3#921a">为什么您应该关注分析NLP模型</a></li><li id="0474" class="le lf it lg b lh lu lj lv kr lw kv lx kz ly lo lp lq lr ls bi translated"><a class="ae lt" rel="noopener" target="_blank" href="/testing-profiling-and-optimizing-nlp-models-with-pytest-cython-and-spacy-a78a8397f9f3#6609">为什么spaCy比NLTK快</a></li><li id="2c1b" class="le lf it lg b lh lu lj lv kr lw kv lx kz ly lo lp lq lr ls bi translated"><a class="ae lt" rel="noopener" target="_blank" href="/testing-profiling-and-optimizing-nlp-models-with-pytest-cython-and-spacy-a78a8397f9f3#4ce4">当你调用nlp(doc)时，到底发生了什么？</a></li><li id="64e0" class="le lf it lg b lh lu lj lv kr lw kv lx kz ly lo lp lq lr ls bi translated"><a class="ae lt" rel="noopener" target="_blank" href="/testing-profiling-and-optimizing-nlp-models-with-pytest-cython-and-spacy-a78a8397f9f3#1892">设置模型测试</a></li><li id="8aeb" class="le lf it lg b lh lu lj lv kr lw kv lx kz ly lo lp lq lr ls bi translated"><a class="ae lt" rel="noopener" target="_blank" href="/testing-profiling-and-optimizing-nlp-models-with-pytest-cython-and-spacy-a78a8397f9f3#38bb"> <strong class="lg iu">判决结果:哪一方因速度而胜</strong> </a></li><li id="2e4b" class="le lf it lg b lh lu lj lv kr lw kv lx kz ly lo lp lq lr ls bi translated"><a class="ae lt" rel="noopener" target="_blank" href="/testing-profiling-and-optimizing-nlp-models-with-pytest-cython-and-spacy-a78a8397f9f3#8b36">编写文本处理管道的最佳实践</a></li><li id="bd0e" class="le lf it lg b lh lu lj lv kr lw kv lx kz ly lo lp lq lr ls bi translated"><a class="ae lt" rel="noopener" target="_blank" href="/testing-profiling-and-optimizing-nlp-models-with-pytest-cython-and-spacy-a78a8397f9f3#647d">NLP优化的建议工作流程</a></li><li id="3ef9" class="le lf it lg b lh lu lj lv kr lw kv lx kz ly lo lp lq lr ls bi translated"><a class="ae lt" rel="noopener" target="_blank" href="/testing-profiling-and-optimizing-nlp-models-with-pytest-cython-and-spacy-a78a8397f9f3#373e">资源和代码库</a></li></ul></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><p id="9bd5" class="pw-post-body-paragraph mg mh it lg b lh mi ju mj lj mk jx ml kr mm mn mo kv mp mq mr kz ms mt mu lo im bi translated">我读了一篇博文<a class="ae lt" href="https://tahirnaeem.net/performance-comparison-of-nlp-libraries-in-text-tokenization" rel="noopener ugc nofollow" target="_blank">声称已经为自然语言数据预处理分析了spaCy和NLTK，并且发现NLTK要快得多。</a></p><figure class="mv mw mx my gt mz"><div class="bz fp l di"><div class="na nb l"/></div><p class="nc nd gj gh gi ne nf bd b be z dk translated">嗯(通过<a class="ae lt" href="https://giphy.com/gifs/latelateshow-what-confused-5t9wJjyHAOxvnxcPNk" rel="noopener ugc nofollow" target="_blank"> giphy </a>，@ TheLateShow)</p></figure><p id="bfbb" class="pw-post-body-paragraph mg mh it lg b lh mi ju mj lj mk jx ml kr mm mn mo kv mp mq mr kz ms mt mu lo im bi translated">什么？</p><p id="1d1f" class="pw-post-body-paragraph mg mh it lg b lh mi ju mj lj mk jx ml kr mm mn mo kv mp mq mr kz ms mt mu lo im bi translated">NLTK是自然语言处理工具包中的吉普大切诺基:它很大，已经存在很长时间了，它有很大的动力，但它很慢，很费油。</p><p id="8c53" class="pw-post-body-paragraph mg mh it lg b lh mi ju mj lj mk jx ml kr mm mn mo kv mp mq mr kz ms mt mu lo im bi translated">SpaCy 是兰博基尼Aventador。它可能不是一个有着所有花里胡哨的坦克，但它很光滑，只剩下裸露的金属。它做什么，它就做<em class="ng">快</em>。它的高马力也带来了风险(和乐趣),即在蜿蜒的道路上加速转弯时转弯过猛，偏离道路。</p><figure class="mv mw mx my gt mz"><div class="bz fp l di"><div class="nh nb l"/></div><p class="nc nd gj gh gi ne nf bd b be z dk translated">这个，但是用向量(via <a class="ae lt" href="https://giphy.com/gifs/3ohc1eTesPXxSRVwNq/html5" rel="noopener ugc nofollow" target="_blank"> giphy </a>，@ thegrandtour)</p></figure><p id="554a" class="pw-post-body-paragraph mg mh it lg b lh mi ju mj lj mk jx ml kr mm mn mo kv mp mq mr kz ms mt mu lo im bi translated">所以，这个说法让我觉得很奇怪:</p><blockquote class="ni nj nk"><p id="4771" class="mg mh ng lg b lh mi ju mj lj mk jx ml nl mm mn mo nm mp mq mr nn ms mt mu lo im bi translated">Spacy比NLTK慢多了。NLTK只用了2秒钟就标记了7 MB的文本样本，而Spacy用了3分钟！</p></blockquote><p id="882c" class="pw-post-body-paragraph mg mh it lg b lh mi ju mj lj mk jx ml kr mm mn mo kv mp mq mr kz ms mt mu lo im bi translated">如果您正确地编写了管道，并且您的硬件有足够的内存，这是不可能发生的。</p><h1 id="921a" class="no kj it bd kk np nq nr kn ns nt nu kq jz nv ka ku kc nw kd ky kf nx kg lc ny bi translated"><strong class="ak">我为什么要关心？</strong></h1><p id="4a9b" class="pw-post-body-paragraph mg mh it lg b lh li ju mj lj lk jx ml kr nz mn mo kv oa mq mr kz ob mt mu lo im bi translated">我主要从事研究工程——我的工作是制作模型，而不是构建软件架构。那么，如果你只想构建聊天机器人和搜索引擎，为什么要关心你的代码性能呢？</p><p id="cf8f" class="pw-post-body-paragraph mg mh it lg b lh mi ju mj lj mk jx ml kr mm mn mo kv mp mq mr kz ms mt mu lo im bi translated">如果你对构建数据的最佳模型感兴趣，你不能脱离代码质量来考虑机器学习模型。</p><ul class=""><li id="045e" class="le lf it lg b lh mi lj mk kr oc kv od kz oe lo lp lq lr ls bi translated">大规模的NLP语料库意味着，除非你尝试在空间和时间上优化你的代码，否则你将在算法和工具上受到限制。</li><li id="b5a0" class="le lf it lg b lh lu lj lv kr lw kv lx kz ly lo lp lq lr ls bi translated">不写测试意味着你不知道什么变化导致了什么错误——或者更糟，在你的实体模型中可能有你甚至没有意识到的问题，并且永远不会发现。(你是否曾经编写了一个ML函数或类，却发现它从未被调用过？)</li><li id="4bdc" class="le lf it lg b lh lu lj lv kr lw kv lx kz ly lo lp lq lr ls bi translated">理解您正在使用的库不仅对代码性能至关重要，而且对深入理解您正在构建的模型的实质也很重要。你将加速你的知识从简单的导入scikit-learn和装配一个估计器到真正的搜索支持NLP的算法。</li><li id="8e3f" class="le lf it lg b lh lu lj lv kr lw kv lx kz ly lo lp lq lr ls bi translated">良好的测试和深思熟虑的代码对于可重复的研究至关重要。</li><li id="84ea" class="le lf it lg b lh lu lj lv kr lw kv lx kz ly lo lp lq lr ls bi translated">如果你是为了生产而写代码，而不仅仅是为了学术目的，你绝对需要考虑它在现实世界中如何运行。</li></ul><h1 id="6609" class="no kj it bd kk np nq nr kn ns nt nu kq jz nv ka ku kc nw kd ky kf nx kg lc ny bi translated">为什么spaCy这么快？</h1><p id="4a27" class="pw-post-body-paragraph mg mh it lg b lh li ju mj lj lk jx ml kr nz mn mo kv oa mq mr kz ob mt mu lo im bi translated">SpaCy的喷漆工作是Python，但引擎是Cython。<a class="ae lt" href="https://cython.org" rel="noopener ugc nofollow" target="_blank"> Cython </a>就像一种克里奥尔语言——一部分是Python，一部分是c。它是Python的超集(所有有效的Python都是有效的Cython)，但它包含了来自c的更快、更复杂的特性</p><p id="6fe8" class="pw-post-body-paragraph mg mh it lg b lh mi ju mj lj mk jx ml kr mm mn mo kv mp mq mr kz ms mt mu lo im bi translated">对于某些用例，Cython是一个很好的速度提升工具——例如，计算大量数字结果，其结果取决于一系列if语句。通常你会使用numpy来加速计算，但是numpy擅长于<em class="ng">矢量化</em>代码——对每个元素做同样的事情。当我们想要对每个元素做不同的事情时，Cython允许我们使用相同的c优化，但是增加了逻辑复杂性。</p><p id="b945" class="pw-post-body-paragraph mg mh it lg b lh mi ju mj lj mk jx ml kr mm mn mo kv mp mq mr kz ms mt mu lo im bi translated">SpaCy广泛使用了开箱即用的cythonization，与许多其他Python库相比，它是一个非常快速的NLP框架。</p><h1 id="4ce4" class="no kj it bd kk np nq nr kn ns nt nu kq jz nv ka ku kc nw kd ky kf nx kg lc ny bi translated">不理解你的算法的陷阱</h1><p id="abad" class="pw-post-body-paragraph mg mh it lg b lh li ju mj lj lk jx ml kr nz mn mo kv oa mq mr kz ob mt mu lo im bi translated">让我们回到那个认为spaCy比NLTK慢的博客。</p><p id="3923" class="pw-post-body-paragraph mg mh it lg b lh mi ju mj lj mk jx ml kr mm mn mo kv mp mq mr kz ms mt mu lo im bi translated">当我使用line_profiler在相同的文档上运行我的NLTK和spaCy文本清理器版本时，采用了苹果对苹果的比较，<strong class="lg iu"> NLTK花了spaCy 5.5倍的时间来做基本上相似的工作。</strong></p><blockquote class="of"><p id="9450" class="og oh it bd oi oj ok ol om on oo lo dk translated">TL；DR: NLTK在相同数据上的可比NLP管道中使用时比spaCy慢5.5倍。</p></blockquote><p id="caf3" class="pw-post-body-paragraph mg mh it lg b lh op ju mj lj oq jx ml kr or mn mo kv os mq mr kz ot mt mu lo im bi translated">我的代码有什么不同？首先，我从里到外研究了这些系统的架构，包括:</p><ul class=""><li id="6c56" class="le lf it lg b lh mi lj mk kr oc kv od kz oe lo lp lq lr ls bi translated">他们在做什么工作，什么时候做</li><li id="7632" class="le lf it lg b lh lu lj lv kr lw kv lx kz ly lo lp lq lr ls bi translated">他们期望并返回什么数据类型</li><li id="e8cc" class="le lf it lg b lh lu lj lv kr lw kv lx kz ly lo lp lq lr ls bi translated">功能的控制流</li></ul><p id="461d" class="pw-post-body-paragraph mg mh it lg b lh mi ju mj lj mk jx ml kr mm mn mo kv mp mq mr kz ms mt mu lo im bi translated">为了进行有意义的比较，您需要知道spaCy在被引用的代码中比NLTK做了更多的<em class="ng"> lot </em>。默认情况下，spaCy管道包括标记化、词汇化、词性标注、依存解析和命名实体识别。每次您调用<code class="fe ou ov ow ox b">nlp(doc)</code>时，它都会完成所有这些(甚至更多)。</p><figure class="mv mw mx my gt mz gh gi paragraph-image"><div role="button" tabindex="0" class="oz pa di pb bf pc"><div class="gh gi oy"><img src="../Images/e69dce70c74a89c79f785106df18dfcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H-acRQvDtRkWVt5GVctDUQ.png"/></div></div><p class="nc nd gj gh gi ne nf bd b be z dk translated">spaCy的词性标注和依存解析功能示例</p></figure><p id="a625" class="pw-post-body-paragraph mg mh it lg b lh mi ju mj lj mk jx ml kr mm mn mo kv mp mq mr kz ms mt mu lo im bi translated">相比之下，NLTK(在引用的代码中)只是<em class="ng">标记和小写的语料库。</em></p><p id="d87a" class="pw-post-body-paragraph mg mh it lg b lh mi ju mj lj mk jx ml kr mm mn mo kv mp mq mr kz ms mt mu lo im bi translated">将这两条管道进行对比是荒谬的。</p><p id="37d7" class="pw-post-body-paragraph mg mh it lg b lh mi ju mj lj mk jx ml kr mm mn mo kv mp mq mr kz ms mt mu lo im bi translated">我们需要一个更好的框架:</p><ul class=""><li id="6953" class="le lf it lg b lh mi lj mk kr oc kv od kz oe lo lp lq lr ls bi translated">我暂时禁用了spaCy管道中的依赖解析和命名实体识别，因为NLTK不做这些事情。</li><li id="dbc1" class="le lf it lg b lh lu lj lv kr lw kv lx kz ly lo lp lq lr ls bi translated">我让NLTK做了词性标注和词汇化，让它更接近spaCy的性能。</li></ul><p id="f504" class="pw-post-body-paragraph mg mh it lg b lh mi ju mj lj mk jx ml kr mm mn mo kv mp mq mr kz ms mt mu lo im bi translated">这仍然不是完美的一对一比较，但已经非常接近了。</p><h2 id="1892" class="ki kj it bd kk kl km dn kn ko kp dp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">两个麻雀的故事</h2><p id="879b" class="pw-post-body-paragraph mg mh it lg b lh li ju mj lj lk jx ml kr nz mn mo kv oa mq mr kz ob mt mu lo im bi translated">我写了两个版本的spaCy pipeline，来反映我是如何看到人们在野外使用<code class="fe ou ov ow ox b">nlp.pipe</code>的。第一个是<code class="fe ou ov ow ox b">list(nlp.pipe(docs))</code>。第二种更有效的方法是使用<code class="fe ou ov ow ox b">nlp.pipe(docs)</code>作为生成器对象。</p><div class="pf pg gp gr ph pi"><a href="https://github.com/lorarjohns/nlp_profiling/blob/master/scripts/profiling_spacy.py" rel="noopener  ugc nofollow" target="_blank"><div class="pj ab fo"><div class="pk ab pl cl cj pm"><h2 class="bd iu gy z fp pn fr fs po fu fw is bi translated">lorarjohns/nlp_profiling</h2><div class="pp l"><h3 class="bd b gy z fp pn fr fs po fu fw dk translated">用于相互比较管道的脚本。</h3></div><div class="pq l"><p class="bd b dl z fp pn fr fs po fu fw dk translated">github.com</p></div></div><div class="pr l"><div class="ps l pt pu pv pr pw pd pi"/></div></div></a></div><p id="a9b4" class="pw-post-body-paragraph mg mh it lg b lh mi ju mj lj mk jx ml kr mm mn mo kv mp mq mr kz ms mt mu lo im bi translated">这种区别很重要，因为与Python列表不同，<a class="ae lt" href="https://realpython.com/introduction-to-python-generators/" rel="noopener ugc nofollow" target="_blank">生成器对象</a>不会同时在内存中保存整个语料库。这意味着您可以迭代地修改、提取或写入数据库的内容。在NLP中，这种情况经常出现，因为语料库通常非常大——大到无法一次保存在内存中。</p><h2 id="38bb" class="ki kj it bd kk kl km dn kn ko kp dp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">结论是什么？</h2><figure class="mv mw mx my gt mz"><div class="bz fp l di"><div class="px nb l"/></div><p class="nc nd gj gh gi ne nf bd b be z dk translated">cProfile(戏剧化)(通过<a class="ae lt" href="https://giphy.com/gifs/iJDLBX5GY8niCpZYkR/html5" rel="noopener ugc nofollow" target="_blank"> giphy </a>，@ f1)</p></figure><p id="4f7e" class="pw-post-body-paragraph mg mh it lg b lh mi ju mj lj mk jx ml kr mm mn mo kv mp mq mr kz ms mt mu lo im bi translated">在同一个Reddit语料库(n=15000)上测试我的三个管道(使用NLTK、spaCy-as-list和spaCy-as-generator)，下面是line_profiler的结果:</p><ul class=""><li id="a345" class="le lf it lg b lh mi lj mk kr oc kv od kz oe lo lp lq lr ls bi translated">列表空间:总时间= 64.260秒</li><li id="694a" class="le lf it lg b lh lu lj lv kr lw kv lx kz ly lo lp lq lr ls bi translated">发电机空间:总时间= 60.356秒</li><li id="6824" class="le lf it lg b lh lu lj lv kr lw kv lx kz ly lo lp lq lr ls bi translated">NLTK:总时间= 334.677秒</li></ul><div class="pf pg gp gr ph pi"><a href="https://github.com/lorarjohns/nlp_profiling/tree/master/profiling" rel="noopener  ugc nofollow" target="_blank"><div class="pj ab fo"><div class="pk ab pl cl cj pm"><h2 class="bd iu gy z fp pn fr fs po fu fw is bi translated">lorarjohns/nlp_profiling</h2><div class="pq l"><p class="bd b dl z fp pn fr fs po fu fw dk translated">分析的结果可以在这里以*_reddit_2.txt的形式找到</p></div></div><div class="pr l"><div class="py l pt pu pv pr pw pd pi"/></div></div></a></div><blockquote class="of"><p id="a647" class="og oh it bd oi oj pz qa qb qc qd lo dk translated">使用spaCy，甚至不用编写自己的Cython，就可以将代码速度提高5倍以上。</p></blockquote><p id="b725" class="pw-post-body-paragraph mg mh it lg b lh op ju mj lj oq jx ml kr or mn mo kv os mq mr kz ot mt mu lo im bi translated">这是有道理的——NLTK没有用Cython进行优化，当它标记和lemmatizes令牌时，它使用了比spaCy更耗时的操作。</p><h1 id="8b36" class="no kj it bd kk np nq nr kn ns nt nu kq jz nv ka ku kc nw kd ky kf nx kg lc ny bi translated">编写文本预处理管道的最好方法是什么？</h1><p id="71c5" class="pw-post-body-paragraph mg mh it lg b lh li ju mj lj lk jx ml kr nz mn mo kv oa mq mr kz ob mt mu lo im bi translated">与任何代码一样，如果你不理解spaCy <em class="ng">的数据结构以及如何负责任地使用它们，spaCy<em class="ng">将会变得很慢。</em></em></p><p id="50e1" class="pw-post-body-paragraph mg mh it lg b lh mi ju mj lj mk jx ml kr mm mn mo kv mp mq mr kz ms mt mu lo im bi translated"><em class="ng">阅读源代码。</em> SpaCy依靠两个主要的东西来快速运行:Cython的c内核和Python生成器。因此，它使用复杂的类和数据管道，这意味着它的对象的类型和方法并不总是显而易见的。</p><p id="b5be" class="pw-post-body-paragraph mg mh it lg b lh mi ju mj lj mk jx ml kr mm mn mo kv mp mq mr kz ms mt mu lo im bi translated">例如，当您在文本上调用<code class="fe ou ov ow ox b">nlp</code>来获取<a class="ae lt" href="https://github.com/explosion/spaCy/blob/master/spacy/tokens/doc.pyx" rel="noopener ugc nofollow" target="_blank">一个Doc对象</a>时，spaCy会生成c代码来处理您的数据。虽然您可以使用括号符号等普通命令进行索引以与结果文档进行交互，但它们的工作方式与基本Python不同。更确切地说，Doc类重载了Python操作符，让您可以像与Python对象一样与结构进行交互。</p><figure class="mv mw mx my gt mz gh gi paragraph-image"><div role="button" tabindex="0" class="oz pa di pb bf pc"><div class="gh gi qe"><img src="../Images/85380d67ce6704bc0af4586eff454039.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zlXpa0-5iMSG-KJ9GWjNOg.png"/></div></div><p class="nc nd gj gh gi ne nf bd b be z dk translated">Doc类中的一个c函数</p></figure><p id="f296" class="pw-post-body-paragraph mg mh it lg b lh mi ju mj lj mk jx ml kr mm mn mo kv mp mq mr kz ms mt mu lo im bi translated">真正了解这一点的唯一方法是阅读源代码。文档不会为你解释清楚。除了通过Spacy  教程学习<a class="ae lt" href="https://course.spacy.io/" rel="noopener ugc nofollow" target="_blank"> <em class="ng">高级NLP之外，没有其他方法可以真正掌握诀窍。</em></a></p><p id="0762" class="pw-post-body-paragraph mg mh it lg b lh mi ju mj lj mk jx ml kr mm mn mo kv mp mq mr kz ms mt mu lo im bi translated">轻松阅读源代码将极大地提高您的编程素养和数据管道。</p><p id="da27" class="pw-post-body-paragraph mg mh it lg b lh mi ju mj lj mk jx ml kr mm mn mo kv mp mq mr kz ms mt mu lo im bi translated"><em class="ng">有计划。在开始编写之前，确保你已经用涂鸦和伪代码概述了管道的步骤。有一个深思熟虑的计划将帮助你思考如何最好地将不同的功能联系在一起。您将看到数据的效率，将函数和变量组合在一起以加快速度的方法，以及如何转换数据以方便流动。</em></p><h1 id="647d" class="no kj it bd kk np nq nr kn ns nt nu kq jz nv ka ku kc nw kd ky kf nx kg lc ny bi translated">自然语言处理优化的工作流程</h1><ol class=""><li id="82d8" class="le lf it lg b lh li lj lk kr ll kv lm kz ln lo qf lq lr ls bi translated"><strong class="lg iu">解决问题不考虑最优性。让它工作起来。</strong></li><li id="ec9d" class="le lf it lg b lh lu lj lv kr lw kv lx kz ly lo qf lq lr ls bi translated">在你开始改变你的代码之前，准备好工作测试。拥有测试意味着你可以改变架构的重要部分，而不用担心引入新的神秘错误。测试并不是很多数据科学家预先考虑的事情，而且考虑如何为NLP机器学习模型编写测试并不总是容易的。但是至少在数据预处理方面，它们可以帮助您避免预处理不好的文本的“垃圾输入，垃圾输出”现象。一些例子包括:</li></ol><ul class=""><li id="ee1a" class="le lf it lg b lh mi lj mk kr oc kv od kz oe lo lp lq lr ls bi translated"><em class="ng">为你的正则表达式</em>(例如，你用来标记句子的表达式)编写单元测试，确保它们只匹配你想要的</li><li id="18b7" class="le lf it lg b lh lu lj lv kr lw kv lx kz ly lo lp lq lr ls bi translated">检查你的函数是否返回正确的数据类型。返回值应该是数字数组、字典、字符串、列表还是列表列表？测试一下。</li><li id="560b" class="le lf it lg b lh lu lj lv kr lw kv lx kz ly lo lp lq lr ls bi translated"><em class="ng">检查你所有的类和函数是否真的按照你想要的方式被调用。</em>发现重要的嵌入模型或特征工程组件得到了错误的输入(或者更糟，根本没有被调用)一点都不好玩。</li></ul><p id="297b" class="pw-post-body-paragraph mg mh it lg b lh mi ju mj lj mk jx ml kr mm mn mo kv mp mq mr kz ms mt mu lo im bi translated">但是，在开始cythonizing之前，请确保您已经剖析了代码并清理了Python。甚至像gensim这样的纯Python库也可以非常快，而且内存效率高，因为它们严格地收紧了数据结构和管道。</p><ol class=""><li id="0ea2" class="le lf it lg b lh mi lj mk kr oc kv od kz oe lo qf lq lr ls bi translated"><strong class="lg iu">持续地、可重复地测量代码的速度和性能。你需要一个基线来知道你是否在改善(或者让事情变得更糟)。<a class="ae lt" href="https://github.com/rkern/line_profiler" rel="noopener ugc nofollow" target="_blank">行分析器</a>、<a class="ae lt" href="https://docs.python.org/2/library/profile.html" rel="noopener ugc nofollow" target="_blank"> cProfile </a>和<a class="ae lt" href="https://github.com/benfred/py-spy" rel="noopener ugc nofollow" target="_blank"> py-spy </a>都会生成记录脚本性能的文件，您可以阅读、引用和比较这些文件。</strong></li><li id="5b7e" class="le lf it lg b lh lu lj lv kr lw kv lx kz ly lo qf lq lr ls bi translated">确保你使用了正确的数据结构和函数调用。在你确定你的Python已经尽可能快之前，不要为Cython费心。有时候，Cython并不是合适的工具，对Python代码的微小修改会比cythonization产生更大的改进。正如我们所见，用列表替换生成器是一个简单的瓶颈修复方法。</li><li id="d380" class="le lf it lg b lh lu lj lv kr lw kv lx kz ly lo qf lq lr ls bi translated"><strong class="lg iu">检查你的函数的控制流。</strong>逐行分析器在这里真的很有帮助。在编写比较时，我注意到line_profiler说我的spaCy函数在文本清理函数的NLTK部分花费了时间。我已经编写了代码，以便在我检查<code class="fe ou ov ow ox b">spacy=True</code>参数是真还是假之前定义只与NLTK相关的内部函数。将该代码移动到if-else语句的NLTK部分中，可以阻止我的spacy模型每次都运行该(不相关的)代码块。</li><li id="3c2f" class="le lf it lg b lh lu lj lv kr lw kv lx kz ly lo qf lq lr ls bi translated">编写好的测试。考虑你的函数需要产生什么样的输出来通过你的测试，几乎会迫使你自动去做1-3。</li></ol><div class="pf pg gp gr ph pi"><a href="https://github.com/lorarjohns/nlp_profiling/blob/master/scripts/test_profiling_spacy.py" rel="noopener  ugc nofollow" target="_blank"><div class="pj ab fo"><div class="pk ab pl cl cj pm"><h2 class="bd iu gy z fp pn fr fs po fu fw is bi translated">lorarjohns/nlp_profiling</h2><div class="pp l"><h3 class="bd b gy z fp pn fr fs po fu fw dk translated">使用pytest对管道进行的一些测试</h3></div><div class="pq l"><p class="bd b dl z fp pn fr fs po fu fw dk translated">github.com</p></div></div><div class="pr l"><div class="qg l pt pu pv pr pw pd pi"/></div></div></a></div><h1 id="edae" class="no kj it bd kk np nq nr kn ns nt nu kq jz nv ka ku kc nw kd ky kf nx kg lc ny bi translated">更好的代码，更好的科学</h1><p id="2950" class="pw-post-body-paragraph mg mh it lg b lh li ju mj lj lk jx ml kr nz mn mo kv oa mq mr kz ob mt mu lo im bi translated">以这种方式思考需要对您的模型进行更多的架构设计，但是为了避免等待半个小时来处理您的文档，这是值得的。花时间仔细考虑模型的逻辑结构，编写测试，并思考分析器的输出，以避免以即时满足的名义进行草率的科学研究。任何人都可以制造一袋单词；NLP的精妙之处在于细节工作。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="373e" class="no kj it bd kk np qh nr kn ns qi nu kq jz qj ka ku kc qk kd ky kf ql kg lc ny bi translated"><strong class="ak">资源:</strong></h1><ul class=""><li id="38fd" class="le lf it lg b lh li lj lk kr ll kv lm kz ln lo lp lq lr ls bi translated"><a class="ae lt" href="https://github.com/lorarjohns/nlp_profiling" rel="noopener ugc nofollow" target="_blank">我对这篇博文</a>的完整回购，附带理解spaCy内部结构和编写自己的Cython的额外代码</li></ul><div class="pf pg gp gr ph pi"><a href="https://github.com/lorarjohns/nlp_profiling" rel="noopener  ugc nofollow" target="_blank"><div class="pj ab fo"><div class="pk ab pl cl cj pm"><h2 class="bd iu gy z fp pn fr fs po fu fw is bi translated">lorarjohns/nlp_profiling</h2><div class="pq l"><p class="bd b dl z fp pn fr fs po fu fw dk translated">github.com</p></div></div><div class="pr l"><div class="qm l pt pu pv pr pw pd pi"/></div></div></a></div><ul class=""><li id="24f9" class="le lf it lg b lh mi lj mk kr oc kv od kz oe lo lp lq lr ls bi translated"><a class="ae lt" href="https://course.spacy.io/" rel="noopener ugc nofollow" target="_blank"> <em class="ng">带空间的高级NLP</em></a>，官方空间教程</li><li id="7176" class="le lf it lg b lh lu lj lv kr lw kv lx kz ly lo lp lq lr ls bi translated"><a class="ae lt" href="http://nltk.org" rel="noopener ugc nofollow" target="_blank"> NLTK </a></li><li id="820e" class="le lf it lg b lh lu lj lv kr lw kv lx kz ly lo lp lq lr ls bi translated"><a class="ae lt" href="https://spacy.io" rel="noopener ugc nofollow" target="_blank">空间</a> ( <a class="ae lt" href="https://github.com/explosion/spaCy/blob/master/spacy" rel="noopener ugc nofollow" target="_blank">源代码</a>)</li><li id="ed2d" class="le lf it lg b lh lu lj lv kr lw kv lx kz ly lo lp lq lr ls bi translated"><a class="ae lt" href="https://docs.pytest.org/en/latest/getting-started.html" rel="noopener ugc nofollow" target="_blank"> pytest </a></li><li id="7d82" class="le lf it lg b lh lu lj lv kr lw kv lx kz ly lo lp lq lr ls bi translated"><a class="ae lt" href="https://github.com/rkern/line_profiler" rel="noopener ugc nofollow" target="_blank">线路剖析器</a>、<a class="ae lt" href="https://docs.python.org/2/library/profile.html" rel="noopener ugc nofollow" target="_blank"> cProfile </a>和<a class="ae lt" href="https://github.com/benfred/py-spy" rel="noopener ugc nofollow" target="_blank"> py-spy </a></li><li id="fb8b" class="le lf it lg b lh lu lj lv kr lw kv lx kz ly lo lp lq lr ls bi translated">Python <a class="ae lt" href="https://realpython.com/introduction-to-python-generators/" rel="noopener ugc nofollow" target="_blank">生成器对象</a>教程</li><li id="6630" class="le lf it lg b lh lu lj lv kr lw kv lx kz ly lo lp lq lr ls bi translated"><a class="ae lt" href="https://cython.org" rel="noopener ugc nofollow" target="_blank"> Cython </a></li></ul></div></div>    
</body>
</html>